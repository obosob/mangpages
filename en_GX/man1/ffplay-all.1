.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFPLAY-ALL 1"
.TH FFPLAY-ALL 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffplay \- FFplay media playa
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
ffplay [\fIoptions\fR] [\fIinput_file\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
FFplay be a straight-up simple n' portable media playa rockin tha FFmpeg
libraries n' tha \s-1SDL\s0 library. Well shiiiit, it is mostly used as a testbed fo' the
various FFmpeg APIs.
.SH "OPTIONS"
.IX Header "OPTIONS"
All tha numerical options, if not specified otherwise, accept a string
representin a number as input, which may be followed by one of tha \s-1SI\s0
unit prefixes, fo' example: 'K', 'M', or 'G'.
.PP
If 'i' be appended ta tha \s-1SI\s0 unit prefix, tha complete prefix will be
interpreted as a unit prefix fo' binary multiplies, which is based on
powerz of 1024 instead of powerz of 1000 fo' realz. Appendin 'B' ta tha \s-1SI\s0 unit
prefix multiplies tha value by 8. This allows using, fo' example:
\&'\s-1KB\s0', 'MiB', 'G' n' 'B' as number suffixes.
.PP
Options which do not take arguments is boolean options, n' set the
correspondin value ta true. They can be set ta false by prefixing
the option name wit \*(L"no\*(R". For example rockin \*(L"\-nofoo\*(R"
will set tha boolean option wit name \*(L"foo\*(R" ta false.
.SS "Stream specifiers"
.IX Subsection "Stream specifiers"
Some options is applied per-stream, e.g. bitrate or codec. Right back up in yo muthafuckin ass. Stream specifiers
are used ta precisely specify which stream(s) a given option belongs to.
.PP
A stream specifier be a strang generally appended ta tha option name and
separated from it by a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch. E.g. \f(CW\*(C`\-codec:a:1 ac3\*(C'\fR gotz nuff the
\&\f(CW\*(C`a:1\*(C'\fR stream specifier, which matches tha second audio stream. Therefore, it
would select tha ac3 codec fo' tha second audio stream.
.PP
A stream specifier can match nuff muthafuckin streams, so dat tha option be applied ta all
of em. E.g. tha stream specifier up in \f(CW\*(C`\-b:a 128k\*(C'\fR matches all audio
streams.
.PP
An empty stream specifier matches all streams. For example, \f(CW\*(C`\-codec copy\*(C'\fR
or \f(CW\*(C`\-codec: copy\*(C'\fR would copy all tha streams without reencoding.
.PP
Possible formz of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches tha stream wit dis index. E.g. \f(CW\*(C`\-threads:1 4\*(C'\fR would set the
thread count fo' tha second stream ta 4.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of following: 'v' fo' vizzle, 'a' fo' audio, 's' fo' subtitle,
\&'d' fo' data, n' 't' fo' attachments, n' you can put dat on yo' toast. If \fIstream_index\fR is given, then it matches
stream number \fIstream_index\fR of dis type. Otherwise, it matches all
streamz of dis type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then it matches tha stream wit number \fIstream_index\fR
in tha program wit tha id \fIprogram_id\fR. Otherwise, it matches all streams up in the
program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches tha stream by a gangbangin' format-specific \s-1ID.\s0
.SS "Generic options"
.IX Subsection "Generic options"
These options is shared amongst tha ff* tools.
.IP "\fB\-L\fR" 4
.IX Item "-L"
Show license.
.IP "\fB\-h, \-?, \-help, \-\-help [\fR\fIarg\fR\fB]\fR" 4
.IX Item "-h, -?, -help, --help [arg]"
Show help fo' realz. An optionizzle parameta may be specified ta print help on some specific
item. If no argument is specified, only basic (non advanced) tool
options is shown.
.Sp
Possible jointz of \fIarg\fR are:
.RS 4
.IP "\fBlong\fR" 4
.IX Item "long"
Print advanced tool options up in addizzle ta tha basic tool options.
.IP "\fBfull\fR" 4
.IX Item "full"
Print complete list of options, includin shared n' private options
for encoders, decoders, demuxers, muxers, filters, etc.
.IP "\fBdecoder=\fR\fIdecoder_name\fR" 4
.IX Item "decoder=decoder_name"
Print detailed shiznit bout tha decoder named \fIdecoder_name\fR. Use the
\&\fB\-decoders\fR option ta git a list of all decoders.
.IP "\fBencoder=\fR\fIencoder_name\fR" 4
.IX Item "encoder=encoder_name"
Print detailed shiznit bout tha encoder named \fIencoder_name\fR. Use the
\&\fB\-encoders\fR option ta git a list of all encoders.
.IP "\fBdemuxer=\fR\fIdemuxer_name\fR" 4
.IX Item "demuxer=demuxer_name"
Print detailed shiznit bout tha demuxer named \fIdemuxer_name\fR. Use the
\&\fB\-formats\fR option ta git a list of all demuxers n' muxers.
.IP "\fBmuxer=\fR\fImuxer_name\fR" 4
.IX Item "muxer=muxer_name"
Print detailed shiznit bout tha muxer named \fImuxer_name\fR. Use the
\&\fB\-formats\fR option ta git a list of all muxers n' demuxers.
.IP "\fBfilter=\fR\fIfilter_name\fR" 4
.IX Item "filter=filter_name"
Print detailed shiznit bout tha filta name \fIfilter_name\fR. Use the
\&\fB\-filters\fR option ta git a list of all filters.
.RE
.RS 4
.RE
.IP "\fB\-version\fR" 4
.IX Item "-version"
Show version.
.IP "\fB\-formats\fR" 4
.IX Item "-formats"
Show available formats.
.IP "\fB\-codecs\fR" 4
.IX Item "-codecs"
Show all codecs known ta libavcodec.
.Sp
Note dat tha term 'codec' is used all up in dis documentation as a gangbangin' finger-lickin' dirty-ass shortcut
for what tha fuck is mo' erectly called a media bitstream format.
.IP "\fB\-decoders\fR" 4
.IX Item "-decoders"
Show available decoders.
.IP "\fB\-encoders\fR" 4
.IX Item "-encoders"
Show all available encoders.
.IP "\fB\-bsfs\fR" 4
.IX Item "-bsfs"
Show available bitstream filters.
.IP "\fB\-protocols\fR" 4
.IX Item "-protocols"
Show available protocols.
.IP "\fB\-filters\fR" 4
.IX Item "-filters"
Show available libavfilta filters.
.IP "\fB\-pix_fmts\fR" 4
.IX Item "-pix_fmts"
Show available pixel formats.
.IP "\fB\-sample_fmts\fR" 4
.IX Item "-sample_fmts"
Show available sample formats.
.IP "\fB\-layouts\fR" 4
.IX Item "-layouts"
Show channel names n' standard channel layouts.
.IP "\fB\-colors\fR" 4
.IX Item "-colors"
Show recognized color names.
.IP "\fB\-loglevel [repeat+]\fR\fIloglevel\fR \fB| \-v [repeat+]\fR\fIloglevel\fR" 4
.IX Item "-loglevel [repeat+]loglevel | -v [repeat+]loglevel"
Set tha loggin level used by tha library.
Addin \*(L"repeat+\*(R" indicates dat repeated log output should not be compressed
to tha straight-up original gangsta line n' tha \*(L"Last message repeated n times\*(R" line will be
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \*(L"repeat\*(R" can also be used ridin' solo.
If \*(L"repeat\*(R" is used alone, n' wit no prior loglevel set, tha default
loglevel is ghon be used. Y'all KNOW dat shit, muthafucka! If multiple loglevel parametas is given, using
\&'repeat' aint gonna chizzle tha loglevel.
\&\fIloglevel\fR be a number or a strang containin one of tha followin joints:
.RS 4
.IP "\fBquiet\fR" 4
.IX Item "quiet"
Show not a god damn thang at all; be silent.
.IP "\fBpanic\fR" 4
.IX Item "panic"
Only show fatal errors which could lead tha process ta crash, such as
and assert failure. This aint currently used fo' anything.
.IP "\fBfatal\fR" 4
.IX Item "fatal"
Only show fatal errors. These is errors afta which tha process straight-up
cannot continue after.
.IP "\fBerror\fR" 4
.IX Item "error"
Show all errors, includin ones which can be recovered from.
.IP "\fBwarning\fR" 4
.IX Item "warning"
Show all warnings n' errors fo' realz. Any message related ta possibly
incorrect or unexpected events is ghon be shown.
.IP "\fBinfo\fR" 4
.IX Item "info"
Show informatizzle lyrics durin processing. This is up in addizzle to
warnings n' errors. This is tha default value.
.IP "\fBverbose\fR" 4
.IX Item "verbose"
Same as \f(CW\*(C`info\*(C'\fR, except mo' verbose.
.IP "\fBdebug\fR" 4
.IX Item "debug"
Show every last muthafuckin thang, includin debuggin shiznit.
.RE
.RS 4
.Sp
By default tha program logs ta stderr, if colorin is supported by the
terminal, flavas is used ta mark errors n' warnings. Log coloring
can be disabled settin tha environment variable
\&\fB\s-1AV_LOG_FORCE_NOCOLOR\s0\fR or \fB\s-1NO_COLOR\s0\fR, or can be forced setting
the environment variable \fB\s-1AV_LOG_FORCE_COLOR\s0\fR.
Da use of tha environment variable \fB\s-1NO_COLOR\s0\fR is deprecated and
will be dropped up in a gangbangin' followin FFmpeg version.
.RE
.IP "\fB\-report\fR" 4
.IX Item "-report"
Dump full command line n' console output ta a gangbangin' file named
\&\f(CW\*(C`\f(CIprogram\f(CW\-\f(CIYYYYMMDD\f(CW\-\f(CIHHMMSS\f(CW.log\*(C'\fR up in tha current
directory.
This file can be useful fo' bug reports.
It also implies \f(CW\*(C`\-loglevel verbose\*(C'\fR.
.Sp
Settin tha environment variable \f(CW\*(C`FFREPORT\*(C'\fR ta any value has the
same effect. If tha value be a ':'\-separated key=value sequence, these
options will affect tha report; options joints must be escaped if they
contain special charactas or tha options delimita ':' (see the
``Quotin n' escaping'' section up in tha ffmpeg-utils manual). The
followin option is recognized:
.RS 4
.IP "\fBfile\fR" 4
.IX Item "file"
set tha file name ta use fo' tha report; \f(CW%p\fR is expanded ta tha name
of tha program, \f(CW%t\fR is expanded ta a timestamp, \f(CW\*(C`%%\*(C'\fR is expanded
to a plain \f(CW\*(C`%\*(C'\fR
.RE
.RS 4
.Sp
Errors up in parsin tha environment variable is not fatal, n' will not
appear up in tha report.
.RE
.IP "\fB\-cpuflags flags (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-cpuflags flags (global)"
Allows settin n' clearin cpu flags. This option is intended
for testing. Do not use it unless you know what tha fuck you bustin.
.Sp
.Vb 3
\&        ffmpeg \-cpuflags \-sse+mmx ...
\&        ffmpeg \-cpuflags mmx ...
\&        ffmpeg \-cpuflags 0 ...
.Ve
.Sp
Possible flags fo' dis option are:
.RS 4
.IP "\fBx86\fR" 4
.IX Item "x86"
.RS 4
.PD 0
.IP "\fBmmx\fR" 4
.IX Item "mmx"
.IP "\fBmmxext\fR" 4
.IX Item "mmxext"
.IP "\fBsse\fR" 4
.IX Item "sse"
.IP "\fBsse2\fR" 4
.IX Item "sse2"
.IP "\fBsse2slow\fR" 4
.IX Item "sse2slow"
.IP "\fBsse3\fR" 4
.IX Item "sse3"
.IP "\fBsse3slow\fR" 4
.IX Item "sse3slow"
.IP "\fBssse3\fR" 4
.IX Item "ssse3"
.IP "\fBatom\fR" 4
.IX Item "atom"
.IP "\fBsse4.1\fR" 4
.IX Item "sse4.1"
.IP "\fBsse4.2\fR" 4
.IX Item "sse4.2"
.IP "\fBavx\fR" 4
.IX Item "avx"
.IP "\fBxop\fR" 4
.IX Item "xop"
.IP "\fBfma4\fR" 4
.IX Item "fma4"
.IP "\fB3dnow\fR" 4
.IX Item "3dnow"
.IP "\fB3dnowext\fR" 4
.IX Item "3dnowext"
.IP "\fBcmov\fR" 4
.IX Item "cmov"
.RE
.RS 4
.RE
.IP "\fB\s-1ARM\s0\fR" 4
.IX Item "ARM"
.RS 4
.IP "\fBarmv5te\fR" 4
.IX Item "armv5te"
.IP "\fBarmv6\fR" 4
.IX Item "armv6"
.IP "\fBarmv6t2\fR" 4
.IX Item "armv6t2"
.IP "\fBvfp\fR" 4
.IX Item "vfp"
.IP "\fBvfpv3\fR" 4
.IX Item "vfpv3"
.IP "\fBneon\fR" 4
.IX Item "neon"
.RE
.RS 4
.RE
.IP "\fBPowerPC\fR" 4
.IX Item "PowerPC"
.RS 4
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.RE
.RS 4
.RE
.IP "\fBSpecific Processors\fR" 4
.IX Item "Specific Processors"
.RS 4
.IP "\fBpentium2\fR" 4
.IX Item "pentium2"
.IP "\fBpentium3\fR" 4
.IX Item "pentium3"
.IP "\fBpentium4\fR" 4
.IX Item "pentium4"
.IP "\fBk6\fR" 4
.IX Item "k6"
.IP "\fBk62\fR" 4
.IX Item "k62"
.IP "\fBathlon\fR" 4
.IX Item "athlon"
.IP "\fBathlonxp\fR" 4
.IX Item "athlonxp"
.IP "\fBk8\fR" 4
.IX Item "k8"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\fB\-opencl_options options (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-opencl_options options (global)"
.PD
Set OpenCL environment options. This option is only available when
FFmpeg has been compiled wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR.
.Sp
\&\fIoptions\fR must be a list of \fIkey\fR=\fIvalue\fR option pairs
separated by ':'. Right back up in yo muthafuckin ass. See tha ``OpenCL Options'' section up in the
ffmpeg-utils manual fo' tha list of supported options.
.SS "AVOptions"
.IX Subsection "AVOptions"
These options is provided directly by tha libavformat, libavdevice and
libavcodec libraries. Put ya muthafuckin choppers up if ya feel dis! To peep tha list of available AVOptions, use the
\&\fB\-help\fR option. I aint talkin' bout chicken n' gravy biatch. They is separated tha fuck into two categories:
.IP "\fBgeneric\fR" 4
.IX Item "generic"
These options can be set fo' any container, codec or device. Generic options
are listed under AVFormatContext options fo' containers/devices n' under
AVCodecContext options fo' codecs.
.IP "\fBprivate\fR" 4
.IX Item "private"
These options is specific ta tha given container, thang or codec. Private
options is listed under they correspondin containers/devices/codecs.
.PP
For example ta write a ID3v2.3 header instead of a thugged-out default ID3v2.4 to
an \s-1MP3\s0 file, use tha \fBid3v2_version\fR private option of tha \s-1MP3\s0
muxer:
.PP
.Vb 1
\&        ffmpeg \-i input.flac \-id3v2_version 3 out.mp3
.Ve
.PP
All codec AVOptions is per-stream, n' thus a stream specifier
should be attached ta em.
.PP
Note: tha \fB\-nooption\fR syntax cannot be used fo' boolean
AVOptions, use \fB\-option 0\fR/\fB\-option 1\fR.
.PP
Note: tha oldschool undocumented way of specifyin per-stream AVOptions by
prependin v/a/s ta tha options name is now obsolete n' will be
removed soon.
.SS "Main options"
.IX Subsection "Main options"
.IP "\fB\-x\fR \fIwidth\fR" 4
.IX Item "-x width"
Force displayed width.
.IP "\fB\-y\fR \fIheight\fR" 4
.IX Item "-y height"
Force displayed height.
.IP "\fB\-s\fR \fIsize\fR" 4
.IX Item "-s size"
Set frame size (WxH or abbreviation), needed fo' vizzlez which do
not contain a header wit tha frame size like raw \s-1YUV. \s0 This option
has been deprecated up in favor of private options, try \-video_size.
.IP "\fB\-an\fR" 4
.IX Item "-an"
Disable audio.
.IP "\fB\-vn\fR" 4
.IX Item "-vn"
Disable vizzle.
.IP "\fB\-ss\fR \fIpos\fR" 4
.IX Item "-ss pos"
Seek ta a given posizzle up in seconds.
.IP "\fB\-t\fR \fIduration\fR" 4
.IX Item "-t duration"
play <duration> secondz of audio/video
.IP "\fB\-bytes\fR" 4
.IX Item "-bytes"
Seek by bytes.
.IP "\fB\-nodisp\fR" 4
.IX Item "-nodisp"
Disable graphical display.
.IP "\fB\-f\fR \fIfmt\fR" 4
.IX Item "-f fmt"
Force format.
.IP "\fB\-window_title\fR \fItitle\fR" 4
.IX Item "-window_title title"
Set window title (default is tha input filename).
.IP "\fB\-loop\fR \fInumber\fR" 4
.IX Item "-loop number"
Loops porno playback <number> times. 0 means alllll muthafuckin day.
.IP "\fB\-showmode\fR \fImode\fR" 4
.IX Item "-showmode mode"
Set tha show mode ta use.
Available joints fo' \fImode\fR are:
.RS 4
.IP "\fB0, vizzle\fR" 4
.IX Item "0, vizzle"
show vizzle
.IP "\fB1, waves\fR" 4
.IX Item "1, waves"
show audio waves
.IP "\fB2, rdft\fR" 4
.IX Item "2, rdft"
show audio frequency crew rockin \s-1RDFT \s0((Inverse) Real Discrete Fourier Transform)
.RE
.RS 4
.Sp
Default value is \*(L"video\*(R", if vizzle aint present or cannot be played
\&\*(L"rdft\*(R" be automatically selected.
.Sp
Yo ass can interactively cycle all up in tha available show modes by
pressin tha key \fBw\fR.
.RE
.IP "\fB\-vf\fR \fIfiltergraph\fR" 4
.IX Item "-vf filtergraph"
Smoke tha filtergraph specified by \fIfiltergraph\fR n' use it to
filta tha vizzle stream.
.Sp
\&\fIfiltergraph\fR be a thugged-out description of tha filtergraph ta apply to
the stream, n' must gotz a single vizzle input n' a single vizzle
output. In tha filtergraph, tha input be associated ta tha label
\&\f(CW\*(C`in\*(C'\fR, n' tha output ta tha label \f(CW\*(C`out\*(C'\fR. Right back up in yo muthafuckin ass. See the
ffmpeg-filtas manual fo' mo' shiznit bout tha filtergraph
syntax.
.IP "\fB\-af\fR \fIfiltergraph\fR" 4
.IX Item "-af filtergraph"
\&\fIfiltergraph\fR be a thugged-out description of tha filtergraph ta apply to
the input audio.
Use tha option \*(L"\-filters\*(R" ta show all tha available filtas (including
sources n' sinks).
.IP "\fB\-i\fR \fIinput_file\fR" 4
.IX Item "-i input_file"
Read \fIinput_file\fR.
.SS "Advanced options"
.IX Subsection "Advanced options"
.IP "\fB\-pix_fmt\fR \fIformat\fR" 4
.IX Item "-pix_fmt format"
Set pixel format.
This option has been deprecated up in favor of private options, try \-pixel_format.
.IP "\fB\-stats\fR" 4
.IX Item "-stats"
Print nuff muthafuckin playback statistics, up in particular show tha stream
duration, tha codec parameters, tha current posizzle up in tha stream and
the audio/video synchronisation drift. Well shiiiit, it is on by default, to
explicitly disable it you need ta specify \f(CW\*(C`\-nostats\*(C'\fR.
.IP "\fB\-bug\fR" 4
.IX Item "-bug"
Work round bugs.
.IP "\fB\-fast\fR" 4
.IX Item "-fast"
Non-spec-compliant optimizations.
.IP "\fB\-genpts\fR" 4
.IX Item "-genpts"
Generate pts.
.IP "\fB\-rtp_tcp\fR" 4
.IX Item "-rtp_tcp"
Force \s-1RTP/TCP\s0 protocol usage instead of \s-1RTP/UDP.\s0 It be only meaningful
if yo ass is streamin wit tha \s-1RTSP\s0 protocol.
.IP "\fB\-sync\fR \fItype\fR" 4
.IX Item "-sync type"
Set tha masta clock ta audio (\f(CW\*(C`type=audio\*(C'\fR), vizzle
(\f(CW\*(C`type=video\*(C'\fR) or external (\f(CW\*(C`type=ext\*(C'\fR). Default be audio. The
masta clock is used ta control audio-video synchronization. I aint talkin' bout chicken n' gravy biatch. Most media
players use audio as masta clock yo, but up in some cases (streamin or high
qualitizzle broadcast) it is necessary ta chizzle dis shit. This option is mainly
used fo' debuggin purposes.
.IP "\fB\-threads\fR \fIcount\fR" 4
.IX Item "-threadz count"
Set tha thread count.
.IP "\fB\-ast\fR \fIaudio_stream_number\fR" 4
.IX Item "-ast audio_stream_number"
Select tha desired audio stream number, countin from 0. Da number
refers ta tha list of all tha input audio streams. If it is pimped outer
than tha number of audio streams minus one, then tha last one is
selected, if it is wack tha audio playback is disabled.
.IP "\fB\-vst\fR \fIvideo_stream_number\fR" 4
.IX Item "-vst vizzle_stream_number"
Select tha desired vizzle stream number, countin from 0. Da number
refers ta tha list of all tha input vizzle streams. If it is pimped outer
than tha number of vizzle streams minus one, then tha last one is
selected, if it is wack tha vizzle playback is disabled.
.IP "\fB\-sst\fR \fIsubtitle_stream_number\fR" 4
.IX Item "-sst subtitle_stream_number"
Select tha desired subtitle stream number, countin from 0. Da number
refers ta tha list of all tha input subtitle streams. If it is pimped outer
than tha number of subtitle streams minus one, then tha last one is
selected, if it is wack tha subtitle renderin is disabled.
.IP "\fB\-autoexit\fR" 4
.IX Item "-autoexit"
Exit when vizzle is done playing.
.IP "\fB\-exitonkeydown\fR" 4
.IX Item "-exitonkeydown"
Exit if any key is pressed.
.IP "\fB\-exitonmousedown\fR" 4
.IX Item "-exitonmousedown"
Exit if any mouse button is pressed.
.IP "\fB\-codec:\fR\fImedia_specifier\fR\fB \fR\fIcodec_name\fR" 4
.IX Item "-codec:media_specifier codec_name"
Force a specific decoder implementation fo' tha stream identified by
\&\fImedia_specifier\fR, which can assume tha joints \f(CW\*(C`a\*(C'\fR (audio),
\&\f(CW\*(C`v\*(C'\fR (video), n' \f(CW\*(C`s\*(C'\fR subtitle.
.IP "\fB\-acodec\fR \fIcodec_name\fR" 4
.IX Item "-acodec codec_name"
Force a specific audio decoder.
.IP "\fB\-vcodec\fR \fIcodec_name\fR" 4
.IX Item "-vcodec codec_name"
Force a specific vizzle decoder.
.IP "\fB\-scodec\fR \fIcodec_name\fR" 4
.IX Item "-scodec codec_name"
Force a specific subtitle decoder.
.SS "While playing"
.IX Subsection "While playing"
.IP "\fBq, \s-1ESC\s0\fR" 4
.IX Item "q, ESC"
Quit.
.IP "\fBf\fR" 4
.IX Item "f"
Toggle full screen.
.IP "\fBp, \s-1SPC\s0\fR" 4
.IX Item "p, SPC"
Pause.
.IP "\fBa\fR" 4
.IX Item "a"
Cycle audio channel up in tha curret program.
.IP "\fBv\fR" 4
.IX Item "v"
Cycle vizzle channel.
.IP "\fBt\fR" 4
.IX Item "t"
Cycle subtitle channel up in tha current program.
.IP "\fBc\fR" 4
.IX Item "c"
Cycle program.
.IP "\fBw\fR" 4
.IX Item "w"
Show audio waves.
.IP "\fBleft/right\fR" 4
.IX Item "left/right"
Seek backward/forward 10 seconds.
.IP "\fBdown/up\fR" 4
.IX Item "down/up"
Seek backward/forward 1 minute.
.IP "\fBpage down/page up\fR" 4
.IX Item "page down/page up"
Seek backward/forward 10 minutes.
.IP "\fBmouse click\fR" 4
.IX Item "mouse click"
Seek ta cementage up in file correspondin ta fraction of width.
.SH "SYNTAX"
.IX Header "SYNTAX"
This section documents tha syntax n' formats employed by tha FFmpeg
libraries n' tools.
.SS "Quotin n' escaping"
.IX Subsection "Quotin n' escaping"
FFmpeg adopts tha followin quotin n' escapin mechanism, unless
explicitly specified. Y'all KNOW dat shit, muthafucka! Da followin rulez is applied:
.IP "\(bu" 4
\&\f(CW\*(C`\*(Aq\*(C'\fR n' \f(CW\*(C`\e\*(C'\fR is special charactas (respectively used for
quotin n' escaping). In addizzle ta them, there might be other
special charactas dependin on tha specific syntax where tha escaping
and quotin is employed.
.IP "\(bu" 4
A special characta is escaped by prefixin it wit a '\e'.
.IP "\(bu" 4
All charactas enclosed between '' is included literally up in the
parsed string. Da quote characta \f(CW\*(C`\*(Aq\*(C'\fR itself cannot be quoted,
so you may need ta close tha quote n' escape dat shit.
.IP "\(bu" 4
Leadin n' trailin whitespaces, unless escaped or quoted, are
removed from tha parsed string.
.PP
Note dat you may need ta add a second level of escapin when using
the command line or a script, which dependz on tha syntax of the
adopted shell language.
.PP
Da function \f(CW\*(C`av_get_token\*(C'\fR defined in
\&\fIlibavutil/avstring.h\fR can be used ta parse a token quoted or
escaped accordin ta tha rulez defined above.
.PP
Da tool \fItools/ffescape\fR up in tha FFmpeg source tree can be used
to automatically quote or escape a strang up in a script.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Escape tha strang \f(CW\*(C`Crime d\*(AqAmour\*(C'\fR containin tha \f(CW\*(C`\*(Aq\*(C'\fR special
character:
.Sp
.Vb 1
\&        Crime d\e\*(AqAmour
.Ve
.IP "\(bu" 4
Da strang above gotz nuff a quote, so tha \f(CW\*(C`\*(Aq\*(C'\fR need ta be escaped
when quotin it:
.Sp
.Vb 1
\&        \*(AqCrime d\*(Aq\e\*(Aq\*(AqAmour\*(Aq
.Ve
.IP "\(bu" 4
Include leadin or trailin whitespaces rockin quoting:
.Sp
.Vb 1
\&        \*(Aq  dis strang starts n' endz wit whitespaces  \*(Aq
.Ve
.IP "\(bu" 4
Escapin n' quotin can be mixed together:
.Sp
.Vb 1
\&        \*(Aq Da strang \*(Aq\e\*(Aqstring\e\*(Aq\*(Aq be a strang \*(Aq
.Ve
.IP "\(bu" 4
To include a literal \f(CW\*(C`\e\*(C'\fR you can use either escapin or quoting:
.Sp
.Vb 1
\&        \*(Aqc:\efoo\*(Aq can be freestyled as c:\e\efoo
.Ve
.SS "Date"
.IX Subsection "Date"
Da accepted syntax is:
.PP
.Vb 2
\&        [(YYYY\-MM\-DD|YYYYMMDD)[T|t| ]]((HH:MM:SS[.m...]]])|(HHMMSS[.m...]]]))[Z]
\&        now
.Ve
.PP
If tha value is \*(L"now\*(R" it takes tha current time.
.PP
Time is local time unless Z be appended, up in which case it is
interpreted as \s-1UTC.\s0
If tha year-month-dizzle part aint specified it takes tha current
year-month-day.
.SS "Time duration"
.IX Subsection "Time duration"
There is two accepted syntaxes fo' expressin time duration.
.PP
.Vb 1
\&        [\-][<HH>:]<MM>:<SS>[.<m>...]
.Ve
.PP
\&\fI\s-1HH\s0\fR expresses tha number of hours, \fI\s-1MM\s0\fR tha number of minutes
for a maximum of 2 digits, n' \fI\s-1SS\s0\fR tha number of secondz fo' a
maximum of 2 digits, n' you can put dat on yo' toast. Da \fIm\fR all up in tha end expresses decimal value for
\&\fI\s-1SS\s0\fR.
.PP
\&\fIor\fR
.PP
.Vb 1
\&        [\-]<S>+[.<m>...]
.Ve
.PP
\&\fIS\fR expresses tha number of seconds, wit tha optionizzle decimal part
\&\fIm\fR.
.PP
In both expressions, tha optionizzle \fB\-\fR indicates wack duration.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Da followin examplez is all valid time duration:
.IP "\fB55\fR" 4
.IX Item "55"
55 seconds
.IP "\fB12:03:45\fR" 4
.IX Item "12:03:45"
12 hours, 03 minutes n' 45 seconds
.IP "\fB23.189\fR" 4
.IX Item "23.189"
23.189 seconds
.SS "Video size"
.IX Subsection "Video size"
Specify tha size of tha sourced vizzle, it may be a strang of tha form
\&\fIwidth\fRx\fIheight\fR, or tha name of a size abbreviation.
.PP
Da followin abbreviations is recognized:
.IP "\fBntsc\fR" 4
.IX Item "ntsc"
720x480
.IP "\fBpal\fR" 4
.IX Item "pal"
720x576
.IP "\fBqntsc\fR" 4
.IX Item "qntsc"
352x240
.IP "\fBqpal\fR" 4
.IX Item "qpal"
352x288
.IP "\fBsntsc\fR" 4
.IX Item "sntsc"
640x480
.IP "\fBspal\fR" 4
.IX Item "spal"
768x576
.IP "\fBfilm\fR" 4
.IX Item "film"
352x240
.IP "\fBntsc-film\fR" 4
.IX Item "ntsc-film"
352x240
.IP "\fBsqcif\fR" 4
.IX Item "sqcif"
128x96
.IP "\fBqcif\fR" 4
.IX Item "qcif"
176x144
.IP "\fBcif\fR" 4
.IX Item "cif"
352x288
.IP "\fB4cif\fR" 4
.IX Item "4cif"
704x576
.IP "\fB16cif\fR" 4
.IX Item "16cif"
1408x1152
.IP "\fBqqvga\fR" 4
.IX Item "qqvga"
160x120
.IP "\fBqvga\fR" 4
.IX Item "qvga"
320x240
.IP "\fBvga\fR" 4
.IX Item "vga"
640x480
.IP "\fBsvga\fR" 4
.IX Item "svga"
800x600
.IP "\fBxga\fR" 4
.IX Item "xga"
1024x768
.IP "\fBuxga\fR" 4
.IX Item "uxga"
1600x1200
.IP "\fBqxga\fR" 4
.IX Item "qxga"
2048x1536
.IP "\fBsxga\fR" 4
.IX Item "sxga"
1280x1024
.IP "\fBqsxga\fR" 4
.IX Item "qsxga"
2560x2048
.IP "\fBhsxga\fR" 4
.IX Item "hsxga"
5120x4096
.IP "\fBwvga\fR" 4
.IX Item "wvga"
852x480
.IP "\fBwxga\fR" 4
.IX Item "wxga"
1366x768
.IP "\fBwsxga\fR" 4
.IX Item "wsxga"
1600x1024
.IP "\fBwuxga\fR" 4
.IX Item "wuxga"
1920x1200
.IP "\fBwoxga\fR" 4
.IX Item "woxga"
2560x1600
.IP "\fBwqsxga\fR" 4
.IX Item "wqsxga"
3200x2048
.IP "\fBwquxga\fR" 4
.IX Item "wquxga"
3840x2400
.IP "\fBwhsxga\fR" 4
.IX Item "whsxga"
6400x4096
.IP "\fBwhuxga\fR" 4
.IX Item "whuxga"
7680x4800
.IP "\fBcga\fR" 4
.IX Item "cga"
320x200
.IP "\fBega\fR" 4
.IX Item "ega"
640x350
.IP "\fBhd480\fR" 4
.IX Item "hd480"
852x480
.IP "\fBhd720\fR" 4
.IX Item "hd720"
1280x720
.IP "\fBhd1080\fR" 4
.IX Item "hd1080"
1920x1080
.IP "\fB2k\fR" 4
.IX Item "2k"
2048x1080
.IP "\fB2kflat\fR" 4
.IX Item "2kflat"
1998x1080
.IP "\fB2kscope\fR" 4
.IX Item "2kscope"
2048x858
.IP "\fB4k\fR" 4
.IX Item "4k"
4096x2160
.IP "\fB4kflat\fR" 4
.IX Item "4kflat"
3996x2160
.IP "\fB4kscope\fR" 4
.IX Item "4kscope"
4096x1716
.IP "\fBnhd\fR" 4
.IX Item "nhd"
640x360
.IP "\fBhqvga\fR" 4
.IX Item "hqvga"
240x160
.IP "\fBwqvga\fR" 4
.IX Item "wqvga"
400x240
.IP "\fBfwqvga\fR" 4
.IX Item "fwqvga"
432x240
.IP "\fBhvga\fR" 4
.IX Item "hvga"
480x320
.IP "\fBqhd\fR" 4
.IX Item "qhd"
960x540
.SS "Video rate"
.IX Subsection "Video rate"
Specify tha frame rate of a vizzle, expressed as tha number of frames
generated per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has ta be a strang up in tha format
\&\fIframe_rate_num\fR/\fIframe_rate_den\fR, a integer number, a gangbangin' float
number or a valid vizzle frame rate abbreviation.
.PP
Da followin abbreviations is recognized:
.IP "\fBntsc\fR" 4
.IX Item "ntsc"
30000/1001
.IP "\fBpal\fR" 4
.IX Item "pal"
25/1
.IP "\fBqntsc\fR" 4
.IX Item "qntsc"
30000/1001
.IP "\fBqpal\fR" 4
.IX Item "qpal"
25/1
.IP "\fBsntsc\fR" 4
.IX Item "sntsc"
30000/1001
.IP "\fBspal\fR" 4
.IX Item "spal"
25/1
.IP "\fBfilm\fR" 4
.IX Item "film"
24/1
.IP "\fBntsc-film\fR" 4
.IX Item "ntsc-film"
24000/1001
.SS "Ratio"
.IX Subsection "Ratio"
A ratio can be expressed as a expression, or up in tha form
\&\fInumerator\fR:\fIdenominator\fR.
.PP
Note dat a ratio wit infinite (1/0) or wack value is
considered valid, so you should check on tha returned value if you
wanna exclude dem joints.
.PP
Da undefined value can be expressed rockin tha \*(L"0:0\*(R" string.
.SS "Color"
.IX Subsection "Color"
It can be tha name of a cold-ass lil color as defined below (case insensitizzle match) or a
\&\f(CW\*(C`[0x|#]RRGGBB[AA]\*(C'\fR sequence, possibly followed by @ n' a string
representin tha alpha component.
.PP
Da alpha component may be a strang composed by \*(L"0x\*(R" followed by an
hexadecimal number or a thugged-out decimal number between 0.0 n' 1.0, which
represents tha opacitizzle value (\fB0x00\fR or \fB0.0\fR means straight-up
transparent, \fB0xff\fR or \fB1.0\fR straight-up opaque). If tha alpha
component aint specified then \fB0xff\fR be assumed.
.PP
Da strang \fBrandom\fR will result up in a random color.
.PP
Da followin namez of flavas is recognized:
.IP "\fBAliceBlue\fR" 4
.IX Item "AliceBlue"
0xF0F8FF
.IP "\fBAntiqueWhite\fR" 4
.IX Item "AntiqueWhite"
0xFAEBD7
.IP "\fBAqua\fR" 4
.IX Item "Aqua"
0x00FFFF
.IP "\fBAquamarine\fR" 4
.IX Item "Aquamarine"
0x7FFFD4
.IP "\fBAzure\fR" 4
.IX Item "Azure"
0xF0FFFF
.IP "\fBBeige\fR" 4
.IX Item "Beige"
0xF5F5DC
.IP "\fBBisque\fR" 4
.IX Item "Bisque"
0xFFE4C4
.IP "\fBBlack\fR" 4
.IX Item "Black"
0x000000
.IP "\fBBlanchedAlmond\fR" 4
.IX Item "BlanchedAlmond"
0xFFEBCD
.IP "\fBBlue\fR" 4
.IX Item "Blue"
0x0000FF
.IP "\fBBlueViolet\fR" 4
.IX Item "BlueViolet"
0x8A2BE2
.IP "\fBBrown\fR" 4
.IX Item "Brown"
0xA52A2A
.IP "\fBBurlyWood\fR" 4
.IX Item "BurlyWood"
0xDEB887
.IP "\fBCadetBlue\fR" 4
.IX Item "CadetBlue"
0x5F9EA0
.IP "\fBChartreuse\fR" 4
.IX Item "Chartreuse"
0x7FFF00
.IP "\fBChocolate\fR" 4
.IX Item "Chocolate"
0xD2691E
.IP "\fBCoral\fR" 4
.IX Item "Coral"
0xFF7F50
.IP "\fBCornflowerBlue\fR" 4
.IX Item "CornflowerBlue"
0x6495ED
.IP "\fBCornsilk\fR" 4
.IX Item "Cornsilk"
0xFFF8DC
.IP "\fBCrimson\fR" 4
.IX Item "Crimson"
0xDC143C
.IP "\fBCyan\fR" 4
.IX Item "Cyan"
0x00FFFF
.IP "\fBDarkBlue\fR" 4
.IX Item "DarkBlue"
0x00008B
.IP "\fBDarkCyan\fR" 4
.IX Item "DarkCyan"
0x008B8B
.IP "\fBDarkGoldenRod\fR" 4
.IX Item "DarkGoldenRod"
0xB8860B
.IP "\fBDarkGray\fR" 4
.IX Item "DarkGray"
0xA9A9A9
.IP "\fBDarkGreen\fR" 4
.IX Item "DarkGreen"
0x006400
.IP "\fBDarkKhaki\fR" 4
.IX Item "DarkKhaki"
0xBDB76B
.IP "\fBDarkMagenta\fR" 4
.IX Item "DarkMagenta"
0x8B008B
.IP "\fBDarkOliveGreen\fR" 4
.IX Item "DarkOliveGreen"
0x556B2F
.IP "\fBDarkorange\fR" 4
.IX Item "Darkorange"
0xFF8C00
.IP "\fBDarkOrchid\fR" 4
.IX Item "DarkOrchid"
0x9932CC
.IP "\fBDarkRed\fR" 4
.IX Item "DarkRed"
0x8B0000
.IP "\fBDarkSalmon\fR" 4
.IX Item "DarkSalmon"
0xE9967A
.IP "\fBDarkSeaGreen\fR" 4
.IX Item "DarkSeaGreen"
0x8FBC8F
.IP "\fBDarkSlateBlue\fR" 4
.IX Item "DarkSlateBlue"
0x483D8B
.IP "\fBDarkSlateGray\fR" 4
.IX Item "DarkSlateGray"
0x2F4F4F
.IP "\fBDarkTurquoise\fR" 4
.IX Item "DarkTurquoise"
0x00CED1
.IP "\fBDarkViolet\fR" 4
.IX Item "DarkViolet"
0x9400D3
.IP "\fBDeepPink\fR" 4
.IX Item "DeepPink"
0xFF1493
.IP "\fBDeepSkyBlue\fR" 4
.IX Item "DeepSkyBlue"
0x00BFFF
.IP "\fBDimGray\fR" 4
.IX Item "DimGray"
0x696969
.IP "\fBDodgerBlue\fR" 4
.IX Item "DodgerBlue"
0x1E90FF
.IP "\fBFireBrick\fR" 4
.IX Item "FireBrick"
0xB22222
.IP "\fBFloralWhite\fR" 4
.IX Item "FloralWhite"
0xFFFAF0
.IP "\fBForestGreen\fR" 4
.IX Item "ForestGreen"
0x228B22
.IP "\fBFuchsia\fR" 4
.IX Item "Fuchsia"
0xFF00FF
.IP "\fBGainsboro\fR" 4
.IX Item "Gainsboro"
0xDCDCDC
.IP "\fBGhostWhite\fR" 4
.IX Item "GhostWhite"
0xF8F8FF
.IP "\fBGold\fR" 4
.IX Item "Gold"
0xFFD700
.IP "\fBGoldenRod\fR" 4
.IX Item "GoldenRod"
0xDAA520
.IP "\fBGray\fR" 4
.IX Item "Gray"
0x808080
.IP "\fBGreen\fR" 4
.IX Item "Green"
0x008000
.IP "\fBGreenYellow\fR" 4
.IX Item "GreenYellow"
0xADFF2F
.IP "\fBHoneyDew\fR" 4
.IX Item "HoneyDew"
0xF0FFF0
.IP "\fBHotPink\fR" 4
.IX Item "HotPink"
0xFF69B4
.IP "\fBIndianRed\fR" 4
.IX Item "IndianRed"
0xCD5C5C
.IP "\fBIndigo\fR" 4
.IX Item "Indigo"
0x4B0082
.IP "\fBIvory\fR" 4
.IX Item "Ivory"
0xFFFFF0
.IP "\fBKhaki\fR" 4
.IX Item "Khaki"
0xF0E68C
.IP "\fBLavender\fR" 4
.IX Item "Lavender"
0xE6E6FA
.IP "\fBLavenderBlush\fR" 4
.IX Item "LavenderBlush"
0xFFF0F5
.IP "\fBLawnGreen\fR" 4
.IX Item "LawnGreen"
0x7CFC00
.IP "\fBLemonChiffon\fR" 4
.IX Item "LemonChiffon"
0xFFFACD
.IP "\fBLightBlue\fR" 4
.IX Item "LightBlue"
0xADD8E6
.IP "\fBLightCoral\fR" 4
.IX Item "LightCoral"
0xF08080
.IP "\fBLightCyan\fR" 4
.IX Item "LightCyan"
0xE0FFFF
.IP "\fBLightGoldenRodYellow\fR" 4
.IX Item "LightGoldenRodYellow"
0xFAFAD2
.IP "\fBLightGreen\fR" 4
.IX Item "LightGreen"
0x90EE90
.IP "\fBLightGay\fR" 4
.IX Item "LightGay"
0xD3D3D3
.IP "\fBLightPink\fR" 4
.IX Item "LightPink"
0xFFB6C1
.IP "\fBLightSalmon\fR" 4
.IX Item "LightSalmon"
0xFFA07A
.IP "\fBLightSeaGreen\fR" 4
.IX Item "LightSeaGreen"
0x20B2AA
.IP "\fBLightSkyBlue\fR" 4
.IX Item "LightSkyBlue"
0x87CEFA
.IP "\fBLightSlateGray\fR" 4
.IX Item "LightSlateGray"
0x778899
.IP "\fBLightSteelBlue\fR" 4
.IX Item "LightSteelBlue"
0xB0C4DE
.IP "\fBLightYellow\fR" 4
.IX Item "LightYellow"
0xFFFFE0
.IP "\fBLime\fR" 4
.IX Item "Lime"
0x00FF00
.IP "\fBLimeGreen\fR" 4
.IX Item "LimeGreen"
0x32CD32
.IP "\fBLinen\fR" 4
.IX Item "Linen"
0xFAF0E6
.IP "\fBMagenta\fR" 4
.IX Item "Magenta"
0xFF00FF
.IP "\fBMaroon\fR" 4
.IX Item "Maroon"
0x800000
.IP "\fBMediumAquaMarine\fR" 4
.IX Item "MediumAquaMarine"
0x66CDAA
.IP "\fBMediumBlue\fR" 4
.IX Item "MediumBlue"
0x0000CD
.IP "\fBMediumOrchid\fR" 4
.IX Item "MediumOrchid"
0xBA55D3
.IP "\fBMediumPurple\fR" 4
.IX Item "MediumPurple"
0x9370D8
.IP "\fBMediumSeaGreen\fR" 4
.IX Item "MediumSeaGreen"
0x3CB371
.IP "\fBMediumSlateBlue\fR" 4
.IX Item "MediumSlateBlue"
0x7B68EE
.IP "\fBMediumSpringGreen\fR" 4
.IX Item "MediumSpringGreen"
0x00FA9A
.IP "\fBMediumTurquoise\fR" 4
.IX Item "MediumTurquoise"
0x48D1CC
.IP "\fBMediumVioletRed\fR" 4
.IX Item "MediumVioletRed"
0xC71585
.IP "\fBMidnightBlue\fR" 4
.IX Item "MidnightBlue"
0x191970
.IP "\fBMintCream\fR" 4
.IX Item "MintCream"
0xF5FFFA
.IP "\fBMistyRose\fR" 4
.IX Item "MistyRose"
0xFFE4E1
.IP "\fBMoccasin\fR" 4
.IX Item "Moccasin"
0xFFE4B5
.IP "\fBNavajoWhite\fR" 4
.IX Item "NavajoWhite"
0xFFDEAD
.IP "\fBNavy\fR" 4
.IX Item "Navy"
0x000080
.IP "\fBOldLace\fR" 4
.IX Item "OldLace"
0xFDF5E6
.IP "\fBOlive\fR" 4
.IX Item "Olive"
0x808000
.IP "\fBOliveDrab\fR" 4
.IX Item "OliveDrab"
0x6B8E23
.IP "\fBOrange\fR" 4
.IX Item "Orange"
0xFFA500
.IP "\fBOrangeRed\fR" 4
.IX Item "OrangeRed"
0xFF4500
.IP "\fBOrchid\fR" 4
.IX Item "Orchid"
0xDA70D6
.IP "\fBPaleGoldenRod\fR" 4
.IX Item "PaleGoldenRod"
0xEEE8AA
.IP "\fBPaleGreen\fR" 4
.IX Item "PaleGreen"
0x98FB98
.IP "\fBPaleTurquoise\fR" 4
.IX Item "PaleTurquoise"
0xAFEEEE
.IP "\fBPaleVioletRed\fR" 4
.IX Item "PaleVioletRed"
0xD87093
.IP "\fBPapayaWhip\fR" 4
.IX Item "PapayaWhip"
0xFFEFD5
.IP "\fBPeachPuff\fR" 4
.IX Item "PeachPuff"
0xFFDAB9
.IP "\fBPeru\fR" 4
.IX Item "Peru"
0xCD853F
.IP "\fBPink\fR" 4
.IX Item "Pink"
0xFFC0CB
.IP "\fBPlum\fR" 4
.IX Item "Plum"
0xDDA0DD
.IP "\fBPowderBlue\fR" 4
.IX Item "PowderBlue"
0xB0E0E6
.IP "\fBPurple\fR" 4
.IX Item "Purple"
0x800080
.IP "\fBRed\fR" 4
.IX Item "Red"
0xFF0000
.IP "\fBRosyBrown\fR" 4
.IX Item "RosyBrown"
0xBC8F8F
.IP "\fBRoyalBlue\fR" 4
.IX Item "RoyalBlue"
0x4169E1
.IP "\fBSaddleBrown\fR" 4
.IX Item "SaddleBrown"
0x8B4513
.IP "\fBSalmon\fR" 4
.IX Item "Salmon"
0xFA8072
.IP "\fBSandyBrown\fR" 4
.IX Item "SandyBrown"
0xF4A460
.IP "\fBSeaGreen\fR" 4
.IX Item "SeaGreen"
0x2E8B57
.IP "\fBSeaShell\fR" 4
.IX Item "SeaShell"
0xFFF5EE
.IP "\fBSienna\fR" 4
.IX Item "Sienna"
0xA0522D
.IP "\fBSilver\fR" 4
.IX Item "Silver"
0xC0C0C0
.IP "\fBSkyBlue\fR" 4
.IX Item "SkyBlue"
0x87CEEB
.IP "\fBSlateBlue\fR" 4
.IX Item "SlateBlue"
0x6A5ACD
.IP "\fBSlateGray\fR" 4
.IX Item "SlateGray"
0x708090
.IP "\fBSnow\fR" 4
.IX Item "Snow"
0xFFFAFA
.IP "\fBSpringGreen\fR" 4
.IX Item "SpringGreen"
0x00FF7F
.IP "\fBSteelBlue\fR" 4
.IX Item "SteelBlue"
0x4682B4
.IP "\fBTan\fR" 4
.IX Item "Tan"
0xD2B48C
.IP "\fBTeal\fR" 4
.IX Item "Teal"
0x008080
.IP "\fBThistle\fR" 4
.IX Item "Thistle"
0xD8BFD8
.IP "\fBTomato\fR" 4
.IX Item "Tomato"
0xFF6347
.IP "\fBTurquoise\fR" 4
.IX Item "Turquoise"
0x40E0D0
.IP "\fBViolet\fR" 4
.IX Item "Violet"
0xEE82EE
.IP "\fBWheat\fR" 4
.IX Item "Wheat"
0xF5DEB3
.IP "\fBWhite\fR" 4
.IX Item "White"
0xFFFFFF
.IP "\fBWhiteSmoke\fR" 4
.IX Item "WhiteSmoke"
0xF5F5F5
.IP "\fBYellow\fR" 4
.IX Item "Yellow"
0xFFFF00
.IP "\fBYellowGreen\fR" 4
.IX Item "YellowGreen"
0x9ACD32
.SS "Channel Layout"
.IX Subsection "Channel Layout"
A channel layout specifies tha spatial disposizzle of tha channels in
a multi-channel audio stream. To specify a cold-ass lil channel layout, FFmpeg
makes use of a special syntax.
.PP
Individual channels is identified by a id, as given by tha table
below:
.IP "\fB\s-1FL\s0\fR" 4
.IX Item "FL"
front left
.IP "\fB\s-1FR\s0\fR" 4
.IX Item "FR"
front right
.IP "\fB\s-1FC\s0\fR" 4
.IX Item "FC"
front center
.IP "\fB\s-1LFE\s0\fR" 4
.IX Item "LFE"
low frequency
.IP "\fB\s-1BL\s0\fR" 4
.IX Item "BL"
back left
.IP "\fB\s-1BR\s0\fR" 4
.IX Item "BR"
back right
.IP "\fB\s-1FLC\s0\fR" 4
.IX Item "FLC"
front left-of-center
.IP "\fB\s-1FRC\s0\fR" 4
.IX Item "FRC"
front right-of-center
.IP "\fB\s-1BC\s0\fR" 4
.IX Item "BC"
back center
.IP "\fB\s-1SL\s0\fR" 4
.IX Item "SL"
side left
.IP "\fB\s-1SR\s0\fR" 4
.IX Item "SR"
side right
.IP "\fB\s-1TC\s0\fR" 4
.IX Item "TC"
top center
.IP "\fB\s-1TFL\s0\fR" 4
.IX Item "TFL"
top front left
.IP "\fB\s-1TFC\s0\fR" 4
.IX Item "TFC"
top front center
.IP "\fB\s-1TFR\s0\fR" 4
.IX Item "TFR"
top front right
.IP "\fB\s-1TBL\s0\fR" 4
.IX Item "TBL"
top back left
.IP "\fB\s-1TBC\s0\fR" 4
.IX Item "TBC"
top back center
.IP "\fB\s-1TBR\s0\fR" 4
.IX Item "TBR"
top back right
.IP "\fB\s-1DL\s0\fR" 4
.IX Item "DL"
downmix left
.IP "\fB\s-1DR\s0\fR" 4
.IX Item "DR"
downmix right
.IP "\fB\s-1WL\s0\fR" 4
.IX Item "WL"
wide left
.IP "\fB\s-1WR\s0\fR" 4
.IX Item "WR"
wide right
.IP "\fB\s-1SDL\s0\fR" 4
.IX Item "SDL"
surround direct left
.IP "\fB\s-1SDR\s0\fR" 4
.IX Item "SDR"
surround direct right
.IP "\fB\s-1LFE2\s0\fR" 4
.IX Item "LFE2"
low frequency 2
.PP
Standard channel layout compositions can be specified by rockin the
followin identifiers:
.IP "\fBmono\fR" 4
.IX Item "mono"
\&\s-1FC\s0
.IP "\fBstereo\fR" 4
.IX Item "stereo"
\&\s-1FL+FR\s0
.IP "\fB2.1\fR" 4
.IX Item "2.1"
\&\s-1FL+FR+LFE\s0
.IP "\fB3.0\fR" 4
.IX Item "3.0"
\&\s-1FL+FR+FC\s0
.IP "\fB3.0(back)\fR" 4
.IX Item "3.0(back)"
\&\s-1FL+FR+BC\s0
.IP "\fB4.0\fR" 4
.IX Item "4.0"
\&\s-1FL+FR+FC+BC\s0
.IP "\fBquad\fR" 4
.IX Item "quad"
\&\s-1FL+FR+BL+BR\s0
.IP "\fBquad(side)\fR" 4
.IX Item "quad(side)"
\&\s-1FL+FR+SL+SR\s0
.IP "\fB3.1\fR" 4
.IX Item "3.1"
\&\s-1FL+FR+FC+LFE\s0
.IP "\fB5.0\fR" 4
.IX Item "5.0"
\&\s-1FL+FR+FC+BL+BR\s0
.IP "\fB5.0(side)\fR" 4
.IX Item "5.0(side)"
\&\s-1FL+FR+FC+SL+SR\s0
.IP "\fB4.1\fR" 4
.IX Item "4.1"
\&\s-1FL+FR+FC+LFE+BC\s0
.IP "\fB5.1\fR" 4
.IX Item "5.1"
\&\s-1FL+FR+FC+LFE+BL+BR\s0
.IP "\fB5.1(side)\fR" 4
.IX Item "5.1(side)"
\&\s-1FL+FR+FC+LFE+SL+SR\s0
.IP "\fB6.0\fR" 4
.IX Item "6.0"
\&\s-1FL+FR+FC+BC+SL+SR\s0
.IP "\fB6.0(front)\fR" 4
.IX Item "6.0(front)"
\&\s-1FL+FR+FLC+FRC+SL+SR\s0
.IP "\fBhexagonal\fR" 4
.IX Item "hexagonal"
\&\s-1FL+FR+FC+BL+BR+BC\s0
.IP "\fB6.1\fR" 4
.IX Item "6.1"
\&\s-1FL+FR+FC+LFE+BC+SL+SR\s0
.IP "\fB6.1\fR" 4
.IX Item "6.1"
\&\s-1FL+FR+FC+LFE+BL+BR+BC\s0
.IP "\fB6.1(front)\fR" 4
.IX Item "6.1(front)"
\&\s-1FL+FR+LFE+FLC+FRC+SL+SR\s0
.IP "\fB7.0\fR" 4
.IX Item "7.0"
\&\s-1FL+FR+FC+BL+BR+SL+SR\s0
.IP "\fB7.0(front)\fR" 4
.IX Item "7.0(front)"
\&\s-1FL+FR+FC+FLC+FRC+SL+SR\s0
.IP "\fB7.1\fR" 4
.IX Item "7.1"
\&\s-1FL+FR+FC+LFE+BL+BR+SL+SR\s0
.IP "\fB7.1(wide)\fR" 4
.IX Item "7.1(wide)"
\&\s-1FL+FR+FC+LFE+BL+BR+FLC+FRC\s0
.IP "\fB7.1(wide\-side)\fR" 4
.IX Item "7.1(wide-side)"
\&\s-1FL+FR+FC+LFE+FLC+FRC+SL+SR\s0
.IP "\fBoctagonal\fR" 4
.IX Item "octagonal"
\&\s-1FL+FR+FC+BL+BR+BC+SL+SR\s0
.IP "\fBdownmix\fR" 4
.IX Item "downmix"
\&\s-1DL+DR\s0
.PP
A custom channel layout can be specified as a sequence of terms, separated by
\&'+' or '|'. Each term can be:
.IP "\(bu" 4
the name of a standard channel layout (e.g. \fBmono\fR,
\&\fBstereo\fR, \fB4.0\fR, \fBquad\fR, \fB5.0\fR, etc.)
.IP "\(bu" 4
the name of a single channel (e.g. \fB\s-1FL\s0\fR, \fB\s-1FR\s0\fR, \fB\s-1FC\s0\fR, \fB\s-1LFE\s0\fR, etc.)
.IP "\(bu" 4
a number of channels, up in decimal, optionally followed by 'c', yielding
the default channel layout fo' dat number of channels (see the
function \f(CW\*(C`av_get_default_channel_layout\*(C'\fR)
.IP "\(bu" 4
a channel layout mask, up in hexadecimal startin wit \*(L"0x\*(R" (see the
\&\f(CW\*(C`AV_CH_*\*(C'\fR macros up in \fIlibavutil/channel_layout.h\fR.
.PP
Startin from libavutil version 53 tha trailin characta \*(L"c\*(R" to
specify a fuckin shitload of channels is ghon be required, while a cold-ass lil channel layout
mask could also be specified as a thugged-out decimal number (if n' only if not
followed by \*(L"c\*(R").
.PP
See also tha function \f(CW\*(C`av_get_channel_layout\*(C'\fR defined in
\&\fIlibavutil/channel_layout.h\fR.
.SH "EXPRESSION EVALUATION"
.IX Header "EXPRESSION EVALUATION"
When evaluatin a arithmetic expression, FFmpeg uses a internal
formula evaluator, implemented all up in tha \fIlibavutil/eval.h\fR
interface.
.PP
An expression may contain unary, binary operators, constants, and
functions.
.PP
Two expressions \fIexpr1\fR n' \fIexpr2\fR can be combined ta form
another expression "\fIexpr1\fR;\fIexpr2\fR".
\&\fIexpr1\fR n' \fIexpr2\fR is evaluated up in turn, n' tha new
expression evaluates ta tha value of \fIexpr2\fR.
.PP
Da followin binary operators is available: \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR,
\&\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`/\*(C'\fR, \f(CW\*(C`^\*(C'\fR.
.PP
Da followin unary operators is available: \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR.
.PP
Da followin functions is available:
.IP "\fBabs(x)\fR" 4
.IX Item "abs(x)"
Compute absolute value of \fIx\fR.
.IP "\fBacos(x)\fR" 4
.IX Item "acos(x)"
Compute arccosine of \fIx\fR.
.IP "\fBasin(x)\fR" 4
.IX Item "asin(x)"
Compute arcsine of \fIx\fR.
.IP "\fBatan(x)\fR" 4
.IX Item "atan(x)"
Compute arctangent of \fIx\fR.
.IP "\fBbetween(x, min, max)\fR" 4
.IX Item "between(x, min, max)"
Return 1 if \fIx\fR is pimped outa than or equal ta \fImin\fR n' lesser than or
equal ta \fImax\fR, 0 otherwise.
.IP "\fBbitand(x, y)\fR" 4
.IX Item "bitand(x, y)"
.PD 0
.IP "\fBbitor(x, y)\fR" 4
.IX Item "bitor(x, y)"
.PD
Compute bitwise and/or operation on \fIx\fR n' \fIy\fR.
.Sp
Da thangs up in dis biatch of tha evaluation of \fIx\fR n' \fIy\fR is converted to
integers before executin tha bitwise operation.
.Sp
Note dat both tha conversion ta integer n' tha conversion back to
floatin point can lose precision. I aint talkin' bout chicken n' gravy biatch. Beware of unexpected thangs up in dis biatch for
pimpin' numbers (usually 2^53 n' larger).
.IP "\fBceil(expr)\fR" 4
.IX Item "ceil(expr)"
Round tha value of expression \fIexpr\fR upwardz ta tha nearest
integer n' shit. For example, \*(L"ceil(1.5)\*(R" is \*(L"2.0\*(R".
.IP "\fBcos(x)\fR" 4
.IX Item "cos(x)"
Compute cosine of \fIx\fR.
.IP "\fBcosh(x)\fR" 4
.IX Item "cosh(x)"
Compute hyperbolic cosine of \fIx\fR.
.IP "\fBeq(x, y)\fR" 4
.IX Item "eq(x, y)"
Return 1 if \fIx\fR n' \fIy\fR is equivalent, 0 otherwise.
.IP "\fBexp(x)\fR" 4
.IX Item "exp(x)"
Compute exponential of \fIx\fR (with base \f(CW\*(C`e\*(C'\fR, tha Eulerz number).
.IP "\fBfloor(expr)\fR" 4
.IX Item "floor(expr)"
Round tha value of expression \fIexpr\fR downwardz ta tha nearest
integer n' shit. For example, \*(L"floor(\-1.5)\*(R" is \*(L"\-2.0\*(R".
.IP "\fBgauss(x)\fR" 4
.IX Item "gauss(x)"
Compute Gauss function of \fIx\fR, correspondin to
\&\f(CW\*(C`exp(\-x*x/2) / sqrt(2*PI)\*(C'\fR.
.IP "\fBgcd(x, y)\fR" 4
.IX Item "gcd(x, y)"
Return tha top billin common divisor of \fIx\fR n' \fIy\fR. If both \fIx\fR and
\&\fIy\fR is 0 or either or both is less than zero then behavior is undefined.
.IP "\fBgt(x, y)\fR" 4
.IX Item "gt(x, y)"
Return 1 if \fIx\fR is pimped outa than \fIy\fR, 0 otherwise.
.IP "\fBgte(x, y)\fR" 4
.IX Item "gte(x, y)"
Return 1 if \fIx\fR is pimped outa than or equal ta \fIy\fR, 0 otherwise.
.IP "\fBhypot(x, y)\fR" 4
.IX Item "hypot(x, y)"
This function is similar ta tha C function wit tha same name; it returns
"sqrt(\fIx\fR*\fIx\fR + \fIy\fR*\fIy\fR)", tha length of tha hypotenuse of a
right triangle wit sidez of length \fIx\fR n' \fIy\fR, or tha distizzle of the
point (\fIx\fR, \fIy\fR) from tha origin.
.IP "\fBif(x, y)\fR" 4
.IX Item "if(x, y)"
Evaluate \fIx\fR, n' if tha result is non-zero return tha result of
the evaluation of \fIy\fR, return 0 otherwise.
.IP "\fBif(x, y, z)\fR" 4
.IX Item "if(x, y, z)"
Evaluate \fIx\fR, n' if tha result is non-zero return tha evaluation
result of \fIy\fR, otherwise tha evaluation result of \fIz\fR.
.IP "\fBifnot(x, y)\fR" 4
.IX Item "ifnot(x, y)"
Evaluate \fIx\fR, n' if tha result is zero return tha result of the
evaluation of \fIy\fR, return 0 otherwise.
.IP "\fBifnot(x, y, z)\fR" 4
.IX Item "ifnot(x, y, z)"
Evaluate \fIx\fR, n' if tha result is zero return tha evaluation
result of \fIy\fR, otherwise tha evaluation result of \fIz\fR.
.IP "\fBisinf(x)\fR" 4
.IX Item "isinf(x)"
Return 1.0 if \fIx\fR is +/\-INFINITY, 0.0 otherwise.
.IP "\fBisnan(x)\fR" 4
.IX Item "isnan(x)"
Return 1.0 if \fIx\fR is \s-1NAN, 0.0\s0 otherwise.
.IP "\fBld(var)\fR" 4
.IX Item "ld(var)"
Allow ta load tha value of tha internal variable wit number
\&\fIvar\fR, which was previously stored wit st(\fIvar\fR, \fIexpr\fR).
Da function returns tha loaded value.
.IP "\fBlog(x)\fR" 4
.IX Item "log(x)"
Compute natural logarithm of \fIx\fR.
.IP "\fBlt(x, y)\fR" 4
.IX Item "lt(x, y)"
Return 1 if \fIx\fR is lesser than \fIy\fR, 0 otherwise.
.IP "\fBlte(x, y)\fR" 4
.IX Item "lte(x, y)"
Return 1 if \fIx\fR is lesser than or equal ta \fIy\fR, 0 otherwise.
.IP "\fBmax(x, y)\fR" 4
.IX Item "max(x, y)"
Return tha maximum between \fIx\fR n' \fIy\fR.
.IP "\fBmin(x, y)\fR" 4
.IX Item "min(x, y)"
Return tha maximum between \fIx\fR n' \fIy\fR.
.IP "\fBmod(x, y)\fR" 4
.IX Item "mod(x, y)"
Compute tha remainder of division of \fIx\fR by \fIy\fR.
.IP "\fBnot(expr)\fR" 4
.IX Item "not(expr)"
Return 1.0 if \fIexpr\fR is zero, 0.0 otherwise.
.IP "\fBpow(x, y)\fR" 4
.IX Item "pow(x, y)"
Compute tha juice of \fIx\fR elevated \fIy\fR, it is equivalent to
"(\fIx\fR)^(\fIy\fR)".
.IP "\fBprint(t)\fR" 4
.IX Item "print(t)"
.PD 0
.IP "\fBprint(t, l)\fR" 4
.IX Item "print(t, l)"
.PD
Print tha value of expression \fIt\fR wit loglevel \fIl\fR. If
\&\fIl\fR aint specified then a thugged-out default log level is used.
Returns tha value of tha expression printed.
.Sp
Prints t wit loglevel l
.IP "\fBrandom(x)\fR" 4
.IX Item "random(x)"
Return a pseudo random value between 0.0 n' 1.0. \fIx\fR is tha index of the
internal variable which is ghon be used ta save tha seed/state.
.IP "\fBroot(expr, max)\fR" 4
.IX Item "root(expr, max)"
Find a input value fo' which tha function represented by \fIexpr\fR
with argument \fI\fIld\fI\|(0)\fR is 0 up in tha interval 0..\fImax\fR.
.Sp
Da expression up in \fIexpr\fR must denote a cold-ass lil continuous function or the
result is undefined.
.Sp
\&\fI\fIld\fI\|(0)\fR is used ta represent tha function input value, which means
that tha given expression is ghon be evaluated multiple times with
various input joints dat tha expression can access through
\&\f(CWld(0)\fR. When tha expression evaluates ta 0 then the
correspondin input value is ghon be returned.
.IP "\fBsin(x)\fR" 4
.IX Item "sin(x)"
Compute sine of \fIx\fR.
.IP "\fBsinh(x)\fR" 4
.IX Item "sinh(x)"
Compute hyperbolic sine of \fIx\fR.
.IP "\fBsqrt(expr)\fR" 4
.IX Item "sqrt(expr)"
Compute tha square root of \fIexpr\fR. This is equivalent to
"(\fIexpr\fR)^.5".
.IP "\fBsquish(x)\fR" 4
.IX Item "squish(x)"
Compute expression \f(CW\*(C`1/(1 + exp(4*x))\*(C'\fR.
.IP "\fBst(var, expr)\fR" 4
.IX Item "st(var, expr)"
Allow ta store tha value of tha expression \fIexpr\fR up in a internal
variable. \fIvar\fR specifies tha number of tha variable where to
store tha value, n' it aint nuthin but a value rangin from 0 ta 9. Da function
returns tha value stored up in tha internal variable.
Note, Variablez is currently not shared between expressions.
.IP "\fBtan(x)\fR" 4
.IX Item "tan(x)"
Compute tangent of \fIx\fR.
.IP "\fBtanh(x)\fR" 4
.IX Item "tanh(x)"
Compute hyperbolic tangent of \fIx\fR.
.IP "\fBtaylor(expr, x)\fR" 4
.IX Item "taylor(expr, x)"
.PD 0
.IP "\fBtaylor(expr, x, id)\fR" 4
.IX Item "taylor(expr, x, id)"
.PD
Evaluate a Tay-Tay series at \fIx\fR, given a expression representing
the \f(CW\*(C`ld(id)\*(C'\fR\-th derivatizzle of a gangbangin' function at 0.
.Sp
When tha series do not converge tha result is undefined.
.Sp
\&\fIld(id)\fR is used ta represent tha derivatizzle order up in \fIexpr\fR,
which means dat tha given expression is ghon be evaluated multiple times
with various input joints dat tha expression can access through
\&\f(CW\*(C`ld(id)\*(C'\fR. If \fIid\fR aint specified then 0 be assumed.
.Sp
Note, when you have tha derivatives at y instead of 0,
\&\f(CW\*(C`taylor(expr, x\-y)\*(C'\fR can be used.
.IP "\fB\f(BItime\fB\|(0)\fR" 4
.IX Item "time"
Return tha current (wallclock) time up in seconds.
.IP "\fBtrunc(expr)\fR" 4
.IX Item "trunc(expr)"
Round tha value of expression \fIexpr\fR towardz zero ta tha nearest
integer n' shit. For example, \*(L"trunc(\-1.5)\*(R" is \*(L"\-1.0\*(R".
.IP "\fBwhile(cond, expr)\fR" 4
.IX Item "while(cond, expr)"
Evaluate expression \fIexpr\fR while tha expression \fIcond\fR is
non-zero, n' returns tha value of tha last \fIexpr\fR evaluation, or
\&\s-1NAN\s0 if \fIcond\fR was always false.
.PP
Da followin constants is available:
.IP "\fB\s-1PI\s0\fR" 4
.IX Item "PI"
area of tha unit disc, approximately 3.14
.IP "\fBE\fR" 4
.IX Item "E"
\&\fIexp\fR\|(1) (Eulerz number), approximately 2.718
.IP "\fB\s-1PHI\s0\fR" 4
.IX Item "PHI"
golden ratio (1+\fIsqrt\fR\|(5))/2, approximately 1.618
.PP
Assumin dat a expression is considered \*(L"true\*(R" if it has a non-zero
value, note that:
.PP
\&\f(CW\*(C`*\*(C'\fR works like \s-1AND\s0
.PP
\&\f(CW\*(C`+\*(C'\fR works like \s-1OR\s0
.PP
For example tha construct:
.PP
.Vb 1
\&        if (A AND B) then C
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&        if(A*B, C)
.Ve
.PP
In yo' C code, you can extend tha list of unary n' binary functions,
and define recognized constants, so dat they is available fo' your
expressions.
.PP
Da evaluator also recognizes tha Internationistic System unit prefixes.
If 'i' be appended afta tha prefix, binary prefixes is used, which
are based on powerz of 1024 instead of powerz of 1000.
Da 'B' postfix multiplies tha value by 8, n' can be appended afta a
unit prefix or used ridin' solo. This allows rockin fo' example '\s-1KB\s0', 'MiB',
\&'G' n' 'B' as number postfix.
.PP
Da list of available Internationistic System prefixes bigs up, with
indication of tha correspondin powerz of 10 n' of 2.
.IP "\fBy\fR" 4
.IX Item "y"
10^\-24 / 2^\-80
.IP "\fBz\fR" 4
.IX Item "z"
10^\-21 / 2^\-70
.IP "\fBa\fR" 4
.IX Item "a"
10^\-18 / 2^\-60
.IP "\fBf\fR" 4
.IX Item "f"
10^\-15 / 2^\-50
.IP "\fBp\fR" 4
.IX Item "p"
10^\-12 / 2^\-40
.IP "\fBn\fR" 4
.IX Item "n"
10^\-9 / 2^\-30
.IP "\fBu\fR" 4
.IX Item "u"
10^\-6 / 2^\-20
.IP "\fBm\fR" 4
.IX Item "m"
10^\-3 / 2^\-10
.IP "\fBc\fR" 4
.IX Item "c"
10^\-2
.IP "\fBd\fR" 4
.IX Item "d"
10^\-1
.IP "\fBh\fR" 4
.IX Item "h"
10^2
.IP "\fBk\fR" 4
.IX Item "k"
10^3 / 2^10
.IP "\fBK\fR" 4
.IX Item "K"
10^3 / 2^10
.IP "\fBM\fR" 4
.IX Item "M"
10^6 / 2^20
.IP "\fBG\fR" 4
.IX Item "G"
10^9 / 2^30
.IP "\fBT\fR" 4
.IX Item "T"
10^12 / 2^40
.IP "\fBP\fR" 4
.IX Item "P"
10^15 / 2^40
.IP "\fBE\fR" 4
.IX Item "E"
10^18 / 2^50
.IP "\fBZ\fR" 4
.IX Item "Z"
10^21 / 2^60
.IP "\fBY\fR" 4
.IX Item "Y"
10^24 / 2^70
.SH "OPENCL OPTIONS"
.IX Header "OPENCL OPTIONS"
When FFmpeg is configured wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR, it is possible
to set tha options fo' tha global OpenCL context.
.PP
Da list of supported options bigs up:
.IP "\fBbuild_options\fR" 4
.IX Item "build_options"
Set build options used ta compile tha registered kernels.
.Sp
See reference \*(L"OpenCL Justification Version: 1.2 chapta 5.6.4\*(R".
.IP "\fBplatform_idx\fR" 4
.IX Item "platform_idx"
Select tha index of tha platform ta run OpenCL code.
.Sp
Da specified index must be one of tha indexes up in tha thang list
which can be obtained wit \f(CW\*(C`av_opencl_get_device_list()\*(C'\fR.
.IP "\fBdevice_idx\fR" 4
.IX Item "device_idx"
Select tha index of tha thang used ta run OpenCL code.
.Sp
Da specifed index must be one of tha indexes up in tha thang list which
can be obtained wit \f(CW\*(C`av_opencl_get_device_list()\*(C'\fR.
.SH "CODEC OPTIONS"
.IX Header "CODEC OPTIONS"
libavcodec serves up some generic global options, which can be set on
all tha encodaz n' decoders. In addizzle each codec may support
so-called private options, which is specific fo' a given codec.
.PP
Sometimes, a global option may only affect a specific kind of codec,
and may be unsensical or ignored by another, so you need ta be aware
of tha meanin of tha specified options fo' realz. Also some options are
meant only fo' decodin or encoding.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, or by settin tha value explicitly up in the
\&\f(CW\*(C`AVCodecContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.PP
Da list of supported options follow:
.IP "\fBb\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "b integer (encoding,audio,video)"
Set bitrate up in bits/s. Default value is 200K.
.IP "\fBab\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "ab integer (encoding,audio)"
Set audio bitrate (in bits/s). Default value is 128K.
.IP "\fBbt\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "bt integer (encoding,video)"
Set vizzle bitrate tolerizzle (in bits/s). In 1\-pass mode, bitrate
tolerizzle specifies how tha fuck far ratecontrol is willin ta deviate from the
target average bitrate value. This aint related ta min/max
bitrate. Lowerin tolerizzle too much has a adverse effect on quality.
.IP "\fBflags\fR \fIflags\fR \fB(\fR\fIdecoding/encoding,audio,video,subtitles\fR\fB)\fR" 4
.IX Item "flags flags (decoding/encoding,audio,video,subtitles)"
Set generic flags.
.Sp
Possible joints:
.RS 4
.IP "\fBmv4\fR" 4
.IX Item "mv4"
Use four motion vector by macroblock (mpeg4).
.IP "\fBqpel\fR" 4
.IX Item "qpel"
Use 1/4 pel motion compensation.
.IP "\fBloop\fR" 4
.IX Item "loop"
Use loop filter.
.IP "\fBqscale\fR" 4
.IX Item "qscale"
Use fixed qscale.
.IP "\fBgmc\fR" 4
.IX Item "gmc"
Use gmc.
.IP "\fBmv0\fR" 4
.IX Item "mv0"
Always try a mb wit mv=<0,0>.
.IP "\fBinput_preserved\fR" 4
.IX Item "input_preserved"
.PD 0
.IP "\fBpass1\fR" 4
.IX Item "pass1"
.PD
Use internal 2pass ratecontrol up in first pass mode.
.IP "\fBpass2\fR" 4
.IX Item "pass2"
Use internal 2pass ratecontrol up in second pass mode.
.IP "\fBgray\fR" 4
.IX Item "gray"
Only decode/encode grayscale.
.IP "\fBemu_edge\fR" 4
.IX Item "emu_edge"
Do not draw edges.
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
Set error[?] variablez durin encoding.
.IP "\fBtruncated\fR" 4
.IX Item "truncated"
.PD 0
.IP "\fBnaq\fR" 4
.IX Item "naq"
.PD
Normalize adaptizzle quantization.
.IP "\fBildct\fR" 4
.IX Item "ildct"
Use interlaced \s-1DCT.\s0
.IP "\fBlow_delay\fR" 4
.IX Item "low_delay"
Force low delay.
.IP "\fBglobal_header\fR" 4
.IX Item "global_header"
Place global headaz up in extradata instead of every last muthafuckin keyframe.
.IP "\fBbitexact\fR" 4
.IX Item "bitexact"
Use only bitexact shiznit (except (I)DCT).
.IP "\fBaic\fR" 4
.IX Item "aic"
Apply H263 advanced intra codin / mpeg4 ac prediction.
.IP "\fBcbp\fR" 4
.IX Item "cbp"
Deprecated, use mpegvideo private options instead.
.IP "\fBqprd\fR" 4
.IX Item "qprd"
Deprecated, use mpegvideo private options instead.
.IP "\fBilme\fR" 4
.IX Item "ilme"
Apply interlaced motion estimation.
.IP "\fBcgop\fR" 4
.IX Item "cgop"
Use closed gop.
.RE
.RS 4
.RE
.IP "\fBme_method\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "me_method integer (encoding,video)"
Set motion estimation method.
.Sp
Possible joints:
.RS 4
.IP "\fBzero\fR" 4
.IX Item "zero"
zero motion estimation (fastest)
.IP "\fBfull\fR" 4
.IX Item "full"
full motion estimation (slowest)
.IP "\fBepzs\fR" 4
.IX Item "epzs"
\&\s-1EPZS\s0 motion estimation (default)
.IP "\fBesa\fR" 4
.IX Item "esa"
esa motion estimation (alias fo' full)
.IP "\fBtesa\fR" 4
.IX Item "tesa"
tesa motion estimation
.IP "\fBdia\fR" 4
.IX Item "dia"
dia motion estimation (alias fo' epzs)
.IP "\fBlog\fR" 4
.IX Item "log"
log motion estimation
.IP "\fBphods\fR" 4
.IX Item "phods"
phodz motion estimation
.IP "\fBx1\fR" 4
.IX Item "x1"
X1 motion estimation
.IP "\fBhex\fR" 4
.IX Item "hex"
hex motion estimation
.IP "\fBumh\fR" 4
.IX Item "umh"
umh motion estimation
.IP "\fBiter\fR" 4
.IX Item "iter"
ita motion estimation
.RE
.RS 4
.RE
.IP "\fBextradata_size\fR \fIinteger\fR" 4
.IX Item "extradata_size integer"
Set extradata size.
.IP "\fBtime_base\fR \fIrationizzle number\fR" 4
.IX Item "time_base rationizzle number"
Set codec time base.
.Sp
It be tha fundamenstrual unit of time (in seconds) up in termz of which
frame timestamps is represented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For fixed-fps content, timebase
should be \f(CW\*(C`1 / frame_rate\*(C'\fR n' timestamp increments should be
identically 1.
.IP "\fBg\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "g integer (encoding,video)"
Set tha crew of picture size. Default value is 12.
.IP "\fBar\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,audio\fR\fB)\fR" 4
.IX Item "ar integer (decoding/encoding,audio)"
Set audio samplin rate (in Hz).
.IP "\fBac\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,audio\fR\fB)\fR" 4
.IX Item "ac integer (decoding/encoding,audio)"
Set number of audio channels.
.IP "\fBcutoff\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "cutoff integer (encoding,audio)"
Set cutoff bandwidth.
.IP "\fBframe_size\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "frame_size integer (encoding,audio)"
Set audio frame size.
.Sp
Each submitted frame except tha last must contain exactly frame_size
samplez per channel. May be 0 when tha codec has
\&\s-1CODEC_CAP_VARIABLE_FRAME_SIZE\s0 set, up in dat case tha frame size is not
restricted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it is set by some decodaz ta indicate constant frame
size.
.IP "\fBframe_number\fR \fIinteger\fR" 4
.IX Item "frame_number integer"
Set tha frame number.
.IP "\fBdelay\fR \fIinteger\fR" 4
.IX Item "delay integer"
.PD 0
.IP "\fBqcomp\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qcomp float (encoding,video)"
.PD
Set vizzle quantizer scale compression (\s-1VBR\s0). Well shiiiit, it is used as a cold-ass lil constant
in tha ratecontrol equation. I aint talkin' bout chicken n' gravy biatch. Recommended range fo' default rc_eq:
0.0\-1.0.
.IP "\fBqblur\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qblur float (encoding,video)"
Set vizzle quantizer scale blur (\s-1VBR\s0).
.IP "\fBqmin\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qmin integer (encoding,video)"
Set min vizzle quantizer scale (\s-1VBR\s0). Must be included between \-1 and
69, default value is 2.
.IP "\fBqmax\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qmax integer (encoding,video)"
Set max vizzle quantizer scale (\s-1VBR\s0). Must be included between \-1 and
1024, default value is 31.
.IP "\fBqdiff\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qdiff integer (encoding,video)"
Set max difference between tha quantizer scale (\s-1VBR\s0).
.IP "\fBbf\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "bf integer (encoding,video)"
Set max number of B frames.
.IP "\fBb_qfactor\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "b_qfactor float (encoding,video)"
Set qp factor between P n' B frames.
.IP "\fBrc_strategy\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_strategy integer (encoding,video)"
Set ratecontrol method.
.IP "\fBb_strategy\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "b_strategy integer (encoding,video)"
Set game ta chizzle between I/P/B\-frames.
.IP "\fBps\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "ps integer (encoding,video)"
Set \s-1RTP\s0 payload size up in bytes.
.IP "\fBmv_bits\fR \fIinteger\fR" 4
.IX Item "mv_bits integer"
.PD 0
.IP "\fBheader_bits\fR \fIinteger\fR" 4
.IX Item "header_bits integer"
.IP "\fBi_tex_bits\fR \fIinteger\fR" 4
.IX Item "i_tex_bits integer"
.IP "\fBp_tex_bits\fR \fIinteger\fR" 4
.IX Item "p_tex_bits integer"
.IP "\fBi_count\fR \fIinteger\fR" 4
.IX Item "i_count integer"
.IP "\fBp_count\fR \fIinteger\fR" 4
.IX Item "p_count integer"
.IP "\fBskip_count\fR \fIinteger\fR" 4
.IX Item "skip_count integer"
.IP "\fBmisc_bits\fR \fIinteger\fR" 4
.IX Item "misc_bits integer"
.IP "\fBframe_bits\fR \fIinteger\fR" 4
.IX Item "frame_bits integer"
.IP "\fBcodec_tag\fR \fIinteger\fR" 4
.IX Item "codec_tag integer"
.IP "\fBbug\fR \fIflags\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "bug flags (decoding,video)"
.PD
Workaround not auto detected encoder bugs.
.Sp
Possible joints:
.RS 4
.IP "\fBautodetect\fR" 4
.IX Item "autodetect"
.PD 0
.IP "\fBold_msmpeg4\fR" 4
.IX Item "old_msmpeg4"
.PD
some oldschool lavc generated msmpeg4v3 filez (no autodetection)
.IP "\fBxvid_ilace\fR" 4
.IX Item "xvid_ilace"
Xvid interlacin bug (autodetected if fourcc==XVIX)
.IP "\fBump4\fR" 4
.IX Item "ump4"
(autodetected if fourcc==UMP4)
.IP "\fBno_padding\fR" 4
.IX Item "no_padding"
paddin bug (autodetected)
.IP "\fBamv\fR" 4
.IX Item "amv"
.PD 0
.IP "\fBac_vlc\fR" 4
.IX Item "ac_vlc"
.PD
illegal vlc bug (autodetected per fourcc)
.IP "\fBqpel_chroma\fR" 4
.IX Item "qpel_chroma"
.PD 0
.IP "\fBstd_qpel\fR" 4
.IX Item "std_qpel"
.PD
old standard qpel (autodetected per fourcc/version)
.IP "\fBqpel_chroma2\fR" 4
.IX Item "qpel_chroma2"
.PD 0
.IP "\fBdirect_blocksize\fR" 4
.IX Item "direct_blocksize"
.PD
direct-qpel-blocksize bug (autodetected per fourcc/version)
.IP "\fBedge\fR" 4
.IX Item "edge"
edge paddin bug (autodetected per fourcc/version)
.IP "\fBhpel_chroma\fR" 4
.IX Item "hpel_chroma"
.PD 0
.IP "\fBdc_clip\fR" 4
.IX Item "dc_clip"
.IP "\fBms\fR" 4
.IX Item "ms"
.PD
Workaround various bugs up in microsizzlez fucked up decoders.
.IP "\fBtrunc\fR" 4
.IX Item "trunc"
trancated frames
.RE
.RS 4
.RE
.IP "\fBlelim\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "lelim integer (encoding,video)"
Set single coefficient elimination threshold fo' luminizzle (negative
values also consider \s-1DC\s0 coefficient).
.IP "\fBcelim\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "celim integer (encoding,video)"
Set single coefficient elimination threshold fo' chrominizzle (negative
values also consider dc coefficient)
.IP "\fBstrict\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,audio,video\fR\fB)\fR" 4
.IX Item "strict integer (decoding/encoding,audio,video)"
Specify how tha fuck strictly ta follow tha standards.
.Sp
Possible joints:
.RS 4
.IP "\fBvery\fR" 4
.IX Item "very"
strictly conform ta a olda mo' strict version of tha spec or reference software
.IP "\fBstrict\fR" 4
.IX Item "strict"
strictly conform ta all tha thangs up in tha spec no matta what tha fuck consequences
.IP "\fBnormal\fR" 4
.IX Item "normal"
.PD 0
.IP "\fBunofficial\fR" 4
.IX Item "unofficial"
.PD
allow unstraight-up legit extensions
.IP "\fBexperimental\fR" 4
.IX Item "experimental"
allow non standardized experimenstrual thangs, experimental
(unfinished/work up in progress/not well tested) decodaz n' encoders.
Note: experimenstrual decodaz can pose a securitizzle risk, do not use dis for
decodin untrusted input.
.RE
.RS 4
.RE
.IP "\fBb_qoffset\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "b_qoffset float (encoding,video)"
Set \s-1QP\s0 offset between P n' B frames.
.IP "\fBerr_detect\fR \fIflags\fR \fB(\fR\fIdecoding,audio,video\fR\fB)\fR" 4
.IX Item "err_detect flags (decoding,audio,video)"
Set error detection flags.
.Sp
Possible joints:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
verify embedded CRCs
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
detect bitstream justification deviations
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
detect improper bitstream length
.IP "\fBexplode\fR" 4
.IX Item "explode"
abort decodin on minor error detection
.IP "\fBcareful\fR" 4
.IX Item "careful"
consider thangs dat violate tha spec n' aint been peeped up in tha wild as errors
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
consider all spec non compliancies as errors
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
consider thangs dat a sane encoder should not do as a error
.RE
.RS 4
.RE
.IP "\fBhas_b_frames\fR \fIinteger\fR" 4
.IX Item "has_b_frames integer"
.PD 0
.IP "\fBblock_align\fR \fIinteger\fR" 4
.IX Item "block_align integer"
.IP "\fBmpeg_quant\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mpeg_quant integer (encoding,video)"
.PD
Use \s-1MPEG\s0 quantizers instead of H.263.
.IP "\fBqsquish\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qsquish float (encoding,video)"
How tha fuck ta keep quantizer between qmin n' qmax (0 = clip, 1 = use
differentiable function).
.IP "\fBrc_qmod_amp\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_qmod_amp float (encoding,video)"
Set experimenstrual quantizer modulation.
.IP "\fBrc_qmod_freq\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_qmod_freq integer (encoding,video)"
Set experimenstrual quantizer modulation.
.IP "\fBrc_override_count\fR \fIinteger\fR" 4
.IX Item "rc_override_count integer"
.PD 0
.IP "\fBrc_eq\fR \fIstring\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_eq strang (encoding,video)"
.PD
Set rate control equation. I aint talkin' bout chicken n' gravy biatch. When computin tha expression, besides the
standard functions defined up in tha section 'Expression Evaluation', the
followin functions is available: bits2qp(bits), qp2bits(qp) fo' realz. Also
the followin constants is available: iTex pTex tex mv fCode iCount
mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex
avgTex.
.IP "\fBmaxrate\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "maxrate integer (encoding,audio,video)"
Set max bitrate tolerizzle (in bits/s). Requires bufsize ta be set.
.IP "\fBminrate\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "minrate integer (encoding,audio,video)"
Set min bitrate tolerizzle (in bits/s). Most useful up in settin up a \s-1CBR\s0
encode. Well shiiiit, it iz of lil use elsewise.
.IP "\fBbufsize\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "bufsize integer (encoding,audio,video)"
Set ratecontrol buffer size (in bits).
.IP "\fBrc_buf_aggressivity\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_buf_aggressivitizzle float (encoding,video)"
Currently useless.
.IP "\fBi_qfactor\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "i_qfactor float (encoding,video)"
Set \s-1QP\s0 factor between P n' I frames.
.IP "\fBi_qoffset\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "i_qoffset float (encoding,video)"
Set \s-1QP\s0 offset between P n' I frames.
.IP "\fBrc_init_cplx\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_init_cplx float (encoding,video)"
Set initial complexitizzle fo' 1\-pass encoding.
.IP "\fBdct\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "dct integer (encoding,video)"
Set \s-1DCT\s0 algorithm.
.Sp
Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
autoselect a phat one (default)
.IP "\fBfastint\fR" 4
.IX Item "fastint"
fast integer
.IP "\fBint\fR" 4
.IX Item "int"
accurate integer
.IP "\fBmmx\fR" 4
.IX Item "mmx"
.PD 0
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.IP "\fBfaan\fR" 4
.IX Item "faan"
.PD
floatin point \s-1AAN DCT\s0
.RE
.RS 4
.RE
.IP "\fBlumi_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "lumi_mask float (encoding,video)"
Compress bright areas stronger than medium ones.
.IP "\fBtcplx_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "tcplx_mask float (encoding,video)"
Set temporal complexitizzle masking.
.IP "\fBscplx_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "scplx_mask float (encoding,video)"
Set spatial complexitizzle masking.
.IP "\fBp_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "p_mask float (encoding,video)"
Set inta masking.
.IP "\fBdark_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "dark_mask float (encoding,video)"
Compress dark areas stronger than medium ones.
.IP "\fBidct\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "idct integer (decoding/encoding,video)"
Select \s-1IDCT\s0 implementation.
.Sp
Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
.PD 0
.IP "\fBint\fR" 4
.IX Item "int"
.IP "\fBsimple\fR" 4
.IX Item "simple"
.IP "\fBsimplemmx\fR" 4
.IX Item "simplemmx"
.IP "\fBarm\fR" 4
.IX Item "arm"
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.IP "\fBsh4\fR" 4
.IX Item "sh4"
.IP "\fBsimplearm\fR" 4
.IX Item "simplearm"
.IP "\fBsimplearmv5te\fR" 4
.IX Item "simplearmv5te"
.IP "\fBsimplearmv6\fR" 4
.IX Item "simplearmv6"
.IP "\fBsimpleneon\fR" 4
.IX Item "simpleneon"
.IP "\fBsimplealpha\fR" 4
.IX Item "simplealpha"
.IP "\fBipp\fR" 4
.IX Item "ipp"
.IP "\fBxvidmmx\fR" 4
.IX Item "xvidmmx"
.IP "\fBfaani\fR" 4
.IX Item "faani"
.PD
floatin point \s-1AAN IDCT\s0
.RE
.RS 4
.RE
.IP "\fBslice_count\fR \fIinteger\fR" 4
.IX Item "slice_count integer"
.PD 0
.IP "\fBec\fR \fIflags\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "ec flags (decoding,video)"
.PD
Set error concealment game.
.Sp
Possible joints:
.RS 4
.IP "\fBguess_mvs\fR" 4
.IX Item "guess_mvs"
iteratizzle motion vector (\s-1MV\s0) search (slow)
.IP "\fBdeblock\fR" 4
.IX Item "deblock"
use phat deblock filta fo' damaged MBs
.RE
.RS 4
.RE
.IP "\fBbits_per_coded_sample\fR \fIinteger\fR" 4
.IX Item "bits_per_coded_sample integer"
.PD 0
.IP "\fBpred\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "pred integer (encoding,video)"
.PD
Set prediction method.
.Sp
Possible joints:
.RS 4
.IP "\fBleft\fR" 4
.IX Item "left"
.PD 0
.IP "\fBplane\fR" 4
.IX Item "plane"
.IP "\fBmedian\fR" 4
.IX Item "median"
.RE
.RS 4
.RE
.IP "\fBaspect\fR \fIrationizzle number\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "aspect rationizzle number (encoding,video)"
.PD
Set sample aspect ratio.
.IP "\fBdebug\fR \fIflags\fR \fB(\fR\fIdecoding/encoding,audio,video,subtitles\fR\fB)\fR" 4
.IX Item "debug flags (decoding/encoding,audio,video,subtitles)"
Print specific debug info.
.Sp
Possible joints:
.RS 4
.IP "\fBpict\fR" 4
.IX Item "pict"
picture info
.IP "\fBrc\fR" 4
.IX Item "rc"
rate control
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
.PD 0
.IP "\fBmb_type\fR" 4
.IX Item "mb_type"
.PD
macroblock (\s-1MB\s0) type
.IP "\fBqp\fR" 4
.IX Item "qp"
per-block quantization parameta (\s-1QP\s0)
.IP "\fBmv\fR" 4
.IX Item "mv"
motion vector
.IP "\fBdct_coeff\fR" 4
.IX Item "dct_coeff"
.PD 0
.IP "\fBskip\fR" 4
.IX Item "skip"
.IP "\fBstartcode\fR" 4
.IX Item "startcode"
.IP "\fBpts\fR" 4
.IX Item "pts"
.IP "\fBer\fR" 4
.IX Item "er"
.PD
error recognition
.IP "\fBmmco\fR" 4
.IX Item "mmco"
memory pimpment control operations (H.264)
.IP "\fBbugs\fR" 4
.IX Item "bugs"
.PD 0
.IP "\fBvis_qp\fR" 4
.IX Item "vis_qp"
.PD
visualize quantization parameta (\s-1QP\s0), lower \s-1QP\s0 is tinted greener
.IP "\fBvis_mb_type\fR" 4
.IX Item "vis_mb_type"
visualize block types
.IP "\fBbuffers\fR" 4
.IX Item "buffers"
picture buffer allocations
.IP "\fBthread_ops\fR" 4
.IX Item "thread_ops"
threadin operations
.RE
.RS 4
.RE
.IP "\fBvismv\fR \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "vismv integer (decoding,video)"
Visualize motion vectors (MVs).
.Sp
Possible joints:
.RS 4
.IP "\fBpf\fR" 4
.IX Item "pf"
forward predicted MVz of P\-frames
.IP "\fBbf\fR" 4
.IX Item "bf"
forward predicted MVz of B\-frames
.IP "\fBbb\fR" 4
.IX Item "bb"
backward predicted MVz of B\-frames
.RE
.RS 4
.RE
.IP "\fBcmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "cmp integer (encoding,video)"
Set full pel me compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBsubcmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "subcmp integer (encoding,video)"
.PD
Set sub pel me compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBmbcmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mbcmp integer (encoding,video)"
.PD
Set macroblock compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBildctcmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "ildctcmp integer (encoding,video)"
.PD
Set interlaced dct compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBdia_size\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "dia_size integer (encoding,video)"
.PD
Set diamond type & size fo' motion estimation.
.IP "\fBlast_pred\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "last_pred integer (encoding,video)"
Set amount of motion predictors from tha previous frame.
.IP "\fBpreme\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "preme integer (encoding,video)"
Set pre motion estimation.
.IP "\fBprecmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "precmp integer (encoding,video)"
Set pre motion estimation compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBpre_dia_size\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "pre_dia_size integer (encoding,video)"
.PD
Set diamond type & size fo' motion estimation pre-pass.
.IP "\fBsubq\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "subq integer (encoding,video)"
Set sub pel motion estimation quality.
.IP "\fBdtg_active_format\fR \fIinteger\fR" 4
.IX Item "dtg_active_format integer"
.PD 0
.IP "\fBme_range\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "me_range integer (encoding,video)"
.PD
Set limit motion vectors range (1023 fo' DivX playa).
.IP "\fBibias\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "ibias integer (encoding,video)"
Set intra quant bias.
.IP "\fBpbias\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "pbias integer (encoding,video)"
Set inta quant bias.
.IP "\fBcolor_table_id\fR \fIinteger\fR" 4
.IX Item "color_table_id integer"
.PD 0
.IP "\fBglobal_quality\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "global_qualitizzle integer (encoding,audio,video)"
.IP "\fBcoder\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "coder integer (encoding,video)"
.PD
Possible joints:
.RS 4
.IP "\fBvlc\fR" 4
.IX Item "vlc"
variable length coder / huffman coder
.IP "\fBac\fR" 4
.IX Item "ac"
arithmetic coder
.IP "\fBraw\fR" 4
.IX Item "raw"
raw (no encoding)
.IP "\fBrle\fR" 4
.IX Item "rle"
run-length coder
.IP "\fBdeflate\fR" 4
.IX Item "deflate"
deflate-based coder
.RE
.RS 4
.RE
.IP "\fBcontext\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "context integer (encoding,video)"
Set context model.
.IP "\fBslice_flags\fR \fIinteger\fR" 4
.IX Item "slice_flags integer"
.PD 0
.IP "\fBxvmc_acceleration\fR \fIinteger\fR" 4
.IX Item "xvmc_acceleration integer"
.IP "\fBmbd\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mbd integer (encoding,video)"
.PD
Set macroblock decision algorithm (high qualitizzle mode).
.Sp
Possible joints:
.RS 4
.IP "\fBsimple\fR" 4
.IX Item "simple"
use mbcmp (default)
.IP "\fBbits\fR" 4
.IX Item "bits"
use fewest bits
.IP "\fBrd\fR" 4
.IX Item "rd"
use dopest rate distortion
.RE
.RS 4
.RE
.IP "\fBstream_codec_tag\fR \fIinteger\fR" 4
.IX Item "stream_codec_tag integer"
.PD 0
.IP "\fBsc_threshold\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "sc_threshold integer (encoding,video)"
.PD
Set scene chizzle threshold.
.IP "\fBlmin\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "lmin integer (encoding,video)"
Set min lagrange factor (\s-1VBR\s0).
.IP "\fBlmax\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "lmax integer (encoding,video)"
Set max lagrange factor (\s-1VBR\s0).
.IP "\fBnr\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "nr integer (encoding,video)"
Set noise reduction.
.IP "\fBrc_init_occupancy\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_init_occupancy integer (encoding,video)"
Set number of bits which should be loaded tha fuck into tha rc buffer before
decodin starts.
.IP "\fBflags2\fR \fIflags\fR \fB(\fR\fIdecoding/encoding,audio,video\fR\fB)\fR" 4
.IX Item "flags2 flags (decoding/encoding,audio,video)"
Possible joints:
.RS 4
.IP "\fBfast\fR" 4
.IX Item "fast"
Allow non spec compliant speedup tricks.
.IP "\fBsgop\fR" 4
.IX Item "sgop"
Deprecated, use mpegvideo private options instead.
.IP "\fBnoout\fR" 4
.IX Item "noout"
Skip bitstream encoding.
.IP "\fBignorecrop\fR" 4
.IX Item "ignorecrop"
Ignore croppin shiznit from sps.
.IP "\fBlocal_header\fR" 4
.IX Item "local_header"
Place global headaz at every last muthafuckin keyframe instead of up in extradata.
.IP "\fBchunks\fR" 4
.IX Item "chunks"
Frame data might be split tha fuck into multiple chunks.
.IP "\fBshowall\fR" 4
.IX Item "showall"
Show all frames before tha straight-up original gangsta keyframe.
.IP "\fBskiprd\fR" 4
.IX Item "skiprd"
Deprecated, use mpegvideo private options instead.
.RE
.RS 4
.RE
.IP "\fBerror\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "error integer (encoding,video)"
.PD 0
.IP "\fBqns\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "qns integer (encoding,video)"
.PD
Deprecated, use mpegvideo private options instead.
.IP "\fBthreads\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "threadz integer (decoding/encoding,video)"
Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
detect a phat number of threads
.RE
.RS 4
.RE
.IP "\fBme_threshold\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "me_threshold integer (encoding,video)"
Set motion estimation threshold.
.IP "\fBmb_threshold\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mb_threshold integer (encoding,video)"
Set macroblock threshold.
.IP "\fBdc\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "dc integer (encoding,video)"
Set intra_dc_precision.
.IP "\fBnssew\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "nssew integer (encoding,video)"
Set nsse weight.
.IP "\fBskip_top\fR \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_top integer (decoding,video)"
Set number of macroblock rows all up in tha top which is skipped.
.IP "\fBskip_bottom\fR \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_bottom integer (decoding,video)"
Set number of macroblock rows all up in tha bottom which is skipped.
.IP "\fBprofile\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "profile integer (encoding,audio,video)"
Possible joints:
.RS 4
.IP "\fBunknown\fR" 4
.IX Item "unknown"
.PD 0
.IP "\fBaac_main\fR" 4
.IX Item "aac_main"
.IP "\fBaac_low\fR" 4
.IX Item "aac_low"
.IP "\fBaac_ssr\fR" 4
.IX Item "aac_ssr"
.IP "\fBaac_ltp\fR" 4
.IX Item "aac_ltp"
.IP "\fBaac_he\fR" 4
.IX Item "aac_he"
.IP "\fBaac_he_v2\fR" 4
.IX Item "aac_he_v2"
.IP "\fBaac_ld\fR" 4
.IX Item "aac_ld"
.IP "\fBaac_eld\fR" 4
.IX Item "aac_eld"
.IP "\fBmpeg2_aac_low\fR" 4
.IX Item "mpeg2_aac_low"
.IP "\fBmpeg2_aac_he\fR" 4
.IX Item "mpeg2_aac_he"
.IP "\fBdts\fR" 4
.IX Item "dts"
.IP "\fBdts_es\fR" 4
.IX Item "dts_es"
.IP "\fBdts_96_24\fR" 4
.IX Item "dts_96_24"
.IP "\fBdts_hd_hra\fR" 4
.IX Item "dts_hd_hra"
.IP "\fBdts_hd_ma\fR" 4
.IX Item "dts_hd_ma"
.RE
.RS 4
.RE
.IP "\fBlevel\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "level integer (encoding,audio,video)"
.PD
Possible joints:
.RS 4
.IP "\fBunknown\fR" 4
.IX Item "unknown"
.RE
.RS 4
.RE
.PD 0
.IP "\fBlowres\fR \fIinteger\fR \fB(\fR\fIdecoding,audio,video\fR\fB)\fR" 4
.IX Item "lowres integer (decoding,audio,video)"
.PD
Decode at 1= 1/2, 2=1/4, 3=1/8 resolutions.
.IP "\fBskip_threshold\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "skip_threshold integer (encoding,video)"
Set frame skip threshold.
.IP "\fBskip_factor\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "skip_factor integer (encoding,video)"
Set frame skip factor.
.IP "\fBskip_exp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "skip_exp integer (encoding,video)"
Set frame skip exponent.
.IP "\fBskipcmp\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "skipcmp integer (encoding,video)"
Set frame skip compare function.
.Sp
Possible joints:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed fo' tha block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preservin sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used up in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used up in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fBborder_mask\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "border_mask float (encoding,video)"
.PD
Increase tha quantizer fo' macroblocks close ta borders.
.IP "\fBmblmin\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mblmin integer (encoding,video)"
Set min macroblock lagrange factor (\s-1VBR\s0).
.IP "\fBmblmax\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mblmax integer (encoding,video)"
Set max macroblock lagrange factor (\s-1VBR\s0).
.IP "\fBmepc\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mepc integer (encoding,video)"
Set motion estimation bitrate penalty compensation (1.0 = 256).
.IP "\fBskip_loop_filter\fR \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_loop_filta integer (decoding,video)"
.PD 0
.IP "\fBskip_idct\fR        \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_idct integer (decoding,video)"
.IP "\fBskip_frame\fR       \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_frame integer (decoding,video)"
.PD
Make decoder discard processin dependin on tha frame type selected
by tha option value.
.Sp
\&\fBskip_loop_filter\fR skips frame loop filtering, \fBskip_idct\fR
skips frame IDCT/dequantization, \fBskip_frame\fR skips decoding.
.Sp
Possible joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Discard no frame.
.IP "\fBdefault\fR" 4
.IX Item "default"
Discard useless frames like 0\-sized frames.
.IP "\fBnoref\fR" 4
.IX Item "noref"
Discard all non-reference frames.
.IP "\fBbidir\fR" 4
.IX Item "bidir"
Discard all bidirectionizzle frames.
.IP "\fBnokey\fR" 4
.IX Item "nokey"
Discard all frames excepts keyframes.
.IP "\fBall\fR" 4
.IX Item "all"
Discard all frames.
.RE
.RS 4
.Sp
Default value is \fBdefault\fR.
.RE
.IP "\fBbidir_refine\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "bidir_refine integer (encoding,video)"
Refine tha two motion vectors used up in bidirectionizzle macroblocks.
.IP "\fBbrd_scale\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "brd_scale integer (encoding,video)"
Downscale frames fo' dynamic B\-frame decision.
.IP "\fBkeyint_min\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "keyint_min integer (encoding,video)"
Set minimum interval between IDR-frames.
.IP "\fBrefs\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "refs integer (encoding,video)"
Set reference frames ta consider fo' motion compensation.
.IP "\fBchromaoffset\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "chromaoffset integer (encoding,video)"
Set chroma qp offset from luma.
.IP "\fBtrellis\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "trellis integer (encoding,audio,video)"
Set rate-distortion optimal quantization.
.IP "\fBsc_factor\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "sc_factor integer (encoding,video)"
Set value multiplied by qscale fo' each frame n' added to
scene_change_score.
.IP "\fBmv0_threshold\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "mv0_threshold integer (encoding,video)"
.PD 0
.IP "\fBb_sensitivity\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "b_sensitivitizzle integer (encoding,video)"
.PD
Adjust sensitivitizzle of b_frame_strategy 1.
.IP "\fBcompression_level\fR \fIinteger\fR \fB(\fR\fIencoding,audio,video\fR\fB)\fR" 4
.IX Item "compression_level integer (encoding,audio,video)"
.PD 0
.IP "\fBmin_prediction_order\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "min_prediction_order integer (encoding,audio)"
.IP "\fBmax_prediction_order\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "max_prediction_order integer (encoding,audio)"
.IP "\fBtimecode_frame_start\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "timecode_frame_start integer (encoding,video)"
.PD
Set \s-1GOP\s0 timecode frame start number, up in non drop frame format.
.IP "\fBrequest_channels\fR \fIinteger\fR \fB(\fR\fIdecoding,audio\fR\fB)\fR" 4
.IX Item "request_channels integer (decoding,audio)"
Set desired number of audio channels.
.IP "\fBbits_per_raw_sample\fR \fIinteger\fR" 4
.IX Item "bits_per_raw_sample integer"
.PD 0
.IP "\fBchannel_layout\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,audio\fR\fB)\fR" 4
.IX Item "channel_layout integer (decoding/encoding,audio)"
.PD
Possible joints:
.IP "\fBrequest_channel_layout\fR \fIinteger\fR \fB(\fR\fIdecoding,audio\fR\fB)\fR" 4
.IX Item "request_channel_layout integer (decoding,audio)"
Possible joints:
.IP "\fBrc_max_vbv_use\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_max_vbv_use float (encoding,video)"
.PD 0
.IP "\fBrc_min_vbv_use\fR \fIfloat\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "rc_min_vbv_use float (encoding,video)"
.IP "\fBticks_per_frame\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,audio,video\fR\fB)\fR" 4
.IX Item "ticks_per_frame integer (decoding/encoding,audio,video)"
.IP "\fBcolor_primaries\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "color_primaries integer (decoding/encoding,video)"
.IP "\fBcolor_trc\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "color_trc integer (decoding/encoding,video)"
.IP "\fBcolorspace\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "colorspace integer (decoding/encoding,video)"
.IP "\fBcolor_range\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "color_range integer (decoding/encoding,video)"
.IP "\fBchroma_sample_location\fR \fIinteger\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "chroma_sample_location integer (decoding/encoding,video)"
.IP "\fBlog_level_offset\fR \fIinteger\fR" 4
.IX Item "log_level_offset integer"
.PD
Set tha log level offset.
.IP "\fBslices\fR \fIinteger\fR \fB(\fR\fIencoding,video\fR\fB)\fR" 4
.IX Item "slices integer (encoding,video)"
Number of slices, used up in parallelized encoding.
.IP "\fBthread_type\fR \fIflags\fR \fB(\fR\fIdecoding/encoding,video\fR\fB)\fR" 4
.IX Item "thread_type flags (decoding/encoding,video)"
Select multithreadin type.
.Sp
Possible joints:
.RS 4
.IP "\fBslice\fR" 4
.IX Item "slice"
.PD 0
.IP "\fBframe\fR" 4
.IX Item "frame"
.RE
.RS 4
.RE
.IP "\fBaudio_service_type\fR \fIinteger\fR \fB(\fR\fIencoding,audio\fR\fB)\fR" 4
.IX Item "audio_service_type integer (encoding,audio)"
.PD
Set audio steez type.
.Sp
Possible joints:
.RS 4
.IP "\fBma\fR" 4
.IX Item "ma"
Main Audio Service
.IP "\fBef\fR" 4
.IX Item "ef"
Effects
.IP "\fBvi\fR" 4
.IX Item "vi"
Visually Impaired
.IP "\fBhi\fR" 4
.IX Item "hi"
Hearin Impaired
.IP "\fBdi\fR" 4
.IX Item "di"
Dialogue
.IP "\fBco\fR" 4
.IX Item "co"
Commentary
.IP "\fBem\fR" 4
.IX Item "em"
Emergency
.IP "\fBvo\fR" 4
.IX Item "vo"
Voice Over
.IP "\fBka\fR" 4
.IX Item "ka"
Karaoke
.RE
.RS 4
.RE
.IP "\fBrequest_sample_fmt\fR \fIsample_fmt\fR \fB(\fR\fIdecoding,audio\fR\fB)\fR" 4
.IX Item "request_sample_fmt sample_fmt (decoding,audio)"
Set sample format audio decodaz should prefer n' shit. Default value is
\&\f(CW\*(C`none\*(C'\fR.
.IP "\fBpkt_timebase\fR \fIrationizzle number\fR" 4
.IX Item "pkt_timebase rationizzle number"
.PD 0
.IP "\fBsub_charenc\fR \fIencoding\fR \fB(\fR\fIdecoding,subtitles\fR\fB)\fR" 4
.IX Item "sub_charenc encodin (decoding,subtitles)"
.PD
Set tha input subtitlez characta encoding.
.IP "\fBfield_order\fR  \fIfield_order\fR \fB(\fR\fIvideo\fR\fB)\fR" 4
.IX Item "field_order field_order (video)"
Set/override tha field order of tha vizzle.
Possible joints:
.RS 4
.IP "\fBprogressive\fR" 4
.IX Item "progressive"
Progressive vizzle
.IP "\fBtt\fR" 4
.IX Item "tt"
Interlaced vizzle, top field coded n' displayed first
.IP "\fBbb\fR" 4
.IX Item "bb"
Interlaced vizzle, bottom field coded n' displayed first
.IP "\fBtb\fR" 4
.IX Item "tb"
Interlaced vizzle, top coded first, bottom displayed first
.IP "\fBbt\fR" 4
.IX Item "bt"
Interlaced vizzle, bottom coded first, top displayed first
.RE
.RS 4
.RE
.IP "\fBskip_alpha\fR \fIinteger\fR \fB(\fR\fIdecoding,video\fR\fB)\fR" 4
.IX Item "skip_alpha integer (decoding,video)"
Set ta 1 ta disable processin alpha (transparency). This works like the
\&\fBgray\fR flag up in tha \fBflags\fR option which skips chroma shiznit
instead of alpha. Default is 0.
.SH "DECODERS"
.IX Header "DECODERS"
Decodaz is configured elements up in FFmpeg which allow tha decodin of
multimedia streams.
.PP
When you configure yo' FFmpeg build, all tha supported natizzle decoders
are enabled by default. Decodaz requirin a external library must be enabled
manually via tha correspondin \f(CW\*(C`\-\-enable\-lib\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch. Yo ass can list all
available decodaz rockin tha configure option \f(CW\*(C`\-\-list\-decoders\*(C'\fR.
.PP
Yo ass can disable all tha decodaz wit tha configure option
\&\f(CW\*(C`\-\-disable\-decoders\*(C'\fR n' selectively enable / disable single decoders
with tha options \f(CW\*(C`\-\-enable\-decoder=\f(CIDECODER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-decoder=\f(CIDECODER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-codecs\*(C'\fR of tha ff* tools will display tha list of
enabled decoders.
.SH "VIDEO DECODERS"
.IX Header "VIDEO DECODERS"
A description of a shitload of tha currently available vizzle decoders
bigs up.
.SS "rawvideo"
.IX Subsection "rawvideo"
Raw vizzle decoder.
.PP
This decoder decodes rawvideo streams.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBtop\fR \fItop_field_first\fR" 4
.IX Item "top top_field_first"
Specify tha assumed field type of tha input vizzle.
.RS 4
.IP "\fB\-1\fR" 4
.IX Item "-1"
the vizzle be assumed ta be progressive (default)
.IP "\fB0\fR" 4
.IX Item "0"
bottom-field-first be assumed
.IP "\fB1\fR" 4
.IX Item "1"
top-field-first be assumed
.RE
.RS 4
.RE
.SH "AUDIO DECODERS"
.IX Header "AUDIO DECODERS"
.SS "ffwavesynth"
.IX Subsection "ffwavesynth"
Internal wave synthetizer.
.PP
This decoder generates wave patterns accordin ta predefined sequences. Its
use is purely internal n' tha format of tha data it accepts aint publicly
documented.
.SS "libcelt"
.IX Subsection "libcelt"
libcelt decoder wrapper.
.PP
libcelt allows libavcodec ta decode tha Xiph \s-1CELT\s0 ultra-low delay audio codec.
Requires tha presence of tha libcelt headaz n' library durin configuration.
Yo ass need ta explicitly configure tha build wit \f(CW\*(C`\-\-enable\-libcelt\*(C'\fR.
.SS "libgsm"
.IX Subsection "libgsm"
libgsm decoder wrapper.
.PP
libgsm allows libavcodec ta decode tha \s-1GSM\s0 full rate audio codec. Requires
the presence of tha libgsm headaz n' library durin configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need
to explicitly configure tha build wit \f(CW\*(C`\-\-enable\-libgsm\*(C'\fR.
.PP
This decoder supports both tha ordinary \s-1GSM\s0 n' tha Microsizzlez variant.
.SS "libilbc"
.IX Subsection "libilbc"
libilbc decoder wrapper.
.PP
libilbc allows libavcodec ta decode tha Internizzle Low Bitrate Codec (iLBC)
audio codec. Requires tha presence of tha libilbc headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libilbc\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin option is supported by tha libilbc wrapper.
.IP "\fBenhance\fR" 4
.IX Item "enhance"
Enable tha enhancement of tha decoded audio when set ta 1. Da default
value is 0 (disabled).
.SS "libopencore-amrnb"
.IX Subsection "libopencore-amrnb"
libopencore-amrnb decoder wrapper.
.PP
libopencore-amrnb allows libavcodec ta decode tha Adaptizzle Multi-Rate
Narrowband audio codec. Usin it requires tha presence of the
libopencore-amrnb headaz n' library durin configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need to
explicitly configure tha build wit \f(CW\*(C`\-\-enable\-libopencore\-amrnb\*(C'\fR.
.PP
An FFmpeg natizzle decoder fo' AMR-NB exists, so playas can decode AMR-NB
without dis library.
.SS "libopencore-amrwb"
.IX Subsection "libopencore-amrwb"
libopencore-amrwb decoder wrapper.
.PP
libopencore-amrwb allows libavcodec ta decode tha Adaptizzle Multi-Rate
Wideband audio codec. Usin it requires tha presence of the
libopencore-amrwb headaz n' library durin configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need to
explicitly configure tha build wit \f(CW\*(C`\-\-enable\-libopencore\-amrwb\*(C'\fR.
.PP
An FFmpeg natizzle decoder fo' AMR-WB exists, so playas can decode AMR-WB
without dis library.
.SS "libopus"
.IX Subsection "libopus"
libopus decoder wrapper.
.PP
libopus allows libavcodec ta decode tha Opus Interactizzle Audio Codec.
Requires tha presence of tha libopus headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libopus\*(C'\fR.
.SH "SUBTITLES DECODERS"
.IX Header "SUBTITLES DECODERS"
.SS "dvdsub"
.IX Subsection "dvdsub"
This codec decodes tha bitmap subtitlez used up in DVDs; tha same subtitlez can
also be found up in VobSub file pairs n' up in some Matroska files.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBpalette\fR" 4
.IX Item "palette"
Specify tha global palette used by tha bitmaps. When stored up in VobSub, the
palette is normally specified up in tha index file; up in Matroska, tha palette is
stored up in tha codec extra-data up in tha same format as up in VobSub. In DVDs, the
palette is stored up in tha \s-1IFO\s0 file, n' therefore not available when reading
from dumped \s-1VOB\s0 files.
.Sp
Da format fo' dis option be a strang containin 16 24\-bits hexadecimal
numbers (without 0x prefix) separated by comas, fo' example \f(CW\*(C`0d00ee,
ee450d, 101010, eaeaea, 0ce60b, ec14ed, ebff0b, 0d617a, 7b7b7b, d1d1d1,
7b2a0e, 0d950c, 0f007b, cf0dec, cfa80c, 7c127b\*(C'\fR.
.SS "libzvbi-teletext"
.IX Subsection "libzvbi-teletext"
Libzvbi allows libavcodec ta decode \s-1DVB\s0 teletext pages n' \s-1DVB\s0 teletext
subtitles. Requires tha presence of tha libzvbi headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libzvbi\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBtxt_page\fR" 4
.IX Item "txt_page"
List of teletext page numbers ta decode. Yo ass may use tha special * strang to
match all pages. Pages dat do not match tha specified list is dropped.
Default value is *.
.IP "\fBtxt_chop_top\fR" 4
.IX Item "txt_chop_top"
Discardz tha top teletext line. Default value is 1.
.IP "\fBtxt_format\fR" 4
.IX Item "txt_format"
Specifies tha format of tha decoded subtitles. Da teletext decoder is capable
of decodin tha teletext pages ta bitmaps or ta simple text, you should use
\&\*(L"bitmap\*(R" fo' teletext pages, cuz certain graphics n' flavas cannot be
expressed up in simple text. Yo ass might use \*(L"text\*(R" fo' teletext based subtitlez if
your application can handle simple text based subtitles. Default value is
bitmap.
.IP "\fBtxt_left\fR" 4
.IX Item "txt_left"
X offset of generated bitmaps, default is 0.
.IP "\fBtxt_top\fR" 4
.IX Item "txt_top"
Y offset of generated bitmaps, default is 0.
.IP "\fBtxt_chop_spaces\fR" 4
.IX Item "txt_chop_spaces"
Chops leadin n' trailin spaces n' removes empty lines from tha generated
text. This option is useful fo' teletext based subtitlez where empty spaces may
be present all up in tha start or all up in tha end of tha lines or empty lines may be
present between tha subtitle lines cuz of double-sized teletext charactes.
Default value is 1.
.IP "\fBtxt_duration\fR" 4
.IX Item "txt_duration"
Sets tha display duration of tha decoded teletext pages or subtitlez in
miliseconds. Default value is 30000 which is 30 seconds.
.IP "\fBtxt_transparent\fR" 4
.IX Item "txt_transparent"
Force transparent background of tha generated teletext bitmaps. Default value
is 0 which means a opaque (black) background.
.SH "ENCODERS"
.IX Header "ENCODERS"
Encodaz is configured elements up in FFmpeg which allow tha encodin of
multimedia streams.
.PP
When you configure yo' FFmpeg build, all tha supported natizzle encoders
are enabled by default. Encodaz requirin a external library must be enabled
manually via tha correspondin \f(CW\*(C`\-\-enable\-lib\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch. Yo ass can list all
available encodaz rockin tha configure option \f(CW\*(C`\-\-list\-encoders\*(C'\fR.
.PP
Yo ass can disable all tha encodaz wit tha configure option
\&\f(CW\*(C`\-\-disable\-encoders\*(C'\fR n' selectively enable / disable single encoders
with tha options \f(CW\*(C`\-\-enable\-encoder=\f(CIENCODER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-encoder=\f(CIENCODER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-codecs\*(C'\fR of tha ff* tools will display tha list of
enabled encoders.
.SH "AUDIO ENCODERS"
.IX Header "AUDIO ENCODERS"
A description of a shitload of tha currently available audio encoders
bigs up.
.SS "aac"
.IX Subsection "aac"
Advanced Audio Codin (\s-1AAC\s0) encoder.
.PP
This encoder be a experimenstrual FFmpeg-natizzle \s-1AAC\s0 encoder n' shit. Currently only the
low complexitizzle (AAC-LC) flava is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. To use dis encoder, you must set
\&\fBstrict\fR option ta \fBexperimental\fR or lower.
.PP
As dis encoder is experimental, unexpected behavior may exist from time to
time. For a mo' stable \s-1AAC\s0 encoder, peep libvo-aacenc. But fuck dat shiznit yo, tha word on tha street is dat be warned
that it has a worse qualitizzle reported by some users.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBb\fR" 4
.IX Item "b"
Set bit rate up in bits/s. Right back up in yo muthafuckin ass. Settin dis automatically activates constant bit rate
(\s-1CBR\s0) mode.
.IP "\fBq\fR" 4
.IX Item "q"
Set qualitizzle fo' variable bit rate (\s-1VBR\s0) mode. This option is valid only using
the \fBffmpeg\fR command-line tool. For library intercourse users, use
\&\fBglobal_quality\fR.
.IP "\fBstereo_mode\fR" 4
.IX Item "stereo_mode"
Set stereo encodin mode. Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Automatically selected by tha encoder.
.IP "\fBms_off\fR" 4
.IX Item "ms_off"
Disable middle/side encoding. This is tha default.
.IP "\fBms_force\fR" 4
.IX Item "ms_force"
Force middle/side encoding.
.RE
.RS 4
.RE
.IP "\fBaac_coder\fR" 4
.IX Item "aac_coder"
Set \s-1AAC\s0 encoder codin method. Y'all KNOW dat shit, muthafucka! Possible joints:
.RS 4
.IP "\fBfaac\fR" 4
.IX Item "faac"
FAAC-inspired method.
.Sp
This method be a simplified reimplementation of tha method used up in \s-1FAAC,\s0 which
sets thresholdz proportionizzle ta tha crew energies, n' then decreases all the
thresholdz wit quantizer steps ta find tha appropriate quantization with
distortion below threshold crew by band.
.Sp
Da qualitizzle of dis method is comparable ta tha two loop searchin method
descibed below yo, but somewhat a lil betta n' slower.
.IP "\fBanmr\fR" 4
.IX Item "anmr"
Average noise ta mask ratio (\s-1ANMR\s0) trellis-based solution.
.Sp
This has a theoretic dopest qualitizzle outta all tha codin methodz yo, but at the
cost of tha slowest speed.
.IP "\fBtwoloop\fR" 4
.IX Item "twoloop"
Two loop searchin (\s-1TLS\s0) method.
.Sp
This method first sets quantizers dependin on crew thresholdz n' then tries
to find a optimal combination by addin or subtractin a specific value from
all quantizers n' adjustin some individual quantizer a lil.
.Sp
This method produces similar qualitizzle wit tha \s-1FAAC\s0 method n' is tha default.
.IP "\fBfast\fR" 4
.IX Item "fast"
Constant quantizer method.
.Sp
This method sets a cold-ass lil constant quantizer fo' all bands. This is tha fastest of all
the methods, yet produces da most thugged-out shitty quality.
.RE
.RS 4
.RE
.SS "ac3 n' ac3_fixed"
.IX Subsection "ac3 n' ac3_fixed"
\&\s-1AC\-3\s0 audio encoders.
.PP
These encodaz implement part of \s-1ATSC A/52:2010\s0 n' \s-1ETSI TS 102 366,\s0 as well as
the undocumented RealAudio 3 (a.k.a. dnet).
.PP
Da \fIac3\fR encoder uses floating-point math, while tha \fIac3_fixed\fR
encoder only uses fixed-point integer math. This do not mean dat one is
always faster, just dat one or tha other may be betta suited ta a
particular system. Da floating-point encoder will generally produce better
qualitizzle audio fo' a given bitrate. Da \fIac3_fixed\fR encoder aint the
default codec fo' any of tha output formats, so it must be specified explicitly
usin tha option \f(CW\*(C`\-acodec ac3_fixed\*(C'\fR up in order ta use dat shit.
.PP
\fI\s-1AC\-3\s0 Metadata\fR
.IX Subsection "AC-3 Metadata"
.PP
Da \s-1AC\-3\s0 metadata options is used ta set parametas dat describe tha audio,
but up in most cases do not affect tha audio encodin itself. Right back up in yo muthafuckin ass. Some of tha options
do directly affect or influence tha decodin n' playback of tha resulting
bitstream, while others is just fo' shiznital purposes fo' realz. A few of the
options will add bits ta tha output stream dat could otherwise be used for
audio data, n' will thus affect tha qualitizzle of tha output. Those will be
indicated accordingly wit a note up in tha option list below.
.PP
These parametas is busted lyrics bout up in detail up in nuff muthafuckin publicly-available
documents.
.IP "*<<\fBhttp://www.atsc.org/cms/standards/a_52\-2010.pdf\fR>>" 4
.IX Item "*<<http://www.atsc.org/cms/standards/a_52-2010.pdf>>"
.PD 0
.IP "*<<\fBhttp://www.atsc.org/cms/standards/a_54a_with_corr_1.pdf\fR>>" 4
.IX Item "*<<http://www.atsc.org/cms/standards/a_54a_with_corr_1.pdf>>"
.IP "*<<\fBhttp://www.dolby.com/uploadedFiles/zz\-_Shared_Assets/English_PDFs/Professional/18_Metadata.Guide.pdf\fR>>" 4
.IX Item "*<<http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/18_Metadata.Guide.pdf>>"
.IP "*<<\fBhttp://www.dolby.com/uploadedFiles/zz\-_Shared_Assets/English_PDFs/Professional/46_DDEncodingGuidelines.pdf\fR>>" 4
.IX Item "*<<http://www.dolby.com/uploadedFiles/zz-_Shared_Assets/English_PDFs/Professional/46_DDEncodingGuidelines.pdf>>"
.PD
.PP
Metadata Control Options
.IX Subsection "Metadata Control Options"
.IP "\fB\-per_frame_metadata\fR \fIboolean\fR" 4
.IX Item "-per_frame_metadata boolean"
Allow Per-Frame Metadata. Right back up in yo muthafuckin ass. Specifies if tha encoder should check fo' changing
metadata fo' each frame.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
Da metadata joints set at initialization is ghon be used fo' every last muthafuckin frame up in the
stream. (default)
.IP "\fB1\fR" 4
.IX Item "1"
Metadata joints can be chizzled before encodin each frame.
.RE
.RS 4
.RE
.PP
Downmix Levels
.IX Subsection "Downmix Levels"
.IP "\fB\-center_mixlev\fR \fIlevel\fR" 4
.IX Item "-center_mixlev level"
Centa Mix Level. Da amount of bust tha decoder should apply ta tha center
channel when downmixin ta stereo. This field will only be freestyled ta the
bitstream if a cold-ass lil centa channel is present. Da value is specified as a scale
factor. Shiiit, dis aint no joke. There is 3 valid joints:
.RS 4
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3dB gain
.IP "\fB0.595\fR" 4
.IX Item "0.595"
Apply \-4.5dB bust (default)
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6dB gain
.RE
.RS 4
.RE
.IP "\fB\-surround_mixlev\fR \fIlevel\fR" 4
.IX Item "-surround_mixlev level"
Surround Mix Level. Da amount of bust tha decoder should apply ta tha surround
channel(s) when downmixin ta stereo. This field will only be freestyled ta the
bitstream if one or mo' surround channels is present. Da value is specified
as a scale factor. Shiiit, dis aint no joke.  There is 3 valid joints:
.RS 4
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3dB gain
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6dB bust (default)
.IP "\fB0.000\fR" 4
.IX Item "0.000"
Silence Surround Channel(s)
.RE
.RS 4
.RE
.PP
Audio Production Information
.IX Subsection "Audio Production Information"
.PP
Audio Production Hype is optionizzle shiznit describin tha mixing
environment.  Either none or both of tha fieldz is freestyled ta tha bitstream.
.IP "\fB\-mixing_level\fR \fInumber\fR" 4
.IX Item "-mixing_level number"
Mixin Level. Right back up in yo muthafuckin ass. Specifies peak sound heat level (\s-1SPL\s0) up in tha thang
environment when tha mix was mastered. Y'all KNOW dat shit, muthafucka! Valid joints is 80 ta 111, or \-1 for
unknown or not indicated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default value is \-1 yo, but dat value cannot be
used if tha Audio Production Hype is freestyled ta tha bitstream. Therefore,
if tha \f(CW\*(C`room_type\*(C'\fR option aint tha default value, tha \f(CW\*(C`mixing_level\*(C'\fR
option must not be \-1.
.IP "\fB\-room_type\fR \fItype\fR" 4
.IX Item "-room_type type"
Room Type. Describes tha equalization used durin tha final mixin session at
the basement or on tha dubbin stage fo' realz. A big-ass room be a thugged-out dubbin stage wit the
industry standard X\-curve equalization; a lil' small-ass room has flat equalization.
This field aint gonna be freestyled ta tha bitstream if both tha \f(CW\*(C`mixing_level\*(C'\fR
option n' tha \f(CW\*(C`room_type\*(C'\fR option have tha default joints.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBnotindicated\fR" 4
.IX Item "notindicated"
.PD
Not Indicated (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBlarge\fR" 4
.IX Item "large"
.PD
Big-Ass Room
.IP "\fB2\fR" 4
.IX Item "2"
.PD 0
.IP "\fBsmall\fR" 4
.IX Item "small"
.PD
Lil Small-Ass Room
.RE
.RS 4
.RE
.PP
Other Metadata Options
.IX Subsection "Other Metadata Options"
.IP "\fB\-copyright\fR \fIboolean\fR" 4
.IX Item "-copyright boolean"
Copyright Indicator. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Specifies whether a cold-ass lil copyright exists fo' dis audio.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
No Copyright Exists (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Copyright Exists
.RE
.RS 4
.RE
.IP "\fB\-dialnorm\fR \fIvalue\fR" 4
.IX Item "-dialnorm value"
Dialogue Normalization. I aint talkin' bout chicken n' gravy biatch. Indicates how tha fuck far tha average dialogue level of the
program is below digital 100% full scale (0 dBFS). This parameta determines a
level shift durin audio rethang dat sets tha average volume of the
dialogue ta a preset level. Da goal is ta match volume level between program
sources fo' realz. A value of \-31dB will result up in no volume level chizzle, relatizzle to
the source volume, durin audio rethang. I aint talkin' bout chicken n' gravy biatch. Valid joints is whole numbers in
the range \-31 ta \-1, wit \-31 bein tha default.
.IP "\fB\-dsur_mode\fR \fImode\fR" 4
.IX Item "-dsur_mode mode"
Dolby Surround Mode. Right back up in yo muthafuckin ass. Specifies whether tha stereo signal uses Dolby Surround
(Pro Logic). This field will only be freestyled ta tha bitstream if tha audio
stream is stereo. Usin dis option do \fB\s-1NOT\s0\fR mean tha encoder will actually
apply Dolby Surround processing.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBnotindicated\fR" 4
.IX Item "notindicated"
.PD
Not Indicated (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
Not Dolby Surround Encoded
.IP "\fB2\fR" 4
.IX Item "2"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Dolby Surround Encoded
.RE
.RS 4
.RE
.IP "\fB\-original\fR \fIboolean\fR" 4
.IX Item "-original gangsta boolean"
Original Gangsta Bit Stream Indicator. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Specifies whether dis audio is from the
original gangsta source n' not a cold-ass lil copy.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
Not Original Gangsta Source
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Original Gangsta Source (default)
.RE
.RS 4
.RE
.PP
\fIExtended Bitstream Information\fR
.IX Subsection "Extended Bitstream Information"
.PP
Da extended bitstream options is part of tha Alternate Bit Stream Syntax as
specified up in Annex D of tha A/52:2010 standard. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is grouped tha fuck into 2 parts.
If any one parameta up in a crew is specified, all joints up in dat crew will be
written ta tha bitstream.  Default joints is used fo' dem dat is written
but aint been specified. Y'all KNOW dat shit, muthafucka!  If tha mixin levels is written, tha decoder
will use these joints instead of tha ones specified up in tha \f(CW\*(C`center_mixlev\*(C'\fR
and \f(CW\*(C`surround_mixlev\*(C'\fR options if it supports tha Alternate Bit Stream
Syntax.
.PP
Extended Bitstream Hype \- Part 1
.IX Subsection "Extended Bitstream Hype - Part 1"
.IP "\fB\-dmix_mode\fR \fImode\fR" 4
.IX Item "-dmix_mode mode"
Preferred Stereo Downmix Mode fo' realz. Allows tha user ta select either Lt/Rt
(Dolby Surround) or Lo/Ro (normal stereo) as tha preferred stereo downmix mode.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBnotindicated\fR" 4
.IX Item "notindicated"
.PD
Not Indicated (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBltrt\fR" 4
.IX Item "ltrt"
.PD
Lt/Rt Downmix Preferred
.IP "\fB2\fR" 4
.IX Item "2"
.PD 0
.IP "\fBloro\fR" 4
.IX Item "loro"
.PD
Lo/Ro Downmix Preferred
.RE
.RS 4
.RE
.IP "\fB\-ltrt_cmixlev\fR \fIlevel\fR" 4
.IX Item "-ltrt_cmixlev level"
Lt/Rt Centa Mix Level. Da amount of bust tha decoder should apply ta the
centa channel when downmixin ta stereo up in Lt/Rt mode.
.RS 4
.IP "\fB1.414\fR" 4
.IX Item "1.414"
Apply +3dB gain
.IP "\fB1.189\fR" 4
.IX Item "1.189"
Apply +1.5dB gain
.IP "\fB1.000\fR" 4
.IX Item "1.000"
Apply 0dB gain
.IP "\fB0.841\fR" 4
.IX Item "0.841"
Apply \-1.5dB gain
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3.0dB gain
.IP "\fB0.595\fR" 4
.IX Item "0.595"
Apply \-4.5dB bust (default)
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6.0dB gain
.IP "\fB0.000\fR" 4
.IX Item "0.000"
Silence Centa Channel
.RE
.RS 4
.RE
.IP "\fB\-ltrt_surmixlev\fR \fIlevel\fR" 4
.IX Item "-ltrt_surmixlev level"
Lt/Rt Surround Mix Level. Da amount of bust tha decoder should apply ta the
surround channel(s) when downmixin ta stereo up in Lt/Rt mode.
.RS 4
.IP "\fB0.841\fR" 4
.IX Item "0.841"
Apply \-1.5dB gain
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3.0dB gain
.IP "\fB0.595\fR" 4
.IX Item "0.595"
Apply \-4.5dB gain
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6.0dB bust (default)
.IP "\fB0.000\fR" 4
.IX Item "0.000"
Silence Surround Channel(s)
.RE
.RS 4
.RE
.IP "\fB\-loro_cmixlev\fR \fIlevel\fR" 4
.IX Item "-loro_cmixlev level"
Lo/Ro Centa Mix Level. Da amount of bust tha decoder should apply ta the
centa channel when downmixin ta stereo up in Lo/Ro mode.
.RS 4
.IP "\fB1.414\fR" 4
.IX Item "1.414"
Apply +3dB gain
.IP "\fB1.189\fR" 4
.IX Item "1.189"
Apply +1.5dB gain
.IP "\fB1.000\fR" 4
.IX Item "1.000"
Apply 0dB gain
.IP "\fB0.841\fR" 4
.IX Item "0.841"
Apply \-1.5dB gain
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3.0dB gain
.IP "\fB0.595\fR" 4
.IX Item "0.595"
Apply \-4.5dB bust (default)
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6.0dB gain
.IP "\fB0.000\fR" 4
.IX Item "0.000"
Silence Centa Channel
.RE
.RS 4
.RE
.IP "\fB\-loro_surmixlev\fR \fIlevel\fR" 4
.IX Item "-loro_surmixlev level"
Lo/Ro Surround Mix Level. Da amount of bust tha decoder should apply ta the
surround channel(s) when downmixin ta stereo up in Lo/Ro mode.
.RS 4
.IP "\fB0.841\fR" 4
.IX Item "0.841"
Apply \-1.5dB gain
.IP "\fB0.707\fR" 4
.IX Item "0.707"
Apply \-3.0dB gain
.IP "\fB0.595\fR" 4
.IX Item "0.595"
Apply \-4.5dB gain
.IP "\fB0.500\fR" 4
.IX Item "0.500"
Apply \-6.0dB bust (default)
.IP "\fB0.000\fR" 4
.IX Item "0.000"
Silence Surround Channel(s)
.RE
.RS 4
.RE
.PP
Extended Bitstream Hype \- Part 2
.IX Subsection "Extended Bitstream Hype - Part 2"
.IP "\fB\-dsurex_mode\fR \fImode\fR" 4
.IX Item "-dsurex_mode mode"
Dolby Surround \s-1EX\s0 Mode. Indicates whether tha stream uses Dolby Surround \s-1EX
\&\s0(7.1 matrixed ta 5.1). Usin dis option do \fB\s-1NOT\s0\fR mean tha encoder will actually
apply Dolby Surround \s-1EX\s0 processing.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBnotindicated\fR" 4
.IX Item "notindicated"
.PD
Not Indicated (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Dolby Surround \s-1EX\s0 Off
.IP "\fB2\fR" 4
.IX Item "2"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
Dolby Surround \s-1EX\s0 On
.RE
.RS 4
.RE
.IP "\fB\-dheadphone_mode\fR \fImode\fR" 4
.IX Item "-dheadphone_mode mode"
Dolby Headphone Mode. Indicates whether tha stream uses Dolby Headphone
encodin (multi-channel matrixed ta 2.0 fo' use wit headphones). Usin this
option do \fB\s-1NOT\s0\fR mean tha encoder will straight-up apply Dolby Headphone
processing.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBnotindicated\fR" 4
.IX Item "notindicated"
.PD
Not Indicated (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Dolby Headphone Off
.IP "\fB2\fR" 4
.IX Item "2"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
Dolby Headphone On
.RE
.RS 4
.RE
.IP "\fB\-ad_conv_type\fR \fItype\fR" 4
.IX Item "-ad_conv_type type"
A/D Converta Type. Indicates whether tha audio has passed all up in \s-1HDCD A/D\s0
conversion.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBstandard\fR" 4
.IX Item "standard"
.PD
Standard A/D Converta (default)
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBhdcd\fR" 4
.IX Item "hdcd"
.PD
\&\s-1HDCD A/D\s0 Converter
.RE
.RS 4
.RE
.PP
\fIOther \s-1AC\-3\s0 Encodin Options\fR
.IX Subsection "Other AC-3 Encodin Options"
.IP "\fB\-stereo_rematrixing\fR \fIboolean\fR" 4
.IX Item "-stereo_rematrixin boolean"
Stereo Rematrixing. Enables/Disablez use of rematrixin fo' stereo input. This
is a optionizzle \s-1AC\-3\s0 feature dat increases qualitizzle by selectively encoding
the left/right channels as mid/side. This option is enabled by default, n' it
is highly recommended dat it be left as enabled except fo' testin purposes.
.PP
\fIFloating-Point-Only \s-1AC\-3\s0 Encodin Options\fR
.IX Subsection "Floating-Point-Only AC-3 Encodin Options"
.PP
These options is only valid fo' tha floating-point encoder n' do not exist
for tha fixed-point encoder cuz of tha correspondin features not being
implemented up in fixed-point.
.IP "\fB\-channel_coupling\fR \fIboolean\fR" 4
.IX Item "-channel_couplin boolean"
Enables/Disablez use of channel coupling, which be a optionizzle \s-1AC\-3\s0 feature
that increases qualitizzle by combinin high frequency shiznit from multiple
channels tha fuck into a single channel. Da per-channel high frequency shiznit is
sent wit less accuracy up in both tha frequency n' time domains. This allows
more bits ta be used fo' lower frequencies while preservin enough shiznit
to reconstruct tha high frequencies. Put ya muthafuckin choppers up if ya feel dis! This option is enabled by default fo' the
floating-point encoder n' should generally be left as enabled except for
testin purposes or ta increase encodin speed.
.RS 4
.IP "\fB\-1\fR" 4
.IX Item "-1"
.PD 0
.IP "\fBauto\fR" 4
.IX Item "auto"
.PD
Selected by Encoder (default)
.IP "\fB0\fR" 4
.IX Item "0"
.PD 0
.IP "\fBoff\fR" 4
.IX Item "off"
.PD
Disable Channel Coupling
.IP "\fB1\fR" 4
.IX Item "1"
.PD 0
.IP "\fBon\fR" 4
.IX Item "on"
.PD
Enable Channel Coupling
.RE
.RS 4
.RE
.IP "\fB\-cpl_start_band\fR \fInumber\fR" 4
.IX Item "-cpl_start_band number"
Couplin Start Band. Y'all KNOW dat shit, muthafucka! Sets tha channel couplin start crew, from 1 ta 15. If a
value higher than tha bandwidth is used, it is ghon be reduced ta 1 less than the
couplin end band. Y'all KNOW dat shit, muthafucka! If \fIauto\fR is used, tha start crew is ghon be determined by
the encoder based on tha bit rate, sample rate, n' channel layout. This option
has no effect if channel couplin is disabled.
.RS 4
.IP "\fB\-1\fR" 4
.IX Item "-1"
.PD 0
.IP "\fBauto\fR" 4
.IX Item "auto"
.PD
Selected by Encoder (default)
.RE
.RS 4
.RE
.SS "libmp3lame"
.IX Subsection "libmp3lame"
\&\s-1LAME \s0(Lame Ain't a \s-1MP3\s0 Encoder) \s-1MP3\s0 encoder wrapper.
.PP
Requires tha presence of tha libmp3lame headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libmp3lame\*(C'\fR.
.PP
See libshine fo' a gangbangin' fixed-point \s-1MP3\s0 encoder, although wit a
lower quality.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libmp3lame wrapper n' shit. The
\&\fBlame\fR\-equivalent of tha options is listed up in parentheses.
.IP "\fBb (\fR\fI\-b\fR\fB)\fR" 4
.IX Item "b (-b)"
Set bitrate expressed up in bits/s fo' \s-1CBR. LAME \s0\f(CW\*(C`bitrate\*(C'\fR is
expressed up in kilobits/s.
.IP "\fBq (\fR\fI\-V\fR\fB)\fR" 4
.IX Item "q (-V)"
Set constant qualitizzle settin fo' \s-1VBR.\s0 This option is valid only
usin tha \fBffmpeg\fR command-line tool. For library intercourse
users, use \fBglobal_quality\fR.
.IP "\fBcompression_level (\fR\fI\-q\fR\fB)\fR" 4
.IX Item "compression_level (-q)"
Set algorithm quality. Valid arguments is integers up in tha 0\-9 range,
with 0 meanin highest qualitizzle but slowest, n' 9 meanin fastest
while producin da most thugged-out shitty quality.
.IP "\fBreservoir\fR" 4
.IX Item "reservoir"
Enable use of bit reservoir when set ta 1. Default value is 1. \s-1LAME\s0
has dis enabled by default yo, but can be overriden by use
\&\fB\-\-nores\fR option.
.IP "\fBjoint_stereo (\fR\fI\-m j\fR\fB)\fR" 4
.IX Item "joint_stereo (-m j)"
Enable tha encoder ta use (on a gangbangin' frame by frame basis) either L/R
stereo or mid/side stereo. Default value is 1.
.SS "libopencore-amrnb"
.IX Subsection "libopencore-amrnb"
OpenCORE Adaptizzle Multi-Rate Narrowband encoder.
.PP
Requires tha presence of tha libopencore-amrnb headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libopencore\-amrnb \-\-enable\-version3\*(C'\fR.
.PP
This be a mono-only encoder n' shit. Officially it only supports 8000Hz sample rate,
but you can override it by settin \fBstrict\fR ta \fBunofficial\fR or
lower.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBb\fR" 4
.IX Item "b"
Set bitrate up in bits per second. Y'all KNOW dat shit, muthafucka! Only tha followin bitrates is supported,
otherwise libavcodec will round ta tha nearest valid bitrate.
.RS 4
.IP "\fB4750\fR" 4
.IX Item "4750"
.PD 0
.IP "\fB5150\fR" 4
.IX Item "5150"
.IP "\fB5900\fR" 4
.IX Item "5900"
.IP "\fB6700\fR" 4
.IX Item "6700"
.IP "\fB7400\fR" 4
.IX Item "7400"
.IP "\fB7950\fR" 4
.IX Item "7950"
.IP "\fB10200\fR" 4
.IX Item "10200"
.IP "\fB12200\fR" 4
.IX Item "12200"
.RE
.RS 4
.RE
.IP "\fBdtx\fR" 4
.IX Item "dtx"
.PD
Allow discontinuous transmission (generate comfort noise) when set ta 1. The
default value is 0 (disabled).
.SS "libshine"
.IX Subsection "libshine"
Shine Fixed-Point \s-1MP3\s0 encoder wrapper.
.PP
Shine be a gangbangin' fixed-point \s-1MP3\s0 encoder n' shit. Well shiiiit, it has a gangbangin' far betta performizzle on
platforms without a \s-1FPU,\s0 e.g. armel CPUs, n' some phones n' tablets.
But fuck dat shiznit yo, tha word on tha street is dat as it is mo' targeted on performizzle than quality, it aint on par
with \s-1LAME\s0 n' other thang-grade encodaz quality-wise fo' realz. Also, accordin to
the projectz homepage, dis encoder may not be free of bugs as tha code was
written a long-ass time ago n' tha project was dead fo' at least 5 years.
.PP
This encoder only supports stereo n' mono input. This be also CBR-only.
.PP
Da original gangsta project (last updated up in early 2007) be at
<\fBhttp://sourceforge.net/projects/libshine\-fxp/\fR>. We only support the
updated fork by tha Savonet/Liquidsoap project at <\fBhttps://github.com/savonet/shine\fR>.
.PP
Requires tha presence of tha libshine headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libshine\*(C'\fR.
.PP
See also libmp3lame.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libshine wrapper n' shit. The
\&\fBshineenc\fR\-equivalent of tha options is listed up in parentheses.
.IP "\fBb (\fR\fI\-b\fR\fB)\fR" 4
.IX Item "b (-b)"
Set bitrate expressed up in bits/s fo' \s-1CBR. \s0\fBshineenc\fR \fB\-b\fR option
is expressed up in kilobits/s.
.SS "libtwolame"
.IX Subsection "libtwolame"
TwoLAME \s-1MP2\s0 encoder wrapper.
.PP
Requires tha presence of tha libtwolame headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libtwolame\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libtwolame wrapper n' shit. The
\&\fBtwolame\fR\-equivalent options follow tha FFmpeg ones n' is in
parentheses.
.IP "\fBb (\fR\fI\-b\fR\fB)\fR" 4
.IX Item "b (-b)"
Set bitrate expressed up in bits/s fo' \s-1CBR. \s0\fBtwolame\fR \fBb\fR
option is expressed up in kilobits/s. Default value is 128k.
.IP "\fBq (\fR\fI\-V\fR\fB)\fR" 4
.IX Item "q (-V)"
Set qualitizzle fo' experimenstrual \s-1VBR\s0 support. Maximum value range is
from \-50 ta 50, useful range is from \-10 ta 10. Da higher the
value, tha betta tha quality. This option is valid only rockin the
\&\fBffmpeg\fR command-line tool. For library intercourse users,
use \fBglobal_quality\fR.
.IP "\fBmode (\fR\fI\-\-mode\fR\fB)\fR" 4
.IX Item "mode (--mode)"
Set tha mode of tha resultin audio. Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Choose mode automatically based on tha input. This is tha default.
.IP "\fBstereo\fR" 4
.IX Item "stereo"
Stereo
.IP "\fBjoint_stereo\fR" 4
.IX Item "joint_stereo"
Joint stereo
.IP "\fBdual_channel\fR" 4
.IX Item "dual_channel"
Dual channel
.IP "\fBmono\fR" 4
.IX Item "mono"
Mono
.RE
.RS 4
.RE
.IP "\fBpsymodel (\fR\fI\-\-psyc\-mode\fR\fB)\fR" 4
.IX Item "psymodel (--psyc-mode)"
Set psychoacoustic model ta use up in encoding. Da argument must be
an integer between \-1 n' 4, inclusive. Da higher tha value, the
betta tha quality. Da default value is 3.
.IP "\fBenergy_levels (\fR\fI\-\-energy\fR\fB)\fR" 4
.IX Item "energy_levels (--energy)"
Enable juice levels extensions when set ta 1. Da default value is
0 (disabled).
.IP "\fBerror_protection (\fR\fI\-\-protect\fR\fB)\fR" 4
.IX Item "error_protection (--protect)"
Enable \s-1CRC\s0 error protection when set ta 1. Da default value is 0
(disabled).
.IP "\fBcopyright (\fR\fI\-\-copyright\fR\fB)\fR" 4
.IX Item "copyright (--copyright)"
Set \s-1MPEG\s0 audio copyright flag when set ta 1. Da default value is 0
(disabled).
.IP "\fBoriginal gangsta (\fR\fI\-\-original\fR\fB)\fR" 4
.IX Item "original gangsta (--original)"
Set \s-1MPEG\s0 audio original gangsta flag when set ta 1. Da default value is 0
(disabled).
.SS "libvo-aacenc"
.IX Subsection "libvo-aacenc"
VisualOn \s-1AAC\s0 encoder.
.PP
Requires tha presence of tha libvo-aacenc headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libvo\-aacenc \-\-enable\-version3\*(C'\fR.
.PP
This encoder is considered ta be worse than the
natizzle experimenstrual FFmpeg \s-1AAC\s0 encoder, accordin to
multiple sources.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da VisualOn \s-1AAC\s0 encoder only support encodin AAC-LC n' up ta 2
channels. Well shiiiit, it be also CBR-only.
.IP "\fBb\fR" 4
.IX Item "b"
Set bit rate up in bits/s.
.SS "libvo-amrwbenc"
.IX Subsection "libvo-amrwbenc"
VisualOn Adaptizzle Multi-Rate Wideband encoder.
.PP
Requires tha presence of tha libvo-amrwbenc headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libvo\-amrwbenc \-\-enable\-version3\*(C'\fR.
.PP
This be a mono-only encoder n' shit. Officially it only supports 16000Hz sample
rate yo, but you can override it by settin \fBstrict\fR to
\&\fBunofficial\fR or lower.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBb\fR" 4
.IX Item "b"
Set bitrate up in bits/s. Only tha followin bitrates is supported, otherwise
libavcodec will round ta tha nearest valid bitrate.
.RS 4
.IP "\fB6600\fR" 4
.IX Item "6600"
.PD 0
.IP "\fB8850\fR" 4
.IX Item "8850"
.IP "\fB12650\fR" 4
.IX Item "12650"
.IP "\fB14250\fR" 4
.IX Item "14250"
.IP "\fB15850\fR" 4
.IX Item "15850"
.IP "\fB18250\fR" 4
.IX Item "18250"
.IP "\fB19850\fR" 4
.IX Item "19850"
.IP "\fB23050\fR" 4
.IX Item "23050"
.IP "\fB23850\fR" 4
.IX Item "23850"
.RE
.RS 4
.RE
.IP "\fBdtx\fR" 4
.IX Item "dtx"
.PD
Allow discontinuous transmission (generate comfort noise) when set ta 1. The
default value is 0 (disabled).
.SS "libopus"
.IX Subsection "libopus"
libopus Opus Interactizzle Audio Codec encoder wrapper.
.PP
Requires tha presence of tha libopus headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libopus\*(C'\fR.
.PP
\fIOption Mapping\fR
.IX Subsection "Option Mapping"
.PP
Most libopus options is modeled afta tha \fBopusenc\fR utilitizzle from
opus-tools. Da followin be a option mappin chart describin options
supported by tha libopus wrapper, n' they \fBopusenc\fR\-equivalent
in parentheses.
.IP "\fBb (\fR\fIbitrate\fR\fB)\fR" 4
.IX Item "b (bitrate)"
Set tha bit rate up in bits/s.  FFmpegz \fBb\fR option is
expressed up in bits/s, while \fBopusenc\fRz \fBbitrate\fR in
kilobits/s.
.IP "\fBvbr (\fR\fIvbr\fR\fB,\fR \fIhard-cbr\fR\fB, and\fR \fIcvbr\fR\fB)\fR" 4
.IX Item "vbr (vbr, hard-cbr, n' cvbr)"
Set \s-1VBR\s0 mode. Da FFmpeg \fBvbr\fR option has tha following
valid arguments, wit tha they \fBopusenc\fR equivalent options
in parentheses:
.RS 4
.IP "\fBoff (\fR\fIhard-cbr\fR\fB)\fR" 4
.IX Item "off (hard-cbr)"
Use constant bit rate encoding.
.IP "\fBon (\fR\fIvbr\fR\fB)\fR" 4
.IX Item "on (vbr)"
Use variable bit rate encodin (the default).
.IP "\fBconstrained (\fR\fIcvbr\fR\fB)\fR" 4
.IX Item "constrained (cvbr)"
Use constrained variable bit rate encoding.
.RE
.RS 4
.RE
.IP "\fBcompression_level (\fR\fIcomp\fR\fB)\fR" 4
.IX Item "compression_level (comp)"
Set encodin algorithm complexity. Valid options is integers in
the 0\-10 range. 0 gives tha fastest encodes but lower quality, while 10
gives tha highest qualitizzle but slowest encoding. Da default is 10.
.IP "\fBframe_duration (\fR\fIframesize\fR\fB)\fR" 4
.IX Item "frame_duration (framesize)"
Set maximum frame size, or duration of a gangbangin' frame up in milliseconds. The
argument must be exactly tha following: 2.5, 5, 10, 20, 40, 60. Right back up in yo muthafuckin ass. Smaller
frame sizes big up lower latency but less qualitizzle at a given bitrate.
Sizes pimped outa than 20ms is only bangin-ass at fairly low bitrates.
Da default is 20ms.
.IP "\fBpacket_loss (\fR\fIexpect-loss\fR\fB)\fR" 4
.IX Item "packet_loss (expect-loss)"
Set expected packet loss cementage. Da default is 0.
.IP "\fBapplication (N.A.)\fR" 4
.IX Item "application (N.A.)"
Set intended application type. Valid options is listed below:
.RS 4
.IP "\fBvoip\fR" 4
.IX Item "voip"
Favor improved rap intelligibility.
.IP "\fBaudio\fR" 4
.IX Item "audio"
Favor faithfulnizz ta tha input (the default).
.IP "\fBlowdelay\fR" 4
.IX Item "lowdelay"
Restrict ta only tha lowest delay modes.
.RE
.RS 4
.RE
.IP "\fBcutoff (N.A.)\fR" 4
.IX Item "cutoff (N.A.)"
Set cutoff bandwidth up in Hz. Da argument must be exactly one of the
following: 4000, 6000, 8000, 12000, or 20000, correspondin to
narrowband, mediumband, wideband, supa wideband, n' fullband
respectively. Da default is 0 (cutoff disabled).
.SS "libvorbis"
.IX Subsection "libvorbis"
libvorbis encoder wrapper.
.PP
Requires tha presence of tha libvorbisenc headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libvorbis\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libvorbis wrapper n' shit. The
\&\fBoggenc\fR\-equivalent of tha options is listed up in parentheses.
.PP
To git a mo' accurate n' extensive documentation of tha libvorbis
options, consult tha libvorbisencs n' \fBoggenc\fRz documentations.
See <\fBhttp://xiph.org/vorbis/\fR>,
<\fBhttp://wiki.xiph.org/Vorbis\-tools\fR>, n' \fIoggenc\fR\|(1).
.IP "\fBb (\fR\fI\-b\fR\fB)\fR" 4
.IX Item "b (-b)"
Set bitrate expressed up in bits/s fo' \s-1ABR. \s0\fBoggenc\fR \fB\-b\fR is
expressed up in kilobits/s.
.IP "\fBq (\fR\fI\-q\fR\fB)\fR" 4
.IX Item "q (-q)"
Set constant qualitizzle settin fo' \s-1VBR.\s0 Da value should be a gangbangin' float
number up in tha range of \-1.0 ta 10.0. Da higher tha value, tha better
the quality. Da default value is \fB3.0\fR.
.Sp
This option is valid only rockin tha \fBffmpeg\fR command-line tool.
For library intercourse users, use \fBglobal_quality\fR.
.IP "\fBcutoff (\fR\fI\-\-advanced\-encode\-option lowpass_frequency=N\fR\fB)\fR" 4
.IX Item "cutoff (--advanced-encode-option lowpass_frequency=N)"
Set cutoff bandwidth up in Hz, a value of 0 disablez cutoff. \fBoggenc\fR's
related option is expressed up in kHz. Da default value is \fB0\fR (cutoff
disabled).
.IP "\fBminrate (\fR\fI\-m\fR\fB)\fR" 4
.IX Item "minrate (-m)"
Set minimum bitrate expressed up in bits/s. \fBoggenc\fR \fB\-m\fR is
expressed up in kilobits/s.
.IP "\fBmaxrate (\fR\fI\-M\fR\fB)\fR" 4
.IX Item "maxrate (-M)"
Set maximum bitrate expressed up in bits/s. \fBoggenc\fR \fB\-M\fR is
expressed up in kilobits/s. This only has effect on \s-1ABR\s0 mode.
.IP "\fBiblock (\fR\fI\-\-advanced\-encode\-option impulse_noisetune=N\fR\fB)\fR" 4
.IX Item "iblock (--advanced-encode-option impulse_noisetune=N)"
Set noise floor bias fo' impulse blocks. Da value be a gangbangin' float number from
\&\-15.0 ta 0.0 fo' realz. A wack bias instructs tha encoder ta pay special attention
to tha crispnizz of transients up in tha encoded audio. Da tradeoff fo' better
transient response be a higher bitrate.
.SS "libwavpack"
.IX Subsection "libwavpack"
A wrapper providin WavPack encodin all up in libwavpack.
.PP
Only lossless mode rockin 32\-bit integer samplez is supported currently.
Da \fBcompression_level\fR option can be used ta control speed vs.
compression tradeoff, wit tha joints mapped ta libwavpack as bigs up:
.IP "\fB0\fR" 4
.IX Item "0"
Fast mode \- correspondin ta tha wavpack \fB\-f\fR option.
.IP "\fB1\fR" 4
.IX Item "1"
Normal (default) settings.
.IP "\fB2\fR" 4
.IX Item "2"
High qualitizzle \- correspondin ta tha wavpack \fB\-h\fR option.
.IP "\fB3\fR" 4
.IX Item "3"
Straight-up high qualitizzle \- correspondin ta tha wavpack \fB\-hh\fR option.
.IP "\fB4\-8\fR" 4
.IX Item "4-8"
Same as 3 yo, but wit extra processin enabled \- correspondin ta tha wavpack
\&\fB\-x\fR option. I aint talkin' bout chicken n' gravy biatch. I.e. 4 is tha same ol' dirty as \fB\-x2\fR n' 8 is tha same ol' dirty as
\&\fB\-x6\fR.
.SH "VIDEO ENCODERS"
.IX Header "VIDEO ENCODERS"
A description of a shitload of tha currently available vizzle encoders
bigs up.
.SS "libtheora"
.IX Subsection "libtheora"
Theora format supported all up in libtheora.
.PP
Requires tha presence of tha libtheora headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libtheora\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin global options is mapped ta internal libtheora options
which affect tha qualitizzle n' tha bitrate of tha encoded stream.
.IP "\fBb\fR" 4
.IX Item "b"
Set tha vizzle bitrate, only works if tha \f(CW\*(C`qscale\*(C'\fR flag in
\&\fBflags\fR aint enabled.
.IP "\fBflags\fR" 4
.IX Item "flags"
Used ta enable constant qualitizzle mode encodin all up in the
\&\fBqscale\fR flag, n' ta enable tha \f(CW\*(C`pass1\*(C'\fR n' \f(CW\*(C`pass2\*(C'\fR
modes.
.IP "\fBg\fR" 4
.IX Item "g"
Set tha \s-1GOP\s0 size.
.IP "\fBglobal_quality\fR" 4
.IX Item "global_quality"
Set tha global qualitizzle up in lambda units, only works if the
\&\f(CW\*(C`qscale\*(C'\fR flag up in \fBflags\fR is enabled. Y'all KNOW dat shit, muthafucka! Da value is clipped
in tha [0 \- 10*\f(CW\*(C`FF_QP2LAMBDA\*(C'\fR] range, n' then multiplied fo' 6.3
to git a value up in tha natizzle libtheora range [0\-63] fo' realz. A higher value
correspondz ta a higher quality.
.Sp
For example, ta set maximum constant qualitizzle encodin with
\&\fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-flags:v qscale \-global_quality:v "10*QP2LAMBDA" \-codec:v libtheora OUTPUT.ogg
.Ve
.SS "libvpx"
.IX Subsection "libvpx"
\&\s-1VP8\s0 format supported all up in libvpx.
.PP
Requires tha presence of tha libvpx headaz n' library durin configuration.
Yo ass need ta explicitly configure tha build wit \f(CW\*(C`\-\-enable\-libvpx\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Mappin from FFmpeg ta libvpx options wit conversion notes up in parentheses.
.IP "\fBthreads\fR" 4
.IX Item "threads"
g_threads
.IP "\fBprofile\fR" 4
.IX Item "profile"
g_profile
.IP "\fBvb\fR" 4
.IX Item "vb"
rc_target_bitrate
.IP "\fBg\fR" 4
.IX Item "g"
kf_max_dist
.IP "\fBkeyint_min\fR" 4
.IX Item "keyint_min"
kf_min_dist
.IP "\fBqmin\fR" 4
.IX Item "qmin"
rc_min_quantizer
.IP "\fBqmax\fR" 4
.IX Item "qmax"
rc_max_quantizer
.IP "\fBbufsize, vb\fR" 4
.IX Item "bufsize, vb"
rc_buf_sz
\&\f(CW\*(C`(bufsize * 1000 / vb)\*(C'\fR
.Sp
rc_buf_optimal_sz
\&\f(CW\*(C`(bufsize * 1000 / vb * 5 / 6)\*(C'\fR
.IP "\fBrc_init_occupancy, vb\fR" 4
.IX Item "rc_init_occupancy, vb"
rc_buf_initial_sz
\&\f(CW\*(C`(rc_init_occupancy * 1000 / vb)\*(C'\fR
.IP "\fBrc_buffer_aggressivity\fR" 4
.IX Item "rc_buffer_aggressivity"
rc_undershoot_pct
.IP "\fBskip_threshold\fR" 4
.IX Item "skip_threshold"
rc_dropframe_thresh
.IP "\fBqcomp\fR" 4
.IX Item "qcomp"
rc_2pass_vbr_bias_pct
.IP "\fBmaxrate, vb\fR" 4
.IX Item "maxrate, vb"
rc_2pass_vbr_maxsection_pct
\&\f(CW\*(C`(maxrate * 100 / vb)\*(C'\fR
.IP "\fBminrate, vb\fR" 4
.IX Item "minrate, vb"
rc_2pass_vbr_minsection_pct
\&\f(CW\*(C`(minrate * 100 / vb)\*(C'\fR
.IP "\fBminrate, maxrate, vb\fR" 4
.IX Item "minrate, maxrate, vb"
\&\f(CW\*(C`VPX_CBR\*(C'\fR
\&\f(CW\*(C`(minrate == maxrate == vb)\*(C'\fR
.IP "\fBcrf\fR" 4
.IX Item "crf"
\&\f(CW\*(C`VPX_CQ\*(C'\fR, \f(CW\*(C`VP8E_SET_CQ_LEVEL\*(C'\fR
.IP "\fBquality\fR" 4
.IX Item "quality"
.RS 4
.PD 0
.IP "\fIbest\fR" 4
.IX Item "best"
.PD
\&\f(CW\*(C`VPX_DL_BEST_QUALITY\*(C'\fR
.IP "\fIgood\fR" 4
.IX Item "good"
\&\f(CW\*(C`VPX_DL_GOOD_QUALITY\*(C'\fR
.IP "\fIrealtime\fR" 4
.IX Item "realtime"
\&\f(CW\*(C`VPX_DL_REALTIME\*(C'\fR
.RE
.RS 4
.RE
.IP "\fBspeed\fR" 4
.IX Item "speed"
\&\f(CW\*(C`VP8E_SET_CPUUSED\*(C'\fR
.IP "\fBnr\fR" 4
.IX Item "nr"
\&\f(CW\*(C`VP8E_SET_NOISE_SENSITIVITY\*(C'\fR
.IP "\fBmb_threshold\fR" 4
.IX Item "mb_threshold"
\&\f(CW\*(C`VP8E_SET_STATIC_THRESHOLD\*(C'\fR
.IP "\fBslices\fR" 4
.IX Item "slices"
\&\f(CW\*(C`VP8E_SET_TOKEN_PARTITIONS\*(C'\fR
.IP "\fBmax-intra-rate\fR" 4
.IX Item "max-intra-rate"
\&\f(CW\*(C`VP8E_SET_MAX_INTRA_BITRATE_PCT\*(C'\fR
.IP "\fBforce_key_frames\fR" 4
.IX Item "force_key_frames"
\&\f(CW\*(C`VPX_EFLAG_FORCE_KF\*(C'\fR
.IP "\fBAlternate reference frame related\fR" 4
.IX Item "Alternate reference frame related"
.RS 4
.PD 0
.IP "\fBvp8flags altref\fR" 4
.IX Item "vp8flags altref"
.PD
\&\f(CW\*(C`VP8E_SET_ENABLEAUTOALTREF\*(C'\fR
.IP "\fIarnr_max_frames\fR" 4
.IX Item "arnr_max_frames"
\&\f(CW\*(C`VP8E_SET_ARNR_MAXFRAMES\*(C'\fR
.IP "\fIarnr_type\fR" 4
.IX Item "arnr_type"
\&\f(CW\*(C`VP8E_SET_ARNR_TYPE\*(C'\fR
.IP "\fIarnr_strength\fR" 4
.IX Item "arnr_strength"
\&\f(CW\*(C`VP8E_SET_ARNR_STRENGTH\*(C'\fR
.IP "\fIrc_lookahead\fR" 4
.IX Item "rc_lookahead"
g_lag_in_frames
.RE
.RS 4
.RE
.IP "\fBvp8flags error_resilient\fR" 4
.IX Item "vp8flags error_resilient"
g_error_resilient
.PP
For mo' shiznit bout libvpx see:
<\fBhttp://www.webmproject.org/\fR>
.SS "libx264"
.IX Subsection "libx264"
x264 H.264/MPEG\-4 \s-1AVC\s0 encoder wrapper.
.PP
This encoder requires tha presence of tha libx264 headaz n' library
durin configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libx264\*(C'\fR.
.PP
libx264 supports a impressive number of features, includin 8x8 and
4x4 adaptizzle spatial transform, adaptizzle B\-frame placement, \s-1CAVLC/CABAC\s0
entropy coding, interlacin (\s-1MBAFF\s0), lossless mode, psy optimizations
for detail retention (adaptizzle quantization, psy-RD, psy-trellis).
.PP
Many libx264 encoder options is mapped ta FFmpeg global codec
options, while unique encoder options is provided all up in private
options fo' realz. Additionally tha \fBx264opts\fR n' \fBx264\-params\fR
private options allows ta pass a list of key=value tuplez as accepted
by tha libx264 \f(CW\*(C`x264_param_parse\*(C'\fR function.
.PP
Da x264 project joint be at
<\fBhttp://www.videolan.org/developers/x264.html\fR>.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libx264 wrapper n' shit. The
\&\fBx264\fR\-equivalent options or joints is listed up in parentheses
for easy as fuck  migration.
.PP
To reduce tha duplication of documentation, only tha private options
and some others requirin special attention is documented here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. For
the documentation of tha undocumented generic options, see
the Codec Options chapter.
.PP
To git a mo' accurate n' extensive documentation of tha libx264
options, invoke tha command \fBx264 \-\-full\-help\fR or consult
the libx264 documentation.
.IP "\fBb (\fR\fIbitrate\fR\fB)\fR" 4
.IX Item "b (bitrate)"
Set bitrate up in bits/s. Note dat FFmpegz \fBb\fR option is
expressed up in bits/s, while \fBx264\fRz \fBbitrate\fR is in
kilobits/s.
.IP "\fBbf (\fR\fIbframes\fR\fB)\fR" 4
.IX Item "bf (bframes)"
.PD 0
.IP "\fBg (\fR\fIkeyint\fR\fB)\fR" 4
.IX Item "g (keyint)"
.IP "\fBqmax (\fR\fIqpmax\fR\fB)\fR" 4
.IX Item "qmax (qpmax)"
.IP "\fBqmin (\fR\fIqpmin\fR\fB)\fR" 4
.IX Item "qmin (qpmin)"
.IP "\fBqdiff (\fR\fIqpstep\fR\fB)\fR" 4
.IX Item "qdiff (qpstep)"
.IP "\fBqblur (\fR\fIqblur\fR\fB)\fR" 4
.IX Item "qblur (qblur)"
.IP "\fBqcomp (\fR\fIqcomp\fR\fB)\fR" 4
.IX Item "qcomp (qcomp)"
.IP "\fBrefs (\fR\fIref\fR\fB)\fR" 4
.IX Item "refs (ref)"
.IP "\fBsc_threshold (\fR\fIscenecut\fR\fB)\fR" 4
.IX Item "sc_threshold (scenecut)"
.IP "\fBtrellis (\fR\fItrellis\fR\fB)\fR" 4
.IX Item "trellis (trellis)"
.IP "\fBnr  (\fR\fInr\fR\fB)\fR" 4
.IX Item "nr (nr)"
.IP "\fBme_range (\fR\fImerange\fR\fB)\fR" 4
.IX Item "me_range (merange)"
.IP "\fBme_method (\fR\fIme\fR\fB)\fR" 4
.IX Item "me_method (me)"
.PD
Set motion estimation method. Y'all KNOW dat shit, muthafucka! Possible joints up in tha decreasin order
of speed:
.RS 4
.IP "\fBdia (\fR\fIdia\fR\fB)\fR" 4
.IX Item "dia (dia)"
.PD 0
.IP "\fBepzs (\fR\fIdia\fR\fB)\fR" 4
.IX Item "epzs (dia)"
.PD
Diamond search wit radius 1 (fastest). \fBepzs\fR be a alias for
\&\fBdia\fR.
.IP "\fBhex (\fR\fIhex\fR\fB)\fR" 4
.IX Item "hex (hex)"
Hexagonal search wit radius 2.
.IP "\fBumh (\fR\fIumh\fR\fB)\fR" 4
.IX Item "umh (umh)"
Uneven multi-hexagon search.
.IP "\fBesa (\fR\fIesa\fR\fB)\fR" 4
.IX Item "esa (esa)"
Exhaustizzle search.
.IP "\fBtesa (\fR\fItesa\fR\fB)\fR" 4
.IX Item "tesa (tesa)"
Hadamard exhaustizzle search (slowest).
.RE
.RS 4
.RE
.IP "\fBsubq (\fR\fIsubme\fR\fB)\fR" 4
.IX Item "subq (subme)"
.PD 0
.IP "\fBb_strategy (\fR\fIb\-adapt\fR\fB)\fR" 4
.IX Item "b_strategy (b-adapt)"
.IP "\fBkeyint_min (\fR\fImin-keyint\fR\fB)\fR" 4
.IX Item "keyint_min (min-keyint)"
.IP "\fBcoder\fR" 4
.IX Item "coder"
.PD
Set entropy encoder n' shit. Possible joints:
.RS 4
.IP "\fBac\fR" 4
.IX Item "ac"
Enable \s-1CABAC.\s0
.IP "\fBvlc\fR" 4
.IX Item "vlc"
Enable \s-1CAVLC\s0 n' disable \s-1CABAC.\s0 It generates tha same ol' dirty effect as
\&\fBx264\fRz \fB\-\-no\-cabac\fR option.
.RE
.RS 4
.RE
.IP "\fBcmp\fR" 4
.IX Item "cmp"
Set full pixel motion estimation comparation algorithm. Possible joints:
.RS 4
.IP "\fBchroma\fR" 4
.IX Item "chroma"
Enable chroma up in motion estimation.
.IP "\fBsad\fR" 4
.IX Item "sad"
Ignore chroma up in motion estimation. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it generates tha same ol' dirty effect as
\&\fBx264\fRz \fB\-\-no\-chroma\-me\fR option.
.RE
.RS 4
.RE
.IP "\fBthreadz (\fR\fIthreads\fR\fB)\fR" 4
.IX Item "threadz (threads)"
.PD 0
.IP "\fBthread_type\fR" 4
.IX Item "thread_type"
.PD
Set multithreadin technique. Possible joints:
.RS 4
.IP "\fBslice\fR" 4
.IX Item "slice"
Slice-based multithreading. Well shiiiit, it generates tha same ol' dirty effect as
\&\fBx264\fRz \fB\-\-sliced\-threads\fR option.
.IP "\fBframe\fR" 4
.IX Item "frame"
Frame-based multithreading.
.RE
.RS 4
.RE
.IP "\fBflags\fR" 4
.IX Item "flags"
Set encodin flags. Well shiiiit, it can be used ta disable closed \s-1GOP\s0 n' enable
open \s-1GOP\s0 by settin it ta \f(CW\*(C`\-cgop\*(C'\fR. Da result is similar to
the behavior of \fBx264\fRz \fB\-\-open\-gop\fR option.
.IP "\fBrc_init_occupancy (\fR\fIvbv-init\fR\fB)\fR" 4
.IX Item "rc_init_occupancy (vbv-init)"
.PD 0
.IP "\fBpreset (\fR\fIpreset\fR\fB)\fR" 4
.IX Item "preset (preset)"
.PD
Set tha encodin preset.
.IP "\fBtune (\fR\fItune\fR\fB)\fR" 4
.IX Item "tune (tune)"
Set tunin of tha encodin params.
.IP "\fBprofile (\fR\fIprofile\fR\fB)\fR" 4
.IX Item "profile (profile)"
Set flava restrictions.
.IP "\fBfastfirstpass\fR" 4
.IX Item "fastfirstpass"
Enable fast settings when encodin first pass, when set ta 1. When set
to 0, it has tha same ol' dirty effect of \fBx264\fR's
\&\fB\-\-slow\-firstpass\fR option.
.IP "\fBcrf (\fR\fIcrf\fR\fB)\fR" 4
.IX Item "crf (crf)"
Set tha qualitizzle fo' constant qualitizzle mode.
.IP "\fBcrf_max (\fR\fIcrf-max\fR\fB)\fR" 4
.IX Item "crf_max (crf-max)"
In \s-1CRF\s0 mode, prevents \s-1VBV\s0 from lowerin qualitizzle beyond dis point.
.IP "\fBqp (\fR\fIqp\fR\fB)\fR" 4
.IX Item "qp (qp)"
Set constant quantization rate control method parameter.
.IP "\fBaq-mode (\fR\fIaq-mode\fR\fB)\fR" 4
.IX Item "aq-mode (aq-mode)"
Set \s-1AQ\s0 method. Y'all KNOW dat shit, muthafucka! Possible joints:
.RS 4
.IP "\fBnone (\fR\fI0\fR\fB)\fR" 4
.IX Item "none (0)"
Disabled.
.IP "\fBvariizzle (\fR\fI1\fR\fB)\fR" 4
.IX Item "variizzle (1)"
Variizzle \s-1AQ \s0(complexitizzle mask).
.IP "\fBautovariizzle (\fR\fI2\fR\fB)\fR" 4
.IX Item "autovariizzle (2)"
Auto-variizzle \s-1AQ \s0(experimental).
.RE
.RS 4
.RE
.IP "\fBaq-strength (\fR\fIaq-strength\fR\fB)\fR" 4
.IX Item "aq-strength (aq-strength)"
Set \s-1AQ\s0 strength, reduce blockin n' blurrin up in flat n' textured areas.
.IP "\fBpsy\fR" 4
.IX Item "psy"
Use psychovisual optimizations when set ta 1. When set ta 0, it has the
same effect as \fBx264\fRz \fB\-\-no\-psy\fR option.
.IP "\fBpsy-rd  (\fR\fIpsy-rd\fR\fB)\fR" 4
.IX Item "psy-rd (psy-rd)"
Set strength of psychovisual optimization, in
\&\fIpsy-rd\fR:\fIpsy-trellis\fR format.
.IP "\fBrc-lookahead (\fR\fIrc-lookahead\fR\fB)\fR" 4
.IX Item "rc-lookahead (rc-lookahead)"
Set number of frames ta look ahead fo' frametype n' ratecontrol.
.IP "\fBweightb\fR" 4
.IX Item "weightb"
Enable weighted prediction fo' B\-frames when set ta 1. When set ta 0,
it has tha same ol' dirty effect as \fBx264\fRz \fB\-\-no\-weightb\fR option.
.IP "\fBweightp (\fR\fIweightp\fR\fB)\fR" 4
.IX Item "weightp (weightp)"
Set weighted prediction method fo' P\-frames. Possible joints:
.RS 4
.IP "\fBnone (\fR\fI0\fR\fB)\fR" 4
.IX Item "none (0)"
Disabled
.IP "\fBsimple (\fR\fI1\fR\fB)\fR" 4
.IX Item "simple (1)"
Enable only weighted refs
.IP "\fBsmart (\fR\fI2\fR\fB)\fR" 4
.IX Item "smart (2)"
Enable both weighted refs n' duplicates
.RE
.RS 4
.RE
.IP "\fBssim (\fR\fIssim\fR\fB)\fR" 4
.IX Item "ssim (ssim)"
Enable calculation n' printin \s-1SSIM\s0 stats afta tha encoding.
.IP "\fBintra-refresh (\fR\fIintra-refresh\fR\fB)\fR" 4
.IX Item "intra-refresh (intra-refresh)"
Enable tha use of Periodic Intra Refresh instead of \s-1IDR\s0 frames when set
to 1.
.IP "\fBbluray-compat (\fR\fIbluray-compat\fR\fB)\fR" 4
.IX Item "bluray-compat (bluray-compat)"
Configure tha encoder ta be compatible wit tha bluray standard.
It be a gangbangin' finger-lickin' dirty-ass shorthand fo' settin \*(L"bluray\-compat=1 force\-cfr=1\*(R".
.IP "\fBb\-bias (\fR\fIb\-bias\fR\fB)\fR" 4
.IX Item "b-bias (b-bias)"
Set tha influence on how tha fuck often B\-frames is used.
.IP "\fBb\-pyramid (\fR\fIb\-pyramid\fR\fB)\fR" 4
.IX Item "b-pyramid (b-pyramid)"
Set method fo' keepin of some B\-frames as references. Possible joints:
.RS 4
.IP "\fBnone (\fR\fInone\fR\fB)\fR" 4
.IX Item "none (none)"
Disabled.
.IP "\fBstrict (\fR\fIstrict\fR\fB)\fR" 4
.IX Item "strict (strict)"
Strictly hierarchical pyramid.
.IP "\fBnormal (\fR\fInormal\fR\fB)\fR" 4
.IX Item "normal (normal)"
Non-strict (not Blu-ray compatible).
.RE
.RS 4
.RE
.IP "\fBmixed-refs\fR" 4
.IX Item "mixed-refs"
Enable tha use of one reference per partition, as opposed ta one
reference per macroblock when set ta 1. When set ta 0, it has the
same effect as \fBx264\fRz \fB\-\-no\-mixed\-refs\fR option.
.IP "\fB8x8dct\fR" 4
.IX Item "8x8dct"
Enable adaptizzle spatial transform (high flava 8x8 transform)
when set ta 1. When set ta 0, it has tha same ol' dirty effect as
\&\fBx264\fRz \fB\-\-no\-8x8dct\fR option.
.IP "\fBfast-pskip\fR" 4
.IX Item "fast-pskip"
Enable early \s-1SKIP\s0 detection on P\-frames when set ta 1. When set
to 0, it has tha same ol' dirty effect as \fBx264\fR's
\&\fB\-\-no\-fast\-pskip\fR option.
.IP "\fBaud (\fR\fIaud\fR\fB)\fR" 4
.IX Item "aud (aud)"
Enable use of access unit delimitas when set ta 1.
.IP "\fBmbtree\fR" 4
.IX Item "mbtree"
Enable use macroblock tree ratecontrol when set ta 1. When set
to 0, it has tha same ol' dirty effect as \fBx264\fR's
\&\fB\-\-no\-mbtree\fR option.
.IP "\fBdeblock (\fR\fIdeblock\fR\fB)\fR" 4
.IX Item "deblock (deblock)"
Set loop filta parameters, up in \fIalpha\fR:\fIbeta\fR form.
.IP "\fBcplxblur (\fR\fIcplxblur\fR\fB)\fR" 4
.IX Item "cplxblur (cplxblur)"
Set fluctuations reduction up in \s-1QP \s0(before curve compression).
.IP "\fBpartitions (\fR\fIpartitions\fR\fB)\fR" 4
.IX Item "partitions (partitions)"
Set partitions ta consider as a cold-ass lil comma-separated list of. Possible
values up in tha list:
.RS 4
.IP "\fBp8x8\fR" 4
.IX Item "p8x8"
8x8 P\-frame partition.
.IP "\fBp4x4\fR" 4
.IX Item "p4x4"
4x4 P\-frame partition.
.IP "\fBb8x8\fR" 4
.IX Item "b8x8"
4x4 B\-frame partition.
.IP "\fBi8x8\fR" 4
.IX Item "i8x8"
8x8 I\-frame partition.
.IP "\fBi4x4\fR" 4
.IX Item "i4x4"
4x4 I\-frame partition.
(Enablin \fBp4x4\fR requires \fBp8x8\fR ta be enabled. Y'all KNOW dat shit, muthafucka! Enabling
\&\fBi8x8\fR requires adaptizzle spatial transform (\fB8x8dct\fR
option) ta be enabled.)
.IP "\fBnone (\fR\fInone\fR\fB)\fR" 4
.IX Item "none (none)"
Do not consider any partitions.
.IP "\fBall (\fR\fIall\fR\fB)\fR" 4
.IX Item "all (all)"
Consider every last muthafuckin partition.
.RE
.RS 4
.RE
.IP "\fBdirect-pred (\fR\fIdirect\fR\fB)\fR" 4
.IX Item "direct-pred (direct)"
Set direct \s-1MV\s0 prediction mode. Possible joints:
.RS 4
.IP "\fBnone (\fR\fInone\fR\fB)\fR" 4
.IX Item "none (none)"
Disable \s-1MV\s0 prediction.
.IP "\fBspatial (\fR\fIspatial\fR\fB)\fR" 4
.IX Item "spatial (spatial)"
Enable spatial predicting.
.IP "\fBtemporal (\fR\fItemporal\fR\fB)\fR" 4
.IX Item "temporal (temporal)"
Enable temporal predicting.
.IP "\fBauto (\fR\fIauto\fR\fB)\fR" 4
.IX Item "auto (auto)"
Automatically decided.
.RE
.RS 4
.RE
.IP "\fBslice-max-size (\fR\fIslice-max-size\fR\fB)\fR" 4
.IX Item "slice-max-size (slice-max-size)"
Set tha limit of tha size of each slice up in bytes. If not specified
but \s-1RTP\s0 payload size (\fBps\fR) is specified, dat is used.
.IP "\fBstats (\fR\fIstats\fR\fB)\fR" 4
.IX Item "stats (stats)"
Set tha file name fo' multi-pass stats.
.IP "\fBnal-hrd (\fR\fInal-hrd\fR\fB)\fR" 4
.IX Item "nal-hrd (nal-hrd)"
Set signal \s-1HRD\s0 shiznit (requires \fBvbv-bufsize\fR ta be set).
Possible joints:
.RS 4
.IP "\fBnone (\fR\fInone\fR\fB)\fR" 4
.IX Item "none (none)"
Disable \s-1HRD\s0 shiznit signaling.
.IP "\fBvbr (\fR\fIvbr\fR\fB)\fR" 4
.IX Item "vbr (vbr)"
Variable bit rate.
.IP "\fBcbr (\fR\fIcbr\fR\fB)\fR" 4
.IX Item "cbr (cbr)"
Constant bit rate (not allowed up in \s-1MP4\s0 container).
.RE
.RS 4
.RE
.IP "\fBx264opts (N.A.)\fR" 4
.IX Item "x264opts (N.A.)"
Set any x264 option, peep \fBx264 \-\-fullhelp\fR fo' a list.
.Sp
Argument be a list of \fIkey\fR=\fIvalue\fR couplez separated by
\&\*(L":\*(R". In \fIfilter\fR n' \fIpsy-rd\fR options dat use \*(L":\*(R" as a separator
themselves, use \*(L",\*(R" instead. Y'all KNOW dat shit, muthafucka! They accept it as well since long ago but this
is kept undocumented fo' some reason.
.Sp
For example ta specify libx264 encodin options wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i foo.mpg \-vcodec libx264 \-x264opts keyint=123:min\-keyint=20 \-an out.mkv
.Ve
.IP "\fBx264\-params (N.A.)\fR" 4
.IX Item "x264-params (N.A.)"
Override tha x264 configuration rockin a :\-separated list of key=value
parameters.
.Sp
This option is functionally tha same as tha \fBx264opts\fR yo, but is
duplicated fo' compabilitizzle wit tha Libav fork.
.Sp
For example ta specify libx264 encodin options wit \fBffmpeg\fR:
.Sp
.Vb 3
\&        ffmpeg \-i INPUT \-c:v libx264 \-x264\-params level=30:bframes=0:weightp=0:\e
\&        cabac=0:ref=1:vbv\-maxrate=768:vbv\-bufsize=2000:analyse=all:me=umh:\e
\&        no\-fast\-pskip=1:subq=6:8x8dct=0:trellis=0 OUTPUT
.Ve
.PP
Encodin ffpresets fo' common usages is provided so they can be used wit the
general presets system (e.g. passin tha \fBpre\fR option).
.SS "libxvid"
.IX Subsection "libxvid"
Xvid \s-1MPEG\-4\s0 Part 2 encoder wrapper.
.PP
This encoder requires tha presence of tha libxvidcore headaz n' library
durin configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\f(CW\*(C`\-\-enable\-libxvid \-\-enable\-gpl\*(C'\fR.
.PP
Da natizzle \f(CW\*(C`mpeg4\*(C'\fR encoder supports tha \s-1MPEG\-4\s0 Part 2 format, so
users can encode ta dis format without dis library.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da followin options is supported by tha libxvid wrapper n' shit. Right back up in yo muthafuckin ass. Some of
the followin options is listed but is not documented, and
correspond ta shared codec options. Right back up in yo muthafuckin ass. See tha Codec
Options chapta fo' they documentation. I aint talkin' bout chicken n' gravy biatch. Da other shared options
which is not listed have no effect fo' tha libxvid encoder.
.IP "\fBb\fR" 4
.IX Item "b"
.PD 0
.IP "\fBg\fR" 4
.IX Item "g"
.IP "\fBqmin\fR" 4
.IX Item "qmin"
.IP "\fBqmax\fR" 4
.IX Item "qmax"
.IP "\fBmpeg_quant\fR" 4
.IX Item "mpeg_quant"
.IP "\fBthreads\fR" 4
.IX Item "threads"
.IP "\fBbf\fR" 4
.IX Item "bf"
.IP "\fBb_qfactor\fR" 4
.IX Item "b_qfactor"
.IP "\fBb_qoffset\fR" 4
.IX Item "b_qoffset"
.IP "\fBflags\fR" 4
.IX Item "flags"
.PD
Set specific encodin flags. Possible joints:
.RS 4
.IP "\fBmv4\fR" 4
.IX Item "mv4"
Use four motion vector by macroblock.
.IP "\fBaic\fR" 4
.IX Item "aic"
Enable high qualitizzle \s-1AC\s0 prediction.
.IP "\fBgray\fR" 4
.IX Item "gray"
Only encode grayscale.
.IP "\fBgmc\fR" 4
.IX Item "gmc"
Enable tha use of global motion compensation (\s-1GMC\s0).
.IP "\fBqpel\fR" 4
.IX Item "qpel"
Enable quarter-pixel motion compensation.
.IP "\fBcgop\fR" 4
.IX Item "cgop"
Enable closed \s-1GOP.\s0
.IP "\fBglobal_header\fR" 4
.IX Item "global_header"
Place global headaz up in extradata instead of every last muthafuckin keyframe.
.RE
.RS 4
.RE
.IP "\fBtrellis\fR" 4
.IX Item "trellis"
.PD 0
.IP "\fBme_method\fR" 4
.IX Item "me_method"
.PD
Set motion estimation method. Y'all KNOW dat shit, muthafucka! Possible joints up in decreasin order of
speed n' increasin order of quality:
.RS 4
.IP "\fBzero\fR" 4
.IX Item "zero"
Use no motion estimation (default).
.IP "\fBphods\fR" 4
.IX Item "phods"
.PD 0
.IP "\fBx1\fR" 4
.IX Item "x1"
.IP "\fBlog\fR" 4
.IX Item "log"
.PD
Enable advanced diamond zonal search fo' 16x16 blocks n' half-pixel
refinement fo' 16x16 blocks. \fBx1\fR n' \fBlog\fR is aliases for
\&\fBphods\fR.
.IP "\fBepzs\fR" 4
.IX Item "epzs"
Enable all of tha thangs busted lyrics bout above, plus advanced diamond zonal
search fo' 8x8 blocks, half-pixel refinement fo' 8x8 blocks, n' motion
estimation on chroma planes.
.IP "\fBfull\fR" 4
.IX Item "full"
Enable all of tha thangs busted lyrics bout above, plus extended 16x16 n' 8x8
blocks search.
.RE
.RS 4
.RE
.IP "\fBmbd\fR" 4
.IX Item "mbd"
Set macroblock decision algorithm. Possible joints up in tha increasing
order of quality:
.RS 4
.IP "\fBsimple\fR" 4
.IX Item "simple"
Use macroblock comparin function algorithm (default).
.IP "\fBbits\fR" 4
.IX Item "bits"
Enable rate distortion-based half pixel n' quarta pixel refinement for
16x16 blocks.
.IP "\fBrd\fR" 4
.IX Item "rd"
Enable all of tha thangs busted lyrics bout above, plus rate distortion-based
half pixel n' quarta pixel refinement fo' 8x8 blocks, n' rate
distortion-based search rockin square pattern.
.RE
.RS 4
.RE
.IP "\fBlumi_aq\fR" 4
.IX Item "lumi_aq"
Enable lumi maskin adaptizzle quantization when set ta 1. Default is 0
(disabled).
.IP "\fBvariance_aq\fR" 4
.IX Item "variance_aq"
Enable variizzle adaptizzle quantization when set ta 1. Default is 0
(disabled).
.Sp
When combined wit \fBlumi_aq\fR, tha resultin qualitizzle will not
be betta than any of tha two specified individually. In other
words, tha resultin qualitizzle is ghon be tha worse one of tha two
effects.
.IP "\fBssim\fR" 4
.IX Item "ssim"
Set structural similaritizzle (\s-1SSIM\s0) displayin method. Y'all KNOW dat shit, muthafucka! Possible joints:
.RS 4
.IP "\fBoff\fR" 4
.IX Item "off"
Disable displayin of \s-1SSIM\s0 shiznit.
.IP "\fBavg\fR" 4
.IX Item "avg"
Output average \s-1SSIM\s0 all up in tha end of encodin ta stdout. Da format of
showin tha average \s-1SSIM\s0 is:
.Sp
.Vb 1
\&        Average SSIM: %f
.Ve
.Sp
For playas whoz ass is not familiar wit C, \f(CW%f\fR means a gangbangin' float number, or
a decimal (e.g. 0.939232).
.IP "\fBframe\fR" 4
.IX Item "frame"
Output both per-frame \s-1SSIM\s0 data durin encodin n' average \s-1SSIM\s0 at
the end of encodin ta stdout. Da format of per-frame shiznit
is:
.Sp
.Vb 1
\&               SSIM: avg: %1.3f min: %1.3f max: %1.3f
.Ve
.Sp
For playas whoz ass is not familiar wit C, \f(CW%1\fR.3f means a gangbangin' float number
rounded ta 3 digits afta tha dot (e.g. 0.932).
.RE
.RS 4
.RE
.IP "\fBssim_acc\fR" 4
.IX Item "ssim_acc"
Set \s-1SSIM\s0 accuracy. Valid options is integers within tha range of
0\-4, while 0 gives da most thugged-out accurate result n' 4 computes the
fastest.
.SS "png"
.IX Subsection "png"
\&\s-1PNG\s0 image encoder.
.PP
\fIPrivate options\fR
.IX Subsection "Private options"
.IP "\fBdpi\fR \fIinteger\fR" 4
.IX Item "dpi integer"
Set physical densitizzle of pixels, up in dots per inch, unset by default
.IP "\fBdpm\fR \fIinteger\fR" 4
.IX Item "dpm integer"
Set physical densitizzle of pixels, up in dots per meter, unset by default
.SS "ProRes"
.IX Subsection "ProRes"
Applez ProRes encoder.
.PP
FFmpeg gotz nuff 2 ProRes encoders, tha prores-aw n' prores-ks encoder.
Da used encoder can be chizzlen wit tha \f(CW\*(C`\-vcodec\*(C'\fR option.
.PP
\fIPrivate Options fo' prores-ks\fR
.IX Subsection "Private Options fo' prores-ks"
.IP "\fBprofile\fR \fIinteger\fR" 4
.IX Item "profile integer"
Select tha ProRes flava ta encode
.RS 4
.IP "\fBproxy\fR" 4
.IX Item "proxy"
.PD 0
.IP "\fBlt\fR" 4
.IX Item "lt"
.IP "\fBstandard\fR" 4
.IX Item "standard"
.IP "\fBhq\fR" 4
.IX Item "hq"
.IP "\fB4444\fR" 4
.IX Item "4444"
.RE
.RS 4
.RE
.IP "\fBquant_mat\fR \fIinteger\fR" 4
.IX Item "quant_mat integer"
.PD
Select quantization matrix.
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
.PD 0
.IP "\fBdefault\fR" 4
.IX Item "default"
.IP "\fBproxy\fR" 4
.IX Item "proxy"
.IP "\fBlt\fR" 4
.IX Item "lt"
.IP "\fBstandard\fR" 4
.IX Item "standard"
.IP "\fBhq\fR" 4
.IX Item "hq"
.RE
.RS 4
.PD
.Sp
If set ta \fIauto\fR, tha matrix matchin tha flava is ghon be picked.
If not set, tha matrix providin tha highest quality, \fIdefault\fR, will be
picked.
.RE
.IP "\fBbits_per_mb\fR \fIinteger\fR" 4
.IX Item "bits_per_mb integer"
How tha fuck nuff bits ta allot fo' codin one macroblock. Different profilez use
between 200 n' 2400 bits per macroblock, tha maximum is 8000.
.IP "\fBmbs_per_slice\fR \fIinteger\fR" 4
.IX Item "mbs_per_slice integer"
Number of macroblocks up in each slice (1\-8); tha default value (8)
should be phat up in almost all thangs.
.IP "\fBvendor\fR \fIstring\fR" 4
.IX Item "vendor string"
Override tha 4\-byte vendor \s-1ID.
A\s0 custom vendor \s-1ID\s0 like \fIapl0\fR would claim tha stream was produced by
the Applez encoder.
.IP "\fBalpha_bits\fR \fIinteger\fR" 4
.IX Item "alpha_bits integer"
Specify number of bits fo' alpha component.
Possible joints is \fI0\fR, \fI8\fR n' \fI16\fR.
Use \fI0\fR ta disable alpha plane coding.
.PP
\fISpeed considerations\fR
.IX Subsection "Speed considerations"
.PP
In tha default mode of operation tha encoder has ta honor frame constraints
(i.e. not produc frames wit size bigger than requested) while still making
output picture as phat as possible.
A frame containin a shitload of lil' small-ass details is harder ta compress n' tha encoder
would spend mo' time searchin fo' appropriate quantizers fo' each slice.
.PP
Settin a higher \fBbits_per_mb\fR limit will improve tha speed.
.PP
For tha fastest encodin speed set tha \fBqscale\fR parameta (4 is the
recommended value) n' do not set a size constraint.
.SH "BITSTREAM FILTERS"
.IX Header "BITSTREAM FILTERS"
When you configure yo' FFmpeg build, all tha supported bitstream
filtas is enabled by default. Yo ass can list all available ones using
the configure option \f(CW\*(C`\-\-list\-bsfs\*(C'\fR.
.PP
Yo ass can disable all tha bitstream filtas rockin tha configure option
\&\f(CW\*(C`\-\-disable\-bsfs\*(C'\fR, n' selectively enable any bitstream filta using
the option \f(CW\*(C`\-\-enable\-bsf=BSF\*(C'\fR, or you can disable a particular
bitstream filta rockin tha option \f(CW\*(C`\-\-disable\-bsf=BSF\*(C'\fR.
.PP
Da option \f(CW\*(C`\-bsfs\*(C'\fR of tha ff* tools will display tha list of
all tha supported bitstream filtas included up in yo' build.
.PP
Below be a thugged-out description of tha currently available bitstream filters.
.SS "aac_adtstoasc"
.IX Subsection "aac_adtstoasc"
Convert \s-1MPEG\-2/4 AAC ADTS\s0 ta \s-1MPEG\-4\s0 Audio Specific Configuration
bitstream filter.
.PP
This filta creates a \s-1MPEG\-4\s0 AudioSpecificConfig from a \s-1MPEG\-2/4
ADTS\s0 header n' removes tha \s-1ADTS\s0 header.
.PP
This is required fo' example when copyin a \s-1AAC\s0 stream from a raw
\&\s-1ADTS AAC\s0 container ta a \s-1FLV\s0 or a \s-1MOV/MP4\s0 file.
.SS "chomp"
.IX Subsection "chomp"
Remove zero paddin all up in tha end of a packet.
.SS "dump_extra"
.IX Subsection "dump_extra"
Add extradata ta tha beginnin of tha filtered packets.
.PP
Da additionizzle argument specifies which packets should be filtered.
It accepts tha joints:
.IP "\fBa\fR" 4
.IX Item "a"
add extradata ta all key packets yo, but only if \fIlocal_header\fR is
set up in tha \fBflags2\fR codec context field
.IP "\fBk\fR" 4
.IX Item "k"
add extradata ta all key packets
.IP "\fBe\fR" 4
.IX Item "e"
add extradata ta all packets
.PP
If not specified it be assumed \fBk\fR.
.PP
For example tha followin \fBffmpeg\fR command forces a global
header (thus disablin individual packet headers) up in tha H.264 packets
generated by tha \f(CW\*(C`libx264\*(C'\fR encoder yo, but erects dem by adding
the header stored up in extradata ta tha key packets:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-map 0 \-flags:v +global_header \-c:v libx264 \-bsf:v dump_extra out.ts
.Ve
.SS "h264_mp4toannexb"
.IX Subsection "h264_mp4toannexb"
Convert a H.264 bitstream from length prefixed mode ta start code
prefixed mode (as defined up in tha Annex B of tha ITU-T H.264
specification).
.PP
This is required by some streamin formats, typically tha \s-1MPEG\-2\s0
transhiznit stream format (\*(L"mpegts\*(R").
.PP
For example ta remux a \s-1MP4\s0 file containin a H.264 stream ta mpegts
format wit \fBffmpeg\fR, you can use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT.mp4 \-codec copy \-bsf:v h264_mp4toannexb OUTPUT.ts
.Ve
.SS "imx_dump_header"
.IX Subsection "imx_dump_header"
.SS "mjpeg2jpeg"
.IX Subsection "mjpeg2jpeg"
Convert \s-1MJPEG/AVI1\s0 packets ta full \s-1JPEG/JFIF\s0 packets.
.PP
\&\s-1MJPEG\s0 be a vizzle codec wherein each vizzle frame is essentially a
\&\s-1JPEG\s0 image. Da individual frames can be extracted without loss,
e.g. by
.PP
.Vb 1
\&        ffmpeg \-i ../some_mjpeg.avi \-c:v copy frames_%d.jpg
.Ve
.PP
Unfortunately, these chunks is incomplete \s-1JPEG\s0 images, cuz
they lack tha \s-1DHT\s0 segment required fo' decoding. Quotin from
<\fBhttp://www.digitalpreservation.gov/formats/fdd/fdd000063.shtml\fR>:
.PP
Avery Lee, freestylin up in tha rec.video.desktop newsgroup up in 2001,
commented dat \*(L"\s-1MJPEG,\s0 or at least tha \s-1MJPEG\s0 up in AVIs havin the
\&\s-1MJPG\s0 fourcc, is restricted \s-1JPEG\s0 wit a gangbangin' fixed \*(-- n' *omitted* \*(--
Huffman table. Da \s-1JPEG\s0 must be YCbCr colorspace, it must be 4:2:2,
and it must use basic Huffman encoding, not arithmetic or
progressive. . . . Yo ass can indeed extract tha \s-1MJPEG\s0 frames and
decode dem wit a regular \s-1JPEG\s0 decoder yo, but you gotta prepend
the \s-1DHT\s0 segment ta them, or else tha decoder won't have any idea
how ta decompress tha data. Da exact table necessary is given in
the OpenDML spec.\*(R"
.PP
This bitstream filta patches tha header of frames extracted from a \s-1MJPEG\s0
stream (carryin tha \s-1AVI1\s0 header \s-1ID\s0 n' lackin a \s-1DHT\s0 segment) to
produce straight-up qualified \s-1JPEG\s0 images.
.PP
.Vb 3
\&        ffmpeg \-i mjpeg\-movie.avi \-c:v copy \-bsf:v mjpeg2jpeg frame_%d.jpg
\&        exiftran \-i \-9 frame*.jpg
\&        ffmpeg \-i frame_%d.jpg \-c:v copy rotated.avi
.Ve
.SS "mjpega_dump_header"
.IX Subsection "mjpega_dump_header"
.SS "movsub"
.IX Subsection "movsub"
.SS "mp3_header_compress"
.IX Subsection "mp3_header_compress"
.SS "mp3_header_decompress"
.IX Subsection "mp3_header_decompress"
.SS "noise"
.IX Subsection "noise"
.SS "remove_extra"
.IX Subsection "remove_extra"
.SH "FORMAT OPTIONS"
.IX Header "FORMAT OPTIONS"
Da libavformat library serves up some generic global options, which
can be set on all tha muxers n' demuxers. In addizzle each muxer or
demuxer may support so-called private options, which is specific for
that component.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, or by settin tha value explicitly up in the
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.PP
Da list of supported options bigs up:
.IP "\fBavioflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "avioflags flags (input/output)"
Possible joints:
.RS 4
.IP "\fBdirect\fR" 4
.IX Item "direct"
Reduce buffering.
.RE
.RS 4
.RE
.IP "\fBprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "probesize integer (input)"
Set probin size up in bytes, i.e. tha size of tha data ta analyze ta get
stream shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. A higher value will allow ta detect more
information up in case it is dispersed tha fuck into tha stream yo, but will increase
latency. Must be a integer not lesser than 32. Well shiiiit, it is 5000000 by default.
.IP "\fBpacketsize\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "packetsize integer (output)"
Set packet size.
.IP "\fBfflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fflags flags (input/output)"
Set format flags.
.Sp
Possible joints:
.RS 4
.IP "\fBignidx\fR" 4
.IX Item "ignidx"
Ignore index.
.IP "\fBgenpts\fR" 4
.IX Item "genpts"
Generate \s-1PTS.\s0
.IP "\fBnofillin\fR" 4
.IX Item "nofillin"
Do not fill up in missin joints dat can be exactly calculated.
.IP "\fBnoparse\fR" 4
.IX Item "noparse"
Disable AVParsers, dis needz \f(CW\*(C`+nofillin\*(C'\fR like a muthafucka.
.IP "\fBigndts\fR" 4
.IX Item "igndts"
Ignore \s-1DTS.\s0
.IP "\fBdiscardcorrupt\fR" 4
.IX Item "discardcorrupt"
Discard corrupted frames.
.IP "\fBsortdts\fR" 4
.IX Item "sortdts"
Try ta interleave output packets by \s-1DTS.\s0
.IP "\fBkeepside\fR" 4
.IX Item "keepside"
Do not merge side data.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Enable \s-1RTP MP4A\-LATM\s0 payload.
.IP "\fBnobuffer\fR" 4
.IX Item "nobuffer"
Reduce tha latency introduced by optionizzle buffering
.RE
.RS 4
.RE
.IP "\fBseek2any\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "seek2any integer (input)"
Allow seekin ta non-keyframes on demuxer level when supported if set ta 1.
Default is 0.
.IP "\fBanalyzeduration\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "analyzeduration integer (input)"
Specify how tha fuck nuff microsecondz is analyzed ta probe tha input fo' realz. A
higher value will allow ta detect mo' accurate shiznit yo, but will
increase latency. Well shiiiit, it defaults ta 5,000,000 microsecondz = 5 seconds.
.IP "\fBcryptokey\fR \fIhexadecimal string\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "cryptokey hexadecimal strang (input)"
Set decryption key.
.IP "\fBindexmem\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "indexmem integer (input)"
Set max memory used fo' timestamp index (per stream).
.IP "\fBrtbufsize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "rtbufsize integer (input)"
Set max memory used fo' bufferin real-time frames.
.IP "\fBfdebug\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fdebug flags (input/output)"
Print specific debug info.
.Sp
Possible joints:
.RS 4
.IP "\fBts\fR" 4
.IX Item "ts"
.RE
.RS 4
.RE
.PD 0
.IP "\fBmax_delay\fR \fIinteger\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "max_delay integer (input/output)"
.PD
Set maximum muxin or demuxin delay up in microseconds.
.IP "\fBfpsprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "fpsprobesize integer (input)"
Set number of frames used ta probe fps.
.IP "\fBaudio_preload\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "audio_preload integer (output)"
Set microsecondz by which audio packets should be interleaved earlier.
.IP "\fBchunk_duration\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_duration integer (output)"
Set microsecondz fo' each chunk.
.IP "\fBchunk_size\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_size integer (output)"
Set size up in bytes fo' each chunk.
.IP "\fBerr_detect, f_err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "err_detect, f_err_detect flags (input)"
Set error detection flags. \f(CW\*(C`f_err_detect\*(C'\fR is deprecated and
should be used only via tha \fBffmpeg\fR tool.
.Sp
Possible joints:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
Verify embedded CRCs.
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
Detect bitstream justification deviations.
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
Detect improper bitstream length.
.IP "\fBexplode\fR" 4
.IX Item "explode"
Abort decodin on minor error detection.
.IP "\fBcareful\fR" 4
.IX Item "careful"
Consider thangs dat violate tha spec n' aint been peeped up in the
wild as errors.
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
Consider all spec non compliancies as errors.
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
Consider thangs dat a sane encoder should not do as a error.
.RE
.RS 4
.RE
.IP "\fBuse_wallclock_as_timestamps\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "use_wallclock_as_timestamps integer (input)"
Use wallclock as timestamps.
.IP "\fBavoid_negative_ts\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "avoid_negative_ts integer (output)"
Shift timestamps ta make dem non-negatizzle fo' realz. A value of 1 enablez shifting,
a value of 0 disablez it, tha default value of \-1 enablez shifting
when required by tha target format.
.Sp
When shiftin is enabled, all output timestamps is shifted by the
same amount fo' realz. Audio, vizzle, n' subtitlez desynchin n' relative
timestamp differences is preserved compared ta how tha fuck they would have
been without shifting.
.Sp
Also note dat dis affects only leadin wack timestamps, n' not
non-monotonic wack timestamps.
.IP "\fBskip_initial_bytes\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "skip_initial_bytes integer (input)"
Set number of bytes ta skip before readin header n' frames if set ta 1.
Default is 0.
.IP "\fBcorrect_ts_overflow\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "correct_ts_overflow integer (input)"
Correct single timestamp overflows if set ta 1. Default is 1.
.IP "\fBflush_packets\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "flush_packets integer (output)"
Flush tha underlyin I/O stream afta each packet. Default 1 enablez it, and
has tha effect of reducin tha latency; 0 disablez it n' may slightly
increase performizzle up in some cases.
.SS "Format stream specifiers"
.IX Subsection "Format stream specifiers"
Format stream specifiers allow selection of one or mo' streams that
match specific properties.
.PP
Possible formz of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches tha stream wit dis index.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of following: 'v' fo' vizzle, 'a' fo' audio,
\&'s' fo' subtitle, 'd' fo' data, n' 't' fo' attachments, n' you can put dat on yo' toast. If
\&\fIstream_index\fR is given, then it matches tha stream number
\&\fIstream_index\fR of dis type. Otherwise, it matches all streams of
this type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then it matches tha stream wit number
\&\fIstream_index\fR up in tha program wit tha id
\&\fIprogram_id\fR. Otherwise, it matches all streams up in tha program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches tha stream by a gangbangin' format-specific \s-1ID.\s0
.PP
Da exact semantics of stream specifiers is defined by the
\&\f(CW\*(C`avformat_match_stream_specifier()\*(C'\fR function declared up in the
\&\fIlibavformat/avformat.h\fR header.
.SH "DEMUXERS"
.IX Header "DEMUXERS"
Demuxers is configured elements up in FFmpeg dat can read the
multimedia streams from a particular type of file.
.PP
When you configure yo' FFmpeg build, all tha supported demuxers
are enabled by default. Yo ass can list all available ones rockin the
configure option \f(CW\*(C`\-\-list\-demuxers\*(C'\fR.
.PP
Yo ass can disable all tha demuxers rockin tha configure option
\&\f(CW\*(C`\-\-disable\-demuxers\*(C'\fR, n' selectively enable a single demuxer with
the option \f(CW\*(C`\-\-enable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR, or disable it
with tha option \f(CW\*(C`\-\-disable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-formats\*(C'\fR of tha ff* tools will display tha list of
enabled demuxers.
.PP
Da description of a shitload of tha currently available demuxers bigs up.
.SS "applehttp"
.IX Subsection "applehttp"
Applez \s-1HTTP\s0 Live Streamin demuxer.
.PP
This demuxer presents all AVStreams from all variant streams.
Da id field is set ta tha bitrate variant index number n' shit. By setting
the discard flags on AVStreams (by pressin 'a' or 'v' up in ffplay),
the calla can decizzle which variant streams ta straight-up receive.
Da total bitrate of tha variant dat tha stream belongs ta is
available up in a metadata key named \*(L"variant_bitrate\*(R".
.SS "asf"
.IX Subsection "asf"
Advanced Systems Format demuxer.
.PP
This demuxer is used ta demux \s-1ASF\s0 filez n' \s-1MMS\s0 network streams.
.IP "\fB\-no_resync_search\fR \fIbool\fR" 4
.IX Item "-no_resync_search bool"
Do not try ta resynchronize by lookin fo' a cold-ass lil certain optionizzle start code.
.SS "concat"
.IX Subsection "concat"
Virtual concatenation script demuxer.
.PP
This demuxer readz a list of filez n' other directives from a text file and
demuxes dem one afta tha other, as if all they packet had been muxed
together.
.PP
Da timestamps up in tha filez is adjusted so dat tha straight-up original gangsta file starts at 0
and each next file starts where tha previous one finishes. Note dat it is
done globally n' may cause gaps if all streams aint gots exactly tha same
length.
.PP
All filez must have tha same streams (same codecs, same time base, etc.).
.PP
Da duration of each file is used ta adjust tha timestampz of tha next file:
if tha duration is incorrect (because dat shiznit was computed rockin tha bit-rate or
because tha file is truncated, fo' example), it can cause artifacts, n' you can put dat on yo' toast. The
\&\f(CW\*(C`duration\*(C'\fR directizzle can be used ta override tha duration stored in
each file.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
Da script be a text file up in extended-ASCII, wit one directizzle per line.
Empty lines, leadin spaces n' lines startin wit '#' is ignored. Y'all KNOW dat shit, muthafucka! The
followin directizzle is recognized:
.ie n .IP "\fB\fB""file \f(BIpath\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBfile \f(CBpath\f(CB\fB\fR" 4
.IX Item "file path"
Path ta a gangbangin' file ta read; special charactas n' spaces must be escaped with
backslash or single quotes.
.Sp
All subsequent directives apply ta dat file.
.ie n .IP "\fB\fB""ffconcat version 1.0""\fB\fR" 4
.el .IP "\fB\f(CBffconcat version 1.0\fB\fR" 4
.IX Item "ffconcat version 1.0"
Identify tha script type n' version. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also sets tha \fBsafe\fR option
to 1 if dat shiznit was ta its default \-1.
.Sp
To make FFmpeg recognize tha format automatically, dis directizzle must
appears exactly as is (no extra space or byte-order-mark) on tha straight-up first
line of tha script.
.ie n .IP "\fB\fB""duration \f(BIdur\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBduration \f(CBdur\f(CB\fB\fR" 4
.IX Item "duration dur"
Duration of tha file. This shiznit can be specified from tha file;
specifyin it here may be mo' efficient or help if tha shiznit from the
file aint available or accurate.
.Sp
If tha duration is set fo' all files, then it is possible ta seek up in the
whole concatenated vizzle.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This demuxer accepts tha followin option:
.IP "\fBsafe\fR" 4
.IX Item "safe"
If set ta 1, reject unsafe file paths fo' realz. A file path is considered safe if it
does not contain a protocol justification n' is relatizzle n' all components
only contain charactas from tha portable characta set (letters, digits,
period, underscore n' hyphen) n' have no period all up in tha beginnin of a
component.
.Sp
If set ta 0, any file name be accepted.
.Sp
Da default is \-1, it is equivalent ta 1 if tha format was automatically
probed n' 0 otherwise.
.SS "flv"
.IX Subsection "flv"
Adobe Flash Video Format demuxer.
.PP
This demuxer is used ta demux \s-1FLV\s0 filez n' \s-1RTMP\s0 network streams.
.IP "\fB\-flv_metadata\fR \fIbool\fR" 4
.IX Item "-flv_metadata bool"
Allocate tha streams accordin ta tha onMetaData array content.
.SS "libgme"
.IX Subsection "libgme"
Da Game Music Emu library be a cold-ass lil collection of vizzle game noize file emulators.
.PP
See <\fBhttp://code.google.com/p/game\-music\-emu/\fR> fo' mo' shiznit.
.PP
Some filez have multiple tracks. Da demuxer will pick tha straight-up original gangsta track by
default. Da \fBtrack_index\fR option can be used ta select a gangbangin' finger-lickin' different
track. Track indexes start at 0. Da demuxer exports tha number of tracks as
\&\fItracks\fR meta data entry.
.PP
For straight-up big-ass files, tha \fBmax_size\fR option may gotta be adjusted.
.SS "libquvi"
.IX Subsection "libquvi"
Play media from Internizzle skillz rockin tha quvi project.
.PP
Da demuxer accepts a \fBformat\fR option ta request a specific quality. It
is by default set ta \fIbest\fR.
.PP
See <\fBhttp://quvi.sourceforge.net/\fR> fo' mo' shiznit.
.PP
FFmpeg need ta be built wit \f(CW\*(C`\-\-enable\-libquvi\*(C'\fR fo' dis demuxer ta be
enabled.
.SS "image2"
.IX Subsection "image2"
Image file demuxer.
.PP
This demuxer readz from a list of image filez specified by a pattern.
Da syntax n' meanin of tha pattern is specified by the
option \fIpattern_type\fR.
.PP
Da pattern may contain a suffix which is used ta automatically
determine tha format of tha images contained up in tha files.
.PP
Da size, tha pixel format, n' tha format of each image must be the
same fo' all tha filez up in tha sequence.
.PP
This demuxer accepts tha followin options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha frame rate fo' tha vizzle stream. Well shiiiit, it defaults ta 25.
.IP "\fBloop\fR" 4
.IX Item "loop"
If set ta 1, loop over tha input. Default value is 0.
.IP "\fBpattern_type\fR" 4
.IX Item "pattern_type"
Select tha pattern type used ta interpret tha provided filename.
.Sp
\&\fIpattern_type\fR accepts one of tha followin joints.
.RS 4
.IP "\fBsequence\fR" 4
.IX Item "sequence"
Select a sequence pattern type, used ta specify a sequence of files
indexed by sequential numbers.
.Sp
A sequence pattern may contain tha strang \*(L"%d\*(R" or "%0\fIN\fRd\*(L", which
specifies tha posizzle of tha charactas representin a sequential
number up in each filename matched by tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If tha form
\&\*(R"%d0\fIN\fRd" is used, tha strang representin tha number up in each
filename is 0\-padded n' \fIN\fR is tha total number of 0\-padded
digits representin tha number n' shit. Da literal characta '%' can be
specified up in tha pattern wit tha strang \*(L"%%\*(R".
.Sp
If tha sequence pattern gotz nuff \*(L"%d\*(R" or "%0\fIN\fRd", tha straight-up original gangsta filename of
the file list specified by tha pattern must contain a number
inclusively contained between \fIstart_number\fR and
\&\fIstart_number\fR+\fIstart_number_range\fR\-1, n' all tha following
numbers must be sequential.
.Sp
For example tha pattern \*(L"img\-%03d.bmp\*(R" will match a sequence of
filenamez of tha form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.; tha pattern \*(L"i%%m%%g\-%d.jpg\*(R" will match a
sequence of filenamez of tha form \fIi%m%g\-1.jpg\fR,
\&\fIi%m%g\-2.jpg\fR, ..., \fIi%m%g\-10.jpg\fR, etc.
.Sp
Note dat tha pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", fo' example ta convert a single image file
\&\fIimg.jpeg\fR you can employ tha command:
.Sp
.Vb 1
\&        ffmpeg \-i img.jpeg img.png
.Ve
.IP "\fBglob\fR" 4
.IX Item "glob"
Select a glob wildcard pattern type.
.Sp
Da pattern is interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This is only
selectable if libavformat was compiled wit globbin support.
.IP "\fBglob_sequence\fR \fI(deprecated, is ghon be removed)\fR" 4
.IX Item "glob_sequence (deprecated, is ghon be removed)"
Select a mixed glob wildcard/sequence pattern.
.Sp
If yo' version of libavformat was compiled wit globbin support, and
the provided pattern gotz nuff at least one glob meta characta among
\&\f(CW\*(C`%*?[]{}\*(C'\fR dat is preceded by a unescaped \*(L"%\*(R", tha pattern is
interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, otherwise it is interpreted
like a sequence pattern.
.Sp
All glob special charactas \f(CW\*(C`%*?[]{}\*(C'\fR must be prefixed
with \*(L"%\*(R". To escape a literal \*(L"%\*(R" you shall use \*(L"%%\*(R".
.Sp
For example tha pattern \f(CW\*(C`foo\-%*.jpeg\*(C'\fR will match all the
filenames prefixed by \*(L"foo\-\*(R" n' terminatin wit \*(L".jpeg\*(R", and
\&\f(CW\*(C`foo\-%?%?%?.jpeg\*(C'\fR will match all tha filenames prefixed with
\&\*(L"foo\-\*(R", followed by a sequence of three characters, n' terminating
with \*(L".jpeg\*(R".
.Sp
This pattern type is deprecated up in favor of \fIglob\fR and
\&\fIsequence\fR.
.RE
.RS 4
.Sp
Default value is \fIglob_sequence\fR.
.RE
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set tha pixel format of tha images ta read. Y'all KNOW dat shit, muthafucka! If not specified tha pixel
format is guessed from tha straight-up original gangsta image file up in tha sequence.
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Set tha index of tha file matched by tha image file pattern ta start
to read from. Default value is 0.
.IP "\fBstart_number_range\fR" 4
.IX Item "start_number_range"
Set tha index interval range ta check when lookin fo' tha straight-up original gangsta image
file up in tha sequence, startin from \fIstart_number\fR. Default value
is 5.
.IP "\fBts_from_file\fR" 4
.IX Item "ts_from_file"
If set ta 1, will set frame timestamp ta modification time of image file. Note
that monotonitizzle of timestamps aint provided: images go up in tha same order as
without dis option. I aint talkin' bout chicken n' gravy biatch. Default value is 0.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle size of tha images ta read. Y'all KNOW dat shit, muthafucka! If not specified tha vizzle
size is guessed from tha straight-up original gangsta image file up in tha sequence.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use \fBffmpeg\fR fo' bustin a vizzle from tha images up in tha file
sequence \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ..., assumin an
input frame rate of 10 frames per second:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
As above yo, but start by readin from a gangbangin' file wit index 100 up in tha sequence:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-start_number 100 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
Read images matchin tha \*(L"*.png\*(R" glob pattern , dat be all tha files
terminatin wit tha \*(L".png\*(R" suffix:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-pattern_type glob \-i "*.png" out.mkv
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\-2\s0 transhiznit stream demuxer.
.IP "\fBfix_teletext_pts\fR" 4
.IX Item "fix_teletext_pts"
Overrides teletext packet \s-1PTS\s0 n' \s-1DTS\s0 joints wit tha timestamps calculated
from tha \s-1PCR\s0 of tha straight-up original gangsta program which tha teletext stream is part of n' is
not discarded. Y'all KNOW dat shit, muthafucka! Default value is 1, set dis option ta 0 if you want your
teletext packet \s-1PTS\s0 n' \s-1DTS\s0 joints untouched.
.SS "rawvideo"
.IX Subsection "rawvideo"
Raw vizzle demuxer.
.PP
This demuxer allows ta read raw vizzle data. Right back up in yo muthafuckin ass. Since there is no header
specifyin tha assumed vizzle parameters, tha user must specify them
in order ta be able ta decode tha data erectly.
.PP
This demuxer accepts tha followin options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set input vizzle frame rate. Default value is 25.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set tha input vizzle pixel format. Default value is \f(CW\*(C`yuv420p\*(C'\fR.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha input vizzle size. This value must be specified explicitly.
.PP
For example ta read a rawvideo file \fIinput.raw\fR with
\&\fBffplay\fR, assumin a pixel format of \f(CW\*(C`rgb24\*(C'\fR, a vizzle
size of \f(CW\*(C`320x240\*(C'\fR, n' a gangbangin' frame rate of 10 images per second, use
the command:
.PP
.Vb 1
\&        ffplay \-f rawvideo \-pixel_format rgb24 \-video_size 320x240 \-framerate 10 input.raw
.Ve
.SS "sbg"
.IX Subsection "sbg"
SBaGen script demuxer.
.PP
This demuxer readz tha script language used by SBaGen
<\fBhttp://uazu.net/sbagen/\fR> ta generate binaural beats sessions fo' realz. A \s-1SBG\s0
script be lookin like that:
.PP
.Vb 9
\&        \-SE
\&        a: 300\-2.5/3 440+4.5/0
\&        b: 300\-2.5/0 440+4.5/3
\&        off: \-
\&        NOW      == a
\&        +0:07:00 == b
\&        +0:14:00 == a
\&        +0:21:00 == b
\&        +0:30:00    off
.Ve
.PP
A \s-1SBG\s0 script can mix absolute n' relatizzle timestamps. If tha script uses
either only absolute timestamps (includin tha script start time) or only
relatizzle ones, then its layout is fixed, n' tha conversion is
straightforward. Y'all KNOW dat shit, muthafucka! On tha other hand, if tha script mixes both kind of
timestamps, then tha \fI\s-1NOW\s0\fR reference fo' relatizzle timestamps will be
taken from tha current time of dizzle all up in tha time tha script is read, n' the
script layout is ghon be frozen accordin ta dat reference. That means dat if
the script is directly played, tha actual times will match tha absolute
timestamps up ta tha sound controllerz clock accuracy yo, but if tha user
somehow pauses tha playback or seeks, all times is ghon be shifted accordingly.
.SS "tedcaptions"
.IX Subsection "tedcaptions"
\&\s-1JSON\s0 captions used fo' <\fBhttp://www.ted.com/\fR>.
.PP
\&\s-1TED\s0 do not provide links ta tha captions yo, but they can be guessed from the
page. Da file \fItools/bookmarklets.html\fR from tha FFmpeg source tree
gotz nuff a funky-ass bookmarklet ta expose em.
.PP
This demuxer accepts tha followin option:
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Set tha start time of tha \s-1TED\s0 talk, up in milliseconds. Da default is 15000
(15s). Well shiiiit, it is used ta sync tha captions wit tha downloadable vizzles, cuz
they include a 15s intro.
.PP
Example: convert tha captions ta a gangbangin' format most playas understand:
.PP
.Vb 1
\&        ffmpeg \-i http://www.ted.com/talks/subtitles/id/1/lang/en talk1\-en.srt
.Ve
.SH "MUXERS"
.IX Header "MUXERS"
Muxers is configured elements up in FFmpeg which allow writing
multimedia streams ta a particular type of file.
.PP
When you configure yo' FFmpeg build, all tha supported muxers
are enabled by default. Yo ass can list all available muxers rockin the
configure option \f(CW\*(C`\-\-list\-muxers\*(C'\fR.
.PP
Yo ass can disable all tha muxers wit tha configure option
\&\f(CW\*(C`\-\-disable\-muxers\*(C'\fR n' selectively enable / disable single muxers
with tha options \f(CW\*(C`\-\-enable\-muxer=\f(CIMUXER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-muxer=\f(CIMUXER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-formats\*(C'\fR of tha ff* tools will display tha list of
enabled muxers.
.PP
A description of a shitload of tha currently available muxers bigs up.
.SS "aiff"
.IX Subsection "aiff"
Audio Interchange File Format muxer.
.PP
It accepts tha followin options:
.IP "\fBwrite_id3v2\fR" 4
.IX Item "write_id3v2"
Enable ID3v2 tags freestylin when set ta 1. Default is 0 (disabled).
.IP "\fBid3v2_version\fR" 4
.IX Item "id3v2_version"
Select ID3v2 version ta write. Currently only version 3 n' 4 (aka.
ID3v2.3 n' ID3v2.4) is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default is version 4.
.SS "crc"
.IX Subsection "crc"
\&\s-1CRC \s0(Cyclic Redundancy Check) testin format.
.PP
This muxer computes n' prints tha Adler\-32 \s-1CRC\s0 of all tha input audio
and vizzle frames. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
\&\s-1CRC.\s0
.PP
Da output of tha muxer consistz of a single line of tha form:
CRC=0x\fI\s-1CRC\s0\fR, where \fI\s-1CRC\s0\fR be a hexadecimal number 0\-padded to
8 digits containin tha \s-1CRC\s0 fo' all tha decoded input frames.
.PP
For example ta compute tha \s-1CRC\s0 of tha input, n' store it up in tha file
\&\fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc out.crc
.Ve
.PP
Yo ass can print tha \s-1CRC\s0 ta stdout wit tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc \-
.Ve
.PP
Yo ass can select tha output format of each frame wit \fBffmpeg\fR by
specifyin tha audio n' vizzle codec n' format. For example to
compute tha \s-1CRC\s0 of tha input audio converted ta \s-1PCM\s0 unsigned 8\-bit
and tha input vizzle converted ta \s-1MPEG\-2\s0 vizzle, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f crc \-
.Ve
.PP
See also tha framecrc muxer.
.SS "framecrc"
.IX Subsection "framecrc"
Per-packet \s-1CRC \s0(Cyclic Redundancy Check) testin format.
.PP
This muxer computes n' prints tha Adler\-32 \s-1CRC\s0 fo' each audio
and vizzle packet. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
\&\s-1CRC.\s0
.PP
Da output of tha muxer consistz of a line fo' each audio n' vizzle
packet of tha form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, 0x<CRC>
.Ve
.PP
\&\fI\s-1CRC\s0\fR be a hexadecimal number 0\-padded ta 8 digits containin the
\&\s-1CRC\s0 of tha packet.
.PP
For example ta compute tha \s-1CRC\s0 of tha audio n' vizzle frames in
\&\fI\s-1INPUT\s0\fR, converted ta raw audio n' vizzle packets, n' store it
in tha file \fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc out.crc
.Ve
.PP
To print tha shiznit ta stdout, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc \-
.Ve
.PP
With \fBffmpeg\fR, you can select tha output format ta which the
audio n' vizzle frames is encoded before computin tha \s-1CRC\s0 fo' each
packet by specifyin tha audio n' vizzle codec. For example, to
compute tha \s-1CRC\s0 of each decoded input audio frame converted ta \s-1PCM\s0
unsigned 8\-bit n' of each decoded input vizzle frame converted to
\&\s-1MPEG\-2\s0 vizzle, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f framecrc \-
.Ve
.PP
See also tha crc muxer.
.SS "framemd5"
.IX Subsection "framemd5"
Per-packet \s-1MD5\s0 testin format.
.PP
This muxer computes n' prints tha \s-1MD5\s0 hash fo' each audio
and vizzle packet. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
hash.
.PP
Da output of tha muxer consistz of a line fo' each audio n' vizzle
packet of tha form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, <MD5>
.Ve
.PP
\&\fI\s-1MD5\s0\fR be a hexadecimal number representin tha computed \s-1MD5\s0 hash
for tha packet.
.PP
For example ta compute tha \s-1MD5\s0 of tha audio n' vizzle frames in
\&\fI\s-1INPUT\s0\fR, converted ta raw audio n' vizzle packets, n' store it
in tha file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 out.md5
.Ve
.PP
To print tha shiznit ta stdout, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 \-
.Ve
.PP
See also tha md5 muxer.
.SS "hls"
.IX Subsection "hls"
Applez \s-1HTTP\s0 Live Streamin muxer dat segments MPEG-TS accordin to
the \s-1HTTP\s0 Live Streamin justification.
.PP
It creates a playlist file n' numbered segment files. Da output
filename specifies tha playlist filename; tha segment filenames
receive tha same basename as tha playlist, a sequential number and
a .ts extension.
.PP
.Vb 1
\&        ffmpeg \-i in.nut out.m3u8
.Ve
.IP "\fB\-hls_time\fR \fIseconds\fR" 4
.IX Item "-hls_time seconds"
Set tha segment length up in seconds.
.IP "\fB\-hls_list_size\fR \fIsize\fR" 4
.IX Item "-hls_list_size size"
Set tha maximum number of playlist entries.
.IP "\fB\-hls_wrap\fR \fIwrap\fR" 4
.IX Item "-hls_wrap wrap"
Set tha number afta which index wraps.
.IP "\fB\-start_number\fR \fInumber\fR" 4
.IX Item "-start_number number"
Start tha sequence from \fInumber\fR.
.SS "ico"
.IX Subsection "ico"
\&\s-1ICO\s0 file muxer.
.PP
Microsoftz icon file format (\s-1ICO\s0) has some strict limitations dat should be noted:
.IP "\(bu" 4
Size cannot exceed 256 pixels up in any dimension
.IP "\(bu" 4
Only \s-1BMP\s0 n' \s-1PNG\s0 images can be stored
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must be one of tha followin pixel formats:
.Sp
.Vb 7
\&        BMP Bit Depth      FFmpeg Pixel Format
\&        1bit               pal8
\&        4bit               pal8
\&        8bit               pal8
\&        16bit              rgb555le
\&        24bit              bgr24
\&        32bit              bgra
.Ve
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must use tha \s-1BITMAPINFOHEADER DIB\s0 header
.IP "\(bu" 4
If a \s-1PNG\s0 image is used, it must use tha rgba pixel format
.SS "image2"
.IX Subsection "image2"
Image file muxer.
.PP
Da image file muxer writes vizzle frames ta image files.
.PP
Da output filenames is specified by a pattern, which can be used to
produce sequentially numbered seriez of files.
Da pattern may contain tha strang \*(L"%d\*(R" or "%0\fIN\fRd\*(L", dis string
specifies tha posizzle of tha charactas representin a numberin in
the filenames. If tha form \*(R"%0\fIN\fRd" is used, tha string
representin tha number up in each filename is 0\-padded ta \fIN\fR
digits, n' you can put dat on yo' toast. Da literal characta '%' can be specified up in tha pattern with
the strang \*(L"%%\*(R".
.PP
If tha pattern gotz nuff \*(L"%d\*(R" or "%0\fIN\fRd", tha straight-up original gangsta filename of
the file list specified will contain tha number 1, all tha following
numbers is ghon be sequential.
.PP
Da pattern may contain a suffix which is used ta automatically
determine tha format of tha image filez ta write.
.PP
For example tha pattern \*(L"img\-%03d.bmp\*(R" will specify a sequence of
filenamez of tha form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.
Da pattern \*(L"img%%\-%d.jpg\*(R" will specify a sequence of filenamez of the
form \fIimg%\-1.jpg\fR, \fIimg%\-2.jpg\fR, ..., \fIimg%\-10.jpg\fR,
etc.
.PP
Da followin example shows how tha fuck ta use \fBffmpeg\fR fo' bustin a
sequence of filez \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ...,
takin one image every last muthafuckin second from tha input vizzle:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \-f image2 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note dat wit \fBffmpeg\fR, if tha format aint specified wit the
\&\f(CW\*(C`\-f\*(C'\fR option n' tha output filename specifies a image file
format, tha image2 muxer be automatically selected, so tha previous
command can be freestyled as:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note also dat tha pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", fo' example ta create a single image file
\&\fIimg.jpeg\fR from tha input vizzle you can employ tha command:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-f image2 \-frames:v 1 img.jpeg
.Ve
.IP "\fBstart_number\fR \fInumber\fR" 4
.IX Item "start_number number"
Start tha sequence from \fInumber\fR. Default value is 1. Must be a
non-negatizzle number.
.IP "\fB\-update\fR \fInumber\fR" 4
.IX Item "-update number"
If \fInumber\fR is nonzero, tha filename will always be interpreted as just a
filename, not a pattern, n' dis file is ghon be continuously overwritten wit new
images.
.PP
Da image muxer supports tha .Y.U.V image file format. This format is
special up in dat that each image frame consistz of three files, for
each of tha \s-1YUV420P\s0 components, n' you can put dat on yo' toast. To read or write dis image file format,
specify tha name of tha '.Y' file. Da muxer will automatically open the
\&'.U' n' '.V' filez as required.
.SS "matroska"
.IX Subsection "matroska"
Matroska container muxer.
.PP
This muxer implements tha matroska n' webm container specs.
.PP
Da recognized metadata settings up in dis muxer are:
.IP "\fBtitle=\fR\fItitle name\fR" 4
.IX Item "title=title name"
Name provided ta a single track
.IP "\fBlanguage=\fR\fIlanguage name\fR" 4
.IX Item "language=language name"
Specifies tha language of tha track up in tha Matroska languages form
.IP "\fBstereo_mode=\fR\fImode\fR" 4
.IX Item "stereo_mode=mode"
Stereo 3D vizzle layout of two views up in a single vizzle track
.RS 4
.IP "\fBmono\fR" 4
.IX Item "mono"
video aint stereo
.IP "\fBleft_right\fR" 4
.IX Item "left_right"
Both views is arranged side by side, Left-eye view is on tha left
.IP "\fBbottom_top\fR" 4
.IX Item "bottom_top"
Both views is arranged up in top-bottom orientation, Left-eye view be at bottom
.IP "\fBtop_bottom\fR" 4
.IX Item "top_bottom"
Both views is arranged up in top-bottom orientation, Left-eye view is on top
.IP "\fBcheckerboard_rl\fR" 4
.IX Item "checkerboard_rl"
Each view be arranged up in a cold-ass lil checkerboard interleaved pattern, Left-eye view bein first
.IP "\fBcheckerboard_lr\fR" 4
.IX Item "checkerboard_lr"
Each view be arranged up in a cold-ass lil checkerboard interleaved pattern, Right-eye view bein first
.IP "\fBrow_interleaved_rl\fR" 4
.IX Item "row_interleaved_rl"
Each view is constituted by a row based interleaving, Right-eye view is first row
.IP "\fBrow_interleaved_lr\fR" 4
.IX Item "row_interleaved_lr"
Each view is constituted by a row based interleaving, Left-eye view is first row
.IP "\fBcol_interleaved_rl\fR" 4
.IX Item "col_interleaved_rl"
Both views is arranged up in a cold-ass lil column based interleavin manner, Right-eye view is first column
.IP "\fBcol_interleaved_lr\fR" 4
.IX Item "col_interleaved_lr"
Both views is arranged up in a cold-ass lil column based interleavin manner, Left-eye view is first column
.IP "\fBanaglyph_cyan_red\fR" 4
.IX Item "anaglyph_cyan_red"
All frames is up in anaglyph format viewable all up in red-cyan filters
.IP "\fBright_left\fR" 4
.IX Item "right_left"
Both views is arranged side by side, Right-eye view is on tha left
.IP "\fBanaglyph_green_magenta\fR" 4
.IX Item "anaglyph_green_magenta"
All frames is up in anaglyph format viewable all up in green-magenta filters
.IP "\fBblock_lr\fR" 4
.IX Item "block_lr"
Both eyes laced up in one Block, Left-eye view is first
.IP "\fBblock_rl\fR" 4
.IX Item "block_rl"
Both eyes laced up in one Block, Right-eye view is first
.RE
.RS 4
.RE
.PP
For example a 3D WebM clip can be pimped rockin tha followin command line:
.PP
.Vb 1
\&        ffmpeg \-i sample_left_right_clip.mpg \-an \-c:v libvpx \-metadata stereo_mode=left_right \-y stereo_clip.webm
.Ve
.PP
This muxer supports tha followin options:
.IP "\fBreserve_index_space\fR" 4
.IX Item "reserve_index_space"
By default, dis muxer writes tha index fo' seekin (called cues up in Matroska
terms) all up in tha end of tha file, cuz it cannot know up in advizzle how tha fuck much space
to leave fo' tha index all up in tha beginnin of tha file yo. However fo' some use cases
\&\*(-- e.g.  streamin where seekin is possible but slow \*(-- it is useful ta put the
index all up in tha beginnin of tha file.
.Sp
If dis option is set ta a non-zero value, tha muxer will reserve a given amount
of space up in tha file header n' then try ta write tha cues there when tha muxing
finishes. If tha available space do not suffice, muxin will fail fo' realz. A safe size
for most use cases should be bout 50kB per minute of vizzle.
.Sp
Note dat cues is only freestyled if tha output is seekable n' dis option will
have no effect if it is not.
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 testin format.
.PP
This muxer computes n' prints tha \s-1MD5\s0 hash of all tha input audio
and vizzle frames. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
hash.
.PP
Da output of tha muxer consistz of a single line of tha form:
MD5=\fI\s-1MD5\s0\fR, where \fI\s-1MD5\s0\fR be a hexadecimal number representing
the computed \s-1MD5\s0 hash.
.PP
For example ta compute tha \s-1MD5\s0 hash of tha input converted ta raw
audio n' vizzle, n' store it up in tha file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 out.md5
.Ve
.PP
Yo ass can print tha \s-1MD5\s0 ta stdout wit tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 \-
.Ve
.PP
See also tha framemd5 muxer.
.SS "\s-1MOV/MP4/ISMV\s0"
.IX Subsection "MOV/MP4/ISMV"
Da mov/mp4/ismv muxer supports fragmentation. I aint talkin' bout chicken n' gravy biatch. Normally, a \s-1MOV/MP4\s0
file has all tha metadata bout all packets stored up in one location
(written all up in tha end of tha file, it can be moved ta tha start for
betta playback by addin \fIfaststart\fR ta tha \fImovflags\fR, or
usin tha \fBqt-faststart\fR tool) fo' realz. A fragmented
file consistz of a fuckin shitload of fragments, where packets n' metadata
about these packets is stored together n' shit. Freestylin a gangbangin' fragmented
file has tha advantage dat tha file is decodable even if the
writin is interrupted (while a aiiight \s-1MOV/MP4\s0 is undecodable if
it aint properly finished), n' it requires less memory when writing
very long filez (since freestylin aiiight \s-1MOV/MP4\s0 filez stores info about
every single packet up in memory until tha file is closed). Da downside
is dat it is less compatible wit other applications.
.PP
Fragmentation is enabled by settin one of tha AVOptions dat define
how ta cut tha file tha fuck into fragments:
.IP "\fB\-moov_size\fR \fIbytes\fR" 4
.IX Item "-moov_size bytes"
Reserves space fo' tha moov atom all up in tha beginnin of tha file instead of placin the
moov atom all up in tha end yo, but it ain't no stoppin cause I be still poppin'. If tha space reserved is insufficient, muxin will fail.
.IP "\fB\-movflags frag_keyframe\fR" 4
.IX Item "-movflags frag_keyframe"
Start a freshly smoked up fragment at each vizzle keyframe.
.IP "\fB\-frag_duration\fR \fIduration\fR" 4
.IX Item "-frag_duration duration"
Smoke fragments dat is \fIduration\fR microsecondz long.
.IP "\fB\-frag_size\fR \fIsize\fR" 4
.IX Item "-frag_size size"
Smoke fragments dat contain up ta \fIsize\fR bytez of payload data.
.IP "\fB\-movflags frag_custom\fR" 4
.IX Item "-movflags frag_custom"
Allow tha calla ta manually chizzle when ta cut fragments, by
callin \f(CW\*(C`av_write_frame(ctx, NULL)\*(C'\fR ta write a gangbangin' fragment with
the packets freestyled so far. Shiiit, dis aint no joke. (This is only useful wit other
applications integratin libavformat, not from \fBffmpeg\fR.)
.IP "\fB\-min_frag_duration\fR \fIduration\fR" 4
.IX Item "-min_frag_duration duration"
Don't create fragments dat is shorta than \fIduration\fR microsecondz long.
.PP
If mo' than one condizzle is specified, fragments is cut when
one of tha specified conditions is fulfilled. Y'all KNOW dat shit, muthafucka! Da exception ta dis is
\&\f(CW\*(C`\-min_frag_duration\*(C'\fR, which has ta be fulfilled fo' any of tha other
conditions ta apply.
.PP
Additionally, tha way tha output file is freestyled can be adjusted
all up in all dem other options:
.IP "\fB\-movflags empty_moov\fR" 4
.IX Item "-movflags empty_moov"
Write a initial moov atom directly all up in tha start of tha file, without
describin any samplez up in dat shit. Generally, a mdat/moov pair is written
at tha start of tha file, as a aiiight \s-1MOV/MP4\s0 file, containin only
a short portion of tha file. With dis option set, there is no initial
mdat atom, n' tha moov atom only raps bout tha tracks but has
a zero duration.
.Sp
Filez freestyled wit dis option set do not work up in QuickTime.
This option is implicitly set when freestylin ismv (Smooth Streaming) files.
.IP "\fB\-movflags separate_moof\fR" 4
.IX Item "-movflags separate_moof"
Write a separate moof (movie fragment) atom fo' each track. Normally,
packets fo' all tracks is freestyled up in a moof atom (which is slightly
more efficient) yo, but wit dis option set, tha muxer writes one moof/mdat
pair fo' each track, makin it easier ta separate tracks.
.Sp
This option is implicitly set when freestylin ismv (Smooth Streaming) files.
.IP "\fB\-movflags faststart\fR" 4
.IX Item "-movflags faststart"
Run a second pass movin tha index (moov atom) ta tha beginnin of tha file.
This operation can take a while, n' aint gonna work up in various thangs such
as fragmented output, thus it aint enabled by default.
.IP "\fB\-movflags rtphint\fR" 4
.IX Item "-movflags rtphint"
Add \s-1RTP\s0 hintin tracks ta tha output file.
.PP
Smooth Streamin content can be pushed up in real time ta a publishing
point on \s-1IIS\s0 wit dis muxer n' shit. Example:
.PP
.Vb 1
\&        ffmpeg \-re <<normal input/transcodin options>> \-movflags isml+frag_keyframe \-f ismv http://server/publishingpoint.isml/Streams(Encoder1)
.Ve
.SS "mp3"
.IX Subsection "mp3"
Da \s-1MP3\s0 muxer writes a raw \s-1MP3\s0 stream wit a ID3v2 header all up in tha beginnin and
optionally a ID3v1 tag all up in tha end yo, but it ain't no stoppin cause I be still poppin'. ID3v2.3 n' ID3v2.4 is supported, the
\&\f(CW\*(C`id3v2_version\*(C'\fR option controls which one is used. Y'all KNOW dat shit, muthafucka! Da legacy ID3v1 tag is
not freestyled by default yo, but may be enabled wit tha \f(CW\*(C`write_id3v1\*(C'\fR option.
.PP
For seekable output tha muxer also writes a Xin frame all up in tha beginning, which
gotz nuff tha number of frames up in tha file. Well shiiiit, it is useful fo' computin duration
of \s-1VBR\s0 files.
.PP
Da muxer supports freestylin ID3v2 attached pictures (\s-1APIC\s0 frames). Da pictures
are supplied ta tha muxer up in form of a vizzle stream wit a single packet. There
can be any number of dem streams, each will correspond ta a single \s-1APIC\s0 frame.
Da stream metadata tags \fItitle\fR n' \fIcomment\fR map ta \s-1APIC
\&\s0\fIdescription\fR n' \fIpicture type\fR respectively. Right back up in yo muthafuckin ass. See
<\fBhttp://id3.org/id3v2.4.0\-frames\fR> fo' allowed picture types.
.PP
Note dat tha \s-1APIC\s0 frames must be freestyled all up in tha beginning, so tha muxer will
buffer tha audio frames until it gets all tha pictures. Well shiiiit, it is therefore advised
to provide tha pictures quicker than a muthafucka ta avoid excessive buffering.
.PP
Examples:
.PP
Write a mp3 wit a ID3v2.3 header n' a ID3v1 footer:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-id3v2_version 3 \-write_id3v1 1 out.mp3
.Ve
.PP
To attach a picture ta a mp3 file select both tha audio n' tha picture stream
with \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 2
\&        ffmpeg \-i input.mp3 \-i cover.png \-c copy \-map 0 \-map 1
\&        \-metadata:s:v title="Album cover" \-metadata:s:v comment="Cover (Front)" out.mp3
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\s0 transhiznit stream muxer.
.PP
This muxer implements \s-1ISO 13818\-1\s0 n' part of \s-1ETSI EN 300 468.\s0
.PP
Da muxer options are:
.IP "\fB\-mpegts_original_network_id\fR \fInumber\fR" 4
.IX Item "-mpegts_original_network_id number"
Set tha original_network_id (default 0x0001). This is unique identifier
of a network up in \s-1DVB.\s0 Its main use is up in tha unique identification of a
service all up in tha path Original_Network_ID, Transport_Stream_ID.
.IP "\fB\-mpegts_transport_stream_id\fR \fInumber\fR" 4
.IX Item "-mpegts_transport_stream_id number"
Set tha transport_stream_id (default 0x0001). This identifies a
transponder up in \s-1DVB.\s0
.IP "\fB\-mpegts_service_id\fR \fInumber\fR" 4
.IX Item "-mpegts_service_id number"
Set tha service_id (default 0x0001) also known as program up in \s-1DVB.\s0
.IP "\fB\-mpegts_pmt_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_pmt_start_pid number"
Set tha straight-up original gangsta \s-1PID\s0 fo' \s-1PMT \s0(default 0x1000, max 0x1f00).
.IP "\fB\-mpegts_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_start_pid number"
Set tha straight-up original gangsta \s-1PID\s0 fo' data packets (default 0x0100, max 0x0f00).
.IP "\fB\-mpegts_m2ts_mode\fR \fInumber\fR" 4
.IX Item "-mpegts_m2ts_mode number"
Enable m2ts mode if set ta 1. Default value is \-1 which disablez m2ts mode.
.IP "\fB\-muxrate\fR \fInumber\fR" 4
.IX Item "-muxrate number"
Set muxrate.
.IP "\fB\-pes_payload_size\fR \fInumber\fR" 4
.IX Item "-pes_payload_size number"
Set minimum \s-1PES\s0 packet payload up in bytes.
.IP "\fB\-mpegts_flags\fR \fIflags\fR" 4
.IX Item "-mpegts_flags flags"
Set flags (see below).
.IP "\fB\-mpegts_copyts\fR \fInumber\fR" 4
.IX Item "-mpegts_copyts number"
Preserve original gangsta timestamps, if value is set ta 1. Default value is \-1, which
results up in shiftin timestamps so dat they start from 0.
.IP "\fB\-tables_version\fR \fInumber\fR" 4
.IX Item "-tables_version number"
Set \s-1PAT, PMT\s0 n' \s-1SDT\s0 version (default 0, valid joints is from 0 ta 31, inclusively).
This option allows uppimpin stream structure so dat standard thug may
detect tha chizzle. To do so, reopen output AVFormatContext (in case of \s-1API\s0
usage) or restart ffmpeg instance, cyclically changin tables_version value:
.Sp
.Vb 7
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
\&        ffmpeg \-i source3.ts \-codec copy \-f mpegts \-tables_version 31 udp://1.1.1.1:1111
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
.Ve
.PP
Option mpegts_flags may take a set of such flags:
.IP "\fBresend_headers\fR" 4
.IX Item "resend_headers"
Reemit \s-1PAT/PMT\s0 before freestylin tha next packet.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Use \s-1LATM\s0 packetization fo' \s-1AAC.\s0
.PP
Da recognized metadata settings up in mpegts muxer is \f(CW\*(C`service_provider\*(C'\fR
and \f(CW\*(C`service_name\*(C'\fR. If they is not set tha default for
\&\f(CW\*(C`service_provider\*(C'\fR is \*(L"FFmpeg\*(R" n' tha default for
\&\f(CW\*(C`service_name\*(C'\fR is \*(L"Service01\*(R".
.PP
.Vb 9
\&        ffmpeg \-i file.mpg \-c copy \e
\&             \-mpegts_original_network_id 0x1122 \e
\&             \-mpegts_transport_stream_id 0x3344 \e
\&             \-mpegts_service_id 0x5566 \e
\&             \-mpegts_pmt_start_pid 0x1500 \e
\&             \-mpegts_start_pid 0x150 \e
\&             \-metadata service_provider="Some provider" \e
\&             \-metadata service_name="Some Channel" \e
\&             \-y out.ts
.Ve
.SS "null"
.IX Subsection "null"
Null muxer.
.PP
This muxer do not generate any output file, it is mainly useful for
testin or benchmarkin purposes.
.PP
For example ta benchmark decodin wit \fBffmpeg\fR you can use the
command:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null out.null
.Ve
.PP
Note dat tha above command do not read or write tha \fIout.null\fR
file yo, but specifyin tha output file is required by tha \fBffmpeg\fR
syntax.
.PP
Alternatively you can write tha command as:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null \-
.Ve
.SS "ogg"
.IX Subsection "ogg"
Ogg container muxer.
.IP "\fB\-page_duration\fR \fIduration\fR" 4
.IX Item "-page_duration duration"
Preferred page duration, up in microseconds. Da muxer will attempt ta create
pages dat is approximately \fIduration\fR microsecondz long. This allows the
user ta compromise between seek granularitizzle n' container overhead. Y'all KNOW dat shit, muthafucka! Da default
is 1 second. Y'all KNOW dat shit, muthafucka! A value of 0 will fill all segments, makin pages as big-ass as
possible fo' realz. A value of 1 will effectively use 1 packet-per-page up in most
situations, givin a lil' small-ass seek granularitizzle all up in tha cost of additionizzle container
overhead.
.SS "segment, stream_segment, ssegment"
.IX Subsection "segment, stream_segment, ssegment"
Basic stream segmenter.
.PP
Da segmenta muxer outputs streams ta a fuckin shitload of separate filez of nearly
fixed duration. I aint talkin' bout chicken n' gravy biatch. Output filename pattern can be set up in a gangbangin' fashizzle similar to
image2.
.PP
\&\f(CW\*(C`stream_segment\*(C'\fR be a variant of tha muxer used ta write to
streamin output formats, i.e. which do not require global headers,
and is recommended fo' outputtin e.g. ta \s-1MPEG\s0 transhiznit stream segments.
\&\f(CW\*(C`ssegment\*(C'\fR be a gangbangin' finger-lickin' dirty-ass shorta alias fo' \f(CW\*(C`stream_segment\*(C'\fR.
.PP
Every segment starts wit a keyframe of tha selected reference stream,
which is set all up in tha \fBreference_stream\fR option.
.PP
Note dat if you want accurate splittin fo' a vizzle file, you need to
make tha input key frames correspond ta tha exact splittin times
expected by tha segmenter, or tha segment muxer will start tha new
segment wit tha key frame found next afta tha specified start
time.
.PP
Da segment muxer works dopest wit a single constant frame rate vizzle.
.PP
Optionally it can generate a list of tha pimped segments, by setting
the option \fIsegment_list\fR. Da list type is specified by the
\&\fIsegment_list_type\fR option.
.PP
Da segment muxer supports tha followin options:
.IP "\fBreference_stream\fR \fIspecifier\fR" 4
.IX Item "reference_stream specifier"
Set tha reference stream, as specified by tha strang \fIspecifier\fR.
If \fIspecifier\fR is set ta \f(CW\*(C`auto\*(C'\fR, tha reference is chizzlen
automatically. Otherwise it must be a stream specifier (see tha ``Stream
specifiers'' chapta up in tha ffmpeg manual) which specifies the
reference stream. Da default value is \f(CW\*(C`auto\*(C'\fR.
.IP "\fBsegment_format\fR \fIformat\fR" 4
.IX Item "segment_format format"
Override tha inner container format, by default it is guessed by tha filename
extension.
.IP "\fBsegment_list\fR \fIname\fR" 4
.IX Item "segment_list name"
Generate also a listfile named \fIname\fR. If not specified no
listfile is generated.
.IP "\fBsegment_list_flags\fR \fIflags\fR" 4
.IX Item "segment_list_flags flags"
Set flags affectin tha segment list generation.
.Sp
It currently supports tha followin flags:
.RS 4
.IP "\fBcache\fR" 4
.IX Item "cache"
Allow cachin (only affects M3U8 list files).
.IP "\fBlive\fR" 4
.IX Item "live"
Allow live-friendly file generation.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`samp\*(C'\fR.
.RE
.IP "\fBsegment_list_size\fR \fIsize\fR" 4
.IX Item "segment_list_size size"
Update tha list file so dat it gotz nuff at most tha last \fIsize\fR
segments, n' you can put dat on yo' toast. If 0 tha list file will contain all tha segments, n' you can put dat on yo' toast. Default
value is 0.
.IP "\fBsegment_list_type\fR \fItype\fR" 4
.IX Item "segment_list_type type"
Specify tha format fo' tha segment list file.
.Sp
Da followin joints is recognized:
.RS 4
.IP "\fBflat\fR" 4
.IX Item "flat"
Generate a gangbangin' flat list fo' tha pimped segments, one segment per line.
.IP "\fBcsv, ext\fR" 4
.IX Item "csv, ext"
Generate a list fo' tha pimped segments, one segment per line,
each line matchin tha format (comma-separated joints):
.Sp
.Vb 1
\&        <segment_filename>,<segment_start_time>,<segment_end_time>
.Ve
.Sp
\&\fIsegment_filename\fR is tha name of tha output file generated by the
muxer accordin ta tha provided pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. \s-1CSV\s0 escapin (accordin to
\&\s-1RFC4180\s0) be applied if required.
.Sp
\&\fIsegment_start_time\fR n' \fIsegment_end_time\fR specify
the segment start n' end time expressed up in seconds.
.Sp
A list file wit tha suffix \f(CW".csv"\fR or \f(CW".ext"\fR will
auto-select dis format.
.Sp
\&\fBext\fR is deprecated up in favor or \fBcsv\fR.
.IP "\fBffconcat\fR" 4
.IX Item "ffconcat"
Generate a ffconcat file fo' tha pimped segments, n' you can put dat on yo' toast. Da resultin file
can be read rockin tha FFmpeg concat demuxer.
.Sp
A list file wit tha suffix \f(CW".ffcat"\fR or \f(CW".ffconcat"\fR will
auto-select dis format.
.IP "\fBm3u8\fR" 4
.IX Item "m3u8"
Generate a extended M3U8 file, version 3, compliant with
<\fBhttp://tools.ietf.org/id/draft\-pantos\-http\-live\-streaming\fR>.
.Sp
A list file wit tha suffix \f(CW".m3u8"\fR will auto-select dis format.
.RE
.RS 4
.Sp
If not specified tha type is guessed from tha list file name suffix.
.RE
.IP "\fBsegment_time\fR \fItime\fR" 4
.IX Item "segment_time time"
Set segment duration ta \fItime\fR, tha value must be a thugged-out duration
specification. I aint talkin' bout chicken n' gravy biatch. Default value is \*(L"2\*(R". Right back up in yo muthafuckin ass. See also the
\&\fBsegment_times\fR option.
.Sp
Note dat splittin may not be accurate, unless you force the
reference stream key-frames all up in tha given time. Right back up in yo muthafuckin ass. See tha introductory
notice n' tha examplez below.
.IP "\fBsegment_time_delta\fR \fIdelta\fR" 4
.IX Item "segment_time_delta delta"
Specify tha accuracy time when selectin tha start time fo' a
segment, expressed as a thugged-out duration justification. I aint talkin' bout chicken n' gravy biatch. Default value is \*(L"0\*(R".
.Sp
When delta is specified a key-frame will start a freshly smoked up segment if its
\&\s-1PTS\s0 satisfies tha relation:
.Sp
.Vb 1
\&        PTS >= start_time \- time_delta
.Ve
.Sp
This option is useful when splittin vizzle content, which be always
split at \s-1GOP\s0 boundaries, up in case a key frame is found just before the
specified split time.
.Sp
In particular may be used up in combination wit tha \fIffmpeg\fR option
\&\fIforce_key_frames\fR. Da key frame times specified by
\&\fIforce_key_frames\fR may not be set accurately cuz of rounding
issues, wit tha consequence dat a key frame time may result set just
before tha specified time. For constant frame rate vizzlez a value of
1/2*\fIframe_rate\fR should address da most thugged-out shitty case mismatch between
the specified time n' tha time set by \fIforce_key_frames\fR.
.IP "\fBsegment_times\fR \fItimes\fR" 4
.IX Item "segment_times times"
Specify a list of split points, n' you can put dat on yo' toast. \fItimes\fR gotz nuff a list of comma
separated duration justifications, up in increasin order n' shit. Right back up in yo muthafuckin ass. See also
the \fBsegment_time\fR option.
.IP "\fBsegment_frames\fR \fIframes\fR" 4
.IX Item "segment_frames frames"
Specify a list of split vizzle frame numbers. \fIframes\fR gotz nuff a
list of comma separated integer numbers, up in increasin order.
.Sp
This option specifies ta start a freshly smoked up segment whenever a reference
stream key frame is found n' tha sequential number (startin from 0)
of tha frame is pimped outa or equal ta tha next value up in tha list.
.IP "\fBsegment_wrap\fR \fIlimit\fR" 4
.IX Item "segment_wrap limit"
Wrap round segment index once it reaches \fIlimit\fR.
.IP "\fBsegment_start_number\fR \fInumber\fR" 4
.IX Item "segment_start_number number"
Set tha sequence number of tha straight-up original gangsta segment. Defaults ta \f(CW0\fR.
.IP "\fBreset_timestamps\fR \fI1|0\fR" 4
.IX Item "reset_timestamps 1|0"
Reset timestamps all up in tha begin of each segment, so dat each segment
will start wit near-zero timestamps. Well shiiiit, it is meant ta ease tha playback
of tha generated segments, n' you can put dat on yo' toast. May not work wit some combinations of
muxers/codecs. Well shiiiit, it is set ta \f(CW0\fR by default.
.IP "\fBinitial_offset\fR \fIoffset\fR" 4
.IX Item "initial_offset offset"
Specify timestamp offset ta apply ta tha output packet timestamps. The
argument must be a time duration justification, n' defaults ta 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
To remux tha content of file \fIin.mkv\fR ta a list of segments
\&\fIout\-000.nut\fR, \fIout\-001.nut\fR, etc., n' write tha list of
generated segments ta \fIout.list\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.list out%03d.nut
.Ve
.IP "\(bu" 4
As tha example above yo, but segment tha input file accordin ta tha split
points specified by tha \fIsegment_times\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 out%03d.nut
.Ve
.IP "\(bu" 4
As tha example above yo, but use tha \fBffmpeg\fR \fBforce_key_frames\fR
option ta force key frames up in tha input all up in tha specified location, together
with tha segment option \fBsegment_time_delta\fR ta account for
possible roundings operated when settin key frame times.
.Sp
.Vb 2
\&        ffmpeg \-i in.mkv \-force_key_frames 1,2,3,5,8,13,21 \-codec:v mpeg4 \-codec:a pcm_s16le \-map 0 \e
\&        \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 \-segment_time_delta 0.05 out%03d.nut
.Ve
.Sp
In order ta force key frames on tha input file, transcodin is
required.
.IP "\(bu" 4
Segment tha input file by splittin tha input file accordin ta the
frame numbers sequence specified wit tha \fBsegment_frames\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_frames 100,200,300,500,800 out%03d.nut
.Ve
.IP "\(bu" 4
To convert tha \fIin.mkv\fR ta \s-1TS\s0 segments rockin tha \f(CW\*(C`libx264\*(C'\fR
and \f(CW\*(C`libfaac\*(C'\fR encoders:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-map 0 \-codec:v libx264 \-codec:a libfaac \-f ssegment \-segment_list out.list out%03d.ts
.Ve
.IP "\(bu" 4
Segment tha input file, n' create a M3U8 live playlist (can be used
as live \s-1HLS\s0 source):
.Sp
.Vb 2
\&        ffmpeg \-re \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list playlist.m3u8 \e
\&        \-segment_list_flags +live \-segment_time 10 out%03d.mkv
.Ve
.SS "tee"
.IX Subsection "tee"
Da tee muxer can be used ta write tha same data ta nuff muthafuckin filez or any
other kind of muxer n' shit. Well shiiiit, it can be used, fo' example, ta both stream a vizzle to
the network n' save it ta disk all up in tha same time.
.PP
It be different from specifyin nuff muthafuckin outputs ta tha \fBffmpeg\fR
command-line tool cuz tha audio n' vizzle data is ghon be encoded only once
with tha tee muxer; encodin can be a straight-up high-rollin' process. Well shiiiit, it is not
useful when rockin tha libavformat \s-1API\s0 directly cuz it is then possible
to feed tha same packets ta nuff muthafuckin muxers directly.
.PP
Da slave outputs is specified up in tha file name given ta tha muxer,
separated by '|'. If any of tha slave name gotz nuff tha '|' separator,
leadin or trailin spaces or any special character, it must be
escaped (see tha ``Quotin n' escaping'' section up in tha ffmpeg-utils
manual).
.PP
Muxer options can be specified fo' each slave by prependin dem as a list of
\&\fIkey\fR=\fIvalue\fR pairs separated by ':', between square brackets, n' you can put dat on yo' toast. If
the options joints contain a special characta or tha ':' separator, they
must be escaped; note dat dis be a second level escaping.
.PP
Da followin special options is also recognized:
.IP "\fBf\fR" 4
.IX Item "f"
Specify tha format name. Useful if it cannot be guessed from the
output name suffix.
.IP "\fBbsfs[/\fR\fIspec\fR\fB]\fR" 4
.IX Item "bsfs[/spec]"
Specify a list of bitstream filtas ta apply ta tha specified
output. Well shiiiit, it is possible ta specify ta which streams a given bitstream
filta applies, by appendin a stream specifier ta tha option
separated by \f(CW\*(C`/\*(C'\fR. If tha stream specifier aint specified, the
bistream filtas is ghon be applied ta all streams up in tha output.
.Sp
Several bitstream filtas can be specified, separated by \*(L",\*(R".
.IP "\fBselect\fR" 4
.IX Item "select"
Select tha streams dat should be mapped ta tha slave output,
specified by a stream specifier n' shit. If not specified, dis defaults to
all tha input streams.
.PP
Some examplez follow.
.IP "\(bu" 4
Encode suttin' n' both archive it up in a WebM file n' stream it
as MPEG-TS over \s-1UDP \s0(the streams need ta be explicitly mapped):
.Sp
.Vb 2
\&        ffmpeg \-i ... \-c:v libx264 \-c:a mp2 \-f tee \-map 0:v \-map 0:a
\&          "archive\-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"
.Ve
.IP "\(bu" 4
Use \fBffmpeg\fR ta encode tha input, n' bust tha output
to three different destinations. Da \f(CW\*(C`dump_extra\*(C'\fR bitstream
filta is used ta add extradata shiznit ta all tha output vizzle
keyframes packets, as axed by tha MPEG-TS format. Da select
option be applied ta \fIout.aac\fR up in order ta make it contain only
audio packets.
.Sp
.Vb 2
\&        ffmpeg \-i ... \-map 0 \-flags +global_header \-c:v libx264 \-c:a aac \-strict experimental
\&               \-f tee "[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac"
.Ve
.PP
Note: some codecs may need different options dependin on tha output format;
the auto-detection of dis can not work wit tha tee muxer n' shit. Da main example
is tha \fBglobal_header\fR flag.
.SH "METADATA"
.IX Header "METADATA"
FFmpeg be able ta dump metadata from media filez tha fuck into a simple UTF\-8\-encoded
INI-like text file n' then load it back rockin tha metadata muxer/demuxer.
.PP
Da file format be as bigs up:
.IP "1." 4
A file consistz of a header n' a fuckin shitload of metadata tags divided tha fuck into sections,
each on its own line.
.IP "2." 4
Da header be a ';FFMETADATA' string, followed by a version number (now 1).
.IP "3." 4
Metadata tags iz of tha form 'key=value'
.IP "4." 4
Immediately afta header bigs up global metadata
.IP "5." 4
Afta global metadata there may be sections wit per\-stream/per\-chapter
metadata.
.IP "6." 4
A section starts wit tha section name up in uppercase (i.e. \s-1STREAM\s0 or \s-1CHAPTER\s0) in
brackets ('[', ']') n' endz wit next section or end of file.
.IP "7." 4
At tha beginnin of a cold-ass lil chapta section there may be a optionizzle timebase ta be
used fo' start/end joints, n' you can put dat on yo' toast. Well shiiiit, it must be up in form 'TIMEBASE=num/den', where num and
den is integers. If tha timebase is missin then start/end times is assumed to
be up in milliseconds.
Next a cold-ass lil chapta section must contain chapta start n' end times up in form
\&'START=num', 'END=num', where num be a positizzle integer.
.IP "8." 4
Empty lines n' lines startin wit ';' or '#' is ignored.
.IP "9." 4
Metadata keys or joints containin special charactas ('=', ';', '#', '\e' n' a
newline) must be escaped wit a funky-ass backslash '\e'.
.IP "10." 4
Note dat whitespace up in metadata (e.g. foo = bar) is considered ta be a part of
the tag (in tha example above key is 'foo ', value is ' bar').
.PP
A ffmetadata file might be lookin like this:
.PP
.Vb 4
\&        ;FFMETADATA1
\&        title=bike\e\eshed
\&        ;this be a cold-ass lil comment
\&        artist=FFmpeg troll crew
\&        
\&        [CHAPTER]
\&        TIMEBASE=1/1000
\&        START=0
\&        #chapta endz at 0:01:00
\&        END=60000
\&        title=chapta \e#1
\&        [STREAM]
\&        title=multi\e
\&        line
.Ve
.PP
By rockin tha ffmetadata muxer n' demuxer it is possible ta extract
metadata from a input file ta a ffmetadata file, n' then transcode
the file tha fuck into a output file wit tha edited ffmetadata file.
.PP
Extractin a ffmetadata file wit \fIffmpeg\fR goes as bigs up:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f ffmetadata FFMETADATAFILE
.Ve
.PP
Reinsertin edited metadata shiznit from tha \s-1FFMETADATAFILE\s0 file can
be done as:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-i FFMETADATAFILE \-map_metadata 1 \-codec copy OUTPUT
.Ve
.SH "PROTOCOLS"
.IX Header "PROTOCOLS"
Protocols is configured elements up in FFmpeg dat enable access to
resources dat require specific protocols.
.PP
When you configure yo' FFmpeg build, all tha supported protocols are
enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-protocols\*(R".
.PP
Yo ass can disable all tha protocols rockin tha configure option
\&\*(L"\-\-disable\-protocols\*(R", n' selectively enable a protocol rockin the
option "\-\-enable\-protocol=\fI\s-1PROTOCOL\s0\fR\*(L", or you can disable a
particular protocol rockin tha option
\&\*(R"\-\-disable\-protocol=\fI\s-1PROTOCOL\s0\fR".
.PP
Da option \*(L"\-protocols\*(R" of tha ff* tools will display tha list of
supported protocols.
.PP
A description of tha currently available protocols bigs up.
.SS "bluray"
.IX Subsection "bluray"
Read BluRay playlist.
.PP
Da accepted options are:
.IP "\fBangle\fR" 4
.IX Item "angle"
BluRay angle
.IP "\fBchapter\fR" 4
.IX Item "chapter"
Start chapta (1...N)
.IP "\fBplaylist\fR" 4
.IX Item "playlist"
Playlist ta read (\s-1BDMV/PLAYLIST/\s0?????.mpls)
.PP
Examples:
.PP
Read longest playlist from BluRay mounted ta /mnt/bluray:
.PP
.Vb 1
\&        bluray:/mnt/bluray
.Ve
.PP
Read angle 2 of playlist 4 from BluRay mounted ta /mnt/bluray, start from chapta 2:
.PP
.Vb 1
\&        \-playlist 4 \-angle 2 \-chapta 2 bluray:/mnt/bluray
.Ve
.SS "cache"
.IX Subsection "cache"
Cachin wrapper fo' input stream.
.PP
Cache tha input stream ta temporary file. Well shiiiit, it brangs seekin capabilitizzle ta live streams.
.PP
.Vb 1
\&        cache:<URL>
.Ve
.SS "concat"
.IX Subsection "concat"
Physical concatenation protocol.
.PP
Allow ta read n' seek from nuff resource up in sequence as if they were
a unique resource.
.PP
A \s-1URL\s0 accepted by dis protocol has tha syntax:
.PP
.Vb 1
\&        concat:<URL1>|<URL2>|...|<URLN>
.Ve
.PP
where \fI\s-1URL1\s0\fR, \fI\s-1URL2\s0\fR, ..., \fI\s-1URLN\s0\fR is tha urlz of the
resource ta be concatenated, each one possibly specifyin a gangbangin' finger-lickin' distinct
protocol.
.PP
For example ta read a sequence of filez \fIsplit1.mpeg\fR,
\&\fIsplit2.mpeg\fR, \fIsplit3.mpeg\fR wit \fBffplay\fR use the
command:
.PP
.Vb 1
\&        ffplay concat:split1.mpeg\e|split2.mpeg\e|split3.mpeg
.Ve
.PP
Note dat you may need ta escape tha characta \*(L"|\*(R" which is special for
many shells.
.SS "crypto"
.IX Subsection "crypto"
AES-encrypted stream readin protocol.
.PP
Da accepted options are:
.IP "\fBkey\fR" 4
.IX Item "key"
Set tha \s-1AES\s0 decryption key binary block from given hexadecimal representation.
.IP "\fBiv\fR" 4
.IX Item "iv"
Set tha \s-1AES\s0 decryption initialization vector binary block from given hexadecimal representation.
.PP
Accepted \s-1URL\s0 formats:
.PP
.Vb 2
\&        crypto:<URL>
\&        crypto+<URL>
.Ve
.SS "data"
.IX Subsection "data"
Data in-line up in tha \s-1URI.\s0 See <\fBhttp://en.wikipedia.org/wiki/Data_URI_scheme\fR>.
.PP
For example, ta convert a \s-1GIF\s0 file given inline wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i "data:image/gif;base64,R0lGODdhCAAIAMIEAAAAAAAA//8AAP//AP///////////////ywAAAAACAAIAAADF0gEDLojDgdGiJdJqUX02iB4E8Q9jUMkADs=" smiley.png
.Ve
.SS "file"
.IX Subsection "file"
File access protocol.
.PP
Allow ta read from or read ta a gangbangin' file.
.PP
For example ta read from a gangbangin' file \fIinput.mpeg\fR wit \fBffmpeg\fR
use tha command:
.PP
.Vb 1
\&        ffmpeg \-i file:input.mpeg output.mpeg
.Ve
.PP
Da ff* tools default ta tha file protocol, dat be a resource
specified wit tha name \*(L"\s-1FILE\s0.mpeg\*(R" is interpreted as tha \s-1URL
\&\s0\*(L"file:FILE.mpeg\*(R".
.PP
This protocol accepts tha followin options:
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate existin filez on write, if set ta 1 fo' realz. A value of 0 prevents
truncating. Default value is 1.
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Set I/O operation maximum block size, up in bytes. Default value is
\&\f(CW\*(C`INT_MAX\*(C'\fR, which thangs up in dis biatch up in not limitin tha axed block size.
Settin dis value reasonably low improves user termination request erection
time, which is valuable fo' filez on slow medium.
.SS "ftp"
.IX Subsection "ftp"
\&\s-1FTP \s0(File Transfer Protocol).
.PP
Allow ta read from or write ta remote resources rockin \s-1FTP\s0 protocol.
.PP
Peepin syntax is required.
.PP
.Vb 1
\&        ftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg
.Ve
.PP
This protocol accepts tha followin options.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout is
not specified.
.IP "\fBftp-anonymous-password\fR" 4
.IX Item "ftp-anonymous-password"
Password used when login as anonymous user n' shit. Typically a e\-mail address
should be used.
.IP "\fBftp-write-seekable\fR" 4
.IX Item "ftp-write-seekable"
Control seekabilitizzle of connection durin encoding. If set ta 1 the
resource is supposed ta be seekable, if set ta 0 it be assumed not
to be seekable. Default value is 0.
.PP
\&\s-1NOTE:\s0 Protocol can be used as output yo, but it is recommended ta not do
it, unless special care is taken (tests, customized server configuration
etc.). Different \s-1FTP\s0 servers behave up in different way durin seek
operation. I aint talkin' bout chicken n' gravy biatch. ff* tools may produce incomplete content cuz of server limitations.
.SS "gopher"
.IX Subsection "gopher"
Gopher protocol.
.SS "hls"
.IX Subsection "hls"
Read Applez \s-1HTTP\s0 Live Streamin compliant segmented stream as
a uniform one. Da M3U8 playlists describin tha segments can be
remote \s-1HTTP\s0 resources or local files, accessed rockin tha standard
file protocol.
Da nested protocol is declared by specifying
"+\fIproto\fR" afta tha hls \s-1URI\s0 scheme name, where \fIproto\fR
is either \*(L"file\*(R" or \*(L"http\*(R".
.PP
.Vb 2
\&        hls+http://host/path/to/remote/resource.m3u8
\&        hls+file://path/to/local/resource.m3u8
.Ve
.PP
Usin dis protocol is discouraged \- tha hls demuxer should work
just as well (if not, please report tha issues) n' is mo' complete.
To use tha hls demuxer instead, simply use tha direct URLs ta the
m3u8 files.
.SS "http"
.IX Subsection "http"
\&\s-1HTTP \s0(Hyper Text Transfer Protocol).
.PP
This protocol accepts tha followin options.
.IP "\fBseekable\fR" 4
.IX Item "seekable"
Control seekabilitizzle of connection. I aint talkin' bout chicken n' gravy biatch. If set ta 1 tha resource is
supposed ta be seekable, if set ta 0 it be assumed not ta be seekable,
if set ta \-1 it will try ta autodetect if it is seekable. Default
value is \-1.
.IP "\fBchunked_post\fR" 4
.IX Item "chunked_post"
If set ta 1 use chunked transfer-encodin fo' posts, default is 1.
.IP "\fBheaders\fR" 4
.IX Item "headers"
Set custom \s-1HTTP\s0 headers, can override built up in default headers. The
value must be a strang encodin tha headers.
.IP "\fBcontent_type\fR" 4
.IX Item "content_type"
Force a cold-ass lil content type.
.IP "\fBuser-agent\fR" 4
.IX Item "user-agent"
Override User-Agent header n' shit. If not specified tha protocol will use a
strin describin tha libavformat build.
.IP "\fBmultiple_requests\fR" 4
.IX Item "multiple_requests"
Use persistent connections if set ta 1. By default it is 0.
.IP "\fBpost_data\fR" 4
.IX Item "post_data"
Set custom \s-1HTTP\s0 post data.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout is
not specified.
.IP "\fBmime_type\fR" 4
.IX Item "mime_type"
Set \s-1MIME\s0 type.
.IP "\fBicy\fR" 4
.IX Item "icy"
If set ta 1 request \s-1ICY \s0(SHOUTcast) metadata from tha server n' shit. If tha server
supports this, tha metadata has ta be retrieved by tha application by reading
the \fBicy_metadata_headers\fR n' \fBicy_metadata_packet\fR options.
Da default is 0.
.IP "\fBicy_metadata_headers\fR" 4
.IX Item "icy_metadata_headers"
If tha server supports \s-1ICY\s0 metadata, dis gotz nuff tha \s-1ICY\s0 specific \s-1HTTP\s0 reply
headers, separated wit newline characters.
.IP "\fBicy_metadata_packet\fR" 4
.IX Item "icy_metadata_packet"
If tha server supports \s-1ICY\s0 metadata, n' \fBicy\fR was set ta 1, this
gotz nuff tha last non-empty metadata packet busted by tha server.
.IP "\fBcookies\fR" 4
.IX Item "cookies"
Set tha dem scooby snacks ta be busted up in future requests, n' you can put dat on yo' toast. Da format of each cookie is the
same as tha value of a Set-Cookie \s-1HTTP\s0 response field. Y'all KNOW dat shit, muthafucka! Multiple dem scooby snacks can be
delimited by a newline character.
.PP
\fI\s-1HTTP\s0 Cookies\fR
.IX Subsection "HTTP Cookies"
.PP
Some \s-1HTTP\s0 requests is ghon be denied unless cookie joints is passed up in wit the
request. Da \fBcookies\fR option allows these dem scooby snacks ta be specified. Y'all KNOW dat shit, muthafucka! At
the straight-up least, each cookie must specify a value along wit a path n' domain.
\&\s-1HTTP\s0 requests dat match both tha domain n' path will automatically include the
cookie value up in tha \s-1HTTP\s0 Cookie header field. Y'all KNOW dat shit, muthafucka! Multiple dem scooby snacks can be delimited
by a newline.
.PP
Da required syntax ta play a stream specifyin a cold-ass lil cookie is:
.PP
.Vb 1
\&        ffplay \-cookies "nlqptid=nltid=tsn; path=/; domain=somedomain.com;" http://somedomain.com/somestream.m3u8
.Ve
.SS "mmst"
.IX Subsection "mmst"
\&\s-1MMS \s0(Microsizzlez Media Server) protocol over \s-1TCP.\s0
.SS "mmsh"
.IX Subsection "mmsh"
\&\s-1MMS \s0(Microsizzlez Media Server) protocol over \s-1HTTP.\s0
.PP
Da required syntax is:
.PP
.Vb 1
\&        mmsh://<server>[:<port>][/<app>][/<playpath>]
.Ve
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 output protocol.
.PP
Computes tha \s-1MD5\s0 hash of tha data ta be written, n' on close writes
this ta tha designated output or stdout if none is specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can
be used ta test muxers without freestylin a actual file.
.PP
Some examplez follow.
.PP
.Vb 2
\&        # Write tha MD5 hash of tha encoded AVI file ta tha file output.avi.md5.
\&        ffmpeg \-i input.flv \-f avi \-y md5:output.avi.md5
\&        
\&        # Write tha MD5 hash of tha encoded AVI file ta stdout.
\&        ffmpeg \-i input.flv \-f avi \-y md5:
.Ve
.PP
Note dat some formats (typically \s-1MOV\s0) require tha output protocol to
be seekable, so they will fail wit tha \s-1MD5\s0 output protocol.
.SS "pipe"
.IX Subsection "pipe"
\&\s-1UNIX\s0 pipe access protocol.
.PP
Allow ta read n' write from \s-1UNIX\s0 pipes.
.PP
Da accepted syntax is:
.PP
.Vb 1
\&        pipe:[<number>]
.Ve
.PP
\&\fInumber\fR is tha number correspondin ta tha file descriptor of the
pipe (e.g. 0 fo' stdin, 1 fo' stdout, 2 fo' stderr).  If \fInumber\fR
is not specified, by default tha stdout file descriptor is ghon be used
for writing, stdin fo' reading.
.PP
For example ta read from stdin wit \fBffmpeg\fR:
.PP
.Vb 3
\&        pussaaaaay test.wav | ffmpeg \-i pipe:0
\&        # ...this is tha same ol' dirty as...
\&        pussaaaaay test.wav | ffmpeg \-i pipe:
.Ve
.PP
For freestylin ta stdout wit \fBffmpeg\fR:
.PP
.Vb 3
\&        ffmpeg \-i test.wav \-f avi pipe:1 | pussaaaaay > test.avi
\&        # ...this is tha same ol' dirty as...
\&        ffmpeg \-i test.wav \-f avi pipe: | pussaaaaay > test.avi
.Ve
.PP
This protocol accepts tha followin options:
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Set I/O operation maximum block size, up in bytes. Default value is
\&\f(CW\*(C`INT_MAX\*(C'\fR, which thangs up in dis biatch up in not limitin tha axed block size.
Settin dis value reasonably low improves user termination request erection
time, which is valuable if data transmission is slow.
.PP
Note dat some formats (typically \s-1MOV\s0), require tha output protocol to
be seekable, so they will fail wit tha pipe output protocol.
.SS "rtmp"
.IX Subsection "rtmp"
Real-Time Messagin Protocol.
.PP
Da Real-Time Messagin Protocol (\s-1RTMP\s0) is used fo' streamin multimedia
content across a \s-1TCP/IP\s0 network.
.PP
Da required syntax is:
.PP
.Vb 1
\&        rtmp://[<username>:<password>@]<server>[:<port>][/<app>][/<instance>][/<playpath>]
.Ve
.PP
Da accepted parametas are:
.IP "\fBusername\fR" 4
.IX Item "username"
An optionizzle username (mostly fo' publishing).
.IP "\fBpassword\fR" 4
.IX Item "password"
An optionizzle password (mostly fo' publishing).
.IP "\fBserver\fR" 4
.IX Item "server"
Da address of tha \s-1RTMP\s0 server.
.IP "\fBport\fR" 4
.IX Item "port"
Da number of tha \s-1TCP\s0 port ta use (by default is 1935).
.IP "\fBapp\fR" 4
.IX Item "app"
It be tha name of tha application ta access. Well shiiiit, it probably correspondz to
the path where tha application is installed on tha \s-1RTMP\s0 server
(e.g. \fI/ondemand/\fR, \fI/flash/live/\fR, etc.). Yo ass can override
the value parsed from tha \s-1URI\s0 all up in tha \f(CW\*(C`rtmp_app\*(C'\fR option, like a muthafucka.
.IP "\fBplaypath\fR" 4
.IX Item "playpath"
It be tha path or name of tha resource ta fuck wit reference ta the
application specified up in \fIapp\fR, may be prefixed by \*(L"mp4:\*(R". You
can override tha value parsed from tha \s-1URI\s0 all up in tha \f(CW\*(C`rtmp_playpath\*(C'\fR
option, like a muthafucka.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Act as a server, listenin fo' a incomin connection.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Maximum time ta wait fo' tha incomin connection. I aint talkin' bout chicken n' gravy biatch. Implies listen.
.PP
Additionally, tha followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBrtmp_app\fR" 4
.IX Item "rtmp_app"
Name of application ta connect on tha \s-1RTMP\s0 server n' shit. This option
overrides tha parameta specified up in tha \s-1URI.\s0
.IP "\fBrtmp_buffer\fR" 4
.IX Item "rtmp_buffer"
Set tha client buffer time up in milliseconds. Da default is 3000.
.IP "\fBrtmp_conn\fR" 4
.IX Item "rtmp_conn"
Extra arbitrary \s-1AMF\s0 connection parameters, parsed from a string,
e.g. like \f(CW\*(C`B:1 S:authMe O:1 NN:code:1.23 NS:flag:ok O:0\*(C'\fR.
Each value is prefixed by a single characta denotin tha type,
B fo' Boolean, N fo' number, S fo' string, O fo' object, or Z fo' null,
followed by a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch. For Booleans tha data must be either 0 or 1 for
\&\s-1FALSE\s0 or \s-1TRUE,\s0 respectively.  Likewise fo' Objects tha data must be 0 or
1 ta end or begin a object, respectively. Data shit up in subobjects may
be named, by prefixin tha type wit 'N' n' specifyin tha name before
the value (i.e. \f(CW\*(C`NB:myFlag:1\*(C'\fR). This option may be used multiple
times ta construct arbitrary \s-1AMF\s0 sequences.
.IP "\fBrtmp_flashver\fR" 4
.IX Item "rtmp_flashver"
Version of tha Flash plugin used ta run tha \s-1SWF\s0 playa n' shit. Da default
is \s-1LNX 9,0,124,2. \s0(When publishing, tha default is \s-1FMLE/3.0 \s0(compatible;
<libavformat version>).)
.IP "\fBrtmp_flush_interval\fR" 4
.IX Item "rtmp_flush_interval"
Number of packets flushed up in tha same request (\s-1RTMPT\s0 only). Da default
is 10.
.IP "\fBrtmp_live\fR" 4
.IX Item "rtmp_live"
Specify dat tha media be a live stream. No resumin or seekin in
live streams is possible. Da default value is \f(CW\*(C`any\*(C'\fR, which means the
subscriber first tries ta play tha live stream specified up in the
playpath. If a live stream of dat name aint found, it skits the
recorded stream. Da other possible joints is \f(CW\*(C`live\*(C'\fR and
\&\f(CW\*(C`recorded\*(C'\fR.
.IP "\fBrtmp_pageurl\fR" 4
.IX Item "rtmp_pageurl"
\&\s-1URL\s0 of tha wizzy page up in which tha media was embedded. Y'all KNOW dat shit, muthafucka! By default no
value is ghon be sent.
.IP "\fBrtmp_playpath\fR" 4
.IX Item "rtmp_playpath"
Stream identifier ta play or ta publish. This option overrides the
parameta specified up in tha \s-1URI.\s0
.IP "\fBrtmp_subscribe\fR" 4
.IX Item "rtmp_subscribe"
Name of live stream ta subscribe to. By default no value is ghon be sent.
It be only busted if tha option is specified or if rtmp_live
is set ta live.
.IP "\fBrtmp_swfhash\fR" 4
.IX Item "rtmp_swfhash"
\&\s-1SHA256\s0 hash of tha decompressed \s-1SWF\s0 file (32 bytes).
.IP "\fBrtmp_swfsize\fR" 4
.IX Item "rtmp_swfsize"
Size of tha decompressed \s-1SWF\s0 file, required fo' SWFVerification.
.IP "\fBrtmp_swfurl\fR" 4
.IX Item "rtmp_swfurl"
\&\s-1URL\s0 of tha \s-1SWF\s0 playa fo' tha media. By default no value is ghon be sent.
.IP "\fBrtmp_swfverify\fR" 4
.IX Item "rtmp_swfverify"
\&\s-1URL\s0 ta playa swf file, compute hash/size automatically.
.IP "\fBrtmp_tcurl\fR" 4
.IX Item "rtmp_tcurl"
\&\s-1URL\s0 of tha target stream. Defaults ta proto://host[:port]/app.
.PP
For example ta read wit \fBffplay\fR a multimedia resource named
\&\*(L"sample\*(R" from tha application \*(L"vod\*(R" from a \s-1RTMP\s0 server \*(L"myserver\*(R":
.PP
.Vb 1
\&        ffplay rtmp://myserver/vod/sample
.Ve
.PP
To publish ta a password protected server, passin tha playpath and
app names separately:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f flv \-rtmp_playpath some/long/path \-rtmp_app long/app/name rtmp://username:password@myserver/
.Ve
.SS "rtmpe"
.IX Subsection "rtmpe"
Encrypted Real-Time Messagin Protocol.
.PP
Da Encrypted Real-Time Messagin Protocol (\s-1RTMPE\s0) is used for
streamin multimedia content within standard cryptographic primitives,
consistin of Diffie-Hellman key exchange n' \s-1HMACSHA256,\s0 generating
a pair of \s-1RC4\s0 keys.
.SS "rtmps"
.IX Subsection "rtmps"
Real-Time Messagin Protocol over a secure \s-1SSL\s0 connection.
.PP
Da Real-Time Messagin Protocol (\s-1RTMPS\s0) is used fo' streaming
multimedia content across a encrypted connection.
.SS "rtmpt"
.IX Subsection "rtmpt"
Real-Time Messagin Protocol tunneled all up in \s-1HTTP.\s0
.PP
Da Real-Time Messagin Protocol tunneled all up in \s-1HTTP \s0(\s-1RTMPT\s0) is used
for streamin multimedia content within \s-1HTTP\s0 requests ta traverse
firewalls.
.SS "rtmpte"
.IX Subsection "rtmpte"
Encrypted Real-Time Messagin Protocol tunneled all up in \s-1HTTP.\s0
.PP
Da Encrypted Real-Time Messagin Protocol tunneled all up in \s-1HTTP \s0(\s-1RTMPTE\s0)
is used fo' streamin multimedia content within \s-1HTTP\s0 requests ta traverse
firewalls.
.SS "rtmpts"
.IX Subsection "rtmpts"
Real-Time Messagin Protocol tunneled all up in \s-1HTTPS.\s0
.PP
Da Real-Time Messagin Protocol tunneled all up in \s-1HTTPS \s0(\s-1RTMPTS\s0) is used
for streamin multimedia content within \s-1HTTPS\s0 requests ta traverse
firewalls.
.SS "libssh"
.IX Subsection "libssh"
Secure File Transfer Protocol via libssh
.PP
Allow ta read from or write ta remote resources rockin \s-1SFTP\s0 protocol.
.PP
Peepin syntax is required.
.PP
.Vb 1
\&        sftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg
.Ve
.PP
This protocol accepts tha followin options.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout
is not specified.
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate existin filez on write, if set ta 1 fo' realz. A value of 0 prevents
truncating. Default value is 1.
.PP
Example: Play a gangbangin' file stored on remote server.
.PP
.Vb 1
\&        ffplay sftp://user:password@server_address:22/home/user/resource.mpeg
.Ve
.SS "librtmp rtmp, rtmpe, rtmps, rtmpt, rtmpte"
.IX Subsection "librtmp rtmp, rtmpe, rtmps, rtmpt, rtmpte"
Real-Time Messagin Protocol n' its variants supported through
librtmp.
.PP
Requires tha presence of tha librtmp headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\*(L"\-\-enable\-librtmp\*(R". If enabled dis will replace tha natizzle \s-1RTMP\s0
protocol.
.PP
This protocol serves up most client functions n' all dem server
functions needed ta support \s-1RTMP, RTMP\s0 tunneled up in \s-1HTTP \s0(\s-1RTMPT\s0),
encrypted \s-1RTMP \s0(\s-1RTMPE\s0), \s-1RTMP\s0 over \s-1SSL/TLS \s0(\s-1RTMPS\s0) n' tunneled
variantz of these encrypted types (\s-1RTMPTE, RTMPTS\s0).
.PP
Da required syntax is:
.PP
.Vb 1
\&        <rtmp_proto>://<server>[:<port>][/<app>][/<playpath>] <options>
.Ve
.PP
where \fIrtmp_proto\fR is one of tha strings \*(L"rtmp\*(R", \*(L"rtmpt\*(R", \*(L"rtmpe\*(R",
\&\*(L"rtmps\*(R", \*(L"rtmpte\*(R", \*(L"rtmpts\*(R" correspondin ta each \s-1RTMP\s0 variant, and
\&\fIserver\fR, \fIport\fR, \fIapp\fR n' \fIplaypath\fR have tha same
meanin as specified fo' tha \s-1RTMP\s0 natizzle protocol.
\&\fIoptions\fR gotz nuff a list of space-separated optionz of tha form
\&\fIkey\fR=\fIval\fR.
.PP
See tha librtmp manual page (man 3 librtmp) fo' mo' shiznit.
.PP
For example, ta stream a gangbangin' file up in real-time ta a \s-1RTMP\s0 server using
\&\fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-re \-i myfile \-f flv rtmp://myserver/live/mystream
.Ve
.PP
To play tha same stream rockin \fBffplay\fR:
.PP
.Vb 1
\&        ffplay "rtmp://myserver/live/mystream live=1"
.Ve
.SS "rtp"
.IX Subsection "rtp"
Real-time Transhiznit Protocol.
.PP
Da required syntax fo' a \s-1RTP URL\s0 is:
rtp://\fIhostname\fR[:\fIport\fR][?\fIoption\fR=\fIval\fR...]
.PP
\&\fIport\fR specifies tha \s-1RTP\s0 port ta use.
.PP
Da followin \s-1URL\s0 options is supported:
.IP "\fBttl=\fR\fIn\fR" 4
.IX Item "ttl=n"
Set tha \s-1TTL \s0(Time-To-Live) value (for multicast only).
.IP "\fBrtcpport=\fR\fIn\fR" 4
.IX Item "rtcpport=n"
Set tha remote \s-1RTCP\s0 port ta \fIn\fR.
.IP "\fBlocalrtpport=\fR\fIn\fR" 4
.IX Item "localrtpport=n"
Set tha local \s-1RTP\s0 port ta \fIn\fR.
.IP "\fBlocalrtcpport=\fR\fIn\fR\fB'\fR" 4
.IX Item "localrtcpport=n'"
Set tha local \s-1RTCP\s0 port ta \fIn\fR.
.IP "\fBpkt_size=\fR\fIn\fR" 4
.IX Item "pkt_size=n"
Set max packet size (in bytes) ta \fIn\fR.
.IP "\fBconnect=0|1\fR" 4
.IX Item "connect=0|1"
Do a \f(CW\*(C`connect()\*(C'\fR on tha \s-1UDP\s0 socket (if set ta 1) or not (if set
to 0).
.IP "\fBsources=\fR\fIip\fR\fB[,\fR\fIip\fR\fB]\fR" 4
.IX Item "sources=ip[,ip]"
List allowed source \s-1IP\s0 addresses.
.IP "\fBblock=\fR\fIip\fR\fB[,\fR\fIip\fR\fB]\fR" 4
.IX Item "block=ip[,ip]"
List disallowed (blocked) source \s-1IP\s0 addresses.
.IP "\fBwrite_to_source=0|1\fR" 4
.IX Item "write_to_source=0|1"
Send packets ta tha source address of tha sickest fuckin received packet (if
set ta 1) or ta a thugged-out default remote address (if set ta 0).
.IP "\fBlocalport=\fR\fIn\fR" 4
.IX Item "localport=n"
Set tha local \s-1RTP\s0 port ta \fIn\fR.
.Sp
This be a thugged-out deprecated option. I aint talkin' bout chicken n' gravy biatch. Instead, \fBlocalrtpport\fR should be
used.
.PP
Important notes:
.IP "1." 4
If \fBrtcpport\fR aint set tha \s-1RTCP\s0 port is ghon be set ta tha \s-1RTP\s0
port value plus 1.
.IP "2." 4
If \fBlocalrtpport\fR (the local \s-1RTP\s0 port) aint set any available
port is ghon be used fo' tha local \s-1RTP\s0 n' \s-1RTCP\s0 ports.
.IP "3." 4
If \fBlocalrtcpport\fR (the local \s-1RTCP\s0 port) aint set it will be
set ta tha the local \s-1RTP\s0 port value plus 1.
.SS "rtsp"
.IX Subsection "rtsp"
\&\s-1RTSP\s0 aint technologically a protocol handlez up in libavformat, it aint nuthin but a thugged-out demuxer
and muxer n' shit. Da demuxer supports both aiiight \s-1RTSP \s0(with data transferred
over \s-1RTP\s0; dis is used by e.g fo' realz. Applez n' Microsoft) n' Real-RTSP (with
data transferred over \s-1RDT\s0).
.PP
Da muxer can be used ta bust a stream rockin \s-1RTSP ANNOUNCE\s0 ta a server
supportin it (currently Darwin Streamin Server n' Mischa Spiegelmock's
<\fBhttp://github.com/revmischa/rtsp\-server\fR>).
.PP
Da required syntax fo' a \s-1RTSP\s0 url is:
.PP
.Vb 1
\&        rtsp://<hostname>[:<port>]/<path>
.Ve
.PP
Da followin options (set on tha \fBffmpeg\fR/\fBffplay\fR command
line, or set up in code via \f(CW\*(C`AVOption\*(C'\fRs or up in \f(CW\*(C`avformat_open_input\*(C'\fR),
are supported:
.PP
Flags fo' \f(CW\*(C`rtsp_transport\*(C'\fR:
.IP "\fBudp\fR" 4
.IX Item "udp"
Use \s-1UDP\s0 as lower transhiznit protocol.
.IP "\fBtcp\fR" 4
.IX Item "tcp"
Use \s-1TCP \s0(interleavin within tha \s-1RTSP\s0 control channel) as lower
transhiznit protocol.
.IP "\fBudp_multicast\fR" 4
.IX Item "udp_multicast"
Use \s-1UDP\s0 multicast as lower transhiznit protocol.
.IP "\fBhttp\fR" 4
.IX Item "http"
Use \s-1HTTP\s0 tunnelin as lower transhiznit protocol, which is useful for
passin proxies.
.PP
Multiple lower transhiznit protocols may be specified, up in dat case they are
tried one at a time (if tha setup of one fails, tha next one is tried).
For tha muxer, only tha \f(CW\*(C`tcp\*(C'\fR n' \f(CW\*(C`udp\*(C'\fR options is supported.
.PP
Flags fo' \f(CW\*(C`rtsp_flags\*(C'\fR:
.IP "\fBfilter_src\fR" 4
.IX Item "filter_src"
Accept packets only from negotiated peer address n' port.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Act as a server, listenin fo' a incomin connection.
.PP
When receivin data over \s-1UDP,\s0 tha demuxer tries ta reorder received packets
(since they may arrive outta order, or packets may git lost straight-up). This
can be disabled by settin tha maximum demuxin delay ta zero (via
the \f(CW\*(C`max_delay\*(C'\fR field of AVFormatContext).
.PP
When watchin multi-bitrate Real-RTSP streams wit \fBffplay\fR, the
streams ta display can be chosen wit \f(CW\*(C`\-vst\*(C'\fR \fIn\fR and
\&\f(CW\*(C`\-ast\*(C'\fR \fIn\fR fo' vizzle n' audio respectively, n' can be switched
on tha fly by pressin \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`a\*(C'\fR.
.PP
Example command lines:
.PP
To peep a stream over \s-1UDP,\s0 wit a max reorderin delay of 0.5 seconds:
.PP
.Vb 1
\&        ffplay \-max_delay 500000 \-rtsp_transhiznit udp rtsp://server/video.mp4
.Ve
.PP
To peep a stream tunneled over \s-1HTTP:\s0
.PP
.Vb 1
\&        ffplay \-rtsp_transhiznit http rtsp://server/video.mp4
.Ve
.PP
To bust a stream up in realtime ta a \s-1RTSP\s0 server, fo' others ta watch:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f rtsp \-muxdelay 0.1 rtsp://server/live.sdp
.Ve
.PP
To receive a stream up in realtime:
.PP
.Vb 1
\&        ffmpeg \-rtsp_flags listen \-i rtsp://ownaddress/live.sdp <output>
.Ve
.IP "\fBstimeout\fR" 4
.IX Item "stimeout"
Socket \s-1IO\s0 timeout up in micro seconds.
.SS "sap"
.IX Subsection "sap"
Session Announcement Protocol (\s-1RFC 2974\s0). This aint technologically a
protocol handlez up in libavformat, it aint nuthin but a muxer n' demuxer.
It be used fo' signallin of \s-1RTP\s0 streams, by announcin tha \s-1SDP\s0 fo' the
streams regularly on a separate port.
.PP
\fIMuxer\fR
.IX Subsection "Muxer"
.PP
Da syntax fo' a \s-1SAP\s0 url given ta tha muxer is:
.PP
.Vb 1
\&        sap://<destination>[:<port>][?<options>]
.Ve
.PP
Da \s-1RTP\s0 packets is busted ta \fIdestination\fR on port \fIport\fR,
or ta port 5004 if no port is specified.
\&\fIoptions\fR be a \f(CW\*(C`&\*(C'\fR\-separated list. Da followin options
are supported:
.IP "\fBannounce_addr=\fR\fIaddress\fR" 4
.IX Item "announce_addr=address"
Specify tha destination \s-1IP\s0 address fo' bustin  tha announcements to.
If omitted, tha announcements is busted ta tha commonly used \s-1SAP\s0
announcement multicast address 224.2.127.254 (sap.mcast.net), or
ff0e::2:7ffe if \fIdestination\fR be a IPv6 address.
.IP "\fBannounce_port=\fR\fIport\fR" 4
.IX Item "announce_port=port"
Specify tha port ta bust tha announcements on, defaults to
9875 if not specified.
.IP "\fBttl=\fR\fIttl\fR" 4
.IX Item "ttl=ttl"
Specify tha time ta live value fo' tha announcements n' \s-1RTP\s0 packets,
defaults ta 255.
.IP "\fBsame_port=\fR\fI0|1\fR" 4
.IX Item "same_port=0|1"
If set ta 1, bust all \s-1RTP\s0 streams on tha same port pair. Shiiit, dis aint no joke. If zero (the
default), all streams is busted on unique ports, wit each stream on a
port 2 numbers higher than tha previous.
VLC/Live555 requires dis ta be set ta 1, ta be able ta receive tha stream.
Da \s-1RTP\s0 stack up in libavformat fo' receivin requires all streams ta be sent
on unique ports.
.PP
Example command lines follow.
.PP
To broadcast a stream on tha local subnet, fo' watchin up in \s-1VLC:\s0
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://224.0.0.255?same_port=1
.Ve
.PP
Similarly, fo' watchin up in \fBffplay\fR:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://224.0.0.255
.Ve
.PP
And fo' watchin up in \fBffplay\fR, over IPv6:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://[ff0e::1:2:3:4]
.Ve
.PP
\fIDemuxer\fR
.IX Subsection "Demuxer"
.PP
Da syntax fo' a \s-1SAP\s0 url given ta tha demuxer is:
.PP
.Vb 1
\&        sap://[<address>][:<port>]
.Ve
.PP
\&\fIaddress\fR is tha multicast address ta listen fo' announcements on,
if omitted, tha default 224.2.127.254 (sap.mcast.net) is used. Y'all KNOW dat shit, muthafucka! \fIport\fR
is tha port dat is listened on, 9875 if omitted.
.PP
Da demuxers listens fo' announcements on tha given address n' port.
Once a announcement is received, it tries ta receive dat particular stream.
.PP
Example command lines follow.
.PP
To play back tha straight-up original gangsta stream announced on tha aiiight \s-1SAP\s0 multicast address:
.PP
.Vb 1
\&        ffplay sap://
.Ve
.PP
To play back tha straight-up original gangsta stream announced on one tha default IPv6 \s-1SAP\s0 multicast address:
.PP
.Vb 1
\&        ffplay sap://[ff0e::2:7ffe]
.Ve
.SS "sctp"
.IX Subsection "sctp"
Stream Control Transmission Protocol.
.PP
Da accepted \s-1URL\s0 syntax is:
.PP
.Vb 1
\&        sctp://<host>:<port>[?<options>]
.Ve
.PP
Da protocol accepts tha followin options:
.IP "\fBlisten\fR" 4
.IX Item "listen"
If set ta any value, listen fo' a incomin connection. I aint talkin' bout chicken n' gravy biatch. Outgoin connection is done by default.
.IP "\fBmax_streams\fR" 4
.IX Item "max_streams"
Set tha maximum number of streams. By default no limit is set.
.SS "srtp"
.IX Subsection "srtp"
Secure Real-time Transhiznit Protocol.
.PP
Da accepted options are:
.IP "\fBsrtp_in_suite\fR" 4
.IX Item "srtp_in_suite"
.PD 0
.IP "\fBsrtp_out_suite\fR" 4
.IX Item "srtp_out_suite"
.PD
Select input n' output encodin suites.
.Sp
Supported joints:
.RS 4
.IP "\fB\s-1AES_CM_128_HMAC_SHA1_80\s0\fR" 4
.IX Item "AES_CM_128_HMAC_SHA1_80"
.PD 0
.IP "\fB\s-1SRTP_AES128_CM_HMAC_SHA1_80\s0\fR" 4
.IX Item "SRTP_AES128_CM_HMAC_SHA1_80"
.IP "\fB\s-1AES_CM_128_HMAC_SHA1_32\s0\fR" 4
.IX Item "AES_CM_128_HMAC_SHA1_32"
.IP "\fB\s-1SRTP_AES128_CM_HMAC_SHA1_32\s0\fR" 4
.IX Item "SRTP_AES128_CM_HMAC_SHA1_32"
.RE
.RS 4
.RE
.IP "\fBsrtp_in_params\fR" 4
.IX Item "srtp_in_params"
.IP "\fBsrtp_out_params\fR" 4
.IX Item "srtp_out_params"
.PD
Set input n' output encodin parameters, which is expressed by a
base64\-encoded representation of a funky-ass binary block. Da first 16 bytes of
this binary block is used as masta key, tha followin 14 bytes are
used as masta salt.
.SS "tcp"
.IX Subsection "tcp"
Trasmission Control Protocol.
.PP
Da required syntax fo' a \s-1TCP\s0 url is:
.PP
.Vb 1
\&        tcp://<hostname>:<port>[?<options>]
.Ve
.IP "\fBlisten\fR" 4
.IX Item "listen"
Listen fo' a incomin connection
.IP "\fBtimeout=\fR\fImicroseconds\fR" 4
.IX Item "timeout=microseconds"
In read mode: if no data arrived up in mo' than dis time interval, raise error.
In write mode: if socket cannot be freestyled up in mo' than dis time interval, raise error.
This also sets timeout on \s-1TCP\s0 connection establishing.
.Sp
.Vb 2
\&        ffmpeg \-i <input> \-f <format> tcp://<hostname>:<port>?listen
\&        ffplay tcp://<hostname>:<port>
.Ve
.SS "tls"
.IX Subsection "tls"
Transhiznit Layer Securitizzle (\s-1TLS\s0) / Secure Sockets Layer (\s-1SSL\s0)
.PP
Da required syntax fo' a \s-1TLS/SSL\s0 url is:
.PP
.Vb 1
\&        tls://<hostname>:<port>[?<options>]
.Ve
.PP
Da followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBca_file, cafile=\fR\fIfilename\fR" 4
.IX Item "ca_file, cafile=filename"
A file containin certificate authoritizzle (\s-1CA\s0) root certificates ta treat
as trusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha linked \s-1TLS\s0 library gotz nuff a thugged-out default dis might not
need ta be specified fo' verification ta work yo, but not all libraries and
setups have defaults built in.
Da file must be up in OpenSSL \s-1PEM\s0 format.
.IP "\fBtls_verify=\fR\fI1|0\fR" 4
.IX Item "tls_verify=1|0"
If enabled, try ta verify tha peer dat we is communicatin with.
Note, if rockin OpenSSL, dis currently only make shizzle dat the
peer certificate is signed by one of tha root certificates up in tha \s-1CA\s0
database yo, but it do not validate dat tha certificate actually
matches tha host name we is tryin ta connect to. (With GnuTLS,
the host name is validated as well.)
.Sp
This is disabled by default since it requires a \s-1CA\s0 database ta be
provided by tha calla up in nuff cases.
.IP "\fBcert_file, cert=\fR\fIfilename\fR" 4
.IX Item "cert_file, cert=filename"
A file containin a cold-ass lil certificate ta use up in tha handshake wit tha peer.
(When operatin as server, up in listen mode, dis is mo' often required
by tha peer, while client certificates only is mandated up in certain
setups.)
.IP "\fBkey_file, key=\fR\fIfilename\fR" 4
.IX Item "key_file, key=filename"
A file containin tha private key fo' tha certificate.
.IP "\fBlisten=\fR\fI1|0\fR" 4
.IX Item "listen=1|0"
If enabled, listen fo' connections on tha provided port, n' assume
the server role up in tha handshake instead of tha client role.
.PP
Example command lines:
.PP
To create a \s-1TLS/SSL\s0 server dat serves a input stream.
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f <format> tls://<hostname>:<port>?listen&cert=<server.crt>&key=<server.key>
.Ve
.PP
To play back a stream from tha \s-1TLS/SSL\s0 server rockin \fBffplay\fR:
.PP
.Vb 1
\&        ffplay tls://<hostname>:<port>
.Ve
.SS "udp"
.IX Subsection "udp"
User Datagram Protocol.
.PP
Da required syntax fo' a \s-1UDP\s0 url is:
.PP
.Vb 1
\&        udp://<hostname>:<port>[?<options>]
.Ve
.PP
\&\fIoptions\fR gotz nuff a list of &\-separated optionz of tha form \fIkey\fR=\fIval\fR.
.PP
In case threadin is enabled on tha system, a cold-ass lil circular buffer is used
to store tha incomin data, which allows ta reduce loss of data due to
\&\s-1UDP\s0 socket buffer overruns. Da \fIfifo_size\fR and
\&\fIoverrun_nonfatal\fR options is related ta dis buffer.
.PP
Da list of supported options bigs up.
.IP "\fBbuffer_size=\fR\fIsize\fR" 4
.IX Item "buffer_size=size"
Set tha \s-1UDP\s0 socket buffer size up in bytes. This is used both fo' the
receivin n' tha bustin  buffer size.
.IP "\fBlocalport=\fR\fIport\fR" 4
.IX Item "localport=port"
Override tha local \s-1UDP\s0 port ta bind with.
.IP "\fBlocaladdr=\fR\fIaddr\fR" 4
.IX Item "localaddr=addr"
Choose tha local \s-1IP\s0 address. This is useful e.g. if bustin  multicast
and tha host has multiple intercourses, where tha user can chizzle
which intercourse ta bust on by specifyin tha \s-1IP\s0 address of dat intercourse.
.IP "\fBpkt_size=\fR\fIsize\fR" 4
.IX Item "pkt_size=size"
Set tha size up in bytez of \s-1UDP\s0 packets.
.IP "\fBreuse=\fR\fI1|0\fR" 4
.IX Item "reuse=1|0"
Explicitly allow or disallow reusin \s-1UDP\s0 sockets.
.IP "\fBttl=\fR\fIttl\fR" 4
.IX Item "ttl=ttl"
Set tha time ta live value (for multicast only).
.IP "\fBconnect=\fR\fI1|0\fR" 4
.IX Item "connect=1|0"
Initialize tha \s-1UDP\s0 socket wit \f(CW\*(C`connect()\*(C'\fR. In dis case, the
destination address can't be chizzled wit ff_udp_set_remote_url later.
If tha destination address aint known all up in tha start, dis option can
be specified up in ff_udp_set_remote_url, like a muthafucka.
This allows findin up tha source address fo' tha packets wit getsockname,
and make writes return wit \s-1AVERROR\s0(\s-1ECONNREFUSED\s0) if \*(L"destination
unreachable\*(R" is received.
For receiving, dis gives tha benefit of only receivin packets from
the specified peer address/port.
.IP "\fBsources=\fR\fIaddress\fR\fB[,\fR\fIaddress\fR\fB]\fR" 4
.IX Item "sources=address[,address]"
Only receive packets busted ta tha multicast crew from one of the
specified sender \s-1IP\s0 addresses.
.IP "\fBblock=\fR\fIaddress\fR\fB[,\fR\fIaddress\fR\fB]\fR" 4
.IX Item "block=address[,address]"
Ignore packets busted ta tha multicast crew from tha specified
sender \s-1IP\s0 addresses.
.IP "\fBfifo_size=\fR\fIunits\fR" 4
.IX Item "fifo_size=units"
Set tha \s-1UDP\s0 receivin circular buffer size, expressed as a number of
packets wit size of 188 bytes. If not specified defaults ta 7*4096.
.IP "\fBoverrun_nonfatal=\fR\fI1|0\fR" 4
.IX Item "overrun_nonfatal=1|0"
Survive up in case of \s-1UDP\s0 receivin circular buffer overrun. I aint talkin' bout chicken n' gravy biatch. Default
value is 0.
.IP "\fBtimeout=\fR\fImicroseconds\fR" 4
.IX Item "timeout=microseconds"
In read mode: if no data arrived up in mo' than dis time interval, raise error.
.PP
Some usage examplez of tha \s-1UDP\s0 protocol wit \fBffmpeg\fR follow.
.PP
To stream over \s-1UDP\s0 ta a remote endpoint:
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f <format> udp://<hostname>:<port>
.Ve
.PP
To stream up in mpegts format over \s-1UDP\s0 rockin 188 sized \s-1UDP\s0 packets, rockin a big-ass input buffer:
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f mpegts udp://<hostname>:<port>?pkt_size=188&buffer_size=65535
.Ve
.PP
To receive over \s-1UDP\s0 from a remote endpoint:
.PP
.Vb 1
\&        ffmpeg \-i udp://[<multicast\-address>]:<port>
.Ve
.SS "unix"
.IX Subsection "unix"
Unix local socket
.PP
Da required syntax fo' a Unix socket \s-1URL\s0 is:
.PP
.Vb 1
\&        unix://<filepath>
.Ve
.PP
Da followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Timeout up in ms.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Smoke tha Unix socket up in listenin mode.
.SH "DEVICE OPTIONS"
.IX Header "DEVICE OPTIONS"
Da libavdevice library serves up tha same intercourse as
libavformat. Namely, a input thang is considered like a thugged-out demuxer, and
an output thang like a muxer, n' tha intercourse n' generic device
options is tha same provided by libavformat (see tha ffmpeg-formats
manual).
.PP
In addizzle each input or output thang may support so-called private
options, which is specific fo' dat component.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, or by settin tha value explicitly up in tha device
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.SH "INPUT DEVICES"
.IX Header "INPUT DEVICES"
Input devices is configured elements up in FFmpeg which allow ta access
the data comin from a multimedia thang attached ta yo' system.
.PP
When you configure yo' FFmpeg build, all tha supported input devices
are enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-indevs\*(R".
.PP
Yo ass can disable all tha input devices rockin tha configure option
\&\*(L"\-\-disable\-indevs\*(R", n' selectively enable a input thang rockin the
option "\-\-enable\-indev=\fI\s-1INDEV\s0\fR\*(L", or you can disable a particular
input thang rockin tha option \*(R"\-\-disable\-indev=\fI\s-1INDEV\s0\fR".
.PP
Da option \*(L"\-formats\*(R" of tha ff* tools will display tha list of
supported input devices (amongst tha demuxers).
.PP
A description of tha currently available input devices bigs up.
.SS "alsa"
.IX Subsection "alsa"
\&\s-1ALSA \s0(Advanced Linux Sound Architecture) input device.
.PP
To enable dis input thang durin configuration you need libasound
installed on yo' system.
.PP
This thang allows capturin from a \s-1ALSA\s0 device. Da name of the
device ta capture has ta be a \s-1ALSA\s0 card identifier.
.PP
An \s-1ALSA\s0 identifier has tha syntax:
.PP
.Vb 1
\&        hw:<CARD>[,<DEV>[,<SUBDEV>]]
.Ve
.PP
where tha \fI\s-1DEV\s0\fR n' \fI\s-1SUBDEV\s0\fR components is optional.
.PP
Da three arguments (in order: \fI\s-1CARD\s0\fR,\fI\s-1DEV\s0\fR,\fI\s-1SUBDEV\s0\fR)
specify card number or identifier, thang number n' subdevice number
(\-1 means any).
.PP
To peep tha list of cardz currently recognized by yo' system check the
filez \fI/proc/asound/cards\fR n' \fI/proc/asound/devices\fR.
.PP
For example ta capture wit \fBffmpeg\fR from a \s-1ALSA\s0 thang with
card id 0, you may run tha command:
.PP
.Vb 1
\&        ffmpeg \-f alsa \-i hw:0 alsaout.wav
.Ve
.PP
For mo' shiznit see:
<\fBhttp://www.alsa\-project.org/alsa\-doc/alsa\-lib/pcm.html\fR>
.SS "bktr"
.IX Subsection "bktr"
\&\s-1BSD\s0 vizzle input device.
.SS "dshow"
.IX Subsection "dshow"
Windows DirectShow input device.
.PP
DirectShow support is enabled when FFmpeg is built wit tha mingw\-w64 project.
Currently only audio n' vizzle devices is supported.
.PP
Multiple devices may be opened as separate inputs yo, but they may also be
opened on tha same input, which should improve synchronizzle between em.
.PP
Da input name should be up in tha format:
.PP
.Vb 1
\&        <TYPE>=<NAME>[:<TYPE>=<NAME>]
.Ve
.PP
where \fI\s-1TYPE\s0\fR can be either \fIaudio\fR or \fIvideo\fR,
and \fI\s-1NAME\s0\fR is tha devicez name.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
If no options is specified, tha devicez defaults is used.
If tha thang do not support tha axed options, it will
fail ta open.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle size up in tha captured vizzle.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha frame rate up in tha captured vizzle.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Set tha sample rate (in Hz) of tha captured audio.
.IP "\fBsample_size\fR" 4
.IX Item "sample_size"
Set tha sample size (in bits) of tha captured audio.
.IP "\fBchannels\fR" 4
.IX Item "channels"
Set tha number of channels up in tha captured audio.
.IP "\fBlist_devices\fR" 4
.IX Item "list_devices"
If set ta \fBtrue\fR, print a list of devices n' exit.
.IP "\fBlist_options\fR" 4
.IX Item "list_options"
If set ta \fBtrue\fR, print a list of selected devicez options
and exit.
.IP "\fBvideo_device_number\fR" 4
.IX Item "video_device_number"
Set vizzle thang number fo' devices wit same name (starts at 0,
defaults ta 0).
.IP "\fBaudio_device_number\fR" 4
.IX Item "audio_device_number"
Set audio thang number fo' devices wit same name (starts at 0,
defaults ta 0).
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Select pixel format ta be used by DirectShow. This may only be set when
the vizzle codec aint set or set ta rawvideo.
.IP "\fBaudio_buffer_size\fR" 4
.IX Item "audio_buffer_size"
Set audio thang buffer size up in millisecondz (which can directly
impact latency, dependin on tha device).
Defaults ta rockin tha audio device's
default buffer size (typically some multiple of 500ms).
Settin dis value too low can degrade performance.
See also
<\fBhttp://msdn.microsoft.com/en\-us/library/windows/desktop/dd377582(v=vs.85).aspx\fR>
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Print tha list of DirectShow supported devices n' exit:
.Sp
.Vb 1
\&        $ ffmpeg \-list_devices legit \-f dshow \-i dummy
.Ve
.IP "\(bu" 4
Open vizzle thang \fICamera\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-i vizzle="Camera"
.Ve
.IP "\(bu" 4
Open second vizzle thang wit name \fICamera\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-video_device_number 1 \-i vizzle="Camera"
.Ve
.IP "\(bu" 4
Open vizzle thang \fICamera\fR n' audio thang \fIMicrophone\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-i vizzle="Camera":audio="Microphone"
.Ve
.IP "\(bu" 4
Print tha list of supported options up in selected thang n' exit:
.Sp
.Vb 1
\&        $ ffmpeg \-list_options legit \-f dshow \-i vizzle="Camera"
.Ve
.SS "dv1394"
.IX Subsection "dv1394"
Linux \s-1DV 1394\s0 input device.
.SS "fbdev"
.IX Subsection "fbdev"
Linux framebuffer input device.
.PP
Da Linux framebuffer be a graphic hardware-independent abstraction
layer ta show graphics on a cold-ass lil computa monitor, typically on the
console. Well shiiiit, it be accessed all up in a gangbangin' file thang node, usually
\&\fI/dev/fb0\fR.
.PP
For mo' detailed shiznit read tha file
Documentation/fb/framebuffer.txt included up in tha Linux source tree.
.PP
To record from tha framebuffer thang \fI/dev/fb0\fR with
\&\fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-f fbdev \-r 10 \-i /dev/fb0 out.avi
.Ve
.PP
Yo ass can take a single screenshot image wit tha command:
.PP
.Vb 1
\&        ffmpeg \-f fbdev \-frames:v 1 \-r 1 \-i /dev/fb0 screenshot.jpeg
.Ve
.PP
See also <\fBhttp://linux\-fbdev.sourceforge.net/\fR>, n' \fIfbset\fR\|(1).
.SS "iec61883"
.IX Subsection "iec61883"
FireWire \s-1DV/HDV\s0 input thang rockin libiec61883.
.PP
To enable dis input device, you need libiec61883, libraw1394 and
libavc1394 installed on yo' system. Use tha configure option
\&\f(CW\*(C`\-\-enable\-libiec61883\*(C'\fR ta compile wit tha thang enabled.
.PP
Da iec61883 capture thang supports capturin from a vizzle device
connected via \s-1IEEE1394 \s0(FireWire), rockin libiec61883 n' tha freshly smoked up Linux
FireWire stack (juju). This is tha default \s-1DV/HDV\s0 input method up in Linux
Kernel 2.6.37 n' later, since tha oldschool FireWire stack was removed.
.PP
Specify tha FireWire port ta be used as input file, or \*(L"auto\*(R"
to chizzle tha straight-up original gangsta port connected.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdvtype\fR" 4
.IX Item "dvtype"
Override autodetection of \s-1DV/HDV.\s0 This should only be used if auto
detection do not work, or if usage of a gangbangin' finger-lickin' different thang type
should be prohibited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Treatin a \s-1DV\s0 thang as \s-1HDV \s0(or vice versa) will
not work n' result up in undefined behavior.
Da joints \fBauto\fR, \fBdv\fR n' \fBhdv\fR is supported.
.IP "\fBdvbuffer\fR" 4
.IX Item "dvbuffer"
Set maxiumum size of buffer fo' incomin data, up in frames. For \s-1DV,\s0 this
is a exact value. For \s-1HDV,\s0 it aint frame exact, since \s-1HDV\s0 do
not gotz a gangbangin' fixed frame size.
.IP "\fBdvguid\fR" 4
.IX Item "dvguid"
Select tha capture thang by specifyin itz \s-1GUID.\s0 Capturin will only
be performed from tha specified thang n' fails if no thang wit the
given \s-1GUID\s0 is found. Y'all KNOW dat shit, muthafucka! This is useful ta select tha input if multiple
devices is connected all up in tha same time.
Look at /sys/bus/firewire/devices ta smoke up tha GUIDs.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Grab n' show tha input of a FireWire \s-1DV/HDV\s0 device.
.Sp
.Vb 1
\&        ffplay \-f iec61883 \-i auto
.Ve
.IP "\(bu" 4
Grab n' record tha input of a FireWire \s-1DV/HDV\s0 device,
usin a packet buffer of 100000 packets if tha source is \s-1HDV.\s0
.Sp
.Vb 1
\&        ffmpeg \-f iec61883 \-i auto \-hdvbuffer 100000 out.mpg
.Ve
.SS "jack"
.IX Subsection "jack"
\&\s-1JACK\s0 input device.
.PP
To enable dis input thang durin configuration you need libjack
installed on yo' system.
.PP
A \s-1JACK\s0 input thang creates one or mo' \s-1JACK\s0 writable clients, one for
each audio channel, wit name \fIclient_name\fR:input_\fIN\fR, where
\&\fIclient_name\fR is tha name provided by tha application, n' \fIN\fR
is a number which identifies tha channel.
Each writable client will bust tha acquired data ta tha FFmpeg input
device.
.PP
Once you have pimped one or mo' \s-1JACK\s0 readable clients, you need to
connect dem ta one or mo' \s-1JACK\s0 writable clients.
.PP
To connect or disconnect \s-1JACK\s0 clients you can use tha \fBjack_connect\fR
and \fBjack_disconnect\fR programs, or do it all up in a graphical intercourse,
for example wit \fBqjackctl\fR.
.PP
To list tha \s-1JACK\s0 clients n' they propertizzles you can invoke tha command
\&\fBjack_lsp\fR.
.PP
Follows a example which shows how tha fuck ta capture a \s-1JACK\s0 readable client
with \fBffmpeg\fR.
.PP
.Vb 2
\&        # Smoke a JACK writable client wit name "ffmpeg".
\&        $ ffmpeg \-f jack \-i ffmpeg \-y out.wav
\&        
\&        # Start tha sample jack_metro readable client.
\&        $ jack_metro \-b 120 \-d 0.2 \-f 4000
\&        
\&        # List tha current JACK clients.
\&        $ jack_lsp \-c
\&        system:capture_1
\&        system:capture_2
\&        system:playback_1
\&        system:playback_2
\&        ffmpeg:input_1
\&        metro:120_bpm
\&        
\&        # Connect metro ta tha ffmpeg writable client.
\&        $ jack_connect metro:120_bpm ffmpeg:input_1
.Ve
.PP
For mo' shiznit read:
<\fBhttp://jackaudio.org/\fR>
.SS "lavfi"
.IX Subsection "lavfi"
Libavfilta input virtual device.
.PP
This input thang readz data from tha open output padz of a libavfilter
filtergraph.
.PP
For each filtergraph open output, tha input thang will create a
correspondin stream which is mapped ta tha generated output. Currently
only vizzle data is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da filtergraph is specified all up in the
option \fBgraph\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBgraph\fR" 4
.IX Item "graph"
Specify tha filtergraph ta use as input. Each vizzle open output must be
labelled by a unique strang of tha form "out\fIN\fR", where \fIN\fR be a
number startin from 0 correspondin ta tha mapped input stream
generated by tha device.
Da first unlabelled output be automatically assigned ta tha \*(L"out0\*(R"
label yo, but all tha others need ta be specified explicitly.
.Sp
If not specified defaults ta tha filename specified fo' tha input
device.
.IP "\fBgraph_file\fR" 4
.IX Item "graph_file"
Set tha filename of tha filtergraph ta be read n' busted ta tha other
filters. Right back up in yo muthafuckin ass. Syntax of tha filtergraph is tha same ol' dirty as tha one specified by
the option \fIgraph\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Smoke a cold-ass lil color vizzle stream n' play it back wit \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-graph "color=c=pink [out0]" dummy
.Ve
.IP "\(bu" 4
As tha previous example yo, but use filename fo' specifyin tha graph
description, n' omit tha \*(L"out0\*(R" label:
.Sp
.Vb 1
\&        ffplay \-f lavfi color=c=pink
.Ve
.IP "\(bu" 4
Smoke three different vizzle test filtered sources n' play them:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-graph "testsrc [out0]; testsrc,hflip [out1]; testsrc,negate [out2]" test3
.Ve
.IP "\(bu" 4
Read a audio stream from a gangbangin' file rockin tha amovie source n' play it
back wit \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi "amovie=test.wav"
.Ve
.IP "\(bu" 4
Read a audio stream n' a vizzle stream n' play it back with
\&\fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi "movie=test.avi[out0];amovie=test.wav[out1]"
.Ve
.SS "libdc1394"
.IX Subsection "libdc1394"
\&\s-1IIDC1394\s0 input device, based on libdc1394 n' libraw1394.
.SS "openal"
.IX Subsection "openal"
Da OpenAL input thang serves up audio capture on all systems wit a
workin OpenAL 1.1 implementation.
.PP
To enable dis input thang durin configuration, you need OpenAL
headaz n' libraries installed on yo' system, n' need ta configure
FFmpeg wit \f(CW\*(C`\-\-enable\-openal\*(C'\fR.
.PP
OpenAL headaz n' libraries should be provided as part of yo' OpenAL
implementation, or as a additionizzle downlizzle (an \s-1SDK\s0). Dependin on your
installation you may need ta specify additionizzle flags via the
\&\f(CW\*(C`\-\-extra\-cflags\*(C'\fR n' \f(CW\*(C`\-\-extra\-ldflags\*(C'\fR fo' allowin tha build
system ta locate tha OpenAL headaz n' libraries.
.PP
An incomplete list of OpenAL implementations bigs up:
.IP "\fBCreative\fR" 4
.IX Item "Creative"
Da straight-up legit Windows implementation, providin hardware acceleration
with supported devices n' software fallback.
See <\fBhttp://openal.org/\fR>.
.IP "\fBOpenAL Soft\fR" 4
.IX Item "OpenAL Soft"
Portable, open source (\s-1LGPL\s0) software implementation. I aint talkin' bout chicken n' gravy biatch. Includes
backendz fo' da most thugged-out common sound APIs on tha Windows, Linux,
Solaris, n' \s-1BSD\s0 operatin systems.
See <\fBhttp://kcat.strangesoft.net/openal.html\fR>.
.IP "\fBApple\fR" 4
.IX Item "Apple"
OpenAL is part of Core Audio, tha straight-up legit Mac \s-1OS X\s0 Audio intercourse.
See <\fBhttp://developer.apple.com/technologies/mac/audio\-and\-video.html\fR>
.PP
This thang allows ta capture from a audio input thang handled
all up in OpenAL.
.PP
Yo ass need ta specify tha name of tha thang ta capture up in tha provided
filename. If tha empty strang is provided, tha thang will
automatically select tha default device. Yo ass can git tha list of the
supported devices by rockin tha option \fIlist_devices\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBchannels\fR" 4
.IX Item "channels"
Set tha number of channels up in tha captured audio. Only tha joints
\&\fB1\fR (monaural) n' \fB2\fR (stereo) is currently supported.
Defaults ta \fB2\fR.
.IP "\fBsample_size\fR" 4
.IX Item "sample_size"
Set tha sample size (in bits) of tha captured audio. Only tha joints
\&\fB8\fR n' \fB16\fR is currently supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Defaults to
\&\fB16\fR.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Set tha sample rate (in Hz) of tha captured audio.
Defaults ta \fB44.1k\fR.
.IP "\fBlist_devices\fR" 4
.IX Item "list_devices"
If set ta \fBtrue\fR, print a list of devices n' exit.
Defaults ta \fBfalse\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Print tha list of OpenAL supported devices n' exit:
.PP
.Vb 1
\&        $ ffmpeg \-list_devices legit \-f openal \-i dummy out.ogg
.Ve
.PP
Capture from tha OpenAL thang \fI\s-1DR\-BT101\s0 via PulseAudio\fR:
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(AqDR\-BT101 via PulseAudio\*(Aq out.ogg
.Ve
.PP
Capture from tha default thang (note tha empty strang '' as filename):
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(Aq\*(Aq out.ogg
.Ve
.PP
Capture from two devices simultaneously, freestylin ta two different files,
within tha same \fBffmpeg\fR command:
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(AqDR\-BT101 via PulseAudio\*(Aq out1.ogg \-f openal \-i \*(AqALSA Default\*(Aq out2.ogg
.Ve
.PP
Note: not all OpenAL implementations support multiple simultaneous capture \-
try tha sickest fuckin OpenAL Soft if tha above do not work.
.SS "oss"
.IX Subsection "oss"
Open Sound System input device.
.PP
Da filename ta provide ta tha input thang is tha thang node
representin tha \s-1OSS\s0 input device, n' is probably set to
\&\fI/dev/dsp\fR.
.PP
For example ta grab from \fI/dev/dsp\fR rockin \fBffmpeg\fR use the
command:
.PP
.Vb 1
\&        ffmpeg \-f oss \-i /dev/dsp /tmp/oss.wav
.Ve
.PP
For mo' shiznit bout \s-1OSS\s0 see:
<\fBhttp://manuals.opensound.com/usersguide/dsp.html\fR>
.SS "pulse"
.IX Subsection "pulse"
PulseAudio input device.
.PP
To enable dis output thang you need ta configure FFmpeg wit \f(CW\*(C`\-\-enable\-libpulse\*(C'\fR.
.PP
Da filename ta provide ta tha input thang be a source thang or the
strin \*(L"default\*(R"
.PP
To list tha PulseAudio source devices n' they propertizzles you can invoke
the command \fBpactl list sources\fR.
.PP
Mo' shiznit bout PulseAudio can be found on <\fBhttp://www.pulseaudio.org\fR>.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBserver\fR" 4
.IX Item "server"
Connect ta a specific PulseAudio server, specified by a \s-1IP\s0 address.
Default server is used when not provided.
.IP "\fBname\fR" 4
.IX Item "name"
Specify tha application name PulseAudio will use when showin actizzle clients,
by default it is tha \f(CW\*(C`LIBAVFORMAT_IDENT\*(C'\fR string.
.IP "\fBstream_name\fR" 4
.IX Item "stream_name"
Specify tha stream name PulseAudio will use when showin actizzle streams,
by default it is \*(L"record\*(R".
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Specify tha samplerate up in Hz, by default 48kHz is used.
.IP "\fBchannels\fR" 4
.IX Item "channels"
Specify tha channels up in use, by default 2 (stereo) is set.
.IP "\fBframe_size\fR" 4
.IX Item "frame_size"
Specify tha number of bytes per frame, by default it is set ta 1024.
.IP "\fBfragment_size\fR" 4
.IX Item "fragment_size"
Specify tha minimal bufferin fragment up in PulseAudio, it will affect the
audio latency. By default it is unset.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Record a stream from default device:
.PP
.Vb 1
\&        ffmpeg \-f pulse \-i default /tmp/pulse.wav
.Ve
.SS "sndio"
.IX Subsection "sndio"
sndio input device.
.PP
To enable dis input thang durin configuration you need libsndio
installed on yo' system.
.PP
Da filename ta provide ta tha input thang is tha thang node
representin tha sndio input device, n' is probably set to
\&\fI/dev/audio0\fR.
.PP
For example ta grab from \fI/dev/audio0\fR rockin \fBffmpeg\fR use the
command:
.PP
.Vb 1
\&        ffmpeg \-f sndio \-i /dev/audio0 /tmp/oss.wav
.Ve
.SS "video4linux2, v4l2"
.IX Subsection "video4linux2, v4l2"
Video4Linux2 input vizzle device.
.PP
\&\*(L"v4l2\*(R" can be used as alias fo' \*(L"video4linux2\*(R".
.PP
If FFmpeg is built wit v4l\-utils support (by rockin the
\&\f(CW\*(C`\-\-enable\-libv4l2\*(C'\fR configure option), it is possible ta use it wit the
\&\f(CW\*(C`\-use_libv4l2\*(C'\fR input thang option.
.PP
Da name of tha thang ta grab be a gangbangin' file thang node, probably Linux
systems tend ta automatically create such nodes when tha device
(e.g. a \s-1STD\s0 webcam) is plugged tha fuck into tha system, n' has a name of the
kind \fI/dev/video\fIN\fI\fR, where \fIN\fR be a number associated to
the device.
.PP
Video4Linux2 devices probably support a limited set of
\&\fIwidth\fRx\fIheight\fR sizes n' frame rates. Yo ass can check which are
supported rockin \fB\-list_formats all\fR fo' Video4Linux2 devices.
Some devices, like \s-1TV\s0 cards, support one or mo' standards. Well shiiiit, it is possible
to list all tha supported standardz rockin \fB\-list_standardz all\fR.
.PP
Da time base fo' tha timestamps is 1 microsecond. Y'all KNOW dat shit, muthafucka! Dependin on tha kernel
version n' configuration, tha timestamps may be derived from tha real time
clock (origin all up in tha Unix Epoch) or tha monotonic clock (origin probably at
boot time, unaffected by \s-1NTP\s0 or manual chizzlez ta tha clock). The
\&\fB\-timestamps abs\fR or \fB\-ts abs\fR option can be used ta force
conversion tha fuck into tha real time clock.
.PP
Some usage examplez of tha vizzle4linux2 thang wit \fBffmpeg\fR
and \fBffplay\fR:
.IP "\(bu" 4
Grab n' show tha input of a vizzle4linux2 device:
.Sp
.Vb 1
\&        ffplay \-f vizzle4linux2 \-framerate 30 \-video_size hd720 /dev/video0
.Ve
.IP "\(bu" 4
Grab n' record tha input of a vizzle4linux2 device, leave the
frame rate n' size as previously set:
.Sp
.Vb 1
\&        ffmpeg \-f vizzle4linux2 \-input_format mjpeg \-i /dev/video0 out.mpeg
.Ve
.PP
For mo' shiznit bout Video4Linux, check <\fBhttp://linuxtv.org/\fR>.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBstandard\fR" 4
.IX Item "standard"
Set tha standard. Y'all KNOW dat shit, muthafucka! Must be tha name of a supported standard. Y'all KNOW dat shit, muthafucka! To git a
list of tha supported standards, use tha \fBlist_standards\fR
option.
.IP "\fBchannel\fR" 4
.IX Item "channel"
Set tha input channel number n' shit. Default ta \-1, which means rockin the
previously selected channel.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle frame size. Da argument must be a strang up in tha form
\&\fI\s-1WIDTH\s0\fRx\fI\s-1HEIGHT\s0\fR or a valid size abbreviation.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Select tha pixel format (only valid fo' raw vizzle input).
.IP "\fBinput_format\fR" 4
.IX Item "input_format"
Set tha preferred pixel format (for raw vizzle) or a cold-ass lil codec name.
This option allows ta select tha input format, when nuff muthafuckin are
available.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha preferred vizzle frame rate.
.IP "\fBlist_formats\fR" 4
.IX Item "list_formats"
List available formats (supported pixel formats, codecs, n' frame
sizes) n' exit.
.Sp
Available joints are:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Show all available (compressed n' non-compressed) formats.
.IP "\fBraw\fR" 4
.IX Item "raw"
Show only raw vizzle (non-compressed) formats.
.IP "\fBcompressed\fR" 4
.IX Item "compressed"
Show only compressed formats.
.RE
.RS 4
.RE
.IP "\fBlist_standards\fR" 4
.IX Item "list_standards"
List supported standardz n' exit.
.Sp
Available joints are:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Show all supported standards.
.RE
.RS 4
.RE
.IP "\fBtimestamps, ts\fR" 4
.IX Item "timestamps, ts"
Set type of timestamps fo' grabbed frames.
.Sp
Available joints are:
.RS 4
.IP "\fBdefault\fR" 4
.IX Item "default"
Use timestamps from tha kernel.
.IP "\fBabs\fR" 4
.IX Item "abs"
Use absolute timestamps (wall clock).
.IP "\fBmono2abs\fR" 4
.IX Item "mono2abs"
Force conversion from monotonic ta absolute timestamps.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`default\*(C'\fR.
.RE
.SS "vfwcap"
.IX Subsection "vfwcap"
VfW (Video fo' Windows) capture input device.
.PP
Da filename passed as input is tha capture driver number, rangin from
0 ta 9. Yo ass may use \*(L"list\*(R" as filename ta print a list of drivers fo' realz. Any
other filename is ghon be interpreted as thang number 0.
.SS "x11grab"
.IX Subsection "x11grab"
X11 vizzle input device.
.PP
This thang allows ta capture a region of a X11 display.
.PP
Da filename passed as input has tha syntax:
.PP
.Vb 1
\&        [<hostname>]:<display_number>.<screen_number>[+<x_offset>,<y_offset>]
.Ve
.PP
\&\fIhostname\fR:\fIdisplay_number\fR.\fIscreen_number\fR specifies the
X11 display name of tha screen ta grab from. \fIhostname\fR can be
omitted, n' defaults ta \*(L"localhost\*(R". Da environment variable
\&\fB\s-1DISPLAY\s0\fR gotz nuff tha default display name.
.PP
\&\fIx_offset\fR n' \fIy_offset\fR specify tha offsetz of tha grabbed
area wit respect ta tha top-left border of tha X11 screen. I aint talkin' bout chicken n' gravy biatch. They
default ta 0.
.PP
Peep tha X11 documentation (e.g. playa X) fo' mo' detailed shiznit.
.PP
Use tha \fBdpyinfo\fR program fo' gettin basic shiznit bout the
propertizzlez of yo' X11 display (e.g. grep fo' \*(L"name\*(R" or \*(L"dimensions\*(R").
.PP
For example ta grab from \fI:0.0\fR rockin \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.PP
Grab at posizzle \f(CW\*(C`10,20\*(C'\fR:
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-framerate 25 \-video_size cif \-i :0.0+10,20 out.mpg
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdraw_mouse\fR" 4
.IX Item "draw_mouse"
Specify whether ta draw tha mouse pointer n' shiznit fo' realz. A value of \f(CW0\fR specify
not ta draw tha pointer n' shit. Default value is \f(CW1\fR.
.IP "\fBfollow_mouse\fR" 4
.IX Item "follow_mouse"
Make tha grabbed area follow tha mouse. Da argument can be
\&\f(CW\*(C`centered\*(C'\fR or a fuckin shitload of pixels \fI\s-1PIXELS\s0\fR.
.Sp
When it is specified wit \*(L"centered\*(R", tha grabbin region bigs up tha mouse
pointa n' keeps tha pointa all up in tha centa of region; otherwise, tha region
bigs up only when tha mouse pointa reaches within \fI\s-1PIXELS\s0\fR (greata than
zero) ta tha edge of region.
.Sp
For example:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse centered \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.Sp
To follow only when tha mouse pointa reaches within 100 pixels ta edge:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse 100 \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha grabbin frame rate. Default value is \f(CW\*(C`ntsc\*(C'\fR,
correspondin ta a gangbangin' frame rate of \f(CW\*(C`30000/1001\*(C'\fR.
.IP "\fBshow_region\fR" 4
.IX Item "show_region"
Show grabbed region on screen.
.Sp
If \fIshow_region\fR is specified wit \f(CW1\fR, then tha grabbing
region is ghon be indicated on screen. I aint talkin' bout chicken n' gravy biatch. With dis option, it is easy as fuck  to
know what tha fuck is bein grabbed if only a portion of tha screen is grabbed.
.Sp
For example:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-show_region 1 \-framerate 25 \-video_size cif \-i :0.0+10,20 out.mpg
.Ve
.Sp
With \fIfollow_mouse\fR:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse centered \-show_region 1 \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle frame size. Default value is \f(CW\*(C`vga\*(C'\fR.
.SH "OUTPUT DEVICES"
.IX Header "OUTPUT DEVICES"
Output devices is configured elements up in FFmpeg dat can write
multimedia data ta a output thang attached ta yo' system.
.PP
When you configure yo' FFmpeg build, all tha supported output devices
are enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-outdevs\*(R".
.PP
Yo ass can disable all tha output devices rockin tha configure option
\&\*(L"\-\-disable\-outdevs\*(R", n' selectively enable a output thang rockin the
option "\-\-enable\-outdev=\fI\s-1OUTDEV\s0\fR\*(L", or you can disable a particular
input thang rockin tha option \*(R"\-\-disable\-outdev=\fI\s-1OUTDEV\s0\fR".
.PP
Da option \*(L"\-formats\*(R" of tha ff* tools will display tha list of
enabled output devices (amongst tha muxers).
.PP
A description of tha currently available output devices bigs up.
.SS "alsa"
.IX Subsection "alsa"
\&\s-1ALSA \s0(Advanced Linux Sound Architecture) output device.
.SS "caca"
.IX Subsection "caca"
\&\s-1CACA\s0 output device.
.PP
This output thang allows ta show a vizzle stream up in \s-1CACA\s0 window.
Only one \s-1CACA\s0 window be allowed per application, so you can
have only one instizzle of dis output thang up in a application.
.PP
To enable dis output thang you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libcaca\*(C'\fR.
libcaca be a graphics library dat outputs text instead of pixels.
.PP
For mo' shiznit bout libcaca, check:
<\fBhttp://caca.zoy.org/wiki/libcaca\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha \s-1CACA\s0 window title, if not specified default ta tha filename
specified fo' tha output device.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha \s-1CACA\s0 window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation.
If not specified it defaults ta tha size of tha input vizzle.
.IP "\fBdriver\fR" 4
.IX Item "driver"
Set display driver.
.IP "\fBalgorithm\fR" 4
.IX Item "algorithm"
Set ditherin algorithm. Ditherin is necessary
because tha picture bein rendered has probably far mo' colours than
the available palette.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither algorithms\*(C'\fR.
.IP "\fBantialias\fR" 4
.IX Item "antialias"
Set antialias method. Y'all KNOW dat shit, muthafucka! Antialiasin smoothens tha rendered
image n' avoidz tha commonly peeped staircase effect.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither antialiases\*(C'\fR.
.IP "\fBcharset\fR" 4
.IX Item "charset"
Set which charactas is goin ta be used when renderin text.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither charsets\*(C'\fR.
.IP "\fBcolor\fR" 4
.IX Item "color"
Set color ta be used when renderin text.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither colors\*(C'\fR.
.IP "\fBlist_drivers\fR" 4
.IX Item "list_drivers"
If set ta \fBtrue\fR, print a list of available drivers n' exit.
.IP "\fBlist_dither\fR" 4
.IX Item "list_dither"
List available dither options related ta tha argument.
Da argument must be one of \f(CW\*(C`algorithms\*(C'\fR, \f(CW\*(C`antialiases\*(C'\fR,
\&\f(CW\*(C`charsets\*(C'\fR, \f(CW\*(C`colors\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Da followin command shows tha \fBffmpeg\fR output be an
\&\s-1CACA\s0 window, forcin its size ta 80x25:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vcodec rawvideo \-pix_fmt rgb24 \-window_size 80x25 \-f caca \-
.Ve
.IP "\(bu" 4
Show tha list of available drivers n' exit:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-pix_fmt rgb24 \-f caca \-list_drivers legit \-
.Ve
.IP "\(bu" 4
Show tha list of available dither flavas n' exit:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-pix_fmt rgb24 \-f caca \-list_dither flavas \-
.Ve
.SS "fbdev"
.IX Subsection "fbdev"
Linux framebuffer output device.
.PP
Da Linux framebuffer be a graphic hardware-independent abstraction
layer ta show graphics on a cold-ass lil computa monitor, typically on the
console. Well shiiiit, it be accessed all up in a gangbangin' file thang node, usually
\&\fI/dev/fb0\fR.
.PP
For mo' detailed shiznit read tha file
\&\fIDocumentation/fb/framebuffer.txt\fR included up in tha Linux source tree.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBxoffset\fR" 4
.IX Item "xoffset"
.PD 0
.IP "\fByoffset\fR" 4
.IX Item "yoffset"
.PD
Set x/y coordinizzle of top left corner n' shit. Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Play a gangbangin' file on framebuffer thang \fI/dev/fb0\fR.
Required pixel format dependz on current framebuffer settings.
.PP
.Vb 1
\&        ffmpeg \-re \-i INPUT \-vcodec rawvideo \-pix_fmt bgra \-f fbdev /dev/fb0
.Ve
.PP
See also <\fBhttp://linux\-fbdev.sourceforge.net/\fR>, n' \fIfbset\fR\|(1).
.SS "oss"
.IX Subsection "oss"
\&\s-1OSS \s0(Open Sound System) output device.
.SS "pulse"
.IX Subsection "pulse"
PulseAudio output device.
.PP
To enable dis output thang you need ta configure FFmpeg wit \f(CW\*(C`\-\-enable\-libpulse\*(C'\fR.
.PP
Mo' shiznit bout PulseAudio can be found on <\fBhttp://www.pulseaudio.org\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBserver\fR" 4
.IX Item "server"
Connect ta a specific PulseAudio server, specified by a \s-1IP\s0 address.
Default server is used when not provided.
.IP "\fBname\fR" 4
.IX Item "name"
Specify tha application name PulseAudio will use when showin actizzle clients,
by default it is tha \f(CW\*(C`LIBAVFORMAT_IDENT\*(C'\fR string.
.IP "\fBstream_name\fR" 4
.IX Item "stream_name"
Specify tha stream name PulseAudio will use when showin actizzle streams,
by default it is set ta tha specified output name.
.IP "\fBdevice\fR" 4
.IX Item "device"
Specify tha thang ta use. Default thang is used when not provided.
List of output devices can be obtained wit command \fBpactl list sinks\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Play a gangbangin' file on default thang on default server:
.PP
.Vb 1
\&        ffmpeg  \-i INPUT \-f pulse "stream name"
.Ve
.SS "sdl"
.IX Subsection "sdl"
\&\s-1SDL \s0(Simple DirectMedia Layer) output device.
.PP
This output thang allows ta show a vizzle stream up in a \s-1SDL\s0
window. Only one \s-1SDL\s0 window be allowed per application, so you can
have only one instizzle of dis output thang up in a application.
.PP
To enable dis output thang you need libsdl installed on yo' system
when configurin yo' build.
.PP
For mo' shiznit bout \s-1SDL,\s0 check:
<\fBhttp://www.libsdl.org/\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha \s-1SDL\s0 window title, if not specified default ta tha filename
specified fo' tha output device.
.IP "\fBicon_title\fR" 4
.IX Item "icon_title"
Set tha name of tha iconified \s-1SDL\s0 window, if not specified it is set
to tha same value of \fIwindow_title\fR.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha \s-1SDL\s0 window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation.
If not specified it defaults ta tha size of tha input vizzle,
downscaled accordin ta tha aspect ratio.
.IP "\fBwindow_fullscreen\fR" 4
.IX Item "window_fullscreen"
Set fullscreen mode when non-zero value is provided.
Zero be a thugged-out default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Da followin command shows tha \fBffmpeg\fR output be an
\&\s-1SDL\s0 window, forcin its size ta tha qcif format:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-vcodec rawvideo \-pix_fmt yuv420p \-window_size qcif \-f sdl "SDL output"
.Ve
.SS "sndio"
.IX Subsection "sndio"
sndio audio output device.
.SS "xv"
.IX Subsection "xv"
\&\s-1XV \s0(XVideo) output device.
.PP
This output thang allows ta show a vizzle stream up in a X Window System
window.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdisplay_name\fR" 4
.IX Item "display_name"
Specify tha hardware display name, which determines tha display and
communications domain ta be used.
.Sp
Da display name or \s-1DISPLAY\s0 environment variable can be a strang in
the format \fIhostname\fR[:\fInumber\fR[.\fIscreen_number\fR]].
.Sp
\&\fIhostname\fR specifies tha name of tha host machine on which the
display is physically attached. Y'all KNOW dat shit, muthafucka! \fInumber\fR specifies tha number of
the display server on dat host machine. \fIscreen_number\fR specifies
the screen ta be used on dat server.
.Sp
If unspecified, it defaults ta tha value of tha \s-1DISPLAY\s0 environment
variable.
.Sp
For example, \f(CW\*(C`dual\-headed:0.1\*(C'\fR would specify screen 1 of display
0 on tha machine named ``dual\-headed''.
.Sp
Peep tha X11 justification fo' mo' detailed shiznit bout the
display name format.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha pimped window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation. I aint talkin' bout chicken n' gravy biatch. If not
specified it defaults ta tha size of tha input vizzle.
.IP "\fBwindow_x\fR" 4
.IX Item "window_x"
.PD 0
.IP "\fBwindow_y\fR" 4
.IX Item "window_y"
.PD
Set tha X n' Y window offsets fo' tha pimped window. They is both
set ta 0 by default. Da joints may be ignored by tha window manager.
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha window title, if not specified default ta tha filename
specified fo' tha output device.
.PP
For mo' shiznit bout XVideo peep <\fBhttp://www.x.org/\fR>.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Decode, display n' encode vizzle input wit \fBffmpeg\fR at the
same time:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT OUTPUT \-f xv display
.Ve
.IP "\(bu" 4
Decode n' display tha input vizzle ta multiple X11 windows:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-f xv aiiight \-vf negate \-f xv negated
.Ve
.SH "RESAMPLER OPTIONS"
.IX Header "RESAMPLER OPTIONS"
Da audio resampla supports tha followin named options.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, \fIoption\fR=\fIvalue\fR fo' tha aresample filter,
by settin tha value explicitly up in the
\&\f(CW\*(C`SwrContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0 for
programmatic use.
.IP "\fBich, in_channel_count\fR" 4
.IX Item "ich, in_channel_count"
Set tha number of input channels. Default value is 0. Right back up in yo muthafuckin ass. Settin this
value aint mandatory if tha correspondin channel layout
\&\fBin_channel_layout\fR is set.
.IP "\fBoch, out_channel_count\fR" 4
.IX Item "och, out_channel_count"
Set tha number of output channels. Default value is 0. Right back up in yo muthafuckin ass. Settin this
value aint mandatory if tha correspondin channel layout
\&\fBout_channel_layout\fR is set.
.IP "\fBuch, used_channel_count\fR" 4
.IX Item "uch, used_channel_count"
Set tha number of used input channels. Default value is 0. This option is
only used fo' special remapping.
.IP "\fBisr, in_sample_rate\fR" 4
.IX Item "isr, in_sample_rate"
Set tha input sample rate. Default value is 0.
.IP "\fBosr, out_sample_rate\fR" 4
.IX Item "osr, out_sample_rate"
Set tha output sample rate. Default value is 0.
.IP "\fBisf, in_sample_fmt\fR" 4
.IX Item "isf, in_sample_fmt"
Specify tha input sample format. Well shiiiit, it is set by default ta \f(CW\*(C`none\*(C'\fR.
.IP "\fBosf, out_sample_fmt\fR" 4
.IX Item "osf, out_sample_fmt"
Specify tha output sample format. Well shiiiit, it is set by default ta \f(CW\*(C`none\*(C'\fR.
.IP "\fBtsf, internal_sample_fmt\fR" 4
.IX Item "tsf, internal_sample_fmt"
Set tha internal sample format. Default value is \f(CW\*(C`none\*(C'\fR.
This will automatically be chosen when it aint explicitly set.
.IP "\fBicl, in_channel_layout\fR" 4
.IX Item "icl, in_channel_layout"
.PD 0
.IP "\fBocl, out_channel_layout\fR" 4
.IX Item "ocl, out_channel_layout"
.PD
Set tha input/output channel layout.
.Sp
See tha Channel Layout section up in tha \fIffmpeg\-utils\fR\|(1) manual
for tha required syntax.
.IP "\fBclev, center_mix_level\fR" 4
.IX Item "clev, center_mix_level"
Set tha centa mix level. Well shiiiit, it aint nuthin but a value expressed up in deciBel, n' must be
in tha interval [\-32,32].
.IP "\fBslev, surround_mix_level\fR" 4
.IX Item "slev, surround_mix_level"
Set tha surround mix level. Well shiiiit, it aint nuthin but a value expressed up in deciBel, n' must
be up in tha interval [\-32,32].
.IP "\fBlfe_mix_level\fR" 4
.IX Item "lfe_mix_level"
Set \s-1LFE\s0 mix tha fuck into non \s-1LFE\s0 level. Well shiiiit, it is used when there be a \s-1LFE\s0 input but no
\&\s-1LFE\s0 output. Well shiiiit, it aint nuthin but a value expressed up in deciBel, n' must
be up in tha interval [\-32,32].
.IP "\fBrmvol, rematrix_volume\fR" 4
.IX Item "rmvol, rematrix_volume"
Set rematrix volume. Default value is 1.0.
.IP "\fBrematrix_maxval\fR" 4
.IX Item "rematrix_maxval"
Set maximum output value fo' rematrixing.
This can be used ta prevent clippin vs. preventin volumn reduction
A value of 1.0 prevents cliping.
.IP "\fBflags, swr_flags\fR" 4
.IX Item "flags, swr_flags"
Set flags used by tha converter n' shit. Default value is 0.
.Sp
It supports tha followin individual flags:
.RS 4
.IP "\fBres\fR" 4
.IX Item "res"
force resampling, dis flag forces resamplin ta be used even when the
input n' output sample rates match.
.RE
.RS 4
.RE
.IP "\fBdither_scale\fR" 4
.IX Item "dither_scale"
Set tha dither scale. Default value is 1.
.IP "\fBdither_method\fR" 4
.IX Item "dither_method"
Set dither method. Y'all KNOW dat shit, muthafucka! Default value is 0.
.Sp
Supported joints:
.RS 4
.IP "\fBrectangular\fR" 4
.IX Item "rectangular"
select rectangular dither
.IP "\fBtriangular\fR" 4
.IX Item "triangular"
select triangular dither
.IP "\fBtriangular_hp\fR" 4
.IX Item "triangular_hp"
select triangular dither wit high pass
.IP "\fBlipshitz\fR" 4
.IX Item "lipshitz"
select lipshitz noise shapin dither
.IP "\fBshibata\fR" 4
.IX Item "shibata"
select shibata noise shapin dither
.IP "\fBlow_shibata\fR" 4
.IX Item "low_shibata"
select low shibata noise shapin dither
.IP "\fBhigh_shibata\fR" 4
.IX Item "high_shibata"
select high shibata noise shapin dither
.IP "\fBf_weighted\fR" 4
.IX Item "f_weighted"
select f\-weighted noise shapin dither
.IP "\fBmodified_e_weighted\fR" 4
.IX Item "modified_e_weighted"
select modified-e-weighted noise shapin dither
.IP "\fBimproved_e_weighted\fR" 4
.IX Item "improved_e_weighted"
select improved-e-weighted noise shapin dither
.RE
.RS 4
.RE
.IP "\fBresampler\fR" 4
.IX Item "resampler"
Set resamplin engine. Default value is swr.
.Sp
Supported joints:
.RS 4
.IP "\fBswr\fR" 4
.IX Item "swr"
select tha natizzle \s-1SW\s0 Resampler; filta options precision n' cheby is not
applicable up in dis case.
.IP "\fBsoxr\fR" 4
.IX Item "soxr"
select tha SoX Resampla (where available); compensation, n' filta options
filter_size, phase_shift, filter_type & kaiser_beta, is not applicable up in this
case.
.RE
.RS 4
.RE
.IP "\fBfilter_size\fR" 4
.IX Item "filter_size"
For swr only, set resamplin filta size, default value is 32.
.IP "\fBphase_shift\fR" 4
.IX Item "phase_shift"
For swr only, set resamplin phase shift, default value is 10, n' must be in
the interval [0,30].
.IP "\fBlinear_interp\fR" 4
.IX Item "linear_interp"
Use Linear Interpolation if set ta 1, default value is 0.
.IP "\fBcutoff\fR" 4
.IX Item "cutoff"
Set cutoff frequency (swr: 6dB point; soxr: 0dB point) ratio; must be a gangbangin' float
value between 0 n' 1.  Default value is 0.97 wit swr, n' 0.91 wit soxr
(which, wit a sample-rate of 44100, preserves tha entire audio crew ta 20kHz).
.IP "\fBprecision\fR" 4
.IX Item "precision"
For soxr only, tha precision up in bits ta which tha resampled signal will be
calculated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da default value of 20 (which, wit suitable dithering, is
appropriate fo' a thugged-out destination bit-depth of 16) gives SoXz 'High Quality'; a
value of 28 gives SoXz 'Straight-up High Quality'.
.IP "\fBcheby\fR" 4
.IX Item "cheby"
For soxr only, selects passband rolloff none (Chebyshev) & higher-precision
approximation fo' 'irrational' ratios. Default value is 0.
.IP "\fBasync\fR" 4
.IX Item "async"
For swr only, simple 1 parameta audio sync ta timestamps rockin stretching,
squeezing, fillin n' trimming. Right back up in yo muthafuckin ass. Settin dis ta 1 will enable fillin and
trimming, larger joints represent tha maximum amount up in samplez dat tha data
may be stretched or squeezed fo' each second.
Default value is 0, thus no compensation be applied ta make tha samplez match
the audio timestamps.
.IP "\fBfirst_pts\fR" 4
.IX Item "first_pts"
For swr only, assume tha straight-up original gangsta pts should be dis value. Da time unit is 1 / sample rate.
This allows fo' padding/trimmin all up in tha start of stream. By default, no
assumption is made bout tha straight-up original gangsta framez expected pts, so no paddin or
trimmin is done. For example, dis could be set ta 0 ta pad tha beginnin with
silence if a audio stream starts afta tha vizzle stream or ta trim any samples
with a wack pts cuz of encoder delay.
.IP "\fBmin_comp\fR" 4
.IX Item "min_comp"
For swr only, set tha minimum difference between timestamps n' audio data (in
seconds) ta trigger stretching/squeezing/fillin or trimmin of the
data ta make it match tha timestamps. Da default is that
stretching/squeezing/fillin n' trimmin is disabled
(\fBmin_comp\fR = \f(CW\*(C`FLT_MAX\*(C'\fR).
.IP "\fBmin_hard_comp\fR" 4
.IX Item "min_hard_comp"
For swr only, set tha minimum difference between timestamps n' audio data (in
seconds) ta trigger adding/droppin samplez ta make it match the
timestamps.  This option effectively be a threshold ta select between
hard (trim/fill) n' soft (squeeze/stretch) compensation. I aint talkin' bout chicken n' gravy biatch. Note that
all compensation is by default disabled all up in \fBmin_comp\fR.
Da default is 0.1.
.IP "\fBcomp_duration\fR" 4
.IX Item "comp_duration"
For swr only, set duration (in seconds) over which data is stretched/squeezed
to make it match tha timestamps. Must be a non-negatizzle double float value,
default value is 1.0.
.IP "\fBmax_soft_comp\fR" 4
.IX Item "max_soft_comp"
For swr only, set maximum factor by which data is stretched/squeezed ta make it
match tha timestamps. Must be a non-negatizzle double float value, default value
is 0.
.IP "\fBmatrix_encoding\fR" 4
.IX Item "matrix_encoding"
Select matrixed stereo encoding.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
select none
.IP "\fBdolby\fR" 4
.IX Item "dolby"
select Dolby
.IP "\fBdplii\fR" 4
.IX Item "dplii"
select Dolby Pro Logic \s-1II\s0
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`none\*(C'\fR.
.RE
.IP "\fBfilter_type\fR" 4
.IX Item "filter_type"
For swr only, select resamplin filta type. This only affects resampling
operations.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBcubic\fR" 4
.IX Item "cubic"
select cubic
.IP "\fBblackman_nuttall\fR" 4
.IX Item "blackman_nuttall"
select Blackman Nuttall Windowed Sinc
.IP "\fBkaiser\fR" 4
.IX Item "kaiser"
select Kaiser Windowed Sinc
.RE
.RS 4
.RE
.IP "\fBkaiser_beta\fR" 4
.IX Item "kaiser_beta"
For swr only, set Kaiser Window Beta value. Must be a integer up in the
interval [2,16], default value is 9.
.IP "\fBoutput_sample_bits\fR" 4
.IX Item "output_sample_bits"
For swr only, set number of used output sample bits fo' dithering. Must be a integer up in the
interval [0,64], default value is 0, which means it aint used.
.SH "SCALER OPTIONS"
.IX Header "SCALER OPTIONS"
Da vizzle scala supports tha followin named options.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools. For programmatic use, they can be set explicitly up in the
\&\f(CW\*(C`SwsContext\*(C'\fR options or all up in tha \fIlibavutil/opt.h\fR \s-1API.\s0
.IP "\fBsws_flags\fR" 4
.IX Item "sws_flags"
Set tha scala flags. This be also used ta set tha scaling
algorithm. Only a single algorithm should be selected.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBfast_bilinear\fR" 4
.IX Item "fast_bilinear"
Select fast bilinear scalin algorithm.
.IP "\fBbilinear\fR" 4
.IX Item "bilinear"
Select bilinear scalin algorithm.
.IP "\fBbicubic\fR" 4
.IX Item "bicubic"
Select bicubic scalin algorithm.
.IP "\fBexperimental\fR" 4
.IX Item "experimental"
Select experimenstrual scalin algorithm.
.IP "\fBneighbor\fR" 4
.IX Item "neighbor"
Select nearest neighbor rescalin algorithm.
.IP "\fBarea\fR" 4
.IX Item "area"
Select averagin area rescalin algorithm.
.IP "\fBbicublin\fR" 4
.IX Item "bicublin"
Select bicubic scalin algorithm fo' tha luma component, bilinear for
chroma components.
.IP "\fBgauss\fR" 4
.IX Item "gauss"
Select Gaussian rescalin algorithm.
.IP "\fBsinc\fR" 4
.IX Item "sinc"
Select sinc rescalin algorithm.
.IP "\fBlanczos\fR" 4
.IX Item "lanczos"
Select lanczos rescalin algorithm.
.IP "\fBspline\fR" 4
.IX Item "spline"
Select natural bicubic spline rescalin algorithm.
.IP "\fBprint_info\fR" 4
.IX Item "print_info"
Enable printing/debug logging.
.IP "\fBaccurate_rnd\fR" 4
.IX Item "accurate_rnd"
Enable accurate rounding.
.IP "\fBfull_chroma_int\fR" 4
.IX Item "full_chroma_int"
Enable full chroma interpolation.
.IP "\fBfull_chroma_inp\fR" 4
.IX Item "full_chroma_inp"
Select full chroma input.
.IP "\fBbitexact\fR" 4
.IX Item "bitexact"
Enable bitexact output.
.RE
.RS 4
.RE
.IP "\fBsrcw\fR" 4
.IX Item "srcw"
Set source width.
.IP "\fBsrch\fR" 4
.IX Item "srch"
Set source height.
.IP "\fBdstw\fR" 4
.IX Item "dstw"
Set destination width.
.IP "\fBdsth\fR" 4
.IX Item "dsth"
Set destination height.
.IP "\fBsrc_format\fR" 4
.IX Item "src_format"
Set source pixel format (must be expressed as a integer).
.IP "\fBdst_format\fR" 4
.IX Item "dst_format"
Set destination pixel format (must be expressed as a integer).
.IP "\fBsrc_range\fR" 4
.IX Item "src_range"
Select source range.
.IP "\fBdst_range\fR" 4
.IX Item "dst_range"
Select destination range.
.IP "\fBparam0, param1\fR" 4
.IX Item "param0, param1"
Set scalin algorithm parameters. Da specified joints is specific of
some scalin algorithms n' ignored by others. Da specified joints
are floatin point number joints.
.IP "\fBsws_dither\fR" 4
.IX Item "sws_dither"
Set tha ditherin algorithm fo' realz. Accepts one of tha following
values. Default value is \fBauto\fR.
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
automatic chizzle
.IP "\fBnone\fR" 4
.IX Item "none"
no dithering
.IP "\fBbayer\fR" 4
.IX Item "bayer"
bayer dither
.IP "\fBed\fR" 4
.IX Item "ed"
error diffusion dither
.RE
.RS 4
.RE
.SH "FILTERING INTRODUCTION"
.IX Header "FILTERING INTRODUCTION"
Filterin up in FFmpeg is enabled all up in tha libavfilta library.
.PP
In libavfilter, a gangbangin' filta can have multiple inputs n' multiple
outputs.
To illustrate tha sortz of thangs dat is possible, we consider the
followin filtergraph.
.PP
.Vb 5
\&                        [main]
\&        input \-\-> split \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> overlay \-\-> output
\&                    |                             ^
\&                    |[tmp]                  [flip]|
\&                    +\-\-\-\-\-> crop \-\-> vflip \-\-\-\-\-\-\-+
.Ve
.PP
This filtergraph splits tha input stream up in two streams, sendz one
stream all up in tha crop filta n' tha vflip filta before mergin it
back wit tha other stream by overlayin it on top. Yo ass can use the
followin command ta bust dis:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-vf "split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2" OUTPUT
.Ve
.PP
Da result is ghon be dat up in output tha top half of tha vizzle is mirrored
onto tha bottom half.
.PP
Filtas up in tha same linear chain is separated by commas, n' distinct
linear chainz of filtas is separated by semicolons. In our example,
\&\fIcrop,vflip\fR is up in one linear chain, \fIsplit\fR and
\&\fIoverlay\fR is separately up in another n' shit. Da points where tha linear
chains join is labelled by names enclosed up in square brackets, n' you can put dat on yo' toast. In the
example, tha split filta generates two outputs dat is associated to
the labels \fI[main]\fR n' \fI[tmp]\fR.
.PP
Da stream busted ta tha second output of \fIsplit\fR, labelled as
\&\fI[tmp]\fR, is processed all up in tha \fIcrop\fR filter, which crops
away tha lower half part of tha vizzle, n' then vertically flipped. Y'all KNOW dat shit, muthafucka! The
\&\fIoverlay\fR filta takes up in input tha straight-up original gangsta unchanged output of the
split filta (which was labelled as \fI[main]\fR), n' overlay on its
lower half tha output generated by tha \fIcrop,vflip\fR filterchain.
.PP
Some filtas take up in input a list of parameters: they is specified
afta tha filta name n' a equal sign, n' is separated from each other
by a cold-ass lil colon.
.PP
There exist so-called \fIsource filters\fR dat aint gots an
audio/video input, n' \fIsink filters\fR dat aint gonna have audio/video
output.
.SH "GRAPH"
.IX Header "GRAPH"
Da \fIgraph2dot\fR program included up in tha FFmpeg \fItools\fR
directory can be used ta parse a gangbangin' filtergraph description n' issue a
correspondin textual representation up in tha dot language.
.PP
Invoke tha command:
.PP
.Vb 1
\&        graph2dot \-h
.Ve
.PP
to peep how tha fuck ta use \fIgraph2dot\fR.
.PP
Yo ass can then pass tha dot description ta tha \fIdot\fR program (from
the graphviz suite of programs) n' obtain a graphical representation
of tha filtergraph.
.PP
For example tha sequence of commands:
.PP
.Vb 4
\&        echo <GRAPH_DESCRIPTION> | \e
\&        tools/graph2dot \-o graph.tmp && \e
\&        dot \-Tpng graph.tmp \-o graph.png && \e
\&        display graph.png
.Ve
.PP
can be used ta create n' display a image representin tha graph
busted lyrics bout by tha \fI\s-1GRAPH_DESCRIPTION\s0\fR string. Note dat dis strang must be
a complete self-contained graph, wit its inputs n' outputs explicitly defined.
For example if yo' command line iz of tha form:
.PP
.Vb 1
\&        ffmpeg \-i infile \-vf scale=640:360 outfile
.Ve
.PP
your \fI\s-1GRAPH_DESCRIPTION\s0\fR strang will need ta be of tha form:
.PP
.Vb 1
\&        nullsrc,scale=640:360,nullsink
.Ve
.PP
you may also need ta set tha \fInullsrc\fR parametas n' add a \fIformat\fR
filta up in order ta simulate a specific input file.
.SH "FILTERGRAPH DESCRIPTION"
.IX Header "FILTERGRAPH DESCRIPTION"
A filtergraph be a gangbangin' finger-lickin' pimped up graph of connected filters. Well shiiiit, it can contain
cycles, n' there can be multiple links between a pair of
filters. Each link has one input pad on one side connectin it ta one
filta from which it takes its input, n' one output pad on tha other
side connectin it ta tha one filta acceptin its output.
.PP
Each filta up in a gangbangin' filtergraph be a instizzle of a gangbangin' filta class
registered up in tha application, which defines tha features n' the
number of input n' output padz of tha filter.
.PP
A filta wit no input padz is called a \*(L"source\*(R", a gangbangin' filta wit no
output padz is called a \*(L"sink\*(R".
.SS "Filtergraph syntax"
.IX Subsection "Filtergraph syntax"
A filtergraph can be represented rockin a textual representation, which is
recognized by tha \fB\-filter\fR/\fB\-vf\fR n' \fB\-filter_complex\fR
options up in \fBffmpeg\fR n' \fB\-vf\fR up in \fBffplay\fR, n' by the
\&\f(CW\*(C`avfilter_graph_parse()\*(C'\fR/\f(CW\*(C`avfilter_graph_parse2()\*(C'\fR function defined in
\&\fIlibavfilter/avfilter.h\fR.
.PP
A filterchain consistz of a sequence of connected filters, each one
connected ta tha previous one up in tha sequence fo' realz. A filterchain is
represented by a list of \*(L",\*(R"\-separated filta descriptions.
.PP
A filtergraph consistz of a sequence of filterchains fo' realz. A sequence of
filterchains is represented by a list of \*(L";\*(R"\-separated filterchain
descriptions.
.PP
A filta is represented by a strang of tha form:
[\fIin_link_1\fR]...[\fIin_link_N\fR]\fIfilter_name\fR=\fIarguments\fR[\fIout_link_1\fR]...[\fIout_link_M\fR]
.PP
\&\fIfilter_name\fR is tha name of tha filta class of which the
busted lyrics bout filta be a instizzle of, n' has ta be tha name of one of
the filta classes registered up in tha program.
Da name of tha filta class is optionally followed by a string
"=\fIarguments\fR".
.PP
\&\fIarguments\fR be a strang which gotz nuff tha parametas used to
initialize tha filta instance. Well shiiiit, it may have one of tha followin forms:
.IP "\(bu" 4
A ':'\-separated list of \fIkey=value\fR pairs.
.IP "\(bu" 4
A ':'\-separated list of \fIvalue\fR. In dis case, tha keys is assumed ta be
the option names up in tha order they is declared. Y'all KNOW dat shit, muthafucka! E.g. tha \f(CW\*(C`fade\*(C'\fR filter
declares three options up in dis order \*(-- \fBtype\fR, \fBstart_frame\fR and
\&\fBnb_frames\fR. Then tha parameta list \fIin:0:30\fR means dat tha value
\&\fIin\fR be assigned ta tha option \fBtype\fR, \fI0\fR to
\&\fBstart_frame\fR n' \fI30\fR ta \fBnb_frames\fR.
.IP "\(bu" 4
A ':'\-separated list of mixed direct \fIvalue\fR n' long \fIkey=value\fR
pairs. Da direct \fIvalue\fR must precede tha \fIkey=value\fR pairs, and
follow tha same constraints order of tha previous point. Da following
\&\fIkey=value\fR pairs can be set up in any preferred order.
.PP
If tha option value itself be a list of shit (e.g. tha \f(CW\*(C`format\*(C'\fR filter
takes a list of pixel formats), tha shit up in tha list is probably separated by
\&'|'.
.PP
Da list of arguments can be quoted rockin tha characta \*(L"'\*(R" as initial
and endin mark, n' tha characta '\e' fo' escapin tha characters
within tha quoted text; otherwise tha argument strang is considered
terminated when tha next special characta (belongin ta tha set
\&\*(L"[]=;,\*(R") is encountered.
.PP
Da name n' argumentz of tha filta is optionally preceded and
followed by a list of link labels.
A link label allows ta name a link n' associate it ta a gangbangin' filta output
or input pad. Y'all KNOW dat shit, muthafucka! Da precedin labels \fIin_link_1\fR
\&... \fIin_link_N\fR, is associated ta tha filta input pads,
the followin labels \fIout_link_1\fR ... \fIout_link_M\fR, are
associated ta tha output pads.
.PP
When two link labels wit tha same name is found up in the
filtergraph, a link between tha correspondin input n' output pad is
created.
.PP
If a output pad aint labelled, it is linked by default ta tha first
unlabelled input pad of tha next filta up in tha filterchain.
For example up in tha filterchain:
.PP
.Vb 1
\&        nullsrc, split[L1], [L2]overlay, nullsink
.Ve
.PP
the split filta instizzle has two output pads, n' tha overlay filter
instizzle two input pads. Da first output pad of split is labelled
\&\*(L"L1\*(R", tha straight-up original gangsta input pad of overlay is labelled \*(L"L2\*(R", n' tha second
output pad of split is linked ta tha second input pad of overlay,
which is both unlabelled.
.PP
In a cold-ass lil complete filterchain all tha unlabelled filta input n' output
padz must be connected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A filtergraph is considered valid if all the
filta input n' output padz of all tha filterchains is connected.
.PP
Libavfilta will automatically bang scale filtas where format
conversion is required. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is possible ta specify swscale flags
for dem automatically banged scalaz by prepending
\&\f(CW\*(C`sws_flags=\f(CIflags\f(CW;\*(C'\fR
to tha filtergraph description.
.PP
Follows a \s-1BNF\s0 description fo' tha filtergraph syntax:
.PP
.Vb 7
\&        <NAME>             ::= sequence of alphanumeric charactas n' \*(Aq_\*(Aq
\&        <LINKLABEL>        ::= "[" <NAME> "]"
\&        <LINKLABELS>       ::= <LINKLABEL> [<LINKLABELS>]
\&        <FILTER_ARGUMENTS> ::= sequence of chars (eventually quoted)
\&        <FILTER>           ::= [<LINKLABELS>] <NAME> ["=" <FILTER_ARGUMENTS>] [<LINKLABELS>]
\&        <FILTERCHAIN>      ::= <FILTER> [,<FILTERCHAIN>]
\&        <FILTERGRAPH>      ::= [sws_flags=<flags>;] <FILTERCHAIN> [;<FILTERGRAPH>]
.Ve
.SS "Notes on filtergraph escaping"
.IX Subsection "Notes on filtergraph escaping"
Some filta arguments require tha use of special characters, typically
\&\f(CW\*(C`:\*(C'\fR ta separate key=value pairs up in a named options list. In this
case tha user should big-ass up a gangbangin' first level escapin when specifying
the filta arguments, n' you can put dat on yo' toast. For example, consider tha followin literal
strin ta be embedded up in tha drawtext filta arguments:
.PP
.Vb 1
\&        dis be a \*(Aqstring\*(Aq: may contain one, or more, special characters
.Ve
.PP
Since \f(CW\*(C`:\*(C'\fR is special fo' tha filta arguments syntax, it needz to
be escaped, so you get:
.PP
.Vb 1
\&        text=this be a \e\*(Aqstring\e\*(Aq\e: may contain one, or more, special characters
.Ve
.PP
A second level of escapin is required when embeddin tha filter
arguments up in a gangbangin' filtergraph description, up in order ta escape all the
filtergraph special characters. Thus tha example above becomes:
.PP
.Vb 1
\&        drawtext=text=this be a \e\e\e\*(Aqstring\e\e\e\*(Aq\e\e: may contain one\e, or more\e, special characters
.Ve
.PP
Finally a additionizzle level of escapin may be needed when freestylin the
filtergraph description up in a gangbangin' finger-lickin' dirty-ass shell command, which dependz on the
escapin rulez of tha adopted shell. For example, assumin that
\&\f(CW\*(C`\e\*(C'\fR is special n' need ta be escaped wit another \f(CW\*(C`\e\*(C'\fR, the
previous strang will finally result in:
.PP
.Vb 1
\&        \-vf "drawtext=text=this be a \e\e\e\e\e\e\*(Aqstring\e\e\e\e\e\e\*(Aq\e\e\e\e: may contain one\e\e, or more\e\e, special characters"
.Ve
.PP
Sometimes, it might be mo' convenient ta employ quotin up in place of
escaping. For example tha string:
.PP
.Vb 1
\&        Caesar: tu quoque, Brute, fili mi
.Ve
.PP
Can be quoted up in tha filta arguments as:
.PP
.Vb 1
\&        text=\*(AqCaesar: tu quoque, Brute, fili mi\*(Aq
.Ve
.PP
And finally banged up in a gangbangin' filtergraph like:
.PP
.Vb 1
\&        drawtext=text=\e\*(AqCaesar: tu quoque\e, Brute\e, fili mi\e\*(Aq
.Ve
.PP
See tha ``Quotin n' escaping'' section up in tha ffmpeg-utils manual
for mo' shiznit bout tha escapin n' quotin rulez adopted by
FFmpeg.
.SH "TIMELINE EDITING"
.IX Header "TIMELINE EDITING"
Some filtas support a generic \fBenable\fR option. I aint talkin' bout chicken n' gravy biatch. For tha filters
supportin timeline editing, dis option can be set ta a expression which is
evaluated before bustin  a gangbangin' frame ta tha filter n' shit. If tha evaluation is non-zero,
the filta is ghon be enabled, otherwise tha frame is ghon be busted unchanged ta the
next filta up in tha filtergraph.
.PP
Da expression accepts tha followin joints:
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.PP
Additionally, these filtas support a \fBenable\fR command dat can be used
to re-define tha expression.
.PP
Like any other filterin option, tha \fBenable\fR option bigs up tha same
rules.
.PP
For example, ta enable a funky-ass blur filta (smartblur) from 10 secondz ta 3
minutes, n' a cold-ass lil curves filta startin at 3 seconds:
.PP
.Vb 2
\&        smartblur = enable=\*(Aqbetween(t,10,3*60)\*(Aq,
\&        curves    = enable=\*(Aqgte(t,3)\*(Aq : preset=cross_process
.Ve
.SH "AUDIO FILTERS"
.IX Header "AUDIO FILTERS"
When you configure yo' FFmpeg build, you can disable any of the
existin filtas rockin \f(CW\*(C`\-\-disable\-filters\*(C'\fR.
Da configure output will show tha audio filtas included up in your
build.
.PP
Below be a thugged-out description of tha currently available audio filters.
.SS "aconvert"
.IX Subsection "aconvert"
Convert tha input audio format ta tha specified formats.
.PP
\&\fIThis filta is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use aformat\fR instead.
.PP
Da filta accepts a strang of tha form:
"\fIsample_format\fR:\fIchannel_layout\fR".
.PP
\&\fIsample_format\fR specifies tha sample format, n' can be a strang or the
correspondin numeric value defined up in \fIlibavutil/samplefmt.h\fR. Use 'p'
suffix fo' a planar sample format.
.PP
\&\fIchannel_layout\fR specifies tha channel layout, n' can be a string
or tha correspondin number value defined up in \fIlibavutil/channel_layout.h\fR.
.PP
Da special parameta \*(L"auto\*(R", signifies dat tha filta will
automatically select tha output format dependin on tha output filter.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert input ta float, planar, stereo:
.Sp
.Vb 1
\&        aconvert=fltp:stereo
.Ve
.IP "\(bu" 4
Convert input ta unsigned 8\-bit, automatically select up channel layout:
.Sp
.Vb 1
\&        aconvert=u8:auto
.Ve
.SS "adelay"
.IX Subsection "adelay"
Delay one or mo' audio channels.
.PP
Samplez up in delayed channel is filled wit silence.
.PP
Da filta accepts tha followin option:
.IP "\fBdelays\fR" 4
.IX Item "delays"
Set list of delays up in millisecondz fo' each channel separated by '|'.
At least one delay pimped outa than 0 should be provided.
Unused delays is ghon be silently ignored. Y'all KNOW dat shit, muthafucka! If number of given delays is
smalla than number of channels all remainin channels aint gonna be delayed.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Delay first channel by 1.5 seconds, tha third channel by 0.5 secondz n' leave
the second channel (and any other channels dat may be present) unchanged.
.Sp
.Vb 1
\&        adelay=1500:0:500
.Ve
.SS "aecho"
.IX Subsection "aecho"
Apply echoin ta tha input audio.
.PP
Echoes is reflected sound n' can occur naturally amongst mountains
(and sometimes big-ass buildings) when rappin' or shouting; digital echo
effects emulate dis behaviour n' is often used ta help fill up the
sound of a single instrument or vocal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da time difference between the
original gangsta signal n' tha reflection is tha \f(CW\*(C`delay\*(C'\fR, n' the
loudnizz of tha reflected signal is tha \f(CW\*(C`decay\*(C'\fR.
Multiple echoes can have different delays n' decays.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBin_gain\fR" 4
.IX Item "in_gain"
Set input bust of reflected signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default is \f(CW0.6\fR.
.IP "\fBout_gain\fR" 4
.IX Item "out_gain"
Set output bust of reflected signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default is \f(CW0.3\fR.
.IP "\fBdelays\fR" 4
.IX Item "delays"
Set list of time intervals up in millisecondz between original gangsta signal n' reflections
separated by '|' fo' realz. Allowed range fo' each \f(CW\*(C`delay\*(C'\fR is \f(CW\*(C`(0 \- 90000.0]\*(C'\fR.
Default is \f(CW1000\fR.
.IP "\fBdecays\fR" 4
.IX Item "decays"
Set list of loudnessez of reflected signals separated by '|'.
Allowed range fo' each \f(CW\*(C`decay\*(C'\fR is \f(CW\*(C`(0 \- 1.0]\*(C'\fR.
Default is \f(CW0.5\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Make it sound as if there be twice as nuff instruments as is straight-up playing:
.Sp
.Vb 1
\&        aecho=0.8:0.88:60:0.4
.Ve
.IP "\(bu" 4
If delay is straight-up short, then it sound like a (metallic) robot playin music:
.Sp
.Vb 1
\&        aecho=0.8:0.88:6:0.4
.Ve
.IP "\(bu" 4
A longer delay will sound like a open air gangbang up in tha mountains:
.Sp
.Vb 1
\&        aecho=0.8:0.9:1000:0.3
.Ve
.IP "\(bu" 4
Same as above but wit one mo' mountain:
.Sp
.Vb 1
\&        aecho=0.8:0.9:1000|1800:0.3|0.25
.Ve
.SS "afade"
.IX Subsection "afade"
Apply fade\-in/out effect ta input audio.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBtype, t\fR" 4
.IX Item "type, t"
Specify tha effect type, can be either \f(CW\*(C`in\*(C'\fR fo' fade-in, or
\&\f(CW\*(C`out\*(C'\fR fo' a gangbangin' fade-out effect. Default is \f(CW\*(C`in\*(C'\fR.
.IP "\fBstart_sample, ss\fR" 4
.IX Item "start_sample, ss"
Specify tha number of tha start sample fo' startin ta apply tha fade
effect. Default is 0.
.IP "\fBnb_samples, ns\fR" 4
.IX Item "nb_samples, ns"
Specify tha number of samplez fo' which tha fade effect has ta last fo' realz. At
the end of tha fade-in effect tha output audio gonna git tha same
volume as tha input audio, all up in tha end of tha fade-out transition
the output audio is ghon be silence. Default is 44100.
.IP "\fBstart_time, st\fR" 4
.IX Item "start_time, st"
Specify time fo' startin ta apply tha fade effect. Default is 0.
Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
If set dis option is used instead of \fIstart_sample\fR one.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Specify tha duration fo' which tha fade effect has ta last. Default is 0.
Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
At tha end of tha fade-in effect tha output audio gonna git tha same
volume as tha input audio, all up in tha end of tha fade-out transition
the output audio is ghon be silence.
If set dis option is used instead of \fInb_samples\fR one.
.IP "\fBcurve\fR" 4
.IX Item "curve"
Set curve fo' fade transition.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBtri\fR" 4
.IX Item "tri"
select triangular, linear slope (default)
.IP "\fBqsin\fR" 4
.IX Item "qsin"
select quarta of sine wave
.IP "\fBhsin\fR" 4
.IX Item "hsin"
select half of sine wave
.IP "\fBesin\fR" 4
.IX Item "esin"
select exponential sine wave
.IP "\fBlog\fR" 4
.IX Item "log"
select logarithmic
.IP "\fBpar\fR" 4
.IX Item "par"
select inverted parabola
.IP "\fBqua\fR" 4
.IX Item "qua"
select quadratic
.IP "\fBcub\fR" 4
.IX Item "cub"
select cubic
.IP "\fBsqu\fR" 4
.IX Item "squ"
select square root
.IP "\fBcbr\fR" 4
.IX Item "cbr"
select cubic root
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Fade up in first 15 secondz of audio:
.Sp
.Vb 1
\&        afade=t=in:ss=0:d=15
.Ve
.IP "\(bu" 4
Fade up last 25 secondz of a 900 secondz audio:
.Sp
.Vb 1
\&        afade=t=out:st=875:d=25
.Ve
.SS "aformat"
.IX Subsection "aformat"
Set output format constraints fo' tha input audio. Da framework will
negotiate da most thugged-out appropriate format ta minimize conversions.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBsample_fmts\fR" 4
.IX Item "sample_fmts"
A '|'\-separated list of axed sample formats.
.IP "\fBsample_rates\fR" 4
.IX Item "sample_rates"
A '|'\-separated list of axed sample rates.
.IP "\fBchannel_layouts\fR" 4
.IX Item "channel_layouts"
A '|'\-separated list of axed channel layouts.
.Sp
See tha Channel Layout section up in tha \fIffmpeg\-utils\fR\|(1) manual
for tha required syntax.
.PP
If a parameta is omitted, all joints is allowed.
.PP
For example ta force tha output ta either unsigned 8\-bit or signed 16\-bit stereo:
.PP
.Vb 1
\&        aformat=sample_fmts=u8|s16:channel_layouts=stereo
.Ve
.SS "allpass"
.IX Subsection "allpass"
Apply a two-pole all-pass filta wit central frequency (in Hz)
\&\fIfrequency\fR, n' filter-width \fIwidth\fR.
An all-pass filta chizzlez tha audioz frequency ta phase relationshizzle
without changin its frequency ta amplitude relationshizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "amerge"
.IX Subsection "amerge"
Merge two or mo' audio streams tha fuck into a single multi-channel stream.
.PP
Da filta accepts tha followin options:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Set tha number of inputs, n' you can put dat on yo' toast. Default is 2.
.PP
If tha channel layoutz of tha inputs is disjoint, n' therefore compatible,
the channel layout of tha output is ghon be set accordingly n' tha channels
will be reordered as necessary. If tha channel layoutz of tha inputs is not
disjoint, tha output gonna git all tha channelz of tha straight-up original gangsta input then all
the channelz of tha second input, up in dat order, n' tha channel layout of
the output is ghon be tha default value correspondin ta tha total number of
channels.
.PP
For example, if tha straight-up original gangsta input is up in 2.1 (\s-1FL+FR+LF\s0) n' tha second input
is \s-1FC+BL+BR,\s0 then tha output is ghon be up in 5.1, wit tha channels up in the
followin order: a1, a2, b1, a3, b2, b3 (a1 is tha straight-up original gangsta channel of the
first input, b1 is tha straight-up original gangsta channel of tha second input).
.PP
On tha other hand, if both input is up in stereo, tha output channels will be
in tha default order: a1, a2, b1, b2, n' tha channel layout will be
arbitrarily set ta 4.0, which may or may not be tha expected value.
.PP
All inputs must have tha same sample rate, n' format.
.PP
If inputs aint gots tha same duration, tha output will stop wit the
shortest.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Merge two mono filez tha fuck into a stereo stream:
.Sp
.Vb 1
\&        amovie=left.wav [l] ; amovie=right.mp3 [r] ; [l] [r] amerge
.Ve
.IP "\(bu" 4
Multiple merges assumin 1 vizzle stream n' 6 audio streams up in \fIinput.mkv\fR:
.Sp
.Vb 1
\&        ffmpeg \-i input.mkv \-filter_complex "[0:1][0:2][0:3][0:4][0:5][0:6] amerge=inputs=6" \-c:a pcm_s16le output.mkv
.Ve
.SS "amix"
.IX Subsection "amix"
Mixes multiple audio inputs tha fuck into a single output.
.PP
For example
.PP
.Vb 1
\&        ffmpeg \-i INPUT1 \-i INPUT2 \-i INPUT3 \-filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT
.Ve
.PP
will mix 3 input audio streams ta a single output wit tha same duration as the
first input n' a thugged-out dropout transizzle time of 3 seconds.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Number of inputs, n' you can put dat on yo' toast. If unspecified, it defaults ta 2.
.IP "\fBduration\fR" 4
.IX Item "duration"
How tha fuck ta determine tha end-of-stream.
.RS 4
.IP "\fBlongest\fR" 4
.IX Item "longest"
Duration of longest input. (default)
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Duration of shortest input.
.IP "\fBfirst\fR" 4
.IX Item "first"
Duration of first input.
.RE
.RS 4
.RE
.IP "\fBdropout_transition\fR" 4
.IX Item "dropout_transition"
Transizzle time, up in seconds, fo' volume renormalization when a input
stream ends. Da default value is 2 seconds.
.SS "anull"
.IX Subsection "anull"
Pass tha audio source unchanged ta tha output.
.SS "apad"
.IX Subsection "apad"
Pad tha end of a audio stream wit silence, dis can be used together with
\&\-shortest ta extend audio streams ta tha same length as tha vizzle stream.
.SS "aphaser"
.IX Subsection "aphaser"
Add a phasin effect ta tha input audio.
.PP
A phaser filta creates seriez of peaks n' troughs up in tha frequency spectrum.
Da posizzle of tha peaks n' troughs is modulated so dat they vary over time, bustin a sweepin effect.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBin_gain\fR" 4
.IX Item "in_gain"
Set input gain. I aint talkin' bout chicken n' gravy biatch. Default is 0.4.
.IP "\fBout_gain\fR" 4
.IX Item "out_gain"
Set output gain. I aint talkin' bout chicken n' gravy biatch. Default is 0.74
.IP "\fBdelay\fR" 4
.IX Item "delay"
Set delay up in milliseconds. Default is 3.0.
.IP "\fBdecay\fR" 4
.IX Item "decay"
Set decay. Default is 0.4.
.IP "\fBspeed\fR" 4
.IX Item "speed"
Set modulation speed up in Hz. Default is 0.5.
.IP "\fBtype\fR" 4
.IX Item "type"
Set modulation type. Default is triangular.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBtriangular, t\fR" 4
.IX Item "triangular, t"
.PD 0
.IP "\fBsinusoidal, s\fR" 4
.IX Item "sinusoidal, s"
.RE
.RS 4
.RE
.PD
.SS "aresample"
.IX Subsection "aresample"
Resample tha input audio ta tha specified parameters, rockin the
libswresample library. If none is specified then tha filta will
automatically convert between its input n' output.
.PP
This filta be also able ta stretch/squeeze tha audio data ta make it match
the timestamps or ta inject silence / cut up audio ta make it match the
timestamps, do a cold-ass lil combination of both or do neither.
.PP
Da filta accepts tha syntax
[\fIsample_rate\fR:]\fIresampler_options\fR, where \fIsample_rate\fR
expresses a sample rate n' \fIresampler_options\fR be a list of
\&\fIkey\fR=\fIvalue\fR pairs, separated by \*(L":\*(R". Right back up in yo muthafuckin ass. See the
ffmpeg-resampla manual fo' tha complete list of supported options.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Resample tha input audio ta 44100Hz:
.Sp
.Vb 1
\&        aresample=44100
.Ve
.IP "\(bu" 4
Stretch/squeeze samplez ta tha given timestamps, wit a maximum of 1000
samplez per second compensation:
.Sp
.Vb 1
\&        aresample=async=1000
.Ve
.SS "asetnsamples"
.IX Subsection "asetnsamples"
Set tha number of samplez per each output audio frame.
.PP
Da last output packet may contain a gangbangin' finger-lickin' different number of samples, as
the filta will flush all tha remainin samplez when tha input audio
signal its end.
.PP
Da filta accepts tha followin options:
.IP "\fBnb_out_samples, n\fR" 4
.IX Item "nb_out_samples, n"
Set tha number of frames per each output audio frame. Da number is
intended as tha number of samplez \fIper each channel\fR.
Default value is 1024.
.IP "\fBpad, p\fR" 4
.IX Item "pad, p"
If set ta 1, tha filta will pad tha last audio frame wit zeroes, so
that tha last frame will contain tha same number of samplez as the
previous ones. Default value is 1.
.PP
For example, ta set tha number of per-frame samplez ta 1234 and
disable paddin fo' tha last frame, use:
.PP
.Vb 1
\&        asetnsamples=n=1234:p=0
.Ve
.SS "asetrate"
.IX Subsection "asetrate"
Set tha sample rate without alterin tha \s-1PCM\s0 data.
This will result up in a cold-ass lil chizzle of speed n' pitch.
.PP
Da filta accepts tha followin options:
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Set tha output sample rate. Default is 44100 Hz.
.SS "ashowinfo"
.IX Subsection "ashowinfo"
Show a line containin various shiznit fo' each input audio frame.
Da input audio aint modified.
.PP
Da shown line gotz nuff a sequence of key/value pairz of tha form
\&\fIkey\fR:\fIvalue\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
Presentation timestamp of tha input frame, up in time base units; tha time base
dependz on tha filta input pad, n' is probably 1/\fIsample_rate\fR.
.IP "\fBpts_time\fR" 4
.IX Item "pts_time"
presentation timestamp of tha input frame up in seconds
.IP "\fBpos\fR" 4
.IX Item "pos"
posizzle of tha frame up in tha input stream, \-1 if dis shiznit in
unavailable and/or meaningless (for example up in case of synthetic audio)
.IP "\fBfmt\fR" 4
.IX Item "fmt"
sample format
.IP "\fBchlayout\fR" 4
.IX Item "chlayout"
channel layout
.IP "\fBrate\fR" 4
.IX Item "rate"
sample rate fo' tha audio frame
.IP "\fBnb_samples\fR" 4
.IX Item "nb_samples"
number of samplez (per channel) up in tha frame
.IP "\fBchecksum\fR" 4
.IX Item "checksum"
Adler\-32 checksum (printed up in hexadecimal) of tha audio data. For planar audio
the data is treated as if all tha planes was concatenated.
.IP "\fBplane_checksums\fR" 4
.IX Item "plane_checksums"
A list of Adler\-32 checksums fo' each data plane.
.SS "astats"
.IX Subsection "astats"
Display time domain statistical shiznit bout tha audio channels.
Statistics is calculated n' displayed fo' each audio channel and,
where applicable, a overall figure be also given.
.PP
Da filta accepts tha followin option:
.IP "\fBlength\fR" 4
.IX Item "length"
Short window length up in seconds, used fo' peak n' trough \s-1RMS\s0 measurement.
Default is \f(CW0.05\fR (50 miliseconds) fo' realz. Allowed range is \f(CW\*(C`[0.1 \- 10]\*(C'\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fB\s-1DC\s0 offset\fR" 4
.IX Item "DC offset"
Mean amplitude displacement from zero.
.IP "\fBMin level\fR" 4
.IX Item "Min level"
Minimal sample level.
.IP "\fBMax level\fR" 4
.IX Item "Max level"
Maximal sample level.
.IP "\fBPeak level dB\fR" 4
.IX Item "Peak level dB"
.PD 0
.IP "\fB\s-1RMS\s0 level dB\fR" 4
.IX Item "RMS level dB"
.PD
Standard peak n' \s-1RMS\s0 level measured up in dBFS.
.IP "\fB\s-1RMS\s0 peak dB\fR" 4
.IX Item "RMS peak dB"
.PD 0
.IP "\fB\s-1RMS\s0 trough dB\fR" 4
.IX Item "RMS trough dB"
.PD
Peak n' trough joints fo' \s-1RMS\s0 level measured over a gangbangin' finger-lickin' dirty-ass short window.
.IP "\fBCrest factor\fR" 4
.IX Item "Crest factor"
Standard ratio of peak ta \s-1RMS\s0 level (note: not up in dB).
.IP "\fBFlat factor\fR" 4
.IX Item "Flat factor"
Flatnizz (i.e. consecutizzle samplez wit tha same value) of tha signal at its peak levels
(i.e. either \fIMin level\fR or \fIMax level\fR).
.IP "\fBPeak count\fR" 4
.IX Item "Peak count"
Number of occasions (not tha number of samples) dat tha signal attained either
\&\fIMin level\fR or \fIMax level\fR.
.SS "astreamsync"
.IX Subsection "astreamsync"
Forward two audio streams n' control tha order tha buffers is forwarded.
.PP
Da filta accepts tha followin options:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set tha expression decidin which stream should be
forwarded next: if tha result is negative, tha straight-up original gangsta stream is forwarded; if
the result is positizzle or zero, tha second stream is forwarded. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can use
the followin variables:
.RS 4
.IP "\fIb1 b2\fR" 4
.IX Item "b1 b2"
number of buffers forwarded so far on each stream
.IP "\fIs1 s2\fR" 4
.IX Item "s1 s2"
number of samplez forwarded so far on each stream
.IP "\fIt1 t2\fR" 4
.IX Item "t1 t2"
current timestamp of each stream
.RE
.RS 4
.Sp
Da default value is \f(CW\*(C`t1\-t2\*(C'\fR, which means ta always forward tha stream
that has a smalla timestamp.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Stress-test \f(CW\*(C`amerge\*(C'\fR by randomly bustin  buffers on tha wrong
input, while avoidin too much of a thugged-out desynchronization:
.PP
.Vb 3
\&        amovie=file.ogg [a] ; amovie=file.mp3 [b] ;
\&        [a] [b] astreamsync=(2*random(1))\-1+tanh(5*(t1\-t2)) [a2] [b2] ;
\&        [a2] [b2] amerge
.Ve
.SS "asyncts"
.IX Subsection "asyncts"
Synchronize audio data wit timestamps by squeezing/stretchin it and/or
droppin samples/addin silence when needed.
.PP
This filta aint built by default, please use aresample ta do squeezing/stretching.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBcompensate\fR" 4
.IX Item "compensate"
Enable stretching/squeezin tha data ta make it match tha timestamps. Disabled
by default. When disabled, time gaps is covered wit silence.
.IP "\fBmin_delta\fR" 4
.IX Item "min_delta"
Minimum difference between timestamps n' audio data (in seconds) ta trigger
adding/droppin samples. Default value is 0.1. If you git non-slick sync with
this filter, try settin dis parameta ta 0.
.IP "\fBmax_comp\fR" 4
.IX Item "max_comp"
Maximum compensation up in samplez per second. Y'all KNOW dat shit, muthafucka! Relevant only wit compensate=1.
Default value 500.
.IP "\fBfirst_pts\fR" 4
.IX Item "first_pts"
Assume tha straight-up original gangsta pts should be dis value. Da time base is 1 / sample rate.
This allows fo' padding/trimmin all up in tha start of stream. By default, no
assumption is made bout tha straight-up original gangsta framez expected pts, so no paddin or
trimmin is done. For example, dis could be set ta 0 ta pad tha beginnin with
silence if a audio stream starts afta tha vizzle stream or ta trim any samples
with a wack pts cuz of encoder delay.
.SS "atempo"
.IX Subsection "atempo"
Adjust audio tempo.
.PP
Da filta accepts exactly one parameter, tha audio tempo. If not
specified then tha filta will assume nominal 1.0 tempo. Tempo must
be up in tha [0.5, 2.0] range.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Slow down audio ta 80% tempo:
.Sp
.Vb 1
\&        atempo=0.8
.Ve
.IP "\(bu" 4
To speed up audio ta 125% tempo:
.Sp
.Vb 1
\&        atempo=1.25
.Ve
.SS "atrim"
.IX Subsection "atrim"
Trim tha input so dat tha output gotz nuff one continuous subpart of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBstart\fR" 4
.IX Item "start"
Specify time of tha start of tha kept section, i.e. tha audio sample
with tha timestamp \fIstart\fR is ghon be tha straight-up original gangsta sample up in tha output.
.IP "\fBend\fR" 4
.IX Item "end"
Specify time of tha straight-up original gangsta audio sample dat is ghon be dropped, i.e. the
audio sample immediately precedin tha one wit tha timestamp \fIend\fR will be
the last sample up in tha output.
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
Same as \fIstart\fR, except dis option sets tha start timestamp up in samples
instead of seconds.
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Same as \fIend\fR, except dis option sets tha end timestamp up in samplez instead
of seconds.
.IP "\fBduration\fR" 4
.IX Item "duration"
Specify maximum duration of tha output.
.IP "\fBstart_sample\fR" 4
.IX Item "start_sample"
Number of tha straight-up original gangsta sample dat should be passed ta output.
.IP "\fBend_sample\fR" 4
.IX Item "end_sample"
Number of tha straight-up original gangsta sample dat should be dropped.
.PP
\&\fBstart\fR, \fBend\fR, \fBduration\fR is expressed as time
duration justifications, check tha \*(L"Time duration\*(R" section up in the
ffmpeg-utils manual.
.PP
Note dat tha straight-up original gangsta two setz of tha start/end options n' tha \fBduration\fR
option peep tha frame timestamp, while tha _sample options simply count the
samplez dat pass all up in tha filter n' shit. Right back up in yo muthafuckin ass. So start/end_pts n' start/end_sample will
give different thangs up in dis biatch when tha timestamps is wrong, inexact or do not start at
zero fo' realz. Also note dat dis filta do not modify tha timestamps. If you wish
that tha output timestamps start at zero, bang tha asetpts filta afta the
atrim filter.
.PP
If multiple start or end options is set, dis filta tries ta be greedy and
keep all samplez dat match at least one of tha specified constraints, n' you can put dat on yo' toast. To keep
only tha part dat matches all tha constraints at once, chain multiple atrim
filters.
.PP
Da defaults is such dat all tha input is kept. Right back up in yo muthafuckin ass. So it is possible ta set e.g.
just tha end joints ta keep every last muthafuckin thang before tha specified time.
.PP
Examples:
.IP "\(bu" 4
drop every last muthafuckin thang except tha second minute of input
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-af atrim=60:120
.Ve
.IP "\(bu" 4
keep only tha straight-up original gangsta 1000 samples
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-af atrim=end_sample=1000
.Ve
.SS "bandpass"
.IX Subsection "bandpass"
Apply a two-pole Butterworth band-pass filta wit central
frequency \fIfrequency\fR, n' (3dB\-point) band-width width.
Da \fIcsg\fR option selects a cold-ass lil constant skirt bust (peak bust = Q)
instead of tha default: constant 0dB peak gain.
Da filta roll off at 6dB per octave (20dB per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency. Default is \f(CW3000\fR.
.IP "\fBcsg\fR" 4
.IX Item "csg"
Constant skirt bust if set ta 1. Defaults ta 0.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "bandreject"
.IX Subsection "bandreject"
Apply a two-pole Butterworth band-reject filta wit central
frequency \fIfrequency\fR, n' (3dB\-point) band-width \fIwidth\fR.
Da filta roll off at 6dB per octave (20dB per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency. Default is \f(CW3000\fR.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "bass"
.IX Subsection "bass"
Boost or cut tha bass (lower) frequenciez of tha audio rockin a two-pole
shelvin filta wit a response similar ta dat of a standard
hi-fiz tone-controls. This be also known as shelvin equalisation (\s-1EQ\s0).
.PP
Da filta accepts tha followin options:
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Give tha bust at 0 Hz. Its useful range be bout \-20
(for a big-ass cut) ta +20 (for a big-ass boost).
Beware of clippin when rockin a positizzle gain.
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency n' so can be used
to extend or reduce tha frequency range ta be boosted or cut.
Da default value is \f(CW100\fR Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Determine how tha fuck steep is tha filterz shelf transition.
.SS "biquad"
.IX Subsection "biquad"
Apply a funky-ass biquad \s-1IIR\s0 filta wit tha given coefficients.
Where \fIb0\fR, \fIb1\fR, \fIb2\fR n' \fIa0\fR, \fIa1\fR, \fIa2\fR
are tha numerator n' denominator coefficients respectively.
.SS "channelmap"
.IX Subsection "channelmap"
Remap input channels ta freshly smoked up locations.
.PP
This filta accepts tha followin named parameters:
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Channel layout of tha output stream.
.IP "\fBmap\fR" 4
.IX Item "map"
Map channels from input ta output. Da argument be a '|'\-separated list of
mappings, each up in tha \f(CW\*(C`\f(CIin_channel\f(CW\-\f(CIout_channel\f(CW\*(C'\fR or
\&\fIin_channel\fR form. \fIin_channel\fR can be either tha name of tha input
channel (e.g. \s-1FL\s0 fo' front left) or its index up in tha input channel layout.
\&\fIout_channel\fR is tha name of tha output channel or its index up in tha output
channel layout. If \fIout_channel\fR aint given then it is implicitly an
index, startin wit zero n' increasin by one fo' each mapping.
.PP
If no mappin is present, tha filta will implicitly map input channels to
output channels preservin index.
.PP
For example, assumin a 5.1+downmix input \s-1MOV\s0 file
.PP
.Vb 1
\&        ffmpeg \-i in.mov \-filta \*(Aqchannelmap=map=DL\-FL|DR\-FR\*(Aq out.wav
.Ve
.PP
will create a output \s-1WAV\s0 file tagged as stereo from tha downmix channels of
the input.
.PP
To fix a 5.1 \s-1WAV\s0 improperly encoded up in \s-1AAC\s0z natizzle channel order
.PP
.Vb 1
\&        ffmpeg \-i in.wav \-filta \*(Aqchannelmap=1|2|0|5|3|4:channel_layout=5.1\*(Aq out.wav
.Ve
.SS "channelsplit"
.IX Subsection "channelsplit"
Split each channel up in input audio stream tha fuck into a separate output stream.
.PP
This filta accepts tha followin named parameters:
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Channel layout of tha input stream. Default is \*(L"stereo\*(R".
.PP
For example, assumin a stereo input \s-1MP3\s0 file
.PP
.Vb 1
\&        ffmpeg \-i in.mp3 \-filter_complex channelsplit out.mkv
.Ve
.PP
will create a output Matroska file wit two audio streams, one containin only
the left channel n' tha other tha right channel.
.PP
To split a 5.1 \s-1WAV\s0 file tha fuck into per-channel files
.PP
.Vb 5
\&        ffmpeg \-i in.wav \-filter_complex
\&        \*(Aqchannelsplit=channel_layout=5.1[FL][FR][FC][LFE][SL][SR]\*(Aq
\&        \-map \*(Aq[FL]\*(Aq front_left.wav \-map \*(Aq[FR]\*(Aq front_right.wav \-map \*(Aq[FC]\*(Aq
\&        front_center.wav \-map \*(Aq[LFE]\*(Aq lfe.wav \-map \*(Aq[SL]\*(Aq side_left.wav \-map \*(Aq[SR]\*(Aq
\&        side_right.wav
.Ve
.SS "compand"
.IX Subsection "compand"
Compress or expand audio dynamic range.
.PP
A description of tha accepted options bigs up.
.IP "\fBattacks\fR" 4
.IX Item "attacks"
.PD 0
.IP "\fBdecays\fR" 4
.IX Item "decays"
.PD
Set list of times up in secondz fo' each channel over which tha instantaneous
level of tha input signal be averaged ta determine its volume.
\&\fBattacks\fR refers ta increase of volume n' \fBdecays\fR refers
to decrease of volume.
For most thangs, tha battle time (response ta tha audio gettin louder)
should be shorta than tha decay time cuz tha human ear is mo' sensitive
to sudden bangin audio than sudden soft audio.
Typical value fo' battle is \f(CW0.3\fR secondz n' fo' decay \f(CW0.8\fR
seconds.
.IP "\fBpoints\fR" 4
.IX Item "points"
Set list of points fo' transfer function, specified up in dB relatizzle ta maximum
possible signal amplitude.
Each key points list need ta be defined rockin tha followin syntax:
\&\f(CW\*(C`x0/y0 x1/y1 x2/y2 ...\*(C'\fR.
.Sp
Da input joints must be up in strictly increasin order but tha transfer
function do not gotta be monotonically rising.
Da point \f(CW\*(C`0/0\*(C'\fR be assumed but may be overridden (by \f(CW\*(C`0/out\-dBn\*(C'\fR).
Typical joints fo' tha transfer function is \f(CW\*(C`\-70/\-70 \-60/\-20\*(C'\fR.
.IP "\fBsoft-knee\fR" 4
.IX Item "soft-knee"
Set amount fo' which tha points at where adjacent line segments on the
transfer function hook up is ghon be rounded. Y'all KNOW dat shit, muthafucka! Defaults is \f(CW0.01\fR.
.IP "\fBgain\fR" 4
.IX Item "gain"
Set additionizzle bust up in dB ta be applied at all points on tha transfer function
and allows easy as fuck  adjustment of tha overall gain.
Default is \f(CW0\fR.
.IP "\fBvolume\fR" 4
.IX Item "volume"
Set initial volume up in dB ta be assumed fo' each channel when filterin starts.
This permits tha user ta supply a nominal level initially, so that,
for example, a straight-up big-ass bust aint applied ta initial signal levels before
the compandin has begun ta operate fo' realz. A typical value fo' audio which is
initially on tha down-low is \-90 dB. Default is \f(CW0\fR.
.IP "\fBdelay\fR" 4
.IX Item "delay"
Set delay up in seconds. Default is \f(CW0\fR. Da input audio
is analysed immediately yo, but audio is delayed before bein fed ta the
volume adjusta n' shit. Right back up in yo muthafuckin ass. Specifyin a thugged-out delay approximately equal ta tha attack/decay
times allows tha filta ta effectively operate up in predictizzle rather than
reactizzle mode.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Make noize wit both on tha down-low n' bangin passages suitable fo' listening
in a noisy environment:
.Sp
.Vb 1
\&        compand=.3 .3:1 1:\-90/\-60 \-60/\-40 \-40/\-30 \-20/\-20:6:0:\-90:0.2
.Ve
.IP "\(bu" 4
Noise-gate fo' when tha noise be at a lower level than tha signal:
.Sp
.Vb 1
\&        compand=.1 .1:.2 .2:\-900/\-900 \-50.1/\-900 \-50/\-50:.01:0:\-90:.1
.Ve
.IP "\(bu" 4
Here be another noise-gate, dis time fo' when tha noise be at a higher level
than tha signal (makin it, up in some ways, similar ta squelch):
.Sp
.Vb 1
\&        compand=.1 .1:.1 .1:\-45.1/\-45.1 \-45/\-900 0/\-900:.01:45:\-90:.1
.Ve
.SS "earwax"
.IX Subsection "earwax"
Make audio easier ta dig on headphones.
.PP
This filta addz `cues' ta 44.1kHz stereo (i.e. audio \s-1CD\s0 format) audio
so dat when listened ta on headphones tha stereo image is moved from
inside yo' head (standard fo' headphones) ta outside n' up in front of
the listener (standard fo' speakers).
.PP
Ported from SoX.
.SS "equalizer"
.IX Subsection "equalizer"
Apply a two-pole peakin equalisation (\s-1EQ\s0) filter n' shit. With this
filter, tha signal-level at n' round a selected frequency can
be increased or decreased, whilst (unlike bandpass n' bandreject
filters) dat at all other frequencies is unchanged.
.PP
In order ta produce complex equalisation curves, dis filta can
be given nuff muthafuckin times, each wit a gangbangin' finger-lickin' different central frequency.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency up in Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Set tha required bust or attenuation up in dB.
Beware of clippin when rockin a positizzle gain.
.SS "highpass"
.IX Subsection "highpass"
Apply a high-pass filta wit 3dB point frequency.
Da filta can be either single-pole, or double-pole (the default).
Da filta roll off at 6dB per pole per octave (20dB per pole per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz. Default is 3000.
.IP "\fBpoles, p\fR" 4
.IX Item "poles, p"
Set number of poles. Default is 2.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
Applies only ta double-pole filter.
Da default is 0.707q n' gives a Butterworth response.
.SS "join"
.IX Subsection "join"
Join multiple input streams tha fuck into one multi-channel stream.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Number of input streams. Defaults ta 2.
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Desired output channel layout. Defaults ta stereo.
.IP "\fBmap\fR" 4
.IX Item "map"
Map channels from inputs ta output. Da argument be a '|'\-separated list of
mappings, each up in tha \f(CW\*(C`\f(CIinput_idx\f(CW.\f(CIin_channel\f(CW\-\f(CIout_channel\f(CW\*(C'\fR
form. \fIinput_idx\fR is tha 0\-based index of tha input stream. \fIin_channel\fR
can be either tha name of tha input channel (e.g. \s-1FL\s0 fo' front left) or its
index up in tha specified input stream. \fIout_channel\fR is tha name of tha output
channel.
.PP
Da filta will attempt ta guess tha mappings when dem is not specified
explicitly. Well shiiiit, it do so by first tryin ta find a unused matchin input channel
and if dat fails it picks tha straight-up original gangsta unused input channel.
.PP
E.g. ta join 3 inputs (with properly set channel layouts)
.PP
.Vb 1
\&        ffmpeg \-i INPUT1 \-i INPUT2 \-i INPUT3 \-filter_complex join=inputs=3 OUTPUT
.Ve
.PP
To build a 5.1 output from 6 single-channel streams:
.PP
.Vb 3
\&        ffmpeg \-i fl \-i fr \-i fc \-i sl \-i sr \-i lfe \-filter_complex
\&        \*(Aqjoin=inputs=6:channel_layout=5.1:map=0.0\-FL|1.0\-FR|2.0\-FC|3.0\-SL|4.0\-SR|5.0\-LFE\*(Aq
\&        out
.Ve
.SS "ladspa"
.IX Subsection "ladspa"
Load a \s-1LADSPA \s0(Linux Audio Developerz Simple Plugin \s-1API\s0) plugin.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-ladspa\*(C'\fR.
.IP "\fBfile, f\fR" 4
.IX Item "file, f"
Specifies tha name of \s-1LADSPA\s0 plugin library ta load. Y'all KNOW dat shit, muthafucka! If tha environment
variable \fB\s-1LADSPA_PATH\s0\fR is defined, tha \s-1LADSPA\s0 plugin is searched in
each one of tha directories specified by tha colon separated list in
\&\fB\s-1LADSPA_PATH\s0\fR, otherwise up in tha standard \s-1LADSPA\s0 paths, which is in
this order: \fI\s-1HOME/\s0.ladspa/lib/\fR, \fI/usr/local/lib/ladspa/\fR,
\&\fI/usr/lib/ladspa/\fR.
.IP "\fBplugin, p\fR" 4
.IX Item "plugin, p"
Specifies tha plugin within tha library. Right back up in yo muthafuckin ass. Some libraries contain only
one plugin yo, but others contain nuff of em. If dis aint set filter
will list all available plugins within tha specified library.
.IP "\fBcontrols, c\fR" 4
.IX Item "controls, c"
Set tha '|' separated list of controls which is zero or mo' floatin point
values dat determine tha behavior of tha loaded plugin (for example delay,
threshold or gain).
Controls need ta be defined rockin tha followin syntax:
c0=\fIvalue0\fR|c1=\fIvalue1\fR|c2=\fIvalue2\fR|..., where
\&\fIvaluei\fR is tha value set on tha \fIi\fR\-th control.
If \fBcontrols\fR is set ta \f(CW\*(C`help\*(C'\fR, all available controls and
their valid ranges is printed.
.IP "\fBsample_rate, s\fR" 4
.IX Item "sample_rate, s"
Specify tha sample rate, default ta 44100. Only used if plugin have
zero inputs.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per channel per each output frame, default
is 1024. Only used if plugin have zero inputs.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha minimum duration of tha sourced audio. Right back up in yo muthafuckin ass. See tha function
\&\f(CW\*(C`av_parse_time()\*(C'\fR fo' tha accepted format, also check tha \*(L"Time duration\*(R"
section up in tha ffmpeg-utils manual.
Note dat tha resultin duration may be pimped outa than tha specified duration,
as tha generated audio be always cut all up in tha end of a cold-ass lil complete frame.
If not specified, or tha expressed duration is negative, tha audio is
supposed ta be generated alllll muthafuckin day.
Only used if plugin have zero inputs.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
List all available plugins within amp (\s-1LADSPA\s0 example plugin) library:
.Sp
.Vb 1
\&        ladspa=file=amp
.Ve
.IP "\(bu" 4
List all available controls n' they valid ranges fo' \f(CW\*(C`vcf_notch\*(C'\fR
plugin from \f(CW\*(C`VCF\*(C'\fR library:
.Sp
.Vb 1
\&        ladspa=f=vcf:p=vcf_notch:c=help
.Ve
.IP "\(bu" 4
Simulate low qualitizzle audio shiznit rockin \f(CW\*(C`Computa Music Toolkit\*(C'\fR (\s-1CMT\s0)
plugin library:
.Sp
.Vb 1
\&        ladspa=file=cmt:plugin=lofi:controls=c0=22|c1=12|c2=12
.Ve
.IP "\(bu" 4
Add reverberation ta tha audio rockin TAP-plugins
(Tomz Audio Processin plugins):
.Sp
.Vb 1
\&        ladspa=file=tap_reverb:tap_reverb
.Ve
.IP "\(bu" 4
Generate white noise, wit 0.2 amplitude:
.Sp
.Vb 1
\&        ladspa=file=cmt:noise_source_white:c=c0=.2
.Ve
.IP "\(bu" 4
Generate 20 bpm clicks rockin plugin \f(CW\*(C`C* Click \- Metronome\*(C'\fR from the
\&\f(CW\*(C`C* Audio Plugin Suite\*(C'\fR (\s-1CAPS\s0) library:
.Sp
.Vb 1
\&        ladspa=file=caps:Click:c=c1=20\*(Aq
.Ve
.IP "\(bu" 4
Apply \f(CW\*(C`C* Eq10X2 \- Stereo 10\-band equaliser\*(C'\fR effect:
.Sp
.Vb 1
\&        ladspa=caps:Eq10X2:c=c0=\-48|c9=\-24|c3=12|c4=2
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBcN\fR" 4
.IX Item "cN"
Modify tha \fIN\fR\-th control value.
.Sp
If tha specified value aint valid, it is ignored n' prior one is kept.
.SS "lowpass"
.IX Subsection "lowpass"
Apply a low-pass filta wit 3dB point frequency.
Da filta can be either single-pole or double-pole (the default).
Da filta roll off at 6dB per pole per octave (20dB per pole per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz. Default is 500.
.IP "\fBpoles, p\fR" 4
.IX Item "poles, p"
Set number of poles. Default is 2.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
Applies only ta double-pole filter.
Da default is 0.707q n' gives a Butterworth response.
.SS "pan"
.IX Subsection "pan"
Mix channels wit specific bust levels. Da filta accepts tha output
channel layout followed by a set of channels definitions.
.PP
This filta be also designed ta remap efficiently tha channelz of a audio
stream.
.PP
Da filta accepts parametaz of tha form:
"\fIl\fR:\fIoutdef\fR:\fIoutdef\fR:..."
.IP "\fBl\fR" 4
.IX Item "l"
output channel layout or number of channels
.IP "\fBoutdef\fR" 4
.IX Item "outdef"
output channel justification, of tha form:
"\fIout_name\fR=[\fIgain\fR*]\fIin_name\fR[+[\fIgain\fR*]\fIin_name\fR...]"
.IP "\fBout_name\fR" 4
.IX Item "out_name"
output channel ta define, either a cold-ass lil channel name (\s-1FL, FR,\s0 etc.) or a cold-ass lil channel
number (c0, c1, etc.)
.IP "\fBgain\fR" 4
.IX Item "gain"
multiplicatizzle coefficient fo' tha channel, 1 leavin tha volume unchanged
.IP "\fBin_name\fR" 4
.IX Item "in_name"
input channel ta use, peep out_name fo' details; it aint possible ta mix
named n' numbered input channels
.PP
If tha `=' up in a cold-ass lil channel justification is replaced by `<', then tha gains for
that justification is ghon be renormalized so dat tha total is 1, thus
avoidin clippin noise.
.PP
\fIMixin examples\fR
.IX Subsection "Mixin examples"
.PP
For example, if you wanna down-mix from stereo ta mono yo, but wit a funky-ass bigger
factor fo' tha left channel:
.PP
.Vb 1
\&        pan=1:c0=0.9*c0+0.1*c1
.Ve
.PP
A customized down-mix ta stereo dat works automatically fo' 3\-, 4\-, 5\- and
7\-channels surround:
.PP
.Vb 1
\&        pan=stereo: FL < FL + 0.5*FC + 0.6*BL + 0.6*SL : FR < FR + 0.5*FC + 0.6*BR + 0.6*SR
.Ve
.PP
Note dat \fBffmpeg\fR integrates a thugged-out default down-mix (and up-mix) system
that should be preferred (see \*(L"\-ac\*(R" option) unless you have straight-up specific
needs.
.PP
\fIRemappin examples\fR
.IX Subsection "Remappin examples"
.PP
Da channel remappin is ghon be effectizzle if, n' only if:
.IP "*<gain coefficients is zeroes or ones,>" 4
.IX Item "*<gain coefficients is zeroes or ones,>"
.PD 0
.IP "*<only one input per channel output,>" 4
.IX Item "*<only one input per channel output,>"
.PD
.PP
If all these conditions is satisfied, tha filta will notify tha user (\*(L"Pure
channel mappin detected\*(R"), n' use a optimized n' lossless method ta do the
remapping.
.PP
For example, if you gotz a 5.1 source n' want a stereo audio stream by
droppin tha extra channels:
.PP
.Vb 1
\&        pan="stereo: c0=FL : c1=FR"
.Ve
.PP
Given tha same source, you can also switch front left n' front right channels
and keep tha input channel layout:
.PP
.Vb 1
\&        pan="5.1: c0=c1 : c1=c0 : c2=c2 : c3=c3 : c4=c4 : c5=c5"
.Ve
.PP
If tha input be a stereo audio stream, you can mute tha front left channel (and
still keep tha stereo channel layout) with:
.PP
.Vb 1
\&        pan="stereo:c1=c1"
.Ve
.PP
Still wit a stereo audio stream input, you can copy tha right channel up in both
front left n' right:
.PP
.Vb 1
\&        pan="stereo: c0=FR : c1=FR"
.Ve
.SS "replaygain"
.IX Subsection "replaygain"
ReplayGain scanner filter n' shit. This filta takes a audio stream as a input and
outputs it unchanged.
At end of filterin it displays \f(CW\*(C`track_gain\*(C'\fR n' \f(CW\*(C`track_peak\*(C'\fR.
.SS "resample"
.IX Subsection "resample"
Convert tha audio sample format, sample rate n' channel layout. This filta is
not meant ta be used directly.
.SS "silencedetect"
.IX Subsection "silencedetect"
Detect silence up in a audio stream.
.PP
This filta logs a message when it detects dat tha input audio volume is less
or equal ta a noise tolerizzle value fo' a thugged-out duration pimped outa or equal ta the
minimum detected noise duration.
.PP
Da printed times n' duration is expressed up in seconds.
.PP
Da filta accepts tha followin options:
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set silence duration until notification (default is 2 seconds).
.IP "\fBnoise, n\fR" 4
.IX Item "noise, n"
Set noise tolerance. Can be specified up in dB (in case \*(L"dB\*(R" be appended ta the
specified value) or amplitude ratio. Default is \-60dB, or 0.001.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Detect 5 secondz of silence wit \-50dB noise tolerance:
.Sp
.Vb 1
\&        silencedetect=n=\-50dB:d=5
.Ve
.IP "\(bu" 4
Complete example wit \fBffmpeg\fR ta detect silence wit 0.0001 noise
tolerizzle up in \fIsilence.mp3\fR:
.Sp
.Vb 1
\&        ffmpeg \-i silence.mp3 \-af silencedetect=noise=0.0001 \-f null \-
.Ve
.SS "treble"
.IX Subsection "treble"
Boost or cut treble (upper) frequenciez of tha audio rockin a two-pole
shelvin filta wit a response similar ta dat of a standard
hi-fiz tone-controls. This be also known as shelvin equalisation (\s-1EQ\s0).
.PP
Da filta accepts tha followin options:
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Give tha bust at whichever is tha lower of ~22 kHz n' the
Nyquist frequency. Its useful range be bout \-20 (for a big-ass cut)
to +20 (for a big-ass boost). Beware of clippin when rockin a positizzle gain.
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency n' so can be used
to extend or reduce tha frequency range ta be boosted or cut.
Da default value is \f(CW3000\fR Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Determine how tha fuck steep is tha filterz shelf transition.
.SS "volume"
.IX Subsection "volume"
Adjust tha input audio volume.
.PP
Da filta accepts tha followin options:
.IP "\fBvolume\fR" 4
.IX Item "volume"
Expresses how tha fuck tha audio volume is ghon be increased or decreased.
.Sp
Output joints is clipped ta tha maximum value.
.Sp
Da output audio volume is given by tha relation:
.Sp
.Vb 1
\&        <output_volume> = <volume> * <input_volume>
.Ve
.Sp
Default value fo' \fIvolume\fR is 1.0.
.IP "\fBprecision\fR" 4
.IX Item "precision"
Set tha mathematical precision.
.Sp
This determines which input sample formats is ghon be allowed, which affects the
precision of tha volume scaling.
.RS 4
.IP "\fBfixed\fR" 4
.IX Item "fixed"
8\-bit fixed-point; limits input sample format ta U8, S16, n' S32.
.IP "\fBfloat\fR" 4
.IX Item "float"
32\-bit floating-point; limits input sample format ta \s-1FLT. \s0(default)
.IP "\fBdouble\fR" 4
.IX Item "double"
64\-bit floating-point; limits input sample format ta \s-1DBL.\s0
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Halve tha input audio volume:
.Sp
.Vb 3
\&        volume=volume=0.5
\&        volume=volume=1/2
\&        volume=volume=\-6.0206dB
.Ve
.Sp
In all tha above example tha named key fo' \fBvolume\fR can be
omitted, fo' example like in:
.Sp
.Vb 1
\&        volume=0.5
.Ve
.IP "\(bu" 4
Increase input audio juice by 6 decibels rockin fixed-point precision:
.Sp
.Vb 1
\&        volume=volume=6dB:precision=fixed
.Ve
.SS "volumedetect"
.IX Subsection "volumedetect"
Detect tha volume of tha input vizzle.
.PP
Da filta has no parameters. Da input aint modified. Y'all KNOW dat shit, muthafucka! Statistics about
the volume is ghon be printed up in tha log when tha input stream end is reached.
.PP
In particular it will show tha mean volume (root mean square), maximum
volume (on a per-sample basis), n' tha beginnin of a histogram of the
registered volume joints (from tha maximum value ta a cold-ass lil cumulated 1/1000 of
the samples).
.PP
All volumes is up in decibels relatizzle ta tha maximum \s-1PCM\s0 value.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Here be a excerpt of tha output:
.PP
.Vb 9
\&        [Parsed_volumedetect_0  0xa23120] mean_volume: \-27 dB
\&        [Parsed_volumedetect_0  0xa23120] max_volume: \-4 dB
\&        [Parsed_volumedetect_0  0xa23120] histogram_4db: 6
\&        [Parsed_volumedetect_0  0xa23120] histogram_5db: 62
\&        [Parsed_volumedetect_0  0xa23120] histogram_6db: 286
\&        [Parsed_volumedetect_0  0xa23120] histogram_7db: 1042
\&        [Parsed_volumedetect_0  0xa23120] histogram_8db: 2551
\&        [Parsed_volumedetect_0  0xa23120] histogram_9db: 4609
\&        [Parsed_volumedetect_0  0xa23120] histogram_10db: 8409
.Ve
.PP
It means that:
.IP "\(bu" 4
Da mean square juice be approximately \-27 dB, or 10^\-2.7.
.IP "\(bu" 4
Da phattest sample be at \-4 dB, or mo' precisely between \-4 dB n' \-5 dB.
.IP "\(bu" 4
There is 6 samplez at \-4 dB, 62 at \-5 dB, 286 at \-6 dB, etc.
.PP
In other lyrics, raisin tha volume by +4 dB do not cause any clipping,
raisin it by +5 dB causes clippin fo' 6 samples, etc.
.SH "AUDIO SOURCES"
.IX Header "AUDIO SOURCES"
Below be a thugged-out description of tha currently available audio sources.
.SS "abuffer"
.IX Subsection "abuffer"
Buffer audio frames, n' make dem available ta tha filta chain.
.PP
This source is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/asrc_abuffer.h\fR.
.PP
It accepts tha followin named parameters:
.IP "\fBtime_base\fR" 4
.IX Item "time_base"
Timebase which is ghon be used fo' timestampz of submitted frames. Well shiiiit, it must be
either a gangbangin' floating-point number or up in \fInumerator\fR/\fIdenominator\fR form.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Da sample rate of tha incomin audio buffers.
.IP "\fBsample_fmt\fR" 4
.IX Item "sample_fmt"
Da sample format of tha incomin audio buffers.
Either a sample format name or its correspongin integer representation from
the enum AVSampleFormat up in \fIlibavutil/samplefmt.h\fR
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Da channel layout of tha incomin audio buffers.
Either a cold-ass lil channel layout name from channel_layout_map in
\&\fIlibavutil/channel_layout.c\fR or its correspondin integer representation
from tha AV_CH_LAYOUT_* macros up in \fIlibavutil/channel_layout.h\fR
.IP "\fBchannels\fR" 4
.IX Item "channels"
Da number of channelz of tha incomin audio buffers.
If both \fIchannels\fR n' \fIchannel_layout\fR is specified, then they
must be consistent.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
.Vb 1
\&        abuffer=sample_rate=44100:sample_fmt=s16p:channel_layout=stereo
.Ve
.PP
will instruct tha source ta accept planar 16bit signed stereo at 44100Hz.
Since tha sample format wit name \*(L"s16p\*(R" correspondz ta tha number
6 n' tha \*(L"stereo\*(R" channel layout correspondz ta tha value 0x3, dis is
equivalent to:
.PP
.Vb 1
\&        abuffer=sample_rate=44100:sample_fmt=6:channel_layout=0x3
.Ve
.SS "aevalsrc"
.IX Subsection "aevalsrc"
Generate a audio signal specified by a expression.
.PP
This source accepts up in input one or mo' expressions (one fo' each
channel), which is evaluated n' used ta generate a cold-ass lil corresponding
audio signal.
.PP
This source accepts tha followin options:
.IP "\fBexprs\fR" 4
.IX Item "exprs"
Set tha '|'\-separated expressions list fo' each separate channel. In case the
\&\fBchannel_layout\fR option aint specified, tha selected channel layout
dependz on tha number of provided expressions.
.IP "\fBchannel_layout, c\fR" 4
.IX Item "channel_layout, c"
Set tha channel layout. Da number of channels up in tha specified layout
must be equal ta tha number of specified expressions.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha minimum duration of tha sourced audio. Right back up in yo muthafuckin ass. See tha function
\&\f(CW\*(C`av_parse_time()\*(C'\fR fo' tha accepted format.
Note dat tha resultin duration may be pimped outa than tha specified
duration, as tha generated audio be always cut all up in tha end of a
complete frame.
.Sp
If not specified, or tha expressed duration is negative, tha audio is
supposed ta be generated alllll muthafuckin day.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per channel per each output frame,
default ta 1024.
.IP "\fBsample_rate, s\fR" 4
.IX Item "sample_rate, s"
Specify tha sample rate, default ta 44100.
.PP
Each expression up in \fIexprs\fR can contain tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
number of tha evaluated sample, startin from 0
.IP "\fBt\fR" 4
.IX Item "t"
time of tha evaluated sample expressed up in seconds, startin from 0
.IP "\fBs\fR" 4
.IX Item "s"
sample rate
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Generate silence:
.Sp
.Vb 1
\&        aevalsrc=0
.Ve
.IP "\(bu" 4
Generate a sin signal wit frequency of 440 Hz, set sample rate to
8000 Hz:
.Sp
.Vb 1
\&        aevalsrc="sin(440*2*PI*t):s=8000"
.Ve
.IP "\(bu" 4
Generate a two channels signal, specify tha channel layout (Front
Centa + Back Center) explicitly:
.Sp
.Vb 1
\&        aevalsrc="sin(420*2*PI*t)|cos(430*2*PI*t):c=FC|BC"
.Ve
.IP "\(bu" 4
Generate white noise:
.Sp
.Vb 1
\&        aevalsrc="\-2+random(0)"
.Ve
.IP "\(bu" 4
Generate a amplitude modulated signal:
.Sp
.Vb 1
\&        aevalsrc="sin(10*2*PI*t)*sin(880*2*PI*t)"
.Ve
.IP "\(bu" 4
Generate 2.5 Hz binaural beats on a 360 Hz carrier:
.Sp
.Vb 1
\&        aevalsrc="0.1*sin(2*PI*(360\-2.5/2)*t) | 0.1*sin(2*PI*(360+2.5/2)*t)"
.Ve
.SS "anullsrc"
.IX Subsection "anullsrc"
Null audio source, return unprocessed audio frames. Well shiiiit, it is mainly useful
as a template n' ta be employed up in analysis / debuggin tools, or as
the source fo' filtas which ignore tha input data (for example tha sox
synth filter).
.PP
This source accepts tha followin options:
.IP "\fBchannel_layout, cl\fR" 4
.IX Item "channel_layout, cl"
Specify tha channel layout, n' can be either a integer or a string
representin a cold-ass lil channel layout. Da default value of \fIchannel_layout\fR
is \*(L"stereo\*(R".
.Sp
Peep tha channel_layout_map definizzle in
\&\fIlibavutil/channel_layout.c\fR fo' tha mappin between strings and
channel layout joints.
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Specify tha sample rate, n' defaults ta 44100.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per axed frames.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha sample rate ta 48000 Hz n' tha channel layout ta \s-1AV_CH_LAYOUT_MONO.\s0
.Sp
.Vb 1
\&        anullsrc=r=48000:cl=4
.Ve
.IP "\(bu" 4
Do tha same operation wit a mo' obvious syntax:
.Sp
.Vb 1
\&        anullsrc=r=48000:cl=mono
.Ve
.PP
All tha parametas need ta be explicitly defined.
.SS "flite"
.IX Subsection "flite"
Synthesize a voice utterizzle rockin tha libflite library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libflite\*(C'\fR.
.PP
Note dat tha flite library aint thread-safe.
.PP
Da filta accepts tha followin options:
.IP "\fBlist_voices\fR" 4
.IX Item "list_voices"
If set ta 1, list tha namez of tha available voices n' exit
immediately. Default value is 0.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha maximum number of samplez per frame. Default value is 512.
.IP "\fBtextfile\fR" 4
.IX Item "textfile"
Set tha filename containin tha text ta speak.
.IP "\fBtext\fR" 4
.IX Item "text"
Set tha text ta speak.
.IP "\fBvoice, v\fR" 4
.IX Item "voice, v"
Set tha voice ta use fo' tha rap synthesis. Default value is
\&\f(CW\*(C`kal\*(C'\fR. Right back up in yo muthafuckin ass. See also tha \fIlist_voices\fR option.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read from file \fIspeech.txt\fR, n' synthetize tha text rockin the
standard flite voice:
.Sp
.Vb 1
\&        flite=textfile=speech.txt
.Ve
.IP "\(bu" 4
Read tha specified text selectin tha \f(CW\*(C`slt\*(C'\fR voice:
.Sp
.Vb 1
\&        flite=text=\*(AqSo fare thee well, skanky devil of a Sub\-Sub, whose commentator I am\*(Aq:voice=slt
.Ve
.IP "\(bu" 4
Input text ta ffmpeg:
.Sp
.Vb 1
\&        ffmpeg \-f lavfi \-i flite=text=\*(AqSo fare thee well, skanky devil of a Sub\-Sub, whose commentator I am\*(Aq:voice=slt
.Ve
.IP "\(bu" 4
Make \fIffplay\fR drop a rhyme tha specified text, rockin \f(CW\*(C`flite\*(C'\fR and
the \f(CW\*(C`lavfi\*(C'\fR device:
.Sp
.Vb 1
\&        ffplay \-f lavfi flite=text=\*(AqNo mo' be grieved fo' which dat thou hast done.\*(Aq
.Ve
.PP
For mo' shiznit bout libflite, check:
<\fBhttp://www.speech.cs.cmu.edu/flite/\fR>
.SS "sine"
.IX Subsection "sine"
Generate a audio signal made of a sine wave wit amplitude 1/8.
.PP
Da audio signal is bit-exact.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha carrier frequency. Default is 440 Hz.
.IP "\fBbeep_factor, b\fR" 4
.IX Item "beep_factor, b"
Enable a periodic beep every last muthafuckin second wit frequency \fIbeep_factor\fR times
the carrier frequency. Default is 0, meanin tha beep is disabled.
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Specify tha sample rate, default is 44100.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Specify tha duration of tha generated audio stream.
.IP "\fBsamples_per_frame\fR" 4
.IX Item "samples_per_frame"
Set tha number of samplez per output frame, default is 1024.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Generate a simple 440 Hz sine wave:
.Sp
.Vb 1
\&        sine
.Ve
.IP "\(bu" 4
Generate a 220 Hz sine wave wit a 880 Hz beep each second, fo' 5 seconds:
.Sp
.Vb 3
\&        sine=220:4:d=5
\&        sine=f=220:b=4:d=5
\&        sine=frequency=220:beep_factor=4:duration=5
.Ve
.SH "AUDIO SINKS"
.IX Header "AUDIO SINKS"
Below be a thugged-out description of tha currently available audio sinks.
.SS "abuffersink"
.IX Subsection "abuffersink"
Buffer audio frames, n' make dem available ta tha end of filta chain.
.PP
This sink is mainly intended fo' programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/buffersink.h\fR
or tha options system.
.PP
It accepts a pointa ta a AVABufferSinkContext structure, which
defines tha incomin buffers' formats, ta be passed as tha opaque
parameta ta \f(CW\*(C`avfilter_init_filter\*(C'\fR fo' initialization.
.SS "anullsink"
.IX Subsection "anullsink"
Null audio sink, do straight-up not a god damn thang wit tha input audio. Well shiiiit, it is
mainly useful as a template n' ta be employed up in analysis / debugging
tools.
.SH "VIDEO FILTERS"
.IX Header "VIDEO FILTERS"
When you configure yo' FFmpeg build, you can disable any of the
existin filtas rockin \f(CW\*(C`\-\-disable\-filters\*(C'\fR.
Da configure output will show tha vizzle filtas included up in your
build.
.PP
Below be a thugged-out description of tha currently available vizzle filters.
.SS "alphaextract"
.IX Subsection "alphaextract"
Extract tha alpha component from tha input as a grayscale vizzle. This
is especially useful wit tha \fIalphamerge\fR filter.
.SS "alphamerge"
.IX Subsection "alphamerge"
Add or replace tha alpha component of tha primary input wit the
grayscale value of a second input. This is intended fo' use with
\&\fIalphaextract\fR ta allow tha transmission or storage of frame
sequences dat have alpha up in a gangbangin' format dat don't support a alpha
channel.
.PP
For example, ta reconstruct full frames from a aiiight YUV-encoded vizzle
and a separate vizzle pimped wit \fIalphaextract\fR, you might use:
.PP
.Vb 1
\&        porno=in_alpha.mkv [alpha]; [in][alpha] alphamerge [out]
.Ve
.PP
Since dis filta is designed fo' reconstruction, it operates on frame
sequences without thankin bout timestamps, n' terminates when either
input reaches end of stream. This will cause problems if yo' encoding
pipeline drops frames. If you tryin ta apply a image as an
overlay ta a vizzle stream, consider tha \fIoverlay\fR filta instead.
.SS "ass"
.IX Subsection "ass"
Same as tha subtitlez filter, except dat it don't require libavcodec
and libavformat ta work. On tha other hand, it is limited ta \s-1ASS \s0(Advanced
Substation Alpha) subtitlez files.
.SS "bbox"
.IX Subsection "bbox"
Compute tha boundin box fo' tha non-black pixels up in tha input frame
luminizzle plane.
.PP
This filta computes tha boundin box containin all tha pixels wit a
luminizzle value pimped outa than tha minimum allowed value.
Da parametas describin tha boundin box is printed on tha filter
log.
.PP
Da filta accepts tha followin option:
.IP "\fBmin_val\fR" 4
.IX Item "min_val"
Set tha minimal luminizzle value. Default is \f(CW16\fR.
.SS "blackdetect"
.IX Subsection "blackdetect"
Detect vizzle intervals dat is (almost) straight-up black. Can be
useful ta detect chapta transitions, commercials, or invalid
recordings. Output lines gotz nuff tha time fo' tha start, end and
duration of tha detected black interval expressed up in seconds.
.PP
In order ta display tha output lines, you need ta set tha loglevel at
least ta tha \s-1AV_LOG_INFO\s0 value.
.PP
Da filta accepts tha followin options:
.IP "\fBblack_min_duration, d\fR" 4
.IX Item "black_min_duration, d"
Set tha minimum detected black duration expressed up in seconds. Well shiiiit, it must
be a non-negatizzle floatin point number.
.Sp
Default value is 2.0.
.IP "\fBpicture_black_ratio_th, pic_th\fR" 4
.IX Item "picture_black_ratio_th, pic_th"
Set tha threshold fo' thankin bout a picture \*(L"black\*(R".
Express tha minimum value fo' tha ratio:
.Sp
.Vb 1
\&        <nb_black_pixels> / <nb_pixels>
.Ve
.Sp
for which a picture is considered black.
Default value is 0.98.
.IP "\fBpixel_black_th, pix_th\fR" 4
.IX Item "pixel_black_th, pix_th"
Set tha threshold fo' thankin bout a pixel \*(L"black\*(R".
.Sp
Da threshold expresses tha maximum pixel luminizzle value fo' which a
pixel is considered \*(L"black\*(R". Da provided value is scaled accordin to
the followin equation:
.Sp
.Vb 1
\&        <absolute_threshold> = <luminance_minimum_value> + <pixel_black_th> * <luminance_range_size>
.Ve
.Sp
\&\fIluminance_range_size\fR n' \fIluminance_minimum_value\fR depend on
the input vizzle format, tha range is [0\-255] fo' \s-1YUV\s0 full-range
formats n' [16\-235] fo' \s-1YUV\s0 non full-range formats.
.Sp
Default value is 0.10.
.PP
Da followin example sets tha maximum pixel threshold ta tha minimum
value, n' detects only black intervalz of 2 or mo' seconds:
.PP
.Vb 1
\&        blackdetect=d=2:pix_th=0.00
.Ve
.SS "blackframe"
.IX Subsection "blackframe"
Detect frames dat is (almost) straight-up black. Can be useful to
detect chapta transitions or commercials. Output lines consist of
the frame number of tha detected frame, tha cementage of blackness,
the posizzle up in tha file if known or \-1 n' tha timestamp up in seconds.
.PP
In order ta display tha output lines, you need ta set tha loglevel at
least ta tha \s-1AV_LOG_INFO\s0 value.
.PP
Da filta accepts tha followin options:
.IP "\fBamount\fR" 4
.IX Item "amount"
Set tha cementage of tha pixels dat gotta be below tha threshold, defaults
to \f(CW98\fR.
.IP "\fBthreshold, thresh\fR" 4
.IX Item "threshold, thresh"
Set tha threshold below which a pixel value is considered black, defaults to
\&\f(CW32\fR.
.SS "blend"
.IX Subsection "blend"
Blend two vizzle frames tha fuck into each other.
.PP
It takes two input streams n' outputs one stream, tha straight-up original gangsta input is the
\&\*(L"top\*(R" layer n' second input is \*(L"bottom\*(R" layer.
Output terminates when shortest input terminates.
.PP
A description of tha accepted options bigs up.
.IP "\fBc0_mode\fR" 4
.IX Item "c0_mode"
.PD 0
.IP "\fBc1_mode\fR" 4
.IX Item "c1_mode"
.IP "\fBc2_mode\fR" 4
.IX Item "c2_mode"
.IP "\fBc3_mode\fR" 4
.IX Item "c3_mode"
.IP "\fBall_mode\fR" 4
.IX Item "all_mode"
.PD
Set blend mode fo' specific pixel component or all pixel components up in case
of \fIall_mode\fR. Default value is \f(CW\*(C`normal\*(C'\fR.
.Sp
Available joints fo' component modes are:
.RS 4
.IP "\fBaddition\fR" 4
.IX Item "addition"
.PD 0
.IP "\fBand\fR" 4
.IX Item "and"
.IP "\fBaverage\fR" 4
.IX Item "average"
.IP "\fBburn\fR" 4
.IX Item "burn"
.IP "\fBdarken\fR" 4
.IX Item "darken"
.IP "\fBdifference\fR" 4
.IX Item "difference"
.IP "\fBdivide\fR" 4
.IX Item "divide"
.IP "\fBdodge\fR" 4
.IX Item "dodge"
.IP "\fBexclusion\fR" 4
.IX Item "exclusion"
.IP "\fBhardlight\fR" 4
.IX Item "hardlight"
.IP "\fBlighten\fR" 4
.IX Item "lighten"
.IP "\fBmultiply\fR" 4
.IX Item "multiply"
.IP "\fBnegation\fR" 4
.IX Item "negation"
.IP "\fBnormal\fR" 4
.IX Item "normal"
.IP "\fBor\fR" 4
.IX Item "or"
.IP "\fBoverlay\fR" 4
.IX Item "overlay"
.IP "\fBphoenix\fR" 4
.IX Item "phoenix"
.IP "\fBpinlight\fR" 4
.IX Item "pinlight"
.IP "\fBreflect\fR" 4
.IX Item "reflect"
.IP "\fBscreen\fR" 4
.IX Item "screen"
.IP "\fBsoftlight\fR" 4
.IX Item "softlight"
.IP "\fBsubtract\fR" 4
.IX Item "subtract"
.IP "\fBvividlight\fR" 4
.IX Item "vividlight"
.IP "\fBxor\fR" 4
.IX Item "xor"
.RE
.RS 4
.RE
.IP "\fBc0_opacity\fR" 4
.IX Item "c0_opacity"
.IP "\fBc1_opacity\fR" 4
.IX Item "c1_opacity"
.IP "\fBc2_opacity\fR" 4
.IX Item "c2_opacity"
.IP "\fBc3_opacity\fR" 4
.IX Item "c3_opacity"
.IP "\fBall_opacity\fR" 4
.IX Item "all_opacity"
.PD
Set blend opacitizzle fo' specific pixel component or all pixel components up in case
of \fIall_opacity\fR. Only used up in combination wit pixel component blend modes.
.IP "\fBc0_expr\fR" 4
.IX Item "c0_expr"
.PD 0
.IP "\fBc1_expr\fR" 4
.IX Item "c1_expr"
.IP "\fBc2_expr\fR" 4
.IX Item "c2_expr"
.IP "\fBc3_expr\fR" 4
.IX Item "c3_expr"
.IP "\fBall_expr\fR" 4
.IX Item "all_expr"
.PD
Set blend expression fo' specific pixel component or all pixel components up in case
of \fIall_expr\fR. Note dat related mode options is ghon be ignored if dem is set.
.Sp
Da expressions can use tha followin variables:
.RS 4
.IP "\fBN\fR" 4
.IX Item "N"
Da sequential number of tha filtered frame, startin from \f(CW0\fR.
.IP "\fBX\fR" 4
.IX Item "X"
.PD 0
.IP "\fBY\fR" 4
.IX Item "Y"
.PD
the coordinatez of tha current sample
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
the width n' height of currently filtered plane
.IP "\fB\s-1SW\s0\fR" 4
.IX Item "SW"
.PD 0
.IP "\fB\s-1SH\s0\fR" 4
.IX Item "SH"
.PD
Width n' height scale dependin on tha currently filtered plane. Well shiiiit, it is the
ratio between tha correspondin luma plane number of pixels n' tha current
plane ones. E.g. fo' \s-1YUV4:2:0\s0 tha joints is \f(CW\*(C`1,1\*(C'\fR fo' tha luma plane, and
\&\f(CW\*(C`0.5,0.5\*(C'\fR fo' chroma planes.
.IP "\fBT\fR" 4
.IX Item "T"
Time of tha current frame, expressed up in seconds.
.IP "\fB\s-1TOP, A\s0\fR" 4
.IX Item "TOP, A"
Value of pixel component at current location fo' first vizzle frame (top layer).
.IP "\fB\s-1BOTTOM, B\s0\fR" 4
.IX Item "BOTTOM, B"
Value of pixel component at current location fo' second vizzle frame (bottom layer).
.RE
.RS 4
.RE
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Force termination when tha shortest input terminates. Default is \f(CW0\fR.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
Continue applyin tha last bottom frame afta tha end of tha stream fo' realz. A value of
\&\f(CW0\fR disable tha filta afta tha last frame of tha bottom layer is reached.
Default is \f(CW1\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply transizzle from bottom layer ta top layer up in first 10 seconds:
.Sp
.Vb 1
\&        blend=all_expr=\*(AqA*(if(gte(T,10),1,T/10))+B*(1\-(if(gte(T,10),1,T/10)))\*(Aq
.Ve
.IP "\(bu" 4
Apply 1x1 checkerboard effect:
.Sp
.Vb 1
\&        blend=all_expr=\*(Aqif(eq(mod(X,2),mod(Y,2)),A,B)\*(Aq
.Ve
.SS "boxblur"
.IX Subsection "boxblur"
Apply boxblur algorithm ta tha input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
.PD 0
.IP "\fBluma_power, lp\fR" 4
.IX Item "luma_power, lp"
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
.IP "\fBchroma_power, cp\fR" 4
.IX Item "chroma_power, cp"
.IP "\fBalpha_radius, ar\fR" 4
.IX Item "alpha_radius, ar"
.IP "\fBalpha_power, ap\fR" 4
.IX Item "alpha_power, ap"
.PD
.PP
A description of tha accepted options bigs up.
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
.PD 0
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
.IP "\fBalpha_radius, ar\fR" 4
.IX Item "alpha_radius, ar"
.PD
Set a expression fo' tha box radius up in pixels used fo' blurrin the
correspondin input plane.
.Sp
Da radius value must be a non-negatizzle number, n' must not be
greata than tha value of tha expression \f(CW\*(C`min(w,h)/2\*(C'\fR fo' the
luma n' alpha planes, n' of \f(CW\*(C`min(cw,ch)/2\*(C'\fR fo' tha chroma
planes.
.Sp
Default value fo' \fBluma_radius\fR is \*(L"2\*(R". If not specified,
\&\fBchroma_radius\fR n' \fBalpha_radius\fR default ta the
correspondin value set fo' \fBluma_radius\fR.
.Sp
Da expressions can contain tha followin constants:
.RS 4
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
the input width n' height up in pixels
.IP "\fBcw\fR" 4
.IX Item "cw"
.PD 0
.IP "\fBch\fR" 4
.IX Item "ch"
.PD
the input chroma image width n' height up in pixels
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.RE
.RS 4
.RE
.IP "\fBluma_power, lp\fR" 4
.IX Item "luma_power, lp"
.PD 0
.IP "\fBchroma_power, cp\fR" 4
.IX Item "chroma_power, cp"
.IP "\fBalpha_power, ap\fR" 4
.IX Item "alpha_power, ap"
.PD
Specify how tha fuck nuff times tha boxblur filta be applied ta the
correspondin plane.
.Sp
Default value fo' \fBluma_power\fR is 2. If not specified,
\&\fBchroma_power\fR n' \fBalpha_power\fR default ta the
correspondin value set fo' \fBluma_power\fR.
.Sp
A value of 0 will disable tha effect.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply a funky-ass boxblur filta wit luma, chroma, n' alpha radius
set ta 2:
.Sp
.Vb 2
\&        boxblur=luma_radius=2:luma_power=1
\&        boxblur=2:1
.Ve
.IP "\(bu" 4
Set luma radius ta 2, alpha n' chroma radius ta 0:
.Sp
.Vb 1
\&        boxblur=2:1:cr=0:ar=0
.Ve
.IP "\(bu" 4
Set luma n' chroma radius ta a gangbangin' fraction of tha vizzle dimension:
.Sp
.Vb 1
\&        boxblur=luma_radius=min(h\e,w)/10:luma_power=1:chroma_radius=min(cw\e,ch)/10:chroma_power=1
.Ve
.SS "colorbalance"
.IX Subsection "colorbalance"
Modify intensitizzle of primary flavas (red, chronic n' blue) of input frames.
.PP
Da filta allows a input frame ta be adjusted up in tha shadows, midtones or highlights
regions fo' tha red-cyan, green-magenta or blue-yellow balance.
.PP
A positizzle adjustment value shifts tha balizzle towardz tha primary color, a negative
value towardz tha complementary color.
.PP
Da filta accepts tha followin options:
.IP "\fBrs\fR" 4
.IX Item "rs"
.PD 0
.IP "\fBgs\fR" 4
.IX Item "gs"
.IP "\fBbs\fR" 4
.IX Item "bs"
.PD
Adjust red, chronic n' blue shadows (darkest pixels).
.IP "\fBrm\fR" 4
.IX Item "rm"
.PD 0
.IP "\fBgm\fR" 4
.IX Item "gm"
.IP "\fBbm\fR" 4
.IX Item "bm"
.PD
Adjust red, chronic n' blue midtones (medium pixels).
.IP "\fBrh\fR" 4
.IX Item "rh"
.PD 0
.IP "\fBgh\fR" 4
.IX Item "gh"
.IP "\fBbh\fR" 4
.IX Item "bh"
.PD
Adjust red, chronic n' blue highlights (brightest pixels).
.Sp
Allowed ranges fo' options is \f(CW\*(C`[\-1.0, 1.0]\*(C'\fR. Defaults is \f(CW0\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Add red color cast ta shadows:
.Sp
.Vb 1
\&        colorbalance=rs=.3
.Ve
.SS "colorchannelmixer"
.IX Subsection "colorchannelmixer"
Adjust vizzle input frames by re-mixin color channels.
.PP
This filta modifies a cold-ass lil color channel by addin tha joints associated to
the other channelz of tha same pixels. For example if tha value to
modify is red, tha output value will be:
.PP
.Vb 1
\&        <red>=<red>*<rr> + <blue>*<rb> + <green>*<rg> + <alpha>*<ra>
.Ve
.PP
Da filta accepts tha followin options:
.IP "\fBrr\fR" 4
.IX Item "rr"
.PD 0
.IP "\fBrg\fR" 4
.IX Item "rg"
.IP "\fBrb\fR" 4
.IX Item "rb"
.IP "\fBra\fR" 4
.IX Item "ra"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output red channel.
Default is \f(CW1\fR fo' \fIrr\fR, n' \f(CW0\fR fo' \fIrg\fR, \fIrb\fR n' \fIra\fR.
.IP "\fBgr\fR" 4
.IX Item "gr"
.PD 0
.IP "\fBgg\fR" 4
.IX Item "gg"
.IP "\fBgb\fR" 4
.IX Item "gb"
.IP "\fBga\fR" 4
.IX Item "ga"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output chronic channel.
Default is \f(CW1\fR fo' \fIgg\fR, n' \f(CW0\fR fo' \fIgr\fR, \fIgb\fR n' \fIga\fR.
.IP "\fBbr\fR" 4
.IX Item "br"
.PD 0
.IP "\fBbg\fR" 4
.IX Item "bg"
.IP "\fBbb\fR" 4
.IX Item "bb"
.IP "\fBba\fR" 4
.IX Item "ba"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output blue channel.
Default is \f(CW1\fR fo' \fIbb\fR, n' \f(CW0\fR fo' \fIbr\fR, \fIbg\fR n' \fIba\fR.
.IP "\fBar\fR" 4
.IX Item "ar"
.PD 0
.IP "\fBag\fR" 4
.IX Item "ag"
.IP "\fBab\fR" 4
.IX Item "ab"
.IP "\fBaa\fR" 4
.IX Item "aa"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output alpha channel.
Default is \f(CW1\fR fo' \fIaa\fR, n' \f(CW0\fR fo' \fIar\fR, \fIag\fR n' \fIab\fR.
.Sp
Allowed ranges fo' options is \f(CW\*(C`[\-2.0, 2.0]\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert source ta grayscale:
.Sp
.Vb 1
\&        colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3
.Ve
.IP "\(bu" 4
Simulate sepia tones:
.Sp
.Vb 1
\&        colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131
.Ve
.SS "colormatrix"
.IX Subsection "colormatrix"
Convert color matrix.
.PP
Da filta accepts tha followin options:
.IP "\fBsrc\fR" 4
.IX Item "src"
.PD 0
.IP "\fBdst\fR" 4
.IX Item "dst"
.PD
Specify tha source n' destination color matrix. Both joints must be
specified.
.Sp
Da accepted joints are:
.RS 4
.IP "\fBbt709\fR" 4
.IX Item "bt709"
\&\s-1BT.709\s0
.IP "\fBbt601\fR" 4
.IX Item "bt601"
\&\s-1BT.601\s0
.IP "\fBsmpte240m\fR" 4
.IX Item "smpte240m"
\&\s-1SMPTE\-240M\s0
.IP "\fBfcc\fR" 4
.IX Item "fcc"
\&\s-1FCC\s0
.RE
.RS 4
.RE
.PP
For example ta convert from \s-1BT.601\s0 ta \s-1SMPTE\-240M,\s0 use tha command:
.PP
.Vb 1
\&        colormatrix=bt601:smpte240m
.Ve
.SS "copy"
.IX Subsection "copy"
Copy tha input source unchanged ta tha output. Mainly useful for
testin purposes.
.SS "crop"
.IX Subsection "crop"
Crop tha input vizzle ta given dimensions.
.PP
Da filta accepts tha followin options:
.IP "\fBw, out_w\fR" 4
.IX Item "w, out_w"
Width of tha output vizzle. Well shiiiit, it defaults ta \f(CW\*(C`iw\*(C'\fR.
This expression is evaluated only once durin tha filter
configuration.
.IP "\fBh, out_h\fR" 4
.IX Item "h, out_h"
Height of tha output vizzle. Well shiiiit, it defaults ta \f(CW\*(C`ih\*(C'\fR.
This expression is evaluated only once durin tha filter
configuration.
.IP "\fBx\fR" 4
.IX Item "x"
Horizontal position, up in tha input vizzle, of tha left edge of tha output vizzle.
It defaults ta \f(CW\*(C`(in_w\-out_w)/2\*(C'\fR.
This expression is evaluated per-frame.
.IP "\fBy\fR" 4
.IX Item "y"
Vertical position, up in tha input vizzle, of tha top edge of tha output vizzle.
It defaults ta \f(CW\*(C`(in_h\-out_h)/2\*(C'\fR.
This expression is evaluated per-frame.
.IP "\fBkeep_aspect\fR" 4
.IX Item "keep_aspect"
If set ta 1 will force tha output display aspect ratio
to be tha same of tha input, by changin tha output sample aspect
ratio. Well shiiiit, it defaults ta 0.
.PP
Da \fIout_w\fR, \fIout_h\fR, \fIx\fR, \fIy\fR parametas are
expressions containin tha followin constants:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the computed joints fo' \fIx\fR n' \fIy\fR. They is evaluated for
each freshly smoked up frame.
.IP "\fBin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fBin_h\fR" 4
.IX Item "in_h"
.PD
the input width n' height
.IP "\fBiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fBih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fBout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fBout_h\fR" 4
.IX Item "out_h"
.PD
the output (cropped) width n' height
.IP "\fBow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fBoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fBa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIiw\fR / \fIih\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.PP
Da expression fo' \fIout_w\fR may depend on tha value of \fIout_h\fR,
and tha expression fo' \fIout_h\fR may depend on \fIout_w\fR yo, but they
cannot depend on \fIx\fR n' \fIy\fR, as \fIx\fR n' \fIy\fR are
evaluated afta \fIout_w\fR n' \fIout_h\fR.
.PP
Da \fIx\fR n' \fIy\fR parametas specify tha expressions fo' the
posizzle of tha top-left corner of tha output (non-cropped) area. They
are evaluated fo' each frame. If tha evaluated value aint valid, it
is approximated ta tha nearest valid value.
.PP
Da expression fo' \fIx\fR may depend on \fIy\fR, n' tha expression
for \fIy\fR may depend on \fIx\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Crop area wit size 100x100 at posizzle (12,34).
.Sp
.Vb 1
\&        crop=100:100:12:34
.Ve
.Sp
Usin named options, tha example above becomes:
.Sp
.Vb 1
\&        crop=w=100:h=100:x=12:y=34
.Ve
.IP "\(bu" 4
Crop tha central input area wit size 100x100:
.Sp
.Vb 1
\&        crop=100:100
.Ve
.IP "\(bu" 4
Crop tha central input area wit size 2/3 of tha input vizzle:
.Sp
.Vb 1
\&        crop=2/3*in_w:2/3*in_h
.Ve
.IP "\(bu" 4
Crop tha input vizzle central square:
.Sp
.Vb 2
\&        crop=out_w=in_h
\&        crop=in_h
.Ve
.IP "\(bu" 4
Delimit tha rectangle wit tha top-left corner placed at position
100:100 n' tha right-bottom corner correspondin ta tha right-bottom
corner of tha input image:
.Sp
.Vb 1
\&        crop=in_w\-100:in_h\-100:100:100
.Ve
.IP "\(bu" 4
Crop 10 pixels from tha left n' right borders, n' 20 pixels from
the top n' bottom borders
.Sp
.Vb 1
\&        crop=in_w\-2*10:in_h\-2*20
.Ve
.IP "\(bu" 4
Keep only tha bottom right quarta of tha input image:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:in_w/2:in_h/2
.Ve
.IP "\(bu" 4
Crop height fo' gettin Greek harmony:
.Sp
.Vb 1
\&        crop=in_w:1/PHI*in_w
.Ve
.IP "\(bu" 4
Appply tremblin effect:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:(in_w\-out_w)/2+((in_w\-out_w)/2)*sin(n/10):(in_h\-out_h)/2 +((in_h\-out_h)/2)*sin(n/7)
.Ve
.IP "\(bu" 4
Apply erratic camera effect dependin on timestamp:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:(in_w\-out_w)/2+((in_w\-out_w)/2)*sin(t*10):(in_h\-out_h)/2 +((in_h\-out_h)/2)*sin(t*13)"
.Ve
.IP "\(bu" 4
Set x dependin on tha value of y:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:y:10+10*sin(n/10)
.Ve
.SS "cropdetect"
.IX Subsection "cropdetect"
Auto-detect crop size.
.PP
Calculate necessary croppin parametas n' prints tha recommended
parametas all up in tha loggin system. Da detected dimensions
correspond ta tha non-black area of tha input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBlimit\fR" 4
.IX Item "limit"
Set higher black value threshold, which can be optionally specified
from not a god damn thang (0) ta every last muthafuckin thang (255) fo' realz. An intensitizzle value pimped outer
to tha set value is considered non-black. Default value is 24.
.IP "\fBround\fR" 4
.IX Item "round"
Set tha value fo' which tha width/height should be divisible by. The
offset be automatically adjusted ta centa tha vizzle. Use 2 ta get
only even dimensions (needed fo' 4:2:2 vizzle). 16 is dopest when
encodin ta most vizzle codecs. Default value is 16.
.IP "\fBreset_count, reset\fR" 4
.IX Item "reset_count, reset"
Set tha counta dat determines afta how tha fuck nuff frames cropdetect will
reset tha previously detected phattest vizzle area n' start over to
detect tha current optimal crop area. Default value is 0.
.Sp
This can be useful when channel logos distort tha vizzle area. 0
indicates never reset n' return tha phattest area encountered during
playback.
.SS "curves"
.IX Subsection "curves"
Apply color adjustments rockin curves.
.PP
This filta is similar ta tha Adobe Photoshop n' \s-1GIMP\s0 curves tools. Each
component (red, chronic n' blue) has its joints defined by \fIN\fR key points
tied from each other rockin a smooth curve. Da x\-axis represents tha pixel
values from tha input frame, n' tha y\-axis tha freshly smoked up pixel joints ta be set for
the output frame.
.PP
By default, a cold-ass lil component curve is defined by tha two points \fI(0;0)\fR and
\&\fI(1;1)\fR. This creates a straight line where each original gangsta pixel value is
\&\*(L"adjusted\*(R" ta its own value, which means no chizzle ta tha image.
.PP
Da filta allows you ta redefine these two points n' add some mo' n' mo' n' mo' fo' realz. A new
curve (usin a natural cubic spline interpolation) is ghon be define ta pass
smoothly all up in all these freshly smoked up coordinates. Da freshly smoked up defined points need ta be
strictly increasin over tha x\-axis, n' they \fIx\fR n' \fIy\fR joints must
be up in tha \fI[0;1]\fR interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha computed curves happened ta go outside
the vector spaces, tha joints is ghon be clipped accordingly.
.PP
If there is no key point defined up in \f(CW\*(C`x=0\*(C'\fR, tha filta will automatically
insert a \fI(0;0)\fR point. In tha same way, if there is no key point defined
in \f(CW\*(C`x=1\*(C'\fR, tha filta will automatically bang a \fI(1;1)\fR point.
.PP
Da filta accepts tha followin options:
.IP "\fBpreset\fR" 4
.IX Item "preset"
Select one of tha available color presets, n' you can put dat on yo' toast. This option can be used up in addition
to tha \fBr\fR, \fBg\fR, \fBb\fR parameters; up in dis case, tha later
options takes prioritizzle on tha preset joints.
Available presets are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
.PD 0
.IP "\fBcolor_negative\fR" 4
.IX Item "color_negative"
.IP "\fBcross_process\fR" 4
.IX Item "cross_process"
.IP "\fBdarker\fR" 4
.IX Item "darker"
.IP "\fBincrease_contrast\fR" 4
.IX Item "increase_contrast"
.IP "\fBlighter\fR" 4
.IX Item "lighter"
.IP "\fBlinear_contrast\fR" 4
.IX Item "linear_contrast"
.IP "\fBmedium_contrast\fR" 4
.IX Item "medium_contrast"
.IP "\fBnegative\fR" 4
.IX Item "negative"
.IP "\fBstrong_contrast\fR" 4
.IX Item "strong_contrast"
.IP "\fBvintage\fR" 4
.IX Item "vintage"
.RE
.RS 4
.PD
.Sp
Default is \f(CW\*(C`none\*(C'\fR.
.RE
.IP "\fBmaster, m\fR" 4
.IX Item "master, m"
Set tha masta key points, n' you can put dat on yo' toast. These points will define a second pass mapping. It
is sometimes called a \*(L"luminance\*(R" or \*(L"value\*(R" mapping. Well shiiiit, it can be used with
\&\fBr\fR, \fBg\fR, \fBb\fR or \fBall\fR since it acts like a
post-processin \s-1LUT.\s0
.IP "\fBred, r\fR" 4
.IX Item "red, r"
Set tha key points fo' tha red component.
.IP "\fBgreen, g\fR" 4
.IX Item "green, g"
Set tha key points fo' tha chronic component.
.IP "\fBblue, b\fR" 4
.IX Item "blue, b"
Set tha key points fo' tha blue component.
.IP "\fBall\fR" 4
.IX Item "all"
Set tha key points fo' all components (not includin master).
Can be used up in addizzle ta tha other key points component
options. In dis case, tha unset component(s) will fallback on this
\&\fBall\fR setting.
.IP "\fBpsfile\fR" 4
.IX Item "psfile"
Specify a Photoshop curves file (\f(CW\*(C`.asv\*(C'\fR) ta import tha settings from.
.PP
To avoid some filtergraph syntax conflicts, each key points list need ta be
defined rockin tha followin syntax: \f(CW\*(C`x0/y0 x1/y1 x2/y2 ...\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Increase slightly tha middle level of blue:
.Sp
.Vb 1
\&        curves=blue=\*(Aq0.5/0.58\*(Aq
.Ve
.IP "\(bu" 4
Vintage effect:
.Sp
.Vb 1
\&        curves=r=\*(Aq0/0.11 .42/.51 1/0.95\*(Aq:g=\*(Aq0.50/0.48\*(Aq:b=\*(Aq0/0.22 .49/.44 1/0.8\*(Aq
.Ve
.Sp
Here we obtain tha followin coordinates fo' each components:
.RS 4
.IP "\fIred\fR" 4
.IX Item "red"
\&\f(CW\*(C`(0;0.11) (0.42;0.51) (1;0.95)\*(C'\fR
.IP "\fIgreen\fR" 4
.IX Item "green"
\&\f(CW\*(C`(0;0) (0.50;0.48) (1;1)\*(C'\fR
.IP "\fIblue\fR" 4
.IX Item "blue"
\&\f(CW\*(C`(0;0.22) (0.49;0.44) (1;0.80)\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
Da previous example can also be  bigged up  wit tha associated built-in preset:
.Sp
.Vb 1
\&        curves=preset=vintage
.Ve
.IP "\(bu" 4
Or simply:
.Sp
.Vb 1
\&        curves=vintage
.Ve
.IP "\(bu" 4
Use a Photoshop preset n' redefine tha pointz of tha chronic component:
.Sp
.Vb 1
\&        curves=psfile=\*(AqMyCurvesPresets/purple.asv\*(Aq:green=\*(Aq0.45/0.53\*(Aq
.Ve
.SS "dctdnoiz"
.IX Subsection "dctdnoiz"
Denoise frames rockin 2D \s-1DCT \s0(frequency domain filtering).
.PP
This filta aint designed fo' real time n' can be mad slow.
.PP
Da filta accepts tha followin options:
.IP "\fBsigma, s\fR" 4
.IX Item "sigma, s"
Set tha noise sigma constant.
.Sp
This \fIsigma\fR defines a hard threshold of \f(CW\*(C`3 * sigma\*(C'\fR; every last muthafuckin \s-1DCT\s0
coefficient (absolute value) below dis threshold wit be dropped.
.Sp
If you need a mo' advanced filtering, peep \fBexpr\fR.
.Sp
Default is \f(CW0\fR.
.IP "\fBoverlap\fR" 4
.IX Item "overlap"
Set number overlappin pixels fo' each block. Each block iz of size
\&\f(CW\*(C`16x16\*(C'\fR. Right back up in yo muthafuckin ass. Since tha filta can be slow, you may wanna reduce dis value,
at tha cost of a less effectizzle filta n' tha risk of various artefacts.
.Sp
If tha overlappin value don't allow ta process tha whole input width or
height, a warnin is ghon be displayed n' accordin bordaz won't be denoised.
.Sp
Default value is \f(CW15\fR.
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set tha coefficient factor expression.
.Sp
For each coefficient of a \s-1DCT\s0 block, dis expression is ghon be evaluated as a
multiplier value fo' tha coefficient.
.Sp
If dis is option is set, tha \fBsigma\fR option is ghon be ignored.
.Sp
Da absolute value of tha coefficient can be accessed all up in tha \fIc\fR
variable.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Apply a thugged-out denoise wit a \fBsigma\fR of \f(CW4.5\fR:
.PP
.Vb 1
\&        dctdnoiz=4.5
.Ve
.PP
Da same operation can be  bigged up  rockin tha expression system:
.PP
.Vb 1
\&        dctdnoiz=e=\*(Aqgte(c, 4.5*3)\*(Aq
.Ve
.SS "decimate"
.IX Subsection "decimate"
Drop duplicated frames at regular intervals.
.PP
Da filta accepts tha followin options:
.IP "\fBcycle\fR" 4
.IX Item "cycle"
Set tha number of frames from which one is ghon be dropped. Y'all KNOW dat shit, muthafucka! Settin dis to
\&\fIN\fR means one frame up in every last muthafuckin batch of \fIN\fR frames is ghon be dropped.
Default is \f(CW5\fR.
.IP "\fBdupthresh\fR" 4
.IX Item "dupthresh"
Set tha threshold fo' duplicate detection. I aint talkin' bout chicken n' gravy biatch. If tha difference metric fo' a gangbangin' frame
is less than or equal ta dis value, then it is declared as duplicate. Default
is \f(CW1.1\fR
.IP "\fBscthresh\fR" 4
.IX Item "scthresh"
Set scene chizzle threshold. Y'all KNOW dat shit, muthafucka! Default is \f(CW15\fR.
.IP "\fBblockx\fR" 4
.IX Item "blockx"
.PD 0
.IP "\fBblocky\fR" 4
.IX Item "blocky"
.PD
Set tha size of tha x n' y\-axis blocks used durin metric calculations.
Larger blocks give betta noise suppression yo, but also give worse detection of
small movements, n' you can put dat on yo' toast. Must be a juice of two. Default is \f(CW32\fR.
.IP "\fBppsrc\fR" 4
.IX Item "ppsrc"
Mark main input as a pre-processed input n' activate clean source input
stream. This allows tha input ta be pre-processed wit various filtas ta help
the metrics calculation while keepin tha frame selection lossless. When set to
\&\f(CW1\fR, tha straight-up original gangsta stream is fo' tha pre-processed input, n' tha second
stream is tha clean source from where tha kept frames is chosen. I aint talkin' bout chicken n' gravy biatch. Default is
\&\f(CW0\fR.
.IP "\fBchroma\fR" 4
.IX Item "chroma"
Set whether or not chroma is considered up in tha metric calculations. Default is
\&\f(CW1\fR.
.SS "delogo"
.IX Subsection "delogo"
Suppress a \s-1TV\s0 station logo by a simple interpolation of tha surrounding
pixels. Just set a rectangle coverin tha logo n' peep it disappear
(and sometimes suttin' even uglier step tha fuck up \- yo' mileage may vary).
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Specify tha top left corner coordinatez of tha logo. They must be
specified.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Specify tha width n' height of tha logo ta clear. Shiiit, dis aint no joke. They must be
specified.
.IP "\fBband, t\fR" 4
.IX Item "band, t"
Specify tha thicknizz of tha fuzzy edge of tha rectangle (added to
\&\fIw\fR n' \fIh\fR). Da default value is 4.
.IP "\fBshow\fR" 4
.IX Item "show"
When set ta 1, a chronic rectangle is drawn on tha screen ta simplify
findin tha right \fIx\fR, \fIy\fR, \fIw\fR, n' \fIh\fR parameters.
Da default value is 0.
.Sp
Da rectangle is drawn on tha outermost pixels which is ghon be (partly)
replaced wit interpolated joints, n' you can put dat on yo' toast. Da jointz of tha next pixels
immediately outside dis rectangle up in each direction is ghon be used to
compute tha interpolated pixel joints inside tha rectangle.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set a rectangle coverin tha area wit top left corner coordinates 0,0
and size 100x77, settin a funky-ass crew of size 10:
.Sp
.Vb 1
\&        delogo=x=0:y=0:w=100:h=77:band=10
.Ve
.SS "deshake"
.IX Subsection "deshake"
Attempt ta fix lil' small-ass chizzlez up in horizontal and/or vertical shift. This
filta helps remove camera shake from hand-holdin a cold-ass lil camera, bumpin a
tripod, movin on a vehicle, etc.
.PP
Da filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.IP "\fBw\fR" 4
.IX Item "w"
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Specify a rectangular area where ta limit tha search fo' motion
vectors.
If desired tha search fo' motion vectors can be limited ta a
rectangular area of tha frame defined by its top left corner, width
and height. These parametas have tha same meanin as tha drawbox
filta which can be used ta visualise tha posizzle of tha bounding
box.
.Sp
This is useful when simultaneous movement of subjects within tha frame
might be trippin fo' camera motion by tha motion vector search.
.Sp
If any or all of \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR is set ta \-1
then tha full frame is used. Y'all KNOW dat shit, muthafucka! This allows lata options ta be set
without specifyin tha boundin box fo' tha motion vector search.
.Sp
Default \- search tha whole frame.
.IP "\fBrx\fR" 4
.IX Item "rx"
.PD 0
.IP "\fBry\fR" 4
.IX Item "ry"
.PD
Specify tha maximum extent of movement up in x n' y directions up in the
range 0\-64 pixels. Default 16.
.IP "\fBedge\fR" 4
.IX Item "edge"
Specify how tha fuck ta generate pixels ta fill blanks all up in tha edge of the
frame fo' realz. Available joints are:
.RS 4
.IP "\fBblank, 0\fR" 4
.IX Item "blank, 0"
Fill zeroes at blank locations
.IP "\fBoriginal, 1\fR" 4
.IX Item "original, 1"
Original Gangsta image at blank locations
.IP "\fBclamp, 2\fR" 4
.IX Item "clamp, 2"
Extruded edge value at blank locations
.IP "\fBmirror, 3\fR" 4
.IX Item "mirror, 3"
Mirrored edge at blank locations
.RE
.RS 4
.Sp
Default value is \fBmirror\fR.
.RE
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Specify tha blocksize ta use fo' motion search. Range 4\-128 pixels,
default 8.
.IP "\fBcontrast\fR" 4
.IX Item "contrast"
Specify tha contrast threshold fo' blocks. Only blocks wit mo' than
the specified contrast (difference between darkest n' lightest
pixels) is ghon be considered. Y'all KNOW dat shit, muthafucka! Range 1\-255, default 125.
.IP "\fBsearch\fR" 4
.IX Item "search"
Specify tha search game fo' realz. Available joints are:
.RS 4
.IP "\fBexhaustive, 0\fR" 4
.IX Item "exhaustive, 0"
Set exhaustizzle search
.IP "\fBless, 1\fR" 4
.IX Item "less, 1"
Set less exhaustizzle search.
.RE
.RS 4
.Sp
Default value is \fBexhaustive\fR.
.RE
.IP "\fBfilename\fR" 4
.IX Item "filename"
If set then a thugged-out detailed log of tha motion search is freestyled ta the
specified file.
.IP "\fBopencl\fR" 4
.IX Item "opencl"
If set ta 1, specify rockin OpenCL capabilities, only available if
FFmpeg was configured wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR. Default value is 0.
.SS "drawbox"
.IX Subsection "drawbox"
Draw a cold-ass lil colored box on tha input image.
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha top left corner coordinatez of tha box. Default ta 0.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Da expressions which specify tha width n' height of tha box, if 0 they is interpreted as
the input width n' height. Default ta 0.
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha box ta write. For tha general syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special
value \f(CW\*(C`invert\*(C'\fR is used, tha box edge color is tha same ol' dirty as the
video wit inverted luma.
.IP "\fBthickness, t\fR" 4
.IX Item "thickness, t"
Da expression which sets tha thicknizz of tha box edge. Default value is \f(CW3\fR.
.Sp
See below fo' tha list of accepted constants.
.PP
Da parametas fo' \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR n' \fIt\fR is expressions containin the
followin constants:
.IP "\fBdar\fR" 4
.IX Item "dar"
Da input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD 0
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD
Da input width n' height.
.IP "\fBsar\fR" 4
.IX Item "sar"
Da input sample aspect ratio.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da x n' y offset coordinates where tha box is drawn.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Da width n' height of tha drawn box.
.IP "\fBt\fR" 4
.IX Item "t"
Da thicknizz of tha drawn box.
.Sp
These constants allow tha \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR n' \fIt\fR expressions ta refer to
each other, so you may fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR or \f(CW\*(C`h=w/dar\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw a funky-ass black box round tha edge of tha input image:
.Sp
.Vb 1
\&        drawbox
.Ve
.IP "\(bu" 4
Draw a funky-ass box wit color red n' a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawbox=10:20:200:60:red@0.5
.Ve
.Sp
Da previous example can be specified as:
.Sp
.Vb 1
\&        drawbox=x=10:y=20:w=200:h=60:color=red@0.5
.Ve
.IP "\(bu" 4
Fill tha box wit pink color:
.Sp
.Vb 1
\&        drawbox=x=10:y=10:w=100:h=100:color=pink@0.5:t=max
.Ve
.IP "\(bu" 4
Draw a 2\-pixel red 2.40:1 mask:
.Sp
.Vb 1
\&        drawbox=x=\-t:y=0.5*(ih\-iw/2.4)\-t:w=iw+t*2:h=iw/2.4+t*2:t=2:c=red
.Ve
.SS "drawgrid"
.IX Subsection "drawgrid"
Draw a grid on tha input image.
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha coordinatez of some point of grid intersection (meant ta configure offset). Both default ta 0.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Da expressions which specify tha width n' height of tha grid cell, if 0 they is interpreted as the
input width n' height, respectively, minus \f(CW\*(C`thickness\*(C'\fR, so image gets
framed. Y'all KNOW dat shit, muthafucka! Default ta 0.
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha grid. Y'all KNOW dat shit, muthafucka! For tha general syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special
value \f(CW\*(C`invert\*(C'\fR is used, tha grid color is tha same ol' dirty as the
video wit inverted luma.
.IP "\fBthickness, t\fR" 4
.IX Item "thickness, t"
Da expression which sets tha thicknizz of tha grid line. Default value is \f(CW1\fR.
.Sp
See below fo' tha list of accepted constants.
.PP
Da parametas fo' \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR n' \fIt\fR is expressions containin the
followin constants:
.IP "\fBdar\fR" 4
.IX Item "dar"
Da input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD 0
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD
Da input grid cell width n' height.
.IP "\fBsar\fR" 4
.IX Item "sar"
Da input sample aspect ratio.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da x n' y coordinatez of some point of grid intersection (meant ta configure offset).
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Da width n' height of tha drawn cell.
.IP "\fBt\fR" 4
.IX Item "t"
Da thicknizz of tha drawn cell.
.Sp
These constants allow tha \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR n' \fIt\fR expressions ta refer to
each other, so you may fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR or \f(CW\*(C`h=w/dar\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw a grid wit cell 100x100 pixels, thicknizz 2 pixels, wit color red n' a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawgrid=width=100:height=100:thickness=2:color=red@0.5
.Ve
.IP "\(bu" 4
Draw a white 3x3 grid wit a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawgrid=w=iw/3:h=ih/3:t=2:c=white@0.5
.Ve
.SS "drawtext"
.IX Subsection "drawtext"
Draw text strang or text from specified file on top of vizzle rockin the
libfreetype library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libfreetype\*(C'\fR.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBbox\fR" 4
.IX Item "box"
Used ta draw a funky-ass box round text rockin background color.
Value should be either 1 (enable) or 0 (disable).
Da default value of \fIbox\fR is 0.
.IP "\fBboxcolor\fR" 4
.IX Item "boxcolor"
Da color ta be used fo' drawin box round text. For tha syntax of this
option, check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIboxcolor\fR is \*(L"white\*(R".
.IP "\fBexpansion\fR" 4
.IX Item "expansion"
Select how tha fuck tha \fItext\fR is expanded. Y'all KNOW dat shit, muthafucka! Can be either \f(CW\*(C`none\*(C'\fR,
\&\f(CW\*(C`strftime\*(C'\fR (deprecated) or
\&\f(CW\*(C`normal\*(C'\fR (default). Right back up in yo muthafuckin ass. See tha drawtext_expansion, Text expansion section
below fo' details.
.IP "\fBfix_bounds\fR" 4
.IX Item "fix_bounds"
If true, check n' fix text coordz ta avoid clipping.
.IP "\fBfontcolor\fR" 4
.IX Item "fontcolor"
Da color ta be used fo' drawin fonts, n' you can put dat on yo' toast. For tha syntax of dis option, check
the \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIfontcolor\fR is \*(L"black\*(R".
.IP "\fBfontfile\fR" 4
.IX Item "fontfile"
Da font file ta be used fo' drawin text. Path must be included.
This parameta is mandatory.
.IP "\fBfontsize\fR" 4
.IX Item "fontsize"
Da font size ta be used fo' drawin text.
Da default value of \fIfontsize\fR is 16.
.IP "\fBft_load_flags\fR" 4
.IX Item "ft_load_flags"
Flags ta be used fo' loadin tha fonts.
.Sp
Da flags map tha correspondin flags supported by libfreetype, n' are
a combination of tha followin joints:
.RS 4
.IP "\fIdefault\fR" 4
.IX Item "default"
.PD 0
.IP "\fIno_scale\fR" 4
.IX Item "no_scale"
.IP "\fIno_hinting\fR" 4
.IX Item "no_hinting"
.IP "\fIrender\fR" 4
.IX Item "render"
.IP "\fIno_bitmap\fR" 4
.IX Item "no_bitmap"
.IP "\fIvertical_layout\fR" 4
.IX Item "vertical_layout"
.IP "\fIforce_autohint\fR" 4
.IX Item "force_autohint"
.IP "\fIcrop_bitmap\fR" 4
.IX Item "crop_bitmap"
.IP "\fIpedantic\fR" 4
.IX Item "pedantic"
.IP "\fIignore_global_advance_width\fR" 4
.IX Item "ignore_global_advance_width"
.IP "\fIno_recurse\fR" 4
.IX Item "no_recurse"
.IP "\fIignore_transform\fR" 4
.IX Item "ignore_transform"
.IP "\fImonochrome\fR" 4
.IX Item "monochrome"
.IP "\fIlinear_design\fR" 4
.IX Item "linear_design"
.IP "\fIno_autohint\fR" 4
.IX Item "no_autohint"
.RE
.RS 4
.PD
.Sp
Default value is \*(L"render\*(R".
.Sp
For mo' shiznit consult tha documentation fo' tha FT_LOAD_*
libfreetype flags.
.RE
.IP "\fBshadowcolor\fR" 4
.IX Item "shadowcolor"
Da color ta be used fo' drawin a gangbangin' finger-lickin' dirty-ass shadow behind tha drawn text. For the
syntax of dis option, check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIshadowcolor\fR is \*(L"black\*(R".
.IP "\fBshadowx\fR" 4
.IX Item "shadowx"
.PD 0
.IP "\fBshadowy\fR" 4
.IX Item "shadowy"
.PD
Da x n' y offsets fo' tha text shadow posizzle wit respect ta the
posizzle of tha text. They can be either positizzle or negative
values. Default value fo' both is \*(L"0\*(R".
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Da startin frame number fo' tha n/frame_num variable. Da default value
is \*(L"0\*(R".
.IP "\fBtabsize\fR" 4
.IX Item "tabsize"
Da size up in number of spaces ta use fo' renderin tha tab.
Default value is 4.
.IP "\fBtimecode\fR" 4
.IX Item "timecode"
Set tha initial timecode representation up in \*(L"hh:mm:ss[:;.]ff\*(R"
format. Well shiiiit, it can be used wit or without text parameter n' shit. \fItimecode_rate\fR
option must be specified.
.IP "\fBtimecode_rate, rate, r\fR" 4
.IX Item "timecode_rate, rate, r"
Set tha timecode frame rate (timecode only).
.IP "\fBtext\fR" 4
.IX Item "text"
Da text strang ta be drawn. I aint talkin' bout chicken n' gravy biatch. Da text must be a sequence of \s-1UTF\-8\s0
encoded characters.
This parameta is mandatory if no file is specified wit tha parameter
\&\fItextfile\fR.
.IP "\fBtextfile\fR" 4
.IX Item "textfile"
A text file containin text ta be drawn. I aint talkin' bout chicken n' gravy biatch. Da text must be a sequence
of \s-1UTF\-8\s0 encoded characters.
.Sp
This parameta is mandatory if no text strang is specified wit the
parameta \fItext\fR.
.Sp
If both \fItext\fR n' \fItextfile\fR is specified, a error is thrown.
.IP "\fBreload\fR" 4
.IX Item "reload"
If set ta 1, tha \fItextfile\fR is ghon be reloaded before each frame.
Be shizzle ta update it atomically, or it may be read partially, or even fail.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha offsets where text is ghon be drawn
within tha vizzle frame. They is relatizzle ta tha top/left border of the
output image.
.Sp
Da default value of \fIx\fR n' \fIy\fR is \*(L"0\*(R".
.Sp
See below fo' tha list of accepted constants n' functions.
.PP
Da parametas fo' \fIx\fR n' \fIy\fR is expressions containin the
followin constants n' functions:
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBline_h, lh\fR" 4
.IX Item "line_h, lh"
the height of each text line
.IP "\fBmain_h, h, H\fR" 4
.IX Item "main_h, h, H"
the input height
.IP "\fBmain_w, w, W\fR" 4
.IX Item "main_w, w, W"
the input width
.IP "\fBmax_glyph_a, ascent\fR" 4
.IX Item "max_glyph_a, ascent"
the maximum distizzle from tha baseline ta tha highest/upper grid
coordinizzle used ta place a glyph outline point, fo' all tha rendered
glyphs.
It be a positizzle value, cuz of tha gridz orientation wit tha Y axis
upwards.
.IP "\fBmax_glyph_d, descent\fR" 4
.IX Item "max_glyph_d, descent"
the maximum distizzle from tha baseline ta tha lowest grid coordinate
used ta place a glyph outline point, fo' all tha rendered glyphs.
This be a wack value, cuz of tha gridz orientation, wit tha Y axis
upwards.
.IP "\fBmax_glyph_h\fR" 4
.IX Item "max_glyph_h"
maximum glyph height, dat is tha maximum height fo' all tha glyphs
contained up in tha rendered text, it is equivalent ta \fIascent\fR \-
\&\fIdescent\fR.
.IP "\fBmax_glyph_w\fR" 4
.IX Item "max_glyph_w"
maximum glyph width, dat is tha maximum width fo' all tha glyphs
contained up in tha rendered text
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBrand(min, max)\fR" 4
.IX Item "rand(min, max)"
return a random number included between \fImin\fR n' \fImax\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBtext_h, th\fR" 4
.IX Item "text_h, th"
the height of tha rendered text
.IP "\fBtext_w, tw\fR" 4
.IX Item "text_w, tw"
the width of tha rendered text
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the x n' y offset coordinates where tha text is drawn.
.Sp
These parametas allow tha \fIx\fR n' \fIy\fR expressions ta refer
each other, so you can fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR.
.PP
If libavfilta was built wit \f(CW\*(C`\-\-enable\-fontconfig\*(C'\fR, then
\&\fBfontfile\fR can be a gangbangin' fontconfig pattern or omitted.
.PP
\fIText expansion\fR
.IX Subsection "Text expansion"
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`strftime\*(C'\fR,
the filta recognizes \fIstrftime()\fR sequences up in tha provided text and
expandz dem accordingly. Peep tha documentation of \fIstrftime()\fR. This
feature is deprecated.
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`none\*(C'\fR, tha text is printed verbatim.
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`normal\*(C'\fR (which is tha default),
the followin expansion mechanizzle is used.
.PP
Da backslash characta '\e', followed by any character, always expandz to
the second character.
.PP
Sequence of tha form \f(CW\*(C`%{...}\*(C'\fR is expanded. Y'all KNOW dat shit, muthafucka! Da text between the
braces be a gangbangin' function name, possibly followed by arguments separated by ':'.
If tha arguments contain special charactas or delimitas (':' or '}'),
they should be escaped.
.PP
Note dat they probably must also be escaped as tha value fo' the
\&\fBtext\fR option up in tha filta argument strang n' as tha filter
argument up in tha filtergraph description, n' possibly also fo' tha shell,
that make up ta four levelz of escaping; rockin a text file avoidz these
problems.
.PP
Da followin functions is available:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Da expression evaluation result.
.Sp
It must take one argument specifyin tha expression ta be evaluated,
which accepts tha same ol' dirty constants n' functions as tha \fIx\fR and
\&\fIy\fR joints, n' you can put dat on yo' toast. Note dat not all constants should be used, for
example tha text size aint known when evaluatin tha expression, so
the constants \fItext_w\fR n' \fItext_h\fR gonna git a undefined
value.
.IP "\fBgmtime\fR" 4
.IX Item "gmtime"
Da time at which tha filta is hustlin, expressed up in \s-1UTC.\s0
It can accept a argument: a \fIstrftime()\fR format string.
.IP "\fBlocaltime\fR" 4
.IX Item "localtime"
Da time at which tha filta is hustlin, expressed up in tha local time unit.
It can accept a argument: a \fIstrftime()\fR format string.
.IP "\fBmetadata\fR" 4
.IX Item "metadata"
Frame metadata. Well shiiiit, it must take one argument specifyin metadata key.
.IP "\fBn, frame_num\fR" 4
.IX Item "n, frame_num"
Da frame number, startin from 0.
.IP "\fBpict_type\fR" 4
.IX Item "pict_type"
A 1 characta description of tha current picture type.
.IP "\fBpts\fR" 4
.IX Item "pts"
Da timestamp of tha current frame, up in seconds, wit microsecond accuracy.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw \*(L"Test Text\*(R" wit font FreeSerif, rockin tha default joints fo' the
optionizzle parameters.
.Sp
.Vb 1
\&        drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text=\*(AqTest Text\*(Aq"
.Ve
.IP "\(bu" 4
Draw 'Test Text' wit font FreeSerif of size 24 at posizzle x=100
and y=50 (countin from tha top-left corner of tha screen), text is
yellow wit a red box round dat shit. Both tha text n' tha box have an
opacitizzle of 20%.
.Sp
.Vb 2
\&        drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text=\*(AqTest Text\*(Aq:\e
\&                  x=100: y=50: fontsize=24: fontcolor=yellow@0.2: box=1: boxcolor=red@0.2"
.Ve
.Sp
Note dat tha double quotes is not necessary if spaces is not used
within tha parameta list.
.IP "\(bu" 4
Show tha text all up in tha centa of tha vizzle frame:
.Sp
.Vb 1
\&        drawtext="fontsize=30:fontfile=FreeSerif.ttf:text=\*(Aqwassup ghetto\*(Aq:x=(w\-text_w)/2:y=(h\-text_h\-line_h)/2"
.Ve
.IP "\(bu" 4
Show a text line slidin from right ta left up in tha last row of tha vizzle
frame. Da file \fI\s-1LONG_LINE\s0\fR be assumed ta contain a single line
with no newlines.
.Sp
.Vb 1
\&        drawtext="fontsize=15:fontfile=FreeSerif.ttf:text=LONG_LINE:y=h\-line_h:x=\-50*t"
.Ve
.IP "\(bu" 4
Show tha content of file \fI\s-1CREDITS\s0\fR off tha bottom of tha frame n' scroll up.
.Sp
.Vb 1
\&        drawtext="fontsize=20:fontfile=FreeSerif.ttf:textfile=CREDITS:y=h\-20*t"
.Ve
.IP "\(bu" 4
Draw a single chronic letta \*(L"g\*(R", all up in tha centa of tha input vizzle.
Da glyph baseline is placed at half screen height.
.Sp
.Vb 1
\&        drawtext="fontsize=60:fontfile=FreeSerif.ttf:fontcolor=green:text=g:x=(w\-max_glyph_w)/2:y=h/2\-ascent"
.Ve
.IP "\(bu" 4
Show text fo' 1 second every last muthafuckin 3 seconds:
.Sp
.Vb 1
\&        drawtext="fontfile=FreeSerif.ttf:fontcolor=white:x=100:y=x/dar:enable=lt(mod(t\e,3)\e,1):text=\*(Aqblink\*(Aq"
.Ve
.IP "\(bu" 4
Use fontconfig ta set tha font. Note dat tha colons need ta be escaped.
.Sp
.Vb 1
\&        drawtext=\*(Aqfontfile=Linux Libertine O\-40\e:style=Semibold:text=FFmpeg\*(Aq
.Ve
.IP "\(bu" 4
Print tha date of a real-time encodin (see \fIstrftime\fR\|(3)):
.Sp
.Vb 1
\&        drawtext=\*(Aqfontfile=FreeSans.ttf:text=%{localtime:%a %b %d %Y}\*(Aq
.Ve
.PP
For mo' shiznit bout libfreetype, check:
<\fBhttp://www.freetype.org/\fR>.
.PP
For mo' shiznit bout fontconfig, check:
<\fBhttp://freedesktop.org/software/fontconfig/fontconfig\-user.html\fR>.
.SS "edgedetect"
.IX Subsection "edgedetect"
Detect n' draw edges. Da filta uses tha Canny Edge Detection algorithm.
.PP
Da filta accepts tha followin options:
.IP "\fBlow\fR" 4
.IX Item "low"
.PD 0
.IP "\fBhigh\fR" 4
.IX Item "high"
.PD
Set low n' high threshold joints used by tha Canny thresholding
algorithm.
.Sp
Da high threshold selects tha \*(L"strong\*(R" edge pixels, which is then
connected all up in 8\-connectivitizzle wit tha \*(L"weak\*(R" edge pixels selected
by tha low threshold.
.Sp
\&\fIlow\fR n' \fIhigh\fR threshold joints must be chizzlen up in tha range
[0,1], n' \fIlow\fR should be lesser or equal ta \fIhigh\fR.
.Sp
Default value fo' \fIlow\fR is \f(CW\*(C`20/255\*(C'\fR, n' default value fo' \fIhigh\fR
is \f(CW\*(C`50/255\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&        edgedetect=low=0.1:high=0.4
.Ve
.SS "extractplanes"
.IX Subsection "extractplanes"
Extract color channel components from input vizzle stream into
separate grayscale vizzle streams.
.PP
Da filta accepts tha followin option:
.IP "\fBplanes\fR" 4
.IX Item "planes"
Set plane(s) ta extract.
.Sp
Available joints fo' planes are:
.RS 4
.IP "\fBy\fR" 4
.IX Item "y"
.PD 0
.IP "\fBu\fR" 4
.IX Item "u"
.IP "\fBv\fR" 4
.IX Item "v"
.IP "\fBa\fR" 4
.IX Item "a"
.IP "\fBr\fR" 4
.IX Item "r"
.IP "\fBg\fR" 4
.IX Item "g"
.IP "\fBb\fR" 4
.IX Item "b"
.RE
.RS 4
.PD
.Sp
Choosin planes not available up in tha input will result up in a error.
That means you cannot select \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR planes
with \f(CW\*(C`y\*(C'\fR, \f(CW\*(C`u\*(C'\fR, \f(CW\*(C`v\*(C'\fR planes at same time.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Extract luma, u n' v color channel component from input vizzle frame
into 3 grayscale outputs:
.Sp
.Vb 1
\&        ffmpeg \-i vizzle.avi \-filter_complex \*(Aqextractplanes=y+u+v[y][u][v]\*(Aq \-map \*(Aq[y]\*(Aq y.avi \-map \*(Aq[u]\*(Aq u.avi \-map \*(Aq[v]\*(Aq v.avi
.Ve
.SS "fade"
.IX Subsection "fade"
Apply fade\-in/out effect ta input vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBtype, t\fR" 4
.IX Item "type, t"
Da effect type \*(-- can be either \*(L"in\*(R" fo' fade-in, or \*(L"out\*(R" fo' a gangbangin' fade-out
effect.
Default is \f(CW\*(C`in\*(C'\fR.
.IP "\fBstart_frame, s\fR" 4
.IX Item "start_frame, s"
Specify tha number of tha start frame fo' startin ta apply tha fade
effect. Default is 0.
.IP "\fBnb_frames, n\fR" 4
.IX Item "nb_frames, n"
Da number of frames fo' which tha fade effect has ta last fo' realz. At tha end of the
fade-in effect tha output vizzle gonna git tha same intensitizzle as tha input vizzle,
at tha end of tha fade-out transizzle tha output vizzle is ghon be straight-up black.
Default is 25.
.IP "\fBalpha\fR" 4
.IX Item "alpha"
If set ta 1, fade only alpha channel, if one exists on tha input.
Default value is 0.
.IP "\fBstart_time, st\fR" 4
.IX Item "start_time, st"
Specify tha timestamp (in seconds) of tha frame ta start ta apply tha fade
effect. If both start_frame n' start_time is specified, tha fade will start at
whichever comes last.  Default is 0.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Da number of secondz fo' which tha fade effect has ta last fo' realz. At tha end of the
fade-in effect tha output vizzle gonna git tha same intensitizzle as tha input vizzle,
at tha end of tha fade-out transizzle tha output vizzle is ghon be straight-up black.
If both duration n' nb_frames is specified, duration is used. Y'all KNOW dat shit, muthafucka! Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Fade up in first 30 framez of vizzle:
.Sp
.Vb 1
\&        fade=in:0:30
.Ve
.Sp
Da command above is equivalent to:
.Sp
.Vb 1
\&        fade=t=in:s=0:n=30
.Ve
.IP "\(bu" 4
Fade up last 45 framez of a 200\-frame vizzle:
.Sp
.Vb 2
\&        fade=out:155:45
\&        fade=type=out:start_frame=155:nb_frames=45
.Ve
.IP "\(bu" 4
Fade up in first 25 frames n' fade up last 25 framez of a 1000\-frame vizzle:
.Sp
.Vb 1
\&        fade=in:0:25, fade=out:975:25
.Ve
.IP "\(bu" 4
Make first 5 frames black, then fade up in from frame 5\-24:
.Sp
.Vb 1
\&        fade=in:5:20
.Ve
.IP "\(bu" 4
Fade up in alpha over first 25 framez of vizzle:
.Sp
.Vb 1
\&        fade=in:0:25:alpha=1
.Ve
.IP "\(bu" 4
Make first 5.5 secondz black, then fade up in fo' 0.5 seconds:
.Sp
.Vb 1
\&        fade=t=in:st=5.5:d=0.5
.Ve
.SS "field"
.IX Subsection "field"
Extract a single field from a interlaced image rockin stride
arithmetic ta avoid wastin \s-1CPU\s0 time. Da output frames is marked as
non-interlaced.
.PP
Da filta accepts tha followin options:
.IP "\fBtype\fR" 4
.IX Item "type"
Specify whether ta extract tha top (if tha value is \f(CW0\fR or
\&\f(CW\*(C`top\*(C'\fR) or tha bottom field (if tha value is \f(CW1\fR or
\&\f(CW\*(C`bottom\*(C'\fR).
.SS "fieldmatch"
.IX Subsection "fieldmatch"
Field matchin filta fo' inverse telecine. Well shiiiit, it is meant ta reconstruct the
progressive frames from a telecined stream. Da filta do not drop duplicated
frames, so ta big up a cold-ass lil complete inverse telecine \f(CW\*(C`fieldmatch\*(C'\fR need ta be
followed by a thugged-out decimation filta like fuckin decimate up in tha filtergraph.
.PP
Da separation of tha field matchin n' tha decimation is notably motivated by
the possibilitizzle of insertin a thugged-out de-interlacin filta fallback between tha two.
If tha source has mixed telecined n' real interlaced content,
\&\f(CW\*(C`fieldmatch\*(C'\fR aint gonna be able ta match fieldz fo' tha interlaced parts.
But these remainin combed frames is ghon be marked as interlaced, n' thus can be
de-interlaced by a lata filta like fuckin yadif before decimation.
.PP
In addizzle ta tha various configuration options, \f(CW\*(C`fieldmatch\*(C'\fR can take an
optionizzle second stream, activated all up in tha \fBppsrc\fR option. I aint talkin' bout chicken n' gravy biatch. If
enabled, tha frames reconstruction is ghon be based on tha fieldz n' frames from
this second stream. This allows tha straight-up original gangsta input ta be pre-processed up in order to
help tha various algorithmz of tha filter, while keepin tha output lossless
(assumin tha fieldz is matched properly). Typically, a gangbangin' field-aware denoiser,
or brightness/contrast adjustments can help.
.PP
Note dat dis filta uses tha same ol' dirty algorithms as \s-1TIVTC/TFM \s0(AviSynth project)
and \s-1VIVTC/VFM \s0(VapourSynth project). Da lata be a light clone of \s-1TFM\s0 from
which \f(CW\*(C`fieldmatch\*(C'\fR is based on. I aint talkin' bout chicken n' gravy biatch. While tha semantic n' usage is hella
close, some behaviour n' options names can differ.
.PP
Da filta accepts tha followin options:
.IP "\fBorder\fR" 4
.IX Item "order"
Specify tha assumed field order of tha input stream fo' realz. Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Auto detect paritizzle (use FFmpegz internal paritizzle value).
.IP "\fBbff\fR" 4
.IX Item "bff"
Assume bottom field first.
.IP "\fBtff\fR" 4
.IX Item "tff"
Assume top field first.
.RE
.RS 4
.Sp
Note dat it is sometimes recommended not ta trust tha paritizzle announced by the
stream.
.Sp
Default value is \fIauto\fR.
.RE
.IP "\fBmode\fR" 4
.IX Item "mode"
Set tha matchin mode or game ta use. \fBpc\fR mode is tha safest up in the
sense dat it won't risk bustin jerkinizz cuz of duplicate frames when
possible yo, but if there be wack edits or blended fieldz it will end up
outputtin combed frames when a phat match might straight-up exist. On tha other
hand, \fBpcn_ub\fR mode is da most thugged-out risky up in termz of bustin jerkiness,
but will almost always find a phat frame if there is one. Da other joints are
all somewhere up in between \fBpc\fR n' \fBpcn_ub\fR up in termz of risking
jerkinizz n' bustin duplicate frames versus findin phat matches up in sections
with wack edits, orphaned fields, blended fields, etc.
.Sp
Mo' details bout p/c/n/u/b is available up in p/c/n/u/b meanin section.
.Sp
Available joints are:
.RS 4
.IP "\fBpc\fR" 4
.IX Item "pc"
2\-way matchin (p/c)
.IP "\fBpc_n\fR" 4
.IX Item "pc_n"
2\-way matching, n' tryin 3rd match if still combed (p/c + n)
.IP "\fBpc_u\fR" 4
.IX Item "pc_u"
2\-way matching, n' tryin 3rd match (same order) if still combed (p/c + u)
.IP "\fBpc_n_ub\fR" 4
.IX Item "pc_n_ub"
2\-way matching, tryin 3rd match if still combed, n' tryin 4th/5th matches if
still combed (p/c + n + u/b)
.IP "\fBpcn\fR" 4
.IX Item "pcn"
3\-way matchin (p/c/n)
.IP "\fBpcn_ub\fR" 4
.IX Item "pcn_ub"
3\-way matching, n' tryin 4th/5th matches if all 3 of tha original gangsta matches are
detected as combed (p/c/n + u/b)
.RE
.RS 4
.Sp
Da parenthesis all up in tha end indicate tha matches dat would be used fo' that
mode assumin \fBorder\fR=\fItff\fR (and \fBfield\fR on \fIauto\fR or
\&\fItop\fR).
.Sp
In termz of speed \fBpc\fR mode is by far tha fastest n' \fBpcn_ub\fR is
the slowest.
.Sp
Default value is \fIpc_n\fR.
.RE
.IP "\fBppsrc\fR" 4
.IX Item "ppsrc"
Mark tha main input stream as a pre-processed input, n' enable tha secondary
input stream as tha clean source ta pick tha fieldz from. Right back up in yo muthafuckin ass. See tha filter
introduction fo' mo' details. Well shiiiit, it is similar ta tha \fBclip2\fR feature from
\&\s-1VFM/TFM.\s0
.Sp
Default value is \f(CW0\fR (disabled).
.IP "\fBfield\fR" 4
.IX Item "field"
Set tha field ta match from. Well shiiiit, it is recommended ta set dis ta tha same value as
\&\fBorder\fR unless you experience matchin failures wit dat setting. In
certain circumstances changin tha field dat is used ta match from can have a
pimpin' impact on matchin performizzle fo' realz. Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Automatic (same value as \fBorder\fR).
.IP "\fBbottom\fR" 4
.IX Item "bottom"
Match from tha bottom field.
.IP "\fBtop\fR" 4
.IX Item "top"
Match from tha top field.
.RE
.RS 4
.Sp
Default value is \fIauto\fR.
.RE
.IP "\fBmchroma\fR" 4
.IX Item "mchroma"
Set whether or not chroma is included durin tha match comparisons. In most
cases it is recommended ta leave dis enabled. Y'all KNOW dat shit, muthafucka! Yo ass should set dis ta \f(CW0\fR
only if yo' clip has wack chroma problems like fuckin heavy rainbowin or other
artifacts, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Settin dis ta \f(CW0\fR could also be used ta speed thangs up at
the cost of some accuracy.
.Sp
Default value is \f(CW1\fR.
.IP "\fBy0\fR" 4
.IX Item "y0"
.PD 0
.IP "\fBy1\fR" 4
.IX Item "y1"
.PD
These define a exclusion crew which excludes tha lines between \fBy0\fR and
\&\fBy1\fR from bein included up in tha field matchin decision. I aint talkin' bout chicken n' gravy biatch fo' realz. An exclusion
band can be used ta ignore subtitles, a logo, or other thangs dat may
interfere wit tha matching. \fBy0\fR sets tha startin scan line and
\&\fBy1\fR sets tha endin line; all lines up in between \fBy0\fR and
\&\fBy1\fR (includin \fBy0\fR n' \fBy1\fR) is ghon be ignored. Y'all KNOW dat shit, muthafucka! Setting
\&\fBy0\fR n' \fBy1\fR ta tha same value will disable tha feature.
\&\fBy0\fR n' \fBy1\fR defaults ta \f(CW0\fR.
.IP "\fBscthresh\fR" 4
.IX Item "scthresh"
Set tha scene chizzle detection threshold as a cementage of maximum chizzle on
the luma plane. Dope joints is up in tha \f(CW\*(C`[8.0, 14.0]\*(C'\fR range. Right back up in yo muthafuckin ass. Scene chizzle
detection is only relevant up in case \fBcombmatch\fR=\fIsc\fR.  Da range for
\&\fBscthresh\fR is \f(CW\*(C`[0.0, 100.0]\*(C'\fR.
.Sp
Default value is \f(CW12.0\fR.
.IP "\fBcombmatch\fR" 4
.IX Item "combmatch"
When \fBcombatch\fR aint \fInone\fR, \f(CW\*(C`fieldmatch\*(C'\fR will take into
account tha combed scorez of matches when decidin what tha fuck match ta use as the
final match fo' realz. Available joints are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
No final matchin based on combed scores.
.IP "\fBsc\fR" 4
.IX Item "sc"
Combed scores is only used when a scene chizzle is detected.
.IP "\fBfull\fR" 4
.IX Item "full"
Use combed scores all tha time.
.RE
.RS 4
.Sp
Default is \fIsc\fR.
.RE
.IP "\fBcombdbg\fR" 4
.IX Item "combdbg"
Force \f(CW\*(C`fieldmatch\*(C'\fR ta calculate tha combed metrics fo' certain matches and
print em. This settin is known as \fBmicout\fR up in \s-1TFM/VFM\s0 vocabulary.
Available joints are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
No forced calculation.
.IP "\fBpcn\fR" 4
.IX Item "pcn"
Force p/c/n calculations.
.IP "\fBpcnub\fR" 4
.IX Item "pcnub"
Force p/c/n/u/b calculations.
.RE
.RS 4
.Sp
Default value is \fInone\fR.
.RE
.IP "\fBcthresh\fR" 4
.IX Item "cthresh"
This is tha area combin threshold used fo' combed frame detection. I aint talkin' bout chicken n' gravy biatch. This
essentially controls how tha fuck \*(L"strong\*(R" or \*(L"visible\*(R" combin must be ta be detected.
Larger joints mean combin must be mo' visible n' smalla joints mean combing
can be less visible or phat n' still be detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Valid settings is from
\&\f(CW\*(C`\-1\*(C'\fR (every pixel is ghon be detected as combed) ta \f(CW255\fR (no pixel will
be detected as combed). This is basically a pixel difference value fo' realz. A good
range is \f(CW\*(C`[8, 12]\*(C'\fR.
.Sp
Default value is \f(CW9\fR.
.IP "\fBchroma\fR" 4
.IX Item "chroma"
Sets whether or not chroma is considered up in tha combed frame decision. I aint talkin' bout chicken n' gravy biatch.  Only
disable dis if yo' source has chroma problems (rainbowing, etc.) dat are
causin problems fo' tha combed frame detection wit chroma enabled. Y'all KNOW dat shit, muthafucka! Actually,
usin \fBchroma\fR=\fI0\fR is probably mo' reliable, except fo' tha case
where there is chroma only combin up in tha source.
.Sp
Default value is \f(CW0\fR.
.IP "\fBblockx\fR" 4
.IX Item "blockx"
.PD 0
.IP "\fBblocky\fR" 4
.IX Item "blocky"
.PD
Respectively set tha x\-axis n' y\-axis size of tha window used durin combed
frame detection. I aint talkin' bout chicken n' gravy biatch. This has ta do wit tha size of tha area up in which
\&\fBcombpel\fR pixels is required ta be detected as combed fo' a gangbangin' frame ta be
declared combed. Y'all KNOW dat shit, muthafucka! See tha \fBcombpel\fR parameta description fo' mo' info.
Possible joints is any number dat be a juice of 2 startin at 4 n' goin up
to 512.
.Sp
Default value is \f(CW16\fR.
.IP "\fBcombpel\fR" 4
.IX Item "combpel"
Da number of combed pixels inside any of tha \fBblocky\fR by
\&\fBblockx\fR size blocks on tha frame fo' tha frame ta be detected as
combed. Y'all KNOW dat shit, muthafucka! While \fBcthresh\fR controls how tha fuck \*(L"visible\*(R" tha combin must be, this
settin controls \*(L"how much\*(R" combin there must be up in any localized area (a
window defined by tha \fBblockx\fR n' \fBblocky\fR settings) on the
frame. Minimum value is \f(CW0\fR n' maximum is \f(CW\*(C`blocky x blockx\*(C'\fR (at
which point no frames will eva be detected as combed). This settin is known
as \fB\s-1MI\s0\fR up in \s-1TFM/VFM\s0 vocabulary.
.Sp
Default value is \f(CW80\fR.
.PP
\fIp/c/n/u/b meaning\fR
.IX Subsection "p/c/n/u/b meaning"
.PP
p/c/n
.IX Subsection "p/c/n"
.PP
We assume tha followin telecined stream:
.PP
.Vb 2
\&        Top fields:     1 2 2 3 4
\&        Bottom fields:  1 2 3 4 4
.Ve
.PP
Da numbers correspond ta tha progressive frame tha fieldz relate ta yo. Here, the
first two frames is progressive, tha 3rd n' 4th is combed, n' so on.
.PP
When \f(CW\*(C`fieldmatch\*(C'\fR is configured ta run a matchin from bottom
(\fBfield\fR=\fIbottom\fR) dis is how tha fuck dis input stream git transformed:
.PP
.Vb 3
\&        Input stream:
\&                        T     1 2 2 3 4
\&                        B     1 2 3 4 4   <\-\- matchin reference
\&        
\&        Matches:              c c n n c
\&        
\&        Output stream:
\&                        T     1 2 3 4 4
\&                        B     1 2 3 4 4
.Ve
.PP
As a result of tha field matching, we can peep dat some frames git duplicated.
To big-ass up a cold-ass lil complete inverse telecine, you need ta rely on a thugged-out decimation filter
afta dis operation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See fo' instizzle tha decimate filter.
.PP
Da same operation now matchin from top fieldz (\fBfield\fR=\fItop\fR)
looks like this:
.PP
.Vb 3
\&        Input stream:
\&                        T     1 2 2 3 4   <\-\- matchin reference
\&                        B     1 2 3 4 4
\&        
\&        Matches:              c c p p c
\&        
\&        Output stream:
\&                        T     1 2 2 3 4
\&                        B     1 2 2 3 4
.Ve
.PP
In these examples, we can peep what tha fuck \fIp\fR, \fIc\fR n' \fIn\fR mean;
basically, they refer ta tha frame n' field of tha opposite parity:
.IP "*<\fIp\fR matches tha field of tha opposite paritizzle up in tha previous frame>" 4
.IX Item "*<p matches tha field of tha opposite paritizzle up in tha previous frame>"
.PD 0
.IP "*<\fIc\fR matches tha field of tha opposite paritizzle up in tha current frame>" 4
.IX Item "*<c matches tha field of tha opposite paritizzle up in tha current frame>"
.IP "*<\fIn\fR matches tha field of tha opposite paritizzle up in tha next frame>" 4
.IX Item "*<n matches tha field of tha opposite paritizzle up in tha next frame>"
.PD
.PP
u/b
.IX Subsection "u/b"
.PP
Da \fIu\fR n' \fIb\fR matchin is a lil' bit special up in tha sense dat they match
from tha opposite paritizzle flag. In tha followin examples, we assume dat we are
currently matchin tha 2nd frame (Top:2, bottom:2) fo' realz. Accordin ta tha match, a
\&'x' is placed above n' below each matched fields.
.PP
With bottom matchin (\fBfield\fR=\fIbottom\fR):
.PP
.Vb 1
\&        Match:           c         p           n          b          u
\&        
\&                         x       x               x        x          x
\&          Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
\&          Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
\&                         x         x           x        x              x
\&        
\&        Output frames:
\&                         2          1          2          2          2
\&                         2          2          2          1          3
.Ve
.PP
With top matchin (\fBfield\fR=\fItop\fR):
.PP
.Vb 1
\&        Match:           c         p           n          b          u
\&        
\&                         x         x           x        x              x
\&          Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
\&          Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
\&                         x       x               x        x          x
\&        
\&        Output frames:
\&                         2          2          2          1          2
\&                         2          1          3          2          2
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Simple \s-1IVTC\s0 of a top field first telecined stream:
.PP
.Vb 1
\&        fieldmatch=order=tff:combmatch=none, decimate
.Ve
.PP
Advanced \s-1IVTC,\s0 wit fallback on yadif fo' still combed frames:
.PP
.Vb 1
\&        fieldmatch=order=tff:combmatch=full, yadif=deint=interlaced, decimate
.Ve
.SS "fieldorder"
.IX Subsection "fieldorder"
Transform tha field order of tha input vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBorder\fR" 4
.IX Item "order"
Output field order n' shit. Valid joints is \fItff\fR fo' top field first or \fIbff\fR
for bottom field first.
.PP
Default value is \fBtff\fR.
.PP
Transformation be  bigged up  by shiftin tha picture content up or down
by one line, n' fillin tha remainin line wit appropriate picture content.
This method is consistent wit most broadcast field order converters.
.PP
If tha input vizzle aint flagged as bein interlaced, or it be already
flagged as bein of tha required output field order then dis filta do
not alta tha incomin vizzle.
.PP
This filta is straight-up useful when convertin ta or from \s-1PAL DV\s0 material,
which is bottom field first.
.PP
For example:
.PP
.Vb 1
\&        ffmpeg \-i in.vob \-vf "fieldorder=bff" out.dv
.Ve
.SS "fifo"
.IX Subsection "fifo"
Buffer input images n' bust dem when they is requested.
.PP
This filta is mainly useful when auto-inserted by tha libavfilter
framework.
.PP
Da filta do not take parameters.
.SS "format"
.IX Subsection "format"
Convert tha input vizzle ta one of tha specified pixel formats.
Libavfilta will try ta pick one dat is supported fo' tha input to
the next filter.
.PP
This filta accepts tha followin parameters:
.IP "\fBpix_fmts\fR" 4
.IX Item "pix_fmts"
A '|'\-separated list of pixel format names, fo' example
\&\*(L"pix_fmts=yuv420p|monow|rgb24\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert tha input vizzle ta tha format \fIyuv420p\fR
.Sp
.Vb 1
\&        format=pix_fmts=yuv420p
.Ve
.Sp
Convert tha input vizzle ta any of tha formats up in tha list
.Sp
.Vb 1
\&        format=pix_fmts=yuv420p|yuv444p|yuv410p
.Ve
.SS "fps"
.IX Subsection "fps"
Convert tha vizzle ta specified constant frame rate by duplicatin or dropping
frames as necessary.
.PP
This filta accepts tha followin named parameters:
.IP "\fBfps\fR" 4
.IX Item "fps"
Desired output frame rate. Da default is \f(CW25\fR.
.IP "\fBround\fR" 4
.IX Item "round"
Roundin method.
.Sp
Possible joints are:
.RS 4
.IP "\fBzero\fR" 4
.IX Item "zero"
zero round towardz 0
.IP "\fBinf\fR" 4
.IX Item "inf"
round away from 0
.IP "\fBdown\fR" 4
.IX Item "down"
round towardz \-infinity
.IP "\fBup\fR" 4
.IX Item "up"
round towardz +infinity
.IP "\fBnear\fR" 4
.IX Item "near"
round ta nearest
.RE
.RS 4
.Sp
Da default is \f(CW\*(C`near\*(C'\fR.
.RE
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Assume tha straight-up original gangsta \s-1PTS\s0 should be tha given value, up in seconds. This allows for
padding/trimmin all up in tha start of stream. By default, no assumption is made
about tha straight-up original gangsta framez expected \s-1PTS,\s0 so no paddin or trimmin is done.
For example, dis could be set ta 0 ta pad tha beginnin wit duplicates of
the first frame if a vizzle stream starts afta tha audio stream or ta trim any
frames wit a wack \s-1PTS.\s0
.PP
Alternatively, tha options can be specified as a gangbangin' flat string:
\&\fIfps\fR[:\fIround\fR].
.PP
See also tha setpts filter.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
A typical usage up in order ta set tha fps ta 25:
.Sp
.Vb 1
\&        fps=fps=25
.Ve
.IP "\(bu" 4
Sets tha fps ta 24, rockin abbreviation n' roundin method ta round ta nearest:
.Sp
.Vb 1
\&        fps=fps=film:round=near
.Ve
.SS "framestep"
.IX Subsection "framestep"
Select one frame every last muthafuckin N\-th frame.
.PP
This filta accepts tha followin option:
.IP "\fBstep\fR" 4
.IX Item "step"
Select frame afta every last muthafuckin \f(CW\*(C`step\*(C'\fR frames.
Allowed joints is positizzle integers higher than 0. Default value is \f(CW1\fR.
.SS "frei0r"
.IX Subsection "frei0r"
Apply a gangbangin' frei0r effect ta tha input vizzle.
.PP
To enable compilation of dis filta you need ta install tha frei0r
header n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-frei0r\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name ta tha frei0r effect ta load. Y'all KNOW dat shit, muthafucka! If tha environment variable
\&\fB\s-1FREI0R_PATH\s0\fR is defined, tha frei0r effect is searched up in each one of the
directories specified by tha colon separated list up in \fB\s-1FREIOR_PATH\s0\fR,
otherwise up in tha standard frei0r paths, which is up in dis order:
\&\fI\s-1HOME/\s0.frei0r\-1/lib/\fR, \fI/usr/local/lib/frei0r\-1/\fR,
\&\fI/usr/lib/frei0r\-1/\fR.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
A '|'\-separated list of parametas ta pass ta tha frei0r effect.
.PP
A frei0r effect parameta can be a funky-ass boolean (whose joints is specified
with \*(L"y\*(R" n' \*(L"n\*(R"), a thugged-out double, a cold-ass lil color (specified by tha syntax
\&\fIR\fR/\fIG\fR/\fIB\fR, (\fIR\fR, \fIG\fR, n' \fIB\fR bein float
numbers from 0.0 ta 1.0) or by a cold-ass lil color description specified up in tha \*(L"Color\*(R"
section up in tha ffmpeg-utils manual), a posizzle (specified by tha syntax \fIX\fR/\fIY\fR,
\&\fIX\fR n' \fIY\fR bein float numbers) n' a string.
.PP
Da number n' kind of parametas depend on tha loaded effect. If an
effect parameta aint specified tha default value is set.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply tha distort0r effect, set tha straight-up original gangsta two double parameters:
.Sp
.Vb 1
\&        frei0r=filter_name=distort0r:filter_params=0.5|0.01
.Ve
.IP "\(bu" 4
Apply tha colordistizzle effect, take a cold-ass lil color as first parameter:
.Sp
.Vb 3
\&        frei0r=colordistance:0.2/0.3/0.4
\&        frei0r=colordistance:violet
\&        frei0r=colordistance:0x112233
.Ve
.IP "\(bu" 4
Apply tha perspectizzle effect, specify tha top left n' top right image
positions:
.Sp
.Vb 1
\&        frei0r=perspective:0.2/0.2|0.8/0.2
.Ve
.PP
For mo' shiznit see:
<\fBhttp://frei0r.dyne.org\fR>
.SS "geq"
.IX Subsection "geq"
Da filta accepts tha followin options:
.IP "\fBlum_expr, lum\fR" 4
.IX Item "lum_expr, lum"
Set tha luminizzle expression.
.IP "\fBcb_expr, cb\fR" 4
.IX Item "cb_expr, cb"
Set tha chrominizzle blue expression.
.IP "\fBcr_expr, cr\fR" 4
.IX Item "cr_expr, cr"
Set tha chrominizzle red expression.
.IP "\fBalpha_expr, a\fR" 4
.IX Item "alpha_expr, a"
Set tha alpha expression.
.IP "\fBred_expr, r\fR" 4
.IX Item "red_expr, r"
Set tha red expression.
.IP "\fBgreen_expr, g\fR" 4
.IX Item "green_expr, g"
Set tha chronic expression.
.IP "\fBblue_expr, b\fR" 4
.IX Item "blue_expr, b"
Set tha blue expression.
.PP
Da colorspace is selected accordin ta tha specified options. If one
of tha \fBlum_expr\fR, \fBcb_expr\fR, or \fBcr_expr\fR
options is specified, tha filta will automatically select a YCbCr
colorspace. If one of tha \fBred_expr\fR, \fBgreen_expr\fR, or
\&\fBblue_expr\fR options is specified, it will select a \s-1RGB\s0
colorspace.
.PP
If one of tha chrominizzle expression aint defined, it falls back on tha other
one. If no alpha expression is specified it will evaluate ta opaque value.
If none of chrominizzle expressions is specified, they will evaluate
to tha luminizzle expression.
.PP
Da expressions can use tha followin variablez n' functions:
.IP "\fBN\fR" 4
.IX Item "N"
Da sequential number of tha filtered frame, startin from \f(CW0\fR.
.IP "\fBX\fR" 4
.IX Item "X"
.PD 0
.IP "\fBY\fR" 4
.IX Item "Y"
.PD
Da coordinatez of tha current sample.
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
Da width n' height of tha image.
.IP "\fB\s-1SW\s0\fR" 4
.IX Item "SW"
.PD 0
.IP "\fB\s-1SH\s0\fR" 4
.IX Item "SH"
.PD
Width n' height scale dependin on tha currently filtered plane. Well shiiiit, it is the
ratio between tha correspondin luma plane number of pixels n' tha current
plane ones. E.g. fo' \s-1YUV4:2:0\s0 tha joints is \f(CW\*(C`1,1\*(C'\fR fo' tha luma plane, and
\&\f(CW\*(C`0.5,0.5\*(C'\fR fo' chroma planes.
.IP "\fBT\fR" 4
.IX Item "T"
Time of tha current frame, expressed up in seconds.
.IP "\fBp(x, y)\fR" 4
.IX Item "p(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha current
plane.
.IP "\fBlum(x, y)\fR" 4
.IX Item "lum(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha luminance
plane.
.IP "\fBcb(x, y)\fR" 4
.IX Item "cb(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
blue-difference chroma plane. Return 0 if there is no such plane.
.IP "\fBcr(x, y)\fR" 4
.IX Item "cr(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
red-difference chroma plane. Return 0 if there is no such plane.
.IP "\fBr(x, y)\fR" 4
.IX Item "r(x, y)"
.PD 0
.IP "\fBg(x, y)\fR" 4
.IX Item "g(x, y)"
.IP "\fBb(x, y)\fR" 4
.IX Item "b(x, y)"
.PD
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
red/green/blue component. Return 0 if there is no such component.
.IP "\fBalpha(x, y)\fR" 4
.IX Item "alpha(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha alpha
plane. Return 0 if there is no such plane.
.PP
For functions, if \fIx\fR n' \fIy\fR is outside tha area, tha value will be
automatically clipped ta tha closer edge.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Flip tha image horizontally:
.Sp
.Vb 1
\&        geq=p(W\-X\e,Y)
.Ve
.IP "\(bu" 4
Generate a funky-ass bidimensionizzle sine wave, wit angle \f(CW\*(C`PI/3\*(C'\fR n' a
wavelength of 100 pixels:
.Sp
.Vb 1
\&        geq=128 + 100*sin(2*(PI/100)*(cos(PI/3)*(X\-50*T) + sin(PI/3)*Y)):128:128
.Ve
.IP "\(bu" 4
Generate a gangbangin' fancy enigmatic movin light:
.Sp
.Vb 1
\&        nullsrc=s=256x256,geq=random(1)/hypot(X\-cos(N*0.07)*W/2\-W/2\e,Y\-sin(N*0.09)*H/2\-H/2)^2*1000000*sin(N*0.02):128:128
.Ve
.IP "\(bu" 4
Generate a quick emboss effect:
.Sp
.Vb 1
\&        format=gray,geq=lum_expr=\*(Aq(p(X,Y)+(256\-p(X\-4,Y\-4)))/2\*(Aq
.Ve
.IP "\(bu" 4
Modify \s-1RGB\s0 components dependin on pixel position:
.Sp
.Vb 1
\&        geq=r=\*(AqX/W*r(X,Y)\*(Aq:g=\*(Aq(1\-X/W)*g(X,Y)\*(Aq:b=\*(Aq(H\-Y)/H*b(X,Y)\*(Aq
.Ve
.SS "gradfun"
.IX Subsection "gradfun"
Fix tha bandin artifacts dat is sometimes introduced tha fuck into nearly flat
regions by truncation ta 8bit color depth.
Interpolate tha gradients dat should go where tha bandz are, and
dither em.
.PP
This filta is designed fo' playback only.  Do not use it prior to
lossy compression, cuz compression tendz ta lose tha dither and
brin back tha bands.
.PP
This filta accepts tha followin options:
.IP "\fBstrength\fR" 4
.IX Item "strength"
Da maximum amount by which tha filta will chizzle any one pixel fo' realz. Also the
threshold fo' detectin nearly flat regions fo' realz. Acceptable joints range from .51 to
64, default value is 1.2, out-of-range joints is ghon be clipped ta tha valid
range.
.IP "\fBradius\fR" 4
.IX Item "radius"
Da hood ta fit tha gradient ta fo' realz. A larger radius make fo' smoother
gradients yo, but also prevents tha filta from modifyin tha pixels near detailed
regions fo' realz. Acceptable joints is 8\-32, default value is 16, out-of-range joints
will be clipped ta tha valid range.
.PP
Alternatively, tha options can be specified as a gangbangin' flat string:
\&\fIstrength\fR[:\fIradius\fR]
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply tha filta wit a \f(CW3.5\fR strength n' radiuz of \f(CW8\fR:
.Sp
.Vb 1
\&        gradfun=3.5:8
.Ve
.IP "\(bu" 4
Specify radius, omittin tha strength (which will fall-back ta tha default
value):
.Sp
.Vb 1
\&        gradfun=radius=8
.Ve
.SS "haldclut"
.IX Subsection "haldclut"
Apply a Hald \s-1CLUT\s0 ta a vizzle stream.
.PP
First input is tha vizzle stream ta process, n' second one is tha Hald \s-1CLUT.\s0
Da Hald \s-1CLUT\s0 input can be a simple picture or a cold-ass lil complete vizzle stream.
.PP
Da filta accepts tha followin options:
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Force termination when tha shortest input terminates. Default is \f(CW0\fR.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
Continue applyin tha last \s-1CLUT\s0 afta tha end of tha stream fo' realz. A value of
\&\f(CW0\fR disable tha filta afta tha last frame of tha \s-1CLUT\s0 is reached.
Default is \f(CW1\fR.
.PP
\&\f(CW\*(C`haldclut\*(C'\fR also has tha same ol' dirty interpolation options as lut3d (both
filtas share tha same internals).
.PP
Mo' shiznit bout tha Hald \s-1CLUT\s0 can be found on Eskil Steenbergz joint
(Hald \s-1CLUT\s0 author) at <\fBhttp://www.quelsolaar.com/technology/clut.html\fR>.
.PP
\fIWorkflow examples\fR
.IX Subsection "Workflow examples"
.PP
Hald \s-1CLUT\s0 vizzle stream
.IX Subsection "Hald CLUT vizzle stream"
.PP
Generate a identitizzle Hald \s-1CLUT\s0 stream altered wit various effects:
.PP
.Vb 1
\&        ffmpeg \-f lavfi \-i haldclutsrc=8 \-vf "hue=H=2*PI*t:s=sin(2*PI*t)+1, curves=cross_process" \-t 10 \-c:v ffv1 clut.nut
.Ve
.PP
Note: make shizzle you bust a lossless codec.
.PP
Then use it wit \f(CW\*(C`haldclut\*(C'\fR ta apply it on some random stream:
.PP
.Vb 1
\&        ffmpeg \-f lavfi \-i mandelbrot \-i clut.nut \-filter_complex \*(Aq[0][1] haldclut\*(Aq \-t 20 mandelclut.mkv
.Ve
.PP
Da Hald \s-1CLUT\s0 is ghon be applied ta tha 10 first secondz (duration of
\&\fIclut.nut\fR), then tha sickest fuckin picture of dat \s-1CLUT\s0 stream is ghon be applied
to tha remainin framez of tha \f(CW\*(C`mandelbrot\*(C'\fR stream.
.PP
Hald \s-1CLUT\s0 wit peepshow
.IX Subsection "Hald CLUT wit peepshow"
.PP
A Hald \s-1CLUT\s0 is supposed ta be a squared image of \f(CW\*(C`Level*Level*Level\*(C'\fR by
\&\f(CW\*(C`Level*Level*Level\*(C'\fR pixels. For a given Hald \s-1CLUT,\s0 FFmpeg will select the
biggest possible square startin all up in tha top left of tha picture. Da remaining
paddin pixels (bottom or right) is ghon be ignored. Y'all KNOW dat shit, muthafucka! This area can be used ta add
a peepshow of tha Hald \s-1CLUT.\s0
.PP
Typically, tha followin generated Hald \s-1CLUT\s0 is ghon be supported by the
\&\f(CW\*(C`haldclut\*(C'\fR filter:
.PP
.Vb 5
\&        ffmpeg \-f lavfi \-i haldclutsrc=8 \-vf "
\&           pad=iw+320 [padded_clut];
\&           smptebars=s=320x256, split [a][b];
\&           [padded_clut][a] overlay=W\-320:h, curves=color_negatizzle [main];
\&           [main][b] overlay=W\-320" \-frames:v 1 clut.png
.Ve
.PP
It gotz nuff tha original gangsta n' a peepshow of tha effect of tha \s-1CLUT: SMPTE\s0 color
bars is displayed on tha right-top, n' below tha same color bars processed by
the color chizzles.
.PP
Then, tha effect of dis Hald \s-1CLUT\s0 can be visualized with:
.PP
.Vb 1
\&        ffplay input.mkv \-vf "movie=clut.png, [in] haldclut"
.Ve
.SS "hflip"
.IX Subsection "hflip"
Flip tha input vizzle horizontally.
.PP
For example ta horizontally flip tha input vizzle wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vf "hflip" out.avi
.Ve
.SS "histeq"
.IX Subsection "histeq"
This filta applies a global color histogram equalization on a
per-frame basis.
.PP
It can be used ta erect vizzle dat has a cold-ass lil compressed range of pixel
intensities. Put ya muthafuckin choppers up if ya feel dis!  Da filta redistributes tha pixel intensitizzles to
equalize they distribution across tha intensitizzle range. Well shiiiit, it may be
viewed as a \*(L"automatically adjustin contrast filter\*(R". This filta is
useful only fo' erectin degraded or skankyly captured source
video.
.PP
Da filta accepts tha followin options:
.IP "\fBstrength\fR" 4
.IX Item "strength"
Determine tha amount of equalization ta be applied. Y'all KNOW dat shit, muthafucka!  As tha strength
is reduced, tha distribution of pixel intensitizzles more-and-more
approaches dat of tha input frame. Da value must be a gangbangin' float number
in tha range [0,1] n' defaults ta 0.200.
.IP "\fBintensity\fR" 4
.IX Item "intensity"
Set tha maximum intensitizzle dat can generated n' scale tha output
values appropriately.  Da strength should be set as desired n' then
the intensitizzle can be limited if needed ta avoid washing-out. Da value
must be a gangbangin' float number up in tha range [0,1] n' defaults ta 0.210.
.IP "\fBantibanding\fR" 4
.IX Item "antibanding"
Set tha antibandin level. If enabled tha filta will randomly vary
the luminizzle of output pixels by a lil' small-ass amount ta avoid bandin of
the histogram. Possible joints is \f(CW\*(C`none\*(C'\fR, \f(CW\*(C`weak\*(C'\fR or
\&\f(CW\*(C`strong\*(C'\fR. Well shiiiit, it defaults ta \f(CW\*(C`none\*(C'\fR.
.SS "histogram"
.IX Subsection "histogram"
Compute n' draw a cold-ass lil color distribution histogram fo' tha input vizzle.
.PP
Da computed histogram be a representation of distribution of color components
in a image.
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Set histogram mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlevels\fR" 4
.IX Item "levels"
standard histogram dat display color components distribution up in a image.
Displays color graph fo' each color component. Right back up in yo muthafuckin ass. Shows distribution
of tha Y, U, V, A or R, G, B components, dependin on input format,
in current frame. Bellow each graph is color component scale meter.
.IP "\fBcolor\fR" 4
.IX Item "color"
chroma joints up in vectorscope, if brighta mo' such chroma joints are
distributed up in a image.
Displays chroma joints (U/V color placement) up in two dimensionizzle graph
(which is called a vectorscope). Well shiiiit, it can be used ta read of tha hue and
saturation of tha current frame fo' realz. At a same time it aint nuthin but a histogram.
Da whita a pixel up in tha vectorscope, tha mo' pixelz of tha input frame
correspond ta dat pixel (that is tha mo' pixels have dis chroma value).
Da V component is displayed on tha horizontal (X) axis, wit tha leftmost
side bein V = 0 n' tha rightmost side bein V = 255.
Da U component is displayed on tha vertical (Y) axis, wit tha top
representin U = 0 n' tha bottom representin U = 255.
.Sp
Da posizzle of a white pixel up in tha graph correspondz ta tha chroma value
of a pixel of tha input clip. Right back up in yo muthafuckin ass. So tha graph can be used ta read of the
hue (color flavor) n' tha saturation (the dominizzle of tha hue up in tha color).
As tha hue of a cold-ass lil color chizzles, it moves round tha square fo' realz. At tha centa of
the square, tha saturation is zero, which means dat tha correspondin pixel
has no color. Shiiit, dis aint no joke. If you increase tha amount of a specific color, while leaving
the other flavas unchanged, tha saturation increases, n' you move towards
the edge of tha square.
.IP "\fBcolor2\fR" 4
.IX Item "color2"
chroma joints up in vectorscope, similar as \f(CW\*(C`color\*(C'\fR but actual chroma joints
are displayed.
.IP "\fBwaveform\fR" 4
.IX Item "waveform"
per row/column color component graph. In row mode graph up in tha left side represents
color component value 0 n' right side represents value = 255. In column mode top
side represents color component value = 0 n' bottom side represents value = 255.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`levels\*(C'\fR.
.RE
.IP "\fBlevel_height\fR" 4
.IX Item "level_height"
Set height of level up in \f(CW\*(C`levels\*(C'\fR. Default value is \f(CW200\fR.
Allowed range is [50, 2048].
.IP "\fBscale_height\fR" 4
.IX Item "scale_height"
Set height of color scale up in \f(CW\*(C`levels\*(C'\fR. Default value is \f(CW12\fR.
Allowed range is [0, 40].
.IP "\fBstep\fR" 4
.IX Item "step"
Set step fo' \f(CW\*(C`waveform\*(C'\fR mode. Right back up in yo muthafuckin ass. Smalla joints is useful ta smoke up how tha fuck much
of same luminizzle joints across input rows/columns is distributed.
Default value is \f(CW10\fR fo' realz. Allowed range is [1, 255].
.IP "\fBwaveform_mode\fR" 4
.IX Item "waveform_mode"
Set mode fo' \f(CW\*(C`waveform\*(C'\fR. Can be either \f(CW\*(C`row\*(C'\fR, or \f(CW\*(C`column\*(C'\fR.
Default is \f(CW\*(C`row\*(C'\fR.
.IP "\fBwaveform_mirror\fR" 4
.IX Item "waveform_mirror"
Set mirrorin mode fo' \f(CW\*(C`waveform\*(C'\fR. \f(CW0\fR means unmirrored, \f(CW1\fR
means mirrored. Y'all KNOW dat shit, muthafucka! In mirrored mode, higher joints is ghon be represented on tha left
side fo' \f(CW\*(C`row\*(C'\fR mode n' all up in tha top fo' \f(CW\*(C`column\*(C'\fR mode. Default is
\&\f(CW0\fR (unmirrored).
.IP "\fBdisplay_mode\fR" 4
.IX Item "display_mode"
Set display mode fo' \f(CW\*(C`waveform\*(C'\fR n' \f(CW\*(C`levels\*(C'\fR.
It accepts tha followin joints:
.RS 4
.IP "\fBparade\fR" 4
.IX Item "parade"
Display separate graph fo' tha color components side by side in
\&\f(CW\*(C`row\*(C'\fR waveform mode or one below other up in \f(CW\*(C`column\*(C'\fR waveform mode
for \f(CW\*(C`waveform\*(C'\fR histogram mode. For \f(CW\*(C`levels\*(C'\fR histogram mode
per color component graphs is placed one bellow other.
.Sp
This display mode up in \f(CW\*(C`waveform\*(C'\fR histogram mode make it easy as fuck  ta spot
color casts up in tha highlights n' shadowz of a image, by comparin the
contourz of tha top n' tha bottom of each waveform.
Since whites, grays, n' blacks is characterized by
exactly equal amountz of red, green, n' blue, neutral areaz of the
picture should display three waveformz of roughly equal width/height.
If not, tha erection is easy as fuck  ta make by makin adjustments ta level the
three waveforms.
.IP "\fBoverlay\fR" 4
.IX Item "overlay"
Presents shiznit thatz identical ta dat up in tha \f(CW\*(C`parade\*(C'\fR, except
that tha graphs representin color components is superimposed directly
over one another.
.Sp
This display mode up in \f(CW\*(C`waveform\*(C'\fR histogram mode can make it easier ta spot
the relatizzle differences or similaritizzles up in overlappin areaz of tha color
components dat is supposed ta be identical, like fuckin neutral whites, grays,
or blacks.
.RE
.RS 4
.Sp
Default is \f(CW\*(C`parade\*(C'\fR.
.RE
.IP "\fBlevels_mode\fR" 4
.IX Item "levels_mode"
Set mode fo' \f(CW\*(C`levels\*(C'\fR. Can be either \f(CW\*(C`linear\*(C'\fR, or \f(CW\*(C`logarithmic\*(C'\fR.
Default is \f(CW\*(C`linear\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Calculate n' draw histogram:
.Sp
.Vb 1
\&        ffplay \-i input \-vf histogram
.Ve
.SS "hqdn3d"
.IX Subsection "hqdn3d"
High precision/qualitizzle 3d denoise filter n' shit. This filta aims ta reduce
image noise producin smooth images n' makin still images straight-up
still. Well shiiiit, it should enhizzle compressibility.
.PP
It accepts tha followin optionizzle parameters:
.IP "\fBluma_spatial\fR" 4
.IX Item "luma_spatial"
a non-negatizzle float number which specifies spatial luma strength,
defaults ta 4.0
.IP "\fBchroma_spatial\fR" 4
.IX Item "chroma_spatial"
a non-negatizzle float number which specifies spatial chroma strength,
defaults ta 3.0*\fIluma_spatial\fR/4.0
.IP "\fBluma_tmp\fR" 4
.IX Item "luma_tmp"
a float number which specifies luma temporal strength, defaults to
6.0*\fIluma_spatial\fR/4.0
.IP "\fBchroma_tmp\fR" 4
.IX Item "chroma_tmp"
a float number which specifies chroma temporal strength, defaults to
\&\fIluma_tmp\fR*\fIchroma_spatial\fR/\fIluma_spatial\fR
.SS "hue"
.IX Subsection "hue"
Modify tha hue and/or tha saturation of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBh\fR" 4
.IX Item "h"
Specify tha hue angle as a fuckin shitload of degrees. Well shiiiit, it accepts a expression,
and defaults ta \*(L"0\*(R".
.IP "\fBs\fR" 4
.IX Item "s"
Specify tha saturation up in tha [\-10,10] range. Well shiiiit, it accepts a expression and
defaults ta \*(L"1\*(R".
.IP "\fBH\fR" 4
.IX Item "H"
Specify tha hue angle as a fuckin shitload of radians. Well shiiiit, it accepts an
expression, n' defaults ta \*(L"0\*(R".
.IP "\fBb\fR" 4
.IX Item "b"
Specify tha brightnizz up in tha [\-10,10] range. Well shiiiit, it accepts a expression and
defaults ta \*(L"0\*(R".
.PP
\&\fBh\fR n' \fBH\fR is mutually exclusive, n' can't be
specified all up in tha same time.
.PP
Da \fBb\fR, \fBh\fR, \fBH\fR n' \fBs\fR option joints are
expressions containin tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
frame count of tha input frame startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
presentation timestamp of tha input frame expressed up in time base units
.IP "\fBr\fR" 4
.IX Item "r"
frame rate of tha input vizzle, \s-1NAN\s0 if tha input frame rate is unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBtb\fR" 4
.IX Item "tb"
time base of tha input vizzle
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha hue ta 90 degrees n' tha saturation ta 1.0:
.Sp
.Vb 1
\&        hue=h=90:s=1
.Ve
.IP "\(bu" 4
Same command but expressin tha hue up in radians:
.Sp
.Vb 1
\&        hue=H=PI/2:s=1
.Ve
.IP "\(bu" 4
Rotate hue n' make tha saturation swin between 0
and 2 over a period of 1 second:
.Sp
.Vb 1
\&        hue="H=2*PI*t: s=sin(2*PI*t)+1"
.Ve
.IP "\(bu" 4
Apply a 3 secondz saturation fade-in effect startin at 0:
.Sp
.Vb 1
\&        hue="s=min(t/3\e,1)"
.Ve
.Sp
Da general fade-in expression can be freestyled as:
.Sp
.Vb 1
\&        hue="s=min(0\e, max((t\-START)/DURATION\e, 1))"
.Ve
.IP "\(bu" 4
Apply a 3 secondz saturation fade-out effect startin at 5 seconds:
.Sp
.Vb 1
\&        hue="s=max(0\e, min(1\e, (8\-t)/3))"
.Ve
.Sp
Da general fade-out expression can be freestyled as:
.Sp
.Vb 1
\&        hue="s=max(0\e, min(1\e, (START+DURATION\-t)/DURATION))"
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBb\fR" 4
.IX Item "b"
.PD 0
.IP "\fBs\fR" 4
.IX Item "s"
.IP "\fBh\fR" 4
.IX Item "h"
.IP "\fBH\fR" 4
.IX Item "H"
.PD
Modify tha hue and/or tha saturation and/or brightnizz of tha input vizzle.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.SS "idet"
.IX Subsection "idet"
Detect vizzle interlacin type.
.PP
This filta tries ta detect if tha input is interlaced or progressive,
top or bottom field first.
.PP
Da filta accepts tha followin options:
.IP "\fBintl_thres\fR" 4
.IX Item "intl_thres"
Set interlacin threshold.
.IP "\fBprog_thres\fR" 4
.IX Item "prog_thres"
Set progressive threshold.
.SS "il"
.IX Subsection "il"
Deinterleave or interleave fields.
.PP
This filta allows ta process interlaced images fieldz without
deinterlacin em. Deinterleavin splits tha input frame tha fuck into 2
fieldz (so called half pictures). Odd lines is moved ta tha top
half of tha output image, even lines ta tha bottom half.
Yo ass can process (filter) dem independently n' then re-interleave em.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_mode, l\fR" 4
.IX Item "luma_mode, l"
.PD 0
.IP "\fBchroma_mode, c\fR" 4
.IX Item "chroma_mode, c"
.IP "\fBalpha_mode, a\fR" 4
.IX Item "alpha_mode, a"
.PD
Available joints fo' \fIluma_mode\fR, \fIchroma_mode\fR and
\&\fIalpha_mode\fR are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Do nothing.
.IP "\fBdeinterleave, d\fR" 4
.IX Item "deinterleave, d"
Deinterleave fields, placin one above tha other.
.IP "\fBinterleave, i\fR" 4
.IX Item "interleave, i"
Interleave fields. Reverse tha effect of deinterleaving.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`none\*(C'\fR.
.RE
.IP "\fBluma_swap, ls\fR" 4
.IX Item "luma_swap, ls"
.PD 0
.IP "\fBchroma_swap, cs\fR" 4
.IX Item "chroma_swap, cs"
.IP "\fBalpha_swap, as\fR" 4
.IX Item "alpha_swap, as"
.PD
Swap luma/chroma/alpha fields. Exchange even & odd lines. Default value is \f(CW0\fR.
.SS "interlace"
.IX Subsection "interlace"
Simple interlacin filta from progressive contents, n' you can put dat on yo' toast. This interleaves upper (or
lower) lines from odd frames wit lower (or upper) lines from even frames,
halvin tha frame rate n' preservin image height.
.PP
.Vb 9
\&           Original Gangsta        Original Gangsta             New Frame
\&           Frame \*(Aqj\*(Aq      Frame \*(Aqj+1\*(Aq             (tff)
\&          ==========      ===========       ==================
\&            Line 0  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->    Frame \*(Aqj\*(Aq Line 0
\&            Line 1          Line 1  \-\-\-\->   Frame \*(Aqj+1\*(Aq Line 1
\&            Line 2 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->    Frame \*(Aqj\*(Aq Line 2
\&            Line 3          Line 3  \-\-\-\->   Frame \*(Aqj+1\*(Aq Line 3
\&             ...             ...                   ...
\&        New Frame + 1 is ghon be generated by Frame \*(Aqj+2\*(Aq n' Frame \*(Aqj+3\*(Aq n' so on
.Ve
.PP
It accepts tha followin optionizzle parameters:
.IP "\fBscan\fR" 4
.IX Item "scan"
determines whether tha interlaced frame is taken from tha even (tff \- default)
or odd (bff) linez of tha progressive frame.
.IP "\fBlowpass\fR" 4
.IX Item "lowpass"
Enable (default) or disable tha vertical lowpass filta ta avoid twitter
interlacin n' reduce moire patterns.
.SS "kerndeint"
.IX Subsection "kerndeint"
Deinterlace input vizzle by applyin Dizzle Graftz adaptizzle kernel
deinterling. Work on interlaced partz of a vizzle ta produce
progressive frames.
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBthresh\fR" 4
.IX Item "thresh"
Set tha threshold which affects tha filterz tolerizzle when
determinin if a pixel line must be processed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it must be a integer
in tha range [0,255] n' defaults ta 10 fo' realz. A value of 0 will result in
applyin tha process on every last muthafuckin pixels.
.IP "\fBmap\fR" 4
.IX Item "map"
Paint pixels exceedin tha threshold value ta white if set ta 1.
Default is 0.
.IP "\fBorder\fR" 4
.IX Item "order"
Set tha fieldz order n' shit. Right back up in yo muthafuckin ass. Swap fieldz if set ta 1, leave fieldz ridin' solo if
0. Default is 0.
.IP "\fBsharp\fR" 4
.IX Item "sharp"
Enable additionizzle sharpenin if set ta 1. Default is 0.
.IP "\fBtwoway\fR" 4
.IX Item "twoway"
Enable twoway sharpenin if set ta 1. Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply default joints:
.Sp
.Vb 1
\&        kerndeint=thresh=10:map=0:order=0:sharp=0:twoway=0
.Ve
.IP "\(bu" 4
Enable additionizzle sharpening:
.Sp
.Vb 1
\&        kerndeint=sharp=1
.Ve
.IP "\(bu" 4
Paint processed pixels up in white:
.Sp
.Vb 1
\&        kerndeint=map=1
.Ve
.SS "lut3d"
.IX Subsection "lut3d"
Apply a 3D \s-1LUT\s0 ta a input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBfile\fR" 4
.IX Item "file"
Set tha 3D \s-1LUT\s0 file name.
.Sp
Currently supported formats:
.RS 4
.IP "\fB3dl\fR" 4
.IX Item "3dl"
AfterEffects
.IP "\fBcube\fR" 4
.IX Item "cube"
Iridas
.IP "\fBdat\fR" 4
.IX Item "dat"
DaVinci
.IP "\fBm3d\fR" 4
.IX Item "m3d"
Pandora
.RE
.RS 4
.RE
.IP "\fBinterp\fR" 4
.IX Item "interp"
Select interpolation mode.
.Sp
Available joints are:
.RS 4
.IP "\fBnearest\fR" 4
.IX Item "nearest"
Use joints from tha nearest defined point.
.IP "\fBtrilinear\fR" 4
.IX Item "trilinear"
Interpolate joints rockin tha 8 points definin a cold-ass lil cube.
.IP "\fBtetrahedral\fR" 4
.IX Item "tetrahedral"
Interpolate joints rockin a tetrahedron.
.RE
.RS 4
.RE
.SS "lut, lutrgb, lutyuv"
.IX Subsection "lut, lutrgb, lutyuv"
Compute a look-up table fo' bindin each pixel component input value
to a output value, n' apply it ta input vizzle.
.PP
\&\fIlutyuv\fR applies a lookup table ta a \s-1YUV\s0 input vizzle, \fIlutrgb\fR
to a \s-1RGB\s0 input vizzle.
.PP
These filtas accept tha followin options:
.IP "\fBc0\fR" 4
.IX Item "c0"
set first pixel component expression
.IP "\fBc1\fR" 4
.IX Item "c1"
set second pixel component expression
.IP "\fBc2\fR" 4
.IX Item "c2"
set third pixel component expression
.IP "\fBc3\fR" 4
.IX Item "c3"
set fourth pixel component expression, correspondz ta tha alpha component
.IP "\fBr\fR" 4
.IX Item "r"
set red component expression
.IP "\fBg\fR" 4
.IX Item "g"
set chronic component expression
.IP "\fBb\fR" 4
.IX Item "b"
set blue component expression
.IP "\fBa\fR" 4
.IX Item "a"
alpha component expression
.IP "\fBy\fR" 4
.IX Item "y"
set Y/luminizzle component expression
.IP "\fBu\fR" 4
.IX Item "u"
set U/Cb component expression
.IP "\fBv\fR" 4
.IX Item "v"
set V/Cr component expression
.PP
Each of dem specifies tha expression ta use fo' computin tha lookup table for
the correspondin pixel component joints.
.PP
Da exact component associated ta each of tha \fIc*\fR options dependz on the
format up in input.
.PP
Da \fIlut\fR filta requires either \s-1YUV\s0 or \s-1RGB\s0 pixel formats up in input,
\&\fIlutrgb\fR requires \s-1RGB\s0 pixel formats up in input, n' \fIlutyuv\fR requires \s-1YUV.\s0
.PP
Da expressions can contain tha followin constants n' functions:
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
the input width n' height
.IP "\fBval\fR" 4
.IX Item "val"
input value fo' tha pixel component
.IP "\fBclipval\fR" 4
.IX Item "clipval"
the input value clipped up in tha \fIminval\fR\-\fImaxval\fR range
.IP "\fBmaxval\fR" 4
.IX Item "maxval"
maximum value fo' tha pixel component
.IP "\fBminval\fR" 4
.IX Item "minval"
minimum value fo' tha pixel component
.IP "\fBnegval\fR" 4
.IX Item "negval"
the negated value fo' tha pixel component value clipped up in the
\&\fIminval\fR\-\fImaxval\fR range , it correspondz ta tha expression
\&\*(L"maxval\-clipval+minval\*(R"
.IP "\fBclip(val)\fR" 4
.IX Item "clip(val)"
the computed value up in \fIval\fR clipped up in the
\&\fIminval\fR\-\fImaxval\fR range
.IP "\fBgammaval(gamma)\fR" 4
.IX Item "gammaval(gamma)"
the computed gamma erection value of tha pixel component value
clipped up in tha \fIminval\fR\-\fImaxval\fR range, correspondz ta the
expression
"pow((clipval\-minval)/(maxval\-minval)\e,\fIgamma\fR)*(maxval\-minval)+minval"
.PP
All expressions default ta \*(L"val\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Negate input vizzle:
.Sp
.Vb 2
\&        lutrgb="r=maxval+minval\-val:g=maxval+minval\-val:b=maxval+minval\-val"
\&        lutyuv="y=maxval+minval\-val:u=maxval+minval\-val:v=maxval+minval\-val"
.Ve
.Sp
Da above is tha same ol' dirty as:
.Sp
.Vb 2
\&        lutrgb="r=negval:g=negval:b=negval"
\&        lutyuv="y=negval:u=negval:v=negval"
.Ve
.IP "\(bu" 4
Negate luminance:
.Sp
.Vb 1
\&        lutyuv=y=negval
.Ve
.IP "\(bu" 4
Remove chroma components, turns tha vizzle tha fuck into a graytone image:
.Sp
.Vb 1
\&        lutyuv="u=128:v=128"
.Ve
.IP "\(bu" 4
Apply a luma burnin effect:
.Sp
.Vb 1
\&        lutyuv="y=2*val"
.Ve
.IP "\(bu" 4
Remove chronic n' blue components:
.Sp
.Vb 1
\&        lutrgb="g=0:b=0"
.Ve
.IP "\(bu" 4
Set a cold-ass lil constant alpha channel value on input:
.Sp
.Vb 1
\&        format=rgba,lutrgb=a="maxval\-minval/2"
.Ve
.IP "\(bu" 4
Correct luminizzle gamma by a 0.5 factor:
.Sp
.Vb 1
\&        lutyuv=y=gammaval(0.5)
.Ve
.IP "\(bu" 4
Discard least dope bitz of luma:
.Sp
.Vb 1
\&        lutyuv=y=\*(Aqbitand(val, 128+64+32)\*(Aq
.Ve
.SS "mergeplanes"
.IX Subsection "mergeplanes"
Merge color channel components from nuff muthafuckin vizzle streams.
.PP
Da filta accepts up ta 4 input streams, n' merge selected input
planes ta tha output vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBmapping\fR" 4
.IX Item "mapping"
Set input ta output plane mapping. Default is \f(CW0\fR.
.Sp
Da mappings is specified as a funky-ass bitmap. Well shiiiit, it should be specified as a
hexadecimal number up in tha form 0xAa[Bb[Cc[Dd]]]. 'Aa' raps bout the
mappin fo' tha straight-up original gangsta plane of tha output stream. 'A' sets tha number of
the input stream ta use (from 0 ta 3), n' 'a' tha plane number of the
correspondin input ta use (from 0 ta 3). Da rest of tha mappings is
similar, 'Bb' raps bout tha mappin fo' tha output stream second
plane, 'Cc' raps bout tha mappin fo' tha output stream third plane and
\&'Dd' raps bout tha mappin fo' tha output stream fourth plane.
.IP "\fBformat\fR" 4
.IX Item "format"
Set output pixel format. Default is \f(CW\*(C`yuva444p\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Merge three gray vizzle streamz of same width n' height tha fuck into single vizzle stream:
.Sp
.Vb 1
\&        [a0][a1][a2]mergeplanes=0x001020:yuv444p
.Ve
.IP "\(bu" 4
Merge 1st yuv444p stream n' 2nd gray vizzle stream tha fuck into yuva444p vizzle stream:
.Sp
.Vb 1
\&        [a0][a1]mergeplanes=0x00010210:yuva444p
.Ve
.IP "\(bu" 4
Swap Y n' A plane up in yuva444p stream:
.Sp
.Vb 1
\&        format=yuva444p,mergeplanes=0x03010200:yuva444p
.Ve
.IP "\(bu" 4
Swap U n' V plane up in yuv420p stream:
.Sp
.Vb 1
\&        format=yuv420p,mergeplanes=0x000201:yuv420p
.Ve
.IP "\(bu" 4
Cast a rgb24 clip ta yuv444p:
.Sp
.Vb 1
\&        format=rgb24,mergeplanes=0x000102:yuv444p
.Ve
.SS "mcdeint"
.IX Subsection "mcdeint"
Apply motion-compensation deinterlacing.
.PP
It needz one field per frame as input n' must thus be used together
with yadif=1/3 or equivalent.
.PP
This filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Set tha deinterlacin mode.
.Sp
It accepts one of tha followin joints:
.RS 4
.IP "\fBfast\fR" 4
.IX Item "fast"
.PD 0
.IP "\fBmedium\fR" 4
.IX Item "medium"
.IP "\fBslow\fR" 4
.IX Item "slow"
.PD
use iteratizzle motion estimation
.IP "\fBextra_slow\fR" 4
.IX Item "extra_slow"
like \fBslow\fR yo, but use multiple reference frames.
.RE
.RS 4
.Sp
Default value is \fBfast\fR.
.RE
.IP "\fBparity\fR" 4
.IX Item "parity"
Set tha picture field paritizzle assumed fo' tha input vizzle. Well shiiiit, it must be
one of tha followin joints:
.RS 4
.IP "\fB0, tff\fR" 4
.IX Item "0, tff"
assume top field first
.IP "\fB1, bff\fR" 4
.IX Item "1, bff"
assume bottom field first
.RE
.RS 4
.Sp
Default value is \fBbff\fR.
.RE
.IP "\fBqp\fR" 4
.IX Item "qp"
Set per-block quantization parameta (\s-1QP\s0) used by tha internal
encoder.
.Sp
Higher joints should result up in a smoother motion vector field but less
optimal individual vectors. Default value is 1.
.SS "mp"
.IX Subsection "mp"
Apply a MPlayer filta ta tha input vizzle.
.PP
This filta serves up a wrapper round a shitload of tha filtas of
MPlayer/MEncoder.
.PP
This wrapper is considered experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Some of tha wrapped filters
may not work properly n' we may drop support fo' them, as they will
be implemented natively tha fuck into FFmpeg. Thus you should avoid
dependin on dem when freestylin portable scripts.
.PP
Da filta accepts tha parameters:
\&\fIfilter_name\fR[:=]\fIfilter_params\fR
.PP
\&\fIfilter_name\fR is tha name of a supported MPlayer filter,
\&\fIfilter_params\fR be a strang containin tha parametas accepted by
the named filter.
.PP
Da list of tha currently supported filtas bigs up:
.IP "\fIeq2\fR" 4
.IX Item "eq2"
.PD 0
.IP "\fIeq\fR" 4
.IX Item "eq"
.IP "\fIfspp\fR" 4
.IX Item "fspp"
.IP "\fIilpack\fR" 4
.IX Item "ilpack"
.IP "\fIpp7\fR" 4
.IX Item "pp7"
.IP "\fIsoftpulldown\fR" 4
.IX Item "softpulldown"
.IP "\fIuspp\fR" 4
.IX Item "uspp"
.PD
.PP
Da parameta syntax n' behavior fo' tha listed filtas is tha same
of tha correspondin MPlayer filters. For detailed instructions check
the \*(L"\s-1VIDEO FILTERS\*(R"\s0 section up in tha MPlayer manual.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Adjust gamma, brightness, contrast:
.Sp
.Vb 1
\&        mp=eq2=1.0:2:0.5
.Ve
.PP
See also \fImplayer\fR\|(1), <\fBhttp://www.mplayerhq.hu/\fR>.
.SS "mpdecimate"
.IX Subsection "mpdecimate"
Drop frames dat do not differ pimped outly from tha previous frame in
order ta reduce frame rate.
.PP
Da main use of dis filta is fo' hella-low-bitrate encoding
(e.g. streamin over dialup modem) yo, but it could up in theory be used for
fixin pornos dat was inverse-telecined incorrectly.
.PP
A description of tha accepted options bigs up.
.IP "\fBmax\fR" 4
.IX Item "max"
Set tha maximum number of consecutizzle frames which can be dropped (if
positive), or tha minimum interval between dropped frames (if
negative). If tha value is 0, tha frame is dropped unregardin the
number of previous sequentially dropped frames.
.Sp
Default value is 0.
.IP "\fBhi\fR" 4
.IX Item "hi"
.PD 0
.IP "\fBlo\fR" 4
.IX Item "lo"
.IP "\fBfrac\fR" 4
.IX Item "frac"
.PD
Set tha droppin threshold joints.
.Sp
Values fo' \fBhi\fR n' \fBlo\fR is fo' 8x8 pixel blocks and
represent actual pixel value differences, so a threshold of 64
correspondz ta 1 unit of difference fo' each pixel, or tha same spread
out differently over tha block.
.Sp
A frame be a cold-ass lil muthafucka fo' droppin if no 8x8 blocks differ by more
than a threshold of \fBhi\fR, n' if no mo' than \fBfrac\fR blocks (1
meanin tha whole image) differ by mo' than a threshold of \fBlo\fR.
.Sp
Default value fo' \fBhi\fR is 64*12, default value fo' \fBlo\fR is
64*5, n' default value fo' \fBfrac\fR is 0.33.
.SS "negate"
.IX Subsection "negate"
Negate input vizzle.
.PP
This filta accepts a integer up in input, if non-zero it negates the
alpha component (if available). Da default value up in input is 0.
.SS "noformat"
.IX Subsection "noformat"
Force libavfilta not ta use any of tha specified pixel formats fo' the
input ta tha next filter.
.PP
This filta accepts tha followin parameters:
.IP "\fBpix_fmts\fR" 4
.IX Item "pix_fmts"
A '|'\-separated list of pixel format names, fo' example
\&\*(L"pix_fmts=yuv420p|monow|rgb24\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Force libavfilta ta bust a gangbangin' format different from \fIyuv420p\fR fo' the
input ta tha vflip filter:
.Sp
.Vb 1
\&        noformat=pix_fmts=yuv420p,vflip
.Ve
.IP "\(bu" 4
Convert tha input vizzle ta any of tha formats not contained up in tha list:
.Sp
.Vb 1
\&        noformat=yuv420p|yuv444p|yuv410p
.Ve
.SS "noise"
.IX Subsection "noise"
Add noise on vizzle input frame.
.PP
Da filta accepts tha followin options:
.IP "\fBall_seed\fR" 4
.IX Item "all_seed"
.PD 0
.IP "\fBc0_seed\fR" 4
.IX Item "c0_seed"
.IP "\fBc1_seed\fR" 4
.IX Item "c1_seed"
.IP "\fBc2_seed\fR" 4
.IX Item "c2_seed"
.IP "\fBc3_seed\fR" 4
.IX Item "c3_seed"
.PD
Set noise seed fo' specific pixel component or all pixel components up in case
of \fIall_seed\fR. Default value is \f(CW123457\fR.
.IP "\fBall_strength, alls\fR" 4
.IX Item "all_strength, alls"
.PD 0
.IP "\fBc0_strength, c0s\fR" 4
.IX Item "c0_strength, c0s"
.IP "\fBc1_strength, c1s\fR" 4
.IX Item "c1_strength, c1s"
.IP "\fBc2_strength, c2s\fR" 4
.IX Item "c2_strength, c2s"
.IP "\fBc3_strength, c3s\fR" 4
.IX Item "c3_strength, c3s"
.PD
Set noise strength fo' specific pixel component or all pixel components up in case
\&\fIall_strength\fR. Default value is \f(CW0\fR fo' realz. Allowed range is [0, 100].
.IP "\fBall_flags, allf\fR" 4
.IX Item "all_flags, allf"
.PD 0
.IP "\fBc0_flags, c0f\fR" 4
.IX Item "c0_flags, c0f"
.IP "\fBc1_flags, c1f\fR" 4
.IX Item "c1_flags, c1f"
.IP "\fBc2_flags, c2f\fR" 4
.IX Item "c2_flags, c2f"
.IP "\fBc3_flags, c3f\fR" 4
.IX Item "c3_flags, c3f"
.PD
Set pixel component flags or set flags fo' all components if \fIall_flags\fR.
Available joints fo' component flags are:
.RS 4
.IP "\fBa\fR" 4
.IX Item "a"
averaged temporal noise (smoother)
.IP "\fBp\fR" 4
.IX Item "p"
mix random noise wit a (semi)regular pattern
.IP "\fBt\fR" 4
.IX Item "t"
temporal noise (noise pattern chizzlez between frames)
.IP "\fBu\fR" 4
.IX Item "u"
uniform noise (gaussian otherwise)
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Add temporal n' uniform noise ta input vizzle:
.PP
.Vb 1
\&        noise=alls=20:allf=t+u
.Ve
.SS "null"
.IX Subsection "null"
Pass tha vizzle source unchanged ta tha output.
.SS "ocv"
.IX Subsection "ocv"
Apply vizzle transform rockin libopencv.
.PP
To enable dis filta install libopencv library n' headaz and
configure FFmpeg wit \f(CW\*(C`\-\-enable\-libopencv\*(C'\fR.
.PP
This filta accepts tha followin parameters:
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name of tha libopencv filta ta apply.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
Da parametas ta pass ta tha libopencv filter n' shit. If not specified tha default
values is assumed.
.PP
Refer ta tha straight-up legit libopencv documentation fo' mo' precise
information:
<\fBhttp://opencv.willowgarage.com/documentation/c/image_filtering.html\fR>
.PP
Follows tha list of supported libopencv filters.
.PP
\fIdilate\fR
.IX Subsection "dilate"
.PP
Dilate a image by rockin a specific structurin element.
This filta correspondz ta tha libopencv function \f(CW\*(C`cvDilate\*(C'\fR.
.PP
It accepts tha parameters: \fIstruct_el\fR|\fInb_iterations\fR.
.PP
\&\fIstruct_el\fR represents a structurin element, n' has tha syntax:
\&\fIcols\fRx\fIrows\fR+\fIanchor_x\fRx\fIanchor_y\fR/\fIshape\fR
.PP
\&\fIcols\fR n' \fIrows\fR represent tha number of columns n' rows of
the structurin element, \fIanchor_x\fR n' \fIanchor_y\fR tha anchor
point, n' \fIshape\fR tha shape fo' tha structurin element, and
can be one of tha joints \*(L"rect\*(R", \*(L"cross\*(R", \*(L"ellipse\*(R", \*(L"custom\*(R".
.PP
If tha value fo' \fIshape\fR is \*(L"custom\*(R", it must be followed by a
strin of tha form "=\fIfilename\fR". Da file wit name
\&\fIfilename\fR be assumed ta represent a funky-ass binary image, wit each
printable characta correspondin ta a funky-ass bright pixel. When a cold-ass lil custom
\&\fIshape\fR is used, \fIcols\fR n' \fIrows\fR is ignored, tha number
or columns n' rowz of tha read file is assumed instead.
.PP
Da default value fo' \fIstruct_el\fR is \*(L"3x3+0x0/rect\*(R".
.PP
\&\fInb_iterations\fR specifies tha number of times tha transform is
applied ta tha image, n' defaults ta 1.
.PP
Big up some example:
.PP
.Vb 2
\&        # use tha default joints
\&        ocv=dilate
\&        
\&        # dilate rockin a structurin element wit a 5x5 cross, iterate two times
\&        ocv=filter_name=dilate:filter_params=5x5+2x2/cross|2
\&        
\&        # read tha shape from tha file diamond.shape, iterate two times
\&        # tha file diamond.shape may contain a pattern of charactas like this:
\&        #   *
\&        #  ***
\&        # *****
\&        #  ***
\&        #   *
\&        # tha specified cols n' rows is ignored (but not tha anchor point coordinates)
\&        ocv=dilate:0x0+2x2/custom=diamond.shape|2
.Ve
.PP
\fIerode\fR
.IX Subsection "erode"
.PP
Erode a image by rockin a specific structurin element.
This filta correspondz ta tha libopencv function \f(CW\*(C`cvErode\*(C'\fR.
.PP
Da filta accepts tha parameters: \fIstruct_el\fR:\fInb_iterations\fR,
with tha same syntax n' semantics as tha dilate filter.
.PP
\fIsmooth\fR
.IX Subsection "smooth"
.PP
Smooth tha input vizzle.
.PP
Da filta takes tha followin parameters:
\&\fItype\fR|\fIparam1\fR|\fIparam2\fR|\fIparam3\fR|\fIparam4\fR.
.PP
\&\fItype\fR is tha type of smooth filta ta apply, n' can be one of
the followin joints: \*(L"blur\*(R", \*(L"blur_no_scale\*(R", \*(L"median\*(R", \*(L"gaussian\*(R",
\&\*(L"bilateral\*(R". Da default value is \*(L"gaussian\*(R".
.PP
\&\fIparam1\fR, \fIparam2\fR, \fIparam3\fR, n' \fIparam4\fR are
parametas whose meanings depend on smooth type. \fIparam1\fR and
\&\fIparam2\fR accept integer positizzle joints or 0, \fIparam3\fR and
\&\fIparam4\fR accept float joints.
.PP
Da default value fo' \fIparam1\fR is 3, tha default value fo' the
other parametas is 0.
.PP
These parametas correspond ta tha parametas assigned ta the
libopencv function \f(CW\*(C`cvSmooth\*(C'\fR.
.SS "overlay"
.IX Subsection "overlay"
Overlay one vizzle on top of another.
.PP
It takes two inputs n' one output, tha straight-up original gangsta input is tha \*(L"main\*(R"
video on which tha second input is overlayed.
.PP
This filta accepts tha followin parameters:
.PP
A description of tha accepted options bigs up.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Set tha expression fo' tha x n' y coordinatez of tha overlayed vizzle
on tha main vizzle. Default value is \*(L"0\*(R" fo' both expressions. In case
the expression is invalid, it is set ta a big-ass value (meanin dat the
overlay aint gonna be displayed within tha output visible area).
.IP "\fBeval\fR" 4
.IX Item "eval"
Set when tha expressions fo' \fBx\fR, n' \fBy\fR is evaluated.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBinit\fR" 4
.IX Item "init"
only evaluate expressions once durin tha filta initialization or
when a cold-ass lil command is processed
.IP "\fBframe\fR" 4
.IX Item "frame"
evaluate expressions fo' each incomin frame
.RE
.RS 4
.Sp
Default value is \fBframe\fR.
.RE
.IP "\fBshortest\fR" 4
.IX Item "shortest"
If set ta 1, force tha output ta terminizzle when tha shortest input
terminates. Default value is 0.
.IP "\fBformat\fR" 4
.IX Item "format"
Set tha format fo' tha output vizzle.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fByuv420\fR" 4
.IX Item "yuv420"
force \s-1YUV420\s0 output
.IP "\fByuv444\fR" 4
.IX Item "yuv444"
force \s-1YUV444\s0 output
.IP "\fBrgb\fR" 4
.IX Item "rgb"
force \s-1RGB\s0 output
.RE
.RS 4
.Sp
Default value is \fByuv420\fR.
.RE
.IP "\fBrgb\fR \fI(deprecated)\fR" 4
.IX Item "rgb (deprecated)"
If set ta 1, force tha filta ta accept inputs up in tha \s-1RGB\s0
color space. Default value is 0. This option is deprecated, use
\&\fBformat\fR instead.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
If set ta 1, force tha filta ta draw tha last overlay frame over the
main input until tha end of tha stream fo' realz. A value of 0 disablez this
behavior. Shiiit, dis aint no joke. Default value is 1.
.PP
Da \fBx\fR, n' \fBy\fR expressions can contain tha following
parameters.
.IP "\fBmain_w, W\fR" 4
.IX Item "main_w, W"
.PD 0
.IP "\fBmain_h, H\fR" 4
.IX Item "main_h, H"
.PD
main input width n' height
.IP "\fBoverlay_w, w\fR" 4
.IX Item "overlay_w, w"
.PD 0
.IP "\fBoverlay_h, h\fR" 4
.IX Item "overlay_h, h"
.PD
overlay input width n' height
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the computed joints fo' \fIx\fR n' \fIy\fR. They is evaluated for
each freshly smoked up frame.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample jointz of tha output
format. For example fo' tha pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 and
\&\fIvsub\fR is 1.
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.PP
Note dat tha \fIn\fR, \fIpos\fR, \fIt\fR variablez is available only
when evaluation is done \fIper frame\fR, n' will evaluate ta \s-1NAN\s0
when \fBeval\fR is set ta \fBinit\fR.
.PP
Be aware dat frames is taken from each input vizzle up in timestamp
order, hence, if they initial timestamps differ, it aint nuthin but a phat idea
to pass tha two inputs all up in a \fIsetpts=PTS\-STARTPTS\fR filta to
have dem begin up in tha same zero timestamp, as it do tha example for
the \fImovie\fR filter.
.PP
Yo ass can chain together mo' overlays but you should test the
efficiency of such approach.
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Modify tha x n' y of tha overlay input.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw tha overlay at 10 pixels from tha bottom right corner of tha main
video:
.Sp
.Vb 1
\&        overlay=main_w\-overlay_w\-10:main_h\-overlay_h\-10
.Ve
.Sp
Usin named options tha example above becomes:
.Sp
.Vb 1
\&        overlay=x=main_w\-overlay_w\-10:y=main_h\-overlay_h\-10
.Ve
.IP "\(bu" 4
Insert a transparent \s-1PNG\s0 logo up in tha bottom left corner of tha input,
usin tha \fBffmpeg\fR tool wit tha \f(CW\*(C`\-filter_complex\*(C'\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i input \-i logo \-filter_complex \*(Aqoverlay=10:main_h\-overlay_h\-10\*(Aq output
.Ve
.IP "\(bu" 4
Insert 2 different transparent \s-1PNG\s0 logos (second logo on bottom
right corner) rockin tha \fBffmpeg\fR tool:
.Sp
.Vb 1
\&        ffmpeg \-i input \-i logo1 \-i logo2 \-filter_complex \*(Aqoverlay=x=10:y=H\-h\-10,overlay=x=W\-w\-10:y=H\-h\-10\*(Aq output
.Ve
.IP "\(bu" 4
Add a transparent color layer on top of tha main vizzle, \f(CW\*(C`WxH\*(C'\fR
must specify tha size of tha main input ta tha overlay filter:
.Sp
.Vb 1
\&        color=color=red@.3:size=WxH [over]; [in][over] overlay [out]
.Ve
.IP "\(bu" 4
Play a original gangsta vizzle n' a gangbangin' filtered version (here wit tha deshake
filter) side by side rockin tha \fBffplay\fR tool:
.Sp
.Vb 1
\&        ffplay input.avi \-vf \*(Aqsplit[a][b]; [a]pad=iw*2:ih[src]; [b]deshake[filt]; [src][filt]overlay=w\*(Aq
.Ve
.Sp
Da above command is tha same ol' dirty as:
.Sp
.Vb 1
\&        ffplay input.avi \-vf \*(Aqsplit[b], pad=iw*2[src], [b]deshake, [src]overlay=w\*(Aq
.Ve
.IP "\(bu" 4
Make a slidin overlay appearin from tha left ta tha right top part of the
screen startin since time 2:
.Sp
.Vb 1
\&        overlay=x=\*(Aqif(gte(t,2), \-w+(t\-2)*20, NAN)\*(Aq:y=0
.Ve
.IP "\(bu" 4
Compose output by puttin two input vizzlez side ta side:
.Sp
.Vb 7
\&        ffmpeg \-i left.avi \-i right.avi \-filter_complex "
\&        nullsrc=size=200x100 [background];
\&        [0:v] setpts=PTS\-STARTPTS, scale=100x100 [left];
\&        [1:v] setpts=PTS\-STARTPTS, scale=100x100 [right];
\&        [background][left]       overlay=shortest=1       [background+left];
\&        [background+left][right] overlay=shortest=1:x=100 [left+right]
\&        "
.Ve
.IP "\(bu" 4
Chain nuff muthafuckin overlays up in cascade:
.Sp
.Vb 6
\&        nullsrc=s=200x200 [bg];
\&        testsrc=s=100x100, split=4 [in0][in1][in2][in3];
\&        [in0] lutrgb=r=0, [bg]   overlay=0:0     [mid0];
\&        [in1] lutrgb=g=0, [mid0] overlay=100:0   [mid1];
\&        [in2] lutrgb=b=0, [mid1] overlay=0:100   [mid2];
\&        [in3] null,       [mid2] overlay=100:100 [out0]
.Ve
.SS "owdenoise"
.IX Subsection "owdenoise"
Apply Overcomplete Wavelet denoiser.
.PP
Da filta accepts tha followin options:
.IP "\fBdepth\fR" 4
.IX Item "depth"
Set depth.
.Sp
Larger depth joints will denoise lower frequency components mo' yo, but
slow down filtering.
.Sp
Must be a int up in tha range 8\-16, default is \f(CW8\fR.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set luma strength.
.Sp
Must be a thugged-out double value up in tha range 0\-1000, default is \f(CW1.0\fR.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set chroma strength.
.Sp
Must be a thugged-out double value up in tha range 0\-1000, default is \f(CW1.0\fR.
.SS "pad"
.IX Subsection "pad"
Add paddings ta tha input image, n' place tha original gangsta input at the
given coordinates \fIx\fR, \fIy\fR.
.PP
This filta accepts tha followin parameters:
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Specify a expression fo' tha size of tha output image wit the
paddings added. Y'all KNOW dat shit, muthafucka! If tha value fo' \fIwidth\fR or \fIheight\fR is 0, the
correspondin input size is used fo' tha output.
.Sp
Da \fIwidth\fR expression can reference tha value set by the
\&\fIheight\fR expression, n' vice versa.
.Sp
Da default value of \fIwidth\fR n' \fIheight\fR is 0.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Specify a expression fo' tha offsets where ta place tha input image
in tha padded area wit respect ta tha top/left border of tha output
image.
.Sp
Da \fIx\fR expression can reference tha value set by tha \fIy\fR
expression, n' vice versa.
.Sp
Da default value of \fIx\fR n' \fIy\fR is 0.
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify tha color of tha padded area. For tha syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIcolor\fR is \*(L"black\*(R".
.PP
Da value fo' tha \fIwidth\fR, \fIheight\fR, \fIx\fR, n' \fIy\fR
options is expressions containin tha followin constants:
.IP "\fBin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fBin_h\fR" 4
.IX Item "in_h"
.PD
the input vizzle width n' height
.IP "\fBiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fBih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fBout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fBout_h\fR" 4
.IX Item "out_h"
.PD
the output width n' height, dat is tha size of tha padded area as
specified by tha \fIwidth\fR n' \fIheight\fR expressions
.IP "\fBow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fBoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
x n' y offsets as specified by tha \fIx\fR n' \fIy\fR
expressions, or \s-1NAN\s0 if not yet specified
.IP "\fBa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIiw\fR / \fIih\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Add paddings wit color \*(L"violet\*(R" ta tha input vizzle. Output vizzle
size is 640x480, tha top-left corner of tha input vizzle is placed at
column 0, row 40:
.Sp
.Vb 1
\&        pad=640:480:0:40:violet
.Ve
.Sp
Da example above is equivalent ta tha followin command:
.Sp
.Vb 1
\&        pad=width=640:height=480:x=0:y=40:color=violet
.Ve
.IP "\(bu" 4
Pad tha input ta git a output wit dimensions increased by 3/2,
and put tha input vizzle all up in tha centa of tha padded area:
.Sp
.Vb 1
\&        pad="3/2*iw:3/2*ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Pad tha input ta git a squared output wit size equal ta tha maximum
value between tha input width n' height, n' put tha input vizzle at
the centa of tha padded area:
.Sp
.Vb 1
\&        pad="max(iw\e,ih):ow:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Pad tha input ta git a gangbangin' final w/h ratio of 16:9:
.Sp
.Vb 1
\&        pad="ih*16/9:ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
In case of anamorphic vizzle, up in order ta set tha output display aspect
correctly, it is necessary ta use \fIsar\fR up in tha expression,
accordin ta tha relation:
.Sp
.Vb 2
\&        (ih * X / ih) * sar = output_dar
\&        X = output_dar / sar
.Ve
.Sp
Thus tha previous example need ta be modified to:
.Sp
.Vb 1
\&        pad="ih*16/9/sar:ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Double output size n' put tha input vizzle up in tha bottom-right
corner of tha output padded area:
.Sp
.Vb 1
\&        pad="2*iw:2*ih:ow\-iw:oh\-ih"
.Ve
.SS "perspective"
.IX Subsection "perspective"
Correct perspectizzle of vizzle not recorded perpendicular ta tha screen.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBx0\fR" 4
.IX Item "x0"
.PD 0
.IP "\fBy0\fR" 4
.IX Item "y0"
.IP "\fBx1\fR" 4
.IX Item "x1"
.IP "\fBy1\fR" 4
.IX Item "y1"
.IP "\fBx2\fR" 4
.IX Item "x2"
.IP "\fBy2\fR" 4
.IX Item "y2"
.IP "\fBx3\fR" 4
.IX Item "x3"
.IP "\fBy3\fR" 4
.IX Item "y3"
.PD
Set coordinates expression fo' top left, top right, bottom left n' bottom right corners.
Default joints is \f(CW\*(C`0:0:W:0:0:H:W:H\*(C'\fR wit which perspectizzle will remain unchanged.
.Sp
Da expressions can use tha followin variables:
.RS 4
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
the width n' height of vizzle frame.
.RE
.RS 4
.RE
.IP "\fBinterpolation\fR" 4
.IX Item "interpolation"
Set interpolation fo' perspectizzle erection.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlinear\fR" 4
.IX Item "linear"
.PD 0
.IP "\fBcubic\fR" 4
.IX Item "cubic"
.RE
.RS 4
.PD
.Sp
Default value is \fBlinear\fR.
.RE
.SS "phase"
.IX Subsection "phase"
Delay interlaced vizzle by one field time so dat tha field order chizzles.
.PP
Da intended use is ta fix \s-1PAL\s0 pornos dat done been captured wit the
opposite field order ta tha film-to-video transfer.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBmode\fR" 4
.IX Item "mode"
Set phase mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBt\fR" 4
.IX Item "t"
Capture field order top-first, transfer bottom-first.
Filta will delay tha bottom field.
.IP "\fBb\fR" 4
.IX Item "b"
Capture field order bottom-first, transfer top-first.
Filta will delay tha top field.
.IP "\fBp\fR" 4
.IX Item "p"
Capture n' transfer wit tha same field order n' shit. This mode only exists
for tha documentation of tha other options ta refer ta yo, but if you
actually select it, tha filta will faithfully do nothing.
.IP "\fBa\fR" 4
.IX Item "a"
Capture field order determined automatically by field flags, transfer
opposite.
Filta selects among \fBt\fR n' \fBb\fR modes on a gangbangin' frame by frame
basis rockin field flags. If no field shiznit be available,
then dis works just like \fBu\fR.
.IP "\fBu\fR" 4
.IX Item "u"
Capture unknown or varying, transfer opposite.
Filta selects among \fBt\fR n' \fBb\fR on a gangbangin' frame by frame basis by
analyzin tha images n' selectin tha alternatizzle dat produces best
match between tha fields.
.IP "\fBT\fR" 4
.IX Item "T"
Capture top-first, transfer unknown or varying.
Filta selects among \fBt\fR n' \fBp\fR rockin image analysis.
.IP "\fBB\fR" 4
.IX Item "B"
Capture bottom-first, transfer unknown or varying.
Filta selects among \fBb\fR n' \fBp\fR rockin image analysis.
.IP "\fBA\fR" 4
.IX Item "A"
Capture determined by field flags, transfer unknown or varying.
Filta selects among \fBt\fR, \fBb\fR n' \fBp\fR rockin field flags and
image analysis. If no field shiznit be available, then dis works just
like \fBU\fR. This is tha default mode.
.IP "\fBU\fR" 4
.IX Item "U"
Both capture n' transfer unknown or varying.
Filta selects among \fBt\fR, \fBb\fR n' \fBp\fR rockin image analysis only.
.RE
.RS 4
.RE
.SS "pixdesctest"
.IX Subsection "pixdesctest"
Pixel format descriptor test filter, mainly useful fo' internal
testing. Da output vizzle should be equal ta tha input vizzle.
.PP
For example:
.PP
.Vb 1
\&        format=monow, pixdesctest
.Ve
.PP
can be used ta test tha monowhite pixel format descriptor definition.
.SS "pp"
.IX Subsection "pp"
Enable tha specified chain of postprocessin subfiltas rockin libpostproc. This
library should be automatically selected wit a \s-1GPL\s0 build (\f(CW\*(C`\-\-enable\-gpl\*(C'\fR).
Subfiltas must be separated by '/' n' can be disabled by prependin a '\-'.
Each subfilta n' some options gotz a gangbangin' finger-lickin' dirty-ass short n' a long-ass name dat can be used
interchangeably, i.e. dr/derin is tha same.
.PP
Da filtas accept tha followin options:
.IP "\fBsubfilters\fR" 4
.IX Item "subfilters"
Set postprocessin subfiltas string.
.PP
All subfiltas share common options ta determine they scope:
.IP "\fBa/autoq\fR" 4
.IX Item "a/autoq"
Honor tha qualitizzle commandz fo' dis subfilter.
.IP "\fBc/chrom\fR" 4
.IX Item "c/chrom"
Do chrominizzle filtering, too (default).
.IP "\fBy/nochrom\fR" 4
.IX Item "y/nochrom"
Do luminizzle filterin only (no chrominance).
.IP "\fBn/noluma\fR" 4
.IX Item "n/noluma"
Do chrominizzle filterin only (no luminance).
.PP
These options can be appended afta tha subfilta name, separated by a '|'.
.PP
Available subfiltas are:
.IP "\fBhb/hdeblock[|difference[|flatness]]\fR" 4
.IX Item "hb/hdeblock[|difference[|flatness]]"
Horizontal deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBvb/vdeblock[|difference[|flatness]]\fR" 4
.IX Item "vb/vdeblock[|difference[|flatness]]"
Vertical deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBha/hadeblock[|difference[|flatness]]\fR" 4
.IX Item "ha/hadeblock[|difference[|flatness]]"
Accurate horizontal deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBva/vadeblock[|difference[|flatness]]\fR" 4
.IX Item "va/vadeblock[|difference[|flatness]]"
Accurate vertical deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.PP
Da horizontal n' vertical deblockin filtas share tha difference and
flatnizz joints so you cannot set different horizontal n' vertical
thresholds.
.IP "\fBh1/x1hdeblock\fR" 4
.IX Item "h1/x1hdeblock"
Experimenstrual horizontal deblockin filter
.IP "\fBv1/x1vdeblock\fR" 4
.IX Item "v1/x1vdeblock"
Experimenstrual vertical deblockin filter
.IP "\fBdr/dering\fR" 4
.IX Item "dr/dering"
Deringin filter
.IP "\fBtn/tmpnoise[|threshold1[|threshold2[|threshold3]]], temporal noise reducer\fR" 4
.IX Item "tn/tmpnoise[|threshold1[|threshold2[|threshold3]]], temporal noise reducer"
.RS 4
.PD 0
.IP "\fBthreshold1\fR" 4
.IX Item "threshold1"
.PD
larger \-> stronger filtering
.IP "\fBthreshold2\fR" 4
.IX Item "threshold2"
larger \-> stronger filtering
.IP "\fBthreshold3\fR" 4
.IX Item "threshold3"
larger \-> stronger filtering
.RE
.RS 4
.RE
.IP "\fBal/autolevels[:f/fullyrange], automatic brightnizz / contrast erection\fR" 4
.IX Item "al/autolevels[:f/fullyrange], automatic brightnizz / contrast erection"
.RS 4
.PD 0
.IP "\fBf/fullyrange\fR" 4
.IX Item "f/fullyrange"
.PD
Stretch luminizzle ta \f(CW\*(C`0\-255\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fBlb/linblenddeint\fR" 4
.IX Item "lb/linblenddeint"
Linear blend deinterlacin filta dat deinterlaces tha given block by
filterin all lines wit a \f(CW\*(C`(1 2 1)\*(C'\fR filter.
.IP "\fBli/linipoldeint\fR" 4
.IX Item "li/linipoldeint"
Linear interpolatin deinterlacin filta dat deinterlaces tha given block by
linearly interpolatin every last muthafuckin second line.
.IP "\fBci/cubicipoldeint\fR" 4
.IX Item "ci/cubicipoldeint"
Cubic interpolatin deinterlacin filta deinterlaces tha given block by
cubically interpolatin every last muthafuckin second line.
.IP "\fBmd/mediandeint\fR" 4
.IX Item "md/mediandeint"
Median deinterlacin filta dat deinterlaces tha given block by applyin a
median filta ta every last muthafuckin second line.
.IP "\fBfd/ffmpegdeint\fR" 4
.IX Item "fd/ffmpegdeint"
FFmpeg deinterlacin filta dat deinterlaces tha given block by filterin every
second line wit a \f(CW\*(C`(\-1 4 2 4 \-1)\*(C'\fR filter.
.IP "\fBl5/lowpass5\fR" 4
.IX Item "l5/lowpass5"
Vertically applied \s-1FIR\s0 lowpass deinterlacin filta dat deinterlaces tha given
block by filterin all lines wit a \f(CW\*(C`(\-1 2 6 2 \-1)\*(C'\fR filter.
.IP "\fBfq/forceQuant[|quantizer]\fR" 4
.IX Item "fq/forceQuant[|quantizer]"
Overrides tha quantizer table from tha input wit tha constant quantizer you
specify.
.RS 4
.IP "\fBquantizer\fR" 4
.IX Item "quantizer"
Quantizer ta use
.RE
.RS 4
.RE
.IP "\fBde/default\fR" 4
.IX Item "de/default"
Default pp filta combination (\f(CW\*(C`hb|a,vb|a,dr|a\*(C'\fR)
.IP "\fBfa/fast\fR" 4
.IX Item "fa/fast"
Fast pp filta combination (\f(CW\*(C`h1|a,v1|a,dr|a\*(C'\fR)
.IP "\fBac\fR" 4
.IX Item "ac"
High qualitizzle pp filta combination (\f(CW\*(C`ha|a|128|7,va|a,dr|a\*(C'\fR)
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply horizontal n' vertical deblocking, deringin n' automatic
brightness/contrast:
.Sp
.Vb 1
\&        pp=hb/vb/dr/al
.Ve
.IP "\(bu" 4
Apply default filtas without brightness/contrast erection:
.Sp
.Vb 1
\&        pp=de/\-al
.Ve
.IP "\(bu" 4
Apply default filtas n' temporal denoiser:
.Sp
.Vb 1
\&        pp=default/tmpnoise|1|2|3
.Ve
.IP "\(bu" 4
Apply deblockin on luminizzle only, n' switch vertical deblockin on or off
automatically dependin on available \s-1CPU\s0 time:
.Sp
.Vb 1
\&        pp=hb|y/vb|a
.Ve
.SS "psnr"
.IX Subsection "psnr"
Obtain tha average, maximum n' minimum \s-1PSNR \s0(Peak Signal ta Noise
Ratio) between two input vizzles.
.PP
This filta takes up in input two input vizzles, tha straight-up original gangsta input is
considered tha \*(L"main\*(R" source n' is passed unchanged ta the
output. Da second input is used as a \*(L"reference\*(R" vizzle fo' computing
the \s-1PSNR.\s0
.PP
Both vizzle inputs must have tha same resolution n' pixel format for
this filta ta work erectly fo' realz. Also it assumes dat both inputs
have tha same number of frames, which is compared one by one.
.PP
Da obtained average \s-1PSNR\s0 is printed all up in tha loggin system.
.PP
Da filta stores tha accumulated \s-1MSE \s0(mean squared error) of each
frame, n' all up in tha end of tha processin it be averaged across all frames
equally, n' tha followin formula be applied ta obtain tha \s-1PSNR:\s0
.PP
.Vb 1
\&        PSNR = 10*log10(MAX^2/MSE)
.Ve
.PP
Where \s-1MAX\s0 is tha average of tha maximum jointz of each component of the
image.
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBstats_file, f\fR" 4
.IX Item "stats_file, f"
If specified tha filta will use tha named file ta save tha \s-1PSNR\s0 of
each individual frame.
.PP
Da file printed if \fIstats_file\fR is selected, gotz nuff a sequence of
key/value pairz of tha form \fIkey\fR:\fIvalue\fR fo' each compared
couple frames.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 1
.IP "\fBmse_avg\fR" 4
.IX Item "mse_avg"
Mean Square Error pixel-by-pixel average difference of tha compared
frames, averaged over all tha image components.
.IP "\fBmse_y, mse_u, mse_v, mse_r, mse_g, mse_g, mse_a\fR" 4
.IX Item "mse_y, mse_u, mse_v, mse_r, mse_g, mse_g, mse_a"
Mean Square Error pixel-by-pixel average difference of tha compared
frames fo' tha component specified by tha suffix.
.IP "\fBpsnr_y, psnr_u, psnr_v, psnr_r, psnr_g, psnr_b, psnr_a\fR" 4
.IX Item "psnr_y, psnr_u, psnr_v, psnr_r, psnr_g, psnr_b, psnr_a"
Peak Signal ta Noise ratio of tha compared frames fo' tha component
specified by tha suffix.
.PP
For example:
.PP
.Vb 2
\&        porno=ref_movie.mpg, setpts=PTS\-STARTPTS [main];
\&        [main][ref] psnr="stats_file=stats.log" [out]
.Ve
.PP
On dis example tha input file bein processed is compared wit the
reference file \fIref_movie.mpg\fR. Da \s-1PSNR\s0 of each individual frame
is stored up in \fIstats.log\fR.
.SS "pullup"
.IX Subsection "pullup"
Pulldown reversal (inverse telecine) filter, capable of handlin mixed
hard-telecine, 24000/1001 fps progressive, n' 30000/1001 fps progressive
content.
.PP
Da pullup filta is designed ta take advantage of future context up in making
its decisions. This filta is stateless up in tha sense dat it do not lock
onto a pattern ta follow yo, but it instead looks forward ta tha following
fieldz up in order ta identify matches n' rebuild progressive frames.
.PP
To produce content wit a even framerate, bang tha fps filta after
pullup, use \f(CW\*(C`fps=24000/1001\*(C'\fR if tha input frame rate is 29.97fps,
\&\f(CW\*(C`fps=24\*(C'\fR fo' 30fps n' tha (rare) telecined 25fps input.
.PP
Da filta accepts tha followin options:
.IP "\fBjl\fR" 4
.IX Item "jl"
.PD 0
.IP "\fBjr\fR" 4
.IX Item "jr"
.IP "\fBjt\fR" 4
.IX Item "jt"
.IP "\fBjb\fR" 4
.IX Item "jb"
.PD
These options set tha amount of \*(L"junk\*(R" ta ignore all up in tha left, right, top, and
bottom of tha image, respectively. Left n' right is up in unitz of 8 pixels,
while top n' bottom is up in unitz of 2 lines.
Da default is 8 pixels on each side.
.IP "\fBsb\fR" 4
.IX Item "sb"
Set tha strict breaks. Right back up in yo muthafuckin ass. Settin dis option ta 1 will reduce tha chances of
filta generatin a occasionizzle mismatched frame yo, but it may also cause an
excessive number of frames ta be dropped durin high motion sequences.
Conversely, settin it ta \-1 will make filta match fieldz mo' doggystyle.
This may help processin of vizzle where there is slight blurrin between
the fieldz yo, but may also cause there ta be interlaced frames up in tha output.
Default value is \f(CW0\fR.
.IP "\fBmp\fR" 4
.IX Item "mp"
Set tha metric plane ta use. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fBl\fR" 4
.IX Item "l"
Use luma plane.
.IP "\fBu\fR" 4
.IX Item "u"
Use chroma blue plane.
.IP "\fBv\fR" 4
.IX Item "v"
Use chroma red plane.
.RE
.RS 4
.Sp
This option may be set ta use chroma plane instead of tha default luma plane
for bustin filterz computations. This may improve accuracy on straight-up clean
source material yo, but mo' likely will decrease accuracy, especially if there
is chroma noise (rainbow effect) or any grayscale vizzle.
Da main purpose of settin \fBmp\fR ta a cold-ass lil chroma plane is ta reduce \s-1CPU\s0
load n' make pullup usable up in realtime on slow machines.
.RE
.PP
For dopest thangs up in dis biatch (without duplicated frames up in tha output file) it is
necessary ta chizzle tha output frame rate. For example, ta inverse
telecine \s-1NTSC\s0 input:
.PP
.Vb 1
\&        ffmpeg \-i input \-vf pullup \-r 24000/1001 ...
.Ve
.SS "removelogo"
.IX Subsection "removelogo"
Suppress a \s-1TV\s0 station logo, rockin a image file ta determine which
pixels comprise tha logo. Well shiiiit, it works by fillin up in tha pixels that
comprise tha logo wit neighborin pixels.
.PP
Da filta accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filta bitmap file, which can be any image format supported by
libavformat. Da width n' height of tha image file must match dem of the
video stream bein processed.
.PP
Pixels up in tha provided bitmap image wit a value of zero is not
considered part of tha logo, non-zero pixels is considered part of
the logo. If you use white (255) fo' tha logo n' black (0) fo' the
rest, yo big-ass booty is ghon be safe. For makin tha filta bitmap, it is
recommended ta take a screen capture of a funky-ass black frame wit tha logo
visible, n' then rockin a threshold filta followed by tha erode
filta once or twice.
.PP
If needed, lil splotches can be fixed manually. Remember dat if
logo pixels is not covered, tha filta qualitizzle is ghon be much
reduced. Y'all KNOW dat shit, muthafucka! Markin too nuff pixels as part of tha logo do not hurt as
much yo, but it will increase tha amount of blurrin needed ta cover over
the image n' will destroy mo' shiznit than necessary, n' extra
pixels will slow thangs down on a big-ass logo.
.SS "rotate"
.IX Subsection "rotate"
Rotate vizzle by a arbitrary angle expressed up in radians.
.PP
Da filta accepts tha followin options:
.PP
A description of tha optionizzle parametas bigs up.
.IP "\fBangle, a\fR" 4
.IX Item "angle, a"
Set a expression fo' tha angle by which ta rotate tha input vizzle
clockwise, expressed as a fuckin shitload of radians fo' realz. A wack value will
result up in a cold-ass lil counter-clockwise rotation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \*(L"0\*(R".
.Sp
This expression is evaluated fo' each frame.
.IP "\fBout_w, ow\fR" 4
.IX Item "out_w, ow"
Set tha output width expression, default value is \*(L"iw\*(R".
This expression is evaluated just once durin configuration.
.IP "\fBout_h, oh\fR" 4
.IX Item "out_h, oh"
Set tha output height expression, default value is \*(L"ih\*(R".
This expression is evaluated just once durin configuration.
.IP "\fBbilinear\fR" 4
.IX Item "bilinear"
Enable bilinear interpolation if set ta 1, a value of 0 disables
it. Default value is 1.
.IP "\fBfillcolor, c\fR" 4
.IX Item "fillcolor, c"
Set tha color used ta fill tha output area not covered by tha rotated
image. For tha generalsyntax of dis option, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special value \*(L"none\*(R" is selected then no
background is printed (useful fo' example if tha background is never shown).
.Sp
Default value is \*(L"black\*(R".
.PP
Da expressions fo' tha angle n' tha output size can contain the
followin constants n' functions:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0. Well shiiiit, it be always \s-1NAN\s0
before tha straight-up original gangsta frame is filtered.
.IP "\fBt\fR" 4
.IX Item "t"
time up in secondz of tha input frame, it is set ta 0 when tha filta is
configured. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be always \s-1NAN\s0 before tha straight-up original gangsta frame is filtered.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD 0
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD
the input vizzle width n' heigth
.IP "\fBout_w, ow\fR" 4
.IX Item "out_w, ow"
.PD 0
.IP "\fBout_h, oh\fR" 4
.IX Item "out_h, oh"
.PD
the output width n' heigth, dat is tha size of tha padded area as
specified by tha \fIwidth\fR n' \fIheight\fR expressions
.IP "\fBrotw(a)\fR" 4
.IX Item "rotw(a)"
.PD 0
.IP "\fBroth(a)\fR" 4
.IX Item "roth(a)"
.PD
the minimal width/height required fo' straight-up containin tha input
video rotated by \fIa\fR radians.
.Sp
These is only available when computin tha \fBout_w\fR and
\&\fBout_h\fR expressions.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Rotate tha input by \s-1PI/6\s0 radians clockwise:
.Sp
.Vb 1
\&        rotate=PI/6
.Ve
.IP "\(bu" 4
Rotate tha input by \s-1PI/6\s0 radians counter-clockwise:
.Sp
.Vb 1
\&        rotate=\-PI/6
.Ve
.IP "\(bu" 4
Apply a cold-ass lil constant rotation wit period T, startin from a angle of \s-1PI/3:\s0
.Sp
.Vb 1
\&        rotate=PI/3+2*PI*t/T
.Ve
.IP "\(bu" 4
Make tha input vizzle rotation oscillatin wit a period of T
secondz n' a amplitude of A radians:
.Sp
.Vb 1
\&        rotate=A*sin(2*PI/T*t)
.Ve
.IP "\(bu" 4
Rotate tha vizzle, output size is chizzlen so dat tha whole rotating
input vizzle be always straight-up contained up in tha output:
.Sp
.Vb 1
\&        rotate=\*(Aq2*PI*t:ow=hypot(iw,ih):oh=ow\*(Aq
.Ve
.IP "\(bu" 4
Rotate tha vizzle, reduce tha output size so dat no background is ever
shown:
.Sp
.Vb 1
\&        rotate=2*PI*t:ow=\*(Aqmin(iw,ih)/sqrt(2)\*(Aq:oh=ow:c=none
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
Da filta supports tha followin commands:
.IP "\fBa, angle\fR" 4
.IX Item "a, angle"
Set tha angle expression.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.SS "sab"
.IX Subsection "sab"
Apply Shape Adaptizzle Blur.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
Set luma blur filta strength, must be a value up in range 0.1\-4.0, default
value is 1.0 fo' realz. A pimped outa value will result up in a mo' blurred image, and
in slower processing.
.IP "\fBluma_pre_filter_radius, lpfr\fR" 4
.IX Item "luma_pre_filter_radius, lpfr"
Set luma pre-filta radius, must be a value up in tha 0.1\-2.0 range, default
value is 1.0.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set luma maximum difference between pixels ta still be considered, must
be a value up in tha 0.1\-100.0 range, default value is 1.0.
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
Set chroma blur filta strength, must be a value up in range 0.1\-4.0 fo' realz. A
greata value will result up in a mo' blurred image, n' up in slower
processing.
.IP "\fBchroma_pre_filter_radius, cpfr\fR" 4
.IX Item "chroma_pre_filter_radius, cpfr"
Set chroma pre-filta radius, must be a value up in tha 0.1\-2.0 range.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set chroma maximum difference between pixels ta still be considered,
must be a value up in tha 0.1\-100.0 range.
.PP
Each chroma option value, if not explicitly specified, is set ta the
correspondin luma option value.
.SS "scale"
.IX Subsection "scale"
Scale (resize) tha input vizzle, rockin tha libswscale library.
.PP
Da scale filta forces tha output display aspect ratio ta be tha same
of tha input, by changin tha output sample aspect ratio.
.PP
If tha input image format is different from tha format axed by
the next filter, tha scale filta will convert tha input ta the
axed format.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da filta accepts tha followin options, or any of tha options
supported by tha libswscale scaler.
.PP
See tha ffmpeg-scala manual for
the complete list of scala options.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Set tha output vizzle dimension expression. I aint talkin' bout chicken n' gravy biatch. Default value is tha input
dimension.
.Sp
If tha value is 0, tha input width is used fo' tha output.
.Sp
If one of tha joints is \-1, tha scale filta will bust a value that
maintains tha aspect ratio of tha input image, calculated from the
other specified dimension. I aint talkin' bout chicken n' gravy biatch. If both of dem is \-1, tha input size is
used
.Sp
See below fo' tha list of accepted constants fo' use up in tha dimension
expression.
.IP "\fBinterl\fR" 4
.IX Item "interl"
Set tha interlacin mode. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Force interlaced aware scaling.
.IP "\fB0\fR" 4
.IX Item "0"
Do not apply interlaced scaling.
.IP "\fB\-1\fR" 4
.IX Item "-1"
Select interlaced aware scalin dependin on whether tha source frames
are flagged as interlaced or not.
.RE
.RS 4
.Sp
Default value is \fB0\fR.
.RE
.IP "\fBflags\fR" 4
.IX Item "flags"
Set libswscale scalin flags. Right back up in yo muthafuckin ass. See
the ffmpeg-scala manual fo' the
complete list of joints, n' you can put dat on yo' toast. If not explictly specified tha filta applies
the default flags.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha vizzle size. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual.
.IP "\fBin_color_matrix\fR" 4
.IX Item "in_color_matrix"
.PD 0
.IP "\fBout_color_matrix\fR" 4
.IX Item "out_color_matrix"
.PD
Set in/output YCbCr color space type.
.Sp
This allows tha autodetected value ta be overridden as well as allows forcing
a specific value used fo' tha output n' encoder.
.Sp
If not specified, tha color space type dependz on tha pixel format.
.Sp
Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Choose automatically.
.IP "\fBbt709\fR" 4
.IX Item "bt709"
Format conformin ta Internationistic Telecommunication Union (\s-1ITU\s0)
Recommendation \s-1BT.709.\s0
.IP "\fBfcc\fR" 4
.IX Item "fcc"
Set color space conformin ta tha United Hoodz Federal Communications
Commission (\s-1FCC\s0) Code of Federal Regulations (\s-1CFR\s0) Title 47 (2003) 73.682 (a).
.IP "\fBbt601\fR" 4
.IX Item "bt601"
Set color space conformin to:
.RS 4
.IP "\(bu" 4
\&\s-1ITU\s0 Radiocommunication Sector (ITU-R) Recommendation \s-1BT.601\s0
.IP "\(bu" 4
ITU-R Rec. \s-1BT.470\-6 \s0(1998) Systems B, B1, n' G
.IP "\(bu" 4
Posse of Motion Picture n' Televizzle Engineers (\s-1SMPTE\s0) \s-1ST 170:2004\s0
.RE
.RS 4
.RE
.IP "\fBsmpte240m\fR" 4
.IX Item "smpte240m"
Set color space conformin ta \s-1SMPTE ST 240:1999.\s0
.RE
.RS 4
.RE
.IP "\fBin_range\fR" 4
.IX Item "in_range"
.PD 0
.IP "\fBout_range\fR" 4
.IX Item "out_range"
.PD
Set in/output YCbCr sample range.
.Sp
This allows tha autodetected value ta be overridden as well as allows forcing
a specific value used fo' tha output n' encoder n' shit. If not specified, the
range dependz on tha pixel format. Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Choose automatically.
.IP "\fBjpeg/full/pc\fR" 4
.IX Item "jpeg/full/pc"
Set full range (0\-255 up in case of 8\-bit luma).
.IP "\fBmpeg/tv\fR" 4
.IX Item "mpeg/tv"
Set \*(L"\s-1MPEG\*(R"\s0 range (16\-235 up in case of 8\-bit luma).
.RE
.RS 4
.RE
.IP "\fBforce_original_aspect_ratio\fR" 4
.IX Item "force_original_aspect_ratio"
Enable decreasin or increasin output vizzle width or height if necessary to
keep tha original gangsta aspect ratio. Possible joints:
.RS 4
.IP "\fBdisable\fR" 4
.IX Item "disable"
Scale tha vizzle as specified n' disable dis feature.
.IP "\fBdecrease\fR" 4
.IX Item "decrease"
Da output vizzle dimensions will automatically be decreased if needed.
.IP "\fBincrease\fR" 4
.IX Item "increase"
Da output vizzle dimensions will automatically be increased if needed.
.RE
.RS 4
.Sp
One useful instizzle of dis option is dat when you know a specific device's
maximum allowed resolution, you can use dis ta limit tha output vizzle to
that, while retainin tha aspect ratio. For example, thang A allows
1280x720 playback, n' yo' vizzle is 1920x800. Usin dis option (set it to
decrease) n' specifyin 1280x720 ta tha command line make tha output
1280x533.
.Sp
Please note dat dis be a gangbangin' finger-lickin' different thang than specifyin \-1 fo' \fBw\fR
or \fBh\fR, you still need ta specify tha output resolution fo' dis option
to work.
.RE
.PP
Da jointz of tha \fBw\fR n' \fBh\fR options is expressions
containin tha followin constants:
.IP "\fIin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fIin_h\fR" 4
.IX Item "in_h"
.PD
the input width n' height
.IP "\fIiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fIih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fIout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fIout_h\fR" 4
.IX Item "out_h"
.PD
the output (scaled) width n' height
.IP "\fIow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fIoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fIa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fIsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fIdar\fR" 4
.IX Item "dar"
input display aspect ratio. Calculated from \f(CW\*(C`(iw / ih) * sar\*(C'\fR.
.IP "\fIhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fIvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Scale tha input vizzle ta a size of 200x100:
.Sp
.Vb 1
\&        scale=w=200:h=100
.Ve
.Sp
This is equivalent to:
.Sp
.Vb 1
\&        scale=200:100
.Ve
.Sp
or:
.Sp
.Vb 1
\&        scale=200x100
.Ve
.IP "\(bu" 4
Specify a size abbreviation fo' tha output size:
.Sp
.Vb 1
\&        scale=qcif
.Ve
.Sp
which can also be freestyled as:
.Sp
.Vb 1
\&        scale=size=qcif
.Ve
.IP "\(bu" 4
Scale tha input ta 2x:
.Sp
.Vb 1
\&        scale=w=2*iw:h=2*ih
.Ve
.IP "\(bu" 4
Da above is tha same ol' dirty as:
.Sp
.Vb 1
\&        scale=2*in_w:2*in_h
.Ve
.IP "\(bu" 4
Scale tha input ta 2x wit forced interlaced scaling:
.Sp
.Vb 1
\&        scale=2*iw:2*ih:interl=1
.Ve
.IP "\(bu" 4
Scale tha input ta half size:
.Sp
.Vb 1
\&        scale=w=iw/2:h=ih/2
.Ve
.IP "\(bu" 4
Increase tha width, n' set tha height ta tha same size:
.Sp
.Vb 1
\&        scale=3/2*iw:ow
.Ve
.IP "\(bu" 4
Seek fo' Greek harmony:
.Sp
.Vb 2
\&        scale=iw:1/PHI*iw
\&        scale=ih*PHI:ih
.Ve
.IP "\(bu" 4
Increase tha height, n' set tha width ta 3/2 of tha height:
.Sp
.Vb 1
\&        scale=w=3/2*oh:h=3/5*ih
.Ve
.IP "\(bu" 4
Increase tha size yo, but make tha size a multiple of tha chroma
subsample joints:
.Sp
.Vb 1
\&        scale="trunc(3/2*iw/hsub)*hsub:trunc(3/2*ih/vsub)*vsub"
.Ve
.IP "\(bu" 4
Increase tha width ta a maximum of 500 pixels, keep tha same input
aspect ratio:
.Sp
.Vb 1
\&        scale=w=\*(Aqmin(500\e, iw*3/2):h=\-1\*(Aq
.Ve
.SS "separatefields"
.IX Subsection "separatefields"
Da \f(CW\*(C`separatefields\*(C'\fR takes a gangbangin' frame-based vizzle input n' splits
each frame tha fuck into its components fields, producin a freshly smoked up half height clip
with twice tha frame rate n' twice tha frame count.
.PP
This filta use field-dominizzle shiznit up in frame ta decizzle which
of each pair of fieldz ta place first up in tha output.
If it gets it wack use setfield filta before \f(CW\*(C`separatefields\*(C'\fR filter.
.SS "setdar, setsar"
.IX Subsection "setdar, setsar"
Da \f(CW\*(C`setdar\*(C'\fR filta sets tha Display Aspect Ratio fo' tha filter
output vizzle.
.PP
This is done by changin tha specified Sample (aka Pixel) Aspect
Ratio, accordin ta tha followin equation:
.PP
.Vb 1
\&        <DAR> = <HORIZONTAL_RESOLUTION> / <VERTICAL_RESOLUTION> * <SAR>
.Ve
.PP
Keep it realz in mind dat tha \f(CW\*(C`setdar\*(C'\fR filta do not modify tha pixel
dimensionz of tha vizzle frame fo' realz. Also tha display aspect ratio set by
this filta may be chizzled by lata filtas up in tha filterchain,
e.g. up in case of scalin or if another \*(L"setdar\*(R" or a \*(L"setsar\*(R" filta is
applied.
.PP
Da \f(CW\*(C`setsar\*(C'\fR filta sets tha Sample (aka Pixel) Aspect Ratio for
the filta output vizzle.
.PP
Note dat as a cold-ass lil consequence of tha application of dis filter, the
output display aspect ratio will chizzle accordin ta tha equation
above.
.PP
Keep it realz in mind dat tha sample aspect ratio set by tha \f(CW\*(C`setsar\*(C'\fR
filta may be chizzled by lata filtas up in tha filterchain, e.g. if
another \*(L"setsar\*(R" or a \*(L"setdar\*(R" filta be applied.
.PP
Da filtas accept tha followin options:
.ie n .IP "\fBr, ratio, dar (\fB""setdar""\fB only), sar (\f(BI""setsar""\fB only)\fR" 4
.el .IP "\fBr, ratio, dar (\f(CBsetdar\fB only), sar (\f(CBsetsar\fB only)\fR" 4
.IX Item "r, ratio, dar (setdar only), sar (setsar only)"
Set tha aspect ratio used by tha filter.
.Sp
Da parameta can be a gangbangin' floatin point number string, a expression, or
a strang of tha form \fInum\fR:\fIden\fR, where \fInum\fR and
\&\fIden\fR is tha numerator n' denominator of tha aspect ratio. If
the parameta aint specified, it be assumed tha value \*(L"0\*(R".
In case tha form "\fInum\fR:\fIden\fR" is used, tha \f(CW\*(C`:\*(C'\fR character
should be escaped.
.IP "\fBmax\fR" 4
.IX Item "max"
Set tha maximum integer value ta use fo' expressin numerator and
denominator when reducin tha expressed aspect ratio ta a rational.
Default value is \f(CW100\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
To chizzle tha display aspect ratio ta 16:9, specify one of tha following:
.Sp
.Vb 3
\&        setdar=dar=1.77777
\&        setdar=dar=16/9
\&        setdar=dar=1.77777
.Ve
.IP "\(bu" 4
To chizzle tha sample aspect ratio ta 10:11, specify:
.Sp
.Vb 1
\&        setsar=sar=10/11
.Ve
.IP "\(bu" 4
To set a gangbangin' finger-lickin' display aspect ratio of 16:9, n' specify a maximum integer value of
1000 up in tha aspect ratio reduction, use tha command:
.Sp
.Vb 1
\&        setdar=ratio=16/9:max=1000
.Ve
.SS "setfield"
.IX Subsection "setfield"
Force field fo' tha output vizzle frame.
.PP
Da \f(CW\*(C`setfield\*(C'\fR filta marks tha interlace type field fo' the
output frames. Well shiiiit, it do not chizzle tha input frame yo, but only sets the
correspondin property, which affects how tha fuck tha frame is treated by
followin filtas (e.g. \f(CW\*(C`fieldorder\*(C'\fR or \f(CW\*(C`yadif\*(C'\fR).
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Keep tha same field property.
.IP "\fBbff\fR" 4
.IX Item "bff"
Mark tha frame as bottom-field-first.
.IP "\fBtff\fR" 4
.IX Item "tff"
Mark tha frame as top-field-first.
.IP "\fBprog\fR" 4
.IX Item "prog"
Mark tha frame as progressive.
.RE
.RS 4
.RE
.SS "showinfo"
.IX Subsection "showinfo"
Show a line containin various shiznit fo' each input vizzle frame.
Da input vizzle aint modified.
.PP
Da shown line gotz nuff a sequence of key/value pairz of tha form
\&\fIkey\fR:\fIvalue\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
Presentation TimeStamp of tha input frame, expressed as a number of
time base units, n' you can put dat on yo' toast. Da time base unit dependz on tha filta input pad.
.IP "\fBpts_time\fR" 4
.IX Item "pts_time"
Presentation TimeStamp of tha input frame, expressed as a number of
seconds
.IP "\fBpos\fR" 4
.IX Item "pos"
posizzle of tha frame up in tha input stream, \-1 if dis shiznit in
unavailable and/or meaningless (for example up in case of synthetic vizzle)
.IP "\fBfmt\fR" 4
.IX Item "fmt"
pixel format name
.IP "\fBsar\fR" 4
.IX Item "sar"
sample aspect ratio of tha input frame, expressed up in tha form
\&\fInum\fR/\fIden\fR
.IP "\fBs\fR" 4
.IX Item "s"
size of tha input frame. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual.
.IP "\fBi\fR" 4
.IX Item "i"
interlaced mode (\*(L"P\*(R" fo' \*(L"progressive\*(R", \*(L"T\*(R" fo' top field first, \*(L"B\*(R"
for bottom field first)
.IP "\fBiskey\fR" 4
.IX Item "iskey"
1 if tha frame be a key frame, 0 otherwise
.IP "\fBtype\fR" 4
.IX Item "type"
picture type of tha input frame (\*(L"I\*(R" fo' a I\-frame, \*(L"P\*(R" fo' a
P\-frame, \*(L"B\*(R" fo' a B\-frame, \*(L"?\*(R" fo' unknown type).
Peep also tha documentation of tha \f(CW\*(C`AVPictureType\*(C'\fR enum n' of
the \f(CW\*(C`av_get_picture_type_char\*(C'\fR function defined in
\&\fIlibavutil/avutil.h\fR.
.IP "\fBchecksum\fR" 4
.IX Item "checksum"
Adler\-32 checksum (printed up in hexadecimal) of all tha planez of tha input frame
.IP "\fBplane_checksum\fR" 4
.IX Item "plane_checksum"
Adler\-32 checksum (printed up in hexadecimal) of each plane of tha input frame,
expressed up in tha form "[\fIc0\fR \fIc1\fR \fIc2\fR \fIc3\fR]"
.SS "smartblur"
.IX Subsection "smartblur"
Blur tha input vizzle without impactin tha outlines.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
Set tha luma radius. Da option value must be a gangbangin' float number in
the range [0.1,5.0] dat specifies tha variizzle of tha gaussian filter
used ta blur tha image (slower if larger). Default value is 1.0.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set tha luma strength. Da option value must be a gangbangin' float number
in tha range [\-1.0,1.0] dat configures tha blurrin fo' realz. A value included
in [0.0,1.0] will blur tha image whereas a value included in
[\-1.0,0.0] will sharpen tha image. Default value is 1.0.
.IP "\fBluma_threshold, lt\fR" 4
.IX Item "luma_threshold, lt"
Set tha luma threshold used as a cold-ass lil coefficient ta determine
whether a pixel should be blurred or not. Da option value must be an
integer up in tha range [\-30,30] fo' realz. A value of 0 will filta all tha image,
a value included up in [0,30] will filta flat areas n' a value included
in [\-30,0] will filta edges. Default value is 0.
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
Set tha chroma radius. Da option value must be a gangbangin' float number in
the range [0.1,5.0] dat specifies tha variizzle of tha gaussian filter
used ta blur tha image (slower if larger). Default value is 1.0.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set tha chroma strength. Da option value must be a gangbangin' float number
in tha range [\-1.0,1.0] dat configures tha blurrin fo' realz. A value included
in [0.0,1.0] will blur tha image whereas a value included in
[\-1.0,0.0] will sharpen tha image. Default value is 1.0.
.IP "\fBchroma_threshold, ct\fR" 4
.IX Item "chroma_threshold, ct"
Set tha chroma threshold used as a cold-ass lil coefficient ta determine
whether a pixel should be blurred or not. Da option value must be an
integer up in tha range [\-30,30] fo' realz. A value of 0 will filta all tha image,
a value included up in [0,30] will filta flat areas n' a value included
in [\-30,0] will filta edges. Default value is 0.
.PP
If a cold-ass lil chroma option aint explicitly set, tha correspondin luma value
is set.
.SS "stereo3d"
.IX Subsection "stereo3d"
Convert between different stereoscopic image formats.
.PP
Da filtas accept tha followin options:
.IP "\fBin\fR" 4
.IX Item "in"
Set stereoscopic image format of input.
.Sp
Available joints fo' input image formats are:
.RS 4
.IP "\fBsbsl\fR" 4
.IX Item "sbsl"
side by side parallel (left eye left, right eye right)
.IP "\fBsbsr\fR" 4
.IX Item "sbsr"
side by side crosseye (right eye left, left eye right)
.IP "\fBsbs2l\fR" 4
.IX Item "sbs2l"
side by side parallel wit half width resolution
(left eye left, right eye right)
.IP "\fBsbs2r\fR" 4
.IX Item "sbs2r"
side by side crosseye wit half width resolution
(right eye left, left eye right)
.IP "\fBabl\fR" 4
.IX Item "abl"
above-below (left eye above, right eye below)
.IP "\fBabr\fR" 4
.IX Item "abr"
above-below (right eye above, left eye below)
.IP "\fBab2l\fR" 4
.IX Item "ab2l"
above-below wit half height resolution
(left eye above, right eye below)
.IP "\fBab2r\fR" 4
.IX Item "ab2r"
above-below wit half height resolution
(right eye above, left eye below)
.IP "\fBal\fR" 4
.IX Item "al"
alternatin frames (left eye first, right eye second)
.IP "\fBar\fR" 4
.IX Item "ar"
alternatin frames (right eye first, left eye second)
.Sp
Default value is \fBsbsl\fR.
.RE
.RS 4
.RE
.IP "\fBout\fR" 4
.IX Item "out"
Set stereoscopic image format of output.
.Sp
Available joints fo' output image formats is all tha input formats as well as:
.RS 4
.IP "\fBarbg\fR" 4
.IX Item "arbg"
anaglyph red/blue gray
(red filta on left eye, blue filta on right eye)
.IP "\fBargg\fR" 4
.IX Item "argg"
anaglyph red/chronic gray
(red filta on left eye, chronic filta on right eye)
.IP "\fBarcg\fR" 4
.IX Item "arcg"
anaglyph red/cyan gray
(red filta on left eye, cyan filta on right eye)
.IP "\fBarch\fR" 4
.IX Item "arch"
anaglyph red/cyan half colored
(red filta on left eye, cyan filta on right eye)
.IP "\fBarcc\fR" 4
.IX Item "arcc"
anaglyph red/cyan color
(red filta on left eye, cyan filta on right eye)
.IP "\fBarcd\fR" 4
.IX Item "arcd"
anaglyph red/cyan color optimized wit tha least squares projection of dubois
(red filta on left eye, cyan filta on right eye)
.IP "\fBagmg\fR" 4
.IX Item "agmg"
anaglyph green/magenta gray
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmh\fR" 4
.IX Item "agmh"
anaglyph green/magenta half colored
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmc\fR" 4
.IX Item "agmc"
anaglyph green/magenta colored
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmd\fR" 4
.IX Item "agmd"
anaglyph green/magenta color optimized wit tha least squares projection of dubois
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBizzlebg\fR" 4
.IX Item "aybg"
anaglyph yellow/blue gray
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebh\fR" 4
.IX Item "aybh"
anaglyph yellow/blue half colored
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebc\fR" 4
.IX Item "aybc"
anaglyph yellow/blue colored
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebd\fR" 4
.IX Item "aybd"
anaglyph yellow/blue color optimized wit tha least squares projection of dubois
(yellow filta on left eye, blue filta on right eye)
.IP "\fBirl\fR" 4
.IX Item "irl"
interleaved rows (left eye has top row, right eye starts on next row)
.IP "\fBirr\fR" 4
.IX Item "irr"
interleaved rows (right eye has top row, left eye starts on next row)
.IP "\fBml\fR" 4
.IX Item "ml"
mono output (left eye only)
.IP "\fBmr\fR" 4
.IX Item "mr"
mono output (right eye only)
.RE
.RS 4
.Sp
Default value is \fBarcd\fR.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert input vizzle from side by side parallel ta anaglyph yellow/blue dubois:
.Sp
.Vb 1
\&        stereo3d=sbsl:aybd
.Ve
.IP "\(bu" 4
Convert input vizzle from above bellow (left eye above, right eye below) ta side by side crosseye.
.Sp
.Vb 1
\&        stereo3d=abl:sbsr
.Ve
.SS "spp"
.IX Subsection "spp"
Apply a simple postprocessin filta dat compresses n' decompresses tha image
at nuff muthafuckin (or \- up in tha case of \fBquality\fR level \f(CW6\fR \- all) shifts
and average tha thangs up in dis biatch.
.PP
Da filta accepts tha followin options:
.IP "\fBquality\fR" 4
.IX Item "quality"
Set quality. This option defines tha number of levels fo' averaging. Well shiiiit, it accepts
an integer up in tha range 0\-6. If set ta \f(CW0\fR, tha filta gonna git no
effect fo' realz. A value of \f(CW6\fR means tha higher quality. For each increment of
that value tha speed drops by a gangbangin' factor of approximately 2.  Default value is
\&\f(CW3\fR.
.IP "\fBqp\fR" 4
.IX Item "qp"
Force a cold-ass lil constant quantization parameter n' shit. If not set, tha filta will use tha \s-1QP\s0
from tha vizzle stream (if available).
.IP "\fBmode\fR" 4
.IX Item "mode"
Set thresholdin mode fo' realz. Available modes are:
.RS 4
.IP "\fBhard\fR" 4
.IX Item "hard"
Set hard thresholdin (default).
.IP "\fBsoft\fR" 4
.IX Item "soft"
Set soft thresholdin (betta de-ringin effect yo, but likely blurrier).
.RE
.RS 4
.RE
.IP "\fBuse_bframe_qp\fR" 4
.IX Item "use_bframe_qp"
Enable tha use of tha \s-1QP\s0 from tha B\-Frames if set ta \f(CW1\fR. Usin this
option may cause flicker since tha B\-Frames have often larger \s-1QP.\s0 Default is
\&\f(CW0\fR (not enabled).
.SS "subtitles"
.IX Subsection "subtitles"
Draw subtitlez on top of input vizzle rockin tha libass library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libass\*(C'\fR. This filta also requires a funky-ass build wit libavcodec and
libavformat ta convert tha passed subtitlez file ta \s-1ASS \s0(Advanced Substation
Alpha) subtitlez format.
.PP
Da filta accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filename of tha subtitle file ta read. Y'all KNOW dat shit, muthafucka! Well shiiiit, it must be specified.
.IP "\fBoriginal_size\fR" 4
.IX Item "original_size"
Specify tha size of tha original gangsta vizzle, tha vizzle fo' which tha \s-1ASS\s0 file
was composed. Y'all KNOW dat shit, muthafucka! For tha syntax of dis option, check tha \*(L"Video size\*(R" section in
the ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Cuz of a misdesign up in \s-1ASS\s0 aspect ratio arithmetic,
this is necessary ta erectly scale tha fonts if tha aspect ratio has been
changed.
.IP "\fBcharenc\fR" 4
.IX Item "charenc"
Set subtitlez input characta encoding. \f(CW\*(C`subtitles\*(C'\fR filta only. Only
useful if not \s-1UTF\-8.\s0
.PP
If tha straight-up original gangsta key aint specified, it be assumed dat tha straight-up original gangsta value
specifies tha \fBfilename\fR.
.PP
For example, ta render tha file \fIsub.srt\fR on top of tha input
video, use tha command:
.PP
.Vb 1
\&        subtitles=sub.srt
.Ve
.PP
which is equivalent to:
.PP
.Vb 1
\&        subtitles=filename=sub.srt
.Ve
.SS "super2xsai"
.IX Subsection "super2xsai"
Scale tha input by 2x n' smooth rockin tha Super2xSaI (Scale and
Interpolate) pixel art scalin algorithm.
.PP
Useful fo' enlargin pixel art images without reducin sharpness.
.SS "swapuv"
.IX Subsection "swapuv"
Swap U & V plane.
.SS "telecine"
.IX Subsection "telecine"
Apply telecine process ta tha vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBfirst_field\fR" 4
.IX Item "first_field"
.RS 4
.PD 0
.IP "\fBtop, t\fR" 4
.IX Item "top, t"
.PD
top field first
.IP "\fBbottom, b\fR" 4
.IX Item "bottom, b"
bottom field first
Da default value is \f(CW\*(C`top\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fBpattern\fR" 4
.IX Item "pattern"
A strang of numbers representin tha pulldown pattern you wish ta apply.
Da default value is \f(CW23\fR.
.PP
.Vb 1
\&        Some typical patterns:
\&        
\&        NTSC output (30i):
\&        27.5p: 32222
\&        24p: 23 (classic)
\&        24p: 2332 (preferred)
\&        20p: 33
\&        18p: 334
\&        16p: 3444
\&        
\&        PAL output (25i):
\&        27.5p: 12222
\&        24p: 222222222223 ("Euro pulldown")
\&        16.67p: 33
\&        16p: 33333334
.Ve
.SS "thumbnail"
.IX Subsection "thumbnail"
Select da most thugged-out representatizzle frame up in a given sequence of consecutizzle frames.
.PP
Da filta accepts tha followin options:
.IP "\fBn\fR" 4
.IX Item "n"
Set tha frames batch size ta analyze; up in a set of \fIn\fR frames, tha filter
will pick one of them, n' then handle tha next batch of \fIn\fR frames until
the end yo, but it ain't no stoppin cause I be still poppin'. Default is \f(CW100\fR.
.PP
Since tha filta keeps track of tha whole frames sequence, a funky-ass bigger \fIn\fR
value will result up in a higher memory usage, so a high value aint recommended.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Extract one picture each 50 frames:
.Sp
.Vb 1
\&        thumbnail=50
.Ve
.IP "\(bu" 4
Complete example of a thumbnail creation wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.avi \-vf thumbnail,scale=300:200 \-frames:v 1 out.png
.Ve
.SS "tile"
.IX Subsection "tile"
Tile nuff muthafuckin successive frames together.
.PP
Da filta accepts tha followin options:
.IP "\fBlayout\fR" 4
.IX Item "layout"
Set tha grid size (i.e. tha number of lines n' columns). For tha syntax of
this option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.IP "\fBnb_frames\fR" 4
.IX Item "nb_frames"
Set tha maximum number of frames ta render up in tha given area. Well shiiiit, it must be less
than or equal ta \fIw\fRx\fIh\fR. Da default value is \f(CW0\fR, meanin all
the area is ghon be used.
.IP "\fBmargin\fR" 4
.IX Item "margin"
Set tha outa border margin up in pixels.
.IP "\fBpadding\fR" 4
.IX Item "padding"
Set tha inner border thicknizz (i.e. tha number of pixels between frames). For
more advanced paddin options (like fuckin havin different joints fo' tha edges),
refer ta tha pad vizzle filter.
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify tha color of tha unused areaFor tha syntax of dis option, check the
\&\*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da default value of \fIcolor\fR
is \*(L"black\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Produce 8x8 \s-1PNG\s0 tilez of all keyframes (\fB\-skip_frame nokey\fR) up in a porno:
.Sp
.Vb 1
\&        ffmpeg \-skip_frame nokey \-i file.avi \-vf \*(Aqscale=128:72,tile=8x8\*(Aq \-an \-vsync 0 keyframes%03d.png
.Ve
.Sp
Da \fB\-vsync 0\fR is necessary ta prevent \fBffmpeg\fR from
duplicatin each output frame ta accomodate tha originally detected frame
rate.
.IP "\(bu" 4
Display \f(CW5\fR pictures up in a area of \f(CW\*(C`3x2\*(C'\fR frames,
with \f(CW7\fR pixels between them, n' \f(CW2\fR pixelz of initial margin, using
mixed flat n' named options:
.Sp
.Vb 1
\&        tile=3x2:nb_frames=5:padding=7:margin=2
.Ve
.SS "tinterlace"
.IX Subsection "tinterlace"
Perform various typez of temporal field interlacing.
.PP
Frames is counted startin from 1, so tha straight-up original gangsta input frame is
considered odd.
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Specify tha mode of tha interlacing. This option can also be specified
as a value ridin' solo. Right back up in yo muthafuckin ass. See below fo' a list of joints fo' dis option.
.Sp
Available joints are:
.RS 4
.IP "\fBmerge, 0\fR" 4
.IX Item "merge, 0"
Move odd frames tha fuck into tha upper field, even tha fuck into tha lower field,
generatin a thugged-out double height frame at half frame rate.
.IP "\fBdrop_odd, 1\fR" 4
.IX Item "drop_odd, 1"
Only output even frames, odd frames is dropped, generatin a gangbangin' frame with
unchanged height at half frame rate.
.IP "\fBdrop_even, 2\fR" 4
.IX Item "drop_even, 2"
Only output odd frames, even frames is dropped, generatin a gangbangin' frame with
unchanged height at half frame rate.
.IP "\fBpad, 3\fR" 4
.IX Item "pad, 3"
Expand each frame ta full height yo, but pad alternate lines wit black,
generatin a gangbangin' frame wit double height all up in tha same input frame rate.
.IP "\fBinterleave_top, 4\fR" 4
.IX Item "interleave_top, 4"
Interleave tha upper field from odd frames wit tha lower field from
even frames, generatin a gangbangin' frame wit unchanged height at half frame rate.
.IP "\fBinterleave_bottom, 5\fR" 4
.IX Item "interleave_bottom, 5"
Interleave tha lower field from odd frames wit tha upper field from
even frames, generatin a gangbangin' frame wit unchanged height at half frame rate.
.IP "\fBinterlacex2, 6\fR" 4
.IX Item "interlacex2, 6"
Double frame rate wit unchanged height. Frames is banged each
containin tha second temporal field from tha previous input frame and
the first temporal field from tha next input frame. This mode relies on
the top_field_first flag. Useful fo' interlaced vizzle displays wit no
field synchronisation.
.RE
.RS 4
.Sp
Numeric joints is deprecated but is accepted fo' backward
compatibilitizzle reasons.
.Sp
Default mode is \f(CW\*(C`merge\*(C'\fR.
.RE
.IP "\fBflags\fR" 4
.IX Item "flags"
Specify flags influencin tha filta process.
.Sp
Available value fo' \fIflags\fR is:
.RS 4
.IP "\fBlow_pass_filter, vlfp\fR" 4
.IX Item "low_pass_filter, vlfp"
Enable vertical low-pass filterin up in tha filter.
Vertical low-pass filterin is required when bustin a interlaced
destination from a progressive source which gotz nuff high-frequency
vertical detail. Filterin will reduce interlace 'twitter' n' Moire
patterning.
.Sp
Vertical low-pass filterin can only be enabled fo' \fBmode\fR
\&\fIinterleave_top\fR n' \fIinterleave_bottom\fR.
.RE
.RS 4
.RE
.SS "transpose"
.IX Subsection "transpose"
Transpose rows wit columns up in tha input vizzle n' optionally flip dat shit.
.PP
This filta accepts tha followin options:
.IP "\fBdir\fR" 4
.IX Item "dir"
Specify tha transposizzle direction.
.Sp
Can assume tha followin joints:
.RS 4
.IP "\fB0, 4, cclock_flip\fR" 4
.IX Item "0, 4, cclock_flip"
Rotate by 90 degrees counterclockwise n' vertically flip (default), dat is:
.Sp
.Vb 3
\&        L.R     L.l
\&        . . \->  . .
\&        l.r     R.r
.Ve
.IP "\fB1, 5, clock\fR" 4
.IX Item "1, 5, clock"
Rotate by 90 degrees clockwise, dat is:
.Sp
.Vb 3
\&        L.R     l.L
\&        . . \->  . .
\&        l.r     r.R
.Ve
.IP "\fB2, 6, cclock\fR" 4
.IX Item "2, 6, cclock"
Rotate by 90 degrees counterclockwise, dat is:
.Sp
.Vb 3
\&        L.R     R.r
\&        . . \->  . .
\&        l.r     L.l
.Ve
.IP "\fB3, 7, clock_flip\fR" 4
.IX Item "3, 7, clock_flip"
Rotate by 90 degrees clockwise n' vertically flip, dat is:
.Sp
.Vb 3
\&        L.R     r.R
\&        . . \->  . .
\&        l.r     l.L
.Ve
.RE
.RS 4
.Sp
For joints between 4\-7, tha transposizzle is only done if tha input
video geometry is portrait n' not landscape. These joints are
deprecated, tha \f(CW\*(C`passthrough\*(C'\fR option should be used instead.
.Sp
Numerical joints is deprecated, n' should be dropped up in favor of
symbolic constants.
.RE
.IP "\fBpassthrough\fR" 4
.IX Item "passthrough"
Do not apply tha transposizzle if tha input geometry matches tha one
specified by tha specified value. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Always apply transposition.
.IP "\fBportrait\fR" 4
.IX Item "portrait"
Preserve portrait geometry (when \fIheight\fR >= \fIwidth\fR).
.IP "\fBlandscape\fR" 4
.IX Item "landscape"
Preserve landscape geometry (when \fIwidth\fR >= \fIheight\fR).
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`none\*(C'\fR.
.RE
.PP
For example ta rotate by 90 degrees clockwise n' preserve portrait
layout:
.PP
.Vb 1
\&        transpose=dir=1:passthrough=portrait
.Ve
.PP
Da command above can also be specified as:
.PP
.Vb 1
\&        transpose=1:portrait
.Ve
.SS "trim"
.IX Subsection "trim"
Trim tha input so dat tha output gotz nuff one continuous subpart of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBstart\fR" 4
.IX Item "start"
Specify time of tha start of tha kept section, i.e. tha frame wit the
timestamp \fIstart\fR is ghon be tha straight-up original gangsta frame up in tha output.
.IP "\fBend\fR" 4
.IX Item "end"
Specify time of tha straight-up original gangsta frame dat is ghon be dropped, i.e. tha frame
immediately precedin tha one wit tha timestamp \fIend\fR is ghon be tha last
frame up in tha output.
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
Same as \fIstart\fR, except dis option sets tha start timestamp up in timebase
units instead of seconds.
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Same as \fIend\fR, except dis option sets tha end timestamp up in timebase units
instead of seconds.
.IP "\fBduration\fR" 4
.IX Item "duration"
Specify maximum duration of tha output.
.IP "\fBstart_frame\fR" 4
.IX Item "start_frame"
Number of tha straight-up original gangsta frame dat should be passed ta output.
.IP "\fBend_frame\fR" 4
.IX Item "end_frame"
Number of tha straight-up original gangsta frame dat should be dropped.
.PP
\&\fBstart\fR, \fBend\fR, \fBduration\fR is expressed as time
duration justifications, check tha \*(L"Time duration\*(R" section up in the
ffmpeg-utils manual.
.PP
Note dat tha straight-up original gangsta two setz of tha start/end options n' tha \fBduration\fR
option peep tha frame timestamp, while tha _frame variants simply count the
frames dat pass all up in tha filter n' shiznit fo' realz. Also note dat dis filta do not modify
the timestamps. If you wish dat tha output timestamps start at zero, bang a
setpts filta afta tha trim filter.
.PP
If multiple start or end options is set, dis filta tries ta be greedy and
keep all tha frames dat match at least one of tha specified constraints, n' you can put dat on yo' toast. To keep
only tha part dat matches all tha constraints at once, chain multiple trim
filters.
.PP
Da defaults is such dat all tha input is kept. Right back up in yo muthafuckin ass. So it is possible ta set e.g.
just tha end joints ta keep every last muthafuckin thang before tha specified time.
.PP
Examples:
.IP "\(bu" 4
drop every last muthafuckin thang except tha second minute of input
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vf trim=60:120
.Ve
.IP "\(bu" 4
keep only tha straight-up original gangsta second
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vf trim=duration=1
.Ve
.SS "unsharp"
.IX Subsection "unsharp"
Sharpen or blur tha input vizzle.
.PP
It accepts tha followin parameters:
.IP "\fBluma_msize_x, lx\fR" 4
.IX Item "luma_msize_x, lx"
Set tha luma matrix horizontal size. Well shiiiit, it must be a odd integer between
3 n' 63, default value is 5.
.IP "\fBluma_msize_y, ly\fR" 4
.IX Item "luma_msize_y, ly"
Set tha luma matrix vertical size. Well shiiiit, it must be a odd integer between 3
and 63, default value is 5.
.IP "\fBluma_amount, la\fR" 4
.IX Item "luma_amount, la"
Set tha luma effect strength. Well shiiiit, it can be a gangbangin' float number, reasonable
values lay between \-1.5 n' 1.5.
.Sp
Negatizzle joints will blur tha input vizzle, while positizzle joints will
sharpen it, a value of zero will disable tha effect.
.Sp
Default value is 1.0.
.IP "\fBchroma_msize_x, cx\fR" 4
.IX Item "chroma_msize_x, cx"
Set tha chroma matrix horizontal size. Well shiiiit, it must be a odd integer
between 3 n' 63, default value is 5.
.IP "\fBchroma_msize_y, cy\fR" 4
.IX Item "chroma_msize_y, cy"
Set tha chroma matrix vertical size. Well shiiiit, it must be a odd integer
between 3 n' 63, default value is 5.
.IP "\fBchroma_amount, ca\fR" 4
.IX Item "chroma_amount, ca"
Set tha chroma effect strength. Well shiiiit, it can be a gangbangin' float number, reasonable
values lay between \-1.5 n' 1.5.
.Sp
Negatizzle joints will blur tha input vizzle, while positizzle joints will
sharpen it, a value of zero will disable tha effect.
.Sp
Default value is 0.0.
.IP "\fBopencl\fR" 4
.IX Item "opencl"
If set ta 1, specify rockin OpenCL capabilities, only available if
FFmpeg was configured wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR. Default value is 0.
.PP
All parametas is optionizzle n' default ta tha equivalent of the
strin '5:5:1.0:5:5:0.0'.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply phat luma sharpen effect:
.Sp
.Vb 1
\&        unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5
.Ve
.IP "\(bu" 4
Apply phat blur of both luma n' chroma parameters:
.Sp
.Vb 1
\&        unsharp=7:7:\-2:7:7:\-2
.Ve
.SS "vidstabdetect"
.IX Subsection "vidstabdetect"
Analyze vizzle stabilization/debobbin. Perform pass 1 of 2, see
vidstabtransform fo' pass 2.
.PP
This filta generates a gangbangin' file wit relatizzle translation n' rotation
transform shiznit bout subsequent frames, which is then used by
the vidstabtransform filter.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libvidstab\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBresult\fR" 4
.IX Item "result"
Set tha path ta tha file used ta write tha transforms shiznit.
Default value is \fItransforms.trf\fR.
.IP "\fBshakiness\fR" 4
.IX Item "shakiness"
Set how tha fuck shaky tha vizzle be n' how tha fuck quick tha camera is. Well shiiiit, it accepts an
integer up in tha range 1\-10, a value of 1 means lil shakiness, a
value of 10 means phat shakiness. Default value is 5.
.IP "\fBaccuracy\fR" 4
.IX Item "accuracy"
Set tha accuracy of tha detection process. Well shiiiit, it must be a value up in the
range 1\-15 fo' realz. A value of 1 means low accuracy, a value of 15 means high
accuracy. Default value is 9.
.IP "\fBstepsize\fR" 4
.IX Item "stepsize"
Set stepsize of tha search process. Da region round minimum is
scanned wit 1 pixel resolution. I aint talkin' bout chicken n' gravy biatch. Default value is 6.
.IP "\fBmincontrast\fR" 4
.IX Item "mincontrast"
Set minimum contrast. Below dis value a local measurement field is
discarded. Y'all KNOW dat shit, muthafucka! Must be a gangbangin' floatin point value up in tha range 0\-1. Default
value is 0.3.
.IP "\fBtripod\fR" 4
.IX Item "tripod"
Set reference frame number fo' tripod mode.
.Sp
If enabled, tha motion of tha frames is compared ta a reference frame
in tha filtered stream, identified by tha specified number n' shit. Da idea
is ta compensate all movements up in a more-or-less static scene n' keep
the camera view straight-up still.
.Sp
If set ta 0, it is disabled. Y'all KNOW dat shit, muthafucka! Da frames is counted startin from 1.
.IP "\fBshow\fR" 4
.IX Item "show"
Show fieldz n' transforms up in tha resultin frames. Well shiiiit, it accepts an
integer up in tha range 0\-2. Default value is 0, which disablez any
visualization.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use default joints:
.Sp
.Vb 1
\&        vidstabdetect
.Ve
.IP "\(bu" 4
Analyze straight fuckin shaky porno n' put tha thangs up in dis biatch up in file
\&\fImytransforms.trf\fR:
.Sp
.Vb 1
\&        vidstabdetect=shakiness=10:accuracy=15:result="mytransforms.trf"
.Ve
.IP "\(bu" 4
Visualize tha result of internal transformations up in tha resulting
video:
.Sp
.Vb 1
\&        vidstabdetect=show=1
.Ve
.IP "\(bu" 4
Analyze a vizzle wit medium shakinizz rockin \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i input \-vf vidstabdetect=shakiness=5:show=1 dummy.avi
.Ve
.SS "vidstabtransform"
.IX Subsection "vidstabtransform"
Video stabilization/debobbin: pass 2 of 2,
see vidstabdetect fo' pass 1.
.PP
Read a gangbangin' file wit transform shiznit fo' each frame and
apply/compensate em. Together wit tha vidstabdetect
filta dis can be used ta deshake vizzles. Right back up in yo muthafuckin ass. See also
<\fBhttp://public.hronopik.de/vid.stab\fR>. Well shiiiit, it is blingin ta also use
the unsharp filter, peep below.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libvidstab\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBinput\fR" 4
.IX Item "input"
path ta tha file used ta read tha transforms (default: \fItransforms.trf\fR)
.IP "\fBsmoothing\fR" 4
.IX Item "smoothing"
number of frames (value*2 + 1) used fo' lowpass filterin tha camera movements
(default: 10). For example a fuckin shitload of 10 means dat 21 frames is used
(10 up in tha past n' 10 up in tha future) ta smoothen tha motion up in the
video fo' realz. A larger joints leadz ta a smoother vizzle yo, but limits the
acceleration of tha camera (pan/tilt movements).
.IP "\fBmaxshift\fR" 4
.IX Item "maxshift"
maximal number of pixels ta translate frames (default: \-1 no limit)
.IP "\fBmaxangle\fR" 4
.IX Item "maxangle"
maximal angle up in radians (degree*PI/180) ta rotate frames (default: \-1
no limit)
.IP "\fBcrop\fR" 4
.IX Item "crop"
How tha fuck ta deal wit bordaz dat may be visible cuz of movement
compensation. I aint talkin' bout chicken n' gravy biatch fo' realz. Available joints are:
.RS 4
.IP "\fBkeep\fR" 4
.IX Item "keep"
keep image shiznit from previous frame (default)
.IP "\fBblack\fR" 4
.IX Item "black"
fill tha border black
.RE
.RS 4
.RE
.IP "\fBinvert\fR" 4
.IX Item "invert"
.RS 4
.PD 0
.IP "\fB0\fR" 4
.IX Item "0"
.PD
keep transforms aiiight (default)
.IP "\fB1\fR" 4
.IX Item "1"
invert transforms
.RE
.RS 4
.RE
.IP "\fBrelative\fR" 4
.IX Item "relative"
consider transforms as
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
absolute
.IP "\fB1\fR" 4
.IX Item "1"
relatizzle ta previous frame (default)
.RE
.RS 4
.RE
.IP "\fBzoom\fR" 4
.IX Item "zoom"
percentage ta zoom (default: 0)
.RS 4
.IP "\fB>0\fR" 4
.IX Item ">0"
zoom in
.IP "\fB<0\fR" 4
.IX Item "<0"
zoom out
.RE
.RS 4
.RE
.IP "\fBoptzoom\fR" 4
.IX Item "optzoom"
set optimal zoomin ta avoid borders
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
disabled
.IP "\fB1\fR" 4
.IX Item "1"
optimal static zoom value is determined (only straight-up phat movements will lead ta visible borders) (default)
.IP "\fB2\fR" 4
.IX Item "2"
optimal adaptizzle zoom value is determined (no bordaz is ghon be visible)
.RE
.RS 4
.Sp
Note dat tha value given at zoom be added ta tha one calculated
here.
.RE
.IP "\fBinterpol\fR" 4
.IX Item "interpol"
type of interpolation
.Sp
Available joints are:
.RS 4
.IP "\fBno\fR" 4
.IX Item "no"
no interpolation
.IP "\fBlinear\fR" 4
.IX Item "linear"
linear only horizontal
.IP "\fBbilinear\fR" 4
.IX Item "bilinear"
linear up in both directions (default)
.IP "\fBbicubic\fR" 4
.IX Item "bicubic"
cubic up in both directions (slow)
.RE
.RS 4
.RE
.IP "\fBtripod\fR" 4
.IX Item "tripod"
virtual tripod mode means dat tha vizzle is stabilized such dat the
camera stays stationary. Use also \f(CW\*(C`tripod\*(C'\fR option of
vidstabdetect.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
off (default)
.IP "\fB1\fR" 4
.IX Item "1"
virtual tripod mode: equivalent ta \f(CW\*(C`relative=0:smoothing=0\*(C'\fR
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
typical call wit default default joints:
 (note tha unsharp filta which be always recommended)
.Sp
.Vb 1
\&        ffmpeg \-i inp.mpeg \-vf vidstabtransform,unsharp=5:5:0.8:3:3:0.4 inp_stabilized.mpeg
.Ve
.IP "\(bu" 4
zoom up in a lil' bit mo' n' load transform data from a given file
.Sp
.Vb 1
\&        vidstabtransform=zoom=5:input="mytransforms.trf"
.Ve
.IP "\(bu" 4
smoothen tha vizzle even more
.Sp
.Vb 1
\&        vidstabtransform=smoothing=30
.Ve
.SS "vflip"
.IX Subsection "vflip"
Flip tha input vizzle vertically.
.PP
For example, ta vertically flip a vizzle wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vf "vflip" out.avi
.Ve
.SS "vignette"
.IX Subsection "vignette"
Make or reverse a natural vignettin effect.
.PP
Da filta accepts tha followin options:
.IP "\fBangle, a\fR" 4
.IX Item "angle, a"
Set lens angle expression as a fuckin shitload of radians.
.Sp
Da value is clipped up in tha \f(CW\*(C`[0,PI/2]\*(C'\fR range.
.Sp
Default value: \f(CW"PI/5"\fR
.IP "\fBx0\fR" 4
.IX Item "x0"
.PD 0
.IP "\fBy0\fR" 4
.IX Item "y0"
.PD
Set centa coordinates expressions. Respectively \f(CW"w/2"\fR n' \f(CW"h/2"\fR
by default.
.IP "\fBmode\fR" 4
.IX Item "mode"
Set forward/backward mode.
.Sp
Available modes are:
.RS 4
.IP "\fBforward\fR" 4
.IX Item "forward"
Da larger tha distizzle from tha central point, tha darker tha image becomes.
.IP "\fBbackward\fR" 4
.IX Item "backward"
Da larger tha distizzle from tha central point, tha brighta tha image becomes.
This can be used ta reverse a vignette effect, though there is no automatic
detection ta extract tha lens \fBangle\fR n' other settings (yet). Well shiiiit, it can
also be used ta create a funky-ass burnin effect.
.RE
.RS 4
.Sp
Default value is \fBforward\fR.
.RE
.IP "\fBeval\fR" 4
.IX Item "eval"
Set evaluation mode fo' tha expressions (\fBangle\fR, \fBx0\fR, \fBy0\fR).
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBinit\fR" 4
.IX Item "init"
Evaluate expressions only once durin tha filta initialization.
.IP "\fBframe\fR" 4
.IX Item "frame"
Evaluate expressions fo' each incomin frame. This is way slower than the
\&\fBinit\fR mode since it requires all tha scalaz ta be re-computed yo, but it
allows advanced dynamic expressions.
.RE
.RS 4
.Sp
Default value is \fBinit\fR.
.RE
.IP "\fBdither\fR" 4
.IX Item "dither"
Set ditherin ta reduce tha circular bandin effects, n' you can put dat on yo' toast. Default is \f(CW1\fR
(enabled).
.IP "\fBaspect\fR" 4
.IX Item "aspect"
Set vignette aspect. This settin allows ta adjust tha shape of tha vignette.
Settin dis value ta tha \s-1SAR\s0 of tha input will cook up a rectangular vignetting
followin tha dimensionz of tha vizzle.
.Sp
Default is \f(CW\*(C`1/1\*(C'\fR.
.PP
\fIExpressions\fR
.IX Subsection "Expressions"
.PP
Da \fBalpha\fR, \fBx0\fR n' \fBy0\fR expressions can contain the
followin parameters.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
input width n' height
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
the \s-1PTS \s0(Presentation TimeStamp) time of tha filtered vizzle frame, expressed in
\&\fI\s-1TB\s0\fR units, \s-1NAN\s0 if undefined
.IP "\fBr\fR" 4
.IX Item "r"
frame rate of tha input vizzle, \s-1NAN\s0 if tha input frame rate is unknown
.IP "\fBt\fR" 4
.IX Item "t"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in seconds, \s-1NAN\s0 if undefined
.IP "\fBtb\fR" 4
.IX Item "tb"
time base of tha input vizzle
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply simple phat vignettin effect:
.Sp
.Vb 1
\&        vignette=PI/4
.Ve
.IP "\(bu" 4
Make a gangbangin' flickerin vignetting:
.Sp
.Vb 1
\&        vignette=\*(AqPI/4+random(1)*PI/50\*(Aq:eval=frame
.Ve
.SS "w3fdif"
.IX Subsection "w3fdif"
Deinterlace tha input vizzle (\*(L"w3fdif\*(R" standz fo' \*(L"Weston 3 Field
Deinterlacin Filter\*(R").
.PP
Based on tha process busted lyrics bout by Martin Weston fo' \s-1BBC R&D,\s0 and
implemented based on tha de-interlace algorithm freestyled by Jim
Easterbrook fo' \s-1BBC R&D,\s0 tha Weston 3 field deinterlacin filter
uses filta coefficients calculated by \s-1BBC R&D.\s0
.PP
There is two setz of filta coefficients, so called \*(L"simple\*(R":
and \*(L"complex\*(R". Which set of filta coefficients is used can
be set by passin a optionizzle parameter:
.IP "\fBfilter\fR" 4
.IX Item "filter"
Set tha interlacin filta coefficients fo' realz. Accepts one of tha followin joints:
.RS 4
.IP "\fBsimple\fR" 4
.IX Item "simple"
Simple filta coefficient set.
.IP "\fBcomplex\fR" 4
.IX Item "complex"
Mo'-complex filta coefficient set.
.RE
.RS 4
.Sp
Default value is \fBcomplex\fR.
.RE
.IP "\fBdeint\fR" 4
.IX Item "deint"
Specify which frames ta deinterlace fo' realz. Accept one of tha followin joints:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Deinterlace all frames,
.IP "\fBinterlaced\fR" 4
.IX Item "interlaced"
Only deinterlace frames marked as interlaced.
.RE
.RS 4
.Sp
Default value is \fBall\fR.
.RE
.SS "yadif"
.IX Subsection "yadif"
Deinterlace tha input vizzle (\*(L"yadif\*(R" means \*(L"yet another deinterlacing
filter\*(R").
.PP
This filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Da interlacin mode ta adopt, accepts one of tha followin joints:
.RS 4
.IP "\fB0, send_frame\fR" 4
.IX Item "0, send_frame"
output 1 frame fo' each frame
.IP "\fB1, send_field\fR" 4
.IX Item "1, send_field"
output 1 frame fo' each field
.IP "\fB2, send_frame_nospatial\fR" 4
.IX Item "2, send_frame_nospatial"
like \f(CW\*(C`send_frame\*(C'\fR but skip spatial interlacin check
.IP "\fB3, send_field_nospatial\fR" 4
.IX Item "3, send_field_nospatial"
like \f(CW\*(C`send_field\*(C'\fR but skip spatial interlacin check
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`send_frame\*(C'\fR.
.RE
.IP "\fBparity\fR" 4
.IX Item "parity"
Da picture field paritizzle assumed fo' tha input interlaced vizzle, accepts one of
the followin joints:
.RS 4
.IP "\fB0, tff\fR" 4
.IX Item "0, tff"
assume top field first
.IP "\fB1, bff\fR" 4
.IX Item "1, bff"
assume bottom field first
.IP "\fB\-1, auto\fR" 4
.IX Item "-1, auto"
enable automatic detection
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`auto\*(C'\fR.
If interlacin is unknown or decoder do not export dis shiznit,
top field first is ghon be assumed.
.RE
.IP "\fBdeint\fR" 4
.IX Item "deint"
Specify which frames ta deinterlace fo' realz. Accept one of tha following
values:
.RS 4
.IP "\fB0, all\fR" 4
.IX Item "0, all"
deinterlace all frames
.IP "\fB1, interlaced\fR" 4
.IX Item "1, interlaced"
only deinterlace frames marked as interlaced
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`all\*(C'\fR.
.RE
.SH "VIDEO SOURCES"
.IX Header "VIDEO SOURCES"
Below be a thugged-out description of tha currently available vizzle sources.
.SS "buffer"
.IX Subsection "buffer"
Buffer vizzle frames, n' make dem available ta tha filta chain.
.PP
This source is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/vsrc_buffer.h\fR.
.PP
This source accepts tha followin options:
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Specify tha size (width n' height) of tha buffered vizzle frames. For the
syntax of dis option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils
manual.
.IP "\fBwidth\fR" 4
.IX Item "width"
Input vizzle width.
.IP "\fBheight\fR" 4
.IX Item "height"
Input vizzle height.
.IP "\fBpix_fmt\fR" 4
.IX Item "pix_fmt"
A strang representin tha pixel format of tha buffered vizzle frames.
It may be a number correspondin ta a pixel format, or a pixel format
name.
.IP "\fBtime_base\fR" 4
.IX Item "time_base"
Specify tha timebase assumed by tha timestampz of tha buffered frames.
.IP "\fBframe_rate\fR" 4
.IX Item "frame_rate"
Specify tha frame rate expected fo' tha vizzle stream.
.IP "\fBpixel_aspect, sar\fR" 4
.IX Item "pixel_aspect, sar"
Specify tha sample aspect ratio assumed by tha vizzle frames.
.IP "\fBsws_param\fR" 4
.IX Item "sws_param"
Specify tha optionizzle parametas ta be used fo' tha scale filta which
is automatically banged when a input chizzle is detected up in the
input size or format.
.PP
For example:
.PP
.Vb 1
\&        buffer=width=320:height=240:pix_fmt=yuv410p:time_base=1/24:sar=1
.Ve
.PP
will instruct tha source ta accept vizzle frames wit size 320x240 and
with format \*(L"yuv410p\*(R", assumin 1/24 as tha timestamps timebase and
square pixels (1:1 sample aspect ratio).
Since tha pixel format wit name \*(L"yuv410p\*(R" correspondz ta tha number 6
(check tha enum AVPixelFormat definizzle up in \fIlibavutil/pixfmt.h\fR),
this example correspondz to:
.PP
.Vb 1
\&        buffer=size=320x240:pixfmt=6:time_base=1/24:pixel_aspect=1/1
.Ve
.PP
Alternatively, tha options can be specified as a gangbangin' flat strin yo, but this
syntax is deprecated:
.PP
\&\fIwidth\fR:\fIheight\fR:\fIpix_fmt\fR:\fItime_base.num\fR:\fItime_base.den\fR:\fIpixel_aspect.num\fR:\fIpixel_aspect.den\fR[:\fIsws_param\fR]
.SS "cellauto"
.IX Subsection "cellauto"
Smoke a pattern generated by a elementary cellular automaton.
.PP
Da initial state of tha cellular automaton can be defined all up in the
\&\fBfilename\fR, n' \fBpattern\fR options. If such options are
not specified a initial state is pimped randomly.
.PP
At each freshly smoked up frame a freshly smoked up row up in tha vizzle is filled wit tha result of
the cellular automaton next generation. I aint talkin' bout chicken n' gravy biatch. Da behavior when tha whole
frame is filled is defined by tha \fBscroll\fR option.
.PP
This source accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Read tha initial cellular automaton state, i.e. tha startin row, from
the specified file.
In tha file, each non-whitespace characta is considered a kickin it
cell, a newline will terminizzle tha row, n' further charactas up in the
file is ghon be ignored.
.IP "\fBpattern, p\fR" 4
.IX Item "pattern, p"
Read tha initial cellular automaton state, i.e. tha startin row, from
the specified string.
.Sp
Each non-whitespace characta up in tha strang is considered a kickin it
cell, a newline will terminizzle tha row, n' further charactas up in the
strin is ghon be ignored.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha vizzle rate, dat is tha number of frames generated per second.
Default is 25.
.IP "\fBrandom_fill_ratio, ratio\fR" 4
.IX Item "random_fill_ratio, ratio"
Set tha random fill ratio fo' tha initial cellular automaton row. It
is a gangbangin' floatin point number value rangin from 0 ta 1, defaults to
1/PHI.
.Sp
This option is ignored when a gangbangin' file or a pattern is specified.
.IP "\fBrandom_seed, seed\fR" 4
.IX Item "random_seed, seed"
Set tha seed fo' fillin randomly tha initial row, must be a integer
included between 0 n' \s-1UINT32_MAX.\s0 If not specified, or if explicitly
set ta \-1, tha filta will try ta bust a phat random seed on a funky-ass best
effort basis.
.IP "\fBrule\fR" 4
.IX Item "rule"
Set tha cellular automaton rule, it aint nuthin but a number rangin from 0 ta 255.
Default value is 110.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha size of tha output vizzle. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.Sp
If \fBfilename\fR or \fBpattern\fR is specified, tha size is set
by default ta tha width of tha specified initial state row, n' the
height is set ta \fIwidth\fR * \s-1PHI.\s0
.Sp
If \fBsize\fR is set, it must contain tha width of tha specified
pattern string, n' tha specified pattern is ghon be centered up in the
larger row.
.Sp
If a gangbangin' filename or a pattern strang aint specified, tha size value
defaults ta \*(L"320x518\*(R" (used fo' a randomly generated initial state).
.IP "\fBscroll\fR" 4
.IX Item "scroll"
If set ta 1, scroll tha output upward when all tha rows up in tha output
have been already filled. Y'all KNOW dat shit, muthafucka! If set ta 0, tha freshly smoked up generated row will be
written over tha top row just afta tha bottom row is filled.
Defaults ta 1.
.IP "\fBstart_full, full\fR" 4
.IX Item "start_full, full"
If set ta 1, straight-up fill tha output wit generated rows before
outputtin tha straight-up original gangsta frame.
This is tha default behavior, fo' disablin set tha value ta 0.
.IP "\fBstitch\fR" 4
.IX Item "stitch"
If set ta 1, stitch tha left n' right row edges together.
This is tha default behavior, fo' disablin set tha value ta 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read tha initial state from \fIpattern\fR, n' specify a output of
size 200x400.
.Sp
.Vb 1
\&        cellauto=f=pattern:s=200x400
.Ve
.IP "\(bu" 4
Generate a random initial row wit a width of 200 cells, wit a gangbangin' fill
ratio of 2/3:
.Sp
.Vb 1
\&        cellauto=ratio=2/3:s=200x200
.Ve
.IP "\(bu" 4
Smoke a pattern generated by rule 18 startin by a single kickin it cell
centered on a initial row wit width 100:
.Sp
.Vb 1
\&        cellauto=p=@s=100x400:full=0:rule=18
.Ve
.IP "\(bu" 4
Specify a mo' elaborated initial pattern:
.Sp
.Vb 1
\&        cellauto=p=\*(Aq@@ @ @@\*(Aq:s=100x400:full=0:rule=18
.Ve
.SS "mandelbrot"
.IX Subsection "mandelbrot"
Generate a Mandelbrot set fractal, n' progressively zoom towardz the
point specified wit \fIstart_x\fR n' \fIstart_y\fR.
.PP
This source accepts tha followin options:
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Set tha terminal pts value. Default value is 400.
.IP "\fBend_scale\fR" 4
.IX Item "end_scale"
Set tha terminal scale value.
Must be a gangbangin' floatin point value. Default value is 0.3.
.IP "\fBinner\fR" 4
.IX Item "inner"
Set tha inner colorin mode, dat is tha algorithm used ta draw the
Mandelbrot fractal internal region.
.Sp
It shall assume one of tha followin joints:
.RS 4
.IP "\fBblack\fR" 4
.IX Item "black"
Set black mode.
.IP "\fBconvergence\fR" 4
.IX Item "convergence"
Show time until convergence.
.IP "\fBmincol\fR" 4
.IX Item "mincol"
Set color based on point closest ta tha origin of tha iterations.
.IP "\fBperiod\fR" 4
.IX Item "period"
Set period mode.
.RE
.RS 4
.Sp
Default value is \fImincol\fR.
.RE
.IP "\fBbailout\fR" 4
.IX Item "bailout"
Set tha bailout value. Default value is 10.0.
.IP "\fBmaxiter\fR" 4
.IX Item "maxiter"
Set tha maximum of iterations performed by tha rendering
algorithm. Default value is 7189.
.IP "\fBouter\fR" 4
.IX Item "outer"
Set outa colorin mode.
It shall assume one of followin joints:
.RS 4
.IP "\fBiteration_count\fR" 4
.IX Item "iteration_count"
Set iteration cound mode.
.IP "\fBnormalized_iteration_count\fR" 4
.IX Item "normalized_iteration_count"
set normalized iteration count mode.
.RE
.RS 4
.Sp
Default value is \fInormalized_iteration_count\fR.
.RE
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set frame rate, expressed as number of frames per second. Y'all KNOW dat shit, muthafucka! Default
value is \*(L"25\*(R".
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set frame size. For tha syntax of dis option, check tha \*(L"Video
size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is \*(L"640x480\*(R".
.IP "\fBstart_scale\fR" 4
.IX Item "start_scale"
Set tha initial scale value. Default value is 3.0.
.IP "\fBstart_x\fR" 4
.IX Item "start_x"
Set tha initial x position. I aint talkin' bout chicken n' gravy biatch. Must be a gangbangin' floatin point value between
\&\-100 n' 100. Default value is \-0.743643887037158704752191506114774.
.IP "\fBstart_y\fR" 4
.IX Item "start_y"
Set tha initial y position. I aint talkin' bout chicken n' gravy biatch. Must be a gangbangin' floatin point value between
\&\-100 n' 100. Default value is \-0.131825904205311970493132056385139.
.SS "mptestsrc"
.IX Subsection "mptestsrc"
Generate various test patterns, as generated by tha MPlayer test filter.
.PP
Da size of tha generated vizzle is fixed, n' is 256x256.
This source is useful up in particular fo' testin encodin features.
.PP
This source accepts tha followin options:
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Specify tha frame rate of tha sourced vizzle, as tha number of frames
generated per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has ta be a strang up in tha format
\&\fIframe_rate_num\fR/\fIframe_rate_den\fR, a integer number, a gangbangin' float
number or a valid vizzle frame rate abbreviation. I aint talkin' bout chicken n' gravy biatch. Da default value is
\&\*(L"25\*(R".
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha vizzle duration of tha sourced vizzle. Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH:MM:SS[.m...]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
.Sp
If not specified, or tha expressed duration is negative, tha vizzle is
supposed ta be generated alllll muthafuckin day.
.IP "\fBtest, t\fR" 4
.IX Item "test, t"
Set tha number or tha name of tha test ta perform. Right back up in yo muthafuckin ass. Supported tests are:
.RS 4
.IP "\fBdc_luma\fR" 4
.IX Item "dc_luma"
.PD 0
.IP "\fBdc_chroma\fR" 4
.IX Item "dc_chroma"
.IP "\fBfreq_luma\fR" 4
.IX Item "freq_luma"
.IP "\fBfreq_chroma\fR" 4
.IX Item "freq_chroma"
.IP "\fBamp_luma\fR" 4
.IX Item "amp_luma"
.IP "\fBamp_chroma\fR" 4
.IX Item "amp_chroma"
.IP "\fBcbp\fR" 4
.IX Item "cbp"
.IP "\fBmv\fR" 4
.IX Item "mv"
.IP "\fBring1\fR" 4
.IX Item "ring1"
.IP "\fBring2\fR" 4
.IX Item "ring2"
.IP "\fBall\fR" 4
.IX Item "all"
.RE
.RS 4
.PD
.Sp
Default value is \*(L"all\*(R", which will cycle all up in tha list of all tests.
.RE
.PP
For example tha following:
.PP
.Vb 1
\&        testsrc=t=dc_luma
.Ve
.PP
will generate a \*(L"dc_luma\*(R" test pattern.
.SS "frei0r_src"
.IX Subsection "frei0r_src"
Provide a gangbangin' frei0r source.
.PP
To enable compilation of dis filta you need ta install tha frei0r
header n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-frei0r\*(C'\fR.
.PP
This source accepts tha followin options:
.IP "\fBsize\fR" 4
.IX Item "size"
Da size of tha vizzle ta generate. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Framerate of tha generated vizzle, may be a strang of tha form
\&\fInum\fR/\fIden\fR or a gangbangin' frame rate abbreviation.
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name ta tha frei0r source ta load. Y'all KNOW dat shit, muthafucka! For mo' shiznit regardin frei0r and
how ta set tha parametas read tha section frei0r up in tha description of
the vizzle filters.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
A '|'\-separated list of parametas ta pass ta tha frei0r source.
.PP
For example, ta generate a gangbangin' frei0r partik0l source wit size 200x200
and frame rate 10 which is overlayed on tha overlay filta main input:
.PP
.Vb 1
\&        frei0r_src=size=200x200:framerate=10:filter_name=partik0l:filter_params=1234 [overlay]; [in][overlay] overlay
.Ve
.SS "life"
.IX Subsection "life"
Generate a game pattern.
.PP
This source is based on a generalization of Jizzy Conwayz game game.
.PP
Da sourced input represents a game grid, each pixel represents a cold-ass lil cell
which can be up in one of two possible states, kickin it or dead as fuckin fried chicken. I aint talkin' bout chicken n' gravy biatch. Every cell
interacts wit its eight neighbours, which is tha cells dat are
horizontally, vertically, or diagonally adjacent.
.PP
At each interaction tha grid evolves accordin ta tha adopted rule,
which specifies tha number of neighbor kickin it cells which will make a
cell stay kickin it or born, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da \fBrule\fR option allows ta specify
the rule ta adopt.
.PP
This source accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha file from which ta read tha initial grid state. In tha file,
each non-whitespace characta is considered a kickin it cell, n' newline
is used ta delimit tha end of each row.
.Sp
If dis option aint specified, tha initial grid is generated
randomly.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha vizzle rate, dat is tha number of frames generated per second.
Default is 25.
.IP "\fBrandom_fill_ratio, ratio\fR" 4
.IX Item "random_fill_ratio, ratio"
Set tha random fill ratio fo' tha initial random grid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a
floatin point number value rangin from 0 ta 1, defaults ta 1/PHI.
It be ignored when a gangbangin' file is specified.
.IP "\fBrandom_seed, seed\fR" 4
.IX Item "random_seed, seed"
Set tha seed fo' fillin tha initial random grid, must be a integer
included between 0 n' \s-1UINT32_MAX.\s0 If not specified, or if explicitly
set ta \-1, tha filta will try ta bust a phat random seed on a funky-ass best
effort basis.
.IP "\fBrule\fR" 4
.IX Item "rule"
Set tha game rule.
.Sp
A rule can be specified wit a cold-ass lil code of tha kind "S\fI\s-1NS\s0\fR/B\fI\s-1NB\s0\fR",
where \fI\s-1NS\s0\fR n' \fI\s-1NB\s0\fR is sequencez of numbers up in tha range 0\-8,
\&\fI\s-1NS\s0\fR specifies tha number of kickin it neighbor cells which make a
live cell stay kickin it, n' \fI\s-1NB\s0\fR tha number of kickin it neighbor cells
which cook up a thugged-out dead cell ta become kickin it (i.e. ta \*(L"born\*(R").
\&\*(L"s\*(R" n' \*(L"b\*(R" can be used up in place of \*(L"S\*(R" n' \*(L"B\*(R", respectively.
.Sp
Alternatively a rule can be specified by a 18\-bits integer n' shit. Da 9
high order bits is used ta encode tha next cell state if it is kickin it
for each number of neighbor kickin it cells, tha low order bits specify
the rule fo' \*(L"borning\*(R" freshly smoked up cells yo. Higher order bits encode fo' an
higher number of neighbor cells.
For example tha number 6153 = \f(CW\*(C`(12<<9)+9\*(C'\fR specifies a stay kickin it
rule of 12 n' a funky-ass born rule of 9, which correspondz ta \*(L"S23/B03\*(R".
.Sp
Default value is \*(L"S23/B3\*(R", which is tha original gangsta Conwayz game of game
rule, n' will keep a cold-ass lil cell kickin it if it has 2 or 3 neighbor kickin it
cells, n' will born a freshly smoked up cell if there be three kickin it cells around
a dead cell.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha size of tha output vizzle. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.Sp
If \fBfilename\fR is specified, tha size is set by default ta the
same size of tha input file. If \fBsize\fR is set, it must contain
the size specified up in tha input file, n' tha initial grid defined in
that file is centered up in tha larger resultin area.
.Sp
If a gangbangin' filename aint specified, tha size value defaults ta \*(L"320x240\*(R"
(used fo' a randomly generated initial grid).
.IP "\fBstitch\fR" 4
.IX Item "stitch"
If set ta 1, stitch tha left n' right grid edges together, n' the
top n' bottom edges also. Defaults ta 1.
.IP "\fBmold\fR" 4
.IX Item "mold"
Set cell mold speed. Y'all KNOW dat shit, muthafucka! If set, a thugged-out dead cell will go from \fBdeath_color\fR to
\&\fBmold_color\fR wit a step of \fBmold\fR. \fBmold\fR can have a
value from 0 ta 255.
.IP "\fBlife_color\fR" 4
.IX Item "life_color"
Set tha color of livin (or freshly smoked up born) cells.
.IP "\fBdeath_color\fR" 4
.IX Item "death_color"
Set tha color of dead cells. If \fBmold\fR is set, dis is tha straight-up original gangsta color
used ta represent a thugged-out dead cell.
.IP "\fBmold_color\fR" 4
.IX Item "mold_color"
Set mold color, fo' definitely dead n' moldy cells.
.Sp
For tha syntax of these 3 color options, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read a grid from \fIpattern\fR, n' centa it on a grid of size
300x300 pixels:
.Sp
.Vb 1
\&        game=f=pattern:s=300x300
.Ve
.IP "\(bu" 4
Generate a random grid of size 200x200, wit a gangbangin' fill ratio of 2/3:
.Sp
.Vb 1
\&        game=ratio=2/3:s=200x200
.Ve
.IP "\(bu" 4
Specify a cold-ass lil custom rule fo' evolvin a randomly generated grid:
.Sp
.Vb 1
\&        game=rule=S14/B34
.Ve
.IP "\(bu" 4
Full example wit slow dirtnap effect (mold) rockin \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi game=s=300x200:mold=10:r=60:ratio=0.1:death_color=#C83232:life_color=#00ff00,scale=1200:800:flags=16
.Ve
.SS "color, haldclutsrc, nullsrc, rgbtestsrc, smptebars, smptehdbars, testsrc"
.IX Subsection "color, haldclutsrc, nullsrc, rgbtestsrc, smptebars, smptehdbars, testsrc"
Da \f(CW\*(C`color\*(C'\fR source serves up a uniformly colored input.
.PP
Da \f(CW\*(C`haldclutsrc\*(C'\fR source serves up a identitizzle Hald \s-1CLUT.\s0 See also
haldclut filter.
.PP
Da \f(CW\*(C`nullsrc\*(C'\fR source returns unprocessed vizzle frames. Well shiiiit, it is
mainly useful ta be employed up in analysis / debuggin tools, or as the
source fo' filtas which ignore tha input data.
.PP
Da \f(CW\*(C`rgbtestsrc\*(C'\fR source generates a \s-1RGB\s0 test pattern useful for
detectin \s-1RGB\s0 vs \s-1BGR\s0 issues. Yo ass should peep a red, chronic n' blue
stripe from top ta bottom.
.PP
Da \f(CW\*(C`smptebars\*(C'\fR source generates a cold-ass lil color bars pattern, based on
the \s-1SMPTE\s0 Engineerin Guideline \s-1EG 1\-1990.\s0
.PP
Da \f(CW\*(C`smptehdbars\*(C'\fR source generates a cold-ass lil color bars pattern, based on
the \s-1SMPTE RP 219\-2002.\s0
.PP
Da \f(CW\*(C`testsrc\*(C'\fR source generates a test vizzle pattern, showin a
color pattern, a scrollin gradient n' a timestamp. This is mainly
intended fo' testin purposes.
.PP
Da sources accept tha followin options:
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha source, only available up in tha \f(CW\*(C`color\*(C'\fR
source. For tha syntax of dis option, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual.
.IP "\fBlevel\fR" 4
.IX Item "level"
Specify tha level of tha Hald \s-1CLUT,\s0 only available up in tha \f(CW\*(C`haldclutsrc\*(C'\fR
source fo' realz. A level of \f(CW\*(C`N\*(C'\fR generates a picture of \f(CW\*(C`N*N*N\*(C'\fR by \f(CW\*(C`N*N*N\*(C'\fR
pixels ta be used as identitizzle matrix fo' 3D lookup tables. Each component is
coded on a \f(CW\*(C`1/(N*N)\*(C'\fR scale.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha size of tha sourced vizzle. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da default value is
\&\*(L"320x240\*(R".
.Sp
This option aint available wit tha \f(CW\*(C`haldclutsrc\*(C'\fR filter.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Specify tha frame rate of tha sourced vizzle, as tha number of frames
generated per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has ta be a strang up in tha format
\&\fIframe_rate_num\fR/\fIframe_rate_den\fR, a integer number, a gangbangin' float
number or a valid vizzle frame rate abbreviation. I aint talkin' bout chicken n' gravy biatch. Da default value is
\&\*(L"25\*(R".
.IP "\fBsar\fR" 4
.IX Item "sar"
Set tha sample aspect ratio of tha sourced vizzle.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha vizzle duration of tha sourced vizzle. Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
.Sp
If not specified, or tha expressed duration is negative, tha vizzle is
supposed ta be generated alllll muthafuckin day.
.IP "\fBdecimals, n\fR" 4
.IX Item "decimals, n"
Set tha number of decimals ta show up in tha timestamp, only available up in the
\&\f(CW\*(C`testsrc\*(C'\fR source.
.Sp
Da displayed timestamp value will correspond ta tha original
timestamp value multiplied by tha juice of 10 of tha specified
value. Default value is 0.
.PP
For example tha following:
.PP
.Vb 1
\&        testsrc=duration=5.3:size=qcif:rate=10
.Ve
.PP
will generate a vizzle wit a thugged-out duration of 5.3 seconds, wit size
176x144 n' a gangbangin' frame rate of 10 frames per second.
.PP
Da followin graph description will generate a red source
with a opacitizzle of 0.2, wit size \*(L"qcif\*(R" n' a gangbangin' frame rate of 10
frames per second.
.PP
.Vb 1
\&        color=c=red@0.2:s=qcif:r=10
.Ve
.PP
If tha input content is ta be ignored, \f(CW\*(C`nullsrc\*(C'\fR can be used. Y'all KNOW dat shit, muthafucka! The
followin command generates noise up in tha luminizzle plane by employing
the \f(CW\*(C`geq\*(C'\fR filter:
.PP
.Vb 1
\&        nullsrc=s=256x256, geq=random(1)*255:128:128
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
Da \f(CW\*(C`color\*(C'\fR source supports tha followin commands:
.IP "\fBc, color\fR" 4
.IX Item "c, color"
Set tha color of tha pimped image fo' realz. Accepts tha same ol' dirty syntax of the
correspondin \fBcolor\fR option.
.SH "VIDEO SINKS"
.IX Header "VIDEO SINKS"
Below be a thugged-out description of tha currently available vizzle sinks.
.SS "buffersink"
.IX Subsection "buffersink"
Buffer vizzle frames, n' make dem available ta tha end of tha filter
graph.
.PP
This sink is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/buffersink.h\fR
or tha options system.
.PP
It accepts a pointa ta a AVBufferSinkContext structure, which
defines tha incomin buffers' formats, ta be passed as tha opaque
parameta ta \f(CW\*(C`avfilter_init_filter\*(C'\fR fo' initialization.
.SS "nullsink"
.IX Subsection "nullsink"
Null vizzle sink, do straight-up not a god damn thang wit tha input vizzle. Well shiiiit, it is
mainly useful as a template n' ta be employed up in analysis / debugging
tools.
.SH "MULTIMEDIA FILTERS"
.IX Header "MULTIMEDIA FILTERS"
Below be a thugged-out description of tha currently available multimedia filters.
.SS "avectorscope"
.IX Subsection "avectorscope"
Convert input audio ta a vizzle output, representin tha audio vector
scope.
.PP
Da filta is used ta measure tha difference between channelz of stereo
audio stream fo' realz. A monoaural signal, consistin of identical left n' right
signal, thangs up in dis biatch up in straight vertical line fo' realz. Any stereo separation is visible
as a thugged-out deviation from dis line, bustin a Lissajous figure.
If tha straight (or deviation from it) but horizontal line appears this
indicates dat tha left n' right channels is outta phase.
.PP
Da filta accepts tha followin options:
.IP "\fBmode, m\fR" 4
.IX Item "mode, m"
Set tha vectorscope mode.
.Sp
Available joints are:
.RS 4
.IP "\fBlissajous\fR" 4
.IX Item "lissajous"
Lissajous rotated by 45 degrees.
.IP "\fBlissajous_xy\fR" 4
.IX Item "lissajous_xy"
Same as above but not rotated.
.RE
.RS 4
.Sp
Default value is \fBlissajous\fR.
.RE
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha vizzle size fo' tha output. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is \f(CW\*(C`400x400\*(C'\fR.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha output frame rate. Default value is \f(CW25\fR.
.IP "\fBrc\fR" 4
.IX Item "rc"
.PD 0
.IP "\fBgc\fR" 4
.IX Item "gc"
.IP "\fBbc\fR" 4
.IX Item "bc"
.PD
Specify tha red, chronic n' blue contrast. Default joints is \f(CW40\fR, \f(CW160\fR n' \f(CW80\fR.
Allowed range is \f(CW\*(C`[0, 255]\*(C'\fR.
.IP "\fBrf\fR" 4
.IX Item "rf"
.PD 0
.IP "\fBgf\fR" 4
.IX Item "gf"
.IP "\fBbf\fR" 4
.IX Item "bf"
.PD
Specify tha red, chronic n' blue fade. Default joints is \f(CW15\fR, \f(CW10\fR n' \f(CW5\fR.
Allowed range is \f(CW\*(C`[0, 255]\*(C'\fR.
.IP "\fBzoom\fR" 4
.IX Item "zoom"
Set tha zoom factor. Shiiit, dis aint no joke. Default value is \f(CW1\fR fo' realz. Allowed range is \f(CW\*(C`[1, 10]\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Complete example rockin \fBffplay\fR:
.Sp
.Vb 2
\&        ffplay \-f lavfi \*(Aqamovie=input.mp3, asplit [a][out1];
\&                     [a] avectorscope=zoom=1.3:rc=2:gc=200:bc=10:rf=1:gf=8:bf=7 [out0]\*(Aq
.Ve
.SS "concat"
.IX Subsection "concat"
Concatenate audio n' vizzle streams, joinin dem together one afta the
other.
.PP
Da filta works on segmentz of synchronized vizzle n' audio streams fo' realz. All
segments must have tha same number of streamz of each type, n' dat will
also be tha number of streams at output.
.PP
Da filta accepts tha followin options:
.IP "\fBn\fR" 4
.IX Item "n"
Set tha number of segments, n' you can put dat on yo' toast. Default is 2.
.IP "\fBv\fR" 4
.IX Item "v"
Set tha number of output vizzle streams, dat be also tha number of vizzle
streams up in each segment. Default is 1.
.IP "\fBa\fR" 4
.IX Item "a"
Set tha number of output audio streams, dat be also tha number of vizzle
streams up in each segment. Default is 0.
.IP "\fBunsafe\fR" 4
.IX Item "unsafe"
Activate unsafe mode: do not fail if segments gotz a gangbangin' finger-lickin' different format.
.PP
Da filta has \fIv\fR+\fIa\fR outputs: first \fIv\fR vizzle outputs, then
\&\fIa\fR audio outputs.
.PP
There is \fIn\fRx(\fIv\fR+\fIa\fR) inputs: first tha inputs fo' tha first
segment, up in tha same order as tha outputs, then tha inputs fo' tha second
segment, etc.
.PP
Related streams do not always have exactly tha same duration, fo' various
reasons includin codec frame size or sloppy authoring. For dat reason,
related synchronized streams (e.g. a vizzle n' its audio track) should be
concatenated at once. Da concat filta will use tha duration of tha longest
stream up in each segment (except tha last one), n' if necessary pad shorter
audio streams wit silence.
.PP
For dis filta ta work erectly, all segments must start at timestamp 0.
.PP
All correspondin streams must have tha same parametas up in all segments; the
filterin system will automatically select a cold-ass lil common pixel format fo' vizzle
streams, n' a cold-ass lil common sample format, sample rate n' channel layout for
audio streams yo, but other settings, like fuckin resolution, must be converted
explicitly by tha user.
.PP
Different frame rates is aaight but will result up in variable frame rate
at output; be shizzle ta configure tha output file ta handle dat shit.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Concatenate a opening, a episode n' a ending, all up in bilingual version
(video up in stream 0, audio up in streams 1 n' 2):
.Sp
.Vb 4
\&        ffmpeg \-i opening.mkv \-i episode.mkv \-i ending.mkv \-filter_complex \e
\&          \*(Aq[0:0] [0:1] [0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2]
\&           concat=n=3:v=1:a=2 [v] [a1] [a2]\*(Aq \e
\&          \-map \*(Aq[v]\*(Aq \-map \*(Aq[a1]\*(Aq \-map \*(Aq[a2]\*(Aq output.mkv
.Ve
.IP "\(bu" 4
Concatenate two parts, handlin audio n' vizzle separately, rockin the
(a)movie sources, n' adjustin tha resolution:
.Sp
.Vb 3
\&        porno=part1.mp4, scale=512:288 [v1] ; amovie=part1.mp4 [a1] ;
\&        porno=part2.mp4, scale=512:288 [v2] ; amovie=part2.mp4 [a2] ;
\&        [v1] [v2] concat [outv] ; [a1] [a2] concat=v=0:a=1 [outa]
.Ve
.Sp
Note dat a thugged-out desync will happen all up in tha stitch if tha audio n' vizzle streams
do not have exactly tha same duration up in tha straight-up original gangsta file.
.SS "ebur128"
.IX Subsection "ebur128"
\&\s-1EBU R128\s0 scanner filter n' shit. This filta takes a audio stream as input n' outputs
it unchanged. Y'all KNOW dat shit, muthafucka! By default, it logs a message at a gangbangin' frequency of 10Hz wit the
Momentary loudnizz (identified by \f(CW\*(C`M\*(C'\fR), Short-term loudnizz (\f(CW\*(C`S\*(C'\fR),
Integrated loudnizz (\f(CW\*(C`I\*(C'\fR) n' Loudnizz Range (\f(CW\*(C`LRA\*(C'\fR).
.PP
Da filta also has a vizzle output (see tha \fIvideo\fR option) wit a real
time graph ta observe tha loudnizz evolution. I aint talkin' bout chicken n' gravy biatch. Da graphic gotz nuff tha logged
message mentioned above, so it aint printed no mo' when dis option is set,
unless tha verbose loggin is set. Da main graphin area gotz nuff the
short-term loudnizz (3 secondz of analysis), n' tha gauge on tha right is for
the momentary loudnizz (400 milliseconds).
.PP
Mo' shiznit bout tha Loudnizz Recommendation \s-1EBU R128\s0 on
<\fBhttp://tech.ebu.ch/loudness\fR>.
.PP
Da filta accepts tha followin options:
.IP "\fBvideo\fR" 4
.IX Item "video"
Activate tha vizzle output. Da audio stream is passed unchanged whether this
option is set or no. Da vizzle stream is ghon be tha straight-up original gangsta output stream if
activated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Default is \f(CW0\fR.
.IP "\fBsize\fR" 4
.IX Item "size"
Set tha vizzle size. This option is fo' vizzle only. For tha syntax of this
option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default
and minimum resolution is \f(CW\*(C`640x480\*(C'\fR.
.IP "\fBmeter\fR" 4
.IX Item "meter"
Set tha \s-1EBU\s0 scale meter n' shit. Default is \f(CW9\fR. Common joints is \f(CW9\fR and
\&\f(CW18\fR, respectively fo' \s-1EBU\s0 scale meta +9 n' \s-1EBU\s0 scale meta +18 fo' realz. Any
other integer value between dis range be allowed.
.IP "\fBmetadata\fR" 4
.IX Item "metadata"
Set metadata injection. I aint talkin' bout chicken n' gravy biatch. If set ta \f(CW1\fR, tha audio input is ghon be segmented
into 100ms output frames, each of dem containin various loudnizz shiznit
in metadata.  All tha metadata keys is prefixed wit \f(CW\*(C`lavfi.r128.\*(C'\fR.
.Sp
Default is \f(CW0\fR.
.IP "\fBframelog\fR" 4
.IX Item "framelog"
Force tha frame loggin level.
.Sp
Available joints are:
.RS 4
.IP "\fBinfo\fR" 4
.IX Item "info"
information loggin level
.IP "\fBverbose\fR" 4
.IX Item "verbose"
verbose loggin level
.RE
.RS 4
.Sp
By default, tha loggin level is set ta \fIinfo\fR. If tha \fBvideo\fR or
the \fBmetadata\fR options is set, it switches ta \fIverbose\fR.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Real-time graph rockin \fBffplay\fR, wit a \s-1EBU\s0 scale meta +18:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-i "amovie=input.mp3,ebur128=video=1:meter=18 [out0][out1]"
.Ve
.IP "\(bu" 4
Run a analysis wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-nostats \-i input.mp3 \-filter_complex ebur128 \-f null \-
.Ve
.SS "interleave, ainterleave"
.IX Subsection "interleave, ainterleave"
Temporally interleave frames from nuff muthafuckin inputs.
.PP
\&\f(CW\*(C`interleave\*(C'\fR works wit vizzle inputs, \f(CW\*(C`ainterleave\*(C'\fR wit audio.
.PP
These filtas read frames from nuff muthafuckin inputs n' bust tha oldest
queued frame ta tha output.
.PP
Input streams must gotz a well defined, monotonically increasin frame
timestamp joints.
.PP
In order ta submit one frame ta output, these filtas need ta enqueue
at least one frame fo' each input, so they cannot work up in case one
input aint yet terminated n' aint gonna receive incomin frames.
.PP
For example consider tha case when one input be a \f(CW\*(C`select\*(C'\fR filter
which always drop input frames. Da \f(CW\*(C`interleave\*(C'\fR filta will keep
readin from dat input yo, but it aint NEVER gonna be able ta bust freshly smoked up frames
to output until tha input will bust a end-of-stream signal.
.PP
Also, dependin on inputs synchronization, tha filtas will drop
frames up in case one input receives mo' frames than tha other ones, and
the queue be already filled.
.PP
These filtas accept tha followin options:
.IP "\fBnb_inputs, n\fR" 4
.IX Item "nb_inputs, n"
Set tha number of different inputs, it is 2 by default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Interleave frames belongin ta different streams rockin \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i bambi.avi \-i pr0n.mkv \-filter_complex "[0:v][1:v] interleave" out.avi
.Ve
.IP "\(bu" 4
Add flickerin blur effect:
.Sp
.Vb 1
\&        select=\*(Aqif(gt(random(0), 0.2), 1, 2)\*(Aq:n=2 [tmp], boxblur=2:2, [tmp] interleave
.Ve
.SS "perms, aperms"
.IX Subsection "perms, aperms"
Set read/write permissions fo' tha output frames.
.PP
These filtas is mainly aimed at pimpers ta test direct path up in the
followin filta up in tha filtergraph.
.PP
Da filtas accept tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Select tha permissions mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Do nothing. This is tha default.
.IP "\fBro\fR" 4
.IX Item "ro"
Set all tha output frames read-only.
.IP "\fBrw\fR" 4
.IX Item "rw"
Set all tha output frames directly writable.
.IP "\fBtoggle\fR" 4
.IX Item "toggle"
Make tha frame read-only if writable, n' writable if read-only.
.IP "\fBrandom\fR" 4
.IX Item "random"
Set each output frame read-only or writable randomly.
.RE
.RS 4
.RE
.IP "\fBseed\fR" 4
.IX Item "seed"
Set tha seed fo' tha \fIrandom\fR mode, must be a integer included between
\&\f(CW0\fR n' \f(CW\*(C`UINT32_MAX\*(C'\fR. If not specified, or if explicitly set to
\&\f(CW\*(C`\-1\*(C'\fR, tha filta will try ta bust a phat random seed on a funky-ass dopest effort
basis.
.PP
Note: up in case of auto-inserted filta between tha permission filta n' the
followin one, tha permission might not be received as expected up in that
followin filter n' shit. Insertin a gangbangin' format or aformat filta before the
perms/aperms filta can avoid dis problem.
.SS "select, aselect"
.IX Subsection "select, aselect"
Select frames ta pass up in output.
.PP
This filta accepts tha followin options:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set expression, which is evaluated fo' each input frame.
.Sp
If tha expression is evaluated ta zero, tha frame is discarded.
.Sp
If tha evaluation result is wack or NaN, tha frame is busted ta the
first output; otherwise it is busted ta tha output wit index
\&\f(CW\*(C`ceil(val)\-1\*(C'\fR, assumin dat tha input index starts from 0.
.Sp
For example a value of \f(CW1.2\fR correspondz ta tha output wit index
\&\f(CW\*(C`ceil(1.2)\-1 = 2\-1 = 1\*(C'\fR, dat is tha second output.
.IP "\fBoutputs, n\fR" 4
.IX Item "outputs, n"
Set tha number of outputs, n' you can put dat on yo' toast. Da output ta which ta bust tha selected
frame is based on tha result of tha evaluation. I aint talkin' bout chicken n' gravy biatch. Default value is 1.
.PP
Da expression can contain tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
the sequential number of tha filtered frame, startin from 0
.IP "\fBselected_n\fR" 4
.IX Item "selected_n"
the sequential number of tha selected frame, startin from 0
.IP "\fBprev_selected_n\fR" 4
.IX Item "prev_selected_n"
the sequential number of tha last selected frame, \s-1NAN\s0 if undefined
.IP "\fB\s-1TB\s0\fR" 4
.IX Item "TB"
timebase of tha input timestamps
.IP "\fBpts\fR" 4
.IX Item "pts"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in \fI\s-1TB\s0\fR units, \s-1NAN\s0 if undefined
.IP "\fBt\fR" 4
.IX Item "t"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in seconds, \s-1NAN\s0 if undefined
.IP "\fBprev_pts\fR" 4
.IX Item "prev_pts"
the \s-1PTS\s0 of tha previously filtered vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBprev_selected_pts\fR" 4
.IX Item "prev_selected_pts"
the \s-1PTS\s0 of tha last previously filtered vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBprev_selected_t\fR" 4
.IX Item "prev_selected_t"
the \s-1PTS\s0 of tha last previously selected vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
the \s-1PTS\s0 of tha straight-up original gangsta vizzle frame up in tha vizzle, \s-1NAN\s0 if undefined
.IP "\fBstart_t\fR" 4
.IX Item "start_t"
the time of tha straight-up original gangsta vizzle frame up in tha vizzle, \s-1NAN\s0 if undefined
.IP "\fBpict_type\fR \fI(video only)\fR" 4
.IX Item "pict_type (video only)"
the type of tha filtered frame, can assume one of tha following
values:
.RS 4
.IP "\fBI\fR" 4
.IX Item "I"
.PD 0
.IP "\fBP\fR" 4
.IX Item "P"
.IP "\fBB\fR" 4
.IX Item "B"
.IP "\fBS\fR" 4
.IX Item "S"
.IP "\fB\s-1SI\s0\fR" 4
.IX Item "SI"
.IP "\fB\s-1SP\s0\fR" 4
.IX Item "SP"
.IP "\fB\s-1BI\s0\fR" 4
.IX Item "BI"
.RE
.RS 4
.RE
.IP "\fBinterlace_type\fR \fI(video only)\fR" 4
.IX Item "interlace_type (video only)"
.PD
the frame interlace type, can assume one of tha followin joints:
.RS 4
.IP "\fB\s-1PROGRESSIVE\s0\fR" 4
.IX Item "PROGRESSIVE"
the frame is progressive (not interlaced)
.IP "\fB\s-1TOPFIRST\s0\fR" 4
.IX Item "TOPFIRST"
the frame is top-field-first
.IP "\fB\s-1BOTTOMFIRST\s0\fR" 4
.IX Item "BOTTOMFIRST"
the frame is bottom-field-first
.RE
.RS 4
.RE
.IP "\fBconsumed_sample_n\fR \fI(audio only)\fR" 4
.IX Item "consumed_sample_n (audio only)"
the number of selected samplez before tha current frame
.IP "\fBsamples_n\fR \fI(audio only)\fR" 4
.IX Item "samples_n (audio only)"
the number of samplez up in tha current frame
.IP "\fBsample_rate\fR \fI(audio only)\fR" 4
.IX Item "sample_rate (audio only)"
the input sample rate
.IP "\fBkey\fR" 4
.IX Item "key"
1 if tha filtered frame be a key-frame, 0 otherwise
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha filtered frame, \-1 if tha shiznit
is not available (e.g. fo' synthetic vizzle)
.IP "\fBscene\fR \fI(video only)\fR" 4
.IX Item "scene (video only)"
value between 0 n' 1 ta indicate a freshly smoked up scene; a low value reflects a low
probabilitizzle fo' tha current frame ta introduce a freshly smoked up scene, while a higher
value means tha current frame is mo' likely ta be one (see tha example below)
.PP
Da default value of tha select expression is \*(L"1\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Select all frames up in input:
.Sp
.Vb 1
\&        select
.Ve
.Sp
Da example above is tha same ol' dirty as:
.Sp
.Vb 1
\&        select=1
.Ve
.IP "\(bu" 4
Skip all frames:
.Sp
.Vb 1
\&        select=0
.Ve
.IP "\(bu" 4
Select only I\-frames:
.Sp
.Vb 1
\&        select=\*(Aqeq(pict_type\e,I)\*(Aq
.Ve
.IP "\(bu" 4
Select one frame every last muthafuckin 100:
.Sp
.Vb 1
\&        select=\*(Aqnot(mod(n\e,100))\*(Aq
.Ve
.IP "\(bu" 4
Select only frames contained up in tha 10\-20 time interval:
.Sp
.Vb 1
\&        select=between(t\e,10\e,20)
.Ve
.IP "\(bu" 4
Select only I frames contained up in tha 10\-20 time interval:
.Sp
.Vb 1
\&        select=between(t\e,10\e,20)*eq(pict_type\e,I)
.Ve
.IP "\(bu" 4
Select frames wit a minimum distizzle of 10 seconds:
.Sp
.Vb 1
\&        select=\*(Aqisnan(prev_selected_t)+gte(t\-prev_selected_t\e,10)\*(Aq
.Ve
.IP "\(bu" 4
Use aselect ta select only audio frames wit samplez number > 100:
.Sp
.Vb 1
\&        aselect=\*(Aqgt(samples_n\e,100)\*(Aq
.Ve
.IP "\(bu" 4
Smoke a mosaic of tha straight-up original gangsta scenes:
.Sp
.Vb 1
\&        ffmpeg \-i vizzle.avi \-vf select=\*(Aqgt(scene\e,0.4)\*(Aq,scale=160:120,tile \-frames:v 1 peepshow.png
.Ve
.Sp
Comparin \fIscene\fR against a value between 0.3 n' 0.5 is generally a sane
choice.
.IP "\(bu" 4
Send even n' odd frames ta separate outputs, n' compose them:
.Sp
.Vb 1
\&        select=n=2:e=\*(Aqmod(n, 2)+1\*(Aq [odd][even]; [odd] pad=h=2*ih [tmp]; [tmp][even] overlay=y=h
.Ve
.SS "sendcmd, asendcmd"
.IX Subsection "sendcmd, asendcmd"
Send commandz ta filtas up in tha filtergraph.
.PP
These filtas read commandz ta be busted ta other filtas up in the
filtergraph.
.PP
\&\f(CW\*(C`sendcmd\*(C'\fR must be banged between two vizzle filters,
\&\f(CW\*(C`asendcmd\*(C'\fR must be banged between two audio filtas yo, but apart
from dat they act tha same way.
.PP
Da justification of commandz can be provided up in tha filta arguments
with tha \fIcommands\fR option, or up in a gangbangin' file specified by the
\&\fIfilename\fR option.
.PP
These filtas accept tha followin options:
.IP "\fBcommands, c\fR" 4
.IX Item "commands, c"
Set tha commandz ta be read n' busted ta tha other filters.
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filename of tha commandz ta be read n' busted ta tha other
filters.
.PP
\fICommandz syntax\fR
.IX Subsection "Commandz syntax"
.PP
A commandz description consistz of a sequence of interval
specifications, comprisin a list of commandz ta be executed when a
particular event related ta dat interval occurs. Da occurrin event
is typically tha current frame time enterin or leavin a given time
interval.
.PP
An interval is specified by tha followin syntax:
.PP
.Vb 1
\&        <START>[\-<END>] <COMMANDS>;
.Ve
.PP
Da time interval is specified by tha \fI\s-1START\s0\fR n' \fI\s-1END\s0\fR times.
\&\fI\s-1END\s0\fR is optionizzle n' defaults ta tha maximum time.
.PP
Da current frame time is considered within tha specified interval if
it is included up in tha interval [\fI\s-1START\s0\fR, \fI\s-1END\s0\fR), dat is when
the time is pimped outa or equal ta \fI\s-1START\s0\fR n' is lesser than
\&\fI\s-1END\s0\fR.
.PP
\&\fI\s-1COMMANDS\s0\fR consistz of a sequence of one or mo' command
specifications, separated by \*(L",\*(R", relatin ta dat interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  The
syntax of a cold-ass lil command justification is given by:
.PP
.Vb 1
\&        [<FLAGS>] <TARGET> <COMMAND> <ARG>
.Ve
.PP
\&\fI\s-1FLAGS\s0\fR is optionizzle n' specifies tha type of events relatin to
the time interval which enable bustin  tha specified command, n' must
be a non-null sequence of identifier flags separated by \*(L"+\*(R" or \*(L"|\*(R" and
enclosed between \*(L"[\*(R" n' \*(L"]\*(R".
.PP
Da followin flags is recognized:
.IP "\fBenter\fR" 4
.IX Item "enter"
Da command is busted when tha current frame timestamp entas the
specified interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In other lyrics, tha command is busted when the
previous frame timestamp was not up in tha given interval, n' the
current is.
.IP "\fBleave\fR" 4
.IX Item "leave"
Da command is busted when tha current frame timestamp leaves the
specified interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In other lyrics, tha command is busted when the
previous frame timestamp was up in tha given interval, n' the
current is not.
.PP
If \fI\s-1FLAGS\s0\fR aint specified, a thugged-out default value of \f(CW\*(C`[enter]\*(C'\fR is
assumed.
.PP
\&\fI\s-1TARGET\s0\fR specifies tha target of tha command, probably tha name of
the filta class or a specific filta instizzle name.
.PP
\&\fI\s-1COMMAND\s0\fR specifies tha name of tha command fo' tha target filter.
.PP
\&\fI\s-1ARG\s0\fR is optionizzle n' specifies tha optionizzle list of argument for
the given \fI\s-1COMMAND\s0\fR.
.PP
Between one interval justification n' another, whitespaces, or
sequencez of charactas startin wit \f(CW\*(C`#\*(C'\fR until tha end of line,
are ignored n' can be used ta annotate comments.
.PP
A simplified \s-1BNF\s0 description of tha commandz justification syntax
bigs up:
.PP
.Vb 6
\&        <COMMAND_FLAG>  ::= "enter" | "leave"
\&        <COMMAND_FLAGS> ::= <COMMAND_FLAG> [(+|"|")<COMMAND_FLAG>]
\&        <COMMAND>       ::= ["[" <COMMAND_FLAGS> "]"] <TARGET> <COMMAND> [<ARG>]
\&        <COMMANDS>      ::= <COMMAND> [,<COMMANDS>]
\&        <INTERVAL>      ::= <START>[\-<END>] <COMMANDS>
\&        <INTERVALS>     ::= <INTERVAL>[;<INTERVALS>]
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Specify audio tempo chizzle at second 4:
.Sp
.Vb 1
\&        asendcmd=c=\*(Aq4.0 atempo tempo 1.5\*(Aq,atempo
.Ve
.IP "\(bu" 4
Specify a list of drawtext n' hue commandz up in a gangbangin' file.
.Sp
.Vb 3
\&        # show text up in tha interval 5\-10
\&        5.0\-10.0 [enter] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=wassup ghetto\*(Aq,
\&                 [leave] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=\*(Aq;
\&        
\&        # desaturate tha image up in tha interval 15\-20
\&        15.0\-20.0 [enter] hue s 0,
\&                  [enter] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=nocolor\*(Aq,
\&                  [leave] hue s 1,
\&                  [leave] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=color\*(Aq;
\&        
\&        # apply a exponential saturation fade\-out effect, startin from time 25
\&        25 [enter] hue s exp(25\-t)
.Ve
.Sp
A filtergraph allowin ta read n' process tha above command list
stored up in a gangbangin' file \fItest.cmd\fR, can be specified with:
.Sp
.Vb 1
\&        sendcmd=f=test.cmd,drawtext=fontfile=FreeSerif.ttf:text=\*(Aq\*(Aq,hue
.Ve
.SS "setpts, asetpts"
.IX Subsection "setpts, asetpts"
Change tha \s-1PTS \s0(presentation timestamp) of tha input frames.
.PP
\&\f(CW\*(C`setpts\*(C'\fR works on vizzle frames, \f(CW\*(C`asetpts\*(C'\fR on audio frames.
.PP
This filta accepts tha followin options:
.IP "\fBexpr\fR" 4
.IX Item "expr"
Da expression which is evaluated fo' each frame ta construct its timestamp.
.PP
Da expression is evaluated all up in tha eval \s-1API\s0 n' can contain tha following
constants:
.IP "\fB\s-1FRAME_RATE\s0\fR" 4
.IX Item "FRAME_RATE"
frame rate, only defined fo' constant frame-rate vizzle
.IP "\fB\s-1PTS\s0\fR" 4
.IX Item "PTS"
the presentation timestamp up in input
.IP "\fBN\fR" 4
.IX Item "N"
the count of tha input frame fo' vizzle or tha number of consumed samples,
not includin tha current frame fo' audio, startin from 0.
.IP "\fB\s-1NB_CONSUMED_SAMPLES\s0\fR" 4
.IX Item "NB_CONSUMED_SAMPLES"
the number of consumed samples, not includin tha current frame (only
audio)
.IP "\fB\s-1NB_SAMPLES, S\s0\fR" 4
.IX Item "NB_SAMPLES, S"
the number of samplez up in tha current frame (only audio)
.IP "\fB\s-1SAMPLE_RATE, SR\s0\fR" 4
.IX Item "SAMPLE_RATE, SR"
audio sample rate
.IP "\fB\s-1STARTPTS\s0\fR" 4
.IX Item "STARTPTS"
the \s-1PTS\s0 of tha straight-up original gangsta frame
.IP "\fB\s-1STARTT\s0\fR" 4
.IX Item "STARTT"
the time up in secondz of tha straight-up original gangsta frame
.IP "\fB\s-1INTERLACED\s0\fR" 4
.IX Item "INTERLACED"
tell if tha current frame is interlaced
.IP "\fBT\fR" 4
.IX Item "T"
the time up in secondz of tha current frame
.IP "\fB\s-1POS\s0\fR" 4
.IX Item "POS"
original gangsta posizzle up in tha file of tha frame, or undefined if undefined
for tha current frame
.IP "\fB\s-1PREV_INPTS\s0\fR" 4
.IX Item "PREV_INPTS"
previous input \s-1PTS\s0
.IP "\fB\s-1PREV_INT\s0\fR" 4
.IX Item "PREV_INT"
previous input time up in seconds
.IP "\fB\s-1PREV_OUTPTS\s0\fR" 4
.IX Item "PREV_OUTPTS"
previous output \s-1PTS\s0
.IP "\fB\s-1PREV_OUTT\s0\fR" 4
.IX Item "PREV_OUTT"
previous output time up in seconds
.IP "\fB\s-1RTCTIME\s0\fR" 4
.IX Item "RTCTIME"
wallclock (\s-1RTC\s0) time up in microseconds. This is deprecated, use \fItime\fR\|(0)
instead.
.IP "\fB\s-1RTCSTART\s0\fR" 4
.IX Item "RTCSTART"
wallclock (\s-1RTC\s0) time all up in tha start of tha porno up in microseconds
.IP "\fB\s-1TB\s0\fR" 4
.IX Item "TB"
timebase of tha input timestamps
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Start countin \s-1PTS\s0 from zero
.Sp
.Vb 1
\&        setpts=PTS\-STARTPTS
.Ve
.IP "\(bu" 4
Apply fast motion effect:
.Sp
.Vb 1
\&        setpts=0.5*PTS
.Ve
.IP "\(bu" 4
Apply slow motion effect:
.Sp
.Vb 1
\&        setpts=2.0*PTS
.Ve
.IP "\(bu" 4
Set fixed rate of 25 frames per second:
.Sp
.Vb 1
\&        setpts=N/(25*TB)
.Ve
.IP "\(bu" 4
Set fixed rate 25 fps wit some jitter:
.Sp
.Vb 1
\&        setpts=\*(Aq1/(25*TB) * (N + 0.05 * sin(N*2*PI/25))\*(Aq
.Ve
.IP "\(bu" 4
Apply a offset of 10 secondz ta tha input \s-1PTS:\s0
.Sp
.Vb 1
\&        setpts=PTS+10/TB
.Ve
.IP "\(bu" 4
Generate timestamps from a \*(L"live source\*(R" n' rebase onto tha current timebase:
.Sp
.Vb 1
\&        setpts=\*(Aq(RTCTIME \- RTCSTART) / (TB * 1000000)\*(Aq
.Ve
.IP "\(bu" 4
Generate timestamps by countin samples:
.Sp
.Vb 1
\&        asetpts=N/SR/TB
.Ve
.SS "settb, asettb"
.IX Subsection "settb, asettb"
Set tha timebase ta use fo' tha output frames timestamps.
It be mainly useful fo' testin timebase configuration.
.PP
This filta accepts tha followin options:
.IP "\fBexpr, tb\fR" 4
.IX Item "expr, tb"
Da expression which is evaluated tha fuck into tha output timebase.
.PP
Da value fo' \fBtb\fR be a arithmetic expression representin a
rational. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da expression can contain tha constants \*(L"\s-1AVTB\*(R" \s0(the default
timebase), \*(L"intb\*(R" (the input timebase) n' \*(L"sr\*(R" (the sample rate,
audio only). Default value is \*(L"intb\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha timebase ta 1/25:
.Sp
.Vb 1
\&        settb=expr=1/25
.Ve
.IP "\(bu" 4
Set tha timebase ta 1/10:
.Sp
.Vb 1
\&        settb=expr=0.1
.Ve
.IP "\(bu" 4
Set tha timebase ta 1001/1000:
.Sp
.Vb 1
\&        settb=1+0.001
.Ve
.IP "\(bu" 4
Set tha timebase ta 2*intb:
.Sp
.Vb 1
\&        settb=2*intb
.Ve
.IP "\(bu" 4
Set tha default timebase value:
.Sp
.Vb 1
\&        settb=AVTB
.Ve
.SS "showspectrum"
.IX Subsection "showspectrum"
Convert input audio ta a vizzle output, representin tha audio frequency
spectrum.
.PP
Da filta accepts tha followin options:
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha vizzle size fo' tha output. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is
\&\f(CW\*(C`640x512\*(C'\fR.
.IP "\fBslide\fR" 4
.IX Item "slide"
Specify if tha spectrum should slide along tha window. Default value is
\&\f(CW0\fR.
.IP "\fBmode\fR" 4
.IX Item "mode"
Specify display mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBcombined\fR" 4
.IX Item "combined"
all channels is displayed up in tha same row
.IP "\fBseparate\fR" 4
.IX Item "separate"
all channels is displayed up in separate rows
.RE
.RS 4
.Sp
Default value is \fBcombined\fR.
.RE
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify display color mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBchannel\fR" 4
.IX Item "channel"
each channel is displayed up in a separate color
.IP "\fBintensity\fR" 4
.IX Item "intensity"
each channel is is displayed rockin tha same color scheme
.RE
.RS 4
.Sp
Default value is \fBchannel\fR.
.RE
.IP "\fBscale\fR" 4
.IX Item "scale"
Specify scale used fo' calculatin intensitizzle color joints.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlin\fR" 4
.IX Item "lin"
linear
.IP "\fBsqrt\fR" 4
.IX Item "sqrt"
square root, default
.IP "\fBcbrt\fR" 4
.IX Item "cbrt"
cubic root
.IP "\fBlog\fR" 4
.IX Item "log"
logarithmic
.RE
.RS 4
.Sp
Default value is \fBsqrt\fR.
.RE
.IP "\fBsaturation\fR" 4
.IX Item "saturation"
Set saturation modifier fo' displayed colors. Negatizzle joints provide
alternatizzle color scheme. \f(CW0\fR is no saturation at all.
Saturation must be up in [\-10.0, 10.0] range.
Default value is \f(CW1\fR.
.PP
Da usage is straight-up similar ta tha showwaves filter; peep tha examplez up in that
section.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Big-Ass window wit logarithmic color scaling:
.Sp
.Vb 1
\&        showspectrum=s=1280x480:scale=log
.Ve
.IP "\(bu" 4
Complete example fo' a cold-ass lil colored n' slidin spectrum per channel rockin \fBffplay\fR:
.Sp
.Vb 2
\&        ffplay \-f lavfi \*(Aqamovie=input.mp3, asplit [a][out1];
\&                     [a] showspectrum=mode=separate:color=intensity:slide=1:scale=cbrt [out0]\*(Aq
.Ve
.SS "showwaves"
.IX Subsection "showwaves"
Convert input audio ta a vizzle output, representin tha samplez waves.
.PP
Da filta accepts tha followin options:
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha vizzle size fo' tha output. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value
is \*(L"600x240\*(R".
.IP "\fBmode\fR" 4
.IX Item "mode"
Set display mode.
.Sp
Available joints are:
.RS 4
.IP "\fBpoint\fR" 4
.IX Item "point"
Draw a point fo' each sample.
.IP "\fBline\fR" 4
.IX Item "line"
Draw a vertical line fo' each sample.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`point\*(C'\fR.
.RE
.IP "\fBn\fR" 4
.IX Item "n"
Set tha number of samplez which is printed on tha same column. I aint talkin' bout chicken n' gravy biatch fo' realz. A
larger value will decrease tha frame rate. Must be a positive
integer n' shit. This option can be set only if tha value fo' \fIrate\fR
is not explicitly specified.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha (approximate) output frame rate. This is done by settin the
option \fIn\fR. Default value is \*(L"25\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Output tha input file audio n' tha correspondin vizzle representation
at tha same time:
.Sp
.Vb 1
\&        amovie=a.mp3,asplit[out0],showwaves[out1]
.Ve
.IP "\(bu" 4
Smoke a synthetic signal n' show it wit showwaves, forcin a
frame rate of 30 frames per second:
.Sp
.Vb 1
\&        aevalsrc=sin(1*2*PI*t)*sin(880*2*PI*t):cos(2*PI*200*t),asplit[out0],showwaves=r=30[out1]
.Ve
.SS "split, asplit"
.IX Subsection "split, asplit"
Split input tha fuck into nuff muthafuckin identical outputs.
.PP
\&\f(CW\*(C`asplit\*(C'\fR works wit audio input, \f(CW\*(C`split\*(C'\fR wit vizzle.
.PP
Da filta accepts a single parameta which specifies tha number of outputs, n' you can put dat on yo' toast. If
unspecified, it defaults ta 2.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Smoke two separate outputs from tha same input:
.Sp
.Vb 1
\&        [in] split [out0][out1]
.Ve
.IP "\(bu" 4
To create 3 or mo' outputs, you need ta specify tha number of
outputs, like in:
.Sp
.Vb 1
\&        [in] asplit=3 [out0][out1][out2]
.Ve
.IP "\(bu" 4
Smoke two separate outputs from tha same input, one cropped and
one padded:
.Sp
.Vb 3
\&        [in] split [splitout1][splitout2];
\&        [splitout1] crop=100:100:0:0    [cropout];
\&        [splitout2] pad=200:200:100:100 [padout];
.Ve
.IP "\(bu" 4
Smoke 5 copiez of tha input audio wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-filter_complex asplit=5 OUTPUT
.Ve
.SS "zmq, azmq"
.IX Subsection "zmq, azmq"
Receive commandz busted all up in a libzmq client, n' forward dem to
filtas up in tha filtergraph.
.PP
\&\f(CW\*(C`zmq\*(C'\fR n' \f(CW\*(C`azmq\*(C'\fR work as a pass-all up in filters. \f(CW\*(C`zmq\*(C'\fR
must be banged between two vizzle filters, \f(CW\*(C`azmq\*(C'\fR between two
audio filters.
.PP
To enable these filtas you need ta install tha libzmq library and
headaz n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-libzmq\*(C'\fR.
.PP
For mo' shiznit bout libzmq see:
<\fBhttp://www.zeromq.org/\fR>
.PP
Da \f(CW\*(C`zmq\*(C'\fR n' \f(CW\*(C`azmq\*(C'\fR filtas work as a libzmq server, which
receives lyrics busted all up in a network intercourse defined by the
\&\fBbind_address\fR option.
.PP
Da received message must be up in tha form:
.PP
.Vb 1
\&        <TARGET> <COMMAND> [<ARG>]
.Ve
.PP
\&\fI\s-1TARGET\s0\fR specifies tha target of tha command, probably tha name of
the filta class or a specific filta instizzle name.
.PP
\&\fI\s-1COMMAND\s0\fR specifies tha name of tha command fo' tha target filter.
.PP
\&\fI\s-1ARG\s0\fR is optionizzle n' specifies tha optionizzle argument list fo' the
given \fI\s-1COMMAND\s0\fR.
.PP
Upon reception, tha message is processed n' tha correspondin command
is injected tha fuck into tha filtergraph. Dependin on tha result, tha filter
will bust a reply ta tha client, adoptin tha format:
.PP
.Vb 2
\&        <ERROR_CODE> <ERROR_REASON>
\&        <MESSAGE>
.Ve
.PP
\&\fI\s-1MESSAGE\s0\fR is optional.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Look at \fItools/zmqsend\fR fo' a example of a zmq client which can
be used ta bust commandz processed by these filters.
.PP
Consider tha followin filtergraph generated by \fBffplay\fR
.PP
.Vb 6
\&        ffplay \-dumpgraph 1 \-f lavfi "
\&        color=s=100x100:c=red  [l];
\&        color=s=100x100:c=blue [r];
\&        nullsrc=s=200x100, zmq [bg];
\&        [bg][l]   overlay      [bg+l];
\&        [bg+l][r] overlay=x=100 "
.Ve
.PP
To chizzle tha color of tha left side of tha vizzle, tha following
command can be used:
.PP
.Vb 1
\&        echo Parsed_color_0 c yellow | tools/zmqsend
.Ve
.PP
To chizzle tha right side:
.PP
.Vb 1
\&        echo Parsed_color_1 c pink | tools/zmqsend
.Ve
.SH "MULTIMEDIA SOURCES"
.IX Header "MULTIMEDIA SOURCES"
Below be a thugged-out description of tha currently available multimedia sources.
.SS "amovie"
.IX Subsection "amovie"
This is tha same ol' dirty as porno source, except it selects a audio
stream by default.
.SS "movie"
.IX Subsection "movie"
Read audio and/or vizzle stream(s) from a porno container.
.PP
This filta accepts tha followin options:
.IP "\fBfilename\fR" 4
.IX Item "filename"
Da name of tha resource ta read (not necessarily a gangbangin' file but also a thang or a
stream accessed all up in some protocol).
.IP "\fBformat_name, f\fR" 4
.IX Item "format_name, f"
Specifies tha format assumed fo' tha porno ta read, n' can be either
the name of a cold-ass lil container or a input device. If not specified the
format is guessed from \fImovie_name\fR or by probing.
.IP "\fBseek_point, sp\fR" 4
.IX Item "seek_point, sp"
Specifies tha seek point up in seconds, tha frames is ghon be output
startin from dis seek point, tha parameta is evaluated with
\&\f(CW\*(C`av_strtod\*(C'\fR so tha numerical value may be suffixed by a \s-1IS\s0
postfix. Default value is \*(L"0\*(R".
.IP "\fBstreams, s\fR" 4
.IX Item "streams, s"
Specifies tha streams ta read. Y'all KNOW dat shit, muthafucka! Several streams can be specified,
separated by \*(L"+\*(R". Da source will then have as nuff outputs, up in the
same order n' shit. Da syntax is explained up in tha ``Stream specifiers''
section up in tha ffmpeg manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Two special names, \*(L"dv\*(R" n' \*(L"da\*(R" specify
respectively tha default (best suited) vizzle n' audio stream. Default
is \*(L"dv\*(R", or \*(L"da\*(R" if tha filta is called as \*(L"amovie\*(R".
.IP "\fBstream_index, si\fR" 4
.IX Item "stream_index, si"
Specifies tha index of tha vizzle stream ta read. Y'all KNOW dat shit, muthafucka! If tha value is \-1,
the dopest suited vizzle stream is ghon be automatically selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Default
value is \*(L"\-1\*(R". Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha filta is called \*(L"amovie\*(R", it will select
audio instead of vizzle.
.IP "\fBloop\fR" 4
.IX Item "loop"
Specifies how tha fuck nuff times ta read tha stream up in sequence.
If tha value is less than 1, tha stream is ghon be read again n' again n' again n' again.
Default value is \*(L"1\*(R".
.Sp
Note dat when tha porno is looped tha source timestamps is not
changed, so it will generate non monotonically increasin timestamps.
.PP
This filta allows ta overlay a second vizzle on top of main input of
a filtergraph as shown up in dis graph:
.PP
.Vb 4
\&        input \-\-\-\-\-\-\-\-\-\-\-> deltapts0 \-\-> overlay \-\-> output
\&                                            ^
\&                                            |
\&        porno \-\-> scale\-\-> deltapts1 \-\-\-\-\-\-\-+
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Skip 3.2 secondz from tha start of tha avi file in.avi, n' overlay it
on top of tha input labelled as \*(L"in\*(R":
.Sp
.Vb 3
\&        porno=in.avi:seek_point=3.2, scale=180:\-1, setpts=PTS\-STARTPTS [over];
\&        [in] setpts=PTS\-STARTPTS [main];
\&        [main][over] overlay=16:16 [out]
.Ve
.IP "\(bu" 4
Read from a vizzle4linux2 device, n' overlay it on top of tha input
labelled as \*(L"in\*(R":
.Sp
.Vb 3
\&        porno=/dev/video0:f=video4linux2, scale=180:\-1, setpts=PTS\-STARTPTS [over];
\&        [in] setpts=PTS\-STARTPTS [main];
\&        [main][over] overlay=16:16 [out]
.Ve
.IP "\(bu" 4
Read tha straight-up original gangsta vizzle stream n' tha audio stream wit id 0x81 from
dvd.vob; tha vizzle is connected ta tha pad named \*(L"video\*(R" n' tha audio is
connected ta tha pad named \*(L"audio\*(R":
.Sp
.Vb 1
\&        porno=dvd.vob:s=v:0+#0x81 [video] [audio]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffplay\fR\|(1),
\&\fIffmpeg\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1),
\&\fIffmpeg\-utils\fR\|(1), \fIffmpeg\-scaler\fR\|(1), \fIffmpeg\-resampler\fR\|(1),
\&\fIffmpeg\-codecs\fR\|(1), \fIffmpeg\-bitstream\-filters\fR\|(1), \fIffmpeg\-formats\fR\|(1),
\&\fIffmpeg\-devices\fR\|(1), \fIffmpeg\-protocols\fR\|(1), \fIffmpeg\-filters\fR\|(1)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
