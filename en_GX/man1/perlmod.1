.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLMOD 1"
.TH PERLMOD 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlmod \- Perl modulez (packages n' symbol tables)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Packages"
.IX Xref "package namespace variable, global global variable global"
.IX Subsection "Packages"
Perl serves up a mechanizzle fo' alternatizzle namespaces ta protect
packages from stompin on each otherz variables.  In fact, there's
really no such thang as a global variable up in Perl.  Da package
statement declares tha compilation unit as bein up in tha given
namespace.  Da scope of tha package declaration is from the
declaration itself all up in tha end of tha enclosin block, \f(CW\*(C`eval\*(C'\fR,
or file, whichever comes first (the same scope as tha \fImy()\fR and
\&\fIlocal()\fR operators).  Unqualified dynamic identifiers is ghon be in
this namespace, except fo' dem few identifiers dat if unqualified,
default ta tha main package instead of tha current one as busted lyrics about
below.  A package statement affects only dynamic variables\*(--including
those you've used \fIlocal()\fR on\*(--but \fInot\fR lexical variablez pimped
with \fImy()\fR.  Typically it would be tha straight-up original gangsta declaration up in a gangbangin' file
included by tha \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR operators.  Yo ass can
switch tha fuck into a package up in mo' than one place; it merely influences
which symbol table is used by tha compila fo' tha rest of that
block.  Yo ass can refer ta variablez n' filehandlez up in other packages
by prefixin tha identifier wit tha package name n' a thugged-out double
colon: \f(CW$Package::Variable\fR.  If tha package name is null, the
\&\f(CW\*(C`main\*(C'\fR package be assumed. Y'all KNOW dat shit, muthafucka!  That is, \f(CW$::sail\fR is equivalent to
\&\f(CW$main::sail\fR.
.PP
Da oldschool package delimita was a single quote yo, but double colon is now the
preferred delimiter, up in part cuz itz mo' readable ta humans, and
in part cuz itz mo' readable ta \fBemacs\fR macros.  It also make \*(C+
programmers feel like they know what tha fuck be happenin\*(--as opposed ta rockin the
single quote as separator, which was there ta make Ada programmers feel
like they knew what tha fuck was goin on. I aint talkin' bout chicken n' gravy biatch.  Because tha old-fashioned syntax is still
supported fo' backwardz compatibility, if you try ta bust a strang like
\&\f(CW"This is $baller\*(Aqs house"\fR, you gonna be accessin \f(CW$baller::s\fR; dat is,
the \f(CW$s\fR variable up in package \f(CW\*(C`baller\*(C'\fR, which is probably not what tha fuck you meant.
Use braces ta disambiguate, as up in \f(CW"This is ${baller}\*(Aqs house"\fR.
.IX Xref ":: '"
.PP
Packages may theyselves contain package separators, as in
\&\f(CW$OUTER::INNER::var\fR.  This implies not a god damn thang bout tha order of
name lookups, however n' shit.  There is no relatizzle packages: all symbols
are either local ta tha current package, or must be straight-up qualified
from tha outa package name down. I aint talkin' bout chicken n' gravy biatch.  For instance, there is nowhere
within package \f(CW\*(C`OUTER\*(C'\fR dat \f(CW$INNER::var\fR refers to
\&\f(CW$OUTER::INNER::var\fR.  \f(CW\*(C`INNER\*(C'\fR refers ta a straight-up
separate global package.
.PP
Only identifiers startin wit lettas (or underscore) is stored
in a packagez symbol table.  All other symbols is kept up in package
\&\f(CW\*(C`main\*(C'\fR, includin all punctuation variables, like \f(CW$_\fR.  In addition,
when unqualified, tha identifiers \s-1STDIN, STDOUT, STDERR, ARGV,
ARGVOUT, ENV, INC,\s0 n' \s-1SIG\s0 is forced ta be up in package \f(CW\*(C`main\*(C'\fR,
even when used fo' other purposes than they built-in ones.  If you
have a package called \f(CW\*(C`m\*(C'\fR, \f(CW\*(C`s\*(C'\fR, or \f(CW\*(C`y\*(C'\fR, then you can't use the
qualified form of a identifier cuz it would be instead interpreted
as a pattern match, a substitution, or a transliteration.
.IX Xref "variable, punctuation"
.PP
Variablez beginnin wit underscore used ta be forced tha fuck into package
main yo, but our phat asses decided dat shiznit was mo' useful fo' package writas ta be able
to use leadin underscore ta indicate private variablez n' method names.
But fuck dat shiznit yo, tha word on tha street is dat variablez n' functions named wit a single \f(CW\*(C`_\*(C'\fR, such as
\&\f(CW$_\fR n' \f(CW\*(C`sub _\*(C'\fR, is still forced tha fuck into tha package \f(CW\*(C`main\*(C'\fR.  See also
\&\*(L"Da Syntax of Variable Names\*(R" up in perlvar.
.PP
\&\f(CW\*(C`eval\*(C'\fRed strings is compiled up in tha package up in which tha \fIeval()\fR was
compiled. Y'all KNOW dat shit, muthafucka!  (Assignments ta \f(CW$SIG{}\fR, however, assume tha signal
handlez specified is up in tha \f(CW\*(C`main\*(C'\fR package.  Qualify tha signal handlez
name if you wish ta git a signal handlez up in a package.)  For an
example, examine \fIperldb.pl\fR up in tha Perl library.  It initially switches
to tha \f(CW\*(C`DB\*(C'\fR package so dat tha debugger don't interfere wit variables
in tha program yo ass is tryin ta debug.  At various points, however, it
temporarily switches back ta tha \f(CW\*(C`main\*(C'\fR package ta evaluate various
expressions up in tha context of tha \f(CW\*(C`main\*(C'\fR package (or wherever you came
from).  See perldebug.
.PP
Da special symbol \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR gotz nuff tha current package yo, but cannot
(easily) be used ta construct variable names.
.PP
See perlsub fo' other scopin thangs related ta \fImy()\fR n' \fIlocal()\fR,
and perlref regardin closures.
.SS "Symbol Tables"
.IX Xref "symbol table stash %:: %main:: typeglob glob alias"
.IX Subsection "Symbol Tables"
Da symbol table fo' a package happens ta be stored up in tha hash of that
name wit two colons appended. Y'all KNOW dat shit, muthafucka!  Da main symbol tablez name is thus
\&\f(CW%main::\fR, or \f(CW%::\fR fo' short.  Likewise tha symbol table fo' tha nested
package mentioned earlier is named \f(CW%OUTER::INNER::\fR.
.PP
Da value up in each entry of tha hash is what tha fuck yo ass is referrin ta when you
use tha \f(CW*name\fR typeglob notation.
.PP
.Vb 1
\&    local *main::foo    = *main::bar;
.Ve
.PP
Yo ass can use dis ta print up all tha variablez up in a package, for
instance.  Da standard but antiquated \fIdumpvar.pl\fR library and
the \s-1CPAN\s0 module Devel::Symdump make use of all dis bullshit.
.PP
Da thangs up in dis biatch of bustin freshly smoked up symbol table entries directly or modifyin any
entries dat is not already typeglobs is undefined n' subject ta chizzle
between releasez of perl.
.PP
Assignment ta a typeglob performs a aliasin operation, i.e.,
.PP
.Vb 1
\&    *dick = *richard;
.Ve
.PP
causes variables, subroutines, formats, n' file n' directory handles
accessible via tha identifier \f(CW\*(C`richard\*(C'\fR also ta be accessible via the
identifier \f(CW\*(C`dick\*(C'\fR.  If you wanna alias only a particular variable or
subroutine, assign a reference instead:
.PP
.Vb 1
\&    *dick = \e$richard;
.Ve
.PP
Which make \f(CW$richard\fR n' \f(CW$dick\fR tha same variable yo, but leaves
\&\f(CW@richard\fR n' \f(CW@dick\fR as separate arrays.  Tricky, eh?
.PP
There is one subtle difference between tha followin statements:
.PP
.Vb 2
\&    *foo = *bar;
\&    *foo = \e$bar;
.Ve
.PP
\&\f(CW\*(C`*foo = *bar\*(C'\fR make tha typeglobs theyselves synonymous while
\&\f(CW\*(C`*foo = \e$bar\*(C'\fR make tha \s-1SCALAR\s0 portionz of two distinct typeglobs
refer ta tha same scalar value. This means dat tha followin code:
.PP
.Vb 2
\&    $bar = 1;
\&    *foo = \e$bar;       # Make $foo a alias fo' $bar
\&
\&    {
\&        local $bar = 2; # Restrict chizzlez ta block
\&        print $foo;     # Prints \*(Aq1\*(Aq!
\&    }
.Ve
.PP
Would print '1', cuz \f(CW$foo\fR holdz a reference ta tha \fIoriginal\fR
\&\f(CW$bar\fR. Da one dat was stuffed away by \f(CW\*(C`local()\*(C'\fR n' which will be
restored when tha block ends. Because variablez is accessed all up in the
typeglob, you can use \f(CW\*(C`*foo = *bar\*(C'\fR ta create a alias which can be
localized. Y'all KNOW dat shit, muthafucka! (But be aware dat dis means you can't gotz a separate
\&\f(CW@foo\fR n' \f(CW@bar\fR, etc.)
.PP
What make all of dis blingin is dat tha Exporta module uses glob
aliasin as tha import/export mechanism. Whether or not you can properly
localize a variable dat has been exported from a module dependz on how
it was exported:
.PP
.Vb 2
\&    @EXPORT = qw($FOO); # Usual form, can\*(Aqt be localized
\&    @EXPORT = qw(*FOO); # Can be localized
.Ve
.PP
Yo ass can work round tha straight-up original gangsta case by rockin tha straight-up qualified name
(\f(CW$Package::FOO\fR) where you need a local value, or by overridin it
by sayin \f(CW\*(C`*FOO = *Package::FOO\*(C'\fR up in yo' script.
.PP
Da \f(CW\*(C`*x = \e$y\*(C'\fR mechanizzle may be used ta pass n' return skanky references
into or from subroutines if you don't wanna copy tha whole
thing.  It only works when assignin ta dynamic variables, not
lexicals.
.PP
.Vb 9
\&    %some_hash = ();                    # can\*(Aqt be my()
\&    *some_hash = fn( \e%another_hash );
\&    sub fn {
\&        local *hashsym = shift;
\&        # now use %hashsym normally, n' you
\&        # will affect tha caller\*(Aqs %another_hash
\&        mah %nhash = (); # do what tha fuck you want
\&        return \e%nhash;
\&    }
.Ve
.PP
On return, tha reference will overwrite tha hash slot up in the
symbol table specified by tha *some_hash typeglob.  This
is a somewhat tricky way of passin round references skankyly
when you don't wanna gotta remember ta dereference variables
explicitly.
.PP
Another use of symbol tablez is fo' makin \*(L"constant\*(R" scalars.
.IX Xref "constant scalar, constant"
.PP
.Vb 1
\&    *PI = \e3.14159265358979;
.Ve
.PP
Now you cannot alta \f(CW$PI\fR, which is probably a phat thang all up in all.
This aint tha same as a cold-ass lil constant subroutine, which is subject to
optimization at compile-time.  A constant subroutine is one prototyped
to take no arguments n' ta return a cold-ass lil constant expression. I aint talkin' bout chicken n' gravy biatch.  See
perlsub fo' details on these n' you can put dat on yo' toast.  Da \f(CW\*(C`use constant\*(C'\fR pragma be a
convenient shorthand fo' these.
.PP
Yo ass can say \f(CW*foo{PACKAGE}\fR n' \f(CW*foo{NAME}\fR ta smoke up what tha fuck name and
package tha *foo symbol table entry be reppin.  This may be useful
in a subroutine dat gets passed typeglobs as arguments:
.PP
.Vb 6
\&    sub identify_typeglob {
\&        mah $glob = shift;
\&        print \*(AqYo ass gave me \*(Aq, *{$glob}{PACKAGE}, \*(Aq::\*(Aq, *{$glob}{NAME}, "\en";
\&    }
\&    identify_typeglob *foo;
\&    identify_typeglob *bar::baz;
.Ve
.PP
This prints
.PP
.Vb 2
\&    Yo ass gave me main::foo
\&    Yo ass gave me bar::baz
.Ve
.PP
Da \f(CW*foo{THING}\fR notation can also be used ta obtain references ta the
individual elementz of *foo.  See perlref.
.PP
Subroutine definitions (and declarations, fo' dat matter) need
not necessarily be situated up in tha package whose symbol table they
occupy.  Yo ass can define a subroutine outside its package by
explicitly qualifyin tha name of tha subroutine:
.PP
.Vb 2
\&    package main;
\&    sub Some_package::foo { ... }   # &foo defined up in Some_package
.Ve
.PP
This is just a gangbangin' finger-lickin' dirty-ass shorthand fo' a typeglob assignment at compile time:
.PP
.Vb 1
\&    BEGIN { *Some_package::foo = sub { ... } }
.Ve
.PP
and is \fInot\fR tha same as writing:
.PP
.Vb 4
\&    {
\&        package Some_package;
\&        sub foo { ... }
\&    }
.Ve
.PP
In tha straight-up original gangsta two versions, tha body of tha subroutine is
lexically up in tha main package, \fInot\fR up in Some_package. Right back up in yo muthafuckin ass. So
suttin' like this:
.PP
.Vb 1
\&    package main;
\&
\&    $Some_package::name = "fred";
\&    $main::name = "barney";
\&
\&    sub Some_package::foo {
\&        print "in ", _\|_PACKAGE_\|_, ": \e$name is \*(Aq$name\*(Aq\en";
\&    }
\&
\&    Some_package::foo();
.Ve
.PP
prints:
.PP
.Vb 1
\&    up in main: $name is \*(Aqbarney\*(Aq
.Ve
.PP
rather than:
.PP
.Vb 1
\&    up in Some_package: $name is \*(Aqfred\*(Aq
.Ve
.PP
This also has implications fo' tha use of tha \s-1SUPER::\s0 qualifier
(see perlobj).
.SS "\s-1BEGIN, UNITCHECK, CHECK, INIT\s0 n' \s-1END \s0"
.IX Xref "BEGIN UNITCHECK CHECK INIT END"
.IX Subsection "BEGIN, UNITCHECK, CHECK, INIT n' END "
Five specially named code blocks is executed all up in tha beginnin n' at
the end of a hustlin Perl program.  These is tha \f(CW\*(C`BEGIN\*(C'\fR,
\&\f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, n' \f(CW\*(C`END\*(C'\fR blocks.
.PP
These code blocks can be prefixed wit \f(CW\*(C`sub\*(C'\fR ta give tha appearizzle of a
subroutine (although dis aint considered phat style).  One should note
that these code blocks don't straight-up exist as named subroutines (despite
their appearance). Da thang dat gives dis away is tha fact dat you can
have \fBmore than one\fR of these code blocks up in a program, n' they will get
\&\fBall\fR executed all up in tha appropriate moment.  So you can't execute any of
these code blocks by name.
.PP
A \f(CW\*(C`BEGIN\*(C'\fR code block is executed quicker than a muthafucka, dat is, tha moment
it is straight-up defined, even before tha rest of tha containin file (or
string) is parsed. Y'all KNOW dat shit, muthafucka!  Yo ass may have multiple \f(CW\*(C`BEGIN\*(C'\fR blocks within a gangbangin' file (or
eval'ed string); they will execute up in order of definition. I aint talkin' bout chicken n' gravy biatch.  Because a \f(CW\*(C`BEGIN\*(C'\fR
code block executes immediately, it can pull up in definitionz of subroutines
and such from other filez up in time ta be visible ta tha rest of tha compile
and run time.  Once a \f(CW\*(C`BEGIN\*(C'\fR has run, it is immediately undefined n' any
code it used is moonwalked back ta Perlz memory pool.
.PP
An \f(CW\*(C`END\*(C'\fR code block is executed as late as possible, dat is, after
perl has finished hustlin tha program n' just before tha interpreter
is bein exited, even if it is exitin as a result of a \fIdie()\fR function.
(But not if itz morphin tha fuck into another program via \f(CW\*(C`exec\*(C'\fR, or
bein blown outta tha wata by a signal\*(--you gotta trap dat yo ass
(if you can).)  Yo ass may have multiple \f(CW\*(C`END\*(C'\fR blocks within a gangbangin' file\*(--they
will execute up in reverse order of definition; dat is: last in, first
out (\s-1LIFO\s0).  \f(CW\*(C`END\*(C'\fR blocks is not executed when you run perl wit the
\&\f(CW\*(C`\-c\*(C'\fR switch, or if compilation fails.
.PP
Note dat \f(CW\*(C`END\*(C'\fR code blocks is \fBnot\fR executed all up in tha end of a string
\&\f(CW\*(C`eval()\*(C'\fR: if any \f(CW\*(C`END\*(C'\fR code blocks is pimped up in a strang \f(CW\*(C`eval()\*(C'\fR,
they is ghon be executed just as any other \f(CW\*(C`END\*(C'\fR code block of dat package
in \s-1LIFO\s0 order just before tha interpreta is bein exited.
.PP
Inside a \f(CW\*(C`END\*(C'\fR code block, \f(CW$?\fR gotz nuff tha value dat tha program is
goin ta pass ta \f(CW\*(C`exit()\*(C'\fR.  Yo ass can modify \f(CW$?\fR ta chizzle tha exit
value of tha program.  Beware of changin \f(CW$?\fR by accident (e.g. by
runnin suttin' via \f(CW\*(C`system\*(C'\fR).
.IX Xref "$?"
.PP
Inside of a \f(CW\*(C`END\*(C'\fR block, tha value of \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR will be
\&\f(CW"END"\fR.
.PP
\&\f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR n' \f(CW\*(C`INIT\*(C'\fR code blocks is useful ta catch the
transizzle between tha compilation phase n' tha execution phase of
the main program.
.PP
\&\f(CW\*(C`UNITCHECK\*(C'\fR blocks is run just afta tha unit which defined dem has
been compiled. Y'all KNOW dat shit, muthafucka!  Da main program file n' each module it loadz are
compilation units, as is strang \f(CW\*(C`eval\*(C'\fRs, run-time code compiled rockin the
\&\f(CW\*(C`(?{ })\*(C'\fR construct up in a regex, calls ta \f(CW\*(C`do FILE\*(C'\fR, \f(CW\*(C`require FILE\*(C'\fR,
and code afta tha \f(CW\*(C`\-e\*(C'\fR switch on tha command line.
.PP
\&\f(CW\*(C`BEGIN\*(C'\fR n' \f(CW\*(C`UNITCHECK\*(C'\fR blocks is not directly related ta tha phase of
the interpreter n' shit.  They can be pimped n' executed durin any phase.
.PP
\&\f(CW\*(C`CHECK\*(C'\fR code blocks is run just afta tha \fBinitial\fR Perl compile phase ends
and before tha run time begins, up in \s-1LIFO\s0 order n' shit.  \f(CW\*(C`CHECK\*(C'\fR code blocks is used
in tha Perl compila suite ta save tha compiled state of tha program.
.PP
Inside of a \f(CW\*(C`CHECK\*(C'\fR block, tha value of \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR will be
\&\f(CW"CHECK"\fR.
.PP
\&\f(CW\*(C`INIT\*(C'\fR blocks is run just before tha Perl runtime begins execution, in
\&\*(L"first in, first out\*(R" (\s-1FIFO\s0) order.
.PP
Inside of a \f(CW\*(C`INIT\*(C'\fR block, tha value of \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR is ghon be \f(CW"INIT"\fR.
.PP
Da \f(CW\*(C`CHECK\*(C'\fR n' \f(CW\*(C`INIT\*(C'\fR blocks up in code compiled by \f(CW\*(C`require\*(C'\fR, strang \f(CW\*(C`do\*(C'\fR,
or strang \f(CW\*(C`eval\*(C'\fR aint gonna be executed if they occur afta tha end of the
main compilation phase; dat can be a problem up in mod_perl n' other persistent
environments which use dem functions ta load code at runtime.
.PP
When you use tha \fB\-n\fR n' \fB\-p\fR switches ta Perl, \f(CW\*(C`BEGIN\*(C'\fR and
\&\f(CW\*(C`END\*(C'\fR work just as they do up in \fBawk\fR, as a thugged-out degenerate case.
Both \f(CW\*(C`BEGIN\*(C'\fR n' \f(CW\*(C`CHECK\*(C'\fR blocks is run when you use tha \fB\-c\fR
switch fo' a cold-ass lil compile-only syntax check, although yo' main code
is not.
.PP
Da \fBbegincheck\fR program make all dat shiznit clear, eventually:
.PP
.Vb 1
\&  #!/usr/bin/perl
\&
\&  # begincheck
\&
\&  print         "10. Ordinary code runs at runtime.\en";
\&
\&  END { print   "16.   So dis is tha end of tha tale.\en" }
\&  INIT { print  " 7. INIT blocks run FIFO just before runtime.\en" }
\&  UNITCHECK {
\&    print       " 4.   And therefore before any CHECK blocks.\en"
\&  }
\&  CHECK { print " 6.   So dis is tha sixth line.\en" }
\&
\&  print         "11.   It runs up in order, of course.\en";
\&
\&  BEGIN { print " 1. BEGIN blocks run FIFO durin compilation.\en" }
\&  END { print   "15.   Read perlmod fo' tha rest of tha story.\en" }
\&  CHECK { print " 5. CHECK blocks run LIFO afta all compilation.\en" }
\&  INIT { print  " 8.   Run dis again, rockin Perl\*(Aqs \-c switch.\en" }
\&
\&  print         "12.   This be anti\-obfuscated code.\en";
\&
\&  END { print   "14. END blocks run LIFO at quittin time.\en" }
\&  BEGIN { print " 2.   So dis line comes up second.\en" }
\&  UNITCHECK {
\&   print " 3. UNITCHECK blocks run LIFO afta each file is compiled.\en"
\&  }
\&  INIT { print  " 9.   You\*(Aqll peep tha difference right away.\en" }
\&
\&  print         "13.   It merely _looks_ like it should be confusing.\en";
\&
\&  _\|_END_\|_
.Ve
.SS "Perl Classes"
.IX Xref "class @ISA"
.IX Subsection "Perl Classes"
There is no special class syntax up in Perl yo, but a package may act
as a cold-ass lil class if it serves up subroutines ta act as methods.  Such a
package may also derive a shitload of its methodz from another class (package)
by listin tha other package name(s) up in its global \f(CW@ISA\fR array (which
must be a package global, not a lexical).
.PP
For mo' on this, peep perlootut n' perlobj.
.SS "Perl Modules"
.IX Xref "module"
.IX Subsection "Perl Modules"
A module is just a set of related functions up in a library file, i.e.,
a Perl package wit tha same name as tha file.  It be specifically
designed ta be reusable by other modulez or programs.  It may do this
by providin a mechanizzle fo' exportin a shitload of its symbols tha fuck into the
symbol table of any package rockin it, or it may function as a cold-ass lil class
definizzle n' make its semantics available implicitly through
method calls on tha class n' its objects, without explicitly
exportin anything.  Or it can do a lil of both.
.PP
For example, ta start a traditional, non-OO module called Some::Module,
create a gangbangin' file called \fISome/Module.pm\fR n' start wit dis template:
.PP
.Vb 1
\&    package Some::Module;  # assumes Some/Module.pm
\&
\&    use strict;
\&    use warnings;
\&
\&    BEGIN {
\&        require Exporter;
\&
\&        # set tha version fo' version checking
\&        our $VERSION     = 1.00;
\&
\&        # Inherit from Exporta ta export functions n' variables
\&        our @ISA         = qw(Exporter);
\&
\&        # Functions n' variablez which is exported by default
\&        our @EXPORT      = qw(func1 func2);
\&
\&        # Functions n' variablez which can be optionally exported
\&        our @EXPORT_OK   = qw($Var1 %Hashiznit func3);
\&    }
\&
\&    # exported package globals go here
\&    our $Var1    = \*(Aq\*(Aq;
\&    our %Hashiznit  = ();
\&
\&    # non\-exported package globals go here
\&    # (they is still accessible as $Some::Module::stuff)
\&    our @more    = ();
\&    our $shiznit   = \*(Aq\*(Aq;
\&
\&    # file\-private lexicals go here, before any functions which use them
\&    mah $priv_var    = \*(Aq\*(Aq;
\&    mah %secret_hash = ();
\&
\&    # here\*(Aqs a gangbangin' file\-private function as a cold-ass lil closure,
\&    # callable as $priv_func\->();
\&    mah $priv_func = sub {
\&        ...
\&    };
\&
\&    # make all yo' functions, whether exported or not;
\&    # remember ta put suttin' bangin-ass up in tha {} stubs
\&    sub func1      { ... }
\&    sub func2      { ... }
\&
\&    # dis one isn\*(Aqt exported yo, but could be called directly
\&    # as Some::Module::func3()
\&    sub func3      { ... }
\&
\&    END { ... }       # module clean\-up code here (global destructor)
\&
\&    1;  # don\*(Aqt forget ta return a legit value from tha file
.Ve
.PP
Then go on ta declare n' use yo' variablez up in functions without
any qualifications.  See Exporta n' tha perlmodlib for
details on mechanics n' steez thangs up in module creation.
.PP
Perl modulez is included tha fuck into yo' program by saying
.PP
.Vb 1
\&    use Module;
.Ve
.PP
or
.PP
.Vb 1
\&    use Module LIST;
.Ve
.PP
This is exactly equivalent to
.PP
.Vb 1
\&    BEGIN { require \*(AqModule.pm\*(Aq; \*(AqModule\*(Aq\->import; }
.Ve
.PP
or
.PP
.Vb 1
\&    BEGIN { require \*(AqModule.pm\*(Aq; \*(AqModule\*(Aq\->import( LIST ); }
.Ve
.PP
As a special case
.PP
.Vb 1
\&    use Module ();
.Ve
.PP
is exactly equivalent to
.PP
.Vb 1
\&    BEGIN { require \*(AqModule.pm\*(Aq; }
.Ve
.PP
All Perl module filez have tha extension \fI.pm\fR.  Da \f(CW\*(C`use\*(C'\fR operator
assumes dis so you don't gotta spell up "\fIModule.pm\fR" up in quotes.
This also helps ta differentiate freshly smoked up modulez from oldschool \fI.pl\fR and
\&\fI.ph\fR files.  Module names is also capitalized unless they're
functionin as pragmas; pragmas is up in effect compila directives,
and is sometimes called \*(L"pragmatic modules\*(R" (or even \*(L"pragmata\*(R"
if you a cold-ass lil classicist).
.PP
Da two statements:
.PP
.Vb 2
\&    require SomeModule;
\&    require "SomeModule.pm";
.Ve
.PP
differ from each other up in two ways.  In tha straight-up original gangsta case, any double
colons up in tha module name, like fuckin \f(CW\*(C`Some::Module\*(C'\fR, is translated
into yo' systemz directory separator, probably \*(L"/\*(R".   Da second
case do not, n' would gotta be specified literally.  Da other
difference is dat seein tha straight-up original gangsta \f(CW\*(C`require\*(C'\fR clues up in tha compiler
that usez of indirect object notation involvin \*(L"SomeModule\*(R", as
in \f(CW\*(C`$ob = purge SomeModule\*(C'\fR, is method calls, not function calls.
(Yes, dis straight-up can cook up a gangbangin' finger-lickin' difference.)
.PP
Because tha \f(CW\*(C`use\*(C'\fR statement implies a \f(CW\*(C`BEGIN\*(C'\fR block, tha importing
of semantics happens as soon as tha \f(CW\*(C`use\*(C'\fR statement is compiled,
before tha rest of tha file is compiled. Y'all KNOW dat shit, muthafucka!  This is how tha fuck it be able
to function as a pragma mechanism, n' also how tha fuck modulez is able to
declare subroutines dat is then visible as list or unary operators for
the rest of tha current file.  This aint gonna work if you use \f(CW\*(C`require\*(C'\fR
instead of \f(CW\*(C`use\*(C'\fR.  With \f(CW\*(C`require\*(C'\fR you can git tha fuck into dis problem:
.PP
.Vb 2
\&    require Cwd;                # make Cwd:: accessible
\&    $here = Cwd::getcwd();
\&
\&    use Cwd;                    # import names from Cwd::
\&    $here = getcwd();
\&
\&    require Cwd;                # make Cwd:: accessible
\&    $here = getcwd();           # oops muthafucka! no main::getcwd()
.Ve
.PP
In general, \f(CW\*(C`use Module ()\*(C'\fR is recommended over \f(CW\*(C`require Module\*(C'\fR,
because it determines module availabilitizzle at compile time, not up in the
middle of yo' programz execution. I aint talkin' bout chicken n' gravy biatch.  An exception would be if two modules
each tried ta \f(CW\*(C`use\*(C'\fR each other, n' each also called a gangbangin' function from
that other module.  In dat case, itz easy as fuck  ta use \f(CW\*(C`require\*(C'\fR instead.
.PP
Perl packages may be nested inside other package names, so we can have
package names containin \f(CW\*(C`::\*(C'\fR.  But if we used dat package name
directly as a gangbangin' filename it would make fo' unwieldy or impossible
filenames on some systems.  Therefore, if a modulez name is, say,
\&\f(CW\*(C`Text::Soundex\*(C'\fR, then its definizzle is straight-up found up in tha library
file \fIText/Soundex.pm\fR.
.PP
Perl modulez always gotz a \fI.pm\fR file yo, but there may also be
dynamically linked executablez (often endin up in \fI.so\fR) or autoloaded
subroutine definitions (often endin up in \fI.al\fR) associated wit the
module.  If so, these is ghon be entirely transparent ta tha user of
the module.  It be tha responsibilitizzle of tha \fI.pm\fR file ta load
(or arrange ta autoload) any additionizzle functionality.  For example,
although tha \s-1POSIX\s0 module happens ta do both dynamic loadin and
autoloading, tha user can say just \f(CW\*(C`use POSIX\*(C'\fR ta git it all.
.SS "Makin yo' module threadsafe"
.IX Xref "threadsafe thread safe module, threadsafe module, thread safe CLONE CLONE_SKIP thread threadz ithread"
.IX Subsection "Makin yo' module threadsafe"
Perl supports a type of threadz called interpreta threadz (ithreads).
These threadz can be used explicitly n' implicitly.
.PP
Ithreadz work by clonin tha data tree so dat no data is shared
between different threads. These threadz can be used by rockin tha \f(CW\*(C`threads\*(C'\fR
module or by bustin \fIfork()\fR on win32 (fake \fIfork()\fR support). When a
thread is cloned all Perl data is cloned, however non-Perl data cannot
be cloned automatically.  Perl afta 5.8.0 has support fo' tha \f(CW\*(C`CLONE\*(C'\fR
special subroutine.  In \f(CW\*(C`CLONE\*(C'\fR you can do whatever
you need ta do,
like fo' example handle tha clonin of non-Perl data, if necessary.
\&\f(CW\*(C`CLONE\*(C'\fR is ghon be called once as a cold-ass lil class method fo' every last muthafuckin package dat has it
defined (or inherits it).  It is ghon be called up in tha context of tha freshly smoked up thread,
so all modifications is made up in tha freshly smoked up area.  Currently \s-1CLONE\s0 is called with
no parametas other than tha invocant package name yo, but code should not assume
that dis will remain unchanged, as it is likely dat up in future extra parameters
will be passed up in ta give mo' shiznit bout tha state of cloning.
.PP
If you wanna \s-1CLONE\s0 all objects yo big-ass booty is ghon need ta keep track of dem per
package. This is simply done rockin a hash n' \fIScalar::Util::weaken()\fR.
.PP
Perl afta 5.8.7 has support fo' tha \f(CW\*(C`CLONE_SKIP\*(C'\fR special subroutine.
Like \f(CW\*(C`CLONE\*(C'\fR, \f(CW\*(C`CLONE_SKIP\*(C'\fR is called once per package; however, it is
called just before clonin starts, n' up in tha context of tha parent
thread. Y'all KNOW dat shit, muthafucka! If it returns a legit value, then no objectz of dat class will
be cloned; or rather, they is ghon be copied as unblessed, undef joints.
For example: if up in tha parent there be two references ta a single pimped
hash, then up in tha lil pimp there is ghon be two references ta a single undefined
scalar value instead.
This serves up a simple mechanizzle fo' bustin a module threadsafe; just add
\&\f(CW\*(C`sub CLONE_SKIP { 1 }\*(C'\fR all up in tha top of tha class, n' \f(CW\*(C`DESTROY()\*(C'\fR will
now only be called once per object. Of course, if tha lil pimp thread needs
to make use of tha objects, then a mo' sophisticated approach is
needed.
.PP
Like \f(CW\*(C`CLONE\*(C'\fR, \f(CW\*(C`CLONE_SKIP\*(C'\fR is currently called wit no parametas other
than tha invocant package name, although dat may chizzle. Right back up in yo muthafuckin ass. Similarly, to
allow fo' future expansion, tha return value should be a single \f(CW0\fR or
\&\f(CW1\fR value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See perlmodlib fo' general steez thangs related ta buildin Perl
modulez n' classes, as well as descriptionz of tha standard library
and \s-1CPAN, \s0Exporta fo' how tha fuck Perlz standard import/export mechanism
works, perlootut n' perlobj fo' in-depth shiznit on
bustin classes, perlobj fo' a hard-core reference document on
objects, perlsub fo' a explanation of functions n' scoping,
and perlxstut n' perlguts fo' mo' shiznit on writing
extension modules.
