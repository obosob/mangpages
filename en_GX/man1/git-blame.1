'\" t
.\"     Title: git-blame
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-BLAME" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-blame \- Show what tha fuck revision n' lyricist last modified each line of a gangbangin' file
.SH "SYNOPSIS"
.sp
.nf
\fIgit blame\fR [\-c] [\-b] [\-l] [\-\-root] [\-t] [\-f] [\-n] [\-s] [\-e] [\-p] [\-w] [\-\-incremental]
            [\-L <range>] [\-S <revs\-file>] [\-M] [\-C] [\-C] [\-C] [\-\-since=<date>]
            [\-\-abbrev=<n>] [<rev> | \-\-contents <file> | \-\-reverse <rev>] [\-\-] <file>
.fi
.sp
.SH "DESCRIPTION"
.sp
Annotates each line up in tha given file wit shiznit from tha revision which last modified tha line\&. Optionally, start annotatin from tha given revision\&.
.sp
When specified one or mo' times, \-L restricts annotation ta tha axed lines\&.
.sp
Da origin of lines be automatically followed across whole\-file renames (currently there is no option ta turn tha rename\-followin off)\&. To follow lines moved from one file ta another, or ta follow lines dat was copied n' pasted from another file, etc\&., peep tha \-C n' \-M options\&.
.sp
Da report do not rap  anythang bout lines which done been deleted or replaced; you need ta bust a tool like fuckin \fIgit diff\fR or tha "pickaxe" intercourse briefly mentioned up in tha followin paragraph\&.
.sp
Apart from supportin file annotation, Git also supports searchin tha pimpment history fo' when a cold-ass lil code snippet occurred up in a cold-ass lil chizzle\&. This make it possible ta track when a cold-ass lil code snippet was added ta a gangbangin' file, moved or copied between files, n' eventually deleted or replaced\&. Well shiiiit, it works by searchin fo' a text strang up in tha diff\& fo' realz. A lil' small-ass example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-\-pretty=oneline \-S\(aqblame_usage\(aq
5040f17eba15504bad66b14a645bddd9b015ebb7 blame \-S <ancestry\-file>
ea4c7f9bf69e781dd0cd88d2bccb2bf5cc15c9a7 git\-blame: Make tha output
.fi
.if n \{\
.RE
.\}
.sp
.SH "OPTIONS"
.PP
\-b
.RS 4
Show blank SHA\-1 fo' boundary commits\&. This can also be controlled via the
blame\&.blankboundary
config option\&.
.RE
.PP
\-\-root
.RS 4
Do not treat root commits as boundaries\&. This can also be controlled via the
blame\&.showroot
config option\&.
.RE
.PP
\-\-show\-stats
.RS 4
Include additionizzle statistics all up in tha end of blame output\&.
.RE
.PP
\-L <start>,<end>, \-L :<regex>
.RS 4
Annotate only tha given line range\&. May be specified multiple times\&. Overlappin ranges is allowed\&.
.sp
<start> n' <end> is optional\&. \(lq\-L <start>\(rq or \(lq\-L <start>,\(rq spans from <start> ta end of file\&. \(lq\-L ,<end>\(rq spans from start of file ta <end>\&.
.sp
<start> n' <end> can take one of these forms:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
number
.sp
If <start> or <end> be a number, it specifies a absolute line number (lines count from 1)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
/regex/
.sp
This form will use tha straight-up original gangsta line matchin tha given POSIX regex\&. If <start> be a regex, it will search from tha end of tha previous
\-L
range, if any, otherwise from tha start of file\&. If <start> is \(lq^/regex/\(rq, it will search from tha start of file\&. If <end> be a regex, it will search startin all up in tha line given by <start>\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
+offset or \-offset
.sp
This is only valid fo' <end> n' will specify a fuckin shitload of lines before or afta tha line given by <start>\&.
.RE
.sp
If \(lq:<regex>\(rq is given up in place of <start> n' <end>, it denotes tha range from tha straight-up original gangsta funcname line dat matches <regex>, up ta tha next funcname line\&. \(lq:<regex>\(rq searches from tha end of tha previous
\-L
range, if any, otherwise from tha start of file\&. \(lq^:<regex>\(rq searches from tha start of file\&.
.RE
.PP
\-l
.RS 4
Show long rev (Default: off)\&.
.RE
.PP
\-t
.RS 4
Show raw timestamp (Default: off)\&.
.RE
.PP
\-S <revs\-file>
.RS 4
Use revisions from revs\-file instead of calling
\fBgit-rev-list\fR(1)\&.
.RE
.PP
\-\-reverse
.RS 4
Walk history forward instead of backward\&. Instead of showin tha revision up in which a line rocked up, dis shows tha last revision up in which a line has existed\&. This requires a range of revision like START\&.\&.END where tha path ta blame exists up in START\&.
.RE
.PP
\-p, \-\-porcelain
.RS 4
Show up in a gangbangin' format designed fo' machine consumption\&.
.RE
.PP
\-\-line\-porcelain
.RS 4
Show tha porcelain format yo, but output commit shiznit fo' each line, not just tha last time a cold-ass lil commit is referenced\&. Implies \-\-porcelain\&.
.RE
.PP
\-\-incremental
.RS 4
Show tha result incrementally up in a gangbangin' format designed fo' machine consumption\&.
.RE
.PP
\-\-encoding=<encoding>
.RS 4
Specifies tha encodin used ta output lyricist names n' commit summaries\&. Right back up in yo muthafuckin ass. Settin it to
none
makes blame output unconverted data\&. For mo' shiznit peep tha rap bout encodin up in the
\fBgit-log\fR(1)
manual page\&.
.RE
.PP
\-\-contents <file>
.RS 4
When <rev> aint specified, tha command annotates tha chizzlez startin backwardz from tha hustlin tree copy\&. This flag make tha command pretend as if tha hustlin tree copy has tha contentz of tha named file (specify
\-
to make tha command read from tha standard input)\&.
.RE
.PP
\-\-date <format>
.RS 4
Da value is one of tha followin alternatives: {relative,local,default,iso,rfc,short}\&. If \-\-date aint provided, tha value of tha blame\&.date config variable is used\&. If tha blame\&.date config variable be also not set, tha iso format is used\&. For mo' shiznit, See tha rap of tha \-\-date option at
\fBgit-log\fR(1)\&.
.RE
.PP
\-M|<num>|
.RS 4
Detect moved or copied lines within a gangbangin' file\&. When a cold-ass lil commit moves or copies a funky-ass block of lines (e\&.g\&. tha original gangsta file has A n' then B, n' tha commit chizzlez it ta B n' then A), tha traditional
\fIblame\fR
algorithm notices only half of tha movement n' typically blames tha lines dat was moved up (i\&.e\&. B) ta tha parent n' assigns blame ta tha lines dat was moved down (i\&.e\& fo' realz. A) ta tha lil pimp commit\&. With dis option, both crewz of lines is blamed on tha parent by hustlin extra passez of inspection\&.
.sp
<num> is optionizzle but it is tha lower bound on tha number of alphanumeric charactas dat Git must detect as moving/copyin within a gangbangin' file fo' it ta associate dem lines wit tha parent commit\&. Da default value is 20\&.
.RE
.PP
\-C|<num>|
.RS 4
In addizzle to
\-M, detect lines moved or copied from other filez dat was modified up in tha same commit\&. This is useful when you reorganize yo' program n' move code round across files\&. When dis option is given twice, tha command additionally looks fo' copies from other filez up in tha commit dat creates tha file\&. When dis option is given three times, tha command additionally looks fo' copies from other filez up in any commit\&.
.sp
<num> is optionizzle but it is tha lower bound on tha number of alphanumeric charactas dat Git must detect as moving/copyin between filez fo' it ta associate dem lines wit tha parent commit\& fo' realz. And tha default value is 40\&. If there be mo' than one
\-C
options given, tha <num> argument of tha last
\-C
will take effect\&.
.RE
.PP
\-h
.RS 4
Show help message\&.
.RE
.PP
\-c
.RS 4
Use tha same output mode as
\fBgit-annotate\fR(1)
(Default: off)\&.
.RE
.PP
\-\-score\-debug
.RS 4
Include debuggin shiznit related ta tha movement of lines between filez (see
\-C) n' lines moved within a gangbangin' file (see
\-M)\&. Da first number listed is tha score\&. This is tha number of alphanumeric charactas detected as havin been moved between or within files\&. This must be above a cold-ass lil certain threshold for
\fIgit blame\fR
to consider dem linez of code ta done been moved\&.
.RE
.PP
\-f, \-\-show\-name
.RS 4
Show tha filename up in tha original gangsta commit\&. By default tha filename is shown if there be any line dat came from a gangbangin' file wit a gangbangin' finger-lickin' different name, cuz of rename detection\&.
.RE
.PP
\-n, \-\-show\-number
.RS 4
Show tha line number up in tha original gangsta commit (Default: off)\&.
.RE
.PP
\-s
.RS 4
Suppress tha lyricist name n' timestamp from tha output\&.
.RE
.PP
\-e, \-\-show\-email
.RS 4
Show tha lyricist email instead of lyricist name (Default: off)\&.
.RE
.PP
\-w
.RS 4
Ignore whitespace when comparin tha parent\(cqs version n' tha child\(cqs ta find where tha lines came from\&.
.RE
.PP
\-\-abbrev=<n>
.RS 4
Instead of rockin tha default 7+1 hexadecimal digits as tha abbreviated object name, use <n>+1 digits\&. Note dat 1 column is used fo' a cold-ass lil caret ta mark tha boundary commit\&.
.RE
.SH "THE PORCELAIN FORMAT"
.sp
In dis format, each line is output afta a header; tha header all up in tha minimum has tha straight-up original gangsta line which has:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
40\-byte SHA\-1 of tha commit tha line be attributed to;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the line number of tha line up in tha original gangsta file;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the line number of tha line up in tha final file;
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
on a line dat starts a crew of lines from a gangbangin' finger-lickin' different commit than tha previous one, tha number of lines up in dis group\&. On subsequent lines dis field be absent\&.
.RE
.sp
This header line is followed by tha followin shiznit at least once fo' each commit:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the lyricist name ("author"), email ("author\-mail"), time ("author\-time"), n' time unit ("author\-tz"); similarly fo' committer\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the filename up in tha commit dat tha line be attributed to\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the first line of tha commit log message ("summary")\&.
.RE
.sp
Da contentz of tha actual line is output afta tha above header, prefixed by a TAB\&. This is ta allow addin mo' header elements later\&.
.sp
Da porcelain format generally suppresses commit shiznit dat has already been seen\&. For example, two lines dat is blamed ta tha same commit will both be shown yo, but tha details fo' dat commit is ghon be shown only once\&. This is mo' efficient yo, but may require mo' state be kept by tha reader\&. Da \-\-line\-porcelain option can be used ta output full commit shiznit fo' each line, allowin simpla (but less efficient) usage like:
.sp
.if n \{\
.RS 4
.\}
.nf
# count tha number of lines attributed ta each author
git blame \-\-line\-porcelain file |
sed \-n \(aqs/^lyricist //p\(aq |
sort | uniq \-c | sort \-rn
.fi
.if n \{\
.RE
.\}
.SH "SPECIFYING RANGES"
.sp
Unlike \fIgit blame\fR n' \fIgit annotate\fR up in olda versionz of git, tha extent of tha annotation can be limited ta both line ranges n' revision ranges\&. Da \-L option, which limits annotation ta a range of lines, may be specified multiple times\&.
.sp
When yo ass is horny bout findin tha origin fo' lines 40\-60 fo' file foo, you can use tha \-L option like so (they mean tha same thang \(em both ask fo' 21 lines startin at line 40):
.sp
.if n \{\
.RS 4
.\}
.nf
git blame \-L 40,60 foo
git blame \-L 40,+21 foo
.fi
.if n \{\
.RE
.\}
.sp
Also you can bust a regular expression ta specify tha line range:
.sp
.if n \{\
.RS 4
.\}
.nf
git blame \-L \(aq/^sub wassup {/,/^}$/\(aq foo
.fi
.if n \{\
.RE
.\}
.sp
which limits tha annotation ta tha body of tha wassup subroutine\&.
.sp
When yo ass is not horny bout chizzlez olda than version v2\&.6\&.18, or chizzlez olda than 3 weeks, you can use revision range specifiers similar ta \fIgit rev\-list\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
git blame v2\&.6\&.18\&.\&. \-\- foo
git blame \-\-since=3\&.weeks \-\- foo
.fi
.if n \{\
.RE
.\}
.sp
When revision range specifiers is used ta limit tha annotation, lines dat aint chizzled since tha range boundary (either tha commit v2\&.6\&.18 or da most thugged-out recent commit dat is mo' than 3 weeks oldschool up in tha above example) is blamed fo' dat range boundary commit\&.
.sp
A particularly useful way is ta peep if a added file has lines pimped by copy\-and\-paste from existin files\&. Right back up in yo muthafuckin ass. Sometimes dis indicates dat tha pimper was bein sloppy n' did not refactor tha code properly\&. Yo ass can first find tha commit dat introduced tha file with:
.sp
.if n \{\
.RS 4
.\}
.nf
git log \-\-diff\-filter=A \-\-pretty=short \-\- foo
.fi
.if n \{\
.RE
.\}
.sp
and then annotate tha chizzle between tha commit n' its muthafathas, rockin commit^! notation:
.sp
.if n \{\
.RS 4
.\}
.nf
git blame \-C \-C \-f $commit^! \-\- foo
.fi
.if n \{\
.RE
.\}
.SH "INCREMENTAL OUTPUT"
.sp
When called wit \-\-incremenstrual option, tha command outputs tha result as it is built\&. Da output generally will rap bout lines touched by mo' recent commits first (i\&.e\&. tha lines is ghon be annotated outta order) n' is meant ta be used by interactizzle viewers\&.
.sp
Da output format is similar ta tha Porcelain format yo, but it do not contain tha actual lines from tha file dat is bein annotated\&.
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Each blame entry always starts wit a line of:
.sp
.if n \{\
.RS 4
.\}
.nf
<40\-byte hex sha1> <sourceline> <resultline> <num_lines>
.fi
.if n \{\
.RE
.\}
.sp
Line numbers count from 1\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Da last time dat a cold-ass lil commit shows up in tha stream, it has various other shiznit bout it printed up wit a one\-word tag all up in tha beginnin of each line describin tha extra commit shiznit (lyricist, email, committer, dates, summary, etc\&.)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Unlike tha Porcelain format, tha filename shiznit be always given n' terminates tha entry:
.sp
.if n \{\
.RS 4
.\}
.nf
"filename" <whitespace\-quoted\-filename\-goes\-here>
.fi
.if n \{\
.RE
.\}
.sp
and thus it is straight-up like easy as fuck  ta parse fo' some line\- n' word\-oriented parser (which should be like natural fo' most scriptin languages)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
For playas whoz ass do parsing: ta make it mo' robust, just ignore any lines between tha straight-up original gangsta n' last one ("<sha1>" n' "filename" lines) where you do not recognize tha tag lyrics (or care bout dat particular one) all up in tha beginnin of tha "extended shiznit" lines\&. That way, if there is eva added shiznit (like tha commit encodin or extended commit commentary), a funky-ass blame viewer aint gonna care\&.
.sp .5v
.RE
.RE
.SH "MAPPING AUTHORS"
.sp
If tha file \&.mailmap exists all up in tha toplevel of tha repository, or all up in tha location pointed ta by tha mailmap\&.file or mailmap\&.blob configuration options, it is used ta map lyricist n' committa names n' email addresses ta canonical real names n' email addresses\&.
.sp
In tha simple form, each line up in tha file consistz of tha canonical real name of a lyricist, whitespace, n' a email address used up in tha commit (enclosed by \fI<\fR n' \fI>\fR) ta map ta tha name\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
Proper Name <commit@email\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
Da mo' complex forms are:
.sp
.if n \{\
.RS 4
.\}
.nf
<proper@email\&.xx> <commit@email\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
which allows mailmap ta replace only tha email part of a cold-ass lil commit, and:
.sp
.if n \{\
.RS 4
.\}
.nf
Proper Name <proper@email\&.xx> <commit@email\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
which allows mailmap ta replace both tha name n' tha email of a cold-ass lil commit matchin tha specified commit email address, and:
.sp
.if n \{\
.RS 4
.\}
.nf
Proper Name <proper@email\&.xx> Commit Name <commit@email\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
which allows mailmap ta replace both tha name n' tha email of a cold-ass lil commit matchin both tha specified commit name n' email address\&.
.sp
Example 1: Yo crazy-ass history gotz nuff commits by two authors, Jane n' Joe, whose names step tha fuck up in tha repository under nuff muthafuckin forms:
.sp
.if n \{\
.RS 4
.\}
.nf
Joe Developer <joe@example\&.com>
Joe R\&. Developer <joe@example\&.com>
Jane Doe <jane@example\&.com>
Jane Doe <jane@laptop\&.(none)>
Jane D\&. <jane@desktop\&.(none)>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Now suppose dat Joe wants his crazy-ass middle name initial used, n' Jane prefers her crew name straight-up spelled out\& fo' realz. A proper \&.mailmap file would look like:
.sp
.if n \{\
.RS 4
.\}
.nf
Jane Doe         <jane@desktop\&.(none)>
Joe R\&. Developer <joe@example\&.com>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Note how tha fuck there is no need fo' a entry fo' <jane@laptop\&.(none)>, cuz tha real name of dat lyricist be already erect\&.
.sp
Example 2: Yo crazy-ass repository gotz nuff commits from tha followin authors:
.sp
.if n \{\
.RS 4
.\}
.nf
nick1 <bugs@company\&.xx>
nick2 <bugs@company\&.xx>
nick2 <nick2@company\&.xx>
santa <me@company\&.xx>
claus <me@company\&.xx>
CTO <cto@coompany\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Then you might want a \&.mailmap file dat looks like:
.sp
.if n \{\
.RS 4
.\}
.nf
<cto@company\&.xx>                       <cto@coompany\&.xx>
Some Dude <some@dude\&.xx>         nick1 <bugs@company\&.xx>
Other Lyricist <other@author\&.xx>   nick2 <bugs@company\&.xx>
Other Lyricist <other@author\&.xx>         <nick2@company\&.xx>
Gangsta Claus <santa\&.claus@northpole\&.xx> <me@company\&.xx>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Use hash \fI#\fR fo' comments dat is either on they own line, or afta tha email address\&.
.SH "SEE ALSO"
.sp
\fBgit-annotate\fR(1)
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
