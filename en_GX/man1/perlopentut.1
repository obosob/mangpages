.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOPENTUT 1"
.TH PERLOPENTUT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlopentut \- tutorial on openin thangs up in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl has two simple, built-in ways ta open files: tha shell way for
convenience, n' tha C way fo' precision. I aint talkin' bout chicken n' gravy biatch.  Da shell way also has 2\- and
3\-argument forms, which have different semantics fo' handlin tha filename.
Da chizzle is yours.
.SH "Open a\*` la shell"
.IX Header "Open a` la shell"
Perlz \f(CW\*(C`open\*(C'\fR function was designed ta mimic tha way command-line
redirection up in tha shell works.  Here is some basic examples
from tha shell:
.PP
.Vb 6
\&    $ myprogram file1 file2 file3
\&    $ myprogram    <  inputfile
\&    $ myprogram    >  outputfile
\&    $ myprogram    >> outputfile
\&    $ myprogram    |  otherprogram 
\&    $ otherprogram |  myprogram
.Ve
.PP
And here is some mo' advanced examples:
.PP
.Vb 4
\&    $ otherprogram      | myprogram f1 \- f2
\&    $ otherprogram 2>&1 | myprogram \-
\&    $ myprogram     <&3
\&    $ myprogram     >&4
.Ve
.PP
Programmers accustomed ta constructs like dem above can take comfort
in peepin' dat Perl directly supports these familiar constructs using
virtually tha same syntax as tha shell.
.SS "Simple Opens"
.IX Subsection "Simple Opens"
Da \f(CW\*(C`open\*(C'\fR function takes two arguments: tha straight-up original gangsta be a gangbangin' filehandle,
and tha second be a single strang comprisin both what tha fuck ta open n' how
to open dat shit.  \f(CW\*(C`open\*(C'\fR returns legit when it works, n' when it fails,
returns a gangbangin' false value n' sets tha special variable \f(CW$!\fR ta reflect
the system error. Shiiit, dis aint no joke.  If tha filehandle was previously opened, it will
be implicitly closed first.
.PP
For example:
.PP
.Vb 4
\&    open(INFO,      "datafile") || die("can\*(Aqt open datafile: $!");
\&    open(INFO,   "<  datafile") || die("can\*(Aqt open datafile: $!");
\&    open(RESULTS,">  runstats") || die("can\*(Aqt open runstats: $!");
\&    open(LOG,    ">> logfile ") || die("can\*(Aqt open logfile:  $!");
.Ve
.PP
If you prefer tha low-punctuation version, you could write dat dis way:
.PP
.Vb 3
\&    open INFO,   "<  datafile"  or take a thugged-out dirtnap "can\*(Aqt open datafile: $!";
\&    open RESULTS,">  runstats"  or take a thugged-out dirtnap "can\*(Aqt open runstats: $!";
\&    open LOG,    ">> logfile "  or take a thugged-out dirtnap "can\*(Aqt open logfile:  $!";
.Ve
.PP
A few thangs ta notice.  First, tha leadin \f(CW\*(C`<\*(C'\fR is optional.
If omitted, Perl assumes dat you wanna open tha file fo' reading.
.PP
Note also dat tha straight-up original gangsta example uses tha \f(CW\*(C`||\*(C'\fR logical operator, n' the
second uses \f(CW\*(C`or\*(C'\fR, which has lower precedence.  Usin \f(CW\*(C`||\*(C'\fR up in tha latter
examplez would effectively mean
.PP
.Vb 1
\&    open INFO, ( "<  datafile"  || take a thugged-out dirtnap "can\*(Aqt open datafile: $!" );
.Ve
.PP
which is definitely not what tha fuck you want.
.PP
Da other blingin thang ta notice is that, just as up in tha shell,
any whitespace before or afta tha filename is ignored. Y'all KNOW dat shit, muthafucka!  This is good,
because you wouldn't want these ta do different thangs:
.PP
.Vb 3
\&    open INFO,   "<datafile"   
\&    open INFO,   "< datafile" 
\&    open INFO,   "<  datafile"
.Ve
.PP
Ignorin surroundin whitespace also helps fo' when you read a gangbangin' filename
in from a gangbangin' finger-lickin' different file, n' forget ta trim it before opening:
.PP
.Vb 2
\&    $filename = <INFO>;         # oops, \en still there
\&    open(EXTRA, "< $filename") || take a thugged-out dirtnap "can\*(Aqt open $filename: $!";
.Ve
.PP
This aint a funky-ass bug yo, but a gangbangin' feature.  Because \f(CW\*(C`open\*(C'\fR mimics tha shell in
its steez of rockin redirection arrows ta specify how tha fuck ta open tha file, it
also do so wit respect ta extra whitespace round tha filename itself
as well.  For accessin filez wit naughty names, peep 
\&\*(L"Dispellin tha Dweomer\*(R".
.PP
There be also a 3\-argument version of \f(CW\*(C`open\*(C'\fR, which lets you put the
special redirection charactas tha fuck into they own argument:
.PP
.Vb 1
\&    open( INFO, ">", $datafile ) || take a thugged-out dirtnap "Can\*(Aqt create $datafile: $!";
.Ve
.PP
In dis case, tha filename ta open is tha actual strang up in \f(CW$datafile\fR,
so you don't gotta worry bout \f(CW$datafile\fR containin characters
that might influence tha open mode, or whitespace all up in tha beginnin of
the filename dat would be absorbed up in tha 2\-argument version. I aint talkin' bout chicken n' gravy biatch.  Also,
any reduction of unnecessary strang interpolation be a phat thang.
.SS "Indirect Filehandles"
.IX Subsection "Indirect Filehandles"
\&\f(CW\*(C`open\*(C'\fRz first argument can be a reference ta a gangbangin' filehandle.  As of
perl 5.6.0, if tha argument is uninitialized, Perl will automatically
create a gangbangin' filehandle n' put a reference ta it up in tha straight-up original gangsta argument,
like so:
.PP
.Vb 5
\&    open( mah $in, $infile )   or take a thugged-out dirtnap "Couldn\*(Aqt read $infile: $!";
\&    while ( <$in> ) {
\&        # do suttin' wit $_
\&    }
\&    close $in;
.Ve
.PP
Indirect filehandlez make namespace pimpment easier n' shit.  Since filehandles
are global ta tha current package, two subroutines tryin ta open
\&\f(CW\*(C`INFILE\*(C'\fR will clash.  With two functions openin indirect filehandles
like \f(CW\*(C`my $infile\*(C'\fR, there be a no clash n' no need ta worry bout future
conflicts.
.PP
Another convenient behavior is dat a indirect filehandle automatically
closes when there be no mo' references ta it:
.PP
.Vb 4
\&    sub firstline {
\&        open( mah $in, shift ) && return scalar <$in>;
\&        # no close() required
\&    }
.Ve
.PP
Indirect filehandlez also make it easy as fuck  ta pass filehandlez ta n' return
filehandlez from subroutines:
.PP
.Vb 5
\&    fo' mah $file ( qw(this.conf dis shit.conf) ) {
\&        mah $fin = open_or_throw(\*(Aq<\*(Aq, $file);
\&        process_conf( $fin );
\&        # no close() needed
\&    }
\&
\&    use Carp;
\&    sub open_or_throw {
\&        mah ($mode, $filename) = @_;
\&        open mah $h, $mode, $filename
\&            or croak "Could not open \*(Aq$filename\*(Aq: $!";
\&        return $h;
\&    }
.Ve
.SS "Pipe Opens"
.IX Subsection "Pipe Opens"
In C, when you wanna open a gangbangin' file rockin tha standard I/O library,
you use tha \f(CW\*(C`fopen\*(C'\fR function yo, but when openin a pipe, you use the
\&\f(CW\*(C`popen\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  But up in tha shell, you just bust a gangbangin' finger-lickin' different redirection
character n' shit.  Thatz also tha case fo' Perl.  Da \f(CW\*(C`open\*(C'\fR call 
remains tha same\*(--just its argument differs.
.PP
If tha leadin characta be a pipe symbol, \f(CW\*(C`open\*(C'\fR starts up a new
command n' opens a write-only filehandle leadin tha fuck into dat command.
This lets you write tha fuck into dat handle n' have what tha fuck you write show up on
that commandz standard input.  For example:
.PP
.Vb 3
\&    open(PRINTER, "| lpr \-Plp1")    || take a thugged-out dirtnap "can\*(Aqt run lpr: $!";
\&    print PRINTER "stuff\en";
\&    close(PRINTER)                  || take a thugged-out dirtnap "can\*(Aqt close lpr: $!";
.Ve
.PP
If tha trailin characta be a pipe, you start up a freshly smoked up command n' open a
read-only filehandle leadin outta dat command. Y'all KNOW dat shit, muthafucka!  This lets whatever that
command writes ta its standard output show up on yo' handle fo' reading.
For example:
.PP
.Vb 3
\&    open(NET, "netstat \-i \-n |")    || take a thugged-out dirtnap "can\*(Aqt fork netstat: $!";
\&    while (<NET>) { }               # do suttin' wit input
\&    close(NET)                      || take a thugged-out dirtnap "can\*(Aqt close netstat: $!";
.Ve
.PP
What happens if you try ta open a pipe ta or from a non-existent
command, biatch?  If possible, Perl will detect tha failure n' set \f(CW$!\fR as
usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  But if tha command gotz nuff special shell characters, such as
\&\f(CW\*(C`>\*(C'\fR or \f(CW\*(C`*\*(C'\fR, called 'metacharacters', Perl do not execute the
command directly.  Instead, Perl runs tha shell, which then tries to
run tha command. Y'all KNOW dat shit, muthafucka!  This means dat itz tha shell dat gets tha error
indication. I aint talkin' bout chicken n' gravy biatch.  In such a cold-ass lil case, tha \f(CW\*(C`open\*(C'\fR call will only indicate
failure if Perl can't even run tha shell.  See \*(L"How tha fuck can I
capture \s-1STDERR\s0 from a external command?\*(R" up in perlfaq8 ta peep how tha fuck ta cope with
this.  Therez also a explanation up in perlipc.
.PP
If you wanna open a funky-ass bidirectionizzle pipe, tha IPC::Open2
library will handle dis fo' yo thugged-out ass.  Peep up 
\&\*(L"Bidirectionizzle Communication wit Another Process\*(R" up in perlipc
.PP
perl\-5.6.x introduced a version of piped open dat executes a process
based on its command line arguments without relyin on tha shell. (Similar
to tha \f(CW\*(C`system(@LIST)\*(C'\fR notation.) This is less thuggy n' fasta than executing
a single argument pipe-command yo, but do not allow special shell
constructs, n' you can put dat on yo' toast. (It be also not supported on Microsizzlez Windows, Mac \s-1OS\s0 Classic
or \s-1RISC OS.\s0)
.PP
Herez a example of \f(CW\*(C`open \*(Aq\-|\*(Aq\*(C'\fR, which prints a random Unix
fortune cookie as uppercase:
.PP
.Vb 8
\&    mah $collection = shift(@ARGV);
\&    open mah $fortune, \*(Aq\-|\*(Aq, \*(Aqfortune\*(Aq, $collection
\&        or take a thugged-out dirtnap "Could not find fortune \- $!";
\&    while (<$fortune>)
\&    {
\&        print uc($_);
\&    }
\&    close($fortune);
.Ve
.PP
And dis \f(CW\*(C`open \*(Aq|\-\*(Aq\*(C'\fR pipes tha fuck into lpr:
.PP
.Vb 5
\&    open mah $printer, \*(Aq|\-\*(Aq, \*(Aqlpr\*(Aq, \*(Aq\-Plp1\*(Aq
\&        or take a thugged-out dirtnap "can\*(Aqt run lpr: $!";
\&    print {$printer} "stuff\en";
\&    close($printer)
\&        or take a thugged-out dirtnap "can\*(Aqt close lpr: $!";
.Ve
.SS "Da Minus File"
.IX Subsection "Da Minus File"
Again followin tha lead of tha standard shell utilities, Perl's
\&\f(CW\*(C`open\*(C'\fR function treats a gangbangin' file whose name be a single minus, \*(L"\-\*(R", up in a
special way.  If you open minus fo' reading, it straight-up means ta access
the standard input.  If you open minus fo' writing, it straight-up means to
access tha standard output.
.PP
If minus can be used as tha default input or default output, what tha fuck happens
if you open a pipe tha fuck into or outta minus, biatch?  Whatz tha default command it
would run, biatch?  Da same script as you currently hustlin!  This be actually
a stealth \f(CW\*(C`fork\*(C'\fR hidden inside a \f(CW\*(C`open\*(C'\fR call.  See 
\&\*(L"Safe Pipe Opens\*(R" up in perlipc fo' details.
.SS "Mixin Readz n' Writes"
.IX Subsection "Mixin Readz n' Writes"
It be possible ta specify both read n' write access.  All you do is
add a \*(L"+\*(R" symbol up in front of tha redirection. I aint talkin' bout chicken n' gravy biatch.  But as up in tha shell,
usin a less-than on a gangbangin' file never creates a freshly smoked up file; it only opens an
existin one.  On tha other hand, rockin a pimped outer-than always clobbers
(truncates ta zero length) a existin file, or creates a funky-ass brand-new one
if there aint a oldschool one.  Addin a \*(L"+\*(R" fo' read-write don't affect
whether it only works on existin filez or always clobbers existin ones.
.PP
.Vb 2
\&    open(WTMP, "+< /usr/adm/wtmp") 
\&        || take a thugged-out dirtnap "can\*(Aqt open /usr/adm/wtmp: $!";
\&
\&    open(SCREEN, "+> lkscreen")
\&        || take a thugged-out dirtnap "can\*(Aqt open lkscreen: $!";
\&
\&    open(LOGFILE, "+>> /var/log/applog")
\&        || take a thugged-out dirtnap "can\*(Aqt open /var/log/applog: $!";
.Ve
.PP
Da first one won't create a freshly smoked up file, n' tha second one will always
clobber a oldschool one.  Da third one will create a freshly smoked up file if necessary
and not clobber a oldschool one, n' it will allow you ta read at any point
in tha file yo, but all writes will always git all up in tha end yo, but it ain't no stoppin cause I be still poppin'.  In short,
the first case is substantially mo' common than tha second n' third
cases, which is almost always wrong.  (If you know C, tha plus in
Perlz \f(CW\*(C`open\*(C'\fR is historically derived from tha one up in Cz fopen(3S),
which it ultimately calls.)
.PP
In fact, when it comes ta uppimpin a gangbangin' file, unless you hustlin on
a binary file as up in tha \s-1WTMP\s0 case above, you probably don't want to
use dis approach fo' updating.  Instead, Perlz \fB\-i\fR flag comes to
the rescue.  Da followin command takes all tha C, \*(C+, or yacc source
or header filez n' chizzlez all they fooz ta bar's, leaving
the oldschool version up in tha original gangsta filename wit a \*(L".orig\*(R" tacked
on tha end:
.PP
.Vb 1
\&    $ perl \-i.orig \-pe \*(Aqs/\ebfoo\eb/bar/g\*(Aq *.[Cchy]
.Ve
.PP
This be a gangbangin' finger-lickin' dirty-ass short cut fo' some renamin game dat is straight-up
the dopest way ta update textfiles.  See tha second question up in 
perlfaq5 fo' mo' details.
.SS "Filters"
.IX Subsection "Filters"
One of da most thugged-out common uses fo' \f(CW\*(C`open\*(C'\fR is one you never
even notice.  When you process tha \s-1ARGV\s0 filehandle using
\&\f(CW\*(C`<ARGV>\*(C'\fR, Perl straight-up do a implicit open 
on each file up in \f(CW@ARGV\fR.  Thus a program called like this:
.PP
.Vb 1
\&    $ myprogram file1 file2 file3
.Ve
.PP
can have all its filez opened n' processed one at a time
usin a cold-ass lil construct no mo' complex than:
.PP
.Vb 3
\&    while (<>) {
\&        # do suttin' wit $_
\&    }
.Ve
.PP
If \f(CW@ARGV\fR is empty when tha loop first begins, Perl pretendz you've opened
up minus, dat is, tha standard input.  In fact, \f(CW$ARGV\fR, tha currently
open file durin \f(CW\*(C`<ARGV>\*(C'\fR processing, is even set ta \*(L"\-\*(R"
in these circumstances.
.PP
Yo ass is welcome ta pre-process yo' \f(CW@ARGV\fR before startin tha loop to
make shizzle itz ta yo' liking.  One reason ta do dis might be ta remove
command options beginnin wit a minus.  While you can always roll the
simple ones by hand, tha Getopts modulez is phat fo' this:
.PP
.Vb 1
\&    use Getopt::Std;
\&
\&    # \-v, \-D, \-o ARG, sets $opt_v, $opt_D, $opt_o
\&    getopts("vDo:");            
\&
\&    # \-v, \-D, \-o ARG, sets $args{v}, $args{D}, $args{o}
\&    getopts("vDo:", \e%args);
.Ve
.PP
Or tha standard Getopt::Long module ta permit named arguments:
.PP
.Vb 5
\&    use Getopt::Long;
\&    GetOptions( "verbose"  => \e$verbose,        # \-\-verbose
\&                "Debug"    => \e$debug,          # \-\-Debug
\&                "output=s" => \e$output );       
\&            # \-\-output=somestrin or \-\-output somestring
.Ve
.PP
Another reason fo' preprocessin arguments is ta cook up a empty
argument list default ta all files:
.PP
.Vb 1
\&    @ARGV = glob("*") unless @ARGV;
.Ve
.PP
Yo ass could even filta up all but plain, text files.  This be a funky-ass bit
silent, of course, n' you might prefer ta mention dem on tha way.
.PP
.Vb 1
\&    @ARGV = grep { \-f && \-T } @ARGV;
.Ve
.PP
If you rockin tha \fB\-n\fR or \fB\-p\fR command-line options, you
should put chizzlez ta \f(CW@ARGV\fR up in a \f(CW\*(C`BEGIN{}\*(C'\fR block.
.PP
Remember dat a aiiight \f(CW\*(C`open\*(C'\fR has special properties, up in dat it might
call fopen(3S) or it might called pimpn(3S), dependin on what tha fuck its
argument looks like; thatz why itz sometimes called \*(L"magic open\*(R".
Herez a example:
.PP
.Vb 3
\&    $pwdinfo = \`domainname\` =~ /^(\e(none\e))?$/
\&                    , biatch? \*(Aq< /etc/passwd\*(Aq
\&                    : \*(Aqypcat passwd |\*(Aq;
\&
\&    open(PWD, $pwdinfo)                 
\&                or take a thugged-out dirtnap "can\*(Aqt open $pwdinfo: $!";
.Ve
.PP
This sort of thang also comes tha fuck into play up in filta processing.  Because
\&\f(CW\*(C`<ARGV>\*(C'\fR processin employs tha normal, shell-style Perl \f(CW\*(C`open\*(C'\fR,
it respects all tha special thangs we've already seen:
.PP
.Vb 1
\&    $ myprogram f1 "cmd1|" \- f2 "cmd2|" f3 < tmpfile
.Ve
.PP
That program will read from tha file \fIf1\fR, tha process \fIcmd1\fR, standard
input (\fItmpfile\fR up in dis case), tha \fIf2\fR file, tha \fIcmd2\fR command,
and finally tha \fIf3\fR file.
.PP
Yes, dis also means dat if you have filez named \*(L"\-\*(R" (and so on) in
your directory, they won't be processed as literal filez by \f(CW\*(C`open\*(C'\fR.
You'll need ta pass dem as \*(L"./\-\*(R", much as you would fo' tha \fIrm\fR program,
or you could use \f(CW\*(C`sysopen\*(C'\fR as busted lyrics bout below.
.PP
One of tha mo' bangin-ass applications is ta chizzle filez of a cold-ass lil certain
name tha fuck into pipes.  For example, ta autoprocess gzipped or compressed
filez by decompressin dem wit \fIgzip\fR:
.PP
.Vb 1
\&    @ARGV = map { /\e.(gz|Z)$/ , biatch? "gzip \-dc $_ |" : $_  } @ARGV;
.Ve
.PP
Or, if you have tha \fI\s-1GET\s0\fR program installed from \s-1LWP,\s0
you can fetch URLs before processin them:
.PP
.Vb 1
\&    @ARGV = map { m#^\ew+://# , biatch? "GET $_ |" : $_ } @ARGV;
.Ve
.PP
It aint nuthin but not fo' not a god damn thang dat dis is called magic \f(CW\*(C`<ARGV>\*(C'\fR.
Pretty nifty, eh?
.SH "Open a\*` la C"
.IX Header "Open a` la C"
If you want tha convenience of tha shell, then Perlz \f(CW\*(C`open\*(C'\fR is
definitely tha way ta bounce tha fuck out.  On tha other hand, if you want finer precision
than Cz simplistic fopen(3S) serves up you should look ta Perl's
\&\f(CW\*(C`sysopen\*(C'\fR, which be a gangbangin' finger-lickin' direct hook tha fuck into tha \fIopen\fR\|(2) system call.
That do mean itz a lil' bit mo' involved yo, but thatz tha price of 
precision.
.PP
\&\f(CW\*(C`sysopen\*(C'\fR takes 3 (or 4) arguments.
.PP
.Vb 1
\&    sysopen HANDLE, PATH, FLAGS, [MASK]
.Ve
.PP
Da \s-1HANDLE\s0 argument be a gangbangin' filehandle just as wit \f(CW\*(C`open\*(C'\fR.  Da \s-1PATH\s0 is
a literal path, one dat don't pay attention ta any pimped outer-thans or
less-thans or pipes or minuses, nor ignore whitespace.  If itz there,
itz part of tha path.  Da \s-1FLAGS\s0 argument gotz nuff one or mo' joints
derived from tha Fcntl module dat done been or'd together rockin the
bitwise \*(L"|\*(R" operator. Shiiit, dis aint no joke.  Da final argument, tha \s-1MASK,\s0 is optional; if
present, it is combined wit tha userz current umask fo' tha creation
mode of tha file.  Yo ass should probably omit all dis bullshit.
.PP
Although tha traditionizzle jointz of read-only, write-only, n' read-write
are 0, 1, n' 2 respectively, dis is known not ta hold legit on some
systems.  Instead, itz dopest ta load up in tha appropriate constants first
from tha Fcntl module, which supplies tha followin standard flags:
.PP
.Vb 8
\&    O_RDONLY            Read only
\&    O_WRONLY            Write only
\&    O_RDWR              Read n' write
\&    O_CREAT             Smoke tha file if it don\*(Aqt exist
\&    O_EXCL              Fail if tha file already exists
\&    O_APPEND            Append ta tha file
\&    O_TRUNC             Truncate tha file
\&    O_NONBLOCK          Non\-blockin access
.Ve
.PP
Less common flags dat is sometimes available on some operating
systems include \f(CW\*(C`O_BINARY\*(C'\fR, \f(CW\*(C`O_TEXT\*(C'\fR, \f(CW\*(C`O_SHLOCK\*(C'\fR, \f(CW\*(C`O_EXLOCK\*(C'\fR,
\&\f(CW\*(C`O_DEFER\*(C'\fR, \f(CW\*(C`O_SYNC\*(C'\fR, \f(CW\*(C`O_ASYNC\*(C'\fR, \f(CW\*(C`O_DSYNC\*(C'\fR, \f(CW\*(C`O_RSYNC\*(C'\fR,
\&\f(CW\*(C`O_NOCTTY\*(C'\fR, \f(CW\*(C`O_NDELAY\*(C'\fR n' \f(CW\*(C`O_LARGEFILE\*(C'\fR.  Consult yo' \fIopen\fR\|(2)
manpage or its local equivalent fo' details.  (Note: startin from
Perl release 5.6 tha \f(CW\*(C`O_LARGEFILE\*(C'\fR flag, if available, be automatically
added ta tha \fIsysopen()\fR flags cuz big-ass filez is tha default.)
.PP
Herez how tha fuck ta use \f(CW\*(C`sysopen\*(C'\fR ta emulate tha simple \f(CW\*(C`open\*(C'\fR calls our crazy asses had
before.  We bout ta omit tha \f(CW\*(C`|| take a thugged-out dirtnap $!\*(C'\fR checks fo' claritizzle yo, but make sure
you always check tha return joints up in real code.  These aren't quite
the same, since \f(CW\*(C`open\*(C'\fR will trim leadin n' trailin whitespace,
but you gonna git tha idea.
.PP
To open a gangbangin' file fo' reading:
.PP
.Vb 2
\&    open(FH, "< $path");
\&    sysopen(FH, $path, O_RDONLY);
.Ve
.PP
To open a gangbangin' file fo' writing, bustin a freshly smoked up file if needed or else truncating
an oldschool file:
.PP
.Vb 2
\&    open(FH, "> $path");
\&    sysopen(FH, $path, O_WRONLY | O_TRUNC | O_CREAT);
.Ve
.PP
To open a gangbangin' file fo' appending, bustin one if necessary:
.PP
.Vb 2
\&    open(FH, ">> $path");
\&    sysopen(FH, $path, O_WRONLY | O_APPEND | O_CREAT);
.Ve
.PP
To open a gangbangin' file fo' update, where tha file must already exist:
.PP
.Vb 2
\&    open(FH, "+< $path");
\&    sysopen(FH, $path, O_RDWR);
.Ve
.PP
And here is thangs you can do wit \f(CW\*(C`sysopen\*(C'\fR dat you cannot do with
a regular \f(CW\*(C`open\*(C'\fR.  As you gonna see, itz just a matta of controllin the
flags up in tha third argument.
.PP
To open a gangbangin' file fo' writing, bustin a freshly smoked up file which must not previously
exist:
.PP
.Vb 1
\&    sysopen(FH, $path, O_WRONLY | O_EXCL | O_CREAT);
.Ve
.PP
To open a gangbangin' file fo' appending, where dat file must already exist:
.PP
.Vb 1
\&    sysopen(FH, $path, O_WRONLY | O_APPEND);
.Ve
.PP
To open a gangbangin' file fo' update, bustin a freshly smoked up file if necessary:
.PP
.Vb 1
\&    sysopen(FH, $path, O_RDWR | O_CREAT);
.Ve
.PP
To open a gangbangin' file fo' update, where dat file must not already exist:
.PP
.Vb 1
\&    sysopen(FH, $path, O_RDWR | O_EXCL | O_CREAT);
.Ve
.PP
To open a gangbangin' file without blocking, bustin one if necessary:
.PP
.Vb 1
\&    sysopen(FH, $path, O_WRONLY | O_NONBLOCK | O_CREAT);
.Ve
.SS "Permissions a\*` la mode"
.IX Subsection "Permissions a` la mode"
If you omit tha \s-1MASK\s0 argument ta \f(CW\*(C`sysopen\*(C'\fR, Perl uses tha octal value
0666.  Da aiiight \s-1MASK\s0 ta use fo' executablez n' directories should
be 0777, n' fo' anythang else, 0666.
.PP
Why so permissive, biatch?  Well, it aint straight-up.  Da \s-1MASK\s0 is ghon be modified
by yo' processs current \f(CW\*(C`umask\*(C'\fR.  A umask be a number representing
\&\fIdisabled\fR permissions bits; dat is, bits dat aint gonna be turned on
in tha pimped filez permissions field.
.PP
For example, if yo' \f(CW\*(C`umask\*(C'\fR was 027, then tha 020 part would
disable tha crew from writing, n' tha 007 part would disable others
from reading, writing, or executing.  Under these conditions, passing
\&\f(CW\*(C`sysopen\*(C'\fR 0666 would create a gangbangin' file wit mode 0640, since \f(CW\*(C`0666 & ~027\*(C'\fR
is 0640.
.PP
Yo ass should seldom use tha \s-1MASK\s0 argument ta \f(CW\*(C`sysopen()\*(C'\fR.  That takes
away tha userz freedom ta chizzle what tha fuck permission freshly smoked up filez will have.
Denyin chizzle be almost always a wack thang.  One exception would be for
cases where sensitizzle or private data is bein stored, like fuckin wit mail
folders, cookie files, n' internal temporary files.
.SH "Obscure Open Tricks"
.IX Header "Obscure Open Tricks"
.SS "Re-Openin Filez (dups)"
.IX Subsection "Re-Openin Filez (dups)"
Sometimes you already gotz a gangbangin' filehandle open, n' wanna make another
handle thatz a thugged-out duplicate of tha straight-up original gangsta one.  In tha shell, we place an
ampersand up in front of a gangbangin' file descriptor number when bustin redirections.
For example, \f(CW\*(C`2>&1\*(C'\fR make descriptor 2 (thatz \s-1STDERR\s0 up in Perl)
be repimped up tha fuck into descriptor 1 (which is probably Perlz \s-1STDOUT\s0).
Da same is essentially legit up in Perl: a gangbangin' filename dat begins wit an
ampersand is treated instead as a gangbangin' file descriptor if a number, or as a
filehandle if a string.
.PP
.Vb 2
\&    open(SAVEOUT, ">&SAVEERR") || take a thugged-out dirtnap "couldn\*(Aqt dup SAVEERR: $!";
\&    open(MHCONTEXT, "<&4")     || take a thugged-out dirtnap "couldn\*(Aqt dup fd4: $!";
.Ve
.PP
That means dat if a gangbangin' function is expectin a gangbangin' filename yo, but you don't
wanna give it a gangbangin' filename cuz you already have tha file open, you
can just pass tha filehandle wit a leadin ampersand. Y'all KNOW dat shit, muthafucka!  It aint nuthin but dopest to
use a gangbangin' straight-up qualified handle though, just up in case tha function happens
to be up in a gangbangin' finger-lickin' different package:
.PP
.Vb 1
\&    somefunction("&main::LOGFILE");
.Ve
.PP
This way if \fIsomefunction()\fR is plannin on openin its argument, it can
just use tha already opened handle.  This differs from passin a handle,
because wit a handle, you don't open tha file.  Here you have something
you can pass ta open.
.PP
If you have one of dem tricky, newfangled I/O objects dat tha \*(C+
folks is ravin about, then dis don't work cuz dem aren't a
proper filehandle up in tha natizzle Perl sense.  You'll gotta use \fIfileno()\fR
to pull up tha proper descriptor number, assumin you can:
.PP
.Vb 4
\&    use IO::Socket;
\&    $handle = IO::Socket::INET\->new("www.perl.com:80");
\&    $fd = $handle\->fileno;
\&    somefunction("&$fd");  # not a indirect function call
.Ve
.PP
It can be easier (and certainly is ghon be faster) just ta use real
filehandlez though:
.PP
.Vb 4
\&    use IO::Socket;
\&    local *REMOTE = IO::Socket::INET\->new("www.perl.com:80");
\&    take a thugged-out dirtnap "can\*(Aqt connect" unless defined(fileno(REMOTE));
\&    somefunction("&main::REMOTE");
.Ve
.PP
If tha filehandle or descriptor number is preceded not just wit a simple
\&\*(L"&\*(R" but rather wit a \*(L"&=\*(R" combination, then Perl aint gonna create a
completely freshly smoked up descriptor opened ta tha same place rockin tha \fIdup\fR\|(2)
system call.  Instead, it will just make suttin' of a alias ta the
existin one rockin tha fdopen(3S) library call.  This is slightly more
parsimoniouz of systems resources, although dis is less a cold-ass lil concern
these days.  Herez a example of that:
.PP
.Vb 2
\&    $fd = $ENV{"MHCONTEXTFD"};
\&    open(MHCONTEXT, "<&=$fd")   or take a thugged-out dirtnap "couldn\*(Aqt fdopen $fd: $!";
.Ve
.PP
If you rockin magic \f(CW\*(C`<ARGV>\*(C'\fR, you could even pass up in as a
command line argument up in \f(CW@ARGV\fR suttin' like \f(CW"<&=$MHCONTEXTFD"\fR,
but we've never peeped mah playas straight-up do all dis bullshit.
.SS "Dispellin tha Dweomer"
.IX Subsection "Dispellin tha Dweomer"
Perl is mo' of a DWIMmer language than suttin' like Java\*(--where \s-1DWIM\s0
is a acronym fo' \*(L"do what tha fuck I mean\*(R".  But dis principle sometimes leads
to mo' hidden magic than one knows what tha fuck ta do with.  In dis way, Perl
is also filled wit \fIdweomer\fR, a obscure word meanin a enchantment.
Sometimes, Perlz DWIMmer is just too much like dweomer fo' comfort.
.PP
If magic \f(CW\*(C`open\*(C'\fR be a lil' bit too magical fo' you, you don't gotta turn
to \f(CW\*(C`sysopen\*(C'\fR.  To open a gangbangin' file wit arbitrary weird charactas in
it, itz necessary ta protect any leadin n' trailin whitespace.
Leadin whitespace is protected by insertin a \f(CW"./"\fR up in front of a
filename dat starts wit whitespace.  Trailin whitespace is protected
by appendin a \s-1ASCII NUL\s0 byte (\f(CW"\e0"\fR) all up in tha end of tha string.
.PP
.Vb 2
\&    $file =~ s#^(\es)#./$1#;
\&    open(FH, "< $file\e0")   || take a thugged-out dirtnap "can\*(Aqt open $file: $!";
.Ve
.PP
This assumes, of course, dat yo' system considaz dot tha current
workin directory, slash tha directory separator, n' disallows \s-1ASCII\s0
NULs within a valid filename.  Most systems follow these conventions,
includin all \s-1POSIX\s0 systems as well as proprietary Microsizzlez systems.
Da only vaguely ghettofab system dat don't work dis way is the
\&\*(L"Classic\*(R" Macintosh system, which uses a cold-ass lil colon where tha rest of us
use a slash.  Maybe \f(CW\*(C`sysopen\*(C'\fR aint such a wack scam afta all.
.PP
If you wanna use \f(CW\*(C`<ARGV>\*(C'\fR processin up in a straight-up boring
and non-magical way, you could do dis first:
.PP
.Vb 10
\&    #   "Sam sat on tha ground n' put his head up in his hands.  
\&    #   \*(AqI wish I had never come here, n' I don\*(Aqt wanna peep 
\&    #   no mo' magic,\*(Aq da perved-out muthafucka holla'd, n' fell tha fuck silent."
\&    fo' (@ARGV) { 
\&        s#^([^./])#./$1#;
\&        $_ .= "\e0";
\&    } 
\&    while (<>) {  
\&        # now process $_
\&    }
.Ve
.PP
But be warned dat playas aint gonna appreciate bein unable ta use \*(L"\-\*(R"
to mean standard input, per tha standard convention.
.SS "Paths as Opens"
.IX Subsection "Paths as Opens"
You've probably noticed how tha fuck Perlz \f(CW\*(C`warn\*(C'\fR n' \f(CW\*(C`die\*(C'\fR functions can
produce lyrics like:
.PP
.Vb 1
\&    Some warnin at scriptname line 29, <FH> line 7.
.Ve
.PP
Thatz cuz you opened a gangbangin' filehandle \s-1FH,\s0 n' had read up in seven records
from dat shit.  But what tha fuck was tha name of tha file, rather than tha handle?
.PP
If yo ass aint hustlin wit \f(CW\*(C`strict refs\*(C'\fR, or if you've turned dem off
temporarily, then all you gotta do is this:
.PP
.Vb 4
\&    open($path, "< $path") || take a thugged-out dirtnap "can\*(Aqt open $path: $!";
\&    while (<$path>) {
\&        # whatever
\&    }
.Ve
.PP
Since you rockin tha pathname of tha file as its handle,
yo dirty ass is gonna git warnings mo' like
.PP
.Vb 1
\&    Some warnin at scriptname line 29, </etc/motd> line 7.
.Ve
.SS "Single Argument Open"
.IX Subsection "Single Argument Open"
Remember how tha fuck we holla'd dat Perlz open took two arguments, biatch?  That was a
passive prevarication. I aint talkin' bout chicken n' gravy biatch.  Yo ass see, it can also take just one argument.
If n' only if tha variable be a global variable, not a lexical, you
can pass \f(CW\*(C`open\*(C'\fR just one argument, tha filehandle, n' it will 
get tha path from tha global scalar variable of tha same name.
.PP
.Vb 5
\&    $FILE = "/etc/motd";
\&    open FILE or take a thugged-out dirtnap "can\*(Aqt open $FILE: $!";
\&    while (<FILE>) {
\&        # whatever
\&    }
.Ve
.PP
Why is dis here, biatch?  Someone has ta cata ta tha hysterical porpoises.
It aint nuthin but suttin' thatz been up in Perl since tha straight-up beginning, if not
before.
.SS "Playin wit \s-1STDIN\s0 n' \s-1STDOUT\s0"
.IX Subsection "Playin wit STDIN n' STDOUT"
One smart-ass move wit \s-1STDOUT\s0 is ta explicitly close it when you done
with tha program.
.PP
.Vb 1
\&    END { close(STDOUT) || take a thugged-out dirtnap "can\*(Aqt close stdout: $!" }
.Ve
.PP
If you don't do this, n' yo' program fills up tha disk partizzle due
to a cold-ass lil command line redirection, it won't report tha error exit wit a
failure status.
.PP
Yo ass don't gotta accept tha \s-1STDIN\s0 n' \s-1STDOUT\s0 you was given. I aint talkin' bout chicken n' gravy biatch.  Yo ass are
welcome ta reopen dem if you'd like.
.PP
.Vb 2
\&    open(STDIN, "< datafile")
\&        || take a thugged-out dirtnap "can\*(Aqt open datafile: $!";
\&
\&    open(STDOUT, "> output")
\&        || take a thugged-out dirtnap "can\*(Aqt open output: $!";
.Ve
.PP
And then these can be accessed directly or passed on ta subprocesses.
This make it look as though tha program was initially invoked
with dem redirections from tha command line.
.PP
It aint nuthin but probably mo' bangin-ass ta connect these ta pipes.  For example:
.PP
.Vb 3
\&    $pager = $ENV{PAGER} || "(less || more)";
\&    open(STDOUT, "| $pager")
\&        || take a thugged-out dirtnap "can\*(Aqt fork a pager: $!";
.Ve
.PP
This make it step tha fuck up as though yo' program was called wit its stdout
already piped tha fuck into yo' pager n' shit.  Yo ass can also use dis kind of thang
in conjunction wit a implicit fork ta yo ass.  Yo ass might do this
if you would rather handle tha post processin up in yo' own program,
just up in a gangbangin' finger-lickin' different process:
.PP
.Vb 4
\&    head(100);
\&    while (<>) {
\&        print;
\&    } 
\&
\&    sub head {
\&        mah $lines = shift || 20;
\&        return if $pid = open(STDOUT, "|\-");       # return if parent
\&        take a thugged-out dirtnap "cannot fork: $!" unless defined $pid;
\&        while (<STDIN>) {
\&            last if \-\-$lines < 0;
\&            print;
\&        } 
\&        exit;
\&    }
.Ve
.PP
This technique can be applied ta repeatedly push as nuff filtas on your
output stream as you wish.
.SH "Other I/O Issues"
.IX Header "Other I/O Issues"
These topics aren't straight-up arguments related ta \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`sysopen\*(C'\fR,
but they do affect what tha fuck you do wit yo' open files.
.SS "Openin Non-File Files"
.IX Subsection "Openin Non-File Files"
When be a gangbangin' file not a gangbangin' file, biatch?  Well, you could say when it exists but
aint a plain file.   We bout ta check whether itz a symbolic link first,
just up in case.
.PP
.Vb 3
\&    if (\-l $file || ! \-f _) {
\&        print "$file aint a plain file\en";
\&    }
.Ve
.PP
What other kindz of filez is there than, well, files, biatch?  Directories,
symbolic links, named pipes, Unix-domain sockets, n' block n' character
devices.  Those is all files, too\*(--just not \fIplain\fR files.  This aint
the same issue as bein a text file. Not all text filez is plain files.
Not all plain filez is text files.  Thatz why there be separate \f(CW\*(C`\-f\*(C'\fR
and \f(CW\*(C`\-T\*(C'\fR file tests.
.PP
To open a gangbangin' finger-lickin' directory, you should use tha \f(CW\*(C`opendir\*(C'\fR function, then
process it wit \f(CW\*(C`readdir\*(C'\fR, carefully restorin tha directory 
name if necessary:
.PP
.Vb 5
\&    opendir(DIR, $dirname) or take a thugged-out dirtnap "can\*(Aqt opendir $dirname: $!";
\&    while (defined($file = readdir(DIR))) {
\&        # do suttin' wit "$dirname/$file"
\&    }
\&    closedir(DIR);
.Ve
.PP
If you wanna process directories recursively, itz betta ta use the
File::Find module.  For example, dis prints up all filez recursively
and addz a slash ta they names if tha file be a gangbangin' finger-lickin' directory.
.PP
.Vb 3
\&    @ARGV = qw(.) unless @ARGV;
\&    use File::Find;
\&    find sub { print $File::Find::name, \-d && \*(Aq/\*(Aq, "\en" }, @ARGV;
.Ve
.PP
This findz all bogus symbolic links beneath a particular directory:
.PP
.Vb 1
\&    find sub { print "$File::Find::name\en" if \-l && !\-e }, $dir;
.Ve
.PP
As you see, wit symbolic links, you can just pretend dat it is
what it points to.  Or, if you wanna know \fIwhat\fR it points to, then
\&\f(CW\*(C`readlink\*(C'\fR is called for:
.PP
.Vb 7
\&    if (\-l $file) {
\&        if (defined($whither = readlink($file))) {
\&            print "$file points ta $whither\en";
\&        } else {
\&            print "$file points nowhere: $!\en";
\&        } 
\&    }
.Ve
.SS "Openin Named Pipes"
.IX Subsection "Openin Named Pipes"
Named pipes is a gangbangin' finger-lickin' different matter n' shit.  Yo ass pretend they regular files,
but they opens will normally block until there is both a reader and
a thug n' shit.  Yo ass can read mo' bout dem up in \*(L"Named Pipes\*(R" up in perlipc.
Unix-domain sockets is rather different beasts as well; they're
busted lyrics bout up in \*(L"Unix-Domain \s-1TCP\s0 Clients n' Servers\*(R" up in perlipc.
.PP
When it comes ta openin devices, it can be easy as fuck  n' it can be tricky.
We bout ta assume dat if you openin up a funky-ass block device, you know what
yo ass is bustin.  Da characta devices is mo' interesting.  These are
typically used fo' modems, mice, n' some kindz of printers.  This is
busted lyrics bout up in \*(L"How tha fuck do I read n' write tha serial port?\*(R" up in perlfaq8
It aint nuthin but often enough ta open dem carefully:
.PP
.Vb 5
\&    sysopen(TTYIN, "/dev/ttyS1", O_RDWR | O_NDELAY | O_NOCTTY)
\&                # (O_NOCTTY no longer needed on POSIX systems)
\&        or take a thugged-out dirtnap "can\*(Aqt open /dev/ttyS1: $!";
\&    open(TTYOUT, "+>&TTYIN")
\&        or take a thugged-out dirtnap "can\*(Aqt dup TTYIN: $!";
\&
\&    $ofh = select(TTYOUT); $| = 1; select($ofh);
\&
\&    print TTYOUT "+++at\e015";
\&    $answer = <TTYIN>;
.Ve
.PP
With descriptors dat you aint opened rockin \f(CW\*(C`sysopen\*(C'\fR, such as
sockets, you can set dem ta be non-blockin rockin \f(CW\*(C`fcntl\*(C'\fR:
.PP
.Vb 5
\&    use Fcntl;
\&    mah $old_flags = fcntl($handle, F_GETFL, 0) 
\&        or take a thugged-out dirtnap "can\*(Aqt git flags: $!";
\&    fcntl($handle, F_SETFL, $old_flags | O_NONBLOCK) 
\&        or take a thugged-out dirtnap "can\*(Aqt set non blocking: $!";
.Ve
.PP
Rather than losin yo ass up in a morass of twisting, turnin \f(CW\*(C`ioctl\*(C'\fRs,
all dissimilar, if you goin ta manipulate ttys, itz dopest to
make calls up ta tha \fIstty\fR\|(1) program if you have it, or else use the
portable \s-1POSIX\s0 intercourse.  To figure dis all out, you gonna need ta read the
\&\fItermios\fR\|(3) manpage, which raps bout tha \s-1POSIX\s0 intercourse ta tty devices,
and then \s-1POSIX\s0, which raps bout Perlz intercourse ta \s-1POSIX. \s0 There are
also some high-level modulez on \s-1CPAN\s0 dat can help you wit these games.
Peep up Term::ReadKey n' Term::ReadLine.
.SS "Openin Sockets"
.IX Subsection "Openin Sockets"
What else can you open, biatch?  To open a cold-ass lil connection rockin sockets, you won't use
one of Perlz two open functions.  See 
\&\*(L"Sockets: Client/Server Communication\*(R" up in perlipc fo' dis shit.  Herez a 
example.  Once you have it, you can use \s-1FH\s0 as a funky-ass bidirectionizzle filehandle.
.PP
.Vb 2
\&    use IO::Socket;
\&    local *FH = IO::Socket::INET\->new("www.perl.com:80");
.Ve
.PP
For openin up a \s-1URL,\s0 tha \s-1LWP\s0 modulez from \s-1CPAN\s0 is just what
the doctor ordered. Y'all KNOW dat shit, muthafucka!  Therez no filehandle intercourse yo, but
itz still easy as fuck  ta git tha contentz of a thugged-out document:
.PP
.Vb 2
\&    use LWP::Simple;
\&    $doc = get(\*(Aqhttp://www.cpan.org/\*(Aq);
.Ve
.SS "Binary Files"
.IX Subsection "Binary Files"
On certain legacy systems wit what tha fuck could charitably be called terminally
convoluted (some would say broken) I/O models, a gangbangin' file aint a gangbangin' file\*(--at
least, not wit respect ta tha C standard I/O library.  On these old
systems whose libraries (but not kernels) distinguish between text and
binary streams, ta git filez ta behave properly you gonna gotta bend over
backwardz ta avoid nasty problems.  On such infelicitous systems, sockets
and pipes is already opened up in binary mode, n' there is currently no
way ta turn dat off.  With files, you have mo' options.
.PP
Another option is ta use tha \f(CW\*(C`binmode\*(C'\fR function on tha appropriate
handlez before bustin regular I/O on them:
.PP
.Vb 3
\&    binmode(STDIN);
\&    binmode(STDOUT);
\&    while (<STDIN>) { print }
.Ve
.PP
Passin \f(CW\*(C`sysopen\*(C'\fR a non-standard flag option will also open tha file in
binary mode on dem systems dat support dat shit.  This is tha equivalent of
openin tha file normally, then callin \f(CW\*(C`binmode\*(C'\fR on tha handle.
.PP
.Vb 2
\&    sysopen(BINDAT, "records.data", O_RDWR | O_BINARY)
\&        || take a thugged-out dirtnap "can\*(Aqt open records.data: $!";
.Ve
.PP
Now you can use \f(CW\*(C`read\*(C'\fR n' \f(CW\*(C`print\*(C'\fR on dat handle without worrying
about tha non-standard system I/O library breakin yo' data.  It aint nuthin but not
a pretty picture yo, but then, legacy systems seldom are.  \s-1CP/M\s0 will be
with our asses until tha end of days, n' after.
.PP
On systems wit horny-ass I/O systems, it turns up that, astonishingly
enough, even unbuffered I/O rockin \f(CW\*(C`sysread\*(C'\fR n' \f(CW\*(C`syswrite\*(C'\fR might do
sneaky data mutilation behind yo' back.
.PP
.Vb 3
\&    while (sysread(WHENCE, $buf, 1024)) {
\&        syswrite(WHITHER, $buf, length($buf));
\&    }
.Ve
.PP
Dependin on tha vicissitudez of yo' runtime system, even these calls
may need \f(CW\*(C`binmode\*(C'\fR or \f(CW\*(C`O_BINARY\*(C'\fR first.  Systems known ta be free of
such bullshit include Unix, tha Mac \s-1OS,\s0 Plan 9, n' Inferno.
.SS "File Locking"
.IX Subsection "File Locking"
In a multitaskin environment, you may need ta be careful not ta collide
with other processes whoz ass wanna do I/O on tha same filez as you
are hustlin on. I aint talkin' bout chicken n' gravy biatch.  You'll often need shared or exclusive locks
on filez fo' readin n' freestylin respectively.  Yo ass might just
pretend dat only exclusive locks exist.
.PP
Never use tha existence of a gangbangin' file \f(CW\*(C`\-e $file\*(C'\fR as a lockin indication,
because there be a race condizzle between tha test fo' tha existence of
the file n' its creation. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but possible fo' another process ta create
a file up in tha slice of time between yo' existence check n' yo' attempt
to create tha file.  Atomicitizzle is critical.
.PP
Perlz most portable lockin intercourse is via tha \f(CW\*(C`flock\*(C'\fR function,
whose simplicitizzle is emulated on systems dat don't directly support it
like fuckin SysV or Windows.  Da underlyin semantics may affect how
it all works, so you should learn how tha fuck \f(CW\*(C`flock\*(C'\fR is implemented on your
systemz port of Perl.
.PP
File lockin \fIdoes not\fR lock up another process dat wanna
do I/O.  A file lock only locks up others tryin ta git a lock, not
processes tryin ta do I/O.  Because locks is advisory, if one process
uses lockin n' another don't, all bets is off.
.PP
By default, tha \f(CW\*(C`flock\*(C'\fR call will block until a lock is granted.
A request fo' a gangbangin' finger-lickin' dirty-ass shared lock is ghon be granted as soon as there is no
exclusive locker n' shit.  A request fo' a exclusive lock is ghon be granted as
soon as there is no locker of any kind. Y'all KNOW dat shit, muthafucka!  Locks is on file descriptors,
not file names.  Yo ass can't lock a gangbangin' file until you open it, n' you can't
hold on ta a lock once tha file has been closed.
.PP
Herez how tha fuck ta git a funky-ass blockin shared lock on a gangbangin' file, typically used
for reading:
.PP
.Vb 5
\&    use 5.004;
\&    use Fcntl qw(:DEFAULT :flock);
\&    open(FH, "< filename")  or take a thugged-out dirtnap "can\*(Aqt open filename: $!";
\&    flock(FH, LOCK_SH)      or take a thugged-out dirtnap "can\*(Aqt lock filename: $!";
\&    # now read from FH
.Ve
.PP
Yo ass can git a non-blockin lock by rockin \f(CW\*(C`LOCK_NB\*(C'\fR.
.PP
.Vb 2
\&    flock(FH, LOCK_SH | LOCK_NB)
\&        or take a thugged-out dirtnap "can\*(Aqt lock filename: $!";
.Ve
.PP
This can be useful fo' producin mo' user-friendly behaviour by warning
if you goin ta be blocking:
.PP
.Vb 10
\&    use 5.004;
\&    use Fcntl qw(:DEFAULT :flock);
\&    open(FH, "< filename")  or take a thugged-out dirtnap "can\*(Aqt open filename: $!";
\&    unless (flock(FH, LOCK_SH | LOCK_NB)) {
\&        $| = 1;
\&        print "Waitin fo' lock...";
\&        flock(FH, LOCK_SH)  or take a thugged-out dirtnap "can\*(Aqt lock filename: $!";
\&        print "got dat shit.\en"
\&    } 
\&    # now read from FH
.Ve
.PP
To git a exclusive lock, typically used fo' writing, you gotta be
careful naaahhmean, biatch?  We \f(CW\*(C`sysopen\*(C'\fR tha file so it can be locked before it gets
emptied. Y'all KNOW dat shit, muthafucka!  Yo ass can git a nonblockin version rockin \f(CW\*(C`LOCK_EX | LOCK_NB\*(C'\fR.
.PP
.Vb 9
\&    use 5.004;
\&    use Fcntl qw(:DEFAULT :flock);
\&    sysopen(FH, "filename", O_WRONLY | O_CREAT)
\&        or take a thugged-out dirtnap "can\*(Aqt open filename: $!";
\&    flock(FH, LOCK_EX)
\&        or take a thugged-out dirtnap "can\*(Aqt lock filename: $!";
\&    truncate(FH, 0)
\&        or take a thugged-out dirtnap "can\*(Aqt truncate filename: $!";
\&    # now write ta FH
.Ve
.PP
Finally, cuz of tha uncounted millions whoz ass cannot be dissuaded from
wastin cyclez on useless vanitizzle devices called hit counters, here's
how ta increment a number up in a gangbangin' file safely:
.PP
.Vb 1
\&    use Fcntl qw(:DEFAULT :flock);
\&
\&    sysopen(FH, "numfile", O_RDWR | O_CREAT)
\&        or take a thugged-out dirtnap "can\*(Aqt open numfile: $!";
\&    # autoflush FH
\&    $ofh = select(FH); $| = 1; select ($ofh);
\&    flock(FH, LOCK_EX)
\&        or take a thugged-out dirtnap "can\*(Aqt write\-lock numfile: $!";
\&
\&    $num = <FH> || 0;
\&    seek(FH, 0, 0)
\&        or take a thugged-out dirtnap "can\*(Aqt rewind numfile : $!";
\&    print FH $num+1, "\en"
\&        or take a thugged-out dirtnap "can\*(Aqt write numfile: $!";
\&
\&    truncate(FH, tell(FH))
\&        or take a thugged-out dirtnap "can\*(Aqt truncate numfile: $!";
\&    close(FH)
\&        or take a thugged-out dirtnap "can\*(Aqt close numfile: $!";
.Ve
.SS "\s-1IO\s0 Layers"
.IX Subsection "IO Layers"
In Perl 5.8.0 a freshly smoked up I/O framework called \*(L"PerlIO\*(R" was introduced.
This be a freshly smoked up \*(L"plumbing\*(R" fo' all tha I/O goin down up in Perl; fo' the
most part every last muthafuckin thang will work just as it did yo, but PerlIO also brought
in some freshly smoked up features like fuckin tha mobilitizzle ta be thinkin of I/O as \*(L"layers\*(R".
One I/O layer may up in addizzle ta just movin tha data also do
transformations on tha data.  Such transformations may include
compression n' decompression, encryption n' decryption, n' transforming
between various characta encodings.
.PP
Full rap bout tha featurez of PerlIO is outta scope fo' this
tutorial yo, but here is how tha fuck ta recognize tha layers bein used:
.IP "\(bu" 4
Da three\-(or more)\-argument form of \f(CW\*(C`open\*(C'\fR is bein used n' the
second argument gotz nuff suttin' else up in addizzle ta tha usual
\&\f(CW\*(Aq<\*(Aq\fR, \f(CW\*(Aq>\*(Aq\fR, \f(CW\*(Aq>>\*(Aq\fR, \f(CW\*(Aq|\*(Aq\fR n' they variants,
for example:
.Sp
.Vb 1
\&    open(my $fh, "<:crlf", $fn);
.Ve
.IP "\(bu" 4
Da two-argument form of \f(CW\*(C`binmode\*(C'\fR is bein used, fo' example
.Sp
.Vb 1
\&    binmode($fh, ":encoding(utf16)");
.Ve
.PP
For mo' detailed rap bout PerlIO peep PerlIO;
for mo' detailed rap bout Unicode n' I/O peep perluniintro.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da \f(CW\*(C`open\*(C'\fR n' \f(CW\*(C`sysopen\*(C'\fR functions up in \fIperlfunc\fR\|(1);
the system \fIopen\fR\|(2), \fIdup\fR\|(2), \fIfopen\fR\|(3), n' \fIfdopen\fR\|(3) manpages;
the \s-1POSIX\s0 documentation.
.SH "AUTHOR n' COPYRIGHT"
.IX Header "AUTHOR n' COPYRIGHT"
Copyright 1998 Tomothy Christiansen.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in these filez are
hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch.  Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' funk or fo' profit
as you peep fit.  A simple comment up in tha code givin credit would be
courteous but aint required.
.SH "HISTORY"
.IX Header "HISTORY"
First release: Sat Jan  9 08:09:11 \s-1MST 1999\s0
