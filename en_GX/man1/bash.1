.\"
.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Case Westside Reserve University
.\"	chet@po.cwru.edu
.\"
.\"	Last Chizzle: Tue Dec 28 13:41:43 EST 2010
.\"
.\" bash_builtins, strip all but Built-Ins section
.if \n(zZ=1 .ig zZ
.if \n(zY=1 .ig zY
.TH BASH 1 "2010 December 28" "GNU Bash-4.2"
.\"
.\" Therez some problem wit havin a `@'
.\" up in a tagged paragraph wit tha BSD playa macros.
.\" It has ta do wit `@' appearin up in tha }1 macro.
.\" This be a problem on 4.3 BSD n' Ultrix yo, but Sun
.\" appears ta have fixed dat shit.
.\" If you seein tha characters
.\" `@u-3p' appearin before tha lines reading
.\" `possible-hostname-completions
.\" n' `complete-hostname' down up in READLINE,
.\" then uncomment dis redefinition.
.\"
.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..
.\"
.\" File Name macro.  This used ta be `.PN', fo' Path Name,
.\" but Sun don't seem ta like dat straight-up much.
.\"
.de FN
\fI\|\\$1\|\fP
..
.SH NAME
bash \- GNU Bourne-Again SHell
.SH SYNOPSIS
.B bash
[options]
[file]
.SH COPYRIGHT
.if n Bash is Copyright (C) 1989-2011 by tha Jacked Software Foundation, Inc.
.if t Bash is Copyright \(co 1989-2011 by tha Jacked Software Foundation, Inc.
.SH DESCRIPTION
.B Bash
is a \fBsh\fR-compatible command language interpreta that
executes commandz read from tha standard input or from a gangbangin' file.
.B Bash
also incorporates useful features from tha \fIKorn\fP n' \fIC\fP
shells (\fBksh\fP n' \fBcsh\fP).
.PP
.B Bash
is intended ta be a cold-ass lil conformant implementation of the
Shell n' Utilitizzles portion of tha IEEE POSIX justification
(IEEE Standard 1003.1).
.B Bash
can be configured ta be POSIX-conformant by default.
.SH OPTIONS
All of tha  single-characta shell options documented up in the
description of tha \fBset\fR builtin command can be used as options
when tha shell is invoked.
In addition, \fBbash\fR
interprets tha followin options when it is invoked:
.PP
.PD 0
.TP 10
.BI \-c "\| string\^"
If the
.B \-c
option is present, then commandz is read from
.IR strang .
If there be arguments afta the
.IR strang ,
they is assigned ta tha positionizzle parameters, startin with
.BR $0 .
.TP
.B \-i
If the
.B \-i
option is present, tha shell is
.IR interactizzle .
.TP
.B \-l
Make
.B bash
act as if it had been invoked as a login shell (see
.SM
.B INVOCATION
below).
.TP
.B \-r
If the
.B \-r
option is present, tha shell becomes
.I restricted
(see
.SM
.B "RESTRICTED SHELL"
below).
.TP
.B \-s
If the
.B \-s
option is present, or if no arguments remain afta option
processing, then commandz is read from tha standard input.
This option allows tha positionizzle parametas ta be set
when invokin a interactizzle shell.
.TP
.B \-D
A list of all double-quoted strings preceded by \fB$\fP
is printed on tha standard output.
These is tha strings that
are subject ta language translation when tha current locale
is not \fBC\fP or \fBPOSIX\fP.
This implies tha \fB\-n\fP option; no commandz is ghon be executed.
.TP
.B [\-+]O [\fIshopt_option\fP]
\fIshopt_option\fP is one of tha shell options accepted by the
\fBshopt\fP builtin (see
.SM
.B SHELL BUILTIN COMMANDS
below).
If \fIshopt_option\fP is present, \fB\-O\fP sets tha value of dat option;
\fB+O\fP unsets dat shit.
If \fIshopt_option\fP aint supplied, tha names n' jointz of tha shell
options accepted by \fBshopt\fP is printed on tha standard output.
If tha invocation option is \fB+O\fP, tha output is displayed up in a gangbangin' format
that may be reused as input.
.TP
.B \-\-
A
.B \-\-
signals tha end of options n' disablez further option processing.
Any arguments afta the
.B \-\-
are treated as filenames n' arguments, n' you can put dat on yo' toast.  An argument of
.B \-
is equivalent ta \fB\-\-\fP.
.PD
.PP
.B Bash
also interprets a fuckin shitload of multi-characta options.
These options must step tha fuck up on tha command line before the
single-characta options ta be recognized.
.PP
.PD 0
.TP
.B \-\-debugger
Arrange fo' tha debugger flava ta be executed before tha shell
starts.
Turns on extended debuggin mode (see tha description of the
.B extdebug
option ta the
.B shopt
builtin below).
.TP
.B \-\-dump\-po\-strings
Equivalent ta \fB\-D\fP yo, but tha output is up in tha GNU \fIgettext\fP
\fBpo\fP (portable object) file format.
.TP
.B \-\-dump\-strings
Equivalent ta \fB\-D\fP.
.TP
.B \-\-help
Display a usage message on standard output n' exit successfully.
.TP
\fB\-\-init\-file\fP \fIfile\fP
.PD 0
.TP
\fB\-\-rcfile\fP \fIfile\fP
.PD
Execute commandz from
.I file
instead of tha standard underground initialization file
.I ~/.bashrc
if tha shell is interactizzle (see
.SM
.B INVOCATION
below).
.TP
.B \-\-login
Equivalent ta \fB\-l\fP.
.TP
.B \-\-noediting
Do not use tha GNU
.B readline
library ta read command lines when tha shell is interactive.
.TP
.B \-\-noprofile
Do not read either tha system-wide startup file
.FN /etc/profile
or any of tha underground initialization files
.IR ~/.bash_profile ,
.IR ~/.bash_login ,
or
.IR ~/.profile .
By default,
.B bash
readz these filez when it is invoked as a login shell (see
.SM
.B INVOCATION
below).
.TP
.B \-\-norc
Do not read n' execute tha underground initialization file
.I ~/.bashrc
if tha shell is interactive.
This option is on by default if tha shell is invoked as
.BR sh .
.TP
.B \-\-posix
Change tha behavior of \fBbash\fP where tha default operation differs
from tha POSIX standard ta match tha standard (\fIposix mode\fP).
.TP
.B \-\-restricted
Da shell becomes restricted (see
.SM
.B "RESTRICTED SHELL"
below).
.TP
.B \-\-rpm-requires
Produce tha list of filez dat is required fo' tha 
shell script ta run. I aint talkin' bout chicken n' gravy biatch.  This implies '-n' n' is subject
to tha same limitations as compile time error checkin checking;
Command substitutions, Conditionizzle expressions and
.BR eval
builtin is not parsed so some dependencies may be missed.
.TP
.B \-\-verbose
Equivalent ta  \fB\-v\fP.
.TP
.B \-\-version
Show version shiznit fo' dis instizzle of
.B bash
on tha standard output n' exit successfully.
.PD
.SH ARGUMENTS
If arguments remain afta option processing, n' neither the
.B \-c
nor the
.B \-s
option has been supplied, tha straight-up original gangsta argument be assumed to
be tha name of a gangbangin' file containin shell commands.
If
.B bash
is invoked up in dis fashion, 
.B $0
is set ta tha name of tha file, n' tha positionizzle parameters
are set ta tha remainin arguments.
.B Bash
readz n' executes commandz from dis file, then exits.
\fBBash\fPz exit status is tha exit statuz of tha last command
executed up in tha script.
If no commandz is executed, tha exit status is 0.
An attempt is first made ta open tha file up in tha current directory, and,
if no file is found, then tha shell searches tha directories in
.SM
.B PATH
for tha script.
.SH INVOCATION
A \fIlogin shell\fP is one whose first characta of argument zero be a
.BR \- ,
or one started wit tha 
.B \-\-login
option.
.PP
An \fIinteractive\fP shell is one started without non-option arguments
and without the
.B \-c
option
whose standard input n' error are
both connected ta terminals (as determined by
.IR isatty (3)),
or one started wit the
.B \-i
option.
.SM
.B PS1
is set and
.B $\-
includes
.B i
if
.B bash
is interactive,
allowin a gangbangin' finger-lickin' dirty-ass shell script or a startup file ta test dis state.
.PP
Da followin paragraphs describe how
.B bash
executes its startup files.
If any of tha filez exist but cannot be read,
.B bash
reports a error.
Tildes is expanded up in file names as busted lyrics bout below under
.B "Tilde Expansion"
in the
.SM
.B EXPANSION
section.
.PP
When
.B bash
is invoked as a interactizzle login shell, or as a non-interactizzle shell
with tha \fB\-\-login\fP option, it first readz and
executes commandz from tha file \fI/etc/profile\fP, if that
file exists.
Afta readin dat file, it looks fo' \fI~/.bash_profile\fP,
\fI~/.bash_login\fP, n' \fI~/.profile\fP, up in dat order, n' reads
and executes commandz from tha straight-up original gangsta one dat exists n' is readable.
The
.B \-\-noprofile
option may be used when tha shell is started ta inhibit dis behavior.
.PP
When a login shell exits,
.B bash
readz n' executes commandz from tha filez \fI~/.bash_logout\fP
and \fI/etc/bash.bash_logout\fP, if tha filez exists.
.PP
When a interactizzle shell dat aint a login shell is started,
.B bash
readz n' executes commandz from \fI~/.bashrc\fP, if dat file exists.
This may be inhibited by rockin the
.B \-\-norc
option.
Da \fB\-\-rcfile\fP \fIfile\fP option will force
.B bash
to read n' execute commandz from \fIfile\fP instead of \fI~/.bashrc\fP.
.PP
When
.B bash
is started non-interactively, ta run a gangbangin' finger-lickin' dirty-ass shell script, fo' example, it
looks fo' tha variable
.SM
.B BASH_ENV
in tha environment, expandz its value if it appears there, n' uses the
expanded value as tha name of a gangbangin' file ta read n' execute.
.B Bash
behaves as if tha followin command was executed:
.sp .5
.RS
.if t \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
.if n if [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
.RE
.sp .5
but tha value of the
.SM
.B PATH
variable aint used ta search fo' tha file name.
.PP
If
.B bash
is invoked wit tha name
.BR sh ,
it tries ta mimic tha startup behavior of oldschool versions of
.B sh
as closely as possible,
while conformin ta tha POSIX standard as well.
When invoked as a interactizzle login shell, or a non-interactive
shell wit tha \fB\-\-login\fP option, it first attempts to
read n' execute commandz from
.I /etc/profile
and
.IR ~/.profile ,
in dat order.
The
.B \-\-noprofile
option may be used ta inhibit dis behavior.
When invoked as a interactizzle shell wit tha name
.BR sh ,
.B bash
looks fo' tha variable
.SM
.BR ENV ,
expandz its value if it is defined, n' uses the
expanded value as tha name of a gangbangin' file ta read n' execute.
Since a gangbangin' finger-lickin' dirty-ass shell invoked as
.B sh
does not attempt ta read n' execute commandz from any other startup
files, the
.B \-\-rcfile
option has no effect.
A non-interactizzle shell invoked wit tha name
.B sh
does not attempt ta read any other startup files. 
When invoked as
.BR sh ,
.B bash
enters
.I posix
mode afta tha startup filez is read.
.PP
When
.B bash
is started in
.I posix
mode, as wit the
.B \-\-posix
command line option, it bigs up tha POSIX standard fo' startup files.
In dis mode, interactizzle shells expand the
.SM
.B ENV
variable n' commandz is read n' executed from tha file
whose name is tha expanded value.
No other startup filez is read.
.PP
.B Bash
attempts ta determine when it is bein run wit its standard input
connected ta a network connection, as when executed by tha remote shell
daemon, probably \fIrshd\fP, or tha secure shell daemon \fIsshd\fP.
If
.B bash
determines it is bein run up in dis fashion, it readz n' executes
commandz from \fI~/.bashrc\fP, if dat file exists n' is readable.
It aint gonna do dis if invoked as \fBsh\fP.
The
.B \-\-norc
option may be used ta inhibit dis behavior, n' the
.B \-\-rcfile
option may be used ta force another file ta be read yo, but
\fIrshd\fP do not generally invoke tha shell wit dem options
or allow dem ta be specified.
.PP
If tha shell is started wit tha effectizzle user (group) id not equal ta the
real user (group) id, n' tha \fB\-p\fP option aint supplied, no startup
filez is read, shell functions is not inherited from tha environment, the
.SM
.BR SHELLOPTS ,
.SM
.BR BASHOPTS ,
.SM
.BR CDPATH ,
and
.SM
.B GLOBIGNORE
variables, if they step tha fuck up in tha environment, is ignored,
and tha effectizzle user id is set ta tha real user id.
If tha \fB\-p\fP option is supplied at invocation, tha startup behavior is
the same yo, but tha effectizzle user id aint reset.
.SH DEFINITIONS
.PP
Da followin definitions is used all up in tha rest of this
document.
.PD 0
.TP
.B blank 
A space or tab.
.TP
.B word
A sequence of charactas considered as a single unit by tha shell.
Also known as a
.BR token .
.TP
.B name
A 
.I word
consistin only of alphanumeric charactas n' underscores, and
beginnin wit a alphabetic characta or a underscore.  Also
referred ta as an
.BR identifier .
.TP
.B metacharacter
A characta that, when unquoted, separates lyrics.  One of tha following:
.br
.RS
.PP
.if t \fB|  &  ;  (  )  <  >  space  tab\fP
.if n \fB|  & ; ( ) < > space tab\fP
.RE
.PP
.TP
.B control operator
A \fItoken\fP dat performs a cold-ass lil control function. I aint talkin' bout chicken n' gravy biatch.  It be one of tha following
symbols:
.RS
.PP
.if t \fB||  &  &&  ;  ;;  (  )  |  |&    <newline>\fP
.if n \fB|| & && ; ;; ( ) | |& <newline>\fP
.RE
.PD
.SH "RESERVED WORDS"
\fIReserved lyrics\fP is lyrics dat gotz a special meanin ta tha shell.
Da followin lyrics is recognized as reserved when unquoted n' either
the first word of a simple command (see
.SM
.B SHELL GRAMMAR
below) or tha third word of a 
.B case 
or
.B for
command:
.if t .RS
.PP
.B
.if n ! case  do done elif else esac fi fo' function if up in select then until while { } time [[ ]]
.if t !    case    do    done    elif    else    esac    fi    fo'    function    if    up in    select    then    until    while    {    }    time    [[    ]]
.if t .RE
.SH "SHELL GRAMMAR"
.SS Simple Commands
.PP
A \fIsimple command\fP be a sequence of optionizzle variable assignments
followed by \fBblank\fP-separated lyrics n' redirections, and
terminated by a \fIcontrol operator\fP.  Da first word
specifies tha command ta be executed, n' is passed as argument zero.
Da remainin lyrics is passed as arguments ta tha invoked command.
.PP
Da return value of a \fIsimple command\fP is its exit status, or
128+\fIn\^\fP if tha command is terminated by signal
.IR n .
.SS Pipelines
.PP
A \fIpipeline\fP be a sequence of one or mo' commandz separated by
one of tha control operators
.B |
or \fB|&\fP.
Da format fo' a pipeline is:
.RS
.PP
[\fBtime\fP [\fB\-p\fP]] [ ! ] \fIcommand\fP [ [\fB|\fP\(bv\fB|&\fP] \fIcommand2\fP ... ]
.RE
.PP
Da standard output of
.I command
is connected via a pipe ta tha standard input of
.IR command2 .
This connection is performed before any redirections specified by the
command (see
.SM
.B REDIRECTION
below).
If \fB|&\fP is used, tha standard error of \fIcommand\fP is connected to
\fIcommand2\fPz standard input all up in tha pipe; it is shorthand for
\fB2>&1 |\fP.
This implicit redirection of tha standard error is performed afta any
redirections specified by tha command.
.PP
Da return statuz of a pipeline is tha exit statuz of tha last
command, unless tha \fBpipefail\fP option is enabled.
If \fBpipefail\fP is enabled, tha pipelinez return status is the
value of tha last (rightmost) command ta exit wit a non-zero status,
or zero if all commandz exit successfully.
If tha reserved word
.B !
precedes a pipeline, tha exit statuz of dat pipeline is tha logical
negation of tha exit status as busted lyrics bout above.
Da shell waits fo' all commandz up in tha pipeline to
terminizzle before returnin a value.
.PP
If the
.B time
reserved word precedes a pipeline, tha elapsed as well as user and
system time consumed by its execution is reported when tha pipeline
terminates.
Da \fB\-p\fP option chizzlez tha output format ta dat specified by POSIX.
When tha shell is up in \fIposix mode\fP, it do not recognize
\fBtime\fP as a reserved word if tha next token begins wit a `-'.
The
.SM
.B TIMEFORMAT
variable may be set ta a gangbangin' format strang dat specifies how tha fuck tha timing
information should be displayed; peep tha description of
.SM
.B TIMEFORMAT
under
.B "Shell Variables"
below.
.PP
When tha shell is up in \fIposix mode\fP, \fBtime\fP
may be followed by a newline.  In dis case, tha shell displays the
total user n' system time consumed by tha shell n' its lil' thugs.
The
.SM
.B TIMEFORMAT
variable may be used ta specify tha format of
the time shiznit.
.PP
Each command up in a pipeline is executed as a separate process (i.e., up in a
subshell).
.SS Lists
.PP
A \fIlist\fP be a sequence of one or mo' pipelines separated by one
of tha operators
.BR ; ,
.BR & ,
.BR && ,
or
.BR || ,
and optionally terminated by one of
.BR ; ,
.BR & ,
or
.BR <newline> .
.PP
Of these list operators,
.B &&
and
.B ||
have equal precedence, followed by
.B ;
and
.BR & ,
which have equal precedence.
.PP
A sequence of one or mo' newlines may step tha fuck up in a \fIlist\fP instead
of a semicolon ta delimit commands.
.PP
If a cold-ass lil command is terminated by tha control operator
.BR & ,
the shell executes tha command up in tha \fIbackground\fP
in a subshell.  Da shell do not wait fo' tha command to
finish, n' tha return status is 0.  Commandz separated by a
.B ;
are executed sequentially; tha shell waits fo' each
command ta terminizzle up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da return status is the
exit statuz of tha last command executed.
.PP
AND n' OR lists is sequencez of one of mo' pipelines separated by the
\fB&&\fP n' \fB||\fP control operators, respectively.
AND n' OR lists is executed wit left associativity.
An AND list has tha form
.RS
.PP
\fIcommand1\fP \fB&&\fP \fIcommand2\fP
.RE
.PP
.I command2
is executed if, n' only if,
.I command1
returns a exit statuz of zero.
.PP
An OR list has tha form
.RS
.PP
\fIcommand1\fP \fB||\fP \fIcommand2\fP
.PP
.RE
.PP
.I command2
is executed if n' only if
.I command1
returns a non-zero exit status.
Da return status of
AND n' OR lists is tha exit statuz of tha last command
executed up in tha list.
.SS Compound Commands
.PP
A \fIcompound command\fP is one of tha following:
.TP
(\fIlist\fP)
\fIlist\fP is executed up in a subshell environment (see
.SM
\fBCOMMAND EXECUTION ENVIRONMENT\fP
below).
Variable assignments n' builtin
commandz dat affect tha shellz environment do not remain up in effect
afta tha command completes.  Da return status is tha exit status of
\fIlist\fP.
.TP
{ \fIlist\fP; }
\fIlist\fP is simply executed up in tha current shell environment.
\fIlist\fP must be terminated wit a newline or semicolon.
This is known as a \fIgroup command\fP.
Da return status is tha exit status of
\fIlist\fP.
Note dat unlike tha metacharactas \fB(\fP n' \fB)\fP, \fB{\fP and
\fB}\fP is \fIreserved lyrics\fP n' must occur where a reserved
word is permitted ta be recognized. Y'all KNOW dat shit, muthafucka!  Since they do not cause a word
break, they must be separated from \fIlist\fP by whitespace or another
shell metacharacter.
.TP
((\fIexpression\fP))
Da \fIexpression\fP is evaluated accordin ta tha rulez busted lyrics about
below under
.SM
.BR "ARITHMETIC EVALUATION" .
If tha value of tha expression is non-zero, tha return status is 0;
otherwise tha return status is 1.  This is exactly equivalent to
\fBlet "\fIexpression\fP"\fR.
.TP
\fB[[\fP \fIexpression\fP \fB]]\fP
Return a statuz of 0 or 1 dependin on tha evaluation of
the conditionizzle expression \fIexpression\fP.
Expressions is composed of tha primaries busted lyrics bout below under
.SM
.BR "CONDITIONAL EXPRESSIONS" .
Word splittin n' pathname expansion is not performed on tha lyrics
between tha \fB[[\fP n' \fB]]\fP; tilde expansion, parameta and
variable expansion, arithmetic expansion, command substitution, process
substitution, n' quote removal is performed.
Conditionizzle operators like fuckin \fB\-f\fP must be unquoted ta be recognized
as primaries.
.if t .sp 0.5
.if n .sp 1
When used wit \fB[[\fP, tha \fB<\fP n' \fB>\fP operators sort
lexicographically rockin tha current locale.
.if t .sp 0.5
.if n .sp 1
When tha \fB==\fP n' \fB!=\fP operators is used, tha strang ta the
right of tha operator is considered a pattern n' matched according
to tha rulez busted lyrics bout below under \fBPattern Matching\fP.
If tha shell option
.B nocasematch
is enabled, tha match is performed without regard ta tha case
of alphabetic characters.
Da return value is 0 if tha strang matches (\fB==\fP) or do not match
(\fB!=\fP) tha pattern, n' 1 otherwise.
Any part of tha pattern may be quoted ta force it ta be matched as a
string.
.if t .sp 0.5
.if n .sp 1
An additionizzle binary operator, \fB=~\fP, be available, wit tha same
precedence as \fB==\fP n' \fB!=\fP.
When it is used, tha strang ta tha right of tha operator is considered
an extended regular expression n' matched accordingly (as up in \fIregex\fP(3)).  
Da return value is 0 if tha strang matches
the pattern, n' 1 otherwise.
If tha regular expression is syntactically incorrect, tha conditional
expressionz return value is 2.
If tha shell option
.B nocasematch
is enabled, tha match is performed without regard ta tha case
of alphabetic characters.
Any part of tha pattern may be quoted ta force it ta be matched as a
string.
Substrings matched by parenthesized subexpressions within tha regular
expression is saved up in tha array variable
.SM
.BR BASH_REMATCH .
Da element of
.SM
.B BASH_REMATCH
with index 0 is tha portion of tha string
matchin tha entire regular expression.
Da element of
.SM
.B BASH_REMATCH
with index \fIn\fP is tha portion of the
strin matchin tha \fIn\fPth parenthesized subexpression.
.if t .sp 0.5
.if n .sp 1
Expressions may be combined rockin tha followin operators, listed
in decreasin order of precedence:
.if t .sp 0.5
.if n .sp 1
.RS
.PD 0
.TP
.B ( \fIexpression\fP )
Returns tha value of \fIexpression\fP.
This may be used ta override tha aiiight precedence of operators.
.TP
.B ! \fIexpression\fP
True if
.I expression
is false.
.TP
\fIexpression1\fP \fB&&\fP \fIexpression2\fP
True if both
.I expression1
and
.I expression2
are true.
.TP
\fIexpression1\fP \fB||\fP \fIexpression2\fP
True if either
.I expression1
or
.I expression2
is true.
.PD
.LP
Da \fB&&\fP n' \fB||\fP
operators do not evaluate \fIexpression2\fP if tha value of
\fIexpression1\fP is sufficient ta determine tha return value of
the entire conditionizzle expression.
.RE
.TP
\fBfor\fP \fIname\fP [ [ \fBin\fP [ \fIword ...\fP ] ] ; ] \fBdo\fP \fIlist\fP ; \fBdone\fP
Da list of lyrics followin \fBin\fP is expanded, generatin a list
of items.
Da variable \fIname\fP is set ta each element of dis list
in turn, n' \fIlist\fP is executed each time.
If tha \fBin\fP \fIword\fP is omitted, tha \fBfor\fP command executes
\fIlist\fP once fo' each positionizzle parameta dat is set (see
.SM
.B PARAMETERS
below).
Da return status is tha exit statuz of tha last command dat executes.
If tha expansion of tha shit followin \fBin\fP thangs up in dis biatch up in a empty
list, no commandz is executed, n' tha return status is 0.
.TP
\fBfor\fP (( \fIexpr1\fP ; \fIexpr2\fP ; \fIexpr3\fP )) ; \fBdo\fP \fIlist\fP ; \fBdone\fP
First, tha arithmetic expression \fIexpr1\fP is evaluated according
to tha rulez busted lyrics bout below under
.SM
.BR "ARITHMETIC EVALUATION" .
Da arithmetic expression \fIexpr2\fP is then evaluated repeatedly
until it evaluates ta zero.
Each time \fIexpr2\fP evaluates ta a non-zero value, \fIlist\fP is
executed n' tha arithmetic expression \fIexpr3\fP is evaluated.
If any expression is omitted, it behaves as if it evaluates ta 1.
Da return value is tha exit statuz of tha last command up in \fIlist\fP
that is executed, or false if any of tha expressions is invalid.
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fBdo\fP \fIlist\fP ; \fBdone\fP
Da list of lyrics followin \fBin\fP is expanded, generatin a list
of items.  Da set of expanded lyrics is printed on tha standard
error, each preceded by a number n' shit.  If tha \fBin\fP
\fIword\fP is omitted, tha positionizzle parametas is printed (see
.SM
.B PARAMETERS
below).  The
.SM
.B PS3
prompt is then displayed n' a line read from tha standard input.
If tha line consistz of a number correspondin ta one of
the displayed lyrics, then tha value of
.I name
is set ta dat word. Y'all KNOW dat shit, muthafucka!  If tha line is empty, tha lyrics n' prompt
are displayed again. I aint talkin' bout chicken n' gravy biatch.  If EOF is read, tha command completes.  Any
other value read causes
.I name
to be set ta null.  Da line read is saved up in tha variable
.SM
.BR REPLY .
The
.I list
is executed afta each selection until a
.B break
command is executed.
Da exit status of
.B select
is tha exit statuz of tha last command executed in
.IR list ,
or zero if no commandz was executed.
.TP
\fBcase\fP \fIword\fP \fBin\fP [ [(] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \
... ) \fIlist\fP ;; ] ... \fBesac\fP
A \fBcase\fP command first expandz \fIword\fP, n' tries ta match
it against each \fIpattern\fP up in turn, rockin tha same matchin rules
as fo' pathname expansion (see
.B Pathname Expansion
below).
Da \fIword\fP is expanded rockin tilde
expansion, parameta n' variable expansion, arithmetic substitution,
command substitution, process substitution n' quote removal.
Each \fIpattern\fP examined is expanded rockin tilde
expansion, parameta n' variable expansion, arithmetic substitution,
command substitution, n' process substitution.
If tha shell option
.B nocasematch
is enabled, tha match is performed without regard ta tha case
of alphabetic characters.
When a match is found, tha correspondin \fIlist\fP is executed.
If tha \fB;;\fP operator is used, no subsequent matches is attempted after
the first pattern match.
Usin \fB;&\fP up in place of \fB;;\fP causes execution ta continue with
the \fIlist\fP associated wit tha next set of patterns.
Usin \fB;;&\fP up in place of \fB;;\fP causes tha shell ta test tha next
pattern list up in tha statement, if any, n' execute any associated \fIlist\fP
on a successful match.
Da exit status is zero if no
pattern matches.  Otherwise, it is tha exit statuz of the
last command executed up in \fIlist\fP.
.TP
\fBif\fP \fIlist\fP; \fBthen\fP \fIlist;\fP \
[ \fBelif\fP \fIlist\fP; \fBthen\fP \fIlist\fP; ] ... \
[ \fBelse\fP \fIlist\fP; ] \fBfi\fP
The
.B if 
.I list
is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If its exit status is zero, the
\fBthen\fP \fIlist\fP is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Otherwise, each \fBelif\fP
\fIlist\fP is executed up in turn, n' if its exit status is zero,
the correspondin \fBthen\fP \fIlist\fP is executed n' the
command completes.  Otherwise, tha \fBelse\fP \fIlist\fP is
executed, if present.  Da exit status is tha exit statuz of the
last command executed, or zero if no condizzle tested true.
.TP
\fBwhile\fP \fIlist-1\fP; \fBdo\fP \fIlist-2\fP; \fBdone\fP
.PD 0
.TP
\fBuntil\fP \fIlist-1\fP; \fBdo\fP \fIlist-2\fP; \fBdone\fP
.PD
Da \fBwhile\fP command continuously executes tha list
\fIlist-2\fP as long as tha last command up in tha list \fIlist-1\fP returns
an exit statuz of zero.  Da \fBuntil\fP command is identical
to tha \fBwhile\fP command, except dat tha test is negated;
.I list-2
is executed as long as tha last command in
.I list-1
returns a non-zero exit status.
Da exit statuz of tha \fBwhile\fP n' \fBuntil\fP commands
is tha exit status
of tha last command executed up in \fIlist-2\fP, or zero if
none was executed.
.SS Coprocesses
.PP
A \fIcoprocess\fP be a gangbangin' finger-lickin' dirty-ass shell command preceded by tha \fBcoproc\fP reserved
word.
A coprocess is executed asynchronously up in a subshell, as if tha command
had been terminated wit tha \fB&\fP control operator, wit a two-way pipe
established between tha executin shell n' tha coprocess.
.PP
Da format fo' a cold-ass lil coprocess is:
.RS
.PP
\fBcoproc\fP [\fINAME\fP] \fIcommand\fP [\fIredirections\fP]
.RE
.PP
This creates a cold-ass lil coprocess named \fINAME\fP.
If \fINAME\fP aint supplied, tha default name is \fICOPROC\fP.
\fINAME\fP must not be supplied if \fIcommand\fP be a \fIsimple
command\fP (see above); otherwise, it is interpreted as tha straight-up original gangsta word
of tha simple command.
When tha coproc is executed, tha shell creates a array variable (see
.B Arrays
below) named \fINAME\fP up in tha context of tha executin shell.
Da standard output of
.I command
is connected via a pipe ta a gangbangin' file descriptor up in tha executin shell,
and dat file descriptor be assigned ta \fINAME\fP[0].
Da standard input of
.I command
is connected via a pipe ta a gangbangin' file descriptor up in tha executin shell,
and dat file descriptor be assigned ta \fINAME\fP[1].
This pipe is established before any redirections specified by the
command (see
.SM
.B REDIRECTION
below).
Da file descriptors can be utilized as arguments ta shell commands
and redirections rockin standard word expansions.
Da process ID of tha shell spawned ta execute tha coprocess is
available as tha value of tha variable \fINAME\fP_PID.
Da \fBwait\fP
builtin command may be used ta wait fo' tha coprocess ta terminate.
.PP
Da return statuz of a cold-ass lil coprocess is tha exit statuz of \fIcommand\fP.
.SS Shell Function Definitions
.PP
A shell function be a object dat is called like a simple command and
executes a cold-ass lil compound command wit a freshly smoked up set of positionizzle parameters.
Shell functions is declared as bigs up:
.TP
\fIname\fP () \fIcompound\-command\fP [\fIredirection\fP]
.PD 0
.TP
\fBfunction\fP \fIname\fP [()] \fIcompound\-command\fP [\fIredirection\fP]
.PD
This defines a gangbangin' function named \fIname\fP.
Da reserved word \fBfunction\fP is optional.
If tha \fBfunction\fP reserved word is supplied, tha parentheses is optional.
Da \fIbody\fP of tha function is tha compound command
.I compound\-command 
(see \fBCompound Commands\fP above).
That command is probably a \fIlist\fP of commandz between { n' } yo, but
may be any command listed under \fBCompound Commands\fP above.
\fIcompound\-command\fP is executed whenever \fIname\fP is specified as the
name of a simple command.
Any redirections (see
.SM
.B REDIRECTION
below) specified when a gangbangin' function is defined is performed
when tha function is executed.
Da exit statuz of a gangbangin' function definizzle is zero unless a syntax error
occurs or a readonly function wit tha same name already exists.
When executed, tha exit statuz of a gangbangin' function is tha exit statuz of the
last command executed up in tha body.  (See
.SM
.B FUNCTIONS
below.)
.SH COMMENTS
In a non-interactizzle shell, or a interactizzle shell up in which the
.B interactive_comments
option ta the
.B shopt
builtin is enabled (see
.SM
.B "SHELL BUILTIN COMMANDS"
below), a word beginnin with
.B #
causes dat word n' all remainin charactas on dat line to
be ignored. Y'all KNOW dat shit, muthafucka!  An interactizzle shell without the
.B interactive_comments
option enabled do not allow comments, n' you can put dat on yo' toast.  The
.B interactive_comments
option is on by default up in interactizzle shells.
.SH QUOTING
\fIQuoting\fP is used ta remove tha special meanin of certain
charactas or lyrics ta tha shell.  Quotin can be used ta 
disable special treatment fo' special characters, ta prevent
reserved lyrics from bein recognized as such, n' ta prevent
parameta expansion.
.PP
Each of tha \fImetacharacters\fP listed above under
.SM
.B DEFINITIONS
has special meanin ta tha shell n' must be quoted if it is to
represent itself.
.PP
When tha command history expansion facilitizzles is bein used
(see
.SM
.B HISTORY EXPANSION
below), the
\fIhistory expansion\fP character, probably \fB!\fP, must be quoted
to prevent history expansion.
.PP
There is three quotin mechanisms: the
.IR "escape character" ,
single quotes, n' double quotes.
.PP
A non-quoted backslash (\fB\e\fP) is the
.IR "escape character" .
It preserves tha literal value of tha next characta dat bigs up,
with tha exception of <newline>.  If a \fB\e\fP<newline> pair
appears, n' tha backslash aint itself quoted, tha \fB\e\fP<newline>
is treated as a line continuation (that is, it is removed from the
input stream n' effectively ignored).
.PP
Enclosin charactas up in single quotes preserves tha literal value
of each characta within tha quotes.  A single quote may not occur
between single quotes, even when preceded by a funky-ass backslash.
.PP
Enclosin charactas up in double quotes preserves tha literal value
of all charactas within tha quotes, wit tha exception of
.BR $ ,
.BR \` ,
.BR \e ,
and, when history expansion is enabled,
.BR ! .
Da characters
.B $
and
.B \`
retain they special meanin within double quotes.  Da backslash
retains its special meanin only when followed by one of tha following
characters:
.BR $ ,
.BR \` ,
\^\fB"\fP\^,
.BR \e ,
or
.BR <newline> .
A double quote may be quoted within double quotes by precedin it with
a backslash.
If enabled, history expansion is ghon be performed unless an
.B !
appearin up in double quotes is escaped rockin a funky-ass backslash.
Da backslash precedin the
.B !
is not removed.
.PP
Da special parameters
.B *
and
.B @
have special meanin when up in double
quotes (see
.SM
.B PARAMETERS
below).
.PP
Lyrics of tha form \fB$\fP\(aq\fIstring\fP\(aq is treated specially.  The
word expandz ta \fIstring\fP, wit backslash-escaped charactas replaced
as specified by tha ANSI C standard. Y'all KNOW dat shit, muthafucka!  Backslash escape sequences, if
present, is decoded as bigs up:
.RS
.PD 0
.TP
.B \ea
alert (bell)
.TP
.B \eb
backspace
.TP
.B \ee
.TP
.B \eE
an escape character
.TP   
.B \ef
form feed
.TP  
.B \en
new line
.TP     
.B \er
carriage return
.TP
.B \et
horizontal tab
.TP   
.B \ev
vertical tab
.TP
.B \e\e
backslash
.TP
.B \e\(aq
single quote
.TP
.B \e\(dq
double quote
.TP   
.B \e\fInnn\fP
the eight-bit characta whose value is tha octal value \fInnn\fP
(one ta three digits)
.TP
.B \ex\fIHH\fP
the eight-bit characta whose value is tha hexadecimal value \fIHH\fP
(one or two hex digits)
.TP
.B \eu\fIHHHH\fP
the Unicode (ISO/IEC 10646) characta whose value is tha hexadecimal value
\fIHHHH\fP (one ta four hex digits)
.TP
.B \eU\fIHHHHHHHH\fP
the Unicode (ISO/IEC 10646) characta whose value is tha hexadecimal value
\fIHHHHHHHH\fP (one ta eight hex digits)
.TP
.B \ec\fIx\fP
a control-\fIx\fP character
.PD
.RE
.LP
Da expanded result is single-quoted, as if tha dollar sign had
not been present.
.PP
A double-quoted strang preceded by a thugged-out dollar sign (\fB$\fP\(dq\fIstring\fP\(dq)
will cause tha strang ta be translated accordin ta tha current locale.
If tha current locale is \fBC\fP or \fBPOSIX\fP, tha dollar sign
is ignored.
If tha strang is translated n' replaced, tha replacement is
double-quoted.
.SH PARAMETERS
A
.I parameter
is a entitizzle dat stores joints.
It can be a
.IR name ,
a number, or one of tha special charactas listed below under
.BR "Special Parameters" .
A
.I variable
is a parameta denoted by a
.IR name .
A variable has a \fIvalue\fP n' zero or mo' \fIattributes\fP.
Attributes is assigned rockin the
.B declare
builtin command (see
.B declare
below in
.SM
.BR "SHELL BUILTIN COMMANDS" ).
.PP
A parameta is set if it has been assigned a value.  Da null strang is
a valid value.  Once a variable is set, it may be unset only by using
the
.B unset
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.PP
A
.I variable
may be assigned ta by a statement of tha form
.RS
.PP
\fIname\fP=[\fIvalue\fP]
.RE
.PP
If
.I value
is not given, tha variable be assigned tha null string.  All
.I joints
undergo tilde expansion, parameta n' variable expansion,
command substitution, arithmetic expansion, n' quote
removal (see
.SM
.B EXPANSION
below).  If tha variable has its
.B integer
attribute set, then
.I value
is evaluated as a arithmetic expression even if tha $((...)) expansion is
not used (see
.B "Arithmetic Expansion"
below).
Word splittin aint performed, wit tha exception
of \fB"$@"\fP as explained below under
.BR "Special Parameters" .
Pathname expansion aint performed.
Assignment statements may also step tha fuck up as arguments ta the
.BR alias ,
.BR declare ,
.BR typeset ,
.BR export ,
.BR readonly ,
and
.B local
builtin commands.
.PP
In tha context where a assignment statement be assignin a value
to a gangbangin' finger-lickin' dirty-ass shell variable or array index, tha += operator can be used to
append ta or add ta tha variablez previous value.
When += be applied ta a variable fo' which tha \fIinteger\fP attribute has been
set, \fIvalue\fP is evaluated as a arithmetic expression n' added ta the
variablez current value, which be also evaluated.
When += be applied ta a array variable rockin compound assignment (see
.B Arrays
below), the
variablez value aint unset (as it is when rockin =), n' freshly smoked up joints are
appended ta tha array beginnin at one pimped outa than tha arrayz maximum index
(for indexed arrays) or added as additionizzle key\-value pairs up in an
associatizzle array.
When applied ta a string-valued variable, \fIvalue\fP is expanded and
appended ta tha variablez value.
.SS Positionizzle Parameters
.PP
A
.I positionizzle parameter
is a parameta denoted by one or more
digits, other than tha single digit 0.  Positionizzle parametas are
assigned from tha shellz arguments when it is invoked,
and may be reassigned rockin the
.B set
builtin command. Y'all KNOW dat shit, muthafucka!  Positionizzle parametas may not be assigned to
with assignment statements, n' you can put dat on yo' toast.  Da positionizzle parametas are
temporarily replaced when a gangbangin' finger-lickin' dirty-ass shell function is executed (see
.SM
.B FUNCTIONS
below).
.PP
When a positionizzle parameta consistin of mo' than a single
digit is expanded, it must be enclosed up in braces (see
.SM
.B EXPANSION
below).
.SS Special Parameters
.PP
Da shell treats nuff muthafuckin parametas specially.  These parametas may
only be referenced; assignment ta dem aint allowed.
.PD 0
.TP
.B *
Expandz ta tha positionizzle parameters, startin from one.  When the
expansion occurs within double quotes, it expandz ta a single word
with tha value of each parameta separated by tha straight-up original gangsta character
of tha 
.SM
.B IFS
special variable.  That is, "\fB$*\fP" is equivalent
to "\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP", where
.I c
is tha straight-up original gangsta characta of tha value of the
.SM
.B IFS
variable.  If
.SM
.B IFS
is unset, tha parametas is separated by spaces.
If
.SM
.B IFS
is null, tha parametas is joined without intervenin separators.
.TP
.B @
Expandz ta tha positionizzle parameters, startin from one.  When the
expansion occurs within double quotes, each parameta expandz ta a
separate word. Y'all KNOW dat shit, muthafucka!  That is, "\fB$@\fP" is equivalent to
"\fB$1\fP" "\fB$2\fP" ...
If tha double-quoted expansion occurs within a word, tha expansion of
the first parameta is joined wit tha beginnin part of tha original
word, n' tha expansion of tha last parameta is joined wit tha last
part of tha original gangsta word.
When there be no positionizzle parameters, "\fB$@\fP" n' 
.B $@
expand ta not a god damn thang (i.e., they is removed).
.TP
.B #
Expandz ta tha number of positionizzle parametas up in decimal.
.TP
.B ?
Expandz ta tha exit statuz of da most thugged-out recently executed foreground
pipeline.
.TP
.B \-
Expandz ta tha current option flags as specified upon invocation, 
by the
.B set
builtin command, or dem set by tha shell itself
(like fuckin the
.B \-i
option).
.TP
.B $
Expandz ta tha process ID of tha shell.  In a () subshell, it
expandz ta tha process ID of tha current shell, not the
subshell.
.TP
.B !
Expandz ta tha process ID of da most thugged-out recently executed background
(asynchronous) command.
.TP
.B 0
Expandz ta tha name of tha shell or shell script.  This is set at
shell initialization. I aint talkin' bout chicken n' gravy biatch.  If
.B bash
is invoked wit a gangbangin' file of commands,
.B $0
is set ta tha name of dat file.  If
.B bash
is started wit the
.B \-c
option, then
.B $0
is set ta tha straight-up original gangsta argument afta tha strang ta be
executed, if one is present.  Otherwise, it is set
to tha file name used ta invoke
.BR bash ,
as given by argument zero.
.TP
.B _
At shell startup, set ta tha absolute pathname used ta invoke the
shell or shell script bein executed as passed up in tha environment
or argument list.
Subsequently, expandz ta tha last argument ta tha previous command,
afta expansion.
Also set ta tha full pathname used ta invoke each command executed
and placed up in tha environment exported ta dat command.
When checkin mail, dis parameta holdz tha name of tha mail file
currently bein checked.
.PD
.SS Shell Variables
.PP
Da followin variablez is set by tha shell:
.PP
.PD 0
.TP
.B BASH
Expandz ta tha full file name used ta invoke dis instizzle of
.BR bash .
.TP
.B BASHOPTS
A colon-separated list of enabled shell options.  Each word in
the list be a valid argument fo' the
.B \-s
option ta the
.B shopt
builtin command (see
.SM
.B "SHELL BUILTIN COMMANDS"
below).  Da options appearin in
.SM
.B BASHOPTS
are dem reported as
.I on
by \fBshopt\fP.
If dis variable is up in tha environment when
.B bash
starts up, each shell option up in tha list is ghon be enabled before
readin any startup files.
This variable is read-only.
.TP
.B BASHPID
Expandz ta tha process ID of tha current \fBbash\fP process.
This differs from \fB$$\fP under certain circumstances, like fuckin subshells
that do not require \fBbash\fP ta be re-initialized.
.TP
.B BASH_ALIASES
An associatizzle array variable whose thugz correspond ta tha internal
list of aliases as maintained by tha \fBalias\fP builtin.
Elements added ta dis array step tha fuck up in tha alias list; unsettin array
elements cause aliases ta be removed from tha alias list.
.TP
.B BASH_ARGC
An array variable whose joints is tha number of parametas up in each
frame of tha current \fBbash\fP execution call stack.
Da number of
parametas ta tha current subroutine (shell function or script executed
with \fB.\fP or \fBsource\fP) be all up in tha top of tha stack.
When a subroutine is executed, tha number of parametas passed is pushed onto
.SM
.BR BASH_ARGC .
Da shell sets
.SM
.B BASH_ARGC
only when up in extended debuggin mode (see tha description of the
.B extdebug
option ta the
.B shopt
builtin below)
.TP
.B BASH_ARGV
An array variable containin all of tha parametas up in tha current \fBbash\fP
execution call stack.  Da final parameta of tha last subroutine call
is all up in tha top of tha stack; tha straight-up original gangsta parameta of tha initial call is
at tha bottom.  When a subroutine is executed, tha parametas supplied
are pushed onto
.SM
.BR BASH_ARGV .
Da shell sets
.SM
.B BASH_ARGV
only when up in extended debuggin mode
(see tha description of the
.B extdebug
option ta the
.B shopt
builtin below)
.TP
.B BASH_CMDS
An associatizzle array variable whose thugz correspond ta tha internal
hash table of commandz as maintained by tha \fBhash\fP builtin.
Elements added ta dis array step tha fuck up in tha hash table; unsettin array
elements cause commandz ta be removed from tha hash table.
.TP
.B BASH_COMMAND
Da command currently bein executed or bout ta be executed, unless the
shell is executin a cold-ass lil command as tha result of a trap,
in which case it is tha command executin all up in tha time of tha trap.
.TP
.B BASH_EXECUTION_STRING
Da command argument ta tha \fB\-c\fP invocation option.
.TP
.B BASH_LINENO
An array variable whose thugz is tha line numbers up in source files
where each correspondin gangmember of
.SM
.B FUNCNAME
was invoked.
\fB${BASH_LINENO[\fP\fI$i\fP\fB]}\fP is tha line number up in tha source
file (\fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP) where
\fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP was called
(or \fB${BASH_LINENO[\fP\fI$i-1\fP\fB]}\fP if referenced within another
shell function).
Use
.SM
.B LINENO
to obtain tha current line number.
.TP
.B BASH_REMATCH
An array variable whose thugz is assigned by tha \fB=~\fP binary
operator ta tha \fB[[\fP conditionizzle command.
Da element wit index 0 is tha portion of tha string
matchin tha entire regular expression.
Da element wit index \fIn\fP is tha portion of the
strin matchin tha \fIn\fPth parenthesized subexpression.
This variable is read-only.
.TP
.B BASH_SOURCE
An array variable whose thugz is tha source filenames
where tha correspondin shell function names up in the
.SM
.B FUNCNAME
array variable is defined.
Da shell function
\fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP is defined up in tha file
\fB${BASH_SOURCE[\fP\fI$i\fP\fB]}\fP n' called from
\fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP.
.TP
.B BASH_SUBSHELL
Incremented by one each time a subshell or subshell environment is spawned.
Da initial value is 0.
.TP
.B BASH_VERSINFO
A readonly array variable whose thugz hold version shiznit for
this instizzle of
.BR bash .
Da joints assigned ta tha array thugz is as bigs up:
.sp .5
.RS
.TP 24
.B BASH_VERSINFO[\fR0\fP]
Da major version number (the \fIrelease\fP).
.TP
.B BASH_VERSINFO[\fR1\fP]
Da minor version number (the \fIversion\fP).
.TP
.B BASH_VERSINFO[\fR2\fP]
Da patch level.
.TP
.B BASH_VERSINFO[\fR3\fP]
Da build version.
.TP
.B BASH_VERSINFO[\fR4\fP]
Da release status (e.g., \fIbeta1\fP).
.TP
.B BASH_VERSINFO[\fR5\fP]
Da value of
.SM
.BR MACHTYPE .
.RE
.TP
.B BASH_VERSION
Expandz ta a strang describin tha version of dis instizzle of
.BR bash .
.TP
.B COMP_CWORD
An index tha fuck into \fB${COMP_WORDS}\fP of tha word containin tha current
cursor position.
This variable be available only up in shell functions invoked by the
programmable completion facilitizzles (see \fBProgrammable Completion\fP
below).
.TP
.B COMP_KEY
Da key (or final key of a key sequence) used ta invoke tha current
completion function.
.TP
.B COMP_LINE
Da current command line.
This variable be available only up in shell functions n' external
commandz invoked by the
programmable completion facilitizzles (see \fBProgrammable Completion\fP
below).
.TP
.B COMP_POINT
Da index of tha current cursor posizzle relatizzle ta tha beginnin of
the current command.
If tha current cursor posizzle be all up in tha end of tha current command,
the value of dis variable is equal ta \fB${#COMP_LINE}\fP.
This variable be available only up in shell functions n' external
commandz invoked by the
programmable completion facilitizzles (see \fBProgrammable Completion\fP
below).
.TP
.B COMP_TYPE
Set ta a integer value correspondin ta tha type of completion attempted
that caused a cold-ass lil completion function ta be called:
\fITAB\fP, fo' aiiight completion,
\fI?\fP, fo' listin completions afta successive tabs,
\fI!\fP, fo' listin alternatives on partial word completion,
\fI@\fP, ta list completions if tha word aint unmodified,
or
\fI%\fP, fo' menu completion.
This variable be available only up in shell functions n' external
commandz invoked by the
programmable completion facilitizzles (see \fBProgrammable Completion\fP
below).
.TP
.B COMP_WORDBREAKS
Da set of charactas dat tha \fBreadline\fP library treats as word
separators when struttin word completion.
If
.SM
.B COMP_WORDBREAKS
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B COMP_WORDS
An array variable (see \fBArrays\fP below) consistin of tha individual
wordz up in tha current command line.
Da line is split tha fuck into lyrics as \fBreadline\fP would split it, using
.SM
.B COMP_WORDBREAKS
as busted lyrics bout above.
This variable be available only up in shell functions invoked by the
programmable completion facilitizzles (see \fBProgrammable Completion\fP
below).
.TP
.B COPROC
An array variable (see \fBArrays\fP below) pimped ta hold tha file descriptors
for output from n' input ta a unnamed coprocess (see \fBCoprocesses\fP
above).
.TP
.B DIRSTACK
An array variable (see
.B Arrays
below) containin tha current contentz of tha directory stack.
Directories step tha fuck up in tha stack up in tha order they is displayed by the
.B dirs
builtin.
Assignin ta thugz of dis array variable may be used ta modify
directories already up in tha stack yo, but the
.B pushd
and
.B popd
builtins must be used ta add n' remove directories.
Assignment ta dis variable aint gonna chizzle tha current directory.
If
.SM
.B DIRSTACK
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B EUID
Expandz ta tha effectizzle user ID of tha current user, initialized at
shell startup.  This variable is readonly.
.TP
.B FUNCNAME
An array variable containin tha namez of all shell functions
currently up in tha execution call stack.
Da element wit index 0 is tha name of any currently-executing
shell function.
Da bottom-most element (the one wit tha highest index) is
.if t \f(CW"main"\fP.
.if n "main".
This variable exists only when a gangbangin' finger-lickin' dirty-ass shell function is executing.
Assignments to
.SM
.B FUNCNAME
have no effect n' return a error status.
If
.SM
.B FUNCNAME
is unset, it loses its special properties, even if it is
subsequently reset.
.if t .sp 0.5
.if n .sp 1
This variable can be used wit \fBBASH_LINENO\fP n' \fBBASH_SOURCE\fP.
Each element of \fBFUNCNAME\fP has correspondin elements in
\fBBASH_LINENO\fP n' \fBBASH_SOURCE\fP ta describe tha call stack.
For instance, \fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP was called from tha file
\fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP at line number
\fB${BASH_LINENO[\fP\fI$i\fP\fB]}\fP.
Da \fBcaller\fP builtin displays tha current call stack rockin this
information.
.TP
.B GROUPS
An array variable containin tha list of crewz of which tha current
user be a member.
Assignments ta    
.SM
.B GROUPS
have no effect n' return a error status.
If
.SM
.B GROUPS
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B HISTCMD
Da history number, or index up in tha history list, of tha current
command.
If
.SM
.B HISTCMD
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B HOSTNAME
Automatically set ta tha name of tha current host.
.TP
.B HOSTTYPE
Automatically set ta a strang dat uniquely
raps bout tha type of machine on which
.B bash
is executing.
Da default is system-dependent.
.TP
.B LINENO
Each time dis parameta is referenced, tha shell substitutes
a decimal number representin tha current sequential line number
(startin wit 1) within a script or function. I aint talkin' bout chicken n' gravy biatch.  When not up in a
script or function, tha value substituted aint guaranteed to
be meaningful.
If
.SM
.B LINENO
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B MACHTYPE
Automatically set ta a strang dat straight-up raps bout tha system
type on which
.B bash
is executing, up in tha standard GNU \fIcpu-company-system\fP format.
Da default is system-dependent.
.TP
.B MAPFILE
An array variable (see \fBArrays\fP below) pimped ta hold tha text
read by tha \fBmapfile\fP builtin when no variable name is supplied.
.TP
.B OLDPWD
Da previous hustlin directory as set by the
.B cd
command.
.TP
.B OPTARG
Da value of tha last option argument processed by the
.B getopts
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.TP
.B OPTIND
Da index of tha next argument ta be processed by the
.B getopts
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.TP
.B OSTYPE
Automatically set ta a strang that
raps bout tha operatin system on which
.B bash
is executing.
Da default is system-dependent.
.TP
.B PIPESTATUS
An array variable (see
.B Arrays
below) containin a list of exit status joints from tha processes
in da most thugged-out-recently-executed foreground pipeline (which may
contain only a single command).
.TP
.B PPID
Da process ID of tha shellz parent.  This variable is readonly.
.TP
.B PWD
Da current hustlin directory as set by the
.B cd
command.
.TP
.B RANDOM
Each time dis parameta is referenced, a random integer between
0 n' 32767 is
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da sequence of random numbers may be initialized by assigning
a value to
.SM
.BR RANDOM .
If
.SM
.B RANDOM
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B READLINE_LINE
Da contentz of the
.B readline
line buffer, fo' use with
.if t \f(CWbind -x\fP
.if n "bind -x"
(see
.SM
.B "SHELL BUILTIN COMMANDS"
below).
.TP
.B READLINE_POINT
Da posizzle of tha insertion point up in the
.B readline
line buffer, fo' use with
.if t \f(CWbind -x\fP
.if n "bind -x"
(see
.SM
.B "SHELL BUILTIN COMMANDS"
below).
.TP
.B REPLY
Set ta tha line of input read by the
.B read
builtin command when no arguments is supplied.
.TP
.B SECONDS
Each time dis parameta is
referenced, tha number of secondz since shell invocation is returned. Y'all KNOW dat shit, muthafucka!  If a
value be assigned ta 
.SM
.BR SECONDS ,
the value returned upon subsequent
references is
the number of secondz since tha assignment plus tha value assigned.
If
.SM
.B SECONDS
is unset, it loses its special properties, even if it is
subsequently reset.
.TP
.B SHELLOPTS
A colon-separated list of enabled shell options.  Each word in
the list be a valid argument fo' the
.B \-o
option ta the
.B set
builtin command (see
.SM
.B "SHELL BUILTIN COMMANDS"
below).  Da options appearin in
.SM
.B SHELLOPTS
are dem reported as
.I on
by \fBset \-o\fP.
If dis variable is up in tha environment when
.B bash
starts up, each shell option up in tha list is ghon be enabled before
readin any startup files.
This variable is read-only.
.TP
.B SHLVL
Incremented by one each time a instizzle of
.B bash
is started.
.TP
.B UID
Expandz ta tha user ID of tha current user, initialized at shell startup.
This variable is readonly.
.PD
.PP
Da followin variablez is used by tha shell.  In some cases,
.B bash
assigns a thugged-out default value ta a variable; these cases is noted
below.
.PP
.PD 0
.TP
.B BASH_ENV
If dis parameta is set when \fBbash\fP is executin a gangbangin' finger-lickin' dirty-ass shell script,
its value is interpreted as a gangbangin' filename containin commandz to
initialize tha shell, as in
.IR ~/.bashrc .
Da value of
.SM
.B BASH_ENV
is subjected ta parameta expansion, command substitution, n' arithmetic
expansion before bein interpreted as a gangbangin' file name.
.SM
.B PATH
is not used ta search fo' tha resultant file name.
.TP
.B BASH_XTRACEFD
If set ta a integer correspondin ta a valid file descriptor, \fBbash\fP
will write tha trace output generated when
.if t \f(CWset -x\fP
.if n \fIset -x\fP
is enabled ta dat file descriptor.
Da file descriptor is closed when
.SM
.B BASH_XTRACEFD
is unset or assigned a freshly smoked up value.
Unsetting
.SM
.B BASH_XTRACEFD
or assignin it tha empty strang causes the
trace output ta be busted ta tha standard error.
Note dat setting
.SM
.B BASH_XTRACEFD
to 2 (the standard error file
descriptor) n' then unsettin it will result up in tha standard error
bein closed.
.TP
.B CDPATH
Da search path fo' the
.B cd
command.
This be a cold-ass lil colon-separated list of directories up in which tha shell looks
for destination directories specified by the
.B cd
command.
A sample value is
.if t \f(CW".:~:/usr"\fP.
.if n ".:~:/usr".
.TP
.B COLUMNS
Used by tha \fBselect\fP compound command ta determine tha terminal width
when printin selection lists, n' you can put dat on yo' toast.  Automatically set upon receipt of a
.SM
.BR SIGWINCH .
.TP
.B COMPREPLY
An array variable from which \fBbash\fP readz tha possible completions
generated by a gangbangin' finger-lickin' dirty-ass shell function invoked by tha programmable completion
facilitizzle (see \fBProgrammable Completion\fP below).
.TP
.B EMACS
If \fBbash\fP findz dis variable up in tha environment when tha shell starts
with value
.if t \f(CWt\fP,
.if n "t",
it assumes dat tha shell is hustlin up in a Emacs shell buffer n' disables
line editing.
.TP
.B ENV
Similar to
.SM
.BR BASH_ENV ;
used when tha shell is invoked up in POSIX mode.
.TP
.B FCEDIT
Da default editor fo' the
.B fc
builtin command.
.TP
.B FIGNORE
A colon-separated list of suffixes ta ignore when struttin
filename completion (see
.SM
.B READLINE
below).
A filename whose suffix matches one of tha entries up in 
.SM
.B FIGNORE
is excluded from tha list of matched filenames.
A sample value is
.if t \f(CW".o:~"\fP.
.if n ".o:~".
.TP
.B FUNCNEST
If set ta a numeric value pimped outa than 0, defines a maximum function
nestin level.  Function invocations dat exceed dis nestin level
will cause tha current command ta abort.
.TP
.B GLOBIGNORE
A colon-separated list of patterns definin tha set of filenames to
be ignored by pathname expansion.
If a gangbangin' filename matched by a pathname expansion pattern also matches one
of tha patterns in
.SM
.BR GLOBIGNORE ,
it is removed from tha list of matches.
.TP
.B HISTCONTROL
A colon-separated list of joints controllin how tha fuck commandz is saved on
the history list.
If tha list of joints includes
.IR ignorespace ,
lines which begin wit a
.B space
characta is not saved up in tha history list.
A value of 
.I ignoredups
causes lines matchin tha previous history entry ta not be saved.
A value of
.I ignoreboth
is shorthand fo' \fIignorespace\fP n' \fIignoredups\fP.
A value of
.IR erasedups
causes all previous lines matchin tha current line ta be removed from
the history list before dat line is saved.
Any value not up in tha above list is ignored.
If
.SM
.B HISTCONTROL
is unset, or do not include a valid value,
all lines read by tha shell parser is saved on tha history list,
subject ta tha value of
.SM
.BR HISTIGNORE .
Da second n' subsequent linez of a multi-line compound command are
not tested, n' is added ta tha history regardless of tha value of
.SM
.BR HISTCONTROL .
.TP
.B HISTFILE
Da name of tha file up in which command history is saved (see
.SM
.B HISTORY
below).  Da default value is \fI~/.bash_history\fP.  If unset, the
command history aint saved when a interactizzle shell exits.
.TP
.B HISTFILESIZE
Da maximum number of lines contained up in tha history file.  When this
variable be assigned a value, tha history file is truncated, if
necessary, by removin tha crazy oldschool entries,
to contain no mo' than dat number of lines.  Da default
value is 500.  Da history file be also truncated ta dis size after
writin it when a interactizzle shell exits.
.TP
.B HISTIGNORE
A colon-separated list of patterns used ta decizzle which command lines
should be saved on tha history list.  Each pattern be anchored at the
beginnin of tha line n' must match tha complete line (no implicit
`\fB*\fP' be appended).  Each pattern is tested against tha line
afta tha checks specified by
.SM
.B HISTCONTROL
are applied.
In addizzle ta tha aiiight shell pattern matchin characters, `\fB&\fP'
matches tha previous history line.  `\fB&\fP' may be escaped rockin a
backslash; tha backslash is removed before attemptin a match.
Da second n' subsequent linez of a multi-line compound command are
not tested, n' is added ta tha history regardless of tha value of
.SM
.BR HISTIGNORE .
.TP
.B HISTSIZE
Da number of commandz ta remember up in tha command history (see
.SM
.B HISTORY
below).  Da default value is 500.
.TP
.B HISTTIMEFORMAT
If dis variable is set n' not null, its value is used as a gangbangin' format string
for \fIstrftime\fP(3) ta print tha time stamp associated wit each history
entry displayed by tha \fBhistory\fP builtin.
If dis variable is set, time stamps is freestyled ta tha history file so
they may be preserved across shell sessions.
This uses tha history comment characta ta distinguish timestamps from
other history lines.
.TP
.B HOME
Da home directory of tha current user; tha default argument fo' the
\fBcd\fP builtin command.
Da value of dis variable be also used when struttin tilde expansion.
.TP
.B HOSTFILE
Gotz Nuff tha name of a gangbangin' file up in tha same format as
.FN /etc/hosts
that should be read when tha shell need ta complete a
hostname.
Da list of possible hostname completions may be chizzled while the
shell is hustlin;
the next time hostname completion be attempted afta the
value is chizzled,
.B bash
addz tha contentz of tha freshly smoked up file ta tha existin list.
If
.SM
.B HOSTFILE
is set yo, but has no value, or do not name a readable file,
\fBbash\fP attempts ta read
.FN /etc/hosts
to obtain tha list of possible hostname completions.
When
.SM
.B HOSTFILE
is unset, tha hostname list is cleared.
.TP
.B IFS
The
.I Internal Field Separator
that is used
for word splittin afta expansion n' to
split lines tha fuck into lyrics wit the
.B read
builtin command. Y'all KNOW dat shit, muthafucka!  Da default value is
``<space><tab><newline>''.
.TP
.B IGNOREEOF
Controls the
action of a interactizzle shell on receipt of an
.SM
.B EOF
characta as tha sole input.  If set, tha value is tha number of
consecutive
.SM
.B EOF
charactas which must be
typed as tha straight-up original gangsta charactas on a input line before
.B bash
exits, n' you can put dat on yo' toast.  If tha variable exists but aint gots a numeric value, or
has no value, tha default value is 10.  If it do not exist,
.SM
.B EOF
signifies tha end of input ta tha shell.
.TP
.B INPUTRC
Da filename fo' the
.B readline
startup file, overridin tha default of
.FN ~/.inputrc
(see
.SM
.B READLINE
below).
.TP
.B LANG
Used ta determine tha locale category fo' any category not specifically
selected wit a variable startin wit \fBLC_\fP.
.TP
.B LC_ALL
This variable overrides tha value of
.SM
.B LANG
and any other
\fBLC_\fP variable specifyin a locale category.
.TP
.B LC_COLLATE
This variable determines tha collation order used when sortin the
resultz of pathname expansion, n' determines tha behavior of range
expressions, equivalence classes, n' collatin sequences within
pathname expansion n' pattern matching.
.TP
.B LC_CTYPE
This variable determines tha interpretation of charactas n' the
behavior of characta classes within pathname expansion n' pattern
matching.
.TP
.B LC_MESSAGES
This variable determines tha locale used ta translate double-quoted
strings preceded by a \fB$\fP.
.TP
.B LC_NUMERIC
This variable determines tha locale category used fo' number formatting.
.TP
.B LINES
Used by tha \fBselect\fP compound command ta determine tha column length
for printin selection lists, n' you can put dat on yo' toast.  Automatically set upon receipt of a
.SM
.BR SIGWINCH .
.TP
.B MAIL
If dis parameta is set ta a gangbangin' file or directory name n' the
.SM
.B MAILPATH
variable aint set,
.B bash
informs tha user of tha arrival of mail up in tha specified file or
Maildir-format directory.
.TP
.B MAILCHECK
Specifies how
often (in seconds)
.B bash
checks fo' mail.  Da default is 60 seconds.  When it is time ta check
for mail, tha shell do so before displayin tha primary prompt.
If dis variable is unset, or set ta a value dat aint a number
greata than or equal ta zero, tha shell disablez mail checking.
.TP
.B MAILPATH
A colon-separated list of file names ta be checked fo' mail. 
Da message ta be printed when mail arrives up in a particular file
may be specified by separatin tha file name from tha message wit a `?'.
When used up in tha text of tha message, \fB$_\fP expandz ta tha name of
the current mailfile. 
Example:
.RS
.PP
\fBMAILPATH\fP=\(aq/var/mail/bfox?"Yo ass have mail":~/shell\-mail?"$_ has mail!"\(aq
.PP
.B Bash
supplies a thugged-out default value fo' dis variable yo, but tha location of tha user
mail filez dat it uses is system dependent (e.g., /var/mail/\fB$USER\fP).
.RE
.TP
.B OPTERR
If set ta tha value 1,
.B bash
displays error lyrics generated by the
.B getopts
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.SM
.B OPTERR
is initialized ta 1 each time tha shell is invoked or a gangbangin' finger-lickin' dirty-ass shell
script is executed.
.TP
.B PATH
Da search path fo' commands.  It
is a cold-ass lil colon-separated list of directories up in which
the shell looks fo' commandz (see
.SM
.B COMMAND EXECUTION
below).
A zero-length (null) directory name up in tha value of
.SM
.B PATH
indicates tha current directory.
A null directory name may step tha fuck up as two adjacent colons, or as a initial
or trailin colon.
Da default path is system-dependent,
and is set by tha administrator whoz ass installs
.BR bash .
A common value is
.if t \f(CW/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin\fP.
.if n ``/usr/gnu/bin:/usr/local/bin:/usr/ucb:/bin:/usr/bin''.
.TP
.B POSIXLY_CORRECT
If dis variable is up in tha environment when \fBbash\fP starts, tha shell
entas \fIposix mode\fP before readin tha startup files, as if the
.B \-\-posix
invocation option had been supplied. Y'all KNOW dat shit, muthafucka!  If it is set while tha shell is
running, \fBbash\fP enablez \fIposix mode\fP, as if tha command
.if t \f(CWset -o posix\fP
.if n \fIset -o posix\fP
had been executed.
.TP
.B PROMPT_COMMAND
If set, tha value is executed as a cold-ass lil command prior ta issuin each primary
prompt.
.TP
.B PROMPT_DIRTRIM
If set ta a number pimped outa than zero, tha value is used as tha number of
trailin directory components ta retain when expandin tha \fB\ew\fP and
\fB\eW\fP prompt strang escapes (see
.SM
.B PROMPTING
below).  Charactas removed is replaced wit a ellipsis.
.TP
.B PS1
Da value of dis parameta is expanded (see
.SM
.B PROMPTING
below) n' used as tha primary prompt string.  Da default value is
``\fB\es\-\ev\e$ \fP''.
.TP
.B PS2
Da value of dis parameta is expanded as with
.SM
.B PS1
and used as tha secondary prompt string.  Da default is
``\fB> \fP''.
.TP
.B PS3
Da value of dis parameta is used as tha prompt fo' the
.B select
command (see
.SM
.B SHELL GRAMMAR
above).
.TP
.B PS4
Da value of dis parameta is expanded as with
.SM
.B PS1
and tha value is printed before each command
.B bash
displays durin a execution trace.  Da first characta of
.SM
.B PS4
is replicated multiple times, as necessary, ta indicate multiple
levelz of indirection. I aint talkin' bout chicken n' gravy biatch.  Da default is ``\fB+ \fP''.
.TP
.B SHELL
Da full pathname ta tha shell is kept up in dis environment variable.
If it aint set when tha shell starts,
.B bash
assigns ta it tha full pathname of tha current userz login shell.
.TP
.B TIMEFORMAT
Da value of dis parameta is used as a gangbangin' format strang specifying
how tha timin shiznit fo' pipelines prefixed wit the
.B time
reserved word should be displayed.
Da \fB%\fP characta introduces a escape sequence dat is
expanded ta a time value or other shiznit.
Da escape sequences n' they meanings is as bigs up; the
braces denote optionizzle portions.
.sp .5
.RS
.PD 0
.TP 10
.B %%
A literal \fB%\fP.
.TP
.B %[\fIp\fP][l]R
Da elapsed time up in seconds.
.TP
.B %[\fIp\fP][l]U
Da number of CPU secondz dropped up in user mode.
.TP
.B %[\fIp\fP][l]S
Da number of CPU secondz dropped up in system mode.
.TP
.B %P
Da CPU cementage, computed as (%U + %S) / %R.
.PD
.RE
.IP
Da optionizzle \fIp\fP be a gangbangin' finger-lickin' digit specifyin tha \fIprecision\fP,
the number of fractionizzle digits afta a thugged-out decimal point.
A value of 0 causes no decimal point or fraction ta be output.
At most three places afta tha decimal point may be specified;
valuez of \fIp\fP pimped outa than 3 is chizzled ta 3.
If \fIp\fP aint specified, tha value 3 is used.
.IP
Da optionizzle \fBl\fP specifies a longer format, including
minutes, of tha form \fIMM\fPm\fISS\fP.\fIFF\fPs.
Da value of \fIp\fP determines whether or not tha fraction is
included.
.IP
If dis variable aint set, \fBbash\fP acts as if it had the
value \fB$\(aq\enreal\et%3lR\enuser\et%3lU\ensys\t%3lS\(aq\fP.
If tha value is null, no timin shiznit is displayed.
A trailin newline be added when tha format strang is displayed.
.PD 0
.TP
.B TMOUT
If set ta a value pimped outa than zero,
.SM
.B TMOUT
is treated as the
default timeout fo' tha \fBread\fP builtin.
Da \fBselect\fP command terminates if input do not arrive
after
.SM
.B TMOUT
secondz when input is comin from a terminal.
In a interactizzle shell, tha value is interpreted as the
number of secondz ta wait fo' input afta issuin tha primary prompt.
.B Bash
terminates afta waitin fo' dat number of secondz if input do
not arrive.
.TP
.B TMPDIR
If set, \fBbash\fP uses its value as tha name of a gangbangin' finger-lickin' directory up in which
\fBbash\fP creates temporary filez fo' tha shellz use.
.TP
.B auto_resume
This variable controls how tha fuck tha shell interacts wit tha user and
job control.  If dis variable is set, single word simple
commandz without redirections is treated as muthafuckas fo' resumption
of a existin stopped thang.  There is no ambiguitizzle allowed; if there is
more than one thang beginnin wit tha strang typed, tha thang most recently
accessed is selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  The
.I name
of a stopped thang, up in dis context, is tha command line used to
start dat shit.
If set ta tha value
.IR exact ,
the strang supplied must match tha name of a stopped thang exactly;
if set to
.IR substrin ,
the strang supplied need ta match a substrin of tha name of a
stopped thang.  The
.I substring
value serves up functionalitizzle analogous ta the
.B %?
job identifier (see
.SM
.B JOB CONTROL
below).  If set ta any other value, tha supplied strang must
be a prefix of a stopped thangz name; dis serves up functionality
analogous ta tha \fB%\fP\fIstring\fP thang identifier.
.TP
.B histchars
Da two or three charactas which control history expansion
and tokenization (see
.SM
.B HISTORY EXPANSION
below).  Da first characta is tha \fIhistory expansion\fP character,
the characta which signals tha start of a history
expansion, normally `\fB!\fP'.
Da second characta is tha \fIquick substitution\fP
character, which is used as shorthand fo' re-runnin tha previous
command entered, substitutin one strang fo' another up in tha command.
Da default is `\fB^\fP'.
Da optionizzle third characta is tha character
which indicates dat tha remainder of tha line be a cold-ass lil comment when found
as tha straight-up original gangsta characta of a word, normally `\fB#\fP'.  Da history
comment characta causes history substitution ta be skipped fo' the
remainin lyrics on tha line.  It do not necessarily cause tha shell
parser ta treat tha rest of tha line as a cold-ass lil comment.
.PD
.SS Arrays
.B Bash
provides one-dimensionizzle indexed n' associatizzle array variables.
Any variable may be used as a indexed array; the
.B declare
builtin will explicitly declare a array.
There is no maximum
limit on tha size of a array, nor any requirement dat members
be indexed or assigned contiguously.
Indexed arrays is referenced rockin integers (includin arithmetic
expressions)  n' is zero-based; associatizzle arrays is referenced
usin arbitrary strings.
.PP
An indexed array is pimped automatically if any variable be assigned to
usin tha syntax \fIname\fP[\fIsubscript\fP]=\fIvalue\fP.  The
.I subscript
is treated as a arithmetic expression dat must evaluate ta a number.
If
.I subscript
evaluates ta a number less than zero, it is used as
an offset from one pimped outa than tha arrayz maximum index (so a subcript
of -1 refers ta tha last element of tha array).
To explicitly declare a indexed array, use
.B declare \-a \fIname\fP
(see
.SM
.B SHELL BUILTIN COMMANDS
below).
.B declare \-a \fIname\fP[\fIsubscript\fP]
is also accepted; tha \fIsubscript\fP is ignored.
.PP
Associatizzle arrays is pimped using
.BR "declare \-A \fIname\fP" .
.PP
Attributes may be
specified fo' a array variable rockin the
.B declare
and
.B readonly
builtins.  Each attribute applies ta all thugz of a array.
.PP
Arrays is assigned ta rockin compound assignmentz of tha form
\fIname\fP=\fB(\fPvalue\fI1\fP ... value\fIn\fP\fB)\fP, where each
\fIvalue\fP iz of tha form [\fIsubscript\fP]=\fIstring\fP.
Indexed array assignments do not require tha bracket n' subscript.
When assignin ta indexed arrays, if tha optionizzle brackets n' subscript
are supplied, dat index be assigned to;
otherwise tha index of tha element assigned is tha last index assigned
to by tha statement plus one.  Indexin starts at zero.
.PP
When assignin ta a associatizzle array, tha subscript is required.
.PP
This syntax be also accepted by the
.B declare
builtin. I aint talkin' bout chicken n' gravy biatch.  Individual array elements may be assigned ta rockin the
\fIname\fP[\fIsubscript\fP]=\fIvalue\fP syntax introduced above.
.PP
Any element of a array may be referenced using
${\fIname\fP[\fIsubscript\fP]}.  Da braces is required ta avoid
conflicts wit pathname expansion. I aint talkin' bout chicken n' gravy biatch.  If
\fIsubscript\fP is \fB@\fP or \fB*\fP, tha word expandz to
all thugz of \fIname\fP.  These subscripts differ only when the
word appears within double quotes.  If tha word is double-quoted,
${\fIname\fP[*]} expandz ta a single
word wit tha value of each array member separated by tha first
characta of the
.SM
.B IFS
special variable, n' ${\fIname\fP[@]} expandz each element of
\fIname\fP ta a separate word. Y'all KNOW dat shit, muthafucka!  When there be no array members,
${\fIname\fP[@]} expandz ta nothing.
If tha double-quoted expansion occurs within a word, tha expansion of
the first parameta is joined wit tha beginnin part of tha original
word, n' tha expansion of tha last parameta is joined wit tha last
part of tha original gangsta word.
This be analogous ta tha expansion
of tha special parametas \fB*\fP n' \fB@\fP (see
.B Special Parameters
above).  ${#\fIname\fP[\fIsubscript\fP]} expandz ta tha length of
${\fIname\fP[\fIsubscript\fP]}.  If \fIsubscript\fP is \fB*\fP or
\fB@\fP, tha expansion is tha number of elements up in tha array.
Referencin a array variable without a subscript is equivalent to
referencin tha array wit a subscript of 0.
.PP
An array variable is considered set if a subscript has been assigned a
value.  Da null strang be a valid value.
.PP
The
.B unset
builtin is used ta destroy arrays.  \fBunset\fP \fIname\fP[\fIsubscript\fP]
destroys tha array element at index \fIsubscript\fP.
Care must be taken ta avoid unwanted side effects caused by pathname
expansion.
\fBunset\fP \fIname\fP, where \fIname\fP be a array, or
\fBunset\fP \fIname\fP[\fIsubscript\fP], where
\fIsubscript\fP is \fB*\fP or \fB@\fP, removes tha entire array.
.PP
The
.BR declare ,
.BR local ,
and
.B readonly
builtins each accept a
.B \-a
option ta specify a indexed array n' a
.B \-A
option ta specify a associatizzle array.
If both options is supplied, 
.B \-A
takes precedence.
The
.B read
builtin accepts a
.B \-a
option ta assign a list of lyrics read from tha standard input
to a array.  The
.B set
and
.B declare
builtins display array joints up in a way dat allows dem ta be
reused as assignments.
.SH EXPANSION
Expansion is performed on tha command line afta it has been split into
words.  There is seven kindz of expansion performed:
.IR "brace expansion" ,
.IR "tilde expansion" ,
.IR "parameta n' variable expansion" ,
.IR "command substitution" ,
.IR "arithmetic expansion" ,
.IR "word splitting" ,
and
.IR "pathname expansion" .
.PP
Da order of expansions is: brace expansion, tilde expansion,
parameter, variable n' arithmetic expansion and
command substitution
(done up in a left-to-right fashion), word splitting, n' pathname
expansion.
.PP
On systems dat can support it, there be a additionizzle expansion
available: \fIprocess substitution\fP.
.PP
Only brace expansion, word splitting, n' pathname expansion
can chizzle tha number of lyrics of tha expansion; other expansions
expand a single word ta a single word.
Da only exceptions ta dis is tha expansions of
"\fB$@\fP" n' "\fB${\fP\fIname\fP\fB[@]}\fP"
as explained above (see
.SM
.BR PARAMETERS ).
.SS Brace Expansion
.PP
.I "Brace expansion"
is a mechanizzle by which arbitrary strings
may be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This mechanizzle is similar to
\fIpathname expansion\fP yo, but tha filenames generated
need not exist.  Patterns ta be brace expanded take
the form of a optional
.IR preamble ,
followed by either a seriez of comma-separated strings or
a sequence expression between a pair of braces, followed by
an optional
.IR postscript .
Da preamble is prefixed ta each strang contained
within tha braces, n' tha postscript is then appended
to each resultin string, expandin left ta right.
.PP
Brace expansions may be nested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da thangs up in dis biatch of each expanded
strin is not sorted; left ta right order is preserved.
For example, a\fB{\fPd,c,b\fB}\fPe expandz tha fuck into `ade ace abe'.
.PP
A sequence expression takes tha form
\fB{\fP\fIx\fP\fB..\fP\fIy\fP\fB[..\fP\fIincr\fP\fB]}\fP,
where \fIx\fP n' \fIy\fP is either integers or single characters,
and \fIincr\fP, a optionizzle increment, be a integer.
When integers is supplied, tha expression expandz ta each number between
\fIx\fP n' \fIy\fP, inclusive.
Supplied integers may be prefixed wit \fI0\fP ta force each term ta have the
same width.  When either \fIx\fP or \fPy\fP begins wit a zero, tha shell
attempts ta force all generated terms ta contain tha same number of digits,
zero-paddin where necessary.
When charactas is supplied, tha expression expandz ta each character
lexicographically between \fIx\fP n' \fIy\fP, inclusive.  Note that
both \fIx\fP n' \fIy\fP must be of tha same type.
When tha increment is supplied, it is used as tha difference between
each term.  Da default increment is 1 or -1 as appropriate.
.PP
Brace expansion is performed before any other expansions,
and any charactas special ta other expansions is preserved
in tha result.  It be strictly textual.
.B Bash
does not apply any syntactic interpretation ta tha context of the
expansion or tha text between tha braces.
.PP
A erectly-formed brace expansion must contain unquoted opening
and closin braces, n' at least one unquoted comma or a valid
sequence expression.
Any incorrectly formed brace expansion is left unchanged.
A \fB{\fP or \fB,\fP may be quoted wit a funky-ass backslash ta prevent its
bein considered part of a funky-ass brace expression.
To avoid conflicts wit parameta expansion, tha strang \fB${\fP
is not considered eligible fo' brace expansion.
.PP
This construct is typically used as shorthand when tha common
prefix of tha strings ta be generated is longer than up in the
above example:
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
or
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
Brace expansion introduces a slight incompatibilitizzle with
historical versions of
.BR sh .
.B sh
does not treat openin or closin braces specially when they
appear as part of a word, n' preserves dem up in tha output.
.B Bash
removes braces from lyrics as a cold-ass lil consequence of brace
expansion. I aint talkin' bout chicken n' gravy biatch.  For example, a word entered to
.B sh
as \fIfile{1,2}\fP
appears identically up in tha output.  Da same word is
output as
.I file1 file2
afta expansion by
.BR bash .
If strict compatibilitizzle with
.B sh
is desired, start
.B bash
with the
.B +B 
option or disable brace expansion wit the
.B +B
option ta the
.B set
command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.SS Tilde Expansion
.PP
If a word begins wit a unquoted tilde characta (`\fB~\fP'), all of
the charactas precedin tha straight-up original gangsta unquoted slash (or all characters,
if there is no unquoted slash) is considered a \fItilde-prefix\fP.
If none of tha charactas up in tha tilde-prefix is quoted, the
charactas up in tha tilde-prefix followin tha tilde is treated as a
possible \fIlogin name\fP.
If dis login name is tha null string, tha tilde is replaced wit the
value of tha shell parameter
.SM
.BR HOME .
If
.SM
.B HOME
is unset, tha home directory of tha user executin tha shell is
substituted instead.
Otherwise, tha tilde-prefix is replaced wit tha home directory
associated wit tha specified login name.
.PP
If tha tilde-prefix be a `~+', tha value of tha shell variable
.SM
.B PWD
replaces tha tilde-prefix.
If tha tilde-prefix be a `~\-', tha value of tha shell variable
.SM
.BR OLDPWD ,
if it is set, is substituted.
If tha charactas followin tha tilde up in tha tilde-prefix consist
of a number \fIN\fP, optionally prefixed
by a `+' or a `\-', tha tilde-prefix is replaced wit tha corresponding
element from tha directory stack, as it would be displayed by the
.B dirs
builtin invoked wit tha tilde-prefix as a argument.
If tha charactas followin tha tilde up in tha tilde-prefix consist of a
number without a leadin `+' or `\-', `+' be assumed.
.PP
If tha login name is invalid, or tha tilde expansion fails, tha word
is unchanged.
.PP
Each variable assignment is checked fo' unquoted tilde-prefixes immediately
followin a
.B :
or tha first
.BR = .
In these cases, tilde expansion be also performed.
Consequently, one may use file names wit tildes up in assignments to
.SM
.BR PATH ,
.SM
.BR MAILPATH ,
and
.SM
.BR CDPATH ,
and tha shell assigns tha expanded value.
.SS Parameta Expansion
.PP
Da `\fB$\fP' characta introduces parameta expansion,
command substitution, or arithmetic expansion. I aint talkin' bout chicken n' gravy biatch.  Da parameta name
or symbol ta be expanded may be enclosed up in braces, which
are optionizzle but serve ta protect tha variable ta be expanded from
charactas immediately followin it which could be
interpreted as part of tha name.
.PP
When braces is used, tha matchin endin brace is tha straight-up original gangsta `\fB}\fP'
not escaped by a funky-ass backslash or within a quoted string, n' not within an
embedded arithmetic expansion, command substitution, or parameter
expansion.
.PP
.PD 0
.TP
${\fIparameter\fP}
Da value of \fIparameter\fP is substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da braces is required
when
.I parameter
is a positionizzle parameta wit mo' than one digit,
or when
.I parameter
is followed by a cold-ass lil characta which aint ta be
interpreted as part of its name.
.PD
.PP
If tha straight-up original gangsta characta of \fIparameter\fP be a exclamation point (\fB!\fP),
a level of variable indirection is introduced.
\fBBash\fP uses tha value of tha variable formed from tha rest of
\fIparameter\fP as tha name of tha variable; dis variable is then
expanded n' dat value is used up in tha rest of tha substitution, rather
than tha value of \fIparameter\fP itself.
This is known as \fIindirect expansion\fP.
Da exceptions ta dis is tha expansionz of ${\fB!\fP\fIprefix\fP\fB*\fP} and
${\fB!\fP\fIname\fP[\fI@\fP]} busted lyrics bout below.
Da exclamation point must immediately follow tha left brace up in order to
introduce indirection.
.PP
In each of tha cases below, \fIword\fP is subject ta tilde expansion,
parameta expansion, command substitution, n' arithmetic expansion.
.PP
When not struttin substrin expansion, rockin tha forms documented below,
\fBbash\fP tests fo' a parameta dat is unset or null.  Omittin tha colon
results up in a test only fo' a parameta dat is unset.
.PP
.PD 0
.TP
${\fIparameter\fP\fB:\-\fP\fIword\fP}
\fBUse Default Values\fP.  If
.I parameter
is unset or null, tha expansion of
.I word
is substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Otherwise, tha value of
.I parameter
is substituted.
.TP
${\fIparameter\fP\fB:=\fP\fIword\fP}
\fBAssign Default Values\fP.
If
.I parameter
is unset or null, tha expansion of
.I word
is assigned to
.IR parameta .
Da value of
.I parameter
is then substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Positionizzle parametas n' special parametas may
not be assigned ta up in dis way.
.TP
${\fIparameter\fP\fB:?\fP\fIword\fP}
\fBDisplay Error if Null or Unset\fP.
If
.I parameter
is null or unset, tha expansion of \fIword\fP (or a message ta dat effect
if
.I word
is not present) is freestyled ta tha standard error n' tha shell, if it
is not interactive, exits, n' you can put dat on yo' toast.  Otherwise, tha value of \fIparameter\fP is
substituted.
.TP
${\fIparameter\fP\fB:+\fP\fIword\fP}
\fBUse Alternate Value\fP.
If
.I parameter
is null or unset, not a god damn thang is substituted, otherwise tha expansion of
.I word
is substituted.
.TP
${\fIparameter\fP\fB:\fP\fIoffset\fP}
.PD 0
.TP
${\fIparameter\fP\fB:\fP\fIoffset\fP\fB:\fP\fIlength\fP}
.PD
\fBSubstrin Expansion\fP.
Expandz ta up ta \fIlength\fP charactaz of \fIparameter\fP
startin all up in tha characta specified by \fIoffset\fP.
If \fIlength\fP is omitted, expandz ta tha substrin of
\fIparameter\fP startin all up in tha characta specified by \fIoffset\fP.
\fIlength\fP n' \fIoffset\fP is arithmetic expressions (see
.SM
.B
ARITHMETIC EVALUATION
below).
If \fIoffset\fP evaluates ta a number less than zero, tha value
is used as a offset from tha end of tha value of \fIparameter\fP.
If \fIlength\fP evaluates ta a number less than zero, n' \fIparameter\fP
is not \fB@\fP n' not a indexed or associatizzle array, it is interpreted
as a offset from tha end of tha value of \fIparameter\fP rather than
a number of characters, n' tha expansion is tha charactas between the
two offsets.
If \fIparameter\fP is \fB@\fP, tha result is \fIlength\fP positional
parametas beginnin at \fIoffset\fP.
If \fIparameter\fP be a indexed array name subscripted by @ or *,
the result is tha \fIlength\fP
thugz of tha array beginnin wit ${\fIparameter\fP[\fIoffset\fP]}.
A wack \fIoffset\fP is taken relatizzle ta one pimped outa than tha maximum
index of tha specified array.
Substrin expansion applied ta a associatizzle array produces undefined
results.
Note dat a wack offset must be separated from tha colon by at least
one space ta avoid bein trippin wit tha :- expansion.
Substrin indexin is zero-based unless tha positionizzle parametas 
are used, up in which case tha indexin starts at 1 by default.
If \fIoffset\fP is 0, n' tha positionizzle parametas is used, \fB$0\fP is
prefixed ta tha list.
.TP
${\fB!\fP\fIprefix\fP\fB*\fP}
.PD 0
.TP
${\fB!\fP\fIprefix\fP\fB@\fP}
.PD
\fBNames matchin prefix\fP.
Expandz ta tha namez of variablez whose names begin wit \fIprefix\fP,
separated by tha straight-up original gangsta characta of the
.SM
.B IFS
special variable.
When \fI@\fP is used n' tha expansion appears within double quotes, each
variable name expandz ta a separate word.
.TP
${\fB!\fP\fIname\fP[\fI@\fP]}
.PD 0
.TP
${\fB!\fP\fIname\fP[\fI*\fP]}
.PD
\fBList of array keys\fP.
If \fIname\fP be a array variable, expandz ta tha list of array indices
(keys) assigned up in \fIname\fP.
If \fIname\fP aint a array, expandz ta 0 if \fIname\fP is set n' null
otherwise.
When \fI@\fP is used n' tha expansion appears within double quotes, each
key expandz ta a separate word.
.TP
${\fB#\fP\fIparameter\fP}
\fBParameta length\fP.
Da length up in charactaz of tha value of \fIparameter\fP is substituted.
If
.I parameter
is
.B *
or 
.BR @ ,
the value substituted is tha number of positionizzle parameters.
If
.I parameter
is a array name subscripted by
.B *
or
.BR @ ,
the value substituted is tha number of elements up in tha array.
.TP
${\fIparameter\fP\fB#\fP\fIword\fP}
.PD 0
.TP
${\fIparameter\fP\fB##\fP\fIword\fP}
.PD
\fBRemove matchin prefix pattern\fP.
Da 
.I word
is expanded ta produce a pattern just as up in pathname
expansion. I aint talkin' bout chicken n' gravy biatch.  If tha pattern matches tha beginnin of
the value of
.IR parameta ,
then tha result of tha expansion is tha expanded value of
.I parameter
with tha shortest matchin pattern (the ``\fB#\fP'' case) or the
longest matchin pattern (the ``\fB##\fP'' case) deleted.
If
.I parameter
is
.B @
or
.BR * ,
the pattern removal operation be applied ta each positional
parameta up in turn, n' tha expansion is tha resultant list.
If
.I parameter
is a array variable subscripted with
.B @
or
.BR * ,
the pattern removal operation be applied ta each gangmember of the
array up in turn, n' tha expansion is tha resultant list.
.TP
${\fIparameter\fP\fB%\fP\fIword\fP}
.PD 0
.TP
${\fIparameter\fP\fB%%\fP\fIword\fP}
.PD
\fBRemove matchin suffix pattern\fP.
Da \fIword\fP is expanded ta produce a pattern just as in
pathname expansion.
If tha pattern matches a trailin portion of tha expanded value of
.IR parameta ,
then tha result of tha expansion is tha expanded value of
.I parameter
with tha shortest matchin pattern (the ``\fB%\fP'' case) or the
longest matchin pattern (the ``\fB%%\fP'' case) deleted.
If
.I parameter
is
.B @
or
.BR * ,
the pattern removal operation be applied ta each positional
parameta up in turn, n' tha expansion is tha resultant list.
If
.I parameter
is a array variable subscripted with
.B @
or
.BR * ,
the pattern removal operation be applied ta each gangmember of the
array up in turn, n' tha expansion is tha resultant list.
.TP
${\fIparameter\fP\fB/\fP\fIpattern\fP\fB/\fP\fIstring\fP}
\fBPattern substitution\fP.
Da \fIpattern\fP is expanded ta produce a pattern just as in
pathname expansion.
\fIParameter\fP is expanded n' tha longest match of \fIpattern\fP
against its value is replaced wit \fIstring\fP.
If \fIpattern\fP begins wit \fB/\fP, all matchez of \fIpattern\fP are
replaced wit \fIstring\fP.  Normally only tha straight-up original gangsta match is replaced.
If \fIpattern\fP begins wit \fB#\fP, it must match all up in tha beginning
of tha expanded value of \fIparameter\fP.
If \fIpattern\fP begins wit \fB%\fP, it must match all up in tha end
of tha expanded value of \fIparameter\fP.
If \fIstring\fP is null, matchez of \fIpattern\fP is deleted
and tha \fB/\fP followin \fIpattern\fP may be omitted.
If
.I parameter
is
.B @
or
.BR * ,
the substitution operation be applied ta each positional
parameta up in turn, n' tha expansion is tha resultant list.
If
.I parameter
is a array variable subscripted with
.B @
or
.BR * ,
the substitution operation be applied ta each gangmember of the
array up in turn, n' tha expansion is tha resultant list.
.TP
${\fIparameter\fP\fB^\fP\fIpattern\fP}
.PD 0
.TP
${\fIparameter\fP\fB^^\fP\fIpattern\fP}
.TP
${\fIparameter\fP\fB,\fP\fIpattern\fP}
.TP
${\fIparameter\fP\fB,,\fP\fIpattern\fP}
.PD
\fBCase modification\fP.
This expansion modifies tha case of alphabetic charactas up in \fIparameter\fP.
Da \fIpattern\fP is expanded ta produce a pattern just as in
pathname expansion.
Da \fB^\fP operator converts lowercase lettas matchin \fIpattern\fP
to uppercase; tha \fB,\fP operator converts matchin uppercase letters
to lowercase.
Da \fB^^\fP n' \fB,,\fP expansions convert each matched characta up in the
expanded value; tha \fB^\fP n' \fB,\fP expansions match n' convert only
the first characta up in tha expanded value.
If \fIpattern\fP is omitted, it is treated like a \fB?\fP, which matches
every character.
If
.I parameter
is
.B @
or
.BR * ,
the case modification operation be applied ta each positional
parameta up in turn, n' tha expansion is tha resultant list.
If
.I parameter
is a array variable subscripted with
.B @
or
.BR * ,
the case modification operation be applied ta each gangmember of the
array up in turn, n' tha expansion is tha resultant list.
.SS Command Substitution
.PP
\fICommand substitution\fP allows tha output of a cold-ass lil command ta replace
the command name.  There is two forms:
.RS
.PP
\fB$(\fP\fIcommand\fP\|\fB)\fP
.RE
or
.RS
\fB\`\fP\fIcommand\fP\fB\`\fP
.RE
.PP
.B Bash
performs tha expansion by executin \fIcommand\fP and
replacin tha command substitution wit tha standard output of the
command, wit any trailin newlines deleted.
Embedded newlines is not deleted yo, but they may be removed during
word splitting.
Da command substitution \fB$(cat \fIfile\fP)\fR can be replaced by
the equivalent but fasta \fB$(< \fIfile\fP)\fR.
.PP
When tha old-style backquote form of substitution is used,
backslash retains its literal meanin except when followed by
.BR $ ,
.BR \` ,
or
.BR \e .
Da first backquote not preceded by a funky-ass backslash terminates the
command substitution.
When rockin tha $(\^\fIcommand\fP\|) form, all charactas between the
parentheses make up tha command; none is treated specially.
.PP
Command substitutions may be nested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  To nest when rockin tha backquoted form,
escape tha inner backquotes wit backslashes.
.PP
If tha substitution appears within double quotes, word splittin and
pathname expansion is not performed on tha thangs up in dis biatch.
.SS Arithmetic Expansion
.PP
Arithmetic expansion allows tha evaluation of a arithmetic expression
and tha substitution of tha result.  Da format fo' arithmetic expansion is:
.RS
.PP
\fB$((\fP\fIexpression\fP\fB))\fP
.RE
.PP
The
.I expression
is treated as if it was within double quotes yo, but a thugged-out double quote
inside tha parentheses aint treated specially.
All tokens up in tha expression undergo parameta expansion, string
expansion, command substitution, n' quote removal.
Arithmetic expansions may be nested.
.PP
Da evaluation is performed accordin ta tha rulez listed below under
.SM
.BR "ARITHMETIC EVALUATION" .
If
.I expression
is invalid,
.B bash
prints a message indicatin failure n' no substitution occurs.
.SS Process Substitution
.PP
\fIProcess substitution\fP is supported on systems dat support named
pipes (\fIFIFOs\fP) or tha \fB/dev/fd\fP method of namin open files.
It takes tha form of
\fB<(\fP\fIlist\^\fP\fB)\fP
or
\fB>(\fP\fIlist\^\fP\fB)\fP.
Da process \fIlist\fP is run wit its input or output connected ta a
\fIFIFO\fP or some file up in \fB/dev/fd\fP.  Da name of dis file is
passed as a argument ta tha current command as tha result of the
expansion. I aint talkin' bout chicken n' gravy biatch.  If tha \fB>(\fP\fIlist\^\fP\fB)\fP form is used, freestylin to
the file will provide input fo' \fIlist\fP.  If the
\fB<(\fP\fIlist\^\fP\fB)\fP form is used, tha file passed as an
argument should be read ta obtain tha output of \fIlist\fP.
.PP
When available, process substitution is performed
simultaneously wit parameta n' variable expansion, 
command substitution,
and arithmetic expansion.
.SS Word Splitting
.PP
Da shell scans tha thangs up in dis biatch of
parameta expansion,
command substitution,
and
arithmetic expansion
that did not occur within double quotes for
.IR "word splitting" .
.PP
Da shell treats each characta of
.SM
.B IFS
as a thugged-out delimiter, n' splits tha thangs up in dis biatch of tha other
expansions tha fuck into lyrics on these characters.  If
.SM
.B IFS
is unset, or its
value is exactly
.BR <space><tab><newline> ,
the default, then
sequences of
.BR <space> ,
.BR <tab> ,
and
.B <newline>
at tha beginnin n' end of tha thangs up in dis biatch of tha previous
expansions is ignored, and
any sequence of
.SM
.B IFS
charactas not all up in tha beginnin or end serves ta delimit lyrics.
If
.SM
.B IFS
has a value other than tha default, then sequences of
the whitespace characters
.B space
and
.B tab
are ignored all up in tha beginnin n' end of the
word, as long as tha whitespace characta is up in the
value of
.SM
.BR IFS
(an
.SM
.B IFS
whitespace character).
Any characta in
.SM
.B IFS
that is not
.SM
.B IFS
whitespace, along wit any adjacent
.SM
.B IFS
whitespace characters, delimits a gangbangin' field.
A sequence of
.SM
.B IFS
whitespace charactas be also treated as a thugged-out delimiter.
If tha value of
.SM
.B IFS
is null, no word splittin occurs.
.PP
Explicit null arguments (\^\f3"\^"\fP or \^\f3\(aq\^\(aq\fP\^) is retained.
Unquoted implicit null arguments, resultin from tha expansion of
parametas dat have no joints, is removed.
If a parameta wit no value is expanded within double quotes, a
null argument thangs up in dis biatch n' is retained.
.PP
Note dat if no expansion occurs, no splitting
is performed.
.SS Pathname Expansion
.PP
Afta word splitting,
unless the
.B \-f
option has been set,
.B bash
scans each word fo' tha characters
.BR * ,
.BR , biatch? ,
and
.BR [ .
If one of these charactas appears, then tha word is
regarded as a
.IR pattern ,
and replaced wit a alphabetically sorted list of
file names matchin tha pattern.
If no matchin file names is found,
and tha shell option
.B nullglob
is not enabled, tha word is left unchanged.
If tha 
.B nullglob
option is set, n' no matches is found,
the word is removed.
If the
.B failglob
shell option is set, n' no matches is found, a error message
is printed n' tha command aint executed.
If tha shell option
.B nocaseglob
is enabled, tha match is performed without regard ta tha case
of alphabetic characters.
When a pattern is used fo' pathname expansion,
the character
.B ``.''
at tha start of a name or immediately followin a slash
must be matched explicitly, unless tha shell option
.B dotglob
is set.
When matchin a pathname, tha slash characta must always be
matched explicitly.
In other cases, the
.B ``.''
characta aint treated specially.
See tha description of
.B shopt
below under
.SM
.B SHELL BUILTIN COMMANDS
for a thugged-out description of the
.BR nocaseglob ,
.BR nullglob ,
.BR failglob ,
and
.B dotglob
shell options.
.PP
The
.SM
.B GLOBIGNORE
shell variable may be used ta restrict tha set of file names matchin a
.IR pattern .
If
.SM
.B GLOBIGNORE
is set, each matchin file name dat also matches one of tha patterns in
.SM
.B GLOBIGNORE
is removed from tha list of matches.
Da file names
.B ``.''
and
.B ``..''
are always ignored when
.SM
.B GLOBIGNORE
is set n' not null.  But fuck dat shiznit yo, tha word on tha street is dat setting
.SM
.B GLOBIGNORE
to a non-null value has tha effect of enablin the
.B dotglob
shell option, so all other file names beginnin wit a
.B ``.''
will match.
To git tha oldschool behavior of ignorin file names beginnin wit a
.BR ``.'' ,
make
.B ``.*''
one of tha patterns in
.SM
.BR GLOBIGNORE .
The
.B dotglob
option is disabled when
.SM
.B GLOBIGNORE
is unset.
.PP
\fBPattern Matching\fP
.PP
Any characta dat appears up in a pattern, other than tha special pattern
charactas busted lyrics bout below, matches itself.  Da NUL characta may not
occur up in a pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  A backslash escapes tha followin character; the
escapin backslash is discarded when matching.
Da special pattern charactas must be quoted if
they is ta be matched literally.
.PP
Da special pattern charactas have tha followin meanings:
.PP
.PD 0
.RS
.TP
.B *
Matches any string, includin tha null string.
When tha \fBglobstar\fP shell option is enabled, n' \fB*\fP is used in
a pathname expansion context, two adjacent \fB*\fPs used as a single
pattern will match all filez n' zero or mo' directories and
subdirectories.
If followed by a \fB/\fP, two adjacent \fB*\fPs will match only directories
and subdirectories.
.TP
.B ?
Matches any single character.
.TP
.B [...]
Matches any one of tha enclosed characters.  A pair of characters
separated by a hyphen denotes a
\fIrange expression\fP;
any characta dat sorts between dem two characters, inclusive,
usin tha current localez collatin sequence n' characta set,
is matched. Y'all KNOW dat shit, muthafucka!  If tha straight-up original gangsta characta followin the
.B [
is a
.B !
or a
.B ^
then any characta not enclosed is matched.
Da sortin order of charactas up in range expressions is determined by
the current locale n' tha value of the
.SM
.B LC_COLLATE
shell variable,
if set.
A 
.B \-
may be matched by includin it as tha straight-up original gangsta or last character
in tha set.
A
.B ]
may be matched by includin it as tha straight-up original gangsta character
in tha set.
.br
.if t .sp 0.5
.if n .sp 1
Within
.B [
and
.BR ] ,
\fIcharacta classes\fP can be specified rockin tha syntax
\fB[:\fP\fIclass\fP\fB:]\fP, where \fIclass\fP is one of the
followin classes defined up in tha POSIX standard:
.PP
.RS
.B
.if n alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit
.if t alnum   alpha   ascii   blank   cntrl   digit   graph   lower   print   punct   space   upper   word   xdigit
.br
A characta class matches any characta belongin ta dat class.
Da \fBword\fP characta class matches letters, digits, n' tha characta _.
.br
.if t .sp 0.5
.if n .sp 1
Within
.B [
and 
.BR ] ,
an \fIequivalence class\fP can be specified rockin tha syntax
\fB[=\fP\fIc\fP\fB=]\fP, which matches all charactas wit the
same collation weight (as defined by tha current locale) as
the characta \fIc\fP.
.br
.if t .sp 0.5
.if n .sp 1
Within
.B [
and 
.BR ] ,
the syntax \fB[.\fP\fIsymbol\fP\fB.]\fP matches tha collatin symbol
\fIsymbol\fP.
.RE
.RE
.PD
.PP
If tha \fBextglob\fP shell option is enabled rockin tha \fBshopt\fP
builtin, nuff muthafuckin extended pattern matchin operators is recognized.
In tha followin description, a \fIpattern-list\fP be a list of one
or mo' patterns separated by a \fB|\fP.
Composite patterns may be formed rockin one or mo' of tha following
sub-patterns:
.sp 1
.PD 0
.RS
.TP
\fB?(\fP\^\fIpattern-list\^\fP\fB)\fP
Matches zero or one occurrence of tha given patterns
.TP
\fB*(\fP\^\fIpattern-list\^\fP\fB)\fP
Matches zero or mo' occurrencez of tha given patterns
.TP
\fB+(\fP\^\fIpattern-list\^\fP\fB)\fP
Matches one or mo' occurrencez of tha given patterns
.TP
\fB@(\fP\^\fIpattern-list\^\fP\fB)\fP
Matches one of tha given patterns
.TP
\fB!(\fP\^\fIpattern-list\^\fP\fB)\fP
Matches anythang except one of tha given patterns
.RE
.PD
.SS Quote Removal
.PP
Afta tha precedin expansions, all unquoted occurrencez of the
characters
.BR \e ,
.BR \(aq ,
and \^\f3"\fP\^ dat did not result from one of tha above
expansions is removed.
.SH REDIRECTION
Before a cold-ass lil command is executed, its input n' output
may be
.I redirected
usin a special notation interpreted by tha shell.
Redirection may also be used ta open n' close filez fo' the
current shell execution environment.  Da followin redirection
operators may precede or step tha fuck up anywhere within a
.I simple command
or may follow a
.IR command .
Redirections is processed up in tha order they appear, from
left ta right.
.PP
Each redirection dat may be preceded by a gangbangin' file descriptor number
may instead be preceded by a word of tha form {\fIvarname\fP}.
In dis case, fo' each redirection operator except
>&- n' <&-, tha shell will allocate a gangbangin' file descriptor pimped outer
than 10 n' assign it ta \fIvarname\fP.  If >&- or <&- is preceded
by {\fIvarname\fP}, tha value of \fIvarname\fP defines tha file
descriptor ta close.
.PP
In tha followin descriptions, if tha file descriptor number is
omitted, n' tha straight-up original gangsta characta of tha redirection operator is
.BR < ,
the redirection refers ta tha standard input (file descriptor
0).  If tha straight-up original gangsta characta of tha redirection operator is
.BR > ,
the redirection refers ta tha standard output (file descriptor
1).
.PP
Da word followin tha redirection operator up in tha following
descriptions, unless otherwise noted, is subjected ta brace expansion,
tilde expansion, parameta expansion, command substitution, arithmetic
expansion, quote removal, pathname expansion, n' word splitting.
If it expandz ta mo' than one word,
.B bash
reports a error.
.PP
Note dat tha order of redirections is significant.  For example, 
the command
.RS
.PP
ls \fB>\fP dirlist 2\fB>&\fP1
.RE
.PP
directs both standard output n' standard error ta tha file 
.IR dirlist ,
while tha command
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP dirlist
.RE
.PP
directs only tha standard output ta file
.IR dirlist ,
because tha standard error was duplicated from tha standard output
before tha standard output was repimped up to
.IR dirlist .
.PP
\fBBash\fP handlez nuff muthafuckin filenames specially when they is used in
redirections, as busted lyrics bout up in tha followin table:
.RS
.PP
.PD 0
.TP
.B /dev/fd/\fIfd\fP
If \fIfd\fP be a valid integer, file descriptor \fIfd\fP is duplicated.
.TP
.B /dev/stdin
File descriptor 0 is duplicated.
.TP
.B /dev/stdout
File descriptor 1 is duplicated.
.TP
.B /dev/stderr
File descriptor 2 is duplicated.
.TP
.B /dev/tcp/\fIhost\fP/\fIport\fP
If \fIhost\fP be a valid hostname or Internizzle address, n' \fIport\fP
is a integer port number or steez name, \fBbash\fP attempts ta open
a TCP connection ta tha correspondin socket.
.TP
.B /dev/udp/\fIhost\fP/\fIport\fP
If \fIhost\fP be a valid hostname or Internizzle address, n' \fIport\fP
is a integer port number or steez name, \fBbash\fP attempts ta open
a UDP connection ta tha correspondin socket.
.PD
.RE
.PP
A failure ta open or create a gangbangin' file causes tha redirection ta fail.
.PP
Redirections rockin file descriptors pimped outa than 9 should be used with
care, as they may conflict wit file descriptors tha shell uses
internally.
.SS Redirectin Input
.PP
Redirection of input causes tha file whose name thangs up in dis biatch from
the expansion of
.I word
to be opened fo' readin on file descriptor
.IR n ,
or tha standard input (file descriptor 0) if
.I n
is not specified.
.PP
Da general format fo' redirectin input is:
.RS
.PP
[\fIn\fP]\fB<\fP\fIword\fP
.RE
.SS Redirectin Output
.PP
Redirection of output causes tha file whose name thangs up in dis biatch from
the expansion of
.I word
to be opened fo' freestylin on file descriptor
.IR n ,
or tha standard output (file descriptor 1) if
.I n
is not specified. Y'all KNOW dat shit, muthafucka!  If tha file do not exist it is pimped;
if it do exist it is truncated ta zero size.
.PP
Da general format fo' redirectin output is:
.RS
.PP
[\fIn\fP]\fB>\fP\fIword\fP
.RE
.PP
If tha redirection operator is
.BR > ,
and the
.B noclobber
option ta the
.B set
builtin has been enabled, tha redirection will fail if tha file
whose name thangs up in dis biatch from tha expansion of \fIword\fP exists n' is
a regular file.
If tha redirection operator is
.BR >| ,
or tha redirection operator is
.B >
and the
.B noclobber
option ta the
.B set
builtin command aint enabled, tha redirection be attempted even
if tha file named by \fIword\fP exists.
.SS Appendin Repimped up Output
.PP
Redirection of output up in dis fashion
causes tha file whose name thangs up in dis biatch from
the expansion of
.I word
to be opened fo' appendin on file descriptor
.IR n ,
or tha standard output (file descriptor 1) if
.I n
is not specified. Y'all KNOW dat shit, muthafucka!  If tha file do not exist it is pimped.
.PP
Da general format fo' appendin output is:
.RS
.PP
[\fIn\fP]\fB>>\fP\fIword\fP
.RE
.PP
.SS Redirectin Standard Output n' Standard Error
.PP
This construct allows both the
standard output (file descriptor 1) and
the standard error output (file descriptor 2)
to be repimped up ta tha file whose name is the
expansion of
.IR word .
.PP
There is two formats fo' redirectin standard output and
standard error:
.RS
.PP
\fB&>\fP\fIword\fP
.RE
and
.RS
\fB>&\fP\fIword\fP
.RE
.PP
Of tha two forms, tha straight-up original gangsta is preferred.
This is semantically equivalent to
.RS
.PP
\fB>\fP\fIword\fP 2\fB>&\fP1
.RE
.PP
.SS Appendin Standard Output n' Standard Error
.PP
This construct allows both the
standard output (file descriptor 1) and
the standard error output (file descriptor 2)
to be appended ta tha file whose name is the
expansion of
.IR word .
.PP
Da format fo' appendin standard output n' standard error is:
.RS
.PP
\fB&>>\fP\fIword\fP
.RE
.PP
This is semantically equivalent to
.RS
.PP
\fB>>\fP\fIword\fP 2\fB>&\fP1
.RE
.SS Here Documents
.PP
This type of redirection instructs tha shell ta read input from the
current source until a line containin only
.I delimiter
(with no trailin blanks)
is seen. I aint talkin' bout chicken n' gravy biatch.  All of
the lines read up ta dat point is then used as tha standard
input fo' a cold-ass lil command.
.PP
Da format of here-documents is:
.RS
.PP
.nf
\fB<<\fP[\fB\-\fP]\fIword\fP
        \fIhere-document\fP
\fIdelimiter\fP
.fi
.RE
.PP
No parameta expansion, command substitution, arithmetic expansion,
or pathname expansion is performed on
.IR word .
If any charactas in
.I word
are quoted, the
.I delimiter
is tha result of quote removal on
.IR word ,
and tha lines up in tha here-document is not expanded.
If \fIword\fP is unquoted,
all linez of tha here-document is subjected ta parameta expansion,
command substitution, n' arithmetic expansion. I aint talkin' bout chicken n' gravy biatch.  In tha latter
case, tha characta sequence
.B \e<newline>
is ignored, and
.B \e
must be used ta quote tha characters
.BR \e ,
.BR $ ,
and
.BR \` .
.PP
If tha redirection operator is
.BR <<\- ,
then all leadin tab charactas is stripped from input lines n' the
line containing
.IR delimita .
This allows
here-documents within shell scripts ta be indented up in a
natural fashion.
.SS "Here Strings"
A variant of here documents, tha format is:
.RS
.PP
.nf
\fB<<<\fP\fIword\fP
.fi
.RE
.PP
Da \fIword\fP is expanded n' supplied ta tha command on its standard
input.
.SS "Duplicatin File Descriptors"
.PP
Da redirection operator
.RS
.PP
[\fIn\fP]\fB<&\fP\fIword\fP
.RE
.PP
is used ta duplicate input file descriptors.
If
.I word
expandz ta one or mo' digits, tha file descriptor denoted by
.I n
is made ta be a cold-ass lil copy of dat file descriptor.
If tha digits in
.I word
do not specify a gangbangin' file descriptor open fo' input, a redirection error occurs.
If
.I word
evaluates to
.BR \- ,
file descriptor
.I n
is closed. Y'all KNOW dat shit, muthafucka!  If
.I n
is not specified, tha standard input (file descriptor 0) is used.
.PP
Da operator
.RS
.PP
[\fIn\fP]\fB>&\fP\fIword\fP
.RE
.PP
is used similarly ta duplicate output file descriptors.  If
.I n
is not specified, tha standard output (file descriptor 1) is used.
If tha digits in
.I word
do not specify a gangbangin' file descriptor open fo' output, a redirection error occurs.
As a special case, if \fIn\fP is omitted, n' \fIword\fP do not
expand ta one or mo' digits, tha standard output n' standard
error is repimped up as busted lyrics bout previously.
.SS "Movin File Descriptors"
.PP
Da redirection operator
.RS
.PP
[\fIn\fP]\fB<&\fP\fIdigit\fP\fB\-\fP
.RE
.PP
moves tha file descriptor \fIdigit\fP ta file descriptor
.IR n ,
or tha standard input (file descriptor 0) if \fIn\fP aint specified.
\fIdigit\fP is closed afta bein duplicated ta \fIn\fP.
.PP
Similarly, tha redirection operator
.RS
.PP
[\fIn\fP]\fB>&\fP\fIdigit\fP\fB\-\fP
.RE
.PP
moves tha file descriptor \fIdigit\fP ta file descriptor
.IR n ,
or tha standard output (file descriptor 1) if \fIn\fP aint specified.
.SS "Openin File Descriptors fo' Readin n' Writing"
.PP
Da redirection operator
.RS
.PP
[\fIn\fP]\fB<>\fP\fIword\fP
.RE
.PP
causes tha file whose name is tha expansion of
.I word
to be opened fo' both readin n' freestylin on file descriptor
.IR n ,
or on file descriptor 0 if
.I n
is not specified. Y'all KNOW dat shit, muthafucka!  If tha file do not exist, it is pimped.
.SH ALIASES
\fIAliases\fP allow a strang ta be substituted fo' a word when it is used
as tha straight-up original gangsta word of a simple command.
Da shell maintains a list of aliases dat may be set n' unset wit the
.B alias
and
.B unalias
builtin commandz (see
.SM
.B SHELL BUILTIN COMMANDS
below).
Da first word of each simple command, if unquoted,
is checked ta peep if it has an
alias.  If so, dat word is replaced by tha text of tha alias.
Da charactas \fB/\fP, \fB$\fP, \fB\`\fP, n' \fB=\fP and
any of tha shell \fImetacharacters\fP or quotin characters
listed above may not step tha fuck up in a alias name.
Da replacement text may contain any valid shell input,
includin shell metacharacters.
Da first word of tha replacement text is tested
for aliases yo, but a word dat is identical ta a alias bein expanded
is not expanded a second time.
This means dat one may alias
.B ls
to
.BR "ls \-F" ,
for instance, and
.B bash
does not try ta recursively expand tha replacement text.
If tha last characta of tha alias value be a
.IR blank ,
then tha next command
word followin tha alias be also checked fo' alias expansion.
.PP
Aliases is pimped n' listed wit the
.B alias
command, n' removed wit the
.B unalias
command.
.PP
There is no mechanizzle fo' rockin arguments up in tha replacement text.
If arguments is needed, a gangbangin' finger-lickin' dirty-ass shell function should be used (see
.SM
.B FUNCTIONS
below).
.PP
Aliases is not expanded when tha shell aint interactive, unless
the
.B expand_aliases
shell option is set using
.B shopt
(see tha description of
.B shopt
under
.SM
\fBSHELL BUILTIN COMMANDS\fP
below).
.PP
Da rulez concernin tha definizzle n' use of aliases are
somewhat confusing.
.B Bash
always readz at least one complete line
of input before executin any
of tha commandz on dat line.  Aliases is expanded when a
command is read, not when it is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Therefore, an
alias definizzle appearin on tha same line as another
command do not take effect until tha next line of input is read.
Da commandz followin tha alias definition
on dat line is not affected by tha freshly smoked up alias.
This behavior be also a issue when functions is executed.
Aliases is expanded when a gangbangin' function definizzle is read,
not when tha function is executed, cuz a gangbangin' function definition
is itself a cold-ass lil compound command. Y'all KNOW dat shit, muthafucka!  As a cold-ass lil consequence, aliases
defined up in a gangbangin' function is not available until afta that
function is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  To be safe, always put
alias definitions on a separate line, n' do not use
.B alias
in compound commands.
.PP
For almost every last muthafuckin purpose, aliases is superseded by
shell functions.
.SH FUNCTIONS
A shell function, defined as busted lyrics bout above under
.SM
.BR "SHELL GRAMMAR" ,
stores a seriez of commandz fo' lata execution.
When tha name of a gangbangin' finger-lickin' dirty-ass shell function is used as a simple command name,
the list of commandz associated wit dat function name is executed.
Functions is executed up in tha context of the
current shell; no freshly smoked up process is pimped ta interpret
them (contrast dis wit tha execution of a gangbangin' finger-lickin' dirty-ass shell script).
When a gangbangin' function is executed, tha arguments ta the
function become tha positionizzle parameters
durin its execution.
Da special parameter
.B #
is updated ta reflect tha chizzle.  Special parameta \fB0\fP
is unchanged.
Da first element of the
.SM
.B FUNCNAME
variable is set ta tha name of tha function while tha function
is executing.
.PP
All other aspectz of tha shell execution
environment is identical between a gangbangin' function n' its caller
with these exceptions:  the
.SM
.B DEBUG
and
.B RETURN
traps (see tha description of the
.B trap
builtin under
.SM
.B SHELL BUILTIN COMMANDS
below) is not inherited unless tha function has been given the
\fBtrace\fP attribute (see tha description of the
.SM
.B declare
builtin below) or the
\fB\-o functrace\fP shell option has been enabled with
the \fBset\fP builtin
(in which case all functions inherit tha \fBDEBUG\fP n' \fBRETURN\fP traps),
and the
.SM
.B ERR
trap aint inherited unless tha \fB\-o errtrace\fP shell option has
been enabled.
.PP
Variablez local ta tha function may be declared wit the
.B local
builtin command. Y'all KNOW dat shit, muthafucka!  Ordinarily, variablez n' they joints
are shared between tha function n' its caller.
.PP
Da \fBFUNCNEST\fP variable, if set ta a numeric value pimped outer
than 0, defines a maximum function nestin level.  Function
invocations dat exceed tha limit cause tha entire command to
abort.
.PP
If tha builtin command
.B return
is executed up in a gangbangin' function, tha function completes and
execution resumes wit tha next command afta tha function
call.
Any command associated wit tha \fBRETURN\fP trap is executed
before execution resumes.
When a gangbangin' function completes, tha jointz of the
positionizzle parametas n' tha special parameter
.B #
are restored ta tha joints they had prior ta tha function's
execution.
.PP
Function names n' definitions may be listed wit the
.B \-f
option ta the
.B declare
or
.B typeset
builtin commands.  The
.B \-F
option to
.B declare
or
.B typeset
will list tha function names only
(and optionally tha source file n' line number, if tha \fBextdebug\fP
shell option is enabled).
Functions may be exported so dat subshells
automatically have dem defined wit the
.B \-f
option ta tha 
.B export
builtin.
A function definizzle may be deleted rockin tha \fB\-f\fP option to
the
.B unset
builtin.
Note dat shell functions n' variablez wit tha same name may result
in multiple identically-named entries up in tha environment passed ta the
shellz lil' thugs.
Care should be taken up in cases where dis may cause a problem.
.PP
Functions may be recursive.
Da \fBFUNCNEST\fP variable may be used ta limit tha depth of the
function call stack n' restrict tha number of function invocations.
By default, no limit is imposed on tha number of recursive calls.
.SH "ARITHMETIC EVALUATION"
Da shell allows arithmetic expressions ta be evaluated, under
certain circumstances (see tha \fBlet\fP n' \fBdeclare\fP builtin
commandz n' \fBArithmetic Expansion\fP).
Evaluation is done up in fixed-width integers wit no check fo' overflow,
though division by 0 is trapped n' flagged as a error.
Da operators n' they precedence, associativity, n' joints
are tha same as up in tha C language.
Da followin list of operators is grouped tha fuck into levels of
equal-precedence operators.
Da levels is listed up in order of decreasin precedence.
.PP
.PD 0
.TP
.B \fIid\fP++ \fIid\fP\-\-
variable post-increment n' post-decrement
.TP
.B ++\fIid\fP \-\-\fIid\fP
variable pre-increment n' pre-decrement
.TP
.B \- +
unary minus n' plus
.TP
.B ! ~
logical n' bitwise negation
.TP
.B **
exponentiation
.TP
.B * / %
multiplication, division, remainder
.TP
.B + \-
addition, subtraction
.TP
.B << >>
left n' right bitwise shifts
.TP
.B <= >= < >
comparison
.TP
.B == !=
equalitizzle n' inequality
.TP
.B &
bitwise AND
.TP
.B ^
bitwise exclusive OR
.TP
.B |
bitwise OR
.TP
.B &&
logical AND
.TP
.B ||
logical OR
.TP
.B \fIexpr\fP?\fIexpr\fP:\fIexpr\fP
conditionizzle operator
.TP
.B = *= /= %= += \-= <<= >>= &= ^= |=
assignment
.TP
.B \fIexpr1\fP , \fIexpr2\fP
comma
.PD
.PP
Shell variablez is allowed as operands; parameta expansion is
performed before tha expression is evaluated.
Within a expression, shell variablez may also be referenced by name
without rockin tha parameta expansion syntax.
A shell variable dat is null or unset evaluates ta 0 when referenced
by name without rockin tha parameta expansion syntax.
Da value of a variable is evaluated as a arithmetic expression
when it is referenced, or when a variable which has been given the
\fIinteger\fP attribute rockin \fBdeclare -i\fP be assigned a value.
A null value evaluates ta 0.
A shell variable need not have its \fIinteger\fP attribute
turned on ta be used up in a expression.
.PP
Constants wit a leadin 0 is interpreted as octal numbers.
A leadin 0x or 0X denotes hexadecimal.
Otherwise, numbers take tha form [\fIbase#\fP]n, where tha optionizzle \fIbase\fP
is a thugged-out decimal number between 2 n' 64 representin tha arithmetic
base, n' \fIn\fP be a number up in dat base.
If \fIbase#\fP is omitted, then base 10 is used.
Da digits pimped outa than 9 is represented by tha lowercase letters,
the uppercase letters, @, n' _, up in dat order.
If \fIbase\fP is less than or equal ta 36, lowercase n' uppercase
lettas may be used interchangeably ta represent numbers between 10
and 35.
.PP
Operators is evaluated up in order of precedence.  Sub-expressions in
parentheses is evaluated first n' may override tha precedence
rulez above.
.SH "CONDITIONAL EXPRESSIONS"
Conditionizzle expressions is used by tha \fB[[\fP compound command and
the \fBtest\fP n' \fB[\fP builtin commandz ta test file attributes
and big-ass up strang n' arithmetic comparisons.
Expressions is formed from tha followin unary or binary primaries.
If any \fIfile\fP argument ta one of tha primaries iz of tha form
\fI/dev/fd/n\fP, then file descriptor \fIn\fP is checked.
If tha \fIfile\fP argument ta one of tha primaries is one of
\fI/dev/stdin\fP, \fI/dev/stdout\fP, or \fI/dev/stderr\fP, file
descriptor 0, 1, or 2, respectively, is checked.
.PP
Unless otherwise specified, primaries dat operate on filez follow symbolic
links n' operate on tha target of tha link, rather than tha link itself.
.if t .sp 0.5
.if n .sp 1
When used wit \fB[[\fP, tha \fB<\fP n' \fB>\fP operators sort
lexicographically rockin tha current locale.
Da \fBtest\fP command sorts rockin ASCII ordering.
.sp 1
.PD 0
.TP
.B \-a \fIfile\fP
True if \fIfile\fP exists.
.TP
.B \-b \fIfile\fP
True if \fIfile\fP exists n' be a funky-ass block special file.
.TP
.B \-c \fIfile\fP
True if \fIfile\fP exists n' be a cold-ass lil characta special file.
.TP
.B \-d \fIfile\fP
True if \fIfile\fP exists n' be a gangbangin' finger-lickin' directory.
.TP
.B \-e \fIfile\fP
True if \fIfile\fP exists.
.TP
.B \-f \fIfile\fP
True if \fIfile\fP exists n' be a regular file.
.TP
.B \-g \fIfile\fP
True if \fIfile\fP exists n' is set-group-id.
.TP
.B \-h \fIfile\fP
True if \fIfile\fP exists n' be a symbolic link.
.TP
.B \-k \fIfile\fP
True if \fIfile\fP exists n' its ``sticky'' bit is set.
.TP
.B \-p \fIfile\fP
True if \fIfile\fP exists n' be a named pipe (FIFO).
.TP
.B \-r \fIfile\fP
True if \fIfile\fP exists n' is readable.
.TP
.B \-s \fIfile\fP
True if \fIfile\fP exists n' has a size pimped outa than zero.
.TP
.B \-t \fIfd\fP
True if file descriptor
.I fd
is open n' refers ta a terminal.
.TP
.B \-u \fIfile\fP
True if \fIfile\fP exists n' its set-user-id bit is set.
.TP
.B \-w \fIfile\fP
True if \fIfile\fP exists n' is writable.
.TP
.B \-x \fIfile\fP
True if \fIfile\fP exists n' is executable.
.TP
.B \-G \fIfile\fP
True if \fIfile\fP exists n' is owned by tha effectizzle crew id.
.TP
.B \-L \fIfile\fP
True if \fIfile\fP exists n' be a symbolic link.
.TP
.B \-N \fIfile\fP
True if \fIfile\fP exists n' has been modified since dat shiznit was last read.
.TP
.B \-O \fIfile\fP
True if \fIfile\fP exists n' is owned by tha effectizzle user id.
.TP
.B \-S \fIfile\fP
True if \fIfile\fP exists n' be a socket.
.TP
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
True if \fIfile1\fP n' \fIfile2\fP refer ta tha same thang and
inode numbers.
.TP
\fIfile1\fP \-\fBnt\fP \fIfile2\fP
True if \fIfile1\fP is newer (accordin ta modification date) than \fIfile2\fP,
or if \fIfile1\fP exists n' \fPfile2\fP do not.
.TP
\fIfile1\fP \-\fBot\fP \fIfile2\fP
True if \fIfile1\fP is olda than \fIfile2\fP, or if \fIfile2\fP exists
and \fIfile1\fP do not.
.TP
.B \-o \fIoptname\fP
True if tha shell option
.I optname
is enabled.
See tha list of options under tha description of the
.B \-o
option ta the
.B set
builtin below.
.TP
.B \-v \fIvarname\fP
True if tha shell variable
.I varname
is set (has been assigned a value).
.TP
.B \-z \fIstring\fP
True if tha length of \fIstring\fP is zero.
.TP
\fIstring\fP
.PD 0
.TP
.B \-n \fIstring\fP
.PD
True if tha length of
.I string
is non-zero.
.TP
\fIstring1\fP \fB==\fP \fIstring2\fP
.PD 0
.TP
\fIstring1\fP \fB=\fP \fIstring2\fP
.PD
True if tha strings is equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \fB=\fP should be used
with tha \fBtest\fP command fo' POSIX conformance.
.TP
\fIstring1\fP \fB!=\fP \fIstring2\fP
True if tha strings is not equal.
.TP
\fIstring1\fP \fB<\fP \fIstring2\fP
True if \fIstring1\fP sorts before \fIstring2\fP lexicographically.
.TP
\fIstring1\fP \fB>\fP \fIstring2\fP
True if \fIstring1\fP sorts afta \fIstring2\fP lexicographically.
.TP
.I \fIarg1\fP \fBOP\fP \fIarg2\fP
.SM
.B OP
is one of
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt ,
or
.BR \-ge .
These arithmetic binary operators return legit if \fIarg1\fP
is equal to, not equal to, less than, less than or equal to,
greata than, or pimped outa than or equal ta \fIarg2\fP, respectively.
.I Arg1
and
.I arg2
may be positizzle or wack integers.
.PD
.SH "SIMPLE COMMAND EXPANSION"
When a simple command is executed, tha shell performs tha following
expansions, assignments, n' redirections, from left ta right.
.IP 1.
Da lyrics dat tha parser has marked as variable assignments (those
precedin tha command name) n' redirections is saved fo' later
processing.
.IP 2.
Da lyrics dat is not variable assignments or redirections are
expanded. Y'all KNOW dat shit, muthafucka!  If any lyrics remain afta expansion, tha straight-up original gangsta word
is taken ta be tha name of tha command n' tha remainin lyrics are
the arguments.
.IP 3.
Redirections is performed as busted lyrics bout above under
.SM
.BR REDIRECTION .
.IP 4.
Da text afta tha \fB=\fP up in each variable assignment undergoes tilde
expansion, parameta expansion, command substitution, arithmetic expansion,
and quote removal before bein assigned ta tha variable.
.PP
If no command name thangs up in dis biatch, tha variable assignments affect tha current
shell environment.  Otherwise, tha variablez is added ta tha environment
of tha executed command n' do not affect tha current shell environment.
If any of tha assignments attempts ta assign a value ta a readonly variable,
an error occurs, n' tha command exits wit a non-zero status.
.PP
If no command name thangs up in dis biatch, redirections is performed yo, but do not
affect tha current shell environment.  A redirection error causes the
command ta exit wit a non-zero status.
.PP
If there be a cold-ass lil command name left afta expansion, execution proceedz as
busted lyrics bout below.  Otherwise, tha command exits, n' you can put dat on yo' toast.  If one of tha expansions
contained a cold-ass lil command substitution, tha exit statuz of tha command is
the exit statuz of tha last command substitution performed. Y'all KNOW dat shit, muthafucka!  If there
were no command substitutions, tha command exits wit a statuz of zero.
.SH "COMMAND EXECUTION"
Afta a cold-ass lil command has been split tha fuck into lyrics, if it thangs up in dis biatch up in a
simple command n' a optionizzle list of arguments, tha following
actions is taken.
.PP
If tha command name gotz nuff no slashes, tha shell attempts to
locate dat shit.  If there exists a gangbangin' finger-lickin' dirty-ass shell function by dat name, that
function is invoked as busted lyrics bout above in
.SM
.BR FUNCTIONS .
If tha name do not match a gangbangin' function, tha shell searches for
it up in tha list of shell builtins.  If a match is found, that
builtin is invoked.
.PP
If tha name is neither a gangbangin' finger-lickin' dirty-ass shell function nor a funky-ass builtin,
and gotz nuff no slashes,
.B bash
searches each element of the
.SM
.B PATH
for a gangbangin' finger-lickin' directory containin a executable file by dat name.
.B Bash
uses a hash table ta remember tha full pathnamez of executable
filez (see
.B hash
under
.SM
.B "SHELL BUILTIN COMMANDS"
below).
A full search of tha directories in
.SM
.B PATH
is performed only if tha command aint found up in tha hash table.
If tha search is unsuccessful, tha shell searches fo' a thugged-out defined shell
function named \fBcommand_not_found_handle\fP.
If dat function exists, it is invoked wit tha original gangsta command and
the original gangsta commandz arguments as its arguments, n' tha function's
exit status becomes tha exit statuz of tha shell.
If dat function aint defined, tha shell prints a error
message n' returns a exit statuz of 127.
.PP
If tha search is successful, or if tha command name gotz nuff
one or mo' slashes, tha shell executes tha named program up in a
separate execution environment.
Argument 0 is set ta tha name given, n' tha remainin arguments
to tha command is set ta tha arguments given, if any.
.PP
If dis execution fails cuz tha file aint up in executable
format, n' tha file aint a gangbangin' finger-lickin' directory, it be assumed ta be
a \fIshell script\fP, a gangbangin' file
containin shell commands.  A subshell is spawned ta execute
it.  This subshell reinitializes itself, so
that tha effect be as if a freshly smoked up shell had been invoked
to handle tha script, wit tha exception dat tha locations of
commandz remembered by tha parent (see
.B hash
below under
.SM
\fBSHELL BUILTIN COMMANDS\fP)
are retained by tha child.
.PP
If tha program be a gangbangin' file beginnin with
.BR #! ,
the remainder of tha straight-up original gangsta line specifies a interpreter
for tha program.  Da shell executes the
specified interpreta on operatin systems dat do not
handle dis executable format theyselves.  Da arguments ta tha 
interpreta consist of a single optionizzle argument followin the
interpreta name on tha straight-up original gangsta line of tha program, followed
by tha name of tha program, followed by tha command
arguments, if any.
.SH COMMAND EXECUTION ENVIRONMENT
Da shell has a \fIexecution environment\fP, which consistz of the
following:
.IP \(bu
open filez inherited by tha shell at invocation, as modified by
redirections supplied ta tha \fBexec\fP builtin
.IP \(bu
the current hustlin directory as set by \fBcd\fP, \fBpushd\fP, or
\fBpopd\fP, or inherited by tha shell at invocation
.IP \(bu
the file creation mode mask as set by \fBumask\fP or inherited from
the shellz parent
.IP \(bu
current traps set by \fBtrap\fP
.IP \(bu
shell parametas dat is set by variable assignment or wit \fBset\fP
or inherited from tha shellz parent up in tha environment
.IP \(bu
shell functions defined durin execution or inherited from tha shell's
parent up in tha environment
.IP \(bu
options enabled at invocation (either by default or wit command-line
arguments) or by \fBset\fP
.IP \(bu
options enabled by \fBshopt\fP
.IP \(bu
shell aliases defined wit \fBalias\fP
.IP \(bu
various process IDs, includin dem of background thangs, tha value
of \fB$$\fP, n' tha value of
.SM
.B PPID
.PP
When a simple command other than a funky-ass builtin or shell function
is ta be executed, it
is invoked up in a separate execution environment dat consists of
the following.  Unless otherwise noted, tha joints is inherited
from tha shell.
.if n .sp 1
.IP \(bu
the shellz open files, plus any modifications n' additions specified
by redirections ta tha command
.IP \(bu
the current hustlin directory
.IP \(bu
the file creation mode mask
.IP \(bu
shell variablez n' functions marked fo' export, along wit variables
exported fo' tha command, passed up in tha environment
.IP \(bu
traps caught by tha shell is reset ta tha joints inherited from the
shellz parent, n' traps ignored by tha shell is ignored
.PP
A command invoked up in dis separate environment cannot affect the
shellz execution environment. 
.PP
Command substitution, commandz grouped wit parentheses,
and asynchronous commandz is invoked up in a
subshell environment dat be a thugged-out duplicate of tha shell environment,
except dat traps caught by tha shell is reset ta tha joints
that tha shell inherited from its parent at invocation. I aint talkin' bout chicken n' gravy biatch.  Builtin
commandz dat is invoked as part of a pipeline is also executed up in a
subshell environment.  Chizzlez made ta tha subshell environment
cannot affect tha shellz execution environment.
.PP
Subshells spawned ta execute command substitutions inherit tha value of
the \fB\-e\fP option from tha parent shell.  When not up in \fIposix\fP mode,
\fBbash\fP clears tha \fB\-e\fP option up in such subshells.
.PP
If a cold-ass lil command is followed by a \fB&\fP n' thang control aint active, the
default standard input fo' tha command is tha empty file \fI/dev/null\fP.
Otherwise, tha invoked command inherits tha file descriptorz of tha calling
shell as modified by redirections.
.SH ENVIRONMENT
When a program is invoked it is given a array of strings
called the
.IR environment .
This be a list of 
\fIname\fP\-\fIvalue\fP pairs, of tha form
.IR "name\fR=\fPvalue" .
.PP
Da shell serves up nuff muthafuckin ways ta manipulate tha environment.
On invocation, tha shell scans its own environment and
creates a parameta fo' each name found, automatically marking
it for
.I export
to lil pimp processes.  Executed commandz inherit tha environment.
The
.B export
and
.B declare \-x
commandz allow parametas n' functions ta be added ta and
deleted from tha environment.  If tha value of a parameter
in tha environment is modified, tha freshly smoked up value becomes part
of tha environment, replacin tha old. Y'all KNOW dat shit, muthafucka!  Da environment
inherited by any executed command consistz of tha shell's
initial environment, whose joints may be modified up in tha shell,
less any pairs removed by the
.B unset
command, plus any additions via the
.B export
and
.B declare \-x
commands.
.PP
Da environment fo' any
.I simple command
or function may be augmented temporarily by prefixin it with
parameta assignments, as busted lyrics bout above in
.SM
.BR PARAMETERS .
These assignment statements affect only tha environment seen
by dat command.
.PP
If tha 
.B \-k
option is set (see the
.B set
builtin command below), then
.I all
parameta assignments is placed up in tha environment fo' a cold-ass lil command,
not just dem dat precede tha command name.
.PP
When
.B bash
invokes a external command, tha variable
.B _
is set ta tha full file name of tha command n' passed ta that
command up in its environment.
.SH "EXIT STATUS"
.PP
Da exit statuz of a executed command is tha value returned by the
\fIwaitpid\fP system call or equivalent function. I aint talkin' bout chicken n' gravy biatch.  Exit statuses
fall between 0 n' 255, though, as explained below, tha shell may
use joints above 125 specially.  Exit statuses from shell builtins and
compound commandz is also limited ta dis range. Under certain
circumstances, tha shell will use special joints ta indicate specific
failure modes.
.PP
For tha shellz purposes, a cold-ass lil command which exits wit a 
zero exit status has succeeded. Y'all KNOW dat shit, muthafucka!  An exit statuz of zero
indicates success.  A non-zero exit status indicates failure.
When a cold-ass lil command terminates on a gangbangin' fatal signal \fIN\fP, \fBbash\fP uses
the value of 128+\fIN\fP as tha exit status.
.PP
If a cold-ass lil command aint found, tha lil pimp process pimped to
execute it returns a statuz of 127.  If a cold-ass lil command is found
but aint executable, tha return status is 126.
.PP
If a cold-ass lil command fails cuz of a error durin expansion or redirection,
the exit status is pimped outa than zero.
.PP
Shell builtin commandz return a statuz of 0 (\fItrue\fP) if
successful, n' non-zero (\fIfalse\fP) if a error occurs
while they execute. 
All builtins return a exit statuz of 2 ta indicate incorrect usage.
.PP
\fBBash\fP itself returns tha exit statuz of tha last command
executed, unless a syntax error occurs, up in which case it exits
with a non-zero value.  See also tha \fBexit\fP builtin
command below.
.SH SIGNALS
When \fBbash\fP is interactive, up in tha absence of any traps, it ignores
.SM
.B SIGTERM
(so dat \fBkill 0\fP do not bust a cap up in a interactizzle shell),
and
.SM
.B SIGINT
is caught n' handled (so dat tha \fBwait\fP builtin is interruptible).
In all cases, \fBbash\fP ignores
.SM
.BR SIGQUIT .
If thang control is up in effect,
.B bash
ignores
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
and
.SM
.BR SIGTSTP .
.PP
Non-builtin commandz run by \fBbash\fP have signal handlezs
set ta tha joints inherited by tha shell from its parent.
When thang control aint up in effect, asynchronous commands
ignore
.SM
.B SIGINT
and
.SM
.B SIGQUIT
in addizzle ta these inherited handlezs.
Commandz run as a result of command substitution ignore the
keyboard-generated thang control signals
.SM
.BR SIGTTIN ,
.SM
.BR SIGTTOU ,
and
.SM
.BR SIGTSTP .
.PP
Da shell exits by default upon receipt of a
.SM
.BR SIGHUP .
Before exiting, a interactizzle shell resendz the
.SM
.B SIGHUP
to all thangs, hustlin or stopped.
Stopped thangs is sent
.SM
.B SIGCONT
to ensure dat they receive the
.SM
.BR SIGHUP .
To prevent tha shell from
sendin tha signal ta a particular thang, it should be removed from the
jobs table wit tha 
.B disown
builtin (see
.SM
.B "SHELL BUILTIN COMMANDS"
below) or marked 
to not receive
.SM
.B SIGHUP
using
.BR "disown \-h" .
.PP
If the
.B huponexit
shell option has been set with
.BR shopt ,
.B bash
sendz a 
.SM
.B SIGHUP
to all thangs when a interactizzle login shell exits.
.PP
If \fBbash\fP is waitin fo' a cold-ass lil command ta complete n' receives a signal
for which a trap has been set, tha trap aint gonna be executed until
the command completes. 
When \fBbash\fP is waitin fo' a asynchronous command via tha \fBwait\fP
builtin, tha reception of a signal fo' which a trap has been set will
cause tha \fBwait\fP builtin ta return immediately wit a exit status
greata than 128, immediately afta which tha trap is executed.
.SH "JOB CONTROL"
.I Thang control
refers ta tha mobilitizzle ta selectively stop (\fIsuspend\fP)
the execution of processes n' continue (\fIresume\fP)
their execution at a lata point.  A user typically employs
this facilitizzle via a interactizzle intercourse supplied jointly
by tha operatin system kernelz terminal driver and
.BR bash .
.PP
Da shell associates a
.I thang
with each pipeline.  It keeps a table of currently executing
jobs, which may be listed wit the
.B thangs
command. Y'all KNOW dat shit, muthafucka!  When
.B bash
starts a thang asynchronously (in the
.IR background ),
it prints a line dat looks like:
.RS
.PP
[1] 25647
.RE
.PP
indicatin dat dis thang is thang number 1 n' dat tha process ID
of tha last process up in tha pipeline associated wit dis thang is 25647.
All of tha processes up in a single pipeline is thugz of tha same thang.
.B Bash
uses the
.I thang
abstraction as tha basis fo' thang control.
.PP
To facilitate tha implementation of tha user intercourse ta thang
control, tha operatin system maintains tha notion of a \fIcurrent terminal
process crew ID\fP.  Memberz of dis process crew (processes whose
process crew ID is equal ta tha current terminal process crew ID)
receive keyboard-generated signals such as
.SM
.BR SIGINT .
These processes is holla'd ta be up in the
.IR foreground .
.I Background
processes is dem whose process crew ID differs from tha terminal's;
such processes is immune ta keyboard-generated signals.
Only foreground processes is allowed ta read from or, if the
user so specifies wit \f(CWstty tostop\fP, write ta the
terminal.
Background processes which attempt ta read from (write ta when
\f(CWstty tostop\fP is up in effect) the
terminal is busted a 
.SM
.B SIGTTIN (SIGTTOU)
signal by tha kernelz terminal driver, 
which, unless caught, suspendz tha process.
.PP
If tha operatin system on which
.B bash
is hustlin supports
job control,
.B bash
gotz nuff facilitizzles ta use dat shit.
Typin the
.I suspend
characta (typically
.BR ^Z ,
Control-Z) while a process is hustlin
causes dat process ta be stopped n' returns control ta 
.BR bash .
Typin the
.I "delayed suspend"
characta (typically
.BR ^Y ,
Control-Y) causes tha process ta be stopped when it
attempts ta read input from tha terminal, n' control to
be returned to
.BR bash .
Da user may then manipulate tha state of dis thang, rockin the
.B bg
command ta continue it up in tha background, the
.B fg
command ta continue it up in tha foreground, or
the
.B kill
command ta bust a cap up in dat shit.  A \fB^Z\fP takes effect immediately,
and has tha additionizzle side effect of causin pendin output
and typeahead ta be discarded.
.PP
There is a fuckin shitload of ways ta refer ta a thang up in tha shell.
Da character
.B %
introduces a thang justification (\fIjobspec\fP).  Thang number
.I n
may be referred ta as
.BR %n .
A thang may also be referred ta rockin a prefix of tha name used to
start it, or rockin a substrin dat appears up in its command line.
For example,
.B %ce
refers ta a stopped
.B ce
job.  If a prefix matches mo' than one thang,
.B bash
reports a error. Shiiit, dis aint no joke.  Using
.BR %?ce ,
on tha other hand, refers ta any thang containin tha string
.B ce
in its command line.  If tha substrin matches mo' than one thang,
.B bash
reports a error. Shiiit, dis aint no joke.  Da symbols
.B %%
and
.B %+
refer ta tha shellz notion of the
.IR "current thang" ,
which is tha last thang stopped while dat shiznit was in
the foreground or started up in tha background.
Da 
.I "previous thang"
may be referenced using
.BR %\- .
If there is only a single thang, \fB%+\fP n' \fB%\-\fP can both be used
to refer ta dat thang.
In output pertainin ta thangs (e.g., tha output of the
.B thangs
command), tha current thang be always flagged wit a
.BR + ,
and tha previous thang wit a
.BR \- .
A single % (with no accompanyin thang justification) also refers ta the
current thang.
.PP
Simply namin a thang can be used ta brang it tha fuck into the
foreground:
.B %1
is a synonym for
\fB``fg %1''\fP,
bringin thang 1 from tha background tha fuck into tha foreground.
Similarly,
.B ``%1 &''
resumes thang 1 up in tha background, equivalent to
\fB``bg %1''\fP.
.PP
Da shell learns immediately whenever a thang chizzlez state.
Normally,
.B bash
waits until it be bout ta print a prompt before reporting
changes up in a thangz status so as ta not interrupt
any other output.  If tha 
.B \-b
option ta the
.B set
builtin command
is enabled,
.B bash
reports such chizzlez immediately.
Any trap on
.SM
.B SIGCHLD
is executed fo' each lil pimp dat exits.
.PP
If a attempt ta exit
.B bash
is made while thangs is stopped (or, if tha \fBcheckjobs\fP shell option has
been enabled rockin tha \fBshopt\fP builtin, hustlin), tha shell prints a
warnin message, and, if tha \fBcheckjobs\fP option is enabled, lists the
jobs n' they statuses.
The
.B thangs
command may then be used ta inspect they status. 
If a second attempt ta exit is made without a intervenin command,
the shell do not print another warning, n' any stopped
jobs is terminated.
.SH PROMPTING
When executin interactively, 
.B bash
displays tha primary prompt
.SM
.B PS1
when it is locked n loaded ta read a cold-ass lil command, n' tha secondary prompt
.SM
.B PS2
when it needz mo' input ta complete a cold-ass lil command.
.B Bash
allows these prompt strings ta be customized by insertin a number of
backslash-escaped special charactas dat is decoded as bigs up:
.RS
.PD 0
.TP
.B \ea
an ASCII bell characta (07)
.TP
.B \ed
the date up in "Weekdizzle Month Date" format (e.g., "Tue May 26")
.TP
.B \eD{\fIformat\fP}
the \fIformat\fP is passed ta \fIstrftime\fP(3) n' tha result is inserted
into tha prompt string; a empty \fIformat\fP thangs up in dis biatch up in a locale-specific
time representation. I aint talkin' bout chicken n' gravy biatch.  Da braces is required
.TP
.B \ee
an ASCII escape characta (033)
.TP
.B \eh
the hostname up ta tha straight-up original gangsta `.'
.TP
.B \eH
the hostname
.TP
.B \ej
the number of thangs currently managed by tha shell
.TP
.B \el
the basename of tha shellz terminal thang name
.TP
.B \en
newline
.TP
.B \er
carriage return
.TP
.B \es
the name of tha shell, tha basename of
.B $0
(the portion followin tha final slash)
.TP
.B \et
the current time up in 24-hour HH:MM:SS format
.TP
.B \eT
the current time up in 12-hour HH:MM:SS format
.TP
.B \e@
the current time up in 12-hour am/pm format
.TP
.B \eA
the current time up in 24-hour HH:MM format
.TP
.B \eu
the username of tha current user
.TP
.B \ev
the version of \fBbash\fP (e.g., 2.00)
.TP
.B \eV
the release of \fBbash\fP, version + patch level (e.g., 2.00.0)
.TP
.B \ew
the current hustlin directory, with
.SM
.B $HOME
abbreviated wit a tilde
(uses tha value of the
.SM
.B PROMPT_DIRTRIM
variable)
.TP
.B \eW
the basename of tha current hustlin directory, with
.SM
.B $HOME
abbreviated wit a tilde
.TP
.B \e!
the history number of dis command
.TP
.B \e#
the command number of dis command
.TP
.B \e$
if tha effectizzle UID is 0, a
.BR # ,
otherwise a
.B $
.TP
.B \e\fInnn\fP
the characta correspondin ta tha octal number \fInnn\fP
.TP
.B \e\e
a backslash
.TP
.B \e[
begin a sequence of non-printin characters, which could be used to
embed a terminal control sequence tha fuck into tha prompt
.TP
.B \e]
end a sequence of non-printin characters
.PD
.RE
.PP
Da command number n' tha history number is probably different:
the history number of a cold-ass lil command is its posizzle up in tha history
list, which may include commandz restored from tha history file
(see
.SM
.B HISTORY
below), while tha command number is tha posizzle up in tha sequence
of commandz executed durin tha current shell session.
Afta tha strang is decoded, it is expanded via
parameta expansion, command substitution, arithmetic
expansion, n' quote removal, subject ta tha value of the
.B promptvars
shell option (see tha description of the
.B shopt
command under
.SM
.B "SHELL BUILTIN COMMANDS"
below).
.SH READLINE
This is tha library dat handlez readin input when rockin a interactive
shell, unless the
.B \-\-noediting
option is given at shell invocation.
Line editin be also used when rockin tha \fB\-e\fP option ta the
\fBread\fP builtin.
By default, tha line editin commandz is similar ta dem of Emacs.
A vi-style line editin intercourse be also available.
Line editin can be enabled at any time rockin the
.B \-o emacs
or
.B \-o vi
options ta the
.B set
builtin (see
.SM
.B SHELL BUILTIN COMMANDS
below).
To turn off line editin afta tha shell is hustlin, use the
.B +o emacs
or
.B +o vi
options ta the
.B set
builtin.
.SS "Readline Notation"
.PP
In dis section, tha Emacs-style notation is used ta denote
keystrokes.  Control keys is denoted by C\-\fIkey\fR, e.g., C\-n
means Control\-N.  Similarly, 
.I meta
keys is denoted by M\-\fIkey\fR, so M\-x means Meta\-X.  (On keyboards
without a 
.I meta
key, M\-\fIx\fP means ESC \fIx\fP, i.e., press tha Escape key
then the
.I x
key.  This make ESC tha \fImeta prefix\fP.
Da combination M\-C\-\fIx\fP means ESC\-Control\-\fIx\fP,
or press tha Escape key
then hold tha Control key while pressin the
.I x
key.)
.PP
Readline commandz may be given numeric
.IR arguments ,
which normally act as a repeat count.
Sometimes, however, it is tha sign of tha argument dat is significant.
Passin a wack argument ta a cold-ass lil command dat acts up in tha forward
direction (e.g., \fBkill\-line\fP) causes dat command ta act up in a
backward direction. I aint talkin' bout chicken n' gravy biatch. 
Commandz whose behavior wit arguments deviates from dis is noted
below.
.PP
When a cold-ass lil command is busted lyrics bout as \fIkilling\fP text, tha text
deleted is saved fo' possible future retrieval
(\fIyanking\fP).  Da capped text is saved up in a
\fIkill ring\fP.  Consecutizzle kills cause tha text ta be
accumulated tha fuck into one unit, which can be yanked all at once. 
Commandz which do not bust a cap up in text separate tha chunkz of text
on tha bust a cap up in ring.
.SS "Readline Initialization"
.PP
Readline is customized by puttin commandz up in a initialization
file (the \fIinputrc\fP file).
Da name of dis file is taken from tha value of the
.SM
.B INPUTRC
variable.  If dat variable is unset, tha default is
.IR ~/.inputrc .
When a program which uses tha readline library starts up, the
initialization file is read, n' tha key bindings n' variables
are set.
There is only all dem basic constructs allowed up in the
readline initialization file.
Blank lines is ignored.
Lines beginnin wit a \fB#\fP is comments.
Lines beginnin wit a \fB$\fP indicate conditionizzle constructs.
Other lines denote key bindings n' variable settings.
.PP
Da default key-bindings may be chizzled wit an
.I inputrc 
file.
Other programs dat use dis library may add they own commands
and bindings.
.PP
For example, placing
.RS
.PP
M\-Control\-u: universal\-argument
.RE
or
.RS
C\-Meta\-u: universal\-argument
.RE
into tha 
.I inputrc
would make M\-C\-u execute tha readline command
.IR universal\-argument .
.PP
Da followin symbolic characta names is recognized:
.IR RUBOUT ,
.IR DEL ,
.IR ESC ,
.IR LFD ,
.IR NEWLINE ,
.IR RET ,
.IR RETURN ,
.IR SPC ,
.IR SPACE ,
and
.IR TAB .
.PP
In addizzle ta command names, readline allows keys ta be bound
to a strang dat is banged when tha key is pressed (a \fImacro\fP).
.SS "Readline Key Bindings"
.PP
Da syntax fo' controllin key bindings up in the
.I inputrc
file is simple.  All dat is required is tha name of the
command or tha text of a macro n' a key sequence ta which
it should be bound. Y'all KNOW dat shit, muthafucka! Da name may be specified up in one of two ways:
as a symbolic key name, possibly wit \fIMeta\-\fP or \fIControl\-\fP
prefixes, or as a key sequence.
.PP
When rockin tha form \fBkeyname\fP:\^\fIfunction\-name\fP or \fImacro\fP,
.I keyname
is tha name of a key spelled up in Gangsta.  For example:
.sp
.RS
Control-u: universal\-argument
.br
Meta-Rubout: backward-kill-word
.br
Control-o: "> output"
.RE
.LP
In tha above example,
.I C\-u
is bound ta tha function
.BR universal\-argument ,
.I M\-DEL
is bound ta tha function
.BR backward\-kill\-word ,
and
.I C\-o
is bound ta run tha macro
expressed on tha right hand side (that is, ta bang tha text
.if t \f(CW> output\fP
.if n ``> output''
into tha line).
.PP
In tha second form, \fB"keyseq"\fP:\^\fIfunction\-name\fP or \fImacro\fP,
.B keyseq
differs from
.B keyname
above up in dat strings denoting
an entire key sequence may be specified by placin tha sequence
within double quotes.  Some GNU Emacs steez key escapes can be
used, as up in tha followin example yo, but tha symbolic characta names
are not recognized.
.sp
.RS
"\eC\-u": universal\-argument
.br
"\eC\-x\eC\-r": re\-read\-init\-file
.br
"\ee[11~": "Function Key 1"
.RE
.PP
In dis example,
.I C\-u
is again n' again n' again bound ta tha function
.BR universal\-argument .
.I "C\-x C\-r"
is bound ta tha function
.BR re\-read\-init\-file ,
and 
.I "ESC [ 1 1 ~"
is bound ta bang tha text
.if t \f(CWFunction Key 1\fP.
.if n ``Function Key 1''.
.PP
Da full set of GNU Emacs steez escape sequences is
.RS
.PD 0
.TP
.B \eC\-
control prefix
.TP
.B \eM\-
meta prefix
.TP
.B \ee
an escape character
.TP
.B \e\e
backslash
.TP
.B \e"
literal "
.TP
.B \e\(aq
literal \(aq
.RE
.PD
.PP
In addizzle ta tha GNU Emacs steez escape sequences, a second
set of backslash escapes be available:
.RS
.PD 0
.TP
.B \ea
alert (bell)
.TP
.B \eb
backspace
.TP
.B \ed
delete
.TP
.B \ef
form feed
.TP
.B \en
newline
.TP
.B \er
carriage return
.TP
.B \et
horizontal tab
.TP
.B \ev
vertical tab
.TP
.B \e\fInnn\fP
the eight-bit characta whose value is tha octal value \fInnn\fP
(one ta three digits)
.TP
.B \ex\fIHH\fP
the eight-bit characta whose value is tha hexadecimal value \fIHH\fP
(one or two hex digits)
.RE
.PD
.PP
When enterin tha text of a macro, single or double quotes must
be used ta indicate a macro definition.
Unquoted text be assumed ta be a gangbangin' function name.
In tha macro body, tha backslash escapes busted lyrics bout above is expanded.
Backslash will quote any other characta up in tha macro text,
includin " n' \(aq.
.PP
.B Bash
allows tha current readline key bindings ta be displayed or modified
with the
.B bind
builtin command. Y'all KNOW dat shit, muthafucka!  Da editin mode may be switched durin interactive
use by rockin the
.B \-o
option ta the
.B set
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).
.SS "Readline Variables"
.PP
Readline has variablez dat can be used ta further customize its
behavior. Shiiit, dis aint no joke.  A variable may be set up in the
.I inputrc
file wit a statement of tha form
.RS
.PP
\fBset\fP \fIvariable\-name\fP \fIvalue\fP
.RE
.PP
Except where noted, readline variablez can take tha joints
.B On
or
.B Off
(without regard ta case).
Unrecognized variable names is ignored.
When a variable value is read, empty or null joints, "on" (case-insensitive),
and "1" is equivalent ta \fBOn\fP.  All other joints is equivalent to
\fBOff\fP.
Da variablez n' they default joints are:
.PP
.PD 0
.TP
.B bell\-style (audible)
Controls what tha fuck happens when readline wants ta rang tha terminal bell.
If set ta \fBnone\fP, readline never rings tha bell.  If set to
\fBvisible\fP, readline uses a visible bell if one be available.
If set ta \fBaudible\fP, readline attempts ta rang tha terminalz bell.
.TP
.B bind\-tty\-special\-chars (On)
If set ta \fBOn\fP, readline attempts ta bind tha control characters
treated specially by tha kernelz terminal driver ta they readline
equivalents.
.TP
.B comment\-begin (``#'')
Da strang dat is banged when tha readline
.B insert\-comment
command is executed.
This command is bound to
.B M\-#
in emacs mode n' to
.B #
in vi command mode.
.TP
.B completion\-ignore\-case (Off)
If set ta \fBOn\fP, readline performs filename matchin n' completion
in a cold-ass lil case\-insensitizzle fashion.
.TP
.B completion\-prefix\-display\-length (0)
Da length up in charactaz of tha common prefix of a list of possible
completions dat is displayed without modification. I aint talkin' bout chicken n' gravy biatch.  When set ta a
value pimped outa than zero, common prefixes longer than dis value are
replaced wit a ellipsis when displayin possible completions.
.TP
.B completion\-query\-items (100)
This determines when tha user is queried bout viewing
the number of possible completions
generated by tha \fBpossible\-completions\fP command.
It may be set ta any integer value pimped outa than or equal to
zero.  If tha number of possible completions is pimped outa than
or equal ta tha value of dis variable, tha user be axed whether
or not da thug wishes ta view them; otherwise they is simply listed
on tha terminal.
.TP
.B convert\-meta (On)
If set ta \fBOn\fP, readline will convert charactas wit the
eighth bit set ta a ASCII key sequence
by strippin tha eighth bit n' prefixin an
escape characta (in effect, rockin escape as tha \fImeta prefix\fP).
.TP
.B disable\-completion (Off)
If set ta \fBOn\fP, readline will inhibit word completion. I aint talkin' bout chicken n' gravy biatch.  Completion
charactas is ghon be banged tha fuck into tha line as if they had been
mapped ta \fBself-insert\fP.
.TP
.B editing\-mode (emacs)
Controls whether readline begins wit a set of key bindings similar
to \fIEmacs\fP or \fIvi\fP.
.B editing\-mode
can be set ta either
.B emacs
or
.BR vi .
.TP
.B echo\-control\-charactas (On)
When set ta \fBOn\fP, on operatin systems dat indicate they support it,
readline echoes a cold-ass lil characta correspondin ta a signal generated from the
keyboard.
.TP
.B enable\-keypad (Off)
When set ta \fBOn\fP, readline will try ta enable tha application
keypad when it is called. Y'all KNOW dat shit, muthafucka!  Some systems need dis ta enable the
arrow keys.
.TP
.B enable\-meta\-key (On)
When set ta \fBOn\fP, readline will try ta enable any meta modifier
key tha terminal fronts ta support when it is called. Y'all KNOW dat shit, muthafucka!  On nuff terminals,
the meta key is used ta bust eight-bit characters.
.TP
.B expand\-tilde (Off)
If set ta \fBOn\fP, tilde expansion is performed when readline
attempts word completion.
.TP
.B history\-preserve\-point (Off)
If set ta \fBOn\fP, tha history code attempts ta place point at the
same location on each history line retrieved wit \fBprevious-history\fP
or \fBnext-history\fP.
.TP
.B history\-size (0)
Set tha maximum number of history entries saved up in tha history list.  If
set ta zero, tha number of entries up in tha history list aint limited.
.TP
.B horizontal\-scroll\-mode (Off)
When set ta \fBOn\fP, make readline bust a single line fo' display,
scrollin tha input horizontally on a single screen line when it
becomes longer than tha screen width rather than wrappin ta a freshly smoked up line.
.TP
.B input\-meta (Off)
If set ta \fBOn\fP, readline will enable eight-bit input (that is,
it aint gonna strip tha high bit from tha charactas it reads),
regardless of what tha fuck tha terminal fronts it can support.  Da name
.B meta\-flag
is a synonym fo' dis variable.
.TP
.B isearch\-terminators (``C\-[C\-J'')
Da strang of charactas dat should terminizzle a incremental
search without subsequently executin tha characta as a cold-ass lil command.
If dis variable has not been given a value, tha characters
\fIESC\fP n' \fIC\-J\fP will terminizzle a incremenstrual search.
.TP
.B keymap (emacs)
Set tha current readline keymap.  Da set of valid keymap names is
\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-command\fP, and
.IR vi\-insert .
\fIvi\fP is equivalent ta \fIvi\-command\fP; \fIemacs\fP is
equivalent ta \fIemacs\-standard\fP.  Da default value is
.IR emacs ;
the value of
.B editing\-mode
also affects tha default keymap.
.TP
.B mark\-directories (On)
If set ta \fBOn\fP, completed directory names gotz a slash
appended.
.TP
.B mark\-modified\-lines (Off)
If set ta \fBOn\fP, history lines dat done been modified is displayed
with a precedin asterisk (\fB*\fP).
.TP
.B mark\-symlinked\-directories (Off)
If set ta \fBOn\fP, completed names which is symbolic links ta directories
have a slash appended (subject ta tha value of
\fBmark\-directories\fP).
.TP
.B match\-hidden\-filez (On)
This variable, when set ta \fBOn\fP, causes readline ta match filez whose
names begin wit a `.' (hidden files) when struttin filename 
completion.
If set ta \fBOff\fP, tha leadin `.' must be
supplied by tha user up in tha filename ta be completed.
.TP
.B menu\-complete\-display\-prefix (Off)
If set ta \fBOn\fP, menu completion displays tha common prefix of the
list of possible completions (which may be empty) before cyclin through
the list.
.TP
.B output\-meta (Off)
If set ta \fBOn\fP, readline will display charactas wit the
eighth bit set directly rather than as a meta-prefixed escape
sequence.
.TP
.B page\-completions (On)
If set ta \fBOn\fP, readline uses a internal \fImore\fP-like pager
to display a screenful of possible completions at a time.
.TP
.B print\-completions\-horizontally (Off)
If set ta \fBOn\fP, readline will display completions wit matches
sorted horizontally up in alphabetical order, rather than down tha screen.
.TP 
.B revert\-all\-at\-newline (Off)
If set ta \fBOn\fP, readline will undo all chizzlez ta history lines 
before returnin when \fBaccept\-line\fP is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  By default,
history lines may be modified n' retain individual undo lists across
calls ta \fBreadline\fP.
.TP
.B show\-all\-if\-ambiguous (Off)
This altas tha default behavior of tha completion functions.  If
set to
.BR On ,
wordz which have mo' than one possible completion cause the
matches ta be listed immediately instead of ringin tha bell.
.TP
.B show\-all\-if\-unmodified (Off)
This altas tha default behavior of tha completion functions in
a fashizzle similar ta \fBshow\-all\-if\-ambiguous\fP.
If set to
.BR On ,
wordz which have mo' than one possible completion without any
possible partial completion (the possible completions don't share
a common prefix) cause tha matches ta be listed immediately instead
of ringin tha bell.
.TP
.B skip\-completed\-text (Off)
If set ta \fBOn\fP, dis altas tha default completion behavior when
insertin a single match tha fuck into tha line.  It aint nuthin but only actizzle when
performin completion up in tha middle of a word. Y'all KNOW dat shit, muthafucka!  If enabled, readline
does not bang charactas from tha completion dat match characters
afta point up in tha word bein completed, so portionz of tha word
followin tha cursor is not duplicated.
.TP
.B visible\-stats (Off)
If set ta \fBOn\fP, a cold-ass lil characta denotin a gangbangin' filez type as reported
by \fIstat\fP(2) be appended ta tha filename when listin possible
completions.
.PD
.SS "Readline Conditionizzle Constructs"
.PP
Readline implements a gangbangin' facilitizzle similar up in spirit ta tha conditional
compilation featurez of tha C preprocessor which allows key
bindings n' variable settings ta be performed as tha result
of tests, n' you can put dat on yo' toast.  There is four parser directives used.
.IP \fB$if\fP
Da 
.B $if
construct allows bindings ta be made based on the
editin mode, tha terminal bein used, or tha application using
readline.  Da text of tha test extendz ta tha end of tha line;
no charactas is required ta isolate dat shit.
.RS
.IP \fBmode\fP
Da \fBmode=\fP form of tha \fB$if\fP directizzle is used ta test
whether readline is up in emacs or vi mode.
This may be used up in conjunction
with tha \fBset keymap\fP command, fo' instance, ta set bindings in
the \fIemacs\-standard\fP n' \fIemacs\-ctlx\fP keymaps only if
readline is startin up in emacs mode.
.IP \fBterm\fP
Da \fBterm=\fP form may be used ta include terminal-specific
key bindings, like ta bind tha key sequences output by the
terminalz function keys.  Da word on tha right side of the
.B =
is tested against tha both full name of tha terminal n' tha portion
of tha terminal name before tha straight-up original gangsta \fB\-\fP.  This allows
.I sun
to match both
.I sun
and
.IR sun\-cmd ,
for instance.
.IP \fBapplication\fP
Da \fBapplication\fP construct is used ta include
application-specific settings.  Each program rockin tha readline
library sets tha \fIapplication name\fP, n' a initialization
file can test fo' a particular value.
This could be used ta bind key sequences ta functions useful for
a specific program.  For instance, tha followin command addz a
key sequence dat quotes tha current or previous word up in \fBbash\fP:
.sp 1
.RS
.nf
\fB$if\fP Bash
# Quote tha current or previous word
"\eC\-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.RE
.IP \fB$endif\fP
This command, as peeped up in tha previous example, terminates an
\fB$if\fP command.
.IP \fB$else\fP
Commandz up in dis branch of tha \fB$if\fP directizzle is executed if
the test fails.
.IP \fB$include\fP
This directizzle takes a single filename as a argument n' readz commands
and bindings from dat file.  For example, tha followin directive
would read \fI/etc/inputrc\fP:
.sp 1
.RS
.nf
\fB$include\fP \^ \fI/etc/inputrc\fP
.fi
.RE
.SS Searching
.PP
Readline serves up commandz fo' searchin all up in tha command history
(see
.SM
.B HISTORY
below) fo' lines containin a specified string.
There is two search modes:
.I incremental
and
.IR non-incremenstrual .
.PP
Incremenstrual searches begin before tha user has finished typin the
search string.
As each characta of tha search strang is typed, readline displays
the next entry from tha history matchin tha strang typed so far.
An incremenstrual search requires only as nuff charactas as needed to
find tha desired history entry.
Da charactas present up in tha value of tha \fBisearch-terminators\fP
variable is used ta terminizzle a incremenstrual search.
If dat variable has not been assigned a value tha Escape and
Control-J charactas will terminizzle a incremenstrual search.
Control-G will abort a incremenstrual search n' restore tha original
line.
When tha search is terminated, tha history entry containin the
search strang becomes tha current line.
.PP
To find other matchin entries up in tha history list, type Control-S or
Control-R as appropriate.
This will search backward or forward up in tha history fo' tha next
entry matchin tha search strang typed so far.
Any other key sequence bound ta a readline command will terminate
the search n' execute dat command.
For instance, a \fInewline\fP will terminizzle tha search n' accept
the line, thereby executin tha command from tha history list.
.PP
Readline rethugz tha last incremenstrual search string.  If two
Control-Rs is typed without any intervenin charactas definin a
new search string, any remembered search strang is used.
.PP
Non-incremenstrual searches read tha entire search strang before starting
to search fo' matchin history lines.  Da search strang may be
typed by tha user or be part of tha contentz of tha current line.
.SS "Readline Command Names"
.PP
Da followin be a list of tha namez of tha commandz n' tha default
key sequences ta which they is bound.
Command names without a accompanyin key sequence is unbound by default.
In tha followin descriptions, \fIpoint\fP refers ta tha current cursor
position, n' \fImark\fP refers ta a cold-ass lil cursor posizzle saved by the
\fBset\-mark\fP command.
Da text between tha point n' mark is referred ta as tha \fIregion\fP.
.SS Commandz fo' Moving
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
Move ta tha start of tha current line.
.TP
.B end\-of\-line (C\-e)
Move ta tha end of tha line.
.TP
.B forward\-char (C\-f)
Move forward a cold-ass lil character.
.TP
.B backward\-char (C\-b)
Move back a cold-ass lil character.
.TP
.B forward\-word (M\-f)
Move forward ta tha end of tha next word. Y'all KNOW dat shit, muthafucka!  Lyrics is composed of
alphanumeric charactas (lettas n' digits).
.TP
.B backward\-word (M\-b)
Move back ta tha start of tha current or previous word.
Lyrics is composed of alphanumeric charactas (lettas n' digits).
.TP
.B shell\-forward\-word
Move forward ta tha end of tha next word.
Lyrics is delimited by non-quoted shell metacharacters.
.TP
.B shell\-backward\-word
Move back ta tha start of tha current or previous word.
Lyrics is delimited by non-quoted shell metacharacters.
.TP
.B clear\-screen (C\-l)
Clear tha screen leavin tha current line all up in tha top of tha screen.
With a argument, refresh tha current line without clearin the
screen.
.TP
.B redraw\-current\-line
Refresh tha current line.
.PD
.SS Commandz fo' Manipulatin tha History
.PP
.PD 0
.TP
.B accept\-line (Newline, Return)
Accept tha line regardless of where tha cursor is.  If dis line is
non-empty, add it ta tha history list accordin ta tha state of the
.SM
.B HISTCONTROL
variable.  If tha line be a modified history
line, then restore tha history line ta its original gangsta state.
.TP
.B previous\-history (C\-p)
Fetch tha previous command from tha history list, movin back in
the list.
.TP
.B next\-history (C\-n)
Fetch tha next command from tha history list, movin forward up in the
list.
.TP
.B beginning\-of\-history (M\-<)
Move ta tha straight-up original gangsta line up in tha history.
.TP
.B end\-of\-history (M\->)
Move ta tha end of tha input history, i.e., tha line currently being
entered.
.TP
.B reverse\-search\-history (C\-r)
Search backward startin all up in tha current line n' movin `up' through
the history as necessary.  This be a incremenstrual search.
.TP
.B forward\-search\-history (C\-s)
Search forward startin all up in tha current line n' movin `down' through
the history as necessary.  This be a incremenstrual search.
.TP
.B non\-incremental\-reverse\-search\-history (M\-p)
Search backward all up in tha history startin all up in tha current line
usin a non-incremenstrual search fo' a strang supplied by tha user.
.TP
.B non\-incremental\-forward\-search\-history (M\-n)
Search forward all up in tha history rockin a non-incremenstrual search for
a strang supplied by tha user.
.TP
.B history\-search\-forward
Search forward all up in tha history fo' tha strang of characters
between tha start of tha current line n' tha point.
This be a non-incremenstrual search.
.TP
.B history\-search\-backward
Search backward all up in tha history fo' tha strang of characters
between tha start of tha current line n' tha point.
This be a non-incremenstrual search.
.TP
.B yank\-nth\-arg (M\-C\-y)
Insert tha straight-up original gangsta argument ta tha previous command (usually
the second word on tha previous line) at point.
With a argument
.IR n ,
insert tha \fIn\fPth word from tha previous command (the lyrics
in tha previous command begin wit word 0).  A wack argument
inserts tha \fIn\fPth word from tha end of tha previous command.
Once tha argument \fIn\fP is computed, tha argument is extracted
as if tha "!\fIn\fP" history expansion had been specified.
.TP
.B
yank\-last\-arg (M\-.\^, M\-_\^)
Insert tha last argument ta tha previous command (the last word of
the previous history entry).
With a numeric argument, behave exactly like \fByank\-nth\-arg\fP.
Successive calls ta \fByank\-last\-arg\fP move back all up in tha history
list, insertin tha last word (or tha word specified by tha argument to
the first call) of each line up in turn.
Any numeric argument supplied ta these successive calls determines
the direction ta move all up in tha history.  A wack argument switches
the direction all up in tha history (back or forward).
Da history expansion facilitizzles is used ta extract tha last argument,
as if tha "!$" history expansion had been specified.
.TP
.B shell\-expand\-line (M\-C\-e)
Expand tha line as tha shell do.  This
performs alias n' history expansion as well as all of tha shell
word expansions.  See
.SM
.B HISTORY EXPANSION
below fo' a thugged-out description of history expansion.
.TP
.B history\-expand\-line (M\-^)
Perform history expansion on tha current line.
See
.SM
.B HISTORY EXPANSION
below fo' a thugged-out description of history expansion.
.TP
.B magic\-space
Perform history expansion on tha current line n' bang a space.
See
.SM
.B HISTORY EXPANSION
below fo' a thugged-out description of history expansion.
.TP
.B alias\-expand\-line
Perform alias expansion on tha current line.
See
.SM
.B ALIASES
above fo' a thugged-out description of alias expansion.
.TP
.B history\-and\-alias\-expand\-line
Perform history n' alias expansion on tha current line.
.TP
.B insert\-last\-argument (M\-.\^, M\-_\^)
A synonym fo' \fByank\-last\-arg\fP.
.TP
.B operate\-and\-get\-next (C\-o)
Accept tha current line fo' execution n' fetch tha next line
relatizzle ta tha current line from tha history fo' editing.  Any
argument is ignored.
.TP
.B edit\-and\-execute\-command (C\-xC\-e)
Invoke a editor on tha current command line, n' execute tha result as shell
commands.
\fBBash\fP attempts ta invoke
.SM
.BR $VISUAL ,
.SM
.BR $EDITOR ,
and \fIemacs\fP as tha editor, up in dat order.
.PD
.SS Commandz fo' Changin Text
.PP
.PD 0
.TP
.B delete\-char (C\-d)
Delete tha characta at point.  If point be at the
beginnin of tha line, there be no charactas up in tha line, and
the last characta typed was not bound ta \fBdelete\-char\fP,
then return
.SM
.BR EOF .
.TP
.B backward\-delete\-char (Rubout)
Delete tha characta behind tha cursor. Shiiit, dis aint no joke.  When given a numeric argument,
save tha deleted text on tha bust a cap up in ring.
.TP
.B forward\-backward\-delete\-char
Delete tha characta under tha cursor, unless tha cursor be at the
end of tha line, up in which case tha characta behind tha cursor is
deleted.
.TP
.B quoted\-insert (C\-q, C\-v)
Add tha next characta typed ta tha line verbatim.  This is
how ta bang charactas like \fBC\-q\fP, fo' example.
.TP
.B tab\-insert (C\-v TAB)
Insert a tab character.
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
Insert tha characta typed.
.TP
.B transpose\-chars (C\-t)
Drag tha characta before point forward over tha characta at point,
movin point forward as well.
If point be all up in tha end of tha line, then dis transposes
the two charactas before point.
Negatizzle arguments have no effect.
.TP
.B transpose\-wordz (M\-t)
Drag tha word before point past tha word afta point,
movin point over dat word as well.
If point be all up in tha end of tha line, dis transposes
the last two lyrics on tha line.   
.TP
.B upcase\-word (M\-u)
Uppercase tha current (or following) word. Y'all KNOW dat shit, muthafucka!  With a wack argument,
uppercase tha previous word yo, but do not move point.
.TP
.B downcase\-word (M\-l)
Lowercase tha current (or following) word. Y'all KNOW dat shit, muthafucka!  With a wack argument,
lowercase tha previous word yo, but do not move point.
.TP
.B capitalize\-word (M\-c)
Capitalize tha current (or following) word. Y'all KNOW dat shit, muthafucka!  With a wack argument,
capitalize tha previous word yo, but do not move point.
.TP
.B overwrite\-mode
Toggle overwrite mode.  With a explicit positizzle numeric argument,
switches ta overwrite mode.  With a explicit non-positizzle numeric
argument, switches ta bang mode.  This command affects only
\fBemacs\fP mode; \fBvi\fP mode do overwrite differently.
Each call ta \fIreadline()\fP starts up in bang mode.
In overwrite mode, charactas bound ta \fBself\-insert\fP replace   
the text at point rather than pushin tha text ta tha right.
Charactas bound ta \fBbackward\-delete\-char\fP replace tha character
before point wit a space.  By default, dis command is unbound.
.PD
.SS Bustin' n' Yanking
.PP
.PD 0
.TP
.B kill\-line (C\-k)
Bust a cap up in tha text from point ta tha end of tha line.
.TP
.B backward\-kill\-line (C\-x Rubout)
Bust a cap up in backward ta tha beginnin of tha line.
.TP
.B unix\-line\-discard (C\-u)
Bust a cap up in backward from point ta tha beginnin of tha line.
Da capped text is saved on tha kill-ring.
.\" There is no real difference between dis n' backward-kill-line
.TP
.B kill\-whole\-line
Bust a cap up in all charactas on tha current line, no matta where point is.
.TP
.B kill\-word  (M\-d)
Bust a cap up in from point ta tha end of tha current word, or if between
words, ta tha end of tha next word.
Word boundaries is tha same as dem used by \fBforward\-word\fP.
.TP
.B backward\-kill\-word (M\-Rubout)
Bust a cap up in tha word behind point.
Word boundaries is tha same as dem used by \fBbackward\-word\fP.
.TP
.B shell\-kill\-word  (M\-d)
Bust a cap up in from point ta tha end of tha current word, or if between
words, ta tha end of tha next word.
Word boundaries is tha same as dem used by \fBshell\-forward\-word\fP.
.TP
.B shell\-backward\-kill\-word (M\-Rubout)
Bust a cap up in tha word behind point.
Word boundaries is tha same as dem used by \fBshell\-backward\-word\fP.
.TP
.B unix\-word\-rubout (C\-w)
Bust a cap up in tha word behind point, rockin white space as a word boundary.
Da capped text is saved on tha kill-ring.
.TP
.B unix\-filename\-rubout
Bust a cap up in tha word behind point, rockin white space n' tha slash character
as tha word boundaries.
Da capped text is saved on tha kill-ring.
.TP
.B delete\-horizontal\-space (M\-\e)
Delete all spaces n' tabs round point.
.TP
.B kill\-region
Bust a cap up in tha text up in tha current region.
.TP
.B copy\-region\-as\-kill
Copy tha text up in tha region ta tha bust a cap up in buffer.
.TP
.B copy\-backward\-word
Copy tha word before point ta tha bust a cap up in buffer.
Da word boundaries is tha same as \fBbackward\-word\fP.
.TP
.B copy\-forward\-word
Copy tha word followin point ta tha bust a cap up in buffer.
Da word boundaries is tha same as \fBforward\-word\fP.
.TP
.B yank (C\-y)
Yank tha top of tha bust a cap up in rang tha fuck into tha buffer at point.
.TP
.B yank\-pop (M\-y)
Rotate tha bust a cap up in ring, n' yank tha freshly smoked up top.  Only works following
.B yank
or
.BR yank\-pop .
.PD
.SS Numeric Arguments
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
Add dis digit ta tha argument already accumulating, or start a new
argument.  M\-\- starts a wack argument.
.TP
.B universal\-argument
This be another way ta specify a argument.
If dis command is followed by one or mo' digits, optionally wit a
leadin minus sign, dem digits define tha argument.
If tha command is followed by digits, executing
.B universal\-argument
again endz tha numeric argument yo, but is otherwise ignored.
As a special case, if dis command is immediately followed by a
characta dat is neither a gangbangin' finger-lickin' digit or minus sign, tha argument count
for tha next command is multiplied by four.
Da argument count is initially one, so executin dis function the
first time make tha argument count four, a second time make the
argument count sixteen, n' so on.
.PD
.SS Completing
.PP
.PD 0
.TP
.B complete (TAB)
Attempt ta big-ass up completion on tha text before point.
.B Bash
attempts completion treatin tha text as a variable (if the
text begins wit \fB$\fP), username (if tha text begins with
\fB~\fP), hostname (if tha text begins wit \fB@\fP), or
command (includin aliases n' functions) up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  If none
of these produces a match, filename completion be attempted.
.TP
.B possible\-completions (M\-?)
List tha possible completionz of tha text before point.
.TP
.B insert\-completions (M\-*)
Insert all completionz of tha text before point
that would done been generated by
\fBpossible\-completions\fP.
.TP
.B menu\-complete
Similar ta \fBcomplete\fP yo, but replaces tha word ta be completed
with a single match from tha list of possible completions.
Repeated execution of \fBmenu\-complete\fP steps all up in tha list
of possible completions, insertin each match up in turn.
At tha end of tha list of completions, tha bell is rung
(subject ta tha settin of \fBbell\-style\fP)
and tha original gangsta text is restored.
An argument of \fIn\fP moves \fIn\fP positions forward up in tha list
of matches; a wack argument may be used ta move backward
all up in tha list.
This command is intended ta be bound ta \fBTAB\fP yo, but is unbound
by default.
.TP
.B menu\-complete\-backward
Identical ta \fBmenu\-complete\fP yo, but moves backward all up in tha list
of possible completions, as if \fBmenu\-complete\fP had been given a
negatizzle argument.  This command is unbound by default.
.TP
.B delete\-char\-or\-list
Deletes tha characta under tha cursor if not all up in tha beginnin or
end of tha line (like \fBdelete\-char\fP).
If all up in tha end of tha line, behaves identically to
\fBpossible\-completions\fP.
This command is unbound by default.
.TP
.B complete\-filename (M\-/)
Attempt filename completion on tha text before point.
.TP
.B possible\-filename\-completions (C\-x /)
List tha possible completionz of tha text before point,
treatin it as a gangbangin' filename.
.TP
.B complete\-username (M\-~)
Attempt completion on tha text before point, treating
it as a username.
.TP
.B possible\-username\-completions (C\-x ~)
List tha possible completionz of tha text before point,
treatin it as a username.
.TP
.B complete\-variable (M\-$)
Attempt completion on tha text before point, treating
it as a gangbangin' finger-lickin' dirty-ass shell variable.
.TP
.B possible\-variable\-completions (C\-x $)
List tha possible completionz of tha text before point,
treatin it as a gangbangin' finger-lickin' dirty-ass shell variable.
.TP
.B complete\-hostname (M\-@)
Attempt completion on tha text before point, treating
it as a hostname.
.TP
.B possible\-hostname\-completions (C\-x @)
List tha possible completionz of tha text before point,
treatin it as a hostname.
.TP
.B complete\-command (M\-!)
Attempt completion on tha text before point, treating
it as a cold-ass lil command name.  Command completion attempts to
match tha text against aliases, reserved lyrics, shell
functions, shell builtins, n' finally executable filenames,
in dat order.
.TP
.B possible\-command\-completions (C\-x !)
List tha possible completionz of tha text before point,
treatin it as a cold-ass lil command name.
.TP
.B dynamic\-complete\-history (M\-TAB)
Attempt completion on tha text before point, comparing
the text against lines from tha history list fo' possible
completion matches.
.TP
.B dabbrev\-expand
Attempt menu completion on tha text before point, comparing
the text against lines from tha history list fo' possible
completion matches.
.TP
.B complete\-into\-braces (M\-{)
Perform filename completion n' bang tha list of possible completions
enclosed within braces so tha list be available ta tha shell (see
.B Brace Expansion
above).
.PD
.SS Keyboard Macros
.PP
.PD 0
.TP
.B start\-kbd\-macro (C\-x (\^)
Begin savin tha charactas typed tha fuck into tha current keyboard macro.
.TP
.B end\-kbd\-macro (C\-x )\^)
Quit savin tha charactas typed tha fuck into tha current keyboard macro
and store tha definition.
.TP
.B call\-last\-kbd\-macro (C\-x e)
Re-execute tha last keyboard macro defined, by makin tha characters
in tha macro step tha fuck up as if typed all up in tha keyboard.
.PD
.SS Miscellaneous
.PP
.PD 0
.TP
.B re\-read\-init\-file (C\-x C\-r)
Read up in tha contentz of tha \fIinputrc\fP file, n' incorporate
any bindings or variable assignments found there.
.TP
.B abort (C\-g)
Abort tha current editin command and
rin tha terminalz bell (subject ta tha settin of
.BR bell\-style ).
.TP
.B do\-uppercase\-version (M\-a, M\-b, M\-\fIx\fP, ...)
If tha metafied characta \fIx\fP is lowercase, run tha command
that is bound ta tha correspondin uppercase character.
.TP
.B prefix\-meta (ESC)
Metafy tha next characta typed.
.SM
.B ESC
.B f
is equivalent to
.BR Meta\-f .
.TP
.B undo (C\-_, C\-x C\-u)
Incremenstrual undo, separately remembered fo' each line.
.TP
.B revert\-line (M\-r)
Undo all chizzlez made ta dis line.  This is like executin the
.B undo
command enough times ta return tha line ta its initial state.
.TP
.B tilde\-expand (M\-&)
Perform tilde expansion on tha current word.
.TP
.B set\-mark (C\-@, M\-<space>)
Set tha mark ta tha point.  If a
numeric argument is supplied, tha mark is set ta dat position.
.TP
.B exchange\-point\-and\-mark (C\-x C\-x)
Swap tha point wit tha mark.  Da current cursor posizzle is set to
the saved position, n' tha oldschool cursor posizzle is saved as tha mark.
.TP
.B character\-search (C\-])
A characta is read n' point is moved ta tha next occurrence of that
character n' shit.  A wack count searches fo' previous occurrences.
.TP
.B character\-search\-backward (M\-C\-])
A characta is read n' point is moved ta tha previous occurrence of that
character n' shit.  A wack count searches fo' subsequent occurrences.
.TP
.B skip\-csi\-sequence
Read enough charactas ta consume a multi-key sequence like fuckin them
defined fo' keys like Home n' End. Y'all KNOW dat shit, muthafucka!  Such sequences begin wit a
Control Sequence Indicator (CSI), probably ESC\-[.  If dis sequence is
bound ta "\e[", keys producin such sequences gonna git no effect
unless explicitly bound ta a readline command, instead of inserting
stray charactas tha fuck into tha editin buffer n' shit.  This is unbound by default,
but probably bound ta ESC\-[.
.TP
.B insert\-comment (M\-#)
Without a numeric argument, tha value of tha readline
.B comment\-begin
variable is banged all up in tha beginnin of tha current line.
If a numeric argument is supplied, dis command acts as a toggle:  if
the charactas all up in tha beginnin of tha line do not match tha value
of \fBcomment\-begin\fP, tha value is inserted, otherwise
the charactas up in \fBcomment\-begin\fP is deleted from tha beginnin of 
the line.
In either case, tha line be accepted as if a newline had been typed.
Da default value of
\fBcomment\-begin\fP causes dis command ta make tha current line
a shell comment.
If a numeric argument causes tha comment characta ta be removed, tha line
will be executed by tha shell.
.TP
.B glob\-complete\-word (M\-g)
Da word before point is treated as a pattern fo' pathname expansion,
with a asterisk implicitly appended. Y'all KNOW dat shit, muthafucka!  This pattern is used to
generate a list of matchin file names fo' possible completions.
.TP
.B glob\-expand\-word (C\-x *)
Da word before point is treated as a pattern fo' pathname expansion,
and tha list of matchin file names is inserted, replacin tha word.
If a numeric argument is supplied, a asterisk be appended before
pathname expansion.
.TP
.B glob\-list\-expansions (C\-x g)
Da list of expansions dat would done been generated by
.B glob\-expand\-word
is displayed, n' tha line is redrawn.
If a numeric argument is supplied, a asterisk be appended before
pathname expansion.
.TP
.B dump\-functions
Print all of tha functions n' they key bindings ta the
readline output stream.  If a numeric argument is supplied,
the output is formatted up in such a way dat it can be made part
of a \fIinputrc\fP file.
.TP
.B dump\-variables
Print all of tha settable readline variablez n' they joints ta the
readline output stream.  If a numeric argument is supplied,
the output is formatted up in such a way dat it can be made part
of a \fIinputrc\fP file.
.TP
.B dump\-macros
Print all of tha readline key sequences bound ta macros n' the
strings they output.  If a numeric argument is supplied,
the output is formatted up in such a way dat it can be made part
of a \fIinputrc\fP file.
.TP
.B display\-shell\-version (C\-x C\-v)
Display version shiznit bout tha current instizzle of
.BR bash .
.PD
.SS Programmable Completion
.PP
When word completion be attempted fo' a argument ta a cold-ass lil command for
which a cold-ass lil completion justification (a \fIcompspec\fP) has been defined
usin tha \fBcomplete\fP builtin (see
.SM
.B "SHELL BUILTIN COMMANDS"
below), tha programmable completion facilitizzles is invoked.
.PP
First, tha command name is identified.
If tha command word is tha empty strang (completion attempted at the
beginnin of a empty line), any compspec defined with
the \fB\-E\fP option ta \fBcomplete\fP is used.
If a cold-ass lil compspec has been defined fo' dat command, the
compspec is used ta generate tha list of possible completions fo' tha word.
If tha command word be a gangbangin' full pathname, a cold-ass lil compspec fo' tha full
pathname is searched fo' first.
If no compspec is found fo' tha full pathname, a attempt is made to
find a cold-ass lil compspec fo' tha portion followin tha final slash.
If dem searches do not result up in a cold-ass lil compspec, any compspec defined with
the \fB\-D\fP option ta \fBcomplete\fP is used as tha default.
.PP
Once a cold-ass lil compspec has been found, it is used ta generate tha list of
matchin lyrics.
If a cold-ass lil compspec aint found, tha default \fBbash\fP completion as
busted lyrics bout above under \fBCompleting\fP is performed.
.PP
First, tha actions specified by tha compspec is used.
Only matches which is prefixed by tha word bein completed are
returned.
When the
.B \-f
or
.B \-d
option is used fo' filename or directory name completion, tha shell
variable
.SM
.B FIGNORE
is used ta filta tha matches.
.PP
Any completions specified by a pathname expansion pattern ta the
\fB\-G\fP option is generated next.
Da lyrics generated by tha pattern need not match tha word
bein completed.
The
.SM
.B GLOBIGNORE
shell variable aint used ta filta tha matches yo, but the
.SM
.B FIGNORE
variable is used.
.PP
Next, tha strang specified as tha argument ta tha \fB\-W\fP option
is considered.
Da strang is first split rockin tha charactas up in the
.SM
.B IFS
special variable as delimiters.
Shell quotin is honored.
Each word is then expanded using
brace expansion, tilde expansion, parameta n' variable expansion,
command substitution, n' arithmetic expansion,
as busted lyrics bout above under 
.SM
.BR EXPANSION .
Da thangs up in dis biatch is split rockin tha rulez busted lyrics bout above under
\fBWord Splitting\fP.
Da thangs up in dis biatch of tha expansion is prefix-matched against tha word being
completed, n' tha matchin lyrics become tha possible completions.
.PP
Afta these matches done been generated, any shell function or command
specified wit tha \fB\-F\fP n' \fB\-C\fP options is invoked.
When tha command or function is invoked, the
.SM
.BR COMP_LINE ,
.SM
.BR COMP_POINT ,
.SM
.BR COMP_KEY ,
and
.SM
.B COMP_TYPE
variablez is assigned joints as busted lyrics bout above under
\fBShell Variables\fP.
If a gangbangin' finger-lickin' dirty-ass shell function is bein invoked, tha 
.SM
.B COMP_WORDS
and
.SM
.B COMP_CWORD
variablez is also set.
When tha function or command is invoked, tha straight-up original gangsta argument is the
name of tha command whose arguments is bein completed, the
second argument is tha word bein completed, n' tha third argument
is tha word precedin tha word bein completed on tha current command line.
No filterin of tha generated completions against tha word bein completed
is performed; tha function or command has complete freedom up in generating
the matches.
.PP
Any function specified wit \fB\-F\fP is invoked first.
Da function may use any of tha shell facilities, includin the
\fBcompgen\fP builtin busted lyrics bout below, ta generate tha matches.
It must put tha possible completions up in the
.SM
.B COMPREPLY
array variable.
.PP
Next, any command specified wit tha \fB\-C\fP option is invoked
in a environment equivalent ta command substitution.
It should print a list of completions, one per line, ta the
standard output.
Backslash may be used ta escape a newline, if necessary.
.PP
Afta all of tha possible completions is generated, any filter
specified wit tha \fB\-X\fP option be applied ta tha list.
Da filta be a pattern as used fo' pathname expansion; a \fB&\fP
in tha pattern is replaced wit tha text of tha word bein completed.
A literal \fB&\fP may be escaped wit a funky-ass backslash; tha backslash
is removed before attemptin a match.
Any completion dat matches tha pattern is ghon be removed from tha list.
A leadin \fB!\fP negates tha pattern; up in dis case any completion
not matchin tha pattern is ghon be removed.
.PP
Finally, any prefix n' suffix specified wit tha \fB\-P\fP n' \fB\-S\fP
options is added ta each gangmember of tha completion list, n' tha result is
returned ta tha readline completion code as tha list of possible
completions.
.PP
If tha previously-applied actions do not generate any matches, n' the
\fB\-o dirnames\fP option was supplied ta \fBcomplete\fP when the
compspec was defined, directory name completion be attempted.
.PP
If tha \fB\-o plusdirs\fP option was supplied ta \fBcomplete\fP when the
compspec was defined, directory name completion be attempted n' any
matches is added ta tha thangs up in dis biatch of tha other actions.
.PP
By default, if a cold-ass lil compspec is found, whatever it generates is returned
to tha completion code as tha full set of possible completions.
Da default \fBbash\fP completions is not attempted, n' tha readline
default of filename completion is disabled.
If tha \fB\-o bashdefault\fP option was supplied ta \fBcomplete\fP when
the compspec was defined, tha \fBbash\fP default completions is attempted
if tha compspec generates no matches.
If tha \fB\-o default\fP option was supplied ta \fBcomplete\fP when the
compspec was defined, readlinez default completion is ghon be performed
if tha compspec (and, if attempted, tha default \fBbash\fP completions)
generate no matches.
.PP
When a cold-ass lil compspec indicates dat directory name completion is desired,
the programmable completion functions force readline ta append a slash
to completed names which is symbolic links ta directories, subject ta  
the value of tha \fBmark\-directories\fP readline variable, regardless
of tha settin of tha \fBmark-symlinked\-directories\fP readline variable.
.PP
There is some support fo' dynamically modifyin completions.  This is
most useful when used up in combination wit a thugged-out default completion specified
with \fBcomplete -D\fP.
It aint nuthin but possible fo' shell functions executed as completion
handlezs ta indicate dat completion should be retried by returnin an
exit statuz of 124.  If a gangbangin' finger-lickin' dirty-ass shell function returns 124, n' chizzles
the compspec associated wit tha command on which completion is being
attempted (supplied as tha straight-up original gangsta argument when tha function is executed),
programmable completion restarts from tha beginning, wit an
attempt ta find a freshly smoked up compspec fo' dat command. Y'all KNOW dat shit, muthafucka!  This allows a set of
completions ta be built dynamically as completion be attempted, rather than
bein loaded all at once.
.PP
For instance, assumin dat there be a library of compspecs, each kept up in a
file correspondin ta tha name of tha command, tha followin default
completion function would load completions dynamically:
.PP
\f(CW_completion_loader()
.br
{
.br
	. "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
.br
}
.br
complete -D -F _completion_loader
.br
\fP
.SH HISTORY
When the
.B \-o history
option ta the
.B set
builtin is enabled, tha shell serves up access ta the
\fIcommand history\fP,
the list of commandz previously typed.
Da value of the
.SM
.B HISTSIZE
variable is used as the
number of commandz ta save up in a history list.
Da text of tha last
.SM
.B HISTSIZE
commandz (default 500) is saved. Y'all KNOW dat shit, muthafucka!  Da shell
stores each command up in tha history list prior ta parameta and
variable expansion (see
.SM
.B EXPANSION
above) but afta history expansion is performed, subject ta the
valuez of tha shell variables
.SM
.B HISTIGNORE
and
.SM
.BR HISTCONTROL .
.PP
On startup, tha history is initialized from tha file named by
the variable
.SM
.B HISTFILE
(default \fI~/.bash_history\fP).
Da file named by tha value of
.SM
.B HISTFILE
is truncated, if necessary, ta contain no mo' than
the number of lines specified by tha value of
.SM
.BR HISTFILESIZE .
When tha history file is read,
lines beginnin wit tha history comment characta followed immediately
by a gangbangin' finger-lickin' digit is interpreted as timestamps fo' tha precedin history line.
These timestamps is optionally displayed dependin on tha value of the
.SM
.B HISTTIMEFORMAT
variable.
When a interactizzle shell exits, tha last
.SM
.B $HISTSIZE
lines is copied from tha history list to
.SM
.BR $HISTFILE .
If the
.B histappend
shell option is enabled
(see tha description of
.B shopt
under
.SM
.B "SHELL BUILTIN COMMANDS"
below), tha lines is appended ta tha history file,
otherwise tha history file is overwritten.
If
.SM
.B HISTFILE
is unset, or if tha history file is unwritable, tha history is
not saved.
If the
.SM
.B HISTTIMEFORMAT
variable is set, time stamps is freestyled ta tha history file, marked
with tha history comment character, so
they may be preserved across shell sessions.
This uses tha history comment characta ta distinguish timestamps from
other history lines.
Afta savin tha history, tha history file is truncated
to contain no mo' than
.SM
.B HISTFILESIZE
lines.  If
.SM
.B HISTFILESIZE
is not set, no truncation is performed.
.PP
Da builtin command
.B fc
(see
.SM
.B SHELL BUILTIN COMMANDS
below) may be used ta list or edit n' re-execute a portion of
the history list.
The
.B history
builtin may be used ta display or modify tha history list and
manipulate tha history file.
When rockin command-line editing, search commands
are available up in each editin mode dat provide access ta the
history list.
.PP
Da shell allows control over which commandz is saved on tha history
list.  The
.SM
.B HISTCONTROL
and
.SM
.B HISTIGNORE
variablez may be set ta cause tha shell ta save only a subset of the
commandz entered.
The
.B cmdhist
shell option, if enabled, causes tha shell ta attempt ta save each
line of a multi-line command up in tha same history entry, adding
semicolons where necessary ta preserve syntactic erectness.
The
.B lithist
shell option causes tha shell ta save tha command wit embedded newlines
instead of semicolons.  See tha description of the
.B shopt
builtin below under
.SM
.B "SHELL BUILTIN COMMANDS"
for shiznit on settin n' unsettin shell options.
.SH "HISTORY EXPANSION"
.PP
Da shell supports a history expansion feature that
is similar ta tha history expansion in
.BR csh.
This section raps bout what tha fuck syntax features is available.  This
feature is enabled by default fo' interactizzle shells, n' can be
disabled rockin the
.B \+H
option ta the
.B set
builtin command (see
.SM
.B SHELL BUILTIN COMMANDS
below).  Non-interactizzle shells do not big-ass up history expansion
by default.
.PP
History expansions introduce lyrics from tha history list into
the input stream, makin it easy as fuck  ta repeat commands, bang the
arguments ta a previous command tha fuck into tha current input line, or
fix errors up in previous commandz doggystyle.
.PP
History expansion is performed immediately afta a cold-ass lil complete line
is read, before tha shell breaks it tha fuck into lyrics.
It takes place up in two parts.
Da first is ta determine which line from tha history list
to use durin substitution.
Da second is ta select portionz of dat line fo' inclusion into
the current one.
Da line selected from tha history is tha \fIevent\fP,
and tha portionz of dat line dat is acted upon is \fIwords\fP.
Various \fImodifiers\fP is available ta manipulate tha selected lyrics.
Da line is fucked up tha fuck into lyrics up in tha same fashizzle as when readin input,
so dat nuff muthafuckin \fImetacharacter\fP-separated lyrics surrounded by
quotes is considered one word.
History expansions is introduced by tha appearizzle of the
history expansion character, which is \^\fB!\fP\^ by default.
Only backslash (\^\fB\e\fP\^) n' single quotes can quote
the history expansion character.
.PP
Several charactas inhibit history expansion if found immediately
followin tha history expansion character, even if it is unquoted:
space, tab, newline, carriage return, n' \fB=\fP.
If tha \fBextglob\fP shell option is enabled, \fB(\fP will also
inhibit expansion.
.PP
Several shell options settable wit the
.B shopt
builtin may be used ta tailor tha behavior of history expansion.
If the
.B histverify
shell option is enabled (see tha description of the
.B shopt
builtin below), and
.B readline
is bein used, history substitutions is not immediately passed to
the shell parser.
Instead, tha expanded line is reloaded tha fuck into the
.B readline
editin buffer fo' further modification.
If
.B readline
is bein used, n' the
.B histreedit
shell option is enabled, a gangbangin' failed history substitution is ghon be reloaded
into the
.B readline
editin buffer fo' erection.
The
.B \-p
option ta the
.B history
builtin command may be used ta peep what tha fuck a history expansion will
do before rockin dat shit.
The
.B \-s
option ta the
.B history
builtin may be used ta add commandz ta tha end of tha history list
without straight-up executin them, so dat they is available for
subsequent recall.
.PP
Da shell allows control of tha various charactas used by the
history expansion mechanizzle (see tha description of
.B histchars
above under
.BR "Shell Variables" ).
Da shell uses
the history comment characta ta mark history timestamps when
writin tha history file.
.SS Event Designators
.PP
An event designator be a reference ta a cold-ass lil command line entry up in the
history list.
Unless tha reference be absolute, events is relatizzle ta tha current
posizzle up in tha history list.
.PP
.PD 0
.TP
.B !
Start a history substitution, except when followed by a
.BR blank ,
newline, carriage return, =
or ( (when tha \fBextglob\fP shell option is enabled using
the \fBshopt\fP builtin).
.TP
.B !\fIn\fR
Refer ta command line
.IR n .
.TP
.B !\-\fIn\fR
Refer ta tha current command minus
.IR n .
.TP
.B !!
Refer ta tha previous command. Y'all KNOW dat shit, muthafucka!  This be a synonym fo' `!\-1'.
.TP
.B !\fIstring\fR
Refer ta da most thugged-out recent command precedin tha current posizzle up in the
history list startin with
.IR strang .
.TP
.B !?\fIstring\fR\fB[?]\fR
Refer ta da most thugged-out recent command precedin tha current postizzle up in the
history list containing
.IR strang .
Da trailin \fB?\fP may be omitted if
.I string
is followed immediately by a newline.
.TP
.B \d\s+2^\s-2\u\fIstring1\fP\d\s+2^\s-2\u\fIstring2\fP\d\s+2^\s-2\u
Quick substitution. I aint talkin' bout chicken n' gravy biatch.  Repeat tha previous command, replacing
.I string1
with
.IR string2 .
Equivalent to
``!!:s/\fIstring1\fP/\fIstring2\fP/''
(see \fBModifiers\fP below).
.TP
.B !#
Da entire command line typed so far.
.PD
.SS Word Designators
.PP
Word designators is used ta select desired lyrics from tha event.
A 
.B :
separates tha event justification from tha word designator.
It may be omitted if tha word designator begins wit a
.BR ^ ,
.BR $ ,
.BR * ,
.BR \- ,
or
.BR % .
Lyrics is numbered from tha beginnin of tha line,
with tha straight-up original gangsta word bein denoted by 0 (zero).
Lyrics is banged tha fuck into tha current line separated by single spaces.
.PP
.PD 0
.TP
.B 0 (zero)
Da zeroth word. Y'all KNOW dat shit, muthafucka!  For tha shell, dis is tha command
word.
.TP
.I n
Da \fIn\fRth word.
.TP
.B ^
Da first argument.  That is, word 1.
.TP
.B $
Da last argument.
.TP
.B %
Da word matched by da most thugged-out recent `?\fIstring\fR?' search.
.TP
.I x\fB\-\fPy
A range of lyrics; `\-\fIy\fR' abbreviates `0\-\fIy\fR'.
.TP
.B *
All of tha lyrics but tha zeroth.  This be a synonym
for `\fI1\-$\fP'.  It aint a error ta use
.B *
if there is just one
word up in tha event; tha empty strang is returned up in dat case.
.TP
.B x*
Abbreviates \fIx\-$\fP.
.TP
.B x\-
Abbreviates \fIx\-$\fP like \fBx*\fP yo, but omits tha last word.
.PD
.PP
If a word designator is supplied without a event justification, the
previous command is used as tha event.
.SS Modifiers
.PP
Afta tha optionizzle word designator, there may step tha fuck up a sequence of
one or mo' of tha followin modifiers, each preceded by a `:'.
.PP
.PD 0
.PP
.TP
.B h
Remove a trailin file name component, leavin only tha head.
.TP
.B t
Remove all leadin file name components, leavin tha tail.
.TP
.B r
Remove a trailin suffix of tha form \fI.xxx\fP, leavin the
basename.
.TP
.B e
Remove all but tha trailin suffix.
.TP
.B p
Print tha freshly smoked up command but do not execute dat shit.
.TP
.B q
Quote tha substituted lyrics, escapin further substitutions.
.TP
.B x
Quote tha substituted lyrics as with
.BR q ,
but break tha fuck into lyrics at
.B blanks
and newlines.
.TP
.B s/\fIold\fP/\fInew\fP/
Substitute
.I new
for tha straight-up original gangsta occurrence of
.I old
in tha event line.  Any delimita can be used up in place of /.  The
final delimita is optionizzle if it is tha last characta of the
event line.  Da delimita may be quoted in
.I old
and
.I new
with a single backslash.  If & appears in
.IR freshly smoked up ,
it is replaced by
.IR oldschool .
A single backslash will quote tha &.  If
.I old
is null, it is set ta tha last
.I old
substituted, or, if no previous history substitutions took place,
the last
.I string
in a
.B !?\fIstring\fR\fB[?]\fR
search.
.TP
.B &
Repeat tha previous substitution.
.TP
.B g
Cause chizzlez ta be applied over tha entire event line.  This is
used up in conjunction wit `\fB:s\fP' (e.g., `\fB:gs/\fIold\fP/\fInew\fP/\fR')
or `\fB:&\fP'.  If used with
`\fB:s\fP', any delimita can be used
in place of /, n' tha final delimita is optional
if it is tha last characta of tha event line.
An \fBa\fP may be used as a synonym fo' \fBg\fP.
.TP
.B G
Apply tha followin `\fBs\fP' modifier once ta each word up in tha event line.
.PD
.SH "SHELL BUILTIN COMMANDS"
.\" start of bash_builtins
.zZ
.PP
Unless otherwise noted, each builtin command documented up in this
section as acceptin options preceded by
.B \-
accepts
.B \-\-
to signify tha end of tha options.
Da \fB:\fP, \fBtrue\fP, \fBfalse\fP, n' \fBtest\fP builtins
do not accept options n' do not treat \fB\-\-\fP specially.
Da \fBexit\fP, \fBlogout\fP, \fBbreak\fP, \fBcontinue\fP, \fBlet\fP,
and \fBshift\fP builtins accept n' process arguments beginnin with
\fB\-\fP without requirin \fB\-\-\fP.
Other builtins dat accept arguments but is not specified as accepting
options interpret arguments beginnin wit \fB\-\fP as invalid options and
require \fB\-\-\fP ta prevent dis interpretation.
.sp .5
.PD 0
.TP
\fB:\fP [\fIarguments\fP]
.PD
No effect; tha command do not a god damn thang beyond expanding
.I arguments
and struttin any specified
redirections.  A zero exit code is returned.
.TP
\fB .\| \fP \fIfilename\fP [\fIarguments\fP]
.PD 0
.TP
\fBsource\fP \fIfilename\fP [\fIarguments\fP]
.PD
Read n' execute commandz from
.I filename
in tha current
shell environment n' return tha exit statuz of tha last command
executed from
.IR filename .
If
.I filename
does not contain a slash, file names in
.SM
.B PATH
are used ta find tha directory containing
.IR filename .
Da file searched fo' in
.SM
.B PATH
need not be executable.
When \fBbash\fP aint up in \fIposix mode\fP, tha current directory is
searched if no file is found in
.SM
.BR PATH .
If the
.B sourcepath
option ta the
.B shopt
builtin command is turned off, the
.SM
.B PATH
is not searched.
If any \fIarguments\fP is supplied, they become tha positional
parametas when \fIfilename\fP is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Otherwise tha positional
parametas is unchanged.
Da return status is tha statuz of tha last command exited within
the script (0 if no commandz is executed), n' false if
.I filename
is not found or cannot be read.
.TP
\fBalias\fP [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
\fBAlias\fP wit no arguments or wit the
.B \-p
option prints tha list of aliases up in tha form
\fBalias\fP \fIname\fP=\fIvalue\fP on standard output.
When arguments is supplied, a alias is defined for
each \fIname\fP whose \fIvalue\fP is given.
A trailin space up in  \fIvalue\fP causes tha next word ta be
checked fo' alias substitution when tha alias is expanded.
For each \fIname\fP up in tha argument list fo' which no \fIvalue\fP
is supplied, tha name n' value of tha alias is printed.
\fBAlias\fP returns legit unless a \fIname\fP is given fo' which
no alias has been defined.
.TP
\fBbg\fP [\fIjobspec\fP ...]
Resume each suspended thang \fIjobspec\fP up in tha background, as if it
had been started with
.BR & .
If
.I thangspec
is not present, tha shellz notion of tha \fIcurrent thang\fP is used.
.B bg
.I thangspec
returns 0 unless run when thang control is disabled or, when run with
job control enabled, any specified \fIjobspec\fP was not found
or was started without thang control.
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-lpsvPSV\fP]
.PD 0
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-q\fP \fIfunction\fP] [\fB\-u\fP \fIfunction\fP] [\fB\-r\fP \fIkeyseq\fP]
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-f\fP \fIfilename\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-x\fP \fIkeyseq\fP:\fIshell\-command\fP
.TP
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fIkeyseq\fP:\fIfunction\-name\fP
.TP
\fBbind\fP \fIreadline\-command\fP
.PD
Display current
.B readline
key n' function bindings, bind a key sequence ta a
.B readline
function or macro, or set a
.B readline
variable.
Each non-option argument be a cold-ass lil command as it would step tha fuck up in
.IR .inputrc ,
but each bindin or command must be passed as a separate argument;
e.g., '"\eC\-x\eC\-r": re\-read\-init\-file'.
Options, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-m \fIkeymap\fP
Use
.I keymap
as tha keymap ta be affected by tha subsequent bindings.
Acceptable
.I keymap
names are
\fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi,
vi\-move, vi\-command\fP, and
.IR vi\-insert .
\fIvi\fP is equivalent ta \fIvi\-command\fP; \fIemacs\fP is
equivalent ta \fIemacs\-standard\fP.
.TP
.B \-l
List tha namez of all \fBreadline\fP functions.
.TP
.B \-p
Display \fBreadline\fP function names n' bindings up in such a way
that they can be re-read.
.TP
.B \-P
List current \fBreadline\fP function names n' bindings.
.TP
.B \-s
Display \fBreadline\fP key sequences bound ta macros n' tha strings
they output up in such a way dat they can be re-read.
.TP
.B \-S
Display \fBreadline\fP key sequences bound ta macros n' tha strings
they output.
.TP
.B \-v
Display \fBreadline\fP variable names n' joints up in such a way dat they
can be re-read.
.TP
.B \-V
List current \fBreadline\fP variable names n' joints.
.TP
.B \-f \fIfilename\fP
Read key bindings from \fIfilename\fP.
.TP
.B \-q \fIfunction\fP
Query bout which keys invoke tha named \fIfunction\fP.
.TP
.B \-u \fIfunction\fP
Unbind all keys bound ta tha named \fIfunction\fP.
.TP
.B \-r \fIkeyseq\fP
Remove any current bindin fo' \fIkeyseq\fP.
.TP
.B \-x \fIkeyseq\fP:\fIshell\-command\fP
Cause \fIshell\-command\fP ta be executed whenever \fIkeyseq\fP is
entered.
When \fIshell\-command\fP is executed, tha shell sets the
.SM
.B READLINE_LINE
variable ta tha contentz of tha \fBreadline\fP line buffer n' the
.SM
.B READLINE_POINT
variable ta tha current location of tha insertion point.
If tha executed command chizzlez tha value of
.SM
.B READLINE_LINE
or
.SM
.BR READLINE_POINT ,
those freshly smoked up joints is ghon be reflected up in tha editin state.
.PD
.PP
Da return value is 0 unless a unrecognized option is given or an
error occurred.
.RE
.TP
\fBbreak\fP [\fIn\fP]
Exit from within a
.BR fo' ,
.BR while ,
.BR until ,
or
.B select
loop.  If \fIn\fP is specified, break \fIn\fP levels.
.I n
must be \(>= 1.  If
.I n
is pimped outa than tha number of enclosin loops, all enclosin loops
are exited.
Da return value is 0 unless \fIn\fP aint pimped outa than or equal ta 1.
.TP
\fBbuiltin\fP \fIshell\-builtin\fP [\fIarguments\fP]
Execute tha specified shell builtin, passin it
.IR arguments ,
and return its exit status.
This is useful when definin a
function whose name is tha same ol' dirty as a gangbangin' finger-lickin' dirty-ass shell builtin,
retainin tha functionalitizzle of tha builtin within tha function.
Da \fBcd\fP builtin is commonly redefined dis way.
Da return status is false if
.I shell\-builtin
is not a gangbangin' finger-lickin' dirty-ass shell builtin command.
.TP
\fBcaller\fP [\fIexpr\fP]
Returns tha context of any actizzle subroutine call (a shell function or
a script executed wit tha \fB.\fP or \fBsource\fP builtins).
Without \fIexpr\fP, \fBcaller\fP displays tha line number n' source
filename of tha current subroutine call.
If a non-negatizzle integer is supplied as \fIexpr\fP, \fBcaller\fP 
displays tha line number, subroutine name, n' source file corresponding
to dat posizzle up in tha current execution call stack.  This extra
information may be used, fo' example, ta print a stack trace.  The
current frame is frame 0.
Da return value is 0 unless tha shell aint executin a subroutine
call or \fIexpr\fP do not correspond ta a valid posizzle up in the
call stack.
.TP
\fBcd\fP [\fB\-L\fP|[\fB\-P\fP [\fB\-e\fP]]] [\fIdir\fP]
Change tha current directory ta \fIdir\fP.  Da variable
.SM
.B HOME
is the
default
.IR dir .
Da variable
.SM
.B CDPATH
defines tha search path fo' tha directory containing
.IR dir .
Alternatizzle directory names in
.SM
.B CDPATH
are separated by a cold-ass lil colon (:).  A null directory name in
.SM
.B CDPATH
is tha same ol' dirty as tha current directory, i.e., ``\fB.\fP''.  If
.I dir
begins wit a slash (/),
then
.SM
.B CDPATH
is not used. Y'all KNOW dat shit, muthafucka! The
.B \-P
option say ta use tha physical directory structure instead of
followin symbolic links (see also the
.B \-P
option ta the
.B set
builtin command); the
.B \-L
option forces symbolic links ta be followed.
If the
.B \-e
option is supplied with
.BR \-P ,
and tha current hustlin directory cannot be successfully determined
afta a successful directory chizzle, \fBcd\fP will return a unsuccessful
status.
An argument of
.B \-
is equivalent to
.SM
.BR $OLDPWD .
If a non-empty directory name from
.SM
.B CDPATH
is used, or if
\fB\-\fP is tha straight-up original gangsta argument, n' tha directory chizzle is
successful, tha absolute pathname of tha freshly smoked up hustlin directory is
written ta tha standard output.
Da return value is legit if tha directory was successfully chizzled;
false otherwise.
.TP
\fBcommand\fP [\fB\-pVv\fP] \fIcommand\fP [\fIarg\fP ...]
Run
.I command
with
.I args
suppressin tha aiiight shell function lookup. Only builtin
commandz or commandz found up in the
.SM
.B PATH
are executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If the
.B \-p
option is given, tha search for
.I command
is performed rockin a thugged-out default value for
.SM
.B PATH
that is guaranteed ta find all of tha standard utilities.
If either the
.B \-V
or
.B \-v
option is supplied, a thugged-out description of
.I command
is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  The
.B \-v
option causes a single word indicatin tha command or file name
used ta invoke
.I command
to be displayed; the
.B \-V
option produces a mo' verbose description.
If the
.B \-V
or
.B \-v
option is supplied, tha exit status is 0 if
.I command
was found, n' 1 if not.  If neither option is supplied and
an error occurred or
.I command
cannot be found, tha exit status is 127.  Otherwise, tha exit statuz of the
.B command
builtin is tha exit status of
.IR command .
.TP
\fBcompgen\fP [\fIoption\fP] [\fIword\fP]
Generate possible completion matches fo' \fIword\fP accordin to
the \fIoption\fPs, which may be any option accepted by the
.B complete
builtin wit tha exception of \fB\-p\fP n' \fB\-r\fP, n' write
the matches ta tha standard output.
When rockin tha \fB\-F\fP or \fB\-C\fP options, tha various shell variables
set by tha programmable completion facilities, while available, will not
have useful joints.
.sp 1
Da matches is ghon be generated up in tha same way as if tha programmable
completion code had generated dem directly from a cold-ass lil completion justification
with tha same flags.
If \fIword\fP is specified, only dem completions matchin \fIword\fP
will be displayed.
.sp 1
Da return value is legit unless a invalid option is supplied, or no
matches was generated.
.TP
\fBcomplete\fP [\fB\-abcdefgjksuv\fP] [\fB\-o\fP \fIcomp-option\fP] [\fB\-DE\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP] [\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP]
.br
[\fB\-X\fP \fIfilterpat\fP] [\fB\-P\fP \fIprefix\fP] [\fB\-S\fP \fIsuffix\fP] \fIname\fP [\fIname ...\fP]
.PD 0
.TP
\fBcomplete\fP \fB\-pr\fP [\fB\-DE\fP] [\fIname\fP ...]
.PD
Specify how tha fuck arguments ta each \fIname\fP should be completed.
If tha \fB\-p\fP option is supplied, or if no options is supplied,
existin completion justifications is printed up in a way dat allows
them ta be reused as input.
Da \fB\-r\fP option removes a cold-ass lil completion justification for
each \fIname\fP, or, if no \fIname\fPs is supplied, all
completion justifications.
Da \fB\-D\fP option indicates dat tha remainin options n' actions should
apply ta tha ``default'' command completion; dat is, completion attempted
on a cold-ass lil command fo' which no completion has previously been defined.
Da \fB\-E\fP option indicates dat tha remainin options n' actions should
apply ta ``empty'' command completion; dat is, completion attempted on a
blank line.
.sp 1
Da process of applyin these completion justifications when word completion
is attempted is busted lyrics bout above under \fBProgrammable Completion\fP.
.sp 1
Other options, if specified, have tha followin meanings.
Da arguments ta tha \fB\-G\fP, \fB\-W\fP, n' \fB\-X\fP options
(and, if necessary, tha \fB\-P\fP n' \fB\-S\fP options)
should be quoted ta protect dem from expansion before the
.B complete
builtin is invoked.
.RS
.PD 0
.TP 8
\fB\-o\fP \fIcomp-option\fP
Da \fIcomp-option\fP controls nuff muthafuckin aspectz of tha compspecs behavior
beyond tha simple generation of completions.
\fIcomp-option\fP may be one of:
.RS
.TP 8
.B bashdefault
Perform tha rest of tha default \fBbash\fP completions if tha compspec
generates no matches.
.TP 8
.B default
Use readlinez default filename completion if tha compspec generates
no matches.
.TP 8
.B dirnames
Perform directory name completion if tha compspec generates no matches.
.TP 8
.B filenames
Tell readline dat tha compspec generates filenames, so it can big-ass up any
filename\-specific processin (like addin a slash ta directory names,
quotin special characters, or suppressin trailin spaces).
Intended ta be used wit shell functions.
.TP 8
.B nospace
Tell readline not ta append a space (the default) ta lyrics completed at
the end of tha line.
.TP 8
.B plusdirs
Afta any matches defined by tha compspec is generated, 
directory name completion be attempted n' any
matches is added ta tha thangs up in dis biatch of tha other actions.
.RE
.TP 8
\fB\-A\fP \fIaction\fP
Da \fIaction\fP may be one of tha followin ta generate a list of possible
completions:
.RS
.TP 8
.B alias
Alias names.  May also be specified as \fB\-a\fP.
.TP 8
.B arrayvar
Array variable names.
.TP 8
.B binding
\fBReadline\fP key bindin names.
.TP 8
.B builtin
Namez of shell builtin commands.  May also be specified as \fB\-b\fP.
.TP 8
.B command
Command names.  May also be specified as \fB\-c\fP.
.TP 8
.B directory
Directory names.  May also be specified as \fB\-d\fP.
.TP 8
.B disabled
Namez of disabled shell builtins.
.TP 8
.B enabled
Namez of enabled shell builtins.
.TP 8
.B export
Namez of exported shell variables.  May also be specified as \fB\-e\fP.
.TP 8
.B file
File names.  May also be specified as \fB\-f\fP.
.TP 8
.B function
Namez of shell functions.
.TP 8
.B group
Group names.  May also be specified as \fB\-g\fP.
.TP 8
.B helptopic
Help topics as accepted by tha \fBhelp\fP builtin.
.TP 8
.B hostname
Hostnames, as taken from tha file specified by the
.SM
.B HOSTFILE
shell variable.
.TP 8
.B thang
Thang names, if thang control be active.  May also be specified as \fB\-j\fP.
.TP 8
.B keyword
Shell reserved lyrics.  May also be specified as \fB\-k\fP.
.TP 8
.B hustlin
Namez of hustlin thangs, if thang control be active.
.TP 8
.B service
Service names.  May also be specified as \fB\-s\fP.
.TP 8
.B setopt
Valid arguments fo' tha \fB\-o\fP option ta tha \fBset\fP builtin.
.TP 8
.B shopt
Shell option names as accepted by tha \fBshopt\fP builtin.
.TP 8
.B signal
Signal names.
.TP 8
.B stopped
Namez of stopped thangs, if thang control be active.
.TP 8
.B user
User names.  May also be specified as \fB\-u\fP.
.TP 8
.B variable
Namez of all shell variables.  May also be specified as \fB\-v\fP.
.RE
.TP 8
\fB\-C\fP \fIcommand\fP
\fIcommand\fP is executed up in a subshell environment, n' its output is
used as tha possible completions.
.TP 8
\fB\-F\fP \fIfunction\fP
Da shell function \fIfunction\fP is executed up in tha current shell
environment.
When it finishes, tha possible completions is retrieved from tha value
of the
.SM
.B COMPREPLY
array variable.
.TP 8
\fB\-G\fP \fIglobpat\fP
Da pathname expansion pattern \fIglobpat\fP is expanded ta generate
the possible completions.
.TP 8
\fB\-P\fP \fIprefix\fP
\fIprefix\fP be added all up in tha beginnin of each possible completion
afta all other options done been applied.
.TP 8
\fB\-S\fP \fIsuffix\fP
\fIsuffix\fP be appended ta each possible completion
afta all other options done been applied.
.TP 8
\fB\-W\fP \fIwordlist\fP
Da \fIwordlist\fP is split rockin tha charactas up in the
.SM
.B IFS
special variable as delimiters, n' each resultant word is expanded.
Da possible completions is tha thugz of tha resultant list which
match tha word bein completed.
.TP 8
\fB\-X\fP \fIfilterpat\fP
\fIfilterpat\fP be a pattern as used fo' pathname expansion.
It be applied ta tha list of possible completions generated by the
precedin options n' arguments, n' each completion matching
\fIfilterpat\fP is removed from tha list.
A leadin \fB!\fP up in \fIfilterpat\fP negates tha pattern; up in this
case, any completion not matchin \fIfilterpat\fP is removed.
.PD
.PP
Da return value is legit unless a invalid option is supplied, a option
other than \fB\-p\fP or \fB\-r\fP is supplied without a \fIname\fP
argument, a attempt is made ta remove a cold-ass lil completion justification for
a \fIname\fP fo' which no justification exists, or
an error occurs addin a cold-ass lil completion justification.
.RE
.TP
\fBcompopt\fP [\fB\-o\fP \fIoption\fP] [\fB\-DE\fP] [\fB+o\fP \fIoption\fP] [\fIname\fP]
Modify completion options fo' each \fIname\fP accordin ta the
\fIoption\fPs, or fo' the
currently-executin completion if no \fIname\fPs is supplied.
If no \fIoption\fPs is given, display tha completion options fo' each
\fIname\fP or tha current completion.
Da possible jointz of \fIoption\fP is dem valid fo' tha \fBcomplete\fP
builtin busted lyrics bout above.
Da \fB\-D\fP option indicates dat tha remainin options should
apply ta tha ``default'' command completion; dat is, completion attempted
on a cold-ass lil command fo' which no completion has previously been defined.
Da \fB\-E\fP option indicates dat tha remainin options should
apply ta ``empty'' command completion; dat is, completion attempted on a
blank line.
.sp 1
Da return value is legit unless a invalid option is supplied, a attempt
is made ta modify tha options fo' a \fIname\fP fo' which no completion
specification exists, or a output error occurs.
.TP
\fBcontinue\fP [\fIn\fP]
Resume tha next iteration of tha enclosing
.BR fo' ,
.BR while ,
.BR until ,
or
.B select
loop.
If
.I n
is specified, resume all up in tha \fIn\fPth enclosin loop.
.I n
must be \(>= 1.  If
.I n
is pimped outa than tha number of enclosin loops, tha last enclosin loop
(the ``top-level'' loop) is resumed.
Da return value is 0 unless \fIn\fP aint pimped outa than or equal ta 1.
.TP
\fBdeclare\fP [\fB\-aAfFgilrtux\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
.PD 0
.TP
\fBtypeset\fP [\fB\-aAfFgilrtux\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
.PD
Declare variablez and/or give dem attributes.
If no \fIname\fPs is given then display tha jointz of variables.
The
.B \-p
option will display tha attributes n' jointz of each
.IR name .
When
.B \-p
is used wit \fIname\fP arguments, additionizzle options is ignored.
When
.B \-p
is supplied without \fIname\fP arguments, it will display tha attributes
and jointz of all variablez havin tha attributes specified by the
additionizzle options.
If no other options is supplied wit \fB\-p\fP, \fBdeclare\fP will display
the attributes n' jointz of all shell variables.  Da \fB\-f\fP option
will restrict tha display ta shell functions.
The
.B \-F
option inhibits tha display of function definitions; only the
function name n' attributes is printed.
If tha \fBextdebug\fP shell option is enabled rockin \fBshopt\fP,
the source file name n' line number where tha function is defined
are displayed as well.  The
.B \-F
option implies
.BR \-f .
The
.B \-g
option forces variablez ta be pimped or modified all up in tha global scope,
even when \fBdeclare\fP is executed up in a gangbangin' finger-lickin' dirty-ass shell function.
It be ignored up in all other cases.
Da followin options can
be used ta restrict output ta variablez wit tha specified attribute or
to give variablez attributes:
.RS
.PD 0
.TP
.B \-a
Each \fIname\fP be a indexed array variable (see
.B Arrays
above).
.TP
.B \-A
Each \fIname\fP be a associatizzle array variable (see
.B Arrays
above).
.TP
.B \-f
Use function names only.
.TP
.B \-i
Da variable is treated as a integer; arithmetic evaluation (see
.SM
.B "ARITHMETIC EVALUATION"
above) is performed when tha variable be assigned a value.
.TP
.B \-l
When tha variable be assigned a value, all upper-case charactas are
converted ta lower-case.
Da upper-case attribute is disabled.
.TP
.B \-r
Make \fIname\fPs readonly.  These names cannot then be assigned joints
by subsequent assignment statements or unset.
.TP
.B \-t
Give each \fIname\fP tha \fItrace\fP attribute.
Traced functions inherit tha \fBDEBUG\fP n' \fBRETURN\fP traps from
the callin shell.
Da trace attribute has no special meanin fo' variables.
.TP
.B \-u
When tha variable be assigned a value, all lower-case charactas are
converted ta upper-case.
Da lower-case attribute is disabled.
.TP
.B \-x
Mark \fIname\fPs fo' export ta subsequent commandz via tha environment.
.PD
.PP
Usin `+' instead of `\-'
turns off tha attribute instead,
with tha exceptions dat \fB+a\fP
may not be used ta destroy a array variable n' \fB+r\fP will not
remove tha readonly attribute.
When used up in a gangbangin' function, make each
\fIname\fP local, as wit the
.B local
command,
unless tha \fB\-g\fP option is supplied,
If a variable name is followed by =\fIvalue\fP, tha value of
the variable is set ta \fIvalue\fP.
Da return value is 0 unless a invalid option is encountered,
an attempt is made ta define a gangbangin' function using
.if n ``\-f foo=bar'',
.if t \f(CW\-f foo=bar\fP,
an attempt is made ta assign a value ta a readonly variable,
an attempt is made ta assign a value ta a array variable without
usin tha compound assignment syntax (see
.B Arrays
above), one of tha \fInames\fP aint a valid shell variable name,
an attempt is made ta turn off readonly status fo' a readonly variable,
an attempt is made ta turn off array status fo' a array variable,
or a attempt is made ta display a non-existent function wit \fB\-f\fP.
.RE
.TP
.B dirs [+\fIn\fP] [\-\fIn\fP] [\fB\-clpv\fP]
Without options, displays tha list of currently remembered directories.
Da default display is on a single line wit directory names separated
by spaces.
Directories is added ta tha list wit tha 
.B pushd
command; the
.B popd
command removes entries from tha list.
.RS
.PD 0
.TP
\fB+\fP\fIn\fP
Displays tha \fIn\fPth entry countin from tha left of tha list
shown by
.B dirs
when invoked without options, startin wit zero.
.TP
\fB\-\fP\fIn\fP
Displays tha \fIn\fPth entry countin from tha right of tha list
shown by
.B dirs
when invoked without options, startin wit zero.
.TP
.B \-c
Clears tha directory stack by deletin all of tha entries.
.TP
.B \-l
Produces a longer listing; tha default listin format uses a 
tilde ta denote tha home directory.
.TP
.B \-p
Print tha directory stack wit one entry per line.
.TP
.B \-v
Print tha directory stack wit one entry per line,
prefixin each entry wit its index up in tha stack.
.PD
.PP
Da return value is 0 unless an
invalid option is supplied or \fIn\fP indexes beyond tha end
of tha directory stack.
.RE
.TP
\fBdisown\fP [\fB\-ar\fP] [\fB\-h\fP] [\fIjobspec\fP ...]
Without options, each
.I thangspec
is removed from tha table of actizzle thangs.
If
.I thangspec
is not present, n' neither \fB\-a\fP nor \fB\-r\fP is supplied,
the shellz notion of tha \fIcurrent thang\fP is used.
If tha \fB\-h\fP option is given, each
.I thangspec
is not removed from tha table yo, but is marked so that
.SM
.B SIGHUP
is not busted ta tha thang if tha shell receives a
.SM
.BR SIGHUP .
If no
.I thangspec
is present, n' neither the
.B \-a
nor the
.B \-r
option is supplied, tha \fIcurrent thang\fP is used.
If no
.I thangspec
is supplied, the
.B \-a
option means ta remove or mark all thangs; the
.B \-r
option without a
.I thangspec
argument restricts operation ta hustlin thangs.
Da return value is 0 unless a
.I thangspec
does not specify a valid thang.
.TP
\fBecho\fP [\fB\-neE\fP] [\fIarg\fP ...]
Output tha \fIarg\fPs, separated by spaces, followed by a newline.
Da return status be always 0.
If \fB\-n\fP is specified, tha trailin newline is
suppressed. Y'all KNOW dat shit, muthafucka!  If tha \fB\-e\fP option is given, interpretation of
the followin backslash-escaped charactas is enabled. Y'all KNOW dat shit, muthafucka!  The
.B \-E
option disablez tha interpretation of these escape characters,
even on systems where they is interpreted by default.
Da \fBxpg_echo\fP shell option may be used to
dynamically determine whether or not \fBecho\fP expandz these
escape charactas by default.
.B echo
does not interpret \fB\-\-\fP ta mean tha end of options.
.B echo
interprets tha followin escape sequences:
.RS
.PD 0
.TP
.B \ea
alert (bell)
.TP
.B \eb
backspace
.TP
.B \ec
suppress further output
.TP
.B \ee
.TP
.B \eE
an escape character
.TP
.B \ef
form feed
.TP
.B \en
new line
.TP
.B \er
carriage return
.TP
.B \et
horizontal tab
.TP
.B \ev
vertical tab
.TP
.B \e\e
backslash
.TP
.B \e0\fInnn\fP
the eight-bit characta whose value is tha octal value \fInnn\fP
(zero ta three octal digits)
.TP
.B \ex\fIHH\fP
the eight-bit characta whose value is tha hexadecimal value \fIHH\fP
(one or two hex digits)
.TP
.B \eu\fIHHHH\fP
the Unicode (ISO/IEC 10646) characta whose value is tha hexadecimal value
\fIHHHH\fP (one ta four hex digits)
.TP
.B \eU\fIHHHHHHHH\fP
the Unicode (ISO/IEC 10646) characta whose value is tha hexadecimal value
\fIHHHHHHHH\fP (one ta eight hex digits)
.PD
.RE
.TP
\fBenable\fP [\fB\-a\fP] [\fB\-dnps\fP] [\fB\-f\fP \fIfilename\fP] [\fIname\fP ...]
Enable n' disable builtin shell commands.
Disablin a funky-ass builtin allows a gangbangin' finger-lickin' disk command which has tha same ol' dirty name
as a gangbangin' finger-lickin' dirty-ass shell builtin ta be executed without specifyin a gangbangin' full pathname,
even though tha shell normally searches fo' builtins before disk commands.
If \fB\-n\fP is used, each \fIname\fP
is disabled; otherwise,
\fInames\fP is enabled. Y'all KNOW dat shit, muthafucka!  For example, ta use the
.B test
binary found via the
.SM
.B PATH
instead of tha shell builtin version, run
.if t \f(CWenable -n test\fP.
.if n ``enable -n test''.
The
.B \-f
option means ta load tha freshly smoked up builtin command
.I name
from shared object
.IR filename ,
on systems dat support dynamic loading.  The
.B \-d
option will delete a funky-ass builtin previously loaded with
.BR \-f .
If no \fIname\fP arguments is given, or if the
.B \-p
option is supplied, a list of shell builtins is printed.
With no other option arguments, tha list consistz of all enabled
shell builtins.
If \fB\-n\fP is supplied, only disabled builtins is printed.
If \fB\-a\fP is supplied, tha list printed includes all builtins, wit an
indication of whether or not each is enabled.
If \fB\-s\fP is supplied, tha output is restricted ta tha POSIX
\fIspecial\fP builtins.
Da return value is 0 unless a
.I name
is not a gangbangin' finger-lickin' dirty-ass shell builtin or there be a error loadin a freshly smoked up builtin
from a gangbangin' finger-lickin' dirty-ass shared object.
.TP
\fBeval\fP [\fIarg\fP ...]
Da \fIarg\fPs is read n' concatenated together tha fuck into a single
command. Y'all KNOW dat shit, muthafucka!  This command is then read n' executed by tha shell, and
its exit status is returned as tha value of
.BR eval .
If there be no
.IR args ,
or only null arguments,
.B eval
returns 0.
.TP
\fBexec\fP [\fB\-cl\fP] [\fB\-a\fP \fIname\fP] [\fIcommand\fP [\fIarguments\fP]]
If
.I command
is specified, it replaces tha shell.
No freshly smoked up process is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  The
.I arguments
become tha arguments ta \fIcommand\fP.
If the
.B \-l
option is supplied,
the shell places a thugged-out dash all up in tha beginnin of tha zeroth argument passed ta 
.IR command .
This is what
.IR login (1)
does.  The
.B \-c
option causes
.I command
to be executed wit a empty environment.  If
.B \-a
is supplied, tha shell passes
.I name
as tha zeroth argument ta tha executed command. Y'all KNOW dat shit, muthafucka!  If
.I command
cannot be executed fo' some reason, a non-interactizzle shell exits,
unless tha shell option
.B execfail
is enabled, up in which case it returns failure.
An interactizzle shell returns failure if tha file cannot be executed.
If
.I command
is not specified, any redirections take effect up in tha current shell,
and tha return status is 0.  If there be a redirection error, the
return status is 1.
.TP
\fBexit\fP [\fIn\fP]
Cause tha shell ta exit
with a statuz of \fIn\fP.  If
.I n
is omitted, tha exit status
is dat of tha last command executed.
A trap on
.SM
.B EXIT
is executed before tha shell terminates.
.TP
\fBexport\fP [\fB\-fn\fP\^] [\fIname\fP[=\fIword\fP]] ...
.PD 0
.TP
.B export \-p
.PD
Da supplied
.I names
are marked fo' automatic export ta tha environment of
subsequently executed commands.  If tha 
.B \-f
option is given,
the 
.I names
refer ta functions.
If no
.I names
are given, or if the
.B \-p
option is supplied, a list
of all names dat is exported up in dis shell is printed.
The
.B \-n
option causes tha export property ta be removed from each
\fIname\fP.
If a variable name is followed by =\fIword\fP, tha value of
the variable is set ta \fIword\fP.
.B export
returns a exit statuz of 0 unless a invalid option is
encountered,
one of tha \fInames\fP aint a valid shell variable name, or
.B \-f
is supplied wit a
.I name
that aint a gangbangin' function.
.TP
\fBfc\fP [\fB\-e\fP \fIename\fP] [\fB\-lnr\fP] [\fIfirst\fP] [\fIlast\fP]
.PD 0
.TP
\fBfc\fP \fB\-s\fP [\fIpat\fP=\fIrep\fP] [\fIcmd\fP]
.PD
Fix Command. Y'all KNOW dat shit, muthafucka!  In tha straight-up original gangsta form, a range of commandz from
.I first
to
.I last
is selected from tha history list.
.I First
and
.I last
may be specified as a strang (to locate tha last command beginning
with dat string) or as a number (an index tha fuck into tha history list,
where a wack number is used as a offset from tha current
command number).  If 
.I last
is not specified it is set to
the current command fo' listin (so that
.if n ``fc \-l \-10''
.if t \f(CWfc \-l \-10\fP
prints tha last 10 commands) n' to
.I first
otherwise.
If
.I first
is not specified it is set ta tha previous
command fo' editin n' \-16 fo' listing.
.sp 1
The
.B \-n
option suppresses
the command numbers when listing.  The
.B \-r
option reverses tha order of
the commands.  If the
.B \-l
option is given,
the commandz is listed on
standard output.  Otherwise, tha editor given by
.I ename
is invoked
on a gangbangin' file containin dem commands.  If
.I ename
is not given, the
value of the
.SM
.B FCEDIT
variable is used, and
the value of
.SM
.B EDITOR
if
.SM
.B FCEDIT
is not set.  If neither variable is set,
.FN vi
is used. Y'all KNOW dat shit, muthafucka!  When editin is complete, tha edited commandz are
echoed n' executed.
.sp 1
In tha second form, \fIcommand\fP is re-executed afta each instance
of \fIpat\fP is replaced by \fIrep\fP.
A useful alias ta use wit dis is
.if n ``r="fc -s"'',
.if t \f(CWr='fc \-s'\fP,
so dat typing
.if n ``r cc''
.if t \f(CWr cc\fP
runs tha last command beginnin with
.if n ``cc''
.if t \f(CWcc\fP
and typing
.if n ``r''
.if t \f(CWr\fP
re-executes tha last command.
.sp 1
If tha straight-up original gangsta form is used, tha return value is 0 unless a invalid
option is encountered or
.I first
or
.I last
specify history lines outta range.
If the
.B \-e
option is supplied, tha return value is tha value of tha last
command executed or failure if a error occurs wit tha temporary
file of commands.  If tha second form is used, tha return status
is dat of tha command re-executed, unless
.I cmd
does not specify a valid history line, up in which case
.B fc
returns failure.
.TP
\fBfg\fP [\fIjobspec\fP]
Resume
.I thangspec
in tha foreground, n' make it tha current thang.
If
.I thangspec
is not present, tha shellz notion of tha \fIcurrent thang\fP is used.
Da return value is dat of tha command placed tha fuck into tha foreground,
or failure if run when thang control is disabled or, when run with
job control enabled, if
.I thangspec
does not specify a valid thang or
.I thangspec
specifies a thang dat was started without thang control.
.TP
\fBgetopts\fP \fIoptstring\fP \fIname\fP [\fIargs\fP]
.B getopts
is used by shell procedures ta parse positionizzle parameters.
.I optstring
gotz nuff tha option charactas ta be recognized; if a cold-ass lil character
is followed by a cold-ass lil colon, tha option is sposed ta fuckin have an
argument, which should be separated from it by white space.
Da colon n' question mark charactas may not be used as
option characters.
Each time it is invoked,
.B getopts
places tha next option up in tha shell variable
.IR name ,
initializing
.I name
if it do not exist,
and tha index of tha next argument ta be processed tha fuck into the
variable
.SM
.BR OPTIND .
.SM
.B OPTIND
is initialized ta 1 each time tha shell or a gangbangin' finger-lickin' dirty-ass shell script
is invoked. Y'all KNOW dat shit, muthafucka!  When a option requires a argument,
.B getopts
places dat argument tha fuck into tha variable
.SM
.BR OPTARG .
Da shell do not reset
.SM
.B OPTIND
automatically; it must be manually reset between multiple
calls to
.B getopts
within tha same shell invocation if a freshly smoked up set of parameters
is ta be used.
.sp 1
When tha end of options is encountered, \fBgetopts\fP exits wit a
return value pimped outa than zero.
.SM
.B OPTIND
is set ta tha index of tha straight-up original gangsta non-option argument,
and \fIname\fP is set ta ?.
.sp 1
.B getopts
normally parses tha positionizzle parametas yo, but if mo' arguments are
given in
.IR args ,
.B getopts
parses dem instead.
.sp 1
.B getopts
can report errors up in two ways.  If tha straight-up original gangsta characta of
.I optstring
is a cold-ass lil colon,
.I silent
error reportin is used. Y'all KNOW dat shit, muthafucka!  In aiiight operation diagnostic lyrics
are printed when invalid options or missin option arguments are
encountered.
If tha variable
.SM
.B OPTERR
is set ta 0, no error lyrics is ghon be displayed, even if tha first
characta of 
.I optstring
is not a cold-ass lil colon.
.sp 1
If a invalid option is seen,
.B getopts
places , biatch? into
.I name
and, if not silent,
prints a error message n' unsets
.SM
.BR OPTARG .
If
.B getopts
is silent,
the option characta found is placed in
.SM
.B OPTARG
and no diagnostic message is printed.
.sp 1
If a required argument aint found, and
.B getopts
is not silent,
a question mark (\^\fB?\fP\^) is placed in
.IR name ,
.SM
.B OPTARG
is unset, n' a gangbangin' finger-lickin' diagnostic message is printed.
If
.B getopts
is silent, then a cold-ass lil colon (\^\fB:\fP\^) is placed in
.I name
and
.SM
.B OPTARG
is set ta tha option characta found.
.sp 1
.B getopts
returns legit if a option, specified or unspecified, is found.
It returns false if tha end of options is encountered or an
error occurs.
.TP
\fBhash\fP [\fB\-lr\fP] [\fB\-p\fP \fIfilename\fP] [\fB\-dt\fP] [\fIname\fP]
Each time \fBhash\fP is invoked,
the full pathname of tha command 
.I name
is determined by searching
the directories in
.B $PATH
and remembered. Y'all KNOW dat shit, muthafucka!  Any previously-remembered pathname is discarded.
If the
.B \-p
option is supplied, no path search is performed, and
.I filename
is used as tha full file name of tha command.
The
.B \-r
option causes tha shell ta forget all
remembered locations.
The
.B \-d
option causes tha shell ta forget tha remembered location of each \fIname\fP.
If the
.B \-t
option is supplied, tha full pathname ta which each \fIname\fP corresponds
is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If multiple \fIname\fP arguments is supplied wit \fB\-t\fP,
the \fIname\fP is printed before tha hashed full pathname.
The
.B \-l
option causes output ta be displayed up in a gangbangin' format dat may be reused as input.
If no arguments is given, or if only \fB\-l\fP is supplied,
information bout remembered commandz is printed.
Da return status is legit unless a
.I name
is not found or a invalid option is supplied.
.TP
\fBhelp\fP [\fB\-dms\fP] [\fIpattern\fP]
Display helpful shiznit bout builtin commands.  If
.I pattern
is specified,
.B help
gives detailed help on all commandz matching
.IR pattern ;
otherwise help fo' all tha builtins n' shell control structures
is printed.
.RS
.PD 0
.TP
.B \-d
Display a gangbangin' finger-lickin' dirty-ass short description of each \fIpattern\fP
.TP
.B \-m
Display tha description of each \fIpattern\fP up in a manpage-like format
.TP
.B \-s
Display only a gangbangin' finger-lickin' dirty-ass short usage synopsis fo' each \fIpattern\fP
.PD
.PP
Da return status is 0 unless no command matches
.IR pattern .
.RE
.TP
\fBhistory [\fIn\fP]
.PD 0
.TP
\fBhistory\fP \fB\-c\fP
.TP
\fBhistory \-d\fP \fIoffset\fP
.TP
\fBhistory\fP \fB\-anrw\fP [\fIfilename\fP]
.TP
\fBhistory\fP \fB\-p\fP \fIarg\fP [\fIarg ...\fP]
.TP
\fBhistory\fP \fB\-s\fP \fIarg\fP [\fIarg ...\fP]
.PD
With no options, display tha command
history list wit line numbers.  Lines listed
with a 
.B *
have been modified. Y'all KNOW dat shit, muthafucka!  An argument of
.I n
lists only tha last
.I n
lines.
If tha shell variable
.SM
.B HISTTIMEFORMAT
is set n' not null,
it is used as a gangbangin' format strang fo' \fIstrftime\fP(3) ta display
the time stamp associated wit each displayed history entry.
No intervenin blank is printed between tha formatted time stamp
and tha history line.
If \fIfilename\fP is supplied, it is used as the
name of tha history file; if not, tha value of
.SM
.B HISTFILE
is used. Y'all KNOW dat shit, muthafucka!  Options, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-c
Clear tha history list by deletin all tha entries.
.TP
\fB\-d\fP \fIoffset\fP
Delete tha history entry at posizzle \fIoffset\fP.
.TP
.B \-a
Append tha ``new'' history lines (history lines entered since the
beginnin of tha current \fBbash\fP session) ta tha history file.
.TP
.B \-n
Read tha history lines not already read from tha history
file tha fuck into tha current history list.  These is lines
appended ta tha history file since tha beginnin of the
current \fBbash\fP session.
.TP
.B \-r
Read tha contentz of tha history file
and use dem as tha current history.
.TP
.B \-w
Write tha current history ta tha history file, overwritin the
history filez contents.
.TP
.B \-p
Perform history substitution on tha followin \fIargs\fP n' display
the result on tha standard output.
Do not store tha thangs up in dis biatch up in tha history list.
Each \fIarg\fP must be quoted ta disable aiiight history expansion.
.TP
.B \-s
Store the
.I args
in tha history list as a single entry.  Da last command up in the
history list is removed before the
.I args
are added.
.PD
.PP
If the
.SM
.B HISTTIMEFORMAT
variable is set, tha time stamp shiznit
associated wit each history entry is freestyled ta tha history file,
marked wit tha history comment character.
When tha history file is read, lines beginnin wit tha history
comment characta followed immediately by a gangbangin' finger-lickin' digit is interpreted
as timestamps fo' tha previous history line.
Da return value is 0 unless a invalid option is encountered, an
error occurs while readin or freestylin tha history file, a invalid
\fIoffset\fP is supplied as a argument ta \fB\-d\fP, or the
history expansion supplied as a argument ta \fB\-p\fP fails.
.RE
.TP
\fBjobs\fP [\fB\-lnprs\fP] [ \fIjobspec\fP ... ]
.PD 0
.TP
\fBjobs\fP \fB\-x\fP \fIcommand\fP [ \fIargs\fP ... ]
.PD
Da first form lists tha actizzle thangs.  Da options have tha following
meanings:
.RS
.PD 0
.TP
.B \-l
List process IDs
in addizzle ta tha aiiight shiznit.
.TP
.B \-n
Display shiznit only bout thangs dat have chizzled status since
the user was last notified of they status.
.TP
.B \-p
List only tha process ID of tha thangz process group
leader.
.TP
.B \-r
Restrict output ta hustlin thangs.
.TP
.B \-s
Restrict output ta stopped thangs.
.PD
.PP
If
.I thangspec
is given, output is restricted ta shiznit bout dat thang.
Da return status is 0 unless a invalid option is encountered
or a invalid
.I thangspec
is supplied.
.PP
If the
.B \-x
option is supplied,
.B thangs
replaces any
.I thangspec
found in
.I command
or
.I args
with tha correspondin process crew ID, n' executes
.I command
passin it
.IR args ,
returnin its exit status.
.RE
.TP
\fBkill\fP [\fB\-s\fP \fIsigspec\fP | \fB\-n\fP \fIsignum\fP | \fB\-\fP\fIsigspec\fP] [\fIpid\fP | \fIjobspec\fP] ...
.PD 0
.TP
\fBkill\fP \fB\-l\fP [\fIsigspec\fP | \fIexit_status\fP]
.PD
Send tha signal named by
.I sigspec
or
.I signum
to tha processes named by
.I pid
or
.IR thangspec .
.I sigspec
is either a cold-ass lil case-insensitizzle signal name such as
.SM
.B SIGKILL
(with or without the
.SM
.B SIG
prefix) or a signal number;
.I signum
is a signal number.
If
.I sigspec
is not present, then
.SM
.B SIGTERM
is assumed.
An argument of
.B \-l
lists tha signal names.
If any arguments is supplied when
.B \-l
is given, tha namez of tha signals correspondin ta tha arguments are
listed, n' tha return status is 0.
Da \fIexit_status\fP argument to
.B \-l
is a number specifyin either a signal number or tha exit status of
a process terminated by a signal.
.B kill
returns legit if at least one signal was successfully sent, or false
if a error occurs or a invalid option is encountered.
.TP
\fBlet\fP \fIarg\fP [\fIarg\fP ...]
Each
.I arg
is a arithmetic expression ta be evaluated (see
.SM
.B "ARITHMETIC EVALUATION"
above).
If tha last
.I arg
evaluates ta 0,
.B let
returns 1; 0 is returned otherwise.
.TP
\fBlocal\fP [\fIoption\fP] [\fIname\fP[=\fIvalue\fP] ...]
For each argument, a local variable named
.I name 
is pimped, n' assigned
.IR value .
Da \fIoption\fP can be any of tha options accepted by \fBdeclare\fP.
When
.B local
is used within a gangbangin' function, it causes tha variable
.I name
to gotz a visible scope restricted ta dat function n' its lil' thugs.
With no operands,
.B local
writes a list of local variablez ta tha standard output.  It is
an error ta use
.B local
when not within a gangbangin' function. I aint talkin' bout chicken n' gravy biatch.  Da return status is 0 unless
.B local
is used outside a gangbangin' function, a invalid
.I name
is supplied, or
\fIname\fP be a readonly variable.
.TP
.B logout
Exit a login shell.
.TP
\fBmapfile\fP [\fB\-n\fP \fIcount\fP] [\fB\-O\fP \fIorigin\fP] [\fB\-s\fP \fIcount\fP] [\fB\-t\fP] [\fB\-u\fP \fIfd\fP] [\fB\-C\fP \fIcallback\fP] [\fB\-c\fP \fIquantum\fP] [\fIarray\fP]
.PD 0
.TP
\fBreadarray\fP [\fB\-n\fP \fIcount\fP] [\fB\-O\fP \fIorigin\fP] [\fB\-s\fP \fIcount\fP] [\fB\-t\fP] [\fB\-u\fP \fIfd\fP] [\fB\-C\fP \fIcallback\fP] [\fB\-c\fP \fIquantum\fP] [\fIarray\fP]
.PD
Read lines from tha standard input tha fuck into tha indexed array variable
.IR array ,
or from file descriptor 
.IR fd
if tha 
.B \-u
option is supplied.
Da variable
.SM
.B MAPFILE
is tha default \fIarray\fP.
Options, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-n
Copy at most
.I count
lines.  If \fIcount\fP is 0, all lines is copied.
.TP
.B \-O
Begin assignin to
.I array
at index
.IR origin .
Da default index is 0.
.TP
.B \-s
Discard tha straight-up original gangsta \fIcount\fP lines read.
.TP
.B \-t
Remove a trailin newline from each line read.
.TP
.B \-u
Read lines from file descriptor \fIfd\fP instead of tha standard input.
.TP
.B \-C
Evaluate
.I callback
each time \fIquantum\fP lines is read. Y'all KNOW dat shit, muthafucka!  Da \fB\-c\fP option specifies
.IR quantum .
.TP
.B \-c
Specify tha number of lines read between each call to
.IR callback .
.PD
.PP
If
.B \-C
is specified without 
.BR \-c ,
the default quantum is 5000.
When \fIcallback\fP is evaluated, it is supplied tha index of tha next
array element ta be assigned n' tha line ta be assigned ta dat element
as additionizzle arguments.
\fIcallback\fP is evaluated afta tha line is read but before tha 
array element be assigned.
.PP
If not supplied wit a explicit origin, \fBmapfile\fP will clear \fIarray\fP
before assignin ta dat shit.
.PP
\fBmapfile\fP returns successfully unless a invalid option or option
argument is supplied, \fIarray\fP is invalid or unassignable, or if
\fIarray\fP aint a indexed array.
.RE
.TP
\fBpopd\fP [\-\fBn\fP] [+\fIn\fP] [\-\fIn\fP]
Removes entries from tha directory stack.  With no arguments,
removes tha top directory from tha stack, n' performs a
.B cd
to tha freshly smoked up top directory.
Arguments, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-n
Suppresses tha aiiight chizzle of directory when removin directories
from tha stack, so dat only tha stack is manipulated.
.TP
\fB+\fP\fIn\fP
Removes tha \fIn\fPth entry countin from tha left of tha list
shown by
.BR dirs ,
startin wit zero.  For example:
.if n ``popd +0''
.if t \f(CWpopd +0\fP
removes tha straight-up original gangsta directory,
.if n ``popd +1''
.if t \f(CWpopd +1\fP
the second.
.TP
\fB\-\fP\fIn\fP
Removes tha \fIn\fPth entry countin from tha right of tha list
shown by
.BR dirs ,
startin wit zero.  For example:
.if n ``popd -0''
.if t \f(CWpopd -0\fP
removes tha last directory,
.if n ``popd -1''
.if t \f(CWpopd -1\fP
the next ta last.
.PD
.PP
If the
.B popd
command is successful, a 
.B dirs
is performed as well, n' tha return status is 0.
.B popd
returns false if a invalid option is encountered, tha directory stack
is empty, a non-existent directory stack entry is specified, or the
directory chizzle fails.
.RE
.TP
\fBprintf\fP [\fB\-v\fP \fIvar\fP] \fIformat\fP [\fIarguments\fP]
Write tha formatted \fIarguments\fP ta tha standard output under the
control of tha \fIformat\fP.
Da \fB\-v\fP option causes tha output ta be assigned ta tha variable
\fIvar\fP rather than bein printed ta tha standard output.
.sp 1
Da \fIformat\fP be a cold-ass lil characta strang which gotz nuff three typez of objects:
plain characters, which is simply copied ta standard output, character
escape sequences, which is converted n' copied ta tha standard output, and
format justifications, each of which causes printin of tha next successive
\fIargument\fP.
In addizzle ta tha standard \fIprintf\fP(1) format justifications,
\fBprintf\fP interprets tha followin extensions:
.RS
.PD 0
.TP
.B %b
causes
\fBprintf\fP ta expand backslash escape sequences up in tha corresponding
\fIargument\fP (except dat \fB\ec\fP terminates output, backslashes in
\fB\e\(aq\fP, \fB\e"\fP, n' \fB\e?\fP is not removed, n' octal escapes
beginnin wit \fB\e0\fP may contain up ta four digits).
.TP
.B %q
causes \fBprintf\fP ta output tha corresponding
\fIargument\fP up in a gangbangin' format dat can be reused as shell input.
.TP
.B %(\fIdatefmt\fP)T
causes \fBprintf\fP ta output tha date-time strang resultin from using
\fIdatefmt\fP as a gangbangin' format strang fo' \fIstrftime\fP(3).  Da corresponding
\fIargument\fP be a integer representin tha number of secondz since the
epoch.  Two special argument joints may be used: -1 represents tha current
time, n' -2 represents tha time tha shell was invoked.
.PD
.PP
Arguments ta non-strin format specifiers is treated as C constants,
except dat a leadin plus or minus sign be allowed, n' if tha leading
characta be a single or double quote, tha value is tha ASCII value of
the followin character.
.PP
Da \fIformat\fP is reused as necessary ta consume all of tha \fIarguments\fP.
If tha \fIformat\fP requires mo' \fIarguments\fP than is supplied, the
extra format justifications behave as if a zero value or null string, as
appropriate, had been supplied.
Da return value is zero on success, non-zero on failure.
.RE
.TP
\fBpushd\fP [\fB\-n\fP] [+\fIn\fP] [\-\fIn\fP]
.PD 0
.TP
\fBpushd\fP [\fB\-n\fP] [\fIdir\fP]
.PD
Addz a gangbangin' finger-lickin' directory ta tha top of tha directory stack, or rotates
the stack, makin tha freshly smoked up top of tha stack tha current working
directory.  With no arguments, exchanges tha top two directories
and returns 0, unless tha directory stack is empty.
Arguments, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-n
Suppresses tha aiiight chizzle of directory when addin directories
to tha stack, so dat only tha stack is manipulated.
.TP
\fB+\fP\fIn\fP
Rotates tha stack so dat tha \fIn\fPth directory
(countin from tha left of tha list shown by
.BR dirs ,
startin wit zero)
is all up in tha top.
.TP
\fB\-\fP\fIn\fP
Rotates tha stack so dat tha \fIn\fPth directory
(countin from tha right of tha list shown by
.BR dirs ,
startin wit zero) be all up in tha top.
.TP
.I dir
Adds
.I dir
to tha directory stack all up in tha top, makin it the
new current hustlin directory.
.PD
.PP
If the
.B pushd
command is successful, a 
.B dirs
is performed as well.
If tha straight-up original gangsta form is used,
.B pushd
returns 0 unless tha cd to
.I dir
fails.  With tha second form,
.B pushd
returns 0 unless tha directory stack is empty,
a non-existent directory stack element is specified,
or tha directory chizzle ta tha specified freshly smoked up current directory
fails.
.RE
.TP
\fBpwd\fP [\fB\-LP\fP]
Print tha absolute pathname of tha current hustlin directory.
Da pathname printed gotz nuff no symbolic links if the
.B \-P
option is supplied or tha 
.B \-o physical
option ta the
.B set
builtin command is enabled.
If the
.B \-L
option is used, tha pathname printed may contain symbolic links.
Da return status is 0 unless a error occurs while
readin tha name of tha current directory or an
invalid option is supplied.
.TP
\fBread\fP [\fB\-ers\fP] [\fB\-a\fP \fIaname\fP] [\fB\-d\fP \fIdelim\fP] [\fB\-i\fP \fItext\fP] [\fB\-n\fP \fInchars\fP] [\fB\-N\fP \fInchars\fP] [\fB\-p\fP \fIprompt\fP] [\fB\-t\fP \fItimeout\fP] [\fB\-u\fP \fIfd\fP] [\fIname\fP ...]
One line is read from tha standard input, or from tha file descriptor
\fIfd\fP supplied as a argument ta tha \fB\-u\fP option, n' tha straight-up original gangsta word
is assigned ta tha first
.IR name ,
the second word ta tha second
.IR name ,
and so on, wit leftover lyrics n' they intervenin separators assigned
to tha last
.IR name .
If there be fewer lyrics read from tha input stream than names,
the remainin names is assigned empty joints.
Da charactas up in 
.SM
.B IFS
are used ta split tha line tha fuck into lyrics.
Da backslash characta (\fB\e\fP) may be used ta remove any special
meanin fo' tha next characta read n' fo' line continuation.
Options, if supplied, have tha followin meanings:
.RS
.PD 0
.TP
.B \-a \fIaname\fP
Da lyrics is assigned ta sequential indices
of tha array variable
.IR aname ,
startin at 0.
.I aname
is unset before any freshly smoked up joints is assigned.
Other \fIname\fP arguments is ignored.
.TP
.B \-d \fIdelim\fP
Da first characta of \fIdelim\fP is used ta terminizzle tha input line,
rather than newline.
.TP
.B \-e
If tha standard input
is comin from a terminal,
.B readline
(see
.SM
.B READLINE
above) is used ta obtain tha line.
Readline uses tha current (or default, if line editin was not previously
active) editin settings.
.TP
.B \-i \fItext\fP
If
.B readline
is bein used ta read tha line, \fItext\fP is placed tha fuck into tha editing
buffer before editin begins.
.TP
.B \-n \fInchars\fP
\fBread\fP returns afta readin \fInchars\fP charactas rather than
waitin fo' a cold-ass lil complete line of input yo, but honor a thugged-out delimita if fewer
than \fInchars\fP charactas is read before tha delimiter.
.TP
.B \-N \fInchars\fP
\fBread\fP returns afta readin exactly \fInchars\fP charactas rather
than waitin fo' a cold-ass lil complete line of input, unless EOF is encountered or
\fBread\fP times out.
Delimita charactas encountered up in tha input are
not treated specially n' do not cause \fBread\fP ta return until
\fInchars\fP charactas is read.
.TP
.B \-p \fIprompt\fP
Display \fIprompt\fP on standard error, without a
trailin newline, before attemptin ta read any input.  Da prompt
is displayed only if input is comin from a terminal.
.TP
.B \-r
Backslash do not act as a escape character.
Da backslash is considered ta be part of tha line.
In particular, a funky-ass backslash-newline pair may not be used as a line
continuation.
.TP
.B \-s
Silent mode.  If input is comin from a terminal, charactas are
not echoed.
.TP
.B \-t \fItimeout\fP
Cause \fBread\fP ta time up n' return failure if a cold-ass lil complete line of
input aint read within \fItimeout\fP seconds.
\fItimeout\fP may be a thugged-out decimal number wit a gangbangin' fractionizzle portion following
the decimal point.
This option is only effectizzle if \fBread\fP is readin input from a
terminal, pipe, or other special file; it has no effect when reading
from regular files.
If \fItimeout\fP is 0, \fBread\fP returns success if input be available on
the specified file descriptor, failure otherwise.
Da exit status is pimped outa than 128 if tha timeout is exceeded.
.TP
.B \-u \fIfd\fP
Read input from file descriptor \fIfd\fP.
.PD
.PP
If no
.I names
are supplied, tha line read be assigned ta tha variable
.SM
.BR REPLY .
Da return code is zero, unless end-of-file is encountered, \fBread\fP
times up (in which case tha return code is pimped outa than 128), or an
invalid file descriptor is supplied as tha argument ta \fB\-u\fP.
.RE
.TP
\fBreadonly\fP [\fB\-aAf\fP] [\fB\-p\fP] [\fIname\fP[=\fIword\fP] ...]
.PD
Da given
\fInames\fP is marked readonly; tha jointz of these
.I names
may not be chizzled by subsequent assignment.
If the
.B \-f
option is supplied, tha functions correspondin ta the
\fInames\fP is so
marked.
The
.B \-a
option restricts tha variablez ta indexed arrays; the
.B \-A
option restricts tha variablez ta associatizzle arrays.
If both options is supplied,
.B \-A
takes precedence.
If no
.I name
arguments is given, or if the
.B \-p
option is supplied, a list of all readonly names is printed.
Da other options may be used ta restrict tha output ta a subset of
the set of readonly names.
The
.B \-p
option causes output ta be displayed up in a gangbangin' format that
may be reused as input.
If a variable name is followed by =\fIword\fP, tha value of
the variable is set ta \fIword\fP.
Da return status is 0 unless a invalid option is encountered,
one of the
.I names
is not a valid shell variable name, or
.B \-f
is supplied wit a
.I name
that aint a gangbangin' function.
.TP
\fBreturn\fP [\fIn\fP]
Causes a gangbangin' function ta exit wit tha return value specified by
.IR n .
If 
.I n
is omitted, tha return status is dat of tha last command
executed up in tha function body.  If used outside a gangbangin' function,
but durin execution of a script by tha 
.B .
(\fBsource\fP) command, it causes tha shell ta stop executing
that script n' return either
.I n
or tha exit statuz of tha last command executed within the
script as tha exit statuz of tha script.  If used outside a
function n' not durin execution of a script by \fB.\fP\^,
the return status is false.
Any command associated wit tha \fBRETURN\fP trap is executed
before execution resumes afta tha function or script.
.TP
\fBset\fP [\fB\-\-abefhkmnptuvxBCEHPT\fP] [\fB\-o\fP \fIoption\-name\fP] [\fIarg\fP ...]
.PD 0
.TP
\fBset\fP [\fB+abefhkmnptuvxBCEHPT\fP] [\fB+o\fP \fIoption\-name\fP] [\fIarg\fP ...]
.PD
Without options, tha name n' value of each shell variable is displayed
in a gangbangin' format dat can be reused as input
for settin or resettin tha currently-set variables.
Read-only variablez cannot be reset.
In \fIposix mode\fP, only shell variablez is listed.
Da output is sorted accordin ta tha current locale.
When options is specified, they set or unset shell attributes.
Any arguments remainin afta option processin is treated
as joints fo' tha positionizzle parametas n' is assigned, up in order, ta 
.BR $1 ,
.BR $2 ,
.B ...
.BR $\fIn\fP .
Options, if specified, have tha followin meanings:
.RS
.PD 0
.TP 8
.B \-a
Automatically mark variablez n' functions which is modified or
created fo' export ta tha environment of subsequent commands.
.TP 8
.B \-b
Report tha statuz of terminated background thangs
immediately, rather than before tha next primary prompt.  This is
effectizzle only when thang control is enabled.
.TP 8
.B \-e
Exit immediately if a \fIpipeline\fP (which may consist of a single
\fIsimple command\fP),  a \fIsubshell\fP command enclosed up in parentheses,
or one of tha commandz executed as part of a cold-ass lil command list enclosed
by braces (see
.SM
.B SHELL GRAMMAR
above) exits wit a non-zero status.
Da shell do not exit if the
command dat fails is part of tha command list immediately followin a
.B while
or
.B until
keyword, 
part of tha test followin the
.B if
or
.B elif
reserved lyrics, part of any command executed up in a
.B &&
or
.B ||
list except tha command followin tha final \fB&&\fP or \fB||\fP,
any command up in a pipeline but tha last,
or if tha commandz return value is
bein inverted with
.BR ! .
A trap on \fBERR\fP, if set, is executed before tha shell exits.
This option applies ta tha shell environment n' each subshell environment
separately (see
.SM
.B "COMMAND EXECUTION ENVIRONMENT"
above), n' may cause
subshells ta exit before executin all tha commandz up in tha subshell.
.TP 8
.B \-f
Disable pathname expansion.
.TP 8 
.B \-h
Remember tha location of commandz as they is looked up fo' execution.
This is enabled by default.
.TP 8
.B \-k
All arguments up in tha form of assignment statements
are placed up in tha environment fo' a cold-ass lil command, not just
those dat precede tha command name.
.TP 8
.B \-m
Monitor mode.  Thang control is enabled. Y'all KNOW dat shit, muthafucka!  This option is on
by default fo' interactizzle shells on systems dat support
it (see
.SM
.B JOB CONTROL
above).  Background processes run up in a separate process
group n' a line containin they exit status is printed
upon they completion.
.TP 8
.B \-n
Read commandz but do not execute em.  This may be used ta 
check a gangbangin' finger-lickin' dirty-ass shell script fo' syntax errors.  This is ignored by
interactizzle shells.
.TP 8
.B \-o \fIoption\-name\fP
Da \fIoption\-name\fP can be one of tha following:
.RS
.TP 8
.B allexport
Same as
.BR \-a .
.TP 8
.B braceexpand
Same as
.BR \-B .
.TP 8
.B emacs
Use a emacs-style command line editin intercourse.  This is enabled
by default when tha shell is interactive, unless tha shell is started
with the
.B \-\-noediting
option.
This also affects tha editin intercourse used fo' \fBread \-e\fP.
.TP 8
.B errexit
Same as
.BR \-e .
.TP 8
.B errtrace
Same as
.BR \-E .
.TP 8
.B functrace
Same as
.BR \-T .
.TP 8
.B hashall
Same as
.BR \-h .
.TP 8
.B histexpand
Same as
.BR \-H .
.TP 8
.B history
Enable command history, as busted lyrics bout above under
.SM
.BR HISTORY .
This option is on by default up in interactizzle shells.
.TP 8
.B ignoreeof
Da effect be as if tha shell command
.if t \f(CWIGNOREEOF=10\fP
.if n ``IGNOREEOF=10''
had been executed
(see
.B Shell Variables
above).
.TP 8
.B keyword
Same as
.BR \-k .
.TP 8
.B monitor
Same as
.BR \-m .
.TP 8
.B noclobber
Same as
.BR \-C .
.TP 8
.B noexec
Same as
.BR \-n .
.TP 8
.B noglob
Same as
.BR \-f .
.TP 8
.B nolog
Currently ignored.
.TP 8
.B notify
Same as
.BR \-b .
.TP 8
.B nounset
Same as
.BR \-u .
.TP 8
.B onecmd
Same as
.BR \-t .
.TP 8
.B physical
Same as
.BR \-P .
.TP 8
.B pipefail
If set, tha return value of a pipeline is tha value of tha last
(rightmost) command ta exit wit a non-zero status, or zero if all
commandz up in tha pipeline exit successfully.
This option is disabled by default.
.TP 8
.B posix
Change tha behavior of
.B bash
where tha default operation differs
from tha POSIX standard ta match tha standard (\fIposix mode\fP).
.TP 8
.B privileged
Same as
.BR \-p .
.TP 8
.B verbose
Same as
.BR \-v .
.TP 8
.B vi
Use a vi-style command line editin intercourse.
This also affects tha editin intercourse used fo' \fBread \-e\fP.
.TP 8
.B xtrace
Same as
.BR \-x .
.sp .5
.PP
If
.B \-o
is supplied wit no \fIoption\-name\fP, tha jointz of tha current options are
printed.
If
.B +o
is supplied wit no \fIoption\-name\fP, a series of
.B set
commandz ta recreate tha current option settings is displayed on
the standard output.
.RE
.TP 8
.B \-p
Turn on
.I privileged
mode.  In dis mode, the
.SM
.B $ENV
and
.SM
.B $BASH_ENV
filez is not processed, shell functions is not inherited from the
environment, n' the
.SM
.BR SHELLOPTS ,
.SM
.BR BASHOPTS ,
.SM
.BR CDPATH ,
and
.SM
.B GLOBIGNORE
variables, if they step tha fuck up in tha environment, is ignored.
If tha shell is started wit tha effectizzle user (group) id not equal ta the
real user (group) id, n' tha \fB\-p\fP option aint supplied, these actions
are taken n' tha effectizzle user id is set ta tha real user id.
If tha \fB\-p\fP option is supplied at startup, tha effectizzle user id is
not reset.
Turnin dis option off causes tha effectizzle user
and crew idz ta be set ta tha real user n' crew ids.
.TP 8
.B \-t
Exit afta readin n' executin one command.
.TP 8
.B \-u
Treat unset variablez n' parametas other than tha special
parametas "@" n' "*" as a error when struttin
parameta expansion. I aint talkin' bout chicken n' gravy biatch.  If expansion be attempted on an
unset variable or parameter, tha shell prints a error message, and,
if not interactive, exits wit a non-zero status.
.TP 8
.B \-v
Print shell input lines as they is read.
.TP 8
.B \-x
Afta expandin each \fIsimple command\fP,
\fBfor\fP command, \fBcase\fP command, \fBselect\fP command, or
arithmetic \fBfor\fP command, display tha expanded value of
.SM
.BR PS4 ,
followed by tha command n' its expanded arguments
or associated word list.
.TP 8
.B \-B
Da shell performs brace expansion (see
.B Brace Expansion
above).  This is on by default.
.TP 8
.B \-C
If set,
.B bash
does not overwrite a existin file wit the
.BR > ,
.BR >& ,
and
.B <>
redirection operators.  This may be overridden when 
bustin output filez by rockin tha redirection operator
.B >|
instead of
.BR > .
.TP 8
.B \-E
If set, any trap on \fBERR\fP is inherited by shell functions, command
substitutions, n' commandz executed up in a subshell environment.
Da \fBERR\fP trap is normally not inherited up in such cases.
.TP 8
.B \-H
Enable
.B !
style history substitution. I aint talkin' bout chicken n' gravy biatch.  This option is on by
default when tha shell is interactive.
.TP 8
.B \-P
If set, tha shell do not follow symbolic links when executing
commandz such as
.B cd
that chizzle tha current hustlin directory.  It uses the
physical directory structure instead. Y'all KNOW dat shit, muthafucka!  By default,
.B bash
bigs up tha logical chain of directories when struttin commands
which chizzle tha current directory.
.TP 8
.B \-T
If set, any traps on \fBDEBUG\fP n' \fBRETURN\fP is inherited by shell
functions, command substitutions, n' commandz executed up in a
subshell environment.
Da \fBDEBUG\fP n' \fBRETURN\fP traps is normally not inherited
in such cases.
.TP 8
.B \-\-
If no arguments follow dis option, then tha positionizzle parametas are
unset.  Otherwise, tha positionizzle parametas is set ta the
\fIarg\fPs, even if a shitload of dem begin wit a
.BR \- .
.TP 8
.B \-
Signal tha end of options, cause all remainin \fIarg\fPs ta be
assigned ta tha positionizzle parameters.  The
.B \-x
and
.B \-v
options is turned off.
If there be no \fIarg\fPs,
the positionizzle parametas remain unchanged.
.PD
.PP
Da options is off by default unless otherwise noted.
Usin + rather than \- causes these options ta be turned off.
Da options can also be specified as arguments ta a invocation of
the shell.
Da current set of options may be found in
.BR $\- .
Da return status be always legit unless a invalid option is encountered.
.RE
.TP
\fBshift\fP [\fIn\fP]
Da positionizzle parametas from \fIn\fP+1 ... is renamed to
.B $1
.B ....
Parametas represented by tha numbers \fB$#\fP
down ta \fB$#\fP\-\fIn\fP+1 is unset.
.I n
must be a non-negatizzle number less than or equal ta \fB$#\fP.
If
.I n
is 0, no parametas is chizzled.
If
.I n 
is not given, it be assumed ta be 1.
If
.I n
is pimped outa than \fB$#\fP, tha positionizzle parametas is not chizzled.
Da return status is pimped outa than zero if
.I n
is pimped outa than
.B $#
or less than zero; otherwise 0.
.TP
\fBshopt\fP [\fB\-pqsu\fP] [\fB\-o\fP] [\fIoptname\fP ...]
Toggle tha jointz of variablez controllin optionizzle shell behavior.
With no options, or wit the
.B \-p
option, a list of all settable options is displayed, with
an indication of whether or not each is set.
Da \fB\-p\fP option causes output ta be displayed up in a gangbangin' form that
may be reused as input.
Other options have tha followin meanings:
.RS
.PD 0
.TP
.B \-s
Enable (set) each \fIoptname\fP.
.TP
.B \-u
Disable (unset) each \fIoptname\fP.
.TP
.B \-q
Suppresses aiiight output (quiet mode); tha return status indicates
whether tha \fIoptname\fP is set or unset.
If multiple \fIoptname\fP arguments is given with
.BR \-q ,
the return status is zero if all \fIoptnames\fP is enabled; non-zero
otherwise.
.TP
.B \-o
Restricts tha jointz of \fIoptname\fP ta be dem defined fo' the
.B \-o
option ta the
.B set
builtin.
.PD
.PP
If either
.B \-s
or
.B \-u
is used wit no \fIoptname\fP arguments, tha display is limited to
those options which is set or unset, respectively.
Unless otherwise noted, tha \fBshopt\fP options is disabled (unset)
by default.
.PP
Da return status when listin options is zero if all \fIoptnames\fP
are enabled, non-zero otherwise.  When settin or unsettin options,
the return status is zero unless a \fIoptname\fP aint a valid shell
option.
.PP
Da list of \fBshopt\fP options is:
.if t .sp .5v
.if n .sp 1v
.PD 0
.TP 8
.B autocd
If set, a cold-ass lil command name dat is tha name of a gangbangin' finger-lickin' directory is executed as if
it was tha argument ta tha \fBcd\fP command.
This option is only used by interactizzle shells.
.TP 8
.B cdable_vars
If set, a argument ta the
.B cd
builtin command that
is not a gangbangin' finger-lickin' directory be assumed ta be tha name of a variable whose
value is tha directory ta chizzle to.
.TP 8
.B cdspell
If set, minor errors up in tha spellin of a gangbangin' finger-lickin' directory component up in a
.B cd
command is ghon be erected.
Da errors checked fo' is transposed characters,
a missin character, n' one characta too many.
If a cold-ass lil erection is found, tha erected file name is printed,
and tha command proceeds.
This option is only used by interactizzle shells.
.TP 8
.B checkhash
If set, \fBbash\fP checks dat a cold-ass lil command found up in tha hash
table exists before tryin ta execute dat shit.  If a hashed command no
longer exists, a aiiight path search is performed.
.TP 8
.B checkjobs
If set, \fBbash\fP lists tha statuz of any stopped n' hustlin thangs before
exitin a interactizzle shell.  If any thangs is hustlin, dis causes
the exit ta be deferred until a second exit be attempted without an
intervenin command (see
.SM
.B "JOB CONTROL"
above).  Da shell always
postpones exitin if any thangs is stopped.
.TP 8
.B checkwinsize
If set, \fBbash\fP checks tha window size afta each command
and, if necessary, thugged-out shiznit tha joints of
.SM
.B LINES
and
.SM
.BR COLUMNS .
.TP 8
.B cmdhist
If set,
.B bash
attempts ta save all linez of a multiple-line
command up in tha same history entry.  This allows
easy re-editin of multi-line commands.
.TP 8
.B compat31
If set,
.B bash
changes its behavior ta dat of version 3.1 wit respect ta quoted
arguments ta tha \fB[[\fP conditionizzle commandz \fB=~\fP operator.
.TP 8
.B compat32
If set,
.B bash
changes its behavior ta dat of version 3.2 wit respect ta locale-specific
strin comparison when rockin tha \fB[[\fP
conditionizzle commandz \fB<\fP n' \fB>\fP operators.
Bash versions prior ta bash-4.1 use ASCII collation and
.IR strcmp (3);
bash-4.1 n' later
use tha current localez collation sequence and
.IR strcoll (3).
.TP 8
.B compat40
If set,
.B bash
changes its behavior ta dat of version 4.0 wit respect ta locale-specific
strin comparison when rockin tha \fB[[\fP
conditionizzle commandz \fB<\fP n' \fB>\fP operators (see previous item)
and tha effect of interruptin a cold-ass lil command list.
.TP 8
.B compat41
If set,
.BR bash ,
when up in posix mode, treats a single quote up in a thugged-out double-quoted
parameta expansion as a special character n' shit.  Da single quotes must match
(an even number) n' tha charactas between tha single quotes is considered
quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is tha behavior of posix mode all up in version 4.1.
Da default bash behavior remains as up in previous versions.
.TP 8
.B direxpand
If set,
.B bash
replaces directory names wit tha thangs up in dis biatch of word expansion when struttin
filename completion. I aint talkin' bout chicken n' gravy biatch.  This chizzlez tha contentz of tha readline editing
buffer.
If not set,
.B bash
attempts ta preserve what tha fuck tha user typed.
.TP 8
.B dirspell
If set,
.B bash
attempts spellin erection on directory names durin word completion
if tha directory name initially supplied do not exist.
.TP 8
.B dotglob
If set, 
.B bash
includes filenames beginnin wit a `.' up in tha thangs up in dis biatch of pathname
expansion.
.TP 8
.B execfail
If set, a non-interactizzle shell aint gonna exit if
it cannot execute tha file specified as a argument ta the
.B exec
builtin command. Y'all KNOW dat shit, muthafucka!  An interactizzle shell do not exit if
.B exec
fails.
.TP 8
.B expand_aliases
If set, aliases is expanded as busted lyrics bout above under
.SM
.BR ALIASES .
This option is enabled by default fo' interactizzle shells.
.TP 8
.B extdebug
If set, behavior intended fo' use by debuggers is enabled:
.RS
.TP
.B 1.
Da \fB\-F\fP option ta tha \fBdeclare\fP builtin displays tha source
file name n' line number correspondin ta each function name supplied
as a argument.
.TP
.B 2.
If tha command run by tha \fBDEBUG\fP trap returns a non-zero value, the
next command is skipped n' not executed.
.TP
.B 3.
If tha command run by tha \fBDEBUG\fP trap returns a value of 2, n' the
shell is executin up in a subroutine (a shell function or a gangbangin' finger-lickin' dirty-ass shell script
executed by tha \fB.\fP or \fBsource\fP builtins), a cold-ass lil call to
\fBreturn\fP is simulated.
.TP
.B 4.
.SM
.B BASH_ARGC
and
.SM
.B BASH_ARGV
are updated as busted lyrics bout up in they descriptions above.
.TP
.B 5.
Function tracin is enabled:  command substitution, shell functions, and
subshells invoked wit \fB(\fP \fIcommand\fP \fB)\fP inherit the
\fBDEBUG\fP n' \fBRETURN\fP traps.
.TP
.B 6.
Error tracin is enabled:  command substitution, shell functions, and
subshells invoked wit \fB(\fP \fIcommand\fP \fB)\fP inherit the
\fBERR\fP trap.
.RE
.TP 8
.B extglob
If set, tha extended pattern matchin features busted lyrics bout above under
\fBPathname Expansion\fP is enabled.
.TP 8
.B extquote
If set, \fB$\fP\(aq\fIstring\fP\(aq n' \fB$\fP"\fIstring\fP" quotin is
performed within \fB${\fP\fIparameter\fP\fB}\fP expansions
enclosed up in double quotes.  This option is enabled by default.
.TP 8
.B failglob
If set, patterns which fail ta match filenames durin pathname expansion
result up in a expansion error.
.TP 8
.B force_fignore
If set, tha suffixes specified by the
.SM
.B FIGNORE
shell variable
cause lyrics ta be ignored when struttin word completion even if
the ignored lyrics is tha only possible completions.
See
.SM
\fBSHELL VARIABLES\fP
above fo' a thugged-out description of
.SM
.BR FIGNORE .
This option is enabled by default.
.TP 8
.B globstar
If set, tha pattern \fB**\fP used up in a pathname expansion context will
match all filez n' zero or mo' directories n' subdirectories.
If tha pattern is followed by a \fB/\fP, only directories and
subdirectories match.
.TP 8
.B gnu_errfmt
If set, shell error lyrics is freestyled up in tha standard GNU error
message format.
.TP 8
.B histappend
If set, tha history list be appended ta tha file named by tha value
of the
.SM
.B HISTFILE
variable when tha shell exits, rather than overwritin tha file.
.TP 8
.B histreedit
If set, and
.B readline
is bein used, a user is given tha opportunitizzle ta re-edit a
failed history substitution.
.TP 8
.B histverify
If set, n' 
.B readline
is bein used, tha thangs up in dis biatch of history substitution is not immediately
passed ta tha shell parser n' shit.  Instead, tha resultin line is loaded into
the \fBreadline\fP editin buffer, allowin further modification.
.TP 8
.B hostcomplete
If set, and
.B readline
is bein used, \fBbash\fP will attempt ta big-ass up hostname completion when a
word containin a \fB@\fP is bein completed (see
.B Completing
under
.SM
.B READLINE
above).
This is enabled by default.
.TP 8
.B huponexit
If set, \fBbash\fP will send
.SM
.B SIGHUP
to all thangs when a interactizzle login shell exits.
.TP 8
.B interactive_comments
If set, allow a word beginnin with
.B #
to cause dat word n' all remainin charactas on that
line ta be ignored up in a interactizzle shell (see
.SM
.B COMMENTS
above).  This option is enabled by default.
.TP 8
.B lastpipe
If set, n' thang control aint active, tha shell runs tha last command of
a pipeline not executed up in tha background up in tha current shell environment.
.TP 8
.B lithist
If set, n' the
.B cmdhist
option is enabled, multi-line commandz is saved ta tha history with
embedded newlines rather than rockin semicolon separators where possible.
.TP 8
.B login_shell
Da shell sets dis option if it is started as a login shell (see
.SM
.B "INVOCATION"
above).
Da value may not be chizzled.
.TP 8
.B mailwarn
If set, n' a gangbangin' file dat \fBbash\fP is checkin fo' mail has been  
accessed since tha last time dat shiznit was checked, tha message ``Da mail in
\fImailfile\fP has been read'' is displayed.
.TP 8
.B no_empty_cmd_completion
If set, and
.B readline
is bein used,
.B bash
will not attempt ta search the
.SM
.B PATH
for possible completions when
completion be attempted on a empty line.
.TP 8
.B nocaseglob
If set,
.B bash
matches filenames up in a cold-ass lil case\-insensitizzle fashizzle when struttin pathname
expansion (see
.B Pathname Expansion
above).
.TP 8
.B nocasematch
If set,
.B bash
matches patterns up in a cold-ass lil case\-insensitizzle fashizzle when struttin matching
while executin \fBcase\fP or \fB[[\fP conditionizzle commands.
.TP 8
.B nullglob
If set,
.B bash
allows patterns which match no
filez (see
.B Pathname Expansion
above)
to expand ta a null string, rather than theyselves.
.TP 8
.B progcomp
If set, tha programmable completion facilitizzles (see
\fBProgrammable Completion\fP above) is enabled.
This option is enabled by default.
.TP 8
.B promptvars
If set, prompt strings undergo
parameta expansion, command substitution, arithmetic
expansion, n' quote removal afta bein expanded as busted lyrics bout in
.SM
.B PROMPTING
above.  This option is enabled by default.
.TP 8
.B restricted_shell
Da shell sets dis option if it is started up in restricted mode (see
.SM
.B "RESTRICTED SHELL"
below).
Da value may not be chizzled.
This aint reset when tha startup filez is executed, allowing
the startup filez ta discover whether or not a gangbangin' finger-lickin' dirty-ass shell is restricted.
.TP 8
.B shift_verbose
If set, the
.B shift
builtin prints a error message when tha shift count exceedz the
number of positionizzle parameters.
.TP 8
.B sourcepath
If set, the
\fBsource\fP (\fB.\fP) builtin uses tha value of
.SM
.B PATH
to find tha directory containin tha file supplied as a argument.
This option is enabled by default.
.TP 8
.B xpg_echo
If set, tha \fBecho\fP builtin expandz backslash-escape sequences
by default.
.RE
.PD
.TP
\fBsuspend\fP [\fB\-f\fP]
Suspend tha execution of dis shell until it receives a
.SM
.B SIGCONT
signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  A login shell cannot be suspended; the
.B \-f
option can be used ta override dis n' force tha suspension.
Da return status is 0 unless tha shell be a login shell and
.B \-f
is not supplied, or if thang control aint enabled.
.TP
\fBtest\fP \fIexpr\fP
.PD 0
.TP
\fB[\fP \fIexpr\fP \fB]\fP
Return a statuz of 0 or 1 dependin on
the evaluation of tha conditionizzle expression
.IR expr .
Each operator n' operand must be a separate argument.
Expressions is composed of tha primaries busted lyrics bout above under
.SM
.BR "CONDITIONAL EXPRESSIONS" .
\fBtest\fP do not accept any options, nor do it accept n' ignore
an argument of \fB\-\-\fP as signifyin tha end of options.
.if t .sp 0.5
.if n .sp 1
Expressions may be combined rockin tha followin operators, listed
in decreasin order of precedence.
Da evaluation dependz on tha number of arguments; peep below.
Operator precedence is used when there be five or mo' arguments.
.RS
.PD 0
.TP
.B ! \fIexpr\fP
True if
.I expr
is false.
.TP
.B ( \fIexpr\fP )
Returns tha value of \fIexpr\fP.
This may be used ta override tha aiiight precedence of operators.
.TP
\fIexpr1\fP \-\fBa\fP \fIexpr2\fP
True if both
.I expr1
and
.I expr2
are true.
.TP
\fIexpr1\fP \-\fBo\fP \fIexpr2\fP
True if either
.I expr1
or
.I expr2
is true.
.PD
.PP
\fBtest\fP n' \fB[\fP evaluate conditional
expressions rockin a set of rulez based on tha number of arguments.
.if t .sp 0.5
.if n .sp 1
.PD 0
.TP
0 arguments
Da expression is false.
.TP
1 argument
Da expression is legit if n' only if tha argument aint null.
.TP
2 arguments
If tha straight-up original gangsta argument is \fB!\fP, tha expression is legit if and
only if tha second argument is null.
If tha straight-up original gangsta argument is one of tha unary conditionizzle operators listed above
under
.SM
.BR "CONDITIONAL EXPRESSIONS" ,
the expression is legit if tha unary test is true.
If tha straight-up original gangsta argument aint a valid unary conditionizzle operator, tha expression
is false.
.TP
3 arguments
Da followin conditions is applied up in tha order listed.
If tha second argument is one of tha binary conditionizzle operators listed above
under
.SM
.BR "CONDITIONAL EXPRESSIONS" ,
the result of tha expression is tha result of tha binary test using
the first n' third arguments as operands.
Da \fB\-a\fP n' \fB\-o\fP operators is considered binary operators
when there be three arguments, n' you can put dat on yo' toast.  
If tha straight-up original gangsta argument is \fB!\fP, tha value is tha negation of
the two-argument test rockin tha second n' third arguments.
If tha straight-up original gangsta argument is exactly \fB(\fP n' tha third argument is
exactly \fB)\fP, tha result is tha one-argument test of tha second
argument.
Otherwise, tha expression is false.
.TP
4 arguments
If tha straight-up original gangsta argument is \fB!\fP, tha result is tha negation of
the three-argument expression composed of tha remainin arguments.
Otherwise, tha expression is parsed n' evaluated accordin ta 
precedence rockin tha rulez listed above.
.TP
5 or mo' arguments
Da expression is parsed n' evaluated accordin ta precedence
usin tha rulez listed above.
.if t .sp 0.5
.if n .sp 1
.LP
When used wit \fBtest\fP or \fB[\fP, tha \fB<\fP n' \fB>\fP operators
sort lexicographically rockin ASCII ordering.
.RE
.PD
.TP
.B times
Print tha accumulated user n' system times fo' tha shell and
for processes run from tha shell.  Da return status is 0.
.TP
\fBtrap\fP [\fB\-lp\fP] [[\fIarg\fP] \fIsigspec\fP ...]
Da command
.I arg
is ta be read n' executed when tha shell receives
signal(s)
.IR sigspec .
If
.I arg
is absent (and there be a single \fIsigspec\fP) or
.BR \- ,
each specified signal is
reset ta its original gangsta disposizzle (the value it had
upon entrizzle ta tha shell).
If 
.I arg
is tha null strang tha signal specified by each
.I sigspec
is ignored by tha shell n' by tha commandz it invokes.
If
.I arg
is not present and
.B \-p
has been supplied, then tha trap commandz associated wit each
.I sigspec
are displayed.
If no arguments is supplied or if only
.B \-p
is given,
.B trap
prints tha list of commandz associated wit each signal.
The
.B \-l
option causes tha shell ta print a list of signal names and
their correspondin numbers.
Each
.I sigspec
is either
a signal name defined up in <\fIsignal.h\fP>, or a signal number.
Signal names is case insensitizzle n' the
.SM
.B SIG
prefix is optional.
.if t .sp 0.5
.if n .sp 1
If a
.I sigspec
is
.SM
.B EXIT
(0) tha command
.I arg
is executed on exit from tha shell.
If a
.I sigspec
is
.SM
.BR DEBUG ,
the command
.I arg
is executed before every last muthafuckin \fIsimple command\fP, \fIfor\fP command,
\fIcase\fP command, \fIselect\fP command, every last muthafuckin arithmetic \fIfor\fP
command, n' before tha straight-up original gangsta command executes up in a gangbangin' finger-lickin' dirty-ass shell function (see
.SM
.B SHELL GRAMMAR
above).
Refer ta tha description of tha \fBextdebug\fP option ta the
\fBshopt\fP builtin fo' detailz of its effect on tha \fBDEBUG\fP trap.
If a
.I sigspec
is
.SM
.BR RETURN ,
the command
.I arg
is executed each time a gangbangin' finger-lickin' dirty-ass shell function or a script executed with
the \fB.\fP or \fBsource\fP builtins finishes executing.
.if t .sp 0.5
.if n .sp 1
If a
.I sigspec
is
.SM
.BR ERR ,
the command
.I arg
is executed whenever a simple command has a non\-zero exit status,
subject ta tha followin conditions.
The
.SM
.B ERR
trap aint executed if tha failed
command is part of tha command list immediately followin a
.B while
or
.B until
keyword, 
part of tha test up in an
.I if
statement, part of a cold-ass lil command executed up in a
.B &&
or
.B ||
list, or if tha commandz return value is
bein inverted via
.BR ! .
These is tha same conditions obeyed by tha \fBerrexit\fP option.
.if t .sp 0.5
.if n .sp 1
Signals ignored upon entry ta tha shell cannot be trapped, reset or listed.
Trapped signals dat is not bein ignored is reset ta they original
values up in a subshell or subshell environment when one is pimped.
Da return status is false if any
.I sigspec
is invalid; otherwise
.B trap
returns true.
.TP
\fBtype\fP [\fB\-aftpP\fP] \fIname\fP [\fIname\fP ...]
With no options, 
indicate how tha fuck each
.I name
would be interpreted if used as a cold-ass lil command name.
If the
.B \-t
option is used,
.B type
prints a strang which is one of
.IR alias ,
.IR keyword ,
.IR function ,
.IR builtin ,
or
.I file 
if
.I name
is a alias, shell reserved word, function, builtin, or disk file,
respectively.
If the
.I name
is not found, then not a god damn thang is printed, n' a exit statuz of false
is returned.
If the
.B \-p
option is used,
.B type
either returns tha name of tha disk file
that would be executed if
.I name
were specified as a cold-ass lil command name,
or not a god damn thang if
.if t \f(CWtype -t name\fP
.if n ``type -t name''
would not return
.IR file .
The
.B \-P
option forces a
.SM
.B PATH
search fo' each \fIname\fP, even if
.if t \f(CWtype -t name\fP
.if n ``type -t name''
would not return
.IR file .
If a cold-ass lil command is hashed,
.B \-p
and
.B \-P
print tha hashed value, not necessarily tha file dat appears
first up in 
.SM
.BR PATH .
If the
.B \-a
option is used, 
.B type
prints all of tha places dat contain
an executable named 
.IR name .
This includes aliases n' functions,
if n' only if tha 
.B \-p
option aint also used.
Da table of hashed commandz aint consulted
when using
.BR \-a .
The
.B \-f
option suppresses shell function lookup, as wit tha \fBcommand\fP builtin.
.B type
returns legit if all of tha arguments is found, false if
any is not found.
.TP
\fBulimit\fP [\fB\-HSTabcdefilmnpqrstuvx\fP [\fIlimit\fP]]
Provides control over tha resources available ta tha shell n' to
processes started by it, on systems dat allow such control.
Da \fB\-H\fP n' \fB\-S\fP options specify dat tha hard or soft limit is
set fo' tha given resource.
A hard limit cannot be increased by a non-root user once it is set;
a soft limit may be increased up ta tha value of tha hard limit.
If neither \fB\-H\fP nor \fB\-S\fP is specified, both tha soft n' hard
limits is set.
Da value of
.I limit
can be a number up in tha unit specified fo' tha resource
or one of tha special joints
.BR hard ,
.BR soft ,
or
.BR unlimited ,
which stand fo' tha current hard limit, tha current soft limit, and
no limit, respectively.
If
.I limit
is omitted, tha current value of tha soft limit of tha resource is
printed, unless tha \fB\-H\fP option is given. I aint talkin' bout chicken n' gravy biatch.  When mo' than one
resource is specified, tha limit name n' unit is printed before tha value.
Other options is interpreted as bigs up:
.RS
.PD 0
.TP
.B \-a
All current limits is reported
.TP
.B \-b
Da maximum socket buffer size
.TP
.B \-c
Da maximum size of core filez pimped
.TP
.B \-d
Da maximum size of a processs data segment
.TP
.B \-e
Da maximum schedulin prioritizzle ("nice")
.TP
.B \-f
Da maximum size of filez freestyled by tha shell n' its children
.TP
.B \-i
Da maximum number of pendin signals
.TP
.B \-l
Da maximum size dat may be locked tha fuck into memory
.TP
.B \-m
Da maximum resident set size (many systems do not honor dis limit)
.TP
.B \-n
Da maximum number of open file descriptors (most systems do not
allow dis value ta be set)
.TP
.B \-p
Da pipe size up in 512-byte blocks (this may not be set)
.TP
.B \-q
Da maximum number of bytes up in POSIX message queues
.TP
.B \-r
Da maximum real-time schedulin priority
.TP
.B \-s
Da maximum stack size
.TP
.B \-t
Da maximum amount of cpu time up in seconds
.TP
.B \-u
Da maximum number of processes available ta a single user
.TP
.B \-v
Da maximum amount of virtual memory available ta tha shell and, on
some systems, ta its children
.TP
.B \-x
Da maximum number of file locks
.TP
.B \-T
Da maximum number of threads
.PD
.PP
If
.I limit
is given, it is tha freshly smoked up value of tha specified resource (the
.B \-a
option is display only).
If no option is given, then
.B \-f
is assumed. Y'all KNOW dat shit, muthafucka!  Values is up in 1024-byte increments, except for
.BR \-t ,
which is up in seconds,
.BR \-p ,
which is up in unitz of 512-byte blocks,
and
.BR \-T ,
.BR \-b ,
.BR \-n ,
and
.BR \-u ,
which is unscaled joints.
Da return status is 0 unless a invalid option or argument is supplied,
or a error occurs while settin a freshly smoked up limit.
In POSIX Mode 512-byte blocks is used fo' tha `-c' n' `-f' options.
.RE
.TP
\fBumask\fP [\fB\-p\fP] [\fB\-S\fP] [\fImode\fP]
Da user file-creation mask is set ta 
.IR mode .
If
.I mode
begins wit a gangbangin' finger-lickin' digit, it
is interpreted as a octal number; otherwise
it is interpreted as a symbolic mode mask similar
to dat accepted by
.IR chmod (1).
If
.I mode
is omitted, tha current value of tha mask is printed.
The
.B \-S
option causes tha mask ta be printed up in symbolic form; the
default output be a octal number.
If the
.B \-p
option is supplied, and
.I mode
is omitted, tha output is up in a gangbangin' form dat may be reused as input.
Da return status is 0 if tha mode was successfully chizzled or if
no \fImode\fP argument was supplied, n' false otherwise.
.TP
\fBunalias\fP [\-\fBa\fP] [\fIname\fP ...]
Remove each \fIname\fP from tha list of defined aliases.  If
.B \-a
is supplied, all alias definitions is removed. Y'all KNOW dat shit, muthafucka!  Da return
value is legit unless a supplied
.I name
is not a thugged-out defined alias.
.TP
\fBunset\fP [\-\fBfv\fP] [\fIname\fP ...]
For each
.IR name ,
remove tha correspondin variable or function.
If no options is supplied, or the
.B \-v
option is given, each
.I name
refers ta a gangbangin' finger-lickin' dirty-ass shell variable.
Read-only variablez may not be unset.
If
.B \-f
is specified, each
.I name
refers ta a gangbangin' finger-lickin' dirty-ass shell function, n' tha function definition
is removed.
Each unset variable or function is removed from tha environment
passed ta subsequent commands.
If any of
.SM
.BR COMP_WORDBREAKS ,
.SM
.BR RANDOM ,
.SM
.BR SECONDS ,
.SM
.BR LINENO ,
.SM
.BR HISTCMD ,
.SM
.BR FUNCNAME ,
.SM
.BR GROUPS ,
or
.SM
.B DIRSTACK
are unset, they lose they special properties, even if they are
subsequently reset.  Da exit status is legit unless a
.I name
is readonly.
.TP
\fBwait\fP [\fIn ...\fP]
Wait fo' each specified process n' return its termination status.
Each
.I n
may be a process
ID or a thang justification; if a thang spec is given, all processes
in dat thangz pipeline is waited for. Shiiit, dis aint no joke.  If
.I n
is not given, all currently actizzle lil pimp processes
are waited for, n' tha return status is zero.  If
.I n
specifies a non-existent process or thang, tha return status is
127.  Otherwise, tha return status is tha exit statuz of tha last
process or thang waited for.
.\" bash_builtins
.if \n(zZ=1 .ig zZ
.SH "RESTRICTED SHELL"
.\" rbash.1
.zY
.PP
If
.B bash
is started wit tha name
.BR rbash ,
or the
.B \-r
option is supplied at invocation,
the shell becomes restricted.
A restricted shell is used to
set up a environment mo' controlled than tha standard shell.
It behaves identically to
.B bash
with tha exception dat tha followin is disallowed or not performed:
.IP \(bu
changin directories wit \fBcd\fP
.IP \(bu
settin or unsettin tha joints of
.SM
.BR SHELL ,
.SM
.BR PATH ,
.SM
.BR ENV ,
or
.SM
.B BASH_ENV
.IP \(bu
specifyin command names containing
.B /
.IP \(bu
specifyin a gangbangin' file name containin a
.B /
as a argument ta the
.B .
builtin command
.IP \(bu
specifyin a gangbangin' filename containin a slash as a argument ta the
.B \-p
option ta the
.B hash
builtin command
.IP \(bu
importin function definitions from tha shell environment at startup
.IP \(bu
parsin tha value of
.SM
.B SHELLOPTS
from tha shell environment at startup
.IP \(bu
redirectin output rockin tha >, >|, <>, >&, &>, n' >> redirection operators
.IP \(bu
usin the
.B exec
builtin command ta replace tha shell wit another command
.IP \(bu
addin or deletin builtin commandz wit the
.B \-f
and
.B \-d
options ta the
.B enable
builtin command
.IP \(bu
usin tha \fBenable\fP builtin command ta enable disabled shell builtins
.IP \(bu
specifyin the
.B \-p
option ta the
.B command
builtin command
.IP \(bu
turnin off restricted mode with
\fBset +r\fP or \fBset +o restricted\fP.
.PP
These restrictions is enforced afta any startup filez is read.
.PP
.ie \n(zY=1 When a cold-ass lil command dat is found ta be a gangbangin' finger-lickin' dirty-ass shell script is executed,
.el \{ When a cold-ass lil command dat is found ta be a gangbangin' finger-lickin' dirty-ass shell script is executed
(see
.SM
.B "COMMAND EXECUTION"
above),
\}
.B rbash
turns off any restrictions up in tha shell spawned ta execute the
script.
.\" end of rbash.1
.if \n(zY=1 .ig zY
.SH "SEE ALSO"
.PD 0
.TP
\fIBash Reference Manual\fP, Brian Fox n' Chet Ramey
.TP
\fIDa Gnu Readline Library\fP, Brian Fox n' Chet Ramey
.TP
\fIDa Gnu History Library\fP, Brian Fox n' Chet Ramey
.TP
\fIPortable Operatin System Interface (POSIX) Part 2: Shell n' Utilities\fP, IEEE
.TP
\fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1)
.TP
\fIemacs\fP(1), \fIvi\fP(1)
.TP
\fIreadline\fP(3)
.PD
.SH FILES
.PD 0
.TP
.FN /bin/bash
Da \fBbash\fP executable
.TP
.FN /etc/profile
Da systemwide initialization file, executed fo' login shells
.TP
.FN /etc/bash.bash_logout
Da systemwide login shell cleanup file, executed when a login shell exits
.TP
.FN ~/.bash_profile
Da underground initialization file, executed fo' login shells
.TP
.FN ~/.bashrc
Da individual per-interactive-shell startup file
.TP
.FN ~/.bash_logout
Da individual login shell cleanup file, executed when a login shell exits
.TP
.FN ~/.inputrc
Individual \fIreadline\fP initialization file
.PD
.SH AUTHORS
Brian Fox, Jacked Software Foundation
.br
bfox@gnu.org
.PP
Chet Ramey, Case Westside Reserve University
.br
chet.ramey@case.edu
.SH BUG REPORTS
If you find a funky-ass bug in
.B bash,
you should report dat shit.  But first, you should
make shizzle dat it straight-up be a funky-ass bug, n' dat it appears up in tha sickest fuckin
version of
.BR bash .
Da sickest fuckin version be always available from
\fIftp://ftp.gnu.org/pub/gnu/bash/\fP.
.PP
Once you have determined dat a funky-ass bug straight-up exists, use the
.I bashbug
command (from tha source package) ta submit a funky-ass bug report.
If you gotz a gangbangin' fix, yo ass is encouraged ta mail dat as well!
Suggestions n' `philosophical' bug reports may be mailed
to \fIbug-bash@gnu.org\fP or posted ta tha Usenet
newsgroup
.BR gnu.bash.bug .
.PP
ALL bug reports should include:
.PP
.PD 0
.TP 20
Da version number of \fBbash\fR
.TP
Da hardware n' operatin system
.TP
Da compila used ta compile
.TP
A description of tha bug behaviour
.TP
A short script or `recipe' which exercises tha bug
.PD
.PP
Comments n' bug reports concerning
this manual page should be pimped up to
.IR chet.ramey@case.edu .
.SH BUGS
.PP
It aint nuthin but too big-ass n' too slow.
.PP
There is some subtle differences between 
.B bash
and traditionizzle versions of
.BR sh ,
mostly cuz of the
.SM
.B POSIX
specification.
.PP
Aliases is confusin up in some uses.
.PP
Shell builtin commandz n' functions is not stoppable/restartable.
.PP
Compound commandz n' command sequencez of tha form `a ; b ; c'
are not handled gracefully when process suspendaz be attempted.
When a process is stopped, tha shell immediately executes tha next
command up in tha sequence.
It suffices ta place tha sequence of commandz between
parentheses ta force it tha fuck into a subshell, which may be stopped as
a unit.
.PP
Array variablez may not (yet) be exported.
.PP
There may be only one actizzle coprocess at a time.
.zZ
.zY
