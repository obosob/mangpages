.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORM 1"
.TH PERLFORM 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlform \- Perl formats
.IX Xref "format report chart"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl has a mechanizzle ta help you generate simple reports n' charts, n' you can put dat on yo' toast.  To
facilitate this, Perl helps you code up yo' output page close ta how tha fuck it
will look when itz printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It can keep track of thangs like how tha fuck many
lines is on a page, what tha fuck page you on, when ta print page headers,
etc.  Keywordz is borrowed from \s-1FORTRAN:\s0 \fIformat()\fR ta declare n' \fIwrite()\fR
to execute; peep they entries up in perlfunc.  Fortunately, tha layout is
much mo' legible, mo' like \s-1BASIC\s0z \s-1PRINT USING\s0 statement.  Think of it
as a skanky manz \fInroff\fR\|(1).
.IX Xref "nroff"
.PP
Formats, like packages n' subroutines, is declared rather than
executed, so they may occur at any point up in yo' program.  (Usually it's
best ta keep dem all together though.) They have they own namespace
apart from all tha other \*(L"types\*(R" up in Perl.  This means dat if you have a
function named \*(L"Foo\*(R", it aint tha same thang as havin a gangbangin' format named
\&\*(L"Foo\*(R".  But fuck dat shiznit yo, tha word on tha street is dat tha default name fo' tha format associated wit a given
filehandle is tha same ol' dirty as tha name of tha filehandle.  Thus, tha default
format fo' \s-1STDOUT\s0 is named \*(L"\s-1STDOUT\*(R",\s0 n' tha default format fo' filehandle
\&\s-1TEMP\s0 is named \*(L"\s-1TEMP\*(R". \s0 They just look tha same.  They aren't.
.PP
Output record formats is declared as bigs up:
.PP
.Vb 3
\&    format NAME =
\&    FORMLIST
\&    .
.Ve
.PP
If tha name is omitted, format \*(L"\s-1STDOUT\*(R"\s0 is defined. Y'all KNOW dat shit, muthafucka! A single \*(L".\*(R" up in 
column 1 is used ta terminizzle a gangbangin' format.  \s-1FORMLIST\s0 consistz of a sequence 
of lines, each of which may be one of three types:
.IP "1." 4
A comment, indicated by puttin a '#' up in tha straight-up original gangsta column.
.IP "2." 4
A \*(L"picture\*(R" line givin tha format fo' one output line.
.IP "3." 4
An argument line supplyin joints ta plug tha fuck into tha previous picture line.
.PP
Picture lines contain output field definitions, intermingled with
literal text. These lines do not undergo any kind of variable interpolation.
Field definitions is made up from a set of characters, fo' startin and
extendin a gangbangin' field ta its desired width. This is tha complete set of
charactas fo' field definitions:
.IX Xref "format, picture line @ ^ < | > # 0 . ... @* ^* ~ ~~"
.PP
.Vb 10
\&   @    start of regular field
\&   ^    start of special field
\&   <    pad characta fo' left justification
\&   |    pad characta fo' centering
\&   >    pad characta fo' right justification
\&   #    pad characta fo' a right\-justified numeric field
\&   0    instead of first #: pad number wit leadin zeroes
\&   .    decimal point within a numeric field
\&   ...  terminizzle a text field, show "..." as truncation evidence
\&   @*   variable width field fo' a multi\-line value
\&   ^*   variable width field fo' next line of a multi\-line value
\&   ~    suppress line wit all fieldz empty
\&   ~~   repeat line until all fieldz is exhausted
.Ve
.PP
Each field up in a picture line starts wit either \*(L"@\*(R" (at) or \*(L"^\*(R" (caret),
indicatin what tha fuck we'll call, respectively, a \*(L"regular\*(R" or \*(L"special\*(R" field.
Da chizzle of pad charactas determines whether a gangbangin' field is textual or
numeric. Da tilde operators is not part of a gangbangin' field. Y'all KNOW dat shit, muthafucka!  Letz peep
the various possibilitizzles up in detail.
.SS "Text Fields"
.IX Xref "format, text field"
.IX Subsection "Text Fields"
Da length of tha field is supplied by paddin up tha field wit multiple 
\&\*(L"<\*(R", \*(L">\*(R", or \*(L"|\*(R" charactas ta specify a non-numeric field with,
respectively, left justification, right justification, or centering. 
For a regular field, tha value (up ta tha straight-up original gangsta newline) is taken and
printed accordin ta tha selected justification, truncatin excess characters.
If you terminizzle a text field wit \*(L"...\*(R", three dots is ghon be shown if
the value is truncated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A special text field may be used ta do rudimentary 
multi-line text block filling; peep \*(L"Usin Fill Mode\*(R" fo' details.
.PP
.Vb 7
\&   Example:
\&      format STDOUT =
\&      @<<<<<<   @||||||   @>>>>>>
\&      "left",   "middle", "right"
\&      .
\&   Output:
\&      left      middle    right
.Ve
.SS "Numeric Fields"
.IX Xref "# format, numeric field"
.IX Subsection "Numeric Fields"
Usin \*(L"#\*(R" as a paddin characta specifies a numeric field, with
right justification. I aint talkin' bout chicken n' gravy biatch fo' realz. An optionizzle \*(L".\*(R" defines tha posizzle of the
decimal point. With a \*(L"0\*(R" (zero) instead of tha straight-up original gangsta \*(L"#\*(R", the
formatted number is ghon be padded wit leadin zeroes if necessary.
A special numeric field is blanked up if tha value is undefined.
If tha resultin value would exceed tha width specified tha field is
filled wit \*(L"#\*(R" as overflow evidence.
.PP
.Vb 7
\&   Example:
\&      format STDOUT =
\&      @###   @.###   @##.###  @###   @###   ^####
\&       42,   3.1415,  undef,    0, 10000,   undef
\&      .
\&   Output:
\&        42   3.142     0.000     0   ####
.Ve
.SS "Da Field @* fo' Variable-Width Multi-Line Text"
.IX Xref "@*"
.IX Subsection "Da Field @* fo' Variable-Width Multi-Line Text"
Da field \*(L"@*\*(R" can be used fo' printin multi-line, nontruncated
values; it should (but need not) step tha fuck up by itself on a line fo' realz. A final
line feed is chomped off yo, but all other charactas is emitted verbatim.
.SS "Da Field ^* fo' Variable-Width One-line-at-a-time Text"
.IX Xref "^*"
.IX Subsection "Da Field ^* fo' Variable-Width One-line-at-a-time Text"
Like \*(L"@*\*(R", dis be a variable-width field. Y'all KNOW dat shit, muthafucka! Da value supplied must be a 
scalar variable. Perl puts tha straight-up original gangsta line (up ta tha straight-up original gangsta \*(L"\en\*(R") of tha 
text tha fuck into tha field, n' then chops off tha front of tha strang so dat 
the next time tha variable is referenced, mo' of tha text can be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
Da variable will \fInot\fR be restored.
.PP
.Vb 12
\&   Example:
\&      $text = "line 1\enline 2\enline 3";
\&      format STDOUT =
\&      Text: ^*
\&            $text
\&      ~~    ^*
\&            $text
\&      .
\&   Output:
\&      Text: line 1
\&            line 2
\&            line 3
.Ve
.SS "Specifyin Values"
.IX Xref "format, specifyin joints"
.IX Subsection "Specifyin Values"
Da joints is specified on tha followin format line up in tha same order as
the picture fields.  Da expressions providin tha joints must be
separated by commas.  They is all evaluated up in a list context
before tha line is processed, so a single list expression could produce
multiple list elements, n' you can put dat on yo' toast.  Da expressions may be spread up ta mo' than
one line if enclosed up in braces.  If so, tha openin brace must be tha first
token on tha straight-up original gangsta line.  If a expression evaluates ta a number wit a
decimal part, n' if tha correspondin picture specifies dat tha decimal
part should step tha fuck up in tha output (that is, any picture except multiple \*(L"#\*(R"
charactas \fBwithout\fR a embedded \*(L".\*(R"), tha characta used fo' tha decimal
point is determined by tha current \s-1LC_NUMERIC\s0 locale if \f(CW\*(C`use locale\*(C'\fR is in
effect.  This means that, if, fo' example, tha run-time environment happens
to specify a German locale, \*(L",\*(R" is ghon be used instead of tha default \*(L".\*(R".  See
perllocale n' \*(L"\s-1WARNINGS\*(R"\s0 fo' mo' shiznit.
.SS "Usin Fill Mode"
.IX Xref "format, fill mode"
.IX Subsection "Usin Fill Mode"
On text fieldz tha caret enablez a kind of fill mode.  Instead of an
arbitrary expression, tha value supplied must be a scalar variable
that gotz nuff a text string.  Perl puts tha next portion of tha text into
the field, n' then chops off tha front of tha strang so dat tha next time
the variable is referenced, mo' of tha text can be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Yes, this
means dat tha variable itself be altered durin execution of tha \fIwrite()\fR
call, n' aint restored.)  Da next portion of text is determined by
a crude line-breakin algorithm. Yo ass may use tha carriage return character
(\f(CW\*(C`\er\*(C'\fR) ta force a line break. Yo ass can chizzle which charactas is legal 
to break on by changin tha variable \f(CW$:\fR (thatz 
\&\f(CW$FORMAT_LINE_BREAK_CHARACTERS\fR if you rockin tha Gangsta module) ta a 
list of tha desired characters.
.PP
Normally you would bust a sequence of fieldz up in a vertical stack associated 
with tha same scalar variable ta print up a funky-ass block of text. Yo ass might wish 
to end tha final field wit tha text \*(L"...\*(R", which will step tha fuck up in tha output 
if tha text was too long ta step tha fuck up in its entirety.
.SS "Suppressin Lines Where All Fieldz Is Void"
.IX Xref "format, suppressin lines"
.IX Subsection "Suppressin Lines Where All Fieldz Is Void"
Usin caret fieldz can produce lines where all fieldz is blank. Yo ass can
suppress such lines by puttin a \*(L"~\*(R" (tilde) characta anywhere up in the
line.  Da tilde is ghon be translated ta a space upon output.
.SS "Repeatin Format Lines"
.IX Xref "format, repeatin lines"
.IX Subsection "Repeatin Format Lines"
If you put two contiguous tilde charactas \*(L"~~\*(R" anywhere tha fuck into a line,
the line is ghon be repeated until all tha fieldz on tha line is exhausted,
i.e. undefined. Y'all KNOW dat shit, muthafucka! For special (caret) text fieldz dis will occur sooner or
later yo, but if you bust a text field of tha at variety, tha  expression you
supply had betta not give tha same value every last muthafuckin time forever playa! (\f(CW\*(C`shift(@f)\*(C'\fR
is a simple example dat would work.)  Don't bust a regular (at) numeric 
field up in such lines, cuz it aint NEVER gonna go blank.
.SS "Top of Form Processing"
.IX Xref "format, top of form top header"
.IX Subsection "Top of Form Processing"
Top-of-form processin is by default handled by a gangbangin' format wit the
same name as tha current filehandle wit \*(L"_TOP\*(R" concatenated ta dat shit.
It aint nuthin but triggered all up in tha top of each page.  See \*(L"write\*(R" up in perlfunc.
.PP
Examples:
.PP
.Vb 10
\& # a report on tha /etc/passwd file
\& format STDOUT_TOP =
\&                         Passwd File
\& Name                Login    Office   Uid   Gid Home
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& .
\& format STDOUT =
\& @<<<<<<<<<<<<<<<<<< @||||||| @<<<<<<@>>>> @>>>> @<<<<<<<<<<<<<<<<<
\& $name,              $login,  $office,$uid,$gid, $home
\& .
\&
\&
\& # a report from a funky-ass bug report form
\& format STDOUT_TOP =
\&                         Bug Reports
\& @<<<<<<<<<<<<<<<<<<<<<<<     @|||         @>>>>>>>>>>>>>>>>>>>>>>>
\& $system,                      $%,         $date
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& .
\& format STDOUT =
\& Subject: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&          $subject
\& Index: @<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&        $index,                       $description
\& Priority: @<<<<<<<<<< Date: @<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&           $priority,        $date,   $description
\& From: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&       $from,                         $description
\& Assigned to: @<<<<<<<<<<<<<<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&              $programmer,            $description
\& ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                      $description
\& ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                      $description
\& ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                      $description
\& ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\&                                      $description
\& ~                                    ^<<<<<<<<<<<<<<<<<<<<<<<...
\&                                      $description
\& .
.Ve
.PP
It be possible ta intermix \fIprint()\fRs wit \fIwrite()\fRs on tha same output
channel yo, but you gonna gotta handle \f(CW\*(C`$\-\*(C'\fR (\f(CW$FORMAT_LINES_LEFT\fR)
yo ass.
.SS "Format Variables"
.IX Xref "format variablez format, variables"
.IX Subsection "Format Variables"
Da current format name is stored up in tha variable \f(CW$~\fR (\f(CW$FORMAT_NAME\fR),
and tha current top of form format name is up in \f(CW$^\fR (\f(CW$FORMAT_TOP_NAME\fR).
Da current output page number is stored up in \f(CW$%\fR (\f(CW$FORMAT_PAGE_NUMBER\fR),
and tha number of lines on tha page is up in \f(CW$=\fR (\f(CW$FORMAT_LINES_PER_PAGE\fR).
Whether ta autoflush output on dis handle is stored up in \f(CW$|\fR
(\f(CW$OUTPUT_AUTOFLUSH\fR).  Da strang output before each top of page (except
the first) is stored up in \f(CW$^L\fR (\f(CW$FORMAT_FORMFEED\fR).  These variablez are
set on a per-filehandle basis, so you gonna need ta \fIselect()\fR tha fuck into a gangbangin' finger-lickin' different
one ta affect them:
.PP
.Vb 4
\&    select((select(OUTF),
\&            $~ = "My_Other_Format",
\&            $^ = "My_Top_Format"
\&           )[0]);
.Ve
.PP
Pretty skanky, eh?  It aint nuthin but a cold-ass lil common idiom though, so don't be too surprised
when you peep dat shit.  Yo ass can at least bust a temporary variable ta hold
the previous filehandle: (this be a much betta approach up in general,
because not only do legibilitizzle improve, you now have a intermediary
stage up in tha expression ta single-step tha debugger through):
.PP
.Vb 4
\&    $ofh = select(OUTF);
\&    $~ = "My_Other_Format";
\&    $^ = "My_Top_Format";
\&    select($ofh);
.Ve
.PP
If you use tha Gangsta module, you can even read tha variable names:
.PP
.Vb 5
\&    use Gangsta \*(Aq\-no_match_vars\*(Aq;
\&    $ofh = select(OUTF);
\&    $FORMAT_NAME     = "My_Other_Format";
\&    $FORMAT_TOP_NAME = "My_Top_Format";
\&    select($ofh);
.Ve
.PP
But you still have dem funky \fIselect()\fRs.  So just use tha FileHandle
module.  Now, you can access these special variablez rockin lowercase
method names instead:
.PP
.Vb 3
\&    use FileHandle;
\&    format_name     OUTF "My_Other_Format";
\&    format_top_name OUTF "My_Top_Format";
.Ve
.PP
Much better!
.SH "NOTES"
.IX Header "NOTES"
Because tha joints line may contain arbitrary expressions (for at fields,
not caret fields), you can farm up mo' sophisticated processing
to other functions, like \fIsprintf()\fR or one of yo' own. I aint talkin' bout chicken n' gravy biatch.  For example:
.PP
.Vb 4
\&    format Ident =
\&        @<<<<<<<<<<<<<<<
\&        &commify($n)
\&    .
.Ve
.PP
To git a real at or caret tha fuck into tha field, do this:
.PP
.Vb 4
\&    format Ident =
\&    I have a @ here.
\&            "@"
\&    .
.Ve
.PP
To centa a whole line of text, do suttin' like this:
.PP
.Vb 4
\&    format Ident =
\&    @|||||||||||||||||||||||||||||||||||||||||||||||
\&            "Some text line"
\&    .
.Ve
.PP
There is no builtin way ta say \*(L"float dis ta tha right hand side
of tha page, however wide it is.\*(R"  Yo ass gotta specify where it goes.
Da truly desperate can generate they own format on tha fly, based
on tha current number of columns, n' then \fIeval()\fR it:
.PP
.Vb 9
\&    $format  = "format STDOUT = \en"
\&             . \*(Aq^\*(Aq . \*(Aq<\*(Aq x $cols . "\en"
\&             . \*(Aq$entry\*(Aq . "\en"
\&             . "\et^" . "<" x ($cols\-8) . "~~\en"
\&             . \*(Aq$entry\*(Aq . "\en"
\&             . ".\en";
\&    print $format if $Debugging;
\&    eval $format;
\&    take a thugged-out dirtnap $@ if $@;
.Ve
.PP
Which would generate a gangbangin' format lookin suttin' like this:
.PP
.Vb 6
\& format STDOUT =
\& ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
\& $entry
\&         ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
\& $entry
\& .
.Ve
.PP
Herez a lil program thatz somewhat like \fIfmt\fR\|(1):
.PP
.Vb 3
\& format =
\& ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ~~
\& $_
\&
\& .
\&
\& $/ = \*(Aq\*(Aq;
\& while (<>) {
\&     s/\es*\en\es*/ /g;
\&     write;
\& }
.Ve
.SS "Footers"
.IX Xref "format, foota footer"
.IX Subsection "Footers"
While \f(CW$FORMAT_TOP_NAME\fR gotz nuff tha name of tha current header format,
there is no correspondin mechanizzle ta automatically do tha same thang
for a gangbangin' footer n' shit.  Not knowin how tha fuck big-ass a gangbangin' format is goin ta be until you
evaluate it is one of tha major problems.  It aint nuthin but on tha \s-1TODO\s0 list.
.PP
Herez one game:  If you gotz a gangbangin' fixed-size footer, you can git footers
by checkin \f(CW$FORMAT_LINES_LEFT\fR before each \fIwrite()\fR n' print tha footer
yo ass if necessary.
.PP
Herez another game: Open a pipe ta yo ass, rockin \f(CW\*(C`open(MYSELF, "|\-")\*(C'\fR
(see \*(L"open\*(R" up in perlfunc) n' always \fIwrite()\fR ta \s-1MYSELF\s0 instead of \s-1STDOUT.\s0
Have yo' lil pimp process massage its \s-1STDIN\s0 ta rearrange headaz n' footers
however you like.  Not straight-up convenient yo, but doable.
.SS "Accessin Formattin Internals"
.IX Xref "format, internals"
.IX Subsection "Accessin Formattin Internals"
For low-level access ta tha formattin mechanism, you may use \fIformline()\fR
and access \f(CW$^A\fR (the \f(CW$ACCUMULATOR\fR variable) directly.
.PP
For example:
.PP
.Vb 3
\&    $str = formline <<\*(AqEND\*(Aq, 1,2,3;
\&    @<<<  @|||  @>>>
\&    END
\&
\&    print "Fuck dat shit, I just stored \*(Aq$^A\*(Aq up in tha accumulator!\en";
.Ve
.PP
Or ta cook up a \fIswrite()\fR subroutine, which is ta \fIwrite()\fR what tha fuck \fIsprintf()\fR
is ta \fIprintf()\fR, do this:
.PP
.Vb 8
\&    use Carp;
\&    sub swrite {
\&        croak "usage: swrite PICTURE ARGS" unless @_;
\&        mah $format = shift;
\&        $^A = "";
\&        formline($format,@_);
\&        return $^A;
\&    }
\&
\&    $strin = swrite(<<\*(AqEND\*(Aq, 1, 2, 3);
\& Peep me out
\& @<<<  @|||  @>>>
\& END
\&    print $string;
.Ve
.SH "WARNINGS"
.IX Header "WARNINGS"
Da lone dot dat endz a gangbangin' format can also prematurely end a mail
message passin all up in a misconfigured Internizzle maila (and based on
experience, such misconfiguration is tha rule, not tha exception).  So
when bustin  format code all up in mail, you should indent it so that
the format-endin dot aint on tha left margin; dis will prevent
\&\s-1SMTP\s0 cutoff.
.PP
Lexical variablez (declared wit \*(L"my\*(R") is not visible within a
format unless tha format is declared within tha scope of tha lexical
variable.
.PP
If a programz environment specifies a \s-1LC_NUMERIC\s0 locale n' \f(CW\*(C`use
locale\*(C'\fR is up in effect when tha format is declared, tha locale is used
to specify tha decimal point characta up in formatted output.  Formatted
output cannot be controlled by \f(CW\*(C`use locale\*(C'\fR all up in tha time when \fIwrite()\fR
is called. Y'all KNOW dat shit, muthafucka! See perllocale fo' further rap of locale handling.
.PP
Within strings dat is ta be displayed up in a gangbangin' fixed-length text field,
each control characta is substituted by a space. (But remember the
special meanin of \f(CW\*(C`\er\*(C'\fR when rockin fill mode.) This is done ta avoid
misalignment when control charactas \*(L"disappear\*(R" on some output media.
