'\" t
.\"     Title: VALGRIND
.\"    Author: [see tha "Author" section]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 12/12/2013
.\"    Manual: Release 3.9.0
.\"    Source: Release 3.9.0
.\"  Language: Gangsta
.\"
.TH "VALGRIND" "1" "12/12/2013" "Release 3.9.0" "Release 3.9.0"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
valgrind \- a suite of tools fo' debuggin n' profilin programs
.SH "SYNOPSIS"
.HP \w'\fBvalgrind\fR\ 'u
\fBvalgrind\fR [\fIvalgrind\-options\fR] [\fByour\-program\fR] [\fIyour\-program\-options\fR]
.SH "DESCRIPTION"
.PP
\fBValgrind\fR
is a gangbangin' flexible program fo' debuggin n' profilin Linux executables\&. Well shiiiit, it consistz of a cold-ass lil core, which serves up a synthetic CPU up in software, n' a seriez of debuggin n' profilin tools\&. Da architecture is modular, so dat freshly smoked up tools can be pimped easily n' without disturbin tha existin structure\&.
.PP
Some of tha options busted lyrics bout below work wit all Valgrind tools, n' some only work wit all dem or one\&. Da section MEMCHECK OPTIONS n' dem below it describe tool\-specific options\&.
.PP
This manual page covers only basic usage n' options\&. For mo' comprehensive shiznit, please peep tha HTML documentation on yo' system:
$INSTALL/share/doc/valgrind/html/index\&.html, or online:
http://www\&.valgrind\&.org/docs/manual/index\&.html\&.
.SH "TOOL SELECTION OPTIONS"
.PP
Da single most blingin option\&.
.PP
\fB\-\-tool=<toolname> [default: memcheck] \fR
.RS 4
Run tha Valgrind tool called
\fItoolname\fR, e\&.g\&. Memcheck, Cachegrind, etc\&.
.RE
.SH "BASIC OPTIONS"
.PP
These options work wit all tools\&.
.PP
\fB\-h \-\-help\fR
.RS 4
Show help fo' all options, both fo' tha core n' fo' tha selected tool\&. If tha option is repeated it is equivalent ta giving
\fB\-\-help\-debug\fR\&.
.RE
.PP
\fB\-\-help\-debug\fR
.RS 4
Same as
\fB\-\-help\fR yo, but also lists debuggin options which probably is only of use ta Valgrind\*(Aqs pimpers\&.
.RE
.PP
\fB\-\-version\fR
.RS 4
Show tha version number of tha Valgrind core\&. Tools can have they own version numbers\&. There be a scheme up in place ta ensure dat tools only execute when tha core version is one they is known ta work with\&. This was done ta minimise tha chancez of strange problems arisin from tool\-vs\-core version incompatibilities\&.
.RE
.PP
\fB\-q\fR, \fB\-\-quiet\fR
.RS 4
Run silently, n' only print error lyrics\&. Useful if yo ass is hustlin regression tests or have some other automated test machinery\&.
.RE
.PP
\fB\-v\fR, \fB\-\-verbose\fR
.RS 4
Be mo' verbose\&. Gives extra shiznit on various aspectz of yo' program, such as: tha shared objects loaded, tha suppressions used, tha progress of tha instrumentation n' execution engines, n' warnings bout unusual behaviour\&. Repeatin tha option increases tha verbositizzle level\&.
.RE
.PP
\fB\-\-trace\-children=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind will trace tha fuck into sub\-processes initiated via the
\fIexec\fR
system call\&. This is necessary fo' multi\-process programs\&.
.sp
Note dat Valgrind do trace tha fuck into tha lil pimp of a
\fIfork\fR
(it would be hard as fuck not to, since
\fIfork\fR
makes a identical copy of a process), so dis option be arguably badly named\&. But fuck dat shiznit yo, tha word on tha street is dat most lil pimps of
\fIfork\fR
calls immediately call
\fIexec\fR
anyway\&.
.RE
.PP
\fB\-\-trace\-children\-skip=patt1,patt2,\&.\&.\&. \fR
.RS 4
This option only has a effect when
\fB\-\-trace\-children=yes\fR
is specified\&. Well shiiiit, it allows fo' some lil pimps ta be skipped\&. Da option takes a cold-ass lil comma separated list of patterns fo' tha namez of lil pimp executablez dat Valgrind should not trace into\&. Patterns may include tha metacharacters
?
and
*, which have tha usual meaning\&.
.sp
This can be useful fo' prunin uninterestin branches from a tree of processes bein run on Valgrind\&. But you should be careful when rockin it\&. When Valgrind skips tracin tha fuck into a executable, it don\*(Aqt just skip tracin dat executable, it also skips tracin any of dat executable\*(Aqs lil pimp processes\&. In other lyrics, tha flag don\*(Aqt merely cause tracin ta stop all up in tha specified executablez \-\- it skips tracin of entire process subtrees rooted at any of tha specified executables\&.
.RE
.PP
\fB\-\-trace\-children\-skip\-by\-arg=patt1,patt2,\&.\&.\&. \fR
.RS 4
This is tha same ol' dirty as
\fB\-\-trace\-children\-skip\fR, wit one difference: tha decision as ta whether ta trace tha fuck into a cold-ass lil lil pimp process is made by examinin tha arguments ta tha lil pimp process, rather than tha name of its executable\&.
.RE
.PP
\fB\-\-child\-silent\-after\-fork=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind aint gonna show any debuggin or loggin output fo' tha lil pimp process resultin from a
\fIfork\fR
call\&. This can make tha output less confusin (although mo' misleading) when dealin wit processes dat create children\&. Well shiiiit, it is particularly useful up in conjunction with
\fI\-\-trace\-children=\fR\&. Use of dis option be also straight fuckin recommended if yo ass is requestin XML output (\fI\-\-xml=yes\fR), since otherwise tha XML from lil pimp n' parent may become mixed up, which probably make it useless\&.
.RE
.PP
\fB\-\-vgdb=<no|yes|full> [default: yes] \fR
.RS 4
Valgrind will provide "gdbserver" functionalitizzle when
\fB\-\-vgdb=yes\fR
or
\fB\-\-vgdb=full\fR
is specified\&. This allows a external GNU GDB debugger ta control n' debug yo' program when it runs on Valgrind\&.
\fB\-\-vgdb=full\fR
incurs dope performizzle overheadz yo, but serves up mo' precise breakpoints n' watchpoints\&. Right back up in yo muthafuckin ass. See
Debuggin yo' program rockin Valgrindz gdbserver n' GDB
for a thugged-out detailed description\&.
.sp
If tha embedded gdbserver is enabled but no gdb is currently bein used, the
vgdb
command line utilitizzle can bust "monitor commands" ta Valgrind from a gangbangin' finger-lickin' dirty-ass shell\&. Da Valgrind core serves up a set of
Valgrind monitor commands\& fo' realz. A tool can optionally provide tool specific monitor commands, which is documented up in tha tool specific chapter\&.
.RE
.PP
\fB\-\-vgdb\-error=<number> [default: 999999999] \fR
.RS 4
Use dis option when tha Valgrind gdbserver is enabled with
\fB\-\-vgdb=yes\fR
or
\fB\-\-vgdb=full\fR\&. Tools dat report errors will wait fo' "number" errors ta be reported before freezin tha program n' waitin fo' you ta hook tha fuck up wit GDB\&. Well shiiiit, it bigs up dat a value of zero will cause tha gdbserver ta be started before yo' program is executed\&. This is typically used ta bang GDB breakpoints before execution, n' also works wit tools dat do not report errors, like fuckin Massif\&.
.RE
.PP
\fB\-\-track\-fds=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind will print up a list of open file descriptors on exit or on request, via tha gdbserver monitor command
\fIv\&.info open_fds\fR\& fo' realz. Along wit each file descriptor is printed a stack backtrace of where tha file was opened n' any details relatin ta tha file descriptor like fuckin tha file name or socket details\&.
.RE
.PP
\fB\-\-time\-stamp=<yes|no> [default: no] \fR
.RS 4
When enabled, each message is preceded wit a indication of tha elapsed wallclock time since startup, expressed as days, hours, minutes, secondz n' milliseconds\&.
.RE
.PP
\fB\-\-log\-fd=<number> [default: 2, stderr] \fR
.RS 4
Specifies dat Valgrind should bust all of its lyrics ta tha specified file descriptor\&. Da default, 2, is tha standard error channel (stderr)\&. Note dat dis may interfere wit tha client\*(Aqs own use of stderr, as Valgrind\*(Aqs output is ghon be interleaved wit any output dat tha client sendz ta stderr\&.
.RE
.PP
\fB\-\-log\-file=<filename> \fR
.RS 4
Specifies dat Valgrind should bust all of its lyrics ta tha specified file\&. If tha file name is empty, it causes a abort\&. There is three special format specifiers dat can be used up in tha file name\&.
.sp
\fB%p\fR
is replaced wit tha current process ID\&. This is straight-up useful fo' program dat invoke multiple processes\&. WARNING: If you use
\fB\-\-trace\-children=yes\fR
and yo' program invokes multiple processes OR yo' program forks without callin exec afterwards, n' you don\*(Aqt use dis specifier (or the
\fB%q\fR
specifier below), tha Valgrind output from all dem processes will go tha fuck into one file, possibly jumbled up, n' possibly incomplete\&.
.sp
\fB%q{FOO}\fR
is replaced wit tha contentz of tha environment variable
\fIFOO\fR\&. If the
\fB{FOO}\fR
part is malformed, it causes a abort\&. This specifier is rarely needed yo, but straight-up useful up in certain circumstances (eg\&. when hustlin MPI programs)\&. Da scam is dat you specify a variable which is ghon be set differently fo' each process up in tha thang, fo' example
BPROC_RANK
or whatever be applicable up in yo' MPI setup\&. If tha named environment variable aint set, it causes a abort\&. Note dat up in some shells, the
\fB{\fR
and
\fB}\fR
charactas may need ta be escaped wit a funky-ass backslash\&.
.sp
\fB%%\fR
is replaced with
\fB%\fR\&.
.sp
If an
\fB%\fR
is followed by any other character, it causes a abort\&.
.RE
.PP
\fB\-\-log\-socket=<ip\-address:port\-number> \fR
.RS 4
Specifies dat Valgrind should bust all of its lyrics ta tha specified port all up in tha specified IP address\&. Da port may be omitted, up in which case port 1500 is used\&. If a cold-ass lil connection cannot be made ta tha specified socket, Valgrind falls back ta freestylin output ta tha standard error (stderr)\&. This option is intended ta be used up in conjunction wit the
valgrind\-listener
program\&. For further details, see
the commentary
in tha manual\&.
.RE
.SH "ERROR-RELATED OPTIONS"
.PP
These options is used by all tools dat can report errors, e\&.g\&. Memcheck yo, but not Cachegrind\&.
.PP
\fB\-\-xml=<yes|no> [default: no] \fR
.RS 4
When enabled, tha blingin partz of tha output (e\&.g\&. tool error lyrics) is ghon be up in XML format rather than plain text\&. Furthermore, tha XML output is ghon be busted ta a gangbangin' finger-lickin' different output channel than tha plain text output\&. Therefore, you also must use one of
\fB\-\-xml\-fd\fR,
\fB\-\-xml\-file\fR
or
\fB\-\-xml\-socket\fR
to specify where tha XML is ta be sent\&.
.sp
Less blingin lyrics will still be printed up in plain text yo, but cuz tha XML output n' plain text output is busted ta different output channels (the destination of tha plain text output is still controlled by
\fB\-\-log\-fd\fR,
\fB\-\-log\-file\fR
and
\fB\-\-log\-socket\fR) dis should not cause problems\&.
.sp
This option be aimed at makin game easier fo' tools dat consume Valgrind\*(Aqs output as input, like fuckin GUI front ends\&. Currently dis option works wit Memcheck, Helgrind, DRD n' SGcheck\&. Da output format is specified up in tha file
docs/internals/xml\-output\-protocol4\&.txt
in tha source tree fo' Valgrind 3\&.5\&.0 or later\&.
.sp
Da recommended options fo' a GUI ta pass, when requestin XML output, are:
\fB\-\-xml=yes\fR
to enable XML output,
\fB\-\-xml\-file\fR
to bust tha XML output ta a (presumably GUI\-selected) file,
\fB\-\-log\-file\fR
to bust tha plain text output ta a second GUI\-selected file,
\fB\-\-child\-silent\-after\-fork=yes\fR, and
\fB\-q\fR
to restrict tha plain text output ta critical error lyrics pimped by Valgrind itself\&. For example, failure ta read a specified suppressions file counts as a cold-ass lil critical error message\&. In dis way, fo' a successful run tha text output file is ghon be empty\&. But if it isn\*(Aqt empty, then it will contain blingin shiznit which tha GUI user should be made aware of\&.
.RE
.PP
\fB\-\-xml\-fd=<number> [default: \-1, disabled] \fR
.RS 4
Specifies dat Valgrind should bust its XML output ta tha specified file descriptor\&. Well shiiiit, it must be used up in conjunction with
\fB\-\-xml=yes\fR\&.
.RE
.PP
\fB\-\-xml\-file=<filename> \fR
.RS 4
Specifies dat Valgrind should bust its XML output ta tha specified file\&. Well shiiiit, it must be used up in conjunction with
\fB\-\-xml=yes\fR\& fo' realz. Any
\fB%p\fR
or
\fB%q\fR
sequences appearin up in tha filename is expanded up in exactly tha same way as they is for
\fB\-\-log\-file\fR\&. Right back up in yo muthafuckin ass. See tha description of
\fB\-\-log\-file\fR
for details\&.
.RE
.PP
\fB\-\-xml\-socket=<ip\-address:port\-number> \fR
.RS 4
Specifies dat Valgrind should bust its XML output tha specified port all up in tha specified IP address\&. Well shiiiit, it must be used up in conjunction with
\fB\-\-xml=yes\fR\&. Da form of tha argument is tha same ol' dirty as dat used by
\fB\-\-log\-socket\fR\&. Right back up in yo muthafuckin ass. See tha description of
\fB\-\-log\-socket\fR
for further details\&.
.RE
.PP
\fB\-\-xml\-user\-comment=<string> \fR
.RS 4
Embedz a extra user comment strang all up in tha start of tha XML output\&. Only works when
\fB\-\-xml=yes\fR
is specified; ignored otherwise\&.
.RE
.PP
\fB\-\-demangle=<yes|no> [default: yes] \fR
.RS 4
Enable/disable automatic demanglin (decoding) of C++ names\&. Enabled by default\&. When enabled, Valgrind will attempt ta translate encoded C++ names back ta suttin' approachin tha original\&. Da demangla handlez symbols mangled by g++ versions 2\&.X, 3\&.X n' 4\&.X\&.
.sp
An blingin fact bout demanglin is dat function names mentioned up in suppressions filez should be up in they mangled form\&. Valgrind do not demangle function names when searchin fo' applicable suppressions, cuz ta do otherwise would make suppression file contents dependent on tha state of Valgrind\*(Aqs demanglin machinery, n' also slow down suppression matching\&.
.RE
.PP
\fB\-\-num\-callers=<number> [default: 12] \fR
.RS 4
Specifies tha maximum number of entries shown up in stack traces dat identify program locations\&. Note dat errors is commoned up rockin only tha top four function locations (the place up in tha current function, n' dat of its three immediate callers)\&. Right back up in yo muthafuckin ass. So dis don\*(Aqt affect tha total number of errors reported\&.
.sp
Da maximum value fo' dis is 500\&. Note dat higher settings will make Valgrind run a lil' bit mo' slowly n' take a lil' bit mo' memory yo, but can be useful when hustlin wit programs wit deeply\-nested call chains\&.
.RE
.PP
\fB\-\-unw\-stack\-scan\-thresh=<number> [default: 0] \fR, \fB\-\-unw\-stack\-scan\-frames=<number> [default: 5] \fR
.RS 4
Stack\-scannin support be available only on ARM targets\&.
.sp
These flags enable n' control stack unwindin by stack scanning\&. When tha aiiight stack unwindin mechanizzlez \-\- usage of Dwarf CFI records, n' frame\-pointa followin \-\- fail, stack scannin may be able ta recover a stack trace\&.
.sp
Note dat stack scannin be a imprecise, heuristic mechanizzle dat may give straight-up misleadin thangs up in dis biatch, or none at all\&. Well shiiiit, it should be used only up in emergencies, when aiiight unwindin fails, n' it is blingin ta nevertheless have stack traces\&.
.sp
Stack scannin be a simple technique: tha unwinder readz lyrics from tha stack, n' tries ta guess which of dem might be return addresses, by checkin ta peep if they point just afta ARM or Thumb call instructions\&. If so, tha word be added ta tha backtrace\&.
.sp
Da main dark shiznit occurs when a gangbangin' function call returns, leavin its return address exposed, n' a freshly smoked up function is called yo, but tha freshly smoked up function do not overwrite tha oldschool address\&. Da result of dis is dat tha backtrace may contain entries fo' functions which have already returned, n' so be straight-up confusing\&.
.sp
A second limitation of dis implementation is dat it will scan only tha page (4KB, normally) containin tha startin stack pointer\&. If tha stack frames is large, dis may result up in only all dem (or not even any) bein present up in tha trace\& fo' realz. Also, if yo ass is unlucky n' have a initial stack pointa near tha end of its containin page, tha scan may miss all bangin-ass frames\&.
.sp
By default stack scannin is disabled\&. Da aiiight use case is ta ask fo' it when a stack trace would otherwise be straight-up short\&. Right back up in yo muthafuckin ass. So, ta enable it, use
\-\-unw\-stack\-scan\-thresh=number\&. This requests Valgrind ta try rockin stack scannin ta "extend" stack traces which contain fewer than
number
frames\&.
.sp
If stack scannin do take place, it will only generate at most tha number of frames specified by
\-\-unw\-stack\-scan\-frames\&. Typically, stack scannin generates all kindsa muthafuckin garbage entries dat dis value is set ta a low value (5) by default\&. In no case will a stack trace larger than tha value specified by
\-\-num\-callers
be pimped\&.
.RE
.PP
\fB\-\-error\-limit=<yes|no> [default: yes] \fR
.RS 4
When enabled, Valgrind stops reportin errors afta 10,000,000 up in total, or 1,000 different ones, done been seen\&. This is ta stop tha error trackin machinery from becomin a big-ass performizzle overhead up in programs wit nuff errors\&.
.RE
.PP
\fB\-\-error\-exitcode=<number> [default: 0] \fR
.RS 4
Specifies a alternatizzle exit code ta return if Valgrind reported any errors up in tha run\&. When set ta tha default value (zero), tha return value from Valgrind will always be tha return value of tha process bein simulated\&. When set ta a nonzero value, dat value is returned instead, if Valgrind detects any errors\&. This is useful fo' rockin Valgrind as part of a automated test suite, since it make it easy as fuck  ta detect test cases fo' which Valgrind has reported errors, just by inspectin return codes\&.
.RE
.PP
\fB\-\-sigill\-diagnostics=<yes|no> [default: yes] \fR
.RS 4
Enable/disable printin of illegal instruction diagnostics\&. Enabled by default yo, but defaults ta disabled when
\fB\-\-quiet\fR
is given\&. Da default can always be explicitly overridden by givin dis option\&.
.sp
When enabled, a warnin message is ghon be printed, along wit some diagnostics, whenever a instruction is encountered dat Valgrind cannot decode or translate, before tha program is given a SIGILL signal\&. Often a illegal instruction indicates a funky-ass bug up in tha program or missin support fo' tha particular instruction up in Valgrind\&. But some programs do deliberately try ta execute a instruction dat might be missin n' trap tha SIGILL signal ta detect processor features\&. Usin dis flag make it possible ta avoid tha diagnostic output dat you would otherwise git up in such cases\&.
.RE
.PP
\fB\-\-show\-below\-main=<yes|no> [default: no] \fR
.RS 4
By default, stack traces fo' errors do not show any functions dat step tha fuck up beneath
\fBmain\fR
because most of tha time it\*(Aqs uninterestin C library shiznit and/or gobbledygook\& fo' realz. Alternatively, if
\fBmain\fR
is not present up in tha stack trace, stack traces aint gonna show any functions below
\fBmain\fR\-like functions like fuckin glibc\*(Aqs
\fB__libc_start_main\fR\&. Furthermore, if
\fBmain\fR\-like functions is present up in tha trace, they is normalised as
\fB(below main)\fR, up in order ta make tha output mo' deterministic\&.
.sp
If dis option is enabled, all stack trace entries is ghon be shown and
\fBmain\fR\-like functions aint gonna be normalised\&.
.RE
.PP
\fB\-\-fullpath\-after=<string> [default: don\*(Aqt show source paths] \fR
.RS 4
By default Valgrind only shows tha filenames up in stack traces yo, but not full paths ta source files\&. When rockin Valgrind up in big-ass projects where tha sources reside up in multiple different directories, dis can be inconvenient\&.
\fB\-\-fullpath\-after\fR
provides a gangbangin' flexible solution ta dis problem\&. When dis option is present, tha path ta each source file is shown, wit tha followin all\-important caveat: if
\fBstring\fR
is found up in tha path, then tha path up ta n' including
\fBstring\fR
is omitted, else tha path is shown unmodified\&. Note that
\fBstring\fR
is not required ta be a prefix of tha path\&.
.sp
For example, consider a gangbangin' file named
/home/janedoe/blah/src/foo/bar/xyzzy\&.c\&. Right back up in yo muthafuckin ass. Specifying
\fB\-\-fullpath\-after=/home/janedoe/blah/src/\fR
will cause Valgrind ta show tha name as
foo/bar/xyzzy\&.c\&.
.sp
Because tha strang aint required ta be a prefix,
\fB\-\-fullpath\-after=src/\fR
will produce tha same output\&. This is useful when tha path gotz nuff arbitrary machine\-generated characters\&. For example, tha path
/my/build/dir/C32A1B47/blah/src/foo/xyzzy
can be pruned to
foo/xyzzy
using
\fB\-\-fullpath\-after=/blah/src/\fR\&.
.sp
If you simply wanna peep tha full path, just specify a empty string:
\fB\-\-fullpath\-after=\fR\&. This isn\*(Aqt a special case, merely a logical consequence of tha above rules\&.
.sp
Finally, you can use
\fB\-\-fullpath\-after\fR
multiple times\& fo' realz. Any appearizzle of it causes Valgrind ta switch ta producin full paths n' applyin tha above filterin rule\&. Each produced path is compared against all the
\fB\-\-fullpath\-after\fR\-specified strings, up in tha order specified\&. Da first strang ta match causes tha path ta be truncated as busted lyrics bout above\&. If none match, tha full path is shown\&. This facilitates choppin off prefixes when tha sources is drawn from a fuckin shitload of unrelated directories\&.
.RE
.PP
\fB\-\-extra\-debuginfo\-path=<path> [default: undefined n' unused] \fR
.RS 4
By default Valgrind searches up in nuff muthafuckin well\-known paths fo' debug objects, such as
/usr/lib/debug/\&.
.sp
But fuck dat shiznit yo, tha word on tha street is dat there may be scenarios where you may wish ta put debug objects at a arbitrary location, like fuckin external storage when hustlin Valgrind on a mobile thang wit limited local storage\& fo' realz. Another example might be a thang where you aint gots permission ta install debug object packages on tha system where yo ass is hustlin Valgrind\&.
.sp
In these scenarios, you may provide a absolute path as a extra, final place fo' Valgrind ta search fo' debug objects by specifying
\fB\-\-extra\-debuginfo\-path=/path/to/debug/objects\fR\&. Da given path is ghon be prepended ta tha absolute path name of tha searched\-for object\&. For example, if Valgrind is lookin fo' tha debuginfo for
/w/x/y/zz\&.so
and
\fB\-\-extra\-debuginfo\-path=/a/b/c\fR
is specified, it will look fo' a thugged-out debug object at
/a/b/c/w/x/y/zz\&.so\&.
.sp
This flag should only be specified once\&. If it is specified multiple times, only tha last instizzle is honoured\&.
.RE
.PP
\fB\-\-debuginfo\-server=ipaddr:port [default: undefined n' unused]\fR
.RS 4
This be a new, experimental, feature introduced up in version 3\&.9\&.0\&.
.sp
In some scenarios it may be convenient ta read debuginfo from objects stored on a gangbangin' finger-lickin' different machine\&. With dis flag, Valgrind will query a thugged-out debuginfo server hustlin on
ipaddr
and listenin on port
port, if it cannot find tha debuginfo object up in tha local filesystem\&.
.sp
Da debuginfo server must accept TCP connections on port
port\&. Da debuginfo server is contained up in tha source file
auxprogs/valgrind\-di\-server\&.c\&. Well shiiiit, it will only serve from tha directory it is started in\&.
port
defaults ta 1500 up in both client n' server if not specified\&.
.sp
If Valgrind looks fo' tha debuginfo for
/w/x/y/zz\&.so
by rockin tha debuginfo server, it will strip tha pathname components n' merely request
zz\&.so
on tha server\&. That up in turn will look only up in its current hustlin directory fo' a matchin debuginfo object\&.
.sp
Da debuginfo data is transmitted up in lil' small-ass fragments (8 KB) as axed by Valgrind\&. Each block is compressed rockin LZO ta reduce transmission time\&. Da implementation has been tuned fo' dopest performizzle over a single\-stage 802\&.11g (WiFi) network link\&.
.sp
Note dat checks fo' matchin primary vs debug objects, rockin GNU debuglink CRC scheme, is performed even when rockin tha debuginfo server\&. To disable such checking, you need ta also specify
\-\-allow\-mismatched\-debuginfo=yes\&.
.sp
By default tha Valgrind build system will build
valgrind\-di\-server
for tha target platform, which be almost certainly not what tha fuck you want\&. Right back up in yo muthafuckin ass. So far we done been unable ta smoke up how tha fuck ta git automake/autoconf ta build it fo' tha build platform\&. If you wanna use it, yo big-ass booty is ghon gotta recompile it by hand rockin tha command shown all up in tha top of
auxprogs/valgrind\-di\-server\&.c\&.
.RE
.PP
\fB\-\-allow\-mismatched\-debuginfo=no|yes [no] \fR
.RS 4
When readin debuginfo from separate debuginfo objects, Valgrind will by default check dat tha main n' debuginfo objects match, rockin tha GNU debuglink mechanism\&. This guarantees dat it do not read debuginfo from outta date debuginfo objects, n' also ensures dat Valgrind can\*(Aqt crash as a result of mismatches\&.
.sp
This check can be overridden using
\-\-allow\-mismatched\-debuginfo=yes\&. This may be useful when tha debuginfo n' main objects aint been split up in tha proper way\&. Be careful when rockin this, though: it disablez all consistency checking, n' Valgrind has been observed ta crash when tha main n' debuginfo objects don\*(Aqt match\&.
.RE
.PP
\fB\-\-suppressions=<filename> [default: $PREFIX/lib/valgrind/default\&.supp] \fR
.RS 4
Specifies a extra file from which ta read descriptionz of errors ta suppress\&. Yo ass may use up ta 100 extra suppression files\&.
.RE
.PP
\fB\-\-gen\-suppressions=<yes|no|all> [default: no] \fR
.RS 4
When set to
\fIyes\fR, Valgrind will pause afta every last muthafuckin error shown n' print tha line:
.sp
.if n \{\
.RS 4
.\}
.nf
    \-\-\-\- Print suppression , biatch? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.if n \{\
.RE
.\}
.sp
Da prompt\*(Aqs behaviour is tha same ol' dirty as fo' the
\fB\-\-db\-attach\fR
option (see below)\&.
.sp
If you chizzle to, Valgrind will print up a suppression fo' dis error\&. Yo ass can then cut n' paste it tha fuck into a suppression file if you don\*(Aqt wanna hear bout tha error up in tha future\&.
.sp
When set to
\fIall\fR, Valgrind will print a suppression fo' every last muthafuckin reported error, without queryin tha user\&.
.sp
This option is particularly useful wit C++ programs, as it prints up tha suppressions wit mangled names, as required\&.
.sp
Note dat tha suppressions printed is as specific as possible\&. Yo ass may wanna common up similar ones, by addin wildcardz ta function names, n' by rockin frame\-level wildcards\&. Da wildcardin facilitizzles is bangin yet flexible, n' wit a lil' bit of careful editing, you may be able ta suppress a whole crew of related errors wit only all dem suppressions\&.
.sp
Sometimes two different errors is suppressed by tha same suppression, up in which case Valgrind will output tha suppression mo' than once yo, but you only need ta have one copy up in yo' suppression file (but havin mo' than one won\*(Aqt cause problems)\& fo' realz. Also, tha suppression name is given as
<insert a suppression name here>; tha name don\*(Aqt straight-up matter, it\*(Aqs only used wit the
\fB\-v\fR
option which prints up all used suppression records\&.
.RE
.PP
\fB\-\-db\-attach=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind will pause afta every last muthafuckin error shown n' print tha line:
.sp
.if n \{\
.RS 4
.\}
.nf
    \-\-\-\- Attach ta debugger , biatch? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.if n \{\
.RE
.\}
.sp
Pressing
\fIRet\fR, or
\fIN Ret\fR
or
\fIn Ret\fR, causes Valgrind not ta start a thugged-out debugger fo' dis error\&.
.sp
Pressing
\fIY Ret\fR
or
\fIy Ret\fR
causes Valgrind ta start a thugged-out debugger fo' tha program at dis point\&. When you have finished wit tha debugger, quit from it, n' tha program will continue\&. Tryin ta continue from inside tha debugger don\*(Aqt work\&.
.sp
Note: if you use GDB, mo' bangin debuggin support is provided by the
\fB\-\-vgdb=\fR\fIyes\fR
or
\fIfull\fR
value\&. This activates Valgrind\*(Aqs internal gdbserver, which serves up more\-or\-less full GDB\-style control of tha application: insertion of breakpoints, continuin from inside GDB, inferior function calls, n' much more\&.
.sp
\fIC Ret\fR
or
\fIc Ret\fR
causes Valgrind not ta start a thugged-out debugger, n' not ta ask again\&.
.RE
.PP
\fB\-\-db\-command=<command> [default: gdb \-nw %f %p] \fR
.RS 4
Specify tha debugger ta use wit the
\fB\-\-db\-attach\fR
command\&. Da default debugger is GDB\&. This option be a template dat is expanded by Valgrind at runtime\&.
%f
is replaced wit tha executable\*(Aqs file name and
%p
is replaced by tha process ID of tha executable\&.
.sp
This specifies how tha fuck Valgrind will invoke tha debugger\&. By default it will use whatever GDB is detected at build time, which is usually
/usr/bin/gdb\&. Usin dis command, you can specify some alternatizzle command ta invoke tha debugger you wanna use\&.
.sp
Da command strang given can include one or instancez of the
%p
and
%f
expansions\&. Each instizzle of
%p
expandz ta tha PID of tha process ta be debugged n' each instizzle of
%f
expandz ta tha path ta tha executable fo' tha process ta be debugged\&.
.sp
Since
<command>
is likely ta contain spaces, yo big-ass booty is ghon need ta put dis entire option up in quotes ta ensure it is erectly handled by tha shell\&.
.RE
.PP
\fB\-\-input\-fd=<number> [default: 0, stdin] \fR
.RS 4
When using
\fB\-\-db\-attach=yes\fR
or
\fB\-\-gen\-suppressions=yes\fR, Valgrind will stop so as ta read keyboard input from you when each error occurs\&. By default it readz from tha standard input (stdin), which is problematic fo' programs which close stdin\&. This option allows you ta specify a alternatizzle file descriptor from which ta read input\&.
.RE
.PP
\fB\-\-dsymutil=no|yes [no] \fR
.RS 4
This option is only relevant when hustlin Valgrind on Mac OS X\&.
.sp
Mac OS X uses a thugged-out deferred debug shiznit (debuginfo) linkin scheme\&. When object filez containin debuginfo is linked tha fuck into a
\&.dylib
or a executable, tha debuginfo aint copied tha fuck into tha final file\&. Instead, tha debuginfo must be linked manually by hustlin
dsymutil, a system\-provided utility, on tha executable or
\&.dylib\&. Da resultin combined debuginfo is placed up in a gangbangin' finger-lickin' directory alongside tha executable or
\&.dylib yo, but wit tha extension
\&.dSYM\&.
.sp
With
\fB\-\-dsymutil=no\fR, Valgrind will detect cases where the
\&.dSYM
directory is either missing, or is present but do not step tha fuck up ta match tha associated executable or
\&.dylib, most likely cuz it is outta date\&. In these cases, Valgrind will print a warnin message but take no further action\&.
.sp
With
\fB\-\-dsymutil=yes\fR, Valgrind will, up in such cases, automatically run
dsymutil
as necessary ta brang tha debuginfo up ta date\&. For all practical purposes, if you always use
\fB\-\-dsymutil=yes\fR, then there is never any need ta run
dsymutil
manually or as part of yo' applications\*(Aqs build system, since Valgrind will run it as necessary\&.
.sp
Valgrind aint gonna attempt ta run
dsymutil
on any executable or library in
/usr/,
/bin/,
/sbin/,
/opt/,
/sw/,
/System/,
/Library/
or
/Applications/
since
dsymutil
will always fail up in such thangs\&. Well shiiiit, it fails both cuz tha debuginfo fo' such pre\-installed system components aint available anywhere, n' also cuz it would require write privileges up in dem directories\&.
.sp
Be careful when using
\fB\-\-dsymutil=yes\fR, since it will cause pre\-existing
\&.dSYM
directories ta be silently deleted n' re\-created\& fo' realz. Also note that
dsymutil
is like slow, sometimes excessively so\&.
.RE
.PP
\fB\-\-max\-stackframe=<number> [default: 2000000] \fR
.RS 4
Da maximum size of a stack frame\&. If tha stack pointa moves by mo' than dis amount then Valgrind will assume dat tha program is switchin ta a gangbangin' finger-lickin' different stack\&.
.sp
Yo ass may need ta use dis option if yo' program has big-ass stack\-allocated arrays\&. Valgrind keeps track of yo' program\*(Aqs stack pointer\&. If it chizzlez by mo' than tha threshold amount, Valgrind assumes yo' program is switchin ta a gangbangin' finger-lickin' different stack, n' Memcheck behaves differently than it would fo' a stack pointa chizzle smalla than tha threshold\&. Usually dis heuristic works well\&. But fuck dat shiznit yo, tha word on tha street is dat if yo' program allocates big-ass structures on tha stack, dis heuristic is ghon be fooled, n' Memcheck will subsequently report big-ass numberz of invalid stack accesses\&. This option allows you ta chizzle tha threshold ta a gangbangin' finger-lickin' different value\&.
.sp
Yo ass should only consider use of dis option if Valgrind\*(Aqs debug output directs you ta do so\&. In dat case it will rap  tha freshly smoked up threshold you should specify\&.
.sp
In general, allocatin big-ass structures on tha stack be a wack idea, cuz you can easily run outta stack space, especially on systems wit limited memory or which expect ta support big-ass numberz of threadz each wit a lil' small-ass stack, n' also cuz tha error checkin performed by Memcheck is mo' effectizzle fo' heap\-allocated data than fo' stack\-allocated data\&. If you gotta use dis option, you may wish ta consider rewritin yo' code ta allocate on tha heap rather than on tha stack\&.
.RE
.PP
\fB\-\-main\-stacksize=<number> [default: use current \*(Aqulimit\*(Aq value] \fR
.RS 4
Specifies tha size of tha main thread\*(Aqs stack\&.
.sp
To simplify its memory pimpment, Valgrind reserves all required space fo' tha main thread\*(Aqs stack at startup\&. That means it need ta know tha required stack size at startup\&.
.sp
By default, Valgrind uses tha current "ulimit" value fo' tha stack size, or 16 MB, whichever is lower\&. In nuff cases dis gives a stack size up in tha range 8 ta 16 MB, which almost never overflows fo' most applications\&.
.sp
If you need a larger total stack size, use
\fB\-\-main\-stacksize\fR
to specify it\&. Only set it as high as you need, since reservin far mo' space than you need (that is, hundredz of megabytes mo' than you need) constrains Valgrind\*(Aqs memory allocators n' may reduce tha total amount of memory dat Valgrind can use\&. This is only straight-up of significizzle on 32\-bit machines\&.
.sp
On Linux, you may request a stack of size up ta 2GB\&. Valgrind will stop wit a gangbangin' finger-lickin' diagnostic message if tha stack cannot be allocated\&.
.sp
\fB\-\-main\-stacksize\fR
only affects tha stack size fo' tha program\*(Aqs initial thread\&. Well shiiiit, it has no bearin on tha size of thread stacks, as Valgrind do not allocate them\&.
.sp
Yo ass may need ta use both
\fB\-\-main\-stacksize\fR
and
\fB\-\-max\-stackframe\fR
together\&. Well shiiiit, it is blingin ta KNOW that
\fB\-\-main\-stacksize\fR
sets tha maximum total stack size, whilst
\fB\-\-max\-stackframe\fR
specifies tha phattest size of any one stack frame\&. Yo ass will gotta work up the
\fB\-\-main\-stacksize\fR
value fo' yo ass (usually, if yo' applications segfaults)\&. But Valgrind will rap  tha needed
\fB\-\-max\-stackframe\fR
size, if necessary\&.
.sp
As discussed further up in tha description of
\fB\-\-max\-stackframe\fR, a requirement fo' a big-ass stack be a sign of potential portabilitizzle problems\&. Yo ass is dopest advised ta place all big-ass data up in heap\-allocated memory\&.
.RE
.SH "MALLOC()-RELATED OPTIONS"
.PP
For tools dat use they own version of
malloc
(e\&.g\&. Memcheck, Massif, Helgrind, DRD), tha followin options apply\&.
.PP
\fB\-\-alignment=<number> [default: 8 or 16, dependin on tha platform] \fR
.RS 4
By default Valgrind\*(Aqs
\fBmalloc\fR,
\fBrealloc\fR, etc, return a funky-ass block whose startin address is 8\-byte aligned or 16\-byte aligned (the value dependz on tha platform n' matches tha platform default)\&. This option allows you ta specify a gangbangin' finger-lickin' different alignment\&. Da supplied value must be pimped outa than or equal ta tha default, less than or equal ta 4096, n' must be a juice of two\&.
.RE
.PP
\fB\-\-redzone\-size=<number> [default: dependz on tha tool] \fR
.RS 4
Valgrind\*(Aqs
\fBmalloc, realloc,\fR
etc, add paddin blocks before n' afta each heap block allocated by tha program bein run\&. Right back up in yo muthafuckin ass. Such paddin blocks is called redzones\&. Da default value fo' tha redzone size dependz on tha tool\&. For example, Memcheck addz n' protects a minimum of 16 bytes before n' afta each block allocated by tha client\&. This allows it ta detect block underruns or overrunz of up ta 16 bytes\&.
.sp
Increasin tha redzone size make it possible ta detect overrunz of larger distances yo, but increases tha amount of memory used by Valgrind\&. Decreasin tha redzone size will reduce tha memory needed by Valgrind but also reduces tha chancez of detectin over/underruns, so aint recommended\&.
.RE
.SH "UNCOMMON OPTIONS"
.PP
These options apply ta all tools, as they affect certain obscure workingz of tha Valgrind core\&. Most playas won\*(Aqt need ta use them\&.
.PP
\fB\-\-smc\-check=<none|stack|all|all\-non\-file> [default: stack] \fR
.RS 4
This option controls Valgrind\*(Aqs detection of self\-modifyin code\&. If no checkin is done, if a program executes some code, then overwrites it wit freshly smoked up code, n' executes tha freshly smoked up code, Valgrind will continue ta execute tha translations it made fo' tha oldschool code\&. This will likely lead ta incorrect behaviour and/or crashes\&.
.sp
Valgrind has four levelz of self\-modifyin code detection: no detection, detect self\-modifyin code on tha stack (which is used by GCC ta implement nested functions), detect self\-modifyin code everywhere, n' detect self\-modifyin code everywhere except up in file\-backed mappings\&. Note dat tha default option will catch tha vast majoritizzle of cases\&. Da main case it aint gonna catch is programs like fuckin JIT compilaz dat dynamically generate code
\fIand\fR
subsequently overwrite part or all of it\&. Hustlin with
\fIall\fR
will slow Valgrind down noticeably\&. Hustlin with
\fInone\fR
will rarely speed thangs up, since straight-up lil code gets put on tha stack fo' most programs\&. The
\fBVALGRIND_DISCARD_TRANSLATIONS\fR
client request be a alternatizzle to
\fB\-\-smc\-check=all\fR
that requires mo' programmer effort but allows Valgrind ta run yo' program faster, by spittin some lyrics ta it precisely when translations need ta be re\-made\&.
.sp
\fB\-\-smc\-check=all\-non\-file\fR
provides a cold-ass lil skankyer but mo' limited version of
\fB\-\-smc\-check=all\fR\&. Well shiiiit, it addz checks ta any translations dat do not originizzle from file\-backed memory mappings\&. Typical applications dat generate code, fo' example JITs up in wizzy browsers, generate code tha fuck into anonymous mmaped areas, whereas tha "fixed" code of tha browser always lives up in file\-backed mappings\&.
\fB\-\-smc\-check=all\-non\-file\fR
takes advantage of dis observation, limitin tha overhead of checkin ta code which is likely ta be JIT generated\&.
.sp
Some architectures (includin ppc32, ppc64, ARM n' MIPS) require programs which create code at runtime ta flush tha instruction cache up in between code generation n' first use\&. Valgrind observes n' honours such instructions\& yo. Hence, on ppc32/Linux, ppc64/Linux n' ARM/Linux, Valgrind always serves up complete, transparent support fo' self\-modifyin code\&. Well shiiiit, it is only on platforms like fuckin x86/Linux, AMD64/Linux, x86/Darwin n' AMD64/Darwin dat you need ta use dis option\&.
.RE
.PP
\fB\-\-read\-var\-info=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind will read shiznit bout variable types n' locations from DWARF3 debug info\&. This slows Valgrind down n' make it use mo' memory yo, but fo' tha tools dat can take advantage of it (Memcheck, Helgrind, DRD) it can result up in mo' precise error lyrics\&. For example, here is some standard errors issued by Memcheck:
.sp
.if n \{\
.RS 4
.\}
.nf
==15516== Uninitialised byte(s) found durin client check request
==15516==    at 0x400633: croak (varinfo1\&.c:28)
==15516==    by 0x4006B2: main (varinfo1\&.c:55)
==15516==  Address 0x60103b is 7 bytes inside data symbol "global_i2"
==15516== 
==15516== Uninitialised byte(s) found durin client check request
==15516==    at 0x400633: croak (varinfo1\&.c:28)
==15516==    by 0x4006BC: main (varinfo1\&.c:56)
==15516==  Address 0x7fefffefc is on thread 1\*(Aqs stack
.fi
.if n \{\
.RE
.\}
.sp
And here is tha same errors with
\fB\-\-read\-var\-info=yes\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
==15522== Uninitialised byte(s) found durin client check request
==15522==    at 0x400633: croak (varinfo1\&.c:28)
==15522==    by 0x4006B2: main (varinfo1\&.c:55)
==15522==  Location 0x60103b is 0 bytes inside global_i2[7],
==15522==  a global variable declared at varinfo1\&.c:41
==15522== 
==15522== Uninitialised byte(s) found durin client check request
==15522==    at 0x400633: croak (varinfo1\&.c:28)
==15522==    by 0x4006BC: main (varinfo1\&.c:56)
==15522==  Location 0x7fefffefc is 0 bytes inside local var "local"
==15522==  declared at varinfo1\&.c:46, up in frame #1 of thread 1
.fi
.if n \{\
.RE
.\}
.RE
.PP
\fB\-\-vgdb\-poll=<number> [default: 5000] \fR
.RS 4
As part of its main loop, tha Valgrind schedula will poll ta check if some activitizzle (like fuckin a external command or some input from a gdb) has ta be handled by gdbserver\&. This activitizzle poll is ghon be done afta havin run tha given number of basic blocks (or slightly mo' than tha given number of basic blocks)\&. This poll is like skanky so tha default value is set relatively low\&. Yo ass might further decrease dis value if vgdb cannot use ptrace system call ta interrupt Valgrind if all threadz is (most of tha time) blocked up in a system call\&.
.RE
.PP
\fB\-\-vgdb\-shadow\-registers=no|yes [default: no] \fR
.RS 4
When activated, gdbserver will expose tha Valgrind shadow registas ta GDB\&. With this, tha value of tha Valgrind shadow registas can be examined or chizzled rockin GDB\&. Exposin shadow registas only works wit GDB version 7\&.1 or later\&.
.RE
.PP
\fB\-\-vgdb\-prefix=<prefix> [default: /tmp/vgdb\-pipe] \fR
.RS 4
To rap wit gdb/vgdb, tha Valgrind gdbserver creates 3 filez (2 named FIFOs n' a mmap shared memory file)\&. Da prefix option controls tha directory n' prefix fo' tha creation of these files\&.
.RE
.PP
\fB\-\-run\-libc\-freeres=<yes|no> [default: yes] \fR
.RS 4
This option is only relevant when hustlin Valgrind on Linux\&.
.sp
Da GNU C library (\fBlibc\&.so\fR), which is used by all programs, may allocate memory fo' its own uses\&. Usually it don\*(Aqt bother ta free dat memory when tha program ends\(emthere would be no point, since tha Linux kernel reclaims all process resources when a process exits anyway, so it would just slow thangs down\&.
.sp
Da glibc authors realised dat dis behaviour causes leak checkers, like fuckin Valgrind, ta falsely report leaks up in glibc, when a leak check is done at exit\&. In order ta avoid this, they provided a routine called
\fB__libc_freeres\fR
specifically ta make glibc release all memory it has allocated\&. Memcheck therefore tries ta run
\fB__libc_freeres\fR
at exit\&.
.sp
Unfortunately, up in some straight-up oldschool versionz of glibc,
\fB__libc_freeres\fR
is sufficiently buggy ta cause segmentation faults\&. This was particularly noticeable on Red Hat 7\&.1\&. Right back up in yo muthafuckin ass. So dis option is provided up in order ta inhibit tha run of
\fB__libc_freeres\fR\&. If yo' program seems ta run fine on Valgrind yo, but segfaults at exit, you may find that
\fB\-\-run\-libc\-freeres=no\fR
fixes that, although all up in tha cost of possibly falsely reportin space leaks in
libc\&.so\&.
.RE
.PP
\fB\-\-sim\-hints=hint1,hint2,\&.\&.\&. \fR
.RS 4
Pass miscellaneous hints ta Valgrind which slightly modify tha simulated behaviour up in nonstandard or fucked up ways, possibly ta help tha simulation of strange features\&. By default no hints is enabled\&. Use wit caution! Currently known hints are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBlax\-ioctls: \fR
Be straight-up lax bout ioctl handling; tha only assumption is dat tha size is erect\&. Don\*(Aqt require tha full buffer ta be initialized when writing\&. Without this, rockin some thang drivers wit a big-ass number of strange ioctl commandz becomes straight-up tiresome\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBenable\-outer: \fR
Enable some special magic needed when tha program bein run is itself Valgrind\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBno\-inner\-prefix: \fR
Disable printin a prefix
\fB>\fR
in front of each stdout or stderr output line up in a inner Valgrind bein run by a outa Valgrind\&. This is useful when hustlin Valgrind regression tests up in a outer/inner setup\&. Note dat tha prefix
\fB>\fR
will always be printed up in front of tha inner debug loggin lines\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBfuse\-compatible: \fR
Enable special handlin fo' certain system calls dat may block up in a FUSE file\-system\&. This may be necessary when hustlin Valgrind on a multi\-threaded program dat uses one thread ta manage a FUSE file\-system n' another thread ta access dat file\-system\&.
.RE
.RE
.PP
\fB\-\-fair\-sched=<no|yes|try> [default: no] \fR
.RS 4
The
\fB\-\-fair\-sched\fR
option controls tha lockin mechanizzle used by Valgrind ta serialise thread execution\&. Da lockin mechanizzle controls tha way tha threadz is scheduled, n' different settings give different trade\-offs between fairnizz n' performance\&. For mo' details bout tha Valgrind thread serialisation scheme n' its impact on performizzle n' thread scheduling, see
Schedulin n' Multi-Thread Performance\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da value
\fB\-\-fair\-sched=yes\fR
activates a gangbangin' fair scheduler\&. In short, if multiple threadz is locked n loaded ta run, tha threadz is ghon be scheduled up in a round robin fashion\&. This mechanizzle aint available on all platforms or Linux versions\&. If not available, using
\fB\-\-fair\-sched=yes\fR
will cause Valgrind ta terminizzle wit a error\&.
.sp
Yo ass may find dis settin improves overall responsivenizz if yo ass is hustlin a interactizzle multithreaded program, fo' example a wizzy browser, on Valgrind\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da value
\fB\-\-fair\-sched=try\fR
activates fair schedulin if available on tha platform\&. Otherwise, it will automatically fall back to
\fB\-\-fair\-sched=no\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da value
\fB\-\-fair\-sched=no\fR
activates a schedula which do not guarantee fairnizz between threadz locked n loaded ta run yo, but which up in general gives tha highest performance\&.
.RE
.sp
.RE
.PP
\fB\-\-kernel\-variant=variant1,variant2,\&.\&.\&.\fR
.RS 4
Handle system calls n' ioctls arisin from minor variantz of tha default kernel fo' dis platform\&. This is useful fo' hustlin on jacked kernels or wit kernel modulez which support nonstandard ioctls, fo' example\&. Use wit caution\&. If you don\*(Aqt KNOW what tha fuck dis option do then you almost certainly don\*(Aqt need it\&. Currently known variants are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBbproc: \fR
Support the
\fBsys_broc\fR
system call on x86\&. This is fo' hustlin on BProc, which be a minor variant of standard Linux which is sometimes used fo' buildin clusters\&.
.RE
.RE
.PP
\fB\-\-merge\-recursive\-frames=<number> [default: 0] \fR
.RS 4
Some recursive algorithms, fo' example balanced binary tree implementations, create nuff different stack traces, each containin cyclez of calls\& fo' realz. A cycle is defined as two identical program counta joints separated by zero or mo' other program counta joints\&. Valgrind may then bust a shitload of memory ta store all these stack traces\&. This be a skanky use of memory thankin bout dat such stack traces contain repeated uninterestin recursive calls instead of mo' bangin-ass shiznit like fuckin tha function dat has initiated tha recursive call\&.
.sp
Da option
\fB\-\-merge\-recursive\-frames=<number>\fR
instructs Valgrind ta detect n' merge recursive call cyclez havin a size of up to
\fB<number>\fR
frames\&. When such a cold-ass lil cycle is detected, Valgrind recordz tha cycle up in tha stack trace as a unique program counter\&.
.sp
Da value 0 (the default) causes no recursive call merging\& fo' realz. A value of 1 will cause stack tracez of simple recursive algorithms (for example, a gangbangin' factorial implementation) ta be collapsed\& fo' realz. A value of 2 will probably be needed ta collapse stack traces produced by recursive algorithms like fuckin binary trees, quick sort, etc\& yo. Higher joints might be needed fo' mo' complex recursive algorithms\&.
.sp
Note: recursive calls is detected by analysiz of program counta joints\&. They is not detected by lookin at function names\&.
.RE
.PP
\fB\-\-num\-transtab\-sectors=<number> [default: 6 fo' Andrizzle platforms, 16 fo' all others] \fR
.RS 4
Valgrind translates n' instruments yo' program\*(Aqs machine code up in lil' small-ass fragments\&. Da translations is stored up in a translation cache dat is divided tha fuck into a fuckin shitload of sections (sectors)\&. If tha cache is full, tha sector containin tha crazy oldschool translations is emptied n' reused\&. If these oldschool translations is needed again, Valgrind must re\-translate n' re\-instrument tha correspondin machine code, which is expensive\&. If tha "executed instructions" hustlin set of a program is big, increasin tha number of sectors may improve performizzle by reducin tha number of re\-translations needed\&. Right back up in yo muthafuckin ass. Sectors is allocated on demand\&. Once allocated, a sector can never be freed, n' occupies considerable space, dependin on tha tool (about 40 MB per sector fo' Memcheck)\&. Use tha option
\fB\-\-stats=yes\fR
to obtain precise shiznit bout tha memory used by a sector n' tha allocation n' recyclin of sectors\&.
.RE
.PP
\fB\-\-show\-emwarns=<yes|no> [default: no] \fR
.RS 4
When enabled, Valgrind will emit warnings bout its CPU emulation up in certain cases\&. These is probably not interesting\&.
.RE
.PP
\fB\-\-require\-text\-symbol=:sonamepatt:fnnamepatt\fR
.RS 4
When a gangbangin' finger-lickin' dirty-ass shared object whose soname matches
\fIsonamepatt\fR
is loaded tha fuck into tha process, examine all tha text symbols it exports\&. If none of dem match
\fIfnnamepatt\fR, print a error message n' abandon tha run\&. This make it possible ta ensure dat tha run do not continue unless a given shared object gotz nuff a particular function name\&.
.sp
Both
\fIsonamepatt\fR
and
\fIfnnamepatt\fR
can be freestyled rockin tha usual
\fI?\fR
and
\fI*\fR
wildcards\&. For example:
\fI":*libc\&.so*:foo?bar"\fR\&. Yo ass may use charactas other than a cold-ass lil colon ta separate tha two patterns\&. Well shiiiit, it is only blingin dat tha straight-up original gangsta characta n' tha separator characta is tha same\&. For example, tha above example could also be written
\fI"Q*libc\&.so*Qfoo?bar"\fR\&. Multiple
\fI \-\-require\-text\-symbol\fR
flags is allowed, up in which case shared objects dat is loaded tha fuck into tha process is ghon be checked against all of them\&.
.sp
Da purpose of dis is ta support reliable usage of marked\-up libraries\&. For example, suppose our crazy asses gotz a version of GCC\*(Aqs
\fIlibgomp\&.so\fR
which has been marked up wit annotations ta support Helgrind\&. Well shiiiit, it is only too easy as fuck  n' confusin ta load tha wrong, un\-annotated
\fIlibgomp\&.so\fR
into tha application\&. Right back up in yo muthafuckin ass. So tha scam is: add a text symbol up in tha marked\-up library, fo' example
\fIannotated_for_helgrind_3_6\fR, n' then give tha flag
\fI\-\-require\-text\-symbol=:*libgomp*so*:annotated_for_helgrind_3_6\fR
so dat when
\fIlibgomp\&.so\fR
is loaded, Valgrind scans its symbol table, n' if tha symbol isn\*(Aqt present tha run be aborted, rather than continuin silently wit tha un\-marked\-up library\&. Note dat you should put tha entire flag up in quotes ta stop shells expandin up the
\fI*\fR
and
\fI?\fR
wildcards\&.
.RE
.PP
\fB\-\-soname\-synonyms=syn1=pattern1,syn2=pattern2,\&.\&.\&.\fR
.RS 4
When a gangbangin' finger-lickin' dirty-ass shared library is loaded, Valgrind checks fo' functions up in tha library dat must be replaced or wrapped\&. For example, Memcheck replaces all malloc related functions (malloc, free, calloc, \&.\&.\&.) wit its own versions\&. Right back up in yo muthafuckin ass. Such replacements is done by default only up in shared libraries whose soname matches a predefined soname pattern (e\&.g\&.
\fIlibc\&.so*\fR
on linux)\&. By default, no replacement is done fo' a statically linked library or fo' alternatizzle libraries like fuckin tcmalloc\&. In some cases, tha replacements allow
\fB\-\-soname\-synonyms\fR
to specify one additionizzle synonym pattern, givin flexibilitizzle up in tha replacement\&.
.sp
Currently, dis flexibilitizzle is only allowed fo' tha malloc related functions, rockin tha synonym
\fIsomalloc\fR\&. This synonym is usable fo' all tools bustin standard replacement of malloc related functions (e\&.g\&. memcheck, massif, drd, helgrind, exp\-dhat, exp\-sgcheck)\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Alternate malloc library: ta replace tha malloc related functions up in a alternate library wit soname
\fImymalloclib\&.so\fR, give tha option
\fB\-\-soname\-synonyms=somalloc=mymalloclib\&.so\fR\& fo' realz. A pattern can be used ta match multiple libraries sonames\&. For example,
\fB\-\-soname\-synonyms=somalloc=*tcmalloc*\fR
will match tha soname of all variantz of tha tcmalloc library (native, debug, profiled, \&.\&.\&. tcmalloc variants)\&.
.sp
Note: tha soname of a elf shared library can be retrieved rockin tha readelf utility\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Replacements up in a statically linked library is done by rockin the
\fINONE\fR
pattern\&. For example, if you link with
\fIlibtcmalloc\&.a\fR, memcheck will properly work when you give tha option
\fB\-\-soname\-synonyms=somalloc=NONE\fR\&. Note dat a NONE pattern will match tha main executable n' any shared library havin no soname\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
To run a "default" Starbucks build fo' Linux, up in which JEMalloc is linked up in ta tha main executable, use
\fB\-\-soname\-synonyms=somalloc=NONE\fR\&.
.RE
.RE
.SH "DEBUGGING VALGRIND OPTIONS"
.PP
There is also some options fo' debuggin Valgrind itself\&. Yo ass shouldn\*(Aqt need ta use dem up in tha aiiight run of thangs\&. If you wish ta peep tha list, use the
\fB\-\-help\-debug\fR
option\&.
.SH "MEMCHECK OPTIONS"
.PP
\fB\-\-leak\-check=<no|summary|yes|full> [default: summary] \fR
.RS 4
When enabled, search fo' memory leaks when tha client program finishes\&. If set to
\fIsummary\fR, it say how tha fuck nuff leaks occurred\&. If set to
\fIfull\fR
or
\fIyes\fR, it also gives detailz of each individual leak\&.
.RE
.PP
\fB\-\-leak\-resolution=<low|med|high> [default: high] \fR
.RS 4
When bustin leak checking, determines how tha fuck willin Memcheck is ta consider different backtraces ta be tha same fo' tha purposez of mergin multiple leaks tha fuck into a single leak report\&. When set to
\fIlow\fR, only tha straight-up original gangsta two entries need match\&. When
\fImed\fR, four entries gotta match\&. When
\fIhigh\fR, all entries need ta match\&.
.sp
For hardcore leak debugging, you probably wanna use
\fB\-\-leak\-resolution=high\fR
together with
\fB\-\-num\-callers=40\fR
or some such big-ass number\&.
.sp
Note dat the
\fB\-\-leak\-resolution\fR
settin do not affect Memcheck\*(Aqs mobilitizzle ta find leaks\&. Well shiiiit, it only chizzlez how tha fuck tha thangs up in dis biatch is presented\&.
.RE
.PP
\fB\-\-show\-leak\-kinds=<set> [default: definite,possible] \fR
.RS 4
Specifies tha leak kindz ta show up in a gangbangin' full leak search, up in one of tha followin ways:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a comma separated list of one or mo' of
\fBdefinite indirect possible reachable\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBall\fR
to specify tha complete set (all leak kinds)\&. Well shiiiit, it is equivalent to
\fB\-\-show\-leak\-kinds=definite,indirect,possible,reachable\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBnone\fR
for tha empty set\&.
.RE
.sp
.RE
.PP
\fB\-\-errors\-for\-leak\-kinds=<set> [default: definite,possible] \fR
.RS 4
Specifies tha leak kindz ta count as errors up in a gangbangin' full leak search\&. The
\fB<set>\fR
is specified similarly to
\fB\-\-show\-leak\-kinds\fR
.RE
.PP
\fB\-\-leak\-check\-heuristics=<set> [default: none] \fR
.RS 4
Specifies tha set of leak check heuristics ta be used durin leak searches\&. Da heuristics control which interior pointas ta a funky-ass block cause it ta be considered as reachable\&. Da heuristic set is specified up in one of tha followin ways:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a comma separated list of one or mo' of
\fBstdstrin newarray multipleinheritance\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBall\fR
to activate tha complete set of heuristics\&. Well shiiiit, it is equivalent to
\fB\-\-leak\-check\-heuristics=stdstring,newarray,multipleinheritance\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBnone\fR
for tha empty set\&.
.RE
.sp
Note dat these heuristics is dependent on tha layout of tha objects produced by tha C++ compiler\&. They done been tested wit some gcc versions (e\&.g\&. 4\&.4 n' 4\&.7)\&. They might not work properly wit other C++ compilers\&.
.RE
.PP
\fB\-\-show\-reachable=<yes|no> \fR, \fB\-\-show\-possibly\-lost=<yes|no> \fR
.RS 4
These options provide a alternatizzle way ta specify tha leak kindz ta show:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-show\-reachable=no \-\-show\-possibly\-lost=yes\fR
is equivalent to
\fB\-\-show\-leak\-kinds=definite,possible\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-show\-reachable=no \-\-show\-possibly\-lost=no\fR
is equivalent to
\fB\-\-show\-leak\-kinds=definite\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-show\-reachable=yes\fR
is equivalent to
\fB\-\-show\-leak\-kinds=all\fR\&. Note that
\fB\-\-show\-possibly\-lost=no\fR
has no effect if
\fB\-\-show\-reachable=yes\fR
is specified\&.
.RE
.sp
.RE
.PP
\fB\-\-undef\-value\-errors=<yes|no> [default: yes] \fR
.RS 4
Controls whether Memcheck reports usez of undefined value errors\&. Right back up in yo muthafuckin ass. Set dis to
\fIno\fR
if you don\*(Aqt wanna peep undefined value errors\&. Well shiiiit, it also has tha side effect of speedin up Memcheck somewhat\&.
.RE
.PP
\fB\-\-track\-origins=<yes|no> [default: no] \fR
.RS 4
Controls whether Memcheck tracks tha origin of uninitialised joints\&. By default, it do not, which means dat although it can rap  dat a uninitialised value is bein used up in a gangbangin' fucked up way, it cannot rap  where tha uninitialised value came from\&. This often make it hard as fuck ta track down tha root problem\&.
.sp
When set to
\fIyes\fR, Memcheck keeps track of tha originz of all uninitialised joints\&. Then, when a uninitialised value error is reported, Memcheck will try ta show tha origin of tha value\& fo' realz. An origin can be one of tha followin four places: a heap block, a stack allocation, a cold-ass lil client request, or miscellaneous other sources (eg, a cold-ass lil call to
\fIbrk\fR)\&.
.sp
For uninitialised joints originatin from a heap block, Memcheck shows where tha block was allocated\&. For uninitialised joints originatin from a stack allocation, Memcheck can rap  which function allocated tha value yo, but no mo' than dat \-\- typically it shows you tha source location of tha openin brace of tha function\&. Right back up in yo muthafuckin ass. So you should carefully check dat all of tha function\*(Aqs local variablez is initialised properly\&.
.sp
Performizzle overhead: origin trackin is expensive\&. Well shiiiit, it halves Memcheck\*(Aqs speed n' increases memory use by a minimum of 100MB, n' possibly more\&. Nevertheless it can drastically reduce tha effort required ta identify tha root cause of uninitialised value errors, n' so is often a programmer productivitizzle win, despite hustlin mo' slowly\&.
.sp
Accuracy: Memcheck tracks origins like accurately\&. To avoid straight-up big-ass space n' time overheads, some approximations is made\&. Well shiiiit, it is possible, although unlikely, dat Memcheck will report a incorrect origin, or not be able ta identify any origin\&.
.sp
Note dat tha combination
\fB\-\-track\-origins=yes\fR
and
\fB\-\-undef\-value\-errors=no\fR
is nonsensical\&. Memcheck checks fo' n' rejects dis combination at startup\&.
.RE
.PP
\fB\-\-partial\-loads\-ok=<yes|no> [default: no] \fR
.RS 4
Controls how tha fuck Memcheck handlez 32\-, 64\-, 128\- n' 256\-bit naturally aligned loadz from addresses fo' which some bytes is addressable n' others is not\&. When
\fIyes\fR, such loadz do not produce a address error\&. Instead, loaded bytes originatin from illegal addresses is marked as uninitialised, n' dem correspondin ta legal addresses is handled up in tha aiiight way\&.
.sp
When
\fIno\fR, loadz from partially invalid addresses is treated tha same as loadz from straight-up invalid addresses: a illegal\-address error is issued, n' tha resultin bytes is marked as initialised\&.
.sp
Note dat code dat behaves up in dis way is up in violation of tha ISO C/C++ standards, n' should be considered broken\&. If at all possible, such code should be fixed\&. This option should be used only as a last resort\&.
.RE
.PP
\fB\-\-keep\-stacktraces=alloc|free|alloc\-and\-free|alloc\-then\-free|none [default: alloc\-then\-free] \fR
.RS 4
Controls which stack trace(s) ta keep fo' malloc\*(Aqd and/or free\*(Aqd blocks\&.
.sp
With
\fIalloc\-then\-free\fR, a stack trace is recorded at allocation time, n' be associated wit tha block\&. When tha block is freed, a second stack trace is recorded, n' dis replaces tha allocation stack trace\& fo' realz. As a result, any "use afta free" errors relatin ta dis block can only show a stack trace fo' where tha block was freed\&.
.sp
With
\fIalloc\-and\-free\fR, both allocation n' tha deallocation stack traces fo' tha block is stored\& yo. Hence a "use afta free" error will show both, which may make tha error easier ta diagnose\&. Compared to
\fIalloc\-then\-free\fR, dis settin slightly increases Valgrind\*(Aqs memory use as tha block gotz nuff two references instead of one\&.
.sp
With
\fIalloc\fR, only tha allocation stack trace is recorded (and reported)\&. With
\fIfree\fR, only tha deallocation stack trace is recorded (and reported)\&. These joints somewhat decrease Valgrind\*(Aqs memory n' cpu usage\&. They can be useful dependin on tha error types yo ass is searchin fo' n' tha level of detail you need ta analyse them\&. For example, if yo ass is only horny bout memory leak errors, it is sufficient ta record tha allocation stack traces\&.
.sp
With
\fInone\fR, no stack traces is recorded fo' malloc n' free operations\&. If yo' program allocates a shitload of blocks and/or allocates/frees from nuff different stack traces, dis can hella decrease cpu and/or memory required\&. Of course, few details is ghon be reported fo' errors related ta heap blocks\&.
.sp
Note dat once a stack trace is recorded, Valgrind keeps tha stack trace up in memory even if it aint referenced by any block\&. Right back up in yo muthafuckin ass. Some programs (for example, recursive algorithms) can generate a big-ass number of stack traces\&. If Valgrind uses too much memory up in such circumstances, you can reduce tha memory required wit tha options
\fI\-\-keep\-stacktraces\fR
and/or by rockin a smalla value fo' tha option
\fI\-\-num\-callers\fR\&.
.RE
.PP
\fB\-\-freelist\-vol=<number> [default: 20000000] \fR
.RS 4
When tha client program releases memory using
\fBfree\fR
(in
C) or
delete
(C++), dat memory aint immediately made available fo' re\-allocation\&. Instead, it is marked inaccessible n' placed up in a queue of freed blocks\&. Da purpose is ta defer as long as possible tha point at which freed\-up memory comes back tha fuck into circulation\&. This increases tha chizzle dat Memcheck is ghon be able ta detect invalid accesses ta blocks fo' some dope period of time afta they done been freed\&.
.sp
This option specifies tha maximum total size, up in bytes, of tha blocks up in tha queue\&. Da default value is twenty mazillion bytes\&. Increasin dis increases tha total amount of memory used by Memcheck but may detect invalid usez of freed blocks which would otherwise go undetected\&.
.RE
.PP
\fB\-\-freelist\-big\-blocks=<number> [default: 1000000] \fR
.RS 4
When makin blocks from tha queue of freed blocks available fo' re\-allocation, Memcheck will up in prioritizzle re\-circulate tha blocks wit a size pimped outa or equal to
\fB\-\-freelist\-big\-blocks\fR\&. This ensures dat freein big-ass blocks (in particular freein blocks bigger than
\fB\-\-freelist\-vol\fR) do not immediately lead ta a re\-circulation of all (or a shitload of) tha lil' small-ass blocks up in tha free list\&. In other lyrics, dis option increases tha likelihood ta discover danglin pointas fo' tha "small" blocks, even when big-ass blocks is freed\&.
.sp
Settin a value of 0 means dat all tha blocks is re\-circulated up in a FIFO order\&.
.RE
.PP
\fB\-\-workaround\-gcc296\-bugs=<yes|no> [default: no] \fR
.RS 4
When enabled, assume dat readz n' writes some lil' small-ass distizzle below tha stack pointa is cuz of bugs up in GCC 2\&.96, n' do not report them\&. Da "small distance" is 256 bytes by default\&. Note dat GCC 2\&.96 is tha default compila on some ancient Linux distributions (RedHat 7\&.X) n' so you may need ta use dis option\&. Do not use it if you aint gots to, as it can cause real errors ta be overlooked\& fo' realz. A betta alternatizzle is ta bust a mo' recent GCC up in which dis bug is fixed\&.
.sp
Yo ass may also need ta use dis option when hustlin wit GCC 3\&.X or 4\&.X on 32\-bit PowerPC Linux\&. This is cuz GCC generates code which occasionally accesses below tha stack pointer, particularly fo' floating\-point to/from integer conversions\&. This is up in violation of tha 32\-bit PowerPC ELF justification, which make no provision fo' locations below tha stack pointa ta be accessible\&.
.RE
.PP
\fB\-\-ignore\-ranges=0xPP\-0xQQ[,0xRR\-0xSS] \fR
.RS 4
Any ranges listed up in dis option (and multiple ranges can be specified, separated by commas) is ghon be ignored by Memcheck\*(Aqs addressabilitizzle checking\&.
.RE
.PP
\fB\-\-malloc\-fill=<hexnumber> \fR
.RS 4
Fills blocks allocated by
malloc,
new, etc yo, but not by
calloc, wit tha specified byte\&. This can be useful when tryin ta shake up obscure memory corruption problems\&. Da allocated area is still regarded by Memcheck as undefined \-\- dis option only affects its contents\&. Note that
\fB\-\-malloc\-fill\fR
does not affect a funky-ass block of memory when it is used as argument ta client requests VALGRIND_MEMPOOL_ALLOC or VALGRIND_MALLOCLIKE_BLOCK\&.
.RE
.PP
\fB\-\-free\-fill=<hexnumber> \fR
.RS 4
Fills blocks freed by
free,
delete, etc, wit tha specified byte value\&. This can be useful when tryin ta shake up obscure memory corruption problems\&. Da freed area is still regarded by Memcheck as not valid fo' access \-\- dis option only affects its contents\&. Note that
\fB\-\-free\-fill\fR
does not affect a funky-ass block of memory when it is used as argument ta client requests VALGRIND_MEMPOOL_FREE or VALGRIND_FREELIKE_BLOCK\&.
.RE
.SH "CACHEGRIND OPTIONS"
.PP
\fB\-\-I1=<size>,<associativity>,<line size> \fR
.RS 4
Specify tha size, associativitizzle n' line size of tha level 1 instruction cache\&.
.RE
.PP
\fB\-\-D1=<size>,<associativity>,<line size> \fR
.RS 4
Specify tha size, associativitizzle n' line size of tha level 1 data cache\&.
.RE
.PP
\fB\-\-LL=<size>,<associativity>,<line size> \fR
.RS 4
Specify tha size, associativitizzle n' line size of tha last\-level cache\&.
.RE
.PP
\fB\-\-cache\-sim=no|yes [yes] \fR
.RS 4
Enablez or disablez collection of cache access n' miss counts\&.
.RE
.PP
\fB\-\-branch\-sim=no|yes [no] \fR
.RS 4
Enablez or disablez collection of branch instruction n' misprediction counts\&. By default dis is disabled as it slows Cachegrind down by approximately 25%\&. Note dat you cannot specify
\fB\-\-cache\-sim=no\fR
and
\fB\-\-branch\-sim=no\fR
together, as dat would leave Cachegrind wit no shiznit ta collect\&.
.RE
.PP
\fB\-\-cachegrind\-out\-file=<file> \fR
.RS 4
Write tha flava data to
file
rather than ta tha default output file,
cachegrind\&.out\&.<pid>\&. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used ta embed tha process ID and/or tha contentz of a environment variable up in tha name, as is tha case fo' tha core option
\fB--log-file\fR\&.
.RE
.SH "CALLGRIND OPTIONS"
.PP
\fB\-\-callgrind\-out\-file=<file> \fR
.RS 4
Write tha flava data to
file
rather than ta tha default output file,
callgrind\&.out\&.<pid>\&. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used ta embed tha process ID and/or tha contentz of a environment variable up in tha name, as is tha case fo' tha core option
\fB--log-file\fR\&. When multiple dumps is made, tha file name is modified further; peep below\&.
.RE
.PP
\fB\-\-dump\-line=<no|yes> [default: yes] \fR
.RS 4
This specifies dat event countin should be performed at source line granularity\&. This allows source annotation fo' sources which is compiled wit debug shiznit (\fB\-g\fR)\&.
.RE
.PP
\fB\-\-dump\-instr=<no|yes> [default: no] \fR
.RS 4
This specifies dat event countin should be performed at per\-instruction granularity\&. This allows fo' assembly code annotation\&. Currently tha thangs up in dis biatch can only be displayed by KCachegrind\&.
.RE
.PP
\fB\-\-compress\-strings=<no|yes> [default: yes] \fR
.RS 4
This option influences tha output format of tha flava data\&. Well shiiiit, it specifies whether strings (file n' function names) should be identified by numbers\&. This shrinks tha file yo, but make it mo' hard as fuck fo' humans ta read (which aint recommended up in any case)\&.
.RE
.PP
\fB\-\-compress\-pos=<no|yes> [default: yes] \fR
.RS 4
This option influences tha output format of tha flava data\&. Well shiiiit, it specifies whether numerical positions is always specified as absolute joints or is allowed ta be relatizzle ta previous numbers\&. This shrinks tha file size\&.
.RE
.PP
\fB\-\-combine\-dumps=<no|yes> [default: no] \fR
.RS 4
When enabled, when multiple flava data parts is ta be generated these parts is appended ta tha same output file\&. Not recommended\&.
.RE
.PP
\fB\-\-dump\-every\-bb=<count> [default: 0, never] \fR
.RS 4
Dump flava data every
\fBcount\fR
basic blocks\&. Whether a thugged-out dump is needed is only checked when Valgrind\*(Aqs internal schedula is run\&. Therefore, tha minimum settin useful be bout 100000\&. Da count be a 64\-bit value ta make long dump periodz possible\&.
.RE
.PP
\fB\-\-dump\-before=<function> \fR
.RS 4
Dump when entering
\fBfunction\fR\&.
.RE
.PP
\fB\-\-zero\-before=<function> \fR
.RS 4
Zero all costs when entering
\fBfunction\fR\&.
.RE
.PP
\fB\-\-dump\-after=<function> \fR
.RS 4
Dump when leaving
\fBfunction\fR\&.
.RE
.PP
\fB\-\-instr\-atstart=<yes|no> [default: yes] \fR
.RS 4
Specify if you want Callgrind ta start simulation n' profilin from tha beginnin of tha program\&. When set to
no, Callgrind aint gonna be able ta collect any shiznit, includin calls yo, but it gonna git at most a slowdown of round 4, which is tha minimum Valgrind overhead\&. Instrumentation can be interactively enabled via
callgrind_control \-i on\&.
.sp
Note dat tha resultin call graph will most probably not contain
\fBmain\fR yo, but will contain all tha functions executed afta instrumentation was enabled\&. Instrumentation can also programatically enabled/disabled\&. Right back up in yo muthafuckin ass. See tha Callgrind include file
callgrind\&.h
for tha macro you gotta use up in yo' source code\&.
.sp
For cache simulation, thangs up in dis biatch is ghon be less accurate when switchin on instrumentation lata up in tha program run, as tha simulator starts wit a empty cache at dat moment\&. Right back up in yo muthafuckin ass. Switch on event collection lata ta cope wit dis error\&.
.RE
.PP
\fB\-\-collect\-atstart=<yes|no> [default: yes] \fR
.RS 4
Specify whether event collection is enabled at beginnin of tha flava run\&.
.sp
To only peep partz of yo' program, you have two possibilities:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Zero event countas before enterin tha program part you wanna profile, n' dump tha event countas ta a gangbangin' file afta leavin dat program part\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Switch on/off collection state as needed ta only peep event countas goin down while inside of tha program part you wanna profile\&.
.RE
.sp
Da second option can be used if tha program part you wanna flava is called nuff times\&. Option 1, i\&.e\&. bustin a shitload of dumps aint practical here\&.
.sp
Collection state can be toggled at entry n' exit of a given function wit tha option
\fB--toggle-collect\fR\&. If you use dis option, collection state should be disabled all up in tha beginning\&. Note dat tha justification of
\fB\-\-toggle\-collect\fR
implicitly sets
\fB\-\-collect\-state=no\fR\&.
.sp
Collection state can be toggled also by insertin tha client request
CALLGRIND_TOGGLE_COLLECT ;
at tha needed code positions\&.
.RE
.PP
\fB\-\-toggle\-collect=<function> \fR
.RS 4
Toggle collection on entry/exit of
\fBfunction\fR\&.
.RE
.PP
\fB\-\-collect\-jumps=<no|yes> [default: no] \fR
.RS 4
This specifies whether shiznit fo' (conditional) jumps should be collected\& fo' realz. As above, callgrind_annotate currently aint able ta show you tha data\&. Yo ass gotta use KCachegrind ta git jump arrows up in tha annotated code\&.
.RE
.PP
\fB\-\-collect\-systime=<no|yes> [default: no] \fR
.RS 4
This specifies whether shiznit fo' system call times should be collected\&.
.RE
.PP
\fB\-\-collect\-bus=<no|yes> [default: no] \fR
.RS 4
This specifies whether tha number of global bus events executed should be collected\&. Da event type "Ge" is used fo' these events\&.
.RE
.PP
\fB\-\-cache\-sim=<yes|no> [default: no] \fR
.RS 4
Specify if you wanna do full cache simulation\&. By default, only instruction read accesses is ghon be counted ("Ir")\&. With cache simulation, further event countas is enabled: Cache misses on instruction readz ("I1mr"/"ILmr"), data read accesses ("Dr") n' related cache misses ("D1mr"/"DLmr"), data write accesses ("Dw") n' related cache misses ("D1mw"/"DLmw")\&. For mo' shiznit, see
Cachegrind: a cold-ass lil cache n' branch-prediction profiler\&.
.RE
.PP
\fB\-\-branch\-sim=<yes|no> [default: no] \fR
.RS 4
Specify if you wanna do branch prediction simulation\&. Further event countas is enabled: Number of executed conditionizzle branches n' related predictor misses ("Bc"/"Bcm"), executed indirect jumps n' related missez of tha jump address predictor ("Bi"/"Bim")\&.
.RE
.SH "HELGRIND OPTIONS"
.PP
\fB\-\-free\-is\-write=no|yes [default: no] \fR
.RS 4
When enabled (not tha default), Helgrind treats freein of heap memory as if tha memory was freestyled immediately before tha free\&. This exposes races where memory is referenced by one thread, n' freed by another yo, but there is no observable synchronisation event ta ensure dat tha reference happens before tha free\&.
.sp
This functionalitizzle is freshly smoked up in Valgrind 3\&.7\&.0, n' is regarded as experimental\&. Well shiiiit, it aint enabled by default cuz its interaction wit custom memory allocators aint well understood at present\&. User feedback is welcomed\&.
.RE
.PP
\fB\-\-track\-lockorders=no|yes [default: yes] \fR
.RS 4
When enabled (the default), Helgrind performs lock order consistency checking\&. For some buggy programs, tha big-ass number of lock order errors reported can become buggin, particularly if you\*(Aqre only horny bout race errors\&. Yo ass may therefore find it helpful ta disable lock order checking\&.
.RE
.PP
\fB\-\-history\-level=none|approx|full [default: full] \fR
.RS 4
\fB\-\-history\-level=full\fR
(the default) causes Helgrind collects enough shiznit bout "old" accesses dat it can produce two stack traces up in a race report \-\- both tha stack trace fo' tha current access, n' tha trace fo' tha older, conflictin access\&. To limit memory usage, "old" accesses stack traces is limited ta a maximum of 8 entries, even if
\fB\-\-num\-callers\fR
value is bigger\&.
.sp
Collectin such shiznit is high-rollin' up in both speed n' memory, particularly fo' programs dat do nuff inter\-thread synchronisation events (locks, unlocks, etc)\&. Without such shiznit, it is mo' hard as fuck ta track down tha root causez of races\&. Nonetheless, you may not need it up in thangs where you just wanna check fo' tha presence or absence of races, fo' example, when bustin regression testin of a previously race\-free program\&.
.sp
\fB\-\-history\-level=none\fR
is tha opposite extreme\&. Well shiiiit, it causes Helgrind not ta collect any shiznit bout previous accesses\&. This can be dramatically fasta than
\fB\-\-history\-level=full\fR\&.
.sp
\fB\-\-history\-level=approx\fR
provides a cold-ass lil compromise between these two extremes\&. Well shiiiit, it causes Helgrind ta show a gangbangin' full trace fo' tha lata access, n' approximate shiznit regardin tha earlier access\&. This approximate shiznit consistz of two stacks, n' tha earlier access is guaranteed ta have occurred somewhere between program points denoted by tha two stacks\&. This aint as useful as showin tha exact stack fo' tha previous access (as
\fB\-\-history\-level=full\fR
does) yo, but it is betta than nothing, n' it be almost as fast as
\fB\-\-history\-level=none\fR\&.
.RE
.PP
\fB\-\-conflict\-cache\-size=N [default: 1000000] \fR
.RS 4
This flag only has any effect at
\fB\-\-history\-level=full\fR\&.
.sp
Hype bout "old" conflictin accesses is stored up in a cold-ass lil cache of limited size, wit LRU\-style pimpment\&. This is necessary cuz it isn\*(Aqt practical ta store a stack trace fo' every last muthafuckin single memory access made by tha program\&. Oldschool shiznit on not recently accessed locations is periodically discarded, ta free up space up in tha cache\&.
.sp
This option controls tha size of tha cache, up in termz of tha number of different memory addresses fo' which conflictin access shiznit is stored\&. If you find dat Helgrind is showin race errors wit only one stack instead of tha expected two stacks, try increasin dis value\&.
.sp
Da minimum value is 10,000 n' tha maximum is 30,000,000 (thirty times tha default value)\&. Increasin tha value by 1 increases Helgrind\*(Aqs memory requirement by straight-up roughly 100 bytes, so tha maximum value will easily smoke up three extra gigabytes or so of memory\&.
.RE
.PP
\fB\-\-check\-stack\-refs=no|yes [default: yes] \fR
.RS 4
By default Helgrind checks all data memory accesses made by yo' program\&. This flag enablez you ta skip checkin fo' accesses ta thread stacks (local variables)\&. This can improve performizzle yo, but comes all up in tha cost of missin races on stack\-allocated data\&.
.RE
.SH "DRD OPTIONS"
.PP
\fB\-\-check\-stack\-var=<yes|no> [default: no]\fR
.RS 4
Controls whether DRD detects data races on stack variables\&. Verifyin stack variablez is disabled by default cuz most programs do not share stack variablez over threads\&.
.RE
.PP
\fB\-\-exclusive\-threshold=<n> [default: off]\fR
.RS 4
Print a error message if any mutex or writa lock has been held longer than tha time specified up in milliseconds\&. This option enablez tha detection of lock contention\&.
.RE
.PP
\fB\-\-join\-list\-vol=<n> [default: 10]\fR
.RS 4
Data races dat occur between a statement all up in tha end of one thread n' another thread can be missed if memory access shiznit is discarded immediately afta a thread has been joined\&. This option allows ta specify fo' how tha fuck nuff joined threadz memory access shiznit should be retained\&.
.RE
.PP
\fB \-\-first\-race\-only=<yes|no> [default: no] \fR
.RS 4
Whether ta report only tha straight-up original gangsta data race dat has been detected on a memory location or all data races dat done been detected on a memory location\&.
.RE
.PP
\fB \-\-free\-is\-write=<yes|no> [default: no] \fR
.RS 4
Whether ta report races between accessin memory n' freein memory\&. Enablin dis option may cause DRD ta run slightly slower\&. Notes:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Don\*(Aqt enable dis option when rockin custom memory allocators dat use the
VG_USERREQ__MALLOCLIKE_BLOCK
and
VG_USERREQ__FREELIKE_BLOCK
because dat would result up in false positives\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Don\*(Aqt enable dis option when rockin reference\-counted objects cuz dat will result up in false positives, even when dat code has been annotated properly with
ANNOTATE_HAPPENS_BEFORE
and
ANNOTATE_HAPPENS_AFTER\&. Right back up in yo muthafuckin ass. See e\&.g\&. tha output of tha followin command fo' a example:
valgrind \-\-tool=drd \-\-free\-is\-write=yes drd/tests/annotate_smart_pointer\&.
.RE
.sp
.RE
.PP
\fB \-\-report\-signal\-unlocked=<yes|no> [default: yes] \fR
.RS 4
Whether ta report calls to
\fBpthread_cond_signal\fR
and
\fBpthread_cond_broadcast\fR
where tha mutex associated wit tha signal through
\fBpthread_cond_wait\fR
or
\fBpthread_cond_timed_wait\fRis not locked all up in tha time tha signal is sent\&. Right back up in yo muthafuckin ass. Sendin a signal without holdin a lock on tha associated mutex be a cold-ass lil common programmin error which can cause subtle race conditions n' unpredictable behavior\&. There exist some uncommon synchronization patterns however where it is safe ta bust a signal without holdin a lock on tha associated mutex\&.
.RE
.PP
\fB\-\-segment\-merging=<yes|no> [default: yes]\fR
.RS 4
Controls segment merging\&. Right back up in yo muthafuckin ass. Segment mergin be a algorithm ta limit memory usage of tha data race detection algorithm\&. Disablin segment mergin may improve tha accuracy of tha so\-called \*(Aqother segments\*(Aq displayed up in race reports but can also trigger a outta memory error\&.
.RE
.PP
\fB\-\-segment\-merging\-interval=<n> [default: 10]\fR
.RS 4
Perform segment mergin only afta tha specified number of freshly smoked up segments done been pimped\&. This be a advanced configuration option dat allows ta chizzle whether ta minimize DRD\*(Aqs memory usage by choosin a low value or ta let DRD run fasta by choosin a slightly higher value\&. Da optimal value fo' dis parameta dependz on tha program bein analyzed\&. Da default value works well fo' most programs\&.
.RE
.PP
\fB\-\-shared\-threshold=<n> [default: off]\fR
.RS 4
Print a error message if a reader lock has been held longer than tha specified time (in milliseconds)\&. This option enablez tha detection of lock contention\&.
.RE
.PP
\fB\-\-show\-confl\-seg=<yes|no> [default: yes]\fR
.RS 4
Show conflictin segments up in race reports\&. Right back up in yo muthafuckin ass. Since dis shiznit can help ta find tha cause of a thugged-out data race, dis option is enabled by default\&. Disablin dis option make tha output of DRD mo' compact\&.
.RE
.PP
\fB\-\-show\-stack\-usage=<yes|no> [default: no]\fR
.RS 4
Print stack usage at thread exit time\&. When a program creates a big-ass number of threadz it becomes blingin ta limit tha amount of virtual memory allocated fo' thread stacks\&. This option make it possible ta observe how tha fuck much stack memory has been used by each thread of tha client program\&. Note: tha DRD tool itself allocates some temporary data on tha client thread stack\&. Da space necessary fo' dis temporary data must be allocated by tha client program when it allocates stack memory yo, but aint included up in stack usage reported by DRD\&.
.RE
.PP
\fB\-\-trace\-addr=<address> [default: none]\fR
.RS 4
Trace all load n' store activitizzle fo' tha specified address\&. This option may be specified mo' than once\&.
.RE
.PP
\fB\-\-ptrace\-addr=<address> [default: none]\fR
.RS 4
Trace all load n' store activitizzle fo' tha specified address n' keep bustin dat even afta tha memory at dat address has been freed n' reallocated\&.
.RE
.PP
\fB\-\-trace\-alloc=<yes|no> [default: no]\fR
.RS 4
Trace all memory allocations n' deallocations\&. May produce a big-ass amount of output\&.
.RE
.PP
\fB\-\-trace\-barrier=<yes|no> [default: no]\fR
.RS 4
Trace all barrier activity\&.
.RE
.PP
\fB\-\-trace\-cond=<yes|no> [default: no]\fR
.RS 4
Trace all condizzle variable activity\&.
.RE
.PP
\fB\-\-trace\-fork\-join=<yes|no> [default: no]\fR
.RS 4
Trace all thread creation n' all thread termination events\&.
.RE
.PP
\fB\-\-trace\-hb=<yes|no> [default: no]\fR
.RS 4
Trace execution of the
ANNOTATE_HAPPENS_BEFORE(),
ANNOTATE_HAPPENS_AFTER()
and
ANNOTATE_HAPPENS_DONE()
client requests\&.
.RE
.PP
\fB\-\-trace\-mutex=<yes|no> [default: no]\fR
.RS 4
Trace all mutex activity\&.
.RE
.PP
\fB\-\-trace\-rwlock=<yes|no> [default: no]\fR
.RS 4
Trace all reader\-writa lock activity\&.
.RE
.PP
\fB\-\-trace\-semaphore=<yes|no> [default: no]\fR
.RS 4
Trace all semaphore activity\&.
.RE
.SH "MASSIF OPTIONS"
.PP
\fB\-\-heap=<yes|no> [default: yes] \fR
.RS 4
Specifies whether heap profilin should be done\&.
.RE
.PP
\fB\-\-heap\-admin=<size> [default: 8] \fR
.RS 4
If heap profilin is enabled, gives tha number of administratizzle bytes per block ta use\&. This should be a estimate of tha average, since it may vary\&. For example, tha allocator used by glibc on Linux requires somewhere between 4 ta 15 bytes per block, dependin on various factors\&. That allocator also requires admin space fo' freed blocks yo, but Massif cannot account fo' this\&.
.RE
.PP
\fB\-\-stacks=<yes|no> [default: no] \fR
.RS 4
Specifies whether stack profilin should be done\&. This option slows Massif down pimped outly, n' so is off by default\&. Note dat Massif assumes dat tha main stack has size zero at start\-up\&. This aint true yo, but bustin otherwise accurately is difficult\&. Furthermore, startin at zero betta indicates tha size of tha part of tha main stack dat a user program straight-up has control over\&.
.RE
.PP
\fB\-\-pages\-as\-heap=<yes|no> [default: no] \fR
.RS 4
Tells Massif ta flava memory all up in tha page level rather than all up in tha malloc\*(Aqd block level\&. Right back up in yo muthafuckin ass. See above fo' details\&.
.RE
.PP
\fB\-\-depth=<number> [default: 30] \fR
.RS 4
Maximum depth of tha allocation trees recorded fo' detailed snapshots\&. Increasin it will make Massif run somewhat mo' slowly, use mo' memory, n' produce bigger output files\&.
.RE
.PP
\fB\-\-alloc\-fn=<name> \fR
.RS 4
Functions specified wit dis option is ghon be treated as though they was a heap allocation function such as
\fBmalloc\fR\&. This is useful fo' functions dat is wrappers to
\fBmalloc\fR
or
\fBnew\fR, which can fill up tha allocation trees wit uninterestin shiznit\&. This option can be specified multiple times on tha command line, ta name multiple functions\&.
.sp
Note dat tha named function will only be treated dis way if it is tha top entry up in a stack trace, or just below another function treated dis way\&. For example, if you gotz a gangbangin' function
\fBmalloc1\fR
that wraps
\fBmalloc\fR, and
\fBmalloc2\fR
that wraps
\fBmalloc1\fR, just specifying
\fB\-\-alloc\-fn=malloc2\fR
will have no effect\&. Yo ass need ta specify
\fB\-\-alloc\-fn=malloc1\fR
as well\&. This be a lil inconvenient yo, but tha reason is dat checkin fo' allocation functions is slow, n' it saves a shitload of time if Massif can stop lookin all up in tha stack trace entries as soon as it findz one dat don\*(Aqt match rather than havin ta continue all up in all tha entries\&.
.sp
Note dat C++ names is demangled\&. Note also dat overloaded C++ names must be freestyled up in full\&. Right back up in yo muthafuckin ass. Single quotes may be necessary ta prevent tha shell from breakin dem up\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-alloc\-fn=\*(Aqoperator new(unsigned, std::nothrow_t const&)\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\fB\-\-ignore\-fn=<name> \fR
.RS 4
Any direct heap allocation (i\&.e\&. a cold-ass lil call to
\fBmalloc\fR,
\fBnew\fR, etc, or a cold-ass lil call ta a gangbangin' function named by an
\fB\-\-alloc\-fn\fR
option) dat occurs up in a gangbangin' function specified by dis option is ghon be ignored\&. This is mostly useful fo' testin purposes\&. This option can be specified multiple times on tha command line, ta name multiple functions\&.
.sp
Any
\fBrealloc\fR
of a ignored block will also be ignored, even if the
\fBrealloc\fR
call do not occur up in a ignored function\&. This avoidz tha possibilitizzle of wack heap sizes if ignored blocks is shrunk with
\fBrealloc\fR\&.
.sp
Da rulez fo' freestylin C++ function names is tha same as for
\fB\-\-alloc\-fn\fR
above\&.
.RE
.PP
\fB\-\-threshold=<m\&.n> [default: 1\&.0] \fR
.RS 4
Da significizzle threshold fo' heap allocations, as a cementage of total memory size\& fo' realz. Allocation tree entries dat account fo' less than dis is ghon be aggregated\&. Note dat dis should be specified up in tandem wit ms_print\*(Aqs option of tha same name\&.
.RE
.PP
\fB\-\-peak\-inaccuracy=<m\&.n> [default: 1\&.0] \fR
.RS 4
Massif do not necessarily record tha actual global memory allocation peak; by default it recordz a peak only when tha global memory allocation size exceedz tha previous peak by at least 1\&.0%\&. This is cuz there can be nuff local allocation peaks along tha way, n' bustin a thugged-out detailed snapshot fo' every last muthafuckin one would be high-rollin' n' wasteful, as all but one of dem is ghon be lata discarded\&. This inaccuracy can be chizzled (even ta 0\&.0%) via dis option yo, but Massif will run drastically slower as tha number approaches zero\&.
.RE
.PP
\fB\-\-time\-unit=<i|ms|B> [default: i] \fR
.RS 4
Da time unit used fo' tha profiling\&. There is three possibilities: instructions executed (i), which is phat fo' most cases; real (wallclock) time (ms, i\&.e\&. milliseconds), which is sometimes useful; n' bytes allocated/deallocated on tha heap and/or stack (B), which is useful fo' straight-up short\-run programs, n' fo' testin purposes, cuz it is da most thugged-out reproducible across different machines\&.
.RE
.PP
\fB\-\-detailed\-freq=<n> [default: 10] \fR
.RS 4
Frequency of detailed snapshots\&. With
\fB\-\-detailed\-freq=1\fR, every last muthafuckin snapshot is detailed\&.
.RE
.PP
\fB\-\-max\-snapshots=<n> [default: 100] \fR
.RS 4
Da maximum number of snapshots recorded\&. If set ta N, fo' all programs except straight-up short\-runnin ones, tha final number of snapshots is ghon be between N/2 n' N\&.
.RE
.PP
\fB\-\-massif\-out\-file=<file> [default: massif\&.out\&.%p] \fR
.RS 4
Write tha flava data to
file
rather than ta tha default output file,
massif\&.out\&.<pid>\&. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used ta embed tha process ID and/or tha contentz of a environment variable up in tha name, as is tha case fo' tha core option
\fB--log-file\fR\&.
.RE
.SH "SGCHECK OPTIONS"
.PP
There is no SGCheck\-specific command\-line options at present\&.
.SH "BBV OPTIONS"
.PP
\fB\-\-bb\-out\-file=<name> [default: bb\&.out\&.%p] \fR
.RS 4
This option selects tha name of tha basic block vector file\&. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used ta embed tha process ID and/or tha contentz of a environment variable up in tha name, as is tha case fo' tha core option
\fB--log-file\fR\&.
.RE
.PP
\fB\-\-pc\-out\-file=<name> [default: pc\&.out\&.%p] \fR
.RS 4
This option selects tha name of tha PC file\&. This file holdz program counta addresses n' function name info fo' tha various basic blocks\&. This can be used up in conjunction wit tha basic block vector file ta fast\-forward via function names instead of just instruction counts\&. The
\fB%p\fR
and
\fB%q\fR
format specifiers can be used ta embed tha process ID and/or tha contentz of a environment variable up in tha name, as is tha case fo' tha core option
\fB--log-file\fR\&.
.RE
.PP
\fB\-\-interval\-size=<number> [default: 100000000] \fR
.RS 4
This option selects tha size of tha interval ta use\&. Da default is 100 mazillion instructions, which be a cold-ass lil commonly used value\&. Other sizes can be used; smalla intervals can help programs wit finer\-grained phases\& yo. However smalla interval size can lead ta accuracy thangs cuz of warm\-up effects (When fast\-forwardin tha various architectural features is ghon be un\-initialized, n' it will take some number of instructions before they "warm up" ta tha state a gangbangin' full simulation would be at without tha fast\-forwarding\&. Big-Ass interval sizes tend ta mitigate this\&.)
.RE
.PP
\fB\-\-instr\-count\-only [default: no] \fR
.RS 4
This option  drops some lyrics ta tha tool ta only display instruction count totals, n' ta not generate tha actual basic block vector file\&. This is useful fo' debugging, n' fo' gatherin instruction count info without generatin tha big-ass basic block vector files\&.
.RE
.SH "LACKEY OPTIONS"
.PP
\fB\-\-basic\-counts=<no|yes> [default: yes] \fR
.RS 4
When enabled, Lackey prints tha followin statistics n' shiznit bout tha execution of tha client program:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Da number of calls ta tha function specified by the
\fB\-\-fnname\fR
option (the default is
main)\&. If tha program has had its symbols stripped, tha count will always be zero\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Da number of conditionizzle branches encountered n' tha number n' proportion of dem taken\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Da number of superblocks entered n' completed by tha program\&. Note dat cuz of optimisations done by tha JIT, dis aint at all a accurate value\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Da number of hommie (x86, amd64, ppc, etc\&.) instructions n' IR statements executed\&. IR is Valgrind\*(Aqs RISC\-like intermediate representation via which all instrumentation is done\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
Ratios between a shitload of these counts\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
Da exit code of tha client program\&.
.RE
.RE
.PP
\fB\-\-detailed\-counts=<no|yes> [default: no] \fR
.RS 4
When enabled, Lackey prints a table containin countz of loads, stores n' ALU operations, differentiated by they IR types\&. Da IR types is identified by they IR name ("I1", "I8", \&.\&.\&. "I128", "F32", "F64", n' "V128")\&.
.RE
.PP
\fB\-\-trace\-mem=<no|yes> [default: no] \fR
.RS 4
When enabled, Lackey prints tha size n' address of almost every last muthafuckin memory access made by tha program\&. Right back up in yo muthafuckin ass. See tha comments all up in tha top of tha file
lackey/lk_main\&.c
for details bout tha output format, how tha fuck it works, n' inaccuracies up in tha address trace\&. Note dat dis option produces immense amountz of output\&.
.RE
.PP
\fB\-\-trace\-superblocks=<no|yes> [default: no] \fR
.RS 4
When enabled, Lackey prints up tha address of every last muthafuckin superblock (a single entry, multiple exit, linear chunk of code) executed by tha program\&. This is primarily of interest ta Valgrind pimpers\&. Right back up in yo muthafuckin ass. See tha comments all up in tha top of tha file
lackey/lk_main\&.c
for details bout tha output format\&. Note dat dis option produces big-ass amountz of output\&.
.RE
.PP
\fB\-\-fnname=<name> [default: main] \fR
.RS 4
Changes tha function fo' which calls is counted when
\fB\-\-basic\-counts=yes\fR
is specified\&.
.RE
.SH "SEE ALSO"
.PP
cg_annotate(1), callgrind_annotate(1), callgrind_control(1), ms_print(1),
$INSTALL/share/doc/valgrind/html/index\&.html
or
http://www\&.valgrind\&.org/docs/manual/index\&.html,
\m[blue]\fBDebuggin yo' program rockin Valgrind\*(Aqs gdbserver n' GDB\fR\m[]\&\s-2\u[1]\d\s+2\m[blue]\fBvgdb\fR\m[]\&\s-2\u[2]\d\s+2,
\m[blue]\fBValgrind monitor commands\fR\m[]\&\s-2\u[3]\d\s+2,
\m[blue]\fBDa Commentary\fR\m[]\&\s-2\u[4]\d\s+2,
\m[blue]\fBSchedulin n' Multi\-Thread Performance\fR\m[]\&\s-2\u[5]\d\s+2,
\m[blue]\fBCachegrind: a cold-ass lil cache n' branch\-prediction profiler\fR\m[]\&\s-2\u[6]\d\s+2\&.
.SH "AUTHOR"
.PP
Da Valgrind pimpers\&.
.PP
This manpage was freestyled by Andres Roldan <aroldan@debian\&.org> n' tha Valgrind pimpers\&.
.SH "NOTES"
.IP " 1." 4
Debuggin yo' program rockin Valgrindz gdbserver n' GDB
.RS 4
\%http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.gdbserver
.RE
.IP " 2." 4
vgdb
.RS 4
\%http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.vgdb
.RE
.IP " 3." 4
Valgrind monitor commands
.RS 4
\%http://www.valgrind.org/docs/manual/manual-core-adv.html#manual-core-adv.valgrind-monitor-commands
.RE
.IP " 4." 4
Da Commentary
.RS 4
\%http://www.valgrind.org/docs/manual/manual-core.html#manual-core.comment
.RE
.IP " 5." 4
Schedulin n' Multi-Thread Performance
.RS 4
\%http://www.valgrind.org/docs/manual/manual-core.html#manual-core.pthreads_perf_sched
.RE
.IP " 6." 4
Cachegrind: a cold-ass lil cache n' branch-prediction profiler
.RS 4
\%http://www.valgrind.org/docs/manual/cg-manual.html
.RE
