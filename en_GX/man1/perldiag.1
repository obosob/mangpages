.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDIAG 1"
.TH PERLDIAG 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldiag \- various Perl diagnostics
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These lyrics is classified as bigs up (listed up in increasin order of
desperation):
.PP
.Vb 7
\&    (W) A warnin (optional).
\&    (D) A deprecation (enabled by default).
\&    (S) A severe warnin (enabled by default).
\&    (F) A fatal error (trappable).
\&    (P) An internal error you should never peep (trappable).
\&    (X) A straight-up fatal error (nontrappable).
\&    (A) An alien error message (not generated by Perl).
.Ve
.PP
Da majoritizzle of lyrics from tha straight-up original gangsta three classifications above
(W, D & S) can be controlled rockin tha \f(CW\*(C`warnings\*(C'\fR pragma.
.PP
If a message can be controlled by tha \f(CW\*(C`warnings\*(C'\fR pragma, its warning
category is included wit tha classification letta up in tha description
below.  E.g. \f(CW\*(C`(W closed)\*(C'\fR means a warnin up in tha \f(CW\*(C`closed\*(C'\fR category.
.PP
Optionizzle warnings is enabled by rockin tha \f(CW\*(C`warnings\*(C'\fR pragma or tha \fB\-w\fR
and \fB\-W\fR switches.  Warnings may be captured by settin \f(CW$SIG{_\|_WARN_\|_}\fR
to a reference ta a routine dat is ghon be called on each warnin instead
of printin dat shit.  See perlvar.
.PP
Severe warnings is always enabled, unless they is explicitly disabled
with tha \f(CW\*(C`warnings\*(C'\fR pragma or tha \fB\-X\fR switch.
.PP
Trappable errors may be trapped rockin tha eval operator. Shiiit, dis aint no joke.  See
\&\*(L"eval\*(R" up in perlfunc.  In almost all cases, warnings may be selectively
disabled or promoted ta fatal errors rockin tha \f(CW\*(C`warnings\*(C'\fR pragma.
See warnings.
.PP
Da lyrics is up in alphabetical order, without regard ta upper or
lower-case.  Some of these lyrics is generic.  Spots dat vary are
denoted wit a \f(CW%s\fR or other printf-style escape.  These escapes are
ignored by tha alphabetical order, as is all charactas other than
letters.  To look up yo' message, just ignore anythang dat aint a
letter.
.ie n .IP "\fIaccept()\fR on closed socket %s" 4
.el .IP "\fIaccept()\fR on closed socket \f(CW%s\fR" 4
.IX Item "accept() on closed socket %s"
(W closed) Yo ass tried ta do a accept on a cold-ass lil closed socket.  Did yo dirty ass forget
to check tha return value of yo' \fIsocket()\fR call?  See
\&\*(L"accept\*(R" up in perlfunc.
.ie n .IP "Allocation too large: %x" 4
.el .IP "Allocation too large: \f(CW%x\fR" 4
.IX Item "Allocation too large: %x"
(X) Yo ass can't allocate mo' than 64K on a MS-DOS machine.
.ie n .IP "'%c' allowed only afta types %s" 4
.el .IP "'%c' allowed only afta types \f(CW%s\fR" 4
.IX Item "'%c' allowed only afta types %s"
(F) Da modifiers '!', '<' n' '>' is allowed up in \fIpack()\fR or \fIunpack()\fR only
afta certain types.  See \*(L"pack\*(R" up in perlfunc.
.IP "Ambiguous call resolved as CORE::%s(), qualify as such or use &" 4
.IX Item "Ambiguous call resolved as CORE::%s(), qualify as such or use &"
(W ambiguous) A subroutine you have declared has tha same ol' dirty name as a Perl
keyword, n' you have used tha name without qualification fo' calling
one or tha other n' shit.  Perl decided ta booty-call tha builtin cuz the
subroutine aint imported.
.Sp
To force interpretation as a subroutine call, either put a ampersand
before tha subroutine name, or qualify tha name wit its package.
Alternatively, you can import tha subroutine (or pretend dat it's
imported wit tha \f(CW\*(C`use subs\*(C'\fR pragma).
.Sp
To silently interpret it as tha Perl operator, use tha \f(CW\*(C`CORE::\*(C'\fR prefix
on tha operator (e.g. \f(CW\*(C`CORE::log($x)\*(C'\fR) or declare tha subroutine
to be a object method (see \*(L"Subroutine Attributes\*(R" up in perlsub or
attributes).
.IP "Ambiguous range up in transliteration operator" 4
.IX Item "Ambiguous range up in transliteration operator"
(F) Yo ass freestyled suttin' like \f(CW\*(C`tr/a\-z\-0//\*(C'\fR which don't mean anythang at
all.  To include a \f(CW\*(C`\-\*(C'\fR characta up in a transliteration, put it either
first or last.  (In tha past, \f(CW\*(C`tr/a\-z\-0//\*(C'\fR was synonymous with
\&\f(CW\*(C`tr/a\-y//\*(C'\fR, which was probably not what tha fuck you would have expected.)
.ie n .IP "Ambiguous use of %s resolved as %s" 4
.el .IP "Ambiguous use of \f(CW%s\fR resolved as \f(CW%s\fR" 4
.IX Item "Ambiguous use of %s resolved as %s"
(S ambiguous) Yo ass holla'd suttin' dat may not be interpreted tha way
you thought.  Normally itz pretty easy as fuck  ta disambiguate it by supplying
a missin quote, operator, parenthesis pair or declaration.
.ie n .IP "Ambiguous use of %c resolved as operator %c" 4
.el .IP "Ambiguous use of \f(CW%c\fR resolved as operator \f(CW%c\fR" 4
.IX Item "Ambiguous use of %c resolved as operator %c"
(S ambiguous) \f(CW\*(C`%\*(C'\fR, \f(CW\*(C`&\*(C'\fR, n' \f(CW\*(C`*\*(C'\fR is both infix operators (modulus,
bitwise and, n' multiplication) \fIand\fR initial special characters
(denotin hashes, subroutines n' typeglobs), n' you holla'd something
like \f(CW\*(C`*foo * foo\*(C'\fR dat might be interpreted as either of em.  We
assumed you meant tha infix operator yo, but please try ta make it more
clear \*(-- up in tha example given, you might write \f(CW\*(C`*foo * foo()\*(C'\fR if you
really meant ta multiply a glob by tha result of callin a gangbangin' function.
.ie n .IP "Ambiguous use of %c{%s} resolved ta %c%s" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s} resolved ta \f(CW%c\fR%s" 4
.IX Item "Ambiguous use of %c{%s} resolved ta %c%s"
(W ambiguous) Yo ass freestyled suttin' like \f(CW\*(C`@{foo}\*(C'\fR, which might be
askin fo' tha variable \f(CW@foo\fR, or it might be callin a gangbangin' function
named foo, n' dereferencin it as a array reference.  If you wanted
the variable, you can just write \f(CW@foo\fR.  If you wanted ta booty-call the
function, write \f(CW\*(C`@{foo()}\*(C'\fR ... or you could just not gotz a variable
and a gangbangin' function wit tha same name, n' save yo ass a shitload of shit.
.ie n .IP "Ambiguous use of %c{%s[...]} resolved ta %c%s[...]" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s[...]} resolved ta \f(CW%c\fR%s[...]" 4
.IX Item "Ambiguous use of %c{%s[...]} resolved ta %c%s[...]"
.PD 0
.ie n .IP "Ambiguous use of %c{%s{...}} resolved ta %c%s{...}" 4
.el .IP "Ambiguous use of \f(CW%c\fR{%s{...}} resolved ta \f(CW%c\fR%s{...}" 4
.IX Item "Ambiguous use of %c{%s{...}} resolved ta %c%s{...}"
.PD
(W ambiguous) Yo ass freestyled suttin' like \f(CW\*(C`${foo[2]}\*(C'\fR (where foo represents
the name of a Perl keyword), which might be lookin fo' element number
2 of tha array named \f(CW@foo\fR, up in which case please write \f(CW$foo[2]\fR, or you
might have meant ta pass a anonymous arrayref ta tha function named
foo, n' then do a scalar deref on tha value it returns.  If you meant
that, write \f(CW\*(C`${foo([2])}\*(C'\fR.
.Sp
In regular expressions, tha \f(CW\*(C`${foo[2]}\*(C'\fR syntax is sometimes necessary
to disambiguate between array subscripts n' characta classes.
\&\f(CW\*(C`/$length[2345]/\*(C'\fR, fo' instance, is ghon be interpreted as \f(CW$length\fR followed
by tha characta class \f(CW\*(C`[2345]\*(C'\fR.  If a array subscript is what tha fuck you
want, you can avoid tha warnin by changin \f(CW\*(C`/${length[2345]}/\*(C'\fR ta the
unsightly \f(CW\*(C`/${\e$length[2345]}/\*(C'\fR, by renamin yo' array ta something
that do not coincizzle wit a funky-ass built-in keyword, or by simply turning
off warnings wit \f(CW\*(C`no warnings \*(Aqambiguous\*(Aq;\*(C'\fR.
.IP "Ambiguous use of \-%s resolved as \-&%s()" 4
.IX Item "Ambiguous use of -%s resolved as -&%s()"
(S ambiguous) Yo ass freestyled suttin' like \f(CW\*(C`\-foo\*(C'\fR, which might be the
strin \f(CW"\-foo"\fR, or a cold-ass lil call ta tha function \f(CW\*(C`foo\*(C'\fR, negated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you meant
the string, just write \f(CW"\-foo"\fR.  If you meant tha function call,
write \f(CW\*(C`\-foo()\*(C'\fR.
.IP "'|' n' '<' may not both be specified on command line" 4
.IX Item "'|' n' '<' may not both be specified on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' found dat \s-1STDIN\s0 was a pipe, n' dat you also tried to
redirect \s-1STDIN\s0 rockin '<'.  Only one \s-1STDIN\s0 stream ta a cold-ass lil hustla, please.
.IP "'|' n' '>' may not both be specified on command line" 4
.IX Item "'|' n' '>' may not both be specified on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' be thinkin you tried ta redirect stdout both ta a gangbangin' file and
into a pipe ta another command. Y'all KNOW dat shit, muthafucka!  Yo ass need ta chizzle one or tha other,
though nothingz stoppin you from pipin tha fuck into a program or Perl script
which 'splits' output tha fuck into two streams, such as
.Sp
.Vb 6
\&    open(OUT,">$ARGV[0]") or take a thugged-out dirtnap "Can\*(Aqt write ta $ARGV[0]: $!";
\&    while (<STDIN>) {
\&        print;
\&        print OUT;
\&    }
\&    close OUT;
.Ve
.ie n .IP "Applyin %s ta %s will act on scalar(%s)" 4
.el .IP "Applyin \f(CW%s\fR ta \f(CW%s\fR will act on scalar(%s)" 4
.IX Item "Applyin %s ta %s will act on scalar(%s)"
(W misc) Da pattern match (\f(CW\*(C`//\*(C'\fR), substitution (\f(CW\*(C`s///\*(C'\fR), and
transliteration (\f(CW\*(C`tr///\*(C'\fR) operators work on scalar joints, n' you can put dat on yo' toast.  If you apply
one of dem ta a array or a hash, it will convert tha array or hash to
a scalar value (the length of a array, or tha population info of a
hash) n' then work on dat scalar value.  This is probably not what
you meant ta do.  See \*(L"grep\*(R" up in perlfunc n' \*(L"map\*(R" up in perlfunc for
alternatives.
.IP "Arg too short fo' msgsnd" 4
.IX Item "Arg too short fo' msgsnd"
(F) \fImsgsnd()\fR requires a strang at least as long as sizeof(long).
.ie n .IP "%s argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or a subroutine" 4
.el .IP "\f(CW%s\fR argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or a subroutine" 4
.IX Item "%s argument aint a HASH or ARRAY element or a subroutine"
(F) Da argument ta \fIexists()\fR must be a hash or array element or a
subroutine wit a ampersand, such as:
.Sp
.Vb 3
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
\&    &do_something
.Ve
.ie n .IP "%s argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or slice" 4
.el .IP "\f(CW%s\fR argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or slice" 4
.IX Item "%s argument aint a HASH or ARRAY element or slice"
(F) Da argument ta \fIdelete()\fR must be either a hash or array element,
such as:
.Sp
.Vb 2
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
.Ve
.Sp
or a hash or array slice, such as:
.Sp
.Vb 2
\&    @foo[$bar, $baz, $xyzzy]
\&    @{$ref\->[12]}{"susie", "queue"}
.Ve
.ie n .IP "%s argument aint a subroutine name" 4
.el .IP "\f(CW%s\fR argument aint a subroutine name" 4
.IX Item "%s argument aint a subroutine name"
(F) Da argument ta \fIexists()\fR fo' \f(CW\*(C`exists &sub\*(C'\fR must be a subroutine
name, n' not a subroutine call.  \f(CW\*(C`exists &sub()\*(C'\fR will generate this
error.
.ie n .IP "Argument ""%s"" aint numeric%s" 4
.el .IP "Argument ``%s'' aint numeric%s" 4
.IX Item "Argument %s aint numeric%s"
(W numeric) Da indicated strang was fed as a argument ta a operator
that expected a numeric value instead. Y'all KNOW dat shit, muthafucka!  If you fortunate tha message
will identify which operator was so unfortunate.
.ie n .IP "Argument list not closed fo' PerlIO layer ""%s""" 4
.el .IP "Argument list not closed fo' PerlIO layer ``%s''" 4
.IX Item "Argument list not closed fo' PerlIO layer %s"
(W layer) When pushin a layer wit arguments onto tha Perl I/O
system you forgot tha ) dat closes tha argument list.  (Layers
take care of transformin data between external n' internal
representations.)  Perl stopped parsin tha layer list at this
point n' did not attempt ta push dis layer n' shit.  If yo' program
didn't explicitly request tha failin operation, it may be the
result of tha value of tha environment variable \s-1PERLIO.\s0
.ie n .IP "Array @%s missin tha @ up in argument %d of %s()" 4
.el .IP "Array @%s missin tha @ up in argument \f(CW%d\fR of %s()" 4
.IX Item "Array @%s missin tha @ up in argument %d of %s()"
(D deprecated) Straight-Up oldschool Perl let you omit tha @ on array names up in some
spots, n' you can put dat on yo' toast.  This is now heavily deprecated.
.IP "A sequence of multiple spaces up in a cold-ass lil charnames alias definizzle is deprecated" 4
.IX Item "A sequence of multiple spaces up in a cold-ass lil charnames alias definizzle is deprecated"
(D) Yo ass defined a cold-ass lil characta name which had multiple space charactas in
a row.  Chizzle dem ta single spaces.  Usually these names is defined
in tha \f(CW\*(C`:alias\*(C'\fR import argument ta \f(CW\*(C`use charnames\*(C'\fR yo, but they could be
defined by a translator installed tha fuck into \f(CW$^H{charnames}\fR.  See
\&\*(L"\s-1CUSTOM ALIASES\*(R"\s0 up in charnames.
.ie n .IP "assertion botched: %s" 4
.el .IP "assertion botched: \f(CW%s\fR" 4
.IX Item "assertion botched: %s"
(X) Da malloc package dat comes wit Perl had a internal failure.
.ie n .IP "Assertion failed: file ""%s""" 4
.el .IP "Assertion failed: file ``%s''" 4
.IX Item "Assertion failed: file %s"
(X) A general assertion failed. Y'all KNOW dat shit, muthafucka!  Da file up in question must be examined.
.IP "Assignin non-zero ta $[ is no longer possible" 4
.IX Item "Assignin non-zero ta $[ is no longer possible"
(F) When tha \*(L"array_base\*(R" feature is disabled (e.g., under \f(CW\*(C`use v5.16;\*(C'\fR)
the special variable \f(CW$[\fR, which is deprecated, is now a gangbangin' fixed zero value.
.IP "Assignment ta both a list n' a scalar" 4
.IX Item "Assignment ta both a list n' a scalar"
(F) If you assign ta a cold-ass lil conditionizzle operator, tha 2nd n' 3rd arguments
must either both be scalars or both be lists, n' you can put dat on yo' toast.  Otherwise Perl won't
know which context ta supply ta tha right side.
.ie n .IP "A thread exited while %d threadz was hustlin" 4
.el .IP "A thread exited while \f(CW%d\fR threadz was hustlin" 4
.IX Item "A thread exited while %d threadz was hustlin"
(W threads)(S) When rockin threaded Perl, a thread (not necessarily
the main thread) exited while there was still other threadz hustlin.
Usually itz a phat scam first ta collect tha return jointz of the
created threadz by joinin them, n' only then ta exit from tha main
thread. Y'all KNOW dat shit, muthafucka!  See threads.
.IP "Attempt ta access disallowed key '%s' up in a restricted hash" 4
.IX Item "Attempt ta access disallowed key '%s' up in a restricted hash"
(F) Da failin code has attempted ta git or set a key which aint in
the current set of allowed keyz of a restricted hash.
.IP "Attempt ta bless tha fuck into a reference" 4
.IX Item "Attempt ta bless tha fuck into a reference"
(F) Da \s-1CLASSNAME\s0 argument ta tha \fIbless()\fR operator is sposed ta fuckin be
the name of tha package ta bless tha resultin object into.  You've
supplied instead a reference ta something: like you wrote
.Sp
.Vb 1
\&    bless $self, $proto;
.Ve
.Sp
when you intended
.Sp
.Vb 1
\&    bless $self, ref($proto) || $proto;
.Ve
.Sp
If you straight-up wanna bless tha fuck into tha stringified version
of tha reference supplied, you need ta stringify it yo ass, for
example by:
.Sp
.Vb 1
\&    bless $self, "$proto";
.Ve
.IP "Attempt ta clear deleted array" 4
.IX Item "Attempt ta clear deleted array"
(S debugging) An array was assigned ta when dat shiznit was bein freed.
Freed joints is not supposed ta be visible ta Perl code.  This
can also happen if \s-1XS\s0 code calls \f(CW\*(C`av_clear\*(C'\fR from a cold-ass lil custom magic
callback on tha array.
.IP "Attempt ta delete disallowed key '%s' from a restricted hash" 4
.IX Item "Attempt ta delete disallowed key '%s' from a restricted hash"
(F) Da failin code attempted ta delete from a restricted hash a key
which aint up in its key set.
.IP "Attempt ta delete readonly key '%s' from a restricted hash" 4
.IX Item "Attempt ta delete readonly key '%s' from a restricted hash"
(F) Da failin code attempted ta delete a key whose value has been
declared readonly from a restricted hash.
.IP "Attempt ta free non-arena \s-1SV:\s0 0x%x" 4
.IX Item "Attempt ta free non-arena SV: 0x%x"
(S internal) All \s-1SV\s0 objects is supposed ta be allocated from arenas
that is ghon be garbage collected on exit.  An \s-1SV\s0 was discovered ta be
outside any of dem arenas.
.IP "Attempt ta free nonexistent shared strang '%s'%s" 4
.IX Item "Attempt ta free nonexistent shared strang '%s'%s"
(S internal) Perl maintains a reference-counted internal table of
strings ta optimize tha storage n' access of hash keys n' other
strings.  This indicates one of mah thugs tried ta decrement tha reference count
of a strang dat can no longer be found up in tha table.
.IP "Attempt ta free temp prematurely: \s-1SV\s0 0x%x" 4
.IX Item "Attempt ta free temp prematurely: SV 0x%x"
(S debugging) Mortalized joints is supposed ta be freed by the
\&\fIfree_tmps()\fR routine.  This indicates dat suttin' else is freein the
\&\s-1SV\s0 before tha \fIfree_tmps()\fR routine gets a cold-ass lil chance, which means dat the
\&\fIfree_tmps()\fR routine is ghon be freein a unreferenced scalar when it do
try ta free dat shit.
.IP "Attempt ta free unreferenced glob pointers" 4
.IX Item "Attempt ta free unreferenced glob pointers"
(S internal) Da reference counts gots screwed up on symbol aliases.
.IP "Attempt ta free unreferenced scalar: \s-1SV\s0 0x%x" 4
.IX Item "Attempt ta free unreferenced scalar: SV 0x%x"
(S internal) Perl went ta decrement tha reference count of a scalar to
see if it would git all up in 0, n' discovered dat it had already gone ta 0
earlier, n' should done been freed, n' up in fact, probably was freed.
This could indicate dat \fISvREFCNT_dec()\fR was called too nuff times, or
that \fISvREFCNT_inc()\fR was called too few times, or dat tha \s-1SV\s0 was
mortalized when it shouldn't have been, or dat memory has been
corrupted.
.IP "Attempt ta join self" 4
.IX Item "Attempt ta join self"
(F) Yo ass tried ta join a thread from within itself, which be an
impossible task.  Yo ass may be joinin tha wack thread, or you may need
to move tha \fIjoin()\fR ta some other thread.
.IP "Attempt ta pack pointa ta temporary value" 4
.IX Item "Attempt ta pack pointa ta temporary value"
(W pack) Yo ass tried ta pass a temporary value (like tha result of a
function, or a cold-ass lil computed expression) ta tha \*(L"p\*(R" \fIpack()\fR template.  This
means tha result gotz nuff a pointa ta a location dat could become
invalid anytime, even before tha end of tha current statement.  Use
literals or global joints as arguments ta tha \*(L"p\*(R" \fIpack()\fR template to
avoid dis warning.
.ie n .IP "Attempt ta reload %s aborted." 4
.el .IP "Attempt ta reload \f(CW%s\fR aborted." 4
.IX Item "Attempt ta reload %s aborted."
(F) Yo ass tried ta load a gangbangin' file wit \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR dat failed to
compile once already.  Perl aint gonna try ta compile dis file again
unless you delete its entry from \f(CW%INC\fR.  See \*(L"require\*(R" up in perlfunc and
\&\*(L"%INC\*(R" up in perlvar.
.IP "Attempt ta set length of freed array" 4
.IX Item "Attempt ta set length of freed array"
(W misc) Yo ass tried ta set tha length of a array which has
been freed. Y'all KNOW dat shit, muthafucka!  Yo ass can do dis by storin a reference ta the
scalar representin tha last index of a array n' later
assignin all up in dat reference.  For example
.Sp
.Vb 2
\&    $r = do {my @a; \e$#a};
\&    $$r = 503
.Ve
.IP "Attempt ta use reference as lvalue up in substr" 4
.IX Item "Attempt ta use reference as lvalue up in substr"
(W substr) Yo ass supplied a reference as tha straight-up original gangsta argument ta \fIsubstr()\fR
used as a lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See \*(L"substr\*(R" up in perlfunc.
.ie n .IP "Attribute ""locked"" is deprecated" 4
.el .IP "Attribute ``locked'' is deprecated" 4
.IX Item "Attribute locked is deprecated"
(D deprecated) Yo ass have used tha attributes pragma ta modify the
\&\*(L"locked\*(R" attribute on a cold-ass lil code reference.  Da :locked attribute is
obsolete, has had no effect since 5005 threadz was removed, and
will be removed up in a gangbangin' future release of Perl 5.
.ie n .IP "Attribute ""unique"" is deprecated" 4
.el .IP "Attribute ``unique'' is deprecated" 4
.IX Item "Attribute unique is deprecated"
(D deprecated) Yo ass have used tha attributes pragma ta modify
the \*(L"unique\*(R" attribute on a array, hash or scalar reference.
Da :unique attribute has had no effect since Perl 5.8.8, and
will be removed up in a gangbangin' future release of Perl 5.
.IP "av_reify called on tied array" 4
.IX Item "av_reify called on tied array"
(S debugging) This indicates dat suttin' went wack n' Perl gots \fIvery\fR
confused bout \f(CW@_\fR or \f(CW@DB::args\fR bein tied.
.ie n .IP "Wack arg length fo' %s, is %u, should be %d" 4
.el .IP "Wack arg length fo' \f(CW%s\fR, is \f(CW%u\fR, should be \f(CW%d\fR" 4
.IX Item "Wack arg length fo' %s, is %u, should be %d"
(F) Yo ass passed a funky-ass buffer of tha wack size ta one of \fImsgctl()\fR, \fIsemctl()\fR
or \fIshmctl()\fR.  In C parlance, tha erect sizes are, respectively,
sizeof(struct\ msqid_ds\ *), sizeof(struct\ semid_ds\ *), and
sizeof(struct\ shmid_ds\ *).
.IP "Wack evalled substitution pattern" 4
.IX Item "Wack evalled substitution pattern"
(F) You've used tha \f(CW\*(C`/e\*(C'\fR switch ta evaluate tha replacement fo' a
substitution yo, but perl found a syntax error up in tha code ta evaluate,
most likely a unexpected right brace '}'.
.ie n .IP "Wack filehandle: %s" 4
.el .IP "Wack filehandle: \f(CW%s\fR" 4
.IX Item "Wack filehandle: %s"
(F) A symbol was passed ta suttin' wantin a gangbangin' filehandle yo, but the
symbol has no filehandle associated wit dat shit.  Perhaps you didn't do an
\&\fIopen()\fR, or done did it up in another package.
.IP "Wack \fIfree()\fR ignored" 4
.IX Item "Wack free() ignored"
(S malloc) An internal routine called \fIfree()\fR on suttin' dat had never
been \fImalloc()\fRed up in tha straight-up original gangsta place.  Mandatory yo, but can be disabled by
settin environment variable \f(CW\*(C`PERL_BADFREE\*(C'\fR ta 0.
.Sp
This message can be peeped like often wit DB_File on systems wit \*(L"hard\*(R"
dynamic linking, like \f(CW\*(C`AIX\*(C'\fR n' \f(CW\*(C`OS/2\*(C'\fR.  It be a funky-ass bug of \f(CW\*(C`Berkeley DB\*(C'\fR
which is left unnoticed if \f(CW\*(C`DB\*(C'\fR uses \fIforgiving\fR system \fImalloc()\fR.
.IP "Wack hash" 4
.IX Item "Wack hash"
(P) One of tha internal hash routines was passed a null \s-1HV\s0 pointer.
.IP "Badly placed ()'s" 4
.IX Item "Badly placed ()'s"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead
of Perl.  Peep tha #! line, or manually feed yo' script into
Perl yo ass.
.ie n .IP "Wack name afta %s" 4
.el .IP "Wack name afta \f(CW%s\fR" 4
.IX Item "Wack name afta %s"
(F) Yo ass started ta name a symbol by rockin a package prefix, n' then
didn't finish tha symbol.  In particular, you can't interpolate outside
of quotes, so
.Sp
.Vb 2
\&    $var = \*(Aqmyvar\*(Aq;
\&    $sym = mypack::$var;
.Ve
.Sp
is not tha same as
.Sp
.Vb 2
\&    $var = \*(Aqmyvar\*(Aq;
\&    $sym = "mypack::$var";
.Ve
.IP "Wack plugin affectin keyword '%s'" 4
.IX Item "Wack plugin affectin keyword '%s'"
(F) An extension rockin tha keyword plugin mechanizzle violated the
plugin \s-1API.\s0
.IP "Wack \fIrealloc()\fR ignored" 4
.IX Item "Wack realloc() ignored"
(S malloc) An internal routine called \fIrealloc()\fR on suttin' that
had never been \fImalloc()\fRed up in tha straight-up original gangsta place.  Mandatory yo, but can
be disabled by settin tha environment variable \f(CW\*(C`PERL_BADFREE\*(C'\fR ta 1.
.IP "Wack symbol fo' array" 4
.IX Item "Wack symbol fo' array"
(P) An internal request axed ta add a array entry ta suttin' that
wasn't a symbol table entry.
.IP "Wack symbol fo' dirhandle" 4
.IX Item "Wack symbol fo' dirhandle"
(P) An internal request axed ta add a gangbangin' finger-lickin' dirhandle entry ta something
that wasn't a symbol table entry.
.IP "Wack symbol fo' filehandle" 4
.IX Item "Wack symbol fo' filehandle"
(P) An internal request axed ta add a gangbangin' filehandle entry ta something
that wasn't a symbol table entry.
.IP "Wack symbol fo' hash" 4
.IX Item "Wack symbol fo' hash"
(P) An internal request axed ta add a hash entry ta suttin' that
wasn't a symbol table entry.
.IP "Bareword found up in conditional" 4
.IX Item "Bareword found up in conditional"
(W bareword) Da compila found a funky-ass bareword where it expected a
conditional, which often indicates dat a || or && was parsed as part
of tha last argument of tha previous construct, fo' example:
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.Sp
It may also indicate a misspelled constant dat has been interpreted as
a bareword:
.Sp
.Vb 2
\&    use constant TYPO => 1;
\&    if (TYOP) { print "foo" }
.Ve
.Sp
Da \f(CW\*(C`strict\*(C'\fR pragma is useful up in avoidin such errors.
.ie n .IP "Bareword ""%s"" not allowed while ""strict subs"" up in use" 4
.el .IP "Bareword ``%s'' not allowed while ``strict subs'' up in use" 4
.IX Item "Bareword %s not allowed while strict subs up in use"
(F) With \*(L"strict subs\*(R" up in use, a funky-ass bareword is only allowed as a
subroutine identifier, up in curly brackets or ta tha left of tha \*(L"=>\*(R"
symbol.  Perhaps you need ta predeclare a subroutine?
.ie n .IP "Bareword ""%s"" refers ta nonexistent package" 4
.el .IP "Bareword ``%s'' refers ta nonexistent package" 4
.IX Item "Bareword %s refers ta nonexistent package"
(W bareword) Yo ass used a qualified bareword of tha form \f(CW\*(C`Foo::\*(C'\fR yo, but the
compila saw no other usez of dat namespace before dat point.  Perhaps
you need ta predeclare a package?
.IP "\s-1BEGIN\s0 failed\*(--compilation aborted" 4
.IX Item "BEGIN failedcompilation aborted"
(F) An untrapped exception was raised while executin a \s-1BEGIN\s0
subroutine.  Compilation stops immediately n' tha interpreta is
exited.
.IP "\s-1BEGIN\s0 not safe afta errors\*(--compilation aborted" 4
.IX Item "BEGIN not safe afta errorscompilation aborted"
(F) Perl found a \f(CW\*(C`BEGIN {}\*(C'\fR subroutine (or a \f(CW\*(C`use\*(C'\fR directive, which
implies a \f(CW\*(C`BEGIN {}\*(C'\fR) afta one or mo' compilation errors had already
occurred. Y'all KNOW dat shit, muthafucka!  Since tha intended environment fo' tha \f(CW\*(C`BEGIN {}\*(C'\fR could not
be guaranteed (due ta tha errors), n' since subsequent code likely
dependz on its erect operation, Perl just gave up.
.ie n .IP "\e1 betta freestyled as $1" 4
.el .IP "\e1 betta freestyled as \f(CW$1\fR" 4
.IX Item "1 betta freestyled as $1"
(W syntax) Outside of patterns, backreferences live on as variables.
Da use of backslashes is grandfathered on tha right-hand side of a
substitution yo, but stylistically itz betta ta use tha variable form
because other Perl programmers will expect it, n' it works betta if
there is mo' than 9 backreferences.
.IP "Binary number > 0b11111111111111111111111111111111 non-portable" 4
.IX Item "Binary number > 0b11111111111111111111111111111111 non-portable"
(W portable) Da binary number you specified is larger than 2**32\-1
(4294967295) n' therefore non-portable between systems.  See
perlport fo' mo' on portabilitizzle concerns.
.ie n .IP "\fIbind()\fR on closed socket %s" 4
.el .IP "\fIbind()\fR on closed socket \f(CW%s\fR" 4
.IX Item "bind() on closed socket %s"
(W closed) Yo ass tried ta do a funky-ass bind on a cold-ass lil closed socket.  Did yo dirty ass forget to
check tha return value of yo' \fIsocket()\fR call?  See \*(L"bind\*(R" up in perlfunc.
.ie n .IP "\fIbinmode()\fR on closed filehandle %s" 4
.el .IP "\fIbinmode()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "binmode() on closed filehandle %s"
(W unopened) Yo ass tried \fIbinmode()\fR on a gangbangin' filehandle dat was never opened.
Peep yo' control flow n' number of arguments.
.ie n .IP """\eb{"" is deprecated; use ""\eb\e{"" or ""\eb[{]"" instead up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "``\eb{'' is deprecated; use ``\eb\e{'' or ``\eb[{]'' instead up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "b{ is deprecated; use b{ or b[{] instead up in regex; marked by <-- HERE up in m/%s/"
.PD 0
.ie n .IP """\eB{"" is deprecated; use ""\eB\e{"" or ""\eB[{]"" instead up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "``\eB{'' is deprecated; use ``\eB\e{'' or ``\eB[{]'' instead up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "B{ is deprecated; use B{ or B[{] instead up in regex; marked by <-- HERE up in m/%s/"
.PD
(W deprecated) Use of a unescaped \*(L"{\*(R" immediately followin a
\&\f(CW\*(C`\eb\*(C'\fR or \f(CW\*(C`\eB\*(C'\fR is now deprecated so as ta reserve its use fo' Perl
itself up in a gangbangin' future release.  Yo ass can either precede tha brace wit a
backslash, or enclose it up in square brackets; tha latta is tha way ta go
if tha pattern delimitas is \f(CW\*(C`{}\*(C'\fR.
.IP "Bit vector size > 32 non-portable" 4
.IX Item "Bit vector size > 32 non-portable"
(W portable) Usin bit vector sizes larger than 32 is non-portable.
.ie n .IP "Bizarre copy of %s" 4
.el .IP "Bizarre copy of \f(CW%s\fR" 4
.IX Item "Bizarre copy of %s"
(P) Perl detected a attempt ta copy a internal value dat is not
copiable.
.ie n .IP "Buffer overflow up in prime_env_iter: %s" 4
.el .IP "Buffer overflow up in prime_env_iter: \f(CW%s\fR" 4
.IX Item "Buffer overflow up in prime_env_iter: %s"
(W internal) A warnin peculiar ta \s-1VMS. \s0 While Perl was preparin to
iterate over \f(CW%ENV\fR, it encountered a logical name or symbol definition
which was too long, so dat shiznit was truncated ta tha strang shown.
.IP "Bizarre SvTYPE [%d]" 4
.IX Item "Bizarre SvTYPE [%d]"
(P) When startin a freshly smoked up thread or return joints from a thread, Perl
encountered a invalid data type.
.IP "Callback called exit" 4
.IX Item "Callback called exit"
(F) A subroutine invoked from a external package via \fIcall_sv()\fR
exited by callin exit.
.IP "%s() called too early ta check prototype" 4
.IX Item "%s() called too early ta check prototype"
(W prototype) You've called a gangbangin' function dat has a prototype before the
parser saw a thugged-out definizzle or declaration fo' it, n' Perl could not check
that tha call conforms ta tha prototype.  Yo ass need ta either add an
early prototype declaration fo' tha subroutine up in question, or move the
subroutine definizzle ahead of tha call ta git proper prototype
checking.  Alternatively, if yo ass is certain dat you callin the
function erectly, you may put a ampersand before tha name ta avoid
the warning.  See perlsub.
.IP "Cannot compress integer up in pack" 4
.IX Item "Cannot compress integer up in pack"
(F) An argument ta pack(\*(L"w\*(R",...) was too big-ass ta compress.  Da \s-1BER\s0
compressed integer format can only be used wit positizzle integers, n' you
attempted ta compress Infinitizzle or a straight-up big-ass number (> 1e308).
See \*(L"pack\*(R" up in perlfunc.
.IP "Cannot compress wack numbers up in pack" 4
.IX Item "Cannot compress wack numbers up in pack"
(F) An argument ta pack(\*(L"w\*(R",...) was negative.  Da \s-1BER\s0 compressed integer
format can only be used wit positizzle integers.  See \*(L"pack\*(R" up in perlfunc.
.ie n .IP "Cannot convert a reference ta %s ta typeglob" 4
.el .IP "Cannot convert a reference ta \f(CW%s\fR ta typeglob" 4
.IX Item "Cannot convert a reference ta %s ta typeglob"
(F) Yo ass manipulated Perlz symbol table directly, stored a reference
in it, then tried ta access dat symbol via conventionizzle Perl syntax.
Da access triggers Perl ta autovivify dat typeglob yo, but it there is
no legal conversion from dat type of reference ta a typeglob.
.ie n .IP "Cannot copy ta %s" 4
.el .IP "Cannot copy ta \f(CW%s\fR" 4
.IX Item "Cannot copy ta %s"
(P) Perl detected a attempt ta copy a value ta a internal type dat cannot
be directly assigned to.
.ie n .IP "Cannot find encodin ""%s""" 4
.el .IP "Cannot find encodin ``%s''" 4
.IX Item "Cannot find encodin %s"
(S io) Yo ass tried ta apply a encodin dat did not exist ta a gangbangin' filehandle,
either wit \fIopen()\fR or \fIbinmode()\fR.
.ie n .IP "Cannot set tied @DB::args" 4
.el .IP "Cannot set tied \f(CW@DB::args\fR" 4
.IX Item "Cannot set tied @DB::args"
(F) \f(CW\*(C`caller\*(C'\fR tried ta set \f(CW@DB::args\fR yo, but found it tied. Y'all KNOW dat shit, muthafucka!  Tyin \f(CW@DB::args\fR
is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Before dis error was added, it used ta crash.)
.IP "Cannot tie unreifiable array" 4
.IX Item "Cannot tie unreifiable array"
(P) Yo ass somehow managed ta booty-call \f(CW\*(C`tie\*(C'\fR on a array dat do not
keep a reference count on its arguments n' cannot be made to
do so.  Such arrays is not even supposed ta be accessible to
Perl code yo, but is only used internally.
.IP "Can only compress unsigned integers up in pack" 4
.IX Item "Can only compress unsigned integers up in pack"
(F) An argument ta pack(\*(L"w\*(R",...) was not a integer n' shit.  Da \s-1BER\s0 compressed
integer format can only be used wit positizzle integers, n' you attempted
to compress suttin' else.  See \*(L"pack\*(R" up in perlfunc.
.IP "Can't bless non-reference value" 4
.IX Item "Can't bless non-reference value"
(F) Only hard references may be pimped. Y'all KNOW dat shit, muthafucka!  This is how tha fuck Perl \*(L"enforces\*(R"
encapsulation of objects, n' you can put dat on yo' toast.  See perlobj.
.ie n .IP "Can't ""break"" up in a loop topicalizer" 4
.el .IP "Can't ``break'' up in a loop topicalizer" 4
.IX Item "Can't break up in a loop topicalizer"
(F) Yo ass called \f(CW\*(C`break\*(C'\fR yo, but you up in a \f(CW\*(C`foreach\*(C'\fR block rather than
a \f(CW\*(C`given\*(C'\fR block.  Yo ass probably meant ta use \f(CW\*(C`next\*(C'\fR or \f(CW\*(C`last\*(C'\fR.
.ie n .IP "Can't ""break"" outside a given block" 4
.el .IP "Can't ``break'' outside a given block" 4
.IX Item "Can't break outside a given block"
(F) Yo ass called \f(CW\*(C`break\*(C'\fR yo, but you not inside a \f(CW\*(C`given\*(C'\fR block.
.ie n .IP "Can't call method ""%s"" on a undefined value" 4
.el .IP "Can't call method ``%s'' on a undefined value" 4
.IX Item "Can't call method %s on a undefined value"
(F) Yo ass used tha syntax of a method call yo, but tha slot filled by the
object reference or package name gotz nuff a undefined value.  Something
like dis will reproduce tha error:
.Sp
.Vb 3
\&    $BADREF = undef;
\&    process $BADREF 1,2,3;
\&    $BADREF\->process(1,2,3);
.Ve
.ie n .IP "Can't call method ""%s"" on unblessed reference" 4
.el .IP "Can't call method ``%s'' on unblessed reference" 4
.IX Item "Can't call method %s on unblessed reference"
(F) A method call must know up in what tha fuck package itz supposed ta run. I aint talkin' bout chicken n' gravy biatch.  It
ordinarily findz dis up from tha object reference you supply yo, but you
didn't supply a object reference up in dis case.  A reference aint an
object reference until it has been pimped. Y'all KNOW dat shit, muthafucka!  See perlobj.
.ie n .IP "Can't call method ""%s"" without a package or object reference" 4
.el .IP "Can't call method ``%s'' without a package or object reference" 4
.IX Item "Can't call method %s without a package or object reference"
(F) Yo ass used tha syntax of a method call yo, but tha slot filled by the
object reference or package name gotz nuff a expression dat returns a
defined value which is neither a object reference nor a package name.
Somethang like dis will reproduce tha error:
.Sp
.Vb 3
\&    $BADREF = 42;
\&    process $BADREF 1,2,3;
\&    $BADREF\->process(1,2,3);
.Ve
.ie n .IP "Can't chdir ta %s" 4
.el .IP "Can't chdir ta \f(CW%s\fR" 4
.IX Item "Can't chdir ta %s"
(F) Yo ass called \f(CW\*(C`perl \-x/foo/bar\*(C'\fR yo, but \fI/foo/bar\fR aint a gangbangin' finger-lickin' directory
that you can chdir to, possibly cuz it don't exist.
.ie n .IP "Can't check filesystem of script ""%s"" fo' nosuid" 4
.el .IP "Can't check filesystem of script ``%s'' fo' nosuid" 4
.IX Item "Can't check filesystem of script %s fo' nosuid"
(P) For some reason you can't check tha filesystem of tha script for
nosuid.
.ie n .IP "Can't coerce %s ta %s up in %s" 4
.el .IP "Can't coerce \f(CW%s\fR ta \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "Can't coerce %s ta %s up in %s"
(F) Certain typez of SVs, up in particular real symbol table entries
(typeglobs), can't be forced ta stop bein what tha fuck they are.  So you can't
say thangs like:
.Sp
.Vb 1
\&    *foo += 1;
.Ve
.Sp
Yo ass \s-1CAN\s0 say
.Sp
.Vb 2
\&    $foo = *foo;
\&    $foo += 1;
.Ve
.Sp
but then \f(CW$foo\fR no longer gotz nuff a glob.
.ie n .IP "Can't ""continue"" outside a when block" 4
.el .IP "Can't ``continue'' outside a when block" 4
.IX Item "Can't continue outside a when block"
(F) Yo ass called \f(CW\*(C`continue\*(C'\fR yo, but you not inside a \f(CW\*(C`when\*(C'\fR
or \f(CW\*(C`default\*(C'\fR block.
.IP "Can't create pipe mailbox" 4
.IX Item "Can't create pipe mailbox"
(P) An error peculiar ta \s-1VMS. \s0 Da process is sufferin from exhausted
quotas or other plumbin problems.
.ie n .IP "Can't declare %s up in ""%s""" 4
.el .IP "Can't declare \f(CW%s\fR up in ``%s''" 4
.IX Item "Can't declare %s up in %s"
(F) Only scalar, array, n' hash variablez may be declared as \*(L"my\*(R", \*(L"our\*(R" or
\&\*(L"state\*(R" variables.  They must have ordinary identifiers as names.
.ie n .IP "Can't ""default"" outside a topicalizer" 4
.el .IP "Can't ``default'' outside a topicalizer" 4
.IX Item "Can't default outside a topicalizer"
(F) Yo ass have used a \f(CW\*(C`default\*(C'\fR block dat is neither inside a
\&\f(CW\*(C`foreach\*(C'\fR loop nor a \f(CW\*(C`given\*(C'\fR block.  (Note dat dis error is
issued on exit from tha \f(CW\*(C`default\*(C'\fR block, so you won't git the
error if you use a explicit \f(CW\*(C`continue\*(C'\fR.)
.ie n .IP "Can't do inplace edit: %s aint a regular file" 4
.el .IP "Can't do inplace edit: \f(CW%s\fR aint a regular file" 4
.IX Item "Can't do inplace edit: %s aint a regular file"
(S inplace) Yo ass tried ta use tha \fB\-i\fR switch on a special file, such as
a file up in /dev, a \s-1FIFO\s0 or a uneditable directory.  Da file was ignored.
.ie n .IP "Can't do inplace edit on %s: %s" 4
.el .IP "Can't do inplace edit on \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Can't do inplace edit on %s: %s"
(S inplace) Da creation of tha freshly smoked up file failed fo' tha indicated
reason.
.IP "Can't do inplace edit without backup" 4
.IX Item "Can't do inplace edit without backup"
(F) Yo ass is on a system like fuckin MS-DOS dat gets trippin if you try
readin from a thugged-out deleted (but still opened) file.  Yo ass gotta say
\&\f(CW\*(C`\-i.bak\*(C'\fR, or some such.
.ie n .IP "Can't do inplace edit: %s would not be unique" 4
.el .IP "Can't do inplace edit: \f(CW%s\fR would not be unique" 4
.IX Item "Can't do inplace edit: %s would not be unique"
(S inplace) Yo crazy-ass filesystem do not support filenames longer than 14
charactas n' Perl was unable ta create a unique filename during
inplace editin wit tha \fB\-i\fR switch.  Da file was ignored.
.IP "Can't do waitpid wit flags" 4
.IX Item "Can't do waitpid wit flags"
(F) This machine aint gots either \fIwaitpid()\fR or \fIwait4()\fR, so only
\&\fIwaitpid()\fR without flags is emulated.
.IP "Can't emulate \-%s on #! line" 4
.IX Item "Can't emulate -%s on #! line"
(F) Da #! line specifies a switch dat don't make sense at this
point.  For example, it'd be kind of wack-ass ta put a \fB\-x\fR on tha #!
line.
.ie n .IP "Can't %s %s\-endian %ss on dis platform" 4
.el .IP "Can't \f(CW%s\fR \f(CW%s\fR\-endian \f(CW%ss\fR on dis platform" 4
.IX Item "Can't %s %s-endian %ss on dis platform"
(F) Yo crazy-ass platformz byte-order is neither big-endian nor lil-endian,
or it has a straight-up strange pointa size.  Packin n' unpackin big\- or
lil-endian floatin point joints n' pointas may not be possible.
See \*(L"pack\*(R" up in perlfunc.
.ie n .IP "Can't exec ""%s"": %s" 4
.el .IP "Can't exec ``%s'': \f(CW%s\fR" 4
.IX Item "Can't exec %s: %s"
(W exec) A \fIsystem()\fR, \fIexec()\fR, or piped open call could not execute the
named program fo' tha indicated reason. I aint talkin' bout chicken n' gravy biatch.  Typical reasons include: the
permissions was wack on tha file, tha file wasn't found in
\&\f(CW$ENV{PATH}\fR, tha executable up in question was compiled fo' another
architecture, or tha #! line up in a script points ta a interpreta that
can't be run fo' similar reasons.  (Or maybe yo' system don't support
#! at all.)
.ie n .IP "Can't exec %s" 4
.el .IP "Can't exec \f(CW%s\fR" 4
.IX Item "Can't exec %s"
(F) Perl was tryin ta execute tha indicated program fo' you cuz
thatz what tha fuck tha #! line holla'd. Y'all KNOW dat shit, muthafucka!  If thatz not what tha fuck you wanted, you may
need ta mention \*(L"perl\*(R" on tha #! line somewhere.
.ie n .IP "Can't execute %s" 4
.el .IP "Can't execute \f(CW%s\fR" 4
.IX Item "Can't execute %s"
(F) Yo ass used tha \fB\-S\fR switch yo, but tha copiez of tha script ta execute
found up in tha \s-1PATH\s0 did not have erect permissions.
.ie n .IP "Can't find a opnumber fo' ""%s""" 4
.el .IP "Can't find a opnumber fo' ``%s''" 4
.IX Item "Can't find a opnumber fo' %s"
(F) A strang of a gangbangin' form \f(CW\*(C`CORE::word\*(C'\fR was given ta \fIprototype()\fR yo, but there
is no builtin wit tha name \f(CW\*(C`word\*(C'\fR.
.ie n .IP "Can't find %s characta property ""%s""" 4
.el .IP "Can't find \f(CW%s\fR characta property ``%s''" 4
.IX Item "Can't find %s characta property %s"
(F) Yo ass used \f(CW\*(C`\ep{}\*(C'\fR or \f(CW\*(C`\eP{}\*(C'\fR but tha characta property by dat name
could not be found. Y'all KNOW dat shit, muthafucka!  Maybe you misspelled tha name of tha property?
See \*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops
for a cold-ass lil complete list of available straight-up legit properties.
.ie n .IP "Can't find label %s" 4
.el .IP "Can't find label \f(CW%s\fR" 4
.IX Item "Can't find label %s"
(F) Yo ass holla'd ta goto a label dat aint mentioned anywhere dat it's
possible fo' our asses ta go to.  See \*(L"goto\*(R" up in perlfunc.
.ie n .IP "Can't find %s on \s-1PATH\s0" 4
.el .IP "Can't find \f(CW%s\fR on \s-1PATH\s0" 4
.IX Item "Can't find %s on PATH"
(F) Yo ass used tha \fB\-S\fR switch yo, but tha script ta execute could not be
found up in tha \s-1PATH.\s0
.ie n .IP "Can't find %s on \s-1PATH, \s0'.' not up in \s-1PATH\s0" 4
.el .IP "Can't find \f(CW%s\fR on \s-1PATH, \s0'.' not up in \s-1PATH\s0" 4
.IX Item "Can't find %s on PATH, '.' not up in PATH"
(F) Yo ass used tha \fB\-S\fR switch yo, but tha script ta execute could not be
found up in tha \s-1PATH,\s0 or at least not wit tha erect permissions.  The
script exists up in tha current directory yo, but \s-1PATH\s0 prohibits hustlin dat shit.
.ie n .IP "Can't find strang terminator %s anywhere before \s-1EOF\s0" 4
.el .IP "Can't find strang terminator \f(CW%s\fR anywhere before \s-1EOF\s0" 4
.IX Item "Can't find strang terminator %s anywhere before EOF"
(F) Perl strings can stretch over multiple lines.  This message means
that tha closin delimita was omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Because bracketed quotes count
nestin levels, tha followin is missin its final parenthesis:
.Sp
.Vb 1
\&    print q(Da characta \*(Aq(\*(Aq starts a side comment.);
.Ve
.Sp
If you gettin dis error from a here-document, you may have
included unseen whitespace before or afta yo' closin tag or there
may not be a linebreak afta dat shit.  A phat programmerz editor will have
a way ta help you find these charactas (or lack of characters).  See
perlop fo' tha full details on here-documents.
.ie n .IP "Can't find Unicode property definizzle ""%s""" 4
.el .IP "Can't find Unicode property definizzle ``%s''" 4
.IX Item "Can't find Unicode property definizzle %s"
(F) Yo ass may have tried ta use \f(CW\*(C`\ep\*(C'\fR which means a Unicode
property (for example \f(CW\*(C`\ep{Lu}\*(C'\fR matches all uppercase
letters).  If you did mean ta bust a Unicode property, see
\&\*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops
for a cold-ass lil complete list of available properties. Put ya muthafuckin choppers up if ya feel dis!  If you didn't
mean ta bust a Unicode property, escape tha \f(CW\*(C`\ep\*(C'\fR, either by
\&\f(CW\*(C`\e\ep\*(C'\fR (just tha \f(CW\*(C`\ep\*(C'\fR) or by \f(CW\*(C`\eQ\ep\*(C'\fR (the rest of tha string, or
until \f(CW\*(C`\eE\*(C'\fR).
.ie n .IP "Can't fork: %s" 4
.el .IP "Can't fork: \f(CW%s\fR" 4
.IX Item "Can't fork: %s"
(F) A fatal error occurred while tryin ta fork while openin a
pipeline.
.IP "Can't fork, tryin again n' again n' again up in 5 seconds" 4
.IX Item "Can't fork, tryin again n' again n' again up in 5 seconds"
(W pipe) A fork up in a piped open failed wit \s-1EAGAIN\s0 n' is ghon be retried
afta five seconds.
.IP "Can't git filespec \- stale stat buffer?" 4
.IX Item "Can't git filespec - stale stat buffer?"
(S) A warnin peculiar ta \s-1VMS. \s0 This arises cuz of tha difference
between access checks under \s-1VMS\s0 n' under tha Unix model Perl assumes.
Under \s-1VMS,\s0 access checks is done by filename, rather than by bits in
the stat buffer, so dat ACLs n' other protections can be taken into
account.  Unfortunately, Perl assumes dat tha stat buffer gotz nuff all
the necessary shiznit, n' passes it, instead of tha filespec, to
the access-checkin routine.  It will try ta retrieve tha filespec using
the thang name n' \s-1FID\s0 present up in tha stat buffer yo, but dis works only
if you aint done cooked up a subsequent call ta tha \s-1CRTL\s0 \fIstat()\fR routine,
because tha thang name is overwritten wit each call.  If dis warning
appears, tha name lookup failed, n' tha access-checkin routine gave up
and returned \s-1FALSE,\s0 just ta be conservative.  (Note: Da access-checking
routine knows bout tha Perl \f(CW\*(C`stat\*(C'\fR operator n' file tests, so you
shouldn't eva peep dis warnin up in response ta a Perl command; it arises
only if some internal code takes stat buffers lightly.)
.IP "Can't git pipe mailbox thang name" 4
.IX Item "Can't git pipe mailbox thang name"
(P) An error peculiar ta \s-1VMS. \s0 Afta bustin a mailbox ta act as a
pipe, Perl can't retrieve its name fo' lata use.
.IP "Can't git \s-1SYSGEN\s0 parameta value fo' \s-1MAXBUF\s0" 4
.IX Item "Can't git SYSGEN parameta value fo' MAXBUF"
(P) An error peculiar ta \s-1VMS. \s0 Perl axed \f(CW$GETSYI\fR how tha fuck big-ass you want your
mailbox buffers ta be, n' didn't git a answer.
.ie n .IP "Can't ""goto"" tha fuck into tha middle of a gangbangin' foreach loop" 4
.el .IP "Can't ``goto'' tha fuck into tha middle of a gangbangin' foreach loop" 4
.IX Item "Can't goto tha fuck into tha middle of a gangbangin' foreach loop"
(F) A \*(L"goto\*(R" statement was executed ta jump tha fuck into tha middle of a gangbangin' foreach
loop.  Yo ass can't git there from here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  See \*(L"goto\*(R" up in perlfunc.
.ie n .IP "Can't ""goto"" outta a pseudo block" 4
.el .IP "Can't ``goto'' outta a pseudo block" 4
.IX Item "Can't goto outta a pseudo block"
(F) A \*(L"goto\*(R" statement was executed ta jump outta what tha fuck might look like
a block, except dat it aint a proper block.  This probably occurs if
you tried ta jump outta a \fIsort()\fR block or subroutine, which be a no-no.
See \*(L"goto\*(R" up in perlfunc.
.IP "Can't goto subroutine from a sort sub (or similar callback)" 4
.IX Item "Can't goto subroutine from a sort sub (or similar callback)"
(F) Da \*(L"goto subroutine\*(R" call can't be used ta jump outta the
comparison sub fo' a \fIsort()\fR, or from a similar callback (such
as tha \fIreduce()\fR function up in List::Util).
.IP "Can't goto subroutine from a eval\-%s" 4
.IX Item "Can't goto subroutine from a eval-%s"
(F) Da \*(L"goto subroutine\*(R" call can't be used ta jump outta a eval
\&\*(L"string\*(R" or block.
.IP "Can't goto subroutine outside a subroutine" 4
.IX Item "Can't goto subroutine outside a subroutine"
(F) Da deeply magical \*(L"goto subroutine\*(R" call can only replace one
subroutine call fo' another n' shit.  It can't manufacture one outta whole
cloth.  In general you should be callin it outta only a \s-1AUTOLOAD\s0
routine anyway.  See \*(L"goto\*(R" up in perlfunc.
.IP "Can't ignore signal \s-1CHLD,\s0 forcin ta default" 4
.IX Item "Can't ignore signal CHLD, forcin ta default"
(W signal) Perl has detected dat it is bein run wit tha \s-1SIGCHLD\s0
signal (sometimes known as \s-1SIGCLD\s0) disabled. Y'all KNOW dat shit, muthafucka!  Since disablin this
signal will interfere wit proper determination of exit statuz of child
processes, Perl has reset tha signal ta its default value.  This
situation typically indicates dat tha parent program under which Perl
may be hustlin (e.g. cron) is bein straight-up careless.
.IP "Can't bust a cap up in a non-numeric process \s-1ID\s0" 4
.IX Item "Can't bust a cap up in a non-numeric process ID"
(F) Process identifiers must be (signed) integers.  It be a gangbangin' fatal error to
attempt ta \fIkill()\fR a undefined, empty-strin or otherwise non-numeric
process identifier.
.ie n .IP "Can't ""last"" outside a loop block" 4
.el .IP "Can't ``last'' outside a loop block" 4
.IX Item "Can't last outside a loop block"
(F) A \*(L"last\*(R" statement was executed ta break outta tha current block,
except dat there be a dis itty bitty problem called there aint a cold-ass lil current
block.  Note dat a \*(L"if\*(R" or \*(L"else\*(R" block don't count as a \*(L"loopish\*(R"
block, as don't a funky-ass block given ta \fIsort()\fR, \fImap()\fR or \fIgrep()\fR.  Yo ass can
usually double tha curlies ta git tha same effect though, cuz the
inner curlies is ghon be considered a funky-ass block dat loops once.  See
\&\*(L"last\*(R" up in perlfunc.
.IP "Can't linearize anonymous symbol table" 4
.IX Item "Can't linearize anonymous symbol table"
(F) Perl tried ta calculate tha method resolution order (\s-1MRO\s0) of a
package yo, but failed cuz tha package stash has no name.
.ie n .IP "Can't load '%s' fo' module %s" 4
.el .IP "Can't load '%s' fo' module \f(CW%s\fR" 4
.IX Item "Can't load '%s' fo' module %s"
(F) Da module you tried ta load failed ta load a thugged-out dynamic extension.
This may either mean dat you upgraded yo' version of perl ta one
that is incompatible wit yo' oldschool dynamic extensions (which is known
to happen between major versionz of perl), or (more likely) dat your
dynamic extension was built against a olda version of tha library
that is installed on yo' system.  Yo ass may need ta rebuild yo' old
dynamic extensions.
.ie n .IP "Can't localize lexical variable %s" 4
.el .IP "Can't localize lexical variable \f(CW%s\fR" 4
.IX Item "Can't localize lexical variable %s"
(F) Yo ass used local on a variable name dat was previously declared as a
lexical variable rockin \*(L"my\*(R" or \*(L"state\*(R".  This aint allowed. Y'all KNOW dat shit, muthafucka!  If you
wanna localize a package variable of tha same name, qualify it with
the package name.
.IP "Can't localize all up in a reference" 4
.IX Item "Can't localize all up in a reference"
(F) Yo ass holla'd suttin' like \f(CW\*(C`local $$ref\*(C'\fR, which Perl can't currently
handle, cuz when it goes ta restore tha oldschool value of whatever \f(CW$ref\fR
pointed ta afta tha scope of tha \fIlocal()\fR is finished, it can't be sure
that \f(CW$ref\fR will still be a reference.
.ie n .IP "Can't locate %s" 4
.el .IP "Can't locate \f(CW%s\fR" 4
.IX Item "Can't locate %s"
(F) Yo ass holla'd ta \f(CW\*(C`do\*(C'\fR (or \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR) a gangbangin' file dat couldn't be found.
Perl looks fo' tha file up in all tha locations mentioned up in \f(CW@INC\fR, unless
the file name included tha full path ta tha file.  Perhaps you need
to set tha \s-1PERL5LIB\s0 or \s-1PERL5OPT\s0 environment variable ta say where the
extra library is, or maybe tha script need ta add tha library name
to \f(CW@INC\fR.  Or maybe you just misspelled tha name of tha file.  See
\&\*(L"require\*(R" up in perlfunc n' lib.
.ie n .IP "Can't locate auto/%s.al up in @INC" 4
.el .IP "Can't locate auto/%s.al up in \f(CW@INC\fR" 4
.IX Item "Can't locate auto/%s.al up in @INC"
(F) A function (or method) was called up in a package which allows
autoload yo, but there is no function ta autoload. Y'all KNOW dat shit, muthafucka!  Most probable causes
are a misprint up in a gangbangin' function/method name or a gangbangin' failure ta \f(CW\*(C`AutoSplit\*(C'\fR
the file, say, by bustin \f(CW\*(C`make install\*(C'\fR.
.ie n .IP "Can't locate loadable object fo' module %s up in @INC" 4
.el .IP "Can't locate loadable object fo' module \f(CW%s\fR up in \f(CW@INC\fR" 4
.IX Item "Can't locate loadable object fo' module %s up in @INC"
(F) Da module you loaded is tryin ta load a external library, like
for example, \fIfoo.so\fR or \fIbar.dll\fR yo, but tha DynaLoader module was
unable ta locate dis library.  See DynaLoader.
.ie n .IP "Can't locate object method ""%s"" via package ""%s""" 4
.el .IP "Can't locate object method ``%s'' via package ``%s''" 4
.IX Item "Can't locate object method %s via package %s"
(F) Yo ass called a method erectly, n' it erectly indicated a package
functionin as a cold-ass lil class yo, but dat package don't define dat particular
method, nor do any of its base classes.  See perlobj.
.ie n .IP "Can't locate package %s fo' @%s::ISA" 4
.el .IP "Can't locate package \f(CW%s\fR fo' @%s::ISA" 4
.IX Item "Can't locate package %s fo' @%s::ISA"
(W syntax) Da \f(CW@ISA\fR array contained tha name of another package that
doesn't seem ta exist.
.IP "Can't locate PerlIO%s" 4
.IX Item "Can't locate PerlIO%s"
(F) Yo ass tried ta use up in \fIopen()\fR a PerlIO layer dat do not exist,
e.g. open(\s-1FH, \*(L"\s0>:nosuchlayer\*(R", \*(L"somefile\*(R").
.ie n .IP "Can't make list assignment ta %ENV on dis system" 4
.el .IP "Can't make list assignment ta \f(CW%ENV\fR on dis system" 4
.IX Item "Can't make list assignment ta %ENV on dis system"
(F) List assignment ta \f(CW%ENV\fR aint supported on some systems, notably
\&\s-1VMS.\s0
.ie n .IP "Can't make loaded symbols global on dis platform while loadin %s" 4
.el .IP "Can't make loaded symbols global on dis platform while loadin \f(CW%s\fR" 4
.IX Item "Can't make loaded symbols global on dis platform while loadin %s"
(W) A module passed tha flag 0x01 ta \fIDynaLoader::dl_load_file()\fR ta request
that symbols from tha stated file is made available globally within the
process yo, but dat functionalitizzle aint available on dis platform.  Whilst
the module likely will still work, dis may prevent tha perl interpreter
from loadin other XS-based extensions which need ta link directly to
functions defined up in tha C or \s-1XS\s0 code up in tha stated file.
.ie n .IP "Can't modify %s up in %s" 4
.el .IP "Can't modify \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "Can't modify %s up in %s"
(F) Yo ass aren't allowed ta assign ta tha item indicated, or otherwise try
to chizzle it, like fuckin wit a auto-increment.
.IP "Can't modify nonexistent substring" 4
.IX Item "Can't modify nonexistent substring"
(P) Da internal routine dat do assignment ta a \fIsubstr()\fR was handed
a \s-1NULL.\s0
.IP "Can't modify non-lvalue subroutine call" 4
.IX Item "Can't modify non-lvalue subroutine call"
(F) Subroutines meant ta be used up in lvalue context should be declared as
such.  See \*(L"Lvalue subroutines\*(R" up in perlsub.
.IP "Can't msgrcv ta read-only var" 4
.IX Item "Can't msgrcv ta read-only var"
(F) Da target of a msgrcv must be modifiable ta be used as a receive
buffer.
.ie n .IP "Can't ""next"" outside a loop block" 4
.el .IP "Can't ``next'' outside a loop block" 4
.IX Item "Can't next outside a loop block"
(F) A \*(L"next\*(R" statement was executed ta reiterate tha current block yo, but
there aint a cold-ass lil current block.  Note dat a \*(L"if\*(R" or \*(L"else\*(R" block don't
count as a \*(L"loopish\*(R" block, as don't a funky-ass block given ta \fIsort()\fR, \fImap()\fR or
\&\fIgrep()\fR.  Yo ass can probably double tha curlies ta git tha same effect
though, cuz tha inner curlies is ghon be considered a funky-ass block dat loops
once.  See \*(L"next\*(R" up in perlfunc.
.ie n .IP "Can't open %s" 4
.el .IP "Can't open \f(CW%s\fR" 4
.IX Item "Can't open %s"
(F) Yo ass tried ta run a perl built wit \s-1MAD\s0 support with
the \s-1PERL_XMLDUMP\s0 environment variable set yo, but tha file
named by dat variable could not be opened.
.ie n .IP "Can't open %s: %s" 4
.el .IP "Can't open \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Can't open %s: %s"
(S inplace) Da implicit openin of a gangbangin' file all up in use of tha \f(CW\*(C`<>\*(C'\fR
filehandle, either implicitly under tha \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR command-line
switches, or explicitly, failed fo' tha indicated reason. I aint talkin' bout chicken n' gravy biatch.  Usually
this is cuz you aint gots read permission fo' a gangbangin' file which
you named on tha command line.
.Sp
(F) Yo ass tried ta booty-call perl wit tha \fB\-e\fR switch yo, but \fI/dev/null\fR (or
your operatin systemz equivalent) could not be opened.
.IP "Can't open a reference" 4
.IX Item "Can't open a reference"
(W io) Yo ass tried ta open a scalar reference fo' readin or writing,
usin tha 3\-arg \fIopen()\fR syntax:
.Sp
.Vb 1
\&    open FH, \*(Aq>\*(Aq, $ref;
.Ve
.Sp
but yo' version of perl is compiled without perlio, n' dis form of
open aint supported.
.IP "Can't open bidirectionizzle pipe" 4
.IX Item "Can't open bidirectionizzle pipe"
(W pipe) Yo ass tried ta say \f(CW\*(C`open(CMD, "|cmd|")\*(C'\fR, which aint supported.
Yo ass can try any of nuff muthafuckin modulez up in tha Perl library ta do this, such
as IPC::Open2.  Alternately, direct tha pipez output ta a gangbangin' file using
\&\*(L">\*(R", n' then read it up in under a gangbangin' finger-lickin' different file handle.
.ie n .IP "Can't open error file %s as stderr" 4
.el .IP "Can't open error file \f(CW%s\fR as stderr" 4
.IX Item "Can't open error file %s as stderr"
(F) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' couldn't open tha file specified afta '2>' or '2>>' on
the command line fo' writing.
.ie n .IP "Can't open input file %s as stdin" 4
.el .IP "Can't open input file \f(CW%s\fR as stdin" 4
.IX Item "Can't open input file %s as stdin"
(F) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' couldn't open tha file specified afta '<' on the
command line fo' reading.
.ie n .IP "Can't open output file %s as stdout" 4
.el .IP "Can't open output file \f(CW%s\fR as stdout" 4
.IX Item "Can't open output file %s as stdout"
(F) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' couldn't open tha file specified afta '>' or '>>' on
the command line fo' writing.
.ie n .IP "Can't open output pipe (name: %s)" 4
.el .IP "Can't open output pipe (name: \f(CW%s\fR)" 4
.IX Item "Can't open output pipe (name: %s)"
(P) An error peculiar ta \s-1VMS. \s0 Perl do its own command line
redirection, n' couldn't open tha pipe tha fuck into which ta bust data destined
for stdout.
.ie n .IP "Can't open perl script ""%s"": %s" 4
.el .IP "Can't open perl script ``%s'': \f(CW%s\fR" 4
.IX Item "Can't open perl script %s: %s"
(F) Da script you specified can't be opened fo' tha indicated reason.
.Sp
If you debuggin a script dat uses #!, n' normally relies on the
shellz \f(CW$PATH\fR search, tha \-S option causes perl ta do dat search, so
you don't gotta type tha path or \f(CW\*(C`\`which $scriptname\`\*(C'\fR.
.IP "Can't read \s-1CRTL\s0 environ" 4
.IX Item "Can't read CRTL environ"
(S) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read a element of \f(CW%ENV\fR
from tha \s-1CRTL\s0z internal environment array n' discovered tha array was
missing.  Yo ass need ta figure up where yo' \s-1CRTL\s0 misplaced its environ
or define \fI\s-1PERL_ENV_TABLES\s0\fR (see perlvms) so dat environ is not
searched.
.ie n .IP "Can't ""redo"" outside a loop block" 4
.el .IP "Can't ``redo'' outside a loop block" 4
.IX Item "Can't redo outside a loop block"
(F) A \*(L"redo\*(R" statement was executed ta restart tha current block yo, but
there aint a cold-ass lil current block.  Note dat a \*(L"if\*(R" or \*(L"else\*(R" block don't
count as a \*(L"loopish\*(R" block, as don't a funky-ass block given ta \fIsort()\fR, \fImap()\fR
or \fIgrep()\fR.  Yo ass can probably double tha curlies ta git tha same effect
though, cuz tha inner curlies is ghon be considered a funky-ass block that
loops once.  See \*(L"redo\*(R" up in perlfunc.
.ie n .IP "Can't remove %s: %s, skippin file" 4
.el .IP "Can't remove \f(CW%s:\fR \f(CW%s\fR, skippin file" 4
.IX Item "Can't remove %s: %s, skippin file"
(S inplace) Yo ass axed a inplace edit without bustin a funky-ass backup
file.  Perl was unable ta remove tha original gangsta file ta replace it with
the modified file.  Da file was left unmodified.
.ie n .IP "Can't rename %s ta %s: %s, skippin file" 4
.el .IP "Can't rename \f(CW%s\fR ta \f(CW%s:\fR \f(CW%s\fR, skippin file" 4
.IX Item "Can't rename %s ta %s: %s, skippin file"
(S inplace) Da rename done by tha \fB\-i\fR switch failed fo' some reason,
probably cuz you aint gots write permission ta tha directory.
.ie n .IP "Can't reopen input pipe (name: %s) up in binary mode" 4
.el .IP "Can't reopen input pipe (name: \f(CW%s\fR) up in binary mode" 4
.IX Item "Can't reopen input pipe (name: %s) up in binary mode"
(P) An error peculiar ta \s-1VMS. \s0 Perl thought stdin was a pipe, n' tried
to reopen it ta accept binary data.  Alas, it failed.
.ie n .IP "Can't reset %ENV on dis system" 4
.el .IP "Can't reset \f(CW%ENV\fR on dis system" 4
.IX Item "Can't reset %ENV on dis system"
(F) Yo ass called \f(CW\*(C`reset(\*(AqE\*(Aq)\*(C'\fR or similar, which tried ta reset
all variablez up in tha current package beginnin wit \*(L"E\*(R".  In
the main package, dat includes \f(CW%ENV\fR.  Resettin \f(CW%ENV\fR is not
supported on some systems, notably \s-1VMS.\s0
.ie n .IP "Can't resolve method ""%s"" overloadin ""%s"" up in package ""%s""" 4
.el .IP "Can't resolve method ``%s'' overloadin ``%s'' up in package ``%s''" 4
.IX Item "Can't resolve method %s overloadin %s up in package %s"
(F)(P) Error resolvin overloadin specified by a method name (as
opposed ta a subroutine reference): no such method callable via the
package.  If tha method name is \f(CW\*(C`???\*(C'\fR, dis be a internal error.
.ie n .IP "Can't return %s from lvalue subroutine" 4
.el .IP "Can't return \f(CW%s\fR from lvalue subroutine" 4
.IX Item "Can't return %s from lvalue subroutine"
(F) Perl detected a attempt ta return illegal lvalues (such as
temporary or readonly joints) from a subroutine used as a lvalue.  This
is not allowed.
.IP "Can't return outside a subroutine" 4
.IX Item "Can't return outside a subroutine"
(F) Da return statement was executed up in mainline code, dat is, where
there was no subroutine call ta return up of.  See perlsub.
.ie n .IP "Can't return %s ta lvalue scalar context" 4
.el .IP "Can't return \f(CW%s\fR ta lvalue scalar context" 4
.IX Item "Can't return %s ta lvalue scalar context"
(F) Yo ass tried ta return a cold-ass lil complete array or hash from a lvalue
subroutine yo, but you called tha subroutine up in a way dat made Perl
think you meant ta return only one value.  Yo ass probably meant to
write parentheses round tha call ta tha subroutine, which tell
Perl dat tha call should be up in list context.
.ie n .IP "Can't stat script ""%s""" 4
.el .IP "Can't stat script ``%s''" 4
.IX Item "Can't stat script %s"
(P) For some reason you can't \fIfstat()\fR tha script even though you have it
open already.  Bizarre.
.ie n .IP "Can't take log of %g" 4
.el .IP "Can't take log of \f(CW%g\fR" 4
.IX Item "Can't take log of %g"
(F) For ordinary real numbers, you can't take tha logarithm of a
negatizzle number or zero.  Therez a Math::Complex package dat comes
standard wit Perl, though, if you straight-up wanna do dat fo' the
negatizzle numbers.
.ie n .IP "Can't take sqrt of %g" 4
.el .IP "Can't take sqrt of \f(CW%g\fR" 4
.IX Item "Can't take sqrt of %g"
(F) For ordinary real numbers, you can't take tha square root of a
negatizzle number n' shit.  Therez a Math::Complex package dat comes standard
with Perl, though, if you straight-up wanna do dis shit.
.IP "Can't undef actizzle subroutine" 4
.IX Item "Can't undef actizzle subroutine"
(F) Yo ass can't undefine a routine thatz currently hustlin.  Yo ass can,
however, redefine it while itz hustlin, n' you can even undef the
redefined subroutine while tha oldschool routine is hustlin.  Go figure.
.ie n .IP "Can't upgrade %s (%d) ta %d" 4
.el .IP "Can't upgrade \f(CW%s\fR (%d) ta \f(CW%d\fR" 4
.IX Item "Can't upgrade %s (%d) ta %d"
(P) Da internal sv_upgrade routine addz \*(L"members\*(R" ta a \s-1SV,\s0 makin it
into a mo' specialized kind of \s-1SV. \s0 Da top nuff muthafuckin \s-1SV\s0 types is so
specialized, however, dat they cannot be interconverted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This message
indicates dat such a cold-ass lil conversion was attempted.
.IP "Can't use '%c' afta \-mname" 4
.IX Item "Can't use '%c' afta -mname"
(F) Yo ass tried ta booty-call perl wit tha \fB\-m\fR switch yo, but you put something
other than \*(L"=\*(R" afta tha module name.
.IP "Can't use anonymous symbol table fo' method lookup" 4
.IX Item "Can't use anonymous symbol table fo' method lookup"
(F) Da internal routine dat do method lookup was handed a symbol
table dat aint gots a name.  Symbol tablez can become anonymous
for example by undefinin stashes: \f(CW\*(C`undef %Some::Package::\*(C'\fR.
.ie n .IP "Can't use a undefined value as %s reference" 4
.el .IP "Can't use a undefined value as \f(CW%s\fR reference" 4
.IX Item "Can't use a undefined value as %s reference"
(F) A value used as either a hard reference or a symbolic reference must
be a thugged-out defined value.  This helps ta delurk some insidious errors.
.ie n .IP "Can't use bareword (""%s"") as %s ref while ""strict refs"" up in use" 4
.el .IP "Can't use bareword (``%s'') as \f(CW%s\fR ref while ``strict refs'' up in use" 4
.IX Item "Can't use bareword (%s) as %s ref while strict refs up in use"
(F) Only hard references is allowed by \*(L"strict refs\*(R".  Symbolic
references is disallowed. Y'all KNOW dat shit, muthafucka!  See perlref.
.IP "Can't use %! cuz Errno.pm aint available" 4
.IX Item "Can't use %! cuz Errno.pm aint available"
(F) Da last time tha \f(CW\*(C`%!\*(C'\fR hash is used, perl automatically loadz the
Errno.pm module.  Da Errno module is sposed ta fuckin tie tha %! hash to
provide symbolic names fo' \f(CW$!\fR errno joints.
.ie n .IP "Can't use both '<' n' '>' afta type '%c' up in %s" 4
.el .IP "Can't use both '<' n' '>' afta type '%c' up in \f(CW%s\fR" 4
.IX Item "Can't use both '<' n' '>' afta type '%c' up in %s"
(F) A type cannot be forced ta have both big-endian n' lil-endian
byte-order all up in tha same time, so dis combination of modifiers is not
allowed. Y'all KNOW dat shit, muthafucka!  See \*(L"pack\*(R" up in perlfunc.
.ie n .IP "Can't use %s fo' loop variable" 4
.el .IP "Can't use \f(CW%s\fR fo' loop variable" 4
.IX Item "Can't use %s fo' loop variable"
(F) Only a simple scalar variable may be used as a loop variable on a
foreach.
.ie n .IP "Can't use global %s up in ""%s""" 4
.el .IP "Can't use global \f(CW%s\fR up in ``%s''" 4
.IX Item "Can't use global %s up in %s"
(F) Yo ass tried ta declare a magical variable as a lexical variable.  This
is not allowed, cuz tha magic can be tied ta only one location
(namely tha global variable) n' it would be incredibly confusin to
have variablez up in yo' program dat looked like magical variablez but
weren't.
.ie n .IP "Can't use '%c' up in a crew wit different byte-order up in %s" 4
.el .IP "Can't use '%c' up in a crew wit different byte-order up in \f(CW%s\fR" 4
.IX Item "Can't use '%c' up in a crew wit different byte-order up in %s"
(F) Yo ass attempted ta force a gangbangin' finger-lickin' different byte-order on a type
that be already inside a crew wit a funky-ass byte-order modifier.
For example you cannot force lil-endiannizz on a type that
is inside a funky-ass big-endian group.
.ie n .IP "Can't use ""my %s"" up in sort comparison" 4
.el .IP "Can't use ``my \f(CW%s\fR'' up in sort comparison" 4
.IX Item "Can't use mah %s up in sort comparison"
(F) Da global variablez \f(CW$a\fR n' \f(CW$b\fR is reserved fo' sort comparisons.
Yo ass mentioned \f(CW$a\fR or \f(CW$b\fR up in tha same line as tha <=> or cmp operator,
and tha variable had earlier been declared as a lexical variable.
Either qualify tha sort variable wit tha package name, or rename the
lexical variable.
.ie n .IP "Can't use %s ref as %s ref" 4
.el .IP "Can't use \f(CW%s\fR ref as \f(CW%s\fR ref" 4
.IX Item "Can't use %s ref as %s ref"
(F) You've mixed up yo' reference types.  Yo ass gotta dereference a
reference of tha type needed. Y'all KNOW dat shit, muthafucka!  Yo ass can use tha \fIref()\fR function to
test tha type of tha reference, if need be.
.ie n .IP "Can't use strang (""%s"") as %s ref while ""strict refs"" up in use" 4
.el .IP "Can't use strang (``%s'') as \f(CW%s\fR ref while ``strict refs'' up in use" 4
.IX Item "Can't use strang (%s) as %s ref while strict refs up in use"
(F) You've holla'd at Perl ta dereference a string, suttin' which
\&\f(CW\*(C`use strict\*(C'\fR blocks ta prevent it goin down accidentally.  See
\&\*(L"Symbolic references\*(R" up in perlref.  This can be triggered by a \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`$\*(C'\fR
in a thugged-out double-quoted strang immediately before interpolatin a variable,
for example up in \f(CW"user @$twitter_id"\fR, which say ta treat tha contents
of \f(CW$twitter_id\fR as a array reference; bust a \f(CW\*(C`\e\*(C'\fR ta git a literal \f(CW\*(C`@\*(C'\fR
symbol followed by tha contentz of \f(CW$twitter_id\fR: \f(CW"user \e@$twitter_id"\fR.
.ie n .IP "Can't use subscript on %s" 4
.el .IP "Can't use subscript on \f(CW%s\fR" 4
.IX Item "Can't use subscript on %s"
(F) Da compila tried ta interpret a funky-ass bracketed expression as a
subscript.  But ta tha left of tha brackets was a expression that
didn't be lookin like a hash or array reference, or anythang else subscriptable.
.IP "Can't use \e%c ta mean $%c up in expression" 4
.IX Item "Can't use %c ta mean $%c up in expression"
(W syntax) In a ordinary expression, backslash be a unary operator that
creates a reference ta its argument.  Da use of backslash ta indicate a
backreference ta a matched substrin is valid only as part of a regular
expression pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Tryin ta do dis up in ordinary Perl code produces a
value dat prints up lookin like \s-1\fISCALAR\s0\fR\|(0xdecaf).  Use tha \f(CW$1\fR form
instead.
.IP "Can't weaken a nonreference" 4
.IX Item "Can't weaken a nonreference"
(F) Yo ass attempted ta weaken suttin' dat was not a reference.  Only
references can be weakened.
.ie n .IP "Can't ""when"" outside a topicalizer" 4
.el .IP "Can't ``when'' outside a topicalizer" 4
.IX Item "Can't when outside a topicalizer"
(F) Yo ass have used a \fIwhen()\fR block dat is neither inside a \f(CW\*(C`foreach\*(C'\fR
loop nor a \f(CW\*(C`given\*(C'\fR block.  (Note dat dis error is issued on exit
from tha \f(CW\*(C`when\*(C'\fR block, so you won't git tha error if tha match fails,
or if you use a explicit \f(CW\*(C`continue\*(C'\fR.)
.IP "Can't x= ta read-only value" 4
.IX Item "Can't x= ta read-only value"
(F) Yo ass tried ta repeat a cold-ass lil constant value (often tha undefined value)
with a assignment operator, which implies modifyin tha value itself.
Perhaps you need ta copy tha value ta a temporary, n' repeat dis shit.
.ie n .IP "Characta followin ""\ec"" must be \s-1ASCII\s0" 4
.el .IP "Characta followin ``\ec'' must be \s-1ASCII\s0" 4
.IX Item "Characta followin c must be ASCII"
(F)(W deprecated, syntax) In \f(CW\*(C`\ec\f(CIX\f(CW\*(C'\fR, \fIX\fR must be a \s-1ASCII\s0 character.
It be planned ta make dis fatal up in all instances up in Perl v5.20.  In the
cases where it aint fatal, tha characta dis evaluates ta is
derived by exclusive or'in tha code point of dis characta wit 0x40.
.Sp
Note dat non-alphabetic \s-1ASCII\s0 charactas is discouraged here as well,
and rockin non-printable ones is ghon be deprecated startin up in v5.18.
.IP "Characta up in 'C' format wrapped up in pack" 4
.IX Item "Characta up in 'C' format wrapped up in pack"
(W pack) Yo ass holla'd
.Sp
.Vb 1
\&    pack("C", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than 0 or mo' than 255; tha \f(CW"C"\fR format is
only fo' encodin natizzle operatin system charactas (\s-1ASCII, EBCDIC,\s0
and so on) n' not fo' Unicode characters, so Perl behaved as if you meant
.Sp
.Vb 1
\&    pack("C", $x & 255)
.Ve
.Sp
If you straight-up wanna pack Unicode codepoints, use tha \f(CW"U"\fR format
instead.
.IP "Characta up in 'W' format wrapped up in pack" 4
.IX Item "Characta up in 'W' format wrapped up in pack"
(W pack) Yo ass holla'd
.Sp
.Vb 1
\&    pack("U0W", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than 0 or mo' than 255.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`U0\*(C'\fR\-mode
expects all joints ta fall up in tha interval [0, 255], so Perl behaved
as if you meant:
.Sp
.Vb 1
\&    pack("U0W", $x & 255)
.Ve
.IP "Characta up in 'c' format wrapped up in pack" 4
.IX Item "Characta up in 'c' format wrapped up in pack"
(W pack) Yo ass holla'd
.Sp
.Vb 1
\&    pack("c", $x)
.Ve
.Sp
where \f(CW$x\fR is either less than \-128 or mo' than 127; tha \f(CW"c"\fR format
is only fo' encodin natizzle operatin system charactas (\s-1ASCII, EBCDIC,\s0
and so on) n' not fo' Unicode characters, so Perl behaved as if you meant
.Sp
.Vb 1
\&    pack("c", $x & 255);
.Ve
.Sp
If you straight-up wanna pack Unicode codepoints, use tha \f(CW"U"\fR format
instead.
.IP "Characta up in '%c' format wrapped up in unpack" 4
.IX Item "Characta up in '%c' format wrapped up in unpack"
(W unpack) Yo ass tried suttin' like
.Sp
.Vb 1
\&   unpack("H", "\ex{2a1}")
.Ve
.Sp
where tha format expects ta process a funky-ass byte (a characta wit a value
below 256) yo, but a higher value was provided instead. Y'all KNOW dat shit, muthafucka!  Perl uses the
value modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   unpack("H", "\ex{a1}")
.Ve
.IP "Character(s) up in '%c' format wrapped up in pack" 4
.IX Item "Character(s) up in '%c' format wrapped up in pack"
(W pack) Yo ass tried suttin' like
.Sp
.Vb 1
\&   pack("u", "\ex{1f3}b")
.Ve
.Sp
where tha format expects ta process a sequence of bytes (characta wit a
value below 256) yo, but a shitload of tha charactas had a higher value.  Perl
uses tha characta joints modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   pack("u", "\ex{f3}b")
.Ve
.IP "Character(s) up in '%c' format wrapped up in unpack" 4
.IX Item "Character(s) up in '%c' format wrapped up in unpack"
(W unpack) Yo ass tried suttin' like
.Sp
.Vb 1
\&   unpack("s", "\ex{1f3}b")
.Ve
.Sp
where tha format expects ta process a sequence of bytes (characta wit a
value below 256) yo, but a shitload of tha charactas had a higher value.  Perl
uses tha characta joints modulus 256 instead, as if you had provided:
.Sp
.Vb 1
\&   unpack("s", "\ex{f3}b")
.Ve
.ie n .IP """\ec{"" is deprecated n' is mo' clearly freestyled as "";""" 4
.el .IP "``\ec{'' is deprecated n' is mo' clearly freestyled as ``;''" 4
.IX Item "c{ is deprecated n' is mo' clearly freestyled as ;"
(D deprecated, syntax) Da \f(CW\*(C`\ec\f(CIX\f(CW\*(C'\fR construct is intended ta be a way
to specify non-printable characters.  Yo ass used it wit a \*(L"{\*(R" which
evaluates ta \*(L";\*(R", which is printable.  It be planned ta remove the
abilitizzle ta specify a semi-colon dis way up in Perl 5.20.  Just use a
semi-colon or a funky-ass backslash-semi-colon without tha \*(L"\ec\*(R".
.ie n .IP """\ec%c"" is mo' clearly freestyled simply as ""%s""" 4
.el .IP "``\ec%c'' is mo' clearly freestyled simply as ``%s''" 4
.IX Item "c%c is mo' clearly freestyled simply as %s"
(W syntax) Da \f(CW\*(C`\ec\f(CIX\f(CW\*(C'\fR construct is intended ta be a way ta specify
non-printable characters.  Yo ass used it fo' a printable one, which is better
written as simply itself, like preceded by a funky-ass backslash fo' non-word
characters.
.IP "Clonin substitution context is unimplemented" 4
.IX Item "Clonin substitution context is unimplemented"
(F) Creatin a freshly smoked up thread inside tha \f(CW\*(C`s///\*(C'\fR operator aint supported.
.ie n .IP "\fIclose()\fR on unopened filehandle %s" 4
.el .IP "\fIclose()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "close() on unopened filehandle %s"
(W unopened) Yo ass tried ta close a gangbangin' filehandle dat was never opened.
.ie n .IP "\fIclosedir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fIclosedir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "closedir() attempted on invalid dirhandle %s"
(W io) Da dirhandle you tried ta close is either closed or not straight-up
a dirhandle.  Peep yo' control flow.
.IP "Closure prototype called" 4
.IX Item "Closure prototype called"
(F) If a cold-ass lil closure has attributes, tha subroutine passed ta a attribute
handlez is tha prototype dat is cloned when a freshly smoked up closure is pimped.
This subroutine cannot be called.
.IP "Code missin afta '/'" 4
.IX Item "Code missin afta '/'"
(F) Yo ass had a (sub\-)template dat endz wit a '/'.  There must be
another template code followin tha slash.  See \*(L"pack\*(R" up in perlfunc.
.IP "Code point 0x%X aint Unicode, may not be portable" 4
.IX Item "Code point 0x%X aint Unicode, may not be portable"
.PD 0
.IP "Code point 0x%X aint Unicode, all \ep{} matches fail; all \eP{} matches succeed" 4
.IX Item "Code point 0x%X aint Unicode, all p{} matches fail; all P{} matches succeed"
.PD
(S utf8, non_unicode) Yo ass had a cold-ass lil code point above tha Unicode maximum
of U+10FFFF.
.Sp
Perl allows strings ta contain a superset of Unicode code points, up
to tha limit of what tha fuck is storable up in a unsigned integer on yo' system,
but these may not be accepted by other languages/systems.  At one time,
it was legal up in some standardz ta have code points up ta 0x7FFF_FFFF,
but not higher n' shit.  Code points above 0xFFFF_FFFF require larger than a
32 bit word.
.Sp
None of tha Unicode or Perl-defined propertizzles will match a non-Unicode
code point.  For example,
.Sp
.Vb 1
\&    chr(0x7FF_FFFF) =~ /\ep{Any}/
.Ve
.Sp
will not match, cuz tha code point aint up in Unicode.  But
.Sp
.Vb 1
\&    chr(0x7FF_FFFF) =~ /\eP{Any}/
.Ve
.Sp
will match.
.Sp
This may be counterintuitizzle at times, as both these fail:
.Sp
.Vb 2
\& chr(0x110000) =~ /\ep{ASCII_Hex_Digit=True}/      # Fails.
\& chr(0x110000) =~ /\ep{ASCII_Hex_Digit=False}/     # Also fails!
.Ve
.Sp
and both these succeed:
.Sp
.Vb 2
\& chr(0x110000) =~ /\eP{ASCII_Hex_Digit=True}/      # Succeeds.
\& chr(0x110000) =~ /\eP{ASCII_Hex_Digit=False}/     # Also succeeds!
.Ve
.ie n .IP "%s: Command not found" 4
.el .IP "\f(CW%s:\fR Command not found" 4
.IX Item "%s: Command not found"
(A) You've accidentally run yo' script all up in \fBcsh\fR or another shell
shell instead of Perl.  Peep tha #! line, or manually feed yo' script
into Perl yo ass.  Da #! line all up in tha top of yo' file could look like
.Sp
.Vb 1
\&  #!/usr/bin/perl \-w
.Ve
.IP "Compilation failed up in require" 4
.IX Item "Compilation failed up in require"
(F) Perl could not compile a gangbangin' file specified up in a \f(CW\*(C`require\*(C'\fR statement.
Perl uses dis generic message when none of tha errors dat it
encountered was severe enough ta halt compilation immediately.
.IP "Complex regular subexpression recursion limit (%d) exceeded" 4
.IX Item "Complex regular subexpression recursion limit (%d) exceeded"
(W regexp) Da regular expression engine uses recursion up in complex
situations where back-trackin is required. Y'all KNOW dat shit, muthafucka!  Recursion depth is limited
to 32766, or like less up in architectures where tha stack cannot grow
arbitrarily.  (\*(L"Simple\*(R" n' \*(L"medium\*(R" thangs is handled without
recursion n' is not subject ta a limit.)  Try shortenin tha string
under examination; loopin up in Perl code (e.g. wit \f(CW\*(C`while\*(C'\fR) rather than
in tha regular expression engine; or rewritin tha regular expression so
that it is simpla or backtracks less.  (See perlfaq2 fo' shiznit
on \fIMasterin Regular Expressions\fR.)
.IP "\fIcond_broadcast()\fR called on unlocked variable" 4
.IX Item "cond_broadcast() called on unlocked variable"
(W threads) Within a thread-enabled program, you tried to
call \fIcond_broadcast()\fR on a variable which wasn't locked.
Da \fIcond_broadcast()\fR function is used ta raise up another thread
that is waitin up in a \fIcond_wait()\fR.  To ensure dat tha signal aint
sent before tha other thread has a cold-ass lil chizzle ta enta tha wait, it
is usual fo' tha signalin thread first ta wait fo' a lock on
variable.  This lock attempt will only succeed afta tha other
thread has entered \fIcond_wait()\fR n' thus relinquished tha lock.
.IP "\fIcond_signal()\fR called on unlocked variable" 4
.IX Item "cond_signal() called on unlocked variable"
(W threads) Within a thread-enabled program, you tried to
call \fIcond_signal()\fR on a variable which wasn't locked. Y'all KNOW dat shit, muthafucka!  The
\&\fIcond_signal()\fR function is used ta raise up another thread that
is waitin up in a \fIcond_wait()\fR.  To ensure dat tha signal aint
sent before tha other thread has a cold-ass lil chizzle ta enta tha wait, it
is usual fo' tha signalin thread first ta wait fo' a lock on
variable.  This lock attempt will only succeed afta tha other
thread has entered \fIcond_wait()\fR n' thus relinquished tha lock.
.ie n .IP "\fIconnect()\fR on closed socket %s" 4
.el .IP "\fIconnect()\fR on closed socket \f(CW%s\fR" 4
.IX Item "connect() on closed socket %s"
(W closed) Yo ass tried ta do a cold-ass lil connect on a cold-ass lil closed socket.  Did yo dirty ass forget
to check tha return value of yo' \fIsocket()\fR call?  See
\&\*(L"connect\*(R" up in perlfunc.
.IP "Constant(%s): Call ta &{$^H{%s}} did not return a thugged-out defined value" 4
.IX Item "Constant(%s): Call ta &{$^H{%s}} did not return a thugged-out defined value"
(F) Da subroutine registered ta handle constant overloading
(see overload) or a cold-ass lil custom charnames handlez (see
\&\*(L"\s-1CUSTOM TRANSLATORS\*(R"\s0 up in charnames) returned a undefined value.
.IP "Constant(%s): $^H{%s} aint defined" 4
.IX Item "Constant(%s): $^H{%s} aint defined"
(F) Da parser found inconsistencies while attemptin ta define an
overloaded constant.  Perhaps you forgot ta load tha corresponding
overload pragma?.
.IP "Constant(%s) unknown" 4
.IX Item "Constant(%s) unknown"
(F) Da parser found inconsistencies either while attemptin ta define
an overloaded constant, or when tryin ta find tha characta name
specified up in tha \f(CW\*(C`\eN{...}\*(C'\fR escape.  Perhaps you forgot ta load the
correspondin overload pragma?.
.ie n .IP "Constant aint %s reference" 4
.el .IP "Constant aint \f(CW%s\fR reference" 4
.IX Item "Constant aint %s reference"
(F) A constant value (like declared rockin tha \f(CW\*(C`use constant\*(C'\fR pragma)
is bein dereferenced yo, but it amounts ta tha wack type of reference.
Da message indicates tha type of reference dat was expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This
usually indicates a syntax error up in dereferencin tha constant value.
See \*(L"Constant Functions\*(R" up in perlsub n' constant.
.ie n .IP "Constant subroutine %s redefined" 4
.el .IP "Constant subroutine \f(CW%s\fR redefined" 4
.IX Item "Constant subroutine %s redefined"
(W redefine)(S) Yo ass redefined a subroutine which had previously
been eligible fo' inlining.  See \*(L"Constant Functions\*(R" up in perlsub
for commentary n' workarounds.
.ie n .IP "Constant subroutine %s undefined" 4
.el .IP "Constant subroutine \f(CW%s\fR undefined" 4
.IX Item "Constant subroutine %s undefined"
(W misc) Yo ass undefined a subroutine which had previously been eligible
for inlining.  See \*(L"Constant Functions\*(R" up in perlsub fo' commentary and
workarounds.
.IP "Copy method did not return a reference" 4
.IX Item "Copy method did not return a reference"
(F) Da method which overloadz \*(L"=\*(R" is buggy.  See
\&\*(L"Copy Constructor\*(R" up in overload.
.IP "&CORE::%s cannot be called directly" 4
.IX Item "&CORE::%s cannot be called directly"
(F) Yo ass tried ta booty-call a subroutine up in tha \f(CW\*(C`CORE::\*(C'\fR namespace
with \f(CW&foo\fR syntax or all up in a reference.  Some subroutines
in dis package cannot yet be called dat way yo, but must be
called as barewords.  Somethang like dis will work:
.Sp
.Vb 2
\&    BEGIN { *shove = \e&CORE::push; }
\&    shove @array, 1,2,3; # pushes on ta @array
.Ve
.IP "CORE::%s aint a keyword" 4
.IX Item "CORE::%s aint a keyword"
(F) Da \s-1CORE::\s0 namespace is reserved fo' Perl keywords.
.IP "corrupted regexp pointers" 4
.IX Item "corrupted regexp pointers"
(P) Da regular expression engine gots trippin by what tha fuck tha regular
expression compila gave dat shit.
.IP "corrupted regexp program" 4
.IX Item "corrupted regexp program"
(P) Da regular expression engine gots passed a regexp program without a
valid magic number.
.IP "Corrupt malloc ptr 0x%x at 0x%x" 4
.IX Item "Corrupt malloc ptr 0x%x at 0x%x"
(P) Da malloc package dat comes wit Perl had a internal failure.
.ie n .IP "Corrupted regexp opcode %d > %d" 4
.el .IP "Corrupted regexp opcode \f(CW%d\fR > \f(CW%d\fR" 4
.IX Item "Corrupted regexp opcode %d > %d"
(F)
This is either a error up in Perl, or, if you rockin one, your
custom regular expression engine.  If not tha latter,
report tha problem all up in tha perlbug utility.
.IP "Count afta length/code up in unpack" 4
.IX Item "Count afta length/code up in unpack"
(F) Yo ass had a unpack template indicatin a cold-ass lil counted-length strin yo, but
you have also specified a explicit size fo' tha string.  See
\&\*(L"pack\*(R" up in perlfunc.
.IP "Deep recursion on anonymous subroutine" 4
.IX Item "Deep recursion on anonymous subroutine"
.PD 0
.ie n .IP "Deep recursion on subroutine ""%s""" 4
.el .IP "Deep recursion on subroutine ``%s''" 4
.IX Item "Deep recursion on subroutine %s"
.PD
(W recursion) This subroutine has called itself (directly or indirectly)
100 times mo' than it has returned. Y'all KNOW dat shit, muthafucka!  This probably indicates an
infinite recursion, unless you freestylin strange benchmark programs, in
which case it indicates suttin' else.
.Sp
This threshold can be chizzled from 100, by recompilin tha \fIperl\fR binary,
settin tha C pre-processor macro \f(CW\*(C`PERL_SUB_DEPTH_WARN\*(C'\fR ta tha desired value.
.IP "defined(@array) is deprecated" 4
.IX Item "defined(@array) is deprecated"
(D deprecated) \fIdefined()\fR aint probably useful on arrays cuz it
checks fo' a undefined \fIscalar\fR value.  If you wanna peep if the
array is empty, just use \f(CW\*(C`if (@array) { # not empty }\*(C'\fR fo' example.
.IP "defined(%hash) is deprecated" 4
.IX Item "defined(%hash) is deprecated"
(D deprecated) \f(CW\*(C`defined()\*(C'\fR aint probably right on hashes n' has been
discouraged since 5.004.
.Sp
Although \f(CW\*(C`defined %hash\*(C'\fR is false on a plain not-yet-used hash, it
becomes legit up in nuff muthafuckin non-obvious circumstances, includin iterators,
weak references, stash names, even remainin legit afta \f(CW\*(C`undef %hash\*(C'\fR.
These thangs make \f(CW\*(C`defined %hash\*(C'\fR fairly useless up in practice.
.Sp
If a cold-ass lil check fo' non-empty is what tha fuck you wanted then just put it up in boolean
context (see \*(L"Scalar joints\*(R" up in perldata):
.Sp
.Vb 3
\&    if (%hash) {
\&       # not empty
\&    }
.Ve
.Sp
If you had \f(CW\*(C`defined %Foo::Bar::QUUX\*(C'\fR ta check whether such a package
variable exists then thatz never straight-up been reliable, n' aint
a phat way ta enquire bout tha featurez of a package, or whether
itz loaded, etc.
.IP "(?(\s-1DEFINE\s0)....) do not allow branches up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "(?(DEFINE)....) do not allow branches up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used suttin' like \f(CW\*(C`(?(DEFINE)...|..)\*(C'\fR which is illegal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  The
most likely cause of dis error is dat you left up a parenthesis inside
of tha \f(CW\*(C`....\*(C'\fR part.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.ie n .IP "%s defines neither package nor VERSION\*(--version check failed" 4
.el .IP "\f(CW%s\fR defines neither package nor VERSION\*(--version check failed" 4
.IX Item "%s defines neither package nor VERSIONversion check failed"
(F) Yo ass holla'd suttin' like \*(L"use Module 42\*(R" but up in tha Module file
there is neither package declarations nor a \f(CW$VERSION\fR.
.IP "Delimita fo' here document is too long" 4
.IX Item "Delimita fo' here document is too long"
(F) In a here document construct like \f(CW\*(C`<<FOO\*(C'\fR, tha label \f(CW\*(C`FOO\*(C'\fR is too
long fo' Perl ta handle.  Yo ass gotta be seriously twisted ta write code
that triggers dis error.
.IP "Deprecated use of \fImy()\fR up in false conditional" 4
.IX Item "Deprecated use of my() up in false conditional"
(D deprecated) Yo ass used a thugged-out declaration similar ta \f(CW\*(C`my $x if 0\*(C'\fR.  There
has been a long-standin bug up in Perl dat causes a lexical variable
not ta be cleared at scope exit when its declaration includes a gangbangin' false
conditional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Some playas have exploited dis bug ta big up a kind of
static variable.  Since we intend ta fix dis bug, our phat asses don't want people
relyin on dis behavior. Shiiit, dis aint no joke.  Yo ass can big up a similar static effect by
declarin tha variable up in a separate block outside tha function, eg
.Sp
.Vb 1
\&    sub f { mah $x if 0; return $x++ }
.Ve
.Sp
becomes
.Sp
.Vb 1
\&    { mah $x; sub f { return $x++ } }
.Ve
.Sp
Beginnin wit perl 5.9.4, you can also use \f(CW\*(C`state\*(C'\fR variablez ta have
lexicals dat is initialized only once (see feature):
.Sp
.Vb 1
\&    sub f { state $x; return $x++ }
.Ve
.IP "\s-1DESTROY\s0 pimped freshly smoked up reference ta dead object '%s'" 4
.IX Item "DESTROY pimped freshly smoked up reference ta dead object '%s'"
(F) A \s-1\fIDESTROY\s0()\fR method pimped a freshly smoked up reference ta tha object which is
just bein DESTROYed. Y'all KNOW dat shit, muthafucka!  Perl is confused, n' prefers ta abort rather
than ta create a thugged-out danglin reference.
.IP "Did not produce a valid header" 4
.IX Item "Did not produce a valid header"
See Server error.
.ie n .IP "%s did not return a legit value" 4
.el .IP "\f(CW%s\fR did not return a legit value" 4
.IX Item "%s did not return a legit value"
(F) A required (or used) file must return a legit value ta indicate that
it compiled erectly n' ran its initialization code erectly.  It's
traditionizzle ta end such a gangbangin' file wit a \*(L"1;\*(R", though any legit value would
do.  See \*(L"require\*(R" up in perlfunc.
.IP "(Did yo dirty ass mean &%s instead?)" 4
.IX Item "(Did yo dirty ass mean &%s instead?)"
(W misc) Yo ass probably referred ta a imported subroutine &FOO as \f(CW$FOO\fR or
some such.
.ie n .IP "(Did yo dirty ass mean ""local"" instead of ""our""?)" 4
.el .IP "(Did yo dirty ass mean ``local'' instead of ``our''?)" 4
.IX Item "(Did yo dirty ass mean local instead of our?)"
(W misc) Remember dat \*(L"our\*(R" do not localize tha declared global
variable.  Yo ass have declared it again n' again n' again up in tha same lexical scope, which
seems superfluous.
.IP "(Did yo dirty ass mean $ or @ instead of %?)" 4
.IX Item "(Did yo dirty ass mean $ or @ instead of %?)"
(W) Yo ass probably holla'd \f(CW%hash\fR{$key} when you meant \f(CW$hash\fR{$key} or
\&\f(CW@hash\fR{@keys}.  On tha other hand, maybe you just meant \f(CW%hash\fR n' got
carried away.
.IP "Died" 4
.IX Item "Died"
(F) Yo ass passed \fIdie()\fR a empty strang (the equivalent of \f(CW\*(C`die ""\*(C'\fR) or
you called it wit no args n' \f(CW$@\fR was empty.
.IP "Document gotz nuff no data" 4
.IX Item "Document gotz nuff no data"
See Server error.
.ie n .IP "%s do not define %s::VERSION\*(--version check failed" 4
.el .IP "\f(CW%s\fR do not define \f(CW%s::VERSION\fR\*(--version check failed" 4
.IX Item "%s do not define %s::VERSIONversion check failed"
(F) Yo ass holla'd suttin' like \*(L"use Module 42\*(R" but tha Module did not
define a \f(CW$VERSION\fR.
.IP "'/' do not take a repeat count" 4
.IX Item "'/' do not take a repeat count"
(F) Yo ass cannot put a repeat count of any kind right afta tha '/' code.
See \*(L"pack\*(R" up in perlfunc.
.IP "Don't know how tha fuck ta handle magic of type '%s'" 4
.IX Item "Don't know how tha fuck ta handle magic of type '%s'"
(P) Da internal handlin of magical variablez has been cursed.
.IP "do_study: outta memory" 4
.IX Item "do_study: outta memory"
(P) This should done been caught by \fIsafemalloc()\fR instead.
.ie n .IP "(Do you need ta predeclare %s?)" 4
.el .IP "(Do you need ta predeclare \f(CW%s\fR?)" 4
.IX Item "(Do you need ta predeclare %s?)"
(S syntax) This be a constipated guess made up in conjunction wit tha message
\&\*(L"%s found where operator expected\*(R".  It often means a subroutine or module
name is bein referenced dat aint been declared yet.  This may be
because of orderin problems up in yo' file, or cuz of a missing
\&\*(L"sub\*(R", \*(L"package\*(R", \*(L"require\*(R", or \*(L"use\*(R" statement.  If you referencing
suttin' dat aint defined yet, you don't straight-up gotta define the
subroutine or package before tha current location. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use a empty
\&\*(L"sub foo;\*(R" or \*(L"package \s-1FOO\s0;\*(R" ta enta a \*(L"forward\*(R" declaration.
.IP "\fIdump()\fR betta freestyled as \fICORE::dump()\fR" 4
.IX Item "dump() betta freestyled as CORE::dump()"
(W misc) Yo ass used tha obsolescent \f(CW\*(C`dump()\*(C'\fR built-in function, without fully
qualifyin it as \f(CW\*(C`CORE::dump()\*(C'\fR.  Maybe itz a typo.  See \*(L"dump\*(R" up in perlfunc.
.IP "dump aint supported" 4
.IX Item "dump aint supported"
(F) Yo crazy-ass machine don't support dump/undump.
.IP "Duplicate \fIfree()\fR ignored" 4
.IX Item "Duplicate free() ignored"
(S malloc) An internal routine called \fIfree()\fR on suttin' dat had
already been freed.
.ie n .IP "Duplicate modifier '%c' afta '%c' up in %s" 4
.el .IP "Duplicate modifier '%c' afta '%c' up in \f(CW%s\fR" 4
.IX Item "Duplicate modifier '%c' afta '%c' up in %s"
(W unpack) Yo ass have applied tha same modifier mo' than once afta a
type up in a pack template.  See \*(L"pack\*(R" up in perlfunc.
.IP "elseif should be elsif" 4
.IX Item "elseif should be elsif"
(S syntax) There is no keyword \*(L"elseif\*(R" up in Perl cuz Larry thinks
itz skanky.  Yo crazy-ass code is ghon be interpreted as a attempt ta booty-call a method
named \*(L"elseif\*(R" fo' tha class returned by tha followin block.  This is
unlikely ta be what tha fuck you want.
.IP "Empty \e%c{} up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Empty %c{} up in regex; marked by <-- HERE up in m/%s/"
(F) \f(CW\*(C`\ep\*(C'\fR n' \f(CW\*(C`\eP\*(C'\fR is used ta introduce a named Unicode property, as
busted lyrics bout up in perlunicode n' perlre.  Yo ass used \f(CW\*(C`\ep\*(C'\fR or \f(CW\*(C`\eP\*(C'\fR in
a regular expression without specifyin tha property name.
.ie n .IP "enterin effectizzle %s failed" 4
.el .IP "enterin effectizzle \f(CW%s\fR failed" 4
.IX Item "enterin effectizzle %s failed"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, switchin tha real and
effectizzle uidz or gidz failed.
.ie n .IP "%ENV be aliased ta %s" 4
.el .IP "\f(CW%ENV\fR be aliased ta \f(CW%s\fR" 4
.IX Item "%ENV be aliased ta %s"
(F) Yo ass is hustlin under taint mode, n' tha \f(CW%ENV\fR variable has been
aliased ta another hash, so it don't reflect no mo' tha state of the
programz environment.  This is potentially insecure.
.ie n .IP "Error convertin file justification %s" 4
.el .IP "Error convertin file justification \f(CW%s\fR" 4
.IX Item "Error convertin file justification %s"
(F) An error peculiar ta \s-1VMS. \s0 Because Perl may gotta deal wit file
specifications up in either \s-1VMS\s0 or Unix syntax, it converts dem ta a
single form when it must operate on dem directly.  Either you've passed
an invalid file justification ta Perl, or you've found a cold-ass lil case the
conversion routines don't handle.  Drat.
.IP "Escape literal pattern white space under /x" 4
.IX Item "Escape literal pattern white space under /x"
(D deprecated) Yo ass compiled a regular expression pattern wit \f(CW\*(C`/x\*(C'\fR to
ignore white space, n' you used, as a literal, one of tha characters
that Perl plans ta eventually treat as white space.  Da characta must
be escaped somehow, or it will work differently on a gangbangin' future Perl that
does treat it as white space.  Da easiest way is ta bang a funky-ass backslash
immediately before it, or ta enclose it wit square brackets, n' you can put dat on yo' toast.  This
change is ta brang Perl tha fuck into conformizzle wit Unicode recommendations.
Here is tha five charactas dat generate dis warning:
U+0085 \s-1NEXT LINE,
U+200E\s0 LEFT-TO-RIGHT \s-1MARK,
U+200F\s0 RIGHT-TO-LEFT \s-1MARK,
U+2028 LINE SEPARATOR,\s0
and
U+2029 \s-1PARAGRAPH SEPARATOR.\s0
.IP "Eval-group up in insecure regular expression" 4
.IX Item "Eval-group up in insecure regular expression"
(F) Perl detected tainted data when tryin ta compile a regular
expression dat gotz nuff tha \f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertion, which
is unsafe.  See \*(L"(?{ code })\*(R" up in perlre, n' perlsec.
.IP "Eval-group not allowed at runtime, use re 'eval' up in regex m/%s/" 4
.IX Item "Eval-group not allowed at runtime, use re 'eval' up in regex m/%s/"
(F) Perl tried ta compile a regular expression containin the
\&\f(CW\*(C`(?{ ... })\*(C'\fR zero-width assertion at run time, as it would when the
pattern gotz nuff interpolated joints, n' you can put dat on yo' toast.  Since dat be a securitizzle risk,
it aint allowed. Y'all KNOW dat shit, muthafucka!  If you insist, you may still do dis by rockin the
\&\f(CW\*(C`re \*(Aqeval\*(Aq\*(C'\fR pragma or by explicitly buildin tha pattern from an
interpolated strang at run time n' rockin dat up in a \fIeval()\fR.  See
\&\*(L"(?{ code })\*(R" up in perlre.
.IP "Eval-group not allowed, use re 'eval' up in regex m/%s/" 4
.IX Item "Eval-group not allowed, use re 'eval' up in regex m/%s/"
(F) A regular expression contained tha \f(CW\*(C`(?{ ... })\*(C'\fR zero-width
assertion yo, but dat construct is only allowed when tha \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR
pragma is up in effect.  See \*(L"(?{ code })\*(R" up in perlre.
.IP "\s-1EVAL\s0 without pos chizzle exceeded limit up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "EVAL without pos chizzle exceeded limit up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a pattern dat nested too nuff \s-1EVAL\s0 calls without consuming
any text.  Restructure tha pattern so dat text is consumed.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Excessively long <> operator" 4
.IX Item "Excessively long <> operator"
(F) Da contentz of a <> operator may not exceed tha maximum size of a
Perl identifier n' shit.  If you just tryin ta glob a long-ass list of
filenames, try rockin tha \fIglob()\fR operator, or put tha filenames tha fuck into a
variable n' glob dis shit.
.IP "exec? I aint *that* kind of operatin system" 4
.IX Item "exec? I aint *that* kind of operatin system"
(F) Da \f(CW\*(C`exec\*(C'\fR function aint implemented on some systems, e.g., Symbian
\&\s-1OS. \s0 See perlport.
.ie n .IP "Execution of %s aborted cuz of compilation errors." 4
.el .IP "Execution of \f(CW%s\fR aborted cuz of compilation errors." 4
.IX Item "Execution of %s aborted cuz of compilation errors."
(F) Da final summary message when a Perl compilation fails.
.ie n .IP "Exitin eval via %s" 4
.el .IP "Exitin eval via \f(CW%s\fR" 4
.IX Item "Exitin eval via %s"
(W exiting) Yo ass is exitin a eval by unconventionizzle means, like fuckin a
goto, or a loop control statement.
.ie n .IP "Exitin format via %s" 4
.el .IP "Exitin format via \f(CW%s\fR" 4
.IX Item "Exitin format via %s"
(W exiting) Yo ass is exitin a gangbangin' format by unconventionizzle means, like fuckin a
goto, or a loop control statement.
.ie n .IP "Exitin pseudo-block via %s" 4
.el .IP "Exitin pseudo-block via \f(CW%s\fR" 4
.IX Item "Exitin pseudo-block via %s"
(W exiting) Yo ass is exitin a rather special block construct (like a
sort block or subroutine) by unconventionizzle means, like fuckin a goto, or a
loop control statement.  See \*(L"sort\*(R" up in perlfunc.
.ie n .IP "Exitin subroutine via %s" 4
.el .IP "Exitin subroutine via \f(CW%s\fR" 4
.IX Item "Exitin subroutine via %s"
(W exiting) Yo ass is exitin a subroutine by unconventionizzle means, such
as a goto, or a loop control statement.
.ie n .IP "Exitin substitution via %s" 4
.el .IP "Exitin substitution via \f(CW%s\fR" 4
.IX Item "Exitin substitution via %s"
(W exiting) Yo ass is exitin a substitution by unconventionizzle means, such
as a return, a goto, or a loop control statement.
.IP "Expectin close bracket up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Expectin close bracket up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass freestyled suttin' like
.Sp
.Vb 1
\& (?13
.Ve
.Sp
to denote a cold-ass lil capturin crew of tha form
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR,
but omitted tha \f(CW")"\fR.
.ie n .IP "Experimenstrual ""%s"" subs not enabled" 4
.el .IP "Experimenstrual ``%s'' subs not enabled" 4
.IX Item "Experimenstrual %s subs not enabled"
(F) To use lexical subs, you must first enable them:
.Sp
.Vb 3
\&    no warnings \*(Aqexperimental::lexical_subs\*(Aq;
\&    use feature \*(Aqlexical_subs\*(Aq;
\&    mah sub foo { ... }
.Ve
.IP "Explicit blessin ta '' (assumin package main)" 4
.IX Item "Explicit blessin ta '' (assumin package main)"
(W misc) Yo ass is blessin a reference ta a zero length string.  This has
the effect of blessin tha reference tha fuck into tha package main. I aint talkin' bout chicken n' gravy biatch.  This is
usually not what tha fuck you want.  Consider providin a thugged-out default target package,
e.g. bless($ref, \f(CW$p\fR || 'MyPackage');
.ie n .IP "%s: Expression syntax" 4
.el .IP "\f(CW%s:\fR Expression syntax" 4
.IX Item "%s: Expression syntax"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead of Perl.
Peep tha #! line, or manually feed yo' script tha fuck into Perl yo ass.
.ie n .IP "%s failed\*(--call queue aborted" 4
.el .IP "\f(CW%s\fR failed\*(--call queue aborted" 4
.IX Item "%s failedcall queue aborted"
(F) An untrapped exception was raised while executin a \s-1UNITCHECK,
CHECK, INIT,\s0 or \s-1END\s0 subroutine.  Processin of tha remainder of the
queue of such routines has been prematurely ended.
.ie n .IP "False [] range ""%s"" up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "False [] range ``%s'' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "False [] range %s up in regex; marked by <-- HERE up in m/%s/"
(W regexp) A characta class range must start n' end at a literal
character, not another characta class like \f(CW\*(C`\ed\*(C'\fR or \f(CW\*(C`[:alpha:]\*(C'\fR.  Da \*(L"\-\*(R"
in yo' false range is interpreted as a literal \*(L"\-\*(R".  Consider quotin the
\&\*(L"\-\*(R", \*(L"\e\-\*(R".  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "Fatal \s-1VMS\s0 error (status=%d) at %s, line %d" 4
.el .IP "Fatal \s-1VMS\s0 error (status=%d) at \f(CW%s\fR, line \f(CW%d\fR" 4
.IX Item "Fatal VMS error (status=%d) at %s, line %d"
(P) An error peculiar ta \s-1VMS. \s0 Somethang untoward happened up in a \s-1VMS\s0
system steez or \s-1RTL\s0 routine; Perlz exit status should provide more
details.  Da filename up in \*(L"at \f(CW%s\fR\*(R" n' tha line number up in \*(L"line \f(CW%d\fR\*(R" tell
you which section of tha Perl source code is distressed.
.IP "fcntl aint implemented" 4
.IX Item "fcntl aint implemented"
(F) Yo crazy-ass machine apparently don't implement \fIfcntl()\fR.  What tha fuck iz this, a
\&\s-1PDP\-11\s0 or something?
.IP "\s-1FETCHSIZE\s0 returned a wack value" 4
.IX Item "FETCHSIZE returned a wack value"
(F) A tied array fronted ta git a wack number of elements, which
is not possible.
.IP "Field too wide up in 'u' format up in pack" 4
.IX Item "Field too wide up in 'u' format up in pack"
(W pack) Each line up in a uuencoded strang starts wit a length indicator
which can't encode joints above 63.  So there is no point up in askin for
a line length bigger than dis shit.  Perl will behave as if you specified
\&\f(CW\*(C`u63\*(C'\fR as tha format.
.ie n .IP "Filehandle %s opened only fo' input" 4
.el .IP "Filehandle \f(CW%s\fR opened only fo' input" 4
.IX Item "Filehandle %s opened only fo' input"
(W io) Yo ass tried ta write on a read-only filehandle.  If you intended
it ta be a read-write filehandle, you needed ta open it wit \*(L"+<\*(R" or
\&\*(L"+>\*(R" or \*(L"+>>\*(R" instead of wit \*(L"<\*(R" or nothing.  If you intended only to
write tha file, use \*(L">\*(R" or \*(L">>\*(R".  See \*(L"open\*(R" up in perlfunc.
.ie n .IP "Filehandle %s opened only fo' output" 4
.el .IP "Filehandle \f(CW%s\fR opened only fo' output" 4
.IX Item "Filehandle %s opened only fo' output"
(W io) Yo ass tried ta read from a gangbangin' filehandle opened only fo' writing, If
you intended it ta be a read/write filehandle, you needed ta open it
with \*(L"+<\*(R" or \*(L"+>\*(R" or \*(L"+>>\*(R" instead of wit \*(L">\*(R".  If you intended only to
read from tha file, use \*(L"<\*(R".  See \*(L"open\*(R" up in perlfunc.  Another possibility
is dat you attempted ta open filedescriptor 0 (also known as \s-1STDIN\s0) for
output (maybe you closed \s-1STDIN\s0 earlier?).
.ie n .IP "Filehandle %s reopened as %s only fo' input" 4
.el .IP "Filehandle \f(CW%s\fR reopened as \f(CW%s\fR only fo' input" 4
.IX Item "Filehandle %s reopened as %s only fo' input"
(W io) Yo ass opened fo' readin a gangbangin' filehandle dat gots tha same filehandle id
as \s-1STDOUT\s0 or \s-1STDERR. \s0 This occurred cuz you closed \s-1STDOUT\s0 or \s-1STDERR\s0
previously.
.ie n .IP "Filehandle \s-1STDIN\s0 reopened as %s only fo' output" 4
.el .IP "Filehandle \s-1STDIN\s0 reopened as \f(CW%s\fR only fo' output" 4
.IX Item "Filehandle STDIN reopened as %s only fo' output"
(W io) Yo ass opened fo' freestylin a gangbangin' filehandle dat gots tha same filehandle id
as \s-1STDIN. \s0 This occurred cuz you closed \s-1STDIN\s0 previously.
.ie n .IP "Final $ should be \e$ or $name" 4
.el .IP "Final $ should be \e$ or \f(CW$name\fR" 4
.IX Item "Final $ should be $ or $name"
(F) Yo ass must now decizzle whether tha final $ up in a strang was meant ta be
a literal dollar sign, or was meant ta introduce a variable name that
happens ta be missing.  So you gotta put either tha backslash or the
name.
.ie n .IP "\fIflock()\fR on closed filehandle %s" 4
.el .IP "\fIflock()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "flock() on closed filehandle %s"
(W closed) Da filehandle you attemptin ta \fIflock()\fR gots itself closed
some time before now, nahmeean?  Peep yo' control flow.  \fIflock()\fR operates on
filehandles.  Is you attemptin ta booty-call \fIflock()\fR on a gangbangin' finger-lickin' dirhandle by the
same name?
.IP "Format not terminated" 4
.IX Item "Format not terminated"
(F) A format must be terminated by a line wit a solitary dot.  Perl got
to tha end of yo' file without findin such a line.
.ie n .IP "Format %s redefined" 4
.el .IP "Format \f(CW%s\fR redefined" 4
.IX Item "Format %s redefined"
(W redefine) Yo ass redefined a gangbangin' format.  To suppress dis warning, say
.Sp
.Vb 4
\&    {
\&        no warnings \*(Aqredefine\*(Aq;
\&        eval "format NAME =...";
\&    }
.Ve
.IP "Found = up in conditional, should be ==" 4
.IX Item "Found = up in conditional, should be =="
(W syntax) Yo ass holla'd
.Sp
.Vb 1
\&    if ($foo = 123)
.Ve
.Sp
when you meant
.Sp
.Vb 1
\&    if ($foo == 123)
.Ve
.Sp
(or suttin' like that).
.ie n .IP "%s found where operator expected" 4
.el .IP "\f(CW%s\fR found where operator expected" 4
.IX Item "%s found where operator expected"
(S syntax) Da Perl lexer knows whether ta expect a term or a operator.
If it sees what tha fuck it knows ta be a term when dat shiznit was expectin ta peep an
operator, it gives you dis warning.  Usually it indicates dat an
operator or delimita was omitted, like fuckin a semicolon.
.ie n .IP "gdbm store returned %d, errno %d, key ""%s""" 4
.el .IP "gdbm store returned \f(CW%d\fR, errno \f(CW%d\fR, key ``%s''" 4
.IX Item "gdbm store returned %d, errno %d, key %s"
(S) A warnin from tha GDBM_File extension dat a store failed.
.IP "gethostent not implemented" 4
.IX Item "gethostent not implemented"
(F) Yo crazy-ass C library apparently don't implement \fIgethostent()\fR, probably
because if it did, it'd feel morally obligated ta return every last muthafuckin hostname
on tha Internet.
.ie n .IP "get%\fIsname()\fR on closed socket %s" 4
.el .IP "get%\fIsname()\fR on closed socket \f(CW%s\fR" 4
.IX Item "get%sname() on closed socket %s"
(W closed) Yo ass tried ta git a socket or peer socket name on a cold-ass lil closed
socket.  Did yo dirty ass forget ta check tha return value of yo' \fIsocket()\fR call?
.ie n .IP "getpwnam returned invalid \s-1UIC\s0 %#o fo' user ""%s""" 4
.el .IP "getpwnam returned invalid \s-1UIC\s0 %#o fo' user ``%s''" 4
.IX Item "getpwnam returned invalid UIC %#o fo' user %s"
(S) A warnin peculiar ta \s-1VMS. \s0 Da call ta \f(CW\*(C`sys$getuai\*(C'\fR underlyin the
\&\f(CW\*(C`getpwnam\*(C'\fR operator returned a invalid \s-1UIC.\s0
.ie n .IP "\fIgetsockopt()\fR on closed socket %s" 4
.el .IP "\fIgetsockopt()\fR on closed socket \f(CW%s\fR" 4
.IX Item "getsockopt() on closed socket %s"
(W closed) Yo ass tried ta git a socket option on a cold-ass lil closed socket.  Did you
forget ta check tha return value of yo' \fIsocket()\fR call?  See
\&\*(L"getsockopt\*(R" up in perlfunc.
.IP "given is experimental" 4
.IX Item "given is experimental"
(S experimental::smartmatch) \f(CW\*(C`given\*(C'\fR dependz on both a lexical \f(CW$_\fR and
smartmatch, both of which is experimental, so its behavior may chizzle or
even be removed up in any future release of perl.
See tha explanation under \*(L"Experimenstrual Details on given n' when\*(R" up in perlsyn.
.ie n .IP "Global symbol ""%s"" requires explicit package name" 4
.el .IP "Global symbol ``%s'' requires explicit package name" 4
.IX Item "Global symbol %s requires explicit package name"
(F) You've holla'd \*(L"use strict\*(R" or \*(L"use strict vars\*(R", which indicates 
that all variablez must either be lexically scoped (usin \*(L"my\*(R" or \*(L"state\*(R"), 
declared beforehand rockin \*(L"our\*(R", or explicitly qualified ta say 
which package tha global variable is up in (usin \*(L"::\*(R").
.IP "glob failed (%s)" 4
.IX Item "glob failed (%s)"
(S glob) Somethang went wack wit tha external program(s) used
for \f(CW\*(C`glob\*(C'\fR n' \f(CW\*(C`<*.c>\*(C'\fR.  Usually, dis means dat you supplied a \f(CW\*(C`glob\*(C'\fR
pattern dat caused tha external program ta fail n' exit wit a
nonzero status.  If tha message indicates dat tha abnormal exit
resulted up in a cold-ass lil coredump, dis may also mean dat yo' csh (C shell)
is broken. I aint talkin' bout chicken n' gravy biatch.  If so, you should chizzle all of tha csh-related variables
in config.sh:  If you have tcsh, make tha variablez refer ta it as
if it was csh (e.g. \f(CW\*(C`full_csh=\*(Aq/usr/bin/tcsh\*(Aq\*(C'\fR); otherwise, make them
all empty (except dat \f(CW\*(C`d_csh\*(C'\fR should be \f(CW\*(Aqundef\*(Aq\fR) so dat Perl will
think csh is missing.  In either case, afta editin config.sh, run
\&\f(CW\*(C`./Configure \-S\*(C'\fR n' rebuild Perl.
.IP "Glob not terminated" 4
.IX Item "Glob not terminated"
(F) Da lexer saw a left angle bracket up in a place where dat shiznit was expecting
a term, so itz lookin fo' tha correspondin right angle bracket, and
not findin dat shit.  Chances is you left some needed parentheses out
earlier up in tha line, n' you straight-up meant a \*(L"less than\*(R".
.IP "gmtime(%f) too large" 4
.IX Item "gmtime(%f) too large"
(W overflow) Yo ass called \f(CW\*(C`gmtime\*(C'\fR wit a number dat was larger than
it can reliably handle n' \f(CW\*(C`gmtime\*(C'\fR probably returned tha wrong
date.  This warnin be also triggered wit NaN (the special
not-a-number value).
.IP "gmtime(%f) too small" 4
.IX Item "gmtime(%f) too small"
(W overflow) Yo ass called \f(CW\*(C`gmtime\*(C'\fR wit a number dat was smalla than
it can reliably handle n' \f(CW\*(C`gmtime\*(C'\fR probably returned tha wack date.
.IP "Got a error from DosAllocMem" 4
.IX Item "Got a error from DosAllocMem"
(P) An error peculiar ta \s-1OS/2. \s0 Most probably you rockin a obsolete
version of Perl, n' dis should not happen anyway.
.IP "goto must have label" 4
.IX Item "goto must have label"
(F) Unlike wit \*(L"next\*(R" or \*(L"last\*(R", you not allowed ta goto an
unspecified destination. I aint talkin' bout chicken n' gravy biatch.  See \*(L"goto\*(R" up in perlfunc.
.IP "Goto undefined subroutine%s" 4
.IX Item "Goto undefined subroutine%s"
(F) Yo ass tried ta booty-call a subroutine wit \f(CW\*(C`goto &sub\*(C'\fR syntax yo, but
the indicated subroutine aint been defined, or if it was, it
has since been undefined.
.IP "()\-group starts wit a cold-ass lil count" 4
.IX Item "()-group starts wit a cold-ass lil count"
(F) A ()\-group started wit a cold-ass lil count.  A count is supposed ta follow
something: a template characta or a ()\-group.  See \*(L"pack\*(R" up in perlfunc.
.IP "Group name must start wit a non-digit word characta up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Group name must start wit a non-digit word characta up in regex; marked by <-- HERE up in m/%s/"
(F) Group names must follow tha rulez fo' perl identifiers, meaning
they must start wit a non-digit word character n' shiznit fo' realz. A common cause of
this error is rockin (?&0) instead of (?0). Right back up in yo muthafuckin ass. See perlre.
.ie n .IP "%s had compilation errors." 4
.el .IP "\f(CW%s\fR had compilation errors." 4
.IX Item "%s had compilation errors."
(F) Da final summary message when a \f(CW\*(C`perl \-c\*(C'\fR fails.
.ie n .IP "Had ta create %s unexpectedly" 4
.el .IP "Had ta create \f(CW%s\fR unexpectedly" 4
.IX Item "Had ta create %s unexpectedly"
(S internal) A routine axed fo' a symbol from a symbol table dat ought
to have existed already yo, but fo' some reason it didn't, n' had ta be
created on a emergency basis ta prevent a cold-ass lil core dump.
.ie n .IP "Hash %%s missin tha % up in argument %d of %s()" 4
.el .IP "Hash %%s missin tha % up in argument \f(CW%d\fR of %s()" 4
.IX Item "Hash %%s missin tha % up in argument %d of %s()"
(D deprecated) Straight-Up oldschool Perl let you omit tha % on hash names up in some
spots, n' you can put dat on yo' toast.  This is now heavily deprecated.
.ie n .IP "%s has too nuff errors" 4
.el .IP "\f(CW%s\fR has too nuff errors" 4
.IX Item "%s has too nuff errors"
(F) Da parser has given up tryin ta parse tha program afta 10 errors.
Further error lyrics wannaly be uninformative.
.IP "Hexadecimal number > 0xffffffff non-portable" 4
.IX Item "Hexadecimal number > 0xffffffff non-portable"
(W portable) Da hexadecimal number you specified is larger than 2**32\-1
(4294967295) n' therefore non-portable between systems.  See
perlport fo' mo' on portabilitizzle concerns.
.IP "\-i used wit no filenames on tha command line, readin from \s-1STDIN\s0" 4
.IX Item "-i used wit no filenames on tha command line, readin from STDIN"
(S inplace) Da \f(CW\*(C`\-i\*(C'\fR option was passed on tha command line, indicating
that tha script is intended ta edit filez inplace yo, but no filez were
given. I aint talkin' bout chicken n' gravy biatch.  This is probably a mistake, since editin \s-1STDIN\s0 inplace don't
make sense, n' can be confusin cuz it can make perl look like
it is hangin when it is straight-up just tryin ta read from \s-1STDIN. \s0 You
should either pass a gangbangin' filename ta edit, or remove \f(CW\*(C`\-i\*(C'\fR from tha command
line.  See perlrun fo' mo' details.
.IP "Identifier too long" 4
.IX Item "Identifier too long"
(F) Perl limits identifiers (names fo' variables, functions, etc.) to
about 250 charactas fo' simple names, n' somewhat mo' fo' compound
names (like \f(CW$A::B\fR).  You've exceeded Perlz limits, n' you can put dat on yo' toast.  Future versions
of Perl is likely ta eliminizzle these arbitrary limitations.
.IP "Ignorin zero length \eN{} up in characta class up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Ignorin zero length N{} up in characta class up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Named Unicode characta escapes \f(CW\*(C`(\eN{...})\*(C'\fR may return a zero-length
sequence.  When such a escape is used up in a cold-ass lil characta class its
behaviour aint well defined. Y'all KNOW dat shit, muthafucka!  Peep dat tha erect escape has
been used, n' tha erect charname handlez is up in scope.
.ie n .IP "Illegal binary digit %s" 4
.el .IP "Illegal binary digit \f(CW%s\fR" 4
.IX Item "Illegal binary digit %s"
(F) Yo ass used a gangbangin' finger-lickin' digit other than 0 or 1 up in a funky-ass binary number.
.ie n .IP "Illegal binary digit %s ignored" 4
.el .IP "Illegal binary digit \f(CW%s\fR ignored" 4
.IX Item "Illegal binary digit %s ignored"
(W digit) Yo ass may have tried ta bust a gangbangin' finger-lickin' digit other than 0 or 1 up in a
binary number n' shit.  Interpretation of tha binary number stopped before the
offendin digit.
.ie n .IP "Illegal characta afta '_' up in prototype fo' %s : %s" 4
.el .IP "Illegal characta afta '_' up in prototype fo' \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Illegal characta afta '_' up in prototype fo' %s : %s"
(W illegalproto) An illegal characta was found up in a prototype declaration.
Legal charactas up in prototypes is $, @, %, *, ;, [, ], &, \e, n' +.
.IP "Illegal characta \e%o (carriage return)" 4
.IX Item "Illegal characta %o (carriage return)"
(F) Perl normally treats carriage returns up in tha program text as it
would any other whitespace, which means you should never peep dis error
when Perl was built rockin standard options.  For some reason, your
version of Perl appears ta done been built without dis support.  Talk
to yo' Perl administrator.
.ie n .IP "Illegal characta up in prototype fo' %s : %s" 4
.el .IP "Illegal characta up in prototype fo' \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Illegal characta up in prototype fo' %s : %s"
(W illegalproto) An illegal characta was found up in a prototype declaration.
Legal charactas up in prototypes is $, @, %, *, ;, [, ], &, \e, n' +.
.IP "Illegal declaration of anonymous subroutine" 4
.IX Item "Illegal declaration of anonymous subroutine"
(F) When rockin tha \f(CW\*(C`sub\*(C'\fR keyword ta construct a anonymous subroutine,
you must always specify a funky-ass block of code.  See perlsub.
.ie n .IP "Illegal declaration of subroutine %s" 4
.el .IP "Illegal declaration of subroutine \f(CW%s\fR" 4
.IX Item "Illegal declaration of subroutine %s"
(F) A subroutine was not declared erectly.  See perlsub.
.IP "Illegal division by zero" 4
.IX Item "Illegal division by zero"
(F) Yo ass tried ta divide a number by 0.  Either suttin' was wack in
your logic, or you need ta put a cold-ass lil conditionizzle up in ta guard against
meaningless input.
.ie n .IP "Illegal hexadecimal digit %s ignored" 4
.el .IP "Illegal hexadecimal digit \f(CW%s\fR ignored" 4
.IX Item "Illegal hexadecimal digit %s ignored"
(W digit) Yo ass may have tried ta bust a cold-ass lil characta other than 0 \- 9 or
A \- F, a \- f up in a hexadecimal number n' shit.  Interpretation of tha hexadecimal
number stopped before tha illegal character.
.IP "Illegal modulus zero" 4
.IX Item "Illegal modulus zero"
(F) Yo ass tried ta divide a number by 0 ta git tha remainder n' shit.  Most
numbers don't take ta dis kindly.
.IP "Illegal number of bits up in vec" 4
.IX Item "Illegal number of bits up in vec"
(F) Da number of bits up in \fIvec()\fR (the third argument) must be a juice of
two from 1 ta 32 (or 64, if yo' platform supports that).
.ie n .IP "Illegal octal digit %s" 4
.el .IP "Illegal octal digit \f(CW%s\fR" 4
.IX Item "Illegal octal digit %s"
(F) Yo ass used a 8 or 9 up in a octal number.
.ie n .IP "Illegal octal digit %s ignored" 4
.el .IP "Illegal octal digit \f(CW%s\fR ignored" 4
.IX Item "Illegal octal digit %s ignored"
(W digit) Yo ass may have tried ta use a 8 or 9 up in a octal number.
Interpretation of tha octal number stopped before tha 8 or 9.
.IP "Illegal pattern up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Illegal pattern up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass freestyled suttin' like
.Sp
.Vb 1
\& (?+foo)
.Ve
.Sp
Da \f(CW"+"\fR is valid only when followed by digits, indicatin a
capturin group.  See
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR.
.IP "Illegal switch up in \s-1PERL5OPT:\s0 \-%c" 4
.IX Item "Illegal switch up in PERL5OPT: -%c"
(X) Da \s-1PERL5OPT\s0 environment variable may only be used ta set the
followin switches: \fB\-[CDIMUdmtw]\fR.
.ie n .IP "Ill-formed \s-1CRTL\s0 environ value ""%s""" 4
.el .IP "Ill-formed \s-1CRTL\s0 environ value ``%s''" 4
.IX Item "Ill-formed CRTL environ value %s"
(W internal) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read tha \s-1CRTL\s0's
internal environ array, n' encountered a element without tha \f(CW\*(C`=\*(C'\fR
delimita used ta separate keys from joints, n' you can put dat on yo' toast.  Da element is ignored.
.IP "Ill-formed message up in prime_env_iter: |%s|" 4
.IX Item "Ill-formed message up in prime_env_iter: |%s|"
(W internal) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read a logical
name or \s-1CLI\s0 symbol definizzle when preparin ta iterate over \f(CW%ENV\fR, and
didn't peep tha expected delimita between key n' value, so tha line was
ignored.
.ie n .IP "(in cleanup) %s" 4
.el .IP "(in cleanup) \f(CW%s\fR" 4
.IX Item "(in cleanup) %s"
(W misc) This prefix probably indicates dat a \s-1\fIDESTROY\s0()\fR method raised
the indicated exception. I aint talkin' bout chicken n' gravy biatch.  Since destructors is probably called by the
system at arbitrary points durin execution, n' often a vast number of
times, tha warnin is issued only once fo' any number of failures that
would otherwise result up in tha same message bein repeated.
.Sp
Failure of user callbacks dispatched rockin tha \f(CW\*(C`G_KEEPERR\*(C'\fR flag could
also result up in dis warning.  See \*(L"G_KEEPERR\*(R" up in perlcall.
.IP "In '(*VERB...)', splittin tha initial '(*' is deprecated up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "In '(*VERB...)', splittin tha initial '(*' is deprecated up in regex; marked by <-- HERE up in m/%s/"
(D regexp, deprecated)
Da two-characta sequence \f(CW"(*"\fR up in dis context up in a regular
expression pattern should be a indivisible token, wit nothing
intervenin between tha \f(CW"("\fR n' tha \f(CW"*"\fR yo, but you separated em.
Cuz of a accident of implementation, dis prohibizzle was not enforced,
but our phat asses do plan ta forbid it up in a gangbangin' future Perl version. I aint talkin' bout chicken n' gravy biatch.  This message
serves as givin you fair warnin of dis pendin chizzle.
.IP "In '(?...)', splittin tha initial '(?' is deprecated up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "In '(?...)', splittin tha initial '(?' is deprecated up in regex; marked by <-- HERE up in m/%s/"
(D regexp, deprecated)
Da two-characta sequence \f(CW"(?"\fR up in dis context up in a regular
expression pattern should be a indivisible token, wit nothing
intervenin between tha \f(CW"("\fR n' tha \f(CW"?"\fR yo, but you separated em.
Cuz of a accident of implementation, dis prohibizzle was not enforced,
but our phat asses do plan ta forbid it up in a gangbangin' future Perl version. I aint talkin' bout chicken n' gravy biatch.  This message
serves as givin you fair warnin of dis pendin chizzle.
.IP "Incomplete expression within '(?[ ])' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Incomplete expression within '(?[ ])' up in regex; marked by <-- HERE up in m/%s/"
(F)
There was a syntax error within tha \f(CW\*(C`(?[ ])\*(C'\fR.  This can happen if the
expression inside tha construct was straight-up empty, or if there are
too nuff or few operandz fo' tha number of operators.  Perl aint smart
enough ta hit you wit a mo' precise indication as ta what tha fuck is wrong.
.IP "Inconsistent hierarchy durin C3 merge of class '%s': mergin failed on parent '%s'" 4
.IX Item "Inconsistent hierarchy durin C3 merge of class '%s': mergin failed on parent '%s'"
(F) Da method resolution order (\s-1MRO\s0) of tha given class is not
C3\-consistent, n' you have enabled tha C3 \s-1MRO\s0 fo' dis class.  See tha C3
documentation up in mro fo' mo' shiznit.
.IP "In \s-1EBCDIC\s0 tha v\-strin components cannot exceed 2147483647" 4
.IX Item "In EBCDIC tha v-strin components cannot exceed 2147483647"
(F) An error peculiar ta \s-1EBCDIC. \s0 Internally, v\-strings is stored as
Unicode code points, n' encoded up in \s-1EBCDIC\s0 as UTF-EBCDIC.  Da UTF-EBCDIC
encodin is limited ta code points no larger than 2147483647 (0x7FFFFFFF).
.IP "Infinite recursion up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Infinite recursion up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a pattern dat references itself without consumin any input
text.  Yo ass should check tha pattern ta ensure dat recursive patterns
either consume text or fail.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Initialization of state variablez up in list context currently forbidden" 4
.IX Item "Initialization of state variablez up in list context currently forbidden"
(F) Currently tha implementation of \*(L"state\*(R" only permits the
initialization of scalar variablez up in scalar context.  Re-write
\&\f(CW\*(C`state ($a) = 42\*(C'\fR as \f(CW\*(C`state $a = 42\*(C'\fR ta chizzle from list ta scalar
context.  Constructions like fuckin \f(CW\*(C`state (@a) = foo()\*(C'\fR will be
supported up in a gangbangin' future perl release.
.ie n .IP "Insecure dependency up in %s" 4
.el .IP "Insecure dependency up in \f(CW%s\fR" 4
.IX Item "Insecure dependency up in %s"
(F) Yo ass tried ta do suttin' dat tha taintin mechanizzle didn't like.
Da taintin mechanizzle is turned on when you hustlin setuid or
setgid, or when you specify \fB\-T\fR ta turn it on explicitly.  The
taintin mechanizzle labels all data thatz derived directly or indirectly
from tha user, whoz ass is considered ta be unworthy of yo' trust.  If any
such data is used up in a \*(L"dangerous\*(R" operation, you git dis error. Shiiit, dis aint no joke.  See
perlsec fo' mo' shiznit.
.ie n .IP "Insecure directory up in %s" 4
.el .IP "Insecure directory up in \f(CW%s\fR" 4
.IX Item "Insecure directory up in %s"
(F) Yo ass can't use \fIsystem()\fR, \fIexec()\fR, or a piped open up in a setuid or
setgid script if \f(CW$ENV{PATH}\fR gotz nuff a gangbangin' finger-lickin' directory dat is writable by
the ghetto. Right back up in yo muthafuckin ass. Y'all KNOW dat shit, muthafucka!  Also, tha \s-1PATH\s0 must not contain any relatizzle directory.
See perlsec.
.ie n .IP "Insecure $ENV{%s} while hustlin %s" 4
.el .IP "Insecure \f(CW$ENV\fR{%s} while hustlin \f(CW%s\fR" 4
.IX Item "Insecure $ENV{%s} while hustlin %s"
(F) Yo ass can't use \fIsystem()\fR, \fIexec()\fR, or a piped open up in a setuid or
setgid script if any of \f(CW$ENV{PATH}\fR, \f(CW$ENV{IFS}\fR, \f(CW$ENV{CDPATH}\fR,
\&\f(CW$ENV{ENV}\fR, \f(CW$ENV{BASH_ENV}\fR or \f(CW$ENV{TERM}\fR is derived from data
supplied (or potentially supplied) by tha user n' shit.  Da script must set
the path ta a known value, rockin trustworthy data.  See perlsec.
.ie n .IP "Insecure user-defined property %s" 4
.el .IP "Insecure user-defined property \f(CW%s\fR" 4
.IX Item "Insecure user-defined property %s"
(F) Perl detected tainted data when tryin ta compile a regular
expression dat gotz nuff a cold-ass lil call ta a user-defined characta property
function, i.e. \f(CW\*(C`\ep{IsFoo}\*(C'\fR or \f(CW\*(C`\ep{InFoo}\*(C'\fR.
See \*(L"User-Defined Characta Properties\*(R" up in perlunicode n' perlsec.
.ie n .IP "Integer overflow up in format strang fo' %s" 4
.el .IP "Integer overflow up in format strang fo' \f(CW%s\fR" 4
.IX Item "Integer overflow up in format strang fo' %s"
(F) Da indexes n' widths specified up in tha format strang of \f(CW\*(C`printf()\*(C'\fR
or \f(CW\*(C`sprintf()\*(C'\fR is too large.  Da numbers must not overflow tha size of
integers fo' yo' architecture.
.ie n .IP "Integer overflow up in %s number" 4
.el .IP "Integer overflow up in \f(CW%s\fR number" 4
.IX Item "Integer overflow up in %s number"
(S overflow) Da hexadecimal, octal or binary number you have specified
either as a literal or as a argument ta \fIhex()\fR or \fIoct()\fR is too big-ass for
your architecture, n' has been converted ta a gangbangin' floatin point number.
On a 32\-bit architecture tha phattest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note dat Perl
transparently promotes all numbers ta a gangbangin' floatin point representation
internally\*(--subject ta loss of precision errors up in subsequent
operations.
.IP "Integer overflow up in srand" 4
.IX Item "Integer overflow up in srand"
(S overflow) Da number you have passed ta srand is too big-ass ta fit
in yo' architecturez integer representation. I aint talkin' bout chicken n' gravy biatch.  Da number has been
replaced wit tha phattest integer supported (0xFFFFFFFF on 32\-bit
architectures).  This means you may be gettin less randomnizz than
you expect, cuz different random seedz above tha maximum will
return tha same sequence of random numbers.
.IP "Integer overflow up in version" 4
.IX Item "Integer overflow up in version"
.PD 0
.ie n .IP "Integer overflow up in version %d" 4
.el .IP "Integer overflow up in version \f(CW%d\fR" 4
.IX Item "Integer overflow up in version %d"
.PD
(W overflow) Some portion of a version initialization is too big-ass for
the size of integers fo' yo' architecture.  This aint a warning
because there is no rationizzle reason fo' a version ta try n' use an
element larger than typically 2**32.  This is probably caused by trying
to use some odd mathematical operation as a version, like 100/9.
.IP "Internal disasta up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Internal disasta up in regex; marked by <-- HERE up in m/%s/"
(P) Somethang went badly wack up in tha regular expression parser.
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Internal inconsistency up in trackin vforks" 4
.IX Item "Internal inconsistency up in trackin vforks"
(S) A warnin peculiar ta \s-1VMS. \s0 Perl keeps track of tha number of times
you've called \f(CW\*(C`fork\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR, ta determine whether tha current call
to \f(CW\*(C`exec\*(C'\fR should affect tha current script or a subprocess (see
\&\*(L"exec \s-1LIST\*(R"\s0 up in perlvms).  Somehow, dis count has become scrambled, so
Perl is bustin a guess n' treatin dis \f(CW\*(C`exec\*(C'\fR as a request to
terminizzle tha Perl script n' execute tha specified command.
.IP "Internal urp up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Internal urp up in regex; marked by <-- HERE up in m/%s/"
(P) Somethang went badly awry up in tha regular expression parser n' shit.  The
<\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.ie n .IP "%s (...) interpreted as function" 4
.el .IP "\f(CW%s\fR (...) interpreted as function" 4
.IX Item "%s (...) interpreted as function"
(W syntax) You've run afoul of tha rule dat say dat any list operator
followed by parentheses turns tha fuck into a gangbangin' function, wit all tha list
operators arguments found inside tha parentheses.  See
\&\*(L"Terms n' List Operators (Leftward)\*(R" up in perlop.
.ie n .IP "Invalid %s attribute: %s" 4
.el .IP "Invalid \f(CW%s\fR attribute: \f(CW%s\fR" 4
.IX Item "Invalid %s attribute: %s"
(F) Da indicated attribute fo' a subroutine or variable was not recognized
by Perl or by a user-supplied handlez n' shit.  See attributes.
.ie n .IP "Invalid %s attributes: %s" 4
.el .IP "Invalid \f(CW%s\fR attributes: \f(CW%s\fR" 4
.IX Item "Invalid %s attributes: %s"
(F) Da indicated attributes fo' a subroutine or variable was not
recognized by Perl or by a user-supplied handlez n' shit.  See attributes.
.ie n .IP "Invalid [] range ""%*.*s"" up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Invalid [] range ``%*.*s'' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Invalid [] range %*.*s up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass freestyled suttin' like
.Sp
.Vb 1
\& [z\-a]
.Ve
.Sp
in a regular expression pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Ranges must be specified wit the
lowest code point first.  Instead write
.Sp
.Vb 1
\& [a\-z]
.Ve
.IP "Invalid characta up in \eN{...}; marked by <\-\- \s-1HERE\s0 up in \eN{%s}" 4
.IX Item "Invalid characta up in N{...}; marked by <-- HERE up in N{%s}"
(F) Only certain charactas is valid fo' characta names.  The
indicated one aint.  See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 up in charnames.
.IP "Invalid characta up in charnames alias definition; marked by <\-\- \s-1HERE\s0 up in '%s" 4
.IX Item "Invalid characta up in charnames alias definition; marked by <-- HERE up in '%s"
(F) Yo ass tried ta create a cold-ass lil custom alias fo' a cold-ass lil characta name, with
the \f(CW\*(C`:alias\*(C'\fR option ta \f(CW\*(C`use charnames\*(C'\fR n' tha specified characta in
the indicated name aint valid. Y'all KNOW dat shit, muthafucka!  See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 up in charnames.
.ie n .IP "Invalid conversion up in %s: ""%s""" 4
.el .IP "Invalid conversion up in \f(CW%s:\fR ``%s''" 4
.IX Item "Invalid conversion up in %s: %s"
(W printf) Perl do not KNOW tha given format conversion. I aint talkin' bout chicken n' gravy biatch.  See
\&\*(L"sprintf\*(R" up in perlfunc.
.IP "Invalid escape up in tha specified encodin up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Invalid escape up in tha specified encodin up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Da numeric escape (for example \f(CW\*(C`\exHH\*(C'\fR) of value < 256
didn't correspond ta a single characta all up in tha conversion
from tha encodin specified by tha encodin pragma.
Da escape was replaced wit \s-1REPLACEMENT CHARACTER \s0(U+FFFD) instead.
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
escape was discovered.
.IP "Invalid hexadecimal number up in \eN{U+...}" 4
.IX Item "Invalid hexadecimal number up in N{U+...}"
.PD 0
.IP "Invalid hexadecimal number up in \eN{U+...} up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Invalid hexadecimal number up in N{U+...} up in regex; marked by <-- HERE up in m/%s/"
.PD
(F) Da characta constant represented by \f(CW\*(C`...\*(C'\fR aint a valid hexadecimal
number n' shit.  Either it is empty, or you tried ta bust a cold-ass lil characta other than
0 \- 9 or A \- F, a \- f up in a hexadecimal number.
.ie n .IP "Invalid module name %s wit \-%c option: gotz nuff single ':'" 4
.el .IP "Invalid module name \f(CW%s\fR wit \-%c option: gotz nuff single ':'" 4
.IX Item "Invalid module name %s wit -%c option: gotz nuff single ':'"
(F) Da module argument ta perlz \fB\-m\fR n' \fB\-M\fR command-line options
cannot contain single colons up in tha module name yo, but only up in the
arguments afta \*(L"=\*(R".  In other lyrics, \fB\-MFoo::Bar=:baz\fR be aiiight yo, but
\&\fB\-MFoo:Bar=baz\fR is not.
.IP "Invalid mro name: '%s'" 4
.IX Item "Invalid mro name: '%s'"
(F) Yo ass tried ta \f(CW\*(C`mro::set_mro("classname", "foo")\*(C'\fR or \f(CW\*(C`use mro \*(Aqfoo\*(Aq\*(C'\fR,
where \f(CW\*(C`foo\*(C'\fR aint a valid method resolution order (\s-1MRO\s0).  Currently,
the only valid ones supported is \f(CW\*(C`dfs\*(C'\fR n' \f(CW\*(C`c3\*(C'\fR, unless you have loaded
a module dat be a \s-1MRO\s0 plugin. I aint talkin' bout chicken n' gravy biatch.  See mro n' perlmroapi.
.IP "Invalid wack number (%s) up in chr" 4
.IX Item "Invalid wack number (%s) up in chr"
(W utf8) Yo ass passed a wack number ta \f(CW\*(C`chr\*(C'\fR.  Negatizzle numbers are
not valid charactas numbers, so it return tha Unicode replacement
characta (U+FFFD).
.IP "invalid option \-D%c, use \-D'' ta peep chizzles" 4
.IX Item "invalid option -D%c, use -D'' ta peep chizzles"
(S debugging) Perl was called wit invalid debugger flags.  Call perl
with tha \fB\-D\fR option wit no flags ta peep tha list of aaight joints.
See also \*(L"\-Dletters\*(R" up in perlrun.
.ie n .IP "Invalid [] range ""%s"" up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Invalid [] range ``%s'' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Invalid [] range %s up in regex; marked by <-- HERE up in m/%s/"
(F) Da range specified up in a cold-ass lil characta class had a minimum character
greata than tha maximum character n' shit.  One possibilitizzle is dat you forgot the
\&\f(CW\*(C`{}\*(C'\fR from yo' endin \f(CW\*(C`\ex{}\*(C'\fR \- \f(CW\*(C`\ex\*(C'\fR without tha curly braces can go only
up ta \f(CW\*(C`ff\*(C'\fR.  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "Invalid range ""%s"" up in transliteration operator" 4
.el .IP "Invalid range ``%s'' up in transliteration operator" 4
.IX Item "Invalid range %s up in transliteration operator"
(F) Da range specified up in tha tr/// or y/// operator had a minimum
characta pimped outa than tha maximum character n' shit.  See perlop.
.ie n .IP "Invalid separator characta %s up in attribute list" 4
.el .IP "Invalid separator characta \f(CW%s\fR up in attribute list" 4
.IX Item "Invalid separator characta %s up in attribute list"
(F) Somethang other than a cold-ass lil colon or whitespace was peeped between the
elementz of a attribute list.  If tha previous attribute had a
parenthesised parameta list, like dat list was terminated too soon.
See attributes.
.ie n .IP "Invalid separator characta %s up in PerlIO layer justification %s" 4
.el .IP "Invalid separator characta \f(CW%s\fR up in PerlIO layer justification \f(CW%s\fR" 4
.IX Item "Invalid separator characta %s up in PerlIO layer justification %s"
(W layer) When pushin layers onto tha Perl I/O system, suttin' other
than a cold-ass lil colon or whitespace was peeped between tha elementz of a layer list.
If tha previous attribute had a parenthesised parameta list, like that
list was terminated too soon.
.IP "Invalid strict version format (%s)" 4
.IX Item "Invalid strict version format (%s)"
(F) A version number did not hook up tha \*(L"strict\*(R" criteria fo' versions.
A \*(L"strict\*(R" version number be a positizzle decimal number (integer or
decimal-fraction) without exponentiation or else a thugged-out dotted-decimal
v\-strin wit a leadin 'v' characta n' at least three components.
Da parenthesized text indicates which criteria was not met.
See tha version module fo' mo' details on allowed version formats.
.ie n .IP "Invalid type '%s' up in %s" 4
.el .IP "Invalid type '%s' up in \f(CW%s\fR" 4
.IX Item "Invalid type '%s' up in %s"
(F) Da given characta aint a valid pack or unpack type.
See \*(L"pack\*(R" up in perlfunc.
.Sp
(W) Da given characta aint a valid pack or unpack type but used ta be
silently ignored.
.IP "Invalid version format (%s)" 4
.IX Item "Invalid version format (%s)"
(F) A version number did not hook up tha \*(L"lax\*(R" criteria fo' versions.
A \*(L"lax\*(R" version number be a positizzle decimal number (integer or
decimal-fraction) without exponentiation or else a thugged-out dotted-decimal
v\-string.  If tha v\-strin has fewer than three components, it
must gotz a leadin 'v' character n' shit.  Otherwise, tha leadin 'v' is
optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Both decimal n' dotted-decimal versions may have a
trailin \*(L"alpha\*(R" component separated by a underscore character
afta a gangbangin' fractionizzle or dotted-decimal component.  Da parenthesized
text indicates which criteria was not met.  See tha version module
for mo' details on allowed version formats.
.IP "Invalid version object" 4
.IX Item "Invalid version object"
(F) Da internal structure of tha version object was invalid.
Perhaps tha internals was modified directly up in some way or
an arbitrary reference was pimped tha fuck into tha \*(L"version\*(R" class.
.IP "ioctl aint implemented" 4
.IX Item "ioctl aint implemented"
(F) Yo crazy-ass machine apparently don't implement \fIioctl()\fR, which is pretty
strange fo' a machine dat supports C.
.ie n .IP "\fIioctl()\fR on unopened %s" 4
.el .IP "\fIioctl()\fR on unopened \f(CW%s\fR" 4
.IX Item "ioctl() on unopened %s"
(W unopened) Yo ass tried \fIioctl()\fR on a gangbangin' filehandle dat was never opened.
Peep yo' control flow n' number of arguments.
.IP "\s-1IO\s0 layers (like '%s') unavailable" 4
.IX Item "IO layers (like '%s') unavailable"
(F) Yo crazy-ass Perl has not been configured ta have PerlIO, n' therefore
you cannot use \s-1IO\s0 layers.  To have PerlIO, Perl must be configured
with 'useperlio'.
.IP "IO::Socket::atmark not implemented on dis architecture" 4
.IX Item "IO::Socket::atmark not implemented on dis architecture"
(F) Yo crazy-ass machine don't implement tha \fIsockatmark()\fR functionality,
neither as a system call nor a ioctl call (\s-1SIOCATMARK\s0).
.IP "$* is no longer supported" 4
.IX Item "$* is no longer supported"
(D deprecated, syntax) Da special variable \f(CW$*\fR, deprecated up in older
perls, has been removed az of 5.9.0 n' is no longer supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In
previous versionz of perl tha use of \f(CW$*\fR enabled or disabled multi-line
matchin within a string.
.Sp
Instead of rockin \f(CW$*\fR you should use tha \f(CW\*(C`/m\*(C'\fR (and maybe \f(CW\*(C`/s\*(C'\fR) regexp
modifiers.  Yo ass can enable \f(CW\*(C`/m\*(C'\fR fo' a lexical scope (even a whole file)
with \f(CW\*(C`use re \*(Aq/m\*(Aq\*(C'\fR.  (In olda versions: when \f(CW$*\fR was set ta a legit value
then all regular expressions behaved as if they was freestyled rockin \f(CW\*(C`/m\*(C'\fR.)
.IP "$# is no longer supported" 4
.IX Item "$# is no longer supported"
(D deprecated, syntax) Da special variable \f(CW$#\fR, deprecated up in older
perls, has been removed az of 5.9.3 n' is no longer supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  You
should use tha printf/sprintf functions instead.
.IP "'%s' aint a cold-ass lil code reference" 4
.IX Item "'%s' aint a cold-ass lil code reference"
(W overload) Da second (fourth, sixth, ...) argument of
overload::constant need ta be a cold-ass lil code reference.  Either
an anonymous subroutine, or a reference ta a subroutine.
.IP "'%s' aint a overloadable type" 4
.IX Item "'%s' aint a overloadable type"
(W overload) Yo ass tried ta overload a cold-ass lil constant type tha overload package is
unaware of.
.IP "Junk on end of regexp up in regex m/%s/" 4
.IX Item "Junk on end of regexp up in regex m/%s/"
(P) Da regular expression parser is confused.
.ie n .IP "Label not found fo' ""last %s""" 4
.el .IP "Label not found fo' ``last \f(CW%s\fR''" 4
.IX Item "Label not found fo' last %s"
(F) Yo ass named a loop ta break up of yo, but you not currently up in a loop
of dat name, not even if you count where you was called from.  See
\&\*(L"last\*(R" up in perlfunc.
.ie n .IP "Label not found fo' ""next %s""" 4
.el .IP "Label not found fo' ``next \f(CW%s\fR''" 4
.IX Item "Label not found fo' next %s"
(F) Yo ass named a loop ta continue yo, but you not currently up in a loop of
that name, not even if you count where you was called from.  See
\&\*(L"last\*(R" up in perlfunc.
.ie n .IP "Label not found fo' ""redo %s""" 4
.el .IP "Label not found fo' ``redo \f(CW%s\fR''" 4
.IX Item "Label not found fo' redo %s"
(F) Yo ass named a loop ta restart yo, but you not currently up in a loop of
that name, not even if you count where you was called from.  See
\&\*(L"last\*(R" up in perlfunc.
.ie n .IP "leavin effectizzle %s failed" 4
.el .IP "leavin effectizzle \f(CW%s\fR failed" 4
.IX Item "leavin effectizzle %s failed"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, switchin tha real and
effectizzle uidz or gidz failed.
.IP "length/code afta end of strang up in unpack" 4
.IX Item "length/code afta end of strang up in unpack"
(F) While unpacking, tha strang buffer was already used up when a unpack
length/code combination tried ta obtain mo' data.  This thangs up in dis biatch in
an undefined value fo' tha length.  See \*(L"pack\*(R" up in perlfunc.
.ie n .IP "\fIlength()\fR used on %s" 4
.el .IP "\fIlength()\fR used on \f(CW%s\fR" 4
.IX Item "length() used on %s"
(W syntax) Yo ass used \fIlength()\fR on either a array or a hash when you
probably wanted a cold-ass lil count of tha items.
.Sp
Array size can be obtained by bustin:
.Sp
.Vb 1
\&    scalar(@array);
.Ve
.Sp
Da number of shit up in a hash can be obtained by bustin:
.Sp
.Vb 1
\&    scalar(keys %hash);
.Ve
.IP "Lexin code attempted ta shiznit non\-Latin\-1 characta tha fuck into Latin\-1 input" 4
.IX Item "Lexin code attempted ta shiznit non-Latin-1 characta tha fuck into Latin-1 input"
(F) An extension be attemptin ta bang text tha fuck into tha current parse
(usin lex_stuff_pvn or similar) yo, but tried ta bang a cold-ass lil characta that
couldn't be part of tha current input.  This be a inherent pitfall
of tha stuffin mechanism, n' one of tha reasons ta avoid dat shit.  Where
it is necessary ta stuff, stuffin only plain \s-1ASCII\s0 is recommended.
.IP "Lexin code internal error (%s)" 4
.IX Item "Lexin code internal error (%s)"
(F) Lexin code supplied by a extension violated tha lexerz \s-1API\s0 up in a
detectable way.
.ie n .IP "\fIlisten()\fR on closed socket %s" 4
.el .IP "\fIlisten()\fR on closed socket \f(CW%s\fR" 4
.IX Item "listen() on closed socket %s"
(W closed) Yo ass tried ta do a listen on a cold-ass lil closed socket.  Did yo dirty ass forget
to check tha return value of yo' \fIsocket()\fR call?  See
\&\*(L"listen\*(R" up in perlfunc.
.IP "List form of piped open not implemented" 4
.IX Item "List form of piped open not implemented"
(F) On some platforms, notably Windows, tha three-or-more-arguments
form of \f(CW\*(C`open\*(C'\fR do not support pipes, like fuckin \f(CW\*(C`open($pipe, \*(Aq|\-\*(Aq, @args)\*(C'\fR.
Use tha two-argument \f(CW\*(C`open($pipe, \*(Aq|prog arg1 arg2...\*(Aq)\*(C'\fR form instead.
.IP "localtime(%f) too large" 4
.IX Item "localtime(%f) too large"
(W overflow) Yo ass called \f(CW\*(C`localtime\*(C'\fR wit a number dat was larger
than it can reliably handle n' \f(CW\*(C`localtime\*(C'\fR probably returned the
wrong date.  This warnin be also triggered wit NaN (the special
not-a-number value).
.IP "localtime(%f) too small" 4
.IX Item "localtime(%f) too small"
(W overflow) Yo ass called \f(CW\*(C`localtime\*(C'\fR wit a number dat was smaller
than it can reliably handle n' \f(CW\*(C`localtime\*(C'\fR probably returned the
wrong date.
.ie n .IP "Lookbehind longer than %d not implemented up in regex m/%s/" 4
.el .IP "Lookbehind longer than \f(CW%d\fR not implemented up in regex m/%s/" 4
.IX Item "Lookbehind longer than %d not implemented up in regex m/%s/"
(F) There is currently a limit on tha length of strang which lookbehind can
handle.  This restriction may be eased up in a gangbangin' future release.
.ie n .IP "Lost precision when %s %f by 1" 4
.el .IP "Lost precision when \f(CW%s\fR \f(CW%f\fR by 1" 4
.IX Item "Lost precision when %s %f by 1"
(W imprecision) Da value you attempted ta increment or decrement by one
is too big-ass fo' tha underlyin floatin point representation ta store
accurately, hence tha target of \f(CW\*(C`++\*(C'\fR or \f(CW\*(C`\-\-\*(C'\fR is unchanged. Y'all KNOW dat shit, muthafucka!  Perl thangs this
warnin cuz it has already switched from integers ta floatin point
when joints is too big-ass fo' integers, n' now even floatin point is
insufficient.  Yo ass may wish ta switch ta rockin Math::BigInt explicitly.
.IP "\fIlstat()\fR on filehandle%s" 4
.IX Item "lstat() on filehandle%s"
(W io) Yo ass tried ta do a lstat on a gangbangin' filehandle.  What did you mean
by that?  \fIlstat()\fR make sense only on filenames.  (Perl did a \fIfstat()\fR
instead on tha filehandle.)
.ie n .IP "lvalue attribute %s already-defined subroutine" 4
.el .IP "lvalue attribute \f(CW%s\fR already-defined subroutine" 4
.IX Item "lvalue attribute %s already-defined subroutine"
(W misc) Although attributes.pm allows this, turnin tha lvalue
attribute on or off on a Perl subroutine dat be already defined
does not always work properly.  It may or may not do what tha fuck you
want, dependin on what tha fuck code is inside tha subroutine, wit exact
details subject ta chizzle between Perl versions.  Only do this
if you straight-up know what tha fuck yo ass is bustin.
.IP "lvalue attribute ignored afta tha subroutine has been defined" 4
.IX Item "lvalue attribute ignored afta tha subroutine has been defined"
(W misc) Usin tha \f(CW\*(C`:lvalue\*(C'\fR declaratizzle syntax ta cook up a Perl
subroutine a lvalue subroutine afta it has been defined is
not permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  To make tha subroutine a lvalue subroutine,
add tha lvalue attribute ta tha definition, or put tha \f(CW\*(C`sub
foo :lvalue;\*(C'\fR declaration before tha definition.
.Sp
See also attributes.pm.
.IP "Malformed integer up in [] up in pack" 4
.IX Item "Malformed integer up in [] up in pack"
(F) Between tha brackets enclosin a numeric repeat count only digits
are permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \*(L"pack\*(R" up in perlfunc.
.IP "Malformed integer up in [] up in unpack" 4
.IX Item "Malformed integer up in [] up in unpack"
(F) Between tha brackets enclosin a numeric repeat count only digits
are permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \*(L"pack\*(R" up in perlfunc.
.IP "Malformed \s-1PERLLIB_PREFIX\s0" 4
.IX Item "Malformed PERLLIB_PREFIX"
(F) An error peculiar ta \s-1OS/2.  PERLLIB_PREFIX\s0 should be of tha form
.Sp
.Vb 1
\&    prefix1;prefix2
.Ve
.Sp
or
    prefix1 prefix2
.Sp
with nonempty prefix1 n' prefix2.  If \f(CW\*(C`prefix1\*(C'\fR is indeed a prefix of
a builtin library search path, prefix2 is substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da error may
appear if components is not found, or is too long.  See
\&\*(L"\s-1PERLLIB_PREFIX\*(R"\s0 up in perlos2.
.ie n .IP "Malformed prototype fo' %s: %s" 4
.el .IP "Malformed prototype fo' \f(CW%s:\fR \f(CW%s\fR" 4
.IX Item "Malformed prototype fo' %s: %s"
(F) Yo ass tried ta bust a gangbangin' function wit a malformed prototype.  The
syntax of function prototypes is given a funky-ass brief compile-time check for
obvious errors like invalid characters.  A mo' rigorous check is run
when tha function is called.
.IP "Malformed \s-1UTF\-8\s0 characta (%s)" 4
.IX Item "Malformed UTF-8 characta (%s)"
(S utf8)(F) Perl detected a strang dat didn't comply wit \s-1UTF\-8\s0
encodin rules, even though it had tha \s-1UTF8\s0 flag on.
.Sp
One possible cause is dat you set tha \s-1UTF8\s0 flag yo ass fo' data that
you thought ta be up in \s-1UTF\-8\s0 but it wasn't (it was fo' example legacy
8\-bit data).  To guard against this, you can use Encode::decode_utf8.
.Sp
If you use tha \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR PerlIO layer fo' input, invalid byte
sequences is handled gracefully yo, but if you use \f(CW\*(C`:utf8\*(C'\fR, tha flag is
set without valipimpin tha data, possibly resultin up in dis error
message.
.Sp
See also \*(L"Handlin Malformed Data\*(R" up in Encode.
.IP "Malformed \s-1UTF\-8\s0 characta immediately afta '%s'" 4
.IX Item "Malformed UTF-8 characta immediately afta '%s'"
(F) Yo ass holla'd \f(CW\*(C`use utf8\*(C'\fR yo, but tha program file don't comply wit \s-1UTF\-8\s0
encodin rules.  Da message prints up tha properly encoded characters
just before tha straight-up original gangsta wack one.  If \f(CW\*(C`utf8\*(C'\fR warnings is enabled, a
warnin is generated dat gives mo' details bout tha type of
malformation.
.IP "Malformed \s-1UTF\-8\s0 returned by \eN{%s} immediately afta '%s'" 4
.IX Item "Malformed UTF-8 returned by N{%s} immediately afta '%s'"
(F) Da charnames handlez returned malformed \s-1UTF\-8.\s0
.IP "Malformed \s-1UTF\-8\s0 strang up in '%c' format up in unpack" 4
.IX Item "Malformed UTF-8 strang up in '%c' format up in unpack"
(F) Yo ass tried ta unpack suttin' dat didn't comply wit \s-1UTF\-8\s0 encoding
rulez n' perl was unable ta guess how tha fuck ta make mo' progress.
.IP "Malformed \s-1UTF\-8\s0 strang up in pack" 4
.IX Item "Malformed UTF-8 strang up in pack"
(F) Yo ass tried ta pack suttin' dat didn't comply wit \s-1UTF\-8\s0 encoding
rulez n' perl was unable ta guess how tha fuck ta make mo' progress.
.IP "Malformed \s-1UTF\-8\s0 strang up in unpack" 4
.IX Item "Malformed UTF-8 strang up in unpack"
(F) Yo ass tried ta unpack suttin' dat didn't comply wit \s-1UTF\-8\s0 encoding
rulez n' perl was unable ta guess how tha fuck ta make mo' progress.
.IP "Malformed \s-1UTF\-16\s0 surrogate" 4
.IX Item "Malformed UTF-16 surrogate"
(F) Perl thought dat shiznit was readin \s-1UTF\-16\s0 encoded characta data but while
fuckin wit it Perl kicked it wit a malformed Unicode surrogate.
.ie n .IP "%s matches null strang nuff times up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "\f(CW%s\fR matches null strang nuff times up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "%s matches null strang nuff times up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Da pattern you've specified would be a infinite loop if the
regular expression engine didn't specifically check fo' dis shit.  Da <\-\- \s-1HERE\s0
shows whereabouts up in tha regular expression tha problem was discovered.
See perlre.
.IP "Maximal count of pendin signals (%u) exceeded" 4
.IX Item "Maximal count of pendin signals (%u) exceeded"
(F) Perl aborted cuz of too high a fuckin shitload of signals pending.  This
usually indicates dat yo' operatin system tried ta serve up signals
too fast (with a straight-up high priority), starvin tha perl process from
resources it would need ta reach a point where it can process signals
safely.  (See \*(L"Deferred Signals (Safe Signals)\*(R" up in perlipc.)
.ie n .IP """%s"" may clash wit future reserved word" 4
.el .IP "``%s'' may clash wit future reserved word" 4
.IX Item "%s may clash wit future reserved word"
(W) This warnin may be cuz of hustlin a perl5 script all up in a perl4
interpreter, especially if tha word dat is bein warned bout is
\&\*(L"use\*(R" or \*(L"my\*(R".
.IP "'%' may not be used up in pack" 4
.IX Item "'%' may not be used up in pack"
(F) Yo ass can't pack a strang by supplyin a cold-ass lil checksum, cuz the
checksummin process loses shiznit, n' you can't go tha other way.
See \*(L"unpack\*(R" up in perlfunc.
.ie n .IP "Method fo' operation %s not found up in package %s durin blessing" 4
.el .IP "Method fo' operation \f(CW%s\fR not found up in package \f(CW%s\fR durin blessing" 4
.IX Item "Method fo' operation %s not found up in package %s durin blessing"
(F) An attempt was made ta specify a entry up in a overloadin table that
doesn't resolve ta a valid subroutine.  See overload.
.ie n .IP "Method %s not permitted" 4
.el .IP "Method \f(CW%s\fR not permitted" 4
.IX Item "Method %s not permitted"
See Server error.
.ie n .IP "Might be a runaway multi-line %s strang startin on line %d" 4
.el .IP "Might be a runaway multi-line \f(CW%s\fR strang startin on line \f(CW%d\fR" 4
.IX Item "Might be a runaway multi-line %s strang startin on line %d"
(S) An advisory indicatin dat tha previous error may done been caused
by a missin delimita on a strang or pattern, cuz it eventually
ended earlier on tha current line.
.IP "Misplaced _ up in number" 4
.IX Item "Misplaced _ up in number"
(W syntax) An underscore (underbar) up in a numeric constant did not
separate two digits.
.ie n .IP "Missin argument up in %s" 4
.el .IP "Missin argument up in \f(CW%s\fR" 4
.IX Item "Missin argument up in %s"
(W uninitialized) A printf-type format required mo' arguments than were
supplied.
.IP "Missin argument ta \-%c" 4
.IX Item "Missin argument ta -%c"
(F) Da argument ta tha indicated command line switch must follow
immediately afta tha switch, without intervenin spaces.
.IP "Missin braces on \eN{}" 4
.IX Item "Missin braces on N{}"
.PD 0
.IP "Missin braces on \eN{} up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Missin braces on N{} up in regex; marked by <-- HERE up in m/%s/"
.PD
(F) Wrong syntax of characta name literal \f(CW\*(C`\eN{charname}\*(C'\fR within
double-quotish context.  This can also happen when there be a space
(or comment) between tha \f(CW\*(C`\eN\*(C'\fR n' tha \f(CW\*(C`{\*(C'\fR up in a regex wit tha \f(CW\*(C`/x\*(C'\fR modifier.
This modifier do not chizzle tha requirement dat tha brace immediately
follow tha \f(CW\*(C`\eN\*(C'\fR.
.IP "Missin braces on \eo{}" 4
.IX Item "Missin braces on o{}"
(F) A \f(CW\*(C`\eo\*(C'\fR must be followed immediately by a \f(CW\*(C`{\*(C'\fR up in double-quotish context.
.ie n .IP "Missin comma afta first argument ta %s function" 4
.el .IP "Missin comma afta first argument ta \f(CW%s\fR function" 4
.IX Item "Missin comma afta first argument ta %s function"
(F) While certain functions allow you ta specify a gangbangin' filehandle or an
\&\*(L"indirect object\*(R" before tha argument list, dis ain't one of em.
.IP "Missin command up in piped open" 4
.IX Item "Missin command up in piped open"
(W pipe) Yo ass used tha \f(CW\*(C`open(FH, "| command")\*(C'\fR or
\&\f(CW\*(C`open(FH, "command |")\*(C'\fR construction yo, but tha command was missin or
blank.
.IP "Missin control char name up in \ec" 4
.IX Item "Missin control char name up in c"
(F) A double-quoted strang ended wit \*(L"\ec\*(R", without tha required control
characta name.
.ie n .IP "Missin name up in ""%s sub""" 4
.el .IP "Missin name up in ``%s sub''" 4
.IX Item "Missin name up in %s sub"
(F) Da reserved syntax fo' lexically scoped subroutines requires that
they gotz a name wit which they can be found.
.IP "Missin $ on loop variable" 4
.IX Item "Missin $ on loop variable"
(F) Apparently you've been programmin up in \fBcsh\fR too much.  Variables
are always mentioned wit tha $ up in Perl, unlike up in tha shells, where it
can vary from one line ta tha next.
.ie n .IP "(Missin operator before %s?)" 4
.el .IP "(Missin operator before \f(CW%s\fR?)" 4
.IX Item "(Missin operator before %s?)"
(S syntax) This be a constipated guess made up in conjunction wit tha message
\&\*(L"%s found where operator expected\*(R".  Often tha missin operator be a cold-ass lil comma.
.IP "Missin right brace on \e%c{} up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Missin right brace on %c{} up in regex; marked by <-- HERE up in m/%s/"
(F) Missin right brace up in \f(CW\*(C`\ex{...}\*(C'\fR, \f(CW\*(C`\ep{...}\*(C'\fR, \f(CW\*(C`\eP{...}\*(C'\fR, or \f(CW\*(C`\eN{...}\*(C'\fR.
.IP "Missin right brace on \eN{} or unescaped left brace afta \eN" 4
.IX Item "Missin right brace on N{} or unescaped left brace afta N"
(F) \f(CW\*(C`\eN\*(C'\fR has two meanings.
.Sp
Da traditionizzle one has it followed by a name enclosed up in braces,
meanin tha characta (or sequence of characters) given by that
name.  Thus \f(CW\*(C`\eN{ASTERISK}\*(C'\fR be another way of freestylin \f(CW\*(C`*\*(C'\fR, valid up in both
double-quoted strings n' regular expression patterns.  In patterns,
it aint gots tha meanin a unescaped \f(CW\*(C`*\*(C'\fR do.
.Sp
Startin up in Perl 5.12.0, \f(CW\*(C`\eN\*(C'\fR also can have a additionizzle meanin (only)
in patterns, namely ta match a non-newline character n' shit.  (This is short
for \f(CW\*(C`[^\en]\*(C'\fR, n' like \f(CW\*(C`.\*(C'\fR but aint affected by tha \f(CW\*(C`/s\*(C'\fR regex modifier.)
.Sp
This can lead ta some ambiguities. Put ya muthafuckin choppers up if ya feel dis!  When \f(CW\*(C`\eN\*(C'\fR aint followed immediately
by a left brace, Perl assumes tha \f(CW\*(C`[^\en]\*(C'\fR meaning.  Also, if tha braces
form a valid quantifier like fuckin \f(CW\*(C`\eN{3}\*(C'\fR or \f(CW\*(C`\eN{5,}\*(C'\fR, Perl assumes dat this
means ta match tha given quantitizzle of non-newlines (in these examples,
3; n' 5 or more, respectively).  In all other case, where there be a
\&\f(CW\*(C`\eN{\*(C'\fR n' a matchin \f(CW\*(C`}\*(C'\fR, Perl assumes dat a cold-ass lil characta name is desired.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat if there is no matchin \f(CW\*(C`}\*(C'\fR, Perl don't give a fuck if it was
mistakenly omitted, or if \f(CW\*(C`[^\en]{\*(C'\fR was desired, n' raises dis error.
If you meant tha former, add tha right brace; if you meant tha latter,
escape tha brace wit a funky-ass backslash, like so: \f(CW\*(C`\eN\e{\*(C'\fR
.IP "Missin right curly or square bracket" 4
.IX Item "Missin right curly or square bracket"
(F) Da lexer counted mo' openin curly or square brackets than closing
ones.  As a general rule, you gonna find itz missin near tha place you
were last editing.
.IP "(Missin semicolon on previous line?)" 4
.IX Item "(Missin semicolon on previous line?)"
(S syntax) This be a constipated guess made up in conjunction wit tha message
\&\*(L"%s found where operator expected\*(R".  Don't automatically put a semicolon on
the previous line just cuz you saw dis message.
.IP "Modification of a read-only value attempted" 4
.IX Item "Modification of a read-only value attempted"
(F) Yo ass tried, directly or indirectly, ta chizzle tha value of a
constant.  Yo ass didn't, of course, try \*(L"2 = 1\*(R", cuz tha compiler
catches dis shit.  But a easy as fuck  way ta do tha same thang is:
.Sp
.Vb 2
\&    sub mod { $_[0] = 1 }
\&    mod(2);
.Ve
.Sp
Another way is ta assign ta a \fIsubstr()\fR thatz off tha end of tha string.
.Sp
Yet another way is ta assign ta a \f(CW\*(C`foreach\*(C'\fR loop \fI\s-1VAR\s0\fR when \fI\s-1VAR\s0\fR
is aliased ta a cold-ass lil constant up in tha look \fI\s-1LIST\s0\fR:
.Sp
.Vb 4
\&    $x = 1;
\&    foreach mah $n ($x, 2) {
\&        $n *= 2; # modifies tha $x yo, but fails on attempt to
\&    }            # modify tha 2
.Ve
.ie n .IP "Modification of non-creatable array value attempted, %s" 4
.el .IP "Modification of non-creatable array value attempted, \f(CW%s\fR" 4
.IX Item "Modification of non-creatable array value attempted, %s"
(F) Yo ass tried ta cook up a array value sprang tha fuck into existence, n' the
subscript was probably negative, even countin from end of tha array
backwards.
.ie n .IP "Modification of non-creatable hash value attempted, %s" 4
.el .IP "Modification of non-creatable hash value attempted, \f(CW%s\fR" 4
.IX Item "Modification of non-creatable hash value attempted, %s"
(P) Yo ass tried ta cook up a hash value sprang tha fuck into existence, n' it
couldn't be pimped fo' some peculiar reason.
.IP "Module name must be constant" 4
.IX Item "Module name must be constant"
(F) Only a funky-ass bare module name be allowed as tha straight-up original gangsta argument ta a \*(L"use\*(R".
.IP "Module name required wit \-%c option" 4
.IX Item "Module name required wit -%c option"
(F) Da \f(CW\*(C`\-M\*(C'\fR or \f(CW\*(C`\-m\*(C'\fR options say dat Perl should load some module yo, but
you omitted tha name of tha module.  Consult perlrun fo' full details
about \f(CW\*(C`\-M\*(C'\fR n' \f(CW\*(C`\-m\*(C'\fR.
.IP "Mo' than one argument ta '%s' open" 4
.IX Item "Mo' than one argument ta '%s' open"
(F) Da \f(CW\*(C`open\*(C'\fR function has been axed ta open multiple files.  This
can happen if yo ass is tryin ta open a pipe ta a cold-ass lil command dat takes a
list of arguments yo, but have forgotten ta specify a piped open mode.
See \*(L"open\*(R" up in perlfunc fo' details.
.IP "msg%s not implemented" 4
.IX Item "msg%s not implemented"
(F) Yo ass aint gots System V message \s-1IPC\s0 on yo' system.
.ie n .IP "Multidimensionizzle syntax %s not supported" 4
.el .IP "Multidimensionizzle syntax \f(CW%s\fR not supported" 4
.IX Item "Multidimensionizzle syntax %s not supported"
(W syntax) Multidimensionizzle arrays aren't freestyled like \f(CW$foo[1,2,3]\fR.
They're freestyled like \f(CW$foo[1][2][3]\fR, as up in C.
.IP "'/' must follow a numeric type up in unpack" 4
.IX Item "'/' must follow a numeric type up in unpack"
(F) Yo ass had a unpack template dat contained a '/' yo, but dis did not
follow some unpack justification producin a numeric value.
See \*(L"pack\*(R" up in perlfunc.
.ie n .IP """my sub"" not yet implemented" 4
.el .IP "``my sub'' not yet implemented" 4
.IX Item "my sub not yet implemented"
(F) Lexically scoped subroutines is not yet implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Don't try
that yet.
.ie n .IP """my"" variable %s can't be up in a package" 4
.el .IP "``my'' variable \f(CW%s\fR can't be up in a package" 4
.IX Item "my variable %s can't be up in a package"
(F) Lexically scoped variablez aren't up in a package, so it don't make
sense ta try ta declare one wit a package qualifier on tha front.  Use
\&\fIlocal()\fR if you wanna localize a package variable.
.ie n .IP "Name ""%s::%s"" used only once: possible typo" 4
.el .IP "Name ``%s::%s'' used only once: possible typo" 4
.IX Item "Name %s::%s used only once: possible typo"
(W once) Typographical errors often show up as unique variable names.
If you had a phat reason fo' havin a unique name, then just mention it
again somehow ta suppress tha message.  Da \f(CW\*(C`our\*(C'\fR declaration is
provided fo' dis purpose.
.Sp
\&\s-1NOTE:\s0 This warnin detects symbols dat done been used only once so \f(CW$c\fR, \f(CW@c\fR,
\&\f(CW%c\fR, *c, &c, sub c{}, c(), n' c (the filehandle or format) is considered
the same; if a program uses \f(CW$c\fR only once but also uses any of tha others it
will not trigger dis warning.
.IP "\eN up in a cold-ass lil characta class must be a named character: \eN{...} up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "N up in a cold-ass lil characta class must be a named character: N{...} up in regex; marked by <-- HERE up in m/%s/"
(F) Da freshly smoked up (5.12) meanin of \f(CW\*(C`\eN\*(C'\fR as \f(CW\*(C`[^\en]\*(C'\fR aint valid up in a funky-ass bracketed
characta class, fo' tha same reason dat \f(CW\*(C`.\*(C'\fR up in a cold-ass lil characta class loses
its specialness: it matches almost every last muthafuckin thang, which is probably not
what you want.
.IP "\eN{\s-1NAME\s0} must be resolved by tha lexer up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "N{NAME} must be resolved by tha lexer up in regex; marked by <-- HERE up in m/%s/"
(F) When compilin a regex pattern, a unresolved named characta or
sequence was encountered. Y'all KNOW dat shit, muthafucka!  This can happen up in any of nuff muthafuckin ways that
bypass tha lexer, like fuckin rockin single-quotish context, or a extra
backslash up in double-quotish:
.Sp
.Vb 3
\&    $re = \*(Aq\eN{SPACE}\*(Aq;  # Wrong!
\&    $re = "\e\eN{SPACE}"; # Wrong!
\&    /$re/;
.Ve
.Sp
Instead, use double-quotes wit a single backslash:
.Sp
.Vb 2
\&    $re = "\eN{SPACE}";  # ok
\&    /$re/;
.Ve
.Sp
Da lexer can be bypassed as well by bustin tha pattern from smaller
components:
.Sp
.Vb 2
\&    $re = \*(Aq\eN\*(Aq;
\&    /${re}{SPACE}/;     # Wrong!
.Ve
.Sp
It aint nuthin but not a phat scam ta split a cold-ass lil construct up in tha middle like this, n' it
doesn't work here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Instead use tha solution above.
.Sp
Finally, tha message also can happen under tha \f(CW\*(C`/x\*(C'\fR regex modifier when the
\&\f(CW\*(C`\eN\*(C'\fR is separated by spaces from tha \f(CW\*(C`{\*(C'\fR, up in which case, remove tha spaces.
.Sp
.Vb 2
\&    /\eN {SPACE}/x;      # Wrong!
\&    /\eN{SPACE}/x;       # ok
.Ve
.IP "Need exactly 3 octal digits up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Need exactly 3 octal digits up in regex; marked by <-- HERE up in m/%s/"
(F) Within \f(CW\*(C`(?[\ \ \ ])\*(C'\fR, all constants interpreted as octal need ta be
exactly 3 digits long.  This helps catch some ambiguities. Put ya muthafuckin choppers up if ya feel dis!  If your
constant is too short, add leadin zeros, like
.Sp
.Vb 3
\& (?[ [ \e078 ] ])     # Syntax error!
\& (?[ [ \e0078 ] ])    # Works
\& (?[ [ \e007 8 ] ])   # Clearer
.Ve
.Sp
Da maximum number dis construct can express is \f(CW\*(C`\e777\*(C'\fR.  If you
need a larger one, you need ta use \eo{}
instead. Y'all KNOW dat shit, muthafucka!  If you meant two separate thangs, you need ta separate them
.Sp
.Vb 4
\& (?[ [ \e7776 ] ])        # Syntax error!
\& (?[ [ \eo{7776} ] ])     # One meaning
\& (?[ [ \e777 6 ] ])       # Another meaning
\& (?[ [ \e777 \e006 ] ])    # Still another
.Ve
.IP "Negatizzle '/' count up in unpack" 4
.IX Item "Negatizzle '/' count up in unpack"
(F) Da length count obtained from a length/code unpack operation was
negative.  See \*(L"pack\*(R" up in perlfunc.
.IP "Negatizzle length" 4
.IX Item "Negatizzle length"
(F) Yo ass tried ta do a read/write/send/recv operation wit a funky-ass buffer
length dat is less than 0.  This is hard as fuck ta imagine.
.IP "Negatizzle offset ta vec up in lvalue context" 4
.IX Item "Negatizzle offset ta vec up in lvalue context"
(F) When \f(CW\*(C`vec\*(C'\fR is called up in a lvalue context, tha second argument must be
greata than or equal ta zero.
.IP "Nested quantifiers up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Nested quantifiers up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass can't quantify a quantifier without intervenin parentheses.
So thangs like ** or +* or ?* is illegal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da <\-\- \s-1HERE\s0 shows
whereabouts up in tha regular expression tha problem was discovered.
.Sp
Note dat tha minimal matchin quantifiers, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, and
\&\f(CW\*(C`??\*(C'\fR step tha fuck up ta be nested quantifiers yo, but aren't.  See perlre.
.ie n .IP "%s never introduced" 4
.el .IP "\f(CW%s\fR never introduced" 4
.IX Item "%s never introduced"
(S internal) Da symbol up in question was declared but somehow went up of
scope before it could possibly done been used.
.IP "next::method/next::can/maybe::next::method cannot find enclosin method" 4
.IX Item "next::method/next::can/maybe::next::method cannot find enclosin method"
(F) \f(CW\*(C`next::method\*(C'\fR need ta be called within tha context of a
real method up in a real package, n' it could not find such a cold-ass lil context.
See mro.
.ie n .IP "No %s allowed while hustlin setuid" 4
.el .IP "No \f(CW%s\fR allowed while hustlin setuid" 4
.IX Item "No %s allowed while hustlin setuid"
(F) Certain operations is deemed ta be too insecure fo' a setuid or
setgid script ta even be allowed ta attempt.  Generally bustin lyrics there
will be another way ta do what tha fuck you want dat is, if not secure, at least
securable.  See perlsec.
.IP "No code specified fo' \-%c" 4
.IX Item "No code specified fo' -%c"
(F) Perlz \fB\-e\fR n' \fB\-E\fR command-line options require a argument.  If
you wanna run a empty program, pass tha empty strang as a separate
argument or run a program consistin of a single 0 or 1:
.Sp
.Vb 3
\&    perl \-e ""
\&    perl \-e0
\&    perl \-e1
.Ve
.ie n .IP "No comma allowed afta %s" 4
.el .IP "No comma allowed afta \f(CW%s\fR" 4
.IX Item "No comma allowed afta %s"
(F) A list operator dat has a gangbangin' filehandle or \*(L"indirect object\*(R" is
not allowed ta git a cold-ass lil comma between dat n' tha followin arguments.
Otherwise it'd be just another one of tha arguments.
.Sp
One possible cause fo' dis is dat you sposed ta fuckin have imported
a constant ta yo' name space wit \fBuse\fR or \fBimport\fR while no such
importin took place, it may fo' example be dat yo' operating
system do not support dat particular constant.  Hopefully you did
use a explicit import list fo' tha constants you expect ta see;
please peep \*(L"use\*(R" up in perlfunc n' \*(L"import\*(R" up in perlfunc.  While an
explicit import list would probably have caught dis error earlier
it naturally do not remedy tha fact dat yo' operatin system
still do not support dat constant.  Maybe you gotz a typo in
the constantz of tha symbol import list of \fBuse\fR or \fBimport\fR or up in the
constant name all up in tha line where dis error was triggered?
.IP "No command tha fuck into which ta pipe on command line" 4
.IX Item "No command tha fuck into which ta pipe on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl handlez its own command line
redirection, n' found a '|' all up in tha end of tha command line, so it
doesn't know where you wanna pipe tha output from dis command.
.IP "No \s-1DB::DB\s0 routine defined" 4
.IX Item "No DB::DB routine defined"
(F) Da currently executin code was compiled wit tha \fB\-d\fR switch yo, but
for some reason tha current debugger (e.g. \fIperl5db.pl\fR or a \f(CW\*(C`Devel::\*(C'\fR
module) didn't define a routine ta be called all up in tha beginnin of each
statement.
.IP "No dbm on dis machine" 4
.IX Item "No dbm on dis machine"
(P) This is counted as a internal error, cuz every last muthafuckin machine should
supply dbm nowadays, cuz Perl comes wit \s-1SDBM. \s0 See SDBM_File.
.IP "No DB::sub routine defined" 4
.IX Item "No DB::sub routine defined"
(F) Da currently executin code was compiled wit tha \fB\-d\fR switch yo, but
for some reason tha current debugger (e.g. \fIperl5db.pl\fR or a \f(CW\*(C`Devel::\*(C'\fR
module) didn't define a \f(CW\*(C`DB::sub\*(C'\fR routine ta be called all up in tha beginning
of each ordinary subroutine call.
.IP "No directory specified fo' \-I" 4
.IX Item "No directory specified fo' -I"
(F) Da \fB\-I\fR command-line switch requires a gangbangin' finger-lickin' directory name as part of the
\&\fIsame\fR argument.  Use \fB\-Ilib\fR, fo' instance.  \fB\-I lib\fR won't work.
.IP "No error file afta 2> or 2>> on command line" 4
.IX Item "No error file afta 2> or 2>> on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl handlez its own command line
redirection, n' found a '2>' or a '2>>' on tha command line yo, but can't
find tha name of tha file ta which ta write data destined fo' stderr.
.IP "No crew endin characta '%c' found up in template" 4
.IX Item "No crew endin characta '%c' found up in template"
(F) A pack or unpack template has a openin '(' or '[' without its
matchin counterpart.  See \*(L"pack\*(R" up in perlfunc.
.IP "No input file afta < on command line" 4
.IX Item "No input file afta < on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl handlez its own command line
redirection, n' found a '<' on tha command line yo, but can't find the
name of tha file from which ta read data fo' stdin.
.ie n .IP "No next::method '%s' found fo' %s" 4
.el .IP "No next::method '%s' found fo' \f(CW%s\fR" 4
.IX Item "No next::method '%s' found fo' %s"
(F) \f(CW\*(C`next::method\*(C'\fR found no further instancez of dis method name
in tha remainin packagez of tha \s-1MRO\s0 of dis class.  If you don't want
it throwin a exception, use \f(CW\*(C`maybe::next::method\*(C'\fR
or \f(CW\*(C`next::can\*(C'\fR.  See mro.
.ie n .IP """no"" not allowed up in expression" 4
.el .IP "``no'' not allowed up in expression" 4
.IX Item "no not allowed up in expression"
(F) Da \*(L"no\*(R" keyword is recognized n' executed at compile time, and
returns no useful value.  See perlmod.
.IP "No output file afta > on command line" 4
.IX Item "No output file afta > on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl handlez its own command line
redirection, n' found a lone '>' all up in tha end of tha command line, so it
doesn't know where you wanted ta redirect stdout.
.IP "No output file afta > or >> on command line" 4
.IX Item "No output file afta > or >> on command line"
(F) An error peculiar ta \s-1VMS. \s0 Perl handlez its own command line
redirection, n' found a '>' or a '>>' on tha command line yo, but can't
find tha name of tha file ta which ta write data destined fo' stdout.
.ie n .IP "No package name allowed fo' variable %s up in ""our""" 4
.el .IP "No package name allowed fo' variable \f(CW%s\fR up in ``our''" 4
.IX Item "No package name allowed fo' variable %s up in our"
(F) Fully qualified variable names is not allowed up in \*(L"our\*(R"
declarations, cuz dat don't make much sense under existing
semantics.  Such syntax is reserved fo' future extensions.
.IP "No Perl script found up in input" 4
.IX Item "No Perl script found up in input"
(F) Yo ass called \f(CW\*(C`perl \-x\*(C'\fR yo, but no line was found up in tha file beginning
with #! n' containin tha word \*(L"perl\*(R".
.IP "No setregid available" 4
.IX Item "No setregid available"
(F) Configure didn't find anythang resemblin tha \fIsetregid()\fR call for
your system.
.IP "No setreuid available" 4
.IX Item "No setreuid available"
(F) Configure didn't find anythang resemblin tha \fIsetreuid()\fR call for
your system.
.ie n .IP "No such class field ""%s"" up in variable %z of type %s" 4
.el .IP "No such class field ``%s'' up in variable \f(CW%s\fR of type \f(CW%s\fR" 4
.IX Item "No such class field %s up in variable %z of type %s"
(F) Yo ass tried ta access a key from a hash all up in tha indicated typed
variable but dat key aint allowed by tha package of tha same type.
Da indicated package has restricted tha set of allowed keys rockin the
fieldz pragma.
.ie n .IP "No such class %s" 4
.el .IP "No such class \f(CW%s\fR" 4
.IX Item "No such class %s"
(F) Yo ass provided a cold-ass lil class qualifier up in a \*(L"my\*(R", \*(L"our\*(R" or \*(L"state\*(R"
declaration yo, but dis class don't exist at dis point up in yo' program.
.ie n .IP "No such hook: %s" 4
.el .IP "No such hook: \f(CW%s\fR" 4
.IX Item "No such hook: %s"
(F) Yo ass specified a signal hook dat was not recognized by Perl.
Currently, Perl accepts \f(CW\*(C`_\|_DIE_\|_\*(C'\fR n' \f(CW\*(C`_\|_WARN_\|_\*(C'\fR as valid signal hooks.
.IP "No such pipe open" 4
.IX Item "No such pipe open"
(P) An error peculiar ta \s-1VMS. \s0 Da internal routine \fImy_pclose()\fR tried to
close a pipe which hadn't been opened. Y'all KNOW dat shit, muthafucka!  This should done been caught
earlier as a attempt ta close a unopened filehandle.
.IP "No such signal: SIG%s" 4
.IX Item "No such signal: SIG%s"
(W signal) Yo ass specified a signal name as a subscript ta \f(CW%SIG\fR dat was
not recognized. Y'all KNOW dat shit, muthafucka!  Say \f(CW\*(C`kill \-l\*(C'\fR up in yo' shell ta peep tha valid signal
names on yo' system.
.IP "Not a \s-1CODE\s0 reference" 4
.IX Item "Not a CODE reference"
(F) Perl was tryin ta evaluate a reference ta a cold-ass lil code value (that is, a
subroutine) yo, but found a reference ta suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can
use tha \fIref()\fR function ta smoke up what tha fuck kind of ref it straight-up was.  See
also perlref.
.IP "Not a \s-1GLOB\s0 reference" 4
.IX Item "Not a GLOB reference"
(F) Perl was tryin ta evaluate a reference ta a \*(L"typeglob\*(R" (that is, a
symbol table entry dat be lookin like \f(CW*foo\fR) yo, but found a reference to
suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can use tha \fIref()\fR function ta smoke up what
kind of ref it straight-up was.  See perlref.
.IP "Not a \s-1HASH\s0 reference" 4
.IX Item "Not a HASH reference"
(F) Perl was tryin ta evaluate a reference ta a hash value yo, but found a
reference ta suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can use tha \fIref()\fR function to
smoke up what tha fuck kind of ref it straight-up was.  See perlref.
.IP "Not a \s-1ARRAY\s0 reference" 4
.IX Item "Not a ARRAY reference"
(F) Perl was tryin ta evaluate a reference ta a array value yo, but found
a reference ta suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can use tha \fIref()\fR function
to smoke up what tha fuck kind of ref it straight-up was.  See perlref.
.IP "Not a unblessed \s-1ARRAY\s0 reference" 4
.IX Item "Not a unblessed ARRAY reference"
(F) Yo ass passed a reference ta a pimped array ta \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`shift\*(C'\fR or
another array function. I aint talkin' bout chicken n' gravy biatch.  These only accept unblessed array references
or arrays beginnin explicitly wit \f(CW\*(C`@\*(C'\fR.
.IP "Not a \s-1SCALAR\s0 reference" 4
.IX Item "Not a SCALAR reference"
(F) Perl was tryin ta evaluate a reference ta a scalar value yo, but found
a reference ta suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can use tha \fIref()\fR function
to smoke up what tha fuck kind of ref it straight-up was.  See perlref.
.IP "Not a subroutine reference" 4
.IX Item "Not a subroutine reference"
(F) Perl was tryin ta evaluate a reference ta a cold-ass lil code value (that is, a
subroutine) yo, but found a reference ta suttin' else instead. Y'all KNOW dat shit, muthafucka!  Yo ass can
use tha \fIref()\fR function ta smoke up what tha fuck kind of ref it straight-up was.  See
also perlref.
.IP "Not a subroutine reference up in overload table" 4
.IX Item "Not a subroutine reference up in overload table"
(F) An attempt was made ta specify a entry up in a overloadin table that
doesn't somehow point ta a valid subroutine.  See overload.
.ie n .IP "Not enough arguments fo' %s" 4
.el .IP "Not enough arguments fo' \f(CW%s\fR" 4
.IX Item "Not enough arguments fo' %s"
(F) Da function requires mo' arguments than you specified.
.IP "Not enough format arguments" 4
.IX Item "Not enough format arguments"
(W syntax) A format specified mo' picture fieldz than tha next line
supplied. Y'all KNOW dat shit, muthafucka!  See perlform.
.ie n .IP "%s: not found" 4
.el .IP "\f(CW%s:\fR not found" 4
.IX Item "%s: not found"
(A) You've accidentally run yo' script all up in tha Bourne shell instead
of Perl.  Peep tha #! line, or manually feed yo' script tha fuck into Perl
yo ass.
.IP "no \s-1UTC\s0 offset shiznit; assumin local time is \s-1UTC\s0" 4
.IX Item "no UTC offset shiznit; assumin local time is UTC"
(S) A warnin peculiar ta \s-1VMS. \s0 Perl was unable ta find tha local
timezone offset, so itz assumin dat local system time is equivalent
to \s-1UTC. \s0 If itz not, define tha logical name
\&\fI\s-1SYS$TIMEZONE_DIFFERENTIAL\s0\fR ta translate ta tha number of secondz which
need ta be added ta \s-1UTC\s0 ta git local time.
.IP "Non-hex characta up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Non-hex characta up in regex; marked by <-- HERE up in m/%s/"
(F)
In a regular expression, there was a non-hexadecimal characta where
a hex one was expected, like
.Sp
.Vb 2
\& (?[ [ \exDG ] ])
\& (?[ [ \ex{DEKA} ] ])
.Ve
.ie n .IP "Non-octal characta '%c'.  Resolved as ""%s""" 4
.el .IP "Non-octal characta '%c'.  Resolved as ``%s''" 4
.IX Item "Non-octal characta '%c'. Resolved as %s"
(W digit) In parsin a octal numeric constant, a cold-ass lil characta was
unexpectedly encountered dat aint octal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da resultin value
is as indicated.
.IP "Non-octal characta up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Non-octal characta up in regex; marked by <-- HERE up in m/%s/"
(F)
In a regular expression, there was a non-octal characta where
an octal one was expected, like
.Sp
.Vb 1
\& (?[ [ \eo{1278} ] ])
.Ve
.IP "Non-strin passed as bitmask" 4
.IX Item "Non-strin passed as bitmask"
(W misc) A number has been passed as a funky-ass bitmask argument ta \fIselect()\fR.
Use tha \fIvec()\fR function ta construct tha file descriptor bitmasks for
select.  See \*(L"select\*(R" up in perlfunc.
.IP "(?[...]) not valid up in locale up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "(?[...]) not valid up in locale up in regex; marked by <-- HERE up in m/%s/"
(F)
\&\f(CW\*(C`(?[...])\*(C'\fR cannot be used within tha scope of a \f(CW\*(C`use\ locale\*(C'\fR or
with a \f(CW\*(C`/l\*(C'\fR regular expression modifier, as dat would require
deferrin ta run-time tha calculation of what tha fuck it should evaluate to, and
it is regex compile-time only.
.IP "Null filename used" 4
.IX Item "Null filename used"
(F) Yo ass can't require tha null filename, especially cuz on many
machines dat means tha current directory dawwwwg!  See \*(L"require\*(R" up in perlfunc.
.IP "\s-1NULL OP IN RUN\s0" 4
.IX Item "NULL OP IN RUN"
(S debugging) Some internal routine called \fIrun()\fR wit a null opcode
pointer.
.IP "Null picture up in formline" 4
.IX Item "Null picture up in formline"
(F) Da first argument ta formline must be a valid format picture
specification. I aint talkin' bout chicken n' gravy biatch.  Dat shiznit was found ta be empty, which probably means you
supplied it a uninitialized value.  See perlform.
.IP "Null realloc" 4
.IX Item "Null realloc"
(P) An attempt was made ta realloc \s-1NULL.\s0
.IP "\s-1NULL\s0 regexp argument" 4
.IX Item "NULL regexp argument"
(P) Da internal pattern matchin routines blew it big-ass time.
.IP "\s-1NULL\s0 regexp parameter" 4
.IX Item "NULL regexp parameter"
(P) Da internal pattern matchin routines is outta they gourd.
.IP "Number too long" 4
.IX Item "Number too long"
(F) Perl limits tha representation of decimal numbers up in programs to
about 250 characters.  You've exceeded dat length.  Future
versionz of Perl is likely ta eliminizzle dis arbitrary limitation. I aint talkin' bout chicken n' gravy biatch.  In
the meantime, try rockin scientistical notation (e.g. \*(L"1e6\*(R" instead of
\&\*(L"1_000_000\*(R").
.IP "Number wit no digits" 4
.IX Item "Number wit no digits"
(F) Perl was lookin fo' a number but found not a god damn thang dat looked like
a number n' shit.  This happens, fo' example wit \f(CW\*(C`\eo{}\*(C'\fR, wit no number between
the braces.
.ie n .IP """my %s"" used up in sort comparison" 4
.el .IP "``my \f(CW%s\fR'' used up in sort comparison" 4
.IX Item "my %s used up in sort comparison"
(W syntax) Da package variablez \f(CW$a\fR n' \f(CW$b\fR is used fo' sort comparisons.
Yo ass used \f(CW$a\fR or \f(CW$b\fR up in as a operand ta tha \f(CW\*(C`<=>\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR operator inside a
sort comparison block, n' tha variable had earlier been declared as a
lexical variable.  Either qualify tha sort variable wit tha package
name, or rename tha lexical variable.
.IP "Octal number > 037777777777 non-portable" 4
.IX Item "Octal number > 037777777777 non-portable"
(W portable) Da octal number you specified is larger than 2**32\-1
(4294967295) n' therefore non-portable between systems.  See
perlport fo' mo' on portabilitizzle concerns.
.IP "Odd number of arguments fo' overload::constant" 4
.IX Item "Odd number of arguments fo' overload::constant"
(W overload) Da call ta overload::constant contained a odd number of
arguments, n' you can put dat on yo' toast.  Da arguments should come up in pairs.
.IP "Odd number of elements up in anonymous hash" 4
.IX Item "Odd number of elements up in anonymous hash"
(W misc) Yo ass specified a odd number of elements ta initialize a hash,
which is odd, cuz hashes come up in key/value pairs.
.IP "Odd number of elements up in hash assignment" 4
.IX Item "Odd number of elements up in hash assignment"
(W misc) Yo ass specified a odd number of elements ta initialize a hash,
which is odd, cuz hashes come up in key/value pairs.
.IP "Offset outside string" 4
.IX Item "Offset outside string"
(F)(W layer) Yo ass tried ta do a read/write/send/recv/seek operation
with a offset pointin outside tha buffer n' shit.  This is hard as fuck to
imagine.  Da sole exceptions ta dis is dat zero paddin will
take place when goin past tha end of tha strang when either
\&\f(CW\*(C`sysread()\*(C'\fRin a gangbangin' file, or when seekin past tha end of a scalar opened
for I/O (in anticipation of future readz n' ta imitate tha behaviour
with real files).
.ie n .IP "%s() on unopened %s" 4
.el .IP "%s() on unopened \f(CW%s\fR" 4
.IX Item "%s() on unopened %s"
(W unopened) An I/O operation was attempted on a gangbangin' filehandle dat was
never initialized. Y'all KNOW dat shit, muthafucka!  Yo ass need ta do a \fIopen()\fR, a \fIsysopen()\fR, or a \fIsocket()\fR
call, or call a cold-ass lil constructor from tha FileHandle package.
.ie n .IP "\-%s on unopened filehandle %s" 4
.el .IP "\-%s on unopened filehandle \f(CW%s\fR" 4
.IX Item "-%s on unopened filehandle %s"
(W unopened) Yo ass tried ta invoke a gangbangin' file test operator on a gangbangin' filehandle
that aint open. I aint talkin' bout chicken n' gravy biatch.  Peep yo' control flow.  See also \*(L"\-X\*(R" up in perlfunc.
.IP "Strings wit code points over 0xFF may not be mapped tha fuck into in-memory file handles" 4
.IX Item "Strings wit code points over 0xFF may not be mapped tha fuck into in-memory file handles"
(W utf8) Yo ass tried ta open a reference ta a scalar fo' read or append
where tha scalar contained code points over 0xFF.  In-memory files
model on-disk filez n' can only contain bytes.
.IP "oops: oopsAV" 4
.IX Item "oops: oopsAV"
(S internal) An internal warnin dat tha grammar is screwed up.
.IP "oops: oopsHV" 4
.IX Item "oops: oopsHV"
(S internal) An internal warnin dat tha grammar is screwed up.
.ie n .IP "Openin dirhandle %s also as a gangbangin' file" 4
.el .IP "Openin dirhandle \f(CW%s\fR also as a gangbangin' file" 4
.IX Item "Openin dirhandle %s also as a gangbangin' file"
(D io, deprecated) Yo ass used \fIopen()\fR ta associate a gangbangin' filehandle to
a symbol (glob or scalar) dat already holdz a gangbangin' finger-lickin' dirhandle.
Although legal, dis idiom might render yo' code confusing
and is deprecated.
.ie n .IP "Openin filehandle %s also as a gangbangin' finger-lickin' directory" 4
.el .IP "Openin filehandle \f(CW%s\fR also as a gangbangin' finger-lickin' directory" 4
.IX Item "Openin filehandle %s also as a gangbangin' finger-lickin' directory"
(D io, deprecated) Yo ass used \fIopendir()\fR ta associate a gangbangin' finger-lickin' dirhandle to
a symbol (glob or scalar) dat already holdz a gangbangin' filehandle.
Although legal, dis idiom might render yo' code confusing
and is deprecated.
.IP "Operand wit no precedin operator up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Operand wit no precedin operator up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass freestyled suttin' like
.Sp
.Vb 1
\& (?[ \ep{Digit} \ep{Thai} ])
.Ve
.Sp
There is two operandz yo, but no operator givin how tha fuck you wanna combine
them.
.ie n .IP "Operation ""%s"": no method found, %s" 4
.el .IP "Operation ``%s'': no method found, \f(CW%s\fR" 4
.IX Item "Operation %s: no method found, %s"
(F) An attempt was made ta big-ass up a overloaded operation fo' which no
handlez was defined. Y'all KNOW dat shit, muthafucka!  While some handlezs can be autogenerated up in terms
of other handlezs, there is no default handlez fo' any operation, unless
the \f(CW\*(C`fallback\*(C'\fR overloadin key is specified ta be true.  See overload.
.ie n .IP "Operation ""%s"" returns its argument fo' non-Unicode code point 0x%X" 4
.el .IP "Operation ``%s'' returns its argument fo' non-Unicode code point 0x%X" 4
.IX Item "Operation %s returns its argument fo' non-Unicode code point 0x%X"
(S utf8, non_unicode) Yo ass performed a operation requirin Unicode
semantics on a cold-ass lil code point dat aint up in Unicode, so what tha fuck it should do
is not defined. Y'all KNOW dat shit, muthafucka!  Perl has chosen ta have it do nothing, n' warn yo thugged-out ass.
.Sp
If tha operation shown is \*(L"ToFold\*(R", it means dat case-insensitive
matchin up in a regular expression was done on tha code point.
.Sp
If you know what tha fuck yo ass is bustin you can turn off dis warnin by
\&\f(CW\*(C`no warnings \*(Aqnon_unicode\*(Aq;\*(C'\fR.
.ie n .IP "Operation ""%s"" returns its argument fo' \s-1UTF\-16\s0 surrogate U+%X" 4
.el .IP "Operation ``%s'' returns its argument fo' \s-1UTF\-16\s0 surrogate U+%X" 4
.IX Item "Operation %s returns its argument fo' UTF-16 surrogate U+%X"
(S utf8, surrogate) Yo ass performed a operation requirin Unicode
semantics on a Unicode surrogate.  Unicode frowns upon tha use of
surrogates fo' anythang but storin strings up in \s-1UTF\-16,\s0 but semantics
are (reluctantly) defined fo' tha surrogates, n' they is ta do
nothang fo' dis operation. I aint talkin' bout chicken n' gravy biatch.  Because tha use of surrogates can be
dangerous, Perl warns.
.Sp
If tha operation shown is \*(L"ToFold\*(R", it means dat case-insensitive
matchin up in a regular expression was done on tha code point.
.Sp
If you know what tha fuck yo ass is bustin you can turn off dis warnin by
\&\f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.ie n .IP "Operator or semicolon missin before %s" 4
.el .IP "Operator or semicolon missin before \f(CW%s\fR" 4
.IX Item "Operator or semicolon missin before %s"
(S ambiguous) Yo ass used a variable or subroutine call where tha parser
was expectin a operator. Shiiit, dis aint no joke.  Da parser has assumed you straight-up meant to
use a operator yo, but dis is highly likely ta be incorrect.  For
example, if you say \*(L"*foo *foo\*(R" it is ghon be interpreted as if you holla'd
\&\*(L"*foo * 'foo'\*(R".
.ie n .IP """our"" variable %s redeclared" 4
.el .IP "``our'' variable \f(CW%s\fR redeclared" 4
.IX Item "our variable %s redeclared"
(W misc) Yo ass seem ta have already declared tha same global once before
in tha current lexical scope.
.IP "Out of memory!" 4
.IX Item "Out of memory!"
(X) Da \fImalloc()\fR function returned 0, indicatin there was insufficient
remainin memory (or virtual memory) ta satisfy tha request.  Perl has
no option but ta exit immediately.
.Sp
At least up in Unix you may be able ta git past dis by increasin your
process datasize limits: up in csh/tcsh use \f(CW\*(C`limit\*(C'\fR and
\&\f(CW\*(C`limit datasize n\*(C'\fR (where \f(CW\*(C`n\*(C'\fR is tha number of kilobytes) ta check
the current limits n' chizzle them, n' up in ksh/bash/zsh use \f(CW\*(C`ulimit \-a\*(C'\fR
and \f(CW\*(C`ulimit \-d n\*(C'\fR, respectively.
.ie n .IP "Out of memory durin %s extend" 4
.el .IP "Out of memory durin \f(CW%s\fR extend" 4
.IX Item "Out of memory durin %s extend"
(X) An attempt was made ta extend a array, a list, or a strang beyond
the phattest possible memory allocation.
.ie n .IP "Out of memory durin ""large"" request fo' %s" 4
.el .IP "Out of memory durin ``large'' request fo' \f(CW%s\fR" 4
.IX Item "Out of memory durin big-ass request fo' %s"
(F) Da \fImalloc()\fR function returned 0, indicatin there was insufficient
remainin memory (or virtual memory) ta satisfy tha request.  However,
the request was judged big-ass enough (compile-time default is 64K), so a
possibilitizzle ta shut down by trappin dis error is granted.
.ie n .IP "Out of memory durin request fo' %s" 4
.el .IP "Out of memory durin request fo' \f(CW%s\fR" 4
.IX Item "Out of memory durin request fo' %s"
(X)(F) Da \fImalloc()\fR function returned 0, indicatin there was
insufficient remainin memory (or virtual memory) ta satisfy the
request.
.Sp
Da request was judged ta be small, so tha possibilitizzle ta trap it
dependz on tha way perl was compiled. Y'all KNOW dat shit, muthafucka!  By default it aint trappable.
But fuck dat shiznit yo, tha word on tha street is dat if compiled fo' this, Perl may use tha contentz of \f(CW$^M\fR as an
emergency pool afta \fIdie()\fRin wit dis message.  In dis case tha error
is trappable \fIonce\fR, n' tha error message will include tha line n' file
where tha failed request happened.
.IP "Out of memory durin ridiculously big-ass request" 4
.IX Item "Out of memory durin ridiculously big-ass request"
(F) Yo ass can't allocate mo' than 2^31+\*(L"small amount\*(R" bytes.  This error
is most likely ta be caused by a typo up in tha Perl program. e.g.,
\&\f(CW$arr[time]\fR instead of \f(CW$arr[$time]\fR.
.IP "Out of memory fo' yacc stack" 4
.IX Item "Out of memory fo' yacc stack"
(F) Da yacc parser wanted ta grow its stack so it could continue
parsin yo, but \fIrealloc()\fR wouldn't give it mo' memory, virtual or
otherwise.
.IP "'.' outside of strang up in pack" 4
.IX Item "'.' outside of strang up in pack"
(F) Da argument ta a '.' up in yo' template tried ta move tha working
posizzle ta before tha start of tha packed strang bein built.
.IP "'@' outside of strang up in unpack" 4
.IX Item "'@' outside of strang up in unpack"
(F) Yo ass had a template dat specified a absolute posizzle outside
the strang bein unpacked. Y'all KNOW dat shit, muthafucka!  See \*(L"pack\*(R" up in perlfunc.
.IP "'@' outside of strang wit malformed \s-1UTF\-8\s0 up in unpack" 4
.IX Item "'@' outside of strang wit malformed UTF-8 up in unpack"
(F) Yo ass had a template dat specified a absolute posizzle outside
the strang bein unpacked. Y'all KNOW dat shit, muthafucka!  Da strang bein unpacked was also invalid
\&\s-1UTF\-8. \s0 See \*(L"pack\*(R" up in perlfunc.
.IP "overload arg '%s' is invalid" 4
.IX Item "overload arg '%s' is invalid"
(W overload) Da overload pragma was passed a argument it did not
recognize.  Did yo dirty ass mistype a operator?
.IP "Overloaded dereference did not return a reference" 4
.IX Item "Overloaded dereference did not return a reference"
(F) An object wit a overloaded dereference operator was dereferenced,
but tha overloaded operation did not return a reference.  See
overload.
.IP "Overloaded qr did not return a \s-1REGEXP\s0" 4
.IX Item "Overloaded qr did not return a REGEXP"
(F) An object wit a \f(CW\*(C`qr\*(C'\fR overload was used as part of a match yo, but the
overloaded operation didn't return a cold-ass lil compiled regexp.  See overload.
.ie n .IP "%s package attribute may clash wit future reserved word: %s" 4
.el .IP "\f(CW%s\fR package attribute may clash wit future reserved word: \f(CW%s\fR" 4
.IX Item "%s package attribute may clash wit future reserved word: %s"
(W reserved) A lowercase attribute name was used dat had a
package-specific handlez n' shit.  That name might gotz a meanin ta Perl itself
some day, even though it don't yet.  Perhaps you should use a
mixed-case attribute name, instead. Y'all KNOW dat shit, muthafucka!  See attributes.
.IP "pack/unpack repeat count overflow" 4
.IX Item "pack/unpack repeat count overflow"
(F) Yo ass can't specify a repeat count so big-ass dat it overflows your
signed integers.  See \*(L"pack\*(R" up in perlfunc.
.IP "page overflow" 4
.IX Item "page overflow"
(W io) A single call ta \fIwrite()\fR produced mo' lines than can fit on a
page.  See perlform.
.ie n .IP "panic: %s" 4
.el .IP "panic: \f(CW%s\fR" 4
.IX Item "panic: %s"
(P) An internal error.
.ie n .IP "panic: attempt ta booty-call %s up in %s" 4
.el .IP "panic: attempt ta booty-call \f(CW%s\fR up in \f(CW%s\fR" 4
.IX Item "panic: attempt ta booty-call %s up in %s"
(P) One of tha file test operators entered a cold-ass lil code branch dat calls
an \s-1ACL\s0 related-function yo, but dat function aint available on this
platform.  Earlier checks mean dat it should not be possible to
enta dis branch on dis platform.
.IP "panic: lil pimp pseudo-process was never scheduled" 4
.IX Item "panic: lil pimp pseudo-process was never scheduled"
(P) A lil pimp pseudo-process up in tha ithreadz implementation on Windows
was not scheduled within tha time period allowed n' therefore was not
able ta initialize properly.
.IP "panic: ck_grep, type=%u" 4
.IX Item "panic: ck_grep, type=%u"
(P) Failed a internal consistency check tryin ta compile a grep.
.IP "panic: ck_split, type=%u" 4
.IX Item "panic: ck_split, type=%u"
(P) Failed a internal consistency check tryin ta compile a split.
.ie n .IP "panic: corrupt saved stack index %ld" 4
.el .IP "panic: corrupt saved stack index \f(CW%ld\fR" 4
.IX Item "panic: corrupt saved stack index %ld"
(P) Da savestack was axed ta restore mo' localized joints than
there is up in tha savestack.
.IP "panic: del_backref" 4
.IX Item "panic: del_backref"
(P) Failed a internal consistency check while tryin ta reset a weak
reference.
.ie n .IP "panic: take a thugged-out dirtnap %s" 4
.el .IP "panic: take a thugged-out dirtnap \f(CW%s\fR" 4
.IX Item "panic: take a thugged-out dirtnap %s"
(P) We popped tha context stack ta a eval context, n' then discovered
it wasn't a eval context.
.IP "panic: do_subst" 4
.IX Item "panic: do_subst"
(P) Da internal \fIpp_subst()\fR routine was called wit invalid operational
data.
.IP "panic: do_trans_%s" 4
.IX Item "panic: do_trans_%s"
(P) Da internal do_trans routines was called wit invalid operational
data.
.ie n .IP "panic: fold_constants \s-1JMPENV_PUSH\s0 returned %d" 4
.el .IP "panic: fold_constants \s-1JMPENV_PUSH\s0 returned \f(CW%d\fR" 4
.IX Item "panic: fold_constants JMPENV_PUSH returned %d"
(P) While attemptin foldin constants a exception other than a \f(CW\*(C`eval\*(C'\fR
failure was caught.
.IP "panic: frexp" 4
.IX Item "panic: frexp"
(P) Da library function \fIfrexp()\fR failed, makin printf(\*(L"%f\*(R") impossible.
.IP "panic: goto, type=%u, ix=%ld" 4
.IX Item "panic: goto, type=%u, ix=%ld"
(P) We popped tha context stack ta a cold-ass lil context wit tha specified label,
and then discovered it wasn't a cold-ass lil context we know how tha fuck ta do a goto in.
.IP "panic: gp_free failed ta free glob pointer" 4
.IX Item "panic: gp_free failed ta free glob pointer"
(P) Da internal routine used ta clear a typeglobz entries tried
repeatedly yo, but each time suttin' re-created entries up in tha glob.
Most likely tha glob gotz nuff a object wit a reference back to
the glob n' a thugged-out destructor dat addz a freshly smoked up object ta tha glob.
.ie n .IP "panic: \s-1INTERPCASEMOD,\s0 %s" 4
.el .IP "panic: \s-1INTERPCASEMOD,\s0 \f(CW%s\fR" 4
.IX Item "panic: INTERPCASEMOD, %s"
(P) Da lexer gots tha fuck into a wack state at a cold-ass lil case modifier.
.ie n .IP "panic: \s-1INTERPCONCAT,\s0 %s" 4
.el .IP "panic: \s-1INTERPCONCAT,\s0 \f(CW%s\fR" 4
.IX Item "panic: INTERPCONCAT, %s"
(P) Da lexer gots tha fuck into a wack state parsin a strang wit brackets.
.IP "panic: kid pimpn errno read" 4
.IX Item "panic: kid pimpn errno read"
(F) forked lil pimp returned a incomprehensible message bout its errno.
.IP "panic: last, type=%u" 4
.IX Item "panic: last, type=%u"
(P) We popped tha context stack ta a funky-ass block context, n' then discovered
it wasn't a funky-ass block context.
.IP "panic: leave_scope clearsv" 4
.IX Item "panic: leave_scope clearsv"
(P) A writable lexical variable became read-only somehow within the
scope.
.ie n .IP "panic: leave_scope inconsistency %u" 4
.el .IP "panic: leave_scope inconsistency \f(CW%u\fR" 4
.IX Item "panic: leave_scope inconsistency %u"
(P) Da savestack probably gots outta sync.  At least, there was an
invalid enum on tha top of dat shit.
.IP "panic: magic_killbackrefs" 4
.IX Item "panic: magic_killbackrefs"
(P) Failed a internal consistency check while tryin ta reset all weak
references ta a object.
.ie n .IP "panic: malloc, %s" 4
.el .IP "panic: malloc, \f(CW%s\fR" 4
.IX Item "panic: malloc, %s"
(P) Somethang axed a wack number of bytez of malloc.
.IP "panic: memory wrap" 4
.IX Item "panic: memory wrap"
(P) Somethang tried ta allocate mo' memory than possible.
.ie n .IP "panic: pad_alloc, %p!=%p" 4
.el .IP "panic: pad_alloc, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_alloc, %p!=%p"
(P) Da compila gots trippin bout which scratch pad dat shiznit was allocating
and freein temporaries n' lexicals from.
.ie n .IP "panic: pad_free curpad, %p!=%p" 4
.el .IP "panic: pad_free curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_free curpad, %p!=%p"
(P) Da compila gots trippin bout which scratch pad dat shiznit was allocating
and freein temporaries n' lexicals from.
.IP "panic: pad_free po" 4
.IX Item "panic: pad_free po"
(P) An invalid scratch pad offset was detected internally.
.ie n .IP "panic: pad_reset curpad, %p!=%p" 4
.el .IP "panic: pad_reset curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_reset curpad, %p!=%p"
(P) Da compila gots trippin bout which scratch pad dat shiznit was allocating
and freein temporaries n' lexicals from.
.IP "panic: pad_sv po" 4
.IX Item "panic: pad_sv po"
(P) An invalid scratch pad offset was detected internally.
.ie n .IP "panic: pad_swipe curpad, %p!=%p" 4
.el .IP "panic: pad_swipe curpad, \f(CW%p\fR!=%p" 4
.IX Item "panic: pad_swipe curpad, %p!=%p"
(P) Da compila gots trippin bout which scratch pad dat shiznit was allocating
and freein temporaries n' lexicals from.
.IP "panic: pad_swipe po" 4
.IX Item "panic: pad_swipe po"
(P) An invalid scratch pad offset was detected internally.
.IP "panic: pp_iter, type=%u" 4
.IX Item "panic: pp_iter, type=%u"
(P) Da foreach iterator gots called up in a non-loop context frame.
.IP "panic: pp_match%s" 4
.IX Item "panic: pp_match%s"
(P) Da internal \fIpp_match()\fR routine was called wit invalid operational
data.
.IP "panic: pp_split, pm=%p, s=%p" 4
.IX Item "panic: pp_split, pm=%p, s=%p"
(P) Somethang shitty went wack up in settin up fo' tha split.
.ie n .IP "panic: realloc, %s" 4
.el .IP "panic: realloc, \f(CW%s\fR" 4
.IX Item "panic: realloc, %s"
(P) Somethang axed a wack number of bytez of realloc.
.IP "panic: reference miscount on nsv up in \fIsv_replace()\fR (%d != 1)" 4
.IX Item "panic: reference miscount on nsv up in sv_replace() (%d != 1)"
(P) Da internal \fIsv_replace()\fR function was handed a freshly smoked up \s-1SV\s0 wit a
reference count other than 1.
.ie n .IP "panic: restartop up in %s" 4
.el .IP "panic: restartop up in \f(CW%s\fR" 4
.IX Item "panic: restartop up in %s"
(P) Some internal routine axed a goto (or suttin' like it), and
didn't supply tha destination.
.IP "panic: return, type=%u" 4
.IX Item "panic: return, type=%u"
(P) We popped tha context stack ta a subroutine or eval context, and
then discovered it wasn't a subroutine or eval context.
.ie n .IP "panic: scan_num, %s" 4
.el .IP "panic: scan_num, \f(CW%s\fR" 4
.IX Item "panic: scan_num, %s"
(P) \fIscan_num()\fR gots called on suttin' dat wasn't a number.
.IP "panic: Sequence (?{...}): no code block found" 4
.IX Item "panic: Sequence (?{...}): no code block found"
(P) while compilin a pattern dat has embedded (?{}) or (??{}) code
blocks, perl couldn't locate tha code block dat should have already been
seen n' compiled by perl before control passed ta tha regex compiler.
.ie n .IP "panic: sv_chop %s" 4
.el .IP "panic: sv_chop \f(CW%s\fR" 4
.IX Item "panic: sv_chop %s"
(P) Da \fIsv_chop()\fR routine was passed a posizzle dat aint within the
scalarz strang buffer.
.IP "panic: sv_insert, midend=%p, bigend=%p" 4
.IX Item "panic: sv_insert, midend=%p, bigend=%p"
(P) Da \fIsv_insert()\fR routine was holla'd at ta remove mo' strang than there
was string.
.ie n .IP "panic: \fIstrxfrm()\fR gets absurd \- a => %u, ab => %u" 4
.el .IP "panic: \fIstrxfrm()\fR gets absurd \- a => \f(CW%u\fR, ab => \f(CW%u\fR" 4
.IX Item "panic: strxfrm() gets absurd - a => %u, ab => %u"
(P) Da interpreterz sanitizzle check of tha C function \fIstrxfrm()\fR failed.
In yo' current locale tha returned transformation of tha strang \*(L"ab\*(R" is
shorta than dat of tha strang \*(L"a\*(R", which make no sense.
.IP "panic: top_env" 4
.IX Item "panic: top_env"
(P) Da compila attempted ta do a goto, or suttin' weird like dis shit.
.ie n .IP "panic: unimplemented op %s (#%d) called" 4
.el .IP "panic: unimplemented op \f(CW%s\fR (#%d) called" 4
.IX Item "panic: unimplemented op %s (#%d) called"
(P) Da compila is screwed up n' attempted ta use a op dat aint
permitted at run time.
.IP "panic: utf16_to_utf8: odd bytelen" 4
.IX Item "panic: utf16_to_utf8: odd bytelen"
(P) Somethang tried ta booty-call utf16_to_utf8 wit a odd (as opposed
to even) byte length.
.IP "panic: utf16_to_utf8_reversed: odd bytelen" 4
.IX Item "panic: utf16_to_utf8_reversed: odd bytelen"
(P) Somethang tried ta booty-call utf16_to_utf8_reversed wit a odd (as opposed
to even) byte length.
.ie n .IP "panic: yylex, %s" 4
.el .IP "panic: yylex, \f(CW%s\fR" 4
.IX Item "panic: yylex, %s"
(P) Da lexer gots tha fuck into a wack state while processin a cold-ass lil case modifier.
.ie n .IP "Parentheses missin round ""%s"" list" 4
.el .IP "Parentheses missin round ``%s'' list" 4
.IX Item "Parentheses missin round %s list"
(W parenthesis) Yo ass holla'd suttin' like
.Sp
.Vb 1
\&    mah $foo, $bar = @_;
.Ve
.Sp
when you meant
.Sp
.Vb 1
\&    mah ($foo, $bar) = @_;
.Ve
.Sp
Remember dat \*(L"my\*(R", \*(L"our\*(R", \*(L"local\*(R" n' \*(L"state\*(R" bind tighta than comma.
.IP "Parsin code internal error (%s)" 4
.IX Item "Parsin code internal error (%s)"
(F) Parsin code supplied by a extension violated tha parserz \s-1API\s0 in
a detectable way.
.ie n .IP "Passin malformed \s-1UTF\-8\s0 ta ""%s"" is deprecated" 4
.el .IP "Passin malformed \s-1UTF\-8\s0 ta ``%s'' is deprecated" 4
.IX Item "Passin malformed UTF-8 ta %s is deprecated"
(D deprecated, utf8) This message indicates a funky-ass bug either up in tha Perl
core or up in \s-1XS\s0 code.  Such code was tryin ta smoke up if a cold-ass lil character,
allegedly stored internally encoded as \s-1UTF\-8,\s0 waz of a given type, such
as bein punctuation or a gangbangin' finger-lickin' digit.  But tha characta was not encoded in
legal \s-1UTF\-8. \s0 Da \f(CW%s\fR is replaced by a strang dat can be used by
knowledgeable playas ta determine what tha fuck tha type bein checked against
was.  If \f(CW\*(C`utf8\*(C'\fR warnings is enabled, a gangbangin' further message is raised,
givin detailz of tha malformation.
.IP "Pattern subroutine nestin without pos chizzle exceeded limit up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Pattern subroutine nestin without pos chizzle exceeded limit up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a pattern dat uses too nuff nested subpattern calls without
consumin any text.  Restructure tha pattern so text is consumed before
the nestin limit is exceeded.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.ie n .IP """\-p"" destination: %s" 4
.el .IP "\f(CW\-p\fR destination: \f(CW%s\fR" 4
.IX Item "-p destination: %s"
(F) An error occurred durin tha implicit output invoked by tha \f(CW\*(C`\-p\*(C'\fR
command-line switch.  (This output goes ta \s-1STDOUT\s0 unless you've
repimped up it wit \fIselect()\fR.)
.ie n .IP "(like you forgot ta load ""%s""?)" 4
.el .IP "(like you forgot ta load ``%s''?)" 4
.IX Item "(like you forgot ta load %s?)"
(F) This be a constipated guess made up in conjunction wit tha message
\&\*(L"Can't locate object method \e\*(R"%s\e\*(L" via package \e\*(R"%s\e"".  It often means
that a method requires a package dat has not been loaded.
.IP "Perl foldin rulez is not up-to-date fo' 0x%X; please use tha perlbug utilitizzle ta report; up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Perl foldin rulez is not up-to-date fo' 0x%X; please use tha perlbug utilitizzle ta report; up in regex; marked by <-- HERE up in m/%s/"
(D regexp, deprecated) Yo ass used a regular expression with
case-insensitizzle matching, n' there be a funky-ass bug up in Perl up in which the
built-in regular expression foldin rulez is not accurate.  This may
lead ta incorrect thangs up in dis biatch.  Please report dis as a funky-ass bug rockin the
perlbug utility.  (This message is marked deprecated, so dat it by
default is ghon be turned-on.)
.IP "Perl_my_%s() not available" 4
.IX Item "Perl_my_%s() not available"
(F) Yo crazy-ass platform has straight-up uncommon byte-order n' integer size,
so dat shiznit was not possible ta set up some or all fixed-width byte-order
conversion functions.  This is only a problem when you rockin the
\&'<' or '>' modifiers up in (un)pack templates.  See \*(L"pack\*(R" up in perlfunc.
.ie n .IP "Perl %s required (did you mean %s?)\-\-this is only %s, stopped" 4
.el .IP "Perl \f(CW%s\fR required (did you mean \f(CW%s\fR?)\-\-this is only \f(CW%s\fR, stopped" 4
.IX Item "Perl %s required (did you mean %s?)--this is only %s, stopped"
(F) Da code yo ass is tryin ta run has axed fo' a newer version of
Perl than yo ass is hustlin.  Perhaps \f(CW\*(C`use 5.10\*(C'\fR was freestyled instead
of \f(CW\*(C`use 5.010\*(C'\fR or \f(CW\*(C`use v5.10\*(C'\fR.  Without tha leadin \f(CW\*(C`v\*(C'\fR, tha number is
interpreted as a thugged-out decimal, wit every last muthafuckin three digits afta the
decimal point representin a part of tha version number n' shit.  So 5.10
is equivalent ta v5.100.
.ie n .IP "Perl %s required\*(--this is only version %s, stopped" 4
.el .IP "Perl \f(CW%s\fR required\*(--this is only version \f(CW%s\fR, stopped" 4
.IX Item "Perl %s requiredthis is only version %s, stopped"
(F) Da module up in question uses featurez of a version of Perl more
recent than tha currently hustlin version. I aint talkin' bout chicken n' gravy biatch.  How tha fuck long has it been since
you upgraded, anyway?  See \*(L"require\*(R" up in perlfunc.
.IP "\s-1PERL_SH_DIR\s0 too long" 4
.IX Item "PERL_SH_DIR too long"
(F) An error peculiar ta \s-1OS/2.  PERL_SH_DIR\s0 is tha directory ta find the
\&\f(CW\*(C`sh\*(C'\fR\-shell in. I aint talkin' bout chicken n' gravy biatch.  See \*(L"\s-1PERL_SH_DIR\*(R"\s0 up in perlos2.
.ie n .IP "\s-1PERL_SIGNALS\s0 illegal: ""%s""" 4
.el .IP "\s-1PERL_SIGNALS\s0 illegal: ``%s''" 4
.IX Item "PERL_SIGNALS illegal: %s"
(X) See \*(L"\s-1PERL_SIGNALS\*(R"\s0 up in perlrun fo' legal joints.
.ie n .IP "Perls since %s too modern\*(--this is %s, stopped" 4
.el .IP "Perls since \f(CW%s\fR too modern\*(--this is \f(CW%s\fR, stopped" 4
.IX Item "Perls since %s too modernthis is %s, stopped"
(F) Da code yo ass is tryin ta run fronts it aint gonna run
on tha version of Perl yo ass is rockin cuz it is too new.
Maybe tha code need ta be updated, or maybe it is simply
wrong n' tha version check should just be removed.
.IP "perl: warning: Settin locale failed." 4
.IX Item "perl: warning: Settin locale failed."
(S) Da whole warnin message will look suttin' like:
.Sp
.Vb 6
\&        perl: warning: Settin locale failed.
\&        perl: warning: Please check dat yo' locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            is supported n' installed on yo' system.
\&        perl: warning: Fallin back ta tha standard locale ("C").
.Ve
.Sp
Exactly what tha fuck was tha failed locale settings varies. Put ya muthafuckin choppers up if ya feel dis!  In tha above the
settings was dat tha \s-1LC_ALL\s0 was \*(L"En_US\*(R" n' tha \s-1LANG\s0 had no value.
This error means dat Perl detected dat you and/or yo' operating
system supplier and/or system administrator have set up tha so-called
locale system but Perl could not use dem settings.  This was not
dead serious, fortunately: there be a \*(L"default locale\*(R" called \*(L"C\*(R" that
Perl can n' will use, n' tha script is ghon be run. I aint talkin' bout chicken n' gravy biatch.  Before you straight-up
fix tha problem, however, yo big-ass booty is ghon git tha same error message each
time you run Perl.  How tha fuck ta straight-up fix tha problem can be found in
perllocale section \fB\s-1LOCALE PROBLEMS\s0\fR.
.IP "perl: warning: Non hex characta up in '$ENV{\s-1PERL_HASH_SEED\s0}', seed only partially set" 4
.IX Item "perl: warning: Non hex characta up in '$ENV{PERL_HASH_SEED}', seed only partially set"
(W) \s-1PERL_HASH_SEED\s0 should match /^\es*(?:0x)?[0\-9a\-fA\-F]+\es*\ez/ but it
contained a non hex character n' shit. This could mean yo ass is not rockin tha hash
seed you be thinkin yo ass is.
.IP "perl: warning: strange settin up in '$ENV{\s-1PERL_PERTURB_KEYS\s0}': '%s'" 4
.IX Item "perl: warning: strange settin up in '$ENV{PERL_PERTURB_KEYS}': '%s'"
(W) Perl was run wit tha environment variable \s-1PERL_PERTURB_KEYS\s0 defined
but containin a unexpected value. Da legal jointz of dis setting
are as bigs up.
.Sp
.Vb 5
\&  Numeric | Strin        | Result
\&  \-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  0       | NO            | Disablez key traversal randomization
\&  1       | RANDOM        | Enablez full key traversal randomization
\&  2       | DETERMINISTIC | Enablez repeatable key traversal randomization
.Ve
.Sp
Both numeric n' strang joints is accepted yo, but note dat strang joints are
case sensitive. Da default fo' dis settin is \*(L"\s-1RANDOM\*(R"\s0 or 1.
.ie n .IP "pid %x not a cold-ass lil child" 4
.el .IP "pid \f(CW%x\fR not a cold-ass lil child" 4
.IX Item "pid %x not a cold-ass lil child"
(W exec) A warnin peculiar ta \s-1VMS. \s0 \fIWaitpid()\fR was axed ta wait fo' a
process which aint a subprocess of tha current process.  While dis is
fine from \s-1VMS\s0' perspective, itz probably not what tha fuck you intended.
.IP "'P' must have a explicit size up in unpack" 4
.IX Item "'P' must have a explicit size up in unpack"
(F) Da unpack format P must have a explicit size, not \*(L"*\*(R".
.IP "\s-1POSIX\s0 class [:%s:] unknown up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "POSIX class [:%s:] unknown up in regex; marked by <-- HERE up in m/%s/"
(F) Da class up in tha characta class [: :] syntax is unknown. I aint talkin' bout chicken n' gravy biatch.  Da <\-\- \s-1HERE\s0
shows whereabouts up in tha regular expression tha problem was discovered.
Note dat tha \s-1POSIX\s0 characta classes do \fBnot\fR have tha \f(CW\*(C`is\*(C'\fR prefix
the correspondin C intercourses have: up in other lyrics, itz \f(CW\*(C`[[:print:]]\*(C'\fR,
not \f(CW\*(C`isprint\*(C'\fR.  See perlre.
.IP "\s-1POSIX\s0 getpgrp can't take a argument" 4
.IX Item "POSIX getpgrp can't take a argument"
(F) Yo crazy-ass system has \s-1POSIX\s0 \fIgetpgrp()\fR, which takes no argument, unlike
the \s-1BSD\s0 version, which takes a pid.
.ie n .IP "\s-1POSIX\s0 syntax [%c %c] belongs inside characta classes up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "\s-1POSIX\s0 syntax [%c \f(CW%c\fR] belongs inside characta classes up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "POSIX syntax [%c %c] belongs inside characta classes up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Da characta class constructs [: :], [= =], n' [. .]  go
\&\fIinside\fR characta classes, tha [] is part of tha construct, fo' example:
/[012[:alpha:]345]/.  Note dat [= =] n' [. .] is not currently
implemented; they is simply placeholdaz fo' future extensions and
will cause fatal errors.  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular
expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "\s-1POSIX\s0 syntax [. .] is reserved fo' future extensions up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "POSIX syntax [. .] is reserved fo' future extensions up in regex; marked by <-- HERE up in m/%s/"
(F) Within regular expression characta classes ([]) tha syntax beginning
with \*(L"[.\*(R" n' endin wit \*(L".]\*(R" is reserved fo' future extensions.  If you
need ta represent dem characta sequences inside a regular expression
characta class, just quote tha square brackets wit tha backslash: \*(L"\e[.\*(R"
and \*(L".\e]\*(R".  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "\s-1POSIX\s0 syntax [= =] is reserved fo' future extensions up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "POSIX syntax [= =] is reserved fo' future extensions up in regex; marked by <-- HERE up in m/%s/"
(F) Within regular expression characta classes ([]) tha syntax beginning
with \*(L"[=\*(R" n' endin wit \*(L"=]\*(R" is reserved fo' future extensions.  If you
need ta represent dem characta sequences inside a regular expression
characta class, just quote tha square brackets wit tha backslash: \*(L"\e[=\*(R"
and \*(L"=\e]\*(R".  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Possible attempt ta put comments up in \fIqw()\fR list" 4
.IX Item "Possible attempt ta put comments up in qw() list"
(W qw) \fIqw()\fR lists contain shit separated by whitespace; as wit literal
strings, comment charactas is not ignored yo, but is instead treated as
literal data.  (Yo ass may have used different delimitas than the
parentheses shown here; braces is also frequently used.)
.Sp
Yo ass probably freestyled suttin' like this:
.Sp
.Vb 4
\&    @list = qw(
\&        a # a cold-ass lil comment
\&        b # another comment
\&    );
.Ve
.Sp
when you should have freestyled this:
.Sp
.Vb 4
\&    @list = qw(
\&        a
\&        b
\&    );
.Ve
.Sp
If you straight-up want comments, build yo' list the
old-fashioned way, wit quotes n' commas:
.Sp
.Vb 4
\&    @list = (
\&        \*(Aqa\*(Aq,    # a cold-ass lil comment
\&        \*(Aqb\*(Aq,    # another comment
\&    );
.Ve
.IP "Possible attempt ta separate lyrics wit commas" 4
.IX Item "Possible attempt ta separate lyrics wit commas"
(W qw) \fIqw()\fR lists contain shit separated by whitespace; therefore
commas aren't needed ta separate tha items.  (Yo ass may have used
different delimitas than tha parentheses shown here; braces is also
frequently used.)
.Sp
Yo ass probably freestyled suttin' like this:
.Sp
.Vb 1
\&    qw! a, b, c !;
.Ve
.Sp
which puts literal commas tha fuck into a shitload of tha list items.  Write it without
commas if you don't want dem ta step tha fuck up in yo' data:
.Sp
.Vb 1
\&    qw! a funky-ass b c !;
.Ve
.ie n .IP "Possible memory corruption: %s overflowed 3rd argument" 4
.el .IP "Possible memory corruption: \f(CW%s\fR overflowed 3rd argument" 4
.IX Item "Possible memory corruption: %s overflowed 3rd argument"
(F) An \fIioctl()\fR or \fIfcntl()\fR returned mo' than Perl was bargainin for.
Perl guesses a reasonable buffer size yo, but puts a sentinel byte at the
end of tha buffer just up in case.  This sentinel byte gots clobbered, and
Perl assumes dat memory is now corrupted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \*(L"ioctl\*(R" up in perlfunc.
.ie n .IP "Possible precedence problem on bitwise %c operator" 4
.el .IP "Possible precedence problem on bitwise \f(CW%c\fR operator" 4
.IX Item "Possible precedence problem on bitwise %c operator"
(W precedence) Yo crazy-ass program uses a funky-ass bitwise logical operator up in conjunction
with a numeric comparison operator, like dis :
.Sp
.Vb 1
\&    if ($x & $y == 0) { ... }
.Ve
.Sp
This expression is straight-up equivalent ta \f(CW\*(C`$x & ($y == 0)\*(C'\fR, cuz of the
higher precedence of \f(CW\*(C`==\*(C'\fR.  This is probably not what tha fuck you want.  (If you
really meant ta write this, disable tha warning, or, better, put the
parentheses explicitly n' write \f(CW\*(C`$x & ($y == 0)\*(C'\fR).
.IP "Possible unintended interpolation of $\e up in regex" 4
.IX Item "Possible unintended interpolation of $ up in regex"
(W ambiguous) Yo ass holla'd suttin' like \f(CW\*(C`m/$\e/\*(C'\fR up in a regex.
Da regex \f(CW\*(C`m/foo$\es+bar/m\*(C'\fR translates to: match tha word 'foo', tha output
record separator (see \*(L"$\e\*(R" up in perlvar) n' tha letta 's' (one time or more)
followed by tha word 'bar'.
.Sp
If dis is what tha fuck you intended then you can silence tha warnin by rockin 
\&\f(CW\*(C`m/${\e}/\*(C'\fR (for example: \f(CW\*(C`m/foo${\e}s+bar/\*(C'\fR).
.Sp
If instead you intended ta match tha word 'foo' all up in tha end of tha line
followed by whitespace n' tha word 'bar' on tha next line then you can use
\&\f(CW\*(C`m/$(?)\e/\*(C'\fR (for example: \f(CW\*(C`m/foo$(?)\es+bar/\*(C'\fR).
.ie n .IP "Possible unintended interpolation of %s up in string" 4
.el .IP "Possible unintended interpolation of \f(CW%s\fR up in string" 4
.IX Item "Possible unintended interpolation of %s up in string"
(W ambiguous) Yo ass holla'd suttin' like '@foo' up in a thugged-out double-quoted string
but there was no array \f(CW@foo\fR up in scope all up in tha time.  If you wanted a
literal \f(CW@foo\fR, then write it as \e@foo; otherwise smoke up what tha fuck happened
to tha array you apparently lost track of.
.ie n .IP "Precedence problem: open %s should be open(%s)" 4
.el .IP "Precedence problem: open \f(CW%s\fR should be open(%s)" 4
.IX Item "Precedence problem: open %s should be open(%s)"
(S precedence) Da oldschool irregular construct
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.Sp
is now misinterpreted as
.Sp
.Vb 1
\&    open(FOO || die);
.Ve
.Sp
because of tha strict regularization of Perl 5z grammar tha fuck into unary and
list operators.  (Da oldschool open was a lil of both.)  Yo ass must put
parentheses round tha filehandle, or use tha freshly smoked up \*(L"or\*(R" operator instead
of \*(L"||\*(R".
.IP "Premature end of script headers" 4
.IX Item "Premature end of script headers"
See Server error.
.ie n .IP "\fIprintf()\fR on closed filehandle %s" 4
.el .IP "\fIprintf()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "printf() on closed filehandle %s"
(W closed) Da filehandle you freestylin ta gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.ie n .IP "\fIprint()\fR on closed filehandle %s" 4
.el .IP "\fIprint()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "print() on closed filehandle %s"
(W closed) Da filehandle you printin on gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.IP "Process terminated by SIG%s" 4
.IX Item "Process terminated by SIG%s"
(W) This be a standard message issued by \s-1OS/2\s0 applications, while *nix
applications take a thugged-out dirtnap up in silence.  It be considered a gangbangin' feature of tha \s-1OS/2\s0
port.  One can easily disable dis by appropriate sighandlezs, see
\&\*(L"Signals\*(R" up in perlipc.  See also \*(L"Process terminated by \s-1SIGTERM/SIGINT\*(R"\s0
in perlos2.
.IP "Property '%s' is unknown up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Property '%s' is unknown up in regex; marked by <-- HERE up in m/%s/"
(F)
Da named property which you specified via \f(CW\*(C`\ep\*(C'\fR or \f(CW\*(C`\eP\*(C'\fR aint one
known ta Perl.  Perhaps you misspelled tha name?  See
\&\*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops
for a cold-ass lil complete list of available straight-up legit properties. Put ya muthafuckin choppers up if ya feel dis!  If it be a
user-defined property
it must done been defined by tha time tha regular expression is
compiled.
.ie n .IP "Prototype afta '%c' fo' %s : %s" 4
.el .IP "Prototype afta '%c' fo' \f(CW%s\fR : \f(CW%s\fR" 4
.IX Item "Prototype afta '%c' fo' %s : %s"
(W illegalproto) A characta bigs up % or @ up in a prototype.  This is
useless, since % n' @ gobble tha rest of tha subroutine arguments.
.ie n .IP "Prototype mismatch: %s vs %s" 4
.el .IP "Prototype mismatch: \f(CW%s\fR vs \f(CW%s\fR" 4
.IX Item "Prototype mismatch: %s vs %s"
(S prototype) Da subroutine bein declared or defined had previously been
declared or defined wit a gangbangin' finger-lickin' different function prototype.
.IP "Prototype not terminated" 4
.IX Item "Prototype not terminated"
(F) You've omitted tha closin parenthesis up in a gangbangin' function prototype
definition.
.IP "\ep{} uses Unicode rules, not locale rules" 4
.IX Item "p{} uses Unicode rules, not locale rules"
(W) Yo ass compiled a regular expression dat contained a Unicode property
match (\f(CW\*(C`\ep\*(C'\fR or \f(CW\*(C`\eP\*(C'\fR) yo, but tha regular expression be also bein holla'd at to
use tha run-time locale, not Unicode.  Instead, bust a \s-1POSIX\s0 character
class, which should know bout tha localez rules.
(See \*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass.)
.Sp
Even if tha run-time locale is \s-1ISO 8859\-1 \s0(Latin1), which be a subset of
Unicode, some propertizzles will give thangs up in dis biatch dat is not valid fo' that
subset.
.Sp
Here is a cold-ass lil couple examplez ta help you peep what tha fuck be happenin. I aint talkin' bout chicken n' gravy biatch.  If the
locale is \s-1ISO 8859\-7,\s0 tha characta at code point 0xD7 is tha \*(L"\s-1GREEK
CAPITAL LETTER CHI\*(R". \s0 But up in Unicode dat code point means the
\&\*(L"\s-1MULTIPLICATION SIGN\*(R"\s0 instead, n' \f(CW\*(C`\ep\*(C'\fR always uses tha Unicode
meaning.  That means dat \f(CW\*(C`\ep{Alpha}\*(C'\fR won't match yo, but \f(CW\*(C`[[:alpha:]]\*(C'\fR
should. Y'all KNOW dat shit, muthafucka!  Only up in tha Latin1 locale is all tha charactas up in tha same
positions as they is up in Unicode.  But, even here, some propertizzles give
incorrect thangs up in dis biatch.  An example is \f(CW\*(C`\ep{Changes_When_Uppercased}\*(C'\fR which
is legit fo' \*(L"\s-1LATIN SMALL LETTER Y WITH DIAERESIS\*(R",\s0 but since tha upper
case of dat characta aint up in Latin1, up in dat locale it don't
change when upper cased.
.IP "Quantifier {n,m} wit n > m can't match up in regex" 4
.IX Item "Quantifier {n,m} wit n > m can't match up in regex"
(W regexp) Minima should be less than or equal ta maxima.  If you straight-up
want yo' regexp ta match suttin' 0 times, just put {0}.
.IP "Quantifier bigs up not a god damn thang up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Quantifier bigs up not a god damn thang up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass started a regular expression wit a quantifier n' shit.  Backslash it if
you meant it literally.  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular
expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "Quantifier up in {,} bigger than %d up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Quantifier up in {,} bigger than \f(CW%d\fR up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Quantifier up in {,} bigger than %d up in regex; marked by <-- HERE up in m/%s/"
(F) There is currently a limit ta tha size of tha min n' max joints of
the {min,max} construct.  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular
expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Quantifier unexpected on zero-length expression up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Quantifier unexpected on zero-length expression up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Yo ass applied a regular expression quantifier up in a place where
it make no sense, like fuckin on a zero-width assertion. I aint talkin' bout chicken n' gravy biatch.  Try puttin the
quantifier inside tha assertion instead. Y'all KNOW dat shit, muthafucka!  For example, tha way ta match
\&\*(L"abc\*(R" provided dat it is followed by three repetitionz of \*(L"xyz\*(R" is
\&\f(CW\*(C`/abc(?=(?:xyz){3})/\*(C'\fR, not \f(CW\*(C`/abc(?=xyz){3}/\*(C'\fR.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Quantifier {n,m} wit n > m can't match up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Quantifier {n,m} wit n > m can't match up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Minima should be less than or equal ta maxima.  If you straight-up
want yo' regexp ta match suttin' 0 times, just put {0}.
.IP "Range iterator outside integer range" 4
.IX Item "Range iterator outside integer range"
(F) One (or both) of tha numeric arguments ta tha range operator \*(L"..\*(R"
are outside tha range which can be represented by integers internally.
One possible workaround is ta force Perl ta use magical strang increment
by prependin \*(L"0\*(R" ta yo' numbers.
.ie n .IP "\fIreaddir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fIreaddir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "readdir() attempted on invalid dirhandle %s"
(W io) Da dirhandle you readin from is either closed or not straight-up
a dirhandle.  Peep yo' control flow.
.ie n .IP "\fIreadline()\fR on closed filehandle %s" 4
.el .IP "\fIreadline()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "readline() on closed filehandle %s"
(W closed) Da filehandle you readin from gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.ie n .IP "\fIread()\fR on closed filehandle %s" 4
.el .IP "\fIread()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "read() on closed filehandle %s"
(W closed) Yo ass tried ta read from a cold-ass lil closed filehandle.
.ie n .IP "\fIread()\fR on unopened filehandle %s" 4
.el .IP "\fIread()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "read() on unopened filehandle %s"
(W unopened) Yo ass tried ta read from a gangbangin' filehandle dat was never opened.
.ie n .IP "Reallocation too large: %x" 4
.el .IP "Reallocation too large: \f(CW%x\fR" 4
.IX Item "Reallocation too large: %x"
(F) Yo ass can't allocate mo' than 64K on a MS-DOS machine.
.IP "\fIrealloc()\fR of freed memory ignored" 4
.IX Item "realloc() of freed memory ignored"
(S malloc) An internal routine called \fIrealloc()\fR on suttin' dat had
already been freed.
.IP "Recompile perl wit \fB\-D\fR\s-1DEBUGGING\s0 ta use \fB\-D\fR switch" 4
.IX Item "Recompile perl wit -DDEBUGGING ta use -D switch"
(S debugging) Yo ass can't use tha \fB\-D\fR option unless tha code ta produce
the desired output is compiled tha fuck into Perl, which entails some overhead,
which is why itz currently left outta yo' copy.
.IP "Recursive call ta Perl_load_module up in PerlIO_find_layer" 4
.IX Item "Recursive call ta Perl_load_module up in PerlIO_find_layer"
(P) It be currently not permitted ta load modulez when bustin
a filehandle inside a \f(CW%INC\fR hook.  This can happen wit \f(CW\*(C`open my
$fh, \*(Aq<\*(Aq, \e$scalar\*(C'\fR, which implicitly loadz PerlIO::scalar. Shiiit, dis aint no joke.  Try
loadin PerlIO::scalar explicitly first.
.IP "Recursive inheritizzle detected up in package '%s'" 4
.IX Item "Recursive inheritizzle detected up in package '%s'"
(F) While calculatin tha method resolution order (\s-1MRO\s0) of a package, Perl
believes it found a infinite loop up in tha \f(CW@ISA\fR hierarchy.  This be a
crude check dat bails up afta 100 levelz of \f(CW@ISA\fR depth.
.ie n .IP "refcnt_dec: fd %d%s" 4
.el .IP "refcnt_dec: fd \f(CW%d\fR%s" 4
.IX Item "refcnt_dec: fd %d%s"
.PD 0
.ie n .IP "refcnt: fd %d%s" 4
.el .IP "refcnt: fd \f(CW%d\fR%s" 4
.IX Item "refcnt: fd %d%s"
.ie n .IP "refcnt_inc: fd %d%s" 4
.el .IP "refcnt_inc: fd \f(CW%d\fR%s" 4
.IX Item "refcnt_inc: fd %d%s"
.PD
(P) Perlz I/O implementation failed a internal consistency check.  If
you peep dis message, suttin' is straight-up wrong.
.IP "Reference found where even-sized list expected" 4
.IX Item "Reference found where even-sized list expected"
(W misc) Yo ass gave a single reference where Perl was expectin a list
with a even number of elements (for assignment ta a hash).  This
usually means dat you used tha anon hash constructor when you meant
to use parens.  In any case, a hash requires key/value \fBpairs\fR.
.Sp
.Vb 4
\&    %hash = { one => 1, two => 2, };    # WRONG
\&    %hash = [ qw/ a anon array / ];    # WRONG
\&    %hash = ( one => 1, two => 2, );    # right
\&    %hash = qw( one 1 two 2 );                  # also fine
.Ve
.IP "Reference be already weak" 4
.IX Item "Reference be already weak"
(W misc) Yo ass have attempted ta weaken a reference dat be already weak.
Bustin so has no effect.
.IP "Reference ta invalid crew 0 up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Reference ta invalid crew 0 up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used \f(CW\*(C`\eg0\*(C'\fR or similar up in a regular expression. I aint talkin' bout chicken n' gravy biatch.  Yo ass may refer
to capturin parentheses only wit strictly positizzle integers
(normal backreferences) or wit strictly wack integers (relative
backreferences).  Usin 0 do not make sense.
.IP "Reference ta nonexistent crew up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Reference ta nonexistent crew up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used suttin' like \f(CW\*(C`\e7\*(C'\fR up in yo' regular expression yo, but there are
not at least seven setz of capturin parentheses up in tha expression. I aint talkin' bout chicken n' gravy biatch.  If
you wanted ta have tha characta wit ordinal 7 banged tha fuck into tha regular
expression, prepend zeroes ta make it three digits long: \f(CW\*(C`\e007\*(C'\fR
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Reference ta nonexistent named crew up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Reference ta nonexistent named crew up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used suttin' like \f(CW\*(C`\ek\*(AqNAME\*(Aq\*(C'\fR or \f(CW\*(C`\ek<NAME>\*(C'\fR up in yo' regular
expression yo, but there is no correspondin named capturin parentheses
like fuckin \f(CW\*(C`(?\*(AqNAME\*(Aq...)\*(C'\fR or \f(CW\*(C`(?<NAME>...)\*(C'\fR.  Peep if tha name has been
spelled erectly both up in tha backreference n' tha declaration.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "Reference ta nonexistent or unclosed crew up in regex; marked by <\-\- \s-1HERE \s0 up in m/%s/" 4
.IX Item "Reference ta nonexistent or unclosed crew up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used suttin' like \f(CW\*(C`\eg{\-7}\*(C'\fR up in yo' regular expression yo, but there
are not at least seven setz of closed capturin parentheses up in the
expression before where tha \f(CW\*(C`\eg{\-7}\*(C'\fR was located.
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered.
.IP "regexp memory corruption" 4
.IX Item "regexp memory corruption"
(P) Da regular expression engine gots trippin by what tha fuck tha regular
expression compila gave dat shit.
.ie n .IP "Regexp modifier ""/%c"" may step tha fuck up a maximum of twice" 4
.el .IP "Regexp modifier ``/%c'' may step tha fuck up a maximum of twice" 4
.IX Item "Regexp modifier /%c may step tha fuck up a maximum of twice"
.PD 0
.ie n .IP "Regexp modifier ""/%c"" may not step tha fuck up twice" 4
.el .IP "Regexp modifier ``/%c'' may not step tha fuck up twice" 4
.IX Item "Regexp modifier /%c may not step tha fuck up twice"
.PD
(F syntax, regexp) Da regular expression pattern had too nuff occurrences
of tha specified modifier n' shit.  Remove tha extraneous ones.
.ie n .IP "Regexp modifier ""%c"" may not step tha fuck up afta tha ""\-"" up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Regexp modifier ``%c'' may not step tha fuck up afta tha ``\-'' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Regexp modifier %c may not step tha fuck up afta tha - up in regex; marked by <-- HERE up in m/%s/"
(F) Turnin off tha given modifier has tha side effect of turnin on
another one.  Perl currently don't allow all dis bullshit.  Reword tha regular
expression ta use tha modifier you wanna turn on (and place it before
the minus), instead of tha one you wanna turn off.
.ie n .IP "Regexp modifiers ""/%c"" n' ""/%c"" is mutually exclusive" 4
.el .IP "Regexp modifiers ``/%c'' n' ``/%c'' is mutually exclusive" 4
.IX Item "Regexp modifiers /%c n' /%c is mutually exclusive"
(F syntax, regexp) Da regular expression pattern had mo' than one of these
mutually exclusive modifiers.  Retain only tha modifier dat is
supposed ta be there.
.IP "Regexp outta space up in regex m/%s/" 4
.IX Item "Regexp outta space up in regex m/%s/"
(P) A \*(L"can't happen\*(R" error, cuz \fIsafemalloc()\fR should have caught it
earlier.
.IP "Repeated format line aint NEVER gonna terminizzle (~~ n' @# incompatible)" 4
.IX Item "Repeated format line aint NEVER gonna terminizzle (~~ n' @# incompatible)"
(F) Yo crazy-ass format gotz nuff tha ~~ repeat-until-blank sequence n' a
numeric field dat aint NEVER gonna go blank so dat tha repetizzle never
terminates.  Yo ass might use ^# instead. Y'all KNOW dat shit, muthafucka!  See perlform.
.IP "Replacement list is longer than search list" 4
.IX Item "Replacement list is longer than search list"
(W misc) Yo ass have used a replacement list dat is longer than the
search list.  So tha additionizzle elements up in tha replacement list
are meaningless.
.IP "'%s' resolved ta '\eo{%s}%d'" 4
.IX Item "'%s' resolved ta 'o{%s}%d'"
(W misc, regexp)  Yo ass freestyled suttin' like \f(CW\*(C`\e08\*(C'\fR, or \f(CW\*(C`\e179\*(C'\fR up in a
double-quotish string.  All but tha last digit is treated as a single
character, specified up in octal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da last digit is tha next characta in
the string.  To tell Perl dat dis is indeed what tha fuck you want, you can use
the \f(CW\*(C`\eo{ }\*(C'\fR syntax, or use exactly three digits ta specify tha octal
for tha character.
.ie n .IP "Reversed %s= operator" 4
.el .IP "Reversed \f(CW%s\fR= operator" 4
.IX Item "Reversed %s= operator"
(W syntax) Yo ass freestyled yo' assignment operator backwards.  Da = must
always come last, ta avoid ambiguitizzle wit subsequent unary operators.
.ie n .IP "\fIrewinddir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fIrewinddir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "rewinddir() attempted on invalid dirhandle %s"
(W io) Da dirhandle you tried ta do a \fIrewinddir()\fR on is either closed or not
really a gangbangin' finger-lickin' dirhandle.  Peep yo' control flow.
.ie n .IP "Scalars leaked: %d" 4
.el .IP "Scalars leaked: \f(CW%d\fR" 4
.IX Item "Scalars leaked: %d"
(S internal) Somethang went wack up in Perlz internal bookkeeping
of scalars: not all scalar variablez was deallocated by tha time
Perl exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  What dis probably indicates be a memory leak, which
iz of course bad, especially if tha Perl program is intended ta be
long-running.
.IP "Scalar value @%s[%s] betta freestyled as $%s[%s]" 4
.IX Item "Scalar value @%s[%s] betta freestyled as $%s[%s]"
(W syntax) You've used a array slice (indicated by @) ta select a
single element of a array.  Generally itz betta ta ask fo' a scalar
value (indicated by $).  Da difference is dat \f(CW$foo[&bar]\fR always
behaves like a scalar, both when assignin ta it n' when evaluatin its
argument, while \f(CW@foo[&bar]\fR behaves like a list when you assign ta it,
and serves up a list context ta its subscript, which can do weird thangs
if you expectin only one subscript.
.Sp
On tha other hand, if you was straight-up hopin ta treat tha array
element as a list, you need ta look tha fuck into how tha fuck references work, cuz
Perl aint gonna magically convert between scalars n' lists fo' yo thugged-out ass.  See
perlref.
.IP "Scalar value @%s{%s} betta freestyled as $%s{%s}" 4
.IX Item "Scalar value @%s{%s} betta freestyled as $%s{%s}"
(W syntax) You've used a hash slice (indicated by @) ta select a single
element of a hash.  Generally itz betta ta ask fo' a scalar value
(indicated by $).  Da difference is dat \f(CW$foo{&bar}\fR always behaves
like a scalar, both when assignin ta it n' when evaluatin its
argument, while \f(CW@foo{&bar}\fR behaves like a list when you assign ta it,
and serves up a list context ta its subscript, which can do weird thangs
if you expectin only one subscript.
.Sp
On tha other hand, if you was straight-up hopin ta treat tha hash element
as a list, you need ta look tha fuck into how tha fuck references work, cuz Perl will
not magically convert between scalars n' lists fo' yo thugged-out ass.  See
perlref.
.IP "Search pattern not terminated" 4
.IX Item "Search pattern not terminated"
(F) Da lexer couldn't find tha final delimita of a // or m{}
construct.  Remember dat bracketin delimitas count nestin level.
Missin tha leadin \f(CW\*(C`$\*(C'\fR from a variable \f(CW$m\fR may cause dis error.
.Sp
Note dat since Perl 5.9.0 a // can also be tha \fIdefined-or\fR
construct, not just tha empty search pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Therefore code written
in Perl 5.9.0 or lata dat uses tha // as tha \fIdefined-or\fR can be
misparsed by pre\-5.9.0 Perls as a non-terminated search pattern.
.IP "Search pattern not terminated or ternary operator parsed as search pattern" 4
.IX Item "Search pattern not terminated or ternary operator parsed as search pattern"
(F) Da lexer couldn't find tha final delimita of a \f(CW\*(C`?PATTERN?\*(C'\fR
construct.
.Sp
Da question mark be also used as part of tha ternary operator (as in
\&\f(CW\*(C`foo ? 0 : 1\*(C'\fR) leadin ta some ambiguous constructions bein wrongly
parsed. Y'all KNOW dat shit, muthafucka!  One way ta disambiguate tha parsin is ta put parentheses around
the conditionizzle expression, i.e. \f(CW\*(C`(foo) ? 0 : 1\*(C'\fR.
.ie n .IP "\fIseekdir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fIseekdir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "seekdir() attempted on invalid dirhandle %s"
(W io) Da dirhandle yo ass is bustin a \fIseekdir()\fR on is either closed or not
really a gangbangin' finger-lickin' dirhandle.  Peep yo' control flow.
.IP "%\fIsseek()\fR on unopened filehandle" 4
.IX Item "%sseek() on unopened filehandle"
(W unopened) Yo ass tried ta use tha \fIseek()\fR or \fIsysseek()\fR function on a
filehandle dat was either never opened or has since been closed.
.IP "select not implemented" 4
.IX Item "select not implemented"
(F) This machine don't implement tha \fIselect()\fR system call.
.IP "Self-tizzlez of arrays n' hashes is not supported" 4
.IX Item "Self-tizzlez of arrays n' hashes is not supported"
(F) Self-tizzles iz of arrays n' hashes is not supported in
the current implementation.
.IP "Semicolon seems ta be missing" 4
.IX Item "Semicolon seems ta be missing"
(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missin operator, like fuckin a cold-ass lil comma.
.IP "semi-panic: attempt ta dup freed string" 4
.IX Item "semi-panic: attempt ta dup freed string"
(S internal) Da internal \fInewSVsv()\fR routine was called ta duplicate a
scalar dat had previously been marked as free.
.IP "sem%s not implemented" 4
.IX Item "sem%s not implemented"
(F) Yo ass aint gots System V semaphore \s-1IPC\s0 on yo' system.
.ie n .IP "\fIsend()\fR on closed socket %s" 4
.el .IP "\fIsend()\fR on closed socket \f(CW%s\fR" 4
.IX Item "send() on closed socket %s"
(W closed) Da socket you bustin  ta gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.IP "Sequence (? incomplete up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Sequence (? incomplete up in regex; marked by <-- HERE up in m/%s/"
(F) A regular expression ended wit a incomplete extension (?.  The
<\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Sequence (?%s...) not implemented up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Sequence (?%s...) not implemented up in regex; marked by <-- HERE up in m/%s/"
(F) A proposed regular expression extension has tha characta reserved
but has not yet been written. I aint talkin' bout chicken n' gravy biatch.  Da <\-\- \s-1HERE\s0 shows whereabouts up in the
regular expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Sequence (?%s...) not recognized up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Sequence (?%s...) not recognized up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a regular expression extension dat don't make sense.  The
<\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered. Y'all KNOW dat shit, muthafucka!  This happens when rockin tha \f(CW\*(C`(?^...)\*(C'\fR construct ta tell
Perl ta use tha default regular expression modifiers, n' you
redundantly specify a thugged-out default modifier n' shit.  For other
causes, peep perlre.
.IP "Sequence \e%s... not terminated up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Sequence %s... not terminated up in regex; marked by <-- HERE up in m/%s/"
(F) Da regular expression expects a mandatory argument followin tha escape
sequence n' dis has been omitted or incorrectly written.
.IP "Sequence (?#... not terminated up in regex m/%s/" 4
.IX Item "Sequence (?#... not terminated up in regex m/%s/"
(F) A regular expression comment must be terminated by a cold-ass lil closing
parenthesis.  Embedded parentheses aren't allowed. Y'all KNOW dat shit, muthafucka!  See
perlre.
.IP "Sequence (?{...}) not terminated wit ')'" 4
.IX Item "Sequence (?{...}) not terminated wit ')'"
(F) Da end of tha perl code contained within tha {...} must be
followed immediately by a ')'.
.IP "500 Server error" 4
.IX Item "500 Server error"
See Server error.
.IP "Server error" 4
.IX Item "Server error"
(A) This is tha error message generally peeped up in a funky-ass browser window
when tryin ta run a \s-1CGI\s0 program (includin \s-1SSI\s0) over tha web.  The
actual error text varies widely from server ta server n' shit.  Da most
frequently-seen variants is \*(L"500 Server error\*(R", \*(L"Method (something)
not permitted\*(R", \*(L"Document gotz nuff no data\*(R", \*(L"Premature end of script
headers\*(R", n' \*(L"Did not produce a valid header\*(R".
.Sp
\&\fBThis be a \s-1CGI\s0 error, not a Perl error\fR.
.Sp
Yo ass need ta make shizzle yo' script is executable, be accessible by
the user \s-1CGI\s0 is hustlin tha script under (which is probably not the
user account you tested it under), do not rely on any environment
variablez (like \s-1PATH\s0) from tha user it aint hustlin under, n' aint
in a location where tha \s-1CGI\s0 server can't find it, basically, mo' or
less.  Please peep tha followin fo' mo' shiznit:
.Sp
.Vb 3
\&        http://www.perl.org/CGI_MetaFAQ.html
\&        http://www.htmlhelp.org/faq/cgifaq.html
\&        http://www.w3.org/Security/Faq/
.Ve
.Sp
Yo ass should also peep perlfaq9.
.IP "\fIsetegid()\fR not implemented" 4
.IX Item "setegid() not implemented"
(F) Yo ass tried ta assign ta \f(CW$)\fR, n' yo' operatin system don't
support tha \fIsetegid()\fR system call (or equivalent), or at least Configure
didn't be thinkin so.
.IP "\fIseteuid()\fR not implemented" 4
.IX Item "seteuid() not implemented"
(F) Yo ass tried ta assign ta \f(CW$>\fR, n' yo' operatin system don't
support tha \fIseteuid()\fR system call (or equivalent), or at least Configure
didn't be thinkin so.
.IP "setpgrp can't take arguments" 4
.IX Item "setpgrp can't take arguments"
(F) Yo crazy-ass system has tha \fIsetpgrp()\fR from \s-1BSD 4.2,\s0 which takes no
arguments, unlike \s-1POSIX\s0 \fIsetpgid()\fR, which takes a process \s-1ID\s0 n' process
group \s-1ID.\s0
.IP "\fIsetrgid()\fR not implemented" 4
.IX Item "setrgid() not implemented"
(F) Yo ass tried ta assign ta \f(CW$(\fR, n' yo' operatin system don't
support tha \fIsetrgid()\fR system call (or equivalent), or at least Configure
didn't be thinkin so.
.IP "\fIsetruid()\fR not implemented" 4
.IX Item "setruid() not implemented"
(F) Yo ass tried ta assign ta \f(CW$<\fR, n' yo' operatin system don't
support tha \fIsetruid()\fR system call (or equivalent), or at least Configure
didn't be thinkin so.
.ie n .IP "\fIsetsockopt()\fR on closed socket %s" 4
.el .IP "\fIsetsockopt()\fR on closed socket \f(CW%s\fR" 4
.IX Item "setsockopt() on closed socket %s"
(W closed) Yo ass tried ta set a socket option on a cold-ass lil closed socket.  Did you
forget ta check tha return value of yo' \fIsocket()\fR call?  See
\&\*(L"setsockopt\*(R" up in perlfunc.
.IP "shm%s not implemented" 4
.IX Item "shm%s not implemented"
(F) Yo ass aint gots System V shared memory \s-1IPC\s0 on yo' system.
.IP "!=~ should be !~" 4
.IX Item "!=~ should be !~"
(W syntax) Da non-matchin operator is !~, not !=~.  !=~ will be
interpreted as tha != (numeric not equal) n' ~ (1z complement)
operators: probably not what tha fuck you intended.
.IP "<> should be quotes" 4
.IX Item "<> should be quotes"
(F) Yo ass freestyled \f(CW\*(C`require <file>\*(C'\fR when you should have written
\&\f(CW\*(C`require \*(Aqfile\*(Aq\*(C'\fR.
.ie n .IP "/%s/ should probably be freestyled as ""%s""" 4
.el .IP "/%s/ should probably be freestyled as ``%s''" 4
.IX Item "/%s/ should probably be freestyled as %s"
(W syntax) Yo ass have used a pattern where Perl sposed ta fuckin find a string,
as up in tha straight-up original gangsta argument ta \f(CW\*(C`join\*(C'\fR.  Perl will treat tha legit or false
result of matchin tha pattern against \f(CW$_\fR as tha string, which is
probably not what tha fuck you had up in mind.
.ie n .IP "\fIshutdown()\fR on closed socket %s" 4
.el .IP "\fIshutdown()\fR on closed socket \f(CW%s\fR" 4
.IX Item "shutdown() on closed socket %s"
(W closed) Yo ass tried ta do a gangbangin' finger-lickin' dirty-ass shutdown on a cold-ass lil closed socket.  Seems a funky-ass bit
superfluous.
.ie n .IP "SIG%s handlez ""%s"" not defined" 4
.el .IP "SIG%s handlez ``%s'' not defined" 4
.IX Item "SIG%s handlez %s not defined"
(W signal) Da signal handlez named up in \f(CW%SIG\fR don't, up in fact, exist.
Perhaps you put it tha fuck into tha wack package?
.ie n .IP "Slab leaked from cv %p" 4
.el .IP "Slab leaked from cv \f(CW%p\fR" 4
.IX Item "Slab leaked from cv %p"
(S) If you peep dis message, then suttin' is seriously wack wit the
internal bookkeepin of op trees.  An op tree needed ta be freed after
a compilation error yo, but could not be found, so dat shiznit was leaked instead.
.IP "sleep(%u) too large" 4
.IX Item "sleep(%u) too large"
(W overflow) Yo ass called \f(CW\*(C`sleep\*(C'\fR wit a number dat was larger than
it can reliably handle n' \f(CW\*(C`sleep\*(C'\fR probably slept fo' less time than
requested.
.IP "Smartmatch is experimental" 4
.IX Item "Smartmatch is experimental"
(S experimental::smartmatch) This warnin is emitted if you
use tha smartmatch (\f(CW\*(C`~~\*(C'\fR) operator. Shiiit, dis aint no joke.  This is currently a experimental
feature, n' its details is subject ta chizzle up in future releases of
Perl.  Particularly, its current behavior is noticed fo' being
unnecessarily complex n' unintuitive, n' is straight-up likely ta be
overhauled.
.IP "Smart matchin a non-overloaded object breaks encapsulation" 4
.IX Item "Smart matchin a non-overloaded object breaks encapsulation"
(F) Yo ass should not use tha \f(CW\*(C`~~\*(C'\fR operator on a object dat do not
overload it: Perl refuses ta use tha objectz underlyin structure for
the smart-ass match.
.IP "sort is now a reserved word" 4
.IX Item "sort is now a reserved word"
(F) An ancient error message dat almost no muthafucka eva runs tha fuck into no mo'.
But before sort was a keyword, playas sometimes used it as a gangbangin' filehandle.
.IP "Sort subroutine didn't return single value" 4
.IX Item "Sort subroutine didn't return single value"
(F) A sort comparison subroutine freestyled up in \s-1XS\s0 must return exactly one
item.  See \*(L"sort\*(R" up in perlfunc.
.IP "Source filtas apply only ta byte streams" 4
.IX Item "Source filtas apply only ta byte streams"
(F) Yo ass tried ta activate a source filta (usually by loadin a
source filta module) within a strang passed ta \f(CW\*(C`eval\*(C'\fR.  This is
not permitted under tha \f(CW\*(C`unicode_eval\*(C'\fR feature.  Consider using
\&\f(CW\*(C`evalbytes\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See feature.
.IP "\fIsplice()\fR offset past end of array" 4
.IX Item "splice() offset past end of array"
(W misc) Yo ass attempted ta specify a offset dat was past tha end of
the array passed ta \fIsplice()\fR.  Splicin will instead commence at the
end of tha array, rather than past dat shit.  If dis aint what tha fuck you want,
try explicitly pre-extendin tha array by assignin $#array = \f(CW$offset\fR.
See \*(L"splice\*(R" up in perlfunc.
.IP "Split loop" 4
.IX Item "Split loop"
(P) Da split was loopin infinitely.  (Obviously, a split shouldn't
iterate mo' times than there be charactaz of input, which is what
happened.)  See \*(L"split\*(R" up in perlfunc.
.IP "Statement unlikely ta be reached" 4
.IX Item "Statement unlikely ta be reached"
(W exec) Yo ass did a \fIexec()\fR wit some statement afta it other than a
\&\fIdie()\fR.  This be almost always a error, cuz \fIexec()\fR never returns
unless there was a gangbangin' failure.  Yo ass probably wanted ta use \fIsystem()\fR
instead, which do return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  To suppress dis warning, put tha \fIexec()\fR in
a block by itself.
.ie n .IP """state"" variable %s can't be up in a package" 4
.el .IP "``state'' variable \f(CW%s\fR can't be up in a package" 4
.IX Item "state variable %s can't be up in a package"
(F) Lexically scoped variablez aren't up in a package, so it don't make
sense ta try ta declare one wit a package qualifier on tha front.  Use
\&\fIlocal()\fR if you wanna localize a package variable.
.ie n .IP """state %s"" used up in sort comparison" 4
.el .IP "``state \f(CW%s\fR'' used up in sort comparison" 4
.IX Item "state %s used up in sort comparison"
(W syntax) Da package variablez \f(CW$a\fR n' \f(CW$b\fR is used fo' sort comparisons.
Yo ass used \f(CW$a\fR or \f(CW$b\fR up in as a operand ta tha \f(CW\*(C`<=>\*(C'\fR or \f(CW\*(C`cmp\*(C'\fR operator inside a
sort comparison block, n' tha variable had earlier been declared as a
lexical variable.  Either qualify tha sort variable wit tha package
name, or rename tha lexical variable.
.ie n .IP "\fIstat()\fR on unopened filehandle %s" 4
.el .IP "\fIstat()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "stat() on unopened filehandle %s"
(W unopened) Yo ass tried ta use tha \fIstat()\fR function on a gangbangin' filehandle that
was either never opened or has since been closed.
.ie n .IP "Stub found while resolvin method ""%s"" overloadin ""%s"" up in package ""%s""" 4
.el .IP "Stub found while resolvin method ``%s'' overloadin ``%s'' up in package ``%s''" 4
.IX Item "Stub found while resolvin method %s overloadin %s up in package %s"
(P) Overloadin resolution over \f(CW@ISA\fR tree may be fucked up by importation
stubs.  Stubs should never be implicitly pimped yo, but explicit calls to
\&\f(CW\*(C`can\*(C'\fR may break all dis bullshit.
.ie n .IP "Subroutine ""&%s"" aint available" 4
.el .IP "Subroutine ``&%s'' aint available" 4
.IX Item "Subroutine &%s aint available"
(W closure) Durin compilation, a inner named subroutine or eval is
attemptin ta capture a outa lexical subroutine dat aint currently
available.  This can happen fo' one of two reasons.  First, tha lexical
subroutine may be declared up in a outa anonymous subroutine dat has not
yet been pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Remember dat named subs is pimped at compile time,
while anonymous subs is pimped at run-time.)  For example,
.Sp
.Vb 1
\&    sub { mah sub a {...} sub f { \e&a } }
.Ve
.Sp
At tha time dat f is pimped, it can't capture tha current tha \*(L"a\*(R" sub,
since tha anonymous subroutine aint been pimped yet.  Conversely, the
followin won't give a warnin since tha anonymous subroutine has by now
been pimped n' is live:
.Sp
.Vb 1
\&    sub { mah sub a {...} eval \*(Aqsub f { \e&a }\*(Aq }\->();
.Ve
.Sp
Da second thang is caused by a eval accessin a variable dat has
gone outta scope, fo' example,
.Sp
.Vb 5
\&    sub f {
\&        mah sub a {...}
\&        sub { eval \*(Aq\e&a\*(Aq }
\&    }
\&    f()\->();
.Ve
.Sp
Here, when tha '\e&a' up in tha eval is bein compiled, f() aint currently
bein executed, so its &a aint available fo' capture.
.ie n .IP """%s"" subroutine &%s masks earlier declaration up in same %s" 4
.el .IP "``%s'' subroutine &%s masks earlier declaration up in same \f(CW%s\fR" 4
.IX Item "%s subroutine &%s masks earlier declaration up in same %s"
(W misc) A \*(L"my\*(R" or \*(L"state\*(R" subroutine has been redeclared up in the
current scope or statement, effectively eliminatin all access to
the previous instance.  This be almost always a typographical error.
Note dat tha earlier subroutine will still exist until tha end of
the scope or until all closure references ta it is destroyed.
.ie n .IP "Subroutine %s redefined" 4
.el .IP "Subroutine \f(CW%s\fR redefined" 4
.IX Item "Subroutine %s redefined"
(W redefine) Yo ass redefined a subroutine.  To suppress dis warning, say
.Sp
.Vb 4
\&    {
\&        no warnings \*(Aqredefine\*(Aq;
\&        eval "sub name { ... }";
\&    }
.Ve
.IP "Substitution loop" 4
.IX Item "Substitution loop"
(P) Da substitution was loopin infinitely.  (Obviously, a substitution
shouldn't iterate mo' times than there be charactaz of input, which
is what tha fuck happened.)  See tha rap of substitution in
\&\*(L"Regexp Quote-Like Operators\*(R" up in perlop.
.IP "Substitution pattern not terminated" 4
.IX Item "Substitution pattern not terminated"
(F) Da lexer couldn't find tha interior delimita of a s/// or s{}{}
construct.  Remember dat bracketin delimitas count nestin level.
Missin tha leadin \f(CW\*(C`$\*(C'\fR from variable \f(CW$s\fR may cause dis error.
.IP "Substitution replacement not terminated" 4
.IX Item "Substitution replacement not terminated"
(F) Da lexer couldn't find tha final delimita of a s/// or s{}{}
construct.  Remember dat bracketin delimitas count nestin level.
Missin tha leadin \f(CW\*(C`$\*(C'\fR from variable \f(CW$s\fR may cause dis error.
.IP "substr outside of string" 4
.IX Item "substr outside of string"
(W substr)(F) Yo ass tried ta reference a \fIsubstr()\fR dat pointed outside of
a string.  That is, tha absolute value of tha offset was larger than the
length of tha string.  See \*(L"substr\*(R" up in perlfunc.  This warnin is fatal if
substr is used up in a lvalue context (as tha left hand side of an
assignment or as a subroutine argument fo' example).
.ie n .IP "sv_upgrade from type %d down ta type %d" 4
.el .IP "sv_upgrade from type \f(CW%d\fR down ta type \f(CW%d\fR" 4
.IX Item "sv_upgrade from type %d down ta type %d"
(P) Perl tried ta force tha upgrade of a \s-1SV\s0 ta a type which was actually
inferior ta its current type.
.IP "Switch (?(condition)... gotz nuff too nuff branches up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Switch (?(condition)... gotz nuff too nuff branches up in regex; marked by <-- HERE up in m/%s/"
(F) A (?(condition)if\-clause|else\-clause) construct can have at most
two branches (the if-clause n' tha else-clause).  If you want one or
both ta contain alternation, like fuckin rockin \f(CW\*(C`this|that|other\*(C'\fR, enclose
it up in clusterin parentheses:
.Sp
.Vb 1
\&    (?(condition)(?:this|that|other)|else\-clause)
.Ve
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem
was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Switch condizzle not recognized up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Switch condizzle not recognized up in regex; marked by <-- HERE up in m/%s/"
(F) If tha argument ta tha (?(...)if\-clause|else\-clause) construct is
a number, it can be only a number n' shit.  Da <\-\- \s-1HERE\s0 shows whereabouts in
the regular expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "switchin effectizzle %s aint implemented" 4
.el .IP "switchin effectizzle \f(CW%s\fR aint implemented" 4
.IX Item "switchin effectizzle %s aint implemented"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, we cannot switch tha real
and effectizzle uidz or gids.
.ie n .IP "%s syntax \s-1OK\s0" 4
.el .IP "\f(CW%s\fR syntax \s-1OK\s0" 4
.IX Item "%s syntax OK"
(F) Da final summary message when a \f(CW\*(C`perl \-c\*(C'\fR succeeds.
.IP "syntax error" 4
.IX Item "syntax error"
(F) Probably means you had a syntax error. Shiiit, dis aint no joke.  Common reasons include:
.Sp
.Vb 6
\&    A keyword is misspelled.
\&    A semicolon is missing.
\&    A comma is missing.
\&    An openin or closin parenthesis is missing.
\&    An openin or closin brace is missing.
\&    A closin quote is missing.
.Ve
.Sp
Often there is ghon be another error message associated wit tha syntax
error givin mo' shiznit. I aint talkin' bout chicken n' gravy biatch.  (Sometimes it helps ta turn on \fB\-w\fR.)
Da error message itself often  drops some lyrics ta you where dat shiznit was up in tha line when
it decided ta give up.  Sometimes tha actual error is nuff muthafuckin tokens
before this, cuz Perl is phat at understandin random input.
Occasionally tha line number may be misleading, n' once up in a funky-ass blue moon
the only way ta figure up whatz triggerin tha error is ta call
\&\f(CW\*(C`perl \-c\*(C'\fR repeatedly, choppin away half tha program each time ta see
if tha error went away.  Sort of tha cybernetic version of 20\ thangs.
.ie n .IP "syntax error at line %d: '%s' unexpected" 4
.el .IP "syntax error at line \f(CW%d:\fR '%s' unexpected" 4
.IX Item "syntax error at line %d: '%s' unexpected"
(A) You've accidentally run yo' script all up in tha Bourne shell instead
of Perl.  Peep tha #! line, or manually feed yo' script tha fuck into Perl
yo ass.
.ie n .IP "syntax error up in file %s at line %d, next 2 tokens ""%s""" 4
.el .IP "syntax error up in file \f(CW%s\fR at line \f(CW%d\fR, next 2 tokens ``%s''" 4
.IX Item "syntax error up in file %s at line %d, next 2 tokens %s"
(F) This error is likely ta occur if you run a perl5 script through
a perl4 interpreter, especially if tha next 2 tokens is \*(L"use strict\*(R"
or \*(L"my \f(CW$var\fR\*(R" or \*(L"our \f(CW$var\fR\*(R".
.ie n .IP "\fIsysread()\fR on closed filehandle %s" 4
.el .IP "\fIsysread()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "sysread() on closed filehandle %s"
(W closed) Yo ass tried ta read from a cold-ass lil closed filehandle.
.ie n .IP "\fIsysread()\fR on unopened filehandle %s" 4
.el .IP "\fIsysread()\fR on unopened filehandle \f(CW%s\fR" 4
.IX Item "sysread() on unopened filehandle %s"
(W unopened) Yo ass tried ta read from a gangbangin' filehandle dat was never opened.
.IP "Syntax error up in (?[...]) up in regex m/%s/" 4
.IX Item "Syntax error up in (?[...]) up in regex m/%s/"
(F)
Perl could not figure up what tha fuck you meant inside dis construct; this
notifies you dat it is givin up trying.
.ie n .IP "System V %s aint implemented on dis machine" 4
.el .IP "System V \f(CW%s\fR aint implemented on dis machine" 4
.IX Item "System V %s aint implemented on dis machine"
(F) Yo ass tried ta do suttin' wit a gangbangin' function beginnin wit \*(L"sem\*(R",
\&\*(L"shm\*(R", or \*(L"msg\*(R" but dat System V \s-1IPC\s0 aint implemented up in your
machine.  In some machines tha functionalitizzle can exist but be
unconfigured. Y'all KNOW dat shit, muthafucka!  Consult yo' system support.
.ie n .IP "\fIsyswrite()\fR on closed filehandle %s" 4
.el .IP "\fIsyswrite()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "syswrite() on closed filehandle %s"
(W closed) Da filehandle you freestylin ta gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.ie n .IP """\-T"" n' ""\-B"" not implemented on filehandles" 4
.el .IP "\f(CW\-T\fR n' \f(CW\-B\fR not implemented on filehandles" 4
.IX Item "-T n' -B not implemented on filehandles"
(F) Perl can't peek all up in tha stdio buffer of filehandlez when it don't
know bout yo' kind of stdio.  You'll gotta bust a gangbangin' filename instead.
.IP "Target of goto is too deeply nested" 4
.IX Item "Target of goto is too deeply nested"
(F) Yo ass tried ta use \f(CW\*(C`goto\*(C'\fR ta reach a label dat was too deeply nested
for Perl ta reach.  Perl is bustin you a gangbangin' favor by refusing.
.ie n .IP "\fItelldir()\fR attempted on invalid dirhandle %s" 4
.el .IP "\fItelldir()\fR attempted on invalid dirhandle \f(CW%s\fR" 4
.IX Item "telldir() attempted on invalid dirhandle %s"
(W io) Da dirhandle you tried ta \fItelldir()\fR is either closed or not straight-up
a dirhandle.  Peep yo' control flow.
.IP "\fItell()\fR on unopened filehandle" 4
.IX Item "tell() on unopened filehandle"
(W unopened) Yo ass tried ta use tha \fItell()\fR function on a gangbangin' filehandle that
was either never opened or has since been closed.
.IP "That use of $[ is unsupported" 4
.IX Item "That use of $[ is unsupported"
(F) Assignment ta \f(CW$[\fR is now strictly circumscribed, n' interpreted
as a cold-ass lil compila directive.  Yo ass may say only one of
.Sp
.Vb 6
\&    $[ = 0;
\&    $[ = 1;
\&    ...
\&    local $[ = 0;
\&    local $[ = 1;
\&    ...
.Ve
.Sp
This is ta prevent tha problem of one module changin tha array base out
from under another module inadvertently.  See \*(L"$[\*(R" up in perlvar n' arybase.
.IP "Da \fIcrypt()\fR function is unimplemented cuz of excessive paranoia." 4
.IX Item "Da crypt() function is unimplemented cuz of excessive paranoia."
(F) Configure couldn't find tha \fIcrypt()\fR function on yo' machine,
probably cuz yo' vendor didn't supply it, probably cuz they
think tha U.S. Posse be thinkin itz a secret, or at least dat they
will continue ta pretend dat it is.  And if you quote me on that, I
will deny dat shit.
.IP "Da lexical_subs feature is experimental" 4
.IX Item "Da lexical_subs feature is experimental"
(S experimental::lexical_subs) This warnin is emitted if you
declare a sub wit \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR.  Simply suppress tha warning
if you wanna use tha feature yo, but know dat up in bustin so you
are takin tha risk of rockin a experimenstrual feature which may
change or be removed up in a gangbangin' future Perl version:
.Sp
.Vb 3
\&    no warnings "experimental::lexical_subs";
\&    use feature "lexical_subs";
\&    mah sub foo { ... }
.Ve
.IP "Da regex_sets feature is experimental" 4
.IX Item "Da regex_sets feature is experimental"
(S experimental::regex_sets) This warnin is emitted if you
use tha syntax \f(CW\*(C`(?[\ \ \ ])\*(C'\fR up in a regular expression.
Da detailz of dis feature is subject ta chizzle.
if you wanna use it yo, but know dat up in bustin so you
are takin tha risk of rockin a experimenstrual feature which may
change up in a gangbangin' future Perl version, you can do dis ta silence the
warning:
.Sp
.Vb 1
\&    no warnings "experimental::regex_sets";
.Ve
.ie n .IP "Da %s feature is experimental" 4
.el .IP "Da \f(CW%s\fR feature is experimental" 4
.IX Item "Da %s feature is experimental"
(S experimental) This warnin is emitted if you enable a experimental
feature via \f(CW\*(C`use feature\*(C'\fR.  Simply suppress tha warnin if you want
to use tha feature yo, but know dat up in bustin so yo ass is takin tha risk
of rockin a experimenstrual feature which may chizzle or be removed up in a
future Perl version:
.Sp
.Vb 2
\&    no warnings "experimental::lexical_subs";
\&    use feature "lexical_subs";
.Ve
.ie n .IP "Da %s function is unimplemented" 4
.el .IP "Da \f(CW%s\fR function is unimplemented" 4
.IX Item "Da %s function is unimplemented"
(F) Da function indicated aint implemented on dis architecture, according
to tha probingz of Configure.
.ie n .IP "Da stat precedin %s wasn't a lstat" 4
.el .IP "Da stat precedin \f(CW%s\fR wasn't a lstat" 4
.IX Item "Da stat precedin %s wasn't a lstat"
(F) It make no sense ta test tha current stat buffer fo' symbolic
linkhood if tha last stat dat freestyled ta tha stat buffer already went
past tha symlink ta git ta tha real file.  Use a actual filename
instead.
.IP "Da 'unique' attribute may only be applied ta 'our' variables" 4
.IX Item "Da 'unique' attribute may only be applied ta 'our' variables"
(F) This attribute was never supported on \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`sub\*(C'\fR declarations.
.IP "This Perl can't reset \s-1CRTL\s0 environ elements (%s)" 4
.IX Item "This Perl can't reset CRTL environ elements (%s)"
.PD 0
.IP "This Perl can't set \s-1CRTL\s0 environ elements (%s=%s)" 4
.IX Item "This Perl can't set CRTL environ elements (%s=%s)"
.PD
(W internal) Warnings peculiar ta \s-1VMS. \s0 Yo ass tried ta chizzle or delete an
element of tha \s-1CRTL\s0z internal environ array yo, but yo' copy of Perl
wasn't built wit a \s-1CRTL\s0 dat contained tha \fIsetenv()\fR function. I aint talkin' bout chicken n' gravy biatch.  You'll
need ta rebuild Perl wit a \s-1CRTL\s0 dat do, or redefine
\&\fI\s-1PERL_ENV_TABLES\s0\fR (see perlvms) so dat tha environ array aint the
target of tha chizzle to
\&\f(CW%ENV\fR which produced tha warning.
.IP "This Perl has not been built wit support fo' randomized hash key traversal but suttin' called \fIPerl_hv_rand_set()\fR." 4
.IX Item "This Perl has not been built wit support fo' randomized hash key traversal but suttin' called Perl_hv_rand_set()."
(F) Somethang has attempted ta use a internal \s-1API\s0 call which
dependz on Perl bein compiled wit tha default support fo' randomized hash
key traversal yo, but dis Perl has been compiled without dat shit. Yo ass should
report dis warnin ta tha relevant upstream party, or recompile perl
with default options.
.ie n .IP "thread failed ta start: %s" 4
.el .IP "thread failed ta start: \f(CW%s\fR" 4
.IX Item "thread failed ta start: %s"
(W threads)(S) Da entry point function of threads\->\fIcreate()\fR failed fo' some reason.
.IP "times not implemented" 4
.IX Item "times not implemented"
(F) Yo crazy-ass version of tha C library apparently don't do \fItimes()\fR.  I
suspect you not hustlin on Unix.
.ie n .IP """\-T"" is on tha #! line, it must also be used on tha command line" 4
.el .IP "``\-T'' is on tha #! line, it must also be used on tha command line" 4
.IX Item "-T is on tha #! line, it must also be used on tha command line"
(X) Da #! line (or local equivalent) up in a Perl script gotz nuff
the \fB\-T\fR option (or tha \fB\-t\fR option) yo, but Perl was not invoked with
\&\fB\-T\fR up in its command line.  This be a error cuz, by tha time
Perl discovers a \fB\-T\fR up in a script, itz too late ta properly taint
everythang from tha environment.  So Perl gives up.
.Sp
If tha Perl script is bein executed as a cold-ass lil command rockin tha #!
mechanizzle (or its local equivalent), dis error can probably be
fixed by editin tha #! line so dat tha \fB\-%c\fR option be a part of
Perlz first argument: e.g. chizzle \f(CW\*(C`perl \-n \-%c\*(C'\fR ta \f(CW\*(C`perl \-%c \-n\*(C'\fR.
.Sp
If tha Perl script is bein executed as \f(CW\*(C`perl scriptname\*(C'\fR, then the
\&\fB\-%c\fR option must step tha fuck up on tha command line: \f(CW\*(C`perl \-%c scriptname\*(C'\fR.
.IP "To%s: illegal mappin '%s'" 4
.IX Item "To%s: illegal mappin '%s'"
(F) Yo ass tried ta define a cold-ass lil customized To-mappin fo' \fIlc()\fR, lcfirst,
\&\fIuc()\fR, or \fIucfirst()\fR (or they string-inlined versions) yo, but you
specified a illegal mapping.
See \*(L"User-Defined Characta Properties\*(R" up in perlunicode.
.IP "Too deeply nested ()\-groups" 4
.IX Item "Too deeply nested ()-groups"
(F) Yo crazy-ass template gotz nuff ()\-groups wit a ridiculously deep nestin level.
.IP "Too few args ta syscall" 4
.IX Item "Too few args ta syscall"
(F) There has ta be at least one argument ta \fIsyscall()\fR ta specify the
system call ta call, wack-ass dilly.
.ie n .IP "Too late fo' ""\-%s"" option" 4
.el .IP "Too late fo' ``\-%s'' option" 4
.IX Item "Too late fo' -%s option"
(X) Da #! line (or local equivalent) up in a Perl script gotz nuff the
\&\fB\-M\fR, \fB\-m\fR or \fB\-C\fR option.
.Sp
In tha case of \fB\-M\fR n' \fB\-m\fR, dis be a error cuz dem options
are not intended fo' use inside scripts, n' you can put dat on yo' toast.  Use tha \f(CW\*(C`use\*(C'\fR pragma instead.
.Sp
Da \fB\-C\fR option only works if it is specified on tha command line as
well (with tha same sequence of lettas or numbers following).  Either
specify dis option on tha command line, or, if yo' system supports
it, make yo' script executable n' run it directly instead of passing
it ta perl.
.ie n .IP "Too late ta run %s block" 4
.el .IP "Too late ta run \f(CW%s\fR block" 4
.IX Item "Too late ta run %s block"
(W void) A \s-1CHECK\s0 or \s-1INIT\s0 block is bein defined durin run time proper,
when tha opportunitizzle ta run dem has already passed. Y'all KNOW dat shit, muthafucka!  Perhaps yo ass is
loadin a gangbangin' file wit \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR when you should be rockin \f(CW\*(C`use\*(C'\fR
instead. Y'all KNOW dat shit, muthafucka!  Or like you should put tha \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR inside a
\&\s-1BEGIN\s0 block.
.IP "Too nuff args ta syscall" 4
.IX Item "Too nuff args ta syscall"
(F) Perl supports a maximum of only 14 args ta \fIsyscall()\fR.
.ie n .IP "Too nuff arguments fo' %s" 4
.el .IP "Too nuff arguments fo' \f(CW%s\fR" 4
.IX Item "Too nuff arguments fo' %s"
(F) Da function requires fewer arguments than you specified.
.IP "Too nuff )'s" 4
.IX Item "Too nuff )'s"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead of Perl.
Peep tha #! line, or manually feed yo' script tha fuck into Perl yo ass.
.IP "Too nuff ('s" 4
.IX Item "Too nuff ('s"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead of Perl.
Peep tha #! line, or manually feed yo' script tha fuck into Perl yo ass.
.IP "Trailin \e up in regex m/%s/" 4
.IX Item "Trailin up in regex m/%s/"
(F) Da regular expression endz wit a unbackslashed backslash.
Backslash dat shit.   See perlre.
.IP "Trailin white-space up in a cold-ass lil charnames alias definizzle is deprecated" 4
.IX Item "Trailin white-space up in a cold-ass lil charnames alias definizzle is deprecated"
(D) Yo ass defined a cold-ass lil characta name which ended up in a space character.
Remove tha trailin space(s).  Usually these names is defined up in the
\&\f(CW\*(C`:alias\*(C'\fR import argument ta \f(CW\*(C`use charnames\*(C'\fR yo, but they could be defined
by a translator installed tha fuck into \f(CW$^H{charnames}\fR.
See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 up in charnames.
.IP "Transliteration pattern not terminated" 4
.IX Item "Transliteration pattern not terminated"
(F) Da lexer couldn't find tha interior delimita of a tr/// or tr[][]
or y/// or y[][] construct.  Missin tha leadin \f(CW\*(C`$\*(C'\fR from variables
\&\f(CW$tr\fR or \f(CW$y\fR may cause dis error.
.IP "Transliteration replacement not terminated" 4
.IX Item "Transliteration replacement not terminated"
(F) Da lexer couldn't find tha final delimita of a tr///, tr[][],
y/// or y[][] construct.
.IP "'%s' trapped by operation mask" 4
.IX Item "'%s' trapped by operation mask"
(F) Yo ass tried ta use a operator from a Safe compartment up in which it's
disallowed. Y'all KNOW dat shit, muthafucka!  See Safe.
.IP "truncate not implemented" 4
.IX Item "truncate not implemented"
(F) Yo crazy-ass machine don't implement a gangbangin' file truncation mechanizzle that
Configure knows about.
.ie n .IP "Type of arg %d ta &CORE::%s must be %s" 4
.el .IP "Type of arg \f(CW%d\fR ta &CORE::%s must be \f(CW%s\fR" 4
.IX Item "Type of arg %d ta &CORE::%s must be %s"
(F) Da subroutine up in question up in tha \s-1CORE\s0 package requires its argument
to be a hard reference ta data of tha specified type.  Overloadin is
ignored, so a reference ta a object dat aint tha specified type yo, but
nonetheless has overloadin ta handle it, will still not be accepted.
.ie n .IP "Type of arg %d ta %s must be %s (not %s)" 4
.el .IP "Type of arg \f(CW%d\fR ta \f(CW%s\fR must be \f(CW%s\fR (not \f(CW%s\fR)" 4
.IX Item "Type of arg %d ta %s must be %s (not %s)"
(F) This function requires tha argument up in dat posizzle ta be of a
certain type.  Arrays must be \f(CW@NAME\fR or \f(CW\*(C`@{EXPR}\*(C'\fR.  Hashes must be
\&\f(CW%NAME\fR or \f(CW\*(C`%{EXPR}\*(C'\fR.  No implicit dereferencin be allowed\*(--use the
{\s-1EXPR\s0} forms as a explicit dereference.  See perlref.
.ie n .IP "Type of argument ta %s must be unblessed hashref or arrayref" 4
.el .IP "Type of argument ta \f(CW%s\fR must be unblessed hashref or arrayref" 4
.IX Item "Type of argument ta %s must be unblessed hashref or arrayref"
(F) Yo ass called \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR or \f(CW\*(C`each\*(C'\fR wit a scalar argument that
was not a reference ta a unblessed hash or array.
.IP "umask not implemented" 4
.IX Item "umask not implemented"
(F) Yo crazy-ass machine don't implement tha umask function n' you tried to
use it ta restrict permissions fo' yo ass (\s-1EXPR & 0700\s0).
.ie n .IP "Unbalanced context: %d mo' PUSHes than POPs" 4
.el .IP "Unbalanced context: \f(CW%d\fR mo' PUSHes than POPs" 4
.IX Item "Unbalanced context: %d mo' PUSHes than POPs"
(S internal) Da exit code detected a internal inconsistency up in how
many execution contexts was entered n' left.
.ie n .IP "Unbalanced saves: %d mo' saves than restores" 4
.el .IP "Unbalanced saves: \f(CW%d\fR mo' saves than restores" 4
.IX Item "Unbalanced saves: %d mo' saves than restores"
(S internal) Da exit code detected a internal inconsistency up in how
many joints was temporarily localized.
.ie n .IP "Unbalanced scopes: %d mo' ENTERs than LEAVEs" 4
.el .IP "Unbalanced scopes: \f(CW%d\fR mo' ENTERs than LEAVEs" 4
.IX Item "Unbalanced scopes: %d mo' ENTERs than LEAVEs"
(S internal) Da exit code detected a internal inconsistency up in how
many blocks was entered n' left.
.ie n .IP "Unbalanced strang table refcount: (%d) fo' ""%s""" 4
.el .IP "Unbalanced strang table refcount: (%d) fo' ``%s''" 4
.IX Item "Unbalanced strang table refcount: (%d) fo' %s"
(S internal) On exit, Perl found some strings remainin up in tha shared
strin table used fo' copy on write n' fo' hash keys.  Da entries
should done been freed, so dis indicates a funky-ass bug somewhere.
.ie n .IP "Unbalanced tmps: %d mo' allocs than frees" 4
.el .IP "Unbalanced tmps: \f(CW%d\fR mo' allocs than frees" 4
.IX Item "Unbalanced tmps: %d mo' allocs than frees"
(S internal) Da exit code detected a internal inconsistency up in how
many mortal scalars was allocated n' freed.
.ie n .IP "Undefined format ""%s"" called" 4
.el .IP "Undefined format ``%s'' called" 4
.IX Item "Undefined format %s called"
(F) Da format indicated don't seem ta exist.  Perhaps itz straight-up in
another package?  See perlform.
.ie n .IP "Undefined sort subroutine ""%s"" called" 4
.el .IP "Undefined sort subroutine ``%s'' called" 4
.IX Item "Undefined sort subroutine %s called"
(F) Da sort comparison routine specified don't seem ta exist.
Perhaps itz up in a gangbangin' finger-lickin' different package?  See \*(L"sort\*(R" up in perlfunc.
.IP "Undefined subroutine &%s called" 4
.IX Item "Undefined subroutine &%s called"
(F) Da subroutine indicated aint been defined, or if it was, it has
since been undefined.
.IP "Undefined subroutine called" 4
.IX Item "Undefined subroutine called"
(F) Da anonymous subroutine you tryin ta booty-call aint been defined,
or if it was, it has since been undefined.
.IP "Undefined subroutine up in sort" 4
.IX Item "Undefined subroutine up in sort"
(F) Da sort comparison routine specified is declared but don't seem
to done been defined yet.  See \*(L"sort\*(R" up in perlfunc.
.ie n .IP "Undefined top format ""%s"" called" 4
.el .IP "Undefined top format ``%s'' called" 4
.IX Item "Undefined top format %s called"
(F) Da format indicated don't seem ta exist.  Perhaps itz straight-up in
another package?  See perlform.
.IP "Undefined value assigned ta typeglob" 4
.IX Item "Undefined value assigned ta typeglob"
(W misc) An undefined value was assigned ta a typeglob, a la
\&\f(CW\*(C`*foo = undef\*(C'\fR.  This do nothing.  It aint nuthin but possible dat you straight-up mean
\&\f(CW\*(C`undef *foo\*(C'\fR.
.ie n .IP "%s: Undefined variable" 4
.el .IP "\f(CW%s:\fR Undefined variable" 4
.IX Item "%s: Undefined variable"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead of Perl.
Peep tha #! line, or manually feed yo' script tha fuck into Perl yo ass.
.ie n .IP "unexec of %s tha fuck into %s failed!" 4
.el .IP "unexec of \f(CW%s\fR tha fuck into \f(CW%s\fR failed!" 4
.IX Item "unexec of %s tha fuck into %s failed!"
(F) Da \fIunexec()\fR routine failed fo' some reason. I aint talkin' bout chicken n' gravy biatch.  See yo' local \s-1FSF\s0
representative, whoz ass probably put it there up in tha straight-up original gangsta place.
.IP "Unexpected '(' wit no precedin operator up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unexpected '(' wit no precedin operator up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ \ep{Digit} ( \ep{Lao} + \ep{Thai} ) ])
.Ve
.Sp
There should be a operator before tha \f(CW"("\fR, as there be a no indication
as ta how tha fuck tha digits is ta be combined wit tha charactas up in tha Lao
and Thai scripts.
.IP "Unexpected ')' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unexpected ')' up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ ( \ep{Digit} + ) ])
.Ve
.Sp
Da \f(CW")"\fR is out-of-place.  Somethang apparently was supposed ta be
combined wit tha digits, or tha \f(CW"+"\fR shouldn't be there, or something
like dis shit.  Perl can't figure up what tha fuck was intended.
.IP "Unexpected binary operator '%c' wit no precedin operand up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unexpected binary operator '%c' wit no precedin operand up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ | \ep{Digit} ])
.Ve
.Sp
where tha \f(CW"|"\fR be a funky-ass binary operator wit a operand on tha right yo, but
no operand on tha left.
.IP "Unexpected characta up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unexpected characta up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ z ])
.Ve
.Sp
Within \f(CW\*(C`(?[ ])\*(C'\fR, no literal charactas is allowed unless they are
within a inner pair of square brackets, like
.Sp
.Vb 1
\& (?[ [ z ] ])
.Ve
.Sp
Another possibilitizzle is dat you forgot a funky-ass backslash.  Perl aint smart
enough ta figure up what tha fuck you straight-up meant.
.ie n .IP "Unexpected constant lvalue entersub entry via type/targ %d:%d" 4
.el .IP "Unexpected constant lvalue entersub entry via type/targ \f(CW%d:\fR%d" 4
.IX Item "Unexpected constant lvalue entersub entry via type/targ %d:%d"
(P) When compilin a subroutine call up in lvalue context, Perl failed an
internal consistency check.  It encountered a malformed op tree.
.IP "Unicode non-characta U+%X is illegal fo' open interchange" 4
.IX Item "Unicode non-characta U+%X is illegal fo' open interchange"
(S utf8, nonchar) Certain codepoints, like fuckin U+FFFE n' U+FFFF, are
defined by tha Unicode standard ta be non-characters.  Those are
legal codepoints yo, but is reserved fo' internal use; so, applications
shouldn't attempt ta exchange em.  If you know what tha fuck yo ass is bustin
you can turn off dis warnin by \f(CW\*(C`no warnings \*(Aqnonchar\*(Aq;\*(C'\fR.
.IP "Unicode surrogate U+%X is illegal up in \s-1UTF\-8\s0" 4
.IX Item "Unicode surrogate U+%X is illegal up in UTF-8"
(S utf8, surrogate) Yo ass had a \s-1UTF\-16\s0 surrogate up in a cold-ass lil context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), is used by Unicode only fo' \s-1UTF\-16. \s0 But fuck dat shiznit yo, tha word on tha street is dat Perl
internally allows all unsigned integer code points (up ta tha size limit
available on yo' platform), includin surrogates.  But these can cause
problems when bein input or output, which is likely where dis message
came from.  If you straight-up straight-up know what tha fuck yo ass is bustin you can turn
off dis warnin by \f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.IP "Unknown \s-1BYTEORDER\s0" 4
.IX Item "Unknown BYTEORDER"
(F) There is no byte-swappin functions fo' a machine wit dis byte
order.
.IP "Unknown charname '%s'" 4
.IX Item "Unknown charname '%s'"
(F) Da name you used inside \f(CW\*(C`\eN{}\*(C'\fR is unknown ta Perl.  Peep the
spelling.  Yo ass can say \f(CW\*(C`use charnames ":loose"\*(C'\fR ta not gotta be
so precise bout spaces, hyphens, n' capitalization on standard Unicode
names.  (Any custom aliases dat done been pimped must be specified
exactly, regardless of whether \f(CW\*(C`:loose\*(C'\fR is used or not.)  This error may
also happen if tha \f(CW\*(C`\eN{}\*(C'\fR aint up in tha scope of tha corresponding
\&\f(CW\*(C`use\ charnames\*(C'\fR.
.IP "Unknown error" 4
.IX Item "Unknown error"
(P) Perl was bout ta print a error message up in \f(CW$@\fR yo, but tha \f(CW$@\fR variable
did not exist, even afta a attempt ta create dat shit.
.IP "Unknown \fIopen()\fR mode '%s'" 4
.IX Item "Unknown open() mode '%s'"
(F) Da second argument of 3\-argument \fIopen()\fR aint among tha list
of valid modes: \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`>>\*(C'\fR, \f(CW\*(C`+<\*(C'\fR,
\&\f(CW\*(C`+>\*(C'\fR, \f(CW\*(C`+>>\*(C'\fR, \f(CW\*(C`\-|\*(C'\fR, \f(CW\*(C`|\-\*(C'\fR, \f(CW\*(C`<&\*(C'\fR, \f(CW\*(C`>&\*(C'\fR.
.ie n .IP "Unknown PerlIO layer ""%s""" 4
.el .IP "Unknown PerlIO layer ``%s''" 4
.IX Item "Unknown PerlIO layer %s"
(W layer) An attempt was made ta push a unknown layer onto tha Perl I/O
system.  (Layers take care of transformin data between external and
internal representations.)  Note dat some layers, like fuckin \f(CW\*(C`mmap\*(C'\fR,
are not supported up in all environments, n' you can put dat on yo' toast.  If yo' program didn't
explicitly request tha failin operation, it may be tha result of the
value of tha environment variable \s-1PERLIO.\s0
.ie n .IP "Unknown process %x busted message ta prime_env_iter: %s" 4
.el .IP "Unknown process \f(CW%x\fR busted message ta prime_env_iter: \f(CW%s\fR" 4
.IX Item "Unknown process %x busted message ta prime_env_iter: %s"
(P) An error peculiar ta \s-1VMS. \s0 Perl was readin joints fo' \f(CW%ENV\fR before
iteratin over it, n' one of mah thugs stuck a message up in tha stream of
data Perl expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Someonez straight-up confused, or like tryin to
subvert Perlz population of \f(CW%ENV\fR fo' nefarious purposes.
.ie n .IP "Unknown ""re"" subpragma '%s' (known ones are: %s)" 4
.el .IP "Unknown ``re'' subpragma '%s' (known ones are: \f(CW%s\fR)" 4
.IX Item "Unknown re subpragma '%s' (known ones are: %s)"
(W) Yo ass tried ta use a unknown subpragma of tha \*(L"re\*(R" pragma.
.ie n .IP "Unknown regex modifier ""%s""" 4
.el .IP "Unknown regex modifier ``%s''" 4
.IX Item "Unknown regex modifier %s"
(F) Alphanumerics immediately followin tha closin delimiter
of a regular expression pattern is interpreted by Perl as modifier
flags fo' tha regex.  One of tha ones you specified is invalid. Y'all KNOW dat shit, muthafucka!  One way
this can happen is if you didn't put up in white space between tha end of
the regex n' a gangbangin' followin alphanumeric operator:
.Sp
.Vb 1
\& if ($a =~ /foo/and $bar == 3) { ... }
.Ve
.Sp
Da \f(CW"a"\fR be a valid modifier flag yo, but tha \f(CW"n"\fR is not, n' raises
this error. Shiiit, dis aint no joke.  Likely what tha fuck was meant instead was:
.Sp
.Vb 1
\& if ($a =~ /foo/ n' $bar == 3) { ... }
.Ve
.IP "Unknown switch condizzle (?(%s up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unknown switch condizzle (?(%s up in regex; marked by <-- HERE up in m/%s/"
(F) Da condizzle part of a (?(condition)if\-clause|else\-clause) construct
is not known. I aint talkin' bout chicken n' gravy biatch.  Da condizzle must be one of tha following:
.Sp
.Vb 9
\& (1) (2) ...        legit if 1st, 2nd, etc., capture matched
\& (<NAME>) (\*(AqNAME\*(Aq)  legit if named capture matched
\& (?=...) (?<=...)   legit if subpattern matches
\& (?!...) (?<!...)   legit if subpattern fails ta match
\& (?{ CODE })        legit if code returns a legit value
\& (R)                legit if evaluatin inside recursion
\& (R1) (R2) ...      legit if directly inside capture crew 1, 2, etc.
\& (R&NAME)           legit if directly inside named capture
\& (DEFINE)           always false; fo' definin named subpatterns
.Ve
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Unknown Unicode option letta '%c'" 4
.IX Item "Unknown Unicode option letta '%c'"
(F) Yo ass specified a unknown Unicode option. I aint talkin' bout chicken n' gravy biatch.  See perlrun documentation
of tha \f(CW\*(C`\-C\*(C'\fR switch fo' tha list of known options.
.ie n .IP "Unknown Unicode option value %x" 4
.el .IP "Unknown Unicode option value \f(CW%x\fR" 4
.IX Item "Unknown Unicode option value %x"
(F) Yo ass specified a unknown Unicode option. I aint talkin' bout chicken n' gravy biatch.  See perlrun documentation
of tha \f(CW\*(C`\-C\*(C'\fR switch fo' tha list of known options.
.IP "Unknown verb pattern '%s' up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unknown verb pattern '%s' up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass either done cooked up a typo or have incorrectly put a \f(CW\*(C`*\*(C'\fR quantifier
afta a open brace up in yo' pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Peep tha pattern n' review
perlre fo' details on legal verb patterns.
.IP "Unknown warnings category '%s'" 4
.IX Item "Unknown warnings category '%s'"
(F) An error issued by tha \f(CW\*(C`warnings\*(C'\fR pragma.  Yo ass specified a warnings
category dat is unknown ta perl at dis point.
.Sp
Note dat if you wanna enable a warnings category registered by a
module (e.g. \f(CW\*(C`use warnings \*(AqFile::Find\*(Aq\*(C'\fR), you must have loaded this
module first.
.IP "Unmatched '%c' up in \s-1POSIX\s0 class up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unmatched '%c' up in POSIX class up in regex; marked by <-- HERE up in m/%s/"
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ [:alnum] ])
.Ve
.Sp
There should be a second \f(CW":"\fR, like this:
.Sp
.Vb 1
\& (?[ [:alnum:] ])
.Ve
.IP "Unmatched [ up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unmatched [ up in regex; marked by <-- HERE up in m/%s/"
(F) Da brackets round a cold-ass lil characta class must match.  If you wish to
include a cold-ass lil closin bracket up in a cold-ass lil characta class, backslash it or put it
first.  Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Unmatched '[' up in \s-1POSIX\s0 class up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unmatched '[' up in POSIX class up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass had suttin' like this:
.Sp
.Vb 1
\& (?[ [:digit: ])
.Ve
.Sp
That should be written:
.Sp
.Vb 1
\& (?[ [:digit:] ])
.Ve
.IP "Unmatched ( up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unmatched ( up in regex; marked by <-- HERE up in m/%s/"
.PD 0
.IP "Unmatched ) up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unmatched ) up in regex; marked by <-- HERE up in m/%s/"
.PD
(F) Unbackslashed parentheses must always be balanced up in regular
expressions.  If you a vi user, tha % key is valuable fo' finding
the matchin parenthesis.  Da <\-\- \s-1HERE\s0 shows whereabouts up in the
regular expression tha problem was discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "Unmatched right %s bracket" 4
.el .IP "Unmatched right \f(CW%s\fR bracket" 4
.IX Item "Unmatched right %s bracket"
(F) Da lexer counted mo' closin curly or square brackets than opening
ones, so you probably missin a matchin openin bracket.  As a
general rule, you gonna find tha missin one (so ta speak) near tha place
you was last editing.
.ie n .IP "Unquoted strang ""%s"" may clash wit future reserved word" 4
.el .IP "Unquoted strang ``%s'' may clash wit future reserved word" 4
.IX Item "Unquoted strang %s may clash wit future reserved word"
(W reserved) Yo ass used a funky-ass bareword dat might somedizzle be fronted as a
reserved word. Y'all KNOW dat shit, muthafucka!  It aint nuthin but dopest ta put such a word up in quotes, or capitalize it
somehow, or bang a underbar tha fuck into dat shit.  Yo ass might also declare it as a
subroutine.
.ie n .IP "Unrecognized characta %s; marked by <\-\- \s-1HERE\s0 afta %s near column %d" 4
.el .IP "Unrecognized characta \f(CW%s\fR; marked by <\-\- \s-1HERE\s0 afta \f(CW%s\fR near column \f(CW%d\fR" 4
.IX Item "Unrecognized characta %s; marked by <-- HERE afta %s near column %d"
(F) Da Perl parser has no clue what tha fuck ta do wit tha specified character
in yo' Perl script (or eval) near tha specified column. I aint talkin' bout chicken n' gravy biatch.  Perhaps you tried 
to run a cold-ass lil compressed script, a funky-ass binary program, or a gangbangin' finger-lickin' directory as a Perl program.
.IP "Unrecognized escape \e%c up in characta class up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unrecognized escape %c up in characta class up in regex; marked by <-- HERE up in m/%s/"
(F)
Yo ass used a funky-ass backslash-characta combination which aint recognized by
Perl inside characta classes.  This be a gangbangin' fatal error when tha character
class is used within \f(CW\*(C`(?[ ])\*(C'\fR.
.IP "Unrecognized escape \e%c up in characta class passed all up in in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unrecognized escape %c up in characta class passed all up in in regex; marked by <-- HERE up in m/%s/"
(W regexp) Yo ass used a funky-ass backslash-characta combination which is not
recognized by Perl inside characta classes.  Da characta was
understood literally yo, but dis may chizzle up in a gangbangin' future version of Perl.
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression the
escape was discovered.
.IP "Unrecognized escape \e%c passed through" 4
.IX Item "Unrecognized escape %c passed through"
(W misc) Yo ass used a funky-ass backslash-characta combination which is not
recognized by Perl.  Da characta was understood literally yo, but dis may
change up in a gangbangin' future version of Perl.
.IP "Unrecognized escape \e%s passed all up in in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unrecognized escape %s passed all up in in regex; marked by <-- HERE up in m/%s/"
(W regexp) Yo ass used a funky-ass backslash-characta combination which is not
recognized by Perl.  Da character(s) was understood literally yo, but
this may chizzle up in a gangbangin' future version of Perl.  Da <\-\- \s-1HERE\s0 shows
whereabouts up in tha regular expression tha escape was discovered.
.ie n .IP "Unrecognized signal name ""%s""" 4
.el .IP "Unrecognized signal name ``%s''" 4
.IX Item "Unrecognized signal name %s"
(F) Yo ass specified a signal name ta tha \fIkill()\fR function dat was not
recognized. Y'all KNOW dat shit, muthafucka!  Say \f(CW\*(C`kill \-l\*(C'\fR up in yo' shell ta peep tha valid signal names
on yo' system.
.IP "Unrecognized switch: \-%s  (\-h will show valid options)" 4
.IX Item "Unrecognized switch: -%s (-h will show valid options)"
(F) Yo ass specified a illegal option ta Perl.  Don't do dis shit.  (If you
think you didn't do that, check tha #! line ta peep if itz supplyin the
bad switch on yo' behalf.)
.ie n .IP "Unsuccessful %s on filename containin newline" 4
.el .IP "Unsuccessful \f(CW%s\fR on filename containin newline" 4
.IX Item "Unsuccessful %s on filename containin newline"
(W newline) A file operation was attempted on a gangbangin' filename, n' that
operation failed, \s-1PROBABLY\s0 cuz tha filename contained a newline,
\&\s-1PROBABLY\s0 cuz you forgot ta \fIchomp()\fR it off.  See \*(L"chomp\*(R" up in perlfunc.
.ie n .IP "Unsupported directory function ""%s"" called" 4
.el .IP "Unsupported directory function ``%s'' called" 4
.IX Item "Unsupported directory function %s called"
(F) Yo crazy-ass machine don't support \fIopendir()\fR n' \fIreaddir()\fR.
.ie n .IP "Unsupported function %s" 4
.el .IP "Unsupported function \f(CW%s\fR" 4
.IX Item "Unsupported function %s"
(F) This machine don't implement tha indicated function, apparently.
At least, Configure don't be thinkin so.
.IP "Unsupported function fork" 4
.IX Item "Unsupported function fork"
(F) Yo crazy-ass version of executable do not support forking.
.Sp
Note dat under some systems, like \s-1OS/2,\s0 there may be different flavors
of Perl executables, a shitload of which may support fork, some not.  Try
changin tha name you call Perl by ta \f(CW\*(C`perl_\*(C'\fR, \f(CW\*(C`perl_\|_\*(C'\fR, n' so on.
.ie n .IP "Unsupported script encodin %s" 4
.el .IP "Unsupported script encodin \f(CW%s\fR" 4
.IX Item "Unsupported script encodin %s"
(F) Yo crazy-ass program file begins wit a Unicode Byte Order Mark (\s-1BOM\s0) which
declares it ta be up in a Unicode encodin dat Perl cannot read.
.ie n .IP "Unsupported socket function ""%s"" called" 4
.el .IP "Unsupported socket function ``%s'' called" 4
.IX Item "Unsupported socket function %s called"
(F) Yo crazy-ass machine don't support tha Berkeley socket mechanism, or at
least thatz what tha fuck Configure thought.
.IP "Unterminated attribute list" 4
.IX Item "Unterminated attribute list"
(F) Da lexer found suttin' other than a simple identifier at the
start of a attribute, n' it wasn't a semicolon or tha start of a
block.  Perhaps you terminated tha parameta list of tha previous
attribute too soon. I aint talkin' bout chicken n' gravy biatch.  See attributes.
.IP "Unterminated attribute parameta up in attribute list" 4
.IX Item "Unterminated attribute parameta up in attribute list"
(F) Da lexer saw a openin (left) parenthesis characta while parsing
an attribute list yo, but tha matchin closin (right) parenthesis
characta was not found. Y'all KNOW dat shit, muthafucka!  Yo ass may need ta add (or remove) a funky-ass backslash
characta ta git yo' parentheses ta balance.  See attributes.
.IP "Unterminated compressed integer" 4
.IX Item "Unterminated compressed integer"
(F) An argument ta unpack(\*(L"w\*(R",...) was incompatible wit tha \s-1BER\s0
compressed integer format n' could not be converted ta a integer.
See \*(L"pack\*(R" up in perlfunc.
.IP "Unterminated delimita fo' here document" 4
.IX Item "Unterminated delimita fo' here document"
(F) This message occurs when a here document label has a initial
quotation mark but tha final quotation mark is missing.  Perhaps
you wrote:
.Sp
.Vb 1
\&    <<"foo
.Ve
.Sp
instead of:
.Sp
.Vb 1
\&    <<"foo"
.Ve
.IP "Unterminated \eg{...} pattern up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unterminated g{...} pattern up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass missed a cold-ass lil close brace on a \eg{..} pattern (group reference) in
a regular expression. I aint talkin' bout chicken n' gravy biatch.  Fix tha pattern n' retry.
.IP "Unterminated <> operator" 4
.IX Item "Unterminated <> operator"
(F) Da lexer saw a left angle bracket up in a place where dat shiznit was expecting
a term, so itz lookin fo' tha correspondin right angle bracket, and
not findin dat shit.  Chances is you left some needed parentheses out
earlier up in tha line, n' you straight-up meant a \*(L"less than\*(R".
.IP "Unterminated verb pattern argument up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unterminated verb pattern argument up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a pattern of tha form \f(CW\*(C`(*VERB:ARG)\*(C'\fR but did not terminate
the pattern wit a \f(CW\*(C`)\*(C'\fR.  Fix tha pattern n' retry.
.IP "Unterminated verb pattern up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Unterminated verb pattern up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a pattern of tha form \f(CW\*(C`(*VERB)\*(C'\fR but did not terminate
the pattern wit a \f(CW\*(C`)\*(C'\fR.  Fix tha pattern n' retry.
.ie n .IP "untie attempted while %d inner references still exist" 4
.el .IP "untie attempted while \f(CW%d\fR inner references still exist" 4
.IX Item "untie attempted while %d inner references still exist"
(W untie) A copy of tha object returned from \f(CW\*(C`tie\*(C'\fR (or \f(CW\*(C`tied\*(C'\fR) was
still valid when \f(CW\*(C`untie\*(C'\fR was called.
.IP "Usage: POSIX::%s(%s)" 4
.IX Item "Usage: POSIX::%s(%s)"
(F) Yo ass called a \s-1POSIX\s0 function wit incorrect arguments.
See \*(L"\s-1FUNCTIONS\*(R"\s0 up in \s-1POSIX\s0 fo' mo' shiznit.
.IP "Usage: Win32::%s(%s)" 4
.IX Item "Usage: Win32::%s(%s)"
(F) Yo ass called a Win32 function wit incorrect arguments.
See Win32 fo' mo' shiznit.
.ie n .IP "$[ used up in %s (did you mean $] ?)" 4
.el .IP "$[ used up in \f(CW%s\fR (did you mean $] ?)" 4
.IX Item "$[ used up in %s (did you mean $] ?)"
(W syntax) Yo ass used \f(CW$[\fR up in a cold-ass lil comparison, such as:
.Sp
.Vb 3
\&    if ($[ > 5.006) {
\&        ...
\&    }
.Ve
.Sp
Yo ass probably meant ta use \f(CW$]\fR instead. Y'all KNOW dat shit, muthafucka!  \f(CW$[\fR is tha base fo' indexing
arrays.  \f(CW$]\fR is tha Perl version number up in decimal.
.IP "Use \e\ex{...} fo' mo' than two hex charactas up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Use x{...} fo' mo' than two hex charactas up in regex; marked by <-- HERE up in m/%s/"
(F)
In a regular expression, you holla'd suttin' like
.Sp
.Vb 1
\& (?[ [ \exBEEF ] ])
.Ve
.Sp
Perl aint shizzle if you meant this
.Sp
.Vb 1
\& (?[ [ \ex{BEEF} ] ])
.Ve
.Sp
or if you meant this
.Sp
.Vb 1
\& (?[ [ \ex{BE} E F ] ])
.Ve
.Sp
Yo ass need ta add either braces or blanks ta disambiguate.
.IP "Use of \fIeach()\fR on hash afta insertion without resettin hash iterator thangs up in dis biatch up in undefined behavior" 4
.IX Item "Use of each() on hash afta insertion without resettin hash iterator thangs up in dis biatch up in undefined behavior"
(S internal) Da behavior of \f(CW\*(C`each()\*(C'\fR afta insertion is undefined, it may
skip items, or visit shit mo' than once. Consider rockin \f(CW\*(C`keys()\*(C'\fR instead
of \f(CW\*(C`each()\*(C'\fR.
.IP "Useless assignment ta a temporary" 4
.IX Item "Useless assignment ta a temporary"
(W misc) Yo ass assigned ta a lvalue subroutine yo, but what
the subroutine returned was a temporary scalar bout to
be discarded, so tha assignment had no effect.
.IP "Useless (?\-%s) \- don't use /%s modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Useless (?-%s) - don't use /%s modifier up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Yo ass have used a internal modifier like fuckin (?\-o) dat has no
meanin unless removed from tha entire regexp:
.Sp
.Vb 1
\&    if ($strin =~ /(?\-o)$pattern/o) { ... }
.Ve
.Sp
must be freestyled as
.Sp
.Vb 1
\&    if ($strin =~ /$pattern/) { ... }
.Ve
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.ie n .IP "Useless localization of %s" 4
.el .IP "Useless localization of \f(CW%s\fR" 4
.IX Item "Useless localization of %s"
(W syntax) Da localization of lvalues like fuckin \f(CW\*(C`local($x=10)\*(C'\fR is legal,
but up in fact tha \fIlocal()\fR currently has no effect.  This may chizzle at
some point up in tha future yo, but up in tha meantime such code is discouraged.
.IP "Useless (?%s) \- use /%s modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Useless (?%s) - use /%s modifier up in regex; marked by <-- HERE up in m/%s/"
(W regexp) Yo ass have used a internal modifier like fuckin (?o) dat has no
meanin unless applied ta tha entire regexp:
.Sp
.Vb 1
\&    if ($strin =~ /(?o)$pattern/) { ... }
.Ve
.Sp
must be freestyled as
.Sp
.Vb 1
\&    if ($strin =~ /$pattern/o) { ... }
.Ve
.Sp
Da <\-\- \s-1HERE\s0 shows whereabouts up in tha regular expression tha problem was
discovered. Y'all KNOW dat shit, muthafucka!  See perlre.
.IP "Useless use of /d modifier up in transliteration operator" 4
.IX Item "Useless use of /d modifier up in transliteration operator"
(W misc) Yo ass have used tha /d modifier where tha searchlist has the
same length as tha replacelist.  See perlop fo' mo' shiznit
about tha /d modifier.
.IP "Useless use of '\e'; don't escape metacharacta '%c'" 4
.IX Item "Useless use of ''; don't escape metacharacta '%c'"
(D deprecated) Yo ass freestyled a regular expression pattern suttin' like
one of these:
.Sp
.Vb 4
\& m{ \ex\e{FF\e} }x
\& m{foo\e{1,3\e}}
\& qr(foo\e(bar\e))
\& s[foo\e[a\-z\e]bar][baz]
.Ve
.Sp
Da interior braces, square brackets, n' parentheses is treated as
metacharactas even though they is backslashed; instead write:
.Sp
.Vb 4
\& m{ \ex{FF} }x
\& m{foo{1,3}}
\& qr(foo(bar))
\& s[foo[a\-z]bar][baz]
.Ve
.Sp
Da backslashes have no effect when a regular expression pattern is
delimitted by \f(CW\*(C`{}\*(C'\fR, \f(CW\*(C`[]\*(C'\fR, or \f(CW\*(C`()\*(C'\fR, which ordinarily are
metacharacters, n' tha delimitas is also used, paired, within the
interior of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  It be planned dat a gangbangin' future Perl release will
change tha meanin of constructs like these so dat tha backslashes
will have a effect, so remove dem from yo' code.
.IP "Useless use of \eE" 4
.IX Item "Useless use of E"
(W misc) Yo ass gotz a \eE up in a thugged-out double-quotish strang without a \f(CW\*(C`\eU\*(C'\fR,
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eQ\*(C'\fR precedin dat shit.
.ie n .IP "Useless use of %s up in void context" 4
.el .IP "Useless use of \f(CW%s\fR up in void context" 4
.IX Item "Useless use of %s up in void context"
(W void) Yo ass did suttin' without a side effect up in a cold-ass lil context dat do
nothang wit tha return value, like fuckin a statement dat don't return a
value from a funky-ass block, or tha left side of a scalar comma operator. Shiiit, dis aint no joke.  Very
often dis points not ta stupiditizzle on yo' part yo, but a gangbangin' failure of Perl
to parse yo' program tha way you thought it would. Y'all KNOW dat shit, muthafucka!  For example, you'd
get dis if you mixed up yo' C precedence wit Python precedence and
said
.Sp
.Vb 1
\&    $one, $two = 1, 2;
.Ve
.Sp
when you meant ta say
.Sp
.Vb 1
\&    ($one, $two) = (1, 2);
.Ve
.Sp
Another common error is ta use ordinary parentheses ta construct a list
reference when you should be rockin square or curly brackets, for
example, if you say
.Sp
.Vb 1
\&    $array = (1,2);
.Ve
.Sp
when you should have holla'd
.Sp
.Vb 1
\&    $array = [1,2];
.Ve
.Sp
Da square brackets explicitly turn a list value tha fuck into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, tha comma is treated like Cz comma operator, which
throws away tha left argument, which aint what tha fuck you want.  See
perlref fo' mo' on all dis bullshit.
.Sp
This warnin aint gonna be issued fo' numerical constants equal ta 0 or 1
since they is often used up in statements like
.Sp
.Vb 1
\&    1 while sub_with_side_effects();
.Ve
.Sp
Strin constants dat would normally evaluate ta 0 or 1 is warned
about.
.ie n .IP "Useless use of ""re"" pragma" 4
.el .IP "Useless use of ``re'' pragma" 4
.IX Item "Useless use of re pragma"
(W) Yo ass did \f(CW\*(C`use re;\*(C'\fR without any arguments, n' you can put dat on yo' toast.  That aint straight-up useful.
.IP "Useless use of sort up in scalar context" 4
.IX Item "Useless use of sort up in scalar context"
(W void) Yo ass used sort up in scalar context, as up in :
.Sp
.Vb 1
\&    mah $x = sort @y;
.Ve
.Sp
This aint straight-up useful, n' perl currently optimizes dis away.
.IP "Useless use of (?\-p) up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Useless use of (?-p) up in regex; marked by <-- HERE up in m/%s/"
(W regexp)
Da \f(CW\*(C`p\*(C'\fR modifier cannot be turned off once set.  Tryin ta do so is
futile.
.ie n .IP "Useless use of %s wit no joints" 4
.el .IP "Useless use of \f(CW%s\fR wit no joints" 4
.IX Item "Useless use of %s wit no joints"
(W syntax) Yo ass used tha \fIpush()\fR or \fIunshift()\fR function wit no arguments
apart from tha array, like \f(CW\*(C`push(@x)\*(C'\fR or \f(CW\*(C`unshift(@foo)\*(C'\fR.  That won't
usually have any effect on tha array, so is straight-up useless.  It's
possible up in principle dat push(@tied_array) could have some effect
if tha array is tied ta a cold-ass lil class which implements a \s-1PUSH\s0 method. Y'all KNOW dat shit, muthafucka!  If so,
you can write it as \f(CW\*(C`push(@tied_array,())\*(C'\fR ta avoid dis warning.
.ie n .IP "Useless (%s%c) \- %suse /%c modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Useless (%s%c) \- \f(CW%suse\fR /%c modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Useless (%s%c) - %suse /%c modifier up in regex; marked by <-- HERE up in m/%s/"
(W regexp)
Da \f(CW\*(C`/g\*(C'\fR n' \f(CW\*(C`/o\*(C'\fR regular expression modifiers is global n' can't be
turned off once set; hence thangs like \f(CW\*(C`(?g)\*(C'\fR or \f(CW\*(C`(?\-o:)\*(C'\fR do nothing.
.ie n .IP "Useless (%sc) \- %suse /gc modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.el .IP "Useless (%sc) \- \f(CW%suse\fR /gc modifier up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Useless (%sc) - %suse /gc modifier up in regex; marked by <-- HERE up in m/%s/"
(W regexp)
Da \f(CW\*(C`/c\*(C'\fR regular expression modifier is global, can't be turned off
once set, n' don't do anythang without tha \f(CW\*(C`/g\*(C'\fR modifier being
specified as well; hence thangs like \f(CW\*(C`(?c)\*(C'\fR or \f(CW\*(C`(?\-c:)\*(C'\fR do nothing,
nor do thang like \f(CW\*(C`(?gc)\*(C'\fR nor \f(CW\*(C`(?\-gc:)\*(C'\fR .
.ie n .IP """use"" not allowed up in expression" 4
.el .IP "``use'' not allowed up in expression" 4
.IX Item "use not allowed up in expression"
(F) Da \*(L"use\*(R" keyword is recognized n' executed at compile time, and
returns no useful value.  See perlmod.
.IP "Use of assignment ta $[ is deprecated" 4
.IX Item "Use of assignment ta $[ is deprecated"
(D deprecated) Da \f(CW$[\fR variable (index of tha straight-up original gangsta element up in a array)
is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \*(L"$[\*(R" up in perlvar.
.ie n .IP "Use of bare << ta mean <<"""" is deprecated" 4
.el .IP "Use of bare << ta mean <<``'' is deprecated" 4
.IX Item "Use of bare << ta mean <<"""" is deprecated"
(D deprecated) Yo ass is now encouraged ta use tha explicitly quoted
form if you wish ta use a empty line as tha terminator of tha here-document.
.IP "Use of comma-less variable list is deprecated" 4
.IX Item "Use of comma-less variable list is deprecated"
(D deprecated) Da joints you give ta a gangbangin' format should be
separated by commas, not just aligned on a line.
.IP "Use of chdir('') or chdir(undef) as \fIchdir()\fR deprecated" 4
.IX Item "Use of chdir('') or chdir(undef) as chdir() deprecated"
(D deprecated) \fIchdir()\fR wit no arguments is documented ta chizzle to
\&\f(CW$ENV\fR{\s-1HOME\s0} or \f(CW$ENV\fR{\s-1LOGDIR\s0}.  chdir(undef) n' chdir('') share this
behavior yo, but dat has been deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In future versions they
will simply fail.
.Sp
Be careful ta check dat what tha fuck you pass ta \fIchdir()\fR is defined n' not
blank, else you might find yo ass up in yo' home directory.
.IP "Use of /c modifier is meaningless up in s///" 4
.IX Item "Use of /c modifier is meaningless up in s///"
(W regexp) Yo ass used tha /c modifier up in a substitution. I aint talkin' bout chicken n' gravy biatch.  Da /c
modifier aint presently meaningful up in substitutions.
.IP "Use of /c modifier is meaningless without /g" 4
.IX Item "Use of /c modifier is meaningless without /g"
(W regexp) Yo ass used tha /c modifier wit a regex operand yo, but didn't
use tha /g modifier n' shit.  Currently, /c is meaningful only when /g is
used. Y'all KNOW dat shit, muthafucka!  (This may chizzle up in tha future.)
.IP "Use of := fo' a empty attribute list aint allowed" 4
.IX Item "Use of := fo' a empty attribute list aint allowed"
(F) Da construction \f(CW\*(C`my $x := 42\*(C'\fR used ta parse as equivalent to
\&\f(CW\*(C`my $x : = 42\*(C'\fR (applyin a empty attribute list ta \f(CW$x\fR).
This construct was deprecated up in 5.12.0, n' has now been done cooked up a syntax
error, so \f(CW\*(C`:=\*(C'\fR can be reclaimed as a freshly smoked up operator up in tha future.
.Sp
If you need a empty attribute list, fo' example up in a cold-ass lil code generator, add
a space before tha \f(CW\*(C`=\*(C'\fR.
.IP "Use of freed value up in iteration" 4
.IX Item "Use of freed value up in iteration"
(F) Perhaps you modified tha iterated array within tha loop?
This error is typically caused by code like tha following:
.Sp
.Vb 2
\&    @a = (3,4);
\&    @a = () fo' (1,2,@a);
.Ve
.Sp
Yo ass aint supposed ta modify arrays while they is bein iterated over.
For speed n' efficiency reasons, Perl internally do not do full
reference-countin of iterated items, hence deletin such a item up in the
middle of a iteration causes Perl ta peep a gangbangin' freed value.
.IP "Use of *glob{\s-1FILEHANDLE\s0} is deprecated" 4
.IX Item "Use of *glob{FILEHANDLE} is deprecated"
(D deprecated) Yo ass is now encouraged ta use tha shorta *glob{\s-1IO\s0} form
to access tha filehandle slot within a typeglob.
.IP "Use of /g modifier is meaningless up in split" 4
.IX Item "Use of /g modifier is meaningless up in split"
(W regexp) Yo ass used tha /g modifier on tha pattern fo' a \f(CW\*(C`split\*(C'\fR
operator. Shiiit, dis aint no joke.  Since \f(CW\*(C`split\*(C'\fR always tries ta match tha pattern
repeatedly, tha \f(CW\*(C`/g\*(C'\fR has no effect.
.ie n .IP "Use of ""goto"" ta jump tha fuck into a cold-ass lil construct is deprecated" 4
.el .IP "Use of ``goto'' ta jump tha fuck into a cold-ass lil construct is deprecated" 4
.IX Item "Use of goto ta jump tha fuck into a cold-ass lil construct is deprecated"
(D deprecated) Usin \f(CW\*(C`goto\*(C'\fR ta jump from a outa scope tha fuck into a inner
scope is deprecated n' should be avoided.
.IP "Use of inherited \s-1AUTOLOAD\s0 fo' non-method %s() is deprecated" 4
.IX Item "Use of inherited AUTOLOAD fo' non-method %s() is deprecated"
(D deprecated) As a (ahem) accidental feature, \f(CW\*(C`AUTOLOAD\*(C'\fR
subroutines is looked up as methodz (usin tha \f(CW@ISA\fR hierarchy)
even when tha subroutines ta be autoloaded was called as plain
functions (e.g. \f(CW\*(C`Foo::bar()\*(C'\fR), not as methodz (e.g. \f(CW\*(C`Foo\->bar()\*(C'\fR or
\&\f(CW\*(C`$obj\->bar()\*(C'\fR).
.Sp
This bug is ghon be rectified up in future by rockin method lookup only for
methods' \f(CW\*(C`AUTOLOAD\*(C'\fRs.  But fuck dat shiznit yo, tha word on tha street is dat there be a thugged-out dope base of existing
code dat may be rockin tha oldschool behavior. Shiiit, dis aint no joke.  So, as a interim step, Perl
currently thangs a optionizzle warnin when non-methodz use inherited
\&\f(CW\*(C`AUTOLOAD\*(C'\fRs.
.Sp
Da simple rule is:  Inheritizzle aint gonna work when autoloading
non-methods.  Da simple fix fo' oldschool code is:  In any module dat used
to depend on inheritin \f(CW\*(C`AUTOLOAD\*(C'\fR fo' non-methodz from a funky-ass base class
named \f(CW\*(C`BaseClass\*(C'\fR, execute \f(CW\*(C`*AUTOLOAD = \e&BaseClass::AUTOLOAD\*(C'\fR during
startup.
.Sp
In code dat currently say \f(CW\*(C`use AutoLoader; @ISA = qw(AutoLoader);\*(C'\fR
you should remove AutoLoader from \f(CW@ISA\fR n' chizzle \f(CW\*(C`use AutoLoader;\*(C'\fR to
\&\f(CW\*(C`use AutoLoader \*(AqAUTOLOAD\*(Aq;\*(C'\fR.
.ie n .IP "Use of %s up in printf format not supported" 4
.el .IP "Use of \f(CW%s\fR up in printf format not supported" 4
.IX Item "Use of %s up in printf format not supported"
(F) Yo ass attempted ta bust a gangbangin' feature of printf dat be accessible from
only C.  This probably means there be a a funky-ass betta way ta do it up in Perl.
.ie n .IP "Use of %s is deprecated" 4
.el .IP "Use of \f(CW%s\fR is deprecated" 4
.IX Item "Use of %s is deprecated"
(D deprecated) Da construct indicated is no longer recommended fo' use,
generally cuz there be a a funky-ass betta way ta do it, n' also cuz the
old way has wack side effects.
.ie n .IP "Use of \-l on filehandle %s" 4
.el .IP "Use of \-l on filehandle \f(CW%s\fR" 4
.IX Item "Use of -l on filehandle %s"
(W io) A filehandle represents a opened file, n' when you opened tha file
it already went past any symlink yo ass is presumably tryin ta look for.
Da operation returned \f(CW\*(C`undef\*(C'\fR.  Use a gangbangin' filename instead.
.ie n .IP "Use of mah $_ is experimental" 4
.el .IP "Use of mah \f(CW$_\fR is experimental" 4
.IX Item "Use of mah $_ is experimental"
(S experimental::lexical_topic) Lexical \f(CW$_\fR be a experimenstrual feature and
its behavior may chizzle or even be removed up in any future release of perl.
See tha explanation under \*(L"$_\*(R" up in perlvar.
.ie n .IP "Use of %s on a handle without * is deprecated" 4
.el .IP "Use of \f(CW%s\fR on a handle without * is deprecated" 4
.IX Item "Use of %s on a handle without * is deprecated"
(D deprecated) Yo ass used \f(CW\*(C`tie\*(C'\fR, \f(CW\*(C`tied\*(C'\fR or \f(CW\*(C`untie\*(C'\fR on a scalar but dat scalar
happens ta hold a typeglob, which means its filehandle is ghon be tied. Y'all KNOW dat shit, muthafucka!  If
you mean ta tie a handle, use a explicit * as up in \f(CW\*(C`tie *$handle\*(C'\fR.
.Sp
This was a long-standin bug dat was removed up in Perl 5.16, as there was
no way ta tie tha scalar itself when it held a typeglob, n' no way to
untie a scalar dat had had a typeglob assigned ta dat shit.  If you peep this
message, you must be rockin a olda version.
.IP "Use of ?PATTERN? without explicit operator is deprecated" 4
.IX Item "Use of ?PATTERN? without explicit operator is deprecated"
(D deprecated) Yo ass have freestyled suttin' like \f(CW\*(C`?\ew?\*(C'\fR, fo' a regular
expression dat matches only once.  Startin dis term directly with
the question mark delimita is now deprecated, so dat tha question mark
will be available fo' use up in freshly smoked up operators up in tha future.  Write \f(CW\*(C`m?\ew?\*(C'\fR
instead, explicitly rockin tha \f(CW\*(C`m\*(C'\fR operator: tha question mark delimiter
still invokes match-once behaviour.
.ie n .IP "Use of reference ""%s"" as array index" 4
.el .IP "Use of reference ``%s'' as array index" 4
.IX Item "Use of reference %s as array index"
(W misc) Yo ass tried ta bust a reference as a array index; dis probably
aint what tha fuck you mean, cuz references up in numerical context tend
to be big-ass numbers, n' so probably indicates programmer error.
.Sp
If you straight-up do mean it, explicitly numify yo' reference, like so:
\&\f(CW$array[0+$ref]\fR.  This warnin aint given fo' overloaded objects,
however, cuz you can overload tha numification n' stringification
operators n' then you presumably know what tha fuck yo ass is bustin.
.ie n .IP "Use of state $_ is experimental" 4
.el .IP "Use of state \f(CW$_\fR is experimental" 4
.IX Item "Use of state $_ is experimental"
(S experimental::lexical_topic) Lexical \f(CW$_\fR be a experimenstrual feature and
its behavior may chizzle or even be removed up in any future release of perl.
See tha explanation under \*(L"$_\*(R" up in perlvar.
.ie n .IP "Use of tainted arguments up in %s is deprecated" 4
.el .IP "Use of tainted arguments up in \f(CW%s\fR is deprecated" 4
.IX Item "Use of tainted arguments up in %s is deprecated"
(W taint, deprecated) Yo ass have supplied \f(CW\*(C`system()\*(C'\fR or \f(CW\*(C`exec()\*(C'\fR wit multiple
arguments n' at least one of dem is tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This used ta be allowed
but will become a gangbangin' fatal error up in a gangbangin' future version of perl.  Untaint your
arguments, n' you can put dat on yo' toast.  See perlsec.
.IP "Use of uninitialized value%s" 4
.IX Item "Use of uninitialized value%s"
(W uninitialized) An undefined value was used as if it was already
defined. Y'all KNOW dat shit, muthafucka!  Dat shiznit was interpreted as a "" or a 0 yo, but maybe dat shiznit was a mistake.
To suppress dis warnin assign a thugged-out defined value ta yo' variables.
.Sp
To help you figure up what tha fuck was undefined, perl will try ta rap 
the name of tha variable (if any) dat was undefined. Y'all KNOW dat shit, muthafucka!  In some cases
it cannot do this, so it also  drops some lyrics ta you what tha fuck operation you used the
undefined value in. I aint talkin' bout chicken n' gravy biatch.  Note, however, dat perl optimizes yo' program
anid tha operation displayed up in tha warnin may not necessarily appear
literally up in yo' program.  For example, \f(CW"that $foo"\fR is usually
optimized tha fuck into \f(CW\*(C`"that " . $foo\*(C'\fR, n' tha warnin will refer ta the
\&\f(CW\*(C`concatenation (.)\*(C'\fR operator, even though there is no \f(CW\*(C`.\*(C'\fR in
your program.
.IP "Usin a hash as a reference is deprecated" 4
.IX Item "Usin a hash as a reference is deprecated"
(D deprecated) Yo ass tried ta bust a hash as a reference, as in
\&\f(CW\*(C`%foo\->{"bar"}\*(C'\fR or \f(CW\*(C`%$ref\->{"hello"}\*(C'\fR.  Versionz of perl <= 5.6.1
used ta allow dis syntax yo, but shouldn't have.   It be now
deprecated, n' is ghon be removed up in a gangbangin' future version.
.IP "Usin a array as a reference is deprecated" 4
.IX Item "Usin a array as a reference is deprecated"
(D deprecated) Yo ass tried ta use a array as a reference, as in
\&\f(CW\*(C`@foo\->[23]\*(C'\fR or \f(CW\*(C`@$ref\->[99]\*(C'\fR.  Versionz of perl <= 5.6.1 used to
allow dis syntax yo, but shouldn't have.  It be now deprecated,
and is ghon be removed up in a gangbangin' future version.
.IP "Usin just tha straight-up original gangsta characta returned by \eN{} up in characta class up in regex; marked by <\-\- \s-1HERE\s0 up in m/%s/" 4
.IX Item "Usin just tha straight-up original gangsta characta returned by N{} up in characta class up in regex; marked by <-- HERE up in m/%s/"
(W regexp) A charnames handlez may return a sequence of mo' than one
character n' shit.  Currently all but tha straight-up original gangsta one is discarded when used in
a regular expression pattern bracketed characta class.
.ie n .IP "Usin !~ wit %s don't make sense" 4
.el .IP "Usin !~ wit \f(CW%s\fR don't make sense" 4
.IX Item "Usin !~ wit %s don't make sense"
(F) Usin tha \f(CW\*(C`!~\*(C'\fR operator wit \f(CW\*(C`s///r\*(C'\fR, \f(CW\*(C`tr///r\*(C'\fR or \f(CW\*(C`y///r\*(C'\fR is
currently reserved fo' future use, as tha exact behaviour has not
been decided. Y'all KNOW dat shit, muthafucka!  (Simply returnin tha boolean opposite of the
modified strang is probably not particularly useful.)
.IP "\s-1UTF\-16\s0 surrogate U+%X" 4
.IX Item "UTF-16 surrogate U+%X"
(S utf8, surrogate) Yo ass had a \s-1UTF\-16\s0 surrogate up in a cold-ass lil context where they are
not considered acceptable.  These code points, between U+D800 and
U+DFFF (inclusive), is used by Unicode only fo' \s-1UTF\-16. \s0 But fuck dat shiznit yo, tha word on tha street is dat Perl
internally allows all unsigned integer code points (up ta tha size limit
available on yo' platform), includin surrogates.  But these can cause
problems when bein input or output, which is likely where dis message
came from.  If you straight-up straight-up know what tha fuck yo ass is bustin you can turn
off dis warnin by \f(CW\*(C`no warnings \*(Aqsurrogate\*(Aq;\*(C'\fR.
.ie n .IP "Value of %s can be ""0""; test wit \fIdefined()\fR" 4
.el .IP "Value of \f(CW%s\fR can be ``0''; test wit \fIdefined()\fR" 4
.IX Item "Value of %s can be 0; test wit defined()"
(W misc) In a cold-ass lil conditionizzle expression, you used <\s-1HANDLE\s0>, <*> (glob),
\&\f(CW\*(C`each()\*(C'\fR, or \f(CW\*(C`readdir()\*(C'\fR as a funky-ass boolean value.  Each of these constructs
can return a value of \*(L"0\*(R"; dat would make tha conditionizzle expression
false, which is probably not what tha fuck you intended. Y'all KNOW dat shit, muthafucka!  When rockin these
constructs up in conditionizzle expressions, test they joints wit the
\&\f(CW\*(C`defined\*(C'\fR operator.
.ie n .IP "Value of \s-1CLI\s0 symbol ""%s"" too long" 4
.el .IP "Value of \s-1CLI\s0 symbol ``%s'' too long" 4
.IX Item "Value of CLI symbol %s too long"
(W misc) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read tha value of an
\&\f(CW%ENV\fR element from a \s-1CLI\s0 symbol table, n' found a resultant string
longer than 1024 characters.  Da return value has been truncated to
1024 characters.
.ie n .IP "Variable ""%s"" aint available" 4
.el .IP "Variable ``%s'' aint available" 4
.IX Item "Variable %s aint available"
(W closure) Durin compilation, a inner named subroutine or eval is
attemptin ta capture a outa lexical dat aint currently available.
This can happen fo' one of two reasons.  First, tha outa lexical may be
declared up in a outa anonymous subroutine dat has not yet been pimped.
(Remember dat named subs is pimped at compile time, while anonymous
subs is pimped at run-time.)  For example,
.Sp
.Vb 1
\&    sub { mah $a; sub f { $a } }
.Ve
.Sp
At tha time dat f is pimped, it can't capture tha current value of \f(CW$a\fR,
since tha anonymous subroutine aint been pimped yet.  Conversely,
the followin won't give a warnin since tha anonymous subroutine has by
now been pimped n' is live:
.Sp
.Vb 1
\&    sub { mah $a; eval \*(Aqsub f { $a }\*(Aq }\->();
.Ve
.Sp
Da second thang is caused by a eval accessin a variable dat has
gone outta scope, fo' example,
.Sp
.Vb 5
\&    sub f {
\&        mah $a;
\&        sub { eval \*(Aq$a\*(Aq }
\&    }
\&    f()\->();
.Ve
.Sp
Here, when tha '$a' up in tha eval is bein compiled, f() aint currently being
executed, so its \f(CW$a\fR aint available fo' capture.
.ie n .IP "Variable ""%s"" aint imported%s" 4
.el .IP "Variable ``%s'' aint imported%s" 4
.IX Item "Variable %s aint imported%s"
(S misc) With \*(L"use strict\*(R" up in effect, you referred ta a global variable
that you apparently thought was imported from another module, cuz
suttin' else of tha same name (usually a subroutine) is exported by
that module.  It probably means you put tha wack funky characta on the
front of yo' variable.
.IP "Variable length lookbehind not implemented up in regex m/%s/" 4
.IX Item "Variable length lookbehind not implemented up in regex m/%s/"
(F) Lookbehind be allowed only fo' subexpressions whose length is fixed and
known at compile time.  See perlre.
.ie n .IP """%s"" variable %s masks earlier declaration up in same %s" 4
.el .IP "``%s'' variable \f(CW%s\fR masks earlier declaration up in same \f(CW%s\fR" 4
.IX Item "%s variable %s masks earlier declaration up in same %s"
(W misc) A \*(L"my\*(R", \*(L"our\*(R" or \*(L"state\*(R" variable has been redeclared up in the
current scope or statement, effectively eliminatin all access ta the
previous instance.  This be almost always a typographical error. Shiiit, dis aint no joke.  Note
that tha earlier variable will still exist until tha end of tha scope
or until all closure references ta it is destroyed.
.IP "Variable syntax" 4
.IX Item "Variable syntax"
(A) You've accidentally run yo' script all up in \fBcsh\fR instead
of Perl.  Peep tha #! line, or manually feed yo' script into
Perl yo ass.
.ie n .IP "Variable ""%s"" aint gonna stay shared" 4
.el .IP "Variable ``%s'' aint gonna stay shared" 4
.IX Item "Variable %s aint gonna stay shared"
(W closure) An inner (nested) \fInamed\fR subroutine is referencin a
lexical variable defined up in a outa named subroutine.
.Sp
When tha inner subroutine is called, it will peep tha value of
the outa subroutinez variable as dat shiznit was before n' durin tha *first*
call ta tha outa subroutine; up in dis case, afta tha straight-up original gangsta call ta the
outa subroutine is complete, tha inner n' outa subroutines will no
longer share a cold-ass lil common value fo' tha variable.  In other lyrics, the
variable will no longer be shared.
.Sp
This problem can probably be solved by makin tha inner subroutine
anonymous, rockin tha \f(CW\*(C`sub {}\*(C'\fR syntax.  When inner anonymous subs that
reference variablez up in outa subroutines is pimped, they
are automatically rebound ta tha current jointz of such variables.
.IP "vector argument not supported wit alpha versions" 4
.IX Item "vector argument not supported wit alpha versions"
(S printf) Da \f(CW%vd\fR (s)printf format do not support version objects
with alpha parts.
.IP "Verb pattern '%s' has a mandatory argument up in regex; marked by <\-\- \s-1HERE \s0 up in m/%s/" 4
.IX Item "Verb pattern '%s' has a mandatory argument up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a verb pattern dat requires a argument.  Supply an
argument or check dat yo ass is rockin tha right verb.
.IP "Verb pattern '%s' may not have a argument up in regex; marked by <\-\- \s-1HERE \s0 up in m/%s/" 4
.IX Item "Verb pattern '%s' may not have a argument up in regex; marked by <-- HERE up in m/%s/"
(F) Yo ass used a verb pattern dat aint allowed a argument.  Remove tha 
argument or check dat yo ass is rockin tha right verb.
.IP "Version number must be a cold-ass lil constant number" 4
.IX Item "Version number must be a cold-ass lil constant number"
(P) Da attempt ta translate a \f(CW\*(C`use Module n.n LIST\*(C'\fR statement into
its equivalent \f(CW\*(C`BEGIN\*(C'\fR block found a internal inconsistency with
the version number.
.IP "Version strang '%s' gotz nuff invalid data; ignoring: '%s'" 4
.IX Item "Version strang '%s' gotz nuff invalid data; ignoring: '%s'"
(W misc) Da version strang gotz nuff invalid charactas all up in tha end, which
are bein ignored.
.IP "Warning: somethingz wrong" 4
.IX Item "Warning: somethingz wrong"
(W) Yo ass passed \fIwarn()\fR a empty strang (the equivalent of \f(CW\*(C`warn ""\*(C'\fR) or
you called it wit no args n' \f(CW$@\fR was empty.
.ie n .IP "Warning: unable ta close filehandle %s properly" 4
.el .IP "Warning: unable ta close filehandle \f(CW%s\fR properly" 4
.IX Item "Warning: unable ta close filehandle %s properly"
(S) Da implicit \fIclose()\fR done by a \fIopen()\fR gots a error indication on
the \fIclose()\fR.  This probably indicates yo' file system ran outta disk
space.
.ie n .IP "Warning: Use of ""%s"" without parentheses be ambiguous" 4
.el .IP "Warning: Use of ``%s'' without parentheses be ambiguous" 4
.IX Item "Warning: Use of %s without parentheses be ambiguous"
(S ambiguous) Yo ass freestyled a unary operator followed by suttin' that
looks like a funky-ass binary operator dat could also done been interpreted as a
term or unary operator. Shiiit, dis aint no joke.  For instance, if you know dat tha rand
function has a thugged-out default argument of 1.0, n' you write
.Sp
.Vb 1
\&    rand + 5;
.Ve
.Sp
you may \s-1THINK\s0 you freestyled tha same thang as
.Sp
.Vb 1
\&    rand() + 5;
.Ve
.Sp
but up in actual fact, you got
.Sp
.Vb 1
\&    rand(+5);
.Ve
.Sp
So put up in parentheses ta say what tha fuck you straight-up mean.
.IP "when is experimental" 4
.IX Item "when is experimental"
(S experimental::smartmatch) \f(CW\*(C`when\*(C'\fR dependz on smartmatch, which is
experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Additionally, it has nuff muthafuckin special cases dat may
not be immediately obvious, n' they behavior may chizzle or
even be removed up in any future release of perl.
See tha explanation under \*(L"Experimenstrual Details on given n' when\*(R" up in perlsyn.
.ie n .IP "Wide characta up in %s" 4
.el .IP "Wide characta up in \f(CW%s\fR" 4
.IX Item "Wide characta up in %s"
(S utf8) Perl kicked it wit a wide characta (>255) when it wasn't expecting
one.  This warnin is by default on fo' I/O (like print).  Da easiest
way ta on tha down-low dis warnin is simply ta add tha \f(CW\*(C`:utf8\*(C'\fR layer ta the
output, e.g. \f(CW\*(C`binmode STDOUT, \*(Aq:utf8\*(Aq\*(C'\fR.  Another way ta turn off the
warnin is ta add \f(CW\*(C`no warnings \*(Aqutf8\*(Aq;\*(C'\fR but dat is often closer to
cheating.  In general, yo ass is supposed ta explicitly mark the
filehandle wit a encoding, peep open n' \*(L"binmode\*(R" up in perlfunc.
.IP "Within []\-length '%c' not allowed" 4
.IX Item "Within []-length '%c' not allowed"
(F) Da count up in tha (un)pack template may be replaced by \f(CW\*(C`[TEMPLATE]\*(C'\fR
only if \f(CW\*(C`TEMPLATE\*(C'\fR always matches tha same ol' dirty amount of packed bytes that
can be determined from tha template ridin' solo.  This aint possible if
it gotz nuff any of tha codes @, /, U, u, w or a *\-length.  Redesign
the template.
.ie n .IP "\fIwrite()\fR on closed filehandle %s" 4
.el .IP "\fIwrite()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "write() on closed filehandle %s"
(W closed) Da filehandle you freestylin ta gots itself closed sometime
before now, nahmeean?  Peep yo' control flow.
.ie n .IP "%s ""\ex%X"" do not map ta Unicode" 4
.el .IP "\f(CW%s\fR ``\ex%X'' do not map ta Unicode" 4
.IX Item "%s x%X do not map ta Unicode"
(F) When readin up in different encodings, Perl tries ta map every last muthafuckin thang
into Unicode characters.  Da bytes you read up in is not legal in
this encoding.  For example
.Sp
.Vb 1
\&    utf8 "\exE4" do not map ta Unicode
.Ve
.Sp
if you try ta read up in tha a\-diaereses Latin\-1 as \s-1UTF\-8.\s0
.IP "'X' outside of string" 4
.IX Item "'X' outside of string"
(F) Yo ass had a (un)pack template dat specified a relatizzle posizzle before
the beginnin of tha strang bein (un)packed. Y'all KNOW dat shit, muthafucka!  See \*(L"pack\*(R" up in perlfunc.
.IP "'x' outside of strang up in unpack" 4
.IX Item "'x' outside of strang up in unpack"
(F) Yo ass had a pack template dat specified a relatizzle posizzle after
the end of tha strang bein unpacked. Y'all KNOW dat shit, muthafucka!  See \*(L"pack\*(R" up in perlfunc.
.IP "\s-1YOU HAVEN\s0'T \s-1DISABLED\s0 SET-ID \s-1SCRIPTS IN THE KERNEL YET\s0!" 4
.IX Item "YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!"
(F) And you probably never will, cuz you probably aint gots the
sources ta yo' kernel, n' yo' vendor probably don't give a rip
about what tha fuck you want.  Yo crazy-ass dopest bet is ta put a setuid C wrapper around
your script.
.ie n .IP "Yo ass need ta quote ""%s""" 4
.el .IP "Yo ass need ta quote ``%s''" 4
.IX Item "Yo ass need ta quote %s"
(W syntax) Yo ass assigned a funky-ass bareword as a signal handlez name.
Unfortunately, you already gotz a subroutine of dat name declared,
which means dat Perl 5 will try ta booty-call tha subroutine when the
assignment is executed, which is probably not what tha fuck you want.  (If it \s-1IS\s0
what you want, put a & up in front.)
.IP "Yo crazy-ass random numbers is not dat random" 4
.IX Item "Yo crazy-ass random numbers is not dat random"
(F) When tryin ta initialise tha random seed fo' hashes, Perl could
not git any randomnizz outta yo' system.  This probably indicates
Somethang Straight-up Wrong.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, perllexwarn, diagnostics.
