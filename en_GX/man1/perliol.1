.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIOL 1"
.TH PERLIOL 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perliol \- C API fo' Perlz implementation of IO up in Layers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    /* Definin a layer ... */
\&    #include <perliol.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout tha behavior n' implementation of tha PerlIO
abstraction busted lyrics bout up in perlapio when \f(CW\*(C`USE_PERLIO\*(C'\fR is defined (and
\&\f(CW\*(C`USE_SFIO\*(C'\fR is not).
.SS "History n' Background"
.IX Subsection "History n' Background"
Da PerlIO abstraction was introduced up in perl5.003_02 but languished as
just a abstraction until perl5.7.0 yo. However durin dat time a number
of perl extensions switched ta rockin it, so tha \s-1API\s0 is mostly fixed to
maintain (source) compatibility.
.PP
Da aim of tha implementation is ta provide tha PerlIO \s-1API\s0 up in a gangbangin' flexible
and platform neutral manner n' shit. Well shiiiit, it be also a trial of a \*(L"Object Oriented
C, wit vtables\*(R" approach which may be applied ta Perl 6.
.SS "Basic Structure"
.IX Subsection "Basic Structure"
PerlIO be a stack of layers.
.PP
Da low levelz of tha stack work wit tha low-level operatin system
calls (file descriptors up in C) gettin bytes up in n' out, tha higher
layerz of tha stack buffer, filter, n' otherwise manipulate tha I/O,
and return charactas (or bytes) ta Perl.  Terms \fIabove\fR n' \fIbelow\fR
are used ta refer ta tha relatizzle positionin of tha stack layers.
.PP
A layer gotz nuff a \*(L"vtable\*(R", tha table of I/O operations (at C level
a table of function pointers), n' status flags.  Da functions up in the
vtable implement operations like \*(L"open\*(R", \*(L"read\*(R", n' \*(L"write\*(R".
.PP
When I/O, fo' example \*(L"read\*(R", is requested, tha request goes from Perl
first down tha stack rockin \*(L"read\*(R" functionz of each layer, then at the
bottom tha input be axed from tha operatin system skillz, then
the result is returned up tha stack, finally bein interpreted as Perl
data.
.PP
Da requests do not necessarily go always all tha way down ta the
operatin system: thatz where PerlIO bufferin comes tha fuck into play.
.PP
When you do a \fIopen()\fR n' specify extra PerlIO layers ta be deployed,
the layers you specify is \*(L"pushed\*(R" on top of tha already existing
default stack.  One way ta peep it is dat \*(L"operatin system is
on tha left\*(R" n' \*(L"Perl is on tha right\*(R".
.PP
What exact layers is up in dis default stack dependz on a shitload of
things: yo' operatin system, Perl version, Perl compile time
configuration, n' Perl runtime configuration. I aint talkin' bout chicken n' gravy biatch.  See PerlIO,
\&\*(L"\s-1PERLIO\*(R"\s0 up in perlrun, n' open fo' mo' shiznit.
.PP
\&\fIbinmode()\fR operates similarly ta \fIopen()\fR: by default tha specified
layers is pushed on top of tha existin stack.
.PP
But fuck dat shiznit yo, tha word on tha street is dat note dat even as tha specified layers is \*(L"pushed on top\*(R"
for \fIopen()\fR n' \fIbinmode()\fR, dis don't mean dat tha effects are
limited ta tha \*(L"top\*(R": PerlIO layers can be straight-up 'active' n' inspect
and affect layers also deeper up in tha stack.  As a example there
is a layer called \*(L"raw\*(R" which repeatedly \*(L"pops\*(R" layers until
it reaches tha straight-up original gangsta layer dat has declared itself capable of
handlin binary data.  Da \*(L"pushed\*(R" layers is processed up in left-to-right
order.
.PP
\&\fIsysopen()\fR operates (unsurprisingly) at a lower level up in tha stack than
\&\fIopen()\fR.  For example up in Unix or Unix-like systems \fIsysopen()\fR operates
directly all up in tha level of file descriptors: up in tha termz of PerlIO
layers, it uses only tha \*(L"unix\*(R" layer, which be a rather thin wrapper
on top of tha Unix file descriptors.
.SS "Layers vs Disciplines"
.IX Subsection "Layers vs Disciplines"
Initial rap of tha mobilitizzle ta modify \s-1IO\s0 streams behaviour used
the term \*(L"discipline\*(R" fo' tha entitizzles which was added. Y'all KNOW dat shit, muthafucka! This came (I
believe) from tha use of tha term up in \*(L"sfio\*(R", which up in turn borrowed it
from \*(L"line disciplines\*(R" on Unix terminals. But fuck dat shiznit yo, tha word on tha street is dat dis document (and
the C code) uses tha term \*(L"layer\*(R".
.PP
This is, I hope, a natural term given tha implementation, n' should
avoid connotations dat is inherent up in earlier usez of \*(L"discipline\*(R"
for thangs which is rather different.
.SS "Data Structures"
.IX Subsection "Data Structures"
Da basic data structure be a PerlIOl:
.PP
.Vb 3
\&        typedef struct _PerlIO PerlIOl;
\&        typedef struct _PerlIO_funcs PerlIO_funcs;
\&        typedef PerlIOl *PerlIO;
\&
\&        struct _PerlIO
\&        {
\&         PerlIOl *      next;       /* Lower layer */
\&         PerlIO_funcs * tab;        /* Functions fo' dis layer */
\&         IV             flags;      /* Various flags fo' state */
\&        };
.Ve
.PP
A \f(CW\*(C`PerlIOl *\*(C'\fR be a pointa ta tha struct, n' tha \fIapplication\fR
level \f(CW\*(C`PerlIO *\*(C'\fR be a pointa ta a \f(CW\*(C`PerlIOl *\*(C'\fR \- i.e. a pointer
to a pointa ta tha struct. This allows tha application level \f(CW\*(C`PerlIO *\*(C'\fR
to remain constant while tha actual \f(CW\*(C`PerlIOl *\*(C'\fR underneath
changes. (Compare perlz \f(CW\*(C`SV *\*(C'\fR which remains constant while its
\&\f(CW\*(C`sv_any\*(C'\fR field chizzlez as tha scalarz type chizzles.) An \s-1IO\s0 stream is
then up in general represented as a pointa ta dis linked-list of
\&\*(L"layers\*(R".
.PP
It should be noted dat cuz of tha double indirection up in a \f(CW\*(C`PerlIO *\*(C'\fR,
a \f(CW\*(C`&(perlio\->next)\*(C'\fR \*(L"is\*(R" a \f(CW\*(C`PerlIO *\*(C'\fR, n' so ta some degree
at least one layer can use tha \*(L"standard\*(R" \s-1API\s0 on tha next layer down.
.PP
A \*(L"layer\*(R" is composed of two parts:
.IP "1." 4
Da functions n' attributez of tha \*(L"layer class\*(R".
.IP "2." 4
Da per-instizzle data fo' a particular handle.
.SS "Functions n' Attributes"
.IX Subsection "Functions n' Attributes"
Da functions n' attributes is accessed via tha \*(L"tab\*(R" (for table)
gangmember of \f(CW\*(C`PerlIOl\*(C'\fR. Da functions (methodz of tha layer \*(L"class\*(R") are
fixed, n' is defined by tha \f(CW\*(C`PerlIO_funcs\*(C'\fR type. They is broadly the
same as tha hood \f(CW\*(C`PerlIO_xxxxx\*(C'\fR functions:
.PP
.Vb 10
\&  struct _PerlIO_funcs
\&  {
\&   Size_t               fsize;
\&   char *               name;
\&   Size_t               size;
\&   IV           kind;
\&   IV           (*Pushed)(pTHX_ PerlIO *f,const char *mode,SV *arg, PerlIO_funcs *tab);
\&   IV           (*Popped)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
\&   IV           (*Binmode)(pTHX_ PerlIO *f);
\&   SV *         (*Getarg)(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
\&   IV           (*Fileno)(pTHX_ PerlIO *f);
\&   PerlIO *     (*Dup)(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
\&   /* Unix\-like functions \- cf sfio line disciplines */
\&   SSize_t      (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
\&   SSize_t      (*Unread)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   SSize_t      (*Write)(pTHX_ PerlIO *f, const void *vbuf, Size_t count);
\&   IV           (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
\&   Off_t        (*Tell)(pTHX_ PerlIO *f);
\&   IV           (*Close)(pTHX_ PerlIO *f);
\&   /* Stdio\-like buffered IO functions */
\&   IV           (*Flush)(pTHX_ PerlIO *f);
\&   IV           (*Fill)(pTHX_ PerlIO *f);
\&   IV           (*Eof)(pTHX_ PerlIO *f);
\&   IV           (*Error)(pTHX_ PerlIO *f);
\&   void         (*Clearerr)(pTHX_ PerlIO *f);
\&   void         (*Setlinebuf)(pTHX_ PerlIO *f);
\&   /* Perl\*(Aqs snoopin functions */
\&   STDCHAR *    (*Get_base)(pTHX_ PerlIO *f);
\&   Size_t       (*Get_bufsiz)(pTHX_ PerlIO *f);
\&   STDCHAR *    (*Get_ptr)(pTHX_ PerlIO *f);
\&   SSize_t      (*Get_cnt)(pTHX_ PerlIO *f);
\&   void         (*Set_ptrcnt)(pTHX_ PerlIO *f,STDCHAR *ptr,SSize_t cnt);
\&  };
.Ve
.PP
Da first few thugz of tha struct give a gangbangin' function table size for
compatibilitizzle check \*(L"name\*(R" fo' tha layer, tha  size ta \f(CW\*(C`malloc\*(C'\fR fo' tha per-instizzle data,
and some flags which is attributez of tha class as whole (like fuckin whether it aint nuthin but a funky-ass buffering
layer), then follow tha functions which fall tha fuck into four basic groups:
.IP "1." 4
Openin n' setup functions
.IP "2." 4
Basic \s-1IO\s0 operations
.IP "3." 4
Stdio class bufferin options.
.IP "4." 4
Functions ta support Perlz traditionizzle \*(L"fast\*(R" access ta tha buffer.
.PP
A layer do not gotta implement all tha functions yo, but tha whole
table has ta be present. Unimplemented slots can be \s-1NULL \s0(which will
result up in a error when called) or can be filled up in wit stubs to
\&\*(L"inherit\*(R" behaviour from a \*(L"base class\*(R". This \*(L"inheritance\*(R" is fixed
for all instancez of tha layer yo, but as tha layer chizzlez which stubs
to populate tha table, limited \*(L"multiple inheritance\*(R" is possible.
.SS "Per-instizzle Data"
.IX Subsection "Per-instizzle Data"
Da per-instizzle data is held up in memory beyond tha basic PerlIOl
struct, by bustin a PerlIOl tha straight-up original gangsta gangmember of tha layerz struct
thus:
.PP
.Vb 10
\&        typedef struct
\&        {
\&         struct _PerlIO base;       /* Base "class" info */
\&         STDCHAR *      buf;        /* Start of buffer */
\&         STDCHAR *      end;        /* End of valid part of buffer */
\&         STDCHAR *      ptr;        /* Current posizzle up in buffer */
\&         Off_t          posn;       /* Offset of buf tha fuck into tha file */
\&         Size_t         bufsiz;     /* Real size of buffer */
\&         IV             oneword;    /* Emergency buffer */
\&        } PerlIOBuf;
.Ve
.PP
In dis way (as fo' perlz scalars) a pointa ta a PerlIOBuf can be
treated as a pointa ta a PerlIOl.
.SS "Layers up in action."
.IX Subsection "Layers up in action."
.Vb 8
\&                table           perlio          unix
\&            |           |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&   PerlIO \->|           |\-\-\->|  next    |\-\-\->|  NULL  |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-\-\-+    +\-\-\-\-\-\-\-\-+
\&            |           |    |  buffer  |    |   fd   |
\&            +\-\-\-\-\-\-\-\-\-\-\-+    |          |    +\-\-\-\-\-\-\-\-+
\&            |           |    +\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Da above attempts ta show how tha fuck tha layer scheme works up in a simple case.
Da applicationz \f(CW\*(C`PerlIO *\*(C'\fR points ta a entry up in tha table(s)
representin open (allocated) handles. For example tha straight-up original gangsta three slots
in tha table correspond ta \f(CW\*(C`stdin\*(C'\fR,\f(CW\*(C`stdout\*(C'\fR n' \f(CW\*(C`stderr\*(C'\fR. Da table
in turn points ta tha current \*(L"top\*(R" layer fo' tha handle \- up in dis case
an instizzle of tha generic bufferin layer \*(L"perlio\*(R". That layer up in turn
points ta tha next layer down \- up in dis case tha low-level \*(L"unix\*(R" layer.
.PP
Da above is roughly equivalent ta a \*(L"stdio\*(R" buffered stream yo, but with
much mo' flexibility:
.IP "\(bu" 4
If Unix level \f(CW\*(C`read\*(C'\fR/\f(CW\*(C`write\*(C'\fR/\f(CW\*(C`lseek\*(C'\fR aint appropriate fo' (say)
sockets then tha \*(L"unix\*(R" layer can be replaced (at open time or even
dynamically) wit a \*(L"socket\*(R" layer.
.IP "\(bu" 4
Different handlez can have different bufferin schemes. Da \*(L"top\*(R"
layer could be tha \*(L"mmap\*(R" layer if readin disk filez was quicker
usin \f(CW\*(C`mmap\*(C'\fR than \f(CW\*(C`read\*(C'\fR fo' realz. An \*(L"unbuffered\*(R" stream can be implemented
simply by not havin a funky-ass buffer layer.
.IP "\(bu" 4
Extra layers can be banged ta process tha data as it flows through.
This was tha rollin need fo' includin tha scheme up in perl 5.7.0+ \- we
needed a mechanizzle ta allow data ta be translated between perl's
internal encodin (conceptually at least Unicode as \s-1UTF\-8\s0), n' the
\&\*(L"native\*(R" format used by tha system. This is provided by the
\&\*(L":encoding(xxxx)\*(R" layer which typically sits above tha bufferin layer.
.IP "\(bu" 4
A layer can be added dat do \*(L"\en\*(R" ta \s-1CRLF\s0 translation. I aint talkin' bout chicken n' gravy biatch. This layer
can be used on any platform, not just dem dat normally do such
things.
.SS "Per-instizzle flag bits"
.IX Subsection "Per-instizzle flag bits"
Da generic flag bits is a hybrid of \f(CW\*(C`O_XXXXX\*(C'\fR steez flags deduced
from tha mode strang passed ta \f(CW\*(C`PerlIO_open()\*(C'\fR, n' state bits for
typical buffer layers.
.IP "\s-1PERLIO_F_EOF\s0" 4
.IX Item "PERLIO_F_EOF"
End of file.
.IP "\s-1PERLIO_F_CANWRITE\s0" 4
.IX Item "PERLIO_F_CANWRITE"
Writes is permitted, i.e. opened as \*(L"w\*(R" or \*(L"r+\*(R" or \*(L"a\*(R", etc.
.IP "\s-1PERLIO_F_CANREAD\s0" 4
.IX Item "PERLIO_F_CANREAD"
Readz is permitted i.e. opened \*(L"r\*(R" or \*(L"w+\*(R" (or even \*(L"a+\*(R" \- ick).
.IP "\s-1PERLIO_F_ERROR\s0" 4
.IX Item "PERLIO_F_ERROR"
An error has occurred (for \f(CW\*(C`PerlIO_error()\*(C'\fR).
.IP "\s-1PERLIO_F_TRUNCATE\s0" 4
.IX Item "PERLIO_F_TRUNCATE"
Truncate file suggested by open mode.
.IP "\s-1PERLIO_F_APPEND\s0" 4
.IX Item "PERLIO_F_APPEND"
All writes should be appends.
.IP "\s-1PERLIO_F_CRLF\s0" 4
.IX Item "PERLIO_F_CRLF"
Layer is struttin Win32\-like \*(L"\en\*(R" mapped ta \s-1CR,LF\s0 fo' output n' \s-1CR,LF\s0
mapped ta \*(L"\en\*(R" fo' input. Normally tha provided \*(L"crlf\*(R" layer is tha only
layer dat need bother bout all dis bullshit. \f(CW\*(C`PerlIO_binmode()\*(C'\fR will mess wit this
flag rather than add/remove layers if tha \f(CW\*(C`PERLIO_K_CANCRLF\*(C'\fR bit is set
for tha layers class.
.IP "\s-1PERLIO_F_UTF8\s0" 4
.IX Item "PERLIO_F_UTF8"
Data freestyled ta dis layer should be \s-1UTF\-8\s0 encoded; data provided
by dis layer should be considered \s-1UTF\-8\s0 encoded. Y'all KNOW dat shit, muthafucka! Can be set on any layer
by \*(L":utf8\*(R" dummy layer n' shiznit fo' realz. Also set on \*(L":encoding\*(R" layer.
.IP "\s-1PERLIO_F_UNBUF\s0" 4
.IX Item "PERLIO_F_UNBUF"
Layer is unbuffered \- i.e. write ta next layer down should occur for
each write ta dis layer.
.IP "\s-1PERLIO_F_WRBUF\s0" 4
.IX Item "PERLIO_F_WRBUF"
Da buffer fo' dis layer currently holdz data freestyled ta it but not sent
to next layer.
.IP "\s-1PERLIO_F_RDBUF\s0" 4
.IX Item "PERLIO_F_RDBUF"
Da buffer fo' dis layer currently holdz unconsumed data read from
layer below.
.IP "\s-1PERLIO_F_LINEBUF\s0" 4
.IX Item "PERLIO_F_LINEBUF"
Layer is line buffered. Y'all KNOW dat shit, muthafucka! Write data should be passed ta next layer down
whenever a \*(L"\en\*(R" is seen. I aint talkin' bout chicken n' gravy biatch fo' realz. Any data beyond tha \*(L"\en\*(R" should then be
processed.
.IP "\s-1PERLIO_F_TEMP\s0" 4
.IX Item "PERLIO_F_TEMP"
File has been \f(CW\*(C`unlink()\*(C'\fRed, or should be deleted on \f(CW\*(C`close()\*(C'\fR.
.IP "\s-1PERLIO_F_OPEN\s0" 4
.IX Item "PERLIO_F_OPEN"
Handle is open.
.IP "\s-1PERLIO_F_FASTGETS\s0" 4
.IX Item "PERLIO_F_FASTGETS"
This instizzle of dis layer supports tha "fast \f(CW\*(C`gets\*(C'\fR" intercourse.
Normally set based on \f(CW\*(C`PERLIO_K_FASTGETS\*(C'\fR fo' tha class n' by the
existence of tha function(s) up in tha table yo. However a cold-ass lil class that
normally serves up dat intercourse may need ta avoid it on a
particular instance. Da \*(L"pending\*(R" layer need ta do dis when
it is pushed above a layer which do not support tha intercourse.
(Perlz \f(CW\*(C`sv_gets()\*(C'\fR do not expect tha streams fast \f(CW\*(C`gets\*(C'\fR behaviour
to chizzle durin one \*(L"get\*(R".)
.SS "Methodz up in Detail"
.IX Subsection "Methodz up in Detail"
.IP "fsize" 4
.IX Item "fsize"
.Vb 1
\&        Size_t fsize;
.Ve
.Sp
Size of tha function table. This is compared against tha value PerlIO
code \*(L"knows\*(R" as a cold-ass lil compatibilitizzle check. Future versions \fImay\fR be able
to tolerate layers compiled against a oldschool version of tha headers.
.IP "name" 4
.IX Item "name"
.Vb 1
\&        char * name;
.Ve
.Sp
Da name of tha layer whose \fIopen()\fR method Perl should invoke on
\&\fIopen()\fR.  For example if tha layer is called \s-1APR,\s0 yo big-ass booty is ghon call:
.Sp
.Vb 1
\&  open $fh, ">:APR", ...
.Ve
.Sp
and Perl knows dat it has ta invoke tha \fIPerlIOAPR_open()\fR method
implemented by tha \s-1APR\s0 layer.
.IP "size" 4
.IX Item "size"
.Vb 1
\&        Size_t size;
.Ve
.Sp
Da size of tha per-instizzle data structure, e.g.:
.Sp
.Vb 1
\&  sizeof(PerlIOAPR)
.Ve
.Sp
If dis field is zero then \f(CW\*(C`PerlIO_pushed\*(C'\fR do not malloc anything
and assumes layerz Pushed function will do any required layer stack
manipulation \- used ta avoid malloc/free overhead fo' dummy layers.
If tha field is non-zero it must be at least tha size of \f(CW\*(C`PerlIOl\*(C'\fR,
\&\f(CW\*(C`PerlIO_pushed\*(C'\fR will allocate memory fo' tha layerz data structures
and link freshly smoked up layer onto tha streamz stack. (If tha layerz Pushed
method returns a error indication tha layer is popped again.)
.IP "kind" 4
.IX Item "kind"
.Vb 1
\&        IV kind;
.Ve
.RS 4
.IP "\(bu" 4
\&\s-1PERLIO_K_BUFFERED\s0
.Sp
Da layer is buffered.
.IP "\(bu" 4
\&\s-1PERLIO_K_RAW\s0
.Sp
Da layer be aaight ta have up in a funky-ass binmode(\s-1FH\s0) stack \- i.e. it do not
(or will configure itself not to) transform bytes passin all up in dat shit.
.IP "\(bu" 4
\&\s-1PERLIO_K_CANCRLF\s0
.Sp
Layer can translate between \*(L"\en\*(R" n' \s-1CRLF\s0 line ends.
.IP "\(bu" 4
\&\s-1PERLIO_K_FASTGETS\s0
.Sp
Layer allows buffer snooping.
.IP "\(bu" 4
\&\s-1PERLIO_K_MULTIARG\s0
.Sp
Used when tha layerz \fIopen()\fR accepts mo' arguments than usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. The
extra arguments should come not before tha \f(CW\*(C`MODE\*(C'\fR argument. When this
flag is used itz up ta tha layer ta validate tha args.
.RE
.RS 4
.RE
.IP "Pushed" 4
.IX Item "Pushed"
.Vb 1
\&        IV      (*Pushed)(pTHX_ PerlIO *f,const char *mode, SV *arg);
.Ve
.Sp
Da only straight-up mandatory method. Y'all KNOW dat shit, muthafucka! Called when tha layer is pushed
onto tha stack.  Da \f(CW\*(C`mode\*(C'\fR argument may be \s-1NULL\s0 if dis occurs
post-open. I aint talkin' bout chicken n' gravy biatch. Da \f(CW\*(C`arg\*(C'\fR is ghon be non\-\f(CW\*(C`NULL\*(C'\fR if a argument strang was
passed. Y'all KNOW dat shit, muthafucka! In most cases dis should call \f(CW\*(C`PerlIOBase_pushed()\*(C'\fR to
convert \f(CW\*(C`mode\*(C'\fR tha fuck into tha appropriate \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags in
addizzle ta any actions tha layer itself takes.  If a layer is not
expectin a argument it need neither save tha one passed ta it, nor
provide \f(CW\*(C`Getarg()\*(C'\fR (it could like \f(CW\*(C`Perl_warn\*(C'\fR dat tha argument
was un-expected).
.Sp
Returns 0 on success. On failure returns \-1 n' should set errno.
.IP "Popped" 4
.IX Item "Popped"
.Vb 1
\&        IV      (*Popped)(pTHX_ PerlIO *f);
.Ve
.Sp
Called when tha layer is popped from tha stack fo' realz. A layer will normally
be popped afta \f(CW\*(C`Close()\*(C'\fR is called. Y'all KNOW dat shit, muthafucka! But a layer can be popped
without bein closed if tha program is dynamically managin layers on
the stream. In such cases \f(CW\*(C`Popped()\*(C'\fR should free any resources
(buffers, translation tables, ...) not held directly up in tha layer's
struct.  It should also \f(CW\*(C`Unread()\*(C'\fR any unconsumed data dat has been
read n' buffered from tha layer below back ta dat layer, so dat it
can be re-provided ta what tha fuck eva is now above.
.Sp
Returns 0 on success n' failure.  If \f(CW\*(C`Popped()\*(C'\fR returns \fItrue\fR then
\&\fIperlio.c\fR assumes dat either tha layer has popped itself, or the
layer is supa special n' need ta be retained fo' other reasons.
In most cases it should return \fIfalse\fR.
.IP "Open" 4
.IX Item "Open"
.Vb 1
\&        PerlIO *        (*Open)(...);
.Ve
.Sp
Da \f(CW\*(C`Open()\*(C'\fR method has fuckin shitloadz of arguments cuz it combines the
functionz of perlz \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`PerlIO_open\*(C'\fR, perlz \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`PerlIO_fdopen\*(C'\fR n' \f(CW\*(C`PerlIO_reopen\*(C'\fR.  Da full prototype be as
bigs up:
.Sp
.Vb 6
\& PerlIO *       (*Open)(pTHX_ PerlIO_funcs *tab,
\&                        PerlIO_list_t *layers, IV n,
\&                        const char *mode,
\&                        int fd, int imode, int perm,
\&                        PerlIO *old,
\&                        int narg, SV **args);
.Ve
.Sp
Open should (like indirectly) call \f(CW\*(C`PerlIO_allocate()\*(C'\fR ta allocate
a slot up in tha table n' associate it wit tha layers shiznit for
the opened file, by callin \f(CW\*(C`PerlIO_push\*(C'\fR.  Da \fIlayers\fR be an
array of all tha layers destined fo' tha \f(CW\*(C`PerlIO *\*(C'\fR, n' any
arguments passed ta them, \fIn\fR is tha index tha fuck into dat array of the
layer bein called. Y'all KNOW dat shit, muthafucka! Da macro \f(CW\*(C`PerlIOArg\*(C'\fR will return a (possibly
\&\f(CW\*(C`NULL\*(C'\fR) \s-1SV\s0 * fo' tha argument passed ta tha layer.
.Sp
Da \fImode\fR strang be a "\f(CW\*(C`fopen()\*(C'\fR\-like" strang which would match
the regular expression \f(CW\*(C`/^[I#]?[rwa]\e+?[bt]?$/\*(C'\fR.
.Sp
Da \f(CW\*(AqI\*(Aq\fR prefix is used durin creation of \f(CW\*(C`stdin\*(C'\fR..\f(CW\*(C`stderr\*(C'\fR via
special \f(CW\*(C`PerlIO_fdopen\*(C'\fR calls; tha \f(CW\*(Aq#\*(Aq\fR prefix means dat dis is
\&\f(CW\*(C`sysopen\*(C'\fR n' dat \fIimode\fR n' \fIperm\fR should be passed to
\&\f(CW\*(C`PerlLIO_open3\*(C'\fR; \f(CW\*(Aqr\*(Aq\fR means \fBr\fRead, \f(CW\*(Aqw\*(Aq\fR means \fBw\fRrite and
\&\f(CW\*(Aqa\*(Aq\fR means \fBa\fRppend yo, but it ain't no stoppin cause I be still poppin'. Da \f(CW\*(Aq+\*(Aq\fR suffix means dat both readin and
writing/appendin is permitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW\*(Aqb\*(Aq\fR suffix means file should
be binary, n' \f(CW\*(Aqt\*(Aq\fR means it is text. (Almost all layers should do
the \s-1IO\s0 up in binary mode, n' ignore tha b/t bits, n' you can put dat on yo' toast. Da \f(CW\*(C`:crlf\*(C'\fR layer
should be pushed ta handle tha distinction.)
.Sp
If \fIold\fR aint \f(CW\*(C`NULL\*(C'\fR then dis be a \f(CW\*(C`PerlIO_reopen\*(C'\fR. Perl itself
does not use dis (yet?) n' semantics is a lil vague.
.Sp
If \fIfd\fR not wack then it is tha numeric file descriptor \fIfd\fR,
which is ghon be open up in a manner compatible wit tha supplied mode
string, tha call is thus equivalent ta \f(CW\*(C`PerlIO_fdopen\*(C'\fR. In dis case
\&\fInargs\fR is ghon be zero.
.Sp
If \fInargs\fR is pimped outa than zero then it gives tha number of arguments
passed ta \f(CW\*(C`open\*(C'\fR, otherwise it is ghon be 1 if fo' example
\&\f(CW\*(C`PerlIO_open\*(C'\fR was called. Y'all KNOW dat shit, muthafucka!  In simple cases SvPV_nolen(*args) is the
pathname ta open.
.Sp
If a layer serves up \f(CW\*(C`Open()\*(C'\fR it should normally call tha \f(CW\*(C`Open()\*(C'\fR
method of next layer down (if any) n' then push itself on top if that
succeeds.  \f(CW\*(C`PerlIOBase_open\*(C'\fR is provided ta do exactly that, so in
most cases you don't gotta write yo' own \f(CW\*(C`Open()\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  If this
method aint defined, other layers may have hang-up pushing
themselves on top of it durin open.
.Sp
If \f(CW\*(C`PerlIO_push\*(C'\fR was performed n' open has failed, it must
\&\f(CW\*(C`PerlIO_pop\*(C'\fR itself, since if itz not, tha layer won't be removed
and may cause wack problems.
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Binmode" 4
.IX Item "Binmode"
.Vb 1
\&        IV        (*Binmode)(pTHX_ PerlIO *f);
.Ve
.Sp
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Used when \f(CW\*(C`:raw\*(C'\fR layer is pushed (explicitly or as a result
of binmode(\s-1FH\s0)). If not present layer is ghon be popped. Y'all KNOW dat shit, muthafucka! If present
should configure layer as binary (or pop itself) n' return 0.
If it returns \-1 fo' error \f(CW\*(C`binmode\*(C'\fR will fail wit layer
still on tha stack.
.IP "Getarg" 4
.IX Item "Getarg"
.Vb 2
\&        SV *      (*Getarg)(pTHX_ PerlIO *f,
\&                            CLONE_PARAMS *param, int flags);
.Ve
.Sp
Optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If present should return a \s-1SV\s0 * representin tha string
argument passed ta tha layer when it was
pushed. Y'all KNOW dat shit, muthafucka! e.g. \*(L":encoding(ascii)\*(R" would return a SvPV wit value
\&\*(L"ascii\*(R". (\fIparam\fR n' \fIflags\fR arguments can be ignored up in most
cases)
.Sp
\&\f(CW\*(C`Dup\*(C'\fR uses \f(CW\*(C`Getarg\*(C'\fR ta retrieve tha argument originally passed to
\&\f(CW\*(C`Pushed\*(C'\fR, so you must implement dis function if yo' layer has an
extra argument ta \f(CW\*(C`Pushed\*(C'\fR n' will eva be \f(CW\*(C`Dup\*(C'\fRed.
.IP "Fileno" 4
.IX Item "Fileno"
.Vb 1
\&        IV        (*Fileno)(pTHX_ PerlIO *f);
.Ve
.Sp
Returns tha Unix/Posix numeric file descriptor fo' tha handle. Normally
\&\f(CW\*(C`PerlIOBase_fileno()\*(C'\fR (which just asks next layer down) will suffice
for all dis bullshit.
.Sp
Returns \-1 on error, which is considered ta include tha case where the
layer cannot provide such a gangbangin' file descriptor.
.IP "Dup" 4
.IX Item "Dup"
.Vb 2
\&        PerlIO * (*Dup)(pTHX_ PerlIO *f, PerlIO *o,
\&                        CLONE_PARAMS *param, int flags);
.Ve
.Sp
\&\s-1XXX:\s0 Needz mo' docs.
.Sp
Used as part of tha \*(L"clone\*(R" process when a thread is spawned (in which
case param is ghon be non-NULL) n' when a stream is bein duplicated via
\&'&' up in tha \f(CW\*(C`open\*(C'\fR.
.Sp
Similar ta \f(CW\*(C`Open\*(C'\fR, returns PerlIO* on success, \f(CW\*(C`NULL\*(C'\fR on failure.
.IP "Read" 4
.IX Item "Read"
.Vb 1
\&        SSize_t (*Read)(pTHX_ PerlIO *f, void *vbuf, Size_t count);
.Ve
.Sp
Basic read operation.
.Sp
Typically will call \f(CW\*(C`Fill\*(C'\fR n' manipulate pointas (possibly via the
\&\s-1API\s0).  \f(CW\*(C`PerlIOBuf_read()\*(C'\fR may be suitable fo' derived classes which
provide \*(L"fast gets\*(R" methods.
.Sp
Returns actual bytes read, or \-1 on a error.
.IP "Unread" 4
.IX Item "Unread"
.Vb 2
\&        SSize_t (*Unread)(pTHX_ PerlIO *f,
\&                          const void *vbuf, Size_t count);
.Ve
.Sp
A superset of stdioz \f(CW\*(C`ungetc()\*(C'\fR. Right back up in yo muthafuckin ass. Should arrange fo' future readz to
see tha bytes up in \f(CW\*(C`vbuf\*(C'\fR. If there is no obviously betta implementation
then \f(CW\*(C`PerlIOBase_unread()\*(C'\fR serves up tha function by pushin a \*(L"fake\*(R"
\&\*(L"pending\*(R" layer above tha callin layer.
.Sp
Returns tha number of unread chars.
.IP "Write" 4
.IX Item "Write"
.Vb 1
\&        SSize_t (*Write)(PerlIO *f, const void *vbuf, Size_t count);
.Ve
.Sp
Basic write operation.
.Sp
Returns bytes freestyled or \-1 on a error.
.IP "Seek" 4
.IX Item "Seek"
.Vb 1
\&        IV      (*Seek)(pTHX_ PerlIO *f, Off_t offset, int whence);
.Ve
.Sp
Posizzle tha file pointer n' shit. Right back up in yo muthafuckin ass. Should normally call its own \f(CW\*(C`Flush\*(C'\fR
method n' then tha \f(CW\*(C`Seek\*(C'\fR method of next layer down.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Tell" 4
.IX Item "Tell"
.Vb 1
\&        Off_t   (*Tell)(pTHX_ PerlIO *f);
.Ve
.Sp
Return tha file pointer n' shit. May be based on layers cached concept of
posizzle ta avoid overhead.
.Sp
Returns \-1 on failure ta git tha file pointer.
.IP "Close" 4
.IX Item "Close"
.Vb 1
\&        IV      (*Close)(pTHX_ PerlIO *f);
.Ve
.Sp
Close tha stream. Right back up in yo muthafuckin ass. Should normally call \f(CW\*(C`PerlIOBase_close()\*(C'\fR ta flush
itself n' close layers below, n' then deallocate any data structures
(buffers, translation tables, ...) not  held directly up in tha data
structure.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Flush" 4
.IX Item "Flush"
.Vb 1
\&        IV      (*Flush)(pTHX_ PerlIO *f);
.Ve
.Sp
Should make streamz state consistent wit layers below. That is, any
buffered write data should be written, n' file posizzle of lower layers
adjusted fo' data read from below but not straight-up consumed.
(Should like \f(CW\*(C`Unread()\*(C'\fR such data ta tha lower layer.)
.Sp
Returns 0 on success, \-1 on failure.
.IP "Fill" 4
.IX Item "Fill"
.Vb 1
\&        IV      (*Fill)(pTHX_ PerlIO *f);
.Ve
.Sp
Da buffer fo' dis layer should be filled (for read) from layer
below.  When you \*(L"subclass\*(R" PerlIOBuf layer, you wanna use its
\&\fI_read\fR method n' ta supply yo' own fill method, which fills the
PerlIOBufz buffer.
.Sp
Returns 0 on success, \-1 on failure.
.IP "Eof" 4
.IX Item "Eof"
.Vb 1
\&        IV      (*Eof)(pTHX_ PerlIO *f);
.Ve
.Sp
Return end-of-file indicator. Shiiit, dis aint no joke. \f(CW\*(C`PerlIOBase_eof()\*(C'\fR is normally sufficient.
.Sp
Returns 0 on end-of-file, 1 if not end-of-file, \-1 on error.
.IP "Error" 4
.IX Item "Error"
.Vb 1
\&        IV      (*Error)(pTHX_ PerlIO *f);
.Ve
.Sp
Return error indicator. Shiiit, dis aint no joke. \f(CW\*(C`PerlIOBase_error()\*(C'\fR is normally sufficient.
.Sp
Returns 1 if there be a error (usually when \f(CW\*(C`PERLIO_F_ERROR\*(C'\fR is set),
0 otherwise.
.IP "Clearerr" 4
.IX Item "Clearerr"
.Vb 1
\&        void    (*Clearerr)(pTHX_ PerlIO *f);
.Ve
.Sp
Clear end-of-file n' error indicators. Right back up in yo muthafuckin ass. Should call \f(CW\*(C`PerlIOBase_clearerr()\*(C'\fR
to set tha \f(CW\*(C`PERLIO_F_XXXXX\*(C'\fR flags, which may suffice.
.IP "Setlinebuf" 4
.IX Item "Setlinebuf"
.Vb 1
\&        void    (*Setlinebuf)(pTHX_ PerlIO *f);
.Ve
.Sp
Mark tha stream as line buffered. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`PerlIOBase_setlinebuf()\*(C'\fR sets the
\&\s-1PERLIO_F_LINEBUF\s0 flag n' is normally sufficient.
.IP "Get_base" 4
.IX Item "Get_base"
.Vb 1
\&        STDCHAR *       (*Get_base)(pTHX_ PerlIO *f);
.Ve
.Sp
Allocate (if not already done so) tha read buffer fo' dis layer and
return pointa ta dat shit. Return \s-1NULL\s0 on failure.
.IP "Get_bufsiz" 4
.IX Item "Get_bufsiz"
.Vb 1
\&        Size_t  (*Get_bufsiz)(pTHX_ PerlIO *f);
.Ve
.Sp
Return tha number of bytes dat last \f(CW\*(C`Fill()\*(C'\fR put up in tha buffer.
.IP "Get_ptr" 4
.IX Item "Get_ptr"
.Vb 1
\&        STDCHAR *       (*Get_ptr)(pTHX_ PerlIO *f);
.Ve
.Sp
Return tha current read pointa relatizzle ta dis layerz buffer.
.IP "Get_cnt" 4
.IX Item "Get_cnt"
.Vb 1
\&        SSize_t (*Get_cnt)(pTHX_ PerlIO *f);
.Ve
.Sp
Return tha number of bytes left ta be read up in tha current buffer.
.IP "Set_ptrcnt" 4
.IX Item "Set_ptrcnt"
.Vb 2
\&        void    (*Set_ptrcnt)(pTHX_ PerlIO *f,
\&                              STDCHAR *ptr, SSize_t cnt);
.Ve
.Sp
Adjust tha read pointa n' count of bytes ta match \f(CW\*(C`ptr\*(C'\fR and/or \f(CW\*(C`cnt\*(C'\fR.
Da application (or layer above) must ensure they is consistent.
(Checkin be allowed by tha paranoid.)
.SS "Utilities"
.IX Subsection "Utilities"
To ask fo' tha next layer down use PerlIONext(PerlIO *f).
.PP
To check dat a PerlIO* is valid use PerlIOValid(PerlIO *f).  (All
this do is straight-up just ta check dat tha pointa is non-NULL and
that tha pointa behind dat is non-NULL.)
.PP
PerlIOBase(PerlIO *f) returns tha \*(L"Base\*(R" pointer, or up in other lyrics,
the \f(CW\*(C`PerlIOl*\*(C'\fR pointer.
.PP
PerlIOSelf(PerlIO* f, type) return tha PerlIOBase cast ta a type.
.PP
Perl_PerlIO_or_Base(PerlIO* f, callback, base, failure, args) either
calls tha \fIcallback\fR from tha functionz of tha layer \fIf\fR (just by
the name of tha \s-1IO\s0 function, like \*(L"Read\*(R") wit tha \fIargs\fR, or if
there is no such callback, calls tha \fIbase\fR version of tha callback
with tha same args, or if tha f is invalid, set errno ta \s-1EBADF\s0 and
return \fIfailure\fR.
.PP
Perl_PerlIO_or_fail(PerlIO* f, callback, failure, args) either calls
the \fIcallback\fR of tha functionz of tha layer \fIf\fR wit tha \fIargs\fR,
or if there is no such callback, set errno ta \s-1EINVAL. \s0 Or if tha f is
invalid, set errno ta \s-1EBADF\s0 n' return \fIfailure\fR.
.PP
Perl_PerlIO_or_Base_void(PerlIO* f, callback, base, args) either calls
the \fIcallback\fR of tha functionz of tha layer \fIf\fR wit tha \fIargs\fR,
or if there is no such callback, calls tha \fIbase\fR version of the
callback wit tha same args, or if tha f is invalid, set errno to
\&\s-1EBADF.\s0
.PP
Perl_PerlIO_or_fail_void(PerlIO* f, callback, args) either calls the
\&\fIcallback\fR of tha functionz of tha layer \fIf\fR wit tha \fIargs\fR, or if
there is no such callback, set errno ta \s-1EINVAL. \s0 Or if tha f is
invalid, set errno ta \s-1EBADF.\s0
.SS "Implementin PerlIO Layers"
.IX Subsection "Implementin PerlIO Layers"
If you find tha implementation document unclear or not sufficient,
peep tha existin PerlIO layer implementations, which include:
.IP "\(bu" 4
C implementations
.Sp
Da \fIperlio.c\fR n' \fIperliol.h\fR up in tha Perl core implement the
\&\*(L"unix\*(R", \*(L"perlio\*(R", \*(L"stdio\*(R", \*(L"crlf\*(R", \*(L"utf8\*(R", \*(L"byte\*(R", \*(L"raw\*(R", \*(L"pending\*(R"
layers, n' also tha \*(L"mmap\*(R" n' \*(L"win32\*(R" layers if applicable.
(Da \*(L"win32\*(R" is currently unfinished n' unused, ta peep what tha fuck is used
instead up in Win32, peep \*(L"Queryin tha layerz of filehandles\*(R" up in PerlIO .)
.Sp
PerlIO::encoding, PerlIO::scalar, PerlIO::via up in tha Perl core.
.Sp
PerlIO::gzip n' APR::PerlIO (mod_perl 2.0) on \s-1CPAN.\s0
.IP "\(bu" 4
Perl implementations
.Sp
PerlIO::via::QuotedPrint up in tha Perl core n' PerlIO::via::* on \s-1CPAN.\s0
.PP
If yo ass is bustin a PerlIO layer, you may wanna be lazy, up in other
words, implement only tha methodz dat interest yo thugged-out ass.  Da other methods
you can either replace wit tha \*(L"blank\*(R" methods
.PP
.Vb 2
\&    PerlIOBase_noop_ok
\&    PerlIOBase_noop_fail
.Ve
.PP
(which do nothing, n' return zero n' \-1, respectively) or for
certain methodz you may assume a thugged-out default behaviour by rockin a \s-1NULL\s0
method. Y'all KNOW dat shit, muthafucka!  Da Open method looks fo' help up in tha 'parent' layer.
Da followin table summarizes tha behaviour:
.PP
.Vb 1
\&    method      behaviour wit NULL
\&
\&    Clearerr    PerlIOBase_clearerr
\&    Close       PerlIOBase_close
\&    Dup         PerlIOBase_dup
\&    Eof         PerlIOBase_eof
\&    Error       PerlIOBase_error
\&    Fileno      PerlIOBase_fileno
\&    Fill        FAILURE
\&    Flush       SUCCESS
\&    Getarg      SUCCESS
\&    Get_base    FAILURE
\&    Get_bufsiz  FAILURE
\&    Get_cnt     FAILURE
\&    Get_ptr     FAILURE
\&    Open        INHERITED
\&    Popped      SUCCESS
\&    Pushed      SUCCESS
\&    Read        PerlIOBase_read
\&    Seek        FAILURE
\&    Set_cnt     FAILURE
\&    Set_ptrcnt  FAILURE
\&    Setlinebuf  PerlIOBase_setlinebuf
\&    Tell        FAILURE
\&    Unread      PerlIOBase_unread
\&    Write       FAILURE
\&
\& FAILURE        Set errno (to EINVAL up in Unixish, ta LIB$_INVARG up in VMS) and
\&                return \-1 (for numeric return joints) or NULL (for pointers)
\& INHERITED      Inherited from tha layer below
\& SUCCESS        Return 0 (for numeric return joints) or a pointer
.Ve
.SS "Core Layers"
.IX Subsection "Core Layers"
Da file \f(CW\*(C`perlio.c\*(C'\fR serves up tha followin layers:
.ie n .IP """unix""" 4
.el .IP "``unix''" 4
.IX Item "unix"
A basic non-buffered layer which calls Unix/POSIX \f(CW\*(C`read()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR,
\&\f(CW\*(C`lseek()\*(C'\fR, \f(CW\*(C`close()\*(C'\fR. No buffering. Even on platforms dat distinguish
between O_TEXT n' O_BINARY dis layer be always O_BINARY.
.ie n .IP """perlio""" 4
.el .IP "``perlio''" 4
.IX Item "perlio"
A straight-up complete generic bufferin layer which serves up tha whole of
PerlIO \s-1API.\s0 It be also intended ta be used as a \*(L"base class\*(R" fo' other
layers. (For example its \f(CW\*(C`Read()\*(C'\fR method is implemented up in terms of
the \f(CW\*(C`Get_cnt()\*(C'\fR/\f(CW\*(C`Get_ptr()\*(C'\fR/\f(CW\*(C`Set_ptrcnt()\*(C'\fR methods).
.Sp
\&\*(L"perlio\*(R" over \*(L"unix\*(R" serves up a cold-ass lil complete replacement fo' stdio as seen
via PerlIO \s-1API.\s0 This is tha default fo' \s-1USE_PERLIO\s0 when systemz stdio
does not permit perlz \*(L"fast gets\*(R" access, n' which do not
distinguish between \f(CW\*(C`O_TEXT\*(C'\fR n' \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """stdio""" 4
.el .IP "``stdio''" 4
.IX Item "stdio"
A layer which serves up tha PerlIO \s-1API\s0 via tha layer scheme yo, but
implements it by callin systemz stdio. This is (currently) tha default
if systemz stdio serves up sufficient access ta allow perlz \*(L"fast gets\*(R"
access n' which do not distinguish between \f(CW\*(C`O_TEXT\*(C'\fR n' \f(CW\*(C`O_BINARY\*(C'\fR.
.ie n .IP """crlf""" 4
.el .IP "``crlf''" 4
.IX Item "crlf"
A layer derived rockin \*(L"perlio\*(R" as a funky-ass base class. Well shiiiit, it serves up Win32\-like
\&\*(L"\en\*(R" ta \s-1CR,LF\s0 translation. I aint talkin' bout chicken n' gravy biatch. Can either be applied above \*(L"perlio\*(R" or serve
as tha buffer layer itself. \*(L"crlf\*(R" over \*(L"unix\*(R" is tha default if system
distinguishes between \f(CW\*(C`O_TEXT\*(C'\fR n' \f(CW\*(C`O_BINARY\*(C'\fR opens. (At some point
\&\*(L"unix\*(R" is ghon be replaced by a \*(L"native\*(R" Win32 \s-1IO\s0 layer on dat platform,
as Win32z read/write layer has various drawbacks.) Da \*(L"crlf\*(R" layer is
a reasonable model fo' a layer which transforms data up in some way.
.ie n .IP """mmap""" 4
.el .IP "``mmap''" 4
.IX Item "mmap"
If Configure detects \f(CW\*(C`mmap()\*(C'\fR functions dis layer is provided (with
\&\*(L"perlio\*(R" as a \*(L"base\*(R") which do \*(L"read\*(R" operations by \fImmap()\fRin the
file. Performizzle improvement is marginal on modern systems, so it is
mainly there as a proof of concept. Well shiiiit, it is likely ta be unbundled from
the core at some point. Da \*(L"mmap\*(R" layer be a reasonable model fo' a
minimalist \*(L"derived\*(R" layer.
.ie n .IP """pending""" 4
.el .IP "``pending''" 4
.IX Item "pending"
An \*(L"internal\*(R" derivatizzle of \*(L"perlio\*(R" which can be used ta provide
\&\fIUnread()\fR function fo' layers which have no buffer or cannot be
bothered. Y'all KNOW dat shit, muthafucka!  (Basically dis layerz \f(CW\*(C`Fill()\*(C'\fR pops itself off tha stack
and so resumes readin from layer below.)
.ie n .IP """raw""" 4
.el .IP "``raw''" 4
.IX Item "raw"
A dummy layer which never exists on tha layer stack. Instead when
\&\*(L"pushed\*(R" it straight-up pops tha stack removin itself, it then calls
Binmode function table entry on all tha layers up in tha stack \- normally
this (via PerlIOBase_binmode) removes any layers which do not have
\&\f(CW\*(C`PERLIO_K_RAW\*(C'\fR bit set. Layers can modify dat behaviour by defining
their own Binmode entry.
.ie n .IP """utf8""" 4
.el .IP "``utf8''" 4
.IX Item "utf8"
Another dummy layer n' shit. When pushed it pops itself n' sets the
\&\f(CW\*(C`PERLIO_F_UTF8\*(C'\fR flag on tha layer which was (and now is once more)
the top of tha stack.
.PP
In addizzle \fIperlio.c\fR also serves up a fuckin shitload of \f(CW\*(C`PerlIOBase_xxxx()\*(C'\fR
functions which is intended ta be used up in tha table slotz of classes
which do not need ta do anythang special fo' a particular method.
.SS "Extension Layers"
.IX Subsection "Extension Layers"
Layers can be made available by extension modules. When a unknown layer
is encountered tha PerlIO code will big-ass up tha equivalent of :
.PP
.Vb 1
\&   use PerlIO \*(Aqlayer\*(Aq;
.Ve
.PP
Where \fIlayer\fR is tha unknown layer n' shit. \fIPerlIO.pm\fR will then attempt to:
.PP
.Vb 1
\&   require PerlIO::layer;
.Ve
.PP
If afta dat process tha layer is still not defined then tha \f(CW\*(C`open\*(C'\fR
will fail.
.PP
Da followin extension layers is bundled wit perl:
.ie n .IP """:encoding""" 4
.el .IP "``:encoding''" 4
.IX Item ":encoding"
.Vb 1
\&   use Encoding;
.Ve
.Sp
makes dis layer available, although \fIPerlIO.pm\fR \*(L"knows\*(R" where to
find dat shit.  It be a example of a layer which takes a argument as it is
called thus:
.Sp
.Vb 1
\&   open( $fh, "<:encoding(iso\-8859\-7)", $pathname );
.Ve
.ie n .IP """:scalar""" 4
.el .IP "``:scalar''" 4
.IX Item ":scalar"
Provides support fo' readin data from n' freestylin data ta a scalar.
.Sp
.Vb 1
\&   open( $fh, "+<:scalar", \e$scalar );
.Ve
.Sp
When a handle is so opened, then readz git bytes from tha strang value
of \fI\f(CI$scalar\fI\fR, n' writes chizzle tha value. In both cases tha position
in \fI\f(CI$scalar\fI\fR starts as zero but can be altered via \f(CW\*(C`seek\*(C'\fR, and
determined via \f(CW\*(C`tell\*(C'\fR.
.Sp
Please note dat dis layer is implied when callin \fIopen()\fR thus:
.Sp
.Vb 1
\&   open( $fh, "+<", \e$scalar );
.Ve
.ie n .IP """:via""" 4
.el .IP "``:via''" 4
.IX Item ":via"
Provided ta allow layers ta be implemented as Perl code.  For instance:
.Sp
.Vb 2
\&   use PerlIO::via::StripHTML;
\&   open( mah $fh, "<:via(StripHTML)", "index.html" );
.Ve
.Sp
See PerlIO::via fo' details.
.SH "TODO"
.IX Header "TODO"
Things dat need ta be done ta improve dis document.
.IP "\(bu" 4
Explain how tha fuck ta cook up a valid fh without goin all up in \fIopen()\fR(i.e. apply
a layer). For example if tha file aint opened all up in perl yo, but we
wanna git back a gangbangin' fh, like dat shiznit was opened by Perl.
.Sp
How tha fuck PerlIO_apply_layera fits in, where its docs, was it made public?
.Sp
Currently tha example could be suttin' like this:
.Sp
.Vb 8
\&  PerlIO *foo_to_PerlIO(pTHX_ char *mode, ...)
\&  {
\&      char *mode; /* "w", "r", etc */
\&      const char *layers = ":APR"; /* tha layer name */
\&      PerlIO *f = PerlIO_allocate(aTHX);
\&      if (!f) {
\&          return NULL;
\&      }
\&
\&      PerlIO_apply_layers(aTHX_ f, mode, layers);
\&
\&      if (f) {
\&          PerlIOAPR *st = PerlIOSelf(f, PerlIOAPR);
\&          /* fill up in tha st struct, as up in _open() */
\&          st\->file = file;
\&          PerlIOBase(f)\->flags |= PERLIO_F_OPEN;
\&
\&          return f;
\&      }
\&      return NULL;
\&  }
.Ve
.IP "\(bu" 4
fix/add tha documentation up in places marked as \s-1XXX.\s0
.IP "\(bu" 4
Da handlin of errors by tha layer aint specified. Y'all KNOW dat shit, muthafucka! e.g. when $!
should be set explicitly, when tha error handlin should be just
delegated ta tha top layer.
.Sp
Probably give some hints on rockin \s-1\fISETERRNO\s0()\fR or pointas ta where they
can be found.
.IP "\(bu" 4
I be thinkin it would help ta give some concrete examplez ta make it easier
to KNOW tha \s-1API.\s0 Of course I smoke dat tha \s-1API\s0 has ta be
concise yo, but since there is no second document dat is mo' of a
guide, I be thinkin dat it'd make it easier ta start wit tha doc which is
an \s-1API,\s0 but has examplez up in it up in places where thangs is unclear, to
a thug whoz ass aint a PerlIO guru (yet).
