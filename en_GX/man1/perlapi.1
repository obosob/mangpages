.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLAPI 1"
.TH PERLAPI 1 "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlapi \- autogenerated documentation fo' tha perl hood API
.SH "DESCRIPTION"
.IX Xref "Perl API API api"
.IX Header "DESCRIPTION"
This file gotz nuff tha documentation of tha perl hood \s-1API\s0 generated by
\&\fIembed.pl\fR, specifically a listin of functions, macros, flags, n' variables
that may be used by extension writers.  At tha end
is a list of functions which have yet ta be documented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da intercourses of
those is subject ta chizzle without notice.  Any functions not listed here are
not part of tha hood \s-1API,\s0 n' should not be used by extension writas at
all.  For these reasons, blindly rockin functions listed up in proto.h is ta be
avoided when freestylin extensions.
.PP
Note dat all Perl \s-1API\s0 global variablez must be referenced wit tha \f(CW\*(C`PL_\*(C'\fR
prefix.  Some macros is provided fo' compatibilitizzle wit tha older,
unadorned names yo, but dis support may be disabled up in a gangbangin' future release.
.PP
Perl was originally freestyled ta handle US-ASCII only (that is characters
whose ordinal numbers is up in tha range 0 \- 127).
And documentation n' comments may still use tha term \s-1ASCII,\s0 when
sometimes up in fact tha entire range from 0 \- 255 is meant.
.PP
Note dat Perl can be compiled n' run under \s-1EBCDIC \s0(See perlebcdic)
or \s-1ASCII. \s0 Most of tha documentation (and even comments up in tha code)
ignore tha \s-1EBCDIC\s0 possibility.  
For almost all purposes tha differences is transparent.
As a example, under \s-1EBCDIC,\s0
instead of \s-1UTF\-8,\s0 UTF-EBCDIC is used ta encode Unicode strings, n' so
whenever dis documentation refers ta \f(CW\*(C`utf8\*(C'\fR
(and variantz of dat name, includin up in function names),
it also (essentially transparently) means \f(CW\*(C`UTF\-EBCDIC\*(C'\fR.
But tha ordinalz of charactas differ between \s-1ASCII, EBCDIC,\s0 and
the \s-1UTF\-\s0 encodings, n' a strang encoded up in UTF-EBCDIC may occupy mo' bytes
than up in \s-1UTF\-8.\s0
.PP
Da listin below be alphabetical, case insensitive.
.ie n .SH """Gimme"" Values"
.el .SH "``Gimme'' Values"
.IX Header "Gimme Values"
.IP "\s-1GIMME \s0" 8
.IX Xref "GIMME"
.IX Item "GIMME "
A backward-compatible version of \f(CW\*(C`GIMME_V\*(C'\fR which can only return
\&\f(CW\*(C`G_SCALAR\*(C'\fR or \f(CW\*(C`G_ARRAY\*(C'\fR; up in a void context, it returns \f(CW\*(C`G_SCALAR\*(C'\fR.
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \f(CW\*(C`GIMME_V\*(C'\fR instead.
.Sp
.Vb 1
\&        U32     GIMME
.Ve
.IP "\s-1GIMME_V \s0" 8
.IX Xref "GIMME_V"
.IX Item "GIMME_V "
Da XSUB-writerz equivalent ta Perlz \f(CW\*(C`wantarray\*(C'\fR.  Returns \f(CW\*(C`G_VOID\*(C'\fR,
\&\f(CW\*(C`G_SCALAR\*(C'\fR or \f(CW\*(C`G_ARRAY\*(C'\fR fo' void, scalar or list context,
respectively. Right back up in yo muthafuckin ass. See perlcall fo' a usage example.
.Sp
.Vb 1
\&        U32     GIMME_V
.Ve
.IP "G_ARRAY" 8
.IX Xref "G_ARRAY"
.IX Item "G_ARRAY"
Used ta indicate list context.  See \f(CW\*(C`GIMME_V\*(C'\fR, \f(CW\*(C`GIMME\*(C'\fR and
perlcall.
.IP "G_DISCARD" 8
.IX Xref "G_DISCARD"
.IX Item "G_DISCARD"
Indicates dat arguments returned from a cold-ass lil callback should be discarded. Y'all KNOW dat shit, muthafucka!  See
perlcall.
.IP "G_EVAL" 8
.IX Xref "G_EVAL"
.IX Item "G_EVAL"
Used ta force a Perl \f(CW\*(C`eval\*(C'\fR wrapper round a cold-ass lil callback.  See
perlcall.
.IP "G_NOARGS" 8
.IX Xref "G_NOARGS"
.IX Item "G_NOARGS"
Indicates dat no arguments is bein busted ta a cold-ass lil callback.  See
perlcall.
.IP "G_SCALAR" 8
.IX Xref "G_SCALAR"
.IX Item "G_SCALAR"
Used ta indicate scalar context.  See \f(CW\*(C`GIMME_V\*(C'\fR, \f(CW\*(C`GIMME\*(C'\fR, and
perlcall.
.IP "G_VOID" 8
.IX Xref "G_VOID"
.IX Item "G_VOID"
Used ta indicate void context.  See \f(CW\*(C`GIMME_V\*(C'\fR n' perlcall.
.SH "Array Manipulation Functions"
.IX Header "Array Manipulation Functions"
.IP "AvFILL" 8
.IX Xref "AvFILL"
.IX Item "AvFILL"
Same as \f(CW\*(C`av_top_index()\*(C'\fR.  Deprecated, use \f(CW\*(C`av_top_index()\*(C'\fR instead.
.Sp
.Vb 1
\&        int     AvFILL(AV* av)
.Ve
.IP "av_clear" 8
.IX Xref "av_clear"
.IX Item "av_clear"
Clears a array, makin it empty.  Do not free tha memory tha av uses to
store its list of scalars.  If any destructors is triggered as a result,
the av itself may be freed when dis function returns.
.Sp
Perl equivalent: \f(CW\*(C`@myarray = ();\*(C'\fR.
.Sp
.Vb 1
\&        void    av_clear(AV *av)
.Ve
.IP "av_create_and_push" 8
.IX Xref "av_create_and_push"
.IX Item "av_create_and_push"
Push a \s-1SV\s0 onto tha end of tha array, bustin tha array if necessary.
A lil' small-ass internal helper function ta remove a cold-ass lil commonly duplicated idiom.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        void    av_create_and_push(AV **const avp,
\&                                   SV *const val)
.Ve
.IP "av_create_and_unshift_one" 8
.IX Xref "av_create_and_unshift_one"
.IX Item "av_create_and_unshift_one"
Unshifts a \s-1SV\s0 onto tha beginnin of tha array, bustin tha array if
necessary.
A lil' small-ass internal helper function ta remove a cold-ass lil commonly duplicated idiom.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        SV**    av_create_and_unshift_one(AV **const avp,
\&                                          SV *const val)
.Ve
.IP "av_delete" 8
.IX Xref "av_delete"
.IX Item "av_delete"
Deletes tha element indexed by \f(CW\*(C`key\*(C'\fR from tha array, make tha element mortal,
and returns dat shit.  If \f(CW\*(C`flags\*(C'\fR equals \f(CW\*(C`G_DISCARD\*(C'\fR, tha element is freed n' null
is returned. Y'all KNOW dat shit, muthafucka!  Perl equivalent: \f(CW\*(C`my $elem = delete($myarray[$idx]);\*(C'\fR fo' the
non\-\f(CW\*(C`G_DISCARD\*(C'\fR version n' a void-context \f(CW\*(C`delete($myarray[$idx]);\*(C'\fR fo' the
\&\f(CW\*(C`G_DISCARD\*(C'\fR version.
.Sp
.Vb 1
\&        SV*     av_delete(AV *av, I32 key, I32 flags)
.Ve
.IP "av_exists" 8
.IX Xref "av_exists"
.IX Item "av_exists"
Returns legit if tha element indexed by \f(CW\*(C`key\*(C'\fR has been initialized.
.Sp
This relies on tha fact dat uninitialized array elements is set to
\&\f(CW&PL_sv_undef\fR.
.Sp
Perl equivalent: \f(CW\*(C`exists($myarray[$key])\*(C'\fR.
.Sp
.Vb 1
\&        bool    av_exists(AV *av, I32 key)
.Ve
.IP "av_extend" 8
.IX Xref "av_extend"
.IX Item "av_extend"
Pre-extend a array.  Da \f(CW\*(C`key\*(C'\fR is tha index ta which tha array should be
extended.
.Sp
.Vb 1
\&        void    av_extend(AV *av, I32 key)
.Ve
.IP "av_fetch" 8
.IX Xref "av_fetch"
.IX Item "av_fetch"
Returns tha \s-1SV\s0 all up in tha specified index up in tha array.  Da \f(CW\*(C`key\*(C'\fR is the
index.  If lval is true, yo ass is guaranteed ta git a real \s-1SV\s0 back (in case
it wasn't real before), which you can then modify.  Peep dat tha return
value is non-null before dereferencin it ta a \f(CW\*(C`SV*\*(C'\fR.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts for
more shiznit on how tha fuck ta use dis function on tied arrays.
.Sp
Da rough perl equivalent is \f(CW$myarray[$idx]\fR.
.Sp
.Vb 1
\&        SV**    av_fetch(AV *av, I32 key, I32 lval)
.Ve
.IP "av_fill" 8
.IX Xref "av_fill"
.IX Item "av_fill"
Set tha highest index up in tha array ta tha given number, equivalent to
Perlz \f(CW\*(C`$#array = $fill;\*(C'\fR.
.Sp
Da number of elements up in tha a array is ghon be \f(CW\*(C`fill + 1\*(C'\fR after
\&\fIav_fill()\fR returns.  If tha array was previously shorter, then the
additionizzle elements appended is set ta \f(CW\*(C`PL_sv_undef\*(C'\fR.  If tha array
was longer, then tha excess elements is freed. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`av_fill(av, \-1)\*(C'\fR is
the same as \f(CW\*(C`av_clear(av)\*(C'\fR.
.Sp
.Vb 1
\&        void    av_fill(AV *av, I32 fill)
.Ve
.IP "av_len" 8
.IX Xref "av_len"
.IX Item "av_len"
Same as \*(L"av_top_index\*(R".  Returns tha highest index up in tha array.  Note dat the
return value is +1 what tha fuck its name implies it returns; n' hence differs in
meanin from what tha fuck tha similarly named \*(L"sv_len\*(R" returns.
.Sp
.Vb 1
\&        I32     av_len(AV *av)
.Ve
.IP "av_make" 8
.IX Xref "av_make"
.IX Item "av_make"
Creates a freshly smoked up \s-1AV\s0 n' populates it wit a list of SVs.  Da SVs is copied
into tha array, so they may be freed afta tha call ta av_make.  Da freshly smoked up \s-1AV\s0
will gotz a reference count of 1.
.Sp
Perl equivalent: \f(CW\*(C`my @new_array = ($scalar1, $scalar2, $scalar3...);\*(C'\fR
.Sp
.Vb 1
\&        AV*     av_make(I32 size, SV **strp)
.Ve
.IP "av_pop" 8
.IX Xref "av_pop"
.IX Item "av_pop"
Removes one \s-1SV\s0 from tha end of tha array, reducin its size by one and
returnin tha \s-1SV \s0(transferrin control of one reference count) ta the
calla n' shit.  Returns \f(CW&PL_sv_undef\fR if tha array is empty.
.Sp
Perl equivalent: \f(CW\*(C`pop(@myarray);\*(C'\fR
.Sp
.Vb 1
\&        SV*     av_pop(AV *av)
.Ve
.IP "av_push" 8
.IX Xref "av_push"
.IX Item "av_push"
Pushes a \s-1SV\s0 onto tha end of tha array.  Da array will grow automatically
to accommodate tha addition. I aint talkin' bout chicken n' gravy biatch.  This takes ballershizzle of one reference count.
.Sp
Perl equivalent: \f(CW\*(C`push @myarray, $elem;\*(C'\fR.
.Sp
.Vb 1
\&        void    av_push(AV *av, SV *val)
.Ve
.IP "av_shift" 8
.IX Xref "av_shift"
.IX Item "av_shift"
Shifts a \s-1SV\s0 off tha beginnin of the
array.  Returns \f(CW&PL_sv_undef\fR if tha 
array is empty.
.Sp
Perl equivalent: \f(CW\*(C`shift(@myarray);\*(C'\fR
.Sp
.Vb 1
\&        SV*     av_shift(AV *av)
.Ve
.IP "av_store" 8
.IX Xref "av_store"
.IX Item "av_store"
Stores a \s-1SV\s0 up in a array.  Da array index is specified as \f(CW\*(C`key\*(C'\fR.  The
return value is ghon be \s-1NULL\s0 if tha operation failed or if tha value did not
need ta be straight-up stored within tha array (as up in tha case of tied
arrays). Otherwise, it can be dereferenced
to git tha \f(CW\*(C`SV*\*(C'\fR dat was stored
there (= \f(CW\*(C`val\*(C'\fR)).
.Sp
Note dat tha calla is responsible fo' suitably incrementin tha reference
count of \f(CW\*(C`val\*(C'\fR before tha call, n' decrementin it if tha function
returned \s-1NULL.\s0
.Sp
Approximate Perl equivalent: \f(CW\*(C`$myarray[$key] = $val;\*(C'\fR.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts for
more shiznit on how tha fuck ta use dis function on tied arrays.
.Sp
.Vb 1
\&        SV**    av_store(AV *av, I32 key, SV *val)
.Ve
.IP "av_tindex" 8
.IX Xref "av_tindex"
.IX Item "av_tindex"
Same as \f(CW\*(C`av_top_index()\*(C'\fR.
.Sp
.Vb 1
\&        int     av_tindex(AV* av)
.Ve
.IP "av_top_index" 8
.IX Xref "av_top_index"
.IX Item "av_top_index"
Returns tha highest index up in tha array.  Da number of elements up in the
array is \f(CW\*(C`av_top_index(av) + 1\*(C'\fR.  Returns \-1 if tha array is empty.
.Sp
Da Perl equivalent fo' dis is \f(CW$#myarray\fR.
.Sp
(A slightly shorta form is \f(CW\*(C`av_tindex\*(C'\fR.)
.Sp
.Vb 1
\&        I32     av_top_index(AV *av)
.Ve
.IP "av_undef" 8
.IX Xref "av_undef"
.IX Item "av_undef"
Undefines tha array.  Frees tha memory used by tha av ta store its list of
scalars.  If any destructors is triggered as a result, tha av itself may
be freed.
.Sp
.Vb 1
\&        void    av_undef(AV *av)
.Ve
.IP "av_unshift" 8
.IX Xref "av_unshift"
.IX Item "av_unshift"
Unshift tha given number of \f(CW\*(C`undef\*(C'\fR joints onto tha beginnin of the
array.  Da array will grow automatically ta accommodate tha addition. I aint talkin' bout chicken n' gravy biatch.  You
must then use \f(CW\*(C`av_store\*(C'\fR ta assign joints ta these freshly smoked up elements.
.Sp
Perl equivalent: \f(CW\*(C`unshift @myarray, ( (undef) x $n );\*(C'\fR
.Sp
.Vb 1
\&        void    av_unshift(AV *av, I32 num)
.Ve
.IP "get_av" 8
.IX Xref "get_av"
.IX Item "get_av"
Returns tha \s-1AV\s0 of tha specified Perl global or package array wit tha given
name (so it won't work on lexical variables).  \f(CW\*(C`flags\*(C'\fR is passed 
to \f(CW\*(C`gv_fetchpv\*(C'\fR. If \f(CW\*(C`GV_ADD\*(C'\fR is set n' the
Perl variable do not exist then it is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \f(CW\*(C`flags\*(C'\fR is zero
and tha variable do not exist then \s-1NULL\s0 is returned.
.Sp
Perl equivalent: \f(CW\*(C`@{"$name"}\*(C'\fR.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        AV*     get_av(const char *name, I32 flags)
.Ve
.IP "newAV" 8
.IX Xref "newAV"
.IX Item "newAV"
Creates a freshly smoked up \s-1AV. \s0 Da reference count is set ta 1.
.Sp
Perl equivalent: \f(CW\*(C`my @array;\*(C'\fR.
.Sp
.Vb 1
\&        AV*     newAV()
.Ve
.IP "sortsv" 8
.IX Xref "sortsv"
.IX Item "sortsv"
Sort a array yo. Here be a example:
.Sp
.Vb 1
\&    sortsv(AvARRAY(av), av_top_index(av)+1, Perl_sv_cmp_locale);
.Ve
.Sp
Currently dis always uses mergesort. Right back up in yo muthafuckin ass. See sortsv_flags fo' a more
flexible routine.
.Sp
.Vb 2
\&        void    sortsv(SV** array, size_t num_elts,
\&                       SVCOMPARE_t cmp)
.Ve
.IP "sortsv_flags" 8
.IX Xref "sortsv_flags"
.IX Item "sortsv_flags"
Sort a array, wit various options.
.Sp
.Vb 2
\&        void    sortsv_flags(SV** array, size_t num_elts,
\&                             SVCOMPARE_t cmp, U32 flags)
.Ve
.SH "Callback Functions"
.IX Header "Callback Functions"
.IP "call_argv" 8
.IX Xref "call_argv"
.IX Item "call_argv"
Performs a cold-ass lil callback ta tha specified named n' package-scoped Perl subroutine 
with \f(CW\*(C`argv\*(C'\fR (a NULL-terminated array of strings) as arguments, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See perlcall.
.Sp
Approximate Perl equivalent: \f(CW\*(C`&{"$sub_name"}(@$argv)\*(C'\fR.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 2
\&        I32     call_argv(const char* sub_name, I32 flags,
\&                          char** argv)
.Ve
.IP "call_method" 8
.IX Xref "call_method"
.IX Item "call_method"
Performs a cold-ass lil callback ta tha specified Perl method. Y'all KNOW dat shit, muthafucka!  Da pimped object must
be on tha stack.  See perlcall.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        I32     call_method(const char* methname, I32 flags)
.Ve
.IP "call_pv" 8
.IX Xref "call_pv"
.IX Item "call_pv"
Performs a cold-ass lil callback ta tha specified Perl sub.  See perlcall.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        I32     call_pv(const char* sub_name, I32 flags)
.Ve
.IP "call_sv" 8
.IX Xref "call_sv"
.IX Item "call_sv"
Performs a cold-ass lil callback ta tha Perl sub whose name is up in tha \s-1SV. \s0 See
perlcall.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        I32     call_sv(SV* sv, VOL I32 flags)
.Ve
.IP "\s-1ENTER \s0" 8
.IX Xref "ENTER"
.IX Item "ENTER "
Openin bracket on a cold-ass lil callback.  See \f(CW\*(C`LEAVE\*(C'\fR n' perlcall.
.Sp
.Vb 1
\&                ENTER;
.Ve
.IP "eval_pv" 8
.IX Xref "eval_pv"
.IX Item "eval_pv"
Tells Perl ta \f(CW\*(C`eval\*(C'\fR tha given strang n' return a SV* result.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        SV*     eval_pv(const char* p, I32 croak_on_error)
.Ve
.IP "eval_sv" 8
.IX Xref "eval_sv"
.IX Item "eval_sv"
Tells Perl ta \f(CW\*(C`eval\*(C'\fR tha strang up in tha \s-1SV.\s0 It supports tha same ol' dirty flags
as \f(CW\*(C`call_sv\*(C'\fR, wit tha obvious exception of G_EVAL. Right back up in yo muthafuckin ass. See perlcall.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        I32     eval_sv(SV* sv, I32 flags)
.Ve
.IP "\s-1FREETMPS \s0" 8
.IX Xref "FREETMPS"
.IX Item "FREETMPS "
Closin bracket fo' temporaries on a cold-ass lil callback.  See \f(CW\*(C`SAVETMPS\*(C'\fR and
perlcall.
.Sp
.Vb 1
\&                FREETMPS;
.Ve
.IP "\s-1LEAVE \s0" 8
.IX Xref "LEAVE"
.IX Item "LEAVE "
Closin bracket on a cold-ass lil callback.  See \f(CW\*(C`ENTER\*(C'\fR n' perlcall.
.Sp
.Vb 1
\&                LEAVE;
.Ve
.IP "\s-1SAVETMPS \s0" 8
.IX Xref "SAVETMPS"
.IX Item "SAVETMPS "
Openin bracket fo' temporaries on a cold-ass lil callback.  See \f(CW\*(C`FREETMPS\*(C'\fR and
perlcall.
.Sp
.Vb 1
\&                SAVETMPS;
.Ve
.SH "Characta case changing"
.IX Header "Characta case changing"
.IP "toLOWER" 8
.IX Xref "toLOWER"
.IX Item "toLOWER"
Converts tha specified characta ta lowercase, if possible; otherwise returns
the input characta itself.
.Sp
.Vb 1
\&        char    toLOWER(char ch)
.Ve
.IP "toUPPER" 8
.IX Xref "toUPPER"
.IX Item "toUPPER"
Converts tha specified characta ta uppercase, if possible; otherwise returns
the input characta itself.
.Sp
.Vb 1
\&        char    toUPPER(char ch)
.Ve
.SH "Characta classes"
.IX Header "Characta classes"
This section be bout functions (really macros) dat classify characters
into types, like fuckin punctuation versus alphabetic, etc.  Most of these are
analogous ta regular expression characta classes.  (See
\&\*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass.)  There is nuff muthafuckin variants for
each class.  (Not all macros have all variants; each item below lists the
ones valid fo' dat shit.)  None is affected by \f(CW\*(C`use bytes\*(C'\fR, n' only tha ones
with \f(CW\*(C`LC\*(C'\fR up in tha name is affected by tha current locale.
.PP
Da base function, e.g., \f(CW\*(C`isALPHA()\*(C'\fR, takes a octet (either a \f(CW\*(C`char\*(C'\fR or a
\&\f(CW\*(C`U8\*(C'\fR) as input n' returns a funky-ass boolean as ta whether or not tha character
represented by dat octet is (or on non-ASCII platforms, correspondz to) an
\&\s-1ASCII\s0 characta up in tha named class based on platform, Unicode, n' Perl rules.
If tha input be a number dat don't fit up in a octet, \s-1FALSE\s0 is returned.
.PP
Variant \f(CW\*(C`isFOO_A\*(C'\fR (e.g., \f(CW\*(C`isALPHA_A()\*(C'\fR) is identical ta tha base function
with no suffix \f(CW"_A"\fR.
.PP
Variant \f(CW\*(C`isFOO_L1\*(C'\fR imposes tha Latin\-1 (or \s-1EBCDIC\s0 equivlalent) characta set
onto tha platform.  That is, tha code points dat is \s-1ASCII\s0 is unaffected,
since \s-1ASCII\s0 be a subset of Latin\-1.  But tha non-ASCII code points is treated
as if they is Latin\-1 characters.  For example, \f(CW\*(C`isWORDCHAR_L1()\*(C'\fR will return
true when called wit tha code point 0xDF, which be a word characta up in both
\&\s-1ASCII\s0 n' \s-1EBCDIC \s0(though it represent different charactas up in each).
.PP
Variant \f(CW\*(C`isFOO_uni\*(C'\fR is like tha \f(CW\*(C`isFOO_L1\*(C'\fR variant yo, but accepts any \s-1UV\s0 code
point as input.  If tha code point is larger than 255, Unicode rulez is used
to determine if it is up in tha characta class.  For example,
\&\f(CW\*(C`isWORDCHAR_uni(0x100)\*(C'\fR returns \s-1TRUE,\s0 since 0x100 is \s-1LATIN CAPITAL LETTER A
WITH MACRON\s0 up in Unicode, n' be a word character.
.PP
Variant \f(CW\*(C`isFOO_utf8\*(C'\fR is like \f(CW\*(C`isFOO_uni\*(C'\fR yo, but tha input be a pointa ta a
(known ta be well-formed) \s-1UTF\-8\s0 encoded strang (\f(CW\*(C`U8*\*(C'\fR or \f(CW\*(C`char*\*(C'\fR).  The
classification of just tha straight-up original gangsta (possibly multi-byte) characta up in tha string
is tested.
.PP
Variant \f(CW\*(C`isFOO_LC\*(C'\fR is like tha \f(CW\*(C`isFOO_A\*(C'\fR n' \f(CW\*(C`isFOO_L1\*(C'\fR variants yo, but uses
the C library function dat gives tha named classification instead of
hard-coded rules.  For example, \f(CW\*(C`isDIGIT_LC()\*(C'\fR returns tha result of calling
\&\f(CW\*(C`isdigit()\*(C'\fR.  This means dat tha result is based on tha current locale, which
is what tha fuck \f(CW\*(C`LC\*(C'\fR up in tha name standz for. Shiiit, dis aint no joke.  \s-1FALSE\s0 be always returned if tha input
won't fit tha fuck into a octet.
.PP
Variant \f(CW\*(C`isFOO_LC_uvchr\*(C'\fR is like \f(CW\*(C`isFOO_LC\*(C'\fR yo, but is defined on any \s-1UV. \s0 It
returns tha same ol' dirty as \f(CW\*(C`isFOO_LC\*(C'\fR fo' input code points less than 256, and
returns tha hard-coded, not-affected-by-locale, Unicode thangs up in dis biatch fo' larger ones.
.PP
Variant \f(CW\*(C`isFOO_LC_utf8\*(C'\fR is like \f(CW\*(C`isFOO_LC_uvchr\*(C'\fR yo, but tha input be a pointa ta a
(known ta be well-formed) \s-1UTF\-8\s0 encoded strang (\f(CW\*(C`U8*\*(C'\fR or \f(CW\*(C`char*\*(C'\fR).  The
classification of just tha straight-up original gangsta (possibly multi-byte) characta up in tha string
is tested.
.IP "isALPHA" 8
.IX Xref "isALPHA"
.IX Item "isALPHA"
Returns a funky-ass boolean indicatin whether tha specified characta be an
alphabetic character, analogous ta \f(CW\*(C`m/[[:alpha:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isALPHA_A\*(C'\fR, \f(CW\*(C`isALPHA_L1\*(C'\fR, \f(CW\*(C`isALPHA_uni\*(C'\fR, \f(CW\*(C`isALPHA_utf8\*(C'\fR, \f(CW\*(C`isALPHA_LC\*(C'\fR,
\&\f(CW\*(C`isALPHA_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isALPHA_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isALPHA(char ch)
.Ve
.IP "isALPHANUMERIC" 8
.IX Xref "isALPHANUMERIC"
.IX Item "isALPHANUMERIC"
Returns a funky-ass boolean indicatin whether tha specified characta be a either an
alphabetic characta or decimal digit, analogous ta \f(CW\*(C`m/[[:alnum:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isALPHANUMERIC_A\*(C'\fR, \f(CW\*(C`isALPHANUMERIC_L1\*(C'\fR, \f(CW\*(C`isALPHANUMERIC_uni\*(C'\fR,
\&\f(CW\*(C`isALPHANUMERIC_utf8\*(C'\fR, \f(CW\*(C`isALPHANUMERIC_LC\*(C'\fR, \f(CW\*(C`isALPHANUMERIC_LC_uvchr\*(C'\fR, and
\&\f(CW\*(C`isALPHANUMERIC_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isALPHANUMERIC(char ch)
.Ve
.IP "isASCII" 8
.IX Xref "isASCII"
.IX Item "isASCII"
Returns a funky-ass boolean indicatin whether tha specified characta is one of tha 128
charactas up in tha \s-1ASCII\s0 characta set, analogous ta \f(CW\*(C`m/[[:ascii:]]/\*(C'\fR.
On non-ASCII platforms, it returns \s-1TRUE\s0 iff this
characta correspondz ta a \s-1ASCII\s0 character n' shit.  Variants \f(CW\*(C`isASCII_A()\*(C'\fR and
\&\f(CW\*(C`isASCII_L1()\*(C'\fR is identical ta \f(CW\*(C`isASCII()\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isASCII_uni\*(C'\fR, \f(CW\*(C`isASCII_utf8\*(C'\fR, \f(CW\*(C`isASCII_LC\*(C'\fR, \f(CW\*(C`isASCII_LC_uvchr\*(C'\fR, and
\&\f(CW\*(C`isASCII_LC_utf8\*(C'\fR.  Note, however, dat some platforms aint gots tha C
library routine \f(CW\*(C`isascii()\*(C'\fR.  In these cases, tha variants whose names contain
\&\f(CW\*(C`LC\*(C'\fR is tha same as tha correspondin ones without.
.Sp
.Vb 1
\&        bool    isASCII(char ch)
.Ve
.IP "isBLANK" 8
.IX Xref "isBLANK"
.IX Item "isBLANK"
Returns a funky-ass boolean indicatin whether tha specified characta be a
characta considered ta be a funky-ass blank, analogous ta \f(CW\*(C`m/[[:blank:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isBLANK_A\*(C'\fR, \f(CW\*(C`isBLANK_L1\*(C'\fR, \f(CW\*(C`isBLANK_uni\*(C'\fR, \f(CW\*(C`isBLANK_utf8\*(C'\fR, \f(CW\*(C`isBLANK_LC\*(C'\fR,
\&\f(CW\*(C`isBLANK_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isBLANK_LC_utf8\*(C'\fR.  Note, however, dat some
platforms aint gots tha C library routine \f(CW\*(C`isblank()\*(C'\fR.  In these cases, the
variants whose names contain \f(CW\*(C`LC\*(C'\fR is tha same as tha correspondin ones
without.
.Sp
.Vb 1
\&        bool    isBLANK(char ch)
.Ve
.IP "isCNTRL" 8
.IX Xref "isCNTRL"
.IX Item "isCNTRL"
Returns a funky-ass boolean indicatin whether tha specified characta be a
control character, analogous ta \f(CW\*(C`m/[[:cntrl:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isCNTRL_A\*(C'\fR, \f(CW\*(C`isCNTRL_L1\*(C'\fR, \f(CW\*(C`isCNTRL_uni\*(C'\fR, \f(CW\*(C`isCNTRL_utf8\*(C'\fR, \f(CW\*(C`isCNTRL_LC\*(C'\fR,
\&\f(CW\*(C`isCNTRL_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isCNTRL_LC_utf8\*(C'\fR
On \s-1EBCDIC\s0 platforms, you almost always wanna use tha \f(CW\*(C`isCNTRL_L1\*(C'\fR variant.
.Sp
.Vb 1
\&        bool    isCNTRL(char ch)
.Ve
.IP "isDIGIT" 8
.IX Xref "isDIGIT"
.IX Item "isDIGIT"
Returns a funky-ass boolean indicatin whether tha specified characta be a
digit, analogous ta \f(CW\*(C`m/[[:digit:]]/\*(C'\fR.
Variants \f(CW\*(C`isDIGIT_A\*(C'\fR n' \f(CW\*(C`isDIGIT_L1\*(C'\fR is identical ta \f(CW\*(C`isDIGIT\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isDIGIT_uni\*(C'\fR, \f(CW\*(C`isDIGIT_utf8\*(C'\fR, \f(CW\*(C`isDIGIT_LC\*(C'\fR, \f(CW\*(C`isDIGIT_LC_uvchr\*(C'\fR, and
\&\f(CW\*(C`isDIGIT_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isDIGIT(char ch)
.Ve
.IP "isGRAPH" 8
.IX Xref "isGRAPH"
.IX Item "isGRAPH"
Returns a funky-ass boolean indicatin whether tha specified characta be a
graphic character, analogous ta \f(CW\*(C`m/[[:graph:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isGRAPH_A\*(C'\fR, \f(CW\*(C`isGRAPH_L1\*(C'\fR, \f(CW\*(C`isGRAPH_uni\*(C'\fR, \f(CW\*(C`isGRAPH_utf8\*(C'\fR, \f(CW\*(C`isGRAPH_LC\*(C'\fR,
\&\f(CW\*(C`isGRAPH_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isGRAPH_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isGRAPH(char ch)
.Ve
.IP "isIDCONT" 8
.IX Xref "isIDCONT"
.IX Item "isIDCONT"
Returns a funky-ass boolean indicatin whether tha specified characta can be the
second or succeedin characta of a identifier n' shit.  This is straight-up close ta yo, but
not like tha same as tha straight-up legit Unicode property \f(CW\*(C`XID_Continue\*(C'\fR.  The
difference is dat dis returns legit only if tha input characta also matches
\&\*(L"isWORDCHAR\*(R".  See tha top of dis section fo' an
explanation of variants \f(CW\*(C`isIDCONT_A\*(C'\fR, \f(CW\*(C`isIDCONT_L1\*(C'\fR, \f(CW\*(C`isIDCONT_uni\*(C'\fR,
\&\f(CW\*(C`isIDCONT_utf8\*(C'\fR, \f(CW\*(C`isIDCONT_LC\*(C'\fR, \f(CW\*(C`isIDCONT_LC_uvchr\*(C'\fR, and
\&\f(CW\*(C`isIDCONT_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isIDCONT(char ch)
.Ve
.IP "isIDFIRST" 8
.IX Xref "isIDFIRST"
.IX Item "isIDFIRST"
Returns a funky-ass boolean indicatin whether tha specified characta can be tha first
characta of a identifier n' shit.  This is straight-up close ta yo, but not like tha same as
the straight-up legit Unicode property \f(CW\*(C`XID_Start\*(C'\fR.  Da difference is dat this
returns legit only if tha input characta also matches \*(L"isWORDCHAR\*(R".
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isIDFIRST_A\*(C'\fR, \f(CW\*(C`isIDFIRST_L1\*(C'\fR, \f(CW\*(C`isIDFIRST_uni\*(C'\fR, \f(CW\*(C`isIDFIRST_utf8\*(C'\fR,
\&\f(CW\*(C`isIDFIRST_LC\*(C'\fR, \f(CW\*(C`isIDFIRST_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isIDFIRST_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isIDFIRST(char ch)
.Ve
.IP "isLOWER" 8
.IX Xref "isLOWER"
.IX Item "isLOWER"
Returns a funky-ass boolean indicatin whether tha specified characta be a
lowercase character, analogous ta \f(CW\*(C`m/[[:lower:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isLOWER_A\*(C'\fR, \f(CW\*(C`isLOWER_L1\*(C'\fR, \f(CW\*(C`isLOWER_uni\*(C'\fR, \f(CW\*(C`isLOWER_utf8\*(C'\fR, \f(CW\*(C`isLOWER_LC\*(C'\fR,
\&\f(CW\*(C`isLOWER_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isLOWER_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isLOWER(char ch)
.Ve
.IP "isOCTAL" 8
.IX Xref "isOCTAL"
.IX Item "isOCTAL"
Returns a funky-ass boolean indicatin whether tha specified characta be an
octal digit, [0\-7].
Da only two variants is \f(CW\*(C`isOCTAL_A\*(C'\fR n' \f(CW\*(C`isOCTAL_L1\*(C'\fR; each is identical to
\&\f(CW\*(C`isOCTAL\*(C'\fR.
.Sp
.Vb 1
\&        bool    isOCTAL(char ch)
.Ve
.IP "isPRINT" 8
.IX Xref "isPRINT"
.IX Item "isPRINT"
Returns a funky-ass boolean indicatin whether tha specified characta be a
printable character, analogous ta \f(CW\*(C`m/[[:print:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isPRINT_A\*(C'\fR, \f(CW\*(C`isPRINT_L1\*(C'\fR, \f(CW\*(C`isPRINT_uni\*(C'\fR, \f(CW\*(C`isPRINT_utf8\*(C'\fR, \f(CW\*(C`isPRINT_LC\*(C'\fR,
\&\f(CW\*(C`isPRINT_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isPRINT_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isPRINT(char ch)
.Ve
.IP "isPSXSPC" 8
.IX Xref "isPSXSPC"
.IX Item "isPSXSPC"
(short fo' Posix Space)
Startin up in 5.18, dis is identical (experimentally) up in all its forms ta the
correspondin \f(CW\*(C`isSPACE()\*(C'\fR macros.  (\*(L"Experimentally\*(R" means dat dis chizzle
may be backed up in 5.20 or 5.22 if field experience indicates dat it
was unwise.)
Da locale formz of dis macro is identical ta they corresponding
\&\f(CW\*(C`isSPACE()\*(C'\fR forms up in all Perl releases.  In releases prior ta 5.18, the
non-locale forms differ from they \f(CW\*(C`isSPACE()\*(C'\fR forms only up in dat the
\&\f(CW\*(C`isSPACE()\*(C'\fR forms don't match a Vertical Tab, n' tha \f(CW\*(C`isPSXSPC()\*(C'\fR forms do.
Otherwise they is identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Thus dis macro be analogous ta what
\&\f(CW\*(C`m/[[:space:]]/\*(C'\fR matches up in a regular expression.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isPSXSPC_A\*(C'\fR, \f(CW\*(C`isPSXSPC_L1\*(C'\fR, \f(CW\*(C`isPSXSPC_uni\*(C'\fR, \f(CW\*(C`isPSXSPC_utf8\*(C'\fR, \f(CW\*(C`isPSXSPC_LC\*(C'\fR,
\&\f(CW\*(C`isPSXSPC_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isPSXSPC_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isPSXSPC(char ch)
.Ve
.IP "isPUNCT" 8
.IX Xref "isPUNCT"
.IX Item "isPUNCT"
Returns a funky-ass boolean indicatin whether tha specified characta be a
punctuation character, analogous ta \f(CW\*(C`m/[[:punct:]]/\*(C'\fR.
Note dat tha definizzle of what tha fuck is punctuation aint as
straightforward as one might desire.  See \*(L"\s-1POSIX\s0 Character
Classes\*(R" up in perlrecharclass fo' details.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isPUNCT_A\*(C'\fR, \f(CW\*(C`isPUNCT_L1\*(C'\fR, \f(CW\*(C`isPUNCT_uni\*(C'\fR, \f(CW\*(C`isPUNCT_utf8\*(C'\fR, \f(CW\*(C`isPUNCT_LC\*(C'\fR,
\&\f(CW\*(C`isPUNCT_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isPUNCT_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isPUNCT(char ch)
.Ve
.IP "isSPACE" 8
.IX Xref "isSPACE"
.IX Item "isSPACE"
Returns a funky-ass boolean indicatin whether tha specified characta be a
whitespace character n' shit.  This be analogous
to what tha fuck \f(CW\*(C`m/\es/\*(C'\fR matches up in a regular expression. I aint talkin' bout chicken n' gravy biatch.  Startin up in Perl 5.18
(experimentally), dis also matches what tha fuck \f(CW\*(C`m/[[:space:]]/\*(C'\fR do.
(\*(L"Experimentally\*(R" means dat dis chizzle may be backed up in 5.20 or 5.22 if
field experience indicates dat dat shiznit was unwise.)  Prior ta 5.18, only the
locale formz of dis macro (the ones wit \f(CW\*(C`LC\*(C'\fR up in they names) matched
precisely what tha fuck \f(CW\*(C`m/[[:space:]]/\*(C'\fR do.  In dem releases, tha only difference,
in tha non-locale variants, was dat \f(CW\*(C`isSPACE()\*(C'\fR did not match a vertical tab.
(See \*(L"isPSXSPC\*(R" fo' a macro dat matches a vertical tab up in all releases.)
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isSPACE_A\*(C'\fR, \f(CW\*(C`isSPACE_L1\*(C'\fR, \f(CW\*(C`isSPACE_uni\*(C'\fR, \f(CW\*(C`isSPACE_utf8\*(C'\fR, \f(CW\*(C`isSPACE_LC\*(C'\fR,
\&\f(CW\*(C`isSPACE_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isSPACE_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isSPACE(char ch)
.Ve
.IP "isUPPER" 8
.IX Xref "isUPPER"
.IX Item "isUPPER"
Returns a funky-ass boolean indicatin whether tha specified characta be an
uppercase character, analogous ta \f(CW\*(C`m/[[:upper:]]/\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isUPPER_A\*(C'\fR, \f(CW\*(C`isUPPER_L1\*(C'\fR, \f(CW\*(C`isUPPER_uni\*(C'\fR, \f(CW\*(C`isUPPER_utf8\*(C'\fR, \f(CW\*(C`isUPPER_LC\*(C'\fR,
\&\f(CW\*(C`isUPPER_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isUPPER_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isUPPER(char ch)
.Ve
.IP "isWORDCHAR" 8
.IX Xref "isWORDCHAR"
.IX Item "isWORDCHAR"
Returns a funky-ass boolean indicatin whether tha specified characta be a cold-ass lil character
that be a word character, analogous ta what tha fuck \f(CW\*(C`m/\ew/\*(C'\fR n' \f(CW\*(C`m/[[:word:]]/\*(C'\fR match
in a regular expression. I aint talkin' bout chicken n' gravy biatch.  A word characta be a alphabetic character, a
decimal digit, a cold-ass lil connectin punctuation characta (like fuckin a underscore), or
a \*(L"mark\*(R" characta dat attaches ta one of dem (like some sort of accent).
\&\f(CW\*(C`isALNUM()\*(C'\fR be a synonym provided fo' backward compatibility, even though a
word characta includes mo' than tha standard C language meanin of
alphanumeric.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isWORDCHAR_A\*(C'\fR, \f(CW\*(C`isWORDCHAR_L1\*(C'\fR, \f(CW\*(C`isWORDCHAR_uni\*(C'\fR, \f(CW\*(C`isWORDCHAR_utf8\*(C'\fR,
\&\f(CW\*(C`isWORDCHAR_LC\*(C'\fR, \f(CW\*(C`isWORDCHAR_LC_uvchr\*(C'\fR, n' \f(CW\*(C`isWORDCHAR_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isWORDCHAR(char ch)
.Ve
.IP "isXDIGIT" 8
.IX Xref "isXDIGIT"
.IX Item "isXDIGIT"
Returns a funky-ass boolean indicatin whether tha specified characta be a hexadecimal
digit.  In tha \s-1ASCII\s0 range these is \f(CW\*(C`[0\-9A\-Fa\-f]\*(C'\fR.  Variants \f(CW\*(C`isXDIGIT_A()\*(C'\fR
and \f(CW\*(C`isXDIGIT_L1()\*(C'\fR is identical ta \f(CW\*(C`isXDIGIT()\*(C'\fR.
See tha top of dis section fo' a explanation of variants
\&\f(CW\*(C`isXDIGIT_uni\*(C'\fR, \f(CW\*(C`isXDIGIT_utf8\*(C'\fR, \f(CW\*(C`isXDIGIT_LC\*(C'\fR, \f(CW\*(C`isXDIGIT_LC_uvchr\*(C'\fR, and
\&\f(CW\*(C`isXDIGIT_LC_utf8\*(C'\fR.
.Sp
.Vb 1
\&        bool    isXDIGIT(char ch)
.Ve
.SH "Clonin a interpreter"
.IX Header "Clonin a interpreter"
.IP "perl_clone" 8
.IX Xref "perl_clone"
.IX Item "perl_clone"
Smoke n' return a freshly smoked up interpreta by clonin tha current one.
.Sp
perl_clone takes these flags as parameters:
.Sp
CLONEf_COPY_STACKS \- is used to, well, copy tha stacks also,
without it we only clone tha data n' zero tha stacks,
with it we copy tha stacks n' tha freshly smoked up perl interpreta is
ready ta run all up in tha exact same point as tha previous one.
Da pseudo-fork code uses \s-1COPY_STACKS\s0 while the
threads\->create don't.
.Sp
CLONEf_KEEP_PTR_TABLE \-
perl_clone keeps a ptr_table wit tha pointa of tha old
variable as a key n' tha freshly smoked up variable as a value,
this allows it ta check if suttin' has been cloned n' not
clone it again n' again n' again but rather just use tha value n' increase the
refcount.  If \s-1KEEP_PTR_TABLE\s0 aint set then perl_clone will kill
the ptr_table rockin tha function
\&\f(CW\*(C`ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;\*(C'\fR,
reason ta keep it round is if you wanna dup a shitload of yo' own
variable whoz ass is outside tha graph perl scans, example of this
code is up in threads.xs create.
.Sp
CLONEf_CLONE_HOST \-
This be a win32 thang, it is ignored on unix, it  drops some lyrics ta perls
win32host code (which is c++) ta clone itself, dis is needed on
win32 if you wanna run two threadz all up in tha same time,
if you just wanna do some shiznit up in a separate perl interpreter
and then throw it away n' return ta tha original gangsta one,
you don't need ta do anything.
.Sp
.Vb 4
\&        PerlInterpreter* perl_clone(
\&                             PerlInterpreta *proto_perl,
\&                             UV flags
\&                         )
.Ve
.SH "Compile-time scope hooks"
.IX Header "Compile-time scope hooks"
.IP "BhkDISABLE" 8
.IX Xref "BhkDISABLE"
.IX Item "BhkDISABLE"
Temporarily disable a entry up in dis \s-1BHK\s0 structure, by clearin the
appropriate flag. \fIwhich\fR be a preprocessor token indicatin which
entry ta disable.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    BhkDISABLE(BHK *hk, which)
.Ve
.IP "BhkENABLE" 8
.IX Xref "BhkENABLE"
.IX Item "BhkENABLE"
Re-enable a entry up in dis \s-1BHK\s0 structure, by settin tha appropriate
flag. \fIwhich\fR be a preprocessor token indicatin which entry ta enable.
This will assert (under \-DDEBUGGING) if tha entry don't contain a valid
pointer.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    BhkENABLE(BHK *hk, which)
.Ve
.IP "BhkENTRY_set" 8
.IX Xref "BhkENTRY_set"
.IX Item "BhkENTRY_set"
Set a entry up in tha \s-1BHK\s0 structure, n' set tha flags ta indicate it is
valid. Y'all KNOW dat shit, muthafucka! \fIwhich\fR be a preprocessin token indicatin which entry ta set.
Da type of \fIptr\fR dependz on tha entry.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    BhkENTRY_set(BHK *hk, which, void *ptr)
.Ve
.IP "blockhook_register" 8
.IX Xref "blockhook_register"
.IX Item "blockhook_register"
Regista a set of hooks ta be called when tha Perl lexical scope chizzles
at compile time. Right back up in yo muthafuckin ass. See \*(L"Compile-time scope hooks\*(R" up in perlguts.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
\&\s-1NOTE:\s0 dis function must be explicitly called as Perl_blockhook_regista wit a aTHX_ parameter.
.Sp
.Vb 1
\&        void    Perl_blockhook_register(pTHX_ BHK *hk)
.Ve
.SH "COP Hint Hashes"
.IX Header "COP Hint Hashes"
.IP "cophh_2hv" 8
.IX Xref "cophh_2hv"
.IX Item "cophh_2hv"
Generates n' returns a standard Perl hash representin tha full set of
key/value pairs up in tha cop hints hash \fIcophh\fR.  \fIflags\fR is currently
unused n' must be zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        HV *    cophh_2hv(const COPHH *cophh, U32 flags)
.Ve
.IP "cophh_copy" 8
.IX Xref "cophh_copy"
.IX Item "cophh_copy"
Make n' return a cold-ass lil complete copy of tha cop hints hash \fIcophh\fR.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        COPHH * cophh_copy(COPHH *cophh)
.Ve
.IP "cophh_delete_pv" 8
.IX Xref "cophh_delete_pv"
.IX Item "cophh_delete_pv"
Like \*(L"cophh_delete_pvn\*(R" yo, but takes a nul-terminated strang instead of
a string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        COPHH * cophh_delete_pv(const COPHH *cophh,
\&                                const char *key, U32 hash,
\&                                U32 flags)
.Ve
.IP "cophh_delete_pvn" 8
.IX Xref "cophh_delete_pvn"
.IX Item "cophh_delete_pvn"
Delete a key n' its associated value from tha cop hints hash \fIcophh\fR,
and returns tha modified hash.  Da returned hash pointa is up in general
not tha same as tha hash pointa dat was passed in. I aint talkin' bout chicken n' gravy biatch.  Da input hash is
consumed by tha function, n' tha pointa ta it must not be subsequently
used. Y'all KNOW dat shit, muthafucka!  Use \*(L"cophh_copy\*(R" if you need both hashes.
.Sp
Da key is specified by \fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has the
\&\f(CW\*(C`COPHH_KEY_UTF8\*(C'\fR bit set, tha key octets is interpreted as \s-1UTF\-8,\s0
otherwise they is interpreted as Latin\-1.  \fIhash\fR be a precomputed
hash of tha key string, or zero if it has not been precomputed.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 4
\&        COPHH * cophh_delete_pvn(COPHH *cophh,
\&                                 const char *keypv,
\&                                 STRLEN keylen, U32 hash,
\&                                 U32 flags)
.Ve
.IP "cophh_delete_pvs" 8
.IX Xref "cophh_delete_pvs"
.IX Item "cophh_delete_pvs"
Like \*(L"cophh_delete_pvn\*(R" yo, but takes a literal strang instead of a
string/length pair, n' no precomputed hash.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        COPHH * cophh_delete_pvs(const COPHH *cophh,
\&                                 const char *key, U32 flags)
.Ve
.IP "cophh_delete_sv" 8
.IX Xref "cophh_delete_sv"
.IX Item "cophh_delete_sv"
Like \*(L"cophh_delete_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        COPHH * cophh_delete_sv(const COPHH *cophh, SV *key,
\&                                U32 hash, U32 flags)
.Ve
.IP "cophh_fetch_pv" 8
.IX Xref "cophh_fetch_pv"
.IX Item "cophh_fetch_pv"
Like \*(L"cophh_fetch_pvn\*(R" yo, but takes a nul-terminated strang instead of
a string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        SV *    cophh_fetch_pv(const COPHH *cophh,
\&                               const char *key, U32 hash,
\&                               U32 flags)
.Ve
.IP "cophh_fetch_pvn" 8
.IX Xref "cophh_fetch_pvn"
.IX Item "cophh_fetch_pvn"
Look up tha entry up in tha cop hints hash \fIcophh\fR wit tha key specified by
\&\fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has tha \f(CW\*(C`COPHH_KEY_UTF8\*(C'\fR bit set,
the key octets is interpreted as \s-1UTF\-8,\s0 otherwise they is interpreted
as Latin\-1.  \fIhash\fR be a precomputed hash of tha key string, or zero if
it has not been precomputed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns a mortal scalar copy of tha value
associated wit tha key, or \f(CW&PL_sv_placeholder\fR if there is no value
associated wit tha key.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 4
\&        SV *    cophh_fetch_pvn(const COPHH *cophh,
\&                                const char *keypv,
\&                                STRLEN keylen, U32 hash,
\&                                U32 flags)
.Ve
.IP "cophh_fetch_pvs" 8
.IX Xref "cophh_fetch_pvs"
.IX Item "cophh_fetch_pvs"
Like \*(L"cophh_fetch_pvn\*(R" yo, but takes a literal strang instead of a
string/length pair, n' no precomputed hash.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        SV *    cophh_fetch_pvs(const COPHH *cophh,
\&                                const char *key, U32 flags)
.Ve
.IP "cophh_fetch_sv" 8
.IX Xref "cophh_fetch_sv"
.IX Item "cophh_fetch_sv"
Like \*(L"cophh_fetch_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        SV *    cophh_fetch_sv(const COPHH *cophh, SV *key,
\&                               U32 hash, U32 flags)
.Ve
.IP "cophh_free" 8
.IX Xref "cophh_free"
.IX Item "cophh_free"
Discard tha cop hints hash \fIcophh\fR, freein all resources associated
with dat shit.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    cophh_free(COPHH *cophh)
.Ve
.IP "cophh_new_empty" 8
.IX Xref "cophh_new_empty"
.IX Item "cophh_new_empty"
Generate n' return a gangbangin' fresh cop hints hash containin no entries.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        COPHH * cophh_new_empty()
.Ve
.IP "cophh_store_pv" 8
.IX Xref "cophh_store_pv"
.IX Item "cophh_store_pv"
Like \*(L"cophh_store_pvn\*(R" yo, but takes a nul-terminated strang instead of
a string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        COPHH * cophh_store_pv(const COPHH *cophh,
\&                               const char *key, U32 hash,
\&                               SV *value, U32 flags)
.Ve
.IP "cophh_store_pvn" 8
.IX Xref "cophh_store_pvn"
.IX Item "cophh_store_pvn"
Stores a value, associated wit a key, up in tha cop hints hash \fIcophh\fR,
and returns tha modified hash.  Da returned hash pointa is up in general
not tha same as tha hash pointa dat was passed in. I aint talkin' bout chicken n' gravy biatch.  Da input hash is
consumed by tha function, n' tha pointa ta it must not be subsequently
used. Y'all KNOW dat shit, muthafucka!  Use \*(L"cophh_copy\*(R" if you need both hashes.
.Sp
Da key is specified by \fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has the
\&\f(CW\*(C`COPHH_KEY_UTF8\*(C'\fR bit set, tha key octets is interpreted as \s-1UTF\-8,\s0
otherwise they is interpreted as Latin\-1.  \fIhash\fR be a precomputed
hash of tha key string, or zero if it has not been precomputed.
.Sp
\&\fIvalue\fR is tha scalar value ta store fo' dis key.  \fIvalue\fR is copied
by dis function, which thus do not take ballershizzle of any reference
to it, n' lata chizzlez ta tha scalar aint gonna be reflected up in the
value visible up in tha cop hints hash.  Complex typez of scalar will not
be stored wit referential integritizzle yo, but is ghon be coerced ta strings.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        COPHH * cophh_store_pvn(COPHH *cophh, const char *keypv,
\&                                STRLEN keylen, U32 hash,
\&                                SV *value, U32 flags)
.Ve
.IP "cophh_store_pvs" 8
.IX Xref "cophh_store_pvs"
.IX Item "cophh_store_pvs"
Like \*(L"cophh_store_pvn\*(R" yo, but takes a literal strang instead of a
string/length pair, n' no precomputed hash.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        COPHH * cophh_store_pvs(const COPHH *cophh,
\&                                const char *key, SV *value,
\&                                U32 flags)
.Ve
.IP "cophh_store_sv" 8
.IX Xref "cophh_store_sv"
.IX Item "cophh_store_sv"
Like \*(L"cophh_store_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        COPHH * cophh_store_sv(const COPHH *cophh, SV *key,
\&                               U32 hash, SV *value, U32 flags)
.Ve
.SH "COP Hint Reading"
.IX Header "COP Hint Reading"
.IP "cop_hints_2hv" 8
.IX Xref "cop_hints_2hv"
.IX Item "cop_hints_2hv"
Generates n' returns a standard Perl hash representin tha full set of
hint entries up in tha cop \fIcop\fR.  \fIflags\fR is currently unused n' must
be zero.
.Sp
.Vb 1
\&        HV *    cop_hints_2hv(const COP *cop, U32 flags)
.Ve
.IP "cop_hints_fetch_pv" 8
.IX Xref "cop_hints_fetch_pv"
.IX Item "cop_hints_fetch_pv"
Like \*(L"cop_hints_fetch_pvn\*(R" yo, but takes a nul-terminated strang instead
of a string/length pair.
.Sp
.Vb 3
\&        SV *    cop_hints_fetch_pv(const COP *cop,
\&                                   const char *key, U32 hash,
\&                                   U32 flags)
.Ve
.IP "cop_hints_fetch_pvn" 8
.IX Xref "cop_hints_fetch_pvn"
.IX Item "cop_hints_fetch_pvn"
Look up tha hint entry up in tha cop \fIcop\fR wit tha key specified by
\&\fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has tha \f(CW\*(C`COPHH_KEY_UTF8\*(C'\fR bit set,
the key octets is interpreted as \s-1UTF\-8,\s0 otherwise they is interpreted
as Latin\-1.  \fIhash\fR be a precomputed hash of tha key string, or zero if
it has not been precomputed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns a mortal scalar copy of tha value
associated wit tha key, or \f(CW&PL_sv_placeholder\fR if there is no value
associated wit tha key.
.Sp
.Vb 4
\&        SV *    cop_hints_fetch_pvn(const COP *cop,
\&                                    const char *keypv,
\&                                    STRLEN keylen, U32 hash,
\&                                    U32 flags)
.Ve
.IP "cop_hints_fetch_pvs" 8
.IX Xref "cop_hints_fetch_pvs"
.IX Item "cop_hints_fetch_pvs"
Like \*(L"cop_hints_fetch_pvn\*(R" yo, but takes a literal strang instead of a
string/length pair, n' no precomputed hash.
.Sp
.Vb 2
\&        SV *    cop_hints_fetch_pvs(const COP *cop,
\&                                    const char *key, U32 flags)
.Ve
.IP "cop_hints_fetch_sv" 8
.IX Xref "cop_hints_fetch_sv"
.IX Item "cop_hints_fetch_sv"
Like \*(L"cop_hints_fetch_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 2
\&        SV *    cop_hints_fetch_sv(const COP *cop, SV *key,
\&                                   U32 hash, U32 flags)
.Ve
.SH "Custom Operators"
.IX Header "Custom Operators"
.IP "custom_op_register" 8
.IX Xref "custom_op_register"
.IX Item "custom_op_register"
Regista a cold-ass lil custom op. Right back up in yo muthafuckin ass. See \*(L"Custom Operators\*(R" up in perlguts.
.Sp
\&\s-1NOTE:\s0 dis function must be explicitly called as Perl_custom_op_regista wit a aTHX_ parameter.
.Sp
.Vb 3
\&        void    Perl_custom_op_register(pTHX_ 
\&                                        Perl_ppaddr_t ppaddr,
\&                                        const XOP *xop)
.Ve
.IP "custom_op_xop" 8
.IX Xref "custom_op_xop"
.IX Item "custom_op_xop"
Return tha \s-1XOP\s0 structure fo' a given custom op. This function should be
considered internal ta \s-1OP_NAME\s0 n' tha other access macros: use dem instead.
.Sp
\&\s-1NOTE:\s0 dis function must be explicitly called as Perl_custom_op_xop wit a aTHX_ parameter.
.Sp
.Vb 1
\&        const XOP * Perl_custom_op_xop(pTHX_ const OP *o)
.Ve
.IP "XopDISABLE" 8
.IX Xref "XopDISABLE"
.IX Item "XopDISABLE"
Temporarily disable a gangmember of tha \s-1XOP,\s0 by clearin tha appropriate flag.
.Sp
.Vb 1
\&        void    XopDISABLE(XOP *xop, which)
.Ve
.IP "XopENABLE" 8
.IX Xref "XopENABLE"
.IX Item "XopENABLE"
Reenable a gangmember of tha \s-1XOP\s0 which has been disabled.
.Sp
.Vb 1
\&        void    XopENABLE(XOP *xop, which)
.Ve
.IP "XopENTRY" 8
.IX Xref "XopENTRY"
.IX Item "XopENTRY"
Return a gangmember of tha \s-1XOP\s0 structure. \fIwhich\fR be a cold-ass lil cpp token indicating
which entry ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If tha member aint set dis will return a
default value. Da return type dependz on \fIwhich\fR.
.Sp
.Vb 1
\&                XopENTRY(XOP *xop, which)
.Ve
.IP "XopENTRY_set" 8
.IX Xref "XopENTRY_set"
.IX Item "XopENTRY_set"
Set a gangmember of tha \s-1XOP\s0 structure. \fIwhich\fR be a cold-ass lil cpp token indicating
which entry ta set. Right back up in yo muthafuckin ass. See \*(L"Custom Operators\*(R" up in perlguts fo' details about
the available thugz n' how tha fuck they is used.
.Sp
.Vb 1
\&        void    XopENTRY_set(XOP *xop, which, value)
.Ve
.IP "XopFLAGS" 8
.IX Xref "XopFLAGS"
.IX Item "XopFLAGS"
Return tha \s-1XOP\s0z flags.
.Sp
.Vb 1
\&        U32     XopFLAGS(XOP *xop)
.Ve
.SH "CV Manipulation Functions"
.IX Header "CV Manipulation Functions"
.IP "CvSTASH" 8
.IX Xref "CvSTASH"
.IX Item "CvSTASH"
Returns tha stash of tha \s-1CV fo' realz. A\s0 stash is tha symbol table hash, containing
the package-scoped variablez up in tha package where tha subroutine was defined.
For mo' shiznit, peep perlguts.
.Sp
This also has a special use wit \s-1XS AUTOLOAD\s0 subs.
See \*(L"Autoloadin wit XSUBs\*(R" up in perlguts.
.Sp
.Vb 1
\&        HV*     CvSTASH(CV* cv)
.Ve
.IP "get_cv" 8
.IX Xref "get_cv"
.IX Item "get_cv"
Uses \f(CW\*(C`strlen\*(C'\fR ta git tha length of \f(CW\*(C`name\*(C'\fR, then calls \f(CW\*(C`get_cvn_flags\*(C'\fR.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        CV*     get_cv(const char* name, I32 flags)
.Ve
.IP "get_cvn_flags" 8
.IX Xref "get_cvn_flags"
.IX Item "get_cvn_flags"
Returns tha \s-1CV\s0 of tha specified Perl subroutine.  \f(CW\*(C`flags\*(C'\fR is passed to
\&\f(CW\*(C`gv_fetchpvn_flags\*(C'\fR. If \f(CW\*(C`GV_ADD\*(C'\fR is set n' tha Perl subroutine do not
exist then it is ghon be declared (which has tha same ol' dirty effect as saying
\&\f(CW\*(C`sub name;\*(C'\fR).  If \f(CW\*(C`GV_ADD\*(C'\fR aint set n' tha subroutine do not exist
then \s-1NULL\s0 is returned.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 2
\&        CV*     get_cvn_flags(const char* name, STRLEN len,
\&                              I32 flags)
.Ve
.SH "Embeddin Functions"
.IX Header "Embeddin Functions"
.IP "cv_clone" 8
.IX Xref "cv_clone"
.IX Item "cv_clone"
Clone a \s-1CV,\s0 bustin a lexical closure.  \fIproto\fR supplies tha prototype
of tha function: its code, pad structure, n' other attributes.
Da prototype is combined wit a cold-ass lil capture of outa lexicals ta which the
code refers, which is taken from tha currently-executin instizzle of
the immediately surroundin code.
.Sp
.Vb 1
\&        CV *    cv_clone(CV *proto)
.Ve
.IP "cv_undef" 8
.IX Xref "cv_undef"
.IX Item "cv_undef"
Clear up all tha actizzle componentz of a \s-1CV.\s0 This can happen either
by a explicit \f(CW\*(C`undef &foo\*(C'\fR, or by tha reference count goin ta zero.
In tha forma case, we keep tha CvOUTSIDE pointer, so dat any anonymous
lil pimps can still follow tha full lexical scope chain.
.Sp
.Vb 1
\&        void    cv_undef(CV* cv)
.Ve
.IP "find_rundefsv" 8
.IX Xref "find_rundefsv"
.IX Item "find_rundefsv"
Find n' return tha variable dat is named \f(CW$_\fR up in tha lexical scope
of tha currently-executin function. I aint talkin' bout chicken n' gravy biatch.  This may be a lexical \f(CW$_\fR,
or will otherwise be tha global one.
.Sp
.Vb 1
\&        SV *    find_rundefsv()
.Ve
.IP "find_rundefsvoffset" 8
.IX Xref "find_rundefsvoffset"
.IX Item "find_rundefsvoffset"
Find tha posizzle of tha lexical \f(CW$_\fR up in tha pad of the
currently-executin function. I aint talkin' bout chicken n' gravy biatch.  Returns tha offset up in tha current pad,
or \f(CW\*(C`NOT_IN_PAD\*(C'\fR if there is no lexical \f(CW$_\fR up in scope (in which case
the global one should be used instead).
\&\*(L"find_rundefsv\*(R" is likely ta be mo' convenient.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        PADOFFSET find_rundefsvoffset()
.Ve
.IP "load_module" 8
.IX Xref "load_module"
.IX Item "load_module"
Loadz tha module whose name is pointed ta by tha strang part of name.
Note dat tha actual module name, not its filename, should be given.
Eg, \*(L"Foo::Bar\*(R" instead of \*(L"Foo/Bar.pm\*(R".  flags can be any of
\&\s-1PERL_LOADMOD_DENY, PERL_LOADMOD_NOIMPORT,\s0 or \s-1PERL_LOADMOD_IMPORT_OPS
\&\s0(or 0 fo' no flags). ver, if specified n' not \s-1NULL,\s0 serves up version semantics
similar ta \f(CW\*(C`use Foo::Bar VERSION\*(C'\fR.  Da optionizzle trailin SV*
arguments can be used ta specify arguments ta tha modulez \fIimport()\fR
method, similar ta \f(CW\*(C`use Foo::Bar VERSION LIST\*(C'\fR.  They must be
terminated wit a gangbangin' final \s-1NULL\s0 pointer n' shit.  Note dat dis list can only
be omitted when tha \s-1PERL_LOADMOD_NOIMPORT\s0 flag has been used.
Otherwise at least a single \s-1NULL\s0 pointa ta designate tha default
import list is required.
.Sp
Da reference count fo' each specified \f(CW\*(C`SV*\*(C'\fR parameta is decremented.
.Sp
.Vb 1
\&        void    load_module(U32 flags, SV* name, SV* ver, ...)
.Ve
.IP "nothreadhook" 8
.IX Xref "nothreadhook"
.IX Item "nothreadhook"
Stub dat serves up thread hook fo' perl_destruct when there are
no threads.
.Sp
.Vb 1
\&        int     nothreadhook()
.Ve
.IP "pad_add_anon" 8
.IX Xref "pad_add_anon"
.IX Item "pad_add_anon"
Allocates a place up in tha currently-compilin pad (via \*(L"pad_alloc\*(R")
for a anonymous function dat is lexically scoped inside the
currently-compilin function.
Da function \fIfunc\fR is linked tha fuck into tha pad, n' its \f(CW\*(C`CvOUTSIDE\*(C'\fR link
to tha outa scope is weakened ta avoid a reference loop.
.Sp
One reference count is jacked, so you may need ta do \f(CW\*(C`SvREFCNT_inc(func)\*(C'\fR.
.Sp
\&\fIoptype\fR should be a opcode indicatin tha type of operation dat the
pad entry is ta support.  This don't affect operationizzle semantics,
but is used fo' debugging.
.Sp
.Vb 1
\&        PADOFFSET pad_add_anon(CV *func, I32 optype)
.Ve
.IP "pad_add_name_pv" 8
.IX Xref "pad_add_name_pv"
.IX Item "pad_add_name_pv"
Exactly like \*(L"pad_add_name_pvn\*(R" yo, but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 2
\&        PADOFFSET pad_add_name_pv(const char *name, U32 flags,
\&                                  HV *typestash, HV *ourstash)
.Ve
.IP "pad_add_name_pvn" 8
.IX Xref "pad_add_name_pvn"
.IX Item "pad_add_name_pvn"
Allocates a place up in tha currently-compilin pad fo' a named lexical
variable.  Stores tha name n' other metadata up in tha name part of the
pad, n' make preparations ta manage tha variablez lexical scoping.
Returns tha offset of tha allocated pad slot.
.Sp
\&\fInamepv\fR/\fInamelen\fR specify tha variablez name, includin leadin sigil.
If \fItypestash\fR is non-null, tha name is fo' a typed lexical, n' this
identifies tha type.  If \fIourstash\fR is non-null, itz a lexical reference
to a package variable, n' dis identifies tha package.  Da following
flags can be \s-1OR\s0'ed together:
.Sp
.Vb 3
\&    padadd_OUR          redundantly specifies if it\*(Aqs a package var
\&    padadd_STATE        variable will retain value persistently
\&    padadd_NO_DUP_CHECK skip check fo' lexical shadowing
\&
\&        PADOFFSET pad_add_name_pvn(const char *namepv,
\&                                   STRLEN namelen, U32 flags,
\&                                   HV *typestash, HV *ourstash)
.Ve
.IP "pad_add_name_sv" 8
.IX Xref "pad_add_name_sv"
.IX Item "pad_add_name_sv"
Exactly like \*(L"pad_add_name_pvn\*(R" yo, but takes tha name strang up in tha form
of a \s-1SV\s0 instead of a string/length pair.
.Sp
.Vb 2
\&        PADOFFSET pad_add_name_sv(SV *name, U32 flags,
\&                                  HV *typestash, HV *ourstash)
.Ve
.IP "pad_alloc" 8
.IX Xref "pad_alloc"
.IX Item "pad_alloc"
Allocates a place up in tha currently-compilin pad,
returnin tha offset of tha allocated pad slot.
No name is initially attached ta tha pad slot.
\&\fItmptype\fR be a set of flags indicatin tha kind of pad entry required,
which is ghon be set up in tha value \s-1SV\s0 fo' tha allocated pad entry:
.Sp
.Vb 2
\&    SVs_PADMY    named lexical variable ("my", "our", "state")
\&    SVs_PADTMP   unnamed temporary store
.Ve
.Sp
\&\fIoptype\fR should be a opcode indicatin tha type of operation dat the
pad entry is ta support.  This don't affect operationizzle semantics,
but is used fo' debugging.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADOFFSET pad_alloc(I32 optype, U32 tmptype)
.Ve
.IP "pad_compname_type" 8
.IX Xref "pad_compname_type"
.IX Item "pad_compname_type"
Looks up tha type of tha lexical variable at posizzle \fIpo\fR up in the
currently-compilin pad. Y'all KNOW dat shit, muthafucka!  If tha variable is typed, tha stash of the
class ta which it is typed is returned. Y'all KNOW dat shit, muthafucka!  If not, \f(CW\*(C`NULL\*(C'\fR is returned.
.Sp
.Vb 1
\&        HV *    pad_compname_type(PADOFFSET po)
.Ve
.IP "pad_findmy_pv" 8
.IX Xref "pad_findmy_pv"
.IX Item "pad_findmy_pv"
Exactly like \*(L"pad_findmy_pvn\*(R" yo, but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 1
\&        PADOFFSET pad_findmy_pv(const char *name, U32 flags)
.Ve
.IP "pad_findmy_pvn" 8
.IX Xref "pad_findmy_pvn"
.IX Item "pad_findmy_pvn"
Given tha name of a lexical variable, find its posizzle up in the
currently-compilin pad.
\&\fInamepv\fR/\fInamelen\fR specify tha variablez name, includin leadin sigil.
\&\fIflags\fR is reserved n' must be zero.
If it aint up in tha current pad but appears up in tha pad of any lexically
enclosin scope, then a pseudo-entry fo' it be added up in tha current pad.
Returns tha offset up in tha current pad,
or \f(CW\*(C`NOT_IN_PAD\*(C'\fR if no such lexical is up in scope.
.Sp
.Vb 2
\&        PADOFFSET pad_findmy_pvn(const char *namepv,
\&                                 STRLEN namelen, U32 flags)
.Ve
.IP "pad_findmy_sv" 8
.IX Xref "pad_findmy_sv"
.IX Item "pad_findmy_sv"
Exactly like \*(L"pad_findmy_pvn\*(R" yo, but takes tha name strang up in tha form
of a \s-1SV\s0 instead of a string/length pair.
.Sp
.Vb 1
\&        PADOFFSET pad_findmy_sv(SV *name, U32 flags)
.Ve
.IP "pad_setsv" 8
.IX Xref "pad_setsv"
.IX Item "pad_setsv"
Set tha value at offset \fIpo\fR up in tha current (compilin or executing) pad.
Use tha macro \s-1\fIPAD_SETSV\s0()\fR rather than callin dis function directly.
.Sp
.Vb 1
\&        void    pad_setsv(PADOFFSET po, SV *sv)
.Ve
.IP "pad_sv" 8
.IX Xref "pad_sv"
.IX Item "pad_sv"
Git tha value at offset \fIpo\fR up in tha current (compilin or executing) pad.
Use macro \s-1PAD_SV\s0 instead of callin dis function directly.
.Sp
.Vb 1
\&        SV *    pad_sv(PADOFFSET po)
.Ve
.IP "pad_tidy" 8
.IX Xref "pad_tidy"
.IX Item "pad_tidy"
Tidy up a pad all up in tha end of compilation of tha code ta which it belongs.
Jobs performed here are: remove most shiznit from tha padz of anonsub
prototypes; give it a \f(CW@_\fR; mark temporaries as such.  \fItype\fR indicates
the kind of subroutine:
.Sp
.Vb 3
\&    padtidy_SUB        ordinary subroutine
\&    padtidy_SUBCLONE   prototype fo' lexical closure
\&    padtidy_FORMAT     format
.Ve
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    pad_tidy(padtidy_type type)
.Ve
.IP "perl_alloc" 8
.IX Xref "perl_alloc"
.IX Item "perl_alloc"
Allocates a freshly smoked up Perl interpreter n' shit.  See perlembed.
.Sp
.Vb 1
\&        PerlInterpreter* perl_alloc()
.Ve
.IP "perl_construct" 8
.IX Xref "perl_construct"
.IX Item "perl_construct"
Initializes a freshly smoked up Perl interpreter n' shit.  See perlembed.
.Sp
.Vb 1
\&        void    perl_construct(PerlInterpreta *my_perl)
.Ve
.IP "perl_destruct" 8
.IX Xref "perl_destruct"
.IX Item "perl_destruct"
Shuts down a Perl interpreter n' shit.  See perlembed.
.Sp
.Vb 1
\&        int     perl_destruct(PerlInterpreta *my_perl)
.Ve
.IP "perl_free" 8
.IX Xref "perl_free"
.IX Item "perl_free"
Releases a Perl interpreter n' shit.  See perlembed.
.Sp
.Vb 1
\&        void    perl_free(PerlInterpreta *my_perl)
.Ve
.IP "perl_parse" 8
.IX Xref "perl_parse"
.IX Item "perl_parse"
Tells a Perl interpreta ta parse a Perl script.  See perlembed.
.Sp
.Vb 3
\&        int     perl_parse(PerlInterpreta *my_perl,
\&                           XSINIT_t xsinit, int argc,
\&                           char** argv, char** env)
.Ve
.IP "perl_run" 8
.IX Xref "perl_run"
.IX Item "perl_run"
Tells a Perl interpreta ta run. I aint talkin' bout chicken n' gravy biatch.  See perlembed.
.Sp
.Vb 1
\&        int     perl_run(PerlInterpreta *my_perl)
.Ve
.IP "require_pv" 8
.IX Xref "require_pv"
.IX Item "require_pv"
Tells Perl ta \f(CW\*(C`require\*(C'\fR tha file named by tha strang argument.  It is
analogous ta tha Perl code \f(CW\*(C`eval "require \*(Aq$file\*(Aq"\*(C'\fR.  It aint nuthin but even
implemented dat way; consider rockin load_module instead.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        void    require_pv(const char* pv)
.Ve
.SH "Functions up in file dump.c"
.IX Header "Functions up in file dump.c"
.IP "pv_display" 8
.IX Xref "pv_display"
.IX Item "pv_display"
Similar to
.Sp
.Vb 1
\&  pv_escape(dsv,pv,cur,pvlim,PERL_PV_ESCAPE_QUOTE);
.Ve
.Sp
except dat a additionizzle \*(L"\e0\*(R" is ghon be appended ta tha strang when
len > cur n' pv[cur] is \*(L"\e0\*(R".
.Sp
Note dat tha final strang may be up ta 7 chars longer than pvlim.
.Sp
.Vb 2
\&        char*   pv_display(SV *dsv, const char *pv, STRLEN cur,
\&                           STRLEN len, STRLEN pvlim)
.Ve
.IP "pv_escape" 8
.IX Xref "pv_escape"
.IX Item "pv_escape"
Escapes at most tha straight-up original gangsta \*(L"count\*(R" charz of pv n' puts tha thangs up in dis biatch into
dsv such dat tha size of tha escaped strang aint gonna exceed \*(L"max\*(R" chars
and aint gonna contain any incomplete escape sequences.
.Sp
If flags gotz nuff \s-1PERL_PV_ESCAPE_QUOTE\s0 then any double quotes up in tha string
will also be escaped.
.Sp
Normally tha \s-1SV\s0 is ghon be cleared before tha escaped strang is prepared,
but when \s-1PERL_PV_ESCAPE_NOCLEAR\s0 is set dis aint gonna occur.
.Sp
If \s-1PERL_PV_ESCAPE_UNI\s0 is set then tha input strang is treated as Unicode,
if \s-1PERL_PV_ESCAPE_UNI_DETECT\s0 is set then tha input strang is scanned
usin \f(CW\*(C`is_utf8_string()\*(C'\fR ta determine if it is Unicode.
.Sp
If \s-1PERL_PV_ESCAPE_ALL\s0 is set then all input chars is ghon be output
usin \f(CW\*(C`\ex01F1\*(C'\fR steez escapes, otherwise if \s-1PERL_PV_ESCAPE_NONASCII\s0 is set, only
chars above 127 is ghon be escaped rockin dis style; otherwise, only chars above
255 is ghon be all kindsa escaped; other non printable chars will use octal or
common escaped patterns like \f(CW\*(C`\en\*(C'\fR. Otherwise, if \s-1PERL_PV_ESCAPE_NOBACKSLASH\s0
then all chars below 255 is ghon be treated as printable and
will be output as literals.
.Sp
If \s-1PERL_PV_ESCAPE_FIRSTCHAR\s0 is set then only tha straight-up original gangsta char of the
strin is ghon be escaped, regardless of max. If tha output is ta be up in hex,
then it is ghon be returned as a plain hex
sequence. Thus tha output will either be a single char,
an octal escape sequence, a special escape like \f(CW\*(C`\en\*(C'\fR or a hex value.
.Sp
If \s-1PERL_PV_ESCAPE_RE\s0 is set then tha escape char used is ghon be a '%' and
not a '\e\e'. This is cuz regexes straight-up often contain backslashed
sequences, whereas '%' aint a particularly common characta up in patterns.
.Sp
Returns a pointa ta tha escaped text as held by dsv.
.Sp
.Vb 4
\&        char*   pv_escape(SV *dsv, char const * const str,
\&                          const STRLEN count, const STRLEN max,
\&                          STRLEN * const escaped,
\&                          const U32 flags)
.Ve
.IP "pv_pretty" 8
.IX Xref "pv_pretty"
.IX Item "pv_pretty"
Converts a strang tha fuck into suttin' presentable, handlin escapin via
\&\fIpv_escape()\fR n' supportin quotin n' ellipses.
.Sp
If tha \s-1PERL_PV_PRETTY_QUOTE\s0 flag is set then tha result is ghon be 
double quoted wit any double quotes up in tha strang escaped. Y'all KNOW dat shit, muthafucka! Otherwise
if tha \s-1PERL_PV_PRETTY_LTGT\s0 flag is set then tha result be wrapped in
angle brackets.
.Sp
If tha \s-1PERL_PV_PRETTY_ELLIPSES\s0 flag is set n' not all charactas in
strin was output then a ellipsis \f(CW\*(C`...\*(C'\fR is ghon be appended ta the
string. Note dat dis happens \s-1AFTER\s0 it has been quoted.
.Sp
If start_color is non-null then it is ghon be banged afta tha opening
quote (if there is one) but before tha escaped text. If end_color
is non-null then it is ghon be banged afta tha escaped text but before
any quotes or ellipses.
.Sp
Returns a pointa ta tha prettified text as held by dsv.
.Sp
.Vb 5
\&        char*   pv_pretty(SV *dsv, char const * const str,
\&                          const STRLEN count, const STRLEN max,
\&                          char const * const start_color,
\&                          char const * const end_color,
\&                          const U32 flags)
.Ve
.SH "Functions up in file mathoms.c"
.IX Header "Functions up in file mathoms.c"
.IP "custom_op_desc" 8
.IX Xref "custom_op_desc"
.IX Item "custom_op_desc"
Return tha description of a given custom op. This was once used by the
\&\s-1OP_DESC\s0 macro yo, but is no longer: it has only been kept for
compatibility, n' should not be used.
.Sp
.Vb 1
\&        const char * custom_op_desc(const OP *o)
.Ve
.IP "custom_op_name" 8
.IX Xref "custom_op_name"
.IX Item "custom_op_name"
Return tha name fo' a given custom op. This was once used by tha \s-1OP_NAME\s0
macro yo, but is no longer: it has only been kept fo' compatibility, and
should not be used.
.Sp
.Vb 1
\&        const char * custom_op_name(const OP *o)
.Ve
.IP "gv_fetchmethod" 8
.IX Xref "gv_fetchmethod"
.IX Item "gv_fetchmethod"
See \*(L"gv_fetchmethod_autoload\*(R".
.Sp
.Vb 1
\&        GV*     gv_fetchmethod(HV* stash, const char* name)
.Ve
.IP "pack_cat" 8
.IX Xref "pack_cat"
.IX Item "pack_cat"
Da engine implementin \fIpack()\fR Perl function. I aint talkin' bout chicken n' gravy biatch. Note: parametas next_in_list and
flags is not used. Y'all KNOW dat shit, muthafucka! This call should not be used; use packlist instead.
.Sp
.Vb 4
\&        void    pack_cat(SV *cat, const char *pat,
\&                         const char *patend, SV **beglist,
\&                         SV **endlist, SV ***next_in_list,
\&                         U32 flags)
.Ve
.IP "sv_2pvbyte_nolen" 8
.IX Xref "sv_2pvbyte_nolen"
.IX Item "sv_2pvbyte_nolen"
Return a pointa ta tha byte-encoded representation of tha \s-1SV.\s0
May cause tha \s-1SV\s0 ta be downgraded from \s-1UTF\-8\s0 as a side-effect.
.Sp
Usually accessed via tha \f(CW\*(C`SvPVbyte_nolen\*(C'\fR macro.
.Sp
.Vb 1
\&        char*   sv_2pvbyte_nolen(SV* sv)
.Ve
.IP "sv_2pvutf8_nolen" 8
.IX Xref "sv_2pvutf8_nolen"
.IX Item "sv_2pvutf8_nolen"
Return a pointa ta tha UTF\-8\-encoded representation of tha \s-1SV.\s0
May cause tha \s-1SV\s0 ta be upgraded ta \s-1UTF\-8\s0 as a side-effect.
.Sp
Usually accessed via tha \f(CW\*(C`SvPVutf8_nolen\*(C'\fR macro.
.Sp
.Vb 1
\&        char*   sv_2pvutf8_nolen(SV* sv)
.Ve
.IP "sv_2pv_nolen" 8
.IX Xref "sv_2pv_nolen"
.IX Item "sv_2pv_nolen"
Like \f(CW\*(C`sv_2pv()\*(C'\fR yo, but don't return tha length like a muthafucka. Yo ass should usually
use tha macro wrapper \f(CW\*(C`SvPV_nolen(sv)\*(C'\fR instead.
.Sp
.Vb 1
\&        char*   sv_2pv_nolen(SV* sv)
.Ve
.IP "sv_catpvn_mg" 8
.IX Xref "sv_catpvn_mg"
.IX Item "sv_catpvn_mg"
Like \f(CW\*(C`sv_catpvn\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 2
\&        void    sv_catpvn_mg(SV *sv, const char *ptr,
\&                             STRLEN len)
.Ve
.IP "sv_catsv_mg" 8
.IX Xref "sv_catsv_mg"
.IX Item "sv_catsv_mg"
Like \f(CW\*(C`sv_catsv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_catsv_mg(SV *dsv, SV *ssv)
.Ve
.IP "sv_force_normal" 8
.IX Xref "sv_force_normal"
.IX Item "sv_force_normal"
Undo various typez of fakery on a \s-1SV:\s0 if tha \s-1PV\s0 be a gangbangin' finger-lickin' dirty-ass shared string, make
a private copy; if we a ref, stop refing; if we a glob, downgrade to
an xpvmg. Right back up in yo muthafuckin ass. See also \f(CW\*(C`sv_force_normal_flags\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_force_normal(SV *sv)
.Ve
.IP "sv_iv" 8
.IX Xref "sv_iv"
.IX Item "sv_iv"
A private implementation of tha \f(CW\*(C`SvIVx\*(C'\fR macro fo' compilaz which can't
cope wit complex macro expressions fo' realz. Always use tha macro instead.
.Sp
.Vb 1
\&        IV      sv_iv(SV* sv)
.Ve
.IP "sv_nolocking" 8
.IX Xref "sv_nolocking"
.IX Item "sv_nolocking"
Dummy routine which \*(L"locks\*(R" a \s-1SV\s0 when there is no lockin module present.
Exists ta avoid test fo' a \s-1NULL\s0 function pointa n' cuz it could
potentially warn under some level of strict-ness.
.Sp
\&\*(L"Superseded\*(R" by \fIsv_nosharing()\fR.
.Sp
.Vb 1
\&        void    sv_nolocking(SV *sv)
.Ve
.IP "sv_nounlocking" 8
.IX Xref "sv_nounlocking"
.IX Item "sv_nounlocking"
Dummy routine which \*(L"unlocks\*(R" a \s-1SV\s0 when there is no lockin module present.
Exists ta avoid test fo' a \s-1NULL\s0 function pointa n' cuz it could
potentially warn under some level of strict-ness.
.Sp
\&\*(L"Superseded\*(R" by \fIsv_nosharing()\fR.
.Sp
.Vb 1
\&        void    sv_nounlocking(SV *sv)
.Ve
.IP "sv_nv" 8
.IX Xref "sv_nv"
.IX Item "sv_nv"
A private implementation of tha \f(CW\*(C`SvNVx\*(C'\fR macro fo' compilaz which can't
cope wit complex macro expressions fo' realz. Always use tha macro instead.
.Sp
.Vb 1
\&        NV      sv_nv(SV* sv)
.Ve
.IP "sv_pv" 8
.IX Xref "sv_pv"
.IX Item "sv_pv"
Use tha \f(CW\*(C`SvPV_nolen\*(C'\fR macro instead
.Sp
.Vb 1
\&        char*   sv_pv(SV *sv)
.Ve
.IP "sv_pvbyte" 8
.IX Xref "sv_pvbyte"
.IX Item "sv_pvbyte"
Use \f(CW\*(C`SvPVbyte_nolen\*(C'\fR instead.
.Sp
.Vb 1
\&        char*   sv_pvbyte(SV *sv)
.Ve
.IP "sv_pvbyten" 8
.IX Xref "sv_pvbyten"
.IX Item "sv_pvbyten"
A private implementation of tha \f(CW\*(C`SvPVbyte\*(C'\fR macro fo' compilers
which can't cope wit complex macro expressions fo' realz. Always use tha macro
instead.
.Sp
.Vb 1
\&        char*   sv_pvbyten(SV *sv, STRLEN *lp)
.Ve
.IP "sv_pvn" 8
.IX Xref "sv_pvn"
.IX Item "sv_pvn"
A private implementation of tha \f(CW\*(C`SvPV\*(C'\fR macro fo' compilaz which can't
cope wit complex macro expressions fo' realz. Always use tha macro instead.
.Sp
.Vb 1
\&        char*   sv_pvn(SV *sv, STRLEN *lp)
.Ve
.IP "sv_pvutf8" 8
.IX Xref "sv_pvutf8"
.IX Item "sv_pvutf8"
Use tha \f(CW\*(C`SvPVutf8_nolen\*(C'\fR macro instead
.Sp
.Vb 1
\&        char*   sv_pvutf8(SV *sv)
.Ve
.IP "sv_pvutf8n" 8
.IX Xref "sv_pvutf8n"
.IX Item "sv_pvutf8n"
A private implementation of tha \f(CW\*(C`SvPVutf8\*(C'\fR macro fo' compilers
which can't cope wit complex macro expressions fo' realz. Always use tha macro
instead.
.Sp
.Vb 1
\&        char*   sv_pvutf8n(SV *sv, STRLEN *lp)
.Ve
.IP "sv_taint" 8
.IX Xref "sv_taint"
.IX Item "sv_taint"
Taint a \s-1SV.\s0 Use \f(CW\*(C`SvTAINTED_on\*(C'\fR instead.
.Sp
.Vb 1
\&        void    sv_taint(SV* sv)
.Ve
.IP "sv_unref" 8
.IX Xref "sv_unref"
.IX Item "sv_unref"
Unsets tha \s-1RV\s0 statuz of tha \s-1SV,\s0 n' decrements tha reference count of
whatever was bein referenced by tha \s-1RV. \s0 This can almost be thought of
as a reversal of \f(CW\*(C`newSVrv\*(C'\fR.  This is \f(CW\*(C`sv_unref_flags\*(C'\fR wit tha \f(CW\*(C`flag\*(C'\fR
bein zero.  See \f(CW\*(C`SvROK_off\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_unref(SV* sv)
.Ve
.IP "sv_usepvn" 8
.IX Xref "sv_usepvn"
.IX Item "sv_usepvn"
Tells a \s-1SV\s0 ta use \f(CW\*(C`ptr\*(C'\fR ta find its strang value. Implemented by
callin \f(CW\*(C`sv_usepvn_flags\*(C'\fR wit \f(CW\*(C`flags\*(C'\fR of 0, hence do not handle 'set'
magic. Right back up in yo muthafuckin ass. See \f(CW\*(C`sv_usepvn_flags\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_usepvn(SV* sv, char* ptr, STRLEN len)
.Ve
.IP "sv_usepvn_mg" 8
.IX Xref "sv_usepvn_mg"
.IX Item "sv_usepvn_mg"
Like \f(CW\*(C`sv_usepvn\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_usepvn_mg(SV *sv, char *ptr, STRLEN len)
.Ve
.IP "sv_uv" 8
.IX Xref "sv_uv"
.IX Item "sv_uv"
A private implementation of tha \f(CW\*(C`SvUVx\*(C'\fR macro fo' compilaz which can't
cope wit complex macro expressions fo' realz. Always use tha macro instead.
.Sp
.Vb 1
\&        UV      sv_uv(SV* sv)
.Ve
.IP "unpack_str" 8
.IX Xref "unpack_str"
.IX Item "unpack_str"
Da engine implementin \fIunpack()\fR Perl function. I aint talkin' bout chicken n' gravy biatch. Note: parametas strbeg, new_s
and ocnt is not used. Y'all KNOW dat shit, muthafucka! This call should not be used, use unpackstrin instead.
.Sp
.Vb 4
\&        I32     unpack_str(const char *pat, const char *patend,
\&                           const char *s, const char *strbeg,
\&                           const char *strend, char **new_s,
\&                           I32 ocnt, U32 flags)
.Ve
.SH "Functions up in file op.c"
.IX Header "Functions up in file op.c"
.IP "alloccopstash" 8
.IX Xref "alloccopstash"
.IX Item "alloccopstash"
Available only under threaded builds, dis function allocates a entry in
\&\f(CW\*(C`PL_stashpad\*(C'\fR fo' tha stash passed ta dat shit.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADOFFSET alloccopstash(HV *hv)
.Ve
.IP "op_contextualize" 8
.IX Xref "op_contextualize"
.IX Item "op_contextualize"
Applies a syntactic context ta a op tree representin a expression.
\&\fIo\fR is tha op tree, n' \fIcontext\fR must be \f(CW\*(C`G_SCALAR\*(C'\fR, \f(CW\*(C`G_ARRAY\*(C'\fR,
or \f(CW\*(C`G_VOID\*(C'\fR ta specify tha context ta apply.  Da modified op tree
is returned.
.Sp
.Vb 1
\&        OP *    op_contextualize(OP *o, I32 context)
.Ve
.SH "Functions up in file perl.h"
.IX Header "Functions up in file perl.h"
.IP "\s-1PERL_SYS_INIT \s0" 8
.IX Xref "PERL_SYS_INIT"
.IX Item "PERL_SYS_INIT "
Provides system-specific tune up of tha C runtime environment necessary to
run Perl interpreters. This should be called only once, before bustin
any Perl interpreters.
.Sp
.Vb 1
\&        void    PERL_SYS_INIT(int *argc, char*** argv)
.Ve
.IP "\s-1PERL_SYS_INIT3 \s0" 8
.IX Xref "PERL_SYS_INIT3"
.IX Item "PERL_SYS_INIT3 "
Provides system-specific tune up of tha C runtime environment necessary to
run Perl interpreters. This should be called only once, before bustin
any Perl interpreters.
.Sp
.Vb 2
\&        void    PERL_SYS_INIT3(int *argc, char*** argv,
\&                               char*** env)
.Ve
.IP "\s-1PERL_SYS_TERM \s0" 8
.IX Xref "PERL_SYS_TERM"
.IX Item "PERL_SYS_TERM "
Provides system-specific clean up of tha C runtime environment after
runnin Perl interpreters. This should be called only once, after
freein any remainin Perl interpreters.
.Sp
.Vb 1
\&        void    PERL_SYS_TERM()
.Ve
.SH "Functions up in file pp_ctl.c"
.IX Header "Functions up in file pp_ctl.c"
.IP "caller_cx" 8
.IX Xref "caller_cx"
.IX Item "caller_cx"
Da XSUB-writerz equivalent of \fIcaller()\fR. The
returned \f(CW\*(C`PERL_CONTEXT\*(C'\fR structure can be invigorated ta find all the
information moonwalked back ta Perl by \f(CW\*(C`caller\*(C'\fR. Note dat XSUBs don't git a
stack frame, so \f(CW\*(C`caller_cx(0, NULL)\*(C'\fR will return shiznit fo' the
immediately-surroundin Perl code.
.Sp
This function skips over tha automatic calls ta \f(CW&DB::sub\fR made on the
behalf of tha debugger n' shit. If tha stack frame axed was a sub called by
\&\f(CW\*(C`DB::sub\*(C'\fR, tha return value is ghon be tha frame fo' tha call to
\&\f(CW\*(C`DB::sub\*(C'\fR, since dat has tha erect line number/etc. fo' tha call
site. If \fIdbcxp\fR is non\-\f(CW\*(C`NULL\*(C'\fR, it is ghon be set ta a pointa ta the
frame fo' tha sub call itself.
.Sp
.Vb 4
\&        const PERL_CONTEXT * caller_cx(
\&                                 I32 level,
\&                                 const PERL_CONTEXT **dbcxp
\&                             )
.Ve
.IP "find_runcv" 8
.IX Xref "find_runcv"
.IX Item "find_runcv"
Locate tha \s-1CV\s0 correspondin ta tha currently executin sub or eval.
If db_seqp is non_null, skip CVs dat is up in tha \s-1DB\s0 package n' populate
*db_seqp wit tha cop sequence number all up in tha point dat tha \s-1DB::\s0 code was
entered. Y'all KNOW dat shit, muthafucka! (allows debuggers ta eval up in tha scope of tha breakpoint rather
than up in tha scope of tha debugger itself).
.Sp
.Vb 1
\&        CV*     find_runcv(U32 *db_seqp)
.Ve
.SH "Functions up in file pp_pack.c"
.IX Header "Functions up in file pp_pack.c"
.IP "packlist" 8
.IX Xref "packlist"
.IX Item "packlist"
Da engine implementin \fIpack()\fR Perl function.
.Sp
.Vb 3
\&        void    packlist(SV *cat, const char *pat,
\&                         const char *patend, SV **beglist,
\&                         SV **endlist)
.Ve
.IP "unpackstring" 8
.IX Xref "unpackstring"
.IX Item "unpackstring"
Da engine implementin tha \fIunpack()\fR Perl function.
.Sp
Usin tha template pat..patend, dis function unpacks tha string
s..strend tha fuck into a fuckin shitload of mortal SVs, which it pushes onto tha perl
argument (@_) stack (so yo big-ass booty is ghon need ta issue a \f(CW\*(C`PUTBACK\*(C'\fR before and
\&\f(CW\*(C`SPAGAIN\*(C'\fR afta tha call ta dis function). Well shiiiit, it returns tha number of
pushed elements.
.Sp
Da strend n' patend pointas should point ta tha byte followin tha last
characta of each string.
.Sp
Although dis function returns its joints on tha perl argument stack, it
doesn't take any parametas from dat stack (and thus up in particular
therez no need ta do a \s-1PUSHMARK\s0 before callin it, unlike \*(L"call_pv\*(R" for
example).
.Sp
.Vb 3
\&        I32     unpackstring(const char *pat,
\&                             const char *patend, const char *s,
\&                             const char *strend, U32 flags)
.Ve
.SH "Functions up in file pp_sys.c"
.IX Header "Functions up in file pp_sys.c"
.IP "setdefout" 8
.IX Xref "setdefout"
.IX Item "setdefout"
Sets PL_defoutgv, tha default file handle fo' output, ta tha passed in
typeglob fo' realz. As PL_defoutgv \*(L"owns\*(R" a reference on its typeglob, tha reference
count of tha passed up in typeglob is increased by one, n' tha reference count
of tha typeglob dat PL_defoutgv points ta is decreased by one.
.Sp
.Vb 1
\&        void    setdefout(GV* gv)
.Ve
.SH "Functions up in file utf8.h"
.IX Header "Functions up in file utf8.h"
.IP "ibcmp_utf8" 8
.IX Xref "ibcmp_utf8"
.IX Item "ibcmp_utf8"
This be a synonym fo' (! \fIfoldEQ_utf8()\fR)
.Sp
.Vb 3
\&        I32     ibcmp_utf8(const char *s1, char **pe1, UV l1,
\&                           bool u1, const char *s2, char **pe2,
\&                           UV l2, bool u2)
.Ve
.SH "Functions up in file util.h"
.IX Header "Functions up in file util.h"
.IP "ibcmp" 8
.IX Xref "ibcmp"
.IX Item "ibcmp"
This be a synonym fo' (! \fIfoldEQ()\fR)
.Sp
.Vb 1
\&        I32     ibcmp(const char* a, const char* b, I32 len)
.Ve
.IP "ibcmp_locale" 8
.IX Xref "ibcmp_locale"
.IX Item "ibcmp_locale"
This be a synonym fo' (! \fIfoldEQ_locale()\fR)
.Sp
.Vb 2
\&        I32     ibcmp_locale(const char* a, const char* b,
\&                             I32 len)
.Ve
.SH "Global Variables"
.IX Header "Global Variables"
.IP "PL_check" 8
.IX Xref "PL_check"
.IX Item "PL_check"
Array, indexed by opcode, of functions dat is ghon be called fo' tha \*(L"check\*(R"
phase of optree buildin durin compilation of Perl code.  For most (but
not all) typez of op, once tha op has been initially built n' populated
with lil pimp ops it is ghon be filtered all up in tha check function referenced
by tha appropriate element of dis array.  Da freshly smoked up op is passed up in as the
sole argument ta tha check function, n' tha check function returns the
completed op.  Da check function may (as tha name suggests) check tha op
for validitizzle n' signal errors.  It may also initialise or modify parts of
the ops, or big-ass up mo' radical surgery like fuckin addin or removin child
ops, or even throw tha op away n' return a gangbangin' finger-lickin' different op up in its place.
.Sp
This array of function pointas be a cold-ass lil convenient place ta hook tha fuck into the
compilation process.  An \s-1XS\s0 module can put its own custom check function
in place of any of tha standard ones, ta influence tha compilation of a
particular type of op.  But fuck dat shiznit yo, tha word on tha street is dat a cold-ass lil custom check function must never fully
replace a standard check function (or even a cold-ass lil custom check function from
another module).  A module modifyin checkin must instead \fBwrap\fR the
preexistin check function. I aint talkin' bout chicken n' gravy biatch.  A custom check function must be selective
about when ta apply its custom behaviour. Shiiit, dis aint no joke.  In tha usual case where
it decides not ta do anythang special wit a op, it must chain the
preexistin op function. I aint talkin' bout chicken n' gravy biatch.  Peep functions is thus linked up in a cold-ass lil chain,
with tha corez base checker all up in tha end.
.Sp
For thread safety, modulez should not write directly ta dis array.
Instead, use tha function \*(L"wrap_op_checker\*(R".
.IP "PL_keyword_plugin" 8
.IX Xref "PL_keyword_plugin"
.IX Item "PL_keyword_plugin"
Function pointer, pointin at a gangbangin' function used ta handle extended keywords.
Da function should be declared as
.Sp
.Vb 3
\&        int keyword_plugin_function(pTHX_
\&                char *keyword_ptr, STRLEN keyword_len,
\&                OP **op_ptr)
.Ve
.Sp
Da function is called from tha tokeniser, whenever a possible keyword
is seen. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`keyword_ptr\*(C'\fR points all up in tha word up in tha parserz input
buffer, n' \f(CW\*(C`keyword_len\*(C'\fR gives its length; it aint null-terminated.
Da function is sposed ta fuckin examine tha word, n' possibly other state
like fuckin %^H, ta decizzle whether it wants ta handle it
as a extended keyword. Y'all KNOW dat shit, muthafucka!  If it do not, tha function should return
\&\f(CW\*(C`KEYWORD_PLUGIN_DECLINE\*(C'\fR, n' tha aiiight parser process will continue.
.Sp
If tha function wants ta handle tha keyword, it first must
parse anythang followin tha keyword dat is part of tha syntax
introduced by tha keyword. Y'all KNOW dat shit, muthafucka!  See \*(L"Lexer intercourse\*(R" fo' details.
.Sp
When a keyword is bein handled, tha plugin function must build
a tree of \f(CW\*(C`OP\*(C'\fR structures, representin tha code dat was parsed.
Da root of tha tree must be stored up in \f(CW*op_ptr\fR.  Da function then
returns a cold-ass lil constant indicatin tha syntactic role of tha construct that
it has parsed: \f(CW\*(C`KEYWORD_PLUGIN_STMT\*(C'\fR if it aint nuthin but a cold-ass lil complete statement, or
\&\f(CW\*(C`KEYWORD_PLUGIN_EXPR\*(C'\fR if it be a expression. I aint talkin' bout chicken n' gravy biatch.  Note dat a statement
construct cannot be used inside a expression (except via \f(CW\*(C`do BLOCK\*(C'\fR
and similar), n' a expression aint a cold-ass lil complete statement (it requires
at least a terminatin semicolon).
.Sp
When a keyword is handled, tha plugin function may also have
(compile-time) side effects, n' you can put dat on yo' toast.  It may modify \f(CW\*(C`%^H\*(C'\fR, define functions, and
so on. I aint talkin' bout chicken n' gravy biatch.  Typically, if side effects is tha main purpose of a handlez,
it do not wish ta generate any ops ta be included up in tha normal
compilation. I aint talkin' bout chicken n' gravy biatch.  In dis case it is still required ta supply a op tree,
but it suffices ta generate a single null op.
.Sp
Thatz how tha fuck tha \f(CW*PL_keyword_plugin\fR function need ta behave overall.
Conventionally, however, one do not straight-up replace tha existing
handlez function. I aint talkin' bout chicken n' gravy biatch.  Instead, take a cold-ass lil copy of \f(CW\*(C`PL_keyword_plugin\*(C'\fR before
assignin yo' own function pointa ta dat shit.  Yo crazy-ass handlez function should
look fo' keywordz dat it is horny bout n' handle them.  Where it
is not interested, it should call tha saved plugin function, passin on
the arguments it received. Y'all KNOW dat shit, muthafucka!  Thus \f(CW\*(C`PL_keyword_plugin\*(C'\fR straight-up points
at a cold-ass lil chain of handlez functions, all of which have a opportunitizzle to
handle keywords, n' only tha last function up in tha chain (built into
the Perl core) will normally return \f(CW\*(C`KEYWORD_PLUGIN_DECLINE\*(C'\fR.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.SH "GV Functions"
.IX Header "GV Functions"
.IP "GvAV" 8
.IX Xref "GvAV"
.IX Item "GvAV"
Return tha \s-1AV\s0 from tha \s-1GV.\s0
.Sp
.Vb 1
\&        AV*     GvAV(GV* gv)
.Ve
.IP "GvCV" 8
.IX Xref "GvCV"
.IX Item "GvCV"
Return tha \s-1CV\s0 from tha \s-1GV.\s0
.Sp
.Vb 1
\&        CV*     GvCV(GV* gv)
.Ve
.IP "GvHV" 8
.IX Xref "GvHV"
.IX Item "GvHV"
Return tha \s-1HV\s0 from tha \s-1GV.\s0
.Sp
.Vb 1
\&        HV*     GvHV(GV* gv)
.Ve
.IP "GvSV" 8
.IX Xref "GvSV"
.IX Item "GvSV"
Return tha \s-1SV\s0 from tha \s-1GV.\s0
.Sp
.Vb 1
\&        SV*     GvSV(GV* gv)
.Ve
.IP "gv_const_sv" 8
.IX Xref "gv_const_sv"
.IX Item "gv_const_sv"
If \f(CW\*(C`gv\*(C'\fR be a typeglob whose subroutine entry be a cold-ass lil constant sub eligible for
inlining, or \f(CW\*(C`gv\*(C'\fR be a placeholda reference dat would be promoted ta such
a typeglob, then returns tha value returned by tha sub.  Otherwise, returns
\&\s-1NULL.\s0
.Sp
.Vb 1
\&        SV*     gv_const_sv(GV* gv)
.Ve
.IP "gv_fetchmeth" 8
.IX Xref "gv_fetchmeth"
.IX Item "gv_fetchmeth"
Like \*(L"gv_fetchmeth_pvn\*(R" yo, but lacks a gangbangin' flags parameter.
.Sp
.Vb 2
\&        GV*     gv_fetchmeth(HV* stash, const char* name,
\&                             STRLEN len, I32 level)
.Ve
.IP "gv_fetchmethod_autoload" 8
.IX Xref "gv_fetchmethod_autoload"
.IX Item "gv_fetchmethod_autoload"
Returns tha glob which gotz nuff tha subroutine ta booty-call ta invoke tha method
on tha \f(CW\*(C`stash\*(C'\fR.  In fact up in tha presence of autoloadin dis may be the
glob fo' \*(L"\s-1AUTOLOAD\*(R". \s0 In dis case tha correspondin variable \f(CW$AUTOLOAD\fR is
already setup.
.Sp
Da third parameta of \f(CW\*(C`gv_fetchmethod_autoload\*(C'\fR determines whether
\&\s-1AUTOLOAD\s0 lookup is performed if tha given method aint present: non-zero
means fo'sho, look fo' \s-1AUTOLOAD\s0; zero means no, don't look fo' \s-1AUTOLOAD.\s0
Callin \f(CW\*(C`gv_fetchmethod\*(C'\fR is equivalent ta callin \f(CW\*(C`gv_fetchmethod_autoload\*(C'\fR
with a non-zero \f(CW\*(C`autoload\*(C'\fR parameter.
.Sp
These functions grant \f(CW"SUPER"\fR token as a prefix of tha method name. Note
that if you wanna keep tha returned glob fo' a long-ass time, you need to
check fo' it bein \*(L"\s-1AUTOLOAD\*(R",\s0 since all up in tha lata time tha call may load a
different subroutine cuz of \f(CW$AUTOLOAD\fR changin its value. Use tha glob
created via a side effect ta do all dis bullshit.
.Sp
These functions have tha same side-effects n' as \f(CW\*(C`gv_fetchmeth\*(C'\fR with
\&\f(CW\*(C`level==0\*(C'\fR.  \f(CW\*(C`name\*(C'\fR should be writable if gotz nuff \f(CW\*(Aq:\*(Aq\fR or \f(CW\*(Aq
\&\*(Aq\*(Aq\fR. Da warnin against passin tha \s-1GV\s0 returned by \f(CW\*(C`gv_fetchmeth\*(C'\fR to
\&\f(CW\*(C`call_sv\*(C'\fR apply equally ta these functions.
.Sp
.Vb 3
\&        GV*     gv_fetchmethod_autoload(HV* stash,
\&                                        const char* name,
\&                                        I32 autoload)
.Ve
.IP "gv_fetchmeth_autoload" 8
.IX Xref "gv_fetchmeth_autoload"
.IX Item "gv_fetchmeth_autoload"
This is tha oldschool form of \*(L"gv_fetchmeth_pvn_autoload\*(R", which has no flags
parameter.
.Sp
.Vb 3
\&        GV*     gv_fetchmeth_autoload(HV* stash,
\&                                      const char* name,
\&                                      STRLEN len, I32 level)
.Ve
.IP "gv_fetchmeth_pv" 8
.IX Xref "gv_fetchmeth_pv"
.IX Item "gv_fetchmeth_pv"
Exactly like \*(L"gv_fetchmeth_pvn\*(R" yo, but takes a nul-terminated strang 
instead of a string/length pair.
.Sp
.Vb 2
\&        GV*     gv_fetchmeth_pv(HV* stash, const char* name,
\&                                I32 level, U32 flags)
.Ve
.IP "gv_fetchmeth_pvn" 8
.IX Xref "gv_fetchmeth_pvn"
.IX Item "gv_fetchmeth_pvn"
Returns tha glob wit tha given \f(CW\*(C`name\*(C'\fR n' a thugged-out defined subroutine or
\&\f(CW\*(C`NULL\*(C'\fR.  Da glob lives up in tha given \f(CW\*(C`stash\*(C'\fR, or up in tha stashes
accessible via \f(CW@ISA\fR n' \s-1UNIVERSAL::.\s0
.Sp
Da argument \f(CW\*(C`level\*(C'\fR should be either 0 or \-1.  If \f(CW\*(C`level==0\*(C'\fR, as a
side-effect creates a glob wit tha given \f(CW\*(C`name\*(C'\fR up in tha given \f(CW\*(C`stash\*(C'\fR
which up in tha case of success gotz nuff a alias fo' tha subroutine, n' sets
up cachin info fo' dis glob.
.Sp
Da only dope joints fo' \f(CW\*(C`flags\*(C'\fR is \s-1GV_SUPER\s0 n' SVf_UTF8.
.Sp
\&\s-1GV_SUPER\s0 indicates dat we wanna look up tha method up in tha superclasses
of tha \f(CW\*(C`stash\*(C'\fR.
.Sp
The
\&\s-1GV\s0 returned from \f(CW\*(C`gv_fetchmeth\*(C'\fR may be a method cache entry, which is not
visible ta Perl code.  So when callin \f(CW\*(C`call_sv\*(C'\fR, you should not use
the \s-1GV\s0 directly; instead, you should use tha methodz \s-1CV,\s0 which can be
obtained from tha \s-1GV\s0 wit tha \f(CW\*(C`GvCV\*(C'\fR macro.
.Sp
.Vb 3
\&        GV*     gv_fetchmeth_pvn(HV* stash, const char* name,
\&                                 STRLEN len, I32 level,
\&                                 U32 flags)
.Ve
.IP "gv_fetchmeth_pvn_autoload" 8
.IX Xref "gv_fetchmeth_pvn_autoload"
.IX Item "gv_fetchmeth_pvn_autoload"
Same as \fIgv_fetchmeth_pvn()\fR yo, but looks fo' autoloaded subroutines like a muthafucka.
Returns a glob fo' tha subroutine.
.Sp
For a autoloaded subroutine without a \s-1GV,\s0 will create a \s-1GV\s0 even
if \f(CW\*(C`level < 0\*(C'\fR.  For a autoloaded subroutine without a stub, \fIGvCV()\fR
of tha result may be zero.
.Sp
Currently, tha only dope value fo' \f(CW\*(C`flags\*(C'\fR is SVf_UTF8.
.Sp
.Vb 4
\&        GV*     gv_fetchmeth_pvn_autoload(HV* stash,
\&                                          const char* name,
\&                                          STRLEN len, I32 level,
\&                                          U32 flags)
.Ve
.IP "gv_fetchmeth_pv_autoload" 8
.IX Xref "gv_fetchmeth_pv_autoload"
.IX Item "gv_fetchmeth_pv_autoload"
Exactly like \*(L"gv_fetchmeth_pvn_autoload\*(R" yo, but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 3
\&        GV*     gv_fetchmeth_pv_autoload(HV* stash,
\&                                         const char* name,
\&                                         I32 level, U32 flags)
.Ve
.IP "gv_fetchmeth_sv" 8
.IX Xref "gv_fetchmeth_sv"
.IX Item "gv_fetchmeth_sv"
Exactly like \*(L"gv_fetchmeth_pvn\*(R" yo, but takes tha name strang up in tha form
of a \s-1SV\s0 instead of a string/length pair.
.Sp
.Vb 2
\&        GV*     gv_fetchmeth_sv(HV* stash, SV* namesv,
\&                                I32 level, U32 flags)
.Ve
.IP "gv_fetchmeth_sv_autoload" 8
.IX Xref "gv_fetchmeth_sv_autoload"
.IX Item "gv_fetchmeth_sv_autoload"
Exactly like \*(L"gv_fetchmeth_pvn_autoload\*(R" yo, but takes tha name strang up in tha form
of a \s-1SV\s0 instead of a string/length pair.
.Sp
.Vb 2
\&        GV*     gv_fetchmeth_sv_autoload(HV* stash, SV* namesv,
\&                                         I32 level, U32 flags)
.Ve
.IP "gv_init" 8
.IX Xref "gv_init"
.IX Item "gv_init"
Da oldschool form of \fIgv_init_pvn()\fR.  It do not work wit \s-1UTF8\s0 strings, as it
has no flags parameter n' shit.  If tha \f(CW\*(C`multi\*(C'\fR parameta is set, the
\&\s-1GV_ADDMULTI\s0 flag is ghon be passed ta \fIgv_init_pvn()\fR.
.Sp
.Vb 2
\&        void    gv_init(GV* gv, HV* stash, const char* name,
\&                        STRLEN len, int multi)
.Ve
.IP "gv_init_pv" 8
.IX Xref "gv_init_pv"
.IX Item "gv_init_pv"
Same as \fIgv_init_pvn()\fR yo, but takes a nul-terminated strang fo' tha name
instead of separate char * n' length parameters.
.Sp
.Vb 2
\&        void    gv_init_pv(GV* gv, HV* stash, const char* name,
\&                           U32 flags)
.Ve
.IP "gv_init_pvn" 8
.IX Xref "gv_init_pvn"
.IX Item "gv_init_pvn"
Converts a scalar tha fuck into a typeglob.  This be a incoercible typeglob;
assignin a reference ta it will assign ta one of its slots, instead of
overwritin it as happens wit typeglobs pimped by SvSetSV.  Converting
any scalar dat is \fISvOK()\fR may produce unpredictable thangs up in dis biatch n' is reserved
for perlz internal use.
.Sp
\&\f(CW\*(C`gv\*(C'\fR is tha scalar ta be converted.
.Sp
\&\f(CW\*(C`stash\*(C'\fR is tha parent stash/package, if any.
.Sp
\&\f(CW\*(C`name\*(C'\fR n' \f(CW\*(C`len\*(C'\fR give tha name.  Da name must be unqualified;
that is, it must not include tha package name.  If \f(CW\*(C`gv\*(C'\fR be a
stash element, it is tha callerz responsibilitizzle ta ensure dat tha name
passed ta dis function matches tha name of tha element.  If it do not
match, perlz internal bookkeepin will git outta sync.
.Sp
\&\f(CW\*(C`flags\*(C'\fR can be set ta SVf_UTF8 if \f(CW\*(C`name\*(C'\fR be a \s-1UTF8\s0 string, or
the return value of SvUTF8(sv).  It can also take the
\&\s-1GV_ADDMULTI\s0 flag, which means ta pretend dat tha \s-1GV\s0 has been
seen before (i.e., suppress \*(L"Used once\*(R" warnings).
.Sp
.Vb 2
\&        void    gv_init_pvn(GV* gv, HV* stash, const char* name,
\&                            STRLEN len, U32 flags)
.Ve
.IP "gv_init_sv" 8
.IX Xref "gv_init_sv"
.IX Item "gv_init_sv"
Same as \fIgv_init_pvn()\fR yo, but takes a \s-1SV\s0 * fo' tha name instead of separate
char * n' length parameters.  \f(CW\*(C`flags\*(C'\fR is currently unused.
.Sp
.Vb 2
\&        void    gv_init_sv(GV* gv, HV* stash, SV* namesv,
\&                           U32 flags)
.Ve
.IP "gv_stashpv" 8
.IX Xref "gv_stashpv"
.IX Item "gv_stashpv"
Returns a pointa ta tha stash fo' a specified package.  Uses \f(CW\*(C`strlen\*(C'\fR to
determine tha length of \f(CW\*(C`name\*(C'\fR, then calls \f(CW\*(C`gv_stashpvn()\*(C'\fR.
.Sp
.Vb 1
\&        HV*     gv_stashpv(const char* name, I32 flags)
.Ve
.IP "gv_stashpvn" 8
.IX Xref "gv_stashpvn"
.IX Item "gv_stashpvn"
Returns a pointa ta tha stash fo' a specified package.  Da \f(CW\*(C`namelen\*(C'\fR
parameta indicates tha length of tha \f(CW\*(C`name\*(C'\fR, up in bytes.  \f(CW\*(C`flags\*(C'\fR is passed
to \f(CW\*(C`gv_fetchpvn_flags()\*(C'\fR, so if set ta \f(CW\*(C`GV_ADD\*(C'\fR then tha package will be
created if it do not already exist.  If tha package do not exist and
\&\f(CW\*(C`flags\*(C'\fR is 0 (or any other settin dat do not create packages) then \s-1NULL\s0
is returned.
.Sp
Flags may be one of:
.Sp
.Vb 6
\&    GV_ADD
\&    SVf_UTF8
\&    GV_NOADD_NOINIT
\&    GV_NOINIT
\&    GV_NOEXPAND
\&    GV_ADDMG
.Ve
.Sp
Da most blingin of which is probably \s-1GV_ADD\s0 n' SVf_UTF8.
.Sp
.Vb 2
\&        HV*     gv_stashpvn(const char* name, U32 namelen,
\&                            I32 flags)
.Ve
.IP "gv_stashpvs" 8
.IX Xref "gv_stashpvs"
.IX Item "gv_stashpvs"
Like \f(CW\*(C`gv_stashpvn\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        HV*     gv_stashpvs(const char* name, I32 create)
.Ve
.IP "gv_stashsv" 8
.IX Xref "gv_stashsv"
.IX Item "gv_stashsv"
Returns a pointa ta tha stash fo' a specified package.  See \f(CW\*(C`gv_stashpvn\*(C'\fR.
.Sp
.Vb 1
\&        HV*     gv_stashsv(SV* sv, I32 flags)
.Ve
.SH "Handy Values"
.IX Header "Handy Values"
.IP "Nullav" 8
.IX Xref "Nullav"
.IX Item "Nullav"
Null \s-1AV\s0 pointer.
.Sp
(deprecated \- use \f(CW\*(C`(AV *)NULL\*(C'\fR instead)
.IP "Nullch" 8
.IX Xref "Nullch"
.IX Item "Nullch"
Null characta pointer n' shit. (No longer available when \f(CW\*(C`PERL_CORE\*(C'\fR is defined.)
.IP "Nullcv" 8
.IX Xref "Nullcv"
.IX Item "Nullcv"
Null \s-1CV\s0 pointer.
.Sp
(deprecated \- use \f(CW\*(C`(CV *)NULL\*(C'\fR instead)
.IP "Nullhv" 8
.IX Xref "Nullhv"
.IX Item "Nullhv"
Null \s-1HV\s0 pointer.
.Sp
(deprecated \- use \f(CW\*(C`(HV *)NULL\*(C'\fR instead)
.IP "Nullsv" 8
.IX Xref "Nullsv"
.IX Item "Nullsv"
Null \s-1SV\s0 pointer n' shit. (No longer available when \f(CW\*(C`PERL_CORE\*(C'\fR is defined.)
.SH "Hash Manipulation Functions"
.IX Header "Hash Manipulation Functions"
.IP "cop_fetch_label" 8
.IX Xref "cop_fetch_label"
.IX Item "cop_fetch_label"
Returns tha label attached ta a cold-ass lil cop.
Da flags pointa may be set ta \f(CW\*(C`SVf_UTF8\*(C'\fR or 0.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        const char * cop_fetch_label(COP *const cop,
\&                                     STRLEN *len, U32 *flags)
.Ve
.IP "cop_store_label" 8
.IX Xref "cop_store_label"
.IX Item "cop_store_label"
Save a label tha fuck into a \f(CW\*(C`cop_hints_hash\*(C'\fR. Yo ass need ta set flags ta \f(CW\*(C`SVf_UTF8\*(C'\fR
for a utf\-8 label.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        void    cop_store_label(COP *const cop,
\&                                const char *label, STRLEN len,
\&                                U32 flags)
.Ve
.IP "get_hv" 8
.IX Xref "get_hv"
.IX Item "get_hv"
Returns tha \s-1HV\s0 of tha specified Perl hash.  \f(CW\*(C`flags\*(C'\fR is passed to
\&\f(CW\*(C`gv_fetchpv\*(C'\fR. If \f(CW\*(C`GV_ADD\*(C'\fR is set n' the
Perl variable do not exist then it is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \f(CW\*(C`flags\*(C'\fR is zero
and tha variable do not exist then \s-1NULL\s0 is returned.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        HV*     get_hv(const char *name, I32 flags)
.Ve
.IP "HEf_SVKEY" 8
.IX Xref "HEf_SVKEY"
.IX Item "HEf_SVKEY"
This flag, used up in tha length slot of hash entries n' magic structures,
specifies tha structure gotz nuff a \f(CW\*(C`SV*\*(C'\fR pointa where a \f(CW\*(C`char*\*(C'\fR pointer
is ta be expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (For shiznit only\*(--not ta be used).
.IP "HeHASH" 8
.IX Xref "HeHASH"
.IX Item "HeHASH"
Returns tha computed hash stored up in tha hash entry.
.Sp
.Vb 1
\&        U32     HeHASH(HE* he)
.Ve
.IP "HeKEY" 8
.IX Xref "HeKEY"
.IX Item "HeKEY"
Returns tha actual pointa stored up in tha key slot of tha hash entry. The
pointa may be either \f(CW\*(C`char*\*(C'\fR or \f(CW\*(C`SV*\*(C'\fR, dependin on tha value of
\&\f(CW\*(C`HeKLEN()\*(C'\fR.  Can be assigned to.  Da \f(CW\*(C`HePV()\*(C'\fR or \f(CW\*(C`HeSVKEY()\*(C'\fR macros are
usually preferable fo' findin tha value of a key.
.Sp
.Vb 1
\&        void*   HeKEY(HE* he)
.Ve
.IP "HeKLEN" 8
.IX Xref "HeKLEN"
.IX Item "HeKLEN"
If dis is negative, n' amounts ta \f(CW\*(C`HEf_SVKEY\*(C'\fR, it indicates tha entry
holdz a \f(CW\*(C`SV*\*(C'\fR key.  Otherwise, holdz tha actual length of tha key.  Can
be assigned to. Da \f(CW\*(C`HePV()\*(C'\fR macro is probably preferable fo' findin key
lengths.
.Sp
.Vb 1
\&        STRLEN  HeKLEN(HE* he)
.Ve
.IP "HePV" 8
.IX Xref "HePV"
.IX Item "HePV"
Returns tha key slot of tha hash entry as a \f(CW\*(C`char*\*(C'\fR value, bustin any
necessary dereferencin of possibly \f(CW\*(C`SV*\*(C'\fR keys.  Da length of tha string
is placed up in \f(CW\*(C`len\*(C'\fR (this be a macro, so do \fInot\fR use \f(CW&len\fR).  If you do
not care bout what tha fuck tha length of tha key is, you may use tha global
variable \f(CW\*(C`PL_na\*(C'\fR, though dis is rather less efficient than rockin a local
variable.  Remember though, dat hash keys up in perl is free ta contain
embedded nulls, so rockin \f(CW\*(C`strlen()\*(C'\fR or similar aint a phat way ta find
the length of hash keys. This is straight-up similar ta tha \f(CW\*(C`SvPV()\*(C'\fR macro
busted lyrics bout elsewhere up in dis document. Right back up in yo muthafuckin ass. See also \f(CW\*(C`HeUTF8\*(C'\fR.
.Sp
If yo ass is rockin \f(CW\*(C`HePV\*(C'\fR ta git joints ta pass ta \f(CW\*(C`newSVpvn()\*(C'\fR ta create a
new \s-1SV,\s0 you should consider rockin \f(CW\*(C`newSVhek(HeKEY_hek(he))\*(C'\fR as it is more
efficient.
.Sp
.Vb 1
\&        char*   HePV(HE* he, STRLEN len)
.Ve
.IP "HeSVKEY" 8
.IX Xref "HeSVKEY"
.IX Item "HeSVKEY"
Returns tha key as a \f(CW\*(C`SV*\*(C'\fR, or \f(CW\*(C`NULL\*(C'\fR if tha hash entry do not
contain a \f(CW\*(C`SV*\*(C'\fR key.
.Sp
.Vb 1
\&        SV*     HeSVKEY(HE* he)
.Ve
.IP "HeSVKEY_force" 8
.IX Xref "HeSVKEY_force"
.IX Item "HeSVKEY_force"
Returns tha key as a \f(CW\*(C`SV*\*(C'\fR.  Will create n' return a temporary mortal
\&\f(CW\*(C`SV*\*(C'\fR if tha hash entry gotz nuff only a \f(CW\*(C`char*\*(C'\fR key.
.Sp
.Vb 1
\&        SV*     HeSVKEY_force(HE* he)
.Ve
.IP "HeSVKEY_set" 8
.IX Xref "HeSVKEY_set"
.IX Item "HeSVKEY_set"
Sets tha key ta a given \f(CW\*(C`SV*\*(C'\fR, takin care ta set tha appropriate flags to
indicate tha presence of a \f(CW\*(C`SV*\*(C'\fR key, n' returns tha same
\&\f(CW\*(C`SV*\*(C'\fR.
.Sp
.Vb 1
\&        SV*     HeSVKEY_set(HE* he, SV* sv)
.Ve
.IP "HeUTF8" 8
.IX Xref "HeUTF8"
.IX Item "HeUTF8"
Returns whether tha \f(CW\*(C`char *\*(C'\fR value returned by \f(CW\*(C`HePV\*(C'\fR is encoded up in \s-1UTF\-8,\s0
fuckin wit any necessary dereferencin of possibly \f(CW\*(C`SV*\*(C'\fR keys.  Da value returned
will be 0 or non\-0, not necessarily 1 (or even a value wit any low bits set),
so \fBdo not\fR blindly assign dis ta a \f(CW\*(C`bool\*(C'\fR variable, as \f(CW\*(C`bool\*(C'\fR may be a
typedef fo' \f(CW\*(C`char\*(C'\fR.
.Sp
.Vb 1
\&        char*   HeUTF8(HE* he)
.Ve
.IP "HeVAL" 8
.IX Xref "HeVAL"
.IX Item "HeVAL"
Returns tha value slot (type \f(CW\*(C`SV*\*(C'\fR) stored up in tha hash entry. Can be assigned
to.
.Sp
.Vb 2
\&  SV *foo= HeVAL(hv);
\&  HeVAL(hv)= sv;
\&
\&
\&        SV*     HeVAL(HE* he)
.Ve
.IP "HvENAME" 8
.IX Xref "HvENAME"
.IX Item "HvENAME"
Returns tha effectizzle name of a stash, or \s-1NULL\s0 if there is none. The
effectizzle name represents a location up in tha symbol table where dis stash
resides. Well shiiiit, it is updated automatically when packages is aliased or deleted.
A stash dat is no longer up in tha symbol table has no effectizzle name. This
name is preferable ta \f(CW\*(C`HvNAME\*(C'\fR fo' use up in \s-1MRO\s0 linearisations n' isa
caches.
.Sp
.Vb 1
\&        char*   HvENAME(HV* stash)
.Ve
.IP "HvENAMELEN" 8
.IX Xref "HvENAMELEN"
.IX Item "HvENAMELEN"
Returns tha length of tha stashz effectizzle name.
.Sp
.Vb 1
\&        STRLEN  HvENAMELEN(HV *stash)
.Ve
.IP "HvENAMEUTF8" 8
.IX Xref "HvENAMEUTF8"
.IX Item "HvENAMEUTF8"
Returns legit if tha effectizzle name is up in \s-1UTF8\s0 encoding.
.Sp
.Vb 1
\&        unsigned char HvENAMEUTF8(HV *stash)
.Ve
.IP "HvNAME" 8
.IX Xref "HvNAME"
.IX Item "HvNAME"
Returns tha package name of a stash, or \s-1NULL\s0 if \f(CW\*(C`stash\*(C'\fR aint a stash.
See \f(CW\*(C`SvSTASH\*(C'\fR, \f(CW\*(C`CvSTASH\*(C'\fR.
.Sp
.Vb 1
\&        char*   HvNAME(HV* stash)
.Ve
.IP "HvNAMELEN" 8
.IX Xref "HvNAMELEN"
.IX Item "HvNAMELEN"
Returns tha length of tha stashz name.
.Sp
.Vb 1
\&        STRLEN  HvNAMELEN(HV *stash)
.Ve
.IP "HvNAMEUTF8" 8
.IX Xref "HvNAMEUTF8"
.IX Item "HvNAMEUTF8"
Returns legit if tha name is up in \s-1UTF8\s0 encoding.
.Sp
.Vb 1
\&        unsigned char HvNAMEUTF8(HV *stash)
.Ve
.IP "hv_assert" 8
.IX Xref "hv_assert"
.IX Item "hv_assert"
Peep dat a hash is up in a internally consistent state.
.Sp
.Vb 1
\&        void    hv_assert(HV *hv)
.Ve
.IP "hv_clear" 8
.IX Xref "hv_clear"
.IX Item "hv_clear"
Frees tha all tha elementz of a hash, leavin it empty.
Da \s-1XS\s0 equivalent of \f(CW\*(C`%hash = ()\*(C'\fR.  See also \*(L"hv_undef\*(R".
.Sp
If any destructors is triggered as a result, tha hv itself may
be freed.
.Sp
.Vb 1
\&        void    hv_clear(HV *hv)
.Ve
.IP "hv_clear_placeholders" 8
.IX Xref "hv_clear_placeholders"
.IX Item "hv_clear_placeholders"
Clears any placeholdaz from a hash.  If a restricted hash has any of its keys
marked as readonly n' tha key is subsequently deleted, tha key aint actually
deleted but is marked by assignin it a value of &PL_sv_placeholda n' shit.  This tags
it so it is ghon be ignored by future operations like fuckin iteratin over tha hash,
but will still allow tha hash ta git a value reassigned ta tha key at some
future point.  This function clears any such placeholda keys from tha hash.
See \fIHash::Util::lock_keys()\fR fo' a example of its use.
.Sp
.Vb 1
\&        void    hv_clear_placeholders(HV *hv)
.Ve
.IP "hv_copy_hints_hv" 8
.IX Xref "hv_copy_hints_hv"
.IX Item "hv_copy_hints_hv"
A specialised version of \*(L"newHVhv\*(R" fo' copyin \f(CW\*(C`%^H\*(C'\fR.  \fIohv\fR must be
a pointa ta a hash (which may have \f(CW\*(C`%^H\*(C'\fR magic yo, but should be generally
non-magical), or \f(CW\*(C`NULL\*(C'\fR (interpreted as a empty hash).  Da content
of \fIohv\fR is copied ta a freshly smoked up hash, which has tha \f(CW\*(C`%^H\*(C'\fR\-specific magic
added ta dat shit.  A pointa ta tha freshly smoked up hash is returned.
.Sp
.Vb 1
\&        HV *    hv_copy_hints_hv(HV *ohv)
.Ve
.IP "hv_delete" 8
.IX Xref "hv_delete"
.IX Item "hv_delete"
Deletes a key/value pair up in tha hash.  Da valuez \s-1SV\s0 is removed from
the hash, made mortal, n' moonwalked back ta tha calla n' shit.  Da absolute
value of \f(CW\*(C`klen\*(C'\fR is tha length of tha key.  If \f(CW\*(C`klen\*(C'\fR is wack the
key be assumed ta be up in UTF\-8\-encoded Unicode.  Da \f(CW\*(C`flags\*(C'\fR value
will normally be zero; if set ta G_DISCARD then \s-1NULL\s0 is ghon be returned.
\&\s-1NULL\s0 will also be returned if tha key aint found.
.Sp
.Vb 2
\&        SV*     hv_delete(HV *hv, const char *key, I32 klen,
\&                          I32 flags)
.Ve
.IP "hv_delete_ent" 8
.IX Xref "hv_delete_ent"
.IX Item "hv_delete_ent"
Deletes a key/value pair up in tha hash.  Da value \s-1SV\s0 is removed from tha hash,
made mortal, n' moonwalked back ta tha calla n' shit.  Da \f(CW\*(C`flags\*(C'\fR value will normally be
zero; if set ta G_DISCARD then \s-1NULL\s0 is ghon be returned. Y'all KNOW dat shit, muthafucka!  \s-1NULL\s0 will also be
returned if tha key aint found. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`hash\*(C'\fR can be a valid precomputed hash
value, or 0 ta ask fo' it ta be computed.
.Sp
.Vb 2
\&        SV*     hv_delete_ent(HV *hv, SV *keysv, I32 flags,
\&                              U32 hash)
.Ve
.IP "hv_exists" 8
.IX Xref "hv_exists"
.IX Item "hv_exists"
Returns a funky-ass boolean indicatin whether tha specified hash key exists, n' you can put dat on yo' toast.  The
absolute value of \f(CW\*(C`klen\*(C'\fR is tha length of tha key.  If \f(CW\*(C`klen\*(C'\fR is
negatizzle tha key be assumed ta be up in UTF\-8\-encoded Unicode.
.Sp
.Vb 1
\&        bool    hv_exists(HV *hv, const char *key, I32 klen)
.Ve
.IP "hv_exists_ent" 8
.IX Xref "hv_exists_ent"
.IX Item "hv_exists_ent"
Returns a funky-ass boolean indicatin whether
the specified hash key exists, n' you can put dat on yo' toast.  \f(CW\*(C`hash\*(C'\fR
can be a valid precomputed hash value, or 0 ta ask fo' it ta be
computed.
.Sp
.Vb 1
\&        bool    hv_exists_ent(HV *hv, SV *keysv, U32 hash)
.Ve
.IP "hv_fetch" 8
.IX Xref "hv_fetch"
.IX Item "hv_fetch"
Returns tha \s-1SV\s0 which correspondz ta tha specified key up in tha hash.
Da absolute value of \f(CW\*(C`klen\*(C'\fR is tha length of tha key.  If \f(CW\*(C`klen\*(C'\fR is
negatizzle tha key be assumed ta be up in UTF\-8\-encoded Unicode.  If
\&\f(CW\*(C`lval\*(C'\fR is set then tha fetch is ghon be part of a store.  This means dat if
there is no value up in tha hash associated wit tha given key, then one is
created n' a pointa ta it is returned. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`SV*\*(C'\fR it points ta can be
assigned to.  But always check dat the
return value is non-null before dereferencin it ta a \f(CW\*(C`SV*\*(C'\fR.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts fo' more
information on how tha fuck ta use dis function on tied hashes.
.Sp
.Vb 2
\&        SV**    hv_fetch(HV *hv, const char *key, I32 klen,
\&                         I32 lval)
.Ve
.IP "hv_fetchs" 8
.IX Xref "hv_fetchs"
.IX Item "hv_fetchs"
Like \f(CW\*(C`hv_fetch\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        SV**    hv_fetchs(HV* tb, const char* key, I32 lval)
.Ve
.IP "hv_fetch_ent" 8
.IX Xref "hv_fetch_ent"
.IX Item "hv_fetch_ent"
Returns tha hash entry which correspondz ta tha specified key up in tha hash.
\&\f(CW\*(C`hash\*(C'\fR must be a valid precomputed hash number fo' tha given \f(CW\*(C`key\*(C'\fR, or 0
if you want tha function ta compute dat shit.  \s-1IF \s0\f(CW\*(C`lval\*(C'\fR is set then tha fetch
will be part of a store.  Make shizzle tha return value is non-null before
accessin dat shit.  Da return value when \f(CW\*(C`hv\*(C'\fR be a tied hash be a pointa ta a
static location, so be shizzle ta cook up a cold-ass lil copy of tha structure if you need to
store it somewhere.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts fo' more
information on how tha fuck ta use dis function on tied hashes.
.Sp
.Vb 2
\&        HE*     hv_fetch_ent(HV *hv, SV *keysv, I32 lval,
\&                             U32 hash)
.Ve
.IP "hv_fill" 8
.IX Xref "hv_fill"
.IX Item "hv_fill"
Returns tha number of hash buckets dat happen ta be up in use. This function is
wrapped by tha macro \f(CW\*(C`HvFILL\*(C'\fR.
.Sp
Previously dis value was stored up in tha \s-1HV\s0 structure, rather than being
calculated on demand.
.Sp
.Vb 1
\&        STRLEN  hv_fill(HV const *const hv)
.Ve
.IP "hv_iterinit" 8
.IX Xref "hv_iterinit"
.IX Item "hv_iterinit"
Prepares a startin point ta traverse a hash table.  Returns tha number of
keys up in tha hash (i.e. tha same as \f(CW\*(C`HvUSEDKEYS(hv)\*(C'\fR).  Da return value is
currently only meaningful fo' hashes without tie magic.
.Sp
\&\s-1NOTE:\s0 Before version 5.004_65, \f(CW\*(C`hv_iterinit\*(C'\fR used ta return tha number of
hash buckets dat happen ta be up in use.  If you still need dat esoteric
value, you can git it all up in tha macro \f(CW\*(C`HvFILL(hv)\*(C'\fR.
.Sp
.Vb 1
\&        I32     hv_iterinit(HV *hv)
.Ve
.IP "hv_iterkey" 8
.IX Xref "hv_iterkey"
.IX Item "hv_iterkey"
Returns tha key from tha current posizzle of tha hash iterator. Shiiit, dis aint no joke.  See
\&\f(CW\*(C`hv_iterinit\*(C'\fR.
.Sp
.Vb 1
\&        char*   hv_iterkey(HE* entry, I32* retlen)
.Ve
.IP "hv_iterkeysv" 8
.IX Xref "hv_iterkeysv"
.IX Item "hv_iterkeysv"
Returns tha key as a \f(CW\*(C`SV*\*(C'\fR from tha current posizzle of tha hash
iterator. Shiiit, dis aint no joke.  Da return value will always be a mortal copy of tha key.  Also
see \f(CW\*(C`hv_iterinit\*(C'\fR.
.Sp
.Vb 1
\&        SV*     hv_iterkeysv(HE* entry)
.Ve
.IP "hv_iternext" 8
.IX Xref "hv_iternext"
.IX Item "hv_iternext"
Returns entries from a hash iterator. Shiiit, dis aint no joke.  See \f(CW\*(C`hv_iterinit\*(C'\fR.
.Sp
Yo ass may call \f(CW\*(C`hv_delete\*(C'\fR or \f(CW\*(C`hv_delete_ent\*(C'\fR on tha hash entry dat the
iterator currently points to, without losin yo' place or invalipimpin your
iterator. Shiiit, dis aint no joke.  Note dat up in dis case tha current entry is deleted from tha hash
with yo' iterator holdin tha last reference ta dat shit.  Yo crazy-ass iterator is flagged
to free tha entry on tha next call ta \f(CW\*(C`hv_iternext\*(C'\fR, so you must not discard
your iterator immediately else tha entry will leak \- call \f(CW\*(C`hv_iternext\*(C'\fR to
trigger tha resource deallocation.
.Sp
.Vb 1
\&        HE*     hv_iternext(HV *hv)
.Ve
.IP "hv_iternextsv" 8
.IX Xref "hv_iternextsv"
.IX Item "hv_iternextsv"
Performs a \f(CW\*(C`hv_iternext\*(C'\fR, \f(CW\*(C`hv_iterkey\*(C'\fR, n' \f(CW\*(C`hv_iterval\*(C'\fR up in one
operation.
.Sp
.Vb 1
\&        SV*     hv_iternextsv(HV *hv, char **key, I32 *retlen)
.Ve
.IP "hv_iternext_flags" 8
.IX Xref "hv_iternext_flags"
.IX Item "hv_iternext_flags"
Returns entries from a hash iterator. Shiiit, dis aint no joke.  See \f(CW\*(C`hv_iterinit\*(C'\fR n' \f(CW\*(C`hv_iternext\*(C'\fR.
Da \f(CW\*(C`flags\*(C'\fR value will normally be zero; if \s-1HV_ITERNEXT_WANTPLACEHOLDERS\s0 is
set tha placeholdaz keys (for restricted hashes) is ghon be returned up in addition
to aiiight keys. By default placeholdaz is automatically skipped over.
Currently a placeholda is implemented wit a value dat is
\&\f(CW&PL_sv_placeholder\fR.  Note dat tha implementation of placeholdaz and
restricted hashes may chizzle, n' tha implementation currently is
insufficiently abstracted fo' any chizzle ta be tidy.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        HE*     hv_iternext_flags(HV *hv, I32 flags)
.Ve
.IP "hv_iterval" 8
.IX Xref "hv_iterval"
.IX Item "hv_iterval"
Returns tha value from tha current posizzle of tha hash iterator. Shiiit, dis aint no joke.  See
\&\f(CW\*(C`hv_iterkey\*(C'\fR.
.Sp
.Vb 1
\&        SV*     hv_iterval(HV *hv, HE *entry)
.Ve
.IP "hv_magic" 8
.IX Xref "hv_magic"
.IX Item "hv_magic"
Addz magic ta a hash.  See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        void    hv_magic(HV *hv, GV *gv, int how)
.Ve
.IP "hv_scalar" 8
.IX Xref "hv_scalar"
.IX Item "hv_scalar"
Evaluates tha hash up in scalar context n' returns tha result yo. Handlez magic when tha hash is tied.
.Sp
.Vb 1
\&        SV*     hv_scalar(HV *hv)
.Ve
.IP "hv_store" 8
.IX Xref "hv_store"
.IX Item "hv_store"
Stores a \s-1SV\s0 up in a hash.  Da hash key is specified as \f(CW\*(C`key\*(C'\fR n' the
absolute value of \f(CW\*(C`klen\*(C'\fR is tha length of tha key.  If \f(CW\*(C`klen\*(C'\fR is
negatizzle tha key be assumed ta be up in UTF\-8\-encoded Unicode.  The
\&\f(CW\*(C`hash\*(C'\fR parameta is tha precomputed hash value; if it is zero then
Perl will compute dat shit.
.Sp
Da return value will be
\&\s-1NULL\s0 if tha operation failed or if tha value did not need ta be actually
stored within tha hash (as up in tha case of tied hashes).  Otherwise it can
be dereferenced ta git tha original gangsta \f(CW\*(C`SV*\*(C'\fR.  Note dat tha calla is
responsible fo' suitably incrementin tha reference count of \f(CW\*(C`val\*(C'\fR before
the call, n' decrementin it if tha function returned \s-1NULL. \s0 Effectively
a successful hv_store takes ballershizzle of one reference ta \f(CW\*(C`val\*(C'\fR.  This is
usually what tha fuck you want; a newly pimped \s-1SV\s0 has a reference count of one, so
if all yo' code do is create SVs then store dem up in a hash, hv_store
will own tha only reference ta tha freshly smoked up \s-1SV,\s0 n' yo' code don't need ta do
anythang further ta tidy up.  hv_store aint implemented as a cold-ass lil call to
hv_store_ent, n' do not create a temporary \s-1SV\s0 fo' tha key, so if your
key data aint already up in \s-1SV\s0 form then use hv_store up in preference to
hv_store_ent.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts fo' more
information on how tha fuck ta use dis function on tied hashes.
.Sp
.Vb 2
\&        SV**    hv_store(HV *hv, const char *key, I32 klen,
\&                         SV *val, U32 hash)
.Ve
.IP "hv_stores" 8
.IX Xref "hv_stores"
.IX Item "hv_stores"
Like \f(CW\*(C`hv_store\*(C'\fR yo, but takes a literal strang instead of a string/length pair
and omits tha hash parameter.
.Sp
.Vb 2
\&        SV**    hv_stores(HV* tb, const char* key,
\&                          NULLOK SV* val)
.Ve
.IP "hv_store_ent" 8
.IX Xref "hv_store_ent"
.IX Item "hv_store_ent"
Stores \f(CW\*(C`val\*(C'\fR up in a hash.  Da hash key is specified as \f(CW\*(C`key\*(C'\fR.  Da \f(CW\*(C`hash\*(C'\fR
parameta is tha precomputed hash value; if it is zero then Perl will
compute dat shit.  Da return value is tha freshly smoked up hash entry so pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It will be
\&\s-1NULL\s0 if tha operation failed or if tha value did not need ta be actually
stored within tha hash (as up in tha case of tied hashes).  Otherwise the
contentz of tha return value can be accessed rockin tha \f(CW\*(C`He?\*(C'\fR macros
busted lyrics bout here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Note dat tha calla is responsible fo' suitably
incrementin tha reference count of \f(CW\*(C`val\*(C'\fR before tha call, and
decrementin it if tha function returned \s-1NULL. \s0 Effectively a successful
hv_store_ent takes ballershizzle of one reference ta \f(CW\*(C`val\*(C'\fR.  This is
usually what tha fuck you want; a newly pimped \s-1SV\s0 has a reference count of one, so
if all yo' code do is create SVs then store dem up in a hash, hv_store
will own tha only reference ta tha freshly smoked up \s-1SV,\s0 n' yo' code don't need ta do
anythang further ta tidy up.  Note dat hv_store_ent only readz tha \f(CW\*(C`key\*(C'\fR;
unlike \f(CW\*(C`val\*(C'\fR it do not take ballershizzle of it, so maintainin tha erect
reference count on \f(CW\*(C`key\*(C'\fR is entirely tha callerz responsibility.  hv_store
is not implemented as a cold-ass lil call ta hv_store_ent, n' do not create a temporary
\&\s-1SV\s0 fo' tha key, so if yo' key data aint already up in \s-1SV\s0 form then use
hv_store up in preference ta hv_store_ent.
.Sp
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" up in perlguts fo' more
information on how tha fuck ta use dis function on tied hashes.
.Sp
.Vb 1
\&        HE*     hv_store_ent(HV *hv, SV *key, SV *val, U32 hash)
.Ve
.IP "hv_undef" 8
.IX Xref "hv_undef"
.IX Item "hv_undef"
Undefines tha hash.  Da \s-1XS\s0 equivalent of \f(CW\*(C`undef(%hash)\*(C'\fR.
.Sp
As well as freein all tha elementz of tha hash (like \fIhv_clear()\fR), this
also frees any auxiliary data n' storage associated wit tha hash.
.Sp
If any destructors is triggered as a result, tha hv itself may
be freed.
.Sp
See also \*(L"hv_clear\*(R".
.Sp
.Vb 1
\&        void    hv_undef(HV *hv)
.Ve
.IP "newHV" 8
.IX Xref "newHV"
.IX Item "newHV"
Creates a freshly smoked up \s-1HV. \s0 Da reference count is set ta 1.
.Sp
.Vb 1
\&        HV*     newHV()
.Ve
.SH "Hook manipulation"
.IX Header "Hook manipulation"
.IP "wrap_op_checker" 8
.IX Xref "wrap_op_checker"
.IX Item "wrap_op_checker"
Puts a C function tha fuck into tha chain of check functions fo' a specified op
type.  This is tha preferred way ta manipulate tha \*(L"PL_check\*(R" array.
\&\fIopcode\fR specifies which type of op is ta be affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fInew_checker\fR
is a pointa ta tha C function dat is ta be added ta dat opcode's
check chain, n' \fIold_checker_p\fR points ta tha storage location where a
pointa ta tha next function up in tha chain is ghon be stored. Y'all KNOW dat shit, muthafucka!  Da value of
\&\fInew_pointer\fR is freestyled tha fuck into tha \*(L"PL_check\*(R" array, while tha value
previously stored there is freestyled ta \fI*old_checker_p\fR.
.Sp
\&\*(L"PL_check\*(R" is global ta a entire process, n' a module wishin to
hook op checkin may find itself invoked mo' than once per process,
typically up in different threads.  To handle dat thang, dis function
is idempotent.  Da location \fI*old_checker_p\fR must initially (once
per process) contain a null pointer n' shit.  A C variable of static duration
(declared at file scope, typically also marked \f(CW\*(C`static\*(C'\fR ta give
it internal linkage) is ghon be implicitly initialised appropriately,
if it aint gots a explicit initialiser n' shit.  This function will only
actually modify tha check chain if it findz \fI*old_checker_p\fR ta be null.
This function be also thread safe on tha lil' small-ass scale.  It uses appropriate
lockin ta avoid race conditions up in accessin \*(L"PL_check\*(R".
.Sp
When dis function is called, tha function referenced by \fInew_checker\fR
must be locked n loaded ta be called, except fo' \fI*old_checker_p\fR bein unfilled.
In a threadin thang, \fInew_checker\fR may be called immediately,
even before dis function has returned. Y'all KNOW dat shit, muthafucka!  \fI*old_checker_p\fR will always
be appropriately set before \fInew_checker\fR is called. Y'all KNOW dat shit, muthafucka!  If \fInew_checker\fR
decides not ta do anythang special wit a op dat it is given (which
is tha usual case fo' most usez of op check hooking), it must chain the
check function referenced by \fI*old_checker_p\fR.
.Sp
If you wanna influence compilation of calls ta a specific subroutine,
then use \*(L"cv_set_call_checker\*(R" rather than hookin checkin of all
\&\f(CW\*(C`entersub\*(C'\fR ops.
.Sp
.Vb 3
\&        void    wrap_op_checker(Optype opcode,
\&                                Perl_check_t new_checker,
\&                                Perl_check_t *old_checker_p)
.Ve
.SH "Lexer intercourse"
.IX Header "Lexer intercourse"
.IP "lex_bufutf8" 8
.IX Xref "lex_bufutf8"
.IX Item "lex_bufutf8"
Indicates whether tha octets up in tha lexer buffer
(\*(L"PL_parser\->linestr\*(R") should be interpreted as tha \s-1UTF\-8\s0 encoding
of Unicode characters.  If not, they should be interpreted as Latin\-1
characters.  This be analogous ta tha \f(CW\*(C`SvUTF8\*(C'\fR flag fo' scalars.
.Sp
In \s-1UTF\-8\s0 mode, it aint guaranteed dat tha lexer buffer actually
gotz nuff valid \s-1UTF\-8. \s0 Lexin code must be robust up in tha grill of invalid
encoding.
.Sp
Da actual \f(CW\*(C`SvUTF8\*(C'\fR flag of tha \*(L"PL_parser\->linestr\*(R" scalar
is significant yo, but not tha whole rap regardin tha input character
encoding.  Normally, when a gangbangin' file is bein read, tha scalar gotz nuff octets
and its \f(CW\*(C`SvUTF8\*(C'\fR flag is off yo, but tha octets should be interpreted as
\&\s-1UTF\-8\s0 if tha \f(CW\*(C`use utf8\*(C'\fR pragma is up in effect.  Durin a strang eval,
however, tha scalar may have tha \f(CW\*(C`SvUTF8\*(C'\fR flag on, n' up in dis case its
octets should be interpreted as \s-1UTF\-8\s0 unless tha \f(CW\*(C`use bytes\*(C'\fR pragma
is up in effect.  This logic may chizzle up in tha future; use dis function
instead of implementin tha logic yo ass.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        bool    lex_bufutf8()
.Ve
.IP "lex_discard_to" 8
.IX Xref "lex_discard_to"
.IX Item "lex_discard_to"
Discardz tha straight-up original gangsta part of tha \*(L"PL_parser\->linestr\*(R" buffer,
up ta \fIptr\fR.  Da remainin content of tha buffer is ghon be moved, and
all pointas tha fuck into tha buffer updated appropriately.  \fIptr\fR must not
be lata up in tha buffer than tha posizzle of \*(L"PL_parser\->bufptr\*(R":
it aint permitted ta discard text dat has yet ta be lexed.
.Sp
Normally it aint necessarily ta do dis directly, cuz it suffices to
use tha implicit discardin behaviour of \*(L"lex_next_chunk\*(R" n' thangs
based on dat shit.  But fuck dat shiznit yo, tha word on tha street is dat if a token stretches across multiple lines,
and tha lexin code has kept multiple linez of text up in tha buffer for
that purpose, then afta completion of tha token it would be wise to
explicitly discard tha now-unneeded earlier lines, ta avoid future
multi-line tokens growin tha buffer without bound.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_discard_to(char *ptr)
.Ve
.IP "lex_grow_linestr" 8
.IX Xref "lex_grow_linestr"
.IX Item "lex_grow_linestr"
Reallocates tha lexer buffer (\*(L"PL_parser\->linestr\*(R") ta accommodate
at least \fIlen\fR octets (includin terminatin \s-1NUL\s0).  Returns a
pointa ta tha reallocated buffer n' shit.  This is necessary before making
any direct modification of tha buffer dat would increase its length.
\&\*(L"lex_stuff_pvn\*(R" serves up a mo' convenient way ta bang text into
the buffer.
.Sp
Do not use \f(CW\*(C`SvGROW\*(C'\fR or \f(CW\*(C`sv_grow\*(C'\fR directly on \f(CW\*(C`PL_parser\->linestr\*(C'\fR;
this function thugged-out shiznit all of tha lexerz variablez dat point directly
into tha buffer.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        char *  lex_grow_linestr(STRLEN len)
.Ve
.IP "lex_next_chunk" 8
.IX Xref "lex_next_chunk"
.IX Item "lex_next_chunk"
Readz up in tha next chunk of text ta be lexed, appendin it to
\&\*(L"PL_parser\->linestr\*(R".  This should be called when lexin code has
looked ta tha end of tha current chunk n' wants ta know mo' n' mo' n' mo'.  It is
usual yo, but not necessary, fo' lexin ta have consumed tha entirety of
the current chunk at dis time.
.Sp
If \*(L"PL_parser\->bufptr\*(R" is pointin ta tha straight-up end of tha current
chunk (i.e., tha current chunk has been entirely consumed), normally the
current chunk is ghon be discarded all up in tha same time dat tha freshly smoked up chunk is
read in. I aint talkin' bout chicken n' gravy biatch.  If \fIflags\fR includes \f(CW\*(C`LEX_KEEP_PREVIOUS\*(C'\fR, tha current chunk
will not be discarded. Y'all KNOW dat shit, muthafucka!  If tha current chunk has not been entirely
consumed, then it aint gonna be discarded regardless of tha flag.
.Sp
Returns legit if some freshly smoked up text was added ta tha buffer, or false if the
buffer has reached tha end of tha input text.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        bool    lex_next_chunk(U32 flags)
.Ve
.IP "lex_peek_unichar" 8
.IX Xref "lex_peek_unichar"
.IX Item "lex_peek_unichar"
Looks ahead one (Unicode) characta up in tha text currently bein lexed.
Returns tha codepoint (unsigned integer value) of tha next character,
or \-1 if lexin has reached tha end of tha input text.  To consume the
peeked character, use \*(L"lex_read_unichar\*(R".
.Sp
If tha next characta is up in (or extendz into) tha next chunk of input
text, tha next chunk is ghon be read in. I aint talkin' bout chicken n' gravy biatch.  Normally tha current chunk will be
discarded all up in tha same time yo, but if \fIflags\fR includes \f(CW\*(C`LEX_KEEP_PREVIOUS\*(C'\fR
then tha current chunk aint gonna be discarded.
.Sp
If tha input is bein interpreted as \s-1UTF\-8\s0 n' a \s-1UTF\-8\s0 encodin error
is encountered, a exception is generated.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        I32     lex_peek_unichar(U32 flags)
.Ve
.IP "lex_read_space" 8
.IX Xref "lex_read_space"
.IX Item "lex_read_space"
Readz optionizzle spaces, up in Perl style, up in tha text currently being
lexed. Y'all KNOW dat shit, muthafucka!  Da spaces may include ordinary whitespace charactas and
Perl-style comments, n' you can put dat on yo' toast.  \f(CW\*(C`#line\*(C'\fR directives is processed if encountered.
\&\*(L"PL_parser\->bufptr\*(R" is moved past tha spaces, so dat it points
at a non-space characta (or tha end of tha input text).
.Sp
If spaces extend tha fuck into tha next chunk of input text, tha next chunk will
be read in. I aint talkin' bout chicken n' gravy biatch.  Normally tha current chunk is ghon be discarded all up in tha same
time yo, but if \fIflags\fR includes \f(CW\*(C`LEX_KEEP_PREVIOUS\*(C'\fR then tha current
chunk aint gonna be discarded.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_read_space(U32 flags)
.Ve
.IP "lex_read_to" 8
.IX Xref "lex_read_to"
.IX Item "lex_read_to"
Consume text up in tha lexer buffer, from \*(L"PL_parser\->bufptr\*(R" up
to \fIptr\fR.  This advances \*(L"PL_parser\->bufptr\*(R" ta match \fIptr\fR,
performin tha erect bookkeepin whenever a newline characta is passed.
This is tha aiiight way ta consume lexed text.
.Sp
Interpretation of tha bufferz octets can be abstracted up by
usin tha slightly higher-level functions \*(L"lex_peek_unichar\*(R" and
\&\*(L"lex_read_unichar\*(R".
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_read_to(char *ptr)
.Ve
.IP "lex_read_unichar" 8
.IX Xref "lex_read_unichar"
.IX Item "lex_read_unichar"
Readz tha next (Unicode) characta up in tha text currently bein lexed.
Returns tha codepoint (unsigned integer value) of tha characta read,
and moves \*(L"PL_parser\->bufptr\*(R" past tha character, or returns \-1
if lexin has reached tha end of tha input text.  To non-destructively
examine tha next character, use \*(L"lex_peek_unichar\*(R" instead.
.Sp
If tha next characta is up in (or extendz into) tha next chunk of input
text, tha next chunk is ghon be read in. I aint talkin' bout chicken n' gravy biatch.  Normally tha current chunk will be
discarded all up in tha same time yo, but if \fIflags\fR includes \f(CW\*(C`LEX_KEEP_PREVIOUS\*(C'\fR
then tha current chunk aint gonna be discarded.
.Sp
If tha input is bein interpreted as \s-1UTF\-8\s0 n' a \s-1UTF\-8\s0 encodin error
is encountered, a exception is generated.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        I32     lex_read_unichar(U32 flags)
.Ve
.IP "lex_start" 8
.IX Xref "lex_start"
.IX Item "lex_start"
Creates n' initialises a freshly smoked up lexer/parser state object, supplying
a context up in which ta lex n' parse from a freshly smoked up source of Perl code.
A pointa ta tha freshly smoked up state object is placed up in \*(L"PL_parser\*(R".  An entry
is made on tha save stack so dat upon unwindin tha freshly smoked up state object
will be destroyed n' tha forma value of \*(L"PL_parser\*(R" is ghon be restored.
Nothang else need be done ta clean up tha parsin context.
.Sp
Da code ta be parsed be reppin \fIline\fR n' \fIrsfp\fR.  \fIline\fR, if
non-null, serves up a strang (in \s-1SV\s0 form) containin code ta be parsed.
A copy of tha strang is made, so subsequent modification of \fIline\fR
does not affect parsing.  \fIrsfp\fR, if non-null, serves up a input stream
from which code is ghon be read ta be parsed. Y'all KNOW dat shit, muthafucka!  If both is non-null, the
code up in \fIline\fR comes first n' must consist of complete linez of input,
and \fIrsfp\fR supplies tha remainder of tha source.
.Sp
Da \fIflags\fR parameta is reserved fo' future use.  Currently it is only
used by perl internally, so extensions should always pass zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_start(SV *line, PerlIO *rsfp, U32 flags)
.Ve
.IP "lex_stuff_pv" 8
.IX Xref "lex_stuff_pv"
.IX Item "lex_stuff_pv"
Insert charactas tha fuck into tha lexer buffer (\*(L"PL_parser\->linestr\*(R"),
immediately afta tha current lexin point (\*(L"PL_parser\->bufptr\*(R"),
reallocatin tha buffer if necessary.  This means dat lexin code that
runs lata will peep tha charactas as if they had rocked up in tha input.
It aint recommended ta do dis as part of aiiight parsing, n' most
usez of dis facilitizzle run tha risk of tha banged charactas being
interpreted up in a unintended manner.
.Sp
Da strang ta be banged is represented by octets startin at \fIpv\fR
and continuin ta tha straight-up original gangsta nul.  These octets is interpreted as either
\&\s-1UTF\-8\s0 or Latin\-1, accordin ta whether tha \f(CW\*(C`LEX_STUFF_UTF8\*(C'\fR flag is set
in \fIflags\fR.  Da charactas is recoded fo' tha lexer buffer, according
to how tha fuck tha buffer is currently bein interpreted (\*(L"lex_bufutf8\*(R").
If it aint convenient ta nul-terminizzle a strang ta be inserted, the
\&\*(L"lex_stuff_pvn\*(R" function is mo' appropriate.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_stuff_pv(const char *pv, U32 flags)
.Ve
.IP "lex_stuff_pvn" 8
.IX Xref "lex_stuff_pvn"
.IX Item "lex_stuff_pvn"
Insert charactas tha fuck into tha lexer buffer (\*(L"PL_parser\->linestr\*(R"),
immediately afta tha current lexin point (\*(L"PL_parser\->bufptr\*(R"),
reallocatin tha buffer if necessary.  This means dat lexin code that
runs lata will peep tha charactas as if they had rocked up in tha input.
It aint recommended ta do dis as part of aiiight parsing, n' most
usez of dis facilitizzle run tha risk of tha banged charactas being
interpreted up in a unintended manner.
.Sp
Da strang ta be banged is represented by \fIlen\fR octets starting
at \fIpv\fR.  These octets is interpreted as either \s-1UTF\-8\s0 or Latin\-1,
accordin ta whether tha \f(CW\*(C`LEX_STUFF_UTF8\*(C'\fR flag is set up in \fIflags\fR.
Da charactas is recoded fo' tha lexer buffer, accordin ta how tha fuck the
buffer is currently bein interpreted (\*(L"lex_bufutf8\*(R").  If a string
to be banged be available as a Perl scalar, tha \*(L"lex_stuff_sv\*(R"
function is mo' convenient.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        void    lex_stuff_pvn(const char *pv, STRLEN len,
\&                              U32 flags)
.Ve
.IP "lex_stuff_pvs" 8
.IX Xref "lex_stuff_pvs"
.IX Item "lex_stuff_pvs"
Like \*(L"lex_stuff_pvn\*(R" yo, but takes a literal strang instead of a
string/length pair.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_stuff_pvs(const char *pv, U32 flags)
.Ve
.IP "lex_stuff_sv" 8
.IX Xref "lex_stuff_sv"
.IX Item "lex_stuff_sv"
Insert charactas tha fuck into tha lexer buffer (\*(L"PL_parser\->linestr\*(R"),
immediately afta tha current lexin point (\*(L"PL_parser\->bufptr\*(R"),
reallocatin tha buffer if necessary.  This means dat lexin code that
runs lata will peep tha charactas as if they had rocked up in tha input.
It aint recommended ta do dis as part of aiiight parsing, n' most
usez of dis facilitizzle run tha risk of tha banged charactas being
interpreted up in a unintended manner.
.Sp
Da strang ta be banged is tha strang value of \fIsv\fR.  Da characters
are recoded fo' tha lexer buffer, accordin ta how tha fuck tha buffer is currently
bein interpreted (\*(L"lex_bufutf8\*(R").  If a strang ta be banged is
not already a Perl scalar, tha \*(L"lex_stuff_pvn\*(R" function avoidz the
need ta construct a scalar.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_stuff_sv(SV *sv, U32 flags)
.Ve
.IP "lex_unstuff" 8
.IX Xref "lex_unstuff"
.IX Item "lex_unstuff"
Discardz text bout ta be lexed, from \*(L"PL_parser\->bufptr\*(R" up to
\&\fIptr\fR.  Text followin \fIptr\fR is ghon be moved, n' tha buffer shortened.
This hides tha discarded text from any lexin code dat runs later,
as if tha text had never rocked up.
.Sp
This aint tha aiiight way ta consume lexed text.  For that, use
\&\*(L"lex_read_to\*(R".
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    lex_unstuff(char *ptr)
.Ve
.IP "parse_arithexpr" 8
.IX Xref "parse_arithexpr"
.IX Item "parse_arithexpr"
Parse a Perl arithmetic expression. I aint talkin' bout chicken n' gravy biatch.  This may contain operatorz of precedence
down ta tha bit shift operators.  Da expression must be followed (and thus
terminated) either by a cold-ass lil comparison or lower-precedence operator or by
suttin' dat would normally terminizzle a expression like fuckin semicolon.
If \fIflags\fR includes \f(CW\*(C`PARSE_OPTIONAL\*(C'\fR then tha expression is optional,
otherwise it is mandatory.  It be up ta tha calla ta ensure dat the
dynamic parser state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect
the source of tha code ta be parsed n' tha lexical context fo' the
expression.
.Sp
Da op tree representin tha expression is returned. Y'all KNOW dat shit, muthafucka!  If a optional
expression be absent, a null pointa is returned, otherwise tha pointer
will be non-null.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree is returned anyway.  Da error is reflected up in tha parser state,
normally resultin up in a single exception all up in tha top level of parsing
which covers all tha compilation errors dat occurred. Y'all KNOW dat shit, muthafucka!  Some compilation
errors, however, will throw a exception immediately.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_arithexpr(U32 flags)
.Ve
.IP "parse_barestmt" 8
.IX Xref "parse_barestmt"
.IX Item "parse_barestmt"
Parse a single unadorned Perl statement.  This may be a aiiight imperative
statement or a thugged-out declaration dat has compile-time effect.  It do not
include any label or other affixture.  It be up ta tha calla ta ensure
that tha dynamic parser state (\*(L"PL_parser\*(R" et al) is erectly set to
reflect tha source of tha code ta be parsed n' tha lexical context for
the statement.
.Sp
Da op tree representin tha statement is returned. Y'all KNOW dat shit, muthafucka!  This may be a
null pointa if tha statement is null, fo' example if dat shiznit was actually
a subroutine definizzle (which has compile-time side effects).  If not
null, it is ghon be ops directly implementin tha statement, suitable to
pass ta \*(L"newSTATEOP\*(R".  It aint gonna normally include a \f(CW\*(C`nextstate\*(C'\fR or
equivalent op (except fo' dem embedded up in a scope contained entirely
within tha statement).
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree (most likely null) is returned anyway.  Da error is reflected in
the parser state, normally resultin up in a single exception all up in tha top
level of parsin which covers all tha compilation errors dat occurred.
Some compilation errors, however, will throw a exception immediately.
.Sp
Da \fIflags\fR parameta is reserved fo' future use, n' must always
be zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_barestmt(U32 flags)
.Ve
.IP "parse_block" 8
.IX Xref "parse_block"
.IX Item "parse_block"
Parse a single complete Perl code block.  This consistz of a opening
brace, a sequence of statements, n' a cold-ass lil closin brace.  Da block
constitutes a lexical scope, so \f(CW\*(C`my\*(C'\fR variablez n' various compile-time
effects can be contained within dat shit.  It be up ta tha calla ta ensure
that tha dynamic parser state (\*(L"PL_parser\*(R" et al) is erectly set to
reflect tha source of tha code ta be parsed n' tha lexical context for
the statement.
.Sp
Da op tree representin tha code block is returned. Y'all KNOW dat shit, muthafucka!  This be always a
real op, never a null pointer n' shit.  It will normally be a \f(CW\*(C`lineseq\*(C'\fR list,
includin \f(CW\*(C`nextstate\*(C'\fR or equivalent ops.  No ops ta construct any kind
of runtime scope is included by virtue of it bein a funky-ass block.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree (most likely null) is returned anyway.  Da error is reflected in
the parser state, normally resultin up in a single exception all up in tha top
level of parsin which covers all tha compilation errors dat occurred.
Some compilation errors, however, will throw a exception immediately.
.Sp
Da \fIflags\fR parameta is reserved fo' future use, n' must always
be zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_block(U32 flags)
.Ve
.IP "parse_fullexpr" 8
.IX Xref "parse_fullexpr"
.IX Item "parse_fullexpr"
Parse a single complete Perl expression. I aint talkin' bout chicken n' gravy biatch.  This allows tha full
expression grammar, includin tha lowest-precedence operators such
as \f(CW\*(C`or\*(C'\fR.  Da expression must be followed (and thus terminated) by a
token dat a expression would normally be terminated by: end-of-file,
closin bracketin punctuation, semicolon, or one of tha keywordz that
signals a postfix expression-statement modifier n' shit.  If \fIflags\fR includes
\&\f(CW\*(C`PARSE_OPTIONAL\*(C'\fR then tha expression is optional, otherwise it is
mandatory.  It be up ta tha calla ta ensure dat tha dynamic parser
state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect tha source of
the code ta be parsed n' tha lexical context fo' tha expression.
.Sp
Da op tree representin tha expression is returned. Y'all KNOW dat shit, muthafucka!  If a optional
expression be absent, a null pointa is returned, otherwise tha pointer
will be non-null.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree is returned anyway.  Da error is reflected up in tha parser state,
normally resultin up in a single exception all up in tha top level of parsing
which covers all tha compilation errors dat occurred. Y'all KNOW dat shit, muthafucka!  Some compilation
errors, however, will throw a exception immediately.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_fullexpr(U32 flags)
.Ve
.IP "parse_fullstmt" 8
.IX Xref "parse_fullstmt"
.IX Item "parse_fullstmt"
Parse a single complete Perl statement.  This may be a aiiight imperative
statement or a thugged-out declaration dat has compile-time effect, n' may include
optionizzle labels.  It be up ta tha calla ta ensure dat tha dynamic
parser state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect tha source
of tha code ta be parsed n' tha lexical context fo' tha statement.
.Sp
Da op tree representin tha statement is returned. Y'all KNOW dat shit, muthafucka!  This may be a
null pointa if tha statement is null, fo' example if dat shiznit was actually
a subroutine definizzle (which has compile-time side effects).  If not
null, it is ghon be tha result of a \*(L"newSTATEOP\*(R" call, normally including
a \f(CW\*(C`nextstate\*(C'\fR or equivalent op.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree (most likely null) is returned anyway.  Da error is reflected in
the parser state, normally resultin up in a single exception all up in tha top
level of parsin which covers all tha compilation errors dat occurred.
Some compilation errors, however, will throw a exception immediately.
.Sp
Da \fIflags\fR parameta is reserved fo' future use, n' must always
be zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_fullstmt(U32 flags)
.Ve
.IP "parse_label" 8
.IX Xref "parse_label"
.IX Item "parse_label"
Parse a single label, possibly optional, of tha type dat may prefix a
Perl statement.  It be up ta tha calla ta ensure dat tha dynamic parser
state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect tha source of
the code ta be parsed. Y'all KNOW dat shit, muthafucka!  If \fIflags\fR includes \f(CW\*(C`PARSE_OPTIONAL\*(C'\fR then the
label is optional, otherwise it is mandatory.
.Sp
Da name of tha label is returned up in tha form of a gangbangin' fresh scalar. Shiiit, dis aint no joke.  If an
optionizzle label be absent, a null pointa is returned.
.Sp
If a error occurs up in parsing, which can only occur if tha label is
mandatory, a valid label is returned anyway.  Da error is reflected in
the parser state, normally resultin up in a single exception all up in tha top
level of parsin which covers all tha compilation errors dat occurred.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SV *    parse_label(U32 flags)
.Ve
.IP "parse_listexpr" 8
.IX Xref "parse_listexpr"
.IX Item "parse_listexpr"
Parse a Perl list expression. I aint talkin' bout chicken n' gravy biatch.  This may contain operatorz of precedence
down ta tha comma operator. Shiiit, dis aint no joke.  Da expression must be followed (and thus
terminated) either by a low-precedence logic operator like fuckin \f(CW\*(C`or\*(C'\fR or by
suttin' dat would normally terminizzle a expression like fuckin semicolon.
If \fIflags\fR includes \f(CW\*(C`PARSE_OPTIONAL\*(C'\fR then tha expression is optional,
otherwise it is mandatory.  It be up ta tha calla ta ensure dat the
dynamic parser state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect
the source of tha code ta be parsed n' tha lexical context fo' the
expression.
.Sp
Da op tree representin tha expression is returned. Y'all KNOW dat shit, muthafucka!  If a optional
expression be absent, a null pointa is returned, otherwise tha pointer
will be non-null.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree is returned anyway.  Da error is reflected up in tha parser state,
normally resultin up in a single exception all up in tha top level of parsing
which covers all tha compilation errors dat occurred. Y'all KNOW dat shit, muthafucka!  Some compilation
errors, however, will throw a exception immediately.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_listexpr(U32 flags)
.Ve
.IP "parse_stmtseq" 8
.IX Xref "parse_stmtseq"
.IX Item "parse_stmtseq"
Parse a sequence of zero or mo' Perl statements, n' you can put dat on yo' toast.  These may be normal
imperatizzle statements, includin optionizzle labels, or declarations
that have compile-time effect, or any mixture thereof.  Da statement
sequence endz when a cold-ass lil closin brace or end-of-file is encountered up in a
place where a freshly smoked up statement could have validly started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It be up to
the calla ta ensure dat tha dynamic parser state (\*(L"PL_parser\*(R" et al)
is erectly set ta reflect tha source of tha code ta be parsed n' the
lexical context fo' tha statements.
.Sp
Da op tree representin tha statement sequence is returned. Y'all KNOW dat shit, muthafucka!  This may
be a null pointa if tha statements was all null, fo' example if there
were no statements or if there was only subroutine definitions (which
have compile-time side effects).  If not null, it is ghon be a \f(CW\*(C`lineseq\*(C'\fR
list, normally includin \f(CW\*(C`nextstate\*(C'\fR or equivalent ops.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree is returned anyway.  Da error is reflected up in tha parser state,
normally resultin up in a single exception all up in tha top level of parsing
which covers all tha compilation errors dat occurred. Y'all KNOW dat shit, muthafucka!  Some compilation
errors, however, will throw a exception immediately.
.Sp
Da \fIflags\fR parameta is reserved fo' future use, n' must always
be zero.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_stmtseq(U32 flags)
.Ve
.IP "parse_termexpr" 8
.IX Xref "parse_termexpr"
.IX Item "parse_termexpr"
Parse a Perl term expression. I aint talkin' bout chicken n' gravy biatch.  This may contain operatorz of precedence
down ta tha assignment operators.  Da expression must be followed (and thus
terminated) either by a cold-ass lil comma or lower-precedence operator or by
suttin' dat would normally terminizzle a expression like fuckin semicolon.
If \fIflags\fR includes \f(CW\*(C`PARSE_OPTIONAL\*(C'\fR then tha expression is optional,
otherwise it is mandatory.  It be up ta tha calla ta ensure dat the
dynamic parser state (\*(L"PL_parser\*(R" et al) is erectly set ta reflect
the source of tha code ta be parsed n' tha lexical context fo' the
expression.
.Sp
Da op tree representin tha expression is returned. Y'all KNOW dat shit, muthafucka!  If a optional
expression be absent, a null pointa is returned, otherwise tha pointer
will be non-null.
.Sp
If a error occurs up in parsin or compilation, up in most cases a valid op
tree is returned anyway.  Da error is reflected up in tha parser state,
normally resultin up in a single exception all up in tha top level of parsing
which covers all tha compilation errors dat occurred. Y'all KNOW dat shit, muthafucka!  Some compilation
errors, however, will throw a exception immediately.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    parse_termexpr(U32 flags)
.Ve
.IP "PL_parser" 8
.IX Xref "PL_parser"
.IX Item "PL_parser"
Pointa ta a structure encapsulatin tha state of tha parsin operation
currently up in progress.  Da pointa can be locally chizzled ta perform
a nested parse without interferin wit tha state of a outa parse.
Individual thugz of \f(CW\*(C`PL_parser\*(C'\fR have they own documentation.
.IP "PL_parser\->bufend" 8
.IX Xref "PL_parser->bufend"
.IX Item "PL_parser->bufend"
Direct pointa ta tha end of tha chunk of text currently bein lexed, the
end of tha lexer buffer n' shit.  This is equal ta \f(CW\*(C`SvPVX(PL_parser\->linestr)
+ SvCUR(PL_parser\->linestr)\*(C'\fR.  A \s-1NUL\s0 characta (zero octet) is
always located all up in tha end of tha buffer, n' do not count as part of
the bufferz contents.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.IP "PL_parser\->bufptr" 8
.IX Xref "PL_parser->bufptr"
.IX Item "PL_parser->bufptr"
Points ta tha current posizzle of lexin inside tha lexer buffer.
Charactas round dis point may be freely examined, within
the range delimited by \f(CW\*(C`SvPVX("PL_parser\->linestr")\*(C'\fR and
\&\*(L"PL_parser\->bufend\*(R".  Da octetz of tha buffer may be intended ta be
interpreted as either \s-1UTF\-8\s0 or Latin\-1, as indicated by \*(L"lex_bufutf8\*(R".
.Sp
Lexin code (whether up in tha Perl core or not) moves dis pointa past
the charactas dat it consumes.  It be also sposed ta fuckin big-ass up some
bookkeepin whenever a newline characta is consumed. Y'all KNOW dat shit, muthafucka!  This movement
can be mo' conveniently performed by tha function \*(L"lex_read_to\*(R",
which handlez newlines appropriately.
.Sp
Interpretation of tha bufferz octets can be abstracted up by
usin tha slightly higher-level functions \*(L"lex_peek_unichar\*(R" and
\&\*(L"lex_read_unichar\*(R".
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.IP "PL_parser\->linestart" 8
.IX Xref "PL_parser->linestart"
.IX Item "PL_parser->linestart"
Points ta tha start of tha current line inside tha lexer buffer.
This is useful fo' indicatin at which column a error occurred, and
not much else.  This must be updated by any lexin code dat consumes
a newline; tha function \*(L"lex_read_to\*(R" handlez dis detail.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.IP "PL_parser\->linestr" 8
.IX Xref "PL_parser->linestr"
.IX Item "PL_parser->linestr"
Buffer scalar containin tha chunk currently under consideration of the
text currently bein lexed. Y'all KNOW dat shit, muthafucka!  This be always a plain strang scalar (for
which \f(CW\*(C`SvPOK\*(C'\fR is true).  It aint intended ta be used as a scalar by
normal scalar means; instead refer ta tha buffer directly by tha pointer
variablez busted lyrics bout below.
.Sp
Da lexer maintains various \f(CW\*(C`char*\*(C'\fR pointas ta thangs up in the
\&\f(CW\*(C`PL_parser\->linestr\*(C'\fR buffer n' shit.  If \f(CW\*(C`PL_parser\->linestr\*(C'\fR is ever
reallocated, all of these pointas must be updated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Don't attempt to
do dis manually yo, but rather use \*(L"lex_grow_linestr\*(R" if you need to
reallocate tha buffer.
.Sp
Da content of tha text chunk up in tha buffer is commonly exactly one
complete line of input, up ta n' includin a newline terminator,
but there be thangs where it is otherwise.  Da octetz of the
buffer may be intended ta be interpreted as either \s-1UTF\-8\s0 or Latin\-1.
Da function \*(L"lex_bufutf8\*(R"  drops some lyrics ta you which.  Do not use tha \f(CW\*(C`SvUTF8\*(C'\fR
flag on dis scalar, which may disagree wit dat shit.
.Sp
For direct examination of tha buffer, tha variable
\&\*(L"PL_parser\->bufend\*(R" points ta tha end of tha buffer n' shit.  Da current
lexin posizzle is pointed ta by \*(L"PL_parser\->bufptr\*(R".  Direct use
of these pointas is probably preferable ta examination of tha scalar
all up in aiiight scalar means.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.SH "Magical Functions"
.IX Header "Magical Functions"
.IP "mg_clear" 8
.IX Xref "mg_clear"
.IX Item "mg_clear"
Clear suttin' magical dat tha \s-1SV\s0 represents, n' you can put dat on yo' toast.  See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        int     mg_clear(SV* sv)
.Ve
.IP "mg_copy" 8
.IX Xref "mg_copy"
.IX Item "mg_copy"
Copies tha magic from one \s-1SV\s0 ta another n' shit.  See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 2
\&        int     mg_copy(SV *sv, SV *nsv, const char *key,
\&                        I32 klen)
.Ve
.IP "mg_find" 8
.IX Xref "mg_find"
.IX Item "mg_find"
Findz tha magic pointa fo' type matchin tha \s-1SV. \s0 See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        MAGIC*  mg_find(const SV* sv, int type)
.Ve
.IP "mg_findext" 8
.IX Xref "mg_findext"
.IX Item "mg_findext"
Findz tha magic pointa of \f(CW\*(C`type\*(C'\fR wit tha given \f(CW\*(C`vtbl\*(C'\fR fo' tha \f(CW\*(C`SV\*(C'\fR.  See
\&\f(CW\*(C`sv_magicext\*(C'\fR.
.Sp
.Vb 2
\&        MAGIC*  mg_findext(const SV* sv, int type,
\&                           const MGVTBL *vtbl)
.Ve
.IP "mg_free" 8
.IX Xref "mg_free"
.IX Item "mg_free"
Jacked any magic storage used by tha \s-1SV. \s0 See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        int     mg_free(SV* sv)
.Ve
.IP "mg_free_type" 8
.IX Xref "mg_free_type"
.IX Item "mg_free_type"
Remove any magic of type \fIhow\fR from tha \s-1SV \s0\fIsv\fR.  See \*(L"sv_magic\*(R".
.Sp
.Vb 1
\&        void    mg_free_type(SV *sv, int how)
.Ve
.IP "mg_get" 8
.IX Xref "mg_get"
.IX Item "mg_get"
Do magic before a value is retrieved from tha \s-1SV. \s0 Da type of \s-1SV\s0 must
be >= SVt_PVMG. Right back up in yo muthafuckin ass. See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        int     mg_get(SV* sv)
.Ve
.IP "mg_length" 8
.IX Xref "mg_length"
.IX Item "mg_length"
This function is deprecated.
.Sp
It reports on tha \s-1SV\s0z length up in bytes, callin length magic if available,
but do not set tha \s-1UTF8\s0 flag on tha sv.  It will fall back ta 'get'
magic if there is no 'length' magic yo, but wit no indication as to
whether it called 'get' magic.  It assumes tha sv be a \s-1PVMG\s0 or
higher n' shit.  Use \fIsv_len()\fR instead.
.Sp
.Vb 1
\&        U32     mg_length(SV* sv)
.Ve
.IP "mg_magical" 8
.IX Xref "mg_magical"
.IX Item "mg_magical"
Turns on tha magical statuz of a \s-1SV. \s0 See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        void    mg_magical(SV* sv)
.Ve
.IP "mg_set" 8
.IX Xref "mg_set"
.IX Item "mg_set"
Do magic afta a value be assigned ta tha \s-1SV. \s0 See \f(CW\*(C`sv_magic\*(C'\fR.
.Sp
.Vb 1
\&        int     mg_set(SV* sv)
.Ve
.IP "SvGETMAGIC" 8
.IX Xref "SvGETMAGIC"
.IX Item "SvGETMAGIC"
Invokes \f(CW\*(C`mg_get\*(C'\fR on a \s-1SV\s0 if it has 'get' magic.  For example, this
will call \f(CW\*(C`FETCH\*(C'\fR on a tied variable.  This macro evaluates its
argument mo' than once.
.Sp
.Vb 1
\&        void    SvGETMAGIC(SV* sv)
.Ve
.IP "SvLOCK" 8
.IX Xref "SvLOCK"
.IX Item "SvLOCK"
Arranges fo' a mutual exclusion lock ta be obtained on sv if a suitable module
has been loaded.
.Sp
.Vb 1
\&        void    SvLOCK(SV* sv)
.Ve
.IP "SvSETMAGIC" 8
.IX Xref "SvSETMAGIC"
.IX Item "SvSETMAGIC"
Invokes \f(CW\*(C`mg_set\*(C'\fR on a \s-1SV\s0 if it has 'set' magic.  This is necessary
afta modifyin a scalar, up in case it aint nuthin but a magical variable like \f(CW$|\fR
or a tied variable (it calls \f(CW\*(C`STORE\*(C'\fR).  This macro evaluates its
argument mo' than once.
.Sp
.Vb 1
\&        void    SvSETMAGIC(SV* sv)
.Ve
.IP "SvSetMagicSV" 8
.IX Xref "SvSetMagicSV"
.IX Item "SvSetMagicSV"
Like \f(CW\*(C`SvSetSV\*(C'\fR yo, but do any set magic required afterwards.
.Sp
.Vb 1
\&        void    SvSetMagicSV(SV* dsb, SV* ssv)
.Ve
.IP "SvSetMagicSV_nosteal" 8
.IX Xref "SvSetMagicSV_nosteal"
.IX Item "SvSetMagicSV_nosteal"
Like \f(CW\*(C`SvSetSV_nosteal\*(C'\fR yo, but do any set magic required afterwards.
.Sp
.Vb 1
\&        void    SvSetMagicSV_nosteal(SV* dsv, SV* ssv)
.Ve
.IP "SvSetSV" 8
.IX Xref "SvSetSV"
.IX Item "SvSetSV"
Calls \f(CW\*(C`sv_setsv\*(C'\fR if dsv aint tha same as ssv.  May evaluate arguments
more than once.
.Sp
.Vb 1
\&        void    SvSetSV(SV* dsb, SV* ssv)
.Ve
.IP "SvSetSV_nosteal" 8
.IX Xref "SvSetSV_nosteal"
.IX Item "SvSetSV_nosteal"
Calls a non-destructizzle version of \f(CW\*(C`sv_setsv\*(C'\fR if dsv aint tha same as
ssv.  May evaluate arguments mo' than once.
.Sp
.Vb 1
\&        void    SvSetSV_nosteal(SV* dsv, SV* ssv)
.Ve
.IP "SvSHARE" 8
.IX Xref "SvSHARE"
.IX Item "SvSHARE"
Arranges fo' sv ta be shared between threadz if a suitable module
has been loaded.
.Sp
.Vb 1
\&        void    SvSHARE(SV* sv)
.Ve
.IP "SvUNLOCK" 8
.IX Xref "SvUNLOCK"
.IX Item "SvUNLOCK"
Releases a mutual exclusion lock on sv if a suitable module
has been loaded.
.Sp
.Vb 1
\&        void    SvUNLOCK(SV* sv)
.Ve
.SH "Memory Management"
.IX Header "Memory Management"
.IP "Copy" 8
.IX Xref "Copy"
.IX Item "Copy"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`memcpy\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`src\*(C'\fR is the
source, \f(CW\*(C`dest\*(C'\fR is tha destination, \f(CW\*(C`nitems\*(C'\fR is tha number of items, and
\&\f(CW\*(C`type\*(C'\fR is tha type.  May fail on overlappin copies. Put ya muthafuckin choppers up if ya feel dis!  See also \f(CW\*(C`Move\*(C'\fR.
.Sp
.Vb 1
\&        void    Copy(void* src, void* dest, int nitems, type)
.Ve
.IP "CopyD" 8
.IX Xref "CopyD"
.IX Item "CopyD"
Like \f(CW\*(C`Copy\*(C'\fR but returns dest. Useful fo' encouragin compilaz ta tail-call
optimise.
.Sp
.Vb 1
\&        void *  CopyD(void* src, void* dest, int nitems, type)
.Ve
.IP "Move" 8
.IX Xref "Move"
.IX Item "Move"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`memmove\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`src\*(C'\fR is the
source, \f(CW\*(C`dest\*(C'\fR is tha destination, \f(CW\*(C`nitems\*(C'\fR is tha number of items, and
\&\f(CW\*(C`type\*(C'\fR is tha type.  Can do overlappin moves.  See also \f(CW\*(C`Copy\*(C'\fR.
.Sp
.Vb 1
\&        void    Move(void* src, void* dest, int nitems, type)
.Ve
.IP "MoveD" 8
.IX Xref "MoveD"
.IX Item "MoveD"
Like \f(CW\*(C`Move\*(C'\fR but returns dest. Useful fo' encouragin compilaz ta tail-call
optimise.
.Sp
.Vb 1
\&        void *  MoveD(void* src, void* dest, int nitems, type)
.Ve
.IP "Newx" 8
.IX Xref "Newx"
.IX Item "Newx"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`malloc\*(C'\fR function.
.Sp
In 5.9.3, \fINewx()\fR n' playaz replace tha olda \fINew()\fR \s-1API,\s0 n' drops
the first parameter, \fIx\fR, a thugged-out debug aid which allowed callaz ta identify
themselves.  This aid has been superseded by a freshly smoked up build option,
\&\s-1PERL_MEM_LOG \s0(see \*(L"\s-1PERL_MEM_LOG\*(R"\s0 up in perlhacktips).  Da olda \s-1API\s0 is still
there fo' use up in \s-1XS\s0 modulez supportin olda perls.
.Sp
.Vb 1
\&        void    Newx(void* ptr, int nitems, type)
.Ve
.IP "Newxc" 8
.IX Xref "Newxc"
.IX Item "Newxc"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`malloc\*(C'\fR function, with
cast.  See also \f(CW\*(C`Newx\*(C'\fR.
.Sp
.Vb 1
\&        void    Newxc(void* ptr, int nitems, type, cast)
.Ve
.IP "Newxz" 8
.IX Xref "Newxz"
.IX Item "Newxz"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`malloc\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Da allocated
memory is zeroed wit \f(CW\*(C`memzero\*(C'\fR.  See also \f(CW\*(C`Newx\*(C'\fR.
.Sp
.Vb 1
\&        void    Newxz(void* ptr, int nitems, type)
.Ve
.IP "Poison" 8
.IX Xref "Poison"
.IX Item "Poison"
PoisonWith(0xEF) fo' catchin access ta freed memory.
.Sp
.Vb 1
\&        void    Poison(void* dest, int nitems, type)
.Ve
.IP "PoisonFree" 8
.IX Xref "PoisonFree"
.IX Item "PoisonFree"
PoisonWith(0xEF) fo' catchin access ta freed memory.
.Sp
.Vb 1
\&        void    PoisonFree(void* dest, int nitems, type)
.Ve
.IP "PoisonNew" 8
.IX Xref "PoisonNew"
.IX Item "PoisonNew"
PoisonWith(0xAB) fo' catchin access ta allocated but uninitialized memory.
.Sp
.Vb 1
\&        void    PoisonNew(void* dest, int nitems, type)
.Ve
.IP "PoisonWith" 8
.IX Xref "PoisonWith"
.IX Item "PoisonWith"
Fill up memory wit a funky-ass byte pattern (a byte repeated over n' over
again) dat hopefully catches attempts ta access uninitialized memory.
.Sp
.Vb 2
\&        void    PoisonWith(void* dest, int nitems, type,
\&                           U8 byte)
.Ve
.IP "Renew" 8
.IX Xref "Renew"
.IX Item "Renew"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`realloc\*(C'\fR function.
.Sp
.Vb 1
\&        void    Renew(void* ptr, int nitems, type)
.Ve
.IP "Renewc" 8
.IX Xref "Renewc"
.IX Item "Renewc"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`realloc\*(C'\fR function, with
cast.
.Sp
.Vb 1
\&        void    Renewc(void* ptr, int nitems, type, cast)
.Ve
.IP "Safefree" 8
.IX Xref "Safefree"
.IX Item "Safefree"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`free\*(C'\fR function.
.Sp
.Vb 1
\&        void    Safefree(void* ptr)
.Ve
.IP "savepv" 8
.IX Xref "savepv"
.IX Item "savepv"
Perlz version of \f(CW\*(C`strdup()\*(C'\fR. Returns a pointa ta a newly allocated
strin which be a thugged-out duplicate of \f(CW\*(C`pv\*(C'\fR. Da size of tha strang is
determined by \f(CW\*(C`strlen()\*(C'\fR. Da memory allocated fo' tha freshly smoked up strang can
be freed wit tha \f(CW\*(C`Safefree()\*(C'\fR function.
.Sp
.Vb 1
\&        char*   savepv(const char* pv)
.Ve
.IP "savepvn" 8
.IX Xref "savepvn"
.IX Item "savepvn"
Perlz version of what tha fuck \f(CW\*(C`strndup()\*(C'\fR would be if it existed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Returns a
pointa ta a newly allocated strang which be a thugged-out duplicate of tha first
\&\f(CW\*(C`len\*(C'\fR bytes from \f(CW\*(C`pv\*(C'\fR, plus a trailin \s-1NUL\s0 byte. Da memory allocated for
the freshly smoked up strang can be freed wit tha \f(CW\*(C`Safefree()\*(C'\fR function.
.Sp
.Vb 1
\&        char*   savepvn(const char* pv, I32 len)
.Ve
.IP "savepvs" 8
.IX Xref "savepvs"
.IX Item "savepvs"
Like \f(CW\*(C`savepvn\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        char*   savepvs(const char* s)
.Ve
.IP "savesharedpv" 8
.IX Xref "savesharedpv"
.IX Item "savesharedpv"
A version of \f(CW\*(C`savepv()\*(C'\fR which allocates tha duplicate strang up in memory
which is shared between threads.
.Sp
.Vb 1
\&        char*   savesharedpv(const char* pv)
.Ve
.IP "savesharedpvn" 8
.IX Xref "savesharedpvn"
.IX Item "savesharedpvn"
A version of \f(CW\*(C`savepvn()\*(C'\fR which allocates tha duplicate strang up in memory
which is shared between threads. (With tha specific difference dat a \s-1NULL\s0
pointa aint acceptable)
.Sp
.Vb 2
\&        char*   savesharedpvn(const char *const pv,
\&                              const STRLEN len)
.Ve
.IP "savesharedpvs" 8
.IX Xref "savesharedpvs"
.IX Item "savesharedpvs"
A version of \f(CW\*(C`savepvs()\*(C'\fR which allocates tha duplicate strang up in memory
which is shared between threads.
.Sp
.Vb 1
\&        char*   savesharedpvs(const char* s)
.Ve
.IP "savesharedsvpv" 8
.IX Xref "savesharedsvpv"
.IX Item "savesharedsvpv"
A version of \f(CW\*(C`savesharedpv()\*(C'\fR which allocates tha duplicate strang in
memory which is shared between threads.
.Sp
.Vb 1
\&        char*   savesharedsvpv(SV *sv)
.Ve
.IP "savesvpv" 8
.IX Xref "savesvpv"
.IX Item "savesvpv"
A version of \f(CW\*(C`savepv()\*(C'\fR/\f(CW\*(C`savepvn()\*(C'\fR which gets tha strang ta duplicate from
the passed up in \s-1SV\s0 rockin \f(CW\*(C`SvPV()\*(C'\fR
.Sp
.Vb 1
\&        char*   savesvpv(SV* sv)
.Ve
.IP "StructCopy" 8
.IX Xref "StructCopy"
.IX Item "StructCopy"
This be a architecture-independent macro ta copy one structure ta another.
.Sp
.Vb 1
\&        void    StructCopy(type *src, type *dest, type)
.Ve
.IP "Zero" 8
.IX Xref "Zero"
.IX Item "Zero"
Da XSUB-writerz intercourse ta tha C \f(CW\*(C`memzero\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`dest\*(C'\fR is the
destination, \f(CW\*(C`nitems\*(C'\fR is tha number of items, n' \f(CW\*(C`type\*(C'\fR is tha type.
.Sp
.Vb 1
\&        void    Zero(void* dest, int nitems, type)
.Ve
.IP "ZeroD" 8
.IX Xref "ZeroD"
.IX Item "ZeroD"
Like \f(CW\*(C`Zero\*(C'\fR but returns dest. Useful fo' encouragin compilaz ta tail-call
optimise.
.Sp
.Vb 1
\&        void *  ZeroD(void* dest, int nitems, type)
.Ve
.SH "Miscellaneous Functions"
.IX Header "Miscellaneous Functions"
.IP "fbm_compile" 8
.IX Xref "fbm_compile"
.IX Item "fbm_compile"
Analyses tha strang up in order ta make fast searches on it rockin \fIfbm_instr()\fR
\&\*(-- tha Boyer-Moore algorithm.
.Sp
.Vb 1
\&        void    fbm_compile(SV* sv, U32 flags)
.Ve
.IP "fbm_instr" 8
.IX Xref "fbm_instr"
.IX Item "fbm_instr"
Returns tha location of tha \s-1SV\s0 up in tha strang delimited by \f(CW\*(C`big\*(C'\fR and
\&\f(CW\*(C`bigend\*(C'\fR.  It returns \f(CW\*(C`NULL\*(C'\fR if tha strang can't be found. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`sv\*(C'\fR
does not gotta be fbm_compiled yo, but tha search aint gonna be as fast
then.
.Sp
.Vb 3
\&        char*   fbm_instr(unsigned char* big,
\&                          unsigned char* bigend, SV* lilstr,
\&                          U32 flags)
.Ve
.IP "foldEQ" 8
.IX Xref "foldEQ"
.IX Item "foldEQ"
Returns legit if tha leadin len bytez of tha strings s1 n' s2 is tha same
case-insensitively; false otherwise.  Uppercase n' lowercase \s-1ASCII\s0 range bytes
match theyselves n' they opposite case counterparts, n' you can put dat on yo' toast.  Non-cased n' non-ASCII
range bytes match only theyselves.
.Sp
.Vb 1
\&        I32     foldEQ(const char* a, const char* b, I32 len)
.Ve
.IP "foldEQ_locale" 8
.IX Xref "foldEQ_locale"
.IX Item "foldEQ_locale"
Returns legit if tha leadin len bytez of tha strings s1 n' s2 is tha same
case-insensitively up in tha current locale; false otherwise.
.Sp
.Vb 2
\&        I32     foldEQ_locale(const char* a, const char* b,
\&                              I32 len)
.Ve
.IP "form" 8
.IX Xref "form"
.IX Item "form"
Takes a sprintf-style format pattern n' conventional
(non-SV) arguments n' returns tha formatted string.
.Sp
.Vb 1
\&    (char *) Perl_form(pTHX_ const char* pat, ...)
.Ve
.Sp
can be used any place a strang (char *) is required:
.Sp
.Vb 1
\&    char * s = Perl_form("%d.%d",major,minor);
.Ve
.Sp
Uses a single private buffer so if you wanna format nuff muthafuckin strings you
must explicitly copy tha earlier strings away (and free tha copies when you
are done).
.Sp
.Vb 1
\&        char*   form(const char* pat, ...)
.Ve
.IP "getcwd_sv" 8
.IX Xref "getcwd_sv"
.IX Item "getcwd_sv"
Fill tha sv wit current hustlin directory
.Sp
.Vb 1
\&        int     getcwd_sv(SV* sv)
.Ve
.IP "mess" 8
.IX Xref "mess"
.IX Item "mess"
Take a sprintf-style format pattern n' argument list.  These is used to
generate a strang message.  If tha message do not end wit a newline,
then it is ghon be extended wit some indication of tha current location
in tha code, as busted lyrics bout fo' \*(L"mess_sv\*(R".
.Sp
Normally, tha resultin message is returned up in a freshly smoked up mortal \s-1SV.\s0
Durin global destruction a single \s-1SV\s0 may be shared between uses of
this function.
.Sp
.Vb 1
\&        SV *    mess(const char *pat, ...)
.Ve
.IP "mess_sv" 8
.IX Xref "mess_sv"
.IX Item "mess_sv"
Expandz a message, intended fo' tha user, ta include a indication of
the current location up in tha code, if tha message do not already appear
to be complete.
.Sp
\&\f(CW\*(C`basemsg\*(C'\fR is tha initial message or object.  If it aint nuthin but a reference, it
will be used as-is n' is ghon be tha result of dis function. I aint talkin' bout chicken n' gravy biatch.  Otherwise it
is used as a string, n' if it already endz wit a newline, it is taken
to be complete, n' tha result of dis function is ghon be tha same string.
If tha message do not end wit a newline, then a segment like fuckin \f(CW\*(C`at
foo.pl line 37\*(C'\fR is ghon be appended, n' possibly other clauses indicating
the current state of execution. I aint talkin' bout chicken n' gravy biatch.  Da resultin message will end wit a
dot n' a newline.
.Sp
Normally, tha resultin message is returned up in a freshly smoked up mortal \s-1SV.\s0
Durin global destruction a single \s-1SV\s0 may be shared between usez of this
function. I aint talkin' bout chicken n' gravy biatch.  If \f(CW\*(C`consume\*(C'\fR is true, then tha function is permitted (but not
required) ta modify n' return \f(CW\*(C`basemsg\*(C'\fR instead of allocatin a freshly smoked up \s-1SV.\s0
.Sp
.Vb 1
\&        SV *    mess_sv(SV *basemsg, bool consume)
.Ve
.IP "my_snprintf" 8
.IX Xref "my_snprintf"
.IX Item "my_snprintf"
Da C library \f(CW\*(C`snprintf\*(C'\fR functionality, if available and
standards-compliant (uses \f(CW\*(C`vsnprintf\*(C'\fR, actually).  But fuck dat shiznit yo, tha word on tha street is dat if the
\&\f(CW\*(C`vsnprintf\*(C'\fR aint available, will unfortunately use tha unsafe
\&\f(CW\*(C`vsprintf\*(C'\fR which can overrun tha buffer (there be a overrun check,
but dat may be too late).  Consider rockin \f(CW\*(C`sv_vcatpvf\*(C'\fR instead, or
gettin \f(CW\*(C`vsnprintf\*(C'\fR.
.Sp
.Vb 2
\&        int     my_snprintf(char *buffer, const Size_t len,
\&                            const char *format, ...)
.Ve
.IP "my_sprintf" 8
.IX Xref "my_sprintf"
.IX Item "my_sprintf"
Da C library \f(CW\*(C`sprintf\*(C'\fR, wrapped if necessary, ta ensure dat it will return
the length of tha strang freestyled ta tha buffer n' shit. Only rare pre-ANSI systems
need tha wrapper function \- probably dis be a gangbangin' finger-lickin' direct call ta \f(CW\*(C`sprintf\*(C'\fR.
.Sp
.Vb 1
\&        int     my_sprintf(char *buffer, const char *pat, ...)
.Ve
.IP "my_vsnprintf" 8
.IX Xref "my_vsnprintf"
.IX Item "my_vsnprintf"
Da C library \f(CW\*(C`vsnprintf\*(C'\fR if available n' standards-compliant.
But fuck dat shiznit yo, tha word on tha street is dat if if tha \f(CW\*(C`vsnprintf\*(C'\fR aint available, will unfortunately
use tha unsafe \f(CW\*(C`vsprintf\*(C'\fR which can overrun tha buffer (there be an
overrun check yo, but dat may be too late).  Consider using
\&\f(CW\*(C`sv_vcatpvf\*(C'\fR instead, or gettin \f(CW\*(C`vsnprintf\*(C'\fR.
.Sp
.Vb 2
\&        int     my_vsnprintf(char *buffer, const Size_t len,
\&                             const char *format, va_list ap)
.Ve
.IP "new_version" 8
.IX Xref "new_version"
.IX Item "new_version"
Returns a freshly smoked up version object based on tha passed up in \s-1SV:\s0
.Sp
.Vb 1
\&    SV *sv = new_version(SV *ver);
.Ve
.Sp
Do not alta tha passed up in ver \s-1SV. \s0 See \*(L"upg_version\*(R" if you
wanna upgrade tha \s-1SV.\s0
.Sp
.Vb 1
\&        SV*     new_version(SV *ver)
.Ve
.IP "prescan_version" 8
.IX Xref "prescan_version"
.IX Item "prescan_version"
Validate dat a given strang can be parsed as a version object yo, but don't
actually big-ass up tha parsing.  Can use either strict or lax validation rules.
Can optionally set a fuckin shitload of hint variablez ta save tha parsin code
some time when tokenizing.
.Sp
.Vb 5
\&        const char* prescan_version(const char *s, bool strict,
\&                                    const char** errstr,
\&                                    bool *sqv,
\&                                    int *ssaw_decimal,
\&                                    int *swidth, bool *salpha)
.Ve
.IP "\s-1READ_XDIGIT \s0" 8
.IX Xref "READ_XDIGIT"
.IX Item "READ_XDIGIT "
Returns tha value of a ASCII-range hex digit n' advances tha strang pointer.
Behaviour is only well defined when isXDIGIT(*str) is true.
.Sp
.Vb 1
\&        U8      READ_XDIGIT(char str*)
.Ve
.IP "scan_version" 8
.IX Xref "scan_version"
.IX Item "scan_version"
Returns a pointa ta tha next characta afta tha parsed
version string, as well as upgradin tha passed up in \s-1SV\s0 to
an \s-1RV.\s0
.Sp
Function must be called wit a already existin \s-1SV\s0 like
.Sp
.Vb 2
\&    sv = newSV(0);
\&    s = scan_version(s, SV *sv, bool qv);
.Ve
.Sp
Performs some preprocessin ta tha strang ta ensure that
it has tha erect characteristics of a version. I aint talkin' bout chicken n' gravy biatch.  Flags the
object if it gotz nuff a underscore (which denotes this
is a alpha version).  Da boolean qv denotes dat tha version
should be interpreted as if it had multiple decimals, even if
it don't.
.Sp
.Vb 1
\&        const char* scan_version(const char *s, SV *rv, bool qv)
.Ve
.IP "strEQ" 8
.IX Xref "strEQ"
.IX Item "strEQ"
Test two strings ta peep if they is equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Returns legit or false.
.Sp
.Vb 1
\&        bool    strEQ(char* s1, char* s2)
.Ve
.IP "strGE" 8
.IX Xref "strGE"
.IX Item "strGE"
Test two strings ta peep if tha first, \f(CW\*(C`s1\*(C'\fR, is pimped outa than or equal to
the second, \f(CW\*(C`s2\*(C'\fR.  Returns legit or false.
.Sp
.Vb 1
\&        bool    strGE(char* s1, char* s2)
.Ve
.IP "strGT" 8
.IX Xref "strGT"
.IX Item "strGT"
Test two strings ta peep if tha first, \f(CW\*(C`s1\*(C'\fR, is pimped outa than tha second,
\&\f(CW\*(C`s2\*(C'\fR.  Returns legit or false.
.Sp
.Vb 1
\&        bool    strGT(char* s1, char* s2)
.Ve
.IP "strLE" 8
.IX Xref "strLE"
.IX Item "strLE"
Test two strings ta peep if tha first, \f(CW\*(C`s1\*(C'\fR, is less than or equal ta the
second, \f(CW\*(C`s2\*(C'\fR.  Returns legit or false.
.Sp
.Vb 1
\&        bool    strLE(char* s1, char* s2)
.Ve
.IP "strLT" 8
.IX Xref "strLT"
.IX Item "strLT"
Test two strings ta peep if tha first, \f(CW\*(C`s1\*(C'\fR, is less than tha second,
\&\f(CW\*(C`s2\*(C'\fR.  Returns legit or false.
.Sp
.Vb 1
\&        bool    strLT(char* s1, char* s2)
.Ve
.IP "strNE" 8
.IX Xref "strNE"
.IX Item "strNE"
Test two strings ta peep if they is different.  Returns legit or
false.
.Sp
.Vb 1
\&        bool    strNE(char* s1, char* s2)
.Ve
.IP "strnEQ" 8
.IX Xref "strnEQ"
.IX Item "strnEQ"
Test two strings ta peep if they is equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da \f(CW\*(C`len\*(C'\fR parameta indicates
the number of bytes ta compare.  Returns legit or false. (A wrapper for
\&\f(CW\*(C`strncmp\*(C'\fR).
.Sp
.Vb 1
\&        bool    strnEQ(char* s1, char* s2, STRLEN len)
.Ve
.IP "strnNE" 8
.IX Xref "strnNE"
.IX Item "strnNE"
Test two strings ta peep if they is different.  Da \f(CW\*(C`len\*(C'\fR parameter
indicates tha number of bytes ta compare.  Returns legit or false. (A
wrapper fo' \f(CW\*(C`strncmp\*(C'\fR).
.Sp
.Vb 1
\&        bool    strnNE(char* s1, char* s2, STRLEN len)
.Ve
.IP "sv_destroyable" 8
.IX Xref "sv_destroyable"
.IX Item "sv_destroyable"
Dummy routine which reports dat object can be destroyed when there is no
sharin module present.  It ignores its single \s-1SV\s0 argument, n' returns
\&'true'.  Exists ta avoid test fo' a \s-1NULL\s0 function pointa n' cuz it
could potentially warn under some level of strict-ness.
.Sp
.Vb 1
\&        bool    sv_destroyable(SV *sv)
.Ve
.IP "sv_nosharing" 8
.IX Xref "sv_nosharing"
.IX Item "sv_nosharing"
Dummy routine which \*(L"shares\*(R" a \s-1SV\s0 when there is no pluggin module present.
Or \*(L"locks\*(R" dat shit. Or \*(L"unlocks\*(R" dat shit. In other lyrics, ignores its single \s-1SV\s0 argument.
Exists ta avoid test fo' a \s-1NULL\s0 function pointa n' cuz it could
potentially warn under some level of strict-ness.
.Sp
.Vb 1
\&        void    sv_nosharing(SV *sv)
.Ve
.IP "upg_version" 8
.IX Xref "upg_version"
.IX Item "upg_version"
In-place upgrade of tha supplied \s-1SV\s0 ta a version object.
.Sp
.Vb 1
\&    SV *sv = upg_version(SV *sv, bool qv);
.Ve
.Sp
Returns a pointa ta tha upgraded \s-1SV. \s0 Set tha boolean qv if you want
to force dis \s-1SV\s0 ta be interpreted as a \*(L"extended\*(R" version.
.Sp
.Vb 1
\&        SV*     upg_version(SV *ver, bool qv)
.Ve
.IP "vcmp" 8
.IX Xref "vcmp"
.IX Item "vcmp"
Version object aware cmp.  Both operandz must already done been 
converted tha fuck into version objects.
.Sp
.Vb 1
\&        int     vcmp(SV *lhv, SV *rhv)
.Ve
.IP "vmess" 8
.IX Xref "vmess"
.IX Item "vmess"
\&\f(CW\*(C`pat\*(C'\fR n' \f(CW\*(C`args\*(C'\fR is a sprintf-style format pattern n' encapsulated
argument list.  These is used ta generate a strang message.  If the
message do not end wit a newline, then it is ghon be extended with
some indication of tha current location up in tha code, as busted lyrics bout for
\&\*(L"mess_sv\*(R".
.Sp
Normally, tha resultin message is returned up in a freshly smoked up mortal \s-1SV.\s0
Durin global destruction a single \s-1SV\s0 may be shared between uses of
this function.
.Sp
.Vb 1
\&        SV *    vmess(const char *pat, va_list *args)
.Ve
.IP "vnormal" 8
.IX Xref "vnormal"
.IX Item "vnormal"
Accepts a version object n' returns tha normalized string
representation. I aint talkin' bout chicken n' gravy biatch.  Call like:
.Sp
.Vb 1
\&    sv = vnormal(rv);
.Ve
.Sp
\&\s-1NOTE:\s0 you can pass either tha object directly or tha \s-1SV\s0
contained within tha \s-1RV.\s0
.Sp
Da \s-1SV\s0 returned has a refcount of 1.
.Sp
.Vb 1
\&        SV*     vnormal(SV *vs)
.Ve
.IP "vnumify" 8
.IX Xref "vnumify"
.IX Item "vnumify"
Accepts a version object n' returns tha normalized floating
point representation. I aint talkin' bout chicken n' gravy biatch.  Call like:
.Sp
.Vb 1
\&    sv = vnumify(rv);
.Ve
.Sp
\&\s-1NOTE:\s0 you can pass either tha object directly or tha \s-1SV\s0
contained within tha \s-1RV.\s0
.Sp
Da \s-1SV\s0 returned has a refcount of 1.
.Sp
.Vb 1
\&        SV*     vnumify(SV *vs)
.Ve
.IP "vstringify" 8
.IX Xref "vstringify"
.IX Item "vstringify"
In order ta maintain maximum compatibilitizzle wit earlier versions
of Perl, dis function will return either tha floatin point
notation or tha multiple dotted notation, dependin on whether
the original gangsta version contained 1 or mo' dots, respectively.
.Sp
Da \s-1SV\s0 returned has a refcount of 1.
.Sp
.Vb 1
\&        SV*     vstringify(SV *vs)
.Ve
.IP "vverify" 8
.IX Xref "vverify"
.IX Item "vverify"
Validates dat tha \s-1SV\s0 gotz nuff valid internal structure fo' a version object.
It may be passed either tha version object (\s-1RV\s0) or tha hash itself (\s-1HV\s0).  If
the structure is valid, it returns tha \s-1HV. \s0 If tha structure is invalid,
it returns \s-1NULL.\s0
.Sp
.Vb 1
\&    SV *hv = vverify(sv);
.Ve
.Sp
Note dat it only confirms tha bare minimum structure (so as not ta get
confused by derived classes which may contain additionizzle hash entries):
.Sp
.Vb 1
\&        SV*     vverify(SV *vs)
.Ve
.SH "MRO Functions"
.IX Header "MRO Functions"
.IP "mro_get_linear_isa" 8
.IX Xref "mro_get_linear_isa"
.IX Item "mro_get_linear_isa"
Returns tha mro linearisation fo' tha given stash.  By default, this
will be whatever \f(CW\*(C`mro_get_linear_isa_dfs\*(C'\fR returns unless some
other \s-1MRO\s0 is up in effect fo' tha stash.  Da return value be a
read-only AV*.
.Sp
Yo ass is responsible fo' \f(CW\*(C`SvREFCNT_inc()\*(C'\fR on the
return value if you plan ta store it anywhere
semi-permanently (otherwise it might be deleted
out from under you tha next time tha cache is
invalidated).
.Sp
.Vb 1
\&        AV*     mro_get_linear_isa(HV* stash)
.Ve
.IP "mro_method_changed_in" 8
.IX Xref "mro_method_changed_in"
.IX Item "mro_method_changed_in"
Invalidates method cachin on any lil pimp classes
of tha given stash, so dat they might notice
the chizzlez up in dis one.
.Sp
Ideally, all instancez of \f(CW\*(C`PL_sub_generation++\*(C'\fR in
perl source outside of \fImro.c\fR should be
replaced by calls ta all dis bullshit.
.Sp
Perl automatically handlez most of tha common
ways a method might be redefined. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat there
are all dem ways you could chizzle a method up in a stash
without tha cache code noticing, up in which case you
need ta booty-call dis method afterwards:
.Sp
1) Directly manipulatin tha stash \s-1HV\s0 entries from
\&\s-1XS\s0 code.
.Sp
2) Assignin a reference ta a readonly scalar
constant tha fuck into a stash entry up in order ta create
a constant subroutine (like constant.pm
does).
.Sp
This same method be available from pure perl
via, \f(CW\*(C`mro::method_changed_in(classname)\*(C'\fR.
.Sp
.Vb 1
\&        void    mro_method_changed_in(HV* stash)
.Ve
.IP "mro_register" 8
.IX Xref "mro_register"
.IX Item "mro_register"
Registas a cold-ass lil custom mro plugin. I aint talkin' bout chicken n' gravy biatch.  See perlmroapi fo' details.
.Sp
.Vb 1
\&        void    mro_register(const struct mro_alg *mro)
.Ve
.SH "Multicall Functions"
.IX Header "Multicall Functions"
.IP "dMULTICALL" 8
.IX Xref "dMULTICALL"
.IX Item "dMULTICALL"
Declare local variablez fo' a multicall. Right back up in yo muthafuckin ass. See \*(L"\s-1LIGHTWEIGHT CALLBACKS\*(R"\s0 up in perlcall.
.Sp
.Vb 1
\&                dMULTICALL;
.Ve
.IP "\s-1MULTICALL \s0" 8
.IX Xref "MULTICALL"
.IX Item "MULTICALL "
Make a lightweight callback. Right back up in yo muthafuckin ass. See \*(L"\s-1LIGHTWEIGHT CALLBACKS\*(R"\s0 up in perlcall.
.Sp
.Vb 1
\&                MULTICALL;
.Ve
.IP "\s-1POP_MULTICALL \s0" 8
.IX Xref "POP_MULTICALL"
.IX Item "POP_MULTICALL "
Closin bracket fo' a lightweight callback.
See \*(L"\s-1LIGHTWEIGHT CALLBACKS\*(R"\s0 up in perlcall.
.Sp
.Vb 1
\&                POP_MULTICALL;
.Ve
.IP "\s-1PUSH_MULTICALL \s0" 8
.IX Xref "PUSH_MULTICALL"
.IX Item "PUSH_MULTICALL "
Openin bracket fo' a lightweight callback.
See \*(L"\s-1LIGHTWEIGHT CALLBACKS\*(R"\s0 up in perlcall.
.Sp
.Vb 1
\&                PUSH_MULTICALL;
.Ve
.SH "Numeric functions"
.IX Header "Numeric functions"
.IP "grok_bin" 8
.IX Xref "grok_bin"
.IX Item "grok_bin"
converts a strang representin a funky-ass binary number ta numeric form.
.Sp
On entry \fIstart\fR n' \fI*len\fR give tha strang ta scan, \fI*flags\fR gives
conversion flags, n' \fIresult\fR should be \s-1NULL\s0 or a pointa ta a \s-1NV.\s0
Da scan stops all up in tha end of tha string, or tha straight-up original gangsta invalid character.
Unless \f(CW\*(C`PERL_SCAN_SILENT_ILLDIGIT\*(C'\fR is set up in \fI*flags\fR, encounterin an
invalid characta will also trigger a warning.
On return \fI*len\fR is set ta tha length of tha scanned string,
and \fI*flags\fR gives output flags.
.Sp
If tha value is <= \f(CW\*(C`UV_MAX\*(C'\fR it is returned as a \s-1UV,\s0 tha output flags is clear,
and not a god damn thang is freestyled ta \fI*result\fR. If tha value is > \s-1UV_MAX \s0\f(CW\*(C`grok_bin\*(C'\fR
returns \s-1UV_MAX,\s0 sets \f(CW\*(C`PERL_SCAN_GREATER_THAN_UV_MAX\*(C'\fR up in tha output flags,
and writes tha value ta \fI*result\fR (or tha value is discarded if \fIresult\fR
is \s-1NULL\s0).
.Sp
Da binary number may optionally be prefixed wit \*(L"0b\*(R" or \*(L"b\*(R" unless
\&\f(CW\*(C`PERL_SCAN_DISALLOW_PREFIX\*(C'\fR is set up in \fI*flags\fR on entry. If
\&\f(CW\*(C`PERL_SCAN_ALLOW_UNDERSCORES\*(C'\fR is set up in \fI*flags\fR then tha binary
number may use '_' charactas ta separate digits.
.Sp
.Vb 2
\&        UV      grok_bin(const char* start, STRLEN* len_p,
\&                         I32* flags, NV *result)
.Ve
.IP "grok_hex" 8
.IX Xref "grok_hex"
.IX Item "grok_hex"
converts a strang representin a hex number ta numeric form.
.Sp
On entry \fIstart\fR n' \fI*len\fR give tha strang ta scan, \fI*flags\fR gives
conversion flags, n' \fIresult\fR should be \s-1NULL\s0 or a pointa ta a \s-1NV.\s0
Da scan stops all up in tha end of tha string, or tha straight-up original gangsta invalid character.
Unless \f(CW\*(C`PERL_SCAN_SILENT_ILLDIGIT\*(C'\fR is set up in \fI*flags\fR, encounterin an
invalid characta will also trigger a warning.
On return \fI*len\fR is set ta tha length of tha scanned string,
and \fI*flags\fR gives output flags.
.Sp
If tha value is <= \s-1UV_MAX\s0 it is returned as a \s-1UV,\s0 tha output flags is clear,
and not a god damn thang is freestyled ta \fI*result\fR. If tha value is > \s-1UV_MAX \s0\f(CW\*(C`grok_hex\*(C'\fR
returns \s-1UV_MAX,\s0 sets \f(CW\*(C`PERL_SCAN_GREATER_THAN_UV_MAX\*(C'\fR up in tha output flags,
and writes tha value ta \fI*result\fR (or tha value is discarded if \fIresult\fR
is \s-1NULL\s0).
.Sp
Da hex number may optionally be prefixed wit \*(L"0x\*(R" or \*(L"x\*(R" unless
\&\f(CW\*(C`PERL_SCAN_DISALLOW_PREFIX\*(C'\fR is set up in \fI*flags\fR on entry. If
\&\f(CW\*(C`PERL_SCAN_ALLOW_UNDERSCORES\*(C'\fR is set up in \fI*flags\fR then tha hex
number may use '_' charactas ta separate digits.
.Sp
.Vb 2
\&        UV      grok_hex(const char* start, STRLEN* len_p,
\&                         I32* flags, NV *result)
.Ve
.IP "grok_number" 8
.IX Xref "grok_number"
.IX Item "grok_number"
Recognise (or not) a number n' shit.  Da type of tha number is returned
(0 if unrecognised), otherwise it aint nuthin but a funky-ass bit-ORed combination of
\&\s-1IS_NUMBER_IN_UV, IS_NUMBER_GREATER_THAN_UV_MAX, IS_NUMBER_NOT_INT,
IS_NUMBER_NEG, IS_NUMBER_INFINITY, IS_NUMBER_NAN \s0(defined up in perl.h).
.Sp
If tha value of tha number can fit a up in \s-1UV,\s0 it is returned up in tha *valuep
\&\s-1IS_NUMBER_IN_UV\s0 is ghon be set ta indicate dat *valuep is valid, \s-1IS_NUMBER_IN_UV\s0
will never be set unless *valuep is valid yo, but *valuep may done been assigned
to durin processin even though \s-1IS_NUMBER_IN_UV\s0 aint set on return.
If valuep is \s-1NULL, IS_NUMBER_IN_UV\s0 is ghon be set fo' tha same cases as when
valuep is non-NULL yo, but no actual assignment (or \s-1SEGV\s0) will occur.
.Sp
\&\s-1IS_NUMBER_NOT_INT\s0 is ghon be set wit \s-1IS_NUMBER_IN_UV\s0 if trailin decimals were
seen (in which case *valuep gives tha legit value truncated ta a integer), and
\&\s-1IS_NUMBER_NEG\s0 if tha number is wack (in which case *valuep holdz the
absolute value).  \s-1IS_NUMBER_IN_UV\s0 aint set if e notation was used or the
number is larger than a \s-1UV.\s0
.Sp
.Vb 2
\&        int     grok_number(const char *pv, STRLEN len,
\&                            UV *valuep)
.Ve
.IP "grok_numeric_radix" 8
.IX Xref "grok_numeric_radix"
.IX Item "grok_numeric_radix"
Scan n' skip fo' a numeric decimal separator (radix).
.Sp
.Vb 2
\&        bool    grok_numeric_radix(const char **sp,
\&                                   const char *send)
.Ve
.IP "grok_oct" 8
.IX Xref "grok_oct"
.IX Item "grok_oct"
converts a strang representin a octal number ta numeric form.
.Sp
On entry \fIstart\fR n' \fI*len\fR give tha strang ta scan, \fI*flags\fR gives
conversion flags, n' \fIresult\fR should be \s-1NULL\s0 or a pointa ta a \s-1NV.\s0
Da scan stops all up in tha end of tha string, or tha straight-up original gangsta invalid character.
Unless \f(CW\*(C`PERL_SCAN_SILENT_ILLDIGIT\*(C'\fR is set up in \fI*flags\fR, encounterin an
8 or 9 will also trigger a warning.
On return \fI*len\fR is set ta tha length of tha scanned string,
and \fI*flags\fR gives output flags.
.Sp
If tha value is <= \s-1UV_MAX\s0 it is returned as a \s-1UV,\s0 tha output flags is clear,
and not a god damn thang is freestyled ta \fI*result\fR. If tha value is > \s-1UV_MAX \s0\f(CW\*(C`grok_oct\*(C'\fR
returns \s-1UV_MAX,\s0 sets \f(CW\*(C`PERL_SCAN_GREATER_THAN_UV_MAX\*(C'\fR up in tha output flags,
and writes tha value ta \fI*result\fR (or tha value is discarded if \fIresult\fR
is \s-1NULL\s0).
.Sp
If \f(CW\*(C`PERL_SCAN_ALLOW_UNDERSCORES\*(C'\fR is set up in \fI*flags\fR then tha octal
number may use '_' charactas ta separate digits.
.Sp
.Vb 2
\&        UV      grok_oct(const char* start, STRLEN* len_p,
\&                         I32* flags, NV *result)
.Ve
.IP "Perl_signbit" 8
.IX Xref "Perl_signbit"
.IX Item "Perl_signbit"
Return a non-zero integer if tha sign bit on a \s-1NV\s0 is set, n' 0 if
it is not.
.Sp
If Configure detects dis system has a \fIsignbit()\fR dat will work with
our NVs, then our laid-back asses just use it via tha #define up in perl.h.  Otherwise,
fall back on dis implementation. I aint talkin' bout chicken n' gravy biatch.  As a gangbangin' first pass, dis gets every last muthafuckin thang
right except \-0.0.  Alas, catchin \-0.0 is tha main use fo' dis function,
so dis aint too helpful yet.  Still, at least our crazy asses have tha scaffolding
in place ta support other systems, should dat prove useful.
.Sp
Configure notes:  This function is called 'Perl_signbit' instead of a
plain 'signbit' cuz it is easy as fuck  ta imagine a system havin a \fIsignbit()\fR
function or macro dat don't happen ta work wit our particular chizzle
of NVs.  We shouldn't just re\-#define signbit as Perl_signbit n' expect
the standard system headaz ta be horny.  Also, dis be a no-context
function (no pTHX_) cuz \fIPerl_signbit()\fR is probably re\-#defined in
perl.h as a simple macro call ta tha systemz \fIsignbit()\fR.
Users should just always call \fIPerl_signbit()\fR.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        int     Perl_signbit(NV f)
.Ve
.IP "scan_bin" 8
.IX Xref "scan_bin"
.IX Item "scan_bin"
For backwardz compatibility. Use \f(CW\*(C`grok_bin\*(C'\fR instead.
.Sp
.Vb 2
\&        NV      scan_bin(const char* start, STRLEN len,
\&                         STRLEN* retlen)
.Ve
.IP "scan_hex" 8
.IX Xref "scan_hex"
.IX Item "scan_hex"
For backwardz compatibility. Use \f(CW\*(C`grok_hex\*(C'\fR instead.
.Sp
.Vb 2
\&        NV      scan_hex(const char* start, STRLEN len,
\&                         STRLEN* retlen)
.Ve
.IP "scan_oct" 8
.IX Xref "scan_oct"
.IX Item "scan_oct"
For backwardz compatibility. Use \f(CW\*(C`grok_oct\*(C'\fR instead.
.Sp
.Vb 2
\&        NV      scan_oct(const char* start, STRLEN len,
\&                         STRLEN* retlen)
.Ve
.SH "Optree construction"
.IX Header "Optree construction"
.IP "newASSIGNOP" 8
.IX Xref "newASSIGNOP"
.IX Item "newASSIGNOP"
Constructs, checks, n' returns a assignment op.  \fIleft\fR n' \fIright\fR
supply tha parametaz of tha assignment; they is consumed by this
function n' become part of tha constructed op tree.
.Sp
If \fIoptype\fR is \f(CW\*(C`OP_ANDASSIGN\*(C'\fR, \f(CW\*(C`OP_ORASSIGN\*(C'\fR, or \f(CW\*(C`OP_DORASSIGN\*(C'\fR, then
a suitable conditionizzle optree is constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIoptype\fR is tha opcode
of a funky-ass binary operator, like fuckin \f(CW\*(C`OP_BIT_OR\*(C'\fR, then a op is constructed that
performs tha binary operation n' assigns tha result ta tha left argument.
Either way, if \fIoptype\fR is non-zero then \fIflags\fR has no effect.
.Sp
If \fIoptype\fR is zero, then a plain scalar or list assignment is
constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Which type of assignment it is be automatically determined.
\&\fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except dat \f(CW\*(C`OPf_KIDS\*(C'\fR
will be set automatically, and, shifted up eight bits, tha eight bits
of \f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1 or 2 be automatically
set as required.
.Sp
.Vb 2
\&        OP *    newASSIGNOP(I32 flags, OP *left, I32 optype,
\&                            OP *right)
.Ve
.IP "newBINOP" 8
.IX Xref "newBINOP"
.IX Item "newBINOP"
Constructs, checks, n' returns a op of any binary type.  \fItype\fR
is tha opcode.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except
that \f(CW\*(C`OPf_KIDS\*(C'\fR is ghon be set automatically, and, shifted up eight bits,
the eight bitz of \f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1 or
2 be automatically set as required. Y'all KNOW dat shit, muthafucka!  \fIfirst\fR n' \fIlast\fR supply up to
two ops ta be tha direct lil pimpz of tha binary op; they is consumed
by dis function n' become part of tha constructed op tree.
.Sp
.Vb 2
\&        OP *    newBINOP(I32 type, I32 flags, OP *first,
\&                         OP *last)
.Ve
.IP "newCONDOP" 8
.IX Xref "newCONDOP"
.IX Item "newCONDOP"
Constructs, checks, n' returns a cold-ass lil conditional-expression (\f(CW\*(C`cond_expr\*(C'\fR)
op.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except dat \f(CW\*(C`OPf_KIDS\*(C'\fR
will be set automatically, and, shifted up eight bits, tha eight bits of
\&\f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1 be automatically set.
\&\fIfirst\fR supplies tha expression selectin between tha two branches,
and \fItrueop\fR n' \fIfalseop\fR supply tha branches; they is consumed by
this function n' become part of tha constructed op tree.
.Sp
.Vb 2
\&        OP *    newCONDOP(I32 flags, OP *first, OP *trueop,
\&                          OP *falseop)
.Ve
.IP "newFOROP" 8
.IX Xref "newFOROP"
.IX Item "newFOROP"
Constructs, checks, n' returns a op tree expressin a \f(CW\*(C`foreach\*(C'\fR
loop (iteration all up in a list of joints).  This be a heavyweight loop,
with structure dat allows exitin tha loop by \f(CW\*(C`last\*(C'\fR n' suchlike.
.Sp
\&\fIsv\fR optionally supplies tha variable dat is ghon be aliased ta each
item up in turn; if null, it defaults ta \f(CW$_\fR (either lexical or global).
\&\fIexpr\fR supplies tha list of joints ta iterate over n' shit.  \fIblock\fR supplies
the main body of tha loop, n' \fIcont\fR optionally supplies a \f(CW\*(C`continue\*(C'\fR
block dat operates as a second half of tha body.  All of these optree
inputs is consumed by dis function n' become part of tha constructed
op tree.
.Sp
\&\fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR fo' tha \f(CW\*(C`leaveloop\*(C'\fR
op and, shifted up eight bits, tha eight bitz of \f(CW\*(C`op_private\*(C'\fR for
the \f(CW\*(C`leaveloop\*(C'\fR op, except dat (in both cases) some bits is ghon be set
automatically.
.Sp
.Vb 2
\&        OP *    newFOROP(I32 flags, OP *sv, OP *expr, OP *block,
\&                         OP *cont)
.Ve
.IP "newGIVENOP" 8
.IX Xref "newGIVENOP"
.IX Item "newGIVENOP"
Constructs, checks, n' returns a op tree expressin a \f(CW\*(C`given\*(C'\fR block.
\&\fIcond\fR supplies tha expression dat is ghon be locally assigned ta a lexical
variable, n' \fIblock\fR supplies tha body of tha \f(CW\*(C`given\*(C'\fR construct; they
are consumed by dis function n' become part of tha constructed op tree.
\&\fIdefsv_off\fR is tha pad offset of tha scalar lexical variable dat will
be affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If it is 0, tha global \f(CW$_\fR is ghon be used.
.Sp
.Vb 2
\&        OP *    newGIVENOP(OP *cond, OP *block,
\&                           PADOFFSET defsv_off)
.Ve
.IP "newGVOP" 8
.IX Xref "newGVOP"
.IX Item "newGVOP"
Constructs, checks, n' returns a op of any type dat involves an
embedded reference ta a \s-1GV.  \s0\fItype\fR is tha opcode.  \fIflags\fR gives the
eight bitz of \f(CW\*(C`op_flags\*(C'\fR.  \fIgv\fR identifies tha \s-1GV\s0 dat tha op should
reference; callin dis function do not transfer ballershizzle of any
reference ta dat shit.
.Sp
.Vb 1
\&        OP *    newGVOP(I32 type, I32 flags, GV *gv)
.Ve
.IP "newLISTOP" 8
.IX Xref "newLISTOP"
.IX Item "newLISTOP"
Constructs, checks, n' returns a op of any list type.  \fItype\fR is
the opcode.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except that
\&\f(CW\*(C`OPf_KIDS\*(C'\fR is ghon be set automatically if required. Y'all KNOW dat shit, muthafucka!  \fIfirst\fR n' \fIlast\fR
supply up ta two ops ta be direct lil pimpz of tha list op; they are
consumed by dis function n' become part of tha constructed op tree.
.Sp
.Vb 2
\&        OP *    newLISTOP(I32 type, I32 flags, OP *first,
\&                          OP *last)
.Ve
.IP "newLOGOP" 8
.IX Xref "newLOGOP"
.IX Item "newLOGOP"
Constructs, checks, n' returns a logical (flow control) op.  \fItype\fR
is tha opcode.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except
that \f(CW\*(C`OPf_KIDS\*(C'\fR is ghon be set automatically, and, shifted up eight bits,
the eight bitz of \f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1 is
automatically set.  \fIfirst\fR supplies tha expression controllin the
flow, n' \fIother\fR supplies tha side (alternate) chain of ops; they are
consumed by dis function n' become part of tha constructed op tree.
.Sp
.Vb 2
\&        OP *    newLOGOP(I32 type, I32 flags, OP *first,
\&                         OP *other)
.Ve
.IP "newLOOPEX" 8
.IX Xref "newLOOPEX"
.IX Item "newLOOPEX"
Constructs, checks, n' returns a loop-exitin op (like fuckin \f(CW\*(C`goto\*(C'\fR
or \f(CW\*(C`last\*(C'\fR).  \fItype\fR is tha opcode.  \fIlabel\fR supplies tha parameter
determinin tha target of tha op; it is consumed by dis function and
becomes part of tha constructed op tree.
.Sp
.Vb 1
\&        OP *    newLOOPEX(I32 type, OP *label)
.Ve
.IP "newLOOPOP" 8
.IX Xref "newLOOPOP"
.IX Item "newLOOPOP"
Constructs, checks, n' returns a op tree expressin a loop.  This is
only a loop up in tha control flow all up in tha op tree; it do not have
the heavyweight loop structure dat allows exitin tha loop by \f(CW\*(C`last\*(C'\fR
and suchlike.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR fo' the
top-level op, except dat some bits is ghon be set automatically as required.
\&\fIexpr\fR supplies tha expression controllin loop iteration, n' \fIblock\fR
supplies tha body of tha loop; they is consumed by dis function and
become part of tha constructed op tree.  \fIdebuggable\fR is currently
unused n' should always be 1.
.Sp
.Vb 2
\&        OP *    newLOOPOP(I32 flags, I32 debuggable, OP *expr,
\&                          OP *block)
.Ve
.IP "newNULLLIST" 8
.IX Xref "newNULLLIST"
.IX Item "newNULLLIST"
Constructs, checks, n' returns a freshly smoked up \f(CW\*(C`stub\*(C'\fR op, which represents an
empty list expression.
.Sp
.Vb 1
\&        OP *    newNULLLIST()
.Ve
.IP "newOP" 8
.IX Xref "newOP"
.IX Item "newOP"
Constructs, checks, n' returns a op of any base type (any type that
has no extra fields).  \fItype\fR is tha opcode.  \fIflags\fR gives the
eight bitz of \f(CW\*(C`op_flags\*(C'\fR, and, shifted up eight bits, tha eight bits
of \f(CW\*(C`op_private\*(C'\fR.
.Sp
.Vb 1
\&        OP *    newOP(I32 type, I32 flags)
.Ve
.IP "newPADOP" 8
.IX Xref "newPADOP"
.IX Item "newPADOP"
Constructs, checks, n' returns a op of any type dat involves a
reference ta a pad element.  \fItype\fR is tha opcode.  \fIflags\fR gives the
eight bitz of \f(CW\*(C`op_flags\*(C'\fR.  A pad slot be automatically allocated, and
is populated wit \fIsv\fR; dis function takes ballershizzle of one reference
to dat shit.
.Sp
This function only exists if Perl has been compiled ta use ithreads.
.Sp
.Vb 1
\&        OP *    newPADOP(I32 type, I32 flags, SV *sv)
.Ve
.IP "newPMOP" 8
.IX Xref "newPMOP"
.IX Item "newPMOP"
Constructs, checks, n' returns a op of any pattern matchin type.
\&\fItype\fR is tha opcode.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR
and, shifted up eight bits, tha eight bitz of \f(CW\*(C`op_private\*(C'\fR.
.Sp
.Vb 1
\&        OP *    newPMOP(I32 type, I32 flags)
.Ve
.IP "newPVOP" 8
.IX Xref "newPVOP"
.IX Item "newPVOP"
Constructs, checks, n' returns a op of any type dat involves an
embedded C\-level pointa (\s-1PV\s0).  \fItype\fR is tha opcode.  \fIflags\fR gives
the eight bitz of \f(CW\*(C`op_flags\*(C'\fR.  \fIpv\fR supplies tha C\-level pointer, which
must done been allocated rockin \*(L"PerlMemShared_malloc\*(R"; tha memory will
be freed when tha op is destroyed.
.Sp
.Vb 1
\&        OP *    newPVOP(I32 type, I32 flags, char *pv)
.Ve
.IP "newRANGE" 8
.IX Xref "newRANGE"
.IX Item "newRANGE"
Constructs n' returns a \f(CW\*(C`range\*(C'\fR op, wit subordinizzle \f(CW\*(C`flip\*(C'\fR and
\&\f(CW\*(C`flop\*(C'\fR ops.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR fo' the
\&\f(CW\*(C`flip\*(C'\fR op and, shifted up eight bits, tha eight bitz of \f(CW\*(C`op_private\*(C'\fR
for both tha \f(CW\*(C`flip\*(C'\fR n' \f(CW\*(C`range\*(C'\fR ops, except dat tha bit wit value
1 be automatically set.  \fIleft\fR n' \fIright\fR supply tha expressions
controllin tha endpointz of tha range; they is consumed by dis function
and become part of tha constructed op tree.
.Sp
.Vb 1
\&        OP *    newRANGE(I32 flags, OP *left, OP *right)
.Ve
.IP "newSLICEOP" 8
.IX Xref "newSLICEOP"
.IX Item "newSLICEOP"
Constructs, checks, n' returns a \f(CW\*(C`lslice\*(C'\fR (list slice) op.  \fIflags\fR
gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except dat \f(CW\*(C`OPf_KIDS\*(C'\fR will
be set automatically, and, shifted up eight bits, tha eight bits of
\&\f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1 or 2 be automatically
set as required. Y'all KNOW dat shit, muthafucka!  \fIlistval\fR n' \fIsubscript\fR supply tha parametas of
the slice; they is consumed by dis function n' become part of the
constructed op tree.
.Sp
.Vb 2
\&        OP *    newSLICEOP(I32 flags, OP *subscript,
\&                           OP *listval)
.Ve
.IP "newSTATEOP" 8
.IX Xref "newSTATEOP"
.IX Item "newSTATEOP"
Constructs a state op (\s-1COP\s0).  Da state op is normally a \f(CW\*(C`nextstate\*(C'\fR op,
but is ghon be a \f(CW\*(C`dbstate\*(C'\fR op if debuggin is enabled fo' currently-compiled
code.  Da state op is populated from \*(L"PL_curcop\*(R" (or \*(L"PL_compiling\*(R").
If \fIlabel\fR is non-null, it supplies tha name of a label ta attach to
the state op; dis function takes ballershizzle of tha memory pointed at by
\&\fIlabel\fR, n' will free dat shit.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR
for tha state op.
.Sp
If \fIo\fR is null, tha state op is returned. Y'all KNOW dat shit, muthafucka!  Otherwise tha state op is
combined wit \fIo\fR tha fuck into a \f(CW\*(C`lineseq\*(C'\fR list op, which is returned. Y'all KNOW dat shit, muthafucka!  \fIo\fR
is consumed by dis function n' becomes part of tha returned op tree.
.Sp
.Vb 1
\&        OP *    newSTATEOP(I32 flags, char *label, OP *o)
.Ve
.IP "newSVOP" 8
.IX Xref "newSVOP"
.IX Item "newSVOP"
Constructs, checks, n' returns a op of any type dat involves an
embedded \s-1SV.  \s0\fItype\fR is tha opcode.  \fIflags\fR gives tha eight bits
of \f(CW\*(C`op_flags\*(C'\fR.  \fIsv\fR gives tha \s-1SV\s0 ta embed up in tha op; dis function
takes ballershizzle of one reference ta dat shit.
.Sp
.Vb 1
\&        OP *    newSVOP(I32 type, I32 flags, SV *sv)
.Ve
.IP "newUNOP" 8
.IX Xref "newUNOP"
.IX Item "newUNOP"
Constructs, checks, n' returns a op of any unary type.  \fItype\fR is
the opcode.  \fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR, except that
\&\f(CW\*(C`OPf_KIDS\*(C'\fR is ghon be set automatically if required, and, shifted up eight
bits, tha eight bitz of \f(CW\*(C`op_private\*(C'\fR, except dat tha bit wit value 1
is automatically set.  \fIfirst\fR supplies a optionizzle op ta be tha direct
child of tha unary op; it is consumed by dis function n' become part
of tha constructed op tree.
.Sp
.Vb 1
\&        OP *    newUNOP(I32 type, I32 flags, OP *first)
.Ve
.IP "newWHENOP" 8
.IX Xref "newWHENOP"
.IX Item "newWHENOP"
Constructs, checks, n' returns a op tree expressin a \f(CW\*(C`when\*(C'\fR block.
\&\fIcond\fR supplies tha test expression, n' \fIblock\fR supplies tha block
that is ghon be executed if tha test evaluates ta true; they is consumed
by dis function n' become part of tha constructed op tree.  \fIcond\fR
will be interpreted DWIMically, often as a cold-ass lil comparison against \f(CW$_\fR,
and may be null ta generate a \f(CW\*(C`default\*(C'\fR block.
.Sp
.Vb 1
\&        OP *    newWHENOP(OP *cond, OP *block)
.Ve
.IP "newWHILEOP" 8
.IX Xref "newWHILEOP"
.IX Item "newWHILEOP"
Constructs, checks, n' returns a op tree expressin a \f(CW\*(C`while\*(C'\fR loop.
This be a heavyweight loop, wit structure dat allows exitin tha loop
by \f(CW\*(C`last\*(C'\fR n' suchlike.
.Sp
\&\fIloop\fR be a optionizzle preconstructed \f(CW\*(C`enterloop\*(C'\fR op ta use up in the
loop; if it is null then a suitable op is ghon be constructed automatically.
\&\fIexpr\fR supplies tha loopz controllin expression. I aint talkin' bout chicken n' gravy biatch.  \fIblock\fR supplies the
main body of tha loop, n' \fIcont\fR optionally supplies a \f(CW\*(C`continue\*(C'\fR block
that operates as a second half of tha body.  All of these optree inputs
are consumed by dis function n' become part of tha constructed op tree.
.Sp
\&\fIflags\fR gives tha eight bitz of \f(CW\*(C`op_flags\*(C'\fR fo' tha \f(CW\*(C`leaveloop\*(C'\fR
op and, shifted up eight bits, tha eight bitz of \f(CW\*(C`op_private\*(C'\fR for
the \f(CW\*(C`leaveloop\*(C'\fR op, except dat (in both cases) some bits is ghon be set
automatically.  \fIdebuggable\fR is currently unused n' should always be 1.
\&\fIhas_my\fR can be supplied as legit ta force the
loop body ta be enclosed up in its own scope.
.Sp
.Vb 3
\&        OP *    newWHILEOP(I32 flags, I32 debuggable,
\&                           LOOP *loop, OP *expr, OP *block,
\&                           OP *cont, I32 has_my)
.Ve
.SH "Optree Manipulation Functions"
.IX Header "Optree Manipulation Functions"
.IP "ck_entersub_args_list" 8
.IX Xref "ck_entersub_args_list"
.IX Item "ck_entersub_args_list"
Performs tha default fixup of tha arguments part of a \f(CW\*(C`entersub\*(C'\fR
op tree.  This consistz of applyin list context ta each of the
argument ops.  This is tha standard treatment used on a cold-ass lil call marked
with \f(CW\*(C`&\*(C'\fR, or a method call, or a cold-ass lil call all up in a subroutine reference,
or any other call where tha callee can't be identified at compile time,
or a cold-ass lil call where tha callee has no prototype.
.Sp
.Vb 1
\&        OP *    ck_entersub_args_list(OP *entersubop)
.Ve
.IP "ck_entersub_args_proto" 8
.IX Xref "ck_entersub_args_proto"
.IX Item "ck_entersub_args_proto"
Performs tha fixup of tha arguments part of a \f(CW\*(C`entersub\*(C'\fR op tree
based on a subroutine prototype.  This make various modifications to
the argument ops, from applyin context up ta insertin \f(CW\*(C`refgen\*(C'\fR ops,
and checkin tha number n' syntactic typez of arguments, as pimped up by
the prototype.  This is tha standard treatment used on a subroutine call,
not marked wit \f(CW\*(C`&\*(C'\fR, where tha callee can be identified at compile time
and has a prototype.
.Sp
\&\fIprotosv\fR supplies tha subroutine prototype ta be applied ta tha call.
It may be a aiiight defined scalar, of which tha strang value is ghon be used.
Alternatively, fo' convenience, it may be a subroutine object (a \f(CW\*(C`CV*\*(C'\fR
that has been cast ta \f(CW\*(C`SV*\*(C'\fR) which has a prototype.  Da prototype
supplied, up in whichever form, do not need ta match tha actual callee
referenced by tha op tree.
.Sp
If tha argument ops disagree wit tha prototype, fo' example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
Da error is reflected up in tha parser state, normally resultin up in a single
exception all up in tha top level of parsin which covers all tha compilation
errors dat occurred. Y'all KNOW dat shit, muthafucka!  In tha error message, tha callee is referred to
by tha name defined by tha \fInamegv\fR parameter.
.Sp
.Vb 2
\&        OP *    ck_entersub_args_proto(OP *entersubop,
\&                                       GV *namegv, SV *protosv)
.Ve
.IP "ck_entersub_args_proto_or_list" 8
.IX Xref "ck_entersub_args_proto_or_list"
.IX Item "ck_entersub_args_proto_or_list"
Performs tha fixup of tha arguments part of a \f(CW\*(C`entersub\*(C'\fR op tree either
based on a subroutine prototype or rockin default list-context processing.
This is tha standard treatment used on a subroutine call, not marked
with \f(CW\*(C`&\*(C'\fR, where tha callee can be identified at compile time.
.Sp
\&\fIprotosv\fR supplies tha subroutine prototype ta be applied ta tha call,
or indicates dat there is no prototype.  It may be a aiiight scalar,
in which case if it is defined then tha strang value is ghon be used
as a prototype, n' if it is undefined then there is no prototype.
Alternatively, fo' convenience, it may be a subroutine object (a \f(CW\*(C`CV*\*(C'\fR
that has been cast ta \f(CW\*(C`SV*\*(C'\fR), of which tha prototype is ghon be used if it
has one.  Da prototype (or lack thereof) supplied, up in whichever form,
does not need ta match tha actual callee referenced by tha op tree.
.Sp
If tha argument ops disagree wit tha prototype, fo' example by having
an unacceptable number of arguments, a valid op tree is returned anyway.
Da error is reflected up in tha parser state, normally resultin up in a single
exception all up in tha top level of parsin which covers all tha compilation
errors dat occurred. Y'all KNOW dat shit, muthafucka!  In tha error message, tha callee is referred to
by tha name defined by tha \fInamegv\fR parameter.
.Sp
.Vb 3
\&        OP *    ck_entersub_args_proto_or_list(OP *entersubop,
\&                                               GV *namegv,
\&                                               SV *protosv)
.Ve
.IP "cv_const_sv" 8
.IX Xref "cv_const_sv"
.IX Item "cv_const_sv"
If \f(CW\*(C`cv\*(C'\fR be a cold-ass lil constant sub eligible fo' inlining. returns tha constant
value returned by tha sub.  Otherwise, returns \s-1NULL.\s0
.Sp
Constant subs can be pimped wit \f(CW\*(C`newCONSTSUB\*(C'\fR or as busted lyrics bout in
\&\*(L"Constant Functions\*(R" up in perlsub.
.Sp
.Vb 1
\&        SV*     cv_const_sv(const CV *const cv)
.Ve
.IP "cv_get_call_checker" 8
.IX Xref "cv_get_call_checker"
.IX Item "cv_get_call_checker"
Retrieves tha function dat is ghon be used ta fix up a cold-ass lil call ta \fIcv\fR.
Specifically, tha function be applied ta a \f(CW\*(C`entersub\*(C'\fR op tree fo' a
subroutine call, not marked wit \f(CW\*(C`&\*(C'\fR, where tha callee can be identified
at compile time as \fIcv\fR.
.Sp
Da C\-level function pointa is returned up in \fI*ckfun_p\fR, n' a \s-1SV\s0
argument fo' it is returned up in \fI*ckobj_p\fR.  Da function is intended
to be called up in dis manner:
.Sp
.Vb 1
\&    entersubop = (*ckfun_p)(aTHX_ entersubop, namegv, (*ckobj_p));
.Ve
.Sp
In dis call, \fIentersubop\fR be a pointa ta tha \f(CW\*(C`entersub\*(C'\fR op,
which may be replaced by tha check function, n' \fInamegv\fR be a \s-1GV\s0
supplyin tha name dat should be used by tha check function ta refer
to tha callee of tha \f(CW\*(C`entersub\*(C'\fR op if it need ta emit any diagnostics.
It be permitted ta apply tha check function up in non-standard thangs,
like fuckin ta a cold-ass lil call ta a gangbangin' finger-lickin' different subroutine or ta a method call.
.Sp
By default, tha function is
Perl_ck_entersub_args_proto_or_list,
and tha \s-1SV\s0 parameta is \fIcv\fR itself.  This implements standard
prototype processing.  It can be chizzled, fo' a particular subroutine,
by \*(L"cv_set_call_checker\*(R".
.Sp
.Vb 3
\&        void    cv_get_call_checker(CV *cv,
\&                                    Perl_call_checker *ckfun_p,
\&                                    SV **ckobj_p)
.Ve
.IP "cv_set_call_checker" 8
.IX Xref "cv_set_call_checker"
.IX Item "cv_set_call_checker"
Sets tha function dat is ghon be used ta fix up a cold-ass lil call ta \fIcv\fR.
Specifically, tha function be applied ta a \f(CW\*(C`entersub\*(C'\fR op tree fo' a
subroutine call, not marked wit \f(CW\*(C`&\*(C'\fR, where tha callee can be identified
at compile time as \fIcv\fR.
.Sp
Da C\-level function pointa is supplied up in \fIckfun\fR, n' a \s-1SV\s0 argument
for it is supplied up in \fIckobj\fR.  Da function is intended ta be called
in dis manner:
.Sp
.Vb 1
\&    entersubop = ckfun(aTHX_ entersubop, namegv, ckobj);
.Ve
.Sp
In dis call, \fIentersubop\fR be a pointa ta tha \f(CW\*(C`entersub\*(C'\fR op,
which may be replaced by tha check function, n' \fInamegv\fR be a \s-1GV\s0
supplyin tha name dat should be used by tha check function ta refer
to tha callee of tha \f(CW\*(C`entersub\*(C'\fR op if it need ta emit any diagnostics.
It be permitted ta apply tha check function up in non-standard thangs,
like fuckin ta a cold-ass lil call ta a gangbangin' finger-lickin' different subroutine or ta a method call.
.Sp
Da current settin fo' a particular \s-1CV\s0 can be retrieved by
\&\*(L"cv_get_call_checker\*(R".
.Sp
.Vb 3
\&        void    cv_set_call_checker(CV *cv,
\&                                    Perl_call_checker ckfun,
\&                                    SV *ckobj)
.Ve
.IP "\s-1LINKLIST \s0" 8
.IX Xref "LINKLIST"
.IX Item "LINKLIST "
Given tha root of a optree, link tha tree up in execution order rockin the
\&\f(CW\*(C`op_next\*(C'\fR pointas n' return tha straight-up original gangsta op executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If dis has
already been done, it aint gonna be redone, n' \f(CW\*(C`o\->op_next\*(C'\fR will be
returned. Y'all KNOW dat shit, muthafucka! If \f(CW\*(C`o\->op_next\*(C'\fR aint already set, \fIo\fR should be at
least a \f(CW\*(C`UNOP\*(C'\fR.
.Sp
.Vb 1
\&        OP*     LINKLIST(OP *o)
.Ve
.IP "newCONSTSUB" 8
.IX Xref "newCONSTSUB"
.IX Item "newCONSTSUB"
See \*(L"newCONSTSUB_flags\*(R".
.Sp
.Vb 1
\&        CV*     newCONSTSUB(HV* stash, const char* name, SV* sv)
.Ve
.IP "newCONSTSUB_flags" 8
.IX Xref "newCONSTSUB_flags"
.IX Item "newCONSTSUB_flags"
Creates a cold-ass lil constant sub equivalent ta Perl \f(CW\*(C`sub FOO () { 123 }\*(C'\fR which is
eligible fo' inlinin at compile-time.
.Sp
Currently, tha only useful value fo' \f(CW\*(C`flags\*(C'\fR is SVf_UTF8.
.Sp
Da newly pimped subroutine takes ballershizzle of a reference ta tha passed in
\&\s-1SV.\s0
.Sp
Passin \s-1NULL\s0 fo' \s-1SV\s0 creates a cold-ass lil constant sub equivalent ta \f(CW\*(C`sub BAR () {}\*(C'\fR,
which won't be called if used as a thugged-out destructor yo, but will suppress tha overhead
of a cold-ass lil call ta \f(CW\*(C`AUTOLOAD\*(C'\fR.  (This form, however, aint eligible fo' inlinin at
compile time.)
.Sp
.Vb 2
\&        CV*     newCONSTSUB_flags(HV* stash, const char* name,
\&                                  STRLEN len, U32 flags, SV* sv)
.Ve
.IP "newXS" 8
.IX Xref "newXS"
.IX Item "newXS"
Used by \f(CW\*(C`xsubpp\*(C'\fR ta hook up XSUBs as Perl subs.  \fIfilename\fR need ta be
static storage, as it is used directly as \fICvFILE()\fR, without a cold-ass lil copy bein made.
.IP "op_append_elem" 8
.IX Xref "op_append_elem"
.IX Item "op_append_elem"
Append a item ta tha list of ops contained directly within a list-type
op, returnin tha lengthened list.  \fIfirst\fR is tha list-type op,
and \fIlast\fR is tha op ta append ta tha list.  \fIoptype\fR specifies the
intended opcode fo' tha list.  If \fIfirst\fR aint already a list of the
right type, it is ghon be upgraded tha fuck into one.  If either \fIfirst\fR or \fIlast\fR
is null, tha other is returned unchanged.
.Sp
.Vb 1
\&        OP *    op_append_elem(I32 optype, OP *first, OP *last)
.Ve
.IP "op_append_list" 8
.IX Xref "op_append_list"
.IX Item "op_append_list"
Concatenate tha listz of ops contained directly within two list-type ops,
returnin tha combined list.  \fIfirst\fR n' \fIlast\fR is tha list-type ops
to concatenate.  \fIoptype\fR specifies tha intended opcode fo' tha list.
If either \fIfirst\fR or \fIlast\fR aint already a list of tha right type,
it is ghon be upgraded tha fuck into one.  If either \fIfirst\fR or \fIlast\fR is null,
the other is returned unchanged.
.Sp
.Vb 1
\&        OP *    op_append_list(I32 optype, OP *first, OP *last)
.Ve
.IP "\s-1OP_CLASS \s0" 8
.IX Xref "OP_CLASS"
.IX Item "OP_CLASS "
Return tha class of tha provided \s-1OP:\s0 dat is, which of tha *OP
structures it uses. For core ops dis currently gets tha shiznit out
of PL_opargs, which do not always accurately reflect tha type used.
For custom ops tha type is returned from tha registration, n' it is up
to tha registree ta ensure it be accurate. Da value returned will be
one of tha OA_* constants from op.h.
.Sp
.Vb 1
\&        U32     OP_CLASS(OP *o)
.Ve
.IP "\s-1OP_DESC \s0" 8
.IX Xref "OP_DESC"
.IX Item "OP_DESC "
Return a gangbangin' finger-lickin' dirty-ass short description of tha provided \s-1OP.\s0
.Sp
.Vb 1
\&        const char * OP_DESC(OP *o)
.Ve
.IP "op_linklist" 8
.IX Xref "op_linklist"
.IX Item "op_linklist"
This function is tha implementation of tha \*(L"\s-1LINKLIST\*(R"\s0 macro. Well shiiiit, it should
not be called directly.
.Sp
.Vb 1
\&        OP*     op_linklist(OP *o)
.Ve
.IP "op_lvalue" 8
.IX Xref "op_lvalue"
.IX Item "op_lvalue"
Propagate lvalue (\*(L"modifiable\*(R") context ta a op n' its lil' thugs.
\&\fItype\fR represents tha context type, roughly based on tha type of op that
would do tha modifying, although \f(CW\*(C`local()\*(C'\fR is represented by \s-1OP_NULL,\s0
because it has no op type of its own (it is signalled by a gangbangin' flag on
the lvalue op).
.Sp
This function detects thangs dat can't be modified, like fuckin \f(CW\*(C`$x+1\*(C'\fR, and
generates errors fo' em. For example, \f(CW\*(C`$x+1 = 2\*(C'\fR would cause it ta be
called wit a op of type \s-1OP_ADD\s0 n' a \f(CW\*(C`type\*(C'\fR argument of \s-1OP_SASSIGN.\s0
.Sp
It also flags thangs dat need ta behave specially up in a lvalue context,
like fuckin \f(CW\*(C`$$x = 5\*(C'\fR which might gotta vivify a reference up in \f(CW$x\fR.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    op_lvalue(OP *o, I32 type)
.Ve
.IP "\s-1OP_NAME \s0" 8
.IX Xref "OP_NAME"
.IX Item "OP_NAME "
Return tha name of tha provided \s-1OP.\s0 For core ops dis looks up tha name
from tha op_type; fo' custom ops from tha op_ppaddr.
.Sp
.Vb 1
\&        const char * OP_NAME(OP *o)
.Ve
.IP "op_prepend_elem" 8
.IX Xref "op_prepend_elem"
.IX Item "op_prepend_elem"
Prepend a item ta tha list of ops contained directly within a list-type
op, returnin tha lengthened list.  \fIfirst\fR is tha op ta prepend ta the
list, n' \fIlast\fR is tha list-type op.  \fIoptype\fR specifies tha intended
opcode fo' tha list.  If \fIlast\fR aint already a list of tha right type,
it is ghon be upgraded tha fuck into one.  If either \fIfirst\fR or \fIlast\fR is null,
the other is returned unchanged.
.Sp
.Vb 1
\&        OP *    op_prepend_elem(I32 optype, OP *first, OP *last)
.Ve
.IP "op_scope" 8
.IX Xref "op_scope"
.IX Item "op_scope"
Wraps up a op tree wit some additionizzle ops so dat at runtime a thugged-out dynamic
scope is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da original gangsta ops run up in tha freshly smoked up dynamic scope,
and then, provided dat they exit normally, tha scope is ghon be unwound.
Da additionizzle ops used ta create n' unwind tha dynamic scope will
normally be a \f(CW\*(C`enter\*(C'\fR/\f(CW\*(C`leave\*(C'\fR pair yo, but a \f(CW\*(C`scope\*(C'\fR op may be used
instead if tha ops is simple enough ta not need tha full dynamic scope
structure.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        OP *    op_scope(OP *o)
.Ve
.IP "rv2cv_op_cv" 8
.IX Xref "rv2cv_op_cv"
.IX Item "rv2cv_op_cv"
Examines a op, which is sposed ta fuckin identify a subroutine at runtime,
and attempts ta determine at compile time which subroutine it identifies.
This is normally used durin Perl compilation ta determine whether
a prototype can be applied ta a gangbangin' function call.  \fIcvop\fR is tha op
bein considered, normally a \f(CW\*(C`rv2cv\*(C'\fR op.  A pointa ta tha identified
subroutine is returned, if it could be determined statically, n' a null
pointa is returned if dat shiznit was not possible ta determine statically.
.Sp
Currently, tha subroutine can be identified statically if tha \s-1RV\s0 dat the
\&\f(CW\*(C`rv2cv\*(C'\fR is ta operate on is provided by a suitable \f(CW\*(C`gv\*(C'\fR or \f(CW\*(C`const\*(C'\fR op.
A \f(CW\*(C`gv\*(C'\fR op is suitable if tha \s-1GV\s0z \s-1CV\s0 slot is populated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A \f(CW\*(C`const\*(C'\fR op is
suitable if tha constant value must be a \s-1RV\s0 pointin ta a \s-1CV. \s0 Details of
this process may chizzle up in future versionz of Perl.  If tha \f(CW\*(C`rv2cv\*(C'\fR op
has tha \f(CW\*(C`OPpENTERSUB_AMPER\*(C'\fR flag set then no attempt is made ta identify
the subroutine statically: dis flag is used ta suppress compile-time
magic on a subroutine call, forcin it ta use default runtime behaviour.
.Sp
If \fIflags\fR has tha bit \f(CW\*(C`RV2CVOPCV_MARK_EARLY\*(C'\fR set, then tha handling
of a \s-1GV\s0 reference is modified. Y'all KNOW dat shit, muthafucka!  If a \s-1GV\s0 was examined n' its \s-1CV\s0 slot was
found ta be empty, then tha \f(CW\*(C`gv\*(C'\fR op has tha \f(CW\*(C`OPpEARLY_CV\*(C'\fR flag set.
If tha op aint optimised away, n' tha \s-1CV\s0 slot is lata populated with
a subroutine havin a prototype, dat flag eventually triggers tha warning
\&\*(L"called too early ta check prototype\*(R".
.Sp
If \fIflags\fR has tha bit \f(CW\*(C`RV2CVOPCV_RETURN_NAME_GV\*(C'\fR set, then instead
of returnin a pointa ta tha subroutine it returns a pointa ta the
\&\s-1GV\s0 givin da most thugged-out appropriate name fo' tha subroutine up in dis context.
Normally dis is just tha \f(CW\*(C`CvGV\*(C'\fR of tha subroutine yo, but fo' a anonymous
(\f(CW\*(C`CvANON\*(C'\fR) subroutine dat is referenced all up in a \s-1GV\s0 it is ghon be the
referencin \s-1GV. \s0 Da resultin \f(CW\*(C`GV*\*(C'\fR is cast ta \f(CW\*(C`CV*\*(C'\fR ta be returned.
A null pointa is returned as usual if there is no statically-determinable
subroutine.
.Sp
.Vb 1
\&        CV *    rv2cv_op_cv(OP *cvop, U32 flags)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "CvPADLIST" 8
.IX Xref "CvPADLIST"
.IX Item "CvPADLIST"
\&\s-1CV\s0z can have CvPADLIST(cv) set ta point ta a \s-1PADLIST. \s0 This is tha \s-1CV\s0's
scratchpad, which stores lexical variablez n' opcode temporary and
per-thread joints.
.Sp
For these purposes \*(L"formats\*(R" is a kind-of \s-1CV\s0; eval"\*(L"s is too (except they're
not callable at will n' is always thrown away afta tha eval\*(R"" is done
executing).  Require'd filez is simply evals without any outa lexical
scope.
.Sp
XSUBs aint gots CvPADLIST set \- dXSTARG fetches joints from PL_curpad,
but dat is straight-up tha callaz pad (a slot of which be allocated by
every entersub).
.Sp
Da \s-1PADLIST\s0 has a C array where padz is stored.
.Sp
Da 0th entry of tha \s-1PADLIST\s0 be a \s-1PADNAMELIST \s0(which is straight-up just an
\&\s-1AV,\s0 but dat may chizzle) which represents tha \*(L"names\*(R" or rather
the \*(L"static type shiznit\*(R" fo' lexicals.  Da individual elementz of a
\&\s-1PADNAMELIST\s0 is PADNAMEs (just SVs; but, again, dat may chizzle).  Future
refactorings might stop tha \s-1PADNAMELIST\s0 from bein stored up in tha \s-1PADLIST\s0's
array, so don't rely on dat shit.  See \*(L"PadlistNAMES\*(R".
.Sp
Da CvDEPTH'th entry of a \s-1PADLIST\s0 be a \s-1PAD \s0(an \s-1AV\s0) which is tha stack frame
at dat depth of recursion tha fuck into tha \s-1CV. \s0 Da 0th slot of a gangbangin' frame \s-1AV\s0 be an
\&\s-1AV\s0 which is \f(CW@_\fR.  Other entries is storage fo' variablez n' op targets.
.Sp
Iteratin over tha \s-1PADNAMELIST\s0 iterates over all possible pad
items.  Pad slots dat is SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef \*(L"names\*(R" (see \fIpad_alloc()\fR).
.Sp
Only my/our variable (SvPADMY/PADNAME_isOUR) slots git valid names.
Da rest is op targets/GVs/constants which is statically allocated
or resolved at compile time.  These aint gots names by which they
can be looked up from Perl code at run time all up in eval"\*(L" tha way
my/our variablez can be.  Since they can't be looked up by \*(R"name"
but only by they index allocated at compile time (which is usually
in PL_op\->op_targ), wastin a name \s-1SV\s0 fo' dem don't make sense.
.Sp
Da SVs up in tha names \s-1AV\s0 have they \s-1PV\s0 bein tha name of tha variable.
xlow+1..xhigh inclusive up in tha \s-1NV\s0 union be a range of cop_seq numbers for
which tha name is valid (accessed all up in tha macros \s-1COP_SEQ_RANGE_LOW\s0 and
_HIGH).  Durin compilation, these fieldz may hold tha special value
\&\s-1PERL_PADSEQ_INTRO\s0 ta indicate various stages:
.Sp
.Vb 5
\&   COP_SEQ_RANGE_LOW        _HIGH
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-        \-\-\-\-\-
\&   PERL_PADSEQ_INTRO            0   variable not yet introduced:   { mah ($x
\&   valid\-seq#   PERL_PADSEQ_INTRO   variable up in scope:             { mah ($x)
\&   valid\-seq#          valid\-seq#   compilation of scope complete: { mah ($x) }
.Ve
.Sp
For typed lexicals name \s-1SV\s0 is SVt_PVMG n' SvSTASH
points all up in tha type.  For \f(CW\*(C`our\*(C'\fR lexicals, tha type be also SVt_PVMG, wit the
SvOURSTASH slot pointin all up in tha stash of tha associated global (so that
duplicate \f(CW\*(C`our\*(C'\fR declarations up in tha same package can be detected).  SvUVX is
sometimes hijacked ta store tha generation number durin compilation.
.Sp
If \s-1PADNAME_OUTER \s0(SvFAKE) is set on the
name \s-1SV,\s0 then dat slot up in tha frame \s-1AV\s0 is
a \s-1REFCNT\s0'ed reference ta a lexical from \*(L"outside\*(R". In dis case,
the name \s-1SV\s0 do not use xlow n' xhigh ta store a cold-ass lil cop_seq range, since it is
in scope throughout. Instead xhigh stores some flags containin info about
the real lexical (is it declared up in a anon, n' is it capable of being
instantiated multiple times?), n' fo' fake ANONs, xlow gotz nuff tha index
within tha parentz pad where tha lexicalz value is stored, ta make
clonin quicker.
.Sp
If tha 'name' is '&' tha correspondin entry up in tha \s-1PAD\s0
is a \s-1CV\s0 representin a possible closure.
(\s-1PADNAME_OUTER\s0 n' name of '&' aint a
meaningful combination currently but could
become so if \f(CW\*(C`my sub foo {}\*(C'\fR is implemented.)
.Sp
Note dat formats is treated as anon subs, n' is cloned each time
write is called (if necessary).
.Sp
Da flag SVs_PADSTALE is cleared on lexicals each time tha \fImy()\fR is executed,
and set on scope exit.  This allows the
\&'Variable \f(CW$x\fR aint available' warning
to be generated up in evals, such as
.Sp
.Vb 1
\&    { mah $x = 1; sub f { eval \*(Aq$x\*(Aq} } f();
.Ve
.Sp
For state vars, SVs_PADSTALE is overloaded ta mean 'not yet initialised'.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADLIST * CvPADLIST(CV *cv)
.Ve
.IP "PadARRAY" 8
.IX Xref "PadARRAY"
.IX Item "PadARRAY"
Da C array of pad entries.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SV **   PadARRAY(PAD pad)
.Ve
.IP "PadlistARRAY" 8
.IX Xref "PadlistARRAY"
.IX Item "PadlistARRAY"
Da C array of a padlist, containin tha pads.  Only subscript it with
numbers >= 1, as tha 0th entry aint guaranteed ta remain usable.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PAD **  PadlistARRAY(PADLIST padlist)
.Ve
.IP "PadlistMAX" 8
.IX Xref "PadlistMAX"
.IX Item "PadlistMAX"
Da index of tha last pad up in tha padlist.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SSize_t PadlistMAX(PADLIST padlist)
.Ve
.IP "PadlistNAMES" 8
.IX Xref "PadlistNAMES"
.IX Item "PadlistNAMES"
Da names associated wit pad entries.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADNAMELIST * PadlistNAMES(PADLIST padlist)
.Ve
.IP "PadlistNAMESARRAY" 8
.IX Xref "PadlistNAMESARRAY"
.IX Item "PadlistNAMESARRAY"
Da C array of pad names.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADNAME ** PadlistNAMESARRAY(PADLIST padlist)
.Ve
.IP "PadlistNAMESMAX" 8
.IX Xref "PadlistNAMESMAX"
.IX Item "PadlistNAMESMAX"
Da index of tha last pad name.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SSize_t PadlistNAMESMAX(PADLIST padlist)
.Ve
.IP "PadlistREFCNT" 8
.IX Xref "PadlistREFCNT"
.IX Item "PadlistREFCNT"
Da reference count of tha padlist.  Currently dis be always 1.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        U32     PadlistREFCNT(PADLIST padlist)
.Ve
.IP "PadMAX" 8
.IX Xref "PadMAX"
.IX Item "PadMAX"
Da index of tha last pad entry.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SSize_t PadMAX(PAD pad)
.Ve
.IP "PadnameLEN" 8
.IX Xref "PadnameLEN"
.IX Item "PadnameLEN"
Da length of tha name.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        STRLEN  PadnameLEN(PADNAME pn)
.Ve
.IP "PadnamelistARRAY" 8
.IX Xref "PadnamelistARRAY"
.IX Item "PadnamelistARRAY"
Da C array of pad names.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PADNAME ** PadnamelistARRAY(PADNAMELIST pnl)
.Ve
.IP "PadnamelistMAX" 8
.IX Xref "PadnamelistMAX"
.IX Item "PadnamelistMAX"
Da index of tha last pad name.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SSize_t PadnamelistMAX(PADNAMELIST pnl)
.Ve
.IP "PadnamePV" 8
.IX Xref "PadnamePV"
.IX Item "PadnamePV"
Da name stored up in tha pad name struct.  This returns \s-1NULL\s0 fo' a target or
\&\s-1GV\s0 slot.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        char *  PadnamePV(PADNAME pn)
.Ve
.IP "PadnameSV" 8
.IX Xref "PadnameSV"
.IX Item "PadnameSV"
Returns tha pad name as a \s-1SV. \s0 This is currently just \f(CW\*(C`pn\*(C'\fR.  It will
begin returnin a freshly smoked up mortal \s-1SV\s0 if pad names eva stop bein SVs.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SV *    PadnameSV(PADNAME pn)
.Ve
.IP "PadnameUTF8" 8
.IX Xref "PadnameUTF8"
.IX Item "PadnameUTF8"
Whether PadnamePV is up in \s-1UTF8.\s0
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        bool    PadnameUTF8(PADNAME pn)
.Ve
.IP "pad_add_name_pvs" 8
.IX Xref "pad_add_name_pvs"
.IX Item "pad_add_name_pvs"
Exactly like \*(L"pad_add_name_pvn\*(R" yo, but takes a literal strang instead
of a string/length pair.
.Sp
.Vb 2
\&        PADOFFSET pad_add_name_pvs(const char *name, U32 flags,
\&                                   HV *typestash, HV *ourstash)
.Ve
.IP "pad_findmy_pvs" 8
.IX Xref "pad_findmy_pvs"
.IX Item "pad_findmy_pvs"
Exactly like \*(L"pad_findmy_pvn\*(R" yo, but takes a literal strang instead
of a string/length pair.
.Sp
.Vb 1
\&        PADOFFSET pad_findmy_pvs(const char *name, U32 flags)
.Ve
.IP "pad_new" 8
.IX Xref "pad_new"
.IX Item "pad_new"
Smoke a freshly smoked up padlist, uppimpin tha global variablez fo' the
currently-compilin padlist ta point ta tha freshly smoked up padlist.  Da following
flags can be \s-1OR\s0'ed together:
.Sp
.Vb 3
\&    padnew_CLONE        dis pad is fo' a cold-ass lil cloned CV
\&    padnew_SAVE         save oldschool globals on tha save stack
\&    padnew_SAVESUB      also save extra shiznit fo' start of sub
\&
\&        PADLIST * pad_new(int flags)
.Ve
.IP "PL_comppad" 8
.IX Xref "PL_comppad"
.IX Item "PL_comppad"
Durin compilation, dis points ta tha array containin tha joints
part of tha pad fo' tha currently-compilin code.  (At runtime a \s-1CV\s0 may
have nuff such value arrays; at compile time just one is constructed.)
At runtime, dis points ta tha array containin tha currently-relevant
values fo' tha pad fo' tha currently-executin code.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.IP "PL_comppad_name" 8
.IX Xref "PL_comppad_name"
.IX Item "PL_comppad_name"
Durin compilation, dis points ta tha array containin tha names part
of tha pad fo' tha currently-compilin code.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.IP "PL_curpad" 8
.IX Xref "PL_curpad"
.IX Item "PL_curpad"
Points directly ta tha body of tha \*(L"PL_comppad\*(R" array.
(I.e., dis is \f(CW\*(C`PAD_ARRAY(PL_comppad)\*(C'\fR.)
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.SH "Per-Interpreta Variables"
.IX Header "Per-Interpreta Variables"
.IP "PL_modglobal" 8
.IX Xref "PL_modglobal"
.IX Item "PL_modglobal"
\&\f(CW\*(C`PL_modglobal\*(C'\fR be a general purpose, interpreta global \s-1HV\s0 fo' use by
extensions dat need ta keep shiznit on a per-interpreta basis.
In a pinch, it can also be used as a symbol table fo' extensions
to share data among each other n' shit.  It be a phat scam ta use keys
prefixed by tha package name of tha extension dat owns tha data.
.Sp
.Vb 1
\&        HV*     PL_modglobal
.Ve
.IP "PL_na" 8
.IX Xref "PL_na"
.IX Item "PL_na"
A convenience variable which is typically used wit \f(CW\*(C`SvPV\*(C'\fR when one
doesn't care bout tha length of tha string.  It be probably mo' efficient
to either declare a local variable n' use dat instead or ta use the
\&\f(CW\*(C`SvPV_nolen\*(C'\fR macro.
.Sp
.Vb 1
\&        STRLEN  PL_na
.Ve
.IP "PL_opfreehook" 8
.IX Xref "PL_opfreehook"
.IX Item "PL_opfreehook"
When non\-\f(CW\*(C`NULL\*(C'\fR, tha function pointed by dis variable is ghon be called each time a \s-1OP\s0 is freed wit tha correspondin \s-1OP\s0 as tha argument.
This allows extensions ta free any extra attribute they have locally attached ta a \s-1OP.\s0
It be also assured ta first fire fo' tha parent \s-1OP\s0 n' then fo' its kids.
.Sp
When you replace dis variable, it is considered a phat practice ta store tha possibly previously installed hook n' dat you recall it inside yo' own.
.Sp
.Vb 1
\&        Perl_ophook_t   PL_opfreehook
.Ve
.IP "PL_peepp" 8
.IX Xref "PL_peepp"
.IX Item "PL_peepp"
Pointa ta tha per-subroutine peephole optimiser n' shit.  This be a gangbangin' function
that gets called all up in tha end of compilation of a Perl subroutine (or
equivalently independent piece of Perl code) ta big-ass up fixups of
some ops n' ta big-ass up small-scale optimisations.  Da function is
called once fo' each subroutine dat is compiled, n' is passed, as sole
parameter, a pointa ta tha op dat is tha entry point ta tha subroutine.
It modifies tha op tree up in place.
.Sp
Da peephole optimiser should never be straight-up replaced. Y'all KNOW dat shit, muthafucka!  Rather,
add code ta it by rappin bout da existin optimiser n' shit.  Da basic way ta do
this can be peeped up in \*(L"Compile pass 3: peephole optimization\*(R" up in perlguts.
If tha freshly smoked up code wishes ta operate on ops all up in tha subroutine's
structure, rather than just all up in tha top level, it is likely ta be more
convenient ta wrap tha \*(L"PL_rpeepp\*(R" hook.
.Sp
.Vb 1
\&        peep_t  PL_peepp
.Ve
.IP "PL_rpeepp" 8
.IX Xref "PL_rpeepp"
.IX Item "PL_rpeepp"
Pointa ta tha recursive peephole optimiser n' shit.  This be a gangbangin' function
that gets called all up in tha end of compilation of a Perl subroutine (or
equivalently independent piece of Perl code) ta big-ass up fixupz of some
ops n' ta big-ass up small-scale optimisations.  Da function is called
once fo' each chain of ops linked all up in they \f(CW\*(C`op_next\*(C'\fR fields;
it is recursively called ta handle each side chain. I aint talkin' bout chicken n' gravy biatch.  It be passed, as
sole parameter, a pointa ta tha op dat be all up in tha head of tha chain.
It modifies tha op tree up in place.
.Sp
Da peephole optimiser should never be straight-up replaced. Y'all KNOW dat shit, muthafucka!  Rather,
add code ta it by rappin bout da existin optimiser n' shit.  Da basic way ta do
this can be peeped up in \*(L"Compile pass 3: peephole optimization\*(R" up in perlguts.
If tha freshly smoked up code wishes ta operate only on ops at a subroutinez top level,
rather than all up in tha structure, it is likely ta be mo' convenient
to wrap tha \*(L"PL_peepp\*(R" hook.
.Sp
.Vb 1
\&        peep_t  PL_rpeepp
.Ve
.IP "PL_sv_no" 8
.IX Xref "PL_sv_no"
.IX Item "PL_sv_no"
This is tha \f(CW\*(C`false\*(C'\fR \s-1SV. \s0 See \f(CW\*(C`PL_sv_yes\*(C'\fR.  Always refer ta dis as
\&\f(CW&PL_sv_no\fR.
.Sp
.Vb 1
\&        SV      PL_sv_no
.Ve
.IP "PL_sv_undef" 8
.IX Xref "PL_sv_undef"
.IX Item "PL_sv_undef"
This is tha \f(CW\*(C`undef\*(C'\fR \s-1SV. \s0 Always refer ta dis as \f(CW&PL_sv_undef\fR.
.Sp
.Vb 1
\&        SV      PL_sv_undef
.Ve
.IP "PL_sv_yes" 8
.IX Xref "PL_sv_yes"
.IX Item "PL_sv_yes"
This is tha \f(CW\*(C`true\*(C'\fR \s-1SV. \s0 See \f(CW\*(C`PL_sv_no\*(C'\fR.  Always refer ta dis as
\&\f(CW&PL_sv_yes\fR.
.Sp
.Vb 1
\&        SV      PL_sv_yes
.Ve
.SH "REGEXP Functions"
.IX Header "REGEXP Functions"
.IP "SvRX" 8
.IX Xref "SvRX"
.IX Item "SvRX"
Convenience macro ta git tha \s-1REGEXP\s0 from a \s-1SV.\s0 This be approximately
equivalent ta tha followin snippet:
.Sp
.Vb 6
\&    if (SvMAGICAL(sv))
\&        mg_get(sv);
\&    if (SvROK(sv))
\&        sv = MUTABLE_SV(SvRV(sv));
\&    if (SvTYPE(sv) == SVt_REGEXP)
\&        return (REGEXP*) sv;
.Ve
.Sp
\&\s-1NULL\s0 is ghon be returned if a REGEXP* aint found.
.Sp
.Vb 1
\&        REGEXP * SvRX(SV *sv)
.Ve
.IP "SvRXOK" 8
.IX Xref "SvRXOK"
.IX Item "SvRXOK"
Returns a funky-ass boolean indicatin whether tha \s-1SV \s0(or tha one it references)
is a \s-1REGEXP.\s0
.Sp
If you wanna do suttin' wit tha REGEXP* lata use SvRX instead
and check fo' \s-1NULL.\s0
.Sp
.Vb 1
\&        bool    SvRXOK(SV* sv)
.Ve
.SH "Simple Exception Handlin Macros"
.IX Header "Simple Exception Handlin Macros"
.IP "dXCPT" 8
.IX Xref "dXCPT"
.IX Item "dXCPT"
Set up necessary local variablez fo' exception handling.
See \*(L"Exception Handling\*(R" up in perlguts.
.Sp
.Vb 1
\&                dXCPT;
.Ve
.IP "\s-1XCPT_CATCH \s0" 8
.IX Xref "XCPT_CATCH"
.IX Item "XCPT_CATCH "
Introduces a cold-ass lil catch block.  See \*(L"Exception Handling\*(R" up in perlguts.
.IP "\s-1XCPT_RETHROW \s0" 8
.IX Xref "XCPT_RETHROW"
.IX Item "XCPT_RETHROW "
Rethrows a previously caught exception. I aint talkin' bout chicken n' gravy biatch.  See \*(L"Exception Handling\*(R" up in perlguts.
.Sp
.Vb 1
\&                XCPT_RETHROW;
.Ve
.IP "\s-1XCPT_TRY_END \s0" 8
.IX Xref "XCPT_TRY_END"
.IX Item "XCPT_TRY_END "
Endz a try block.  See \*(L"Exception Handling\*(R" up in perlguts.
.IP "\s-1XCPT_TRY_START \s0" 8
.IX Xref "XCPT_TRY_START"
.IX Item "XCPT_TRY_START "
Starts a try block.  See \*(L"Exception Handling\*(R" up in perlguts.
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "dMARK" 8
.IX Xref "dMARK"
.IX Item "dMARK"
Declare a stack marker variable, \f(CW\*(C`mark\*(C'\fR, fo' tha \s-1XSUB. \s0 See \f(CW\*(C`MARK\*(C'\fR and
\&\f(CW\*(C`dORIGMARK\*(C'\fR.
.Sp
.Vb 1
\&                dMARK;
.Ve
.IP "dORIGMARK" 8
.IX Xref "dORIGMARK"
.IX Item "dORIGMARK"
Saves tha original gangsta stack mark fo' tha \s-1XSUB. \s0 See \f(CW\*(C`ORIGMARK\*(C'\fR.
.Sp
.Vb 1
\&                dORIGMARK;
.Ve
.IP "dSP" 8
.IX Xref "dSP"
.IX Item "dSP"
Declares a local copy of perlz stack pointa fo' tha \s-1XSUB,\s0 available via
the \f(CW\*(C`SP\*(C'\fR macro.  See \f(CW\*(C`SP\*(C'\fR.
.Sp
.Vb 1
\&                dSP;
.Ve
.IP "\s-1EXTEND \s0" 8
.IX Xref "EXTEND"
.IX Item "EXTEND "
Used ta extend tha argument stack fo' a \s-1XSUB\s0z return joints, n' you can put dat on yo' toast. Once
used, guarantees dat there is room fo' at least \f(CW\*(C`nitems\*(C'\fR ta be pushed
onto tha stack.
.Sp
.Vb 1
\&        void    EXTEND(SP, int nitems)
.Ve
.IP "\s-1MARK \s0" 8
.IX Xref "MARK"
.IX Item "MARK "
Stack marker variable fo' tha \s-1XSUB. \s0 See \f(CW\*(C`dMARK\*(C'\fR.
.IP "mPUSHi" 8
.IX Xref "mPUSHi"
.IX Item "mPUSHi"
Push a integer onto tha stack.  Da stack must have room fo' dis element.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHi\*(C'\fR, \f(CW\*(C`mXPUSHi\*(C'\fR n' \f(CW\*(C`XPUSHi\*(C'\fR.
.Sp
.Vb 1
\&        void    mPUSHi(IV iv)
.Ve
.IP "mPUSHn" 8
.IX Xref "mPUSHn"
.IX Item "mPUSHn"
Push a thugged-out double onto tha stack.  Da stack must have room fo' dis element.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHn\*(C'\fR, \f(CW\*(C`mXPUSHn\*(C'\fR n' \f(CW\*(C`XPUSHn\*(C'\fR.
.Sp
.Vb 1
\&        void    mPUSHn(NV nv)
.Ve
.IP "mPUSHp" 8
.IX Xref "mPUSHp"
.IX Item "mPUSHp"
Push a strang onto tha stack.  Da stack must have room fo' dis element.
Da \f(CW\*(C`len\*(C'\fR indicates tha length of tha string.  Do not use \f(CW\*(C`TARG\*(C'\fR.
See also \f(CW\*(C`PUSHp\*(C'\fR, \f(CW\*(C`mXPUSHp\*(C'\fR n' \f(CW\*(C`XPUSHp\*(C'\fR.
.Sp
.Vb 1
\&        void    mPUSHp(char* str, STRLEN len)
.Ve
.IP "mPUSHs" 8
.IX Xref "mPUSHs"
.IX Item "mPUSHs"
Push a \s-1SV\s0 onto tha stack n' mortalizes tha \s-1SV. \s0 Da stack must have room
for dis element.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHs\*(C'\fR n' \f(CW\*(C`mXPUSHs\*(C'\fR.
.Sp
.Vb 1
\&        void    mPUSHs(SV* sv)
.Ve
.IP "mPUSHu" 8
.IX Xref "mPUSHu"
.IX Item "mPUSHu"
Push a unsigned integer onto tha stack.  Da stack must have room fo' this
element.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHu\*(C'\fR, \f(CW\*(C`mXPUSHu\*(C'\fR n' \f(CW\*(C`XPUSHu\*(C'\fR.
.Sp
.Vb 1
\&        void    mPUSHu(UV uv)
.Ve
.IP "mXPUSHi" 8
.IX Xref "mXPUSHi"
.IX Item "mXPUSHi"
Push a integer onto tha stack, extendin tha stack if necessary.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHi\*(C'\fR, \f(CW\*(C`mPUSHi\*(C'\fR n' \f(CW\*(C`PUSHi\*(C'\fR.
.Sp
.Vb 1
\&        void    mXPUSHi(IV iv)
.Ve
.IP "mXPUSHn" 8
.IX Xref "mXPUSHn"
.IX Item "mXPUSHn"
Push a thugged-out double onto tha stack, extendin tha stack if necessary.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHn\*(C'\fR, \f(CW\*(C`mPUSHn\*(C'\fR n' \f(CW\*(C`PUSHn\*(C'\fR.
.Sp
.Vb 1
\&        void    mXPUSHn(NV nv)
.Ve
.IP "mXPUSHp" 8
.IX Xref "mXPUSHp"
.IX Item "mXPUSHp"
Push a strang onto tha stack, extendin tha stack if necessary.  Da \f(CW\*(C`len\*(C'\fR
indicates tha length of tha string.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHp\*(C'\fR,
\&\f(CW\*(C`mPUSHp\*(C'\fR n' \f(CW\*(C`PUSHp\*(C'\fR.
.Sp
.Vb 1
\&        void    mXPUSHp(char* str, STRLEN len)
.Ve
.IP "mXPUSHs" 8
.IX Xref "mXPUSHs"
.IX Item "mXPUSHs"
Push a \s-1SV\s0 onto tha stack, extendin tha stack if necessary n' mortalizes
the \s-1SV. \s0 Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHs\*(C'\fR n' \f(CW\*(C`mPUSHs\*(C'\fR.
.Sp
.Vb 1
\&        void    mXPUSHs(SV* sv)
.Ve
.IP "mXPUSHu" 8
.IX Xref "mXPUSHu"
.IX Item "mXPUSHu"
Push a unsigned integer onto tha stack, extendin tha stack if necessary.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHu\*(C'\fR, \f(CW\*(C`mPUSHu\*(C'\fR n' \f(CW\*(C`PUSHu\*(C'\fR.
.Sp
.Vb 1
\&        void    mXPUSHu(UV uv)
.Ve
.IP "\s-1ORIGMARK \s0" 8
.IX Xref "ORIGMARK"
.IX Item "ORIGMARK "
Da original gangsta stack mark fo' tha \s-1XSUB. \s0 See \f(CW\*(C`dORIGMARK\*(C'\fR.
.IP "POPi" 8
.IX Xref "POPi"
.IX Item "POPi"
Pops a integer off tha stack.
.Sp
.Vb 1
\&        IV      POPi
.Ve
.IP "POPl" 8
.IX Xref "POPl"
.IX Item "POPl"
Pops a long-ass off tha stack.
.Sp
.Vb 1
\&        long    POPl
.Ve
.IP "POPn" 8
.IX Xref "POPn"
.IX Item "POPn"
Pops a thugged-out double off tha stack.
.Sp
.Vb 1
\&        NV      POPn
.Ve
.IP "POPp" 8
.IX Xref "POPp"
.IX Item "POPp"
Pops a strang off tha stack.
.Sp
.Vb 1
\&        char*   POPp
.Ve
.IP "POPpbytex" 8
.IX Xref "POPpbytex"
.IX Item "POPpbytex"
Pops a strang off tha stack which must consist of bytes i.e. charactas < 256.
.Sp
.Vb 1
\&        char*   POPpbytex
.Ve
.IP "POPpx" 8
.IX Xref "POPpx"
.IX Item "POPpx"
Pops a strang off tha stack.  Identical ta POPp.  There is two names for
historical reasons.
.Sp
.Vb 1
\&        char*   POPpx
.Ve
.IP "POPs" 8
.IX Xref "POPs"
.IX Item "POPs"
Pops a \s-1SV\s0 off tha stack.
.Sp
.Vb 1
\&        SV*     POPs
.Ve
.IP "PUSHi" 8
.IX Xref "PUSHi"
.IX Item "PUSHi"
Push a integer onto tha stack.  Da stack must have room fo' dis element.
Handlez 'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be
called ta declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros ta 
return lists from \s-1XSUB\s0z \- peep \f(CW\*(C`mPUSHi\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`XPUSHi\*(C'\fR and
\&\f(CW\*(C`mXPUSHi\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHi(IV iv)
.Ve
.IP "\s-1PUSHMARK \s0" 8
.IX Xref "PUSHMARK"
.IX Item "PUSHMARK "
Openin bracket fo' arguments on a cold-ass lil callback.  See \f(CW\*(C`PUTBACK\*(C'\fR and
perlcall.
.Sp
.Vb 1
\&        void    PUSHMARK(SP)
.Ve
.IP "PUSHmortal" 8
.IX Xref "PUSHmortal"
.IX Item "PUSHmortal"
Push a freshly smoked up mortal \s-1SV\s0 onto tha stack.  Da stack must have room fo' this
element.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHs\*(C'\fR, \f(CW\*(C`XPUSHmortal\*(C'\fR n' \f(CW\*(C`XPUSHs\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHmortal()
.Ve
.IP "PUSHn" 8
.IX Xref "PUSHn"
.IX Item "PUSHn"
Push a thugged-out double onto tha stack.  Da stack must have room fo' dis element.
Handlez 'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be
called ta declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros to
return lists from \s-1XSUB\s0z \- peep \f(CW\*(C`mPUSHn\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`XPUSHn\*(C'\fR and
\&\f(CW\*(C`mXPUSHn\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHn(NV nv)
.Ve
.IP "PUSHp" 8
.IX Xref "PUSHp"
.IX Item "PUSHp"
Push a strang onto tha stack.  Da stack must have room fo' dis element.
Da \f(CW\*(C`len\*(C'\fR indicates tha length of tha string.  Handlez 'set' magic.  Uses
\&\f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be called ta declare dat shit.  Do not
call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros ta return lists from \s-1XSUB\s0z \- see
\&\f(CW\*(C`mPUSHp\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`XPUSHp\*(C'\fR n' \f(CW\*(C`mXPUSHp\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHp(char* str, STRLEN len)
.Ve
.IP "PUSHs" 8
.IX Xref "PUSHs"
.IX Item "PUSHs"
Push a \s-1SV\s0 onto tha stack.  Da stack must have room fo' dis element.
Do not handle 'set' magic.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`PUSHmortal\*(C'\fR,
\&\f(CW\*(C`XPUSHs\*(C'\fR n' \f(CW\*(C`XPUSHmortal\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHs(SV* sv)
.Ve
.IP "PUSHu" 8
.IX Xref "PUSHu"
.IX Item "PUSHu"
Push a unsigned integer onto tha stack.  Da stack must have room fo' this
element.  Handlez 'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR
should be called ta declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented
macros ta return lists from \s-1XSUB\s0z \- peep \f(CW\*(C`mPUSHu\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also
\&\f(CW\*(C`XPUSHu\*(C'\fR n' \f(CW\*(C`mXPUSHu\*(C'\fR.
.Sp
.Vb 1
\&        void    PUSHu(UV uv)
.Ve
.IP "\s-1PUTBACK \s0" 8
.IX Xref "PUTBACK"
.IX Item "PUTBACK "
Closin bracket fo' \s-1XSUB\s0 arguments, n' you can put dat on yo' toast.  This is probably handled by \f(CW\*(C`xsubpp\*(C'\fR.
See \f(CW\*(C`PUSHMARK\*(C'\fR n' perlcall fo' other uses.
.Sp
.Vb 1
\&                PUTBACK;
.Ve
.IP "\s-1SP \s0" 8
.IX Xref "SP"
.IX Item "SP "
Stack pointer n' shit.  This is probably handled by \f(CW\*(C`xsubpp\*(C'\fR.  See \f(CW\*(C`dSP\*(C'\fR and
\&\f(CW\*(C`SPAGAIN\*(C'\fR.
.IP "\s-1SPAGAIN \s0" 8
.IX Xref "SPAGAIN"
.IX Item "SPAGAIN "
Refetch tha stack pointer n' shit.  Used afta a cold-ass lil callback.  See perlcall.
.Sp
.Vb 1
\&                SPAGAIN;
.Ve
.IP "XPUSHi" 8
.IX Xref "XPUSHi"
.IX Item "XPUSHi"
Push a integer onto tha stack, extendin tha stack if necessary.  Handles
\&'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be called to
declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros ta return lists
from \s-1XSUB\s0z \- peep \f(CW\*(C`mXPUSHi\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`PUSHi\*(C'\fR n' \f(CW\*(C`mPUSHi\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHi(IV iv)
.Ve
.IP "XPUSHmortal" 8
.IX Xref "XPUSHmortal"
.IX Item "XPUSHmortal"
Push a freshly smoked up mortal \s-1SV\s0 onto tha stack, extendin tha stack if necessary.
Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHs\*(C'\fR, \f(CW\*(C`PUSHmortal\*(C'\fR n' \f(CW\*(C`PUSHs\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHmortal()
.Ve
.IP "XPUSHn" 8
.IX Xref "XPUSHn"
.IX Item "XPUSHn"
Push a thugged-out double onto tha stack, extendin tha stack if necessary.  Handles
\&'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be called to
declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros ta return lists
from \s-1XSUB\s0z \- peep \f(CW\*(C`mXPUSHn\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`PUSHn\*(C'\fR n' \f(CW\*(C`mPUSHn\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHn(NV nv)
.Ve
.IP "XPUSHp" 8
.IX Xref "XPUSHp"
.IX Item "XPUSHp"
Push a strang onto tha stack, extendin tha stack if necessary.  Da \f(CW\*(C`len\*(C'\fR
indicates tha length of tha string.  Handlez 'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so
\&\f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be called ta declare dat shit.  Do not call
multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros ta return lists from \s-1XSUB\s0z \- see
\&\f(CW\*(C`mXPUSHp\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`PUSHp\*(C'\fR n' \f(CW\*(C`mPUSHp\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHp(char* str, STRLEN len)
.Ve
.IP "XPUSHs" 8
.IX Xref "XPUSHs"
.IX Item "XPUSHs"
Push a \s-1SV\s0 onto tha stack, extendin tha stack if necessary.  Do not
handle 'set' magic.  Do not use \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`XPUSHmortal\*(C'\fR,
\&\f(CW\*(C`PUSHs\*(C'\fR n' \f(CW\*(C`PUSHmortal\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHs(SV* sv)
.Ve
.IP "XPUSHu" 8
.IX Xref "XPUSHu"
.IX Item "XPUSHu"
Push a unsigned integer onto tha stack, extendin tha stack if necessary.
Handlez 'set' magic.  Uses \f(CW\*(C`TARG\*(C'\fR, so \f(CW\*(C`dTARGET\*(C'\fR or \f(CW\*(C`dXSTARG\*(C'\fR should be
called ta declare dat shit.  Do not call multiple \f(CW\*(C`TARG\*(C'\fR\-oriented macros to
return lists from \s-1XSUB\s0z \- peep \f(CW\*(C`mXPUSHu\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`PUSHu\*(C'\fR and
\&\f(CW\*(C`mPUSHu\*(C'\fR.
.Sp
.Vb 1
\&        void    XPUSHu(UV uv)
.Ve
.IP "\s-1XSRETURN \s0" 8
.IX Xref "XSRETURN"
.IX Item "XSRETURN "
Return from \s-1XSUB,\s0 indicatin number of shit on tha stack.  This is usually
handled by \f(CW\*(C`xsubpp\*(C'\fR.
.Sp
.Vb 1
\&        void    XSRETURN(int nitems)
.Ve
.IP "\s-1XSRETURN_EMPTY \s0" 8
.IX Xref "XSRETURN_EMPTY"
.IX Item "XSRETURN_EMPTY "
Return a empty list from a \s-1XSUB\s0 immediately.
.Sp
.Vb 1
\&                XSRETURN_EMPTY;
.Ve
.IP "\s-1XSRETURN_IV \s0" 8
.IX Xref "XSRETURN_IV"
.IX Item "XSRETURN_IV "
Return a integer from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mIV\*(C'\fR.
.Sp
.Vb 1
\&        void    XSRETURN_IV(IV iv)
.Ve
.IP "\s-1XSRETURN_NO \s0" 8
.IX Xref "XSRETURN_NO"
.IX Item "XSRETURN_NO "
Return \f(CW&PL_sv_no\fR from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mNO\*(C'\fR.
.Sp
.Vb 1
\&                XSRETURN_NO;
.Ve
.IP "\s-1XSRETURN_NV \s0" 8
.IX Xref "XSRETURN_NV"
.IX Item "XSRETURN_NV "
Return a thugged-out double from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mNV\*(C'\fR.
.Sp
.Vb 1
\&        void    XSRETURN_NV(NV nv)
.Ve
.IP "\s-1XSRETURN_PV \s0" 8
.IX Xref "XSRETURN_PV"
.IX Item "XSRETURN_PV "
Return a cold-ass lil copy of a strang from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mPV\*(C'\fR.
.Sp
.Vb 1
\&        void    XSRETURN_PV(char* str)
.Ve
.IP "\s-1XSRETURN_UNDEF \s0" 8
.IX Xref "XSRETURN_UNDEF"
.IX Item "XSRETURN_UNDEF "
Return \f(CW&PL_sv_undef\fR from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mUNDEF\*(C'\fR.
.Sp
.Vb 1
\&                XSRETURN_UNDEF;
.Ve
.IP "\s-1XSRETURN_UV \s0" 8
.IX Xref "XSRETURN_UV"
.IX Item "XSRETURN_UV "
Return a integer from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mUV\*(C'\fR.
.Sp
.Vb 1
\&        void    XSRETURN_UV(IV uv)
.Ve
.IP "\s-1XSRETURN_YES \s0" 8
.IX Xref "XSRETURN_YES"
.IX Item "XSRETURN_YES "
Return \f(CW&PL_sv_yes\fR from a \s-1XSUB\s0 immediately.  Uses \f(CW\*(C`XST_mYES\*(C'\fR.
.Sp
.Vb 1
\&                XSRETURN_YES;
.Ve
.IP "XST_mIV" 8
.IX Xref "XST_mIV"
.IX Item "XST_mIV"
Place a integer tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on tha stack.  The
value is stored up in a freshly smoked up mortal \s-1SV.\s0
.Sp
.Vb 1
\&        void    XST_mIV(int pos, IV iv)
.Ve
.IP "XST_mNO" 8
.IX Xref "XST_mNO"
.IX Item "XST_mNO"
Place \f(CW&PL_sv_no\fR tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on the
stack.
.Sp
.Vb 1
\&        void    XST_mNO(int pos)
.Ve
.IP "XST_mNV" 8
.IX Xref "XST_mNV"
.IX Item "XST_mNV"
Place a thugged-out double tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on tha stack.  Da value
is stored up in a freshly smoked up mortal \s-1SV.\s0
.Sp
.Vb 1
\&        void    XST_mNV(int pos, NV nv)
.Ve
.IP "XST_mPV" 8
.IX Xref "XST_mPV"
.IX Item "XST_mPV"
Place a cold-ass lil copy of a strang tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on tha stack. 
Da value is stored up in a freshly smoked up mortal \s-1SV.\s0
.Sp
.Vb 1
\&        void    XST_mPV(int pos, char* str)
.Ve
.IP "XST_mUNDEF" 8
.IX Xref "XST_mUNDEF"
.IX Item "XST_mUNDEF"
Place \f(CW&PL_sv_undef\fR tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on the
stack.
.Sp
.Vb 1
\&        void    XST_mUNDEF(int pos)
.Ve
.IP "XST_mYES" 8
.IX Xref "XST_mYES"
.IX Item "XST_mYES"
Place \f(CW&PL_sv_yes\fR tha fuck into tha specified posizzle \f(CW\*(C`pos\*(C'\fR on the
stack.
.Sp
.Vb 1
\&        void    XST_mYES(int pos)
.Ve
.SH "SV Flags"
.IX Header "SV Flags"
.IP "svtype" 8
.IX Xref "svtype"
.IX Item "svtype"
An enum of flags fo' Perl types.  These is found up in tha file \fBsv.h\fR
in tha \f(CW\*(C`svtype\*(C'\fR enum.  Test these flags wit tha \f(CW\*(C`SvTYPE\*(C'\fR macro.
.Sp
Da types are:
.Sp
.Vb 10
\&    SVt_NULL
\&    SVt_BIND (unused)
\&    SVt_IV
\&    SVt_NV
\&    SVt_RV
\&    SVt_PV
\&    SVt_PVIV
\&    SVt_PVNV
\&    SVt_PVMG
\&    SVt_REGEXP
\&    SVt_PVGV
\&    SVt_PVLV
\&    SVt_PVAV
\&    SVt_PVHV
\&    SVt_PVCV
\&    SVt_PVFM
\&    SVt_PVIO
.Ve
.Sp
These is most easily explained from tha bottom up.
.Sp
SVt_PVIO is fo' I/O objects, SVt_PVFM fo' formats, SVt_PVCV for
subroutines, SVt_PVHV fo' hashes n' SVt_PVAV fo' arrays.
.Sp
All tha others is scalar types, dat is, thangs dat can be bound ta a
\&\f(CW\*(C`$\*(C'\fR variable.  For these, tha internal types is mostly orthogonal to
types up in tha Perl language.
.Sp
Hence, checkin \f(CW\*(C`SvTYPE(sv) < SVt_PVAV\*(C'\fR is tha dopest way ta peep whether
suttin' be a scalar.
.Sp
SVt_PVGV represents a typeglob.  If !SvFAKE(sv), then it aint nuthin but a real,
incoercible typeglob.  If SvFAKE(sv), then it aint nuthin but a scalar ta which a
typeglob has been assigned. Y'all KNOW dat shit, muthafucka!  Assignin ta it again n' again n' again will stop it from being
a typeglob.  SVt_PVLV represents a scalar dat delegates ta another scalar
behind tha scenes.  It be used, e.g., fo' tha return value of \f(CW\*(C`substr\*(C'\fR and
for tied hash n' array elements, n' you can put dat on yo' toast.  It can hold any scalar value, including
a typeglob. Right back up in yo muthafuckin ass. SVt_REGEXP is fo' regular expressions.
.Sp
SVt_PVMG represents a \*(L"normal\*(R" scalar (not a typeglob, regular expression,
or delegate).  Since most scalars do not need all tha internal fieldz of a
\&\s-1PVMG,\s0 we save memory by allocatin smalla structs when possible.  All the
other types is just simpla formz of SVt_PVMG, wit fewer internal fields.
 SVt_NULL can only hold undef.  SVt_IV can hold undef, a integer, or a
reference.  (SVt_RV be a alias fo' SVt_IV, which exists fo' backward
compatibility.)  SVt_NV can hold any of dem or a thugged-out double.  SVt_PV can only
hold undef or a string.  SVt_PVIV be a superset of SVt_PV n' SVt_IV.
SVt_PVNV is similar. Shiiit, dis aint no joke.  SVt_PVMG can hold anythang SVt_PVNV can hold yo, but it
can yo, but aint gots to, be pimped or magical.
.IP "SVt_IV" 8
.IX Xref "SVt_IV"
.IX Item "SVt_IV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_NULL" 8
.IX Xref "SVt_NULL"
.IX Item "SVt_NULL"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_NV" 8
.IX Xref "SVt_NV"
.IX Item "SVt_NV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_PV" 8
.IX Xref "SVt_PV"
.IX Item "SVt_PV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_PVAV" 8
.IX Xref "SVt_PVAV"
.IX Item "SVt_PVAV"
Type flag fo' arrays.  See \*(L"svtype\*(R".
.IP "SVt_PVCV" 8
.IX Xref "SVt_PVCV"
.IX Item "SVt_PVCV"
Type flag fo' subroutines.  See \*(L"svtype\*(R".
.IP "SVt_PVFM" 8
.IX Xref "SVt_PVFM"
.IX Item "SVt_PVFM"
Type flag fo' formats, n' you can put dat on yo' toast.  See \*(L"svtype\*(R".
.IP "SVt_PVGV" 8
.IX Xref "SVt_PVGV"
.IX Item "SVt_PVGV"
Type flag fo' typeglobs.  See \*(L"svtype\*(R".
.IP "SVt_PVHV" 8
.IX Xref "SVt_PVHV"
.IX Item "SVt_PVHV"
Type flag fo' hashes.  See \*(L"svtype\*(R".
.IP "SVt_PVIO" 8
.IX Xref "SVt_PVIO"
.IX Item "SVt_PVIO"
Type flag fo' I/O objects, n' you can put dat on yo' toast.  See \*(L"svtype\*(R".
.IP "SVt_PVIV" 8
.IX Xref "SVt_PVIV"
.IX Item "SVt_PVIV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_PVLV" 8
.IX Xref "SVt_PVLV"
.IX Item "SVt_PVLV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_PVMG" 8
.IX Xref "SVt_PVMG"
.IX Item "SVt_PVMG"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_PVNV" 8
.IX Xref "SVt_PVNV"
.IX Item "SVt_PVNV"
Type flag fo' scalars.  See \*(L"svtype\*(R".
.IP "SVt_REGEXP" 8
.IX Xref "SVt_REGEXP"
.IX Item "SVt_REGEXP"
Type flag fo' regular expressions.  See \*(L"svtype\*(R".
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "boolSV" 8
.IX Xref "boolSV"
.IX Item "boolSV"
Returns a legit \s-1SV\s0 if \f(CW\*(C`b\*(C'\fR be a legit value, or a gangbangin' false \s-1SV\s0 if \f(CW\*(C`b\*(C'\fR is 0.
.Sp
See also \f(CW\*(C`PL_sv_yes\*(C'\fR n' \f(CW\*(C`PL_sv_no\*(C'\fR.
.Sp
.Vb 1
\&        SV *    boolSV(bool b)
.Ve
.IP "croak_xs_usage" 8
.IX Xref "croak_xs_usage"
.IX Item "croak_xs_usage"
A specialised variant of \f(CW\*(C`croak()\*(C'\fR fo' emittin tha usage message fo' xsubs
.Sp
.Vb 1
\&    croak_xs_usage(cv, "eee_yow");
.Ve
.Sp
works up tha package name n' subroutine name from \f(CW\*(C`cv\*(C'\fR, n' then calls
\&\f(CW\*(C`croak()\*(C'\fR yo. Hence if \f(CW\*(C`cv\*(C'\fR is \f(CW&ouch::awk\fR, it would call \f(CW\*(C`croak\*(C'\fR as:
.Sp
.Vb 1
\&    Perl_croak(aTHX_ "Usage: %"SVf"::%"SVf"(%s)", "ouch" "awk", "eee_yow");
\&
\&        void    croak_xs_usage(const CV *const cv,
\&                               const char *const params)
.Ve
.IP "get_sv" 8
.IX Xref "get_sv"
.IX Item "get_sv"
Returns tha \s-1SV\s0 of tha specified Perl scalar. Shiiit, dis aint no joke.  \f(CW\*(C`flags\*(C'\fR is passed to
\&\f(CW\*(C`gv_fetchpv\*(C'\fR. If \f(CW\*(C`GV_ADD\*(C'\fR is set n' the
Perl variable do not exist then it is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \f(CW\*(C`flags\*(C'\fR is zero
and tha variable do not exist then \s-1NULL\s0 is returned.
.Sp
\&\s-1NOTE:\s0 tha perl_ form of dis function is deprecated.
.Sp
.Vb 1
\&        SV*     get_sv(const char *name, I32 flags)
.Ve
.IP "newRV_inc" 8
.IX Xref "newRV_inc"
.IX Item "newRV_inc"
Creates a \s-1RV\s0 wrapper fo' a \s-1SV. \s0 Da reference count fo' tha original gangsta \s-1SV\s0 is
incremented.
.Sp
.Vb 1
\&        SV*     newRV_inc(SV* sv)
.Ve
.IP "newSVpadname" 8
.IX Xref "newSVpadname"
.IX Item "newSVpadname"
Creates a freshly smoked up \s-1SV\s0 containin tha pad name.  This is currently identical
to \f(CW\*(C`newSVsv\*(C'\fR yo, but pad names may cease bein SVs at some point, so
\&\f(CW\*(C`newSVpadname\*(C'\fR is preferable.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SV*     newSVpadname(PADNAME *pn)
.Ve
.IP "newSVpvn_utf8" 8
.IX Xref "newSVpvn_utf8"
.IX Item "newSVpvn_utf8"
Creates a freshly smoked up \s-1SV\s0 n' copies a strang tha fuck into dat shit.  If utf8 is true, calls
\&\f(CW\*(C`SvUTF8_on\*(C'\fR on tha freshly smoked up \s-1SV. \s0 Implemented as a wrapper round \f(CW\*(C`newSVpvn_flags\*(C'\fR.
.Sp
.Vb 2
\&        SV*     newSVpvn_utf8(NULLOK const char* s, STRLEN len,
\&                              U32 utf8)
.Ve
.IP "SvCUR" 8
.IX Xref "SvCUR"
.IX Item "SvCUR"
Returns tha length of tha strang which is up in tha \s-1SV. \s0 See \f(CW\*(C`SvLEN\*(C'\fR.
.Sp
.Vb 1
\&        STRLEN  SvCUR(SV* sv)
.Ve
.IP "SvCUR_set" 8
.IX Xref "SvCUR_set"
.IX Item "SvCUR_set"
Set tha current length of tha strang which is up in tha \s-1SV. \s0 See \f(CW\*(C`SvCUR\*(C'\fR
and \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvCUR_set(SV* sv, STRLEN len)
.Ve
.IP "SvEND" 8
.IX Xref "SvEND"
.IX Item "SvEND"
Returns a pointa ta tha spot just afta tha last characta in
the strang which is up in tha \s-1SV,\s0 where there is probably a trailing
null (even though Perl scalars do not strictly require it).
See \f(CW\*(C`SvCUR\*(C'\fR.  Access tha characta as *(SvEND(sv)).
.Sp
Warning: If \f(CW\*(C`SvCUR\*(C'\fR is equal ta \f(CW\*(C`SvLEN\*(C'\fR, then \f(CW\*(C`SvEND\*(C'\fR points to
unallocated memory.
.Sp
.Vb 1
\&        char*   SvEND(SV* sv)
.Ve
.IP "SvGAMAGIC" 8
.IX Xref "SvGAMAGIC"
.IX Item "SvGAMAGIC"
Returns legit if tha \s-1SV\s0 has git magic or
overloading.  If either is legit then
the scalar be actizzle data, n' has tha potential ta return a freshly smoked up value every
time it be accessed. Y'all KNOW dat shit, muthafucka!  Hence you must be careful to
only read it once per user logical operation n' work
with dat returned value.  If neither is legit then
the scalarz value cannot chizzle unless freestyled to.
.Sp
.Vb 1
\&        U32     SvGAMAGIC(SV* sv)
.Ve
.IP "SvGROW" 8
.IX Xref "SvGROW"
.IX Item "SvGROW"
Expandz tha characta buffer up in tha \s-1SV\s0 so dat it has room fo' the
indicated number of bytes (remember ta reserve space fo' a extra trailing
\&\s-1NUL\s0 character).  Calls \f(CW\*(C`sv_grow\*(C'\fR ta big-ass up tha expansion if necessary.
Returns a pointa ta tha characta buffer n' shit. \s-1SV\s0 must be of type >= SVt_PV. One
alternatizzle is ta booty-call \f(CW\*(C`sv_grow\*(C'\fR if yo ass is not shizzle of tha type of \s-1SV.\s0
.Sp
.Vb 1
\&        char *  SvGROW(SV* sv, STRLEN len)
.Ve
.IP "SvIOK" 8
.IX Xref "SvIOK"
.IX Item "SvIOK"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a integer.
.Sp
.Vb 1
\&        U32     SvIOK(SV* sv)
.Ve
.IP "SvIOKp" 8
.IX Xref "SvIOKp"
.IX Item "SvIOKp"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a integer n' shit.  Checks
the \fBprivate\fR setting.  Use \f(CW\*(C`SvIOK\*(C'\fR instead.
.Sp
.Vb 1
\&        U32     SvIOKp(SV* sv)
.Ve
.IP "SvIOK_notUV" 8
.IX Xref "SvIOK_notUV"
.IX Item "SvIOK_notUV"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 gotz nuff a signed integer.
.Sp
.Vb 1
\&        bool    SvIOK_notUV(SV* sv)
.Ve
.IP "SvIOK_off" 8
.IX Xref "SvIOK_off"
.IX Item "SvIOK_off"
Unsets tha \s-1IV\s0 statuz of a \s-1SV.\s0
.Sp
.Vb 1
\&        void    SvIOK_off(SV* sv)
.Ve
.IP "SvIOK_on" 8
.IX Xref "SvIOK_on"
.IX Item "SvIOK_on"
Tells a \s-1SV\s0 dat it be a integer.
.Sp
.Vb 1
\&        void    SvIOK_on(SV* sv)
.Ve
.IP "SvIOK_only" 8
.IX Xref "SvIOK_only"
.IX Item "SvIOK_only"
Tells a \s-1SV\s0 dat it be a integer n' disablez all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        void    SvIOK_only(SV* sv)
.Ve
.IP "SvIOK_only_UV" 8
.IX Xref "SvIOK_only_UV"
.IX Item "SvIOK_only_UV"
Tells a \s-1SV\s0 dat it be a unsigned integer n' disablez all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        void    SvIOK_only_UV(SV* sv)
.Ve
.IP "SvIOK_UV" 8
.IX Xref "SvIOK_UV"
.IX Item "SvIOK_UV"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 gotz nuff a integer dat must be
interpreted as unsigned. Y'all KNOW dat shit, muthafucka!  A non-negatizzle integer whose value is within the
range of both a \s-1IV\s0 n' a \s-1UV\s0 may be be flagged as either SvUOK or \s-1SVIOK.\s0
.Sp
.Vb 1
\&        bool    SvIOK_UV(SV* sv)
.Ve
.IP "SvIsCOW" 8
.IX Xref "SvIsCOW"
.IX Item "SvIsCOW"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 is Copy-On-Write (either shared
hash key scalars, or full Copy On Write scalars if 5.9.0 is configured for
\&\s-1COW\s0).
.Sp
.Vb 1
\&        bool    SvIsCOW(SV* sv)
.Ve
.IP "SvIsCOW_shared_hash" 8
.IX Xref "SvIsCOW_shared_hash"
.IX Item "SvIsCOW_shared_hash"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 is Copy-On-Write shared hash key
scalar.
.Sp
.Vb 1
\&        bool    SvIsCOW_shared_hash(SV* sv)
.Ve
.IP "SvIV" 8
.IX Xref "SvIV"
.IX Item "SvIV"
Coerces tha given \s-1SV\s0 ta a integer n' returns dat shit.  See \f(CW\*(C`SvIVx\*(C'\fR fo' a
version which guarantees ta evaluate sv only once.
.Sp
.Vb 1
\&        IV      SvIV(SV* sv)
.Ve
.IP "SvIVX" 8
.IX Xref "SvIVX"
.IX Item "SvIVX"
Returns tha raw value up in tha \s-1SV\s0z \s-1IV\s0 slot, without checks or conversions.
Only use when yo ass is shizzle SvIOK is true.  See also \f(CW\*(C`SvIV()\*(C'\fR.
.Sp
.Vb 1
\&        IV      SvIVX(SV* sv)
.Ve
.IP "SvIVx" 8
.IX Xref "SvIVx"
.IX Item "SvIVx"
Coerces tha given \s-1SV\s0 ta a integer n' returns dat shit.
Guarantees ta evaluate \f(CW\*(C`sv\*(C'\fR only once.  Only use
this if \f(CW\*(C`sv\*(C'\fR be a expression wit side effects,
otherwise use tha mo' efficient \f(CW\*(C`SvIV\*(C'\fR.
.Sp
.Vb 1
\&        IV      SvIVx(SV* sv)
.Ve
.IP "SvIV_nomg" 8
.IX Xref "SvIV_nomg"
.IX Item "SvIV_nomg"
Like \f(CW\*(C`SvIV\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        IV      SvIV_nomg(SV* sv)
.Ve
.IP "SvIV_set" 8
.IX Xref "SvIV_set"
.IX Item "SvIV_set"
Set tha value of tha \s-1IV\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  It be possible ta perform
the same function of dis macro wit a lvalue assignment ta \f(CW\*(C`SvIVX\*(C'\fR.
With future Perls, however, it is ghon be mo' efficient ta use 
\&\f(CW\*(C`SvIV_set\*(C'\fR instead of tha lvalue assignment ta \f(CW\*(C`SvIVX\*(C'\fR.
.Sp
.Vb 1
\&        void    SvIV_set(SV* sv, IV val)
.Ve
.IP "SvLEN" 8
.IX Xref "SvLEN"
.IX Item "SvLEN"
Returns tha size of tha strang buffer up in tha \s-1SV,\s0 not includin any part
attributable ta \f(CW\*(C`SvOOK\*(C'\fR.  See \f(CW\*(C`SvCUR\*(C'\fR.
.Sp
.Vb 1
\&        STRLEN  SvLEN(SV* sv)
.Ve
.IP "SvLEN_set" 8
.IX Xref "SvLEN_set"
.IX Item "SvLEN_set"
Set tha actual length of tha strang which is up in tha \s-1SV. \s0 See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvLEN_set(SV* sv, STRLEN len)
.Ve
.IP "SvMAGIC_set" 8
.IX Xref "SvMAGIC_set"
.IX Item "SvMAGIC_set"
Set tha value of tha \s-1MAGIC\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvMAGIC_set(SV* sv, MAGIC* val)
.Ve
.IP "SvNIOK" 8
.IX Xref "SvNIOK"
.IX Item "SvNIOK"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a number, integer or
double.
.Sp
.Vb 1
\&        U32     SvNIOK(SV* sv)
.Ve
.IP "SvNIOKp" 8
.IX Xref "SvNIOKp"
.IX Item "SvNIOKp"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a number, integer or
double.  Checks tha \fBprivate\fR setting.  Use \f(CW\*(C`SvNIOK\*(C'\fR instead.
.Sp
.Vb 1
\&        U32     SvNIOKp(SV* sv)
.Ve
.IP "SvNIOK_off" 8
.IX Xref "SvNIOK_off"
.IX Item "SvNIOK_off"
Unsets tha \s-1NV/IV\s0 statuz of a \s-1SV.\s0
.Sp
.Vb 1
\&        void    SvNIOK_off(SV* sv)
.Ve
.IP "SvNOK" 8
.IX Xref "SvNOK"
.IX Item "SvNOK"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a thugged-out double.
.Sp
.Vb 1
\&        U32     SvNOK(SV* sv)
.Ve
.IP "SvNOKp" 8
.IX Xref "SvNOKp"
.IX Item "SvNOKp"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a thugged-out double.  Checks the
\&\fBprivate\fR setting.  Use \f(CW\*(C`SvNOK\*(C'\fR instead.
.Sp
.Vb 1
\&        U32     SvNOKp(SV* sv)
.Ve
.IP "SvNOK_off" 8
.IX Xref "SvNOK_off"
.IX Item "SvNOK_off"
Unsets tha \s-1NV\s0 statuz of a \s-1SV.\s0
.Sp
.Vb 1
\&        void    SvNOK_off(SV* sv)
.Ve
.IP "SvNOK_on" 8
.IX Xref "SvNOK_on"
.IX Item "SvNOK_on"
Tells a \s-1SV\s0 dat it aint nuthin but a thugged-out double.
.Sp
.Vb 1
\&        void    SvNOK_on(SV* sv)
.Ve
.IP "SvNOK_only" 8
.IX Xref "SvNOK_only"
.IX Item "SvNOK_only"
Tells a \s-1SV\s0 dat it aint nuthin but a thugged-out double n' disablez all other \s-1OK\s0 bits.
.Sp
.Vb 1
\&        void    SvNOK_only(SV* sv)
.Ve
.IP "SvNV" 8
.IX Xref "SvNV"
.IX Item "SvNV"
Coerce tha given \s-1SV\s0 ta a thugged-out double n' return dat shit.  See \f(CW\*(C`SvNVx\*(C'\fR fo' a version
which guarantees ta evaluate sv only once.
.Sp
.Vb 1
\&        NV      SvNV(SV* sv)
.Ve
.IP "SvNVX" 8
.IX Xref "SvNVX"
.IX Item "SvNVX"
Returns tha raw value up in tha \s-1SV\s0z \s-1NV\s0 slot, without checks or conversions.
Only use when yo ass is shizzle SvNOK is true.  See also \f(CW\*(C`SvNV()\*(C'\fR.
.Sp
.Vb 1
\&        NV      SvNVX(SV* sv)
.Ve
.IP "SvNVx" 8
.IX Xref "SvNVx"
.IX Item "SvNVx"
Coerces tha given \s-1SV\s0 ta a thugged-out double n' returns dat shit.
Guarantees ta evaluate \f(CW\*(C`sv\*(C'\fR only once.  Only use
this if \f(CW\*(C`sv\*(C'\fR be a expression wit side effects,
otherwise use tha mo' efficient \f(CW\*(C`SvNV\*(C'\fR.
.Sp
.Vb 1
\&        NV      SvNVx(SV* sv)
.Ve
.IP "SvNV_nomg" 8
.IX Xref "SvNV_nomg"
.IX Item "SvNV_nomg"
Like \f(CW\*(C`SvNV\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        NV      SvNV_nomg(SV* sv)
.Ve
.IP "SvNV_set" 8
.IX Xref "SvNV_set"
.IX Item "SvNV_set"
Set tha value of tha \s-1NV\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvNV_set(SV* sv, NV val)
.Ve
.IP "SvOK" 8
.IX Xref "SvOK"
.IX Item "SvOK"
Returns a U32 value indicatin whether tha value is defined. Y'all KNOW dat shit, muthafucka! This is
only meaningful fo' scalars.
.Sp
.Vb 1
\&        U32     SvOK(SV* sv)
.Ve
.IP "SvOOK" 8
.IX Xref "SvOOK"
.IX Item "SvOOK"
Returns a U32 indicatin whether tha pointa ta tha strang buffer is offset.
This hack is used internally ta speed up removal of charactas from the
beginnin of a SvPV.  When SvOOK is true, then tha start of the
allocated strang buffer is straight-up \f(CW\*(C`SvOOK_offset()\*(C'\fR bytes before SvPVX.
This offset used ta be stored up in SvIVX yo, but is now stored within tha spare
part of tha buffer.
.Sp
.Vb 1
\&        U32     SvOOK(SV* sv)
.Ve
.IP "SvOOK_offset" 8
.IX Xref "SvOOK_offset"
.IX Item "SvOOK_offset"
Readz tha fuck into \fIlen\fR tha offset from SvPVX back ta tha legit start of the
allocated buffer, which is ghon be non-zero if \f(CW\*(C`sv_chop\*(C'\fR has been used to
efficiently remove charactas from start of tha buffer n' shit.  Implemented as a
macro, which takes tha address of \fIlen\fR, which must be of type \f(CW\*(C`STRLEN\*(C'\fR.
Evaluates \fIsv\fR mo' than once.  Sets \fIlen\fR ta 0 if \f(CW\*(C`SvOOK(sv)\*(C'\fR is false.
.Sp
.Vb 1
\&        void    SvOOK_offset(NN SV*sv, STRLEN len)
.Ve
.IP "SvPOK" 8
.IX Xref "SvPOK"
.IX Item "SvPOK"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a cold-ass lil character
string.
.Sp
.Vb 1
\&        U32     SvPOK(SV* sv)
.Ve
.IP "SvPOKp" 8
.IX Xref "SvPOKp"
.IX Item "SvPOKp"
Returns a U32 value indicatin whether tha \s-1SV\s0 gotz nuff a cold-ass lil characta string.
Checks tha \fBprivate\fR setting.  Use \f(CW\*(C`SvPOK\*(C'\fR instead.
.Sp
.Vb 1
\&        U32     SvPOKp(SV* sv)
.Ve
.IP "SvPOK_off" 8
.IX Xref "SvPOK_off"
.IX Item "SvPOK_off"
Unsets tha \s-1PV\s0 statuz of a \s-1SV.\s0
.Sp
.Vb 1
\&        void    SvPOK_off(SV* sv)
.Ve
.IP "SvPOK_on" 8
.IX Xref "SvPOK_on"
.IX Item "SvPOK_on"
Tells a \s-1SV\s0 dat it aint nuthin but a string.
.Sp
.Vb 1
\&        void    SvPOK_on(SV* sv)
.Ve
.IP "SvPOK_only" 8
.IX Xref "SvPOK_only"
.IX Item "SvPOK_only"
Tells a \s-1SV\s0 dat it aint nuthin but a strang n' disablez all other \s-1OK\s0 bits.
Will also turn off tha \s-1UTF\-8\s0 status.
.Sp
.Vb 1
\&        void    SvPOK_only(SV* sv)
.Ve
.IP "SvPOK_only_UTF8" 8
.IX Xref "SvPOK_only_UTF8"
.IX Item "SvPOK_only_UTF8"
Tells a \s-1SV\s0 dat it aint nuthin but a strang n' disablez all other \s-1OK\s0 bits,
and leaves tha \s-1UTF\-8\s0 status as it was.
.Sp
.Vb 1
\&        void    SvPOK_only_UTF8(SV* sv)
.Ve
.IP "SvPV" 8
.IX Xref "SvPV"
.IX Item "SvPV"
Returns a pointa ta tha strang up in tha \s-1SV,\s0 or a stringified form of
the \s-1SV\s0 if tha \s-1SV\s0 do not contain a string.  Da \s-1SV\s0 may cache the
stringified version becomin \f(CW\*(C`SvPOK\*(C'\fR.  Handlez 'get' magic.  See also
\&\f(CW\*(C`SvPVx\*(C'\fR fo' a version which guarantees ta evaluate sv only once.
.Sp
Note dat there is no guarantee dat tha return value of \f(CW\*(C`SvPV()\*(C'\fR is
equal ta \f(CW\*(C`SvPVX(sv)\*(C'\fR, or dat \f(CW\*(C`SvPVX(sv)\*(C'\fR gotz nuff valid data, or that
successive calls ta \f(CW\*(C`SvPV(sv)) will return tha same pointa value each
time. This is cuz of tha way dat thangs like overloadin and
Copy\-On\-Write is handled. Y'all KNOW dat shit, muthafucka!  In these cases, tha return value may point to
a temporary buffer or similar. Shiiit, dis aint no joke.  If you straight-up need tha SvPVX field to
be valid (for example, if you intend ta write ta it), then see
"SvPV_force".\*(C'\fR
.Sp
.Vb 1
\&        char*   SvPV(SV* sv, STRLEN len)
.Ve
.IP "SvPVbyte" 8
.IX Xref "SvPVbyte"
.IX Item "SvPVbyte"
Like \f(CW\*(C`SvPV\*(C'\fR yo, but converts sv ta byte representation first if necessary.
.Sp
.Vb 1
\&        char*   SvPVbyte(SV* sv, STRLEN len)
.Ve
.IP "SvPVbytex" 8
.IX Xref "SvPVbytex"
.IX Item "SvPVbytex"
Like \f(CW\*(C`SvPV\*(C'\fR yo, but converts sv ta byte representation first if necessary.
Guarantees ta evaluate sv only once; use tha mo' efficient \f(CW\*(C`SvPVbyte\*(C'\fR
otherwise.
.Sp
.Vb 1
\&        char*   SvPVbytex(SV* sv, STRLEN len)
.Ve
.IP "SvPVbytex_force" 8
.IX Xref "SvPVbytex_force"
.IX Item "SvPVbytex_force"
Like \f(CW\*(C`SvPV_force\*(C'\fR yo, but converts sv ta byte representation first if necessary.
Guarantees ta evaluate sv only once; use tha mo' efficient \f(CW\*(C`SvPVbyte_force\*(C'\fR
otherwise.
.Sp
.Vb 1
\&        char*   SvPVbytex_force(SV* sv, STRLEN len)
.Ve
.IP "SvPVbyte_force" 8
.IX Xref "SvPVbyte_force"
.IX Item "SvPVbyte_force"
Like \f(CW\*(C`SvPV_force\*(C'\fR yo, but converts sv ta byte representation first if necessary.
.Sp
.Vb 1
\&        char*   SvPVbyte_force(SV* sv, STRLEN len)
.Ve
.IP "SvPVbyte_nolen" 8
.IX Xref "SvPVbyte_nolen"
.IX Item "SvPVbyte_nolen"
Like \f(CW\*(C`SvPV_nolen\*(C'\fR yo, but converts sv ta byte representation first if necessary.
.Sp
.Vb 1
\&        char*   SvPVbyte_nolen(SV* sv)
.Ve
.IP "SvPVutf8" 8
.IX Xref "SvPVutf8"
.IX Item "SvPVutf8"
Like \f(CW\*(C`SvPV\*(C'\fR yo, but converts sv ta utf8 first if necessary.
.Sp
.Vb 1
\&        char*   SvPVutf8(SV* sv, STRLEN len)
.Ve
.IP "SvPVutf8x" 8
.IX Xref "SvPVutf8x"
.IX Item "SvPVutf8x"
Like \f(CW\*(C`SvPV\*(C'\fR yo, but converts sv ta utf8 first if necessary.
Guarantees ta evaluate sv only once; use tha mo' efficient \f(CW\*(C`SvPVutf8\*(C'\fR
otherwise.
.Sp
.Vb 1
\&        char*   SvPVutf8x(SV* sv, STRLEN len)
.Ve
.IP "SvPVutf8x_force" 8
.IX Xref "SvPVutf8x_force"
.IX Item "SvPVutf8x_force"
Like \f(CW\*(C`SvPV_force\*(C'\fR yo, but converts sv ta utf8 first if necessary.
Guarantees ta evaluate sv only once; use tha mo' efficient \f(CW\*(C`SvPVutf8_force\*(C'\fR
otherwise.
.Sp
.Vb 1
\&        char*   SvPVutf8x_force(SV* sv, STRLEN len)
.Ve
.IP "SvPVutf8_force" 8
.IX Xref "SvPVutf8_force"
.IX Item "SvPVutf8_force"
Like \f(CW\*(C`SvPV_force\*(C'\fR yo, but converts sv ta utf8 first if necessary.
.Sp
.Vb 1
\&        char*   SvPVutf8_force(SV* sv, STRLEN len)
.Ve
.IP "SvPVutf8_nolen" 8
.IX Xref "SvPVutf8_nolen"
.IX Item "SvPVutf8_nolen"
Like \f(CW\*(C`SvPV_nolen\*(C'\fR yo, but converts sv ta utf8 first if necessary.
.Sp
.Vb 1
\&        char*   SvPVutf8_nolen(SV* sv)
.Ve
.IP "SvPVX" 8
.IX Xref "SvPVX"
.IX Item "SvPVX"
Returns a pointa ta tha physical strang up in tha \s-1SV. \s0 Da \s-1SV\s0 must contain a
string. Prior ta 5.9.3 it aint safe ta execute dis macro unless tha \s-1SV\s0's
type >= SVt_PV.
.Sp
This be also used ta store tha name of a autoloaded subroutine up in a \s-1XS
AUTOLOAD\s0 routine.  See \*(L"Autoloadin wit XSUBs\*(R" up in perlguts.
.Sp
.Vb 1
\&        char*   SvPVX(SV* sv)
.Ve
.IP "SvPVx" 8
.IX Xref "SvPVx"
.IX Item "SvPVx"
A version of \f(CW\*(C`SvPV\*(C'\fR which guarantees ta evaluate \f(CW\*(C`sv\*(C'\fR only once.
Only use dis if \f(CW\*(C`sv\*(C'\fR be a expression wit side effects, otherwise use the
more efficient \f(CW\*(C`SvPV\*(C'\fR.
.Sp
.Vb 1
\&        char*   SvPVx(SV* sv, STRLEN len)
.Ve
.IP "SvPV_force" 8
.IX Xref "SvPV_force"
.IX Item "SvPV_force"
Like \f(CW\*(C`SvPV\*(C'\fR but will force tha \s-1SV\s0 tha fuck into containin a strang (\f(CW\*(C`SvPOK\*(C'\fR), and
only a strang (\f(CW\*(C`SvPOK_only\*(C'\fR), by hook or by crook.  Yo ass need force if yo ass is
goin ta update tha \f(CW\*(C`SvPVX\*(C'\fR directly.  Processes git magic.
.Sp
Note dat coercin a arbitrary scalar tha fuck into a plain \s-1PV\s0 will potentially
strip useful data from dat shit. For example if tha \s-1SV\s0 was \f(CW\*(C`SvROK\*(C'\fR, then the
referent gonna git its reference count decremented, n' tha \s-1SV\s0 itself may
be converted ta a \f(CW\*(C`SvPOK\*(C'\fR scalar wit a strang buffer containin a value
like fuckin \f(CW"ARRAY(0x1234)"\fR.
.Sp
.Vb 1
\&        char*   SvPV_force(SV* sv, STRLEN len)
.Ve
.IP "SvPV_force_nomg" 8
.IX Xref "SvPV_force_nomg"
.IX Item "SvPV_force_nomg"
Like \f(CW\*(C`SvPV_force\*(C'\fR yo, but don't process git magic.
.Sp
.Vb 1
\&        char*   SvPV_force_nomg(SV* sv, STRLEN len)
.Ve
.IP "SvPV_nolen" 8
.IX Xref "SvPV_nolen"
.IX Item "SvPV_nolen"
Like \f(CW\*(C`SvPV\*(C'\fR but don't set a length variable.
.Sp
.Vb 1
\&        char*   SvPV_nolen(SV* sv)
.Ve
.IP "SvPV_nomg" 8
.IX Xref "SvPV_nomg"
.IX Item "SvPV_nomg"
Like \f(CW\*(C`SvPV\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        char*   SvPV_nomg(SV* sv, STRLEN len)
.Ve
.IP "SvPV_nomg_nolen" 8
.IX Xref "SvPV_nomg_nolen"
.IX Item "SvPV_nomg_nolen"
Like \f(CW\*(C`SvPV_nolen\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        char*   SvPV_nomg_nolen(SV* sv)
.Ve
.IP "SvPV_set" 8
.IX Xref "SvPV_set"
.IX Item "SvPV_set"
Set tha value of tha \s-1PV\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See also \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
Beware dat tha existin pointa may be involved up in copy-on-write or other
mischizzle, so do \f(CW\*(C`SvOOK_off(sv)\*(C'\fR n' use \f(CW\*(C`sv_force_normal\*(C'\fR or
\&\f(CW\*(C`SvPV_force\*(C'\fR (or check tha SvIsCOW flag) first ta make shizzle this
modification is safe.
.Sp
.Vb 1
\&        void    SvPV_set(SV* sv, char* val)
.Ve
.IP "SvREFCNT" 8
.IX Xref "SvREFCNT"
.IX Item "SvREFCNT"
Returns tha value of tha objectz reference count.
.Sp
.Vb 1
\&        U32     SvREFCNT(SV* sv)
.Ve
.IP "SvREFCNT_dec" 8
.IX Xref "SvREFCNT_dec"
.IX Item "SvREFCNT_dec"
Decrements tha reference count of tha given \s-1SV. \s0\fIsv\fR may be \s-1NULL.\s0
.Sp
.Vb 1
\&        void    SvREFCNT_dec(SV* sv)
.Ve
.IP "SvREFCNT_dec_NN" 8
.IX Xref "SvREFCNT_dec_NN"
.IX Item "SvREFCNT_dec_NN"
Same as SvREFCNT_dec yo, but can only be used if you know \fIsv\fR
is not \s-1NULL. \s0 Since our phat asses don't gotta check tha NULLness, itz faster
and smaller.
.Sp
.Vb 1
\&        void    SvREFCNT_dec_NN(SV* sv)
.Ve
.IP "SvREFCNT_inc" 8
.IX Xref "SvREFCNT_inc"
.IX Item "SvREFCNT_inc"
Increments tha reference count of tha given \s-1SV,\s0 returnin tha \s-1SV.\s0
.Sp
All of tha followin SvREFCNT_inc* macros is optimized versions of
SvREFCNT_inc, n' can be replaced wit SvREFCNT_inc.
.Sp
.Vb 1
\&        SV*     SvREFCNT_inc(SV* sv)
.Ve
.IP "SvREFCNT_inc_NN" 8
.IX Xref "SvREFCNT_inc_NN"
.IX Item "SvREFCNT_inc_NN"
Same as SvREFCNT_inc yo, but can only be used if you know \fIsv\fR
is not \s-1NULL. \s0 Since our phat asses don't gotta check tha NULLness, itz faster
and smaller.
.Sp
.Vb 1
\&        SV*     SvREFCNT_inc_NN(SV* sv)
.Ve
.IP "SvREFCNT_inc_simple" 8
.IX Xref "SvREFCNT_inc_simple"
.IX Item "SvREFCNT_inc_simple"
Same as SvREFCNT_inc yo, but can only be used wit expressions without side
effects, n' you can put dat on yo' toast.  Since our phat asses don't gotta store a temporary value, itz faster.
.Sp
.Vb 1
\&        SV*     SvREFCNT_inc_simple(SV* sv)
.Ve
.IP "SvREFCNT_inc_simple_NN" 8
.IX Xref "SvREFCNT_inc_simple_NN"
.IX Item "SvREFCNT_inc_simple_NN"
Same as SvREFCNT_inc_simple yo, but can only be used if you know \fIsv\fR
is not \s-1NULL. \s0 Since our phat asses don't gotta check tha NULLness, itz faster
and smaller.
.Sp
.Vb 1
\&        SV*     SvREFCNT_inc_simple_NN(SV* sv)
.Ve
.IP "SvREFCNT_inc_simple_void" 8
.IX Xref "SvREFCNT_inc_simple_void"
.IX Item "SvREFCNT_inc_simple_void"
Same as SvREFCNT_inc_simple yo, but can only be used if you don't need the
return value.  Da macro don't need ta return a meaningful value.
.Sp
.Vb 1
\&        void    SvREFCNT_inc_simple_void(SV* sv)
.Ve
.IP "SvREFCNT_inc_simple_void_NN" 8
.IX Xref "SvREFCNT_inc_simple_void_NN"
.IX Item "SvREFCNT_inc_simple_void_NN"
Same as SvREFCNT_inc yo, but can only be used if you don't need tha return
value, n' you know dat \fIsv\fR aint \s-1NULL. \s0 Da macro don't need
to return a meaningful value, or check fo' NULLness, so itz smaller
and faster.
.Sp
.Vb 1
\&        void    SvREFCNT_inc_simple_void_NN(SV* sv)
.Ve
.IP "SvREFCNT_inc_void" 8
.IX Xref "SvREFCNT_inc_void"
.IX Item "SvREFCNT_inc_void"
Same as SvREFCNT_inc yo, but can only be used if you don't need the
return value.  Da macro don't need ta return a meaningful value.
.Sp
.Vb 1
\&        void    SvREFCNT_inc_void(SV* sv)
.Ve
.IP "SvREFCNT_inc_void_NN" 8
.IX Xref "SvREFCNT_inc_void_NN"
.IX Item "SvREFCNT_inc_void_NN"
Same as SvREFCNT_inc yo, but can only be used if you don't need tha return
value, n' you know dat \fIsv\fR aint \s-1NULL. \s0 Da macro don't need
to return a meaningful value, or check fo' NULLness, so itz smaller
and faster.
.Sp
.Vb 1
\&        void    SvREFCNT_inc_void_NN(SV* sv)
.Ve
.IP "SvROK" 8
.IX Xref "SvROK"
.IX Item "SvROK"
Tests if tha \s-1SV\s0 be a \s-1RV.\s0
.Sp
.Vb 1
\&        U32     SvROK(SV* sv)
.Ve
.IP "SvROK_off" 8
.IX Xref "SvROK_off"
.IX Item "SvROK_off"
Unsets tha \s-1RV\s0 statuz of a \s-1SV.\s0
.Sp
.Vb 1
\&        void    SvROK_off(SV* sv)
.Ve
.IP "SvROK_on" 8
.IX Xref "SvROK_on"
.IX Item "SvROK_on"
Tells a \s-1SV\s0 dat it be a \s-1RV.\s0
.Sp
.Vb 1
\&        void    SvROK_on(SV* sv)
.Ve
.IP "SvRV" 8
.IX Xref "SvRV"
.IX Item "SvRV"
Dereferences a \s-1RV\s0 ta return tha \s-1SV.\s0
.Sp
.Vb 1
\&        SV*     SvRV(SV* sv)
.Ve
.IP "SvRV_set" 8
.IX Xref "SvRV_set"
.IX Item "SvRV_set"
Set tha value of tha \s-1RV\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvRV_set(SV* sv, SV* val)
.Ve
.IP "SvSTASH" 8
.IX Xref "SvSTASH"
.IX Item "SvSTASH"
Returns tha stash of tha \s-1SV.\s0
.Sp
.Vb 1
\&        HV*     SvSTASH(SV* sv)
.Ve
.IP "SvSTASH_set" 8
.IX Xref "SvSTASH_set"
.IX Item "SvSTASH_set"
Set tha value of tha \s-1STASH\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvSTASH_set(SV* sv, HV* val)
.Ve
.IP "SvTAINT" 8
.IX Xref "SvTAINT"
.IX Item "SvTAINT"
Taints a \s-1SV\s0 if taintin is enabled, n' if some input ta tha current
expression is tainted\*(--usually a variable yo, but possibly also implicit
inputs like fuckin locale settings.  \f(CW\*(C`SvTAINT\*(C'\fR propagates dat taintednizz to
the outputz of a expression up in a pessimistic fashion; i.e., without paying
attention ta precisely which outputs is hyped up by which inputs.
.Sp
.Vb 1
\&        void    SvTAINT(SV* sv)
.Ve
.IP "SvTAINTED" 8
.IX Xref "SvTAINTED"
.IX Item "SvTAINTED"
Checks ta peep if a \s-1SV\s0 is tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns \s-1TRUE\s0 if it is, \s-1FALSE\s0 if
not.
.Sp
.Vb 1
\&        bool    SvTAINTED(SV* sv)
.Ve
.IP "SvTAINTED_off" 8
.IX Xref "SvTAINTED_off"
.IX Item "SvTAINTED_off"
Untaints a \s-1SV. \s0 Be \fIvery\fR careful wit dis routine, as it short-circuits
some of Perlz fundamenstrual securitizzle features.  \s-1XS\s0 module authors should not
use dis function unless they straight-up KNOW all tha implications of
unconditionally untaintin tha value. Untaintin should be done up in the
standard perl fashion, via a cold-ass lil carefully crafted regexp, rather than directly
untaintin variables.
.Sp
.Vb 1
\&        void    SvTAINTED_off(SV* sv)
.Ve
.IP "SvTAINTED_on" 8
.IX Xref "SvTAINTED_on"
.IX Item "SvTAINTED_on"
Marks a \s-1SV\s0 as tainted if taintin is enabled.
.Sp
.Vb 1
\&        void    SvTAINTED_on(SV* sv)
.Ve
.IP "SvTRUE" 8
.IX Xref "SvTRUE"
.IX Item "SvTRUE"
Returns a funky-ass boolean indicatin whether Perl would evaluate tha \s-1SV\s0 as legit or
false.  See \fISvOK()\fR fo' a thugged-out defined/undefined test.  Handlez 'get' magic
unless tha scalar be already SvPOK, SvIOK or SvNOK (the public, not the
private flags).
.Sp
.Vb 1
\&        bool    SvTRUE(SV* sv)
.Ve
.IP "SvTRUE_nomg" 8
.IX Xref "SvTRUE_nomg"
.IX Item "SvTRUE_nomg"
Returns a funky-ass boolean indicatin whether Perl would evaluate tha \s-1SV\s0 as legit or
false.  See \fISvOK()\fR fo' a thugged-out defined/undefined test.  Do not handle 'get' magic.
.Sp
.Vb 1
\&        bool    SvTRUE_nomg(SV* sv)
.Ve
.IP "SvTYPE" 8
.IX Xref "SvTYPE"
.IX Item "SvTYPE"
Returns tha type of tha \s-1SV. \s0 See \f(CW\*(C`svtype\*(C'\fR.
.Sp
.Vb 1
\&        svtype  SvTYPE(SV* sv)
.Ve
.IP "SvUOK" 8
.IX Xref "SvUOK"
.IX Item "SvUOK"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 gotz nuff a integer dat must be
interpreted as unsigned. Y'all KNOW dat shit, muthafucka!  A non-negatizzle integer whose value is within the
range of both a \s-1IV\s0 n' a \s-1UV\s0 may be be flagged as either SvUOK or \s-1SVIOK.\s0
.Sp
.Vb 1
\&        bool    SvUOK(SV* sv)
.Ve
.IP "SvUPGRADE" 8
.IX Xref "SvUPGRADE"
.IX Item "SvUPGRADE"
Used ta upgrade a \s-1SV\s0 ta a mo' complex form.  Uses \f(CW\*(C`sv_upgrade\*(C'\fR to
perform tha upgrade if necessary.  See \f(CW\*(C`svtype\*(C'\fR.
.Sp
.Vb 1
\&        void    SvUPGRADE(SV* sv, svtype type)
.Ve
.IP "SvUTF8" 8
.IX Xref "SvUTF8"
.IX Item "SvUTF8"
Returns a U32 value indicatin tha \s-1UTF\-8\s0 statuz of a \s-1SV. \s0 If thangs is set-up
properly, dis indicates whether or not tha \s-1SV\s0 gotz nuff \s-1UTF\-8\s0 encoded data.
Yo ass should use dis \fIafter\fR a cold-ass lil call ta \fISvPV()\fR or one of its variants, in
case any call ta strang overloadin thugged-out shiznit tha internal flag.
.Sp
.Vb 1
\&        U32     SvUTF8(SV* sv)
.Ve
.IP "SvUTF8_off" 8
.IX Xref "SvUTF8_off"
.IX Item "SvUTF8_off"
Unsets tha \s-1UTF\-8\s0 statuz of a \s-1SV \s0(the data aint chizzled, just tha flag).
Do not use frivolously.
.Sp
.Vb 1
\&        void    SvUTF8_off(SV *sv)
.Ve
.IP "SvUTF8_on" 8
.IX Xref "SvUTF8_on"
.IX Item "SvUTF8_on"
Turn on tha \s-1UTF\-8\s0 statuz of a \s-1SV \s0(the data aint chizzled, just tha flag).
Do not use frivolously.
.Sp
.Vb 1
\&        void    SvUTF8_on(SV *sv)
.Ve
.IP "SvUV" 8
.IX Xref "SvUV"
.IX Item "SvUV"
Coerces tha given \s-1SV\s0 ta a unsigned integer n' returns dat shit.  See \f(CW\*(C`SvUVx\*(C'\fR
for a version which guarantees ta evaluate sv only once.
.Sp
.Vb 1
\&        UV      SvUV(SV* sv)
.Ve
.IP "SvUVX" 8
.IX Xref "SvUVX"
.IX Item "SvUVX"
Returns tha raw value up in tha \s-1SV\s0z \s-1UV\s0 slot, without checks or conversions.
Only use when yo ass is shizzle SvIOK is true.  See also \f(CW\*(C`SvUV()\*(C'\fR.
.Sp
.Vb 1
\&        UV      SvUVX(SV* sv)
.Ve
.IP "SvUVx" 8
.IX Xref "SvUVx"
.IX Item "SvUVx"
Coerces tha given \s-1SV\s0 ta a unsigned integer and
returns dat shit.  Guarantees ta evaluate \f(CW\*(C`sv\*(C'\fR only once.  Only
use dis if \f(CW\*(C`sv\*(C'\fR be a expression wit side effects,
otherwise use tha mo' efficient \f(CW\*(C`SvUV\*(C'\fR.
.Sp
.Vb 1
\&        UV      SvUVx(SV* sv)
.Ve
.IP "SvUV_nomg" 8
.IX Xref "SvUV_nomg"
.IX Item "SvUV_nomg"
Like \f(CW\*(C`SvUV\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        UV      SvUV_nomg(SV* sv)
.Ve
.IP "SvUV_set" 8
.IX Xref "SvUV_set"
.IX Item "SvUV_set"
Set tha value of tha \s-1UV\s0 pointa up in sv ta val. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \f(CW\*(C`SvIV_set\*(C'\fR.
.Sp
.Vb 1
\&        void    SvUV_set(SV* sv, UV val)
.Ve
.IP "SvVOK" 8
.IX Xref "SvVOK"
.IX Item "SvVOK"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 gotz nuff a v\-string.
.Sp
.Vb 1
\&        bool    SvVOK(SV* sv)
.Ve
.IP "sv_catpvn_nomg" 8
.IX Xref "sv_catpvn_nomg"
.IX Item "sv_catpvn_nomg"
Like \f(CW\*(C`sv_catpvn\*(C'\fR but don't process magic.
.Sp
.Vb 2
\&        void    sv_catpvn_nomg(SV* sv, const char* ptr,
\&                               STRLEN len)
.Ve
.IP "sv_catpv_nomg" 8
.IX Xref "sv_catpv_nomg"
.IX Item "sv_catpv_nomg"
Like \f(CW\*(C`sv_catpv\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        void    sv_catpv_nomg(SV* sv, const char* ptr)
.Ve
.IP "sv_catsv_nomg" 8
.IX Xref "sv_catsv_nomg"
.IX Item "sv_catsv_nomg"
Like \f(CW\*(C`sv_catsv\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        void    sv_catsv_nomg(SV* dsv, SV* ssv)
.Ve
.IP "sv_derived_from" 8
.IX Xref "sv_derived_from"
.IX Item "sv_derived_from"
Exactly like \*(L"sv_derived_from_pv\*(R" yo, but don't take a \f(CW\*(C`flags\*(C'\fR parameter.
.Sp
.Vb 1
\&        bool    sv_derived_from(SV* sv, const char *const name)
.Ve
.IP "sv_derived_from_pv" 8
.IX Xref "sv_derived_from_pv"
.IX Item "sv_derived_from_pv"
Exactly like \*(L"sv_derived_from_pvn\*(R" yo, but takes a nul-terminated strang 
instead of a string/length pair.
.Sp
.Vb 3
\&        bool    sv_derived_from_pv(SV* sv,
\&                                   const char *const name,
\&                                   U32 flags)
.Ve
.IP "sv_derived_from_pvn" 8
.IX Xref "sv_derived_from_pvn"
.IX Item "sv_derived_from_pvn"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 is derived from tha specified class
\&\fIat tha C level\fR.  To check derivation all up in tha Perl level, call \f(CW\*(C`isa()\*(C'\fR as a
normal Perl method.
.Sp
Currently, tha only dope value fo' \f(CW\*(C`flags\*(C'\fR is SVf_UTF8.
.Sp
.Vb 3
\&        bool    sv_derived_from_pvn(SV* sv,
\&                                    const char *const name,
\&                                    const STRLEN len, U32 flags)
.Ve
.IP "sv_derived_from_sv" 8
.IX Xref "sv_derived_from_sv"
.IX Item "sv_derived_from_sv"
Exactly like \*(L"sv_derived_from_pvn\*(R" yo, but takes tha name strang up in tha form
of a \s-1SV\s0 instead of a string/length pair.
.Sp
.Vb 2
\&        bool    sv_derived_from_sv(SV* sv, SV *namesv,
\&                                   U32 flags)
.Ve
.IP "sv_does" 8
.IX Xref "sv_does"
.IX Item "sv_does"
Like \*(L"sv_does_pv\*(R" yo, but don't take a \f(CW\*(C`flags\*(C'\fR parameter.
.Sp
.Vb 1
\&        bool    sv_does(SV* sv, const char *const name)
.Ve
.IP "sv_does_pv" 8
.IX Xref "sv_does_pv"
.IX Item "sv_does_pv"
Like \*(L"sv_does_sv\*(R" yo, but takes a nul-terminated strang instead of a \s-1SV.\s0
.Sp
.Vb 2
\&        bool    sv_does_pv(SV* sv, const char *const name,
\&                           U32 flags)
.Ve
.IP "sv_does_pvn" 8
.IX Xref "sv_does_pvn"
.IX Item "sv_does_pvn"
Like \*(L"sv_does_sv\*(R" yo, but takes a string/length pair instead of a \s-1SV.\s0
.Sp
.Vb 2
\&        bool    sv_does_pvn(SV* sv, const char *const name,
\&                            const STRLEN len, U32 flags)
.Ve
.IP "sv_does_sv" 8
.IX Xref "sv_does_sv"
.IX Item "sv_does_sv"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 performs a specific, named role.
Da \s-1SV\s0 can be a Perl object or tha name of a Perl class.
.Sp
.Vb 1
\&        bool    sv_does_sv(SV* sv, SV* namesv, U32 flags)
.Ve
.IP "sv_report_used" 8
.IX Xref "sv_report_used"
.IX Item "sv_report_used"
Dump tha contentz of all SVs not yet freed (debuggin aid).
.Sp
.Vb 1
\&        void    sv_report_used()
.Ve
.IP "sv_setsv_nomg" 8
.IX Xref "sv_setsv_nomg"
.IX Item "sv_setsv_nomg"
Like \f(CW\*(C`sv_setsv\*(C'\fR but don't process magic.
.Sp
.Vb 1
\&        void    sv_setsv_nomg(SV* dsv, SV* ssv)
.Ve
.IP "sv_utf8_upgrade_nomg" 8
.IX Xref "sv_utf8_upgrade_nomg"
.IX Item "sv_utf8_upgrade_nomg"
Like sv_utf8_upgrade yo, but don't do magic on \f(CW\*(C`sv\*(C'\fR.
.Sp
.Vb 1
\&        STRLEN  sv_utf8_upgrade_nomg(NN SV *sv)
.Ve
.SH "SV-Body Allocation"
.IX Header "SV-Body Allocation"
.IP "looks_like_number" 8
.IX Xref "looks_like_number"
.IX Item "looks_like_number"
Test if tha content of a \s-1SV\s0 be lookin like a number (or be a number).
\&\f(CW\*(C`Inf\*(C'\fR n' \f(CW\*(C`Infinity\*(C'\fR is treated as numbers (so aint gonna issue a
non-numeric warning), even if yo' \fIatof()\fR don't grok em.  Get-magic is
ignored.
.Sp
.Vb 1
\&        I32     looks_like_number(SV *const sv)
.Ve
.IP "newRV_noinc" 8
.IX Xref "newRV_noinc"
.IX Item "newRV_noinc"
Creates a \s-1RV\s0 wrapper fo' a \s-1SV. \s0 Da reference count fo' tha original
\&\s-1SV\s0 is \fBnot\fR incremented.
.Sp
.Vb 1
\&        SV*     newRV_noinc(SV *const sv)
.Ve
.IP "newSV" 8
.IX Xref "newSV"
.IX Item "newSV"
Creates a freshly smoked up \s-1SV.  A\s0 non-zero \f(CW\*(C`len\*(C'\fR parameta indicates tha number of
bytez of preallocated strang space tha \s-1SV\s0 should have.  An extra byte fo' a
trailin \s-1NUL\s0 be also reserved. Y'all KNOW dat shit, muthafucka!  (SvPOK aint set fo' tha \s-1SV\s0 even if string
space be allocated.)  Da reference count fo' tha freshly smoked up \s-1SV\s0 is set ta 1.
.Sp
In 5.9.3, \fInewSV()\fR replaces tha olda \s-1\fINEWSV\s0()\fR \s-1API,\s0 n' drops tha first
parameter, \fIx\fR, a thugged-out debug aid which allowed callaz ta identify theyselves.
This aid has been superseded by a freshly smoked up build option, \s-1PERL_MEM_LOG \s0(see
\&\*(L"\s-1PERL_MEM_LOG\*(R"\s0 up in perlhacktips).  Da olda \s-1API\s0 is still there fo' use up in \s-1XS\s0
modulez supportin olda perls.
.Sp
.Vb 1
\&        SV*     newSV(const STRLEN len)
.Ve
.IP "newSVhek" 8
.IX Xref "newSVhek"
.IX Item "newSVhek"
Creates a freshly smoked up \s-1SV\s0 from tha hash key structure.  It will generate scalars that
point ta tha shared strang table where possible.  Returns a freshly smoked up (undefined)
\&\s-1SV\s0 if tha hek is \s-1NULL.\s0
.Sp
.Vb 1
\&        SV*     newSVhek(const HEK *const hek)
.Ve
.IP "newSViv" 8
.IX Xref "newSViv"
.IX Item "newSViv"
Creates a freshly smoked up \s-1SV\s0 n' copies a integer tha fuck into dat shit.  Da reference count fo' the
\&\s-1SV\s0 is set ta 1.
.Sp
.Vb 1
\&        SV*     newSViv(const IV i)
.Ve
.IP "newSVnv" 8
.IX Xref "newSVnv"
.IX Item "newSVnv"
Creates a freshly smoked up \s-1SV\s0 n' copies a gangbangin' floatin point value tha fuck into dat shit.
Da reference count fo' tha \s-1SV\s0 is set ta 1.
.Sp
.Vb 1
\&        SV*     newSVnv(const NV n)
.Ve
.IP "newSVpv" 8
.IX Xref "newSVpv"
.IX Item "newSVpv"
Creates a freshly smoked up \s-1SV\s0 n' copies a strang tha fuck into dat shit.  Da reference count fo' the
\&\s-1SV\s0 is set ta 1.  If \f(CW\*(C`len\*(C'\fR is zero, Perl will compute tha length using
\&\fIstrlen()\fR.  For efficiency, consider rockin \f(CW\*(C`newSVpvn\*(C'\fR instead.
.Sp
.Vb 1
\&        SV*     newSVpv(const char *const s, const STRLEN len)
.Ve
.IP "newSVpvf" 8
.IX Xref "newSVpvf"
.IX Item "newSVpvf"
Creates a freshly smoked up \s-1SV\s0 n' initializes it wit tha strang formatted like
\&\f(CW\*(C`sprintf\*(C'\fR.
.Sp
.Vb 1
\&        SV*     newSVpvf(const char *const pat, ...)
.Ve
.IP "newSVpvn" 8
.IX Xref "newSVpvn"
.IX Item "newSVpvn"
Creates a freshly smoked up \s-1SV\s0 n' copies a funky-ass buffer tha fuck into it, which may contain \s-1NUL\s0 characters
(\f(CW\*(C`\e0\*(C'\fR) n' other binary data.  Da reference count fo' tha \s-1SV\s0 is set ta 1.
Note dat if \f(CW\*(C`len\*(C'\fR is zero, Perl will create a zero length (Perl) string.  You
are responsible fo' ensurin dat tha source buffer be at least
\&\f(CW\*(C`len\*(C'\fR bytes long.  If tha \f(CW\*(C`buffer\*(C'\fR argument is \s-1NULL\s0 tha freshly smoked up \s-1SV\s0 will be
undefined.
.Sp
.Vb 1
\&        SV*     newSVpvn(const char *const s, const STRLEN len)
.Ve
.IP "newSVpvn_flags" 8
.IX Xref "newSVpvn_flags"
.IX Item "newSVpvn_flags"
Creates a freshly smoked up \s-1SV\s0 n' copies a strang tha fuck into dat shit.  Da reference count fo' the
\&\s-1SV\s0 is set ta 1.  Note dat if \f(CW\*(C`len\*(C'\fR is zero, Perl will create a zero length
string.  Yo ass is responsible fo' ensurin dat tha source strang be at least
\&\f(CW\*(C`len\*(C'\fR bytes long.  If tha \f(CW\*(C`s\*(C'\fR argument is \s-1NULL\s0 tha freshly smoked up \s-1SV\s0 is ghon be undefined.
Currently tha only flag bits accepted is \f(CW\*(C`SVf_UTF8\*(C'\fR n' \f(CW\*(C`SVs_TEMP\*(C'\fR.
If \f(CW\*(C`SVs_TEMP\*(C'\fR is set, then \f(CW\*(C`sv_2mortal()\*(C'\fR is called on tha result before
returning.  If \f(CW\*(C`SVf_UTF8\*(C'\fR is set, \f(CW\*(C`s\*(C'\fR
is considered ta be up in \s-1UTF\-8\s0 n' the
\&\f(CW\*(C`SVf_UTF8\*(C'\fR flag is ghon be set on tha freshly smoked up \s-1SV.
\&\s0\f(CW\*(C`newSVpvn_utf8()\*(C'\fR be a cold-ass lil convenience wrapper fo' dis function, defined as
.Sp
.Vb 2
\&    #define newSVpvn_utf8(s, len, u)                    \e
\&        newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
\&
\&        SV*     newSVpvn_flags(const char *const s,
\&                               const STRLEN len,
\&                               const U32 flags)
.Ve
.IP "newSVpvn_share" 8
.IX Xref "newSVpvn_share"
.IX Item "newSVpvn_share"
Creates a freshly smoked up \s-1SV\s0 wit its SvPVX_const pointin ta a gangbangin' finger-lickin' dirty-ass shared strang up in tha string
table.  If tha strang do not already exist up in tha table, it is
created first.  Turns on tha SvIsCOW flag (or \s-1READONLY\s0
and \s-1FAKE\s0 up in 5.16 n' earlier).  If tha \f(CW\*(C`hash\*(C'\fR parameter
is non-zero, dat value is used; otherwise tha hash is computed.
Da stringz hash can lata be retrieved from tha \s-1SV\s0
with tha \f(CW\*(C`SvSHARED_HASH()\*(C'\fR macro.  Da scam here is
that as tha strang table is used fo' shared hash keys these strings will have
SvPVX_const == HeKEY n' hash lookup will avoid strang compare.
.Sp
.Vb 1
\&        SV*     newSVpvn_share(const char* s, I32 len, U32 hash)
.Ve
.IP "newSVpvs" 8
.IX Xref "newSVpvs"
.IX Item "newSVpvs"
Like \f(CW\*(C`newSVpvn\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        SV*     newSVpvs(const char* s)
.Ve
.IP "newSVpvs_flags" 8
.IX Xref "newSVpvs_flags"
.IX Item "newSVpvs_flags"
Like \f(CW\*(C`newSVpvn_flags\*(C'\fR yo, but takes a literal strang instead of a string/length
pair.
.Sp
.Vb 1
\&        SV*     newSVpvs_flags(const char* s, U32 flags)
.Ve
.IP "newSVpvs_share" 8
.IX Xref "newSVpvs_share"
.IX Item "newSVpvs_share"
Like \f(CW\*(C`newSVpvn_share\*(C'\fR yo, but takes a literal strang instead of a string/length
pair n' omits tha hash parameter.
.Sp
.Vb 1
\&        SV*     newSVpvs_share(const char* s)
.Ve
.IP "newSVpv_share" 8
.IX Xref "newSVpv_share"
.IX Item "newSVpv_share"
Like \f(CW\*(C`newSVpvn_share\*(C'\fR yo, but takes a nul-terminated strang instead of a
string/length pair.
.Sp
.Vb 1
\&        SV*     newSVpv_share(const char* s, U32 hash)
.Ve
.IP "newSVrv" 8
.IX Xref "newSVrv"
.IX Item "newSVrv"
Creates a freshly smoked up \s-1SV\s0 fo' tha existin \s-1RV, \s0\f(CW\*(C`rv\*(C'\fR, ta point to.  If \f(CW\*(C`rv\*(C'\fR aint an
\&\s-1RV\s0 then it is ghon be upgraded ta one.  If \f(CW\*(C`classname\*(C'\fR is non-null then tha new
\&\s-1SV\s0 is ghon be pimped up in tha specified package.  Da freshly smoked up \s-1SV\s0 is returned n' its
reference count is 1. Da reference count 1 is owned by \f(CW\*(C`rv\*(C'\fR.
.Sp
.Vb 2
\&        SV*     newSVrv(SV *const rv,
\&                        const char *const classname)
.Ve
.IP "newSVsv" 8
.IX Xref "newSVsv"
.IX Item "newSVsv"
Creates a freshly smoked up \s-1SV\s0 which be a exact duplicate of tha original gangsta \s-1SV.
\&\s0(Uses \f(CW\*(C`sv_setsv\*(C'\fR.)
.Sp
.Vb 1
\&        SV*     newSVsv(SV *const old)
.Ve
.IP "newSVuv" 8
.IX Xref "newSVuv"
.IX Item "newSVuv"
Creates a freshly smoked up \s-1SV\s0 n' copies a unsigned integer tha fuck into dat shit.
Da reference count fo' tha \s-1SV\s0 is set ta 1.
.Sp
.Vb 1
\&        SV*     newSVuv(const UV u)
.Ve
.IP "newSV_type" 8
.IX Xref "newSV_type"
.IX Item "newSV_type"
Creates a freshly smoked up \s-1SV,\s0 of tha type specified. Y'all KNOW dat shit, muthafucka!  Da reference count fo' tha freshly smoked up \s-1SV\s0
is set ta 1.
.Sp
.Vb 1
\&        SV*     newSV_type(const svtype type)
.Ve
.IP "sv_2bool" 8
.IX Xref "sv_2bool"
.IX Item "sv_2bool"
This macro is only used by \fIsv_true()\fR or its macro equivalent, n' only if
the latterz argument is neither SvPOK, SvIOK nor SvNOK.
It calls sv_2bool_flags wit tha \s-1SV_GMAGIC\s0 flag.
.Sp
.Vb 1
\&        bool    sv_2bool(SV *const sv)
.Ve
.IP "sv_2bool_flags" 8
.IX Xref "sv_2bool_flags"
.IX Item "sv_2bool_flags"
This function is only used by \fIsv_true()\fR n' playas,  n' only if
the latterz argument is neither SvPOK, SvIOK nor SvNOK.  If tha flags
contain \s-1SV_GMAGIC,\s0 then it do a \fImg_get()\fR first.
.Sp
.Vb 1
\&        bool    sv_2bool_flags(SV *const sv, const I32 flags)
.Ve
.IP "sv_2cv" 8
.IX Xref "sv_2cv"
.IX Item "sv_2cv"
Usin various gambits, try ta git a \s-1CV\s0 from a \s-1SV\s0; up in addition, try if
possible ta set \f(CW*st\fR n' \f(CW*gvp\fR ta tha stash n' \s-1GV\s0 associated wit dat shit.
Da flags up in \f(CW\*(C`lref\*(C'\fR is passed ta gv_fetchsv.
.Sp
.Vb 2
\&        CV*     sv_2cv(SV* sv, HV **const st, GV **const gvp,
\&                       const I32 lref)
.Ve
.IP "sv_2io" 8
.IX Xref "sv_2io"
.IX Item "sv_2io"
Usin various gambits, try ta git a \s-1IO\s0 from a \s-1SV:\s0 tha \s-1IO\s0 slot if its a
\&\s-1GV\s0; or tha recursive result if we a \s-1RV\s0; or tha \s-1IO\s0 slot of tha symbol
named afta tha \s-1PV\s0 if we a string.
.Sp
\&'Get' magic is ignored on tha sv passed up in yo, but is ghon be called on
\&\f(CW\*(C`SvRV(sv)\*(C'\fR if sv be a \s-1RV.\s0
.Sp
.Vb 1
\&        IO*     sv_2io(SV *const sv)
.Ve
.IP "sv_2iv_flags" 8
.IX Xref "sv_2iv_flags"
.IX Item "sv_2iv_flags"
Return tha integer value of a \s-1SV,\s0 bustin any necessary string
conversion. I aint talkin' bout chicken n' gravy biatch.  If flags includes \s-1SV_GMAGIC,\s0 do a \fImg_get()\fR first.
Normally used via tha \f(CW\*(C`SvIV(sv)\*(C'\fR n' \f(CW\*(C`SvIVx(sv)\*(C'\fR macros.
.Sp
.Vb 1
\&        IV      sv_2iv_flags(SV *const sv, const I32 flags)
.Ve
.IP "sv_2mortal" 8
.IX Xref "sv_2mortal"
.IX Item "sv_2mortal"
Marks a existin \s-1SV\s0 as mortal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da \s-1SV\s0 is ghon be destroyed \*(L"soon\*(R", either
by a explicit call ta \s-1FREETMPS,\s0 or by a implicit call at places such as
statement boundaries. Put ya muthafuckin choppers up if ya feel dis!  \fISvTEMP()\fR is turned on which means dat tha \s-1SV\s0's
strin buffer can be \*(L"stolen\*(R" if dis \s-1SV\s0 is copied. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`sv_newmortal\*(C'\fR
and \f(CW\*(C`sv_mortalcopy\*(C'\fR.
.Sp
.Vb 1
\&        SV*     sv_2mortal(SV *const sv)
.Ve
.IP "sv_2nv_flags" 8
.IX Xref "sv_2nv_flags"
.IX Item "sv_2nv_flags"
Return tha num value of a \s-1SV,\s0 bustin any necessary strang or integer
conversion. I aint talkin' bout chicken n' gravy biatch.  If flags includes \s-1SV_GMAGIC,\s0 do a \fImg_get()\fR first.
Normally used via tha \f(CW\*(C`SvNV(sv)\*(C'\fR n' \f(CW\*(C`SvNVx(sv)\*(C'\fR macros.
.Sp
.Vb 1
\&        NV      sv_2nv_flags(SV *const sv, const I32 flags)
.Ve
.IP "sv_2pvbyte" 8
.IX Xref "sv_2pvbyte"
.IX Item "sv_2pvbyte"
Return a pointa ta tha byte-encoded representation of tha \s-1SV,\s0 n' set *lp
to its length.  May cause tha \s-1SV\s0 ta be downgraded from \s-1UTF\-8\s0 as a
side-effect.
.Sp
Usually accessed via tha \f(CW\*(C`SvPVbyte\*(C'\fR macro.
.Sp
.Vb 1
\&        char*   sv_2pvbyte(SV *sv, STRLEN *const lp)
.Ve
.IP "sv_2pvutf8" 8
.IX Xref "sv_2pvutf8"
.IX Item "sv_2pvutf8"
Return a pointa ta tha UTF\-8\-encoded representation of tha \s-1SV,\s0 n' set *lp
to its length.  May cause tha \s-1SV\s0 ta be upgraded ta \s-1UTF\-8\s0 as a side-effect.
.Sp
Usually accessed via tha \f(CW\*(C`SvPVutf8\*(C'\fR macro.
.Sp
.Vb 1
\&        char*   sv_2pvutf8(SV *sv, STRLEN *const lp)
.Ve
.IP "sv_2pv_flags" 8
.IX Xref "sv_2pv_flags"
.IX Item "sv_2pv_flags"
Returns a pointa ta tha strang value of a \s-1SV,\s0 n' sets *lp ta its length.
If flags includes \s-1SV_GMAGIC,\s0 do a \fImg_get()\fR first.  Coerces sv ta a
strin if necessary.  Normally invoked via tha \f(CW\*(C`SvPV_flags\*(C'\fR macro.
\&\f(CW\*(C`sv_2pv()\*(C'\fR n' \f(CW\*(C`sv_2pv_nomg\*(C'\fR probably end up here like a muthafucka.
.Sp
.Vb 2
\&        char*   sv_2pv_flags(SV *const sv, STRLEN *const lp,
\&                             const I32 flags)
.Ve
.IP "sv_2uv_flags" 8
.IX Xref "sv_2uv_flags"
.IX Item "sv_2uv_flags"
Return tha unsigned integer value of a \s-1SV,\s0 bustin any necessary string
conversion. I aint talkin' bout chicken n' gravy biatch.  If flags includes \s-1SV_GMAGIC,\s0 do a \fImg_get()\fR first.
Normally used via tha \f(CW\*(C`SvUV(sv)\*(C'\fR n' \f(CW\*(C`SvUVx(sv)\*(C'\fR macros.
.Sp
.Vb 1
\&        UV      sv_2uv_flags(SV *const sv, const I32 flags)
.Ve
.IP "sv_backoff" 8
.IX Xref "sv_backoff"
.IX Item "sv_backoff"
Remove any strang offset.  Yo ass should normally use tha \f(CW\*(C`SvOOK_off\*(C'\fR macro
wrapper instead.
.Sp
.Vb 1
\&        int     sv_backoff(SV *const sv)
.Ve
.IP "sv_bless" 8
.IX Xref "sv_bless"
.IX Item "sv_bless"
Blesses a \s-1SV\s0 tha fuck into a specified package.  Da \s-1SV\s0 must be a \s-1RV. \s0 Da package
must be designated by its stash (see \f(CW\*(C`gv_stashpv()\*(C'\fR).  Da reference count
of tha \s-1SV\s0 is unaffected.
.Sp
.Vb 1
\&        SV*     sv_bless(SV *const sv, HV *const stash)
.Ve
.IP "sv_catpv" 8
.IX Xref "sv_catpv"
.IX Item "sv_catpv"
Concatenates tha strang onto tha end of tha strang which is up in tha \s-1SV.\s0
If tha \s-1SV\s0 has tha \s-1UTF\-8\s0 status set, then tha bytes appended should be
valid \s-1UTF\-8. \s0 Handlez 'get' magic yo, but not 'set' magic.  See \f(CW\*(C`sv_catpv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_catpv(SV *const sv, const char* ptr)
.Ve
.IP "sv_catpvf" 8
.IX Xref "sv_catpvf"
.IX Item "sv_catpvf"
Processes its arguments like \f(CW\*(C`sprintf\*(C'\fR n' appendz tha formatted
output ta a \s-1SV. \s0 If tha appended data gotz nuff \*(L"wide\*(R" characters
(includin yo, but not limited to, SVs wit a \s-1UTF\-8 PV\s0 formatted wit \f(CW%s\fR,
and charactas >255 formatted wit \f(CW%c\fR), tha original gangsta \s-1SV\s0 might get
upgraded ta \s-1UTF\-8. \s0 Handlez 'get' magic yo, but not 'set' magic.  See
\&\f(CW\*(C`sv_catpvf_mg\*(C'\fR.  If tha original gangsta \s-1SV\s0 was \s-1UTF\-8,\s0 tha pattern should be
valid \s-1UTF\-8\s0; if tha original gangsta \s-1SV\s0 was bytes, tha pattern should be like a muthafucka.
.Sp
.Vb 2
\&        void    sv_catpvf(SV *const sv, const char *const pat,
\&                          ...)
.Ve
.IP "sv_catpvf_mg" 8
.IX Xref "sv_catpvf_mg"
.IX Item "sv_catpvf_mg"
Like \f(CW\*(C`sv_catpvf\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 2
\&        void    sv_catpvf_mg(SV *const sv,
\&                             const char *const pat, ...)
.Ve
.IP "sv_catpvn" 8
.IX Xref "sv_catpvn"
.IX Item "sv_catpvn"
Concatenates tha strang onto tha end of tha strang which is up in tha \s-1SV. \s0 The
\&\f(CW\*(C`len\*(C'\fR indicates number of bytes ta copy.  If tha \s-1SV\s0 has tha \s-1UTF\-8\s0
status set, then tha bytes appended should be valid \s-1UTF\-8.\s0
Handlez 'get' magic yo, but not 'set' magic.  See \f(CW\*(C`sv_catpvn_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_catpvn(SV *dsv, const char *sstr, STRLEN len)
.Ve
.IP "sv_catpvn_flags" 8
.IX Xref "sv_catpvn_flags"
.IX Item "sv_catpvn_flags"
Concatenates tha strang onto tha end of tha strang which is up in tha \s-1SV. \s0 The
\&\f(CW\*(C`len\*(C'\fR indicates number of bytes ta copy.  If tha \s-1SV\s0 has tha \s-1UTF\-8\s0
status set, then tha bytes appended should be valid \s-1UTF\-8.\s0
If \f(CW\*(C`flags\*(C'\fR has tha \f(CW\*(C`SV_SMAGIC\*(C'\fR bit set, will
\&\f(CW\*(C`mg_set\*(C'\fR on \f(CW\*(C`dsv\*(C'\fR afterwardz if appropriate.
\&\f(CW\*(C`sv_catpvn\*(C'\fR n' \f(CW\*(C`sv_catpvn_nomg\*(C'\fR is implemented
in termz of dis function.
.Sp
.Vb 4
\&        void    sv_catpvn_flags(SV *const dstr,
\&                                const char *sstr,
\&                                const STRLEN len,
\&                                const I32 flags)
.Ve
.IP "sv_catpvs" 8
.IX Xref "sv_catpvs"
.IX Item "sv_catpvs"
Like \f(CW\*(C`sv_catpvn\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        void    sv_catpvs(SV* sv, const char* s)
.Ve
.IP "sv_catpvs_flags" 8
.IX Xref "sv_catpvs_flags"
.IX Item "sv_catpvs_flags"
Like \f(CW\*(C`sv_catpvn_flags\*(C'\fR yo, but takes a literal strang instead of a
string/length pair.
.Sp
.Vb 2
\&        void    sv_catpvs_flags(SV* sv, const char* s,
\&                                I32 flags)
.Ve
.IP "sv_catpvs_mg" 8
.IX Xref "sv_catpvs_mg"
.IX Item "sv_catpvs_mg"
Like \f(CW\*(C`sv_catpvn_mg\*(C'\fR yo, but takes a literal strang instead of a
string/length pair.
.Sp
.Vb 1
\&        void    sv_catpvs_mg(SV* sv, const char* s)
.Ve
.IP "sv_catpvs_nomg" 8
.IX Xref "sv_catpvs_nomg"
.IX Item "sv_catpvs_nomg"
Like \f(CW\*(C`sv_catpvn_nomg\*(C'\fR yo, but takes a literal strang instead of a
string/length pair.
.Sp
.Vb 1
\&        void    sv_catpvs_nomg(SV* sv, const char* s)
.Ve
.IP "sv_catpv_flags" 8
.IX Xref "sv_catpv_flags"
.IX Item "sv_catpv_flags"
Concatenates tha strang onto tha end of tha strang which is up in tha \s-1SV.\s0
If tha \s-1SV\s0 has tha \s-1UTF\-8\s0 status set, then tha bytes appended should
be valid \s-1UTF\-8. \s0 If \f(CW\*(C`flags\*(C'\fR has tha \f(CW\*(C`SV_SMAGIC\*(C'\fR bit set, will \f(CW\*(C`mg_set\*(C'\fR
on tha modified \s-1SV\s0 if appropriate.
.Sp
.Vb 2
\&        void    sv_catpv_flags(SV *dstr, const char *sstr,
\&                               const I32 flags)
.Ve
.IP "sv_catpv_mg" 8
.IX Xref "sv_catpv_mg"
.IX Item "sv_catpv_mg"
Like \f(CW\*(C`sv_catpv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_catpv_mg(SV *const sv, const char *const ptr)
.Ve
.IP "sv_catsv" 8
.IX Xref "sv_catsv"
.IX Item "sv_catsv"
Concatenates tha strang from \s-1SV \s0\f(CW\*(C`ssv\*(C'\fR onto tha end of tha strang up in \s-1SV
\&\s0\f(CW\*(C`dsv\*(C'\fR.  If \f(CW\*(C`ssv\*(C'\fR is null, do nothing; otherwise modifies only \f(CW\*(C`dsv\*(C'\fR.
Handlez 'get' magic on both SVs yo, but no 'set' magic.  See \f(CW\*(C`sv_catsv_mg\*(C'\fR and
\&\f(CW\*(C`sv_catsv_nomg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_catsv(SV *dstr, SV *sstr)
.Ve
.IP "sv_catsv_flags" 8
.IX Xref "sv_catsv_flags"
.IX Item "sv_catsv_flags"
Concatenates tha strang from \s-1SV \s0\f(CW\*(C`ssv\*(C'\fR onto tha end of tha strang up in \s-1SV
\&\s0\f(CW\*(C`dsv\*(C'\fR.  If \f(CW\*(C`ssv\*(C'\fR is null, do nothing; otherwise modifies only \f(CW\*(C`dsv\*(C'\fR.
If \f(CW\*(C`flags\*(C'\fR include \f(CW\*(C`SV_GMAGIC\*(C'\fR bit set, will call \f(CW\*(C`mg_get\*(C'\fR on both SVs if
appropriate.  If \f(CW\*(C`flags\*(C'\fR include \f(CW\*(C`SV_SMAGIC\*(C'\fR, \f(CW\*(C`mg_set\*(C'\fR is ghon be called on
the modified \s-1SV\s0 afterward, if appropriate.  \f(CW\*(C`sv_catsv\*(C'\fR, \f(CW\*(C`sv_catsv_nomg\*(C'\fR,
and \f(CW\*(C`sv_catsv_mg\*(C'\fR is implemented up in termz of dis function.
.Sp
.Vb 2
\&        void    sv_catsv_flags(SV *const dsv, SV *const ssv,
\&                               const I32 flags)
.Ve
.IP "sv_chop" 8
.IX Xref "sv_chop"
.IX Item "sv_chop"
Efficient removal of charactas from tha beginnin of tha strang buffer.
SvPOK(sv), or at least SvPOKp(sv), must be legit n' tha \f(CW\*(C`ptr\*(C'\fR must be a
pointa ta somewhere inside tha strang buffer n' shit.  Da \f(CW\*(C`ptr\*(C'\fR becomes tha first
characta of tha adjusted string.  Uses tha \*(L"\s-1OOK\s0 hack\*(R".  On return, only
SvPOK(sv) n' SvPOKp(sv) among tha \s-1OK\s0 flags is ghon be true.
.Sp
Beware: afta dis function returns, \f(CW\*(C`ptr\*(C'\fR n' SvPVX_const(sv) may no longer
refer ta tha same chunk of data.
.Sp
Da fucked up similaritizzle of dis functionz name ta dat of Perlz \f(CW\*(C`chop\*(C'\fR
operator is strictly coincidental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This function works from tha left;
\&\f(CW\*(C`chop\*(C'\fR works from tha right.
.Sp
.Vb 1
\&        void    sv_chop(SV *const sv, const char *const ptr)
.Ve
.IP "sv_clear" 8
.IX Xref "sv_clear"
.IX Item "sv_clear"
Clear a \s-1SV:\s0 call any destructors, free up any memory used by tha body,
and free tha body itself.  Da \s-1SV\s0z head is \fInot\fR freed, although
its type is set ta all 1z so dat it won't inadvertently be assumed
to be live durin global destruction etc.
This function should only be called when \s-1REFCNT\s0 is zero.  Most of tha time
yo dirty ass is gonna wanna call \f(CW\*(C`sv_free()\*(C'\fR (or its macro wrapper \f(CW\*(C`SvREFCNT_dec\*(C'\fR)
instead.
.Sp
.Vb 1
\&        void    sv_clear(SV *const orig_sv)
.Ve
.IP "sv_cmp" 8
.IX Xref "sv_cmp"
.IX Item "sv_cmp"
Compares tha strings up in two SVs.  Returns \-1, 0, or 1 indicatin whether the
strin up in \f(CW\*(C`sv1\*(C'\fR is less than, equal to, or pimped outa than tha strang in
\&\f(CW\*(C`sv2\*(C'\fR.  Is \s-1UTF\-8\s0 n' 'use bytes' aware, handlez git magic, n' will
coerce its args ta strings if necessary.  See also \f(CW\*(C`sv_cmp_locale\*(C'\fR.
.Sp
.Vb 1
\&        I32     sv_cmp(SV *const sv1, SV *const sv2)
.Ve
.IP "sv_cmp_flags" 8
.IX Xref "sv_cmp_flags"
.IX Item "sv_cmp_flags"
Compares tha strings up in two SVs.  Returns \-1, 0, or 1 indicatin whether the
strin up in \f(CW\*(C`sv1\*(C'\fR is less than, equal to, or pimped outa than tha strang in
\&\f(CW\*(C`sv2\*(C'\fR.  Is \s-1UTF\-8\s0 n' 'use bytes' aware n' will coerce its args ta strings
if necessary.  If tha flags include \s-1SV_GMAGIC,\s0 it handlez git magic.  See
also \f(CW\*(C`sv_cmp_locale_flags\*(C'\fR.
.Sp
.Vb 2
\&        I32     sv_cmp_flags(SV *const sv1, SV *const sv2,
\&                             const U32 flags)
.Ve
.IP "sv_cmp_locale" 8
.IX Xref "sv_cmp_locale"
.IX Item "sv_cmp_locale"
Compares tha strings up in two SVs up in a locale-aware manner n' shit.  Is \s-1UTF\-8\s0 and
\&'use bytes' aware, handlez git magic, n' will coerce its args ta strings
if necessary.  See also \f(CW\*(C`sv_cmp\*(C'\fR.
.Sp
.Vb 1
\&        I32     sv_cmp_locale(SV *const sv1, SV *const sv2)
.Ve
.IP "sv_cmp_locale_flags" 8
.IX Xref "sv_cmp_locale_flags"
.IX Item "sv_cmp_locale_flags"
Compares tha strings up in two SVs up in a locale-aware manner n' shit.  Is \s-1UTF\-8\s0 and
\&'use bytes' aware n' will coerce its args ta strings if necessary.  If the
flags contain \s-1SV_GMAGIC,\s0 it handlez git magic.  See also \f(CW\*(C`sv_cmp_flags\*(C'\fR.
.Sp
.Vb 3
\&        I32     sv_cmp_locale_flags(SV *const sv1,
\&                                    SV *const sv2,
\&                                    const U32 flags)
.Ve
.IP "sv_collxfrm" 8
.IX Xref "sv_collxfrm"
.IX Item "sv_collxfrm"
This calls \f(CW\*(C`sv_collxfrm_flags\*(C'\fR wit tha \s-1SV_GMAGIC\s0 flag.  See
\&\f(CW\*(C`sv_collxfrm_flags\*(C'\fR.
.Sp
.Vb 1
\&        char*   sv_collxfrm(SV *const sv, STRLEN *const nxp)
.Ve
.IP "sv_collxfrm_flags" 8
.IX Xref "sv_collxfrm_flags"
.IX Item "sv_collxfrm_flags"
Add Collate Transform magic ta a \s-1SV\s0 if it don't already have dat shit.  If the
flags contain \s-1SV_GMAGIC,\s0 it handlez get-magic.
.Sp
Any scalar variable may carry PERL_MAGIC_collxfrm magic dat gotz nuff the
scalar data of tha variable yo, but transformed ta such a gangbangin' format dat a normal
memory comparison can be used ta compare tha data accordin ta tha locale
settings.
.Sp
.Vb 3
\&        char*   sv_collxfrm_flags(SV *const sv,
\&                                  STRLEN *const nxp,
\&                                  I32 const flags)
.Ve
.IP "sv_copypv_flags" 8
.IX Xref "sv_copypv_flags"
.IX Item "sv_copypv_flags"
Implementation of sv_copypv n' sv_copypv_nomg.  Calls git magic iff flags
include \s-1SV_GMAGIC.\s0
.Sp
.Vb 2
\&        void    sv_copypv_flags(SV *const dsv, SV *const ssv,
\&                                const I32 flags)
.Ve
.IP "sv_copypv_nomg" 8
.IX Xref "sv_copypv_nomg"
.IX Item "sv_copypv_nomg"
Like sv_copypv yo, but don't invoke git magic first.
.Sp
.Vb 1
\&        void    sv_copypv_nomg(SV *const dsv, SV *const ssv)
.Ve
.IP "sv_dec" 8
.IX Xref "sv_dec"
.IX Item "sv_dec"
Auto-decrement of tha value up in tha \s-1SV,\s0 bustin strang ta numeric conversion
if necessary.  Handlez 'get' magic n' operator overloading.
.Sp
.Vb 1
\&        void    sv_dec(SV *const sv)
.Ve
.IP "sv_dec_nomg" 8
.IX Xref "sv_dec_nomg"
.IX Item "sv_dec_nomg"
Auto-decrement of tha value up in tha \s-1SV,\s0 bustin strang ta numeric conversion
if necessary.  Handlez operator overloading.  Skips handlin 'get' magic.
.Sp
.Vb 1
\&        void    sv_dec_nomg(SV *const sv)
.Ve
.IP "sv_eq" 8
.IX Xref "sv_eq"
.IX Item "sv_eq"
Returns a funky-ass boolean indicatin whether tha strings up in tha two SVs are
identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Is \s-1UTF\-8\s0 n' 'use bytes' aware, handlez git magic, n' will
coerce its args ta strings if necessary.
.Sp
.Vb 1
\&        I32     sv_eq(SV* sv1, SV* sv2)
.Ve
.IP "sv_eq_flags" 8
.IX Xref "sv_eq_flags"
.IX Item "sv_eq_flags"
Returns a funky-ass boolean indicatin whether tha strings up in tha two SVs are
identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Is \s-1UTF\-8\s0 n' 'use bytes' aware n' coerces its args ta strings
if necessary.  If tha flags include \s-1SV_GMAGIC,\s0 it handlez get-magic, like a muthafucka.
.Sp
.Vb 1
\&        I32     sv_eq_flags(SV* sv1, SV* sv2, const U32 flags)
.Ve
.IP "sv_force_normal_flags" 8
.IX Xref "sv_force_normal_flags"
.IX Item "sv_force_normal_flags"
Undo various typez of fakery on a \s-1SV,\s0 where fakery means
\&\*(L"more than\*(R" a string: if tha \s-1PV\s0 be a gangbangin' finger-lickin' dirty-ass shared string, make
a private copy; if we a ref, stop refing; if we a glob, downgrade to
an xpvmg; if we a cold-ass lil copy-on-write scalar, dis is tha on-write time when
we do tha copy, n' be also used locally; if dis be a
vstring, drop tha vstrin magic.  If \f(CW\*(C`SV_COW_DROP_PV\*(C'\fR is set
then a cold-ass lil copy-on-write scalar drops its \s-1PV\s0 buffer (if any) n' becomes
SvPOK_off rather than bustin a cold-ass lil copy.  (Used where this
scalar be bout ta be set ta some other value.)  In addition,
the \f(CW\*(C`flags\*(C'\fR parameta gets passed ta \f(CW\*(C`sv_unref_flags()\*(C'\fR
when unreffing.  \f(CW\*(C`sv_force_normal\*(C'\fR calls dis function
with flags set ta 0.
.Sp
.Vb 2
\&        void    sv_force_normal_flags(SV *const sv,
\&                                      const U32 flags)
.Ve
.IP "sv_free" 8
.IX Xref "sv_free"
.IX Item "sv_free"
Decrement a \s-1SV\s0z reference count, n' if it drops ta zero, call
\&\f(CW\*(C`sv_clear\*(C'\fR ta invoke destructors n' free up any memory used by
the body; finally, deallocate tha \s-1SV\s0z head itself.
Normally called via a wrapper macro \f(CW\*(C`SvREFCNT_dec\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_free(SV *const sv)
.Ve
.IP "sv_gets" 8
.IX Xref "sv_gets"
.IX Item "sv_gets"
Git a line from tha filehandle n' store it tha fuck into tha \s-1SV,\s0 optionally
appendin ta tha currently-stored string. If \f(CW\*(C`append\*(C'\fR aint 0, the
line be appended ta tha \s-1SV\s0 instead of overwritin dat shit. \f(CW\*(C`append\*(C'\fR should
be set ta tha byte offset dat tha appended strang should start at
in tha \s-1SV \s0(typically, \f(CW\*(C`SvCUR(sv)\*(C'\fR be a suitable chizzle).
.Sp
.Vb 2
\&        char*   sv_gets(SV *const sv, PerlIO *const fp,
\&                        I32 append)
.Ve
.IP "sv_grow" 8
.IX Xref "sv_grow"
.IX Item "sv_grow"
Expandz tha characta buffer up in tha \s-1SV. \s0 If necessary, uses \f(CW\*(C`sv_unref\*(C'\fR and
upgrades tha \s-1SV\s0 ta \f(CW\*(C`SVt_PV\*(C'\fR.  Returns a pointa ta tha characta buffer.
Use tha \f(CW\*(C`SvGROW\*(C'\fR wrapper instead.
.Sp
.Vb 1
\&        char*   sv_grow(SV *const sv, STRLEN newlen)
.Ve
.IP "sv_inc" 8
.IX Xref "sv_inc"
.IX Item "sv_inc"
Auto-increment of tha value up in tha \s-1SV,\s0 bustin strang ta numeric conversion
if necessary.  Handlez 'get' magic n' operator overloading.
.Sp
.Vb 1
\&        void    sv_inc(SV *const sv)
.Ve
.IP "sv_inc_nomg" 8
.IX Xref "sv_inc_nomg"
.IX Item "sv_inc_nomg"
Auto-increment of tha value up in tha \s-1SV,\s0 bustin strang ta numeric conversion
if necessary.  Handlez operator overloading.  Skips handlin 'get' magic.
.Sp
.Vb 1
\&        void    sv_inc_nomg(SV *const sv)
.Ve
.IP "sv_insert" 8
.IX Xref "sv_insert"
.IX Item "sv_insert"
Inserts a strang all up in tha specified offset/length within tha \s-1SV. \s0 Similar to
the Perl \fIsubstr()\fR function. I aint talkin' bout chicken n' gravy biatch.  Handlez git magic.
.Sp
.Vb 4
\&        void    sv_insert(SV *const bigstr, const STRLEN offset,
\&                          const STRLEN len,
\&                          const char *const lil,
\&                          const STRLEN lillen)
.Ve
.IP "sv_insert_flags" 8
.IX Xref "sv_insert_flags"
.IX Item "sv_insert_flags"
Same as \f(CW\*(C`sv_insert\*(C'\fR yo, but tha extra \f(CW\*(C`flags\*(C'\fR is passed ta the
\&\f(CW\*(C`SvPV_force_flags\*(C'\fR dat applies ta \f(CW\*(C`bigstr\*(C'\fR.
.Sp
.Vb 6
\&        void    sv_insert_flags(SV *const bigstr,
\&                                const STRLEN offset,
\&                                const STRLEN len,
\&                                const char *const lil,
\&                                const STRLEN lillen,
\&                                const U32 flags)
.Ve
.IP "sv_isa" 8
.IX Xref "sv_isa"
.IX Item "sv_isa"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 is pimped tha fuck into tha specified
class.  This do not check fo' subtypes; use \f(CW\*(C`sv_derived_from\*(C'\fR ta verify
an inheritizzle relationshizzle.
.Sp
.Vb 1
\&        int     sv_isa(SV* sv, const char *const name)
.Ve
.IP "sv_isobject" 8
.IX Xref "sv_isobject"
.IX Item "sv_isobject"
Returns a funky-ass boolean indicatin whether tha \s-1SV\s0 be a \s-1RV\s0 pointin ta a pimped
object.  If tha \s-1SV\s0 aint a \s-1RV,\s0 or if tha object aint pimped, then this
will return false.
.Sp
.Vb 1
\&        int     sv_isobject(SV* sv)
.Ve
.IP "sv_len" 8
.IX Xref "sv_len"
.IX Item "sv_len"
Returns tha length of tha strang up in tha \s-1SV. \s0 Handlez magic n' type
coercion n' sets tha \s-1UTF8\s0 flag appropriately.  See also \f(CW\*(C`SvCUR\*(C'\fR, which
gives raw access ta tha xpv_cur slot.
.Sp
.Vb 1
\&        STRLEN  sv_len(SV *const sv)
.Ve
.IP "sv_len_utf8" 8
.IX Xref "sv_len_utf8"
.IX Item "sv_len_utf8"
Returns tha number of charactas up in tha strang up in a \s-1SV,\s0 countin wide
\&\s-1UTF\-8\s0 bytes as a single character n' shit.  Handlez magic n' type coercion.
.Sp
.Vb 1
\&        STRLEN  sv_len_utf8(SV *const sv)
.Ve
.IP "sv_magic" 8
.IX Xref "sv_magic"
.IX Item "sv_magic"
Addz magic ta a \s-1SV. \s0 First upgrades \f(CW\*(C`sv\*(C'\fR ta type \f(CW\*(C`SVt_PVMG\*(C'\fR if
necessary, then addz a freshly smoked up magic item of type \f(CW\*(C`how\*(C'\fR ta tha head of the
magic list.
.Sp
See \f(CW\*(C`sv_magicext\*(C'\fR (which \f(CW\*(C`sv_magic\*(C'\fR now calls) fo' a thugged-out description of the
handlin of tha \f(CW\*(C`name\*(C'\fR n' \f(CW\*(C`namlen\*(C'\fR arguments.
.Sp
Yo ass need ta use \f(CW\*(C`sv_magicext\*(C'\fR ta add magic ta SvREADONLY SVs n' also
to add mo' than one instizzle of tha same 'how'.
.Sp
.Vb 3
\&        void    sv_magic(SV *const sv, SV *const obj,
\&                         const int how, const char *const name,
\&                         const I32 namlen)
.Ve
.IP "sv_magicext" 8
.IX Xref "sv_magicext"
.IX Item "sv_magicext"
Addz magic ta a \s-1SV,\s0 upgradin it if necessary.  Applies the
supplied vtable n' returns a pointa ta tha magic added.
.Sp
Note dat \f(CW\*(C`sv_magicext\*(C'\fR will allow thangs dat \f(CW\*(C`sv_magic\*(C'\fR will not.
In particular, you can add magic ta SvREADONLY SVs, n' add mo' than
one instizzle of tha same 'how'.
.Sp
If \f(CW\*(C`namlen\*(C'\fR is pimped outa than zero then a \f(CW\*(C`savepvn\*(C'\fR \fIcopy\fR of \f(CW\*(C`name\*(C'\fR is
stored, if \f(CW\*(C`namlen\*(C'\fR is zero then \f(CW\*(C`name\*(C'\fR is stored as-is n' \- as another
special case \- if \f(CW\*(C`(name && namlen == HEf_SVKEY)\*(C'\fR then \f(CW\*(C`name\*(C'\fR be assumed
to contain a \f(CW\*(C`SV*\*(C'\fR n' is stored as-is wit its \s-1REFCNT\s0 incremented.
.Sp
(This is now used as a subroutine by \f(CW\*(C`sv_magic\*(C'\fR.)
.Sp
.Vb 5
\&        MAGIC * sv_magicext(SV *const sv, SV *const obj,
\&                            const int how,
\&                            const MGVTBL *const vtbl,
\&                            const char *const name,
\&                            const I32 namlen)
.Ve
.IP "sv_mortalcopy" 8
.IX Xref "sv_mortalcopy"
.IX Item "sv_mortalcopy"
Creates a freshly smoked up \s-1SV\s0 which be a cold-ass lil copy of tha original gangsta \s-1SV \s0(usin \f(CW\*(C`sv_setsv\*(C'\fR).
Da freshly smoked up \s-1SV\s0 is marked as mortal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  It is ghon be destroyed \*(L"soon\*(R", either by an
explicit call ta \s-1FREETMPS,\s0 or by a implicit call at places such as
statement boundaries. Put ya muthafuckin choppers up if ya feel dis!  See also \f(CW\*(C`sv_newmortal\*(C'\fR n' \f(CW\*(C`sv_2mortal\*(C'\fR.
.Sp
.Vb 1
\&        SV*     sv_mortalcopy(SV *const oldsv)
.Ve
.IP "sv_newmortal" 8
.IX Xref "sv_newmortal"
.IX Item "sv_newmortal"
Creates a freshly smoked up null \s-1SV\s0 which is mortal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da reference count of tha \s-1SV\s0 is
set ta 1.  It is ghon be destroyed \*(L"soon\*(R", either by a explicit call to
\&\s-1FREETMPS,\s0 or by a implicit call at places like fuckin statement boundaries.
See also \f(CW\*(C`sv_mortalcopy\*(C'\fR n' \f(CW\*(C`sv_2mortal\*(C'\fR.
.Sp
.Vb 1
\&        SV*     sv_newmortal()
.Ve
.IP "sv_newref" 8
.IX Xref "sv_newref"
.IX Item "sv_newref"
Increment a \s-1SV\s0z reference count.  Use tha \f(CW\*(C`SvREFCNT_inc()\*(C'\fR wrapper
instead.
.Sp
.Vb 1
\&        SV*     sv_newref(SV *const sv)
.Ve
.IP "sv_pos_b2u" 8
.IX Xref "sv_pos_b2u"
.IX Item "sv_pos_b2u"
Converts tha value pointed ta by offsetp from a cold-ass lil count of bytes from the
start of tha string, ta a cold-ass lil count of tha equivalent number of \s-1UTF\-8\s0 chars.
Handlez magic n' type coercion.
.Sp
.Vb 1
\&        void    sv_pos_b2u(SV *const sv, I32 *const offsetp)
.Ve
.IP "sv_pos_u2b" 8
.IX Xref "sv_pos_u2b"
.IX Item "sv_pos_u2b"
Converts tha value pointed ta by offsetp from a cold-ass lil count of \s-1UTF\-8\s0 chars from
the start of tha string, ta a cold-ass lil count of tha equivalent number of bytes; if
lenp is non-zero, it do tha same ta lenp yo, but dis time startin from
the offset, rather than from tha start of tha string.  Handlez magic and
type coercion.
.Sp
Use \f(CW\*(C`sv_pos_u2b_flags\*(C'\fR up in preference, which erectly handlez strings longer
than 2Gb.
.Sp
.Vb 2
\&        void    sv_pos_u2b(SV *const sv, I32 *const offsetp,
\&                           I32 *const lenp)
.Ve
.IP "sv_pos_u2b_flags" 8
.IX Xref "sv_pos_u2b_flags"
.IX Item "sv_pos_u2b_flags"
Converts tha value pointed ta by offsetp from a cold-ass lil count of \s-1UTF\-8\s0 chars from
the start of tha string, ta a cold-ass lil count of tha equivalent number of bytes; if
lenp is non-zero, it do tha same ta lenp yo, but dis time startin from
the offset, rather than from tha start
of tha string.  Handlez type coercion.
\&\fIflags\fR is passed ta \f(CW\*(C`SvPV_flags\*(C'\fR, n' probably should be
\&\f(CW\*(C`SV_GMAGIC|SV_CONST_RETURN\*(C'\fR ta handle magic.
.Sp
.Vb 2
\&        STRLEN  sv_pos_u2b_flags(SV *const sv, STRLEN uoffset,
\&                                 STRLEN *const lenp, U32 flags)
.Ve
.IP "sv_pvbyten_force" 8
.IX Xref "sv_pvbyten_force"
.IX Item "sv_pvbyten_force"
Da backend fo' tha \f(CW\*(C`SvPVbytex_force\*(C'\fR macro.  Always use tha macro
instead.
.Sp
.Vb 1
\&        char*   sv_pvbyten_force(SV *const sv, STRLEN *const lp)
.Ve
.IP "sv_pvn_force" 8
.IX Xref "sv_pvn_force"
.IX Item "sv_pvn_force"
Git a sensible strang outta tha \s-1SV\s0 somehow.
A private implementation of tha \f(CW\*(C`SvPV_force\*(C'\fR macro fo' compilaz which
can't cope wit complex macro expressions.  Always use tha macro instead.
.Sp
.Vb 1
\&        char*   sv_pvn_force(SV* sv, STRLEN* lp)
.Ve
.IP "sv_pvn_force_flags" 8
.IX Xref "sv_pvn_force_flags"
.IX Item "sv_pvn_force_flags"
Git a sensible strang outta tha \s-1SV\s0 somehow.
If \f(CW\*(C`flags\*(C'\fR has \f(CW\*(C`SV_GMAGIC\*(C'\fR bit set, will \f(CW\*(C`mg_get\*(C'\fR on \f(CW\*(C`sv\*(C'\fR if
appropriate, else not.  \f(CW\*(C`sv_pvn_force\*(C'\fR n' \f(CW\*(C`sv_pvn_force_nomg\*(C'\fR are
implemented up in termz of dis function.
Yo ass normally wanna use tha various wrapper macros instead: see
\&\f(CW\*(C`SvPV_force\*(C'\fR n' \f(CW\*(C`SvPV_force_nomg\*(C'\fR
.Sp
.Vb 3
\&        char*   sv_pvn_force_flags(SV *const sv,
\&                                   STRLEN *const lp,
\&                                   const I32 flags)
.Ve
.IP "sv_pvutf8n_force" 8
.IX Xref "sv_pvutf8n_force"
.IX Item "sv_pvutf8n_force"
Da backend fo' tha \f(CW\*(C`SvPVutf8x_force\*(C'\fR macro.  Always use tha macro
instead.
.Sp
.Vb 1
\&        char*   sv_pvutf8n_force(SV *const sv, STRLEN *const lp)
.Ve
.IP "sv_reftype" 8
.IX Xref "sv_reftype"
.IX Item "sv_reftype"
Returns a strang describin what tha fuck tha \s-1SV\s0 be a reference to.
.Sp
.Vb 1
\&        const char* sv_reftype(const SV *const sv, const int ob)
.Ve
.IP "sv_replace" 8
.IX Xref "sv_replace"
.IX Item "sv_replace"
Make tha straight-up original gangsta argument a cold-ass lil copy of tha second, then delete tha original.
Da target \s-1SV\s0 physically takes over ballershizzle of tha body of tha source \s-1SV\s0
and inherits its flags; however, tha target keeps any magic it owns,
and any magic up in tha source is discarded.
Note dat dis be a rather specialist \s-1SV\s0 copyin operation; most of the
time you gonna wanna use \f(CW\*(C`sv_setsv\*(C'\fR or one of its nuff macro front-ends.
.Sp
.Vb 1
\&        void    sv_replace(SV *const sv, SV *const nsv)
.Ve
.IP "sv_reset" 8
.IX Xref "sv_reset"
.IX Item "sv_reset"
Underlyin implementation fo' tha \f(CW\*(C`reset\*(C'\fR Perl function.
Note dat tha perl-level function is vaguely deprecated.
.Sp
.Vb 1
\&        void    sv_reset(const char* s, HV *const stash)
.Ve
.IP "sv_rvweaken" 8
.IX Xref "sv_rvweaken"
.IX Item "sv_rvweaken"
Weaken a reference: set tha \f(CW\*(C`SvWEAKREF\*(C'\fR flag on dis \s-1RV\s0; give the
referred-to \s-1SV \s0\f(CW\*(C`PERL_MAGIC_backref\*(C'\fR magic if it aint already; and
push a funky-ass back-reference ta dis \s-1RV\s0 onto tha array of backreferences
associated wit dat magic.  If tha \s-1RV\s0 is magical, set magic will be
called afta tha \s-1RV\s0 is cleared.
.Sp
.Vb 1
\&        SV*     sv_rvweaken(SV *const sv)
.Ve
.IP "sv_setiv" 8
.IX Xref "sv_setiv"
.IX Item "sv_setiv"
Copies a integer tha fuck into tha given \s-1SV,\s0 upgradin first if necessary.
Do not handle 'set' magic.  See also \f(CW\*(C`sv_setiv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setiv(SV *const sv, const IV num)
.Ve
.IP "sv_setiv_mg" 8
.IX Xref "sv_setiv_mg"
.IX Item "sv_setiv_mg"
Like \f(CW\*(C`sv_setiv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setiv_mg(SV *const sv, const IV i)
.Ve
.IP "sv_setnv" 8
.IX Xref "sv_setnv"
.IX Item "sv_setnv"
Copies a thugged-out double tha fuck into tha given \s-1SV,\s0 upgradin first if necessary.
Do not handle 'set' magic.  See also \f(CW\*(C`sv_setnv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setnv(SV *const sv, const NV num)
.Ve
.IP "sv_setnv_mg" 8
.IX Xref "sv_setnv_mg"
.IX Item "sv_setnv_mg"
Like \f(CW\*(C`sv_setnv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setnv_mg(SV *const sv, const NV num)
.Ve
.IP "sv_setpv" 8
.IX Xref "sv_setpv"
.IX Item "sv_setpv"
Copies a strang tha fuck into a \s-1SV. \s0 Da strang must be null-terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Do not
handle 'set' magic.  See \f(CW\*(C`sv_setpv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setpv(SV *const sv, const char *const ptr)
.Ve
.IP "sv_setpvf" 8
.IX Xref "sv_setpvf"
.IX Item "sv_setpvf"
Works like \f(CW\*(C`sv_catpvf\*(C'\fR but copies tha text tha fuck into tha \s-1SV\s0 instead of
appendin dat shit.  Do not handle 'set' magic.  See \f(CW\*(C`sv_setpvf_mg\*(C'\fR.
.Sp
.Vb 2
\&        void    sv_setpvf(SV *const sv, const char *const pat,
\&                          ...)
.Ve
.IP "sv_setpvf_mg" 8
.IX Xref "sv_setpvf_mg"
.IX Item "sv_setpvf_mg"
Like \f(CW\*(C`sv_setpvf\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 2
\&        void    sv_setpvf_mg(SV *const sv,
\&                             const char *const pat, ...)
.Ve
.IP "sv_setpviv" 8
.IX Xref "sv_setpviv"
.IX Item "sv_setpviv"
Copies a integer tha fuck into tha given \s-1SV,\s0 also uppimpin its strang value.
Do not handle 'set' magic.  See \f(CW\*(C`sv_setpviv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setpviv(SV *const sv, const IV num)
.Ve
.IP "sv_setpviv_mg" 8
.IX Xref "sv_setpviv_mg"
.IX Item "sv_setpviv_mg"
Like \f(CW\*(C`sv_setpviv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setpviv_mg(SV *const sv, const IV iv)
.Ve
.IP "sv_setpvn" 8
.IX Xref "sv_setpvn"
.IX Item "sv_setpvn"
Copies a strang tha fuck into a \s-1SV. \s0 Da \f(CW\*(C`len\*(C'\fR parameta indicates tha number of
bytes ta be copied. Y'all KNOW dat shit, muthafucka!  If tha \f(CW\*(C`ptr\*(C'\fR argument is \s-1NULL\s0 tha \s-1SV\s0 will become
undefined. Y'all KNOW dat shit, muthafucka!  Do not handle 'set' magic.  See \f(CW\*(C`sv_setpvn_mg\*(C'\fR.
.Sp
.Vb 2
\&        void    sv_setpvn(SV *const sv, const char *const ptr,
\&                          const STRLEN len)
.Ve
.IP "sv_setpvn_mg" 8
.IX Xref "sv_setpvn_mg"
.IX Item "sv_setpvn_mg"
Like \f(CW\*(C`sv_setpvn\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 3
\&        void    sv_setpvn_mg(SV *const sv,
\&                             const char *const ptr,
\&                             const STRLEN len)
.Ve
.IP "sv_setpvs" 8
.IX Xref "sv_setpvs"
.IX Item "sv_setpvs"
Like \f(CW\*(C`sv_setpvn\*(C'\fR yo, but takes a literal strang instead of a string/length pair.
.Sp
.Vb 1
\&        void    sv_setpvs(SV* sv, const char* s)
.Ve
.IP "sv_setpvs_mg" 8
.IX Xref "sv_setpvs_mg"
.IX Item "sv_setpvs_mg"
Like \f(CW\*(C`sv_setpvn_mg\*(C'\fR yo, but takes a literal strang instead of a
string/length pair.
.Sp
.Vb 1
\&        void    sv_setpvs_mg(SV* sv, const char* s)
.Ve
.IP "sv_setpv_mg" 8
.IX Xref "sv_setpv_mg"
.IX Item "sv_setpv_mg"
Like \f(CW\*(C`sv_setpv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setpv_mg(SV *const sv, const char *const ptr)
.Ve
.IP "sv_setref_iv" 8
.IX Xref "sv_setref_iv"
.IX Item "sv_setref_iv"
Copies a integer tha fuck into a freshly smoked up \s-1SV,\s0 optionally blessin tha \s-1SV. \s0 Da \f(CW\*(C`rv\*(C'\fR
argument is ghon be upgraded ta a \s-1RV. \s0 That \s-1RV\s0 is ghon be modified ta point to
the freshly smoked up \s-1SV. \s0 Da \f(CW\*(C`classname\*(C'\fR argument indicates tha package fo' the
blessing.  Set \f(CW\*(C`classname\*(C'\fR ta \f(CW\*(C`NULL\*(C'\fR ta avoid tha blessing.  Da freshly smoked up \s-1SV\s0
will gotz a reference count of 1, n' tha \s-1RV\s0 is ghon be returned.
.Sp
.Vb 3
\&        SV*     sv_setref_iv(SV *const rv,
\&                             const char *const classname,
\&                             const IV iv)
.Ve
.IP "sv_setref_nv" 8
.IX Xref "sv_setref_nv"
.IX Item "sv_setref_nv"
Copies a thugged-out double tha fuck into a freshly smoked up \s-1SV,\s0 optionally blessin tha \s-1SV. \s0 Da \f(CW\*(C`rv\*(C'\fR
argument is ghon be upgraded ta a \s-1RV. \s0 That \s-1RV\s0 is ghon be modified ta point to
the freshly smoked up \s-1SV. \s0 Da \f(CW\*(C`classname\*(C'\fR argument indicates tha package fo' the
blessing.  Set \f(CW\*(C`classname\*(C'\fR ta \f(CW\*(C`NULL\*(C'\fR ta avoid tha blessing.  Da freshly smoked up \s-1SV\s0
will gotz a reference count of 1, n' tha \s-1RV\s0 is ghon be returned.
.Sp
.Vb 3
\&        SV*     sv_setref_nv(SV *const rv,
\&                             const char *const classname,
\&                             const NV nv)
.Ve
.IP "sv_setref_pv" 8
.IX Xref "sv_setref_pv"
.IX Item "sv_setref_pv"
Copies a pointa tha fuck into a freshly smoked up \s-1SV,\s0 optionally blessin tha \s-1SV. \s0 Da \f(CW\*(C`rv\*(C'\fR
argument is ghon be upgraded ta a \s-1RV. \s0 That \s-1RV\s0 is ghon be modified ta point to
the freshly smoked up \s-1SV. \s0 If tha \f(CW\*(C`pv\*(C'\fR argument is \s-1NULL\s0 then \f(CW\*(C`PL_sv_undef\*(C'\fR is ghon be placed
into tha \s-1SV. \s0 Da \f(CW\*(C`classname\*(C'\fR argument indicates tha package fo' the
blessing.  Set \f(CW\*(C`classname\*(C'\fR ta \f(CW\*(C`NULL\*(C'\fR ta avoid tha blessing.  Da freshly smoked up \s-1SV\s0
will gotz a reference count of 1, n' tha \s-1RV\s0 is ghon be returned.
.Sp
Do not use wit other Perl types like fuckin \s-1HV, AV, SV, CV,\s0 cuz them
objects will become corrupted by tha pointa copy process.
.Sp
Note dat \f(CW\*(C`sv_setref_pvn\*(C'\fR copies tha strang while dis copies tha pointer.
.Sp
.Vb 3
\&        SV*     sv_setref_pv(SV *const rv,
\&                             const char *const classname,
\&                             void *const pv)
.Ve
.IP "sv_setref_pvn" 8
.IX Xref "sv_setref_pvn"
.IX Item "sv_setref_pvn"
Copies a strang tha fuck into a freshly smoked up \s-1SV,\s0 optionally blessin tha \s-1SV. \s0 Da length of the
strin must be specified wit \f(CW\*(C`n\*(C'\fR.  Da \f(CW\*(C`rv\*(C'\fR argument is ghon be upgraded to
an \s-1RV. \s0 That \s-1RV\s0 is ghon be modified ta point ta tha freshly smoked up \s-1SV. \s0 Da \f(CW\*(C`classname\*(C'\fR
argument indicates tha package fo' tha blessing.  Set \f(CW\*(C`classname\*(C'\fR to
\&\f(CW\*(C`NULL\*(C'\fR ta avoid tha blessing.  Da freshly smoked up \s-1SV\s0 gonna git a reference count
of 1, n' tha \s-1RV\s0 is ghon be returned.
.Sp
Note dat \f(CW\*(C`sv_setref_pv\*(C'\fR copies tha pointa while dis copies tha string.
.Sp
.Vb 4
\&        SV*     sv_setref_pvn(SV *const rv,
\&                              const char *const classname,
\&                              const char *const pv,
\&                              const STRLEN n)
.Ve
.IP "sv_setref_pvs" 8
.IX Xref "sv_setref_pvs"
.IX Item "sv_setref_pvs"
Like \f(CW\*(C`sv_setref_pvn\*(C'\fR yo, but takes a literal strang instead of a
string/length pair.
.Sp
.Vb 1
\&        SV *    sv_setref_pvs(const char* s)
.Ve
.IP "sv_setref_uv" 8
.IX Xref "sv_setref_uv"
.IX Item "sv_setref_uv"
Copies a unsigned integer tha fuck into a freshly smoked up \s-1SV,\s0 optionally blessin tha \s-1SV. \s0 Da \f(CW\*(C`rv\*(C'\fR
argument is ghon be upgraded ta a \s-1RV. \s0 That \s-1RV\s0 is ghon be modified ta point to
the freshly smoked up \s-1SV. \s0 Da \f(CW\*(C`classname\*(C'\fR argument indicates tha package fo' the
blessing.  Set \f(CW\*(C`classname\*(C'\fR ta \f(CW\*(C`NULL\*(C'\fR ta avoid tha blessing.  Da freshly smoked up \s-1SV\s0
will gotz a reference count of 1, n' tha \s-1RV\s0 is ghon be returned.
.Sp
.Vb 3
\&        SV*     sv_setref_uv(SV *const rv,
\&                             const char *const classname,
\&                             const UV uv)
.Ve
.IP "sv_setsv" 8
.IX Xref "sv_setsv"
.IX Item "sv_setsv"
Copies tha contentz of tha source \s-1SV \s0\f(CW\*(C`ssv\*(C'\fR tha fuck into tha destination \s-1SV
\&\s0\f(CW\*(C`dsv\*(C'\fR.  Da source \s-1SV\s0 may be destroyed if it is mortal, so don't use this
function if tha source \s-1SV\s0 need ta be reused. Y'all KNOW dat shit, muthafucka!  Do not handle 'set' magic.
Loosely bustin lyrics, it performs a cold-ass lil copy-by-value, obliteratin any previous
content of tha destination.
.Sp
Yo ass probably wanna use one of tha assortment of wrappers, such as
\&\f(CW\*(C`SvSetSV\*(C'\fR, \f(CW\*(C`SvSetSV_nosteal\*(C'\fR, \f(CW\*(C`SvSetMagicSV\*(C'\fR and
\&\f(CW\*(C`SvSetMagicSV_nosteal\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setsv(SV *dstr, SV *sstr)
.Ve
.IP "sv_setsv_flags" 8
.IX Xref "sv_setsv_flags"
.IX Item "sv_setsv_flags"
Copies tha contentz of tha source \s-1SV \s0\f(CW\*(C`ssv\*(C'\fR tha fuck into tha destination \s-1SV
\&\s0\f(CW\*(C`dsv\*(C'\fR.  Da source \s-1SV\s0 may be destroyed if it is mortal, so don't use this
function if tha source \s-1SV\s0 need ta be reused. Y'all KNOW dat shit, muthafucka!  Do not handle 'set' magic.
Loosely bustin lyrics, it performs a cold-ass lil copy-by-value, obliteratin any previous
content of tha destination.
If tha \f(CW\*(C`flags\*(C'\fR parameta has tha \f(CW\*(C`SV_GMAGIC\*(C'\fR bit set, will \f(CW\*(C`mg_get\*(C'\fR on
\&\f(CW\*(C`ssv\*(C'\fR if appropriate, else not.  If tha \f(CW\*(C`flags\*(C'\fR
parameta has tha \f(CW\*(C`NOSTEAL\*(C'\fR bit set then the
bufferz of temps aint gonna be jacked. I aint talkin' bout chicken n' gravy biatch.  <sv_setsv>
and \f(CW\*(C`sv_setsv_nomg\*(C'\fR is implemented up in termz of dis function.
.Sp
Yo ass probably wanna use one of tha assortment of wrappers, such as
\&\f(CW\*(C`SvSetSV\*(C'\fR, \f(CW\*(C`SvSetSV_nosteal\*(C'\fR, \f(CW\*(C`SvSetMagicSV\*(C'\fR and
\&\f(CW\*(C`SvSetMagicSV_nosteal\*(C'\fR.
.Sp
This is tha primary function fo' copyin scalars, n' most other
copy-ish functions n' macros use dis underneath.
.Sp
.Vb 2
\&        void    sv_setsv_flags(SV *dstr, SV *sstr,
\&                               const I32 flags)
.Ve
.IP "sv_setsv_mg" 8
.IX Xref "sv_setsv_mg"
.IX Item "sv_setsv_mg"
Like \f(CW\*(C`sv_setsv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setsv_mg(SV *const dstr, SV *const sstr)
.Ve
.IP "sv_setuv" 8
.IX Xref "sv_setuv"
.IX Item "sv_setuv"
Copies a unsigned integer tha fuck into tha given \s-1SV,\s0 upgradin first if necessary.
Do not handle 'set' magic.  See also \f(CW\*(C`sv_setuv_mg\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_setuv(SV *const sv, const UV num)
.Ve
.IP "sv_setuv_mg" 8
.IX Xref "sv_setuv_mg"
.IX Item "sv_setuv_mg"
Like \f(CW\*(C`sv_setuv\*(C'\fR yo, but also handlez 'set' magic.
.Sp
.Vb 1
\&        void    sv_setuv_mg(SV *const sv, const UV u)
.Ve
.IP "sv_tainted" 8
.IX Xref "sv_tainted"
.IX Item "sv_tainted"
Test a \s-1SV\s0 fo' taintedness.  Use \f(CW\*(C`SvTAINTED\*(C'\fR instead.
.Sp
.Vb 1
\&        bool    sv_tainted(SV *const sv)
.Ve
.IP "sv_true" 8
.IX Xref "sv_true"
.IX Item "sv_true"
Returns legit if tha \s-1SV\s0 has a legit value by Perlz rules.
Use tha \f(CW\*(C`SvTRUE\*(C'\fR macro instead, which may call \f(CW\*(C`sv_true()\*(C'\fR or may
instead use a in-line version.
.Sp
.Vb 1
\&        I32     sv_true(SV *const sv)
.Ve
.IP "sv_unmagic" 8
.IX Xref "sv_unmagic"
.IX Item "sv_unmagic"
Removes all magic of type \f(CW\*(C`type\*(C'\fR from a \s-1SV.\s0
.Sp
.Vb 1
\&        int     sv_unmagic(SV *const sv, const int type)
.Ve
.IP "sv_unmagicext" 8
.IX Xref "sv_unmagicext"
.IX Item "sv_unmagicext"
Removes all magic of type \f(CW\*(C`type\*(C'\fR wit tha specified \f(CW\*(C`vtbl\*(C'\fR from a \s-1SV.\s0
.Sp
.Vb 2
\&        int     sv_unmagicext(SV *const sv, const int type,
\&                              MGVTBL *vtbl)
.Ve
.IP "sv_unref_flags" 8
.IX Xref "sv_unref_flags"
.IX Item "sv_unref_flags"
Unsets tha \s-1RV\s0 statuz of tha \s-1SV,\s0 n' decrements tha reference count of
whatever was bein referenced by tha \s-1RV. \s0 This can almost be thought of
as a reversal of \f(CW\*(C`newSVrv\*(C'\fR.  Da \f(CW\*(C`cflags\*(C'\fR argument can contain
\&\f(CW\*(C`SV_IMMEDIATE_UNREF\*(C'\fR ta force tha reference count ta be decremented
(otherwise tha decrementin is conditionizzle on tha reference count being
different from one or tha reference bein a readonly \s-1SV\s0).
See \f(CW\*(C`SvROK_off\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_unref_flags(SV *const ref, const U32 flags)
.Ve
.IP "sv_untaint" 8
.IX Xref "sv_untaint"
.IX Item "sv_untaint"
Untaint a \s-1SV. \s0 Use \f(CW\*(C`SvTAINTED_off\*(C'\fR instead.
.Sp
.Vb 1
\&        void    sv_untaint(SV *const sv)
.Ve
.IP "sv_upgrade" 8
.IX Xref "sv_upgrade"
.IX Item "sv_upgrade"
Upgrade a \s-1SV\s0 ta a mo' complex form.  Generally addz a freshly smoked up body type ta the
\&\s-1SV,\s0 then copies across as much shiznit as possible from tha oldschool body.
It croaks if tha \s-1SV\s0 be already up in a mo' complex form than requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  You
generally wanna use tha \f(CW\*(C`SvUPGRADE\*(C'\fR macro wrapper, which checks tha type
before callin \f(CW\*(C`sv_upgrade\*(C'\fR, n' hence do not croak.  See also
\&\f(CW\*(C`svtype\*(C'\fR.
.Sp
.Vb 1
\&        void    sv_upgrade(SV *const sv, svtype new_type)
.Ve
.IP "sv_usepvn_flags" 8
.IX Xref "sv_usepvn_flags"
.IX Item "sv_usepvn_flags"
Tells a \s-1SV\s0 ta use \f(CW\*(C`ptr\*(C'\fR ta find its strang value.  Normally the
strin is stored inside tha \s-1SV\s0 but sv_usepvn allows tha \s-1SV\s0 ta use an
outside string.  Da \f(CW\*(C`ptr\*(C'\fR should point ta memory dat was allocated
by \f(CW\*(C`malloc\*(C'\fR.  It must be tha start of a mallocked block
of memory, n' not a pointa ta tha middle of dat shit.  The
strin length, \f(CW\*(C`len\*(C'\fR, must be supplied. Y'all KNOW dat shit, muthafucka!  By default
this function will realloc (i.e. move) tha memory pointed ta by \f(CW\*(C`ptr\*(C'\fR,
so dat pointa should not be freed or used by tha programmer after
givin it ta sv_usepvn, n' neither should any pointas from \*(L"behind\*(R"
that pointa (e.g. ptr + 1) be used.
.Sp
If \f(CW\*(C`flags\*(C'\fR & \s-1SV_SMAGIC\s0 is true, will call SvSETMAGIC.  If \f(CW\*(C`flags\*(C'\fR &
\&\s-1SV_HAS_TRAILING_NUL\s0 is true, then \f(CW\*(C`ptr[len]\*(C'\fR must be \s-1NUL,\s0 n' tha realloc
will be skipped (i.e. tha buffer is straight-up at least 1 byte longer than
\&\f(CW\*(C`len\*(C'\fR, n' already meets tha requirements fo' storin up in \f(CW\*(C`SvPVX\*(C'\fR).
.Sp
.Vb 3
\&        void    sv_usepvn_flags(SV *const sv, char* ptr,
\&                                const STRLEN len,
\&                                const U32 flags)
.Ve
.IP "sv_utf8_decode" 8
.IX Xref "sv_utf8_decode"
.IX Item "sv_utf8_decode"
If tha \s-1PV\s0 of tha \s-1SV\s0 be a octet sequence up in \s-1UTF\-8\s0
and gotz nuff a multiple-byte character, tha \f(CW\*(C`SvUTF8\*(C'\fR flag is turned on
so dat it be lookin like a cold-ass lil character n' shit.  If tha \s-1PV\s0 gotz nuff only single-byte
characters, tha \f(CW\*(C`SvUTF8\*(C'\fR flag stays off.
Scans \s-1PV\s0 fo' validitizzle n' returns false if tha \s-1PV\s0 is invalid \s-1UTF\-8.\s0
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        bool    sv_utf8_decode(SV *const sv)
.Ve
.IP "sv_utf8_downgrade" 8
.IX Xref "sv_utf8_downgrade"
.IX Item "sv_utf8_downgrade"
Attempts ta convert tha \s-1PV\s0 of a \s-1SV\s0 from charactas ta bytes.
If tha \s-1PV\s0 gotz nuff a cold-ass lil characta dat cannot fit
in a funky-ass byte, dis conversion will fail;
in dis case, either returns false or, if \f(CW\*(C`fail_ok\*(C'\fR is not
true, croaks.
.Sp
This aint a general purpose Unicode ta byte encodin intercourse:
use tha Encode extension fo' dis shit.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        bool    sv_utf8_downgrade(SV *const sv,
\&                                  const bool fail_ok)
.Ve
.IP "sv_utf8_encode" 8
.IX Xref "sv_utf8_encode"
.IX Item "sv_utf8_encode"
Converts tha \s-1PV\s0 of a \s-1SV\s0 ta \s-1UTF\-8,\s0 but then turns tha \f(CW\*(C`SvUTF8\*(C'\fR
flag off so dat it be lookin like octets again.
.Sp
.Vb 1
\&        void    sv_utf8_encode(SV *const sv)
.Ve
.IP "sv_utf8_upgrade" 8
.IX Xref "sv_utf8_upgrade"
.IX Item "sv_utf8_upgrade"
Converts tha \s-1PV\s0 of a \s-1SV\s0 ta its UTF\-8\-encoded form.
Forces tha \s-1SV\s0 ta strang form if it aint already.
Will \f(CW\*(C`mg_get\*(C'\fR on \f(CW\*(C`sv\*(C'\fR if appropriate.
Always sets tha SvUTF8 flag ta avoid future validitizzle checks even
if tha whole strang is tha same ol' dirty up in \s-1UTF\-8\s0 as not.
Returns tha number of bytes up in tha converted string
.Sp
This aint a general purpose byte encodin ta Unicode intercourse:
use tha Encode extension fo' dis shit.
.Sp
.Vb 1
\&        STRLEN  sv_utf8_upgrade(SV *sv)
.Ve
.IP "sv_utf8_upgrade_flags" 8
.IX Xref "sv_utf8_upgrade_flags"
.IX Item "sv_utf8_upgrade_flags"
Converts tha \s-1PV\s0 of a \s-1SV\s0 ta its UTF\-8\-encoded form.
Forces tha \s-1SV\s0 ta strang form if it aint already.
Always sets tha SvUTF8 flag ta avoid future validitizzle checks even
if all tha bytes is invariant up in \s-1UTF\-8.\s0
If \f(CW\*(C`flags\*(C'\fR has \f(CW\*(C`SV_GMAGIC\*(C'\fR bit set,
will \f(CW\*(C`mg_get\*(C'\fR on \f(CW\*(C`sv\*(C'\fR if appropriate, else not.
Returns tha number of bytes up in tha converted string
\&\f(CW\*(C`sv_utf8_upgrade\*(C'\fR and
\&\f(CW\*(C`sv_utf8_upgrade_nomg\*(C'\fR is implemented up in termz of dis function.
.Sp
This aint a general purpose byte encodin ta Unicode intercourse:
use tha Encode extension fo' dis shit.
.Sp
.Vb 2
\&        STRLEN  sv_utf8_upgrade_flags(SV *const sv,
\&                                      const I32 flags)
.Ve
.IP "sv_utf8_upgrade_nomg" 8
.IX Xref "sv_utf8_upgrade_nomg"
.IX Item "sv_utf8_upgrade_nomg"
Like sv_utf8_upgrade yo, but don't do magic on \f(CW\*(C`sv\*(C'\fR.
.Sp
.Vb 1
\&        STRLEN  sv_utf8_upgrade_nomg(SV *sv)
.Ve
.IP "sv_vcatpvf" 8
.IX Xref "sv_vcatpvf"
.IX Item "sv_vcatpvf"
Processes its arguments like \f(CW\*(C`vsprintf\*(C'\fR n' appendz tha formatted output
to a \s-1SV. \s0 Do not handle 'set' magic.  See \f(CW\*(C`sv_vcatpvf_mg\*(C'\fR.
.Sp
Usually used via its frontend \f(CW\*(C`sv_catpvf\*(C'\fR.
.Sp
.Vb 2
\&        void    sv_vcatpvf(SV *const sv, const char *const pat,
\&                           va_list *const args)
.Ve
.IP "sv_vcatpvfn" 8
.IX Xref "sv_vcatpvfn"
.IX Item "sv_vcatpvfn"
.Vb 5
\&        void    sv_vcatpvfn(SV *const sv, const char *const pat,
\&                            const STRLEN patlen,
\&                            va_list *const args,
\&                            SV **const svargs, const I32 svmax,
\&                            bool *const maybe_tainted)
.Ve
.IP "sv_vcatpvfn_flags" 8
.IX Xref "sv_vcatpvfn_flags"
.IX Item "sv_vcatpvfn_flags"
Processes its arguments like \f(CW\*(C`vsprintf\*(C'\fR n' appendz tha formatted output
to a \s-1SV. \s0 Uses a array of SVs if tha C steez variable argument list is
missin (\s-1NULL\s0).  When hustlin wit taint checks enabled, indicates via
\&\f(CW\*(C`maybe_tainted\*(C'\fR if thangs up in dis biatch is untrustworthy (often cuz of tha use of
locales).
.Sp
If called as \f(CW\*(C`sv_vcatpvfn\*(C'\fR or flags include \f(CW\*(C`SV_GMAGIC\*(C'\fR, calls git magic.
.Sp
Usually used via one of its frontendz \f(CW\*(C`sv_vcatpvf\*(C'\fR n' \f(CW\*(C`sv_vcatpvf_mg\*(C'\fR.
.Sp
.Vb 8
\&        void    sv_vcatpvfn_flags(SV *const sv,
\&                                  const char *const pat,
\&                                  const STRLEN patlen,
\&                                  va_list *const args,
\&                                  SV **const svargs,
\&                                  const I32 svmax,
\&                                  bool *const maybe_tainted,
\&                                  const U32 flags)
.Ve
.IP "sv_vcatpvf_mg" 8
.IX Xref "sv_vcatpvf_mg"
.IX Item "sv_vcatpvf_mg"
Like \f(CW\*(C`sv_vcatpvf\*(C'\fR yo, but also handlez 'set' magic.
.Sp
Usually used via its frontend \f(CW\*(C`sv_catpvf_mg\*(C'\fR.
.Sp
.Vb 3
\&        void    sv_vcatpvf_mg(SV *const sv,
\&                              const char *const pat,
\&                              va_list *const args)
.Ve
.IP "sv_vsetpvf" 8
.IX Xref "sv_vsetpvf"
.IX Item "sv_vsetpvf"
Works like \f(CW\*(C`sv_vcatpvf\*(C'\fR but copies tha text tha fuck into tha \s-1SV\s0 instead of
appendin dat shit.  Do not handle 'set' magic.  See \f(CW\*(C`sv_vsetpvf_mg\*(C'\fR.
.Sp
Usually used via its frontend \f(CW\*(C`sv_setpvf\*(C'\fR.
.Sp
.Vb 2
\&        void    sv_vsetpvf(SV *const sv, const char *const pat,
\&                           va_list *const args)
.Ve
.IP "sv_vsetpvfn" 8
.IX Xref "sv_vsetpvfn"
.IX Item "sv_vsetpvfn"
Works like \f(CW\*(C`sv_vcatpvfn\*(C'\fR but copies tha text tha fuck into tha \s-1SV\s0 instead of
appendin dat shit.
.Sp
Usually used via one of its frontendz \f(CW\*(C`sv_vsetpvf\*(C'\fR n' \f(CW\*(C`sv_vsetpvf_mg\*(C'\fR.
.Sp
.Vb 5
\&        void    sv_vsetpvfn(SV *const sv, const char *const pat,
\&                            const STRLEN patlen,
\&                            va_list *const args,
\&                            SV **const svargs, const I32 svmax,
\&                            bool *const maybe_tainted)
.Ve
.IP "sv_vsetpvf_mg" 8
.IX Xref "sv_vsetpvf_mg"
.IX Item "sv_vsetpvf_mg"
Like \f(CW\*(C`sv_vsetpvf\*(C'\fR yo, but also handlez 'set' magic.
.Sp
Usually used via its frontend \f(CW\*(C`sv_setpvf_mg\*(C'\fR.
.Sp
.Vb 3
\&        void    sv_vsetpvf_mg(SV *const sv,
\&                              const char *const pat,
\&                              va_list *const args)
.Ve
.SH "Unicode Support"
.IX Header "Unicode Support"
.IP "bytes_cmp_utf8" 8
.IX Xref "bytes_cmp_utf8"
.IX Item "bytes_cmp_utf8"
Compares tha sequence of charactas (stored as octets) up in \f(CW\*(C`b\*(C'\fR, \f(CW\*(C`blen\*(C'\fR wit the
sequence of charactas (stored as \s-1UTF\-8\s0) up in \f(CW\*(C`u\*(C'\fR, \f(CW\*(C`ulen\*(C'\fR. Returns 0 if they are
equal, \-1 or \-2 if tha straight-up original gangsta strang is less than tha second string, +1 or +2
if tha straight-up original gangsta strang is pimped outa than tha second string.
.Sp
\&\-1 or +1 is returned if tha shorta strang was identical ta tha start of the
longer string. \-2 or +2 is returned if tha was a gangbangin' finger-lickin' difference between characters
within tha strings.
.Sp
.Vb 2
\&        int     bytes_cmp_utf8(const U8 *b, STRLEN blen,
\&                               const U8 *u, STRLEN ulen)
.Ve
.IP "bytes_from_utf8" 8
.IX Xref "bytes_from_utf8"
.IX Item "bytes_from_utf8"
Converts a strang \f(CW\*(C`s\*(C'\fR of length \f(CW\*(C`len\*(C'\fR from \s-1UTF\-8\s0 tha fuck into natizzle byte encoding.
Unlike \*(L"utf8_to_bytes\*(R" but like \*(L"bytes_to_utf8\*(R", returns a pointa to
the newly-created string, n' thugged-out shiznit \f(CW\*(C`len\*(C'\fR ta contain tha new
length.  Returns tha original gangsta strang if no conversion occurs, \f(CW\*(C`len\*(C'\fR
is unchanged. Y'all KNOW dat shit, muthafucka! Do not a god damn thang if \f(CW\*(C`is_utf8\*(C'\fR points ta 0. Right back up in yo muthafuckin ass. Sets \f(CW\*(C`is_utf8\*(C'\fR to
0 if \f(CW\*(C`s\*(C'\fR is converted or consisted entirely of charactas dat is invariant
in utf8 (i.e., US-ASCII on non-EBCDIC machines).
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 2
\&        U8*     bytes_from_utf8(const U8 *s, STRLEN *len,
\&                                bool *is_utf8)
.Ve
.IP "bytes_to_utf8" 8
.IX Xref "bytes_to_utf8"
.IX Item "bytes_to_utf8"
Converts a strang \f(CW\*(C`s\*(C'\fR of length \f(CW\*(C`len\*(C'\fR bytes from tha natizzle encodin into
\&\s-1UTF\-8.\s0
Returns a pointa ta tha newly-created string, n' sets \f(CW\*(C`len\*(C'\fR to
reflect tha freshly smoked up length up in bytes.
.Sp
A \s-1NUL\s0 characta is ghon be freestyled afta tha end of tha string.
.Sp
If you wanna convert ta \s-1UTF\-8\s0 from encodings other than
the natizzle (Latin1 or \s-1EBCDIC\s0),
see \*(L"sv_recode_to_utf8\*(R"().
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        U8*     bytes_to_utf8(const U8 *s, STRLEN *len)
.Ve
.IP "foldEQ_utf8" 8
.IX Xref "foldEQ_utf8"
.IX Item "foldEQ_utf8"
Returns legit if tha leadin portionz of tha strings \f(CW\*(C`s1\*(C'\fR n' \f(CW\*(C`s2\*(C'\fR (either or both
of which may be up in \s-1UTF\-8\s0) is tha same case-insensitively; false otherwise.
How tha fuck far tha fuck into tha strings ta compare is determined by other input parameters.
.Sp
If \f(CW\*(C`u1\*(C'\fR is true, tha strang \f(CW\*(C`s1\*(C'\fR be assumed ta be up in UTF\-8\-encoded Unicode;
otherwise it be assumed ta be up in natizzle 8\-bit encoding.  Correspondingly fo' \f(CW\*(C`u2\*(C'\fR
with respect ta \f(CW\*(C`s2\*(C'\fR.
.Sp
If tha byte length \f(CW\*(C`l1\*(C'\fR is non-zero, it say how tha fuck far tha fuck into \f(CW\*(C`s1\*(C'\fR ta check fo' fold
equality.  In other lyrics, \f(CW\*(C`s1\*(C'\fR+\f(CW\*(C`l1\*(C'\fR is ghon be used as a goal ta reach.  The
scan aint gonna be considered ta be a match unless tha goal is reached, and
scannin won't continue past dat goal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Correspondingly fo' \f(CW\*(C`l2\*(C'\fR wit respect to
\&\f(CW\*(C`s2\*(C'\fR.
.Sp
If \f(CW\*(C`pe1\*(C'\fR is non-NULL n' tha pointa it points ta aint \s-1NULL,\s0 dat pointa is
considered a end pointa ta tha posizzle 1 byte past tha maximum point
in \f(CW\*(C`s1\*(C'\fR beyond which scannin aint gonna continue under any circumstances.
(This routine assumes dat \s-1UTF\-8\s0 encoded input strings is not malformed;
malformed input can cause it ta read past \f(CW\*(C`pe1\*(C'\fR).
This means dat if both \f(CW\*(C`l1\*(C'\fR n' \f(CW\*(C`pe1\*(C'\fR is specified, n' \f(CW\*(C`pe1\*(C'\fR
is less than \f(CW\*(C`s1\*(C'\fR+\f(CW\*(C`l1\*(C'\fR, tha match aint NEVER gonna be successful cuz it can
never
get as far as its goal (and up in fact be asserted against).  Correspondingly for
\&\f(CW\*(C`pe2\*(C'\fR wit respect ta \f(CW\*(C`s2\*(C'\fR.
.Sp
At least one of \f(CW\*(C`s1\*(C'\fR n' \f(CW\*(C`s2\*(C'\fR must gotz a goal (at least one of \f(CW\*(C`l1\*(C'\fR and
\&\f(CW\*(C`l2\*(C'\fR must be non-zero), n' if both do, both gotta be
reached fo' a successful match.   Also, if tha fold of a cold-ass lil characta is multiple
characters, all of dem must be matched (see tr21 reference below for
\&'folding').
.Sp
Upon a successful match, if \f(CW\*(C`pe1\*(C'\fR is non-NULL,
it is ghon be set ta point ta tha beginnin of tha \fInext\fR characta of \f(CW\*(C`s1\*(C'\fR
beyond what tha fuck was matched. Y'all KNOW dat shit, muthafucka!  Correspondingly fo' \f(CW\*(C`pe2\*(C'\fR n' \f(CW\*(C`s2\*(C'\fR.
.Sp
For case-insensitiveness, tha \*(L"casefolding\*(R" of Unicode is used
instead of upper/lowercasin both tha characters, see
<http://www.unicode.org/unicode/reports/tr21/> (Case Mappings).
.Sp
.Vb 3
\&        I32     foldEQ_utf8(const char *s1, char **pe1, UV l1,
\&                            bool u1, const char *s2, char **pe2,
\&                            UV l2, bool u2)
.Ve
.IP "is_ascii_string" 8
.IX Xref "is_ascii_string"
.IX Item "is_ascii_string"
Returns legit if tha straight-up original gangsta \f(CW\*(C`len\*(C'\fR bytez of tha strang \f(CW\*(C`s\*(C'\fR is tha same whether
or not tha strang is encoded up in \s-1UTF\-8 \s0(or UTF-EBCDIC on \s-1EBCDIC\s0 machines).  That
is, if they is invariant.  On ASCII-ish machines, only \s-1ASCII\s0 characters
fit dis definition, hence tha functionz name.
.Sp
If \f(CW\*(C`len\*(C'\fR is 0, it is ghon be calculated rockin \f(CWstrlen(s)\fR.
.Sp
See also \*(L"is_utf8_string\*(R"(), \*(L"is_utf8_string_loclen\*(R"(), n' \*(L"is_utf8_string_loc\*(R"().
.Sp
.Vb 1
\&        bool    is_ascii_string(const U8 *s, STRLEN len)
.Ve
.IP "is_utf8_char" 8
.IX Xref "is_utf8_char"
.IX Item "is_utf8_char"
\&\s-1DEPRECATED\s0!
.Sp
Tests if some arbitrary number of bytes begins up in a valid \s-1UTF\-8\s0
character n' shit.  Note dat a \s-1INVARIANT \s0(i.e. \s-1ASCII\s0 on non-EBCDIC machines)
characta be a valid \s-1UTF\-8\s0 character n' shit.  Da actual number of bytes up in tha \s-1UTF\-8\s0
characta is ghon be returned if it is valid, otherwise 0.
.Sp
This function is deprecated cuz of tha possibilitizzle dat malformed input could
cause readin beyond tha end of tha input buffer n' shit.  Use \*(L"is_utf8_char_buf\*(R"
instead.
.Sp
.Vb 1
\&        STRLEN  is_utf8_char(const U8 *s)
.Ve
.IP "is_utf8_char_buf" 8
.IX Xref "is_utf8_char_buf"
.IX Item "is_utf8_char_buf"
Returns tha number of bytes dat comprise tha straight-up original gangsta \s-1UTF\-8\s0 encoded characta in
buffer \f(CW\*(C`buf\*(C'\fR.  \f(CW\*(C`buf_end\*(C'\fR should point ta one posizzle beyond tha end of the
buffer n' shit.  0 is returned if \f(CW\*(C`buf\*(C'\fR do not point ta a cold-ass lil complete, valid \s-1UTF\-8\s0
encoded character.
.Sp
Note dat a \s-1INVARIANT\s0 characta (i.e. \s-1ASCII\s0 on non-EBCDIC
machines) be a valid \s-1UTF\-8\s0 character.
.Sp
.Vb 2
\&        STRLEN  is_utf8_char_buf(const U8 *buf,
\&                                 const U8 *buf_end)
.Ve
.IP "is_utf8_string" 8
.IX Xref "is_utf8_string"
.IX Item "is_utf8_string"
Returns legit if tha straight-up original gangsta \f(CW\*(C`len\*(C'\fR bytez of strang \f(CW\*(C`s\*(C'\fR form a valid
\&\s-1UTF\-8\s0 string, false otherwise.  If \f(CW\*(C`len\*(C'\fR is 0, it is ghon be calculated
usin \f(CWstrlen(s)\fR (which means if you use dis option, dat \f(CW\*(C`s\*(C'\fR has ta have a
terminatin \s-1NUL\s0 byte).  Note dat all charactas bein \s-1ASCII\s0 constitute 'a
valid \s-1UTF\-8\s0 string'.
.Sp
See also \*(L"is_ascii_string\*(R"(), \*(L"is_utf8_string_loclen\*(R"(), n' \*(L"is_utf8_string_loc\*(R"().
.Sp
.Vb 1
\&        bool    is_utf8_string(const U8 *s, STRLEN len)
.Ve
.IP "is_utf8_string_loc" 8
.IX Xref "is_utf8_string_loc"
.IX Item "is_utf8_string_loc"
Like \*(L"is_utf8_string\*(R" but stores tha location of tha failure (in the
case of \*(L"utf8nizz failure\*(R") or tha location \f(CW\*(C`s\*(C'\fR+\f(CW\*(C`len\*(C'\fR (in tha case of
\&\*(L"utf8nizz success\*(R") up in tha \f(CW\*(C`ep\*(C'\fR.
.Sp
See also \*(L"is_utf8_string_loclen\*(R"() n' \*(L"is_utf8_string\*(R"().
.Sp
.Vb 2
\&        bool    is_utf8_string_loc(const U8 *s, STRLEN len,
\&                                   const U8 **ep)
.Ve
.IP "is_utf8_string_loclen" 8
.IX Xref "is_utf8_string_loclen"
.IX Item "is_utf8_string_loclen"
Like \*(L"is_utf8_string\*(R"() but stores tha location of tha failure (in the
case of \*(L"utf8nizz failure\*(R") or tha location \f(CW\*(C`s\*(C'\fR+\f(CW\*(C`len\*(C'\fR (in tha case of
\&\*(L"utf8nizz success\*(R") up in tha \f(CW\*(C`ep\*(C'\fR, n' tha number of \s-1UTF\-8\s0
encoded charactas up in tha \f(CW\*(C`el\*(C'\fR.
.Sp
See also \*(L"is_utf8_string_loc\*(R"() n' \*(L"is_utf8_string\*(R"().
.Sp
.Vb 2
\&        bool    is_utf8_string_loclen(const U8 *s, STRLEN len,
\&                                      const U8 **ep, STRLEN *el)
.Ve
.IP "pv_uni_display" 8
.IX Xref "pv_uni_display"
.IX Item "pv_uni_display"
Build ta tha scalar \f(CW\*(C`dsv\*(C'\fR a gangbangin' finger-lickin' displayable version of tha strang \f(CW\*(C`spv\*(C'\fR,
length \f(CW\*(C`len\*(C'\fR, tha displayable version bein at most \f(CW\*(C`pvlim\*(C'\fR bytes long
(if longer, tha rest is truncated n' \*(L"...\*(R" is ghon be appended).
.Sp
Da \f(CW\*(C`flags\*(C'\fR argument can have \s-1UNI_DISPLAY_ISPRINT\s0 set ta display
\&\fIisPRINT()\fRable charactas as theyselves, \s-1UNI_DISPLAY_BACKSLASH\s0
to display tha \e\e[nrfta\e\e] as tha backslashed versions (like '\en')
(\s-1UNI_DISPLAY_BACKSLASH\s0 is preferred over \s-1UNI_DISPLAY_ISPRINT\s0 fo' \e\e).
\&\s-1UNI_DISPLAY_QQ \s0(and its alias \s-1UNI_DISPLAY_REGEX\s0) have both
\&\s-1UNI_DISPLAY_BACKSLASH\s0 n' \s-1UNI_DISPLAY_ISPRINT\s0 turned on.
.Sp
Da pointa ta tha \s-1PV\s0 of tha \f(CW\*(C`dsv\*(C'\fR is returned.
.Sp
.Vb 3
\&        char*   pv_uni_display(SV *dsv, const U8 *spv,
\&                               STRLEN len, STRLEN pvlim,
\&                               UV flags)
.Ve
.IP "sv_cat_decode" 8
.IX Xref "sv_cat_decode"
.IX Item "sv_cat_decode"
Da encodin be assumed ta be a Encode object, tha \s-1PV\s0 of tha ssv is
assumed ta be octets up in dat encodin n' decodin tha input starts
from tha posizzle which (\s-1PV +\s0 *offset) pointed to.  Da dsv will be
concatenated tha decoded \s-1UTF\-8\s0 strang from ssv.  Decodin will terminate
when tha strang tstr appears up in decodin output or tha input endz on
the \s-1PV\s0 of tha ssv.  Da value which tha offset points is ghon be modified
to tha last input posizzle on tha ssv.
.Sp
Returns \s-1TRUE\s0 if tha terminator was found, else returns \s-1FALSE.\s0
.Sp
.Vb 2
\&        bool    sv_cat_decode(SV* dsv, SV *encoding, SV *ssv,
\&                              int *offset, char* tstr, int tlen)
.Ve
.IP "sv_recode_to_utf8" 8
.IX Xref "sv_recode_to_utf8"
.IX Item "sv_recode_to_utf8"
Da encodin be assumed ta be a Encode object, on entry tha \s-1PV\s0
of tha sv be assumed ta be octets up in dat encoding, n' tha sv
will be converted tha fuck into Unicode (and \s-1UTF\-8\s0).
.Sp
If tha sv already is \s-1UTF\-8 \s0(or if it aint \s-1POK\s0), or if tha encoding
is not a reference, not a god damn thang is done ta tha sv.  If tha encodin is not
an \f(CW\*(C`Encode::XS\*(C'\fR Encodin object, wack thangs will happen.
(See \fIlib/encoding.pm\fR n' Encode.)
.Sp
Da \s-1PV\s0 of tha sv is returned.
.Sp
.Vb 1
\&        char*   sv_recode_to_utf8(SV* sv, SV *encoding)
.Ve
.IP "sv_uni_display" 8
.IX Xref "sv_uni_display"
.IX Item "sv_uni_display"
Build ta tha scalar \f(CW\*(C`dsv\*(C'\fR a gangbangin' finger-lickin' displayable version of tha scalar \f(CW\*(C`sv\*(C'\fR,
the displayable version bein at most \f(CW\*(C`pvlim\*(C'\fR bytes long
(if longer, tha rest is truncated n' \*(L"...\*(R" is ghon be appended).
.Sp
Da \f(CW\*(C`flags\*(C'\fR argument be as up in \*(L"pv_uni_display\*(R"().
.Sp
Da pointa ta tha \s-1PV\s0 of tha \f(CW\*(C`dsv\*(C'\fR is returned.
.Sp
.Vb 2
\&        char*   sv_uni_display(SV *dsv, SV *ssv, STRLEN pvlim,
\&                               UV flags)
.Ve
.IP "to_utf8_case" 8
.IX Xref "to_utf8_case"
.IX Item "to_utf8_case"
Da \f(CW\*(C`p\*(C'\fR gotz nuff tha pointa ta tha \s-1UTF\-8\s0 strang encoding
the characta dat is bein converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This routine assumes dat tha character
at \f(CW\*(C`p\*(C'\fR is well-formed.
.Sp
Da \f(CW\*(C`ustrp\*(C'\fR be a pointa ta tha characta buffer ta put the
conversion result to.  Da \f(CW\*(C`lenp\*(C'\fR be a pointa ta tha length
of tha result.
.Sp
Da \f(CW\*(C`swashp\*(C'\fR be a pointa ta tha swash ta use.
.Sp
Both tha special n' aiiight mappings is stored up in \fIlib/unicore/To/Foo.pl\fR,
and loaded by \s-1SWASHNEW,\s0 rockin \fIlib/utf8_heavy.pl\fR.  Da \f(CW\*(C`special\*(C'\fR (usually,
but not always, a multicharacta mapping), is tried first.
.Sp
Da \f(CW\*(C`special\*(C'\fR be a strang like \*(L"utf8::ToSpecLower\*(R", which means the
hash \f(CW%utf8::ToSpecLower\fR.  Da access ta tha hash is through
\&\fIPerl_to_utf8_case()\fR.
.Sp
Da \f(CW\*(C`normal\*(C'\fR be a strang like \*(L"ToLower\*(R" which means tha swash
\&\f(CW%utf8::ToLower\fR.
.Sp
.Vb 4
\&        UV      to_utf8_case(const U8 *p, U8* ustrp,
\&                             STRLEN *lenp, SV **swashp,
\&                             const char *normal,
\&                             const char *special)
.Ve
.IP "to_utf8_fold" 8
.IX Xref "to_utf8_fold"
.IX Item "to_utf8_fold"
Convert tha \s-1UTF\-8\s0 encoded characta at \f(CW\*(C`p\*(C'\fR ta its foldcase version and
store dat up in \s-1UTF\-8\s0 up in \f(CW\*(C`ustrp\*(C'\fR n' its length up in bytes up in \f(CW\*(C`lenp\*(C'\fR.  Note
that tha \f(CW\*(C`ustrp\*(C'\fR need ta be at least \s-1UTF8_MAXBYTES_CASE+1\s0 bytes since the
foldcase version may be longer than tha original gangsta characta (up to
three characters).
.Sp
Da first characta of tha foldcased version is returned
(but note, as explained above, dat there may be more.)
.Sp
Da characta at \f(CW\*(C`p\*(C'\fR be assumed by dis routine ta be well-formed.
.Sp
.Vb 2
\&        UV      to_utf8_fold(const U8 *p, U8* ustrp,
\&                             STRLEN *lenp)
.Ve
.IP "to_utf8_lower" 8
.IX Xref "to_utf8_lower"
.IX Item "to_utf8_lower"
Convert tha \s-1UTF\-8\s0 encoded characta at \f(CW\*(C`p\*(C'\fR ta its lowercase version and
store dat up in \s-1UTF\-8\s0 up in ustrp n' its length up in bytes up in \f(CW\*(C`lenp\*(C'\fR.  Note
that tha \f(CW\*(C`ustrp\*(C'\fR need ta be at least \s-1UTF8_MAXBYTES_CASE+1\s0 bytes since the
lowercase version may be longer than tha original gangsta character.
.Sp
Da first characta of tha lowercased version is returned
(but note, as explained above, dat there may be more.)
.Sp
Da characta at \f(CW\*(C`p\*(C'\fR be assumed by dis routine ta be well-formed.
.Sp
.Vb 2
\&        UV      to_utf8_lower(const U8 *p, U8* ustrp,
\&                              STRLEN *lenp)
.Ve
.IP "to_utf8_title" 8
.IX Xref "to_utf8_title"
.IX Item "to_utf8_title"
Convert tha \s-1UTF\-8\s0 encoded characta at \f(CW\*(C`p\*(C'\fR ta its titlecase version and
store dat up in \s-1UTF\-8\s0 up in \f(CW\*(C`ustrp\*(C'\fR n' its length up in bytes up in \f(CW\*(C`lenp\*(C'\fR.  Note
that tha \f(CW\*(C`ustrp\*(C'\fR need ta be at least \s-1UTF8_MAXBYTES_CASE+1\s0 bytes since the
titlecase version may be longer than tha original gangsta character.
.Sp
Da first characta of tha titlecased version is returned
(but note, as explained above, dat there may be more.)
.Sp
Da characta at \f(CW\*(C`p\*(C'\fR be assumed by dis routine ta be well-formed.
.Sp
.Vb 2
\&        UV      to_utf8_title(const U8 *p, U8* ustrp,
\&                              STRLEN *lenp)
.Ve
.IP "to_utf8_upper" 8
.IX Xref "to_utf8_upper"
.IX Item "to_utf8_upper"
Convert tha \s-1UTF\-8\s0 encoded characta at \f(CW\*(C`p\*(C'\fR ta its uppercase version and
store dat up in \s-1UTF\-8\s0 up in \f(CW\*(C`ustrp\*(C'\fR n' its length up in bytes up in \f(CW\*(C`lenp\*(C'\fR.  Note
that tha ustrp need ta be at least \s-1UTF8_MAXBYTES_CASE+1\s0 bytes since
the uppercase version may be longer than tha original gangsta character.
.Sp
Da first characta of tha uppercased version is returned
(but note, as explained above, dat there may be more.)
.Sp
Da characta at \f(CW\*(C`p\*(C'\fR be assumed by dis routine ta be well-formed.
.Sp
.Vb 2
\&        UV      to_utf8_upper(const U8 *p, U8* ustrp,
\&                              STRLEN *lenp)
.Ve
.IP "utf8n_to_uvchr" 8
.IX Xref "utf8n_to_uvchr"
.IX Item "utf8n_to_uvchr"
Returns tha natizzle characta value of tha straight-up original gangsta characta up in tha string
\&\f(CW\*(C`s\*(C'\fR
which be assumed ta be up in \s-1UTF\-8\s0 encoding; \f(CW\*(C`retlen\*(C'\fR is ghon be set ta the
length, up in bytes, of dat character.
.Sp
\&\f(CW\*(C`length\*(C'\fR n' \f(CW\*(C`flags\*(C'\fR is tha same as \*(L"utf8n_to_uvuni\*(R"().
.Sp
.Vb 2
\&        UV      utf8n_to_uvchr(const U8 *s, STRLEN curlen,
\&                               STRLEN *retlen, U32 flags)
.Ve
.IP "utf8n_to_uvuni" 8
.IX Xref "utf8n_to_uvuni"
.IX Item "utf8n_to_uvuni"
Bottom level \s-1UTF\-8\s0 decode routine.
Returns tha code point value of tha straight-up original gangsta characta up in tha strang \f(CW\*(C`s\*(C'\fR,
which be assumed ta be up in \s-1UTF\-8 \s0(or UTF-EBCDIC) encoding, n' no longer than
\&\f(CW\*(C`curlen\*(C'\fR bytes; \f(CW*retlen\fR (if \f(CW\*(C`retlen\*(C'\fR aint \s-1NULL\s0) is ghon be set to
the length, up in bytes, of dat character.
.Sp
Da value of \f(CW\*(C`flags\*(C'\fR determines tha behavior when \f(CW\*(C`s\*(C'\fR do not point ta a
well-formed \s-1UTF\-8\s0 character n' shit.  If \f(CW\*(C`flags\*(C'\fR is 0, when a malformation is found,
zero is returned n' \f(CW*retlen\fR is set so dat (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is the
next possible posizzle up in \f(CW\*(C`s\*(C'\fR dat could begin a non-malformed character.
Also, if \s-1UTF\-8\s0 warnings aint been lexically disabled, a warnin is raised.
.Sp
Various \s-1ALLOW\s0 flags can be set up in \f(CW\*(C`flags\*(C'\fR ta allow (and not warn on)
individual typez of malformations, like fuckin tha sequence bein overlong (that
is, when there be a gangbangin' finger-lickin' dirty-ass shorta sequence dat can express tha same ol' dirty code point;
overlong sequences is expressly forbidden up in tha \s-1UTF\-8\s0 standard due to
potential securitizzle issues).  Another malformation example is tha straight-up original gangsta byte of
a characta not bein a legal first byte.  See \fIutf8.h\fR fo' tha list of such
flags.  For allowed 0 length strings, dis function returns 0; fo' allowed
overlong sequences, tha computed code point is returned; fo' all other allowed
malformations, tha Unicode \s-1REPLACEMENT CHARACTER\s0 is returned, as these have no
determinable reasonable value.
.Sp
Da \s-1UTF8_CHECK_ONLY\s0 flag overrides tha behavior when a non-allowed (by other
flags) malformation is found. Y'all KNOW dat shit, muthafucka!  If dis flag is set, tha routine assumes that
the calla will raise a warning, n' dis function will silently just set
\&\f(CW\*(C`retlen\*(C'\fR ta \f(CW\*(C`\-1\*(C'\fR (cast ta \f(CW\*(C`STRLEN\*(C'\fR) n' return zero.
.Sp
Note dat dis \s-1API\s0 requires disambiguation between successful decodin a \s-1NUL\s0
character, n' a error return (unless tha \s-1UTF8_CHECK_ONLY\s0 flag is set), as
in both cases, 0 is returned. Y'all KNOW dat shit, muthafucka!  To disambiguate, upon a zero return, peep if the
first byte of \f(CW\*(C`s\*(C'\fR is 0 as well.  If so, tha input was a \s-1NUL\s0; if not, tha input
had a error.
.Sp
Certain code points is considered problematic.  These is Unicode surrogates,
Unicode non-characters, n' code points above tha Unicode maximum of 0x10FFFF.
By default these is considered regular code points yo, but certain thangs
warrant special handlin fo' em.  If \f(CW\*(C`flags\*(C'\fR gotz nuff
\&\s-1UTF8_DISALLOW_ILLEGAL_INTERCHANGE,\s0 all three classes is treated as
malformations n' handled as such.  Da flags \s-1UTF8_DISALLOW_SURROGATE,
UTF8_DISALLOW_NONCHAR,\s0 n' \s-1UTF8_DISALLOW_SUPER \s0(meanin above tha legal Unicode
maximum) can be set ta disallow these categories individually.
.Sp
Da flags \s-1UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE,
UTF8_WARN_NONCHAR,\s0 n' \s-1UTF8_WARN_SUPER\s0 will cause warnin lyrics ta be raised
for they respectizzle categories yo, but otherwise tha code points is considered
valid (not malformations).  To git a cold-ass lil category ta both be treated as a
malformation n' raise a warning, specify both tha \s-1WARN\s0 n' \s-1DISALLOW\s0 flags.
(But note dat warnings is not raised if lexically disabled nor if
\&\s-1UTF8_CHECK_ONLY\s0 be also specified.)
.Sp
Straight-up big-ass code points (above 0x7FFF_FFFF) is considered mo' problematic than
the others dat is above tha Unicode legal maximum.  There is several
reasons: they requre at least 32 bits ta represent dem on \s-1ASCII\s0 platforms, are
not representable at all on \s-1EBCDIC\s0 platforms, n' tha original gangsta \s-1UTF\-8\s0
specification never went above dis number (the current 0x10FFFF limit was
imposed later).  (Da smalla ones, dem dat fit tha fuck into 32 bits, are
representable by a \s-1UV\s0 on \s-1ASCII\s0 platforms yo, but not by a \s-1IV,\s0 which means that
the number of operations dat can be performed on dem is like restricted.)
Da \s-1UTF\-8\s0 encodin on \s-1ASCII\s0 platforms fo' these big-ass code points begins wit a
byte containin 0xFE or 0xFF.  Da \s-1UTF8_DISALLOW_FE_FF\s0 flag will cause dem to
be treated as malformations, while allowin smalla above-Unicode code points.
(Of course \s-1UTF8_DISALLOW_SUPER\s0 will treat all above-Unicode code points,
includin these, as malformations.) Similarly, \s-1UTF8_WARN_FE_FF\s0 acts just like
the other \s-1WARN\s0 flags yo, but applies just ta these code points.
.Sp
All other code points correspondin ta Unicode characters, includin private
use n' dem yet ta be assigned, is never considered malformed n' never
warn.
.Sp
Most code should use \*(L"utf8_to_uvchr_buf\*(R"() rather than call dis directly.
.Sp
.Vb 2
\&        UV      utf8n_to_uvuni(const U8 *s, STRLEN curlen,
\&                               STRLEN *retlen, U32 flags)
.Ve
.IP "utf8_distance" 8
.IX Xref "utf8_distance"
.IX Item "utf8_distance"
Returns tha number of \s-1UTF\-8\s0 charactas between tha \s-1UTF\-8\s0 pointas \f(CW\*(C`a\*(C'\fR
and \f(CW\*(C`b\*(C'\fR.
.Sp
\&\s-1WARNING:\s0 use only if you *know* dat tha pointas point inside the
same \s-1UTF\-8\s0 buffer.
.Sp
.Vb 1
\&        IV      utf8_distance(const U8 *a, const U8 *b)
.Ve
.IP "utf8_hop" 8
.IX Xref "utf8_hop"
.IX Item "utf8_hop"
Return tha \s-1UTF\-8\s0 pointa \f(CW\*(C`s\*(C'\fR displaced by \f(CW\*(C`off\*(C'\fR characters, either
forward or backward.
.Sp
\&\s-1WARNING:\s0 do not use tha followin unless you *know* \f(CW\*(C`off\*(C'\fR is within
the \s-1UTF\-8\s0 data pointed ta by \f(CW\*(C`s\*(C'\fR *and* dat on entry \f(CW\*(C`s\*(C'\fR be aligned
on tha straight-up original gangsta byte of characta or just afta tha last byte of a cold-ass lil character.
.Sp
.Vb 1
\&        U8*     utf8_hop(const U8 *s, I32 off)
.Ve
.IP "utf8_length" 8
.IX Xref "utf8_length"
.IX Item "utf8_length"
Return tha length of tha \s-1UTF\-8\s0 char encoded strang \f(CW\*(C`s\*(C'\fR up in characters.
Stops at \f(CW\*(C`e\*(C'\fR (inclusive).  If \f(CW\*(C`e < s\*(C'\fR or if tha scan would end
up past \f(CW\*(C`e\*(C'\fR, croaks.
.Sp
.Vb 1
\&        STRLEN  utf8_length(const U8* s, const U8 *e)
.Ve
.IP "utf8_to_bytes" 8
.IX Xref "utf8_to_bytes"
.IX Item "utf8_to_bytes"
Converts a strang \f(CW\*(C`s\*(C'\fR of length \f(CW\*(C`len\*(C'\fR from \s-1UTF\-8\s0 tha fuck into natizzle byte encoding.
Unlike \*(L"bytes_to_utf8\*(R", dis over-writes tha original gangsta string, and
updates \f(CW\*(C`len\*(C'\fR ta contain tha freshly smoked up length.
Returns zero on failure, settin \f(CW\*(C`len\*(C'\fR ta \-1.
.Sp
If you need a cold-ass lil copy of tha string, peep \*(L"bytes_from_utf8\*(R".
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        U8*     utf8_to_bytes(U8 *s, STRLEN *len)
.Ve
.IP "utf8_to_uvchr" 8
.IX Xref "utf8_to_uvchr"
.IX Item "utf8_to_uvchr"
\&\s-1DEPRECATED\s0!
.Sp
Returns tha natizzle code point of tha straight-up original gangsta characta up in tha strang \f(CW\*(C`s\*(C'\fR
which be assumed ta be up in \s-1UTF\-8\s0 encoding; \f(CW\*(C`retlen\*(C'\fR is ghon be set ta the
length, up in bytes, of dat character.
.Sp
Some yo, but not all, \s-1UTF\-8\s0 malformations is detected, n' up in fact, some
malformed input could cause readin beyond tha end of tha input buffer, which
is why dis function is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \*(L"utf8_to_uvchr_buf\*(R" instead.
.Sp
If \f(CW\*(C`s\*(C'\fR points ta one of tha detected malformations, n' \s-1UTF8\s0 warnings are
enabled, zero is returned n' \f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR aint
\&\s-1NULL\s0) ta \-1.  If dem warnings is off, tha computed value if well-defined (or
the Unicode \s-1REPLACEMENT CHARACTER,\s0 if not) is silently returned, n' \f(CW*retlen\fR
is set (if \f(CW\*(C`retlen\*(C'\fR aint \s-1NULL\s0) so dat (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is the
next possible posizzle up in \f(CW\*(C`s\*(C'\fR dat could begin a non-malformed character.
See \*(L"utf8n_to_uvuni\*(R" fo' details on when tha \s-1REPLACEMENT CHARACTER\s0 is returned.
.Sp
.Vb 1
\&        UV      utf8_to_uvchr(const U8 *s, STRLEN *retlen)
.Ve
.IP "utf8_to_uvchr_buf" 8
.IX Xref "utf8_to_uvchr_buf"
.IX Item "utf8_to_uvchr_buf"
Returns tha natizzle code point of tha straight-up original gangsta characta up in tha strang \f(CW\*(C`s\*(C'\fR which
is assumed ta be up in \s-1UTF\-8\s0 encoding; \f(CW\*(C`send\*(C'\fR points ta 1 beyond tha end of \f(CW\*(C`s\*(C'\fR.
\&\f(CW*retlen\fR is ghon be set ta tha length, up in bytes, of dat character.
.Sp
If \f(CW\*(C`s\*(C'\fR do not point ta a well-formed \s-1UTF\-8\s0 characta n' \s-1UTF8\s0 warnings are
enabled, zero is returned n' \f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR aint
\&\s-1NULL\s0) ta \-1.  If dem warnings is off, tha computed value, if well-defined
(or tha Unicode \s-1REPLACEMENT CHARACTER\s0 if not), is silently returned, and
\&\f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR aint \s-1NULL\s0) so dat (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is
the next possible posizzle up in \f(CW\*(C`s\*(C'\fR dat could begin a non-malformed character.
See \*(L"utf8n_to_uvuni\*(R" fo' details on when tha \s-1REPLACEMENT CHARACTER\s0 is
returned.
.Sp
.Vb 2
\&        UV      utf8_to_uvchr_buf(const U8 *s, const U8 *send,
\&                                  STRLEN *retlen)
.Ve
.IP "utf8_to_uvuni" 8
.IX Xref "utf8_to_uvuni"
.IX Item "utf8_to_uvuni"
\&\s-1DEPRECATED\s0!
.Sp
Returns tha Unicode code point of tha straight-up original gangsta characta up in tha strang \f(CW\*(C`s\*(C'\fR
which be assumed ta be up in \s-1UTF\-8\s0 encoding; \f(CW\*(C`retlen\*(C'\fR is ghon be set ta the
length, up in bytes, of dat character.
.Sp
This function should only be used when tha returned \s-1UV\s0 is considered
an index tha fuck into tha Unicode semantic tablez (e.g. swashes).
.Sp
Some yo, but not all, \s-1UTF\-8\s0 malformations is detected, n' up in fact, some
malformed input could cause readin beyond tha end of tha input buffer, which
is why dis function is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \*(L"utf8_to_uvuni_buf\*(R" instead.
.Sp
If \f(CW\*(C`s\*(C'\fR points ta one of tha detected malformations, n' \s-1UTF8\s0 warnings are
enabled, zero is returned n' \f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR don't point to
\&\s-1NULL\s0) ta \-1.  If dem warnings is off, tha computed value if well-defined (or
the Unicode \s-1REPLACEMENT CHARACTER,\s0 if not) is silently returned, n' \f(CW*retlen\fR
is set (if \f(CW\*(C`retlen\*(C'\fR aint \s-1NULL\s0) so dat (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is the
next possible posizzle up in \f(CW\*(C`s\*(C'\fR dat could begin a non-malformed character.
See \*(L"utf8n_to_uvuni\*(R" fo' details on when tha \s-1REPLACEMENT CHARACTER\s0 is returned.
.Sp
.Vb 1
\&        UV      utf8_to_uvuni(const U8 *s, STRLEN *retlen)
.Ve
.IP "utf8_to_uvuni_buf" 8
.IX Xref "utf8_to_uvuni_buf"
.IX Item "utf8_to_uvuni_buf"
Returns tha Unicode code point of tha straight-up original gangsta characta up in tha strang \f(CW\*(C`s\*(C'\fR which
is assumed ta be up in \s-1UTF\-8\s0 encoding; \f(CW\*(C`send\*(C'\fR points ta 1 beyond tha end of \f(CW\*(C`s\*(C'\fR.
\&\f(CW\*(C`retlen\*(C'\fR is ghon be set ta tha length, up in bytes, of dat character.
.Sp
This function should only be used when tha returned \s-1UV\s0 is considered
an index tha fuck into tha Unicode semantic tablez (e.g. swashes).
.Sp
If \f(CW\*(C`s\*(C'\fR do not point ta a well-formed \s-1UTF\-8\s0 characta n' \s-1UTF8\s0 warnings are
enabled, zero is returned n' \f(CW*retlen\fR is set (if \f(CW\*(C`retlen\*(C'\fR aint
\&\s-1NULL\s0) ta \-1.  If dem warnings is off, tha computed value if well-defined (or
the Unicode \s-1REPLACEMENT CHARACTER,\s0 if not) is silently returned, n' \f(CW*retlen\fR
is set (if \f(CW\*(C`retlen\*(C'\fR aint \s-1NULL\s0) so dat (\f(CW\*(C`s\*(C'\fR\ +\ \f(CW*retlen\fR) is the
next possible posizzle up in \f(CW\*(C`s\*(C'\fR dat could begin a non-malformed character.
See \*(L"utf8n_to_uvuni\*(R" fo' details on when tha \s-1REPLACEMENT CHARACTER\s0 is returned.
.Sp
.Vb 2
\&        UV      utf8_to_uvuni_buf(const U8 *s, const U8 *send,
\&                                  STRLEN *retlen)
.Ve
.IP "uvchr_to_utf8" 8
.IX Xref "uvchr_to_utf8"
.IX Item "uvchr_to_utf8"
Addz tha \s-1UTF\-8\s0 representation of tha Natizzle code point \f(CW\*(C`uv\*(C'\fR ta tha end
of tha strang \f(CW\*(C`d\*(C'\fR; \f(CW\*(C`d\*(C'\fR should have at least \f(CW\*(C`UTF8_MAXBYTES+1\*(C'\fR free
bytes available. Da return value is tha pointa ta tha byte afta the
end of tha freshly smoked up character n' shit. In other lyrics,
.Sp
.Vb 1
\&    d = uvchr_to_utf8(d, uv);
.Ve
.Sp
is tha recommended wide natizzle character-aware way of saying
.Sp
.Vb 1
\&    *(d++) = uv;
\&
\&        U8*     uvchr_to_utf8(U8 *d, UV uv)
.Ve
.IP "uvuni_to_utf8_flags" 8
.IX Xref "uvuni_to_utf8_flags"
.IX Item "uvuni_to_utf8_flags"
Addz tha \s-1UTF\-8\s0 representation of tha Unicode code point \f(CW\*(C`uv\*(C'\fR ta tha end
of tha strang \f(CW\*(C`d\*(C'\fR; \f(CW\*(C`d\*(C'\fR should have at least \f(CW\*(C`UTF8_MAXBYTES+1\*(C'\fR free
bytes available. Da return value is tha pointa ta tha byte afta the
end of tha freshly smoked up character n' shit. In other lyrics,
.Sp
.Vb 1
\&    d = uvuni_to_utf8_flags(d, uv, flags);
.Ve
.Sp
or, up in most cases,
.Sp
.Vb 1
\&    d = uvuni_to_utf8(d, uv);
.Ve
.Sp
(which is equivalent to)
.Sp
.Vb 1
\&    d = uvuni_to_utf8_flags(d, uv, 0);
.Ve
.Sp
This is tha recommended Unicode-aware way of saying
.Sp
.Vb 1
\&    *(d++) = uv;
.Ve
.Sp
where uv be a cold-ass lil code point expressed up in Latin\-1 or above, not tha platform's
natizzle characta set.  \fBAlmost all code should instead use \*(L"uvchr_to_utf8\*(R"
or \*(L"uvchr_to_utf8_flags\*(R"\fR.
.Sp
This function will convert ta \s-1UTF\-8 \s0(and not warn) even code points dat aren't
legal Unicode or is problematic, unless \f(CW\*(C`flags\*(C'\fR gotz nuff one or mo' of the
followin flags:
.Sp
If \f(CW\*(C`uv\*(C'\fR be a Unicode surrogate code point n' \s-1UNICODE_WARN_SURROGATE\s0 is set,
the function will raise a warning, provided \s-1UTF8\s0 warnings is enabled. Y'all KNOW dat shit, muthafucka!  If instead
\&\s-1UNICODE_DISALLOW_SURROGATE\s0 is set, tha function will fail n' return \s-1NULL.\s0
If both flags is set, tha function will both warn n' return \s-1NULL.\s0
.Sp
Da \s-1UNICODE_WARN_NONCHAR\s0 n' \s-1UNICODE_DISALLOW_NONCHAR\s0 flags correspondingly
affect how tha fuck tha function handlez a Unicode non-character n' shit.  And likewise, the
\&\s-1UNICODE_WARN_SUPER\s0 n' \s-1UNICODE_DISALLOW_SUPER\s0 flags, affect tha handlin of
code points dat are
above tha Unicode maximum of 0x10FFFF.  Code points above 0x7FFF_FFFF (which are
even less portable) can be warned and/or disallowed even if other above-Unicode
code points is accepted by tha \s-1UNICODE_WARN_FE_FF\s0 n' \s-1UNICODE_DISALLOW_FE_FF\s0
flags.
.Sp
And finally, tha flag \s-1UNICODE_WARN_ILLEGAL_INTERCHANGE\s0 selects all four of the
above \s-1WARN\s0 flags; n' \s-1UNICODE_DISALLOW_ILLEGAL_INTERCHANGE\s0 selects all four
\&\s-1DISALLOW\s0 flags.
.Sp
.Vb 1
\&        U8*     uvuni_to_utf8_flags(U8 *d, UV uv, UV flags)
.Ve
.ie n .SH "Variablez pimped by ""xsubpp"" n' ""xsubpp"" internal functions"
.el .SH "Variablez pimped by \f(CWxsubpp\fP n' \f(CWxsubpp\fP internal functions"
.IX Header "Variablez pimped by xsubpp n' xsubpp internal functions"
.IP "ax" 8
.IX Xref "ax"
.IX Item "ax"
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta indicate tha stack base offset,
used by tha \f(CW\*(C`ST\*(C'\fR, \f(CW\*(C`XSprePUSH\*(C'\fR n' \f(CW\*(C`XSRETURN\*(C'\fR macros.  Da \f(CW\*(C`dMARK\*(C'\fR macro
must be called prior ta setup tha \f(CW\*(C`MARK\*(C'\fR variable.
.Sp
.Vb 1
\&        I32     ax
.Ve
.IP "\s-1CLASS \s0" 8
.IX Xref "CLASS"
.IX Item "CLASS "
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta indicate tha 
class name fo' a \*(C+ \s-1XS\s0 constructor. Shiiit, dis aint no joke.  This be always a \f(CW\*(C`char*\*(C'\fR.  See \f(CW\*(C`THIS\*(C'\fR.
.Sp
.Vb 1
\&        char*   CLASS
.Ve
.IP "dAX" 8
.IX Xref "dAX"
.IX Item "dAX"
Sets up tha \f(CW\*(C`ax\*(C'\fR variable.
This is probably handled automatically by \f(CW\*(C`xsubpp\*(C'\fR by callin \f(CW\*(C`dXSARGS\*(C'\fR.
.Sp
.Vb 1
\&                dAX;
.Ve
.IP "dAXMARK" 8
.IX Xref "dAXMARK"
.IX Item "dAXMARK"
Sets up tha \f(CW\*(C`ax\*(C'\fR variable n' stack marker variable \f(CW\*(C`mark\*(C'\fR.
This is probably handled automatically by \f(CW\*(C`xsubpp\*(C'\fR by callin \f(CW\*(C`dXSARGS\*(C'\fR.
.Sp
.Vb 1
\&                dAXMARK;
.Ve
.IP "dITEMS" 8
.IX Xref "dITEMS"
.IX Item "dITEMS"
Sets up tha \f(CW\*(C`items\*(C'\fR variable.
This is probably handled automatically by \f(CW\*(C`xsubpp\*(C'\fR by callin \f(CW\*(C`dXSARGS\*(C'\fR.
.Sp
.Vb 1
\&                dITEMS;
.Ve
.IP "dUNDERBAR" 8
.IX Xref "dUNDERBAR"
.IX Item "dUNDERBAR"
Sets up any variable needed by tha \f(CW\*(C`UNDERBAR\*(C'\fR macro. Well shiiiit, it used ta define
\&\f(CW\*(C`padoff_du\*(C'\fR yo, but it is currently a noop. But fuck dat shiznit yo, tha word on tha street is dat it is straight fuckin advised
to still use it fo' ensurin past n' future compatibility.
.Sp
.Vb 1
\&                dUNDERBAR;
.Ve
.IP "dXSARGS" 8
.IX Xref "dXSARGS"
.IX Item "dXSARGS"
Sets up stack n' mark pointas fo' a \s-1XSUB,\s0 callin dSP n' dMARK.
Sets up tha \f(CW\*(C`ax\*(C'\fR n' \f(CW\*(C`items\*(C'\fR variablez by callin \f(CW\*(C`dAX\*(C'\fR n' \f(CW\*(C`dITEMS\*(C'\fR.
This is probably handled automatically by \f(CW\*(C`xsubpp\*(C'\fR.
.Sp
.Vb 1
\&                dXSARGS;
.Ve
.IP "dXSI32" 8
.IX Xref "dXSI32"
.IX Item "dXSI32"
Sets up tha \f(CW\*(C`ix\*(C'\fR variable fo' a \s-1XSUB\s0 which has aliases.  This is usually
handled automatically by \f(CW\*(C`xsubpp\*(C'\fR.
.Sp
.Vb 1
\&                dXSI32;
.Ve
.IP "items" 8
.IX Xref "items"
.IX Item "items"
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta indicate tha number of 
items on tha stack.  See \*(L"Variable-length Parameta Lists\*(R" up in perlxs.
.Sp
.Vb 1
\&        I32     items
.Ve
.IP "ix" 8
.IX Xref "ix"
.IX Item "ix"
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta indicate which of a 
\&\s-1XSUB\s0z aliases was used ta invoke dat shit.  See \*(L"Da \s-1ALIAS:\s0 Keyword\*(R" up in perlxs.
.Sp
.Vb 1
\&        I32     ix
.Ve
.IP "newXSproto" 8
.IX Xref "newXSproto"
.IX Item "newXSproto"
Used by \f(CW\*(C`xsubpp\*(C'\fR ta hook up XSUBs as Perl subs.  Addz Perl prototypes to
the subs.
.IP "\s-1RETVAL \s0" 8
.IX Xref "RETVAL"
.IX Item "RETVAL "
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta hold tha return value fo' a 
\&\s-1XSUB.\s0 This be always tha proper type fo' tha \s-1XSUB.\s0 See 
\&\*(L"Da \s-1RETVAL\s0 Variable\*(R" up in perlxs.
.Sp
.Vb 1
\&        (whatever)      RETVAL
.Ve
.IP "\s-1ST \s0" 8
.IX Xref "ST"
.IX Item "ST "
Used ta access elements on tha \s-1XSUB\s0z stack.
.Sp
.Vb 1
\&        SV*     ST(int ix)
.Ve
.IP "\s-1THIS \s0" 8
.IX Xref "THIS"
.IX Item "THIS "
Variable which is setup by \f(CW\*(C`xsubpp\*(C'\fR ta designate tha object up in a \*(C+ 
\&\s-1XSUB. \s0 This be always tha proper type fo' tha \*(C+ object.  See \f(CW\*(C`CLASS\*(C'\fR n' 
\&\*(L"Usin \s-1XS\s0 With \*(C+\*(R" up in perlxs.
.Sp
.Vb 1
\&        (whatever)      THIS
.Ve
.IP "\s-1UNDERBAR \s0" 8
.IX Xref "UNDERBAR"
.IX Item "UNDERBAR "
Da SV* correspondin ta tha \f(CW$_\fR variable. Works even if there
is a lexical \f(CW$_\fR up in scope.
.IP "\s-1XS \s0" 8
.IX Xref "XS"
.IX Item "XS "
Macro ta declare a \s-1XSUB\s0 n' its C parameta list.  This is handled by
\&\f(CW\*(C`xsubpp\*(C'\fR. Well shiiiit, it is tha same ol' dirty as rockin tha mo' explicit \s-1XS_EXTERNAL\s0 macro.
.IP "\s-1XS_APIVERSION_BOOTCHECK \s0" 8
.IX Xref "XS_APIVERSION_BOOTCHECK"
.IX Item "XS_APIVERSION_BOOTCHECK "
Macro ta verify dat tha perl api version a \s-1XS\s0 module has been compiled against
matches tha api version of tha perl interpreta itz bein loaded into.
.Sp
.Vb 1
\&                XS_APIVERSION_BOOTCHECK;
.Ve
.IP "\s-1XS_EXTERNAL \s0" 8
.IX Xref "XS_EXTERNAL"
.IX Item "XS_EXTERNAL "
Macro ta declare a \s-1XSUB\s0 n' its C parameta list explicitly exportin tha symbols.
.IP "\s-1XS_INTERNAL \s0" 8
.IX Xref "XS_INTERNAL"
.IX Item "XS_INTERNAL "
Macro ta declare a \s-1XSUB\s0 n' its C parameta list without exportin tha symbols.
This is handled by \f(CW\*(C`xsubpp\*(C'\fR n' generally preferable over exportin tha \s-1XSUB\s0
symbols unnecessarily.
.IP "\s-1XS_VERSION \s0" 8
.IX Xref "XS_VERSION"
.IX Item "XS_VERSION "
Da version identifier fo' a \s-1XS\s0 module.  This is usually
handled automatically by \f(CW\*(C`ExtUtils::MakeMaker\*(C'\fR.  See \f(CW\*(C`XS_VERSION_BOOTCHECK\*(C'\fR.
.IP "\s-1XS_VERSION_BOOTCHECK \s0" 8
.IX Xref "XS_VERSION_BOOTCHECK"
.IX Item "XS_VERSION_BOOTCHECK "
Macro ta verify dat a \s-1PM\s0 modulez \f(CW$VERSION\fR variable matches tha \s-1XS\s0
modulez \f(CW\*(C`XS_VERSION\*(C'\fR variable.  This is probably handled automatically by
\&\f(CW\*(C`xsubpp\*(C'\fR.  See \*(L"Da \s-1VERSIONCHECK:\s0 Keyword\*(R" up in perlxs.
.Sp
.Vb 1
\&                XS_VERSION_BOOTCHECK;
.Ve
.SH "Warnin n' Dieing"
.IX Header "Warnin n' Dieing"
.IP "croak" 8
.IX Xref "croak"
.IX Item "croak"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`die\*(C'\fR function.
.Sp
Take a sprintf-style format pattern n' argument list.  These is used to
generate a strang message.  If tha message do not end wit a newline,
then it is ghon be extended wit some indication of tha current location
in tha code, as busted lyrics bout fo' \*(L"mess_sv\*(R".
.Sp
Da error message is ghon be used as a exception, by default
returnin control ta tha nearest enclosin \f(CW\*(C`eval\*(C'\fR yo, but subject to
modification by a \f(CW$SIG{_\|_DIE_\|_}\fR handlez n' shit.  In any case, tha \f(CW\*(C`croak\*(C'\fR
function never returns normally.
.Sp
For oldschool reasons, if \f(CW\*(C`pat\*(C'\fR is null then tha contentz of \f(CW\*(C`ERRSV\*(C'\fR
(\f(CW$@\fR) is ghon be used as a error message or object instead of buildin an
error message from arguments, n' you can put dat on yo' toast.  If you wanna throw a non-strin object,
or build a error message up in a \s-1SV\s0 yo ass, it is preferable ta use
the \*(L"croak_sv\*(R" function, which do not involve clobberin \f(CW\*(C`ERRSV\*(C'\fR.
.Sp
.Vb 1
\&        void    croak(const char *pat, ...)
.Ve
.IP "croak_no_modify" 8
.IX Xref "croak_no_modify"
.IX Item "croak_no_modify"
Exactly equivalent ta \f(CW\*(C`Perl_croak(aTHX_ "%s", PL_no_modify)\*(C'\fR yo, but generates
terser object code than rockin \f(CW\*(C`Perl_croak\*(C'\fR. Less code used on exception code
paths reduces \s-1CPU\s0 cache pressure.
.Sp
.Vb 1
\&        void    croak_no_modify()
.Ve
.IP "croak_sv" 8
.IX Xref "croak_sv"
.IX Item "croak_sv"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`die\*(C'\fR function.
.Sp
\&\f(CW\*(C`baseex\*(C'\fR is tha error message or object.  If it aint nuthin but a reference, it
will be used as-is.  Otherwise it is used as a string, n' if it do
not end wit a newline then it is ghon be extended wit some indication of
the current location up in tha code, as busted lyrics bout fo' \*(L"mess_sv\*(R".
.Sp
Da error message or object is ghon be used as a exception, by default
returnin control ta tha nearest enclosin \f(CW\*(C`eval\*(C'\fR yo, but subject to
modification by a \f(CW$SIG{_\|_DIE_\|_}\fR handlez n' shit.  In any case, tha \f(CW\*(C`croak_sv\*(C'\fR
function never returns normally.
.Sp
To take a thugged-out dirtnap wit a simple strang message, tha \*(L"croak\*(R" function may be
more convenient.
.Sp
.Vb 1
\&        void    croak_sv(SV *baseex)
.Ve
.IP "die" 8
.IX Xref "die"
.IX Item "die"
Behaves tha same ol' dirty as \*(L"croak\*(R", except fo' tha return type.
It should be used only where tha \f(CW\*(C`OP *\*(C'\fR return type is required.
Da function never straight-up returns.
.Sp
.Vb 1
\&        OP *    die(const char *pat, ...)
.Ve
.IP "die_sv" 8
.IX Xref "die_sv"
.IX Item "die_sv"
Behaves tha same ol' dirty as \*(L"croak_sv\*(R", except fo' tha return type.
It should be used only where tha \f(CW\*(C`OP *\*(C'\fR return type is required.
Da function never straight-up returns.
.Sp
.Vb 1
\&        OP *    die_sv(SV *baseex)
.Ve
.IP "vcroak" 8
.IX Xref "vcroak"
.IX Item "vcroak"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`die\*(C'\fR function.
.Sp
\&\f(CW\*(C`pat\*(C'\fR n' \f(CW\*(C`args\*(C'\fR is a sprintf-style format pattern n' encapsulated
argument list.  These is used ta generate a strang message.  If the
message do not end wit a newline, then it is ghon be extended with
some indication of tha current location up in tha code, as busted lyrics bout for
\&\*(L"mess_sv\*(R".
.Sp
Da error message is ghon be used as a exception, by default
returnin control ta tha nearest enclosin \f(CW\*(C`eval\*(C'\fR yo, but subject to
modification by a \f(CW$SIG{_\|_DIE_\|_}\fR handlez n' shit.  In any case, tha \f(CW\*(C`croak\*(C'\fR
function never returns normally.
.Sp
For oldschool reasons, if \f(CW\*(C`pat\*(C'\fR is null then tha contentz of \f(CW\*(C`ERRSV\*(C'\fR
(\f(CW$@\fR) is ghon be used as a error message or object instead of buildin an
error message from arguments, n' you can put dat on yo' toast.  If you wanna throw a non-strin object,
or build a error message up in a \s-1SV\s0 yo ass, it is preferable ta use
the \*(L"croak_sv\*(R" function, which do not involve clobberin \f(CW\*(C`ERRSV\*(C'\fR.
.Sp
.Vb 1
\&        void    vcroak(const char *pat, va_list *args)
.Ve
.IP "vwarn" 8
.IX Xref "vwarn"
.IX Item "vwarn"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`warn\*(C'\fR function.
.Sp
\&\f(CW\*(C`pat\*(C'\fR n' \f(CW\*(C`args\*(C'\fR is a sprintf-style format pattern n' encapsulated
argument list.  These is used ta generate a strang message.  If the
message do not end wit a newline, then it is ghon be extended with
some indication of tha current location up in tha code, as busted lyrics bout for
\&\*(L"mess_sv\*(R".
.Sp
Da error message or object will by default be freestyled ta standard error,
but dis is subject ta modification by a \f(CW$SIG{_\|_WARN_\|_}\fR handlez.
.Sp
Unlike wit \*(L"vcroak\*(R", \f(CW\*(C`pat\*(C'\fR aint permitted ta be null.
.Sp
.Vb 1
\&        void    vwarn(const char *pat, va_list *args)
.Ve
.IP "warn" 8
.IX Xref "warn"
.IX Item "warn"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`warn\*(C'\fR function.
.Sp
Take a sprintf-style format pattern n' argument list.  These is used to
generate a strang message.  If tha message do not end wit a newline,
then it is ghon be extended wit some indication of tha current location
in tha code, as busted lyrics bout fo' \*(L"mess_sv\*(R".
.Sp
Da error message or object will by default be freestyled ta standard error,
but dis is subject ta modification by a \f(CW$SIG{_\|_WARN_\|_}\fR handlez.
.Sp
Unlike wit \*(L"croak\*(R", \f(CW\*(C`pat\*(C'\fR aint permitted ta be null.
.Sp
.Vb 1
\&        void    warn(const char *pat, ...)
.Ve
.IP "warn_sv" 8
.IX Xref "warn_sv"
.IX Item "warn_sv"
This be a \s-1XS\s0 intercourse ta Perlz \f(CW\*(C`warn\*(C'\fR function.
.Sp
\&\f(CW\*(C`baseex\*(C'\fR is tha error message or object.  If it aint nuthin but a reference, it
will be used as-is.  Otherwise it is used as a string, n' if it do
not end wit a newline then it is ghon be extended wit some indication of
the current location up in tha code, as busted lyrics bout fo' \*(L"mess_sv\*(R".
.Sp
Da error message or object will by default be freestyled ta standard error,
but dis is subject ta modification by a \f(CW$SIG{_\|_WARN_\|_}\fR handlez.
.Sp
To warn wit a simple strang message, tha \*(L"warn\*(R" function may be
more convenient.
.Sp
.Vb 1
\&        void    warn_sv(SV *baseex)
.Ve
.SH "Undocumented functions"
.IX Header "Undocumented functions"
Da followin functions done been flagged as part of tha hood \s-1API,\s0
but is currently undocumented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use dem at yo' own risk, as the
interfaces is subject ta chizzle.  Functions dat is not listed up in this
document is not intended fo' hood use, n' should \s-1NOT\s0 be used under any
circumstances.
.PP
If you use one of tha undocumented functions below, you may wish ta consider
bustin n' submittin documentation fo' dat shit. If yo' patch be accepted, this
will indicate dat tha intercourse is stable (unless it is explicitly marked
otherwise).
.IP "GetVars" 4
.IX Xref "GetVars"
.IX Item "GetVars"
.PD 0
.IP "Gv_AMupdate" 4
.IX Xref "Gv_AMupdate"
.IX Item "Gv_AMupdate"
.IP "PerlIO_clearerr" 4
.IX Xref "PerlIO_clearerr"
.IX Item "PerlIO_clearerr"
.IP "PerlIO_close" 4
.IX Xref "PerlIO_close"
.IX Item "PerlIO_close"
.IP "PerlIO_context_layers" 4
.IX Xref "PerlIO_context_layers"
.IX Item "PerlIO_context_layers"
.IP "PerlIO_eof" 4
.IX Xref "PerlIO_eof"
.IX Item "PerlIO_eof"
.IP "PerlIO_error" 4
.IX Xref "PerlIO_error"
.IX Item "PerlIO_error"
.IP "PerlIO_fileno" 4
.IX Xref "PerlIO_fileno"
.IX Item "PerlIO_fileno"
.IP "PerlIO_fill" 4
.IX Xref "PerlIO_fill"
.IX Item "PerlIO_fill"
.IP "PerlIO_flush" 4
.IX Xref "PerlIO_flush"
.IX Item "PerlIO_flush"
.IP "PerlIO_get_base" 4
.IX Xref "PerlIO_get_base"
.IX Item "PerlIO_get_base"
.IP "PerlIO_get_bufsiz" 4
.IX Xref "PerlIO_get_bufsiz"
.IX Item "PerlIO_get_bufsiz"
.IP "PerlIO_get_cnt" 4
.IX Xref "PerlIO_get_cnt"
.IX Item "PerlIO_get_cnt"
.IP "PerlIO_get_ptr" 4
.IX Xref "PerlIO_get_ptr"
.IX Item "PerlIO_get_ptr"
.IP "PerlIO_read" 4
.IX Xref "PerlIO_read"
.IX Item "PerlIO_read"
.IP "PerlIO_seek" 4
.IX Xref "PerlIO_seek"
.IX Item "PerlIO_seek"
.IP "PerlIO_set_cnt" 4
.IX Xref "PerlIO_set_cnt"
.IX Item "PerlIO_set_cnt"
.IP "PerlIO_set_ptrcnt" 4
.IX Xref "PerlIO_set_ptrcnt"
.IX Item "PerlIO_set_ptrcnt"
.IP "PerlIO_setlinebuf" 4
.IX Xref "PerlIO_setlinebuf"
.IX Item "PerlIO_setlinebuf"
.IP "PerlIO_stderr" 4
.IX Xref "PerlIO_stderr"
.IX Item "PerlIO_stderr"
.IP "PerlIO_stdin" 4
.IX Xref "PerlIO_stdin"
.IX Item "PerlIO_stdin"
.IP "PerlIO_stdout" 4
.IX Xref "PerlIO_stdout"
.IX Item "PerlIO_stdout"
.IP "PerlIO_tell" 4
.IX Xref "PerlIO_tell"
.IX Item "PerlIO_tell"
.IP "PerlIO_unread" 4
.IX Xref "PerlIO_unread"
.IX Item "PerlIO_unread"
.IP "PerlIO_write" 4
.IX Xref "PerlIO_write"
.IX Item "PerlIO_write"
.IP "amagic_call" 4
.IX Xref "amagic_call"
.IX Item "amagic_call"
.IP "amagic_deref_call" 4
.IX Xref "amagic_deref_call"
.IX Item "amagic_deref_call"
.IP "any_dup" 4
.IX Xref "any_dup"
.IX Item "any_dup"
.IP "atfork_lock" 4
.IX Xref "atfork_lock"
.IX Item "atfork_lock"
.IP "atfork_unlock" 4
.IX Xref "atfork_unlock"
.IX Item "atfork_unlock"
.IP "av_arylen_p" 4
.IX Xref "av_arylen_p"
.IX Item "av_arylen_p"
.IP "av_iter_p" 4
.IX Xref "av_iter_p"
.IX Item "av_iter_p"
.IP "block_gimme" 4
.IX Xref "block_gimme"
.IX Item "block_gimme"
.IP "call_atexit" 4
.IX Xref "call_atexit"
.IX Item "call_atexit"
.IP "call_list" 4
.IX Xref "call_list"
.IX Item "call_list"
.IP "calloc" 4
.IX Xref "calloc"
.IX Item "calloc"
.IP "cast_i32" 4
.IX Xref "cast_i32"
.IX Item "cast_i32"
.IP "cast_iv" 4
.IX Xref "cast_iv"
.IX Item "cast_iv"
.IP "cast_ulong" 4
.IX Xref "cast_ulong"
.IX Item "cast_ulong"
.IP "cast_uv" 4
.IX Xref "cast_uv"
.IX Item "cast_uv"
.IP "ck_warner" 4
.IX Xref "ck_warner"
.IX Item "ck_warner"
.IP "ck_warner_d" 4
.IX Xref "ck_warner_d"
.IX Item "ck_warner_d"
.IP "ckwarn" 4
.IX Xref "ckwarn"
.IX Item "ckwarn"
.IP "ckwarn_d" 4
.IX Xref "ckwarn_d"
.IX Item "ckwarn_d"
.IP "clone_params_del" 4
.IX Xref "clone_params_del"
.IX Item "clone_params_del"
.IP "clone_params_new" 4
.IX Xref "clone_params_new"
.IX Item "clone_params_new"
.IP "croak_nocontext" 4
.IX Xref "croak_nocontext"
.IX Item "croak_nocontext"
.IP "csighandlez" 4
.IX Xref "csighandlez"
.IX Item "csighandlez"
.IP "cx_dump" 4
.IX Xref "cx_dump"
.IX Item "cx_dump"
.IP "cx_dup" 4
.IX Xref "cx_dup"
.IX Item "cx_dup"
.IP "cxinc" 4
.IX Xref "cxinc"
.IX Item "cxinc"
.IP "deb" 4
.IX Xref "deb"
.IX Item "deb"
.IP "deb_nocontext" 4
.IX Xref "deb_nocontext"
.IX Item "deb_nocontext"
.IP "debop" 4
.IX Xref "debop"
.IX Item "debop"
.IP "debprofdump" 4
.IX Xref "debprofdump"
.IX Item "debprofdump"
.IP "debstack" 4
.IX Xref "debstack"
.IX Item "debstack"
.IP "debstackptrs" 4
.IX Xref "debstackptrs"
.IX Item "debstackptrs"
.IP "delimcpy" 4
.IX Xref "delimcpy"
.IX Item "delimcpy"
.IP "despatch_signals" 4
.IX Xref "despatch_signals"
.IX Item "despatch_signals"
.IP "die_nocontext" 4
.IX Xref "die_nocontext"
.IX Item "die_nocontext"
.IP "dirp_dup" 4
.IX Xref "dirp_dup"
.IX Item "dirp_dup"
.IP "do_aspawn" 4
.IX Xref "do_aspawn"
.IX Item "do_aspawn"
.IP "do_binmode" 4
.IX Xref "do_binmode"
.IX Item "do_binmode"
.IP "do_close" 4
.IX Xref "do_close"
.IX Item "do_close"
.IP "do_gv_dump" 4
.IX Xref "do_gv_dump"
.IX Item "do_gv_dump"
.IP "do_gvgv_dump" 4
.IX Xref "do_gvgv_dump"
.IX Item "do_gvgv_dump"
.IP "do_hv_dump" 4
.IX Xref "do_hv_dump"
.IX Item "do_hv_dump"
.IP "do_join" 4
.IX Xref "do_join"
.IX Item "do_join"
.IP "do_magic_dump" 4
.IX Xref "do_magic_dump"
.IX Item "do_magic_dump"
.IP "do_op_dump" 4
.IX Xref "do_op_dump"
.IX Item "do_op_dump"
.IP "do_open" 4
.IX Xref "do_open"
.IX Item "do_open"
.IP "do_open9" 4
.IX Xref "do_open9"
.IX Item "do_open9"
.IP "do_openn" 4
.IX Xref "do_openn"
.IX Item "do_openn"
.IP "do_pmop_dump" 4
.IX Xref "do_pmop_dump"
.IX Item "do_pmop_dump"
.IP "do_spawn" 4
.IX Xref "do_spawn"
.IX Item "do_spawn"
.IP "do_spawn_nowait" 4
.IX Xref "do_spawn_nowait"
.IX Item "do_spawn_nowait"
.IP "do_sprintf" 4
.IX Xref "do_sprintf"
.IX Item "do_sprintf"
.IP "do_sv_dump" 4
.IX Xref "do_sv_dump"
.IX Item "do_sv_dump"
.IP "doing_taint" 4
.IX Xref "doing_taint"
.IX Item "doing_taint"
.IP "doref" 4
.IX Xref "doref"
.IX Item "doref"
.IP "dounwind" 4
.IX Xref "dounwind"
.IX Item "dounwind"
.IP "dowantarray" 4
.IX Xref "dowantarray"
.IX Item "dowantarray"
.IP "dump_all" 4
.IX Xref "dump_all"
.IX Item "dump_all"
.IP "dump_eval" 4
.IX Xref "dump_eval"
.IX Item "dump_eval"
.IP "dump_fds" 4
.IX Xref "dump_fds"
.IX Item "dump_fds"
.IP "dump_form" 4
.IX Xref "dump_form"
.IX Item "dump_form"
.IP "dump_indent" 4
.IX Xref "dump_indent"
.IX Item "dump_indent"
.IP "dump_mstats" 4
.IX Xref "dump_mstats"
.IX Item "dump_mstats"
.IP "dump_packsubs" 4
.IX Xref "dump_packsubs"
.IX Item "dump_packsubs"
.IP "dump_sub" 4
.IX Xref "dump_sub"
.IX Item "dump_sub"
.IP "dump_vindent" 4
.IX Xref "dump_vindent"
.IX Item "dump_vindent"
.IP "filter_add" 4
.IX Xref "filter_add"
.IX Item "filter_add"
.IP "filter_del" 4
.IX Xref "filter_del"
.IX Item "filter_del"
.IP "filter_read" 4
.IX Xref "filter_read"
.IX Item "filter_read"
.IP "foldEQ_latin1" 4
.IX Xref "foldEQ_latin1"
.IX Item "foldEQ_latin1"
.IP "form_nocontext" 4
.IX Xref "form_nocontext"
.IX Item "form_nocontext"
.IP "fp_dup" 4
.IX Xref "fp_dup"
.IX Item "fp_dup"
.IP "fprintf_nocontext" 4
.IX Xref "fprintf_nocontext"
.IX Item "fprintf_nocontext"
.IP "free_global_struct" 4
.IX Xref "free_global_struct"
.IX Item "free_global_struct"
.IP "free_tmps" 4
.IX Xref "free_tmps"
.IX Item "free_tmps"
.IP "get_context" 4
.IX Xref "get_context"
.IX Item "get_context"
.IP "get_mstats" 4
.IX Xref "get_mstats"
.IX Item "get_mstats"
.IP "get_op_descs" 4
.IX Xref "get_op_descs"
.IX Item "get_op_descs"
.IP "get_op_names" 4
.IX Xref "get_op_names"
.IX Item "get_op_names"
.IP "get_ppaddr" 4
.IX Xref "get_ppaddr"
.IX Item "get_ppaddr"
.IP "get_vtbl" 4
.IX Xref "get_vtbl"
.IX Item "get_vtbl"
.IP "gp_dup" 4
.IX Xref "gp_dup"
.IX Item "gp_dup"
.IP "gp_free" 4
.IX Xref "gp_free"
.IX Item "gp_free"
.IP "gp_ref" 4
.IX Xref "gp_ref"
.IX Item "gp_ref"
.IP "gv_AVadd" 4
.IX Xref "gv_AVadd"
.IX Item "gv_AVadd"
.IP "gv_HVadd" 4
.IX Xref "gv_HVadd"
.IX Item "gv_HVadd"
.IP "gv_IOadd" 4
.IX Xref "gv_IOadd"
.IX Item "gv_IOadd"
.IP "gv_SVadd" 4
.IX Xref "gv_SVadd"
.IX Item "gv_SVadd"
.IP "gv_add_by_type" 4
.IX Xref "gv_add_by_type"
.IX Item "gv_add_by_type"
.IP "gv_autoload4" 4
.IX Xref "gv_autoload4"
.IX Item "gv_autoload4"
.IP "gv_autoload_pv" 4
.IX Xref "gv_autoload_pv"
.IX Item "gv_autoload_pv"
.IP "gv_autoload_pvn" 4
.IX Xref "gv_autoload_pvn"
.IX Item "gv_autoload_pvn"
.IP "gv_autoload_sv" 4
.IX Xref "gv_autoload_sv"
.IX Item "gv_autoload_sv"
.IP "gv_check" 4
.IX Xref "gv_check"
.IX Item "gv_check"
.IP "gv_dump" 4
.IX Xref "gv_dump"
.IX Item "gv_dump"
.IP "gv_efullname" 4
.IX Xref "gv_efullname"
.IX Item "gv_efullname"
.IP "gv_efullname3" 4
.IX Xref "gv_efullname3"
.IX Item "gv_efullname3"
.IP "gv_efullname4" 4
.IX Xref "gv_efullname4"
.IX Item "gv_efullname4"
.IP "gv_fetchfile" 4
.IX Xref "gv_fetchfile"
.IX Item "gv_fetchfile"
.IP "gv_fetchfile_flags" 4
.IX Xref "gv_fetchfile_flags"
.IX Item "gv_fetchfile_flags"
.IP "gv_fetchpv" 4
.IX Xref "gv_fetchpv"
.IX Item "gv_fetchpv"
.IP "gv_fetchpvn_flags" 4
.IX Xref "gv_fetchpvn_flags"
.IX Item "gv_fetchpvn_flags"
.IP "gv_fetchsv" 4
.IX Xref "gv_fetchsv"
.IX Item "gv_fetchsv"
.IP "gv_fullname" 4
.IX Xref "gv_fullname"
.IX Item "gv_fullname"
.IP "gv_fullname3" 4
.IX Xref "gv_fullname3"
.IX Item "gv_fullname3"
.IP "gv_fullname4" 4
.IX Xref "gv_fullname4"
.IX Item "gv_fullname4"
.IP "gv_handlez" 4
.IX Xref "gv_handlez"
.IX Item "gv_handlez"
.IP "gv_name_set" 4
.IX Xref "gv_name_set"
.IX Item "gv_name_set"
.IP "he_dup" 4
.IX Xref "he_dup"
.IX Item "he_dup"
.IP "hek_dup" 4
.IX Xref "hek_dup"
.IX Item "hek_dup"
.IP "hv_common" 4
.IX Xref "hv_common"
.IX Item "hv_common"
.IP "hv_common_key_len" 4
.IX Xref "hv_common_key_len"
.IX Item "hv_common_key_len"
.IP "hv_delayfree_ent" 4
.IX Xref "hv_delayfree_ent"
.IX Item "hv_delayfree_ent"
.IP "hv_eiter_p" 4
.IX Xref "hv_eiter_p"
.IX Item "hv_eiter_p"
.IP "hv_eiter_set" 4
.IX Xref "hv_eiter_set"
.IX Item "hv_eiter_set"
.IP "hv_free_ent" 4
.IX Xref "hv_free_ent"
.IX Item "hv_free_ent"
.IP "hv_ksplit" 4
.IX Xref "hv_ksplit"
.IX Item "hv_ksplit"
.IP "hv_name_set" 4
.IX Xref "hv_name_set"
.IX Item "hv_name_set"
.IP "hv_placeholders_get" 4
.IX Xref "hv_placeholders_get"
.IX Item "hv_placeholders_get"
.IP "hv_placeholders_p" 4
.IX Xref "hv_placeholders_p"
.IX Item "hv_placeholders_p"
.IP "hv_placeholders_set" 4
.IX Xref "hv_placeholders_set"
.IX Item "hv_placeholders_set"
.IP "hv_rand_set" 4
.IX Xref "hv_rand_set"
.IX Item "hv_rand_set"
.IP "hv_riter_p" 4
.IX Xref "hv_riter_p"
.IX Item "hv_riter_p"
.IP "hv_riter_set" 4
.IX Xref "hv_riter_set"
.IX Item "hv_riter_set"
.IP "init_global_struct" 4
.IX Xref "init_global_struct"
.IX Item "init_global_struct"
.IP "init_i18nl10n" 4
.IX Xref "init_i18nl10n"
.IX Item "init_i18nl10n"
.IP "init_i18nl14n" 4
.IX Xref "init_i18nl14n"
.IX Item "init_i18nl14n"
.IP "init_stacks" 4
.IX Xref "init_stacks"
.IX Item "init_stacks"
.IP "init_tm" 4
.IX Xref "init_tm"
.IX Item "init_tm"
.IP "instr" 4
.IX Xref "instr"
.IX Item "instr"
.IP "is_lvalue_sub" 4
.IX Xref "is_lvalue_sub"
.IX Item "is_lvalue_sub"
.IP "leave_scope" 4
.IX Xref "leave_scope"
.IX Item "leave_scope"
.IP "load_module_nocontext" 4
.IX Xref "load_module_nocontext"
.IX Item "load_module_nocontext"
.IP "magic_dump" 4
.IX Xref "magic_dump"
.IX Item "magic_dump"
.IP "malloc" 4
.IX Xref "malloc"
.IX Item "malloc"
.IP "markstack_grow" 4
.IX Xref "markstack_grow"
.IX Item "markstack_grow"
.IP "mess_nocontext" 4
.IX Xref "mess_nocontext"
.IX Item "mess_nocontext"
.IP "mfree" 4
.IX Xref "mfree"
.IX Item "mfree"
.IP "mg_dup" 4
.IX Xref "mg_dup"
.IX Item "mg_dup"
.IP "mg_size" 4
.IX Xref "mg_size"
.IX Item "mg_size"
.IP "mini_mktime" 4
.IX Xref "mini_mktime"
.IX Item "mini_mktime"
.IP "moreswitches" 4
.IX Xref "moreswitches"
.IX Item "moreswitches"
.IP "mro_get_from_name" 4
.IX Xref "mro_get_from_name"
.IX Item "mro_get_from_name"
.IP "mro_get_private_data" 4
.IX Xref "mro_get_private_data"
.IX Item "mro_get_private_data"
.IP "mro_set_mro" 4
.IX Xref "mro_set_mro"
.IX Item "mro_set_mro"
.IP "mro_set_private_data" 4
.IX Xref "mro_set_private_data"
.IX Item "mro_set_private_data"
.IP "my_atof" 4
.IX Xref "my_atof"
.IX Item "my_atof"
.IP "my_atof2" 4
.IX Xref "my_atof2"
.IX Item "my_atof2"
.IP "my_bcopy" 4
.IX Xref "my_bcopy"
.IX Item "my_bcopy"
.IP "my_bzero" 4
.IX Xref "my_bzero"
.IX Item "my_bzero"
.IP "my_chsize" 4
.IX Xref "my_chsize"
.IX Item "my_chsize"
.IP "my_cxt_index" 4
.IX Xref "my_cxt_index"
.IX Item "my_cxt_index"
.IP "my_cxt_init" 4
.IX Xref "my_cxt_init"
.IX Item "my_cxt_init"
.IP "my_dirfd" 4
.IX Xref "my_dirfd"
.IX Item "my_dirfd"
.IP "my_exit" 4
.IX Xref "my_exit"
.IX Item "my_exit"
.IP "my_failure_exit" 4
.IX Xref "my_failure_exit"
.IX Item "my_failure_exit"
.IP "my_fflush_all" 4
.IX Xref "my_fflush_all"
.IX Item "my_fflush_all"
.IP "my_fork" 4
.IX Xref "my_fork"
.IX Item "my_fork"
.IP "my_htonl" 4
.IX Xref "my_htonl"
.IX Item "my_htonl"
.IP "my_lstat" 4
.IX Xref "my_lstat"
.IX Item "my_lstat"
.IP "my_memcmp" 4
.IX Xref "my_memcmp"
.IX Item "my_memcmp"
.IP "my_memset" 4
.IX Xref "my_memset"
.IX Item "my_memset"
.IP "my_ntohl" 4
.IX Xref "my_ntohl"
.IX Item "my_ntohl"
.IP "my_pclose" 4
.IX Xref "my_pclose"
.IX Item "my_pclose"
.IP "my_popen" 4
.IX Xref "my_popen"
.IX Item "my_popen"
.IP "my_popen_list" 4
.IX Xref "my_popen_list"
.IX Item "my_popen_list"
.IP "my_setenv" 4
.IX Xref "my_setenv"
.IX Item "my_setenv"
.IP "my_socketpair" 4
.IX Xref "my_socketpair"
.IX Item "my_socketpair"
.IP "my_stat" 4
.IX Xref "my_stat"
.IX Item "my_stat"
.IP "my_strftime" 4
.IX Xref "my_strftime"
.IX Item "my_strftime"
.IP "my_strlcat" 4
.IX Xref "my_strlcat"
.IX Item "my_strlcat"
.IP "my_strlcpy" 4
.IX Xref "my_strlcpy"
.IX Item "my_strlcpy"
.IP "my_swap" 4
.IX Xref "my_swap"
.IX Item "my_swap"
.IP "newANONATTRSUB" 4
.IX Xref "newANONATTRSUB"
.IX Item "newANONATTRSUB"
.IP "newANONHASH" 4
.IX Xref "newANONHASH"
.IX Item "newANONHASH"
.IP "newANONLIST" 4
.IX Xref "newANONLIST"
.IX Item "newANONLIST"
.IP "newANONSUB" 4
.IX Xref "newANONSUB"
.IX Item "newANONSUB"
.IP "newATTRSUB" 4
.IX Xref "newATTRSUB"
.IX Item "newATTRSUB"
.IP "newAVREF" 4
.IX Xref "newAVREF"
.IX Item "newAVREF"
.IP "newCVREF" 4
.IX Xref "newCVREF"
.IX Item "newCVREF"
.IP "newFORM" 4
.IX Xref "newFORM"
.IX Item "newFORM"
.IP "newGVREF" 4
.IX Xref "newGVREF"
.IX Item "newGVREF"
.IP "newGVgen" 4
.IX Xref "newGVgen"
.IX Item "newGVgen"
.IP "newGVgen_flags" 4
.IX Xref "newGVgen_flags"
.IX Item "newGVgen_flags"
.IP "newHVREF" 4
.IX Xref "newHVREF"
.IX Item "newHVREF"
.IP "newHVhv" 4
.IX Xref "newHVhv"
.IX Item "newHVhv"
.IP "newIO" 4
.IX Xref "newIO"
.IX Item "newIO"
.IP "newMYSUB" 4
.IX Xref "newMYSUB"
.IX Item "newMYSUB"
.IP "newPROG" 4
.IX Xref "newPROG"
.IX Item "newPROG"
.IP "newRV" 4
.IX Xref "newRV"
.IX Item "newRV"
.IP "newSUB" 4
.IX Xref "newSUB"
.IX Item "newSUB"
.IP "newSVREF" 4
.IX Xref "newSVREF"
.IX Item "newSVREF"
.IP "newSVpvf_nocontext" 4
.IX Xref "newSVpvf_nocontext"
.IX Item "newSVpvf_nocontext"
.IP "new_collate" 4
.IX Xref "new_collate"
.IX Item "new_collate"
.IP "new_ctype" 4
.IX Xref "new_ctype"
.IX Item "new_ctype"
.IP "new_numeric" 4
.IX Xref "new_numeric"
.IX Item "new_numeric"
.IP "new_stackinfo" 4
.IX Xref "new_stackinfo"
.IX Item "new_stackinfo"
.IP "ninstr" 4
.IX Xref "ninstr"
.IX Item "ninstr"
.IP "op_dump" 4
.IX Xref "op_dump"
.IX Item "op_dump"
.IP "op_free" 4
.IX Xref "op_free"
.IX Item "op_free"
.IP "op_null" 4
.IX Xref "op_null"
.IX Item "op_null"
.IP "op_refcnt_lock" 4
.IX Xref "op_refcnt_lock"
.IX Item "op_refcnt_lock"
.IP "op_refcnt_unlock" 4
.IX Xref "op_refcnt_unlock"
.IX Item "op_refcnt_unlock"
.IP "parser_dup" 4
.IX Xref "parser_dup"
.IX Item "parser_dup"
.IP "perl_alloc_using" 4
.IX Xref "perl_alloc_using"
.IX Item "perl_alloc_using"
.IP "perl_clone_using" 4
.IX Xref "perl_clone_using"
.IX Item "perl_clone_using"
.IP "pmop_dump" 4
.IX Xref "pmop_dump"
.IX Item "pmop_dump"
.IP "pop_scope" 4
.IX Xref "pop_scope"
.IX Item "pop_scope"
.IP "pregcomp" 4
.IX Xref "pregcomp"
.IX Item "pregcomp"
.IP "pregexec" 4
.IX Xref "pregexec"
.IX Item "pregexec"
.IP "pregfree" 4
.IX Xref "pregfree"
.IX Item "pregfree"
.IP "pregfree2" 4
.IX Xref "pregfree2"
.IX Item "pregfree2"
.IP "printf_nocontext" 4
.IX Xref "printf_nocontext"
.IX Item "printf_nocontext"
.IP "ptr_table_clear" 4
.IX Xref "ptr_table_clear"
.IX Item "ptr_table_clear"
.IP "ptr_table_fetch" 4
.IX Xref "ptr_table_fetch"
.IX Item "ptr_table_fetch"
.IP "ptr_table_free" 4
.IX Xref "ptr_table_free"
.IX Item "ptr_table_free"
.IP "ptr_table_new" 4
.IX Xref "ptr_table_new"
.IX Item "ptr_table_new"
.IP "ptr_table_split" 4
.IX Xref "ptr_table_split"
.IX Item "ptr_table_split"
.IP "ptr_table_store" 4
.IX Xref "ptr_table_store"
.IX Item "ptr_table_store"
.IP "push_scope" 4
.IX Xref "push_scope"
.IX Item "push_scope"
.IP "re_compile" 4
.IX Xref "re_compile"
.IX Item "re_compile"
.IP "re_dup_guts" 4
.IX Xref "re_dup_guts"
.IX Item "re_dup_guts"
.IP "re_intuit_start" 4
.IX Xref "re_intuit_start"
.IX Item "re_intuit_start"
.IP "re_intuit_string" 4
.IX Xref "re_intuit_string"
.IX Item "re_intuit_string"
.IP "realloc" 4
.IX Xref "realloc"
.IX Item "realloc"
.IP "reentrant_free" 4
.IX Xref "reentrant_free"
.IX Item "reentrant_free"
.IP "reentrant_init" 4
.IX Xref "reentrant_init"
.IX Item "reentrant_init"
.IP "reentrant_retry" 4
.IX Xref "reentrant_retry"
.IX Item "reentrant_retry"
.IP "reentrant_size" 4
.IX Xref "reentrant_size"
.IX Item "reentrant_size"
.IP "ref" 4
.IX Xref "ref"
.IX Item "ref"
.IP "reg_named_buff_all" 4
.IX Xref "reg_named_buff_all"
.IX Item "reg_named_buff_all"
.IP "reg_named_buff_exists" 4
.IX Xref "reg_named_buff_exists"
.IX Item "reg_named_buff_exists"
.IP "reg_named_buff_fetch" 4
.IX Xref "reg_named_buff_fetch"
.IX Item "reg_named_buff_fetch"
.IP "reg_named_buff_firstkey" 4
.IX Xref "reg_named_buff_firstkey"
.IX Item "reg_named_buff_firstkey"
.IP "reg_named_buff_nextkey" 4
.IX Xref "reg_named_buff_nextkey"
.IX Item "reg_named_buff_nextkey"
.IP "reg_named_buff_scalar" 4
.IX Xref "reg_named_buff_scalar"
.IX Item "reg_named_buff_scalar"
.IP "regclass_swash" 4
.IX Xref "regclass_swash"
.IX Item "regclass_swash"
.IP "regdump" 4
.IX Xref "regdump"
.IX Item "regdump"
.IP "regdupe_internal" 4
.IX Xref "regdupe_internal"
.IX Item "regdupe_internal"
.IP "regexec_flags" 4
.IX Xref "regexec_flags"
.IX Item "regexec_flags"
.IP "regfree_internal" 4
.IX Xref "regfree_internal"
.IX Item "regfree_internal"
.IP "reginitcolors" 4
.IX Xref "reginitcolors"
.IX Item "reginitcolors"
.IP "regnext" 4
.IX Xref "regnext"
.IX Item "regnext"
.IP "repeatcpy" 4
.IX Xref "repeatcpy"
.IX Item "repeatcpy"
.IP "rninstr" 4
.IX Xref "rninstr"
.IX Item "rninstr"
.IP "rsignal" 4
.IX Xref "rsignal"
.IX Item "rsignal"
.IP "rsignal_state" 4
.IX Xref "rsignal_state"
.IX Item "rsignal_state"
.IP "runops_debug" 4
.IX Xref "runops_debug"
.IX Item "runops_debug"
.IP "runops_standard" 4
.IX Xref "runops_standard"
.IX Item "runops_standard"
.IP "rvpv_dup" 4
.IX Xref "rvpv_dup"
.IX Item "rvpv_dup"
.IP "safesyscalloc" 4
.IX Xref "safesyscalloc"
.IX Item "safesyscalloc"
.IP "safesysfree" 4
.IX Xref "safesysfree"
.IX Item "safesysfree"
.IP "safesysmalloc" 4
.IX Xref "safesysmalloc"
.IX Item "safesysmalloc"
.IP "safesysrealloc" 4
.IX Xref "safesysrealloc"
.IX Item "safesysrealloc"
.IP "save_I16" 4
.IX Xref "save_I16"
.IX Item "save_I16"
.IP "save_I32" 4
.IX Xref "save_I32"
.IX Item "save_I32"
.IP "save_I8" 4
.IX Xref "save_I8"
.IX Item "save_I8"
.IP "save_adelete" 4
.IX Xref "save_adelete"
.IX Item "save_adelete"
.IP "save_aelem" 4
.IX Xref "save_aelem"
.IX Item "save_aelem"
.IP "save_aelem_flags" 4
.IX Xref "save_aelem_flags"
.IX Item "save_aelem_flags"
.IP "save_alloc" 4
.IX Xref "save_alloc"
.IX Item "save_alloc"
.IP "save_aptr" 4
.IX Xref "save_aptr"
.IX Item "save_aptr"
.IP "save_ary" 4
.IX Xref "save_ary"
.IX Item "save_ary"
.IP "save_bool" 4
.IX Xref "save_bool"
.IX Item "save_bool"
.IP "save_clearsv" 4
.IX Xref "save_clearsv"
.IX Item "save_clearsv"
.IP "save_delete" 4
.IX Xref "save_delete"
.IX Item "save_delete"
.IP "save_destructor" 4
.IX Xref "save_destructor"
.IX Item "save_destructor"
.IP "save_destructor_x" 4
.IX Xref "save_destructor_x"
.IX Item "save_destructor_x"
.IP "save_freeop" 4
.IX Xref "save_freeop"
.IX Item "save_freeop"
.IP "save_freepv" 4
.IX Xref "save_freepv"
.IX Item "save_freepv"
.IP "save_freesv" 4
.IX Xref "save_freesv"
.IX Item "save_freesv"
.IP "save_generic_pvref" 4
.IX Xref "save_generic_pvref"
.IX Item "save_generic_pvref"
.IP "save_generic_svref" 4
.IX Xref "save_generic_svref"
.IX Item "save_generic_svref"
.IP "save_gp" 4
.IX Xref "save_gp"
.IX Item "save_gp"
.IP "save_hash" 4
.IX Xref "save_hash"
.IX Item "save_hash"
.IP "save_hdelete" 4
.IX Xref "save_hdelete"
.IX Item "save_hdelete"
.IP "save_helem" 4
.IX Xref "save_helem"
.IX Item "save_helem"
.IP "save_helem_flags" 4
.IX Xref "save_helem_flags"
.IX Item "save_helem_flags"
.IP "save_hints" 4
.IX Xref "save_hints"
.IX Item "save_hints"
.IP "save_hptr" 4
.IX Xref "save_hptr"
.IX Item "save_hptr"
.IP "save_int" 4
.IX Xref "save_int"
.IX Item "save_int"
.IP "save_item" 4
.IX Xref "save_item"
.IX Item "save_item"
.IP "save_iv" 4
.IX Xref "save_iv"
.IX Item "save_iv"
.IP "save_list" 4
.IX Xref "save_list"
.IX Item "save_list"
.IP "save_long" 4
.IX Xref "save_long"
.IX Item "save_long"
.IP "save_mortalizesv" 4
.IX Xref "save_mortalizesv"
.IX Item "save_mortalizesv"
.IP "save_nogv" 4
.IX Xref "save_nogv"
.IX Item "save_nogv"
.IP "save_op" 4
.IX Xref "save_op"
.IX Item "save_op"
.IP "save_padsv_and_mortalize" 4
.IX Xref "save_padsv_and_mortalize"
.IX Item "save_padsv_and_mortalize"
.IP "save_pptr" 4
.IX Xref "save_pptr"
.IX Item "save_pptr"
.IP "save_pushi32ptr" 4
.IX Xref "save_pushi32ptr"
.IX Item "save_pushi32ptr"
.IP "save_pushptr" 4
.IX Xref "save_pushptr"
.IX Item "save_pushptr"
.IP "save_pushptrptr" 4
.IX Xref "save_pushptrptr"
.IX Item "save_pushptrptr"
.IP "save_re_context" 4
.IX Xref "save_re_context"
.IX Item "save_re_context"
.IP "save_scalar" 4
.IX Xref "save_scalar"
.IX Item "save_scalar"
.IP "save_set_svflags" 4
.IX Xref "save_set_svflags"
.IX Item "save_set_svflags"
.IP "save_shared_pvref" 4
.IX Xref "save_shared_pvref"
.IX Item "save_shared_pvref"
.IP "save_sptr" 4
.IX Xref "save_sptr"
.IX Item "save_sptr"
.IP "save_svref" 4
.IX Xref "save_svref"
.IX Item "save_svref"
.IP "save_vptr" 4
.IX Xref "save_vptr"
.IX Item "save_vptr"
.IP "savestack_grow" 4
.IX Xref "savestack_grow"
.IX Item "savestack_grow"
.IP "savestack_grow_cnt" 4
.IX Xref "savestack_grow_cnt"
.IX Item "savestack_grow_cnt"
.IP "scan_num" 4
.IX Xref "scan_num"
.IX Item "scan_num"
.IP "scan_vstring" 4
.IX Xref "scan_vstring"
.IX Item "scan_vstring"
.IP "screaminstr" 4
.IX Xref "screaminstr"
.IX Item "screaminstr"
.IP "seed" 4
.IX Xref "seed"
.IX Item "seed"
.IP "set_context" 4
.IX Xref "set_context"
.IX Item "set_context"
.IP "set_numeric_local" 4
.IX Xref "set_numeric_local"
.IX Item "set_numeric_local"
.IP "set_numeric_radix" 4
.IX Xref "set_numeric_radix"
.IX Item "set_numeric_radix"
.IP "set_numeric_standard" 4
.IX Xref "set_numeric_standard"
.IX Item "set_numeric_standard"
.IP "share_hek" 4
.IX Xref "share_hek"
.IX Item "share_hek"
.IP "si_dup" 4
.IX Xref "si_dup"
.IX Item "si_dup"
.IP "ss_dup" 4
.IX Xref "ss_dup"
.IX Item "ss_dup"
.IP "stack_grow" 4
.IX Xref "stack_grow"
.IX Item "stack_grow"
.IP "start_subparse" 4
.IX Xref "start_subparse"
.IX Item "start_subparse"
.IP "str_to_version" 4
.IX Xref "str_to_version"
.IX Item "str_to_version"
.IP "sv_2iv" 4
.IX Xref "sv_2iv"
.IX Item "sv_2iv"
.IP "sv_2pv" 4
.IX Xref "sv_2pv"
.IX Item "sv_2pv"
.IP "sv_2uv" 4
.IX Xref "sv_2uv"
.IX Item "sv_2uv"
.IP "sv_catpvf_mg_nocontext" 4
.IX Xref "sv_catpvf_mg_nocontext"
.IX Item "sv_catpvf_mg_nocontext"
.IP "sv_catpvf_nocontext" 4
.IX Xref "sv_catpvf_nocontext"
.IX Item "sv_catpvf_nocontext"
.IP "sv_dump" 4
.IX Xref "sv_dump"
.IX Item "sv_dump"
.IP "sv_dup" 4
.IX Xref "sv_dup"
.IX Item "sv_dup"
.IP "sv_dup_inc" 4
.IX Xref "sv_dup_inc"
.IX Item "sv_dup_inc"
.IP "sv_peek" 4
.IX Xref "sv_peek"
.IX Item "sv_peek"
.IP "sv_pvn_nomg" 4
.IX Xref "sv_pvn_nomg"
.IX Item "sv_pvn_nomg"
.IP "sv_setpvf_mg_nocontext" 4
.IX Xref "sv_setpvf_mg_nocontext"
.IX Item "sv_setpvf_mg_nocontext"
.IP "sv_setpvf_nocontext" 4
.IX Xref "sv_setpvf_nocontext"
.IX Item "sv_setpvf_nocontext"
.IP "sv_utf8_upgrade_flags_grow" 4
.IX Xref "sv_utf8_upgrade_flags_grow"
.IX Item "sv_utf8_upgrade_flags_grow"
.IP "swash_fetch" 4
.IX Xref "swash_fetch"
.IX Item "swash_fetch"
.IP "swash_init" 4
.IX Xref "swash_init"
.IX Item "swash_init"
.IP "sys_init" 4
.IX Xref "sys_init"
.IX Item "sys_init"
.IP "sys_init3" 4
.IX Xref "sys_init3"
.IX Item "sys_init3"
.IP "sys_intern_clear" 4
.IX Xref "sys_intern_clear"
.IX Item "sys_intern_clear"
.IP "sys_intern_dup" 4
.IX Xref "sys_intern_dup"
.IX Item "sys_intern_dup"
.IP "sys_intern_init" 4
.IX Xref "sys_intern_init"
.IX Item "sys_intern_init"
.IP "sys_term" 4
.IX Xref "sys_term"
.IX Item "sys_term"
.IP "taint_env" 4
.IX Xref "taint_env"
.IX Item "taint_env"
.IP "taint_proper" 4
.IX Xref "taint_proper"
.IX Item "taint_proper"
.IP "tmps_grow" 4
.IX Xref "tmps_grow"
.IX Item "tmps_grow"
.IP "unlnk" 4
.IX Xref "unlnk"
.IX Item "unlnk"
.IP "unsharepvn" 4
.IX Xref "unsharepvn"
.IX Item "unsharepvn"
.IP "utf16_to_utf8" 4
.IX Xref "utf16_to_utf8"
.IX Item "utf16_to_utf8"
.IP "utf16_to_utf8_reversed" 4
.IX Xref "utf16_to_utf8_reversed"
.IX Item "utf16_to_utf8_reversed"
.IP "uvchr_to_utf8_flags" 4
.IX Xref "uvchr_to_utf8_flags"
.IX Item "uvchr_to_utf8_flags"
.IP "uvuni_to_utf8" 4
.IX Xref "uvuni_to_utf8"
.IX Item "uvuni_to_utf8"
.IP "vdeb" 4
.IX Xref "vdeb"
.IX Item "vdeb"
.IP "vform" 4
.IX Xref "vform"
.IX Item "vform"
.IP "vload_module" 4
.IX Xref "vload_module"
.IX Item "vload_module"
.IP "vnewSVpvf" 4
.IX Xref "vnewSVpvf"
.IX Item "vnewSVpvf"
.IP "vwarner" 4
.IX Xref "vwarner"
.IX Item "vwarner"
.IP "warn_nocontext" 4
.IX Xref "warn_nocontext"
.IX Item "warn_nocontext"
.IP "warner" 4
.IX Xref "warner"
.IX Item "warner"
.IP "warner_nocontext" 4
.IX Xref "warner_nocontext"
.IX Item "warner_nocontext"
.IP "whichsig" 4
.IX Xref "whichsig"
.IX Item "whichsig"
.IP "whichsig_pv" 4
.IX Xref "whichsig_pv"
.IX Item "whichsig_pv"
.IP "whichsig_pvn" 4
.IX Xref "whichsig_pvn"
.IX Item "whichsig_pvn"
.IP "whichsig_sv" 4
.IX Xref "whichsig_sv"
.IX Item "whichsig_sv"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Until May 1997, dis document was maintained by Jeff Okamoto
<okamoto@corp.hp.com>.  It be now maintained as part of Perl itself.
.PP
With fuckin shitloadz of help n' suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Pizzle Hudson, Ilya Zakharevich, Pizzle Marquess, Neil
Bowers, Matthew Green, Slim Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, n' Gurusamy Sarathy.
.PP
\&\s-1API\s0 Listin originally by Dean Roehrich <roehrich@cray.com>.
.PP
Updated ta be autogenerated from comments up in tha source by Benjamin Stuhl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, perlxs, perlxstut, perlintern
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 8556:" 4
.IX Item "Around line 8556:"
Unterminated C<...> sequence
