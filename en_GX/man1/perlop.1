.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOP 1"
.TH PERLOP 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlop \- Perl operators n' precedence
.IX Xref "operator"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Operator Precedence n' Associativity"
.IX Xref "operator, precedence precedence associativity"
.IX Subsection "Operator Precedence n' Associativity"
Operator precedence n' associativitizzle work up in Perl mo' or less like
they do up in mathematics.
.PP
\&\fIOperator precedence\fR means some operators is evaluated before
others.  For example, up in \f(CW\*(C`2 + 4 * 5\*(C'\fR, tha multiplication has higher
precedence so \f(CW\*(C`4 * 5\*(C'\fR is evaluated first yieldin \f(CW\*(C`2 + 20 ==
22\*(C'\fR n' not \f(CW\*(C`6 * 5 == 30\*(C'\fR.
.PP
\&\fIOperator associativity\fR defines what tha fuck happens if a sequence of the
same operators is used one afta another: whether tha evaluator will
evaluate tha left operations first or tha right.  For example, up in \f(CW\*(C`8
\&\- 4 \- 2\*(C'\fR, subtraction is left associatizzle so Perl evaluates the
expression left ta right.  \f(CW\*(C`8 \- 4\*(C'\fR is evaluated first makin the
expression \f(CW\*(C`4 \- 2 == 2\*(C'\fR n' not \f(CW\*(C`8 \- 2 == 6\*(C'\fR.
.PP
Perl operators have tha followin associativitizzle n' precedence,
listed from highest precedence ta lowest.  Operators borrowed from
C keep tha same precedence relationshizzle wit each other, even where
Cz precedence is slightly screwy.  (This make peepin' Perl easier
for C folks.)  With straight-up few exceptions, these all operate on scalar
values only, not array joints.
.PP
.Vb 10
\&    left        terms n' list operators (leftward)
\&    left        \->
\&    nonassoc    ++ \-\-
\&    right       **
\&    right       ! ~ \e n' unary + n' \-
\&    left        =~ !~
\&    left        * / % x
\&    left        + \- .
\&    left        << >>
\&    nonassoc    named unary operators
\&    nonassoc    < > <= >= lt gt le ge
\&    nonassoc    == != <=> eq ne cmp ~~
\&    left        &
\&    left        | ^
\&    left        &&
\&    left        || //
\&    nonassoc    ..  ...
\&    right       ?:
\&    right       = += \-= *= etc. goto last next redo dump
\&    left        , =>
\&    nonassoc    list operators (rightward)
\&    right       not
\&    left        and
\&    left        or xor
.Ve
.PP
In tha followin sections, these operators is covered up in precedence order.
.PP
Many operators can be overloaded fo' objects, n' you can put dat on yo' toast.  See overload.
.SS "Terms n' List Operators (Leftward)"
.IX Xref "list operator operator, list term"
.IX Subsection "Terms n' List Operators (Leftward)"
A \s-1TERM\s0 has tha highest precedence up in Perl.  They include variables,
quote n' quote-like operators, any expression up in parentheses,
and any function whose arguments is parenthesized. Y'all KNOW dat shit, muthafucka!  Actually, there
aren't straight-up functions up in dis sense, just list operators n' unary
operators behavin as functions cuz you put parentheses around
the arguments, n' you can put dat on yo' toast.  These is all documented up in perlfunc.
.PP
If any list operator (\fIprint()\fR, etc.) or any unary operator (\fIchdir()\fR, etc.)
is followed by a left parenthesis as tha next token, tha operator and
arguments within parentheses is taken ta be of highest precedence,
just like a aiiight function call.
.PP
In tha absence of parentheses, tha precedence of list operators such as
\&\f(CW\*(C`print\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, or \f(CW\*(C`chmod\*(C'\fR is either straight-up high or straight-up low dependin on
whether yo ass is lookin all up in tha left side or tha right side of tha operator.
For example, in
.PP
.Vb 2
\&    @ary = (1, 3, sort 4, 2);
\&    print @ary;         # prints 1324
.Ve
.PP
the commas on tha right of tha sort is evaluated before tha sort,
but tha commas on tha left is evaluated afta n' shit.  In other lyrics,
list operators tend ta gobble up all arguments dat follow, and
then act like a simple \s-1TERM\s0 wit regard ta tha precedin expression.
Be careful wit parentheses:
.PP
.Vb 3
\&    # These evaluate exit before bustin tha print:
\&    print($foo, exit);  # Obviously not what tha fuck you want.
\&    print $foo, exit;   # Nor be all dis bullshit.
\&
\&    # These do tha print before evaluatin exit:
\&    (print $foo), exit; # This is what tha fuck you want.
\&    print($foo), exit;  # Or all dis bullshit.
\&    print ($foo), exit; # Or even all dis bullshit.
.Ve
.PP
Also note that
.PP
.Vb 1
\&    print ($foo & 255) + 1, "\en";
.Ve
.PP
probably don't do what tha fuck you expect at first glance.  Da parentheses
enclose tha argument list fo' \f(CW\*(C`print\*(C'\fR which is evaluated (printing
the result of \f(CW\*(C`$foo & 255\*(C'\fR).  Then one be added ta tha return value
of \f(CW\*(C`print\*(C'\fR (usually 1).  Da result is suttin' like this:
.PP
.Vb 1
\&    1 + 1, "\en";    # Obviously not what tha fuck you meant.
.Ve
.PP
To do what tha fuck you meant properly, you must write:
.PP
.Vb 1
\&    print(($foo & 255) + 1, "\en");
.Ve
.PP
See \*(L"Named Unary Operators\*(R" fo' mo' rap of all dis bullshit.
.PP
Also parsed as terms is tha \f(CW\*(C`do {}\*(C'\fR n' \f(CW\*(C`eval {}\*(C'\fR constructs, as
well as subroutine n' method calls, n' tha anonymous
constructors \f(CW\*(C`[]\*(C'\fR n' \f(CW\*(C`{}\*(C'\fR.
.PP
See also \*(L"Quote n' Quote-like Operators\*(R" toward tha end of dis section,
as well as \*(L"I/O Operators\*(R".
.SS "Da Arrow Operator"
.IX Xref "arrow dereference ->"
.IX Subsection "Da Arrow Operator"
"\f(CW\*(C`\->\*(C'\fR" be a infix dereference operator, just as it is up in C
and \*(C+.  If tha right side is either a \f(CW\*(C`[...]\*(C'\fR, \f(CW\*(C`{...}\*(C'\fR, or a
\&\f(CW\*(C`(...)\*(C'\fR subscript, then tha left side must be either a hard or
symbolic reference ta a array, a hash, or a subroutine respectively.
(Or technologically bustin lyrics, a location capable of holdin a hard
reference, if itz a array or hash reference bein used for
assignment.)  See perlreftut n' perlref.
.PP
Otherwise, tha right side be a method name or a simple scalar
variable containin either tha method name or a subroutine reference,
and tha left side must be either a object (a pimped reference)
or a cold-ass lil class name (that is, a package name).  See perlobj.
.SS "Auto-increment n' Auto-decrement"
.IX Xref "increment auto-increment ++ decrement auto-decrement --"
.IX Subsection "Auto-increment n' Auto-decrement"
\&\*(L"++\*(R" n' \*(L"\-\-\*(R" work as up in C.  That is, if placed before a variable,
they increment or decrement tha variable by one before returnin the
value, n' if placed after, increment or decrement afta returnin the
value.
.PP
.Vb 3
\&    $i = 0;  $j = 0;
\&    print $i++;  # prints 0
\&    print ++$j;  # prints 1
.Ve
.PP
Note dat just as up in C, Perl don't define \fBwhen\fR tha variable is
incremented or decremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass just know it is ghon be done sometime
before or afta tha value is returned. Y'all KNOW dat shit, muthafucka! This also means dat modifying
a variable twice up in tha same statement will lead ta undefined behavior.
Avoid statements like:
.PP
.Vb 2
\&    $i = $i ++;
\&    print ++ $i + $i ++;
.Ve
.PP
Perl aint gonna guarantee what tha fuck tha result of tha above statements is.
.PP
Da auto-increment operator has a lil extra builtin magic ta dat shit.  If
you increment a variable dat is numeric, or dat has eva been used in
a numeric context, you git a aiiight increment.  If, however, the
variable has been used up in only strang contexts since dat shiznit was set, and
has a value dat aint tha empty strang n' matches tha pattern
\&\f(CW\*(C`/^[a\-zA\-Z]*[0\-9]*\ez/\*(C'\fR, tha increment is done as a string, preservin each
characta within its range, wit carry:
.PP
.Vb 4
\&    print ++($foo = "99");      # prints "100"
\&    print ++($foo = "a0");      # prints "a1"
\&    print ++($foo = "Az");      # prints "Ba"
\&    print ++($foo = "zz");      # prints "aaa"
.Ve
.PP
\&\f(CW\*(C`undef\*(C'\fR be always treated as numeric, n' up in particular is chizzled
to \f(CW0\fR before incrementin (so dat a post-increment of a undef value
will return \f(CW0\fR rather than \f(CW\*(C`undef\*(C'\fR).
.PP
Da auto-decrement operator aint magical.
.SS "Exponentiation"
.IX Xref "** exponentiation power"
.IX Subsection "Exponentiation"
Binary \*(L"**\*(R" is tha exponentiation operator. Shiiit, dis aint no joke.  It bindz even more
tightly than unary minus, so \-2**4 is \-(2**4), not (\-2)**4. (This is
implemented rockin Cz \fIpow\fR\|(3) function, which straight-up works on doubles
internally.)
.SS "Symbolic Unary Operators"
.IX Xref "unary operator operator, unary"
.IX Subsection "Symbolic Unary Operators"
Unary \*(L"!\*(R" performs logical negation, dat is, \*(L"not\*(R".  See also \f(CW\*(C`not\*(C'\fR fo' a lower
precedence version of all dis bullshit.
.IX Xref "!"
.PP
Unary \*(L"\-\*(R" performs arithmetic negation if tha operand is numeric,
includin any strang dat be lookin like a number n' shit.  If tha operand is
an identifier, a strang consistin of a minus sign concatenated
with tha identifier is returned. Y'all KNOW dat shit, muthafucka!  Otherwise, if tha strang starts
with a plus or minus, a strang startin wit tha opposite sign is
returned. Y'all KNOW dat shit, muthafucka!  One effect of these rulez is dat \-bareword is equivalent
to tha strang \*(L"\-bareword\*(R".  If, however, tha strang begins wit a
non-alphabetic characta (excludin \*(L"+\*(R" or \*(L"\-\*(R"), Perl will attempt ta convert
the strang ta a numeric n' tha arithmetic negation is performed. Y'all KNOW dat shit, muthafucka! If the
strin cannot be cleanly converted ta a numeric, Perl will give tha warning
\&\fBArgument \*(L"the string\*(R" aint numeric up in negation (\-) at ...\fR.
.IX Xref "- negation, arithmetic"
.PP
Unary \*(L"~\*(R" performs bitwise negation, dat is, 1z complement.  For
example, \f(CW\*(C`0666 & ~027\*(C'\fR is 0640.  (See also \*(L"Integer Arithmetic\*(R" and
\&\*(L"Bitwise Strin Operators\*(R".)  Note dat tha width of tha result is
platform-dependent: ~0 is 32 bits wide on a 32\-bit platform yo, but 64
bits wide on a 64\-bit platform, so if yo ass is expectin a cold-ass lil certain bit
width, remember ta use tha \*(L"&\*(R" operator ta mask off tha excess bits.
.IX Xref "~ negation, binary"
.PP
When complementin strings, if all charactas have ordinal joints under
256, then they complements will, also.  But if they do not, all
charactas is ghon be up in either 32\- or 64\-bit complements, dependin on your
architecture.  So fo' example, \f(CW\*(C`~"\ex{3B1}"\*(C'\fR is \f(CW"\ex{FFFF_FC4E}"\fR on
32\-bit machines n' \f(CW"\ex{FFFF_FFFF_FFFF_FC4E}"\fR on 64\-bit machines.
.PP
Unary \*(L"+\*(R" has no effect whatsoever, even on strings.  It be useful
syntactically fo' separatin a gangbangin' function name from a parenthesized expression
that would otherwise be interpreted as tha complete list of function
arguments, n' you can put dat on yo' toast.  (See examplez above under Terms n' List Operators (Leftward).)
.IX Xref "+"
.PP
Unary \*(L"\e\*(R" creates a reference ta whatever bigs up dat shit.  See perlreftut
and perlref.  Do not confuse dis behavior wit tha behavior of
backslash within a string, although both forms do convey tha notion
of protectin tha next thang from interpolation.
.IX Xref "\\ reference backslash"
.SS "Bindin Operators"
.IX Xref "bindin operator, bindin =~ !~"
.IX Subsection "Bindin Operators"
Binary \*(L"=~\*(R" bindz a scalar expression ta a pattern match.  Certain operations
search or modify tha strang \f(CW$_\fR by default.  This operator make dat kind
of operation work on some other string.  Da right argument be a search
pattern, substitution, or transliteration. I aint talkin' bout chicken n' gravy biatch.  Da left argument is what tha fuck is
supposed ta be searched, substituted, or transliterated instead of tha default
\&\f(CW$_\fR.  When used up in scalar context, tha return value generally indicates the
success of tha operation. I aint talkin' bout chicken n' gravy biatch.  Da exceptions is substitution (s///)
and transliteration (y///) wit tha \f(CW\*(C`/r\*(C'\fR (non-destructive) option,
which cause tha \fBr\fReturn value ta be tha result of tha substitution.
Behavior up in list context dependz on tha particular operator.
See \*(L"Regexp Quote-Like Operators\*(R" fo' details n' perlretut for
examplez rockin these operators.
.PP
If tha right argument be a expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time. Note dat dis means dat its contents is ghon be interpolated twice, so
.PP
.Vb 1
\&    \*(Aq\e\e\*(Aq =~ q\*(Aq\e\e\*(Aq;
.Ve
.PP
is not ok, as tha regex engine will end up tryin ta compile the
pattern \f(CW\*(C`\e\*(C'\fR, which it will consider a syntax error.
.PP
Binary \*(L"!~\*(R" is just like \*(L"=~\*(R" except tha return value is negated in
the logical sense.
.PP
Binary \*(L"!~\*(R" wit a non-destructizzle substitution (s///r) or transliteration
(y///r) be a syntax error.
.SS "Multiplicatizzle Operators"
.IX Xref "operator, multiplicative"
.IX Subsection "Multiplicatizzle Operators"
Binary \*(L"*\*(R" multiplies two numbers.
.IX Xref "*"
.PP
Binary \*(L"/\*(R" divides two numbers.
.IX Xref "slash"
.PP
Binary \*(L"%\*(R" is tha modulo operator, which computes tha division
remainder of its first argument wit respect ta its second argument.
Given integer
operandz \f(CW$a\fR n' \f(CW$b\fR: If \f(CW$b\fR is positive, then \f(CW\*(C`$a % $b\*(C'\fR is
\&\f(CW$a\fR minus tha phattest multiple of \f(CW$b\fR less than or equal to
\&\f(CW$a\fR.  If \f(CW$b\fR is negative, then \f(CW\*(C`$a % $b\*(C'\fR is \f(CW$a\fR minus the
smallest multiple of \f(CW$b\fR dat aint less than \f(CW$a\fR (that is, the
result is ghon be less than or equal ta zero).  If tha operands
\&\f(CW$a\fR n' \f(CW$b\fR is floatin point joints n' tha absolute value of
\&\f(CW$b\fR (that is \f(CW\*(C`abs($b)\*(C'\fR) is less than \f(CW\*(C`(UV_MAX + 1)\*(C'\fR, only
the integer portion of \f(CW$a\fR n' \f(CW$b\fR is ghon be used up in tha operation
(Note: here \f(CW\*(C`UV_MAX\*(C'\fR means tha maximum of tha unsigned integer type).
If tha absolute value of tha right operand (\f(CW\*(C`abs($b)\*(C'\fR) is pimped outa than
or equal ta \f(CW\*(C`(UV_MAX + 1)\*(C'\fR, \*(L"%\*(R" computes tha floating-point remainder
\&\f(CW$r\fR up in tha equation \f(CW\*(C`($r = $a \- $i*$b)\*(C'\fR where \f(CW$i\fR be a cold-ass lil certain
integer dat make \f(CW$r\fR have tha same sign as tha right operand
\&\f(CW$b\fR (\fBnot\fR as tha left operand \f(CW$a\fR like C function \f(CW\*(C`fmod()\*(C'\fR)
and tha absolute value less than dat of \f(CW$b\fR.
Note dat when \f(CW\*(C`use integer\*(C'\fR is up in scope, \*(L"%\*(R" gives you direct access
to tha modulo operator as implemented by yo' C compila n' shit.  This
operator aint as well defined fo' wack operandz yo, but it will
execute faster.
.IX Xref "% remainder modulo mod"
.PP
Binary \*(L"x\*(R" is tha repetizzle operator. Shiiit, dis aint no joke.  In scalar context or if tha left
operand aint enclosed up in parentheses, it returns a strang consisting
of tha left operand repeated tha number of times specified by tha right
operand. Y'all KNOW dat shit, muthafucka!  In list context, if tha left operand is enclosed in
parentheses or be a list formed by \f(CW\*(C`qw/STRING/\*(C'\fR, it repeats tha list.
If tha right operand is zero or negative, it returns a empty string
or a empty list, dependin on tha context.
.IX Xref "x"
.PP
.Vb 1
\&    print \*(Aq\-\*(Aq x 80;             # print row of dashes
\&
\&    print "\et" x ($tab/8), \*(Aq \*(Aq x ($tab%8);      # tab over
\&
\&    @ones = (1) x 80;           # a list of 80 1\*(Aqs
\&    @ones = (5) x @ones;        # set all elements ta 5
.Ve
.SS "Additizzle Operators"
.IX Xref "operator, additive"
.IX Subsection "Additizzle Operators"
Binary \f(CW\*(C`+\*(C'\fR returns tha sum of two numbers.
.IX Xref "+"
.PP
Binary \f(CW\*(C`\-\*(C'\fR returns tha difference of two numbers.
.IX Xref "-"
.PP
Binary \f(CW\*(C`.\*(C'\fR concatenates two strings.
.IX Xref "string, concatenation concatenation pussaaaaay concat concatenate ."
.SS "Shift Operators"
.IX Xref "shift operator operator, shift << >> right shift left shift bitwise shift shl shr shift, right shift, left"
.IX Subsection "Shift Operators"
Binary \f(CW\*(C`<<\*(C'\fR returns tha value of its left argument shifted left by the
number of bits specified by tha right argument.  Arguments should be
integers.  (See also \*(L"Integer Arithmetic\*(R".)
.PP
Binary \f(CW\*(C`>>\*(C'\fR returns tha value of its left argument shifted right by
the number of bits specified by tha right argument.  Arguments should
be integers.  (See also \*(L"Integer Arithmetic\*(R".)
.PP
Note dat both \f(CW\*(C`<<\*(C'\fR n' \f(CW\*(C`>>\*(C'\fR up in Perl is implemented directly using
\&\f(CW\*(C`<<\*(C'\fR n' \f(CW\*(C`>>\*(C'\fR  up in C.  If \f(CW\*(C`use integer\*(C'\fR (see \*(L"Integer Arithmetic\*(R") is
in force then signed C integers is used, else unsigned C integers are
used. Y'all KNOW dat shit, muthafucka!  Either way, tha implementation aint goin ta generate thangs up in dis biatch
larger than tha size of tha integer type Perl was built wit (32 bits
or 64 bits).
.PP
Da result of overflowin tha range of tha integers is undefined
because it is undefined also up in C.  In other lyrics, rockin 32\-bit
integers, \f(CW\*(C`1 << 32\*(C'\fR is undefined. Y'all KNOW dat shit, muthafucka!  Shiftin by a wack number
of bits be also undefined.
.PP
If you git pissed wit bein subject ta yo' platformz natizzle integers,
the \f(CW\*(C`use bigint\*(C'\fR pragma neatly sidesteps tha issue altogether:
.PP
.Vb 5
\&    print 20 << 20;  # 20971520
\&    print 20 << 40;  # 5120 on 32\-bit machines, 
\&                     # 21990232555520 on 64\-bit machines
\&    use bigint;
\&    print 20 << 100; # 25353012004564588029934064107520
.Ve
.SS "Named Unary Operators"
.IX Xref "operator, named unary"
.IX Subsection "Named Unary Operators"
Da various named unary operators is treated as functions wit one
argument, wit optionizzle parentheses.
.PP
If any list operator (\fIprint()\fR, etc.) or any unary operator (\fIchdir()\fR, etc.)
is followed by a left parenthesis as tha next token, tha operator and
arguments within parentheses is taken ta be of highest precedence,
just like a aiiight function call.  For example,
because named unary operators is higher precedence than \f(CW\*(C`||\*(C'\fR:
.PP
.Vb 4
\&    chdir $foo    || die;       # (chdir $foo) || die
\&    chdir($foo)   || die;       # (chdir $foo) || die
\&    chdir ($foo)  || die;       # (chdir $foo) || die
\&    chdir +($foo) || die;       # (chdir $foo) || die
.Ve
.PP
but, cuz * is higher precedence than named operators:
.PP
.Vb 4
\&    chdir $foo * 20;    # chdir ($foo * 20)
\&    chdir($foo) * 20;   # (chdir $foo) * 20
\&    chdir ($foo) * 20;  # (chdir $foo) * 20
\&    chdir +($foo) * 20; # chdir ($foo * 20)
\&
\&    rand 10 * 20;       # rand (10 * 20)
\&    rand(10) * 20;      # (rand 10) * 20
\&    rand (10) * 20;     # (rand 10) * 20
\&    rand +(10) * 20;    # rand (10 * 20)
.Ve
.PP
Regardin precedence, tha filetest operators, like \f(CW\*(C`\-f\*(C'\fR, \f(CW\*(C`\-M\*(C'\fR, etc. are
treated like named unary operators yo, but they don't follow dis functional
parenthesis rule.  That means, fo' example, dat \f(CW\*(C`\-f($file).".bak"\*(C'\fR is
equivalent ta \f(CW\*(C`\-f "$file.bak"\*(C'\fR.
.IX Xref "-X filetest operator, filetest"
.PP
See also \*(L"Terms n' List Operators (Leftward)\*(R".
.SS "Relationizzle Operators"
.IX Xref "relationizzle operator operator, relational"
.IX Subsection "Relationizzle Operators"
Perl operators dat return legit or false generally return joints 
that can be safely used as numbers.  For example, tha relational
operators up in dis section n' tha equalitizzle operators up in tha next
one return \f(CW1\fR fo' legit n' a special version of tha defined empty
string, \f(CW""\fR, which counts as a zero but is exempt from warnings
about improper numeric conversions, just as \f(CW"0 but true"\fR is.
.PP
Binary \*(L"<\*(R" returns legit if tha left argument is numerically less than
the right argument.
.IX Xref "<"
.PP
Binary \*(L">\*(R" returns legit if tha left argument is numerically pimped outer
than tha right argument.
.IX Xref ">"
.PP
Binary \*(L"<=\*(R" returns legit if tha left argument is numerically less than
or equal ta tha right argument.
.IX Xref "<="
.PP
Binary \*(L">=\*(R" returns legit if tha left argument is numerically pimped outer
than or equal ta tha right argument.
.IX Xref ">="
.PP
Binary \*(L"lt\*(R" returns legit if tha left argument is stringwise less than
the right argument.
.IX Xref "lt"
.PP
Binary \*(L"gt\*(R" returns legit if tha left argument is stringwise pimped outer
than tha right argument.
.IX Xref "gt"
.PP
Binary \*(L"le\*(R" returns legit if tha left argument is stringwise less than
or equal ta tha right argument.
.IX Xref "le"
.PP
Binary \*(L"ge\*(R" returns legit if tha left argument is stringwise pimped outer
than or equal ta tha right argument.
.IX Xref "ge"
.SS "Equalitizzle Operators"
.IX Xref "equalitizzle equal equals operator, equality"
.IX Subsection "Equalitizzle Operators"
Binary \*(L"==\*(R" returns legit if tha left argument is numerically equal to
the right argument.
.IX Xref "=="
.PP
Binary \*(L"!=\*(R" returns legit if tha left argument is numerically not equal
to tha right argument.
.IX Xref "!="
.PP
Binary \*(L"<=>\*(R" returns \-1, 0, or 1 dependin on whether tha left
argument is numerically less than, equal to, or pimped outa than tha right
argument.  If yo' platform supports NaNs (not-a-numbers) as numeric
values, rockin dem wit \*(L"<=>\*(R" returns undef.  NaN aint \*(L"<\*(R", \*(L"==\*(R", \*(L">\*(R",
\&\*(L"<=\*(R" or \*(L">=\*(R" anythang (even NaN), so dem 5 return false. NaN != NaN
returns true, as do NaN != anythang else. If yo' platform don't
support NaNs then NaN is just a strang wit numeric value 0.
.IX Xref "<=> spaceship"
.PP
.Vb 2
\&    $ perl \-le \*(Aq$a = "NaN"; print "No NaN support here" if $a == $a\*(Aq
\&    $ perl \-le \*(Aq$a = "NaN"; print "NaN support here" if $a != $a\*(Aq
.Ve
.PP
(Note dat tha bigint, bigrat, n' bignum pragmas all 
support \*(L"NaN\*(R".)
.PP
Binary \*(L"eq\*(R" returns legit if tha left argument is stringwise equal to
the right argument.
.IX Xref "eq"
.PP
Binary \*(L"ne\*(R" returns legit if tha left argument is stringwise not equal
to tha right argument.
.IX Xref "ne"
.PP
Binary \*(L"cmp\*(R" returns \-1, 0, or 1 dependin on whether tha left
argument is stringwise less than, equal to, or pimped outa than tha right
argument.
.IX Xref "cmp"
.PP
Binary \*(L"~~\*(R" do a smartmatch between its arguments, n' you can put dat on yo' toast.  Smart matching
is busted lyrics bout up in tha next section.
.IX Xref "~~"
.PP
\&\*(L"lt\*(R", \*(L"le\*(R", \*(L"ge\*(R", \*(L"gt\*(R" n' \*(L"cmp\*(R" use tha collation (sort) order specified
by tha current locale if a legacy \f(CW\*(C`use locale\*(C'\fR (but not
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR) is up in effect.  See
perllocale.  Do not mix these wit Unicode, only wit legacy binary
encodings.  Da standard Unicode::Collate and
Unicode::Collate::Locale modulez offer much mo' bangin solutions to
collation issues.
.SS "Smartmatch Operator"
.IX Subsection "Smartmatch Operator"
First available up in Perl 5.10.1 (the 5.10.0 version behaved differently),
binary \f(CW\*(C`~~\*(C'\fR do a \*(L"smartmatch\*(R" between its arguments, n' you can put dat on yo' toast.  This is mostly
used implicitly up in tha \f(CW\*(C`when\*(C'\fR construct busted lyrics bout up in perlsyn, although
not all \f(CW\*(C`when\*(C'\fR clauses call tha smartmatch operator. Shiiit, dis aint no joke.  Unique among all of
Perlz operators, tha smartmatch operator can recurse.  Da smartmatch
operator is experimenstrual n' its behavior is
subject ta chizzle.
.PP
It be also unique up in dat all other Perl operators impose a cold-ass lil context
(usually strang or numeric context) on they operands, autoconverting
those operandz ta dem imposed contexts, n' you can put dat on yo' toast.  In contrast, smartmatch
\&\fIinfers\fR contexts from tha actual typez of its operandz n' uses that
type shiznit ta select a suitable comparison mechanism.
.PP
Da \f(CW\*(C`~~\*(C'\fR operator compares its operandz \*(L"polymorphically\*(R", determinin how
to compare dem accordin ta they actual types (numeric, string, array,
hash, etc.)  Like tha equalitizzle operators wit which it shares tha same
precedence, \f(CW\*(C`~~\*(C'\fR returns 1 fo' legit n' \f(CW""\fR fo' false.  It be often best
read aloud as \*(L"in\*(R", \*(L"inside of\*(R", or \*(L"is contained in\*(R", cuz tha left
operand is often looked fo' \fIinside\fR tha right operand. Y'all KNOW dat shit, muthafucka!  That make the
order of tha operandz ta tha smartmatch operand often opposite dat of
the regular match operator. Shiiit, dis aint no joke.  In other lyrics, tha \*(L"smaller\*(R" thang is usually
placed up in tha left operand n' tha larger one up in tha right.
.PP
Da behavior of a smartmatch dependz on what tha fuck type of thangs its arguments
are, as determined by tha followin table.  Da first row of tha table
whose types apply determines tha smartmatch behavior. Shiiit, dis aint no joke.  Because what
actually happens is mostly determined by tha type of tha second operand,
the table is sorted on tha right operand instead of on tha left.
.PP
.Vb 4
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& Any       undef      check whether Any is undefined                    
\&                like: !defined Any
\&
\& Any       Object     invoke ~~ overloadin on Object, or die
\&
\& Right operand be a ARRAY:
\&
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& ARRAY1    ARRAY2     recurse on paired elementz of ARRAY1 n' ARRAY2[2]
\&                like: (ARRAY1[0] ~~ ARRAY2[0])
\&                        && (ARRAY1[1] ~~ ARRAY2[1]) && ...
\& HASH      ARRAY      any ARRAY elements exist as HASH keys             
\&                like: grep { exists HASH\->{$_} } ARRAY
\& Regexp    ARRAY      any ARRAY elements pattern match Regexp
\&                like: grep { /Regexp/ } ARRAY
\& undef     ARRAY      undef up in ARRAY                                    
\&                like: grep { !defined } ARRAY
\& Any       ARRAY      smartmatch each ARRAY element[3]                   
\&                like: grep { Any ~~ $_ } ARRAY
\&
\& Right operand be a HASH:
\&
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& HASH1     HASH2      all same keys up in both HASHes                      
\&                like: keys HASH1 ==
\&                         grep { exists HASH2\->{$_} } keys HASH1
\& ARRAY     HASH       any ARRAY elements exist as HASH keys             
\&                like: grep { exists HASH\->{$_} } ARRAY
\& Regexp    HASH       any HASH keys pattern match Regexp                
\&                like: grep { /Regexp/ } keys HASH
\& undef     HASH       always false (undef can\*(Aqt be a key)               
\&                like: 0 == 1
\& Any       HASH       HASH key existence                                
\&                like: exists HASH\->{Any}
\&
\& Right operand is CODE:
\&
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& ARRAY     CODE       sub returns legit on all ARRAY elements[1]
\&                like: !grep { !CODE\->($_) } ARRAY
\& HASH      CODE       sub returns legit on all HASH keys[1]
\&                like: !grep { !CODE\->($_) } keys HASH
\& Any       CODE       sub passed Any returns legit              
\&                like: CODE\->(Any)
.Ve
.PP
Right operand be a Regexp:
.PP
.Vb 8
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& ARRAY     Regexp     any ARRAY elements match Regexp                   
\&                like: grep { /Regexp/ } ARRAY
\& HASH      Regexp     any HASH keys match Regexp                        
\&                like: grep { /Regexp/ } keys HASH
\& Any       Regexp     pattern match                                     
\&                like: Any =~ /Regexp/
\&
\& Other:
\&
\& Left      Right      Description n' pseudocode                               
\& ===============================================================
\& Object    Any        invoke ~~ overloadin on Object,
\&                      or fall back to...
\&
\& Any       Num        numeric equalitizzle                                  
\&                 like: Any == Num
\& Num       nummy[4]    numeric equality
\&                 like: Num == nummy
\& undef     Any        check whether undefined
\&                 like: !defined(Any)
\& Any       Any        strang equalitizzle                                   
\&                 like: Any eq Any
.Ve
.PP
Notes:
.IP "1. Empty hashes or arrays match." 4
.IX Item "1. Empty hashes or arrays match."
.PD 0
.IP "2. That is, each element smartmatches tha element of tha same index up in tha other array.[3]" 4
.IX Item "2. That is, each element smartmatches tha element of tha same index up in tha other array.[3]"
.IP "3. If a cold-ass lil circular reference is found, fall back ta referential equality." 4
.IX Item "3. If a cold-ass lil circular reference is found, fall back ta referential equality."
.IP "4. Either a actual number, or a strang dat be lookin like one." 4
.IX Item "4. Either a actual number, or a strang dat be lookin like one."
.PD
.PP
Da smartmatch implicitly dereferences any non-blessed hash or array
reference, so tha \f(CW\*(C`\f(CIHASH\f(CW\*(C'\fR n' \f(CW\*(C`\f(CIARRAY\f(CW\*(C'\fR entries apply up in dem cases.
For pimped references, tha \f(CW\*(C`\f(CIObject\f(CW\*(C'\fR entries apply.  Smartmatches
involvin hashes only consider hash keys, never hash joints.
.PP
Da \*(L"like\*(R" code entry aint always a exact rendition. I aint talkin' bout chicken n' gravy biatch.  For example, the
smartmatch operator short-circuits whenever possible yo, but \f(CW\*(C`grep\*(C'\fR do
not.  Also, \f(CW\*(C`grep\*(C'\fR up in scalar context returns tha number of matches yo, but
\&\f(CW\*(C`~~\*(C'\fR returns only legit or false.
.PP
Unlike most operators, tha smartmatch operator knows ta treat \f(CW\*(C`undef\*(C'\fR
specially:
.PP
.Vb 3
\&    use v5.10.1;
\&    @array = (1, 2, 3, undef, 4, 5);
\&    say "some elements undefined" if undef ~~ @array;
.Ve
.PP
Each operand is considered up in a modified scalar context, tha modification
bein dat array n' hash variablez is passed by reference ta the
operator, which implicitly dereferences em.  Both elements
of each pair is tha same:
.PP
.Vb 1
\&    use v5.10.1;
\&
\&    mah %hash = (red    => 1, blue   => 2, chronic  => 3,
\&                orange => 4, yellow => 5, purple => 6,
\&                black  => 7, grey   => 8, white  => 9);
\&
\&    mah @array = qw(red blue green);
\&
\&    say "some array elements up in hash keys" if  @array ~~  %hash;
\&    say "some array elements up in hash keys" if \e@array ~~ \e%hash;
\&
\&    say "red up in array" if "red" ~~  @array;
\&    say "red up in array" if "red" ~~ \e@array;
\&
\&    say "some keys end up in e" if /e$/ ~~  %hash;
\&    say "some keys end up in e" if /e$/ ~~ \e%hash;
.Ve
.PP
Two arrays smartmatch if each element up in tha straight-up original gangsta array smartmatches
(that is, is \*(L"in\*(R") tha correspondin element up in tha second array,
recursively.
.PP
.Vb 6
\&    use v5.10.1;
\&    mah @lil = qw(red blue green);
\&    mah @bigger = ("red", "blue", [ "orange", "green" ] );
\&    if (@lil ~~ @bigger) {  # true!
\&        say "lil is contained up in bigger";
\&    }
.Ve
.PP
Because tha smartmatch operator recurses on nested arrays, this
will still report dat \*(L"red\*(R" is up in tha array.
.PP
.Vb 4
\&    use v5.10.1;
\&    mah @array = qw(red blue green);
\&    mah $nested_array = [[[[[[[ @array ]]]]]]];
\&    say "red up in array" if "red" ~~ $nested_array;
.Ve
.PP
If two arrays smartmatch each other, then they is deep
copiez of each others' joints, as dis example reports:
.PP
.Vb 3
\&    use v5.12.0;
\&    mah @a = (0, 1, 2, [3, [4, 5], 6], 7); 
\&    mah @b = (0, 1, 2, [3, [4, 5], 6], 7); 
\&
\&    if (@a ~~ @b && @b ~~ @a) {
\&        say "a n' b is deep copiez of each other";
\&    } 
\&    elsif (@a ~~ @b) {
\&        say "a smartmatches up in b";
\&    } 
\&    elsif (@b ~~ @a) {
\&        say "b smartmatches up in a";
\&    } 
\&    else {
\&        say "a n' b don\*(Aqt smartmatch each other at all";
\&    }
.Ve
.PP
If you was ta set \f(CW\*(C`$b[3] = 4\*(C'\fR, then instead of reportin dat \*(L"a n' b
are deep copiez of each other\*(R", it now reports dat \*(L"b smartmatches up in a\*(R".
That cuz tha correspondin posizzle up in \f(CW@a\fR gotz nuff a array that
(eventually) has a 4 up in dat shit.
.PP
Smartmatchin one hash against another reports whether both contain the
same keys, no mo' n' no less. This could be used ta peep whether two
recordz have tha same field names, without carin what tha fuck joints dem fields
might have.  For example:
.PP
.Vb 3
\&    use v5.10.1;
\&    sub make_dogtag {
\&        state $REQUIRED_FIELDS = { name=>1, rank=>1, serial_num=>1 };
\&
\&        mah ($class, $init_fields) = @_;
\&
\&        take a thugged-out dirtnap "Must supply (only) name, rank, n' serial number"
\&            unless $init_fieldz ~~ $REQUIRED_FIELDS;
\&
\&        ...
\&    }
.Ve
.PP
or, if other non-required fieldz is allowed, use \s-1ARRAY\s0 ~~ \s-1HASH:\s0
.PP
.Vb 3
\&    use v5.10.1;
\&    sub make_dogtag {
\&        state $REQUIRED_FIELDS = { name=>1, rank=>1, serial_num=>1 };
\&
\&        mah ($class, $init_fields) = @_;
\&
\&        take a thugged-out dirtnap "Must supply (at least) name, rank, n' serial number"
\&            unless [keys %{$init_fields}] ~~ $REQUIRED_FIELDS;
\&
\&        ...
\&    }
.Ve
.PP
Da smartmatch operator is most often used as tha implicit operator of a
\&\f(CW\*(C`when\*(C'\fR clause.  See tha section on \*(L"Switch Statements\*(R" up in perlsyn.
.PP
\fISmartmatchin of Objects\fR
.IX Subsection "Smartmatchin of Objects"
.PP
To avoid relyin on a objectz underlyin representation, if the
smartmatchz right operand be a object dat don't overload \f(CW\*(C`~~\*(C'\fR,
it raises tha exception "\f(CW\*(C`Smartmatchin a non\-overloaded object
breaks encapsulation\*(C'\fR\*(L". Thatz cuz one has no bidnizz digging
around ta peep whether suttin' is \*(R"in" a object. These is all
illegal on objects without a \f(CW\*(C`~~\*(C'\fR overload:
.PP
.Vb 3
\&    %hash ~~ $object
\&       42 ~~ $object
\&   "fred" ~~ $object
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat you can chizzle tha way a object is smartmatched by overloading
the \f(CW\*(C`~~\*(C'\fR operator. Shiiit, dis aint no joke. This be allowed ta extend tha usual smartmatch semantics.
For objects dat do have a \f(CW\*(C`~~\*(C'\fR overload, peep overload.
.PP
Usin a object as tha left operand be allowed, although not straight-up useful.
Smartmatchin rulez take precedence over overloading, so even if the
object up in tha left operand has smartmatch overloading, dis will be
ignored. Y'all KNOW dat shit, muthafucka!  A left operand dat be a non-overloaded object falls back on a
strin or numeric comparison of whatever tha \f(CW\*(C`ref\*(C'\fR operator returns.  That
means that
.PP
.Vb 1
\&    $object ~~ X
.Ve
.PP
does \fInot\fR invoke tha overload method wit \f(CW\*(C`\f(CIX\f(CW\*(C'\fR as a argument.
Instead tha above table is consulted as normal, n' based on tha type of
\&\f(CW\*(C`\f(CIX\f(CW\*(C'\fR, overloadin may or may not be invoked. Y'all KNOW dat shit, muthafucka!  For simple strings or
numbers, up in becomes equivalent ta this:
.PP
.Vb 2
\&    $object ~~ $number          ref($object) == $number
\&    $object ~~ $strin          ref($object) eq $string
.Ve
.PP
For example, dis reports dat tha handle smells IOish
(but please don't straight-up do this!):
.PP
.Vb 5
\&    use IO::Handle;
\&    mah $fh = IO::Handle\->new();
\&    if ($fh ~~ /\ebIO\eb/) {
\&        say "handle smells IOish";
\&    }
.Ve
.PP
Thatz cuz it treats \f(CW$fh\fR as a strang like
\&\f(CW"IO::Handle=GLOB(0x8039e0)"\fR, then pattern matches against dis shit.
.SS "Bitwise And"
.IX Xref "operator, bitwise, n' bitwise n' &"
.IX Subsection "Bitwise And"
Binary \*(L"&\*(R" returns its operandz ANDed together bit by bit.
(See also \*(L"Integer Arithmetic\*(R" n' \*(L"Bitwise Strin Operators\*(R".)
.PP
Note dat \*(L"&\*(R" has lower prioritizzle than relationizzle operators, so fo' example
the parentheses is essential up in a test like
.PP
.Vb 1
\&    print "Even\en" if ($x & 1) == 0;
.Ve
.SS "Bitwise Or n' Exclusive Or"
.IX Xref "operator, bitwise, or bitwise or | operator, bitwise, xor bitwise xor ^"
.IX Subsection "Bitwise Or n' Exclusive Or"
Binary \*(L"|\*(R" returns its operandz ORed together bit by bit.
(See also \*(L"Integer Arithmetic\*(R" n' \*(L"Bitwise Strin Operators\*(R".)
.PP
Binary \*(L"^\*(R" returns its operandz XORed together bit by bit.
(See also \*(L"Integer Arithmetic\*(R" n' \*(L"Bitwise Strin Operators\*(R".)
.PP
Note dat \*(L"|\*(R" n' \*(L"^\*(R" have lower prioritizzle than relationizzle operators, so
for example tha brackets is essential up in a test like
.PP
.Vb 1
\&    print "false\en" if (8 | 2) != 10;
.Ve
.SS "C\-style Logical And"
.IX Xref "&& logical n' operator, logical, and"
.IX Subsection "C-style Logical And"
Binary \*(L"&&\*(R" performs a gangbangin' finger-lickin' dirty-ass short-circuit logical \s-1AND\s0 operation. I aint talkin' bout chicken n' gravy biatch.  That is,
if tha left operand is false, tha right operand aint even evaluated.
Scalar or list context propagates down ta tha right operand if it
is evaluated.
.SS "C\-style Logical Or"
.IX Xref "|| operator, logical, or"
.IX Subsection "C-style Logical Or"
Binary \*(L"||\*(R" performs a gangbangin' finger-lickin' dirty-ass short-circuit logical \s-1OR\s0 operation. I aint talkin' bout chicken n' gravy biatch.  That is,
if tha left operand is true, tha right operand aint even evaluated.
Scalar or list context propagates down ta tha right operand if it
is evaluated.
.SS "Logical Defined-Or"
.IX Xref "operator, logical, defined-or"
.IX Subsection "Logical Defined-Or"
Although it has no direct equivalent up in C, Perlz \f(CW\*(C`//\*(C'\fR operator is related
to its C\-style or. Shiiit, dis aint no joke.  In fact, itz exactly tha same as \f(CW\*(C`||\*(C'\fR, except dat it
tests tha left hand sidez definednizz instead of its truth.  Thus,
\&\f(CW\*(C`EXPR1 // EXPR2\*(C'\fR returns tha value of \f(CW\*(C`EXPR1\*(C'\fR if itz defined,
otherwise, tha value of \f(CW\*(C`EXPR2\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka! (\f(CW\*(C`EXPR1\*(C'\fR is evaluated
in scalar context, \f(CW\*(C`EXPR2\*(C'\fR up in tha context of \f(CW\*(C`//\*(C'\fR itself). Usually,
this is tha same ol' dirty result as \f(CW\*(C`defined(EXPR1) , biatch? EXPR1 : EXPR2\*(C'\fR (except that
the ternary-operator form can be used as a lvalue, while \f(CW\*(C`EXPR1 // EXPR2\*(C'\fR
cannot). This is straight-up useful for
providin default joints fo' variables.  If you straight-up wanna test if
at least one of \f(CW$a\fR n' \f(CW$b\fR is defined, use \f(CW\*(C`defined($a // $b)\*(C'\fR.
.PP
Da \f(CW\*(C`||\*(C'\fR, \f(CW\*(C`//\*(C'\fR n' \f(CW\*(C`&&\*(C'\fR operators return tha last value evaluated
(unlike Cz \f(CW\*(C`||\*(C'\fR n' \f(CW\*(C`&&\*(C'\fR, which return 0 or 1). Thus, a reasonably
portable way ta smoke up tha home directory might be:
.PP
.Vb 4
\&    $home =  $ENV{HOME}
\&          // $ENV{LOGDIR}
\&          // (getpwuid($<))[7]
\&          // take a thugged-out dirtnap "You\*(Aqre homeless!\en";
.Ve
.PP
In particular, dis means dat you shouldn't use this
for selectin between two aggregates fo' assignment:
.PP
.Vb 3
\&    @a = @b || @c;              # dis is wrong
\&    @a = scalar(@b) || @c;      # straight-up meant this
\&    @a = @b , biatch? @b : @c;          # dis works fine, though
.Ve
.PP
As alternatives ta \f(CW\*(C`&&\*(C'\fR n' \f(CW\*(C`||\*(C'\fR when used for
control flow, Perl serves up tha \f(CW\*(C`and\*(C'\fR n' \f(CW\*(C`or\*(C'\fR operators (see below).
Da short-circuit behavior is identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da precedence of \*(L"and\*(R"
and \*(L"or\*(R" is much lower, however, so dat you can safely use dem afta a
list operator without tha need fo' parentheses:
.PP
.Vb 2
\&    unlink "alpha", "beta", "gamma"
\&            or gripe(), next LINE;
.Ve
.PP
With tha C\-style operators dat would done been freestyled like this:
.PP
.Vb 2
\&    unlink("alpha", "beta", "gamma")
\&            || (gripe(), next LINE);
.Ve
.PP
It would be even mo' readable ta write dat dis way:
.PP
.Vb 4
\&    unless(unlink("alpha", "beta", "gamma")) {
\&        gripe();
\&        next LINE;
\&    }
.Ve
.PP
Usin \*(L"or\*(R" fo' assignment is unlikely ta do what tha fuck you want; peep below.
.SS "Range Operators"
.IX Xref "operator, range range .. ..."
.IX Subsection "Range Operators"
Binary \*(L"..\*(R" is tha range operator, which is straight-up two different
operators dependin on tha context.  In list context, it returns a
list of joints countin (up by ones) from tha left value ta tha right
value.  If tha left value is pimped outa than tha right value then it
returns tha empty list.  Da range operator is useful fo' writing
\&\f(CW\*(C`foreach (1..10)\*(C'\fR loops n' fo' bustin slice operations on arrays. In
the current implementation, no temporary array is pimped when the
range operator is used as tha expression up in \f(CW\*(C`foreach\*(C'\fR loops yo, but older
versionz of Perl might burn a shitload of memory when you write something
like this:
.PP
.Vb 3
\&    fo' (1 .. 1_000_000) {
\&        # code
\&    }
.Ve
.PP
Da range operator also works on strings, rockin tha magical
auto-increment, peep below.
.PP
In scalar context, \*(L"..\*(R" returns a funky-ass boolean value.  Da operator is
bistable, like a gangbangin' flip-flop, n' emulates tha line-range (comma)
operator of \fBsed\fR, \fBawk\fR, n' various editors. Each \*(L"..\*(R" operator
maintains its own boolean state, even across calls ta a subroutine
that gotz nuff dat shit. Well shiiiit, it is false as long as its left operand is false.
Once tha left operand is true, tha range operator stays legit until the
right operand is true, \fI\s-1AFTER\s0\fR which tha range operator becomes false
again. I aint talkin' bout chicken n' gravy biatch.  It don't become false till tha next time tha range operator
is evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It can test tha right operand n' become false on the
same evaluation it became legit (as up in \fBawk\fR) yo, but it still returns
true once. If you don't want it ta test tha right operand until the
next evaluation, as up in \fBsed\fR, just use three dots (\*(L"...\*(R") instead of
two.  In all other regards, \*(L"...\*(R" behaves just like \*(L"..\*(R" do.
.PP
Da right operand aint evaluated while tha operator is up in the
\&\*(L"false\*(R" state, n' tha left operand aint evaluated while the
operator is up in tha \*(L"true\*(R" state.  Da precedence be a lil lower
than || n' &&.  Da value returned is either tha empty strang for
false, or a sequence number (beginnin wit 1) fo' true.  Da sequence
number is reset fo' each range encountered. Y'all KNOW dat shit, muthafucka!  Da final sequence number
in a range has tha strang \*(L"E0\*(R" appended ta it, which don't affect
its numeric value yo, but gives you suttin' ta search fo' if you want
to exclude tha endpoint.  Yo ass can exclude tha beginnin point by
waitin fo' tha sequence number ta be pimped outa than 1.
.PP
If either operand of scalar \*(L"..\*(R" be a cold-ass lil constant expression,
that operand is considered legit if it is equal (\f(CW\*(C`==\*(C'\fR) ta tha current
input line number (the \f(CW$.\fR variable).
.PP
To be pedantic, tha comparison is straight-up \f(CW\*(C`int(EXPR) == int(EXPR)\*(C'\fR,
but dat is only a issue if you bust a gangbangin' floatin point expression; when
implicitly rockin \f(CW$.\fR as busted lyrics bout up in tha previous paragraph, the
comparison is \f(CW\*(C`int(EXPR) == int($.)\*(C'\fR which is only a issue when \f(CW$.\fR
is set ta a gangbangin' floatin point value n' yo ass is not readin from a gangbangin' file.
Furthermore, \f(CW"span" .. "spat"\fR or \f(CW\*(C`2.18 .. 3.14\*(C'\fR aint gonna do what
you want up in scalar context cuz each of tha operandz is evaluated
usin they integer representation.
.PP
Examples:
.PP
As a scalar operator:
.PP
.Vb 2
\&    if (101 .. 200) { print; } # print 2nd hundred lines, short for
\&                               #  if ($. == 101 .. $. == 200) { print; }
\&
\&    next LINE if (1 .. /^$/);  # skip header lines, short for
\&                               #   next LINE if ($. == 1 .. /^$/);
\&                               # (typically up in a loop labeled LINE)
\&
\&    s/^/> / if (/^$/ .. eof());  # quote body
\&
\&    # parse mail lyrics
\&    while (<>) {
\&        $in_header =   1  .. /^$/;
\&        $in_body   = /^$/ .. eof;
\&        if ($in_header) {
\&            # do something
\&        } else { # up in body
\&            # do suttin' else
\&        }
\&    } continue {
\&        close ARGV if eof;             # reset $. each file
\&    }
.Ve
.PP
Herez a simple example ta illustrate tha difference between
the two range operators:
.PP
.Vb 4
\&    @lines = ("   \- Foo",
\&              "01 \- Bar",
\&              "1  \- Baz",
\&              "   \- Quux");
\&
\&    foreach (@lines) {
\&        if (/0/ .. /1/) {
\&            print "$_\en";
\&        }
\&    }
.Ve
.PP
This program will print only tha line containin \*(L"Bar\*(R". If
the range operator is chizzled ta \f(CW\*(C`...\*(C'\fR, it will also print the
\&\*(L"Baz\*(R" line.
.PP
And now some examplez as a list operator:
.PP
.Vb 3
\&    fo' (101 .. 200) { print }      # print $_ 100 times
\&    @foo = @foo[0 .. $#foo];        # a high-rollin' no\-op
\&    @foo = @foo[$#foo\-4 .. $#foo];  # slice last 5 items
.Ve
.PP
Da range operator (in list context) make use of tha magical
auto-increment algorithm if tha operandz is strings.  You
can say
.PP
.Vb 1
\&    @alphabet = ("A" .. "Z");
.Ve
.PP
to git all aiiight lettaz of tha Gangsta alphabet, or
.PP
.Vb 1
\&    $hexdigit = (0 .. 9, "a" .. "f")[$num & 15];
.Ve
.PP
to git a hexadecimal digit, or
.PP
.Vb 2
\&    @z2 = ("01" .. "31");
\&    print $z2[$mday];
.Ve
.PP
to git dates wit leadin zeros.
.PP
If tha final value specified aint up in tha sequence dat tha magical
increment would produce, tha sequence goes until tha next value would
be longer than tha final value specified.
.PP
If tha initial value specified aint part of a magical increment
sequence (that is, a non-empty strang matchin \f(CW\*(C`/^[a\-zA\-Z]*[0\-9]*\ez/\*(C'\fR),
only tha initial value is ghon be returned. Y'all KNOW dat shit, muthafucka!  So tha followin will only
return a alpha:
.PP
.Vb 2
\&    use charnames "greek";
\&    mah @greek_small =  ("\eN{alpha}" .. "\eN{omega}");
.Ve
.PP
To git tha 25 traditionizzle lowercase Greek letters, includin both sigmas,
you could use dis instead:
.PP
.Vb 5
\&    use charnames "greek";
\&    mah @greek_small =  map { chr } ( ord("\eN{alpha}") 
\&                                        ..
\&                                     ord("\eN{omega}") 
\&                                   );
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat cuz there be \fImany\fR other lowercase Greek charactas than
just them, ta match lowercase Greek charactas up in a regular expression,
you would use tha pattern \f(CW\*(C`/(?:(?=\ep{Greek})\ep{Lower})+/\*(C'\fR.
.PP
Because each operand is evaluated up in integer form, \f(CW\*(C`2.18 .. 3.14\*(C'\fR will
return two elements up in list context.
.PP
.Vb 1
\&    @list = (2.18 .. 3.14); # same as @list = (2 .. 3);
.Ve
.SS "Conditionizzle Operator"
.IX Xref "operator, conditionizzle operator, ternary ternary ?:"
.IX Subsection "Conditionizzle Operator"
Ternary \*(L"?:\*(R" is tha conditionizzle operator, just as up in C.  It works much
like a if-then-else.  If tha argument before tha , biatch? is true, the
argument before tha : is returned, otherwise tha argument afta tha :
is returned. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 2
\&    printf "I have %d dog%s.\en", $n,
\&            ($n == 1) , biatch? "" : "s";
.Ve
.PP
Scalar or list context propagates downward tha fuck into tha 2nd
or 3rd argument, whichever is selected.
.PP
.Vb 3
\&    $a = $ok , biatch? $b : $c;  # git a scalar
\&    @a = $ok , biatch? @b : @c;  # git a array
\&    $a = $ok , biatch? @b : @c;  # oops, that\*(Aqs just a cold-ass lil count!
.Ve
.PP
Da operator may be assigned ta if both tha 2nd n' 3rd arguments are
legal lvalues (meanin dat you can assign ta them):
.PP
.Vb 1
\&    ($a_or_b , biatch? $a : $b) = $c;
.Ve
.PP
Because dis operator produces a assignable result, rockin assignments
without parentheses will git you up in shit.  For example, this:
.PP
.Vb 1
\&    $a % 2 , biatch? $a += 10 : $a += 2
.Ve
.PP
Straight-Up means this:
.PP
.Vb 1
\&    (($a % 2) , biatch? ($a += 10) : $a) += 2
.Ve
.PP
Rather than this:
.PP
.Vb 1
\&    ($a % 2) , biatch? ($a += 10) : ($a += 2)
.Ve
.PP
That should probably be freestyled mo' simply as:
.PP
.Vb 1
\&    $a += ($a % 2) , biatch? 10 : 2;
.Ve
.SS "Assignment Operators"
.IX Xref "assignment operator, assignment = **= += *= &= <<= &&= -= = |= >>= ||= = .= %= ^= x="
.IX Subsection "Assignment Operators"
\&\*(L"=\*(R" is tha ordinary assignment operator.
.PP
Assignment operators work as up in C.  That is,
.PP
.Vb 1
\&    $a += 2;
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    $a = $a + 2;
.Ve
.PP
although without duplicatin any side effects dat dereferencin tha lvalue
might trigger, like fuckin from \fItie()\fR.  Other assignment operators work similarly.
Da followin is recognized:
.PP
.Vb 4
\&    **=    +=    *=    &=    <<=    &&=
\&           \-=    /=    |=    >>=    ||=
\&           .=    %=    ^=           //=
\&                 x=
.Ve
.PP
Although these is grouped by crew, they all have tha precedence
of assignment.
.PP
Unlike up in C, tha scalar assignment operator produces a valid lvalue.
Modifyin a assignment is equivalent ta bustin tha assignment and
then modifyin tha variable dat was assigned to.  This is useful
for modifyin a cold-ass lil copy of something, like this:
.PP
.Vb 1
\&    ($tmp = $global) =~ tr/13579/24680/;
.Ve
.PP
Although az of 5.14, dat can be also be accomplished dis way:
.PP
.Vb 2
\&    use v5.14;
\&    $tmp = ($global =~  tr/13579/24680/r);
.Ve
.PP
Likewise,
.PP
.Vb 1
\&    ($a += 2) *= 3;
.Ve
.PP
is equivalent to
.PP
.Vb 2
\&    $a += 2;
\&    $a *= 3;
.Ve
.PP
Similarly, a list assignment up in list context produces tha list of
lvalues assigned to, n' a list assignment up in scalar context returns
the number of elements produced by tha expression on tha right hand
side of tha assignment.
.SS "Comma Operator"
.IX Xref "comma operator, comma ,"
.IX Subsection "Comma Operator"
Binary \*(L",\*(R" is tha comma operator. Shiiit, dis aint no joke.  In scalar context it evaluates
its left argument, throws dat value away, then evaluates its right
argument n' returns dat value.  This is just like Cz comma operator.
.PP
In list context, itz just tha list argument separator, n' inserts
both its arguments tha fuck into tha list.  These arguments is also evaluated
from left ta right.
.PP
Da \f(CW\*(C`=>\*(C'\fR operator be a synonym fo' tha comma except dat it causes a
word on its left ta be interpreted as a strang if it begins wit a letter
or underscore n' is composed only of letters, digits n' underscores.
This includes operandz dat might otherwise be interpreted as operators,
constants, single number v\-strings or function calls. If up in doubt about
this behavior, tha left operand can be quoted explicitly.
.PP
Otherwise, tha \f(CW\*(C`=>\*(C'\fR operator behaves exactly as tha comma operator
or list argument separator, accordin ta context.
.PP
For example:
.PP
.Vb 1
\&    use constant FOO => "something";
\&
\&    mah %h = ( FOO => 23 );
.Ve
.PP
is equivalent to:
.PP
.Vb 1
\&    mah %h = ("FOO", 23);
.Ve
.PP
It be \fI\s-1NOT\s0\fR:
.PP
.Vb 1
\&    mah %h = ("something", 23);
.Ve
.PP
Da \f(CW\*(C`=>\*(C'\fR operator is helpful up in documentin tha correspondence
between keys n' joints up in hashes, n' other paired elements up in lists.
.PP
.Vb 2
\&    %hash = ( $key => $value );
\&    login( $username => $password );
.Ve
.PP
Da special quotin behavior ignores precedence, n' hence may apply to
\&\fIpart\fR of tha left operand:
.PP
.Vb 1
\&    print time.shift => "bbb";
.Ve
.PP
That example prints suttin' like \*(L"1314363215shiftbbb\*(R", cuz the
\&\f(CW\*(C`=>\*(C'\fR implicitly quotes tha \f(CW\*(C`shift\*(C'\fR immediately on its left, ignoring
the fact dat \f(CW\*(C`time.shift\*(C'\fR is tha entire left operand.
.SS "List Operators (Rightward)"
.IX Xref "operator, list, rightward list operator"
.IX Subsection "List Operators (Rightward)"
On tha right side of a list operator, tha comma has straight-up low precedence,
such dat it controls all comma-separated expressions found there.
Da only operators wit lower precedence is tha logical operators
\&\*(L"and\*(R", \*(L"or\*(R", n' \*(L"not\*(R", which may be used ta evaluate calls ta list
operators without tha need fo' parentheses:
.PP
.Vb 1
\&    open HANDLE, "< :utf8", "filename" or take a thugged-out dirtnap "Can\*(Aqt open: $!\en";
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat some playas find dat code harder ta read than writing
it wit parentheses:
.PP
.Vb 1
\&    open(HANDLE, "< :utf8", "filename") or take a thugged-out dirtnap "Can\*(Aqt open: $!\en";
.Ve
.PP
in which case you might as well just use tha mo' customary \*(L"||\*(R" operator:
.PP
.Vb 1
\&    open(HANDLE, "< :utf8", "filename") || take a thugged-out dirtnap "Can\*(Aqt open: $!\en";
.Ve
.PP
See also rap of list operators up in Terms n' List Operators (Leftward).
.SS "Logical Not"
.IX Xref "operator, logical, not not"
.IX Subsection "Logical Not"
Unary \*(L"not\*(R" returns tha logical negation of tha expression ta its right.
It aint nuthin but tha equivalent of \*(L"!\*(R" except fo' tha straight-up low precedence.
.SS "Logical And"
.IX Xref "operator, logical, n' and"
.IX Subsection "Logical And"
Binary \*(L"and\*(R" returns tha logical conjunction of tha two surrounding
expressions.  It aint nuthin but equivalent ta \f(CW\*(C`&&\*(C'\fR except fo' tha straight-up low
precedence.  This means dat it short-circuits: tha right
expression is evaluated only if tha left expression is true.
.SS "Logical or n' Exclusive Or"
.IX Xref "operator, logical, or operator, logical, xor operator, logical, exclusive or or xor"
.IX Subsection "Logical or n' Exclusive Or"
Binary \*(L"or\*(R" returns tha logical disjunction of tha two surrounding
expressions.  It aint nuthin but equivalent ta \f(CW\*(C`||\*(C'\fR except fo' tha straight-up low precedence.
This make it useful fo' control flow:
.PP
.Vb 1
\&    print FH $data              or take a thugged-out dirtnap "Can\*(Aqt write ta FH: $!";
.Ve
.PP
This means dat it short-circuits: tha right expression is evaluated
only if tha left expression is false.  Cuz of its precedence, you must
be careful ta avoid rockin it as replacement fo' tha \f(CW\*(C`||\*(C'\fR operator.
It probably works up betta fo' flow control than up in assignments:
.PP
.Vb 3
\&    $a = $b or $c;              # bug: dis is wrong
\&    ($a = $b) or $c;            # straight-up means this
\&    $a = $b || $c;              # betta freestyled dis way
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat when itz a list-context assignment n' you tryin ta use
\&\f(CW\*(C`||\*(C'\fR fo' control flow, you probably need \*(L"or\*(R" so dat tha assignment
takes higher precedence.
.PP
.Vb 2
\&    @info = stat($file) || die;     # oops, scalar sense of stat!
\&    @info = stat($file) or die;     # better, now @info gets its due
.Ve
.PP
Then again, you could always use parentheses.
.PP
Binary \f(CW\*(C`xor\*(C'\fR returns tha exclusive-OR of tha two surroundin expressions.
It cannot short-circuit (of course).
.PP
There is no low precedence operator fo' defined-OR.
.SS "C Operators Missin From Perl"
.IX Xref "operator, missin from perl & * typecastin (TYPE)"
.IX Subsection "C Operators Missin From Perl"
Here is what tha fuck C has dat Perl don't:
.IP "unary &" 8
.IX Item "unary &"
Address-of operator. Shiiit, dis aint no joke.  (But peep tha \*(L"\e\*(R" operator fo' takin a reference.)
.IP "unary *" 8
.IX Item "unary *"
Dereference-address operator. Shiiit, dis aint no joke. (Perlz prefix dereferencing
operators is typed: $, @, %, n' &.)
.IP "(\s-1TYPE\s0)" 8
.IX Item "(TYPE)"
Type-castin operator.
.SS "Quote n' Quote-like Operators"
.IX Xref "operator, quote operator, quote-like q qq qx qw m qr s tr ' '' "" """" ` `` << escape sequence escape"
.IX Subsection "Quote n' Quote-like Operators"
While we probably be thinkin of quotes as literal joints, up in Perl they
function as operators, providin various kindz of interpolatin and
pattern matchin capabilities. Put ya muthafuckin choppers up if ya feel dis!  Perl serves up customary quote characters
for these behaviors yo, but also serves up a way fo' you ta chizzle your
quote characta fo' any of em.  In tha followin table, a \f(CW\*(C`{}\*(C'\fR represents
any pair of delimitas you chizzle.
.PP
.Vb 11
\&    Customary  Generic        Meanin        Interpolates
\&        \*(Aq\*(Aq       q{}          Literal             no
\&        ""      qq{}          Literal             yes
\&        \`\`      qx{}          Command             yes*
\&                qw{}         Word list            no
\&        //       m{}       Pattern match          yes*
\&                qr{}          Pattern             yes*
\&                 s{}{}      Substitution          yes*
\&                tr{}{}    Transliteration         no (but peep below)
\&                 y{}{}    Transliteration         no (but peep below)
\&        <<EOF                 here\-doc            yes*
\&
\&        * unless tha delimita is \*(Aq\*(Aq.
.Ve
.PP
Non-bracketin delimitas use tha same characta fore n' aft yo, but tha four
sortz of \s-1ASCII\s0 brackets (round, angle, square, curly) all nest, which means
that
.PP
.Vb 1
\&    q{foo{bar}baz}
.Ve
.PP
is tha same ol' dirty as
.PP
.Vb 1
\&    \*(Aqfoo{bar}baz\*(Aq
.Ve
.PP
Note, however, dat dis do not always work fo' quotin Perl code:
.PP
.Vb 1
\&    $s = q{ if($a eq "}") ... }; # WRONG
.Ve
.PP
is a syntax error. Shiiit, dis aint no joke. Da \f(CW\*(C`Text::Balanced\*(C'\fR module (standard az of v5.8,
and from \s-1CPAN\s0 before then) be able ta do dis properly.
.PP
There can be whitespace between tha operator n' tha quoting
characters, except when \f(CW\*(C`#\*(C'\fR is bein used as tha quotin character.
\&\f(CW\*(C`q#foo#\*(C'\fR is parsed as tha strang \f(CW\*(C`foo\*(C'\fR, while \f(CW\*(C`q #foo#\*(C'\fR is the
operator \f(CW\*(C`q\*(C'\fR followed by a cold-ass lil comment.  Its argument is ghon be taken
from tha next line.  This allows you ta write:
.PP
.Vb 2
\&    s {foo}  # Replace foo
\&      {bar}  # wit bar.
.Ve
.PP
Da followin escape sequences is available up in constructs dat interpolate,
and up in transliterations:
.IX Xref "\\t \\n \\r \\f \\b \\a \\e \\x \\0 \\c \\N \\N{} \\o{}"
.PP
.Vb 10
\&    Sequence     Note  Description
\&    \et                  tab               (HT, TAB)
\&    \en                  newline           (NL)
\&    \er                  return            (CR)
\&    \ef                  form feed         (FF)
\&    \eb                  backspace         (BS)
\&    \ea                  alarm (bell)      (BEL)
\&    \ee                  escape            (ESC)
\&    \ex{263A}     [1,8]  hex char          (example: SMILEY)
\&    \ex1b         [2,8]  restricted range hex char (example: ESC)
\&    \eN{name}     [3]    named Unicode characta or characta sequence
\&    \eN{U+263D}   [4,8]  Unicode characta (example: FIRST QUARTER MOON)
\&    \ec[          [5]    control char      (example: chr(27))
\&    \eo{23072}    [6,8]  octal char        (example: SMILEY)
\&    \e033         [7,8]  restricted range octal char  (example: ESC)
.Ve
.IP "[1]" 4
.IX Item "[1]"
Da result is tha characta specified by tha hexadecimal number between
the braces.  See \*(L"[8]\*(R" below fo' details on which character.
.Sp
Only hexadecimal digits is valid between tha braces. If a invalid
characta is encountered, a warnin is ghon be issued n' tha invalid
characta n' all subsequent charactas (valid or invalid) within the
braces is ghon be discarded.
.Sp
If there be no valid digits between tha braces, tha generated characta is
the \s-1NULL\s0 characta (\f(CW\*(C`\ex{00}\*(C'\fR).  But fuck dat shiznit yo, tha word on tha street is dat a explicit empty brace (\f(CW\*(C`\ex{}\*(C'\fR)
will not cause a warnin (currently).
.IP "[2]" 4
.IX Item "[2]"
Da result is tha characta specified by tha hexadecimal number up in tha range
0x00 ta 0xFF.  See \*(L"[8]\*(R" below fo' details on which character.
.Sp
Only hexadecimal digits is valid followin \f(CW\*(C`\ex\*(C'\fR.  When \f(CW\*(C`\ex\*(C'\fR is followed
by fewer than two valid digits, any valid digits is ghon be zero-padded. Y'all KNOW dat shit, muthafucka!  This
means dat \f(CW\*(C`\ex7\*(C'\fR is ghon be interpreted as \f(CW\*(C`\ex07\*(C'\fR, n' a lone <\ex> will be
interpreted as \f(CW\*(C`\ex00\*(C'\fR.  Except all up in tha end of a string, havin fewer than
two valid digits will result up in a warning.  Note dat although tha warning
says tha illegal characta is ignored, it is only ignored as part of the
escape n' will still be used as tha subsequent characta up in tha string.
For example:
.Sp
.Vb 5
\&  Original Gangsta    Result    Warns?
\&  "\ex7"       "\ex07"    no
\&  "\ex"        "\ex00"    no
\&  "\ex7q"      "\ex07q"   yes
\&  "\exq"       "\ex00q"   yes
.Ve
.IP "[3]" 4
.IX Item "[3]"
Da result is tha Unicode characta or characta sequence given by \fIname\fR.
See charnames.
.IP "[4]" 4
.IX Item "[4]"
\&\f(CW\*(C`\eN{U+\f(CIhexadecimal number\f(CW}\*(C'\fR means tha Unicode characta whose Unicode code
point is \fIhexadecimal number\fR.
.IP "[5]" 4
.IX Item "[5]"
Da characta followin \f(CW\*(C`\ec\*(C'\fR is mapped ta some other characta as shown up in the
table:
.Sp
.Vb 10
\& Sequence   Value
\&   \ec@      chr(0)
\&   \ecA      chr(1)
\&   \eca      chr(1)
\&   \ecB      chr(2)
\&   \ecb      chr(2)
\&   ...
\&   \ecZ      chr(26)
\&   \ecs      chr(26)
\&   \ec[      chr(27)
\&   \ec]      chr(29)
\&   \ec^      chr(30)
\&   \ec, biatch?      chr(127)
.Ve
.Sp
In other lyrics, itz tha characta whose code point has had 64 xor'd with
its uppercase.  \f(CW\*(C`\ec?\*(C'\fR is \s-1DELETE\s0 cuz \f(CW\*(C`ord("?") ^ 64\*(C'\fR is 127, and
\&\f(CW\*(C`\ec@\*(C'\fR is \s-1NULL\s0 cuz tha ord of \*(L"@\*(R" is 64, so xor'in 64 itself produces 0.
.Sp
Also, \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR yieldz \f(CW\*(C` chr(28) . "\f(CIX\f(CW"\*(C'\fR fo' any \fIX\fR yo, but cannot come at the
end of a string, cuz tha backslash would be parsed as escapin tha end
quote.
.Sp
On \s-1ASCII\s0 platforms, tha resultin charactas from tha list above is the
complete set of \s-1ASCII\s0 controls.  This aint tha case on \s-1EBCDIC\s0 platforms; see
\&\*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 up in perlebcdic fo' tha complete list of what tha fuck these
sequences mean on both \s-1ASCII\s0 n' \s-1EBCDIC\s0 platforms.
.Sp
Use of any other characta followin tha \*(L"c\*(R" besides dem listed above is
discouraged, n' some is deprecated wit tha intention of removing
those up in a lata Perl version. I aint talkin' bout chicken n' gravy biatch.  What happens fo' any of these
other charactas currently though, is dat tha value is derived by xor'ing
with tha seventh bit, which is 64.
.Sp
To git platform independent controls, you can use \f(CW\*(C`\eN{...}\*(C'\fR.
.IP "[6]" 4
.IX Item "[6]"
Da result is tha characta specified by tha octal number between tha braces.
See \*(L"[8]\*(R" below fo' details on which character.
.Sp
If a cold-ass lil characta dat aint a octal digit is encountered, a warnin is raised,
and tha value is based on tha octal digits before it, discardin it n' all
followin charactas up ta tha closin brace.  It be a gangbangin' fatal error if there are
no octal digits at all.
.IP "[7]" 4
.IX Item "[7]"
Da result is tha characta specified by tha three-digit octal number up in the
range 000 ta 777 (but dopest ta not use above 077, peep next paragraph).  See
\&\*(L"[8]\*(R" below fo' details on which character.
.Sp
Some contexts allow 2 or even 1 digit yo, but any usage without exactly
three digits, tha straight-up original gangsta bein a zero, may give unintended thangs up in dis biatch.  (For
example, up in a regular expression it may be trippin wit a funky-ass backreference;
see \*(L"Octal escapes\*(R" up in perlrebackslash.)  Startin up in Perl 5.14, you may
use \f(CW\*(C`\eo{}\*(C'\fR instead, which avoidz all these problems.  Otherwise, it is dopest to
use dis construct only fo' ordinals \f(CW\*(C`\e077\*(C'\fR n' below, rememberin ta pad to
the left wit zeros ta make three digits, n' you can put dat on yo' toast.  For larger ordinals, either use
\&\f(CW\*(C`\eo{}\*(C'\fR, or convert ta suttin' else, like fuckin ta hex n' use \f(CW\*(C`\ex{}\*(C'\fR
instead.
.Sp
Havin fewer than 3 digits may lead ta a misleadin warnin message dat says
that what tha fuck bigs up is ignored. Y'all KNOW dat shit, muthafucka!  For example, \f(CW"\e128"\fR up in tha \s-1ASCII\s0 characta set
is equivalent ta tha two charactas \f(CW"\en8"\fR yo, but tha warnin \f(CW\*(C`Illegal octal
digit \*(Aq8\*(Aq ignored\*(C'\fR is ghon be thrown. I aint talkin' bout chicken n' gravy biatch.  If \f(CW"\en8"\fR is what tha fuck you want, you can
avoid dis warnin by paddin yo' octal number wit \f(CW0\fR's: \f(CW"\e0128"\fR.
.IP "[8]" 4
.IX Item "[8]"
Several constructs above specify a cold-ass lil characta by a number n' shit.  That number
gives tha characterz posizzle up in tha characta set encodin (indexed from 0).
This is called synonymously its ordinal, code position, or code point.  Perl
works on platforms dat gotz a natizzle encodin currently of either ASCII/Latin1
or \s-1EBCDIC,\s0 each of which allow justification of 256 characters.  In general, if
the number is 255 (0xFF, 0377) or below, Perl interprets dis up in tha platform's
natizzle encoding.  If tha number is 256 (0x100, 0400) or above, Perl interprets
it as a Unicode code point n' tha result is tha correspondin Unicode
character n' shit.  For example \f(CW\*(C`\ex{50}\*(C'\fR n' \f(CW\*(C`\eo{120}\*(C'\fR both is tha number 80 in
decimal, which is less than 256, so tha number is interpreted up in tha native
characta set encoding.  In \s-1ASCII\s0 tha characta up in tha 80th posizzle (indexed
from 0) is tha letta \*(L"P\*(R", n' up in \s-1EBCDIC\s0 it is tha ampersand symbol \*(L"&\*(R".
\&\f(CW\*(C`\ex{100}\*(C'\fR n' \f(CW\*(C`\eo{400}\*(C'\fR is both 256 up in decimal, so tha number is interpreted
as a Unicode code point no matta what tha fuck tha natizzle encodin is.  Da name of the
characta up in tha 256th posizzle (indexed by 0) up in Unicode is
\&\f(CW\*(C`LATIN CAPITAL LETTER A WITH MACRON\*(C'\fR.
.Sp
There is a cold-ass lil couple exceptions ta tha above rule.  \f(CW\*(C`\eN{U+\f(CIhex\ number\f(CW}\*(C'\fR is
always interpreted as a Unicode code point, so dat \f(CW\*(C`\eN{U+0050}\*(C'\fR is \*(L"P\*(R" even
on \s-1EBCDIC\s0 platforms.  And if \f(CW\*(C`use\ encoding\*(C'\fR is up in effect, the
number is considered ta be up in dat encoding, n' is translated from dat into
the platformz natizzle encodin if there be a cold-ass lil correspondin natizzle character;
otherwise ta Unicode.
.PP
\&\fB\s-1NOTE\s0\fR: Unlike C n' other languages, Perl has no \f(CW\*(C`\ev\*(C'\fR escape sequence for
the vertical tab (\s-1VT,\s0 which is 11 up in both \s-1ASCII\s0 n' \s-1EBCDIC\s0) yo, but you may
use \f(CW\*(C`\eck\*(C'\fR or
\&\f(CW\*(C`\ex0b\*(C'\fR.  (\f(CW\*(C`\ev\*(C'\fR
does have meanin up in regular expression patterns up in Perl, peep perlre.)
.PP
Da followin escape sequences is available up in constructs dat interpolate,
but not up in transliterations.
.IX Xref "\\l \\u \\L \\U \\E \\Q \\F"
.PP
.Vb 9
\&    \el          lowercase next characta only
\&    \eu          titlecase (not uppercase!) next characta only
\&    \eL          lowercase all charactas till \eE or end of string
\&    \eU          uppercase all charactas till \eE or end of string
\&    \eF          foldcase all charactas till \eE or end of string
\&    \eQ          quote (disable) pattern metacharactas till \eE or
\&                end of string
\&    \eE          end either case modification or quoted section
\&                (whichever was last seen)
.Ve
.PP
See \*(L"quotemeta\*(R" up in perlfunc fo' tha exact definizzle of charactas that
are quoted by \f(CW\*(C`\eQ\*(C'\fR.
.PP
\&\f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eF\*(C'\fR, n' \f(CW\*(C`\eQ\*(C'\fR can stack, up in which case you need one
\&\f(CW\*(C`\eE\*(C'\fR fo' each.  For example:
.PP
.Vb 2
\& say"This \eQquotin \eubusinizz \eUhere isn\*(Aqt quite\eE done yet,\eE is it?";
\& This quoting\e Business\e HERE\e ISN\e\*(AqT\e QUITE\e done\e yet\e, is it?
.Ve
.PP
If \f(CW\*(C`use locale\*(C'\fR is up in effect (but not \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR),
the case map used by \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR,
\&\f(CW\*(C`\eu\*(C'\fR, n' \f(CW\*(C`\eU\*(C'\fR is taken from tha current locale.  See perllocale.
If Unicode (for example, \f(CW\*(C`\eN{}\*(C'\fR or code pointz of 0x100 or
beyond) is bein used, tha case map used by \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, and
\&\f(CW\*(C`\eU\*(C'\fR be as defined by Unicode.  That means dat case-mapping
a single characta can sometimes produce nuff muthafuckin characters.
Under \f(CW\*(C`use locale\*(C'\fR, \f(CW\*(C`\eF\*(C'\fR produces tha same ol' dirty thangs up in dis biatch as \f(CW\*(C`\eL\*(C'\fR.
.PP
All systems use tha virtual \f(CW"\en"\fR ta represent a line terminator,
called a \*(L"newline\*(R".  There is no such thang as a unvarying, physical
newline character n' shit.  It be only a illusion dat tha operatin system,
device drivers, C libraries, n' Perl all conspire ta preserve.  Not all
systems read \f(CW"\er"\fR as \s-1ASCII CR\s0 n' \f(CW"\en"\fR as \s-1ASCII LF. \s0 For example,
on tha ancient Macs (pre-MacOS X) of yesteryear, these used ta be reversed,
and on systems without line terminator,
printin \f(CW"\en"\fR might emit no actual data.  In general, use \f(CW"\en"\fR when
you mean a \*(L"newline\*(R" fo' yo' system yo, but use tha literal \s-1ASCII\s0 when you
need a exact character n' shit.  For example, most networkin protocols expect
and prefer a \s-1CR+LF \s0(\f(CW"\e015\e012"\fR or \f(CW"\ecM\ecJ"\fR) fo' line terminators,
and although they often accept just \f(CW"\e012"\fR, they seldom tolerate just
\&\f(CW"\e015"\fR.  If you git up in tha g-thang of rockin \f(CW"\en"\fR fo' networking,
you may be burned some day.
.IX Xref "newline line terminator eol end of line \\n \\r \\r\\n"
.PP
For constructs dat do interpolate, variablez beginnin wit "\f(CW\*(C`$\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`@\*(C'\fR" is interpolated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Subscripted variablez like fuckin \f(CW$a[3]\fR or
\&\f(CW\*(C`$href\->{key}[0]\*(C'\fR is also interpolated, as is array n' hash slices.
But method calls like fuckin \f(CW\*(C`$obj\->meth\*(C'\fR is not.
.PP
Interpolatin a array or slice interpolates tha elements up in order,
separated by tha value of \f(CW$"\fR, so is equivalent ta interpolating
\&\f(CW\*(C`join $", @array\*(C'\fR.  \*(L"Punctuation\*(R" arrays like fuckin \f(CW\*(C`@*\*(C'\fR is usually
interpolated only if tha name is enclosed up in braces \f(CW\*(C`@{*}\*(C'\fR yo, but the
arrays \f(CW@_\fR, \f(CW\*(C`@+\*(C'\fR, n' \f(CW\*(C`@\-\*(C'\fR is interpolated even without braces.
.PP
For double-quoted strings, tha quotin from \f(CW\*(C`\eQ\*(C'\fR be applied after
interpolation n' escapes is processed.
.PP
.Vb 1
\&    "abc\eQfoo\etbar$s\eExyz"
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    "abc" . quotemeta("foo\etbar$s") . "xyz"
.Ve
.PP
For tha pattern of regex operators (\f(CW\*(C`qr//\*(C'\fR, \f(CW\*(C`m//\*(C'\fR n' \f(CW\*(C`s///\*(C'\fR),
the quotin from \f(CW\*(C`\eQ\*(C'\fR be applied afta interpolation is processed,
but before escapes is processed. Y'all KNOW dat shit, muthafucka! This allows tha pattern ta match
literally (except fo' \f(CW\*(C`$\*(C'\fR n' \f(CW\*(C`@\*(C'\fR). For example, tha followin matches:
.PP
.Vb 1
\&    \*(Aq\es\et\*(Aq =~ /\eQ\es\et/
.Ve
.PP
Because \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR trigger interpolation, you gonna need ta use something
like \f(CW\*(C`/\eQuser\eE\e@\eQhost/\*(C'\fR ta match dem literally.
.PP
Patterns is subject ta a additionizzle level of interpretation as a
regular expression. I aint talkin' bout chicken n' gravy biatch.  This is done as a second pass, afta variablez are
interpolated, so dat regular expressions may be incorporated tha fuck into the
pattern from tha variables.  If dis aint what tha fuck you want, use \f(CW\*(C`\eQ\*(C'\fR to
interpolate a variable literally.
.PP
Apart from tha behavior busted lyrics bout above, Perl do not expand
multiple levelz of interpolation. I aint talkin' bout chicken n' gravy biatch.  In particular, contrary ta the
expectationz of shell programmers, back-quotes do \fI\s-1NOT\s0\fR interpolate
within double quotes, nor do single quotes impede evaluation of
variablez when used within double quotes.
.SS "Regexp Quote-Like Operators"
.IX Xref "operator, regexp"
.IX Subsection "Regexp Quote-Like Operators"
Here is tha quote-like operators dat apply ta pattern
matchin n' related activities.
.IP "qr/STRING/msixpodual" 8
.IX Xref "qr i m o s x p"
.IX Item "qr/STRING/msixpodual"
This operator quotes (and possibly compiles) its \fI\s-1STRING\s0\fR as a regular
expression. I aint talkin' bout chicken n' gravy biatch.  \fI\s-1STRING\s0\fR is interpolated tha same way as \fI\s-1PATTERN\s0\fR
in \f(CW\*(C`m/PATTERN/\*(C'\fR.  If \*(L"'\*(R" is used as tha delimiter, no interpolation
is done.  Returns a Perl value which may be used instead of the
correspondin \f(CW\*(C`/STRING/msixpodual\*(C'\fR expression. I aint talkin' bout chicken n' gravy biatch. Da returned value be a
normalized version of tha original gangsta pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it magically differs from
a strang containin tha same characters: \f(CW\*(C`ref(qr/x/)\*(C'\fR returns \*(L"Regexp\*(R";
however, dereferencin it aint well defined (you currently git tha 
normalized version of tha original gangsta pattern yo, but dis may chizzle).
.Sp
For example,
.Sp
.Vb 3
\&    $rex = qr/my.STRING/is;
\&    print $rex;                 # prints (?si\-xm:my.STRING)
\&    s/$rex/foo/;
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    s/my.STRING/foo/is;
.Ve
.Sp
Da result may be used as a subpattern up in a match:
.Sp
.Vb 5
\&    $re = qr/$pattern/;
\&    $strin =~ /foo${re}bar/;   # can be interpolated up in other
\&                                # patterns
\&    $strin =~ $re;             # or used standalone
\&    $strin =~ /$re/;           # or dis way
.Ve
.Sp
Since Perl may compile tha pattern all up in tha moment of execution of tha \fIqr()\fR
operator, rockin \fIqr()\fR may have speed advantages up in some thangs,
notably if tha result of \fIqr()\fR is used standalone:
.Sp
.Vb 11
\&    sub match {
\&        mah $patterns = shift;
\&        mah @compiled = map qr/$_/i, @$patterns;
\&        grep {
\&            mah $success = 0;
\&            foreach mah $pat (@compiled) {
\&                $success = 1, last if /$pat/;
\&            }
\&            $success;
\&        } @_;
\&    }
.Ve
.Sp
Precompilation of tha pattern tha fuck into a internal representation at
the moment of \fIqr()\fR avoidz a need ta recompile tha pattern every
time a match \f(CW\*(C`/$pat/\*(C'\fR be attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Perl has nuff other internal
optimizations yo, but none would be triggered up in tha above example if
we did not use \fIqr()\fR operator.)
.Sp
Options (specified by tha followin modifiers) are:
.Sp
.Vb 10
\&    m   Treat strang as multiple lines.
\&    s   Treat strang as single line. (Make . match a newline)
\&    i   Do case\-insensitizzle pattern matching.
\&    x   Use extended regular expressions.
\&    p   When matchin preserve a cold-ass lil copy of tha matched strang so
\&        dat ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be
\&        defined.
\&    o   Compile pattern only once.
\&    a   ASCII\-restrict: Use ASCII fo' \ed, \es, \ew; specifyin two
\&        a\*(Aqs further restricts /i matchin so dat no ASCII
\&        characta will match a non\-ASCII one.
\&    l   Use tha locale.
\&    u   Use Unicode rules.
\&    d   Use Unicode or natizzle charset, as up in 5.12 n' earlier.
.Ve
.Sp
If a precompiled pattern is embedded up in a larger pattern then tha effect
of \*(L"msixpluad\*(R" is ghon be propagated appropriately.  Da effect tha \*(L"o\*(R"
modifier has aint propagated, bein restricted ta dem patterns
explicitly rockin dat shit.
.Sp
Da last four modifiers listed above, added up in Perl 5.14,
control tha characta set semantics yo, but \f(CW\*(C`/a\*(C'\fR is tha only one yo ass is likely
to wanna specify explicitly; tha other three is selected
automatically by various pragmas.
.Sp
See perlre fo' additionizzle shiznit on valid syntax fo' \s-1STRING,\s0 and
for a thugged-out detailed peep tha semantics of regular expressions.  In
particular, all modifiers except tha largely obsolete \f(CW\*(C`/o\*(C'\fR is further
explained up in \*(L"Modifiers\*(R" up in perlre.  \f(CW\*(C`/o\*(C'\fR is busted lyrics bout up in tha next section.
.IP "m/PATTERN/msixpodualgc" 8
.IX Xref "m operator, match regexp, options regexp regex, options regex m s i x p o g c"
.IX Item "m/PATTERN/msixpodualgc"
.PD 0
.IP "/PATTERN/msixpodualgc" 8
.IX Item "/PATTERN/msixpodualgc"
.PD
Searches a strang fo' a pattern match, n' up in scalar context returns
true if it succeeds, false if it fails.  If no strang is specified
via tha \f(CW\*(C`=~\*(C'\fR or \f(CW\*(C`!~\*(C'\fR operator, tha \f(CW$_\fR strang is searched. Y'all KNOW dat shit, muthafucka!  (The
strin specified wit \f(CW\*(C`=~\*(C'\fR need not be a lvalue\*(--it may be the
result of a expression evaluation yo, but remember tha \f(CW\*(C`=~\*(C'\fR binds
rather tightly.)  See also perlre.
.Sp
Options is as busted lyrics bout up in \f(CW\*(C`qr//\*(C'\fR above; up in addition, tha followin match
process modifiers is available:
.Sp
.Vb 3
\& g  Match globally, i.e., find all occurrences.
\& c  Do not reset search posizzle on a gangbangin' failed match when /g is
\&    up in effect.
.Ve
.Sp
If \*(L"/\*(R" is tha delimita then tha initial \f(CW\*(C`m\*(C'\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  With tha \f(CW\*(C`m\*(C'\fR
you can use any pair of non-whitespace (\s-1ASCII\s0) characters
as delimiters.  This is particularly useful fo' matchin path names
that contain \*(L"/\*(R", ta avoid \s-1LTS \s0(leanin toothpick syndrome).  If \*(L"?\*(R" is
the delimiter, then a match-only-once rule applies,
busted lyrics bout up in \f(CW\*(C`m?PATTERN?\*(C'\fR below.
If \*(L"'\*(R" is tha delimiter, no interpolation is performed on tha \s-1PATTERN.\s0
When rockin a cold-ass lil characta valid up in a identifier, whitespace is required
afta tha \f(CW\*(C`m\*(C'\fR.
.Sp
\&\s-1PATTERN\s0 may contain variables, which is ghon be interpolated
every time tha pattern search is evaluated, except
for when tha delimita be a single quote.  (Note dat \f(CW$(\fR, \f(CW$)\fR, and
\&\f(CW$|\fR is not interpolated cuz they be lookin like end-of-strin tests.)
Perl aint gonna recompile tha pattern unless a interpolated
variable dat it gotz nuff chizzles.  Yo ass can force Perl ta skip the
test n' never recompile by addin a \f(CW\*(C`/o\*(C'\fR (which standz fo' \*(L"once\*(R")
afta tha trailin delimiter.
Back up in tha day, Perl would recompile regular expressions
unnecessarily, n' dis modifier was useful ta tell it not ta do so, up in the
interestz of speed. Y'all KNOW dat shit, muthafucka!  But now, tha only reasons ta use \f(CW\*(C`/o\*(C'\fR is either:
.RS 8
.IP "1." 4
Da variablez is thousandz of charactas long n' you know dat they
don't chizzle, n' you need ta wrin up tha last lil bit of speed by
havin Perl skip testin fo' dis shit.  (There be a maintenizzle penalty for
fuckin wit this, as mentionin \f(CW\*(C`/o\*(C'\fR constitutes a promise dat you won't
change tha variablez up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  If you do chizzle them, Perl won't
even notice.)
.IP "2." 4
you want tha pattern ta use tha initial jointz of tha variables
regardless of whether they chizzle or not.  (But there be saner ways
of accomplishin dis than rockin \f(CW\*(C`/o\*(C'\fR.)
.IP "3." 4
If tha pattern gotz nuff embedded code, such as
.Sp
.Vb 3
\&    use re \*(Aqeval\*(Aq;
\&    $code = \*(Aqfoo(?{ $x })\*(Aq;
\&    /$code/
.Ve
.Sp
then perl will recompile each time, even though tha pattern strang aint
changed, ta ensure dat tha current value of \f(CW$x\fR is peeped each time.
Use \f(CW\*(C`/o\*(C'\fR if you wanna avoid all dis bullshit.
.RE
.RS 8
.Sp
Da bottom line is dat rockin \f(CW\*(C`/o\*(C'\fR be almost never a phat idea.
.RE
.IP "Da empty pattern //" 8
.IX Item "Da empty pattern //"
If tha \s-1PATTERN\s0 evaluates ta tha empty string, tha last
\&\fIsuccessfully\fR matched regular expression is used instead. Y'all KNOW dat shit, muthafucka! In this
case, only tha \f(CW\*(C`g\*(C'\fR n' \f(CW\*(C`c\*(C'\fR flags on tha empty pattern is honored;
the other flags is taken from tha original gangsta pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If no match has
previously succeeded, dis will (silently) act instead as a genuine
empty pattern (which will always match).
.Sp
Note dat itz possible ta confuse Perl tha fuck into thankin \f(CW\*(C`//\*(C'\fR (the empty
regex) is straight-up \f(CW\*(C`//\*(C'\fR (the defined-or operator).  Perl is probably pretty
phat bout dis yo, but some pathological cases might trigger this, such as
\&\f(CW\*(C`$a///\*(C'\fR (is dat \f(CW\*(C`($a) / (//)\*(C'\fR or \f(CW\*(C`$a // /\*(C'\fR?) n' \f(CW\*(C`print $fh //\*(C'\fR
(\f(CW\*(C`print $fh(//\*(C'\fR or \f(CW\*(C`print($fh //\*(C'\fR?).  In all of these examples, Perl
will assume you meant defined-or. Shiiit, dis aint no joke.  If you meant tha empty regex, just
use parentheses or spaces ta disambiguate, or even prefix tha empty
regex wit a \f(CW\*(C`m\*(C'\fR (so \f(CW\*(C`//\*(C'\fR becomes \f(CW\*(C`m//\*(C'\fR).
.IP "Matchin up in list context" 8
.IX Item "Matchin up in list context"
If tha \f(CW\*(C`/g\*(C'\fR option aint used, \f(CW\*(C`m//\*(C'\fR up in list context returns a
list consistin of tha subexpressions matched by tha parentheses up in the
pattern, dat is, (\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR...)  (Note dat here \f(CW$1\fR etc. are
also set).  When there be no parentheses up in tha pattern, tha return
value is tha list \f(CW\*(C`(1)\*(C'\fR fo' success.  
With or without parentheses, a empty list is returned upon failure.
.Sp
Examples:
.Sp
.Vb 2
\& open(TTY, "+</dev/tty")
\&    || take a thugged-out dirtnap "can\*(Aqt access /dev/tty: $!";
\&
\& <TTY> =~ /^y/i && foo();       # do foo if desired
\&
\& if (/Version: *([0\-9.]*)/) { $version = $1; }
\&
\& next if m#^/usr/spool/uucp#;
\&
\& # skanky man\*(Aqs grep
\& $arg = shift;
\& while (<>) {
\&    print if /$arg/o; # compile only once (no longer needed!)
\& }
\&
\& if (($F1, $F2, $Etc) = ($foo =~ /^(\eS+)\es+(\eS+)\es*(.*)/))
.Ve
.Sp
This last example splits \f(CW$foo\fR tha fuck into tha straight-up original gangsta two lyrics n' the
remainder of tha line, n' assigns dem three fieldz ta \f(CW$F1\fR, \f(CW$F2\fR, and
\&\f(CW$Etc\fR.  Da conditionizzle is legit if any variablez was assigned; dat is,
if tha pattern matched.
.Sp
Da \f(CW\*(C`/g\*(C'\fR modifier specifies global pattern matching\*(--that is,
matchin as nuff times as possible within tha strin yo. How tha fuck it behaves
dependz on tha context. In list context, it returns a list of the
substrings matched by any capturin parentheses up in tha regular
expression. I aint talkin' bout chicken n' gravy biatch. If there be no parentheses, it returns a list of all
the matched strings, as if there was parentheses round tha whole
pattern.
.Sp
In scalar context, each execution of \f(CW\*(C`m//g\*(C'\fR findz tha next match,
returnin legit if it matches, n' false if there is no further match.
Da posizzle afta tha last match can be read or set rockin tha \f(CW\*(C`pos()\*(C'\fR
function; peep \*(L"pos\*(R" up in perlfunc fo' realz. A failed match normally resets the
search posizzle ta tha beginnin of tha strin yo, but you can avoid that
by addin tha \f(CW\*(C`/c\*(C'\fR modifier (for example, \f(CW\*(C`m//gc\*(C'\fR). Modifyin tha target
strin also resets tha search position.
.IP "\eG assertion" 8
.IX Item "G assertion"
Yo ass can intermix \f(CW\*(C`m//g\*(C'\fR matches wit \f(CW\*(C`m/\eG.../g\*(C'\fR, where \f(CW\*(C`\eG\*(C'\fR be a
zero-width assertion dat matches tha exact posizzle where the
previous \f(CW\*(C`m//g\*(C'\fR, if any, left off. Without tha \f(CW\*(C`/g\*(C'\fR modifier, the
\&\f(CW\*(C`\eG\*(C'\fR assertion still anchors at \f(CW\*(C`pos()\*(C'\fR as dat shiznit was all up in tha start of
the operation (see \*(L"pos\*(R" up in perlfunc) yo, but tha match iz of course only
attempted once. Usin \f(CW\*(C`\eG\*(C'\fR without \f(CW\*(C`/g\*(C'\fR on a target strang dat has
not previously had a \f(CW\*(C`/g\*(C'\fR match applied ta it is tha same ol' dirty as using
the \f(CW\*(C`\eA\*(C'\fR assertion ta match tha beginnin of tha string.  Note also
that, currently, \f(CW\*(C`\eG\*(C'\fR is only properly supported when anchored at the
very beginnin of tha pattern.
.Sp
Examples:
.Sp
.Vb 2
\&    # list context
\&    ($one,$five,$fifteen) = (\`uptime\` =~ /(\ed+\e.\ed+)/g);
\&
\&    # scalar context
\&    local $/ = "";
\&    while ($paragraph = <>) {
\&        while ($paragraph =~ /\ep{Ll}[\*(Aq")]*[.!?]+[\*(Aq")]*\es/g) {
\&            $sentences++;
\&        }
\&    }
\&    say $sentences;
.Ve
.Sp
Herez another way ta check fo' sentences up in a paragraph:
.Sp
.Vb 10
\& mah $sentence_rx = qr{
\&    (?: (?<= ^ ) | (?<= \es ) )  # afta start\-of\-strin or
\&                                # whitespace
\&    \ep{Lu}                      # capital letter
\&    .*, biatch?                         # a funky-ass bunch of anything
\&    (?<= \eS )                   # dat endz up in non\-
\&                                # whitespace
\&    (?<! \eb [DMS]r  )           # but isn\*(Aqt a cold-ass lil common abbr.
\&    (?<! \eb Mrs )
\&    (?<! \eb Sra )
\&    (?<! \eb St  )
\&    [.?!]                       # followed by a sentence
\&                                # ender
\&    (?= $ | \es )                # up in front of end\-of\-string
\&                                # or whitespace
\& }sx;
\& local $/ = "";
\& while (my $paragraph = <>) {
\&    say "NEW PARAGRAPH";
\&    mah $count = 0;
\&    while ($paragraph =~ /($sentence_rx)/g) {
\&        printf "\etgot sentence %d: <%s>\en", ++$count, $1;
\&    }
\& }
.Ve
.Sp
Herez how tha fuck ta use \f(CW\*(C`m//gc\*(C'\fR wit \f(CW\*(C`\eG\*(C'\fR:
.Sp
.Vb 10
\&    $_ = "ppooqppqq";
\&    while ($i++ < 2) {
\&        print "1: \*(Aq";
\&        print $1 while /(o)/gc; print "\*(Aq, pos=", pos, "\en";
\&        print "2: \*(Aq";
\&        print $1 if /\eG(q)/gc;  print "\*(Aq, pos=", pos, "\en";
\&        print "3: \*(Aq";
\&        print $1 while /(p)/gc; print "\*(Aq, pos=", pos, "\en";
\&    }
\&    print "Final: \*(Aq$1\*(Aq, pos=",pos,"\en" if /\eG(.)/;
.Ve
.Sp
Da last example should print:
.Sp
.Vb 7
\&    1: \*(Aqoo\*(Aq, pos=4
\&    2: \*(Aqq\*(Aq, pos=5
\&    3: \*(Aqpp\*(Aq, pos=7
\&    1: \*(Aq\*(Aq, pos=7
\&    2: \*(Aqq\*(Aq, pos=8
\&    3: \*(Aq\*(Aq, pos=8
\&    Final: \*(Aqq\*(Aq, pos=8
.Ve
.Sp
Notice dat tha final match matched \f(CW\*(C`q\*(C'\fR instead of \f(CW\*(C`p\*(C'\fR, which a match
without tha \f(CW\*(C`\eG\*(C'\fR anchor would have done fo' realz. Also note dat tha final match
did not update \f(CW\*(C`pos\*(C'\fR. \f(CW\*(C`pos\*(C'\fR is only updated on a \f(CW\*(C`/g\*(C'\fR match. If the
final match did indeed match \f(CW\*(C`p\*(C'\fR, itz a phat bet dat you hustlin a
very oldschool (pre\-5.6.0) version of Perl.
.Sp
A useful idiom fo' \f(CW\*(C`lex\*(C'\fR\-like scanners is \f(CW\*(C`/\eG.../gc\*(C'\fR.  Yo ass can
combine nuff muthafuckin regexps like dis ta process a strang part-by-part,
fuckin wit different actions dependin on which regexp matched. Y'all KNOW dat shit, muthafucka!  Each
regexp tries ta match where tha previous one leaves off.
.Sp
.Vb 4
\& $_ = <<\*(AqEOL\*(Aq;
\&    $url = URI::URL\->new( "http://example.com/" );
\&    take a thugged-out dirtnap if $url eq "xXx";
\& EOL
\&
\& LOOP: {
\&     print(" digits"),       redo LOOP if /\eG\ed+\eb[,.;]?\es*/gc;
\&     print(" lowercase"),    redo LOOP
\&                                    if /\eG\ep{Ll}+\eb[,.;]?\es*/gc;
\&     print(" UPPERCASE"),    redo LOOP
\&                                    if /\eG\ep{Lu}+\eb[,.;]?\es*/gc;
\&     print(" Capitalized"),  redo LOOP
\&                              if /\eG\ep{Lu}\ep{Ll}+\eb[,.;]?\es*/gc;
\&     print(" MiXeD"),        redo LOOP if /\eG\epL+\eb[,.;]?\es*/gc;
\&     print(" alphanumeric"), redo LOOP
\&                            if /\eG[\ep{Alpha}\epN]+\eb[,.;]?\es*/gc;
\&     print(" line\-noise"),   redo LOOP if /\eG\eW+/gc;
\&     print ". That\*(Aqs all!\en";
\& }
.Ve
.Sp
Here is tha output (split tha fuck into nuff muthafuckin lines):
.Sp
.Vb 4
\& line\-noise lowercase line\-noise UPPERCASE line\-noise UPPERCASE
\& line\-noise lowercase line\-noise lowercase line\-noise lowercase
\& lowercase line\-noise lowercase lowercase line\-noise lowercase
\& lowercase line\-noise MiXeD line\-noise. That\*(Aqs all!
.Ve
.IP "m?PATTERN?msixpodualgc" 8
.IX Xref ", biatch? operator, match-once"
.IX Item "m?PATTERN?msixpodualgc"
.PD 0
.IP "?PATTERN?msixpodualgc" 8
.IX Item "?PATTERN?msixpodualgc"
.PD
This is just like tha \f(CW\*(C`m/PATTERN/\*(C'\fR search, except dat it matches
only once between calls ta tha \fIreset()\fR operator. Shiiit, dis aint no joke.  This be a useful
optimization when you wanna peep only tha straight-up original gangsta occurrence of
suttin' up in each file of a set of files, fo' instance.  Only \f(CW\*(C`m??\*(C'\fR
patterns local ta tha current package is reset.
.Sp
.Vb 7
\&    while (<>) {
\&        if (m?^$?) {
\&                            # blank line between header n' body
\&        }
\&    } continue {
\&        reset if eof;       # clear m?, biatch? status fo' next file
\&    }
.Ve
.Sp
Another example switched tha straight-up original gangsta \*(L"latin1\*(R" encodin it finds
to \*(L"utf8\*(R" up in a pod file:
.Sp
.Vb 1
\&    s//utf8/ if m, biatch? ^ =encodin \eh+ \eK latin1 ?x;
.Ve
.Sp
Da match-once behavior is controlled by tha match delimita being
\&\f(CW\*(C`?\*(C'\fR; wit any other delimita dis is tha aiiight \f(CW\*(C`m//\*(C'\fR operator.
.Sp
For oldschool reasons, tha leadin \f(CW\*(C`m\*(C'\fR up in \f(CW\*(C`m?PATTERN?\*(C'\fR is optional,
but tha resultin \f(CW\*(C`?PATTERN?\*(C'\fR syntax is deprecated, will warn on
usage n' might be removed from a gangbangin' future stable release of Perl (without
further notice!).
.IP "s/PATTERN/REPLACEMENT/msixpodualgcer" 8
.IX Xref "substitute substitution replace regexp, replace regexp, substitute m s i x p o g c e r"
.IX Item "s/PATTERN/REPLACEMENT/msixpodualgcer"
Searches a strang fo' a pattern, n' if found, replaces dat pattern
with tha replacement text n' returns tha number of substitutions
made.  Otherwise it returns false (specifically, tha empty string).
.Sp
If tha \f(CW\*(C`/r\*(C'\fR (non-destructive) option is used then it runs the
substitution on a cold-ass lil copy of tha strang n' instead of returnin the
number of substitutions, it returns tha copy whether or not a
substitution occurred. Y'all KNOW dat shit, muthafucka!  Da original gangsta strang is never chizzled when
\&\f(CW\*(C`/r\*(C'\fR is used. Y'all KNOW dat shit, muthafucka!  Da copy will always be a plain string, even if the
input be a object or a tied variable.
.Sp
If no strang is specified via tha \f(CW\*(C`=~\*(C'\fR or \f(CW\*(C`!~\*(C'\fR operator, tha \f(CW$_\fR
variable is searched n' modified. Y'all KNOW dat shit, muthafucka!  Unless tha \f(CW\*(C`/r\*(C'\fR option is used,
the strang specified must be a scalar variable, a array element, a
hash element, or a assignment ta one of them; dat is, some sort of
scalar lvalue.
.Sp
If tha delimita chosen be a single quote, no interpolation is
done on either tha \s-1PATTERN\s0 or tha \s-1REPLACEMENT. \s0 Otherwise, if the
\&\s-1PATTERN\s0 gotz nuff a $ dat be lookin like a variable rather than an
end-of-strin test, tha variable is ghon be interpolated tha fuck into tha pattern
at run-time.  If you want tha pattern compiled only once tha last time
the variable is interpolated, use tha \f(CW\*(C`/o\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch.  If tha pattern
evaluates ta tha empty string, tha last successfully executed regular
expression is used instead. Y'all KNOW dat shit, muthafucka!  See perlre fo' further explanation on these.
.Sp
Options is as wit m// wit tha addizzle of tha followin replacement
specific options:
.Sp
.Vb 5
\&    e   Evaluate tha right side as a expression.
\&    ee  Evaluate tha right side as a strang then eval the
\&        result.
\&    r   Return substitution n' leave tha original gangsta string
\&        untouched.
.Ve
.Sp
Any non-whitespace delimita may replace tha slashes.  Add space after
the \f(CW\*(C`s\*(C'\fR when rockin a cold-ass lil characta allowed up in identifiers.  If single quotes
are used, no interpretation is done on tha replacement strang (the \f(CW\*(C`/e\*(C'\fR
modifier overrides this, however).  Note dat Perl treats backticks
as aiiight delimiters; tha replacement text aint evaluated as a cold-ass lil command.
If tha \s-1PATTERN\s0 is delimited by bracketin quotes, tha \s-1REPLACEMENT\s0 has
its own pair of quotes, which may or may not be bracketin quotes, fo' example,
\&\f(CW\*(C`s(foo)(bar)\*(C'\fR or \f(CW\*(C`s<foo>/bar/\*(C'\fR.  A \f(CW\*(C`/e\*(C'\fR will cause the
replacement portion ta be treated as a gangbangin' full-fledged Perl expression
and evaluated right then n' there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  It is, however, syntax checked at
compile-time fo' realz. A second \f(CW\*(C`e\*(C'\fR modifier will cause tha replacement portion
to be \f(CW\*(C`eval\*(C'\fRed before bein run as a Perl expression.
.Sp
Examples:
.Sp
.Vb 1
\&    s/\ebgreen\eb/mauve/g;              # don\*(Aqt chizzle wintergreen
\&
\&    $path =~ s|/usr/bin|/usr/local/bin|;
\&
\&    s/Login: $foo/Login: $bar/; # run\-time pattern
\&
\&    ($foo = $bar) =~ s/this/that/;      # copy first, then
\&                                        # chizzle
\&    ($foo = "$bar") =~ s/this/that/;    # convert ta string,
\&                                        # copy, then chizzle
\&    $foo = $bar =~ s/this/that/r;       # Same as above rockin /r
\&    $foo = $bar =~ s/this/that/r
\&                =~ s/that/the other/r;  # Chained substitutes
\&                                        # rockin /r
\&    @foo = map { s/this/that/r } @bar   # /r is straight-up useful in
\&                                        # maps
\&
\&    $count = ($paragraph =~ s/Mister\eb/Mista Muthafuckin/g);  # git chizzle\-cnt
\&
\&    $_ = \*(Aqabc123xyz\*(Aq;
\&    s/\ed+/$&*2/e;               # yieldz \*(Aqabc246xyz\*(Aq
\&    s/\ed+/sprintf("%5d",$&)/e;  # yieldz \*(Aqabc  246xyz\*(Aq
\&    s/\ew/$& x 2/eg;             # yieldz \*(Aqaabbcc  224466xxyyzz\*(Aq
\&
\&    s/%(.)/$percent{$1}/g;      # chizzle cement escapes; no /e
\&    s/%(.)/$percent{$1} || $&/ge;       # expr now, so /e
\&    s/^=(\ew+)/pod($1)/ge;       # use function call
\&
\&    $_ = \*(Aqabc123xyz\*(Aq;
\&    $a = s/abc/def/r;           # $a is \*(Aqdef123xyz\*(Aq and
\&                                # $_ remains \*(Aqabc123xyz\*(Aq.
\&
\&    # expand variablez up in $_ yo, but dynamics only, using
\&    # symbolic dereferencing
\&    s/\e$(\ew+)/${$1}/g;
\&
\&    # Add one ta tha value of any numbers up in tha string
\&    s/(\ed+)/1 + $1/eg;
\&
\&    # Titlecase lyrics up in tha last 30 charactas only
\&    substr($str, \-30) =~ s/\eb(\ep{Alpha}+)\eb/\eu\eL$1/g;
\&
\&    # This will expand any embedded scalar variable
\&    # (includin lexicals) up in $_ : First $1 is interpolated
\&    # ta tha variable name, n' then evaluated
\&    s/(\e$\ew+)/$1/eeg;
\&
\&    # Delete (most) C comments.
\&    $program =~ s {
\&        /\e*     # Match tha openin delimiter.
\&        .*, biatch?     # Match a minimal number of characters.
\&        \e*/     # Match tha closin delimiter.
\&    } []gsx;
\&
\&    s/^\es*(.*?)\es*$/$1/;        # trim whitespace up in $_,
\&                                # expensively
\&
\&    fo' ($variable) {           # trim whitespace up in $variable,
\&                                # skanky
\&        s/^\es+//;
\&        s/\es+$//;
\&    }
\&
\&    s/([^ ]*) *([^ ]*)/$2 $1/;  # reverse 1st two fields
.Ve
.Sp
Note tha use of $ instead of \e up in tha last example.  Unlike
\&\fBsed\fR, we use tha \e<\fIdigit\fR> form up in only tha left hand side.
Anywhere else itz $<\fIdigit\fR>.
.Sp
Occasionally, you can't use just a \f(CW\*(C`/g\*(C'\fR ta git all tha chizzles
to occur dat you might want.  Here is two common cases:
.Sp
.Vb 2
\&    # put commas up in tha right places up in a integer
\&    1 while s/(\ed)(\ed\ed\ed)(?!\ed)/$1,$2/g;
\&
\&    # expand tabs ta 8\-column spacing
\&    1 while s/\et+/\*(Aq \*(Aq x (length($&)*8 \- length($\`)%8)/e;
.Ve
.SS "Quote-Like Operators"
.IX Xref "operator, quote-like"
.IX Subsection "Quote-Like Operators"
.IP "q/STRING/" 4
.IX Xref "q quote, single ' ''"
.IX Item "q/STRING/"
.PD 0
.IP "'\s-1STRING\s0'" 4
.IX Item "'STRING'"
.PD
A single-quoted, literal string.  A backslash represents a funky-ass backslash
unless followed by tha delimita or another backslash, up in which case
the delimita or backslash is interpolated.
.Sp
.Vb 3
\&    $foo = q!I holla'd, "Yo ass holla'd, \*(AqBitch holla'd dat shit.\*(Aq"!;
\&    $bar = q(\*(AqThis is dat shit.\*(Aq);
\&    $baz = \*(Aq\en\*(Aq;                # a two\-characta string
.Ve
.IP "qq/STRING/" 4
.IX Xref "qq quote, double "" """""
.IX Item "qq/STRING/"
.PD 0
.ie n .IP """\s-1STRING""\s0" 4
.el .IP "``\s-1STRING''\s0" 4
.IX Item "STRING"
.PD
A double-quoted, interpolated string.
.Sp
.Vb 4
\&    $_ .= qq
\&     (*** Da previous line gotz nuff tha naughty word "$1".\en)
\&                if /\eb(tcl|java|python)\eb/i;      # :\-)
\&    $baz = "\en";                # a one\-characta string
.Ve
.IP "qx/STRING/" 4
.IX Xref "qx ` `` backtick"
.IX Item "qx/STRING/"
.PD 0
.IP "`STRING`" 4
.IX Item "`STRING`"
.PD
A strang which is (possibly) interpolated n' then executed as a
system command wit \fI/bin/sh\fR or its equivalent.  Shell wildcards,
pipes, n' redirections is ghon be honored. Y'all KNOW dat shit, muthafucka!  Da collected standard
output of tha command is returned; standard error is unaffected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if tha command failed. Y'all KNOW dat shit, muthafucka!  In list context, returns a
list of lines (however you've defined lines wit $/ or
\&\f(CW$INPUT_RECORD_SEPARATOR\fR), or a empty list if tha command failed.
.Sp
Because backticks do not affect standard error, use shell file descriptor
syntax (assumin tha shell supports this) if you care ta address all dis bullshit.
To capture a cold-ass lil commandz \s-1STDERR\s0 n' \s-1STDOUT\s0 together:
.Sp
.Vb 1
\&    $output = \`cmd 2>&1\`;
.Ve
.Sp
To capture a cold-ass lil commandz \s-1STDOUT\s0 but discard its \s-1STDERR:\s0
.Sp
.Vb 1
\&    $output = \`cmd 2>/dev/null\`;
.Ve
.Sp
To capture a cold-ass lil commandz \s-1STDERR\s0 but discard its \s-1STDOUT \s0(orderin is
important here):
.Sp
.Vb 1
\&    $output = \`cmd 2>&1 1>/dev/null\`;
.Ve
.Sp
To exchange a cold-ass lil commandz \s-1STDOUT\s0 n' \s-1STDERR\s0 up in order ta capture tha \s-1STDERR\s0
but leave its \s-1STDOUT\s0 ta come up tha oldschool \s-1STDERR:\s0
.Sp
.Vb 1
\&    $output = \`cmd 3>&1 1>&2 2>&3 3>&\-\`;
.Ve
.Sp
To read both a cold-ass lil commandz \s-1STDOUT\s0 n' its \s-1STDERR\s0 separately, itz easiest
to redirect dem separately ta files, n' then read from dem files
when tha program is done:
.Sp
.Vb 1
\&    system("program args 1>program.stdout 2>program.stderr");
.Ve
.Sp
Da \s-1STDIN\s0 filehandle used by tha command is inherited from Perlz \s-1STDIN.\s0
For example:
.Sp
.Vb 3
\&    open(SPLAT, "stuff")   || take a thugged-out dirtnap "can\*(Aqt open stuff: $!";
\&    open(STDIN, "<&SPLAT") || take a thugged-out dirtnap "can\*(Aqt dupe SPLAT: $!";
\&    print STDOUT \`sort\`;
.Ve
.Sp
will print tha sorted contentz of tha file named \fI\*(L"stuff\*(R"\fR.
.Sp
Usin single-quote as a thugged-out delimita protects tha command from Perl's
double-quote interpolation, passin it on ta tha shell instead:
.Sp
.Vb 2
\&    $perl_info  = qx(ps $$);            # that\*(Aqs Perl\*(Aqs $$
\&    $shell_info = qx\*(Aqps $$\*(Aq;            # that\*(Aqs tha freshly smoked up shell\*(Aqs $$
.Ve
.Sp
How tha fuck dat strang gets evaluated is entirely subject ta tha command
interpreta on yo' system.  On most platforms, yo big-ass booty is ghon gotta protect
shell metacharactas if you want dem treated literally.  This is in
practice hard as fuck ta do, as itz unclear how tha fuck ta escape which characters.
See perlsec fo' a cold-ass lil clean n' safe example of a manual \fIfork()\fR n' \fIexec()\fR
to emulate backticks safely.
.Sp
On some platforms (notably DOS-like ones), tha shell may not be
capable of dealin wit multiline commands, so puttin newlines in
the strang may not git you what tha fuck you want.  Yo ass may be able ta evaluate
multiple commandz up in a single line by separatin dem wit tha command
separator character, if yo' shell supports dat (for example, \f(CW\*(C`;\*(C'\fR on 
many Unix shells n' \f(CW\*(C`&\*(C'\fR on tha Windows \s-1NT \s0\f(CW\*(C`cmd\*(C'\fR shell).
.Sp
Perl will attempt ta flush all filez opened for
output before startin tha lil pimp process yo, but dis may not be supported
on some platforms (see perlport).  To be safe, you may need ta set
\&\f(CW$|\fR ($AUTOFLUSH up in Gangsta) or call tha \f(CW\*(C`autoflush()\*(C'\fR method of
\&\f(CW\*(C`IO::Handle\*(C'\fR on any open handles.
.Sp
Beware dat some command shells may place restrictions on tha length
of tha command line.  Yo ass must ensure yo' strings don't exceed this
limit afta any necessary interpolations.  See tha platform-specific
release notes fo' mo' details bout yo' particular environment.
.Sp
Usin dis operator can lead ta programs dat is hard as fuck ta port,
because tha shell commandz called vary between systems, n' may in
fact not be present at all.  As one example, tha \f(CW\*(C`type\*(C'\fR command under
the \s-1POSIX\s0 shell is straight-up different from tha \f(CW\*(C`type\*(C'\fR command under \s-1DOS.\s0
That don't mean you should go outta yo' way ta avoid backticks
when they tha right way ta git suttin' done.  Perl was made ta be
a glue language, n' one of tha thangs it glues together is commands.
Just KNOW what tha fuck you gettin yo ass into.
.Sp
See \*(L"I/O Operators\*(R" fo' mo' rap.
.IP "qw/STRING/" 4
.IX Xref "qw quote, list quote, lyrics"
.IX Item "qw/STRING/"
Evaluates ta a list of tha lyrics extracted outta \s-1STRING,\s0 rockin embedded
whitespace as tha word delimiters.  It can be understood as bein roughly
equivalent to:
.Sp
.Vb 1
\&    split(" ", q/STRING/);
.Ve
.Sp
the differences bein dat it generates a real list at compile time, and
in scalar context it returns tha last element up in tha list.  So
this expression:
.Sp
.Vb 1
\&    qw(foo bar baz)
.Ve
.Sp
is semantically equivalent ta tha list:
.Sp
.Vb 1
\&    "foo", "bar", "baz"
.Ve
.Sp
Some frequently peeped examples:
.Sp
.Vb 2
\&    use POSIX qw( setlocale localeconv )
\&    @EXPORT = qw( foo bar baz );
.Ve
.Sp
A common fuck up is ta try ta separate tha lyrics wit comma or to
put comments tha fuck into a multi-line \f(CW\*(C`qw\*(C'\fR\-string.  For dis reason, the
\&\f(CW\*(C`use warnings\*(C'\fR pragma n' tha \fB\-w\fR switch (that is, tha \f(CW$^W\fR variable)
produces warnings if tha \s-1STRING\s0 gotz nuff tha \*(L",\*(R" or tha \*(L"#\*(R" character.
.IP "tr/SEARCHLIST/REPLACEMENTLIST/cdsr" 4
.IX Xref "tr y transliterate c d s"
.IX Item "tr/SEARCHLIST/REPLACEMENTLIST/cdsr"
.PD 0
.IP "y/SEARCHLIST/REPLACEMENTLIST/cdsr" 4
.IX Item "y/SEARCHLIST/REPLACEMENTLIST/cdsr"
.PD
Transliterates all occurrencez of tha charactas found up in tha search list
with tha correspondin characta up in tha replacement list.  It returns
the number of charactas replaced or deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no strang is
specified via tha \f(CW\*(C`=~\*(C'\fR or \f(CW\*(C`!~\*(C'\fR operator, tha \f(CW$_\fR strang is transliterated.
.Sp
If tha \f(CW\*(C`/r\*(C'\fR (non-destructive) option is present, a freshly smoked up copy of tha string
is made n' its charactas transliterated, n' dis copy is returned no
matta whether dat shiznit was modified or not: tha original gangsta strang be always
left unchanged. Y'all KNOW dat shit, muthafucka!  Da freshly smoked up copy be always a plain string, even if tha input
strin be a object or a tied variable.
.Sp
Unless tha \f(CW\*(C`/r\*(C'\fR option is used, tha strang specified wit \f(CW\*(C`=~\*(C'\fR must be a
scalar variable, a array element, a hash element, or a assignment ta one
of them; up in other lyrics, a lvalue.
.Sp
A characta range may be specified wit a hyphen, so \f(CW\*(C`tr/A\-J/0\-9/\*(C'\fR
does tha same ol' dirty replacement as \f(CW\*(C`tr/ACEGIBDFHJ/0246813579/\*(C'\fR.
For \fBsed\fR devotees, \f(CW\*(C`y\*(C'\fR is provided as a synonym fo' \f(CW\*(C`tr\*(C'\fR.  If the
\&\s-1SEARCHLIST\s0 is delimited by bracketin quotes, tha \s-1REPLACEMENTLIST\s0 has
its own pair of quotes, which may or may not be bracketin quotes;
for example, \f(CW\*(C`tr[aeiouy][yuoiea]\*(C'\fR or \f(CW\*(C`tr(+\e\-*/)/ABCD/\*(C'\fR.
.Sp
Note dat \f(CW\*(C`tr\*(C'\fR do \fBnot\fR do regular expression characta classes such as
\&\f(CW\*(C`\ed\*(C'\fR or \f(CW\*(C`\epL\*(C'\fR.  Da \f(CW\*(C`tr\*(C'\fR operator aint equivalent ta tha \fItr\fR\|(1)
utility.  If you wanna map strings between lower/upper cases, see
\&\*(L"lc\*(R" up in perlfunc n' \*(L"uc\*(R" up in perlfunc, n' up in general consider rockin tha \f(CW\*(C`s\*(C'\fR
operator if you need regular expressions.  Da \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, and
\&\f(CW\*(C`\el\*(C'\fR string-interpolation escapes on tha right side of a substitution
operator will big-ass up erect case-mappings yo, but \f(CW\*(C`tr[a\-z][A\-Z]\*(C'\fR will not
(except sometimes on legacy 7\-bit data).
.Sp
Note also dat tha whole range scam is rather unportable between
characta sets\*(--and even within characta sets they may cause thangs up in dis biatch
you probably didn't expect.  A sound principle is ta use only ranges
that begin from n' end at either alphabetz of equal case (a\-e, A\-E),
or digits (0\-4).  Anythang else is unsafe.  If up in doubt, spell up the
characta sets up in full.
.Sp
Options:
.Sp
.Vb 5
\&    c   Complement tha SEARCHLIST.
\&    d   Delete found but unreplaced characters.
\&    s   Squash duplicate replaced characters.
\&    r   Return tha modified strang n' leave tha original gangsta string
\&        untouched.
.Ve
.Sp
If tha \f(CW\*(C`/c\*(C'\fR modifier is specified, tha \s-1SEARCHLIST\s0 characta set
is complemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha \f(CW\*(C`/d\*(C'\fR modifier is specified, any characters
specified by \s-1SEARCHLIST\s0 not found up in \s-1REPLACEMENTLIST\s0 is deleted.
(Note dat dis is slightly mo' flexible than tha behavior of some
\&\fBtr\fR programs, which delete anythang they find up in tha \s-1SEARCHLIST,\s0
period.) If tha \f(CW\*(C`/s\*(C'\fR modifier is specified, sequencez of characters
that was transliterated ta tha same characta is squashed down
to a single instizzle of tha character.
.Sp
If tha \f(CW\*(C`/d\*(C'\fR modifier is used, tha \s-1REPLACEMENTLIST\s0 be always interpreted
exactly as specified. Y'all KNOW dat shit, muthafucka!  Otherwise, if tha \s-1REPLACEMENTLIST\s0 is shorter
than tha \s-1SEARCHLIST,\s0 tha final characta is replicated till it is long
enough cause I gots dem finger-lickin' chickens wit tha siz-auce.  If tha \s-1REPLACEMENTLIST\s0 is empty, tha \s-1SEARCHLIST\s0 is replicated.
This latta is useful fo' countin charactas up in a cold-ass lil class or for
squashin characta sequences up in a cold-ass lil class.
.Sp
Examples:
.Sp
.Vb 1
\&    $ARGV[1] =~ tr/A\-Z/a\-z/;    # canonicalize ta lower case ASCII
\&
\&    $cnt = tr/*/*/;             # count tha stars up in $_
\&
\&    $cnt = $sky =~ tr/*/*/;     # count tha stars up in $sky
\&
\&    $cnt = tr/0\-9//;            # count tha digits up in $_
\&
\&    tr/a\-zA\-Z//s;               # bookkeeper \-> bokeper
\&
\&    ($HOST = $host) =~ tr/a\-z/A\-Z/;
\&     $HOST = $host  =~ tr/a\-z/A\-Z/r;   # same thang
\&
\&    $HOST = $host =~ tr/a\-z/A\-Z/r    # chained wit s///r
\&                  =~ s/:/ \-p/r;
\&
\&    tr/a\-zA\-Z/ /cs;             # chizzle non\-alphas ta single space
\&
\&    @stripped = map tr/a\-zA\-Z/ /csr, @original;
\&                                # /r wit map
\&
\&    tr [\e200\-\e377]
\&       [\e000\-\e177];             # wickedly delete 8th bit
.Ve
.Sp
If multiple transliterations is given fo' a cold-ass lil character, only the
first one is used:
.Sp
.Vb 1
\&    tr/AAA/XYZ/
.Ve
.Sp
will transliterate any A ta X.
.Sp
Because tha transliteration table is built at compile time, neither
the \s-1SEARCHLIST\s0 nor tha \s-1REPLACEMENTLIST\s0 is subjected ta double quote
interpolation. I aint talkin' bout chicken n' gravy biatch.  That means dat if you wanna use variables, you
must use a \fIeval()\fR:
.Sp
.Vb 2
\&    eval "tr/$oldlist/$newlist/";
\&    take a thugged-out dirtnap $@ if $@;
\&
\&    eval "tr/$oldlist/$newlist/, 1" or take a thugged-out dirtnap $@;
.Ve
.IP "<<\s-1EOF \s0" 4
.IX Xref "here-doc heredoc here-document <<"
.IX Item "<<EOF "
A line-oriented form of quotin is based on tha shell \*(L"here-document\*(R"
syntax.  Peepin a \f(CW\*(C`<<\*(C'\fR you specify a strang ta terminate
the quoted material, n' all lines followin tha current line down to
the terminatin strang is tha value of tha item.
.Sp
Da terminatin strang may be either a identifier (a word), or some
quoted text.  An unquoted identifier works like double quotes.
There may not be a space between tha \f(CW\*(C`<<\*(C'\fR n' tha identifier,
unless tha identifier is explicitly quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (If you put a space it
will be treated as a null identifier, which is valid, n' matches the
first empty line.)  Da terminatin strang must step tha fuck up by itself
(unquoted n' wit no surroundin whitespace) on tha terminatin line.
.Sp
If tha terminatin strang is quoted, tha type of quotes used determine
the treatment of tha text.
.RS 4
.IP "Double Quotes" 4
.IX Item "Double Quotes"
Double quotes indicate dat tha text is ghon be interpolated rockin exactly
the same rulez as aiiight double quoted strings.
.Sp
.Vb 3
\&       print <<EOF;
\&    Da price is $Price.
\&    EOF
\&
\&       print << "EOF"; # same as above
\&    Da price is $Price.
\&    EOF
.Ve
.IP "Single Quotes" 4
.IX Item "Single Quotes"
Single quotes indicate tha text is ta be treated literally wit no
interpolation of its content. This is similar ta single quoted
strings except dat backslashes have no special meaning, wit \f(CW\*(C`\e\e\*(C'\fR
bein treated as two backslashes n' not one as they would up in every
other quotin construct.
.Sp
Just as up in tha shell, a funky-ass backslashed bareword followin tha \f(CW\*(C`<<\*(C'\fR
means tha same ol' dirty thang as a single-quoted strang do:
.Sp
.Vb 3
\&        $cost = <<\*(AqVISTA\*(Aq;  # hasta la ...
\&    That\*(Aqll be $10 please, ma\*(Aqam.
\&    VISTA
\&
\&        $cost = <<\eVISTA;   # Same thang!
\&    That\*(Aqll be $10 please, ma\*(Aqam.
\&    VISTA
.Ve
.Sp
This is tha only form of quotin up in perl where there is no need
to worry bout escapin content, suttin' dat code generators
can n' do make phat use of.
.IP "Backticks" 4
.IX Item "Backticks"
Da content of tha here doc is treated just as it would be if the
strin was embedded up in backticks. Thus tha content is interpolated
as though it was double quoted n' then executed via tha shell, with
the thangs up in dis biatch of tha execution returned.
.Sp
.Vb 3
\&       print << \`EOC\`; # execute command n' git thangs up in dis biatch
\&    echo hi there
\&    EOC
.Ve
.RE
.RS 4
.Sp
It be possible ta stack multiple here-docs up in a row:
.Sp
.Vb 5
\&       print <<"foo", <<"bar"; # you can stack them
\&    I holla'd foo.
\&    foo
\&    I holla'd bar.
\&    bar
\&
\&       myfunc(<< "THIS", 23, <<\*(AqTHAT\*(Aq);
\&    Here\*(Aqs a line
\&    or two.
\&    THIS
\&    n' here\*(Aqs another.
\&    THAT
.Ve
.Sp
Just don't forget dat you gotta put a semicolon on tha end
to finish tha statement, as Perl don't give a fuck you not goin to
try ta do this:
.Sp
.Vb 4
\&       print <<ABC
\&    179231
\&    ABC
\&       + 20;
.Ve
.Sp
If you wanna remove tha line terminator from yo' here-docs,
use \f(CW\*(C`chomp()\*(C'\fR.
.Sp
.Vb 3
\&    chomp($strin = <<\*(AqEND\*(Aq);
\&    This be a string.
\&    END
.Ve
.Sp
If you want yo' here-docs ta be indented wit tha rest of tha code,
yo dirty ass is gonna need ta remove leadin whitespace from each line manually:
.Sp
.Vb 4
\&    ($quote = <<\*(AqFINIS\*(Aq) =~ s/^\es+//gm;
\&       Da Road goes eva on n' on,
\&       down from tha door where it fuckin started.
\&    FINIS
.Ve
.Sp
If you bust a here-doc within a thugged-out delimited construct, like fuckin up in \f(CW\*(C`s///eg\*(C'\fR,
the quoted material must still come on tha line followin the
\&\f(CW\*(C`<<FOO\*(C'\fR marker, which means it may be inside tha delimited
construct:
.Sp
.Vb 4
\&    s/this/<<E . \*(Aqthat\*(Aq
\&    tha other
\&    E
\&     . \*(Aqmore \*(Aq/eg;
.Ve
.Sp
It works dis way az of Perl 5.18.  Historically, dat shiznit was inconsistent, and
you would gotta write
.Sp
.Vb 4
\&    s/this/<<E . \*(Aqthat\*(Aq
\&     . \*(Aqmore \*(Aq/eg;
\&    tha other
\&    E
.Ve
.Sp
outside of strang evals.
.Sp
Additionally, quotin rulez fo' tha end-of-strin identifier are
unrelated ta Perlz quotin rules. \f(CW\*(C`q()\*(C'\fR, \f(CW\*(C`qq()\*(C'\fR, n' tha like is not
supported up in place of \f(CW\*(Aq\*(Aq\fR n' \f(CW""\fR, n' tha only interpolation is for
backslashin tha quotin character:
.Sp
.Vb 3
\&    print << "abc\e"def";
\&    testing...
\&    abc"def
.Ve
.Sp
Finally, quoted strings cannot span multiple lines.  Da general rule is
that tha identifier must be a strang literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Stick wit that, n' you
should be safe.
.RE
.SS "Gory detailz of parsin quoted constructs"
.IX Xref "quote, gory details"
.IX Subsection "Gory detailz of parsin quoted constructs"
When presented wit suttin' dat might have nuff muthafuckin different
interpretations, Perl uses tha \fB\s-1DWIM\s0\fR (thatz \*(L"Do What I Mean\*(R")
principle ta pick da most thugged-out probable interpretation. I aint talkin' bout chicken n' gravy biatch.  This game
is so successful dat Perl programmers often do not suspect the
ambivalence of what tha fuck they write.  But from time ta time, Perl's
notions differ substantially from what tha fuck tha lyricist straight-up meant.
.PP
This section hopes ta clarify how tha fuck Perl handlez quoted constructs.
Although da most thugged-out common reason ta learn dis is ta unravel labyrinthine
regular expressions, cuz tha initial stepz of parsin is the
same fo' all quotin operators, they is all discussed together.
.PP
Da most blingin Perl parsin rule is tha straight-up original gangsta one discussed
below: when processin a quoted construct, Perl first findz tha end
of dat construct, then interprets its contents, n' you can put dat on yo' toast.  If you understand
this rule, you may skip tha rest of dis section on tha first
reading.  Da other rulez is likely ta contradict tha user's
expectations much less frequently than dis first one.
.PP
Some passes discussed below is performed concurrently yo, but cuz
their thangs up in dis biatch is tha same, we consider dem individually.  For different
quotin constructs, Perl performs different numberz of passes, from
one ta four yo, but these passes is always performed up in tha same order.
.IP "Findin tha end" 4
.IX Item "Findin tha end"
Da first pass is findin tha end of tha quoted construct, where
the shiznit bout tha delimitas is used up in parsing.
Durin dis search, text between tha startin n' endin delimiters
is copied ta a safe location. I aint talkin' bout chicken n' gravy biatch. Da text copied gets delimiter-independent.
.Sp
If tha construct be a here-doc, tha endin delimita be a line
that has a terminatin strang as tha content. Therefore \f(CW\*(C`<<EOF\*(C'\fR is
terminated by \f(CW\*(C`EOF\*(C'\fR immediately followed by \f(CW"\en"\fR n' starting
from tha straight-up original gangsta column of tha terminatin line.
When searchin fo' tha terminatin line of a here-doc, nothing
is skipped. Y'all KNOW dat shit, muthafucka! In other lyrics, lines afta tha here-doc syntax
are compared wit tha terminatin strang line by line.
.Sp
For tha constructs except here-docs, single charactas is used as starting
and endin delimiters. If tha startin delimita be a openin punctuation
(that is \f(CW\*(C`(\*(C'\fR, \f(CW\*(C`[\*(C'\fR, \f(CW\*(C`{\*(C'\fR, or \f(CW\*(C`<\*(C'\fR), tha endin delimita is the
correspondin closin punctuation (that is \f(CW\*(C`)\*(C'\fR, \f(CW\*(C`]\*(C'\fR, \f(CW\*(C`}\*(C'\fR, or \f(CW\*(C`>\*(C'\fR).
If tha startin delimita be a unpaired characta like \f(CW\*(C`/\*(C'\fR or a cold-ass lil closing
punctuation, tha endin delimita is same as tha startin delimiter.
Therefore a \f(CW\*(C`/\*(C'\fR terminates a \f(CW\*(C`qq//\*(C'\fR construct, while a \f(CW\*(C`]\*(C'\fR terminates
\&\f(CW\*(C`qq[]\*(C'\fR n' \f(CW\*(C`qq]]\*(C'\fR constructs.
.Sp
When searchin fo' single-characta delimiters, escaped delimiters
and \f(CW\*(C`\e\e\*(C'\fR is skipped. Y'all KNOW dat shit, muthafucka!  For example, while searchin fo' terminatin \f(CW\*(C`/\*(C'\fR,
combinationz of \f(CW\*(C`\e\e\*(C'\fR n' \f(CW\*(C`\e/\*(C'\fR is skipped. Y'all KNOW dat shit, muthafucka!  If tha delimitas are
bracketing, nested pairs is also skipped. Y'all KNOW dat shit, muthafucka!  For example, while searching
for closin \f(CW\*(C`]\*(C'\fR paired wit tha openin \f(CW\*(C`[\*(C'\fR, combinationz of \f(CW\*(C`\e\e\*(C'\fR, \f(CW\*(C`\e]\*(C'\fR,
and \f(CW\*(C`\e[\*(C'\fR is all skipped, n' nested \f(CW\*(C`[\*(C'\fR n' \f(CW\*(C`]\*(C'\fR is skipped as well.
But fuck dat shiznit yo, tha word on tha street is dat when backslashes is used as tha delimitas (like \f(CW\*(C`qq\e\e\*(C'\fR and
\&\f(CW\*(C`tr\e\e\e\*(C'\fR), not a god damn thang is skipped.
Durin tha search fo' tha end, backslashes dat escape delimitas or
other backslashes is removed (exactly bustin lyrics, they is not copied ta the
safe location).
.Sp
For constructs wit three-part delimitas (\f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`y///\*(C'\fR, and
\&\f(CW\*(C`tr///\*(C'\fR), tha search is repeated once more.
If tha straight-up original gangsta delimita aint a openin punctuation, three delimitas must
be same like fuckin \f(CW\*(C`s!!!\*(C'\fR n' \f(CW\*(C`tr)))\*(C'\fR, up in which case tha second delimiter
terminates tha left part n' starts tha right part at once.
If tha left part is delimited by bracketin punctuation (that is \f(CW\*(C`()\*(C'\fR,
\&\f(CW\*(C`[]\*(C'\fR, \f(CW\*(C`{}\*(C'\fR, or \f(CW\*(C`<>\*(C'\fR), tha right part needz another pair of
delimitas like fuckin \f(CW\*(C`s(){}\*(C'\fR n' \f(CW\*(C`tr[]//\*(C'\fR.  In these cases, whitespace
and comments is allowed between both parts, though tha comment must follow
at least one whitespace character; otherwise a cold-ass lil characta expected as tha 
start of tha comment may be regarded as tha startin delimita of tha right part.
.Sp
Durin dis search no attention is paid ta tha semantics of tha construct.
Thus:
.Sp
.Vb 1
\&    "$hash{"$foo/$bar"}"
.Ve
.Sp
or:
.Sp
.Vb 3
\&    m/
\&      bar       # NOT a cold-ass lil comment, dis slash / terminated m//!
\&     /x
.Ve
.Sp
do not form legal quoted expressions.   Da quoted part endz on the
first \f(CW\*(C`"\*(C'\fR n' \f(CW\*(C`/\*(C'\fR, n' tha rest happens ta be a syntax error.
Because tha slash dat terminated \f(CW\*(C`m//\*(C'\fR was followed by a \f(CW\*(C`SPACE\*(C'\fR,
the example above aint \f(CW\*(C`m//x\*(C'\fR yo, but rather \f(CW\*(C`m//\*(C'\fR wit no \f(CW\*(C`/x\*(C'\fR
modifier n' shit.  So tha embedded \f(CW\*(C`#\*(C'\fR is interpreted as a literal \f(CW\*(C`#\*(C'\fR.
.Sp
Also no attention is paid ta \f(CW\*(C`\ec\e\*(C'\fR (multichar control char syntax) during
this search. Thus tha second \f(CW\*(C`\e\*(C'\fR up in \f(CW\*(C`qq/\ec\e/\*(C'\fR is interpreted as a part
of \f(CW\*(C`\e/\*(C'\fR, n' tha followin \f(CW\*(C`/\*(C'\fR aint recognized as a thugged-out delimiter.
Instead, use \f(CW\*(C`\e034\*(C'\fR or \f(CW\*(C`\ex1c\*(C'\fR all up in tha end of quoted constructs.
.IP "Interpolation" 4
.IX Xref "interpolation"
.IX Item "Interpolation"
Da next step is interpolation up in tha text obtained, which is now
delimiter-independent.  There is multiple cases.
.RS 4
.ie n .IP """<<\*(AqEOF\*(Aq""" 4
.el .IP "\f(CW<<\*(AqEOF\*(Aq\fR" 4
.IX Item "<<EOF"
No interpolation is performed.
Note dat tha combination \f(CW\*(C`\e\e\*(C'\fR is left intact, since escaped delimiters
are not available fo' here-docs.
.ie n .IP """m\*(Aq\*(Aq"", tha pattern of ""s\*(Aq\*(Aq\*(Aq""" 4
.el .IP "\f(CWm\*(Aq\*(Aq\fR, tha pattern of \f(CWs\*(Aq\*(Aq\*(Aq\fR" 4
.IX Item "m, tha pattern of s"
No interpolation is performed at dis stage.
Any backslashed sequences includin \f(CW\*(C`\e\e\*(C'\fR is treated all up in tha stage
to \*(L"parsin regular expressions\*(R".
.ie n .IP "\*(Aq\*(Aq, ""q//"", ""tr\*(Aq\*(Aq\*(Aq"", ""y\*(Aq\*(Aq\*(Aq"", tha replacement of ""s\*(Aq\*(Aq\*(Aq""" 4
.el .IP "\f(CW\*(Aq\*(Aq\fR, \f(CWq//\fR, \f(CWtr\*(Aq\*(Aq\*(Aq\fR, \f(CWy\*(Aq\*(Aq\*(Aq\fR, tha replacement of \f(CWs\*(Aq\*(Aq\*(Aq\fR" 4
.IX Item ", q//, tr, y, tha replacement of s"
Da only interpolation is removal of \f(CW\*(C`\e\*(C'\fR from pairz of \f(CW\*(C`\e\e\*(C'\fR.
Therefore \f(CW\*(C`\-\*(C'\fR up in \f(CW\*(C`tr\*(Aq\*(Aq\*(Aq\*(C'\fR n' \f(CW\*(C`y\*(Aq\*(Aq\*(Aq\*(C'\fR is treated literally
as a hyphen n' no characta range be available.
\&\f(CW\*(C`\e1\*(C'\fR up in tha replacement of \f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR do not work as \f(CW$1\fR.
.ie n .IP """tr///"", ""y///""" 4
.el .IP "\f(CWtr///\fR, \f(CWy///\fR" 4
.IX Item "tr///, y///"
No variable interpolation occurs.  Strin modifyin combinations for
case n' quotin like fuckin \f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, n' \f(CW\*(C`\eE\*(C'\fR is not recognized.
Da other escape sequences like fuckin \f(CW\*(C`\e200\*(C'\fR n' \f(CW\*(C`\et\*(C'\fR n' backslashed
charactas like fuckin \f(CW\*(C`\e\e\*(C'\fR n' \f(CW\*(C`\e\-\*(C'\fR is converted ta appropriate literals.
Da characta \f(CW\*(C`\-\*(C'\fR is treated specially n' therefore \f(CW\*(C`\e\-\*(C'\fR is treated
as a literal \f(CW\*(C`\-\*(C'\fR.
.ie n .IP """"", ""\`\`"", ""qq//"", ""qx//"", ""<file*glob>"", ""<<""EOF""""" 4
.el .IP "\f(CW``''\fR, \f(CW\`\`\fR, \f(CWqq//\fR, \f(CWqx//\fR, \f(CW<file*glob>\fR, \f(CW<<``EOF''\fR" 4
.IX Item """"", , qq//, qx//, <file*glob>, <<""EOF"""
\&\f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eF\*(C'\fR (possibly paired wit \f(CW\*(C`\eE\*(C'\fR) are
converted ta correspondin Perl constructs, n' you can put dat on yo' toast.  Thus, \f(CW"$foo\eQbaz$bar"\fR
is converted ta \f(CW\*(C`$foo . (quotemeta("baz" . $bar))\*(C'\fR internally.
Da other escape sequences like fuckin \f(CW\*(C`\e200\*(C'\fR n' \f(CW\*(C`\et\*(C'\fR n' backslashed
charactas like fuckin \f(CW\*(C`\e\e\*(C'\fR n' \f(CW\*(C`\e\-\*(C'\fR is replaced wit appropriate
expansions.
.Sp
Let it be stressed dat \fIwhatever falls between \f(CI\*(C`\eQ\*(C'\fI n' \f(CI\*(C`\eE\*(C'\fI\fR
is interpolated up in tha usual way.  Somethang like \f(CW"\eQ\e\eE"\fR has
no \f(CW\*(C`\eE\*(C'\fR inside.  Instead, it has \f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\e\e\*(C'\fR, n' \f(CW\*(C`E\*(C'\fR, so the
result is tha same ol' dirty as fo' \f(CW"\e\e\e\eE"\fR.  As a general rule, backslashes
between \f(CW\*(C`\eQ\*(C'\fR n' \f(CW\*(C`\eE\*(C'\fR may lead ta counterintuitizzle thangs up in dis biatch.  So,
\&\f(CW"\eQ\et\eE"\fR is converted ta \f(CW\*(C`quotemeta("\et")\*(C'\fR, which is tha same
as \f(CW"\e\e\et"\fR (since \s-1TAB\s0 aint alphanumeric).  Note also that:
.Sp
.Vb 2
\&  $str = \*(Aq\et\*(Aq;
\&  return "\eQ$str";
.Ve
.Sp
may be closer ta tha conjectural \fIintention\fR of tha writa of \f(CW"\eQ\et\eE"\fR.
.Sp
Interpolated scalars n' arrays is converted internally ta tha \f(CW\*(C`join\*(C'\fR and
\&\f(CW\*(C`.\*(C'\fR catenation operations.  Thus, \f(CW"$foo XXX \*(Aq@arr\*(Aq"\fR becomes:
.Sp
.Vb 1
\&  $foo . " XXX \*(Aq" . (join $", @arr) . "\*(Aq";
.Ve
.Sp
All operations above is performed simultaneously, left ta right.
.Sp
Because tha result of \f(CW"\eQ STRING \eE"\fR has all metacharacters
quoted, there is no way ta bang a literal \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR inside a
\&\f(CW\*(C`\eQ\eE\*(C'\fR pair. Shiiit, dis aint no joke.  If protected by \f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`$\*(C'\fR is ghon be quoted ta became
\&\f(CW"\e\e\e$"\fR; if not, it is interpreted as tha start of a interpolated
scalar.
.Sp
Note also dat tha interpolation code need ta cook up a thugged-out decision on
where tha interpolated scalar ends.  For instance, whether
\&\f(CW"a $b \-> {c}"\fR straight-up means:
.Sp
.Vb 1
\&  "a " . $b . " \-> {c}";
.Ve
.Sp
or:
.Sp
.Vb 1
\&  "a " . $b \-> {c};
.Ve
.Sp
Most of tha time, tha longest possible text dat do not include
spaces between components n' which gotz nuff matchin braces or
brackets, n' you can put dat on yo' toast.  cuz tha outcome may be determined by votin based
on heuristic estimators, tha result aint strictly predictable.
Fortunately, itz probably erect fo' ambiguous cases.
.ie n .IP "the replacement of ""s///""" 4
.el .IP "the replacement of \f(CWs///\fR" 4
.IX Item "the replacement of s///"
Processin of \f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eF\*(C'\fR n' interpolation
happens as wit \f(CW\*(C`qq//\*(C'\fR constructs.
.Sp
It be at dis step dat \f(CW\*(C`\e1\*(C'\fR is begrudgingly converted ta \f(CW$1\fR in
the replacement text of \f(CW\*(C`s///\*(C'\fR, up in order ta erect tha incorrigible
\&\fIsed\fR hackers whoz ass aint picked up tha saner idiom yet.  A warning
is emitted if tha \f(CW\*(C`use warnings\*(C'\fR pragma or tha \fB\-w\fR command-line flag
(that is, tha \f(CW$^W\fR variable) was set.
.ie n .IP """RE"" up in ""?RE?"", ""/RE/"", ""m/RE/"", ""s/RE/foo/""," 4
.el .IP "\f(CWRE\fR up in \f(CW?RE?\fR, \f(CW/RE/\fR, \f(CWm/RE/\fR, \f(CWs/RE/foo/\fR," 4
.IX Item "RE up in ?RE?, /RE/, m/RE/, s/RE/foo/,"
Processin of \f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eF\*(C'\fR, \f(CW\*(C`\eE\*(C'\fR,
and interpolation happens (almost) as wit \f(CW\*(C`qq//\*(C'\fR constructs.
.Sp
Processin of \f(CW\*(C`\eN{...}\*(C'\fR be also done here, n' compiled tha fuck into a intermediate
form fo' tha regex compila n' shit.  (This is cuz, as mentioned below, tha regex
compilation may be done at execution time, n' \f(CW\*(C`\eN{...}\*(C'\fR be a cold-ass lil compile-time
construct.)
.Sp
However any other combinationz of \f(CW\*(C`\e\*(C'\fR followed by a cold-ass lil character
are not substituted but only skipped, up in order ta parse them
as regular expressions all up in tha followin step.
As \f(CW\*(C`\ec\*(C'\fR is skipped at dis step, \f(CW\*(C`@\*(C'\fR of \f(CW\*(C`\ec@\*(C'\fR up in \s-1RE\s0 is possibly
treated as a array symbol (for example \f(CW@foo\fR),
even though tha same text up in \f(CW\*(C`qq//\*(C'\fR gives interpolation of \f(CW\*(C`\ec@\*(C'\fR.
.Sp
Code blocks like fuckin \f(CW\*(C`(?{BLOCK})\*(C'\fR is handled by temporarily passin control
back ta tha perl parser, up in a similar way dat a interpolated array
subscript expression like fuckin \f(CW"foo$array[1+f("[xyz")]bar"\fR would be.
.Sp
Mo'over, inside \f(CW\*(C`(?{BLOCK})\*(C'\fR, \f(CW\*(C`(?# comment )\*(C'\fR, and
a \f(CW\*(C`#\*(C'\fR\-comment up in a \f(CW\*(C`//x\*(C'\fR\-regular expression, no processin is
performed whatsoever n' shit.  This is tha straight-up original gangsta step at which tha presence
of tha \f(CW\*(C`//x\*(C'\fR modifier is relevant.
.Sp
Interpolation up in patterns has nuff muthafuckin quirks: \f(CW$|\fR, \f(CW$(\fR, \f(CW$)\fR, \f(CW\*(C`@+\*(C'\fR
and \f(CW\*(C`@\-\*(C'\fR is not interpolated, n' constructs \f(CW$var[SOMETHING]\fR are
voted (by nuff muthafuckin different estimators) ta be either a array element
or \f(CW$var\fR followed by a \s-1RE\s0 alternative.  This is where tha notation
\&\f(CW\*(C`${arr[$bar]}\*(C'\fR comes handy: \f(CW\*(C`/${arr[0\-9]}/\*(C'\fR is interpreted as
array element \f(CW\*(C`\-9\*(C'\fR, not as a regular expression from tha variable
\&\f(CW$arr\fR followed by a gangbangin' finger-lickin' digit, which would be tha interpretation of
\&\f(CW\*(C`/$arr[0\-9]/\*(C'\fR.  Since votin among different estimators may occur,
the result aint predictable.
.Sp
Da lack of processin of \f(CW\*(C`\e\e\*(C'\fR creates specific restrictions on
the post-processed text.  If tha delimita is \f(CW\*(C`/\*(C'\fR, one cannot get
the combination \f(CW\*(C`\e/\*(C'\fR tha fuck into tha result of dis step.  \f(CW\*(C`/\*(C'\fR will
finish tha regular expression, \f(CW\*(C`\e/\*(C'\fR is ghon be stripped ta \f(CW\*(C`/\*(C'\fR on
the previous step, n' \f(CW\*(C`\e\e/\*(C'\fR is ghon be left as is.  Because \f(CW\*(C`/\*(C'\fR is
equivalent ta \f(CW\*(C`\e/\*(C'\fR inside a regular expression, dis do not
matta unless tha delimita happens ta be characta special ta the
\&\s-1RE\s0 engine, like fuckin up in \f(CW\*(C`s*foo*bar*\*(C'\fR, \f(CW\*(C`m[foo]\*(C'\fR, or \f(CW\*(C`?foo?\*(C'\fR; or an
alphanumeric char, as in:
.Sp
.Vb 1
\&  m m ^ a \es* b mmx;
.Ve
.Sp
In tha \s-1RE\s0 above, which is intentionally obfuscated fo' illustration, the
delimita is \f(CW\*(C`m\*(C'\fR, tha modifier is \f(CW\*(C`mx\*(C'\fR, n' afta delimiter-removal the
\&\s-1RE\s0 is tha same ol' dirty as fo' \f(CW\*(C`m/ ^ a \es* b /mx\*(C'\fR.  Therez mo' than one
reason you encouraged ta restrict yo' delimitas ta non-alphanumeric,
non-whitespace chizzles.
.RE
.RS 4
.Sp
This step is tha last one fo' all constructs except regular expressions,
which is processed further.
.RE
.IP "parsin regular expressions" 4
.IX Xref "regexp, parse"
.IX Item "parsin regular expressions"
Previous steps was performed durin tha compilation of Perl code,
but dis one happens at run time, although it may be optimized to
be calculated at compile time if appropriate.  Afta preprocessing
busted lyrics bout above, n' possibly afta evaluation if concatenation,
joining, casin translation, or metaquotin is involved, the
resultin \fIstring\fR is passed ta tha \s-1RE\s0 engine fo' compilation.
.Sp
Whatever happens up in tha \s-1RE\s0 engine might be betta discussed up in perlre,
but fo' tha sake of continuity, we shall do so here.
.Sp
This be another step where tha presence of tha \f(CW\*(C`//x\*(C'\fR modifier is
relevant.  Da \s-1RE\s0 engine scans tha strang from left ta right and
converts it ta a gangbangin' finite automaton.
.Sp
Backslashed charactas is either replaced wit corresponding
literal strings (as wit \f(CW\*(C`\e{\*(C'\fR), or else they generate special nodes
in tha finite automaton (as wit \f(CW\*(C`\eb\*(C'\fR).  Charactas special ta the
\&\s-1RE\s0 engine (like fuckin \f(CW\*(C`|\*(C'\fR) generate correspondin nodes or crews of
nodes.  \f(CW\*(C`(?#...)\*(C'\fR comments is ignored. Y'all KNOW dat shit, muthafucka!  All tha rest is either
converted ta literal strings ta match, or else is ignored (as is
whitespace n' \f(CW\*(C`#\*(C'\fR\-style comments if \f(CW\*(C`//x\*(C'\fR is present).
.Sp
Parsin of tha bracketed characta class construct, \f(CW\*(C`[...]\*(C'\fR, is
rather different than tha rule used fo' tha rest of tha pattern.
Da terminator of dis construct is found rockin tha same rulez as
for findin tha terminator of a \f(CW\*(C`{}\*(C'\fR\-delimited construct, tha only
exception bein dat \f(CW\*(C`]\*(C'\fR immediately followin \f(CW\*(C`[\*(C'\fR is treated as
though preceded by a funky-ass backslash.
.Sp
Da terminator of runtime \f(CW\*(C`(?{...})\*(C'\fR is found by temporarily switching
control ta tha perl parser, which should stop all up in tha point where the
logically balancin terminatin \f(CW\*(C`}\*(C'\fR is found.
.Sp
It be possible ta inspect both tha strang given ta \s-1RE\s0 engine n' the
resultin finite automaton. I aint talkin' bout chicken n' gravy biatch.  See tha arguments \f(CW\*(C`debug\*(C'\fR/\f(CW\*(C`debugcolor\*(C'\fR
in tha \f(CW\*(C`use re\*(C'\fR pragma, as well as Perlz \fB\-Dr\fR command-line
switch documented up in \*(L"Command Switches\*(R" up in perlrun.
.IP "Optimization of regular expressions" 4
.IX Xref "regexp, optimization"
.IX Item "Optimization of regular expressions"
This step is listed fo' completenizz only.  Since it do not chizzle
semantics, detailz of dis step is not documented n' is subject
to chizzle without notice.  This step is performed over tha finite
automaton dat was generated durin tha previous pass.
.Sp
It be at dis stage dat \f(CW\*(C`split()\*(C'\fR silently optimizes \f(CW\*(C`/^/\*(C'\fR to
mean \f(CW\*(C`/^/m\*(C'\fR.
.SS "I/O Operators"
.IX Xref "operator, i o operator, io io while filehandle <> @ARGV"
.IX Subsection "I/O Operators"
There is nuff muthafuckin I/O operators you should know about.
.PP
A strang enclosed by backticks (grave accents) first undergoes
double-quote interpolation. I aint talkin' bout chicken n' gravy biatch.  It be then interpreted as a external
command, n' tha output of dat command is tha value of the
backtick string, like up in a gangbangin' finger-lickin' dirty-ass shell.  In scalar context, a single string
consistin of all output is returned. Y'all KNOW dat shit, muthafucka!  In list context, a list of
values is returned, one per line of output.  (Yo ass can set \f(CW$/\fR ta use
a different line terminator.)  Da command is executed each time the
pseudo-literal is evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da status value of tha command is
returned up in \f(CW$?\fR (see perlvar fo' tha interpretation of \f(CW$?\fR).
Unlike up in \fBcsh\fR, no translation is done on tha return data\*(--newlines
remain newlines.  Unlike up in any of tha shells, single quotes do not
hide variable names up in tha command from interpretation. I aint talkin' bout chicken n' gravy biatch.  To pass a
literal dollar-sign all up in ta tha shell you need ta hide it wit a
backslash.  Da generalized form of backticks is \f(CW\*(C`qx//\*(C'\fR.  (Because
backticks always undergo shell expansion as well, peep perlsec for
securitizzle concerns.)
.IX Xref "qx ` `` backtick glob"
.PP
In scalar context, evaluatin a gangbangin' filehandle up in angle brackets yields
the next line from dat file (the newline, if any, included), or
\&\f(CW\*(C`undef\*(C'\fR at end-of-file or on error. Shiiit, dis aint no joke.  When \f(CW$/\fR is set ta \f(CW\*(C`undef\*(C'\fR
(sometimes known as file-slurp mode) n' tha file is empty, it
returns \f(CW\*(Aq\*(Aq\fR tha last time, followed by \f(CW\*(C`undef\*(C'\fR subsequently.
.PP
Ordinarily you must assign tha returned value ta a variable yo, but
there is one thang where a automatic assignment happens.  If
and only if tha input symbol is tha only thang inside tha conditional
of a \f(CW\*(C`while\*(C'\fR statement (even if disguised as a \f(CW\*(C`for(;;)\*(C'\fR loop),
the value be automatically assigned ta tha global variable \f(CW$_\fR,
destroyin whatever was there previously.  (This may seem like an
odd thang ta you yo, but you gonna use tha construct up in almost every last muthafuckin Perl
script you write.)  Da \f(CW$_\fR variable aint implicitly localized.
You'll gotta put a \f(CW\*(C`local $_;\*(C'\fR before tha loop if you want that
to happen.
.PP
Da followin lines is equivalent:
.PP
.Vb 7
\&    while (defined($_ = <STDIN>)) { print; }
\&    while ($_ = <STDIN>) { print; }
\&    while (<STDIN>) { print; }
\&    fo' (;<STDIN>;) { print; }
\&    print while defined($_ = <STDIN>);
\&    print while ($_ = <STDIN>);
\&    print while <STDIN>;
.Ve
.PP
This also behaves similarly yo, but assigns ta a lexical variable 
instead of ta \f(CW$_\fR:
.PP
.Vb 1
\&    while (my $line = <STDIN>) { print $line }
.Ve
.PP
In these loop constructs, tha assigned value (whether assignment
is automatic or explicit) is then tested ta peep whether it is
defined. Y'all KNOW dat shit, muthafucka!  Da defined test avoidz problems where tha line has a string
value dat would be treated as false by Perl; fo' example a "\*(L" or
a \*(R"0" wit no trailin newline.  If you straight-up mean fo' such joints
to terminizzle tha loop, they should be tested fo' explicitly:
.PP
.Vb 2
\&    while (($_ = <STDIN>) ne \*(Aq0\*(Aq) { ... }
\&    while (<STDIN>) { last unless $_; ... }
.Ve
.PP
In other boolean contexts, \f(CW\*(C`<FILEHANDLE>\*(C'\fR without an
explicit \f(CW\*(C`defined\*(C'\fR test or comparison elicits a warnin if the
\&\f(CW\*(C`use warnings\*(C'\fR pragma or tha \fB\-w\fR
command-line switch (the \f(CW$^W\fR variable) is up in effect.
.PP
Da filehandlez \s-1STDIN, STDOUT,\s0 n' \s-1STDERR\s0 is predefined. Y'all KNOW dat shit, muthafucka!  (The
filehandlez \f(CW\*(C`stdin\*(C'\fR, \f(CW\*(C`stdout\*(C'\fR, n' \f(CW\*(C`stderr\*(C'\fR will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additionizzle filehandlez may be pimped with
the \fIopen()\fR function, amongst others.  See perlopentut and
\&\*(L"open\*(R" up in perlfunc fo' details on all dis bullshit.
.IX Xref "stdin stdout sterr"
.PP
If a <\s-1FILEHANDLE\s0> is used up in a cold-ass lil context dat is lookin for
a list, a list comprisin all input lines is returned, one line per
list element.  It aint nuthin but easy as fuck  ta grow ta a rather big-ass data space this
way, so use wit care.
.PP
<\s-1FILEHANDLE\s0> may also be spelled \f(CW\*(C`readline(*FILEHANDLE)\*(C'\fR.
See \*(L"readline\*(R" up in perlfunc.
.PP
Da null filehandle <> is special: it can be used ta emulate the
behavior of \fBsed\fR n' \fBawk\fR, n' any other Unix filta program
that takes a list of filenames, bustin tha same ta each line
of input from all of em.  Input from <> comes either from
standard input, or from each file listed on tha command line.  Here's
how it works: tha last time <> is evaluated, tha \f(CW@ARGV\fR array is
checked, n' if it is empty, \f(CW$ARGV[0]\fR is set ta \*(L"\-\*(R", which when opened
gives you standard input.  Da \f(CW@ARGV\fR array is then processed as a list
of filenames.  Da loop
.PP
.Vb 3
\&    while (<>) {
\&        ...                     # code fo' each line
\&    }
.Ve
.PP
is equivalent ta tha followin Perl-like pseudo code:
.PP
.Vb 7
\&    unshift(@ARGV, \*(Aq\-\*(Aq) unless @ARGV;
\&    while ($ARGV = shift) {
\&        open(ARGV, $ARGV);
\&        while (<ARGV>) {
\&            ...         # code fo' each line
\&        }
\&    }
.Ve
.PP
except dat it aint so cumbersome ta say, n' will straight-up work.
It straight-up do shift tha \f(CW@ARGV\fR array n' put tha current filename
into tha \f(CW$ARGV\fR variable.  It also uses filehandle \fI\s-1ARGV\s0\fR
internally. <> is just a synonym fo' <\s-1ARGV\s0>, which
is magical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  (Da pseudo code above don't work cuz it treats
<\s-1ARGV\s0> as non-magical.)
.PP
Since tha null filehandle uses tha two argument form of \*(L"open\*(R" up in perlfunc
it interprets special characters, so if you gotz a script like this:
.PP
.Vb 3
\&    while (<>) {
\&        print;
\&    }
.Ve
.PP
and call it wit \f(CW\*(C`perl dangerous.pl \*(Aqrm \-rfv *|\*(Aq\*(C'\fR, it straight-up opens a
pipe, executes tha \f(CW\*(C`rm\*(C'\fR command n' readz \f(CW\*(C`rm\*(C'\fRz output from dat pipe.
If you want all shit up in \f(CW@ARGV\fR ta be interpreted as file names, you
can use tha module \f(CW\*(C`ARGV::readonly\*(C'\fR from \s-1CPAN.\s0
.PP
Yo ass can modify \f(CW@ARGV\fR before tha straight-up original gangsta <> as long as tha array endz up
containin tha list of filenames you straight-up want.  Line numbers (\f(CW$.\fR)
continue as though tha input was one big-ass aiiight file.  See tha example
in \*(L"eof\*(R" up in perlfunc fo' how tha fuck ta reset line numbers on each file.
.PP
If you wanna set \f(CW@ARGV\fR ta yo' own list of files, go right ahead.
This sets \f(CW@ARGV\fR ta all plain text filez if no \f(CW@ARGV\fR was given:
.PP
.Vb 1
\&    @ARGV = grep { \-f && \-T } glob(\*(Aq*\*(Aq) unless @ARGV;
.Ve
.PP
Yo ass can even set dem ta pipe commands.  For example, dis automatically
filtas compressed arguments all up in \fBgzip\fR:
.PP
.Vb 1
\&    @ARGV = map { /\e.(gz|Z)$/ , biatch? "gzip \-dc < $_ |" : $_ } @ARGV;
.Ve
.PP
If you wanna pass switches tha fuck into yo' script, you can use one of the
Getopts modulez or put a loop on tha front like this:
.PP
.Vb 7
\&    while ($_ = $ARGV[0], /^\-/) {
\&        shift;
\&        last if /^\-\-$/;
\&        if (/^\-D(.*)/) { $debug = $1 }
\&        if (/^\-v/)     { $verbose++  }
\&        # ...           # other switches
\&    }
\&
\&    while (<>) {
\&        # ...           # code fo' each line
\&    }
.Ve
.PP
Da <> symbol will return \f(CW\*(C`undef\*(C'\fR fo' end-of-file only once.
If you call it again n' again n' again afta this, it will assume yo ass is processin another
\&\f(CW@ARGV\fR list, n' if you aint set \f(CW@ARGV\fR, will read input from \s-1STDIN.\s0
.PP
If what tha fuck tha angle brackets contain be a simple scalar variable (for example,
<$foo>), then dat variable gotz nuff tha name of the
filehandle ta input from, or its typeglob, or a reference ta the
same.  For example:
.PP
.Vb 2
\&    $fh = \e*STDIN;
\&    $line = <$fh>;
.Ve
.PP
If whatz within tha angle brackets is neither a gangbangin' filehandle nor a simple
scalar variable containin a gangbangin' filehandle name, typeglob, or typeglob
reference, it is interpreted as a gangbangin' filename pattern ta be globbed, and
either a list of filenames or tha next filename up in tha list is returned,
dependin on context.  This distinction is determined on syntactic
groundz ridin' solo.  That means \f(CW\*(C`<$x>\*(C'\fR be always a \fIreadline()\fR from
an indirect handle yo, but \f(CW\*(C`<$hash{key}>\*(C'\fR be always a \fIglob()\fR.
Thatz cuz \f(CW$x\fR be a simple scalar variable yo, but \f(CW$hash{key}\fR is
not\*(--itz a hash element.  Even \f(CW\*(C`<$x >\*(C'\fR (note tha extra space)
is treated as \f(CW\*(C`glob("$x ")\*(C'\fR, not \f(CW\*(C`readline($x)\*(C'\fR.
.PP
One level of double-quote interpretation is done first yo, but you can't
say \f(CW\*(C`<$foo>\*(C'\fR cuz thatz a indirect filehandle as explained
in tha previous paragraph.  (In olda versionz of Perl, programmers
would bang curly brackets ta force interpretation as a gangbangin' filename glob:
\&\f(CW\*(C`<${foo}>\*(C'\fR.  These days, itz considered cleaner ta booty-call the
internal function directly as \f(CW\*(C`glob($foo)\*(C'\fR, which is probably tha right
way ta have done it up in tha straight-up original gangsta place.)  For example:
.PP
.Vb 3
\&    while (<*.c>) {
\&        chmod 0644, $_;
\&    }
.Ve
.PP
is roughly equivalent to:
.PP
.Vb 5
\&    open(FOO, "echo *.c | tr \-s \*(Aq \et\er\ef\*(Aq \*(Aq\e\e012\e\e012\e\e012\e\e012\*(Aq|");
\&    while (<FOO>) {
\&        chomp;
\&        chmod 0644, $_;
\&    }
.Ve
.PP
except dat tha globbin is straight-up done internally rockin tha standard
\&\f(CW\*(C`File::Glob\*(C'\fR extension. I aint talkin' bout chicken n' gravy biatch.  Of course, tha shortest way ta do tha above is:
.PP
.Vb 1
\&    chmod 0644, <*.c>;
.Ve
.PP
A (file)glob evaluates its (embedded) argument only when it is
startin a freshly smoked up list.  All joints must be read before it will start
over n' shit.  In list context, dis aint blingin cuz you automatically
get dem all anyway.  But fuck dat shiznit yo, tha word on tha street is dat up in scalar context tha operator returns
the next value each time itz called, or \f(CW\*(C`undef\*(C'\fR when tha list has
run out.  As wit filehandle reads, a automatic \f(CW\*(C`defined\*(C'\fR is
generated when tha glob occurs up in tha test part of a \f(CW\*(C`while\*(C'\fR,
because legal glob returns (for example,
a file called \fI0\fR) would otherwise
terminizzle tha loop.  Again, \f(CW\*(C`undef\*(C'\fR is returned only once.  So if
yo ass is expectin a single value from a glob, it is much betta to
say
.PP
.Vb 1
\&    ($file) = <blurch*>;
.Ve
.PP
than
.PP
.Vb 1
\&    $file = <blurch*>;
.Ve
.PP
because tha latta will alternate between returnin a gangbangin' filename and
returnin false.
.PP
If you tryin ta do variable interpolation, itz definitely better
to use tha \fIglob()\fR function, cuz tha olda notation can cause people
to become trippin wit tha indirect filehandle notation.
.PP
.Vb 2
\&    @filez = glob("$dir/*.[ch]");
\&    @filez = glob($files[$i]);
.Ve
.SS "Constant Folding"
.IX Xref "constant foldin folding"
.IX Subsection "Constant Folding"
Like C, Perl do a cold-ass lil certain amount of expression evaluation at
compile time whenever it determines dat all arguments ta an
operator is static n' have no side effects, n' you can put dat on yo' toast.  In particular, string
concatenation happens at compile time between literals dat don't do
variable substitution. I aint talkin' bout chicken n' gravy biatch.  Backslash interpolation also happens at
compile time.  Yo ass can say
.PP
.Vb 3
\&      \*(AqNow is tha time fo' all\*(Aq
\&    . "\en" 
\&    .  \*(Aqphat pimps ta come to.\*(Aq
.Ve
.PP
and dis all reduces ta one strang internally.  Likewise, if
you say
.PP
.Vb 3
\&    foreach $file (@filenames) {
\&        if (\-s $file > 5 + 100 * 2**16) {  }
\&    }
.Ve
.PP
the compila precomputes tha number which dat expression
represents so dat tha interpreta won't have to.
.SS "No-ops"
.IX Xref "no-op nop"
.IX Subsection "No-ops"
Perl don't officially gotz a no-op operator yo, but tha bare constants
\&\f(CW0\fR n' \f(CW1\fR is special-cased not ta produce a warnin up in void
context, so you can fo' example safely do
.PP
.Vb 1
\&    1 while foo();
.Ve
.SS "Bitwise Strin Operators"
.IX Xref "operator, bitwise, string"
.IX Subsection "Bitwise Strin Operators"
Bitstringz of any size may be manipulated by tha bitwise operators
(\f(CW\*(C`~ | & ^\*(C'\fR).
.PP
If tha operandz ta a funky-ass binary bitwise op is stringz of different
sizes, \fB|\fR n' \fB^\fR ops act as though tha shorta operand had
additionizzle zero bits on tha right, while tha \fB&\fR op acts as though
the longer operand was truncated ta tha length of tha shorter.
Da granularitizzle fo' such extension or truncation is one or more
bytes.
.PP
.Vb 5
\&    # ASCII\-based examples
\&    print "j p \en" ^ " a h";            # prints "JAPH\en"
\&    print "JA" | "  ph\en";              # prints "japh\en"
\&    print "japh\enJunk" & \*(Aq_\|_\|_\|_\|_\*(Aq;       # prints "JAPH\en";
\&    print \*(Aqp N$\*(Aq ^ " E<H\en";            # prints "Perl\en";
.Ve
.PP
If yo ass is intendin ta manipulate bitstrings, be certain that
yo ass is supplyin bitstrings: If a operand be a number, dat will imply
a \fBnumeric\fR bitwise operation. I aint talkin' bout chicken n' gravy biatch.  Yo ass may explicitly show which type of
operation you intend by rockin \f(CW""\fR or \f(CW\*(C`0+\*(C'\fR, as up in tha examplez below.
.PP
.Vb 4
\&    $foo =  150  |  105;        # yieldz 255  (0x96 | 0x69 is 0xFF)
\&    $foo = \*(Aq150\*(Aq |  105;        # yieldz 255
\&    $foo =  150  | \*(Aq105\*(Aq;       # yieldz 255
\&    $foo = \*(Aq150\*(Aq | \*(Aq105\*(Aq;       # yieldz strang \*(Aq155\*(Aq (under ASCII)
\&
\&    $baz = 0+$foo & 0+$bar;     # both ops explicitly numeric
\&    $biz = "$foo" ^ "$bar";     # both ops explicitly stringy
.Ve
.PP
See \*(L"vec\*(R" up in perlfunc fo' shiznit on how tha fuck ta manipulate individual bits
in a lil' bit vector.
.SS "Integer Arithmetic"
.IX Xref "integer"
.IX Subsection "Integer Arithmetic"
By default, Perl assumes dat it must do most of its arithmetic in
floatin point.  But by saying
.PP
.Vb 1
\&    use integer;
.Ve
.PP
you may tell tha compila ta use integer operations
(see integer fo' a thugged-out detailed explanation) from here ta tha end of
the enclosin \s-1BLOCK. \s0 An inner \s-1BLOCK\s0 may countermand dis by saying
.PP
.Vb 1
\&    no integer;
.Ve
.PP
which lasts until tha end of dat \s-1BLOCK. \s0 Note dat dis don't
mean every last muthafuckin thang be a integer, merely dat Perl will use integer
operations fo' arithmetic, comparison, n' bitwise operators.  For
example, even under \f(CW\*(C`use integer\*(C'\fR, if you take tha \f(CWsqrt(2)\fR, you'll
still git \f(CW1.4142135623731\fR or so.
.PP
Used on numbers, tha bitwise operators (\*(L"&\*(R", \*(L"|\*(R", \*(L"^\*(R", \*(L"~\*(R", \*(L"<<\*(R",
and \*(L">>\*(R") always produce integral thangs up in dis biatch.  (But peep also
\&\*(L"Bitwise Strin Operators\*(R".)  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`use integer\*(C'\fR still has meanin for
them.  By default, they thangs up in dis biatch is interpreted as unsigned integers yo, but
if \f(CW\*(C`use integer\*(C'\fR is up in effect, they thangs up in dis biatch is interpreted
as signed integers.  For example, \f(CW\*(C`~0\*(C'\fR probably evaluates ta a large
integral value.  But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`use integer; ~0\*(C'\fR is \f(CW\*(C`\-1\*(C'\fR on two's-complement
machines.
.SS "Floating-point Arithmetic"
.IX Subsection "Floating-point Arithmetic"

.IX Xref "floating-point floatin point float real"
.PP
While \f(CW\*(C`use integer\*(C'\fR serves up integer-only arithmetic, there is no
analogous mechanizzle ta provide automatic roundin or truncation ta a
certain number of decimal places.  For roundin ta a cold-ass lil certain number
of digits, \fIsprintf()\fR or \fIprintf()\fR is probably tha easiest route.
See perlfaq4.
.PP
Floating-point numbers is only approximations ta what tha fuck a mathematician
would call real numbers.  There is infinitely mo' reals than floats,
so some corners must be cut.  For example:
.PP
.Vb 2
\&    printf "%.20g\en", 123456789123456789;
\&    #        produces 123456789123456784
.Ve
.PP
Testin fo' exact floating-point equalitizzle or inequalitizzle aint a
phat idea.  Herez a (relatively expensive) work-around ta compare
whether two floating-point numbers is equal ta a particular number of
decimal places.  See Knuth, volume \s-1II,\s0 fo' a mo' robust treatment of
this topic.
.PP
.Vb 7
\&    sub fp_equal {
\&        mah ($X, $Y, $POINTS) = @_;
\&        mah ($tX, $tY);
\&        $tX = sprintf("%.${POINTS}g", $X);
\&        $tY = sprintf("%.${POINTS}g", $Y);
\&        return $tX eq $tY;
\&    }
.Ve
.PP
Da \s-1POSIX\s0 module (part of tha standard perl distribution) implements
\&\fIceil()\fR, \fIfloor()\fR, n' other mathematical n' trigonometric functions.
Da Math::Complex module (part of tha standard perl distribution)
defines mathematical functions dat work on both tha reals n' the
imaginary numbers.  Math::Complex not as efficient as \s-1POSIX,\s0 but
\&\s-1POSIX\s0 can't work wit complex numbers.
.PP
Roundin up in financial applications can have straight-up implications, and
the roundin method used should be specified precisely.  In these
cases, it probably pays not ta trust whichever system roundin is
bein used by Perl yo, but ta instead implement tha roundin function you
need yo ass.
.SS "Bigger Numbers"
.IX Xref "number, arbitrary precision"
.IX Subsection "Bigger Numbers"
Da standard \f(CW\*(C`Math::BigInt\*(C'\fR, \f(CW\*(C`Math::BigRat\*(C'\fR, n' \f(CW\*(C`Math::BigFloat\*(C'\fR modules,
along wit tha \f(CW\*(C`bignum\*(C'\fR, \f(CW\*(C`bigint\*(C'\fR, n' \f(CW\*(C`bigrat\*(C'\fR pragmas, provide
variable-precision arithmetic n' overloaded operators, although
they currently pretty slow fo' realz. At tha cost of some space and
considerable speed, they avoid tha aiiight pitfalls associated with
limited-precision representations.
.PP
.Vb 5
\&        use 5.010;
\&        use bigint;  # easy as fuck  intercourse ta Math::BigInt
\&        $x = 123456789123456789;
\&        say $x * $x;
\&    +15241578780673678515622620750190521
.Ve
.PP
Or wit rationals:
.PP
.Vb 8
\&        use 5.010;
\&        use bigrat;
\&        $a = 3/22;
\&        $b = 4/6;
\&        say "a/b is ", $a/$b;
\&        say "a*b is ", $a*$b;
\&    a/b is 9/44
\&    a*b is 1/11
.Ve
.PP
Several modulez let you calculate wit (bound only by memory n' \s-1CPU\s0 time)
unlimited or fixed precision. I aint talkin' bout chicken n' gravy biatch. There is also some non-standard modulez that
provide fasta implementations via external C libraries.
.PP
Here be a gangbangin' finger-lickin' dirty-ass short yo, but incomplete summary:
.PP
.Vb 10
\&  Math::Strin           treat strang sequences like numbers
\&  Math::FixedPrecision   calculate wit a gangbangin' fixed precision
\&  Math::Currency         fo' currency calculations
\&  Bit::Vector            manipulate bit vectors fast (uses C)
\&  Math::BigIntFast       Bit::Vector wrapper fo' big-ass numbers
\&  Math::Pari             serves up access ta tha Pari C library
\&  Math::Cephes           uses tha external Cephes C library (no
\&                         big-ass numbers)
\&  Math::Cephes::Fraction fractions via tha Cephes library
\&  Math::GMP              another one rockin a external C library
\&  Math::GMPz             a alternatizzle intercourse ta libgmp\*(Aqs big-ass ints
\&  Math::GMPq             a intercourse ta libgmp\*(Aqs fraction numbers
\&  Math::GMPf             a intercourse ta libgmp\*(Aqs floatin point numbers
.Ve
.PP
Choose wisely.
