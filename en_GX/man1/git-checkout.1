'\" t
.\"     Title: git-checkout
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-CHECKOUT" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-checkout \- Checkout a funky-ass branch or paths ta tha hustlin tree
.SH "SYNOPSIS"
.sp
.nf
\fIgit checkout\fR [\-q] [\-f] [\-m] [<branch>]
\fIgit checkout\fR [\-q] [\-f] [\-m] \-\-detach [<branch>]
\fIgit checkout\fR [\-q] [\-f] [\-m] [\-\-detach] <commit>
\fIgit checkout\fR [\-q] [\-f] [\-m] [[\-b|\-B|\-\-orphan] <new_branch>] [<start_point>]
\fIgit checkout\fR [\-f|\-\-ours|\-\-theirs|\-m|\-\-conflict=<style>] [<tree\-ish>] [\-\-] <paths>\&...
\fIgit checkout\fR [\-p|\-\-patch] [<tree\-ish>] [\-\-] [<paths>\&...]
.fi
.sp
.SH "DESCRIPTION"
.sp
Updates filez up in tha hustlin tree ta match tha version up in tha index or tha specified tree\&. If no paths is given, \fIgit checkout\fR will also update HEAD ta set tha specified branch as tha current branch\&.
.PP
\fIgit checkout\fR <branch>
.RS 4
To prepare fo' hustlin on <branch>, switch ta it by uppimpin tha index n' tha filez up in tha hustlin tree, n' by pointin HEAD all up in tha branch\&. Local modifications ta tha filez up in tha hustlin tree is kept, so dat they can be committed ta tha <branch>\&.
.sp
If <branch> aint found but there do exist a trackin branch up in exactly one remote (call it <remote>) wit a matchin name, treat as equivalent to
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-b <branch> \-\-track <remote>/<branch>
.fi
.if n \{\
.RE
.\}
.sp
Yo ass could omit <branch>, up in which case tha command degenerates ta "check up tha current branch", which be a glorified no\-op wit a rather high-rollin' side\-effects ta show only tha trackin shiznit, if exists, fo' tha current branch\&.
.RE
.PP
\fIgit checkout\fR \-b|\-B <new_branch> [<start point>]
.RS 4
Specifying
\-b
causes a freshly smoked up branch ta be pimped as if
\fBgit-branch\fR(1)
were called n' then checked out\&. In dis case you can use the
\-\-track
or
\-\-no\-track
options, which is ghon be passed to
\fIgit branch\fR\& fo' realz. As a cold-ass lil convenience,
\-\-track
without
\-b
implies branch creation; peep tha description of
\-\-track
below\&.
.sp
If
\-B
is given, <new_branch> is pimped if it don\(cqt exist; otherwise, it is reset\&. This is tha transactionizzle equivalent of
.sp
.if n \{\
.RS 4
.\}
.nf
$ git branch \-f <branch> [<start point>]
$ git checkout <branch>
.fi
.if n \{\
.RE
.\}
.sp
that is ta say, tha branch aint reset/created unless "git checkout" is successful\&.
.RE
.PP
\fIgit checkout\fR \-\-detach [<branch>], \fIgit checkout\fR [\-\-detach] <commit>
.RS 4
Prepare ta work on top of <commit>, by detachin HEAD at it (see "DETACHED HEAD" section), n' uppimpin tha index n' tha filez up in tha hustlin tree\&. Local modifications ta tha filez up in tha hustlin tree is kept, so dat tha resultin hustlin tree is ghon be tha state recorded up in tha commit plus tha local modifications\&.
.sp
When tha <commit> argument be a funky-ass branch name, the
\-\-detach
option can be used ta detach HEAD all up in tha tip of tha branch (git checkout <branch>
would check up dat branch without detachin HEAD)\&.
.sp
Omittin <branch> detaches HEAD all up in tha tip of tha current branch\&.
.RE
.PP
\fIgit checkout\fR [\-p|\-\-patch] [<tree\-ish>] [\-\-] <pathspec>\&...
.RS 4
When <paths> or
\-\-patch
are given,
\fIgit checkout\fR
does
\fBnot\fR
switch branches\&. Well shiiiit, it thugged-out shiznit tha named paths up in tha hustlin tree from tha index file or from a named <tree\-ish> (most often a cold-ass lil commit)\&. In dis case, the
\-b
and
\-\-track
options is meaningless n' givin either of dem thangs up in dis biatch up in a error\&. Da <tree\-ish> argument can be used ta specify a specific tree\-ish (i\&.e\&. commit, tag or tree) ta update tha index fo' tha given paths before uppimpin tha hustlin tree\&.
.sp
Da index may contain unmerged entries cuz of a previous failed merge\&. By default, if you try ta check up such a entry from tha index, tha checkout operation will fail n' not a god damn thang is ghon be checked out\&. Using
\-f
will ignore these unmerged entries\&. Da contents from a specific side of tha merge can be checked outta tha index by using
\-\-ours
or
\-\-theirs\&. With
\-m, chizzlez made ta tha hustlin tree file can be discarded ta re\-create tha original gangsta conflicted merge result\&.
.RE
.SH "OPTIONS"
.PP
\-q, \-\-quiet
.RS 4
Quiet, suppress feedback lyrics\&.
.RE
.PP
\-f, \-\-force
.RS 4
When switchin branches, proceed even if tha index or tha hustlin tree differs from HEAD\&. This is used ta throw away local chizzles\&.
.sp
When checkin up paths from tha index, do not fail upon unmerged entries; instead, unmerged entries is ignored\&.
.RE
.PP
\-\-ours, \-\-theirs
.RS 4
When checkin up paths from tha index, check up stage #2 (\fIours\fR) or #3 (\fItheirs\fR) fo' unmerged paths\&.
.RE
.PP
\-b <new_branch>
.RS 4
Smoke a freshly smoked up branch named <new_branch> n' start it at <start_point>; see
\fBgit-branch\fR(1)
for details\&.
.RE
.PP
\-B <new_branch>
.RS 4
Creates tha branch <new_branch> n' start it at <start_point>; if it already exists, then reset it ta <start_point>\&. This is equivalent ta hustlin "git branch" wit "\-f"; see
\fBgit-branch\fR(1)
for details\&.
.RE
.PP
\-t, \-\-track
.RS 4
When bustin a freshly smoked up branch, set up "upstream" configuration\&. Right back up in yo muthafuckin ass. See "\-\-track" in
\fBgit-branch\fR(1)
for details\&.
.sp
If no
\fI\-b\fR
option is given, tha name of tha freshly smoked up branch is ghon be derived from tha remote\-trackin branch, by lookin all up in tha local part of tha refspec configured fo' tha correspondin remote, n' then strippin tha initial part up ta tha "*"\&. This would tell our asses ta use "hack" as tha local branch when branchin off of "origin/hack" (or "remotes/origin/hack", or even "refs/remotes/origin/hack")\&. If tha given name has no slash, or tha above guessin thangs up in dis biatch up in a empty name, tha guessin be aborted\&. Yo ass can explicitly give a name with
\fI\-b\fR
in such a cold-ass lil case\&.
.RE
.PP
\-\-no\-track
.RS 4
Do not set up "upstream" configuration, even if tha branch\&.autosetupmerge configuration variable is true\&.
.RE
.PP
\-l
.RS 4
Smoke tha freshly smoked up branch\(cqs reflog; see
\fBgit-branch\fR(1)
for details\&.
.RE
.PP
\-\-detach
.RS 4
Rather than checkin up a funky-ass branch ta work on it, check up a cold-ass lil commit fo' inspection n' discardable experiments\&. This is tha default behavior of "git checkout <commit>" when <commit> aint a funky-ass branch name\&. Right back up in yo muthafuckin ass. See tha "DETACHED HEAD" section below fo' details\&.
.RE
.PP
\-\-orphan <new_branch>
.RS 4
Smoke a new
\fIorphan\fR
branch, named <new_branch>, started from <start_point> n' switch ta it\&. Da first commit made on dis freshly smoked up branch gonna git no muthafathas n' it is ghon be tha root of a freshly smoked up history straight-up disconnected from all tha other branches n' commits\&.
.sp
Da index n' tha hustlin tree is adjusted as if you had previously run "git checkout <start_point>"\&. This allows you ta start a freshly smoked up history dat recordz a set of paths similar ta <start_point> by easily hustlin "git commit \-a" ta make tha root commit\&.
.sp
This can be useful when you wanna publish tha tree from a cold-ass lil commit without exposin its full history\&. Yo ass might wanna do dis ta publish a open source branch of a project whose current tree is "clean" yo, but whose full history gotz nuff proprietary or otherwise encumbered bitz of code\&.
.sp
If you wanna start a gangbangin' finger-lickin' disconnected history dat recordz a set of paths dat is straight-up different from tha one of <start_point>, then you should clear tha index n' tha hustlin tree right afta bustin tha orphan branch by hustlin "git rm \-rf \&." from tha top level of tha hustlin tree\& fo' realz. Afterwardz yo big-ass booty is ghon be locked n loaded ta prepare yo' freshly smoked up files, repopulatin tha hustlin tree, by copyin dem from elsewhere, extractin a tarball, etc\&.
.RE
.PP
\-\-ignore\-skip\-worktree\-bits
.RS 4
In sparse checkout mode,
git checkout \-\- <paths>
would update only entries matched by <paths> n' sparse patterns up in $GIT_DIR/info/sparse\-checkout\&. This option ignores tha sparse patterns n' addz back any filez up in <paths>\&.
.RE
.PP
\-m, \-\-merge
.RS 4
When switchin branches, if you have local modifications ta one or mo' filez dat is different between tha current branch n' tha branch ta which yo ass is switching, tha command refuses ta switch branches up in order ta preserve yo' modifications up in context\&. But fuck dat shiznit yo, tha word on tha street is dat wit dis option, a three\-way merge between tha current branch, yo' hustlin tree contents, n' tha freshly smoked up branch is done, n' yo big-ass booty is ghon be on tha freshly smoked up branch\&.
.sp
When a merge conflict happens, tha index entries fo' conflictin paths is left unmerged, n' you need ta resolve tha conflicts n' mark tha resolved paths with
git add
(or
git rm
if tha merge should result up in deletion of tha path)\&.
.sp
When checkin up paths from tha index, dis option lets you recreate tha conflicted merge up in tha specified paths\&.
.RE
.PP
\-\-conflict=<style>
.RS 4
Da same as \-\-merge option above yo, but chizzlez tha way tha conflictin hunks is presented, overridin tha merge\&.conflictstyle configuration variable\&. Possible joints is "merge" (default) n' "diff3" (in addizzle ta what tha fuck is shown by "merge" style, shows tha original gangsta contents)\&.
.RE
.PP
\-p, \-\-patch
.RS 4
Interactively select hunks up in tha difference between tha <tree\-ish> (or tha index, if unspecified) n' tha hustlin tree\&. Da chosen hunks is then applied up in reverse ta tha hustlin tree (and if a <tree\-ish> was specified, tha index)\&.
.sp
This means dat you can use
git checkout \-p
to selectively discard edits from yo' current hustlin tree\&. Right back up in yo muthafuckin ass. See tha \(lqInteractizzle Mode\(rq section of
\fBgit-add\fR(1)
to learn how tha fuck ta operate the
\-\-patch
mode\&.
.RE
.PP
<branch>
.RS 4
Branch ta checkout; if it refers ta a funky-ass branch (i\&.e\&., a name that, when prepended wit "refs/heads/", be a valid ref), then dat branch is checked out\&. Otherwise, if it refers ta a valid commit, yo' HEAD becomes "detached" n' yo ass is no longer on any branch (see below fo' details)\&.
.sp
As a special case, the
"@{\-N}"
syntax fo' tha N\-th last branch/commit checks up branches (instead of detaching)\&. Yo ass may also specify
\-
which is synonymous with
"@{\-1}"\&.
.sp
As a gangbangin' further special case, you may use
"A\&.\&.\&.B"
as a gangbangin' finger-lickin' dirty-ass shortcut fo' tha merge base of
A
and
B
if there is exactly one merge base\&. Yo ass can leave up at most one of
A
and
B, up in which case it defaults to
HEAD\&.
.RE
.PP
<new_branch>
.RS 4
Name fo' tha freshly smoked up branch\&.
.RE
.PP
<start_point>
.RS 4
Da name of a cold-ass lil commit at which ta start tha freshly smoked up branch; see
\fBgit-branch\fR(1)
for details\&. Defaults ta HEAD\&.
.RE
.PP
<tree\-ish>
.RS 4
Tree ta checkout from (when paths is given)\&. If not specified, tha index is ghon be used\&.
.RE
.SH "DETACHED HEAD"
.sp
HEAD normally refers ta a named branch (e\&.g\&. \fImaster\fR)\&. Meanwhile, each branch refers ta a specific commit\&. Let\(cqs peep a repo wit three commits, one of dem tagged, n' wit branch \fImaster\fR checked out:
.sp
.if n \{\
.RS 4
.\}
.nf
           HEAD (refers ta branch \(aqmaster\(aq)
            |
            v
a\-\-\-b\-\-\-c  branch \(aqmaster\(aq (refers ta commit \(aqc\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
When a cold-ass lil commit is pimped up in dis state, tha branch is updated ta refer ta tha freshly smoked up commit\&. Right back up in yo muthafuckin ass. Specifically, \fIgit commit\fR creates a freshly smoked up commit \fId\fR, whose parent is commit \fIc\fR, n' then thugged-out shiznit branch \fImaster\fR ta refer ta freshly smoked up commit \fId\fR\& yo. HEAD still refers ta branch \fImaster\fR n' so indirectly now refers ta commit \fId\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit; git add; git commit

               HEAD (refers ta branch \(aqmaster\(aq)
                |
                v
a\-\-\-b\-\-\-c\-\-\-d  branch \(aqmaster\(aq (refers ta commit \(aqd\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
It be sometimes useful ta be able ta checkout a cold-ass lil commit dat aint all up in tha tip of any named branch, or even ta create a freshly smoked up commit dat aint referenced by a named branch\&. Let\(cqs peep what tha fuck happens when we checkout commit \fIb\fR (here we show two ways dis may be done):
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout v2\&.0  # or
$ git checkout master^^

   HEAD (refers ta commit \(aqb\(aq)
    |
    v
a\-\-\-b\-\-\-c\-\-\-d  branch \(aqmaster\(aq (refers ta commit \(aqd\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
Notice dat regardless of which checkout command we use, HEAD now refers directly ta commit \fIb\fR\&. This is known as bein up in detached HEAD state\&. Well shiiiit, it means simply dat HEAD refers ta a specific commit, as opposed ta referrin ta a named branch\&. Let\(cqs peep what tha fuck happens when we create a cold-ass lil commit:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit; git add; git commit

     HEAD (refers ta commit \(aqe\(aq)
      |
      v
      e
     /
a\-\-\-b\-\-\-c\-\-\-d  branch \(aqmaster\(aq (refers ta commit \(aqd\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
There is now a freshly smoked up commit \fIe\fR yo, but it is referenced only by HEAD\&. We can of course add yet another commit up in dis state:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit; git add; git commit

         HEAD (refers ta commit \(aqf\(aq)
          |
          v
      e\-\-\-f
     /
a\-\-\-b\-\-\-c\-\-\-d  branch \(aqmaster\(aq (refers ta commit \(aqd\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
In fact, we can big-ass up all tha aiiight Git operations\&. But, let\(cqs peep what tha fuck happens when we then checkout master:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout master

               HEAD (refers ta branch \(aqmaster\(aq)
      e\-\-\-f     |
     /          v
a\-\-\-b\-\-\-c\-\-\-d  branch \(aqmaster\(aq (refers ta commit \(aqd\(aq)
    ^
    |
  tag \(aqv2\&.0\(aq (refers ta commit \(aqb\(aq)
.fi
.if n \{\
.RE
.\}
.sp
.sp
It be blingin ta realize dat at dis point not a god damn thang refers ta commit \fIf\fR\&. Eventually commit \fIf\fR (and by extension commit \fIe\fR) is ghon be deleted by tha routine Git garbage collection process, unless we create a reference before dat happens\&. If we aint yet moved away from commit \fIf\fR, any of these will create a reference ta it:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-b foo   \fB(1)\fR
$ git branch foo        \fB(2)\fR
$ git tag foo           \fB(3)\fR
.fi
.if n \{\
.RE
.\}
.sp
.sp
\fB1. \fRcreates a freshly smoked up branch
\fIfoo\fR, which refers ta commit
\fIf\fR, n' then thugged-out shiznit HEAD ta refer ta branch
\fIfoo\fR\&. In other lyrics, we\(cqll no longer be up in detached HEAD state afta dis command\&.
.br
\fB2. \fRsimilarly creates a freshly smoked up branch
\fIfoo\fR, which refers ta commit
\fIf\fR yo, but leaves HEAD detached\&.
.br
\fB3. \fRcreates a freshly smoked up tag
\fIfoo\fR, which refers ta commit
\fIf\fR, leavin HEAD detached\&.
.br
.sp
If our crazy asses have moved away from commit \fIf\fR, then we must first recover its object name (typically by rockin git reflog), n' then we can create a reference ta it\&. For example, ta peep tha last two commits ta which HEAD referred, we can use either of these commands:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git reflog \-2 HEAD # or
$ git log \-g \-2 HEAD
.fi
.if n \{\
.RE
.\}
.sp
.SH "EXAMPLES"
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Da followin sequence checks up the
master
branch, reverts the
Makefile
to two revisions back, deletes hello\&.c by mistake, n' gets it back from tha index\&.
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout masta             \fB(1)\fR
$ git checkout master~2 Makefile  \fB(2)\fR
$ rm \-f hello\&.c
$ git checkout hello\&.c            \fB(3)\fR
.fi
.if n \{\
.RE
.\}
.sp
\fB1. \fRswitch branch
.br
\fB2. \fRtake a gangbangin' file outta another commit
.br
\fB3. \fRrestore hello\&.c from tha index
.sp
If you wanna check out
\fIall\fR
C source filez outta tha index, you can say
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-\- \(aq*\&.c\(aq
.fi
.if n \{\
.RE
.\}
.sp
Note tha quotes around
*\&.c\&. Da file
hello\&.c
will also be checked out, even though it is no longer up in tha hustlin tree, cuz tha file globbin is used ta match entries up in tha index (not up in tha hustlin tree by tha shell)\&.
.sp
If you have a fucked up branch dat is named
hello\&.c, dis step would be trippin as a instruction ta switch ta dat branch\&. Yo ass should instead write:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-\- hello\&.c
.fi
.if n \{\
.RE
.\}
.sp
.br
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Afta hustlin up in tha wack branch, switchin ta tha erect branch would be done using:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout mytopic
.fi
.if n \{\
.RE
.\}
.sp
But fuck dat shiznit yo, tha word on tha street is dat yo' "wrong" branch n' erect "mytopic" branch may differ up in filez dat you have modified locally, up in which case tha above checkout would fail like this:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout mytopic
error: Yo ass have local chizzlez ta \(aqfrotz\(aq; not switchin branches\&.
.fi
.if n \{\
.RE
.\}
.sp
Yo ass can give the
\-m
flag ta tha command, which would try a three\-way merge:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-m mytopic
Auto\-mergin frotz
.fi
.if n \{\
.RE
.\}
.sp
Afta dis three\-way merge, tha local modifications are
\fInot\fR
registered up in yo' index file, so
git diff
would show you what tha fuck chizzlez you made since tha tip of tha freshly smoked up branch\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
When a merge conflict happens durin switchin branches wit the
\-m
option, you would peep suttin' like this:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git checkout \-m mytopic
Auto\-mergin frotz
ERROR: Merge conflict up in frotz
fatal: merge program failed
.fi
.if n \{\
.RE
.\}
.sp
At dis point,
git diff
shows tha chizzlez cleanly merged as up in tha previous example, as well as tha chizzlez up in tha conflicted files\&. Edit n' resolve tha conflict n' mark it resolved with
git add
as usual:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit frotz
$ git add frotz
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
