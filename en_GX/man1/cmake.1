.TH cmake 1 "February 11, 2014" "cmake 2.8.12.2"
.SH NAME
.PP
.nf
  cmake \- Cross\-Platform Makefile Generator.
.fi

.SH USAGE
.PP
.nf
  cmake [options] <path\-to\-source>
  cmake [options] <path\-to\-existing\-build>
.fi

.SH DESCRIPTION
.PP
Da "cmake" executable is tha CMake command\-line intercourse.  It may be used ta configure projects up in scripts, n' you can put dat on yo' toast.  Project configuration settings may be specified on tha command line wit tha \-D option. I aint talkin' bout chicken n' gravy biatch.  Da \-i option will cause cmake ta interactively prompt fo' such settings.

.PP
CMake be a cold-ass lil cross\-platform build system generator. Shiiit, dis aint no joke.  Projects specify they build process wit platform\-independent CMake listfilez included up in each directory of a source tree wit tha name CMakeLists.txt. Users build a project by rockin CMake ta generate a funky-ass build system fo' a natizzle tool on they platform.

.SH OPTIONS
.TP
.B -C <initial-cache>
Pre\-load a script ta populate tha cache.

When cmake is first run up in a empty build tree, it creates a CMakeCache.txt file n' populates it wit customizable settings fo' tha project.  This option may be used ta specify a gangbangin' file from which ta load cache entries before tha straight-up original gangsta pass all up in tha projectz cmake listfiles.  Da loaded entries take prioritizzle over tha projectz default joints, n' you can put dat on yo' toast.  Da given file should be a CMake script containin SET commandz dat use tha CACHE option, not a cold-ass lil cache\-format file.

.TP
.B -D <var>:<type>=<value>
Smoke a cold-ass lil cmake cache entry.

When cmake is first run up in a empty build tree, it creates a CMakeCache.txt file n' populates it wit customizable settings fo' tha project.  This option may be used ta specify a settin dat takes prioritizzle over tha projectz default value.  Da option may be repeated fo' as nuff cache entries as desired.

.TP
.B -U <globbing_expr>
Remove matchin entries from CMake cache.

This option may be used ta remove one or mo' variablez from tha CMakeCache.txt file, globbin expressions rockin * n' , biatch? is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da option may be repeated fo' as nuff cache entries as desired.


Use wit care, you can make yo' CMakeCache.txt non\-working.

.TP
.B -G <generator-name>
Specify a funky-ass build system generator.

CMake may support multiple natizzle build systems on certain platforms.  A generator is responsible fo' generatin a particular build system.  Possible generator names is specified up in tha Generators section.

.TP
.B -T <toolset-name>
Specify toolset name if supported by generator.

Some CMake generators support a toolset name ta be given ta tha natizzle build system ta chizzle a cold-ass lil compila n' shit.  This is supported only on specific generators:


.nf
  Visual Studio >= 10
  Xcode >= 3.0
.fi

See natizzle build system documentation fo' allowed toolset names.

.TP
.B -Wno-dev
Suppress pimper warnings.

Suppress warnings dat is meant fo' tha lyricist of tha CMakeLists.txt files.

.TP
.B -Wdev
Enable pimper warnings.

Enable warnings dat is meant fo' tha lyricist of tha CMakeLists.txt files.

.TP
.B -E
CMake command mode.

For legit platform independence, CMake serves up a list of commandz dat can be used on all systems. Run wit \-E help fo' tha usage shiznit. I aint talkin' bout chicken n' gravy biatch. Commandz available are: chdir, compare_files, copy, copy_directory, copy_if_different, echo, echo_append, environment, make_directory, md5sum, remove, remove_directory, rename, tar, time, touch, touch_nocreate. In addition, some platform specific commandz is available. On Windows: comspec, delete_regv, write_regv. On UNIX: create_symlink.

.TP
.B -i
Run up in wizzle mode.

Wizard mode runs cmake interactively without a GUI.  Da user is prompted ta answer thangs bout tha project configuration. I aint talkin' bout chicken n' gravy biatch.  Da lyrics is used ta set cmake cache joints.

.TP
.B -L[A][H]
List non\-advanced cached variables.

List cache variablez will run CMake n' list all tha variablez from tha CMake cache dat is not marked as INTERNAL or ADVANCED. This will effectively display current CMake settings, which can then be chizzled wit \-D option. I aint talkin' bout chicken n' gravy biatch. Changin a shitload of tha variablez may result up in mo' variablez bein pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If A is specified, then it will display also advanced variables. If H is specified, it will also display help fo' each variable.

.TP
.B --build <dir>
Build a CMake\-generated project binary tree.

This abstracts a natizzle build toolz command\-line intercourse wit tha followin options:


.nf
  <dir>          = Project binary directory ta be built.
  \-\-target <tgt> = Build <tgt> instead of default targets.
  \-\-config <cfg> = For multi\-configuration tools, chizzle <cfg>.
  \-\-clean\-first  = Build target 'clean' first, then build.
                   (To clean only, use \-\-target 'clean'.)
  \-\-use\-stderr   = Don't merge stdout/stderr output n' pass the
                   original gangsta stdout/stderr handlez ta tha native
                   tool so it can use tha capabilitizzlez of the
                   callin terminal (e.g. colored output).
  \-\-             = Pass remainin options ta tha natizzle tool.
.fi

Run cmake \-\-build wit no options fo' quick help.

.TP
.B -N
View mode only.

Only load tha cache. Do not straight-up run configure n' generate steps.

.TP
.B -P <file>
Process script mode.

Process tha given cmake file as a script freestyled up in tha CMake language.  No configure or generate step is performed n' tha cache aint modified. Y'all KNOW dat shit, muthafucka! If variablez is defined rockin \-D, dis must be done before tha \-P argument.

.TP
.B --find-package
Run up in pkg\-config like mode.

Search a package rockin find_package() n' print tha resultin flags ta stdout. This can be used ta use cmake instead of pkg\-config ta find installed libraries up in plain Makefile\-based projects or up in autoconf\-based projects (via share/aclocal/cmake.m4).

.TP
.B --graphviz=[file]
Generate graphviz of dependencies, peep CMakeGraphVizOptions.cmake fo' more.

Generate a graphviz input file dat will contain all tha library n' executable dependencies up in tha project. Right back up in yo muthafuckin ass. See tha documentation fo' CMakeGraphVizOptions.cmake fo' mo' details. 

.TP
.B --system-information [file]
Dump shiznit bout dis system.

Dump a wide range of shiznit bout tha current system. If run from tha top of a funky-ass binary tree fo' a CMake project it will dump additionizzle shiznit like fuckin tha cache, log filez etc.

.TP
.B --debug-trycompile
Do not delete tha try_compile build tree. Only useful on one try_compile at a time.

Do not delete tha filez n' directories pimped fo' try_compile calls. This is useful up in debuggin failed try_compiles. Well shiiiit, it may however chizzle tha thangs up in dis biatch of tha try\-compilez as oldschool junk from a previous try\-compile may cause a gangbangin' finger-lickin' different test ta either pass or fail incorrectly.  This option is dopest used fo' one try\-compile at a time, n' only when debugging.

.TP
.B --debug-output
Put cmake up in a thugged-out debug mode.

Print extra shiznit durin tha cmake run like stack traces wit message(send_error ) calls.

.TP
.B --trace
Put cmake up in trace mode.

Print a trace of all calls made n' from where wit message(send_error ) calls.

.TP
.B --warn-uninitialized
Warn bout uninitialized joints.

Print a warnin when a uninitialized variable is used.

.TP
.B --warn-unused-vars
Warn bout unused variables.

Find variablez dat is declared or set yo, but not used.

.TP
.B --no-warn-unused-cli
Don't warn bout command line options.

Don't find variablez dat is declared on tha command line yo, but not used.

.TP
.B --check-system-vars
Find problems wit variable usage up in system files.

Normally, unused n' uninitialized variablez is searched fo' only up in CMAKE_SOURCE_DIR n' CMAKE_BINARY_DIR. This flag  drops some lyrics ta CMake ta warn bout other filez as well.

.TP
.B --help-command cmd [file]
Print help fo' a single command n' exit.

Full documentation specific ta tha given command is displayed. Y'all KNOW dat shit, muthafucka! If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-command-list [file]
List available listfile commandz n' exit.

Da list gotz nuff all commandz fo' which help may be obtained by rockin tha \-\-help\-command argument followed by a cold-ass lil command name. If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-commandz [file]
Print help fo' all commandz n' exit.

Full documentation specific fo' all current commandz is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-compatcommandz [file]
Print help fo' compatibilitizzle commands. 

Full documentation specific fo' all compatibilitizzle commandz is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-module module [file]
Print help fo' a single module n' exit.

Full documentation specific ta tha given module is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-module-list [file]
List available modulez n' exit.

Da list gotz nuff all modulez fo' which help may be obtained by rockin tha \-\-help\-module argument followed by a module name. If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-modulez [file]
Print help fo' all modulez n' exit.

Full documentation fo' all modulez is displayed. Y'all KNOW dat shit, muthafucka! If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-custom-modulez [file]
Print help fo' all custom modulez n' exit.

Full documentation fo' all custom modulez is displayed. Y'all KNOW dat shit, muthafucka! If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-policy cmp [file]
Print help fo' a single policy n' exit.

Full documentation specific ta tha given policy is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-policies [file]
Print help fo' all policies n' exit.

Full documentation fo' all policies is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-property prop [file]
Print help fo' a single property n' exit.

Full documentation specific ta tha given property is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-property-list [file]
List available propertizzles n' exit.

Da list gotz nuff all propertizzles fo' which help may be obtained by rockin tha \-\-help\-property argument followed by a property name.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-propertizzles [file]
Print help fo' all propertizzles n' exit.

Full documentation fo' all propertizzles is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-variable var [file]
Print help fo' a single variable n' exit.

Full documentation specific ta tha given variable is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-variable-list [file]
List documented variablez n' exit.

Da list gotz nuff all variablez fo' which help may be obtained by rockin tha \-\-help\-variable argument followed by a variable name.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --help-variablez [file]
Print help fo' all variablez n' exit.

Full documentation fo' all variablez is displayed.If a gangbangin' file is specified, tha documentation is freestyled tha fuck into n' tha output format is determined dependin on tha filename suffix. Right back up in yo muthafuckin ass. Supported is playa page, HTML, DocBook n' plain text.

.TP
.B --copyright [file]
Print tha CMake copyright n' exit.

If a gangbangin' file is specified, tha copyright is freestyled tha fuck into dat shit.

.TP
.B --help,-help,-usage,-h,-H,/?
Print usage shiznit n' exit.

Usage raps bout tha basic command line intercourse n' its options.

.TP
.B --help-full [file]
Print full help n' exit.

Full help displays most of tha documentation provided by tha UNIX playa page.  It be provided fo' use on non\-UNIX platforms yo, but be also convenient if tha playa page aint installed. Y'all KNOW dat shit, muthafucka!  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-html [file]
Print full help up in HTML format.

This option is used by CMake authors ta help produce wizzy pages.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-man [file]
Print full help as a UNIX playa page n' exit.

This option is used by tha cmake build ta generate tha UNIX playa page.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --version,-version,/V [file]
Show program name/version banner n' exit.

If a gangbangin' file is specified, tha version is freestyled tha fuck into dat shit.

.SH GENERATORS
.PP
Da followin generators is available on dis platform:

.TP
.B Unix Makefiles
Generates standard UNIX makefiles.

A hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Ninja
Generates build.ninja filez (experimental).

A build.ninja file is generated tha fuck into tha build tree. Recent versionz of tha ninja program can build tha project all up in tha "all" target.  An "install" target be also provided.

.TP
.B CodeBlocks - Ninja
Generates CodeBlocks project files.

Project filez fo' CodeBlocks is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B CodeBlocks - Unix Makefiles
Generates CodeBlocks project files.

Project filez fo' CodeBlocks is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Eclipse CDT4 - Ninja
Generates Eclipse CDT 4.0 project files.

Project filez fo' Eclipse is ghon be pimped up in tha top directory. In outta source builds, a linked resource ta tha top level source directory is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree. Da appropriate make program can build tha project all up in tha default make target fo' realz. A "make install" target be also provided.

.TP
.B Eclipse CDT4 - Unix Makefiles
Generates Eclipse CDT 4.0 project files.

Project filez fo' Eclipse is ghon be pimped up in tha top directory. In outta source builds, a linked resource ta tha top level source directory is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree. Da appropriate make program can build tha project all up in tha default make target fo' realz. A "make install" target be also provided.

.TP
.B KDevelop3
Generates KDevelop 3 project files.

Project filez fo' KDevelop 3 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call. If you chizzle tha settings rockin KDevelop cmake will try its dopest ta keep yo' chizzlez when regeneratin tha project filez fo' realz. Additionally a hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B KDevelop3 - Unix Makefiles
Generates KDevelop 3 project files.

Project filez fo' KDevelop 3 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call. If you chizzle tha settings rockin KDevelop cmake will try its dopest ta keep yo' chizzlez when regeneratin tha project filez fo' realz. Additionally a hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Sublime Text 2 - Ninja
Generates Sublime Text 2 project files.

Project filez fo' Sublime Text 2 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally Makefilez (or build.ninja files) is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Sublime Text 2 - Unix Makefiles
Generates Sublime Text 2 project files.

Project filez fo' Sublime Text 2 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally Makefilez (or build.ninja files) is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.SH COMMANDS
.TP
.B add_compile_options
Addz options ta tha compilation of source files.

.nf
  add_compile_options(<option> ...)
.fi

Addz options ta tha compila command line fo' sources up in tha current directory n' below.  This command can be used ta add any options yo, but alternatizzle commandz exist ta add preprocessor definitions or include directories. Put ya muthafuckin choppers up if ya feel dis!  See documentation of tha directory n' target COMPILE_OPTIONS propertizzles fo' details.  Arguments ta add_compile_options may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B add_custom_command
Add a cold-ass lil custom build rule ta tha generated build system.

There is two main signatures fo' add_custom_command Da first signature is fo' addin a cold-ass lil custom command ta produce a output.


.nf
  add_custom_command(OUTPUT output1 [output2 ...]
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [MAIN_DEPENDENCY depend]
                     [DEPENDS [depends...]]
                     [IMPLICIT_DEPENDS <lang1> depend1
                                      [<lang2> depend2] ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM] [APPEND])
.fi

This defines a cold-ass lil command ta generate specified OUTPUT file(s).  A target pimped up in tha same directory (CMakeLists.txt file) dat specifies any output of tha custom command as a source file is given a rule ta generate tha file rockin tha command at build time.  Do not list tha output up in mo' than one independent target dat may build up in parallel or tha two instancez of tha rule may conflict (instead use add_custom_target ta drive tha command n' make tha other targets depend on dat one).  If a output name be a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. Note dat MAIN_DEPENDENCY is straight-up optionizzle n' is used as a suggestion ta visual basement bout where ta hang tha custom command. Y'all KNOW dat shit, muthafucka! In makefile terms dis creates a freshly smoked up target up in tha followin form:


.nf
  OUTPUT: MAIN_DEPENDENCY DEPENDS
          COMMAND
.fi

If mo' than one command is specified they is ghon be executed up in order n' shit. Da optionizzle ARGS argument is fo' backward compatibilitizzle n' is ghon be ignored.


Da second signature addz a cold-ass lil custom command ta a target like fuckin a library or executable. This is useful fo' struttin a operation before or afta buildin tha target. Da command becomes part of tha target n' will only execute when tha target itself is built.  If tha target be already built, tha command aint gonna execute.


.nf
  add_custom_command(TARGET target
                     PRE_BUILD | PRE_LINK | POST_BUILD
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM])
.fi

This defines a freshly smoked up command dat is ghon be associated wit buildin tha specified target. When tha command will happen is determined by which of tha followin is specified:


.nf
  PRE_BUILD \- run before all other dependencies
  PRE_LINK \- run afta other dependencies
  POST_BUILD \- run afta tha target has been built
.fi

Note dat tha PRE_BUILD option is only supported on Visual Studio 7 or later n' shit. For all other generators PRE_BUILD is ghon be treated as PRE_LINK.


If WORKING_DIRECTORY is specified tha command is ghon be executed up in tha directory given. I aint talkin' bout chicken n' gravy biatch. If it aint nuthin but a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. If COMMENT is set, tha value is ghon be displayed as a message before tha commandz is executed at build time. If APPEND is specified tha COMMAND n' DEPENDS option joints is appended ta tha custom command fo' tha straight-up original gangsta output specified. Y'all KNOW dat shit, muthafucka! There must have already been a previous call ta dis command wit tha same output. Da COMMENT, WORKING_DIRECTORY, n' MAIN_DEPENDENCY options is currently ignored when APPEND is given yo, but may be used up in tha future.


If VERBATIM is given then all arguments ta tha commandz is ghon be escaped properly fo' tha build tool so dat tha invoked command receives each argument unchanged. Y'all KNOW dat shit, muthafucka!  Note dat one level of escapes is still used by tha CMake language processor before add_custom_command even sees tha arguments, n' you can put dat on yo' toast. Use of VERBATIM is recommended as it enablez erect behavior. Shiiit, dis aint no joke. When VERBATIM aint given tha behavior is platform specific cuz there is no protection of tool\-specific special characters.


If tha output of tha custom command aint straight-up pimped as a gangbangin' file on disk it should be marked as SYMBOLIC wit SET_SOURCE_FILES_PROPERTIES.


Da IMPLICIT_DEPENDS option requests scannin of implicit dependenciez of a input file.  Da language given specifies tha programmin language whose correspondin dependency scanner should be used. Y'all KNOW dat shit, muthafucka!  Currently only C n' CXX language scanners is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da language has ta be specified fo' every last muthafuckin file up in tha IMPLICIT_DEPENDS list. Dependencies discovered from tha scannin is added ta dem of tha custom command at build time.  Note dat tha IMPLICIT_DEPENDS option is currently supported only fo' Makefile generators n' is ghon be ignored by other generators.


If COMMAND specifies a executable target (created by ADD_EXECUTABLE) it will automatically be replaced by tha location of tha executable pimped at build time.  Additionally a target\-level dependency is ghon be added so dat tha executable target is ghon be built before any target rockin dis custom command. Y'all KNOW dat shit, muthafucka!  However dis do NOT add a gangbangin' file\-level dependency dat would cause tha custom command ta re\-run whenever tha executable is recompiled.


Arguments ta COMMAND may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

References ta target names up in generator expressions imply target\-level dependencies yo, but NOT file\-level dependencies. Put ya muthafuckin choppers up if ya feel dis!  List target names wit tha DEPENDS option ta add file dependencies.


Da DEPENDS option specifies filez on which tha command depends.  If any dependency be a OUTPUT of another custom command up in tha same directory (CMakeLists.txt file) CMake automatically brangs tha other custom command tha fuck into tha target up in which dis command is built.  If DEPENDS aint specified tha command will run whenever tha OUTPUT is missing; if tha command do not straight-up create tha OUTPUT then tha rule will always run. I aint talkin' bout chicken n' gravy biatch.  If DEPENDS specifies any target (created by a ADD_* command) a target\-level dependency is pimped ta make shizzle tha target is built before any target rockin dis custom command. Y'all KNOW dat shit, muthafucka!  Additionally, if tha target be a executable or library a gangbangin' file\-level dependency is pimped ta cause tha custom command ta re\-run whenever tha target is recompiled.


.TP
.B add_custom_target
Add a target wit no output so it will always be built.

.nf
  add_custom_target(Name [ALL] [command1 [args1...]]
                    [COMMAND command2 [args2...] ...]
                    [DEPENDS depend depend depend ... ]
                    [WORKING_DIRECTORY dir]
                    [COMMENT comment] [VERBATIM]
                    [SOURCES src1 [src2...]])
.fi

Addz a target wit tha given name dat executes tha given commands. Da target has no output file n' is ALWAYS CONSIDERED OUT OF DATE even if tha commandz try ta create a gangbangin' file wit tha name of tha target. Use ADD_CUSTOM_COMMAND ta generate a gangbangin' file wit dependencies. Put ya muthafuckin choppers up if ya feel dis! By default not a god damn thang dependz on tha custom target. Use ADD_DEPENDENCIES ta add dependencies ta or from other targets, n' you can put dat on yo' toast. If tha ALL option is specified it indicates dat dis target should be added ta tha default build target so dat it is ghon be run every last muthafuckin time (the command cannot be called ALL). Da command n' arguments is optionizzle n' if not specified a empty target is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If WORKING_DIRECTORY is set, then tha command is ghon be run up in dat directory. If it aint nuthin but a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. If COMMENT is set, tha value is ghon be displayed as a message before tha commandz is executed at build time. Dependencies listed wit tha DEPENDS argument may reference filez n' outputz of custom commandz pimped wit add_custom_command() up in tha same directory (CMakeLists.txt file).


If VERBATIM is given then all arguments ta tha commandz is ghon be escaped properly fo' tha build tool so dat tha invoked command receives each argument unchanged. Y'all KNOW dat shit, muthafucka!  Note dat one level of escapes is still used by tha CMake language processor before add_custom_target even sees tha arguments, n' you can put dat on yo' toast. Use of VERBATIM is recommended as it enablez erect behavior. Shiiit, dis aint no joke. When VERBATIM aint given tha behavior is platform specific cuz there is no protection of tool\-specific special characters.


Da SOURCES option specifies additionizzle source filez ta be included up in tha custom target.  Specified source filez is ghon be added ta IDE project filez fo' convenience up in editin even if they aint build rules.

.TP
.B add_definitions
Addz \-D define flags ta tha compilation of source files.

.nf
  add_definitions(\-DFOO \-DBAR ...)
.fi

Addz flags ta tha compila command line fo' sources up in tha current directory n' below.  This command can be used ta add any flags yo, but dat shiznit was originally intended ta add preprocessor definitions.  Flags beginnin up in \-D or /D dat be lookin like preprocessor definitions is automatically added ta tha COMPILE_DEFINITIONS property fo' tha current directory.  Definitions wit non\-trivial joints may be left up in tha set of flags instead of bein converted fo' reasonz of backwardz compatibility.  See documentation of tha directory, target, n' source file COMPILE_DEFINITIONS propertizzles fo' details on addin preprocessor definitions ta specific scopes n' configurations.

.TP
.B add_dependencies
Add a thugged-out dependency between top\-level targets.

.nf
  add_dependencies(target\-name depend\-target1
                   depend\-target2 ...)
.fi

Make a top\-level target depend on other top\-level targets, n' you can put dat on yo' toast.  A top\-level target is one pimped by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET.  Addin dependencies wit dis command can be used ta make shizzle one target is built before another target.  Dependencies added ta a IMPORTED target is followed transitively up in its place since tha target itself do not build. Y'all KNOW dat shit, muthafucka!  See tha DEPENDS option of ADD_CUSTOM_TARGET n' ADD_CUSTOM_COMMAND fo' addin file\-level dependencies up in custom rules.  See tha OBJECT_DEPENDS option up in SET_SOURCE_FILES_PROPERTIES ta add file\-level dependencies ta object files.

.TP
.B add_executable
Add a executable ta tha project rockin tha specified source files.

.nf
  add_executable(<name> [WIN32] [MACOSX_BUNDLE]
                 [EXCLUDE_FROM_ALL]
                 source1 source2 ... sourceN)
.fi

Addz a executable target called <name> ta be built from tha source filez listed up in tha command invocation. I aint talkin' bout chicken n' gravy biatch.  Da <name> correspondz ta tha logical target name n' must be globally unique within a project.  Da actual file name of tha executable built is constructed based on conventionz of tha natizzle platform (like fuckin <name>.exe or just <name>).  


By default tha executable file is ghon be pimped up in tha build tree directory correspondin ta tha source tree directory up in which tha command was invoked. Y'all KNOW dat shit, muthafucka!  See documentation of tha RUNTIME_OUTPUT_DIRECTORY target property ta chizzle dis location. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha OUTPUT_NAME target property ta chizzle tha <name> part of tha final file name.  


If WIN32 is given tha property WIN32_EXECUTABLE is ghon be set on tha target pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See documentation of dat target property fo' details.


If MACOSX_BUNDLE is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha MACOSX_BUNDLE target property fo' details.


If EXCLUDE_FROM_ALL is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha EXCLUDE_FROM_ALL target property fo' details.


Da add_executable command can also create IMPORTED executable targets rockin dis signature:


.nf
  add_executable(<name> IMPORTED [GLOBAL])
.fi

An IMPORTED executable target references a executable file located outside tha project.  No rulez is generated ta build dat shit.  Da target name has scope up in tha directory up in which it is pimped n' below yo, but tha GLOBAL option extendz visibility.  It may be referenced like any target built within tha project.  IMPORTED executablez is useful fo' convenient reference from commandz like add_custom_command. Y'all KNOW dat shit, muthafucka!  Details bout tha imported executable is specified by settin propertizzles whose names begin up in "IMPORTED_".  Da most blingin such property is IMPORTED_LOCATION (and its per\-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies tha location of tha main executable file on disk.  See documentation of tha IMPORTED_* propertizzles fo' mo' shiznit.


Da signature


.nf
  add_executable(<name> ALIAS <target>)
.fi

creates a alias, such dat <name> can be used ta refer ta <target> up in subsequent commands.  Da <name> do not step tha fuck up in tha generated buildsystem as a make target.  Da <target> may not be a IMPORTED target or a ALIAS.  Alias targets can be used as linkable targets, targets ta read propertizzles from, executablez fo' custom commandz n' custom targets, n' you can put dat on yo' toast.  They can also be tested fo' existizzle wit tha regular if(TARGET) subcommand. Y'all KNOW dat shit, muthafucka!  Da <name> may not be used ta modify propertizzlez of <target>, dat is, it may not be used as tha operand of set_property, set_target_properties, target_link_libraries etc.  An ALIAS target may not be installed of exported.

.TP
.B add_library
Add a library ta tha project rockin tha specified source files.

.nf
  add_library(<name> [STATIC | SHARED | MODULE]
              [EXCLUDE_FROM_ALL]
              source1 source2 ... sourceN)
.fi

Addz a library target called <name> ta be built from tha source filez listed up in tha command invocation. I aint talkin' bout chicken n' gravy biatch.  Da <name> correspondz ta tha logical target name n' must be globally unique within a project.  Da actual file name of tha library built is constructed based on conventionz of tha natizzle platform (like fuckin lib<name>.a or <name>.lib).


STATIC, SHARED, or MODULE may be given ta specify tha type of library ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  STATIC libraries is archivez of object filez fo' use when linkin other targets, n' you can put dat on yo' toast.  SHARED libraries is linked dynamically n' loaded at runtime.  MODULE libraries is plugins dat is not linked tha fuck into other targets but may be loaded dynamically at runtime rockin dlopen\-like functionality.  If no type is given explicitly tha type is STATIC or SHARED based on whether tha current value of tha variable BUILD_SHARED_LIBS is true.  For SHARED n' MODULE libraries tha POSITION_INDEPENDENT_CODE target property is set ta TRUE automatically.


By default tha library file is ghon be pimped up in tha build tree directory correspondin ta tha source tree directory up in which tha command was invoked. Y'all KNOW dat shit, muthafucka!  See documentation of tha ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, n' RUNTIME_OUTPUT_DIRECTORY target propertizzles ta chizzle dis location. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha OUTPUT_NAME target property ta chizzle tha <name> part of tha final file name.  


If EXCLUDE_FROM_ALL is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha EXCLUDE_FROM_ALL target property fo' details.


Da add_library command can also create IMPORTED library targets rockin dis signature:


.nf
  add_library(<name> <SHARED|STATIC|MODULE|UNKNOWN> IMPORTED
              [GLOBAL])
.fi

An IMPORTED library target references a library file located outside tha project.  No rulez is generated ta build dat shit.  Da target name has scope up in tha directory up in which it is pimped n' below yo, but tha GLOBAL option extendz visibility.  It may be referenced like any target built within tha project.  IMPORTED libraries is useful fo' convenient reference from commandz like target_link_libraries. Put ya muthafuckin choppers up if ya feel dis!  Details bout tha imported library is specified by settin propertizzles whose names begin up in "IMPORTED_".  Da most blingin such property is IMPORTED_LOCATION (and its per\-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies tha location of tha main library file on disk.  See documentation of tha IMPORTED_* propertizzles fo' mo' shiznit.


Da signature


.nf
  add_library(<name> OBJECT <src>...)
.fi

creates a special "object library" target.  An object library compilez source filez but do not archive or link they object filez tha fuck into a library.  Instead other targets pimped by add_library or add_executable may reference tha objects rockin a expression of tha form $<TARGET_OBJECTS:objlib> as a source, where "objlib" is tha object library name.  For example:


.nf
  add_library(... $<TARGET_OBJECTS:objlib> ...)
  add_executable(... $<TARGET_OBJECTS:objlib> ...)
.fi

will include objlibz object filez up in a library n' a executable along wit dem compiled from they own sources.  Object libraries may contain only sources (and headers) dat compile ta object files.  They may contain custom commandz generatin such sources yo, but not PRE_BUILD, PRE_LINK, or POST_BUILD commands.  Object libraries cannot be imported, exported, installed, or linked. Y'all KNOW dat shit, muthafucka!  Some natizzle build systems may not like targets dat have only object files, so consider addin at least one real source file ta any target dat references $<TARGET_OBJECTS:objlib>.


Da signature


.nf
  add_library(<name> ALIAS <target>)
.fi

creates a alias, such dat <name> can be used ta refer ta <target> up in subsequent commands.  Da <name> do not step tha fuck up in tha generated buildsystem as a make target.  Da <target> may not be a IMPORTED target or a ALIAS.  Alias targets can be used as linkable targets, targets ta read propertizzles from.  They can also be tested fo' existizzle wit tha regular if(TARGET) subcommand. Y'all KNOW dat shit, muthafucka!  Da <name> may not be used ta modify propertizzlez of <target>, dat is, it may not be used as tha operand of set_property, set_target_properties, target_link_libraries etc.  An ALIAS target may not be installed of exported.

.TP
.B add_subdirectory
Add a subdirectory ta tha build.

.nf
  add_subdirectory(source_dir [binary_dir] 
                   [EXCLUDE_FROM_ALL])
.fi

Add a subdirectory ta tha build. Y'all KNOW dat shit, muthafucka! Da source_dir specifies tha directory up in which tha source CMakeLists.txt n' code filez is located. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If it aint nuthin but a relatizzle path it is ghon be evaluated wit respect ta tha current directory (the typical usage) yo, but it may also be a absolute path. Da binary_dir specifies tha directory up in which ta place tha output files. If it aint nuthin but a relatizzle path it is ghon be evaluated wit respect ta tha current output directory yo, but it may also be a absolute path. If binary_dir aint specified, tha value of source_dir, before expandin any relatizzle path, is ghon be used (the typical usage). Da CMakeLists.txt file up in tha specified source directory is ghon be processed immediately by CMake before processin up in tha current input file continues beyond dis command.


If tha EXCLUDE_FROM_ALL argument is provided then targets up in tha subdirectory aint gonna be included up in tha ALL target of tha parent directory by default, n' is ghon be excluded from IDE project files.  Users must explicitly build targets up in tha subdirectory.  This is meant fo' use when tha subdirectory gotz nuff a separate part of tha project dat is useful but not necessary, like fuckin a set of examples.  Typically tha subdirectory should contain its own project() command invocation so dat a gangbangin' full build system is ghon be generated up in tha subdirectory (like fuckin a VS IDE solution file).  Note dat inter\-target dependencies supercede dis exclusion. I aint talkin' bout chicken n' gravy biatch.  If a target built by tha parent project dependz on a target up in tha subdirectory, tha dependee target is ghon be included up in tha parent project build system ta satisfy tha dependency.

.TP
.B add_test
Add a test ta tha project wit tha specified arguments.

.nf
  add_test(testname Exename arg1 arg2 ... )
.fi

If tha ENABLE_TESTING command has been run, dis command addz a test target ta tha current directory. If ENABLE_TESTING has not been run, dis command do nothing.  Da tests is run by tha testin subsystem by executin Exename wit tha specified arguments, n' you can put dat on yo' toast.  Exename can be either a executable built by dis project or a arbitrary executable on tha system (like tclsh).  Da test is ghon be run wit tha current hustlin directory set ta tha CMakeList.txt filez correspondin directory up in tha binary tree.





.nf
  add_test(NAME <name> [CONFIGURATIONS [Debug|Release|...]]
           [WORKING_DIRECTORY dir]
           COMMAND <command> [arg1 [arg2 ...]])
.fi

Add a test called <name>.  Da test name may not contain spaces, quotes, or other charactas special up in CMake syntax.  If COMMAND specifies a executable target (created by add_executable) it will automatically be replaced by tha location of tha executable pimped at build time.  If a CONFIGURATIONS option is given then tha test is ghon be executed only when testin under one of tha named configurations.  If a WORKING_DIRECTORY option is given then tha test is ghon be executed up in tha given directory.


Arguments afta COMMAND may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Example usage:


.nf
  add_test(NAME mytest
           COMMAND testDriver \-\-config $<CONFIGURATION>
                              \-\-exe $<TARGET_FILE:myexe>)
.fi

This creates a test "mytest" whose command runs a testDriver tool passin tha configuration name n' tha full path ta tha executable file produced by target "myexe".

.TP
.B aux_source_directory
Find all source filez up in a gangbangin' finger-lickin' directory.

.nf
  aux_source_directory(<dir> <variable>)
.fi

Collects tha namez of all tha source filez up in tha specified directory n' stores tha list up in tha <variable> provided. Y'all KNOW dat shit, muthafucka!  This command is intended ta be used by projects dat use explicit template instantiation. I aint talkin' bout chicken n' gravy biatch.  Template instantiation filez can be stored up in a "Templates" subdirectory n' collected automatically rockin dis command ta avoid manually listin all instantiations.


It be temptin ta use dis command ta avoid freestylin tha list of source filez fo' a library or executable target.  While dis seems ta work, there is no way fo' CMake ta generate a funky-ass build system dat knows when a freshly smoked up source file has been added. Y'all KNOW dat shit, muthafucka!  Normally tha generated build system knows when it need ta rerun CMake cuz tha CMakeLists.txt file is modified ta add a freshly smoked up source.  When tha source is just added ta tha directory without modifyin dis file, one would gotta manually rerun CMake ta generate a funky-ass build system incorporatin tha freshly smoked up file.

.TP
.B break
Break from a enclosin foreach or while loop.

.nf
  break()
.fi

Breaks from a enclosin foreach loop or while loop

.TP
.B build_command
Git tha command line ta build dis project.

.nf
  build_command(<variable>
                [CONFIGURATION <config>]
                [PROJECT_NAME <projname>]
                [TARGET <target>])
.fi

Sets tha given <variable> ta a strang containin tha command line fo' buildin one configuration of a target up in a project rockin tha build tool appropriate fo' tha current CMAKE_GENERATOR.


If CONFIGURATION is omitted, CMake chizzlez a reasonable default value  fo' multi\-configuration generators.  CONFIGURATION is ignored fo' single\-configuration generators.


If PROJECT_NAME is omitted, tha resultin command line will build tha top level PROJECT up in tha current build tree.


If TARGET is omitted, tha resultin command line will build every last muthafuckin thang, effectively rockin build target 'all' or 'ALL_BUILD'.


.nf
  build_command(<cachevariable> <makecommand>)
.fi

This second signature is deprecated yo, but still available fo' backwardz compatibility. Use tha straight-up original gangsta signature instead.


Sets tha given <cachevariable> ta a strang containin tha command ta build dis project from tha root of tha build tree rockin tha build tool given by <makecommand>.  <makecommand> should be tha full path ta msdev, devenv, nmake, make or one of tha end user build tools.

.TP
.B cmake_host_system_information
Query host system specific shiznit.

.nf
  cmake_host_system_information(RESULT <variable> QUERY <key> ...)
.fi

Queries system shiznit of tha host system on which cmake runs. One or mo' <key> can be provided ta select tha shiznit ta be queried. Y'all KNOW dat shit, muthafucka! Da list of queried joints is stored up in <variable>.


<key> can be one of tha followin joints:


.nf
  NUMBER_OF_LOGICAL_CORES   = Number of logical cores.
  NUMBER_OF_PHYSICAL_CORES  = Number of physical cores.
  HOSTNAME                  = Hostname.
  FQDN                      = Fully qualified domain name.
  TOTAL_VIRTUAL_MEMORY      = Total virtual memory up in megabytes.
  AVAILABLE_VIRTUAL_MEMORY  = Available virtual memory up in megabytes.
  TOTAL_PHYSICAL_MEMORY     = Total physical memory up in megabytes.
  AVAILABLE_PHYSICAL_MEMORY = Available physical memory up in megabytes.
.fi

.TP
.B cmake_minimum_required
Set tha minimum required version of cmake fo' a project.

.nf
  cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]]
                         [FATAL_ERROR])
.fi

If tha current version of CMake is lower than dat required it will stop processin tha project n' report a error. Shiiit, dis aint no joke.  When a version higher than 2.4 is specified tha command implicitly invokes


.nf
  cmake_policy(VERSION major[.minor[.patch[.tweak]]])
.fi

which sets tha cmake policy version level ta tha version specified. Y'all KNOW dat shit, muthafucka!  When version 2.4 or lower is given tha command implicitly invokes


.nf
  cmake_policy(VERSION 2.4)
.fi

which enablez compatibilitizzle features fo' CMake 2.4 n' lower.


Da FATAL_ERROR option be accepted but ignored by CMake 2.6 n' higher n' shit.  It should be specified so CMake versions 2.4 n' lower fail wit a error instead of just a warning.

.TP
.B cmake_policy
Manage CMake Policy settings.

As CMake evolves it is sometimes necessary ta chizzle existin behavior up in order ta fix bugs or improve implementationz of existin features.  Da CMake Policy mechanizzle is designed ta help keep existin projects buildin as freshly smoked up versionz of CMake introduce chizzlez up in behavior. Shiiit, dis aint no joke.  Each freshly smoked up policy (behavioral chizzle) is given a identifier of tha form "CMP<NNNN>" where "<NNNN>" be a integer index.  Documentation associated wit each policy raps bout tha OLD n' NEW behavior n' tha reason tha policy was introduced. Y'all KNOW dat shit, muthafucka!  Projects may set each policy ta select tha desired behavior. Shiiit, dis aint no joke.  When CMake need ta know which behavior ta use it checks fo' a settin specified by tha project.  If no settin be available tha OLD behavior be assumed n' a warnin is produced requestin dat tha policy be set.


Da cmake_policy command is used ta set policies ta OLD or NEW behavior. Shiiit, dis aint no joke.  While settin policies individually is supported, we encourage projects ta set policies based on CMake versions.


.nf
  cmake_policy(VERSION major.minor[.patch[.tweak]])
.fi

Specify dat tha current CMake list file is freestyled fo' tha given version of CMake.  All policies introduced up in tha specified version or earlier is ghon be set ta use NEW behavior. Shiiit, dis aint no joke.  All policies introduced afta tha specified version is ghon be unset (unless variable CMAKE_POLICY_DEFAULT_CMP<NNNN> sets a thugged-out default).  This effectively requests behavior preferred az of a given CMake version n'  drops some lyrics ta newer CMake versions ta warn bout they freshly smoked up policies. Put ya muthafuckin choppers up if ya feel dis!  Da policy version specified must be at least 2.4 or tha command will report a error. Shiiit, dis aint no joke.  In order ta git compatibilitizzle features supportin versions earlier than 2.4 peep documentation of policy CMP0001.


.nf
  cmake_policy(SET CMP<NNNN> NEW)
  cmake_policy(SET CMP<NNNN> OLD)
.fi

Tell CMake ta use tha OLD or NEW behavior fo' a given policy.  Projects dependin on tha oldschool behavior of a given policy may silence a policy warnin by settin tha policy state ta OLD.  Alternatively one may fix tha project ta work wit tha freshly smoked up behavior n' set tha policy state ta NEW.


.nf
  cmake_policy(GET CMP<NNNN> <variable>)
.fi

Peep whether a given policy is set ta OLD or NEW behavior. Shiiit, dis aint no joke.  Da output variable value is ghon be "OLD" or "NEW" if tha policy is set, n' empty otherwise.


CMake keeps policy settings on a stack, so chizzlez made by tha cmake_policy command affect only tha top of tha stack.  A freshly smoked up entry on tha policy stack is managed automatically fo' each subdirectory ta protect its muthafathas n' siblings.  CMake also manages a freshly smoked up entry fo' scripts loaded by include() n' find_package() commandz except when invoked wit tha NO_POLICY_SCOPE option (see also policy CMP0011).  Da cmake_policy command serves up a intercourse ta manage custom entries on tha policy stack:


.nf
  cmake_policy(PUSH)
  cmake_policy(POP)
.fi

Each PUSH must gotz a matchin POP ta erase any chizzles.  This is useful ta make temporary chizzlez ta policy settings.


Functions n' macros record policy settings when they is pimped n' use tha pre\-record policies when they is invoked. Y'all KNOW dat shit, muthafucka!  If tha function or macro implementation sets policies, tha chizzlez automatically propagate up all up in callaz until they reach tha closest nested policy stack entry.

.TP
.B configure_file
Copy a gangbangin' file ta another location n' modify its contents.

.nf
  configure_file(<input> <output>
                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY] 
                 [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])
.fi

Copies a gangbangin' file <input> ta file <output> n' substitutes variable joints referenced up in tha file content.  If <input> be a relatizzle path it is evaluated wit respect ta tha current source directory.  Da <input> must be a gangbangin' file, not a gangbangin' finger-lickin' directory.  If <output> be a relatizzle path it is evaluated wit respect ta tha current binary directory.  If <output> names a existin directory tha input file is placed up in dat directory wit its original gangsta name.  


If tha <input> file is modified tha build system will re\-run CMake ta re\-configure tha file n' generate tha build system again.


This command replaces any variablez up in tha input file referenced as ${VAR} or @VAR@ wit they joints as determined by CMake.  If a variable aint defined, it is ghon be replaced wit nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes is ghon be C\-style escaped. Y'all KNOW dat shit, muthafucka!  Da file is ghon be configured wit tha current jointz of CMake variables. If @ONLY is specified, only variablez of tha form @VAR@ is ghon be replaced n' ${VAR} is ghon be ignored. Y'all KNOW dat shit, muthafucka!  This is useful fo' configurin scripts dat use ${VAR}.


Input file linez of tha form "#cmakedefine VAR ..." is ghon be replaced wit either "#define VAR ..." or "/* #undef VAR */" dependin on whether VAR is set up in CMake ta any value not considered a gangbangin' false constant by tha if() command. Y'all KNOW dat shit, muthafucka! (Content of "...", if any, is processed as above.) Input file linez of tha form "#cmakedefine01 VAR" is ghon be replaced wit either "#define VAR 1" or "#define VAR 0" similarly.


With NEWLINE_STYLE tha line endin could be adjusted: 


.nf
    'UNIX' or 'LF' fo' \\n, 'DOS', 'WIN32' or 'CRLF' fo' \\r\\n.
.fi

COPYONLY must not be used wit NEWLINE_STYLE.


.TP
.B create_test_sourcelist
Smoke a test driver n' source list fo' buildin test programs.

.nf
  create_test_sourcelist(sourceListName driverName
                         test1 test2 test3
                         EXTRA_INCLUDE include.h
                         FUNCTION function)
.fi

A test driver be a program dat links together nuff lil' small-ass tests tha fuck into a single executable.  This is useful when buildin static executablez wit big-ass libraries ta shrink tha total required size.  Da list of source filez needed ta build tha test driver is ghon be up in sourceListName.  DriverName is tha name of tha test driver program.  Da rest of tha arguments consist of a list of test source files, can be semicolon separated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Each test source file should gotz a gangbangin' function up in it dat is tha same ol' dirty name as tha file wit no extension (foo.cxx should have int foo(int, char*[]);) DriverName is ghon be able ta booty-call each of tha tests by name on tha command line. If EXTRA_INCLUDE is specified, then tha next argument is included tha fuck into tha generated file. If FUNCTION is specified, then tha next argument is taken as a gangbangin' function name dat is passed a pointa ta ac n' av.  This can be used ta add extra command line processin ta each test. Da cmake variable CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set ta have code dat is ghon be placed directly before callin tha test main function. I aint talkin' bout chicken n' gravy biatch.   CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set ta have code dat is ghon be placed directly afta tha call ta tha test main function.

.TP
.B define_property
Define n' document custom properties.

.nf
  define_property(<GLOBAL | DIRECTORY | TARGET | SOURCE |
                   TEST | VARIABLE | CACHED_VARIABLE>
                   PROPERTY <name> [INHERITED]
                   BRIEF_DOCS <brief\-doc> [docs...]
                   FULL_DOCS <full\-doc> [docs...])
.fi

Define one property up in a scope fo' use wit tha set_property n' get_property commands.  This is primarily useful ta associate documentation wit property names dat may be retrieved wit tha get_property command. Y'all KNOW dat shit, muthafucka!  Da first argument determines tha kind of scope up in which tha property should be used. Y'all KNOW dat shit, muthafucka!  It must be one of tha following:


.nf
  GLOBAL    = associated wit tha global namespace
  DIRECTORY = associated wit one directory
  TARGET    = associated wit one target
  SOURCE    = associated wit one source file
  TEST      = associated wit a test named wit add_test
  VARIABLE  = documents a CMake language variable
  CACHED_VARIABLE = documents a CMake cache variable
.fi

Note dat unlike set_property n' get_property no actual scope need ta be given; only tha kind of scope is blingin.


Da required PROPERTY option is immediately followed by tha name of tha property bein defined.


If tha INHERITED option then tha get_property command will chain up ta tha next higher scope when tha axed property aint set up in tha scope given ta tha command. Y'all KNOW dat shit, muthafucka!  DIRECTORY scope chains ta GLOBAL.  TARGET, SOURCE, n' TEST chain ta DIRECTORY.


Da BRIEF_DOCS n' FULL_DOCS options is followed by strings ta be associated wit tha property as its brief n' full documentation. I aint talkin' bout chicken n' gravy biatch.  Correspondin options ta tha get_property command will retrieve tha documentation.

.TP
.B else
Starts tha else portion of a if block.

.nf
  else(expression)
.fi

See tha if command.

.TP
.B elseif
Starts tha elseif portion of a if block.

.nf
  elseif(expression)
.fi

See tha if command.

.TP
.B enable_language
Enable a language (CXX/C/Fortran/etc)

.nf
  enable_language(<lang> [OPTIONAL] )
.fi

This command enablez support fo' tha named language up in CMake. This is tha same ol' dirty as tha project command but do not create any of tha extra variablez dat is pimped by tha project command. Y'all KNOW dat shit, muthafucka! Example languages is CXX, C, Fortran. I aint talkin' bout chicken n' gravy biatch. 


This command must be called up in file scope, not up in a gangbangin' function call.  Furthermore, it must be called up in tha highest directory common ta all targets rockin tha named language directly fo' compilin sources or indirectly all up in link dependencies. Put ya muthafuckin choppers up if ya feel dis!  It be simplest ta enable all needed languages up in tha top\-level directory of a project.


Da OPTIONAL keyword be a placeholda fo' future implementation n' do not currently work.

.TP
.B enable_testing
Enable testin fo' current directory n' below.

.nf
  enable_testing()
.fi

Enablez testin fo' dis directory n' below.  See also tha add_test command. Y'all KNOW dat shit, muthafucka!  Note dat ctest expects ta find a test file up in tha build directory root.  Therefore, dis command should be up in tha source directory root.

.TP
.B endforeach
Endz a list of commandz up in a FOREACH block.

.nf
  endforeach(expression)
.fi

See tha FOREACH command.

.TP
.B endfunction
Endz a list of commandz up in a gangbangin' function block.

.nf
  endfunction(expression)
.fi

See tha function command.

.TP
.B endif
Endz a list of commandz up in a if block.

.nf
  endif(expression)
.fi

See tha if command.

.TP
.B endmacro
Endz a list of commandz up in a macro block.

.nf
  endmacro(expression)
.fi

See tha macro command.

.TP
.B endwhile
Endz a list of commandz up in a while block.

.nf
  endwhile(expression)
.fi

See tha while command.

.TP
.B execute_process
Execute one or mo' lil pimp processes.

.nf
  execute_process(COMMAND <cmd1> [args1...]]
                  [COMMAND <cmd2> [args2...] [...]]
                  [WORKING_DIRECTORY <directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE <variable>]
                  [OUTPUT_VARIABLE <variable>]
                  [ERROR_VARIABLE <variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                  [OUTPUT_STRIP_TRAILING_WHITESPACE]
                  [ERROR_STRIP_TRAILING_WHITESPACE])
.fi

Runs tha given sequence of one or mo' commandz wit tha standard output of each process piped ta tha standard input of tha next.  A single standard error pipe is used fo' all processes.  If WORKING_DIRECTORY is given tha named directory is ghon be set as tha current hustlin directory of tha lil pimp processes.  If TIMEOUT is given tha lil pimp processes is ghon be terminated if they do not finish up in tha specified number of secondz (fractions is allowed).  If RESULT_VARIABLE is given tha variable is ghon be set ta contain tha result of hustlin tha processes.  This is ghon be a integer return code from tha last lil pimp or a strang describin a error condition. I aint talkin' bout chicken n' gravy biatch.  If OUTPUT_VARIABLE or ERROR_VARIABLE is given tha variable named is ghon be set wit tha contentz of tha standard output n' standard error pipes respectively.  If tha same variable is named fo' both pipes they output is ghon be merged up in tha order produced. Y'all KNOW dat shit, muthafucka!  If INPUT_FILE, OUTPUT_FILE, or ERROR_FILE is given tha file named is ghon be attached ta tha standard input of tha straight-up original gangsta process, standard output of tha last process, or standard error of all processes respectively.  If OUTPUT_QUIET or ERROR_QUIET is given then tha standard output or standard error thangs up in dis biatch is ghon be on tha fuckin' down-lowly ignored. Y'all KNOW dat shit, muthafucka!  If mo' than one OUTPUT_* or ERROR_* option is given fo' tha same pipe tha precedence aint specified. Y'all KNOW dat shit, muthafucka!  If no OUTPUT_* or ERROR_* options is given tha output is ghon be shared wit tha correspondin pipez of tha CMake process itself.


Da execute_process command be a newer mo' bangin version of exec_program yo, but tha oldschool command has been kept fo' compatibility.

.TP
.B export
Export targets from tha build tree fo' use by outside projects.

.nf
  export(TARGETS [target1 [target2 [...]]] [NAMESPACE <namespace>]
         [APPEND] FILE <filename> [EXPORT_LINK_INTERFACE_LIBRARIES])
.fi

Smoke a gangbangin' file <filename> dat may be included by outside projects ta import targets from tha current projectz build tree.  This is useful durin cross\-compilin ta build utilitizzle executablez dat can run on tha host platform up in one project n' then import dem tha fuck into another project bein compiled fo' tha target platform.  If tha NAMESPACE option is given tha <namespace> strang is ghon be prepended ta all target names freestyled ta tha file.  If tha APPEND option is given tha generated code is ghon be appended ta tha file instead of overwritin dat shit.  Da EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes tha contentz of tha propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>), biatch? ta be exported, when policy CMP0022 is NEW.  If a library target is included up in tha export but a target ta which it links aint included tha behavior is unspecified.


Da file pimped by dis command is specific ta tha build tree n' should never be installed. Y'all KNOW dat shit, muthafucka!  See tha install(EXPORT) command ta export targets from a installation tree.


Do not set propertizzles dat affect tha location of a target afta passin it ta dis command. Y'all KNOW dat shit, muthafucka!  These include propertizzles whose names match "(RUNTIME|LIBRARY|ARCHIVE)_OUTPUT_(NAME|DIRECTORY)(_<CONFIG>)?", "(IMPLIB_)?(PREFIX|SUFFIX)", or "LINKER_LANGUAGE".  Failure ta follow dis rule aint diagnosed n' leaves tha location of tha target undefined.


.nf
  export(PACKAGE <name>)
.fi

Store tha current build directory up in tha CMake user package registry fo' package <name>.  Da find_package command may consider tha directory while searchin fo' package <name>.  This helps dependent projects find n' bust a package from tha current projectz build tree without help from tha user n' shit.  Note dat tha entry up in tha package registry dat dis command creates works only up in conjunction wit a package configuration file (<name>Config.cmake) dat works wit tha build tree.

.TP
.B file
File manipulation command.

.nf
  file(WRITE filename "message ta write"... )
  file(APPEND filename "message ta write"... )
  file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])
  file(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512> filename variable)
  file(STRINGS filename variable [LIMIT_COUNT num]
       [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]
       [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]
       [NEWLINE_CONSUME] [REGEX regex]
       [NO_HEX_CONVERSION])
  file(GLOB variable [RELATIVE path] [globbin expressions]...)
  file(GLOB_RECURSE variable [RELATIVE path] 
       [FOLLOW_SYMLINKS] [globbin expressions]...)
  file(RENAME <oldname> <newname>)
  file(REMOVE [file1 ...])
  file(REMOVE_RECURSE [file1 ...])
  file(MAKE_DIRECTORY [directory1 directory2 ...])
  file(RELATIVE_PATH variable directory file)
  file(TO_CMAKE_PATH path result)
  file(TO_NATIVE_PATH path result)
  file(DOWNLOAD url file [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS]
       [EXPECTED_HASH ALGO=value] [EXPECTED_MD5 sum]
       [TLS_VERIFY on|off] [TLS_CAINFO file])
  file(UPLOAD filename url [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS])
  file(TIMESTAMP filename variable [<format string>] [UTC])
  file(GENERATE OUTPUT output_file
       <INPUT input_file|CONTENT input_content>
       [CONDITION expression])
.fi

WRITE will write a message tha fuck into a gangbangin' file called 'filename'. Well shiiiit, it overwrites tha file if it already exists, n' creates tha file if it do not exist. (If tha file be a funky-ass build input, use configure_file ta update tha file only when its content chizzles.)


APPEND will write a message tha fuck into a gangbangin' file same as WRITE, except it will append it ta tha end of tha file


READ will read tha content of a gangbangin' file n' store it tha fuck into tha variable. Well shiiiit, it will start all up in tha given offset n' read up ta numBytes. If tha argument HEX is given, tha binary data is ghon be converted ta hexadecimal representation n' dis is ghon be stored up in tha variable.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha content of a gangbangin' file.


STRINGS will parse a list of ASCII strings from a gangbangin' file n' store it up in a variable. Binary data up in tha file is ignored. Y'all KNOW dat shit, muthafucka! Carriage return (CR) charactas is ignored. Y'all KNOW dat shit, muthafucka! Well shiiiit, it works also fo' Intel Hex n' Motorola S\-record files, which is automatically converted ta binary format when readin em. Disable dis rockin NO_HEX_CONVERSION.


LIMIT_COUNT sets tha maximum number of strings ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. LIMIT_INPUT sets tha maximum number of bytes ta read from tha input file. LIMIT_OUTPUT sets tha maximum number of bytes ta store up in tha output variable. LENGTH_MINIMUM sets tha minimum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Shorta strings is ignored. Y'all KNOW dat shit, muthafucka! LENGTH_MAXIMUM sets tha maximum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Longer strings is split tha fuck into strings no longer than tha maximum length. NEWLINE_CONSUME allows newlines ta be included up in strings instead of terminatin em.


REGEX specifies a regular expression dat a strang must match ta be returned. Y'all KNOW dat shit, muthafucka! Typical usage 


.nf
  file(STRINGS myfile.txt myfile)
.fi

stores a list up in tha variable "myfile" up in which each item be a line from tha input file.


GLOB will generate a list of all filez dat match tha globbin expressions n' store it tha fuck into tha variable. Globbin expressions is similar ta regular expressions yo, but much simpla n' shit. If RELATIVE flag is specified fo' a expression, tha thangs up in dis biatch is ghon be returned as a relatizzle path ta tha given path.  (Us dudes do not recommend rockin GLOB ta collect a list of source filez from yo' source tree.  If no CMakeLists.txt file chizzlez when a source be added or removed then tha generated build system cannot know when ta ask CMake ta regenerate.)


Examplez of globbin expressions include:


.nf
   *.cxx      \- match all filez wit extension cxx
   *.vt, biatch?      \- match all filez wit extension vta,...,vtz
   f[3\-5].txt \- match filez f3.txt, f4.txt, f5.txt
.fi

GLOB_RECURSE will generate a list similar ta tha regular GLOB, except it will traverse all tha subdirectoriez of tha matched directory n' match tha files. Right back up in yo muthafuckin ass. Subdirectories dat is symlinks is only traversed if FOLLOW_SYMLINKS is given or cmake policy CMP0009 aint set ta NEW. Right back up in yo muthafuckin ass. See cmake \-\-help\-policy CMP0009 fo' mo' shiznit.


Examplez of recursive globbin include:


.nf
   /dir/*.py  \- match all python filez up in /dir n' subdirectories
.fi

MAKE_DIRECTORY will create tha given directories, also if they parent directories don't exist yet


RENAME moves a gangbangin' file or directory within a gangbangin' filesystem, replacin tha destination atomically.


REMOVE will remove tha given files, also up in subdirectories


REMOVE_RECURSE will remove tha given filez n' directories, also non\-empty directories


RELATIVE_PATH will determine relatizzle path from directory ta tha given file.


TO_CMAKE_PATH will convert path tha fuck into a cold-ass lil cmake steez path wit unix /.  Da input can be a single path or a system path like "$ENV{PATH}".  Note tha double quotes round tha ENV call TO_CMAKE_PATH only takes  one argument. This command will also convert tha natizzle list delimitas fo' a list of paths like tha PATH environment variable.


TO_NATIVE_PATH works just like TO_CMAKE_PATH yo, but will convert from  a cold-ass lil cmake steez path tha fuck into tha natizzle path steez \\ fo' windows n' / fo' UNIX.


DOWNLOAD will downlizzle tha given URL ta tha given file. If LOG var is specified a log of tha downlizzle is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If EXPECTED_HASH ALGO=value is specified, tha operation will verify dat tha downloaded filez actual hash matches tha expected value, where ALGO is one of MD5, SHA1, SHA224, SHA256, SHA384, or SHA512.  If it do not match, tha operation fails wit a error. Shiiit, dis aint no joke. ("EXPECTED_MD5 sum" is short\-hand fo' "EXPECTED_HASH MD5=sum".) If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete. For https URLs CMake must be built wit OpenSSL.  TLS/SSL certificates is not checked by default.  Set TLS_VERIFY ta ON ta check certificates and/or use EXPECTED_HASH ta verify downloaded content.  Set TLS_CAINFO ta specify a cold-ass lil custom Certificate Authoritizzle file.  If either TLS option aint given CMake will check variablez CMAKE_TLS_VERIFY n' CMAKE_TLS_CAINFO, respectively.


UPLOAD will upload tha given file ta tha given URL. If LOG var is specified a log of tha upload is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete.


TIMESTAMP will write a strang representation of tha modification time of filename ta variable.


Should tha command be unable ta obtain a timestamp variable is ghon be set ta tha empty strang "".


See documentation of tha strang TIMESTAMP sub\-command fo' mo' details.


Da file() command also serves up COPY n' INSTALL signatures:


.nf
  file(<COPY|INSTALL> files... DESTINATION <dir>
       [FILE_PERMISSIONS permissions...]
       [DIRECTORY_PERMISSIONS permissions...]
       [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]
       [FILES_MATCHING]
       [[PATTERN <pattern> | REGEX <regex>]
        [EXCLUDE] [PERMISSIONS permissions...]] [...])
.fi

Da COPY signature copies files, directories, n' symlinks ta a thugged-out destination folda n' shit.  Relatizzle input paths is evaluated wit respect ta tha current source directory, n' a relatizzle destination is evaluated wit respect ta tha current build directory.  Copyin preserves input file timestamps, n' optimizes up a gangbangin' file if it exists all up in tha destination wit tha same timestamp.  Copyin preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS is given (default is USE_SOURCE_PERMISSIONS).  See tha install(DIRECTORY) command fo' documentation of permissions, PATTERN, REGEX, n' EXCLUDE options.  


Da INSTALL signature differs slightly from COPY: it prints status lyrics, n' NO_SOURCE_PERMISSIONS is default.  Installation scripts generated by tha install() command use dis signature (with some undocumented options fo' internal use).


GENERATE will write a <output_file> wit content from a <input_file>, or from <input_content>.  Da output is generated conditionally based on tha content of tha <condition>.  Da file is freestyled at CMake generate\-time n' tha input may contain generator expressions.  Da <condition>, <output_file> n' <input_file> may also contain generator expressions.  Da <condition> must evaluate ta either '0' or '1'.  Da <output_file> must evaluate ta a unique name among all configurations n' among all invocationz of file(GENERATE).

.TP
.B find_file
Find tha full path ta a gangbangin' file.

.nf
   find_file(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_file(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_file(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' full path ta named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha full path ta a gangbangin' file is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_file is invoked wit tha same variable.  Da name of tha full path ta a gangbangin' file dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_file(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_file(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B find_library
Find a library.

.nf
   find_library(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_library(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_library(
             <VAR>
             name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a library fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha library is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_library is invoked wit tha same variable.  Da name of tha library dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   LIB
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_LIBRARY_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_library(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_library(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When mo' than one value is given ta tha NAMES option dis command by default will consider one name at a time n' search every last muthafuckin directory fo' dat shit.  Da NAMES_PER_DIR option  drops some lyrics ta dis command ta consider one directory at a time n' search fo' all names up in dat shit.


If tha library found be a gangbangin' framework, then VAR is ghon be set ta tha full path ta tha framework <fullPath>/A.framework. When a gangbangin' full path ta a gangbangin' framework is used as a library, CMake will bust a \-framework A, n' a \-F<fullPath> ta link tha framework ta tha target.


If tha global property FIND_LIBRARY_USE_LIB64_PATHS is set all search paths is ghon be tested as normal, wit "64/" appended, n' wit all matchez of "lib/" replaced wit "lib64/". This property be automatically set fo' tha platforms dat is known ta need it if at least one of tha languages supported by tha PROJECT command is enabled.

.TP
.B find_package
Load settings fo' a external project.

.nf
  find_package(<package> [version] [EXACT] [QUIET] [MODULE]
               [REQUIRED] [[COMPONENTS] [components...]]
               [OPTIONAL_COMPONENTS components...]
               [NO_POLICY_SCOPE])
.fi

Findz n' loadz settings from a external project.  <package>_FOUND is ghon be set ta indicate whether tha package was found. Y'all KNOW dat shit, muthafucka!  When tha package is found package\-specific shiznit is provided all up in variablez n' imported targets documented by tha package itself.  Da QUIET option disablez lyrics if tha package cannot be found. Y'all KNOW dat shit, muthafucka!  Da MODULE option disablez tha second signature documented below.  Da REQUIRED option stops processin wit a error message if tha package cannot be found.


A package\-specific list of required components may be listed afta tha COMPONENTS option (or afta tha REQUIRED option if present).  Additionizzle optionizzle components may be listed afta OPTIONAL_COMPONENTS.  Available components n' they influence on whether a package is considered ta be found is defined by tha target package.


Da [version] argument requests a version wit which tha package found should be compatible (format is major[.minor[.patch[.tweak]]]).  Da EXACT option requests dat tha version be matched exactly.  If no [version] and/or component list is given ta a recursive invocation inside a gangbangin' find\-module, tha correspondin arguments is forwarded automatically from tha outa call (includin tha EXACT flag fo' [version]).  Version support is currently provided only on a package\-by\-package basis (details below).


User code should generally look fo' packages rockin tha above simple signature.  Da remainder of dis command documentation specifies tha full command signature n' detailz of tha search process.  Project maintainers wishin ta provide a package ta be found by dis command is encouraged ta read on.


Da command has two modes by which it searches fo' packages: "Module" mode n' "Config" mode.  Module mode be available when tha command is invoked wit tha above reduced signature.  CMake searches fo' a gangbangin' file called "Find<package>.cmake" up in tha CMAKE_MODULE_PATH followed by tha CMake installation. I aint talkin' bout chicken n' gravy biatch.  If tha file is found, it is read n' processed by CMake.  It be responsible fo' findin tha package, checkin tha version, n' producin any needed lyrics.  Many find\-modulez provide limited or no support fo' versioning; check tha module documentation. I aint talkin' bout chicken n' gravy biatch.  If no module is found n' tha MODULE option aint given tha command proceedz ta Config mode.


Da complete Config mode command signature is:


.nf
  find_package(<package> [version] [EXACT] [QUIET]
               [REQUIRED] [[COMPONENTS] [components...]]
               [CONFIG|NO_MODULE]
               [NO_POLICY_SCOPE]
               [NAMES name1 [name2 ...]]
               [CONFIGS config1 [config2 ...]]
               [HINTS path1 [path2 ... ]]
               [PATHS path1 [path2 ... ]]
               [PATH_SUFFIXES suffix1 [suffix2 ...]]
               [NO_DEFAULT_PATH]
               [NO_CMAKE_ENVIRONMENT_PATH]
               [NO_CMAKE_PATH]
               [NO_SYSTEM_ENVIRONMENT_PATH]
               [NO_CMAKE_PACKAGE_REGISTRY]
               [NO_CMAKE_BUILDS_PATH]
               [NO_CMAKE_SYSTEM_PATH]
               [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
               [CMAKE_FIND_ROOT_PATH_BOTH |
                ONLY_CMAKE_FIND_ROOT_PATH |
                NO_CMAKE_FIND_ROOT_PATH])
.fi

Da CONFIG option may be used ta skip Module mode explicitly n' switch ta Config mode.  It be synonymous ta rockin NO_MODULE.  Config mode be also implied by use of options not specified up in tha reduced signature.  


Config mode attempts ta locate a cold-ass lil configuration file provided by tha package ta be found. Y'all KNOW dat shit, muthafucka!  A cache entry called <package>_DIR is pimped ta hold tha directory containin tha file.  By default tha command searches fo' a package wit tha name <package>.  If tha NAMES option is given tha names followin it is used instead of <package>.  Da command searches fo' a gangbangin' file called "<name>Config.cmake" or "<lower\-case\-name>\-config.cmake" fo' each name specified. Y'all KNOW dat shit, muthafucka!  A replacement set of possible configuration file names may be given rockin tha CONFIGS option. I aint talkin' bout chicken n' gravy biatch.  Da search procedure is specified below.  Once found, tha configuration file is read n' processed by CMake.  Since tha file is provided by tha package it already knows tha location of package contents, n' you can put dat on yo' toast.  Da full path ta tha configuration file is stored up in tha cmake variable <package>_CONFIG.


All configuration filez which done been considered by CMake while searchin fo' a installation of tha package wit a appropriate version is stored up in tha cmake variable <package>_CONSIDERED_CONFIGS, tha associated versions up in <package>_CONSIDERED_VERSIONS. 


If tha package configuration file cannot be found CMake will generate a error describin tha problem unless tha QUIET argument is specified. Y'all KNOW dat shit, muthafucka!  If REQUIRED is specified n' tha package aint found a gangbangin' fatal error is generated n' tha configure step stops executing.  If <package>_DIR has been set ta a gangbangin' finger-lickin' directory not containin a cold-ass lil configuration file CMake will ignore it n' search from scratch.


When tha [version] argument is given Config mode will only find a version of tha package dat fronts compatibilitizzle wit tha axed version (format is major[.minor[.patch[.tweak]]]).  If tha EXACT option is given only a version of tha package frontin a exact match of tha axed version may be found. Y'all KNOW dat shit, muthafucka!  CMake do not establish any convention fo' tha meanin of version numbers.  Package version numbers is checked by "version" filez provided by tha packages theyselves.  For a cold-ass lil muthafucka package configuration file "<config\-file>.cmake" tha correspondin version file is located next ta it n' named either "<config\-file>\-version.cmake" or "<config\-file>Version.cmake".  If no such version file be available then tha configuration file be assumed ta not be compatible wit any axed version. I aint talkin' bout chicken n' gravy biatch.  A basic version file containin generic version matchin code can be pimped rockin tha macro write_basic_package_version_file(), peep its documentation fo' mo' details.  When a version file is found it is loaded ta check tha axed version number n' shit.  Da version file is loaded up in a nested scope up in which tha followin variablez done been defined:


.nf
  PACKAGE_FIND_NAME          = tha <package> name
  PACKAGE_FIND_VERSION       = full axed version string
  PACKAGE_FIND_VERSION_MAJOR = major version if requested, else 0
  PACKAGE_FIND_VERSION_MINOR = minor version if requested, else 0
  PACKAGE_FIND_VERSION_PATCH = patch version if requested, else 0
  PACKAGE_FIND_VERSION_TWEAK = tweak version if requested, else 0
  PACKAGE_FIND_VERSION_COUNT = number of version components, 0 ta 4
.fi

Da version file checks whether it satisfies tha axed version n' sets these variables:


.nf
  PACKAGE_VERSION            = full provided version string
  PACKAGE_VERSION_EXACT      = legit if version is exact match
  PACKAGE_VERSION_COMPATIBLE = legit if version is compatible
  PACKAGE_VERSION_UNSUITABLE = legit if unsuitable as any version
.fi

These variablez is checked by tha find_package command ta determine whether tha configuration file serves up a aaight version. I aint talkin' bout chicken n' gravy biatch.  They is not available afta tha find_package call returns.  If tha version be aaight tha followin variablez is set:


.nf
  <package>_VERSION       = full provided version string
  <package>_VERSION_MAJOR = major version if provided, else 0
  <package>_VERSION_MINOR = minor version if provided, else 0
  <package>_VERSION_PATCH = patch version if provided, else 0
  <package>_VERSION_TWEAK = tweak version if provided, else 0
  <package>_VERSION_COUNT = number of version components, 0 ta 4
.fi

and tha correspondin package configuration file is loaded. Y'all KNOW dat shit, muthafucka!  When multiple package configuration filez is available whose version filez claim compatibilitizzle wit tha version axed it is unspecified which one is chosen. I aint talkin' bout chicken n' gravy biatch.  No attempt is made ta chizzle a highest or closest version number.


Config mode serves up a elaborate intercourse n' search procedure.  Much of tha intercourse is provided fo' completenizz n' fo' use internally by find\-modulez loaded by Module mode.  Most user code should simply call


.nf
  find_package(<package> [major[.minor]] [EXACT] [REQUIRED|QUIET])
.fi

in order ta find a package.  Package maintainers providin CMake package configuration filez is encouraged ta name n' install dem such dat tha procedure outlined below will find dem without requirin use of additionizzle options.


CMake constructs a set of possible installation prefixes fo' tha package.  Under each prefix nuff muthafuckin directories is searched fo' a cold-ass lil configuration file.  Da tablez below show tha directories searched. Y'all KNOW dat shit, muthafucka!  Each entry is meant fo' installation trees followin Windows (W), UNIX (U), or Applez (A) conventions.


.nf
  <prefix>/                                               (W)
  <prefix>/(cmake|CMake)/                                 (W)
  <prefix>/<name>*/                                       (W)
  <prefix>/<name>*/(cmake|CMake)/                         (W)
  <prefix>/(lib/<arch>|lib|share)/cmake/<name>*/          (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/                (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/(cmake|CMake)/  (U)
.fi

On systems supportin OS X Frameworks n' Application Bundlez tha followin directories is searched fo' frameworks or bundlez containin a cold-ass lil configuration file:


.nf
  <prefix>/<name>.framework/Resources/                    (A)
  <prefix>/<name>.framework/Resources/CMake/              (A)
  <prefix>/<name>.framework/Versions/*/Resources/         (A)
  <prefix>/<name>.framework/Versions/*/Resources/CMake/   (A)
  <prefix>/<name>.app/Contents/Resources/                 (A)
  <prefix>/<name>.app/Contents/Resources/CMake/           (A)
.fi

In all cases tha <name> is treated as case\-insensitizzle n' correspondz ta any of tha names specified (<package> or names given by NAMES).  Paths wit lib/<arch> is enabled if CMAKE_LIBRARY_ARCHITECTURE is set.  If PATH_SUFFIXES is specified tha suffixes is appended ta each (W) or (U) directory entry one\-by\-one.


This set of directories is intended ta work up in cooperation wit projects dat provide configuration filez up in they installation trees.  Directories above marked wit (W) is intended fo' installations on Windows where tha prefix may point all up in tha top of a applicationz installation directory.  Those marked wit (U) is intended fo' installations on UNIX platforms where tha prefix is shared by multiple packages.  This is merely a cold-ass lil convention, so all (W) n' (U) directories is still searched on all platforms.  Directories marked wit (A) is intended fo' installations on Applez platforms.  Da cmake variablez CMAKE_FIND_FRAMEWORK n' CMAKE_FIND_APPBUNDLE determine tha order of preference as specified below.


Da set of installation prefixes is constructed rockin tha followin steps.  If NO_DEFAULT_PATH is specified all NO_* options is enabled.


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <package>_DIR
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed. Y'all KNOW dat shit, muthafucka!  Path entries endin up in "/bin" or "/sbin" is automatically converted ta they parent directories.


.nf
   PATH
.fi

5. Right back up in yo muthafuckin ass. Search project build trees recently configured up in a CMake GUI.  This can be skipped if NO_CMAKE_BUILDS_PATH is passed. Y'all KNOW dat shit, muthafucka!  It be intended fo' tha case when a user is buildin multiple dependent projects one afta another.


6. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake user package registry.  This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  On UNIX platforms a <package> may step tha fuck up under tha directory


.nf
  ~/.cmake/packages/<package>
.fi

as a gangbangin' file, wit arbitrary name, whose content specifies tha directory containin tha package configuration file.  See tha export(PACKAGE) command ta create user package registry entries fo' project build trees.


7. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

8. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake system package registry.  This can be skipped if NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_LOCAL_MACHINE\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  There is no system package registry on non\-Windows platforms.


9. Right back up in yo muthafuckin ass. Search paths specified by tha PATHS option. I aint talkin' bout chicken n' gravy biatch.  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_package(<package> PATHS paths... NO_DEFAULT_PATH)
   find_package(<package>)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


Every non\-REQUIRED find_package() call can be disabled by settin tha variable CMAKE_DISABLE_FIND_PACKAGE_<package> ta TRUE. Right back up in yo muthafuckin ass. See tha documentation fo' tha CMAKE_DISABLE_FIND_PACKAGE_<package> variable fo' mo' shiznit.


When loadin a gangbangin' find module or package configuration file find_package defines variablez ta provide shiznit bout tha call arguments (and restores they original gangsta state before returning):


.nf
 <package>_FIND_REQUIRED      = legit if REQUIRED option was given
 <package>_FIND_QUIETLY       = legit if QUIET option was given
 <package>_FIND_VERSION       = full axed version string
 <package>_FIND_VERSION_MAJOR = major version if requested, else 0
 <package>_FIND_VERSION_MINOR = minor version if requested, else 0
 <package>_FIND_VERSION_PATCH = patch version if requested, else 0
 <package>_FIND_VERSION_TWEAK = tweak version if requested, else 0
 <package>_FIND_VERSION_COUNT = number of version components, 0 ta 4
 <package>_FIND_VERSION_EXACT = legit if EXACT option was given
 <package>_FIND_COMPONENTS    = list of axed components
 <package>_FIND_REQUIRED_<c>  = legit if component <c> is required
                                false if component <c> is optional
.fi

In Module mode tha loaded find module is responsible ta honor tha request detailed by these variables; peep tha find module fo' details.  In Config mode find_package handlez REQUIRED, QUIET, n' version options automatically but leaves it ta tha package configuration file ta handle components up in a way dat make sense fo' tha package.  Da package configuration file may set <package>_FOUND ta false ta tell find_package dat component requirements is not satisfied.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B find_path
Find tha directory containin a gangbangin' file.

.nf
   find_path(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_path(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_path(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' finger-lickin' directory containin tha named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha file up in a gangbangin' finger-lickin' directory is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_path is invoked wit tha same variable.  Da name of tha file up in a gangbangin' finger-lickin' directory dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_path(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_path(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When searchin fo' frameworks, if tha file is specified as A/b.h, then tha framework search will look fo' A.framework/Headers/b.h. If dat is found tha path is ghon be set ta tha path ta tha framework. CMake will convert dis ta tha erect \-F option ta include tha file. 

.TP
.B find_program
Find a executable program.

.nf
   find_program(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_program(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_program(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a program fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha program is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_program is invoked wit tha same variable.  Da name of tha program dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_PROGRAM_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_program(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_program(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B fltk_wrap_ui
Smoke FLTK user intercourses Wrappers.

.nf
  fltk_wrap_ui(resultingLibraryName source1
               source2 ... sourceN )
.fi

Produce .h n' .cxx filez fo' all tha .fl n' .fld filez listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da resultin .h n' .cxx filez is ghon be added ta a variable named resultingLibraryName_FLTK_UI_SRCS which should be added ta yo' library.

.TP
.B foreach
Evaluate a crew of commandz fo' each value up in a list.

.nf
  foreach(loop_var arg1 arg2 ...)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endforeach(loop_var)
.fi

All commandz between foreach n' tha matchin endforeach is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endforeach is evaluated, tha recorded list of commandz is invoked once fo' each argument listed up in tha original gangsta foreach command. Y'all KNOW dat shit, muthafucka!  Before each iteration of tha loop "${loop_var}" is ghon be set as a variable wit tha current value up in tha list.


.nf
  foreach(loop_var RANGE total)
  foreach(loop_var RANGE start stop [step])
.fi

Foreach can also iterate over a generated range of numbers. There is three typez of dis iteration:


* When specifyin single number, tha range gonna git elements 0 ta "total".


* When specifyin two numbers, tha range gonna git elements from tha straight-up original gangsta number ta tha second number.


* Da third optionizzle number is tha increment used ta iterate from tha straight-up original gangsta number ta tha second number.


.nf
  foreach(loop_var IN [LISTS [list1 [...]]]
                      [ITEMS [item1 [...]]])
.fi

Iterates over a precise list of items.  Da LISTS option names list\-valued variablez ta be traversed, includin empty elements (an empty strang be a zero\-length list).  Da ITEMS option endz argument parsin n' includes all arguments followin it up in tha iteration.

.TP
.B function
Start recordin a gangbangin' function fo' lata invocation as a cold-ass lil command.

.nf
  function(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endfunction(<name>)
.fi

Define a gangbangin' function named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta function yo, but before tha matchin endfunction, is not invoked until tha function is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha function is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha variable ARGC which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ARGV0 ARGV1 ARGV2 ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin functions wit optionizzle arguments fo' realz. Additionally ARGV holdz tha list of all arguments given ta tha function n' ARGN holdz tha list of arguments past tha last expected argument.


A function opens a freshly smoked up scope: peep set(var PARENT_SCOPE) fo' details.


See tha cmake_policy() command documentation fo' tha behavior of policies inside functions.

.TP
.B get_cmake_property
Git a property of tha CMake instance.

.nf
  get_cmake_property(VAR property)
.fi

Git a property from tha CMake instance.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND".  Some supported propertizzles include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, n' COMPONENTS.


See also tha mo' general get_property() command.

.TP
.B get_directory_property
Git a property of DIRECTORY scope.

.nf
  get_directory_property(<variable> [DIRECTORY <dir>] <prop\-name>)
.fi

Store a property of directory scope up in tha named variable.  If tha property aint defined tha empty\-strin is returned. Y'all KNOW dat shit, muthafucka!  Da DIRECTORY argument specifies another directory from which ta retrieve tha property value.  Da specified directory must have already been traversed by CMake.


.nf
  get_directory_property(<variable> [DIRECTORY <dir>]
                         DEFINITION <var\-name>)
.fi

Git a variable definizzle from a gangbangin' finger-lickin' directory.  This form is useful ta git a variable definizzle from another directory.


See also tha mo' general get_property() command.

.TP
.B get_filename_component
Git a specific component of a gangbangin' full filename.

.nf
  get_filename_component(<VAR> <FileName> <COMP> [CACHE])
.fi

Set <VAR> ta a cold-ass lil component of <FileName>, where <COMP> is one of:


.nf
 DIRECTORY = Directory without file name
 NAME      = File name without directory
 EXT       = File name longest extension (.b.c from d/a.b.c)
 NAME_WE   = File name without directory or longest extension
 ABSOLUTE  = Full path ta file
 REALPATH  = Full path ta existin file wit symlinks resolved
 PATH      = Legacy alias fo' DIRECTORY (use fo' CMake <= 2.8.11)
.fi

Paths is returned wit forward slashes n' have no trailin slahes. Da longest file extension be always considered. Y'all KNOW dat shit, muthafucka! If tha optionizzle CACHE argument is specified, tha result variable be added ta tha cache.


.nf
  get_filename_component(<VAR> FileName
                         PROGRAM [PROGRAM_ARGS <ARG_VAR>]
                         [CACHE])
.fi

Da program up in FileName is ghon be found up in tha system search path or left as a gangbangin' full path.  If PROGRAM_ARGS is present wit PROGRAM, then any command\-line arguments present up in tha FileName strang is split from tha program name n' stored up in <ARG_VAR>.  This is used ta separate a program name from its arguments up in a cold-ass lil command line string.

.TP
.B get_property
Git a property.

.nf
  get_property(<variable>
               <GLOBAL             |
                DIRECTORY [dir]    |
                TARGET    <target> |
                SOURCE    <source> |
                TEST      <test>   |
                CACHE     <entry>  |
                VARIABLE>
               PROPERTY <name>
               [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])
.fi

Git one property from one object up in a scope.  Da first argument specifies tha variable up in which ta store tha result.  Da second argument determines tha scope from which ta git tha property.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope must name one existin target.


SOURCE scope must name one source file.


TEST scope must name one existin test.


CACHE scope must name one cache entry.


VARIABLE scope is unique n' do not accept a name.


Da required PROPERTY option is immediately followed by tha name of tha property ta get.  If tha property aint set a empty value is returned. Y'all KNOW dat shit, muthafucka!  If tha SET option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been set.  If tha DEFINED option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been defined like fuckin wit define_property. If BRIEF_DOCS or FULL_DOCS is given then tha variable is set ta a strang containin documentation fo' tha axed property.  If documentation be axed fo' a property dat has not been defined NOTFOUND is returned.

.TP
.B get_source_file_property
Git a property fo' a source file.

.nf
  get_source_file_property(VAR file property)
.fi

Git a property from a source file.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND". Use set_source_files_propertizzles ta set property joints, n' you can put dat on yo' toast.  Source file propertizzles probably control how tha fuck tha file is built. One property dat be always there is LOCATION


See also tha mo' general get_property() command.

.TP
.B get_target_property
Git a property from a target.

.nf
  get_target_property(VAR target property)
.fi

Git a property from a target.   Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND".  Use set_target_propertizzles ta set property joints, n' you can put dat on yo' toast.  Propertizzles is probably used ta control how tha fuck a target is built yo, but some query tha target instead. Y'all KNOW dat shit, muthafucka!  This command can git propertizzles fo' any target so far pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da targets do not need ta be up in tha current CMakeLists.txt file.


See also tha mo' general get_property() command.

.TP
.B get_test_property
Git a property of tha test.

.nf
  get_test_property(test property VAR)
.fi

Git a property from tha Test.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND". For a list of standard propertizzles you can type cmake \-\-help\-property\-list


See also tha mo' general get_property() command.

.TP
.B if
Conditionally execute a crew of commands.

.nf
  if(expression)
    # then section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  elseif(expression2)
    # elseif section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  else(expression)
    # else section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endif(expression)
.fi

Evaluates tha given expression. I aint talkin' bout chicken n' gravy biatch.  If tha result is true, tha commandz up in tha THEN section is invoked. Y'all KNOW dat shit, muthafucka!  Otherwise, tha commandz up in tha else section is invoked. Y'all KNOW dat shit, muthafucka!  Da elseif n' else sections is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass may have multiple elseif clauses. Note dat tha expression up in tha else n' endif clause is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Long expressions can be used n' there be a traditionizzle order of precedence. Parenthetical expressions is evaluated first followed by unary operators like fuckin EXISTS, COMMAND, n' DEFINED. Then any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Then NOT operators n' finally AND, OR operators is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Possible expressions are:


.nf
  if(<constant>)
.fi

True if tha constant is 1, ON, YES, TRUE, Y, or a non\-zero number n' shit.  False if tha constant is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, '', or endz up in tha suffix '\-NOTFOUND'.  Named boolean constants is case\-insensitive.  If tha argument aint one of these constants, it is treated as a variable:


.nf
  if(<variable>)
.fi

True if tha variable is defined ta a value dat aint a gangbangin' false constant.  False otherwise.  (Note macro arguments is not variables.)


.nf
  if(NOT <expression>)
.fi

True if tha expression aint true.


.nf
  if(<expr1> AND <expr2>)
.fi

True if both expressions would be considered legit individually.


.nf
  if(<expr1> OR <expr2>)
.fi

True if either expression would be considered legit individually.


.nf
  if(COMMAND command\-name)
.fi

True if tha given name be a cold-ass lil command, macro or function dat can be invoked.


.nf
  if(POLICY policy\-id)
.fi

True if tha given name be a existin policy (of tha form CMP<NNNN>).


.nf
  if(TARGET target\-name)
.fi

True if tha given name be a existin target, built or imported.


.nf
  if(EXISTS file\-name)
  if(EXISTS directory\-name)
.fi

True if tha named file or directory exists, n' you can put dat on yo' toast.  Behavior is well\-defined only fo' full paths.


.nf
  if(file1 IS_NEWER_THAN file2)
.fi

True if file1 is newer than file2 or if one of tha two filez don't exist. Behavior is well\-defined only fo' full paths. If tha file time stamps is exactly tha same, a IS_NEWER_THAN comparison returns true, so dat any dependent build operations will occur up in tha event of a tie. This includes tha case of passin tha same file name fo' both file1 n' file2.


.nf
  if(IS_DIRECTORY directory\-name)
.fi

True if tha given name be a gangbangin' finger-lickin' directory.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_SYMLINK file\-name)
.fi

True if tha given name be a symbolic link.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_ABSOLUTE path)
.fi

True if tha given path be a absolute path.


.nf
  if(<variable|string> MATCHES regex)
.fi

True if tha given strang or variablez value matches tha given regular expression.


.nf
  if(<variable|string> LESS <variable|string>)
  if(<variable|string> GREATER <variable|string>)
  if(<variable|string> EQUAL <variable|string>)
.fi

True if tha given strang or variablez value be a valid number n' tha inequalitizzle or equalitizzle is true.


.nf
  if(<variable|string> STRLESS <variable|string>)
  if(<variable|string> STRGREATER <variable|string>)
  if(<variable|string> STREQUAL <variable|string>)
.fi

True if tha given strang or variablez value is lexicographically less (or pimped outer, or equal) than tha strang or variable on tha right.


.nf
  if(<variable|string> VERSION_LESS <variable|string>)
  if(<variable|string> VERSION_EQUAL <variable|string>)
  if(<variable|string> VERSION_GREATER <variable|string>)
.fi

Component\-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]]).


.nf
  if(DEFINED <variable>)
.fi

True if tha given variable is defined. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do not matta if tha variable is legit or false just if it has been set.


.nf
  if((expression) AND (expression OR (expression)))
.fi

Da expressions inside tha parenthesis is evaluated first n' then tha remainin expression is evaluated as up in tha previous examples. Where there be nested parenthesis tha innermost is evaluated as part of evaluatin tha expression dat gotz nuff em.


Da if command was freestyled straight-up early up in CMakez history, prepimpin tha ${} variable evaluation syntax, n' fo' convenience evaluates variablez named by its arguments as shown up in tha above signatures.  Note dat aiiight variable evaluation wit ${} applies before tha if command even receives tha arguments, n' you can put dat on yo' toast.  Therefore code like


.nf
  set(var1 OFF)
  set(var2 "var1")
  if(${var2})
.fi

appears ta tha if command as


.nf
  if(var1)
.fi

and is evaluated accordin ta tha if(<variable>) case documented above.  Da result is OFF which is false.  But fuck dat shiznit yo, tha word on tha street is dat if we remove tha ${} from tha example then tha command sees


.nf
  if(var2)
.fi

which is legit cuz var2 is defined ta "var1" which aint a gangbangin' false constant.


Automatic evaluation applies up in tha other cases whenever tha above\-documented signature accepts <variable|string>:


1) Da left hand argument ta MATCHES is first checked ta peep if it aint nuthin but a thugged-out defined variable, if so tha variablez value is used, otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


2) If tha left hand argument ta MATCHES is missin it returns false without error 


3) Both left n' right hand arguments ta LESS GREATER EQUAL is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


4) Both left n' right hand arguments ta STRLESS STREQUAL STRGREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


5) Both left n' right hand argumemnts ta VERSION_LESS VERSION_EQUAL VERSION_GREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


6) Da right hand argument ta NOT is tested ta peep if it aint nuthin but a funky-ass boolean constant, if so tha value is used, otherwise it be assumed ta be a variable n' it is dereferenced. Y'all KNOW dat shit, muthafucka! 


7) Da left n' right hand arguments ta AND OR is independently tested ta peep if they is boolean constants, if so they is used as such, otherwise they is assumed ta be variablez n' is dereferenced. Y'all KNOW dat shit, muthafucka! 


.TP
.B include
Load n' run CMake code from a gangbangin' file or module.

.nf
  include(<file|module> [OPTIONAL] [RESULT_VARIABLE <VAR>]
                        [NO_POLICY_SCOPE])
.fi

Load n' run CMake code from tha file given. I aint talkin' bout chicken n' gravy biatch.  Variable readz n' writes access tha scope of tha calla (dynamic scoping).  If OPTIONAL is present, then no error is raised if tha file do not exist.  If RESULT_VARIABLE is given tha variable is ghon be set ta tha full filename which has been included or NOTFOUND if it failed.


If a module is specified instead of a gangbangin' file, tha file wit name <modulename>.cmake is searched first up in CMAKE_MODULE_PATH, then up in tha CMake module directory. There is one exception ta this: if tha file which calls include() is located itself up in tha CMake module directory, then first tha CMake module directory is searched n' CMAKE_MODULE_PATH afterwards. Right back up in yo muthafuckin ass. See also policy CMP0017.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B include_directories
Add include directories ta tha build.

.nf
  include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)
.fi

Add tha given directories ta dem tha compila uses ta search fo' include files.  Relatizzle paths is interpreted as relatizzle ta tha current source directory. 


Da include directories is added ta tha directory property INCLUDE_DIRECTORIES fo' tha current CMakeLists file. They is also added ta tha target property INCLUDE_DIRECTORIES fo' each target up in tha current CMakeLists file. Da target property joints is tha ones used by tha generators.


By default tha directories is appended onto tha current list of directories. Put ya muthafuckin choppers up if ya feel dis! This default behavior can be chizzled by settin CMAKE_INCLUDE_DIRECTORIES_BEFORE ta ON. By rockin AFTER or BEFORE explicitly, you can select between appendin n' prepending, independent of tha default. 


If tha SYSTEM option is given, tha compila is ghon be holla'd all up in tha directories is meant as system include directories on some platforms (signallin dis settin might big up effects like fuckin tha compila skippin warnings, or these fixed\-install system filez not bein considered up in dependency calculations \- peep compila docs).

.TP
.B include_external_msproject
Include a external Microsizzlez project file up in a workspace.

.nf
  include_external_msproject(projectname location
                             [TYPE projectTypeGUID]
                             [GUID projectGUID]
                             [PLATFORM platformName]
                             dep1 dep2 ...)
.fi

Includes a external Microsizzlez project up in tha generated workspace file.  Currently do not a god damn thang on UNIX. This will create a target named [projectname].  This can be used up in tha add_dependencies command ta make thangs depend on tha external project.


TYPE, GUID n' PLATFORM is optionizzle parametas dat allow one ta specify tha type of project, id (GUID) of tha project n' tha name of tha target platform.  This is useful fo' projects requirin joints other than tha default (e.g. WIX projects). These options is not supported by tha Visual Studio 6 generator.

.TP
.B include_regular_expression
Set tha regular expression used fo' dependency checking.

.nf
  include_regular_expression(regex_match [regex_complain])
.fi

Set tha regular expressions used up in dependency checking.  Only filez matchin regex_match is ghon be traced as dependencies. Put ya muthafuckin choppers up if ya feel dis!  Only filez matchin regex_diss will generate warnings if they cannot be found (standard header paths is not searched).  Da defaults are:


.nf
  regex_match    = "^.*$" (match every last muthafuckin thang)
  regex_diss = "^$" (match empty strang only)
.fi

.TP
.B install
Specify rulez ta run at install time.

This command generates installation rulez fo' a project.  Rulez specified by calls ta dis command within a source directory is executed up in order durin installation. I aint talkin' bout chicken n' gravy biatch.  Da order across directories aint defined.


There is multiple signatures fo' dis command. Y'all KNOW dat shit, muthafucka!  Some of dem define installation propertizzles fo' filez n' targets, n' you can put dat on yo' toast.  Propertizzles common ta multiple signatures is covered here but they is valid only fo' signatures dat specify em.


DESTINATION arguments specify tha directory on disk ta which a gangbangin' file is ghon be installed. Y'all KNOW dat shit, muthafucka!  If a gangbangin' full path (with a leadin slash or drive letter) is given it is used directly.  If a relatizzle path is given it is interpreted relatizzle ta tha value of CMAKE_INSTALL_PREFIX. Da prefix can be relocated at install time rockin DESTDIR mechanizzle explained up in tha CMAKE_INSTALL_PREFIX variable documentation.


PERMISSIONS arguments specify permissions fo' installed files.  Valid permissions is OWNER_READ, OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, n' SETGID.  Permissions dat do not make sense on certain platforms is ignored on dem platforms.


Da CONFIGURATIONS argument specifies a list of build configurations fo' which tha install rule applies (Debug, Release, etc.).


Da COMPONENT argument specifies a installation component name wit which tha install rule be associated, like fuckin "runtime" or "development".  Durin component\-specific installation only install rulez associated wit tha given component name is ghon be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Durin a gangbangin' full installation all components is installed. Y'all KNOW dat shit, muthafucka! If COMPONENT aint provided a thugged-out default component "Unspecified" is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default component name may be controlled wit tha CMAKE_INSTALL_DEFAULT_COMPONENT_NAME variable.


Da RENAME argument specifies a name fo' a installed file dat may be different from tha original gangsta file.  Renamin be allowed only when a single file is installed by tha command.


Da OPTIONAL argument specifies dat it aint a error if tha file ta be installed do not exist.  


Da TARGETS signature:


.nf
  install(TARGETS targets... [EXPORT <export\-name>]
          [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
            PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
           [DESTINATION <dir>]
           [INCLUDES DESTINATION [<dir> ...]]
           [PERMISSIONS permissions...]
           [CONFIGURATIONS [Debug|Release|...]]
           [COMPONENT <component>]
           [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
          ] [...])
.fi

Da TARGETS form specifies rulez fo' installin targets from a project.  There is five kindz of target filez dat may be installed: ARCHIVE, LIBRARY, RUNTIME, FRAMEWORK, n' BUNDLE.  Executablez is treated as RUNTIME targets, except dat dem marked wit tha MACOSX_BUNDLE property is treated as BUNDLE targets on OS X. Right back up in yo muthafuckin ass. Static libraries is always treated as ARCHIVE targets, n' you can put dat on yo' toast. Module libraries is always treated as LIBRARY targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as LIBRARY targets, except dat dem marked wit tha FRAMEWORK property is treated as FRAMEWORK targets on OS X.  For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a RUNTIME target n' tha correspondin import library is treated as a ARCHIVE target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms. Da ARCHIVE, LIBRARY, RUNTIME, n' FRAMEWORK arguments chizzle tha type of target ta which tha subsequent propertizzles apply.  If none is given tha installation propertizzles apply ta all target types.  If only one is given then only targetz of dat type is ghon be installed (which can be used ta install just a DLL or just a import library).Da INCLUDES DESTINATION specifies a list of directories which is ghon be added ta tha INTERFACE_INCLUDE_DIRECTORIES of tha <targets> when exported by install(EXPORT).  If a relatizzle path is specified, it is treated as relatizzle ta tha $<INSTALL_PREFIX>.


Da PRIVATE_HEADER, PUBLIC_HEADER, n' RESOURCE arguments cause subsequent propertizzles ta be applied ta installin a FRAMEWORK shared library targetz associated filez on non\-Applez platforms.  Rulez defined by these arguments is ignored on Applez platforms cuz tha associated filez is installed tha fuck into tha appropriate locations inside tha framework folda n' shit.  See documentation of tha PRIVATE_HEADER, PUBLIC_HEADER, n' RESOURCE target propertizzles fo' details.


Either NAMELINK_ONLY or NAMELINK_SKIP may be specified as a LIBRARY option. I aint talkin' bout chicken n' gravy biatch.  On some platforms a versioned shared library has a symbolic link such as


.nf
  lib<name>.so \-> lib<name>.so.1
.fi

where "lib<name>.so.1" is tha soname of tha library n' "lib<name>.so" be a "namelink" allowin linkers ta find tha library when given "\-l<name>".  Da NAMELINK_ONLY option causes installation of only tha namelink when a library target is installed. Y'all KNOW dat shit, muthafucka!  Da NAMELINK_SKIP option causes installation of library filez other than tha namelink when a library target is installed. Y'all KNOW dat shit, muthafucka!  When neither option is given both portions is installed. Y'all KNOW dat shit, muthafucka!  On platforms where versioned shared libraries aint gots namelinks or when a library aint versioned tha NAMELINK_SKIP option installs tha library n' tha NAMELINK_ONLY option installs nothing.  See tha VERSION n' SOVERSION target propertizzles fo' details on bustin versioned shared libraries.


One or mo' crewz of propertizzles may be specified up in a single call ta tha TARGETS form of dis command. Y'all KNOW dat shit, muthafucka!  A target may be installed mo' than once ta different locations.  Consider hypothetical targets "myExe", "mySharedLib", n' "myStaticLib".  Da code


.nf
    install(TARGETS myExe mySharedLib myStaticLib
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib/static)
    install(TARGETS mySharedLib DESTINATION /some/full/path)
.fi

will install myExe ta <prefix>/bin n' myStaticLib ta <prefix>/lib/static.  On non\-DLL platforms mySharedLib is ghon be installed ta <prefix>/lib n' /some/full/path.  On DLL platforms tha mySharedLib DLL is ghon be installed ta <prefix>/bin n' /some/full/path n' its import library is ghon be installed ta <prefix>/lib/static n' /some/full/path.


Da EXPORT option associates tha installed target filez wit a export called <export\-name>.  It must step tha fuck up before any RUNTIME, LIBRARY, or ARCHIVE options.  To straight-up install tha export file itself, call install(EXPORT).  See documentation of tha install(EXPORT ...) signature below fo' details.


Installin a target wit EXCLUDE_FROM_ALL set ta legit has undefined behavior.


Da FILES signature:


.nf
  install(FILES files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])
.fi

Da FILES form specifies rulez fo' installin filez fo' a project.  File names given as relatizzle paths is interpreted wit respect ta tha current source directory.  Filez installed by dis form is by default given permissions OWNER_WRITE, OWNER_READ, GROUP_READ, n' WORLD_READ if no PERMISSIONS argument is given.


Da PROGRAMS signature:


.nf
  install(PROGRAMS files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])
.fi

Da PROGRAMS form is identical ta tha FILES form except dat tha default permissions fo' tha installed file also include OWNER_EXECUTE, GROUP_EXECUTE, n' WORLD_EXECUTE.  This form is intended ta install programs dat is not targets, like fuckin shell scripts, n' you can put dat on yo' toast.  Use tha TARGETS form ta install targets built within tha project.


Da DIRECTORY signature:


.nf
  install(DIRECTORY dirs... DESTINATION <dir>
          [FILE_PERMISSIONS permissions...]
          [DIRECTORY_PERMISSIONS permissions...]
          [USE_SOURCE_PERMISSIONS] [OPTIONAL]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>] [FILES_MATCHING]
          [[PATTERN <pattern> | REGEX <regex>]
           [EXCLUDE] [PERMISSIONS permissions...]] [...])
.fi

Da DIRECTORY form installs contentz of one or mo' directories ta a given destination. I aint talkin' bout chicken n' gravy biatch.  Da directory structure is copied verbatim ta tha destination. I aint talkin' bout chicken n' gravy biatch.  Da last component of each directory name be appended ta tha destination directory but a trailin slash may be used ta avoid dis cuz it leaves tha last component empty.  Directory names given as relatizzle paths is interpreted wit respect ta tha current source directory.  If no input directory names is given tha destination directory is ghon be pimped but not a god damn thang is ghon be installed tha fuck into dat shit.  Da FILE_PERMISSIONS n' DIRECTORY_PERMISSIONS options specify permissions given ta filez n' directories up in tha destination. I aint talkin' bout chicken n' gravy biatch.  If USE_SOURCE_PERMISSIONS is specified n' FILE_PERMISSIONS is not, file permissions is ghon be copied from tha source directory structure.  If no permissions is specified filez is ghon be given tha default permissions specified up in tha FILES form of tha command, n' tha directories is ghon be given tha default permissions specified up in tha PROGRAMS form of tha command.


Installation of directories may be controlled wit fine granularitizzle rockin tha PATTERN or REGEX options.  These "match" options specify a globbin pattern or regular expression ta match directories or filez encountered within input directories. Put ya muthafuckin choppers up if ya feel dis!  They may be used ta apply certain options (see below) ta a subset of tha filez n' directories encountered. Y'all KNOW dat shit, muthafucka!  Da full path ta each input file or directory (with forward slashes) is matched against tha expression. I aint talkin' bout chicken n' gravy biatch.  A PATTERN will match only complete file names: tha portion of tha full path matchin tha pattern must occur all up in tha end of tha file name n' be preceded by a slash.  A REGEX will match any portion of tha full path but it may use '/' n' '$' ta simulate tha PATTERN behavior. Shiiit, dis aint no joke.  By default all filez n' directories is installed whether or not they is matched. Y'all KNOW dat shit, muthafucka!  Da FILES_MATCHING option may be given before tha straight-up original gangsta match option ta disable installation of filez (but not directories) not matched by any expression. I aint talkin' bout chicken n' gravy biatch.  For example, tha code


.nf
  install(DIRECTORY src/ DESTINATION include/myproj
          FILES_MATCHING PATTERN "*.h")
.fi

will extract n' install header filez from a source tree.


Some options may follow a PATTERN or REGEX expression n' is applied only ta filez or directories matchin em.  Da EXCLUDE option will skip tha matched file or directory.  Da PERMISSIONS option overrides tha permissions settin fo' tha matched file or directory.  For example tha code


.nf
  install(DIRECTORY icons scripts/ DESTINATION share/myproj
          PATTERN "CVS" EXCLUDE
          PATTERN "scripts/*"
          PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                      GROUP_EXECUTE GROUP_READ)
.fi

will install tha icons directory ta share/myproj/icons n' tha scripts directory ta share/myproj.  Da icons will git default file permissions, tha scripts is ghon be given specific permissions, n' any CVS directories is ghon be excluded.


Da SCRIPT n' CODE signature:


.nf
  install([[SCRIPT <file>] [CODE <code>]] [...])
.fi

Da SCRIPT form will invoke tha given CMake script filez durin installation. I aint talkin' bout chicken n' gravy biatch.  If tha script file name be a relatizzle path it is ghon be interpreted wit respect ta tha current source directory.  Da CODE form will invoke tha given CMake code durin installation. I aint talkin' bout chicken n' gravy biatch.  Code is specified as a single argument inside a thugged-out double\-quoted string. For example, tha code


.nf
  install(CODE "MESSAGE(\\"Sample install message.\\")")
.fi

will print a message durin installation.


Da EXPORT signature:


.nf
  install(EXPORT <export\-name> DESTINATION <dir>
          [NAMESPACE <namespace>] [FILE <name>.cmake]
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [EXPORT_LINK_INTERFACE_LIBRARIES]
          [COMPONENT <component>])
.fi

Da EXPORT form generates n' installs a CMake file containin code ta import targets from tha installation tree tha fuck into another project.  Target installations is associated wit tha export <export\-name> rockin tha EXPORT option of tha install(TARGETS ...) signature documented above.  Da NAMESPACE option will prepend <namespace> ta tha target names as they is freestyled ta tha import file.  By default tha generated file is ghon be called <export\-name>.cmake but tha FILE option may be used ta specify a gangbangin' finger-lickin' different name.  Da value given ta tha FILE option must be a gangbangin' file name wit tha ".cmake" extension. I aint talkin' bout chicken n' gravy biatch.  If a CONFIGURATIONS option is given then tha file will only be installed when one of tha named configurations is installed. Y'all KNOW dat shit, muthafucka!  Additionally, tha generated import file will reference only tha matchin target configurations.  Da EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes tha contentz of tha propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>), biatch? ta be exported, when policy CMP0022 is NEW.  If a COMPONENT option is specified dat do not match dat given ta tha targets associated wit <export\-name> tha behavior is undefined. Y'all KNOW dat shit, muthafucka!  If a library target is included up in tha export but a target ta which it links aint included tha behavior is unspecified.


Da EXPORT form is useful ta help outside projects use targets built n' installed by tha current project.  For example, tha code


.nf
  install(TARGETS myexe EXPORT myproj DESTINATION bin)
  install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
.fi

will install tha executable myexe ta <prefix>/bin n' code ta import it up in tha file "<prefix>/lib/myproj/myproj.cmake".  An outside project may load dis file wit tha include command n' reference tha myexe executable from tha installation tree rockin tha imported target name mp_myexe as if tha target was built up in its own tree.


NOTE: This command supercedes tha INSTALL_TARGETS command n' tha target propertizzles PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT.  It also replaces tha FILES formz of tha INSTALL_FILES n' INSTALL_PROGRAMS commands.  Da processin order of these install rulez relatizzle ta dem generated by INSTALL_TARGETS, INSTALL_FILES, n' INSTALL_PROGRAMS commandz aint defined.


.TP
.B link_directories
Specify directories up in which tha linker will look fo' libraries.

.nf
  link_directories(directory1 directory2 ...)
.fi

Specify tha paths up in which tha linker should search fo' libraries. Put ya muthafuckin choppers up if ya feel dis! Da command will apply only ta targets pimped afta it is called. Y'all KNOW dat shit, muthafucka! Relatizzle paths given ta dis command is interpreted as relatizzle ta tha current source directory, peep CMP0015. 


Note dat dis command is rarely necessary.  Library locations returned by find_package() n' find_library() is absolute paths.  Pass these absolute library file paths directly ta tha target_link_libraries() command. Y'all KNOW dat shit, muthafucka!  CMake will ensure tha linker findz em.

.TP
.B list
List operations.

.nf
  list(LENGTH <list> <output variable>)
  list(GET <list> <element index> [<element index> ...]
       <output variable>)
  list(APPEND <list> <element> [<element> ...])
  list(FIND <list> <value> <output variable>)
  list(INSERT <list> <element_index> <element> [<element> ...])
  list(REMOVE_ITEM <list> <value> [<value> ...])
  list(REMOVE_AT <list> <index> [<index> ...])
  list(REMOVE_DUPLICATES <list>)
  list(REVERSE <list>)
  list(SORT <list>)
.fi

LENGTH will return a given listz length.


GET will return list of elements specified by indices from tha list.


APPEND will append elements ta tha list.


FIND will return tha index of tha element specified up in tha list or \-1 if it wasn't found.


INSERT will bang elements ta tha list ta tha specified location.


REMOVE_AT n' REMOVE_ITEM will remove shit from tha list. Da difference is dat REMOVE_ITEM will remove tha given items, while REMOVE_AT will remove tha shit all up in tha given indices.


REMOVE_DUPLICATES will remove duplicated shit up in tha list.


REVERSE reverses tha contentz of tha list in\-place.


SORT sorts tha list in\-place alphabetically.


Da list subcommandz APPEND, INSERT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE n' SORT may create freshly smoked up joints fo' tha list within tha current CMake variable scope. Right back up in yo muthafuckin ass. Similar ta tha SET command, tha LIST command creates freshly smoked up variable joints up in tha current scope, even if tha list itself is straight-up defined up in a parent scope. To propagate tha thangs up in dis biatch of these operations upwards, use SET wit PARENT_SCOPE, SET wit CACHE INTERNAL, or some other meanz of value propagation.


NOTES: A list up in cmake be a ; separated crew of strings. To create a list tha set command can be used. Y'all KNOW dat shit, muthafucka! For example, set(var a funky-ass b c d e)  creates a list wit a;b;c;d;e, n' set(var "a b c d e") creates a strang or a list wit one item up in dat shit.


When specifyin index joints, if <element index> is 0 or pimped outer, it is indexed from tha beginnin of tha list, wit 0 representin tha straight-up original gangsta list element. If <element index> is \-1 or lesser, it is indexed from tha end of tha list, wit \-1 representin tha last list element. Be careful when countin wit wack indices: they do not start from 0. \-0 is equivalent ta 0, tha straight-up original gangsta list element.


.TP
.B load_cache
Load up in tha joints from another projectz CMake cache.

.nf
  load_cache(pathToCacheFile READ_WITH_PREFIX
             prefix entry1...)
.fi

Read tha cache n' store tha axed entries up in variablez wit they name prefixed wit tha given prefix.  This only readz tha joints, n' do not create entries up in tha local projectz cache.


.nf
  load_cache(pathToCacheFile [EXCLUDE entry1...]
             [INCLUDE_INTERNALS entry1...])
.fi

Load up in tha joints from another cache n' store dem up in tha local projectz cache as internal entries. Put ya muthafuckin choppers up if ya feel dis!  This is useful fo' a project dat dependz on another project built up in a gangbangin' finger-lickin' different tree.  EXCLUDE option can be used ta provide a list of entries ta be excluded. Y'all KNOW dat shit, muthafucka!  INCLUDE_INTERNALS can be used ta provide a list of internal entries ta be included. Y'all KNOW dat shit, muthafucka!  Normally, no internal entries is brought in. I aint talkin' bout chicken n' gravy biatch.  Use of dis form of tha command is straight fuckin discouraged yo, but it is provided fo' backward compatibility.

.TP
.B load_command
Load a cold-ass lil command tha fuck into a hustlin CMake.

.nf
  load_command(COMMAND_NAME <loc1> [loc2 ...])
.fi

Da given locations is searched fo' a library whose name is cmCOMMAND_NAME.  If found, it is loaded as a module n' tha command be added ta tha set of available CMake commands.  Usually, TRY_COMPILE is used before dis command ta compile tha module. If tha command is successfully loaded a variable named


.nf
  CMAKE_LOADED_COMMAND_<COMMAND_NAME>
.fi

will be set ta tha full path of tha module dat was loaded. Y'all KNOW dat shit, muthafucka!  Otherwise tha variable aint gonna be set.

.TP
.B macro
Start recordin a macro fo' lata invocation as a cold-ass lil command.

.nf
  macro(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endmacro(<name>)
.fi

Define a macro named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta macro yo, but before tha matchin endmacro, is not invoked until tha macro is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha macro is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha joints ${ARGC} which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ${ARGV0} ${ARGV1} ${ARGV2} ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin macros wit optionizzle arguments fo' realz. Additionally ${ARGV} holdz tha list of all arguments given ta tha macro n' ${ARGN} holdz tha list of arguments past tha last expected argument. Note dat tha parametas ta a macro n' joints like fuckin ARGN is not variablez up in tha usual CMake sense. They is strang replacements much like tha C preprocessor would do wit a macro. If you want legit CMake variablez and/or betta CMake scope control you should peep tha function command.


See tha cmake_policy() command documentation fo' tha behavior of policies inside macros.

.TP
.B mark_as_advanced
Mark cmake cached variablez as advanced.

.nf
  mark_as_advanced([CLEAR|FORCE] VAR VAR2 VAR...)
.fi

Mark tha named cached variablez as advanced. Y'all KNOW dat shit, muthafucka!  An advanced variable aint gonna be displayed up in any of tha cmake GUIs unless tha show advanced option is on. I aint talkin' bout chicken n' gravy biatch.  If CLEAR is tha straight-up original gangsta argument advanced variablez is chizzled back ta unadvanced. Y'all KNOW dat shit, muthafucka!  If FORCE is tha straight-up original gangsta argument, then tha variable is made advanced. Y'all KNOW dat shit, muthafucka!  If neither FORCE nor CLEAR is specified, freshly smoked up joints is ghon be marked as advanced yo, but if tha variable already has a advanced/non\-advanced state, it aint gonna be chizzled.


It do not a god damn thang up in script mode.

.TP
.B math
Mathematical expressions.

.nf
  math(EXPR <output variable> <math expression>)
.fi

EXPR evaluates mathematical expression n' returns result up in tha output variable. Example mathematical expression is '5 * ( 10 + 13 )'.  Supported operators is + \- * / % | & ^ ~ << >> * / %.  They have tha same meanin  as they do up in C code.

.TP
.B message
Display a message ta tha user.

.nf
  message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
          "message ta display" ...)
.fi

Da optionizzle keyword determines tha type of message:


.nf
  (none)         = Important shiznit
  STATUS         = Incidental shiznit
  WARNING        = CMake Warning, continue processing
  AUTHOR_WARNING = CMake Warnin (dev), continue processing
  SEND_ERROR     = CMake Error, continue processing,
                                but skip generation
  FATAL_ERROR    = CMake Error, stop processin n' generation
.fi

Da CMake command\-line tool displays STATUS lyrics on stdout n' all other message types on stderr. Shiiit, dis aint no joke.  Da CMake GUI displays all lyrics up in its log area.  Da interactizzle dialogs (ccmake n' CMakeSetup) show STATUS lyrics one at a time on a status line n' other lyrics up in interactizzle pop\-up boxes.


CMake Warnin n' Error message text displays rockin a simple markup language.  Non\-indented text is formatted up in line\-wrapped paragraphs delimited by newlines.  Indented text is considered pre\-formatted.

.TP
.B option
Provides a option dat tha user can optionally select.

.nf
  option(<option_variable> "help strang describin option"
         [initial value])
.fi

Provide a option fo' tha user ta select as ON or OFF.  If no initial value is provided, OFF is used.


If you have options dat depend on tha jointz of other options, peep tha module help fo' CMakeDependentOption.

.TP
.B project
Set a name fo' tha entire project.

.nf
  project(<projectname> [languageName1 languageName2 ... ] )
.fi

Sets tha name of tha project.  Additionally dis sets tha variablez <projectName>_BINARY_DIR n' <projectName>_SOURCE_DIR ta tha respectizzle joints.


Optionally you can specify which languages yo' project supports, n' you can put dat on yo' toast.  Example languages is CXX (i.e. C++), C, Fortran, etc. By default C n' CXX is enabled. Y'all KNOW dat shit, muthafucka!  E.g. if you aint gots a C++ compiler, you can disable tha check fo' it by explicitly listin tha languages you wanna support, e.g. C.  By rockin tha special language "NONE" all checks fo' any language can be disabled. Y'all KNOW dat shit, muthafucka! If a variable exists called CMAKE_PROJECT_<projectName>_INCLUDE, tha file pointed ta by dat variable is ghon be included as tha last step of tha project command.


Da top\-level CMakeLists.txt file fo' a project must contain a literal, direct call ta tha project() command; loadin one all up in tha include() command aint sufficient.  If no such call exists CMake will implicitly add one ta tha top dat enablez tha default languages (C n' CXX).

.TP
.B qt_wrap_cpp
Smoke Qt Wrappers.

.nf
  qt_wrap_cpp(resultingLibraryName DestName
              SourceLists ...)
.fi

Produce moc filez fo' all tha .h filez listed up in tha SourceLists, n' you can put dat on yo' toast.  Da moc filez is ghon be added ta tha library rockin tha DestName source list.

.TP
.B qt_wrap_ui
Smoke Qt user intercourses Wrappers.

.nf
  qt_wrap_ui(resultingLibraryName HeadersDestName
             SourcesDestName SourceLists ...)
.fi

Produce .h n' .cxx filez fo' all tha .ui filez listed up in tha SourceLists, n' you can put dat on yo' toast.  Da .h filez is ghon be added ta tha library rockin tha HeadersDestNamesource list.  Da .cxx filez is ghon be added ta tha library rockin tha SourcesDestNamesource list.

.TP
.B remove_definitions
Removes \-D define flags added by add_definitions.

.nf
  remove_definitions(\-DFOO \-DBAR ...)
.fi

Removes flags (added by add_definitions) from tha compila command line fo' sources up in tha current directory n' below.

.TP
.B return
Return from a gangbangin' file, directory or function.

.nf
  return()
.fi

Returns from a gangbangin' file, directory or function. I aint talkin' bout chicken n' gravy biatch. When dis command is encountered up in a included file (via include() or find_package()), it causes processin of tha current file ta stop n' control is moonwalked back ta tha includin file. If it is encountered up in a gangbangin' file which aint included by another file, e.g. a CMakeLists.txt, control is moonwalked back ta tha parent directory if there is one. If return is called up in a gangbangin' function, control is moonwalked back ta tha calla of tha function. I aint talkin' bout chicken n' gravy biatch. Note dat a macro aint a gangbangin' function n' do not handle return like a gangbangin' function do.

.TP
.B separate_arguments
Parse space\-separated arguments tha fuck into a semicolon\-separated list.

.nf
  separate_arguments(<var> <UNIX|WINDOWS>_COMMAND "<args>")
.fi

Parses a unix\- or windows\-style command\-line strang "<args>" n' stores a semicolon\-separated list of tha arguments up in <var>.  Da entire command line must be given up in one "<args>" argument.


Da UNIX_COMMAND mode separates arguments by unquoted whitespace.  It recognizes both single\-quote n' double\-quote pairs.  A backslash escapes tha next literal characta (\\" is "); there be no special escapes (\\n is just n).


Da WINDOWS_COMMAND mode parses a windows command\-line rockin tha same syntax tha runtime library uses ta construct argv at startup.  It separates arguments by whitespace dat aint double\-quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Backslashes is literal unless they precede double\-quotes.  See tha MSDN article "Parsin C Command\-Line Arguments" fo' details.


.nf
  separate_arguments(VARIABLE)
.fi

Convert tha value of VARIABLE ta a semi\-colon separated list.  All spaces is replaced wit ';'.  This helps wit generatin command lines.

.TP
.B set
Set a CMake, cache or environment variable ta a given value.

.nf
  set(<variable> <value>
      [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
.fi

Within CMake sets <variable> ta tha value <value>.  <value> is expanded before <variable> is set ta dat shit.  Normally, set will set a regular CMake variable. If CACHE is present, then tha <variable> is put up in tha cache instead, unless it be already up in tha cache. Right back up in yo muthafuckin ass. See section 'Variable types up in CMake' below fo' detailz of regular n' cache variablez n' they interactions. If CACHE is used, <type> n' <docstring> is required. Y'all KNOW dat shit, muthafucka! <type> is used by tha CMake GUI ta chizzle a widget wit which tha user sets a value. Da value fo' <type> may be one of


.nf
  FILEPATH = File chizzla dialog.
  PATH     = Directory chizzla dialog.
  STRING   = Arbitrary string.
  BOOL     = Boolean ON/OFF checkbox.
  INTERNAL = No GUI entry (used fo' persistent variables).
.fi

If <type> is INTERNAL, tha cache variable is marked as internal, n' aint gonna be shown ta tha user up in tools like cmake\-gui. This is intended fo' joints dat should be persisted up in tha cache yo, but which playas should not normally chizzle. INTERNAL implies FORCE.


Normally, set(...CACHE...) creates cache variablez yo, but do not modify em. If FORCE is specified, tha value of tha cache variable is set, even if tha variable be already up in tha cache. This should normally be avoided, as it will remove any chizzlez ta tha cache variablez value by tha user.


If PARENT_SCOPE is present, tha variable is ghon be set up in tha scope above tha current scope. Each freshly smoked up directory or function creates a freshly smoked up scope. This command will set tha value of a variable tha fuck into tha parent directory or callin function (whichever be applicable ta tha case at hand). PARENT_SCOPE cannot be combined wit CACHE.


If <value> aint specified then tha variable is removed instead of set.  See also: tha unset() command.


.nf
  set(<variable> <value1> ... <valueN>)
.fi

In dis case <variable> is set ta a semicolon separated list of joints.


<variable> can be a environment variable such as:


.nf
  set( ENV{PATH} /home/martink )
.fi

in which case tha environment variable is ghon be set.


*** Variable types up in CMake ***


In CMake there be two typez of variables: aiiight variablez n' cache variables. Normal variablez is meant fo' tha internal use of tha script (just like variablez up in most programmin languages); they is not persisted across CMake runs. Cache variablez (unless set wit INTERNAL) is mostly intended fo' configuration settings where tha straight-up original gangsta CMake run determines a suitable default value, which tha user can then override, by editin tha cache wit tools like fuckin ccmake or cmake\-gui. Cache variablez is stored up in tha CMake cache file, n' is persisted across CMake runs. 


Both types can exist all up in tha same time wit tha same name but different joints, n' you can put dat on yo' toast. When ${FOO} is evaluated, CMake first looks fo' a aiiight variable 'FOO' up in scope n' uses it if set. If n' only if no aiiight variable exists then it falls back ta tha cache variable 'FOO'.


Some examples:


Da code 'set(FOO "x")' sets tha aiiight variable 'FOO'. Well shiiiit, it do not bust a nut on tha cache yo, but it will hide any existin cache value 'FOO'.


Da code 'set(FOO "x" CACHE ...)' checks fo' 'FOO' up in tha cache, ignorin any aiiight variable of tha same name. If 'FOO' is up in tha cache then not a god damn thang happens ta either tha aiiight variable or tha cache variable. If 'FOO' aint up in tha cache, then it be added ta tha cache.


Finally, whenever a cold-ass lil cache variable be added or modified by a cold-ass lil command, CMake also *removes* tha aiiight variable of tha same name from tha current scope so dat a immediately followin evaluation of it will expose tha newly cached value.


Normally projects should avoid rockin aiiight n' cache variablez of tha same name, as dis interaction can be hard ta follow. But fuck dat shiznit yo, tha word on tha street is dat up in some thangs it can be useful naaahhmean, biatch? One example (used by some projects):


A project has a subproject up in its source tree. Da lil pimp project has its own CMakeLists.txt, which is included from tha parent CMakeLists.txt rockin add_subdirectory(). Now, if tha parent n' tha lil pimp project provide tha same option (for example a cold-ass lil compila option), tha parent gets tha straight-up original gangsta chizzle ta add a user\-editable option ta tha cache. Normally, tha lil pimp would then use tha same value dat tha parent uses. But fuck dat shiznit yo, tha word on tha street is dat it may be necessary ta hard\-code tha value fo' tha lil pimp projectz option while still allowin tha user ta edit tha value used by tha parent project. Da parent project can bust dis simply by settin a aiiight variable wit tha same name as tha option up in a scope sufficient ta hide tha optionz cache variable from tha lil pimp straight-up. Da parent has already set tha cache variable,  so tha childz set(...CACHE...) will do nothing, n' evaluatin tha option variable will use tha value from tha aiiight variable, which hides tha cache variable.

.TP
.B set_directory_properties
Set a property of tha directory.

.nf
  set_directory_properties(PROPERTIES prop1 value1 prop2 value2)
.fi

Set a property fo' tha current directory n' subdirectories. Put ya muthafuckin choppers up if ya feel dis! If tha property aint found, CMake will report a error. Shiiit, dis aint no joke. Da propertizzles include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, n' ADDITIONAL_MAKE_CLEAN_FILES fo' realz. ADDITIONAL_MAKE_CLEAN_FILES be a list of filez dat is ghon be cleaned as a part of "make clean" stage.

.TP
.B set_property
Set a named property up in a given scope.

.nf
  set_property(<GLOBAL                            |
                DIRECTORY [dir]                   |
                TARGET    [target1 [target2 ...]] |
                SOURCE    [src1 [src2 ...]]       |
                TEST      [test1 [test2 ...]]     |
                CACHE     [entry1 [entry2 ...]]>
               [APPEND] [APPEND_STRING]
               PROPERTY <name> [value1 [value2 ...]])
.fi

Set one property on zero or mo' objectz of a scope.  Da first argument determines tha scope up in which tha property is set.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope may name zero or mo' existin targets.


SOURCE scope may name zero or mo' source files.  Note dat source file propertizzles is visible only ta targets added up in tha same directory (CMakeLists.txt).


TEST scope may name zero or mo' existin tests.


CACHE scope must name zero or mo' cache existin entries.


Da required PROPERTY option is immediately followed by tha name of tha property ta set.  Remainin arguments is used ta compose tha property value up in tha form of a semicolon\-separated list.  If tha APPEND option is given tha list be appended ta any existin property value.If tha APPEND_STRING option is given tha strang be append ta any existin property value as string, i.e. it thangs up in dis biatch up in a longer strang n' not a list of strings.

.TP
.B set_source_files_properties
Source filez can have propertizzles dat affect how tha fuck they is built.

.nf
  set_source_files_properties([file1 [file2 [...]]]
                              PROPERTIES prop1 value1
                              [prop2 value2 [...]])
.fi

Set propertizzles associated wit source filez rockin a key/value paired list.  See propertizzles documentation fo' dem known ta CMake.  Unrecognized propertizzles is ignored. Y'all KNOW dat shit, muthafucka!  Source file propertizzles is visible only ta targets added up in tha same directory (CMakeLists.txt).

.TP
.B set_target_properties
Targets can have propertizzles dat affect how tha fuck they is built.

.nf
  set_target_properties(target1 target2 ...
                        PROPERTIES prop1 value1
                        prop2 value2 ...)
.fi

Set propertizzles on a target. Da syntax fo' tha command is ta list all tha filez you wanna chizzle, n' then provide tha joints you wanna set next.  Yo ass can use any prop value pair you want n' extract it lata wit tha GET_TARGET_PROPERTY command.


Propertizzles dat affect tha name of a targetz output file is as bigs up.  Da PREFIX n' SUFFIX propertizzles override tha default target name prefix (like fuckin "lib") n' suffix (like fuckin ".so"). IMPORT_PREFIX n' IMPORT_SUFFIX is tha equivalent propertizzles fo' tha import library correspondin ta a DLL (for SHARED library targets).  OUTPUT_NAME sets tha real name of a target when it is built n' can be used ta help create two targetz of tha same name even though CMake requires unique logical target names.  There be also a <CONFIG>_OUTPUT_NAME dat can set tha output name on a per\-configuration basis.  <CONFIG>_POSTFIX sets a postfix fo' tha real name of tha target when it is built under tha configuration named by <CONFIG> (in upper\-case, like fuckin "DEBUG_POSTFIX").  Da value of dis property is initialized when tha target is pimped ta tha value of tha variable CMAKE_<CONFIG>_POSTFIX (except fo' executable targets cuz earlier CMake versions which did not use dis variable fo' executables).


Da LINK_FLAGS property can be used ta add extra flags ta tha link step of a target. LINK_FLAGS_<CONFIG> will add ta tha configuration <CONFIG>, fo' example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. DEFINE_SYMBOL sets tha name of tha preprocessor symbol defined when compilin sources up in a gangbangin' finger-lickin' dirty-ass shared library. If not set here then it is set ta target_EXPORTS by default (with some substitutions if tha target aint a valid C identifier). This is useful fo' headaz ta know whether they is bein included from inside they library or outside ta properly setup dllexport/dllimport decorations. Da COMPILE_FLAGS property sets additionizzle compila flags used ta build sources within tha target.  It may also be used ta pass additionizzle preprocessor definitions.


Da LINKER_LANGUAGE property is used ta chizzle tha tool used ta link a executable or shared library. Da default is set tha language ta match tha filez up in tha library. CXX n' C is common joints fo' dis property.


For shared libraries VERSION n' SOVERSION can be used ta specify tha build version n' API version respectively. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks n' tha linker supports so\-names. If only one of both is specified tha missin be assumed ta have tha same version number n' shit. For executablez VERSION can be used ta specify tha build version. I aint talkin' bout chicken n' gravy biatch. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks. For shared libraries n' executablez on Windows tha VERSION attribute is parsed ta extract a "major.minor" version number n' shit. These numbers is used as tha image version of tha binary. 


There is all dem propertizzles used ta specify RPATH rules. INSTALL_RPATH be a semicolon\-separated list specifyin tha rpath ta use up in installed targets (for platforms dat support it). INSTALL_RPATH_USE_LINK_PATH be a funky-ass boolean dat if set ta legit will append directories up in tha linker search path n' outside tha project ta tha INSTALL_RPATH. Right back up in yo muthafuckin ass. SKIP_BUILD_RPATH be a funky-ass boolean specifyin whether ta skip automatic generation of a rpath allowin tha target ta run from tha build tree. BUILD_WITH_INSTALL_RPATH be a funky-ass boolean specifyin whether ta link tha target up in tha build tree wit tha INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH n' avoidz tha need fo' relinkin before installation. I aint talkin' bout chicken n' gravy biatch.  INSTALL_NAME_DIR be a strang specifyin tha directory portion of tha "install_name" field of shared libraries on Mac OSX ta use up in tha installed targets, n' you can put dat on yo' toast. When tha target is pimped tha jointz of tha variablez CMAKE_INSTALL_RPATH, CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH, CMAKE_BUILD_WITH_INSTALL_RPATH, n' CMAKE_INSTALL_NAME_DIR is used ta initialize these properties.


PROJECT_LABEL can be used ta chizzle tha name of tha target up in a IDE like visual studio.  VS_KEYWORD can be set ta chizzle tha visual basement keyword, fo' example Qt integration works betta if dis is set ta Qt4VSv1.0.


VS_SCC_PROJECTNAME, VS_SCC_LOCALPATH, VS_SCC_PROVIDER n' VS_SCC_AUXPATH can be set ta add support fo' source control bindings up in a  Visual Studio project file.


VS_GLOBAL_<variable> can be set ta add a Visual Studio project\-specific global variable. Qt integration works betta if VS_GLOBAL_QtVersion is set ta tha Qt version FindQt4.cmake found. Y'all KNOW dat shit, muthafucka! For example, "4.7.3"


Da PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT propertizzles is tha oldschool way ta specify CMake scripts ta run before n' afta installin a target.  They is used only when tha oldschool INSTALL_TARGETS command is used ta install tha target.  Use tha INSTALL command instead.


Da EXCLUDE_FROM_DEFAULT_BUILD property is used by tha visual basement generators.  If it is set ta 1 tha target aint gonna be part of tha default build when you select "Build Solution". This can also be set on a per\-configuration basis rockin EXCLUDE_FROM_DEFAULT_BUILD_<CONFIG>.

.TP
.B set_tests_properties
Set a property of tha tests.

.nf
  set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)
.fi

Set a property fo' tha tests, n' you can put dat on yo' toast. If tha property aint found, CMake will report a error. Shiiit, dis aint no joke. Da propertizzles include:


WILL_FAIL: If set ta true, dis will invert tha pass/fail flag of tha test.


PASS_REGULAR_EXPRESSION: If set, tha test output is ghon be checked against tha specified regular expressions n' at least one of tha regular expressions has ta match, otherwise tha test will fail.


.nf
  Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"
.fi

FAIL_REGULAR_EXPRESSION: If set, if tha output will match ta one of specified regular expressions, tha test will fail.


.nf
  Example: PASS_REGULAR_EXPRESSION "[^a\-z]Error;ERROR;Failed"
.fi

Both PASS_REGULAR_EXPRESSION n' FAIL_REGULAR_EXPRESSION expect a list of regular expressions.


TIMEOUT: Settin dis will limit tha test runtime ta tha number of secondz specified.


.TP
.B crib_name
Set tha given variable ta tha name of tha computer.

.nf
  crib_name(variable)
.fi

.TP
.B source_group
Define a groupin fo' sources up in tha makefile.

.nf
  source_group(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])
.fi

Defines a crew tha fuck into which sources is ghon be placed up in project files.  This is mainly used ta setup file tabs up in Visual Studio.  Any file whose name is listed or matches tha regular expression is ghon be placed up in dis group.  If a gangbangin' file matches multiple groups, tha LAST crew dat explicitly lists tha file is ghon be favored, if any.  If no crew explicitly lists tha file, tha LAST crew whose regular expression matches tha file is ghon be favored.


Da name of tha crew may contain backslashes ta specify subgroups:


.nf
  source_group(outer\\\\inner ...)
.fi

For backwardz compatibility, dis command also supports tha format:


.nf
  source_group(name regex)
.fi

.TP
.B string
Strin operations.

.nf
  string(REGEX MATCH <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX MATCHALL <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX REPLACE <regular_expression>
         <replace_expression> <output variable>
         <input> [<input>...])
  string(REPLACE <match_string>
         <replace_string> <output variable>
         <input> [<input>...])
  string(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512>
         <output variable> <input>)
  string(COMPARE EQUAL <string1> <string2> <output variable>)
  string(COMPARE NOTEQUAL <string1> <string2> <output variable>)
  string(COMPARE LESS <string1> <string2> <output variable>)
  string(COMPARE GREATER <string1> <string2> <output variable>)
  string(ASCII <number> [<number> ...] <output variable>)
  string(CONFIGURE <string1> <output variable>
         [@ONLY] [ESCAPE_QUOTES])
  string(TOUPPER <string1> <output variable>)
  string(TOLOWER <string1> <output variable>)
  string(LENGTH <string> <output variable>)
  string(SUBSTRING <string> <begin> <length> <output variable>)
  string(STRIP <string> <output variable>)
  string(RANDOM [LENGTH <length>] [ALPHABET <alphabet>]
         [RANDOM_SEED <seed>] <output variable>)
  string(FIND <string> <substring> <output variable> [REVERSE])
  string(TIMESTAMP <output variable> [<format string>] [UTC])
  string(MAKE_C_IDENTIFIER <input string> <output variable>)
.fi

REGEX MATCH will match tha regular expression once n' store tha match up in tha output variable.


REGEX MATCHALL will match tha regular expression as nuff times as possible n' store tha matches up in tha output variable as a list.


REGEX REPLACE will match tha regular expression as nuff times as possible n' substitute tha replacement expression fo' tha match up in tha output.  Da replace expression may refer ta paren\-delimited subexpressionz of tha match rockin \\1, \\2, ..., \\9.  Note dat two backslashes (\\\\1) is required up in CMake code ta git a funky-ass backslash all up in argument parsing.


REPLACE will replace all occurrencez of match_strin up in tha input wit replace_strin n' store tha result up in tha output.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha input string.


COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare tha strings n' store legit or false up in tha output variable.


ASCII'ma convert all numbers tha fuck into correspondin ASCII characters.


CONFIGURE will transform a strang like CONFIGURE_FILE transforms a gangbangin' file.


TOUPPER/TOLOWER will convert strang ta upper/lower characters.


LENGTH will return a given stringz length.


SUBSTRING will return a substrin of a given string. If length is \-1 tha remainder of tha strang startin at begin is ghon be returned.


STRIP will return a substrin of a given strang wit leadin n' trailin spaces removed.


RANDOM will return a random strang of given length consistin of charactas from tha given alphabet. Default length is 5 charactas n' default alphabet be all numbers n' upper n' lower case letters.  If a integer RANDOM_SEED is given, its value is ghon be used ta seed tha random number generator.


FIND will return tha posizzle where tha given substrin was found up in tha supplied string. If tha REVERSE flag was used, tha command will search fo' tha posizzle of tha last occurrence of tha specified substring.


Da followin charactas have special meanin up in regular expressions:


.nf
   ^         Matches at beginnin of input
   $         Matches at end of input
   .         Matches any single character
   [ ]       Matches any character(s) inside tha brackets
   [^ ]      Matches any character(s) not inside tha brackets
    \-        Inside brackets, specifies a inclusive range between
             charactas on either side e.g. [a\-f] is [abcdef]
             To match a literal \- rockin brackets, make it tha first
             or tha last characta e.g. [+*/\-] matches basic
             mathematical operators.
   *         Matches precedin pattern zero or mo' times
   +         Matches precedin pattern one or mo' times
   , biatch?         Matches precedin pattern zero or once only
   |         Matches a pattern on either side of tha |
   ()        Saves a matched subexpression, which can be referenced 
             up in tha REGEX REPLACE operation. I aint talkin' bout chicken n' gravy biatch fo' realz. Additionally it is saved
             by all regular expression\-related commands, includin 
             e.g. if( MATCHES ), up in tha variablez CMAKE_MATCH_(0..9).
.fi

*, + n' , biatch? have higher precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. | has lower precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. This means dat tha regular expression "^ab+d$" matches "abbd" but not "ababd", n' tha regular expression "^(ab|cd)$" matches "ab" but not "abd".


TIMESTAMP will write a strang representation of tha current date and/or time ta tha output variable.


Should tha command be unable ta obtain a timestamp tha output variable is ghon be set ta tha empty strang "".


Da optionizzle UTC flag requests tha current date/time representation ta be up in Coordinated Universal Time (UTC) rather than local time.


Da optionizzle <format string> may contain tha followin format specifiers: 


.nf
   %d        Da dizzle of tha current month (01\-31).
   %H        Da minute on a 24\-hour clock (00\-23).
   %I        Da minute on a 12\-hour clock (01\-12).
   %j        Da dizzle of tha current year (001\-366).
   %m        Da month of tha current year (01\-12).
   %M        Da minute of tha current minute (00\-59).
   %S        Da second of tha current minute.
             60 represents a leap second. Y'all KNOW dat shit, muthafucka! (00\-60)
   %U        Da week number of tha current year (00\-53).
   %w        Da dizzle of tha current week. 0 is Sunday. It make me wanna hollar playa! (0\-6)
   %y        Da last two digitz of tha current year (00\-99)
   %Y        Da current year. Shiiit, dis aint no joke. 
.fi

Unknown format specifiers is ghon be ignored n' copied ta tha output as\-is.


If no explicit <format string> is given it will default to:


.nf
   %Y\-%m\-%dT%H:%M:%S    fo' local time.
   %Y\-%m\-%dT%H:%M:%SZ   fo' UTC.
.fi

MAKE_C_IDENTIFIER will write a strang which can be used as a identifier up in C.

.TP
.B target_compile_definitions
Add compile definitions ta a target.

.nf
  target_compile_definitions(<target> <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify compile definitions ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.  Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha COMPILE_DEFINITIONS property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_COMPILE_DEFINITIONS property of <target>.   Da followin arguments specify compile definitions.  Repeated calls fo' tha same <target> append shit up in tha order called.


Arguments ta target_compile_definitions may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_compile_options
Add compile options ta a target.

.nf
  target_compile_options(<target> [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify compile options ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.  If BEFORE is specified, tha content is ghon be prepended ta tha property instead of bein appended.


Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha COMPILE_OPTIONS property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_COMPILE_OPTIONS property of <target>.   Da followin arguments specify compile opitions.  Repeated calls fo' tha same <target> append shit up in tha order called.


Arguments ta target_compile_options may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_include_directories
Add include directories ta a target.

.nf
  target_include_directories(<target> [SYSTEM] [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify include directories or targets ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.


If BEFORE is specified, tha content is ghon be prepended ta tha property instead of bein appended.


Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha INCLUDE_DIRECTORIES property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_INCLUDE_DIRECTORIES property of <target>.   Da followin arguments specify include directories. Put ya muthafuckin choppers up if ya feel dis!  Specified include directories may be absolute paths or relatizzle paths.  Repeated calls fo' tha same <target> append shit up in tha order called.If SYSTEM is specified, tha compila is ghon be holla'd all up in tha directories is meant as system include directories on some platforms (signallin dis settin might big up effects like fuckin tha compila skippin warnings, or these fixed\-install system filez not bein considered up in dependency calculations \- peep compila docs).  If SYSTEM is used together wit PUBLIC or INTERFACE, tha INTERFACE_SYSTEM_INCLUDE_DIRECTORIES target property is ghon be populated wit tha specified directories.


Arguments ta target_include_directories may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_link_libraries
Link a target ta given libraries.

.nf
  target_link_libraries(<target> [item1 [item2 [...]]]
                        [[debug|optimized|general] <item>] ...)
.fi

Specify libraries or flags ta use when linkin a given target.  Da named <target> must done been pimped up in tha current directory by a cold-ass lil command like fuckin add_executable or add_library.  Da remainin arguments specify library names or flags.  Repeated calls fo' tha same <target> append shit up in tha order called.


If a library name matches dat of another target up in tha project a thugged-out dependency will automatically be added up in tha build system ta make shizzle tha library bein linked is up\-to\-date before tha target links.  Item names startin wit '\-' yo, but not '\-l' or '\-framework', is treated as linker flags.


A "debug", "optimized", or "general" keyword indicates dat tha library immediately followin it is ta be used only fo' tha correspondin build configuration. I aint talkin' bout chicken n' gravy biatch.  Da "debug" keyword correspondz ta tha Debug configuration (or ta configurations named up in tha DEBUG_CONFIGURATIONS global property if it is set).  Da "optimized" keyword correspondz ta all other configurations.  Da "general" keyword correspondz ta all configurations, n' is purely optionizzle (assumed if omitted).  Higher granularitizzle may be  bigged up  fo' per\-configuration rulez by bustin n' linkin ta IMPORTED library targets, n' you can put dat on yo' toast.  See tha IMPORTED mode of tha add_library command fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch.  


Library dependencies is transitizzle by default wit dis signature.  When dis target is linked tha fuck into another target then tha libraries linked ta dis target will step tha fuck up on tha link line fo' tha other target like a muthafucka.  This transitizzle "link intercourse" is stored up in tha INTERFACE_LINK_LIBRARIES target property when policy CMP0022 is set ta NEW n' may be overridden by settin tha property directly. (When CMP0022 aint set ta NEW, transitizzle linkin is builtin but may be overridden by tha LINK_INTERFACE_LIBRARIES property.  Calls ta other signaturez of dis command may set tha property makin any libraries linked exclusively by dis signature private.)


CMake will also propagate "usage requirements" from linked library targets, n' you can put dat on yo' toast.  Usage requirements affect compilation of sources up in tha <target>.  They is specified by propertizzles defined on linked targets, n' you can put dat on yo' toast.  Durin generation of tha build system, CMake integrates usage requirement property joints wit tha correspondin build propertizzles fo' <target>:


.nf
 INTERFACE_COMPILE_DEFINITONS: Appendz ta COMPILE_DEFINITONS
 INTERFACE_INCLUDE_DIRECTORIES: Appendz ta INCLUDE_DIRECTORIES
 INTERFACE_POSITION_INDEPENDENT_CODE: Sets POSITION_INDEPENDENT_CODE
   or checked fo' consistency wit existin value
.fi




If a <item> be a library up in a Mac OX framework, tha Headaz directory of tha framework will also be processed as a "usage requirement".  This has tha same ol' dirty effect as passin tha framework directory as a include directory.  target_link_libraries(<target>


.nf
                      <PRIVATE|PUBLIC|INTERFACE> <lib> ...
                      [<PRIVATE|PUBLIC|INTERFACE> <lib> ... ] ...])
.fi

Da PUBLIC, PRIVATE n' INTERFACE keywordz can be used ta specify both tha link dependencies n' tha link intercourse up in one command. Y'all KNOW dat shit, muthafucka!  Libraries n' targets followin PUBLIC is linked to, n' is made part of tha link intercourse.  Libraries n' targets followin PRIVATE is linked ta yo, but is not made part of tha link intercourse.  Libraries followin INTERFACE is appended ta tha link intercourse n' is not used fo' linkin <target>.


.nf
  target_link_libraries(<target> LINK_INTERFACE_LIBRARIES
                        [[debug|optimized|general] <lib>] ...)
.fi

Da LINK_INTERFACE_LIBRARIES mode appendz tha libraries ta tha INTERFACE_LINK_LIBRARIES target property instead of rockin dem fo' linking.  If policy CMP0022 aint NEW, then dis mode also appendz libraries ta tha LINK_INTERFACE_LIBRARIES n' its per\-configuration equivalent.  This signature is fo' compatibilitizzle only. Prefer tha INTERFACE mode instead. Y'all KNOW dat shit, muthafucka!  Libraries specified as "debug" is wrapped up in a generator expression ta correspond ta debug builds.  If policy CMP0022 aint NEW, tha libraries is also appended ta tha LINK_INTERFACE_LIBRARIES_DEBUG property (or ta tha propertizzles correspondin ta configurations listed up in tha DEBUG_CONFIGURATIONS global property if it is set).  Libraries specified as "optimized" is appended ta tha INTERFACE_LINK_LIBRARIES property.  If policy CMP0022 aint NEW, they is also appended ta tha LINK_INTERFACE_LIBRARIES property.  Libraries specified as "general" (or without any keyword) is treated as if specified fo' both "debug" n' "optimized".


.nf
  target_link_libraries(<target>
                        <LINK_PRIVATE|LINK_PUBLIC>
                          [[debug|optimized|general] <lib>] ...
                        [<LINK_PRIVATE|LINK_PUBLIC>
                          [[debug|optimized|general] <lib>] ...])
.fi

Da LINK_PUBLIC n' LINK_PRIVATE modes can be used ta specify both tha link dependencies n' tha link intercourse up in one command. Y'all KNOW dat shit, muthafucka!  This signature is fo' compatibilitizzle only. Prefer tha PUBLIC or PRIVATE keywordz instead. Y'all KNOW dat shit, muthafucka!  Libraries n' targets followin LINK_PUBLIC is linked to, n' is made part of tha INTERFACE_LINK_LIBRARIES.  If policy CMP0022 aint NEW, they is also made part of tha LINK_INTERFACE_LIBRARIES.  Libraries n' targets followin LINK_PRIVATE is linked ta yo, but is not made part of tha INTERFACE_LINK_LIBRARIES (or LINK_INTERFACE_LIBRARIES).


Da library dependency graph is normally acyclic (a DAG) yo, but up in tha case of mutually\-dependent STATIC libraries CMake allows tha graph ta contain cyclez (strongly connected components).  When another target links ta one of tha libraries CMake repeats tha entire connected component.  For example, tha code


.nf
  add_library(A STATIC a.c)
  add_library(B STATIC b.c)
  target_link_libraries(A B)
  target_link_libraries(B A)
  add_executable(main main.c)
  target_link_libraries(main A)
.fi

links 'main' ta 'A B A B'.  (While one repetizzle is probably sufficient, pathological object file n' symbol arrangements can require mo' n' mo' n' mo'.  One may handle such cases by manually repeatin tha component up in tha last target_link_libraries call.  But fuck dat shiznit yo, tha word on tha street is dat if two archives is straight-up so interdependent they should probably be combined tha fuck into a single archive.)


Arguments ta target_link_libraries may use "generator expressions" wit tha syntax "$<...>".  Note however, dat generator expressions aint gonna be used up in OLD handlin of CMP0003 or CMP0004.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B try_compile
Try buildin some code.

.nf
  try_compile(RESULT_VAR <bindir> <srcdir>
              <projectName> [targetName] [CMAKE_FLAGS flags...]
              [OUTPUT_VARIABLE <var>])
.fi

Try buildin a project.  In dis form, srcdir should contain a cold-ass lil complete CMake project wit a CMakeLists.txt file n' all sources. Da bindir n' srcdir aint gonna be deleted afta dis command is run. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Specify targetName ta build a specific target instead of tha 'all' or 'ALL_BUILD' target.


.nf
  try_compile(RESULT_VAR <bindir> <srcfile|SOURCES srcfile...>
              [CMAKE_FLAGS flags...]
              [COMPILE_DEFINITIONS flags...]
              [LINK_LIBRARIES libs...]
              [OUTPUT_VARIABLE <var>]
              [COPY_FILE <fileName> [COPY_FILE_ERROR <var>]])
.fi

Try buildin a executable from one or mo' source files.  In dis form tha user need only supply one or mo' source filez dat include a thugged-out definizzle fo' 'main'.  CMake will create a CMakeLists.txt file ta build tha source(s) as a executable.  Specify COPY_FILE ta git a cold-ass lil copy of tha linked executable all up in tha given fileName n' optionally COPY_FILE_ERROR ta capture any error.


In dis version all filez up in bindir/CMakeFiles/CMakeTmp is ghon be cleaned automatically. For debugging, \-\-debug\-trycompile can be passed ta cmake ta avoid dis clean. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat multiple sequential try_compile operations reuse dis single output directory. If you use \-\-debug\-trycompile, you can only debug one try_compile call at a time. Da recommended procedure is ta configure wit cmake all tha way all up in once, then delete tha cache entry associated wit tha try_compile call of interest, n' then re\-run cmake again n' again n' again wit \-\-debug\-trycompile.


Some extra flags dat can be included are,  INCLUDE_DIRECTORIES, LINK_DIRECTORIES, n' LINK_LIBRARIES.  COMPILE_DEFINITIONS is \-Ddefinizzle dat is ghon be passed ta tha compile line.


Da srcfile signature also accepts a LINK_LIBRARIES argument which may contain a list of libraries or IMPORTED targets which is ghon be linked ta up in tha generated project.  If LINK_LIBRARIES is specified as a parameta ta try_compile, then any LINK_LIBRARIES passed as CMAKE_FLAGS is ghon be ignored.


try_compile creates a CMakeList.txt file on tha fly dat be lookin like this:


.nf
  add_definitions( <expanded COMPILE_DEFINITIONS from callin cmake>)
  include_directories(${INCLUDE_DIRECTORIES})
  link_directories(${LINK_DIRECTORIES})
  add_executable(cmTryCompileExec sources)
  target_link_libraries(cmTryCompileExec ${LINK_LIBRARIES})
.fi

In both versionz of tha command, if OUTPUT_VARIABLE is specified, then tha output from tha build process is stored up in tha given variable. Da success or failure of tha try_compile, i.e. TRUE or FALSE respectively, is returned up in RESULT_VAR. CMAKE_FLAGS can be used ta pass \-DVAR:TYPE=VALUE flags ta tha cmake dat is run durin tha build. Y'all KNOW dat shit, muthafucka! Set variable CMAKE_TRY_COMPILE_CONFIGURATION ta chizzle a funky-ass build configuration.

.TP
.B try_run
Try compilin n' then hustlin some code.

.nf
  try_run(RUN_RESULT_VAR COMPILE_RESULT_VAR
          bindir srcfile [CMAKE_FLAGS <Flags>]
          [COMPILE_DEFINITIONS <flags>]
          [COMPILE_OUTPUT_VARIABLE comp]
          [RUN_OUTPUT_VARIABLE run]
          [OUTPUT_VARIABLE var]
          [ARGS <arg1> <arg2>...])
.fi

Try compilin a srcfile.  Return TRUE or FALSE fo' success or failure up in COMPILE_RESULT_VAR.  Then if tha compile succeeded, run tha executable n' return its exit code up in RUN_RESULT_VAR. If tha executable was built yo, but failed ta run, then RUN_RESULT_VAR is ghon be set ta FAILED_TO_RUN. COMPILE_OUTPUT_VARIABLE specifies tha variable where tha output from tha compile step goes. RUN_OUTPUT_VARIABLE specifies tha variable where tha output from tha hustlin executable goes.


For compatibilitizzle reasons OUTPUT_VARIABLE is still supported, which gives you tha output from tha compile n' run step combined.


Cross compilin issues


When cross compiling, tha executable compiled up in tha straight-up original gangsta step probably cannot be run on tha build host. try_run() checks tha CMAKE_CROSSCOMPILING variable ta detect whether CMake is up in crosscompilin mode. If thatz tha case, it will still try ta compile tha executable yo, but it aint gonna try ta run tha executable. Instead it will create cache variablez which must be filled by tha user or by presettin dem up in some CMake script file ta tha joints tha executable would have produced if it had been run on its actual target platform. These variablez is RUN_RESULT_VAR (explanation peep above) n' if RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) was used, a additionizzle cache variable RUN_RESULT_VAR__COMPILE_RESULT_VAR__TRYRUN_OUTPUT.This is intended ta hold stdout n' stderr from tha executable.


In order ta make cross compilin yo' project easier, use try_run only if straight-up required. Y'all KNOW dat shit, muthafucka! If you use try_run, use RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) only if straight-up required. Y'all KNOW dat shit, muthafucka! Usin dem will require dat when crosscompiling, tha cache variablez will gotta be set manually ta tha output of tha executable. Yo ass can also "guard" tha calls ta try_run wit if(CMAKE_CROSSCOMPILING) n' provide a easy as fuck \-to\-preset alternatizzle fo' dis case.


Set variable CMAKE_TRY_COMPILE_CONFIGURATION ta chizzle a funky-ass build configuration.

.TP
.B unset
Unset a variable, cache variable, or environment variable.

.nf
  unset(<variable> [CACHE])
.fi

Removes tha specified variable causin it ta become undefined. Y'all KNOW dat shit, muthafucka!  If CACHE is present then tha variable is removed from tha cache instead of tha current scope.


<variable> can be a environment variable such as:


.nf
  unset(ENV{LD_LIBRARY_PATH})
.fi

in which case tha variable is ghon be removed from tha current environment.

.TP
.B variable_watch
Watch tha CMake variable fo' chizzle.

.nf
  variable_watch(<variable name> [<command ta execute>])
.fi

If tha specified variable chizzles, tha message is ghon be printed bout tha variable bein chizzled. Y'all KNOW dat shit, muthafucka! If tha command is specified, tha command is ghon be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da command will receive tha followin arguments: COMMAND(<variable> <access> <value> <current list file> <stack>)

.TP
.B while
Evaluate a crew of commandz while a cold-ass lil condizzle is true

.nf
  while(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endwhile(condition)
.fi

All commandz between while n' tha matchin endwhile is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endwhile is evaluated, tha recorded list of commandz is invoked as long as tha condizzle is true. Da condizzle is evaluated rockin tha same logic as tha if command.

.SH PROPERTIES
.PP
.nf
  CMake Propertizzles \- Propertizzles supported by CMake, tha Cross\-Platform Makefile Generator.
.fi

.PP
This is tha documentation fo' tha propertizzles supported by CMake. Propertizzles can have different scopes. They can either be assigned ta a source file, a gangbangin' finger-lickin' directory, a target or globally ta CMake. By modifyin tha jointz of propertizzles tha behaviour of tha build system can be customized.

.SH PROPERTIES OF GLOBAL SCOPE
.TP
.B ALLOW_DUPLICATE_CUSTOM_TARGETS
Allow duplicate custom targets ta be pimped.

Normally CMake requires dat all targets built up in a project have globally unique logical names (see policy CMP0002).  This is necessary ta generate meaningful project file names up in Xcode n' VS IDE generators.  It also allows tha target names ta be referenced unambiguously.


Makefile generators is capable of supportin duplicate custom target names.  For projects dat care only bout Makefile generators n' do not wish ta support Xcode or VS IDE generators, one may set dis property ta legit ta allow duplicate custom targets, n' you can put dat on yo' toast.  Da property allows multiple add_custom_target command calls up in different directories ta specify tha same target name.  But fuck dat shiznit yo, tha word on tha street is dat settin dis property will cause non\-Makefile generators ta produce a error n' refuse ta generate tha project.

.TP
.B AUTOMOC_TARGETS_FOLDER
Name of FOLDER fo' *_automoc targets dat is added automatically by CMake fo' targets fo' which AUTOMOC is enabled.

If not set, CMake uses tha FOLDER property of tha parent target as a thugged-out default value fo' dis property. Right back up in yo muthafuckin ass. See also tha documentation fo' tha FOLDER target property n' tha AUTOMOC target property.

.TP
.B DEBUG_CONFIGURATIONS
Specify which configurations is fo' debugging.

Da value must be a semi\-colon separated list of configuration names.  Currently dis property is used only by tha target_link_libraries command (see its documentation fo' details).  Additionizzle uses may be defined up in tha future.  


This property must be set all up in tha top level of tha project n' before tha straight-up original gangsta target_link_libraries command invocation. I aint talkin' bout chicken n' gravy biatch.  If any entry up in tha list do not match a valid configuration fo' tha project tha behavior is undefined.

.TP
.B DISABLED_FEATURES
List of features which is disabled durin tha CMake run.

List of features which is disabled durin tha CMake run. I aint talkin' bout chicken n' gravy biatch. By default it gotz nuff tha namez of all packages which was not found. Y'all KNOW dat shit, muthafucka! This is determined rockin tha <NAME>_FOUND variables. Packages which is searched QUIET is not listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A project can add its own features ta dis list. This property is used by tha macros up in FeatureSummary.cmake.

.TP
.B ENABLED_FEATURES
List of features which is enabled durin tha CMake run.

List of features which is enabled durin tha CMake run. I aint talkin' bout chicken n' gravy biatch. By default it gotz nuff tha namez of all packages which was found. Y'all KNOW dat shit, muthafucka! This is determined rockin tha <NAME>_FOUND variables. Packages which is searched QUIET is not listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A project can add its own features ta dis list. This property is used by tha macros up in FeatureSummary.cmake.

.TP
.B ENABLED_LANGUAGES
Read\-only property dat gotz nuff tha list of currently enabled languages

Set ta list of currently enabled languages.

.TP
.B FIND_LIBRARY_USE_LIB64_PATHS
Whether FIND_LIBRARY should automatically search lib64 directories.

FIND_LIBRARY_USE_LIB64_PATHS be a funky-ass boolean specifyin whether tha FIND_LIBRARY command should automatically search tha lib64 variant of directories called lib up in tha search path when buildin 64\-bit binaries.

.TP
.B FIND_LIBRARY_USE_OPENBSD_VERSIONING
Whether FIND_LIBRARY should find OpenBSD\-style shared libraries.

This property be a funky-ass boolean specifyin whether tha FIND_LIBRARY command should find shared libraries wit OpenBSD\-style versioned extension: ".so.<major>.<minor>".  Da property is set ta legit on OpenBSD n' false on other platforms.

.TP
.B GLOBAL_DEPENDS_DEBUG_MODE
Enable global target dependency graph debug mode.

CMake automatically analyzes tha global inter\-target dependency graph all up in tha beginnin of natizzle build system generation. I aint talkin' bout chicken n' gravy biatch.  This property causes it ta display detailz of its analysis ta stderr.

.TP
.B GLOBAL_DEPENDS_NO_CYCLES
Disallow global target dependency graph cycles.

CMake automatically analyzes tha global inter\-target dependency graph all up in tha beginnin of natizzle build system generation. I aint talkin' bout chicken n' gravy biatch.  It reports a error if tha dependency graph gotz nuff a cold-ass lil cycle dat do not consist of all STATIC library targets, n' you can put dat on yo' toast.  This property  drops some lyrics ta CMake ta disallow all cyclez straight-up, even among static libraries.

.TP
.B IN_TRY_COMPILE
Read\-only property dat is legit durin a try\-compile configuration.

True when buildin a project inside a TRY_COMPILE or TRY_RUN command.

.TP
.B PACKAGES_FOUND
List of packages which was found durin tha CMake run.

List of packages which was found durin tha CMake run. I aint talkin' bout chicken n' gravy biatch. Whether a package has been found is determined rockin tha <NAME>_FOUND variables.

.TP
.B PACKAGES_NOT_FOUND
List of packages which was not found durin tha CMake run.

List of packages which was not found durin tha CMake run. I aint talkin' bout chicken n' gravy biatch. Whether a package has been found is determined rockin tha <NAME>_FOUND variables.

.TP
.B PREDEFINED_TARGETS_FOLDER
Name of FOLDER fo' targets dat is added automatically by CMake.

If not set, CMake uses "CMakePredefinedTargets" as a thugged-out default value fo' dis property. Targets like fuckin INSTALL, PACKAGE n' RUN_TESTS is ghon be organized tha fuck into dis FOLDER. Right back up in yo muthafuckin ass. See also tha documentation fo' tha FOLDER target property.

.TP
.B REPORT_UNDEFINED_PROPERTIES
If set, report any undefined propertizzles ta dis file.

If dis property is set ta a gangbangin' filename then when CMake runs it will report any propertizzles or variablez dat was accessed but not defined tha fuck into tha filename specified up in dis property.

.TP
.B RULE_LAUNCH_COMPILE
Specify a launcher fo' compile rules.

Makefile generators prefix compila commandz wit tha given launcher command line.  This is intended ta allow launchers ta intercept build problems wit high granularity.  Non\-Makefile generators currently ignore dis property.

.TP
.B RULE_LAUNCH_CUSTOM
Specify a launcher fo' custom rules.

Makefile generators prefix custom commandz wit tha given launcher command line.  This is intended ta allow launchers ta intercept build problems wit high granularity.  Non\-Makefile generators currently ignore dis property.

.TP
.B RULE_LAUNCH_LINK
Specify a launcher fo' link rules.

Makefile generators prefix link n' archive commandz wit tha given launcher command line.  This is intended ta allow launchers ta intercept build problems wit high granularity.  Non\-Makefile generators currently ignore dis property.

.TP
.B RULE_MESSAGES
Specify whether ta report a message fo' each make rule.

This property specifies whether Makefile generators should add a progress message describin what tha fuck each build rule do.  If tha property aint set tha default is ON.  Set tha property ta OFF ta disable granular lyrics n' report only as each target completes.  This is intended ta allow scripted buildz ta avoid tha build time cost of detailed reports, n' you can put dat on yo' toast.  If a CMAKE_RULE_MESSAGES cache entry exists its value initializes tha value of dis property.  Non\-Makefile generators currently ignore dis property.

.TP
.B TARGET_ARCHIVES_MAY_BE_SHARED_LIBS
Set if shared libraries may be named like archives.

On AIX shared libraries may be named "lib<name>.a".  This property is set ta legit on such platforms.

.TP
.B TARGET_SUPPORTS_SHARED_LIBS
Do tha target platform support shared libraries.

TARGET_SUPPORTS_SHARED_LIBS be a funky-ass boolean specifyin whether tha target platform supports shared libraries. Put ya muthafuckin choppers up if ya feel dis! Basically all current general general purpose OS do so, tha exception is probably embedded systems wit no or special OSs.

.TP
.B USE_FOLDERS
Use tha FOLDER target property ta organize targets tha fuck into folders.

If not set, CMake treats dis property as OFF by default. CMake generators dat is capable of organizin tha fuck into a hierarchy of foldaz use tha jointz of tha FOLDER target property ta name dem folders. Right back up in yo muthafuckin ass. See also tha documentation fo' tha FOLDER target property.

.TP
.B __CMAKE_DELETE_CACHE_CHANGE_VARS_
Internal property

Used ta detect compila chizzles, Do not set.

.SH PROPERTIES ON DIRECTORIES
.TP
.B ADDITIONAL_MAKE_CLEAN_FILES
Additionizzle filez ta clean durin tha make clean stage.

A list of filez dat is ghon be cleaned as a part of tha "make clean" stage. 

.TP
.B CACHE_VARIABLES
List of cache variablez available up in tha current directory.

This read\-only property specifies tha list of CMake cache variablez currently defined. Y'all KNOW dat shit, muthafucka!  It be intended fo' debuggin purposes.

.TP
.B CLEAN_NO_CUSTOM
Should tha output of custom commandz be left.

If dis is legit then tha outputz of custom commandz fo' dis directory aint gonna be removed durin tha "make clean" stage. 

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions fo' compilin a gangbangin' finger-lickin' directoryz sources.

Da COMPILE_DEFINITIONS property may be set ta a semicolon\-separated list of preprocessor definitions rockin tha syntax VAR or VAR=value.  Function\-style definitions is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  CMake will automatically escape tha value erectly fo' tha natizzle build system (note dat CMake language syntax may require escapes ta specify some joints).  This property may be set on a per\-configuration basis rockin tha name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> be a upper\-case name (ex. "COMPILE_DEFINITIONS_DEBUG").  This property is ghon be initialized up in each directory by its value up in tha directoryz parent.


CMake will automatically drop some definitions dat is not supported by tha natizzle build tool.  Da VS6 IDE do not support definizzle joints wit spaces (but NMake do).


Disclaimer: Most natizzle build tools have skanky support fo' escapin certain joints, n' you can put dat on yo' toast.  CMake has work\-aroundz fo' nuff cases but some joints may just not be possible ta pass erectly.  If a value do not seem ta be escaped erectly, do not attempt ta work\-around tha problem by addin escape sequences ta tha value.  Yo crazy-ass work\-around may break up in a gangbangin' future version of CMake dat has improved escape support.  Instead consider definin tha macro up in a (configured) header file.  Then report tha limitation. I aint talkin' bout chicken n' gravy biatch.  Known limitations include:


.nf
  #          \- fucked up almost everywhere
  ;          \- fucked up in VS IDE 7.0 n' Borland Makefiles
  ,          \- fucked up in VS IDE
  %          \- fucked up in some cases up in NMake
  & |        \- fucked up in some cases on MinGW
  ^ < > \\"   \- fucked up in most Make tools on Windows
.fi

CMake do not reject these joints outright cuz they do work up in some cases.  Use wit caution. I aint talkin' bout chicken n' gravy biatch.  

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per\-configuration preprocessor definitions up in a gangbangin' finger-lickin' directory.

This is tha configuration\-specific version of COMPILE_DEFINITIONS.  This property is ghon be initialized up in each directory by its value up in tha directoryz parent.


.TP
.B COMPILE_OPTIONS
List of options ta pass ta tha compiler.

This property specifies tha list of directories given so far fo' dis property.  This property exists on directories n' targets.


Da target property joints is used by tha generators ta set tha options fo' tha compiler.


Contentz of COMPILE_OPTIONS may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B DEFINITIONS
For CMake 2.4 compatibilitizzle only.  Use COMPILE_DEFINITIONS instead.

This read\-only property specifies tha list of flags given so far ta tha add_definitions command. Y'all KNOW dat shit, muthafucka!  It be intended fo' debuggin purposes.  Use tha COMPILE_DEFINITIONS instead.

.TP
.B EXCLUDE_FROM_ALL
Exclude tha directory from tha all target of its parent.

A property on a gangbangin' finger-lickin' directory dat indicates if its targets is excluded from tha default build target. If it is not, then wit a Makefile fo' example typin make will cause tha targets ta be built. Da same concept applies ta tha default build of other generators.

.TP
.B IMPLICIT_DEPENDS_INCLUDE_TRANSFORM
Specify #include line transforms fo' dependencies up in a gangbangin' finger-lickin' directory.

This property specifies rulez ta transform macro\-like #include lines durin implicit dependency scannin of C n' C++ source files.  Da list of rulez must be semicolon\-separated wit each entry of tha form "A_MACRO(%)=value\-with\-%" (the % must be literal).  Durin dependency scannin occurrencez of A_MACRO(...) on #include lines is ghon be replaced by tha value given wit tha macro argument substituted fo' '%'.  For example, tha entry


.nf
  MYDIR(%)=<mydir/%>
.fi

will convert linez of tha form


.nf
  #include MYDIR(myheader.h)
.fi

to


.nf
  #include <mydir/myheader.h>
.fi

allowin tha dependency ta be followed.


This property applies ta sources up in all targets within a gangbangin' finger-lickin' directory.  Da property value is initialized up in each directory by its value up in tha directoryz parent.

.TP
.B INCLUDE_DIRECTORIES
List of preprocessor include file search directories.

This property specifies tha list of directories given so far ta tha include_directories command. Y'all KNOW dat shit, muthafucka!  This property exists on directories n' targets, n' you can put dat on yo' toast.  In addizzle ta acceptin joints from tha include_directories command, joints may be set directly on any directory or any target rockin tha set_property command. Y'all KNOW dat shit, muthafucka!  A target gets its initial value fo' dis property from tha value of tha directory property.  A directory gets its initial value from its parent directory if it has one.  Both directory n' target property joints is adjusted by calls ta tha include_directories command.


Da target property joints is used by tha generators ta set tha include paths fo' tha compila n' shit.  See also tha include_directories command.

.TP
.B INCLUDE_REGULAR_EXPRESSION
Include file scannin regular expression.

This read\-only property specifies tha regular expression used durin dependency scannin ta match include filez dat should be followed. Y'all KNOW dat shit, muthafucka!  See tha include_regular_expression command.

.TP
.B INTERPROCEDURAL_OPTIMIZATION
Enable interprocedural optimization fo' targets up in a gangbangin' finger-lickin' directory.

If set ta true, enablez interprocedural optimizations if they is known ta be supported by tha compiler.

.TP
.B INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
Per\-configuration interprocedural optimization fo' a gangbangin' finger-lickin' directory.

This be a per\-configuration version of INTERPROCEDURAL_OPTIMIZATION.  If set, dis property overrides tha generic property fo' tha named configuration.

.TP
.B LINK_DIRECTORIES
List of linker search directories.

This read\-only property specifies tha list of directories given so far ta tha link_directories command. Y'all KNOW dat shit, muthafucka!  It be intended fo' debuggin purposes.

.TP
.B LISTFILE_STACK
Da current stack of listfilez bein processed.

This property is mainly useful when tryin ta debug errors up in yo' CMake scripts, n' you can put dat on yo' toast. Well shiiiit, it returns a list of what tha fuck list filez is currently bein processed, up in order n' shit. Right back up in yo muthafuckin ass. So if one listfile do a INCLUDE command then dat is effectively pushin tha included listfile onto tha stack.

.TP
.B MACROS
List of macro commandz available up in tha current directory.

This read\-only property specifies tha list of CMake macros currently defined. Y'all KNOW dat shit, muthafucka!  It be intended fo' debuggin purposes.  See tha macro command.

.TP
.B PARENT_DIRECTORY
Source directory dat added current subdirectory.

This read\-only property specifies tha source directory dat added tha current source directory as a subdirectory of tha build. Y'all KNOW dat shit, muthafucka!  In tha top\-level directory tha value is tha empty\-string.

.TP
.B RULE_LAUNCH_COMPILE
Specify a launcher fo' compile rules.

See tha global property of tha same name fo' details.  This overrides tha global property fo' a gangbangin' finger-lickin' directory.

.TP
.B RULE_LAUNCH_CUSTOM
Specify a launcher fo' custom rules.

See tha global property of tha same name fo' details.  This overrides tha global property fo' a gangbangin' finger-lickin' directory.

.TP
.B RULE_LAUNCH_LINK
Specify a launcher fo' link rules.

See tha global property of tha same name fo' details.  This overrides tha global property fo' a gangbangin' finger-lickin' directory.

.TP
.B TEST_INCLUDE_FILE
A cmake file dat is ghon be included when ctest is run.

If you specify TEST_INCLUDE_FILE, dat file is ghon be included n' processed when ctest is run on tha directory.

.TP
.B VARIABLES
List of variablez defined up in tha current directory.

This read\-only property specifies tha list of CMake variablez currently defined. Y'all KNOW dat shit, muthafucka!  It be intended fo' debuggin purposes.

.TP
.B VS_GLOBAL_SECTION_POST_<section>
Specify a postSolution global section up in Visual Studio.

Settin a property like dis generates a entry of tha followin form up in tha solution file:


.nf
  GlobalSection(<section>) = postSolution
    <contents based on property value>
  EndGlobalSection
.fi

Da property must be set ta a semicolon\-separated list of key=value pairs. Each such pair is ghon be transformed tha fuck into a entry up in tha solution global section. I aint talkin' bout chicken n' gravy biatch. Whitespace round key n' value is ignored. Y'all KNOW dat shit, muthafucka! List elements which do not contain a equal sign is skipped.


This property only works fo' Visual Studio 7 n' above; it is ignored on other generators. Da property only applies when set on a gangbangin' finger-lickin' directory whose CMakeLists.txt gotz nuff a project() command.


Note dat CMake generates postSolution sections ExtensibilityGlobals n' ExtensibilityAddIns by default. If you set tha correspondin property, it will override tha default section. I aint talkin' bout chicken n' gravy biatch. For example, settin VS_GLOBAL_SECTION_POST_ExtensibilityGlobals will override tha default contentz of tha ExtensibilityGlobals section, while keepin ExtensibilityAddIns on its default.

.TP
.B VS_GLOBAL_SECTION_PRE_<section>
Specify a preSolution global section up in Visual Studio.

Settin a property like dis generates a entry of tha followin form up in tha solution file:


.nf
  GlobalSection(<section>) = preSolution
    <contents based on property value>
  EndGlobalSection
.fi

Da property must be set ta a semicolon\-separated list of key=value pairs. Each such pair is ghon be transformed tha fuck into a entry up in tha solution global section. I aint talkin' bout chicken n' gravy biatch. Whitespace round key n' value is ignored. Y'all KNOW dat shit, muthafucka! List elements which do not contain a equal sign is skipped.


This property only works fo' Visual Studio 7 n' above; it is ignored on other generators. Da property only applies when set on a gangbangin' finger-lickin' directory whose CMakeLists.txt gotz nuff a project() command.

.SH PROPERTIES ON TARGETS
.TP
.B <CONFIG>_OUTPUT_NAME
Oldskool per\-configuration target file base name.

This be a cold-ass lil configuration\-specific version of OUTPUT_NAME.  Use OUTPUT_NAME_<CONFIG> instead.

.TP
.B <CONFIG>_POSTFIX
Postfix ta append ta tha target file name fo' configuration <CONFIG>.

When buildin wit configuration <CONFIG> tha value of dis property be appended ta tha target file name built on disk.  For non\-executable targets, dis property is initialized by tha value of tha variable CMAKE_<CONFIG>_POSTFIX if it is set when a target is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This property is ignored on tha Mac fo' Frameworks n' App Bundles.

.TP
.B <LANG>_VISIBILITY_PRESET
Value fo' symbol visibilitizzle compile flags

Da <LANG>_VISIBILITY_PRESET property determines tha value passed up in a visibilitizzle related compile option, like fuckin \-fvisibility= fo' <LANG>.  This property only has a affect fo' libraries n' executablez wit exports, n' you can put dat on yo' toast.  This property is initialized by tha value of tha variable CMAKE_<LANG>_VISIBILITY_PRESET if it is set when a target is pimped.

.TP
.B ALIASED_TARGET
Name of target aliased by dis target.

If dis be a ALIAS target, dis property gotz nuff tha name of tha target aliased.

.TP
.B ARCHIVE_OUTPUT_DIRECTORY
Output directory up in which ta build ARCHIVE target files.

This property specifies tha directory tha fuck into which archive target filez should be built. Multi\-configuration generators (VS, Xcode) append a per\-configuration subdirectory ta tha specified directory.  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.  This property is initialized by tha value of tha variable CMAKE_ARCHIVE_OUTPUT_DIRECTORY if it is set when a target is pimped.

.TP
.B ARCHIVE_OUTPUT_DIRECTORY_<CONFIG>
Per\-configuration output directory fo' ARCHIVE target files.

This be a per\-configuration version of ARCHIVE_OUTPUT_DIRECTORY yo, but multi\-configuration generators (VS, Xcode) do NOT append a per\-configuration subdirectory ta tha specified directory.  This property is initialized by tha value of tha variable CMAKE_ARCHIVE_OUTPUT_DIRECTORY_<CONFIG> if it is set when a target is pimped.

.TP
.B ARCHIVE_OUTPUT_NAME
Output name fo' ARCHIVE target files.

This property specifies tha base name fo' archive target files. Well shiiiit, it overrides OUTPUT_NAME n' OUTPUT_NAME_<CONFIG> properties. Put ya muthafuckin choppers up if ya feel dis!  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.

.TP
.B ARCHIVE_OUTPUT_NAME_<CONFIG>
Per\-configuration output name fo' ARCHIVE target files.

This is tha configuration\-specific version of ARCHIVE_OUTPUT_NAME.

.TP
.B AUTOMOC
Should tha target be processed wit automoc (for Qt projects).

AUTOMOC be a funky-ass boolean specifyin whether CMake will handle tha Qt moc preprocessor automatically, i.e. without havin ta use tha QT4_WRAP_CPP() or QT5_WRAP_CPP() macro. Currently Qt4 n' Qt5 is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When dis property is set ta TRUE, CMake will scan tha source filez at build time n' invoke moc accordingly. If a #include statement like #include "moc_foo.cpp" is found, tha Q_OBJECT class declaration is expected up in tha header, n' moc is run on tha header file. If a #include statement like #include "foo.moc" is found, then a Q_OBJECT is expected up in tha current source file n' moc is run on tha file itself fo' realz. Additionally, all header filez is parsed fo' Q_OBJECT macros, n' if found, moc be also executed on dem files. Da resultin moc files, which is not included as shown above up in any of tha source filez is included up in a generated <targetname>_automoc.cpp file, which is compiled as part of tha target.This property is initialized by tha value of tha variable CMAKE_AUTOMOC if it is set when a target is pimped.


Additionizzle command line options fo' moc can be set via tha AUTOMOC_MOC_OPTIONS property.


By settin tha CMAKE_AUTOMOC_RELAXED_MODE variable ta TRUE tha rulez fo' searchin tha filez which is ghon be processed by moc can be chillaxed. Y'all KNOW dat shit, muthafucka! See tha documentation fo' dis variable fo' mo' details.


Da global property AUTOMOC_TARGETS_FOLDER can be used ta crew tha automoc targets together up in a IDE, e.g. up in MSVS.

.TP
.B AUTOMOC_MOC_OPTIONS
Additionizzle options fo' moc when rockin automoc (see tha AUTOMOC property)

This property is only used if tha AUTOMOC property is set ta TRUE fo' dis target. In dis case, it holdz additionizzle command line options which is ghon be used when moc is executed durin tha build, i.e. it is equivalent ta tha optionizzle OPTIONS argument of tha qt4_wrap_cpp() macro.


By default it is empty.

.TP
.B BUILD_WITH_INSTALL_RPATH
Should build tree targets have install tree rpaths.

BUILD_WITH_INSTALL_RPATH be a funky-ass boolean specifyin whether ta link tha target up in tha build tree wit tha INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH n' avoidz tha need fo' relinkin before installation. I aint talkin' bout chicken n' gravy biatch.  This property is initialized by tha value of tha variable CMAKE_BUILD_WITH_INSTALL_RPATH if it is set when a target is pimped.

.TP
.B BUNDLE
This target be a CFBundle on tha Mac.

If a module library target has dis property set ta legit it is ghon be built as a CFBundle when built on tha mac. Well shiiiit, it gonna git tha directory structure required fo' a CFBundle n' is ghon be suitable ta be used fo' bustin Browser Plugins or other application resources.

.TP
.B BUNDLE_EXTENSION
Da file extension used ta name a BUNDLE target on tha Mac.

Da default value is "bundle" \- you can also use "plugin" or whatever file extension is required by tha host app fo' yo' bundle.

.TP
.B COMPATIBLE_INTERFACE_BOOL
Propertizzles which must be compatible wit they link intercourse

Da COMPATIBLE_INTERFACE_BOOL property may contain a list of propertiesfor dis target which must be consistent when evaluated as a funky-ass boolean up in tha INTERFACE of all linked dependees.  For example, if a property "FOO" appears up in tha list, then fo' each dependee, tha "INTERFACE_FOO" property content up in all of its dependencies must be consistent wit each other, n' wit tha "FOO" property up in tha dependee.  Consistency up in dis sense has tha meanin dat if tha property is set, then it must have tha same boolean value as all others, n' if tha property aint set, then it is ignored. Y'all KNOW dat shit, muthafucka!  Note dat fo' each dependee, tha set of propertizzles from dis property must not intersect wit tha set of propertizzles from tha COMPATIBLE_INTERFACE_STRING property.

.TP
.B COMPATIBLE_INTERFACE_STRING
Propertizzles which must be string\-compatible wit they link intercourse

Da COMPATIBLE_INTERFACE_STRING property may contain a list of propertizzles fo' dis target which must be tha same when evaluated as a strang up in tha INTERFACE of all linked dependees.  For example, if a property "FOO" appears up in tha list, then fo' each dependee, tha "INTERFACE_FOO" property content up in all of its dependencies must be equal wit each other, n' wit tha "FOO" property up in tha dependee.  If tha property aint set, then it is ignored. Y'all KNOW dat shit, muthafucka!  Note dat fo' each dependee, tha set of propertizzles from dis property must not intersect wit tha set of propertizzles from tha COMPATIBLE_INTERFACE_BOOL property.

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions fo' compilin a targetz sources.

Da COMPILE_DEFINITIONS property may be set ta a semicolon\-separated list of preprocessor definitions rockin tha syntax VAR or VAR=value.  Function\-style definitions is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  CMake will automatically escape tha value erectly fo' tha natizzle build system (note dat CMake language syntax may require escapes ta specify some joints).  This property may be set on a per\-configuration basis rockin tha name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> be a upper\-case name (ex. "COMPILE_DEFINITIONS_DEBUG").


CMake will automatically drop some definitions dat is not supported by tha natizzle build tool.  Da VS6 IDE do not support definizzle joints wit spaces (but NMake do).


Contentz of COMPILE_DEFINITIONS may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

Disclaimer: Most natizzle build tools have skanky support fo' escapin certain joints, n' you can put dat on yo' toast.  CMake has work\-aroundz fo' nuff cases but some joints may just not be possible ta pass erectly.  If a value do not seem ta be escaped erectly, do not attempt ta work\-around tha problem by addin escape sequences ta tha value.  Yo crazy-ass work\-around may break up in a gangbangin' future version of CMake dat has improved escape support.  Instead consider definin tha macro up in a (configured) header file.  Then report tha limitation. I aint talkin' bout chicken n' gravy biatch.  Known limitations include:


.nf
  #          \- fucked up almost everywhere
  ;          \- fucked up in VS IDE 7.0 n' Borland Makefiles
  ,          \- fucked up in VS IDE
  %          \- fucked up in some cases up in NMake
  & |        \- fucked up in some cases on MinGW
  ^ < > \\"   \- fucked up in most Make tools on Windows
.fi

CMake do not reject these joints outright cuz they do work up in some cases.  Use wit caution. I aint talkin' bout chicken n' gravy biatch.  

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per\-configuration preprocessor definitions on a target.

This is tha configuration\-specific version of COMPILE_DEFINITIONS.

.TP
.B COMPILE_FLAGS
Additionizzle flags ta use when compilin dis targetz sources.

Da COMPILE_FLAGS property sets additionizzle compila flags used ta build sources within tha target.  Use COMPILE_DEFINITIONS ta pass additionizzle preprocessor definitions.

.TP
.B COMPILE_OPTIONS
List of options ta pass ta tha compiler.

This property specifies tha list of options specified so far fo' dis property.  This property exists on directories n' targets.


Da target property joints is used by tha generators ta set tha options fo' tha compiler.


Contentz of COMPILE_OPTIONS may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B DEBUG_POSTFIX
See target property <CONFIG>_POSTFIX.

This property be a special case of tha more\-general <CONFIG>_POSTFIX property fo' tha DEBUG configuration.

.TP
.B DEFINE_SYMBOL
Define a symbol when compilin dis targetz sources.

DEFINE_SYMBOL sets tha name of tha preprocessor symbol defined when compilin sources up in a gangbangin' finger-lickin' dirty-ass shared library. If not set here then it is set ta target_EXPORTS by default (with some substitutions if tha target aint a valid C identifier). This is useful fo' headaz ta know whether they is bein included from inside they library or outside ta properly setup dllexport/dllimport decorations. 

.TP
.B ENABLE_EXPORTS
Specify whether a executable exports symbols fo' loadable modules.

Normally a executable do not export any symbols cuz it is tha final program.  It be possible fo' a executable ta export symbols ta be used by loadable modules.  When dis property is set ta legit CMake will allow other targets ta "link" ta tha executable wit tha TARGET_LINK_LIBRARIES command. Y'all KNOW dat shit, muthafucka!  On all platforms a target\-level dependency on tha executable is pimped fo' targets dat link ta dat shit.  For DLL platforms a import library is ghon be pimped fo' tha exported symbols n' then used fo' linking.  All Windows\-based systems includin Cygwin is DLL platforms.  For non\-DLL platforms dat require all symbols ta be resolved at link time, like fuckin Mac OS X, tha module will "link" ta tha executable rockin a gangbangin' flag like "\-bundle_loader".  For other non\-DLL platforms tha link rule is simply ignored since tha dynamic loader will automatically bind symbols when tha module is loaded. Y'all KNOW dat shit, muthafucka!  

.TP
.B EXCLUDE_FROM_ALL
Exclude tha target from tha all target.

A property on a target dat indicates if tha target is excluded from tha default build target. If it is not, then wit a Makefile fo' example typin make will cause dis target ta be built. Da same concept applies ta tha default build of other generators. Installin a target wit EXCLUDE_FROM_ALL set ta legit has undefined behavior.

.TP
.B EXCLUDE_FROM_DEFAULT_BUILD
Exclude target from "Build Solution".

This property is only used by Visual Studio generators 7 n' above. When set ta TRUE, tha target aint gonna be built when you press "Build Solution".

.TP
.B EXCLUDE_FROM_DEFAULT_BUILD_<CONFIG>
Per\-configuration version of target exclusion from "Build Solution". 

This is tha configuration\-specific version of EXCLUDE_FROM_DEFAULT_BUILD. If tha generic EXCLUDE_FROM_DEFAULT_BUILD be also set on a target, EXCLUDE_FROM_DEFAULT_BUILD_<CONFIG> takes precedence up in configurations fo' which it has a value.

.TP
.B EXPORT_NAME
Exported name fo' target files.

This sets tha name fo' tha IMPORTED target generated when it dis target is is exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If not set, tha logical target name is used by default.

.TP
.B EchoString
A message ta be displayed when tha target is built.

A message ta display on some generators (like fuckin makefiles) when tha target is built.

.TP
.B FOLDER
Set tha folda name. Use ta organize targets up in a IDE.

Targets wit no FOLDER property will step tha fuck up as top level entitizzles up in IDEs like Visual Studio. Targets wit tha same FOLDER property value will step tha fuck up next ta each other up in a gangbangin' folda of dat name. To nest folders, use FOLDER joints like fuckin 'GUI/Dialogs' wit '/' charactas separatin folda levels.

.TP
.B FRAMEWORK
This target be a gangbangin' framework on tha Mac.

If a gangbangin' finger-lickin' dirty-ass shared library target has dis property set ta legit it is ghon be built as a gangbangin' framework when built on tha mac. Well shiiiit, it gonna git tha directory structure required fo' a gangbangin' framework n' is ghon be suitable ta be used wit tha \-framework option

.TP
.B Fortran_FORMAT
Set ta FIXED or FREE ta indicate tha Fortran source layout.

This property  drops some lyrics ta CMake whether tha Fortran source filez up in a target use fixed\-format or free\-format.  CMake will pass tha correspondin format flag ta tha compila n' shit.  Use tha source\-specific Fortran_FORMAT property ta chizzle tha format of a specific source file.  If tha variable CMAKE_Fortran_FORMAT is set when a target is pimped its value is used ta initialize dis property.

.TP
.B Fortran_MODULE_DIRECTORY
Specify output directory fo' Fortran modulez provided by tha target.

If tha target gotz nuff Fortran source filez dat provide modulez n' tha compila supports a module output directory dis specifies tha directory up in which tha modulez is ghon be placed. Y'all KNOW dat shit, muthafucka!  When dis property aint set tha modulez is ghon be placed up in tha build directory correspondin ta tha targetz source directory.  If tha variable CMAKE_Fortran_MODULE_DIRECTORY is set when a target is pimped its value is used ta initialize dis property.


Note dat some compilaz will automatically search tha module output directory fo' modulez USEd durin compilation but others will not.  If yo' sources USE modulez they location must be specified by INCLUDE_DIRECTORIES regardless of dis property.

.TP
.B GENERATOR_FILE_NAME
Generatorz file fo' dis target.

An internal property used by some generators ta record tha name of tha project or dsp file associated wit dis target. Note dat at configure time, dis property is only set fo' targets pimped by include_external_msproject().

.TP
.B GNUtoMS
Convert GNU import library (.dll.a) ta MS format (.lib).

When linkin a gangbangin' finger-lickin' dirty-ass shared library or executable dat exports symbols rockin GNU tools on Windows (MinGW/MSYS) wit Visual Studio installed convert tha import library (.dll.a) from GNU ta MS format (.lib).  Both import libraries is ghon be installed by install(TARGETS) n' exported by install(EXPORT) n' export() ta be linked by applications wit either GNU\- or MS\-compatible tools.


If tha variable CMAKE_GNUtoMS is set when a target is pimped its value is used ta initialize dis property.  Da variable must be set prior ta tha straight-up original gangsta command dat enablez a language like fuckin project() or enable_language().  CMake serves up tha variable as a option ta tha user automatically when configurin on Windows wit GNU tools.

.TP
.B HAS_CXX
Link tha target rockin tha C++ linker tool (obsolete).

This is equivalent ta settin tha LINKER_LANGUAGE property ta CXX.  See dat propertyz documentation fo' details.

.TP
.B IMPLICIT_DEPENDS_INCLUDE_TRANSFORM
Specify #include line transforms fo' dependencies up in a target.

This property specifies rulez ta transform macro\-like #include lines durin implicit dependency scannin of C n' C++ source files.  Da list of rulez must be semicolon\-separated wit each entry of tha form "A_MACRO(%)=value\-with\-%" (the % must be literal).  Durin dependency scannin occurrencez of A_MACRO(...) on #include lines is ghon be replaced by tha value given wit tha macro argument substituted fo' '%'.  For example, tha entry


.nf
  MYDIR(%)=<mydir/%>
.fi

will convert linez of tha form


.nf
  #include MYDIR(myheader.h)
.fi

to


.nf
  #include <mydir/myheader.h>
.fi

allowin tha dependency ta be followed.


This property applies ta sources up in tha target on which it is set.

.TP
.B IMPORTED
Read\-only indication of whether a target is IMPORTED.

Da boolean value of dis property is legit fo' targets pimped wit tha IMPORTED option ta add_executable or add_library.  It be false fo' targets built within tha project.

.TP
.B IMPORTED_CONFIGURATIONS
Configurations provided fo' a IMPORTED target.

Set dis ta tha list of configuration names available fo' a IMPORTED target.  Da names correspond ta configurations defined up in tha project from which tha target is imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If tha importin project uses a gangbangin' finger-lickin' different set of configurations tha names may be mapped rockin tha MAP_IMPORTED_CONFIG_<CONFIG> property.  Ignored fo' non\-imported targets.

.TP
.B IMPORTED_IMPLIB
Full path ta tha import library fo' a IMPORTED target.

Set dis ta tha location of tha ".lib" part of a windows DLL.  Ignored fo' non\-imported targets.

.TP
.B IMPORTED_IMPLIB_<CONFIG>
<CONFIG>\-specific version of IMPORTED_IMPLIB property.

Configuration names correspond ta dem provided by tha project from which tha target is imported.

.TP
.B IMPORTED_LINK_DEPENDENT_LIBRARIES
Dependent shared librariez of a imported shared library.

Shared libraries may be linked ta other shared libraries as part of they implementation. I aint talkin' bout chicken n' gravy biatch.  On some platforms tha linker searches fo' tha dependent librariez of shared libraries they is includin up in tha link.  Set dis property ta tha list of dependent shared librariez of a imported library.  Da list should be disjoint from tha list of intercourse libraries up in tha INTERFACE_LINK_LIBRARIES property.  On platforms requirin dependent shared libraries ta be found at link time CMake uses dis list ta add appropriate filez or paths ta tha link command line.  Ignored fo' non\-imported targets.

.TP
.B IMPORTED_LINK_DEPENDENT_LIBRARIES_<CONFIG>
<CONFIG>\-specific version of IMPORTED_LINK_DEPENDENT_LIBRARIES.

Configuration names correspond ta dem provided by tha project from which tha target is imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If set, dis property straight-up overrides tha generic property fo' tha named configuration.

.TP
.B IMPORTED_LINK_INTERFACE_LANGUAGES
Languages compiled tha fuck into a IMPORTED static library.

Set dis ta tha list of languagez of source filez compiled ta produce a STATIC IMPORTED library (like fuckin "C" or "CXX").  CMake accounts fo' these languages when computin how tha fuck ta link a target ta tha imported library.  For example, when a C executable links ta a imported C++ static library CMake chizzlez tha C++ linker ta satisfy language runtime dependenciez of tha static library.  


This property is ignored fo' targets dat is not STATIC libraries. Put ya muthafuckin choppers up if ya feel dis!  This property is ignored fo' non\-imported targets.

.TP
.B IMPORTED_LINK_INTERFACE_LANGUAGES_<CONFIG>
<CONFIG>\-specific version of IMPORTED_LINK_INTERFACE_LANGUAGES.

Configuration names correspond ta dem provided by tha project from which tha target is imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If set, dis property straight-up overrides tha generic property fo' tha named configuration.

.TP
.B IMPORTED_LINK_INTERFACE_LIBRARIES
Transitizzle link intercourse of a IMPORTED target.

Set dis ta tha list of libraries whose intercourse is included when a IMPORTED library target is linked ta another target.  Da libraries is ghon be included on tha link line fo' tha target.  Unlike tha LINK_INTERFACE_LIBRARIES property, dis property applies ta all imported target types, includin STATIC libraries. Put ya muthafuckin choppers up if ya feel dis!  This property is ignored fo' non\-imported targets.


This property is ignored if tha target also has a non\-empty INTERFACE_LINK_LIBRARIES property.


This property is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use INTERFACE_LINK_LIBRARIES instead.

.TP
.B IMPORTED_LINK_INTERFACE_LIBRARIES_<CONFIG>
<CONFIG>\-specific version of IMPORTED_LINK_INTERFACE_LIBRARIES.

Configuration names correspond ta dem provided by tha project from which tha target is imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If set, dis property straight-up overrides tha generic property fo' tha named configuration.


This property is ignored if tha target also has a non\-empty INTERFACE_LINK_LIBRARIES property.


This property is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use INTERFACE_LINK_LIBRARIES instead.

.TP
.B IMPORTED_LINK_INTERFACE_MULTIPLICITY
Repetizzle count fo' cyclez of IMPORTED static libraries.

This is LINK_INTERFACE_MULTIPLICITY fo' IMPORTED targets.

.TP
.B IMPORTED_LINK_INTERFACE_MULTIPLICITY_<CONFIG>
<CONFIG>\-specific version of IMPORTED_LINK_INTERFACE_MULTIPLICITY.

If set, dis property straight-up overrides tha generic property fo' tha named configuration.

.TP
.B IMPORTED_LOCATION
Full path ta tha main file on disk fo' a IMPORTED target.

Set dis ta tha location of a IMPORTED target file on disk.  For executablez dis is tha location of tha executable file.  For bundlez on OS X dis is tha location of tha executable file inside Contents/MacOS under tha application bundle folda n' shit.  For static libraries n' modulez dis is tha location of tha library or module.  For shared libraries on non\-DLL platforms dis is tha location of tha shared library.  For frameworks on OS X dis is tha location of tha library file symlink just inside tha framework folda n' shit.  For DLLs dis is tha location of tha ".dll" part of tha library.  For UNKNOWN libraries dis is tha location of tha file ta be linked. Y'all KNOW dat shit, muthafucka!  Ignored fo' non\-imported targets.


Projects may skip IMPORTED_LOCATION if tha configuration\-specific property IMPORTED_LOCATION_<CONFIG> is set.  To git tha location of a imported target read one of tha LOCATION or LOCATION_<CONFIG> properties.

.TP
.B IMPORTED_LOCATION_<CONFIG>
<CONFIG>\-specific version of IMPORTED_LOCATION property.

Configuration names correspond ta dem provided by tha project from which tha target is imported.

.TP
.B IMPORTED_NO_SONAME
Specifies dat a IMPORTED shared library target has no "soname".  

Set dis property ta legit fo' a imported shared library file dat has no "soname" field. Y'all KNOW dat shit, muthafucka!  CMake may adjust generated link commandz fo' some platforms ta prevent tha linker from rockin tha path ta tha library up in place of its missin soname.  Ignored fo' non\-imported targets.

.TP
.B IMPORTED_NO_SONAME_<CONFIG>
<CONFIG>\-specific version of IMPORTED_NO_SONAME property.

Configuration names correspond ta dem provided by tha project from which tha target is imported.

.TP
.B IMPORTED_SONAME
Da "soname" of a IMPORTED target of shared library type.

Set dis ta tha "soname" embedded up in a imported shared library.  This is meaningful only on platforms supportin tha feature.  Ignored fo' non\-imported targets.

.TP
.B IMPORTED_SONAME_<CONFIG>
<CONFIG>\-specific version of IMPORTED_SONAME property.

Configuration names correspond ta dem provided by tha project from which tha target is imported.

.TP
.B IMPORT_PREFIX
What comes before tha import library name.

Similar ta tha target property PREFIX yo, but used fo' import libraries (typically correspondin ta a DLL) instead of regular libraries fo' realz. A target property dat can be set ta override tha prefix (like fuckin "lib") on a import library name.

.TP
.B IMPORT_SUFFIX
What comes afta tha import library name.

Similar ta tha target property SUFFIX yo, but used fo' import libraries (typically correspondin ta a DLL) instead of regular libraries fo' realz. A target property dat can be set ta override tha suffix (like fuckin ".lib") on a import library name.

.TP
.B INCLUDE_DIRECTORIES
List of preprocessor include file search directories.

This property specifies tha list of directories given so far ta tha include_directories command. Y'all KNOW dat shit, muthafucka! This property exists on directories n' targets, n' you can put dat on yo' toast. In addizzle ta acceptin joints from tha include_directories command, joints may be set directly on any directory or any target rockin tha set_property command. Y'all KNOW dat shit, muthafucka! A target gets its initial value fo' dis property from tha value of tha directory property fo' realz. A directory gets its initial value from its parent directory if it has one. Both directory n' target property joints is adjusted by calls ta tha include_directories command.


Da target property joints is used by tha generators ta set tha include paths fo' tha compila n' shit.  See also tha include_directories command.


Contentz of INCLUDE_DIRECTORIES may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INSTALL_NAME_DIR
Mac OSX directory name fo' installed targets.

INSTALL_NAME_DIR be a strang specifyin tha directory portion of tha "install_name" field of shared libraries on Mac OSX ta use up in tha installed targets, n' you can put dat on yo' toast. 

.TP
.B INSTALL_RPATH
Da rpath ta use fo' installed targets.

A semicolon\-separated list specifyin tha rpath ta use up in installed targets (for platforms dat support it).  This property is initialized by tha value of tha variable CMAKE_INSTALL_RPATH if it is set when a target is pimped.

.TP
.B INSTALL_RPATH_USE_LINK_PATH
Add paths ta linker search n' installed rpath.

INSTALL_RPATH_USE_LINK_PATH be a funky-ass boolean dat if set ta legit will append directories up in tha linker search path n' outside tha project ta tha INSTALL_RPATH.  This property is initialized by tha value of tha variable CMAKE_INSTALL_RPATH_USE_LINK_PATH if it is set when a target is pimped.

.TP
.B INTERFACE_COMPILE_DEFINITIONS
List of hood compile definitions fo' a library.

Targets may populate dis property ta publish tha compile definitions required ta compile against tha headaz fo' tha target.  Consumin targets can add entries ta they own COMPILE_DEFINITIONS property like fuckin $<TARGET_PROPERTY:foo,INTERFACE_COMPILE_DEFINITIONS> ta use tha compile definitions specified up in tha intercourse of 'foo'.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INTERFACE_COMPILE_OPTIONS
List of intercourse options ta pass ta tha compiler.

Targets may populate dis property ta publish tha compile options required ta compile against tha headaz fo' tha target.  Consumin targets can add entries ta they own COMPILE_OPTIONS property like fuckin $<TARGET_PROPERTY:foo,INTERFACE_COMPILE_OPTIONS> ta use tha compile options specified up in tha intercourse of 'foo'.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INTERFACE_INCLUDE_DIRECTORIES
List of hood include directories fo' a library.

Targets may populate dis property ta publish tha include directories required ta compile against tha headaz fo' tha target.  Consumin targets can add entries ta they own INCLUDE_DIRECTORIES property like fuckin $<TARGET_PROPERTY:foo,INTERFACE_INCLUDE_DIRECTORIES> ta use tha include directories specified up in tha intercourse of 'foo'.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INTERFACE_LINK_LIBRARIES
List hood intercourse libraries fo' a library.

This property gotz nuff tha list of transitizzle link dependencies. Put ya muthafuckin choppers up if ya feel dis!  When tha target is linked tha fuck into another target tha libraries listed (and recursively they link intercourse libraries) is ghon be provided ta tha other target also.  This property is overridden by tha LINK_INTERFACE_LIBRARIES or LINK_INTERFACE_LIBRARIES_<CONFIG> property if policy CMP0022 is OLD or unset.





Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INTERFACE_POSITION_INDEPENDENT_CODE
Whether thugs need ta create a position\-independent target

Da INTERFACE_POSITION_INDEPENDENT_CODE property informs thugz of dis target whether they must set they POSITION_INDEPENDENT_CODE property ta ON.  If dis property is set ta ON, then tha POSITION_INDEPENDENT_CODE property on all thugs is ghon be set ta ON.  Similarly, if dis property is set ta OFF, then tha POSITION_INDEPENDENT_CODE property on all thugs is ghon be set ta OFF.  If dis property is undefined, then thugs will determine they POSITION_INDEPENDENT_CODE property by other means.  Consumers must ensure dat tha targets dat they link ta git a cold-ass lil consistent requirement fo' they INTERFACE_POSITION_INDEPENDENT_CODE property.

.TP
.B INTERFACE_SYSTEM_INCLUDE_DIRECTORIES
List of hood system include directories fo' a library.

Targets may populate dis property ta publish tha include directories which contain system headers, n' therefore should not result up in compila warnings.  Consumin targets will then mark tha same include directories as system headers.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B INTERPROCEDURAL_OPTIMIZATION
Enable interprocedural optimization fo' a target.

If set ta true, enablez interprocedural optimizations if they is known ta be supported by tha compiler.

.TP
.B INTERPROCEDURAL_OPTIMIZATION_<CONFIG>
Per\-configuration interprocedural optimization fo' a target.

This be a per\-configuration version of INTERPROCEDURAL_OPTIMIZATION.  If set, dis property overrides tha generic property fo' tha named configuration.

.TP
.B LABELS
Specify a list of text labels associated wit a target.

Target label semantics is currently unspecified.

.TP
.B LIBRARY_OUTPUT_DIRECTORY
Output directory up in which ta build LIBRARY target files.

This property specifies tha directory tha fuck into which library target filez should be built. Multi\-configuration generators (VS, Xcode) append a per\-configuration subdirectory ta tha specified directory.  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.  This property is initialized by tha value of tha variable CMAKE_LIBRARY_OUTPUT_DIRECTORY if it is set when a target is pimped.

.TP
.B LIBRARY_OUTPUT_DIRECTORY_<CONFIG>
Per\-configuration output directory fo' LIBRARY target files.

This be a per\-configuration version of LIBRARY_OUTPUT_DIRECTORY yo, but multi\-configuration generators (VS, Xcode) do NOT append a per\-configuration subdirectory ta tha specified directory.  This property is initialized by tha value of tha variable CMAKE_LIBRARY_OUTPUT_DIRECTORY_<CONFIG> if it is set when a target is pimped.

.TP
.B LIBRARY_OUTPUT_NAME
Output name fo' LIBRARY target files.

This property specifies tha base name fo' library target files. Well shiiiit, it overrides OUTPUT_NAME n' OUTPUT_NAME_<CONFIG> properties. Put ya muthafuckin choppers up if ya feel dis!  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.

.TP
.B LIBRARY_OUTPUT_NAME_<CONFIG>
Per\-configuration output name fo' LIBRARY target files.

This is tha configuration\-specific version of LIBRARY_OUTPUT_NAME.

.TP
.B LINKER_LANGUAGE
Specifies language whose compila will invoke tha linker.

For executables, shared libraries, n' modules, dis sets tha language whose compila is used ta link tha target (like fuckin "C" or "CXX").  A typical value fo' a executable is tha language of tha source file providin tha program entry point (main).  If not set, tha language wit tha highest linker preference value is tha default.  See documentation of CMAKE_<LANG>_LINKER_PREFERENCE variables.


If dis property aint set by tha user, it is ghon be calculated at generate\-time by CMake.

.TP
.B LINK_DEPENDS
Additionizzle filez on which a target binary dependz fo' linking.

Specifies a semicolon\-separated list of full\-paths ta filez on which tha link rule fo' dis target depends.  Da target binary is ghon be linked if any of tha named filez is newer than dat shit.


This property is ignored by non\-Makefile generators.  It be intended ta specify dependencies on "linker scripts" fo' custom Makefile link rules.

.TP
.B LINK_DEPENDS_NO_SHARED
Do not depend on linked shared library files.

Set dis property ta legit ta tell CMake generators not ta add file\-level dependencies on tha shared library filez linked by dis target.  Modification ta tha shared libraries aint gonna be sufficient ta re\-link dis target.  Logical target\-level dependencies aint gonna be affected so tha linked shared libraries will still be brought up ta date before dis target is built.


This property is initialized by tha value of tha variable CMAKE_LINK_DEPENDS_NO_SHARED if it is set when a target is pimped.

.TP
.B LINK_FLAGS
Additionizzle flags ta use when linkin dis target.

Da LINK_FLAGS property can be used ta add extra flags ta tha link step of a target. LINK_FLAGS_<CONFIG> will add ta tha configuration <CONFIG>, fo' example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. 

.TP
.B LINK_FLAGS_<CONFIG>
Per\-configuration linker flags fo' a target.

This is tha configuration\-specific version of LINK_FLAGS.

.TP
.B LINK_INTERFACE_LIBRARIES
List hood intercourse libraries fo' a gangbangin' finger-lickin' dirty-ass shared library or executable.

By default linkin ta a gangbangin' finger-lickin' dirty-ass shared library target transitively links ta targets wit which tha library itself was linked. Y'all KNOW dat shit, muthafucka!  For a executable wit exports (see tha ENABLE_EXPORTS property) no default transitizzle link dependencies is used. Y'all KNOW dat shit, muthafucka!  This property replaces tha default transitizzle link dependencies wit a explicit list.  When tha target is linked tha fuck into another target tha libraries listed (and recursively they link intercourse libraries) is ghon be provided ta tha other target also.  If tha list is empty then no transitizzle link dependencies is ghon be incorporated when dis target is linked tha fuck into another target even if tha default set is non\-empty.  This property is initialized by tha value of tha variable CMAKE_LINK_INTERFACE_LIBRARIES if it is set when a target is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This property is ignored fo' STATIC libraries.


This property is overridden by tha INTERFACE_LINK_LIBRARIES property if policy CMP0022 is NEW.


This property is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use INTERFACE_LINK_LIBRARIES instead.

.TP
.B LINK_INTERFACE_LIBRARIES_<CONFIG>
Per\-configuration list of hood intercourse libraries fo' a target.

This is tha configuration\-specific version of LINK_INTERFACE_LIBRARIES.  If set, dis property straight-up overrides tha generic property fo' tha named configuration.


This property is overridden by tha INTERFACE_LINK_LIBRARIES property if policy CMP0022 is NEW.


This property is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use INTERFACE_LINK_LIBRARIES instead.

.TP
.B LINK_INTERFACE_MULTIPLICITY
Repetizzle count fo' STATIC libraries wit cyclic dependencies.

When linkin ta a STATIC library target wit cyclic dependencies tha linker may need ta scan mo' than once all up in tha archives up in tha straight fuckin connected component of tha dependency graph.  CMake by default constructs tha link line so dat tha linker will scan all up in tha component at least twice.  This property specifies tha minimum number of scans if it is larger than tha default.  CMake uses tha phattest value specified by any target up in a cold-ass lil component.

.TP
.B LINK_INTERFACE_MULTIPLICITY_<CONFIG>
Per\-configuration repetizzle count fo' cyclez of STATIC libraries.

This is tha configuration\-specific version of LINK_INTERFACE_MULTIPLICITY.  If set, dis property straight-up overrides tha generic property fo' tha named configuration.

.TP
.B LINK_LIBRARIES
List of direct link dependencies.

This property specifies tha list of libraries or targets which is ghon be used fo' linking. In addizzle ta acceptin joints from tha target_link_libraries command, joints may be set directly on any target rockin tha set_property command. Y'all KNOW dat shit, muthafucka! 


Da target property joints is used by tha generators ta set tha link libraries fo' tha compila n' shit.  See also tha target_link_libraries command.


Contentz of LINK_LIBRARIES may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B LINK_SEARCH_END_STATIC
End a link line such dat static system libraries is used.

Some linkers support switches like fuckin \-Bstatic n' \-Bdynamic ta determine whether ta use static or shared libraries fo' \-lXXX options.  CMake uses these options ta set tha link type fo' libraries whose full paths is not known or (in some cases) is up in implicit link directories fo' tha platform.  By default CMake addz a option all up in tha end of tha library list (if necessary) ta set tha linker search type back ta its startin type.  This property switches tha final linker search type ta \-Bstatic regardless of how tha fuck it started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See also LINK_SEARCH_START_STATIC.

.TP
.B LINK_SEARCH_START_STATIC
Assume tha linker looks fo' static libraries by default.

Some linkers support switches like fuckin \-Bstatic n' \-Bdynamic ta determine whether ta use static or shared libraries fo' \-lXXX options.  CMake uses these options ta set tha link type fo' libraries whose full paths is not known or (in some cases) is up in implicit link directories fo' tha platform.  By default tha linker search type be assumed ta be \-Bdynamic all up in tha beginnin of tha library list.  This property switches tha assumption ta \-Bstatic.  It be intended fo' use when linkin a executable statically (e.g. wit tha GNU \-static option).  See also LINK_SEARCH_END_STATIC.

.TP
.B LOCATION
Read\-only location of a target on disk.

For a imported target, dis read\-only property returns tha value of tha LOCATION_<CONFIG> property fo' a unspecified configuration <CONFIG> provided by tha target.


For a non\-imported target, dis property is provided fo' compatibilitizzle wit CMake 2.4 n' below.  Dat shiznit was meant ta git tha location of a executable targetz output file fo' use up in add_custom_command. Y'all KNOW dat shit, muthafucka!  Da path may contain a funky-ass build\-system\-specific portion dat is replaced at build time wit tha configuration gettin built (like fuckin "$(ConfigurationName)" up in VS). In CMake 2.6 n' above add_custom_command automatically recognizes a target name up in its COMMAND n' DEPENDS options n' computes tha target location. I aint talkin' bout chicken n' gravy biatch.  In CMake 2.8.4 n' above add_custom_command recognizes generator expressions ta refer ta target locations anywhere up in tha command. Y'all KNOW dat shit, muthafucka!  Therefore dis property aint needed fo' bustin custom commands.


Do not set propertizzles dat affect tha location of a target afta readin dis property.  These include propertizzles whose names match "(RUNTIME|LIBRARY|ARCHIVE)_OUTPUT_(NAME|DIRECTORY)(_<CONFIG>)?", "(IMPLIB_)?(PREFIX|SUFFIX)", or "LINKER_LANGUAGE".  Failure ta follow dis rule aint diagnosed n' leaves tha location of tha target undefined.

.TP
.B LOCATION_<CONFIG>
Read\-only property providin a target location on disk.

A read\-only property dat indicates where a targetz main file is located on disk fo' tha configuration <CONFIG>.  Da property is defined only fo' library n' executable targets, n' you can put dat on yo' toast.  An imported target may provide a set of configurations different from dat of tha importin project.  By default CMake looks fo' a exact\-match but otherwise uses a arbitrary available configuration. I aint talkin' bout chicken n' gravy biatch.  Use tha MAP_IMPORTED_CONFIG_<CONFIG> property ta map imported configurations explicitly.


Do not set propertizzles dat affect tha location of a target afta readin dis property.  These include propertizzles whose names match "(RUNTIME|LIBRARY|ARCHIVE)_OUTPUT_(NAME|DIRECTORY)(_<CONFIG>)?", "(IMPLIB_)?(PREFIX|SUFFIX)", or "LINKER_LANGUAGE".  Failure ta follow dis rule aint diagnosed n' leaves tha location of tha target undefined.

.TP
.B MACOSX_BUNDLE
Build a executable as a application bundle on Mac OS X.

When dis property is set ta legit tha executable when built on Mac OS X is ghon be pimped as a application bundle.  This make it a GUI executable dat can be launched from tha Finder n' shit.  See tha MACOSX_BUNDLE_INFO_PLIST target property fo' shiznit bout creation of tha Info.plist file fo' tha application bundle.  This property is initialized by tha value of tha variable CMAKE_MACOSX_BUNDLE if it is set when a target is pimped.

.TP
.B MACOSX_BUNDLE_INFO_PLIST
Specify a cold-ass lil custom Info.plist template fo' a Mac OS X App Bundle.

An executable target wit MACOSX_BUNDLE enabled is ghon be built as a application bundle on Mac OS X.  By default its Info.plist file is pimped by configurin a template called MacOSXBundleInfo.plist.in located up in tha CMAKE_MODULE_PATH.  This property specifies a alternatizzle template file name which may be a gangbangin' full path.


Da followin target propertizzles may be set ta specify content ta be configured tha fuck into tha file:


.nf
  MACOSX_BUNDLE_INFO_STRING
  MACOSX_BUNDLE_ICON_FILE
  MACOSX_BUNDLE_GUI_IDENTIFIER
  MACOSX_BUNDLE_LONG_VERSION_STRING
  MACOSX_BUNDLE_BUNDLE_NAME
  MACOSX_BUNDLE_SHORT_VERSION_STRING
  MACOSX_BUNDLE_BUNDLE_VERSION
  MACOSX_BUNDLE_COPYRIGHT
.fi

CMake variablez of tha same name may be set ta affect all targets up in a gangbangin' finger-lickin' directory dat aint gots each specific property set.  If a cold-ass lil custom Info.plist is specified by dis property it may of course hard\-code all tha settings instead of rockin tha target properties.

.TP
.B MACOSX_FRAMEWORK_INFO_PLIST
Specify a cold-ass lil custom Info.plist template fo' a Mac OS X Framework.

A library target wit FRAMEWORK enabled is ghon be built as a gangbangin' framework on Mac OS X.  By default its Info.plist file is pimped by configurin a template called MacOSXFrameworkInfo.plist.in located up in tha CMAKE_MODULE_PATH.  This property specifies a alternatizzle template file name which may be a gangbangin' full path.


Da followin target propertizzles may be set ta specify content ta be configured tha fuck into tha file:


.nf
  MACOSX_FRAMEWORK_ICON_FILE
  MACOSX_FRAMEWORK_IDENTIFIER
  MACOSX_FRAMEWORK_SHORT_VERSION_STRING
  MACOSX_FRAMEWORK_BUNDLE_VERSION
.fi

CMake variablez of tha same name may be set ta affect all targets up in a gangbangin' finger-lickin' directory dat aint gots each specific property set.  If a cold-ass lil custom Info.plist is specified by dis property it may of course hard\-code all tha settings instead of rockin tha target properties.

.TP
.B MACOSX_RPATH
Whether ta use rpaths on Mac OS X.

When dis property is set ta true, tha directory portion of the"install_name" field of shared libraries will default ta "@rpath".Runtime paths will also be embedded up in binaries rockin dis target.This property is initialized by tha value of tha variable CMAKE_MACOSX_RPATH if it is set when a target is pimped.

.TP
.B MAP_IMPORTED_CONFIG_<CONFIG>
Map from project configuration ta IMPORTED targetz configuration.

Set dis ta tha list of configurationz of a imported target dat may be used fo' tha current projectz <CONFIG> configuration. I aint talkin' bout chicken n' gravy biatch.  Targets imported from another project may not provide tha same set of configuration names available up in tha current project.  Settin dis property  drops some lyrics ta CMake what tha fuck imported configurations is suitable fo' use when buildin tha <CONFIG> configuration. I aint talkin' bout chicken n' gravy biatch.  Da first configuration up in tha list found ta be provided by tha imported target is selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If dis property is set n' no matchin configurations is available, then tha imported target is considered ta be not found. Y'all KNOW dat shit, muthafucka!  This property is ignored fo' non\-imported targets.

.TP
.B NAME
Logical name fo' tha target.

Read\-only logical name fo' tha target as used by CMake.

.TP
.B NO_SONAME
Whether ta set "soname" when linkin a gangbangin' finger-lickin' dirty-ass shared library or module.

Enable dis boolean property if a generated shared library or module should not have "soname" set. Default is ta set "soname" on all shared libraries n' modulez as long as tha platform supports dat shit. Generally, use dis property only fo' leaf private libraries or plugins. If you use it on aiiight shared libraries which other targets link against, on some platforms a linker will bang a gangbangin' full path ta tha library (as specified at link time) tha fuck into tha dynamic section of tha dependent binary. Therefore, once installed, dynamic loader may eventually fail ta locate tha library fo' tha binary.

.TP
.B OSX_ARCHITECTURES
Target specific architectures fo' OS X.

Da OSX_ARCHITECTURES property sets tha target binary architecture fo' targets on OS X.  This property is initialized by tha value of tha variable CMAKE_OSX_ARCHITECTURES if it is set when a target is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use OSX_ARCHITECTURES_<CONFIG> ta set tha binary architectures on a per\-configuration basis.  <CONFIG> be a upper\-case name (ex: "OSX_ARCHITECTURES_DEBUG").

.TP
.B OSX_ARCHITECTURES_<CONFIG>
Per\-configuration OS X binary architectures fo' a target.

This property is tha configuration\-specific version of OSX_ARCHITECTURES.

.TP
.B OUTPUT_NAME
Output name fo' target files.

This sets tha base name fo' output filez pimped fo' a executable or library target.  If not set, tha logical target name is used by default.

.TP
.B OUTPUT_NAME_<CONFIG>
Per\-configuration target file base name.

This is tha configuration\-specific version of OUTPUT_NAME.

.TP
.B PDB_NAME
Output name fo' MS debug symbols .pdb file from linker.

Set tha base name fo' debug symbols file pimped fo' a executable or shared library target.  If not set, tha logical target name is used by default.  


This property aint implemented by tha Visual Studio 6 generator.

.TP
.B PDB_NAME_<CONFIG>
Per\-configuration name fo' MS debug symbols .pdb file.  

This is tha configuration\-specific version of PDB_NAME.  


This property aint implemented by tha Visual Studio 6 generator.

.TP
.B PDB_OUTPUT_DIRECTORY
Output directory fo' MS debug symbols .pdb file from linker.

This property specifies tha directory tha fuck into which tha MS debug symbols is ghon be placed by tha linker n' shit.  This property is initialized by tha value of tha variable CMAKE_PDB_OUTPUT_DIRECTORY if it is set when a target is pimped.


This property aint implemented by tha Visual Studio 6 generator.

.TP
.B PDB_OUTPUT_DIRECTORY_<CONFIG>
Per\-configuration output directory fo' MS debug symbols .pdb files.

This be a per\-configuration version of PDB_OUTPUT_DIRECTORY yo, but multi\-configuration generators (VS, Xcode) do NOT append a per\-configuration subdirectory ta tha specified directory. This property is initialized by tha value of tha variable CMAKE_PDB_OUTPUT_DIRECTORY_<CONFIG> if it is set when a target is pimped.


This property aint implemented by tha Visual Studio 6 generator.

.TP
.B POSITION_INDEPENDENT_CODE
Whether ta create a position\-independent target

Da POSITION_INDEPENDENT_CODE property determines whether posizzle independent executablez or shared libraries is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This property is legit by default fo' SHARED n' MODULE library targets n' false otherwise.  This property is initialized by tha value of tha variable CMAKE_POSITION_INDEPENDENT_CODE if it is set when a target is pimped.

.TP
.B POST_INSTALL_SCRIPT
Deprecated install support.

Da PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT propertizzles is tha oldschool way ta specify CMake scripts ta run before n' afta installin a target.  They is used only when tha oldschool INSTALL_TARGETS command is used ta install tha target.  Use tha INSTALL command instead.

.TP
.B PREFIX
What comes before tha library name.

A target property dat can be set ta override tha prefix (like fuckin "lib") on a library name.

.TP
.B PRE_INSTALL_SCRIPT
Deprecated install support.

Da PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT propertizzles is tha oldschool way ta specify CMake scripts ta run before n' afta installin a target.  They is used only when tha oldschool INSTALL_TARGETS command is used ta install tha target.  Use tha INSTALL command instead.

.TP
.B PRIVATE_HEADER
Specify private header filez up in a FRAMEWORK shared library target.

Shared library targets marked wit tha FRAMEWORK property generate frameworks on OS X n' aiiight shared libraries on other platforms.  This property may be set ta a list of header filez ta be placed up in tha PrivateHeadaz directory inside tha framework folda n' shit.  On non\-Applez platforms these headaz may be installed rockin tha PRIVATE_HEADER option ta tha install(TARGETS) command.

.TP
.B PROJECT_LABEL
Change tha name of a target up in a IDE.

Can be used ta chizzle tha name of tha target up in a IDE like Visual Studio. 

.TP
.B PUBLIC_HEADER
Specify hood header filez up in a FRAMEWORK shared library target.

Shared library targets marked wit tha FRAMEWORK property generate frameworks on OS X n' aiiight shared libraries on other platforms.  This property may be set ta a list of header filez ta be placed up in tha Headaz directory inside tha framework folda n' shit.  On non\-Applez platforms these headaz may be installed rockin tha PUBLIC_HEADER option ta tha install(TARGETS) command.

.TP
.B RESOURCE
Specify resource filez up in a FRAMEWORK shared library target.

Shared library targets marked wit tha FRAMEWORK property generate frameworks on OS X n' aiiight shared libraries on other platforms.  This property may be set ta a list of filez ta be placed up in tha Resources directory inside tha framework folda n' shit.  On non\-Applez platforms these filez may be installed rockin tha RESOURCE option ta tha install(TARGETS) command.

.TP
.B RULE_LAUNCH_COMPILE
Specify a launcher fo' compile rules.

See tha global property of tha same name fo' details.  This overrides tha global n' directory property fo' a target.

.TP
.B RULE_LAUNCH_CUSTOM
Specify a launcher fo' custom rules.

See tha global property of tha same name fo' details.  This overrides tha global n' directory property fo' a target.

.TP
.B RULE_LAUNCH_LINK
Specify a launcher fo' link rules.

See tha global property of tha same name fo' details.  This overrides tha global n' directory property fo' a target.

.TP
.B RUNTIME_OUTPUT_DIRECTORY
Output directory up in which ta build RUNTIME target files.

This property specifies tha directory tha fuck into which runtime target filez should be built. Multi\-configuration generators (VS, Xcode) append a per\-configuration subdirectory ta tha specified directory.  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.  This property is initialized by tha value of tha variable CMAKE_RUNTIME_OUTPUT_DIRECTORY if it is set when a target is pimped.

.TP
.B RUNTIME_OUTPUT_DIRECTORY_<CONFIG>
Per\-configuration output directory fo' RUNTIME target files.

This be a per\-configuration version of RUNTIME_OUTPUT_DIRECTORY yo, but multi\-configuration generators (VS, Xcode) do NOT append a per\-configuration subdirectory ta tha specified directory.  This property is initialized by tha value of tha variable CMAKE_RUNTIME_OUTPUT_DIRECTORY_<CONFIG> if it is set when a target is pimped.

.TP
.B RUNTIME_OUTPUT_NAME
Output name fo' RUNTIME target files.

This property specifies tha base name fo' runtime target files.  It overrides OUTPUT_NAME n' OUTPUT_NAME_<CONFIG> properties. Put ya muthafuckin choppers up if ya feel dis!  There is three kindz of target filez dat may be built: archive, library, n' runtime.  Executablez is always treated as runtime targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Static libraries is always treated as archive targets, n' you can put dat on yo' toast. Module libraries is always treated as library targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as library targets, n' you can put dat on yo' toast. For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a runtime target n' tha correspondin import library is treated as a archive target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms.

.TP
.B RUNTIME_OUTPUT_NAME_<CONFIG>
Per\-configuration output name fo' RUNTIME target files.

This is tha configuration\-specific version of RUNTIME_OUTPUT_NAME.

.TP
.B SKIP_BUILD_RPATH
Should rpaths be used fo' tha build tree.

SKIP_BUILD_RPATH be a funky-ass boolean specifyin whether ta skip automatic generation of a rpath allowin tha target ta run from tha build tree.  This property is initialized by tha value of tha variable CMAKE_SKIP_BUILD_RPATH if it is set when a target is pimped.

.TP
.B SOURCES
Source names specified fo' a target.

Read\-only list of sources specified fo' a target.  Da names returned is suitable fo' passin ta tha set_source_files_propertizzles command.

.TP
.B SOVERSION
What version number is dis target.

For shared libraries VERSION n' SOVERSION can be used ta specify tha build version n' API version respectively. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks n' tha linker supports so\-names. If only one of both is specified tha missin be assumed ta have tha same version number n' shit. Right back up in yo muthafuckin ass. SOVERSION is ignored if NO_SONAME property is set. For shared libraries n' executablez on Windows tha VERSION attribute is parsed ta extract a "major.minor" version number n' shit. These numbers is used as tha image version of tha binary. 

.TP
.B STATIC_LIBRARY_FLAGS
Extra flags ta use when linkin static libraries.

Extra flags ta use when linkin a static library.

.TP
.B STATIC_LIBRARY_FLAGS_<CONFIG>
Per\-configuration flags fo' bustin a static library.

This is tha configuration\-specific version of STATIC_LIBRARY_FLAGS.

.TP
.B SUFFIX
What comes afta tha target name.

A target property dat can be set ta override tha suffix (like fuckin ".so" or ".exe") on tha name of a library, module or executable.

.TP
.B TYPE
Da type of tha target.

This read\-only property can be used ta test tha type of tha given target. Well shiiiit, it is ghon be one of STATIC_LIBRARY, MODULE_LIBRARY, SHARED_LIBRARY, EXECUTABLE or one of tha internal target types.

.TP
.B VERSION
What version number is dis target.

For shared libraries VERSION n' SOVERSION can be used ta specify tha build version n' API version respectively. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks n' tha linker supports so\-names. If only one of both is specified tha missin be assumed ta have tha same version number n' shit. For executablez VERSION can be used ta specify tha build version. I aint talkin' bout chicken n' gravy biatch. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks. For shared libraries n' executablez on Windows tha VERSION attribute is parsed ta extract a "major.minor" version number n' shit. These numbers is used as tha image version of tha binary. 

.TP
.B VISIBILITY_INLINES_HIDDEN
Whether ta add a cold-ass lil compile flag ta hide symbolz of inline functions

Da VISIBILITY_INLINES_HIDDEN property determines whether a gangbangin' flag fo' hidin symbols fo' inline functions. tha value passed used up in a visibilitizzle related compile option, like fuckin \-fvisibility=.  This property only has a affect fo' libraries n' executablez wit exports, n' you can put dat on yo' toast.  This property is initialized by tha value of tha variable CMAKE_VISIBILITY_INLINES_HIDDEN if it is set when a target is pimped.

.TP
.B VS_DOTNET_REFERENCES
Visual Studio managed project .NET references

Addz one or mo' semicolon\-delimited .NET references ta a generated Visual Studio project. For example, "System;System.Windows.Forms".

.TP
.B VS_DOTNET_TARGET_FRAMEWORK_VERSION
Specify tha .NET target framework version.

Used ta specify tha .NET target framework version fo' C++/CLI. For example, "v4.5".

.TP
.B VS_GLOBAL_<variable>
Visual Studio project\-specific global variable.

Tell tha Visual Studio generator ta set tha global variable '<variable>' ta a given value up in tha generated Visual Studio project. Ignored on other generators. Qt integration works betta if VS_GLOBAL_QtVersion is set ta tha version FindQt4.cmake found. Y'all KNOW dat shit, muthafucka! For example, "4.7.3"

.TP
.B VS_GLOBAL_KEYWORD
Visual Studio project keyword.

Sets tha "keyword" attribute fo' a generated Visual Studio project. Defaults ta "Win32Proj". Yo ass may wish ta override dis value wit "ManagedCProj", fo' example, up in a Visual Studio managed C++ unit test project.

.TP
.B VS_GLOBAL_PROJECT_TYPES
Visual Studio project type(s).

Can be set ta one or mo' UUIDs recognized by Visual Studio ta indicate tha type of project. This value is copied verbatim tha fuck into tha generated project file. Example fo' a managed C++ unit testin project:


.nf
 {3AC096D0\-A1C2\-E12C\-1390\-A8335801FDAB};{8BC9CEB8\-8B4A\-11D0\-8D11\-00A0C91BC942}
.fi

UUIDs is semicolon\-delimited.

.TP
.B VS_GLOBAL_ROOTNAMESPACE
Visual Studio project root namespace.

Sets tha "RootNamespace" attribute fo' a generated Visual Studio project.  Da attribute is ghon be generated only if dis is set.

.TP
.B VS_KEYWORD
Visual Studio project keyword.

Can be set ta chizzle tha visual basement keyword, fo' example Qt integration works betta if dis is set ta Qt4VSv1.0. 

.TP
.B VS_SCC_AUXPATH
Visual Studio Source Code Control Aux Path.

Can be set ta chizzle tha visual basement source code control auxpath property.

.TP
.B VS_SCC_LOCALPATH
Visual Studio Source Code Control Local Path.

Can be set ta chizzle tha visual basement source code control local path property.

.TP
.B VS_SCC_PROJECTNAME
Visual Studio Source Code Control Project.

Can be set ta chizzle tha visual basement source code control project name property.

.TP
.B VS_SCC_PROVIDER
Visual Studio Source Code Control Provider.

Can be set ta chizzle tha visual basement source code control provider property.

.TP
.B VS_WINRT_EXTENSIONS
Visual Studio project C++/CX language extensions fo' Windows Runtime

Can be set ta enable C++/CX language extensions.

.TP
.B VS_WINRT_REFERENCES
Visual Studio project Windows Runtime Metadata references

Addz one or mo' semicolon\-delimited WinRT references ta a generated Visual Studio project. For example, "Windows;Windows.UI.Core".

.TP
.B WIN32_EXECUTABLE
Build a executable wit a WinMain entry point on windows.

When dis property is set ta legit tha executable when linked on Windows is ghon be pimped wit a WinMain() entry point instead of just main().  This make it a GUI executable instead of a cold-ass lil console application. I aint talkin' bout chicken n' gravy biatch.  See tha CMAKE_MFC_FLAG variable documentation ta configure use of MFC fo' WinMain executables.  This property is initialized by tha value of tha variable CMAKE_WIN32_EXECUTABLE if it is set when a target is pimped.

.TP
.B XCODE_ATTRIBUTE_<an-attribute>
Set Xcode target attributes directly.

Tell tha Xcode generator ta set '<an\-attribute>' ta a given value up in tha generated Xcode project.  Ignored on other generators.

.SH PROPERTIES ON TESTS
.TP
.B ATTACHED_FILES
Attach a list of filez ta a thugged-out dashboard submission.

Set dis property ta a list of filez dat is ghon be encoded n' submitted ta tha dashboard as a addizzle ta tha test result.

.TP
.B ATTACHED_FILES_ON_FAIL
Attach a list of filez ta a thugged-out dashboard submission if tha test fails.

Same as ATTACHED_FILES yo, but these filez will only be included if tha test do not pass.

.TP
.B COST
Set dis ta a gangbangin' floatin point value. Tests up in a test set is ghon be run up in descendin order of cost.

This property raps bout tha cost of a test. Yo ass can explicitly set dis value; tests wit higher COST joints will run first.

.TP
.B DEPENDS
Specifies dat dis test should only be run afta tha specified list of tests.

Set dis ta a list of tests dat must finish before dis test is run.

.TP
.B ENVIRONMENT
Specify environment variablez dat should be defined fo' hustlin a test.

If set ta a list of environment variablez n' jointz of tha form MYVAR=value dem environment variablez is ghon be defined while hustlin tha test. Da environment is restored ta its previous state afta tha test is done.

.TP
.B FAIL_REGULAR_EXPRESSION
If tha output matches dis regular expression tha test will fail.

If set, if tha output matches one of specified regular expressions, tha test will fail.For example: FAIL_REGULAR_EXPRESSION "[^a\-z]Error;ERROR;Failed"

.TP
.B LABELS
Specify a list of text labels associated wit a test.

Da list is reported up in dashboard submissions.

.TP
.B MEASUREMENT
Specify a CDASH measurement n' value ta be reported fo' a test.

If set ta a name then dat name is ghon be reported ta CDASH as a named measurement wit a value of 1. Yo ass may also specify a value by settin MEASUREMENT ta "measurement=value".

.TP
.B PASS_REGULAR_EXPRESSION
Da output must match dis regular expression fo' tha test ta pass.

If set, tha test output is ghon be checked against tha specified regular expressions n' at least one of tha regular expressions has ta match, otherwise tha test will fail.

.TP
.B PROCESSORS
How tha fuck nuff process slots dis test requires

Denotes tha number of processors dat dis test will require. This is typically used fo' MPI tests, n' should be used up in conjunction wit tha ctest_test PARALLEL_LEVEL option.

.TP
.B REQUIRED_FILES
List of filez required ta run tha test.

If set ta a list of files, tha test aint gonna be run unless all of tha filez exist.

.TP
.B RESOURCE_LOCK
Specify a list of resources dat is locked by dis test.

If multiple tests specify tha same resource lock, they is guaranteed not ta run concurrently.

.TP
.B RUN_SERIAL
Do not run dis test up in parallel wit any other test.

Use dis option up in conjunction wit tha ctest_test PARALLEL_LEVEL option ta specify dat dis test should not be run up in parallel wit any other tests.

.TP
.B TIMEOUT
How tha fuck nuff secondz ta allow fo' dis test.

This property if set will limit a test ta not take mo' than tha specified number of secondz ta run. I aint talkin' bout chicken n' gravy biatch. If it exceedz dat tha test process is ghon be capped n' ctest will move ta tha next test. This settin takes precedence over CTEST_TESTING_TIMEOUT.

.TP
.B WILL_FAIL
If set ta true, dis will invert tha pass/fail flag of tha test.

This property can be used fo' tests dat is sposed ta fuckin fail n' return a non zero return code.

.TP
.B WORKING_DIRECTORY
Da directory from which tha test executable is ghon be called.

If dis aint set it is called from tha directory tha test executable is located in.

.SH PROPERTIES ON SOURCE FILES
.TP
.B ABSTRACT
Is dis source file a abstract class.

A property on a source file dat indicates if tha source file represents a cold-ass lil class dat be abstract. This only make sense fo' languages dat gotz a notion of a abstract class n' it is only used by some tools dat wrap classes tha fuck into other languages.

.TP
.B COMPILE_DEFINITIONS
Preprocessor definitions fo' compilin a source file.

Da COMPILE_DEFINITIONS property may be set ta a semicolon\-separated list of preprocessor definitions rockin tha syntax VAR or VAR=value.  Function\-style definitions is not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  CMake will automatically escape tha value erectly fo' tha natizzle build system (note dat CMake language syntax may require escapes ta specify some joints).  This property may be set on a per\-configuration basis rockin tha name COMPILE_DEFINITIONS_<CONFIG> where <CONFIG> be a upper\-case name (ex. "COMPILE_DEFINITIONS_DEBUG").


CMake will automatically drop some definitions dat is not supported by tha natizzle build tool.  Da VS6 IDE do not support definizzle joints wit spaces (but NMake do).  Xcode do not support per\-configuration definitions on source files.


Disclaimer: Most natizzle build tools have skanky support fo' escapin certain joints, n' you can put dat on yo' toast.  CMake has work\-aroundz fo' nuff cases but some joints may just not be possible ta pass erectly.  If a value do not seem ta be escaped erectly, do not attempt ta work\-around tha problem by addin escape sequences ta tha value.  Yo crazy-ass work\-around may break up in a gangbangin' future version of CMake dat has improved escape support.  Instead consider definin tha macro up in a (configured) header file.  Then report tha limitation. I aint talkin' bout chicken n' gravy biatch.  Known limitations include:


.nf
  #          \- fucked up almost everywhere
  ;          \- fucked up in VS IDE 7.0 n' Borland Makefiles
  ,          \- fucked up in VS IDE
  %          \- fucked up in some cases up in NMake
  & |        \- fucked up in some cases on MinGW
  ^ < > \\"   \- fucked up in most Make tools on Windows
.fi

CMake do not reject these joints outright cuz they do work up in some cases.  Use wit caution. I aint talkin' bout chicken n' gravy biatch.  

.TP
.B COMPILE_DEFINITIONS_<CONFIG>
Per\-configuration preprocessor definitions on a source file.

This is tha configuration\-specific version of COMPILE_DEFINITIONS.  Note dat Xcode do not support per\-configuration source file flags so dis property is ghon be ignored by tha Xcode generator.

.TP
.B COMPILE_FLAGS
Additionizzle flags ta be added when compilin dis source file.

These flags is ghon be added ta tha list of compile flags when dis source file builds.  Use COMPILE_DEFINITIONS ta pass additionizzle preprocessor definitions.

.TP
.B EXTERNAL_OBJECT
If set ta legit then dis be a object file.

If dis property is set ta legit then tha source file is straight-up a object file n' should not be compiled. Y'all KNOW dat shit, muthafucka!  It will still be linked tha fuck into tha target though.

.TP
.B Fortran_FORMAT
Set ta FIXED or FREE ta indicate tha Fortran source layout.

This property  drops some lyrics ta CMake whether a given Fortran source file uses fixed\-format or free\-format.  CMake will pass tha correspondin format flag ta tha compila n' shit.  Consider rockin tha target\-wide Fortran_FORMAT property if all source filez up in a target share tha same format.

.TP
.B GENERATED
Is dis source file generated as part of tha build process.

If a source file is generated by tha build process CMake will handle it differently up in termz of dependency checkin etc. Otherwise havin a non\-existent source file could create problems.

.TP
.B HEADER_FILE_ONLY
Is dis source file only a header file.

A property on a source file dat indicates if tha source file be a header file wit no associated implementation. I aint talkin' bout chicken n' gravy biatch. This is set automatically based on tha file extension n' is used by CMake ta determine if certain dependency shiznit should be computed.

.TP
.B KEEP_EXTENSION
Make tha output file have tha same extension as tha source file.

If dis property is set then tha file extension of tha output file is ghon be tha same as dat of tha source file. Normally tha output file extension is computed based on tha language of tha source file, fo' example .cxx will git all up in a .o extension.

.TP
.B LABELS
Specify a list of text labels associated wit a source file.

This property has meanin only when tha source file is listed up in a target whose LABELS property be also set.  No other semantics is currently specified.

.TP
.B LANGUAGE
What programmin language is tha file.

A property dat can be set ta indicate what tha fuck programmin language tha source file is. If it aint set tha language is determined based on tha file extension. I aint talkin' bout chicken n' gravy biatch. Typical joints is CXX C etc. Right back up in yo muthafuckin ass. Settin dis property fo' a gangbangin' file means dis file is ghon be compiled. Y'all KNOW dat shit, muthafucka! Do not set dis fo' headaz or filez dat should not be compiled.

.TP
.B LOCATION
Da full path ta a source file.

A read only property on a SOURCE FILE dat gotz nuff tha full path ta tha source file.

.TP
.B MACOSX_PACKAGE_LOCATION
Place a source file inside a Mac OS X bundle, CFBundle, or framework.

Executable targets wit tha MACOSX_BUNDLE property set is built as Mac OS X application bundlez on Applez platforms.  Shared library targets wit tha FRAMEWORK property set is built as Mac OS X frameworks on Applez platforms.  Module library targets wit tha BUNDLE property set is built as Mac OS X CFBundle bundlez on Applez platforms.  Source filez listed up in tha target wit dis property set is ghon be copied ta a gangbangin' finger-lickin' directory inside tha bundle or framework content folda specified by tha property value.  For bundlez tha content folda is "<name>.app/Contents".  For frameworks tha content folda is "<name>.framework/Versions/<version>".  For cfbundlez tha content folda is "<name>.bundle/Contents" (unless tha extension is chizzled).  See tha PUBLIC_HEADER, PRIVATE_HEADER, n' RESOURCE target propertizzles fo' specifyin filez meant fo' Headers, PrivateHeaders, or Resources directories.

.TP
.B OBJECT_DEPENDS
Additionizzle filez on which a cold-ass lil compiled object file depends.

Specifies a semicolon\-separated list of full\-paths ta filez on which any object filez compiled from dis source file depend yo, but it ain't no stoppin cause I be still poppin'.  An object file is ghon be recompiled if any of tha named filez is newer than dat shit.


This property need not be used ta specify tha dependency of a source file on a generated header file dat it includes.  Although tha property was originally introduced fo' dis purpose, it is no longer necessary.  If tha generated header file is pimped by a cold-ass lil custom command up in tha same target as tha source file, tha automatic dependency scannin process will recognize tha dependency.  If tha generated header file is pimped by another target, a inter\-target dependency should be pimped wit tha add_dependencies command (if one do not already exist cuz of linkin relationshizzles).

.TP
.B OBJECT_OUTPUTS
Additionizzle outputs fo' a Makefile rule.

Additionizzle outputs pimped by compilation of dis source file. If any of these outputs is missin tha object is ghon be recompiled. Y'all KNOW dat shit, muthafucka! This is supported only on Makefile generators n' is ghon be ignored on other generators.

.TP
.B SYMBOLIC
Is dis just a name fo' a rule.

If SYMBOLIC (boolean) is set ta legit tha build system is ghon be informed dat tha source file aint straight-up pimped on disk but instead used as a symbolic name fo' a funky-ass build rule.

.TP
.B WRAP_EXCLUDE
Exclude dis source file from any code wrappin steez.

Some packages can wrap source filez tha fuck into alternate languages ta provide additionizzle functionality. For example, C++ code can be wrapped tha fuck into Java or Python etc rockin SWIG etc. If WRAP_EXCLUDE is set ta legit (1 etc) dat indicates dat dis source file should not be wrapped.

.SH PROPERTIES ON CACHE ENTRIES
.TP
.B ADVANCED
True if entry should be hidden by default up in GUIs.

This be a funky-ass boolean value indicatin whether tha entry is considered bangin-ass only fo' advanced configuration. I aint talkin' bout chicken n' gravy biatch.  Da mark_as_advanced() command modifies dis property.

.TP
.B HELPSTRING
Help associated wit entry up in GUIs.

This strang summarizes tha purpose of a entry ta help playas set it all up in a CMake GUI.

.TP
.B MODIFIED
Internal pimpment property.  Do not set or get.

This be a internal cache entry property managed by CMake ta track interactizzle user modification of entries. Put ya muthafuckin choppers up if ya feel dis!  Ignore dat shit.

.TP
.B STRINGS
Enumerate possible STRING entry joints fo' GUI selection.

For cache entries wit type STRING, dis enumerates a set of joints, n' you can put dat on yo' toast.  CMake GUIs may use dis ta provide a selection widget instead of a generic strang entry field. Y'all KNOW dat shit, muthafucka!  This is fo' convenience only.  CMake do not enforce dat tha value matches one of dem listed.

.TP
.B TYPE
Widget type fo' entry up in GUIs.

Cache entry joints is always strings yo, but CMake GUIs present widgets ta help playas set joints, n' you can put dat on yo' toast.  Da GUIs use dis property as a hint ta determine tha widget type.  Valid TYPE joints are:


.nf
  BOOL          = Boolean ON/OFF value.
  PATH          = Path ta a gangbangin' finger-lickin' directory.
  FILEPATH      = Path ta a gangbangin' file.
  STRING        = Generic strang value.
  INTERNAL      = Do not present up in GUI at all.
  STATIC        = Value managed by CMake, do not chizzle.
  UNINITIALIZED = Type not yet specified.
.fi

Generally tha TYPE of a cold-ass lil cache entry should be set by tha command which creates it (set, option, find_library, etc.).

.TP
.B VALUE
Value of a cold-ass lil cache entry.

This property maps ta tha actual value of a cold-ass lil cache entry.  Settin dis property always sets tha value without checking, so use wit care.

.SH COMPATIBILITY COMMANDS
.PP
.nf
  CMake Compatibilitizzle Listfile Commandz \- Obsolete commandz supported by CMake fo' compatibility.
.fi

.PP
This is tha documentation fo' now obsolete listfile commandz from previous CMake versions, which is still supported fo' compatibilitizzle reasons. Yo ass should instead use tha newer, fasta n' shinier freshly smoked up commands. ;\-)

.TP
.B build_name
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use ${CMAKE_SYSTEM} n' ${CMAKE_CXX_COMPILER} instead.

.nf
  build_name(variable)
.fi

Sets tha specified variable ta a strang representin tha platform n' compila settings.  These joints is now available all up in tha CMAKE_SYSTEM n' CMAKE_CXX_COMPILER variables.

.TP
.B exec_program
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha execute_process() command instead.

Run a executable program durin tha processin of tha CMakeList.txt file.


.nf
  exec_program(Executable [directory up in which ta run]
               [ARGS <arguments ta executable>]
               [OUTPUT_VARIABLE <var>]
               [RETURN_VALUE <var>])
.fi

Da executable is run up in tha optionally specified directory.  Da executable can include arguments if it is double quoted yo, but it is betta ta use tha optionizzle ARGS argument ta specify arguments ta tha program.   This is cuz cmake will then be able ta escape spaces up in tha executable path.  An optionizzle argument OUTPUT_VARIABLE specifies a variable up in which ta store tha output. To capture tha return value of tha execution, provide a RETURN_VALUE. If OUTPUT_VARIABLE is specified, then no output will git all up in tha stdout/stderr of tha console hustlin cmake.


.TP
.B export_library_dependencies
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use INSTALL(EXPORT) or EXPORT command.

This command generates a old\-style library dependencies file.  Projects requirin CMake 2.6 or lata should not use tha command. Y'all KNOW dat shit, muthafucka!  Use instead tha install(EXPORT) command ta help export targets from a installation tree n' tha export() command ta export targets from a funky-ass build tree.


Da old\-style library dependencies file do not take tha fuck into account per\-configuration namez of libraries or tha LINK_INTERFACE_LIBRARIES target property.


.nf
  export_library_dependencies(<file> [APPEND])
.fi

Smoke a gangbangin' file named <file> dat can be included tha fuck into a CMake listfile wit tha INCLUDE command. Y'all KNOW dat shit, muthafucka!  Da file will contain a fuckin shitload of SET commandz dat will set all tha variablez needed fo' library dependency shiznit. I aint talkin' bout chicken n' gravy biatch.  This should be tha last command up in tha top level CMakeLists.txt file of tha project.  If tha APPEND option is specified, tha SET commandz is ghon be appended ta tha given file instead of replacin dat shit.

.TP
.B install_files
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha install(FILES ) command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.  Da FILES form is directly replaced by tha FILES form of tha install command. Y'all KNOW dat shit, muthafucka!  Da regexp form can be expressed mo' clearly rockin tha GLOB form of tha file command.


.nf
  install_files(<dir> extension file file ...)
.fi

Smoke rulez ta install tha listed filez wit tha given extension tha fuck into tha given directory.  Only filez existin up in tha current source tree or its correspondin location up in tha binary tree may be listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If a gangbangin' file specified already has a extension, dat extension is ghon be removed first.  This is useful fo' providin listz of source filez like fuckin foo.cxx when you want tha correspondin foo.h ta be installed. Y'all KNOW dat shit, muthafucka! A typical extension is '.h'.


.nf
  install_files(<dir> regexp)
.fi

Any filez up in tha current source directory dat match tha regular expression is ghon be installed.


.nf
  install_files(<dir> FILES file file ...)
.fi

Any filez listed afta tha FILES keyword is ghon be installed explicitly from tha names given. I aint talkin' bout chicken n' gravy biatch.  Full paths is allowed up in dis form.


Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX.

.TP
.B install_programs
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha install(PROGRAMS ) command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.  Da FILES form is directly replaced by tha PROGRAMS form of tha INSTALL command. Y'all KNOW dat shit, muthafucka!  Da regexp form can be expressed mo' clearly rockin tha GLOB form of tha FILE command.


.nf
  install_programs(<dir> file1 file2 [file3 ...])
  install_programs(<dir> FILES file1 [file2 ...])
.fi

Smoke rulez ta install tha listed programs tha fuck into tha given directory. Use tha FILES argument ta guarantee dat tha file list version of tha command is ghon be used even when there is only one argument.


.nf
  install_programs(<dir> regexp)
.fi

In tha second form any program up in tha current source directory dat matches tha regular expression is ghon be installed.


This command is intended ta install programs dat is not built by cmake, like fuckin shell scripts, n' you can put dat on yo' toast.  See tha TARGETS form of tha INSTALL command ta create installation rulez fo' targets built by cmake.


Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX.

.TP
.B install_targets
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha install(TARGETS )  command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.


.nf
  install_targets(<dir> [RUNTIME_DIRECTORY dir] target target)
.fi

Smoke rulez ta install tha listed targets tha fuck into tha given directory.  Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX. If RUNTIME_DIRECTORY is specified, then on systems wit special runtime filez (Windows DLL), tha filez is ghon be copied ta dat directory.

.TP
.B link_libraries
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha target_link_libraries() command instead.

Link libraries ta all targets added later.


.nf
  link_libraries(library1 <debug | optimized> library2 ...)
.fi

Specify a list of libraries ta be linked tha fuck into any followin targets (typically added wit tha add_executable or add_library calls).  This command is passed down ta all subdirectories. Put ya muthafuckin choppers up if ya feel dis!  Da debug n' optimized strings may be used ta indicate dat tha next library listed is ta be used only fo' dat specific type of build.

.TP
.B make_directory
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(MAKE_DIRECTORY ) command instead.

.nf
  make_directory(directory)
.fi

Creates tha specified directory.  Full paths should be given. I aint talkin' bout chicken n' gravy biatch.  Any parent directories dat do not exist will also be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use wit care.

.TP
.B output_required_files
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Approximate C preprocessor dependency scanning.

This command exists only cuz ancient CMake versions provided dat shit.  CMake handlez preprocessor dependency scannin automatically rockin a mo' advanced scanner.


.nf
  output_required_files(srcfile outputfile)
.fi

Outputs a list of all tha source filez dat is required by tha specified srcfile. This list is freestyled tha fuck into outputfile. This is similar ta freestylin up tha dependencies fo' srcfile except dat it jumps from .h filez tha fuck into .cxx, .c n' .cpp filez if possible.

.TP
.B remove
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha list(REMOVE_ITEM ) command instead.

.nf
  remove(VAR VALUE VALUE ...)
.fi

Removes VALUE from tha variable VAR.  This is typically used ta remove entries from a vector (e.g. semicolon separated list).  VALUE is expanded.

.TP
.B subdir_depends
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Do nothing.

.nf
  subdir_depends(subdir dep1 dep2 ...)
.fi

Do not do anything.  This command used ta help projects order parallel buildz erectly.  This functionalitizzle is now automatic.

.TP
.B subdirs
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha add_subdirectory() command instead.

Add a list of subdirectories ta tha build.


.nf
  subdirs(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...]
          [PREORDER] )
.fi

Add a list of subdirectories ta tha build. Y'all KNOW dat shit, muthafucka! Da add_subdirectory command should be used instead of subdirs although subdirs will still work. This will cause any CMakeLists.txt filez up in tha sub directories ta be processed by CMake.  Any directories afta tha PREORDER flag is traversed first by makefile builds, tha PREORDER flag has no effect on IDE projects, n' you can put dat on yo' toast.  Any directories afta tha EXCLUDE_FROM_ALL marker aint gonna be included up in tha top level makefile or project file. This is useful fo' havin CMake create makefilez or projects fo' a set of examplez up in a project. Yo ass would want CMake ta generate makefilez or project filez fo' all tha examplez all up in tha same time yo, but you would not want dem ta show up in tha top level project or be built each time make is run from tha top.

.TP
.B use_mangled_mesa
Copy mesa headaz fo' use up in combination wit system GL.

.nf
  use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)
.fi

Da path ta mesa includes, should contain gl_mangle.h.  Da mesa headaz is copied ta tha specified output directory.  This allows mangled mesa headaz ta override other GL headaz by bein added ta tha include directory path earlier.

.TP
.B utility_source
Specify tha source tree of a third\-party utility.

.nf
  utility_source(cache_entry executable_name
                 path_to_source [file1 file2 ...])
.fi

When a third\-party utilityz source is included up in tha distribution, dis command specifies its location n' name.  Da cache entry aint gonna be set unless tha path_to_source n' all listed filez exist.  It be assumed dat tha source tree of tha utilitizzle gonna git been built before it is needed.


When cross compilin CMake will print a warnin if a utility_source() command is executed, cuz up in nuff cases it is used ta build a executable which is executed lata on. I aint talkin' bout chicken n' gravy biatch. This don't work when cross compiling, since tha executable can run only on they target platform. Right back up in yo muthafuckin ass. So up in dis case tha cache entry has ta be adjusted manually so it points ta a executable which is runnable on tha build host.

.TP
.B variable_requires
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha if() command instead.

Assert satisfaction of a optionz required variables.


.nf
  variable_requires(TEST_VARIABLE RESULT_VARIABLE
                    REQUIRED_VARIABLE1
                    REQUIRED_VARIABLE2 ...)
.fi

Da first argument (TEST_VARIABLE) is tha name of tha variable ta be tested, if dat variable is false not a god damn thang else is done. If TEST_VARIABLE is true, then tha next argument (RESULT_VARIABLE) be a variable dat is set ta legit if all tha required variablez is set. Da rest of tha arguments is variablez dat must be legit or not set ta NOTFOUND ta avoid a error. Shiiit, dis aint no joke.  If any is not true, a error is reported.

.TP
.B write_file
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(WRITE ) command instead.

.nf
  write_file(filename "message ta write"... [APPEND])
.fi

Da first argument is tha file name, tha rest of tha arguments is lyrics ta write. If tha argument APPEND is specified, then tha message is ghon be appended.


NOTE 1: file(WRITE ... n' file(APPEND ... do exactly tha same as dis one but add some mo' functionality.


NOTE 2: When rockin write_file tha produced file cannot be used as a input ta CMake (CONFIGURE_FILE, source file ...) cuz it will lead ta a infinite loop. Use configure_file if you wanna generate input filez ta CMake.

.SH MODULES
.PP
Da followin modulez is provided wit CMake. They can be used wit INCLUDE(ModuleName).

.PP
.nf
  CMake Modulez \- Modulez comin wit CMake, tha Cross\-Platform Makefile Generator.
.fi

.PP
This is tha documentation fo' tha modulez n' scripts comin wit CMake. Usin these modulez you can check tha computa system fo' installed software packages, featurez of tha compila n' tha existence of headaz ta name just a gangbangin' few.

.TP
.B AddFileDependencies
ADD_FILE_DEPENDENCIES(source_file depend_files...)

Addz tha given filez as dependencies ta source_file


.TP
.B BundleUtilities
Functions ta help assemble a standalone bundle application.

A collection of CMake utilitizzle functions useful fo' dealin wit .app bundlez on tha Mac n' bundle\-like directories on any OS.


Da followin functions is provided by dis module:


.nf
   fixup_bundle
   copy_and_fixup_bundle
   verify_app
   get_bundle_main_executable
   get_dotapp_dir
   get_bundle_and_executable
   get_bundle_all_executables
   get_item_key
   clear_bundle_keys
   set_bundle_key_values
   get_bundle_keys
   copy_resolved_item_into_bundle
   copy_resolved_framework_into_bundle
   fixup_bundle_item
   verify_bundle_prerequisites
   verify_bundle_symlinks
.fi

Requires CMake 2.6 or pimped outa cuz it uses function, break n' PARENT_SCOPE fo' realz. Also dependz on GetPrerequisites.cmake.


.nf
  FIXUP_BUNDLE(<app> <libs> <dirs>)
.fi

Fix up a funky-ass bundle in\-place n' make it standalone, such dat it can be drag\-n\-drop copied ta another machine n' run on dat machine as long as all of tha system libraries is compatible.


If you pass plugins ta fixup_bundle as tha libs parameter, you should install dem or copy dem tha fuck into tha bundle before callin fixup_bundle. Da "libs" parameta be a list of libraries dat must be fixed up yo, but dat cannot be determined by otool output analysis. (i.e., plugins)


Gather all tha keys fo' all tha executablez n' libraries up in a funky-ass bundle, n' then, fo' each key, copy each prerequisite tha fuck into tha bundle. Then fix each one up accordin ta its own list of prerequisites.


Then clear all tha keys n' call verify_app on tha final bundle ta ensure dat it is truly standalone.


.nf
  COPY_AND_FIXUP_BUNDLE(<src> <dst> <libs> <dirs>)
.fi

Makes a cold-ass lil copy of tha bundle <src> at location <dst> n' then fixes up tha freshly smoked up copied bundle in\-place at <dst>...


.nf
  VERIFY_APP(<app>)
.fi

Verifies dat a application <app> appears valid based on hustlin analysis tools on dat shit. Calls "message(FATAL_ERROR" if tha application aint verified.


.nf
  GET_BUNDLE_MAIN_EXECUTABLE(<bundle> <result_var>)
.fi

Da result is ghon be tha full path name of tha bundlez main executable file or a "error:" prefixed strang if it could not be determined.


.nf
  GET_DOTAPP_DIR(<exe> <dotapp_dir_var>)
.fi

Returns tha nearest parent dir whose name endz wit ".app" given tha full path ta a executable. If there is no such parent dir, then simply return tha dir containin tha executable.


Da returned directory may or may not exist.


.nf
  GET_BUNDLE_AND_EXECUTABLE(<app> <bundle_var> <executable_var> <valid_var>)
.fi

Takes either a ".app" directory name or tha name of a executable nested inside a ".app" directory n' returns tha path ta tha ".app" directory up in <bundle_var> n' tha path ta its main executable up in <executable_var>


.nf
  GET_BUNDLE_ALL_EXECUTABLES(<bundle> <exes_var>)
.fi

Scans tha given bundle recursively fo' all executable filez n' accumulates dem tha fuck into a variable.


.nf
  GET_ITEM_KEY(<item> <key_var>)
.fi

Given a gangbangin' file (item) name, generate a key dat should be unique thankin bout tha set of libraries dat need copyin or fixin up ta cook up a funky-ass bundle standalone. This is essentially tha file name includin extension wit "." replaced by "_"


This key is used as a prefix fo' CMake variablez so dat we can associate a set of variablez wit a given item based on its key.


.nf
  CLEAR_BUNDLE_KEYS(<keys_var>)
.fi

Loop over tha list of keys, clearin all tha variablez associated wit each key fo' realz. Afta tha loop, clear tha list of keys itself.


Calla of get_bundle_keys should call clear_bundle_keys when done wit list of keys.


.nf
  SET_BUNDLE_KEY_VALUES(<keys_var> <context> <item> <exepath> <dirs>
                        <copyflag>)
.fi

Add a key ta tha list (if necessary) fo' tha given item. If added, also set all tha variablez associated wit dat key.


.nf
  GET_BUNDLE_KEYS(<app> <libs> <dirs> <keys_var>)
.fi

Loop over all tha executable n' library filez within tha bundle (and given as extra <libs>) n' accumulate a list of keys representin em. Right back up in yo muthafuckin ass. Set joints associated wit each key such dat we can loop over all of dem n' copy prerequisite libs tha fuck into tha bundle n' then do appropriate install_name_tool fixups.


.nf
  COPY_RESOLVED_ITEM_INTO_BUNDLE(<resolved_item> <resolved_embedded_item>)
.fi

Copy a resolved item tha fuck into tha bundle if necessary. Copy aint necessary if tha resolved_item is "the same as" tha resolved_embedded_item.


.nf
  COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE(<resolved_item> <resolved_embedded_item>)
.fi

Copy a resolved framework tha fuck into tha bundle if necessary. Copy aint necessary if tha resolved_item is "the same as" tha resolved_embedded_item.


By default, BU_COPY_FULL_FRAMEWORK_CONTENTS aint set. If you want full frameworks embedded up in yo' bundles, set BU_COPY_FULL_FRAMEWORK_CONTENTS ta ON before callin fixup_bundle. By default, COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE copies tha framework dylib itself plus tha framework Resources directory.


.nf
  FIXUP_BUNDLE_ITEM(<resolved_embedded_item> <exepath> <dirs>)
.fi

Git tha direct/non\-system prerequisitez of tha resolved embedded item. For each prerequisite, chizzle tha way it is referenced ta tha value of tha _EMBEDDED_ITEM keyed variable fo' dat prerequisite. (Most likely changin ta a "@executable_path" steez reference.)


This function requires dat tha resolved_embedded_item be "inside" tha bundle already. In other lyrics, if you pass plugins ta fixup_bundle as tha libs parameter, you should install dem or copy dem tha fuck into tha bundle before callin fixup_bundle. Da "libs" parameta be a list of libraries dat must be fixed up yo, but dat cannot be determined by otool output analysis. (i.e., plugins)


Also, chizzle tha id of tha item bein fixed up ta its own _EMBEDDED_ITEM value.


Accumulate chizzlez up in a local variable n' make *one* call ta install_name_tool all up in tha end of tha function wit all tha chizzlez at once.


If tha BU_CHMOD_BUNDLE_ITEMS variable is set then bundle shit is ghon be marked writable before install_name_tool tries ta chizzle em.


.nf
  VERIFY_BUNDLE_PREREQUISITES(<bundle> <result_var> <info_var>)
.fi

Verifies dat tha sum of all prerequisitez of all filez inside tha bundle is contained within tha bundle or is "system" libraries, presumed ta exist all over dis biiiatch.


.nf
  VERIFY_BUNDLE_SYMLINKS(<bundle> <result_var> <info_var>)
.fi

Verifies dat any symlinks found up in tha bundle point ta other filez dat is already also up in tha bundle.. fo' realz. Anythang dat points ta a external file causes dis function ta fail tha verification.

.TP
.B CMakeAddFortranSubdirectory
Use MinGW gfortran from VS if a gangbangin' fortran compila aint found.

Da 'add_fortran_subdirectory' function addz a subdirectory ta a project dat gotz nuff a gangbangin' fortran only sub\-project. Da module will check tha current compila n' peep if it can support fortran. I aint talkin' bout chicken n' gravy biatch. If no fortran compila is found n' tha compila is MSVC, then dis module will find tha MinGW gfortran. I aint talkin' bout chicken n' gravy biatch.  It will then use a external project ta build wit tha MinGW tools.  It will also create imported targets fo' tha libraries pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This will only work if tha fortran code is built tha fuck into a thugged-out dll, so BUILD_SHARED_LIBS is turned on up in tha project.  In addizzle tha CMAKE_GNUtoMS option is set ta on, so dat tha MS .lib filez is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Usage be as bigs up:


.nf
  cmake_add_fortran_subdirectory(
   <subdir>                # name of subdirectory
   PROJECT <project_name>  # project name up in subdir top CMakeLists.txt
   ARCHIVE_DIR <dir>       # dir where project places .lib files
   RUNTIME_DIR <dir>       # dir where project places .dll files
   LIBRARIES <lib>...      # namez of library targets ta import
   LINK_LIBRARIES          # link intercourse libraries fo' LIBRARIES
    [LINK_LIBS <lib> <dep>...]...
   CMAKE_COMMAND_LINE ...  # extra command line flags ta pass ta cmake
   NO_EXTERNAL_INSTALL     # skip installation of external project
   )
.fi

Relatizzle paths up in ARCHIVE_DIR n' RUNTIME_DIR is interpreted wit respect ta tha build directory correspondin ta tha source directory up in which tha function is invoked.


Limitations:


NO_EXTERNAL_INSTALL is required fo' forward compatibilitizzle wit a gangbangin' future version dat supports installation of tha external project binaries durin "make install".

.TP
.B CMakeBackwardCompatibilityCXX
define a funky-ass bunch of backwardz compatibilitizzle variables

.nf
  CMAKE_ANSI_CXXFLAGS \- flag fo' ansi c++
  CMAKE_HAS_ANSI_STRING_STREAM \- has <strstream>
  include(TestForANSIStreamHeaders)
  include(CheckIncludeFileCXX)
  include(TestForSTDNamespace)
  include(TestForANSIForScope)
.fi

.TP
.B CMakeDependentOption
Macro ta provide a option dependent on other options.

This macro presents a option ta tha user only if a set of other conditions is true.  When tha option aint presented a thugged-out default value is used yo, but any value set by tha user is preserved fo' when tha option is presented again. I aint talkin' bout chicken n' gravy biatch. Example invocation:


.nf
  CMAKE_DEPENDENT_OPTION(USE_FOO "Use Foo" ON
                         "USE_BAR;NOT USE_ZOT" OFF)
.fi

If USE_BAR is legit n' USE_ZOT is false, dis serves up a option called USE_FOO dat defaults ta ON.  Otherwise, it sets USE_FOO ta OFF.  If tha statuz of USE_BAR or USE_ZOT eva chizzles, any value fo' tha USE_FOO option is saved so dat when tha option is re\-enabled it retains its oldschool value.

.TP
.B CMakeDetermineVSServicePack
Determine tha Visual Studio steez ounce ta tha bounce of tha 'cl' up in use.

Da functionalitizzle of dis module has been superseded by tha platform variable CMAKE_<LANG>_COMPILER_VERSION dat gotz nuff tha compila version number.


Usage:


.nf
  if(MSVC)
    include(CMakeDetermineVSServicePack)
    DetermineVSServicePack( my_service_pack )
    if( my_service_pack )
      message(STATUS "Detected: ${my_service_pack}")
    endif()
  endif()
.fi

Function DetermineVSServicePack sets tha given variable ta one of tha followin joints or a empty strang if unknown:


.nf
  vc80, vc80sp1
  vc90, vc90sp1
  vc100, vc100sp1
  vc110, vc110sp1, vc110sp2
.fi

.TP
.B CMakeExpandImportedTargets
.nf
 
.fi

CMAKE_EXPAND_IMPORTED_TARGETS(<var> LIBRARIES lib1 lib2...libN


.nf
                                     [CONFIGURATION <config>] )
.fi




CMAKE_EXPAND_IMPORTED_TARGETS() takes a list of libraries n' replaces all imported targets contained up in dis list wit they actual file pathz of tha referenced libraries on disk, includin tha libraries from they link intercourses. If a CONFIGURATION is given, it uses tha respectizzle configuration of tha imported targets if it exists, n' you can put dat on yo' toast. If no CONFIGURATION is given, it uses tha straight-up original gangsta configuration from ${CMAKE_CONFIGURATION_TYPES} if set, otherwise ${CMAKE_BUILD_TYPE}. This macro is used by all Check*.cmake filez which use try_compile() or try_run() n' support CMAKE_REQUIRED_LIBRARIES , so dat these checks support imported targets up in CMAKE_REQUIRED_LIBRARIES:


.nf
    cmake_expand_imported_targets(expandedLibs LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}
                                               CONFIGURATION "${CMAKE_TRY_COMPILE_CONFIGURATION}" )
.fi

.TP
.B CMakeFindFrameworks
helper module ta find OSX frameworks

.TP
.B CMakeFindPackageMode
.nf
 
.fi

This file is executed by cmake when invoked wit \-\-find\-package. Well shiiiit, it expects dat tha followin variablez is set rockin \-D:


.nf
   NAME = name of tha package
   COMPILER_ID = tha CMake compila ID fo' which tha result is, i.e. GNU/Intel/Clang/MSVC, etc.
   LANGUAGE = language fo' which tha result is ghon be used, i.e. C/CXX/Fortan/ASM
   MODE = EXIST : only check fo' existence of tha given package
          COMPILE : print tha flags needed fo' compilin a object file which uses tha given package
          LINK : print tha flags needed fo' linkin when rockin tha given package
   QUIET = if TRUE, don't print anything
.fi

.TP
.B CMakeForceCompiler
.nf
 
.fi

This module defines macros intended fo' use by cross\-compilin toolchain filez when CMake aint able ta automatically detect tha compila identification.


Macro CMAKE_FORCE_C_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_C_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_C_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_C_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


Macro CMAKE_FORCE_CXX_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_CXX_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_CXX_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_CXX_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


Macro CMAKE_FORCE_Fortran_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_Fortran_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_Fortran_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_Fortran_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


So a simple toolchain file could be lookin like this:


.nf
   include (CMakeForceCompiler)
   set(CMAKE_SYSTEM_NAME Generic)
   CMAKE_FORCE_C_COMPILER   (chc12 MetrowerksHicross)
   CMAKE_FORCE_CXX_COMPILER (chc12 MetrowerksHicross)
.fi

.TP
.B CMakeGraphVizOptions
Da builtin graphviz support of CMake.

CMake can generate graphviz files, showin tha dependencies between tha targets up in a project n' also external libraries which is linked against. When CMake is run wit tha \-\-graphiz=foo option, it will produce


.nf
    * a gangbangin' foo.dot file showin all dependencies up in tha project
    * a gangbangin' foo.dot.<target> file fo' each target, file showin on which other targets tha respectizzle target depends
    * a gangbangin' foo.dot.<target>.dependaz file, showin which other targets depend on tha respectizzle target
.fi




This can result up in big-ass graphs. Usin tha file CMakeGraphVizOptions.cmake tha look n' content of tha generated graphs can be influenced. Y'all KNOW dat shit, muthafucka! This file is searched first up in ${CMAKE_BINARY_DIR} n' then up in ${CMAKE_SOURCE_DIR}. If found, it is read n' tha variablez set up in it is used ta adjust options fo' tha generated graphviz files.


.nf
  GRAPHVIZ_GRAPH_TYPE \- Da graph type
     Mandatory : NO
     Default   : "digraph"
  GRAPHVIZ_GRAPH_NAME \- Da graph name.
     Mandatory : NO
     Default   : "GG"
  GRAPHVIZ_GRAPH_HEADER \- Da header freestyled all up in tha top of tha graphviz file.
     Mandatory : NO
     Default   : "node [n  fontsize = "12"];"
  GRAPHVIZ_NODE_PREFIX \- Da prefix fo' each node up in tha graphviz file.
     Mandatory : NO
     Default   : "node"
  GRAPHVIZ_EXECUTABLES \- Set dis ta FALSE ta exclude executablez from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_STATIC_LIBS \- Set dis ta FALSE ta exclude static libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_SHARED_LIBS \- Set dis ta FALSE ta exclude shared libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_MODULE_LIBS \- Set dis ta FALSE ta exclude static libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_EXTERNAL_LIBS \- Set dis ta FALSE ta exclude external libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_IGNORE_TARGETS \- A list of regular expressions fo' ignorin targets.
     Mandatory : NO
     Default   : empty
.fi

.TP
.B CMakePackageConfigHelpers
CONFIGURE_PACKAGE_CONFIG_FILE(), WRITE_BASIC_PACKAGE_VERSION_FILE()




.nf
    CONFIGURE_PACKAGE_CONFIG_FILE(<input> <output> INSTALL_DESTINATION <path>
                                                   [PATH_VARS <var1> <var2> ... <varN>]
                                                   [NO_SET_AND_CHECK_MACRO]
                                                   [NO_CHECK_REQUIRED_COMPONENTS_MACRO])
.fi




CONFIGURE_PACKAGE_CONFIG_FILE() should be used instead of tha plain configure_file() command when bustin tha <Name>Config.cmake or <Name>\-config.cmake file fo' installin a project or library. Well shiiiit, it helps makin tha resultin package relocatable by avoidin hardcoded paths up in tha installed Config.cmake file.


In a FooConfig.cmake file there may be code like dis ta make tha install destinations know ta tha rockin project:


.nf
   set(FOO_INCLUDE_DIR   "@CMAKE_INSTALL_FULL_INCLUDEDIR@" )
   set(FOO_DATA_DIR   "@CMAKE_INSTALL_PREFIX@/@RELATIVE_DATA_INSTALL_DIR@" )
   set(FOO_ICONS_DIR   "@CMAKE_INSTALL_PREFIX@/share/icons" )
   ...logic ta determine installedPrefix from tha own location...
   set(FOO_CONFIG_DIR  "${installedPrefix}/@CONFIG_INSTALL_DIR@" )
.fi

All 4 options shown above is not sufficient, since tha straight-up original gangsta 3 hardcode tha absolute directory locations, n' tha 4th case works only if tha logic ta determine tha installedPrefix is erect, n' if CONFIG_INSTALL_DIR gotz nuff a relatizzle path, which up in general cannot be guaranteed. Y'all KNOW dat shit, muthafucka! This has tha effect dat tha resultin FooConfig.cmake file would work skankyly under Windows n' OSX, where playas is used ta chizzle tha install location of a funky-ass binary package at install time, independent from how tha fuck CMAKE_INSTALL_PREFIX was set at build/cmake time.


Usin CONFIGURE_PACKAGE_CONFIG_FILE() helps. If used erectly, it make tha resultin FooConfig.cmake file relocatable. Usage:


.nf
   1. write a FooConfig.cmake.in file as yo ass is used to
   2. bang a line containin only tha strang "@PACKAGE_INIT@"
   3. instead of set(FOO_DIR "@SOME_INSTALL_DIR@"), use set(FOO_DIR "@PACKAGE_SOME_INSTALL_DIR@")
      (this must be afta tha @PACKAGE_INIT@ line)
   4. instead of rockin tha aiiight configure_file(), use CONFIGURE_PACKAGE_CONFIG_FILE()
.fi




Da <input> n' <output> arguments is tha input n' output file, tha same way as up in configure_file().


Da <path> given ta INSTALL_DESTINATION must be tha destination where tha FooConfig.cmake file is ghon be installed to. This can either be a relatizzle or absolute path, both work.


Da variablez <var1> ta <varN> given as PATH_VARS is tha variablez which contain install destinations. For each of dem tha macro will create a helper variable PACKAGE_<var...>. These helper variablez must be used up in tha FooConfig.cmake.in file fo' settin tha installed location. I aint talkin' bout chicken n' gravy biatch. They is calculated by CONFIGURE_PACKAGE_CONFIG_FILE() so dat they is always relatizzle ta tha installed location of tha package. This works both fo' relatizzle n' also fo' absolute locations. For absolute locations it works only if tha absolute location be a subdirectory of CMAKE_INSTALL_PREFIX.


By default configure_package_config_file() also generates two helper macros, set_and_check() n' check_required_components() tha fuck into tha FooConfig.cmake file.


set_and_check() should be used instead of tha aiiight set() command fo' settin directories n' file locations fo' realz. Additionally ta settin tha variable it also checks dat tha referenced file or directory straight-up exists n' fails wit a FATAL_ERROR otherwise. This make shizzle dat tha pimped FooConfig.cmake file do not contain wack references. When rockin tha NO_SET_AND_CHECK_MACRO, dis macro aint generated tha fuck into tha FooConfig.cmake file.


check_required_components(<package_name>) should be called all up in tha end of tha FooConfig.cmake file if tha package supports components, n' you can put dat on yo' toast. This macro checks whether all requested, non\-optionizzle components done been found, n' if dis aint tha case, sets tha Foo_FOUND variable ta FALSE, so dat tha package is considered ta be not found. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do dat by testin tha Foo_<Component>_FOUND variablez fo' all axed required components, n' you can put dat on yo' toast. When rockin tha NO_CHECK_REQUIRED_COMPONENTS option, dis macro aint generated tha fuck into tha FooConfig.cmake file.


For a example peep below tha documentation fo' WRITE_BASIC_PACKAGE_VERSION_FILE().





.nf
  WRITE_BASIC_PACKAGE_VERSION_FILE( filename VERSION major.minor.patch COMPATIBILITY (AnyNewerVersion|SameMajorVersion|ExactVersion) )
.fi




Writes a gangbangin' file fo' use as <package>ConfigVersion.cmake file ta <filename>. Right back up in yo muthafuckin ass. See tha documentation of find_package() fo' details on all dis bullshit.


.nf
    filename is tha output filename, it should be up in tha build tree.
    major.minor.patch is tha version number of tha project ta be installed
.fi

Da COMPATIBILITY mode AnyNewerVersion means dat tha installed package version is ghon be considered compatible if it is newer or exactly tha same as tha axed version. I aint talkin' bout chicken n' gravy biatch. This mode should be used fo' packages which is straight-up backward compatible, also across major versions. If SameMajorVersion is used instead, then tha behaviour differs from AnyNewerVersion up in dat tha major version number must be tha same as requested, e.g. version 2.0 aint gonna be considered compatible if 1.0 is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This mode should be used fo' packages which guarantee backward compatibilitizzle within tha same major version. I aint talkin' bout chicken n' gravy biatch. If ExactVersion is used, then tha package is only considered compatible if tha axed version matches exactly its own version number (not thankin bout tha tweak version). For example, version 1.2.3 of a package is only considered compatible ta axed version 1.2.3. This mode is fo' packages without compatibilitizzle guarantees. If yo' project has mo' elaborated version matchin rules, yo big-ass booty is ghon need ta write yo' own custom ConfigVersion.cmake file instead of rockin dis macro.


Internally, dis macro executes configure_file() ta create tha resultin version file. Dependin on tha COMPATIBLITY, either tha file BasicConfigVersion\-SameMajorVersion.cmake.in or BasicConfigVersion\-AnyNewerVersion.cmake.in is used. Y'all KNOW dat shit, muthafucka! Please note dat these two filez is internal ta CMake n' you should not call configure_file() on dem yo ass yo, but they can be used as startin point ta create mo' sophisticted custom ConfigVersion.cmake files.





Example rockin both configure_package_config_file() n' write_basic_package_version_file(): CMakeLists.txt:


.nf
   set(INCLUDE_INSTALL_DIR include/ ... CACHE )
   set(LIB_INSTALL_DIR lib/ ... CACHE )
   set(SYSCONFIG_INSTALL_DIR etc/foo/ ... CACHE )
   ...
   include(CMakePackageConfigHelpers)
   configure_package_config_file(FooConfig.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/FooConfig.cmake
                                 INSTALL_DESTINATION ${LIB_INSTALL_DIR}/Foo/cmake
                                 PATH_VARS INCLUDE_INSTALL_DIR SYSCONFIG_INSTALL_DIR)
   write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/FooConfigVersion.cmake
                                    VERSION 1.2.3
                                    COMPATIBILITY SameMajorVersion )
   install(FILES ${CMAKE_CURRENT_BINARY_DIR}/FooConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/FooConfigVersion.cmake
           DESTINATION ${LIB_INSTALL_DIR}/Foo/cmake )
.fi




With a FooConfig.cmake.in:


.nf
   set(FOO_VERSION x.y.z)
   ...
   @PACKAGE_INIT@
   ...
   set_and_check(FOO_INCLUDE_DIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
   set_and_check(FOO_SYSCONFIG_DIR "@PACKAGE_SYSCONFIG_INSTALL_DIR@")
.fi




.nf
   check_required_components(Foo)
.fi

.TP
.B CMakeParseArguments
.nf
 
.fi

CMAKE_PARSE_ARGUMENTS(<prefix> <options> <one_value_keywords> <multi_value_keywords> args...)


CMAKE_PARSE_ARGUMENTS() is intended ta be used up in macros or functions fo' parsin tha arguments given ta dat macro or function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it processes tha arguments n' defines a set of variablez which hold tha jointz of tha respectizzle options.


Da <options> argument gotz nuff all options fo' tha respectizzle macro, i.e. keywordz which can be used when callin tha macro without any value following, like e.g. tha OPTIONAL keyword of tha install() command.


Da <one_value_keywords> argument gotz nuff all keywordz fo' dis macro which is followed by one value, like e.g. DESTINATION keyword of tha install() command.


Da <multi_value_keywords> argument gotz nuff all keywordz fo' dis macro which can be followed by mo' than one value, like e.g. tha TARGETS or FILES keywordz of tha install() command.


When done, CMAKE_PARSE_ARGUMENTS() gonna git defined fo' each of tha keywordz listed up in <options>, <one_value_keywords> n' <multi_value_keywords> a variable composed of tha given <prefix> followed by "_" n' tha name of tha respectizzle keyword. Y'all KNOW dat shit, muthafucka! These variablez will then hold tha respectizzle value from tha argument list. For tha <options> keywordz dis is ghon be TRUE or FALSE.


All remainin arguments is collected up in a variable <prefix>_UNPARSED_ARGUMENTS, dis can be checked afterwardz ta peep whether yo' macro was called wit unrecognized parameters.


As a example here a my_install() macro, which takes similar arguments as tha real install() command:


.nf
   function(MY_INSTALL)
     set(options OPTIONAL FAST)
     set(oneValueArgs DESTINATION RENAME)
     set(multiValueArgs TARGETS CONFIGURATIONS)
     cmake_parse_arguments(MY_INSTALL "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN} )
     ...
.fi




Assume my_install() has been called like this:


.nf
   my_install(TARGETS foo bar DESTINATION bin OPTIONAL blub)
.fi




Afta tha cmake_parse_arguments() call tha macro gonna git set tha followin variables:


.nf
   MY_INSTALL_OPTIONAL = TRUE
   MY_INSTALL_FAST = FALSE (this option was not used when callin my_install()
   MY_INSTALL_DESTINATION = "bin"
   MY_INSTALL_RENAME = "" (was not used)
   MY_INSTALL_TARGETS = "foo;bar"
   MY_INSTALL_CONFIGURATIONS = "" (was not used)
   MY_INSTALL_UNPARSED_ARGUMENTS = "blub" (no value expected afta "OPTIONAL"
.fi




Yo ass can then continue n' process these variables.


Keywordz terminizzle listz of joints, e.g. if directly afta a one_value_keyword another recognized keyword bigs up, dis is interpreted as tha beginnin of tha freshly smoked up option. I aint talkin' bout chicken n' gravy biatch. E.g. my_install(TARGETS foo DESTINATION OPTIONAL) would result up in MY_INSTALL_DESTINATION set ta "OPTIONAL" yo, but MY_INSTALL_DESTINATION would be empty n' MY_INSTALL_OPTIONAL would be set ta TRUE therefor.

.TP
.B CMakePrintHelpers
Convenience macros fo' printin propertizzles n' variables, useful e.g. fo' debugging.







CMAKE_PRINT_PROPERTIES([TARGETS target1 .. targetN]


.nf
                        [SOURCES source1 .. sourceN]
                        [DIRECTORIES dir1 .. dirN]
                        [TESTS test1 .. testN]
                        [CACHE_ENTRIES entry1 .. entryN]
                        PROPERTIES prop1 .. propN )
.fi




This macro prints tha jointz of tha propertizzlez of tha given targets, source files, directories, tests or cache entries. Put ya muthafuckin choppers up if ya feel dis! Exactly one of tha scope keywordz must be used. Y'all KNOW dat shit, muthafucka! Example:


.nf
   cmake_print_properties(TARGETS foo bar PROPERTIES LOCATION INTERFACE_INCLUDE_DIRS)
.fi

This will print tha LOCATION n' INTERFACE_INCLUDE_DIRS propertizzles fo' both targets foo n' bar.





CMAKE_PRINT_VARIABLES(var1 var2 .. varN)


This macro will print tha name of each variable followed by its value. Example:


.nf
   cmake_print_variables(CMAKE_C_COMPILER CMAKE_MAJOR_VERSION THIS_ONE_DOES_NOT_EXIST)
.fi

Gives:


.nf
   \-\- CMAKE_C_COMPILER="/usr/bin/gcc" ; CMAKE_MAJOR_VERSION="2" ; THIS_ONE_DOES_NOT_EXIST=""
.fi

.TP
.B CMakePrintSystemInformation
print system shiznit

This file can be used fo' diagnostic purposes just include it up in a project ta peep various internal CMake variables.

.TP
.B CMakePushCheckState
.nf
 
.fi

This module defines three macros: CMAKE_PUSH_CHECK_STATE() CMAKE_POP_CHECK_STATE() n' CMAKE_RESET_CHECK_STATE() These macros can be used ta save, restore n' reset (i.e., clear contents) tha state of tha variablez CMAKE_REQUIRED_FLAGS, CMAKE_REQUIRED_DEFINITIONS, CMAKE_REQUIRED_LIBRARIES n' CMAKE_REQUIRED_INCLUDES used by tha various Check\-filez comin wit CMake, like e.g. check_function_exists() etc. Da variable contents is pushed on a stack, pushin multiple times is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is useful e.g. when executin such tests up in a Find\-module, where they gotta be set yo, but afta tha Find\-module has been executed they should have tha same value as they had before.


CMAKE_PUSH_CHECK_STATE() macro receives optionizzle argument RESET. Whether itz specified, CMAKE_PUSH_CHECK_STATE() will set all CMAKE_REQUIRED_* variablez ta empty joints, same as CMAKE_RESET_CHECK_STATE() call will do.


Usage:


.nf
   cmake_push_check_state(RESET)
   set(CMAKE_REQUIRED_DEFINITIONS \-DSOME_MORE_DEF)
   check_function_exists(...)
   cmake_reset_check_state()
   set(CMAKE_REQUIRED_DEFINITIONS \-DANOTHER_DEF)
   check_function_exists(...)
   cmake_pop_check_state()
.fi

.TP
.B CMakeVerifyManifest
.nf
 
.fi

CMakeVerifyManifest.cmake


This script is used ta verify dat embeded manifests n' side by side manifests fo' a project match.  To run dis script, cd ta a gangbangin' finger-lickin' directory n' run tha script wit cmake \-P. On tha command line you can pass up in versions dat is OK even if not found up in tha .manifest files. For example, cmake \-Dallow_versions=8.0.50608.0 \-PCmakeVerifyManifest.cmake could be used ta allow a embeded manifest of 8.0.50608.0 ta be used up in a project even if dat version was not found up in tha .manifest file.

.TP
.B CPack
Build binary n' source package installers.

Da CPack module generates binary n' source installaz up in a variety of formats rockin tha cpack program. Inclusion of tha CPack module addz two freshly smoked up targets ta tha resultin makefiles, package n' package_source, which build tha binary n' source installers, respectively. Da generated binary installaz contain every last muthafuckin thang installed via CMakez INSTALL command (and tha deprecated INSTALL_FILES, INSTALL_PROGRAMS, n' INSTALL_TARGETS commands).


For certain kindz of binary installaz (includin tha graphical installaz on Mac OS X n' Windows), CPack generates installaz dat allow playas ta select individual application components ta install. Right back up in yo muthafuckin ass. See CPackComponent module fo' dis shit.


Da CPACK_GENERATOR variable has different meanings up in different contexts, n' you can put dat on yo' toast. In yo' CMakeLists.txt file, CPACK_GENERATOR be a *list of generators*: when run wit no other arguments, CPack will iterate over dat list n' produce one package fo' each generator. Shiiit, dis aint no joke. In a CPACK_PROJECT_CONFIG_FILE, though, CPACK_GENERATOR be a *strin namin a single generator*. If you need per\-cpack\- generator logic ta control *other* cpack settings, then you need a CPACK_PROJECT_CONFIG_FILE.


Da CMake source tree itself gotz nuff a CPACK_PROJECT_CONFIG_FILE. Right back up in yo muthafuckin ass. See tha top level file CMakeCPackOptions.cmake.in fo' a example.


If set, tha CPACK_PROJECT_CONFIG_FILE is included automatically on a per\-generator basis. Well shiiiit, it only need contain overrides.


Herez how tha fuck it works:


.nf
  \- cpack runs
  \- it includes CPackConfig.cmake
  \- it iterates over tha generators listed up in dat file's
    CPACK_GENERATOR list variable (unless holla'd at ta use just a
    specific one via \-G on tha command line...)
.fi




.nf
  \- foreach generator, it then
    \- sets CPACK_GENERATOR ta tha one currently bein iterated
    \- includes tha CPACK_PROJECT_CONFIG_FILE
    \- produces tha package fo' dat generator
.fi




This is tha key: For each generator listed up in CPACK_GENERATOR up in CPackConfig.cmake, cpack will *reset* CPACK_GENERATOR internally ta *the one currently bein used* n' then include tha CPACK_PROJECT_CONFIG_FILE.


Before includin dis CPack module up in yo' CMakeLists.txt file, there be a variety of variablez dat can be set ta customize tha resultin installers. Da most commonly\-used variablez are:


.nf
  CPACK_PACKAGE_NAME \- Da name of tha package (or application). If
  not specified, defaults ta tha project name.
.fi




.nf
  CPACK_PACKAGE_VENDOR \- Da name of tha package vendor. Shiiit, dis aint no joke. (e.g.,
  "Kitware").
.fi




.nf
  CPACK_PACKAGE_DIRECTORY \- Da directory up in which CPack is bustin its
  packaging. If it aint set then dis will default (internally) ta the
  build dir. Shiiit, dis aint no joke. This variable may be defined up in CPack config file or from
  tha cpack command line option "\-B". If set tha command line option
  override tha value found up in tha config file.
.fi




.nf
  CPACK_PACKAGE_VERSION_MAJOR \- Package major Version
.fi




.nf
  CPACK_PACKAGE_VERSION_MINOR \- Package minor Version
.fi




.nf
  CPACK_PACKAGE_VERSION_PATCH \- Package patch Version
.fi




.nf
  CPACK_PACKAGE_DESCRIPTION_FILE \- A text file used ta describe the
  project. Used, fo' example, tha introduction screen of a
  CPack\-generated Windows installa ta describe tha project.
.fi




.nf
  CPACK_PACKAGE_DESCRIPTION_SUMMARY \- Short description of the
  project (only all dem lyrics).
.fi




.nf
  CPACK_PACKAGE_FILE_NAME \- Da name of tha package file ta generate,
  not includin tha extension. I aint talkin' bout chicken n' gravy biatch. For example, cmake\-2.6.1\-Linux\-i686.
  Da default value is
.fi




.nf
  ${CPACK_PACKAGE_NAME}\-${CPACK_PACKAGE_VERSION}\-${CPACK_SYSTEM_NAME}.
.fi




.nf
  CPACK_PACKAGE_INSTALL_DIRECTORY \- Installation directory on the
  target system. This may be used by some CPack generators
  like NSIS ta create a installation directory e.g., "CMake 2.5"
  below tha installation prefix fo' realz. All installed element will be
  put inside dis directory.
.fi




.nf
   CPACK_PACKAGE_ICON \- A brandin image dat is ghon be displayed inside
   tha installa (used by GUI installers).
.fi




.nf
  CPACK_PROJECT_CONFIG_FILE \- CPack\-time project CPack configuration
  file. This file included at cpack time, once per
  generator afta CPack has set CPACK_GENERATOR ta tha actual generator
  bein used. Y'all KNOW dat shit, muthafucka! Well shiiiit, it allows per\-generator settin of CPACK_* variablez at
  cpack time.
.fi




.nf
  CPACK_RESOURCE_FILE_LICENSE \- License ta be embedded up in tha installa n' shit. It
  will typically be displayed ta tha user by tha produced installer
  (often wit a explicit "Accept" button, fo' graphical installers)
  prior ta installation. I aint talkin' bout chicken n' gravy biatch. This license file is NOT added ta installed
  file but is used by some CPack generators like NSIS. If you want
  ta install a license file (may be tha same as dis one)
  along wit yo' project you must add a appropriate CMake INSTALL
  command up in yo' CMakeLists.txt.
.fi




.nf
  CPACK_RESOURCE_FILE_README \- ReadMe file ta be embedded up in tha installa n' shit. It
  typically raps bout up in some detail tha purpose of tha project
  durin tha installation. I aint talkin' bout chicken n' gravy biatch. Not all CPack generators uses
  dis file.
.fi




.nf
  CPACK_RESOURCE_FILE_WELCOME \- Welcome file ta be embedded up in the
  installa n' shit. Well shiiiit, it welcomes playas ta dis installer.
  Typically used up in tha graphical installaz on Windows n' Mac OS X.
.fi




.nf
  CPACK_MONOLITHIC_INSTALL \- Disablez tha component\-based
  installation mechanism. When set tha component justification is ignored
  n' all installed shit is put up in a single "MONOLITHIC" package.
  Some CPack generators do monolithic packagin by default and
  may be axed ta do component packagin by setting
  CPACK_<GENNAME>_COMPONENT_INSTALL ta 1/TRUE.
.fi




.nf
  CPACK_GENERATOR \- List of CPack generators ta use. If not
  specified, CPack will create a set of options CPACK_BINARY_<GENNAME> (e.g.,
  CPACK_BINARY_NSIS) allowin tha user ta enable/disable individual
  generators. This variable may be used on tha command line
  as well as in:
.fi




.nf
    cpack \-D CPACK_GENERATOR="ZIP;TGZ" /path/to/build/tree
.fi




.nf
  CPACK_OUTPUT_CONFIG_FILE \- Da name of tha CPack binary configuration
  file. This file is tha CPack configuration generated by tha CPack module
  fo' binary installers. Defaults ta CPackConfig.cmake.
.fi




.nf
  CPACK_PACKAGE_EXECUTABLES \- Lists each of tha executablez n' associated
  text label ta be used ta create Start Menu shortcuts, n' you can put dat on yo' toast. For example,
  settin dis ta tha list ccmake;CMake will
  create a gangbangin' finger-lickin' dirty-ass shortcut named "CMake" dat will execute tha installed
  executable ccmake. Not all CPack generators use it (at least NSIS and
  OSXX11 do).
.fi




.nf
  CPACK_STRIP_FILES \- List of filez ta be stripped. Y'all KNOW dat shit, muthafucka! Startin with
  CMake 2.6.0 CPACK_STRIP_FILES is ghon be a funky-ass boolean variable which
  enablez strippin of all filez (a list of filez evaluates ta TRUE
  up in CMake, so dis chizzle is compatible).
.fi




Da followin CPack variablez is specific ta source packages, n' aint gonna affect binary packages:


.nf
  CPACK_SOURCE_PACKAGE_FILE_NAME \- Da name of tha source package. For
  example cmake\-2.6.1.
.fi




.nf
  CPACK_SOURCE_STRIP_FILES \- List of filez up in tha source tree that
  is ghon be stripped. Y'all KNOW dat shit, muthafucka! Startin wit CMake 2.6.0
  CPACK_SOURCE_STRIP_FILES is ghon be a funky-ass boolean variable which enables
  strippin of all filez (a list of filez evaluates ta TRUE up in CMake,
  so dis chizzle is compatible).
.fi




.nf
  CPACK_SOURCE_GENERATOR \- List of generators used fo' tha source
  packages fo' realz. As wit CPACK_GENERATOR, if dis aint specified then
  CPack will create a set of options (e.g., CPACK_SOURCE_ZIP)
  allowin playas ta select which packages is ghon be generated.
.fi




.nf
  CPACK_SOURCE_OUTPUT_CONFIG_FILE \- Da name of tha CPack source
  configuration file. This file is tha CPack configuration generated by the
  CPack module fo' source installers. Defaults ta CPackSourceConfig.cmake.
.fi




.nf
  CPACK_SOURCE_IGNORE_FILES \- Pattern of filez up in tha source tree
  dat won't be packaged when buildin a source package. This be a
  list of regular expression patterns (that must be properly escaped),
  e.g., /CVS/;/\\\\.svn/;\\\\.swp$;\\\\.#;/#;.*~;cscope.*
.fi




Da followin variablez is fo' advanced usez of CPack:


.nf
  CPACK_CMAKE_GENERATOR \- What CMake generator should be used if the
  project is CMake project. Defaults ta tha value of CMAKE_GENERATOR
  few playas will wanna chizzle dis setting.
.fi




.nf
  CPACK_INSTALL_CMAKE_PROJECTS \- List of four joints dat specify
  what tha fuck project ta install. Da four joints are: Build directory,
  Project Name, Project Component, Directory. If omitted, CPack will
  build a installa dat installaz every last muthafuckin thang.
.fi




.nf
  CPACK_SYSTEM_NAME \- System name, defaults ta tha value of
  ${CMAKE_SYSTEM_NAME}.
.fi




.nf
  CPACK_PACKAGE_VERSION \- Package full version, used internally. By
  default, dis is built from CPACK_PACKAGE_VERSION_MAJOR,
  CPACK_PACKAGE_VERSION_MINOR, n' CPACK_PACKAGE_VERSION_PATCH.
.fi




.nf
  CPACK_TOPLEVEL_TAG \- Directory fo' tha installed files.
.fi




.nf
  CPACK_INSTALL_COMMANDS \- Extra commandz ta install components.
.fi




.nf
  CPACK_INSTALLED_DIRECTORIES \- Extra directories ta install.
.fi




.nf
   CPACK_PACKAGE_INSTALL_REGISTRY_KEY \- Registry key used when
   installin dis project. This is only used by installa fo' Windows.
   Da default value is based on tha installation directory.
   CPACK_CREATE_DESKTOP_LINKS \- List of desktop links ta create.
.fi




.TP
.B CPackBundle
CPack Bundle generator (Mac OS X) specific options




Installaz built on Mac OS X rockin tha Bundle generator use tha aforementioned DragNDrop (CPACK_DMG_xxx) variables, plus tha followin Bundle\-specific parametas (CPACK_BUNDLE_xxx).


.nf
  CPACK_BUNDLE_NAME \- Da name of tha generated bundle. This
  appears up in tha OSX finder as tha bundle name. Required.
.fi




.nf
  CPACK_BUNDLE_PLIST \- Path ta a OSX plist file dat is ghon be used
  fo' tha generated bundle. This assumes dat tha calla has generated
  or specified they own Info.plist file. Required.
.fi




.nf
  CPACK_BUNDLE_ICON \- Path ta a OSX icon file dat is ghon be used as
  tha icon fo' tha generated bundle. This is tha icon dat appears up in the
  OSX finder fo' tha bundle, n' up in tha OSX dock when tha bundle is opened.
  Required.
.fi




.nf
  CPACK_BUNDLE_STARTUP_COMMAND \- Path ta a startup script. This be a path to
  a executable or script dat is ghon be run whenever a end\-user double\-clicks
  tha generated bundle up in tha OSX Finder n' shit. Optional.
.fi

.TP
.B CPackComponent
Build binary n' source package installers




Da CPackComponent module is tha module which handlez tha component part of CPack. Right back up in yo muthafuckin ass. See CPack module fo' general shiznit bout CPack.


For certain kindz of binary installaz (includin tha graphical installaz on Mac OS X n' Windows), CPack generates installaz dat allow playas ta select individual application components ta install. Da contentz of each of tha components is identified by tha COMPONENT argument of CMakez INSTALL command. Y'all KNOW dat shit, muthafucka! These components can be annotated wit user\-friendly names n' descriptions, inter\-component dependencies, etc., n' grouped up in various ways ta customize tha resultin installa n' shit. Right back up in yo muthafuckin ass. See tha cpack_add_* commands, busted lyrics bout below, fo' mo' shiznit bout component\-specific installations.


Component\-specific installation allows playas ta select specific setz of components ta install durin tha install process. Installation components is identified by tha COMPONENT argument of CMakez INSTALL commands, n' should be further busted lyrics bout by tha followin CPack commands:


.nf
  CPACK_COMPONENTS_ALL \- Da list of component ta install.
.fi




Da default value of dis variable is computed by CPack n' gotz nuff all components defined by tha project. Da user may set it ta only include tha specified components.


.nf
  CPACK_<GENNAME>_COMPONENT_INSTALL \- Enable/Disable component install for
  CPack generator <GENNAME>.
.fi




Each CPack Generator (RPM, DEB, ARCHIVE, NSIS, DMG, etc...) has a legacy default behavior. Shiiit, dis aint no joke. e.g. RPM buildz monolithic whereas NSIS buildz component. One can chizzle tha default behavior by settin dis variable ta 0/1 or OFF/ON.


.nf
  CPACK_COMPONENTS_GROUPING \- Specify how tha fuck components is grouped fo' multi\-package
  component\-aware CPack generators.
.fi




Some generators like RPM or ARCHIVE crew (TGZ, ZIP, ...) generates nuff muthafuckin packages filez when axed fo' component packaging. They crew tha component differently dependin on tha value of dis variable:


.nf
  \- ONE_PER_GROUP (default): creates one package file per component group
  \- ALL_COMPONENTS_IN_ONE : creates a single package wit all (requested) component
  \- IGNORE : creates one package per component, i.e. IGNORE component group
.fi

One can specify different groupin fo' different CPack generator by rockin a CPACK_PROJECT_CONFIG_FILE.


.nf
  CPACK_COMPONENT_<compName>_DISPLAY_NAME \- Da name ta be displayed fo' a cold-ass lil component.
  CPACK_COMPONENT_<compName>_DESCRIPTION \- Da description of a cold-ass lil component.
  CPACK_COMPONENT_<compName>_GROUP \- Da crew of a cold-ass lil component.
  CPACK_COMPONENT_<compName>_DEPENDS \- Da dependencies (list of components)
  on which dis component depends.
  CPACK_COMPONENT_<compName>_REQUIRED \- True is dis component is required.
.fi

cpack_add_component \- Describes a CPack installation component named by tha COMPONENT argument ta a CMake INSTALL command.


.nf
  cpack_add_component(compname
                      [DISPLAY_NAME name]
                      [DESCRIPTION description]
                      [HIDDEN | REQUIRED | DISABLED ]
                      [GROUP group]
                      [DEPENDS comp1 comp2 ... ]
                      [INSTALL_TYPES type1 type2 ... ]
                      [DOWNLOADED]
                      [ARCHIVE_FILE filename])
.fi




Da cmake_add_component command raps bout a installation component, which tha user can opt ta install or remove as part of tha graphical installation process. compname is tha name of tha component, as provided ta tha COMPONENT argument of one or mo' CMake INSTALL commands.


DISPLAY_NAME is tha displayed name of tha component, used up in graphical installaz ta display tha component name. This value can be any string.


DESCRIPTION be a extended description of tha component, used up in graphical installaz ta give tha user additionizzle shiznit bout tha component. Descriptions can span multiple lines rockin "\\n" as tha line separator. Shiiit, dis aint no joke. Typically, these descriptions should be no mo' than all dem lines long.


HIDDEN indicates dat dis component is ghon be hidden up in tha graphical installer, so dat tha user cannot directly chizzle whether it is installed or not.


REQUIRED indicates dat dis component is required, n' therefore will always be installed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is ghon be visible up in tha graphical installa yo, but it cannot be unselected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Typically, required components is shown greyed out).


DISABLED indicates dat dis component should be disabled (unselected) by default. Da user is free ta select dis component fo' installation, unless it be also HIDDEN.


DEPENDS lists tha components on which dis component depends. If dis component is selected, then each of tha components listed must also be selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da dependency shiznit is encoded within tha installa itself, so dat playas cannot install inconsistent setz of components.


GROUP names tha component crew of which dis component be a part. If not provided, tha component is ghon be a standalone component, not part of any component group. Component crews is busted lyrics bout wit tha cpack_add_component_group command, detailed below.


INSTALL_TYPES lists tha installation typez of which dis component be a part. When one of these installations types is selected, dis component will automatically be selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Installation types is busted lyrics bout wit tha cpack_add_install_type command, detailed below.


DOWNLOADED indicates dat dis component should be downloaded on\-the\-fly by tha installer, rather than packaged up in wit tha installa itself. For mo' shiznit, peep tha cpack_configure_downloadz command.


ARCHIVE_FILE serves up a name fo' tha archive file pimped by CPack ta be used fo' downloaded components, n' you can put dat on yo' toast. If not supplied, CPack will create a gangbangin' file wit some name based on CPACK_PACKAGE_FILE_NAME n' tha name of tha component. Right back up in yo muthafuckin ass. See cpack_configure_downloadz fo' mo' shiznit.


cpack_add_component_group \- Describes a crew of related CPack installation components.


.nf
  cpack_add_component_group(groupname
                           [DISPLAY_NAME name]
                           [DESCRIPTION description]
                           [PARENT_GROUP parent]
                           [EXPANDED]
                           [BOLD_TITLE])
.fi




Da cpack_add_component_group raps on some crew of installation components, which is ghon be placed together within tha listin of options. Typically, component crews allow tha user ta select/deselect all of tha components within a single crew via a single group\-level option. I aint talkin' bout chicken n' gravy biatch. Use component crews ta reduce tha complexitizzle of installaz wit nuff options. groupname be a arbitrary name used ta identify tha crew up in tha GROUP argument of tha cpack_add_component command, which is used ta place a cold-ass lil component up in a group. Da name of tha crew must not conflict wit tha name of any component.


DISPLAY_NAME is tha displayed name of tha component group, used up in graphical installaz ta display tha component crew name. This value can be any string.


DESCRIPTION be a extended description of tha component group, used up in graphical installaz ta give tha user additionizzle shiznit bout tha components within dat group. Descriptions can span multiple lines rockin "\\n" as tha line separator. Shiiit, dis aint no joke. Typically, these descriptions should be no mo' than all dem lines long.


PARENT_GROUP, if supplied, names tha parent crew of dis group. Parent crews is used ta establish a hierarchy of groups, providin a arbitrary hierarchy of groups.


EXPANDED indicates that, by default, tha crew should show up as "expanded", so dat tha user immediately sees all of tha components within tha group. Otherwise, tha crew will initially show up as a single entry.


BOLD_TITLE indicates dat tha crew title should step tha fuck up in bold, ta booty-call tha userz attention ta tha group.


cpack_add_install_type \- Add a freshly smoked up installation type containin a set of predefined component selections ta tha graphical installer.


.nf
  cpack_add_install_type(typename
                         [DISPLAY_NAME name])
.fi




Da cpack_add_install_type command identifies a set of preselected components dat represents a cold-ass lil common use case fo' a application. I aint talkin' bout chicken n' gravy biatch. For example, a "Developer" install type might include a application along wit its header n' library files, while a "End user" install type might just include tha applicationz executable. Each component identifies itself wit one or mo' install types via tha INSTALL_TYPES argument ta cpack_add_component.


DISPLAY_NAME is tha displayed name of tha install type, which will typically show up in a thugged-out drop\-down box within a graphical installa n' shit. This value can be any string.


cpack_configure_downloadz \- Configure CPack ta downlizzle selected components on\-the\-fly as part of tha installation process.


.nf
  cpack_configure_downloads(site
                            [UPLOAD_DIRECTORY dirname]
                            [ALL]
                            [ADD_REMOVE|NO_ADD_REMOVE])
.fi




Da cpack_configure_downloadz command configures installation\-time downloadz of selected components, n' you can put dat on yo' toast. For each downloadable component, CPack will create a archive containin tha contentz of dat component, which should be uploaded ta tha given crib. When tha user selects dat component fo' installation, tha installa will downlizzle n' extract tha component up in place. This feature is useful fo' bustin lil' small-ass installaz dat only downlizzle tha axed components, savin bandwidth fo' realz. Additionally, tha installaz is lil' small-ass enough dat they is ghon be installed as part of tha aiiight installation process, n' tha "Change" button up in Windows Add/Remove Programs control panel will allow one ta add or remove partz of tha application afta tha original gangsta installation. I aint talkin' bout chicken n' gravy biatch. On Windows, tha downloaded\-components functionalitizzle requires tha ZipDLL plug\-in fo' NSIS, available at:


.nf
  http://nsis.sourceforge.net/ZipDLL_plug\-in
.fi




On Mac OS X, installaz dat downlizzle components on\-the\-fly can only be built n' installed on system rockin Mac OS X 10.5 or later.


Da joint argument be a URL where tha archives fo' downloadable components will reside, e.g., http://www.cmake.org/files/2.6.1/installer/ All of tha archives produced by CPack should be uploaded ta dat location.


UPLOAD_DIRECTORY is tha local directory where CPack will create tha various archives fo' each of tha components, n' you can put dat on yo' toast. Da contentz of dis directory should be uploaded ta a location accessible by tha URL given up in tha joint argument. If omitted, CPack will use tha directory CPackUploadz inside tha CMake binary directory ta store tha generated archives.


Da ALL flag indicates dat all components be downloaded. Y'all KNOW dat shit, muthafucka! Otherwise, only dem components explicitly marked as DOWNLOADED or dat gotz a specified ARCHIVE_FILE is ghon be downloaded. Y'all KNOW dat shit, muthafucka! Additionally, tha ALL option implies ADD_REMOVE (unless NO_ADD_REMOVE is specified).


ADD_REMOVE indicates dat CPack should install a cold-ass lil copy of tha installa dat can be called from Windows' Add/Remove Programs dialog (via tha "Modify" button) ta chizzle tha set of installed components, n' you can put dat on yo' toast. NO_ADD_REMOVE turns off dis behavior. Shiiit, dis aint no joke. This option is ignored on Mac OS X.

.TP
.B CPackCygwin
Cygwin CPack generator (Cygwin).

Da followin variable is specific ta installaz build on and/or fo' Cygwin:


.nf
   CPACK_CYGWIN_PATCH_NUMBER \- Da Cygwin patch number.
   FIXME: This documentation is incomplete.
   CPACK_CYGWIN_PATCH_FILE \- Da Cygwin patch file.
   FIXME: This documentation is incomplete.
   CPACK_CYGWIN_BUILD_SCRIPT \- Da Cygwin build script.
   FIXME: This documentation is incomplete.
.fi

.TP
.B CPackDMG
DragNDrop CPack generator (Mac OS X).

Da followin variablez is specific ta tha DragNDrop installaz built on Mac OS X:


.nf
  CPACK_DMG_VOLUME_NAME \- Da volume name of tha generated disk
  image. Defaults ta CPACK_PACKAGE_FILE_NAME.
.fi




.nf
  CPACK_DMG_FORMAT \- Da disk image format. Common joints is UDRO
  (UDIF read\-only), UDZO (UDIF zlib\-compressed) or UDBZ (UDIF
  bzip2\-compressed). Refer ta hdiutil(1) fo' mo' shiznit on
  other available formats.
.fi




.nf
  CPACK_DMG_DS_STORE \- Path ta a cold-ass lil custom DS_Store file. This .DS_Store
  file e.g. can be used ta specify tha Finder window
  position/geometry n' layout (like fuckin hidden toolbars, placement of the
  icons etc.). This file has ta be generated by tha Finder (either manually or
  all up in OSA\-script) rockin a aiiight folda from which tha .DS_Store
  file can then be extracted.
.fi




.nf
  CPACK_DMG_BACKGROUND_IMAGE \- Path ta a funky-ass background image file. This
  file is ghon be used as tha background fo' tha Finder Window when tha disk
  image is opened. Y'all KNOW dat shit, muthafucka!  By default no background image is set. Da background
  image be applied afta applyin tha custom .DS_Store file.
.fi




.nf
  CPACK_COMMAND_HDIUTIL \- Path ta tha hdiutil(1) command used to
  operate on disk image filez on Mac OS X. This variable can be used
  ta override tha automatically detected command (or specify its
  location if tha auto\-detection fails ta find dat shit.)
.fi




.nf
  CPACK_COMMAND_SETFILE \- Path ta tha SetFile(1) command used ta set
  extended attributes on filez n' directories on Mac OS X. This
  variable can be used ta override tha automatically detected
  command (or specify its location if tha auto\-detection fails to
  find dat shit.)
.fi




.nf
  CPACK_COMMAND_REZ \- Path ta tha Rez(1) command used ta compile
  resources on Mac OS X. This variable can be used ta override the
  automatically detected command (or specify its location if the
  auto\-detection fails ta find dat shit.)
.fi

.TP
.B CPackDeb
Da builtin (binary) CPack Deb generator (Unix only)

CPackDeb may be used ta create Deb package rockin CPack. CPackDeb be a CPack generator thus it uses tha CPACK_XXX variablez used by CPack : http://www.cmake.org/Wiki/CMake:CPackConfiguration. I aint talkin' bout chicken n' gravy biatch. CPackDeb generator should work on any linux host but it will produce betta deb package when Debian specific tools 'dpkg\-xxx' is usable on tha build system.


CPackDeb has specific features which is controlled by tha specifics CPACK_DEBIAN_XXX variables.You'll find a thugged-out detailed usage on tha wiki:


.nf
  http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#DEB_.28UNIX_only.29
.fi

However as a handy reminder here comes tha list of specific variables:


CPACK_DEBIAN_PACKAGE_NAME


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_NAME (lower case)
     Da debian package summary
.fi

CPACK_DEBIAN_PACKAGE_VERSION


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_VERSION
     Da debian package version
.fi

CPACK_DEBIAN_PACKAGE_ARCHITECTURE


.nf
     Mandatory : YES
     Default   : Output of dpkg \-\-print\-architecture (or i386 if dpkg aint found)
     Da debian package architecture
.fi

CPACK_DEBIAN_PACKAGE_DEPENDS


.nf
     Mandatory : NO
     Default   : \-
     May be used ta set deb dependencies.
.fi

CPACK_DEBIAN_PACKAGE_MAINTAINER


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_CONTACT
     Da debian package maintainer
.fi

CPACK_DEBIAN_PACKAGE_DESCRIPTION


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
     Da debian package description
.fi

CPACK_DEBIAN_PACKAGE_SECTION


.nf
     Mandatory : YES
     Default   : 'devel'
     Da debian package section
.fi

CPACK_DEBIAN_PACKAGE_PRIORITY


.nf
     Mandatory : YES
     Default   : 'optional'
     Da debian package priority
.fi

CPACK_DEBIAN_PACKAGE_HOMEPAGE


.nf
     Mandatory : NO
     Default   : \-
     Da URL of tha wizzy joint fo' dis package, preferably (when applicable) the
     joint from which tha original gangsta source can be obtained n' any additional
     upstream documentation or shiznit may be found.
     Da content of dis field be a simple URL without any surrounding
     charactas like fuckin <>.
.fi

CPACK_DEBIAN_PACKAGE_SHLIBDEPS


.nf
     Mandatory : NO
     Default   : OFF
     May be set ta ON up in order ta use dpkg\-shlibdeps ta generate
     betta package dependency list.
     Yo ass may need set CMAKE_INSTALL_RPATH toi appropriate value
     if you use dis feature, cuz if you don't dpkg\-shlibdeps
     may fail ta find yo' own shared libs.
     See http://www.cmake.org/Wiki/CMake_RPATH_handling.
.fi

CPACK_DEBIAN_PACKAGE_DEBUG


.nf
     Mandatory : NO
     Default   : \-
     May be set when invokin cpack up in order ta trace debug shiznit
     durin CPackDeb run.
.fi

CPACK_DEBIAN_PACKAGE_PREDEPENDS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     This field is like Depends, except dat it also forces dpkg ta complete installation of
     tha packages named before even startin tha installation of tha package which declares
     tha pre\-dependency.
.fi

CPACK_DEBIAN_PACKAGE_ENHANCES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     This field is similar ta Suggests but works up in tha opposite direction.
     It be used ta declare dat a package can enhizzle tha functionalitizzle of another package.
.fi

CPACK_DEBIAN_PACKAGE_BREAKS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     When one binary package declares dat it breaks another, dpkg will refuse ta allow the
     package which declares Breaks be installed unless tha fucked up package is deconfigured first,
     n' it will refuse ta allow tha fucked up package ta be reconfigured.
.fi

CPACK_DEBIAN_PACKAGE_CONFLICTS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     When one binary package declares a cold-ass lil conflict wit another rockin a Conflicts field,
     dpkg will refuse ta allow dem ta be installed on tha system all up in tha same time.
.fi

CPACK_DEBIAN_PACKAGE_PROVIDES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     A virtual package is one which appears up in tha Provides control field of another package.
.fi

CPACK_DEBIAN_PACKAGE_REPLACES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Packages can declare up in they control file dat they should overwrite
     filez up in certain other packages, or straight-up replace other packages.
.fi

CPACK_DEBIAN_PACKAGE_RECOMMENDS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Allows packages ta declare a strong yo, but not absolute, dependency on other packages.
.fi

CPACK_DEBIAN_PACKAGE_SUGGESTS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Allows packages ta declare a suggested package install grouping.
.fi

CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA


.nf
     Mandatory : NO
     Default   : \-
     This variable allow advanced user ta add custom script ta tha control.tar.gz
     Typical usage is fo' conffiles, postinst, postrm, prerm.
     Usage: set(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA
            "${CMAKE_CURRENT_SOURCE_DIR/prerm;${CMAKE_CURRENT_SOURCE_DIR}/postrm")
.fi

.TP
.B CPackNSIS
CPack NSIS generator specific options




Da followin variablez is specific ta tha graphical installaz built on Windows rockin tha Nullsoft Installation System.


.nf
   CPACK_NSIS_INSTALL_ROOT \- Da default installation directory presented
   ta tha end user by tha NSIS installa is under dis root dir. Shiiit, dis aint no joke. Da full
   directory presented ta tha end user is:
   ${CPACK_NSIS_INSTALL_ROOT}/${CPACK_PACKAGE_INSTALL_DIRECTORY}
.fi




.nf
   CPACK_NSIS_MUI_ICON \- An icon filename.
   Da name of a *.ico file used as tha main icon fo' tha generated
   install program.
.fi




.nf
   CPACK_NSIS_MUI_UNIICON \- An icon filename.
   Da name of a *.ico file used as tha main icon fo' tha generated
   uninstall program.
.fi




.nf
   CPACK_NSIS_INSTALLER_MUI_ICON_CODE \- undocumented.
.fi




.nf
   CPACK_NSIS_EXTRA_PREINSTALL_COMMANDS \- Extra NSIS commandz that
   is ghon be added ta tha beginnin of tha install Section, before your
   install tree be available on tha target system.
.fi




.nf
   CPACK_NSIS_EXTRA_INSTALL_COMMANDS \- Extra NSIS commandz that
   is ghon be added ta tha end of tha install Section, afta your
   install tree be available on tha target system.
.fi




.nf
   CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS \- Extra NSIS commandz dat will
   be added ta tha uninstall Section, before yo' install tree is
   removed from tha target system.
.fi




.nf
   CPACK_NSIS_COMPRESSOR \- Da arguments dat is ghon be passed ta the
   NSIS SetCompressor command.
.fi




.nf
   CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL \- Ask bout uninstalling
   previous versions first.
   If dis is set ta "ON", then a installa will look fo' previous
   installed versions n' if one is found, ask tha user whether to
   uninstall it before proceedin wit tha install.
.fi




.nf
   CPACK_NSIS_MODIFY_PATH \- Modify PATH toggle.
   If dis is set ta "ON", then a extra page
   will step tha fuck up in tha installa dat will allow tha user ta chizzle
   whether tha program directory should be added ta tha system PATH
   variable.
.fi




.nf
   CPACK_NSIS_DISPLAY_NAME \- Da display name strang dat appears in
   tha Windows Add/Remove Program control panel
.fi




.nf
   CPACK_NSIS_PACKAGE_NAME \- Da title displayed all up in tha top of the
   installer.
.fi




.nf
   CPACK_NSIS_INSTALLED_ICON_NAME \- A path ta tha executable that
   gotz nuff tha installa icon.
.fi




.nf
   CPACK_NSIS_HELP_LINK \- URL ta a wizzy joint providin assistizzle in
   installin yo' application.
.fi




.nf
   CPACK_NSIS_URL_INFO_ABOUT \- URL ta a wizzy joint providin more
   shiznit bout yo' application.
.fi




.nf
   CPACK_NSIS_CONTACT \- Contact shiznit fo' thangs n' comments
   bout tha installation process.
.fi




.nf
   CPACK_NSIS_CREATE_ICONS_EXTRA \- Additionizzle NSIS commandz for
   bustin start menu shortcuts.
.fi




.nf
   CPACK_NSIS_DELETE_ICONS_EXTRA \-Additionizzle NSIS commandz to
   uninstall start menu shortcuts.
.fi




.nf
   CPACK_NSIS_EXECUTABLES_DIRECTORY \- Creatin NSIS start menu links
   assumes dat they is up in 'bin' unless dis variable is set.
   For example, you would set dis ta 'exec' if yo' executablez are
   up in a exec directory.
.fi




.nf
   CPACK_NSIS_MUI_FINISHPAGE_RUN \- Specify a executable ta add a option
   ta run on tha finish page of tha NSIS installer.
   CPACK_NSIS_MENU_LINKS \- Specify links up in [application] menu.
   This should contain a list of pair "link" "link name". Da link
   may be a URL or a path relatizzle ta installation prefix.
   Like:
     set(CPACK_NSIS_MENU_LINKS
         "doc/cmake\-@CMake_VERSION_MAJOR@.@CMake_VERSION_MINOR@/cmake.html" "CMake Help"
         "http://www.cmake.org" "CMake Web Joint")
.fi

.TP
.B CPackPackageMaker
PackageMaker CPack generator (Mac OS X).

Da followin variable is specific ta installaz built on Mac OS X rockin PackageMaker:


.nf
  CPACK_OSX_PACKAGE_VERSION \- Da version of Mac OS X dat the
  resultin PackageMaker archive should be compatible with. Different
  versionz of Mac OS X support different
  features. For example, CPack can only build component\-based
  installaz fo' Mac OS X 10.4 or newer, n' can only build
  installaz dat downlizzle component son\-the\-fly fo' Mac OS X 10.5
  or newer n' shit. If left blank, dis value is ghon be set ta tha minimum
  version of Mac OS X dat supports tha axed features. Right back up in yo muthafuckin ass. Set this
  variable ta some value (e.g., 10.4) only if you wanna guarantee
  dat yo' installa will work on dat version of Mac OS X, and
  don't mind missin extra features available up in tha installer
  shippin wit lata versionz of Mac OS X.
.fi

.TP
.B CPackRPM
Da builtin (binary) CPack RPM generator (Unix only)

CPackRPM may be used ta create RPM package rockin CPack. CPackRPM be a CPack generator thus it uses tha CPACK_XXX variablez used by CPack : http://www.cmake.org/Wiki/CMake:CPackConfiguration


However CPackRPM has specific features which is controlled by tha specifics CPACK_RPM_XXX variables. CPackRPM be a cold-ass lil component aware generator so when CPACK_RPM_COMPONENT_INSTALL is ON some mo' CPACK_RPM_<ComponentName>_XXXX variablez may be used up in order ta have component specific joints, n' you can put dat on yo' toast. Note however dat <componentName> refers ta tha **groupin name**. This may be either a cold-ass lil component name or a cold-ass lil component GROUP name. Usually dem vars correspond ta RPM spec file entities, one may find shiznit bout spec filez here http://www.rpm.org/wiki/Docs. You'll find a thugged-out detailed usage of CPackRPM on tha wiki:


.nf
  http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#RPM_.28Unix_Only.29
.fi

However as a handy reminder here comes tha list of specific variables:


.nf
  CPACK_RPM_PACKAGE_SUMMARY \- Da RPM package summary.
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
  CPACK_RPM_PACKAGE_NAME \- Da RPM package name.
     Mandatory : YES
     Default   : CPACK_PACKAGE_NAME
  CPACK_RPM_PACKAGE_VERSION \- Da RPM package version.
     Mandatory : YES
     Default   : CPACK_PACKAGE_VERSION
  CPACK_RPM_PACKAGE_ARCHITECTURE \- Da RPM package architecture.
     Mandatory : NO
     Default   : \-
     This may be set ta "noarch" if you
     know yo ass is buildin a noarch package.
  CPACK_RPM_PACKAGE_RELEASE \- Da RPM package release.
     Mandatory : YES
     Default   : 1
     This is tha numberin of tha RPM package
     itself, i.e. tha version of tha packagin n' not tha version of the
     content (see CPACK_RPM_PACKAGE_VERSION). One may chizzle tha default
     value if tha previous packagin was buggy and/or you wanna put here
     a gangbangin' fancy Linux distro specific numbering.
  CPACK_RPM_PACKAGE_LICENSE \- Da RPM package license policy.
     Mandatory : YES
     Default   : "unknown"
  CPACK_RPM_PACKAGE_GROUP \- Da RPM package group.
     Mandatory : YES
     Default   : "unknown"
  CPACK_RPM_PACKAGE_VENDOR \- Da RPM package vendor.
     Mandatory : YES
     Default   : CPACK_PACKAGE_VENDOR if set or "unknown"
  CPACK_RPM_PACKAGE_URL \- Da projects URL.
     Mandatory : NO
     Default   : \-
  CPACK_RPM_PACKAGE_DESCRIPTION \- RPM package description.
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_FILE if set or "no package description available"
  CPACK_RPM_COMPRESSION_TYPE \- RPM compression type.
     Mandatory : NO
     Default   : \-
     May be used ta override RPM compression type ta be used
     ta build tha RPM. For example some Linux distribution now default
     ta lzma or xz compression whereas olda cannot use such RPM.
     Usin dis one can enforce compression type ta be used.
     Possible value are: lzma, xz, bzip2 n' gzip.
  CPACK_RPM_PACKAGE_REQUIRES \- RPM spec requires field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM dependencies (requires).
     Note dat you must enclose tha complete requires strang between quotes,
     fo' example:
     set(CPACK_RPM_PACKAGE_REQUIRES "python >= 2.5.0, cmake >= 2.8")
     Da required package list of a RPM file could be printed with
     rpm \-qp \-\-requires file.rpm
  CPACK_RPM_PACKAGE_SUGGESTS \- RPM spec suggest field.
     Mandatory : NO
     Default   : \-
     May be used ta set weak RPM dependencies (suggests).
     Note dat you must enclose tha complete requires strang between quotes.
  CPACK_RPM_PACKAGE_PROVIDES \- RPM spec serves up field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM dependencies (provides).
     Da provided package list of a RPM file could be printed with
     rpm \-qp \-\-provides file.rpm
  CPACK_RPM_PACKAGE_OBSOLETES \- RPM spec obsoletes field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM packages dat is obsoleted by dis one.
  CPACK_RPM_PACKAGE_RELOCATABLE \- build a relocatable RPM.
     Mandatory : NO
     Default   : CPACK_PACKAGE_RELOCATABLE
     If dis variable is set ta TRUE or ON CPackRPM will try
     ta build a relocatable RPM package fo' realz. A relocatable RPM may
     be installed rockin rpm \-\-prefix or \-\-relocate up in order to
     install it at a alternate place peep rpm(8).
     Note dat currently dis may fail if CPACK_SET_DESTDIR is set ta ON.
     If CPACK_SET_DESTDIR is set then yo big-ass booty is ghon git a warnin message
     but if there is file installed wit absolute path you gonna get
     unexpected behavior.
  CPACK_RPM_SPEC_INSTALL_POST \- [deprecated].
     Mandatory : NO
     Default   : \-
     This way of specifyin post\-install script is deprecated use
     CPACK_RPM_POST_INSTALL_SCRIPT_FILE
     May be used ta set a RPM post\-install command inside tha spec file.
     For example settin it ta "/bin/true" may be used ta prevent
     rpmbuild ta strip binaries.
  CPACK_RPM_SPEC_MORE_DEFINE \- RPM extended spec definitions lines.
     Mandatory : NO
     Default   : \-
     May be used ta add any %define lines ta tha generated spec file.
  CPACK_RPM_PACKAGE_DEBUG \- Toggle CPackRPM debug output.
     Mandatory : NO
     Default   : \-
     May be set when invokin cpack up in order ta trace debug shiznit
     durin CPack RPM run. I aint talkin' bout chicken n' gravy biatch. For example you may launch CPack like this
     cpack \-D CPACK_RPM_PACKAGE_DEBUG=1 \-G RPM
  CPACK_RPM_USER_BINARY_SPECFILE \- A user provided spec file.
     Mandatory : NO
     Default   : \-
     May be set by tha user up in order ta specify a USER binary spec file
     ta be used by CPackRPM instead of generatin tha file.
     Da specified file is ghon be processed by configure_file( @ONLY).
     One can provide a cold-ass lil component specific file by setting
     CPACK_RPM_<componentName>_USER_BINARY_SPECFILE.
  CPACK_RPM_GENERATE_USER_BINARY_SPECFILE_TEMPLATE \- Spec file template.
     Mandatory : NO
     Default   : \-
     If set CPack will generate a template fo' USER specified binary
     spec file n' stop wit a error. Shiiit, dis aint no joke. For example launch CPack like this
     cpack \-D CPACK_RPM_GENERATE_USER_BINARY_SPECFILE_TEMPLATE=1 \-G RPM
     Da user may then use dis file up in order ta hand\-craft is own
     binary spec file which may be used wit CPACK_RPM_USER_BINARY_SPECFILE.
  CPACK_RPM_PRE_INSTALL_SCRIPT_FILE
  CPACK_RPM_PRE_UNINSTALL_SCRIPT_FILE
     Mandatory : NO
     Default   : \-
     May be used ta embed a pre (un)installation script up in tha spec file.
     Da refered script file(s) is ghon be read n' directly
     put afta tha %pre or %preun section
     If CPACK_RPM_COMPONENT_INSTALL is set ta ON tha (un)install script for
     each component can be overridden with
     CPACK_RPM_<COMPONENT>_PRE_INSTALL_SCRIPT_FILE and
     CPACK_RPM_<COMPONENT>_PRE_UNINSTALL_SCRIPT_FILE
     One may verify which scriptlet has been included with
      rpm \-qp \-\-scripts  package.rpm
  CPACK_RPM_POST_INSTALL_SCRIPT_FILE
  CPACK_RPM_POST_UNINSTALL_SCRIPT_FILE
     Mandatory : NO
     Default   : \-
     May be used ta embed a post (un)installation script up in tha spec file.
     Da refered script file(s) is ghon be read n' directly
     put afta tha %post or %postun section
     If CPACK_RPM_COMPONENT_INSTALL is set ta ON tha (un)install script for
     each component can be overridden with
     CPACK_RPM_<COMPONENT>_POST_INSTALL_SCRIPT_FILE and
     CPACK_RPM_<COMPONENT>_POST_UNINSTALL_SCRIPT_FILE
     One may verify which scriptlet has been included with
      rpm \-qp \-\-scripts  package.rpm
  CPACK_RPM_USER_FILELIST
  CPACK_RPM_<COMPONENT>_USER_FILELIST
     Mandatory : NO
     Default   : \-
     May be used ta explicitly specify %(<directive>) file line
     up in tha spec file. Like %config(noreplace) or any other directive
     dat be found up in tha %filez section. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since CPackRPM is generating
     tha list of filez (and directories) tha user specified filez of
     tha CPACK_RPM_<COMPONENT>_USER_FILELIST list is ghon be removed from tha generated list.
  CPACK_RPM_CHANGELOG_FILE \- RPM chizzlelog file.
     Mandatory : NO
     Default   : \-
     May be used ta embed a cold-ass lil chizzlelog up in tha spec file.
     Da refered file is ghon be read n' directly put afta tha %changelog
     section.
  CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST \- list of path ta be excluded.
     Mandatory : NO
     Default   : /etc /etc/init.d /usr /usr/share /usr/share/doc /usr/bin /usr/lib /usr/lib64 /usr/include
     May be used ta exclude path (directories or files) from tha auto\-generated
     list of paths discovered by CPack RPM. Da defaut value gotz nuff a reasonable
     set of joints if tha variable aint defined by tha user n' shit. If tha variable
     is defined by tha user then CPackRPM will NOT any of tha default path.
     If you wanna add some path ta tha default list then you can use
     CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION variable.
  CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION \- additionizzle list of path ta be excluded.
     Mandatory : NO
     Default   : \-
     May be used ta add mo' exclude path (directories or files) from tha initial
     default list of excluded paths. Right back up in yo muthafuckin ass. See CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST.
.fi

.TP
.B CPackWIX
CPack WiX generator specific options




Da followin variablez is specific ta tha installaz built on Windows rockin WiX.


.nf
  CPACK_WIX_UPGRADE_GUID \- Upgrade GUID (Product/@UpgradeCode)
.fi




Will be automatically generated unless explicitly provided.


It should be explicitly set ta a cold-ass lil constant generated gloabally unique identifier (GUID) ta allow yo' installaz ta replace existin installations dat use tha same GUID.


Yo ass may fo' example explicitly set dis variable up in yo' CMakeLists.txt ta tha value dat has been generated per default. Yo ass should not use GUIDs dat you did not generate yo ass or which may belong ta other projects.


A GUID shall have tha followin fixed length syntax: XXXXXXXX\-XXXX\-XXXX\-XXXX\-XXXXXXXXXXXX


.nf
  (each X represents a uppercase hexadecimal digit)
  CPACK_WIX_PRODUCT_GUID \- Product GUID (Product/@Id)
.fi




Will be automatically generated unless explicitly provided.


If explicitly provided dis will set tha Product Id of yo' installer.


Da installa will abort if it detects a pre\-existin installation dat uses tha same ol' dirty GUID.


Da GUID shall use tha syntax busted lyrics bout fo' CPACK_WIX_UPGRADE_GUID.


.nf
  CPACK_WIX_LICENSE_RTF \- RTF License File
.fi




If CPACK_RESOURCE_FILE_LICENSE has a .rtf extension it is used as\-is.


If CPACK_RESOURCE_FILE_LICENSE has a .txt extension it is implicitly converted ta RTF by tha WiX Generator.


With CPACK_WIX_LICENSE_RTF you can override tha license file used by tha WiX Generator up in case CPACK_RESOURCE_FILE_LICENSE is up in a unsupported format or tha .txt \-> .rtf conversion do not work as expected.





CPACK_WIX_PRODUCT_ICON \- Da Icon shown next ta tha program name up in Add/Remove programs.


If set, dis icon is used up in place of tha default icon.





CPACK_WIX_UI_BANNER \- Da bitmap will step tha fuck up all up in tha top of all installa pages other than tha welcome n' completion dialogs.


If set, dis image will replace tha default banner image.


This image must be 493 by 58 pixels.





CPACK_WIX_UI_DIALOG \- Background bitmap used on tha welcome n' completion dialogs.


If dis variable is set, tha installa will replace tha default dialog image.


This image must be 493 by 312 pixels.





CPACK_WIX_PROGRAM_MENU_FOLDER \- Start menu folda name fo' launcher.


If dis variable aint set, it is ghon be initialized wit CPACK_PACKAGE_NAME


CPACK_WIX_CULTURES \- Language(s) of tha installer


Languages is compiled tha fuck into tha WixUI extension library. To use them, simply provide tha name of tha culture.  If you specify mo' than one culture identifier up in a cold-ass lil comma or semicolon delimited list, tha straight-up original gangsta one dat is found is ghon be used. Y'all KNOW dat shit, muthafucka!  Yo ass can find a list of supported languages at: http://wix.sourceforge.net/manual\-wix3/WixUI_localization.htm


CPACK_WIX_TEMPLATE \- Template file fo' WiX generation


If dis variable is set, tha specified template is ghon be used ta generate tha WiX wxs file. This should be used if further customization of tha output is required.


If dis variable aint set, tha default MSI template included wit CMake is ghon be used.


.TP
.B CTest
Configure a project fo' testin wit CTest/CDash

Include dis module up in tha top CMakeLists.txt file of a project ta enable testin wit CTest n' dashboard submissions ta CDash:


.nf
   project(MyProject)
   ...
   include(CTest)
.fi

Da module automatically creates a BUILD_TESTING option dat selects whether ta enable testin support (ON by default).  Afta includin tha module, use code like


.nf
   if(BUILD_TESTING)
     # ... CMake code ta create tests ...
   endif()
.fi

to bustin tests when testin is enabled.


To enable submissions ta a CDash server, create a CTestConfig.cmake file all up in tha top of tha project wit content such as


.nf
   set(CTEST_PROJECT_NAME "MyProject")
   set(CTEST_NIGHTLY_START_TIME "01:00:00 UTC")
   set(CTEST_DROP_METHOD "http")
   set(CTEST_DROP_SITE "my.cdash.org")
   set(CTEST_DROP_LOCATION "/submit.php?project=MyProject")
   set(CTEST_DROP_SITE_CDASH TRUE)
.fi

(the CDash server can provide tha file ta a project administrator whoz ass configures 'MyProject'). Right back up in yo muthafuckin ass. Settings up in tha config file is shared by both dis CTest module n' tha CTest command\-line toolz dashboard script mode (ctest \-S).


While buildin a project fo' submission ta CDash, CTest scans tha build output fo' errors n' warnings n' reports dem wit surroundin context from tha build log.  This generic approach works fo' all build tools yo, but do not give details bout tha command invocation dat produced a given problem.  One may git mo' detailed reports by adding


.nf
   set(CTEST_USE_LAUNCHERS 1)
.fi

to tha CTestConfig.cmake file.  When dis option is enabled, tha CTest module  drops some lyrics ta CMakez Makefile generators ta invoke every last muthafuckin command up in tha generated build system all up in a CTest launcher program.  (Currently tha CTEST_USE_LAUNCHERS option is ignored on non\-Makefile generators.)  Durin a manual build each launcher transparently runs tha command it wraps.  Durin a CTest\-driven build fo' submission ta CDash each launcher reports detailed shiznit when its command fails or warns. (Settin CTEST_USE_LAUNCHERS up in CTestConfig.cmake is convenient yo, but also addz tha launcher overhead even fo' manual builds.  One may instead set it up in a CTest dashboard script n' add it ta tha CMake cache fo' tha build tree.)

.TP
.B CTestScriptMode
.nf
 
.fi

This file is read by ctest up in script mode (\-S)

.TP
.B CTestUseLaunchers
Set tha RULE_LAUNCH_* global propertizzles when CTEST_USE_LAUNCHERS is on.

CTestUseLaunchers be automatically included when you include(CTest). But fuck dat shiznit yo, tha word on tha street is dat it is split up tha fuck into its own module file so projects can use tha CTEST_USE_LAUNCHERS functionalitizzle independently.


To use launchers, set CTEST_USE_LAUNCHERS ta ON up in a cold-ass lil ctest \-S dashboard script, n' then also set it up in tha cache of tha configured project. Both cmake n' ctest need ta know tha value of it fo' tha launchers ta work properly. CMake need ta know up in order ta generate proper build rules, n' ctest, up in order ta produce tha proper error n' warnin analysis.


For convenience, you may set tha ENV variable CTEST_USE_LAUNCHERS_DEFAULT up in yo' ctest \-S script, like a muthafucka. Then, as long as yo' CMakeLists uses include(CTest) or include(CTestUseLaunchers), it will use tha value of tha ENV variable ta initialize a CTEST_USE_LAUNCHERS cache variable. This cache variable initialization only occurs if CTEST_USE_LAUNCHERS aint already defined.

.TP
.B CheckCCompilerFlag
Peep whether tha C compila supports a given flag.

CHECK_C_COMPILER_FLAG(<flag> <var>)


.nf
  <flag> \- tha compila flag
  <var>  \- variable ta store tha result
.fi

This internally calls tha check_c_source_compilez macro n' sets CMAKE_REQUIRED_DEFINITIONS ta <flag>. Right back up in yo muthafuckin ass. See help fo' CheckCSourceCompilez fo' a listin of variablez dat can otherwise modify tha build. Y'all KNOW dat shit, muthafucka! Da result only  drops some lyrics ta dat tha compila do not give a error message when it encountas tha flag. If tha flag has any effect or even a specific one is beyond tha scope of dis module.

.TP
.B CheckCSourceCompiles
Peep if given C source compilez n' links tha fuck into a executable

CHECK_C_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail\-regex>])


.nf
  <code>       \- source code ta try ta compile, must define 'main'
  <var>        \- variable ta store whether tha source code compiled
  <fail\-regex> \- fail if test output matches dis regex
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCSourceRuns
Peep if tha given C source code compilez n' runs.

CHECK_C_SOURCE_RUNS(<code> <var>)


.nf
  <code>   \- source code ta try ta compile
  <var>    \- variable ta store tha result
             (1 fo' success, empty fo' failure)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXCompilerFlag
Peep whether tha CXX compila supports a given flag.

CHECK_CXX_COMPILER_FLAG(<flag> <var>)


.nf
  <flag> \- tha compila flag
  <var>  \- variable ta store tha result
.fi

This internally calls tha check_cxx_source_compilez macro n' sets CMAKE_REQUIRED_DEFINITIONS ta <flag>. Right back up in yo muthafuckin ass. See help fo' CheckCXXSourceCompilez fo' a listin of variablez dat can otherwise modify tha build. Y'all KNOW dat shit, muthafucka! Da result only  drops some lyrics ta dat tha compila do not give a error message when it encountas tha flag. If tha flag has any effect or even a specific one is beyond tha scope of dis module.

.TP
.B CheckCXXSourceCompiles
Peep if given C++ source compilez n' links tha fuck into a executable

CHECK_CXX_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail\-regex>])


.nf
  <code>       \- source code ta try ta compile, must define 'main'
  <var>        \- variable ta store whether tha source code compiled
  <fail\-regex> \- fail if test output matches dis regex
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXSourceRuns
Peep if tha given C++ source code compilez n' runs.

CHECK_CXX_SOURCE_RUNS(<code> <var>)


.nf
  <code>   \- source code ta try ta compile
  <var>    \- variable ta store tha result
             (1 fo' success, empty fo' failure)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXSymbolExists
Peep if a symbol exists as a gangbangin' function, variable, or macro up in C++

CHECK_CXX_SYMBOL_EXISTS(<symbol> <files> <variable>)


Peep dat tha <symbol> be available afta includin given header <files> n' store tha result up in a <variable>.  Specify tha list of filez up in one argument as a semicolon\-separated list. CHECK_CXX_SYMBOL_EXISTS() can be used ta check up in C++ files, as opposed ta CHECK_SYMBOL_EXISTS(), which works only fo' C.


If tha header filez define tha symbol as a macro it is considered available n' assumed ta work.  If tha header filez declare tha symbol as a gangbangin' function or variable then tha symbol must also be available fo' linking.  If tha symbol be a type or enum value it aint gonna be recognized (consider rockin CheckTypeSize or CheckCSourceCompiles).


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckFortranFunctionExists
macro which checks if tha Fortran function exists

CHECK_FORTRAN_FUNCTION_EXISTS(FUNCTION VARIABLE)


.nf
  FUNCTION \- tha name of tha Fortran function
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckFunctionExists
Peep if a C function can be linked

CHECK_FUNCTION_EXISTS(<function> <variable>)


Peep dat tha <function> is provided by libraries on tha system n' store tha result up in a <variable>.  This do not verify dat any system header file declares tha function, only dat it can be found at link time (consider rockin CheckSymbolExists).


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckIncludeFile
macro which checks tha include file exists.

CHECK_INCLUDE_FILE(INCLUDE VARIABLE)


.nf
  INCLUDE  \- name of include file
  VARIABLE \- variable ta return result
.fi




an optionizzle third argument is tha CFlags ta add ta tha compile line or you can use CMAKE_REQUIRED_FLAGS


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




.TP
.B CheckIncludeFileCXX
Peep if tha include file exists.

.nf
  CHECK_INCLUDE_FILE_CXX(INCLUDE VARIABLE)
.fi




.nf
  INCLUDE  \- name of include file
  VARIABLE \- variable ta return result
.fi




An optionizzle third argument is tha CFlags ta add ta tha compile line or you can use CMAKE_REQUIRED_FLAGS.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




.TP
.B CheckIncludeFiles
Peep if tha filez can be included




CHECK_INCLUDE_FILES(INCLUDE VARIABLE)


.nf
  INCLUDE  \- list of filez ta include
  VARIABLE \- variable ta return result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi

.TP
.B CheckLanguage
Peep if a language can be enabled

Usage:


.nf
  check_language(<lang>)
.fi

where <lang> be a language dat may be passed ta enable_language() like fuckin "Fortran".  If CMAKE_<lang>_COMPILER be already defined tha check do nothing.  Otherwise it tries enablin tha language up in a test project.  Da result is cached up in CMAKE_<lang>_COMPILER as tha compila dat was found, or NOTFOUND if tha language cannot be enabled.


Example:


.nf
  check_language(Fortran)
  if(CMAKE_Fortran_COMPILER)
    enable_language(Fortran)
  else()
    message(STATUS "No Fortran support")
  endif()
.fi

.TP
.B CheckLibraryExists
Peep if tha function exists.

CHECK_LIBRARY_EXISTS (LIBRARY FUNCTION LOCATION VARIABLE)


.nf
  LIBRARY  \- tha name of tha library yo ass is lookin for
  FUNCTION \- tha name of tha function
  LOCATION \- location where tha library should be found
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckPrototypeDefinition
Peep if tha protoype we expect is erect.

check_prototype_definition(FUNCTION PROTOTYPE RETURN HEADER VARIABLE)


.nf
  FUNCTION \- Da name of tha function (used ta check if prototype exists)
  PROTOTYPE\- Da prototype ta check.
  RETURN \- Da return value of tha function.
  HEADER \- Da header filez required.
  VARIABLE \- Da variable ta store tha result.
.fi

Example:


.nf
  check_prototype_definition(getpwent_r
   "struct passwd *getpwent_r(struct passwd *src, char *buf, int buflen)"
   "NULL"
   "unistd.h;pwd.h"
   SOLARIS_GETPWENT_R)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckStructHasMember
Peep if tha given struct or class has tha specified member variable

CHECK_STRUCT_HAS_MEMBER (STRUCT MEMBER HEADER VARIABLE)


.nf
  STRUCT \- tha name of tha struct or class yo ass is interested in
  MEMBER \- tha member which existence you wanna check
  HEADER \- tha header(s) where tha prototype should be declared
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




Example: CHECK_STRUCT_HAS_MEMBER("struct timeval" tv_sec sys/select.h HAVE_TIMEVAL_TV_SEC)

.TP
.B CheckSymbolExists
Peep if a symbol exists as a gangbangin' function, variable, or macro

CHECK_SYMBOL_EXISTS(<symbol> <files> <variable>)


Peep dat tha <symbol> be available afta includin given header <files> n' store tha result up in a <variable>.  Specify tha list of filez up in one argument as a semicolon\-separated list.


If tha header filez define tha symbol as a macro it is considered available n' assumed ta work.  If tha header filez declare tha symbol as a gangbangin' function or variable then tha symbol must also be available fo' linking.  If tha symbol be a type or enum value it aint gonna be recognized (consider rockin CheckTypeSize or CheckCSourceCompiles). If tha check need ta be done up in C++, consider rockin CHECK_CXX_SYMBOL_EXISTS(), which do tha same as CHECK_SYMBOL_EXISTS() yo, but up in C++.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckTypeSize
Peep sizeof a type

.nf
  CHECK_TYPE_SIZE(TYPE VARIABLE [BUILTIN_TYPES_ONLY])
.fi

Peep if tha type exists n' determine its size. On return, "HAVE_${VARIABLE}" holdz tha existence of tha type, n' "${VARIABLE}" holdz one of tha following:


.nf
   <size> = type has non\-zero size <size>
   "0"    = type has arch\-dependent size (see below)
   ""     = type do not exist
.fi

Furthermore, tha variable "${VARIABLE}_CODE" holdz C preprocessor code ta define tha macro "${VARIABLE}" ta tha size of tha type, or leave tha macro undefined if tha type do not exist.


Da variable "${VARIABLE}" may be "0" when CMAKE_OSX_ARCHITECTURES has multiple architectures fo' buildin OS X universal binaries. Put ya muthafuckin choppers up if ya feel dis! This indicates dat tha type size varies across architectures. In dis case "${VARIABLE}_CODE" gotz nuff C preprocessor tests mappin from each architecture macro ta tha correspondin type size. Da list of architecture macros is stored up in "${VARIABLE}_KEYS", n' tha value fo' each key is stored up in "${VARIABLE}\-${KEY}".


If tha BUILTIN_TYPES_ONLY option aint given, tha macro checks fo' headaz <sys/types.h>, <stdint.h>, n' <stddef.h>, n' saves thangs up in dis biatch up in HAVE_SYS_TYPES_H, HAVE_STDINT_H, n' HAVE_STDDEF_H.  Da type size check automatically includes tha available headers, thus supportin checkz of types defined up in tha headers.


Despite tha name of tha macro you may use it ta check tha size of mo' complex expressions, like a muthafucka. To check e.g. fo' tha size of a struct member you can do suttin' like this:


.nf
  check_type_size("((struct something*)0)\->member" SIZEOF_MEMBER)
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
  CMAKE_EXTRA_INCLUDE_FILES = list of extra headaz ta include
.fi

.TP
.B CheckVariableExists
Peep if tha variable exists.

.nf
  CHECK_VARIABLE_EXISTS(VAR VARIABLE)
.fi




.nf
  VAR      \- tha name of tha variable
  VARIABLE \- variable ta store tha result
.fi




This macro is only fo' C variables.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B Dart
Configure a project fo' testin wit CTest or oldschool Dart Tcl Client

This file is tha backwards\-compatibilitizzle version of tha CTest module. Well shiiiit, it supports rockin tha oldschool Dart 1 Tcl client fo' rollin dashboard submissions as well as testin wit CTest.  This module should be included up in tha CMakeLists.txt file all up in tha top of a project.  Typical usage:


.nf
  include(Dart)
  if(BUILD_TESTING)
    # ... testin related CMake code ...
  endif()
.fi

Da BUILD_TESTING option is pimped by tha Dart module ta determine whether testin support should be enabled. Y'all KNOW dat shit, muthafucka!  Da default is ON.

.TP
.B DeployQt4
Functions ta help assemble a standalone Qt4 executable.

A collection of CMake utilitizzle functions useful fo' deployin Qt4 executables.


Da followin functions is provided by dis module:


.nf
   write_qt4_conf
   resolve_qt4_paths
   fixup_qt4_executable
   install_qt4_plugin_path
   install_qt4_plugin
   install_qt4_executable
.fi

Requires CMake 2.6 or pimped outa cuz it uses function n' PARENT_SCOPE fo' realz. Also dependz on BundleUtilities.cmake.


.nf
  WRITE_QT4_CONF(<qt_conf_dir> <qt_conf_contents>)
.fi

Writes a qt.conf file wit tha <qt_conf_contents> tha fuck into <qt_conf_dir>.


.nf
  RESOLVE_QT4_PATHS(<paths_var> [<executable_path>])
.fi

Loop all up in <paths_var> list n' if any don't exist resolve dem relatizzle ta tha <executable_path> (if supplied) or tha CMAKE_INSTALL_PREFIX.


.nf
  FIXUP_QT4_EXECUTABLE(<executable> [<qtplugins> <libs> <dirs> <plugins_dir> <request_qt_conf>])
.fi

Copies Qt plugins, writes a Qt configuration file (if needed) n' fixes up a Qt4 executable rockin BundleUtilitizzles so it is standalone n' can be drag\-and\-drop copied ta another machine as long as all of tha system libraries is compatible.


<executable> should point ta tha executable ta be fixed\-up.


<qtplugins> should contain a list of tha names or pathz of any Qt plugins ta be installed.


<libs> is ghon be passed ta BundleUtilitizzles n' should be a list of any already installed plugins, libraries or executablez ta also be fixed\-up.


<dirs> is ghon be passed ta BundleUtilitizzles n' should contain n' directories ta be searched ta find library dependencies.


<plugins_dir> allows a custom plugins directory ta be used.


<request_qt_conf> will force a qt.conf file ta be freestyled even if not needed.


.nf
  INSTALL_QT4_PLUGIN_PATH(plugin executable copy installed_plugin_path_var <plugins_dir> <component> <configurations>)
.fi

Install (or copy) a resolved <plugin> ta tha default plugins directory (or <plugins_dir>) relatizzle ta <executable> n' store tha result up in <installed_plugin_path_var>.


If <copy> is set ta TRUE then tha plugins is ghon be copied rather than installed. Y'all KNOW dat shit, muthafucka! This is ta allow dis module ta be used at CMake time rather than install time.


If <component> is set then anythang installed will use dis COMPONENT.


.nf
  INSTALL_QT4_PLUGIN(plugin executable copy installed_plugin_path_var <plugins_dir> <component>)
.fi

Install (or copy) a unresolved <plugin> ta tha default plugins directory (or <plugins_dir>) relatizzle ta <executable> n' store tha result up in <installed_plugin_path_var>. Right back up in yo muthafuckin ass. See documentation of INSTALL_QT4_PLUGIN_PATH.


.nf
  INSTALL_QT4_EXECUTABLE(<executable> [<qtplugins> <libs> <dirs> <plugins_dir> <request_qt_conf> <component>])
.fi

Installs Qt plugins, writes a Qt configuration file (if needed) n' fixes up a Qt4 executable rockin BundleUtilitizzles so it is standalone n' can be drag\-and\-drop copied ta another machine as long as all of tha system libraries is compatible. Da executable is ghon be fixed\-up at install time. <component> is tha COMPONENT used fo' bundle fixup n' plugin installation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See documentation of FIXUP_QT4_BUNDLE.

.TP
.B Documentation
DocumentationVTK.cmake

This file serves up support fo' tha VTK documentation framework. Well shiiiit, it relies on nuff muthafuckin tools (Doxygen, Perl, etc).

.TP
.B ExternalData
Manage data filez stored outside source tree

Use dis module ta unambiguously reference data filez stored outside tha source tree n' fetch dem at build time from arbitrary local n' remote content\-addressed locations.  Functions provided by dis module recognize arguments wit tha syntax "DATA{<name>}" as references ta external data, replace dem wit full paths ta local copiez of dem data, n' create build rulez ta fetch n' update tha local copies.


Da DATA{} syntax is literal n' tha <name> be a gangbangin' full or relatizzle path within tha source tree.  Da source tree must contain either a real data file at <name> or a "content link" at <name><ext> containin a hash of tha real file rockin a hash algorithm correspondin ta <ext>.  For example, tha argument "DATA{img.png}" may be satisfied by either a real "img.png" file up in tha current source directory or a "img.png.md5" file containin its MD5 sum.


Da 'ExternalData_Expand_Arguments' function evaluates DATA{} references up in its arguments n' constructs a freshly smoked up list of arguments:


.nf
  ExternalData_Expand_Arguments(
    <target>   # Name of data pimpment target
    <outVar>   # Output variable
    [args...]  # Input arguments, DATA{} allowed
    )
.fi

It replaces each DATA{} reference up in a argument wit tha full path of a real data file on disk dat will exist afta tha <target> builds.


Da 'ExternalData_Add_Test' function wraps round tha CMake add_test() command but supports DATA{} references up in its arguments:


.nf
  ExternalData_Add_Test(
    <target>   # Name of data pimpment target
    ...        # Argumentz of add_test(), DATA{} allowed
    )
.fi

It passes its arguments all up in ExternalData_Expand_Arguments n' then invokes add_test() rockin tha thangs up in dis biatch.


Da 'ExternalData_Add_Target' function creates a cold-ass lil custom target ta manage local instancez of data filez stored externally:


.nf
  ExternalData_Add_Target(
    <target>   # Name of data pimpment target
    )
.fi

It creates custom commandz up in tha target as necessary ta make data filez available fo' each DATA{} reference previously evaluated by other functions provided by dis module.  A list of URL templates must be provided up in tha variable ExternalData_URL_TEMPLATES rockin tha placeholdaz "%(algo)" n' "%(hash)" up in each template.  Data fetch rulez try each URL template up in order by substitutin tha hash algorithm name fo' "%(algo)" n' tha hash value fo' "%(hash)".


Da followin hash algorithms is supported:


.nf
    %(algo)     <ext>     Description
    \-\-\-\-\-\-\-     \-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-
    MD5         .md5      Message\-Digest Algorithm 5, RFC 1321
    SHA1        .sha1     US Secure Hash Algorithm 1, RFC 3174
    SHA224      .sha224   US Secure Hash Algorithms, RFC 4634
    SHA256      .sha256   US Secure Hash Algorithms, RFC 4634
    SHA384      .sha384   US Secure Hash Algorithms, RFC 4634
    SHA512      .sha512   US Secure Hash Algorithms, RFC 4634
.fi

Note dat tha hashes is used only fo' unique data identification n' downlizzle verification. I aint talkin' bout chicken n' gravy biatch.  This aint securitizzle software.


Example usage:


.nf
   include(ExternalData)
   set(ExternalData_URL_TEMPLATES "file:///local/%(algo)/%(hash)"
                                  "http://data.org/%(algo)/%(hash)")
   ExternalData_Add_Test(MyData
     NAME MyTest
     COMMAND MyExe DATA{MyInput.png}
     )
   ExternalData_Add_Target(MyData)
.fi

When test "MyTest" runs tha "DATA{MyInput.png}" argument is ghon be replaced by tha full path ta a real instizzle of tha data file "MyInput.png" on disk.  If tha source tree gotz nuff a cold-ass lil content link like fuckin "MyInput.png.md5" then tha "MyData" target creates a real "MyInput.png" up in tha build tree.


Da DATA{} syntax can be holla'd at ta fetch a gangbangin' file series rockin tha form "DATA{<name>,:}", where tha ":" is literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha source tree gotz nuff a crew of filez or content links named like a series then a reference ta one member addz rulez ta fetch all of em.  Although all thugz of a series is fetched, only tha file originally named by tha DATA{} argument is substituted fo' dat shit.  Da default configuration recognizes file series names endin wit "#.ext", "_#.ext", ".#.ext", or "\-#.ext" where "#" be a sequence of decimal digits n' ".ext" be any single extension. I aint talkin' bout chicken n' gravy biatch.  Configure it wit a regex dat parses <number> n' <suffix> parts from tha end of <name>:


.nf
  ExternalData_SERIES_PARSE = regex of tha form (<number>)(<suffix>)$
.fi

For mo' fucked up cases set:


.nf
  ExternalData_SERIES_PARSE = regex wit at least two () groups
  ExternalData_SERIES_PARSE_PREFIX = <prefix> regex crew number, if any
  ExternalData_SERIES_PARSE_NUMBER = <number> regex crew number
  ExternalData_SERIES_PARSE_SUFFIX = <suffix> regex crew number
.fi

Configure series number matchin wit a regex dat matches tha <number> part of series thugz named <prefix><number><suffix>:


.nf
  ExternalData_SERIES_MATCH = regex matchin <number> up in all series members
.fi

Note dat tha <suffix> of a series do not include a hash\-algorithm extension.


Da DATA{} syntax can alternatively match filez associated wit tha named file n' contained up in tha same directory.  Associated filez may be specified by options rockin tha syntax DATA{<name>,<opt1>,<opt2>,...}.  Each option may specify one file by name or specify a regular expression ta match file names rockin tha syntax REGEX:<regex>.  For example, tha arguments


.nf
   DATA{MyData/MyInput.mhd,MyInput.img}                   # File pair
   DATA{MyData/MyFrames00.png,REGEX:MyFrames[0\-9]+\\\\.png} # Series
.fi

will pass MyInput.mha n' MyFrames00.png on tha command line but ensure dat tha associated filez is present next ta em.


Da DATA{} syntax may reference a gangbangin' finger-lickin' directory rockin a trailin slash n' a list of associated files.  Da form DATA{<name>/,<opt1>,<opt2>,...} addz rulez ta fetch any filez up in tha directory dat match one of tha associated file options.  For example, tha argument DATA{MyDataDir/,REGEX:.*} will pass tha full path ta a MyDataDir directory on tha command line n' ensure dat tha directory gotz nuff filez correspondin ta every last muthafuckin file or content link up in tha MyDataDir source directory.


Da variable ExternalData_LINK_CONTENT may be set ta tha name of a supported hash algorithm ta enable automatic conversion of real data filez referenced by tha DATA{} syntax tha fuck into content links.  For each such <file> a cold-ass lil content link named "<file><ext>" is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da original gangsta file is renamed ta tha form ".ExternalData_<algo>_<hash>" ta stage it fo' future transmission ta one of tha locations up in tha list of URL templates (by means outside tha scope of dis module).  Da data fetch rule pimped fo' tha content link will use tha staged object if it cannot be found rockin any URL template.


Da variable ExternalData_OBJECT_STORES may be set ta a list of local directories dat store objects rockin tha layout <dir>/%(algo)/%(hash). These directories is ghon be searched first fo' a needed object.  If tha object aint available up in any store then it is ghon be fetched remotely rockin tha URL templates n' added ta tha straight-up original gangsta local store listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no stores is specified tha default be a location inside tha build tree.


Da variable ExternalData_SOURCE_ROOT may be set ta tha highest source directory containin any path named by a DATA{} reference.  Da default is CMAKE_SOURCE_DIR.  ExternalData_SOURCE_ROOT n' CMAKE_SOURCE_DIR must refer ta directories within a single source distribution (e.g. they come together up in one tarball).


Da variable ExternalData_BINARY_ROOT may be set ta tha directory ta hold tha real data filez named by expanded DATA{} references.  Da default is CMAKE_BINARY_DIR.  Da directory layout will mirror dat of content links under ExternalData_SOURCE_ROOT.


Variablez ExternalData_TIMEOUT_INACTIVITY n' ExternalData_TIMEOUT_ABSOLUTE set tha downlizzle inactivitizzle n' absolute timeouts, up in seconds.  Da defaults is 60 secondz n' 300 seconds, respectively.  Set either timeout ta 0 secondz ta disable enforcement.

.TP
.B ExternalProject
Smoke custom targets ta build projects up in external trees

Da 'ExternalProject_Add' function creates a cold-ass lil custom target ta drive download, update/patch, configure, build, install n' test stepz of a external project:


.nf
  ExternalProject_Add(<name>    # Name fo' custom target
    [DEPENDS projects...]       # Targets on which tha project depends
    [PREFIX dir]                # Root dir fo' entire project
    [LIST_SEPARATOR sep]        # Sep ta be replaced by ; up in cmd lines
    [TMP_DIR dir]               # Directory ta store temporary files
    [STAMP_DIR dir]             # Directory ta store step timestamps
   #\-\-Downlizzle step\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [DOWNLOAD_NAME fname]       # File name ta store (if not end of URL)
    [DOWNLOAD_DIR dir]          # Directory ta store downloaded files
    [DOWNLOAD_COMMAND cmd...]   # Command ta downlizzle source tree
    [CVS_REPOSITORY cvsroot]    # CVSROOT of CVS repository
    [CVS_MODULE mod]            # Module ta checkout from CVS repo
    [CVS_TAG tag]               # Tag ta checkout from CVS repo
    [SVN_REPOSITORY url]        # URL of Subversion repo
    [SVN_REVISION rev]          # Revision ta checkout from Subversion repo
    [SVN_USERNAME john ]        # Username fo' Subversion checkout n' update
    [SVN_PASSWORD doe ]         # Password fo' Subversion checkout n' update
    [SVN_TRUST_CERT 1 ]         # Trust tha Subversion server joint certificate
    [GIT_REPOSITORY url]        # URL of git repo
    [GIT_TAG tag]               # Git branch name, commit id or tag
    [HG_REPOSITORY url]         # URL of mercurial repo
    [HG_TAG tag]                # Mercurial branch name, commit id or tag
    [URL /.../src.tgz]          # Full path or URL of source
    [URL_HASH ALGO=value]       # Hash of file at URL
    [URL_MD5 md5]               # Equivalent ta URL_HASH MD5=md5
    [TLS_VERIFY bool]           # Should certificate fo' https be checked
    [TLS_CAINFO file]           # Path ta a cold-ass lil certificate authoritizzle file
    [TIMEOUT seconds]           # Time allowed fo' file downlizzle operations
   #\-\-Update/Patch step\-\-\-\-\-\-\-\-\-\-
    [UPDATE_COMMAND cmd...]     # Source work\-tree update command
    [PATCH_COMMAND cmd...]      # Command ta patch downloaded source
   #\-\-Configure step\-\-\-\-\-\-\-\-\-\-\-\-\-
    [SOURCE_DIR dir]            # Source dir ta be used fo' build
    [CONFIGURE_COMMAND cmd...]  # Build tree configuration command
    [CMAKE_COMMAND /.../cmake]  # Specify alternatizzle cmake executable
    [CMAKE_GENERATOR gen]       # Specify generator fo' natizzle build
    [CMAKE_GENERATOR_TOOLSET t] # Generator\-specific toolset name
    [CMAKE_ARGS args...]        # Arguments ta CMake command line
    [CMAKE_CACHE_ARGS args...]  # Initial cache arguments, of tha form \-Dvar:string=on
   #\-\-Build step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [BINARY_DIR dir]            # Specify build dir location
    [BUILD_COMMAND cmd...]      # Command ta drive tha natizzle build
    [BUILD_IN_SOURCE 1]         # Use source dir fo' build dir
   #\-\-Install step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [INSTALL_DIR dir]           # Installation prefix
    [INSTALL_COMMAND cmd...]    # Command ta drive install afta build
   #\-\-Test step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [TEST_BEFORE_INSTALL 1]     # Add test step executed before install step
    [TEST_AFTER_INSTALL 1]      # Add test step executed afta install step
    [TEST_COMMAND cmd...]       # Command ta drive test
   #\-\-Output logging\-\-\-\-\-\-\-\-\-\-\-\-\-
    [LOG_DOWNLOAD 1]            # Wrap downlizzle up in script ta log output
    [LOG_UPDATE 1]              # Wrap update up in script ta log output
    [LOG_CONFIGURE 1]           # Wrap configure up in script ta log output
    [LOG_BUILD 1]               # Wrap build up in script ta log output
    [LOG_TEST 1]                # Wrap test up in script ta log output
    [LOG_INSTALL 1]             # Wrap install up in script ta log output
   #\-\-Custom targets\-\-\-\-\-\-\-\-\-\-\-\-\-
    [STEP_TARGETS st1 st2 ...]  # Generate custom targets fo' these steps
    )
.fi

Da *_DIR options specify directories fo' tha project, wit default directories computed as bigs up. If tha PREFIX option is given ta ExternalProject_Add() or tha EP_PREFIX directory property is set, then a external project is built n' installed under tha specified prefix:


.nf
   TMP_DIR      = <prefix>/tmp
   STAMP_DIR    = <prefix>/src/<name>\-stamp
   DOWNLOAD_DIR = <prefix>/src
   SOURCE_DIR   = <prefix>/src/<name>
   BINARY_DIR   = <prefix>/src/<name>\-build
   INSTALL_DIR  = <prefix>
.fi

Otherwise, if tha EP_BASE directory property is set then componentz of a external project is stored under tha specified base:


.nf
   TMP_DIR      = <base>/tmp/<name>
   STAMP_DIR    = <base>/Stamp/<name>
   DOWNLOAD_DIR = <base>/Download/<name>
   SOURCE_DIR   = <base>/Source/<name>
   BINARY_DIR   = <base>/Build/<name>
   INSTALL_DIR  = <base>/Install/<name>
.fi

If no PREFIX, EP_PREFIX, or EP_BASE is specified then tha default is ta set PREFIX ta "<name>\-prefix". Relatizzle paths is interpreted wit respect ta tha build directory correspondin ta tha source directory up in which ExternalProject_Add is invoked.


If SOURCE_DIR is explicitly set ta a existin directory tha project is ghon be built from dat shit. Otherwise a thugged-out downlizzle step must be specified rockin one of tha DOWNLOAD_COMMAND, CVS_*, SVN_*, or URL options. Da URL option may refer locally ta a gangbangin' finger-lickin' directory or source tarball, or refer ta a remote tarbizzle (e.g. http://.../src.tgz).


Da 'ExternalProject_Add_Step' function addz a cold-ass lil custom step ta a external project:


.nf
  ExternalProject_Add_Step(<name> <step> # Namez of project n' custom step
    [COMMAND cmd...]        # Command line invoked by dis step
    [COMMENT "text..."]     # Text printed when step executes
    [DEPENDEES steps...]    # Steps on which dis step depends
    [DEPENDERS steps...]    # Steps dat depend on dis step
    [DEPENDS files...]      # Filez on which dis step depends
    [ALWAYS 1]              # No stamp file, step always runs
    [WORKING_DIRECTORY dir] # Workin directory fo' command
    [LOG 1]                 # Wrap step up in script ta log output
    )
.fi

Da command line, comment, n' hustlin directory of every last muthafuckin standard n' custom step is processed ta replace tokens <SOURCE_DIR>, <BINARY_DIR>, <INSTALL_DIR>, n' <TMP_DIR> wit correspondin property joints.


Any builtin step dat specifies a "<step>_COMMAND cmd..." or custom step dat specifies a "COMMAND cmd..." may specify additionizzle command lines rockin tha form "COMMAND cmd...".  At build time tha commandz is ghon be executed up in order n' aborted if any one fails.  For example:


.nf
  ... BUILD_COMMAND make COMMAND echo done ...
.fi

specifies ta run "make" n' then "echo done" durin tha build step. Whether tha current hustlin directory is preserved between commandz aint defined. Y'all KNOW dat shit, muthafucka!  Behavior of shell operators like "&&" aint defined.


Da 'ExternalProject_Get_Property' function retrieves external project target properties:


.nf
  ExternalProject_Get_Property(<name> [prop1 [prop2 [...]]])
.fi

It stores property joints up in variablez of tha same name. Property names correspond ta tha keyword argument namez of 'ExternalProject_Add'.


Da 'ExternalProject_Add_StepTargets' function generates custom targets fo' tha steps listed:


.nf
  ExternalProject_Add_StepTargets(<name> [step1 [step2 [...]]])
.fi




If STEP_TARGETS is set then ExternalProject_Add_StepTargets be automatically called all up in tha end of matchin calls ta ExternalProject_Add_Step. Pass STEP_TARGETS explicitly ta individual ExternalProject_Add calls, or implicitly ta all ExternalProject_Add calls by settin tha directory property EP_STEP_TARGETS.


If STEP_TARGETS aint set, clients may still manually call ExternalProject_Add_StepTargets afta callin ExternalProject_Add or ExternalProject_Add_Step.


This functionalitizzle is provided ta make it easy as fuck  ta drive tha steps independently of each other by specifyin targets on build command lines. For example, you may be submittin ta a sub\-project based dashboard, where you wanna drive tha configure portion of tha build, then submit ta tha dashboard, followed by tha build portion, followed by tests, n' you can put dat on yo' toast. If you invoke a cold-ass lil custom target dat dependz on a step halfway all up in tha step dependency chain, then all tha previous steps will also run ta ensure every last muthafuckin thang is up ta date.


For example, ta drive configure, build n' test steps independently fo' each ExternalProject_Add call up in yo' project, write tha followin line prior ta any ExternalProject_Add calls up in yo' CMakeLists file:


.nf
   set_property(DIRECTORY PROPERTY EP_STEP_TARGETS configure build test)
.fi

.TP
.B FeatureSummary
Macros fo' generatin a summary of enabled/disabled features




This module serves up tha macros feature_summary(), set_package_properties() n' add_feature_info(). For compatibilitizzle it also still serves up set_package_info(), set_feature_info(), print_enabled_features() n' print_disabled_features().


These macros can be used ta generate a summary of enabled n' disabled packages and/or feature fo' a funky-ass build tree:


.nf
    \-\- Da followin OPTIONAL packages done been found:
    LibXml2 (required version >= 2.4) , XML processin library. , <http://xmlsoft.org>
       * Enablez HTML\-import up in MyWordProcessor
       * Enablez odt\-export up in MyWordProcessor
    PNG , A PNG image library. , <http://www.libpng.org/pub/png/>
       * Enablez savin screenshots
    \-\- Da followin OPTIONAL packages aint been found:
    Lua51 , Da Lua scriptin language. , <http://www.lua.org>
       * Enablez macros up in MyWordProcessor
    Foo , Foo serves up def stuff.
.fi







.nf
    FEATURE_SUMMARY( [FILENAME <file>]
                     [APPEND]
                     [VAR <variable_name>]
                     [INCLUDE_QUIET_PACKAGES]
                     [FATAL_ON_MISSING_REQUIRED_PACKAGES]
                     [DESCRIPTION "Found packages:"]
                     WHAT (ALL | PACKAGES_FOUND | PACKAGES_NOT_FOUND
                          | ENABLED_FEATURES | DISABLED_FEATURES]
                   )
.fi




Da FEATURE_SUMMARY() macro can be used ta print shiznit bout enabled or disabled packages or featurez of a project. By default, only tha namez of tha features/packages is ghon be printed n' they required version when one was specified. Y'all KNOW dat shit, muthafucka! Use SET_PACKAGE_PROPERTIES() ta add mo' useful shiznit, like e.g. a thugged-out downlizzle URL fo' tha respectizzle package or they purpose up in tha project.


Da WHAT option is tha only mandatory option. I aint talkin' bout chicken n' gravy biatch yo. Here you specify what tha fuck shiznit is ghon be printed:


.nf
    ALL: print every last muthafuckin thang
    ENABLED_FEATURES: tha list of all features which is enabled
    DISABLED_FEATURES: tha list of all features which is disabled
    PACKAGES_FOUND: tha list of all packages which done been found
    PACKAGES_NOT_FOUND: tha list of all packages which aint been found
    OPTIONAL_PACKAGES_FOUND: only dem packages which done been found which have tha type OPTIONAL
    OPTIONAL_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type OPTIONAL
    RECOMMENDED_PACKAGES_FOUND: only dem packages which done been found which have tha type RECOMMENDED
    RECOMMENDED_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type RECOMMENDED
    REQUIRED_PACKAGES_FOUND: only dem packages which done been found which have tha type REQUIRED
    REQUIRED_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type REQUIRED
    RUNTIME_PACKAGES_FOUND: only dem packages which done been found which have tha type RUNTIME
    RUNTIME_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type RUNTIME
.fi




If a FILENAME is given, tha shiznit is printed tha fuck into dis file. If APPEND is used, it be appended ta dis file, otherwise tha file is overwritten if it already existed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha VAR option is used, tha shiznit is "printed" tha fuck into tha specified variable. If FILENAME aint used, tha shiznit is printed ta tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Usin tha DESCRIPTION option a thugged-out description or headline can be set which is ghon be printed above tha actual content. If INCLUDE_QUIET_PACKAGES is given, packages which done been searched wit find_package(... QUIET) will also be listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default they is skipped. Y'all KNOW dat shit, muthafucka! If FATAL_ON_MISSING_REQUIRED_PACKAGES is given, CMake will abort if a package which is marked as REQUIRED has not been found.


Example 1, append every last muthafuckin thang ta a gangbangin' file:


.nf
   feature_summary(WHAT ALL
                   FILENAME ${CMAKE_BINARY_DIR}/all.log APPEND)
.fi




Example 2, print tha enabled features tha fuck into tha variable enabledFeaturesText, includin QUIET packages:


.nf
   feature_summary(WHAT ENABLED_FEATURES
                   INCLUDE_QUIET_PACKAGES
                   DESCRIPTION "Enabled Features:"
                   VAR enabledFeaturesText)
   message(STATUS "${enabledFeaturesText}")
.fi







.nf
    SET_PACKAGE_PROPERTIES(<name> PROPERTIES [ URL <url> ]
                                             [ DESCRIPTION <description> ]
                                             [ TYPE (RUNTIME|OPTIONAL|RECOMMENDED|REQUIRED) ]
                                             [ PURPOSE <purpose> ]
                          )
.fi




Use dis macro ta set up shiznit bout tha named package, which can then be displayed via FEATURE_SUMMARY(). This can be done either directly up in tha Find\-module or up in tha project which uses tha module afta tha find_package() call. Da features fo' which shiznit can be set is added automatically by tha find_package() command.


URL: dis should be tha homepizzy of tha package, or suttin' similar. Shiiit, dis aint no joke. Ideally dis is set already directly up in tha Find\-module.


DESCRIPTION: A short description what tha fuck dat package is, at most one sentence. Ideally dis is set already directly up in tha Find\-module.


TYPE: What type of dependency has tha rockin project on dat package. Default is OPTIONAL. In dis case it aint nuthin but a package which can be used by tha project when available at buildtime yo, but it also work without. RECOMMENDED is similar ta OPTIONAL, i.e. tha project will build if tha package aint present yo, but tha functionalitizzle of tha resultin binaries is ghon be severly limited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a REQUIRED package aint available at buildtime, tha project may not even build. Y'all KNOW dat shit, muthafucka! This can be combined wit tha FATAL_ON_MISSING_REQUIRED_PACKAGES argument fo' feature_summary(). Last, a RUNTIME package be a package which is straight-up not used at all durin tha build yo, but which is required fo' straight-up hustlin tha resultin binaries. Put ya muthafuckin choppers up if ya feel dis! Right back up in yo muthafuckin ass. So if such a package is missing, tha project can still be built yo, but it may not work lata on. I aint talkin' bout chicken n' gravy biatch. If set_package_properties() is called multiple times fo' tha same package wit different TYPEs, tha TYPE is only chizzled ta higher TYPEs ( RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED ), lower TYPEs is ignored. Y'all KNOW dat shit, muthafucka! Da TYPE property is project\-specific, so it cannot be set by tha Find\-module yo, but must be set up in tha project.


PURPOSE: This raps bout which features dis package enablez up in tha project, i.e. it  drops some lyrics ta tha user what tha fuck functionalitizzle he gets up in tha resultin binaries. Put ya muthafuckin choppers up if ya feel dis! If set_package_properties() is called multiple times fo' a package, all PURPOSE propertizzles is appended ta a list of purposez of tha package up in tha project fo' realz. As tha TYPE property, also tha PURPOSE property is project\-specific, so it cannot be set by tha Find\-module yo, but must be set up in tha project.





Example fo' settin tha info fo' a package:


.nf
   find_package(LibXml2)
   set_package_properties(LibXml2 PROPERTIES DESCRIPTION "A XML processin library."
                                             URL "http://xmlsoft.org/")
.fi




.nf
   set_package_properties(LibXml2 PROPERTIES TYPE RECOMMENDED
                                             PURPOSE "Enablez HTML\-import up in MyWordProcessor")
   ...
   set_package_properties(LibXml2 PROPERTIES TYPE OPTIONAL
                                             PURPOSE "Enablez odt\-export up in MyWordProcessor")
.fi




.nf
   find_package(DBUS)
   set_package_properties(DBUS PROPERTIES TYPE RUNTIME
                                             PURPOSE "Necessary ta disable tha screensaver durin a presentation" )
.fi




.nf
    ADD_FEATURE_INFO(<name> <enabled> <description>)
.fi

Use dis macro ta add shiznit on some gangbangin' feature wit tha given <name>. <enabled> gotz nuff whether dis feature is enabled or not, <description> be a text describin tha feature. Da shiznit can be displayed rockin feature_summary() fo' ENABLED_FEATURES n' DISABLED_FEATURES respectively.


Example fo' settin tha info fo' a gangbangin' feature:


.nf
   option(WITH_FOO "Help fo' foo" ON)
   add_feature_info(Foo WITH_FOO "Da Foo feature serves up straight-up def stuff.")
.fi







Da followin macros is provided fo' compatibilitizzle wit previous CMake versions:


.nf
    SET_PACKAGE_INFO(<name> <description> [<url> [<purpose>] ] )
.fi

Use dis macro ta set up shiznit bout tha named package, which can then be displayed via FEATURE_SUMMARY(). This can be done either directly up in tha Find\-module or up in tha project which uses tha module afta tha find_package() call. Da features fo' which shiznit can be set is added automatically by tha find_package() command.


.nf
    PRINT_ENABLED_FEATURES()
.fi

Do tha same as FEATURE_SUMMARY(WHAT ENABLED_FEATURES  DESCRIPTION "Enabled features:")


.nf
    PRINT_DISABLED_FEATURES()
.fi

Do tha same as FEATURE_SUMMARY(WHAT DISABLED_FEATURES  DESCRIPTION "Disabled features:")


.nf
    SET_FEATURE_INFO(<name> <description> [<url>] )
.fi

Do tha same as SET_PACKAGE_INFO(<name> <description> <url> )

.TP
.B FindALSA
Find alsa

Find tha alsa libraries (asound)


.nf
  This module defines tha followin variables:
     ALSA_FOUND       \- True if ALSA_INCLUDE_DIR & ALSA_LIBRARY is found
     ALSA_LIBRARIES   \- Set when ALSA_LIBRARY is found
     ALSA_INCLUDE_DIRS \- Set when ALSA_INCLUDE_DIR is found
.fi




.nf
     ALSA_INCLUDE_DIR \- where ta find asoundlib.h, etc.
     ALSA_LIBRARY     \- tha asound library
     ALSA_VERSION_STRING \- tha version of alsa found (since CMake 2.8.8)
.fi




.TP
.B FindASPELL
Try ta find ASPELL

Once done dis will define


.nf
  ASPELL_FOUND \- system has ASPELL
  ASPELL_EXECUTABLE \- tha ASPELL executable
  ASPELL_INCLUDE_DIR \- tha ASPELL include directory
  ASPELL_LIBRARIES \- Da libraries needed ta use ASPELL
  ASPELL_DEFINITIONS \- Compila switches required fo' rockin ASPELL
.fi

.TP
.B FindAVIFile
Locate AVIFILE library n' include paths

AVIFILE (http://avifile.sourceforge.net/)is a set of libraries fo' i386 machines ta use various AVI codecs. Right back up in yo muthafuckin ass. Support is limited beyond Linux. Windows serves up natizzle AVI support, n' so don't need dis library. This module defines


.nf
  AVIFILE_INCLUDE_DIR, where ta find avifile.h , etc.
  AVIFILE_LIBRARIES, tha libraries ta link against
  AVIFILE_DEFINITIONS, definitions ta use when compiling
  AVIFILE_FOUND, If false, don't try ta use AVIFILE
.fi

.TP
.B FindArmadillo
Find Armadillo

Find tha Armadillo C++ library


Usin Armadillo:


.nf
  find_package(Armadillo REQUIRED)
  include_directories(${ARMADILLO_INCLUDE_DIRS})
  add_executable(foo foo.cc)
  target_link_libraries(foo ${ARMADILLO_LIBRARIES})
.fi

This module sets tha followin variables:


.nf
  ARMADILLO_FOUND \- set ta legit if tha library is found
  ARMADILLO_INCLUDE_DIRS \- list of required include directories
  ARMADILLO_LIBRARIES \- list of libraries ta be linked
  ARMADILLO_VERSION_MAJOR \- major version number
  ARMADILLO_VERSION_MINOR \- minor version number
  ARMADILLO_VERSION_PATCH \- patch version number
  ARMADILLO_VERSION_STRING \- version number as a strang (ex: "1.0.4")
  ARMADILLO_VERSION_NAME \- name of tha version (ex: "Antipodean Antileech")
.fi

.TP
.B FindBISON
Find bison executable n' serves up macros ta generate custom build rules

Da module defines tha followin variables:


.nf
  BISON_EXECUTABLE \- path ta tha bison program
  BISON_VERSION \- version of bison
  BISON_FOUND \- legit if tha program was found
.fi




Da minimum required version of bison can be specified rockin tha standard CMake syntax, e.g. find_package(BISON 2.1.3)


If bison is found, tha module defines tha macros:


.nf
  BISON_TARGET(<Name> <YaccInput> <CodeOutput> [VERBOSE <file>]
              [COMPILE_FLAGS <string>])
.fi

which will create  a cold-ass lil custom rule ta generate  a parser n' shit. <YaccInput> is tha path ta  a yacc file. <CodeOutput> is tha name  of tha source file generated by bison. I aint talkin' bout chicken n' gravy biatch.  A header file be also  be generated, n' gotz nuff tha  token  list.  If  COMPILE_FLAGS  option is  specified,  tha  next parameta is  added up in tha bison  command line.  if  VERBOSE option is specified, <file> is pimped  n' gotz nuff verbose descriptionz of tha grammar n' parser n' shit. Da macro defines a set of variables:


.nf
  BISON_${Name}_DEFINED \- legit is tha macro ran successfully
  BISON_${Name}_INPUT \- Da input source file, a alias fo' <YaccInput>
  BISON_${Name}_OUTPUT_SOURCE \- Da source file generated by bison
  BISON_${Name}_OUTPUT_HEADER \- Da header file generated by bison
  BISON_${Name}_OUTPUTS \- Da sources filez generated by bison
  BISON_${Name}_COMPILE_FLAGS \- Options used up in tha bison command line
.fi




.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(BISON)
   BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
   add_executable(Foo main.cpp ${BISON_MyParser_OUTPUTS})
  ====================================================================
.fi

.TP
.B FindBLAS
Find BLAS library

This module findz a installed fortran library dat implements tha BLAS linear\-algebra intercourse (see http://www.netlib.org/blas/). Da list of libraries searched fo' is taken from tha autoconf macro file, acx_blas.m4 (distributed at http://ac\-archive.sourceforge.net/ac\-archive/acx_blas.html).


This module sets tha followin variables:


.nf
  BLAS_FOUND \- set ta legit if a library implementin tha BLAS intercourse
    is found
  BLAS_LINKER_FLAGS \- uncached list of required linker flags (excludin \-l
    n' \-L).
  BLAS_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use BLAS
  BLAS95_LIBRARIES \- uncached list of libraries (usin full path name)
    ta link against ta use BLAS95 intercourse
  BLAS95_FOUND \- set ta legit if a library implementin tha BLAS f95 intercourse
    is found
  BLA_STATIC  if set on dis determines what tha fuck kind of linkage our phat asses do (static)
  BLA_VENDOR  if set checks only tha specified vendor, if not set checks
     all tha possibilities
  BLA_F95     if set on tries ta find tha f95 intercourses fo' BLAS/LAPACK
.fi

C/CXX should be enabled ta use Intel mkl

.TP
.B FindBZip2
Try ta find BZip2

Once done dis will define


.nf
  BZIP2_FOUND \- system has BZip2
  BZIP2_INCLUDE_DIR \- tha BZip2 include directory
  BZIP2_LIBRARIES \- Link these ta use BZip2
  BZIP2_NEED_PREFIX \- dis is set if tha functions is prefixed wit BZ2_
  BZIP2_VERSION_STRING \- tha version of BZip2 found (since CMake 2.8.8)
.fi

.TP
.B FindBoost
Find Boost include dirs n' libraries

Use dis module by invokin find_package wit tha form:


.nf
  find_package(Boost
    [version] [EXACT]      # Minimum or EXACT version e.g. 1.36.0
    [REQUIRED]             # Fail wit error if Boost aint found
    [COMPONENTS <libs>...] # Boost libraries by they canonical name
    )                      # e.g. "date_time" fo' "libboost_date_time"
.fi

This module findz headaz n' axed component libraries OR a CMake package configuration file provided by a "Boost CMake" build. Y'all KNOW dat shit, muthafucka!  For tha latta case skip ta tha "Boost CMake" section below.  For tha forma case thangs up in dis biatch is reported up in variables:


.nf
  Boost_FOUND            \- True if headaz n' axed libraries was found
  Boost_INCLUDE_DIRS     \- Boost include directories
  Boost_LIBRARY_DIRS     \- Link directories fo' Boost libraries
  Boost_LIBRARIES        \- Boost component libraries ta be linked
  Boost_<C>_FOUND        \- True if component <C> was found (<C> is upper\-case)
  Boost_<C>_LIBRARY      \- Libraries ta link fo' component <C> (may include
                           target_link_libraries debug/optimized keywords)
  Boost_VERSION          \- BOOST_VERSION value from boost/version.hpp
  Boost_LIB_VERSION      \- Version strang appended ta library filenames
  Boost_MAJOR_VERSION    \- Boost major version number (X up in X.y.z)
  Boost_MINOR_VERSION    \- Boost minor version number (Y up in x.Y.z)
  Boost_SUBMINOR_VERSION \- Boost subminor version number (Z up in x.y.Z)
  Boost_LIB_DIAGNOSTIC_DEFINITIONS (Windows)
                         \- Pass ta add_definitions() ta have diagnostic
                           shiznit bout Boostz automatic linking
                           displayed durin compilation
.fi




This module readz hints bout search locations from variables:


.nf
  BOOST_ROOT             \- Preferred installation prefix
   (or BOOSTROOT)
  BOOST_INCLUDEDIR       \- Preferred include directory e.g. <prefix>/include
  BOOST_LIBRARYDIR       \- Preferred library directory e.g. <prefix>/lib
  Boost_NO_SYSTEM_PATHS  \- Set ta ON ta disable searchin up in locations not
                           specified by these hint variables. Default is OFF.
  Boost_ADDITIONAL_VERSIONS
                         \- List of Boost versions not known ta dis module
                           (Boost install locations may contain tha version)
.fi

and saves search thangs up in dis biatch persistently up in CMake cache entries:


.nf
  Boost_INCLUDE_DIR         \- Directory containin Boost headers
  Boost_LIBRARY_DIR         \- Directory containin Boost libraries
  Boost_<C>_LIBRARY_DEBUG   \- Component <C> library debug variant
  Boost_<C>_LIBRARY_RELEASE \- Component <C> library release variant
.fi

Users may set these hints or thangs up in dis biatch as cache entries. Put ya muthafuckin choppers up if ya feel dis!  Projects should not read these entries directly but instead use tha above result variables. Note dat some hint names start up in upper\-case "BOOST".  One may specify these as environment variablez if they is not specified as CMake variablez or cache entries.


This module first searches fo' tha Boost header filez rockin tha above hint variablez (excludin BOOST_LIBRARYDIR) n' saves tha result up in Boost_INCLUDE_DIR.  Then it searches fo' axed component libraries rockin tha above hints (excludin BOOST_INCLUDEDIR n' Boost_ADDITIONAL_VERSIONS), "lib" directories near Boost_INCLUDE_DIR, n' tha library name configuration settings below.  It saves tha library directory up in Boost_LIBRARY_DIR n' individual library locations up in Boost_<C>_LIBRARY_DEBUG n' Boost_<C>_LIBRARY_RELEASE.  When one chizzlez settings used by previous searches up in tha same build tree (excludin environment variables) dis module discardz previous search thangs up in dis biatch affected by tha chizzlez n' searches again.


Boost libraries come up in nuff variants encoded up in they file name.  Users or projects may tell dis module which variant ta find by settin variables:


.nf
  Boost_USE_MULTITHREADED  \- Set ta OFF ta use tha non\-multithreaded
                             libraries ('mt' tag).  Default is ON.
  Boost_USE_STATIC_LIBS    \- Set ta ON ta force tha use of tha static
                             libraries. Put ya muthafuckin choppers up if ya feel dis!  Default is OFF.
  Boost_USE_STATIC_RUNTIME \- Set ta ON or OFF ta specify whether ta use
                             libraries linked statically ta tha C++ runtime
                             ('s' tag).  Default is platform dependent.
  Boost_USE_DEBUG_PYTHON   \- Set ta ON ta use libraries compiled wit a
                             debug Python build ('y' tag). Default is OFF.
  Boost_USE_STLPORT        \- Set ta ON ta use libraries compiled with
                             STLPort ('p' tag).  Default is OFF.
  Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS
                           \- Set ta ON ta use libraries compiled with
                             STLPort deprecated "natizzle iostreams"
                             ('n' tag).  Default is OFF.
  Boost_COMPILER           \- Set ta tha compiler\-specific library suffix
                             (e.g. "\-gcc43").  Default be auto\-computed
                             fo' tha C++ compila up in use.
  Boost_THREADAPI          \- Suffix fo' "thread" component library name,
                             like fuckin "pthread" or "win32".  Names with
                             n' without dis suffix will both be tried.
.fi

Other variablez one may set ta control dis module are:


.nf
  Boost_DEBUG              \- Set ta ON ta enable debug output from FindBoost.
                             Please enable dis before filin any bug report.
  Boost_DETAILED_FAILURE_MSG
                           \- Set ta ON ta add detailed shiznit ta the
                             failure message even when tha REQUIRED option
                             aint given ta tha find_package call.
  Boost_REALPATH           \- Set ta ON ta resolve symlinks fo' discovered
                             libraries ta assist wit packaging.  For example,
                             tha "system" component library may be resolved to
                             "/usr/lib/libboost_system.so.1.42.0" instead of
                             "/usr/lib/libboost_system.so".  This do not
                             affect linkin n' should not be enabled unless
                             tha user needz dis shiznit.
.fi

On Visual Studio n' Borland compilaz Boost headaz request automatic linkin ta correspondin libraries. Put ya muthafuckin choppers up if ya feel dis!  This requires matchin libraries ta be linked explicitly or available up in tha link library search path.  In dis case settin Boost_USE_STATIC_LIBS ta OFF may not big up dynamic linking. Boost automatic linkin typically requests static libraries wit all dem exceptions (like fuckin Boost.Python).  Use


.nf
  add_definitions(${Boost_LIB_DIAGNOSTIC_DEFINITIONS})
.fi

to ask Boost ta report shiznit bout automatic linkin requests.


Example ta find Boost headaz only:


.nf
  find_package(Boost 1.36.0)
  if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    add_executable(foo foo.cc)
  endif()
.fi

Example ta find Boost headaz n' some libraries:


.nf
  set(Boost_USE_STATIC_LIBS        ON)
  set(Boost_USE_MULTITHREADED      ON)
  set(Boost_USE_STATIC_RUNTIME    OFF)
  find_package(Boost 1.36.0 COMPONENTS date_time filesystem system ...)
  if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    add_executable(foo foo.cc)
    target_link_libraries(foo ${Boost_LIBRARIES})
  endif()
.fi




Boost CMake \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-


If Boost was built rockin tha boost\-cmake project it serves up a package configuration file fo' use wit find_packagez Config mode.  This module looks fo' tha package configuration file called BoostConfig.cmake or boost\-config.cmake n' stores tha result up in cache entry "Boost_DIR".  If found, tha package configuration file is loaded n' dis module returns wit no further action. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha Boost CMake package configuration fo' details on what tha fuck it provides.


Set Boost_NO_BOOST_CMAKE ta ON ta disable tha search fo' boost\-cmake.

.TP
.B FindBullet
Try ta find tha Cap physics engine




.nf
  This module defines tha followin variables
.fi




.nf
  BULLET_FOUND \- Was cap found
  BULLET_INCLUDE_DIRS \- tha Cap include directories
  BULLET_LIBRARIES \- Link ta this, by default it includes
                     all cap components (Dynamics,
                     Collision, LinearMath, & SoftBody)
.fi




.nf
  This module accepts tha followin variables
.fi




.nf
  BULLET_ROOT \- Can be set ta cap install path or Windows build path
.fi




.TP
.B FindCABLE
Find CABLE

This module findz if CABLE is installed n' determines where tha include filez n' libraries are.  This code sets tha followin variables:


.nf
  CABLE             tha path ta tha cable executable
  CABLE_TCL_LIBRARY tha path ta tha Tcl wrapper library
  CABLE_INCLUDE_DIR tha path ta tha include directory
.fi




To build Tcl wrappers, you should add shared library n' link it ta ${CABLE_TCL_LIBRARY}.  Yo ass should also add ${CABLE_INCLUDE_DIR} as a include directory.

.TP
.B FindCUDA
Tools fo' buildin CUDA C files: libraries n' build dependencies.

This script locates tha NVIDIA CUDA C tools. Well shiiiit, it should work on linux, windows, n' mac n' should be reasonably up ta date wit CUDA C releases.


This script make use of tha standard find_package argumentz of <VERSION>, REQUIRED n' QUIET.  CUDA_FOUND will report if a aaight version of CUDA was found.


Da script will prompt tha user ta specify CUDA_TOOLKIT_ROOT_DIR if tha prefix cannot be determined by tha location of nvcc up in tha system path n' REQUIRED is specified ta find_package(). To bust a gangbangin' finger-lickin' different installed version of tha toolkit set tha environment variable CUDA_BIN_PATH before hustlin cmake (e.g. CUDA_BIN_PATH=/usr/local/cuda1.0 instead of tha default /usr/local/cuda) or set CUDA_TOOLKIT_ROOT_DIR afta configuring.  If you chizzle tha value of CUDA_TOOLKIT_ROOT_DIR, various components dat depend on tha path is ghon be relocated.


It might be necessary ta set CUDA_TOOLKIT_ROOT_DIR manually on certain platforms, or ta bust a cold-ass lil cuda runtime not installed up in tha default location. I aint talkin' bout chicken n' gravy biatch. In newer versionz of tha toolkit tha cuda library is included wit tha graphics driver\- be shizzle dat tha driver version matches what tha fuck is needed by tha cuda runtime version.


Da followin variablez affect tha behavior of tha macros up in tha script (in alphebetical order).  Note dat any of these flags can be chizzled multiple times up in tha same directory before callin CUDA_ADD_EXECUTABLE, CUDA_ADD_LIBRARY, CUDA_COMPILE, CUDA_COMPILE_PTX or CUDA_WRAP_SRCS.


.nf
  CUDA_64_BIT_DEVICE_CODE (Default matches host bit size)
  \-\- Set ta ON ta compile fo' 64 bit thang code, OFF fo' 32 bit thang code.
     Note dat makin dis different from tha host code when generatin object
     or C filez from CUDA code just won't work, cuz size_t gets defined by
     nvcc up in tha generated source.  If you compile ta PTX n' then load the
     file yo ass, you can mix bit sizes between thang n' host.
.fi




.nf
  CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE (Default ON)
  \-\- Set ta ON if you want tha custom build rule ta be attached ta tha source
     file up in Visual Studio.  Turn OFF if you add tha same cuda file ta multiple
     targets.
.fi




.nf
     This allows tha user ta build tha target from tha CUDA file; however, bad
     thangs can happen if tha CUDA source file be added ta multiple targets.
     When struttin parallel buildz it is possible fo' tha custom build
     command ta be run mo' than once n' up in parallel causin cryptic build
     errors.  VS runs tha rulez fo' every last muthafuckin source file up in tha target, n' a
     source can have only one rule no matta how tha fuck nuff projects it be added to.
     When tha rule is run from multiple targets race conditions can occur on
     tha generated file.  Eventually every last muthafuckin thang will git built yo, but if tha user
     is unaware of dis behavior, there may be mad drama.  It would be sick if
     dis script could detect tha reuse of source filez across multiple targets
     n' turn tha option off fo' tha user yo, but no phat solution could be found.
.fi




.nf
  CUDA_BUILD_CUBIN (Default OFF)
  \-\- Set ta ON ta enable n' extra compilation pass wit tha \-cubin option in
     Device mode. Da output is parsed n' register, shared memory usage is
     printed durin build.
.fi




.nf
  CUDA_BUILD_EMULATION (Default OFF fo' thang mode)
  \-\- Set ta ON fo' Emulation mode. \-D_DEVICEEMU is defined fo' CUDA C files
     when CUDA_BUILD_EMULATION is TRUE.
.fi




.nf
  CUDA_GENERATED_OUTPUT_DIR (Default CMAKE_CURRENT_BINARY_DIR)
  \-\- Set ta tha path you wish ta have tha generated filez placed. Y'all KNOW dat shit, muthafucka!  If it is
     blank output filez is ghon be placed up in CMAKE_CURRENT_BINARY_DIR.
     Intermediate filez will always be placed in
     CMAKE_CURRENT_BINARY_DIR/CMakeFiles.
.fi




.nf
  CUDA_HOST_COMPILATION_CPP (Default ON)
  \-\- Set ta OFF fo' C compilation of host code.
.fi




.nf
  CUDA_HOST_COMPILER (Default CMAKE_C_COMPILER, $(VCInstallDir)/bin fo' VS)
  \-\- Set tha host compila ta be used by nvcc.  Ignored if \-ccbin or
     \-\-compiler\-bindir be already present up in tha CUDA_NVCC_FLAGS or
     CUDA_NVCC_FLAGS_<CONFIG> variables.  For Visual Studio targets
     $(VCInstallDir)/bin be a special value dat expandz up ta tha path when
     tha command is run from withang VS.
.fi




.nf
  CUDA_NVCC_FLAGS
  CUDA_NVCC_FLAGS_<CONFIG>
  \-\- Additionizzle NVCC command line arguments, n' you can put dat on yo' toast.  NOTE: multiple arguments must be
     semi\-colon delimited (e.g. \-\-compiler\-options;\-Wall)
.fi




.nf
  CUDA_PROPAGATE_HOST_FLAGS (Default ON)
  \-\- Set ta ON ta propagate CMAKE_{C,CXX}_FLAGS n' they configuration
     dependent counterparts (e.g. CMAKE_C_FLAGS_DEBUG) automatically ta the
     host compila all up in nvccs \-Xcompila flag.  This helps make the
     generated host code match tha rest of tha system mo' betta n' shit.  Sometimes
     certain flags give nvcc problems, n' dis will help you turn tha flag
     propagation off.  This do not affect tha flags supplied directly ta nvcc
     via CUDA_NVCC_FLAGS or all up in tha OPTION flags specified through
     CUDA_ADD_LIBRARY, CUDA_ADD_EXECUTABLE, or CUDA_WRAP_SRCS.  Flags used for
     shared library compilation is not affected by dis flag.
.fi




.nf
  CUDA_SEPARABLE_COMPILATION (Default OFF)
  \-\- If set dis will enable separable compilation fo' all CUDA runtime object
     files.  If used outside of CUDA_ADD_EXECUTABLE n' CUDA_ADD_LIBRARY
     (e.g. callin CUDA_WRAP_SRCS directly),
     CUDA_COMPUTE_SEPARABLE_COMPILATION_OBJECT_FILE_NAME and
     CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS should be called.
.fi




.nf
  CUDA_VERBOSE_BUILD (Default OFF)
  \-\- Set ta ON ta peep all tha commandz used when buildin tha CUDA file.  When
     rockin a Makefile generator tha value defaults ta VERBOSE (run make
     VERBOSE=1 ta peep output), although settin CUDA_VERBOSE_BUILD ta ON will
     always print tha output.
.fi




Da script creates tha followin macros (in alphebetical order):


.nf
  CUDA_ADD_CUFFT_TO_TARGET( cuda_target )
  \-\- Addz tha cufft library ta tha target (can be any target).  Handlez whether
     yo ass is up in emulation mode or not.
.fi




.nf
  CUDA_ADD_CUBLAS_TO_TARGET( cuda_target )
  \-\- Addz tha cublas library ta tha target (can be any target).  Handles
     whether yo ass is up in emulation mode or not.
.fi




.nf
  CUDA_ADD_EXECUTABLE( cuda_target file0 file1 ...
                       [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
  \-\- Creates a executable "cuda_target" which is made up of tha files
     specified. Y'all KNOW dat shit, muthafucka!  All of tha non CUDA C filez is compiled rockin tha standard
     build rulez specified by CMAKE n' tha cuda filez is compiled ta object
     filez rockin nvcc n' tha host compila n' shit.  In addizzle CUDA_INCLUDE_DIRS is
     added automatically ta include_directories().  Some standard CMake target
     calls can be used on tha target afta callin dis macro
     (e.g. set_target_propertizzles n' target_link_libraries) yo, but setting
     propertizzles dat adjust compilation flags aint gonna affect code compiled by
     nvcc.  Such flags should be modified before callin CUDA_ADD_EXECUTABLE,
     CUDA_ADD_LIBRARY or CUDA_WRAP_SRCS.
.fi




.nf
  CUDA_ADD_LIBRARY( cuda_target file0 file1 ...
                    [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
  \-\- Same as CUDA_ADD_EXECUTABLE except dat a library is pimped.
.fi




.nf
  CUDA_BUILD_CLEAN_TARGET()
  \-\- Creates a cold-ass lil convience target dat deletes all tha dependency files
     generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass should make clean afta hustlin dis target ta ensure the
     dependency filez git regenerated.
.fi




.nf
  CUDA_COMPILE( generated_filez file0 file1 ... [STATIC | SHARED | MODULE]
                [OPTIONS ...] )
  \-\- Returns a list of generated filez from tha input source filez ta be used
     wit ADD_LIBRARY or ADD_EXECUTABLE.
.fi




.nf
  CUDA_COMPILE_PTX( generated_filez file0 file1 ... [OPTIONS ...] )
  \-\- Returns a list of PTX filez generated from tha input source files.
.fi




.nf
  CUDA_COMPUTE_SEPARABLE_COMPILATION_OBJECT_FILE_NAME( output_file_var
                                                       cuda_target
                                                       object_filez )
  \-\- Compute tha name of tha intermediate link file used fo' separable
     compilation. I aint talkin' bout chicken n' gravy biatch.  This file name is typically passed into
     CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS.  output_file_var is produced
     based on cuda_target tha list of objects filez dat need separable
     compilation as specified by object_files.  If tha object_filez list is
     empty, then output_file_var is ghon be empty.  This function is called
     automatically fo' CUDA_ADD_LIBRARY n' CUDA_ADD_EXECUTABLE.  Note that
     dis be a gangbangin' function n' not a macro.
.fi




.nf
  CUDA_INCLUDE_DIRECTORIES( path0 path1 ... )
  \-\- Sets tha directories dat should be passed ta nvcc
     (e.g. nvcc \-Ipath0 \-Ipath1 ... ). These paths probably contain other .cu
     files.
.fi







.nf
  CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS( output_file_var cuda_target
                                           nvcc_flags object_files)
.fi




.nf
  \-\- Generates tha link object required by separable compilation from tha given
     object files.  This is called automatically fo' CUDA_ADD_EXECUTABLE and
     CUDA_ADD_LIBRARY yo, but can be called manually when rockin CUDA_WRAP_SRCS
     directly.  When called from CUDA_ADD_LIBRARY or CUDA_ADD_EXECUTABLE the
     nvcc_flags passed up in is tha same as tha flags passed up in via tha OPTIONS
     argument.  Da only nvcc flag added automatically is tha bitnizz flag as
     specified by CUDA_64_BIT_DEVICE_CODE.  Note dat dis be a gangbangin' function
     instead of a macro.
.fi




.nf
  CUDA_WRAP_SRCS ( cuda_target format generated_filez file0 file1 ...
                   [STATIC | SHARED | MODULE] [OPTIONS ...] )
  \-\- This is where all tha magic happens.  CUDA_ADD_EXECUTABLE,
     CUDA_ADD_LIBRARY, CUDA_COMPILE, n' CUDA_COMPILE_PTX all call this
     function under tha hood.
.fi




.nf
     Given tha list of filez (file0 file1 ... fileN) dis macro generates
     custom commandz dat generate either PTX or linkable objects (use "PTX" or
     "OBJ" fo' tha format argument ta switch).  Filez dat don't end wit .cu
     or have tha HEADER_FILE_ONLY property is ignored.
.fi




.nf
     Da arguments passed up in afta OPTIONS is extra command line options to
     give ta nvcc.  Yo ass can also specify per configuration options by
     specifyin tha name of tha configuration followed by tha options.  General
     options must preceed configuration specific options.  Not all
     configurations need ta be specified, only tha ones provided is ghon be used.
.fi




.nf
        OPTIONS \-DFLAG=2 "\-DFLAG_OTHER=space up in flag"
        DEBUG \-g
        RELEASE \-\-use_fast_math
        RELWITHDEBINFO \-\-use_fast_math;\-g
        MINSIZEREL \-\-use_fast_math
.fi




.nf
     For certain configurations (namely VS generatin object filez with
     CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE set ta ON), no generated file will
     be produced fo' tha given cuda file.  This is cuz when you add the
     cuda file ta Visual Studio it knows dat dis file produces a object file
     n' will link up in tha resultin object file automatically.
.fi




.nf
     This script will also generate a separate cmake script dat is used at
     build time ta invoke nvcc.  This is fo' nuff muthafuckin reasons.
.fi




.nf
       1. nvcc can return wack numbers as return joints which confuses
       Visual Studio tha fuck into thankin dat tha command succeeded. Y'all KNOW dat shit, muthafucka!  Da script now
       checks tha error codes n' produces errors when there was a problem.
.fi




.nf
       2. nvcc has been known ta not delete incomplete thangs up in dis biatch when it
       encountas problems.  This confuses build systems tha fuck into thankin the
       target was generated when up in fact a unusable file exists, n' you can put dat on yo' toast.  Da script
       now deletes tha output filez if there was a error.
.fi




.nf
       3. By puttin all tha options dat affect tha build tha fuck into a gangbangin' file n' then
       make tha build rule dependent on tha file, tha output filez will be
       regenerated when tha options chizzle.
.fi




.nf
     This script also looks at optionizzle arguments STATIC, SHARED, or MODULE to
     determine when ta target tha object compilation fo' a gangbangin' finger-lickin' dirty-ass shared library.
     BUILD_SHARED_LIBS is ignored up in CUDA_WRAP_SRCS yo, but it is bigged up in
     CUDA_ADD_LIBRARY.  On some systems special flags is added fo' building
     objects intended fo' shared libraries. Put ya muthafuckin choppers up if ya feel dis!  A preprocessor macro,
     <target_name>_EXPORTS is defined when a gangbangin' finger-lickin' dirty-ass shared library compilation is
     detected.
.fi




.nf
     Flags passed tha fuck into add_definitions wit \-D or /D is passed along ta nvcc.
.fi




Da script defines tha followin variables:


.nf
  CUDA_VERSION_MAJOR    \-\- Da major version of cuda as reported by nvcc.
  CUDA_VERSION_MINOR    \-\- Da minor version.
  CUDA_VERSION
  CUDA_VERSION_STRING   \-\- CUDA_VERSION_MAJOR.CUDA_VERSION_MINOR
.fi




.nf
  CUDA_TOOLKIT_ROOT_DIR \-\- Path ta tha CUDA Toolkit (defined if not set).
  CUDA_SDK_ROOT_DIR     \-\- Path ta tha CUDA SDK.  Use dis ta find filez up in the
                           SDK.  This script aint gonna directly support finding
                           specific libraries or headers, as dat aint
                           supported by NVIDIA.  If you wanna chizzle
                           libraries when tha path chizzlez peep the
                           FindCUDA.cmake script fo' a example of how tha fuck ta clear
                           these variables.  There is also examplez of how tha fuck to
                           use tha CUDA_SDK_ROOT_DIR ta locate headaz or
                           libraries, if you so chizzle (at yo' own risk).
  CUDA_INCLUDE_DIRS     \-\- Include directory fo' cuda headers.  Added automatically
                           fo' CUDA_ADD_EXECUTABLE n' CUDA_ADD_LIBRARY.
  CUDA_LIBRARIES        \-\- Cuda RT library.
  CUDA_CUFFT_LIBRARIES  \-\- Device or emulation library fo' tha Cuda FFT
                           implementation (alternatizzle to:
                           CUDA_ADD_CUFFT_TO_TARGET macro)
  CUDA_CUBLAS_LIBRARIES \-\- Device or emulation library fo' tha Cuda BLAS
                           implementation (alteratizzle to:
                           CUDA_ADD_CUBLAS_TO_TARGET macro).
  CUDA_cupti_LIBRARY    \-\- CUDA Profilin Tools Interface library.
                           Only available fo' CUDA version 4.0+.
  CUDA_curand_LIBRARY   \-\- CUDA Random Number Generation library.
                           Only available fo' CUDA version 3.2+.
  CUDA_cusparse_LIBRARY \-\- CUDA Sparse Matrix library.
                           Only available fo' CUDA version 3.2+.
  CUDA_npp_LIBRARY      \-\- NVIDIA Performizzle Primitives library.
                           Only available fo' CUDA version 4.0+.
  CUDA_nppc_LIBRARY      \-\- NVIDIA Performizzle Primitives library (core).
                           Only available fo' CUDA version 5.5+.
  CUDA_nppi_LIBRARY      \-\- NVIDIA Performizzle Primitives library (image processing).
                           Only available fo' CUDA version 5.5+.
  CUDA_npps_LIBRARY      \-\- NVIDIA Performizzle Primitives library (signal processing).
                           Only available fo' CUDA version 5.5+.
  CUDA_nvcuvenc_LIBRARY \-\- CUDA Video Encoder library.
                           Only available fo' CUDA version 3.2+.
                           Windows only.
  CUDA_nvcuvid_LIBRARY  \-\- CUDA Video Decoder library.
                           Only available fo' CUDA version 3.2+.
                           Windows only.
.fi







.nf
  Jizzy Bigler, NVIDIA Corp (nvidia.com \- jbigler)
  Abe Stephens, SCI Institute \-\- http://www.sci.utah.edu/~abe/FindCuda.html
.fi




.nf
  Copyright (c) 2008 \- 2009 NVIDIA Corporation. I aint talkin' bout chicken n' gravy biatch.  All muthafuckin rights reserved.
.fi




.nf
  Copyright (c) 2007\-2009
  Scientific Computin n' Imagin Institute, Universitizzle of Utah
.fi




.nf
  This code is licensed under tha MIT License.  See tha FindCUDA.cmake script
  fo' tha text of tha license.
.fi

.TP
.B FindCURL
Find curl

Find tha natizzle CURL headaz n' libraries.


.nf
  CURL_INCLUDE_DIRS   \- where ta find curl/curl.h, etc.
  CURL_LIBRARIES      \- List of libraries when rockin curl.
  CURL_FOUND          \- True if curl found.
  CURL_VERSION_STRING \- tha version of curl found (since CMake 2.8.8)
.fi

.TP
.B FindCVS
.nf
 
.fi

Da module defines tha followin variables:


.nf
   CVS_EXECUTABLE \- path ta cvs command line client
   CVS_FOUND \- legit if tha command line client was found
.fi

Example usage:


.nf
   find_package(CVS)
   if(CVS_FOUND)
     message("CVS found: ${CVS_EXECUTABLE}")
   endif()
.fi

.TP
.B FindCoin3D
Find Coin3D (Open Inventor)

Coin3D be a implementation of tha Open Inventor API. Well shiiiit, it serves up data structures n' algorithms fo' 3D visualization http://www.coin3d.org/


This module defines tha followin variables


.nf
  COIN3D_FOUND         \- system has Coin3D \- Open Inventor
  COIN3D_INCLUDE_DIRS  \- where tha Inventor include directory can be found
  COIN3D_LIBRARIES     \- Link ta dis ta use Coin3D
.fi




.TP
.B FindCups
Try ta find tha Cups printin system

Once done dis will define


.nf
  CUPS_FOUND \- system has Cups
  CUPS_INCLUDE_DIR \- tha Cups include directory
  CUPS_LIBRARIES \- Libraries needed ta use Cups
  CUPS_VERSION_STRING \- version of Cups found (since CMake 2.8.8)
  Set CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE ta TRUE if you need a version which
  features dis function (i.e. at least 1.1.19)
.fi

.TP
.B FindCurses
Find tha curses include file n' library




.nf
  CURSES_FOUND \- system has Curses
  CURSES_INCLUDE_DIR \- tha Curses include directory
  CURSES_LIBRARIES \- Da libraries needed ta use Curses
  CURSES_HAVE_CURSES_H \- legit if curses.h be available
  CURSES_HAVE_NCURSES_H \- legit if ncurses.h be available
  CURSES_HAVE_NCURSES_NCURSES_H \- legit if ncurses/ncurses.h be available
  CURSES_HAVE_NCURSES_CURSES_H \- legit if ncurses/curses.h be available
  CURSES_LIBRARY \- set fo' backwardz compatibilitizzle wit 2.4 CMake
.fi




Set CURSES_NEED_NCURSES ta TRUE before tha find_package() command if NCurses functionalitizzle is required.

.TP
.B FindCxxTest
Find CxxTest

Find tha CxxTest suite n' declare a helper macro fo' bustin unit tests n' integratin dem wit CTest. For mo' details on CxxTest peep http://cxxtest.tigris.org


INPUT Variables


.nf
   CXXTEST_USE_PYTHON [deprecated since 1.3]
       Only used up in tha case both Python & Perl
       is detected on tha system ta control
       which CxxTest code generator is used.
       Valid only fo' CxxTest version 3.
.fi




.nf
       NOTE: In olda versionz of dis Find Module,
       dis variable controlled if tha Python test
       generator was used instead of tha Perl one,
       regardless of which scriptin language the
       user had installed.
.fi




.nf
   CXXTEST_TESTGEN_ARGS (since CMake 2.8.3)
       Specify a list of options ta pass ta tha CxxTest code
       generator. Shiiit, dis aint no joke.  If not defined, \-\-error\-printa is
       passed.
.fi




OUTPUT Variables


.nf
   CXXTEST_FOUND
       True if tha CxxTest framework was found
   CXXTEST_INCLUDE_DIRS
       Where ta find tha CxxTest include directory
   CXXTEST_PERL_TESTGEN_EXECUTABLE
       Da perl\-based test generator
   CXXTEST_PYTHON_TESTGEN_EXECUTABLE
       Da python\-based test generator
   CXXTEST_TESTGEN_EXECUTABLE (since CMake 2.8.3)
       Da test generator dat is straight-up used (chosen rockin user preferences
       n' interpretas found up in tha system)
   CXXTEST_TESTGEN_INTERPRETER (since CMake 2.8.3)
       Da full path ta tha Perl or Python executable on tha system
.fi




MACROS fo' optionizzle use by CMake users:


.nf
    CXXTEST_ADD_TEST(<test_name> <gen_source_file> <input_files_to_testgen...>)
       Creates a CxxTest runner n' addz it ta tha CTest testin suite
       Parameters:
           test_name               Da name of tha test
           gen_source_file         Da generated source filename ta be
                                   generated by CxxTest
           input_files_to_testgen  Da list of header filez containin the
                                   CxxTest::TestSuitez ta be included in
                                   dis runner
.fi




.nf
       #==============
       Example Usage:
.fi




.nf
           find_package(CxxTest)
           if(CXXTEST_FOUND)
               include_directories(${CXXTEST_INCLUDE_DIR})
               enable_testing()
.fi




.nf
               CXXTEST_ADD_TEST(unittest_foo foo_test.cc
                                 ${CMAKE_CURRENT_SOURCE_DIR}/foo_test.h)
               target_link_libraries(unittest_foo foo) # as needed
           endif()
.fi




.nf
              This will (if CxxTest is found):
              1. Invoke tha testgen executable ta autogenerate foo_test.cc up in the
                 binary tree from "foo_test.h" up in tha current source directory.
              2. Right back up in yo muthafuckin ass. Smoke a executable n' test called unittest_foo.
.fi




.nf
      #=============
      Example foo_test.h:
.fi




.nf
          #include <cxxtest/TestSuite.h>
.fi




.nf
          class MyTestSuite : hood CxxTest::TestSuite
          {
          public:
             void testAddition( void )
             {
                TS_ASSERT( 1 + 1 > 1 );
                TS_ASSERT_EQUALS( 1 + 1, 2 );
             }
          };
.fi




.TP
.B FindCygwin
this module looks fo' Cygwin




.TP
.B FindDCMTK
find DCMTK libraries n' applications




.TP
.B FindDart
Find DART

This module looks fo' tha dart testin software n' sets DART_ROOT ta point ta where it found dat shit.


.TP
.B FindDevIL
.nf
 
.fi

This module locates tha pimperz image library. http://openil.sourceforge.net/


This module sets:


.nf
   IL_LIBRARIES \-   tha name of tha IL library. These include tha full path to
                    tha core DevIL library. This one has ta be linked tha fuck into the
                    application.
   ILU_LIBRARIES \-  tha name of tha ILU library fo' realz. Again, tha full path. This
                    library is fo' filtas n' effects, not actual loading. It
                    don't gotta be linked if tha functionalitizzle it provides
                    aint used.
   ILUT_LIBRARIES \- tha name of tha ILUT library. Full path. This part of the
                    library intercourses wit OpenGL. Well shiiiit, it aint strictly needed
                    up in applications.
   IL_INCLUDE_DIR \- where ta find tha il.h, ilu.h n' ilut.h files.
   IL_FOUND \-       dis is set ta TRUE if all tha above variablez was set.
                    This is ghon be set ta false if ILU or ILUT is not found,
                    even if they is not needed. Y'all KNOW dat shit, muthafucka! In most systems, if one
                    library is found all tha others is as well. Thatz the
                    way tha DevIL pimpers release dat shit.
.fi

.TP
.B FindDoxygen
This module looks fo' Doxygen n' tha path ta Graphvizz dot

Doxygen be a thugged-out documentation generation tool.  Please peep http://www.doxygen.org


This module accepts tha followin optionizzle variables:


.nf
   DOXYGEN_SKIP_DOT       = If legit dis module will skip tryin ta find Dot
                            (an optionizzle component often used by Doxygen)
.fi




This modulez defines tha followin variables:


.nf
   DOXYGEN_EXECUTABLE     = Da path ta tha doxygen command.
   DOXYGEN_FOUND          = Was Doxygen found or not?
   DOXYGEN_VERSION        = Da version reported by doxygen \-\-version
.fi




.nf
   DOXYGEN_DOT_EXECUTABLE = Da path ta tha dot program used by doxygen.
   DOXYGEN_DOT_FOUND      = Was Dot found or not?
   DOXYGEN_DOT_PATH       = Da path ta dot not includin tha executable
.fi







.TP
.B FindEXPAT
Find expat

Find tha natizzle EXPAT headaz n' libraries.


.nf
  EXPAT_INCLUDE_DIRS \- where ta find expat.h, etc.
  EXPAT_LIBRARIES    \- List of libraries when rockin expat.
  EXPAT_FOUND        \- True if expat found.
.fi

.TP
.B FindFLEX
Find flex executable n' serves up a macro ta generate custom build rules




Da module defines tha followin variables:


.nf
  FLEX_FOUND \- legit is flex executable is found
  FLEX_EXECUTABLE \- tha path ta tha flex executable
  FLEX_VERSION \- tha version of flex
  FLEX_LIBRARIES \- Da flex libraries
  FLEX_INCLUDE_DIRS \- Da path ta tha flex headers
.fi




Da minimum required version of flex can be specified rockin tha standard syntax, e.g. find_package(FLEX 2.5.13)





If flex is found on tha system, tha module serves up tha macro:


.nf
  FLEX_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>])
.fi

which creates a cold-ass lil custom command  ta generate tha <FlexOutput> file from tha <FlexInput> file.  If  COMPILE_FLAGS option is specified, tha next parameta be added ta tha flex  command line. Name be a alias used ta git  detailz of  dis custom  command. Y'all KNOW dat shit, muthafucka!  Indeed tha  macro defines  tha followin variables:


.nf
  FLEX_${Name}_DEFINED \- legit is tha macro ran successfully
  FLEX_${Name}_OUTPUTS \- tha source file generated by tha custom rule, an
  alias fo' FlexOutput
  FLEX_${Name}_INPUT \- tha flex source file, a alias fo' ${FlexInput}
.fi




Flex scanners oftenly use tokens  defined by Bison: tha code generated by Flex  dependz of tha header  generated by Bison. I aint talkin' bout chicken n' gravy biatch.   This module also defines a macro:


.nf
  ADD_FLEX_BISON_DEPENDENCY(FlexTarget BisonTarget)
.fi

which  addz tha  required dependency  between a  scanner n'  a parser where  <FlexTarget>  n' <BisonTarget>  is  tha  first parametas  of respectively FLEX_TARGET n' BISON_TARGET macros.


.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(BISON)
   find_package(FLEX)
.fi




.nf
   BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
   FLEX_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
   ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser)
.fi




.nf
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
   add_executable(Foo
      Foo.cc
      ${BISON_MyParser_OUTPUTS}
      ${FLEX_MyScanner_OUTPUTS}
   )
  ====================================================================
.fi

.TP
.B FindFLTK
Find tha natizzle FLTK includes n' library




By default FindFLTK.cmake will search fo' all of tha FLTK components n' add dem ta tha FLTK_LIBRARIES variable.


.nf
   Yo ass can limit tha components which git placed up in FLTK_LIBRARIES by
   definin one or mo' of tha followin three options:
.fi




.nf
     FLTK_SKIP_OPENGL, set ta legit ta disable searchin fo' opengl and
                       tha FLTK GL library
     FLTK_SKIP_FORMS, set ta legit ta disable searchin fo' fltk_forms
     FLTK_SKIP_IMAGES, set ta legit ta disable searchin fo' fltk_images
.fi




.nf
     FLTK_SKIP_FLUID, set ta legit if tha fluid binary need not be present
                      at build time
.fi




Da followin variablez is ghon be defined:


.nf
     FLTK_FOUND, True if all components not skipped was found
     FLTK_INCLUDE_DIR, where ta find include files
     FLTK_LIBRARIES, list of fltk libraries you should link against
     FLTK_FLUID_EXECUTABLE, where ta find tha Fluid tool
     FLTK_WRAP_UI, This enablez tha FLTK_WRAP_UI command
.fi




Da followin cache variablez is assigned but should not be used. Y'all KNOW dat shit, muthafucka! See tha FLTK_LIBRARIES variable instead.


.nf
     FLTK_BASE_LIBRARY   = tha full path ta fltk.lib
     FLTK_GL_LIBRARY     = tha full path ta fltk_gl.lib
     FLTK_FORMS_LIBRARY  = tha full path ta fltk_forms.lib
     FLTK_IMAGES_LIBRARY = tha full path ta fltk_images.lib
.fi

.TP
.B FindFLTK2
Find tha natizzle FLTK2 includes n' library

Da followin settings is defined


.nf
  FLTK2_FLUID_EXECUTABLE, where ta find tha Fluid tool
  FLTK2_WRAP_UI, This enablez tha FLTK2_WRAP_UI command
  FLTK2_INCLUDE_DIR, where ta find include files
  FLTK2_LIBRARIES, list of fltk2 libraries
  FLTK2_FOUND, Don't use FLTK2 if false.
.fi

Da followin settings should not be used up in general.


.nf
  FLTK2_BASE_LIBRARY   = tha full path ta fltk2.lib
  FLTK2_GL_LIBRARY     = tha full path ta fltk2_gl.lib
  FLTK2_IMAGES_LIBRARY = tha full path ta fltk2_images.lib
.fi

.TP
.B FindFreetype
Locate FreeType library

This module defines


.nf
  FREETYPE_LIBRARIES, tha library ta link against
  FREETYPE_FOUND, if false, do not try ta link ta FREETYPE
  FREETYPE_INCLUDE_DIRS, where ta find headers.
  FREETYPE_VERSION_STRING, tha version of freetype found (since CMake 2.8.8)
  This is tha concatenation of tha paths:
  FREETYPE_INCLUDE_DIR_ft2build
  FREETYPE_INCLUDE_DIR_freetype2
.fi




$FREETYPE_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$FREETYPE_DIR used up in buildin FREETYPE.

.TP
.B FindGCCXML
Find tha GCC\-XML front\-end executable.




This module will define tha followin variables:


.nf
  GCCXML \- tha GCC\-XML front\-end executable.
.fi

.TP
.B FindGDAL
.nf
 
.fi

Locate gdal


This module accepts tha followin environment variables:


.nf
    GDAL_DIR or GDAL_ROOT \- Specify tha location of GDAL
.fi




This module defines tha followin CMake variables:


.nf
    GDAL_FOUND \- True if libgdal is found
    GDAL_LIBRARY \- A variable pointin ta tha GDAL library
    GDAL_INCLUDE_DIR \- Where ta find tha headers
.fi

.TP
.B FindGIF
.nf
 
.fi

This module searches giflib n' defines GIF_LIBRARIES \- libraries ta link ta up in order ta use GIF GIF_FOUND, if false, do not try ta link GIF_INCLUDE_DIR, where ta find tha headaz GIF_VERSION, reports either version 4 or 3 (for every last muthafuckin thang before version 4)


Da minimum required version of giflib can be specified rockin tha standard syntax, e.g. find_package(GIF 4)


$GIF_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$GIF_DIR

.TP
.B FindGLEW
Find tha OpenGL Extension Wrangla Library (GLEW)

This module defines tha followin variables:


.nf
  GLEW_INCLUDE_DIRS \- include directories fo' GLEW
  GLEW_LIBRARIES \- libraries ta link against GLEW
  GLEW_FOUND \- legit if GLEW has been found n' can be used
.fi

.TP
.B FindGLUT
try ta find glut library n' include files

.nf
  GLUT_INCLUDE_DIR, where ta find GL/glut.h, etc.
  GLUT_LIBRARIES, tha libraries ta link against
  GLUT_FOUND, If false, do not try ta use GLUT.
.fi

Also defined yo, but not fo' general use are:


.nf
  GLUT_glut_LIBRARY = tha full path ta tha glut library.
  GLUT_Xmu_LIBRARY  = tha full path ta tha Xmu library.
  GLUT_Xi_LIBRARY   = tha full path ta tha Xi Library.
.fi

.TP
.B FindGTK
try ta find GTK (and glib) n' GTKGLArea

.nf
  GTK_INCLUDE_DIR   \- Directories ta include ta use GTK
  GTK_LIBRARIES     \- Filez ta link against ta use GTK
  GTK_FOUND         \- GTK was found
  GTK_GL_FOUND      \- GTKz GL features was found
.fi

.TP
.B FindGTK2
FindGTK2.cmake

This module can find tha GTK2 widget libraries n' nuff muthafuckin of its other optionizzle components like gtkmm, glade, n' glademm.


NOTE: If you intend ta use version checking, CMake 2.6.2 or lata is


.nf
       required.
.fi




Specify one or mo' of tha followin components as you call dis find module. Right back up in yo muthafuckin ass. See example below.


.nf
   gtk
   gtkmm
   glade
   glademm
.fi




Da followin variablez is ghon be defined fo' yo' use


.nf
   GTK2_FOUND \- Were all of yo' specified components found?
   GTK2_INCLUDE_DIRS \- All include directories
   GTK2_LIBRARIES \- All libraries
   GTK2_DEFINITIONS \- Additionizzle compila flags
.fi




.nf
   GTK2_VERSION \- Da version of GTK2 found (x.y.z)
   GTK2_MAJOR_VERSION \- Da major version of GTK2
   GTK2_MINOR_VERSION \- Da minor version of GTK2
   GTK2_PATCH_VERSION \- Da patch version of GTK2
.fi




Optionizzle variablez you can define prior ta callin dis module:


.nf
   GTK2_DEBUG \- Enablez verbose debuggin of tha module
   GTK2_ADDITIONAL_SUFFIXES \- Allows definin additionizzle directories to
                              search fo' include files
.fi




================= Example Usage:


.nf
   Call find_package() once, here is some examplez ta pick from:
.fi




.nf
   Require GTK 2.6 or later
       find_package(GTK2 2.6 REQUIRED gtk)
.fi




.nf
   Require GTK 2.10 or lata n' Glade
       find_package(GTK2 2.10 REQUIRED gtk glade)
.fi




.nf
   Search fo' GTK/GTKMM 2.8 or later
       find_package(GTK2 2.8 COMPONENTS gtk gtkmm)
.fi




.nf
   if(GTK2_FOUND)
      include_directories(${GTK2_INCLUDE_DIRS})
      add_executable(mygui mygui.cc)
      target_link_libraries(mygui ${GTK2_LIBRARIES})
   endif()
.fi




.TP
.B FindGTest
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

Locate tha Gizoogle C++ Testin Framework.


Defines tha followin variables:


.nf
   GTEST_FOUND \- Found tha Gizoogle Testin framework
   GTEST_INCLUDE_DIRS \- Include directories
.fi




Also defines tha library variablez below as aiiight variables.  These contain debug/optimized keywordz when a thugged-out debuggin library is found.


.nf
   GTEST_BOTH_LIBRARIES \- Both libgtest & libgtest\-main
   GTEST_LIBRARIES \- libgtest
   GTEST_MAIN_LIBRARIES \- libgtest\-main
.fi




Accepts tha followin variablez as input:


.nf
   GTEST_ROOT \- (as a CMake or environment variable)
                Da root directory of tha gtest install prefix
.fi




.nf
   GTEST_MSVC_SEARCH \- If compilin wit MSVC, dis variable can be set to
                       "MD" or "MT" ta enable searchin a GTest build tree
                       (defaults: "MD")
.fi




Example Usage:


.nf
    enable_testing()
    find_package(GTest REQUIRED)
    include_directories(${GTEST_INCLUDE_DIRS})
.fi




.nf
    add_executable(foo foo.cc)
    target_link_libraries(foo ${GTEST_BOTH_LIBRARIES})
.fi




.nf
    add_test(AllTestsInFoo foo)
.fi







If you wanna each Gizoogle test ta show up in CTest as a test you may use tha followin macro. NOTE: It will slow down yo' tests by hustlin a executable fo' each test n' test fixture.  Yo ass will also gotta rerun CMake afta addin or removin tests or test fixtures.


GTEST_ADD_TESTS(executable extra_args ARGN)


.nf
    executable = Da path ta tha test executable
    extra_args = Pass a list of extra arguments ta be passed to
                 executable enclosed up in quotes (or "" fo' none)
    ARGN =       A list of source filez ta search fo' tests & test
                 fixtures.
.fi




.nf
  Example:
     set(FooTestArgs \-\-foo 1 \-\-bar 2)
     add_executable(FooTest FooUnitTest.cc)
     GTEST_ADD_TESTS(FooTest "${FooTestArgs}" FooUnitTest.cc)
.fi

.TP
.B FindGettext
Find GNU gettext tools

This module looks fo' tha GNU gettext tools. This module defines tha followin joints:


.nf
  GETTEXT_MSGMERGE_EXECUTABLE: tha full path ta tha msgmerge tool.
  GETTEXT_MSGFMT_EXECUTABLE: tha full path ta tha msgfmt tool.
  GETTEXT_FOUND: True if gettext has been found.
  GETTEXT_VERSION_STRING: tha version of gettext found (since CMake 2.8.8)
.fi




Additionally it serves up tha followin macros: GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ... fileN )


.nf
    This will create a target "translations" which will convert the
    given input po filez tha fuck into tha binary output mo file. If the
    ALL option is used, tha translations will also be pimped when
    buildin tha default target.
.fi

GETTEXT_PROCESS_POT( <potfile> [ALL] [INSTALL_DESTINATION <destdir>] LANGUAGES <lang1> <lang2> ... )


.nf
     Process tha given pot file ta mo files.
     If INSTALL_DESTINATION is given then automatically install rulez is ghon be pimped,
     tha language subdirectory is ghon be taken tha fuck into account (by default use share/locale/).
     If ALL is specified, tha pot file is processed when buildin tha all traget.
     It creates a cold-ass lil custom target "potfile".
.fi

GETTEXT_PROCESS_PO_FILES( <lang> [ALL] [INSTALL_DESTINATION <dir>] PO_FILES <po1> <po2> ... )


.nf
     Process tha given po filez ta mo filez fo' tha given language.
     If INSTALL_DESTINATION is given then automatically install rulez is ghon be pimped,
     tha language subdirectory is ghon be taken tha fuck into account (by default use share/locale/).
     If ALL is specified, tha po filez is processed when buildin tha all traget.
     It creates a cold-ass lil custom target "pofiles".
.fi

.TP
.B FindGit
.nf
 
.fi

Da module defines tha followin variables:


.nf
   GIT_EXECUTABLE \- path ta git command line client
   GIT_FOUND \- legit if tha command line client was found
   GIT_VERSION_STRING \- tha version of git found (since CMake 2.8.8)
.fi

Example usage:


.nf
   find_package(Git)
   if(GIT_FOUND)
     message("git found: ${GIT_EXECUTABLE}")
   endif()
.fi

.TP
.B FindGnuTLS
Try ta find tha GNU Transhiznit Layer Securitizzle library (gnutls)




Once done dis will define


.nf
  GNUTLS_FOUND \- System has gnutls
  GNUTLS_INCLUDE_DIR \- Da gnutls include directory
  GNUTLS_LIBRARIES \- Da libraries needed ta use gnutls
  GNUTLS_DEFINITIONS \- Compila switches required fo' rockin gnutls
.fi

.TP
.B FindGnuplot
this module looks fo' gnuplot




Once done dis will define


.nf
  GNUPLOT_FOUND \- system has Gnuplot
  GNUPLOT_EXECUTABLE \- tha Gnuplot executable
  GNUPLOT_VERSION_STRING \- tha version of Gnuplot found (since CMake 2.8.8)
.fi




GNUPLOT_VERSION_STRING aint gonna work fo' oldschool versions like 3.7.1.

.TP
.B FindHDF5
Find HDF5, a library fo' readin n' freestylin self describin array data.




This module invokes tha HDF5 wrapper compila dat should be installed alongside HDF5.  Dependin upon tha HDF5 Configuration, tha wrapper compila is called either h5cc or h5pcc.  If dis succeeds, tha module will then call tha compila wit tha \-show argument ta peep what tha fuck flags is used when compilin a HDF5 client application.


Da module will optionally accept tha COMPONENTS argument.  If no COMPONENTS is specified, then tha find module will default ta findin only tha HDF5 C library.  If one or mo' COMPONENTS is specified, tha module will attempt ta find tha language bindings fo' tha specified components, n' you can put dat on yo' toast.  Da only valid components is C, CXX, Fortran, HL, n' Fortran_HL.  If tha COMPONENTS argument aint given, tha module will attempt ta find only tha C bindings.


On UNIX systems, dis module will read tha variable HDF5_USE_STATIC_LIBRARIES ta determine whether or not ta prefer a static link ta a thugged-out dynamic link fo' HDF5 n' all of itz dependencies. Put ya muthafuckin choppers up if ya feel dis!  To use dis feature, make shizzle dat tha HDF5_USE_STATIC_LIBRARIES variable is set before tha call ta find_package.


To provide tha module wit a hint bout where ta find yo' HDF5 installation, you can set tha environment variable HDF5_ROOT.  Da Find module will then look up in dis path when searchin fo' HDF5 executables, paths, n' libraries.


In addizzle ta findin tha includes n' libraries required ta compile a HDF5 client application, dis module also make a effort ta find tools dat come wit tha HDF5 distribution dat may be useful fo' regression testing.


This module will define tha followin variables:


.nf
  HDF5_INCLUDE_DIRS \- Location of tha hdf5 includes
  HDF5_INCLUDE_DIR \- Location of tha hdf5 includes (deprecated)
  HDF5_DEFINITIONS \- Required compila definitions fo' HDF5
  HDF5_C_LIBRARIES \- Required libraries fo' tha HDF5 C bindings.
  HDF5_CXX_LIBRARIES \- Required libraries fo' tha HDF5 C++ bindings
  HDF5_Fortran_LIBRARIES \- Required libraries fo' tha HDF5 Fortran bindings
  HDF5_HL_LIBRARIES \- Required libraries fo' tha HDF5 high level API
  HDF5_Fortran_HL_LIBRARIES \- Required libraries fo' tha high level Fortran
                              bindings.
  HDF5_LIBRARIES \- Required libraries fo' all axed bindings
  HDF5_FOUND \- legit if HDF5 was found on tha system
  HDF5_LIBRARY_DIRS \- tha full set of library directories
  HDF5_IS_PARALLEL \- Whether or not HDF5 was found wit parallel IO support
  HDF5_C_COMPILER_EXECUTABLE \- tha path ta tha HDF5 C wrapper compiler
  HDF5_CXX_COMPILER_EXECUTABLE \- tha path ta tha HDF5 C++ wrapper compiler
  HDF5_Fortran_COMPILER_EXECUTABLE \- tha path ta tha HDF5 Fortran wrapper compiler
  HDF5_DIFF_EXECUTABLE \- tha path ta tha HDF5 dataset comparison tool
.fi

.TP
.B FindHSPELL
Try ta find Hspell

Once done dis will define


.nf
  HSPELL_FOUND \- system has Hspell
  HSPELL_INCLUDE_DIR \- tha Hspell include directory
  HSPELL_LIBRARIES \- Da libraries needed ta use Hspell
  HSPELL_DEFINITIONS \- Compila switches required fo' rockin Hspell
.fi




.nf
  HSPELL_VERSION_STRING \- Da version of Hspell found (x.y)
  HSPELL_MAJOR_VERSION  \- tha major version of Hspell
  HSPELL_MINOR_VERSION  \- Da minor version of Hspell
.fi

.TP
.B FindHTMLHelp
This module looks fo' Microsizzlez HTML Help Compiler

It defines:


.nf
   HTML_HELP_COMPILER     : full path ta tha Compila (hhc.exe)
   HTML_HELP_INCLUDE_PATH : include path ta tha API (htmlhelp.h)
   HTML_HELP_LIBRARY      : full path ta tha library (htmlhelp.lib)
.fi




.TP
.B FindHg
.nf
 
.fi

Da module defines tha followin variables:


.nf
   HG_EXECUTABLE \- path ta mercurial command line client (hg)
   HG_FOUND \- legit if tha command line client was found
   HG_VERSION_STRING \- tha version of mercurial found
.fi

Example usage:


.nf
   find_package(Hg)
   if(HG_FOUND)
     message("hg found: ${HG_EXECUTABLE}")
   endif()
.fi

.TP
.B FindITK
Find a ITK installation or build tree.

.TP
.B FindIcotool
Find icotool

This module looks fo' icotool. This module defines tha followin joints:


.nf
  ICOTOOL_EXECUTABLE: tha full path ta tha icotool tool.
  ICOTOOL_FOUND: True if icotool has been found.
  ICOTOOL_VERSION_STRING: tha version of icotool found.
.fi




.TP
.B FindImageMagick
Find tha ImageMagick binary suite.

This module will search fo' a set of ImageMagick tools specified as components up in tha FIND_PACKAGE call. Typical components include yo, but is not limited ta (future versionz of ImageMagick might have additionizzle components not listed here):


.nf
  animate
  compare
  composite
  conjure
  convert
  display
  identify
  import
  mogrify
  montage
  stream
.fi




If no component is specified up in tha FIND_PACKAGE call, then it only searches fo' tha ImageMagick executable directory. This code defines tha followin variables:


.nf
  ImageMagick_FOUND                  \- TRUE if all components is found.
  ImageMagick_EXECUTABLE_DIR         \- Full path ta executablez directory.
  ImageMagick_<component>_FOUND      \- TRUE if <component> is found.
  ImageMagick_<component>_EXECUTABLE \- Full path ta <component> executable.
  ImageMagick_VERSION_STRING         \- tha version of ImageMagick found
                                       (since CMake 2.8.8)
.fi




ImageMagick_VERSION_STRING aint gonna work fo' oldschool versions like 5.2.3.


There is also components fo' tha followin ImageMagick APIs:


.nf
  Magick++
  MagickWand
  MagickCore
.fi




For these components tha followin variablez is set:


.nf
  ImageMagick_FOUND                    \- TRUE if all components is found.
  ImageMagick_INCLUDE_DIRS             \- Full paths ta all include dirs.
  ImageMagick_LIBRARIES                \- Full paths ta all libraries.
  ImageMagick_<component>_FOUND        \- TRUE if <component> is found.
  ImageMagick_<component>_INCLUDE_DIRS \- Full path ta <component> include dirs.
  ImageMagick_<component>_LIBRARIES    \- Full path ta <component> libraries.
.fi




Example Usages:


.nf
  find_package(ImageMagick)
  find_package(ImageMagick COMPONENTS convert)
  find_package(ImageMagick COMPONENTS convert mogrify display)
  find_package(ImageMagick COMPONENTS Magick++)
  find_package(ImageMagick COMPONENTS Magick++ convert)
.fi




Note dat tha standard FIND_PACKAGE features is supported (i.e., QUIET, REQUIRED, etc.).

.TP
.B FindJNI
Find JNI java libraries.

This module findz if Java is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  JNI_INCLUDE_DIRS      = tha include dirs ta use
  JNI_LIBRARIES         = tha libraries ta use
  JNI_FOUND             = TRUE if JNI headaz n' libraries was found.
  JAVA_AWT_LIBRARY      = tha path ta tha jawt library
  JAVA_JVM_LIBRARY      = tha path ta tha jvm library
  JAVA_INCLUDE_PATH     = tha include path ta jni.h
  JAVA_INCLUDE_PATH2    = tha include path ta jni_md.h
  JAVA_AWT_INCLUDE_PATH = tha include path ta jawt.h
.fi




.TP
.B FindJPEG
Find JPEG

Find tha natizzle JPEG includes n' library This module defines


.nf
  JPEG_INCLUDE_DIR, where ta find jpeglib.h, etc.
  JPEG_LIBRARIES, tha libraries needed ta use JPEG.
  JPEG_FOUND, If false, do not try ta use JPEG.
.fi

also defined yo, but not fo' general use are


.nf
  JPEG_LIBRARY, where ta find tha JPEG library.
.fi

.TP
.B FindJasper
Try ta find tha Jasper JPEG2000 library

Once done dis will define


.nf
  JASPER_FOUND \- system has Jasper
  JASPER_INCLUDE_DIR \- tha Jasper include directory
  JASPER_LIBRARIES \- tha libraries needed ta use Jasper
  JASPER_VERSION_STRING \- tha version of Jasper found (since CMake 2.8.8)
.fi

.TP
.B FindJava
Find Java

This module findz if Java is installed n' determines where tha include filez n' libraries are. This code sets tha followin variables:


.nf
  Java_JAVA_EXECUTABLE    = tha full path ta tha Java runtime
  Java_JAVAC_EXECUTABLE   = tha full path ta tha Java compiler
  Java_JAVAH_EXECUTABLE   = tha full path ta tha Java header generator
  Java_JAVADOC_EXECUTABLE = tha full path ta tha Java documention generator
  Java_JAR_EXECUTABLE     = tha full path ta tha Java archiver
  Java_VERSION_STRING     = Version of tha package found (java version), eg. 1.6.0_12
  Java_VERSION_MAJOR      = Da major version of tha package found.
  Java_VERSION_MINOR      = Da minor version of tha package found.
  Java_VERSION_PATCH      = Da patch version of tha package found.
  Java_VERSION_TWEAK      = Da tweak version of tha package found (afta '_')
  Java_VERSION            = This is set to: $major.$minor.$patch(.$tweak)
.fi




Da minimum required version of Java can be specified rockin tha standard CMake syntax, e.g. find_package(Java 1.5)


NOTE: ${Java_VERSION} n' ${Java_VERSION_STRING} is not guaranteed ta be identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example some java version may return: Java_VERSION_STRING = 1.5.0_17 n' Java_VERSION        = 1.5.0.17


another example is tha Java OEM, with: Java_VERSION_STRING = 1.6.0\-oem n' Java_VERSION        = 1.6.0


For these components tha followin variablez is set:


.nf
  Java_FOUND                    \- TRUE if all components is found.
  Java_INCLUDE_DIRS             \- Full paths ta all include dirs.
  Java_LIBRARIES                \- Full paths ta all libraries.
  Java_<component>_FOUND        \- TRUE if <component> is found.
.fi




Example Usages:


.nf
  find_package(Java)
  find_package(Java COMPONENTS Runtime)
  find_package(Java COMPONENTS Development)
.fi




.TP
.B FindKDE3
Find tha KDE3 include n' library dirs, KDE preprocessors n' define a some macros




This module defines tha followin variables:


.nf
  KDE3_DEFINITIONS         \- compila definitions required fo' compilin KDE software
  KDE3_INCLUDE_DIR         \- tha KDE include directory
  KDE3_INCLUDE_DIRS        \- tha KDE n' tha Qt include directory, fo' use wit include_directories()
  KDE3_LIB_DIR             \- tha directory where tha KDE libraries is installed, fo' use wit link_directories()
  QT_AND_KDECORE_LIBS      \- dis gotz nuff both tha Qt n' tha kdecore library
  KDE3_DCOPIDL_EXECUTABLE  \- tha dcopidl executable
  KDE3_DCOPIDL2CPP_EXECUTABLE \- tha dcopidl2cpp executable
  KDE3_KCFGC_EXECUTABLE    \- tha kconfig_compila executable
  KDE3_FOUND               \- set ta TRUE if all of tha above has been found
.fi




Da followin user adjustable options is provided:


.nf
  KDE3_BUILD_TESTS \- enable dis ta build KDE testcases
.fi







It also addz tha followin macros (from KDE3Macros.cmake) SRCS_VAR be always tha variable which gotz nuff tha list of source filez fo' yo' application or library.


KDE3_AUTOMOC(file1 ... fileN)


.nf
    Call dis if you wanna have automatic moc file handling.
    This means if you include "foo.moc" up in tha source file foo.cpp
    a moc file fo' tha header foo.h is ghon be pimped automatically.
    Yo ass can set tha property SKIP_AUTOMAKE rockin set_source_files_properties()
    ta exclude some filez up in tha list from bein processed.
.fi




KDE3_ADD_MOC_FILES(SRCS_VAR file1 ... fileN )


.nf
    If you don't use tha KDE3_AUTOMOC() macro, fo' tha files
    listed here moc filez is ghon be pimped (named "foo.moc.cpp")
.fi




KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ... headerN.h )


.nf
    Use dis ta generate DCOP skeletions from tha listed headers.
.fi




KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ... headerN.h )


.nf
     Use dis ta generate DCOP stubs from tha listed headers.
.fi




KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ... fileN.ui )


.nf
    Use dis ta add tha Qt designer ui filez ta yo' application/library.
.fi




KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ... fileN.kcfgc )


.nf
    Use dis ta add KDE kconfig compila filez ta yo' application/library.
.fi




KDE3_INSTALL_LIBTOOL_FILE(target)


.nf
    This will create n' install a simple libtool file fo' tha given target.
.fi




KDE3_ADD_EXECUTABLE(name file1 ... fileN )


.nf
    Currently identical ta add_executable(), may provide some advanced features up in tha future.
.fi




KDE3_ADD_KPART(name [WITH_PREFIX] file1 ... fileN )


.nf
    Smoke a KDE plugin (KPart, kioslave, etc.) from tha given source files.
    If WITH_PREFIX is given, tha resultin plugin gonna git tha prefix "lib", otherwise it won't.
    It creates n' installs a appropriate libtool la\-file.
.fi




KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ... fileN )


.nf
    Smoke a KDE application up in tha form of a module loadable via kdeinit.
    A library named kdeinit_<name> is ghon be pimped n' a lil' small-ass executable which links ta dat shit.
.fi




Da option KDE3_ENABLE_FINAL ta enable all\-in\-one compilation is no longer supported.





Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindKDE4
.nf
 
.fi

Find KDE4 n' provide all necessary variablez n' macros ta compile software fo' dat shit. Well shiiiit, it looks fo' KDE 4 up in tha followin directories up in tha given order:


.nf
  CMAKE_INSTALL_PREFIX
  KDEDIRS
  /opt/kde4
.fi




Please look up in FindKDE4Internal.cmake n' KDE4Macros.cmake fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. They is installed wit tha KDE 4 libraries up in $KDEDIRS/share/apps/cmake/modules/.


Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindLAPACK
Find LAPACK library

This module findz a installed fortran library dat implements tha LAPACK linear\-algebra intercourse (see http://www.netlib.org/lapack/).


Da approach bigs up dat taken fo' tha autoconf macro file, acx_lapack.m4 (distributed at http://ac\-archive.sourceforge.net/ac\-archive/acx_lapack.html).


This module sets tha followin variables:


.nf
  LAPACK_FOUND \- set ta legit if a library implementin tha LAPACK intercourse
    is found
  LAPACK_LINKER_FLAGS \- uncached list of required linker flags (excludin \-l
    n' \-L).
  LAPACK_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use LAPACK
  LAPACK95_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use LAPACK95
  LAPACK95_FOUND \- set ta legit if a library implementin tha LAPACK f95
    intercourse is found
  BLA_STATIC  if set on dis determines what tha fuck kind of linkage our phat asses do (static)
  BLA_VENDOR  if set checks only tha specified vendor, if not set checks
     all tha possibilities
  BLA_F95     if set on tries ta find tha f95 intercourses fo' BLAS/LAPACK
.fi

.TP
.B FindLATEX
Find Latex

This module findz if Latex is installed n' determines where tha executablez are. This code sets tha followin variables:


.nf
  LATEX_COMPILER:       path ta tha LaTeX compiler
  PDFLATEX_COMPILER:    path ta tha PdfLaTeX compiler
  BIBTEX_COMPILER:      path ta tha BibTeX compiler
  MAKEINDEX_COMPILER:   path ta tha MakeIndex compiler
  DVIPS_CONVERTER:      path ta tha DVIPS converter
  PS2PDF_CONVERTER:     path ta tha PS2PDF converter
  LATEX2HTML_CONVERTER: path ta tha LaTeX2Html converter
.fi




.TP
.B FindLibArchive
Find libarchive library n' headers

Da module defines tha followin variables:


.nf
  LibArchive_FOUND        \- legit if libarchive was found
  LibArchive_INCLUDE_DIRS \- include search path
  LibArchive_LIBRARIES    \- libraries ta link
  LibArchive_VERSION      \- libarchive 3\-component version number
.fi

.TP
.B FindLibLZMA
Find LibLZMA

Find LibLZMA headaz n' library


.nf
  LIBLZMA_FOUND             \- True if liblzma is found.
  LIBLZMA_INCLUDE_DIRS      \- Directory where liblzma headaz is located.
  LIBLZMA_LIBRARIES         \- Lzma libraries ta link against.
  LIBLZMA_HAS_AUTO_DECODER  \- True if lzma_auto_decoder() is found (required).
  LIBLZMA_HAS_EASY_ENCODER  \- True if lzma_easy_encoder() is found (required).
  LIBLZMA_HAS_LZMA_PRESET   \- True if lzma_lzma_preset() is found (required).
  LIBLZMA_VERSION_MAJOR     \- Da major version of lzma
  LIBLZMA_VERSION_MINOR     \- Da minor version of lzma
  LIBLZMA_VERSION_PATCH     \- Da patch version of lzma
  LIBLZMA_VERSION_STRING    \- version number as a strang (ex: "5.0.3")
.fi

.TP
.B FindLibXml2
Try ta find tha LibXml2 xml processin library

Once done dis will define


.nf
  LIBXML2_FOUND \- System has LibXml2
  LIBXML2_INCLUDE_DIR \- Da LibXml2 include directory
  LIBXML2_LIBRARIES \- Da libraries needed ta use LibXml2
  LIBXML2_DEFINITIONS \- Compila switches required fo' rockin LibXml2
  LIBXML2_XMLLINT_EXECUTABLE \- Da XML checkin tool xmllint comin wit LibXml2
  LIBXML2_VERSION_STRING \- tha version of LibXml2 found (since CMake 2.8.8)
.fi

.TP
.B FindLibXslt
Try ta find tha LibXslt library

Once done dis will define


.nf
  LIBXSLT_FOUND \- system has LibXslt
  LIBXSLT_INCLUDE_DIR \- tha LibXslt include directory
  LIBXSLT_LIBRARIES \- Link these ta LibXslt
  LIBXSLT_DEFINITIONS \- Compila switches required fo' rockin LibXslt
  LIBXSLT_VERSION_STRING \- version of LibXslt found (since CMake 2.8.8)
.fi

Additionally, tha followin two variablez is set (but not required fo' rockin xslt):


.nf
  LIBXSLT_EXSLT_LIBRARIES \- Link ta these if you need ta link against tha exslt library
  LIBXSLT_XSLTPROC_EXECUTABLE \- Gotz Nuff tha full path ta tha xsltproc executable if found
.fi

.TP
.B FindLua50
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA50_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES, both lua n' lualib
  LUA_INCLUDE_DIR, where ta find lua.h n' lualib.h (and probably lauxlib.h)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindLua51
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA51_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES
  LUA_INCLUDE_DIR, where ta find lua.h
  LUA_VERSION_STRING, tha version of Lua found (since CMake 2.8.8)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindLua52
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA52_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES
  LUA_INCLUDE_DIR, where ta find lua.h
  LUA_VERSION_STRING, tha version of Lua found (since CMake 2.8.8)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindMFC
Find MFC on Windows

Find tha natizzle MFC \- i.e. decizzle if a application can link ta tha MFC libraries.


.nf
  MFC_FOUND \- Was MFC support found
.fi

Yo ass don't need ta include anythang or link anythang ta use dat shit.

.TP
.B FindMPEG
Find tha natizzle MPEG includes n' library

This module defines


.nf
  MPEG_INCLUDE_DIR, where ta find MPEG.h, etc.
  MPEG_LIBRARIES, tha libraries required ta use MPEG.
  MPEG_FOUND, If false, do not try ta use MPEG.
.fi

also defined yo, but not fo' general use are


.nf
  MPEG_mpeg2_LIBRARY, where ta find tha MPEG library.
  MPEG_vo_LIBRARY, where ta find tha vo library.
.fi

.TP
.B FindMPEG2
Find tha natizzle MPEG2 includes n' library

This module defines


.nf
  MPEG2_INCLUDE_DIR, path ta mpeg2dec/mpeg2.h, etc.
  MPEG2_LIBRARIES, tha libraries required ta use MPEG2.
  MPEG2_FOUND, If false, do not try ta use MPEG2.
.fi

also defined yo, but not fo' general use are


.nf
  MPEG2_mpeg2_LIBRARY, where ta find tha MPEG2 library.
  MPEG2_vo_LIBRARY, where ta find tha vo library.
.fi

.TP
.B FindMPI
Find a Message Passin Interface (MPI) implementation

Da Message Passin Interface (MPI) be a library used ta write high\-performizzle distributed\-memory parallel applications, n' is typically deployed on a cold-ass lil clusta n' shit. MPI be a standard intercourse (defined by tha MPI forum) fo' which nuff implementations is available fo' realz. All of dem have somewhat different include paths, libraries ta link against, etc., n' dis module tries ta smooth up dem differences.


=== Variablez ===


This module will set tha followin variablez per language up in yo' project, where <lang> is one of C, CXX, or Fortran:


.nf
   MPI_<lang>_FOUND           TRUE if FindMPI found MPI flags fo' <lang>
   MPI_<lang>_COMPILER        MPI Compila wrapper fo' <lang>
   MPI_<lang>_COMPILE_FLAGS   Compilation flags fo' MPI programs
   MPI_<lang>_INCLUDE_PATH    Include path(s) fo' MPI header
   MPI_<lang>_LINK_FLAGS      Linkin flags fo' MPI programs
   MPI_<lang>_LIBRARIES       All libraries ta link MPI programs against
.fi

Additionally, FindMPI sets tha followin variablez fo' hustlin MPI programs from tha command line:


.nf
   MPIEXEC                    Executable fo' hustlin MPI programs
   MPIEXEC_NUMPROC_FLAG       Flag ta pass ta MPIEXEC before giving
                              it tha number of processors ta run on
   MPIEXEC_PREFLAGS           Flags ta pass ta MPIEXEC directly
                              before tha executable ta run.
   MPIEXEC_POSTFLAGS          Flags ta pass ta MPIEXEC afta other flags
.fi

=== Usage ===


To use dis module, simply call FindMPI from a CMakeLists.txt file, or run find_package(MPI), then run CMake.  If yo ass be aiiight wit tha auto\- detected configuration fo' yo' language, then you done.  If not, you have two options:


.nf
   1. Right back up in yo muthafuckin ass. Set MPI_<lang>_COMPILER ta tha MPI wrapper (mpicc, etc.) of your
      chizzle n' reconfigure.  FindMPI'ma attempt ta determine all the
      necessary variablez rockin THAT compilerz compile n' link flags.
   2. If dis fails, or if yo' MPI implementation do not come with
      a cold-ass lil compila wrapper, then set both MPI_<lang>_LIBRARIES and
      MPI_<lang>_INCLUDE_PATH.  Yo ass may also set any other variables
      listed above yo, but these two is required. Y'all KNOW dat shit, muthafucka!  This will circumvent
      autodetection entirely.
.fi

When configuration is successful, MPI_<lang>_COMPILER is ghon be set ta tha compila wrapper fo' <lang>, if dat shiznit was found. Y'all KNOW dat shit, muthafucka!  MPI_<lang>_FOUND n' other variablez above is ghon be set if any MPI implementation was found fo' <lang>, regardless of whether a cold-ass lil compila was found.


When rockin MPIEXEC ta execute MPI applications, you should typically use all of tha MPIEXEC flags as bigs up:


.nf
   ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} PROCS
     ${MPIEXEC_PREFLAGS} EXECUTABLE ${MPIEXEC_POSTFLAGS} ARGS
.fi

where PROCS is tha number of processors on which ta execute tha program, EXECUTABLE is tha MPI program, n' ARGS is tha arguments ta pass ta tha MPI program.


=== Backward Compatibilitizzle ===


For backward compatibilitizzle wit olda versionz of FindMPI, these variablez is set yo, but deprecated:


.nf
   MPI_FOUND           MPI_COMPILER        MPI_LIBRARY
   MPI_COMPILE_FLAGS   MPI_INCLUDE_PATH    MPI_EXTRA_LIBRARY
   MPI_LINK_FLAGS      MPI_LIBRARIES
.fi

In freshly smoked up projects, please use tha MPI_<lang>_XXX equivalents.

.TP
.B FindMatlab
this module looks fo' Matlab

Defines:


.nf
  MATLAB_INCLUDE_DIR: include path fo' mex.h, engine.h
  MATLAB_LIBRARIES:   required libraries: libmex, etc
  MATLAB_MEX_LIBRARY: path ta libmex.lib
  MATLAB_MX_LIBRARY:  path ta libmx.lib
  MATLAB_ENG_LIBRARY: path ta libeng.lib
.fi

.TP
.B FindMotif
Try ta find Motif (or lesstif)

Once done dis will define:


.nf
  MOTIF_FOUND        \- system has MOTIF
  MOTIF_INCLUDE_DIR  \- include paths ta use Motif
  MOTIF_LIBRARIES    \- Link these ta use Motif
.fi

.TP
.B FindOpenAL
.nf
 
.fi

Locate OpenAL This module defines OPENAL_LIBRARY OPENAL_FOUND, if false, do not try ta link ta OpenAL OPENAL_INCLUDE_DIR, where ta find tha headers


$OPENALDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OPENALDIR used up in buildin OpenAL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module.

.TP
.B FindOpenGL
Try ta find OpenGL

Once done dis will define


.nf
  OPENGL_FOUND        \- system has OpenGL
  OPENGL_XMESA_FOUND  \- system has XMESA
  OPENGL_GLU_FOUND    \- system has GLU
  OPENGL_INCLUDE_DIR  \- tha GL include directory
  OPENGL_LIBRARIES    \- Link these ta use OpenGL n' GLU
.fi




If you wanna use just GL you can use these joints


.nf
  OPENGL_gl_LIBRARY   \- Path ta OpenGL Library
  OPENGL_glu_LIBRARY  \- Path ta GLU Library
.fi




On OSX default ta rockin tha framework version of opengl Muthafuckas will gotta chizzle tha cache jointz of OPENGL_glu_LIBRARY n' OPENGL_gl_LIBRARY ta use OpenGL wit X11 on OSX

.TP
.B FindOpenMP
Findz OpenMP support

This module can be used ta detect OpenMP support up in a cold-ass lil compila n' shit. If tha compila supports OpenMP, tha flags required ta compile wit OpenMP support is returned up in variablez fo' tha different languages. Da variablez may be empty if tha compila do not need a special flag ta support OpenMP.


Da followin variablez is set:


.nf
   OpenMP_C_FLAGS \- flags ta add ta tha C compila fo' OpenMP support
   OpenMP_CXX_FLAGS \- flags ta add ta tha CXX compila fo' OpenMP support
   OPENMP_FOUND \- legit if openmp is detected
.fi




Supported compilaz can be found at http://openmp.org/wp/openmp\-compilers/

.TP
.B FindOpenSSL
Try ta find tha OpenSSL encryption library

Once done dis will define


.nf
  OPENSSL_ROOT_DIR \- Set dis variable ta tha root installation of OpenSSL
.fi




Read\-Only variables:


.nf
  OPENSSL_FOUND \- system has tha OpenSSL library
  OPENSSL_INCLUDE_DIR \- tha OpenSSL include directory
  OPENSSL_LIBRARIES \- Da libraries needed ta use OpenSSL
  OPENSSL_VERSION \- This is set ta $major.$minor.$revision$path (eg. 0.9.8s)
.fi

.TP
.B FindOpenSceneGraph
Find OpenSceneGraph

This module searches fo' tha OpenSceneGraph core "osg" library as well as OpenThreads, n' whatever additionizzle COMPONENTS (nodekits) dat you specify.


.nf
    See http://www.openscenegraph.org
.fi




NOTE: To use dis module effectively you must either require CMake >= 2.6.3 wit cmake_minimum_required(VERSION 2.6.3) or downlizzle n' place FindOpenThreads.cmake, Findosg_functions.cmake, Findosg.cmake, n' Find<etc>.cmake filez tha fuck into yo' CMAKE_MODULE_PATH.


==================================


This module accepts tha followin variablez (note mixed case)


.nf
    OpenSceneGraph_DEBUG \- Enable debuggin output
.fi




.nf
    OpenSceneGraph_MARK_AS_ADVANCED \- Mark cache variablez as advanced
                                      automatically
.fi




Da followin environment variablez is also bigged up fo' findin tha OSG n' itz various components, n' you can put dat on yo' toast.  CMAKE_PREFIX_PATH can also be used fo' dis (see find_library() CMake documentation).


.nf
    <MODULE>_DIR (where MODULE iz of tha form "OSGVOLUME" n' there be a FindosgVolume.cmake file)
    OSG_DIR
    OSGDIR
    OSG_ROOT
.fi




[CMake 2.8.10]: Da CMake variable OSG_DIR can now be used as well ta influence detection, instead of needin ta specify a environment variable.


This module defines tha followin output variables:


.nf
    OPENSCENEGRAPH_FOUND \- Was tha OSG n' all of tha specified components found?
.fi




.nf
    OPENSCENEGRAPH_VERSION \- Da version of tha OSG which was found
.fi




.nf
    OPENSCENEGRAPH_INCLUDE_DIRS \- Where ta find tha headers
.fi




.nf
    OPENSCENEGRAPH_LIBRARIES \- Da OSG libraries
.fi




================================== Example Usage:


.nf
  find_package(OpenSceneGraph 2.0.0 REQUIRED osgDB osgUtil)
      # libOpenThreadz & libosg automatically searched
  include_directories(${OPENSCENEGRAPH_INCLUDE_DIRS})
.fi




.nf
  add_executable(foo foo.cc)
  target_link_libraries(foo ${OPENSCENEGRAPH_LIBRARIES})
.fi




.TP
.B FindOpenThreads
.nf
 
.fi

OpenThreadz be a C++ based threadin library. Its phattest userbase seems ta OpenSceneGraph so you might notice I accept OSGDIR as a environment path. I consider dis part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module.


Locate OpenThreadz This module defines OPENTHREADS_LIBRARY OPENTHREADS_FOUND, if false, do not try ta link ta OpenThreadz OPENTHREADS_INCLUDE_DIR, where ta find tha headers


$OPENTHREADS_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OPENTHREADS_DIR used up in buildin osg.


[CMake 2.8.10]: Da CMake variablez OPENTHREADS_DIR or OSG_DIR can now be used as well ta influence detection, instead of needin ta specify a environment variable.


Created by Eric Wing.

.TP
.B FindPHP4
Find PHP4

This module findz if PHP4 is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PHP4_INCLUDE_PATH       = path ta where php.h can be found
  PHP4_EXECUTABLE         = full path ta tha php4 binary
.fi




.TP
.B FindPNG
Find tha natizzle PNG includes n' library




This module searches libpng, tha library fo' hustlin wit PNG images.


It defines tha followin variables


.nf
  PNG_INCLUDE_DIRS, where ta find png.h, etc.
  PNG_LIBRARIES, tha libraries ta link against ta use PNG.
  PNG_DEFINITIONS \- Yo ass should add_definitons(${PNG_DEFINITIONS}) before compilin code dat includes png library files.
  PNG_FOUND, If false, do not try ta use PNG.
  PNG_VERSION_STRING \- tha version of tha PNG library found (since CMake 2.8.8)
.fi

Also defined yo, but not fo' general use are


.nf
  PNG_LIBRARY, where ta find tha PNG library.
.fi

For backward compatiblitizzle tha variable PNG_INCLUDE_DIR be also set. Well shiiiit, it has tha same ol' dirty value as PNG_INCLUDE_DIRS.


Since PNG dependz on tha ZLib compression library, none of tha above is ghon be defined unless ZLib can be found.

.TP
.B FindPackageHandleStandardArgs
.nf
 
.fi

FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> ... )


This function is intended ta be used up in FindXXX.cmake modulez files. Well shiiiit, it handlez tha REQUIRED, QUIET n' version\-related arguments ta find_package(). Well shiiiit, it also sets tha <packagename>_FOUND variable. Da package is considered found if all variablez <var1>... listed contain valid thangs up in dis biatch, e.g. valid filepaths.


There is two modez of dis function. I aint talkin' bout chicken n' gravy biatch. Da first argument up in both modes is tha name of tha Find\-module where it is called (in original gangsta casing).


Da first simple mode be lookin like this:


.nf
    FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> (DEFAULT_MSG|"Custom failure message") <var1>...<varN> )
.fi

If tha variablez <var1> ta <varN> is all valid, then <UPPERCASED_NAME>_FOUND is ghon be set ta TRUE. If DEFAULT_MSG is given as second argument, then tha function will generate itself useful success n' error lyrics. Yo ass can also supply a cold-ass lil custom error message fo' tha failure case. This aint recommended.


Da second mode is mo' bangin n' also supports version checking:


.nf
    FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME [FOUND_VAR <resultVar>]
                                           [REQUIRED_VARS <var1>...<varN>]
                                           [VERSION_VAR   <versionvar>]
                                           [HANDLE_COMPONENTS]
                                           [CONFIG_MODE]
                                           [FAIL_MESSAGE "Custom failure message"] )
.fi




In dis mode, tha name of tha result\-variable can be set either ta either <UPPERCASED_NAME>_FOUND or <OriginalCase_Name>_FOUND rockin tha FOUND_VAR option. I aint talkin' bout chicken n' gravy biatch. Other names fo' tha result\-variable is not allowed. Y'all KNOW dat shit, muthafucka! So fo' a Find\-module named FindFooBar.cmake, tha two possible names is FooBar_FOUND n' FOOBAR_FOUND. Well shiiiit, it is recommended ta use tha original gangsta case version. I aint talkin' bout chicken n' gravy biatch. If tha FOUND_VAR option aint used, tha default is <UPPERCASED_NAME>_FOUND.


As up in tha simple mode, if <var1> all up in <varN> is all valid, <packagename>_FOUND is ghon be set ta TRUE fo' realz. Afta REQUIRED_VARS tha variablez which is required fo' dis package is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Peepin VERSION_VAR tha name of tha variable can be specified which holdz tha version of tha package which has been found. Y'all KNOW dat shit, muthafucka! If dis is done, dis version is ghon be checked against tha (potentially) specified required version used up in tha find_package() call. Da EXACT keyword be also handled. Y'all KNOW dat shit, muthafucka! Da default lyrics include shiznit bout tha required version n' tha version which has been straight-up found, both if tha version be aiiight or not. If tha package supports components, use tha HANDLE_COMPONENTS option ta enable handlin em. In dis case, find_package_handle_standard_args() will report which components done been found n' which is missing, n' tha <packagename>_FOUND variable is ghon be set ta FALSE if any of tha required components (i.e. not tha ones listed afta OPTIONAL_COMPONENTS) is missing. Use tha option CONFIG_MODE if yo' FindXXX.cmake module be a wrapper fo' a gangbangin' find_package(... NO_MODULE) call.  In dis case VERSION_VAR is ghon be set ta <NAME>_VERSION n' tha macro will automatically check whether tha Config module was found. Y'all KNOW dat shit, muthafucka! Via FAIL_MESSAGE a cold-ass lil custom failure message can be specified, if dis aint used, tha default message is ghon be displayed.


Example fo' mode 1:


.nf
    find_package_handle_standard_args(LibXml2  DEFAULT_MSG  LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR)
.fi




LibXml2 is considered ta be found, if both LIBXML2_LIBRARY n' LIBXML2_INCLUDE_DIR is valid. Y'all KNOW dat shit, muthafucka! Then also LIBXML2_FOUND is set ta TRUE. If it aint found n' REQUIRED was used, it fails wit FATAL_ERROR, independent whether QUIET was used or not. If it is found, success is ghon be reported, includin tha content of <var1>. On repeated Cmake runs, tha same message won't be printed again.


Example fo' mode 2:


.nf
    find_package_handle_standard_args(LibXslt FOUND_VAR LibXslt_FOUND
                                             REQUIRED_VARS LibXslt_LIBRARIES LibXslt_INCLUDE_DIRS
                                             VERSION_VAR LibXslt_VERSION_STRING)
.fi

In dis case, LibXslt is considered ta be found if tha variable(s) listed afta REQUIRED_VAR is all valid, i.e. LibXslt_LIBRARIES n' LibXslt_INCLUDE_DIRS up in dis case. Da result will then be stored up in LibXslt_FOUND  fo' realz. Also tha version of LibXslt is ghon be checked by rockin tha version contained up in LibXslt_VERSION_STRING. Right back up in yo muthafuckin ass. Since no FAIL_MESSAGE is given, tha default lyrics is ghon be printed.


Another example fo' mode 2:


.nf
    find_package(Automoc4 QUIET NO_MODULE HINTS /opt/automoc4)
    find_package_handle_standard_args(Automoc4  CONFIG_MODE)
.fi

In dis case, FindAutmoc4.cmake wraps a cold-ass lil call ta find_package(Automoc4 NO_MODULE) n' addz a additionizzle search directory fo' automoc4 yo. Here tha result is ghon be stored up in AUTOMOC4_FOUND. Da followin FIND_PACKAGE_HANDLE_STANDARD_ARGS() call produces a proper success/error message.

.TP
.B FindPackageMessage
.nf
 
.fi

FIND_PACKAGE_MESSAGE(<name> "message fo' user" "find result details")


This macro is intended ta be used up in FindXXX.cmake modulez files. Well shiiiit, it will print a message once fo' each unique find result. This is useful fo' spittin some lyrics ta tha user where a package was found. Y'all KNOW dat shit, muthafucka! Da first argument specifies tha name (XXX) of tha package. Da second argument specifies tha message ta display. Da third argument lists details bout tha find result so dat if they chizzle tha message is ghon be displayed again. I aint talkin' bout chicken n' gravy biatch. Da macro also obeys tha QUIET argument ta tha find_package command.


Example:


.nf
  if(X11_FOUND)
    FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
      "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
  else()
   ...
  endif()
.fi

.TP
.B FindPerl
Find perl

this module looks fo' Perl


.nf
  PERL_EXECUTABLE     \- tha full path ta perl
  PERL_FOUND          \- If false, don't attempt ta use perl.
  PERL_VERSION_STRING \- version of perl found (since CMake 2.8.8)
.fi

.TP
.B FindPerlLibs
Find Perl libraries

This module findz if PERL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PERLLIBS_FOUND    = True if perl.h & libperl was found
  PERL_INCLUDE_PATH = path ta where perl.h is found
  PERL_LIBRARY      = path ta libperl
  PERL_EXECUTABLE   = full path ta tha perl binary
.fi




Da minimum required version of Perl can be specified rockin tha standard syntax, e.g. find_package(PerlLibs 6.0)


.nf
  Da followin variablez is also available if needed
  (introduced afta CMake 2.6.4)
.fi




.nf
  PERL_SITESEARCH    = path ta tha cribsearch install dir
  PERL_SITELIB       = path ta tha criblib install directory
  PERL_VENDORARCH    = path ta tha vendor arch install directory
  PERL_VENDORLIB     = path ta tha vendor lib install directory
  PERL_ARCHLIB       = path ta tha arch lib install directory
  PERL_PRIVLIB       = path ta tha priv lib install directory
  PERL_EXTRA_C_FLAGS = Compilation flags used ta build perl
.fi




.TP
.B FindPhysFS
.nf
 
.fi

Locate PhysFS library This module defines PHYSFS_LIBRARY, tha name of tha library ta link against PHYSFS_FOUND, if false, do not try ta link ta PHYSFS PHYSFS_INCLUDE_DIR, where ta find physfs.h


$PHYSFSDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$PHYSFSDIR used up in buildin PHYSFS.


Created by Eric Wing.

.TP
.B FindPike
Find Pike

This module findz if PIKE is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PIKE_INCLUDE_PATH       = path ta where program.h is found
  PIKE_EXECUTABLE         = full path ta tha pike binary
.fi




.TP
.B FindPkgConfig
a pkg\-config module fo' CMake




Usage:


.nf
   pkg_check_modules(<PREFIX> [REQUIRED] [QUIET] <MODULE> [<MODULE>]*)
     checks fo' all tha given modules
.fi




.nf
   pkg_search_module(<PREFIX> [REQUIRED] [QUIET] <MODULE> [<MODULE>]*)
     checks fo' given modulez n' uses tha straight-up original gangsta hustlin one
.fi




When tha 'REQUIRED' argument was set, macros will fail wit a error when module(s) could not be found


When tha 'QUIET' argument is set, no status lyrics is ghon be printed.


It sets tha followin variables:


.nf
   PKG_CONFIG_FOUND          ... if pkg\-config executable was found
   PKG_CONFIG_EXECUTABLE     ... pathname of tha pkg\-config program
   PKG_CONFIG_VERSION_STRING ... tha version of tha pkg\-config program found
                                 (since CMake 2.8.8)
.fi




For tha followin variablez two setz of joints exist; first one is tha common one n' has tha given PREFIX. Da second set gotz nuff flags which is given up when pkgconfig was called wit tha '\-\-static' option.


.nf
   <XPREFIX>_FOUND          ... set ta 1 if module(s) exist
   <XPREFIX>_LIBRARIES      ... only tha libraries (w/o tha '\-l')
   <XPREFIX>_LIBRARY_DIRS   ... tha pathz of tha libraries (w/o tha '\-L')
   <XPREFIX>_LDFLAGS        ... all required linker flags
   <XPREFIX>_LDFLAGS_OTHER  ... all other linker flags
   <XPREFIX>_INCLUDE_DIRS   ... tha '\-I' preprocessor flags (w/o tha '\-I')
   <XPREFIX>_CFLAGS         ... all required cflags
   <XPREFIX>_CFLAGS_OTHER   ... tha other compila flags
.fi




.nf
   <XPREFIX> = <PREFIX>        fo' common case
   <XPREFIX> = <PREFIX>_STATIC fo' static linking
.fi




There is some special variablez whose prefix dependz on tha count of given modules. When there is only one module, <PREFIX> stays unchanged. Y'all KNOW dat shit, muthafucka! When there be multiple modules, tha prefix is ghon be chizzled ta <PREFIX>_<MODNAME>:


.nf
   <XPREFIX>_VERSION    ... version of tha module
   <XPREFIX>_PREFIX     ... prefix\-directory of tha module
   <XPREFIX>_INCLUDEDIR ... include\-dir of tha module
   <XPREFIX>_LIBDIR     ... lib\-dir of tha module
.fi




.nf
   <XPREFIX> = <PREFIX>  when |MODULES| == 1, else
   <XPREFIX> = <PREFIX>_<MODNAME>
.fi




A <MODULE> parameta can have tha followin formats:


.nf
   {MODNAME}            ... matches any version
   {MODNAME}>={VERSION} ... at least version <VERSION> is required
   {MODNAME}={VERSION}  ... exactly version <VERSION> is required
   {MODNAME}<={VERSION} ... modulez must not be newer than <VERSION>
.fi




Examples


.nf
   pkg_check_modulez (GLIB2   glib\-2.0)
.fi




.nf
   pkg_check_modulez (GLIB2   glib\-2.0>=2.10)
     requires at least version 2.10 of glib2 n' defines e.g.
       GLIB2_VERSION=2.10.3
.fi




.nf
   pkg_check_modulez (FOO     glib\-2.0>=2.10 gtk+\-2.0)
     requires both glib2 n' gtk2, n' defines e.g.
       FOO_glib\-2.0_VERSION=2.10.3
       FOO_gtk+\-2.0_VERSION=2.8.20
.fi




.nf
   pkg_check_modulez (XRENDER REQUIRED xrender)
     defines e.g.:
       XRENDER_LIBRARIES=Xrender;X11
       XRENDER_STATIC_LIBRARIES=Xrender;X11;pthread;Xau;Xdmcp
.fi




.nf
   pkg_search_module (BAR     libxml\-2.0 libxml2 libxml>=2)
.fi

.TP
.B FindPostgreSQL
Find tha PostgreSQL installation.

In Windows, we make tha assumption that, if tha PostgreSQL filez is installed, tha default directory is ghon be C:\\Program Files\\PostgreSQL.


This module defines


.nf
  PostgreSQL_LIBRARIES \- tha PostgreSQL libraries needed fo' linking
  PostgreSQL_INCLUDE_DIRS \- tha directoriez of tha PostgreSQL headers
  PostgreSQL_VERSION_STRING \- tha version of PostgreSQL found (since CMake 2.8.8)
.fi

.TP
.B FindProducer
.nf
 
.fi

Though Producer aint directly part of OpenSceneGraph, its primary user is OSG so I consider dis part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. You'll notice dat I accept OSGDIR as a environment path.


Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL (and OpenThreads?) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate Producer This module defines PRODUCER_LIBRARY PRODUCER_FOUND, if false, do not try ta link ta Producer PRODUCER_INCLUDE_DIR, where ta find tha headers


$PRODUCER_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$PRODUCER_DIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindProtobuf
.nf
 
.fi

Locate n' configure tha Gizoogle Protocol Buffers library.


Da followin variablez can be set n' is optional:


.nf
   PROTOBUF_SRC_ROOT_FOLDER \- When compilin wit MSVC, if dis cache variable is set
                              tha protobuf\-default VS project build locations
                              (vsprojects/Debug & vsprojects/Release) is ghon be searched
                              fo' libraries n' binaries.
.fi




.nf
   PROTOBUF_IMPORT_DIRS     \- List of additionizzle directories ta be searched for
                              imported .proto files. (New up in CMake 2.8.8)
.fi




Defines tha followin variables:


.nf
   PROTOBUF_FOUND \- Found tha Gizoogle Protocol Buffers library (libprotobuf & header files)
   PROTOBUF_INCLUDE_DIRS \- Include directories fo' Gizoogle Protocol Buffers
   PROTOBUF_LIBRARIES \- Da protobuf libraries
.fi

[New up in CMake 2.8.5]


.nf
   PROTOBUF_PROTOC_LIBRARIES \- Da protoc libraries
   PROTOBUF_LITE_LIBRARIES \- Da protobuf\-lite libraries
.fi




Da followin cache variablez is also available ta set or use:


.nf
   PROTOBUF_LIBRARY \- Da protobuf library
   PROTOBUF_PROTOC_LIBRARY   \- Da protoc library
   PROTOBUF_INCLUDE_DIR \- Da include directory fo' protocol buffers
   PROTOBUF_PROTOC_EXECUTABLE \- Da protoc compiler
.fi

[New up in CMake 2.8.5]


.nf
   PROTOBUF_LIBRARY_DEBUG \- Da protobuf library (debug)
   PROTOBUF_PROTOC_LIBRARY_DEBUG   \- Da protoc library (debug)
   PROTOBUF_LITE_LIBRARY \- Da protobuf lite library
   PROTOBUF_LITE_LIBRARY_DEBUG \- Da protobuf lite library (debug)
.fi




.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(Protobuf REQUIRED)
   include_directories(${PROTOBUF_INCLUDE_DIRS})
.fi




.nf
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
   PROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS foo.proto)
   add_executable(bar bar.cc ${PROTO_SRCS} ${PROTO_HDRS})
   target_link_libraries(bar ${PROTOBUF_LIBRARIES})
.fi




NOTE: Yo ass may need ta link against pthreads, depending


.nf
       on tha platform.
.fi




NOTE: Da PROTOBUF_GENERATE_CPP macro & add_executable() or add_library()


.nf
       calls only work properly within tha same directory.
.fi




.nf
  ====================================================================
.fi




PROTOBUF_GENERATE_CPP (hood function)


.nf
   SRCS = Variable ta define wit autogenerated
          source files
   HDRS = Variable ta define wit autogenerated
          header files
   ARGN = proto files
.fi




.nf
  ====================================================================
.fi

.TP
.B FindPythonInterp
Find python interpreter

This module findz if Python interpreta is installed n' determines where tha executablez are. This code sets tha followin variables:


.nf
  PYTHONINTERP_FOUND         \- Was tha Python executable found
  PYTHON_EXECUTABLE          \- path ta tha Python interpreter
.fi




.nf
  PYTHON_VERSION_STRING      \- Python version found e.g. 2.5.2
  PYTHON_VERSION_MAJOR       \- Python major version found e.g. 2
  PYTHON_VERSION_MINOR       \- Python minor version found e.g. 5
  PYTHON_VERSION_PATCH       \- Python patch version found e.g. 2
.fi




Da Python_ADDITIONAL_VERSIONS variable can be used ta specify a list of version numbers dat should be taken tha fuck into account when searchin fo' Python. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta set dis variable before callin find_package(PythonInterp).

.TP
.B FindPythonLibs
Find python libraries

This module findz if Python is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PYTHONLIBS_FOUND           \- have tha Python libs been found
  PYTHON_LIBRARIES           \- path ta tha python library
  PYTHON_INCLUDE_PATH        \- path ta where Python.h is found (deprecated)
  PYTHON_INCLUDE_DIRS        \- path ta where Python.h is found
  PYTHON_DEBUG_LIBRARIES     \- path ta tha debug library (deprecated)
  PYTHONLIBS_VERSION_STRING  \- version of tha Python libs found (since CMake 2.8.8)
.fi




Da Python_ADDITIONAL_VERSIONS variable can be used ta specify a list of version numbers dat should be taken tha fuck into account when searchin fo' Python. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta set dis variable before callin find_package(PythonLibs).


If you'd like ta specify tha installation of Python ta use, you should modify tha followin cache variables:


.nf
  PYTHON_LIBRARY             \- path ta tha python library
  PYTHON_INCLUDE_DIR         \- path ta where Python.h is found
.fi

.TP
.B FindQt
Searches fo' all installed versionz of Qt.

This should only be used if yo' project can work wit multiple versionz of Qt.  If not, you should just directly use FindQt4 or FindQt3. If multiple versionz of Qt is found on tha machine, then Da user must set tha option DESIRED_QT_VERSION ta tha version they wanna use.  If only one version of qt is found on tha machine, then tha DESIRED_QT_VERSION is set ta dat version n' tha matchin FindQt3 or FindQt4 module is included. Y'all KNOW dat shit, muthafucka! Once tha user sets DESIRED_QT_VERSION, then tha FindQt3 or FindQt4 module is included.


.nf
  QT_REQUIRED if dis is set ta TRUE then if CMake can
              not find Qt4 or Qt3 a error is raised
              n' a message is busted ta tha user.
.fi




.nf
  DESIRED_QT_VERSION OPTION is pimped
  QT4_INSTALLED is set ta TRUE if qt4 is found.
  QT3_INSTALLED is set ta TRUE if qt3 is found.
.fi

.TP
.B FindQt3
Locate Qt include paths n' libraries

This module defines:


.nf
  QT_INCLUDE_DIR    \- where ta find qt.h, etc.
  QT_LIBRARIES      \- tha libraries ta link against ta use Qt.
  QT_DEFINITIONS    \- definitions ta use when
                      compilin code dat uses Qt.
  QT_FOUND          \- If false, don't try ta use Qt.
  QT_VERSION_STRING \- tha version of Qt found
.fi




If you need tha multithreaded version of Qt, set QT_MT_REQUIRED ta TRUE


Also defined yo, but not fo' general use are:


.nf
  QT_MOC_EXECUTABLE, where ta find tha moc tool.
  QT_UIC_EXECUTABLE, where ta find tha uic tool.
  QT_QT_LIBRARY, where ta find tha Qt library.
  QT_QTMAIN_LIBRARY, where ta find tha qtmain
   library. This is only required by Qt3 on Windows.
.fi

.TP
.B FindQt4
Find Qt 4

This module can be used ta find Qt4. Da most blingin issue is dat tha Qt4 qmake be available via tha system path. This qmake is then used ta detect basically every last muthafuckin thang else. This module defines a fuckin shitload of key variablez n' macros. Da variable QT_USE_FILE is set which is tha path ta a CMake file dat can be included ta compile Qt 4 applications n' libraries. Put ya muthafuckin choppers up if ya feel dis!  It sets up tha compilation environment fo' include directories, preprocessor defines n' populates a QT_LIBRARIES variable.


Typical usage could be suttin' like:


.nf
   find_package(Qt4 4.4.3 REQUIRED QtCore QtGui QtXml)
   include(${QT_USE_FILE})
   add_executable(myexe main.cpp)
   target_link_libraries(myexe ${QT_LIBRARIES})
.fi




Da minimum required version can be specified rockin tha standard find_package()\-syntax (see example above). For compatibilitizzle wit olda versionz of FindQt4.cmake it be also possible ta set tha variable QT_MIN_VERSION ta tha minimum required version of Qt4 before tha find_package(Qt4) command. Y'all KNOW dat shit, muthafucka! If both is used, tha version used up in tha find_package() command overrides tha one from QT_MIN_VERSION.


When rockin tha components argument, QT_USE_QT* variablez is automatically set fo' tha QT_USE_FILE ta pick up.  If one wishes ta manually set them, tha available ones ta set include:


.nf
                    QT_DONT_USE_QTCORE
                    QT_DONT_USE_QTGUI
                    QT_USE_QT3SUPPORT
                    QT_USE_QTASSISTANT
                    QT_USE_QAXCONTAINER
                    QT_USE_QAXSERVER
                    QT_USE_QTDESIGNER
                    QT_USE_QTMOTIF
                    QT_USE_QTMAIN
                    QT_USE_QTMULTIMEDIA
                    QT_USE_QTNETWORK
                    QT_USE_QTNSPLUGIN
                    QT_USE_QTOPENGL
                    QT_USE_QTSQL
                    QT_USE_QTXML
                    QT_USE_QTSVG
                    QT_USE_QTTEST
                    QT_USE_QTUITOOLS
                    QT_USE_QTDBUS
                    QT_USE_QTSCRIPT
                    QT_USE_QTASSISTANTCLIENT
                    QT_USE_QTHELP
                    QT_USE_QTWEBKIT
                    QT_USE_QTXMLPATTERNS
                    QT_USE_PHONON
                    QT_USE_QTSCRIPTTOOLS
                    QT_USE_QTDECLARATIVE
.fi




.nf
  QT_USE_IMPORTED_TARGETS
        If dis variable is set ta TRUE, FindQt4.cmake will create imported
        library targets fo' tha various Qt libraries n' set the
        library variablez like QT_QTCORE_LIBRARY ta point at these imported
        targets instead of tha library file on disk. This serves up much better
        handlin of tha release n' debug versionz of tha Qt libraries n' is
       also always backwardz compatible, except fo' tha case dat dependencies
       of libraries is exported, these will then also list tha namez of the
       imported targets as dependency n' not tha file location on disk. This
       is much mo' flexible yo, but requires dat FindQt4.cmake is executed before
       such a exported dependency file is processed.
.fi




.nf
       Note dat if rockin IMPORTED targets, tha qtmain.lib static library is
       automatically linked on Windows. To disable dat globally, set the
       QT4_NO_LINK_QTMAIN variable before findin Qt4. To disable dat fo' a
       particular executable, set tha QT4_NO_LINK_QTMAIN target property to
       True on tha executable.
.fi




.nf
  QT_INCLUDE_DIRS_NO_SYSTEM
        If dis variable is set ta TRUE, tha Qt include directories
        up in tha QT_USE_FILE will NOT have tha SYSTEM keyword set.
.fi




There is also some filez dat need processin by some Qt tools like fuckin moc n' uic.  Listed below is macros dat may be used ta process dem files.


.nf
  macro QT4_WRAP_CPP(outfilez inputfile ... OPTIONS ...)
        create moc code from a list of filez containin Qt class with
        tha Q_OBJECT declaration. I aint talkin' bout chicken n' gravy biatch.  Per\-directory preprocessor definitions
        is also added. Y'all KNOW dat shit, muthafucka!  Options may be given ta moc, like fuckin dem found
        when executin "moc \-help".
.fi




.nf
  macro QT4_WRAP_UI(outfilez inputfile ... OPTIONS ...)
        create code from a list of Qt designer ui files.
        Options may be given ta uic, like fuckin dem found
        when executin "uic \-help"
.fi




.nf
  macro QT4_ADD_RESOURCES(outfilez inputfile ... OPTIONS ...)
        create code from a list of Qt resource files.
        Options may be given ta rcc, like fuckin dem found
        when executin "rcc \-help"
.fi




.nf
  macro QT4_GENERATE_MOC(inputfile outputfile )
        creates a rule ta run moc on infile n' create outfile.
        Use dis if fo' some reason QT4_WRAP_CPP() aint appropriate, e.g.
        cuz you need a cold-ass lil custom filename fo' tha moc file or suttin' similar.
.fi




.nf
  macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
        Da qt4_automoc macro is obsolete.  Use tha CMAKE_AUTOMOC feature instead.
        This macro is still experimental.
        It can be used ta have moc automatically handled.
        So if you have tha filez foo.h n' foo.cpp, n' up in foo.h a
        a cold-ass lil class uses tha Q_OBJECT macro, moc has ta run on dat shit. If you don't
        wanna use QT4_WRAP_CPP() (which is reliable n' mature), you can insert
        #include "foo.moc"
        up in foo.cpp n' then give foo.cpp as argument ta QT4_AUTOMOC(). This will the
        scan all listed filez at cmake\-time fo' such included moc filez n' if it finds
        dem cause a rule ta be generated ta run moc at build time on the
        accompanyin header file foo.h.
        If a source file has tha SKIP_AUTOMOC property set it is ghon be ignored by dis macro.
.fi




.nf
        Yo ass should gotz a look on tha AUTOMOC property fo' targets ta big up tha same thangs up in dis biatch.
.fi




.nf
  macro QT4_ADD_DBUS_INTERFACE(outfilez intercourse basename)
        Smoke tha intercourse header n' implementation filez wit the
        given basename from tha given intercourse xml file n' add it to
        tha list of sources.
.fi




.nf
        Yo ass can pass additionizzle parametas ta tha qdbusxml2cpp call by setting
        propertizzles on tha input file:
.fi




.nf
        INCLUDE tha given file is ghon be included up in tha generate intercourse header
.fi




.nf
        CLASSNAME tha generated class is named accordingly
.fi




.nf
        NO_NAMESPACE tha generated class aint wrapped up in a namespace
.fi




.nf
  macro QT4_ADD_DBUS_INTERFACES(outfilez inputfile ... )
        Smoke tha intercourse header n' implementation files
        fo' all listed intercourse xml files.
        Da basename is ghon be automatically determined from tha name of tha xml file.
.fi




.nf
        Da source file propertizzles busted lyrics bout fo' QT4_ADD_DBUS_INTERFACE also apply here.
.fi




.nf
  macro QT4_ADD_DBUS_ADAPTOR(outfilez xmlfile parentheader parentclassname [basename] [classname])
        create a thugged-out dbus adaptor (header n' implementation file) from tha xml file
        describin tha intercourse, n' add it ta tha list of sources. Da adaptor
        forwardz tha calls ta a parent class, defined up in parentheader n' named
        parentclassname. Da name of tha generated filez will be
        <basename>adaptor.{cpp,h} where basename defaults ta tha basename of tha xml file.
        If <classname> is provided, then it is ghon be used as tha classname of the
        adaptor itself.
.fi




.nf
  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] OPTIONS ...)
        generate tha xml intercourse file from tha given header.
        If tha optionizzle argument intercoursename is omitted, tha name of the
        intercourse file is constructed from tha basename of tha header with
        tha suffix .xml appended.
        Options may be given ta qdbuscpp2xml, like fuckin dem found when executin "qdbuscpp2xml \-\-help"
.fi




.nf
  macro QT4_CREATE_TRANSLATION( qm_filez directories ... sources ...
                                ts_filez ... OPTIONS ...)
        out: qm_files
        in:  directories sources ts_files
        options: flags ta pass ta lupdate, like fuckin \-extensions ta specify
        extensions fo' a gangbangin' finger-lickin' directory scan.
        generates commandz ta create .ts (vie lupdate) n' .qm
        (via lrelease) \- filez from directories and/or sources. Da ts filez are
        pimped and/or updated up in tha source tree (unless given wit full paths).
        Da qm filez is generated up in tha build tree.
        Uppimpin tha translations can be done by addin tha qm_files
        ta tha source list of yo' library/executable, so they are
        always updated, or by addin a cold-ass lil custom target ta control when
        they git updated/generated.
.fi




.nf
  macro QT4_ADD_TRANSLATION( qm_filez ts_filez ... )
        out: qm_files
        in:  ts_files
        generates commandz ta create .qm from .ts \- files. Da generated
        filenames can be found up in qm_files. Da ts_files
        must exist n' is not updated up in any way.
.fi




function QT4_USE_MODULES( target [link_type] modules...)


.nf
        This function is obsolete. Use target_link_libraries wit IMPORTED targets instead.
        Make <target> use tha <modules> from Qt. Usin a Qt module means
        ta link ta tha library, add tha relevant include directories fo' tha module,
        n' add tha relevant compila defines fo' rockin tha module.
        Modulez is roughly equivalent ta componentz of Qt4, so usage would be
        suttin' like:
         qt4_use_modules(myexe Core Gui Declarative)
        ta use QtCore, QtGui n' QtDeclarative. Da optionizzle <link_type> argument can
        be specified as either LINK_PUBLIC or LINK_PRIVATE ta specify tha same argument
        ta tha target_link_libraries call.
.fi







.nf
  Below be a thugged-out detailed list of variablez dat FindQt4.cmake sets.
  QT_FOUND         If false, don't try ta use Qt.
  Qt4_FOUND        If false, don't try ta use Qt 4.
  QT4_FOUND        If false, don't try ta use Qt 4. This variable is fo' compatibilitizzle only.
.fi




.nf
  QT_VERSION_MAJOR Da major version of Qt found.
  QT_VERSION_MINOR Da minor version of Qt found.
  QT_VERSION_PATCH Da patch version of Qt found.
.fi




.nf
  QT_EDITION               Set ta tha edizzle of Qt (i.e. DesktopLight)
  QT_EDITION_DESKTOPLIGHT  True if QT_EDITION == DesktopLight
  QT_QTCORE_FOUND          True if QtCore was found.
  QT_QTGUI_FOUND           True if QtGui was found.
  QT_QT3SUPPORT_FOUND      True if Qt3Support was found.
  QT_QTASSISTANT_FOUND     True if QtAssistant was found.
  QT_QTASSISTANTCLIENT_FOUND  True if QtAssistantClient was found.
  QT_QAXCONTAINER_FOUND    True if QAxContainer was found (Windows only).
  QT_QAXSERVER_FOUND       True if QAxServer was found (Windows only).
  QT_QTDBUS_FOUND          True if QtDBus was found.
  QT_QTDESIGNER_FOUND      True if QtDesigner was found.
  QT_QTDESIGNERCOMPONENTS  True if QtDesignerComponents was found.
  QT_QTHELP_FOUND          True if QtHelp was found.
  QT_QTMOTIF_FOUND         True if QtMotif was found.
  QT_QTMULTIMEDIA_FOUND    True if QtMultimedia was found (since Qt 4.6.0).
  QT_QTNETWORK_FOUND       True if QtNetwork was found.
  QT_QTNSPLUGIN_FOUND      True if QtNsPlugin was found.
  QT_QTOPENGL_FOUND        True if QtOpenGL was found.
  QT_QTSQL_FOUND           True if QtSql was found.
  QT_QTSVG_FOUND           True if QtSvg was found.
  QT_QTSCRIPT_FOUND        True if QtScript was found.
  QT_QTSCRIPTTOOLS_FOUND   True if QtScriptTools was found.
  QT_QTTEST_FOUND          True if QtTest was found.
  QT_QTUITOOLS_FOUND       True if QtUiTools was found.
  QT_QTWEBKIT_FOUND        True if QtWebKit was found.
  QT_QTXML_FOUND           True if QtXml was found.
  QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
  QT_PHONON_FOUND          True if phonon was found.
  QT_QTDECLARATIVE_FOUND   True if QtDeclaratizzle was found.
.fi




.nf
  QT_MAC_USE_COCOA    For Mac OS X, its whether Cocoa or Carbon is used.
                      In general, dis should not be used yo, but its useful
                      when havin platform specific code.
.fi




.nf
  QT_DEFINITIONS   Definitions ta use when compilin code dat uses Qt.
                   Yo ass do not need ta use dis if you include QT_USE_FILE.
                   Da QT_USE_FILE will also define QT_DEBUG n' QT_NO_DEBUG
                   ta fit yo' current build type.  Those is not contained
                   up in QT_DEFINITIONS.
.fi




.nf
  QT_INCLUDES      List of paths ta all include directories of
                   Qt4 QT_INCLUDE_DIR n' QT_QTCORE_INCLUDE_DIR are
                   always up in dis variable even if NOTFOUND,
                   all other INCLUDE_DIRS are
                   only added if they is found.
                   Yo ass do not need ta use dis if you include QT_USE_FILE.
.fi







.nf
  Include directories fo' tha Qt modulez is listed here.
  Yo ass do not need ta use these variablez if you include QT_USE_FILE.
.fi




.nf
  QT_INCLUDE_DIR              Path ta "include" of Qt4
  QT_QT3SUPPORT_INCLUDE_DIR   Path ta "include/Qt3Support"
  QT_QTASSISTANT_INCLUDE_DIR  Path ta "include/QtAssistant"
  QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path ta "include/QtAssistant"
  QT_QAXCONTAINER_INCLUDE_DIR Path ta "include/ActiveQt" (Windows only)
  QT_QAXSERVER_INCLUDE_DIR    Path ta "include/ActiveQt" (Windows only)
  QT_QTCORE_INCLUDE_DIR       Path ta "include/QtCore"
  QT_QTDBUS_INCLUDE_DIR       Path ta "include/QtDBus"
  QT_QTDESIGNER_INCLUDE_DIR   Path ta "include/QtDesigner"
  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path ta "include/QtDesigner"
  QT_QTGUI_INCLUDE_DIR        Path ta "include/QtGui"
  QT_QTHELP_INCLUDE_DIR       Path ta "include/QtHelp"
  QT_QTMOTIF_INCLUDE_DIR      Path ta "include/QtMotif"
  QT_QTMULTIMEDIA_INCLUDE_DIR Path ta "include/QtMultimedia"
  QT_QTNETWORK_INCLUDE_DIR    Path ta "include/QtNetwork"
  QT_QTNSPLUGIN_INCLUDE_DIR   Path ta "include/QtNsPlugin"
  QT_QTOPENGL_INCLUDE_DIR     Path ta "include/QtOpenGL"
  QT_QTSCRIPT_INCLUDE_DIR     Path ta "include/QtScript"
  QT_QTSQL_INCLUDE_DIR        Path ta "include/QtSql"
  QT_QTSVG_INCLUDE_DIR        Path ta "include/QtSvg"
  QT_QTTEST_INCLUDE_DIR       Path ta "include/QtTest"
  QT_QTWEBKIT_INCLUDE_DIR     Path ta "include/QtWebKit"
  QT_QTXML_INCLUDE_DIR        Path ta "include/QtXml"
  QT_QTXMLPATTERNS_INCLUDE_DIR  Path ta "include/QtXmlPatterns"
  QT_PHONON_INCLUDE_DIR       Path ta "include/phonon"
  QT_QTSCRIPTTOOLS_INCLUDE_DIR       Path ta "include/QtScriptTools"
  QT_QTDECLARATIVE_INCLUDE_DIR       Path ta "include/QtDeclarative"
.fi




.nf
  QT_BINARY_DIR               Path ta "bin" of Qt4
  QT_LIBRARY_DIR              Path ta "lib" of Qt4
  QT_PLUGINS_DIR              Path ta "plugins" fo' Qt4
  QT_TRANSLATIONS_DIR         Path ta "translations" of Qt4
  QT_IMPORTS_DIR              Path ta "imports" of Qt4
  QT_DOC_DIR                  Path ta "doc" of Qt4
  QT_MKSPECS_DIR              Path ta "mkspecs" of Qt4
.fi







Da Qt toolkit may contain both debug n' release libraries. Put ya muthafuckin choppers up if ya feel dis! In dat case, tha followin library variablez will contain both. Yo ass do not need ta use these variablez if you include QT_USE_FILE, n' use QT_LIBRARIES.


.nf
  QT_QT3SUPPORT_LIBRARY            Da Qt3Support library
  QT_QTASSISTANT_LIBRARY           Da QtAssistant library
  QT_QTASSISTANTCLIENT_LIBRARY     Da QtAssistantClient library
  QT_QAXCONTAINER_LIBRARY           Da QAxContainer library (Windows only)
  QT_QAXSERVER_LIBRARY                Da QAxServer library (Windows only)
  QT_QTCORE_LIBRARY                Da QtCore library
  QT_QTDBUS_LIBRARY                Da QtDBus library
  QT_QTDESIGNER_LIBRARY            Da QtDesigner library
  QT_QTDESIGNERCOMPONENTS_LIBRARY  Da QtDesignerComponents library
  QT_QTGUI_LIBRARY                 Da QtGui library
  QT_QTHELP_LIBRARY                Da QtHelp library
  QT_QTMOTIF_LIBRARY               Da QtMotif library
  QT_QTMULTIMEDIA_LIBRARY          Da QtMultimedia library
  QT_QTNETWORK_LIBRARY             Da QtNetwork library
  QT_QTNSPLUGIN_LIBRARY            Da QtNsPLugin library
  QT_QTOPENGL_LIBRARY              Da QtOpenGL library
  QT_QTSCRIPT_LIBRARY              Da QtScript library
  QT_QTSQL_LIBRARY                 Da QtSql library
  QT_QTSVG_LIBRARY                 Da QtSvg library
  QT_QTTEST_LIBRARY                Da QtTest library
  QT_QTUITOOLS_LIBRARY             Da QtUiTools library
  QT_QTWEBKIT_LIBRARY              Da QtWebKit library
  QT_QTXML_LIBRARY                 Da QtXml library
  QT_QTXMLPATTERNS_LIBRARY         Da QtXmlPatterns library
  QT_QTMAIN_LIBRARY                Da qtmain library fo' Windows
  QT_PHONON_LIBRARY                Da phonon library
  QT_QTSCRIPTTOOLS_LIBRARY         Da QtScriptTools library
.fi




Da QtDeclaratizzle library:             QT_QTDECLARATIVE_LIBRARY


also defined yo, but NOT fo' general use are


.nf
  QT_MOC_EXECUTABLE                   Where ta find tha moc tool.
  QT_UIC_EXECUTABLE                   Where ta find tha uic tool.
  QT_UIC3_EXECUTABLE                  Where ta find tha uic3 tool.
  QT_RCC_EXECUTABLE                   Where ta find tha rcc tool
  QT_DBUSCPP2XML_EXECUTABLE           Where ta find tha qdbuscpp2xml tool.
  QT_DBUSXML2CPP_EXECUTABLE           Where ta find tha qdbusxml2cpp tool.
  QT_LUPDATE_EXECUTABLE               Where ta find tha lupdate tool.
  QT_LRELEASE_EXECUTABLE              Where ta find tha lrelease tool.
  QT_QCOLLECTIONGENERATOR_EXECUTABLE  Where ta find tha qcollectiongenerator tool.
  QT_DESIGNER_EXECUTABLE              Where ta find tha Qt designer tool.
  QT_LINGUIST_EXECUTABLE              Where ta find tha Qt linguist tool.
.fi







These is round fo' backwardz compatibilitizzle they is ghon be set


.nf
  QT_WRAP_CPP  Set legit if QT_MOC_EXECUTABLE is found
  QT_WRAP_UI   Set legit if QT_UIC_EXECUTABLE is found
.fi




These variablez do _NOT_ have any effect no mo' (compared ta FindQt.cmake)


.nf
  QT_MT_REQUIRED         Qt4 is now always multithreaded
.fi




These variablez is set ta "" Because Qt structure chizzled (They make no sense up in Qt4)


.nf
  QT_QT_LIBRARY        Qt\-Library is now split
.fi

.TP
.B FindQuickTime
.nf
 
.fi

Locate QuickTime This module defines QUICKTIME_LIBRARY QUICKTIME_FOUND, if false, do not try ta link ta gdal QUICKTIME_INCLUDE_DIR, where ta find tha headers


$QUICKTIME_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$QUICKTIME_DIR


Created by Eric Wing.

.TP
.B FindRTI
Try ta find M&S HLA RTI libraries

This module findz if any HLA RTI is installed n' locates tha standard RTI include filez n' libraries.


RTI be a simulation infrastructure standardized by IEEE n' SISO. Well shiiiit, it has a well defined C++ API dat assures dat simulation applications is independent on a particular RTI implementation.


.nf
  http://en.wikipedia.org/wiki/Run\-Time_Infrastructure_(simulation)
.fi




This code sets tha followin variables:


.nf
  RTI_INCLUDE_DIR = tha directory where RTI includes file is found
  RTI_LIBRARIES = Da libraries ta link against ta use RTI
  RTI_DEFINITIONS = \-DRTI_USES_STD_FSTREAM
  RTI_FOUND = Set ta FALSE if any HLA RTI was not found
.fi




Report problems ta <certi\-devel@nongnu.org>

.TP
.B FindRuby
Find Ruby

This module findz if Ruby is installed n' determines where tha include filez n' libraries are. Ruby 1.8 n' 1.9 is supported.


Da minimum required version of Ruby can be specified rockin tha standard syntax, e.g. find_package(Ruby 1.8)


It also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  RUBY_EXECUTABLE   = full path ta tha ruby binary
  RUBY_INCLUDE_DIRS = include dirs ta be used when rockin tha ruby library
  RUBY_LIBRARY      = full path ta tha ruby library
  RUBY_VERSION      = tha version of ruby which was found, e.g. "1.8.7"
  RUBY_FOUND        = set ta legit if ruby ws found successfully
.fi




.nf
  RUBY_INCLUDE_PATH = same as RUBY_INCLUDE_DIRS, only provided fo' compatibilitizzle reasons, don't use it
.fi

.TP
.B FindSDL
Locate SDL library

This module defines


.nf
  SDL_LIBRARY, tha name of tha library ta link against
  SDL_FOUND, if false, do not try ta link ta SDL
  SDL_INCLUDE_DIR, where ta find SDL.h
  SDL_VERSION_STRING, human\-readable strang containin tha version of SDL
.fi




This module respondz ta tha the flag:


.nf
  SDL_BUILDING_LIBRARY
    If dis is defined, then no SDL_main is ghon be linked up in cuz
    only applications need main().
    Otherwise, it be assumed yo ass is buildin a application n' this
    module will attempt ta locate n' set tha the proper link flags
    as part of tha returned SDL_LIBRARY variable.
.fi




Don't forget ta include SDLmain.h n' SDLmain.m yo' project fo' tha OS X framework based version. I aint talkin' bout chicken n' gravy biatch. (Other versions link ta \-lSDLmain which dis module will try ta find on yo' behalf.) Also fo' OS X, dis module will automatically add tha \-framework Cocoa on yo' behalf.





Additionizzle Note: If you peep a empty SDL_LIBRARY_TEMP up in yo' configuration n' no SDL_LIBRARY, it means CMake did not find yo' SDL library (SDL.dll, libsdl.so, SDL.framework, etc). Right back up in yo muthafuckin ass. Set SDL_LIBRARY_TEMP ta point ta yo' SDL library, n' configure again. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Similarly, if you peep a empty SDLMAIN_LIBRARY, you should set dis value as appropriate. These joints is used ta generate tha final SDL_LIBRARY variable yo, but when these joints is unset, SDL_LIBRARY do not git pimped.





$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL. l.e.galup  9\-20\-02


Modified by Eric Win fo' realz. Added code ta assist wit automated buildin by rockin environmenstrual variablez n' providin a mo' controlled/consistent search behavior fo' realz. Added freshly smoked up modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc) fo' realz. Also erected tha header search path ta follow "proper" SDL guidelines fo' realz. Added a search fo' SDLmain which is needed by some platforms fo' realz. Added a search fo' threadz which is needed by some platforms fo' realz. Added needed compile switches fo' MinGW.


On OSX, dis will prefer tha Framework version (if found) over others. Muthafuckas will gotta manually chizzle tha cache jointz of SDL_LIBRARY ta override dis selection or set tha CMake environment CMAKE_INCLUDE_PATH ta modify tha search paths.


Note dat tha header path has chizzled from SDL/SDL.h ta just SDL.h This needed ta chizzle cuz "proper" SDL convention is #include "SDL.h", not <SDL/SDL.h>. This is done fo' portabilitizzle reasons cuz not all systems place thangs up in SDL/ (see FreeBSD).

.TP
.B FindSDL_image
Locate SDL_image library

This module defines:


.nf
  SDL_IMAGE_LIBRARIES, tha name of tha library ta link against
  SDL_IMAGE_INCLUDE_DIRS, where ta find tha headers
  SDL_IMAGE_FOUND, if false, do not try ta link against
  SDL_IMAGE_VERSION_STRING \- human\-readable strang containin tha version of SDL_image
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLIMAGE_LIBRARY (same value as SDL_IMAGE_LIBRARIES)
  SDLIMAGE_INCLUDE_DIR (same value as SDL_IMAGE_INCLUDE_DIRS)
  SDLIMAGE_FOUND (same value as SDL_IMAGE_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_mixer
Locate SDL_mixer library

This module defines:


.nf
  SDL_MIXER_LIBRARIES, tha name of tha library ta link against
  SDL_MIXER_INCLUDE_DIRS, where ta find tha headers
  SDL_MIXER_FOUND, if false, do not try ta link against
  SDL_MIXER_VERSION_STRING \- human\-readable strang containin tha version of SDL_mixer
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLMIXER_LIBRARY (same value as SDL_MIXER_LIBRARIES)
  SDLMIXER_INCLUDE_DIR (same value as SDL_MIXER_INCLUDE_DIRS)
  SDLMIXER_FOUND (same value as SDL_MIXER_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_net
Locate SDL_net library

This module defines:


.nf
  SDL_NET_LIBRARIES, tha name of tha library ta link against
  SDL_NET_INCLUDE_DIRS, where ta find tha headers
  SDL_NET_FOUND, if false, do not try ta link against
  SDL_NET_VERSION_STRING \- human\-readable strang containin tha version of SDL_net
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLNET_LIBRARY (same value as SDL_NET_LIBRARIES)
  SDLNET_INCLUDE_DIR (same value as SDL_NET_INCLUDE_DIRS)
  SDLNET_FOUND (same value as SDL_NET_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_sound
Locates tha SDL_sound library




This module dependz on SDL bein found n' must be called AFTER FindSDL.cmake is called.


This module defines


.nf
  SDL_SOUND_INCLUDE_DIR, where ta find SDL_sound.h
  SDL_SOUND_FOUND, if false, do not try ta link ta SDL_sound
  SDL_SOUND_LIBRARIES, dis gotz nuff tha list of libraries dat you need
    ta link against. This be a read\-only variable n' is marked INTERNAL.
  SDL_SOUND_EXTRAS, dis be a optionizzle variable fo' you ta add yo' own
    flags ta SDL_SOUND_LIBRARIES. This is prepended ta SDL_SOUND_LIBRARIES.
    This be available mostly fo' cases dis module failed ta anticipate for
    n' you must add additionizzle flags. This is marked as ADVANCED.
  SDL_SOUND_VERSION_STRING, human\-readable strang containin tha version of SDL_sound
.fi




This module also defines (but you shouldn't need ta use directly)


.nf
   SDL_SOUND_LIBRARY, tha name of just tha SDL_sound library you would link
   against. Use SDL_SOUND_LIBRARIES fo' you link instructions n' not dis one.
.fi

And might define tha followin as needed


.nf
   MIKMOD_LIBRARY
   MODPLUG_LIBRARY
   OGG_LIBRARY
   VORBIS_LIBRARY
   SMPEG_LIBRARY
   FLAC_LIBRARY
   SPEEX_LIBRARY
.fi




Typically, you should not use these variablez directly, n' you should use SDL_SOUND_LIBRARIES which gotz nuff SDL_SOUND_LIBRARY n' tha other audio libraries (if needed) ta successfully compile on yo' system.


Created by Eric Wing. This module be a lil' bit mo' fucked up than tha other FindSDL* crew modules. Da reason is dat SDL_sound can be compiled up in a big-ass variety of different ways which is independent of platform. Right back up in yo muthafuckin ass. SDL_sound may dynamically link against other 3rd jam libraries ta git additionizzle codec support, like fuckin Ogg Vorbis, SMPEG, ModPlug, MikMod, FLAC, Speex, n' potentially others. Under some circumstances which I don't straight-up understand, there seems ta be a requirement dat dependent librariez of libraries you use must also be explicitly linked against up in order ta successfully compile. Right back up in yo muthafuckin ass. SDL_sound do not currently have any system up in place ta know how tha fuck dat shiznit was compiled. Y'all KNOW dat shit, muthafucka! So dis CMake module do tha mad bullshit up in tryin ta discover which 3rd jam libraries is required fo' buildin (if any). This module uses a funky-ass brute force approach ta create a test program dat uses SDL_sound, n' then tries ta build dat shit. If tha build fails, it parses tha error output fo' known symbol names ta figure up which libraries is needed.


Respondz ta tha $SDLDIR n' $SDLSOUNDDIR environmenstrual variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


On OSX, dis will prefer tha Framework version (if found) over others. Muthafuckas will gotta manually chizzle tha cache jointz of SDL_LIBRARY ta override dis selectionor set tha CMake environment CMAKE_INCLUDE_PATH ta modify tha search paths.

.TP
.B FindSDL_ttf
Locate SDL_ttf library

This module defines:


.nf
  SDL_TTF_LIBRARIES, tha name of tha library ta link against
  SDL_TTF_INCLUDE_DIRS, where ta find tha headers
  SDL_TTF_FOUND, if false, do not try ta link against
  SDL_TTF_VERSION_STRING \- human\-readable strang containin tha version of SDL_ttf
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLTTF_LIBRARY (same value as SDL_TTF_LIBRARIES)
  SDLTTF_INCLUDE_DIR (same value as SDL_TTF_INCLUDE_DIRS)
  SDLTTF_FOUND (same value as SDL_TTF_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSWIG
Find SWIG

This module findz a installed SWIG.  It sets tha followin variables:


.nf
  SWIG_FOUND \- set ta legit if SWIG is found
  SWIG_DIR \- tha directory where swig is installed
  SWIG_EXECUTABLE \- tha path ta tha swig executable
  SWIG_VERSION   \- tha version number of tha swig executable
.fi




Da minimum required version of SWIG can be specified rockin tha standard syntax, e.g. find_package(SWIG 1.1)


All shiznit is collected from tha SWIG_EXECUTABLE so tha version ta be found can be chizzled from tha command line by meanz of settin SWIG_EXECUTABLE


.TP
.B FindSelfPackers
Find upx

This module looks fo' some executable packers (i.e. software dat compress executablez or shared libs tha fuck into on\-the\-fly self\-extractin executablez or shared libs. Examples:


.nf
  UPX: http://wildsau.idv.uni\-linz.ac.at/mfx/upx.html
.fi

.TP
.B FindSquish
\-\- Typical Use




This module can be used ta find Squish. Currently Squish versions 3 n' 4 is supported.


.nf
  SQUISH_FOUND                    If false, don't try ta use Squish
  SQUISH_VERSION                  Da full version of Squish found
  SQUISH_VERSION_MAJOR            Da major version of Squish found
  SQUISH_VERSION_MINOR            Da minor version of Squish found
  SQUISH_VERSION_PATCH            Da patch version of Squish found
.fi




.nf
  SQUISH_INSTALL_DIR              Da Squish installation directory (containin bin, lib, etc)
  SQUISH_SERVER_EXECUTABLE        Da squishserver executable
  SQUISH_CLIENT_EXECUTABLE        Da squishrunner executable
.fi




.nf
  SQUISH_INSTALL_DIR_FOUND        Was tha install directory found?
  SQUISH_SERVER_EXECUTABLE_FOUND  Was tha server executable found?
  SQUISH_CLIENT_EXECUTABLE_FOUND  Was tha client executable found?
.fi




It serves up tha function squish_v4_add_test() fo' addin a squish test ta cmake rockin Squish 4.x:


.nf
   squish_v4_add_test(cmakeTestName AUT targetName SUITE suiteName TEST squishTestName
                   [SETTINGSGROUP group] [PRE_COMMAND command] [POST_COMMAND command] )
.fi




Da arguments have tha followin meaning:


.nf
   cmakeTestName: dis is ghon be used as tha straight-up original gangsta argument fo' add_test()
   AUT targetName: tha name of tha cmake target which is ghon be used as AUT, i.e. the
                   executable which is ghon be tested.
   SUITE suiteName: dis is either tha full path ta tha squish suite, or just the
                    last directory of tha suite, i.e. tha suite name. In dis case
                    tha CMakeLists.txt which calls squish_add_test() must be located
                    up in tha parent directory of tha suite directory.
   TEST squishTestName: tha name of tha squish test, i.e. tha name of tha subdirectory
                        of tha test inside tha suite directory.
   SETTINGSGROUP group: if specified, tha given settings crew is ghon be used fo' executin tha test.
                        If not specified, tha groupname is ghon be "CTest_<username>"
   PRE_COMMAND command:  if specified, tha given command is ghon be executed before startin tha squish test.
   POST_COMMAND command: same as PRE_COMMAND yo, but afta tha squish test has been executed.
.fi




.nf
   enable_testing()
   find_package(Squish 4.0)
   if (SQUISH_FOUND)
      squish_v4_add_test(myTestName AUT myApp SUITE ${CMAKE_SOURCE_DIR}/tests/mySuite TEST someSquishTest SETTINGSGROUP myGroup )
   endif ()
.fi







For playaz of Squish version 3.x tha macro squish_v3_add_test() is provided:


.nf
   squish_v3_add_test(testName applicationUnderTest testCase envVars testWrapper)
   Use dis macro ta add a test rockin Squish 3.x.
.fi




.nf
  enable_testing()
  find_package(Squish)
  if (SQUISH_FOUND)
    squish_v3_add_test(myTestName myApplication testCase envVars testWrapper)
  endif ()
.fi




macro SQUISH_ADD_TEST(testName applicationUnderTest testCase envVars testWrapper)


.nf
   This is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use SQUISH_V3_ADD_TEST() if yo ass is rockin Squish 3.x instead.
.fi

.TP
.B FindSubversion
Extract shiznit from a subversion hustlin copy

Da module defines tha followin variables:


.nf
  Subversion_SVN_EXECUTABLE \- path ta svn command line client
  Subversion_VERSION_SVN \- version of svn command line client
  Subversion_FOUND \- legit if tha command line client was found
  SUBVERSION_FOUND \- same as Subversion_FOUND, set fo' compatiblitizzle reasons
.fi




Da minimum required version of Subversion can be specified rockin tha standard syntax, e.g. find_package(Subversion 1.4)


If tha command line client executable is found two macros is defined:


.nf
  Subversion_WC_INFO(<dir> <var\-prefix>)
  Subversion_WC_LOG(<dir> <var\-prefix>)
.fi

Subversion_WC_INFO extracts shiznit of a subversion hustlin copy at a given location. I aint talkin' bout chicken n' gravy biatch. This macro defines tha followin variables:


.nf
  <var\-prefix>_WC_URL \- url of tha repository (at <dir>)
  <var\-prefix>_WC_ROOT \- root url of tha repository
  <var\-prefix>_WC_REVISION \- current revision
  <var\-prefix>_WC_LAST_CHANGED_AUTHOR \- lyricist of last commit
  <var\-prefix>_WC_LAST_CHANGED_DATE \- date of last commit
  <var\-prefix>_WC_LAST_CHANGED_REV \- revision of last commit
  <var\-prefix>_WC_INFO \- output of command `svn info <dir>'
.fi

Subversion_WC_LOG retrieves tha log message of tha base revision of a subversion hustlin copy at a given location. I aint talkin' bout chicken n' gravy biatch. This macro defines tha variable:


.nf
  <var\-prefix>_LAST_CHANGED_LOG \- last log of base revision
.fi

Example usage:


.nf
  find_package(Subversion)
  if(SUBVERSION_FOUND)
    Subversion_WC_INFO(${PROJECT_SOURCE_DIR} Project)
    message("Current revision is ${Project_WC_REVISION}")
    Subversion_WC_LOG(${PROJECT_SOURCE_DIR} Project)
    message("Last chizzled log is ${Project_LAST_CHANGED_LOG}")
  endif()
.fi

.TP
.B FindTCL
TK_INTERNAL_PATH was removed.

This module findz if Tcl is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TCL_FOUND              = Tcl was found
  TK_FOUND               = Tk was found
  TCLTK_FOUND            = Tcl n' Tk was found
  TCL_LIBRARY            = path ta Tcl library (tcl tcl80)
  TCL_INCLUDE_PATH       = path ta where tcl.h can be found
  TCL_TCLSH              = path ta tclsh binary (tcl tcl80)
  TK_LIBRARY             = path ta Tk library (tk tk80 etc)
  TK_INCLUDE_PATH        = path ta where tk.h can be found
  TK_WISH                = full path ta tha wish executable
.fi




In a effort ta remove some clutta n' clear up some thangs fo' playas whoz ass is not necessarily Tcl/Tk gurus/developpers, some variablez was moved or removed. Y'all KNOW dat shit, muthafucka! Chizzlez compared ta CMake 2.4 are:


.nf
   => they was only useful fo' playas freestylin Tcl/Tk extensions.
   => these libs is not packaged by default wit Tcl/Tk distributions.
      Even when Tcl/Tk is built from source, nuff muthafuckin flavorz of debug libs
      is pimped n' there is no real reason ta pick a single one
      specifically (say, amongst tcl84g, tcl84gs, or tcl84sgx).
      Letz leave dat chizzle ta tha user by allowin his ass ta assign
      TCL_LIBRARY ta any Tcl library, debug or not.
   => dis ended up bein only a Win32 variable, n' there be a shitload of
      mad drama regardin tha location of dis file up in a installed Tcl/Tk
      tree anyway (see 8.5 fo' example). If you need tha internal path at
      dis point it is less thuggy you ask directly where tha *source* tree is
      n' dig from there.
.fi

.TP
.B FindTIFF
Find TIFF library

Find tha natizzle TIFF includes n' library This module defines


.nf
  TIFF_INCLUDE_DIR, where ta find tiff.h, etc.
  TIFF_LIBRARIES, libraries ta link against ta use TIFF.
  TIFF_FOUND, If false, do not try ta use TIFF.
.fi

also defined yo, but not fo' general use are


.nf
  TIFF_LIBRARY, where ta find tha TIFF library.
.fi

.TP
.B FindTclStub
TCL_STUB_LIBRARY_DEBUG n' TK_STUB_LIBRARY_DEBUG was removed.

This module findz Tcl stub libraries. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it first findz Tcl include filez n' libraries by callin FindTCL.cmake yo. How tha fuck ta Use tha Tcl Stubs Library:


.nf
   http://tcl.activestate.com/doc/howto/stubs.html
.fi

Usin Stub Libraries:


.nf
   http://safari.oreilly.com/0130385603/ch48lev1sec3
.fi

This code sets tha followin variables:


.nf
  TCL_STUB_LIBRARY       = path ta Tcl stub library
  TK_STUB_LIBRARY        = path ta Tk stub library
  TTK_STUB_LIBRARY       = path ta ttk stub library
.fi




In a effort ta remove some clutta n' clear up some thangs fo' playas whoz ass is not necessarily Tcl/Tk gurus/developpers, some variablez was moved or removed. Y'all KNOW dat shit, muthafucka! Chizzlez compared ta CMake 2.4 are:


.nf
   => these libs is not packaged by default wit Tcl/Tk distributions.
      Even when Tcl/Tk is built from source, nuff muthafuckin flavorz of debug libs
      is pimped n' there is no real reason ta pick a single one
      specifically (say, amongst tclstub84g, tclstub84gs, or tclstub84sgx).
      Letz leave dat chizzle ta tha user by allowin his ass ta assign
      TCL_STUB_LIBRARY ta any Tcl library, debug or not.
.fi

.TP
.B FindTclsh
Find tclsh

This module findz if TCL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TCLSH_FOUND = TRUE if tclsh has been found
  TCL_TCLSH = tha path ta tha tclsh executable
.fi

In cygwin, look fo' tha cygwin version first.  Don't look fo' it lata ta avoid findin tha cygwin version on a Win32 build.

.TP
.B FindThreads
This module determines tha thread library of tha system.

Da followin variablez is set


.nf
  CMAKE_THREAD_LIBS_INIT     \- tha thread library
  CMAKE_USE_SPROC_INIT       \- is we rockin sproc?
  CMAKE_USE_WIN32_THREADS_INIT \- rockin WIN32 threads?
  CMAKE_USE_PTHREADS_INIT    \- is we rockin pthreads
  CMAKE_HP_PTHREADS_INIT     \- is we rockin hp pthreads
.fi

For systems wit multiple thread libraries, calla can set


.nf
  CMAKE_THREAD_PREFER_PTHREAD
.fi

.TP
.B FindUnixCommands
Find unix commandz from cygwin

This module looks fo' some usual Unix commands.


.TP
.B FindVTK
Find a VTK installation or build tree.

Da followin variablez is set if VTK is found. Y'all KNOW dat shit, muthafucka!  If VTK aint found, VTK_FOUND is set ta false.


.nf
  VTK_FOUND         \- Set ta legit when VTK is found.
  VTK_USE_FILE      \- CMake file ta use VTK.
  VTK_MAJOR_VERSION \- Da VTK major version number.
  VTK_MINOR_VERSION \- Da VTK minor version number
                       (odd non\-release).
  VTK_BUILD_VERSION \- Da VTK patch level
                       (meaningless fo' odd minor).
  VTK_INCLUDE_DIRS  \- Include directories fo' VTK
  VTK_LIBRARY_DIRS  \- Link directories fo' VTK libraries
  VTK_KITS          \- List of VTK kits, up in CAPS
                      (COMMON,IO,) etc.
  VTK_LANGUAGES     \- List of wrapped languages, up in CAPS
                      (TCL, PYHTON,) etc.
.fi

Da followin cache entries must be set by tha user ta locate VTK:


.nf
  VTK_DIR  \- Da directory containin VTKConfig.cmake.
             This is either tha root of tha build tree,
             or tha lib/vtk directory.  This is the
             only cache entry.
.fi

Da followin variablez is set fo' backward compatibilitizzle n' should not be used up in freshly smoked up code:


.nf
  USE_VTK_FILE \- Da full path ta tha UseVTK.cmake file.
                 This is provided fo' backward
                 compatibility.  Use VTK_USE_FILE
                 instead.
.fi




.TP
.B FindWget
Find wget

This module looks fo' wget. This module defines tha followin joints:


.nf
  WGET_EXECUTABLE: tha full path ta tha wget tool.
  WGET_FOUND: True if wget has been found.
.fi

.TP
.B FindWish
Find wish installation

This module findz if TCL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TK_WISH = tha path ta tha wish executable
.fi




if UNIX is defined, then it will look fo' tha cygwin version first

.TP
.B FindX11
Find X11 installation

Try ta find X11 on UNIX systems. Da followin joints is defined


.nf
  X11_FOUND        \- True if X11 be available
  X11_INCLUDE_DIR  \- include directories ta use X11
  X11_LIBRARIES    \- link against these ta use X11
.fi




and also tha followin mo' fine grained variables: Include paths: X11_ICE_INCLUDE_PATH,          X11_ICE_LIB,        X11_ICE_FOUND


.nf
                X11_SM_INCLUDE_PATH,           X11_SM_LIB,         X11_SM_FOUND
                X11_X11_INCLUDE_PATH,          X11_X11_LIB
                X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
                X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
                X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
                X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
                X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
                X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
                X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
                                               X11_Xext_LIB,       X11_Xext_FOUND
                X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
                X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
                X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
                X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
                X11_xf86vmode_INCLUDE_PATH,    X11_Xxf86vm_LIB     X11_xf86vmode_FOUND
                X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
                X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
                X11_Xi_INCLUDE_PATH,           X11_Xi_LIB,         X11_Xi_FOUND
                X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
                X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
                X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
                X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
                X11_Xkbfile_INCLUDE_PATH,      X11_Xkbfile_LIB,    X11_Xkbfile_FOUND
                X11_Xmu_INCLUDE_PATH,          X11_Xmu_LIB,        X11_Xmu_FOUND
                X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
                X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
                X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
                X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
                X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
                X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
                X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
                X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND
                X11_XSync_INCLUDE_PATH,        (in X11_Xext_LIB),  X11_XSync_FOUND
.fi

.TP
.B FindXMLRPC
Find xmlrpc

Find tha natizzle XMLRPC headaz n' libraries.


.nf
  XMLRPC_INCLUDE_DIRS      \- where ta find xmlrpc.h, etc.
  XMLRPC_LIBRARIES         \- List of libraries when rockin xmlrpc.
  XMLRPC_FOUND             \- True if xmlrpc found.
.fi

XMLRPC modulez may be specified as components fo' dis find module. Modulez may be listed by hustlin "xmlrpc\-c\-config".  Modulez include:


.nf
  c++            C++ wrapper code
  libwww\-client  libwww\-based client
  cgi\-server     CGI\-based server
  abyss\-server   ABYSS\-based server
.fi

Typical usage:


.nf
  find_package(XMLRPC REQUIRED libwww\-client)
.fi

.TP
.B FindZLIB
Find zlib

Find tha natizzle ZLIB includes n' library. Once done dis will define


.nf
  ZLIB_INCLUDE_DIRS   \- where ta find zlib.h, etc.
  ZLIB_LIBRARIES      \- List of libraries when rockin zlib.
  ZLIB_FOUND          \- True if zlib found.
.fi




.nf
  ZLIB_VERSION_STRING \- Da version of zlib found (x.y.z)
  ZLIB_VERSION_MAJOR  \- Da major version of zlib
  ZLIB_VERSION_MINOR  \- Da minor version of zlib
  ZLIB_VERSION_PATCH  \- Da patch version of zlib
  ZLIB_VERSION_TWEAK  \- Da tweak version of zlib
.fi




Da followin variable is provided fo' backward compatibility


.nf
  ZLIB_MAJOR_VERSION  \- Da major version of zlib
  ZLIB_MINOR_VERSION  \- Da minor version of zlib
  ZLIB_PATCH_VERSION  \- Da patch version of zlib
.fi




An includer may set ZLIB_ROOT ta a zlib installation root ta tell dis module where ta look.

.TP
.B Findosg
.nf
 
.fi




NOTE: It be highly recommended dat you use tha freshly smoked up FindOpenSceneGraph.cmake introduced up in CMake 2.6.3 n' not use dis Find module directly.


This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osg This module defines


OSG_FOUND \- Was tha Osg found, biatch? OSG_INCLUDE_DIR \- Where ta find tha headaz OSG_LIBRARIES \- Da libraries ta link against fo' tha OSG (use this)


OSG_LIBRARY \- Da OSG library OSG_LIBRARY_DEBUG \- Da OSG debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgAnimation
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgAnimation This module defines


OSGANIMATION_FOUND \- Was osgAnimation found, biatch? OSGANIMATION_INCLUDE_DIR \- Where ta find tha headaz OSGANIMATION_LIBRARIES \- Da libraries ta link against fo' tha OSG (use this)


OSGANIMATION_LIBRARY \- Da OSG library OSGANIMATION_LIBRARY_DEBUG \- Da OSG debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgDB
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgDB This module defines


OSGDB_FOUND \- Was osgDB found, biatch? OSGDB_INCLUDE_DIR \- Where ta find tha headaz OSGDB_LIBRARIES \- Da libraries ta link against fo' tha osgDB (use this)


OSGDB_LIBRARY \- Da osgDB library OSGDB_LIBRARY_DEBUG \- Da osgDB debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgFX
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgFX This module defines


OSGFX_FOUND \- Was osgFX found, biatch? OSGFX_INCLUDE_DIR \- Where ta find tha headaz OSGFX_LIBRARIES \- Da libraries ta link against fo' tha osgFX (use this)


OSGFX_LIBRARY \- Da osgFX library OSGFX_LIBRARY_DEBUG \- Da osgFX debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgGA
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgGA This module defines


OSGGA_FOUND \- Was osgGA found, biatch? OSGGA_INCLUDE_DIR \- Where ta find tha headaz OSGGA_LIBRARIES \- Da libraries ta link against fo' tha osgGA (use this)


OSGGA_LIBRARY \- Da osgGA library OSGGA_LIBRARY_DEBUG \- Da osgGA debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgIntrospection
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgINTROSPECTION This module defines


OSGINTROSPECTION_FOUND \- Was osgIntrospection found, biatch? OSGINTROSPECTION_INCLUDE_DIR \- Where ta find tha headaz OSGINTROSPECTION_LIBRARIES \- Da libraries ta link fo' osgIntrospection (use this)


OSGINTROSPECTION_LIBRARY \- Da osgIntrospection library OSGINTROSPECTION_LIBRARY_DEBUG \- Da osgIntrospection debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgManipulator
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgManipulator This module defines


OSGMANIPULATOR_FOUND \- Was osgManipulator found, biatch? OSGMANIPULATOR_INCLUDE_DIR \- Where ta find tha headaz OSGMANIPULATOR_LIBRARIES \- Da libraries ta link fo' osgManipulator (use this)


OSGMANIPULATOR_LIBRARY \- Da osgManipulator library OSGMANIPULATOR_LIBRARY_DEBUG \- Da osgManipulator debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgParticle
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgParticle This module defines


OSGPARTICLE_FOUND \- Was osgParticle found, biatch? OSGPARTICLE_INCLUDE_DIR \- Where ta find tha headaz OSGPARTICLE_LIBRARIES \- Da libraries ta link fo' osgParticle (use this)


OSGPARTICLE_LIBRARY \- Da osgParticle library OSGPARTICLE_LIBRARY_DEBUG \- Da osgParticle debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgPresentation
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgPresentation This module defines


OSGPRESENTATION_FOUND \- Was osgPresentation found, biatch? OSGPRESENTATION_INCLUDE_DIR \- Where ta find tha headaz OSGPRESENTATION_LIBRARIES \- Da libraries ta link fo' osgPresentation (use this)


OSGPRESENTATION_LIBRARY \- Da osgPresentation library OSGPRESENTATION_LIBRARY_DEBUG \- Da osgPresentation debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing. Modified ta work wit osgPresentation by Robert Osfield, January 2012.

.TP
.B FindosgProducer
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgProducer This module defines


OSGPRODUCER_FOUND \- Was osgProducer found, biatch? OSGPRODUCER_INCLUDE_DIR \- Where ta find tha headaz OSGPRODUCER_LIBRARIES \- Da libraries ta link fo' osgProducer (use this)


OSGPRODUCER_LIBRARY \- Da osgProducer library OSGPRODUCER_LIBRARY_DEBUG \- Da osgProducer debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgQt
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgQt This module defines


OSGQT_FOUND \- Was osgQt found, biatch? OSGQT_INCLUDE_DIR \- Where ta find tha headaz OSGQT_LIBRARIES \- Da libraries ta link fo' osgQt (use this)


OSGQT_LIBRARY \- Da osgQt library OSGQT_LIBRARY_DEBUG \- Da osgQt debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing. Modified ta work wit osgQt by Robert Osfield, January 2012.

.TP
.B FindosgShadow
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgShadow This module defines


OSGSHADOW_FOUND \- Was osgShadow found, biatch? OSGSHADOW_INCLUDE_DIR \- Where ta find tha headaz OSGSHADOW_LIBRARIES \- Da libraries ta link fo' osgShadow (use this)


OSGSHADOW_LIBRARY \- Da osgShadow library OSGSHADOW_LIBRARY_DEBUG \- Da osgShadow debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgSim
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgSim This module defines


OSGSIM_FOUND \- Was osgSim found, biatch? OSGSIM_INCLUDE_DIR \- Where ta find tha headaz OSGSIM_LIBRARIES \- Da libraries ta link fo' osgSim (use this)


OSGSIM_LIBRARY \- Da osgSim library OSGSIM_LIBRARY_DEBUG \- Da osgSim debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgTerrain
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgTerrain This module defines


OSGTERRAIN_FOUND \- Was osgTerrain found, biatch? OSGTERRAIN_INCLUDE_DIR \- Where ta find tha headaz OSGTERRAIN_LIBRARIES \- Da libraries ta link fo' osgTerrain (use this)


OSGTERRAIN_LIBRARY \- Da osgTerrain library OSGTERRAIN_LIBRARY_DEBUG \- Da osgTerrain debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgText
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgText This module defines


OSGTEXT_FOUND \- Was osgText found, biatch? OSGTEXT_INCLUDE_DIR \- Where ta find tha headaz OSGTEXT_LIBRARIES \- Da libraries ta link fo' osgText (use this)


OSGTEXT_LIBRARY \- Da osgText library OSGTEXT_LIBRARY_DEBUG \- Da osgText debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgUtil
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgUtil This module defines


OSGUTIL_FOUND \- Was osgUtil found, biatch? OSGUTIL_INCLUDE_DIR \- Where ta find tha headaz OSGUTIL_LIBRARIES \- Da libraries ta link fo' osgUtil (use this)


OSGUTIL_LIBRARY \- Da osgUtil library OSGUTIL_LIBRARY_DEBUG \- Da osgUtil debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgViewer
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgViewer This module defines


OSGVIEWER_FOUND \- Was osgViewer found, biatch? OSGVIEWER_INCLUDE_DIR \- Where ta find tha headaz OSGVIEWER_LIBRARIES \- Da libraries ta link fo' osgViewer (use this)


OSGVIEWER_LIBRARY \- Da osgViewer library OSGVIEWER_LIBRARY_DEBUG \- Da osgViewer debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgVolume
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgVolume This module defines


OSGVOLUME_FOUND \- Was osgVolume found, biatch? OSGVOLUME_INCLUDE_DIR \- Where ta find tha headaz OSGVOLUME_LIBRARIES \- Da libraries ta link fo' osgVolume (use this)


OSGVOLUME_LIBRARY \- Da osgVolume library OSGVOLUME_LIBRARY_DEBUG \- Da osgVolume debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgWidget
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgWidget This module defines


OSGWIDGET_FOUND \- Was osgWidget found, biatch? OSGWIDGET_INCLUDE_DIR \- Where ta find tha headaz OSGWIDGET_LIBRARIES \- Da libraries ta link fo' osgWidget (use this)


OSGWIDGET_LIBRARY \- Da osgWidget library OSGWIDGET_LIBRARY_DEBUG \- Da osgWidget debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


FindosgWidget.cmake tweaked from Findosg* suite as pimped by Eric Wing.

.TP
.B Findosg_functions
.nf
 
.fi




This CMake file gotz nuff two macros ta assist wit searchin fo' OSG libraries n' nodekits, n' you can put dat on yo' toast.  Please peep FindOpenSceneGraph.cmake fo' full documentation.


.TP
.B FindwxWidgets
Find a wxWidgets (a.k.a., wxWindows) installation.

This module findz if wxWidgets is installed n' selects a thugged-out default configuration ta use. wxWidgets be a modular library. To specify tha modulez dat yo big-ass booty is ghon use, you need ta name dem as components ta tha package:


find_package(wxWidgets COMPONENTS core base ...)


There is two search branches: a windows steez n' a unix style. For windows, tha followin variablez is searched fo' n' set ta defaults up in case of multiple chizzles. Chizzle dem if tha defaults is not desired (i.e., these is tha only variablez you should chizzle ta select a cold-ass lil configuration):


.nf
  wxWidgets_ROOT_DIR      \- Base wxWidgets directory
                            (e.g., C:/wxWidgets\-2.6.3).
  wxWidgets_LIB_DIR       \- Path ta wxWidgets libraries
                            (e.g., C:/wxWidgets\-2.6.3/lib/vc_lib).
  wxWidgets_CONFIGURATION \- Configuration ta use
                            (e.g., msw, mswd, mswu, mswunivud, etc.)
  wxWidgets_EXCLUDE_COMMON_LIBRARIES
                          \- Set ta TRUE ta exclude linkin of
                            commonly required libs (e.g., png tiff
                            jpeg zlib regex expat).
.fi




For unix steez it uses tha wx\-config utility. Yo ass can select between debug/release, unicode/ansi, universal/non\-universal, n' static/shared up in tha QtDialog or ccmake intercourses by turnin ON/OFF tha followin variables:


.nf
  wxWidgets_USE_DEBUG
  wxWidgets_USE_UNICODE
  wxWidgets_USE_UNIVERSAL
  wxWidgets_USE_STATIC
.fi




There be also a wxWidgets_CONFIG_OPTIONS variable fo' all other options dat need ta be passed ta tha wx\-config utility. For example, ta use tha base toolkit found up in tha /usr/local path, set tha variable (before callin tha FIND_PACKAGE command) as such:


.nf
  set(wxWidgets_CONFIG_OPTIONS \-\-toolkit=base \-\-prefix=/usr)
.fi




Da followin is set afta tha configuration is done fo' both windows n' unix style:


.nf
  wxWidgets_FOUND            \- Set ta TRUE if wxWidgets was found.
  wxWidgets_INCLUDE_DIRS     \- Include directories fo' WIN32
                               i.e., where ta find "wx/wx.h" and
                               "wx/setup.h"; possibly empty fo' unices.
  wxWidgets_LIBRARIES        \- Path ta tha wxWidgets libraries.
  wxWidgets_LIBRARY_DIRS     \- compile time link dirs, useful for
                               rpath on UNIX. Typically a empty string
                               up in WIN32 environment.
  wxWidgets_DEFINITIONS      \- Gotz Nuff defines required ta compile/link
                               against WX, e.g. WXUSINGDLL
  wxWidgets_DEFINITIONS_DEBUG\- Gotz Nuff defines required ta compile/link
                               against WX debug builds, e.g. __WXDEBUG__
  wxWidgets_CXX_FLAGS        \- Include dirs n' compila flags for
                               unices, empty on WIN32. Essentially
                               "`wx\-config \-\-cxxflags`".
  wxWidgets_USE_FILE         \- Convenience include file.
.fi




Sample usage:


.nf
   # Note dat fo' MinGW playas tha order of libs is blingin!
   find_package(wxWidgets COMPONENTS net gl core base)
   if(wxWidgets_FOUND)
     include(${wxWidgets_USE_FILE})
     # n' fo' each of yo' dependent executable/library targets:
     target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
   endif()
.fi




If wxWidgets is required (i.e., not a optionizzle part):


.nf
   find_package(wxWidgets REQUIRED net gl core base)
   include(${wxWidgets_USE_FILE})
   # n' fo' each of yo' dependent executable/library targets:
   target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
.fi

.TP
.B FindwxWindows
Find wxWindows (wxWidgets) installation

This module findz if wxWindows/wxWidgets is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. Please note dis file is DEPRECATED n' replaced by FindwxWidgets.cmake. This code sets tha followin variables:


.nf
  WXWINDOWS_FOUND     = system has WxWindows
  WXWINDOWS_LIBRARIES = path ta tha wxWindows libraries
                        on Unix/Linux wit additional
                        linker flags from
                        "wx\-config \-\-libs"
  CMAKE_WXWINDOWS_CXX_FLAGS  = Compila flags fo' wxWindows,
                               essentially "`wx\-config \-\-cxxflags`"
                               on Linux
  WXWINDOWS_INCLUDE_DIR      = where ta find "wx/wx.h" n' "wx/setup.h"
  WXWINDOWS_LINK_DIRECTORIES = link directories, useful fo' rpath on
                                Unix
  WXWINDOWS_DEFINITIONS      = extra defines
.fi




OPTIONS If you need OpenGL support please


.nf
  set(WXWINDOWS_USE_GL 1)
.fi

in yo' CMakeLists.txt *before* you include dis file.


.nf
  HAVE_ISYSTEM      \- legit required ta replace \-I by \-isystem on g++
.fi




For convenience include Use_wxWindows.cmake up in yo' projectz CMakeLists.txt rockin include(${CMAKE_CURRENT_LIST_DIR}/Use_wxWindows.cmake).


USAGE


.nf
  set(WXWINDOWS_USE_GL 1)
  find_package(wxWindows)
.fi




NOTES wxWidgets 2.6.x is supported fo' monolithic buildz e.g. compiled  up in wx/build/msw dir as:


.nf
  nmake \-f makefile.vc BUILD=debug SHARED=0 USE_OPENGL=1 MONOLITHIC=1
.fi




DEPRECATED


.nf
  CMAKE_WX_CAN_COMPILE
  WXWINDOWS_LIBRARY
  CMAKE_WX_CXX_FLAGS
  WXWINDOWS_INCLUDE_PATH
.fi




AUTHOR Jan Woetzel <http://www.mip.informatik.uni\-kiel.de/~jw> (07/2003\-01/2006)

.TP
.B FortranCInterface
Fortran/C Interface Detection

This module automatically detects tha API by which C n' Fortran languages interact.  Variablez indicate if tha manglin is found:


.nf
   FortranCInterface_GLOBAL_FOUND = Global subroutines n' functions
   FortranCInterface_MODULE_FOUND = Module subroutines n' functions
                                    (declared by "MODULE PROCEDURE")
.fi

A function is provided ta generate a C header file containin macros ta mangle symbol names:


.nf
   FortranCInterface_HEADER(<file>
                            [MACRO_NAMESPACE <macro\-ns>]
                            [SYMBOL_NAMESPACE <ns>]
                            [SYMBOLS [<module>:]<function> ...])
.fi

It generates up in <file> definitionz of tha followin macros:


.nf
   #define FortranCInterface_GLOBAL (name,NAME) ...
   #define FortranCInterface_GLOBAL_(name,NAME) ...
   #define FortranCInterface_MODULE (mod,name, MOD,NAME) ...
   #define FortranCInterface_MODULE_(mod,name, MOD,NAME) ...
.fi

These macros mangle four categoriez of Fortran symbols, respectively:


.nf
   \- Global symbols without '_': call mysub()
   \- Global symbols wit '_'   : call my_sub()
   \- Module symbols without '_': use mymod; call mysub()
   \- Module symbols wit '_'   : use mymod; call my_sub()
.fi

If manglin fo' a cold-ass lil category aint known, its macro is left undefined. Y'all KNOW dat shit, muthafucka! All macros require raw names up in both lower case n' upper case. Da MACRO_NAMESPACE option replaces tha default "FortranCInterface_" prefix wit a given namespace "<macro\-ns>".


Da SYMBOLS option lists symbols ta mangle automatically wit C preprocessor definitions:


.nf
   <function>          ==> #define <ns><function> ...
   <module>:<function> ==> #define <ns><module>_<function> ...
.fi

If tha manglin fo' some symbol aint known then no preprocessor definizzle is pimped, n' a warnin is displayed. Y'all KNOW dat shit, muthafucka! Da SYMBOL_NAMESPACE option prefixes all preprocessor definitions generated by tha SYMBOLS option wit a given namespace "<ns>".


Example usage:


.nf
   include(FortranCInterface)
   FortranCInterface_HEADER(FC.h MACRO_NAMESPACE "FC_")
.fi

This creates a "FC.h" header dat defines manglin macros FC_GLOBAL(), FC_GLOBAL_(), FC_MODULE(), n' FC_MODULE_().


Example usage:


.nf
   include(FortranCInterface)
   FortranCInterface_HEADER(FCMangle.h
                            MACRO_NAMESPACE "FC_"
                            SYMBOL_NAMESPACE "FC_"
                            SYMBOLS mysub mymod:my_sub)
.fi

This creates a "FCMangle.h" header dat defines tha same ol' dirty FC_*() manglin macros as tha previous example plus preprocessor symbols FC_mysub n' FC_mymod_my_sub.


Another function is provided ta verify dat tha Fortran n' C/C++ compilaz work together:


.nf
   FortranCInterface_VERIFY([CXX] [QUIET])
.fi

It tests whether a simple test executable rockin Fortran n' C (and C++ when tha CXX option is given) compilez n' links successfully. Da result is stored up in tha cache entry FortranCInterface_VERIFIED_C (or FortranCInterface_VERIFIED_CXX if CXX is given) as a funky-ass boolean. I aint talkin' bout chicken n' gravy biatch. If tha check fails n' QUIET aint given tha function terminates wit a FATAL_ERROR message describin tha problem.  Da purpose of dis check is ta stop a funky-ass build early fo' incompatible compila combinations.  Da test is built up in tha Release configuration.


FortranCInterface be aware of possible GLOBAL n' MODULE manglings fo' nuff Fortran compilaz yo, but it also serves up a intercourse ta specify freshly smoked up possible manglings.  Set tha variables


.nf
   FortranCInterface_GLOBAL_SYMBOLS
   FortranCInterface_MODULE_SYMBOLS
.fi

before includin FortranCInterface ta specify manglingz of tha symbols "MySub", "My_Sub", "MyModule:MySub", n' "My_Module:My_Sub". For example, tha code:


.nf
   set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub__ MYSUB_)
     #                                  ^^^^^  ^^^^^^   ^^^^^
   set(FortranCInterface_MODULE_SYMBOLS
       __mymodule_MOD_mysub __my_module_MOD_my_sub)
     #   ^^^^^^^^     ^^^^^   ^^^^^^^^^     ^^^^^^
   include(FortranCInterface)
.fi

 drops some lyrics ta FortranCInterface ta try given GLOBAL n' MODULE manglings. (Da carets point at raw symbol names fo' claritizzle up in dis example but is not needed.)

.TP
.B GNUInstallDirs
Define GNU standard installation directories

Provides install directory variablez as defined fo' GNU software:


.nf
  http://www.gnu.org/prep/standards/html_node/Directory\-Variables.html
.fi

Inclusion of dis module defines tha followin variables:


.nf
  CMAKE_INSTALL_<dir>      \- destination fo' filez of a given type
  CMAKE_INSTALL_FULL_<dir> \- correspondin absolute path
.fi

where <dir> is one of:


.nf
  BINDIR           \- user executablez (bin)
  SBINDIR          \- system admin executablez (sbin)
  LIBEXECDIR       \- program executablez (libexec)
  SYSCONFDIR       \- read\-only single\-machine data (etc)
  SHAREDSTATEDIR   \- modifiable architecture\-independent data (com)
  LOCALSTATEDIR    \- modifiable single\-machine data (var)
  LIBDIR           \- object code libraries (lib or lib64 or lib/<multiarch\-tuple> on Debian)
  INCLUDEDIR       \- C header filez (include)
  OLDINCLUDEDIR    \- C header filez fo' non\-gcc (/usr/include)
  DATAROOTDIR      \- read\-only architecture\-independent data root (share)
  DATADIR          \- read\-only architecture\-independent data (DATAROOTDIR)
  INFODIR          \- info documentation (DATAROOTDIR/info)
  LOCALEDIR        \- locale\-dependent data (DATAROOTDIR/locale)
  MANDIR           \- playa documentation (DATAROOTDIR/man)
  DOCDIR           \- documentation root (DATAROOTDIR/doc/PROJECT_NAME)
.fi

Each CMAKE_INSTALL_<dir> value may be passed ta tha DESTINATION optionz of install() commandz fo' tha correspondin file type.  If tha includer do not define a value tha above\-shown default is ghon be used n' tha value will step tha fuck up in tha cache fo' editin by tha user n' shit. Each CMAKE_INSTALL_FULL_<dir> value gotz nuff a absolute path constructed from tha correspondin destination by prependin (if necessary) tha value of CMAKE_INSTALL_PREFIX.

.TP
.B GenerateExportHeader
Function fo' generation of export macros fo' libraries

This module serves up tha function GENERATE_EXPORT_HEADER() n' tha accompanyin ADD_COMPILER_EXPORT_FLAGS() function.


Da GENERATE_EXPORT_HEADER function can be used ta generate a gangbangin' file suitable fo' preprocessor inclusion which gotz nuff EXPORT macros ta be used up in library classes.


GENERATE_EXPORT_HEADER( LIBRARY_TARGET


.nf
             [BASE_NAME <base_name>]
             [EXPORT_MACRO_NAME <export_macro_name>]
             [EXPORT_FILE_NAME <export_file_name>]
             [DEPRECATED_MACRO_NAME <deprecated_macro_name>]
             [NO_EXPORT_MACRO_NAME <no_export_macro_name>]
             [STATIC_DEFINE <static_define>]
             [NO_DEPRECATED_MACRO_NAME <no_deprecated_macro_name>]
             [DEFINE_NO_DEPRECATED]
             [PREFIX_NAME <prefix_name>]
.fi

)


ADD_COMPILER_EXPORT_FLAGS( [<output_variable>] )


By default GENERATE_EXPORT_HEADER() generates macro names up in a gangbangin' file name determined by tha name of tha library. Da ADD_COMPILER_EXPORT_FLAGS function addz \-fvisibility=hidden ta CMAKE_CXX_FLAGS if supported, n' be a no\-op on Windows which do not need extra compila flags fo' exportin support. Yo ass may optionally pass a single argument ta ADD_COMPILER_EXPORT_FLAGS dat is ghon be populated wit tha required CXX_FLAGS required ta enable visibilitizzle support fo' tha compiler/architecture up in use.


This means dat up in tha simplest case, playaz of these functions is ghon be equivalent to:


.nf
   add_compiler_export_flags()
   add_library(somelib someclass.cpp)
   generate_export_header(somelib)
   install(TARGETS somelib DESTINATION ${LIBRARY_INSTALL_DIR})
   install(FILES
    someclass.h
    ${PROJECT_BINARY_DIR}/somelib_export.h DESTINATION ${INCLUDE_INSTALL_DIR}
   )
.fi




And up in tha ABI header files:


.nf
   #include "somelib_export.h"
   class SOMELIB_EXPORT SomeClass {
     ...
   };
.fi




Da CMake fragment will generate a gangbangin' file up in tha ${CMAKE_CURRENT_BINARY_DIR} called somelib_export.h containin tha macros SOMELIB_EXPORT, SOMELIB_NO_EXPORT, SOMELIB_DEPRECATED, SOMELIB_DEPRECATED_EXPORT n' SOMELIB_DEPRECATED_NO_EXPORT. Da resultin file should be installed wit other headaz up in tha library.


Da BASE_NAME argument can be used ta override tha file name n' tha names used fo' tha macros


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     BASE_NAME other_name
   )
.fi




Generates a gangbangin' file called other_name_export.h containin tha macros OTHER_NAME_EXPORT, OTHER_NAME_NO_EXPORT n' OTHER_NAME_DEPRECATED etc.


Da BASE_NAME may be overridden by specifiyin other options up in tha function. I aint talkin' bout chicken n' gravy biatch. For example:


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     EXPORT_MACRO_NAME OTHER_NAME_EXPORT
   )
.fi




creates tha macro OTHER_NAME_EXPORT instead of SOMELIB_EXPORT yo, but other macros n' tha generated file name be as default.


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     DEPRECATED_MACRO_NAME KDE_DEPRECATED
   )
.fi




creates tha macro KDE_DEPRECATED instead of SOMELIB_DEPRECATED.


If LIBRARY_TARGET be a static library, macros is defined without joints.


If tha same sources is used ta create both a gangbangin' finger-lickin' dirty-ass shared n' a static library, tha uppercased symbol ${BASE_NAME}_STATIC_DEFINE should be used when buildin tha static library


.nf
   add_library(shared_variant SHARED ${lib_SRCS})
   add_library(static_variant ${lib_SRCS})
   generate_export_header(shared_variant BASE_NAME libshared_and_static)
   set_target_properties(static_variant PROPERTIES
     COMPILE_FLAGS \-DLIBSHARED_AND_STATIC_STATIC_DEFINE)
.fi




This will cause tha export macros ta expand ta not a god damn thang when buildin tha static library.


If DEFINE_NO_DEPRECATED is specified, then a macro ${BASE_NAME}_NO_DEPRECATED is ghon be defined This macro can be used ta remove deprecated code from preprocessor output.


.nf
   option(EXCLUDE_DEPRECATED "Exclude deprecated partz of tha library" FALSE)
   if (EXCLUDE_DEPRECATED)
     set(NO_BUILD_DEPRECATED DEFINE_NO_DEPRECATED)
   endif()
   generate_export_header(somelib ${NO_BUILD_DEPRECATED})
.fi




And then up in somelib:


.nf
   class SOMELIB_EXPORT SomeClass
   {
   public:
   #ifndef SOMELIB_NO_DEPRECATED
     SOMELIB_DEPRECATED void oldMethod();
   #endif
   };
.fi




.nf
   #ifndef SOMELIB_NO_DEPRECATED
   void SomeClass::oldMethod() {  }
   #endif
.fi




If PREFIX_NAME is specified, tha argument is ghon be used as a prefix ta all generated macros.


For example:


.nf
   generate_export_header(somelib PREFIX_NAME VTK_)
.fi




Generates tha macros VTK_SOMELIB_EXPORT etc.

.TP
.B GetPrerequisites
Functions ta analyze n' list executable file prerequisites.

This module serves up functions ta list tha .dll, .dylib or .so filez dat a executable or shared library file dependz on. I aint talkin' bout chicken n' gravy biatch. (Its prerequisites.)


It uses various tools ta obtain tha list of required shared library files:


.nf
   dumpbin (Windows)
   objdump (MinGW on Windows)
   ldd (Linux/Unix)
   otool (Mac OSX)
.fi

Da followin functions is provided by dis module:


.nf
   get_prerequisites
   list_prerequisites
   list_prerequisites_by_glob
   gp_append_unique
   is_file_executable
   gp_item_default_embedded_path
     (projects can override wit gp_item_default_embedded_path_override)
   gp_resolve_item
     (projects can override wit gp_resolve_item_override)
   gp_resolved_file_type
     (projects can override wit gp_resolved_file_type_override)
   gp_file_type
.fi

Requires CMake 2.6 or pimped outa cuz it uses function, break, return n' PARENT_SCOPE.


.nf
  GET_PREREQUISITES(<target> <prerequisites_var> <exclude_system> <recurse>
                    <exepath> <dirs>)
.fi

Git tha list of shared library filez required by <target>. Da list up in tha variable named <prerequisites_var> should be empty on first entry ta dis function. I aint talkin' bout chicken n' gravy biatch. On exit, <prerequisites_var> will contain tha list of required shared library files.


<target> is tha full path ta a executable file. <prerequisites_var> is tha name of a CMake variable ta contain tha thangs up in dis biatch. <exclude_system> must be 0 or 1 indicatin whether ta include or exclude "system" prerequisites. If <recurse> is set ta 1 all prerequisites is ghon be found recursively, if set ta 0 only direct prerequisites is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. <exepath> is tha path ta tha top level executable used fo' @executable_path replacment on tha Mac. <dirs> be a list of paths where libraries might be found: these paths is searched first when a target without any path info is given. I aint talkin' bout chicken n' gravy biatch. Then standard system locations is also searched: PATH, Framework locations, /usr/lib...


.nf
  LIST_PREREQUISITES(<target> [<recurse> [<exclude_system> [<verbose>]]])
.fi

Print a message listin tha prerequisitez of <target>.


<target> is tha name of a gangbangin' finger-lickin' dirty-ass shared library or executable target or tha full path ta a gangbangin' finger-lickin' dirty-ass shared library or executable file. If <recurse> is set ta 1 all prerequisites is ghon be found recursively, if set ta 0 only direct prerequisites is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. <exclude_system> must be 0 or 1 indicatin whether ta include or exclude "system" prerequisites. With <verbose> set ta 0 only tha full path namez of tha prerequisites is printed, set ta 1 extra informatin is ghon be displayed.


.nf
  LIST_PREREQUISITES_BY_GLOB(<glob_arg> <glob_exp>)
.fi

Print tha prerequisitez of shared library n' executable filez matchin a globbin pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. <glob_arg> is GLOB or GLOB_RECURSE n' <glob_exp> be a globbin expression used wit "file(GLOB" or "file(GLOB_RECURSE" ta retrieve a list of matchin files. If a matchin file is executable, its prerequisites is listed.


Any additionizzle (optional) arguments provided is passed along as tha optionizzle arguments ta tha list_prerequisites calls.


.nf
  GP_APPEND_UNIQUE(<list_var> <value>)
.fi

Append <value> ta tha list variable <list_var> only if tha value aint already up in tha list.


.nf
  IS_FILE_EXECUTABLE(<file> <result_var>)
.fi

Return 1 up in <result_var> if <file> be a funky-ass binary executable, 0 otherwise.


.nf
  GP_ITEM_DEFAULT_EMBEDDED_PATH(<item> <default_embedded_path_var>)
.fi

Return tha path dat others should refer ta tha item by when tha item is embedded inside a funky-ass bundle.


Override on a per\-project basis by providin a project\-specific gp_item_default_embedded_path_override function.


.nf
  GP_RESOLVE_ITEM(<context> <item> <exepath> <dirs> <resolved_item_var>)
.fi

Resolve a item tha fuck into a existin full path file.


Override on a per\-project basis by providin a project\-specific gp_resolve_item_override function.


.nf
  GP_RESOLVED_FILE_TYPE(<original_file> <file> <exepath> <dirs> <type_var>)
.fi

Return tha type of <file> wit respect ta <original_file>. Right back up in yo muthafuckin ass. Strin describin type of prerequisite is returned up in variable named <type_var>.


Use <exepath> n' <dirs> if necessary ta resolve non\-absolute <file> joints \-\- but only fo' non\-embedded items.


Possible types are:


.nf
   system
   local
   embedded
   other
.fi

Override on a per\-project basis by providin a project\-specific gp_resolved_file_type_override function.


.nf
  GP_FILE_TYPE(<original_file> <file> <type_var>)
.fi

Return tha type of <file> wit respect ta <original_file>. Right back up in yo muthafuckin ass. Strin describin type of prerequisite is returned up in variable named <type_var>.


Possible types are:


.nf
   system
   local
   embedded
   other
.fi

.TP
.B InstallRequiredSystemLibraries
.nf
 
.fi

By includin dis file, all library filez listed up in tha variable CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS is ghon be installed wit install(PROGRAMS ...) tha fuck into bin fo' WIN32 n' lib fo' non\-WIN32. If CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP is set ta TRUE before includin dis file, then tha INSTALL command aint called. Y'all KNOW dat shit, muthafucka! Da user can use tha variable CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS ta bust a cold-ass lil custom install command n' install dem however they want. If it is tha MSVC compiler, then tha microsizzlez run time libraries is ghon be found n' automatically added ta tha CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS, n' installed. Y'all KNOW dat shit, muthafucka! If CMAKE_INSTALL_DEBUG_LIBRARIES is set n' it is tha MSVC compiler, then tha debug libraries is installed when available. If CMAKE_INSTALL_DEBUG_LIBRARIES_ONLY is set then only tha debug libraries is installed when both debug n' release is available. If CMAKE_INSTALL_MFC_LIBRARIES is set then tha MFC run time libraries is installed as well as tha CRT run time libraries. Put ya muthafuckin choppers up if ya feel dis! If CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION is set then tha libraries is installed ta dat directory rather than tha default. If CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS is NOT set, then dis file warns bout required filez dat do not exist. Yo ass can set dis variable ta ON before includin dis file ta avoid tha warning. For example, tha Visual Studio Express editions do not include tha redistributable files, so if you include dis file on a machine wit only VS Express installed, you gonna git tha warning.

.TP
.B MacroAddFileDependencies
MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...)

Usin tha macro MACRO_ADD_FILE_DEPENDENCIES() is discouraged. Y'all KNOW dat shit, muthafucka! There is probably betta ways ta specify tha erect dependencies.


MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...) is just a cold-ass lil convenience wrapper round tha OBJECT_DEPENDS source file property. Yo ass can just use set_property(SOURCE <file> APPEND PROPERTY OBJECT_DEPENDS depend_files) instead.

.TP
.B ProcessorCount
ProcessorCount(var)

Determine tha number of processors/cores n' save value up in ${var}


Sets tha variable named ${var} ta tha number of physical cores available on tha machine if tha shiznit can be determined. Y'all KNOW dat shit, muthafucka! Otherwise it is set ta 0. Currently dis functionalitizzle is implemented fo' AIX, cygwin, FreeBSD, HPUX, IRIX, Linux, Mac OS X, QNX, Sun n' Windows.


This function is guaranteed ta return a positizzle integer (>=1) if it succeeds. Well shiiiit, it returns 0 if there be a a problem determinin tha processor count.


Example use, up in a cold-ass lil ctest \-S dashboard script:


.nf
   include(ProcessorCount)
   ProcessorCount(N)
   if(NOT N EQUAL 0)
     set(CTEST_BUILD_FLAGS \-j${N})
     set(ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N})
   endif()
.fi




This function is intended ta offer a approximation of tha value of tha number of compute cores available on tha current machine, such dat you may use dat value fo' parallel buildin n' parallel testing. Well shiiiit, it is meant ta help utilize as much of tha machine as seems reasonable. Of course, knowledge of what tha fuck else might be hustlin on tha machine simultaneously should be used when decidin whether ta request a machinez full capacitizzle all fo' yo ass.

.TP
.B Qt4ConfigDependentSettings
.nf
 
.fi

This file is included by FindQt4.cmake, don't include it directly.

.TP
.B Qt4Macros
.nf
 
.fi

This file is included by FindQt4.cmake, don't include it directly.

.TP
.B SelectLibraryConfigurations
.nf
 
.fi

select_library_configurations( basename )


This macro takes a library base name as a argument, n' will chizzle phat joints fo' basename_LIBRARY, basename_LIBRARIES, basename_LIBRARY_DEBUG, n' basename_LIBRARY_RELEASE dependin on what tha fuck has been found n' set.  If only basename_LIBRARY_RELEASE is defined, basename_LIBRARY is ghon be set ta tha release value, n' basename_LIBRARY_DEBUG is ghon be set ta basename_LIBRARY_DEBUG\-NOTFOUND.  If only basename_LIBRARY_DEBUG is defined, then basename_LIBRARY will take tha debug value, n' basename_LIBRARY_RELEASE is ghon be set ta basename_LIBRARY_RELEASE\-NOTFOUND.


If tha generator supports configuration types, then basename_LIBRARY n' basename_LIBRARIES is ghon be set wit debug n' optimized flags specifyin tha library ta be used fo' tha given configuration. I aint talkin' bout chicken n' gravy biatch.  If no build type has been set or tha generator up in use do not support configuration types, then basename_LIBRARY n' basename_LIBRARIES will take only tha release value, or tha debug value if tha release one aint set.

.TP
.B SquishTestScript
.nf
 
.fi




This script launches a GUI test rockin Squish.  Yo ass should not call tha script directly; instead, you should access it via tha SQUISH_ADD_TEST macro dat is defined up in FindSquish.cmake.


This script starts tha Squish server, launches tha test on tha client, n' finally stops tha squish server n' shit.  If any of these steps fail (includin if tha tests do not pass) then a gangbangin' fatal error is raised.


.TP
.B TestBigEndian
Define macro ta determine endian type

Peep if tha system is big-ass endian or lil endian


.nf
  TEST_BIG_ENDIAN(VARIABLE)
  VARIABLE \- variable ta store tha result to
.fi




.TP
.B TestCXXAcceptsFlag
Test CXX compila fo' a gangbangin' flag

Peep if tha CXX compila accepts a gangbangin' flag


.nf
  Macro CHECK_CXX_ACCEPTS_FLAG(FLAGS VARIABLE) \-
     checks if tha function exists
  FLAGS \- tha flags ta try
  VARIABLE \- variable ta store tha result
.fi




.TP
.B TestForANSIForScope
Peep fo' ANSI fo' scope support

Peep if tha compila restricts tha scope of variablez declared up in a gangbangin' for\-init\-statement ta tha loop body.


.nf
  CMAKE_NO_ANSI_FOR_SCOPE \- holdz result
.fi




.TP
.B TestForANSIStreamHeaders
Test fo' compila support of ANSI stream headaz iostream, etc.

check if tha compila supports tha standard ANSI iostream header (without tha .h)


.nf
  CMAKE_NO_ANSI_STREAM_HEADERS \- defined by tha thangs up in dis biatch
.fi




.TP
.B TestForSSTREAM
Test fo' compila support of ANSI sstream header

check if tha compila supports tha standard ANSI sstream header


.nf
  CMAKE_NO_ANSI_STRING_STREAM \- defined by tha thangs up in dis biatch
.fi




.TP
.B TestForSTDNamespace
Test fo' std:: namespace support

check if tha compila supports std:: on stl classes


.nf
  CMAKE_NO_STD_NAMESPACE \- defined by tha thangs up in dis biatch
.fi




.TP
.B UseEcos
This module defines variablez n' macros required ta build eCos application.

This file gotz nuff tha followin macros: ECOS_ADD_INCLUDE_DIRECTORIES() \- add tha eCos include dirs ECOS_ADD_EXECUTABLE(name source1 ... sourceN ) \- create a eCos executable ECOS_ADJUST_DIRECTORY(VAR source1 ... sourceN ) \- adjusts tha path of tha source filez n' puts tha result tha fuck into VAR


Macros fo' selectin tha toolchain: ECOS_USE_ARM_ELF_TOOLS()       \- enable tha ARM ELF toolchain fo' tha directory where it is called ECOS_USE_I386_ELF_TOOLS()      \- enable tha i386 ELF toolchain fo' tha directory where it is called ECOS_USE_PPC_EABI_TOOLS()      \- enable tha PowerPC toolchain fo' tha directory where it is called


It gotz nuff tha followin variables: ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE               \- defaults ta ecos.ecc, if yo' eCos configuration file has a gangbangin' finger-lickin' different name, adjust dis variable fo' internal use only:


.nf
  ECOS_ADD_TARGET_LIB
.fi

.TP
.B UseJava
Use Module fo' Java

This file serves up functions fo' Java. Well shiiiit, it be assumed dat FindJava.cmake has already been loaded. Y'all KNOW dat shit, muthafucka!  See FindJava.cmake fo' shiznit on how tha fuck ta load Java tha fuck into yo' CMake project.


add_jar(target_name


.nf
         [SOURCES] source1 [source2 ...] [resource1 ...]
         [INCLUDE_JARS jar1 [jar2 ...]]
         [ENTRY_POINT entry]
         [VERSION version]
         [OUTPUT_NAME name]
         [OUTPUT_DIR dir]
        )
.fi




This command creates a <target_name>.jar. Shiiit, dis aint no joke. Well shiiiit, it compilez tha given source filez (source) n' addz tha given resource filez (resource) ta tha jar file. If only resource filez is given then just a jar file is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da list of include jars is added ta tha classpath when compilin tha java sources n' also ta tha dependenciez of tha target. INCLUDE_JARS also accepts other target names pimped by add_jar. Shiiit, dis aint no joke. For backwardz compatibility, jar filez listed as sources is ignored (as they done been since tha straight-up original gangsta version of dis module).


Da default OUTPUT_DIR can also be chizzled by settin tha variable CMAKE_JAVA_TARGET_OUTPUT_DIR.


Additionizzle instructions:


.nf
   To add compile flags ta tha target you can set these flags with
   tha followin variable:
.fi




.nf
       set(CMAKE_JAVA_COMPILE_FLAGS \-nowarn)
.fi




.nf
   To add a path or a jar file ta tha class path you can do this
   wit tha CMAKE_JAVA_INCLUDE_PATH variable.
.fi




.nf
       set(CMAKE_JAVA_INCLUDE_PATH /usr/share/java/shibboleet.jar)
.fi




.nf
   To bust a gangbangin' finger-lickin' different output name fo' tha target you can set it with:
.fi




.nf
       add_jar(foobar foobar.java OUTPUT_NAME shibboleet.jar)
.fi




.nf
   To bust a gangbangin' finger-lickin' different output directory than CMAKE_CURRENT_BINARY_DIR
   you can set it with:
.fi




.nf
       add_jar(foobar foobar.java OUTPUT_DIR ${PROJECT_BINARY_DIR}/bin)
.fi




.nf
   To define a entry point up in yo' jar you can set it wit tha ENTRY_POINT
   named argument:
.fi




.nf
       add_jar(example ENTRY_POINT com/examples/MyProject/Main)
.fi




.nf
   To add a VERSION ta tha target output name you can set it using
   tha VERSION named argument ta add_jar. Shiiit, dis aint no joke. This will create a jar file wit the
   name shibboleet\-1.0.0.jar n' will create a symlink shibboleet.jar
   pointin ta tha jar wit tha version shiznit.
.fi




.nf
       add_jar(shibboleet shibbotleet.java VERSION 1.2.0)
.fi




.nf
    If tha target be a JNI library, utilize tha followin commandz to
    create a JNI symbolic link:
.fi




.nf
       set(CMAKE_JNI_TARGET TRUE)
       add_jar(shibboleet shibbotleet.java VERSION 1.2.0)
       install_jar(shibboleet ${LIB_INSTALL_DIR}/shibboleet)
       install_jni_symlink(shibboleet ${JAVA_LIB_INSTALL_DIR})
.fi




.nf
    If a single target need ta produce mo' than one jar from its
    java source code, ta prevent tha accumulation of duplicate class
    filez up in subsequent jars, set/reset CMAKE_JAR_CLASSES_PREFIX prior
    ta callin tha add_jar() function:
.fi




.nf
       set(CMAKE_JAR_CLASSES_PREFIX com/redhat/foo)
       add_jar(foo foo.java)
.fi




.nf
       set(CMAKE_JAR_CLASSES_PREFIX com/redhat/bar)
       add_jar(bar bar.java)
.fi




Target Properties:


.nf
   Da add_jar() functions sets some target properties. Put ya muthafuckin choppers up if ya feel dis! Yo ass can git these
   propertizzles wit the
      get_property(TARGET <target_name> PROPERTY <propery_name>)
   command.
.fi




.nf
   INSTALL_FILES      Da filez which should be installed. Y'all KNOW dat shit, muthafucka! This is used by
                      install_jar().
   JNI_SYMLINK        Da JNI symlink which should be installed.
                      This is used by install_jni_symlink().
   JAR_FILE           Da location of tha jar file so dat you can include
                      dat shit.
   CLASS_DIR          Da directory where tha class filez can be found. Y'all KNOW dat shit, muthafucka! For
                      example ta use dem wit javah.
.fi




find_jar(<VAR>


.nf
          name | NAMES name1 [name2 ...]
          [PATHS path1 [path2 ... ENV var]]
          [VERSIONS version1 [version2]]
          [DOC "cache documentation string"]
         )
.fi




This command is used ta find a gangbangin' full path ta tha named jar fo' realz. A cache entry named by <VAR> is pimped ta stor tha result of dis command. Y'all KNOW dat shit, muthafucka! If tha full path ta a jar is found tha result is stored up in tha variable n' tha search aint gonna repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka! If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again next time find_jar is invoked wit tha same variable. Da name of tha full path ta a gangbangin' file dat is searched fo' is specified by tha names listed afta NAMES argument fo' realz. Additionizzle search locations can be specified afta tha PATHS argument. If you require special a version of a jar file you can specify it wit tha VERSIONS argument. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.


install_jar(TARGET_NAME DESTINATION)


This command installs tha TARGET_NAME filez ta tha given DESTINATION. Well shiiiit, it should be called up in tha same scope as add_jar() or it will fail.


install_jni_symlink(TARGET_NAME DESTINATION)


This command installs tha TARGET_NAME JNI symlinks ta tha given DESTINATION. Well shiiiit, it should be called up in tha same scope as add_jar() or it will fail.


create_javadoc(<VAR>


.nf
                PACKAGES pkg1 [pkg2 ...]
                [SOURCEPATH <sourcepath>]
                [CLASSPATH <classpath>]
                [INSTALLPATH <install path>]
                [DOCTITLE "the documentation title"]
                [WINDOWTITLE "the title of tha document"]
                [AUTHOR TRUE|FALSE]
                [USE TRUE|FALSE]
                [VERSION TRUE|FALSE]
               )
.fi




Smoke java documentation based on filez or packages. For mo' details please read tha javadoc manpage.


There is two main signatures fo' create_javadoc. Da first signature works wit package names on a path wit source files:


.nf
   Example:
   create_javadoc(my_example_doc
     PACKAGES com.exmaple.foo com.example.bar
     SOURCEPATH "${CMAKE_CURRENT_SOURCE_DIR}"
     CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH}
     WINDOWTITLE "My fuckin example"
     DOCTITLE "<h1>I be a gangsta yo, but y'all knew dat n' mah example</h1>"
     AUTHOR TRUE
     USE TRUE
     VERSION TRUE
   )
.fi




Da second signature fo' create_javadoc works on a given list of files.


.nf
   create_javadoc(<VAR>
                  FILES file1 [file2 ...]
                  [CLASSPATH <classpath>]
                  [INSTALLPATH <install path>]
                  [DOCTITLE "the documentation title"]
                  [WINDOWTITLE "the title of tha document"]
                  [AUTHOR TRUE|FALSE]
                  [USE TRUE|FALSE]
                  [VERSION TRUE|FALSE]
                 )
.fi




Example:


.nf
   create_javadoc(my_example_doc
     FILES ${example_SRCS}
     CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH}
     WINDOWTITLE "My fuckin example"
     DOCTITLE "<h1>I be a gangsta yo, but y'all knew dat n' mah example</h1>"
     AUTHOR TRUE
     USE TRUE
     VERSION TRUE
   )
.fi




Both signatures share most of tha options. These options is tha same as what tha fuck you can find up in tha javadoc manpage. Please peep tha manpage fo' CLASSPATH, DOCTITLE, WINDOWTITLE, AUTHOR, USE n' VERSION.


Da documentation is ghon be by default installed to


.nf
   ${CMAKE_INSTALL_PREFIX}/share/javadoc/<VAR>
.fi




if you don't set tha INSTALLPATH.


.TP
.B UseJavaClassFilelist
.nf
 
.fi




This script create a list of compiled Java class filez ta be added ta a jar file. This avoidz includin cmake filez which git pimped up in tha binary directory.


.TP
.B UseJavaSymlinks
.nf
 
.fi




Helper script fo' UseJava.cmake


.TP
.B UsePkgConfig
Obsolete pkg\-config module fo' CMake, use FindPkgConfig instead.




This module defines tha followin macro:


PKGCONFIG(package includedir libdir linkflags cflags)


Callin PKGCONFIG will fill tha desired shiznit tha fuck into tha 4 given arguments, e.g. PKGCONFIG(libart\-2.0 LIBART_INCLUDE_DIR LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg\-config was NOT found or tha specified software package don't exist, tha variable is ghon be empty when tha function returns, otherwise they will contain tha respectizzle shiznit


.TP
.B UseQt4
Use Module fo' QT4

Sets up C n' C++ ta use Qt 4.  It be assumed dat FindQt.cmake has already been loaded. Y'all KNOW dat shit, muthafucka!  See FindQt.cmake fo' shiznit on how tha fuck ta load Qt 4 tha fuck into yo' CMake project.

.TP
.B UseSWIG
SWIG module fo' CMake

Defines tha followin macros:


.nf
   SWIG_ADD_MODULE(name language [ filez ])
     \- Define swig module wit given name n' specified language
   SWIG_LINK_LIBRARIES(name [ libraries ])
     \- Link libraries ta swig module
.fi

All other macros is fo' internal use only. To git tha actual name of tha swig module, use: ${SWIG_MODULE_${name}_REAL_NAME}. Right back up in yo muthafuckin ass. Set Source filez propertizzles like fuckin CPLUSPLUS n' SWIG_FLAGS ta specify special behavior of SWIG fo' realz. Also global CMAKE_SWIG_FLAGS can be used ta add special flags ta all swig calls fo' realz. Another special variable is CMAKE_SWIG_OUTDIR, it allows one ta specify where ta write all tha swig generated module (swig \-outdir option) Da name\-specific variable SWIG_MODULE_<name>_EXTRA_DEPS may be used ta specify extra dependencies fo' tha generated modules. If tha source file generated by swig need some special flag you can use set_source_files_properties( ${swig_generated_file_fullname}


.nf
        PROPERTIES COMPILE_FLAGS "\-bla")
.fi

.TP
.B Use_wxWindows
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-




This convenience include findz if wxWindows is installed n' set tha appropriate libs, incdirs, flags etc. lyricist Jan Woetzel <jw \-at\- mip.informatik.uni\-kiel.de> (07/2003) USAGE:


.nf
   just include Use_wxWindows.cmake
   up in yo' projects CMakeLists.txt
.fi

include( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)


.nf
   if yo ass is shizzle you need GL then
.fi

set(WXWINDOWS_USE_GL 1)


.nf
   *before* you include dis file.
.fi

.TP
.B UsewxWidgets
Convenience include fo' rockin wxWidgets library.

Determines if wxWidgets was FOUND n' sets tha appropriate libs, incdirs, flags, etc. INCLUDE_DIRECTORIES n' LINK_DIRECTORIES is called.


USAGE


.nf
  # Note dat fo' MinGW playas tha order of libs is blingin!
  find_package(wxWidgets REQUIRED net gl core base)
  include(${wxWidgets_USE_FILE})
  # n' fo' each of yo' dependent executable/library targets:
  target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
.fi




DEPRECATED


.nf
  LINK_LIBRARIES aint called up in favor of addin dependencies per target.
.fi




AUTHOR


.nf
  Jan Woetzel <jw \-at\- mip.informatik.uni\-kiel.de>
.fi

.TP
.B WriteBasicConfigVersionFile
.nf
 
.fi

.nf
  WRITE_BASIC_CONFIG_VERSION_FILE( filename VERSION major.minor.patch COMPATIBILITY (AnyNewerVersion|SameMajorVersion) )
.fi




Deprecated, peep WRITE_BASIC_PACKAGE_VERSION_FILE(), it is identical.

.SH POLICIES
.TP
.B CMP0000
A minimum required CMake version must be specified.

CMake requires dat projects specify tha version of CMake ta which they done been written. I aint talkin' bout chicken n' gravy biatch.  This policy has been put up in place so playas tryin ta build tha project may be holla'd at when they need ta update they CMake.  Specifyin a version also helps tha project build wit CMake versions newer than dat specified. Y'all KNOW dat shit, muthafucka!  Use tha cmake_minimum_required command all up in tha top of yo' main  CMakeLists.txt file:


.nf
  cmake_minimum_required(VERSION <major>.<minor>)
.fi

where "<major>.<minor>" is tha version of CMake you wanna support (like fuckin "2.6").  Da command will ensure dat at least tha given version of CMake is hustlin n' help newer versions be compatible wit tha project.  See documentation of cmake_minimum_required fo' details.


Note dat tha command invocation must step tha fuck up in tha CMakeLists.txt file itself; a cold-ass lil call up in a included file aint sufficient.  But fuck dat shiznit yo, tha word on tha street is dat tha cmake_policy command may be called ta set policy CMP0000 ta OLD or NEW behavior explicitly.  Da OLD behavior is ta silently ignore tha missin invocation. I aint talkin' bout chicken n' gravy biatch.  Da NEW behavior is ta issue a error instead of a warning.  An included file may set CMP0000 explicitly ta affect how tha fuck dis policy is enforced fo' tha main CMakeLists.txt file.


This policy was introduced up in CMake version 2.6.0.

.TP
.B CMP0001
CMAKE_BACKWARDS_COMPATIBILITY should no longer be used.

Da OLD behavior is ta check CMAKE_BACKWARDS_COMPATIBILITY n' present it ta tha user n' shit.  Da NEW behavior is ta ignore CMAKE_BACKWARDS_COMPATIBILITY straight-up.


In CMake 2.4 n' below tha variable CMAKE_BACKWARDS_COMPATIBILITY was used ta request compatibilitizzle wit earlier versionz of CMake.  In CMake 2.6 n' above all compatibilitizzle thangs is handled by policies n' tha cmake_policy command. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat CMake must still check CMAKE_BACKWARDS_COMPATIBILITY fo' projects freestyled fo' CMake 2.4 n' below.


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0002
Logical target names must be globally unique.

Targets names pimped wit add_executable, add_library, or add_custom_target is logical build target names.  Logical target names must be globally unique cuz:


.nf
  \- Unique names may be referenced unambiguously both up in CMake
    code n' on make tool command lines.
  \- Logical names is used by Xcode n' VS IDE generators
    ta produce meaningful project names fo' tha targets.
.fi

Da logical name of executable n' library targets do not gotta correspond ta tha physical file names built.  Consider rockin tha OUTPUT_NAME target property ta create two targets wit tha same physical name while keepin logical names distinct.  Custom targets must simply have globally unique names (unless one uses tha global property ALLOW_DUPLICATE_CUSTOM_TARGETS wit a Makefilez generator).


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0003
Libraries linked via full path no longer produce linker search paths.

This policy affects how tha fuck libraries whose full paths is NOT known is found at link time yo, but was pimped cuz of a cold-ass lil chizzle up in how tha fuck CMake deals wit libraries whose full paths is known. I aint talkin' bout chicken n' gravy biatch.  Consider tha code


.nf
  target_link_libraries(myexe /path/to/libA.so)
.fi

CMake 2.4 n' below implemented linkin ta libraries whose full paths is known by splittin dem on tha link line tha fuck into separate components consistin of tha linker search path n' tha library name.  Da example code might have produced suttin' like


.nf
  ... \-L/path/to \-lA ...
.fi

in order ta link ta library A.  An analysis was performed ta order multiple link directories such dat tha linker would find library A up in tha desired location yo, but there be cases up in which dis do not work.  CMake versions 2.6 n' above use tha mo' reliable approach of passin tha full path ta libraries directly ta tha linker up in most cases.  Da example code now produces suttin' like


.nf
  ... /path/to/libA.so ....
.fi

Unfortunately dis chizzle can break code like


.nf
  target_link_libraries(myexe /path/to/libA.so B)
.fi

where "B" is meant ta find "/path/to/libB.so".  This code is wack cuz tha user be askin tha linker ta find library B but has not provided a linker search path (which may be added wit tha link_directories command).  But fuck dat shiznit yo, tha word on tha street is dat wit tha oldschool linkin implementation tha code would work accidentally cuz tha linker search path added fo' library A allowed library B ta be found.


In order ta support projects dependin on linker search paths added by linkin ta libraries wit known full paths, tha OLD behavior fo' dis policy will add tha linker search paths even though they is not needed fo' they own libraries. Put ya muthafuckin choppers up if ya feel dis!  When dis policy is set ta OLD, CMake will produce a link line such as


.nf
  ... \-L/path/to /path/to/libA.so \-lB ...
.fi

which will allow library B ta be found as dat shiznit was previously.  When dis policy is set ta NEW, CMake will produce a link line such as


.nf
  ... /path/to/libA.so \-lB ...
.fi

which mo' accurately matches what tha fuck tha project specified.


Da settin fo' dis policy used when generatin tha link line is dat up in effect when tha target is pimped by a add_executable or add_library command. Y'all KNOW dat shit, muthafucka!  For tha example busted lyrics bout above, tha code


.nf
  cmake_policy(SET CMP0003 OLD) # or cmake_policy(VERSION 2.4)
  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so B)
.fi

will work n' suppress tha warnin fo' dis policy.  It may also be updated ta work wit tha erected linkin approach:


.nf
  cmake_policy(SET CMP0003 NEW) # or cmake_policy(VERSION 2.6)
  link_directories(/path/to) # needed ta find library B
  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so B)
.fi

Even better, library B may be specified wit a gangbangin' full path:


.nf
  add_executable(myexe myexe.c)
  target_link_libraries(myexe /path/to/libA.so /path/to/libB.so)
.fi

When all shit on tha link line have known paths CMake do not check dis policy so it has no effect.


Note dat tha warnin fo' dis policy is ghon be issued fo' at most one target.  This avoidz floodin playas wit lyrics fo' every last muthafuckin target when settin tha policy once will probably fix all targets.


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0004
Libraries linked may not have leadin or trailin whitespace.

CMake versions 2.4 n' below silently removed leadin n' trailin whitespace from libraries linked wit code like


.nf
  target_link_libraries(myexe " A ")
.fi

This could lead ta subtle errors up in user projects.


Da OLD behavior fo' dis policy is ta silently remove leadin n' trailin whitespace.  Da NEW behavior fo' dis policy is ta diagnose tha existence of such whitespace as a error. Shiiit, dis aint no joke.  Da settin fo' dis policy used when checkin tha library names is dat up in effect when tha target is pimped by a add_executable or add_library command.


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0005
Preprocessor definizzle joints is now escaped automatically.

This policy determines whether or not CMake should generate escaped preprocessor definizzle joints added via add_definitions.  CMake versions 2.4 n' below assumed dat only trivial joints would be given fo' macros up in add_definitions calls.  It did not attempt ta escape non\-trivial joints like fuckin strang literals up in generated build rules.  CMake versions 2.6 n' above support escapin of most joints yo, but cannot assume tha user has not added escapes already up in a attempt ta work round limitations up in earlier versions.


Da OLD behavior fo' dis policy is ta place definizzle joints given ta add_definitions directly up in tha generated build rulez without attemptin ta escape anything.  Da NEW behavior fo' dis policy is ta generate erect escapes fo' all natizzle build tools automatically.  See documentation of tha COMPILE_DEFINITIONS target property fo' limitationz of tha escapin implementation.


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0006
Installin MACOSX_BUNDLE targets requires a BUNDLE DESTINATION.

This policy determines whether tha install(TARGETS) command must be given a BUNDLE DESTINATION when axed ta install a target wit tha MACOSX_BUNDLE property set.  CMake 2.4 n' below did not distinguish application bundlez from aiiight executablez when installin targets, n' you can put dat on yo' toast.  CMake 2.6 serves up a BUNDLE option ta tha install(TARGETS) command dat specifies rulez specific ta application bundlez on tha Mac.  Projects should use dis option when installin a target wit tha MACOSX_BUNDLE property set.


Da OLD behavior fo' dis policy is ta fall back ta tha RUNTIME DESTINATION if a BUNDLE DESTINATION aint given. I aint talkin' bout chicken n' gravy biatch.  Da NEW behavior fo' dis policy is ta produce a error if a funky-ass bundle target is installed without a BUNDLE DESTINATION.


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0007
list command no longer ignores empty elements.

This policy determines whether tha list command will ignore empty elements up in tha list. CMake 2.4 n' below list commandz ignored all empty elements up in tha list.  For example, a;b;;c would have length 3 n' not 4. Da OLD behavior fo' dis policy is ta ignore empty list elements, n' you can put dat on yo' toast. Da NEW behavior fo' dis policy is ta erectly count empty elements up in a list. 


This policy was introduced up in CMake version 2.6.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0008
Libraries linked by full\-path must gotz a valid library file name.

In CMake 2.4 n' below it is possible ta write code like


.nf
  target_link_libraries(myexe /full/path/to/somelib)
.fi

where "somelib" is supposed ta be a valid library file name like fuckin "libsomelib.a" or "somelib.lib".  For Makefile generators dis produces a error at build time cuz tha dependency on tha full path cannot be found. Y'all KNOW dat shit, muthafucka!  For VS IDE n' Xcode generators dis used ta work by accident cuz CMake would always split off tha library directory n' ask tha linker ta search fo' tha library by name (\-lsomelib or somelib.lib).  Despite tha failure wit Makefiles, some projects have code like dis n' build only wit VS and/or Xcode.  This version of CMake prefers ta pass tha full path directly ta tha natizzle build tool, which will fail up in dis case cuz it do not name a valid library file.


This policy determines what tha fuck ta do wit full paths dat do not step tha fuck up ta name a valid library file.  Da OLD behavior fo' dis policy is ta split tha library name from tha path n' ask tha linker ta search fo' dat shit.  Da NEW behavior fo' dis policy is ta trust tha given path n' pass it directly ta tha natizzle build tool unchanged.


This policy was introduced up in CMake version 2.6.1.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0009
FILE GLOB_RECURSE calls should not follow symlinks by default.

In CMake 2.6.1 n' below, FILE GLOB_RECURSE calls would follow all up in symlinks, sometimes comin up wit unexpectedly big-ass result sets cuz of symlinks ta top level directories dat contain hundredz of thousandz of files.


This policy determines whether or not ta follow symlinks encountered durin a FILE GLOB_RECURSE call. Da OLD behavior fo' dis policy is ta follow tha symlinks. Da NEW behavior fo' dis policy aint ta follow tha symlinks by default yo, but only if FOLLOW_SYMLINKS is given as a additionizzle argument ta tha FILE command.


This policy was introduced up in CMake version 2.6.2.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0010
Wack variable reference syntax be a error.

In CMake 2.6.2 n' below, incorrect variable reference syntax like fuckin a missin close\-brace ("${FOO") was reported but did not stop processin of CMake code.  This policy determines whether a wack variable reference be a error. Shiiit, dis aint no joke.  Da OLD behavior fo' dis policy is ta warn bout tha error, leave tha strang untouched, n' continue. Da NEW behavior fo' dis policy is ta report a error.


This policy was introduced up in CMake version 2.6.3.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0011
Included scripts do automatic cmake_policy PUSH n' POP.

In CMake 2.6.2 n' below, CMake Policy settings up in scripts loaded by tha include() n' find_package() commandz would affect tha includer n' shit.  Explicit invocationz of cmake_policy(PUSH) n' cmake_policy(POP) was required ta isolate policy chizzlez n' protect tha includer n' shit.  While some scripts intend ta affect tha policiez of they includer, most do not.  In CMake 2.6.3 n' above, include() n' find_package() by default PUSH n' POP a entry on tha policy stack round a included script yo, but provide a NO_POLICY_SCOPE option ta disable dat shit.  This policy determines whether or not ta imply NO_POLICY_SCOPE fo' compatibility.  Da OLD behavior fo' dis policy is ta imply NO_POLICY_SCOPE fo' include() n' find_package() commands.  Da NEW behavior fo' dis policy is ta allow tha commandz ta do they default cmake_policy PUSH n' POP.


This policy was introduced up in CMake version 2.6.3.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0012
if() recognizes numbers n' boolean constants.

In CMake versions 2.6.4 n' lower tha if() command implicitly dereferenced arguments correspondin ta variables, even dem named like numbers or boolean constants, except fo' 0 n' 1.  Numbers n' boolean constants like fuckin true, false, fo'sho, no, on, off, y, n, notfound, ignore (all case insensitive) was recognized up in some cases but not all.  For example, tha code "if(TRUE)" might have evaluated as false.  Numbers like fuckin 2 was recognized only up in boolean expressions like "if(NOT 2)" (leadin ta false) but not as a single\-argument like "if(2)" (also leadin ta false). Lata versionz of CMake prefer ta treat numbers n' boolean constants literally, so they should not be used as variable names.


Da OLD behavior fo' dis policy is ta implicitly dereference variablez named like numbers n' boolean constants, n' you can put dat on yo' toast. Da NEW behavior fo' dis policy is ta recognize numbers n' boolean constants without dereferencin variablez wit such names.


This policy was introduced up in CMake version 2.8.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0013
Duplicate binary directories is not allowed.

CMake 2.6.3 n' below silently permitted add_subdirectory() calls ta create tha same binary directory multiple times.  Durin build system generation filez would be freestyled n' then overwritten up in tha build tree n' could lead ta strange behavior. Shiiit, dis aint no joke.  CMake 2.6.4 n' above explicitly detect duplicate binary directories. Put ya muthafuckin choppers up if ya feel dis!  CMake 2.6.4 always considaz dis case a error. Shiiit, dis aint no joke.  In CMake 2.8.0 n' above dis policy determines whether or not tha case be a error. Shiiit, dis aint no joke.  Da OLD behavior fo' dis policy is ta allow duplicate binary directories. Put ya muthafuckin choppers up if ya feel dis!  Da NEW behavior fo' dis policy is ta disallow duplicate binary directories wit a error.


This policy was introduced up in CMake version 2.8.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0014
Input directories must have CMakeLists.txt.

CMake versions before 2.8 silently ignored missin CMakeLists.txt filez up in directories referenced by add_subdirectory() or subdirs(), treatin dem as if present but empty.  In CMake 2.8.0 n' above dis policy determines whether or not tha case be a error. Shiiit, dis aint no joke.  Da OLD behavior fo' dis policy is ta silently ignore tha problem.  Da NEW behavior fo' dis policy is ta report a error.


This policy was introduced up in CMake version 2.8.0.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0015
link_directories() treats paths relatizzle ta tha source dir.

In CMake 2.8.0 n' lower tha link_directories() command passed relatizzle paths unchanged ta tha linker n' shit.  In CMake 2.8.1 n' above tha link_directories() command prefers ta interpret relatizzle paths wit respect ta CMAKE_CURRENT_SOURCE_DIR, which is consistent wit include_directories() n' other commands.  Da OLD behavior fo' dis policy is ta use relatizzle paths verbatim up in tha linker command. Y'all KNOW dat shit, muthafucka!  Da NEW behavior fo' dis policy is ta convert relatizzle paths ta absolute paths by appendin tha relatizzle path ta CMAKE_CURRENT_SOURCE_DIR.


This policy was introduced up in CMake version 2.8.1.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0016
target_link_libraries() reports error if its only argument aint a target.

In CMake 2.8.2 n' lower tha target_link_libraries() command silently ignored if dat shiznit was called wit only one argument, n' dis argument wasn't a valid target. In CMake 2.8.3 n' above it reports a error up in dis case.


This policy was introduced up in CMake version 2.8.3.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0017
Prefer filez from tha CMake module directory when includin from there.

Startin wit CMake 2.8.4, if a cold-ass lil cmake\-module shipped wit CMake (i.e. located up in tha CMake module directory) calls include() or find_package(), tha filez located up in tha CMake module directory is preferred over tha filez up in CMAKE_MODULE_PATH.  This make shizzle dat tha modulez belongin ta CMake always git dem filez included which they expect, n' against which they was pimped n' tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In all other cases, tha filez found up in CMAKE_MODULE_PATH still take precedence over tha ones up in tha CMake module directory.  Da OLD behaviour is ta always prefer filez from CMAKE_MODULE_PATH over filez from tha CMake modulez directory.


This policy was introduced up in CMake version 2.8.4.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0018
Ignore CMAKE_SHARED_LIBRARY_<Lang>_FLAGS variable.

CMake 2.8.8 n' lower compiled sources up in SHARED n' MODULE libraries rockin tha value of tha undocumented CMAKE_SHARED_LIBRARY_<Lang>_FLAGS platform variable.  Da variable contained platform\-specific flags needed ta compile objects fo' shared libraries. Put ya muthafuckin choppers up if ya feel dis!  Typically it included a gangbangin' flag like fuckin \-fPIC fo' posizzle independent code but also included other flags needed on certain platforms.  CMake 2.8.9 n' higher prefer instead ta use tha POSITION_INDEPENDENT_CODE target property ta determine what tha fuck targets should be posizzle independent, n' freshly smoked up undocumented platform variablez ta select flags while ignorin CMAKE_SHARED_LIBRARY_<Lang>_FLAGS straight-up.


Da default fo' either approach produces identical compilation flags yo, but if a project modifies CMAKE_SHARED_LIBRARY_<Lang>_FLAGS from its original gangsta value dis policy determines which approach ta use.


Da OLD behavior fo' dis policy is ta ignore tha POSITION_INDEPENDENT_CODE property fo' all targets n' use tha modified value of CMAKE_SHARED_LIBRARY_<Lang>_FLAGS fo' SHARED n' MODULE libraries.


Da NEW behavior fo' dis policy is ta ignore CMAKE_SHARED_LIBRARY_<Lang>_FLAGS whether it is modified or not n' honor tha POSITION_INDEPENDENT_CODE target property.


This policy was introduced up in CMake version 2.8.9.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0019
Do not re\-expand variablez up in include n' link shiznit.

CMake 2.8.10 n' lower re\-evaluated joints given ta tha include_directories, link_directories, n' link_libraries commandz ta expand any leftover variable references all up in tha end of tha configuration step.  This was fo' strict compatibilitizzle wit VERY early CMake versions cuz all variable references is now normally evaluated durin CMake language processing.  CMake 2.8.11 n' higher prefer ta skip tha extra evaluation.


Da OLD behavior fo' dis policy is ta re\-evaluate tha joints fo' strict compatibility.  Da NEW behavior fo' dis policy is ta leave tha joints untouched.


This policy was introduced up in CMake version 2.8.11.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0020
Automatically link Qt executablez ta qtmain target on Windows.

CMake 2.8.10 n' lower required playaz of Qt ta always specify a link dependency ta tha qtmain.lib static library manually on Windows.  CMake 2.8.11 gained tha mobilitizzle ta evaluate generator expressions while determinin tha link dependencies from IMPORTED targets, n' you can put dat on yo' toast.  This allows CMake itself ta automatically link executablez which link ta Qt ta tha qtmain.lib library when rockin IMPORTED Qt targets, n' you can put dat on yo' toast.  For applications already linkin ta qtmain.lib, dis should have lil impact.  For applications which supply they own alternatizzle WinMain implementation n' fo' applications which use tha QAxServer library, dis automatic linkin will need ta be disabled as per tha documentation.


Da OLD behavior fo' dis policy aint ta link executablez ta qtmain.lib automatically when they link ta tha QtCore IMPORTEDtarget.  Da NEW behavior fo' dis policy is ta link executablez ta qtmain.lib automatically when they link ta QtCore IMPORTED target.


This policy was introduced up in CMake version 2.8.11.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0021
Fatal error on relatizzle paths up in INCLUDE_DIRECTORIES target property.

CMake 2.8.10.2 n' lower allowed tha INCLUDE_DIRECTORIES target property ta contain relatizzle paths.  Da base path fo' such relatizzle entries aint well defined. Y'all KNOW dat shit, muthafucka!  CMake 2.8.12 thangs a FATAL_ERROR if tha INCLUDE_DIRECTORIES property gotz nuff a relatizzle path.


Da OLD behavior fo' dis policy aint ta warn bout relatizzle paths up in tha INCLUDE_DIRECTORIES target property.  Da NEW behavior fo' dis policy is ta issue a FATAL_ERROR if INCLUDE_DIRECTORIES gotz nuff a relatizzle path.


This policy was introduced up in CMake version 2.8.12.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0022
INTERFACE_LINK_LIBRARIES defines tha link intercourse.

CMake 2.8.11 constructed tha 'link intercourse' of a target from propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?.  Da modern way ta specify config\-sensitizzle content is ta use generator expressions n' tha IMPORTED_ prefix make uniform processin of tha link intercourse wit generator expressions impossible.  Da INTERFACE_LINK_LIBRARIES target property was introduced as a replacement up in CMake 2.8.12. This freshly smoked up property is named consistently wit tha INTERFACE_COMPILE_DEFINITIONS, INTERFACE_INCLUDE_DIRECTORIES n' INTERFACE_COMPILE_OPTIONS properties. Put ya muthafuckin choppers up if ya feel dis!  For in\-build targets, CMake will use tha INTERFACE_LINK_LIBRARIES property as tha source of tha link intercourse only if policy CMP0022 is NEW.  When exportin a target which has dis policy set ta NEW, only tha INTERFACE_LINK_LIBRARIES property is ghon be processed n' generated fo' tha IMPORTED target by default.  A freshly smoked up option ta tha install(EXPORT) n' export commandz allows export of tha old\-style propertizzles fo' compatibilitizzle wit downstream playaz of CMake versions olda than 2.8.12.  Da target_link_libraries command will no longer populate tha propertizzles matchin LINK_INTERFACE_LIBRARIES(_<CONFIG>), biatch? if dis policy is NEW.


Da OLD behavior fo' dis policy is ta ignore tha INTERFACE_LINK_LIBRARIES property fo' in\-build targets, n' you can put dat on yo' toast.  Da NEW behavior fo' dis policy is ta use tha INTERFACE_LINK_LIBRARIES property fo' in\-build targets, n' ignore tha oldschool propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)?.


This policy was introduced up in CMake version 2.8.12.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.TP
.B CMP0023
Plain n' keyword target_link_libraries signatures cannot be mixed.

CMake 2.8.12 introduced tha target_link_libraries signature rockin tha PUBLIC, PRIVATE, n' INTERFACE keywordz ta generalize tha LINK_PUBLIC n' LINK_PRIVATE keywordz introduced up in CMake 2.8.7.  Use of signatures wit any of these keywordz sets tha link intercourse of a target explicitly, even if empty.  This produces confusin behavior when used up in combination wit tha oldschool behavior of tha plain target_link_libraries signature.  For example, consider tha code:


.nf
 target_link_libraries(mylib A)
 target_link_libraries(mylib PRIVATE B)
.fi

Afta tha straight-up original gangsta line tha link intercourse has not been set explicitly so CMake would use tha link implementation, A, as tha link intercourse.  But fuck dat shiznit yo, tha word on tha street is dat tha second line sets tha link intercourse ta empty.  In order ta avoid dis subtle behavior CMake now prefers ta disallow mixin tha plain n' keyword signaturez of target_link_libraries fo' a single target.


Da OLD behavior fo' dis policy is ta allow keyword n' plain target_link_libraries signatures ta be mixed. Y'all KNOW dat shit, muthafucka!  Da NEW behavior fo' dis policy is ta not ta allow mixin of tha keyword n' plain signatures.


This policy was introduced up in CMake version 2.8.12.  CMake version 2.8.12.2 warns when tha policy aint set n' uses OLD behavior. Shiiit, dis aint no joke.  Use tha cmake_policy command ta set it ta OLD or NEW explicitly.

.SH VARIABLES
.SH VARIABLES THAT CHANGE BEHAVIOR
.TP
.B BUILD_SHARED_LIBS
Global flag ta cause add_library ta create shared libraries if on.

If present n' true, dis will cause all libraries ta be built shared unless tha library was explicitly added as a static library.  This variable is often added ta projects as a OPTION so dat each user of a project can decizzle if they wanna build tha project rockin shared or static libraries.

.TP
.B CMAKE_ABSOLUTE_DESTINATION_FILES
List of filez which done been installed rockin  a ABSOLUTE DESTINATION path.

This variable is defined by CMake\-generated cmake_install.cmake scripts, n' you can put dat on yo' toast. Well shiiiit, it can be used (read\-only) by programs or scripts dat source dem install scripts, n' you can put dat on yo' toast. This is used by some CPack generators (e.g. RPM).

.TP
.B CMAKE_AUTOMOC_RELAXED_MODE
Switch between strict n' chillaxed automoc mode.

By default, automoc behaves exactly as busted lyrics bout up in tha documentation of tha AUTOMOC target property.  When set ta TRUE, it accepts mo' input n' tries ta find tha erect input file fo' moc even if it differs from tha documented behaviour. Shiiit, dis aint no joke.  In dis mode it e.g. also checks whether a header file is intended ta be processed by moc when a "foo.moc" file has been included.


Relaxed mode has ta be enabled fo' KDE4 compatibility.

.TP
.B CMAKE_BACKWARDS_COMPATIBILITY
Version of cmake required ta build project

From tha deal wit view of backwardz compatibility, dis specifies what tha fuck version of CMake should be supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default dis value is tha version number of CMake dat yo ass is hustlin. Yo ass can set dis ta a olda version of CMake ta support deprecated commandz of CMake up in projects dat was freestyled ta use olda versionz of CMake. This can be set by tha user or set all up in tha beginnin of a CMakeLists file.

.TP
.B CMAKE_BUILD_TYPE
Specifies tha build type on single\-configuration generators.

This statically specifies what tha fuck build type (configuration) is ghon be built up in dis build tree. Possible joints is empty, Debug, Release, RelWithDebInfo n' MinSizeRel.  This variable is only meaningful ta single\-configuration generators (like fuckin make n' Ninja) i.e. dem which chizzle a single configuration when CMake runs ta generate a funky-ass build tree as opposed ta multi\-configuration generators which offer selection of tha build configuration within tha generated build environment.  There is nuff per\-config propertizzles n' variablez (usually followin clean SOME_VAR_<CONFIG> order conventions), like fuckin CMAKE_C_FLAGS_<CONFIG>, specified as uppercase: CMAKE_C_FLAGS_[DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL].  For example, up in a funky-ass build tree configured ta build type Debug, CMake will peep ta havin CMAKE_C_FLAGS_DEBUG settings git added ta tha CMAKE_C_FLAGS settings.  See also CMAKE_CONFIGURATION_TYPES.

.TP
.B CMAKE_COLOR_MAKEFILE
Enablez color output when rockin tha Makefile generator.

When enabled, tha generated Makefilez will produce colored output.  Default is ON.

.TP
.B CMAKE_CONFIGURATION_TYPES
Specifies tha available build types on multi\-config generators.

This specifies what tha fuck build types (configurations) is ghon be available like fuckin Debug, Release, RelWithDebInfo etc.  This has reasonable defaults on most platforms yo, but can be extended ta provide other build types.  See also CMAKE_BUILD_TYPE fo' detailz of managin configuration data, n' CMAKE_CFG_INTDIR.

.TP
.B CMAKE_DEBUG_TARGET_PROPERTIES
Enablez tracin output fo' target properties.

This variable can be populated wit a list of propertizzles ta generate debug output fo' when evaluatin target properties. Put ya muthafuckin choppers up if ya feel dis!  Currently it can only be used when evaluatin tha INCLUDE_DIRECTORIES, COMPILE_DEFINITIONS n' COMPILE_OPTIONS target properties. Put ya muthafuckin choppers up if ya feel dis!  In dat case, it outputs a funky-ass backtrace fo' each entry up in tha target property.  Default is unset.

.TP
.B CMAKE_DISABLE_FIND_PACKAGE_<PackageName>
Variable fo' disablin find_package() calls.

Every non\-REQUIRED find_package() call up in a project can be disabled by settin tha variable CMAKE_DISABLE_FIND_PACKAGE_<PackageName> ta TRUE. This can be used ta build a project without a optionizzle package, although dat package is installed.


This switch should be used durin tha initial CMake run. I aint talkin' bout chicken n' gravy biatch. Otherwise if tha package has already been found up in a previous CMake run, tha variablez which done been stored up in tha cache will still be there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  In dat case it is recommended ta remove tha cache variablez fo' dis package from tha cache rockin tha cache editor or cmake \-U

.TP
.B CMAKE_ERROR_DEPRECATED
Whether ta issue deprecation errors fo' macros n' functions.

If TRUE, dis can be used by macros n' functions ta issue fatal errors when deprecated macros or functions is used. Y'all KNOW dat shit, muthafucka!  This variable is FALSE by default.

.TP
.B CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION
Ask cmake_install.cmake script ta error up as soon as a gangbangin' file wit absolute INSTALL DESTINATION is encountered.

Da fatal error is emitted before tha installation of tha offendin file takes place. This variable is used by CMake\-generated cmake_install.cmake scripts, n' you can put dat on yo' toast. If one sets dis variable ta ON while hustlin tha script, it may git fatal error lyrics from tha script.

.TP
.B CMAKE_FIND_LIBRARY_PREFIXES
Prefixes ta prepend when lookin fo' libraries.

This specifies what tha fuck prefixes ta add ta library names when tha find_library command looks fo' libraries. Put ya muthafuckin choppers up if ya feel dis! On UNIX systems dis is typically lib, meanin dat when tryin ta find tha foo library it will look fo' libfoo.

.TP
.B CMAKE_FIND_LIBRARY_SUFFIXES
Suffixes ta append when lookin fo' libraries.

This specifies what tha fuck suffixes ta add ta library names when tha find_library command looks fo' libraries. Put ya muthafuckin choppers up if ya feel dis! On Windows systems dis is typically .lib n' .dll, meanin dat when tryin ta find tha foo library it will look fo' foo.dll etc.

.TP
.B CMAKE_FIND_PACKAGE_WARN_NO_MODULE
Tell find_package ta warn if called without a explicit mode.

If find_package is called without a explicit mode option (MODULE, CONFIG or NO_MODULE) n' no Find<pkg>.cmake module is up in CMAKE_MODULE_PATH then CMake implicitly assumes dat tha calla intendz ta search fo' a package configuration file.  If no package configuration file is found then tha wordin of tha failure message must account fo' both tha case dat tha package is straight-up missin n' tha case dat tha project has a funky-ass bug n' failed ta provide tha intended Find module.  If instead tha calla specifies a explicit mode option then tha failure message can be mo' specific.


Set CMAKE_FIND_PACKAGE_WARN_NO_MODULE ta TRUE ta tell find_package ta warn when it implicitly assumes Config mode.  This helps pimpers enforce use of a explicit mode up in all calls ta find_package within a project.

.TP
.B CMAKE_IGNORE_PATH
Path ta be ignored by FIND_XXX() commands.

Specifies directories ta be ignored by searches up in FIND_XXX() commands.  This is useful up in cross\-compiled environments where some system directories contain incompatible but possibly linkable libraries. Put ya muthafuckin choppers up if ya feel dis! For example, on cross\-compiled clusta environments, dis allows a user ta ignore directories containin libraries meant fo' tha front\-end machine dat modulez like FindX11 (and others) would normally search.  By default dis is empty; it is intended ta be set by tha project.  Note dat CMAKE_IGNORE_PATH takes a list of directory names, NOT a list of prefixes. If you wanna ignore paths under prefixes (bin, include, lib, etc.), you gonna need ta specify dem explicitly.  See also CMAKE_PREFIX_PATH, CMAKE_LIBRARY_PATH, CMAKE_INCLUDE_PATH, CMAKE_PROGRAM_PATH.

.TP
.B CMAKE_INCLUDE_PATH
Path used fo' searchin by FIND_FILE() n' FIND_PATH().

Specifies a path which is ghon be used both by FIND_FILE() n' FIND_PATH(). Both commandz will check each of tha contained directories fo' tha existence of tha file which is currently searched. Y'all KNOW dat shit, muthafucka! By default it is empty, it is intended ta be set by tha project. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_INCLUDE_PATH, CMAKE_PREFIX_PATH.

.TP
.B CMAKE_INSTALL_DEFAULT_COMPONENT_NAME
Default component used up in install() commands.

If a install() command is used without tha COMPONENT argument, these filez is ghon be grouped tha fuck into a thugged-out default component. Da name of dis default install component is ghon be taken from dis variable.  It defaults ta "Unspecified".

.TP
.B CMAKE_INSTALL_PREFIX
Install directory used by install.

If "make install" is invoked or INSTALL is built, dis directory is prepended onto all install directories. Put ya muthafuckin choppers up if ya feel dis! This variable defaults ta /usr/local on UNIX n' c:/Program Filez on Windows.


On UNIX one can use tha DESTDIR mechanizzle up in order ta relocate tha whole installation. I aint talkin' bout chicken n' gravy biatch.  DESTDIR means DESTination DIRectory. Well shiiiit, it is commonly used by makefile playas up in order ta install software at non\-default location. I aint talkin' bout chicken n' gravy biatch.  It be probably invoked like this:


.nf
 make DESTDIR=/home/john install
.fi

which will install tha concerned software rockin tha installation prefix, e.g. "/usr/local" prepended wit tha DESTDIR value which finally gives "/home/john/usr/local".


WARNING: DESTDIR may not be used on Windows cuz installation prefix probably gotz nuff a thugged-out drive letta like up in "C:/Program Files" which cannot be prepended wit some other prefix.


Da installation prefix be also added ta CMAKE_SYSTEM_PREFIX_PATH so dat find_package, find_program, find_library, find_path, n' find_file will search tha prefix fo' other software.

.TP
.B CMAKE_LIBRARY_PATH
Path used fo' searchin by FIND_LIBRARY().

Specifies a path which is ghon be used by FIND_LIBRARY(). FIND_LIBRARY() will check each of tha contained directories fo' tha existence of tha library which is currently searched. Y'all KNOW dat shit, muthafucka! By default it is empty, it is intended ta be set by tha project. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_LIBRARY_PATH, CMAKE_PREFIX_PATH.

.TP
.B CMAKE_MFC_FLAG
Tell cmake ta use MFC fo' a executable or dll.

This can be set up in a CMakeLists.txt file n' will enable MFC up in tha application. I aint talkin' bout chicken n' gravy biatch.  It should be set ta 1 fo' tha static MFC library, n' 2 fo' tha shared MFC library.  This is used up in Visual Studio 6 n' 7 project files.   Da CMakeSetup dialog used MFC n' tha CMakeLists.txt be lookin like this:


.nf
  add_definitions(\-D_AFXDLL)
  set(CMAKE_MFC_FLAG 2)
  add_executable(CMakeSetup WIN32 ${SRCS})
.fi

.TP
.B CMAKE_MODULE_PATH
List of directories ta search fo' CMake modules.

Commandz like include() n' find_package() search fo' filez up in directories listed by dis variable before checkin tha default modulez dat come wit CMake.

.TP
.B CMAKE_NOT_USING_CONFIG_FLAGS
Skip _BUILD_TYPE flags if true.

This be a internal flag used by tha generators up in CMake ta tell CMake ta skip tha _BUILD_TYPE flags.

.TP
.B CMAKE_POLICY_DEFAULT_CMP<NNNN>
Default fo' CMake Policy CMP<NNNN> when it is otherwise left unset.

Commandz cmake_minimum_required(VERSION) n' cmake_policy(VERSION) by default leave policies introduced afta tha given version unset.  Set CMAKE_POLICY_DEFAULT_CMP<NNNN> ta OLD or NEW ta specify tha default fo' policy CMP<NNNN>, where <NNNN> is tha policy number.


This variable should not be set by a project up in CMake code; use cmake_policy(SET) instead. Y'all KNOW dat shit, muthafucka!  Users hustlin CMake may set dis variable up in tha cache (e.g. \-DCMAKE_POLICY_DEFAULT_CMP<NNNN>=<OLD|NEW>) ta set a policy not otherwise set by tha project.  Set ta OLD ta on tha down-low a policy warnin while rockin oldschool behavior or ta NEW ta try buildin tha project wit freshly smoked up behavior.

.TP
.B CMAKE_PREFIX_PATH
Path used fo' searchin by FIND_XXX(), wit appropriate suffixes added.

Specifies a path which is ghon be used by tha FIND_XXX() commands. Well shiiiit, it gotz nuff tha "base" directories, tha FIND_XXX() commandz append appropriate subdirectories ta tha base directories. Put ya muthafuckin choppers up if ya feel dis! Right back up in yo muthafuckin ass. So FIND_PROGRAM() addz /bin ta each of tha directories up in tha path, FIND_LIBRARY() appendz /lib ta each of tha directories, n' FIND_PATH() n' FIND_FILE() append /include . By default it is empty, it is intended ta be set by tha project. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_PREFIX_PATH, CMAKE_INCLUDE_PATH, CMAKE_LIBRARY_PATH, CMAKE_PROGRAM_PATH.

.TP
.B CMAKE_PROGRAM_PATH
Path used fo' searchin by FIND_PROGRAM().

Specifies a path which is ghon be used by FIND_PROGRAM(). FIND_PROGRAM() will check each of tha contained directories fo' tha existence of tha program which is currently searched. Y'all KNOW dat shit, muthafucka! By default it is empty, it is intended ta be set by tha project. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_PROGRAM_PATH,  CMAKE_PREFIX_PATH.

.TP
.B CMAKE_SKIP_INSTALL_ALL_DEPENDENCY
Don't make tha install target depend on tha all target.

By default, tha "install" target dependz on tha "all" target.  This has tha effect, dat when "make install" is invoked or INSTALL is built, first tha "all" target is built, then tha installation starts, n' you can put dat on yo' toast.  If CMAKE_SKIP_INSTALL_ALL_DEPENDENCY is set ta TRUE, dis dependency aint pimped, so tha installation process will start immediately, independent from whether tha project has been straight-up built or not.

.TP
.B CMAKE_SYSTEM_IGNORE_PATH
Path ta be ignored by FIND_XXX() commands.

Specifies directories ta be ignored by searches up in FIND_XXX() commands.  This is useful up in cross\-compiled environments where some system directories contain incompatible but possibly linkable libraries. Put ya muthafuckin choppers up if ya feel dis! For example, on cross\-compiled clusta environments, dis allows a user ta ignore directories containin libraries meant fo' tha front\-end machine dat modulez like FindX11 (and others) would normally search.  By default dis gotz nuff a list of directories containin incompatible binaries fo' tha host system.  See also CMAKE_SYSTEM_PREFIX_PATH, CMAKE_SYSTEM_LIBRARY_PATH, CMAKE_SYSTEM_INCLUDE_PATH, n' CMAKE_SYSTEM_PROGRAM_PATH.

.TP
.B CMAKE_SYSTEM_INCLUDE_PATH
Path used fo' searchin by FIND_FILE() n' FIND_PATH().

Specifies a path which is ghon be used both by FIND_FILE() n' FIND_PATH(). Both commandz will check each of tha contained directories fo' tha existence of tha file which is currently searched. Y'all KNOW dat shit, muthafucka! By default it gotz nuff tha standard directories fo' tha current system. Well shiiiit, it is NOT intended ta be modified by tha project, use CMAKE_INCLUDE_PATH fo' all dis bullshit. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_PREFIX_PATH.

.TP
.B CMAKE_SYSTEM_LIBRARY_PATH
Path used fo' searchin by FIND_LIBRARY().

Specifies a path which is ghon be used by FIND_LIBRARY(). FIND_LIBRARY() will check each of tha contained directories fo' tha existence of tha library which is currently searched. Y'all KNOW dat shit, muthafucka! By default it gotz nuff tha standard directories fo' tha current system. Well shiiiit, it is NOT intended ta be modified by tha project, use CMAKE_LIBRARY_PATH fo' all dis bullshit. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_PREFIX_PATH.

.TP
.B CMAKE_SYSTEM_PREFIX_PATH
Path used fo' searchin by FIND_XXX(), wit appropriate suffixes added.

Specifies a path which is ghon be used by tha FIND_XXX() commands. Well shiiiit, it gotz nuff tha "base" directories, tha FIND_XXX() commandz append appropriate subdirectories ta tha base directories. Put ya muthafuckin choppers up if ya feel dis! Right back up in yo muthafuckin ass. So FIND_PROGRAM() addz /bin ta each of tha directories up in tha path, FIND_LIBRARY() appendz /lib ta each of tha directories, n' FIND_PATH() n' FIND_FILE() append /include . By default dis gotz nuff tha standard directories fo' tha current system n' tha CMAKE_INSTALL_PREFIX.  It be NOT intended ta be modified by tha project, use CMAKE_PREFIX_PATH fo' all dis bullshit. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_INCLUDE_PATH, CMAKE_SYSTEM_LIBRARY_PATH, CMAKE_SYSTEM_PROGRAM_PATH, n' CMAKE_SYSTEM_IGNORE_PATH.

.TP
.B CMAKE_SYSTEM_PROGRAM_PATH
Path used fo' searchin by FIND_PROGRAM().

Specifies a path which is ghon be used by FIND_PROGRAM(). FIND_PROGRAM() will check each of tha contained directories fo' tha existence of tha program which is currently searched. Y'all KNOW dat shit, muthafucka! By default it gotz nuff tha standard directories fo' tha current system. Well shiiiit, it is NOT intended ta be modified by tha project, use CMAKE_PROGRAM_PATH fo' all dis bullshit. Right back up in yo muthafuckin ass. See also CMAKE_SYSTEM_PREFIX_PATH.

.TP
.B CMAKE_USER_MAKE_RULES_OVERRIDE
Specify a CMake file dat overrides platform shiznit.

CMake loadz tha specified file while enablin support fo' each language from either tha project() or enable_language() commands.  It be loaded afta CMakez builtin compila n' platform shiznit modulez done been loaded but before tha shiznit is used. Y'all KNOW dat shit, muthafucka!  Da file may set platform shiznit variablez ta override CMakez defaults.


This feature is intended fo' use only up in overridin shiznit variablez dat must be set before CMake buildz its first test project ta check dat tha compila fo' a language works.  It should not be used ta load a gangbangin' file up in cases dat a aiiight include() will work.  Use it only as a last resort fo' behavior dat cannot be  bigged up  any other way.  For example, one may set CMAKE_C_FLAGS_INIT ta chizzle tha default value used ta initialize CMAKE_C_FLAGS before it is cached. Y'all KNOW dat shit, muthafucka!  Da override file should NOT be used ta set anythang dat could be set afta languages is enabled, like fuckin variablez like CMAKE_RUNTIME_OUTPUT_DIRECTORY dat affect tha placement of binaries. Put ya muthafuckin choppers up if ya feel dis!  Hype set up in tha file is ghon be used fo' try_compile n' try_run buildz like a muthafucka.

.TP
.B CMAKE_WARN_DEPRECATED
Whether ta issue deprecation warnings fo' macros n' functions.

If TRUE, dis can be used by macros n' functions ta issue deprecation warnings.  This variable is FALSE by default.

.TP
.B CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION
Ask cmake_install.cmake script ta warn each time a gangbangin' file wit absolute INSTALL DESTINATION is encountered.

This variable is used by CMake\-generated cmake_install.cmake scripts, n' you can put dat on yo' toast. If one sets dis variable ta ON while hustlin tha script, it may git warnin lyrics from tha script.

.SH VARIABLES THAT DESCRIBE THE SYSTEM
.TP
.B APPLE
True if hustlin on Mac OS X.

Set ta legit on Mac OS X.

.TP
.B BORLAND
True if tha Borland compila is bein used.

This is set ta legit if tha Borland compila is bein used.

.TP
.B CMAKE_CL_64
Usin tha 64 bit compila from Microsoft

Set ta legit when rockin tha 64 bit cl compila from Microsoft.

.TP
.B CMAKE_COMPILER_2005
Usin tha Visual Studio 2005 compila from Microsoft

Set ta legit when rockin tha Visual Studio 2005 compila from Microsoft.

.TP
.B CMAKE_HOST_APPLE
True fo' Applez OS X operatin systems.

Set ta legit when tha host system is Applez OS X.

.TP
.B CMAKE_HOST_SYSTEM
Name of system cmake is bein run on.

Da same as CMAKE_SYSTEM but fo' tha host system instead of tha target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_NAME
Name of tha OS CMake is hustlin on.

Da same as CMAKE_SYSTEM_NAME but fo' tha host system instead of tha target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_PROCESSOR
Da name of tha CPU CMake is hustlin on.

Da same as CMAKE_SYSTEM_PROCESSOR but fo' tha host system instead of tha target system when cross compiling.

.TP
.B CMAKE_HOST_SYSTEM_VERSION
OS version CMake is hustlin on.

Da same as CMAKE_SYSTEM_VERSION but fo' tha host system instead of tha target system when cross compiling.

.TP
.B CMAKE_HOST_UNIX
True fo' UNIX n' UNIX like operatin systems.

Set ta legit when tha host system is UNIX or UNIX like (i.e fo' realz. APPLE n' CYGWIN).

.TP
.B CMAKE_HOST_WIN32
True on windows systems, includin win64.

Set ta legit when tha host system is Windows n' on Cygwin.

.TP
.B CMAKE_LIBRARY_ARCHITECTURE
Target architecture library directory name, if detected.

This is tha value of CMAKE_<lang>_LIBRARY_ARCHITECTURE as detected fo' one of tha enabled languages.

.TP
.B CMAKE_LIBRARY_ARCHITECTURE_REGEX
Regex matchin possible target architecture library directory names.

This is used ta detect CMAKE_<lang>_LIBRARY_ARCHITECTURE from tha implicit linker search path by matchin tha <arch> name.

.TP
.B CMAKE_OBJECT_PATH_MAX
Maximum object file full\-path length allowed by natizzle build tools.

CMake computes fo' every last muthafuckin source file a object file name dat is unique ta tha source file n' deterministic wit respect ta tha full path ta tha source file.  This allows multiple source filez up in a target ta share tha same name if they lie up in different directories without rebuildin when one be added or removed. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat it can produce long full paths up in all dem cases, so CMake shortens tha path rockin a hashin scheme when tha full path ta a object file exceedz a limit.  CMake has a funky-ass built\-in limit fo' each platform dat is sufficient fo' common tools yo, but some natizzle tools may gotz a lower limit.  This variable may be set ta specify tha limit explicitly.  Da value must be a integer no less than 128.

.TP
.B CMAKE_SYSTEM
Name of system cmake is compilin for.

This variable is tha composite of CMAKE_SYSTEM_NAME n' CMAKE_SYSTEM_VERSION, like dis ${CMAKE_SYSTEM_NAME}\-${CMAKE_SYSTEM_VERSION}.  If CMAKE_SYSTEM_VERSION aint set, then CMAKE_SYSTEM is tha same ol' dirty as CMAKE_SYSTEM_NAME.

.TP
.B CMAKE_SYSTEM_NAME
Name of tha OS CMake is buildin for.

This is tha name of tha operatin system on which CMake is targeting.   On systems dat have tha uname command, dis variable is set ta tha output of uname \-s.  Linux, Windows,  n' Darwin fo' Mac OS X is tha joints found  on tha big-ass three operatin systems.

.TP
.B CMAKE_SYSTEM_PROCESSOR
Da name of tha CPU CMake is buildin for.

On systems dat support uname, dis variable is set ta tha output of uname \-p, on windows it is set ta tha value of tha environment variable PROCESSOR_ARCHITECTURE

.TP
.B CMAKE_SYSTEM_VERSION
OS version CMake is buildin for.

A numeric version strang fo' tha system, on systems dat support uname, dis variable is set ta tha output of uname \-r. Shiiit, dis aint no joke. On other systems dis is set ta major\-minor version numbers.

.TP
.B CYGWIN
True fo' Cygwin.

Set ta legit when rockin Cygwin.

.TP
.B ENV
Access environment variables.

Use tha syntax $ENV{VAR} ta read environment variable VAR.  See also tha set() command ta set ENV{VAR}.

.TP
.B MSVC
True when rockin Microsizzlez Visual C

Set ta legit when tha compila is some version of Microsizzlez Visual C.

.TP
.B MSVC10
True when rockin Microsizzlez Visual C 10.0

Set ta legit when tha compila is version 10.0 of Microsizzlez Visual C.

.TP
.B MSVC11
True when rockin Microsizzlez Visual C 11.0

Set ta legit when tha compila is version 11.0 of Microsizzlez Visual C.

.TP
.B MSVC12
True when rockin Microsizzlez Visual C 12.0

Set ta legit when tha compila is version 12.0 of Microsizzlez Visual C.

.TP
.B MSVC60
True when rockin Microsizzlez Visual C 6.0

Set ta legit when tha compila is version 6.0 of Microsizzlez Visual C.

.TP
.B MSVC70
True when rockin Microsizzlez Visual C 7.0

Set ta legit when tha compila is version 7.0 of Microsizzlez Visual C.

.TP
.B MSVC71
True when rockin Microsizzlez Visual C 7.1

Set ta legit when tha compila is version 7.1 of Microsizzlez Visual C.

.TP
.B MSVC80
True when rockin Microsizzlez Visual C 8.0

Set ta legit when tha compila is version 8.0 of Microsizzlez Visual C.

.TP
.B MSVC90
True when rockin Microsizzlez Visual C 9.0

Set ta legit when tha compila is version 9.0 of Microsizzlez Visual C.

.TP
.B MSVC_IDE
True when rockin tha Microsizzlez Visual C IDE

Set ta legit when tha target platform is tha Microsizzlez Visual C IDE, as opposed ta tha command line compiler.

.TP
.B MSVC_VERSION
Da version of Microsizzlez Visual C/C++ bein used if any.

Known version numbers are:


.nf
  1200 = VS  6.0
  1300 = VS  7.0
  1310 = VS  7.1
  1400 = VS  8.0
  1500 = VS  9.0
  1600 = VS 10.0
  1700 = VS 11.0
  1800 = VS 12.0
.fi

.TP
.B UNIX
True fo' UNIX n' UNIX like operatin systems.

Set ta legit when tha target system is UNIX or UNIX like (i.e fo' realz. APPLE n' CYGWIN).

.TP
.B WIN32
True on windows systems, includin win64.

Set ta legit when tha target system is Windows.

.TP
.B XCODE_VERSION
Version of Xcode (Xcode generator only).

Under tha Xcode generator, dis is tha version of Xcode as specified up in "Xcode.app/Contents/version.plist" (like fuckin "3.1.2").

.SH VARIABLES FOR LANGUAGES
.TP
.B CMAKE_<LANG>_ARCHIVE_APPEND
Rule variable ta append ta a static archive.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta append ta a static archive.  It be used up in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms up in order ta support big-ass object counts, n' you can put dat on yo' toast.  See also CMAKE_<LANG>_ARCHIVE_CREATE n' CMAKE_<LANG>_ARCHIVE_FINISH.

.TP
.B CMAKE_<LANG>_ARCHIVE_CREATE
Rule variable ta create a freshly smoked up static archive.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta create a static archive.  It be used up in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms up in order ta support big-ass object counts, n' you can put dat on yo' toast.  See also CMAKE_<LANG>_ARCHIVE_APPEND n' CMAKE_<LANG>_ARCHIVE_FINISH.

.TP
.B CMAKE_<LANG>_ARCHIVE_FINISH
Rule variable ta finish a existin static archive.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta finish a static archive.  It be used up in place of CMAKE_<LANG>_CREATE_STATIC_LIBRARY on some platforms up in order ta support big-ass object counts, n' you can put dat on yo' toast.  See also CMAKE_<LANG>_ARCHIVE_CREATE n' CMAKE_<LANG>_ARCHIVE_APPEND.

.TP
.B CMAKE_<LANG>_COMPILER
Da full path ta tha compila fo' LANG.

This is tha command dat is ghon be used as tha <LANG> compila n' shit.  Once set, you can not chizzle dis variable.

.TP
.B CMAKE_<LANG>_COMPILER_ABI
An internal variable subject ta chizzle.

This is used up in determinin tha compila ABI n' is subject ta chizzle.

.TP
.B CMAKE_<LANG>_COMPILER_ID
Compila identification string.

A short strang unique ta tha compila vendor. Shiiit, dis aint no joke.  Possible joints include:


.nf
  Absoft = Absoft Fortran (absoft.com)
  ADSP = Analog VisualDSP++ (analog.com)
  Clang = LLVM Clang (clang.llvm.org)
  Cray = Cray Compila (cray.com)
  Embarcadero, Borland = Embarcadero (embarcadero.com)
  G95 = G95 Fortran (g95.org)
  GNU = GNU Compila Collection (gcc.gnu.org)
  HP = Hewlett\-Packard Compila (hp.com)
  Intel = Intel Compila (intel.com)
  MIPSpro = SGI MIPSpro (sgi.com)
  MSVC = Microsizzlez Visual Studio (microsoft.com)
  PGI = Da Portland Group (pgroup.com)
  PathScale = PathScale (pathscale.com)
  SDCC = Lil Small-Ass Device C Compila (sdcc.sourceforge.net)
  SunPro = Oracle Solaris Studio (oracle.com)
  TI = Texas Instruments (ti.com)
  TinyCC = Tiny C Compila (tinycc.org)
  Watcom = Open Watcom (openwatcom.org)
  XL, VisualAge, zOS = IBM XL (ibm.com)
.fi

This variable aint guaranteed ta be defined fo' all compilaz or languages.

.TP
.B CMAKE_<LANG>_COMPILER_LOADED
Defined ta legit if tha language is enabled.

When language <LANG> is enabled by project() or enable_language() dis variable is defined ta 1.

.TP
.B CMAKE_<LANG>_COMPILER_VERSION
Compila version string.

Compila version up in major[.minor[.patch[.tweak]]] format.  This variable aint guaranteed ta be defined fo' all compilaz or languages.

.TP
.B CMAKE_<LANG>_COMPILE_OBJECT
Rule variable ta compile a single object file.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta compile a single object file fo' tha language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_SHARED_LIBRARY
Rule variable ta create a gangbangin' finger-lickin' dirty-ass shared library.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta create a gangbangin' finger-lickin' dirty-ass shared library fo' tha language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_SHARED_MODULE
Rule variable ta create a gangbangin' finger-lickin' dirty-ass shared module.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta create a gangbangin' finger-lickin' dirty-ass shared library fo' tha language <LANG>.

.TP
.B CMAKE_<LANG>_CREATE_STATIC_LIBRARY
Rule variable ta create a static library.

This be a rule variable dat  drops some lyrics ta CMake how tha fuck ta create a static library fo' tha language <LANG>.

.TP
.B CMAKE_<LANG>_FLAGS
Flags fo' all build types.

<LANG> flags used regardless of tha value of CMAKE_BUILD_TYPE.

.TP
.B CMAKE_<LANG>_FLAGS_DEBUG
Flags fo' Debug build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is Debug.

.TP
.B CMAKE_<LANG>_FLAGS_MINSIZEREL
Flags fo' MinSizeRel build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is MinSizeRel.Short fo' minimum size release.

.TP
.B CMAKE_<LANG>_FLAGS_RELEASE
Flags fo' Release build type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is Release

.TP
.B CMAKE_<LANG>_FLAGS_RELWITHDEBINFO
Flags fo' RelWithDebInfo type or configuration.

<LANG> flags used when CMAKE_BUILD_TYPE is RelWithDebInfo.  Short fo' Release With Debug Information.

.TP
.B CMAKE_<LANG>_IGNORE_EXTENSIONS
File extensions dat should be ignored by tha build.

This be a list of file extensions dat may be part of a project fo' a given language but is not compiled.

.TP
.B CMAKE_<LANG>_IMPLICIT_INCLUDE_DIRECTORIES
Directories implicitly searched by tha compila fo' header files.

CMake do not explicitly specify these directories on compila command lines fo' language <LANG>.  This prevents system include directories from bein treated as user include directories on some compilers.

.TP
.B CMAKE_<LANG>_IMPLICIT_LINK_DIRECTORIES
Implicit linker search path detected fo' language <LANG>.

Compilaz typically pass directories containin language runtime libraries n' default library search paths when they invoke a linker n' shit.  These paths is implicit linker search directories fo' tha compilerz language.  CMake automatically detects these directories fo' each language n' reports tha thangs up in dis biatch up in dis variable.


When a library up in one of these directories is given by full path ta target_link_libraries() CMake will generate tha \-l<name> form on link lines ta ensure tha linker searches its implicit directories fo' tha library.  Note dat some toolchains read implicit directories from a environment variable like fuckin LIBRARY_PATH so keep its value consistent when operatin up in a given build tree.

.TP
.B CMAKE_<LANG>_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES
Implicit linker framework search path detected fo' language <LANG>.

These paths is implicit linker framework search directories fo' tha compilerz language.  CMake automatically detects these directories fo' each language n' reports tha thangs up in dis biatch up in dis variable.

.TP
.B CMAKE_<LANG>_IMPLICIT_LINK_LIBRARIES
Implicit link libraries n' flags detected fo' language <LANG>.

Compilaz typically pass language runtime library names n' other flags when they invoke a linker n' shit.  These flags is implicit link options fo' tha compilerz language.  CMake automatically detects these libraries n' flags fo' each language n' reports tha thangs up in dis biatch up in dis variable.

.TP
.B CMAKE_<LANG>_LIBRARY_ARCHITECTURE
Target architecture library directory name detected fo' <lang>.

If tha <lang> compila passes ta tha linker a architecture\-specific system library search directory like fuckin <prefix>/lib/<arch> dis variable gotz nuff tha <arch> name if/as detected by CMake.

.TP
.B CMAKE_<LANG>_LINKER_PREFERENCE
Preference value fo' linker language selection.

Da "linker language" fo' executable, shared library, n' module targets is tha language whose compila will invoke tha linker n' shit.  Da LINKER_LANGUAGE target property sets tha language explicitly.  Otherwise, tha linker language is dat whose linker preference value is highest among languages compiled n' linked tha fuck into tha target.  See also tha CMAKE_<LANG>_LINKER_PREFERENCE_PROPAGATES variable.

.TP
.B CMAKE_<LANG>_LINKER_PREFERENCE_PROPAGATES
True if CMAKE_<LANG>_LINKER_PREFERENCE propagates across targets.

This is used when CMake selects a linker language fo' a target.  Languages compiled directly tha fuck into tha target is always considered. Y'all KNOW dat shit, muthafucka!  A language compiled tha fuck into static libraries linked by tha target is considered if dis variable is true.

.TP
.B CMAKE_<LANG>_LINK_EXECUTABLE 
Rule variable ta link a executable.

Rule variable ta link a executable fo' tha given language.

.TP
.B CMAKE_<LANG>_OUTPUT_EXTENSION
Extension fo' tha output of a cold-ass lil compile fo' a single file.

This is tha extension fo' a object file fo' tha given <LANG>. For example .obj fo' C on Windows.

.TP
.B CMAKE_<LANG>_PLATFORM_ID
An internal variable subject ta chizzle.

This is used up in determinin tha platform n' is subject ta chizzle.

.TP
.B CMAKE_<LANG>_SIZEOF_DATA_PTR
Size of pointer\-to\-data types fo' language <LANG>.

This holdz tha size (in bytes) of pointer\-to\-data types up in tha target platform ABI.  It be defined fo' languages C n' CXX (C++).

.TP
.B CMAKE_<LANG>_SOURCE_FILE_EXTENSIONS
Extensionz of source filez fo' tha given language.

This is tha list of extensions fo' a given languagez source files.

.TP
.B CMAKE_COMPILER_IS_GNU<LANG>
True if tha compila is GNU.

If tha selected <LANG> compila is tha GNU compila then dis is TRUE, if not it is FALSE.  Unlike tha other per\-language variables, dis uses tha GNU syntax fo' identifyin languages instead of tha CMake syntax. Recognized jointz of tha <LANG> suffix are:


.nf
  CC = C compiler
  CXX = C++ compiler
  G77 = Fortran compiler
.fi

.TP
.B CMAKE_Fortran_MODDIR_DEFAULT
Fortran default module output directory.

Most Fortran compilaz write .mod filez ta tha current hustlin directory.  For dem dat do not, dis is set ta "." n' used when tha Fortran_MODULE_DIRECTORY target property aint set.

.TP
.B CMAKE_Fortran_MODDIR_FLAG
Fortran flag fo' module output directory.

This stores tha flag needed ta pass tha value of tha Fortran_MODULE_DIRECTORY target property ta tha compiler.

.TP
.B CMAKE_Fortran_MODOUT_FLAG
Fortran flag ta enable module output.

Most Fortran compilaz write .mod filez up by default.  For others, dis stores tha flag needed ta enable module output.

.TP
.B CMAKE_INTERNAL_PLATFORM_ABI
An internal variable subject ta chizzle.

This is used up in determinin tha compila ABI n' is subject ta chizzle.

.TP
.B CMAKE_USER_MAKE_RULES_OVERRIDE_<LANG>
Specify a CMake file dat overrides platform shiznit fo' <LANG>.

This be a language\-specific version of CMAKE_USER_MAKE_RULES_OVERRIDE loaded only when enablin language <LANG>.

.SH VARIABLES THAT CONTROL THE BUILD
.TP
.B CMAKE_<CONFIG>_POSTFIX
Default filename postfix fo' libraries under configuration <CONFIG>.

When a non\-executable target is pimped its <CONFIG>_POSTFIX target property is initialized wit tha value of dis variable if it is set.

.TP
.B CMAKE_<LANG>_VISIBILITY_PRESET
Default value fo' <LANG>_VISIBILITY_PRESET of targets.

This variable is used ta initialize tha <LANG>_VISIBILITY_PRESET property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_ARCHIVE_OUTPUT_DIRECTORY
Where ta put all tha ARCHIVE targets when built.

This variable is used ta initialize tha ARCHIVE_OUTPUT_DIRECTORY property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_AUTOMOC
Whether ta handle moc automatically fo' Qt targets.

This variable is used ta initialize tha AUTOMOC property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_AUTOMOC_MOC_OPTIONS
Additionizzle options fo' moc when rockin automoc (see CMAKE_AUTOMOC).

This variable is used ta initialize tha AUTOMOC_MOC_OPTIONS property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_BUILD_WITH_INSTALL_RPATH
Use tha install path fo' tha RPATH

Normally CMake uses tha build tree fo' tha RPATH when buildin executablez etc on systems dat use RPATH. When tha software is installed tha executablez etc is relinked by CMake ta have tha install RPATH. If dis variable is set ta legit then tha software be always built wit tha install path fo' tha RPATH n' do not need ta be relinked when installed.

.TP
.B CMAKE_DEBUG_POSTFIX
See variable CMAKE_<CONFIG>_POSTFIX.

This variable be a special case of tha more\-general CMAKE_<CONFIG>_POSTFIX variable fo' tha DEBUG configuration.

.TP
.B CMAKE_EXE_LINKER_FLAGS
Linker flags ta be used ta create executables.

These flags is ghon be used by tha linker when bustin a executable.

.TP
.B CMAKE_EXE_LINKER_FLAGS_<CONFIG>
Flags ta be used when linkin a executable.

Same as CMAKE_C_FLAGS_* but used by tha linker when bustin executables.

.TP
.B CMAKE_Fortran_FORMAT
Set ta FIXED or FREE ta indicate tha Fortran source layout.

This variable is used ta initialize tha Fortran_FORMAT property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_Fortran_MODULE_DIRECTORY
Fortran module output directory.

This variable is used ta initialize tha Fortran_MODULE_DIRECTORY property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_GNUtoMS
Convert GNU import libraries (.dll.a) ta MS format (.lib).

This variable is used ta initialize tha GNUtoMS property on targets when they is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_INCLUDE_CURRENT_DIR
Automatically add tha current source\- n' build directories ta tha include path.

If dis variable is enabled, CMake automatically addz up in each directory ${CMAKE_CURRENT_SOURCE_DIR} n' ${CMAKE_CURRENT_BINARY_DIR} ta tha include path fo' dis directory. These additionizzle include directories do not propagate down ta subdirectories. Put ya muthafuckin choppers up if ya feel dis! This is useful mainly fo' out\-of\-source builds, where filez generated tha fuck into tha build tree is included by filez located up in tha source tree.


By default CMAKE_INCLUDE_CURRENT_DIR is OFF.

.TP
.B CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE
Automatically add tha current source\- n' build directories ta tha INTERFACE_INCLUDE_DIRECTORIES.

If dis variable is enabled, CMake automatically addz fo' each shared library target, static library target, module target n' executable target, ${CMAKE_CURRENT_SOURCE_DIR} n' ${CMAKE_CURRENT_BINARY_DIR} ta tha INTERFACE_INCLUDE_DIRECTORIES.By default CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE is OFF.

.TP
.B CMAKE_INSTALL_NAME_DIR
Mac OS X directory name fo' installed targets.

CMAKE_INSTALL_NAME_DIR is used ta initialize tha INSTALL_NAME_DIR property on all targets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See dat target property fo' mo' shiznit.

.TP
.B CMAKE_INSTALL_RPATH
Da rpath ta use fo' installed targets.

A semicolon\-separated list specifyin tha rpath ta use up in installed targets (for platforms dat support it).  This is used ta initialize tha target property INSTALL_RPATH fo' all targets.

.TP
.B CMAKE_INSTALL_RPATH_USE_LINK_PATH
Add paths ta linker search n' installed rpath.

CMAKE_INSTALL_RPATH_USE_LINK_PATH be a funky-ass boolean dat if set ta legit will append directories up in tha linker search path n' outside tha project ta tha INSTALL_RPATH.  This is used ta initialize tha target property INSTALL_RPATH_USE_LINK_PATH fo' all targets.

.TP
.B CMAKE_LIBRARY_OUTPUT_DIRECTORY
Where ta put all tha LIBRARY targets when built.

This variable is used ta initialize tha LIBRARY_OUTPUT_DIRECTORY property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_LIBRARY_PATH_FLAG
Da flag ta be used ta add a library search path ta a cold-ass lil compiler.

Da flag is ghon be used ta specify a library directory ta tha compila n' shit.  On most compilaz dis is "\-L".

.TP
.B CMAKE_LINK_DEF_FILE_FLAG  
Linker flag ta be used ta specify a .def file fo' dll creation.

Da flag is ghon be used ta add a .def file when bustin a thugged-out dll on Windows; dis is only defined on Windows.

.TP
.B CMAKE_LINK_DEPENDS_NO_SHARED
Whether ta skip link dependencies on shared library files.

This variable initializes tha LINK_DEPENDS_NO_SHARED property on targets when they is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_LINK_INTERFACE_LIBRARIES
Default value fo' LINK_INTERFACE_LIBRARIES of targets.

This variable is used ta initialize tha LINK_INTERFACE_LIBRARIES property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_LINK_LIBRARY_FILE_FLAG
Flag ta be used ta link a library specified by a path ta its file.

Da flag is ghon be used before a library file path is given ta tha linker n' shit.  This is needed only on straight-up few platforms.

.TP
.B CMAKE_LINK_LIBRARY_FLAG
Flag ta be used ta link a library tha fuck into a executable.

Da flag is ghon be used ta specify a library ta link ta a executable.  On most compilaz dis is "\-l".

.TP
.B CMAKE_MACOSX_BUNDLE
Default value fo' MACOSX_BUNDLE of targets.

This variable is used ta initialize tha MACOSX_BUNDLE property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_MODULE_LINKER_FLAGS
Linker flags ta be used ta create modules.

These flags is ghon be used by tha linker when bustin a module.

.TP
.B CMAKE_MODULE_LINKER_FLAGS_<CONFIG>
Flags ta be used when linkin a module.

Same as CMAKE_C_FLAGS_* but used by tha linker when bustin modules.

.TP
.B CMAKE_NO_BUILTIN_CHRPATH
Do not use tha builtin ELF editor ta fix RPATHs on installation.

When a ELF binary need ta gotz a gangbangin' finger-lickin' different RPATH afta installation than it do up in tha build tree, CMake uses a funky-ass builtin editor ta chizzle tha RPATH up in tha installed copy.  If dis variable is set ta legit then CMake will relink tha binary before installation instead of rockin its builtin editor.

.TP
.B CMAKE_PDB_OUTPUT_DIRECTORY
Where ta put all tha MS debug symbol filez from linker.

This variable is used ta initialize tha PDB_OUTPUT_DIRECTORY property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_POSITION_INDEPENDENT_CODE
Default value fo' POSITION_INDEPENDENT_CODE of targets.

This variable is used ta initialize tha POSITION_INDEPENDENT_CODE property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_RUNTIME_OUTPUT_DIRECTORY
Where ta put all tha RUNTIME targets when built.

This variable is used ta initialize tha RUNTIME_OUTPUT_DIRECTORY property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_SHARED_LINKER_FLAGS
Linker flags ta be used ta create shared libraries.

These flags is ghon be used by tha linker when bustin a gangbangin' finger-lickin' dirty-ass shared library.

.TP
.B CMAKE_SHARED_LINKER_FLAGS_<CONFIG>
Flags ta be used when linkin a gangbangin' finger-lickin' dirty-ass shared library.

Same as CMAKE_C_FLAGS_* but used by tha linker when bustin shared libraries.

.TP
.B CMAKE_SKIP_BUILD_RPATH
Do not include RPATHs up in tha build tree.

Normally CMake uses tha build tree fo' tha RPATH when buildin executablez etc on systems dat use RPATH. When tha software is installed tha executablez etc is relinked by CMake ta have tha install RPATH. If dis variable is set ta legit then tha software be always built wit no RPATH.

.TP
.B CMAKE_SKIP_INSTALL_RPATH
Do not include RPATHs up in tha install tree.

Normally CMake uses tha build tree fo' tha RPATH when buildin executablez etc on systems dat use RPATH. When tha software is installed tha executablez etc is relinked by CMake ta have tha install RPATH. If dis variable is set ta legit then tha software be always installed without RPATH, even if RPATH is enabled when building.  This can be useful fo' example ta allow hustlin tests from tha build directory wit RPATH enabled before tha installation step.  To omit RPATH up in both tha build n' install steps, use CMAKE_SKIP_RPATH instead.

.TP
.B CMAKE_STATIC_LINKER_FLAGS
Linker flags ta be used ta create static libraries.

These flags is ghon be used by tha linker when bustin a static library.

.TP
.B CMAKE_STATIC_LINKER_FLAGS_<CONFIG>
Flags ta be used when linkin a static library.

Same as CMAKE_C_FLAGS_* but used by tha linker when bustin static libraries.

.TP
.B CMAKE_TRY_COMPILE_CONFIGURATION
Build configuration used fo' try_compile n' try_run projects.

Projects built by try_compile n' try_run is built synchronously durin tha CMake configuration step.  Therefore a specific build configuration must be chosen even if tha generated build system supports multiple configurations.

.TP
.B CMAKE_USE_RELATIVE_PATHS
Use relatizzle paths (May not work!).

If dis is set ta TRUE, then CMake will use relatizzle paths between tha source n' binary tree.  This option do not work fo' mo' fucked up projects, n' relatizzle paths is used when possible.  In general, it aint possible ta move CMake generated makefilez ta a gangbangin' finger-lickin' different location regardless of tha value of dis variable.

.TP
.B CMAKE_VISIBILITY_INLINES_HIDDEN
Default value fo' VISIBILITY_INLINES_HIDDEN of targets.

This variable is used ta initialize tha VISIBILITY_INLINES_HIDDEN property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B CMAKE_WIN32_EXECUTABLE
Default value fo' WIN32_EXECUTABLE of targets.

This variable is used ta initialize tha WIN32_EXECUTABLE property on all tha targets, n' you can put dat on yo' toast.  See dat target property fo' additionizzle shiznit.

.TP
.B EXECUTABLE_OUTPUT_PATH
Oldskool executable location variable.

Da target property RUNTIME_OUTPUT_DIRECTORY supercedes dis variable fo' a target if it is set.  Executable targets is otherwise placed up in dis directory.

.TP
.B LIBRARY_OUTPUT_PATH
Oldskool library location variable.

Da target propertizzles ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, n' RUNTIME_OUTPUT_DIRECTORY supercede dis variable fo' a target if they is set.  Library targets is otherwise placed up in dis directory.

.SH VARIABLES THAT PROVIDE INFORMATION
.PP
variablez defined by cmake, dat give shiznit bout tha project, n' cmake

.TP
.B CMAKE_AR
Name of archivin tool fo' static libraries.

This specifies tha name of tha program dat creates archive or static libraries.

.TP
.B CMAKE_ARGC
Number of command line arguments passed ta CMake up in script mode.

When run up in \-P script mode, CMake sets dis variable ta tha number of command line arguments, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See also CMAKE_ARGV0, 1, 2 ...

.TP
.B CMAKE_ARGV0
Command line argument passed ta CMake up in script mode.

When run up in \-P script mode, CMake sets dis variable ta tha straight-up original gangsta command line argument. Well shiiiit, it then also sets CMAKE_ARGV1, CMAKE_ARGV2, ... n' so on, up ta tha number of command line arguments given. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See also CMAKE_ARGC.

.TP
.B CMAKE_BINARY_DIR
Da path ta tha top level of tha build tree.

This is tha full path ta tha top level of tha current CMake build tree. For a in\-source build, dis would be tha same as CMAKE_SOURCE_DIR.

.TP
.B CMAKE_BUILD_TOOL
Tool used fo' tha actual build process.

This variable is set ta tha program dat is ghon be needed ta build tha output of CMake.   If tha generator selected was Visual Studio 6, tha CMAKE_BUILD_TOOL is ghon be set ta msdev, fo' Unix Makefilez it is ghon be set ta make or gmake, n' fo' Visual Studio 7 it set ta devenv.  For NMake Makefilez tha value is nmake. This can be useful fo' addin special flags n' commandz based on tha final build environment.

.TP
.B CMAKE_CACHEFILE_DIR
Da directory wit tha CMakeCache.txt file.

This is tha full path ta tha directory dat has tha CMakeCache.txt file up in dat shit.  This is tha same ol' dirty as CMAKE_BINARY_DIR.

.TP
.B CMAKE_CACHE_MAJOR_VERSION
Major version of CMake used ta create tha CMakeCache.txt file

This stores tha major version of CMake used ta write a CMake cache file. Well shiiiit, it is only different when a gangbangin' finger-lickin' different version of CMake is run on a previously pimped cache file.

.TP
.B CMAKE_CACHE_MINOR_VERSION
Minor version of CMake used ta create tha CMakeCache.txt file

This stores tha minor version of CMake used ta write a CMake cache file. Well shiiiit, it is only different when a gangbangin' finger-lickin' different version of CMake is run on a previously pimped cache file.

.TP
.B CMAKE_CACHE_PATCH_VERSION
Patch version of CMake used ta create tha CMakeCache.txt file

This stores tha patch version of CMake used ta write a CMake cache file. Well shiiiit, it is only different when a gangbangin' finger-lickin' different version of CMake is run on a previously pimped cache file.

.TP
.B CMAKE_CFG_INTDIR
Build\-time reference ta per\-configuration output subdirectory.

For natizzle build systems supportin multiple configurations up in tha build tree (like fuckin Visual Studio n' Xcode), tha value be a reference ta a funky-ass build\-time variable specifyin tha name of tha per\-configuration output subdirectory.  On Makefile generators dis evaluates ta "." cuz there is only one configuration up in a funky-ass build tree.  Example joints:


.nf
  $(IntDir)        = Visual Studio 6
  $(OutDir)        = Visual Studio 7, 8, 9
  $(Configuration) = Visual Studio 10
  $(CONFIGURATION) = Xcode
  .                = Make\-based tools
.fi

Since these joints is evaluated by tha natizzle build system, dis variable is suitable only fo' use up in command lines dat is ghon be evaluated at build time.  Example of intended usage:


.nf
  add_executable(mytool mytool.c)
  add_custom_command(
    OUTPUT out.txt
    COMMAND ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/mytool
            ${CMAKE_CURRENT_SOURCE_DIR}/in.txt out.txt
    DEPENDS mytool in.txt
    )
  add_custom_target(drive ALL DEPENDS out.txt)
.fi

Note dat CMAKE_CFG_INTDIR is no longer necessary fo' dis purpose but has been left fo' compatibilitizzle wit existin projects, n' you can put dat on yo' toast.  Instead add_custom_command() recognizes executable target names up in its COMMAND option, so "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/mytool" can be replaced by just "mytool".


This variable is read\-only.  Settin it is undefined behavior. Shiiit, dis aint no joke.  In multi\-configuration build systems tha value of dis variable is passed as tha value of preprocessor symbol "CMAKE_INTDIR" ta tha compilation of all source files.

.TP
.B CMAKE_COMMAND
Da full path ta tha cmake executable.

This is tha full path ta tha CMake executable cmake which is useful from custom commandz dat wanna use tha cmake \-E option fo' portable system commands.  (e.g. /usr/local/bin/cmake

.TP
.B CMAKE_CROSSCOMPILING
Is CMake currently cross compiling.

This variable is ghon be set ta legit by CMake if CMake is cross compiling. Right back up in yo muthafuckin ass. Specifically if tha build platform is different from tha target platform.

.TP
.B CMAKE_CTEST_COMMAND
Full path ta ctest command installed wit cmake.

This is tha full path ta tha CTest executable ctest which is useful from custom commandz dat wanna use tha cmake \-E option fo' portable system commands.

.TP
.B CMAKE_CURRENT_BINARY_DIR
Da path ta tha binary directory currently bein processed.

This tha full path ta tha build directory dat is currently bein processed by cmake.  Each directory added by add_subdirectory will create a funky-ass binary directory up in tha build tree, n' as it is bein processed dis variable is ghon be set.  For in\-source buildz dis is tha current source directory bein processed.

.TP
.B CMAKE_CURRENT_LIST_DIR
Full directory of tha listfile currently bein processed.

As CMake processes tha listfilez up in yo' project dis variable will always be set ta tha directory where tha listfile which is currently bein processed (CMAKE_CURRENT_LIST_FILE) is located. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da value has dynamic scope.  When CMake starts processin commandz up in a source file it sets dis variable ta tha directory where dis file is located. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When CMake finishes processin commandz from tha file it restores tha previous value.  Therefore tha value of tha variable inside a macro or function is tha directory of tha file invokin tha bottom\-most entry on tha call stack, not tha directory of tha file containin tha macro or function definition.


See also CMAKE_CURRENT_LIST_FILE.

.TP
.B CMAKE_CURRENT_LIST_FILE
Full path ta tha listfile currently bein processed.

As CMake processes tha listfilez up in yo' project dis variable will always be set ta tha one currently bein processed. Y'all KNOW dat shit, muthafucka!  Da value has dynamic scope.  When CMake starts processin commandz up in a source file it sets dis variable ta tha location of tha file.  When CMake finishes processin commandz from tha file it restores tha previous value.  Therefore tha value of tha variable inside a macro or function is tha file invokin tha bottom\-most entry on tha call stack, not tha file containin tha macro or function definition.


See also CMAKE_PARENT_LIST_FILE.

.TP
.B CMAKE_CURRENT_LIST_LINE
Da line number of tha current file bein processed.

This is tha line number of tha file currently bein processed by cmake.

.TP
.B CMAKE_CURRENT_SOURCE_DIR
Da path ta tha source directory currently bein processed.

This tha full path ta tha source directory dat is currently bein processed by cmake.  

.TP
.B CMAKE_DL_LIBS
Name of library containin dlopen n' dlcose.

Da name of tha library dat has dlopen n' dlclose up in it, probably \-ldl on most UNIX machines.

.TP
.B CMAKE_EDIT_COMMAND
Full path ta cmake\-gui or ccmake.

This is tha full path ta tha CMake executable dat can graphically edit tha cache.  For example, cmake\-gui, ccmake, or cmake \-i.

.TP
.B CMAKE_EXECUTABLE_SUFFIX
Da suffix fo' executablez on dis platform.

Da suffix ta use fo' tha end of a executable filename if any, .exe on Windows.


CMAKE_EXECUTABLE_SUFFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_EXTRA_GENERATOR
Da extra generator used ta build tha project.

When rockin tha Eclipse, CodeBlocks or KDevelop generators, CMake generates Makefilez (CMAKE_GENERATOR) n' additionally project filez fo' tha respectizzle IDE. This IDE project file generator is stored up in CMAKE_EXTRA_GENERATOR (e.g. "Eclipse CDT4").

.TP
.B CMAKE_EXTRA_SHARED_LIBRARY_SUFFIXES
Additionizzle suffixes fo' shared libraries.

Extensions fo' shared libraries other than dat specified by CMAKE_SHARED_LIBRARY_SUFFIX, if any.  CMake uses dis ta recognize external shared library filez durin analysiz of libraries linked by a target.

.TP
.B CMAKE_GENERATOR
Da generator used ta build tha project.

Da name of tha generator dat is bein used ta generate tha build files.  (e.g. "Unix Makefiles", "Visual Studio 6", etc.)

.TP
.B CMAKE_GENERATOR_TOOLSET
Natizzle build system toolset name specified by user.

Some CMake generators support a toolset name ta be given ta tha natizzle build system ta chizzle a cold-ass lil compila n' shit.  If tha user specifies a toolset name (e.g. via tha cmake \-T option) tha value is ghon be available up in dis variable.

.TP
.B CMAKE_HOME_DIRECTORY
Path ta top of source tree.

This is tha path ta tha top level of tha source tree.

.TP
.B CMAKE_IMPORT_LIBRARY_PREFIX
Da prefix fo' import libraries dat you link to.

Da prefix ta use fo' tha name of a import library if used on dis platform.


CMAKE_IMPORT_LIBRARY_PREFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_IMPORT_LIBRARY_SUFFIX
Da suffix fo' import libraries dat you link to.

Da suffix ta use fo' tha end of a import library filename if used on dis platform.


CMAKE_IMPORT_LIBRARY_SUFFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_LINK_LIBRARY_SUFFIX
Da suffix fo' libraries dat you link to.

Da suffix ta use fo' tha end of a library filename, .lib on Windows.

.TP
.B CMAKE_MAJOR_VERSION
Da Major version of cmake (i.e. tha 2 up in 2.X.X)

This specifies tha major version of tha CMake executable bein run.

.TP
.B CMAKE_MAKE_PROGRAM
See CMAKE_BUILD_TOOL.

This variable is round fo' backwardz compatibility, peep CMAKE_BUILD_TOOL.

.TP
.B CMAKE_MINIMUM_REQUIRED_VERSION
Version specified ta cmake_minimum_required command

Variable containin tha VERSION component specified up in tha cmake_minimum_required command.

.TP
.B CMAKE_MINOR_VERSION
Da Minor version of cmake (i.e. tha 4 up in X.4.X).

This specifies tha minor version of tha CMake executable bein run.

.TP
.B CMAKE_PARENT_LIST_FILE
Full path ta tha CMake file dat included tha current one.

While processin a CMake file loaded by include() or find_package() dis variable gotz nuff tha full path ta tha file includin dat shit.  Da top of tha include stack be always tha CMakeLists.txt fo' tha current directory.  See also CMAKE_CURRENT_LIST_FILE.

.TP
.B CMAKE_PATCH_VERSION
Da patch version of cmake (i.e. tha 3 up in X.X.3).

This specifies tha patch version of tha CMake executable bein run.

.TP
.B CMAKE_PROJECT_NAME
Da name of tha current project.

This specifies name of tha current project from tha closest inherited PROJECT command.

.TP
.B CMAKE_RANLIB
Name of randomizin tool fo' static libraries.

This specifies name of tha program dat randomizes libraries on UNIX, not used on Windows yo, but may be present.

.TP
.B CMAKE_ROOT
Install directory fo' hustlin cmake.

This is tha install root fo' tha hustlin CMake n' tha Modulez directory can be found here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This is commonly used up in dis format: ${CMAKE_ROOT}/Modules

.TP
.B CMAKE_SCRIPT_MODE_FILE
Full path ta tha \-P script file currently bein processed.

When run up in \-P script mode, CMake sets dis variable ta tha full path of tha script file. When run ta configure a CMakeLists.txt file, dis variable aint set.

.TP
.B CMAKE_SHARED_LIBRARY_PREFIX
Da prefix fo' shared libraries dat you link to.

Da prefix ta use fo' tha name of a gangbangin' finger-lickin' dirty-ass shared library, lib on UNIX.


CMAKE_SHARED_LIBRARY_PREFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_SHARED_LIBRARY_SUFFIX
Da suffix fo' shared libraries dat you link to.

Da suffix ta use fo' tha end of a gangbangin' finger-lickin' dirty-ass shared library filename, .dll on Windows.


CMAKE_SHARED_LIBRARY_SUFFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_SHARED_MODULE_PREFIX
Da prefix fo' loadable modulez dat you link to.

Da prefix ta use fo' tha name of a loadable module on dis platform.


CMAKE_SHARED_MODULE_PREFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_SHARED_MODULE_SUFFIX
Da suffix fo' shared libraries dat you link to.

Da suffix ta use fo' tha end of a loadable module filename on dis platform


CMAKE_SHARED_MODULE_SUFFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_SIZEOF_VOID_P
Size of a void pointer.

This is set ta tha size of a pointa on tha machine, n' is determined by a try compile. If a 64 bit size is found, then tha library search path is modified ta look fo' 64 bit libraries first.

.TP
.B CMAKE_SKIP_RPATH
If true, do not add run time path shiznit.

If dis is set ta TRUE, then tha rpath shiznit aint added ta compiled executables.  Da default is ta add rpath shiznit if tha platform supports dat shit.  This allows fo' easy as fuck  hustlin from tha build tree.  To omit RPATH up in tha install step yo, but not tha build step, use CMAKE_SKIP_INSTALL_RPATH instead.

.TP
.B CMAKE_SOURCE_DIR
Da path ta tha top level of tha source tree.

This is tha full path ta tha top level of tha current CMake source tree. For a in\-source build, dis would be tha same as CMAKE_BINARY_DIR.

.TP
.B CMAKE_STANDARD_LIBRARIES
Libraries linked tha fuck into every last muthafuckin executable n' shared library.

This is tha list of libraries dat is linked tha fuck into all executablez n' libraries.

.TP
.B CMAKE_STATIC_LIBRARY_PREFIX
Da prefix fo' static libraries dat you link to.

Da prefix ta use fo' tha name of a static library, lib on UNIX.


CMAKE_STATIC_LIBRARY_PREFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_STATIC_LIBRARY_SUFFIX
Da suffix fo' static libraries dat you link to.

Da suffix ta use fo' tha end of a static library filename, .lib on Windows.


CMAKE_STATIC_LIBRARY_SUFFIX_<LANG> overrides dis fo' language <LANG>.

.TP
.B CMAKE_TWEAK_VERSION
Da tweak version of cmake (i.e. tha 1 up in X.X.X.1).

This specifies tha tweak version of tha CMake executable bein run. I aint talkin' bout chicken n' gravy biatch.  Releases use tweak < 20000000 n' pimpment versions use tha date format CCYYMMDD fo' tha tweak level.

.TP
.B CMAKE_VERBOSE_MAKEFILE
Smoke verbose makefilez if on.

This variable defaults ta false. Yo ass can set dis variable ta legit ta make CMake produce verbose makefilez dat show each command line as it is used.

.TP
.B CMAKE_VERSION
Da full version of cmake up in major.minor.patch[.tweak[\-id]] format.

This specifies tha full version of tha CMake executable bein run. I aint talkin' bout chicken n' gravy biatch.  This variable is defined by versions 2.6.3 n' higher n' shit.  See variablez CMAKE_MAJOR_VERSION, CMAKE_MINOR_VERSION, CMAKE_PATCH_VERSION, n' CMAKE_TWEAK_VERSION fo' individual version components, n' you can put dat on yo' toast.  Da [\-id] component appears up in non\-release versions n' may be arbitrary text.

.TP
.B CMAKE_VS_PLATFORM_TOOLSET
Visual Studio Platform Toolset name.

VS 10 n' above use MSBuild under tha hood n' support multiple compila toolchains.  CMake may specify a toolset explicitly, like fuckin "v110" fo' VS 11 or "Windows7.1SDK" fo' 64\-bit support up in VS 10 Express.  CMake serves up tha name of tha chosen toolset up in dis variable.

.TP
.B CMAKE_XCODE_PLATFORM_TOOLSET
Xcode compila selection.

Xcode supports selection of a cold-ass lil compila from one of tha installed toolsets, n' you can put dat on yo' toast.  CMake serves up tha name of tha chosen toolset up in dis variable, if any is explicitly selected (e.g. via tha cmake \-T option).

.TP
.B PROJECT_BINARY_DIR
Full path ta build directory fo' project.

This is tha binary directory of da most thugged-out recent PROJECT command.

.TP
.B PROJECT_NAME
Name of tha project given ta tha project command.

This is tha name given ta da most thugged-out recent PROJECT command.

.TP
.B PROJECT_SOURCE_DIR
Top level source directory fo' tha current project.

This is tha source directory of da most thugged-out recent PROJECT command.

.TP
.B [Project name]_BINARY_DIR
Top level binary directory fo' tha named project.

A variable is pimped wit tha name used up in tha PROJECT command, n' is tha binary directory fo' tha project.   This can be useful when SUBDIR is used ta connect nuff muthafuckin projects.

.TP
.B [Project name]_SOURCE_DIR
Top level source directory fo' tha named project.

A variable is pimped wit tha name used up in tha PROJECT command, n' is tha source directory fo' tha project.   This can be useful when add_subdirectory is used ta connect nuff muthafuckin projects.

.SH COPYRIGHT
.PP
Copyright 2000\-2012 Kitware, Inc., Insight Software Consortium.  All muthafuckin rights reserved.

.PP
Redistribution n' use up in source n' binary forms, wit or without modification, is permitted provided dat tha followin conditions is met:

.PP
Redistributionz of source code must retain tha above copyright notice, dis list of conditions n' tha followin disclaimer.

.PP
Redistributions up in binary form must reproduce tha above copyright notice, dis list of conditions n' tha followin disclaimer up in tha documentation and/or other shiznit provided wit tha distribution.

.PP
Neither tha namez of Kitware, Inc., tha Insight Software Consortium, nor tha namez of they contributors may be used ta endorse or promote shizzle derived from dis software without specific prior freestyled permission.

.PP
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.SH SEE ALSO
.PP
.B ccmake(1), cpack(1), ctest(1), cmakecommands(1), cmakecompat(1), cmakemodules(1), cmakeprops(1), cmakevars(1)

.PP
Da followin resources is available ta git help rockin CMake:

.TP
.B Home Page
http://www.cmake.org

Da primary startin point fo' peepin' bout CMake.

.TP
.B Frequently Axed Questions
http://www.cmake.org/Wiki/CMake_FAQ

A Wiki is provided containin lyrics ta frequently axed thangs. 

.TP
.B Online Documentation
http://www.cmake.org/HTML/Documentation.html

Links ta available documentation may be found on dis wizzy page.

.TP
.B Mailin List
http://www.cmake.org/HTML/MailingLists.html

For help n' rap bout rockin cmake, a mailin list is provided at cmake@cmake.org. Da list is member\-post\-only but one may sign up on tha CMake wizzy page. Please first read tha full documentation at http://www.cmake.org before postin thangs ta tha list.

.SH AUTHOR
.PP
This manual page was generated by tha "\-\-help\-man" option.

