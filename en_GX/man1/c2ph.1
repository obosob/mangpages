.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C2PH 1"
.TH C2PH 1 "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
c2ph, pstruct \- Dump C structures as generated from "cc \-g \-S" stabs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    c2ph [\-dpnP] [var=val] [filez ...]
.Ve
.SS "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
.Vb 1
\&    Options:
\&
\&    \-w  wide; short for: type_width=45 member_width=35 offset_width=8
\&    \-x  hex; short for:  offset_fmt=x offset_width=08 size_fmt=x size_width=04
\&
\&    \-n  do not generate perl code  (default when invoked as pstruct)
\&    \-p  generate perl code         (default when invoked as c2ph)
\&    \-v  generate perl code, wit C decls as comments
\&
\&    \-i  do NOT recompute sizes fo' intrinsic datatypes
\&    \-a  dump shiznit on intrinsics also
\&
\&    \-t  trace execution
\&    \-d  spew reamz of debuggin output
\&
\&    \-slist  give comma\-separated list a structures ta dump
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da followin is tha oldschool c2ph.doc documentation by Tomothy Christiansen
<tchrist@perl.com>
Date: 25 Jul 91 08:10:21 \s-1GMT\s0
.PP
Back up in tha day, I freestyled a program called pstruct.  Dat shiznit was a perl
program dat tried ta parse up C structures n' display they member
offsets fo' yo thugged-out ass.  This was especially useful fo' playas lookin at
binary dumps or pokin round tha kernel.
.PP
Pstruct was not a pimpin' program.  Neither was it particularly robust.
Da problem, you see, was dat tha C compila was much betta at parsing
C than I could eva hope ta be.
.PP
So I gots smart:  I decided ta be lazy n' let tha C compila parse tha C,
which would spit up debugger stabs fo' me ta read. Y'all KNOW dat shit, muthafucka!  These was much
easier ta parse.  It aint nuthin but still not a pimpin' program yo, but at least itz more
robust.
.PP
Pstruct takes any .c or .h files, or preferably .s ones, since that's
the format it is goin ta massage dem tha fuck into anyway, n' spits out
listings like this:
.PP
.Vb 10
\& struct tty {
\&   int                          tty.t_locker                         000      4
\&   int                          tty.t_mutex_index                    004      4
\&   struct tty *                 tty.t_tp_virt                        008      4
\&   struct clist                 tty.t_rawq                           00c     20
\&     int                        tty.t_rawq.c_cc                      00c      4
\&     int                        tty.t_rawq.c_cmax                    010      4
\&     int                        tty.t_rawq.c_cfx                     014      4
\&     int                        tty.t_rawq.c_clx                     018      4
\&     struct tty *               tty.t_rawq.c_tp_cpu                  01c      4
\&     struct tty *               tty.t_rawq.c_tp_iop                  020      4
\&     unsigned char *            tty.t_rawq.c_buf_cpu                 024      4
\&     unsigned char *            tty.t_rawq.c_buf_iop                 028      4
\&   struct clist                 tty.t_canq                           02c     20
\&     int                        tty.t_canq.c_cc                      02c      4
\&     int                        tty.t_canq.c_cmax                    030      4
\&     int                        tty.t_canq.c_cfx                     034      4
\&     int                        tty.t_canq.c_clx                     038      4
\&     struct tty *               tty.t_canq.c_tp_cpu                  03c      4
\&     struct tty *               tty.t_canq.c_tp_iop                  040      4
\&     unsigned char *            tty.t_canq.c_buf_cpu                 044      4
\&     unsigned char *            tty.t_canq.c_buf_iop                 048      4
\&   struct clist                 tty.t_outq                           04c     20
\&     int                        tty.t_outq.c_cc                      04c      4
\&     int                        tty.t_outq.c_cmax                    050      4
\&     int                        tty.t_outq.c_cfx                     054      4
\&     int                        tty.t_outq.c_clx                     058      4
\&     struct tty *               tty.t_outq.c_tp_cpu                  05c      4
\&     struct tty *               tty.t_outq.c_tp_iop                  060      4
\&     unsigned char *            tty.t_outq.c_buf_cpu                 064      4
\&     unsigned char *            tty.t_outq.c_buf_iop                 068      4
\&   (*int)()                     tty.t_oproc_cpu                      06c      4
\&   (*int)()                     tty.t_oproc_iop                      070      4
\&   (*int)()                     tty.t_stopproc_cpu                   074      4
\&   (*int)()                     tty.t_stopproc_iop                   078      4
\&   struct thread *              tty.t_rsel                           07c      4
.Ve
.PP
etc.
.PP
Actually, dis was generated by a particular set of options.  Yo ass can control
the formattin of each column, whether you prefer wide or fat, hex or decimal,
leadin zeroes or whatever.
.PP
All you need ta be able ta use dis be a C compila than generates
BSD/GCC\-style stabs.  Da \fB\-g\fR option on natizzle \s-1BSD\s0 compilaz n' \s-1GCC\s0
should git dis fo' yo thugged-out ass.
.PP
To learn more, just type a funky-ass bogus option, like \fB\-\e?\fR, n' a long-ass usage message
will be provided. Y'all KNOW dat shit, muthafucka!  There is a gangbangin' fair number of possibilities.
.PP
If you only a C programmer, than dis is tha end of tha message fo' yo thugged-out ass.
Yo ass can quit up in dis biatch, n' if you care to, save off tha source n' run it
when you feel like dat shit.  Or not.
.PP
But if you a perl programmer, then fo' you I have suttin' much more
wondrous than just a structure offset printer.
.PP
Yo ass see, if you call pstruct by its other incybernation, c2ph, you gotz a cold-ass lil code
generator dat translates C code tha fuck into perl code biaaatch!  Well, structure n' union
declarations at least yo, but thatz like a funky-ass bit.
.PP
Prior ta dis point, mah playas programmin up in perl whoz ass wanted ta interact
with C programs, like tha kernel, was forced ta guess tha layouts of
the C structures, n' then hardwire these tha fuck into his thugged-out lil' program.  Of course,
when you took yo' wonderfully crafted program ta a system where the
sgtty structure was laid up differently, yo' program broke.  Which is
a muthafucka.
.PP
We've had Larryz h2ph translator, which helped yo, but dat only works on
cpp symbols, not real C, which was also straight-up much needed. Y'all KNOW dat shit, muthafucka!  What I offer
you be a symbolic way of gettin at all tha C structures.  I've couched
them up in termz of packages n' functions.  Consider tha followin program:
.PP
.Vb 1
\&    #!/usr/local/bin/perl
\&
\&    require \*(Aqsyscall.ph\*(Aq;
\&    require \*(Aqsys/time.ph\*(Aq;
\&    require \*(Aqsys/resource.ph\*(Aq;
\&
\&    $ru = "\e0" x &rusage\*(Aqsizeof();
\&
\&    syscall(&SYS_getrusage, &RUSAGE_SELF, $ru)      && take a thugged-out dirtnap "getrusage: $!";
\&
\&    @ru = unpack($t = &rusage\*(Aqtypedef(), $ru);
\&
\&    $utime =  $ru[ &rusage\*(Aqru_utime + &timeval\*(Aqtv_sec  ]
\&           + ($ru[ &rusage\*(Aqru_utime + &timeval\*(Aqtv_usec ]) / 1e6;
\&
\&    $stime =  $ru[ &rusage\*(Aqru_stime + &timeval\*(Aqtv_sec  ]
\&           + ($ru[ &rusage\*(Aqru_stime + &timeval\*(Aqtv_usec ]) / 1e6;
\&
\&    printf "you have used %8.3fs+%8.3fu seconds.\en", $utime, $stime;
.Ve
.PP
As you see, tha name of tha package is tha name of tha structure.  Regular
fieldz is just they own names.  Plus tha followin accessor functions are
provided fo' yo' convenience:
.PP
.Vb 3
\&    struct      This takes no arguments, n' is merely tha number of first\-level
\&                elements up in tha structure.  Yo ass would use dis fo' indexing
\&                tha fuck into arrayz of structures, like like this
\&
\&
\&                    $usec = $u[ &user\*(Aqu_utimer
\&                                + (&ITIMER_VIRTUAL * &itimerval\*(Aqstruct)
\&                                + &itimerval\*(Aqit_value
\&                                + &timeval\*(Aqtv_usec
\&                              ];
\&
\&    sizeof      Returns tha bytes up in tha structure, or tha member if
\&                you pass it a argument, such as
\&
\&                        &rusage\*(Aqsizeof(&rusage\*(Aqru_utime)
\&
\&    typedef     This is tha perl format definizzle fo' passin ta pack and
\&                unpack.  If you ask fo' tha typedef of a nothing, you get
\&                tha whole structure, otherwise you git dat of tha member
\&                you ask for. Shiiit, dis aint no joke.  Paddin is taken care of, as is tha magic to
\&                guarantee dat a union is unpacked tha fuck into all its aliases.
\&                Bitfieldz is not like yet supported however.
\&
\&    offsetof    This function is tha byte offset tha fuck into tha array of that
\&                member n' shit.  Yo ass may wish ta use dis fo' indexin directly
\&                tha fuck into tha packed structure wit vec() if you\*(Aqre too lazy
\&                ta unpack dat shit.
\&
\&    typeof      Not ta be trippin wit tha typedef accessor function, this
\&                one returns tha C type of dat field. Y'all KNOW dat shit, muthafucka!  This would allow
\&                you ta print up a sick structured pretty print of some
\&                structure without knonin anythang bout it beforehand.
\&                No args ta dis one be a noop.  Somedizzle I\*(Aqll post such
\&                a thang ta dump up yo' u structure fo' yo thugged-out ass.
.Ve
.PP
Da way I peep dis bein used is like basically this:
.PP
.Vb 3
\&        % h2ph <some_include_file.h  >  /usr/lib/perl/tmp.ph
\&        % c2ph  some_include_file.h  >> /usr/lib/perl/tmp.ph
\&        % install
.Ve
.PP
It aint nuthin but a lil tricker wit c2ph cuz you gotta git tha includes right.
I can't know dis fo' yo' system yo, but it aint probably too terribly difficult.
.PP
Da code aint pretty as I mentioned  \*(-- I never thought it would be a 1000\-
line program when I started, or I might not have begun. I aint talkin' bout chicken n' gravy biatch. :\-)  But I would have
been less cavalier up in how tha fuck tha partz of tha program communicated wit each
other, etc.  It might also have helped if I didn't gotta divine tha makeup
of tha stabs on tha fly, n' then account fo' micro differences between my
compila n' gcc.
.PP
Anyway, here it is.  Should run on perl v4 or pimped outer n' shit.  Maybe less.
.PP
.Vb 1
\& \-\-tom
.Ve
