.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SHELL-QUOTE 1"
.TH SHELL-QUOTE 1 "2010-06-11" "perl v5.18.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
shell\-quote \- quote arguments fo' safe use, unmodified up in a gangbangin' finger-lickin' dirty-ass shell command
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBshell-quote\fR [\fIswitch\fR]... \fIarg\fR...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBshell-quote\fR lets you pass arbitrary strings all up in tha shell so that
they won't be chizzled by tha shell.  This lets you process commandz or
filez wit embedded white space or shell globbin charactas safely.
Here is all dem examples.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "\fBssh preservin args\fR" 4
.IX Item "ssh preservin args"
When hustlin a remote command wit ssh, ssh don't preserve tha separate
arguments it receives.  It just joins dem wit spaces n' passes dem to
\&\f(CW\*(C`$SHELL \-c\*(C'\fR.  This don't work as intended:
.Sp
.Vb 1
\&    ssh host bust a nut on \*(Aqhi there\*(Aq           # fails
.Ve
.Sp
It creates 2 files, \fIhi\fR n' \fIthere\fR.  Instead, do this:
.Sp
.Vb 2
\&    cmd=\`shell\-quote bust a nut on \*(Aqhi there\*(Aq\`
\&    ssh host "$cmd"
.Ve
.Sp
This gives you just 1 file, \fIhi there\fR.
.IP "\fBprocess smoke upput\fR" 4
.IX Item "process smoke upput"
It aint nuthin but not ordinarily possible ta process a arbitrary list of files
output by \fBfind\fR wit a gangbangin' finger-lickin' dirty-ass shell script.  Anythang you put up in \f(CW$IFS\fR to
split up tha output could legitimately be up in a gangbangin' filez name.  Herez how
you can do it rockin \fBshell-quote\fR:
.Sp
.Vb 1
\&    eval set \-\- \`find \-type f \-print0 | xargs \-0 shell\-quote \-\-\`
.Ve
.IP "\fBdebug shell scripts\fR" 4
.IX Item "debug shell scripts"
\&\fBshell-quote\fR is betta than \fBecho\fR fo' debuggin shell scripts.
.Sp
.Vb 3
\&    debug() {
\&        [ \-z "$debug" ] || shell\-quote "debug:" "$@"
\&    }
.Ve
.Sp
With \fBecho\fR you can't tell tha difference between \f(CW\*(C`debug \*(Aqfoo bar\*(Aq\*(C'\fR
and \f(CW\*(C`debug foo bar\*(C'\fR yo, but wit \fBshell-quote\fR you can.
.IP "\fBsave a cold-ass lil command fo' later\fR" 4
.IX Item "save a cold-ass lil command fo' later"
\&\fBshell-quote\fR can be used ta build up a gangbangin' finger-lickin' dirty-ass shell command ta run later.
Say you want tha user ta be able ta hit you wit switches fo' a cold-ass lil command
yo ass is goin ta run. I aint talkin' bout chicken n' gravy biatch.  If you don't want tha switches ta be re-evaluated
by tha shell (which is probably a phat idea, else there be thangs the
user can't pass through), you can do suttin' like this:
.Sp
.Vb 10
\&    user_switches=
\&    while [ $# != 0 ]
\&    do
\&        case x$1 in
\&            x\-\-pass\-through)
\&                [ $# \-gt 1 ] || take a thugged-out dirtnap "need a argument fo' $1"
\&                user_switches="$user_switches "\`shell\-quote \-\- "$2"\`
\&                shift;;
\&            # process other switches
\&        esac
\&        shift
\&    done
\&    # later
\&    eval "shell\-quote some\-command $user_switches mah args"
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-\-debug\fR" 4
.IX Item "--debug"
Turn debuggin on.
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
Show tha usage message n' take a thugged-out dirt nap.
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
Show tha version number n' exit.
.SH "AVAILABILITY"
.IX Header "AVAILABILITY"
Da code is licensed under tha \s-1GNU GPL. \s0 Check
http://www.argon.org/~roderick/ or \s-1CPAN\s0 fo' updated versions.
.SH "AUTHOR"
.IX Header "AUTHOR"
Roderick Schertla <roderick@argon.org>
