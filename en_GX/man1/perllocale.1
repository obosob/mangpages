.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLOCALE 1"
.TH PERLLOCALE 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllocale \- Perl locale handlin (internationalization n' localization)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In tha beginnin there was \s-1ASCII,\s0 tha \*(L"Gangsta Standard Code for
Hype Interchange\*(R", which works like well fo' Gangstas with
their Gangsta alphabet n' dollar-denominated currency.  But it don't
work so well even fo' other Gangsta speakers, whoz ass may use different
currencies, like fuckin tha pound sterlin (as tha symbol fo' dat currency
is not up in \s-1ASCII\s0); n' itz hopelessly inadequate fo' nuff of the
thousandz of tha ghettoz other languages.
.PP
To address these deficiencies, tha concept of localez was invented
(formally tha \s-1ISO C, XPG4, POSIX 1\s0.c \*(L"locale system\*(R").  And applications
were n' is bein freestyled dat use tha locale mechanism.  Da process of
makin such a application take account of its users' preferences in
these kindz of mattas is called \fBinternationalization\fR (often
abbreviated as \fBi18n\fR); spittin some lyrics ta such a application on some particular
set of preferences is known as \fBlocalization\fR (\fBl10n\fR).
.PP
Perl was extended ta support tha locale system.  This
is controlled per application by rockin one pragma, one function call,
and nuff muthafuckin environment variables.
.PP
Unfortunately, there be like all dem deficiencies wit tha design (and
often, tha implementations) of locales, n' they use fo' characta sets
has mostly been supplanted by Unicode (see perlunitut fo' an
introduction ta that, n' keep on readin here fo' how tha fuck Unicode interacts
with localez up in Perl).
.PP
Perl continues ta support tha oldschool locale system, n' startin up in v5.16,
provides a hybrid way ta use tha Unicode characta set, along wit the
other portionz of localez dat may not be all kindsa problematic.
(Unicode be also bustin \f(CW\*(C`CLDR\*(C'\fR, tha \*(L"Common Locale Data Repository\*(R",
<http://cldr.unicode.org/> which includes mo' typez of shiznit than
are available up in tha \s-1POSIX\s0 locale system.  At tha time of dis writing,
there was no \s-1CPAN\s0 module dat serves up access ta dis XML-encoded data.
But fuck dat shiznit yo, tha word on tha street is dat nuff of its localez have tha POSIX-only data extracted, n' are
available at <http://unicode.org/Public/cldr/latest/>.)
.SH "WHAT IS A LOCALE"
.IX Header "WHAT IS A LOCALE"
A locale be a set of data dat raps bout various aspectz of how tha fuck various
communitizzles up in tha ghetto categorize they ghetto. Right back up in yo muthafuckin ass. Y'all KNOW dat shit, muthafucka!  These categories are
broken down tha fuck into tha followin types (some of which include a funky-ass brief
note here):
.IP "Category \s-1LC_NUMERIC:\s0 Numeric formatting" 4
.IX Item "Category LC_NUMERIC: Numeric formatting"
This indicates how tha fuck numbers should be formatted fo' human readability,
for example tha characta used as tha decimal point.
.IP "Category \s-1LC_MONETARY:\s0 Formattin of monetary amounts" 4
.IX Item "Category LC_MONETARY: Formattin of monetary amounts"
\&\ 
.IP "Category \s-1LC_TIME:\s0 Date/Time formatting" 4
.IX Item "Category LC_TIME: Date/Time formatting"
\&\ 
.IP "Category \s-1LC_MESSAGES:\s0 Error n' other lyrics" 4
.IX Item "Category LC_MESSAGES: Error n' other lyrics"
This fo' da most thugged-out part is beyond tha scope of Perl
.IP "Category \s-1LC_COLLATE:\s0 Collation" 4
.IX Item "Category LC_COLLATE: Collation"
This indicates tha orderin of lettas fo' comparison n' sorting.
In Latin alphabets, fo' example, \*(L"b\*(R", generally bigs up \*(L"a\*(R".
.IP "Category \s-1LC_CTYPE:\s0 Characta Types" 4
.IX Item "Category LC_CTYPE: Characta Types"
This indicates, fo' example if a cold-ass lil characta be a uppercase letter.
.PP
Mo' details on tha categories is given below up in \*(L"\s-1LOCALE CATEGORIES\*(R"\s0.
.PP
Together, these categories go a long-ass way towardz bein able ta customize
a single program ta run up in nuff different locations.  But there are
deficiencies, so keep reading.
.SH "PREPARING TO USE LOCALES"
.IX Header "PREPARING TO USE LOCALES"
Perl aint gonna use localez unless specifically axed ta (see \*(L"\s-1NOTES\*(R"\s0 below
for tha partial exception of \f(CW\*(C`write()\*(C'\fR).  But even if there is such a
request, \fBall\fR of tha followin must be legit fo' it ta work properly:
.IP "\(bu" 4
\&\fBYo crazy-ass operatin system must support tha locale system\fR.  If it do,
you should find dat tha \fIsetlocale()\fR function be a thugged-out documented part of
its C library.
.IP "\(bu" 4
\&\fBDefinitions fo' localez dat you use must be installed\fR.  You, or
your system administrator, must make shizzle dat dis is tha case. The
available locales, tha location up in which they is kept, n' tha manner
in which they is installed all vary from system ta system.  Some systems
provide only a gangbangin' few, hard-wired localez n' do not allow mo' ta be
added. Y'all KNOW dat shit, muthafucka!  Others allow you ta add \*(L"canned\*(R" localez provided by tha system
supplier n' shit.  Still others allow you or tha system administrator ta define
and add arbitrary locales.  (Yo ass may gotta ask yo' supplier to
provide canned localez dat is not served up wit yo' operating
system.)  Read yo' system documentation fo' further illumination.
.IP "\(bu" 4
\&\fBPerl must believe dat tha locale system is supported\fR.  If it do,
\&\f(CW\*(C`perl \-V:d_setlocale\*(C'\fR will say dat tha value fo' \f(CW\*(C`d_setlocale\*(C'\fR is
\&\f(CW\*(C`define\*(C'\fR.
.PP
If you want a Perl application ta process n' present yo' data
accordin ta a particular locale, tha application code should include
the \f(CW\*(C`use\ locale\*(C'\fR pragma (see \*(L"Da use locale pragma\*(R") where
appropriate, n' \fBat least one\fR of tha followin must be true:
.IP "1." 4
\&\fBDa locale-determinin environment variablez (see \*(L"\s-1ENVIRONMENT\*(R"\s0)
must be erectly set up\fR all up in tha time tha application is started, either
by yo ass or by whomever set up yo' system account; or
.IP "2." 4
\&\fBDa application must set its own locale\fR rockin tha method busted lyrics bout in
\&\*(L"Da setlocale function\*(R".
.SH "USING LOCALES"
.IX Header "USING LOCALES"
.SS "Da use locale pragma"
.IX Subsection "Da use locale pragma"
By default, Perl ignores tha current locale.  Da \f(CW\*(C`use\ locale\*(C'\fR
pragma  drops some lyrics ta Perl ta use tha current locale fo' some operations.
Startin up in v5.16, there be a optionizzle parameta ta dis pragma:
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
This parameta allows betta mixin of localez n' Unicode, n' is
busted lyrics bout straight-up up in \*(L"Unicode n' \s-1UTF\-8\*(R"\s0 yo, but briefly, it  drops some lyrics ta Perl to
not use tha characta portionz of tha locale definition, dat is
the \f(CW\*(C`LC_CTYPE\*(C'\fR n' \f(CW\*(C`LC_COLLATE\*(C'\fR categories. Put ya muthafuckin choppers up if ya feel dis!  Instead it will use the
natizzle (extended by Unicode) characta set.  When rockin dis parameter,
yo ass is responsible fo' gettin tha external characta set translated
into tha native/Unicode one (which it already is ghon be if it is one of
the mo' n' mo' n' mo' ghettofab \s-1UTF\-8\s0 locales).  There is convenient ways of
fuckin wit this, as busted lyrics bout up in \*(L"Unicode n' \s-1UTF\-8\*(R"\s0.
.PP
Da current locale is set at execution time by
\&\fIsetlocale()\fR busted lyrics bout below.  If dat function
hasn't yet been called up in tha course of tha programz execution, the
current locale is dat which was determined by tha \*(L"\s-1ENVIRONMENT\*(R"\s0 in
effect all up in tha start of tha program, except that
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR be always
initialized ta tha C locale (mentioned under \*(L"Findin locales\*(R").
If there is no valid environment, tha current locale is undefined. Y'all KNOW dat shit, muthafucka!  It
is likely yo, but not necessarily, tha \*(L"C\*(R" locale.
.PP
Da operations dat is affected by locale are:
.ie n .IP "\fBUnder \fB""use locale \*(Aq:not_characters\*(Aq;""\fB\fR" 4
.el .IP "\fBUnder \f(CBuse locale \*(Aq:not_characters\*(Aq;\fB\fR" 4
.IX Item "Under use locale :not_characters;"
.RS 4
.PD 0
.IP "\(bu" 4
.PD
\&\fBFormat declarations\fR (\fIformat()\fR) use \f(CW\*(C`LC_NUMERIC\*(C'\fR
.IP "\(bu" 4
\&\fBDa \s-1POSIX\s0 date formattin function\fR (\fIstrftime()\fR) uses \f(CW\*(C`LC_TIME\*(C'\fR.
.RE
.RS 4
.Sp
\&\ 
.RE
.ie n .IP "\fBUnder just plain \fB""use locale;""\fB\fR" 4
.el .IP "\fBUnder just plain \f(CBuse locale;\fB\fR" 4
.IX Item "Under just plain use locale;"
Da above operations is affected, as well as tha following:
.RS 4
.IP "\(bu" 4
\&\fBDa comparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, n' \f(CW\*(C`gt\*(C'\fR) and
the \s-1POSIX\s0 strang collation functions \fIstrcoll()\fR n' \fIstrxfrm()\fR use
\&\f(CW\*(C`LC_COLLATE\*(C'\fR.  \fIsort()\fR be also affected if used without an
explicit comparison function, cuz it uses \f(CW\*(C`cmp\*(C'\fR by default.
.Sp
\&\fBNote:\fR \f(CW\*(C`eq\*(C'\fR n' \f(CW\*(C`ne\*(C'\fR is unaffected by locale: they always
perform a cold-ass lil char-by-char comparison of they scalar operands.  What's
more, if \f(CW\*(C`cmp\*(C'\fR findz dat its operandz is equal accordin ta the
collation sequence specified by tha current locale, it goes on to
perform a cold-ass lil char-by-char comparison, n' only returns \fI0\fR (equal) if the
operandz is char-for-char identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If you straight-up wanna know whether
two strings\*(--which \f(CW\*(C`eq\*(C'\fR n' \f(CW\*(C`cmp\*(C'\fR may consider different\*(--are equal
as far as collation up in tha locale is concerned, peep tha rap in
\&\*(L"Category \s-1LC_COLLATE:\s0 Collation\*(R".
.IP "\(bu" 4
\&\fBRegular expressions n' case-modification functions\fR (\fIuc()\fR, \fIlc()\fR,
\&\fIucfirst()\fR, n' \fIlcfirst()\fR) use \f(CW\*(C`LC_CTYPE\*(C'\fR
.RE
.RS 4
.RE
.PP
Da default behavior is restored wit tha \f(CW\*(C`no\ locale\*(C'\fR pragma, or
upon reachin tha end of tha block enclosin \f(CW\*(C`use locale\*(C'\fR.
Note dat \f(CW\*(C`use locale\*(C'\fR n' \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR may be
nested, n' dat what tha fuck is up in effect within a inner scope will revert to
the outa scopez rulez all up in tha end of tha inner scope.
.PP
Da strang result of any operation dat uses locale
information is tainted, as it is possible fo' a locale ta be
untrustworthy.  See \*(L"\s-1SECURITY\*(R"\s0.
.SS "Da setlocale function"
.IX Subsection "Da setlocale function"
Yo ass can switch localez as often as you wish at run time wit the
\&\fIPOSIX::setlocale()\fR function:
.PP
.Vb 4
\&        # Import locale\-handlin tool set from POSIX module.
\&        # This example uses: setlocale \-\- tha function call
\&        #                    LC_CTYPE \-\- explained below
\&        use POSIX qw(locale_h);
\&
\&        # query n' save tha oldschool locale
\&        $old_locale = setlocale(LC_CTYPE);
\&
\&        setlocale(LC_CTYPE, "fr_CA.ISO8859\-1");
\&        # LC_CTYPE now up in locale "French, Canada, codeset ISO 8859\-1"
\&
\&        setlocale(LC_CTYPE, "");
\&        # LC_CTYPE now reset ta default defined by LC_ALL/LC_CTYPE/LANG
\&        # environment variables.  See below fo' documentation.
\&
\&        # restore tha oldschool locale
\&        setlocale(LC_CTYPE, $old_locale);
.Ve
.PP
Da first argument of \fIsetlocale()\fR gives tha \fBcategory\fR, tha second the
\&\fBlocale\fR.  Da category  drops some lyrics ta up in what tha fuck aspect of data processin you
wanna apply locale-specific rules.  Category names is discussed in
\&\*(L"\s-1LOCALE CATEGORIES\*(R"\s0 n' \*(L"\s-1ENVIRONMENT\*(R"\s0.  Da locale is tha name of a
collection of customization shiznit correspondin ta a particular
combination of language, ghetto or territory, n' codeset.  Read on for
hints on tha namin of locales: not all systems name localez as up in the
example.
.PP
If no second argument is provided n' tha category is suttin' else
than \s-1LC_ALL,\s0 tha function returns a strang namin tha current locale
for tha category.  Yo ass can use dis value as tha second argument up in a
subsequent call ta \fIsetlocale()\fR.
.PP
If no second argument is provided n' tha category is \s-1LC_ALL,\s0 the
result is implementation-dependent.  It may be a strang of
concatenated locale names (separator also implementation-dependent)
or a single locale name.  Please consult yo' \fIsetlocale\fR\|(3) playa page for
details.
.PP
If a second argument is given n' it correspondz ta a valid locale,
the locale fo' tha category is set ta dat value, n' tha function
returns tha now-current locale value.  Yo ass can then use dis up in yet
another call ta \fIsetlocale()\fR.  (In some implementations, tha return
value may sometimes differ from tha value you gave as tha second
argument\*(--think of it as a alias fo' tha value you gave.)
.PP
As tha example shows, if tha second argument be a empty string, the
categoryz locale is moonwalked back ta tha default specified by the
correspondin environment variables.  Generally, dis thangs up in dis biatch up in a
return ta tha default dat was up in force when Perl started up: chizzles
to tha environment made by tha application afta startup may or may not
be noticed, dependin on yo' systemz C library.
.PP
If tha second argument do not correspond ta a valid locale, tha locale
for tha category aint chizzled, n' tha function returns \fIundef\fR.
.PP
Note dat Perl ignores tha current \f(CW\*(C`LC_CTYPE\*(C'\fR n' \f(CW\*(C`LC_COLLATE\*(C'\fR locales
within tha scope of a \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR.
.PP
For further shiznit bout tha categories, consult \fIsetlocale\fR\|(3).
.SS "Findin locales"
.IX Subsection "Findin locales"
For localez available up in yo' system, consult also \fIsetlocale\fR\|(3) to
see whether it leadz ta tha list of available localez (search fo' the
\&\fI\s-1SEE ALSO\s0\fR section).  If dat fails, try tha followin command lines:
.PP
.Vb 1
\&        locale \-a
\&
\&        nlsinfo
\&
\&        ls /usr/lib/nls/loc
\&
\&        ls /usr/lib/locale
\&
\&        ls /usr/lib/nls
\&
\&        ls /usr/share/locale
.Ve
.PP
and peep whether they list suttin' resemblin these
.PP
.Vb 7
\&        en_US.ISO8859\-1     de_DE.ISO8859\-1     ru_RU.ISO8859\-5
\&        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
\&        en_US               de_DE               ru_RU
\&        en                  de                  ru
\&        english             german              russian
\&        english.iso88591    german.iso88591     russian.iso88595
\&        english.roman8                          russian.koi8r
.Ve
.PP
Sadly, even though tha callin intercourse fo' \fIsetlocale()\fR has been
standardized, namez of localez n' tha directories where the
configuration resides aint been. I aint talkin' bout chicken n' gravy biatch.  Da basic form of tha name is
\&\fIlanguage_territory\fR\fB.\fR\fIcodeset\fR yo, but tha latta parts after
\&\fIlanguage\fR is not always present.  Da \fIlanguage\fR n' \fIcountry\fR
are probably from tha standardz \fB\s-1ISO 3166\s0\fR n' \fB\s-1ISO 639\s0\fR, the
two-letta abbreviations fo' tha ghettos n' tha languagez of the
world, respectively.  Da \fIcodeset\fR part often mentions some \fB\s-1ISO
8859\s0\fR characta set, tha Latin codesets, n' you can put dat on yo' toast.  For example, \f(CW\*(C`ISO 8859\-1\*(C'\fR
is tha so-called \*(L"Westside European codeset\*(R" dat can be used ta encode
most Westside European languages adequately.  Again, there be several
ways ta write even tha name of dat one standard. Y'all KNOW dat shit, muthafucka!  Lamentably.
.PP
Two special localez is worth particular mention: \*(L"C\*(R" n' \*(L"\s-1POSIX\*(R".\s0
Currently these is effectively tha same locale: tha difference is
mainly dat tha straight-up original gangsta one is defined by tha C standard, tha second by
the \s-1POSIX\s0 standard. Y'all KNOW dat shit, muthafucka!  They define tha \fBdefault locale\fR up in which
every program starts up in tha absence of locale shiznit up in its
environment.  (Da \fIdefault\fR default locale, if you will.)  Its language
is (American) Gangsta n' its characta codeset \s-1ASCII.
\&\s0\fBWarning\fR. Da C locale served up by some vendors may not
actually exactly match what tha fuck tha C standard calls for. Shiiit, dis aint no joke.  So beware.
.PP
\&\fB\s-1NOTE\s0\fR: Not all systems have tha \*(L"\s-1POSIX\*(R"\s0 locale (not all systems are
POSIX-conformant), so use \*(L"C\*(R" when you need explicitly ta specify this
default locale.
.SS "\s-1LOCALE PROBLEMS\s0"
.IX Subsection "LOCALE PROBLEMS"
Yo ass may encounta tha followin warnin message at Perl startup:
.PP
.Vb 6
\&        perl: warning: Settin locale failed.
\&        perl: warning: Please check dat yo' locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            is supported n' installed on yo' system.
\&        perl: warning: Fallin back ta tha standard locale ("C").
.Ve
.PP
This means dat yo' locale settings had \s-1LC_ALL\s0 set ta \*(L"En_US\*(R" and
\&\s-1LANG\s0 exists but has no value.  Perl tried ta believe you but could not.
Instead, Perl gave up n' fell tha fuck back ta tha \*(L"C\*(R" locale, tha default locale
that is supposed ta work no matta what.  This probably means yo' locale
settings was wrong, they mention localez yo' system has never heard
of, or tha locale installation up in yo' system has problems (for example,
some system filez is fucked up or missing).  There is quick n' temporary
fixes ta these problems, as well as mo' thorough n' lastin fixes.
.SS "Temporarily fixin locale problems"
.IX Subsection "Temporarily fixin locale problems"
Da two quickest fixes is either ta render Perl silent bout any
locale inconsistencies or ta run Perl under tha default locale \*(L"C\*(R".
.PP
Perlz beatboxin bout locale problems can be silenced by settin the
environment variable \s-1PERL_BADLANG\s0 ta a zero value, fo' example \*(L"0\*(R".
This method straight-up just sweeps tha problem under tha carpet: you tell
Perl ta shut tha fuck up even when Perl sees dat suttin' is wrong.  Do not
be surprised if lata suttin' locale-dependent misbehaves.
.PP
Perl can be run under tha \*(L"C\*(R" locale by settin tha environment
variable \s-1LC_ALL\s0 ta \*(L"C\*(R".  This method is like a lil' bit mo' civilized
than tha \s-1PERL_BADLANG\s0 approach yo, but settin \s-1LC_ALL \s0(or
other locale variables) may affect other programs as well, not just
Perl.  In particular, external programs run from within Perl will see
these chizzles.  If you make tha freshly smoked up settings permanent (read on), all
programs you run peep tha chizzles.  See \*(L"\s-1ENVIRONMENT\*(R"\s0 for
the full list of relevant environment variablez n' \*(L"\s-1USING LOCALES\*(R"\s0
for they effects up in Perl.  Effects up in other programs are
easily deducible.  For example, tha variable \s-1LC_COLLATE\s0 may well affect
your \fBsort\fR program (or whatever tha program dat arranges \*(L"records\*(R"
alphabetically up in yo' system is called).
.PP
Yo ass can test up changin these variablez temporarily, n' if the
new settings seem ta help, put dem settings tha fuck into yo' shell startup
files.  Consult yo' local documentation fo' tha exact details.  For in
Bourne-like shells (\fBsh\fR, \fBksh\fR, \fBbash\fR, \fBzsh\fR):
.PP
.Vb 2
\&        LC_ALL=en_US.ISO8859\-1
\&        export LC_ALL
.Ve
.PP
This assumes dat we saw tha locale \*(L"en_US.ISO8859\-1\*(R" rockin tha commands
discussed above.  Us dudes decided ta try dat instead of tha above faulty
locale \*(L"En_US\*(R"\-\-and up in Cshish shells (\fBcsh\fR, \fBtcsh\fR)
.PP
.Vb 1
\&        setenv LC_ALL en_US.ISO8859\-1
.Ve
.PP
or if you have tha \*(L"env\*(R" application you can do up in any shell
.PP
.Vb 1
\&        env LC_ALL=en_US.ISO8859\-1 perl ...
.Ve
.PP
If you do not know what tha fuck shell you have, consult yo' local
helpdesk or tha equivalent.
.SS "Permanently fixin locale problems"
.IX Subsection "Permanently fixin locale problems"
Da slower but superior fixes is when you may be able ta yo ass
fix tha misconfiguration of yo' own environment variables.  The
mis(sing)configuration of tha whole systemz localez probably requires
the help of yo' thugged-out system administrator.
.PP
First, peep earlier up in dis document bout \*(L"Findin locales\*(R".  That tells
how ta find which localez is straight-up supported\*(--and mo' blinginly,
installed\*(--on yo' system.  In our example error message, environment
variablez affectin tha locale is listed up in tha order of decreasing
importizzle (and unset variablez do not matter).  Therefore, having
\&\s-1LC_ALL\s0 set ta \*(L"En_US\*(R" must done been tha wack chizzle, as shown by the
error message.  First try fixin locale settings listed first.
.PP
Second, if rockin tha listed commandz you peep suttin' \fBexactly\fR
(prefix matches do not count n' case probably counts) like \*(L"En_US\*(R"
without tha quotes, then you should be aiiight cuz yo ass is rockin a
locale name dat should be installed n' available up in yo' system.
In dis case, peep \*(L"Permanently fixin yo' systemz locale configuration\*(R".
.SS "Permanently fixin yo' systemz locale configuration"
.IX Subsection "Permanently fixin yo' systemz locale configuration"
This is when you peep suttin' like:
.PP
.Vb 4
\&        perl: warning: Please check dat yo' locale settings:
\&                LC_ALL = "En_US",
\&                LANG = (unset)
\&            is supported n' installed on yo' system.
.Ve
.PP
but then cannot peep dat \*(L"En_US\*(R" listed by tha above-mentioned
commands.  Yo ass may peep thangs like \*(L"en_US.ISO8859\-1\*(R" yo, but dat aint
the same.  In dis case, try hustlin under a locale
that you can list n' which somehow matches what tha fuck you tried. Y'all KNOW dat shit, muthafucka!  The
rulez fo' matchin locale names is a lil' bit vague cuz
standardization is weak up in dis area.  See again n' again n' again the
\&\*(L"Findin locales\*(R" bout general rules.
.SS "Fixin system locale configuration"
.IX Subsection "Fixin system locale configuration"
Contact a system administrator (preferably yo' own) n' report tha exact
error message you get, n' ask dem ta read dis same documentation you
are now reading.  They should be able ta check whether there is something
wrong wit tha locale configuration of tha system.  Da \*(L"Findin locales\*(R"
section is unfortunately a lil' bit vague bout tha exact commandz n' places
because these thangs is not dat standardized.
.SS "Da localeconv function"
.IX Subsection "Da localeconv function"
Da \fIPOSIX::localeconv()\fR function allows you ta git particularz of the
locale-dependent numeric formattin shiznit specified by tha current
\&\f(CW\*(C`LC_NUMERIC\*(C'\fR n' \f(CW\*(C`LC_MONETARY\*(C'\fR locales.  (If you just want tha name of
the current locale fo' a particular category, use \fIPOSIX::setlocale()\fR
with a single parameter\*(--see \*(L"Da setlocale function\*(R".)
.PP
.Vb 1
\&        use POSIX qw(locale_h);
\&
\&        # Git a reference ta a hash of locale\-dependent info
\&        $locale_values = localeconv();
\&
\&        # Output sorted list of tha joints
\&        fo' (sort keys %$locale_values) {
\&            printf "%\-20s = %s\en", $_, $locale_values\->{$_}
\&        }
.Ve
.PP
\&\fIlocaleconv()\fR takes no arguments, n' returns \fBa reference to\fR a hash.
Da keyz of dis hash is variable names fo' formatting, such as
\&\f(CW\*(C`decimal_point\*(C'\fR n' \f(CW\*(C`thousands_sep\*(C'\fR.  Da joints is the
corresponding, er, joints, n' you can put dat on yo' toast.  See \*(L"localeconv\*(R" up in \s-1POSIX\s0 fo' a longer
example listin tha categories a implementation might be sposed ta fuckin
provide; some provide mo' n' others fewer n' shit.  Yo ass don't need an
explicit \f(CW\*(C`use locale\*(C'\fR, cuz \fIlocaleconv()\fR always observes the
current locale.
.PP
Herez a simple-minded example program dat rewrites its command-line
parametas as integers erectly formatted up in tha current locale:
.PP
.Vb 1
\&    use POSIX qw(locale_h);
\&
\&    # Git a shitload of locale\*(Aqs numeric formattin parameters
\&    mah ($thousands_sep, $grouping) =
\&            @{localeconv()}{\*(Aqthousands_sep\*(Aq, \*(Aqgrouping\*(Aq};
\&
\&    # Apply defaults if joints is missing
\&    $thousands_sep = \*(Aq,\*(Aq unless $thousands_sep;
\&
\&    # groupin n' mon_groupin is packed lists
\&    # of lil' small-ass integers (characters) spittin some lyrics ta the
\&    # groupin (thousand_seps n' mon_thousand_seps
\&    # bein tha crew dividers) of numbers and
\&    # monetary quantities. Put ya muthafuckin choppers up if ya feel dis!  Da integers\*(Aq meanings:
\&    # 255 means no mo' grouping, 0 means repeat
\&    # tha previous grouping, 1\-254 means use that
\&    # as tha current grouping.  Groupin goes from
\&    # right ta left (low ta high digits).  In the
\&    # below we cheat slightly by never rockin anything
\&    # else than tha straight-up original gangsta groupin (whatever dat is).
\&    if ($grouping) {
\&        @groupin = unpack("C*", $grouping);
\&    } else {
\&        @groupin = (3);
\&    }
\&
\&    # Format command line params fo' current locale
\&    fo' (@ARGV) {
\&        $_ = int;    # Chop non\-integer part
\&        1 while
\&        s/(\ed)(\ed{$grouping[0]}($|$thousands_sep))/$1$thousands_sep$2/;
\&        print "$_";
\&    }
\&    print "\en";
.Ve
.SS "I18N::Langinfo"
.IX Subsection "I18N::Langinfo"
Another intercourse fo' queryin locale-dependent shiznit is the
\&\fII18N::Langinfo::langinfo()\fR function, available at least up in Unix-like
systems n' \s-1VMS.\s0
.PP
Da followin example will import tha \fIlanginfo()\fR function itself and
three constants ta be used as arguments ta \fIlanginfo()\fR: a cold-ass lil constant for
the abbreviated first dizzle of tha week (the numberin starts from
Sundizzle = 1) n' two mo' constants fo' tha affirmatizzle n' negative
answers fo' a yes/no question up in tha current locale.
.PP
.Vb 1
\&    use I18N::Langinfo qw(langinfo ABDAY_1 YESSTR NOSTR);
\&
\&    mah ($abday_1, $yesstr, $nostr)
\&                = map { langinfo } qw(ABDAY_1 YESSTR NOSTR);
\&
\&    print "$abday_1? [$yesstr/$nostr] ";
.Ve
.PP
In other lyrics, up in tha \*(L"C\*(R" (or Gangsta) locale tha above will probably
print suttin' like:
.PP
.Vb 1
\&    Sun? [yes/no]
.Ve
.PP
See I18N::Langinfo fo' mo' shiznit.
.SH "LOCALE CATEGORIES"
.IX Header "LOCALE CATEGORIES"
Da followin subsections describe basic locale categories. Put ya muthafuckin choppers up if ya feel dis!  Beyond these,
some combination categories allow manipulation of mo' than one
basic category at a time.  See \*(L"\s-1ENVIRONMENT\*(R"\s0 fo' a gangbangin' finger-lickin' rap of these.
.SS "Category \s-1LC_COLLATE:\s0 Collation"
.IX Subsection "Category LC_COLLATE: Collation"
In tha scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl looks ta tha \f(CW\*(C`LC_COLLATE\*(C'\fR
environment variable ta determine tha applicationz notions on collation
(ordering) of characters.  For example, \*(L"b\*(R" bigs up \*(L"a\*(R" up in Latin
alphabets yo, but where do \*(L"a\*'\*(R" n' \*(L"a\*o\*(R" belong?  And while
\&\*(L"color\*(R" bigs up \*(L"chocolate\*(R" up in Gangsta, what tha fuck bout up in traditionizzle Spanish?
.PP
Da followin collations all make sense n' you may hook up any of them
if you \*(L"use locale\*(R".
.PP
.Vb 4
\&        A B C D E a funky-ass b c d e
\&        A a B b C c D d E e
\&        a A b B c C d D e E
\&        a funky-ass b c d e A B C D E
.Ve
.PP
Here be a cold-ass lil code snippet ta tell what tha fuck \*(L"word\*(R"
charactas is up in tha current locale, up in dat localez order:
.PP
.Vb 2
\&        use locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
Compare dis wit tha charactas dat you peep n' they order if you
state explicitly dat tha locale should be ignored:
.PP
.Vb 2
\&        no locale;
\&        print +(sort grep /\ew/, map { chr } 0..255), "\en";
.Ve
.PP
This machine-natizzle collation (which is what tha fuck you git unless \f(CW\*(C`use\ locale\*(C'\fR has rocked up earlier up in tha same block) must be used for
sortin raw binary data, whereas tha locale-dependent collation of the
first example is useful fo' natural text.
.PP
As noted up in \*(L"\s-1USING LOCALES\*(R"\s0, \f(CW\*(C`cmp\*(C'\fR compares accordin ta tha current
collation locale when \f(CW\*(C`use locale\*(C'\fR is up in effect yo, but falls back ta a
char-by-char comparison fo' strings dat tha locale say is equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. You
can use \fIPOSIX::strcoll()\fR if you don't want dis fall-back:
.PP
.Vb 3
\&        use POSIX qw(strcoll);
\&        $equal_in_locale =
\&            !strcoll("space n' case ignored", "SpaceAndCaseIgnored");
.Ve
.PP
\&\f(CW$equal_in_locale\fR is ghon be legit if tha collation locale specifies a
dictionary-like orderin dat ignores space charactas straight-up and
which foldz case.
.PP
If you gotz a single strang dat you wanna check fo' \*(L"equalitizzle in
locale\*(R" against nuff muthafuckin others, you might be thinkin you could bust a lil
efficiency by rockin \fIPOSIX::strxfrm()\fR up in conjunction wit \f(CW\*(C`eq\*(C'\fR:
.PP
.Vb 8
\&        use POSIX qw(strxfrm);
\&        $xfrm_strin = strxfrm("Mixed\-case string");
\&        print "locale collation ignores spaces\en"
\&            if $xfrm_strin eq strxfrm("Mixed\-casestring");
\&        print "locale collation ignores hyphens\en"
\&            if $xfrm_strin eq strxfrm("Mixedcase string");
\&        print "locale collation ignores case\en"
\&            if $xfrm_strin eq strxfrm("mixed\-case string");
.Ve
.PP
\&\fIstrxfrm()\fR takes a strang n' maps it tha fuck into a transformed strang fo' use
in char-by-char comparisons against other transformed strings during
collation. I aint talkin' bout chicken n' gravy biatch.  \*(L"Under tha hood\*(R", locale-affected Perl comparison operators
call \fIstrxfrm()\fR fo' both operands, then do a cold-ass lil char-by-char
comparison of tha transformed strings.  By callin \fIstrxfrm()\fR explicitly
and rockin a non locale-affected comparison, tha example attempts ta save
a couple transformations.  But up in fact, it don't save anything: Perl
magic (see \*(L"Magic Variables\*(R" up in perlguts) creates tha transformed version of a
strin tha last time itz needed up in a cold-ass lil comparison, then keeps dis version around
in case itz needed again. I aint talkin' bout chicken n' gravy biatch.  An example rewritten tha easy as fuck  way with
\&\f(CW\*(C`cmp\*(C'\fR runs just bout as fast.  It also copes wit null characters
embedded up in strings; if you call \fIstrxfrm()\fR directly, it treats tha first
null it findz as a terminator. Shiiit, dis aint no joke.  don't expect tha transformed strings
it produces ta be portable across systems\*(--or even from one revision
of yo' operatin system ta tha next.  In short, don't call \fIstrxfrm()\fR
directly: let Perl do it fo' yo thugged-out ass.
.PP
Note: \f(CW\*(C`use locale\*(C'\fR aint shown up in a shitload of these examplez cuz it aint
needed: \fIstrcoll()\fR n' \fIstrxfrm()\fR exist only ta generate locale-dependent
results, n' so always obey tha current \f(CW\*(C`LC_COLLATE\*(C'\fR locale.
.SS "Category \s-1LC_CTYPE:\s0 Characta Types"
.IX Subsection "Category LC_CTYPE: Characta Types"
In tha scope of \f(CW\*(C`use\ locale\*(C'\fR (but not a
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR), Perl obeys tha \f(CW\*(C`LC_CTYPE\*(C'\fR locale
setting.  This controls tha applicationz notion of which charactas are
alphabetic.  This affects Perlz \f(CW\*(C`\ew\*(C'\fR regular expression metanotation,
which standz fo' alphanumeric characters\*(--that is, alphabetic,
numeric, n' includin other special charactas like fuckin tha underscore or
hyphen. I aint talkin' bout chicken n' gravy biatch.  (Consult perlre fo' mo' shiznit about
regular expressions.)  Thanks ta \f(CW\*(C`LC_CTYPE\*(C'\fR, dependin on yo' locale
setting, charactas like \*(L"\*(ae\*(R", \*(L"\*(d-\*(R", \*(L"\*8\*(R", and
\&\*(L"o\*/\*(R" may be understood as \f(CW\*(C`\ew\*(C'\fR characters.
.PP
Da \f(CW\*(C`LC_CTYPE\*(C'\fR locale also serves up tha map used up in transliterating
charactas between lower n' uppercase.  This affects tha case-mapping
functions\*(--\fIlc()\fR, lcfirst, \fIuc()\fR, n' \fIucfirst()\fR; case-mapping
interpolation wit \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR up in double-quoted strings
and \f(CW\*(C`s///\*(C'\fR substitutions; n' case-independent regular expression
pattern matchin rockin tha \f(CW\*(C`i\*(C'\fR modifier.
.PP
Finally, \f(CW\*(C`LC_CTYPE\*(C'\fR affects tha \s-1POSIX\s0 character-class test
functions\*(--\fIisalpha()\fR, \fIislower()\fR, n' so on. I aint talkin' bout chicken n' gravy biatch.  For example, if you move
from tha \*(L"C\*(R" locale ta a 7\-bit Scandinavian one, you may find\*(--possibly
to yo' surprise\*(--that \*(L"|\*(R" moves from tha \fIispunct()\fR class ta \fIisalpha()\fR.
Unfortunately, dis creates big-ass problems fo' regular expressions. \*(L"|\*(R" still
means alternation even though it matches \f(CW\*(C`\ew\*(C'\fR.
.PP
Note dat there be like all dem thangs dat is unaffected by the
current locale.  All tha escape sequences fo' particular characters,
\&\f(CW\*(C`\en\*(C'\fR fo' example, always mean tha platformz natizzle one.  This means,
for example, dat \f(CW\*(C`\eN\*(C'\fR up in regular expressions (every character
but new-line) work on tha platform characta set.
.PP
\&\fBNote:\fR A fucked up or malicious \f(CW\*(C`LC_CTYPE\*(C'\fR locale definizzle may result
in clearly ineligible charactas bein considered ta be alphanumeric by
your application. I aint talkin' bout chicken n' gravy biatch.  For strict matchin of (mundane) \s-1ASCII\s0 lettas and
digits\*(--for example, up in command strings\*(--locale\-aware applications
should use \f(CW\*(C`\ew\*(C'\fR wit tha \f(CW\*(C`/a\*(C'\fR regular expression modifier n' shit.  See \*(L"\s-1SECURITY\*(R"\s0.
.SS "Category \s-1LC_NUMERIC:\s0 Numeric Formatting"
.IX Subsection "Category LC_NUMERIC: Numeric Formatting"
Afta a proper \fIPOSIX::setlocale()\fR call, Perl obeys tha \f(CW\*(C`LC_NUMERIC\*(C'\fR
locale shiznit, which controls a applicationz scam of how tha fuck numbers
should be formatted fo' human readabilitizzle by tha \fIprintf()\fR, \fIsprintf()\fR, and
\&\fIwrite()\fR functions. Right back up in yo muthafuckin ass. String-to-numeric conversion by tha \fIPOSIX::strtod()\fR
function be also affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In most implementations tha only effect is to
change tha characta used fo' tha decimal point\*(--like from \*(L".\*(R"  ta \*(L",\*(R".
These functions aren't aware of such sicktizzles as thousandz separation and
so on. I aint talkin' bout chicken n' gravy biatch. (See \*(L"Da localeconv function\*(R" if you care bout these thangs.)
.PP
Output produced by \fIprint()\fR be also affected by tha current locale: it
correspondz ta what tha fuck you'd git from \fIprintf()\fR up in tha \*(L"C\*(R" locale.  The
same is legit fo' Perlz internal conversions between numeric and
strin formats:
.PP
.Vb 1
\&        use POSIX qw(strtod setlocale LC_NUMERIC);
\&
\&        setlocale LC_NUMERIC, "";
\&
\&        $n = 5/2;   # Assign numeric 2.5 ta $n
\&
\&        $a = " $n"; # Locale\-dependent conversion ta string
\&
\&        print "half five is $n\en";       # Locale\-dependent output
\&
\&        printf "half five is %g\en", $n;  # Locale\-dependent output
\&
\&        print "DECIMAL POINT IS COMMA\en"
\&            if $n == (strtod("2,5"))[0]; # Locale\-dependent conversion
.Ve
.PP
See also I18N::Langinfo n' \f(CW\*(C`RADIXCHAR\*(C'\fR.
.SS "Category \s-1LC_MONETARY:\s0 Formattin of monetary amounts"
.IX Subsection "Category LC_MONETARY: Formattin of monetary amounts"
Da C standard defines tha \f(CW\*(C`LC_MONETARY\*(C'\fR category yo, but not a gangbangin' function
that be affected by its contents, n' you can put dat on yo' toast.  (Those wit experience of standards
committees will recognize dat tha hustlin crew decided ta punt on the
issue.)  Consequently, Perl takes no notice of dat shit.  If you straight-up want
to use \f(CW\*(C`LC_MONETARY\*(C'\fR, you can query its contents\*(--see
\&\*(L"Da localeconv function\*(R"\-\-and use tha shiznit dat it returns up in your
applicationz own formattin of currency amounts, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat you may well
find dat tha shiznit, voluminous n' complex though it may be, still
does not like hook up yo' requirements: currency formattin be a hard nut
to crack.
.PP
See also I18N::Langinfo n' \f(CW\*(C`CRNCYSTR\*(C'\fR.
.SS "\s-1LC_TIME\s0"
.IX Subsection "LC_TIME"
Output produced by \fIPOSIX::strftime()\fR, which buildz a gangbangin' formatted
human-readable date/time string, be affected by tha current \f(CW\*(C`LC_TIME\*(C'\fR
locale.  Thus, up in a French locale, tha output produced by tha \f(CW%B\fR
format element (full month name) fo' tha straight-up original gangsta month of tha year would
be \*(L"janvier\*(R".  Herez how tha fuck ta git a list of long month names up in the
current locale:
.PP
.Vb 5
\&        use POSIX qw(strftime);
\&        fo' (0..11) {
\&            $long_month_name[$_] =
\&                strftime("%B", 0, 0, 0, 1, $_, 96);
\&        }
.Ve
.PP
Note: \f(CW\*(C`use locale\*(C'\fR aint needed up in dis example: as a gangbangin' function that
exists only ta generate locale-dependent thangs up in dis biatch, \fIstrftime()\fR always
obeys tha current \f(CW\*(C`LC_TIME\*(C'\fR locale.
.PP
See also I18N::Langinfo n' \f(CW\*(C`ABDAY_1\*(C'\fR..\f(CW\*(C`ABDAY_7\*(C'\fR, \f(CW\*(C`DAY_1\*(C'\fR..\f(CW\*(C`DAY_7\*(C'\fR,
\&\f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR, n' \f(CW\*(C`ABMON_1\*(C'\fR..\f(CW\*(C`ABMON_12\*(C'\fR.
.SS "Other categories"
.IX Subsection "Other categories"
Da remainin locale category, \f(CW\*(C`LC_MESSAGES\*(C'\fR (possibly supplemented
by others up in particular implementations) aint currently used by
Perl\*(--except possibly ta affect tha behavior of library functions
called by extensions outside tha standard Perl distribution n' by the
operatin system n' its utilities. Put ya muthafuckin choppers up if ya feel dis!  Note especially dat tha string
value of \f(CW$!\fR n' tha error lyrics given by external utilitizzles may
be chizzled by \f(CW\*(C`LC_MESSAGES\*(C'\fR.  If you wanna have portable error
codes, use \f(CW\*(C`%!\*(C'\fR.  See Errno.
.SH "SECURITY"
.IX Header "SECURITY"
Although tha main rap of Perl securitizzle thangs can be found in
perlsec, a gangbangin' finger-lickin' rap of Perlz locale handlin would be incomplete
if it did not draw yo' attention ta locale-dependent securitizzle issues.
Locales\*(--particularly on systems dat allow unprivileged playas to
build they own locales\*(--are untrustworthy.  A malicious (or just plain
broken) locale can cook up a locale-aware application give unexpected
results, n' you can put dat on yo' toast.  Here is all dem possibilities:
.IP "\(bu" 4
Regular expression checks fo' safe file names or mail addresses using
\&\f(CW\*(C`\ew\*(C'\fR may be spoofed by a \f(CW\*(C`LC_CTYPE\*(C'\fR locale dat fronts that
charactas like fuckin \*(L">\*(R" n' \*(L"|\*(R" is alphanumeric.
.IP "\(bu" 4
Strin interpolation wit case-mapping, as in, say, \f(CW\*(C`$dest =
"C:\eU$name.$ext"\*(C'\fR, may produce fucked up thangs up in dis biatch if a funky-ass bogus \s-1LC_CTYPE\s0
case-mappin table is up in effect.
.IP "\(bu" 4
A sneaky \f(CW\*(C`LC_COLLATE\*(C'\fR locale could result up in tha namez of hustlas with
\&\*(L"D\*(R" grades appearin ahead of dem wit \*(L"A\*(R"s.
.IP "\(bu" 4
An application dat takes tha shiznit ta use shiznit in
\&\f(CW\*(C`LC_MONETARY\*(C'\fR may format debits as if they was credits n' vice versa
if dat locale has been subverted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Or it might make payments up in \s-1US\s0
dollars instead of Hong Kong dollars.
.IP "\(bu" 4
Da date n' dizzle names up in dates formatted by \fIstrftime()\fR could be
manipulated ta advantage by a malicious user able ta subvert the
\&\f(CW\*(C`LC_DATE\*(C'\fR locale.  (\*(L"Look\*(--it say I wasn't up in tha buildin on
Sunday.\*(R")
.PP
Such dangers is not peculiar ta tha locale system: any aspect of an
applicationz environment which may be modified maliciously presents
similar challenges.  Similarly, they is not specific ta Perl: any
programmin language dat allows you ta write programs dat take
account of they environment exposes you ta these issues.
.PP
Perl cannot protect you from all possibilitizzles shown up in the
examples\*(--there is no substitute fo' yo' own vigilance\*(--but, when
\&\f(CW\*(C`use locale\*(C'\fR is up in effect, Perl uses tha taintin mechanizzle (see
perlsec) ta mark strang thangs up in dis biatch dat become locale-dependent, and
which may be untrustworthy up in consequence.  Here be a summary of the
taintin behavior of operators n' functions dat may be affected by
the locale:
.IP "\(bu" 4
\&\fBComparison operators\fR (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`gt\*(C'\fR n' \f(CW\*(C`cmp\*(C'\fR):
.Sp
Scalar true/false (or less/equal/greater) result is never tainted.
.IP "\(bu" 4
\&\fBCase-mappin interpolation\fR (with \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR)
.Sp
Result strang containin interpolated material is tainted if
\&\f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is up in effect.
.IP "\(bu" 4
\&\fBMatchin operator\fR (\f(CW\*(C`m//\*(C'\fR):
.Sp
Scalar true/false result never tainted.
.Sp
Subpatterns, either served up as a list-context result or as \f(CW$1\fR etc.
are tainted if \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR)
is up in effect, n' tha subpattern regular
expression gotz nuff \f(CW\*(C`\ew\*(C'\fR (to match a alphanumeric character), \f(CW\*(C`\eW\*(C'\fR
(non-alphanumeric character), \f(CW\*(C`\es\*(C'\fR (whitespace character), or \f(CW\*(C`\eS\*(C'\fR
(non whitespace character).  Da matched-pattern variable, $&, $`
(pre-match), $' (post-match), n' $+ (last match) is also tainted if
\&\f(CW\*(C`use locale\*(C'\fR is up in effect n' tha regular expression gotz nuff \f(CW\*(C`\ew\*(C'\fR,
\&\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR.
.IP "\(bu" 4
\&\fBSubstitution operator\fR (\f(CW\*(C`s///\*(C'\fR):
.Sp
Has tha same ol' dirty behavior as tha match operator. Shiiit, dis aint no joke.  Also, tha left
operand of \f(CW\*(C`=~\*(C'\fR becomes tainted when \f(CW\*(C`use locale\*(C'\fR
(but not \f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is up in effect if modified as
a result of a substitution based on a regular
expression match involvin \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, or \f(CW\*(C`\eS\*(C'\fR; or of
case-mappin wit \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR,\f(CW\*(C`\eu\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR.
.IP "\(bu" 4
\&\fBOutput formattin functions\fR (\fIprintf()\fR n' \fIwrite()\fR):
.Sp
Results is never tainted cuz otherwise even output from print,
for example \f(CW\*(C`print(1/7)\*(C'\fR, should be tainted if \f(CW\*(C`use locale\*(C'\fR is in
effect.
.IP "\(bu" 4
\&\fBCase-mappin functions\fR (\fIlc()\fR, \fIlcfirst()\fR, \fIuc()\fR, \fIucfirst()\fR):
.Sp
Results is tainted if \f(CW\*(C`use locale\*(C'\fR (but not
\&\f(CW\*(C`use\ locale\ \*(Aq:not_characters\*(Aq\*(C'\fR) is up in effect.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 locale-dependent functions\fR (\fIlocaleconv()\fR, \fIstrcoll()\fR,
\&\fIstrftime()\fR, \fIstrxfrm()\fR):
.Sp
Results is never tainted.
.IP "\(bu" 4
\&\fB\s-1POSIX\s0 characta class tests\fR (\fIisalnum()\fR, \fIisalpha()\fR, \fIisdigit()\fR,
\&\fIisgraph()\fR, \fIislower()\fR, \fIisprint()\fR, \fIispunct()\fR, \fIisspace()\fR, \fIisupper()\fR,
\&\fIisxdigit()\fR):
.Sp
True/false thangs up in dis biatch is never tainted.
.PP
Three examplez illustrate locale-dependent tainting.
Da first program, which ignores its locale, won't run: a value taken
directly from tha command line may not be used ta name a output file
when taint checks is enabled.
.PP
.Vb 2
\&        #/usr/local/bin/perl \-T
\&        # Run wit taint checking
\&
\&        # Command line sanitizzle check omitted...
\&        $tainted_output_file = shift;
\&
\&        open(F, ">$tainted_output_file")
\&            or warn "Open of $tainted_output_file failed: $!\en";
.Ve
.PP
Da program can be made ta run by \*(L"laundering\*(R" tha tainted value through
a regular expression: tha second example\*(--which still ignores locale
information\*(--runs, bustin tha file named on its command line
if it can.
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $untainted_output_file = $&;
\&
\&        open(F, ">$untainted_output_file")
\&            or warn "Open of $untainted_output_file failed: $!\en";
.Ve
.PP
Compare dis wit a similar but locale-aware program:
.PP
.Vb 1
\&        #/usr/local/bin/perl \-T
\&
\&        $tainted_output_file = shift;
\&        use locale;
\&        $tainted_output_file =~ m%[\ew/]+%;
\&        $localized_output_file = $&;
\&
\&        open(F, ">$localized_output_file")
\&            or warn "Open of $localized_output_file failed: $!\en";
.Ve
.PP
This third program fails ta run cuz $& is tainted: it is tha result
of a match involvin \f(CW\*(C`\ew\*(C'\fR while \f(CW\*(C`use locale\*(C'\fR is up in effect.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.IP "\s-1PERL_BADLANG\s0" 12
.IX Item "PERL_BADLANG"
A strang dat can suppress Perlz warnin bout failed locale settings
at startup.  Failure can occur if tha locale support up in tha operating
system is lackin (broken) up in some way\*(--or if you mistyped tha name of
a locale when you set up yo' environment.  If dis environment
variable be absent, or has a value dat do not evaluate ta integer
zero\*(--that is, \*(L"0\*(R" or ""\-\- Perl will diss bout locale setting
failures.
.Sp
\&\fB\s-1NOTE\s0\fR: \s-1PERL_BADLANG\s0 only gives you a way ta hide tha warnin message.
Da message  drops some lyrics ta bout some problem up in yo' systemz locale support,
and you should rewind what tha fuck tha problem is.
.PP
Da followin environment variablez is not specific ta Perl: They are
part of tha standardized (\s-1ISO C, XPG4, POSIX 1\s0.c) \fIsetlocale()\fR method
for controllin a applicationz opinion on data.
.IP "\s-1LC_ALL\s0" 12
.IX Item "LC_ALL"
\&\f(CW\*(C`LC_ALL\*(C'\fR is tha \*(L"override-all\*(R" locale environment variable. If
set, it overrides all tha rest of tha locale environment variables.
.IP "\s-1LANGUAGE\s0" 12
.IX Item "LANGUAGE"
\&\fB\s-1NOTE\s0\fR: \f(CW\*(C`LANGUAGE\*(C'\fR be a \s-1GNU\s0 extension, it affects you only if you
are rockin tha \s-1GNU\s0 libc.  This is tha case if yo ass is rockin e.g. Linux.
If yo ass is rockin \*(L"commercial\*(R" Unixes yo ass is most probably \fInot\fR
usin \s-1GNU\s0 libc n' you can ignore \f(CW\*(C`LANGUAGE\*(C'\fR.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat up in tha case yo ass is rockin \f(CW\*(C`LANGUAGE\*(C'\fR: it affects the
language of shiznital, warning, n' error lyrics output by
commandz (in other lyrics, itz like \f(CW\*(C`LC_MESSAGES\*(C'\fR) but it has higher
prioritizzle than \f(CW\*(C`LC_ALL\*(C'\fR.  Mo'over, it aint a single value but
instead a \*(L"path\*(R" (\*(L":\*(R"\-separated list) of \fIlanguages\fR (not locales).
See tha \s-1GNU \s0\f(CW\*(C`gettext\*(C'\fR library documentation fo' mo' shiznit.
.IP "\s-1LC_CTYPE\s0" 12
.IX Item "LC_CTYPE"
In tha absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_CTYPE\*(C'\fR chizzlez tha characta type
locale.  In tha absence of both \f(CW\*(C`LC_ALL\*(C'\fR n' \f(CW\*(C`LC_CTYPE\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses tha characta type locale.
.IP "\s-1LC_COLLATE\s0" 12
.IX Item "LC_COLLATE"
In tha absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_COLLATE\*(C'\fR chizzlez tha collation
(sorting) locale.  In tha absence of both \f(CW\*(C`LC_ALL\*(C'\fR n' \f(CW\*(C`LC_COLLATE\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chizzlez tha collation locale.
.IP "\s-1LC_MONETARY\s0" 12
.IX Item "LC_MONETARY"
In tha absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_MONETARY\*(C'\fR chizzlez tha monetary
formattin locale.  In tha absence of both \f(CW\*(C`LC_ALL\*(C'\fR n' \f(CW\*(C`LC_MONETARY\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chizzlez tha monetary formattin locale.
.IP "\s-1LC_NUMERIC\s0" 12
.IX Item "LC_NUMERIC"
In tha absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_NUMERIC\*(C'\fR chizzlez tha numeric format
locale.  In tha absence of both \f(CW\*(C`LC_ALL\*(C'\fR n' \f(CW\*(C`LC_NUMERIC\*(C'\fR, \f(CW\*(C`LANG\*(C'\fR
chooses tha numeric format.
.IP "\s-1LC_TIME\s0" 12
.IX Item "LC_TIME"
In tha absence of \f(CW\*(C`LC_ALL\*(C'\fR, \f(CW\*(C`LC_TIME\*(C'\fR chizzlez tha date n' time
formattin locale.  In tha absence of both \f(CW\*(C`LC_ALL\*(C'\fR n' \f(CW\*(C`LC_TIME\*(C'\fR,
\&\f(CW\*(C`LANG\*(C'\fR chizzlez tha date n' time formattin locale.
.IP "\s-1LANG\s0" 12
.IX Item "LANG"
\&\f(CW\*(C`LANG\*(C'\fR is tha \*(L"catch-all\*(R" locale environment variable. If it is set, it
is used as tha last resort afta tha overall \f(CW\*(C`LC_ALL\*(C'\fR n' the
category-specific \f(CW\*(C`LC_...\*(C'\fR.
.SS "Examples"
.IX Subsection "Examples"
Da \s-1LC_NUMERIC\s0 controls tha numeric output:
.PP
.Vb 4
\&   use locale;
\&   use POSIX qw(locale_h); # Imports setlocale() n' tha LC_ constants.
\&   setlocale(LC_NUMERIC, "fr_FR") or take a thugged-out dirtnap "Pardon";
\&   printf "%g\en", 1.23; # If tha "fr_FR" succeeded, probably shows 1,23.
.Ve
.PP
and also how tha fuck strings is parsed by \fIPOSIX::strtod()\fR as numbers:
.PP
.Vb 5
\&   use locale;
\&   use POSIX qw(locale_h strtod);
\&   setlocale(LC_NUMERIC, "de_DE") or take a thugged-out dirtnap "Entschuldigung";
\&   mah $x = strtod("2,34") + 5;
\&   print $x, "\en"; # Probably shows 7,34.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS "Backward compatibility"
.IX Subsection "Backward compatibility"
Versionz of Perl prior ta 5.004 \fBmostly\fR ignored locale shiznit,
generally behavin as if suttin' similar ta tha \f(CW"C"\fR locale were
always up in force, even if tha program environment suggested otherwise
(see \*(L"Da setlocale function\*(R").  By default, Perl still behaves this
way fo' backward compatibility.  If you want a Perl application ta pay
attention ta locale shiznit, you \fBmust\fR use tha \f(CW\*(C`use\ locale\*(C'\fR
pragma (see \*(L"Da use locale pragma\*(R") or, up in tha unlikely event
that you wanna do so fo' just pattern matching, the
\&\f(CW\*(C`/l\*(C'\fR regular expression modifier (see \*(L"Characta set
modifiers\*(R" up in perlre) ta instruct it ta do so.
.PP
Versionz of Perl from 5.002 ta 5.003 did use tha \f(CW\*(C`LC_CTYPE\*(C'\fR
information if available; dat is, \f(CW\*(C`\ew\*(C'\fR did KNOW what
were tha lettas accordin ta tha locale environment variables.
Da problem was dat tha user had no control over tha feature:
if tha C library supported locales, Perl used em.
.SS "I18N:Collate obsolete"
.IX Subsection "I18N:Collate obsolete"
In versionz of Perl prior ta 5.004, per-locale collation was possible
usin tha \f(CW\*(C`I18N::Collate\*(C'\fR library module.  This module is now mildly
obsolete n' should be avoided up in freshly smoked up applications.  Da \f(CW\*(C`LC_COLLATE\*(C'\fR
functionalitizzle is now integrated tha fuck into tha Perl core language: One can
use locale-specific scalar data straight-up normally wit \f(CW\*(C`use locale\*(C'\fR,
so there is no longer any need ta juggle wit tha scalar references of
\&\f(CW\*(C`I18N::Collate\*(C'\fR.
.SS "Sort speed n' memory use impacts"
.IX Subsection "Sort speed n' memory use impacts"
Comparin n' sortin by locale is probably slower than tha default
sorting; slow-downz of two ta four times done been observed. Y'all KNOW dat shit, muthafucka!  It will
also consume mo' memory: once a Perl scalar variable has participated
in any strang comparison or sortin operation obeyin tha locale
collation rules, it will take 3\-15 times mo' memory than before.  (The
exact multiplier dependz on tha stringz contents, tha operatin system
and tha locale.) These downsides is dictated mo' by tha operating
systemz implementation of tha locale system than by Perl.
.SS "\fIwrite()\fP n' \s-1LC_NUMERIC\s0"
.IX Subsection "write() n' LC_NUMERIC"
If a programz environment specifies a \s-1LC_NUMERIC\s0 locale n' \f(CW\*(C`use
locale\*(C'\fR is up in effect when tha format is declared, tha locale is used
to specify tha decimal point characta up in formatted output.  Formatted
output cannot be controlled by \f(CW\*(C`use locale\*(C'\fR all up in tha time when \fIwrite()\fR
is called.
.SS "Freely available locale definitions"
.IX Subsection "Freely available locale definitions"
Da Unicode \s-1CLDR\s0 project extracts tha \s-1POSIX\s0 portion of nuff of its
locales, available at
.PP
.Vb 1
\&  http://unicode.org/Public/cldr/latest/
.Ve
.PP
There be a big-ass collection of locale definitions at:
.PP
.Vb 1
\&  http://std.dkuug.dk/i18n/WG15\-collection/locales/
.Ve
.PP
Yo ass should be aware dat it is
unsupported, n' aint fronted ta be fit fo' any purpose.  If your
system allows installation of arbitrary locales, you may find the
definitions useful as they are, or as a funky-ass basis fo' tha pimpment of
your own locales.
.SS "I18n n' l10n"
.IX Subsection "I18n n' l10n"
\&\*(L"Internationalization\*(R" is often abbreviated as \fBi18n\fR cuz its first
and last lettas is separated by eighteen others.  (Yo ass may guess why
the internalin ... internaliti ... i18n tendz ta git abbreviated.)  In
the same way, \*(L"localization\*(R" is often abbreviated ta \fBl10n\fR.
.SS "An imslick standard"
.IX Subsection "An imslick standard"
Internationalization, as defined up in tha C n' \s-1POSIX\s0 standards, can be
criticized as incomplete, ungainly, n' havin too big-ass a granularity.
(Localez apply ta a whole process, when it would arguably be mo' useful
to have dem apply ta a single thread, window group, or whatever.)  They
also gotz a tendency, like standardz groups, ta divide tha ghetto into
nations, when we all know dat tha ghetto can equally well be divided
into bankers, bikers, gamers, n' so on.
.SH "Unicode n' UTF\-8"
.IX Header "Unicode n' UTF-8"
Da support of Unicode is freshly smoked up startin from Perl version v5.6, n' mo' fully
implemented up in version v5.8 n' later n' shit.  See perluniintro.  It is
strongly recommended dat when combinin Unicode n' locale (startin in
v5.16), you use
.PP
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.PP
When dis form of tha pragma is used, only tha non-characta portions of
localez is used by Perl, fo' example \f(CW\*(C`LC_NUMERIC\*(C'\fR.  Perl assumes that
you have translated all tha charactas it is ta operate on tha fuck into Unicode
(actually tha platformz natizzle characta set (\s-1ASCII\s0 or \s-1EBCDIC\s0) plus
Unicode).  For data up in files, dis can conveniently be done by also
specifying
.PP
.Vb 1
\&    use open \*(Aq:locale\*(Aq;
.Ve
.PP
This pragma arranges fo' all inputs from filez ta be translated into
Unicode from tha current locale as specified up in tha environment (see
\&\*(L"\s-1ENVIRONMENT\*(R"\s0), n' all outputs ta filez ta be translated back
into tha locale.  (See open).  On a per-filehandle basis, you can
instead use tha PerlIO::locale module, or tha Encode::Locale
module, both available from \s-1CPAN. \s0 Da latta module also has methodz to
ease tha handlin of \f(CW\*(C`ARGV\*(C'\fR n' environment variables, n' can be used
on individual strings.  Also, if you know dat all yo' localez will be
\&\s-1UTF\-8,\s0 as nuff is these days, you can use tha \fB\-C\fR
command line switch.
.PP
This form of tha pragma allows essentially seamless handlin of locales
with Unicode.  Da collation order is ghon be Unicode's.  It be strongly
recommended dat when you need ta order n' sort strings dat you use
the standard module Unicode::Collate which gives much betta thangs up in dis biatch
in nuff instances than you can git wit tha old-style locale handling.
.PP
For pre\-v5.16 Perls, or if you use tha locale pragma without the
\&\f(CW\*(C`:not_characters\*(C'\fR parameter, Perl tries ta work wit both Unicode and
locales\*(--but there be problems.
.PP
Perl do not handle multi-byte localez up in dis case, like fuckin have been
used fo' various
Asian languages, like fuckin Big5 or Shift \s-1JIS. \s0 But fuck dat shiznit yo, tha word on tha street is dat tha increasingly
common multi-byte \s-1UTF\-8\s0 locales, if properly implemented, may work
reasonably well (dependin on yo' C library implementation) up in this
form of tha locale pragma, simply cuz both
they n' Perl store charactas dat take up multiple bytes tha same ol' dirty way.
But fuck dat shiznit yo, tha word on tha street is dat some, if not most, C library implementations may not process
the charactas up in tha upper half of tha Latin\-1 range (128 \- 255)
properly under \s-1LC_CTYPE. \s0 To peep if a cold-ass lil characta be a particular type
under a locale, Perl uses tha functions like \f(CW\*(C`isalnum()\*(C'\fR.  Yo crazy-ass C
library may not work fo' \s-1UTF\-8\s0 localez wit dem functions, instead
only hustlin under tha newer wide library functions like \f(CW\*(C`iswalnum()\*(C'\fR.
.PP
Perl generally takes tha tack ta use locale rulez on code points dat can fit
in a single byte, n' Unicode rulez fo' dem dat can't (though this
aint uniformly applied, peep tha note all up in tha end of dis section).  This
prevents nuff problems up in localez dat aren't \s-1UTF\-8. \s0 Suppose tha locale
is \s-1ISO8859\-7,\s0 Greek.  Da characta at 0xD7 there be a cold-ass lil capital Chi. But
in tha \s-1ISO8859\-1\s0 locale, Latin1, it aint nuthin but a multiplication sign. I aint talkin' bout chicken n' gravy biatch.  Da \s-1POSIX\s0
regular expression characta class \f(CW\*(C`[[:alpha:]]\*(C'\fR will magically match
0xD7 up in tha Greek locale but not up in tha Latin one.
.PP
But fuck dat shiznit yo, tha word on tha street is dat there be places where dis breaks down. I aint talkin' bout chicken n' gravy biatch.  Certain constructs are
for Unicode only, like fuckin \f(CW\*(C`\ep{Alpha}\*(C'\fR.  They assume dat 0xD7 always has its
Unicode meanin (or tha equivalent on \s-1EBCDIC\s0 platforms).  Since Latin1 be a
subset of Unicode n' 0xD7 is tha multiplication sign up in both Latin1 and
Unicode, \f(CW\*(C`\ep{Alpha}\*(C'\fR aint NEVER gonna match it, regardless of locale.  A similar
issue occurs wit \f(CW\*(C`\eN{...}\*(C'\fR.  It be therefore a wack scam ta use \f(CW\*(C`\ep{}\*(C'\fR or
\&\f(CW\*(C`\eN{}\*(C'\fR under plain \f(CW\*(C`use locale\*(C'\fR\-\-\fIunless\fR you can guarantee dat the
locale is ghon be a \s-1ISO8859\-1. \s0 Use \s-1POSIX\s0 characta classes instead.
.PP
Another problem wit dis approach is dat operations dat cross the
single byte/multiple byte boundary is not well-defined, n' so are
disallowed. Y'all KNOW dat shit, muthafucka!  (This boundary is between tha codepoints at 255/256.).
For example, lower casin \s-1LATIN CAPITAL LETTER Y WITH DIAERESIS \s0(U+0178)
should return \s-1LATIN SMALL LETTER Y WITH DIAERESIS \s0(U+00FF).  But up in the
Greek locale, fo' example, there is no characta at 0xFF, n' Perl
has no way of knowin what tha fuck tha characta at 0xFF is straight-up supposed to
represent.  Thus it disallows tha operation. I aint talkin' bout chicken n' gravy biatch.  In dis mode, the
lowercase of U+0178 is itself.
.PP
Da same problems ensue if you enable automatic UTF\-8\-ification of your
standard file handles, default \f(CW\*(C`open()\*(C'\fR layer, n' \f(CW@ARGV\fR on non\-ISO8859\-1,
non\-UTF\-8 localez (by rockin either tha \fB\-C\fR command line switch or the
\&\f(CW\*(C`PERL_UNICODE\*(C'\fR environment variable; peep perlrun).
Things is read up in as \s-1UTF\-8,\s0 which would normally imply a Unicode
interpretation yo, but tha presence of a locale causes dem ta be interpreted
in dat locale instead. Y'all KNOW dat shit, muthafucka!  For example, a 0xD7 code point up in tha Unicode
input, which should mean tha multiplication sign, won't be interpreted by
Perl dat way under tha Greek locale.  This aint a problem
\&\fIprovided\fR you make certain dat all localez will always n' only be either
an \s-1ISO8859\-1,\s0 or, if you aint gots a thugged-out deficient C library, a \s-1UTF\-8\s0 locale.
.PP
Vendor localez is notoriously buggy, n' it is hard as fuck fo' Perl ta test
its locale-handlin code cuz dis interacts wit code dat Perl has no
control over; therefore tha locale-handlin code up in Perl may be buggy as
well.  (But fuck dat shiznit yo, tha word on tha street is dat tha Unicode-supplied localez should be better, and
there be a gangbangin' feed back mechanizzle ta erect any problems.  See
\&\*(L"Freely available locale definitions\*(R".)
.PP
If you have Perl v5.16, tha problems mentioned above go away if you use
the \f(CW\*(C`:not_characters\*(C'\fR parameta ta tha locale pragma (except fo' vendor
bugs up in tha non-characta portions).  If you aint gots v5.16, n' you
\&\fIdo\fR have localez dat work, rockin dem may be worthwhile fo' certain
specific purposes, as long as you keep up in mind tha gotchas already
mentioned. Y'all KNOW dat shit, muthafucka!  For example, if tha collation fo' yo' localez works, it
runs fasta under localez than under Unicode::Collate; n' you gain
access ta such thangs as tha local currency symbol n' tha namez of the
months n' minutez of tha week.  (But ta hammer home tha point, up in v5.16,
you git dis access without tha downsidez of localez by rockin the
\&\f(CW\*(C`:not_characters\*(C'\fR form of tha pragma.)
.PP
Note: Da policy of rockin locale rulez fo' code points dat can fit up in a
byte, n' Unicode rulez fo' dem dat can't aint uniformly applied.
Pre\-v5.12, dat shiznit was somewhat haphazard; up in v5.12 dat shiznit was applied fairly
consistently ta regular expression matchin except fo' bracketed
characta classes; up in v5.14 dat shiznit was extended ta all regex matches; n' in
v5.16 ta tha casin operations like fuckin \f(CW"\eL"\fR n' \f(CW\*(C`uc()\*(C'\fR.  For
collation, up in all releases, tha systemz \f(CW\*(C`strxfrm()\*(C'\fR function is called,
and whatever it do is what tha fuck you get.
.SH "BUGS"
.IX Header "BUGS"
.SS "Broken systems"
.IX Subsection "Broken systems"
In certain systems, tha operatin systemz locale support
is fucked up n' cannot be fixed or used by Perl.  Such deficiencies can
and will result up in mysterious hangs and/or Perl core dumps when
\&\f(CW\*(C`use locale\*(C'\fR is up in effect.  When confronted wit such a system,
please report up in excruciatin detail ta <\fIperlbug@perl.org\fR>, and
also contact yo' vendor: bug fixes may exist fo' these problems
in yo' operatin system.  Sometimes such bug fixes is called an
operatin system upgrade.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
I18N::Langinfo, perluniintro, perlunicode, open,
\&\*(L"isalnum\*(R" up in \s-1POSIX\s0, \*(L"isalpha\*(R" up in \s-1POSIX\s0,
\&\*(L"isdigit\*(R" up in \s-1POSIX\s0, \*(L"isgraph\*(R" up in \s-1POSIX\s0, \*(L"islower\*(R" up in \s-1POSIX\s0,
\&\*(L"isprint\*(R" up in \s-1POSIX\s0, \*(L"ispunct\*(R" up in \s-1POSIX\s0, \*(L"isspace\*(R" up in \s-1POSIX\s0,
\&\*(L"isupper\*(R" up in \s-1POSIX\s0, \*(L"isxdigit\*(R" up in \s-1POSIX\s0, \*(L"localeconv\*(R" up in \s-1POSIX\s0,
\&\*(L"setlocale\*(R" up in \s-1POSIX\s0, \*(L"strcoll\*(R" up in \s-1POSIX\s0, \*(L"strftime\*(R" up in \s-1POSIX\s0,
\&\*(L"strtod\*(R" up in \s-1POSIX\s0, \*(L"strxfrm\*(R" up in \s-1POSIX\s0.
.SH "HISTORY"
.IX Header "HISTORY"
Jarkko Hietaniemiz original gangsta \fIperli18n.pod\fR heavily jacked by Dominic
Dunlop, assisted by tha perl5\-porters.  Prose hit dat shiznit over a lil' bit by
Tomothy Christiansen, n' updated by Perl 5 porters.
