.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOOTUT 1"
.TH PERLOOTUT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlootut \- Object\-Oriented Programmin up in Perl Tutorial
.SH "DATE"
.IX Header "DATE"
This document was pimped up in February, 2011, n' tha last major
revision was up in February, 2013.
.PP
If yo ass is readin dis up in tha future then itz possible dat tha state
of tha art has chizzled. Y'all KNOW dat shit, muthafucka! We recommend you start by readin tha perlootut
document up in tha sickest fuckin stable release of Perl, rather than this
version.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document serves up a introduction ta object-oriented programming
in Perl. Well shiiiit, it begins wit a funky-ass brief overview of tha concepts behind object
oriented design. I aint talkin' bout chicken n' gravy biatch. Then it introduces nuff muthafuckin different \s-1OO\s0 systems from
\&\s-1CPAN\s0 <http://search.cpan.org> which build on top of what tha fuck Perl
provides.
.PP
By default, Perlz built-in \s-1OO\s0 system is straight-up minimal, leavin you to
do most of tha work. This minimalizzle done cooked up a shitload of sense up in 1994 yo, but
in tha muthafuckin years since Perl 5.0 we've peeped a fuckin shitload of common patterns
emerge up in Perl \s-1OO.\s0 Fortunately, Perlz flexibilitizzle has allowed a rich
ecosystem of Perl \s-1OO\s0 systems ta flourish.
.PP
If you wanna know how tha fuck Perl \s-1OO\s0 works under tha hood, tha perlobj
document explains tha nitty gritty details.
.PP
This document assumes dat you already KNOW tha basics of Perl
syntax, variable types, operators, n' subroutine calls. If you don't
understand these concepts yet, please read perlintro first. You
should also read tha perlsyn, perlop, n' perlsub documents.
.SH "OBJECT-ORIENTED FUNDAMENTALS"
.IX Header "OBJECT-ORIENTED FUNDAMENTALS"
Most object systems share a fuckin shitload of common concepts, n' you can put dat on yo' toast. You've probably
heard terms like \*(L"class\*(R", \*(L"object, \*(R"method\*(L", n' \*(R"attribute" before.
Understandin tha concepts will make it much easier ta read n' write
object-oriented code. If you already familiar wit these terms, you
should still skim dis section, since it explains each concept up in terms
of Perlz \s-1OO\s0 implementation.
.PP
Perlz \s-1OO\s0 system is class-based. Y'all KNOW dat shit, muthafucka! Class-based \s-1OO\s0 is fairly common. I aint talkin' bout chicken n' gravy biatch. It's
used by Java, \*(C+, C#, Python, Ruby, n' nuff other languages. There
are other object orientation paradigms as well. JavaScript is da most thugged-out
popular language ta use another paradigm. JavaScriptz \s-1OO\s0 system is
prototype-based.
.SS "Object"
.IX Subsection "Object"
An \fBobject\fR be a thugged-out data structure dat bundlez together data and
subroutines which operate on dat data fo' realz. An objectz data is called
\&\fBattributes\fR, n' its subroutines is called \fBmethods\fR fo' realz. An object can
be thought of as a noun (a person, a wizzy service, a cold-ass lil computer).
.PP
An object represents a single discrete thang. For example, a object
might represent a gangbangin' file. Da attributes fo' a gangbangin' file object might include
its path, content, n' last modification time. If we pimped a object
to represent \fI/etc/hostname\fR on a machine named \*(L"foo.example.com\*(R",
that objectz path would be \*(L"/etc/hostname\*(R", its content would be
\&\*(L"foo\en\*(R", n' itz last modification time would be 1304974868 seconds
since tha beginnin of tha epoch.
.PP
Da methodz associated wit a gangbangin' file might include \f(CW\*(C`rename()\*(C'\fR and
\&\f(CW\*(C`write()\*(C'\fR.
.PP
In Perl most objects is hashes yo, but tha \s-1OO\s0 systems we recommend keep
you from havin ta worry bout all dis bullshit. In practice, itz dopest ta consider
an objectz internal data structure opaque.
.SS "Class"
.IX Subsection "Class"
A \fBclass\fR defines tha behavior of a cold-ass lil category of objects fo' realz. A class be a
name fo' a cold-ass lil category (like \*(L"File\*(R"), n' a cold-ass lil class also defines the
behavior of objects up in dat category.
.PP
All objects belong ta a specific class. For example, our
\&\fI/etc/hostname\fR object belongs ta tha \f(CW\*(C`File\*(C'\fR class. When we want to
create a specific object, we start wit its class, n' \fBconstruct\fR or
\&\fBinstantiate\fR a object fo' realz. A specific object is often referred ta as an
\&\fBinstance\fR of a cold-ass lil class.
.PP
In Perl, any package can be a cold-ass lil class. Da difference between a package
which be a cold-ass lil class n' one which aint is based on how tha fuck tha package is
used. Y'all KNOW dat shit, muthafucka! Herez our \*(L"class declaration\*(R" fo' tha \f(CW\*(C`File\*(C'\fR class:
.PP
.Vb 1
\&  package File;
.Ve
.PP
In Perl, there is no special keyword fo' constructin a object.
But fuck dat shiznit yo, tha word on tha street is dat most \s-1OO\s0 modulez on \s-1CPAN\s0 bust a method named \f(CW\*(C`new()\*(C'\fR to
construct a freshly smoked up object:
.PP
.Vb 5
\&  mah $hostname = File\->new(
\&      path          => \*(Aq/etc/hostname\*(Aq,
\&      content       => "foo\en",
\&      last_mod_time => 1304974868,
\&  );
.Ve
.PP
(Don't worry bout dat \f(CW\*(C`\->\*(C'\fR operator, it is ghon be explained
later.)
.PP
\fIBlessing\fR
.IX Subsection "Blessing"
.PP
As we holla'd earlier, most Perl objects is hashes yo, but a object can be
an instizzle of any Perl data type (scalar, array, etc.). Turnin a
plain data structure tha fuck into a object is done by \fBblessing\fR dat data
structure rockin Perlz \f(CW\*(C`bless\*(C'\fR function.
.PP
While we straight fuckin suggest you don't build yo' objects from scratch,
you should know tha term \fBbless\fR fo' realz. A \fBblessed\fR data structure (aka \*(L"a
referent\*(R") be a object. We sometimes say dat a object has been
\&\*(L"blessed tha fuck into a cold-ass lil class\*(R".
.PP
Once a referent has been pimped, tha \f(CW\*(C`blessed\*(C'\fR function from the
Scalar::Util core module can tell our asses its class name. This subroutine
returns a objectz class when passed a object, n' false otherwise.
.PP
.Vb 1
\&  use Scalar::Util \*(Aqblessed\*(Aq;
\&
\&  print pimped($hash);      # undef
\&  print pimped($hostname);  # File
.Ve
.PP
\fIConstructor\fR
.IX Subsection "Constructor"
.PP
A \fBconstructor\fR creates a freshly smoked up object. In Perl, a cold-ass lil classs constructor
is just another method, unlike some other languages, which provide
syntax fo' constructors. Most Perl classes use \f(CW\*(C`new\*(C'\fR as tha name for
their constructor:
.PP
.Vb 1
\&  mah $file = File\->new(...);
.Ve
.SS "Methods"
.IX Subsection "Methods"
Yo ass already hustled dat a \fBmethod\fR be a subroutine dat operates on
an object. Yo ass can be thinkin of a method as tha thangs dat a object can
\&\fIdo\fR. If a object be a noun, then methodz is its verbs (save, print,
open).
.PP
In Perl, methodz is simply subroutines dat live up in a cold-ass lil classs package.
Methodz is always freestyled ta receive tha object as they first
argument:
.PP
.Vb 2
\&  sub print_info {
\&      mah $self = shift;
\&
\&      print "This file be at ", $self\->path, "\en";
\&  }
\&
\&  $file\->print_info;
\&  # Da file be at /etc/hostname
.Ve
.PP
What cook up a method special is \fIhow itz called\fR. Da arrow operator
(\f(CW\*(C`\->\*(C'\fR)  drops some lyrics ta Perl dat we is callin a method.
.PP
When we cook up a method call, Perl arranges fo' tha methodz \fBinvocant\fR
to be passed as tha straight-up original gangsta argument. \fBInvocant\fR be a gangbangin' fancy name fo' the
thang on tha left side of tha arrow. Da invocant can either be a cold-ass lil class
name or a object. We can also pass additionizzle arguments ta tha method:
.PP
.Vb 3
\&  sub print_info {
\&      mah $self   = shift;
\&      mah $prefix = shift // "This file be at ";
\&
\&      print $prefix, ", ", $self\->path, "\en";
\&  }
\&
\&  $file\->print_info("Da file is located at ");
\&  # Da file is located at /etc/hostname
.Ve
.SS "Attributes"
.IX Subsection "Attributes"
Each class can define its \fBattributes\fR. When we instantiate a object,
we assign joints ta dem attributes. For example, every last muthafuckin \f(CW\*(C`File\*(C'\fR object
has a path fo' realz. Attributes is sometimes called \fBproperties\fR.
.PP
Perl has no special syntax fo' attributes. Under tha hood, attributes
are often stored as keys up in tha objectz underlyin hash yo, but don't
worry bout all dis bullshit.
.PP
We recommend dat you only access attributes via \fBaccessor\fR methods.
These is methodz dat can git or set tha value of each attribute. We
saw dis earlier up in tha \f(CW\*(C`print_info()\*(C'\fR example, which calls \f(CW\*(C`$self\->path\*(C'\fR.
.PP
Yo ass might also peep tha terms \fBgetter\fR n' \fBsetter\fR. These is two
typez of accessors fo' realz. A getta gets tha attributez value, while a setter
sets it fo' realz. Another term fo' a setta is \fBmutator\fR
.PP
Attributes is typically defined as read-only or read-write. Read-only
attributes can only be set when tha object is first pimped, while
read-write attributes can be altered at any time.
.PP
Da value of a attribute may itself be another object. For example,
instead of returnin its last mod time as a number, tha \f(CW\*(C`File\*(C'\fR class
could return a DateTime object representin dat value.
.PP
It aint nuthin but possible ta git a cold-ass lil class dat do not expose any publicly
settable attributes. Not every last muthafuckin class has attributes n' methods.
.SS "Polymorphism"
.IX Subsection "Polymorphism"
\&\fBPolymorphism\fR be a gangbangin' fancy way of sayin dat objects from two
different classes share a \s-1API.\s0 For example, we could have \f(CW\*(C`File\*(C'\fR and
\&\f(CW\*(C`WebPage\*(C'\fR classes which both gotz a \f(CW\*(C`print_content()\*(C'\fR method. Y'all KNOW dat shit, muthafucka! This
method might produce different output fo' each class yo, but they share a
common intercourse.
.PP
While tha two classes may differ up in nuff ways, when it comes ta the
\&\f(CW\*(C`print_content()\*(C'\fR method, they is tha same. This means dat we can
try ta booty-call tha \f(CW\*(C`print_content()\*(C'\fR method on a object of either class,
and \fBwe don't gotta know what tha fuck class tha object belongs to!\fR
.PP
Polymorphizzle is one of tha key conceptz of object-oriented design.
.SS "Inheritance"
.IX Subsection "Inheritance"
\&\fBInheritance\fR lets you create a specialized version of a existing
class. Inheritizzle lets tha freshly smoked up class reuse tha methodz n' attributes
of another class.
.PP
For example, we could create a \f(CW\*(C`File::MP3\*(C'\fR class which \fBinherits\fR
from \f(CW\*(C`File\*(C'\fR fo' realz. An \f(CW\*(C`File::MP3\*(C'\fR \fBis-a\fR \fImore specific\fR type of \f(CW\*(C`File\*(C'\fR.
All mp3 filez is filez yo, but not all filez is mp3 files.
.PP
We often refer ta inheritizzle relationshizzlez as \fBparent-child\fR or
\&\f(CW\*(C`superclass/subclass\*(C'\fR relationshizzles. Right back up in yo muthafuckin ass. Sometimes we say dat tha child
has a \fBis-a\fR relationshizzle wit its parent class.
.PP
\&\f(CW\*(C`File\*(C'\fR be a \fBsuperclass\fR of \f(CW\*(C`File::MP3\*(C'\fR, n' \f(CW\*(C`File::MP3\*(C'\fR be a
\&\fBsubclass\fR of \f(CW\*(C`File\*(C'\fR.
.PP
.Vb 1
\&  package File::MP3;
\&
\&  use parent \*(AqFile\*(Aq;
.Ve
.PP
Da parent module is one of nuff muthafuckin ways dat Perl lets you define
inheritizzle relationshizzles.
.PP
Perl allows multiple inheritance, which means dat a cold-ass lil class can inherit
from multiple muthafathas. While dis is possible, we straight fuckin recommend
against dat shit. Generally, you can use \fBroles\fR ta do every last muthafuckin thang you can do
with multiple inheritizzle yo, but up in a cold-ass lil cleaner way.
.PP
Note dat there be a not a god damn thang wack wit definin multiple subclassez of a
given class. This is both common n' safe. For example, we might define
\&\f(CW\*(C`File::MP3::FixedBitrate\*(C'\fR n' \f(CW\*(C`File::MP3::VariableBitrate\*(C'\fR classes to
distinguish between different typez of mp3 file.
.PP
\fIOverridin methodz n' method resolution\fR
.IX Subsection "Overridin methodz n' method resolution"
.PP
Inheritizzle allows two classes ta share code. By default, every last muthafuckin method
in tha parent class be also available up in tha child. Y'all KNOW dat shit, muthafucka! Da lil pimp can
explicitly \fBoverride\fR a parentz method ta provide its own
implementation. I aint talkin' bout chicken n' gravy biatch. For example, if our crazy asses have a \f(CW\*(C`File::MP3\*(C'\fR object, it has
the \f(CW\*(C`print_info()\*(C'\fR method from \f(CW\*(C`File\*(C'\fR:
.PP
.Vb 6
\&  mah $cage = File::MP3\->new(
\&      path          => \*(Aqmp3s/My\-Body\-Is\-a\-Cage.mp3\*(Aq,
\&      content       => $mp3_data,
\&      last_mod_time => 1304974868,
\&      title         => \*(AqMy fuckin Body Is a Cage\*(Aq,
\&  );
\&
\&  $cage\->print_info;
\&  # Da file be at mp3s/My\-Body\-Is\-a\-Cage.mp3
.Ve
.PP
If we wanted ta include tha mp3z title up in tha greeting, we could
override tha method:
.PP
.Vb 1
\&  package File::MP3;
\&
\&  use parent \*(AqFile\*(Aq;
\&
\&  sub print_info {
\&      mah $self = shift;
\&
\&      print "This file be at ", $self\->path, "\en";
\&      print "Its title is ", $self\->title, "\en";
\&  }
\&
\&  $cage\->print_info;
\&  # Da file be at mp3s/My\-Body\-Is\-a\-Cage.mp3
\&  # Its title is My fuckin Body Is a Cage
.Ve
.PP
Da process of determinin what tha fuck method should be used is called
\&\fBmethod resolution\fR. What Perl do is peep tha objectz class
first (\f(CW\*(C`File::MP3\*(C'\fR up in dis case). If dat class defines tha method,
then dat classs version of tha method is called. Y'all KNOW dat shit, muthafucka! If not, Perl looks
at each parent class up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. For \f(CW\*(C`File::MP3\*(C'\fR, its only parent is
\&\f(CW\*(C`File\*(C'\fR. If \f(CW\*(C`File::MP3\*(C'\fR do not define tha method yo, but \f(CW\*(C`File\*(C'\fR do,
then Perl calls tha method up in \f(CW\*(C`File\*(C'\fR.
.PP
If \f(CW\*(C`File\*(C'\fR inherited from \f(CW\*(C`DataSource\*(C'\fR, which inherited from \f(CW\*(C`Thing\*(C'\fR,
then Perl would keep lookin \*(L"up tha chain\*(R" if necessary.
.PP
It be possible ta explicitly call a parent method from a cold-ass lil child:
.PP
.Vb 1
\&  package File::MP3;
\&
\&  use parent \*(AqFile\*(Aq;
\&
\&  sub print_info {
\&      mah $self = shift;
\&
\&      $self\->SUPER::print_info();
\&      print "Its title is ", $self\->title, "\en";
\&  }
.Ve
.PP
Da \f(CW\*(C`SUPER::\*(C'\fR bit  drops some lyrics ta Perl ta look fo' tha \f(CW\*(C`print_info()\*(C'\fR up in the
\&\f(CW\*(C`File::MP3\*(C'\fR classs inheritizzle chain. I aint talkin' bout chicken n' gravy biatch. When it findz tha parent class
that implements dis method, tha method is called.
.PP
We mentioned multiple inheritizzle earlier n' shit. Da main problem with
multiple inheritizzle is dat it pimped outly complicates method resolution.
See perlobj fo' mo' details.
.SS "Encapsulation"
.IX Subsection "Encapsulation"
\&\fBEncapsulation\fR is tha scam dat a object is opaque. When another
developer uses yo' class, they don't need ta know \fIhow\fR it is
implemented, they just need ta know \fIwhat\fR it do.
.PP
Encapsulation is blingin fo' nuff muthafuckin reasons. First, it allows you to
separate tha hood \s-1API\s0 from tha private implementation. I aint talkin' bout chicken n' gravy biatch. This means you
can chizzle dat implementation without breakin tha \s-1API.\s0
.PP
Second, when classes is well encapsulated, they become easier to
subclass. Ideally, a subclass uses tha same ol' dirty APIs ta access object data
that its parent class uses. In reality, subclassin sometimes involves
violatin encapsulation yo, but a phat \s-1API\s0 can minimize tha need ta do
this.
.PP
We mentioned earlier dat most Perl objects is implemented as hashes
under tha hood. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg! Da principle of encapsulation  drops some lyrics ta our asses dat we should
not rely on all dis bullshit. Instead, we should use accessor methodz ta access the
data up in dat hash. Da object systems dat we recommend below all
automate tha generation of accessor methods. If you use one of them,
you should never gotta access tha object as a hash directly.
.SS "Composition"
.IX Subsection "Composition"
In object-oriented code, we often find dat one object references
another object. This is called \fBcomposition\fR, or a \fBhas-a\fR
relationship.
.PP
Earlier, we mentioned dat tha \f(CW\*(C`File\*(C'\fR classs \f(CW\*(C`last_mod_time\*(C'\fR
accessor could return a DateTime object. This be a slick example
of composition. I aint talkin' bout chicken n' gravy biatch. We could go even further, n' make tha \f(CW\*(C`path\*(C'\fR and
\&\f(CW\*(C`content\*(C'\fR accessors return objects as well. Da \f(CW\*(C`File\*(C'\fR class would
then be \fBcomposed\fR of nuff muthafuckin other objects.
.SS "Roles"
.IX Subsection "Roles"
\&\fBRoles\fR is suttin' dat a cold-ass lil class \fIdoes\fR, rather than suttin' that
it \fIis\fR. Rolez is relatively freshly smoked up ta Perl yo, but have become rather
popular. Shiiit, dis aint no joke. Rolez is \fBapplied\fR ta classes. Right back up in yo muthafuckin ass. Sometimes we say dat classes
\&\fBconsume\fR roles.
.PP
Rolez is a alternatizzle ta inheritizzle fo' providin polymorphism.
Letz assume our crazy asses have two classes, \f(CW\*(C`Radio\*(C'\fR n' \f(CW\*(C`Computer\*(C'\fR. Both of
these thangs have on/off switches. Us thugs wanna model dat up in our class
definitions.
.PP
We could have both classes inherit from a cold-ass lil common parent, like
\&\f(CW\*(C`Machine\*(C'\fR yo, but not all machines have on/off switches. We could create
a parent class called \f(CW\*(C`HasOnOffSwitch\*(C'\fR yo, but dat is straight-up artificial.
Radios n' computas is not specializationz of dis parent. This
parent is straight-up a rather wack creation.
.PP
This is where rolez come in. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it cook up a shitload of sense ta create a
\&\f(CW\*(C`HasOnOffSwitch\*(C'\fR role n' apply it ta both classes. This role would
define a known \s-1API\s0 like providin \f(CW\*(C`turn_on()\*(C'\fR n' \f(CW\*(C`turn_off()\*(C'\fR
methods.
.PP
Perl aint gots any built-in way ta express roles. In tha past,
people just bit tha cap n' used multiple inheritance. Nowadays,
there is nuff muthafuckin phat chizzlez on \s-1CPAN\s0 fo' rockin roles.
.SS "When ta Use \s-1OO\s0"
.IX Subsection "When ta Use OO"
Object Orientation aint tha dopest solution ta every last muthafuckin problem. In \fIPerl
Best Practices\fR (copyright 2004, Published by O'Reilly Media, Inc.),
Damian Conway serves up a list of criteria ta use when decidin if \s-1OO\s0 is
the right fit fo' yo' problem:
.IP "\(bu" 4
Da system bein designed is large, or is likely ta become large.
.IP "\(bu" 4
Da data can be aggregated tha fuck into obvious structures, especially if
therez a big-ass amount of data up in each aggregate.
.IP "\(bu" 4
Da various typez of data aggregate form a natural hierarchy that
facilitates tha use of inheritizzle n' polymorphism.
.IP "\(bu" 4
Yo ass gotz a piece of data on which nuff different operations are
applied.
.IP "\(bu" 4
Yo ass need ta big-ass up tha same general operations on related types of
data yo, but wit slight variations dependin on tha specific type of data
the operations is applied to.
.IP "\(bu" 4
It aint nuthin but likely you gonna gotta add freshly smoked up data types later.
.IP "\(bu" 4
Da typical interactions between piecez of data is dopest represented by
operators.
.IP "\(bu" 4
Da implementation of individual componentz of tha system is likely to
change over time.
.IP "\(bu" 4
Da system design be already object-oriented.
.IP "\(bu" 4
Big-Ass numberz of other programmers is ghon be rockin yo' code modules.
.SH "PERL OO SYSTEMS"
.IX Header "PERL OO SYSTEMS"
As we mentioned before, Perlz built-in \s-1OO\s0 system is straight-up minimal yo, but
also like flexible. Over tha years, nuff playas have pimped systems
which build on top of Perlz built-in system ta provide mo' features
and convenience.
.PP
We straight fuckin recommend dat you use one of these systems. Even da most thugged-out
minimal of dem eliminates a shitload of repetitizzle boilerplate. There's
really no phat reason ta write yo' classes from scratch up in Perl.
.PP
If yo ass is horny bout tha guts underlyin these systems, check out
perlobj.
.SS "Moose"
.IX Subsection "Moose"
Moose bills itself as a \*(L"postmodern object system fo' Perl 5\*(R". Don't
be scared, tha \*(L"postmodern\*(R" label be a cold-ass lil callback ta Larryz description
of Perl as \*(L"the first postmodern computa language\*(R".
.PP
\&\f(CW\*(C`Moose\*(C'\fR serves up a cold-ass lil complete, modern \s-1OO\s0 system. Its freshest influence
is tha Common Lisp Object System yo, but it also borrows scams from
Smalltalk n' nuff muthafuckin other languages. \f(CW\*(C`Moose\*(C'\fR was pimped by Stevan
Little, n' draws heavily from his work on tha Perl 6 \s-1OO\s0 design.
.PP
Here is our \f(CW\*(C`File\*(C'\fR class rockin \f(CW\*(C`Moose\*(C'\fR:
.PP
.Vb 2
\&  package File;
\&  use Moose;
\&
\&  has path          => ( is => \*(Aqro\*(Aq );
\&  has content       => ( is => \*(Aqro\*(Aq );
\&  has last_mod_time => ( is => \*(Aqro\*(Aq );
\&
\&  sub print_info {
\&      mah $self = shift;
\&
\&      print "This file be at ", $self\->path, "\en";
\&  }
.Ve
.PP
\&\f(CW\*(C`Moose\*(C'\fR serves up a fuckin shitload of features:
.IP "\(bu" 4
Declaratizzle sugar
.Sp
\&\f(CW\*(C`Moose\*(C'\fR serves up a layer of declaratizzle \*(L"sugar\*(R" fo' definin classes.
That sugar is just a set of exported functions dat make declarin how
your class works simpla n' mo' palatable.  This lets you describe
\&\fIwhat\fR yo' class is, rather than havin ta tell Perl \fIhow\fR to
implement yo' class.
.Sp
Da \f(CW\*(C`has()\*(C'\fR subroutine declares a attribute, n' \f(CW\*(C`Moose\*(C'\fR
automatically creates accessors fo' these attributes. Well shiiiit, it also takes
care of bustin a \f(CW\*(C`new()\*(C'\fR method fo' yo thugged-out ass. This constructor knows
about tha attributes you declared, so you can set dem when bustin a
new \f(CW\*(C`File\*(C'\fR.
.IP "\(bu" 4
Rolez built-in
.Sp
\&\f(CW\*(C`Moose\*(C'\fR lets you define rolez tha same ol' dirty way you define classes:
.Sp
.Vb 2
\&  package HasOnOfSwitch;
\&  use Moose::Role;
\&
\&  has is_on => (
\&      is  => \*(Aqrw\*(Aq,
\&      isa => \*(AqBool\*(Aq,
\&  );
\&
\&  sub turn_on {
\&      mah $self = shift;
\&      $self\->is_on(1);
\&  }
\&
\&  sub turn_off {
\&      mah $self = shift;
\&      $self\->is_on(0);
\&  }
.Ve
.IP "\(bu" 4
A miniature type system
.Sp
In tha example above, you can peep dat we passed \f(CW\*(C`isa => \*(AqBool\*(Aq\*(C'\fR
to \f(CW\*(C`has()\*(C'\fR when bustin our \f(CW\*(C`is_on\*(C'\fR attribute. This  drops some lyrics ta \f(CW\*(C`Moose\*(C'\fR
that dis attribute must be a funky-ass boolean value. If we try ta set it ta an
invalid value, our code will throw a error.
.IP "\(bu" 4
Full introspection n' manipulation
.Sp
Perlz built-in introspection features is fairly minimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. \f(CW\*(C`Moose\*(C'\fR
buildz on top of dem n' creates a gangbangin' full introspection layer fo' your
classes. This lets you ask thangs like \*(L"what methodz do tha File
class implement?\*(R" It also lets you modify yo' classes
programmatically.
.IP "\(bu" 4
Self-hosted n' extensible
.Sp
\&\f(CW\*(C`Moose\*(C'\fR raps bout itself rockin its own introspection \s-1API.\s0 Besides
bein a cold-ass lil def trick, dis means dat you can extend \f(CW\*(C`Moose\*(C'\fR using
\&\f(CW\*(C`Moose\*(C'\fR itself.
.IP "\(bu" 4
Rich ecosystem
.Sp
There be a rich ecosystem of \f(CW\*(C`Moose\*(C'\fR extensions on \s-1CPAN\s0 under the
MooseX <http://search.cpan.org/search?query=MooseX&mode=dist>
namespace. In addition, nuff modulez on \s-1CPAN\s0 already use \f(CW\*(C`Moose\*(C'\fR,
providin you wit fuckin shitloadz of examplez ta learn from.
.IP "\(bu" 4
Many mo' features
.Sp
\&\f(CW\*(C`Moose\*(C'\fR be a straight-up bangin tool, n' we can't cover all of its
features here, so peek-a-boo, clear tha way, I be comin' thru fo'sho. We encourage you ta learn mo' by readin tha \f(CW\*(C`Moose\*(C'\fR
documentation, startin with
Moose::Manual <http://search.cpan.org/perldoc?Moose::Manual>.
.PP
Of course, \f(CW\*(C`Moose\*(C'\fR aint perfect.
.PP
\&\f(CW\*(C`Moose\*(C'\fR can make yo' code slower ta load. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`Moose\*(C'\fR itself is not
small, n' it do a \fIlot\fR of code generation when you define your
class. This code generation means dat yo' runtime code be as fast as
it can be yo, but you pay fo' dis when yo' modulez is first loaded.
.PP
This load time hit can be a problem when startup speed is blingin,
like fuckin wit a cold-ass lil command-line script or a \*(L"plain vanilla\*(R" \s-1CGI\s0 script that
must be loaded each time it is executed.
.PP
Before you panic, know dat nuff playas do use \f(CW\*(C`Moose\*(C'\fR for
command-line tools n' other startup-sensitizzle code. We encourage you
to try \f(CW\*(C`Moose\*(C'\fR up first before worryin bout startup speed.
.PP
\&\f(CW\*(C`Moose\*(C'\fR also has nuff muthafuckin dependencies on other modules. Most of these
are lil' small-ass stand-alone modules, a fuckin shitload of which done been spun off
from \f(CW\*(C`Moose\*(C'\fR. \f(CW\*(C`Moose\*(C'\fR itself, n' a shitload of its dependencies, require a
compila n' shit. If you need ta install yo' software on a system without a
compiler, or if havin \fIany\fR dependencies be a problem, then \f(CW\*(C`Moose\*(C'\fR
may not be right fo' yo thugged-out ass.
.PP
\fIMoo\fR
.IX Subsection "Moo"
.PP
If you try \f(CW\*(C`Moose\*(C'\fR n' find dat one of these thangs is preventin you
from rockin \f(CW\*(C`Moose\*(C'\fR, we encourage you ta consider Moo next. \f(CW\*(C`Moo\*(C'\fR
implements a subset of \f(CW\*(C`Moose\*(C'\fRz functionalitizzle up in a simpla package.
For most features dat it do implement, tha end-user \s-1API\s0 is
\&\fIidentical\fR ta \f(CW\*(C`Moose\*(C'\fR, meanin you can switch from \f(CW\*(C`Moo\*(C'\fR to
\&\f(CW\*(C`Moose\*(C'\fR like doggystyle.
.PP
\&\f(CW\*(C`Moo\*(C'\fR do not implement most of \f(CW\*(C`Moose\*(C'\fRz introspection \s-1API,\s0 so it's
often fasta when loadin yo' modulez fo' realz. Additionally, none of its
dependencies require \s-1XS,\s0 so it can be installed on machines without a
compiler.
.PP
One of \f(CW\*(C`Moo\*(C'\fRz most compellin features is its interoperabilitizzle with
\&\f(CW\*(C`Moose\*(C'\fR. When one of mah thugs tries ta use \f(CW\*(C`Moose\*(C'\fRz introspection \s-1API\s0 on a
\&\f(CW\*(C`Moo\*(C'\fR class or role, it is transparently inflated tha fuck into a \f(CW\*(C`Moose\*(C'\fR
class or role. This make it easier ta incorporate \f(CW\*(C`Moo\*(C'\fR\-usin code
into a \f(CW\*(C`Moose\*(C'\fR code base n' vice versa.
.PP
For example, a \f(CW\*(C`Moose\*(C'\fR class can subclass a \f(CW\*(C`Moo\*(C'\fR class using
\&\f(CW\*(C`extends\*(C'\fR or consume a \f(CW\*(C`Moo\*(C'\fR role rockin \f(CW\*(C`with\*(C'\fR.
.PP
Da \f(CW\*(C`Moose\*(C'\fR authors hope dat one dizzle \f(CW\*(C`Moo\*(C'\fR can be made obsolete by
improvin \f(CW\*(C`Moose\*(C'\fR enough yo, but fo' now it serves up a worthwhile
alternatizzle ta \f(CW\*(C`Moose\*(C'\fR.
.SS "Class::Accessor"
.IX Subsection "Class::Accessor"
Class::Accessor is tha polar opposite of \f(CW\*(C`Moose\*(C'\fR. Well shiiiit, it serves up hella
few features, nor is it self-hosting.
.PP
It is, however, straight-up simple, pure Perl, n' it has no non-core
dependencies. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it also serves up a \*(L"Moose-like\*(R" \s-1API\s0 on demand fo' the
features it supports.
.PP
Even though it don't do much, it is still preferable ta freestylin your
own classes from scratch.
.PP
Herez our \f(CW\*(C`File\*(C'\fR class wit \f(CW\*(C`Class::Accessor\*(C'\fR:
.PP
.Vb 2
\&  package File;
\&  use Class::Accessor \*(Aqantlers\*(Aq;
\&
\&  has path          => ( is => \*(Aqro\*(Aq );
\&  has content       => ( is => \*(Aqro\*(Aq );
\&  has last_mod_time => ( is => \*(Aqro\*(Aq );
\&
\&  sub print_info {
\&      mah $self = shift;
\&
\&      print "This file be at ", $self\->path, "\en";
\&  }
.Ve
.PP
Da \f(CW\*(C`antlers\*(C'\fR import flag  drops some lyrics ta \f(CW\*(C`Class::Accessor\*(C'\fR dat you want to
define yo' attributes rockin \f(CW\*(C`Moose\*(C'\fR\-like syntax. Da only parameter
that you can pass ta \f(CW\*(C`has\*(C'\fR is \f(CW\*(C`is\*(C'\fR. We recommend dat you use this
Moose-like syntax if you chizzle \f(CW\*(C`Class::Accessor\*(C'\fR since it means you
will gotz a smoother upgrade path if you lata decizzle ta move to
\&\f(CW\*(C`Moose\*(C'\fR.
.PP
Like \f(CW\*(C`Moose\*(C'\fR, \f(CW\*(C`Class::Accessor\*(C'\fR generates accessor methodz n' a
constructor fo' yo' class.
.SS "Object::Tiny"
.IX Subsection "Object::Tiny"
Finally, our crazy asses have Object::Tiny. This module truly lives up ta its
name. Well shiiiit, it has a incredibly minimal \s-1API\s0 n' straight-up no dependencies
(core or not). Right back up in yo muthafuckin ass. Still, we be thinkin itz a shitload easier ta use than writing
your own \s-1OO\s0 code from scratch.
.PP
Herez our \f(CW\*(C`File\*(C'\fR class once more:
.PP
.Vb 2
\&  package File;
\&  use Object::Tiny qw( path content last_mod_time );
\&
\&  sub print_info {
\&      mah $self = shift;
\&
\&      print "This file be at ", $self\->path, "\en";
\&  }
.Ve
.PP
Thatz dat shiznit son!
.PP
With \f(CW\*(C`Object::Tiny\*(C'\fR, all accessors is read-only. Well shiiiit, it generates a
constructor fo' you, as well as tha accessors you define.
.SS "Role::Tiny"
.IX Subsection "Role::Tiny"
As we mentioned before, rolez provide a alternatizzle ta inheritance,
but Perl aint gots any built-in role support. If you chizzle ta use
Moose, it comes wit a gangbangin' full-fledged role implementation. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat if
you use one of our other recommended \s-1OO\s0 modules, you can still use
rolez wit Role::Tiny
.PP
\&\f(CW\*(C`Role::Tiny\*(C'\fR serves up a shitload of tha same features as Moosez role
system yo, but up in a much smalla package. Most notably, it don't support
any sort of attribute declaration, so you gotta do dat by hand.
Still, itz useful, n' works well wit \f(CW\*(C`Class::Accessor\*(C'\fR and
\&\f(CW\*(C`Object::Tiny\*(C'\fR
.SS "\s-1OO\s0 System Summary"
.IX Subsection "OO System Summary"
Herez a funky-ass brief recap of tha options we covered:
.IP "\(bu" 4
Moose
.Sp
\&\f(CW\*(C`Moose\*(C'\fR is tha maximal option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it has a shitload of features, a funky-ass big
ecosystem, n' a thrivin user base. We also covered Moo briefly.
\&\f(CW\*(C`Moo\*(C'\fR is \f(CW\*(C`Moose\*(C'\fR lite, n' a reasonable alternatizzle when Moose
doesn't work fo' yo' application.
.IP "\(bu" 4
Class::Accessor
.Sp
\&\f(CW\*(C`Class::Accessor\*(C'\fR do a shitload less than \f(CW\*(C`Moose\*(C'\fR, n' be a sick
alternatizzle if you find \f(CW\*(C`Moose\*(C'\fR overwhelming. It aint nuthin but been round a long
time n' is well battle-tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it also has a minimal \f(CW\*(C`Moose\*(C'\fR
compatibilitizzle mode which make movin from \f(CW\*(C`Class::Accessor\*(C'\fR to
\&\f(CW\*(C`Moose\*(C'\fR easy as fuck .
.IP "\(bu" 4
Object::Tiny
.Sp
\&\f(CW\*(C`Object::Tiny\*(C'\fR is tha absolute minimal option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it has no dependencies,
and almost no syntax ta learn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. It aint nuthin but a phat option fo' a supa minimal
environment n' fo' throwin suttin' together quickly without having
to worry bout details.
.IP "\(bu" 4
Role::Tiny
.Sp
Use \f(CW\*(C`Role::Tiny\*(C'\fR wit \f(CW\*(C`Class::Accessor\*(C'\fR or \f(CW\*(C`Object::Tiny\*(C'\fR if you
find yo ass thankin bout multiple inheritance. If you go with
\&\f(CW\*(C`Moose\*(C'\fR, it comes wit its own role implementation.
.SS "Other \s-1OO\s0 Systems"
.IX Subsection "Other OO Systems"
There is literally dozenz of other OO-related modulez on \s-1CPAN\s0 besides
those covered here, n' you likely ta run across one or mo' of them
if you work wit other peoplez code.
.PP
In addition, nuff code up in tha wild do all of its \s-1OO \s0\*(L"by hand\*(R",
usin just tha Perl built-in \s-1OO\s0 features. If you need ta maintain such
code, you should read perlobj ta KNOW exactly how tha fuck Perl's
built-in \s-1OO\s0 works.
.SH "CONCLUSION"
.IX Header "CONCLUSION"
As we holla'd before, Perlz minimal \s-1OO\s0 system has hustled ta a profusion of
\&\s-1OO\s0 systems on \s-1CPAN.\s0 While you can still drop down ta tha bare metal and
write yo' classes by hand, there be a straight-up no reason ta do dat with
modern Perl.
.PP
For lil' small-ass systems, Object::Tiny n' Class::Accessor both provide
minimal object systems dat take care of basic boilerplate fo' yo thugged-out ass.
.PP
For bigger projects, Moose serves up a rich set of features dat will
let you focus on implementin yo' bidnizz logic.
.PP
We encourage you ta fuck wit n' evaluate Moose,
Class::Accessor, n' Object::Tiny ta peep which \s-1OO\s0 system is right
for yo thugged-out ass.
