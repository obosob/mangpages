'\" t
.\"     Title: git-commit
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-COMMIT" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-commit \- Record chizzlez ta tha repository
.SH "SYNOPSIS"
.sp
.nf
\fIgit commit\fR [\-a | \-\-interactizzle | \-\-patch] [\-s] [\-v] [\-u<mode>] [\-\-amend]
           [\-\-dry\-run] [(\-c | \-C | \-\-fixup | \-\-squash) <commit>]
           [\-F <file> | \-m <msg>] [\-\-reset\-author] [\-\-allow\-empty]
           [\-\-allow\-empty\-message] [\-\-no\-verify] [\-e] [\-\-author=<author>]
           [\-\-date=<date>] [\-\-cleanup=<mode>] [\-\-[no\-]status]
           [\-i | \-o] [\-S[<keyid>]] [\-\-] [<file>\&...]
.fi
.sp
.SH "DESCRIPTION"
.sp
Stores tha current contentz of tha index up in a freshly smoked up commit along wit a log message from tha user describin tha chizzles\&.
.sp
Da content ta be added can be specified up in nuff muthafuckin ways:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
by using
\fIgit add\fR
to incrementally "add" chizzlez ta tha index before rockin the
\fIcommit\fR
command (Note: even modified filez must be "added");
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
by using
\fIgit rm\fR
to remove filez from tha hustlin tree n' tha index, again n' again n' again before rockin the
\fIcommit\fR
command;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
by listin filez as arguments ta the
\fIcommit\fR
command, up in which case tha commit will ignore chizzlez staged up in tha index, n' instead record tha current content of tha listed filez (which must already be known ta Git);
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
by rockin tha \-a switch wit the
\fIcommit\fR
command ta automatically "add" chizzlez from all known filez (i\&.e\&. all filez dat is already listed up in tha index) n' ta automatically "rm" filez up in tha index dat done been removed from tha hustlin tree, n' then big-ass up tha actual commit;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
by rockin tha \-\-interactizzle or \-\-patch switches wit the
\fIcommit\fR
command ta decizzle one by one which filez or hunks should be part of tha commit, before finalizin tha operation\&. Right back up in yo muthafuckin ass. See tha \(lqInteractizzle Mode\(rq section of
\fBgit-add\fR(1)
to learn how tha fuck ta operate these modes\&.
.RE
.sp
Da \-\-dry\-run option can be used ta obtain a summary of what tha fuck is included by any of tha above fo' tha next commit by givin tha same set of parametas (options n' paths)\&.
.sp
If you cook up a cold-ass lil commit n' then find a gangbangin' fuck up immediately afta that, you can recover from it wit \fIgit reset\fR\&.
.SH "OPTIONS"
.PP
\-a, \-\-all
.RS 4
Tell tha command ta automatically stage filez dat done been modified n' deleted yo, but freshly smoked up filez you aint holla'd at Git bout is not affected\&.
.RE
.PP
\-p, \-\-patch
.RS 4
Use tha interactizzle patch selection intercourse ta chose which chizzlez ta commit\&. Right back up in yo muthafuckin ass. See
\fBgit-add\fR(1)
for details\&.
.RE
.PP
\-C <commit>, \-\-reuse\-message=<commit>
.RS 4
Take a existin commit object, n' reuse tha log message n' tha authorshizzle shiznit (includin tha timestamp) when bustin tha commit\&.
.RE
.PP
\-c <commit>, \-\-reedit\-message=<commit>
.RS 4
Like
\fI\-C\fR yo, but with
\fI\-c\fR
the editor is invoked, so dat tha user can further edit tha commit message\&.
.RE
.PP
\-\-fixup=<commit>
.RS 4
Construct a cold-ass lil commit message fo' use with
rebase \-\-autosquash\&. Da commit message is ghon be tha subject line from tha specified commit wit a prefix of "fixup! "\&. Right back up in yo muthafuckin ass. See
\fBgit-rebase\fR(1)
for details\&.
.RE
.PP
\-\-squash=<commit>
.RS 4
Construct a cold-ass lil commit message fo' use with
rebase \-\-autosquash\&. Da commit message subject line is taken from tha specified commit wit a prefix of "squash! "\&. Can be used wit additionizzle commit message options (\-m/\-c/\-C/\-F)\&. Right back up in yo muthafuckin ass. See
\fBgit-rebase\fR(1)
for details\&.
.RE
.PP
\-\-reset\-author
.RS 4
When used wit \-C/\-c/\-\-amend options, or when committin afta a a cold-ass lil conflictin cherry\-pick, declare dat tha authorshizzle of tha resultin commit now belongz of tha committer\&. This also reshizzle tha lyricist timestamp\&.
.RE
.PP
\-\-short
.RS 4
When bustin a thugged-out dry\-run, give tha output up in tha short\-format\&. Right back up in yo muthafuckin ass. See
\fBgit-status\fR(1)
for details\&. Implies
\-\-dry\-run\&.
.RE
.PP
\-\-branch
.RS 4
Show tha branch n' trackin info even up in short\-format\&.
.RE
.PP
\-\-porcelain
.RS 4
When bustin a thugged-out dry\-run, give tha output up in a porcelain\-ready format\&. Right back up in yo muthafuckin ass. See
\fBgit-status\fR(1)
for details\&. Implies
\-\-dry\-run\&.
.RE
.PP
\-\-long
.RS 4
When bustin a thugged-out dry\-run, give tha output up in a tha long\-format\&. Implies
\-\-dry\-run\&.
.RE
.PP
\-z, \-\-null
.RS 4
When showing
short
or
porcelain
status output, terminizzle entries up in tha status output wit NUL, instead of LF\&. If no format is given, implies the
\-\-porcelain
output format\&.
.RE
.PP
\-F <file>, \-\-file=<file>
.RS 4
Take tha commit message from tha given file\&. Use
\fI\-\fR
to read tha message from tha standard input\&.
.RE
.PP
\-\-author=<author>
.RS 4
Override tha commit author\&. Right back up in yo muthafuckin ass. Specify a explicit lyricist rockin tha standard
A U Thor <author@example\&.com>
format\&. Otherwise <author> be assumed ta be a pattern n' is used ta search fo' a existin commit by dat lyricist (i\&.e\&. rev\-list \-\-all \-i \-\-author=<author>); tha commit lyricist is then copied from tha straight-up original gangsta such commit found\&.
.RE
.PP
\-\-date=<date>
.RS 4
Override tha lyricist date used up in tha commit\&.
.RE
.PP
\-m <msg>, \-\-message=<msg>
.RS 4
Use tha given <msg> as tha commit message\&. If multiple
\-m
options is given, they joints is concatenated as separate paragraphs\&.
.RE
.PP
\-t <file>, \-\-template=<file>
.RS 4
When editin tha commit message, start tha editor wit tha contents up in tha given file\&. The
commit\&.template
configuration variable is often used ta give dis option implicitly ta tha command\&. This mechanizzle can be used by projects dat wanna guide participants wit some hints on what tha fuck ta write up in tha message up in what tha fuck order\&. If tha user exits tha editor without editin tha message, tha commit be aborted\&. This has no effect when a message is given by other means, e\&.g\&. wit the
\-m
or
\-F
options\&.
.RE
.PP
\-s, \-\-signoff
.RS 4
Add Signed\-off\-by line by tha committa all up in tha end of tha commit log message\&.
.RE
.PP
\-n, \-\-no\-verify
.RS 4
This option bypasses tha pre\-commit n' commit\-msg hooks\&. Right back up in yo muthafuckin ass. See also
\fBgithooks\fR(5)\&.
.RE
.PP
\-\-allow\-empty
.RS 4
Usually recordin a cold-ass lil commit dat has tha exact same tree as its sole parent commit be a mistake, n' tha command prevents you from makin such a cold-ass lil commit\&. This option bypasses tha safety, n' is primarily fo' use by foreign SCM intercourse scripts\&.
.RE
.PP
\-\-allow\-empty\-message
.RS 4
Like \-\-allow\-empty dis command is primarily fo' use by foreign SCM intercourse scripts\&. Well shiiiit, it allows you ta create a cold-ass lil commit wit a empty commit message without rockin plumbin commandz like
\fBgit-commit-tree\fR(1)\&.
.RE
.PP
\-\-cleanup=<mode>
.RS 4
This option determines how tha fuck tha supplied commit message should be cleaned up before committing\&. The
\fI<mode>\fR
can be
strip,
whitespace,
verbatim, or
default\&.
.PP
strip
.RS 4
Strip leadin n' trailin empty lines, trailin whitespace, n' #commentary n' collapse consecutizzle empty lines\&.
.RE
.PP
whitespace
.RS 4
Same as
strip
except #commentary aint removed\&.
.RE
.PP
verbatim
.RS 4
Do not chizzle tha message at all\&.
.RE
.PP
default
.RS 4
Same as
strip
if tha message is ta be edited\&. Otherwise
whitespace\&.
.RE
.sp
Da default can be chizzled by the
\fIcommit\&.cleanup\fR
configuration variable (see
\fBgit-config\fR(1))\&.
.RE
.PP
\-e, \-\-edit
.RS 4
Da message taken from file with
\-F, command line with
\-m, n' from commit object with
\-C
are probably used as tha commit log message unmodified\&. This option lets you further edit tha message taken from these sources\&.
.RE
.PP
\-\-no\-edit
.RS 4
Use tha selected commit message without launchin a editor\&. For example,
git commit \-\-amend \-\-no\-edit
amendz a cold-ass lil commit without changin its commit message\&.
.RE
.PP
\-\-amend
.RS 4
Replace tha tip of tha current branch by bustin a freshly smoked up commit\&. Da recorded tree is prepared as usual (includin tha effect of the
\-i
and
\-o
options n' explicit pathspec), n' tha message from tha original gangsta commit is used as tha startin point, instead of a empty message, when no other message is specified from tha command line via options such as
\-m,
\-F,
\-c, etc\&. Da freshly smoked up commit has tha same ol' dirty muthafathas n' lyricist as tha current one (the
\-\-reset\-author
option can countermand this)\&.
.sp
It be a rough equivalent for:
.sp
.if n \{\
.RS 4
.\}
.nf
        $ git reset \-\-soft HEAD^
        $ \&.\&.\&. do suttin' else ta come up wit tha right tree \&.\&.\&.
        $ git commit \-c ORIG_HEAD
.fi
.if n \{\
.RE
.\}
.sp
but can be used ta amend a merge commit\&.
.sp
Yo ass should KNOW tha implicationz of rewritin history if you amend a cold-ass lil commit dat has already been published\&. (See tha "RECOVERING FROM UPSTREAM REBASE" section in
\fBgit-rebase\fR(1)\&.)
.RE
.PP
\-\-no\-post\-rewrite
.RS 4
Bypass tha post\-rewrite hook\&.
.RE
.PP
\-i, \-\-include
.RS 4
Before bustin a cold-ass lil commit outta staged contents so far, stage tha contentz of paths given on tha command line as well\&. This is probably not what tha fuck you want unless yo ass is concludin a cold-ass lil conflicted merge\&.
.RE
.PP
\-o, \-\-only
.RS 4
Make a cold-ass lil commit only from tha paths specified on tha command line, disregardin any contents dat done been staged so far\&. This is tha default mode of operation of
\fIgit commit\fR
if any paths is given on tha command line, up in which case dis option can be omitted\&. If dis option is specified together with
\fI\-\-amend\fR, then no paths need ta be specified, which can be used ta amend tha last commit without committin chizzlez dat have already been staged\&.
.RE
.PP
\-u[<mode>], \-\-untracked\-files[=<mode>]
.RS 4
Show untracked files\&.
.sp
Da mode parameta is optionizzle (defaults to
\fIall\fR), n' is used ta specify tha handlin of untracked files; when \-u aint used, tha default is
\fInormal\fR, i\&.e\&. show untracked filez n' directories\&.
.sp
Da possible options are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIno\fR
\- Show no untracked files
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fInormal\fR
\- Shows untracked filez n' directories
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIall\fR
\- Also shows individual filez up in untracked directories\&.
.sp
Da default can be chizzled rockin tha status\&.showUntrackedFilez configuration variable documented in
\fBgit-config\fR(1)\&.
.RE
.RE
.PP
\-v, \-\-verbose
.RS 4
Show unified diff between tha HEAD commit n' what tha fuck would be committed all up in tha bottom of tha commit message template\&. Note dat dis diff output don\(cqt have its lines prefixed with
\fI#\fR\&.
.RE
.PP
\-q, \-\-quiet
.RS 4
Suppress commit summary message\&.
.RE
.PP
\-\-dry\-run
.RS 4
Do not create a cold-ass lil commit yo, but show a list of paths dat is ta be committed, paths wit local chizzlez dat is ghon be left uncommitted n' paths dat is untracked\&.
.RE
.PP
\-\-status
.RS 4
Include tha output of
\fBgit-status\fR(1)
in tha commit message template when rockin a editor ta prepare tha commit message\&. Defaults ta on yo, but can be used ta override configuration variable commit\&.status\&.
.RE
.PP
\-\-no\-status
.RS 4
Do not include tha output of
\fBgit-status\fR(1)
in tha commit message template when rockin a editor ta prepare tha default commit message\&.
.RE
.PP
\-S[<keyid>], \-\-gpg\-sign[=<keyid>]
.RS 4
GPG\-sign commit\&.
.RE
.PP
\-\-
.RS 4
Do not interpret any mo' arguments as options\&.
.RE
.PP
<file>\&...
.RS 4
When filez is given on tha command line, tha command commits tha contentz of tha named files, without recordin tha chizzlez already staged\&. Da contentz of these filez is also staged fo' tha next commit on top of what tha fuck done been staged before\&.
.RE
.SH "DATE FORMATS"
.sp
Da GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment variablez n' tha \-\-date option support tha followin date formats:
.PP
Git internal format
.RS 4
It is
<unix timestamp> <time unit offset>, where
<unix timestamp>
is tha number of secondz since tha UNIX epoch\&.
<time unit offset>
is a positizzle or wack offset from UTC\&. For example CET (which is 2 minutes ahead UTC) is
+0200\&.
.RE
.PP
RFC 2822
.RS 4
Da standard email format as busted lyrics bout by RFC 2822, fo' example
Thu, 07 Apr 2005 22:13:13 +0200\&.
.RE
.PP
ISO 8601
.RS 4
Time n' date specified by tha ISO 8601 standard, fo' example
2005\-04\-07T22:13:13\&. Da parser accepts a space instead of the
T
characta as well\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In addition, tha date part be accepted up in tha followin formats:
YYYY\&.MM\&.DD,
MM/DD/YYYY
and
DD\&.MM\&.YYYY\&.
.sp .5v
.RE
.RE
.SH "EXAMPLES"
.sp
When recordin yo' own work, tha contentz of modified filez up in yo' hustlin tree is temporarily stored ta a stagin area called tha "index" wit \fIgit add\fR\& fo' realz. A file can be reverted back, only up in tha index but not up in tha hustlin tree, ta dat of tha last commit wit git reset HEAD \-\- <file>, which effectively reverts \fIgit add\fR n' prevents tha chizzlez ta dis file from participatin up in tha next commit\& fo' realz. Afta buildin tha state ta be committed incrementally wit these commands, git commit (without any pathname parameter) is used ta record what tha fuck has been staged so far\&. This is da most thugged-out basic form of tha command\& fo' realz. An example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit hello\&.c
$ git rm peace out\&.c
$ git add hello\&.c
$ git commit
.fi
.if n \{\
.RE
.\}
.sp
.sp
Instead of stagin filez afta each individual chizzle, you can tell git commit ta notice tha chizzlez ta tha filez whose contents is tracked up in yo' hustlin tree n' do correspondin git add n' git rm fo' you\&. That is, dis example do tha same as tha earlier example if there is no other chizzle up in yo' hustlin tree:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit hello\&.c
$ rm peace out\&.c
$ git commit \-a
.fi
.if n \{\
.RE
.\}
.sp
.sp
Da command git commit \-a first looks at yo' hustlin tree, notices dat you have modified hello\&.c n' removed peace out\&.c, n' performs necessary git add n' git rm fo' you\&.
.sp
Afta stagin chizzlez ta nuff files, you can alta tha order tha chizzlez is recorded in, by givin pathnames ta git commit\&. When pathnames is given, tha command cook up a cold-ass lil commit dat only recordz tha chizzlez made ta tha named paths:
.sp
.if n \{\
.RS 4
.\}
.nf
$ edit hello\&.c hello\&.h
$ git add hello\&.c hello\&.h
$ edit Makefile
$ git commit Makefile
.fi
.if n \{\
.RE
.\}
.sp
.sp
This cook up a cold-ass lil commit dat recordz tha modification ta Makefile\&. Da chizzlez staged fo' hello\&.c n' hello\&.h is not included up in tha resultin commit\&. But fuck dat shiznit yo, tha word on tha street is dat they chizzlez is not lost \(em they is still staged n' merely held back\& fo' realz. Afta tha above sequence, if you do:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git commit
.fi
.if n \{\
.RE
.\}
.sp
.sp
this second commit would record tha chizzlez ta hello\&.c n' hello\&.h as expected\&.
.sp
Afta a merge (initiated by \fIgit merge\fR or \fIgit pull\fR) stops cuz of conflicts, cleanly merged paths is already staged ta be committed fo' you, n' paths dat conflicted is left up in unmerged state\&. Yo ass would gotta first check which paths is conflictin wit \fIgit status\fR n' afta fixin dem manually up in yo' hustlin tree, you would stage tha result as usual wit \fIgit add\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git status | grep unmerged
unmerged: hello\&.c
$ edit hello\&.c
$ git add hello\&.c
.fi
.if n \{\
.RE
.\}
.sp
.sp
Afta resolvin conflicts n' stagin tha result, git ls\-filez \-u would stop mentionin tha conflicted path\&. When yo ass is done, run git commit ta finally record tha merge:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git commit
.fi
.if n \{\
.RE
.\}
.sp
.sp
As wit tha case ta record yo' own chizzles, you can use \-a option ta save typing\&. One difference is dat durin a merge resolution, you cannot use git commit wit pathnames ta alta tha order tha chizzlez is committed, cuz tha merge should be recorded as a single commit\&. In fact, tha command refuses ta run when given pathnames (but peep \-i option)\&.
.SH "DISCUSSION"
.sp
Though not required, it\(cqs a phat scam ta begin tha commit message wit a single short (less than 50 character) line summarizin tha chizzle, followed by a funky-ass blank line n' then a mo' thorough description\&. Da text up ta tha straight-up original gangsta blank line up in a cold-ass lil commit message is treated as tha commit title, n' dat title is used all up in Git\&. For example, \fBgit-format-patch\fR(1) turns a cold-ass lil commit tha fuck into email, n' it uses tha title on tha Subject line n' tha rest of tha commit up in tha body\&.
.sp
At tha core level, Git is characta encodin agnostic\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da pathnames recorded up in tha index n' up in tha tree objects is treated as uninterpreted sequencez of non\-NUL bytes\&. What readdir(2) returns is what tha fuck is recorded n' compared wit tha data Git keeps track of, which up in turn is sposed ta fuckin be what tha fuck lstat(2) n' creat(2) accepts\&. There is no such thang as pathname encodin translation\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da contentz of tha blob objects is uninterpreted sequencez of bytes\&. There is no encodin translation all up in tha core level\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da commit log lyrics is uninterpreted sequencez of non\-NUL bytes\&.
.RE
.sp
Although we encourage dat tha commit log lyrics is encoded up in UTF\-8, both tha core n' Git Porcelain is designed not ta force UTF\-8 on projects\&. If all participantz of a particular project find it mo' convenient ta use legacy encodings, Git do not forbid it\&. But fuck dat shiznit yo, tha word on tha street is dat there be all dem thangs ta keep up in mind\&.
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
\fIgit commit\fR
and
\fIgit commit\-tree\fR
issues a warnin if tha commit log message given ta it do not be lookin like a valid UTF\-8 string, unless you explicitly say yo' project uses a legacy encoding\&. Da way ta say dis is ta have i18n\&.commitencodin in
\&.git/config
file, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[i18n]
        commitencodin = ISO\-8859\-1
.fi
.if n \{\
.RE
.\}
.sp
Commit objects pimped wit tha above settin record tha value of
i18n\&.commitencoding
in its
encoding
header\&. This is ta help other playas whoz ass peep dem later\&. Lack of dis header implies dat tha commit log message is encoded up in UTF\-8\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
\fIgit log\fR,
\fIgit show\fR,
\fIgit blame\fR
and playaz peep the
encoding
header of a cold-ass lil commit object, n' try ta re\-code tha log message tha fuck into UTF\-8 unless otherwise specified\&. Yo ass can specify tha desired output encodin with
i18n\&.logoutputencoding
in
\&.git/config
file, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[i18n]
        logoutputencodin = ISO\-8859\-1
.fi
.if n \{\
.RE
.\}
.sp
If you aint gots dis configuration variable, tha value of
i18n\&.commitencoding
is used instead\&.
.RE
.sp
Note dat our phat asses deliberately chose not ta re\-code tha commit log message when a cold-ass lil commit is made ta force UTF\-8 all up in tha commit object level, cuz re\-codin ta UTF\-8 aint necessarily a reversible operation\&.
.SH "ENVIRONMENT AND CONFIGURATION VARIABLES"
.sp
Da editor used ta edit tha commit log message is ghon be chosen from tha GIT_EDITOR environment variable, tha core\&.editor configuration variable, tha VISUAL environment variable, or tha EDITOR environment variable (in dat order)\&. Right back up in yo muthafuckin ass. See \fBgit-var\fR(1) fo' details\&.
.SH "HOOKS"
.sp
This command can run commit\-msg, prepare\-commit\-msg, pre\-commit, n' post\-commit hooks\&. Right back up in yo muthafuckin ass. See \fBgithooks\fR(5) fo' mo' shiznit\&.
.SH "FILES"
.PP
$GIT_DIR/COMMIT_EDITMSG
.RS 4
This file gotz nuff tha commit message of a cold-ass lil commit up in progress\&. If
git commit
exits cuz of a error before bustin a cold-ass lil commit, any commit message dat has been provided by tha user (e\&.g\&., up in a editor session) is ghon be available up in dis file yo, but is ghon be overwritten by tha next invocation of
git commit\&.
.RE
.SH "SEE ALSO"
.sp
\fBgit-add\fR(1), \fBgit-rm\fR(1), \fBgit-mv\fR(1), \fBgit-merge\fR(1), \fBgit-commit-tree\fR(1)
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
