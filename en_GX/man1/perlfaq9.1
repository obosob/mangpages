.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq9 \- Web, Email n' Networking
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals wit thangs related ta hustlin wizzy cribs,
sendin n' receivin email as well as general networking.
.SS "Should I bust a wizzy framework?"
.IX Subsection "Should I bust a wizzy framework?"
Yes yes y'all. If yo ass is buildin a wizzy joint wit any level of interactivity
(forms / playas / databases), you
will wanna bust a gangbangin' framework ta make handlin requests
and responses easier.
.PP
If there is no interactivitizzle then you may still want
to peep rockin suttin' like Template Toolkit <https://metacpan.org/module/Template>
or Plack::Middleware::TemplateToolkit
so maintenizzle of yo' \s-1HTML\s0 filez (and other assets) is easier.
.SS "Which wizzy framework should I use?"
.IX Xref "framework CGI.pm CGI Catalyst Dancer"
.IX Subsection "Which wizzy framework should I use?"
There is no simple answer ta dis question. I aint talkin' bout chicken n' gravy biatch. Perl frameworks can run every last muthafuckin thang
from basic file servers n' lil' small-ass scale intranets ta massive multinational
multilingual joints dat is tha core ta internationistic bidnizzes.
.PP
Below be a list of all dem frameworks wit comments which might help you up in 
makin a thugged-out decision, dependin on yo' specific requirements, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Start by reading
the docs, then ask thangs on tha relevant mailin list or \s-1IRC\s0 channel.
.IP "Catalyst" 4
.IX Item "Catalyst"
Strongly object-oriented n' fully-featured wit a long-ass pimpment history and
a big-ass hood n' addon ecosystem. Well shiiiit, it is pimpin fo' big-ass n' complex
applications, where you have full control over tha server.
.IP "Dancer" 4
.IX Item "Dancer"
Young n' free of legacy weight, providin a lightweight n' easy as fuck  ta learn \s-1API.\s0
Has a growin addon ecosystem. Well shiiiit, it is dopest used fo' smalla projects and
very easy as fuck  ta learn fo' beginners.
.IP "Mojolicious" 4
.IX Item "Mojolicious"
Fairly lil' wit a gangbangin' focus on \s-1HTML5\s0 n' real-time wizzy technologies such as
WebSockets.
.IP "Web::Simple" 4
.IX Item "Web::Simple"
Currently experimental, straight fuckin object-oriented, built fo' speed n' intended
as a toolkit fo' buildin micro wizzy apps, custom frameworks or fo' tieing
together existin Plack-compatible wizzy applications wit one central dispatcher.
.PP
All of these interact wit or use Plack which is worth understanding
the basics of when buildin a joint up in Perl (there be a shitload of useful
Plack::Middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>).
.SS "What tha fuck iz Plack n' \s-1PSGI\s0?"
.IX Subsection "What tha fuck iz Plack n' PSGI?"
\&\s-1PSGI\s0 is tha Perl Web Server Gateway Interface Justification, it is
a standard dat nuff Perl wizzy frameworks use, you should not need to
understand it ta build a wizzy crib, tha part you might wanna use is Plack.
.PP
Plack be a set of tools fo' rockin tha \s-1PSGI\s0 stack. Well shiiiit, it gotz nuff
middleware <https://metacpan.org/search?q=plack%3A%3Amiddleware>
components, a reference server n' utilitizzles fo' Web application frameworks.
Plack is like Rubyz Rack or Pythonz Paste fo' \s-1WSGI.\s0
.PP
Yo ass could build a wizzy joint rockin Plack n' yo' own code,
but fo' anythang other than a straight-up basic wizzy crib, rockin a wizzy framework
(that uses Plack) be a funky-ass betta option.
.SS "How tha fuck do I remove \s-1HTML\s0 from a string?"
.IX Subsection "How tha fuck do I remove HTML from a string?"
Use HTML::Strip, or HTML::FormatText which not only removes \s-1HTML\s0
but also attempts ta do a lil simple formattin of tha resulting
plain text.
.SS "How tha fuck do I extract URLs?"
.IX Subsection "How tha fuck do I extract URLs?"
HTML::SimpleLinkExtor will extract URLs from \s-1HTML,\s0 it handlez anchors,
images, objects, frames, n' nuff other tags dat can contain a \s-1URL.\s0
If you need anythang mo' complex, you can create yo' own subclass of
HTML::LinkExtor or HTML::Parser n' shit. Yo ass might even use
HTML::SimpleLinkExtor as a example fo' suttin' specifically
suited ta yo' needs.
.PP
Yo ass can use URI::Find ta extract URLs from a arbitrary text document.
.SS "How tha fuck do I fetch a \s-1HTML\s0 file?"
.IX Subsection "How tha fuck do I fetch a HTML file?"
(contributed by brian d foy)
.PP
Use tha libwww-perl distribution. I aint talkin' bout chicken n' gravy biatch. Da LWP::Simple module can fetch web
resources n' give they content back ta you as a string:
.PP
.Vb 1
\&    use LWP::Simple qw(get);
\&
\&    mah $html = get( "http://www.example.com/index.html" );
.Ve
.PP
It can also store tha resource directly up in a gangbangin' file:
.PP
.Vb 1
\&    use LWP::Simple qw(getstore);
\&
\&    getstore( "http://www.example.com/index.html", "foo.html" );
.Ve
.PP
If you need ta do suttin' mo' fucked up, you can use
LWP::UserAgent module ta create yo' own user-agent (e.g. browser)
to git tha thang done. If you wanna simulate a interactizzle web
browser, you can use tha WWW::Mechanize module.
.SS "How tha fuck do I automate a \s-1HTML\s0 form submission?"
.IX Subsection "How tha fuck do I automate a HTML form submission?"
If yo ass is bustin suttin' complex, like fuckin movin all up in nuff pages
and forms or a wizzy crib, you can use WWW::Mechanize. Right back up in yo muthafuckin ass. See its
documentation fo' all tha details.
.PP
If you submittin joints rockin tha \s-1GET\s0 method, create a \s-1URL\s0 n' encode
the form rockin tha \f(CW\*(C`query_form\*(C'\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
\&
\&    mah $url = url(\*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq)>;
\&    $url\->query_form(module => \*(AqDB_File\*(Aq, readme => 1);
\&    $content = get($url);
.Ve
.PP
If you rockin tha \s-1POST\s0 method, create yo' own user agent n' encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
\&
\&    mah $ua = LWP::UserAgent\->new();
\&    mah $req = POST \*(AqL<http://www.perl.com/cgi\-bin/cpan_mod\*(Aq>,
\&                   [ module => \*(AqDB_File\*(Aq, readme => 1 ];
\&    mah $content = $ua\->request($req)\->as_string;
.Ve
.SS "How tha fuck do I decode or create dem %\-encodings on tha web?"
.IX Xref "URI URI::Escape RFC 2396"
.IX Subsection "How tha fuck do I decode or create dem %-encodings on tha web?"
Most of tha time you should not need ta do dis as
your wizzy framework, or if yo ass is bustin a request,
the \s-1LWP\s0 or other module would handle it fo' yo thugged-out ass.
.PP
To encode a strang yo ass, use tha URI::Escape module. Da \f(CW\*(C`uri_escape\*(C'\fR
function returns tha escaped string:
.PP
.Vb 1
\&    mah $original gangsta = "Colon : Hash # Cement %";
\&
\&    mah $escaped = uri_escape( $original gangsta );
\&
\&    print "$escaped\en"; # \*(AqColon%20%3A%20Hash%20%23%20Percent%20%25\*(Aq
.Ve
.PP
To decode tha string, use tha \f(CW\*(C`uri_unescape\*(C'\fR function:
.PP
.Vb 1
\&    mah $unescaped = uri_unescape( $escaped );
\&
\&    print $unescaped; # back ta original
.Ve
.PP
Remember not ta encode a gangbangin' full \s-1URI,\s0 you need ta escape each
component separately n' then join dem together.
.SS "How tha fuck do I redirect ta another page?"
.IX Subsection "How tha fuck do I redirect ta another page?"
Most Perl Web Frameworks gonna git a mechanizzle fo' bustin this,
usin tha Catalyst framework it would be:
.PP
.Vb 2
\&    $c\->res\->redirect($url);
\&    $c\->detach();
.Ve
.PP
If yo ass is rockin Plack (which most frameworks do), then
Plack::Middleware::Rewrite is worth lookin at if you
are migratin from Apache or have \s-1URL\s0z you wanna always
redirect.
.SS "How tha fuck do I put a password on mah wizzy pages?"
.IX Subsection "How tha fuck do I put a password on mah wizzy pages?"
See if tha wizzy framework yo ass is rockin has an
authentication system n' if dat fits yo' needs.
.PP
Alternativly peep Plack::Middleware::Auth::Basic,
or one of tha other Plack authentication <https://metacpan.org/search?q=plack+auth>
options.
.SS "How tha fuck do I make shizzle playas can't enta joints tha fuck into a gangbangin' form dat causes mah \s-1CGI\s0 script ta do wack thangs?"
.IX Subsection "How tha fuck do I make shizzle playas can't enta joints tha fuck into a gangbangin' form dat causes mah CGI script ta do wack thangs?"
(contributed by brian d foy)
.PP
Yo ass can't prevent playas from bustin  yo' script wack data. Even if
you add some client-side checks, playas may disable dem or bypass
them straight-up. For instance, one of mah thugs might bust a module such as
\&\s-1LWP\s0 ta submit ta yo' wizzy crib. If you wanna prevent data that
try ta use \s-1SQL\s0 injection or other sortz of attacks (and you should
want to), you gotta not trust any data dat enta yo' program.
.PP
Da perlsec documentation has general lyrics bout data security.
If yo ass is rockin tha \s-1DBI\s0 module, use placeholda ta fill up in data.
If yo ass is hustlin external programs wit \f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR, use
the list forms. There is nuff other precautions dat you should take,
too nuff ta list here, n' most of dem fall under tha category of not
usin any data dat you don't intend ta use. Trust no one.
.SS "How tha fuck do I parse a mail header?"
.IX Subsection "How tha fuck do I parse a mail header?"
Use tha Email::MIME module. It aint nuthin but well-tested n' supports all the
crazinizz dat you gonna peep up in tha real ghetto (comment-foldin whitespace,
encodings, comments, etc.).
.PP
.Vb 1
\&  use Email::MIME;
\&
\&  mah $message = Email::MIME\->new($rfc2822);
\&  mah $subject = $message\->header(\*(AqSubject\*(Aq);
\&  mah $from    = $message\->header(\*(AqFrom\*(Aq);
.Ve
.PP
If you've already gots some other kind of email object, consider passing
it ta Email::Abstract n' then rockin its cast method ta git an
Email::MIME object:
.PP
.Vb 3
\&  mah $mail_message_object = read_message();
\&  mah $abstract = Email::Abstract\->new($mail_message_object);
\&  mah $email_mime_object = $abstract\->cast(\*(AqEmail::MIME\*(Aq);
.Ve
.SS "How tha fuck do I check a valid mail address?"
.IX Subsection "How tha fuck do I check a valid mail address?"
(partly contributed by Aaron Sherman)
.PP
This aint as simple a question as it sounds. There is two parts:
.PP
a) How tha fuck do I verify dat a email address is erectly formatted?
.PP
b) How tha fuck do I verify dat a email address targets a valid recipient?
.PP
Without bustin  mail ta tha address n' seein whether there be a a human
on tha other end ta answer you, you cannot straight-up answer part \fIb\fR yo, but
the Email::Valid module will do both part \fIa\fR n' part \fIb\fR as far
as you can up in real-time.
.PP
Our dopest lyrics fo' verifyin a personz mail address is ta have them
enta they address twice, just as you normally do ta chizzle a
password. Y'all KNOW dat shit, muthafucka! This probably weedz up typos. If both versions match, send
mail ta dat address wit a underground message. If you git tha message
back n' they've followed yo' directions, you can be reasonably
assured dat itz real.
.PP
A related game thatz less open ta forgery is ta give dem a \s-1PIN
\&\s0(personal \s-1ID\s0 number). Record tha address n' \s-1PIN \s0(best dat it be a
random one) fo' lata processing. In tha mail you send, include a link to
your joint wit tha \s-1PIN\s0 included. Y'all KNOW dat shit, muthafucka! If tha mail bounces, you know itz not
valid. Y'all KNOW dat shit, muthafucka! If they don't click on tha link, either they forged tha address or
(assumin they gots tha message) followin all up in wasn't blingin so you
don't need ta worry bout dat shit.
.SS "How tha fuck do I decode a \s-1MIME/BASE64\s0 string?"
.IX Subsection "How tha fuck do I decode a MIME/BASE64 string?"
Da MIME::Base64 package handlez dis as well as tha \s-1MIME/QP\s0 encoding.
Decodin base 64 becomes as simple as:
.PP
.Vb 2
\&    use MIME::Base64;
\&    mah $decoded = decode_base64($encoded);
.Ve
.PP
Da Email::MIME module can decode base 64\-encoded email message parts
transparently so tha pimper don't need ta worry bout dat shit.
.SS "How tha fuck do I find tha userz mail address?"
.IX Subsection "How tha fuck do I find tha userz mail address?"
Ask dem fo' dat shit. There is all kindsa muthafuckin email providaz available dat it's
unlikely tha local system has any scam how tha fuck ta determine a userz email address.
.PP
Da exception is fo' organization-specific email (e.g. foo@yourcompany.com)
where policy can be codified up in yo' program. In dat case, you could peep
\&\f(CW$ENV\fR{\s-1USER\s0}, \f(CW$ENV\fR{\s-1LOGNAME\s0}, n' getpwuid($<) up in scalar context, like so:
.PP
.Vb 1
\&  mah $user_name = getpwuid($<)
.Ve
.PP
But you still cannot make assumptions bout whether dis is erect, unless
your policy say it is. Yo ass straight-up is dopest off askin tha user.
.SS "How tha fuck do I bust email?"
.IX Subsection "How tha fuck do I bust email?"
Use tha Email::MIME n' Email::Sender::Simple modules, like so:
.PP
.Vb 10
\&  # first, create yo' message
\&  mah $message = Email::MIME\->create(
\&    header_str => [
\&      From    => \*(Aqyou@example.com\*(Aq,
\&      To      => \*(Aqfriend@example.com\*(Aq,
\&      Subject => \*(AqKool as fuck birthday!\*(Aq,
\&    ],
\&    attributes => {
\&      encodin => \*(Aqquoted\-printable\*(Aq,
\&      charset  => \*(Aqutf\-8\*(Aq,
\&    },
\&    body_str => "Pimpin' bizzledizzle ta you, nahmean biiiatch?\en",
\&  );
\&
\&  use Email::Sender::Simple qw(sendmail);
\&  sendmail($message);
.Ve
.PP
By default, Email::Sender::Simple will try `sendmail` first, if it exists
in yo' \f(CW$PATH\fR. This generally aint tha case. If there be a a remote mail
server you use ta bust mail, consider investigatin one of tha Transport
classes fo' realz. At time of writing, tha available transports include:
.IP "Email::Sender::Transport::Sendmail" 4
.IX Item "Email::Sender::Transport::Sendmail"
This is tha default. If you can use tha \fImail\fR\|(1) or \fImailx\fR\|(1)
program ta bust mail from tha machine where yo' code runs, you should
be able ta use all dis bullshit.
.IP "Email::Sender::Transport::SMTP" 4
.IX Item "Email::Sender::Transport::SMTP"
This transhiznit contacts a remote \s-1SMTP\s0 server over \s-1TCP.\s0 It optionally
uses \s-1SSL\s0 n' can authenticate ta tha server via \s-1SASL.\s0
.IP "Email::Sender::Transport::SMTP::TLS" 4
.IX Item "Email::Sender::Transport::SMTP::TLS"
This is like tha \s-1SMTP\s0 transhiznit yo, but uses \s-1TLS\s0 security. Yo ass can
authenticate wit dis module as well, rockin any mechanizzlez yo' server
supports afta \s-1STARTTLS.\s0
.PP
Tellin Email::Sender::Simple ta use yo' transhiznit is straightforward.
.PP
.Vb 6
\&  sendmail(
\&    $message,
\&    {
\&      transhiznit => $email_sender_transport_object,
\&    }
\&  );
.Ve
.SS "How tha fuck do I use \s-1MIME\s0 ta cook up a attachment ta a mail message?"
.IX Subsection "How tha fuck do I use MIME ta cook up a attachment ta a mail message?"
Email::MIME directly supports multipart lyrics. Email::MIME
objects theyselves is parts n' can be attached ta other Email::MIME
objects, n' you can put dat on yo' toast. Consult tha Email::MIME documentation fo' mo' shiznit,
includin all of tha supported methodz n' examplez of they use.
.SS "How tha fuck do I read email?"
.IX Subsection "How tha fuck do I read email?"
Use tha Email::Folda module, like so:
.PP
.Vb 1
\&  use Email::Folder;
\&
\&  mah $folda = Email::Folder\->new(\*(Aq/path/to/email/folder\*(Aq);
\&  while(my $message = $folder\->next_message) {
\&    # next_message returns Email::Simple objects yo, but we want
\&    # Email::MIME objects as they\*(Aqre mo' robust
\&    mah $mime = Email::MIME\->new($message\->as_string);
\&  }
.Ve
.PP
There is different classes up in tha Email::Folda namespace for
supportin various mailbox types. Note dat these modulez is generally
rather limited n' only support \fBreading\fR rather than writing.
.SS "How tha fuck do I smoke up mah hostname, domainname, or \s-1IP\s0 address?"
.IX Xref "hostname, domainname, IP address, host, domain, hostfqdn, inet_ntoa, gethostbyname, Socket, Net::Domain, Sys::Hostname"
.IX Subsection "How tha fuck do I smoke up mah hostname, domainname, or IP address?"
(contributed by brian d foy)
.PP
Da Net::Domain module, which is part of tha Standard Library starting
in Perl 5.7.3, can git you tha straight-up qualified domain name (\s-1FQDN\s0), tha host
name, or tha domain name.
.PP
.Vb 1
\&    use Net::Domain qw(hostname hostfqdn hostdomain);
\&
\&    mah $host = hostfqdn();
.Ve
.PP
Da Sys::Hostname module, part of tha Standard Library, can also git the
hostname:
.PP
.Vb 1
\&    use Sys::Hostname;
\&
\&    $host = hostname();
.Ve
.PP
Da Sys::Hostname::Long module takes a gangbangin' finger-lickin' different approach n' tries
harder ta return tha straight-up qualified hostname:
.PP
.Vb 1
\&  use Sys::Hostname::Long \*(Aqhostname_long\*(Aq;
\&
\&  mah $hostname = hostname_long();
.Ve
.PP
To git tha \s-1IP\s0 address, you can use tha \f(CW\*(C`gethostbyname\*(C'\fR built-in function
to turn tha name tha fuck into a number n' shit. To turn dat number tha fuck into tha dotted octet
form (a.b.c.d) dat most playas expect, use tha \f(CW\*(C`inet_ntoa\*(C'\fR function
from tha Socket module, which also comes wit perl.
.PP
.Vb 1
\&    use Socket;
\&
\&    mah $address = inet_ntoa(
\&        scalar gethostbyname( $host || \*(Aqlocalhost\*(Aq )
\&    );
.Ve
.SS "How tha fuck do I fetch/put a (S)FTP file?"
.IX Subsection "How tha fuck do I fetch/put a (S)FTP file?"
Net::FTP, n' Net::SFTP allow you ta interact wit \s-1FTP\s0 n' \s-1SFTP \s0(Secure
\&\s-1FTP\s0) servers.
.SS "How tha fuck can I do \s-1RPC\s0 up in Perl?"
.IX Subsection "How tha fuck can I do RPC up in Perl?"
Use one of tha \s-1RPC\s0 modules( <https://metacpan.org/search?q=RPC> ).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in dis file
are hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' fun
or fo' profit as you peep fit fo' realz. A simple comment up in tha code giving
credit would be courteous but aint required.
