.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLAPIO 1"
.TH PERLAPIO 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlapio \- perlz IO abstraction intercourse.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    #define PERLIO_NOT_STDIO 0    /* For co\-existence wit stdio only */
\&    #include <perlio.h>           /* Usually via #include <perl.h> */
\&
\&    PerlIO *PerlIO_stdin(void);
\&    PerlIO *PerlIO_stdout(void);
\&    PerlIO *PerlIO_stderr(void);
\&
\&    PerlIO *PerlIO_open(const char *path,const char *mode);
\&    PerlIO *PerlIO_fdopen(int fd, const char *mode);
\&    PerlIO *PerlIO_reopen(const char *path, const char *mode, PerlIO *old);  /* deprecated */
\&    int     PerlIO_close(PerlIO *f);
\&
\&    int     PerlIO_stdoutf(const char *fmt,...)
\&    int     PerlIO_puts(PerlIO *f,const char *string);
\&    int     PerlIO_putc(PerlIO *f,int ch);
\&    int     PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
\&    int     PerlIO_printf(PerlIO *f, const char *fmt,...);
\&    int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
\&    int     PerlIO_flush(PerlIO *f);
\&
\&    int     PerlIO_eof(PerlIO *f);
\&    int     PerlIO_error(PerlIO *f);
\&    void    PerlIO_clearerr(PerlIO *f);
\&
\&    int     PerlIO_getc(PerlIO *d);
\&    int     PerlIO_ungetc(PerlIO *f,int ch);
\&    int     PerlIO_read(PerlIO *f, void *buf, size_t numbytes);
\&
\&    int     PerlIO_fileno(PerlIO *f);
\&
\&    void    PerlIO_setlinebuf(PerlIO *f);
\&
\&    Off_t   PerlIO_tell(PerlIO *f);
\&    int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
\&    void    PerlIO_rewind(PerlIO *f);
\&
\&    int     PerlIO_getpos(PerlIO *f, SV *save);        /* prototype chizzled */
\&    int     PerlIO_setpos(PerlIO *f, SV *saved);       /* prototype chizzled */
\&
\&    int     PerlIO_fast_gets(PerlIO *f);
\&    int     PerlIO_has_cntptr(PerlIO *f);
\&    int     PerlIO_get_cnt(PerlIO *f);
\&    char   *PerlIO_get_ptr(PerlIO *f);
\&    void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, int count);
\&
\&    int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
\&    void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */
\&
\&    int     PerlIO_has_base(PerlIO *f);
\&    char   *PerlIO_get_base(PerlIO *f);
\&    int     PerlIO_get_bufsiz(PerlIO *f);
\&
\&    PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
\&    FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
\&    FILE   *PerlIO_findFILE(PerlIO *f);
\&    void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);
\&
\&    int     PerlIO_apply_layers(PerlIO *f, const char *mode, const char *layers);
\&    int     PerlIO_binmode(PerlIO *f, int ptype, int imode, const char *layers);
\&    void    PerlIO_debug(const char *fmt,...)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perlz source code, n' extensions dat want maximum portability,
should use tha above functions instead of dem defined up in \s-1ANSI C\s0's
\&\fIstdio.h\fR.  Da perl headaz (in particular \*(L"perlio.h\*(R") will
\&\f(CW\*(C`#define\*(C'\fR dem ta tha I/O mechanizzle selected at Configure time.
.PP
Da functions is modeled on dem up in \fIstdio.h\fR yo, but parameta order
has been \*(L"tidied up a lil\*(R".
.PP
\&\f(CW\*(C`PerlIO *\*(C'\fR takes tha place of \s-1FILE\s0 *. Like \s-1FILE\s0 * it should be
treated as opaque (it is probably safe ta assume it aint nuthin but a pointa to
something).
.PP
There is currently three implementations:
.IP "1. \s-1USE_STDIO\s0" 4
.IX Item "1. USE_STDIO"
All above is #define'd ta stdio functions or is trivial wrapper
functions which call stdio. In dis case \fIonly\fR PerlIO * be a \s-1FILE\s0 *.
This has been tha default implementation since tha abstraction was
introduced up in perl5.003_02.
.IP "2. \s-1USE_SFIO\s0" 4
.IX Item "2. USE_SFIO"
A \*(L"legacy\*(R" implementation up in termz of tha \*(L"sfio\*(R" library. Used for
some specialist applications on Unix machines (\*(L"sfio\*(R" aint widely
ported away from Unix).  Most of above is #define'd ta tha sfio
functions. PerlIO * is up in dis case Sfio_t *.
.IP "3. \s-1USE_PERLIO\s0" 4
.IX Item "3. USE_PERLIO"
Introduced just afta perl5.7.0, dis be a re-implementation of the
above abstraction which allows perl mo' control over how tha fuck \s-1IO\s0 is done
as it decouplez \s-1IO\s0 from tha way tha operatin system n' C library
choose ta do thangs. For \s-1USE_PERLIO\s0 PerlIO * has a extra layer of
indirection \- it aint nuthin but a pointer-to-a-pointer n' shit.  This allows tha PerlIO *
to remain wit a known value while swappin tha implementation around
underneath \fIat run time\fR. In dis case all tha above is legit (but
very simple) functions which call tha underlyin implementation.
.Sp
This is tha only implementation fo' which \f(CW\*(C`PerlIO_apply_layers()\*(C'\fR
does anythang \*(L"interesting\*(R".
.Sp
Da \s-1USE_PERLIO\s0 implementation is busted lyrics bout up in perliol.
.PP
Because \*(L"perlio.h\*(R" be a thin layer (for efficiency) tha semantics of
these functions is somewhat dependent on tha underlyin implementation.
Where these variations is understood they is noted below.
.PP
Unless otherwise noted, functions return 0 on success, or a negative
value (usually \f(CW\*(C`EOF\*(C'\fR which is probably \-1) n' set \f(CW\*(C`errno\*(C'\fR on error.
.IP "\fB\f(BIPerlIO_stdin()\fB\fR, \fB\f(BIPerlIO_stdout()\fB\fR, \fB\f(BIPerlIO_stderr()\fB\fR" 4
.IX Item "PerlIO_stdin(), PerlIO_stdout(), PerlIO_stderr()"
Use these rather than \f(CW\*(C`stdin\*(C'\fR, \f(CW\*(C`stdout\*(C'\fR, \f(CW\*(C`stderr\*(C'\fR. They is written
to be lookin like \*(L"function calls\*(R" rather than variablez cuz dis makes
it easier ta \fImake them\fR function calls if platform cannot export data
to loaded modules, or if (say) different \*(L"threads\*(R" might have different
values.
.IP "\fBPerlIO_open(path, mode)\fR, \fBPerlIO_fdopen(fd,mode)\fR" 4
.IX Item "PerlIO_open(path, mode), PerlIO_fdopen(fd,mode)"
These correspond ta \fIfopen()\fR/\fIfdopen()\fR n' tha arguments is tha same.
Return \f(CW\*(C`NULL\*(C'\fR n' set \f(CW\*(C`errno\*(C'\fR if there be a error. Shiiit, dis aint no joke.  There may be an
implementation limit on tha number of open handles, which may be lower
than tha limit on tha number of open filez \- \f(CW\*(C`errno\*(C'\fR may not be set
when \f(CW\*(C`NULL\*(C'\fR is returned if dis limit is exceeded.
.IP "\fBPerlIO_reopen(path,mode,f)\fR" 4
.IX Item "PerlIO_reopen(path,mode,f)"
While dis currently exists up in all three implementations perl itself
does not use dat shit. \fIAs perl do not use it, it aint well tested.\fR
.Sp
Perl prefers ta \f(CW\*(C`dup\*(C'\fR tha freshly smoked up low-level descriptor ta tha descriptor
used by tha existin PerlIO. This may become tha behaviour of this
function up in tha future.
.IP "\fBPerlIO_printf(f,fmt,...)\fR, \fBPerlIO_vprintf(f,fmt,a)\fR" 4
.IX Item "PerlIO_printf(f,fmt,...), PerlIO_vprintf(f,fmt,a)"
These is \fIfprintf()\fR/\fIvfprintf()\fR equivalents.
.IP "\fBPerlIO_stdoutf(fmt,...)\fR" 4
.IX Item "PerlIO_stdoutf(fmt,...)"
This is \fIprintf()\fR equivalent. printf is #defined ta dis function,
so it is (currently) legal ta use \f(CW\*(C`printf(fmt,...)\*(C'\fR up in perl sources.
.IP "\fBPerlIO_read(f,buf,count)\fR, \fBPerlIO_write(f,buf,count)\fR" 4
.IX Item "PerlIO_read(f,buf,count), PerlIO_write(f,buf,count)"
These correspond functionally ta \fIfread()\fR n' \fIfwrite()\fR but the
arguments n' return joints is different.  Da \fIPerlIO_read()\fR and
\&\fIPerlIO_write()\fR signatures done been modeled on tha mo' sane low level
\&\fIread()\fR n' \fIwrite()\fR functions instead: Da \*(L"file\*(R" argument is passed
first, there is only one \*(L"count\*(R", n' tha return value can distinguish
between error n' \f(CW\*(C`EOF\*(C'\fR.
.Sp
Returns a funky-ass byte count if successful (which may be zero or
positive), returns wack value n' sets \f(CW\*(C`errno\*(C'\fR on error.
Dependin on implementation \f(CW\*(C`errno\*(C'\fR may be \f(CW\*(C`EINTR\*(C'\fR if operation was
interrupted by a signal.
.IP "\fBPerlIO_close(f)\fR" 4
.IX Item "PerlIO_close(f)"
Dependin on implementation \f(CW\*(C`errno\*(C'\fR may be \f(CW\*(C`EINTR\*(C'\fR if operation was
interrupted by a signal.
.IP "\fBPerlIO_puts(f,s)\fR, \fBPerlIO_putc(f,c)\fR" 4
.IX Item "PerlIO_puts(f,s), PerlIO_putc(f,c)"
These correspond ta \fIfputs()\fR n' \fIfputc()\fR.
Note dat arguments done been revised ta have \*(L"file\*(R" first.
.IP "\fBPerlIO_ungetc(f,c)\fR" 4
.IX Item "PerlIO_ungetc(f,c)"
This correspondz ta \fIungetc()\fR.  Note dat arguments done been revised
to have \*(L"file\*(R" first.  Arranges dat next read operation will return
the byte \fBc\fR.  Despite tha implied \*(L"character\*(R" up in tha name only
values up in tha range 0..0xFF is defined. Y'all KNOW dat shit, muthafucka! Returns tha byte \fBc\fR on
success or \-1 (\f(CW\*(C`EOF\*(C'\fR) on error. Shiiit, dis aint no joke.  Da number of bytes dat can be
\&\*(L"pushed back\*(R" may vary, only 1 characta is certain, n' then only if
it is tha last characta dat was read from tha handle.
.IP "\fBPerlIO_getc(f)\fR" 4
.IX Item "PerlIO_getc(f)"
This correspondz ta \fIgetc()\fR.
Despite tha c up in tha name only byte range 0..0xFF is supported.
Returns tha characta read or \-1 (\f(CW\*(C`EOF\*(C'\fR) on error.
.IP "\fBPerlIO_eof(f)\fR" 4
.IX Item "PerlIO_eof(f)"
This correspondz ta \fIfeof()\fR.  Returns a true/false indication of
whether tha handle be at end of file.  For terminal devices dis may
or may not be \*(L"sticky\*(R" dependin on tha implementation. I aint talkin' bout chicken n' gravy biatch.  Da flag is
cleared by \fIPerlIO_seek()\fR, or \fIPerlIO_rewind()\fR.
.IP "\fBPerlIO_error(f)\fR" 4
.IX Item "PerlIO_error(f)"
This correspondz ta \fIferror()\fR.  Returns a true/false indication of
whether there has been a \s-1IO\s0 error on tha handle.
.IP "\fBPerlIO_fileno(f)\fR" 4
.IX Item "PerlIO_fileno(f)"
This correspondz ta \fIfileno()\fR, note dat on some platforms, tha meaning
of \*(L"fileno\*(R" may not match Unix. Returns \-1 if tha handle has no open
descriptor associated wit dat shit.
.IP "\fBPerlIO_clearerr(f)\fR" 4
.IX Item "PerlIO_clearerr(f)"
This correspondz ta \fIclearerr()\fR, i.e., clears 'error' n' (usually)
\&'eof' flags fo' tha \*(L"stream\*(R". Do not return a value.
.IP "\fBPerlIO_flush(f)\fR" 4
.IX Item "PerlIO_flush(f)"
This correspondz ta \fIfflush()\fR.  Sendz any buffered write data ta the
underlyin file.  If called wit \f(CW\*(C`NULL\*(C'\fR dis may flush all open
streams (or core dump wit some \s-1USE_STDIO\s0 implementations).  Calling
on a handle open fo' read only, or on which last operation was a read
of some kind may lead ta undefined behaviour on some \s-1USE_STDIO\s0
implementations.  Da \s-1USE_PERLIO \s0(layers) implementation tries to
behave better: it flushes all open streams when passed \f(CW\*(C`NULL\*(C'\fR, and
attempts ta retain data on read streams either up in tha buffer or by
seekin tha handle ta tha current logical position.
.IP "\fBPerlIO_seek(f,offset,whence)\fR" 4
.IX Item "PerlIO_seek(f,offset,whence)"
This correspondz ta \fIfseek()\fR.  Sendz buffered write data ta the
underlyin file, or discardz any buffered read data, then positions
the file descriptor as specified by \fBoffset\fR n' \fBwhence\fR (sic).
This is tha erect thang ta do when switchin between read n' write
on tha same handle (see thangs wit \fIPerlIO_flush()\fR above).  Offset is
of type \f(CW\*(C`Off_t\*(C'\fR which be a perl Configure value which may not be same
as stdioz \f(CW\*(C`off_t\*(C'\fR.
.IP "\fBPerlIO_tell(f)\fR" 4
.IX Item "PerlIO_tell(f)"
This correspondz ta \fIftell()\fR.  Returns tha current file position, or
(Off_t) \-1 on error. Shiiit, dis aint no joke.  May just return value system \*(L"knows\*(R" without
makin a system call or checkin tha underlyin file descriptor (so
use on shared file descriptors aint safe without a
\&\fIPerlIO_seek()\fR). Return value iz of type \f(CW\*(C`Off_t\*(C'\fR which be a perl
Configure value which may not be same as stdioz \f(CW\*(C`off_t\*(C'\fR.
.IP "\fBPerlIO_getpos(f,p)\fR, \fBPerlIO_setpos(f,p)\fR" 4
.IX Item "PerlIO_getpos(f,p), PerlIO_setpos(f,p)"
These correspond (loosely) ta \fIfgetpos()\fR n' \fIfsetpos()\fR. Rather than
stdioz Fpos_t they expect a \*(L"Perl Scalar Value\*(R" ta be passed. Y'all KNOW dat shit, muthafucka! What tha fuck iz
stored there should be considered opaque. Da layout of tha data may
vary from handle ta handle.  When not rockin stdio or if platform do
not have tha stdio calls then they is implemented up in terms of
\&\fIPerlIO_tell()\fR n' \fIPerlIO_seek()\fR.
.IP "\fBPerlIO_rewind(f)\fR" 4
.IX Item "PerlIO_rewind(f)"
This correspondz ta \fIrewind()\fR. Well shiiiit, it is probably defined as being
.Sp
.Vb 2
\&    PerlIO_seek(f,(Off_t)0L, SEEK_SET);
\&    PerlIO_clearerr(f);
.Ve
.IP "\fB\f(BIPerlIO_tmpfile()\fB\fR" 4
.IX Item "PerlIO_tmpfile()"
This correspondz ta \fItmpfile()\fR, i.e., returns a anonymous PerlIO or
\&\s-1NULL\s0 on error. Shiiit, dis aint no joke.  Da system will attempt ta automatically delete the
file when closed. Y'all KNOW dat shit, muthafucka!  On Unix tha file is probably \f(CW\*(C`unlink\*(C'\fR\-ed just after
it is pimped so it do not matta how tha fuck it gets closed. Y'all KNOW dat shit, muthafucka! On other
systems tha file may only be deleted if closed via \fIPerlIO_close()\fR
and/or tha program exits via \f(CW\*(C`exit\*(C'\fR.  Dependin on tha implementation
there may be \*(L"race conditions\*(R" which allow other processes access to
the file, though up in general it is ghon be less thuggy up in dis regard than
ad. Y'all KNOW dat shit, muthafucka! hoc. schemes.
.IP "\fBPerlIO_setlinebuf(f)\fR" 4
.IX Item "PerlIO_setlinebuf(f)"
This correspondz ta \fIsetlinebuf()\fR.  Do not return a value. What
constitutes a \*(L"line\*(R" is implementation dependent but probably means
that freestylin \*(L"\en\*(R" flushes tha buffer n' shit.  What happens wit thangs like
\&\*(L"this\enthat\*(R" is uncertain. I aint talkin' bout chicken n' gravy biatch.  (Perl core uses it \fIonly\fR when \*(L"dumping\*(R";
it has not a god damn thang ta do wit $| auto-flush.)
.SS "Co-existence wit stdio"
.IX Subsection "Co-existence wit stdio"
There is outline support fo' co-existence of PerlIO wit stdio.
Obviously if PerlIO is implemented up in termz of stdio there is no
problem yo. However up in other cases then mechanizzlez must exist ta create a
\&\s-1FILE\s0 * which can be passed ta library code which is goin ta use stdio
calls.
.PP
Da first step is ta add dis line:
.PP
.Vb 1
\&   #define PERLIO_NOT_STDIO 0
.Ve
.PP
\&\fIbefore\fR includin any perl header files. (This will probably become
the default at some point).  That prevents \*(L"perlio.h\*(R" from attempting
to #define stdio functions onto PerlIO functions.
.PP
\&\s-1XS\s0 code is probably betta rockin \*(L"typemap\*(R" if it expects \s-1FILE\s0 *
arguments, n' you can put dat on yo' toast.  Da standard typemap is ghon be adjusted ta comprehend any
changes up in dis area.
.IP "\fBPerlIO_importFILE(f,mode)\fR" 4
.IX Item "PerlIO_importFILE(f,mode)"
Used ta git a PerlIO * from a \s-1FILE\s0 *.
.Sp
Da mode argument should be a strang as would be passed to
fopen/PerlIO_open. I aint talkin' bout chicken n' gravy biatch.  If it is \s-1NULL\s0 then \- fo' legacy support \- tha code
will (dependin upon tha platform n' tha implementation) either
attempt ta empirically determine tha mode up in which \fIf\fR is open, or
use \*(L"r+\*(R" ta indicate a read/write stream.
.Sp
Once called tha \s-1FILE\s0 * should \fI\s-1ONLY\s0\fR be closed by calling
\&\f(CW\*(C`PerlIO_close()\*(C'\fR on tha returned PerlIO *.
.Sp
Da PerlIO is set ta textmode. Use PerlIO_binmode if dis is
not tha desired mode.
.Sp
This is \fBnot\fR tha reverse of \fIPerlIO_exportFILE()\fR.
.IP "\fBPerlIO_exportFILE(f,mode)\fR" 4
.IX Item "PerlIO_exportFILE(f,mode)"
Given a PerlIO * create a 'native' \s-1FILE\s0 * suitable fo' passin ta code
expectin ta be compiled n' linked wit \s-1ANSI C \s0\fIstdio.h\fR.  Da mode
argument should be a strang as would be passed ta fopen/PerlIO_open.
If it is \s-1NULL\s0 then \- fo' legacy support \- tha \s-1FILE\s0 * is opened up in same
mode as tha PerlIO *.
.Sp
Da fact dat such a \s-1FILE\s0 * has been 'exported' is recorded, (normally
by pushin a freshly smoked up :stdio \*(L"layer\*(R" onto tha PerlIO *), which may affect
future PerlIO operations on tha original gangsta PerlIO *.  Yo ass should not
call \f(CW\*(C`fclose()\*(C'\fR on tha file unless you call \f(CW\*(C`PerlIO_releaseFILE()\*(C'\fR
to disassociate it from tha PerlIO *.  (Do not use \fIPerlIO_importFILE()\fR
for bustin tha disassociation.)
.Sp
Callin dis function repeatedly will create a \s-1FILE\s0 * on each call
(and will push a :stdio layer each time as well).
.IP "\fBPerlIO_releaseFILE(p,f)\fR" 4
.IX Item "PerlIO_releaseFILE(p,f)"
Callin PerlIO_releaseFILE informs PerlIO dat all use of \s-1FILE\s0 * is
complete. Well shiiiit, it is removed from tha list of 'exported' \s-1FILE\s0 *s, n' the
associated PerlIO * should revert ta its original gangsta behaviour.
.Sp
Use dis ta disassociate a gangbangin' file from a PerlIO * dat was associated
usin \fIPerlIO_exportFILE()\fR.
.IP "\fBPerlIO_findFILE(f)\fR" 4
.IX Item "PerlIO_findFILE(f)"
Returns a natizzle \s-1FILE\s0 * used by a stdio layer n' shit. If there is none, it
will create one wit PerlIO_exportFILE. In either case tha \s-1FILE\s0 *
should be considered as belongin ta PerlIO subsystem n' should
only be closed by callin \f(CW\*(C`PerlIO_close()\*(C'\fR.
.ie n .SS """Fast gets"" Functions"
.el .SS "``Fast gets'' Functions"
.IX Subsection "Fast gets Functions"
In addizzle ta standard-like \s-1API\s0 defined so far above there be an
\&\*(L"implementation\*(R" intercourse which allows perl ta git at internals of
PerlIO.  Da followin calls correspond ta tha various FILE_xxx macros
determined by Configure \- or they equivalent up in other
implementations. This section is straight-up of interest ta only them
concerned wit detailed perl-core behaviour, implementin a PerlIO
mappin or freestylin code which can make use of tha \*(L"read ahead\*(R" that
has been done by tha \s-1IO\s0 system up in tha same way perl do. Note that
any code dat uses these intercourses must be prepared ta do thangs the
traditionizzle way if a handle do not support em.
.IP "\fBPerlIO_fast_gets(f)\fR" 4
.IX Item "PerlIO_fast_gets(f)"
Returns legit if implementation has all tha intercourses required to
allow perlz \f(CW\*(C`sv_gets\*(C'\fR ta \*(L"bypass\*(R" aiiight \s-1IO\s0 mechanism.  This can
vary from handle ta handle.
.Sp
.Vb 3
\&  PerlIO_fast_gets(f) = PerlIO_has_cntptr(f) && \e
\&                        PerlIO_canset_cnt(f) && \e
\&                        \*(AqCan set pointa tha fuck into buffer\*(Aq
.Ve
.IP "\fBPerlIO_has_cntptr(f)\fR" 4
.IX Item "PerlIO_has_cntptr(f)"
Implementation can return pointa ta current posizzle up in tha \*(L"buffer\*(R"
and a cold-ass lil count of bytes available up in tha buffer n' shit.  Do not use dis \- use
PerlIO_fast_gets.
.IP "\fBPerlIO_get_cnt(f)\fR" 4
.IX Item "PerlIO_get_cnt(f)"
Return count of readable bytes up in tha buffer n' shit. Zero or wack return
means no mo' bytes available.
.IP "\fBPerlIO_get_ptr(f)\fR" 4
.IX Item "PerlIO_get_ptr(f)"
Return pointa ta next readable byte up in buffer, accessin via the
pointa (dereferencing) is only safe if \fIPerlIO_get_cnt()\fR has returned
a positizzle value.  Only positizzle offsets up ta value returned by
\&\fIPerlIO_get_cnt()\fR is allowed.
.IP "\fBPerlIO_set_ptrcnt(f,p,c)\fR" 4
.IX Item "PerlIO_set_ptrcnt(f,p,c)"
Set pointa tha fuck into buffer, n' a cold-ass lil count of bytes still up in the
buffer n' shit. Right back up in yo muthafuckin ass. Should be used only ta set pointa ta within range implied by
previous calls ta \f(CW\*(C`PerlIO_get_ptr\*(C'\fR n' \f(CW\*(C`PerlIO_get_cnt\*(C'\fR. Da two
values \fImust\fR be consistent wit each other (implementation may only
use one or tha other or may require both).
.IP "\fBPerlIO_canset_cnt(f)\fR" 4
.IX Item "PerlIO_canset_cnt(f)"
Implementation can adjust its scam of number of bytes up in tha buffer.
Do not use dis \- use PerlIO_fast_gets.
.IP "\fBPerlIO_set_cnt(f,c)\fR" 4
.IX Item "PerlIO_set_cnt(f,c)"
Obscure \- set count of bytes up in tha buffer n' shit. Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Only usable
if \fIPerlIO_canset_cnt()\fR returns true.  Currently used up in only doio.c to
force count less than \-1 ta \-1.  Perhaps should be PerlIO_set_empty or
similar. Shiiit, dis aint no joke.  This call may straight-up do not a god damn thang if \*(L"count\*(R" is deduced from
pointa n' a \*(L"limit\*(R".  Do not use dis \- use \fIPerlIO_set_ptrcnt()\fR.
.IP "\fBPerlIO_has_base(f)\fR" 4
.IX Item "PerlIO_has_base(f)"
Returns legit if implementation has a funky-ass buffer, n' can return pointer
to whole buffer n' its size. Used by perl fo' \fB\-T\fR / \fB\-B\fR tests.
Other uses would be straight-up obscure...
.IP "\fBPerlIO_get_base(f)\fR" 4
.IX Item "PerlIO_get_base(f)"
Return \fIstart\fR of buffer n' shiznit fo' realz. Access only positizzle offsets up in tha buffer
up ta tha value returned by \fIPerlIO_get_bufsiz()\fR.
.IP "\fBPerlIO_get_bufsiz(f)\fR" 4
.IX Item "PerlIO_get_bufsiz(f)"
Return tha \fItotal number of bytes\fR up in tha buffer, dis is neither the
number dat can be read, nor tha amount of memory allocated ta the
buffer n' shit. Rather it is what tha fuck tha operatin system and/or implementation
happened ta \f(CW\*(C`read()\*(C'\fR (or whatever) last time \s-1IO\s0 was requested.
.SS "Other Functions"
.IX Subsection "Other Functions"
.IP "PerlIO_apply_layers(f,mode,layers)" 4
.IX Item "PerlIO_apply_layers(f,mode,layers)"
Da freshly smoked up intercourse ta tha \s-1USE_PERLIO\s0 implementation. I aint talkin' bout chicken n' gravy biatch. Da layers \*(L":crlf\*(R"
and \*(L":raw\*(R" is only ones allowed fo' other implementations n' them
are silently ignored. Y'all KNOW dat shit, muthafucka! (Az of perl5.8 \*(L":raw\*(R" is deprecated.)  Use
\&\fIPerlIO_binmode()\fR below fo' tha portable case.
.IP "PerlIO_binmode(f,ptype,imode,layers)" 4
.IX Item "PerlIO_binmode(f,ptype,imode,layers)"
Da hook used by perlz \f(CW\*(C`binmode\*(C'\fR operator.
\&\fBptype\fR is perlz characta fo' tha kind of \s-1IO:\s0
.RS 4
.IP "'<' read" 8
.IX Item "'<' read"
.PD 0
.IP "'>' write" 8
.IX Item "'>' write"
.IP "'+' read/write" 8
.IX Item "'+' read/write"
.RE
.RS 4
.PD
.Sp
\&\fBimode\fR is \f(CW\*(C`O_BINARY\*(C'\fR or \f(CW\*(C`O_TEXT\*(C'\fR.
.Sp
\&\fBlayers\fR be a strang of layers ta apply, only \*(L":crlf\*(R" make sense in
the non \s-1USE_PERLIO\s0 case. (Az of perl5.8 \*(L":raw\*(R" is deprecated up in favour
of passin \s-1NULL.\s0)
.Sp
Portable cases are:
.Sp
.Vb 3
\&    PerlIO_binmode(f,ptype,O_BINARY,NULL);
\&and
\&    PerlIO_binmode(f,ptype,O_TEXT,":crlf");
.Ve
.Sp
On Unix these calls probably have no effect whatsoever n' shit.  Elsewhere
they alta \*(L"\en\*(R" ta \s-1CR,LF\s0 translation n' possibly cause a special text
\&\*(L"end of file\*(R" indicator ta be freestyled or honoured on read. Y'all KNOW dat shit, muthafucka! Da effect
of makin tha call afta bustin any \s-1IO\s0 ta tha handle dependz on the
implementation. I aint talkin' bout chicken n' gravy biatch. (It may be ignored, affect any data which be already
buffered as well, or only apply ta subsequent data.)
.RE
.IP "PerlIO_debug(fmt,...)" 4
.IX Item "PerlIO_debug(fmt,...)"
PerlIO_debug be a \fIprintf()\fR\-like function which can be used for
debugging.  No return value. Its main use is inside PerlIO where using
real printf, \fIwarn()\fR etc. would recursively call PerlIO n' be a
problem.
.Sp
PerlIO_debug writes ta tha file named by \f(CW$ENV\fR{'\s-1PERLIO_DEBUG\s0'} typical
use might be
.Sp
.Vb 2
\&  Bourne shells (sh, ksh, bash, zsh, ash, ...):
\&   PERLIO_DEBUG=/dev/tty ./perl somescript some args
\&
\&  Csh/Tcsh:
\&   setenv PERLIO_DEBUG /dev/tty
\&   ./perl somescript some args
\&
\&  If you have tha "env" utility:
\&   env PERLIO_DEBUG=/dev/tty ./perl somescript some args
\&
\&  Win32:
\&   set PERLIO_DEBUG=CON
\&   perl somescript some args
.Ve
.Sp
If \f(CW$ENV\fR{'\s-1PERLIO_DEBUG\s0'} aint set \fIPerlIO_debug()\fR be a no-op.
