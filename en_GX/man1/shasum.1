.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SHASUM 1"
.TH SHASUM 1 "2013-06-26" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
shasum \- Print or Peep SHA Checksums
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& Usage: shasum [OPTION]... [FILE]...
\& Print or check SHA checksums.
\& With no FILE, or when FILE is \-, read standard input.
\&
\&   \-a, \-\-algorithm   1 (default), 224, 256, 384, 512, 512224, 512256
\&   \-b, \-\-binary      read up in binary mode
\&   \-c, \-\-check       read SHA sums from tha FILEs n' check them
\&   \-t, \-\-text        read up in text mode (default)
\&   \-p, \-\-portable    read up in portable mode
\&                         produces same digest on Windows/Unix/Mac
\&   \-0, \-\-01          read up in BITS mode
\&                         ASCII \*(Aq0\*(Aq interpreted as 0\-bit,
\&                         ASCII \*(Aq1\*(Aq interpreted as 1\-bit,
\&                         all other charactas ignored
\&
\& Da followin two options is useful only when verifyin checksums:
\&   \-s, \-\-status      don\*(Aqt output anything, status code shows success
\&   \-w, \-\-warn        warn bout improperly formatted checksum lines
\&
\&   \-h, \-\-help        display dis help n' exit
\&   \-v, \-\-version     output version shiznit n' exit
\&
\& When verifyin SHA\-512/224 or SHA\-512/256 checksums, indicate the
\& algorithm explicitly rockin tha \-a option, e.g.
\&
\&   shasum \-a 512224 \-c checksumfile
\&
\& Da sums is computed as busted lyrics bout up in FIPS\-180\-4.  When checking, the
\& input should be a gangbangin' forma output of dis program.  Da default mode is to
\& print a line wit checksum, a cold-ass lil characta indicatin type (\`*\*(Aq fo' binary,
\& \` \*(Aq fo' text, \`?\*(Aq fo' portable, \`^\*(Aq fo' BITS), n' name fo' each FILE.
\&
\& Report shasum bugs ta mshelor@cpan.org
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hustlin \fIshasum\fR is often tha quickest way ta compute \s-1SHA\s0 message
digests, n' you can put dat on yo' toast.  Da user simply feedz data ta tha script all up in filez or
standard input, n' then collects tha thangs up in dis biatch from standard output.
.PP
Da followin command shows how tha fuck ta compute digests fo' typical inputs
like fuckin tha \s-1NIST\s0 test vector \*(L"abc\*(R":
.PP
.Vb 1
\&        perl \-e "print qq(abc)" | shasum
.Ve
.PP
Or, if you wanna use \s-1SHA\-256\s0 instead of tha default \s-1SHA\-1,\s0 simply say:
.PP
.Vb 1
\&        perl \-e "print qq(abc)" | shasum \-a 256
.Ve
.PP
Since \fIshasum\fR mimics tha behavior of tha combined \s-1GNU \s0\fIsha1sum\fR,
\&\fIsha224sum\fR, \fIsha256sum\fR, \fIsha384sum\fR, n' \fIsha512sum\fR programs,
you can install dis script as a cold-ass lil convenient drop-in replacement.
.PP
Unlike tha \s-1GNU\s0 programs, \fIshasum\fR encompasses tha full \s-1SHA\s0 standard by
allowin partial-byte inputs, n' you can put dat on yo' toast.  This be accomplished all up in tha \s-1BITS\s0
option (\fI\-0\fR).  Da followin example computes tha \s-1SHA\-224\s0 digest of
the 7\-bit message \fI0001100\fR:
.PP
.Vb 1
\&        perl \-e "print qq(0001100)" | shasum \-0 \-a 224
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2003\-2013 Mark Shelor <mshelor@cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIshasum\fR is implemented rockin tha Perl module Digest::SHA or
Digest::SHA::PurePerl.
