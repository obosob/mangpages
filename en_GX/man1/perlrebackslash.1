.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREBACKSLASH 1"
.TH PERLREBACKSLASH 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrebackslash \- Perl Regular Expression Backslash Sequences n' Escapes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da top level documentation bout Perl regular expressions
is found up in perlre.
.PP
This document raps bout all backslash n' escape sequences fo' realz. After
explainin tha role of tha backslash, it lists all tha sequences dat have
a special meanin up in Perl regular expressions (in alphabetical order),
then raps bout each of em.
.PP
Most sequences is busted lyrics bout up in detail up in different documents; tha primary
purpose of dis document is ta git a quick reference guide describin all
backslash n' escape sequences.
.SS "Da backslash"
.IX Subsection "Da backslash"
In a regular expression, tha backslash can big-ass up one of two tasks:
it either takes away tha special meanin of tha characta followin it
(for instance, \f(CW\*(C`\e|\*(C'\fR matches a vertical bar, it aint a alternation),
or it is tha start of a funky-ass backslash or escape sequence.
.PP
Da rulez determinin what tha fuck it be is like simple: if tha character
followin tha backslash be a \s-1ASCII\s0 punctuation (non-word) characta (that is,
anythang dat aint a letter, digit, or underscore), then tha backslash just
takes away any special meanin of tha characta followin dat shit.
.PP
If tha characta followin tha backslash be a \s-1ASCII\s0 letta or a \s-1ASCII\s0 digit,
then tha sequence may be special; if so, itz listed below fo' realz. A few lettas have
not been used yet, so escapin dem wit a funky-ass backslash don't chizzle dem ta be
special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  A future version of Perl may assign a special meanin ta them, so if
you have warnings turned on, Perl thangs a warnin if you use such a
sequence.  [1].
.PP
It be however guaranteed dat backslash or escape sequences never have a
punctuation characta followin tha backslash, not now, n' not up in a gangbangin' future
version of Perl 5. Right back up in yo muthafuckin ass. So it is safe ta put a funky-ass backslash up in front of a non-word
character.
.PP
Note dat tha backslash itself is special; if you wanna match a funky-ass backslash,
you gotta escape tha backslash wit a funky-ass backslash: \f(CW\*(C`/\e\e/\*(C'\fR matches a single
backslash.
.IP "[1]" 4
.IX Item "[1]"
There is one exception. I aint talkin' bout chicken n' gravy biatch. If you use a alphanumeric characta as the
delimita of yo' pattern (which you probably shouldn't do fo' readability
reasons), you gotta escape tha delimita if you wanna match
it. Perl won't warn then. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See also \*(L"Gory detailz of parsing
quoted constructs\*(R" up in perlop.
.SS "All tha sequences n' escapes"
.IX Subsection "All tha sequences n' escapes"
Those not usable within a funky-ass bracketed characta class (like \f(CW\*(C`[\eda\-z]\*(C'\fR) is marked
as \f(CW\*(C`Not up in [].\*(C'\fR
.PP
.Vb 10
\& \e000              Octal escape sequence.  See also \eo{}.
\& \e1                Absolute backreference.  Not up in [].
\& \ea                Alarm or bell.
\& \eA                Beginnin of string.  Not up in [].
\& \eb                Word/non\-word boundary. (Backspace up in []).
\& \eB                Not a word/non\-word boundary.  Not up in [].
\& \ecX               Control\-X.
\& \eC                Single octet, even under UTF\-8.  Not up in [].
\& \ed                Characta class fo' digits.
\& \eD                Characta class fo' non\-digits.
\& \ee                Escape character.
\& \eE                Turn off \eQ, \eL n' \eU processing.  Not up in [].
\& \ef                Form feed.
\& \eF                Foldcase till \eE.  Not up in [].
\& \eg{}, \eg1         Named, absolute or relatizzle backreference.
\&                   Not up in [].
\& \eG                Pos assertion. I aint talkin' bout chicken n' gravy biatch.  Not up in [].
\& \eh                Characta class fo' horizontal whitespace.
\& \eH                Characta class fo' non horizontal whitespace.
\& \ek{}, \ek<>, \ek\*(Aq\*(Aq  Named backreference.  Not up in [].
\& \eK                Keep tha shiznit left of \eK.  Not up in [].
\& \el                Lowercase next character n' shit.  Not up in [].
\& \eL                Lowercase till \eE.  Not up in [].
\& \en                (Logical) newline character.
\& \eN                Any characta but newline.  Not up in [].
\& \eN{}              Named or numbered (Unicode) characta or sequence.
\& \eo{}              Octal escape sequence.
\& \ep{}, \epP         Characta wit tha given Unicode property.
\& \eP{}, \ePP         Characta without tha given Unicode property.
\& \eQ                Quote (disable) pattern metacharactas till \eE.  Not
\&                   up in [].
\& \er                Return character.
\& \eR                Generic freshly smoked up line.  Not up in [].
\& \es                Characta class fo' whitespace.
\& \eS                Characta class fo' non whitespace.
\& \et                Tab character.
\& \eu                Titlecase next character n' shit.  Not up in [].
\& \eU                Uppercase till \eE.  Not up in [].
\& \ev                Characta class fo' vertical whitespace.
\& \eV                Characta class fo' non vertical whitespace.
\& \ew                Characta class fo' word characters.
\& \eW                Characta class fo' non\-word characters.
\& \ex{}, \ex00        Hexadecimal escape sequence.
\& \eX                Unicode "extended grapheme cluster".  Not up in [].
\& \ez                End of string.  Not up in [].
\& \eZ                End of string.  Not up in [].
.Ve
.SS "Characta Escapes"
.IX Subsection "Characta Escapes"
\fIFixed characters\fR
.IX Subsection "Fixed characters"
.PP
A handful of charactas gotz a thugged-out dedicated \fIcharacta escape\fR. Da following
table shows them, along wit they \s-1ASCII\s0 code points (in decimal n' hex),
their \s-1ASCII\s0 name, tha control escape on \s-1ASCII\s0 platforms n' a gangbangin' finger-lickin' dirty-ass short
description. I aint talkin' bout chicken n' gravy biatch.  (For \s-1EBCDIC\s0 platforms, peep \*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 up in perlebcdic.)
.PP
.Vb 9
\& Seq.  Code Point  ASCII   Cntrl   Description.
\&       Dec    Hex
\&  \ea     7     07    BEL    \ecG    alarm or bell
\&  \eb     8     08     BS    \ecH    backspace [1]
\&  \ee    27     1B    ESC    \ec[    escape character
\&  \ef    12     0C     FF    \ecL    form feed
\&  \en    10     0A     LF    \ecJ    line feed [2]
\&  \er    13     0D     CR    \ecM    carriage return
\&  \et     9     09    TAB    \ecI    tab
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\eb\*(C'\fR is tha backspace characta only inside a cold-ass lil characta class. Outside a
characta class, \f(CW\*(C`\eb\*(C'\fR be a word/non\-word boundary.
.IP "[2]" 4
.IX Item "[2]"
\&\f(CW\*(C`\en\*(C'\fR matches a logical newline. Perl converts between \f(CW\*(C`\en\*(C'\fR n' your
\&\s-1OS\s0z natizzle newline characta when readin from or freestylin ta text files.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\et/;   # Matches if $str gotz nuff a (horizontal) tab.
.Ve
.PP
\fIControl characters\fR
.IX Subsection "Control characters"
.PP
\&\f(CW\*(C`\ec\*(C'\fR is used ta denote a cold-ass lil control character; tha characta followin \f(CW\*(C`\ec\*(C'\fR
determines tha value of tha construct.  For example tha value of \f(CW\*(C`\ecA\*(C'\fR is
\&\f(CWchr(1)\fR, n' tha value of \f(CW\*(C`\ecb\*(C'\fR is \f(CWchr(2)\fR, etc.
Da gory details is up in \*(L"Regexp Quote-Like Operators\*(R" up in perlop.  A complete
list of what tha fuck \f(CWchr(1)\fR, etc. means fo' \s-1ASCII\s0 n' \s-1EBCDIC\s0 platforms is in
\&\*(L"\s-1OPERATOR DIFFERENCES\*(R"\s0 up in perlebcdic.
.PP
Note dat \f(CW\*(C`\ec\e\*(C'\fR ridin' solo all up in tha end of a regular expression (or doubled-quoted
string) aint valid. Y'all KNOW dat shit, muthafucka!  Da backslash must be followed by another character.
That is, \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR means \f(CW\*(C`chr(28) . \*(Aq\f(CIX\f(CW\*(Aq\*(C'\fR fo' all charactas \fIX\fR.
.PP
To write platform-independent code, you must use \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR instead, like
\&\f(CW\*(C`\eN{ESCAPE}\*(C'\fR or \f(CW\*(C`\eN{U+001B}\*(C'\fR, peep charnames.
.PP
Mnemonic: \fIc\fRontrol character.
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\ecK/;  # Matches if $str gotz nuff a vertical tab (control\-K).
.Ve
.PP
\fINamed or numbered charactas n' characta sequences\fR
.IX Subsection "Named or numbered charactas n' characta sequences"
.PP
Unicode charactas gotz a Unicode name n' numeric code point (ordinal)
value.  Use the
\&\f(CW\*(C`\eN{}\*(C'\fR construct ta specify a cold-ass lil characta by either of these joints.
Certain sequencez of charactas also have names.
.PP
To specify by name, tha name of tha characta or characta sequence goes
between tha curly braces.
.PP
To specify a cold-ass lil characta by Unicode code point, use tha form \f(CW\*(C`\eN{U+\f(CIcode
point\f(CW}\*(C'\fR, where \fIcode point\fR be a number up in hexadecimal dat gives the
code point dat Unicode has assigned ta tha desired character n' shit.  It is
customary but not required ta use leadin zeros ta pad tha number ta 4
digits, n' you can put dat on yo' toast.  Thus \f(CW\*(C`\eN{U+0041}\*(C'\fR means \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR, n' you will
rarely peep it freestyled without tha two leadin zeros.  \f(CW\*(C`\eN{U+0041}\*(C'\fR means
\&\*(L"A\*(R" even on \s-1EBCDIC\s0 machines (where tha ordinal value of \*(L"A\*(R" aint 0x41).
.PP
It be even possible ta give yo' own names ta charactas n' character
sequences.  For details, peep charnames.
.PP
(There be a expanded internal form dat you may peep up in debug output:
\&\f(CW\*(C`\eN{U+\f(CIcode point\f(CW.\f(CIcode point\f(CW...}\*(C'\fR.
Da \f(CW\*(C`...\*(C'\fR means any number of these \fIcode point\fRs separated by dots.
This represents tha sequence formed by tha characters.  This be a internal
form only, subject ta chizzle, n' you should not try ta use it yo ass.)
.PP
Mnemonic: \fIN\fRamed character.
.PP
Note dat a cold-ass lil characta or characta sequence expressed as a named
or numbered characta is considered a cold-ass lil characta without special
meanin by tha regex engine, n' will match \*(L"as is\*(R".
.PP
Example
.IX Subsection "Example"
.PP
.Vb 1
\& $str =~ /\eN{THAI CHARACTER SO SO}/;  # Matches tha Thai SO SO character
\&
\& use charnames \*(AqCyrillic\*(Aq;            # Loadz Cyrillic names.
\& $str =~ /\eN{ZHE}\eN{KA}/;             # Match "ZHE" followed by "KA".
.Ve
.PP
\fIOctal escapes\fR
.IX Subsection "Octal escapes"
.PP
There is two formz of octal escapes.  Each is used ta specify a cold-ass lil characta by
its code point specified up in octal notation.
.PP
One form, available startin up in Perl 5.14 be lookin like \f(CW\*(C`\eo{...}\*(C'\fR, where tha dots
represent one or mo' octal digits, n' you can put dat on yo' toast.  It can be used fo' any Unicode character.
.PP
Dat shiznit was introduced ta avoid tha potential problems wit tha other form,
available up in all Perls.  That form consistz of a funky-ass backslash followed by three
octal digits, n' you can put dat on yo' toast.  One problem wit dis form is dat it can look exactly like an
old-style backreference (see
\&\*(L"Disambiguation rulez between old-style octal escapes n' backreferences\*(R"
below.)  Yo ass can avoid dis by makin tha straight-up original gangsta of tha three digits always a
zero yo, but dat make \e077 tha phattest code point specifiable.
.PP
In some contexts, a funky-ass backslash followed by two or even one octal digits may be
interpreted as a octal escape, sometimes wit a warning, n' cuz of some
bugs, sometimes wit surprisin thangs up in dis biatch.  Also, if yo ass is bustin a regex
out of smalla snippets concatenated together, n' you use fewer than three
digits, tha beginnin of one snippet may be interpreted as addin digits ta the
endin of tha snippet before dat shit.  See \*(L"Absolute referencing\*(R" fo' more
rap n' examplez of tha snippet problem.
.PP
Note dat a cold-ass lil characta expressed as a octal escape is considered
a characta without special meanin by tha regex engine, n' will match
\&\*(L"as is\*(R".
.PP
To summarize, tha \f(CW\*(C`\eo{}\*(C'\fR form be always safe ta use, n' tha other form is
safe ta use fo' code points all up in \e077 when you use exactly three digits to
specify em.
.PP
Mnemonic: \fI0\fRctal or \fIo\fRctal.
.PP
Examplez (assumin a \s-1ASCII\s0 platform)
.IX Subsection "Examplez (assumin a ASCII platform)"
.PP
.Vb 9
\& $str = "Perl";
\& $str =~ /\eo{120}/;  # Match, "\e120" is "P".
\& $str =~ /\e120/;     # Same.
\& $str =~ /\eo{120}+/; # Match, "\e120" is "P",
\&                     # it\*(Aqs repeated at least once.
\& $str =~ /\e120+/;    # Same.
\& $str =~ /P\e053/;    # No match, "\e053" is "+" n' taken literally.
\& /\eo{23073}/         # Black foreground, white background smilin face.
\& /\eo{4801234567}/    # Raises a warning, n' yieldz chr(4).
.Ve
.PP
Disambiguation rulez between old-style octal escapes n' backreferences
.IX Subsection "Disambiguation rulez between old-style octal escapes n' backreferences"
.PP
Octal escapez of tha \f(CW\*(C`\e000\*(C'\fR form outside of bracketed characta classes
potentially clash wit old-style backreferences (see \*(L"Absolute referencing\*(R"
below).  They both consist of a funky-ass backslash followed by numbers.  So Perl has to
use heuristics ta determine whether it aint nuthin but a funky-ass backreference or a octal escape.
Perl uses tha followin rulez ta disambiguate:
.IP "1." 4
If tha backslash is followed by a single digit, itz a funky-ass backreference.
.IP "2." 4
If tha straight-up original gangsta digit followin tha backslash be a 0, itz a octal escape.
.IP "3." 4
If tha number followin tha backslash is N (in decimal), n' Perl already
has peeped N capture groups, Perl considaz dis a funky-ass backreference.  Otherwise,
it considaz it a octal escape. If N has mo' than three digits, Perl
takes only tha straight-up original gangsta three fo' tha octal escape; tha rest is matched as is.
.Sp
.Vb 6
\& mah $pat  = "(" x 999;
\&    $pat .= "a";
\&    $pat .= ")" x 999;
\& /^($pat)\e1000$/;   #  Matches \*(Aqaa\*(Aq; there be 1000 capture groups.
\& /^$pat\e1000$/;     #  Matches \*(Aqa@0\*(Aq; there be 999 capture groups
\&                    #  n' \e1000 is peeped as \e100 (a \*(Aq@\*(Aq) n' a \*(Aq0\*(Aq.
.Ve
.PP
Yo ass can force a funky-ass backreference interpretation always by rockin tha \f(CW\*(C`\eg{...}\*(C'\fR
form.  Yo ass can tha force a octal interpretation always by rockin tha \f(CW\*(C`\eo{...}\*(C'\fR
form, or fo' numbers up all up in \e077 (= 63 decimal), by rockin three digits,
beginnin wit a \*(L"0\*(R".
.PP
\fIHexadecimal escapes\fR
.IX Subsection "Hexadecimal escapes"
.PP
Like octal escapes, there be two formz of hexadecimal escapes yo, but both start
with tha same thang, \f(CW\*(C`\ex\*(C'\fR.  This is followed by either exactly two hexadecimal
digits formin a number, or a hexadecimal number of arbitrary length surrounded
by curly braces. Da hexadecimal number is tha code point of tha characta you
wanna express.
.PP
Note dat a cold-ass lil characta expressed as one of these escapes is considered a
characta without special meanin by tha regex engine, n' will match
\&\*(L"as is\*(R".
.PP
Mnemonic: he\fIx\fRadecimal.
.PP
Examplez (assumin a \s-1ASCII\s0 platform)
.IX Subsection "Examplez (assumin a ASCII platform)"
.PP
.Vb 4
\& $str = "Perl";
\& $str =~ /\ex50/;    # Match, "\ex50" is "P".
\& $str =~ /\ex50+/;   # Match, "\ex50" is "P", it is repeated at least once
\& $str =~ /P\ex2B/;   # No match, "\ex2B" is "+" n' taken literally.
\&
\& /\ex{2603}\ex{2602}/ # Snowman wit a umbrella.
\&                    # Da Unicode characta 2603 be a snowman,
\&                    # tha Unicode characta 2602 be a umbrella.
\& /\ex{263B}/         # Black smilin face.
\& /\ex{263b}/         # Same, tha hex digits A \- F is case insensitive.
.Ve
.SS "Modifiers"
.IX Subsection "Modifiers"
A number of backslash sequences gotta do wit changin tha character,
or charactas followin em. \f(CW\*(C`\el\*(C'\fR will lowercase tha characta following
it, while \f(CW\*(C`\eu\*(C'\fR will uppercase (or, mo' accurately, titlecase) the
characta followin dat shit. They provide functionalitizzle similar ta the
functions \f(CW\*(C`lcfirst\*(C'\fR n' \f(CW\*(C`ucfirst\*(C'\fR.
.PP
To uppercase or lowercase nuff muthafuckin characters, one might wanna use
\&\f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR, which will lowercase/uppercase all charactas following
them, until either tha end of tha pattern or tha next occurrence of
\&\f(CW\*(C`\eE\*(C'\fR, whichever comes first. They provide functionalitizzle similar ta what
the functions \f(CW\*(C`lc\*(C'\fR n' \f(CW\*(C`uc\*(C'\fR provide.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR is used ta quote (disable) pattern metacharacters, up ta tha next
\&\f(CW\*(C`\eE\*(C'\fR or tha end of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`\eQ\*(C'\fR addz a funky-ass backslash ta any character
that could have special meanin ta Perl.  In tha \s-1ASCII\s0 range, it quotes
every characta dat aint a letter, digit, or underscore.  See
\&\*(L"quotemeta\*(R" up in perlfunc fo' details on what tha fuck gets quoted fo' non-ASCII
code points, n' you can put dat on yo' toast.  Usin dis ensures dat any characta between \f(CW\*(C`\eQ\*(C'\fR and
\&\f(CW\*(C`\eE\*(C'\fR is ghon be matched literally, not interpreted as a metacharacta by
the regex engine.
.PP
\&\f(CW\*(C`\eF\*(C'\fR can be used ta casefold all charactas following, up ta tha next \f(CW\*(C`\eE\*(C'\fR
or tha end of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it serves up tha functionalitizzle similar to
the \f(CW\*(C`fc\*(C'\fR function.
.PP
Mnemonic: \fIL\fRowercase, \fIU\fRppercase, \fIF\fRold-case, \fIQ\fRuotemeta, \fIE\fRnd.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& $sid     = "sid";
\& $greg    = "GrEg";
\& $miranda = "(Miranda)";
\& $str     =~ /\eu$sid/;        # Matches \*(AqSid\*(Aq
\& $str     =~ /\eL$greg/;       # Matches \*(Aqgreg\*(Aq
\& $str     =~ /\eQ$miranda\eE/;  # Matches \*(Aq(Miranda)\*(Aq, as if tha pattern
\&                              #   had been freestyled as /\e(Miranda\e)/
.Ve
.SS "Characta classes"
.IX Subsection "Characta classes"
Perl regular expressions gotz a big-ass range of characta classes. Right back up in yo muthafuckin ass. Some of
the characta classes is freestyled as a funky-ass backslash sequence. Us thugs will briefly
say shit bout dem here; full detailz of characta classes can be found in
perlrecharclass.
.PP
\&\f(CW\*(C`\ew\*(C'\fR be a cold-ass lil characta class dat matches any single \fIword\fR character
(letters, digits, Unicode marks, n' connector punctuation (like the
underscore)).  \f(CW\*(C`\ed\*(C'\fR be a cold-ass lil characta class dat matches any decimal
digit, while tha characta class \f(CW\*(C`\es\*(C'\fR matches any whitespace character.
New up in perl 5.10.0 is tha classes \f(CW\*(C`\eh\*(C'\fR n' \f(CW\*(C`\ev\*(C'\fR which match horizontal
and vertical whitespace characters.
.PP
Da exact set of charactas matched by \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, n' \f(CW\*(C`\ew\*(C'\fR varies
dependin on various pragma n' regular expression modifiers.  It is
possible ta restrict tha match ta tha \s-1ASCII\s0 range by rockin tha \f(CW\*(C`/a\*(C'\fR
regular expression modifier n' shit.  See perlrecharclass.
.PP
Da uppercase variants (\f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\eH\*(C'\fR, n' \f(CW\*(C`\eV\*(C'\fR) are
characta classes dat match, respectively, any characta dat aint a
word character, digit, whitespace, horizontal whitespace, or vertical
whitespace.
.PP
Mnemonics: \fIw\fRord, \fId\fRigit, \fIs\fRpace, \fIh\fRorizontal, \fIv\fRertical.
.PP
\fIUnicode classes\fR
.IX Subsection "Unicode classes"
.PP
\&\f(CW\*(C`\epP\*(C'\fR (where \f(CW\*(C`P\*(C'\fR be a single letter) n' \f(CW\*(C`\ep{Property}\*(C'\fR is used to
match a cold-ass lil characta dat matches tha given Unicode property; properties
include thangs like \*(L"letter\*(R", or \*(L"thai character\*(R". Capitalizin the
sequence ta \f(CW\*(C`\ePP\*(C'\fR n' \f(CW\*(C`\eP{Property}\*(C'\fR make tha sequence match a cold-ass lil character
that don't match tha given Unicode property. For mo' details, see
\&\*(L"Backslash sequences\*(R" up in perlrecharclass and
\&\*(L"Unicode Characta Properties\*(R" up in perlunicode.
.PP
Mnemonic: \fIp\fRroperty.
.SS "Referencing"
.IX Subsection "Referencing"
If capturin parenthesis is used up in a regular expression, we can refer
to tha part of tha source strang dat was matched, n' match exactly the
same thang. There is three wayz of referrin ta such \fIbackreference\fR:
straight-up, relatively, n' by name.
.PP
\fIAbsolute referencing\fR
.IX Subsection "Absolute referencing"
.PP
Either \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR (startin up in Perl 5.10.0), or \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR (old-style) where \fIN\fR
is a positizzle (unsigned) decimal number of any length be a absolute reference
to a cold-ass lil capturin group.
.PP
\&\fIN\fR refers ta tha Nth set of parentheses, so \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR refers ta whatever has
been matched by dat set of parentheses.  Thus \f(CW\*(C`\eg1\*(C'\fR refers ta tha first
capture crew up in tha regex.
.PP
Da \f(CW\*(C`\eg\f(CIN\f(CW\*(C'\fR form can be equivalently freestyled as \f(CW\*(C`\eg{\f(CIN\f(CW}\*(C'\fR
which avoidz ambiguitizzle when buildin a regex by concatenatin shorter
strings.  Otherwise if you had a regex \f(CW\*(C`qr/$a$b/\*(C'\fR, n' \f(CW$a\fR contained
\&\f(CW"\eg1"\fR, n' \f(CW$b\fR contained \f(CW"37"\fR, you would git \f(CW\*(C`/\eg137/\*(C'\fR which is
probably not what tha fuck you intended.
.PP
In tha \f(CW\*(C`\e\f(CIN\f(CW\*(C'\fR form, \fIN\fR must not begin wit a \*(L"0\*(R", n' there must be at
least \fIN\fR capturin groups, or else \fIN\fR is considered a octal escape
(but suttin' like \f(CW\*(C`\e18\*(C'\fR is tha same ol' dirty as \f(CW\*(C`\e0018\*(C'\fR; dat is, tha octal escape
\&\f(CW"\e001"\fR followed by a literal digit \f(CW"8"\fR).
.PP
Mnemonic: \fIg\fRroup.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 3
\& /(\ew+) \eg1/;    # Findz a thugged-out duplicated word, (e.g. "cat cat").
\& /(\ew+) \e1/;     # Same thang; freestyled old\-style.
\& /(.)(.)\eg2\eg1/;  # Match a gangbangin' four letta palindrome (e.g. "ABBA").
.Ve
.PP
\fIRelatizzle referencing\fR
.IX Subsection "Relatizzle referencing"
.PP
\&\f(CW\*(C`\eg\-\f(CIN\f(CW\*(C'\fR (startin up in Perl 5.10.0) is used fo' relatizzle addressing.  (It can
be freestyled as \f(CW\*(C`\eg{\-\f(CIN\f(CW\*(C'\fR.)  It refers ta tha \fIN\fRth crew before the
\&\f(CW\*(C`\eg{\-\f(CIN\f(CW}\*(C'\fR.
.PP
Da big-ass advantage of dis form is dat it make it much easier ta write
patterns wit references dat can be interpolated up in larger patterns,
even if tha larger pattern also gotz nuff capture groups.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 7
\& /(A)        # Group 1
\&  (          # Group 2
\&    (B)      # Group 3
\&    \eg{\-1}   # Refers ta crew 3 (B)
\&    \eg{\-3}   # Refers ta crew 1 (A)
\&  )
\& /x;         # Matches "ABBA".
\&
\& mah $qr = qr /(.)(.)\eg{\-2}\eg{\-1}/;  # Matches \*(Aqabab\*(Aq, \*(Aqcdcd\*(Aq, etc.
\& /$qr$qr/                           # Matches \*(Aqababcdcd\*(Aq.
.Ve
.PP
\fINamed referencing\fR
.IX Subsection "Named referencing"
.PP
\&\f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR (startin up in Perl 5.10.0) can be used ta back refer ta a
named capture group, dispensin straight-up wit havin ta be thinkin bout capture
buffer positions.
.PP
To be compatible wit .Net regular expressions, \f(CW\*(C`\eg{name}\*(C'\fR may also be
written as \f(CW\*(C`\ek{name}\*(C'\fR, \f(CW\*(C`\ek<name>\*(C'\fR or \f(CW\*(C`\ek\*(Aqname\*(Aq\*(C'\fR.
.PP
To prevent any ambiguity, \fIname\fR must not start wit a gangbangin' finger-lickin' digit nor contain a
hyphen.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 5
\& /(?<word>\ew+) \eg{word}/ # Findz duplicated word, (e.g. "cat cat")
\& /(?<word>\ew+) \ek{word}/ # Same.
\& /(?<word>\ew+) \ek<word>/ # Same.
\& /(?<letter1>.)(?<letter2>.)\eg{letter2}\eg{letter1}/
\&                         # Match a gangbangin' four letta palindrome (e.g. "ABBA")
.Ve
.SS "Assertions"
.IX Subsection "Assertions"
Assertions is conditions dat gotta be true; they don't actually
match partz of tha substring. There is six assertions dat is freestyled as
backslash sequences.
.IP "\eA" 4
.IX Item "A"
\&\f(CW\*(C`\eA\*(C'\fR only matches all up in tha beginnin of tha string. If tha \f(CW\*(C`/m\*(C'\fR modifier
aint used, then \f(CW\*(C`/\eA/\*(C'\fR is equivalent ta \f(CW\*(C`/^/\*(C'\fR. But fuck dat shiznit yo, tha word on tha street is dat if tha \f(CW\*(C`/m\*(C'\fR
modifier is used, then \f(CW\*(C`/^/\*(C'\fR matches internal newlines yo, but tha meaning
of \f(CW\*(C`/\eA/\*(C'\fR aint chizzled by tha \f(CW\*(C`/m\*(C'\fR modifier n' shit. \f(CW\*(C`\eA\*(C'\fR matches all up in tha beginning
of tha strang regardless whether tha \f(CW\*(C`/m\*(C'\fR modifier is used.
.IP "\ez, \eZ" 4
.IX Item "z, Z"
\&\f(CW\*(C`\ez\*(C'\fR n' \f(CW\*(C`\eZ\*(C'\fR match all up in tha end of tha string. If tha \f(CW\*(C`/m\*(C'\fR modifier aint
used, then \f(CW\*(C`/\eZ/\*(C'\fR is equivalent ta \f(CW\*(C`/$/\*(C'\fR; dat is, it matches at the
end of tha string, or one before tha newline all up in tha end of tha string. If the
\&\f(CW\*(C`/m\*(C'\fR modifier is used, then \f(CW\*(C`/$/\*(C'\fR matches at internal newlines yo, but the
meanin of \f(CW\*(C`/\eZ/\*(C'\fR aint chizzled by tha \f(CW\*(C`/m\*(C'\fR modifier n' shit. \f(CW\*(C`\eZ\*(C'\fR matches at
the end of tha strang (or just before a trailin newline) regardless whether
the \f(CW\*(C`/m\*(C'\fR modifier is used.
.Sp
\&\f(CW\*(C`\ez\*(C'\fR is just like \f(CW\*(C`\eZ\*(C'\fR, except dat it do not match before a trailing
newline. \f(CW\*(C`\ez\*(C'\fR matches all up in tha end of tha strang only, regardless of the
modifiers used, n' not just before a newline.  It be how tha fuck ta anchor the
match ta tha legit end of tha strang under all conditions.
.IP "\eG" 4
.IX Item "G"
\&\f(CW\*(C`\eG\*(C'\fR is probably used only up in combination wit tha \f(CW\*(C`/g\*(C'\fR modifier n' shit. If the
\&\f(CW\*(C`/g\*(C'\fR modifier is used n' tha match is done up in scalar context, Perl 
rethugz where up in tha source strang tha last match ended, n' tha next time,
it will start tha match from where it ended tha previous time.
.Sp
\&\f(CW\*(C`\eG\*(C'\fR matches tha point where tha previous match on dat strang ended, 
or tha beginnin of dat strang if there was no previous match.
.Sp
Mnemonic: \fIG\fRlobal.
.IP "\eb, \eB" 4
.IX Item "b, B"
\&\f(CW\*(C`\eb\*(C'\fR matches at any place between a word n' a non-word character; \f(CW\*(C`\eB\*(C'\fR
matches at any place between charactas where \f(CW\*(C`\eb\*(C'\fR don't match. \f(CW\*(C`\eb\*(C'\fR
and \f(CW\*(C`\eB\*(C'\fR assume there be a a non-word characta before tha beginnin n' after
the end of tha source string; so \f(CW\*(C`\eb\*(C'\fR will match all up in tha beginnin (or end)
of tha source strang if tha source strang begins (or ends) wit a word
character n' shit. Otherwise, \f(CW\*(C`\eB\*(C'\fR will match.
.Sp
Do not use suttin' like \f(CW\*(C`\eb=head\ed\eb\*(C'\fR n' expect it ta match the
beginnin of a line.  It can't, cuz fo' there ta be a funky-ass boundary before
the non-word \*(L"=\*(R", there must be a word characta immediately previous.  
All boundary determinations look fo' word charactas alone, not for
non-wordz charactas nor fo' strang ends.  It may help ta KNOW how
<\eb> n' <\eB> work by equatin dem as bigs up:
.Sp
.Vb 2
\&    \eb  straight-up means    (?:(?<=\ew)(?!\ew)|(?<!\ew)(?=\ew))
\&    \eB  straight-up means    (?:(?<=\ew)(?=\ew)|(?<!\ew)(?!\ew))
.Ve
.Sp
Mnemonic: \fIb\fRoundary.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 4
\&  "cat"   =~ /\eAcat/;     # Match.
\&  "cat"   =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\eZ/;     # Match.
\&  "cat\en" =~ /cat\ez/;     # No match.
\&
\&  "cat"   =~ /\ebcat\eb/;   # Matches.
\&  "cats"  =~ /\ebcat\eb/;   # No match.
\&  "cat"   =~ /\ebcat\eB/;   # No match.
\&  "cats"  =~ /\ebcat\eB/;   # Match.
\&
\&  while ("cat dog" =~ /(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcatdog\*(Aq
\&  }
\&  while ("cat dog" =~ /\eG(\ew+)/g) {
\&      print $1;           # Prints \*(Aqcat\*(Aq
\&  }
.Ve
.SS "Misc"
.IX Subsection "Misc"
Here our phat asses document tha backslash sequences dat don't fall up in one of the
categories above. These are:
.IP "\eC" 4
.IX Item "C"
\&\f(CW\*(C`\eC\*(C'\fR always matches a single octet, even if tha source strang is encoded
in \s-1UTF\-8\s0 format, n' tha characta ta be matched be a multi-octet character.
This is straight-up dangerous, cuz it violates
the logical characta abstraction n' can cause \s-1UTF\-8\s0 sequences ta become malformed.
.Sp
Mnemonic: o\fIC\fRtet.
.IP "\eK" 4
.IX Item "K"
This rocked up in perl 5.10.0 fo' realz. Anythang matched left of \f(CW\*(C`\eK\*(C'\fR is
not included up in \f(CW$&\fR, n' aint gonna be replaced if tha pattern is
used up in a substitution. I aint talkin' bout chicken n' gravy biatch. This lets you write \f(CW\*(C`s/PAT1 \eK PAT2/REPL/x\*(C'\fR
instead of \f(CW\*(C`s/(PAT1) PAT2/${1}REPL/x\*(C'\fR or \f(CW\*(C`s/(?<=PAT1) PAT2/REPL/x\*(C'\fR.
.Sp
Mnemonic: \fIK\fReep.
.IP "\eN" 4
.IX Item "N"
This feature, available startin up in v5.12,  matches any character
that is \fBnot\fR a newline.  It be a gangbangin' finger-lickin' dirty-ass short-hand fo' freestylin \f(CW\*(C`[^\en]\*(C'\fR, n' is
identical ta tha \f(CW\*(C`.\*(C'\fR metasymbol, except under tha \f(CW\*(C`/s\*(C'\fR flag, which chizzles
the meanin of \f(CW\*(C`.\*(C'\fR yo, but not \f(CW\*(C`\eN\*(C'\fR.
.Sp
Note dat \f(CW\*(C`\eN{...}\*(C'\fR can mean a
named or numbered character
\&.
.Sp
Mnemonic: Complement of \fI\en\fR.
.IP "\eR" 4
.IX Xref "\\R"
.IX Item "R"
\&\f(CW\*(C`\eR\*(C'\fR matches a \fIgeneric newline\fR; dat is, anythang considered a
linebreak sequence by Unicode. This includes all charactas matched by
\&\f(CW\*(C`\ev\*(C'\fR (vertical whitespace), n' tha multi characta sequence \f(CW"\ex0D\ex0A"\fR
(carriage return followed by a line feed, sometimes called tha network
newline; itz tha end of line sequence used up in Microsizzlez text filez opened
in binary mode). \f(CW\*(C`\eR\*(C'\fR is equivalent ta \f(CW\*(C`(?>\ex0D\ex0A|\ev)\*(C'\fR.  (The
reason it don't backtrack is dat tha sequence is considered
inseparable.  That means that
.Sp
.Vb 1
\& "\ex0D\ex0A" =~ /^\eR\ex0A$/   # No match
.Ve
.Sp
fails, cuz tha \f(CW\*(C`\eR\*(C'\fR matches tha entire string, n' won't backtrack
to match just tha \f(CW"\ex0D"\fR.)  Since
\&\f(CW\*(C`\eR\*(C'\fR can match a sequence of mo' than one character, it cannot be put
inside a funky-ass bracketed characta class; \f(CW\*(C`/[\eR]/\*(C'\fR be a error; use \f(CW\*(C`\ev\*(C'\fR
instead. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`\eR\*(C'\fR was introduced up in perl 5.10.0.
.Sp
Note dat dis do not respect any locale dat might be up in effect; it
matches accordin ta tha platformz natizzle characta set.
.Sp
Mnemonic: none straight-up. \f(CW\*(C`\eR\*(C'\fR was picked cuz \s-1PCRE\s0 already uses \f(CW\*(C`\eR\*(C'\fR,
and mo' blinginly cuz Unicode recommendz such a regular expression
metacharacter, n' suggests \f(CW\*(C`\eR\*(C'\fR as its notation.
.IP "\eX" 4
.IX Xref "\\X"
.IX Item "X"
This matches a Unicode \fIextended grapheme cluster\fR.
.Sp
\&\f(CW\*(C`\eX\*(C'\fR matches like well what tha fuck aiiight (non-Unicode-programmer) usage
would consider a single character n' shit.  As a example, consider a G wit some sort
of diacritic mark, like fuckin a arrow.  There is no such single characta in
Unicode yo, but one can be composed by rockin a G followed by a Unicode \*(L"\s-1COMBINING
UPWARDS ARROW BELOW\*(R",\s0 n' would be displayed by Unicode-aware software as if it
were a single character.
.Sp
Mnemonic: e\fIX\fRtended Unicode character.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 2
\& "\ex{256}" =~ /^\eC\eC$/;    # Match as chr (0x256) takes 
\&                           # 2 octets up in UTF\-8.
\&
\& $str =~ s/foo\eKbar/baz/g; # Chizzle any \*(Aqbar\*(Aq followin a \*(Aqfoo\*(Aq ta \*(Aqbaz\*(Aq
\& $str =~ s/(.)\eK\eg1//g;    # Delete duplicated characters.
\&
\& "\en"   =~ /^\eR$/;         # Match, \en   be a generic newline.
\& "\er"   =~ /^\eR$/;         # Match, \er   be a generic newline.
\& "\er\en" =~ /^\eR$/;         # Match, \er\en be a generic newline.
\&
\& "P\ex{307}" =~ /^\eX$/     # \eX matches a P wit a thugged-out dot above.
.Ve
