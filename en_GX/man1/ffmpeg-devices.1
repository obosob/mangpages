.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-DEVICES 1"
.TH FFMPEG-DEVICES 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-devices \- FFmpeg devices
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout tha input n' output devices provided by the
libavdevice library.
.SH "DEVICE OPTIONS"
.IX Header "DEVICE OPTIONS"
Da libavdevice library serves up tha same intercourse as
libavformat. Namely, a input thang is considered like a thugged-out demuxer, and
an output thang like a muxer, n' tha intercourse n' generic device
options is tha same provided by libavformat (see tha ffmpeg-formats
manual).
.PP
In addizzle each input or output thang may support so-called private
options, which is specific fo' dat component.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, or by settin tha value explicitly up in tha device
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.SH "INPUT DEVICES"
.IX Header "INPUT DEVICES"
Input devices is configured elements up in FFmpeg which allow ta access
the data comin from a multimedia thang attached ta yo' system.
.PP
When you configure yo' FFmpeg build, all tha supported input devices
are enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-indevs\*(R".
.PP
Yo ass can disable all tha input devices rockin tha configure option
\&\*(L"\-\-disable\-indevs\*(R", n' selectively enable a input thang rockin the
option "\-\-enable\-indev=\fI\s-1INDEV\s0\fR\*(L", or you can disable a particular
input thang rockin tha option \*(R"\-\-disable\-indev=\fI\s-1INDEV\s0\fR".
.PP
Da option \*(L"\-formats\*(R" of tha ff* tools will display tha list of
supported input devices (amongst tha demuxers).
.PP
A description of tha currently available input devices bigs up.
.SS "alsa"
.IX Subsection "alsa"
\&\s-1ALSA \s0(Advanced Linux Sound Architecture) input device.
.PP
To enable dis input thang durin configuration you need libasound
installed on yo' system.
.PP
This thang allows capturin from a \s-1ALSA\s0 device. Da name of the
device ta capture has ta be a \s-1ALSA\s0 card identifier.
.PP
An \s-1ALSA\s0 identifier has tha syntax:
.PP
.Vb 1
\&        hw:<CARD>[,<DEV>[,<SUBDEV>]]
.Ve
.PP
where tha \fI\s-1DEV\s0\fR n' \fI\s-1SUBDEV\s0\fR components is optional.
.PP
Da three arguments (in order: \fI\s-1CARD\s0\fR,\fI\s-1DEV\s0\fR,\fI\s-1SUBDEV\s0\fR)
specify card number or identifier, thang number n' subdevice number
(\-1 means any).
.PP
To peep tha list of cardz currently recognized by yo' system check the
filez \fI/proc/asound/cards\fR n' \fI/proc/asound/devices\fR.
.PP
For example ta capture wit \fBffmpeg\fR from a \s-1ALSA\s0 thang with
card id 0, you may run tha command:
.PP
.Vb 1
\&        ffmpeg \-f alsa \-i hw:0 alsaout.wav
.Ve
.PP
For mo' shiznit see:
<\fBhttp://www.alsa\-project.org/alsa\-doc/alsa\-lib/pcm.html\fR>
.SS "bktr"
.IX Subsection "bktr"
\&\s-1BSD\s0 vizzle input device.
.SS "dshow"
.IX Subsection "dshow"
Windows DirectShow input device.
.PP
DirectShow support is enabled when FFmpeg is built wit tha mingw\-w64 project.
Currently only audio n' vizzle devices is supported.
.PP
Multiple devices may be opened as separate inputs yo, but they may also be
opened on tha same input, which should improve synchronizzle between em.
.PP
Da input name should be up in tha format:
.PP
.Vb 1
\&        <TYPE>=<NAME>[:<TYPE>=<NAME>]
.Ve
.PP
where \fI\s-1TYPE\s0\fR can be either \fIaudio\fR or \fIvideo\fR,
and \fI\s-1NAME\s0\fR is tha devicez name.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
If no options is specified, tha devicez defaults is used.
If tha thang do not support tha axed options, it will
fail ta open.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle size up in tha captured vizzle.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha frame rate up in tha captured vizzle.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Set tha sample rate (in Hz) of tha captured audio.
.IP "\fBsample_size\fR" 4
.IX Item "sample_size"
Set tha sample size (in bits) of tha captured audio.
.IP "\fBchannels\fR" 4
.IX Item "channels"
Set tha number of channels up in tha captured audio.
.IP "\fBlist_devices\fR" 4
.IX Item "list_devices"
If set ta \fBtrue\fR, print a list of devices n' exit.
.IP "\fBlist_options\fR" 4
.IX Item "list_options"
If set ta \fBtrue\fR, print a list of selected devicez options
and exit.
.IP "\fBvideo_device_number\fR" 4
.IX Item "video_device_number"
Set vizzle thang number fo' devices wit same name (starts at 0,
defaults ta 0).
.IP "\fBaudio_device_number\fR" 4
.IX Item "audio_device_number"
Set audio thang number fo' devices wit same name (starts at 0,
defaults ta 0).
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Select pixel format ta be used by DirectShow. This may only be set when
the vizzle codec aint set or set ta rawvideo.
.IP "\fBaudio_buffer_size\fR" 4
.IX Item "audio_buffer_size"
Set audio thang buffer size up in millisecondz (which can directly
impact latency, dependin on tha device).
Defaults ta rockin tha audio device's
default buffer size (typically some multiple of 500ms).
Settin dis value too low can degrade performance.
See also
<\fBhttp://msdn.microsoft.com/en\-us/library/windows/desktop/dd377582(v=vs.85).aspx\fR>
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Print tha list of DirectShow supported devices n' exit:
.Sp
.Vb 1
\&        $ ffmpeg \-list_devices legit \-f dshow \-i dummy
.Ve
.IP "\(bu" 4
Open vizzle thang \fICamera\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-i vizzle="Camera"
.Ve
.IP "\(bu" 4
Open second vizzle thang wit name \fICamera\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-video_device_number 1 \-i vizzle="Camera"
.Ve
.IP "\(bu" 4
Open vizzle thang \fICamera\fR n' audio thang \fIMicrophone\fR:
.Sp
.Vb 1
\&        $ ffmpeg \-f dshow \-i vizzle="Camera":audio="Microphone"
.Ve
.IP "\(bu" 4
Print tha list of supported options up in selected thang n' exit:
.Sp
.Vb 1
\&        $ ffmpeg \-list_options legit \-f dshow \-i vizzle="Camera"
.Ve
.SS "dv1394"
.IX Subsection "dv1394"
Linux \s-1DV 1394\s0 input device.
.SS "fbdev"
.IX Subsection "fbdev"
Linux framebuffer input device.
.PP
Da Linux framebuffer be a graphic hardware-independent abstraction
layer ta show graphics on a cold-ass lil computa monitor, typically on the
console. Well shiiiit, it be accessed all up in a gangbangin' file thang node, usually
\&\fI/dev/fb0\fR.
.PP
For mo' detailed shiznit read tha file
Documentation/fb/framebuffer.txt included up in tha Linux source tree.
.PP
To record from tha framebuffer thang \fI/dev/fb0\fR with
\&\fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-f fbdev \-r 10 \-i /dev/fb0 out.avi
.Ve
.PP
Yo ass can take a single screenshot image wit tha command:
.PP
.Vb 1
\&        ffmpeg \-f fbdev \-frames:v 1 \-r 1 \-i /dev/fb0 screenshot.jpeg
.Ve
.PP
See also <\fBhttp://linux\-fbdev.sourceforge.net/\fR>, n' \fIfbset\fR\|(1).
.SS "iec61883"
.IX Subsection "iec61883"
FireWire \s-1DV/HDV\s0 input thang rockin libiec61883.
.PP
To enable dis input device, you need libiec61883, libraw1394 and
libavc1394 installed on yo' system. Use tha configure option
\&\f(CW\*(C`\-\-enable\-libiec61883\*(C'\fR ta compile wit tha thang enabled.
.PP
Da iec61883 capture thang supports capturin from a vizzle device
connected via \s-1IEEE1394 \s0(FireWire), rockin libiec61883 n' tha freshly smoked up Linux
FireWire stack (juju). This is tha default \s-1DV/HDV\s0 input method up in Linux
Kernel 2.6.37 n' later, since tha oldschool FireWire stack was removed.
.PP
Specify tha FireWire port ta be used as input file, or \*(L"auto\*(R"
to chizzle tha straight-up original gangsta port connected.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdvtype\fR" 4
.IX Item "dvtype"
Override autodetection of \s-1DV/HDV.\s0 This should only be used if auto
detection do not work, or if usage of a gangbangin' finger-lickin' different thang type
should be prohibited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Treatin a \s-1DV\s0 thang as \s-1HDV \s0(or vice versa) will
not work n' result up in undefined behavior.
Da joints \fBauto\fR, \fBdv\fR n' \fBhdv\fR is supported.
.IP "\fBdvbuffer\fR" 4
.IX Item "dvbuffer"
Set maxiumum size of buffer fo' incomin data, up in frames. For \s-1DV,\s0 this
is a exact value. For \s-1HDV,\s0 it aint frame exact, since \s-1HDV\s0 do
not gotz a gangbangin' fixed frame size.
.IP "\fBdvguid\fR" 4
.IX Item "dvguid"
Select tha capture thang by specifyin itz \s-1GUID.\s0 Capturin will only
be performed from tha specified thang n' fails if no thang wit the
given \s-1GUID\s0 is found. Y'all KNOW dat shit, muthafucka! This is useful ta select tha input if multiple
devices is connected all up in tha same time.
Look at /sys/bus/firewire/devices ta smoke up tha GUIDs.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Grab n' show tha input of a FireWire \s-1DV/HDV\s0 device.
.Sp
.Vb 1
\&        ffplay \-f iec61883 \-i auto
.Ve
.IP "\(bu" 4
Grab n' record tha input of a FireWire \s-1DV/HDV\s0 device,
usin a packet buffer of 100000 packets if tha source is \s-1HDV.\s0
.Sp
.Vb 1
\&        ffmpeg \-f iec61883 \-i auto \-hdvbuffer 100000 out.mpg
.Ve
.SS "jack"
.IX Subsection "jack"
\&\s-1JACK\s0 input device.
.PP
To enable dis input thang durin configuration you need libjack
installed on yo' system.
.PP
A \s-1JACK\s0 input thang creates one or mo' \s-1JACK\s0 writable clients, one for
each audio channel, wit name \fIclient_name\fR:input_\fIN\fR, where
\&\fIclient_name\fR is tha name provided by tha application, n' \fIN\fR
is a number which identifies tha channel.
Each writable client will bust tha acquired data ta tha FFmpeg input
device.
.PP
Once you have pimped one or mo' \s-1JACK\s0 readable clients, you need to
connect dem ta one or mo' \s-1JACK\s0 writable clients.
.PP
To connect or disconnect \s-1JACK\s0 clients you can use tha \fBjack_connect\fR
and \fBjack_disconnect\fR programs, or do it all up in a graphical intercourse,
for example wit \fBqjackctl\fR.
.PP
To list tha \s-1JACK\s0 clients n' they propertizzles you can invoke tha command
\&\fBjack_lsp\fR.
.PP
Follows a example which shows how tha fuck ta capture a \s-1JACK\s0 readable client
with \fBffmpeg\fR.
.PP
.Vb 2
\&        # Smoke a JACK writable client wit name "ffmpeg".
\&        $ ffmpeg \-f jack \-i ffmpeg \-y out.wav
\&        
\&        # Start tha sample jack_metro readable client.
\&        $ jack_metro \-b 120 \-d 0.2 \-f 4000
\&        
\&        # List tha current JACK clients.
\&        $ jack_lsp \-c
\&        system:capture_1
\&        system:capture_2
\&        system:playback_1
\&        system:playback_2
\&        ffmpeg:input_1
\&        metro:120_bpm
\&        
\&        # Connect metro ta tha ffmpeg writable client.
\&        $ jack_connect metro:120_bpm ffmpeg:input_1
.Ve
.PP
For mo' shiznit read:
<\fBhttp://jackaudio.org/\fR>
.SS "lavfi"
.IX Subsection "lavfi"
Libavfilta input virtual device.
.PP
This input thang readz data from tha open output padz of a libavfilter
filtergraph.
.PP
For each filtergraph open output, tha input thang will create a
correspondin stream which is mapped ta tha generated output. Currently
only vizzle data is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da filtergraph is specified all up in the
option \fBgraph\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBgraph\fR" 4
.IX Item "graph"
Specify tha filtergraph ta use as input. Each vizzle open output must be
labelled by a unique strang of tha form "out\fIN\fR", where \fIN\fR be a
number startin from 0 correspondin ta tha mapped input stream
generated by tha device.
Da first unlabelled output be automatically assigned ta tha \*(L"out0\*(R"
label yo, but all tha others need ta be specified explicitly.
.Sp
If not specified defaults ta tha filename specified fo' tha input
device.
.IP "\fBgraph_file\fR" 4
.IX Item "graph_file"
Set tha filename of tha filtergraph ta be read n' busted ta tha other
filters. Right back up in yo muthafuckin ass. Syntax of tha filtergraph is tha same ol' dirty as tha one specified by
the option \fIgraph\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Smoke a cold-ass lil color vizzle stream n' play it back wit \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-graph "color=c=pink [out0]" dummy
.Ve
.IP "\(bu" 4
As tha previous example yo, but use filename fo' specifyin tha graph
description, n' omit tha \*(L"out0\*(R" label:
.Sp
.Vb 1
\&        ffplay \-f lavfi color=c=pink
.Ve
.IP "\(bu" 4
Smoke three different vizzle test filtered sources n' play them:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-graph "testsrc [out0]; testsrc,hflip [out1]; testsrc,negate [out2]" test3
.Ve
.IP "\(bu" 4
Read a audio stream from a gangbangin' file rockin tha amovie source n' play it
back wit \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi "amovie=test.wav"
.Ve
.IP "\(bu" 4
Read a audio stream n' a vizzle stream n' play it back with
\&\fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi "movie=test.avi[out0];amovie=test.wav[out1]"
.Ve
.SS "libdc1394"
.IX Subsection "libdc1394"
\&\s-1IIDC1394\s0 input device, based on libdc1394 n' libraw1394.
.SS "openal"
.IX Subsection "openal"
Da OpenAL input thang serves up audio capture on all systems wit a
workin OpenAL 1.1 implementation.
.PP
To enable dis input thang durin configuration, you need OpenAL
headaz n' libraries installed on yo' system, n' need ta configure
FFmpeg wit \f(CW\*(C`\-\-enable\-openal\*(C'\fR.
.PP
OpenAL headaz n' libraries should be provided as part of yo' OpenAL
implementation, or as a additionizzle downlizzle (an \s-1SDK\s0). Dependin on your
installation you may need ta specify additionizzle flags via the
\&\f(CW\*(C`\-\-extra\-cflags\*(C'\fR n' \f(CW\*(C`\-\-extra\-ldflags\*(C'\fR fo' allowin tha build
system ta locate tha OpenAL headaz n' libraries.
.PP
An incomplete list of OpenAL implementations bigs up:
.IP "\fBCreative\fR" 4
.IX Item "Creative"
Da straight-up legit Windows implementation, providin hardware acceleration
with supported devices n' software fallback.
See <\fBhttp://openal.org/\fR>.
.IP "\fBOpenAL Soft\fR" 4
.IX Item "OpenAL Soft"
Portable, open source (\s-1LGPL\s0) software implementation. I aint talkin' bout chicken n' gravy biatch. Includes
backendz fo' da most thugged-out common sound APIs on tha Windows, Linux,
Solaris, n' \s-1BSD\s0 operatin systems.
See <\fBhttp://kcat.strangesoft.net/openal.html\fR>.
.IP "\fBApple\fR" 4
.IX Item "Apple"
OpenAL is part of Core Audio, tha straight-up legit Mac \s-1OS X\s0 Audio intercourse.
See <\fBhttp://developer.apple.com/technologies/mac/audio\-and\-video.html\fR>
.PP
This thang allows ta capture from a audio input thang handled
all up in OpenAL.
.PP
Yo ass need ta specify tha name of tha thang ta capture up in tha provided
filename. If tha empty strang is provided, tha thang will
automatically select tha default device. Yo ass can git tha list of the
supported devices by rockin tha option \fIlist_devices\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBchannels\fR" 4
.IX Item "channels"
Set tha number of channels up in tha captured audio. Only tha joints
\&\fB1\fR (monaural) n' \fB2\fR (stereo) is currently supported.
Defaults ta \fB2\fR.
.IP "\fBsample_size\fR" 4
.IX Item "sample_size"
Set tha sample size (in bits) of tha captured audio. Only tha joints
\&\fB8\fR n' \fB16\fR is currently supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Defaults to
\&\fB16\fR.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Set tha sample rate (in Hz) of tha captured audio.
Defaults ta \fB44.1k\fR.
.IP "\fBlist_devices\fR" 4
.IX Item "list_devices"
If set ta \fBtrue\fR, print a list of devices n' exit.
Defaults ta \fBfalse\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Print tha list of OpenAL supported devices n' exit:
.PP
.Vb 1
\&        $ ffmpeg \-list_devices legit \-f openal \-i dummy out.ogg
.Ve
.PP
Capture from tha OpenAL thang \fI\s-1DR\-BT101\s0 via PulseAudio\fR:
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(AqDR\-BT101 via PulseAudio\*(Aq out.ogg
.Ve
.PP
Capture from tha default thang (note tha empty strang '' as filename):
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(Aq\*(Aq out.ogg
.Ve
.PP
Capture from two devices simultaneously, freestylin ta two different files,
within tha same \fBffmpeg\fR command:
.PP
.Vb 1
\&        $ ffmpeg \-f openal \-i \*(AqDR\-BT101 via PulseAudio\*(Aq out1.ogg \-f openal \-i \*(AqALSA Default\*(Aq out2.ogg
.Ve
.PP
Note: not all OpenAL implementations support multiple simultaneous capture \-
try tha sickest fuckin OpenAL Soft if tha above do not work.
.SS "oss"
.IX Subsection "oss"
Open Sound System input device.
.PP
Da filename ta provide ta tha input thang is tha thang node
representin tha \s-1OSS\s0 input device, n' is probably set to
\&\fI/dev/dsp\fR.
.PP
For example ta grab from \fI/dev/dsp\fR rockin \fBffmpeg\fR use the
command:
.PP
.Vb 1
\&        ffmpeg \-f oss \-i /dev/dsp /tmp/oss.wav
.Ve
.PP
For mo' shiznit bout \s-1OSS\s0 see:
<\fBhttp://manuals.opensound.com/usersguide/dsp.html\fR>
.SS "pulse"
.IX Subsection "pulse"
PulseAudio input device.
.PP
To enable dis output thang you need ta configure FFmpeg wit \f(CW\*(C`\-\-enable\-libpulse\*(C'\fR.
.PP
Da filename ta provide ta tha input thang be a source thang or the
strin \*(L"default\*(R"
.PP
To list tha PulseAudio source devices n' they propertizzles you can invoke
the command \fBpactl list sources\fR.
.PP
Mo' shiznit bout PulseAudio can be found on <\fBhttp://www.pulseaudio.org\fR>.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBserver\fR" 4
.IX Item "server"
Connect ta a specific PulseAudio server, specified by a \s-1IP\s0 address.
Default server is used when not provided.
.IP "\fBname\fR" 4
.IX Item "name"
Specify tha application name PulseAudio will use when showin actizzle clients,
by default it is tha \f(CW\*(C`LIBAVFORMAT_IDENT\*(C'\fR string.
.IP "\fBstream_name\fR" 4
.IX Item "stream_name"
Specify tha stream name PulseAudio will use when showin actizzle streams,
by default it is \*(L"record\*(R".
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Specify tha samplerate up in Hz, by default 48kHz is used.
.IP "\fBchannels\fR" 4
.IX Item "channels"
Specify tha channels up in use, by default 2 (stereo) is set.
.IP "\fBframe_size\fR" 4
.IX Item "frame_size"
Specify tha number of bytes per frame, by default it is set ta 1024.
.IP "\fBfragment_size\fR" 4
.IX Item "fragment_size"
Specify tha minimal bufferin fragment up in PulseAudio, it will affect the
audio latency. By default it is unset.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Record a stream from default device:
.PP
.Vb 1
\&        ffmpeg \-f pulse \-i default /tmp/pulse.wav
.Ve
.SS "sndio"
.IX Subsection "sndio"
sndio input device.
.PP
To enable dis input thang durin configuration you need libsndio
installed on yo' system.
.PP
Da filename ta provide ta tha input thang is tha thang node
representin tha sndio input device, n' is probably set to
\&\fI/dev/audio0\fR.
.PP
For example ta grab from \fI/dev/audio0\fR rockin \fBffmpeg\fR use the
command:
.PP
.Vb 1
\&        ffmpeg \-f sndio \-i /dev/audio0 /tmp/oss.wav
.Ve
.SS "video4linux2, v4l2"
.IX Subsection "video4linux2, v4l2"
Video4Linux2 input vizzle device.
.PP
\&\*(L"v4l2\*(R" can be used as alias fo' \*(L"video4linux2\*(R".
.PP
If FFmpeg is built wit v4l\-utils support (by rockin the
\&\f(CW\*(C`\-\-enable\-libv4l2\*(C'\fR configure option), it is possible ta use it wit the
\&\f(CW\*(C`\-use_libv4l2\*(C'\fR input thang option.
.PP
Da name of tha thang ta grab be a gangbangin' file thang node, probably Linux
systems tend ta automatically create such nodes when tha device
(e.g. a \s-1STD\s0 webcam) is plugged tha fuck into tha system, n' has a name of the
kind \fI/dev/video\fIN\fI\fR, where \fIN\fR be a number associated to
the device.
.PP
Video4Linux2 devices probably support a limited set of
\&\fIwidth\fRx\fIheight\fR sizes n' frame rates. Yo ass can check which are
supported rockin \fB\-list_formats all\fR fo' Video4Linux2 devices.
Some devices, like \s-1TV\s0 cards, support one or mo' standards. Well shiiiit, it is possible
to list all tha supported standardz rockin \fB\-list_standardz all\fR.
.PP
Da time base fo' tha timestamps is 1 microsecond. Y'all KNOW dat shit, muthafucka! Dependin on tha kernel
version n' configuration, tha timestamps may be derived from tha real time
clock (origin all up in tha Unix Epoch) or tha monotonic clock (origin probably at
boot time, unaffected by \s-1NTP\s0 or manual chizzlez ta tha clock). The
\&\fB\-timestamps abs\fR or \fB\-ts abs\fR option can be used ta force
conversion tha fuck into tha real time clock.
.PP
Some usage examplez of tha vizzle4linux2 thang wit \fBffmpeg\fR
and \fBffplay\fR:
.IP "\(bu" 4
Grab n' show tha input of a vizzle4linux2 device:
.Sp
.Vb 1
\&        ffplay \-f vizzle4linux2 \-framerate 30 \-video_size hd720 /dev/video0
.Ve
.IP "\(bu" 4
Grab n' record tha input of a vizzle4linux2 device, leave the
frame rate n' size as previously set:
.Sp
.Vb 1
\&        ffmpeg \-f vizzle4linux2 \-input_format mjpeg \-i /dev/video0 out.mpeg
.Ve
.PP
For mo' shiznit bout Video4Linux, check <\fBhttp://linuxtv.org/\fR>.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBstandard\fR" 4
.IX Item "standard"
Set tha standard. Y'all KNOW dat shit, muthafucka! Must be tha name of a supported standard. Y'all KNOW dat shit, muthafucka! To git a
list of tha supported standards, use tha \fBlist_standards\fR
option.
.IP "\fBchannel\fR" 4
.IX Item "channel"
Set tha input channel number n' shit. Default ta \-1, which means rockin the
previously selected channel.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle frame size. Da argument must be a strang up in tha form
\&\fI\s-1WIDTH\s0\fRx\fI\s-1HEIGHT\s0\fR or a valid size abbreviation.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Select tha pixel format (only valid fo' raw vizzle input).
.IP "\fBinput_format\fR" 4
.IX Item "input_format"
Set tha preferred pixel format (for raw vizzle) or a cold-ass lil codec name.
This option allows ta select tha input format, when nuff muthafuckin are
available.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha preferred vizzle frame rate.
.IP "\fBlist_formats\fR" 4
.IX Item "list_formats"
List available formats (supported pixel formats, codecs, n' frame
sizes) n' exit.
.Sp
Available joints are:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Show all available (compressed n' non-compressed) formats.
.IP "\fBraw\fR" 4
.IX Item "raw"
Show only raw vizzle (non-compressed) formats.
.IP "\fBcompressed\fR" 4
.IX Item "compressed"
Show only compressed formats.
.RE
.RS 4
.RE
.IP "\fBlist_standards\fR" 4
.IX Item "list_standards"
List supported standardz n' exit.
.Sp
Available joints are:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Show all supported standards.
.RE
.RS 4
.RE
.IP "\fBtimestamps, ts\fR" 4
.IX Item "timestamps, ts"
Set type of timestamps fo' grabbed frames.
.Sp
Available joints are:
.RS 4
.IP "\fBdefault\fR" 4
.IX Item "default"
Use timestamps from tha kernel.
.IP "\fBabs\fR" 4
.IX Item "abs"
Use absolute timestamps (wall clock).
.IP "\fBmono2abs\fR" 4
.IX Item "mono2abs"
Force conversion from monotonic ta absolute timestamps.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`default\*(C'\fR.
.RE
.SS "vfwcap"
.IX Subsection "vfwcap"
VfW (Video fo' Windows) capture input device.
.PP
Da filename passed as input is tha capture driver number, rangin from
0 ta 9. Yo ass may use \*(L"list\*(R" as filename ta print a list of drivers fo' realz. Any
other filename is ghon be interpreted as thang number 0.
.SS "x11grab"
.IX Subsection "x11grab"
X11 vizzle input device.
.PP
This thang allows ta capture a region of a X11 display.
.PP
Da filename passed as input has tha syntax:
.PP
.Vb 1
\&        [<hostname>]:<display_number>.<screen_number>[+<x_offset>,<y_offset>]
.Ve
.PP
\&\fIhostname\fR:\fIdisplay_number\fR.\fIscreen_number\fR specifies the
X11 display name of tha screen ta grab from. \fIhostname\fR can be
omitted, n' defaults ta \*(L"localhost\*(R". Da environment variable
\&\fB\s-1DISPLAY\s0\fR gotz nuff tha default display name.
.PP
\&\fIx_offset\fR n' \fIy_offset\fR specify tha offsetz of tha grabbed
area wit respect ta tha top-left border of tha X11 screen. I aint talkin' bout chicken n' gravy biatch. They
default ta 0.
.PP
Peep tha X11 documentation (e.g. playa X) fo' mo' detailed shiznit.
.PP
Use tha \fBdpyinfo\fR program fo' gettin basic shiznit bout the
propertizzlez of yo' X11 display (e.g. grep fo' \*(L"name\*(R" or \*(L"dimensions\*(R").
.PP
For example ta grab from \fI:0.0\fR rockin \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.PP
Grab at posizzle \f(CW\*(C`10,20\*(C'\fR:
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-framerate 25 \-video_size cif \-i :0.0+10,20 out.mpg
.Ve
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdraw_mouse\fR" 4
.IX Item "draw_mouse"
Specify whether ta draw tha mouse pointer n' shiznit fo' realz. A value of \f(CW0\fR specify
not ta draw tha pointer n' shit. Default value is \f(CW1\fR.
.IP "\fBfollow_mouse\fR" 4
.IX Item "follow_mouse"
Make tha grabbed area follow tha mouse. Da argument can be
\&\f(CW\*(C`centered\*(C'\fR or a fuckin shitload of pixels \fI\s-1PIXELS\s0\fR.
.Sp
When it is specified wit \*(L"centered\*(R", tha grabbin region bigs up tha mouse
pointa n' keeps tha pointa all up in tha centa of region; otherwise, tha region
bigs up only when tha mouse pointa reaches within \fI\s-1PIXELS\s0\fR (greata than
zero) ta tha edge of region.
.Sp
For example:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse centered \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.Sp
To follow only when tha mouse pointa reaches within 100 pixels ta edge:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse 100 \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha grabbin frame rate. Default value is \f(CW\*(C`ntsc\*(C'\fR,
correspondin ta a gangbangin' frame rate of \f(CW\*(C`30000/1001\*(C'\fR.
.IP "\fBshow_region\fR" 4
.IX Item "show_region"
Show grabbed region on screen.
.Sp
If \fIshow_region\fR is specified wit \f(CW1\fR, then tha grabbing
region is ghon be indicated on screen. I aint talkin' bout chicken n' gravy biatch. With dis option, it is easy as fuck  to
know what tha fuck is bein grabbed if only a portion of tha screen is grabbed.
.Sp
For example:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-show_region 1 \-framerate 25 \-video_size cif \-i :0.0+10,20 out.mpg
.Ve
.Sp
With \fIfollow_mouse\fR:
.Sp
.Vb 1
\&        ffmpeg \-f x11grab \-follow_mouse centered \-show_region 1 \-framerate 25 \-video_size cif \-i :0.0 out.mpg
.Ve
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle frame size. Default value is \f(CW\*(C`vga\*(C'\fR.
.SH "OUTPUT DEVICES"
.IX Header "OUTPUT DEVICES"
Output devices is configured elements up in FFmpeg dat can write
multimedia data ta a output thang attached ta yo' system.
.PP
When you configure yo' FFmpeg build, all tha supported output devices
are enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-outdevs\*(R".
.PP
Yo ass can disable all tha output devices rockin tha configure option
\&\*(L"\-\-disable\-outdevs\*(R", n' selectively enable a output thang rockin the
option "\-\-enable\-outdev=\fI\s-1OUTDEV\s0\fR\*(L", or you can disable a particular
input thang rockin tha option \*(R"\-\-disable\-outdev=\fI\s-1OUTDEV\s0\fR".
.PP
Da option \*(L"\-formats\*(R" of tha ff* tools will display tha list of
enabled output devices (amongst tha muxers).
.PP
A description of tha currently available output devices bigs up.
.SS "alsa"
.IX Subsection "alsa"
\&\s-1ALSA \s0(Advanced Linux Sound Architecture) output device.
.SS "caca"
.IX Subsection "caca"
\&\s-1CACA\s0 output device.
.PP
This output thang allows ta show a vizzle stream up in \s-1CACA\s0 window.
Only one \s-1CACA\s0 window be allowed per application, so you can
have only one instizzle of dis output thang up in a application.
.PP
To enable dis output thang you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libcaca\*(C'\fR.
libcaca be a graphics library dat outputs text instead of pixels.
.PP
For mo' shiznit bout libcaca, check:
<\fBhttp://caca.zoy.org/wiki/libcaca\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha \s-1CACA\s0 window title, if not specified default ta tha filename
specified fo' tha output device.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha \s-1CACA\s0 window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation.
If not specified it defaults ta tha size of tha input vizzle.
.IP "\fBdriver\fR" 4
.IX Item "driver"
Set display driver.
.IP "\fBalgorithm\fR" 4
.IX Item "algorithm"
Set ditherin algorithm. Ditherin is necessary
because tha picture bein rendered has probably far mo' colours than
the available palette.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither algorithms\*(C'\fR.
.IP "\fBantialias\fR" 4
.IX Item "antialias"
Set antialias method. Y'all KNOW dat shit, muthafucka! Antialiasin smoothens tha rendered
image n' avoidz tha commonly peeped staircase effect.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither antialiases\*(C'\fR.
.IP "\fBcharset\fR" 4
.IX Item "charset"
Set which charactas is goin ta be used when renderin text.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither charsets\*(C'\fR.
.IP "\fBcolor\fR" 4
.IX Item "color"
Set color ta be used when renderin text.
Da accepted joints is listed wit \f(CW\*(C`\-list_dither colors\*(C'\fR.
.IP "\fBlist_drivers\fR" 4
.IX Item "list_drivers"
If set ta \fBtrue\fR, print a list of available drivers n' exit.
.IP "\fBlist_dither\fR" 4
.IX Item "list_dither"
List available dither options related ta tha argument.
Da argument must be one of \f(CW\*(C`algorithms\*(C'\fR, \f(CW\*(C`antialiases\*(C'\fR,
\&\f(CW\*(C`charsets\*(C'\fR, \f(CW\*(C`colors\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Da followin command shows tha \fBffmpeg\fR output be an
\&\s-1CACA\s0 window, forcin its size ta 80x25:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vcodec rawvideo \-pix_fmt rgb24 \-window_size 80x25 \-f caca \-
.Ve
.IP "\(bu" 4
Show tha list of available drivers n' exit:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-pix_fmt rgb24 \-f caca \-list_drivers legit \-
.Ve
.IP "\(bu" 4
Show tha list of available dither flavas n' exit:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-pix_fmt rgb24 \-f caca \-list_dither flavas \-
.Ve
.SS "fbdev"
.IX Subsection "fbdev"
Linux framebuffer output device.
.PP
Da Linux framebuffer be a graphic hardware-independent abstraction
layer ta show graphics on a cold-ass lil computa monitor, typically on the
console. Well shiiiit, it be accessed all up in a gangbangin' file thang node, usually
\&\fI/dev/fb0\fR.
.PP
For mo' detailed shiznit read tha file
\&\fIDocumentation/fb/framebuffer.txt\fR included up in tha Linux source tree.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBxoffset\fR" 4
.IX Item "xoffset"
.PD 0
.IP "\fByoffset\fR" 4
.IX Item "yoffset"
.PD
Set x/y coordinizzle of top left corner n' shit. Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Play a gangbangin' file on framebuffer thang \fI/dev/fb0\fR.
Required pixel format dependz on current framebuffer settings.
.PP
.Vb 1
\&        ffmpeg \-re \-i INPUT \-vcodec rawvideo \-pix_fmt bgra \-f fbdev /dev/fb0
.Ve
.PP
See also <\fBhttp://linux\-fbdev.sourceforge.net/\fR>, n' \fIfbset\fR\|(1).
.SS "oss"
.IX Subsection "oss"
\&\s-1OSS \s0(Open Sound System) output device.
.SS "pulse"
.IX Subsection "pulse"
PulseAudio output device.
.PP
To enable dis output thang you need ta configure FFmpeg wit \f(CW\*(C`\-\-enable\-libpulse\*(C'\fR.
.PP
Mo' shiznit bout PulseAudio can be found on <\fBhttp://www.pulseaudio.org\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBserver\fR" 4
.IX Item "server"
Connect ta a specific PulseAudio server, specified by a \s-1IP\s0 address.
Default server is used when not provided.
.IP "\fBname\fR" 4
.IX Item "name"
Specify tha application name PulseAudio will use when showin actizzle clients,
by default it is tha \f(CW\*(C`LIBAVFORMAT_IDENT\*(C'\fR string.
.IP "\fBstream_name\fR" 4
.IX Item "stream_name"
Specify tha stream name PulseAudio will use when showin actizzle streams,
by default it is set ta tha specified output name.
.IP "\fBdevice\fR" 4
.IX Item "device"
Specify tha thang ta use. Default thang is used when not provided.
List of output devices can be obtained wit command \fBpactl list sinks\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Play a gangbangin' file on default thang on default server:
.PP
.Vb 1
\&        ffmpeg  \-i INPUT \-f pulse "stream name"
.Ve
.SS "sdl"
.IX Subsection "sdl"
\&\s-1SDL \s0(Simple DirectMedia Layer) output device.
.PP
This output thang allows ta show a vizzle stream up in a \s-1SDL\s0
window. Only one \s-1SDL\s0 window be allowed per application, so you can
have only one instizzle of dis output thang up in a application.
.PP
To enable dis output thang you need libsdl installed on yo' system
when configurin yo' build.
.PP
For mo' shiznit bout \s-1SDL,\s0 check:
<\fBhttp://www.libsdl.org/\fR>
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha \s-1SDL\s0 window title, if not specified default ta tha filename
specified fo' tha output device.
.IP "\fBicon_title\fR" 4
.IX Item "icon_title"
Set tha name of tha iconified \s-1SDL\s0 window, if not specified it is set
to tha same value of \fIwindow_title\fR.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha \s-1SDL\s0 window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation.
If not specified it defaults ta tha size of tha input vizzle,
downscaled accordin ta tha aspect ratio.
.IP "\fBwindow_fullscreen\fR" 4
.IX Item "window_fullscreen"
Set fullscreen mode when non-zero value is provided.
Zero be a thugged-out default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Da followin command shows tha \fBffmpeg\fR output be an
\&\s-1SDL\s0 window, forcin its size ta tha qcif format:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-vcodec rawvideo \-pix_fmt yuv420p \-window_size qcif \-f sdl "SDL output"
.Ve
.SS "sndio"
.IX Subsection "sndio"
sndio audio output device.
.SS "xv"
.IX Subsection "xv"
\&\s-1XV \s0(XVideo) output device.
.PP
This output thang allows ta show a vizzle stream up in a X Window System
window.
.PP
\fIOptions\fR
.IX Subsection "Options"
.IP "\fBdisplay_name\fR" 4
.IX Item "display_name"
Specify tha hardware display name, which determines tha display and
communications domain ta be used.
.Sp
Da display name or \s-1DISPLAY\s0 environment variable can be a strang in
the format \fIhostname\fR[:\fInumber\fR[.\fIscreen_number\fR]].
.Sp
\&\fIhostname\fR specifies tha name of tha host machine on which the
display is physically attached. Y'all KNOW dat shit, muthafucka! \fInumber\fR specifies tha number of
the display server on dat host machine. \fIscreen_number\fR specifies
the screen ta be used on dat server.
.Sp
If unspecified, it defaults ta tha value of tha \s-1DISPLAY\s0 environment
variable.
.Sp
For example, \f(CW\*(C`dual\-headed:0.1\*(C'\fR would specify screen 1 of display
0 on tha machine named ``dual\-headed''.
.Sp
Peep tha X11 justification fo' mo' detailed shiznit bout the
display name format.
.IP "\fBwindow_size\fR" 4
.IX Item "window_size"
Set tha pimped window size, can be a strang of tha form
\&\fIwidth\fRx\fIheight\fR or a vizzle size abbreviation. I aint talkin' bout chicken n' gravy biatch. If not
specified it defaults ta tha size of tha input vizzle.
.IP "\fBwindow_x\fR" 4
.IX Item "window_x"
.PD 0
.IP "\fBwindow_y\fR" 4
.IX Item "window_y"
.PD
Set tha X n' Y window offsets fo' tha pimped window. They is both
set ta 0 by default. Da joints may be ignored by tha window manager.
.IP "\fBwindow_title\fR" 4
.IX Item "window_title"
Set tha window title, if not specified default ta tha filename
specified fo' tha output device.
.PP
For mo' shiznit bout XVideo peep <\fBhttp://www.x.org/\fR>.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Decode, display n' encode vizzle input wit \fBffmpeg\fR at the
same time:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT OUTPUT \-f xv display
.Ve
.IP "\(bu" 4
Decode n' display tha input vizzle ta multiple X11 windows:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-f xv aiiight \-vf negate \-f xv negated
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavdevice\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
