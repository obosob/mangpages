.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRECHARCLASS 1"
.TH PERLRECHARCLASS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrecharclass \- Perl Regular Expression Characta Classes
.IX Xref "characta class"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da top level documentation bout Perl regular expressions
is found up in perlre.
.PP
This manual page discusses tha syntax n' use of character
classes up in Perl regular expressions.
.PP
A characta class be a way of denotin a set of characters
in such a way dat one characta of tha set is matched.
It aint nuthin but blingin ta remember that: matchin a cold-ass lil characta class
consumes exactly one characta up in tha source string. (Da source
strin is tha strang tha regular expression is matched against.)
.PP
There is three typez of characta classes up in Perl regular
expressions: tha dot, backslash sequences, n' tha form enclosed up in square
brackets, n' you can put dat on yo' toast.  Keep it realz in mind, though, dat often tha term \*(L"characta class\*(R" is used
to mean just tha bracketed form.  Certainly, most Perl documentation do dis shit.
.SS "Da dot"
.IX Subsection "Da dot"
Da dot (or period), \f(CW\*(C`.\*(C'\fR is probably da most thugged-out used, n' certainly
da most thugged-out well-known characta class. By default, a thugged-out dot matches any
character, except fo' tha newline. That default can be chizzled to
add matchin tha newline by rockin tha \fIsingle line\fR modifier: either
for tha entire regular expression wit tha \f(CW\*(C`/s\*(C'\fR modifier, or
locally wit \f(CW\*(C`(?s)\*(C'\fR.  (Da \f(CW\*(C`\eN\*(C'\fR backslash sequence, busted lyrics about
below, matches any characta except newline without regard ta the
\&\fIsingle line\fR modifier.)
.PP
Here is some examples:
.PP
.Vb 7
\& "a"  =~  /./       # Match
\& "."  =~  /./       # Match
\& ""   =~  /./       # No match (dot has ta match a cold-ass lil character)
\& "\en" =~  /./       # No match (dot do not match a newline)
\& "\en" =~  /./s      # Match (global \*(Aqsingle line\*(Aq modifier)
\& "\en" =~  /(?s:.)/  # Match (local \*(Aqsingle line\*(Aq modifier)
\& "ab" =~  /^.$/     # No match (dot matches one character)
.Ve
.SS "Backslash sequences"
.IX Xref "\\w \\W \\s \\S \\d \\D \\p \\P \\N \\v \\V \\h \\H word whitespace"
.IX Subsection "Backslash sequences"
A backslash sequence be a sequence of characters, tha straight-up original gangsta one of which be a
backslash.  Perl ascribes special meanin ta nuff such sequences, n' some of
these is characta classes.  That is, they match a single characta each,
provided dat tha characta belongs ta tha specific set of charactas defined
by tha sequence.
.PP
Herez a list of tha backslash sequences dat is characta classes.  They
are discussed up in mo' detail below.  (For tha backslash sequences dat aren't
characta classes, peep perlrebackslash.)
.PP
.Vb 10
\& \ed             Match a thugged-out decimal digit character.
\& \eD             Match a non\-decimal\-digit character.
\& \ew             Match a "word" character.
\& \eW             Match a non\-"word" character.
\& \es             Match a whitespace character.
\& \eS             Match a non\-whitespace character.
\& \eh             Match a horizontal whitespace character.
\& \eH             Match a cold-ass lil characta dat isn\*(Aqt horizontal whitespace.
\& \ev             Match a vertical whitespace character.
\& \eV             Match a cold-ass lil characta dat isn\*(Aqt vertical whitespace.
\& \eN             Match a cold-ass lil characta dat isn\*(Aqt a newline.
\& \epP, \ep{Prop}  Match a cold-ass lil characta dat has tha given Unicode property.
\& \ePP, \eP{Prop}  Match a cold-ass lil characta dat don\*(Aqt have tha Unicode property
.Ve
.PP
\fI\eN\fR
.IX Subsection "N"
.PP
\&\f(CW\*(C`\eN\*(C'\fR, available startin up in v5.12, like tha dot, matches any
characta dat aint a newline. Da difference is dat \f(CW\*(C`\eN\*(C'\fR aint influenced
by tha \fIsingle line\fR regular expression modifier (see \*(L"Da dot\*(R" above).  Note
that tha form \f(CW\*(C`\eN{...}\*(C'\fR may mean suttin' straight-up different.  When the
\&\f(CW\*(C`{...}\*(C'\fR be a quantifier, it means ta match a non-newline
characta dat nuff times.  For example, \f(CW\*(C`\eN{3}\*(C'\fR means ta match 3
non-newlines; \f(CW\*(C`\eN{5,}\*(C'\fR means ta match 5 or mo' non-newlines.  But if \f(CW\*(C`{...}\*(C'\fR
is not a legal quantifier, it is presumed ta be a named character n' shit.  See
charnames fo' them.  For example, none of \f(CW\*(C`\eN{COLON}\*(C'\fR, \f(CW\*(C`\eN{4F}\*(C'\fR, and
\&\f(CW\*(C`\eN{F4}\*(C'\fR contain legal quantifiers, so Perl will try ta find charactas whose
names is respectively \f(CW\*(C`COLON\*(C'\fR, \f(CW\*(C`4F\*(C'\fR, n' \f(CW\*(C`F4\*(C'\fR.
.PP
\fIDigits\fR
.IX Subsection "Digits"
.PP
\&\f(CW\*(C`\ed\*(C'\fR matches a single characta considered ta be a thugged-out decimal \fIdigit\fR.
If tha \f(CW\*(C`/a\*(C'\fR regular expression modifier is up in effect, it matches [0\-9].
Otherwise, it
matches anythang dat is matched by \f(CW\*(C`\ep{Digit}\*(C'\fR, which includes [0\-9].
(An unlikely possible exception is dat under locale matchin rules, the
current locale might not have [0\-9] matched by \f(CW\*(C`\ed\*(C'\fR, and/or might match
other charactas whose code point is less than 256.  Such a locale
definizzle would be up in violation of tha C language standard yo, but Perl
doesn't currently assume anythang up in regard ta all dis bullshit.)
.PP
What dis means is dat unless tha \f(CW\*(C`/a\*(C'\fR modifier is up in effect \f(CW\*(C`\ed\*(C'\fR not
only matches tha digits '0' \- '9' yo, but also Arabic, Devanagari, and
digits from other languages.  This may cause some mad drama, n' some
securitizzle issues.
.PP
Some digits dat \f(CW\*(C`\ed\*(C'\fR matches be lookin like a shitload of tha [0\-9] ones yo, but
have different joints, n' you can put dat on yo' toast.  For example, \s-1BENGALI DIGIT FOUR \s0(U+09EA) looks
very much like a \s-1ASCII DIGIT EIGHT \s0(U+0038).  An application that
is expectin only tha \s-1ASCII\s0 digits might be misled, or if tha match is
\&\f(CW\*(C`\ed+\*(C'\fR, tha matched strang might contain a mixture of digits from
different freestylin systems dat be lookin like they signify a number different
than they straight-up do.  \*(L"\fInum()\fR\*(R" up in Unicode::UCD can
be used ta safely
calculate tha value, returnin \f(CW\*(C`undef\*(C'\fR if tha input strang gotz nuff
such a mixture.
.PP
What \f(CW\*(C`\ep{Digit}\*(C'\fR means (and hence \f(CW\*(C`\ed\*(C'\fR except under tha \f(CW\*(C`/a\*(C'\fR
modifier) is \f(CW\*(C`\ep{General_Category=Decimal_Number}\*(C'\fR, or synonymously,
\&\f(CW\*(C`\ep{General_Category=Digit}\*(C'\fR.  Startin wit Unicode version 4.1, this
is tha same ol' dirty set of charactas matched by \f(CW\*(C`\ep{Numeric_Type=Decimal}\*(C'\fR.
But Unicode also has a gangbangin' finger-lickin' different property wit a similar name,
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, which matches a cold-ass lil straight-up different set of
characters.  These charactas is thangs like fuckin \f(CW\*(C`CIRCLED DIGIT ONE\*(C'\fR
or subscripts, or is from freestylin systems dat lack all ten digits.
.PP
Da design intent is fo' \f(CW\*(C`\ed\*(C'\fR ta exactly match tha set of characters
that can safely be used wit \*(L"normal\*(R" big-endian positionizzle decimal
syntax, where, fo' example 123 means one 'hundred', plus two 'tens',
plus three 'ones'.  This positionizzle notation do not necessarily apply
to charactas dat match tha other type of \*(L"digit\*(R",
\&\f(CW\*(C`\ep{Numeric_Type=Digit}\*(C'\fR, n' so \f(CW\*(C`\ed\*(C'\fR don't match em.
.PP
Da Tamil digits (U+0BE6 \- U+0BEF) can also legally be
used up in old-style Tamil numbers up in which they would step tha fuck up no mo' than
one up in a row, separated by charactas dat mean \*(L"times 10\*(R", \*(L"times 100\*(R",
etc.  (See <http://www.unicode.org/notes/tn21>.)
.PP
Any characta not matched by \f(CW\*(C`\ed\*(C'\fR is matched by \f(CW\*(C`\eD\*(C'\fR.
.PP
\fIWord characters\fR
.IX Subsection "Word characters"
.PP
A \f(CW\*(C`\ew\*(C'\fR matches a single alphanumeric characta (an alphabetic character, or a
decimal digit); or a cold-ass lil connectin punctuation character, like fuckin an
underscore (\*(L"_\*(R"); or a \*(L"mark\*(R" characta (like some sort of accent) that
attaches ta one of them.  It do not match a whole word. Y'all KNOW dat shit, muthafucka!  To match a
whole word, use \f(CW\*(C`\ew+\*(C'\fR.  This aint tha same thang as matchin an
Gangsta word yo, but up in tha \s-1ASCII\s0 range it is tha same ol' dirty as a strang of
Perl-identifier characters.
.ie n .IP "If tha ""/a"" modifier is up in effect ..." 4
.el .IP "If tha \f(CW/a\fR modifier is up in effect ..." 4
.IX Item "If tha /a modifier is up in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches tha 63 charactas [a\-zA\-Z0\-9_].
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches tha same ol' dirty as \f(CW\*(C`\ep{Word}\*(C'\fR matches up in dis range.  That is,
it matches Thai letters, Greek letters, etc.  This includes connector
punctuation (like tha underscore) which connect two lyrics together, or
diacritics, like fuckin a \f(CW\*(C`COMBINING TILDE\*(C'\fR n' tha modifier letters, which
are generally used ta add auxiliary markings ta letters.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rulez is up in effect ..." 4
.IX Item "if locale rulez is up in effect ..."
.PD
\&\f(CW\*(C`\ew\*(C'\fR matches tha platformz natizzle underscore characta plus whatever
the locale considaz ta be alphanumeric.
.IP "if Unicode rulez is up in effect ..." 4
.IX Item "if Unicode rulez is up in effect ..."
\&\f(CW\*(C`\ew\*(C'\fR matches exactly what tha fuck \f(CW\*(C`\ep{Word}\*(C'\fR matches.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\ew\*(C'\fR matches [a\-zA\-Z0\-9_].
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rulez apply is determined as busted lyrics bout up in \*(L"Which characta set modifier is up in effect?\*(R" up in perlre.
.PP
There is a fuckin shitload of securitizzle thangs wit tha full Unicode list of word
characters.  See <http://unicode.org/reports/tr36>.
.PP
Also, fo' a somewhat finer-grained set of charactas dat is up in programming
language identifiers beyond tha \s-1ASCII\s0 range, you may wish ta instead use the
more customized \*(L"Unicode Properties\*(R", \f(CW\*(C`\ep{ID_Start}\*(C'\fR,
\&\f(CW\*(C`\ep{ID_Continue}\*(C'\fR, \f(CW\*(C`\ep{XID_Start}\*(C'\fR, n' \f(CW\*(C`\ep{XID_Continue}\*(C'\fR.  See
<http://unicode.org/reports/tr31>.
.PP
Any characta not matched by \f(CW\*(C`\ew\*(C'\fR is matched by \f(CW\*(C`\eW\*(C'\fR.
.PP
\fIWhitespace\fR
.IX Subsection "Whitespace"
.PP
\&\f(CW\*(C`\es\*(C'\fR matches any single characta considered whitespace.
.ie n .IP "If tha ""/a"" modifier is up in effect ..." 4
.el .IP "If tha \f(CW/a\fR modifier is up in effect ..." 4
.IX Item "If tha /a modifier is up in effect ..."
In all Perl versions, \f(CW\*(C`\es\*(C'\fR matches tha 5 charactas [\et\en\ef\er ]; that
is, tha horizontal tab,
the newline, tha form feed, tha carriage return, n' tha space.
Startin up in Perl v5.18, experimentally, it also matches tha vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
See note \f(CW\*(C`[1]\*(C'\fR below fo' a gangbangin' finger-lickin' rap of all dis bullshit.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches exactly tha code points above 255 shown wit a \*(L"s\*(R" column
in tha table below.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rulez is up in effect ..." 4
.IX Item "if locale rulez is up in effect ..."
.PD
\&\f(CW\*(C`\es\*(C'\fR matches whatever tha locale considaz ta be whitespace.
.IP "if Unicode rulez is up in effect ..." 4
.IX Item "if Unicode rulez is up in effect ..."
\&\f(CW\*(C`\es\*(C'\fR matches exactly tha charactas shown wit a \*(L"s\*(R" column up in the
table below.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
\&\f(CW\*(C`\es\*(C'\fR matches [\et\en\ef\er\ecK ] and, starting, experimentally up in Perl
v5.18, tha vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
(See note \f(CW\*(C`[1]\*(C'\fR below fo' a gangbangin' finger-lickin' rap of all dis bullshit.)
Note dat dis list don't include tha non-breakin space.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rulez apply is determined as busted lyrics bout up in \*(L"Which characta set modifier is up in effect?\*(R" up in perlre.
.PP
Any characta not matched by \f(CW\*(C`\es\*(C'\fR is matched by \f(CW\*(C`\eS\*(C'\fR.
.PP
\&\f(CW\*(C`\eh\*(C'\fR matches any characta considered horizontal whitespace;
this includes tha platformz space n' tab charactas n' nuff muthafuckin others
listed up in tha table below.  \f(CW\*(C`\eH\*(C'\fR matches any character
not considered horizontal whitespace.  They use tha platformz native
characta set, n' do not consider any locale dat may otherwise be in
use.
.PP
\&\f(CW\*(C`\ev\*(C'\fR matches any characta considered vertical whitespace;
this includes tha platformz carriage return n' line feed charactas (newline)
plus nuff muthafuckin other characters, all listed up in tha table below.
\&\f(CW\*(C`\eV\*(C'\fR matches any characta not considered vertical whitespace.
They use tha platformz natizzle characta set, n' do not consider any
locale dat may otherwise be up in use.
.PP
\&\f(CW\*(C`\eR\*(C'\fR matches anythang dat can be considered a newline under Unicode
rules. It aint nuthin but not a cold-ass lil characta class, as it can match a multi-character
sequence. Therefore, it cannot be used inside a funky-ass bracketed character
class; use \f(CW\*(C`\ev\*(C'\fR instead (vertical whitespace).  It uses tha platform's
natizzle characta set, n' do not consider any locale dat may
otherwise be up in use.
Details is discussed up in perlrebackslash.
.PP
Note dat unlike \f(CW\*(C`\es\*(C'\fR (and \f(CW\*(C`\ed\*(C'\fR n' \f(CW\*(C`\ew\*(C'\fR), \f(CW\*(C`\eh\*(C'\fR n' \f(CW\*(C`\ev\*(C'\fR always match
the same characters, without regard ta other factors, like fuckin tha active
locale or whether tha source strang is up in \s-1UTF\-8\s0 format.
.PP
One might be thinkin dat \f(CW\*(C`\es\*(C'\fR is equivalent ta \f(CW\*(C`[\eh\ev]\*(C'\fR. This is indeed true
startin up in Perl v5.18 yo, but prior ta that, tha sole difference was dat the
vertical tab (\f(CW"\ecK"\fR) was not matched by \f(CW\*(C`\es\*(C'\fR.
.PP
Da followin table be a cold-ass lil complete listin of charactas matched by
\&\f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eh\*(C'\fR n' \f(CW\*(C`\ev\*(C'\fR az of Unicode 6.0.
.PP
Da first column gives tha Unicode code point of tha characta (in hex format),
the second column gives tha (Unicode) name. Da third column indicates
by which class(es) tha characta is matched (assumin no locale is in
effect dat chizzlez tha \f(CW\*(C`\es\*(C'\fR matching).
.PP
.Vb 10
\& 0x0009        CHARACTER TABULATION   h s
\& 0x000a              LINE FEED (LF)    vs
\& 0x000b             LINE TABULATION    vs  [1]
\& 0x000c              FORM FEED (FF)    vs
\& 0x000d        CARRIAGE RETURN (CR)    vs
\& 0x0020                       SPACE   h s
\& 0x0085             NEXT LINE (NEL)    vs  [2]
\& 0x00a0              NO\-BREAK SPACE   h s  [2]
\& 0x1680            OGHAM SPACE MARK   h s
\& 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
\& 0x2000                     EN QUAD   h s
\& 0x2001                     EM QUAD   h s
\& 0x2002                    EN SPACE   h s
\& 0x2003                    EM SPACE   h s
\& 0x2004          THREE\-PER\-EM SPACE   h s
\& 0x2005           FOUR\-PER\-EM SPACE   h s
\& 0x2006            SIX\-PER\-EM SPACE   h s
\& 0x2007                FIGURE SPACE   h s
\& 0x2008           PUNCTUATION SPACE   h s
\& 0x2009                  THIN SPACE   h s
\& 0x200a                  HAIR SPACE   h s
\& 0x2028              LINE SEPARATOR    vs
\& 0x2029         PARAGRAPH SEPARATOR    vs
\& 0x202f       NARROW NO\-BREAK SPACE   h s
\& 0x205f   MEDIUM MATHEMATICAL SPACE   h s
\& 0x3000           IDEOGRAPHIC SPACE   h s
.Ve
.IP "[1]" 4
.IX Item "[1]"
Prior ta Perl v5.18, \f(CW\*(C`\es\*(C'\fR did not match tha vertical tab.  Da chizzle
in v5.18 is considered a experiment, which means it could be backed out
in v5.20 or v5.22 if experience indicates dat it breaks too much
existin code.  If dis chizzle adversely affects you, bust email to
\&\f(CW\*(C`perlbug@perl.org\*(C'\fR; if it affects you positively, email
\&\f(CW\*(C`perlthanks@perl.org\*(C'\fR.  In tha meantime, \f(CW\*(C`[^\eS\ecK]\*(C'\fR (obscurely)
matches what tha fuck \f(CW\*(C`\es\*(C'\fR traditionally done did.
.IP "[2]" 4
.IX Item "[2]"
\&\s-1NEXT LINE\s0 n' NO-BREAK \s-1SPACE\s0 may or may not match \f(CW\*(C`\es\*(C'\fR depending
on tha rulez up in effect.  See
the beginnin of dis section.
.PP
\fIUnicode Properties\fR
.IX Subsection "Unicode Properties"
.PP
\&\f(CW\*(C`\epP\*(C'\fR n' \f(CW\*(C`\ep{Prop}\*(C'\fR is characta classes ta match charactas dat fit given
Unicode properties. Put ya muthafuckin choppers up if ya feel dis!  One letta property names can be used up in tha \f(CW\*(C`\epP\*(C'\fR form,
with tha property name followin tha \f(CW\*(C`\ep\*(C'\fR, otherwise, braces is required.
When rockin braces, there be a single form, which is just tha property name
enclosed up in tha braces, n' a cold-ass lil compound form which be lookin like \f(CW\*(C`\ep{name=value}\*(C'\fR,
which means ta match if tha property \*(L"name\*(R" fo' tha characta has dat particular
\&\*(L"value\*(R".
For instance, a match fo' a number can be freestyled as \f(CW\*(C`/\epN/\*(C'\fR or as
\&\f(CW\*(C`/\ep{Number}/\*(C'\fR, or as \f(CW\*(C`/\ep{Number=True}/\*(C'\fR.
Lowercase lettas is matched by tha property \fILowercase_Letter\fR which
has tha short form \fILl\fR. They need tha braces, so is freestyled as \f(CW\*(C`/\ep{Ll}/\*(C'\fR or
\&\f(CW\*(C`/\ep{Lowercase_Letter}/\*(C'\fR, or \f(CW\*(C`/\ep{General_Category=Lowercase_Letter}/\*(C'\fR
(the underscores is optional).
\&\f(CW\*(C`/\epLl/\*(C'\fR is valid yo, but means suttin' different.
It matches a two characta string: a letta (Unicode property \f(CW\*(C`\epL\*(C'\fR),
followed by a lowercase \f(CW\*(C`l\*(C'\fR.
.PP
If locale rulez is not up in effect, tha use of
a Unicode property will force tha regular expression tha fuck into rockin Unicode
rules, if it aint already.
.PP
Note dat almost all propertizzles is immune ta case-insensitizzle matching.
That is, addin a \f(CW\*(C`/i\*(C'\fR regular expression modifier do not chizzle what
they match.  There is two sets dat is affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da first set is
\&\f(CW\*(C`Uppercase_Letter\*(C'\fR,
\&\f(CW\*(C`Lowercase_Letter\*(C'\fR,
and \f(CW\*(C`Titlecase_Letter\*(C'\fR,
all of which match \f(CW\*(C`Cased_Letter\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
Da second set is
\&\f(CW\*(C`Uppercase\*(C'\fR,
\&\f(CW\*(C`Lowercase\*(C'\fR,
and \f(CW\*(C`Titlecase\*(C'\fR,
all of which match \f(CW\*(C`Cased\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
(Da difference between these sets is dat some thangs, like fuckin Roman
numerals, come up in both upper n' lower case, so they is \f(CW\*(C`Cased\*(C'\fR yo, but
aren't considered ta be letters, so they aren't \f(CW\*(C`Cased_Letter\*(C'\fRs. They're
actually \f(CW\*(C`Letter_Number\*(C'\fRs.)
This set also includes its subsets \f(CW\*(C`PosixUpper\*(C'\fR n' \f(CW\*(C`PosixLower\*(C'\fR, both
of which under \f(CW\*(C`/i\*(C'\fR match \f(CW\*(C`PosixAlpha\*(C'\fR.
.PP
For mo' details on Unicode properties, peep \*(L"Unicode
Characta Properties\*(R" up in perlunicode; fo' a
complete list of possible properties, see
\&\*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops,
which notes all forms dat have \f(CW\*(C`/i\*(C'\fR differences.
It be also possible ta define yo' own properties. Put ya muthafuckin choppers up if ya feel dis! This is discussed in
\&\*(L"User-Defined Characta Properties\*(R" up in perlunicode.
.PP
Unicode propertizzles is defined (surprise!) only on Unicode code points.
A warnin is raised n' all matches fail on non-Unicode code points
(those above tha legal Unicode maximum of 0x10FFFF).  This can be
somewhat surprising,
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Also fails!
.Ve
.PP
Even though these two matches might be thought of as complements, they
are so only on Unicode code points.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 8
\& "a"  =~  /\ew/      # Match, "a" be a \*(Aqword\*(Aq character.
\& "7"  =~  /\ew/      # Match, "7" be a \*(Aqword\*(Aq characta as well.
\& "a"  =~  /\ed/      # No match, "a" isn\*(Aqt a gangbangin' finger-lickin' digit.
\& "7"  =~  /\ed/      # Match, "7" be a gangbangin' finger-lickin' digit.
\& " "  =~  /\es/      # Match, a space is whitespace.
\& "a"  =~  /\eD/      # Match, "a" be a non\-digit.
\& "7"  =~  /\eD/      # No match, "7" aint a non\-digit.
\& " "  =~  /\eS/      # No match, a space aint non\-whitespace.
\&
\& " "  =~  /\eh/      # Match, space is horizontal whitespace.
\& " "  =~  /\ev/      # No match, space aint vertical whitespace.
\& "\er" =~  /\ev/      # Match, a return is vertical whitespace.
\&
\& "a"  =~  /\epL/     # Match, "a" be a letter.
\& "a"  =~  /\ep{Lu}/  # No match, /\ep{Lu}/ matches upper case letters.
\&
\& "\ex{0e0b}" =~ /\ep{Thai}/  # Match, \ex{0e0b} is tha character
\&                           # \*(AqTHAI CHARACTER SO SO\*(Aq, n' that\*(Aqs in
\&                           # Thai Unicode class.
\& "a"  =~  /\eP{Lao}/ # Match, as "a" aint a Laotian character.
.Ve
.PP
It be worth emphasizin dat \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, etc, match single characters, not
complete numbers or lyrics. To match a number (that consistz of digits),
use \f(CW\*(C`\ed+\*(C'\fR; ta match a word, use \f(CW\*(C`\ew+\*(C'\fR.  But be aware of tha security
considerations up in bustin so, as mentioned above.
.SS "Bracketed Characta Classes"
.IX Subsection "Bracketed Characta Classes"
Da third form of characta class you can use up in Perl regular expressions
is tha bracketed characta class.  In its simplest form, it lists tha characters
that may be matched, surrounded by square brackets, like this: \f(CW\*(C`[aeiou]\*(C'\fR.
This matches one of \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`e\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`o\*(C'\fR or \f(CW\*(C`u\*(C'\fR.  Like tha other
characta classes, exactly one characta is matched.* To match
a longer strang consistin of charactas mentioned up in tha character
class, follow tha characta class wit a quantifier n' shit.  For
instance, \f(CW\*(C`[aeiou]+\*(C'\fR matches one or mo' lowercase Gangsta vowels.
.PP
Repeatin a cold-ass lil characta up in a cold-ass lil characta class has no
effect; itz considered ta be up in tha set only once.
.PP
Examples:
.PP
.Vb 5
\& "e"  =~  /[aeiou]/        # Match, as "e" is listed up in tha class.
\& "p"  =~  /[aeiou]/        # No match, "p" aint listed up in tha class.
\& "ae" =~  /^[aeiou]$/      # No match, a cold-ass lil characta class only matches
\&                           # a single character.
\& "ae" =~  /^[aeiou]+$/     # Match, cuz of tha quantifier.
\&
\& \-\-\-\-\-\-\-
.Ve
.PP
* There be a exception ta a funky-ass bracketed characta class matchin a
single characta only.  When tha class is ta match caselessly under \f(CW\*(C`/i\*(C'\fR
matchin rules, n' a cold-ass lil characta dat is explicitly mentioned inside the
class matches a
multiple-characta sequence caselessly under Unicode rules, tha class
(when not inverted) will also match dat sequence.  For
example, Unicode say dat tha letta \f(CW\*(C`LATIN SMALL LETTER SHARP S\*(C'\fR
should match tha sequence \f(CW\*(C`ss\*(C'\fR under \f(CW\*(C`/i\*(C'\fR rules.  Thus,
.PP
.Vb 2
\& \*(Aqss\*(Aq =~ /\eA\eN{LATIN SMALL LETTER SHARP S}\ez/i             # Matches
\& \*(Aqss\*(Aq =~ /\eA[aeioust\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # Matches
.Ve
.PP
For dis ta happen, tha characta must be explicitly specified, n' not
be part of a multi-characta range (not even as one of its endpoints).
(\*(L"Characta Ranges\*(R" is ghon be explained shortly.)  Therefore,
.PP
.Vb 5
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\ex{ff}]\ez/i        # Don\*(Aqt match
\& \*(Aqss\*(Aq =~ /\eA[\e0\-\eN{LATIN SMALL LETTER SHARP S}]\ez/i    # No match
\& \*(Aqss\*(Aq =~ /\eA[\exDF\-\exDF]\ez/i    # Matches on ASCII platforms, since \eXDF
\&                               # is LATIN SMALL LETTER SHARP S, n' the
\&                               # range is just a single element
.Ve
.PP
Note dat it aint a phat scam ta specify these typez of ranges anyway.
.PP
\fISpecial Charactas Inside a Bracketed Characta Class\fR
.IX Subsection "Special Charactas Inside a Bracketed Characta Class"
.PP
Most charactas dat is meta charactas up in regular expressions (that
is, charactas dat carry a special meanin like \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`*\*(C'\fR, or \f(CW\*(C`(\*(C'\fR) lose
their special meanin n' can be used inside a cold-ass lil characta class without
the need ta escape em. For instance, \f(CW\*(C`[()]\*(C'\fR matches either a opening
parenthesis, or a cold-ass lil closin parenthesis, n' tha parens inside tha character
class don't crew or capture.
.PP
Charactas dat may carry a special meanin inside a cold-ass lil characta class are:
\&\f(CW\*(C`\e\*(C'\fR, \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`\-\*(C'\fR, \f(CW\*(C`[\*(C'\fR n' \f(CW\*(C`]\*(C'\fR, n' is discussed below. They can be
escaped wit a funky-ass backslash, although dis is sometimes not needed, up in which
case tha backslash may be omitted.
.PP
Da sequence \f(CW\*(C`\eb\*(C'\fR is special inside a funky-ass bracketed characta class. While
outside tha characta class, \f(CW\*(C`\eb\*(C'\fR be a assertion indicatin a point
that aint gots either two word charactas or two non-word characters
on either side, inside a funky-ass bracketed characta class, \f(CW\*(C`\eb\*(C'\fR matches a
backspace character.
.PP
Da sequences
\&\f(CW\*(C`\ea\*(C'\fR,
\&\f(CW\*(C`\ec\*(C'\fR,
\&\f(CW\*(C`\ee\*(C'\fR,
\&\f(CW\*(C`\ef\*(C'\fR,
\&\f(CW\*(C`\en\*(C'\fR,
\&\f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR,
\&\f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR,
\&\f(CW\*(C`\er\*(C'\fR,
\&\f(CW\*(C`\et\*(C'\fR,
and
\&\f(CW\*(C`\ex\*(C'\fR
are also special n' have tha same meanings as they do outside a
bracketed characta class.  (But fuck dat shiznit yo, tha word on tha street is dat inside a funky-ass bracketed character
class, if \f(CW\*(C`\eN{\f(CINAME\f(CW}\*(C'\fR expandz ta a sequence of characters, only tha first
one up in tha sequence is used, wit a warning.)
.PP
Also, a funky-ass backslash followed by two or three octal digits is considered a octal
number.
.PP
A \f(CW\*(C`[\*(C'\fR aint special inside a cold-ass lil characta class, unless itz tha start of a
\&\s-1POSIX\s0 characta class (see \*(L"\s-1POSIX\s0 Characta Classes\*(R" below). Well shiiiit, it normally do
not need escaping.
.PP
A \f(CW\*(C`]\*(C'\fR is normally either tha end of a \s-1POSIX\s0 characta class (see
\&\*(L"\s-1POSIX\s0 Characta Classes\*(R" below), or it signals tha end of tha bracketed
characta class.  If you wanna include a \f(CW\*(C`]\*(C'\fR up in tha set of characters, you
must generally escape dat shit.
.PP
But fuck dat shiznit yo, tha word on tha street is dat if tha \f(CW\*(C`]\*(C'\fR is tha \fIfirst\fR (or tha second if tha first
characta be a cold-ass lil caret) characta of a funky-ass bracketed characta class, it
does not denote tha end of tha class (as you cannot have a empty class)
and is considered part of tha set of charactas dat can be matched without
escaping.
.PP
Examples:
.PP
.Vb 8
\& "+"   =~ /[+?*]/     #  Match, "+" up in a cold-ass lil characta class aint special.
\& "\ecH" =~ /[\eb]/      #  Match, \eb inside up in a cold-ass lil characta class.
\&                      #  is equivalent ta a funky-ass backspace.
\& "]"   =~ /[][]/      #  Match, as tha characta class gotz nuff.
\&                      #  both [ n' ].
\& "[]"  =~ /[[]]/      #  Match, tha pattern gotz nuff a cold-ass lil characta class
\&                      #  containin just ], n' tha characta class is
\&                      #  followed by a ].
.Ve
.PP
\fICharacta Ranges\fR
.IX Subsection "Characta Ranges"
.PP
It aint uncommon ta wanna match a range of characters. Luckily, instead
of listin all charactas up in tha range, one may use tha hyphen (\f(CW\*(C`\-\*(C'\fR).
If inside a funky-ass bracketed characta class you have two charactas separated
by a hyphen, itz treated as if all charactas between tha two was in
the class. For instance, \f(CW\*(C`[0\-9]\*(C'\fR matches any \s-1ASCII\s0 digit, n' \f(CW\*(C`[a\-m]\*(C'\fR
matches any lowercase letta from tha straight-up original gangsta half of tha \s-1ASCII\s0 alphabet.
.PP
Note dat tha two charactas on either side of tha hyphen is not
necessarily both lettas or both digits fo' realz. Any characta is possible,
although not advisable.  \f(CW\*(C`[\*(Aq\-?]\*(C'\fR gotz nuff a range of charactas yo, but
most playas aint gonna know which charactas dat means.  Furthermore,
such ranges may lead ta portabilitizzle problems if tha code has ta run on
a platform dat uses a gangbangin' finger-lickin' different characta set, like fuckin \s-1EBCDIC.\s0
.PP
If a hyphen up in a cold-ass lil characta class cannot syntactically be part of a range, for
instizzle cuz it is tha straight-up original gangsta or tha last characta of tha characta class,
or if it immediately bigs up a range, tha hyphen aint special, n' so is
considered a cold-ass lil characta ta be matched literally.  If you want a hyphen in
your set of charactas ta be matched n' its posizzle up in tha class is such
that it could be considered part of a range, you must escape dat hyphen
with a funky-ass backslash.
.PP
Examples:
.PP
.Vb 8
\& [a\-z]       #  Matches a cold-ass lil characta dat be a lower case ASCII letter.
\& [a\-fz]      #  Matches any letta between \*(Aqa\*(Aq n' \*(Aqf\*(Aq (inclusive) or
\&             #  tha letta \*(Aqz\*(Aq.
\& [\-z]        #  Matches either a hyphen (\*(Aq\-\*(Aq) or tha letta \*(Aqz\*(Aq.
\& [a\-f\-m]     #  Matches any letta between \*(Aqa\*(Aq n' \*(Aqf\*(Aq (inclusive), the
\&             #  hyphen (\*(Aq\-\*(Aq), or tha letta \*(Aqm\*(Aq.
\& [\*(Aq\-?]       #  Matches any of tha charactas  \*(Aq()*+,\-./0123456789:;<=>?
\&             #  (But not on a EBCDIC platform).
.Ve
.PP
\fINegation\fR
.IX Subsection "Negation"
.PP
It be also possible ta instead list tha charactas you do not want to
match. Yo ass can do so by rockin a cold-ass lil caret (\f(CW\*(C`^\*(C'\fR) as tha straight-up original gangsta characta up in the
characta class. For instance, \f(CW\*(C`[^a\-z]\*(C'\fR matches any characta dat aint a
lowercase \s-1ASCII\s0 letter, which therefore includes mo' than a million
Unicode code points, n' you can put dat on yo' toast.  Da class is holla'd ta be \*(L"negated\*(R" or \*(L"inverted\*(R".
.PP
This syntax make tha caret a special characta inside a funky-ass bracketed character
class yo, but only if it is tha straight-up original gangsta characta of tha class. Right back up in yo muthafuckin ass. So if you want
the caret as one of tha charactas ta match, either escape tha caret or
else don't list it first.
.PP
In inverted bracketed characta classes, Perl ignores tha Unicode rules
that normally say dat certain charactas should match a sequence of
multiple charactas under caseless \f(CW\*(C`/i\*(C'\fR matching.  Peepin them
rulez could lead ta highly confusin thangs:
.PP
.Vb 1
\& "ss" =~ /^[^\exDF]+$/ui;   # Matches!
.Ve
.PP
This should match any sequencez of charactas dat aren't \f(CW\*(C`\exDF\*(C'\fR nor
what \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  \f(CW"s"\fR aint \f(CW\*(C`\exDF\*(C'\fR yo, but Unicode
says dat \f(CW"ss"\fR is what tha fuck \f(CW\*(C`\exDF\*(C'\fR matches under \f(CW\*(C`/i\*(C'\fR.  So which one
\&\*(L"wins\*(R", biatch? Do you fail tha match cuz tha strang has \f(CW\*(C`ss\*(C'\fR or accept it
because it has a \f(CW\*(C`s\*(C'\fR followed by another \f(CW\*(C`s\*(C'\fR, biatch?  Perl has chosen the
latter.
.PP
Examples:
.PP
.Vb 4
\& "e"  =~  /[^aeiou]/   #  No match, tha \*(Aqe\*(Aq is listed.
\& "x"  =~  /[^aeiou]/   #  Match, as \*(Aqx\*(Aq isn\*(Aqt a lowercase vowel.
\& "^"  =~  /[^^]/       #  No match, matches anythang dat isn\*(Aqt a cold-ass lil caret.
\& "^"  =~  /[x^]/       #  Match, caret aint special here.
.Ve
.PP
\fIBackslash Sequences\fR
.IX Subsection "Backslash Sequences"
.PP
Yo ass can put any backslash sequence characta class (with tha exception of
\&\f(CW\*(C`\eN\*(C'\fR n' \f(CW\*(C`\eR\*(C'\fR) inside a funky-ass bracketed characta class, n' it will act just
as if you had put all charactas matched by tha backslash sequence inside the
characta class. For instance, \f(CW\*(C`[a\-f\ed]\*(C'\fR matches any decimal digit, or any
of tha lowercase lettas between 'a' n' 'f' inclusive.
.PP
\&\f(CW\*(C`\eN\*(C'\fR within a funky-ass bracketed characta class must be of tha forms \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR
or \f(CW\*(C`\eN{U+\f(CIhex char\f(CW}\*(C'\fR, n' \s-1NOT\s0 be tha form dat matches non-newlines,
for tha same reason dat a thugged-out dot \f(CW\*(C`.\*(C'\fR inside a funky-ass bracketed characta class loses
its special meaning: it matches nearly anything, which generally aint what tha fuck you
wanna happen.
.PP
Examples:
.PP
.Vb 4
\& /[\ep{Thai}\ed]/     # Matches a cold-ass lil characta dat is either a Thai
\&                    # character, or a gangbangin' finger-lickin' digit.
\& /[^\ep{Arabic}()]/  # Matches a cold-ass lil characta dat is neither a Arabic
\&                    # character, nor a parenthesis.
.Ve
.PP
Backslash sequence characta classes cannot form one of tha endpoints
of a range.  Thus, you can't say:
.PP
.Vb 1
\& /[\ep{Thai}\-\ed]/     # Wrong!
.Ve
.PP
\fI\s-1POSIX\s0 Characta Classes\fR
.IX Xref "characta class \\p \\p{} alpha alnum ascii blank cntrl digit graph lower print punct space upper word xdigit"
.IX Subsection "POSIX Characta Classes"
.PP
\&\s-1POSIX\s0 characta classes have tha form \f(CW\*(C`[:class:]\*(C'\fR, where \fIclass\fR is
name, n' tha \f(CW\*(C`[:\*(C'\fR n' \f(CW\*(C`:]\*(C'\fR delimiters. \s-1POSIX\s0 characta classes only appear
\&\fIinside\fR bracketed characta classes, n' is a cold-ass lil convenient n' descriptive
way of listin a crew of characters.
.PP
Be careful bout tha syntax,
.PP
.Vb 2
\& # Correct:
\& $strin =~ /[[:alpha:]]/
\&
\& # Incorrect (will warn):
\& $strin =~ /[:alpha:]/
.Ve
.PP
Da latta pattern would be a cold-ass lil characta class consistin of a cold-ass lil colon,
and tha lettas \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR n' \f(CW\*(C`h\*(C'\fR.
\&\s-1POSIX\s0 characta classes can be part of a larger bracketed characta class.
For example,
.PP
.Vb 1
\& [01[:alpha:]%]
.Ve
.PP
is valid n' matches '0', '1', any alphabetic character, n' tha cement sign.
.PP
Perl recognizes tha followin \s-1POSIX\s0 characta classes:
.PP
.Vb 10
\& alpha  Any alphabetical characta ("[A\-Za\-z]").
\& alnum  Any alphanumeric characta ("[A\-Za\-z0\-9]").
\& ascii  Any characta up in tha ASCII characta set.
\& blank  A GNU extension, equal ta a space or a horizontal tab ("\et").
\& cntrl  Any control character n' shit.  See Note [2] below.
\& digit  Any decimal digit ("[0\-9]"), equivalent ta "\ed".
\& graph  Any printable character, excludin a space.  See Note [3] below.
\& lower  Any lowercase characta ("[a\-z]").
\& print  Any printable character, includin a space.  See Note [4] below.
\& punct  Any graphical characta excludin "word" characters.  Note [5].
\& space  Any whitespace character n' shit. "\es" includin tha vertical tab
\&        ("\ecK").
\& upper  Any uppercase characta ("[A\-Z]").
\& word   A Perl extension ("[A\-Za\-z0\-9_]"), equivalent ta "\ew".
\& xdigit Any hexadecimal digit ("[0\-9a\-fA\-F]").
.Ve
.PP
Most \s-1POSIX\s0 characta classes have two Unicode-style \f(CW\*(C`\ep\*(C'\fR property
counterparts, n' you can put dat on yo' toast.  (They is not straight-up legit Unicode propertizzles yo, but Perl extensions
derived from straight-up legit Unicode properties.)  Da table below shows tha relation
between \s-1POSIX\s0 characta classes n' these counterparts.
.PP
One counterpart, up in tha column labelled \*(L"ASCII-range Unicode\*(R" in
the table, matches only charactas up in tha \s-1ASCII\s0 characta set.
.PP
Da other counterpart, up in tha column labelled \*(L"Full-range Unicode\*(R", matches any
appropriate charactas up in tha full Unicode characta set.  For example,
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR matches not just tha \s-1ASCII\s0 alphabetic charactas yo, but any
characta up in tha entire Unicode characta set considered alphabetic.
An entry up in tha column labelled \*(L"backslash sequence\*(R" be a (short)
equivalent.
.PP
.Vb 10
\& [[:...:]]      ASCII\-range          Full\-range  backslash  Note
\&                 Unicode              Unicode     sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   alpha      \ep{PosixAlpha}       \ep{XPosixAlpha}
\&   alnum      \ep{PosixAlnum}       \ep{XPosixAlnum}
\&   ascii      \ep{ASCII}
\&   blank      \ep{PosixBlank}       \ep{XPosixBlank}  \eh      [1]
\&                                   or \ep{HorizSpace}        [1]
\&   cntrl      \ep{PosixCntrl}       \ep{XPosixCntrl}          [2]
\&   digit      \ep{PosixDigit}       \ep{XPosixDigit}  \ed
\&   graph      \ep{PosixGraph}       \ep{XPosixGraph}          [3]
\&   lower      \ep{PosixLower}       \ep{XPosixLower}
\&   print      \ep{PosixPrint}       \ep{XPosixPrint}          [4]
\&   punct      \ep{PosixPunct}       \ep{XPosixPunct}          [5]
\&              \ep{PerlSpace}        \ep{XPerlSpace}   \es      [6]
\&   space      \ep{PosixSpace}       \ep{XPosixSpace}          [6]
\&   upper      \ep{PosixUpper}       \ep{XPosixUpper}
\&   word       \ep{PosixWord}        \ep{XPosixWord}   \ew
\&   xdigit     \ep{PosixXDigit}      \ep{XPosixXDigit}
.Ve
.IP "[1]" 4
.IX Item "[1]"
\&\f(CW\*(C`\ep{Blank}\*(C'\fR n' \f(CW\*(C`\ep{HorizSpace}\*(C'\fR is synonyms.
.IP "[2]" 4
.IX Item "[2]"
Control charactas don't produce output as such yo, but instead probably control
the terminal somehow: fo' example, newline n' backspace is control characters.
In tha \s-1ASCII\s0 range, charactas whose code points is between 0 n' 31 inclusive,
plus 127 (\f(CW\*(C`DEL\*(C'\fR) is control characters.
.IP "[3]" 4
.IX Item "[3]"
Any characta dat is \fIgraphical\fR, dat is, visible. This class consists
of all alphanumeric charactas n' all punctuation characters.
.IP "[4]" 4
.IX Item "[4]"
All printable characters, which is tha set of all graphical characters
plus dem whitespace charactas which is not also controls.
.IP "[5]" 4
.IX Item "[5]"
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR n' \f(CW\*(C`[[:punct:]]\*(C'\fR up in tha \s-1ASCII\s0 range match all
non-controls, non-alphanumeric, non-space characters:
\&\f(CW\*(C`[\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e\e]^_\`{|}~]\*(C'\fR (although if a locale is up in effect,
it could alta tha behavior of \f(CW\*(C`[[:punct:]]\*(C'\fR).
.Sp
Da similarly named property, \f(CW\*(C`\ep{Punct}\*(C'\fR, matches a somewhat different
set up in tha \s-1ASCII\s0 range, namely
\&\f(CW\*(C`[\-!"#%&\*(Aq()*,./:;?@[\e\e\e]_{}]\*(C'\fR.  That is, it is missin tha nine
charactas \f(CW\*(C`[$+<=>^\`|~]\*(C'\fR.
This is cuz Unicode splits what tha fuck \s-1POSIX\s0 considaz ta be punctuation tha fuck into two
categories, Punctuation n' Symbols.
.Sp
\&\f(CW\*(C`\ep{XPosixPunct}\*(C'\fR n' (under Unicode rules) \f(CW\*(C`[[:punct:]]\*(C'\fR, match what
\&\f(CW\*(C`\ep{PosixPunct}\*(C'\fR matches up in tha \s-1ASCII\s0 range, plus what tha fuck \f(CW\*(C`\ep{Punct}\*(C'\fR
matches.  This is different than strictly matchin accordin to
\&\f(CW\*(C`\ep{Punct}\*(C'\fR.  Another way ta say it is that
if Unicode rulez is up in effect, \f(CW\*(C`[[:punct:]]\*(C'\fR matches all characters
that Unicode considaz punctuation, plus all ASCII-range charactas that
Unicode considaz symbols.
.IP "[6]" 4
.IX Item "[6]"
\&\f(CW\*(C`\ep{SpacePerl}\*(C'\fR n' \f(CW\*(C`\ep{Space}\*(C'\fR match identically startin wit Perl
v5.18.  In earlier versions, these differ only up in dat up in non-locale
matching, \f(CW\*(C`\ep{SpacePerl}\*(C'\fR do not match tha vertical tab, \f(CW\*(C`\ecK\*(C'\fR.
Same fo' tha two ASCII-only range forms.
.PP
There is various other synonyms dat can be used besides tha names
listed up in tha table.  For example, \f(CW\*(C`\ep{PosixAlpha}\*(C'\fR can be freestyled as
\&\f(CW\*(C`\ep{Alpha}\*(C'\fR.  All is listed in
\&\*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops,
plus all charactas matched by each ASCII-range property.
.PP
Both tha \f(CW\*(C`\ep\*(C'\fR counterparts always assume Unicode rulez is up in effect.
On \s-1ASCII\s0 platforms, dis means they assume dat tha code points from 128
to 255 is Latin\-1, n' dat means dat rockin dem under locale rulez is
unwise unless tha locale is guaranteed ta be Latin\-1 or \s-1UTF\-8. \s0 In contrast, the
\&\s-1POSIX\s0 characta classes is useful under locale rules.  They are
affected by tha actual rulez up in effect, as bigs up:
.ie n .IP "If tha ""/a"" modifier, is up in effect ..." 4
.el .IP "If tha \f(CW/a\fR modifier, is up in effect ..." 4
.IX Item "If tha /a modifier, is up in effect ..."
Each of tha \s-1POSIX\s0 classes matches exactly tha same as they ASCII-range
counterparts.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
.RS 4
.PD 0
.IP "For code points above 255 ..." 4
.IX Item "For code points above 255 ..."
.PD
Da \s-1POSIX\s0 class matches tha same ol' dirty as its Full-range counterpart.
.IP "For code points below 256 ..." 4
.IX Item "For code points below 256 ..."
.RS 4
.PD 0
.IP "if locale rulez is up in effect ..." 4
.IX Item "if locale rulez is up in effect ..."
.PD
Da \s-1POSIX\s0 class matches accordin ta tha locale, except that
\&\f(CW\*(C`word\*(C'\fR uses tha platformz natizzle underscore character, no matta what
the locale is.
.IP "if Unicode rulez is up in effect ..." 4
.IX Item "if Unicode rulez is up in effect ..."
Da \s-1POSIX\s0 class matches tha same ol' dirty as tha Full-range counterpart.
.IP "otherwise ..." 4
.IX Item "otherwise ..."
Da \s-1POSIX\s0 class matches tha same ol' dirty as tha \s-1ASCII\s0 range counterpart.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PP
Which rulez apply is determined as busted lyrics bout in
\&\*(L"Which characta set modifier is up in effect?\*(R" up in perlre.
.PP
It be proposed ta chizzle dis behavior up in a gangbangin' future release of Perl so that
whether or not Unicode rulez is up in effect would not chizzle the
behavior:  Outside of locale, tha \s-1POSIX\s0 classes
would behave like they ASCII-range counterparts, n' you can put dat on yo' toast.  If you wish to
comment on dis proposal, bust email ta \f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
Negation of \s-1POSIX\s0 characta classes
.IX Xref "characta class, negation"
.IX Subsection "Negation of POSIX characta classes"
.PP
A Perl extension ta tha \s-1POSIX\s0 characta class is tha mobilitizzle to
negate dat shit. This is done by prefixin tha class name wit a cold-ass lil caret (\f(CW\*(C`^\*(C'\fR).
Some examples:
.PP
.Vb 7
\&     POSIX         ASCII\-range     Full\-range  backslash
\&                    Unicode         Unicode    sequence
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& [[:^digit:]]   \eP{PosixDigit}  \eP{XPosixDigit}   \eD
\& [[:^space:]]   \eP{PosixSpace}  \eP{XPosixSpace}
\&                \eP{PerlSpace}   \eP{XPerlSpace}    \eS
\& [[:^word:]]    \eP{PerlWord}    \eP{XPosixWord}    \eW
.Ve
.PP
Da backslash sequence can mean either \s-1ASCII\-\s0 or Full-range Unicode,
dependin on various factors as busted lyrics bout up in \*(L"Which characta set modifier is up in effect?\*(R" up in perlre.
.PP
[= =] n' [. .]
.IX Subsection "[= =] n' [. .]"
.PP
Perl recognizes tha \s-1POSIX\s0 characta classes \f(CW\*(C`[=class=]\*(C'\fR and
\&\f(CW\*(C`[.class.]\*(C'\fR yo, but do not (yet?) support em.  Any attempt ta use
either construct raises a exception.
.PP
Examples
.IX Subsection "Examples"
.PP
.Vb 12
\& /[[:digit:]]/            # Matches a cold-ass lil characta dat be a gangbangin' finger-lickin' digit.
\& /[01[:lower:]]/          # Matches a cold-ass lil characta dat is either a
\&                          # lowercase letter, or \*(Aq0\*(Aq or \*(Aq1\*(Aq.
\& /[[:digit:][:^xdigit:]]/ # Matches a cold-ass lil characta dat can be anything
\&                          # except tha lettas \*(Aqa\*(Aq ta \*(Aqf\*(Aq n' \*(AqA\*(Aq to
\&                          # \*(AqF\*(Aq.  This is cuz tha main character
\&                          # class is composed of two POSIX character
\&                          # classes dat is ORed together, one that
\&                          # matches any digit, n' tha other that
\&                          # matches anythang dat isn\*(Aqt a hex digit.
\&                          # Da OR addz tha digits, leavin only the
\&                          # lettas \*(Aqa\*(Aq ta \*(Aqf\*(Aq n' \*(AqA\*(Aq ta \*(AqF\*(Aq excluded.
.Ve
.PP
\fIExtended Bracketed Characta Classes\fR
.IX Xref "characta class set operations"
.IX Subsection "Extended Bracketed Characta Classes"
.PP
This be a gangbangin' fancy bracketed characta class dat can be used fo' more
readable n' less error-prone classes, n' ta big-ass up set operations,
like fuckin intersection. I aint talkin' bout chicken n' gravy biatch fo' realz. An example is
.PP
.Vb 1
\& /(?[ \ep{Thai} & \ep{Digit} ])/
.Ve
.PP
This will match all tha digit charactas dat is up in tha Thai script.
.PP
This be a experimenstrual feature available startin up in 5.18, n' is
subject ta chizzle as we bust field experience wit dat shit.  Any attempt to
use it will raise a warning, unless disabled via
.PP
.Vb 1
\& no warnings "experimental::regex_sets";
.Ve
.PP
Comments on dis feature is welcome; bust email to
\&\f(CW\*(C`perl5\-porters@perl.org\*(C'\fR.
.PP
We can extend tha example above:
.PP
.Vb 1
\& /(?[ ( \ep{Thai} + \ep{Lao} ) & \ep{Digit} ])/
.Ve
.PP
This matches digits dat is up in either tha Thai or Laotian scripts.
.PP
Notice tha white space up in these examples.  This construct always has
the \f(CW\*(C`/x\*(C'\fR modifier turned on.
.PP
Da available binary operators are:
.PP
.Vb 10
\& &    intersection
\& +    union
\& |    another name fo' \*(Aq+\*(Aq, hence means union
\& \-    subtraction (the result matches tha set consistin of them
\&      code points matched by tha straight-up original gangsta operand, excludin any that
\&      is also matched by tha second operand)
\& ^    symmetric difference (the union minus tha intersection).  This
\&      is like a exclusive or, up in dat tha result is tha set of code
\&      points dat is matched by either yo, but not both, of the
\&      operands.
.Ve
.PP
There is one unary operator:
.PP
.Vb 1
\& !    complement
.Ve
.PP
All tha binary operators left associate, n' iz of equal precedence.
Da unary operator right associates, n' has higher precedence.  Use
parentheses ta override tha default associations.  Some feedback we've
received indicates a thugged-out desire fo' intersection ta have higher precedence
than union. I aint talkin' bout chicken n' gravy biatch.  This is suttin' dat feedback from tha field may cause us
to chizzle up in future releases; you may wanna parenthesize copiously to
avoid such chizzlez affectin yo' code, until dis feature is no longer
considered experimental.
.PP
Da main restriction is dat every last muthafuckin thang be a metacharacter n' shit.  Thus,
you cannot refer ta single charactas by bustin suttin' like this:
.PP
.Vb 1
\& /(?[ a + b ])/ # Syntax error!
.Ve
.PP
Da easiest way ta specify a individual typable characta is ta enclose
it up in brackets:
.PP
.Vb 1
\& /(?[ [a] + [b] ])/
.Ve
.PP
(This is tha same ol' dirty thang as \f(CW\*(C`[ab]\*(C'\fR.)  Yo ass could also have holla'd the
equivalent:
.PP
.Vb 1
\& /(?[[ a funky-ass b ]])/
.Ve
.PP
(Yo ass can, of course, specify single charactas by using, \f(CW\*(C`\ex{ }\*(C'\fR,
\&\f(CW\*(C`\eN{ }\*(C'\fR, etc.)
.PP
This last example shows tha use of dis construct ta specify a ordinary
bracketed characta class without additionizzle set operations.  Note the
white space within it; \f(CW\*(C`/x\*(C'\fR is turned on even within bracketed
characta classes, except you can't have comments inside em.  Hence,
.PP
.Vb 1
\& (?[ [#] ])
.Ve
.PP
matches tha literal characta \*(L"#\*(R".  To specify a literal white space character,
you can escape it wit a funky-ass backslash, like:
.PP
.Vb 1
\& /(?[ [ a e i o u \e  ] ])/
.Ve
.PP
This matches tha Gangsta vowels plus tha \s-1SPACE\s0 character.
All tha other escapes accepted by aiiight bracketed characta classes are
accepted here as well; but unrecognized escapes dat generate warnings
in aiiight classes is fatal errors here.
.PP
All warnings from these class elements is fatal, as well as some
practices dat don't currently warn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  For example you cannot say
.PP
.Vb 1
\& /(?[ [ \exF ] ])/     # Syntax error!
.Ve
.PP
Yo ass gotta have two hex digits afta a funky-ass braceless \f(CW\*(C`\ex\*(C'\fR (use a leading
zero ta make two).  These restrictions is ta lower tha incidence of
typos causin tha class ta not match what tha fuck you thought it would.
.PP
Da final difference between regular bracketed characta classes and
these, is dat it aint possible ta git these ta match a
multi-characta fold. Y'all KNOW dat shit, muthafucka!  Thus,
.PP
.Vb 1
\& /(?[ [\exDF] ])/iu
.Ve
.PP
does not match tha strang \f(CW\*(C`ss\*(C'\fR.
.PP
Yo ass don't gotta enclose \s-1POSIX\s0 class names inside double brackets,
hence both of tha followin work:
.PP
.Vb 2
\& /(?[ [:word:] \- [:lower:] ])/
\& /(?[ [[:word:]] \- [[:lower:]] ])/
.Ve
.PP
Any contained \s-1POSIX\s0 characta classes, includin thangs like \f(CW\*(C`\ew\*(C'\fR n' \f(CW\*(C`\eD\*(C'\fR
respect tha \f(CW\*(C`/a\*(C'\fR (and \f(CW\*(C`/aa\*(C'\fR) modifiers.
.PP
\&\f(CW\*(C`(?[ ])\*(C'\fR be a regex-compile-time construct.  Any attempt ta use
suttin' which aint knowable all up in tha time tha containin regular
expression is compiled be a gangbangin' fatal error. Shiiit, dis aint no joke.  In practice, dis means
just three limitiations:
.IP "1." 4
This construct cannot be used within tha scope of
\&\f(CW\*(C`use locale\*(C'\fR (or tha \f(CW\*(C`/l\*(C'\fR regex modifier).
.IP "2." 4
Any
user-defined property
used must be already defined by tha time tha regular expression is
compiled (but note dat dis construct can be used instead of such
properties).
.IP "3." 4
A regular expression dat otherwise would compile
usin \f(CW\*(C`/d\*(C'\fR rules, n' which uses dis construct will instead
use \f(CW\*(C`/u\*(C'\fR.  Thus dis construct  drops some lyrics ta Perl dat you don't want
\&\f(CW\*(C`/d\*(C'\fR rulez fo' tha entire regular expression containin dat shit.
.PP
Da \f(CW\*(C`/x\*(C'\fR processin within dis class be a extended form.
Besides tha charactas dat is considered white space up in aiiight \f(CW\*(C`/x\*(C'\fR
processing, there be 5 others, recommended by tha Unicode standard:
.PP
.Vb 5
\& U+0085 NEXT LINE
\& U+200E LEFT\-TO\-RIGHT MARK
\& U+200F RIGHT\-TO\-LEFT MARK
\& U+2028 LINE SEPARATOR
\& U+2029 PARAGRAPH SEPARATOR
.Ve
.PP
Note dat skippin white space applies only ta tha interior of this
construct.  There must not be any space between any of tha characters
that form tha initial \f(CW\*(C`(?[\*(C'\fR.  Nor may there be space between the
closin \f(CW\*(C`])\*(C'\fR characters.
.PP
Just as up in all regular expressions, tha pattern can can be built up by
includin variablez dat is interpolated at regex compilation time.
Care must be taken ta ensure dat yo ass is gettin what tha fuck you expect.  For
example:
.PP
.Vb 3
\& mah $thai_or_lao = \*(Aq\ep{Thai} + \ep{Lao}\*(Aq;
\& ...
\& qr/(?[ \ep{Digit} & $thai_or_lao ])/;
.Ve
.PP
compilez to
.PP
.Vb 1
\& qr/(?[ \ep{Digit} & \ep{Thai} + \ep{Lao} ])/;
.Ve
.PP
But dis aint gots tha effect dat one of mah thugs readin tha code would
likely expect, as tha intersection applies just ta \f(CW\*(C`\ep{Thai}\*(C'\fR,
excludin tha Laotian. I aint talkin' bout chicken n' gravy biatch.  Pitfalls like dis can be avoided by
parenthesizin tha component pieces:
.PP
.Vb 1
\& mah $thai_or_lao = \*(Aq( \ep{Thai} + \ep{Lao} )\*(Aq;
.Ve
.PP
But any modifiers will still apply ta all tha components:
.PP
.Vb 2
\& mah $lower = \*(Aq\ep{Lower} + \ep{Digit}\*(Aq;
\& qr/(?[ \ep{Greek} & $lower ])/i;
.Ve
.PP
matches upper case thangs.  Yo ass can avoid surprises by makin the
components tha fuck into instancez of dis construct by compilin them:
.PP
.Vb 2
\& mah $thai_or_lao = qr/(?[ \ep{Thai} + \ep{Lao} ])/;
\& mah $lower = qr/(?[ \ep{Lower} + \ep{Digit} ])/;
.Ve
.PP
When these is embedded up in another pattern, what tha fuck they match do not
change, regardless of parenthesization or what tha fuck modifiers is up in effect
in dat outa pattern.
.PP
Cuz of tha way dat Perl parses thangs, yo' parentheses n' brackets
may need ta be balanced, even includin comments, n' you can put dat on yo' toast.  If you run tha fuck into any
examples, please bust dem ta \f(CW\*(C`perlbug@perl.org\*(C'\fR, so dat we can have a
concrete example fo' dis playa page.
.PP
We may chizzle it so dat thangs dat remain legal uses up in aiiight bracketed
characta classes might become illegal within dis experimental
construct.  One proposal, fo' example, is ta forbid adjacent usez of the
same character, as up in \f(CW\*(C`(?[ [aa] ])\*(C'\fR.  Da motivation fo' such a cold-ass lil chizzle
is dat dis usage is likely a typo, as tha second \*(L"a\*(R" addz nothing.
