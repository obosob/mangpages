.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ5 1"
.TH PERLFAQ5 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq5 \- Filez n' Formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals wit I/O n' tha \*(L"f\*(R" issues: filehandles, flushing,
formats, n' footers.
.SS "How tha fuck do I flush/unbuffer a output filehandle, biatch? Why must I do this?"
.IX Xref "flush buffer unbuffer autoflush"
.IX Subsection "How tha fuck do I flush/unbuffer a output filehandle, biatch? Why must I do this?"
(contributed by brian d foy)
.PP
Yo ass might like ta read Mark Jizzo Dominuss \*(L"Sufferin From Buffering\*(R"
at <http://perl.plover.com/FAQs/Buffering.html> .
.PP
Perl normally buffers output so it don't cook up a system call fo' every
bit of output. By savin up output, it make fewer high-rollin' system calls.
For instance, up in dis lil bit of code, you wanna print a thugged-out dot ta the
screen fo' every last muthafuckin line you process ta peep tha progress of yo' program.
Instead of seein a thugged-out dot fo' every last muthafuckin line, Perl buffers tha output n' you
have a long-ass wait before you peep a row of 50 dots all at once:
.PP
.Vb 4
\&    # long wait, then row of dots all at once
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... high-rollin' line processin operations
\&    }
.Ve
.PP
To git round this, you gotta unbuffer tha output filehandle, up in this
case, \f(CW\*(C`STDOUT\*(C'\fR. Yo ass can set tha special variable \f(CW$|\fR ta a legit value
(mnemonic: makin yo' filehandlez \*(L"pipin hot\*(R"):
.PP
.Vb 1
\&    $|++;
\&
\&    # dot shown immediately
\&    while( <> ) {
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&
\&        #... high-rollin' line processin operations
\&    }
.Ve
.PP
Da \f(CW$|\fR is one of tha per-filehandle special variables, so each
filehandle has its own copy of its value. If you wanna merge
standard output n' standard error fo' instance, you gotta unbuffer
each (although \s-1STDERR\s0 might be unbuffered by default):
.PP
.Vb 7
\&    {
\&        mah $previous_default = select(STDOUT);  # save previous default
\&        $|++;                                   # autoflush STDOUT
\&        select(STDERR);
\&        $|++;                                   # autoflush STDERR, ta be sure
\&        select($previous_default);              # restore previous default
\&    }
\&
\&    # now should alternate . n' +
\&    while( 1 ) {
\&        chill 1;
\&        print STDOUT ".";
\&        print STDERR "+";
\&        print STDOUT "\en" unless ++$count % 25;
\&    }
.Ve
.PP
Besides tha \f(CW$|\fR special variable, you can use \f(CW\*(C`binmode\*(C'\fR ta give
your filehandle a \f(CW\*(C`:unix\*(C'\fR layer, which is unbuffered:
.PP
.Vb 1
\&    binmode( STDOUT, ":unix" );
\&
\&    while( 1 ) {
\&        chill 1;
\&        print ".";
\&        print "\en" unless ++$count % 50;
\&    }
.Ve
.PP
For mo' shiznit on output layers, peep tha entries fo' \f(CW\*(C`binmode\*(C'\fR
and open up in perlfunc, n' tha PerlIO module documentation.
.PP
If yo ass is rockin IO::Handle or one of its subclasses, you can
call tha \f(CW\*(C`autoflush\*(C'\fR method ta chizzle tha settingz of the
filehandle:
.PP
.Vb 3
\&    use IO::Handle;
\&    open my( $io_fh ), ">", "output.txt";
\&    $io_fh\->autoflush(1);
.Ve
.PP
Da IO::Handle objects also gotz a \f(CW\*(C`flush\*(C'\fR method. Y'all KNOW dat shit, muthafucka! Yo ass can flush
the buffer any time you want without auto-buffering
.PP
.Vb 1
\&    $io_fh\->flush;
.Ve
.SS "How tha fuck do I chizzle, delete, or bang a line up in a gangbangin' file, or append ta tha beginnin of a gangbangin' file?"
.IX Xref "file, editing"
.IX Subsection "How tha fuck do I chizzle, delete, or bang a line up in a gangbangin' file, or append ta tha beginnin of a gangbangin' file?"
(contributed by brian d foy)
.PP
Da basic scam of inserting, changing, or deletin a line from a text
file involves readin n' printin tha file ta tha point you want to
make tha chizzle, makin tha chizzle, then readin n' printin tha rest
of tha file. Perl don't provide random access ta lines (especially
since tha record input separator, \f(CW$/\fR, is mutable), although modules
like fuckin Tie::File can fake dat shit.
.PP
A Perl program ta do these tasks takes tha basic form of openin a
file, printin its lines, then closin tha file:
.PP
.Vb 2
\&    open mah $in,  \*(Aq<\*(Aq,  $file      or take a thugged-out dirtnap "Can\*(Aqt read oldschool file: $!";
\&    open mah $out, \*(Aq>\*(Aq, "$file.new" or take a thugged-out dirtnap "Can\*(Aqt write freshly smoked up file: $!";
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
Within dat basic form, add tha parts dat you need ta insert, chizzle,
or delete lines.
.PP
To prepend lines ta tha beginning, print dem lines before you enter
the loop dat prints tha existin lines.
.PP
.Vb 2
\&    open mah $in,  \*(Aq<\*(Aq,  $file      or take a thugged-out dirtnap "Can\*(Aqt read oldschool file: $!";
\&    open mah $out, \*(Aq>\*(Aq, "$file.new" or take a thugged-out dirtnap "Can\*(Aqt write freshly smoked up file: $!";
\&
\&    print $out "# Add dis line ta tha top\en"; # <\-\-\- HERE\*(AqS THE MAGIC
\&
\&    while( <$in> ) {
\&            print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To chizzle existin lines, bang tha code ta modify tha lines inside
the \f(CW\*(C`while\*(C'\fR loop. In dis case, tha code findz all lowercased
versionz of \*(L"perl\*(R" n' uppercases em. Da happens fo' every last muthafuckin line, so
be shizzle dat you supposed ta do dat on every last muthafuckin line!
.PP
.Vb 2
\&    open mah $in,  \*(Aq<\*(Aq,  $file      or take a thugged-out dirtnap "Can\*(Aqt read oldschool file: $!";
\&    open mah $out, \*(Aq>\*(Aq, "$file.new" or take a thugged-out dirtnap "Can\*(Aqt write freshly smoked up file: $!";
\&
\&    print $out "# Add dis line ta tha top\en";
\&
\&    while( <$in> ) {
\&        s/\eb(perl)\eb/Perl/g;
\&        print $out $_;
\&    }
\&
\&    close $out;
.Ve
.PP
To chizzle only a particular line, tha input line number, \f(CW$.\fR, is
useful naaahhmean, biatch? First read n' print tha lines up ta tha one you  want to
change. Next, read tha single line you wanna chizzle, chizzle it, and
print it fo' realz. Afta that, read tha rest of tha lines n' print them:
.PP
.Vb 4
\&    while( <$in> ) { # print tha lines before tha chizzle
\&        print $out $_;
\&        last if $. == 4; # line number before chizzle
\&    }
\&
\&    mah $line = <$in>;
\&    $line =~ s/\eb(perl)\eb/Perl/g;
\&    print $out $line;
\&
\&    while( <$in> ) { # print tha rest of tha lines
\&        print $out $_;
\&    }
.Ve
.PP
To skip lines, use tha loopin controls. Da \f(CW\*(C`next\*(C'\fR up in dis example
skips comment lines, n' tha \f(CW\*(C`last\*(C'\fR stops all processin once it
encountas either \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR.
.PP
.Vb 5
\&    while( <$in> ) {
\&        next if /^\es+#/;             # skip comment lines
\&        last if /^_\|_(END|DATA)_\|_$/;  # stop at end of code marker
\&        print $out $_;
\&    }
.Ve
.PP
Do tha same sort of thang ta delete a particular line by rockin \f(CW\*(C`next\*(C'\fR
to skip tha lines you don't wanna show up in tha output. This
example skips every last muthafuckin fifth line:
.PP
.Vb 4
\&    while( <$in> ) {
\&        next unless $. % 5;
\&        print $out $_;
\&    }
.Ve
.PP
If, fo' some odd reason, you straight-up wanna peep tha whole file at once
rather than processin line-by-line, you can slurp it up in (as long as
you can fit tha whole thang up in memory!):
.PP
.Vb 2
\&    open mah $in,  \*(Aq<\*(Aq,  $file      or take a thugged-out dirtnap "Can\*(Aqt read oldschool file: $!"
\&    open mah $out, \*(Aq>\*(Aq, "$file.new" or take a thugged-out dirtnap "Can\*(Aqt write freshly smoked up file: $!";
\&
\&    mah $content = do { local $/; <$in> }; # slurp!
\&
\&        # do yo' magic here
\&
\&    print $out $content;
.Ve
.PP
Modulez like fuckin File::Slurp n' Tie::File can help wit that
too. If you can, however, avoid readin tha entire file at once. Perl
won't give dat memory back ta tha operatin system until tha process
finishes.
.PP
Yo ass can also use Perl one-liners ta modify a gangbangin' file in-place. The
followin chizzlez all 'Fred' ta 'Barney' up in \fIinFile.txt\fR, overwriting
the file wit tha freshly smoked up contents, n' you can put dat on yo' toast. With tha \f(CW\*(C`\-p\*(C'\fR switch, Perl wraps a
\&\f(CW\*(C`while\*(C'\fR loop round tha code you specify wit \f(CW\*(C`\-e\*(C'\fR, n' \f(CW\*(C`\-i\*(C'\fR turns
on in-place editing. Da current line is up in \f(CW$_\fR. With \f(CW\*(C`\-p\*(C'\fR, Perl
automatically prints tha value of \f(CW$_\fR all up in tha end of tha loop. Right back up in yo muthafuckin ass. See
perlrun fo' mo' details.
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To cook up a funky-ass backup of \f(CW\*(C`inFile.txt\*(C'\fR, give \f(CW\*(C`\-i\*(C'\fR a gangbangin' file extension ta add:
.PP
.Vb 1
\&    perl \-pi.bak \-e \*(Aqs/Fred/Barney/\*(Aq inFile.txt
.Ve
.PP
To chizzle only tha fifth line, you can add a test checkin \f(CW$.\fR, the
input line number, then only big-ass up tha operation when tha test
passes:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/Fred/Barney/ if $. == 5\*(Aq inFile.txt
.Ve
.PP
To add lines before a cold-ass lil certain line, you can add a line (or lines!)
before Perl prints \f(CW$_\fR:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before third line\en" if $. == 3\*(Aq inFile.txt
.Ve
.PP
Yo ass can even add a line ta tha beginnin of a gangbangin' file, since tha current
line prints all up in tha end of tha loop:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqprint "Put before first line\en" if $. == 1\*(Aq inFile.txt
.Ve
.PP
To bang a line afta one already up in tha file, use tha \f(CW\*(C`\-n\*(C'\fR switch.
It aint nuthin but just like \f(CW\*(C`\-p\*(C'\fR except dat it don't print \f(CW$_\fR all up in tha end of
the loop, so you gotta do dat yo ass. In dis case, print \f(CW$_\fR
first, then print tha line dat you wanna add.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint; print "Put afta fifth line\en" if $. == 5\*(Aq inFile.txt
.Ve
.PP
To delete lines, only print tha ones dat you want.
.PP
.Vb 1
\&    perl \-ni \-e \*(Aqprint if /d/\*(Aq inFile.txt
.Ve
.SS "How tha fuck do I count tha number of lines up in a gangbangin' file?"
.IX Xref "file, countin lines lines line"
.IX Subsection "How tha fuck do I count tha number of lines up in a gangbangin' file?"
(contributed by brian d foy)
.PP
Conceptually, tha easiest way ta count tha lines up in a gangbangin' file is to
simply read dem n' count them:
.PP
.Vb 2
\&    mah $count = 0;
\&    while( <$fh> ) { $count++; }
.Ve
.PP
Yo ass don't straight-up gotta count dem yo ass, though, since Perl
already do dat wit tha \f(CW$.\fR variable, which is tha current line
number from tha last filehandle read:
.PP
.Vb 2
\&    1 while( <$fh> );
\&    mah $count = $.;
.Ve
.PP
If you wanna use \f(CW$.\fR, you can reduce it ta a simple one-liner,
like one of these:
.PP
.Vb 1
\&    % perl \-lne \*(Aq} print $.; {\*(Aq    file
\&
\&    % perl \-lne \*(AqEND { print $. }\*(Aq file
.Ve
.PP
Those can be rather inefficient though cause I gots dem finger-lickin' chickens wit tha siz-auce. If they aren't fast enough for
you, you might just read chunkz of data n' count tha number of
newlines:
.PP
.Vb 6
\&    mah $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or take a thugged-out dirtnap "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ tr/\en// );
\&    }
\&    close FILE;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat that don't work if tha line endin aint a newline. You
might chizzle dat \f(CW\*(C`tr///\*(C'\fR ta a \f(CW\*(C`s///\*(C'\fR so you can count tha number of
times tha input record separator, \f(CW$/\fR, shows up:
.PP
.Vb 6
\&    mah $lines = 0;
\&    open my($fh), \*(Aq<:raw\*(Aq, $filename or take a thugged-out dirtnap "Can\*(Aqt open $filename: $!";
\&    while( sysread $fh, $buffer, 4096 ) {
\&        $lines += ( $buffer =~ s|$/||g; );
\&    }
\&    close FILE;
.Ve
.PP
If you don't mind shellin out, tha \f(CW\*(C`wc\*(C'\fR command is probably the
fastest, even wit tha extra interprocess overhead. Y'all KNOW dat shit, muthafucka! Ensure dat you
have a untainted filename though:
.PP
.Vb 1
\&    #!perl \-T
\&
\&    $ENV{PATH} = undef;
\&
\&    mah $lines;
\&    if( $filename =~ /^([0\-9a\-z_.]+)\ez/ ) {
\&        $lines = \`/usr/bin/wc \-l $1\`
\&        chomp $lines;
\&    }
.Ve
.SS "How tha fuck do I delete tha last N lines from a gangbangin' file?"
.IX Xref "lines file"
.IX Subsection "How tha fuck do I delete tha last N lines from a gangbangin' file?"
(contributed by brian d foy)
.PP
Da easiest conceptual solution is ta count tha lines up in the
file then start all up in tha beginnin n' print tha number of lines
(minus tha last N) ta a freshly smoked up file.
.PP
Most often, tha real question is how tha fuck you can delete tha last N lines
without makin mo' than one pass over tha file, or how tha fuck ta do it
without a shitload of copying. Da easy as fuck  concept is tha hard realitizzle when
you might have millionz of lines up in yo' file.
.PP
One trick is ta use File::ReadBackwards, which starts all up in tha end of
the file. That module serves up a object dat wraps tha real filehandle
to make it easy as fuck  fo' you ta move round tha file. Once you git ta the
spot you need, you can git tha actual filehandle n' work wit it as
normal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In dis case, you git tha file posizzle all up in tha end of tha last
line you wanna keep n' truncate tha file ta dat point:
.PP
.Vb 1
\&    use File::ReadBackwards;
\&
\&    mah $filename = \*(Aqtest.txt\*(Aq;
\&    mah $Lines_to_truncate = 2;
\&
\&    mah $bw = File::ReadBackwards\->new( $filename )
\&        or take a thugged-out dirtnap "Could not read backwardz up in [$filename]: $!";
\&
\&    mah $lines_from_end = 0;
\&    until( $bw\->eof or $lines_from_end == $Lines_to_truncate ) {
\&        print "Got: ", $bw\->readline;
\&        $lines_from_end++;
\&    }
\&
\&    truncate( $filename, $bw\->tell );
.Ve
.PP
Da File::ReadBackwardz module also has tha advantage of setting
the input record separator ta a regular expression.
.PP
Yo ass can also use tha Tie::File module which lets you access
the lines all up in a tied array. Yo ass can use aiiight array operations
to modify yo' file, includin settin tha last index n' using
\&\f(CW\*(C`splice\*(C'\fR.
.ie n .SS "How tha fuck can I use Perlz ""\-i"" option from within a program?"
.el .SS "How tha fuck can I use Perlz \f(CW\-i\fP option from within a program?"
.IX Xref "-i in-place"
.IX Subsection "How tha fuck can I use Perlz -i option from within a program?"
\&\f(CW\*(C`\-i\*(C'\fR sets tha value of Perlz \f(CW$^I\fR variable, which up in turn affects
the behavior of \f(CW\*(C`<>\*(C'\fR; peep perlrun fo' mo' details. By
modifyin tha appropriate variablez directly, you can git tha same
behavior within a larger program. For example:
.PP
.Vb 10
\&    # ...
\&    {
\&        local($^I, @ARGV) = (\*(Aq.orig\*(Aq, glob("*.c"));
\&        while (<>) {
\&            if ($. == 1) {
\&                print "This line should step tha fuck up all up in tha top of each file\en";
\&            }
\&            s/\eb(p)earl\eb/${1}erl/i;        # Correct typos, preservin case
\&            print;
\&            close ARGV if eof;              # Reset $.
\&        }
\&    }
\&    # $^I n' @ARGV return ta they oldschool joints here
.Ve
.PP
This block modifies all tha \f(CW\*(C`.c\*(C'\fR filez up in tha current directory,
leavin a funky-ass backup of tha original gangsta data from each file up in a new
\&\f(CW\*(C`.c.orig\*(C'\fR file.
.SS "How tha fuck can I copy a gangbangin' file?"
.IX Xref "copy file, copy File::Copy"
.IX Subsection "How tha fuck can I copy a gangbangin' file?"
(contributed by brian d foy)
.PP
Use tha File::Copy module. Well shiiiit, it comes wit Perl n' can do a
true copy across file systems, n' it do its magic in
a portable fashion.
.PP
.Vb 1
\&    use File::Copy;
\&
\&    copy( $original, $new_copy ) or take a thugged-out dirtnap "Copy failed: $!";
.Ve
.PP
If you can't use File::Copy, you gonna gotta do tha work yo ass:
open tha original gangsta file, open tha destination file, then print
to tha destination file as you read tha original. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass also have to
remember ta copy tha permissions, baller, n' crew ta tha freshly smoked up file.
.SS "How tha fuck do I cook up a temporary file name?"
.IX Xref "file, temporary"
.IX Subsection "How tha fuck do I cook up a temporary file name?"
If you don't need ta know tha name of tha file, you can use \f(CW\*(C`open()\*(C'\fR
with \f(CW\*(C`undef\*(C'\fR up in place of tha file name. In Perl 5.8 or later, the
\&\f(CW\*(C`open()\*(C'\fR function creates a anonymous temporary file:
.PP
.Vb 1
\&    open mah $tmp, \*(Aq+>\*(Aq, undef or take a thugged-out dirtnap $!;
.Ve
.PP
Otherwise, you can use tha File::Temp module.
.PP
.Vb 1
\&    use File::Temp qw/ tempfile tempdir /;
\&
\&    mah $dir = tempdir( CLEANUP => 1 );
\&    ($fh, $filename) = tempfile( DIR => $dir );
\&
\&    # or if you don\*(Aqt need ta know tha filename
\&
\&    mah $fh = tempfile( DIR => $dir );
.Ve
.PP
Da File::Temp has been a standard module since Perl 5.6.1. If you
don't gotz a modern enough Perl installed, use tha \f(CW\*(C`new_tmpfile\*(C'\fR
class method from tha IO::File module ta git a gangbangin' filehandle opened for
readin n' writing. Use it if you don't need ta know tha filez name:
.PP
.Vb 3
\&    use IO::File;
\&    mah $fh = IO::File\->new_tmpfile()
\&        or take a thugged-out dirtnap "Unable ta make freshly smoked up temporary file: $!";
.Ve
.PP
If you committed ta bustin a temporary file by hand, use the
process \s-1ID\s0 and/or tha current time-value. If you need ta have many
temporary filez up in one process, bust a cold-ass lil counter:
.PP
.Vb 4
\&    BEGIN {
\&        use Fcntl;
\&        mah $temp_dir = \-d \*(Aq/tmp\*(Aq , biatch? \*(Aq/tmp\*(Aq : $ENV{TMPDIR} || $ENV{TEMP};
\&        mah $base_name = sprintf "%s/%d\-%d\-0000", $temp_dir, $$, time;
\&
\&        sub temp_file {
\&            mah $fh;
\&            mah $count = 0;
\&            until( defined(fileno($fh)) || $count++ > 100 ) {
\&                $base_name =~ s/\-(\ed+)$/"\-" . (1 + $1)/e;
\&                # O_EXCL is required fo' securitizzle reasons.
\&                sysopen $fh, $base_name, O_WRONLY|O_EXCL|O_CREAT;
\&            }
\&
\&            if( defined fileno($fh) ) {
\&                return ($fh, $base_name);
\&            }
\&            else {
\&                return ();
\&            }
\&        }
\&    }
.Ve
.SS "How tha fuck can I manipulate fixed-record-length files?"
.IX Xref "fixed-length file, fixed-length records"
.IX Subsection "How tha fuck can I manipulate fixed-record-length files?"
Da most efficient way is rockin \fIpack()\fR and
\&\fIunpack()\fR. This is fasta than using
\&\fIsubstr()\fR when takin many, nuff strings. Well shiiiit, it is
slower fo' just a gangbangin' few.
.PP
Here be a sample chunk of code ta break up n' put back together again
some fixed-format input lines, up in dis case from tha output of a normal,
Berkeley-style ps:
.PP
.Vb 10
\&    # sample input line:
\&    #   15158 p5  T      0:00 perl /home/tchrist/scripts/now\-what
\&    mah $PS_T = \*(AqA6 A4 A7 A5 A*\*(Aq;
\&    open mah $ps, \*(Aq\-|\*(Aq, \*(Aqps\*(Aq;
\&    print scalar <$ps>;
\&    mah @fieldz = qw( pid tt stat time command );
\&    while (<$ps>) {
\&        mah %process;
\&        @process{@fields} = unpack($PS_T, $_);
\&        fo' mah $field ( @fieldz ) {
\&            print "$field: <$process{$field}>\en";
\&        }
\&        print \*(Aqline=\*(Aq, pack($PS_T, @process{@fields} ), "\en";
\&    }
.Ve
.PP
We've used a hash slice up in order ta easily handle tha fieldz of each row.
Storin tha keys up in a array make it easy as fuck  ta operate on dem as a
group or loop over dem wit \f(CW\*(C`for\*(C'\fR. Well shiiiit, it also avoidz shittin' on tha program
with global variablez n' rockin symbolic references.
.SS "How tha fuck can I cook up a gangbangin' filehandle local ta a subroutine, biatch? How tha fuck do I pass filehandlez between subroutines, biatch? How tha fuck do I cook up a array of filehandles?"
.IX Xref "filehandle, local filehandle, passin filehandle, reference"
.IX Subsection "How tha fuck can I cook up a gangbangin' filehandle local ta a subroutine, biatch? How tha fuck do I pass filehandlez between subroutines, biatch? How tha fuck do I cook up a array of filehandles?"
Az of perl5.6, \fIopen()\fR autovivifies file n' directory handles
as references if you pass it a uninitialized scalar variable.
Yo ass can then pass these references just like any other scalar,
and use dem up in tha place of named handles.
.PP
.Vb 1
\&    open mah    $fh, $file_name;
\&
\&    open local $fh, $file_name;
\&
\&    print $fh "Wuz crackalackin' World!\en";
\&
\&    process_file( $fh );
.Ve
.PP
If you like, you can store these filehandlez up in a array or a hash.
If you access dem directly, they aren't simple scalars n' you
need ta give \f(CW\*(C`print\*(C'\fR a lil help by placin tha filehandle
reference up in braces. Perl can only figure it up on its own when
the filehandle reference be a simple scalar.
.PP
.Vb 1
\&    mah @fhs = ( $fh1, $fh2, $fh3 );
\&
\&    for( $i = 0; $i <= $#fhs; $i++ ) {
\&        print {$fhs[$i]} "just another Perl answer, \en";
\&    }
.Ve
.PP
Before perl5.6, you had ta deal wit various typeglob idioms
which you may peep up in olda code.
.PP
.Vb 3
\&    open FILE, "> $filename";
\&    process_typeglob(   *FILE );
\&    process_reference( \e*FILE );
\&
\&    sub process_typeglob  { local *FH = shift; print FH  "Typeglob!" }
\&    sub process_reference { local $fh = shift; print $fh "Reference!" }
.Ve
.PP
If you wanna create nuff anonymous handles, you should
check up tha Symbol or IO::Handle modules.
.SS "How tha fuck can I bust a gangbangin' filehandle indirectly?"
.IX Xref "filehandle, indirect"
.IX Subsection "How tha fuck can I bust a gangbangin' filehandle indirectly?"
An indirect filehandle is tha use of suttin' other than a symbol
in a place dat a gangbangin' filehandle is expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time yo. Here is ways
to git indirect filehandles:
.PP
.Vb 5
\&    $fh =   SOME_FH;       # bareword is strict\-subs hostile
\&    $fh =  "SOME_FH";      # strict\-refs hostile; same package only
\&    $fh =  *SOME_FH;       # typeglob
\&    $fh = \e*SOME_FH;       # ref ta typeglob (bless\-able)
\&    $fh =  *SOME_FH{IO};   # pimped IO::Handle from *SOME_FH typeglob
.Ve
.PP
Or, you can use tha \f(CW\*(C`new\*(C'\fR method from one of tha IO::* modulez to
create a anonymous filehandle n' store dat up in a scalar variable.
.PP
.Vb 2
\&    use IO::Handle;                     # 5.004 or higher
\&    mah $fh = IO::Handle\->new();
.Ve
.PP
Then use any of dem as you would a aiiight filehandle fo' realz. Anywhere that
Perl is expectin a gangbangin' filehandle, a indirect filehandle may be used
instead. Y'all KNOW dat shit, muthafucka! An indirect filehandle is just a scalar variable dat gotz nuff
a filehandle. Functions like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, or
the \f(CW\*(C`<FH>\*(C'\fR diamond operator will accept either a named filehandle
or a scalar variable containin one:
.PP
.Vb 4
\&    ($ifh, $ofh, $efh) = (*STDIN, *STDOUT, *STDERR);
\&    print $ofh "Type it: ";
\&    mah $got = <$ifh>
\&    print $efh "What was that: $got";
.Ve
.PP
If you passin a gangbangin' filehandle ta a gangbangin' function, you can write
the function up in two ways:
.PP
.Vb 4
\&    sub accept_fh {
\&        mah $fh = shift;
\&        print $fh "Sendin ta indirect filehandle\en";
\&    }
.Ve
.PP
Or it can localize a typeglob n' use tha filehandle directly:
.PP
.Vb 4
\&    sub accept_fh {
\&        local *FH = shift;
\&        print  FH "Sendin ta localized filehandle\en";
\&    }
.Ve
.PP
Both stylez work wit either objects or typeglobz of real filehandles.
(They might also work wit strings under some circumstances yo, but this
is risky.)
.PP
.Vb 2
\&    accept_fh(*STDOUT);
\&    accept_fh($handle);
.Ve
.PP
In tha examplez above, we assigned tha filehandle ta a scalar variable
before rockin dat shit. That is cuz only simple scalar variables, not
expressions or subscriptz of hashes or arrays, can be used with
built-ins like \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or tha diamond operator. Shiiit, dis aint no joke. Using
suttin' other than a simple scalar variable as a gangbangin' filehandle is
illegal n' won't even compile:
.PP
.Vb 4
\&    mah @fd = (*STDIN, *STDOUT, *STDERR);
\&    print $fd[1] "Type it: ";                           # WRONG
\&    mah $got = <$fd[0]>                                  # WRONG
\&    print $fd[2] "What was that: $got";                 # WRONG
.Ve
.PP
With \f(CW\*(C`print\*(C'\fR n' \f(CW\*(C`printf\*(C'\fR, you git round dis by rockin a funky-ass block and
an expression where you would place tha filehandle:
.PP
.Vb 3
\&    print  { $fd[1] } "funny stuff\en";
\&    printf { $fd[1] } "Pitizzle tha skanky %x.\en", 3_735_928_559;
\&    # Pitizzle tha skanky deadbeef.
.Ve
.PP
That block be a proper block like any other, so you can put more
fucked up code there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This sendz tha message up ta one of two places:
.PP
.Vb 3
\&    mah $ok = \-x "/bin/cat";
\&    print { $ok , biatch? $fd[1] : $fd[2] } "cat stat $ok\en";
\&    print { $fd[ 1+ ($ok || 0) ]  } "cat stat $ok\en";
.Ve
.PP
This approach of treatin \f(CW\*(C`print\*(C'\fR n' \f(CW\*(C`printf\*(C'\fR like object methods
calls don't work fo' tha diamond operator. Shiiit, dis aint no joke. Thatz cuz itz a
real operator, not just a gangbangin' function wit a cold-ass lil comma-less argument fo' realz. Assuming
you've been storin typeglobs up in yo' structure as our phat asses did above, you
can use tha built-in function named \f(CW\*(C`readline\*(C'\fR ta read a record just
as \f(CW\*(C`<>\*(C'\fR do. Given tha initialization shown above fo' \f(CW@fd\fR, this
would work yo, but only cuz \fIreadline()\fR requires a typeglob. Well shiiiit, it don't
work wit objects or strings, which might be a funky-ass bug we aint fixed yet.
.PP
.Vb 1
\&    $got = readline($fd[0]);
.Ve
.PP
Let it be noted dat tha flakinizz of indirect filehandlez is not
related ta whether they strings, typeglobs, objects, or anythang else.
It aint nuthin but tha syntax of tha fundamenstrual operators. Playin tha object
game don't help you at all here.
.SS "How tha fuck can I set up a gangbangin' foota format ta be used wit \fIwrite()\fP?"
.IX Xref "footer"
.IX Subsection "How tha fuck can I set up a gangbangin' foota format ta be used wit write()?"
Therez no builtin way ta do dis yo, but perlform has a cold-ass lil couple
steez ta make it possible fo' tha intrepid hacker.
.SS "How tha fuck can I \fIwrite()\fP tha fuck into a string?"
.IX Xref "write, tha fuck into a string"
.IX Subsection "How tha fuck can I write() tha fuck into a string?"
(contributed by brian d foy)
.PP
If you wanna \f(CW\*(C`write\*(C'\fR tha fuck into a string, you just gotta <open> a
filehandle ta a string, which Perl has been able ta do since Perl 5.6:
.PP
.Vb 2
\&    open FH, \*(Aq>\*(Aq, \emy $string;
\&    write( FH );
.Ve
.PP
Since you wanna be a phat programmer, you probably wanna bust a lexical
filehandle, even though formats is designed ta work wit bareword filehandles
since tha default format names take tha filehandle name. But fuck dat shiznit yo, tha word on tha street is dat you can
control dis wit some Perl special per-filehandle variables: \f(CW$^\fR, which
names tha top-of-page format, n' \f(CW$~\fR which shows tha line format. Yo ass have
to chizzle tha default filehandle ta set these variables:
.PP
.Vb 1
\&    open my($fh), \*(Aq>\*(Aq, \emy $string;
\&
\&    { # set per\-filehandle variables
\&        mah $old_fh = select( $fh );
\&        $~ = \*(AqANIMAL\*(Aq;
\&        $^ = \*(AqANIMAL_TOP\*(Aq;
\&        select( $old_fh );
\&    }
\&
\&    format ANIMAL_TOP =
\&     ID  Type    Name
\&    .
\&
\&    format ANIMAL =
\&    @##   @<<<    @<<<<<<<<<<<<<<
\&    $id,  $type,  $name
\&    .
.Ve
.PP
Although write can work wit lexical or package variables, whatever variables
you use gotta scope up in tha format. That most likely means you gonna want to
localize some package variables:
.PP
.Vb 4
\&    {
\&        local( $id, $type, $name ) = qw( 12 pussaaaaay Busta );
\&        write( $fh );
\&    }
\&
\&    print $string;
.Ve
.PP
There is also some tricks dat you can fuck wit \f(CW\*(C`formline\*(C'\fR n' the
accumulator variable \f(CW$^A\fR yo, but you lose a shitload of tha value of formats
since \f(CW\*(C`formline\*(C'\fR won't handle pagin n' so on. I aint talkin' bout chicken n' gravy biatch. Yo ass end up reimplementing
formats when you use em.
.SS "How tha fuck can I open a gangbangin' filehandle ta a string?"
.IX Xref "strin open IO::Strin filehandle"
.IX Subsection "How tha fuck can I open a gangbangin' filehandle ta a string?"
(contributed by Peta J yo. Holzer, hjp\-usenet2@hjp.at)
.PP
Since Perl 5.8.0 a gangbangin' file handle referrin ta a strang can be pimped by
callin open wit a reference ta dat strang instead of tha filename.
This file handle can then be used ta read from or write ta tha string:
.PP
.Vb 3
\&    open(my $fh, \*(Aq>\*(Aq, \e$string) or take a thugged-out dirtnap "Could not open strang fo' writing";
\&    print $fh "foo\en";
\&    print $fh "bar\en";    # $strin now gotz nuff "foo\enbar\en"
\&
\&    open(my $fh, \*(Aq<\*(Aq, \e$string) or take a thugged-out dirtnap "Could not open strang fo' reading";
\&    mah $x = <$fh>;    # $x now gotz nuff "foo\en"
.Ve
.PP
With olda versionz of Perl, tha IO::Strin module serves up similar
functionality.
.SS "How tha fuck can I output mah numbers wit commas added?"
.IX Xref "number, commify"
.IX Subsection "How tha fuck can I output mah numbers wit commas added?"
(contributed by brian d foy n' Benjamin Goldberg)
.PP
Yo ass can use Number::Format ta separate places up in a number.
It handlez locale shiznit fo' all y'all whoz ass wanna insert
full stops instead (or anythang else dat they wanna use,
really).
.PP
This subroutine will add commas ta yo' number:
.PP
.Vb 5
\&    sub commify {
\&        local $_  = shift;
\&        1 while s/^([\-+]?\ed+)(\ed{3})/$1,$2/;
\&        return $_;
\&    }
.Ve
.PP
This regex from Benjamin Goldberg will add commas ta numbers:
.PP
.Vb 1
\&    s/(^[\-+]?\ed+?(?=(?>(?:\ed{3})+)(?!\ed))|\eG\ed{3}(?=\ed))/$1,/g;
.Ve
.PP
It be easier ta peep wit comments:
.PP
.Vb 11
\&    s/(
\&        ^[\-+], biatch?             # beginnin of number.
\&        \ed+, biatch?               # first digits before first comma
\&        (?=                # followed by, (but not included up in tha match) :
\&            (?>(?:\ed{3})+) # some positizzle multiple of three digits.
\&            (?!\ed)         # a *exact* multiple, not x * 3 + 1 or whatever.
\&        )
\&        |                  # or:
\&        \eG\ed{3}            # afta tha last group, git three digits
\&        (?=\ed)             # but they gotta have mo' digits afta em.
\&    )/$1,/xg;
.Ve
.SS "How tha fuck can I translate tildes (~) up in a gangbangin' filename?"
.IX Xref "tilde tilde expansion"
.IX Subsection "How tha fuck can I translate tildes (~) up in a gangbangin' filename?"
Use tha <> (\f(CW\*(C`glob()\*(C'\fR) operator, documented up in perlfunc.
Versionz of Perl olda than 5.6 require dat you gotz a gangbangin' finger-lickin' dirty-ass shell
installed dat groks tildes. Lata versionz of Perl have dis feature
built in. I aint talkin' bout chicken n' gravy biatch. Da File::KGlob module (available from \s-1CPAN\s0) gives more
portable glob functionality.
.PP
Within Perl, you may use dis directly:
.PP
.Vb 11
\&    $filename =~ s{
\&      ^ ~             # find a leadin tilde
\&      (               # save dis up in $1
\&          [^/]        # a non\-slash character
\&                *     # repeated 0 or mo' times (0 means me)
\&      )
\&    }{
\&      $1
\&          , biatch? (getpwnam($1))[7]
\&          : ( $ENV{HOME} || $ENV{LOGDIR} )
\&    }ex;
.Ve
.SS "How tha fuck come when I open a gangbangin' file read-write it wipes it out?"
.IX Xref "clobber read-write clobberin truncate truncating"
.IX Subsection "How tha fuck come when I open a gangbangin' file read-write it wipes it out?"
Because you rockin suttin' like this, which truncates tha file
\&\fIthen\fR gives you read-write access:
.PP
.Vb 1
\&    open mah $fh, \*(Aq+>\*(Aq, \*(Aq/path/name\*(Aq; # WRONG (almost always)
.Ve
.PP
Whoops. Yo ass should instead use this, which will fail if tha file
doesn't exist:
.PP
.Vb 1
\&    open mah $fh, \*(Aq+<\*(Aq, \*(Aq/path/name\*(Aq; # open fo' update
.Ve
.PP
Usin \*(L">\*(R" always clobbers or creates. Usin \*(L"<\*(R" never do
either n' shit. Da \*(L"+\*(R" don't chizzle all dis bullshit.
.PP
Here is examplez of nuff kindz of file opens. Those rockin \f(CW\*(C`sysopen\*(C'\fR
all assume dat you've pulled up in tha constants from Fcntl:
.PP
.Vb 1
\&    use Fcntl;
.Ve
.PP
To open file fo' reading:
.PP
.Vb 2
\&    open mah $fh, \*(Aq<\*(Aq, $path                               or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_RDONLY                       or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' writing, create freshly smoked up file if needed or else truncate oldschool file:
.PP
.Vb 3
\&    open mah $fh, \*(Aq>\*(Aq, $path                               or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_WRONLY|O_TRUNC|O_CREAT       or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_WRONLY|O_TRUNC|O_CREAT, 0666 or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' writing, create freshly smoked up file, file must not exist:
.PP
.Vb 2
\&    sysopen mah $fh, $path, O_WRONLY|O_EXCL|O_CREAT        or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_WRONLY|O_EXCL|O_CREAT, 0666  or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' appending, create if necessary:
.PP
.Vb 3
\&    open mah $fh, \*(Aq>>\*(Aq $path                               or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_WRONLY|O_APPEND|O_CREAT      or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_WRONLY|O_APPEND|O_CREAT, 0666 or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' appending, file must exist:
.PP
.Vb 1
\&    sysopen mah $fh, $path, O_WRONLY|O_APPEND              or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' update, file must exist:
.PP
.Vb 2
\&    open mah $fh, \*(Aq+<\*(Aq, $path                              or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_RDWR                         or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' update, create file if necessary:
.PP
.Vb 2
\&    sysopen mah $fh, $path, O_RDWR|O_CREAT                 or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_RDWR|O_CREAT, 0666           or take a thugged-out dirtnap $!;
.Ve
.PP
To open file fo' update, file must not exist:
.PP
.Vb 2
\&    sysopen mah $fh, $path, O_RDWR|O_EXCL|O_CREAT          or take a thugged-out dirtnap $!;
\&    sysopen mah $fh, $path, O_RDWR|O_EXCL|O_CREAT, 0666    or take a thugged-out dirtnap $!;
.Ve
.PP
To open a gangbangin' file without blocking, bustin if necessary:
.PP
.Vb 2
\&    sysopen mah $fh, \*(Aq/foo/somefile\*(Aq, O_WRONLY|O_NDELAY|O_CREAT
\&        or take a thugged-out dirtnap "can\*(Aqt open /foo/somefile: $!":
.Ve
.PP
Be warned dat neither creation nor deletion of filez is guaranteed to
be a atomic operation over \s-1NFS.\s0 That is, two processes might both
successfully create or unlink tha same file biaaatch! Therefore O_EXCL
aint as exclusive as you might wish.
.PP
See also perlopentut.
.ie n .SS "Why do I sometimes git a ""Argument list too long"" when I use <*>?"
.el .SS "Why do I sometimes git a ``Argument list too long'' when I use <*>?"
.IX Xref "argument list too long"
.IX Subsection "Why do I sometimes git a Argument list too long when I use <*>?"
Da \f(CW\*(C`<>\*(C'\fR operator performs a globbin operation (see above).
In Perl versions earlier than v5.6.0, tha internal \fIglob()\fR operator forks
\&\fIcsh\fR\|(1) ta do tha actual glob expansion yo, but
csh can't handle mo' than 127 shit n' so gives tha error message
\&\f(CW\*(C`Argument list too long\*(C'\fR. Muthafuckas whoz ass installed tcsh as csh won't
have dis problem yo, but they playas may be surprised by dat shit.
.PP
To git round this, either upgrade ta Perl v5.6.0 or later, do tha glob
yo ass wit \fIreaddir()\fR n' patterns, or bust a module like File::Glob,
one dat don't use tha shell ta do globbing.
.ie n .SS "How tha fuck can I open a gangbangin' file wit a leadin "">"" or trailin blanks?"
.el .SS "How tha fuck can I open a gangbangin' file wit a leadin ``>'' or trailin blanks?"
.IX Xref "filename, special characters"
.IX Subsection "How tha fuck can I open a gangbangin' file wit a leadin > or trailin blanks?"
(contributed by Brian McCauley)
.PP
Da special two-argument form of Perlz \fIopen()\fR function ignores
trailin blanks up in filenames n' infers tha mode from certain leading
charactas (or a trailin \*(L"|\*(R"). In olda versionz of Perl dis was the
only version of \fIopen()\fR n' so it is prevalent up in oldschool code n' books.
.PP
Unless you gotz a particular reason ta use tha two-argument form you
should use tha three-argument form of \fIopen()\fR which do not treat any
charactas up in tha filename as special.
.PP
.Vb 2
\&    open mah $fh, "<", "  file  ";  # filename is "   file   "
\&    open mah $fh, ">", ">file";     # filename is ">file"
.Ve
.SS "How tha fuck can I reliably rename a gangbangin' file?"
.IX Xref "rename mv move file, rename"
.IX Subsection "How tha fuck can I reliably rename a gangbangin' file?"
If yo' operatin system supports a proper \fImv\fR\|(1) utilitizzle or its
functionizzle equivalent, dis works:
.PP
.Vb 1
\&    rename($old, $new) or system("mv", $old, $new);
.Ve
.PP
It may be mo' portable ta use tha File::Copy module instead.
Yo ass just copy ta tha freshly smoked up file ta tha freshly smoked up name (checkin return
values), then delete tha oldschool one. This aint straight-up tha same
semantically as a \f(CW\*(C`rename()\*(C'\fR, which preserves meta-information like
permissions, timestamps, inode info, etc.
.SS "How tha fuck can I lock a gangbangin' file?"
.IX Xref "lock file, lock flock"
.IX Subsection "How tha fuck can I lock a gangbangin' file?"
Perlz builtin \fIflock()\fR function (see perlfunc fo' details) will call
\&\fIflock\fR\|(2) if dat exists, \fIfcntl\fR\|(2) if it don't (on perl version 5.004 and
later), n' \fIlockf\fR\|(3) if neither of tha two previous system calls exists.
On some systems, it may even bust a gangbangin' finger-lickin' different form of natizzle locking.
Here is some gotchas wit Perlz \fIflock()\fR:
.IP "1." 4
Produces a gangbangin' fatal error if none of tha three system calls (or their
close equivalent) exists.
.IP "2." 4
\&\fIlockf\fR\|(3) do not provide shared locking, n' requires dat the
filehandle be open fo' freestylin (or appending, or read/writing).
.IP "3." 4
Some versionz of \fIflock()\fR can't lock filez over a network (e.g. on \s-1NFS\s0 file
systems), so you'd need ta force tha use of \fIfcntl\fR\|(2) when you build Perl.
But even dis is dubious at best. Right back up in yo muthafuckin ass. See tha flock entry of perlfunc
and tha \fI\s-1INSTALL\s0\fR file up in tha source distribution fo' shiznit on
buildin Perl ta do all dis bullshit.
.Sp
Two potentially non-obvious but traditionizzle flock semantics is that
it waits indefinitely until tha lock is granted, n' dat its locks are
\&\fImerely advisory\fR. Right back up in yo muthafuckin ass. Such discretionary locks is mo' flexible yo, but
offer fewer guarantees. This means dat filez locked wit \fIflock()\fR may
be modified by programs dat do not also use \fIflock()\fR. Whips dat stop
for red lights git on well wit each other yo, but not wit rides dat don't
stop fo' red lights, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See tha perlport manpage, yo' portz specific
documentation, or yo' system-specific local manpages fo' details. It's
best ta assume traditionizzle behavior if you freestylin portable programs.
(If you not, you should as always feel perfectly free ta write
for yo' own systemz idiosyncrasies (sometimes called \*(L"features\*(R").
Slavish adherence ta portabilitizzle concerns shouldn't git up in tha way of
your gettin yo' thang done.)
.Sp
For mo' shiznit on file locking, peep also
\&\*(L"File Locking\*(R" up in perlopentut if you have it (new fo' 5.6).
.ie n .SS "Why can't I just open(\s-1FH, ""\s0>file.lock"")?"
.el .SS "Why can't I just open(\s-1FH, ``\s0>file.lock'')?"
.IX Xref "lock, lockfile race condition"
.IX Subsection "Why can't I just open(FH, >file.lock)?"
A common bit of code \fB\s-1NOT TO USE\s0\fR is this:
.PP
.Vb 2
\&    chill(3) while \-e \*(Aqfile.lock\*(Aq;    # PLEASE DO NOT USE
\&    open mah $lock, \*(Aq>\*(Aq, \*(Aqfile.lock\*(Aq; # THIS BROKEN CODE
.Ve
.PP
This be a cold-ass lil funky-ass race condition: you take two steps ta do something
which must be done up in one. Thatz why computa hardware serves up an
atomic test-and-set instruction. I aint talkin' bout chicken n' gravy biatch. In theory, dis \*(L"ought\*(R" ta work:
.PP
.Vb 2
\&    sysopen mah $fh, "file.lock", O_WRONLY|O_EXCL|O_CREAT
\&        or take a thugged-out dirtnap "can\*(Aqt open  file.lock: $!";
.Ve
.PP
except dat lamentably, file creation (and deletion) aint atomic
over \s-1NFS,\s0 so dis won't work (at least, not every last muthafuckin time) over tha net. Put yo muthafuckin choppers up if ya feel this!
Various schemes involvin \fIlink()\fR done been suggested yo, but
these tend ta involve busy-wait, which be also less than desirable.
.SS "I still don't git locking. I just wanna increment tha number up in tha file yo. How tha fuck can I do this?"
.IX Xref "counta file, counter"
.IX Subsection "I still don't git locking. I just wanna increment tha number up in tha file yo. How tha fuck can I do this?"
Didn't mah playas eva rap  web-page hit countas was useless?
They don't count number of hits, they a waste of time, n' they serve
only ta stroke tha writerz vanity. It aint nuthin but betta ta pick a random number;
they mo' realistic.
.PP
Anyway, dis is what tha fuck you can do if you can't help yo ass.
.PP
.Vb 8
\&    use Fcntl qw(:DEFAULT :flock);
\&    sysopen mah $fh, "numfile", O_RDWR|O_CREAT or take a thugged-out dirtnap "can\*(Aqt open numfile: $!";
\&    flock $fh, LOCK_EX                        or take a thugged-out dirtnap "can\*(Aqt flock numfile: $!";
\&    mah $num = <$fh> || 0;
\&    seek $fh, 0, 0                            or take a thugged-out dirtnap "can\*(Aqt rewind numfile: $!";
\&    truncate $fh, 0                           or take a thugged-out dirtnap "can\*(Aqt truncate numfile: $!";
\&    (print $fh $num+1, "\en")                  or take a thugged-out dirtnap "can\*(Aqt write numfile: $!";
\&    close $fh                                 or take a thugged-out dirtnap "can\*(Aqt close numfile: $!";
.Ve
.PP
Herez a much betta web-page hit counter:
.PP
.Vb 1
\&    $hits = int( (time() \- 850_000_000) / rand(1_000) );
.Ve
.PP
If tha count don't impress yo' playas, then tha code might. :\-)
.SS "All I wanna do be append a lil' small-ass amount of text ta tha end of a gangbangin' file. Do I still gotta use locking?"
.IX Xref "append file, append"
.IX Subsection "All I wanna do be append a lil' small-ass amount of text ta tha end of a gangbangin' file. Do I still gotta use locking?"
If yo ass is on a system dat erectly implements \f(CW\*(C`flock\*(C'\fR n' you use
the example appendin code from \*(L"perldoc \-f flock\*(R" every last muthafuckin thang will be
\&\s-1OK\s0 even if tha \s-1OS\s0 yo ass is on don't implement append mode erectly
(if such a system exists). Right back up in yo muthafuckin ass. So if yo ass be aiiight ta restrict yo ass to
OSs dat implement \f(CW\*(C`flock\*(C'\fR (and thatz not straight-up much of a
restriction) then dat is what tha fuck you should do.
.PP
If you know yo ass is only goin ta bust a system dat do erectly
implement appendin (i.e. not Win32) then you can omit tha \f(CW\*(C`seek\*(C'\fR
from tha code up in tha previous answer.
.PP
If you know yo ass is only freestylin code ta run on a \s-1OS\s0 n' filesystem
that do implement append mode erectly (a local filesystem on a
modern Unix fo' example), n' you keep tha file up in block-buffered mode
and you write less than one buffer-full of output between each manual
flushin of tha buffer then each bufferload be almost guaranteed ta be
written ta tha end of tha file up in one chunk without getting
intermingled wit any suckasz output. Yo ass can also use the
\&\f(CW\*(C`syswrite\*(C'\fR function which is simply a wrapper round yo' system's
\&\f(CWwrite(2)\fR system call.
.PP
There is still a lil' small-ass theoretical chizzle dat a signal will interrupt
the system-level \f(CW\*(C`write()\*(C'\fR operation before completion. I aint talkin' bout chicken n' gravy biatch. There be also
a possibilitizzle dat some \s-1STDIO\s0 implementations may call multiple system
level \f(CW\*(C`write()\*(C'\fRs even if tha buffer was empty ta start. There may be
some systems where dis probabilitizzle is reduced ta zero, n' dis is
not a cold-ass lil concern when rockin \f(CW\*(C`:perlio\*(C'\fR instead of yo' systemz \s-1STDIO.\s0
.SS "How tha fuck do I randomly update a funky-ass binary file?"
.IX Xref "file, binary patch"
.IX Subsection "How tha fuck do I randomly update a funky-ass binary file?"
If you just tryin ta patch a funky-ass binary, up in nuff cases suttin' as
simple as dis works:
.PP
.Vb 1
\&    perl \-i \-pe \*(Aqs{window manager}{window mangler}g\*(Aq /usr/bin/emacs
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat if you have fixed sized records, then you might do suttin' more
like this:
.PP
.Vb 9
\&    mah $RECSIZE = 220; # size of record, up in bytes
\&    mah $recno   = 37;  # which record ta update
\&    open mah $fh, \*(Aq+<\*(Aq, \*(Aqsomewhere\*(Aq or take a thugged-out dirtnap "can\*(Aqt update somewhere: $!";
\&    seek $fh, $recno * $RECSIZE, 0;
\&    read $fh, $record, $RECSIZE == $RECSIZE or take a thugged-out dirtnap "can\*(Aqt read record $recno: $!";
\&    # munge tha record
\&    seek $fh, \-$RECSIZE, 1;
\&    print $fh $record;
\&    close $fh;
.Ve
.PP
Lockin n' error checkin is left as a exercise fo' tha reader.
Don't forget dem or you gonna be like sorry bout dat bullshit.
.SS "How tha fuck do I git a gangbangin' filez timestamp up in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How tha fuck do I git a gangbangin' filez timestamp up in perl?"
If you wanna retrieve tha time at which tha file was last read,
written, or had its meta-data (baller, etc) chizzled, you use tha \fB\-A\fR,
\&\fB\-M\fR, or \fB\-C\fR file test operations as documented up in perlfunc.
These retrieve tha age of tha file (measured against tha start-time of
your program) up in minutes as a gangbangin' floatin point number n' shit. Right back up in yo muthafuckin ass. Some platforms may
not have all of these times. Right back up in yo muthafuckin ass. See perlport fo' details. To retrieve
the \*(L"raw\*(R" time up in secondz since tha epoch, you would call tha stat
function, then use \f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`gmtime()\*(C'\fR, or
\&\f(CW\*(C`POSIX::strftime()\*(C'\fR ta convert dis tha fuck into human-readable form.
.PP
Herez a example:
.PP
.Vb 3
\&    mah $write_secs = (stat($file))[9];
\&    printf "file %s updated at %s\en", $file,
\&        scalar localtime($write_secs);
.Ve
.PP
If you prefer suttin' mo' legible, use tha File::stat module
(part of tha standard distribution up in version 5.004 n' later):
.PP
.Vb 5
\&    # error checkin left as a exercise fo' reader.
\&    use File::stat;
\&    use Time::localtime;
\&    mah $date_strin = ctime(stat($file)\->mtime);
\&    print "file $file updated at $date_string\en";
.Ve
.PP
Da \fIPOSIX::strftime()\fR approach has tha benefit of being,
in theory, independent of tha current locale. Right back up in yo muthafuckin ass. See perllocale
for details.
.SS "How tha fuck do I set a gangbangin' filez timestamp up in perl?"
.IX Xref "timestamp file, timestamp"
.IX Subsection "How tha fuck do I set a gangbangin' filez timestamp up in perl?"
Yo ass use tha \fIutime()\fR function documented up in \*(L"utime\*(R" up in perlfunc.
By way of example, herez a lil program dat copies the
read n' write times from its first argument ta all tha rest
of em.
.PP
.Vb 6
\&    if (@ARGV < 2) {
\&        take a thugged-out dirtnap "usage: cptimes timestamp_file other_filez ...\en";
\&    }
\&    mah $timestamp = shift;
\&    my($atime, $mtime) = (stat($timestamp))[8,9];
\&    utime $atime, $mtime, @ARGV;
.Ve
.PP
Error checkin is, as usual, left as a exercise fo' tha reader.
.PP
Da perldoc fo' utime also has a example dat has tha same
effect as \fItouch\fR\|(1) on filez dat \fIalready exist\fR.
.PP
Certain file systems gotz a limited mobilitizzle ta store tha times
on a gangbangin' file all up in tha expected level of precision. I aint talkin' bout chicken n' gravy biatch. For example, the
\&\s-1FAT\s0 n' \s-1HPFS\s0 filesystem is unable ta create dates on filez with
a finer granularitizzle than two seconds. This be a limitation of
the filesystems, not of \fIutime()\fR.
.SS "How tha fuck do I print ta mo' than one file at once?"
.IX Xref "print, ta multiple files"
.IX Subsection "How tha fuck do I print ta mo' than one file at once?"
To connect one filehandle ta nuff muthafuckin output filehandles,
you can use tha IO::Tee or Tie::FileHandle::Multiplex modules.
.PP
If you only gotta do dis once, you can print individually
to each filehandle.
.PP
.Vb 1
\&    fo' mah $fh ($fh1, $fh2, $fh3) { print $fh "whatever\en" }
.Ve
.SS "How tha fuck can I read up in a entire file all at once?"
.IX Xref "slurp file, slurping"
.IX Subsection "How tha fuck can I read up in a entire file all at once?"
Da customary Perl approach fo' processin all tha lines up in a gangbangin' file is to
do so one line at a time:
.PP
.Vb 6
\&    open mah $input, \*(Aq<\*(Aq, $file or take a thugged-out dirtnap "can\*(Aqt open $file: $!";
\&    while (<$input>) {
\&        chomp;
\&        # do suttin' wit $_
\&    }
\&    close $input or take a thugged-out dirtnap "can\*(Aqt close $file: $!";
.Ve
.PP
This is tremendously mo' efficient than readin tha entire file into
memory as a array of lines n' then processin it one element at a time,
which is often\*(--if not almost always\*(--the wack approach. Whenever
you peep one of mah thugs do this:
.PP
.Vb 1
\&    mah @lines = <INPUT>;
.Ve
.PP
Yo ass should be thinkin long n' hard bout why you need every last muthafuckin thang loaded at
once. It aint nuthin but just not a scalable solution.
.PP
If you \*(L"mmap\*(R" tha file wit tha File::Map module from
\&\s-1CPAN,\s0 you can virtually load tha entire file tha fuck into a
strin without straight-up storin it up in memory:
.PP
.Vb 1
\&    use File::Map qw(map_file);
\&
\&    map_file mah $string, $filename;
.Ve
.PP
Once mapped, you can treat \f(CW$string\fR as you would any other string.
Since you don't necessarily gotta load tha data, mmap-in can be
very fast n' may not increase yo' memory footprint.
.PP
Yo ass might also find it more
fun ta use tha standard Tie::File module, or tha DB_File module's
\&\f(CW$DB_RECNO\fR bindings, which allow you ta tie a array ta a gangbangin' file so that
accessin a element of tha array straight-up accesses tha corresponding
line up in tha file.
.PP
If you wanna load tha entire file, you can use tha File::Slurp
module ta do it up in one one simple n' efficient step:
.PP
.Vb 1
\&    use File::Slurp;
\&
\&    mah $all_of_it = read_file($filename); # entire file up in scalar
\&    mah @all_lines = read_file($filename); # one line per element
.Ve
.PP
Or you can read tha entire file contents tha fuck into a scalar like this:
.PP
.Vb 6
\&    mah $var;
\&    {
\&        local $/;
\&        open mah $fh, \*(Aq<\*(Aq, $file or take a thugged-out dirtnap "can\*(Aqt open $file: $!";
\&        $var = <$fh>;
\&    }
.Ve
.PP
That temporarily undefs yo' record separator, n' will automatically
close tha file at block exit. If tha file be already open, just use this:
.PP
.Vb 1
\&    mah $var = do { local $/; <$fh> };
.Ve
.PP
Yo ass can also bust a localized \f(CW@ARGV\fR ta eliminizzle tha \f(CW\*(C`open\*(C'\fR:
.PP
.Vb 1
\&    mah $var = do { local( @ARGV, $/ ) = $file; <> };
.Ve
.PP
For ordinary filez you can also use tha \f(CW\*(C`read\*(C'\fR function.
.PP
.Vb 1
\&    read( $fh, $var, \-s $fh );
.Ve
.PP
That third argument tests tha byte size of tha data on tha \f(CW$fh\fR filehandle
and readz dat nuff bytes tha fuck into tha buffer \f(CW$var\fR.
.SS "How tha fuck can I read up in a gangbangin' file by paragraphs?"
.IX Xref "file, readin by paragraphs"
.IX Subsection "How tha fuck can I read up in a gangbangin' file by paragraphs?"
Use tha \f(CW$/\fR variable (see perlvar fo' details). Yo ass can either
set it ta \f(CW""\fR ta eliminizzle empty paragraphs (\f(CW"abc\en\en\en\endef"\fR,
for instance, gets treated as two paragraphs n' not three), or
\&\f(CW"\en\en"\fR ta accept empty paragraphs.
.PP
Note dat a funky-ass blank line must have no blanks up in dat shit. Thus
\&\f(CW"fred\en\ \enstuff\en\en"\fR is one paragraph yo, but \f(CW"fred\en\enstuff\en\en"\fR is two.
.SS "How tha fuck can I read a single characta from a gangbangin' file, biatch? From tha keyboard?"
.IX Xref "getc file, readin one characta at a time"
.IX Subsection "How tha fuck can I read a single characta from a gangbangin' file, biatch? From tha keyboard?"
Yo ass can use tha builtin \f(CW\*(C`getc()\*(C'\fR function fo' most filehandlez yo, but
it won't (easily) work on a terminal device. For \s-1STDIN,\s0 either use
the Term::ReadKey module from \s-1CPAN\s0 or use tha sample code in
\&\*(L"getc\*(R" up in perlfunc.
.PP
If yo' system supports tha portable operatin system programming
interface (\s-1POSIX\s0), you can use tha followin code, which you gonna note
turns off echo processin as well.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    $| = 1;
\&    fo' (1..4) {
\&        print "gimme: ";
\&        mah $got = getone();
\&        print "\-\-> $got\en";
\&    }
\&    exit;
\&
\&    BEGIN {
\&        use POSIX qw(:termios_h);
\&
\&        mah ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&        mah $fd_stdin = fileno(STDIN);
\&
\&        $term     = POSIX::Termios\->new();
\&        $term\->getattr($fd_stdin);
\&        $oterm     = $term\->getlflag();
\&
\&        $echo     = ECHO | ECHOK | ICANON;
\&        $noecho   = $oterm & ~$echo;
\&
\&        sub cbreak {
\&            $term\->setlflag($noecho);
\&            $term\->setcc(VTIME, 1);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub cooked {
\&            $term\->setlflag($oterm);
\&            $term\->setcc(VTIME, 0);
\&            $term\->setattr($fd_stdin, TCSANOW);
\&        }
\&
\&        sub getone {
\&            mah $key = \*(Aq\*(Aq;
\&            cbreak();
\&            sysread(STDIN, $key, 1);
\&            cooked();
\&            return $key;
\&        }
\&    }
\&
\&    END { cooked() }
.Ve
.PP
Da Term::ReadKey module from \s-1CPAN\s0 may be easier ta use. Recent versions
include also support fo' non-portable systems as well.
.PP
.Vb 8
\&    use Term::ReadKey;
\&    open mah $tty, \*(Aq<\*(Aq, \*(Aq/dev/tty\*(Aq;
\&    print "Gimme a cold-ass lil char: ";
\&    ReadMode "raw";
\&    mah $key = ReadKey 0, $tty;
\&    ReadMode "normal";
\&    printf "\enYo ass holla'd %s, char number %03d\en",
\&        $key, ord $key;
.Ve
.SS "How tha fuck can I tell whether there be a a cold-ass lil characta waitin on a gangbangin' filehandle?"
.IX Subsection "How tha fuck can I tell whether there be a a cold-ass lil characta waitin on a gangbangin' filehandle?"
Da straight-up first thang you should do is look tha fuck into gettin tha Term::ReadKey
extension from \s-1CPAN.\s0 As we mentioned earlier, it now even has limited
support fo' non-portable (read: not open systems, closed, proprietary,
not \s-1POSIX,\s0 not Unix, etc.) systems.
.PP
Yo ass should also check up tha Frequently Axed Thangs list in
comp.unix.* fo' thangs like this: tha answer is essentially tha same.
It aint nuthin but straight-up system-dependent yo. Herez one solution dat works on \s-1BSD\s0
systems:
.PP
.Vb 5
\&    sub key_ready {
\&        my($rin, $nfd);
\&        vec($rin, fileno(STDIN), 1) = 1;
\&        return $nfd = select($rin,undef,undef,0);
\&    }
.Ve
.PP
If you wanna smoke up how tha fuck nuff charactas is waiting, there's
also tha \s-1FIONREAD\s0 ioctl call ta be looked at. Da \fIh2ph\fR tool that
comes wit Perl tries ta convert C include filez ta Perl code, which
can be \f(CW\*(C`require\*(C'\fRd. Y'all KNOW dat shit, muthafucka! \s-1FIONREAD\s0 endz up defined as a gangbangin' function up in the
\&\fIsys/ioctl.ph\fR file:
.PP
.Vb 1
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, FIONREAD(), $size)    or take a thugged-out dirtnap "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
If \fIh2ph\fR wasn't installed or don't work fo' you, you can
\&\fIgrep\fR tha include filez by hand:
.PP
.Vb 2
\&    % grep FIONREAD /usr/include/*/*
\&    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B
.Ve
.PP
Or write a lil' small-ass C program rockin tha editor of champions:
.PP
.Vb 9
\&    % pussaaaaay > fionread.c
\&    #include <sys/ioctl.h>
\&    main() {
\&        printf("%#08x\en", FIONREAD);
\&    }
\&    ^D
\&    % cc \-o fionread fionread.c
\&    % ./fionread
\&    0x4004667f
.Ve
.PP
And then hard-code it, leavin portin as a exercise ta yo' successor.
.PP
.Vb 1
\&    $FIONREAD = 0x4004667f;         # XXX: opsys dependent
\&
\&    $size = pack("L", 0);
\&    ioctl(FH, $FIONREAD, $size)     or take a thugged-out dirtnap "Couldn\*(Aqt call ioctl: $!\en";
\&    $size = unpack("L", $size);
.Ve
.PP
\&\s-1FIONREAD\s0 requires a gangbangin' filehandle connected ta a stream, meanin dat sockets,
pipes, n' tty devices work yo, but \fInot\fR files.
.ie n .SS "How tha fuck do I do a ""tail \-f"" up in perl?"
.el .SS "How tha fuck do I do a \f(CWtail \-f\fP up in perl?"
.IX Xref "tail IO::Handle File::Tail clearerr"
.IX Subsection "How tha fuck do I do a tail -f up in perl?"
First try
.PP
.Vb 1
\&    seek($gw_fh, 0, 1);
.Ve
.PP
Da statement \f(CW\*(C`seek($gw_fh, 0, 1)\*(C'\fR don't chizzle tha current position,
but it do clear tha end-of-file condizzle on tha handle, so dat the
next \f(CW\*(C`<$gw_fh>\*(C'\fR make Perl try again n' again n' again ta read something.
.PP
If dat don't work (it relies on featurez of yo' stdio implementation),
then you need suttin' mo' like this:
.PP
.Vb 7
\&    fo' (;;) {
\&      fo' ($curpos = tell($gw_fh); <$gw_fh>; $curpos =tell($gw_fh)) {
\&        # search fo' some shiznit n' put it tha fuck into files
\&      }
\&      # chill fo' a while
\&      seek($gw_fh, $curpos, 0);  # seek ta where our crazy asses had been
\&    }
.Ve
.PP
If dis still don't work, look tha fuck into tha \f(CW\*(C`clearerr\*(C'\fR method
from IO::Handle, which resets tha error n' end-of-file states
on tha handle.
.PP
Therez also a File::Tail module from \s-1CPAN.\s0
.SS "How tha fuck do I \fIdup()\fP a gangbangin' filehandle up in Perl?"
.IX Xref "dup"
.IX Subsection "How tha fuck do I dup() a gangbangin' filehandle up in Perl?"
If you check \*(L"open\*(R" up in perlfunc, you gonna peep dat nuff muthafuckin of tha ways
to call \fIopen()\fR should do tha trick. For example:
.PP
.Vb 2
\&    open mah $log, \*(Aq>>\*(Aq, \*(Aq/foo/logfile\*(Aq;
\&    open STDERR, \*(Aq>&\*(Aq, $log;
.Ve
.PP
Or even wit a literal numeric descriptor:
.PP
.Vb 2
\&    mah $fd = $ENV{MHCONTEXTFD};
\&    open $mhcontext, "<&=$fd";  # like fdopen(3S)
.Ve
.PP
Note dat \*(L"<&STDIN\*(R" cook up a cold-ass lil copy yo, but \*(L"<&=STDIN\*(R" makes
an alias. That means if you close a aliased handle, all
aliases become inaccessible. This aint legit with
a copied one.
.PP
Error checking, as always, has been left as a exercise fo' tha reader.
.SS "How tha fuck do I close a gangbangin' file descriptor by number?"
.IX Xref "file, closin file descriptors POSIX close"
.IX Subsection "How tha fuck do I close a gangbangin' file descriptor by number?"
If, fo' some reason, you gotz a gangbangin' file descriptor instead of a
filehandle (like you used \f(CW\*(C`POSIX::open\*(C'\fR), you can use the
\&\f(CW\*(C`close()\*(C'\fR function from tha \s-1POSIX\s0 module:
.PP
.Vb 1
\&    use POSIX ();
\&
\&    POSIX::close( $fd );
.Ve
.PP
This should rarely be necessary, as tha Perl \f(CW\*(C`close()\*(C'\fR function is ta be
used fo' thangs dat Perl opened itself, even if dat shiznit was a thugged-out dup of a
numeric descriptor as wit \f(CW\*(C`MHCONTEXT\*(C'\fR above. But if you straight-up have
to, you may be able ta do this:
.PP
.Vb 3
\&    require \*(Aqsys/syscall.ph\*(Aq;
\&    mah $rc = syscall(SYS_close(), $fd + 0);  # must force numeric
\&    take a thugged-out dirtnap "can\*(Aqt sysclose $fd: $!" unless $rc == \-1;
.Ve
.PP
Or, just use tha fdopen(3S) feature of \f(CW\*(C`open()\*(C'\fR:
.PP
.Vb 4
\&    {
\&        open mah $fh, "<&=$fd" or take a thugged-out dirtnap "Cannot reopen fd=$fd: $!";
\&        close $fh;
\&    }
.Ve
.ie n .SS "Why can't I use ""C:\etemp\efoo"" up in \s-1DOS\s0 paths, biatch? Why don't `C:\etemp\efoo.exe` work?"
.el .SS "Why can't I use ``C:\etemp\efoo'' up in \s-1DOS\s0 paths, biatch? Why don't `C:\etemp\efoo.exe` work?"
.IX Xref "filename, DOS issues"
.IX Subsection "Why can't I use C:tempfoo up in DOS paths, biatch? Why don't `C:tempfoo.exe` work?"
Whoops muthafucka!  Yo ass just put a tab n' a gangbangin' formfeed tha fuck into dat filename!
Remember dat within double quoted strings (\*(L"like\ethis\*(R"), the
backslash be a escape character n' shit. Da full list of these is in
\&\*(L"Quote n' Quote-like Operators\*(R" up in perlop. Unsurprisingly, you don't
have a gangbangin' file called \*(L"c:(tab)emp(formfeed)oo\*(R" or
\&\*(L"c:(tab)emp(formfeed)oo.exe\*(R" on yo' legacy \s-1DOS\s0 filesystem.
.PP
Either single-quote yo' strings, or (preferably) use forward slashes.
Since all \s-1DOS\s0 n' Windows versions since suttin' like MS-DOS 2.0 or so
have treated \f(CW\*(C`/\*(C'\fR n' \f(CW\*(C`\e\*(C'\fR tha same up in a path, you might as well use the
one dat don't clash wit Perl\*(--or tha \s-1POSIX\s0 shell, \s-1ANSI C\s0 n' \*(C+,
awk, Tcl, Java, or Python, just ta mention a gangbangin' few. \s-1POSIX\s0 paths
are mo' portable, like a muthafucka.
.ie n .SS "Why don't glob(""*.*"") git all tha files?"
.el .SS "Why don't glob(``*.*'') git all tha files?"
.IX Xref "glob"
.IX Subsection "Why don't glob(*.*) git all tha files?"
Because even on non-Unix ports, Perlz glob function bigs up standard
Unix globbin semantics. You'll need \f(CW\*(C`glob("*")\*(C'\fR ta git all (non-hidden)
files. This make \fIglob()\fR portable even ta legacy systems. Your
port may include proprietary globbin functions as well. Peep its
documentation fo' details.
.ie n .SS "Why do Perl let me delete read-only files, biatch? Why do ""\-i"" clobber protected files, biatch? Isn't dis a funky-ass bug up in Perl?"
.el .SS "Why do Perl let me delete read-only files, biatch? Why do \f(CW\-i\fP clobber protected files, biatch? Isn't dis a funky-ass bug up in Perl?"
.IX Subsection "Why do Perl let me delete read-only files, biatch? Why do -i clobber protected files, biatch? Isn't dis a funky-ass bug up in Perl?"
This is elaborately n' painstakingly busted lyrics bout up in the
\&\fIfile-dir-perms\fR article up in tha \*(L"Far Mo' Than Yo ass Ever Wanted To
Know\*(R" collection up in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> .
.PP
Da executizzle summary: learn how tha fuck yo' filesystem works. The
permissions on a gangbangin' file say what tha fuck can happen ta tha data up in dat file.
Da permissions on a gangbangin' finger-lickin' directory say what tha fuck can happen ta tha list of
filez up in dat directory. If you delete a gangbangin' file, you removin its
name from tha directory (so tha operation dependz on tha permissions
of tha directory, not of tha file). If you try ta write ta tha file,
the permissionz of tha file govern whether you allowed to.
.SS "How tha fuck do I select a random line from a gangbangin' file?"
.IX Xref "file, selectin a random line"
.IX Subsection "How tha fuck do I select a random line from a gangbangin' file?"
Short of loadin tha file tha fuck into a thugged-out database or pre-indexin tha lines in
the file, there be a cold-ass lil couple thangs dat you can do.
.PP
Herez a reservoir-samplin algorithm from tha Camel Book:
.PP
.Vb 2
\&    srand;
\&    rand($.) < 1 && ($line = $_) while <>;
.Ve
.PP
This has a thugged-out dope advantage up in space over readin tha whole file
in. I aint talkin' bout chicken n' gravy biatch. Yo ass can find a proof of dis method up in \fIDa Art of Computer
Programming\fR, Volume 2, Section 3.4.2, by Dizzle E. Knuth.
.PP
Yo ass can use tha File::Random module which serves up a gangbangin' function
for dat algorithm:
.PP
.Vb 2
\&    use File::Random qw/random_line/;
\&    mah $line = random_line($filename);
.Ve
.PP
Another way is ta use tha Tie::File module, which treats tha entire
file as a array. Right back up in yo muthafuckin ass. Simply access a random array element.
.SS "Why do I git weird spaces when I print a array of lines?"
.IX Subsection "Why do I git weird spaces when I print a array of lines?"
(contributed by brian d foy)
.PP
If yo ass is seein spaces between tha elementz of yo' array when
you print tha array, yo ass is probably interpolatin tha array in
double quotes:
.PP
.Vb 2
\&    mah @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: @animals\en";
.Ve
.PP
It aint nuthin but tha double quotes, not tha \f(CW\*(C`print\*(C'\fR, bustin all dis bullshit. Whenever you
interpolate a array up in a thugged-out double quote context, Perl joins the
elements wit spaces (or whatever is up in \f(CW$"\fR, which be a space by
default):
.PP
.Vb 1
\&    muthafuckas are: camel llama alpaca vicuna
.Ve
.PP
This is different than printin tha array without tha interpolation:
.PP
.Vb 2
\&    mah @animals = qw(camel llama alpaca vicuna);
\&    print "animals are: ", @animals, "\en";
.Ve
.PP
Now tha output aint gots tha spaces between tha elements cuz
the elementz of \f(CW@animals\fR simply become part of tha list to
\&\f(CW\*(C`print\*(C'\fR:
.PP
.Vb 1
\&    muthafuckas are: camelllamaalpacavicuna
.Ve
.PP
Yo ass might notice dis when each of tha elementz of \f(CW@array\fR end with
a newline. Yo ass expect ta print one element per line yo, but notice that
every line afta tha straight-up original gangsta is indented:
.PP
.Vb 3
\&    dis be a line
\&     dis be another line
\&     dis is tha third line
.Ve
.PP
That extra space be reppin tha interpolation of tha array. If you
don't wanna put anythang between yo' array elements, don't use the
array up in double quotes. Yo ass can bust it ta print without them:
.PP
.Vb 1
\&    print @lines;
.Ve
.SS "How tha fuck do I traverse a gangbangin' finger-lickin' directory tree?"
.IX Subsection "How tha fuck do I traverse a gangbangin' finger-lickin' directory tree?"
(contributed by brian d foy)
.PP
Da File::Find module, which comes wit Perl, do all of tha hard
work ta traverse a gangbangin' finger-lickin' directory structure. Well shiiiit, it comes wit Perl. Yo ass simply
call tha \f(CW\*(C`find\*(C'\fR subroutine wit a cold-ass lil callback subroutine n' the
directories you wanna traverse:
.PP
.Vb 1
\&    use File::Find;
\&
\&    find( \e&wanted, @directories );
\&
\&    sub wanted {
\&        # full path up in $File::Find::name
\&        # just filename up in $_
\&        ... do whatever you wanna do ...
\&    }
.Ve
.PP
Da File::Find::Closures, which you can downlizzle from \s-1CPAN,\s0 provides
many ready-to-use subroutines dat you can use wit File::Find.
.PP
Da File::Finder, which you can downlizzle from \s-1CPAN,\s0 can help you
create tha callback subroutine rockin suttin' closer ta tha syntax of
the \f(CW\*(C`find\*(C'\fR command-line utility:
.PP
.Vb 2
\&    use File::Find;
\&    use File::Finder;
\&
\&    mah $deep_dirs = File::Finder\->depth\->type(\*(Aqd\*(Aq)\->ls\->exec(\*(Aqrmdir\*(Aq,\*(Aq{}\*(Aq);
\&
\&    find( $deep_dirs\->as_options, @places );
.Ve
.PP
Da File::Find::Rule module, which you can downlizzle from \s-1CPAN,\s0 has
a similar intercourse yo, but do tha traversal fo' you too:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    mah @filez = File::Find::Rule\->file()
\&                             \->name( \*(Aq*.pm\*(Aq )
\&                             \->in( @INC );
.Ve
.SS "How tha fuck do I delete a gangbangin' finger-lickin' directory tree?"
.IX Subsection "How tha fuck do I delete a gangbangin' finger-lickin' directory tree?"
(contributed by brian d foy)
.PP
If you have a empty directory, you can use Perlz built-in \f(CW\*(C`rmdir\*(C'\fR.
If tha directory aint empty (so, no filez or subdirectories), you
either gotta empty it yo ass (a shitload of work) or bust a module to
help yo thugged-out ass.
.PP
Da File::Path module, which comes wit Perl, has a \f(CW\*(C`remove_tree\*(C'\fR
which can take care of all of tha mad bullshit fo' you:
.PP
.Vb 1
\&    use File::Path qw(remove_tree);
\&
\&    remove_tree( @directories );
.Ve
.PP
Da File::Path module also has a legacy intercourse ta tha older
\&\f(CW\*(C`rmtree\*(C'\fR subroutine.
.SS "How tha fuck do I copy a entire directory?"
.IX Subsection "How tha fuck do I copy a entire directory?"
(contributed by Shlomi Fish)
.PP
To do tha equivalent of \f(CW\*(C`cp \-R\*(C'\fR (i.e. copy a entire directory tree
recursively) up in portable Perl, you gonna either need ta write suttin' yo ass
or find a phat \s-1CPAN\s0 module like fuckin  File::Copy::Recursive.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez here is up in tha public
domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted n' encouraged ta use dis code n' any
derivatives thereof up in yo' own programs fo' funk or fo' profit as you
see fit fo' realz. A simple comment up in tha code givin credit ta tha \s-1FAQ\s0 would
be courteous but aint required.
