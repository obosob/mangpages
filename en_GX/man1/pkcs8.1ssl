.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PKCS8 1"
.TH PKCS8 1 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
pkcs8 \- PKCS#8 format private key conversion tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBopenssl\fR \fBpkcs8\fR
[\fB\-topk8\fR]
[\fB\-inform PEM|DER\fR]
[\fB\-outform PEM|DER\fR]
[\fB\-in filename\fR]
[\fB\-passin arg\fR]
[\fB\-out filename\fR]
[\fB\-passout arg\fR]
[\fB\-noiter\fR]
[\fB\-nocrypt\fR]
[\fB\-nooct\fR]
[\fB\-embed\fR]
[\fB\-nsdb\fR]
[\fB\-v2 alg\fR]
[\fB\-v1 alg\fR]
[\fB\-engine id\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fBpkcs8\fR command processes private keys up in PKCS#8 format. Well shiiiit, it can handle
both unencrypted PKCS#8 PrivateKeyInfo format n' EncryptedPrivateKeyInfo
format wit a variety of PKCS#5 (v1.5 n' v2.0) n' PKCS#12 algorithms.
.SH "COMMAND OPTIONS"
.IX Header "COMMAND OPTIONS"
.IP "\fB\-topk8\fR" 4
.IX Item "-topk8"
Normally a PKCS#8 private key is expected on input n' a traditionizzle format
private key is ghon be written. I aint talkin' bout chicken n' gravy biatch. With tha \fB\-topk8\fR option tha thang is
reversed: it readz a traditionizzle format private key n' writes a PKCS#8
format key.
.IP "\fB\-inform DER|PEM\fR" 4
.IX Item "-inform DER|PEM"
This specifies tha input format. If a PKCS#8 format key is expected on input
then either a \fB\s-1DER\s0\fR or \fB\s-1PEM\s0\fR encoded version of a PKCS#8 key will be
expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Otherwise tha \fB\s-1DER\s0\fR or \fB\s-1PEM\s0\fR format of tha traditionizzle format
private key is used.
.IP "\fB\-outform DER|PEM\fR" 4
.IX Item "-outform DER|PEM"
This specifies tha output format, tha options have tha same meanin as tha 
\&\fB\-inform\fR option.
.IP "\fB\-in filename\fR" 4
.IX Item "-in filename"
This specifies tha input filename ta read a key from or standard input if this
option aint specified. Y'all KNOW dat shit, muthafucka! If tha key is encrypted a pass phrase will be
prompted for.
.IP "\fB\-passin arg\fR" 4
.IX Item "-passin arg"
the input file password source. For mo' shiznit bout tha format of \fBarg\fR
see tha \fB\s-1PASS PHRASE ARGUMENTS\s0\fR section up in \fIopenssl\fR\|(1).
.IP "\fB\-out filename\fR" 4
.IX Item "-out filename"
This specifies tha output filename ta write a key ta or standard output by
default. If any encryption options is set then a pass phrase will be
prompted for. Shiiit, dis aint no joke. Da output filename should \fBnot\fR be tha same as tha input
filename.
.IP "\fB\-passout arg\fR" 4
.IX Item "-passout arg"
the output file password source. For mo' shiznit bout tha format of \fBarg\fR
see tha \fB\s-1PASS PHRASE ARGUMENTS\s0\fR section up in \fIopenssl\fR\|(1).
.IP "\fB\-nocrypt\fR" 4
.IX Item "-nocrypt"
PKCS#8 keys generated or input is normally PKCS#8 EncryptedPrivateKeyInfo
structures rockin a appropriate password based encryption algorithm. With
this option a unencrypted PrivateKeyInfo structure is expected or output.
This option do not encrypt private keys at all n' should only be used
when straight-up necessary. Certain software like fuckin some versionz of Java
code signin software used unencrypted private keys.
.IP "\fB\-nooct\fR" 4
.IX Item "-nooct"
This option generates \s-1RSA\s0 private keys up in a gangbangin' fucked up format dat some software
uses. Right back up in yo muthafuckin ass. Specifically tha private key should be enclosed up in a \s-1OCTET STRING\s0
but some software just includes tha structure itself without the
surroundin \s-1OCTET STRING.\s0
.IP "\fB\-embed\fR" 4
.IX Item "-embed"
This option generates \s-1DSA\s0 keys up in a gangbangin' fucked up format. Da \s-1DSA\s0 parametas are
embedded inside tha PrivateKey structure. In dis form tha \s-1OCTET STRING\s0
gotz nuff a \s-1ASN1 SEQUENCE\s0 consistin of two structures: a \s-1SEQUENCE\s0 containing
the parametas n' a \s-1ASN1 INTEGER\s0 containin tha private key.
.IP "\fB\-nsdb\fR" 4
.IX Item "-nsdb"
This option generates \s-1DSA\s0 keys up in a gangbangin' fucked up format compatible wit Netscape
private key databases. Da PrivateKey gotz nuff a \s-1SEQUENCE\s0 consistin of
the hood n' private keys respectively.
.IP "\fB\-v2 alg\fR" 4
.IX Item "-v2 alg"
This option enablez tha use of PKCS#5 v2.0 algorithms. Normally PKCS#8
private keys is encrypted wit tha password based encryption algorithm
called \fBpbeWithMD5AndDES\-CBC\fR dis uses 56 bit \s-1DES\s0 encryption but it
was tha strongest encryption algorithm supported up in PKCS#5 v1.5. Usin 
the \fB\-v2\fR option PKCS#5 v2.0 algorithms is used which can use any
encryption algorithm like fuckin 168 bit triple \s-1DES\s0 or 128 bit \s-1RC2\s0 however
not nuff implementations support PKCS#5 v2.0 yet. If yo ass is just using
private keys wit OpenSSL then dis don't matter.
.Sp
Da \fBalg\fR argument is tha encryption algorithm ta use, valid joints include
\&\fBdes\fR, \fBdes3\fR n' \fBrc2\fR. Well shiiiit, it is recommended dat \fBdes3\fR is used.
.IP "\fB\-v1 alg\fR" 4
.IX Item "-v1 alg"
This option specifies a PKCS#5 v1.5 or PKCS#12 algorithm ta use fo' realz. A complete
list of possible algorithms is included below.
.IP "\fB\-engine id\fR" 4
.IX Item "-engine id"
specifyin a engine (by its unique \fBid\fR string) will cause \fBpkcs8\fR
to attempt ta obtain a gangbangin' functionizzle reference ta tha specified engine,
thus initialisin it if needed. Y'all KNOW dat shit, muthafucka! Da engine will then be set as tha default
for all available algorithms.
.SH "NOTES"
.IX Header "NOTES"
Da encrypted form of a \s-1PEM\s0 encode PKCS#8 filez uses tha following
headaz n' footers:
.PP
.Vb 2
\& \-\-\-\-\-BEGIN ENCRYPTED PRIVATE KEY\-\-\-\-\-
\& \-\-\-\-\-END ENCRYPTED PRIVATE KEY\-\-\-\-\-
.Ve
.PP
Da unencrypted form uses:
.PP
.Vb 2
\& \-\-\-\-\-BEGIN PRIVATE KEY\-\-\-\-\-
\& \-\-\-\-\-END PRIVATE KEY\-\-\-\-\-
.Ve
.PP
Private keys encrypted rockin PKCS#5 v2.0 algorithms n' high iteration
counts is mo' secure dat dem encrypted rockin tha traditional
SSLeay compatible formats, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. So if additionizzle securitizzle is considered
important tha keys should be converted.
.PP
Da default encryption is only 56 bits cuz dis is tha encryption
that most current implementationz of PKCS#8 will support.
.PP
Some software may use PKCS#12 password based encryption algorithms
with PKCS#8 format private keys: these is handled automatically
but there is no option ta produce em.
.PP
It be possible ta write up \s-1DER\s0 encoded encrypted private keys in
PKCS#8 format cuz tha encryption details is included at a \s-1ASN1\s0
level whereas tha traditionizzle format includes dem at a \s-1PEM\s0 level.
.SH "PKCS#5 v1.5 n' PKCS#12 algorithms."
.IX Header "PKCS#5 v1.5 n' PKCS#12 algorithms."
Various algorithms can be used wit tha \fB\-v1\fR command line option,
includin PKCS#5 v1.5 n' PKCS#12. These is busted lyrics bout up in mo' detail
below.
.IP "\fB\s-1PBE\-MD2\-DES PBE\-MD5\-DES\s0\fR" 4
.IX Item "PBE-MD2-DES PBE-MD5-DES"
These algorithms was included up in tha original gangsta PKCS#5 v1.5 justification.
They only offer 56 bitz of protection since they both use \s-1DES.\s0
.IP "\fB\s-1PBE\-SHA1\-RC2\-64 PBE\-MD2\-RC2\-64 PBE\-MD5\-RC2\-64 PBE\-SHA1\-DES\s0\fR" 4
.IX Item "PBE-SHA1-RC2-64 PBE-MD2-RC2-64 PBE-MD5-RC2-64 PBE-SHA1-DES"
These algorithms is not mentioned up in tha original gangsta PKCS#5 v1.5 justification
but they use tha same key derivation algorithm n' is supported by some
software. They is mentioned up in PKCS#5 v2.0. They use either 64 bit \s-1RC2\s0 or
56 bit \s-1DES.\s0
.IP "\fB\s-1PBE\-SHA1\-RC4\-128 PBE\-SHA1\-RC4\-40 PBE\-SHA1\-3DES PBE\-SHA1\-2DES PBE\-SHA1\-RC2\-128 PBE\-SHA1\-RC2\-40\s0\fR" 4
.IX Item "PBE-SHA1-RC4-128 PBE-SHA1-RC4-40 PBE-SHA1-3DES PBE-SHA1-2DES PBE-SHA1-RC2-128 PBE-SHA1-RC2-40"
These algorithms use tha PKCS#12 password based encryption algorithm and
allow phat encryption algorithms like triple \s-1DES\s0 or 128 bit \s-1RC2\s0 ta be used.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Convert a private from traditionizzle ta PKCS#5 v2.0 format rockin triple
\&\s-1DES:\s0
.PP
.Vb 1
\& openssl pkcs8 \-in key.pem \-topk8 \-v2 des3 \-out enckey.pem
.Ve
.PP
Convert a private key ta PKCS#8 rockin a PKCS#5 1.5 compatible algorithm
(\s-1DES\s0):
.PP
.Vb 1
\& openssl pkcs8 \-in key.pem \-topk8 \-out enckey.pem
.Ve
.PP
Convert a private key ta PKCS#8 rockin a PKCS#12 compatible algorithm
(3DES):
.PP
.Vb 1
\& openssl pkcs8 \-in key.pem \-topk8 \-out enckey.pem \-v1 PBE\-SHA1\-3DES
.Ve
.PP
Read a \s-1DER\s0 unencrypted PKCS#8 format private key:
.PP
.Vb 1
\& openssl pkcs8 \-inform DER \-nocrypt \-in key.der \-out key.pem
.Ve
.PP
Convert a private key from any PKCS#8 format ta traditionizzle format:
.PP
.Vb 1
\& openssl pkcs8 \-in pk8.pem \-out key.pem
.Ve
.SH "STANDARDS"
.IX Header "STANDARDS"
Test vectors from dis PKCS#5 v2.0 implementation was posted ta the
pkcs-tng mailin list rockin triple \s-1DES, DES\s0 n' \s-1RC2\s0 wit high iteration
counts, nuff muthafuckin playas confirmed dat they could decrypt tha private
keys produced n' Therefore it can be assumed dat tha PKCS#5 v2.0
implementation is reasonably accurate at least as far as these
algorithms is concerned.
.PP
Da format of PKCS#8 \s-1DSA \s0(and other) private keys aint well documented:
it is hidden away up in PKCS#11 v2.01, section 11.9. OpenSSLz default \s-1DSA\s0
PKCS#8 private key format complies wit dis standard.
.SH "BUGS"
.IX Header "BUGS"
There should be a option dat prints up tha encryption algorithm
in use n' other details like fuckin tha iteration count.
.PP
PKCS#8 rockin triple \s-1DES\s0 n' PKCS#5 v2.0 should be tha default private
key format fo' OpenSSL: fo' compatibilitizzle nuff muthafuckin of tha utilitizzles use
the oldschool format at present.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdsa\fR\|(1), \fIrsa\fR\|(1), \fIgenrsa\fR\|(1),
\&\fIgendsa\fR\|(1)
