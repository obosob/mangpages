.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PARALLEL 1"
.TH PARALLEL 1 "2013-08-03" "20130522" "parallel"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
parallel \- build n' execute shell command lines from standard input up in parallel
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] < list_of_arguments
.PP
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] ( \fB:::\fR arguments |
\&\fB::::\fR argfile(s) ) ...
.PP
\&\fBparallel\fR \-\-semaphore [options] \fIcommand\fR
.PP
\&\fB#!/usr/bin/parallel\fR \-\-shebang [options] [\fIcommand\fR [arguments]]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1GNU \s0\fBparallel\fR be a gangbangin' finger-lickin' dirty-ass shell tool fo' executin thangs up in parallel using
one or mo' computas fo' realz. A thang can be a single command or a small
script dat has ta be run fo' each of tha lines up in tha input. The
typical input be a list of files, a list of hosts, a list of users, a
list of URLs, or a list of tablez fo' realz. A thang can also be a cold-ass lil command that
readz from a pipe. \s-1GNU \s0\fBparallel\fR can then split tha input into
blocks n' pipe a funky-ass block tha fuck into each command up in parallel.
.PP
If you use xargs n' tee todizzle yo big-ass booty is ghon find \s-1GNU \s0\fBparallel\fR straight-up easy as fuck  to
use as \s-1GNU \s0\fBparallel\fR is freestyled ta have tha same options as xargs. If
you write loops up in shell, yo big-ass booty is ghon find \s-1GNU \s0\fBparallel\fR may be able to
replace most of tha loops n' make dem run fasta by hustlin several
jobs up in parallel.
.PP
\&\s-1GNU \s0\fBparallel\fR make shizzle output from tha commandz is tha same ol' dirty output as
you would git had you run tha commandz sequentially. This make it
possible ta use output from \s-1GNU \s0\fBparallel\fR as input fo' other programs.
.PP
For each line of input \s-1GNU \s0\fBparallel\fR will execute \fIcommand\fR with
the line as arguments, n' you can put dat on yo' toast. If no \fIcommand\fR is given, tha line of input is
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. Several lines is ghon be run up in parallel. \s-1GNU \s0\fBparallel\fR can
often be used as a substitute fo' \fBxargs\fR or \fBcat | bash\fR.
.SS "Readerz guide"
.IX Subsection "Readerz guide"
Before lookin all up in tha options you may wanna check up tha \fB\s-1EXAMPLE\s0\fRs
afta tha list of options. That will hit you wit a scam of what tha fuck \s-1GNU
\&\s0\fBparallel\fR is capable of.
.PP
Yo ass can also peep tha intro vizzle fo' a quick introduction:
http://tinyogg.com/watch/TORaR/ http://tinyogg.com/watch/hfxKj/ and
http://tinyogg.com/watch/YQuXd/ or
http://www.youtube.com/playlist?list=PL284C9FF2488BC6D1
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fIcommand\fR" 9
.IX Item "command"
Command ta execute.  If \fIcommand\fR or tha followin arguments contain
replacement strings (like fuckin \fB{}\fR) every last muthafuckin instizzle is ghon be substituted
with tha input.
.Sp
If \fIcommand\fR is given, \s-1GNU \s0\fBparallel\fR solve tha same tasks as
\&\fBxargs\fR. If \fIcommand\fR aint given \s-1GNU \s0\fBparallel\fR will behave
similar ta \fBcat | sh\fR.
.Sp
Da \fIcommand\fR must be a executable, a script, a cold-ass lil composed command, or
a function. I aint talkin' bout chicken n' gravy biatch. If it aint nuthin but a gangbangin' function you need ta \fBexport \-f\fR tha function
first fo' realz. An alias will, however, not work (see why
http://www.perlmonks.org/index.pl?node_id=484296).
.IP "\fB{}\fR" 9
.IX Item "{}"
Input line. This replacement strang is ghon be replaced by a gangbangin' full line
read from tha input source. Da input source is normally stdin
(standard input) yo, but can also be given wit \fB\-a\fR, \fB:::\fR, or
\&\fB::::\fR.
.Sp
Da replacement strang \fB{}\fR can be chizzled wit \fB\-I\fR.
.Sp
If tha command line gotz nuff no replacement strings then \fB{}\fR will be
appended ta tha command line.
.IP "\fB{.}\fR" 9
.IX Item "{.}"
Input line without extension. I aint talkin' bout chicken n' gravy biatch. This replacement strang is ghon be replaced
by tha input wit tha extension removed. Y'all KNOW dat shit, muthafucka! If tha input line gotz nuff
\&\fB.\fR afta tha last \fB/\fR tha last \fB.\fR till tha end of tha strang will
be removed n' \fB{.}\fR is ghon be replaced wit the
remaining. E.g. \fIfoo.jpg\fR becomes \fIfoo\fR, \fIsubdir/foo.jpg\fR becomes
\&\fIsubdir/foo\fR, \fIsub.dir/foo.jpg\fR becomes \fIsub.dir/foo\fR,
\&\fIsub.dir/bar\fR remains \fIsub.dir/bar\fR. If tha input line do not
contain \fB.\fR it will remain unchanged.
.Sp
Da replacement strang \fB{.}\fR can be chizzled wit \fB\-\-er\fR.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{/}\fR" 9
.IX Item "{/}"
Basename of input line. This replacement strang is ghon be replaced by
the input wit tha directory part removed.
.Sp
Da replacement strang \fB{/}\fR can be chizzled with
\&\fB\-\-basenamereplace\fR.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{//}\fR" 9
.IX Item "{//}"
Dirname of input line. This replacement strang is ghon be replaced by the
dir of tha input line. Right back up in yo muthafuckin ass. See \fBdirname\fR(1).
.Sp
Da replacement strang \fB{//}\fR can be chizzled with
\&\fB\-\-dirnamereplace\fR.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{/.}\fR" 9
.IX Item "{/.}"
Basename of input line without extension. I aint talkin' bout chicken n' gravy biatch. This replacement strang will
be replaced by tha input wit tha directory n' extension part
removed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it aint nuthin but a cold-ass lil combination of \fB{/}\fR n' \fB{.}\fR.
.Sp
Da replacement strang \fB{/.}\fR can be chizzled with
\&\fB\-\-basenameextensionreplace\fR.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{#}\fR" 9
.IX Item "{#}"
Sequence number of tha thang ta run. I aint talkin' bout chicken n' gravy biatch. This replacement strang will be
replaced by tha sequence number of tha thang bein run. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it gotz nuff the
same number as \f(CW$PARALLEL_SEQ\fR.
.Sp
Da replacement strang \fB{#}\fR can be chizzled wit \fB\-\-seqreplace\fR.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{\fR\fIn\fR\fB}\fR (beta testing)" 9
.IX Item "{n} (beta testing)"
Argument from input source \fIn\fR or tha \fIn\fR'th argument. This
positionizzle replacement strang is ghon be replaced by tha input from input
source \fIn\fR (when used wit \fB\-a\fR or \fB::::\fR) or wit tha \fIn\fR'th
argument (when used wit \fB\-N\fR). If \fIn\fR is wack it refers ta the
\&\fIn\fR'th last argument.
.Sp
To KNOW replacement strings peep \fB{}\fR.
.IP "\fB{\fR\fIn\fR.\fB}\fR (beta testing)" 9
.IX Item "{n.} (beta testing)"
Argument from input source \fIn\fR or tha \fIn\fR'th argument without
extension. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it aint nuthin but a cold-ass lil combination of \fB{\fR\fIn\fR\fB}\fR n' \fB{.}\fR.
.Sp
This positionizzle replacement strang is ghon be replaced by tha input from
input source \fIn\fR (when used wit \fB\-a\fR or \fB::::\fR) or wit the
\&\fIn\fR'th argument (when used wit \fB\-N\fR). Da input gonna git the
extension removed.
.Sp
To KNOW positionizzle replacement strings peep \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR/\fB}\fR (beta testing)" 9
.IX Item "{n/} (beta testing)"
Basename of argument from input source \fIn\fR or tha \fIn\fR'th argument.
It be a cold-ass lil combination of \fB{\fR\fIn\fR\fB}\fR n' \fB{/}\fR.
.Sp
This positionizzle replacement strang is ghon be replaced by tha input from
input source \fIn\fR (when used wit \fB\-a\fR or \fB::::\fR) or wit the
\&\fIn\fR'th argument (when used wit \fB\-N\fR). Da input gonna git the
directory (if any) removed.
.Sp
To KNOW positionizzle replacement strings peep \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR//\fB}\fR (beta testing)" 9
.IX Item "{n//} (beta testing)"
Dirname of argument from input source \fIn\fR or tha \fIn\fR'th argument.
It be a cold-ass lil combination of \fB{\fR\fIn\fR\fB}\fR n' \fB{//}\fR.
.Sp
This positionizzle replacement strang is ghon be replaced by tha dir of the
input from input source \fIn\fR (when used wit \fB\-a\fR or \fB::::\fR) or with
the \fIn\fR'th argument (when used wit \fB\-N\fR). Right back up in yo muthafuckin ass. See \fBdirname\fR(1).
.Sp
To KNOW positionizzle replacement strings peep \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB{\fR\fIn\fR/.\fB}\fR (beta testing)" 9
.IX Item "{n/.} (beta testing)"
Basename of argument from input source \fIn\fR or tha \fIn\fR'th argument
without extension. I aint talkin' bout chicken n' gravy biatch.  It be a cold-ass lil combination of \fB{\fR\fIn\fR\fB}\fR, \fB{/}\fR, and
\&\fB{.}\fR.
.Sp
This positionizzle replacement strang is ghon be replaced by tha input from
input source \fIn\fR (when used wit \fB\-a\fR or \fB::::\fR) or wit the
\&\fIn\fR'th argument (when used wit \fB\-N\fR). Da input gonna git the
directory (if any) n' extension removed.
.Sp
To KNOW positionizzle replacement strings peep \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB:::\fR \fIarguments\fR" 9
.IX Item "::: arguments"
Use arguments from tha command line as input source instead of stdin
(standard input). Unlike other options fo' \s-1GNU \s0\fBparallel\fR \fB:::\fR is
placed afta tha \fIcommand\fR n' before tha arguments.
.Sp
Da followin is equivalent:
.Sp
.Vb 6
\&  (echo file1; echo file2) | parallel gzip
\&  parallel gzip ::: file1 file2
\&  parallel gzip {} ::: file1 file2
\&  parallel \-\-arg\-sep ,, gzip {} ,, file1 file2
\&  parallel \-\-arg\-sep ,, gzip ,, file1 file2
\&  parallel ::: "gzip file1" "gzip file2"
.Ve
.Sp
To avoid treatin \fB:::\fR as special use \fB\-\-arg\-sep\fR ta set the
argument separator ta suttin' else. Right back up in yo muthafuckin ass. See also \fB\-\-arg\-sep\fR.
.Sp
stdin (standard input) is ghon be passed ta tha straight-up original gangsta process run.
.Sp
If multiple \fB:::\fR is given, each crew is ghon be treated as a input
source, n' all combinationz of input sources will be
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. E.g. ::: 1 2 ::: a funky-ass b c will result up in tha combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful fo' replacing
nested for-loops.
.Sp
\&\fB:::\fR n' \fB::::\fR can be mixed. Y'all KNOW dat shit, muthafucka! So these is equivalent:
.Sp
.Vb 6
\&  parallel echo {1} {2} {3} ::: 6 7 ::: 4 5 ::: 1 2 3
\&  parallel echo {1} {2} {3} :::: <(seq 6 7) <(seq 4 5) :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) echo {1} {2} {3} :::: <(seq 4 5) :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) \-a <(seq 4 5) echo {1} {2} {3} ::: 1 2 3
\&  seq 6 7 | parallel \-a \- \-a <(seq 4 5) echo {1} {2} {3} ::: 1 2 3
\&  seq 4 5 | parallel echo {1} {2} {3} :::: <(seq 6 7) \- ::: 1 2 3
.Ve
.IP "\fB::::\fR \fIargfiles\fR" 9
.IX Item ":::: argfiles"
Another way ta write \fB\-a\fR \fIargfile1\fR \fB\-a\fR \fIargfile2\fR ...
.Sp
\&\fB:::\fR n' \fB::::\fR can be mixed.
.Sp
See \fB\-a\fR, \fB:::\fR n' \fB\-\-xapply\fR.
.IP "\fB\-\-null\fR" 9
.IX Item "--null"
.PD 0
.IP "\fB\-0\fR" 9
.IX Item "-0"
.PD
Use \s-1NUL\s0 as delimiter n' shit.  Normally input lines will end up in \en
(newline). If they end up in \e0 (\s-1NUL\s0), then use dis option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is useful
for processin arguments dat may contain \en (newline).
.IP "\fB\-\-arg\-file\fR \fIinput-file\fR" 9
.IX Item "--arg-file input-file"
.PD 0
.IP "\fB\-a\fR \fIinput-file\fR" 9
.IX Item "-a input-file"
.PD
Use \fIinput-file\fR as input source. If you use dis option, stdin
(standard input) is given ta tha straight-up original gangsta process run. I aint talkin' bout chicken n' gravy biatch.  Otherwise, stdin
(standard input) is repimped up from /dev/null.
.Sp
If multiple \fB\-a\fR is given, each \fIinput-file\fR is ghon be treated as an
input source, n' all combinationz of input sources will be
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. E.g. Da file \fBfoo\fR gotz nuff \fB1 2\fR, tha file \fBbar\fR
gotz nuff \fBa b c\fR.  \fB\-a foo\fR \fB\-a bar\fR will result up in tha combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful fo' replacing
nested for-loops.
.Sp
See also \fB\-\-xapply\fR n' \fB{\fR\fIn\fR\fB}\fR.
.IP "\fB\-\-arg\-file\-sep\fR \fIsep-str\fR" 9
.IX Item "--arg-file-sep sep-str"
Use \fIsep-str\fR instead of \fB::::\fR as separator strang between command
and argument files. Useful if \fB::::\fR is used fo' suttin' else by the
command.
.Sp
See also: \fB::::\fR.
.IP "\fB\-\-arg\-sep\fR \fIsep-str\fR" 9
.IX Item "--arg-sep sep-str"
Use \fIsep-str\fR instead of \fB:::\fR as separator string. Useful if \fB:::\fR
is used fo' suttin' else by tha command.
.Sp
Also useful if you command uses \fB:::\fR but you still wanna read
arguments from stdin (standard input): Simply chizzle \fB\-\-arg\-sep\fR ta a
strin dat aint up in tha command line.
.Sp
See also: \fB:::\fR.
.IP "\fB\-\-basefile\fR \fIfile\fR" 9
.IX Item "--basefile file"
.PD 0
.IP "\fB\-\-bf\fR \fIfile\fR" 9
.IX Item "--bf file"
.PD
\&\fIfile\fR is ghon be transferred ta each sshlogin before a thangs is
started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it is ghon be removed if \fB\-\-cleanup\fR be active. Da file may be
a script ta run or some common base data needed fo' tha thangs.
Multiple \fB\-\-bf\fR can be specified ta transfer mo' basefiles. The
\&\fIfile\fR is ghon be transferred tha same way as \fB\-\-transfer\fR.
.IP "\fB\-\-basenamereplace\fR \fIreplace-str\fR" 9
.IX Item "--basenamereplace replace-str"
.PD 0
.IP "\fB\-\-bnr\fR \fIreplace-str\fR" 9
.IX Item "--bnr replace-str"
.PD
Use tha replacement strang \fIreplace-str\fR instead of \fB{/}\fR for
basename of input line.
.IP "\fB\-\-basenameextensionreplace\fR \fIreplace-str\fR" 9
.IX Item "--basenameextensionreplace replace-str"
.PD 0
.IP "\fB\-\-bner\fR \fIreplace-str\fR" 9
.IX Item "--bner replace-str"
.PD
Use tha replacement strang \fIreplace-str\fR instead of \fB{/.}\fR fo' basename of input line without extension.
.IP "\fB\-\-bg\fR" 9
.IX Item "--bg"
Run command up in background thus \s-1GNU \s0\fBparallel\fR aint gonna wait for
completion of tha command before exiting. This is tha default if
\&\fB\-\-semaphore\fR is set.
.Sp
See also: \fB\-\-fg\fR, \fBman sem\fR
.Sp
Implies \fB\-\-semaphore\fR.
.IP "\fB\-\-bibtex\fR" 9
.IX Item "--bibtex"
Print tha BibTeX entry fo' \s-1GNU \s0\fBparallel\fR.
.IP "\fB\-\-block\fR \fIsize\fR" 9
.IX Item "--block size"
.PD 0
.IP "\fB\-\-block\-size\fR \fIsize\fR" 9
.IX Item "--block-size size"
.PD
Size of block up in bytes. Da size can be postfixed wit K, M, G, T, P,
k, m, g, t, or p which would multiply tha size wit 1024, 1048576,
1073741824, 1099511627776, 1125899906842624, 1000, 1000000,
1000000000, 1000000000000, or 1000000000000000 respectively.
.Sp
\&\s-1GNU \s0\fBparallel\fR tries ta hook up tha block size but can be off by the
length of one record. Y'all KNOW dat shit, muthafucka! For performizzle reasons \fIsize\fR should be bigger
than a single record.
.Sp
\&\fIsize\fR defaults ta 1M.
.Sp
See \fB\-\-pipe\fR fo' use of all dis bullshit.
.IP "\fB\-\-cleanup\fR (beta testing)" 9
.IX Item "--cleanup (beta testing)"
Remove transferred files. \fB\-\-cleanup\fR will remove tha transferred files
on tha remote computa afta processin is done.
.Sp
.Vb 3
\&  find log \-name \*(Aq*gz\*(Aq | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer \-\-return {.}.bz2 \e
\&    \-\-cleanup "zcat {} | bzip \-9 >{.}.bz2"
.Ve
.Sp
With \fB\-\-transfer\fR tha file transferred ta tha remote computa will be
removed on tha remote computer n' shit.  Directories pimped aint gonna be removed
\&\- even if they is empty.
.Sp
With \fB\-\-return\fR tha file transferred from tha remote computa will be
removed on tha remote computer n' shit.  Directories pimped aint gonna be removed
\&\- even if they is empty.
.Sp
\&\fB\-\-cleanup\fR is ignored when not used wit \fB\-\-transfer\fR or \fB\-\-return\fR.
.IP "\fB\-\-colsep\fR \fIregexp\fR" 9
.IX Item "--colsep regexp"
.PD 0
.IP "\fB\-C\fR \fIregexp\fR" 9
.IX Item "-C regexp"
.PD
Column separator. Shiiit, dis aint no joke. Da input is ghon be treated as a table wit \fIregexp\fR
separatin tha columns. Da n'th column can be access using
\&\fB{\fR\fIn\fR\fB}\fR or \fB{\fR\fIn\fR.\fB}\fR. E.g. \fB{3}\fR is tha 3rd column.
.Sp
\&\fB\-\-colsep\fR implies \fB\-\-trim rl\fR.
.Sp
\&\fIregexp\fR be a Perl Regular Expression:
http://perldoc.perl.org/perlre.html
.IP "\fB\-\-ctrlc\fR (alpha testing)" 9
.IX Item "--ctrlc (alpha testing)"
Sendz \s-1SIGINT\s0 ta tasks hustlin on remote computas thus cappin' em.
.IP "\fB\-\-delimiter\fR \fIdelim\fR" 9
.IX Item "--delimita delim"
.PD 0
.IP "\fB\-d\fR \fIdelim\fR" 9
.IX Item "-d delim"
.PD
Input shit is terminated by tha specified character n' shit.  Quotes and
backslash is not special; every last muthafuckin characta up in tha input is taken
literally.  Disablez tha end-of-file string, which is treated like any
other argument.  This can be used when tha input consistz of simply
newline-separated items, although it be almost always betta ta design
your program ta use \-\-null where dis is possible.  Da specified
delimita may be a single character, a C\-style characta escape such
as \en, or a octal or hexadecimal escape code.  Octal and
hexadecimal escape codes is understood as fo' tha printf command.
Multibyte charactas is not supported.
.IP "\fB\-\-dirnamereplace\fR \fIreplace-str\fR" 9
.IX Item "--dirnamereplace replace-str"
.PD 0
.IP "\fB\-\-dnr\fR \fIreplace-str\fR" 9
.IX Item "--dnr replace-str"
.PD
Use tha replacement strang \fIreplace-str\fR instead of \fB{//}\fR for
dirname of input line.
.IP "\fB\-E\fR \fIeof-str\fR" 9
.IX Item "-E eof-str"
Set tha end of file strang ta eof-str. Shiiit, dis aint no joke.  If tha end of file string
occurs as a line of input, tha rest of tha input is ignored. Y'all KNOW dat shit, muthafucka!  If
neither \fB\-E\fR nor \fB\-e\fR is used, no end of file strang is used.
.IP "\fB\-\-delay\fR \fIsecs\fR" 9
.IX Item "--delay secs"
Delay startin next thang \fIsecs\fR seconds. \s-1GNU \s0\fBparallel\fR will pause
\&\fIsecs\fR secondz afta startin each thang. \fIsecs\fR can be less than 1
seconds.
.IP "\fB\-\-dry\-run\fR" 9
.IX Item "--dry-run"
Print tha thang ta run on stdout (standard output) yo, but do not run the
job. Use \fB\-v \-v\fR ta include tha ssh/rsync wrappin if tha thang would
be run on a remote computer n' shit. Do not count on dis literaly, though, as
the thang may be scheduled on another computa or tha local computa if
: is up in tha list.
.IP "\fB\-\-eof\fR[=\fIeof-str\fR]" 9
.IX Item "--eof[=eof-str]"
.PD 0
.IP "\fB\-e\fR[\fIeof-str\fR]" 9
.IX Item "-e[eof-str]"
.PD
This option be a synonym fo' tha \fB\-E\fR option. I aint talkin' bout chicken n' gravy biatch.  Use \fB\-E\fR instead,
because it is \s-1POSIX\s0 compliant fo' \fBxargs\fR while dis option is not.
If \fIeof-str\fR is omitted, there is no end of file string.  If neither
\&\fB\-E\fR nor \fB\-e\fR is used, no end of file strang is used.
.IP "\fB\-\-env\fR \fIvar\fR" 9
.IX Item "--env var"
Copy environment variable \fIvar\fR. This will copy \fIvar\fR ta the
environment dat tha command is run in. I aint talkin' bout chicken n' gravy biatch. This is especially useful for
remote environments.
.Sp
Caveat: If \fIvar\fR gotz nuff newline ('\en') tha value is messed up.
.IP "\fB\-\-eta\fR" 9
.IX Item "--eta"
Show tha estimated number of secondz before finishing. This forces \s-1GNU
\&\s0\fBparallel\fR ta read all thangs before startin ta find tha number of
jobs. \s-1GNU \s0\fBparallel\fR normally only readz tha next thang ta run.
Implies \fB\-\-progress\fR.
.IP "\fB\-\-fg\fR" 9
.IX Item "--fg"
Run command up in foreground thus \s-1GNU \s0\fBparallel\fR will wait for
completion of tha command before exiting.
.Sp
See also: \fB\-\-bg\fR, \fBman sem\fR
.Sp
Implies \fB\-\-semaphore\fR.
.IP "\fB\-\-filter\-hosts\fR (alpha testing)" 9
.IX Item "--filter-hosts (alpha testing)"
Remove down hosts, n' you can put dat on yo' toast. For each remote host: check dat login all up in ssh
works. If not: do not use dis host.
.Sp
Currently you can \fInot\fR put \fB\-\-filter\-hosts\fR up in a profile,
\&\f(CW$PARALLEL\fR, /etc/parallel/config or similar. Shiiit, dis aint no joke. This is cuz \s-1GNU
\&\s0\fBparallel\fR uses \s-1GNU \s0\fBparallel\fR ta compute this, so yo big-ass booty is ghon git an
infinite loop. This will likely be fixed up in a lata release.
.IP "\fB\-\-gnu\fR" 9
.IX Item "--gnu"
Behave like \s-1GNU \s0\fBparallel\fR. If \fB\-\-tollef\fR n' \fB\-\-gnu\fR is both set,
\&\fB\-\-gnu\fR takes precedence.
.IP "\fB\-\-group\fR" 9
.IX Item "--group"
Group output. Output from each thangs is grouped together n' is only
printed when tha command is finished. Y'all KNOW dat shit, muthafucka! stderr (standard error) first
followed by stdout (standard output). This takes some \s-1CPU\s0 time. In
rare thangs \s-1GNU \s0\fBparallel\fR takes up fuckin shitloadz of \s-1CPU\s0 time n' if it is
acceptable dat tha outputs from different commandz is mixed
together, then disablin groupin wit \fB\-u\fR can speedup \s-1GNU
\&\s0\fBparallel\fR by a gangbangin' factor of 10.
.Sp
\&\fB\-\-group\fR is tha default. Can be reversed wit \fB\-u\fR.
.IP "\fB\-\-help\fR" 9
.IX Item "--help"
.PD 0
.IP "\fB\-h\fR" 9
.IX Item "-h"
.PD
Print a summary of tha options ta \s-1GNU \s0\fBparallel\fR n' exit.
.IP "\fB\-\-halt\-on\-error\fR <0|1|2>" 9
.IX Item "--halt-on-error <0|1|2>"
.PD 0
.IP "\fB\-\-halt\fR <0|1|2>" 9
.IX Item "--halt <0|1|2>"
.RS 9
.IP ".0" 3
.IX Item ".0"
.PD
Do not halt if a thang fails. Exit status is ghon be tha number of thangs
failed. Y'all KNOW dat shit, muthafucka! This is tha default.
.IP ".1" 3
.IX Item ".1"
Do not start freshly smoked up thangs if a thang fails yo, but complete tha hustlin thangs
includin cleanup. Da exit status is ghon be tha exit status from the
last failin thang.
.IP ".2" 3
.IX Item ".2"
Bust a cap up in off all thangs immediately n' exit without cleanup. Da exit
status is ghon be tha exit status from tha failin thang.
.RE
.RS 9
.RE
.IP "\fB\-\-header\fR \fIregexp\fR" 9
.IX Item "--header regexp"
Use upto regexp as header n' shit. For aiiight usage tha matched header
(typically tha straight-up original gangsta line: \fB\-\-header '\en'\fR) is ghon be split using
\&\fB\-\-colsep\fR (which will default ta '\et') n' column names can be used
as replacement variables: \fB{column name}\fR. For \fB\-\-pipe\fR tha matched
header is ghon be prepended ta each output.
.Sp
\&\fB\-\-header :\fR be a alias fo' \fB\-\-header '\en'\fR.
.IP "\fB\-I\fR \fIreplace-str\fR" 9
.IX Item "-I replace-str"
Use tha replacement strang \fIreplace-str\fR instead of {}.
.IP "\fB\-\-replace\fR[=\fIreplace-str\fR]" 9
.IX Item "--replace[=replace-str]"
.PD 0
.IP "\fB\-i\fR[\fIreplace-str\fR]" 9
.IX Item "-i[replace-str]"
.PD
This option be a synonym fo' \fB\-I\fR\fIreplace-str\fR if \fIreplace-str\fR is
specified, n' fo' \fB\-I\fR{} otherwise.  This option is deprecated;
use \fB\-I\fR instead.
.IP "\fB\-\-joblog\fR \fIlogfile\fR" 9
.IX Item "--joSnoop Bloggy-Blogg logfile"
Logfile fo' executed thangs. Right back up in yo muthafuckin ass. Save a list of tha executed thangs to
\&\fIlogfile\fR up in tha followin \s-1TAB\s0 separated format: sequence number,
sshlogin, start time as secondz since epoch, run time up in seconds,
bytes up in filez transferred, bytes up in filez returned, exit status,
and command run.
.Sp
To convert tha times tha fuck into \s-1ISO\-8601\s0 strict do:
.Sp
\&\fBperl \-a \-F\*(L"\et\*(R" \-ne 'chomp($F[2]=`date \-d \e@$F[2] +%FT%T`); print join(\*(L"\et\*(R",@F)'\fR
.Sp
See also \fB\-\-resume\fR.
.IP "\fB\-\-jobs\fR \fIN\fR" 9
.IX Item "--jobs N"
.PD 0
.IP "\fB\-j\fR \fIN\fR" 9
.IX Item "-j N"
.IP "\fB\-\-max\-procs\fR \fIN\fR" 9
.IX Item "--max-procs N"
.IP "\fB\-P\fR \fIN\fR" 9
.IX Item "-P N"
.PD
Number of thangslots, n' you can put dat on yo' toast. Run up ta N thangs up in parallel.  0 means as nuff as
possible. Default is 100% which will run one thang per \s-1CPU\s0 core.
.Sp
If \fB\-\-semaphore\fR is set default is 1 thus bustin a mutex.
.IP "\fB\-\-jobs\fR \fI+N\fR" 9
.IX Item "--jobs +N"
.PD 0
.IP "\fB\-j\fR \fI+N\fR" 9
.IX Item "-j +N"
.IP "\fB\-\-max\-procs\fR \fI+N\fR" 9
.IX Item "--max-procs +N"
.IP "\fB\-P\fR \fI+N\fR" 9
.IX Item "-P +N"
.PD
Add N ta tha number of \s-1CPU\s0 cores.  Run dis nuff thangs up in parallel.
See also \fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fI\-N\fR" 9
.IX Item "--jobs -N"
.PD 0
.IP "\fB\-j\fR \fI\-N\fR" 9
.IX Item "-j -N"
.IP "\fB\-\-max\-procs\fR \fI\-N\fR" 9
.IX Item "--max-procs -N"
.IP "\fB\-P\fR \fI\-N\fR" 9
.IX Item "-P -N"
.PD
Subtract N from tha number of \s-1CPU\s0 cores.  Run dis nuff thangs up in parallel.
If tha evaluated number is less than 1 then 1 is ghon be used. Y'all KNOW dat shit, muthafucka!  See also
\&\fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fIN\fR%" 9
.IX Item "--jobs N%"
.PD 0
.IP "\fB\-j\fR \fIN\fR%" 9
.IX Item "-j N%"
.IP "\fB\-\-max\-procs\fR \fIN\fR%" 9
.IX Item "--max-procs N%"
.IP "\fB\-P\fR \fIN\fR%" 9
.IX Item "-P N%"
.PD
Multiply N% wit tha number of \s-1CPU\s0 cores.  Run dis nuff thangs up in parallel.
If tha evaluated number is less than 1 then 1 is ghon be used. Y'all KNOW dat shit, muthafucka!  See also
\&\fB\-\-use\-cpus\-instead\-of\-cores\fR.
.IP "\fB\-\-jobs\fR \fIprocfile\fR" 9
.IX Item "--jobs procfile"
.PD 0
.IP "\fB\-j\fR \fIprocfile\fR" 9
.IX Item "-j procfile"
.IP "\fB\-\-max\-procs\fR \fIprocfile\fR" 9
.IX Item "--max-procs procfile"
.IP "\fB\-P\fR \fIprocfile\fR" 9
.IX Item "-P procfile"
.PD
Read parameta from file. Use tha content of \fIprocfile\fR as parameter
for \fI\-j\fR. E.g. \fIprocfile\fR could contain tha strang 100% or +2 or
10. If \fIprocfile\fR is chizzled when a thang completes, \fIprocfile\fR is
read again n' again n' again n' tha freshly smoked up number of thangs is computed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha number is
lower than before, hustlin thangs is ghon be allowed ta finish but freshly smoked up thangs
will not be started until tha wanted number of thangs has been reached.
This make it possible ta chizzle tha number of simultaneous hustlin
jobs while \s-1GNU \s0\fBparallel\fR is hustlin.
.IP "\fB\-\-keep\-order\fR" 9
.IX Item "--keep-order"
.PD 0
.IP "\fB\-k\fR" 9
.IX Item "-k"
.PD
Keep sequence of output same as tha order of input. Normally the
output of a thang is ghon be printed as soon as tha thang completes. Try this
to peep tha difference:
.Sp
.Vb 2
\&  parallel \-j4 chill {}\e; echo {} ::: 2 1 4 3
\&  parallel \-j4 \-k chill {}\e; echo {} ::: 2 1 4 3
.Ve
.IP "\fB\-L\fR \fImax-lines\fR" 9
.IX Item "-L max-lines"
When used wit \fB\-\-pipe\fR: Read recordz of \fImax-lines\fR.
.Sp
When used otherwise: Use at most \fImax-lines\fR nonblank input lines per
command line.  Trailin blanks cause a input line ta be logically
continued on tha next input line.
.Sp
\&\fB\-L 0\fR means read one line yo, but bang 0 arguments on tha command
line.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.IP "\fB\-\-max\-lines\fR[=\fImax-lines\fR]" 9
.IX Item "--max-lines[=max-lines]"
.PD 0
.IP "\fB\-l\fR[\fImax-lines\fR]" 9
.IX Item "-l[max-lines]"
.PD
When used wit \fB\-\-pipe\fR: Read recordz of \fImax-lines\fR.
.Sp
When used otherwise: Synonym fo' tha \fB\-L\fR option. I aint talkin' bout chicken n' gravy biatch.  Unlike \fB\-L\fR, the
\&\fImax-lines\fR argument is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If \fImax-lines\fR aint specified,
it defaults ta one.  Da \fB\-l\fR option is deprecated since tha \s-1POSIX\s0
standard specifies \fB\-L\fR instead.
.Sp
\&\fB\-l 0\fR be a alias fo' \fB\-l 1\fR.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.IP "\fB\-\-load\fR \fImax-load\fR (beta testing)" 9
.IX Item "--load max-load (beta testing)"
Do not start freshly smoked up thangs on a given computa unless tha number of hustlin
processes on tha computa is less than \fImax-load\fR. \fImax-load\fR uses
the same syntax as \fB\-\-jobs\fR, so \fI100%\fR fo' one per \s-1CPU\s0 be a valid
setting. Only difference is 0 which is interpreted as 0.01.
.IP "\fB\-\-controlmaster\fR (experimental)" 9
.IX Item "--controlmasta (experimental)"
.PD 0
.IP "\fB\-M\fR (experimental)" 9
.IX Item "-M (experimental)"
.PD
Use sshz ControlMasta ta make ssh connections fasta n' shit. Useful if thangs
run remote n' is straight-up fast ta run. I aint talkin' bout chicken n' gravy biatch. This is disabled fo' sshlogins
that specify they own ssh command.
.IP "\fB\-\-xargs\fR" 9
.IX Item "--xargs"
Multiple arguments, n' you can put dat on yo' toast. Insert as nuff arguments as tha command line
length permits.
.Sp
If \fB{}\fR aint used tha arguments is ghon be appended ta the
line.  If \fB{}\fR is used multiple times each \fB{}\fR is ghon be replaced
with all tha arguments.
.Sp
Support fo' \fB\-\-xargs\fR wit \fB\-\-sshlogin\fR is limited n' may fail.
.Sp
See also \fB\-X\fR fo' context replace. If up in doubt use \fB\-X\fR as dat will
most likely do what tha fuck is needed.
.IP "\fB\-m\fR" 9
.IX Item "-m"
Multiple arguments, n' you can put dat on yo' toast. Insert as nuff arguments as tha command line
length permits, n' you can put dat on yo' toast. If multiple thangs is bein run up in parallel: distribute
the arguments evenly among tha thangs. Use \fB\-j1\fR ta avoid all dis bullshit.
.Sp
If \fB{}\fR aint used tha arguments is ghon be appended ta the
line.  If \fB{}\fR is used multiple times each \fB{}\fR is ghon be replaced
with all tha arguments.
.Sp
Support fo' \fB\-m\fR wit \fB\-\-sshlogin\fR is limited n' may fail.
.Sp
See also \fB\-X\fR fo' context replace. If up in doubt use \fB\-X\fR as dat will
most likely do what tha fuck is needed.
.IP "\fB\-\-minversion\fR \fIversion\fR" 9
.IX Item "--minversion version"
Print tha version \s-1GNU \s0\fBparallel\fR n' exit.  If tha current version of
\&\s-1GNU \s0\fBparallel\fR is less than \fIversion\fR tha exit code is
255. Otherwise it is 0.
.Sp
This is useful fo' scripts dat depend on features only available from
a certain version of \s-1GNU \s0\fBparallel\fR.
.IP "\fB\-\-nonall\fR" 9
.IX Item "--nonall"
\&\fB\-\-onall\fR wit no arguments, n' you can put dat on yo' toast. Run tha command on all computas given
with \fB\-\-sshlogin\fR but take no arguments, n' you can put dat on yo' toast. \s-1GNU \s0\fBparallel\fR will log
into \fB\-\-jobs\fR number of computas up in parallel n' run tha thang on the
computer n' shit. \fB\-j\fR adjusts how tha fuck nuff computas ta log tha fuck into up in parallel.
.Sp
This is useful fo' hustlin tha same command (e.g. uptime) on a list of
servers.
.IP "\fB\-\-onall\fR" 9
.IX Item "--onall"
Run all tha thangs on all computas given wit \fB\-\-sshlogin\fR. \s-1GNU
\&\s0\fBparallel\fR will log tha fuck into \fB\-\-jobs\fR number of computas up in parallel
and run one thang at a time on tha computer n' shit. Da order of tha thangs will
not be chizzled yo, but some computas may finish before others. \fB\-j\fR
adjusts how tha fuck nuff computas ta log tha fuck into up in parallel.
.Sp
When rockin \fB\-\-group\fR tha output is ghon be grouped by each server, so
all tha output from one server is ghon be grouped together.
.IP "\fB\-\-output\-as\-files\fR" 9
.IX Item "--output-as-files"
.PD 0
.IP "\fB\-\-outputasfiles\fR" 9
.IX Item "--outputasfiles"
.IP "\fB\-\-files\fR" 9
.IX Item "--files"
.PD
Instead of printin tha output ta stdout (standard output) tha output
of each thang is saved up in a gangbangin' file n' tha filename is then printed.
.IP "\fB\-\-pipe\fR (beta testing)" 9
.IX Item "--pipe (beta testing)"
.PD 0
.IP "\fB\-\-spreadstdin\fR (beta testing)" 9
.IX Item "--spreadstdin (beta testing)"
.PD
Spread input ta thangs on stdin (standard input). Read a funky-ass block of data
from stdin (standard input) n' give one block of data as input ta one
job.
.Sp
Da block size is determined by \fB\-\-block\fR. Da strings \fB\-\-recstart\fR
and \fB\-\-recend\fR tell \s-1GNU \s0\fBparallel\fR how tha fuck a record starts and/or
ends. Da block read gonna git tha final partial record removed before
the block is passed on ta tha thang. Da partial record will be
prepended ta next block.
.Sp
If \fB\-\-recstart\fR is given dis is ghon be used ta split at record start.
.Sp
If \fB\-\-recend\fR is given dis is ghon be used ta split at record end.
.Sp
If both \fB\-\-recstart\fR n' \fB\-\-recend\fR is given both gonna git to
match ta find a split position.
.Sp
If neither \fB\-\-recstart\fR nor \fB\-\-recend\fR is given \fB\-\-recend\fR
defaults ta '\en'. To have no record separator use \fB\-\-recend ""\fR.
.Sp
\&\fB\-\-files\fR is often used wit \fB\-\-pipe\fR.
.IP "\fB\-\-plain\fR" 9
.IX Item "--plain"
Ignore any \fB\-\-profile\fR, \f(CW$PARALLEL\fR, ~/.parallel/config, and
\&\fB\-\-tollef\fR ta git full control on tha command line (used by \s-1GNU
\&\s0\fBparallel\fR internally when called wit \fB\-\-sshlogin\fR).
.IP "\fB\-\-progress\fR" 9
.IX Item "--progress"
Show progress of computations. List tha computas involved up in tha task
with number of \s-1CPU\s0 cores detected n' tha max number of thangs to
run. I aint talkin' bout chicken n' gravy biatch fo' realz. Afta dat show progress fo' each computer: number of hustlin
jobs, number of completed thangs, n' cementage of all thangs done by
this computer n' shit. Da cementage will only be available afta all thangs
have been scheduled as \s-1GNU \s0\fBparallel\fR only read tha next thang when
ready ta schedule it \- dis is ta avoid wastin time n' memory by
readin every last muthafuckin thang at startup.
.Sp
By bustin  \s-1GNU \s0\fBparallel\fR \s-1SIGUSR2\s0 you can toggle turnin on/off
\&\fB\-\-progress\fR on a hustlin \s-1GNU \s0\fBparallel\fR process.
.Sp
See also: \fB\-\-eta\fR
.IP "\fB\-\-max\-args\fR=\fImax-args\fR (beta testing)" 9
.IX Item "--max-args=max-args (beta testing)"
.PD 0
.IP "\fB\-n\fR \fImax-args\fR (beta testing)" 9
.IX Item "-n max-args (beta testing)"
.PD
Use at most \fImax-args\fR arguments per command line.  Fewer than
\&\fImax-args\fR arguments is ghon be used if tha size (see tha \fB\-s\fR option)
is exceeded, unless tha \fB\-x\fR option is given, up in which case
\&\s-1GNU \s0\fBparallel\fR will exit.
.Sp
\&\fB\-n 0\fR means read one argument yo, but bang 0 arguments on tha command
line.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR is set.
.IP "\fB\-\-max\-replace\-args\fR=\fImax-args\fR (beta testing)" 9
.IX Item "--max-replace-args=max-args (beta testing)"
.PD 0
.IP "\fB\-N\fR \fImax-args\fR (beta testing)" 9
.IX Item "-N max-args (beta testing)"
.PD
Use at most \fImax-args\fR arguments per command line. Like \fB\-n\fR but
also make replacement strings \fB{1}\fR .. \fB{\fR\fImax-args\fR\fB}\fR that
represents argument 1 .. \fImax-args\fR. If too few args tha \fB{\fR\fIn\fR\fB}\fR will
be empty.
.Sp
\&\fB\-N 0\fR means read one argument yo, but bang 0 arguments on tha command
line.
.Sp
This will set tha balla of tha homedir ta tha user:
.Sp
\&\fBtr ':' '\en' < /etc/passwd | parallel \-N7 chown {1} {6}\fR
.Sp
Implies \fB\-X\fR unless \fB\-m\fR or \fB\-\-pipe\fR is set.
.Sp
When used wit \fB\-\-pipe\fR \fB\-N\fR is tha number of recordz ta read. Y'all KNOW dat shit, muthafucka! This
is somewhat slower than \fB\-\-block\fR.
.IP "\fB\-\-max\-line\-length\-allowed\fR" 9
.IX Item "--max-line-length-allowed"
Print tha maximal number of charactas allowed on tha command line and
exit (used by \s-1GNU \s0\fBparallel\fR itself ta determine tha line length
on remote computers).
.IP "\fB\-\-number\-of\-cpus\fR" 9
.IX Item "--number-of-cpus"
Print tha number of physical CPUs n' exit (used by \s-1GNU \s0\fBparallel\fR
itself ta determine tha number of physical CPUs on remote computers).
.IP "\fB\-\-number\-of\-cores\fR" 9
.IX Item "--number-of-cores"
Print tha number of \s-1CPU\s0 cores n' exit (used by \s-1GNU \s0\fBparallel\fR itself
to determine tha number of \s-1CPU\s0 cores on remote computers).
.IP "\fB\-\-nice\fR \fIniceness\fR" 9
.IX Item "--nice sickness"
Run tha command at dis sickness. For simple commandz you can just add
\&\fBnice\fR up in front of tha command. Y'all KNOW dat shit, muthafucka! But if tha command consistz of more
sub commandz (Like: ls|wc) then prependin \fBnice\fR aint gonna always
work. \fB\-\-nice\fR will make shizzle all sub commandz is sickd.
.IP "\fB\-\-interactive\fR" 9
.IX Item "--interactive"
.PD 0
.IP "\fB\-p\fR" 9
.IX Item "-p"
.PD
Prompt tha user bout whether ta run each command line n' read a line
from tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Only run tha command line if tha response starts
with 'y' or 'Y'.  Implies \fB\-t\fR.
.IP "\fB\-\-profile\fR \fIprofilename\fR" 9
.IX Item "--profile profilename"
.PD 0
.IP "\fB\-J\fR \fIprofilename\fR" 9
.IX Item "-J profilename"
.PD
Use flava \fIprofilename\fR fo' options. This is useful if you want to
have multiple profiles. Yo ass could have one flava fo' hustlin thangs in
parallel on tha local computa n' a gangbangin' finger-lickin' different flava fo' hustlin thangs
on remote computers. Right back up in yo muthafuckin ass. See tha section \s-1PROFILE FILES\s0 fo' examples.
.Sp
\&\fIprofilename\fR correspondz ta tha file ~/.parallel/\fIprofilename\fR.
.Sp
Yo ass can give multiple profilez by repeatin \fB\-\-profile\fR. If parts of
the profilez conflict, tha lata ones is ghon be used.
.Sp
Default: config
.IP "\fB\-\-quote\fR" 9
.IX Item "--quote"
.PD 0
.IP "\fB\-q\fR" 9
.IX Item "-q"
.PD
Quote \fIcommand\fR.  This will quote tha command line so special
charactas is not interpreted by tha shell. Right back up in yo muthafuckin ass. See tha section
\&\s-1QUOTING.\s0 Most playas aint NEVER gonna need all dis bullshit.  Quotin is disabled by
default.
.IP "\fB\-\-no\-run\-if\-empty\fR" 9
.IX Item "--no-run-if-empty"
.PD 0
.IP "\fB\-r\fR" 9
.IX Item "-r"
.PD
If tha stdin (standard input) only gotz nuff whitespace, do not run tha command.
.Sp
If used wit \fB\-\-pipe\fR dis is slow.
.IP "\fB\-\-recstart\fR \fIstartstring\fR" 9
.IX Item "--recstart startstring"
.PD 0
.IP "\fB\-\-recend\fR \fIendstring\fR" 9
.IX Item "--recend endstring"
.PD
If \fB\-\-recstart\fR is given \fIstartstring\fR is ghon be used ta split at record start.
.Sp
If \fB\-\-recend\fR is given \fIendstring\fR is ghon be used ta split at record end.
.Sp
If both \fB\-\-recstart\fR n' \fB\-\-recend\fR is given tha combined string
\&\fIendstring\fR\fIstartstring\fR will gotta match ta find a split
position. I aint talkin' bout chicken n' gravy biatch. This is useful if either \fIstartstring\fR or \fIendstring\fR
match up in tha middle of a record.
.Sp
If neither \fB\-\-recstart\fR nor \fB\-\-recend\fR is given then \fB\-\-recend\fR
defaults ta '\en'. To have no record separator use \fB\-\-recend ""\fR.
.Sp
\&\fB\-\-recstart\fR n' \fB\-\-recend\fR is used wit \fB\-\-pipe\fR.
.Sp
Use \fB\-\-regexp\fR ta interpret \fB\-\-recstart\fR n' \fB\-\-recend\fR as regular
expressions. This is slow, however.
.IP "\fB\-\-regexp\fR" 9
.IX Item "--regexp"
Use \fB\-\-regexp\fR ta interpret \fB\-\-recstart\fR n' \fB\-\-recend\fR as regular
expressions. This is slow, however.
.IP "\fB\-\-remove\-rec\-sep\fR" 9
.IX Item "--remove-rec-sep"
.PD 0
.IP "\fB\-\-removerecsep\fR" 9
.IX Item "--removerecsep"
.IP "\fB\-\-rrs\fR" 9
.IX Item "--rrs"
.PD
Remove tha text matched by \fB\-\-recstart\fR n' \fB\-\-recend\fR before piping
it ta tha command.
.Sp
Only used wit \fB\-\-pipe\fR.
.IP "\fB\-\-results\fR \fIprefix\fR" 9
.IX Item "--results prefix"
.PD 0
.IP "\fB\-\-res\fR \fIprefix\fR" 9
.IX Item "--res prefix"
.PD
Save tha output tha fuck into files. Da filez is ghon be stored up in a gangbangin' finger-lickin' directory tree
rooted at \fIprefix\fR.  Within dis directory tree, each command will result
in two files: \fIprefix\fR/<\s-1ARGS\s0>/stdout n' \fIprefix\fR/<\s-1ARGS\s0>/stderr, where
<\s-1ARGS\s0> be a sequence of directories representin tha header of tha input
source (if rockin \fB\-\-header :\fR) or tha number of tha input source and
correspondin joints.
.Sp
E.g:
.Sp
.Vb 1
\&  parallel \-\-header : \-\-results foo echo {a} {b} ::: a I Pt II ::: b Pt III Pt IIII
.Ve
.Sp
will generate tha files:
.Sp
.Vb 8
\&  foo/a/I/b/III/stderr
\&  foo/a/I/b/IIII/stderr
\&  foo/a/II/b/III/stderr
\&  foo/a/II/b/IIII/stderr
\&  foo/a/I/b/III/stdout
\&  foo/a/I/b/IIII/stdout
\&  foo/a/II/b/III/stdout
\&  foo/a/II/b/IIII/stdout
.Ve
.Sp
and
.Sp
.Vb 1
\&  parallel \-\-results foo echo {1} {2} ::: I Pt II ::: Pt III Pt IIII
.Ve
.Sp
will generate tha files:
.Sp
.Vb 8
\&  foo/1/I/2/III/stderr
\&  foo/1/I/2/IIII/stderr
\&  foo/1/II/2/III/stderr
\&  foo/1/II/2/IIII/stderr
\&  foo/1/I/2/III/stdout
\&  foo/1/I/2/IIII/stdout
\&  foo/1/II/2/III/stdout
\&  foo/1/II/2/IIII/stdout
.Ve
.Sp
See also \fB\-\-files\fR, \fB\-\-header\fR, \fB\-\-joblog\fR.
.IP "\fB\-\-resume\fR" 9
.IX Item "--resume"
Resumes from tha last unfinished thang. By readin \fB\-\-joblog\fR \s-1GNU
\&\s0\fBparallel\fR will figure up tha last unfinished thang n' continue from
there, so peek-a-boo, clear tha way, I be comin' thru fo'sho fo' realz. As \s-1GNU \s0\fBparallel\fR only looks all up in tha sequence numbers in
\&\fB\-\-joblog\fR then tha input, tha command, n' \fB\-\-joblog\fR all have to
remain unchanged; otherwise \s-1GNU \s0\fBparallel\fR may run wack commands.
.Sp
See also: \fB\-\-joblog\fR, \fB\-\-resume\-failed\fR.
.IP "\fB\-\-resume\-failed\fR" 9
.IX Item "--resume-failed"
Retry all failed n' resume from tha last unfinished thang. By reading
\&\fB\-\-joblog\fR \s-1GNU \s0\fBparallel\fR will figure up tha failed thangs n' run
those again. I aint talkin' bout chicken n' gravy biatch fo' realz. Afta dat it will resume last unfinished thang and
continue from there, so peek-a-boo, clear tha way, I be comin' thru fo'sho fo' realz. As \s-1GNU \s0\fBparallel\fR only looks all up in tha sequence
numbers up in \fB\-\-joblog\fR then tha input, tha command, n' \fB\-\-joblog\fR
all gotta remain unchanged; otherwise \s-1GNU \s0\fBparallel\fR may run wrong
commands.
.Sp
See also: \fB\-\-joblog\fR, \fB\-\-resume\fR.
.IP "\fB\-\-retries\fR \fIn\fR" 9
.IX Item "--retries n"
If a thang fails, retry it on another computer n' shit. Do dis \fIn\fR times. If
there is fewer than \fIn\fR computas up in \fB\-\-sshlogin\fR \s-1GNU \s0\fBparallel\fR will
re-use tha computers. This is useful if some thangs fail fo' no apparent
reason (like fuckin network failure).
.IP "\fB\-\-return\fR \fIfilename\fR (beta testing)" 9
.IX Item "--return filename (beta testing)"
Transfer filez from remote computers. \fB\-\-return\fR is used with
\&\fB\-\-sshlogin\fR when tha arguments is filez on tha remote computers. When
processin is done tha file \fIfilename\fR is ghon be transferred
from tha remote computa rockin \fBrsync\fR n' is ghon be put relatizzle to
the default login dir. Shiiit, dis aint no joke. E.g.
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-return {.}.out bust a nut on {.}.out
.Ve
.Sp
This will transfer tha file \fI\f(CI$HOME\fI/foo/bar.out\fR from tha computer
\&\fIserver.example.com\fR ta tha file \fIfoo/bar.out\fR afta hustlin
\&\fBtouch foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-return {.}.out bust a nut on {.}.out
.Ve
.Sp
This will transfer tha file \fI/tmp/foo/bar.out\fR from tha computer
\&\fIserver.example.com\fR ta tha file \fI/tmp/foo/bar.out\fR afta hustlin
\&\fBtouch /tmp/foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
Multiple filez can be transferred by repeatin tha options multiple
times:
.Sp
.Vb 3
\&  echo /tmp/foo/bar.txt | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-return {.}.out \-\-return {.}.out2 bust a nut on {.}.out {.}.out2
.Ve
.Sp
\&\fB\-\-return\fR is often used wit \fB\-\-transfer\fR n' \fB\-\-cleanup\fR.
.Sp
\&\fB\-\-return\fR is ignored when used wit \fB\-\-sshlogin :\fR or when not used
with \fB\-\-sshlogin\fR.
.IP "\fB\-\-max\-chars\fR=\fImax-chars\fR" 9
.IX Item "--max-chars=max-chars"
.PD 0
.IP "\fB\-s\fR \fImax-chars\fR" 9
.IX Item "-s max-chars"
.PD
Use at most \fImax-chars\fR charactas per command line, includin the
command n' initial-arguments n' tha terminatin nulls all up in tha endz of
the argument strings.  Da phattest allowed value is system-dependent,
and is calculated as tha argument length limit fo' exec, less tha size
of yo' environment.  Da default value is tha maximum.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR is set.
.IP "\fB\-\-show\-limits\fR" 9
.IX Item "--show-limits"
Display tha limits on tha command-line length which is imposed by the
operatin system n' tha \fB\-s\fR option. I aint talkin' bout chicken n' gravy biatch.  Pipe tha input from /dev/null
(and like specify \-\-no\-run\-if\-empty) if you don't want \s-1GNU \s0\fBparallel\fR
to do anything.
.IP "\fB\-\-semaphore\fR" 9
.IX Item "--semaphore"
Work as a cold-ass lil countin semaphore. \fB\-\-semaphore\fR will cause \s-1GNU
\&\s0\fBparallel\fR ta start \fIcommand\fR up in tha background. Y'all KNOW dat shit, muthafucka! When tha number of
simultaneous thangs is reached, \s-1GNU \s0\fBparallel\fR will wait fo' one of
these ta complete before startin another command.
.Sp
\&\fB\-\-semaphore\fR implies \fB\-\-bg\fR unless \fB\-\-fg\fR is specified.
.Sp
\&\fB\-\-semaphore\fR implies \fB\-\-semaphorename `tty`\fR unless
\&\fB\-\-semaphorename\fR is specified.
.Sp
Used wit \fB\-\-fg\fR, \fB\-\-wait\fR, n' \fB\-\-semaphorename\fR.
.Sp
Da command \fBsem\fR be a alias fo' \fBparallel \-\-semaphore\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-\-semaphorename\fR \fIname\fR" 9
.IX Item "--semaphorename name"
.PD 0
.IP "\fB\-\-id\fR \fIname\fR" 9
.IX Item "--id name"
.PD
Use \fBname\fR as tha name of tha semaphore. Default is tha name of the
controllin tty (output from \fBtty\fR).
.Sp
Da default normally works as expected when used interactively yo, but
when used up in a script \fIname\fR should be set. \fI$$\fR or \fImy_task_name\fR
are often a phat value.
.Sp
Da semaphore is stored up in ~/.parallel/semaphores/
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-\-semaphoretimeout\fR \fIsecs\fR (not implemented)" 9
.IX Item "--semaphoretimeout secs (not implemented)"
If tha semaphore aint busted out within secs seconds, take it anyway.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-\-seqreplace\fR \fIreplace-str\fR" 9
.IX Item "--seqreplace replace-str"
Use tha replacement strang \fIreplace-str\fR instead of \fB{#}\fR for
job sequence number.
.IP "\fB\-\-shebang\fR" 9
.IX Item "--shebang"
.PD 0
.IP "\fB\-\-hashbang\fR" 9
.IX Item "--hashbang"
.PD
\&\s-1GNU \s0\fBparallel\fR can be called as a gangbangin' finger-lickin' dirty-ass shebang (#!) command as tha first
line of a script. Da content of tha file is ghon be treated as
inputsource.
.Sp
Like this:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang \-r traceroute
\&
\&  foss.org.my
\&  debian.org
\&  freenetproject.org
.Ve
.Sp
\&\fB\-\-shebang\fR must be set as tha straight-up original gangsta option.
.IP "\fB\-\-shebang\-wrap\fR" 9
.IX Item "--shebang-wrap"
\&\s-1GNU \s0\fBparallel\fR can parallelize scripts by rappin bout da shebang
line. If tha program can be run like this:
.Sp
.Vb 1
\&  pussaaaaay arguments | parallel the_program
.Ve
.Sp
then tha script can be chizzled to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /the/original/parser \-\-with\-options
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/python
.Ve
.Sp
If tha program can be run like this:
.Sp
.Vb 1
\&  pussaaaaay data | parallel \-\-pipe the_program
.Ve
.Sp
then tha script can be chizzled to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /the/original/parser \-\-with\-options
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /usr/bin/perl \-w
.Ve
.Sp
\&\fB\-\-shebang\-wrap\fR must be set as tha straight-up original gangsta option.
.IP "\fB\-\-shellquote\fR" 9
.IX Item "--shellquote"
Do not run tha command but quotes dat shit. Useful fo' makin quoted
composed commandz fo' \s-1GNU \s0\fBparallel\fR.
.IP "\fB\-\-skip\-first\-line\fR" 9
.IX Item "--skip-first-line"
Do not use tha straight-up original gangsta line of input (used by \s-1GNU \s0\fBparallel\fR itself
when called wit \fB\-\-shebang\fR).
.IP "\fB\-\-sshdelay\fR \fIsecs\fR (beta testing)" 9
.IX Item "--sshdelay secs (beta testing)"
Delay startin next ssh by \fIsecs\fR seconds. \s-1GNU \s0\fBparallel\fR will pause
\&\fIsecs\fR secondz afta startin each ssh. \fIsecs\fR can be less than 1
seconds.
.IP "\fB\-S\fR \fI[ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]\fR" 9
.IX Item "-S [ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]"
.PD 0
.IP "\fB\-\-sshlogin\fR \fI[ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]\fR" 9
.IX Item "--sshlogin [ncpu/]sshlogin[,[ncpu/]sshlogin[,...]]"
.PD
Distribute thangs ta remote computers. Da thangs is ghon be run on a list of
remote computers.  \s-1GNU \s0\fBparallel\fR will determine tha number of \s-1CPU\s0
cores on tha remote computas n' run tha number of thangs as specified by
\&\fB\-j\fR.  If tha number \fIncpu\fR is given \s-1GNU \s0\fBparallel\fR will use this
number fo' number of \s-1CPU\s0 cores on tha host. Normally \fIncpu\fR will not
be needed.
.Sp
An \fIsshlogin\fR iz of tha form:
.Sp
.Vb 1
\&  [sshcommand [options]][username@]hostname
.Ve
.Sp
Da sshlogin must not require a password.
.Sp
Da sshlogin ':' is special, it means 'no ssh' n' will therefore run
on tha local computer.
.Sp
Da sshlogin '..' is special, it read sshlogins from ~/.parallel/sshloginfile
.Sp
Da sshlogin '\-' is special, too, it read sshlogins from stdin
(standard input).
.Sp
To specify mo' sshlogins separate tha sshlogins by comma or repeat
the options multiple times.
.Sp
For examples: peep \fB\-\-sshloginfile\fR.
.Sp
Da remote host must have \s-1GNU \s0\fBparallel\fR installed.
.Sp
\&\fB\-\-sshlogin\fR is known ta cause problems wit \fB\-m\fR n' \fB\-X\fR.
.Sp
\&\fB\-\-sshlogin\fR is often used wit \fB\-\-transfer\fR, \fB\-\-return\fR,
\&\fB\-\-cleanup\fR, n' \fB\-\-trc\fR.
.IP "\fB\-\-sshloginfile\fR \fIfilename\fR" 9
.IX Item "--sshloginfile filename"
.PD 0
.IP "\fB\-\-slf\fR \fIfilename\fR" 9
.IX Item "--slf filename"
.PD
File wit sshlogins. Da file consistz of sshlogins on separate
lines. Empty lines n' lines startin wit '#' is ignored. Y'all KNOW dat shit, muthafucka! Example:
.Sp
.Vb 10
\&  server.example.com
\&  username@server2.example.com
\&  8/my\-8\-core\-server.example.com
\&  2/my_other_username@my\-dualcore.example.net
\&  # This server has SSH hustlin on port 2222
\&  ssh \-p 2222 server.example.net
\&  4/ssh \-p 2222 quadserver.example.net
\&  # Use a gangbangin' finger-lickin' different ssh program
\&  myssh \-p 2222 \-l myusername hexacpu.example.net
\&  # Use a gangbangin' finger-lickin' different ssh program wit default number of cores
\&  //usr/local/bin/myssh \-p 2222 \-l myusername hexacpu.example.net
\&  # Use a gangbangin' finger-lickin' different ssh program wit 6 cores
\&  6//usr/local/bin/myssh \-p 2222 \-l myusername hexacpu.example.net
\&  # Assume 16 cores on tha local computer
\&  16/:
.Ve
.Sp
When rockin a gangbangin' finger-lickin' different ssh program tha last argument must be tha hostname.
.Sp
Multiple \fB\-\-sshloginfile\fR is allowed.
.Sp
Da sshloginfile '..' is special, it read sshlogins from
~/.parallel/sshloginfile
.Sp
Da sshloginfile '.' is special, it read sshlogins from
/etc/parallel/sshloginfile
.Sp
Da sshloginfile '\-' is special, too, it read sshlogins from stdin
(standard input).
.IP "\fB\-\-noswap\fR" 9
.IX Item "--noswap"
Do not start freshly smoked up thangs on a given computa if there is both swap-in and
swap-out activity.
.Sp
Da swap activitizzle is only sampled every last muthafuckin 10 secondz as tha sampling
takes 1 second ta do.
.Sp
Swap activitizzle is computed as (swap\-in)*(swap\-out) which up in practice is
a phat value: swappin up aint a problem, swappin up in aint a
problem yo, but both swappin up in n' up probably indicates a problem.
.IP "\fB\-\-silent\fR" 9
.IX Item "--silent"
Silent.  Da thang ta be run aint gonna be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is tha default.
Can be reversed wit \fB\-v\fR.
.IP "\fB\-\-tty\fR" 9
.IX Item "--tty"
Open terminal tty. If \s-1GNU \s0\fBparallel\fR is used fo' startin an
interactizzle program then dis option may be needed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it will start only
one thang at a time (i.e. \fB\-j1\fR), not buffer tha output (i.e. \fB\-u\fR),
and it will open a tty fo' tha thang. When tha thang is done, tha next thang
will git tha tty.
.IP "\fB\-\-tag\fR" 9
.IX Item "--tag"
Tag lines wit arguments, n' you can put dat on yo' toast. Each output line is ghon be prepended wit the
arguments n' \s-1TAB \s0(\et). When combined wit \fB\-\-onall\fR or \fB\-\-nonall\fR
the lines is ghon be prepended wit tha sshlogin instead.
.Sp
\&\fB\-\-tag\fR is ignored when rockin \fB\-u\fR.
.IP "\fB\-\-tagstring\fR \fIstr\fR" 9
.IX Item "--tagstrin str"
Tag lines wit a string. Each output line is ghon be prepended with
\&\fIstr\fR n' \s-1TAB \s0(\et). \fIstr\fR can contain replacement strings such as
{}.
.Sp
\&\fB\-\-tagstring\fR is ignored when rockin \fB\-u\fR, \fB\-\-onall\fR, n' \fB\-\-nonall\fR.
.IP "\fB\-\-tmpdir\fR \fIdirname\fR" 9
.IX Item "--tmpdir dirname"
Directory fo' temporary files. \s-1GNU \s0\fBparallel\fR normally buffers output
into temporary filez up in /tmp. By settin \fB\-\-tmpdir\fR you can use a
different dir fo' tha files. Right back up in yo muthafuckin ass. Settin \fB\-\-tmpdir\fR is equivalent to
settin \f(CW$TMPDIR\fR.
.IP "\fB\-\-timeout\fR \fIval\fR (alpha testing)" 9
.IX Item "--timeout val (alpha testing)"
Time up fo' command. Y'all KNOW dat shit, muthafucka! If tha command runs fo' longer than \fIval\fR
secondz it will git capped wit \s-1SIGTERM,\s0 followed by \s-1SIGTERM 200\s0 ms
later, followed by \s-1SIGKILL 200\s0 ms later.
.Sp
If \fIval\fR is followed by a % then tha timeout will dynamically be
computed as a cementage of tha smoothed average runtime. Only joints
> 100% will make sense.
.IP "\fB\-\-tollef\fR (obsolete \- is ghon be retired 20140222)" 9
.IX Item "--tollef (obsolete - is ghon be retired 20140222)"
Make \s-1GNU \s0\fBparallel\fR behave mo' like Tollefz parallel command. Y'all KNOW dat shit, muthafucka! It
activates \fB\-u\fR, \fB\-q\fR, n' \fB\-\-arg\-sep \-\-\fR. Well shiiiit, it also causes \fB\-l\fR to
change meanin ta \fB\-\-load\fR.
.Sp
Not givin '\-\-' is unsupported.
.Sp
\&\fBDo not use \-\-tollef unless you know what tha fuck yo ass is bustin\fR.
.Sp
To override use \fB\-\-gnu\fR.
.IP "\fB\-\-verbose\fR" 9
.IX Item "--verbose"
.PD 0
.IP "\fB\-t\fR" 9
.IX Item "-t"
.PD
Print tha thang ta be run on stderr (standard error).
.Sp
See also \fB\-v\fR n' \fB\-p\fR.
.IP "\fB\-\-transfer\fR (beta testing)" 9
.IX Item "--transfer (beta testing)"
Transfer filez ta remote computers. \fB\-\-transfer\fR is used with
\&\fB\-\-sshlogin\fR when tha arguments is filez n' should be transferred to
the remote computers. Da filez is ghon be transferred rockin \fBrsync\fR and
will be put relatizzle ta tha default login dir. Shiiit, dis aint no joke. E.g.
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer wc
.Ve
.Sp
This will transfer tha file \fIfoo/bar.txt\fR ta tha computer
\&\fIserver.example.com\fR ta tha file \fI\f(CI$HOME\fI/foo/bar.txt\fR before hustlin
\&\fBwc foo/bar.txt\fR on \fIserver.example.com\fR.
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \-\-transfer wc
.Ve
.Sp
This will transfer tha file \fIfoo/bar.txt\fR ta tha computer
\&\fIserver.example.com\fR ta tha file \fI/tmp/foo/bar.txt\fR before hustlin
\&\fBwc /tmp/foo/bar.txt\fR on \fIserver.example.com\fR.
.Sp
\&\fB\-\-transfer\fR is often used wit \fB\-\-return\fR n' \fB\-\-cleanup\fR.
.Sp
\&\fB\-\-transfer\fR is ignored when used wit \fB\-\-sshlogin :\fR or when not used wit \fB\-\-sshlogin\fR.
.IP "\fB\-\-trc\fR \fIfilename\fR" 9
.IX Item "--trc filename"
Transfer, Return, Cleanup. Right back up in yo muthafuckin ass. Short hand for:
.Sp
\&\fB\-\-transfer\fR \fB\-\-return\fR \fIfilename\fR \fB\-\-cleanup\fR
.IP "\fB\-\-trim\fR <n|l|r|lr|rl>" 9
.IX Item "--trim <n|l|r|lr|rl>"
Trim white space up in input.
.RS 9
.IP "n" 4
.IX Item "n"
No trim. Input aint modified. Y'all KNOW dat shit, muthafucka! This is tha default.
.IP "l" 4
.IX Item "l"
Left trim. Remove white space from start of input. E.g. \*(L" a funky-ass bc \*(R" \-> \*(L"a bc \*(R".
.IP "r" 4
.IX Item "r"
Right trim. Remove white space from end of input. E.g. \*(L" a funky-ass bc \*(R" \-> \*(L" a funky-ass bc\*(R".
.IP "lr" 4
.IX Item "lr"
.PD 0
.IP "rl" 4
.IX Item "rl"
.PD
Both trim. Remove white space from both start n' end of input. E.g. \*(L"
a bc \*(R" \-> \*(L"a bc\*(R". This is tha default if \fB\-\-colsep\fR is used.
.RE
.RS 9
.RE
.IP "\fB\-\-ungroup\fR" 9
.IX Item "--ungroup"
.PD 0
.IP "\fB\-u\fR" 9
.IX Item "-u"
.PD
Ungroup output.  Output is printed quicker than a muthafucka n' by passes
\&\s-1GNU \s0\fBparallel\fR internal processing. This may cause output from
different commandz ta be mixed thus should only be used if you do not
care bout tha output. Compare these:
.Sp
\&\fBparallel \-j0 'sleep {};echo \-n start{};sleep {};echo {}end' ::: 1 2 3 4\fR
.Sp
\&\fBparallel \-u \-j0 'sleep {};echo \-n start{};sleep {};echo {}end' ::: 1 2 3 4\fR
.Sp
It also disablez \fB\-\-tag\fR. \s-1GNU \s0\fBparallel\fR runs fasta wit \fB\-u\fR. Can
be reversed wit \fB\-\-group\fR.
.IP "\fB\-\-extensionreplace\fR \fIreplace-str\fR" 9
.IX Item "--extensionreplace replace-str"
.PD 0
.IP "\fB\-\-er\fR \fIreplace-str\fR" 9
.IX Item "--er replace-str"
.PD
Use tha replacement strang \fIreplace-str\fR instead of {.} fo' input line without extension.
.IP "\fB\-\-use\-cpus\-instead\-of\-cores\fR" 9
.IX Item "--use-cpus-instead-of-cores"
Count tha number of physical CPUs instead of \s-1CPU\s0 cores. When computing
how nuff thangs ta run simultaneously relatizzle ta tha number of \s-1CPU\s0 cores
you can ask \s-1GNU \s0\fBparallel\fR ta instead peep tha number of physical
CPUs. This will make sense fo' computas dat have hyperthreadin as
two thangs hustlin on one \s-1CPU\s0 wit hyperthreadin will run slower than
two thangs hustlin on two physical CPUs. Right back up in yo muthafuckin ass. Some multi-core CPUs can run
fasta if only one thread is hustlin per physical \s-1CPU.\s0 Most playas will
not need dis option.
.IP "\fB\-v\fR" 9
.IX Item "-v"
Verbose.  Print tha thang ta be run on stdout (standard output). Can be reversed
with \fB\-\-silent\fR. Right back up in yo muthafuckin ass. See also \fB\-t\fR.
.Sp
Use \fB\-v\fR \fB\-v\fR ta print tha wrappin ssh command when hustlin remotely.
.IP "\fB\-\-version\fR" 9
.IX Item "--version"
.PD 0
.IP "\fB\-V\fR" 9
.IX Item "-V"
.PD
Print tha version \s-1GNU \s0\fBparallel\fR n' exit.
.IP "\fB\-\-workdir\fR \fImydir\fR (beta testing)" 9
.IX Item "--workdir mydir (beta testing)"
.PD 0
.IP "\fB\-\-wd\fR \fImydir\fR (beta testing)" 9
.IX Item "--wd mydir (beta testing)"
.PD
Filez transferred rockin \fB\-\-transfer\fR n' \fB\-\-return\fR is ghon be relative
to \fImydir\fR on remote computers, n' tha command is ghon be executed in
the dir \fImydir\fR.
.Sp
Da special \fImydir\fR value \fB...\fR will create hustlin dirs under
\&\fB~/.parallel/tmp/\fR on tha remote computers. If \fB\-\-cleanup\fR is given
these dirs is ghon be removed.
.Sp
Da special \fImydir\fR value \fB.\fR uses tha current hustlin dir. Shiiit, dis aint no joke.  If the
current hustlin dir is beneath yo' home dir, tha value \fB.\fR is
treated as tha relatizzle path ta yo' home dir. Shiiit, dis aint no joke. This means dat if your
home dir is different on remote computas (e.g. if yo' login is
different) tha relatizzle path will still be relatizzle ta yo' home dir.
.Sp
To peep tha difference try:
.Sp
\&\fBparallel \-S server pwd ::: ""\fR
.Sp
\&\fBparallel \-\-wd . \-S server pwd ::: ""\fR
.Sp
\&\fBparallel \-\-wd ... \-S server pwd ::: ""\fR
.IP "\fB\-\-wait\fR" 9
.IX Item "--wait"
Wait fo' all commandz ta complete.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-X\fR" 9
.IX Item "-X"
Multiple arguments wit context replace. Insert as nuff arguments as
the command line length permits, n' you can put dat on yo' toast. If multiple thangs is bein run in
parallel: distribute tha arguments evenly among tha thangs. Use \fB\-j1\fR
to avoid all dis bullshit.
.Sp
If \fB{}\fR aint used tha arguments is ghon be appended ta tha line.  If
\&\fB{}\fR is used as part of a word (like \fIpic{}.jpg\fR) then tha whole
word is ghon be repeated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If \fB{}\fR is used multiple times each \fB{}\fR will
be replaced wit tha arguments.
.Sp
Normally \fB\-X\fR will do tha right thang, whereas \fB\-m\fR can give
unexpected thangs up in dis biatch if \fB{}\fR is used as part of a word.
.Sp
Support fo' \fB\-X\fR wit \fB\-\-sshlogin\fR is limited n' may fail.
.Sp
See also \fB\-m\fR.
.IP "\fB\-\-exit\fR" 9
.IX Item "--exit"
.PD 0
.IP "\fB\-x\fR" 9
.IX Item "-x"
.PD
Exit if tha size (see tha \fB\-s\fR option) is exceeded.
.IP "\fB\-\-xapply\fR" 9
.IX Item "--xapply"
Read multiple input sources like \fBxapply\fR. If multiple input sources
are given, one argument is ghon be read from each of tha input
sources. Da arguments can be accessed up in tha command as \fB{1}\fR
\&.. \fB{\fR\fIn\fR\fB}\fR, so \fB{1}\fR is ghon be a line from tha straight-up original gangsta input source, and
\&\fB{6}\fR will refer ta tha line wit tha same line number from tha 6th
input source.
.Sp
Compare these two:
.Sp
.Vb 2
\&  parallel echo {1} {2} ::: 1 2 3 ::: a funky-ass b c
\&  parallel \-\-xapply echo {1} {2} ::: 1 2 3 ::: a funky-ass b c
.Ve
.Sp
See also \fB\-\-header\fR.
.SH "EXAMPLE: Workin as xargs \-n1 fo' realz. Argument appending"
.IX Header "EXAMPLE: Workin as xargs -n1 fo' realz. Argument appending"
\&\s-1GNU \s0\fBparallel\fR can work similar ta \fBxargs \-n1\fR.
.PP
To compress all html filez rockin \fBgzip\fR run:
.PP
\&\fBfind . \-name '*.html' | parallel gzip\fR
.PP
If tha file names may contain a newline use \fB\-0\fR. Right back up in yo muthafuckin ass. Substitute \s-1FOO BAR\s0 with
\&\s-1FUBAR\s0 up in all filez up in dis dir n' subdirs:
.PP
\&\fBfind . \-type f \-print0 | parallel \-q0 perl \-i \-pe 's/FOO BAR/FUBAR/g'\fR
.PP
Note \fB\-q\fR is needed cuz of tha space up in '\s-1FOO BAR\s0'.
.SH "EXAMPLE: Readin arguments from command line"
.IX Header "EXAMPLE: Readin arguments from command line"
\&\s-1GNU \s0\fBparallel\fR can take tha arguments from command line instead of
stdin (standard input). To compress all html filez up in tha current dir
usin \fBgzip\fR run:
.PP
\&\fBparallel gzip ::: *.html\fR
.PP
To convert *.wav ta *.mp3 rockin \s-1LAME\s0 hustlin one process per \s-1CPU\s0 core
run:
.PP
\&\fBparallel lame {} \-o {.}.mp3 ::: *.wav\fR
.SH "EXAMPLE: Insertin multiple arguments"
.IX Header "EXAMPLE: Insertin multiple arguments"
When movin a shitload of filez like this: \fBmv *.log destdir\fR you will
sometimes git tha error:
.PP
\&\fBbash: /bin/mv: Argument list too long\fR
.PP
because there be too nuff files. Yo ass can instead do:
.PP
\&\fBls | grep \-E '\e.log$' | parallel mv {} destdir\fR
.PP
This will run \fBmv\fR fo' each file. Well shiiiit, it can be done fasta if \fBmv\fR gets
as nuff arguments dat will fit on tha line:
.PP
\&\fBls | grep \-E '\e.log$' | parallel \-m mv {} destdir\fR
.SH "EXAMPLE: Context replace"
.IX Header "EXAMPLE: Context replace"
To remove tha filez \fIpict0000.jpg\fR .. \fIpict9999.jpg\fR you could do:
.PP
\&\fBseq \-w 0 9999 | parallel rm pict{}.jpg\fR
.PP
Yo ass could also do:
.PP
\&\fBseq \-w 0 9999 | perl \-pe 's/(.*)/pict$1.jpg/' | parallel \-m rm\fR
.PP
Da first will run \fBrm\fR 10000 times, while tha last will only run
\&\fBrm\fR as nuff times needed ta keep tha command line length short
enough ta avoid \fBArgument list too long\fR (it typically runs 1\-2 times).
.PP
Yo ass could also run:
.PP
\&\fBseq \-w 0 9999 | parallel \-X rm pict{}.jpg\fR
.PP
This will also only run \fBrm\fR as nuff times needed ta keep tha command
line length short enough.
.SH "EXAMPLE: Compute intensive thangs n' substitution"
.IX Header "EXAMPLE: Compute intensive thangs n' substitution"
If ImageMagick is installed dis will generate a thumbnail of a jpg
file:
.PP
\&\fBconvert \-geometry 120 foo.jpg thumb_foo.jpg\fR
.PP
This will run wit number-of-cpu-cores thangs up in parallel fo' all jpg
filez up in a gangbangin' finger-lickin' directory:
.PP
\&\fBls *.jpg | parallel convert \-geometry 120 {} thumb_{}\fR
.PP
To do it recursively use \fBfind\fR:
.PP
\&\fBfind . \-name '*.jpg' | parallel convert \-geometry 120 {} {}_thumb.jpg\fR
.PP
Notice how tha fuck tha argument has ta start wit \fB{}\fR as \fB{}\fR will include path
(e.g. hustlin \fBconvert \-geometry 120 ./foo/bar.jpg
thumb_./foo/bar.jpg\fR would clearly be wrong). Da command will
generate filez like ./foo/bar.jpg_thumb.jpg.
.PP
Use \fB{.}\fR ta avoid tha extra .jpg up in tha file name. This command will
make filez like ./foo/bar_thumb.jpg:
.PP
\&\fBfind . \-name '*.jpg' | parallel convert \-geometry 120 {} {.}_thumb.jpg\fR
.SH "EXAMPLE: Substitution n' redirection"
.IX Header "EXAMPLE: Substitution n' redirection"
This will generate a uncompressed version of .gz\-filez next ta tha .gz\-file:
.PP
\&\fBparallel zcat {} "\fR>\fB"{.} ::: *.gz\fR
.PP
Quotin of > is necessary ta postpone tha redirection. I aint talkin' bout chicken n' gravy biatch fo' realz. Another
solution is ta quote tha whole command:
.PP
\&\fBparallel "zcat {} \fR>\fB{.}" ::: *.gz\fR
.PP
Other special shell charactas (like fuckin * ; $ > < | >> <<) also need
to be put up in quotes, as they may otherwise be interpreted by tha shell
and not given ta \s-1GNU \s0\fBparallel\fR.
.SH "EXAMPLE: Composed commands"
.IX Header "EXAMPLE: Composed commands"
A thang can consist of nuff muthafuckin commands. This will print tha number of
filez up in each directory:
.PP
\&\fBls | parallel 'echo \-n {}\*(L" \*(R"; ls {}|wc \-l'\fR
.PP
To put tha output up in a gangbangin' file called <name>.dir:
.PP
\&\fBls | parallel '(echo \-n {}\*(L" \*(R"; ls {}|wc \-l) \fR> \fB{}.dir'\fR
.PP
Even lil' small-ass shell scripts can be run by \s-1GNU \s0\fBparallel\fR:
.PP
\&\fBfind . | parallel 'a={}; name=${a##*/}; upper=$(echo \*(L"$name\*(R" | tr \*(L"[:lower:]\*(R" \*(L"[:upper:]\*(R"); echo \*(L"$name \- \f(CB$upper\fB\*(R"'\fR
.PP
\&\fBls | parallel 'mv {} \*(L"$(echo {} | tr \*(R"[:upper:]\*(L" \*(R"[:lower:]\*(L")\*(R"'\fR
.PP
Given a list of URLs, list all URLs dat fail ta download. Y'all KNOW dat shit, muthafucka! Print the
line number n' tha \s-1URL.\s0
.PP
\&\fBcat urlfile | parallel "wget {} 2\fR>\fB/dev/null || grep \-n {} urlfile"\fR
.PP
Smoke a mirror directory wit tha same filenames except all filez and
symlinks is empty files.
.PP
\&\fBcp \-rs /the/source/dir mirror_dir; find mirror_dir \-type l | parallel \-m rm {} '&&' bust a nut on {}\fR
.PP
Find tha filez up in a list dat do not exist
.PP
\&\fBcat file_list | parallel 'if [ ! \-e {} ] ; then echo {}; fi'\fR
.SH "EXAMPLE: Removin file extension when processin files"
.IX Header "EXAMPLE: Removin file extension when processin files"
When processin filez removin tha file extension rockin \fB{.}\fR is
often useful.
.PP
Smoke a gangbangin' finger-lickin' directory fo' each zip-file n' unzip it up in dat dir:
.PP
\&\fBparallel 'mkdir {.}; cd {.}; unzip ../{}' ::: *.zip\fR
.PP
Recompress all .gz filez up in current directory rockin \fBbzip2\fR hustlin 1
job per \s-1CPU\s0 core up in parallel:
.PP
\&\fBparallel "zcat {} | bzip2 \fR>\fB{.}.bz2 && rm {}" ::: *.gz\fR
.PP
Convert all \s-1WAV\s0 filez ta \s-1MP3\s0 rockin \s-1LAME:\s0
.PP
\&\fBfind sounddir \-type f \-name '*.wav' | parallel lame {} \-o {.}.mp3\fR
.PP
Put all converted up in tha same directory:
.PP
\&\fBfind sounddir \-type f \-name '*.wav' | parallel lame {} \-o mydir/{/.}.mp3\fR
.SH "EXAMPLE: Removin two file extensions when processin filez n' callin GNU Parallel from itself"
.IX Header "EXAMPLE: Removin two file extensions when processin filez n' callin GNU Parallel from itself"
If you have directory wit tar.gz filez n' want these extracted in
the correspondin dir (e.g foo.tar.gz is ghon be extracted up in tha dir
foo) you can do:
.PP
\&\fBls *.tar.gz| parallel \-\-er {tar} 'echo {tar}|parallel \*(L"mkdir \-p {.} ; tar \-C {.} \-xf {.}.tar.gz\*(R"'\fR
.SH "EXAMPLE: Downlizzle 10 images fo' each of tha past 30 days"
.IX Header "EXAMPLE: Downlizzle 10 images fo' each of tha past 30 days"
Let our asses assume a joint stores images like:
.PP
.Vb 1
\&   http://www.example.com/path/to/YYYYMMDD_##.jpg
.Ve
.PP
where \s-1YYYYMMDD\s0 is tha date n' ## is tha number 01\-10. This will
downlizzle images fo' tha past 30 days:
.PP
\&\fBparallel wget http://www.example.com/path/to/'$(date \-d \*(L"todizzle \-{1} days\*(R" +%Y%m%d)_{2}.jpg' ::: $(seq 30) ::: $(seq \-w 10)\fR
.PP
\&\fB$(date \-d \*(L"todizzle \-{1} days\*(R" +%Y%m%d)\fR will give tha dates in
\&\s-1YYYYMMDD\s0 wit {1} minutes subtracted.
.SH "EXAMPLE: Breadth first parallel wizzy crawler/mirrorer"
.IX Header "EXAMPLE: Breadth first parallel wizzy crawler/mirrorer"
This script below will crawl n' mirror a \s-1URL\s0 up in parallel.  It
downloadz first pages dat is 1 click down, then 2 clicks down, then
3; instead of tha aiiight depth first, where tha straight-up original gangsta link link on
each page is fetched first.
.PP
Run like this:
.PP
\&\fBPARALLEL=\-j100 ./parallel\-crawl http://gatt.org.yeslab.org/\fR
.PP
Remove tha \fBwget\fR part if you only want a wizzy crawler.
.PP
It works by fetchin a page from a list of URLs n' lookin fo' links
in dat page dat is within tha same startin \s-1URL\s0 n' dat have not
already been seen. I aint talkin' bout chicken n' gravy biatch. These links is added ta a freshly smoked up queue. When all the
pages from tha list is done, tha freshly smoked up queue is moved ta tha list of
URLs n' tha process is started over until no unseen links is found.
.PP
.Vb 1
\&  #!/bin/bash
\&
\&  # E.g. http://gatt.org.yeslab.org/
\&  URL=$1
\&  # Stay inside tha start dir
\&  BASEURL=$(echo $URL | perl \-pe \*(Aqs:#.*::; s:(//.*/)[^/]*:$1:\*(Aq)
\&  URLLIST=$(mktemp urllist.XXXX)
\&  URLLIST2=$(mktemp urllist.XXXX)
\&  SEEN=$(mktemp seen.XXXX)
\&
\&  # Spider ta git tha URLs
\&  echo $URL >$URLLIST
\&  cp $URLLIST $SEEN
\&
\&  while [ \-s $URLLIST ] ; do
\&    pussaaaaay $URLLIST |
\&      parallel lynx \-listonly \-image_links \-dump {} \e; wget \-qm \-l1 \-Q1 {} \e; echo Spidered: {} \e>\e&2 |
\&      perl \-ne \*(Aqs/#.*//; s/\es+\ed+.\es(\eS+)$/$1/ n' do { $seen{$1}++ or print }\*(Aq |
\&      grep \-F $BASEURL |
\&      grep \-v \-x \-F \-f $SEEN | tee \-a $SEEN > $URLLIST2
\&    mv $URLLIST2 $URLLIST
\&  done
\&
\&  rm \-f $URLLIST $URLLIST2 $SEEN
.Ve
.SH "EXAMPLE: Process filez from a tar file while unpacking"
.IX Header "EXAMPLE: Process filez from a tar file while unpacking"
If tha filez ta be processed is up in a tar file then unpackin one file
and processin it immediately may be fasta than first unpackin all
files.
.PP
\&\fBtar xvf foo.tgz | perl \-ne 'print \f(CB$l\fB;$l=$_;END{print \f(CB$l\fB}' |
parallel echo\fR
.PP
Da Perl one-liner is needed ta avoid race condition.
.SH "EXAMPLE: Rewritin a gangbangin' for-loop n' a while-read-loop"
.IX Header "EXAMPLE: Rewritin a gangbangin' for-loop n' a while-read-loop"
for-loops like this:
.PP
.Vb 3
\&  (for x up in \`cat list\` ; do
\&    do_suttin' $x
\&  done) | process_output
.Ve
.PP
and while-read-loops like this:
.PP
.Vb 3
\&  pussaaaaay list | (while read x ; do
\&    do_suttin' $x
\&  done) | process_output
.Ve
.PP
can be freestyled like this:
.PP
\&\fBcat list | parallel do_suttin' | process_output\fR
.PP
For example: Find which host name up in a list has \s-1IP\s0 address 1.2.3 4:
.PP
\&\fBcat hosts.txt | parallel \-P 100 host | grep 1.2.3.4\fR
.PP
If tha processin requires mo' steps tha for-loop like this:
.PP
.Vb 5
\& (for x up in \`cat list\` ; do
\&   no_extension=${x%.*};
\&   do_suttin' $x scale $no_extension.jpg
\&   do_step2 <$x $no_extension
\& done) | process_output
.Ve
.PP
and while-loops like this:
.PP
.Vb 5
\& pussaaaaay list | (while read x ; do
\&   no_extension=${x%.*};
\&   do_suttin' $x scale $no_extension.jpg
\&   do_step2 <$x $no_extension
\& done) | process_output
.Ve
.PP
can be freestyled like this:
.PP
\&\fBcat list | parallel \*(L"do_suttin' {} scale {.}.jpg ; do_step2 <{} {.}\*(R" | process_output\fR
.SH "EXAMPLE: Rewritin nested for-loops"
.IX Header "EXAMPLE: Rewritin nested for-loops"
Nested for-loops like this:
.PP
.Vb 5
\&  (for x up in \`cat xlist\` ; do
\&    fo' y up in \`cat ylist\` ; do
\&      do_suttin' $x $y
\&    done
\&  done) | process_output
.Ve
.PP
can be freestyled like this:
.PP
\&\fBparallel do_suttin' {1} {2} :::: xlist ylist | process_output\fR
.PP
Nested for-loops like this:
.PP
.Vb 5
\&  (for gender up in M F ; do
\&    fo' size up in S M L XL XXL ; do
\&      echo $gender $size
\&    done
\&  done) | sort
.Ve
.PP
can be freestyled like this:
.PP
\&\fBparallel echo {1} {2} ::: M F ::: S M L \s-1XL XXL\s0 | sort\fR
.SH "EXAMPLE: for-loops wit column names"
.IX Header "EXAMPLE: for-loops wit column names"
When bustin multiple nested for-loops it can be easier ta keep track of
the loop variable if is is named instead of just havin a number n' shit. Use
\&\fB\-\-header :\fR ta let tha straight-up original gangsta argument be a named alias fo' the
positionizzle replacement string:
.PP
.Vb 1
\&  parallel \-\-header : echo {gender} {size} ::: gender M F ::: size S M L XL XXL
.Ve
.PP
This also works if tha input file be a gangbangin' file wit columns:
.PP
.Vb 1
\&  pussaaaaay addressbook.tsv | parallel \-\-colsep \*(Aq\et\*(Aq \-\-header : echo {Name} {E\-mail address}
.Ve
.SH "EXAMPLE: Count tha differences between all filez up in a gangbangin' finger-lickin' dir"
.IX Header "EXAMPLE: Count tha differences between all filez up in a gangbangin' finger-lickin' dir"
Usin \fB\-\-results\fR tha thangs up in dis biatch is saved up in /tmp/diffcount*.
.PP
.Vb 1
\&  parallel \-\-results /tmp/diffcount "diff \-U 0 {1} {2} |tail \-n +3 |grep \-v \*(Aq^@\*(Aq|wc \-l" ::: * ::: *
.Ve
.PP
To peep tha difference between file A n' file B peep tha file
\&'/tmp/diffcount 1 A 2 B' where spaces is TABs (\et).
.SH "EXAMPLE: Speedin up fast thangs"
.IX Header "EXAMPLE: Speedin up fast thangs"
Startin a thang on tha local machine takes round 3 ms. This can be a
bangin' overhead if tha thang takes straight-up few ms ta run. I aint talkin' bout chicken n' gravy biatch. Often you can group
small thangs together rockin \fB\-X\fR which will make tha overhead less
significant. Compare tha speed of these:
.PP
.Vb 1
\&    seq \-w 0 9999 | parallel bust a nut on pict{}.jpg
\&
\&    seq \-w 0 9999 | parallel \-X bust a nut on pict{}.jpg
.Ve
.PP
If yo' program cannot take multiple arguments, then you can use \s-1GNU
\&\s0\fBparallel\fR ta spawn multiple \s-1GNU \s0\fBparallel\fRs:
.PP
.Vb 1
\&    seq \-w 0 999999 | parallel \-j10 \-\-pipe parallel \-j0 bust a nut on pict{}.jpg
.Ve
.PP
If \fB\-j0\fR normally spawns 506 thangs, then tha above will try ta spawn
5060 thangs. Well shiiiit, it is likely dat you dis way will hit tha limit of number
of processes and/or filehandles. Look at 'ulimit \-n' n' 'ulimit \-u'
to raise these limits.
.SH "EXAMPLE: Usin shell variables"
.IX Header "EXAMPLE: Usin shell variables"
When rockin shell variablez you need ta quote dem erectly as they
may otherwise be split on spaces.
.PP
Notice tha difference between:
.PP
.Vb 2
\& V=("My fuckin brother\*(Aqs 12\e" recordz is worth <\e$\e$\e$>"\*(Aq!\*(Aq Foo Bar)
\& parallel echo ::: ${V[@]} # This is probably not what tha fuck you want
.Ve
.PP
and:
.PP
.Vb 2
\& V=("My fuckin brother\*(Aqs 12\e" recordz is worth <\e$\e$\e$>"\*(Aq!\*(Aq Foo Bar)
\& parallel echo ::: "${V[@]}"
.Ve
.PP
When rockin variablez up in tha actual command dat gotz nuff special
charactas (e.g. space) you can quote dem rockin \fB'\*(L"$VAR\*(R"'\fR or using
"z n' \fB\-q\fR:
.PP
.Vb 3
\& V="Here  is  two "
\& parallel echo "\*(Aq$V\*(Aq" ::: spaces
\& parallel \-q echo "$V" ::: spaces
.Ve
.SH "EXAMPLE: Group output lines"
.IX Header "EXAMPLE: Group output lines"
When hustlin thangs dat output data, you often do not want tha output
of multiple thangs ta run together n' shit. \s-1GNU \s0\fBparallel\fR defaults ta groupin the
output of each thang, so tha output is printed when tha thang finishes. If
you want tha output ta be printed while tha thang is hustlin you can use
\&\fB\-u\fR.
.PP
Compare tha output of:
.PP
\&\fBparallel traceroute ::: foss.org.my debian.org freenetproject.org\fR
.PP
to tha output of:
.PP
\&\fBparallel \-u traceroute ::: foss.org.my debian.org freenetproject.org\fR
.SH "EXAMPLE: Tag output lines"
.IX Header "EXAMPLE: Tag output lines"
\&\s-1GNU \s0\fBparallel\fR crews tha output lines yo, but it can be hard ta see
where tha different thangs begin. I aint talkin' bout chicken n' gravy biatch. \fB\-\-tag\fR prependz tha argument ta make
that mo' visible:
.PP
\&\fBparallel \-\-tag traceroute ::: foss.org.my debian.org freenetproject.org\fR
.PP
Peep tha uptime of tha servers up in \fI~/.parallel/sshloginfile\fR:
.PP
\&\fBparallel \-\-tag \-S .. \-\-nonall uptime\fR
.SH "EXAMPLE: Keep order of output same as order of input"
.IX Header "EXAMPLE: Keep order of output same as order of input"
Normally tha output of a thang is ghon be printed as soon as it
completes. Right back up in yo muthafuckin ass. Sometimes you want tha order of tha output ta remain the
same as tha order of tha input. This is often blingin, if tha output
is used as input fo' another system. \fB\-k\fR will make shizzle tha order of
output is ghon be up in tha same order as input even if lata thangs end
before earlier thangs.
.PP
Append a strang ta every last muthafuckin line up in a text file:
.PP
\&\fBcat textfile | parallel \-k echo {} append_string\fR
.PP
If you remove \fB\-k\fR a shitload of tha lines may come up in tha wack order.
.PP
Another example is \fBtraceroute\fR:
.PP
\&\fBparallel traceroute ::: foss.org.my debian.org freenetproject.org\fR
.PP
will give traceroute of foss.org.my, debian.org and
freenetproject.org yo, but it is ghon be sorted accordin ta which thang
completed first.
.PP
To keep tha order tha same as input run:
.PP
\&\fBparallel \-k traceroute ::: foss.org.my debian.org freenetproject.org\fR
.PP
This will make shizzle tha traceroute ta foss.org.my is ghon be printed
first.
.PP
A bit mo' complex example is downloadin a big-ass file up in chunks in
parallel: Some internizzle connections will serve up mo' data if you
downlizzle filez up in parallel. For downloadin filez up in parallel see:
\&\*(L"\s-1EXAMPLE:\s0 Downlizzle 10 images fo' each of tha past 30 days\*(R". But if you
are downloadin a funky-ass big-ass file you can downlizzle tha file up in chunks in
parallel.
.PP
To downlizzle byte 10000000\-19999999 you can use \fBcurl\fR:
.PP
\&\fBcurl \-r 10000000\-19999999 http://example.com/the/big/file\fR > \fBfile.part\fR
.PP
To downlizzle a 1 \s-1GB\s0 file we need 100 10MB chunks downloaded and
combined up in tha erect order.
.PP
\&\fBseq 0 99 | parallel \-k curl \-r \e
    {}0000000\-{}9999999 http://example.com/the/big/file\fR > \fBfile\fR
.SH "EXAMPLE: Parallel grep"
.IX Header "EXAMPLE: Parallel grep"
\&\fBgrep \-r\fR greps recursively all up in directories. Put ya muthafuckin choppers up if ya feel dis! On multicore CPUs
\&\s-1GNU \s0\fBparallel\fR can often speed dis up.
.PP
\&\fBfind . \-type f | parallel \-k \-j150% \-n 1000 \-m grep \-H \-n \s-1STRING\s0 {}\fR
.PP
This will run 1.5 thang per core, n' give 1000 arguments ta \fBgrep\fR.
.SH "EXAMPLE: Usin remote computers"
.IX Header "EXAMPLE: Usin remote computers"
To run commandz on a remote computa \s-1SSH\s0 need ta be set up n' you
must be able ta login without enterin a password (Da commands
\&\fBssh-copy-id\fR n' \fBssh-agent\fR may help you do that).
.PP
To run \fBecho\fR on \fBserver.example.com\fR:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin server.example.com echo
.Ve
.PP
To run commandz on mo' than one remote computa run:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin server.example.com,server2.example.net echo
.Ve
.PP
Or:
.PP
.Vb 2
\&  seq 10 | parallel \-\-sshlogin server.example.com \e
\&    \-\-sshlogin server2.example.net echo
.Ve
.PP
If tha login username is \fIfoo\fR on \fIserver2.example.net\fR use:
.PP
.Vb 2
\&  seq 10 | parallel \-\-sshlogin server.example.com \e
\&    \-\-sshlogin foo@server2.example.net echo
.Ve
.PP
To distribute tha commandz ta a list of computers, cook up a gangbangin' file
\&\fImycomputers\fR wit all tha computers:
.PP
.Vb 3
\&  server.example.com
\&  foo@server2.example.com
\&  server3.example.com
.Ve
.PP
Then run:
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshloginfile mycomputas echo
.Ve
.PP
To include tha local computa add tha special sshlogin ':' ta tha list:
.PP
.Vb 4
\&  server.example.com
\&  foo@server2.example.com
\&  server3.example.com
\&  :
.Ve
.PP
\&\s-1GNU \s0\fBparallel\fR will try ta determine tha number of \s-1CPU\s0 cores on each
of tha remote computers, n' run one thang per \s-1CPU\s0 core \- even if the
remote computas aint gots tha same number of \s-1CPU\s0 cores.
.PP
If tha number of \s-1CPU\s0 cores on tha remote computas aint identified
correctly tha number of \s-1CPU\s0 cores can be added up in front yo. Here the
computa has 8 \s-1CPU\s0 cores.
.PP
.Vb 1
\&  seq 10 | parallel \-\-sshlogin 8/server.example.com echo
.Ve
.SH "EXAMPLE: Transferrin of files"
.IX Header "EXAMPLE: Transferrin of files"
To recompress gzipped filez wit \fBbzip2\fR rockin a remote computa run:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
This will list tha .gz\-filez up in tha \fIlogs\fR directory n' all
directories below. Then it will transfer tha filez to
\&\fIserver.example.com\fR ta tha correspondin directory in
\&\fI\f(CI$HOME\fI/logs\fR. On \fIserver.example.com\fR tha file is ghon be recompressed
usin \fBzcat\fR n' \fBbzip2\fR resultin up in tha correspondin file with
\&\fI.gz\fR replaced wit \fI.bz2\fR.
.PP
If you want tha resultin bz2\-file ta be transferred back ta tha local
computa add \fI\-\-return {.}.bz2\fR:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
Afta tha recompressin is done tha \fI.bz2\fR\-file is transferred back to
the local computa n' put next ta tha original gangsta \fI.gz\fR\-file.
.PP
If you wanna delete tha transferred filez on tha remote computa add
\&\fI\-\-cleanup\fR. This will remove both tha file transferred ta tha remote
computa n' tha filez transferred from tha remote computer:
.PP
.Vb 3
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
If you want run on nuff muthafuckin computas add tha computas ta \fI\-\-sshlogin\fR
either rockin ',' or multiple \fI\-\-sshlogin\fR:
.PP
.Vb 4
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
Yo ass can add tha local computa rockin \fI\-\-sshlogin :\fR. This will disable the
removin n' transferrin fo' tha local computa only:
.PP
.Vb 5
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-sshlogin : \e
\&    \-\-transfer \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
Often \fI\-\-transfer\fR, \fI\-\-return\fR n' \fI\-\-cleanup\fR is used together n' shit. They can be
shortened ta \fI\-\-trc\fR:
.PP
.Vb 5
\&  find logs/ \-name \*(Aq*.gz\*(Aq | \e
\&    parallel \-\-sshlogin server.example.com,server2.example.com \e
\&    \-\-sshlogin server3.example.com \e
\&    \-\-sshlogin : \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
With tha file \fImycomputers\fR containin tha list of computas it becomes:
.PP
.Vb 2
\&  find logs/ \-name \*(Aq*.gz\*(Aq | parallel \-\-sshloginfile mycomputas \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.PP
If tha file \fI~/.parallel/sshloginfile\fR gotz nuff tha list of computers
the special short hand \fI\-S ..\fR can be used:
.PP
.Vb 2
\&  find logs/ \-name \*(Aq*.gz\*(Aq | parallel \-S .. \e
\&    \-\-trc {.}.bz2 "zcat {} | bzip2 \-9 >{.}.bz2"
.Ve
.SH "EXAMPLE: Distributin work ta local n' remote computers"
.IX Header "EXAMPLE: Distributin work ta local n' remote computers"
Convert *.mp3 ta *.ogg hustlin one process per \s-1CPU\s0 core on local computa n' server2:
.PP
.Vb 2
\&  parallel \-\-trc {.}.ogg \-S server2,: \e
\&  \*(Aqmpg321 \-w \- {} | oggenc \-q0 \- \-o {.}.ogg\*(Aq ::: *.mp3
.Ve
.SH "EXAMPLE: Hustlin tha same command on remote computers"
.IX Header "EXAMPLE: Hustlin tha same command on remote computers"
To run tha command \fBuptime\fR on remote computas you can do:
.PP
\&\fBparallel \-\-tag \-\-nonall \-S server1,server2 uptime\fR
.PP
\&\fB\-\-nonall\fR readz no arguments, n' you can put dat on yo' toast. If you gotz a list of thangs you want
run on each computa you can do:
.PP
\&\fBparallel \-\-tag \-\-onall \-S server1,server2 echo ::: 1 2 3\fR
.PP
Remove \fB\-\-tag\fR if you do not want tha sshlogin added before the
output.
.PP
If you gotz a shitload of hosts use '\-j0' ta access mo' hosts up in parallel.
.SH "EXAMPLE: Parallelizin rsync"
.IX Header "EXAMPLE: Parallelizin rsync"
\&\fBrsync\fR be a pimped out tool yo, but sometimes it aint gonna fill up the
available bandwidth. This is often a problem when copyin nuff muthafuckin big
filez over high speed connections.
.PP
Da followin will start one \fBrsync\fR per big-ass file up in \fIsrc-dir\fR to
\&\fIdest-dir\fR on tha server \fIfooserver\fR:
.PP
\&\fBcd src-dir; find . \-type f \-size +100000 | parallel \-v ssh fooserver
mkdir \-p /dest\-dir/{//}\e;rsync \-Havessh {} fooserver:/dest\-dir/{}\fR
.PP
Da dirs pimped may end up wit wack permissions n' smalla files
are not bein transferred. Y'all KNOW dat shit, muthafucka! To fix dem run \fBrsync\fR a gangbangin' final time:
.PP
\&\fBrsync \-Havessh src\-dir/ fooserver:/dest\-dir/\fR
.PP
If yo ass is unable ta push data yo, but need ta pull dem n' tha files
are called digits.png (e.g. 000000.png) you might be able ta do:
.PP
<seq \-w 0 99 | parallel rsync \-Havessh fooserver:src\-path/*{}.png destdir/>
.SH "EXAMPLE: Use multiple inputs up in one command"
.IX Header "EXAMPLE: Use multiple inputs up in one command"
Copy filez like foo.es.ext ta foo.ext:
.PP
\&\fBls *.es.* | perl \-pe 'print; s/\e.es//' | parallel \-N2 cp {1} {2}\fR
.PP
Da perl command spits up 2 lines fo' each input. \s-1GNU \s0\fBparallel\fR
takes 2 inputs (usin \fB\-N2\fR) n' replaces {1} n' {2} wit tha inputs.
.PP
Count up in binary:
.PP
\&\fBparallel \-k echo ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1 ::: 0 1\fR
.PP
Print tha number on tha opposin sidez of a six sided die:
.PP
\&\fBparallel \-\-xapply \-a <(seq 6) \-a <(seq 6 \-1 1) echo\fR
.PP
\&\fBparallel \-\-xapply echo :::: <(seq 6) <(seq 6 \-1 1)\fR
.PP
Convert filez from all subdirs ta PNG-filez wit consecutizzle numbers
(useful fo' makin input \s-1PNG\s0z fo' \fBffmpeg\fR):
.PP
\&\fBparallel \-\-xapply \-a <(find . \-type f | sort) \-a <(seq $(find . \-type f|wc \-l)) convert {1} {2}.png\fR
.PP
Alternatizzle version:
.PP
\&\fBfind . \-type f | sort | parallel convert {} {#}.png\fR
.SH "EXAMPLE: Use a table as input"
.IX Header "EXAMPLE: Use a table as input"
Content of table_file.tsv:
.PP
.Vb 2
\&  foo<TAB>bar
\&  baz <TAB> quux
.Ve
.PP
To run:
.PP
.Vb 2
\&  cmd \-o bar \-i foo
\&  cmd \-o quux \-i baz
.Ve
.PP
you can run:
.PP
\&\fBparallel \-a table_file.tsv \-\-colsep '\et' cmd \-o {2} \-i {1}\fR
.PP
Note: Da default fo' \s-1GNU \s0\fBparallel\fR is ta remove tha spaces round tha columns. To keep tha spaces:
.PP
\&\fBparallel \-a table_file.tsv \-\-trim n \-\-colsep '\et' cmd \-o {2} \-i {1}\fR
.SH "EXAMPLE: Run tha same command 10 times"
.IX Header "EXAMPLE: Run tha same command 10 times"
If you wanna run tha same command wit tha same arguments 10 times
in parallel you can do:
.PP
\&\fBseq 10 | parallel \-n0 my_command my_args\fR
.SH "EXAMPLE: Workin as pussaaaaay | sh. Resource inexpensive thangs n' evaluation"
.IX Header "EXAMPLE: Workin as pussaaaaay | sh. Resource inexpensive thangs n' evaluation"
\&\s-1GNU \s0\fBparallel\fR can work similar ta \fBcat | sh\fR.
.PP
A resource inexpensive thang be a thang dat takes straight-up lil \s-1CPU,\s0 disk
I/O n' network I/O. Pin be a example of a resource inexpensive
job. wget is too \- if tha webpages is small.
.PP
Da content of tha file thangs_to_run:
.PP
.Vb 7
\&  pin \-c 1 10.0.0.1
\&  wget http://example.com/status.cgi?ip=10.0.0.1
\&  pin \-c 1 10.0.0.2
\&  wget http://example.com/status.cgi?ip=10.0.0.2
\&  ...
\&  pin \-c 1 10.0.0.255
\&  wget http://example.com/status.cgi?ip=10.0.0.255
.Ve
.PP
To run 100 processes simultaneously do:
.PP
\&\fBparallel \-j 100 < thangs_to_run\fR
.PP
As there aint a \fIcommand\fR tha thangs is ghon be evaluated by tha shell.
.SH "EXAMPLE: Processin a funky-ass big-ass file rockin mo' cores"
.IX Header "EXAMPLE: Processin a funky-ass big-ass file rockin mo' cores"
To process a funky-ass big-ass file or some output you can use \fB\-\-pipe\fR ta split up
the data tha fuck into blocks n' pipe tha blocks tha fuck into tha processin program.
.PP
If tha program is \fBgzip \-9\fR you can do:
.PP
\&\fBcat bigfile | parallel \-\-pipe \-\-recend '' \-k gzip \-9 \fR>\fBbigfile.gz\fR
.PP
This will split \fBbigfile\fR tha fuck into blockz of 1 \s-1MB\s0 n' pass dat ta \fBgzip
\&\-9\fR up in parallel. One \fBgzip\fR is ghon be run per \s-1CPU\s0 core. Da output of
\&\fBgzip \-9\fR is ghon be kept up in order n' saved ta \fBbigfile.gz\fR
.PP
\&\fBgzip\fR works fine if tha output be appended yo, but some processin do
not work like dat \- fo' example sorting. For dis \s-1GNU \s0\fBparallel\fR can
put tha output of each command tha fuck into a gangbangin' file. This will sort a funky-ass big-ass file
in parallel:
.PP
\&\fBcat bigfile | parallel \-\-pipe \-\-filez sort | parallel \-Xj1 sort \-m {} ';' rm {} \fR>\fBbigfile.sort\fR
.PP
Here \fBbigfile\fR is split tha fuck into blockz of round 1MB, each block ending
in '\en' (which is tha default fo' \fB\-\-recend\fR). Each block is passed
to \fBsort\fR n' tha output from \fBsort\fR is saved tha fuck into files. These
filez is passed ta tha second \fBparallel\fR dat runs \fBsort \-m\fR on the
filez before it removes tha files. Da output is saved to
\&\fBbigfile.sort\fR.
.SH "EXAMPLE: Workin as mutex n' countin semaphore"
.IX Header "EXAMPLE: Workin as mutex n' countin semaphore"
Da command \fBsem\fR be a alias fo' \fBparallel \-\-semaphore\fR.
.PP
A countin semaphore will allow a given number of thangs ta be started
in tha background. Y'all KNOW dat shit, muthafucka!  When tha number of thangs is hustlin up in the
background, \s-1GNU \s0\fBsem\fR will wait fo' one of these ta complete before
startin another command. Y'all KNOW dat shit, muthafucka! \fBsem \-\-wait\fR will wait fo' all thangs to
complete.
.PP
Run 10 thangs concurrently up in tha background:
.PP
.Vb 5
\&  fo' i up in *.log ; do
\&    echo $i
\&    sem \-j10 gzip $i ";" echo done
\&  done
\&  sem \-\-wait
.Ve
.PP
A mutex be a cold-ass lil countin semaphore allowin only one thang ta run. I aint talkin' bout chicken n' gravy biatch. This
will edit tha file \fImyfile\fR n' prependz tha file wit lines wit the
numbers 1 ta 3.
.PP
.Vb 1
\&  seq 3 | parallel sem sed \-i \-e \*(Aqi{}\*(Aq myfile
.Ve
.PP
As \fImyfile\fR can be straight-up big-ass it is blingin only one process edits
the file all up in tha same time.
.PP
Name tha semaphore ta have multiple different semaphores actizzle at the
same time:
.PP
.Vb 1
\&  seq 3 | parallel sem \-\-id mymutex sed \-i \-e \*(Aqi{}\*(Aq myfile
.Ve
.SH "EXAMPLE: Start editor wit filenames from stdin (standard input)"
.IX Header "EXAMPLE: Start editor wit filenames from stdin (standard input)"
Yo ass can use \s-1GNU \s0\fBparallel\fR ta start interactizzle programs like emacs or vi:
.PP
\&\fBcat filelist | parallel \-\-tty \-X emacs\fR
.PP
\&\fBcat filelist | parallel \-\-tty \-X vi\fR
.PP
If there be mo' filez than will fit on a single command line, the
editor is ghon be started again n' again n' again wit tha remainin files.
.SH "EXAMPLE: Hustlin sudo"
.IX Header "EXAMPLE: Hustlin sudo"
\&\fBsudo\fR requires a password ta run a cold-ass lil command as root. Well shiiiit, it caches the
access, so you only need ta enta tha password again n' again n' again if you have not
used \fBsudo\fR fo' a while.
.PP
Da command:
.PP
.Vb 1
\&  parallel sudo echo ::: This be a wack idea
.Ve
.PP
is no good, as you would be prompted fo' tha sudo password fo' each of
the thangs. Yo ass can either do:
.PP
.Vb 2
\&  sudo echo This
\&  parallel sudo echo ::: be a phat idea
.Ve
.PP
or:
.PP
.Vb 1
\&  sudo parallel echo ::: This be a phat idea
.Ve
.PP
This way you only gotta enta tha sudo password once.
.SH "EXAMPLE: GNU Parallel as queue system/batch manager"
.IX Header "EXAMPLE: GNU Parallel as queue system/batch manager"
\&\s-1GNU \s0\fBparallel\fR can work as a simple thang queue system or batch manager.
Da scam is ta put tha thangs tha fuck into a gangbangin' file n' have \s-1GNU \s0\fBparallel\fR read
from dat continuously fo' realz. As \s-1GNU \s0\fBparallel\fR will stop at end of file we
use \fBtail\fR ta continue reading:
.PP
\&\fBtrue \fR>\fBjobqueue\fR; \fBtail \-f thangqueue | parallel\fR
.PP
To submit yo' thangs ta tha queue:
.PP
\&\fBecho my_command my_arg \fR>>\fB thangqueue\fR
.PP
Yo ass can of course use \fB\-S\fR ta distribute tha thangs ta remote
computers:
.PP
\&\fBecho \fR>\fBjobqueue\fR; \fBtail \-f thangqueue | parallel \-S ..\fR
.PP
There is a two lil' small-ass thangs when rockin \s-1GNU \s0\fBparallel\fR as queue
system/batch manager:
.IP "\(bu" 2
Yo ass will git a warnin if you do not submit JobSlots thangs within
the first second. Y'all KNOW dat shit, muthafucka! E.g. if you have 8 cores n' use \-j+2 you have to
submit 10 thangs. These can be dummy thangs (e.g. echo foo). Yo ass can also
simply ignore tha warning.  For parallel versions 20110322 n' higher,
the warnings aint gonna appear.
.IP "\(bu" 2
Yo ass gotta submit JobSlot number of thangs before they will start, and
afta dat you can submit one at a time, n' thang will start
immediately if free slots is available.  Output from tha hustlin or
completed thangs is held back n' will only be printed when JobSlots
more thangs has been started (unless you use \-\-ungroup or \-u, up in which
case tha output from tha thangs is printed immediately).  E.g. if you
have 10 thangslots then tha output from tha straight-up original gangsta completed thang will
only be printed when thang 11 has started, n' tha output of second
completed thang will only be printed when thang 12 has started.
.SH "EXAMPLE: GNU Parallel as dir processor"
.IX Header "EXAMPLE: GNU Parallel as dir processor"
If you gotz a gangbangin' finger-lickin' dir up in which playas drop filez dat need ta be processed
you can do dis on GNU/Linux (If you know what tha fuck \fBinotifywait\fR is
called on other platforms file a funky-ass bug report):
.PP
\&\fBinotifywait \-q \-m \-r \-e \s-1MOVED_TO\s0 \-e \s-1CLOSE_WRITE\s0 \-\-format \f(CB%w\fB%f my_dir | parallel
\&\-u echo\fR
.PP
This will run tha command \fBecho\fR on each file put tha fuck into \fBmy_dir\fR or
subdirz of \fBmy_dir\fR.
.PP
Yo ass can of course use \fB\-S\fR ta distribute tha thangs ta remote
computers:
.PP
\&\fBinotifywait \-q \-m \-r \-e \s-1MOVED_TO\s0 \-e \s-1CLOSE_WRITE\s0 \-\-format \f(CB%w\fB%f my_dir
| parallel \-S ..  \-u echo\fR
.PP
If tha filez ta be processed is up in a tar file then unpackin one file
and processin it immediately may be fasta than first unpackin all
files. Right back up in yo muthafuckin ass. Set up tha dir processor as above n' unpack tha fuck into tha dir.
.PP
Usin \s-1GNU\s0 Parallel as dir processor has tha same ol' dirty limitations as using
\&\s-1GNU\s0 Parallel as queue system/batch manager.
.SH "QUOTING"
.IX Header "QUOTING"
\&\s-1GNU \s0\fBparallel\fR is straight-up liberal up in quoting. Yo ass only need ta quote
charactas dat have special meanin up in shell:
.PP
( ) $ ` ' " < > ; | \e
.PP
and dependin on context these need ta be quoted, too:
.PP
~ & # ! ? space * {
.PP
Therefore most playas aint NEVER gonna need mo' quotin than puttin '\e'
in front of tha special characters.
.PP
Often you can simply put \e' round every last muthafuckin ':
.PP
.Vb 1
\&  perl \-ne \*(Aq/^\eS+\es+\eS+$/ n' print $ARGV,"\en"\*(Aq file
.Ve
.PP
can be quoted:
.PP
.Vb 1
\&  parallel perl \-ne \e\*(Aq\*(Aq/^\eS+\es+\eS+$/ n' print $ARGV,"\en"\*(Aq\e\*(Aq ::: file
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat when you wanna bust a gangbangin' finger-lickin' dirty-ass shell variable you need ta quote the
$\-sign. I aint talkin' bout chicken n' gravy biatch yo. Here be a example rockin \f(CW$PARALLEL_SEQ\fR. This variable is set
by \s-1GNU \s0\fBparallel\fR itself, so tha evaluation of tha $ must be done by
the sub shell started by \s-1GNU \s0\fBparallel\fR:
.PP
\&\fBseq 10 | parallel \-N2 echo seq:\e$PARALLEL_SEQ arg1:{1} arg2:{2}\fR
.PP
If tha variable is set before \s-1GNU \s0\fBparallel\fR starts you can do this:
.PP
\&\fBVAR=this_is_set_before_starting\fR
.PP
\&\fBecho test | parallel echo {} \f(CB$VAR\fB\fR
.PP
Prints: \fBtest this_is_set_before_starting\fR
.PP
It be a lil mo' tricky if tha variable gotz nuff mo' than one space up in a row:
.PP
\&\fBVAR=\*(L"two  spaces  between  each  word\*(R"\fR
.PP
\&\fBecho test | parallel echo {} \e'\*(L"$VAR\*(R"\e'\fR
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
If tha variable should not be evaluated by tha shell startin \s-1GNU
\&\s0\fBparallel\fR but be evaluated by tha sub shell started by \s-1GNU
\&\s0\fBparallel\fR, then you need ta quote it:
.PP
\&\fBecho test | parallel VAR=this_is_set_after_startin \e; echo {} \e$VAR\fR
.PP
Prints: \fBtest this_is_set_after_starting\fR
.PP
It be a lil mo' tricky if tha variable gotz nuff space:
.PP
\&\fBecho test | parallel VAR='\*(L"two  spaces  between  each  word\*(R"' echo {} \e'\*(L"$VAR\*(R"\e'\fR
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
$$ is tha shell variable containin tha process id of tha shell. This
will print tha process id of tha shell hustlin \s-1GNU \s0\fBparallel\fR:
.PP
\&\fBseq 10 | parallel echo $$\fR
.PP
And dis will print tha process idz of tha sub shells started by \s-1GNU
\&\s0\fBparallel\fR.
.PP
\&\fBseq 10 | parallel echo \e$\e$\fR
.PP
If tha special charactas should not be evaluated by tha sub shell
then you need ta protect it against evaluation from both tha shell
startin \s-1GNU \s0\fBparallel\fR n' tha sub shell:
.PP
\&\fBecho test | parallel echo {} \e\e\e$VAR\fR
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
\&\s-1GNU \s0\fBparallel\fR can protect against evaluation by tha sub shell by
usin \-q:
.PP
\&\fBecho test | parallel \-q echo {} \e$VAR\fR
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
This is particularly useful if you have fuckin shitloadz of quoting. If you wanna run a perl script like this:
.PP
\&\fBperl \-ne '/^\eS+\es+\eS+$/ n' print \f(CB$ARGV\fB,\*(L"\en\*(R"' file\fR
.PP
It need ta be quoted like this:
.PP
\&\fBls | parallel  perl \-ne '/^\e\eS+\e\es+\e\eS+\e$/\e and\e print\e \e$ARGV,\e\*(L"\e\en\e\*(R"'\fR
.PP
Notice how tha fuck spaces, \e's, "'s, n' $z need ta be quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \s-1GNU \s0\fBparallel\fR
can do tha quotin by rockin option \-q:
.PP
\&\fBls | parallel \-q  perl \-ne '/^\eS+\es+\eS+$/ n' print \f(CB$ARGV\fB,\*(L"\en\*(R"'\fR
.PP
But fuck dat shiznit yo, tha word on tha street is dat dis means you cannot make tha sub shell interpret special
characters. For example cuz of \fB\-q\fR dis \s-1WILL NOT WORK:\s0
.PP
\&\fBls *.gz | parallel \-q "zcat {} \fR>\fB{.}"\fR
.PP
\&\fBls *.gz | parallel \-q "zcat {} | bzip2 \fR>\fB{.}.bz2"\fR
.PP
because > n' | need ta be interpreted by tha sub shell.
.PP
If you git errors like:
.PP
.Vb 4
\&  sh: \-c: line 0: syntax error near unsposed ta fuckinken
\&  sh: Syntax error: Unterminated quoted string
\&  sh: \-c: line 0: unexpected EOF while lookin fo' matchin \`\*(Aq\*(Aq
\&  sh: \-c: line 1: syntax error: unexpected end of file
.Ve
.PP
then you might try rockin \fB\-q\fR.
.PP
If yo ass is rockin \fBbash\fR process substitution like \fB<(cat foo)\fR then
you may try \fB\-q\fR n' prependin \fIcommand\fR wit \fBbash \-c\fR:
.PP
\&\fBls | parallel \-q bash \-c 'wc \-c <(echo {})'\fR
.PP
Or fo' substitutin output:
.PP
\&\fBls | parallel \-q bash \-c 'tar c {} | tee \fR>\fB(gzip \fR>\fB{}.tar.gz) | bzip2 \fR>\fB{}.tar.bz2'\fR
.PP
\&\fBConclusion\fR: To avoid dealin wit tha quotin problems it may be
easier just ta write a lil' small-ass script n' have \s-1GNU \s0\fBparallel\fR call that
script.
.SH "LIST RUNNING JOBS"
.IX Header "LIST RUNNING JOBS"
If you want a list of tha thangs currently hustlin you can run:
.PP
\&\fBkillall \-USR1 parallel\fR
.PP
\&\s-1GNU \s0\fBparallel\fR will then print tha currently hustlin thangs on stderr
(standard error).
.SH "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
.IX Header "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
If you regret startin a shitload of thangs you can simply break \s-1GNU \s0\fBparallel\fR,
but if you wanna make shizzle you aint gots half-completed thangs you
should bust tha signal \fB\s-1SIGTERM\s0\fR ta \s-1GNU \s0\fBparallel\fR:
.PP
\&\fBkillall \-TERM parallel\fR
.PP
This will tell \s-1GNU \s0\fBparallel\fR ta not start any freshly smoked up thangs yo, but wait until
the currently hustlin thangs is finished before exiting.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.ie n .IP "$PARALLEL_PID" 9
.el .IP "\f(CW$PARALLEL_PID\fR" 9
.IX Item "$PARALLEL_PID"
Da environment variable \f(CW$PARALLEL_PID\fR is set by \s-1GNU \s0\fBparallel\fR and
is visible ta tha thangs started from \s-1GNU \s0\fBparallel\fR. This make it
possible fo' tha thangs ta rap directly ta \s-1GNU \s0\fBparallel\fR.
Remember ta quote tha $, so it gets evaluated by tha erect
shell.
.Sp
\&\fBExample:\fR If each of tha thangs tests a solution n' one of thangs finds
the solution tha thang can tell \s-1GNU \s0\fBparallel\fR not ta start mo' thangs
by: \fBkill \-TERM \f(CB$PARALLEL_PID\fB\fR. This only works on tha local
computer.
.ie n .IP "$PARALLEL_SEQ" 9
.el .IP "\f(CW$PARALLEL_SEQ\fR" 9
.IX Item "$PARALLEL_SEQ"
\&\f(CW$PARALLEL_SEQ\fR is ghon be set ta tha sequence number of tha thang
running. Remember ta quote tha $, so it gets evaluated by tha erect
shell.
.Sp
\&\fBExample:\fR
.Sp
\&\fBseq 10 | parallel \-N2 echo seq:'$'\s-1PARALLEL_SEQ\s0 arg1:{1} arg2:{2}\fR
.ie n .IP "$TMPDIR" 9
.el .IP "\f(CW$TMPDIR\fR" 9
.IX Item "$TMPDIR"
Directory fo' temporary files. Right back up in yo muthafuckin ass. See: \fB\-\-tmpdir\fR.
.ie n .IP "$PARALLEL" 9
.el .IP "\f(CW$PARALLEL\fR" 9
.IX Item "$PARALLEL"
Da environment variable \f(CW$PARALLEL\fR is ghon be used as default options for
\&\s-1GNU \s0\fBparallel\fR. If tha variable gotz nuff special shell characters
(e.g. $, *, or space) then these need ta be ta be escaped wit \e.
.Sp
\&\fBExample:\fR
.Sp
\&\fBcat list | parallel \-j1 \-k \-v ls\fR
.Sp
can be freestyled as:
.Sp
\&\fBcat list | PARALLEL=\*(L"\-kvj1\*(R" parallel ls\fR
.Sp
\&\fBcat list | parallel \-j1 \-k \-v \-S\*(L"myssh user@server\*(R" ls\fR
.Sp
can be freestyled as:
.Sp
\&\fBcat list | PARALLEL='\-kvj1 \-S myssh\e user@server' parallel echo\fR
.Sp
Notice tha \e up in tha middle is needed cuz 'myssh' n' 'user@server'
must be one argument.
.SH "DEFAULT PROFILE (CONFIG FILE)"
.IX Header "DEFAULT PROFILE (CONFIG FILE)"
Da file ~/.parallel/config (formerly known as .parallelrc) will be
read if it exists, n' you can put dat on yo' toast.  Lines startin wit '#' is ghon be ignored. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can be
formatted like tha environment variable \f(CW$PARALLEL\fR yo, but it is often
easier ta simply put each option on its own line.
.PP
Options on tha command line takes precedence over tha environment
variable \f(CW$PARALLEL\fR which takes precedence over tha file
~/.parallel/config.
.SH "PROFILE FILES"
.IX Header "PROFILE FILES"
If \fB\-\-profile\fR set, \s-1GNU \s0\fBparallel\fR will read tha flava from dat file instead of
~/.parallel/config. Yo ass can have multiple \fB\-\-profiles\fR.
.PP
Example: Flava fo' hustlin a cold-ass lil command on every last muthafuckin sshlogin in
~/.ssh/sshlogins n' prepend tha output wit tha sshlogin:
.PP
.Vb 2
\&  echo \-\-tag \-S .. \-\-nonall > ~/.parallel/n
\&  parallel \-Jn uptime
.Ve
.PP
Example: Flava fo' hustlin every last muthafuckin command wit \fB\-j\-1\fR n' \fBnice\fR
.PP
.Vb 2
\&  echo \-j\-1 sick > ~/.parallel/nice_profile
\&  parallel \-J sick_profile bzip2 \-9 ::: *
.Ve
.PP
Example: Flava fo' hustlin a perl script before every last muthafuckin command:
.PP
.Vb 2
\&  echo "perl \-e \*(Aq\e$a=\e$\e$; print \e$a,\e" \e",\*(Aq\e$PARALLEL_SEQ\*(Aq,\e" \e";\*(Aq;" > ~/.parallel/pre_perl
\&  parallel \-J pre_perl echo ::: *
.Ve
.PP
Note how tha fuck tha $ n' " need ta be quoted rockin \e.
.PP
Example: Flava fo' hustlin distributed thangs wit \fBnice\fR on the
remote computers:
.PP
.Vb 2
\&  echo \-S .. sick > ~/.parallel/dist
\&  parallel \-J dist \-\-trc {.}.bz2 bzip2 \-9 ::: *
.Ve
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
If \fB\-\-halt\-on\-error\fR 0 or not specified:
.IP ".0" 6
.IX Item ".0"
All thangs ran without error.
.IP "1\-253" 6
.IX Item "1-253"
Some of tha thangs failed. Y'all KNOW dat shit, muthafucka! Da exit status gives tha number of failed thangs
.IP ".254" 6
.IX Item ".254"
Mo' than 253 thangs failed.
.IP ".255" 6
.IX Item ".255"
Other error.
.PP
If \fB\-\-halt\-on\-error\fR 1 or 2: Exit statuz of tha failin thang.
.SH "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
.IX Header "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
There is a shitload programs wit a shitload of tha functionalitizzle of \s-1GNU
\&\s0\fBparallel\fR. \s-1GNU \s0\fBparallel\fR strives ta include tha dopest of the
functionalitizzle without sacrificin ease of use.
.SS "\s-1SUMMARY TABLE\s0"
.IX Subsection "SUMMARY TABLE"
Da followin features is up in a shitload of tha comparable tools:
.PP
Inputs
 I1 fo' realz. Arguments can be read from stdin
 I2 fo' realz. Arguments can be read from a gangbangin' file
 I3 fo' realz. Arguments can be read from multiple files
 I4 fo' realz. Arguments can be read from command line
 I5 fo' realz. Arguments can be read from a table
 I6 fo' realz. Arguments can be read from tha same file rockin #! (shebang)
 I7. Line oriented input as default (Quotin of special chars not needed)
.PP
Manipulation of input
 M1. Composed command
 M2. Multiple arguments can fill up a execution line
 M3 fo' realz. Arguments can be put anywhere up in tha execution line
 M4. Multiple arguments can be put anywhere up in tha execution line
 M5 fo' realz. Arguments can be replaced wit context
 M6. Input can be treated as complete execution line
.PP
Outputs
 O1. Groupin output so output from different thangs do not mix
 O2. Right back up in yo muthafuckin ass. Send stderr (standard error) ta stderr (standard error)
 O3. Right back up in yo muthafuckin ass. Send stdout (standard output) ta stdout (standard output)
 O4. Order of output can be same as order of input
 O5. Right back up in yo muthafuckin ass. Stdout only gotz nuff stdout (standard output) from tha command
 O6. Right back up in yo muthafuckin ass. Stderr only gotz nuff stderr (standard error) from tha command
.PP
Execution
 E1. Hustlin thangs up in parallel
 E2. List hustlin thangs
 E3. Finish hustlin thangs yo, but do not start freshly smoked up thangs
 E4. Number of hustlin thangs can depend on number of cpus
 E5. Finish hustlin thangs yo, but do not start freshly smoked up thangs afta first failure
 E6. Number of hustlin thangs can be adjusted while hustlin
.PP
Remote execution
 R1. Jobs can be run on remote computers
 R2. Basefilez can be transferred
 R3 fo' realz. Argument filez can be transferred
 R4. Result filez can be transferred
 R5. Cleanup of transferred files
 R6. No config filez needed
 R7. Do not run mo' than \s-1SSHD\s0z MaxStartup can handle
 R8. Configurable \s-1SSH\s0 command
 R9. Retry if connection breaks occasionally
.PP
Semaphore
 S1. Possibilitizzle ta work as a mutex
 S2. Possibilitizzle ta work as a cold-ass lil countin semaphore
.PP
Legend
 \- = no
 x = not applicable
 \s-1ID\s0 = yes
.PP
As every last muthafuckin freshly smoked up version of tha programs is not tested tha table may be
outdated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Please file a funky-ass bug-report if you find errors (See \s-1REPORTING
BUGS\s0).
.PP
parallel:
I1 I2 I3 I4 I5 I6 I7
M1 M2 M3 M4 M5 M6
O1 O2 O3 O4 O5 O6
E1 E2 E3 E4 E5 E6
R1 R2 R3 R4 R5 R6 R7 R8 R9
S1 S2
.PP
xargs:
I1 I2 \-  \-  \-  \-  \-
\&\-  M2 M3 \-  \-  \-
\&\-  O2 O3 \-  O5 O6
E1 \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  x  \-  \-  \-
\&\-  \-
.PP
find \-exec:
\&\-  \-  \-  x  \-  x  \-
\&\-  M2 M3 \-  \-  \-  \-
\&\-  O2 O3 O4 O5 O6
\&\-  \-  \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  \-  \-  \-  \-
x  x
.PP
make \-j:
\&\-  \-  \-  \-  \-  \-  \-
\&\-  \-  \-  \-  \-  \-
O1 O2 O3 \-  x  O6
E1 \-  \-  \-  E5 \-
\&\-  \-  \-  \-  \-  \-  \-  \-  \-
\&\-  \-
.PP
ppss:
I1 I2 \-  \-  \-  \-  I7
M1 \-  M3 \-  \-  M6
O1 \-  \-  x  \-  \-
E1 E2 ?E3 E4 \- \-
R1 R2 R3 R4 \-  \-  ?R7 ? ?
\&\-  \-
.PP
pexec:
I1 I2 \-  I4 I5 \-  \-
M1 \-  M3 \-  \-  M6
O1 O2 O3 \-  O5 O6
E1 \-  \-  E4 \-  E6
R1 \-  \-  \-  \-  R6 \-  \-  \-
S1 \-
.PP
xjobs: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features xjobs
supports (See \s-1REPORTING BUGS\s0).
.PP
prll: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features prll
supports (See \s-1REPORTING BUGS\s0).
.PP
dxargs: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features dxargs
supports (See \s-1REPORTING BUGS\s0).
.PP
mdm/middelman: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what
features mdm/middelman supports (See \s-1REPORTING BUGS\s0).
.PP
xapply: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features xapply
supports (See \s-1REPORTING BUGS\s0).
.PP
paexec: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features paexec
supports (See \s-1REPORTING BUGS\s0).
.PP
ClusterSSH: \s-1TODO \-\s0 Please file a funky-ass bug-report if you know what tha fuck features ClusterSSH
supports (See \s-1REPORTING BUGS\s0).
.SS "\s-1DIFFERENCES BETWEEN\s0 xargs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xargs AND GNU Parallel"
\&\fBxargs\fR offer a shitload of tha same possibilitizzles as \s-1GNU \s0\fBparallel\fR.
.PP
\&\fBxargs\fR deals badly wit special charactas (like fuckin space, ' and
"). To peep tha problem try this:
.PP
.Vb 5
\&  bust a nut on blingin_file
\&  bust a nut on \*(Aqnot blingin_file\*(Aq
\&  ls not* | xargs rm
\&  mkdir \-p "My fuckin brother\*(Aqs 12\e" records"
\&  ls | xargs rmdir
.Ve
.PP
Yo ass can specify \fB\-0\fR or \fB\-d \*(L"\en\*(R"\fR yo, but nuff input generators is not
optimized fo' rockin \fB\s-1NUL\s0\fR as separator but is optimized for
\&\fBnewline\fR as separator. Shiiit, dis aint no joke. E.g \fBhead\fR, \fBtail\fR, \fBawk\fR, \fBls\fR, \fBecho\fR,
\&\fBsed\fR, \fBtar \-v\fR, \fBperl\fR (\fB\-0\fR n' \e0 instead of \en), \fBlocate\fR
(requires rockin \fB\-0\fR), \fBfind\fR (requires rockin \fB\-print0\fR), \fBgrep\fR
(requires user ta use \fB\-z\fR or \fB\-Z\fR), \fBsort\fR (requires rockin \fB\-z\fR).
.PP
So \s-1GNU \s0\fBparallel\fRz newline separation can be emulated with:
.PP
\&\fBcat | xargs \-d \*(L"\en\*(R" \-n1 \f(BIcommand\fB\fR
.PP
\&\fBxargs\fR can run a given number of thangs up in parallel yo, but has no
support fo' hustlin number-of-cpu-cores thangs up in parallel.
.PP
\&\fBxargs\fR has no support fo' groupin tha output, therefore output may
run together, e.g. tha straight-up original gangsta half of a line is from one process and
the last half of tha line is from another process. Da example
\&\fBParallel grep\fR cannot be done reliably wit \fBxargs\fR cuz of
this. To peep dis up in action try:
.PP
.Vb 8
\&  parallel perl \-e \*(Aq\e$a=\e"1{}\e"x10000000\e;print\e \e$a,\e"\e\en\e"\*(Aq \*(Aq>\*(Aq {} ::: a funky-ass b c d e f
\&  ls \-l a funky-ass b c d e f
\&  parallel \-kP4 \-n1 grep 1 > out.par ::: a funky-ass b c d e f
\&  echo a funky-ass b c d e f | xargs \-P4 \-n1 grep 1 > out.xargs\-unbuf
\&  echo a funky-ass b c d e f | xargs \-P4 \-n1 grep \-\-line\-buffered 1 > out.xargs\-linebuf
\&  echo a funky-ass b c d e f | xargs \-n1 grep \-\-line\-buffered 1 > out.xargs\-serial
\&  ls \-l out*
\&  md5sum out*
.Ve
.PP
\&\fBxargs\fR has no support fo' keepin tha order of tha output, therefore
if hustlin thangs up in parallel rockin \fBxargs\fR tha output of tha second
job cannot be postponed till tha straight-up original gangsta thang is done.
.PP
\&\fBxargs\fR has no support fo' hustlin thangs on remote computers.
.PP
\&\fBxargs\fR has no support fo' context replace, so yo big-ass booty is ghon gotta create the
arguments.
.PP
If you bust a replace strang up in \fBxargs\fR (\fB\-I\fR) you can not force
\&\fBxargs\fR ta use mo' than one argument.
.PP
Quotin up in \fBxargs\fR works like \fB\-q\fR up in \s-1GNU \s0\fBparallel\fR. This means
composed commandz n' redirection require rockin \fBbash \-c\fR.
.PP
\&\fBls | parallel "wc {} \fR> \fB{}.wc"\fR
.PP
becomes (assumin you have 8 cores)
.PP
\&\fBls | xargs \-d \*(L"\en\*(R" \-P8 \-I {} bash \-c "wc {} \fR>\fB {}.wc"\fR
.PP
and
.PP
\&\fBls | parallel \*(L"echo {}; ls {}|wc\*(R"\fR
.PP
becomes (assumin you have 8 cores)
.PP
\&\fBls | xargs \-d \*(L"\en\*(R" \-P8 \-I {} bash \-c \*(L"echo {}; ls {}|wc\*(R"\fR
.SS "\s-1DIFFERENCES BETWEEN\s0 find \-exec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN find -exec AND GNU Parallel"
\&\fBfind \-exec\fR offer a shitload of tha same possibilitizzles as \s-1GNU \s0\fBparallel\fR.
.PP
\&\fBfind \-exec\fR only works on files. Right back up in yo muthafuckin ass. So processin other input (such as
hosts or URLs) will require bustin these inputs as files. \fBfind
\&\-exec\fR has no support fo' hustlin commandz up in parallel.
.SS "\s-1DIFFERENCES BETWEEN\s0 make \-j \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN make -j AND GNU Parallel"
\&\fBmake \-j\fR can run thangs up in parallel yo, but requires a cold-ass lil crafted Makefile
to do all dis bullshit. That thangs up in dis biatch up in extra quotin ta git filename containing
newline ta work erectly.
.PP
\&\fBmake \-j\fR has no support fo' groupin tha output, therefore output
may run together, e.g. tha straight-up original gangsta half of a line is from one process
and tha last half of tha line is from another process. Da example
\&\fBParallel grep\fR cannot be done reliably wit \fBmake \-j\fR cuz of
this.
.PP
(Straight-up early versionz of \s-1GNU \s0\fBparallel\fR was coincidently implemented
usin \fBmake \-j\fR).
.SS "\s-1DIFFERENCES BETWEEN\s0 ppss \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN ppss AND GNU Parallel"
\&\fBppss\fR be also a tool fo' hustlin thangs up in parallel.
.PP
Da output of \fBppss\fR is status shiznit n' thus not useful for
usin as input fo' another command. Y'all KNOW dat shit, muthafucka! Da output from tha thangs is put
into files.
.PP
Da argument replace strang ($ITEM) cannot be chizzled. Y'all KNOW dat shit, muthafucka! Arguments must
be quoted \- thus arguments containin special charactas (space '"&!*)
may cause problems. Mo' than one argument aint supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. File
names containin newlines is not processed erectly. When reading
input from a gangbangin' file null cannot be used as a terminator. Shiiit, dis aint no joke. \fBppss\fR needs
to read tha whole input file before startin any thangs.
.PP
Output n' status shiznit is stored up in ppss_dir n' thus requires
cleanup when completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha dir aint removed before hustlin
\&\fBppss\fR again n' again n' again it may cause not a god damn thang ta happen as \fBppss\fR be thinkin the
task be already done. \s-1GNU \s0\fBparallel\fR will normally not need cleaning
up if hustlin locally n' will only need cleanin up if stopped
abnormally n' hustlin remote (\fB\-\-cleanup\fR may not complete if
stopped abnormally). Da example \fBParallel grep\fR would require extra
postprocessin if freestyled rockin \fBppss\fR.
.PP
For remote systems \s-1PPSS\s0 requires 3 steps: config, deploy, and
start. \s-1GNU \s0\fBparallel\fR only requires one step.
.PP
\fI\s-1EXAMPLES FROM\s0 ppss \s-1MANUAL\s0\fR
.IX Subsection "EXAMPLES FROM ppss MANUAL"
.PP
Here is tha examplez from \fBppss\fRz manual page wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR ./ppss.sh standalone \-d /path/to/filez \-c 'gzip '
.PP
\&\fB1\fR find /path/to/filez \-type f | parallel gzip
.PP
\&\fB2\fR ./ppss.sh standalone \-d /path/to/filez \-c 'cp \*(L"$ITEM\*(R" /destination/dir '
.PP
\&\fB2\fR find /path/to/filez \-type f | parallel cp {} /destination/dir
.PP
\&\fB3\fR ./ppss.sh standalone \-f list\-of\-urls.txt \-c 'wget \-q '
.PP
\&\fB3\fR parallel \-a list\-of\-urls.txt wget \-q
.PP
\&\fB4\fR ./ppss.sh standalone \-f list\-of\-urls.txt \-c 'wget \-q \*(L"$ITEM\*(R"'
.PP
\&\fB4\fR parallel \-a list\-of\-urls.txt wget \-q {}
.PP
\&\fB5\fR ./ppss config \-C config.cfg \-c 'encode.sh ' \-d /source/dir \-m
192.168.1.100 \-u ppss \-k ppss\-key.key \-S ./encode.sh \-n nodes.txt \-o
/some/output/dir \-\-upload \-\-downlizzle ; ./ppss deploy \-C config.cfg ;
\&./ppss start \-C config
.PP
\&\fB5\fR # parallel do not use configs. If you want a gangbangin' finger-lickin' different username put it up in nodes.txt: user@hostname
.PP
\&\fB5\fR find source/dir \-type f | parallel \-\-sshloginfile nodes.txt \-\-trc {.}.mp3 lame \-a {} \-o {.}.mp3 \-\-preset standard \-\-quiet
.PP
\&\fB6\fR ./ppss stop \-C config.cfg
.PP
\&\fB6\fR killall \-TERM parallel
.PP
\&\fB7\fR ./ppss pause \-C config.cfg
.PP
\&\fB7\fR Press: CTRL-Z or killall \-SIGTSTP parallel
.PP
\&\fB8\fR ./ppss continue \-C config.cfg
.PP
\&\fB8\fR Enter: fg or killall \-SIGCONT parallel
.PP
\&\fB9\fR ./ppss.sh status \-C config.cfg
.PP
\&\fB9\fR killall \-SIGUSR2 parallel
.SS "\s-1DIFFERENCES BETWEEN\s0 pexec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN pexec AND GNU Parallel"
\&\fBpexec\fR be also a tool fo' hustlin thangs up in parallel.
.PP
Here is tha examplez from \fBpexec\fRz info page wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR pexec \-o sqrt\-%s.dat \-p \*(L"$(seq 10)\*(R" \-e \s-1NUM\s0 \-n 4 \-c \*(-- \e
  'echo \*(L"scale=10000;sqrt($NUM)\*(R" | bc'
.PP
\&\fB1\fR seq 10 | parallel \-j4 'echo \*(L"scale=10000;sqrt({})\*(R" | bc > sqrt\-{}.dat'
.PP
\&\fB2\fR pexec \-p \*(L"$(ls myfiles*.ext)\*(R" \-i \f(CW%s\fR \-o \f(CW%s\fR.sort \*(-- sort
.PP
\&\fB2\fR ls myfiles*.ext | parallel sort {} \*(L">{}.sort\*(R"
.PP
\&\fB3\fR pexec \-f image.list \-n auto \-e B \-u star.log \-c \*(-- \e
  'fistar \f(CW$B\fR.fits \-f 100 \-F id,x,y,flux \-o \f(CW$B\fR.star'
.PP
\&\fB3\fR parallel \-a image.list \e
  'fistar {}.fits \-f 100 \-F id,x,y,flux \-o {}.star' 2>star.log
.PP
\&\fB4\fR pexec \-r *.png \-e \s-1IMG\s0 \-c \-o \- \*(-- \e
  'convert \f(CW$IMG\fR ${IMG%.png}.jpeg ; \*(L"echo \f(CW$IMG:\fR done\*(R"'
.PP
\&\fB4\fR ls *.png | parallel 'convert {} {.}.jpeg; echo {}: done'
.PP
\&\fB5\fR pexec \-r *.png \-i \f(CW%s\fR \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB5\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {}.jpg'
.PP
\&\fB6\fR fo' p up in *.png ; do echo ${p%.png} ; done | \e
  pexec \-f \- \-i \f(CW%s\fR.png \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB6\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {.}.jpg'
.PP
\&\fB7\fR LIST=$(for p up in *.png ; do echo ${p%.png} ; done)
  pexec \-r \f(CW$LIST\fR \-i \f(CW%s\fR.png \-o \f(CW%s\fR.jpg \-c 'pngtopnm | pnmtojpeg'
.PP
\&\fB7\fR ls *.png | parallel 'pngtopnm < {} | pnmtojpeg > {.}.jpg'
.PP
\&\fB8\fR pexec \-n 8 \-r *.jpg \-y unix \-e \s-1IMG\s0 \-c \e
  'pexec \-j \-m blockread \-d \f(CW$IMG\fR | \e
  jpegtopnm | pnmscale 0.5 | pnmtojpeg | \e
  pexec \-j \-m blockwrite \-s th_$IMG'
.PP
\&\fB8\fR Combinin \s-1GNU \s0\fBparallel\fR n' \s-1GNU \s0\fBsem\fR.
.PP
\&\fB8\fR ls *jpg | parallel \-j8 'sem \-\-id blockread pussaaaaay {} | jpegtopnm |' \e
  'pnmscale 0.5 | pnmtojpeg | sem \-\-id blockwrite pussaaaaay > th_{}'
.PP
\&\fB8\fR If readin n' freestylin is done ta tha same disk, dis may be
fasta as only one process is ghon be either readin or writing:
.PP
\&\fB8\fR ls *jpg | parallel \-j8 'sem \-\-id diskio pussaaaaay {} | jpegtopnm |' \e
  'pnmscale 0.5 | pnmtojpeg | sem \-\-id diskio pussaaaaay > th_{}'
.SS "\s-1DIFFERENCES BETWEEN\s0 xjobs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xjobs AND GNU Parallel"
\&\fBxjobs\fR be also a tool fo' hustlin thangs up in parallel. Well shiiiit, it only supports
runnin thangs on yo' local computer.
.PP
\&\fBxjobs\fR deals badly wit special charactas just like \fBxargs\fR. Right back up in yo muthafuckin ass. See
the section \fB\s-1DIFFERENCES BETWEEN\s0 xargs \s-1AND GNU\s0 Parallel\fR.
.PP
Here is tha examplez from \fBxjobs\fRz playa page wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR ls \-1 *.zip | xjobs unzip
.PP
\&\fB1\fR ls *.zip | parallel unzip
.PP
\&\fB2\fR ls \-1 *.zip | xjobs \-n unzip
.PP
\&\fB2\fR ls *.zip | parallel unzip >/dev/null
.PP
\&\fB3\fR find . \-name '*.bak' | xjobs gzip
.PP
\&\fB3\fR find . \-name '*.bak' | parallel gzip
.PP
\&\fB4\fR ls \-1 *.jar | sed 's/\e(.*\e)/\e1 > \e1.idx/' | xjobs jar tf
.PP
\&\fB4\fR ls *.jar | parallel jar tf {} '>' {}.idx
.PP
\&\fB5\fR xjobs \-s script
.PP
\&\fB5\fR pussaaaaay script | parallel
.PP
\&\fB6\fR mkfifo /var/run/my_named_pipe;
xjobs \-s /var/run/my_named_pipe &
echo unzip 1.zip >> /var/run/my_named_pipe;
echo tar cf /backup/myhome.tar /home/me >> /var/run/my_named_pipe
.PP
\&\fB6\fR mkfifo /var/run/my_named_pipe;
cat /var/run/my_named_pipe | parallel &
echo unzip 1.zip >> /var/run/my_named_pipe;
echo tar cf /backup/myhome.tar /home/me >> /var/run/my_named_pipe
.SS "\s-1DIFFERENCES BETWEEN\s0 prll \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN prll AND GNU Parallel"
\&\fBprll\fR be also a tool fo' hustlin thangs up in parallel. Well shiiiit, it do not
support hustlin thangs on remote computers.
.PP
\&\fBprll\fR encourages rockin \s-1BASH\s0 aliases n' \s-1BASH\s0 functions instead of
scripts, n' you can put dat on yo' toast. \s-1GNU \s0\fBparallel\fR aint NEVER gonna support hustlin aliases (see why
http://www.perlmonks.org/index.pl?node_id=484296). But fuck dat shiznit yo, tha word on tha street is dat scripts,
composed commands, or functions exported wit \fBexport \-f\fR work just
fine.
.PP
\&\fBprll\fR generates a shitload of status shiznit on stderr (standard
error) which make it harder ta use tha stderr (standard error) output
of tha thang directly as input fo' another program.
.PP
Here is tha example from \fBprll\fRz playa page wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.PP
prll \-s 'mogrify \-flip \f(CW$1\fR' *.jpg
.PP
parallel mogrify \-flip ::: *.jpg
.SS "\s-1DIFFERENCES BETWEEN\s0 dxargs \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN dxargs AND GNU Parallel"
\&\fBdxargs\fR be also a tool fo' hustlin thangs up in parallel.
.PP
\&\fBdxargs\fR do not deal well wit mo' simultaneous thangs than \s-1SSHD\s0's
MaxStartup. \fBdxargs\fR is only built fo' remote run thangs yo, but do not
support transferrin of files.
.SS "\s-1DIFFERENCES BETWEEN\s0 mdm/middleman \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN mdm/middleman AND GNU Parallel"
middleman(mdm) be also a tool fo' hustlin thangs up in parallel.
.PP
Here is tha shellscriptz of http://mdm.berlios.de/usage.html ported
to \s-1GNU \s0\fBparallel\fR:
.PP
\&\fBseq 19 | parallel buffon \-o \- | sort \-n \fR>\fB result\fR
.PP
\&\fBcat filez | parallel cmd\fR
.PP
\&\fBfind dir \-execdir sem cmd {} \e;\fR
.SS "\s-1DIFFERENCES BETWEEN\s0 xapply \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN xapply AND GNU Parallel"
\&\fBxapply\fR can run thangs up in parallel on tha local computer.
.PP
Here is tha examplez from \fBxapply\fRz playa page wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.PP
\&\fB1\fR xapply '(cd \f(CW%1\fR && make all)' */
.PP
\&\fB1\fR parallel 'cd {} && make all' ::: */
.PP
\&\fB2\fR xapply \-f 'diff \f(CW%1\fR ../version5/%1' manifest | more
.PP
\&\fB2\fR parallel diff {} ../version5/{} < manifest | more
.PP
\&\fB3\fR xapply \-p/dev/null \-f 'diff \f(CW%1\fR \f(CW%2\fR' manifest1 checklist1
.PP
\&\fB3\fR parallel \-\-xapply diff {1} {2} :::: manifest1 checklist1
.PP
\&\fB4\fR xapply 'indent' *.c
.PP
\&\fB4\fR parallel indent ::: *.c
.PP
\&\fB5\fR find ~ksb/bin \-type f ! \-perm \-111 \-print | xapply \-f \-v 'chmod a+x' \-
.PP
\&\fB5\fR find ~ksb/bin \-type f ! \-perm \-111 \-print | parallel \-v chmod a+x
.PP
\&\fB6\fR find */ \-... | fmt 960 1024 | xapply \-f \-i /dev/tty 'vi' \-
.PP
\&\fB6\fR sh <(find */ \-... | parallel \-s 1024 echo vi)
.PP
\&\fB6\fR find */ \-... | parallel \-s 1024 \-Xuj1 vi
.PP
\&\fB7\fR find ... | xapply \-f \-5 \-i /dev/tty 'vi' \- \- \- \- \-
.PP
\&\fB7\fR sh <(find ... |parallel \-n5 echo vi)
.PP
\&\fB7\fR find ... |parallel \-n5 \-uj1 vi
.PP
\&\fB8\fR xapply \-fn "" /etc/passwd
.PP
\&\fB8\fR parallel \-k echo < /etc/passwd
.PP
\&\fB9\fR tr ':' '\e012' < /etc/passwd | xapply \-7 \-nf 'chown \f(CW%1\fR \f(CW%6\fR' \- \- \- \- \- \- \-
.PP
\&\fB9\fR tr ':' '\e012' < /etc/passwd | parallel \-N7 chown {1} {6}
.PP
\&\fB10\fR xapply '[ \-d \f(CW%1\fR/RCS ] || echo \f(CW%1\fR' */
.PP
\&\fB10\fR parallel '[ \-d {}/RCS ] || echo {}' ::: */
.PP
\&\fB11\fR xapply \-f '[ \-f \f(CW%1\fR ] && echo \f(CW%1\fR' List | ...
.PP
\&\fB11\fR parallel '[ \-f {} ] && echo {}' < List | ...
.SS "\s-1DIFFERENCES BETWEEN\s0 paexec \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN paexec AND GNU Parallel"
\&\fBpaexec\fR can run thangs up in parallel on both tha local n' remote computers.
.PP
\&\fBpaexec\fR requires commandz ta print a funky-ass blank line as tha last
output. This means yo big-ass booty is ghon gotta write a wrapper fo' most programs.
.PP
\&\fBpaexec\fR has a thang dependency facilitizzle so a thang can depend on another
job ta be executed successfully. Right back up in yo muthafuckin ass. Sort of a skanky-manz \fBmake\fR.
.PP
Here is tha examplez from \fBpaexec\fRz example catalog wit tha equivalent
usin \s-1GNU \s0\fBparallel\fR:
.IP "1_div_X_run:" 1
.IX Item "1_div_X_run:"
.Vb 2
\&  ../../paexec \-s \-l \-c "\`pwd\`/1_div_X_cmd" \-n +1 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq \`pwd\`/1_div_X_cmd <<EOF [...]
.Ve
.IP "all_substr_run:" 1
.IX Item "all_substr_run:"
.Vb 2
\&  ../../paexec \-lp \-c "\`pwd\`/all_substr_cmd" \-n +3 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq \`pwd\`/all_substr_cmd <<EOF [...]
.Ve
.IP "cc_wrapper_run:" 1
.IX Item "cc_wrapper_run:"
.Vb 8
\&  ../../paexec \-c "env CC=gcc CFLAGS=\-O2 \`pwd\`/cc_wrapper_cmd" \e
\&             \-n \*(Aqhost1 host2\*(Aq \e
\&             \-t \*(Aq/usr/bin/ssh \-x\*(Aq <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq "env CC=gcc CFLAGS=\-O2 \`pwd\`/cc_wrapper_cmd" \e
\&             \-S host1,host2 <<EOF [...]
\&  # This aint exactly tha same yo, but avoidz tha wrapper
\&  parallel gcc \-O2 \-c \-o {.}.o {} \e
\&             \-S host1,host2 <<EOF [...]
.Ve
.IP "toupper_run:" 1
.IX Item "toupper_run:"
.Vb 4
\&  ../../paexec \-lp \-c "\`pwd\`/toupper_cmd" \-n +10 <<EOF [...]
\&  parallel echo {} \*(Aq|\*(Aq ./toupper_cmd <<EOF [...]
\&  # Without tha wrapper:
\&  parallel echo {} \*(Aq| awk {print\e toupper\e(\e$0\e)}\*(Aq <<EOF [...]
.Ve
.SS "\s-1DIFFERENCES BETWEEN\s0 ClusterSSH \s-1AND GNU\s0 Parallel"
.IX Subsection "DIFFERENCES BETWEEN ClusterSSH AND GNU Parallel"
ClusterSSH solves a gangbangin' finger-lickin' different problem than \s-1GNU \s0\fBparallel\fR.
.PP
ClusterSSH opens a terminal window fo' each computa n' rockin a
masta window you can run tha same command on all tha computers. This
is typically used fo' administratin nuff muthafuckin computas dat is almost
identical.
.PP
\&\s-1GNU \s0\fBparallel\fR runs tha same ol' dirty (or different) commandz wit different
arguments up in parallel possibly rockin remote computas ta help
computing. If mo' than one computa is listed up in \fB\-S\fR \s-1GNU \s0\fBparallel\fR may
only use one of these (e.g. if there be 8 thangs ta be run n' one
computa has 8 cores).
.PP
\&\s-1GNU \s0\fBparallel\fR can be used as a skanky-manz version of ClusterSSH:
.PP
\&\fBparallel \-\-nonall \-S server\-a,server\-b do_shiznit foo bar\fR
.SH "BUGS"
.IX Header "BUGS"
.SS "Quotin of newline"
.IX Subsection "Quotin of newline"
Because of tha way newline is quoted dis aint gonna work:
.PP
echo 1,2,3 | parallel \-vkd, \*(L"echo 'a{}b'\*(R"
.PP
But fuck dat shiznit yo, tha word on tha street is dat these will all work:
.PP
echo 1,2,3 | parallel \-vkd, echo a{}b
.PP
echo 1,2,3 | parallel \-vkd, \*(L"echo 'a'{}'b'\*(R"
.PP
echo 1,2,3 | parallel \-vkd, \*(L"echo 'a'\*(R"{}\*(L"'b'\*(R"
.SS "Speed"
.IX Subsection "Speed"
\fIStartup\fR
.IX Subsection "Startup"
.PP
\&\s-1GNU \s0\fBparallel\fR is slow at startin up \- round 250 ms yo. Half of the
startup time is dropped findin tha maximal length of a cold-ass lil command
line. Right back up in yo muthafuckin ass. Settin \fB\-s\fR will remove dis part of tha startup time.
.PP
\fIThang startup\fR
.IX Subsection "Thang startup"
.PP
Startin a thang on tha local machine takes round 3 ms. This can be a
bangin' overhead if tha thang takes straight-up few ms ta run. I aint talkin' bout chicken n' gravy biatch. Often you can group
small thangs together rockin \fB\-X\fR which will make tha overhead less
significant.
.PP
Usin \fB\-\-ungroup\fR tha 3 ms can be lowered ta round 2 ms.
.PP
\fI\s-1SSH\s0\fR
.IX Subsection "SSH"
.PP
When rockin multiple computas \s-1GNU \s0\fBparallel\fR opens \fBssh\fR connections
to dem ta figure up how tha fuck nuff connections can be used reliably
simultaneously (Namely \s-1SSHD\s0z MaxStartup). This test is done fo' each
host up in serial, so if yo' \fB\-\-sshloginfile\fR gotz nuff nuff hosts it may
be slow.
.PP
If yo' thangs is short you may peep dat there be fewer thangs hustlin
on tha remove systems than expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is cuz of time dropped logging
in n' out. \fB\-M\fR may help here.
.PP
\fIDisk access\fR
.IX Subsection "Disk access"
.PP
A single disk can normally read data fasta if it readz one file at a
time instead of readin a shitload of filez up in parallel, as dis will avoid
disk seeks. But fuck dat shiznit yo, tha word on tha street is dat newer disk systems wit multiple drives can read
fasta if readin from multiple filez up in parallel.
.PP
If tha thangs iz of tha form read-all-compute-all-write-all, so
everythang is read before anythang is written, it may be fasta to
force only one disk access all up in tha time:
.PP
.Vb 1
\&  sem \-\-id diskio pussaaaaay file | compute | sem \-\-id diskio pussaaaaay > file
.Ve
.PP
If tha thangs iz of tha form read-compute-write, so freestylin starts
before all readin is done, it may be fasta ta force only one reader
and writa all up in tha time:
.PP
.Vb 1
\&  sem \-\-id read pussaaaaay file | compute | sem \-\-id write pussaaaaay > file
.Ve
.PP
If tha thangs iz of tha form read-compute-read-compute, it may be
fasta ta run mo' thangs up in parallel than tha system has CPUs, as some
of tha thangs is ghon be stuck waitin fo' disk access.
.SS "\-\-nice limits command length"
.IX Subsection "--nice limits command length"
Da current implementation of \fB\-\-nice\fR is too pessimistic up in tha max
allowed command length. Well shiiiit, it only uses a lil mo' than half of what
it could. Y'all KNOW dat shit, muthafucka! This affects \fB\-X\fR n' \fB\-m\fR. If dis becomes a real problem for
you file a funky-ass bug-report.
.SS "Aliases n' functions do not work"
.IX Subsection "Aliases n' functions do not work"
If you get:
.PP
\&\fBCan't exec "\f(BIcommand\fB": No such file or directory\fR
.PP
or:
.PP
\&\fBopen3: exec of by \f(BIcommand\fB failed\fR
.PP
it may be cuz \fIcommand\fR aint known yo, but it could also be
because \fIcommand\fR be a alias or a gangbangin' function. I aint talkin' bout chicken n' gravy biatch. If it aint nuthin but a gangbangin' function you
need ta \fBexport \-f\fR tha function first fo' realz. An alias will, however, not
work (see why http://www.perlmonks.org/index.pl?node_id=484296), so
change yo' alias ta a script.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Report bugs ta <bug\-parallel@gnu.org> or
https://savannah.gnu.org/bugs/?func=additem&group=parallel
.PP
Yo crazy-ass bug report should always include:
.IP "\(bu" 2
Da error message you git (if any).
.IP "\(bu" 2
Da output of \fBparallel \-\-version\fR. If yo ass is not hustlin tha sickest fuckin
released version you should specify why you believe tha problem is not
fixed up in dat version.
.IP "\(bu" 2
A complete example dat others can run dat shows tha problem. This
should preferably be lil' small-ass n' simple fo' realz. A combination of \fByes\fR, \fBseq\fR,
\&\fBcat\fR, \fBecho\fR, n' \fBsleep\fR can reproduce most errors. If your
example requires big-ass files, peep if you can make dem by something
like \fBseq 1000000\fR > \fBfile\fR or \fByes | head \-n 10000000\fR > \fBfile\fR.
.IP "\(bu" 2
Da output of yo' example. If yo' problem aint easily reproduced
by others, tha output might help dem figure up tha problem.
.PP
If you suspect tha error is dependent on yo' environment or
distribution, please peep if you can reproduce tha error on one of
these VirtualBox images:
http://sourceforge.net/projects/virtualboximage/files/
.PP
Specifyin tha name of yo' distribution aint enough as you may have
installed software dat aint up in tha VirtualBox images.
.PP
If you cannot reproduce tha error on any of tha VirtualBox images
above, you should assume tha debuggin is ghon be done all up in yo thugged-out ass. That
will put mo' burden on you n' it is extra blingin you give any
information dat help.
.SH "AUTHOR"
.IX Header "AUTHOR"
When rockin \s-1GNU \s0\fBparallel\fR fo' a publication please cite:
.PP
O. Tange (2011): \s-1GNU\s0 Parallel \- Da Command-Line Juice Tool, ;login:
Da \s-1USENIX\s0 Magazine, February 2011:42\-47.
.PP
Copyright (C) 2007\-10\-18 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2008,2009,2010 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2010,2011,2012,2013 Ole Tange, http://ole.tange.dk and
Jacked Software Foundation, Inc.
.PP
Partz of tha manual concernin \fBxargs\fR compatibilitizzle is inspired by
the manual of \fBxargs\fR from \s-1GNU\s0 findutils 4.4.2.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2007,2008,2009,2010,2011,2012,2013 Jacked Software Foundation,
Inc.
.PP
This program is free software; you can redistribute it and/or modify
it under tha termz of tha \s-1GNU\s0 General Public License as published by
the Jacked Software Foundation; either version 3 of tha License, or
at yo' option any lata version.
.PP
This program is distributed up in tha hope dat it is ghon be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even tha implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See the
\&\s-1GNU\s0 General Public License fo' mo' details.
.PP
Yo ass should have received a cold-ass lil copy of tha \s-1GNU\s0 General Public License
along wit dis program.  If not, peep <http://www.gnu.org/licenses/>.
.SS "Documentation license I"
.IX Subsection "Documentation license I"
Permission is granted ta copy, distribute and/or modify dis documentation
under tha termz of tha \s-1GNU\s0 Jacked Documentation License, Version 1.3 or
any lata version published by tha Jacked Software Foundation; wit no
Invariant Sections, wit no Front-Cover Texts, n' wit no Back-Cover
Texts, n' you can put dat on yo' toast.  A copy of tha license is included up in tha file fdl.txt.
.SS "Documentation license \s-1II\s0"
.IX Subsection "Documentation license Pt II"
Yo ass is free:
.IP "\fBto Share\fR" 9
.IX Item "to Share"
to copy, distribute n' transmit tha work
.IP "\fBto Remix\fR" 9
.IX Item "to Remix"
to adapt tha work
.PP
Under tha followin conditions:
.IP "\fBAttribution\fR" 9
.IX Item "Attribution"
Yo ass must attribute tha work up in tha manner specified by tha lyricist or
licensor (but not up in any way dat suggests dat they endorse you or
your use of tha work).
.IP "\fBSmoke up Alike\fR" 9
.IX Item "Smoke up Alike"
If you alter, transform, or build upon dis work, you may distribute
the resultin work only under tha same, similar or a cold-ass lil compatible
license.
.PP
With tha understandin that:
.IP "\fBWaiver\fR" 9
.IX Item "Waiver"
Any of tha above conditions can be waived if you git permission from
the copyright holder.
.IP "\fBPublic Domain\fR" 9
.IX Item "Public Domain"
Where tha work or any of its elements is up in tha hood domain under
applicable law, dat status is up in no way affected by tha license.
.IP "\fBOther Rights\fR" 9
.IX Item "Other Rights"
In no way is any of tha followin muthafuckin rights affected by tha license:
.RS 9
.IP "\(bu" 2
Yo crazy-ass fair dealin or fair use rights, or other applicable
copyright exceptions n' limitations;
.IP "\(bu" 2
Da authorz moral rights;
.IP "\(bu" 2
Rights other peeps may have either up in tha work itself or in
how tha work is used, like fuckin publicitizzle or privacy rights.
.RE
.RS 9
.RE
.IP "\fBNotice\fR" 9
.IX Item "Notice"
For any reuse or distribution, you must make clear ta others the
license termz of dis work.
.PP
A copy of tha full license is included up in tha file as cc\-by\-sa.txt.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
\&\s-1GNU \s0\fBparallel\fR uses Perl, n' tha Perl modulez Getopt::Long,
IPC::Open3, Symbol, IO::File, \s-1POSIX,\s0 n' File::Temp. For remote usage
it also uses rsync wit ssh.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBssh\fR(1), \fBrsync\fR(1), \fBfind\fR(1), \fBxargs\fR(1), \fBdirname\fR,
\&\fBmake\fR(1), \fBpexec\fR(1), \fBppss\fR(1), \fBxjobs\fR(1), \fBprll\fR(1),
\&\fBdxargs\fR(1), \fBmdm\fR(1),
