.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ4 1"
.TH PERLFAQ4 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq4 \- Data Manipulation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of tha \s-1FAQ\s0 lyrics thangs related ta manipulating
numbers, dates, strings, arrays, hashes, n' miscellaneous data issues.
.SH "Data: Numbers"
.IX Header "Data: Numbers"
.SS "Why is I gettin long decimals (eg, 19.9499999999999) instead of tha numbers I should be gettin (eg, 19.95)?"
.IX Subsection "Why is I gettin long decimals (eg, 19.9499999999999) instead of tha numbers I should be gettin (eg, 19.95)?"
For tha long explanation, peep Dizzy Goldbergz \*(L"What Every Computer
Scientist Should Know Bout Floating-Point Arithmetic\*(R"
(<http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf>).
.PP
Internally, yo' computa represents floating-point numbers up in binary.
Digital (as up in powerz of two) computas cannot store all numbers
exactly. Right back up in yo muthafuckin ass. Some real numbers lose precision up in tha process. This be a
problem wit how tha fuck computas store numbers n' affects all computer
languages, not just Perl.
.PP
perlnumber shows tha gory detailz of number representations and
conversions.
.PP
To limit tha number of decimal places up in yo' numbers, you can use the
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`sprintf\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See
\&\*(L"Floating-point Arithmetic\*(R" up in perlop fo' mo' details.
.PP
.Vb 1
\&    printf "%.2f", 10/3;
\&
\&    mah $number = sprintf "%.2f", 10/3;
.Ve
.SS "Why is \fIint()\fP broken?"
.IX Subsection "Why is int() broken?"
Yo crazy-ass \f(CW\*(C`int()\*(C'\fR is most probably hustlin just fine. It aint nuthin but tha numbers that
aren't like what tha fuck you think.
.PP
First, peep tha answer ta \*(L"Why is I gettin long decimals
(eg, 19.9499999999999) instead of tha numbers I should be getting
(eg, 19.95)?\*(R".
.PP
For example, this
.PP
.Vb 1
\&    print int(0.6/0.2\-2), "\en";
.Ve
.PP
will up in most computas print 0, not 1, cuz even such simple
numbers as 0.6 n' 0.2 cannot be presented exactly by floating-point
numbers. What you be thinkin up in tha above as 'three' is straight-up mo' like
2.9999999999999995559.
.SS "Why aint mah octal data interpreted erectly?"
.IX Subsection "Why aint mah octal data interpreted erectly?"
(contributed by brian d foy)
.PP
Yo ass is probably tryin ta convert a strang ta a number, which Perl only
converts as a thugged-out decimal number n' shit. When Perl converts a strang ta a number, it
ignores leadin spaces n' zeroes, then assumes tha rest of tha digits
are up in base 10:
.PP
.Vb 1
\&    mah $strin = \*(Aq0644\*(Aq;
\&
\&    print $strin + 0;  # prints 644
\&
\&    print $strin + 44; # prints 688, certainly not octal!
.Ve
.PP
This problem probably involves one of tha Perl built-ins dat has the
same name a Unix command dat uses octal numbers as arguments on the
command line. In dis example, \f(CW\*(C`chmod\*(C'\fR on tha command line knows that
its first argument is octal cuz thatz what tha fuck it do:
.PP
.Vb 1
\&    %prompt> chmod 644 file
.Ve
.PP
If you wanna use tha same literal digits (644) up in Perl, you gotta tell
Perl ta treat dem as octal numbers either by prefixin tha digits with
a \f(CW0\fR or rockin \f(CW\*(C`oct\*(C'\fR:
.PP
.Vb 2
\&    chmod(     0644, $filename );  # right, has leadin zero
\&    chmod( oct(644), $filename );  # also erect
.Ve
.PP
Da problem comes up in when you take yo' numbers from suttin' dat Perl
thinks be a string, like fuckin a cold-ass lil command line argument up in \f(CW@ARGV\fR:
.PP
.Vb 1
\&    chmod( $ARGV[0],      $filename );  # wrong, even if "0644"
\&
\&    chmod( oct($ARGV[0]), $filename );  # erect, treat strang as octal
.Ve
.PP
Yo ass can always check tha value you rockin by printin it up in octal
notation ta ensure it matches what tha fuck you be thinkin it should be. Print it
in octal  n' decimal format:
.PP
.Vb 1
\&    printf "0%o %d", $number, $number;
.Ve
.SS "Do Perl gotz a \fIround()\fP function, biatch? What bout \fIceil()\fP n' \fIfloor()\fP, biatch? Trig functions?"
.IX Subsection "Do Perl gotz a round() function, biatch? What bout ceil() n' floor(), biatch? Trig functions?"
Remember dat \f(CW\*(C`int()\*(C'\fR merely truncates toward 0. For roundin ta a
certain number of digits, \f(CW\*(C`sprintf()\*(C'\fR or \f(CW\*(C`printf()\*(C'\fR is probably the
easiest route.
.PP
.Vb 1
\&    printf("%.3f", 3.1415926535);   # prints 3.142
.Ve
.PP
Da \s-1POSIX\s0 module (part of tha standard Perl distribution)
implements \f(CW\*(C`ceil()\*(C'\fR, \f(CW\*(C`floor()\*(C'\fR, n' a fuckin shitload of other mathematical
and trigonometric functions.
.PP
.Vb 3
\&    use POSIX;
\&    mah $ceil   = ceil(3.5);   # 4
\&    mah $floor  = floor(3.5);  # 3
.Ve
.PP
In 5.000 ta 5.003 perls, trigonometry was done up in tha Math::Complex
module. With 5.004, tha Math::Trig module (part of tha standard Perl
distribution) implements tha trigonometric functions. Internally it
uses tha Math::Complex module n' some functions can break up from
the real axis tha fuck into tha complex plane, fo' example tha inverse sine of
2.
.PP
Roundin up in financial applications can have straight-up implications, and
the roundin method used should be specified precisely. In these
cases, it probably pays not ta trust whichever system of roundin is
bein used by Perl yo, but instead ta implement tha roundin function you
need yo ass.
.PP
To peep why, notice how tha fuck you gonna still have a issue on half-way-point
alternation:
.PP
.Vb 1
\&    fo' (my $i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
\&
\&    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
\&    0.8 0.8 0.9 0.9 1.0 1.0
.Ve
.PP
Don't blame Perl. It aint nuthin but tha same as up in C. \s-1IEEE\s0 say we gotta do
this. Perl numbers whose absolute joints is integers under 2**31 (on
32\-bit machines) will work pretty much like mathematical integers.
Other numbers is not guaranteed.
.SS "How tha fuck do I convert between numeric representations/bases/radixes?"
.IX Subsection "How tha fuck do I convert between numeric representations/bases/radixes?"
As always wit Perl there is mo' than one way ta do dat shit. Below is a
few examplez of approaches ta makin common conversions between number
representations. This is intended ta be representationizzle rather than
exhaustive.
.PP
Some of tha examplez lata up in perlfaq4 use tha Bit::Vector
module from \s-1CPAN.\s0 Da reason you might chizzle Bit::Vector over the
perl built-in functions is dat it works wit numberz of \s-1ANY\s0 size,
that it is optimized fo' speed on some operations, n' fo' at least
some programmers tha notation might be familiar.
.IP "How tha fuck do I convert hexadecimal tha fuck into decimal" 4
.IX Item "How tha fuck do I convert hexadecimal tha fuck into decimal"
Usin perlz built up in conversion of \f(CW\*(C`0x\*(C'\fR notation:
.Sp
.Vb 1
\&    mah $dec = 0xDEADBEEF;
.Ve
.Sp
Usin tha \f(CW\*(C`hex\*(C'\fR function:
.Sp
.Vb 1
\&    mah $dec = hex("DEADBEEF");
.Ve
.Sp
Usin \f(CW\*(C`pack\*(C'\fR:
.Sp
.Vb 1
\&    mah $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", \-8)));
.Ve
.Sp
Usin tha \s-1CPAN\s0 module \f(CW\*(C`Bit::Vector\*(C'\fR:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new_Hex(32, "DEADBEEF");
\&    mah $dec = $vec\->to_Dec();
.Ve
.IP "How tha fuck do I convert from decimal ta hexadecimal" 4
.IX Item "How tha fuck do I convert from decimal ta hexadecimal"
Usin \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 2
\&    mah $hex = sprintf("%X", 3735928559); # upper case A\-F
\&    mah $hex = sprintf("%x", 3735928559); # lower case a\-f
.Ve
.Sp
Usin \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    mah $hex = unpack("H*", pack("N", 3735928559));
.Ve
.Sp
Usin Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    mah $hex = $vec\->to_Hex();
.Ve
.Sp
And Bit::Vector supports odd bit counts:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new_Dec(33, 3735928559);
\&    $vec\->Resize(32); # suppress leadin 0 if unwanted
\&    mah $hex = $vec\->to_Hex();
.Ve
.IP "How tha fuck do I convert from octal ta decimal" 4
.IX Item "How tha fuck do I convert from octal ta decimal"
Usin Perlz built up in conversion of numbers wit leadin zeros:
.Sp
.Vb 1
\&    mah $dec = 033653337357; # note tha leadin 0!
.Ve
.Sp
Usin tha \f(CW\*(C`oct\*(C'\fR function:
.Sp
.Vb 1
\&    mah $dec = oct("33653337357");
.Ve
.Sp
Usin Bit::Vector:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new(32);
\&    $vec\->Chunk_List_Store(3, split(//, reverse "33653337357"));
\&    mah $dec = $vec\->to_Dec();
.Ve
.IP "How tha fuck do I convert from decimal ta octal" 4
.IX Item "How tha fuck do I convert from decimal ta octal"
Usin \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 1
\&    mah $oct = sprintf("%o", 3735928559);
.Ve
.Sp
Usin Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    mah $oct = reverse join(\*(Aq\*(Aq, $vec\->Chunk_List_Read(3));
.Ve
.IP "How tha fuck do I convert from binary ta decimal" 4
.IX Item "How tha fuck do I convert from binary ta decimal"
Perl 5.6 lets you write binary numbers directly with
the \f(CW\*(C`0b\*(C'\fR notation:
.Sp
.Vb 1
\&    mah $number = 0b10110110;
.Ve
.Sp
Usin \f(CW\*(C`oct\*(C'\fR:
.Sp
.Vb 2
\&    mah $input = "10110110";
\&    mah $decimal = oct( "0b$input" );
.Ve
.Sp
Usin \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`ord\*(C'\fR:
.Sp
.Vb 1
\&    mah $decimal = ord(pack(\*(AqB8\*(Aq, \*(Aq10110110\*(Aq));
.Ve
.Sp
Usin \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR fo' larger strings:
.Sp
.Vb 3
\&    mah $int = unpack("N", pack("B32",
\&    substr("0" x 32 . "11110101011011011111011101111", \-32)));
\&    mah $dec = sprintf("%d", $int);
\&
\&    # substr() is used ta left\-pad a 32\-characta strang wit zeros.
.Ve
.Sp
Usin Bit::Vector:
.Sp
.Vb 2
\&    mah $vec = Bit::Vector\->new_Bin(32, "11011110101011011011111011101111");
\&    mah $dec = $vec\->to_Dec();
.Ve
.IP "How tha fuck do I convert from decimal ta binary" 4
.IX Item "How tha fuck do I convert from decimal ta binary"
Usin \f(CW\*(C`sprintf\*(C'\fR (perl 5.6+):
.Sp
.Vb 1
\&    mah $bin = sprintf("%b", 3735928559);
.Ve
.Sp
Usin \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    mah $bin = unpack("B*", pack("N", 3735928559));
.Ve
.Sp
Usin Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    mah $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    mah $bin = $vec\->to_Bin();
.Ve
.Sp
Da remainin transformations (e.g. hex \-> oct, bin \-> hex, etc.)
are left as a exercise ta tha inclined reader.
.SS "Why don't & work tha way I want it to?"
.IX Subsection "Why don't & work tha way I want it to?"
Da behavior of binary arithmetic operators dependz on whether they're
used on numbers or strings. Da operators treat a strang as a series
of bits n' work wit dat (the strang \f(CW"3"\fR is tha bit pattern
\&\f(CW00110011\fR). Da operators work wit tha binary form of a number
(the number \f(CW3\fR is treated as tha bit pattern \f(CW00000011\fR).
.PP
So, sayin \f(CW\*(C`11 & 3\*(C'\fR performs tha \*(L"and\*(R" operation on numbers (yielding
\&\f(CW3\fR). Right back up in yo muthafuckin ass. Sayin \f(CW"11" & "3"\fR performs tha \*(L"and\*(R" operation on strings
(yieldin \f(CW"1"\fR).
.PP
Most problems wit \f(CW\*(C`&\*(C'\fR n' \f(CW\*(C`|\*(C'\fR arise cuz tha programmer thinks
they gotz a number but straight-up itz a strang or vice versa. To avoid this,
stringify tha arguments explicitly (usin \f(CW""\fR or \f(CW\*(C`qq()\*(C'\fR) or convert them
to numbers explicitly (usin \f(CW\*(C`0+$arg\*(C'\fR). Da rest arise cuz
the programmer says:
.PP
.Vb 3
\&    if ("\e020\e020" & "\e101\e101") {
\&        # ...
\&    }
.Ve
.PP
but a strang consistin of two null bytes (the result of \f(CW"\e020\e020"
& "\e101\e101"\fR) aint a gangbangin' false value up in Perl. Yo ass need:
.PP
.Vb 3
\&    if ( ("\e020\e020" & "\e101\e101") !~ /[^\e000]/) {
\&        # ...
\&    }
.Ve
.SS "How tha fuck do I multiply matrices?"
.IX Subsection "How tha fuck do I multiply matrices?"
Use tha Math::Matrix or Math::MatrixReal modulez (available from \s-1CPAN\s0)
or tha \s-1PDL\s0 extension (also available from \s-1CPAN\s0).
.SS "How tha fuck do I big-ass up a operation on a seriez of integers?"
.IX Subsection "How tha fuck do I big-ass up a operation on a seriez of integers?"
To call a gangbangin' function on each element up in a array, n' collect the
results, use:
.PP
.Vb 1
\&    mah @results = map { my_func($_) } @array;
.Ve
.PP
For example:
.PP
.Vb 1
\&    mah @triple = map { 3 * $_ } @single;
.Ve
.PP
To call a gangbangin' function on each element of a array yo, but ignore the
results:
.PP
.Vb 3
\&    foreach mah $iterator (@array) {
\&        some_func($iterator);
\&    }
.Ve
.PP
To call a gangbangin' function on each integer up in a (small) range, you \fBcan\fR use:
.PP
.Vb 1
\&    mah @results = map { some_func($_) } (5 .. 25);
.Ve
.PP
but you should be aware dat up in dis form, tha \f(CW\*(C`..\*(C'\fR operator
creates a list of all integers up in tha range, which can take a shitload of
memory fo' big-ass ranges. But fuck dat shiznit yo, tha word on tha street is dat tha problem do not occur when
usin \f(CW\*(C`..\*(C'\fR within a \f(CW\*(C`for\*(C'\fR loop, cuz up in dat case tha range
operator is optimized ta \fIiterate\fR over tha range, without bustin
the entire list. Right back up in yo muthafuckin ass. So
.PP
.Vb 4
\&    mah @results = ();
\&    fo' mah $i (5 .. 500_005) {
\&        push(@results, some_func($i));
\&    }
.Ve
.PP
or even
.PP
.Vb 1
\&   push(@results, some_func($_)) fo' 5 .. 500_005;
.Ve
.PP
will not create a intermediate list of 500,000 integers.
.SS "How tha fuck can I output Roman numerals?"
.IX Subsection "How tha fuck can I output Roman numerals?"
Git tha <http://www.cpan.org/modules/by\-module/Roman> module.
.SS "Why aren't mah random numbers random?"
.IX Subsection "Why aren't mah random numbers random?"
If you rockin a version of Perl before 5.004, you must call \f(CW\*(C`srand\*(C'\fR
once all up in tha start of yo' program ta seed tha random number generator.
.PP
.Vb 1
\&     BEGIN { srand() if $] < 5.004 }
.Ve
.PP
5.004 n' lata automatically call \f(CW\*(C`srand\*(C'\fR all up in tha beginning. Don't
call \f(CW\*(C`srand\*(C'\fR mo' than once\*(--you make yo' numbers less random,
rather than more.
.PP
Computas is phat at bein predictable n' wack at bein random
(despite appearances caused by bugs up in yo' programs :\-). The
\&\fIrandom\fR article up in tha \*(L"Far Mo' Than Yo ass Ever Wanted To Know\*(R"
collection up in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
of Tomothy Phoenix, talks mo' bout all dis bullshit. Jizzy von Neumann holla'd, \*(L"Every Muthafucka
who attempts ta generate random numbers by deterministic means is, of
course, livin up in a state of sin.\*(R"
.PP
Perl relies on tha underlyin system fo' tha implementation of
\&\f(CW\*(C`rand\*(C'\fR n' \f(CW\*(C`srand\*(C'\fR; on some systems, tha generated numbers are
not random enough (especially on Windows : see
<http://www.perlmonks.org/?node_id=803632>).
Several \s-1CPAN\s0 modulez up in tha \f(CW\*(C`Math\*(C'\fR namespace implement better
pseudorandom generators; peep fo' example
Math::Random::MT (\*(L"Mersenne Twister\*(R", fast), or
Math::TrulyRandom (uses tha imperfections up in tha system's
timer ta generate random numbers, which is rather slow).
Mo' algorithms fo' random numbers is busted lyrics bout in
\&\*(L"Numerical Recipes up in C\*(R" at <http://www.nr.com/>
.SS "How tha fuck do I git a random number between X n' Y?"
.IX Subsection "How tha fuck do I git a random number between X n' Y?"
To git a random number between two joints, you can use tha \f(CW\*(C`rand()\*(C'\fR
built-in ta git a random number between 0 n' 1. From there, you shift
that tha fuck into tha range dat you want.
.PP
\&\f(CW\*(C`rand($x)\*(C'\fR returns a number such dat \f(CW\*(C`0 <= rand($x) < $x\*(C'\fR. Thus
what you wanna have perl figure up be a random number up in tha range
from 0 ta tha difference between yo' \fIX\fR n' \fIY\fR.
.PP
That is, ta git a number between 10 n' 15, inclusive, you want a
random number between 0 n' 5 dat you can then add ta 10.
.PP
.Vb 1
\&    mah $number = 10 + int rand( 15\-10+1 ); # ( 10,11,12,13,14, or 15 )
.Ve
.PP
Hence you derive tha followin simple function ta abstract
dat shit. Well shiiiit, it selects a random integer between tha two given
integers (inclusive), For example: \f(CW\*(C`random_int_between(50,120)\*(C'\fR.
.PP
.Vb 7
\&    sub random_int_between {
\&        my($min, $max) = @_;
\&        # Assumes dat tha two arguments is integers theyselves!
\&        return $min if $min == $max;
\&        ($min, $max) = ($max, $min)  if  $min > $max;
\&        return $min + int rand(1 + $max \- $min);
\&    }
.Ve
.SH "Data: Dates"
.IX Header "Data: Dates"
.SS "How tha fuck do I find tha dizzle or week of tha year?"
.IX Subsection "How tha fuck do I find tha dizzle or week of tha year?"
Da dizzle of tha year is up in tha list returned
by tha \f(CW\*(C`localtime\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Without an
argument \f(CW\*(C`localtime\*(C'\fR uses tha current time.
.PP
.Vb 1
\&    mah $day_of_year = (localtime)[7];
.Ve
.PP
Da \s-1POSIX\s0 module can also format a thugged-out date as tha dizzle of tha year or
week of tha year.
.PP
.Vb 3
\&    use POSIX qw/strftime/;
\&    mah $day_of_year  = strftime "%j", localtime;
\&    mah $week_of_year = strftime "%W", localtime;
.Ve
.PP
To git tha dizzle of year fo' any date, use \s-1POSIX\s0z \f(CW\*(C`mktime\*(C'\fR ta get
a time up in epoch secondz fo' tha argument ta \f(CW\*(C`localtime\*(C'\fR.
.PP
.Vb 3
\&    use POSIX qw/mktime strftime/;
\&    mah $week_of_year = strftime "%W",
\&        localtime( mktime( 0, 0, 0, 18, 11, 87 ) );
.Ve
.PP
Yo ass can also use Time::Piece, which comes wit Perl n' serves up a
\&\f(CW\*(C`localtime\*(C'\fR dat returns a object:
.PP
.Vb 3
\&    use Time::Piece;
\&    mah $day_of_year  = localtime\->yday;
\&    mah $week_of_year = localtime\->week;
.Ve
.PP
Da Date::Calc module serves up two functions ta calculate these, too:
.PP
.Vb 3
\&    use Date::Calc;
\&    mah $day_of_year  = Day_of_Year(  1987, 12, 18 );
\&    mah $week_of_year = Week_of_Year( 1987, 12, 18 );
.Ve
.SS "How tha fuck do I find tha current century or millennium?"
.IX Subsection "How tha fuck do I find tha current century or millennium?"
Use tha followin simple functions:
.PP
.Vb 3
\&    sub get_century    {
\&        return int((((localtime(shift || time))[5] + 1999))/100);
\&    }
\&
\&    sub get_millennium {
\&        return 1+int((((localtime(shift || time))[5] + 1899))/1000);
\&    }
.Ve
.PP
On some systems, tha \s-1POSIX\s0 modulez \f(CW\*(C`strftime()\*(C'\fR function has been
extended up in a non-standard way ta bust a \f(CW%C\fR format, which they
sometimes claim is tha \*(L"century\*(R". Well shiiiit, it aint, cuz on most such
systems, dis is only tha straight-up original gangsta two digitz of tha four-digit year, and
thus cannot be used ta determine reliably tha current century or
millennium.
.SS "How tha fuck can I compare two dates n' find tha difference?"
.IX Subsection "How tha fuck can I compare two dates n' find tha difference?"
(contributed by brian d foy)
.PP
Yo ass could just store all yo' dates as a number n' then subtract.
Life aint always dat simple though.
.PP
Da Time::Piece module, which comes wit Perl, replaces localtime
with a version dat returns a object. Well shiiiit, it also overloadz tha comparison
operators so you can compare dem directly:
.PP
.Vb 3
\&    use Time::Piece;
\&    mah $date1 = localtime( $some_time );
\&    mah $date2 = localtime( $some_other_time );
\&
\&    if( $date1 < $date2 ) {
\&        print "Da date was up in tha past\en";
\&    }
.Ve
.PP
Yo ass can also git differences wit a subtraction, which returns a
Time::Secondz object:
.PP
.Vb 2
\&    mah $diff = $date1 \- $date2;
\&    print "Da difference is ", $date_diff\->days, " days\en";
.Ve
.PP
If you wanna work wit formatted dates, tha Date::Manip,
Date::Calc, or DateTime modulez can help yo thugged-out ass.
.SS "How tha fuck can I take a strang n' turn it tha fuck into epoch seconds?"
.IX Subsection "How tha fuck can I take a strang n' turn it tha fuck into epoch seconds?"
If itz a regular enough strang dat it always has tha same ol' dirty format,
you can split it up n' pass tha parts ta \f(CW\*(C`timelocal\*(C'\fR up in tha standard
Time::Local module. Otherwise, you should look tha fuck into tha Date::Calc,
Date::Parse, n' Date::Manip modulez from \s-1CPAN.\s0
.SS "How tha fuck can I find tha Julian Day?"
.IX Subsection "How tha fuck can I find tha Julian Day?"
(contributed by brian d foy n' Dizzle Cross)
.PP
Yo ass can use tha Time::Piece module, part of tha Standard Library,
which can convert a thugged-out date/time ta a Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->julian_day\*(Aq
\&    2455607.7959375
.Ve
.PP
Or tha modified Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->mjd\*(Aq
\&    55607.2961226851
.Ve
.PP
Or even tha dizzle of tha year (which is what tha fuck some playas be thinkin of as a
Julian day):
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->yday\*(Aq
\&    45
.Ve
.PP
Yo ass can also do tha same thangs wit tha DateTime module:
.PP
.Vb 6
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->todizzle\->jd\*(Aq
\&    2453401.5
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->todizzle\->mjd\*(Aq
\&    53401
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->todizzle\->doy\*(Aq
\&    31
.Ve
.PP
Yo ass can use tha Time::JulianDizzle module available on \s-1CPAN.\s0 Ensure
that you straight-up wanna find a Julian day, though, as nuff playas have
different scams bout Julian minutes (see <http://www.hermetic.ch/cal_stud/jdn.htm>
for instance):
.PP
.Vb 2
\&    $  perl \-MTime::JulianDizzle \-le \*(Aqprint local_julian_day( time )\*(Aq
\&    55608
.Ve
.SS "How tha fuck do I find yesterdayz date?"
.IX Xref "date yesterdizzle DateTime Date::Calc Time::Local daylight savin time dizzle Today_and_Now localtime timelocal"
.IX Subsection "How tha fuck do I find yesterdayz date?"
(contributed by brian d foy)
.PP
To do it erectly, you can use one of tha \f(CW\*(C`Date\*(C'\fR modulez since they
work wit calendars instead of times. Da DateTime module make it
simple, n' hit you wit tha same time of day, only tha dizzle before,
despite daylight savin time chizzles:
.PP
.Vb 1
\&    use DateTime;
\&
\&    mah $yesterdizzle = DateTime\->now\->subtract( minutes => 1 );
\&
\&    print "Yesterdizzle was $yesterday\en";
.Ve
.PP
Yo ass can also use tha Date::Calc module rockin its \f(CW\*(C`Today_and_Now\*(C'\fR
function.
.PP
.Vb 1
\&    use Date::Calc qw( Today_and_Now Add_Delta_DHMS );
\&
\&    mah @date_time = Add_Delta_DHMS( Today_and_Now(), \-1, 0, 0, 0 );
\&
\&    print "@date_time\en";
.Ve
.PP
Most playas try ta use tha time rather than tha calendar ta figure out
dates yo, but dat assumes dat minutes is twenty-four minutes each. For
most people, there be two minutes a year when they aren't: tha switch to
and from summer time throws dis off. For example, tha rest of the
suggestions is ghon be wack sometimes:
.PP
Startin wit Perl 5.10, Time::Piece n' Time::Secondz is part
of tha standard distribution, so you might be thinkin dat you could do
suttin' like this:
.PP
.Vb 2
\&    use Time::Piece;
\&    use Time::Seconds;
\&
\&    mah $yesterdizzle = localtime() \- ONE_DAY; # WRONG
\&    print "Yesterdizzle was $yesterday\en";
.Ve
.PP
Da Time::Piece module exports a freshly smoked up \f(CW\*(C`localtime\*(C'\fR dat returns an
object, n' Time::Secondz exports tha \f(CW\*(C`ONE_DAY\*(C'\fR constant dat be a
set number of seconds. This means dat it always gives tha time 24
hours ago, which aint always yesterday. It make me wanna hollar playa! This can cause problems
around tha end of daylight savin time when there be a one dizzle dat is 25
hours long.
.PP
Yo ass have tha same problem wit Time::Local, which will give tha wrong
answer fo' dem same special cases:
.PP
.Vb 5
\&    # contributed by Gunnar Hjalmarsson
\&     use Time::Local;
\&     mah $todizzle = timelocal 0, 0, 12, ( localtime )[3..5];
\&     mah ($d, $m, $y) = ( localtime $todizzle\-86400 )[3..5]; # WRONG
\&     printf "Yesterday: %d\-%02d\-%02d\en", $y+1900, $m+1, $d;
.Ve
.SS "Do Perl gotz a Year 2000 or 2038 problem, biatch? Is Perl Y2K compliant?"
.IX Subsection "Do Perl gotz a Year 2000 or 2038 problem, biatch? Is Perl Y2K compliant?"
(contributed by brian d foy)
.PP
Perl itself never had a Y2K problem, although dat never stopped people
from bustin Y2K problems on they own. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See tha documentation for
\&\f(CW\*(C`localtime\*(C'\fR fo' its proper use.
.PP
Startin wit Perl 5.12, \f(CW\*(C`localtime\*(C'\fR n' \f(CW\*(C`gmtime\*(C'\fR can handle dates past
03:14:08 January 19, 2038, when a 32\-bit based time would overflow. You
still might git a warnin on a 32\-bit \f(CW\*(C`perl\*(C'\fR:
.PP
.Vb 3
\&    % perl5.12 \-E \*(Aqsay scalar localtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Integer overflow up in hexadecimal number at \-e line 1.
\&    Wed Nov  1 19:42:39 5576711
.Ve
.PP
On a 64\-bit \f(CW\*(C`perl\*(C'\fR, you can git even larger dates fo' dem straight-up long
runnin projects:
.PP
.Vb 2
\&    % perl5.12 \-E \*(Aqsay scalar gmtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Thu Nov  2 00:42:39 5576711
.Ve
.PP
Yo ass is still outta luck if you need ta keep track of decayin protons
though.
.SH "Data: Strings"
.IX Header "Data: Strings"
.SS "How tha fuck do I validate input?"
.IX Subsection "How tha fuck do I validate input?"
(contributed by brian d foy)
.PP
There is nuff ways ta ensure dat joints is what tha fuck you expect or
wanna accept. Besides tha specific examplez dat we cover up in the
perlfaq, you can also peep tha modulez wit \*(L"Assert\*(R" n' \*(L"Validate\*(R"
in they names, along wit other modulez like fuckin Regexp::Common.
.PP
Some modulez have validation fo' particular typez of input, such
as Business::ISBN, Business::CreditCard, Email::Valid,
and Data::Validate::IP.
.SS "How tha fuck do I unescape a string?"
.IX Subsection "How tha fuck do I unescape a string?"
It dependz just what tha fuck you mean by \*(L"escape\*(R". \s-1URL\s0 escapes is dealt
with up in perlfaq9. Right back up in yo muthafuckin ass. Shell escapes wit tha backslash (\f(CW\*(C`\e\*(C'\fR)
characta is removed with
.PP
.Vb 1
\&    s/\e\e(.)/$1/g;
.Ve
.PP
This won't expand \f(CW"\en"\fR or \f(CW"\et"\fR or any other special escapes.
.SS "How tha fuck do I remove consecutizzle pairz of characters?"
.IX Subsection "How tha fuck do I remove consecutizzle pairz of characters?"
(contributed by brian d foy)
.PP
Yo ass can use tha substitution operator ta find pairz of charactas (or
runz of characters) n' replace dem wit a single instance. In this
substitution, we find a cold-ass lil characta up in \f(CW\*(C`(.)\*(C'\fR. Da memory parentheses
store tha matched characta up in tha back-reference \f(CW\*(C`\eg1\*(C'\fR n' we use
that ta require dat tha same thang immediately follow dat shit. We replace
that part of tha strang wit tha characta up in \f(CW$1\fR.
.PP
.Vb 1
\&    s/(.)\eg1/$1/g;
.Ve
.PP
We can also use tha transliteration operator, \f(CW\*(C`tr///\*(C'\fR. In this
example, tha search list side of our \f(CW\*(C`tr///\*(C'\fR gotz nuff not a god damn thang yo, but
the \f(CW\*(C`c\*(C'\fR option complements dat so it gotz nuff every last muthafuckin thang. The
replacement list also gotz nuff nothing, so tha transliteration is
almost a no-op since it won't do any replacements (or mo' exactly,
replace tha characta wit itself). But fuck dat shiznit yo, tha word on tha street is dat tha \f(CW\*(C`s\*(C'\fR option squashes
duplicated n' consecutizzle charactas up in tha strang so a cold-ass lil character
does not show up next ta itself
.PP
.Vb 2
\&    mah $str = \*(AqHaarlem\*(Aq;   # up in tha Netherlands
\&    $str =~ tr///cs;       # Now Harlem, like up in New York
.Ve
.SS "How tha fuck do I expand function calls up in a string?"
.IX Subsection "How tha fuck do I expand function calls up in a string?"
(contributed by brian d foy)
.PP
This is documented up in perlref, n' although it aint tha easiest
thang ta read, it do work. In each of these examples, we call the
function inside tha braces used ta dereference a reference. If we
have mo' than one return value, we can construct n' dereference an
anonymous array. In dis case, we call tha function up in list context.
.PP
.Vb 1
\&    print "Da time joints is @{ [localtime] }.\en";
.Ve
.PP
If we wanna call tha function up in scalar context, we gotta do a funky-ass bit
more work. We can straight-up have any code our slick asses like inside tha braces, so
we simply gotta end wit tha scalar reference, although how tha fuck you do
that is up ta you, n' you can use code inside tha braces. Note that
the use of parens creates a list context, so we need \f(CW\*(C`scalar\*(C'\fR to
force tha scalar context on tha function:
.PP
.Vb 1
\&    print "Da time is ${\e(scalar localtime)}.\en"
\&
\&    print "Da time is ${ mah $x = localtime; \e$x }.\en";
.Ve
.PP
If yo' function already returns a reference, you don't need ta create
the reference yo ass.
.PP
.Vb 1
\&    sub timestamp { mah $t = localtime; \e$t }
\&
\&    print "Da time is ${ timestamp() }.\en";
.Ve
.PP
Da \f(CW\*(C`Interpolation\*(C'\fR module can also do a shitload of magic fo' yo thugged-out ass. Yo ass can
specify a variable name, up in dis case \f(CW\*(C`E\*(C'\fR, ta set up a tied hash that
does tha interpolation fo' yo thugged-out ass. Well shiiiit, it has nuff muthafuckin other methodz ta do this
as well.
.PP
.Vb 2
\&    use Interpolation E => \*(Aqeval\*(Aq;
\&    print "Da time joints is $E{localtime()}.\en";
.Ve
.PP
In most cases, it is probably easier ta simply use strang concatenation,
which also forces scalar context.
.PP
.Vb 1
\&    print "Da time is " . localtime() . ".\en";
.Ve
.SS "How tha fuck do I find matching/nestin anything?"
.IX Subsection "How tha fuck do I find matching/nestin anything?"
To find suttin' between two single
characters, a pattern like \f(CW\*(C`/x([^x]*)x/\*(C'\fR will git tha intervening
bits up in \f(CW$1\fR. For multiple ones, then suttin' mo' like
\&\f(CW\*(C`/alpha(.*?)omega/\*(C'\fR would be needed. Y'all KNOW dat shit, muthafucka! For nested patterns
and/or balanced expressions, peep tha so-called
(?PARNO)
construct (available since perl 5.10).
Da \s-1CPAN\s0 module Regexp::Common can help ta build such
regular expressions (see up in particular
Regexp::Common::balanced n' Regexp::Common::delimited).
.PP
Mo' complex cases will require ta write a parser, probably
usin a parsin module from \s-1CPAN,\s0 like
Regexp::Grammars, Parse::RecDescent, Parse::Yapp,
Text::Balanced, or Marpa::XS.
.SS "How tha fuck do I reverse a string?"
.IX Subsection "How tha fuck do I reverse a string?"
Use \f(CW\*(C`reverse()\*(C'\fR up in scalar context, as documented in
\&\*(L"reverse\*(R" up in perlfunc.
.PP
.Vb 1
\&    mah $reversed = reverse $string;
.Ve
.SS "How tha fuck do I expand tabs up in a string?"
.IX Subsection "How tha fuck do I expand tabs up in a string?"
Yo ass can do it yo ass:
.PP
.Vb 1
\&    1 while $strin =~ s/\et+/\*(Aq \*(Aq x (length($&) * 8 \- length($\`) % 8)/e;
.Ve
.PP
Or you can just use tha Text::Tabs module (part of tha standard Perl
distribution).
.PP
.Vb 2
\&    use Text::Tabs;
\&    mah @expanded_lines = expand(@lines_with_tabs);
.Ve
.SS "How tha fuck do I reformat a paragraph?"
.IX Subsection "How tha fuck do I reformat a paragraph?"
Use Text::Wrap (part of tha standard Perl distribution):
.PP
.Vb 2
\&    use Text::Wrap;
\&    print wrap("\et", \*(Aq  \*(Aq, @paragraphs);
.Ve
.PP
Da paragraphs you give ta Text::Wrap should not contain embedded
newlines. Text::Wrap don't justify tha lines (flush-right).
.PP
Or use tha \s-1CPAN\s0 module Text::Autoformat. Formattin filez can be
easily done by bustin a gangbangin' finger-lickin' dirty-ass shell alias, like so:
.PP
.Vb 2
\&    alias fmt="perl \-i \-MText::Autoformat \-n0777 \e
\&        \-e \*(Aqprint autoformat $_, {all=>1}\*(Aq $*"
.Ve
.PP
See tha documentation fo' Text::Autoformat ta appreciate its many
capabilities.
.SS "How tha fuck can I access or chizzle N charactaz of a string?"
.IX Subsection "How tha fuck can I access or chizzle N charactaz of a string?"
Yo ass can access tha straight-up original gangsta charactaz of a strang wit \fIsubstr()\fR.
To git tha straight-up original gangsta character, fo' example, start at posizzle 0
and grab tha strang of length 1.
.PP
.Vb 2
\&    mah $strin = "Just another Perl Hacker";
\&    mah $first_char = substr( $string, 0, 1 );  #  \*(AqJ\*(Aq
.Ve
.PP
To chizzle part of a string, you can use tha optionizzle fourth
argument which is tha replacement string.
.PP
.Vb 1
\&    substr( $string, 13, 4, "Perl 5.8.0" );
.Ve
.PP
Yo ass can also use \fIsubstr()\fR as a lvalue.
.PP
.Vb 1
\&    substr( $string, 13, 4 ) =  "Perl 5.8.0";
.Ve
.SS "How tha fuck do I chizzle tha Nth occurrence of something?"
.IX Subsection "How tha fuck do I chizzle tha Nth occurrence of something?"
Yo ass gotta keep track of N yo ass. For example, letz say you want
to chizzle tha fifth occurrence of \f(CW"whoever"\fR or \f(CW"whomever"\fR into
\&\f(CW"whosoever"\fR or \f(CW"whomsoever"\fR, case insensitively. These
all assume dat \f(CW$_\fR gotz nuff tha strang ta be altered.
.PP
.Vb 6
\&    $count = 0;
\&    s{((whom?)ever)}{
\&    ++$count == 5       # is it tha 5th?
\&        , biatch? "${2}soever"  # fo'sho, swap
\&        : $1            # renege n' leave it there
\&        }ige;
.Ve
.PP
In tha mo' general case, you can use tha \f(CW\*(C`/g\*(C'\fR modifier up in a \f(CW\*(C`while\*(C'\fR
loop, keepin count of matches.
.PP
.Vb 8
\&    $WANT = 3;
\&    $count = 0;
\&    $_ = "One fish two fish red fish blue fish";
\&    while (/(\ew+)\es+fish\eb/gi) {
\&        if (++$count == $WANT) {
\&            print "Da third fish be a $1 one.\en";
\&        }
\&    }
.Ve
.PP
That prints out: \f(CW"Da third fish be a red one."\fR  Yo ass can also use a
repetizzle count n' repeated pattern like this:
.PP
.Vb 1
\&    /(?:\ew+\es+fish\es+){2}(\ew+)\es+fish/i;
.Ve
.SS "How tha fuck can I count tha number of occurrencez of a substrin within a string?"
.IX Subsection "How tha fuck can I count tha number of occurrencez of a substrin within a string?"
There is a fuckin shitload of ways, wit varyin efficiency. If you want a
count of a cold-ass lil certain single characta (X) within a string, you can use the
\&\f(CW\*(C`tr///\*(C'\fR function like so:
.PP
.Vb 3
\&    mah $strin = "ThisXlineXhasXsomeXx\*(AqsXinXit";
\&    mah $count = ($strin =~ tr/X//);
\&    print "There is $count X charactas up in tha string";
.Ve
.PP
This is fine if yo ass is just lookin fo' a single character n' shiznit yo. However,
if yo ass is tryin ta count multiple characta substrings within a
larger string, \f(CW\*(C`tr///\*(C'\fR won't work. What you can do is wrap a \fIwhile()\fR
loop round a global pattern match. For example, letz count negative
integers:
.PP
.Vb 4
\&    mah $strin = "\-9 55 48 \-2 23 \-76 4 14 \-44";
\&    mah $count = 0;
\&    while ($strin =~ /\-\ed+/g) { $count++ }
\&    print "There is $count wack numbers up in tha string";
.Ve
.PP
Another version uses a global match up in list context, then assigns the
result ta a scalar, producin a cold-ass lil count of tha number of matches.
.PP
.Vb 1
\&    mah $count = () = $strin =~ /\-\ed+/g;
.Ve
.SS "How tha fuck do I capitalize all tha lyrics on one line?"
.IX Xref "Text::Autoformat capitalize case, title case, sentence"
.IX Subsection "How tha fuck do I capitalize all tha lyrics on one line?"
(contributed by brian d foy)
.PP
Damian Conwayz Text::Autoformat handlez all of tha thinking
for yo thugged-out ass.
.PP
.Vb 3
\&    use Text::Autoformat;
\&    mah $x = "Dr. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Strangeludd or: How tha fuck I Learned ta Quit ".
\&      "Worryin n' Ludd tha Bomb";
\&
\&    print $x, "\en";
\&    fo' mah $style (qw( sentence title highlight )) {
\&        print autoformat($x, { case => $style }), "\en";
\&    }
.Ve
.PP
How tha fuck do you wanna capitalize dem lyrics?
.PP
.Vb 3
\&    FRED AND BARNEY\*(AqS LODGE        # all uppercase
\&    Fred And Barney\*(Aqs Lodge        # title case
\&    Fred n' Barney\*(Aqs Lodge        # highlight case
.Ve
.PP
It aint nuthin but not as easy as fuck  a problem as it looks yo. How tha fuck nuff lyrics do you think
are up in there, biatch? Wait fo' dat shit... wait fo' dat shit.... If you answered 5
yo ass is right. Perl lyrics is crewz of \f(CW\*(C`\ew+\*(C'\fR yo, but thatz not what
you wanna capitalize yo. How tha fuck is Perl supposed ta know not ta capitalize
that \f(CW\*(C`s\*(C'\fR afta tha apostrophe, biatch? Yo ass could try a regular expression:
.PP
.Vb 6
\&    $strin =~ s/ (
\&                 (^\ew)    #at tha beginnin of tha line
\&                   |      # or
\&                 (\es\ew)   #preceded by whitespace
\&                   )
\&                /\eU$1/xg;
\&
\&    $strin =~ s/([\ew\*(Aq]+)/\eu\eL$1/g;
.Ve
.PP
Now, what tha fuck if you don't wanna capitalize dat \*(L"and\*(R", biatch? Just use
Text::Autoformat n' git on wit tha next problem. :)
.SS "How tha fuck can I split a [character]\-delimited strang except when inside [character]?"
.IX Subsection "How tha fuck can I split a [character]-delimited strang except when inside [character]?"
Several modulez can handle dis sort of parsing\*(--Text::Balanced,
Text::CSV, Text::CSV_XS, n' Text::ParseWords, among others.
.PP
Take tha example case of tryin ta split a strang dat is
comma-separated tha fuck into its different fields. Yo ass can't use \f(CW\*(C`split(/,/)\*(C'\fR
because you shouldn't split if tha comma is inside quotes. For
example, take a thugged-out data line like this:
.PP
.Vb 1
\&    SAR001,"","Cimetrix, Inc","Bob Smizzle","CAM",N,8,1,0,7,"Error, Core Dumped"
.Ve
.PP
Cuz of tha restriction of tha quotes, dis be a gangbangin' fairly complex
problem. Thankfully, our crazy asses have Jeffrey Friedl, lyricist of
\&\fIMasterin Regular Expressions\fR, ta handle these fo' our asses yo. He
suggests (assumin yo' strang is contained up in \f(CW$text\fR):
.PP
.Vb 7
\&     mah @new = ();
\&     push(@new, $+) while $text =~ m{
\&         "([^\e"\e\e]*(?:\e\e.[^\e"\e\e]*)*)",, biatch? # crews tha phrase inside tha quotes
\&        | ([^,]+),?
\&        | ,
\&     }gx;
\&     push(@new, undef) if substr($text,\-1,1) eq \*(Aq,\*(Aq;
.Ve
.PP
If you wanna represent quotation marks inside a
quotation-mark-delimited field, escape dem wit backslashes (eg,
\&\f(CW"like \e"this\e""\fR.
.PP
Alternatively, tha Text::ParseLyrics module (part of tha standard
Perl distribution) lets you say:
.PP
.Vb 2
\&    use Text::ParseWords;
\&    @new = quotewords(",", 0, $text);
.Ve
.PP
For parsin or generatin \s-1CSV,\s0 though, rockin Text::CSV rather than
implementin it yo ass is highly recommended; you gonna save yo ass odd bugs
poppin up lata by just rockin code which has already been tried n' tested in
thang fo' years.
.SS "How tha fuck do I strip blank space from tha beginning/end of a string?"
.IX Subsection "How tha fuck do I strip blank space from tha beginning/end of a string?"
(contributed by brian d foy)
.PP
A substitution can do dis fo' yo thugged-out ass. For a single line, you want to
replace all tha leadin or trailin whitespace wit nothing. You
can do dat wit a pair of substitutions:
.PP
.Vb 2
\&    s/^\es+//;
\&    s/\es+$//;
.Ve
.PP
Yo ass can also write dat as a single substitution, although it turns
out tha combined statement is slower than tha separate ones. That
might not matta ta you, though:
.PP
.Vb 1
\&    s/^\es+|\es+$//g;
.Ve
.PP
In dis regular expression, tha alternation matches either at the
beginnin or tha end of tha strang since tha anchors gotz a lower
precedence than tha alternation. I aint talkin' bout chicken n' gravy biatch. With tha \f(CW\*(C`/g\*(C'\fR flag, tha substitution
makes all possible matches, so it gets both. Remember, tha trailing
newline matches tha \f(CW\*(C`\es+\*(C'\fR, n'  tha \f(CW\*(C`$\*(C'\fR anchor can match ta the
absolute end of tha string, so tha newline disappears like a muthafucka. Just add
the newline ta tha output, which has tha added benefit of preserving
\&\*(L"blank\*(R" (consistin entirely of whitespace) lines which tha \f(CW\*(C`^\es+\*(C'\fR
would remove all by itself:
.PP
.Vb 4
\&    while( <> ) {
\&        s/^\es+|\es+$//g;
\&        print "$_\en";
\&    }
.Ve
.PP
For a multi-line string, you can apply tha regular expression ta each
logical line up in tha strang by addin tha \f(CW\*(C`/m\*(C'\fR flag (for
\&\*(L"multi-line\*(R"). With tha \f(CW\*(C`/m\*(C'\fR flag, tha \f(CW\*(C`$\*(C'\fR matches \fIbefore\fR an
embedded newline, so it don't remove dat shit. This pattern still removes
the newline all up in tha end of tha string:
.PP
.Vb 1
\&    $strin =~ s/^\es+|\es+$//gm;
.Ve
.PP
Remember dat lines consistin entirely of whitespace will disappear,
since tha straight-up original gangsta part of tha alternation can match tha entire string
and replace it wit nothing. If you need ta keep embedded blank lines,
you gotta do a lil mo' work. Instead of matchin any whitespace
(since dat includes a newline), just match tha other whitespace:
.PP
.Vb 1
\&    $strin =~ s/^[\et\ef ]+|[\et\ef ]+$//mg;
.Ve
.SS "How tha fuck do I pad a strang wit blanks or pad a number wit zeroes?"
.IX Subsection "How tha fuck do I pad a strang wit blanks or pad a number wit zeroes?"
In tha followin examples, \f(CW$pad_len\fR is tha length ta which you wish
to pad tha string, \f(CW$text\fR or \f(CW$num\fR gotz nuff tha strang ta be padded,
and \f(CW$pad_char\fR gotz nuff tha paddin character n' shit. Yo ass can bust a single
characta strang constant instead of tha \f(CW$pad_char\fR variable if you
know what tha fuck it is up in advizzle fo' realz. And up in tha same way you can use a integer in
place of \f(CW$pad_len\fR if you know tha pad length up in advance.
.PP
Da simplest method uses tha \f(CW\*(C`sprintf\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it can pad on tha left
or right wit blanks n' on tha left wit zeroes n' it will not
truncate tha result. Da \f(CW\*(C`pack\*(C'\fR function can only pad strings on the
right wit blanks n' it will truncate tha result ta a maximum length of
\&\f(CW$pad_len\fR.
.PP
.Vb 3
\&    # Left paddin a strang wit blanks (no truncation):
\&    mah $padded = sprintf("%${pad_len}s", $text);
\&    mah $padded = sprintf("%*s", $pad_len, $text);  # same thang
\&
\&    # Right paddin a strang wit blanks (no truncation):
\&    mah $padded = sprintf("%\-${pad_len}s", $text);
\&    mah $padded = sprintf("%\-*s", $pad_len, $text); # same thang
\&
\&    # Left paddin a number wit 0 (no truncation):
\&    mah $padded = sprintf("%0${pad_len}d", $num);
\&    mah $padded = sprintf("%0*d", $pad_len, $num); # same thang
\&
\&    # Right paddin a strang wit blanks rockin pack (will truncate):
\&    mah $padded = pack("A$pad_len",$text);
.Ve
.PP
If you need ta pad wit a cold-ass lil characta other than blank or zero you can use
one of tha followin methods. They all generate a pad strang wit the
\&\f(CW\*(C`x\*(C'\fR operator n' combine dat wit \f(CW$text\fR. These methodz do
not truncate \f(CW$text\fR.
.PP
Left n' right paddin wit any character, bustin a freshly smoked up string:
.PP
.Vb 2
\&    mah $padded = $pad_char x ( $pad_len \- length( $text ) ) . $text;
\&    mah $padded = $text . $pad_char x ( $pad_len \- length( $text ) );
.Ve
.PP
Left n' right paddin wit any character, modifyin \f(CW$text\fR directly:
.PP
.Vb 2
\&    substr( $text, 0, 0 ) = $pad_char x ( $pad_len \- length( $text ) );
\&    $text .= $pad_char x ( $pad_len \- length( $text ) );
.Ve
.SS "How tha fuck do I extract selected columns from a string?"
.IX Subsection "How tha fuck do I extract selected columns from a string?"
(contributed by brian d foy)
.PP
If you know tha columns dat contain tha data, you can
use \f(CW\*(C`substr\*(C'\fR ta extract a single column.
.PP
.Vb 1
\&    mah $column = substr( $line, $start_column, $length );
.Ve
.PP
Yo ass can use \f(CW\*(C`split\*(C'\fR if tha columns is separated by whitespace or
some other delimiter, as long as whitespace or tha delimita cannot
appear as part of tha data.
.PP
.Vb 3
\&    mah $line    = \*(Aq fred barney   betty   \*(Aq;
\&    mah @columns = split /\es+/, $line;
\&        # ( \*(Aq\*(Aq, \*(Aqfred\*(Aq, \*(Aqbarney\*(Aq, \*(Aqbetty\*(Aq );
\&
\&    mah $line    = \*(Aqfred||barney||betty\*(Aq;
\&    mah @columns = split /\e|/, $line;
\&        # ( \*(Aqfred\*(Aq, \*(Aq\*(Aq, \*(Aqbarney\*(Aq, \*(Aq\*(Aq, \*(Aqbetty\*(Aq );
.Ve
.PP
If you wanna work wit comma-separated joints, don't do dis since
that format be a lil' bit mo' fucked up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use one of tha modulez that
handle dat format, like fuckin Text::CSV, Text::CSV_XS, or
Text::CSV_PP.
.PP
If you wanna break apart a entire line of fixed columns, you can use
\&\f(CW\*(C`unpack\*(C'\fR wit tha A (\s-1ASCII\s0) format. By rockin a number afta tha format
specifier, you can denote tha column width. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR
entries up in perlfunc fo' mo' details.
.PP
.Vb 1
\&    mah @fieldz = unpack( $line, "A8 A8 A8 A16 A4" );
.Ve
.PP
Note dat spaces up in tha format argument ta \f(CW\*(C`unpack\*(C'\fR do not denote literal
spaces. If you have space separated data, you may want \f(CW\*(C`split\*(C'\fR instead.
.SS "How tha fuck do I find tha soundex value of a string?"
.IX Subsection "How tha fuck do I find tha soundex value of a string?"
(contributed by brian d foy)
.PP
Yo ass can use tha \f(CW\*(C`Text::Soundex\*(C'\fR module. If you wanna do fuzzy or close
matching, you might also try tha String::Approx, and
Text::Metaphone, n' Text::DoubleMetaphone modules.
.SS "How tha fuck can I expand variablez up in text strings?"
.IX Subsection "How tha fuck can I expand variablez up in text strings?"
(contributed by brian d foy)
.PP
If you can avoid it, don't, or if you can bust a templatin system,
like fuckin Text::Template or Template Toolkit, do dat instead. Y'all KNOW dat shit, muthafucka! You
might even be able ta git tha thang done wit \f(CW\*(C`sprintf\*(C'\fR or \f(CW\*(C`printf\*(C'\fR:
.PP
.Vb 1
\&    mah $strin = sprintf \*(AqSay wassup ta %s n' %s\*(Aq, $foo, $bar;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat fo' tha one-off simple case where I don't wanna pull up a
full templatin system, I be bout ta bust a strang dat has two Perl scalar
variablez up in dat shit. In dis example, I wanna expand \f(CW$foo\fR n' \f(CW$bar\fR
to they variablez joints:
.PP
.Vb 3
\&    mah $foo = \*(AqFred\*(Aq;
\&    mah $bar = \*(AqBarney\*(Aq;
\&    $strin = \*(AqSay wassup ta $foo n' $bar\*(Aq;
.Ve
.PP
One way I can do dis involves tha substitution operator n' a thugged-out double
\&\f(CW\*(C`/e\*(C'\fR flag. Da first \f(CW\*(C`/e\*(C'\fR evaluates \f(CW$1\fR on tha replacement side and
turns it tha fuck into \f(CW$foo\fR. Da second /e starts wit \f(CW$foo\fR n' replaces
it wit its value. \f(CW$foo\fR, then, turns tha fuck into 'Fred', n' thatz finally
whatz left up in tha string:
.PP
.Vb 1
\&    $strin =~ s/(\e$\ew+)/$1/eeg; # \*(AqSay wassup ta Fred n' Barney\*(Aq
.Ve
.PP
Da \f(CW\*(C`/e\*(C'\fR will also silently ignore violationz of strict, replacing
undefined variable names wit tha empty string. Right back up in yo muthafuckin ass. Since I be rockin the
\&\f(CW\*(C`/e\*(C'\fR flag (twice even!), I have all of tha same securitizzle problems I
have wit \f(CW\*(C`eval\*(C'\fR up in its strang form. If there be a suttin' odd in
\&\f(CW$foo\fR, like suttin' like \f(CW\*(C`@{[ system "rm \-rf /" ]}\*(C'\fR, then
I could git mah dirty ass up in shit.
.PP
To git round tha securitizzle problem, I could also pull tha joints from
a hash instead of evaluatin variable names. Usin a single \f(CW\*(C`/e\*(C'\fR, I
can check tha hash ta ensure tha value exists, n' if it don't, I
can replace tha missin value wit a marker, up in dis case \f(CW\*(C`???\*(C'\fR to
signal dat I missed something:
.PP
.Vb 1
\&    mah $strin = \*(AqThis has $foo n' $bar\*(Aq;
\&
\&    mah %Replacements = (
\&        foo  => \*(AqFred\*(Aq,
\&        );
\&
\&    # $strin =~ s/\e$(\ew+)/$Replacements{$1}/g;
\&    $strin =~ s/\e$(\ew+)/
\&        exists $Replacements{$1} , biatch? $Replacements{$1} : \*(Aq???\*(Aq
\&        /eg;
\&
\&    print $string;
.Ve
.ie n .SS "Whatz wack wit always quotin ""$vars""?"
.el .SS "Whatz wack wit always quotin ``$vars''?"
.IX Subsection "Whatz wack wit always quotin $vars?"
Da problem is dat dem double-quotes force
stringification\*(--coercin numbers n' references tha fuck into strings\*(--even
when you don't want dem ta be strings. Think of it dis way:
double-quote expansion is used ta produce freshly smoked up strings. If you already
have a string, why do you need more?
.PP
If you git used ta freestylin odd thangs like these:
.PP
.Vb 3
\&    print "$var";       # BAD
\&    mah $new = "$old";       # BAD
\&    somefunc("$var");    # BAD
.Ve
.PP
You'll be up in shit. Those should (in 99.8% of tha cases) be
the simpla n' mo' direct:
.PP
.Vb 3
\&    print $var;
\&    mah $new = $old;
\&    somefunc($var);
.Ve
.PP
Otherwise, besides slowin you down, you goin ta break code when
the thang up in tha scalar is straight-up neither a strang nor a number yo, but
a reference:
.PP
.Vb 5
\&    func(\e@array);
\&    sub func {
\&        mah $aref = shift;
\&        mah $oref = "$aref";  # WRONG
\&    }
.Ve
.PP
Yo ass can also git tha fuck into subtle problems on dem few operations up in Perl
that straight-up do care bout tha difference between a strang n' a
number, like fuckin tha magical \f(CW\*(C`++\*(C'\fR autoincrement operator or the
\&\fIsyscall()\fR function.
.PP
Stringification also destroys arrays.
.PP
.Vb 3
\&    mah @lines = \`command\`;
\&    print "@lines";     # WRONG \- extra blanks
\&    print @lines;       # right
.Ve
.SS "Why don't mah <<\s-1HERE\s0 documents work?"
.IX Subsection "Why don't mah <<HERE documents work?"
Here documents is found up in perlop. Peep fo' these three thangs:
.IP "There must be no space afta tha << part." 4
.IX Item "There must be no space afta tha << part."
.PD 0
.IP "There (probably) should be a semicolon all up in tha end of tha openin token" 4
.IX Item "There (probably) should be a semicolon all up in tha end of tha openin token"
.IP "Yo ass can't (easily) have any space up in front of tha tag." 4
.IX Item "Yo ass can't (easily) have any space up in front of tha tag."
.IP "There need ta be at least a line separator afta tha end token." 4
.IX Item "There need ta be at least a line separator afta tha end token."
.PD
.PP
If you wanna indent tha text up in tha here document, you
can do this:
.PP
.Vb 5
\&    # all up in one
\&    (my $VAR = <<HERE_TARGET) =~ s/^\es+//gm;
\&        yo' text
\&        goes here
\&    HERE_TARGET
.Ve
.PP
But tha \s-1HERE_TARGET\s0 must still be flush against tha margin.
If you want dat indented also, you gonna gotta quote
in tha indentation.
.PP
.Vb 7
\&    (my $quote = <<\*(Aq    FINIS\*(Aq) =~ s/^\es+//gm;
\&            ...we gonna git peace, when you n' all yo' works have
\&            perished\-\-and tha workz of yo' dark masta ta whom you
\&            would serve up us. Yo ass be a liar, Saruman, n' a cold-ass lil corrupter
\&            of men\*(Aqs hearts, n' you can put dat on yo' toast. \-\-Theoden up in /usr/src/perl/taint.c
\&        FINIS
\&    $quote =~ s/\es+\-\-/\en\-\-/;
.Ve
.PP
A sick general-purpose fixer-upper function fo' indented here documents
bigs up. Well shiiiit, it expects ta be called wit a here document as its argument.
It looks ta peep whether each line begins wit a cold-ass lil common substring, and
if so, strips dat substrin off. Otherwise, it takes tha amount of leading
whitespace found on tha straight-up original gangsta line n' removes dat much off each
subsequent line.
.PP
.Vb 11
\&    sub fix {
\&        local $_ = shift;
\&        mah ($white, $leader);  # common whitespace n' common leadin string
\&        if (/^\es*(?:([^\ew\es]+)(\es*).*\en)(?:\es*\eg1\eg2?.*\en)+$/) {
\&            ($white, $leader) = ($2, quotemeta($1));
\&        } else {
\&            ($white, $leader) = (/^(\es+)/, \*(Aq\*(Aq);
\&        }
\&        s/^\es*?$leader(?:$white)?//gm;
\&        return $_;
\&    }
.Ve
.PP
This works wit leadin special strings, dynamically determined:
.PP
.Vb 10
\&    mah $remember_the_main = fix<<\*(Aq    MAIN_INTERPRETER_LOOP\*(Aq;
\&    @@@ int
\&    @@@ runops() {
\&    @@@     SAVEI32(runlevel);
\&    @@@     runlevel++;
\&    @@@     while ( op = (*op\->op_ppaddr)() );
\&    @@@     TAINT_NOT;
\&    @@@     return 0;
\&    @@@ }
\&    MAIN_INTERPRETER_LOOP
.Ve
.PP
Or wit a gangbangin' fixed amount of leadin whitespace, wit remaining
indentation erectly preserved:
.PP
.Vb 9
\&    mah $poem = fix<<EVER_ON_AND_ON;
\&       Now far ahead tha Road has gone,
\&      And I must follow, if I can,
\&       Pursuin it wit eager feet,
\&      Until it joins some larger way
\&       Where nuff paths n' errandz meet.
\&      And whither then, biatch? I cannot say.
\&        \-\-Bilbo up in /usr/src/perl/pp_ctl.c
\&    EVER_ON_AND_ON
.Ve
.SH "Data: Arrays"
.IX Header "Data: Arrays"
.SS "What tha fuck iz tha difference between a list n' a array?"
.IX Subsection "What tha fuck iz tha difference between a list n' a array?"
(contributed by brian d foy)
.PP
A list be a gangbangin' fixed collection of scalars fo' realz. An array be a variable that
holdz a variable collection of scalars fo' realz. An array can supply its collection
for list operations, so list operations also work on arrays:
.PP
.Vb 3
\&    # slices
\&    ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq )[2,3];
\&    @animals[2,3];
\&
\&    # iteration
\&    foreach ( qw( dawg pussaaaaay bird ) ) { ... }
\&    foreach ( @animals ) { ... }
\&
\&    mah @three = grep { length == 3 } qw( dawg pussaaaaay bird );
\&    mah @three = grep { length == 3 } @animals;
\&
\&    # supply a argument list
\&    wash_animals( qw( dawg pussaaaaay bird ) );
\&    wash_animals( @animals );
.Ve
.PP
Array operations, which chizzle tha scalars, rearrange them, or add
or subtract some scalars, only work on arrays. These can't work on a
list, which is fixed. Y'all KNOW dat shit, muthafucka! Array operations include \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR,
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, n' \f(CW\*(C`splice\*(C'\fR.
.PP
An array can also chizzle its length:
.PP
.Vb 2
\&    $#animals = 1;  # truncate ta two elements
\&    $#animals = 10000; # pre\-extend ta 10,001 elements
.Ve
.PP
Yo ass can chizzle a array element yo, but you can't chizzle a list element:
.PP
.Vb 2
\&    $animals[0] = \*(AqRottweiler\*(Aq;
\&    qw( dawg pussaaaaay bird )[0] = \*(AqRottweiler\*(Aq; # syntax error!
\&
\&    foreach ( @animals ) {
\&        s/^d/fr/;  # works fine
\&    }
\&
\&    foreach ( qw( dawg pussaaaaay bird ) ) {
\&        s/^d/fr/;  # Error playa! Modification of read only value!
\&    }
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat if tha list element is itself a variable, it appears dat you
can chizzle a list element. But fuck dat shiznit yo, tha word on tha street is dat tha list element is tha variable, not
the data. Yo ass aint changin tha list element yo, but suttin' tha list
element refers to. Da list element itself don't chizzle: itz still
the same variable.
.PP
Yo ass also gotta be careful bout context. Yo ass can assign a array to
a scalar ta git tha number of elements up in tha array. This only works
for arrays, though:
.PP
.Vb 1
\&    mah $count = @animals;  # only works wit arrays
.Ve
.PP
If you try ta do tha same thang wit what tha fuck you be thinkin be a list, you
get a like different result fo' realz. Although it be lookin like you gotz a list
on tha righthand side, Perl straight-up sees a funky-ass bunch of scalars separated
by a cold-ass lil comma:
.PP
.Vb 1
\&    mah $scalar = ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq );  # $scalar gets bird
.Ve
.PP
Since you assignin ta a scalar, tha righthand side is up in scalar
context. Da comma operator (yes, itz a operator!) up in scalar
context evaluates its lefthand side, throws away tha result, and
evaluates itz righthand side n' returns tha result. In effect,
that list-lookalike assigns ta \f(CW$scalar\fR itz rightmost value. Many
people mess dis up cuz they chizzle a list-lookalike whose
last element be also tha count they expect:
.PP
.Vb 1
\&    mah $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally
.Ve
.ie n .SS "What tha fuck iz tha difference between $array[1] n' @array[1]?"
.el .SS "What tha fuck iz tha difference between \f(CW$array\fP[1] n' \f(CW@array\fP[1]?"
.IX Subsection "What tha fuck iz tha difference between $array[1] n' @array[1]?"
(contributed by brian d foy)
.PP
Da difference is tha sigil, dat special characta up in front of the
array name. Da \f(CW\*(C`$\*(C'\fR sigil means \*(L"exactly one item\*(R", while tha \f(CW\*(C`@\*(C'\fR
sigil means \*(L"zero or mo' items\*(R". Da \f(CW\*(C`$\*(C'\fR gets you a single scalar,
while tha \f(CW\*(C`@\*(C'\fR gets you a list.
.PP
Da mad drama arises cuz playas incorrectly assume dat tha sigil
denotes tha variable type.
.PP
Da \f(CW$array[1]\fR be a single-element access ta tha array. It aint nuthin but going
to return tha item up in index 1 (or undef if there is no item there).
If you intend ta git exactly one element from tha array, dis is the
form you should use.
.PP
Da \f(CW@array[1]\fR be a array slice, although it has only one index.
Yo ass can pull up multiple elements simultaneously by specifying
additionizzle indices as a list, like \f(CW@array[1,4,3,0]\fR.
.PP
Usin a slice on tha lefthand side of tha assignment supplies list
context ta tha righthand side. This can lead ta unexpected thangs up in dis biatch.
For instance, if you wanna read a single line from a gangbangin' filehandle,
assignin ta a scalar value is fine:
.PP
.Vb 1
\&    $array[1] = <STDIN>;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat up in list context, tha line input operator returns all of the
lines as a list. Da first line goes tha fuck into \f(CW@array[1]\fR n' tha rest
of tha lines mysteriously disappear:
.PP
.Vb 1
\&    @array[1] = <STDIN>;  # most likely not what tha fuck you want
.Ve
.PP
Either tha \f(CW\*(C`use warnings\*(C'\fR pragma or tha \fB\-w\fR flag will warn you when
you use a array slice wit a single index.
.SS "How tha fuck can I remove duplicate elements from a list or array?"
.IX Subsection "How tha fuck can I remove duplicate elements from a list or array?"
(contributed by brian d foy)
.PP
Use a hash. When you be thinkin tha lyrics \*(L"unique\*(R" or \*(L"duplicated\*(R", think
\&\*(L"hash keys\*(R".
.PP
If you couldn't give a fuckin shiznit bout tha order of tha elements, you could just
create tha hash then extract tha keys. It aint nuthin but not blingin how tha fuck you
create dat hash: just dat you use \f(CW\*(C`keys\*(C'\fR ta git tha unique
elements.
.PP
.Vb 3
\&    mah %hash   = map { $_, 1 } @array;
\&    # or a hash slice: @hash{ @array } = ();
\&    # or a gangbangin' foreach: $hash{$_} = 1 foreach ( @array );
\&
\&    mah @unique = keys %hash;
.Ve
.PP
If you wanna bust a module, try tha \f(CW\*(C`uniq\*(C'\fR function from
List::Mo'Utils. In list context it returns tha unique elements,
preservin they order up in tha list. In scalar context, it returns the
number of unique elements.
.PP
.Vb 1
\&    use List::Mo'Utils qw(uniq);
\&
\&    mah @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
\&    mah $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7
.Ve
.PP
Yo ass can also go all up in each element n' skip tha ones you've seen
before. Use a hash ta keep track. Da last time tha loop sees an
element, dat element has no key up in \f(CW%Seen\fR. Da \f(CW\*(C`next\*(C'\fR statement
creates tha key n' immediately uses its value, which is \f(CW\*(C`undef\*(C'\fR, so
the loop continues ta tha \f(CW\*(C`push\*(C'\fR n' increments tha value fo' that
key. Da next time tha loop sees dat same element, its key exists in
the hash \fIand\fR tha value fo' dat key is legit (since it aint 0 or
\&\f(CW\*(C`undef\*(C'\fR), so tha next skips dat iteration n' tha loop goes ta the
next element.
.PP
.Vb 2
\&    mah @unique = ();
\&    mah %seen   = ();
\&
\&    foreach mah $elem ( @array ) {
\&        next if $seen{ $elem }++;
\&        push @unique, $elem;
\&    }
.Ve
.PP
Yo ass can write dis mo' briefly rockin a grep, which do the
same thang.
.PP
.Vb 2
\&    mah %seen = ();
\&    mah @unique = grep { ! $seen{ $_ }++ } @array;
.Ve
.SS "How tha fuck can I tell whether a cold-ass lil certain element is contained up in a list or array?"
.IX Subsection "How tha fuck can I tell whether a cold-ass lil certain element is contained up in a list or array?"
(portionz of dis answer contributed by Anno Siegel n' brian d foy)
.PP
Hearin tha word \*(L"in\*(R" be a \fIin\fRdication dat you probably should have
used a hash, not a list or array, ta store yo' data yo. Hashes are
designed ta answer dis question quickly n' efficiently fo' realz. Arrays aren't.
.PP
That bein holla'd, there be nuff muthafuckin ways ta approach all dis bullshit. In Perl 5.10
and later, you can use tha smart-ass match operator ta check dat a item is
contained up in a array or a hash:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( $item ~~ @array ) {
\&        say "Da array gotz nuff $item"
\&    }
\&
\&    if( $item ~~ %hash ) {
\&        say "Da hash gotz nuff $item"
\&    }
.Ve
.PP
With earlier versionz of Perl, you gotta do a lil' bit mo' work. If you
are goin ta make dis query nuff times over arbitrary strang joints,
the fastest way is probably ta invert tha original gangsta array n' maintain a
hash whose keys is tha straight-up original gangsta arrayz joints:
.PP
.Vb 3
\&    mah @blues = qw/azure cerulean teal turquoise lapis\-lazuli/;
\&    mah %is_blue = ();
\&    fo' (@blues) { $is_blue{$_} = 1 }
.Ve
.PP
Now you can check whether \f(CW$is_blue{$some_color}\fR. Well shiiiit, it might have
been a phat scam ta keep tha blues all up in a hash up in tha straight-up original gangsta place.
.PP
If tha joints is all lil' small-ass integers, you could bust a simple indexed
array. This kind of a array will take up less space:
.PP
.Vb 4
\&    mah @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
\&    mah @is_tiny_prime = ();
\&    fo' (@primes) { $is_tiny_prime[$_] = 1 }
\&    # or simply  @istiny_prime[@primes] = (1) x @primes;
.Ve
.PP
Now you check whether \f(CW$is_tiny_prime\fR[$some_number].
.PP
If tha joints up in question is integers instead of strings, you can save
quite a shitload of space by rockin bit strings instead:
.PP
.Vb 3
\&    mah @articlez = ( 1..10, 150..2000, 2017 );
\&    undef $read;
\&    fo' (@articles) { vec($read,$_,1) = 1 }
.Ve
.PP
Now check whether \f(CW\*(C`vec($read,$n,1)\*(C'\fR is legit fo' some \f(CW$n\fR.
.PP
These methodz guarantee fast individual tests but require a re-organization
of tha original gangsta list or array. They only pay off if you gotta test
multiple joints against tha same array.
.PP
If yo ass is testin only once, tha standard module List::Util exports
the function \f(CW\*(C`first\*(C'\fR fo' dis purpose. Well shiiiit, it works by stoppin once it
findz tha element. It aint nuthin but freestyled up in C fo' speed, n' its Perl equivalent
looks like dis subroutine:
.PP
.Vb 7
\&    sub first (&@) {
\&        mah $code = shift;
\&        foreach (@_) {
\&            return $_ if &{$code}();
\&        }
\&        undef;
\&    }
.Ve
.PP
If speed iz of lil concern, tha common idiom uses grep up in scalar context
(which returns tha number of shit dat passed its condition) ta traverse the
entire list. This do have tha benefit of spittin some lyrics ta you how tha fuck nuff matches it
found, though.
.PP
.Vb 1
\&    mah $is_there = grep $_ eq $whatever, @array;
.Ve
.PP
If you wanna straight-up extract tha matchin elements, simply use grep in
list context.
.PP
.Vb 1
\&    mah @matches = grep $_ eq $whatever, @array;
.Ve
.SS "How tha fuck do I compute tha difference of two arrays, biatch? How tha fuck do I compute tha intersection of two arrays?"
.IX Subsection "How tha fuck do I compute tha difference of two arrays, biatch? How tha fuck do I compute tha intersection of two arrays?"
Use a hash yo. Herez code ta do both n' mo' n' mo' n' mo'. Well shiiiit, it assumes dat each
element is unique up in a given array:
.PP
.Vb 7
\&    mah (@union, @intersection, @difference);
\&    mah %count = ();
\&    foreach mah $element (@array1, @array2) { $count{$element}++ }
\&    foreach mah $element (keys %count) {
\&        push @union, $element;
\&        push @{ $count{$element} > 1 , biatch? \e@intersection : \e@difference }, $element;
\&    }
.Ve
.PP
Note dat dis is tha \fIsymmetric difference\fR, dat is, all elements
in either A or up in B but not up in both. Think of it as a xor operation.
.SS "How tha fuck do I test whether two arrays or hashes is equal?"
.IX Subsection "How tha fuck do I test whether two arrays or hashes is equal?"
With Perl 5.10 n' later, tha smart-ass match operator can hit you wit tha answer
with tha least amount of work:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( @array1 ~~ @array2 ) {
\&        say "Da arrays is tha same";
\&    }
\&
\&    if( %hash1 ~~ %hash2 ) # don\*(Aqt check joints muthafucka!  {
\&        say "Da hash keys is tha same";
\&    }
.Ve
.PP
Da followin code works fo' single-level arrays. Well shiiiit, it uses a
stringwise comparison, n' do not distinguish defined versus
undefined empty strings. Modify if you have other needs.
.PP
.Vb 1
\&    $are_equal = compare_arrays(\e@frogs, \e@toads);
\&
\&    sub compare_arrays {
\&        mah ($first, $second) = @_;
\&        no warnings;  # silence spurious \-w undef disses
\&        return 0 unless @$first == @$second;
\&        fo' (my $i = 0; $i < @$first; $i++) {
\&            return 0 if $first\->[$i] ne $second\->[$i];
\&        }
\&        return 1;
\&    }
.Ve
.PP
For multilevel structures, you may wish ta use a approach more
like dis one. Well shiiiit, it uses tha \s-1CPAN\s0 module FreezeThaw:
.PP
.Vb 2
\&    use FreezeThaw qw(cmpStr);
\&    mah @a = mah @b = ( "this", "that", [ "more", "stuff" ] );
\&
\&    printf "a n' b contain %s arrays\en",
\&        cmpStr(\e@a, \e@b) == 0
\&        , biatch? "the same"
\&        : "different";
.Ve
.PP
This approach also works fo' comparin hashes yo. Here we'll demonstrate
two different lyrics:
.PP
.Vb 1
\&    use FreezeThaw qw(cmpStr cmpStrHard);
\&
\&    mah %a = mah %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
\&    $a{EXTRA} = \e%b;
\&    $b{EXTRA} = \e%a;
\&
\&    printf "a n' b contain %s hashes\en",
\&    cmpStr(\e%a, \e%b) == 0 , biatch? "the same" : "different";
\&
\&    printf "a n' b contain %s hashes\en",
\&    cmpStrHard(\e%a, \e%b) == 0 , biatch? "the same" : "different";
.Ve
.PP
Da first reports dat both dem tha hashes contain tha same data,
while tha second reports dat they do not. Which you prefer is left as
an exercise ta tha reader.
.SS "How tha fuck do I find tha straight-up original gangsta array element fo' which a cold-ass lil condizzle is true?"
.IX Subsection "How tha fuck do I find tha straight-up original gangsta array element fo' which a cold-ass lil condizzle is true?"
To find tha straight-up original gangsta array element which satisfies a cold-ass lil condition, you can
use tha \f(CW\*(C`first()\*(C'\fR function up in tha List::Util module, which comes
with Perl 5.8. This example findz tha straight-up original gangsta element dat gotz nuff
\&\*(L"Perl\*(R".
.PP
.Vb 1
\&    use List::Util qw(first);
\&
\&    mah $element = first { /Perl/ } @array;
.Ve
.PP
If you cannot use List::Util, you can make yo' own loop ta do the
same thang. Once you find tha element, you stop tha loop wit last.
.PP
.Vb 4
\&    mah $found;
\&    foreach ( @array ) {
\&        if( /Perl/ ) { $found = $_; last }
\&    }
.Ve
.PP
If you want tha array index, use tha \f(CW\*(C`firstidx()\*(C'\fR function from
\&\f(CW\*(C`List::Mo'Utils\*(C'\fR:
.PP
.Vb 2
\&    use List::Mo'Utils qw(firstidx);
\&    mah $index = firstidx { /Perl/ } @array;
.Ve
.PP
Or write it yo ass, iteratin all up in tha indices
and checkin tha array element at each index until you find one
that satisfies tha condition:
.PP
.Vb 8
\&    my( $found, $index ) = ( undef, \-1 );
\&    for( $i = 0; $i < @array; $i++ ) {
\&        if( $array[$i] =~ /Perl/ ) {
\&            $found = $array[$i];
\&            $index = $i;
\&            last;
\&        }
\&    }
.Ve
.SS "How tha fuck do I handle linked lists?"
.IX Subsection "How tha fuck do I handle linked lists?"
(contributed by brian d foy)
.PP
Perlz arrays aint gots a gangbangin' fixed size, so you don't need linked lists
if you just wanna add or remove items. Yo ass can use array operations
like fuckin \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, or \f(CW\*(C`splice\*(C'\fR ta do
that.
.PP
Sometimes, however, linked lists can be useful up in thangs where you
wanna \*(L"shard\*(R" a array so you have have nuff lil' small-ass arrays instead of
a single big-ass array. Yo ass can keep arrays longer than Perlz phattest
array index, lock smalla arrays separately up in threaded programs,
reallocate less memory, or quickly bang elements up in tha middle of
the chain.
.PP
Steve Lembark goes all up in tha details up in his \s-1YAPC::NA 2009\s0 rap \*(L"Perly
Linked Lists\*(R" ( <http://www.slideshare.net/lembark/perly\-linked\-lists> ),
although you can just use his LinkedList::Single module.
.SS "How tha fuck do I handle circular lists?"
.IX Xref "circular array Tie::Cycle Array::Iterator::Circular cycle modulus"
.IX Subsection "How tha fuck do I handle circular lists?"
(contributed by brian d foy)
.PP
If you wanna cycle all up in a array endlessly, you can increment the
index modulo tha number of elements up in tha array:
.PP
.Vb 2
\&    mah @array = qw( a funky-ass b c );
\&    mah $i = 0;
\&
\&    while( 1 ) {
\&        print $array[ $i++ % @array ], "\en";
\&        last if $i > 20;
\&    }
.Ve
.PP
Yo ass can also use Tie::Cycle ta bust a scalar dat always has the
next element of tha circular array:
.PP
.Vb 1
\&    use Tie::Cycle;
\&
\&    tie mah $cycle, \*(AqTie::Cycle\*(Aq, [ qw( FFFFFF 000000 FFFF00 ) ];
\&
\&    print $cycle; # FFFFFF
\&    print $cycle; # 000000
\&    print $cycle; # FFFF00
.Ve
.PP
Da Array::Iterator::Circular creates a iterator object for
circular arrays:
.PP
.Vb 1
\&    use Array::Iterator::Circular;
\&
\&    mah $color_iterator = Array::Iterator::Circular\->new(
\&        qw(red chronic blue orange)
\&        );
\&
\&    foreach ( 1 .. 20 ) {
\&        print $color_iterator\->next, "\en";
\&    }
.Ve
.SS "How tha fuck do I shuffle a array randomly?"
.IX Subsection "How tha fuck do I shuffle a array randomly?"
If you either have Perl 5.8.0 or lata installed, or if you have
Scalar-List-Utils 1.03 or lata installed, you can say:
.PP
.Vb 1
\&    use List::Util \*(Aqshuffle\*(Aq;
\&
\&    @shuffled = shuffle(@list);
.Ve
.PP
If not, you can bust a Fisher-Yates shuffle.
.PP
.Vb 3
\&    sub fisher_yates_shuffle {
\&        mah $deck = shift;  # $deck be a reference ta a array
\&        return unless @$deck; # must not be empty!
\&
\&        mah $i = @$deck;
\&        while (\-\-$i) {
\&            mah $j = int rand ($i+1);
\&            @$deck[$i,$j] = @$deck[$j,$i];
\&        }
\&    }
\&
\&    # shuffle mah mpeg collection
\&    #
\&    mah @mpeg = <audio/*/*.mp3>;
\&    fisher_yates_shuffle( \e@mpeg );    # randomize @mpeg up in place
\&    print @mpeg;
.Ve
.PP
Note dat tha above implementation shufflez a array up in place,
unlike tha \f(CW\*(C`List::Util::shuffle()\*(C'\fR which takes a list n' returns
a freshly smoked up shuffled list.
.PP
You've probably peeped shufflin algorithms dat work rockin splice,
randomly pickin another element ta swap tha current element with
.PP
.Vb 6
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10;  # just a thugged-out demo
\&    while (@old) {
\&        push(@new, splice(@old, rand @old, 1));
\&    }
.Ve
.PP
This is wack cuz splice be already O(N), n' since you do it N
times, you just invented a quadratic algorithm; dat is, O(N**2).
This do not scale, although Perl is so efficient dat you probably
won't notice dis until you have rather largish arrays.
.SS "How tha fuck do I process/modify each element of a array?"
.IX Subsection "How tha fuck do I process/modify each element of a array?"
Use \f(CW\*(C`for\*(C'\fR/\f(CW\*(C`foreach\*(C'\fR:
.PP
.Vb 4
\&    fo' (@lines) {
\&        s/foo/bar/;    # chizzle dat word
\&        tr/XZ/ZX/;    # swap dem letters
\&    }
.Ve
.PP
Herez another; letz compute spherical volumes:
.PP
.Vb 5
\&    mah @volumes = @radii;
\&    fo' (@volumes) {   # @volumes has chizzled parts
\&        $_ **= 3;
\&        $_ *= (4/3) * 3.14159;  # dis is ghon be constant folded
\&    }
.Ve
.PP
which can also be done wit \f(CW\*(C`map()\*(C'\fR which is made ta transform
one list tha fuck into another:
.PP
.Vb 1
\&    mah @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;
.Ve
.PP
If you wanna do tha same thang ta modify tha jointz of the
hash, you can use tha \f(CW\*(C`values\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch fo' realz. Az of Perl 5.6
the joints is not copied, so if you modify \f(CW$orbit\fR (in this
case), you modify tha value.
.PP
.Vb 3
\&    fo' mah $orbit ( joints %orbits ) {
\&        ($orbit **= 3) *= (4/3) * 3.14159;
\&    }
.Ve
.PP
Prior ta perl 5.6 \f(CW\*(C`values\*(C'\fR returned copiez of tha joints,
so olda perl code often gotz nuff constructions such as
\&\f(CW@orbits{keys %orbits}\fR instead of \f(CW\*(C`values %orbits\*(C'\fR where
the hash is ta be modified.
.SS "How tha fuck do I select a random element from a array?"
.IX Subsection "How tha fuck do I select a random element from a array?"
Use tha \f(CW\*(C`rand()\*(C'\fR function (see \*(L"rand\*(R" up in perlfunc):
.PP
.Vb 2
\&    mah $index   = rand @array;
\&    mah $element = $array[$index];
.Ve
.PP
Or, simply:
.PP
.Vb 1
\&    mah $element = $array[ rand @array ];
.Ve
.SS "How tha fuck do I permute N elementz of a list?"
.IX Xref "List::Permutor permute Algorithm::Loops Knuth Da Art of Computa Programmin Fischer-Krause"
.IX Subsection "How tha fuck do I permute N elementz of a list?"
Use tha List::Permutor module on \s-1CPAN.\s0 If tha list is straight-up an
array, try tha Algorithm::Permute module (also on \s-1CPAN\s0). It's
written up in \s-1XS\s0 code n' is straight-up efficient:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    mah @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&    mah $p_iterator = Algorithm::Permute\->new ( \e@array );
\&
\&    while (my @perm = $p_iterator\->next) {
\&       print "next permutation: (@perm)\en";
\&    }
.Ve
.PP
For even fasta execution, you could do:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    mah @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&
\&    Algorithm::Permute::permute {
\&        print "next permutation: (@array)\en";
\&    } @array;
.Ve
.PP
Herez a lil program dat generates all permutationz of all the
wordz on each line of input. Da algorithm embodied up in the
\&\f(CW\*(C`permute()\*(C'\fR function is discussed up in Volume 4 (still unpublished) of
Knuthz \fIDa Art of Computa Programming\fR n' will work on any list:
.PP
.Vb 2
\&    #!/usr/bin/perl \-n
\&    # Fischer\-Krause ordered permutation generator
\&
\&    sub permute (&@) {
\&        mah $code = shift;
\&        mah @idx = 0..$#_;
\&        while ( $code\->(@_[@idx]) ) {
\&            mah $p = $#idx;
\&            \-\-$p while $idx[$p\-1] > $idx[$p];
\&            mah $q = $p or return;
\&            push @idx, reverse splice @idx, $p;
\&            ++$q while $idx[$p\-1] > $idx[$q];
\&            @idx[$p\-1,$q]=@idx[$q,$p\-1];
\&        }
\&    }
\&
\&    permute { print "@_\en" } split;
.Ve
.PP
Da Algorithm::Loops module also serves up tha \f(CW\*(C`NextPermute\*(C'\fR and
\&\f(CW\*(C`NextPermuteNum\*(C'\fR functions which efficiently find all unique permutations
of a array, even if it gotz nuff duplicate joints, modifyin it in-place:
if its elements is up in reverse-sorted order then tha array is reversed,
makin it sorted, n' it returns false; otherwise tha next
permutation is returned.
.PP
\&\f(CW\*(C`NextPermute\*(C'\fR uses strang order n' \f(CW\*(C`NextPermuteNum\*(C'\fR numeric order, so
you can enumerate all tha permutationz of \f(CW0..9\fR like this:
.PP
.Vb 1
\&    use Algorithm::Loops qw(NextPermuteNum);
\&
\&    mah @list= 0..9;
\&    do { print "@list\en" } while NextPermuteNum @list;
.Ve
.SS "How tha fuck do I sort a array by (anything)?"
.IX Subsection "How tha fuck do I sort a array by (anything)?"
Supply a cold-ass lil comparison function ta \fIsort()\fR (busted lyrics bout up in \*(L"sort\*(R" up in perlfunc):
.PP
.Vb 1
\&    @list = sort { $a <=> $b } @list;
.Ve
.PP
Da default sort function is cmp, strang comparison, which would
sort \f(CW\*(C`(1, 2, 10)\*(C'\fR tha fuck into \f(CW\*(C`(1, 10, 2)\*(C'\fR. \f(CW\*(C`<=>\*(C'\fR, used above, is
the numerical comparison operator.
.PP
If you gotz a cold-ass lil fucked up function needed ta pull up tha part you
wanna sort on, then don't do it inside tha sort function. I aint talkin' bout chicken n' gravy biatch. Pull it
out first, cuz tha sort \s-1BLOCK\s0 can be called nuff times fo' the
same element yo. Herez a example of how tha fuck ta pull up tha straight-up original gangsta word
afta tha straight-up original gangsta number on each item, n' then sort dem lyrics
case-insensitively.
.PP
.Vb 7
\&    mah @idx;
\&    fo' (@data) {
\&        mah $item;
\&        ($item) = /\ed+\es*(\eS+)/;
\&        push @idx, uc($item);
\&    }
\&    mah @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
.Ve
.PP
which could also be freestyled dis way, rockin a trick
thatz come ta be known as tha Schwartzian Transform:
.PP
.Vb 3
\&    mah @sorted = map  { $_\->[0] }
\&        sort { $a\->[1] cmp $b\->[1] }
\&        map  { [ $_, uc( (/\ed+\es*(\eS+)/)[0]) ] } @data;
.Ve
.PP
If you need ta sort on nuff muthafuckin fields, tha followin paradigm is useful.
.PP
.Vb 5
\&    mah @sorted = sort {
\&        field1($a) <=> field1($b) ||
\&        field2($a) cmp field2($b) ||
\&        field3($a) cmp field3($b)
\&    } @data;
.Ve
.PP
This can be conveniently combined wit precalculation of keys as given
above.
.PP
See tha \fIsort\fR article up in tha \*(L"Far Mo' Than Yo ass Ever Wanted
To Know\*(R" collection up in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> for
more bout dis approach.
.PP
See also tha question lata up in perlfaq4 on sortin hashes.
.SS "How tha fuck do I manipulate arrayz of bits?"
.IX Subsection "How tha fuck do I manipulate arrayz of bits?"
Use \f(CW\*(C`pack()\*(C'\fR n' \f(CW\*(C`unpack()\*(C'\fR, or else \f(CW\*(C`vec()\*(C'\fR n' tha bitwise
operations.
.PP
For example, you don't gotta store individual bits up in a array
(which would mean dat you wastin a shitload of space). To convert an
array of bits ta a string, use \f(CW\*(C`vec()\*(C'\fR ta set tha right bits, n' you can put dat on yo' toast. This
sets \f(CW$vec\fR ta have bit N set only if \f(CW$ints[N]\fR was set:
.PP
.Vb 5
\&    mah @ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
\&    mah $vec = \*(Aq\*(Aq;
\&    foreach( 0 .. $#ints ) {
\&        vec($vec,$_,1) = 1 if $ints[$_];
\&    }
.Ve
.PP
Da strang \f(CW$vec\fR only takes up as nuff bits as it needs. For
instance, if you had 16 entries up in \f(CW@ints\fR, \f(CW$vec\fR only needz two
bytes ta store dem (not countin tha scalar variable overhead).
.PP
Herez how, given a vector up in \f(CW$vec\fR, you can git dem bits into
your \f(CW@ints\fR array:
.PP
.Vb 7
\&    sub bitvec_to_list {
\&        mah $vec = shift;
\&        mah @ints;
\&        # Find null\-byte densitizzle then select dopest algorithm
\&        if ($vec =~ tr/\e0// / length $vec > 0.95) {
\&            use integer;
\&            mah $i;
\&
\&            # This method is fasta wit mostly null\-bytes
\&            while($vec =~ /[^\e0]/g ) {
\&                $i = \-9 + 8 * pos $vec;
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&            }
\&        }
\&        else {
\&            # This method be a gangbangin' fast general algorithm
\&            use integer;
\&            mah $bits = unpack "b*", $vec;
\&            push @ints, 0 if $bits =~ s/^(\ed)// && $1;
\&            push @ints, pos $bits while($bits =~ /1/g);
\&        }
\&
\&        return \e@ints;
\&    }
.Ve
.PP
This method gets fasta tha mo' sparse tha bit vector is.
(Courtesy of Slim Tim Bunce n' Winfried Koenig.)
.PP
Yo ass can make tha while loop a shitload shorta wit dis suggestion
from Benjamin Goldberg:
.PP
.Vb 3
\&    while($vec =~ /[^\e0]+/g ) {
\&        push @ints, grep vec($vec, $_, 1), $\-[0] * 8 .. $+[0] * 8;
\&    }
.Ve
.PP
Or use tha \s-1CPAN\s0 module Bit::Vector:
.PP
.Vb 3
\&    mah $vector = Bit::Vector\->new($num_of_bits);
\&    $vector\->Index_List_Store(@ints);
\&    mah @ints = $vector\->Index_List_Read();
.Ve
.PP
Bit::Vector serves up efficient methodz fo' bit vector, sets of
small integers n' \*(L"bangin' int\*(R" math.
.PP
Herez a mo' extensive illustration rockin \fIvec()\fR:
.PP
.Vb 7
\&    # vec demo
\&    mah $vector = "\exff\ex0f\exef\exfe";
\&    print "Ilya\*(Aqs strang \e\exff\e\ex0f\e\exef\e\exfe represents tha number ",
\&    unpack("N", $vector), "\en";
\&    mah $is_set = vec($vector, 23, 1);
\&    print "Its 23rd bit is ", $is_set , biatch? "set" : "clear", ".\en";
\&    pvec($vector);
\&
\&    set_vec(1,1,1);
\&    set_vec(3,1,1);
\&    set_vec(23,1,1);
\&
\&    set_vec(3,1,3);
\&    set_vec(3,2,3);
\&    set_vec(3,4,3);
\&    set_vec(3,4,7);
\&    set_vec(3,8,3);
\&    set_vec(3,8,7);
\&
\&    set_vec(0,32,17);
\&    set_vec(1,32,17);
\&
\&    sub set_vec {
\&        mah ($offset, $width, $value) = @_;
\&        mah $vector = \*(Aq\*(Aq;
\&        vec($vector, $offset, $width) = $value;
\&        print "offset=$offset width=$width value=$value\en";
\&        pvec($vector);
\&    }
\&
\&    sub pvec {
\&        mah $vector = shift;
\&        mah $bits = unpack("b*", $vector);
\&        mah $i = 0;
\&        mah $BASE = 8;
\&
\&        print "vector length up in bytes: ", length($vector), "\en";
\&        @bytes = unpack("A8" x length($vector), $bits);
\&        print "bits are: @bytes\en\en";
\&    }
.Ve
.SS "Why do \fIdefined()\fP return legit on empty arrays n' hashes?"
.IX Subsection "Why do defined() return legit on empty arrays n' hashes?"
Da short rap is dat you should probably only use defined on scalars or
functions, not on aggregates (arrays n' hashes). Right back up in yo muthafuckin ass. See \*(L"defined\*(R" up in perlfunc
in tha 5.004 release or lata of Perl fo' mo' detail.
.SH "Data: Hashes (Associatizzle Arrays)"
.IX Header "Data: Hashes (Associatizzle Arrays)"
.SS "How tha fuck do I process a entire hash?"
.IX Subsection "How tha fuck do I process a entire hash?"
(contributed by brian d foy)
.PP
There is a cold-ass lil couple ways dat you can process a entire hash. You
can git a list of keys, then go all up in each key, or grab a one
key-value pair at a time.
.PP
To go all up in all of tha keys, use tha \f(CW\*(C`keys\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. This extracts
all of tha keyz of tha hash n' gives dem back ta you as a list. You
can then git tha value all up in tha particular key you processing:
.PP
.Vb 4
\&    foreach mah $key ( keys %hash ) {
\&        mah $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Once you have tha list of keys, you can process dat list before you
process tha hash elements, n' you can put dat on yo' toast. For instance, you can sort tha keys so you
can process dem up in lexical order:
.PP
.Vb 4
\&    foreach mah $key ( sort keys %hash ) {
\&        mah $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Or, you might wanna only process a shitload of tha items. If you only want
to deal wit tha keys dat start wit \f(CW\*(C`text:\*(C'\fR, you can select just
those rockin \f(CW\*(C`grep\*(C'\fR:
.PP
.Vb 4
\&    foreach mah $key ( grep /^text:/, keys %hash ) {
\&        mah $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
If tha hash is straight-up large, you might not wanna create a long-ass list of
keys. To save some memory, you can grab one key-value pair at a time using
\&\f(CW\*(C`each()\*(C'\fR, which returns a pair you aint peeped yet:
.PP
.Vb 3
\&    while( my( $key, $value ) = each( %hash ) ) {
\&        ...
\&    }
.Ve
.PP
Da \f(CW\*(C`each\*(C'\fR operator returns tha pairs up in apparently random order, so if
orderin mattas ta you, you gonna gotta stick wit tha \f(CW\*(C`keys\*(C'\fR method.
.PP
Da \f(CW\*(C`each()\*(C'\fR operator can be a lil' bit tricky though cause I gots dem finger-lickin' chickens wit tha siz-auce. Yo ass can't add or
delete keyz of tha hash while you rockin it without possibly
skippin or re-processin some pairs afta Perl internally rehashes
all of tha elements fo' realz. Additionally, a hash has only one iterator, so if
you mix \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR on tha same hash, you risk resetting
the iterator n' messin up yo' processing. Right back up in yo muthafuckin ass. See tha \f(CW\*(C`each\*(C'\fR entry in
perlfunc fo' mo' details.
.SS "How tha fuck do I merge two hashes?"
.IX Xref "hash merge slice, hash"
.IX Subsection "How tha fuck do I merge two hashes?"
(contributed by brian d foy)
.PP
Before you decizzle ta merge two hashes, you gotta decizzle what tha fuck ta do
if both hashes contain keys dat is tha same n' if you wanna leave
the original gangsta hashes as they were.
.PP
If you wanna preserve tha original gangsta hashes, copy one hash (\f(CW%hash1\fR)
to a freshly smoked up hash (\f(CW%new_hash\fR), then add tha keys from tha other hash
(\f(CW%hash2\fR ta tha freshly smoked up hash. Checkin dat tha key already exists in
\&\f(CW%new_hash\fR gives you a cold-ass lil chizzle ta decizzle what tha fuck ta do wit the
duplicates:
.PP
.Vb 1
\&    mah %new_hash = %hash1; # cook up a cold-ass lil copy; leave %hash1 alone
\&
\&    foreach mah $key2 ( keys %hash2 ) {
\&        if( exists $new_hash{$key2} ) {
\&            warn "Key [$key2] is up in both hashes!";
\&            # handle tha duplicate (like only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $new_hash{$key2} = $hash2{$key2};
\&        }
\&    }
.Ve
.PP
If you don't wanna create a freshly smoked up hash, you can still use dis looping
technique; just chizzle tha \f(CW%new_hash\fR ta \f(CW%hash1\fR.
.PP
.Vb 11
\&    foreach mah $key2 ( keys %hash2 ) {
\&        if( exists $hash1{$key2} ) {
\&            warn "Key [$key2] is up in both hashes!";
\&            # handle tha duplicate (like only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $hash1{$key2} = $hash2{$key2};
\&        }
\&      }
.Ve
.PP
If you couldn't give a fuckin shiznit dat one hash overwrites keys n' joints from tha other, you
could just bust a hash slice ta add one hash ta another n' shit. In dis case, joints
from \f(CW%hash2\fR replace joints from \f(CW%hash1\fR when they have keys up in common:
.PP
.Vb 1
\&    @hash1{ keys %hash2 } = joints %hash2;
.Ve
.SS "What happens if I add or remove keys from a hash while iteratin over it?"
.IX Subsection "What happens if I add or remove keys from a hash while iteratin over it?"
(contributed by brian d foy)
.PP
Da easy as fuck  answer is \*(L"Don't do that!\*(R"
.PP
If you iterate all up in tha hash wit \fIeach()\fR, you can delete tha key
most recently returned without worryin bout dat shit. If you delete or add
other keys, tha iterator may skip or double up on dem since perl
may rearrange tha hash table. Right back up in yo muthafuckin ass. See the
entry fo' \f(CW\*(C`each()\*(C'\fR up in perlfunc.
.SS "How tha fuck do I look up a hash element by value?"
.IX Subsection "How tha fuck do I look up a hash element by value?"
Smoke a reverse hash:
.PP
.Vb 2
\&    mah %by_value = reverse %by_key;
\&    mah $key = $by_value{$value};
.Ve
.PP
Thatz not particularly efficient. Well shiiiit, it would be mo' space-efficient
to use:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&        $by_value{$value} = $key;
\&    }
.Ve
.PP
If yo' hash could have repeated joints, tha methodz above will only find
one of tha associated keys.  This may or may not worry yo thugged-out ass. If it do
worry you, you can always reverse tha hash tha fuck into a hash of arrays instead:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&         push @{$key_list_by_value{$value}}, $key;
\&    }
.Ve
.SS "How tha fuck can I know how tha fuck nuff entries is up in a hash?"
.IX Subsection "How tha fuck can I know how tha fuck nuff entries is up in a hash?"
(contributed by brian d foy)
.PP
This is straight-up similar ta \*(L"How tha fuck do I process a entire hash?\*(R", also in
perlfaq4 yo, but a lil' bit simpla up in tha common cases.
.PP
Yo ass can use tha \f(CW\*(C`keys()\*(C'\fR built-in function up in scalar context ta smoke up
have nuff entries you have up in a hash:
.PP
.Vb 1
\&    mah $key_count = keys %hash; # must be scalar context!
.Ve
.PP
If you wanna smoke up how tha fuck nuff entries gotz a thugged-out defined value, that's
a bit different. Yo ass gotta check each value fo' realz. A \f(CW\*(C`grep\*(C'\fR is handy:
.PP
.Vb 1
\&    mah $defined_value_count = grep { defined } joints %hash;
.Ve
.PP
Yo ass can use dat same structure ta count tha entries any way that
you like. If you want tha count of tha keys wit vowels up in them,
you just test fo' dat instead:
.PP
.Vb 1
\&    mah $vowel_count = grep { /[aeiou]/ } keys %hash;
.Ve
.PP
Da \f(CW\*(C`grep\*(C'\fR up in scalar context returns tha count. If you want tha list
of matchin items, just use it up in list context instead:
.PP
.Vb 1
\&    mah @defined_values = grep { defined } joints %hash;
.Ve
.PP
Da \f(CW\*(C`keys()\*(C'\fR function also resets tha iterator, which means dat you may
see strange thangs up in dis biatch if you use dis between usez of other hash operators
like fuckin \f(CW\*(C`each()\*(C'\fR.
.SS "How tha fuck do I sort a hash (optionally by value instead of key)?"
.IX Subsection "How tha fuck do I sort a hash (optionally by value instead of key)?"
(contributed by brian d foy)
.PP
To sort a hash, start wit tha keys. In dis example, we give tha list of
keys ta tha sort function which then compares dem ASCIIbetically (which
might be affected by yo' locale settings). Da output list has tha keys
in ASCIIbetical order n' shit. Once our crazy asses have tha keys, we can go all up in dem to
create a report which lists tha keys up in ASCIIbetical order.
.PP
.Vb 1
\&    mah @keys = sort { $a cmp $b } keys %hash;
\&
\&    foreach mah $key ( @keys ) {
\&        printf "%\-20s %6d\en", $key, $hash{$key};
\&    }
.Ve
.PP
We could git mo' fancy up in tha \f(CW\*(C`sort()\*(C'\fR block though cause I gots dem finger-lickin' chickens wit tha siz-auce. Instead of
comparin tha keys, we can compute a value wit dem n' use that
value as tha comparison.
.PP
For instance, ta make our report order case-insensitive, we use
\&\f(CW\*(C`lc\*(C'\fR ta lowercase tha keys before comparin them:
.PP
.Vb 1
\&    mah @keys = sort { lc $a cmp lc $b } keys %hash;
.Ve
.PP
Note: if tha computation is high-rollin' or tha hash has nuff elements,
you may wanna peep tha Schwartzian Transform ta cache the
computation thangs up in dis biatch.
.PP
If we wanna sort by tha hash value instead, we use tha hash key
to look it up. We still git up a list of keys yo, but dis time they
are ordered by they value.
.PP
.Vb 1
\&    mah @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;
.Ve
.PP
From there we can git mo' complex. If tha hash joints is tha same,
we can provide a secondary sort on tha hash key.
.PP
.Vb 5
\&    mah @keys = sort {
\&        $hash{$a} <=> $hash{$b}
\&            or
\&        "\eL$a" cmp "\eL$b"
\&    } keys %hash;
.Ve
.SS "How tha fuck can I always keep mah hash sorted?"
.IX Xref "hash tie sort DB_File Tie::IxHash"
.IX Subsection "How tha fuck can I always keep mah hash sorted?"
Yo ass can look tha fuck into rockin tha \f(CW\*(C`DB_File\*(C'\fR module n' \f(CW\*(C`tie()\*(C'\fR rockin the
\&\f(CW$DB_BTREE\fR hash bindings as documented up in \*(L"In Memory
Databases\*(R" up in DB_File. Da Tie::IxHash module from \s-1CPAN\s0 might also be
instructizzle fo' realz. Although dis do keep yo' hash sorted, you might not
like tha slowdown you suffer from tha tie intercourse. Is you shizzle you
need ta do this, biatch? :)
.ie n .SS "Whatz tha difference between ""delete"" n' ""undef"" wit hashes?"
.el .SS "Whatz tha difference between ``delete'' n' ``undef'' wit hashes?"
.IX Subsection "Whatz tha difference between delete n' undef wit hashes?"
Hashes contain pairz of scalars: tha straight-up original gangsta is tha key, the
second is tha value. Da key is ghon be coerced ta a string,
although tha value can be any kind of scalar: string,
number, or reference. If a key \f(CW$key\fR is present in
\&\f(CW%hash\fR, \f(CW\*(C`exists($hash{$key})\*(C'\fR will return true. Da value
for a given key can be \f(CW\*(C`undef\*(C'\fR, up in which case
\&\f(CW$hash{$key}\fR is ghon be \f(CW\*(C`undef\*(C'\fR while \f(CW\*(C`exists $hash{$key}\*(C'\fR
will return true. This correspondz ta (\f(CW$key\fR, \f(CW\*(C`undef\*(C'\fR)
bein up in tha hash.
.PP
Pictures help.. yo. Herez tha \f(CW%hash\fR table:
.PP
.Vb 7
\&      keys  joints
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   |  3   |
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
And these conditions hold
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is true
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is true
\&    exists $hash{\*(Aqa\*(Aq}                is legit (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
If you now say
.PP
.Vb 1
\&    undef $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 7
\&      keys  joints
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   | undef|
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; chizzlez up in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is FALSE
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is FALSE
\&    exists $hash{\*(Aqa\*(Aq}                is legit (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
Notice tha last two: you have a undef value yo, but a thugged-out defined key!
.PP
Now, consider this:
.PP
.Vb 1
\&    delete $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 6
\&      keys  joints
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; chizzlez up in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is false
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is false
\&    exists $hash{\*(Aqa\*(Aq}                is FALSE (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is FALSE
.Ve
.PP
See, tha whole entry is gone!
.SS "Why don't mah tied hashes make tha defined/exists distinction?"
.IX Subsection "Why don't mah tied hashes make tha defined/exists distinction?"
This dependz on tha tied hashz implementation of \s-1\fIEXISTS\s0()\fR.
For example, there aint tha concept of undef wit hashes
that is tied ta DBM* files. Well shiiiit, it also means dat \fIexists()\fR and
\&\fIdefined()\fR do tha same thang wit a DBM* file, n' what tha fuck they
end up bustin aint what tha fuck they do wit ordinary hashes.
.SS "How tha fuck do I reset a \fIeach()\fP operation part-way through?"
.IX Subsection "How tha fuck do I reset a each() operation part-way through?"
(contributed by brian d foy)
.PP
Yo ass can use tha \f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR functions ta reset \f(CW\*(C`each\*(C'\fR. To
simply reset tha iterator used by \f(CW\*(C`each\*(C'\fR without bustin anythang else,
use one of dem up in void context:
.PP
.Vb 2
\&    keys %hash; # resets iterator, not a god damn thang else.
\&    joints %hash; # resets iterator, not a god damn thang else.
.Ve
.PP
See tha documentation fo' \f(CW\*(C`each\*(C'\fR up in perlfunc.
.SS "How tha fuck can I git tha unique keys from two hashes?"
.IX Subsection "How tha fuck can I git tha unique keys from two hashes?"
First you extract tha keys from tha hashes tha fuck into lists, then solve
the \*(L"removin duplicates\*(R" problem busted lyrics bout above. For example:
.PP
.Vb 5
\&    mah %seen = ();
\&    fo' mah $element (keys(%foo), keys(%bar)) {
\&        $seen{$element}++;
\&    }
\&    mah @uniq = keys %seen;
.Ve
.PP
Or mo' succinctly:
.PP
.Vb 1
\&    mah @uniq = keys %{{%foo,%bar}};
.Ve
.PP
Or if you straight-up wanna save space:
.PP
.Vb 8
\&    mah %seen = ();
\&    while (defined ($key = each %foo)) {
\&        $seen{$key}++;
\&    }
\&    while (defined ($key = each %bar)) {
\&        $seen{$key}++;
\&    }
\&    mah @uniq = keys %seen;
.Ve
.SS "How tha fuck can I store a multidimensionizzle array up in a \s-1DBM\s0 file?"
.IX Subsection "How tha fuck can I store a multidimensionizzle array up in a DBM file?"
Either stringify tha structure yo ass (no fun), or else
get tha \s-1MLDBM \s0(which uses Data::Dumper) module from \s-1CPAN\s0 n' layer
it on top of either DB_File or GDBM_File. Yo ass might also try DBM::Deep yo, but
it can be a lil' bit slow.
.SS "How tha fuck can I make mah hash remember tha order I put elements tha fuck into it?"
.IX Subsection "How tha fuck can I make mah hash remember tha order I put elements tha fuck into it?"
Use tha Tie::IxHash from \s-1CPAN.\s0
.PP
.Vb 1
\&    use Tie::IxHash;
\&
\&    tie mah %myhash, \*(AqTie::IxHash\*(Aq;
\&
\&    fo' (my $i=0; $i<20; $i++) {
\&        $myhash{$i} = 2*$i;
\&    }
\&
\&    mah @keys = keys %myhash;
\&    # @keys = (0,1,2,3,...)
.Ve
.SS "Why do passin a subroutine a undefined element up in a hash create it?"
.IX Subsection "Why do passin a subroutine a undefined element up in a hash create it?"
(contributed by brian d foy)
.PP
Is you rockin a straight-up oldschool version of Perl?
.PP
Normally, accessin a hash keyz value fo' a nonexistent key will
\&\fInot\fR create tha key.
.PP
.Vb 3
\&    mah %hash  = ();
\&    mah $value = $hash{ \*(Aqfoo\*(Aq };
\&    print "This won\*(Aqt print\en" if exists $hash{ \*(Aqfoo\*(Aq };
.Ve
.PP
Passin \f(CW$hash{ \*(Aqfoo\*(Aq }\fR ta a subroutine used ta be a special case, though.
Since you could assign directly ta \f(CW$_[0]\fR, Perl had ta be locked n loaded to
make dat assignment so it pimped tha hash key ahead of time:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print before 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        # $_[0] = \*(Aqbar\*(Aq; # create hash key up in case you do this
\&        1;
\&    }
.Ve
.PP
Since Perl 5.004, however, dis thang be a special case n' Perl
creates tha hash key only when you make tha assignment:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print, even afta 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        $_[0] = \*(Aqbar\*(Aq;
\&    }
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat if you want tha oldschool behavior (and be thinkin carefully bout that
because itz a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make dis a special case:
.PP
.Vb 1
\&    my_sub( @hash{ qw/foo/ } );
.Ve
.SS "How tha fuck can I make tha Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"
.IX Subsection "How tha fuck can I make tha Perl equivalent of a C structure/ class/hash or array of hashes or arrays?"
Usually a hash ref, like like this:
.PP
.Vb 8
\&    $record = {
\&        NAME   => "Jason",
\&        EMPNO  => 132,
\&        TITLE  => "deputy peon",
\&        AGE    => 23,
\&        SALARY => 37_000,
\&        PALS   => [ "Norbert", "Rhys", "Phineas"],
\&    };
.Ve
.PP
References is documented up in perlref n' perlreftut.
Examplez of complex data structures is given up in perldsc and
perllol. Examplez of structures n' object-oriented classes are
in perltoot.
.SS "How tha fuck can I bust a reference as a hash key?"
.IX Subsection "How tha fuck can I bust a reference as a hash key?"
(contributed by brian d foy n' Lil' Bow Wow Morrow)
.PP
Hash keys is strings, so you can't straight-up bust a reference as tha key.
When you try ta do that, perl turns tha reference tha fuck into its stringified
form (for instance, \f(CW\*(C`HASH(0xDEADBEEF)\*(C'\fR). From there you can't get
back tha reference from tha stringified form, at least without bustin
some extra work on yo' own.
.PP
Remember dat tha entry up in tha hash will still be there even if
the referenced variable  goes outta scope, n' dat it is entirely
possible fo' Perl ta subsequently allocate a gangbangin' finger-lickin' different variable at
the same address. This will mean a freshly smoked up variable might accidentally
be associated wit tha value fo' a old.
.PP
If you have Perl 5.10 or later, n' you just wanna store a value
against tha reference fo' lookup later, you can use tha core
Hash::Util::Fieldhash module. This will also handle renamin the
keys if you use multiple threadz (which causes all variablez ta be
reallocated at freshly smoked up addresses, changin they stringification), and
garbage-collectin tha entries when tha referenced variable goes out
of scope.
.PP
If you straight-up need ta be able ta git a real reference back from
each hash entry, you can use tha Tie::RefHash module, which do the
required work fo' yo thugged-out ass.
.SS "How tha fuck can I check if a key exists up in a multilevel hash?"
.IX Subsection "How tha fuck can I check if a key exists up in a multilevel hash?"
(contributed by brian d foy)
.PP
Da trick ta dis problem be avoidin accidental autovivification. I aint talkin' bout chicken n' gravy biatch. If
you wanna check three keys deep, you might nai\*:vely try this:
.PP
.Vb 4
\&    mah %hash;
\&    if( exists $hash{key1}{key2}{key3} ) {
\&        ...;
\&    }
.Ve
.PP
Even though you started wit a cold-ass lil straight-up empty hash, afta dat call to
\&\f(CW\*(C`exists\*(C'\fR you've pimped tha structure you needed ta check fo' \f(CW\*(C`key3\*(C'\fR:
.PP
.Vb 5
\&    %hash = (
\&              \*(Aqkey1\*(Aq => {
\&                          \*(Aqkey2\*(Aq => {}
\&                        }
\&            );
.Ve
.PP
Thatz autovivification. I aint talkin' bout chicken n' gravy biatch. Yo ass can git round dis up in all dem ways. The
easiest way is ta just turn it off. Da lexical \f(CW\*(C`autovivification\*(C'\fR
pragma be available on \s-1CPAN.\s0 Now you don't add ta tha hash:
.PP
.Vb 7
\&    {
\&        no autovivification;
\&        mah %hash;
\&        if( exists $hash{key1}{key2}{key3} ) {
\&            ...;
\&        }
\&    }
.Ve
.PP
Da Data::Diver module on \s-1CPAN\s0 can do it fo' you like a muthafucka. Its \f(CW\*(C`Dive\*(C'\fR
subroutine can rap  not only if tha keys exist but also git the
value:
.PP
.Vb 1
\&    use Data::Diver qw(Dive);
\&
\&    mah @exists = Dive( \e%hash, qw(key1 key2 key3) );
\&    if(  ! @exists  ) {
\&        ...; # keys do not exist
\&    }
\&    elsif(  ! defined $exists[0]  ) {
\&        ...; # keys exist but value is undef
\&    }
.Ve
.PP
Yo ass can easily do dis yo ass too by checkin each level of tha hash
before you move onto tha next level. This is essentially what
Data::Diver do fo' you:
.PP
.Vb 3
\&    if( check_hash( \e%hash, qw(key1 key2 key3) ) ) {
\&        ...;
\&    }
\&
\&    sub check_hash {
\&       my( $hash, @keys ) = @_;
\&
\&       return unless @keys;
\&
\&       foreach mah $key ( @keys ) {
\&           return unless eval { exists $hash\->{$key} };
\&           $hash = $hash\->{$key};
\&        }
\&
\&       return 1;
\&    }
.Ve
.SS "How tha fuck can I prevent addizzle of unwanted keys tha fuck into a hash?"
.IX Subsection "How tha fuck can I prevent addizzle of unwanted keys tha fuck into a hash?"
Since version 5.8.0, hashes can be \fIrestricted\fR ta a gangbangin' fixed number
of given keys. Methodz fo' bustin n' dealin wit restricted hashes
are exported by tha Hash::Util module.
.SH "Data: Misc"
.IX Header "Data: Misc"
.SS "How tha fuck do I handle binary data erectly?"
.IX Subsection "How tha fuck do I handle binary data erectly?"
Perl is binary-clean, so it can handle binary data just fine.
On Windows or \s-1DOS,\s0 however, you gotta use \f(CW\*(C`binmode\*(C'\fR fo' binary
filez ta avoid conversions fo' line endings. In general, you should
use \f(CW\*(C`binmode\*(C'\fR any time you wanna work wit binary data.
.PP
Also peep \*(L"binmode\*(R" up in perlfunc or perlopentut.
.PP
If you concerned bout 8\-bit textual data then peep perllocale.
If you wanna deal wit multibyte characters, however, there are
some gotchas. Right back up in yo muthafuckin ass. See tha section on Regular Expressions.
.SS "How tha fuck do I determine whether a scalar be a number/whole/integer/float?"
.IX Subsection "How tha fuck do I determine whether a scalar be a number/whole/integer/float?"
Assumin dat you couldn't give a fuckin shiznit bout \s-1IEEE\s0 notations like \*(L"NaN\*(R" or
\&\*(L"Infinity\*(R", you probably just wanna bust a regular expression:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given( $number ) {
\&        when( /\eD/ )
\&            { say "\ethas nondigits"; continue }
\&        when( /^\ed+\ez/ )
\&            { say "\etis a whole number"; continue }
\&        when( /^\-?\ed+\ez/ )
\&            { say "\etis a integer"; continue }
\&        when( /^[+\-]?\ed+\ez/ )
\&            { say "\etis a +/\- integer"; continue }
\&        when( /^\-?(?:\ed+\e.?|\e.\ed)\ed*\ez/ )
\&            { say "\etis a real number"; continue }
\&        when( /^[+\-]?(?=\e.?\ed)\ed*\e.?\ed*(?:e[+\-]?\ed+)?\ez/i)
\&            { say "\etis a C float" }
\&    }
.Ve
.PP
There is also some commonly used modulez fo' tha task.
Scalar::Util (distributed wit 5.8) serves up access ta perl's
internal function \f(CW\*(C`looks_like_number\*(C'\fR fo' determinin whether a
variable be lookin like a number n' shit. Data::Types exports functions that
validate data types rockin both tha above n' other regular
expressions. Thirdly, there is Regexp::Common which has regular
expressions ta match various typez of numbers. Those three modulez are
available from tha \s-1CPAN.\s0
.PP
If you on a \s-1POSIX\s0 system, Perl supports tha \f(CW\*(C`POSIX::strtod\*(C'\fR
function fo' convertin strings ta doublez (and also \f(CW\*(C`POSIX::strtol\*(C'\fR
for longs). Its semantics is somewhat cumbersome, so herez a
\&\f(CW\*(C`getnum\*(C'\fR wrapper function fo' mo' convenient access. This function
takes a strang n' returns tha number it found, or \f(CW\*(C`undef\*(C'\fR fo' input
that aint a C float. Da \f(CW\*(C`is_numeric\*(C'\fR function be a gangbangin' front end to
\&\f(CW\*(C`getnum\*(C'\fR if you just wanna say, \*(L"Is dis a gangbangin' float?\*(R"
.PP
.Vb 10
\&    sub getnum {
\&        use POSIX qw(strtod);
\&        mah $str = shift;
\&        $str =~ s/^\es+//;
\&        $str =~ s/\es+$//;
\&        $! = 0;
\&        my($num, $unparsed) = strtod($str);
\&        if (($str eq \*(Aq\*(Aq) || ($unparsed != 0) || $!) {
\&                return undef;
\&        }
\&        else {
\&            return $num;
\&        }
\&    }
\&
\&    sub is_numeric { defined getnum($_[0]) }
.Ve
.PP
Or you could check up tha String::Scanf module on tha \s-1CPAN\s0
instead.
.SS "How tha fuck do I keep persistent data across program calls?"
.IX Subsection "How tha fuck do I keep persistent data across program calls?"
For some specific applications, you can use one of tha \s-1DBM\s0 modules.
See AnyDBM_File. Mo' generically, you should consult tha FreezeThaw
or Storable modulez from \s-1CPAN.\s0 Startin from Perl 5.8, Storable is part
of tha standard distribution. I aint talkin' bout chicken n' gravy biatch yo. Herez one example rockin Storablez \f(CW\*(C`store\*(C'\fR
and \f(CW\*(C`retrieve\*(C'\fR functions:
.PP
.Vb 2
\&    use Storable;
\&    store(\e%hash, "filename");
\&
\&    # lata on...
\&    $href = retrieve("filename");        # by ref
\&    %hash = %{ retrieve("filename") };   # direct ta hash
.Ve
.SS "How tha fuck do I print up or copy a recursive data structure?"
.IX Subsection "How tha fuck do I print up or copy a recursive data structure?"
Da Data::Dumper module on \s-1CPAN \s0(or tha 5.005 release of Perl) is pimped out
for printin up data structures. Da Storable module on \s-1CPAN \s0(or the
5.8 release of Perl), serves up a gangbangin' function called \f(CW\*(C`dclone\*(C'\fR dat recursively
copies its argument.
.PP
.Vb 2
\&    use Storable qw(dclone);
\&    $r2 = dclone($r1);
.Ve
.PP
Where \f(CW$r1\fR can be a reference ta any kind of data structure you'd like.
It is ghon be deeply copied. Y'all KNOW dat shit, muthafucka! Because \f(CW\*(C`dclone\*(C'\fR takes n' returns references,
you'd gotta add extra punctuation if you had a hash of arrays that
you wanted ta copy.
.PP
.Vb 1
\&    %newhash = %{ dclone(\e%oldhash) };
.Ve
.SS "How tha fuck do I define methodz fo' every last muthafuckin class/object?"
.IX Subsection "How tha fuck do I define methodz fo' every last muthafuckin class/object?"
(contributed by Lil' Bow Wow Morrow)
.PP
Yo ass can use tha \f(CW\*(C`UNIVERSAL\*(C'\fR class (see \s-1UNIVERSAL\s0). But fuck dat shiznit yo, tha word on tha street is dat please
be straight-up careful ta consider tha consequencez of bustin this: adding
methodz ta every last muthafuckin object is straight-up likely ta have unintended
consequences. If possible, it would be betta ta have all yo' object
inherit from some common base class, or ta use a object system like
Moose dat supports roles.
.SS "How tha fuck do I verify a cold-ass lil credit card checksum?"
.IX Subsection "How tha fuck do I verify a cold-ass lil credit card checksum?"
Git tha Business::CreditCard module from \s-1CPAN.\s0
.SS "How tha fuck do I pack arrayz of doublez or floats fo' \s-1XS\s0 code?"
.IX Subsection "How tha fuck do I pack arrayz of doublez or floats fo' XS code?"
Da arrays.h/arrays.c code up in tha \s-1PGPLOT\s0 module on \s-1CPAN\s0 do just all dis bullshit.
If you bustin a shitload of float or double processing, consider using
the \s-1PDL\s0 module from \s-1CPAN\s0 instead\*(--it make number-crunchin easy as fuck .
.PP
See <http://search.cpan.org/dist/PGPLOT> fo' tha code.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in dis file
are hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' fun
or fo' profit as you peep fit fo' realz. A simple comment up in tha code giving
credit would be courteous but aint required.
