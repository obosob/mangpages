.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLMROAPI 1"
.TH PERLMROAPI 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlmroapi \- Perl method resolution plugin intercourse
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Az of Perl 5.10.1 there be a freshly smoked up intercourse fo' pluggin n' rockin method
resolution ordaz other than tha default (linear depth first search).
Da C3 method resolution order added up in 5.10.0 has been re-implemented as
a plugin, without changin its Perl-space intercourse.
.PP
Each plugin should regista itself by providing
the followin structure
.PP
.Vb 7
\&    struct mro_alg {
\&        AV *(*resolve)(pTHX_ HV *stash, U32 level);
\&        const char *name;
\&        U16 length;
\&        U16 kflags;
\&        U32 hash;
\&    };
.Ve
.PP
and callin \f(CW\*(C`Perl_mro_register\*(C'\fR:
.PP
.Vb 1
\&    Perl_mro_register(aTHX_ &my_mro_alg);
.Ve
.IP "resolve" 4
.IX Item "resolve"
Pointa ta tha linearisation function, busted lyrics bout below.
.IP "name" 4
.IX Item "name"
Name of tha \s-1MRO,\s0 either up in \s-1ISO\-8859\-1\s0 or \s-1UTF\-8.\s0
.IP "length" 4
.IX Item "length"
Length of tha name.
.IP "kflags" 4
.IX Item "kflags"
If tha name is given up in \s-1UTF\-8,\s0 set dis ta \f(CW\*(C`HVhek_UTF8\*(C'\fR. Da value is passed
direct as tha parameta \fIkflags\fR ta \f(CW\*(C`hv_common()\*(C'\fR.
.IP "hash" 4
.IX Item "hash"
A precomputed hash value fo' tha \s-1MRO\s0z name, or 0.
.SH "Callbacks"
.IX Header "Callbacks"
Da \f(CW\*(C`resolve\*(C'\fR function is called ta generate a linearised \s-1ISA\s0 fo' the
given stash, rockin dis \s-1MRO.\s0 It be called wit a pointa ta tha stash, and
a \fIlevel\fR of 0. Da core always sets \fIlevel\fR ta 0 when it calls your
function \- tha parameta is provided ta allow yo' implementation ta track
depth if it need ta recurse.
.PP
Da function should return a reference ta a array containin tha parent
classes up in order n' shit. Da namez of tha classes should be tha result of calling
\&\f(CW\*(C`HvENAME()\*(C'\fR on tha stash. In dem cases where \f(CW\*(C`HvENAME()\*(C'\fR returns null,
\&\f(CW\*(C`HvNAME()\*(C'\fR should be used instead.
.PP
Da calla is responsible fo' incrementin tha reference count of tha array
returned if it wants ta keep tha structure yo. Hence, if you have pimped a
temporary value dat you keep no pointa to, \f(CW\*(C`sv_2mortal()\*(C'\fR ta ensure that
it is disposed of erectly. If you have cached yo' return value, then
return a pointa ta it without changin tha reference count.
.SH "Caching"
.IX Header "Caching"
Computin MROs can be expensive. Da implementation serves up a cold-ass lil cache, in
which you can store a single \f(CW\*(C`SV *\*(C'\fR, or anythang dat can be cast to
\&\f(CW\*(C`SV *\*(C'\fR, like fuckin \f(CW\*(C`AV *\*(C'\fR. To read yo' private value, use tha macro
\&\f(CW\*(C`MRO_GET_PRIVATE_DATA()\*(C'\fR, passin it tha \f(CW\*(C`mro_meta\*(C'\fR structure from the
stash, n' a pointa ta yo' \f(CW\*(C`mro_alg\*(C'\fR structure:
.PP
.Vb 2
\&    meta = HvMROMETA(stash);
\&    private_sv = MRO_GET_PRIVATE_DATA(meta, &my_mro_alg);
.Ve
.PP
To set yo' private value, call \f(CW\*(C`Perl_mro_set_private_data()\*(C'\fR:
.PP
.Vb 1
\&    Perl_mro_set_private_data(aTHX_ meta, &c3_alg, private_sv);
.Ve
.PP
Da private data cache will take ballershizzle of a reference ta private_sv,
much tha same way dat \f(CW\*(C`hv_store()\*(C'\fR takes ballershizzle of a reference ta the
value dat you pass dat shit.
.SH "Examples"
.IX Header "Examples"
For examplez of \s-1MRO\s0 implementations, peep \f(CW\*(C`S_mro_get_linear_isa_c3()\*(C'\fR
and tha \f(CW\*(C`BOOT:\*(C'\fR section of \fImro/mro.xs\fR, n' \f(CW\*(C`S_mro_get_linear_isa_dfs()\*(C'\fR
in \fImro.c\fR
.SH "AUTHORS"
.IX Header "AUTHORS"
Da implementation of tha C3 \s-1MRO\s0 n' switchable MROs within tha perl core was
written by Brandon L Black. Nicholas Clark pimped tha pluggable intercourse, 
refactored Brandonz implementation ta work wit it, n' freestyled dis document.
