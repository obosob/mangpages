.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLIPC 1"
.TH PERLIPC 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlipc \- Perl interprocess communication (signals, fifos, pipes, safe subprocesses, sockets, n' semaphores)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da basic \s-1IPC\s0 facilitizzlez of Perl is built outta tha phat oldschool Unix
signals, named pipes, pipe opens, tha Berkeley socket routines, n' SysV
\&\s-1IPC\s0 calls.  Each is used up in slightly different thangs.
.SH "Signals"
.IX Header "Signals"
Perl uses a simple signal handlin model: tha \f(CW%SIG\fR hash gotz nuff names
or referencez of user-installed signal handlezs.  These handlezs will
be called wit a argument which is tha name of tha signal that
triggered dat shit.  A signal may be generated intentionally from a
particular keyboard sequence like control-C or control-Z, busted ta you
from another process, or triggered automatically by tha kernel when
special events transpire, like a cold-ass lil lil pimp process exiting, yo' own process
runnin outta stack space, or hittin a process file-size limit.
.PP
For example, ta trap a interrupt signal, set up a handlez like this:
.PP
.Vb 1
\&    our $shucks;
\&
\&    sub catch_zap {
\&        mah $signame = shift;
\&        $shucks++;
\&        take a thugged-out dirtnap "Some Muthafucka busted mah crazy ass a SIG$signame";
\&    }
\&    $SIG{INT} = _\|_PACKAGE_\|_ . "::catch_zap";  
\&    $SIG{INT} = \e&catch_zap;  # dopest game
.Ve
.PP
Prior ta Perl 5.8.0 dat shiznit was necessary ta do as lil as you possibly
could up in yo' handlez; notice how tha fuck all our phat asses do is set a global variable
and then raise a exception. I aint talkin' bout chicken n' gravy biatch.  Thatz cuz on most systems,
libraries is not re-entrant; particularly, memory allocation n' I/O
routines is not.  That meant dat bustin nearly \fIanything\fR up in your
handlez could up in theory trigger a memory fault n' subsequent core
dump \- peep \*(L"Deferred Signals (Safe Signals)\*(R" below.
.PP
Da namez of tha signals is tha ones listed up by \f(CW\*(C`kill \-l\*(C'\fR on your
system, or you can retrieve dem rockin tha \s-1CPAN\s0 module IPC::Signal.
.PP
Yo ass may also chizzle ta assign tha strings \f(CW"IGNORE"\fR or \f(CW"DEFAULT"\fR as
the handlez, up in which case Perl will try ta discard tha signal or do the
default thang.
.PP
On most Unix platforms, tha \f(CW\*(C`CHLD\*(C'\fR (sometimes also known as \f(CW\*(C`CLD\*(C'\fR) signal
has special behavior wit respect ta a value of \f(CW"IGNORE"\fR.
Settin \f(CW$SIG{CHLD}\fR ta \f(CW"IGNORE"\fR on such a platform has tha effect of
not bustin zombie processes when tha parent process fails ta \f(CW\*(C`wait()\*(C'\fR
on its lil pimp processes (i.e., lil pimp processes is automatically reaped).
Callin \f(CW\*(C`wait()\*(C'\fR wit \f(CW$SIG{CHLD}\fR set ta \f(CW"IGNORE"\fR probably returns
\&\f(CW\*(C`\-1\*(C'\fR on such platforms.
.PP
Some signals can be neither trapped nor ignored, like fuckin tha \s-1KILL\s0 n' \s-1STOP
\&\s0(but not tha \s-1TSTP\s0) signals. Note dat ignorin signals make dem disappear.
If you only want dem blocked temporarily without dem gettin lost you'll
have ta use \s-1POSIX\s0' sigprocmask.
.PP
Sendin a signal ta a wack process \s-1ID\s0 means dat you bust tha signal
to tha entire Unix process group.  This code sendz a hang-up signal ta all
processes up in tha current process group, n' also sets \f(CW$SIG\fR{\s-1HUP\s0} ta \f(CW"IGNORE"\fR 
so it don't bust a cap up in itself:
.PP
.Vb 6
\&    # block scope fo' local
\&    {
\&        local $SIG{HUP} = "IGNORE";
\&        bust a cap up in HUP => \-$$;
\&        # snazzy freestylin of: kill("HUP", \-$$)
\&    }
.Ve
.PP
Another bangin-ass signal ta bust is signal number zero.  This don't
actually affect a cold-ass lil lil pimp process yo, but instead checks whether itz kickin it
or has chizzled its UIDs.
.PP
.Vb 3
\&    unless (kill 0 => $kid_pid) {
\&        warn "suttin' wicked happened ta $kid_pid";
\&    }
.Ve
.PP
Signal number zero may fail cuz you lack permission ta bust the
signal when pimped up at a process whose real or saved \s-1UID\s0 is not
identical ta tha real or effectizzle \s-1UID\s0 of tha bustin  process, even
though tha process is kickin dat shit, yo.  Yo ass may be able ta determine tha cause of
failure rockin \f(CW$!\fR or \f(CW\*(C`%!\*(C'\fR.
.PP
.Vb 3
\&    unless (kill(0 => $pid) || $!{EPERM}) {
\&        warn "$pid looks dead";
\&    }
.Ve
.PP
Yo ass might also wanna employ anonymous functions fo' simple signal
handlezs:
.PP
.Vb 1
\&    $SIG{INT} = sub { take a thugged-out dirtnap "\enOutta here!\en" };
.Ve
.PP
\&\s-1SIGCHLD\s0 handlezs require some special care.  If a second lil pimp dies
while up in tha signal handlez caused by tha straight-up original gangsta dirtnap, we won't get
another signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. So must loop here else we will leave tha unreaped child
as a zombie fo' realz. And tha next time two lil pimps take a thugged-out dirtnap we git another zombie.
And so on.
.PP
.Vb 7
\&    use POSIX ":sys_wait_h";
\&    $SIG{CHLD} = sub {
\&        while ((my $child = waitpid(\-1, WNOHANG)) > 0) {
\&            $Kid_Status{$child} = $?;
\&        }
\&    };
\&    # do suttin' dat forks...
.Ve
.PP
Be careful: \fIqx()\fR, \fIsystem()\fR, n' some modulez fo' callin external commands
do a \fIfork()\fR, then \fIwait()\fR fo' tha result. Thus, yo' signal handlez
will be called. Y'all KNOW dat shit, muthafucka! Because \fIwait()\fR was already called by \fIsystem()\fR or \fIqx()\fR,
the \fIwait()\fR up in tha signal handlez will peep no mo' zombies n' will
therefore block.
.PP
Da dopest way ta prevent dis issue is ta use \fIwaitpid()\fR, as up in tha following
example:
.PP
.Vb 1
\&    use POSIX ":sys_wait_h"; # fo' nonblockin read
\&
\&    mah %children;
\&
\&    $SIG{CHLD} = sub {
\&        # don\*(Aqt chizzle $! n' $, biatch? outside handlez
\&        local ($!, $?);
\&        mah $pid = waitpid(\-1, WNOHANG);
\&        return if $pid == \-1;
\&        return unless defined $children{$pid};
\&        delete $children{$pid};
\&        cleanup_child($pid, $?);
\&    };
\&
\&    while (1) {
\&        mah $pid = fork();
\&        take a thugged-out dirtnap "cannot fork" unless defined $pid;
\&        if ($pid == 0) {
\&            # ...
\&            exit 0;
\&        } else {
\&            $children{$pid}=1;
\&            # ...
\&            system($command);
\&            # ...
\&       }
\&    }
.Ve
.PP
Signal handlin be also used fo' timeouts up in Unix.  While safely
protected within a \f(CW\*(C`eval{}\*(C'\fR block, you set a signal handlez ta trap
alarm signals n' then schedule ta have one served up ta you up in some
number of seconds.  Then try yo' blockin operation, clearin tha alarm
when itz done but not before you've exited yo' \f(CW\*(C`eval{}\*(C'\fR block.  If it
goes off, you gonna use \fIdie()\fR ta jump outta tha block.
.PP
Herez a example:
.PP
.Vb 9
\&    mah $ALARM_EXCEPTION = "alarm clock restart";
\&    eval {
\&        local $SIG{ALRM} = sub { take a thugged-out dirtnap $ALARM_EXCEPTION };
\&        alarm 10;
\&        flock(FH, 2)    # blockin write lock
\&                        || take a thugged-out dirtnap "cannot flock: $!";
\&        alarm 0;
\&    };
\&    if ($@ && $@ !~ quotemeta($ALARM_EXCEPTION)) { take a thugged-out dirtnap }
.Ve
.PP
If tha operation bein timed up is \fIsystem()\fR or \fIqx()\fR, dis technique
is liable ta generate zombies. Put ya muthafuckin choppers up if ya feel dis!    If dis mattas ta you, you'll
need ta do yo' own \fIfork()\fR n' \fIexec()\fR, n' bust a cap up in tha errant lil pimp process.
.PP
For mo' complex signal handling, you might peep tha standard \s-1POSIX\s0
module.  Lamentably, dis be almost entirely undocumented yo, but
the \fIt/lib/posix.t\fR file from tha Perl source distribution has some
examplez up in dat shit.
.SS "Handlin tha \s-1SIGHUP\s0 Signal up in Daemons"
.IX Subsection "Handlin tha SIGHUP Signal up in Daemons"
A process dat probably starts when tha system boots n' shuts down
when tha system is shut down is called a thugged-out daemon (Disk And Execution
MONitor). If a thugged-out daemon process has a cold-ass lil configuration file which is
modified afta tha process has been started, there should be a way to
tell dat process ta reread its configuration file without stopping
the process. Many daemons provide dis mechanizzle rockin a \f(CW\*(C`SIGHUP\*(C'\fR
signal handlez n' shit. When you wanna tell tha daemon ta reread tha file,
simply bust it tha \f(CW\*(C`SIGHUP\*(C'\fR signal.
.PP
Da followin example implements a simple daemon, which restarts
itself every last muthafuckin time tha \f(CW\*(C`SIGHUP\*(C'\fR signal is received. Y'all KNOW dat shit, muthafucka! Da actual code is
located up in tha subroutine \f(CW\*(C`code()\*(C'\fR, which just prints some debugging
info ta show dat it works; it should be replaced wit tha real code.
.PP
.Vb 1
\&  #!/usr/bin/perl \-w
\&
\&  use POSIX ();
\&  use FindBin ();
\&  use File::Basename ();
\&  use File::Spec::Functions;
\&
\&  $| = 1;
\&
\&  # make tha daemon cross\-platform, so exec always calls tha script
\&  # itself wit tha right path, no matta how tha fuck tha script was invoked.
\&  mah $script = File::Basename::basename($0);
\&  mah $SELF  = catfile($FindBin::Bin, $script);
\&
\&  # POSIX unmasks tha sigprocmask properly
\&  $SIG{HUP} = sub {
\&      print "got SIGHUP\en";
\&      exec($SELF, @ARGV)        || take a thugged-out dirtnap "$0: couldn\*(Aqt restart: $!";
\&  };
\&
\&  code();
\&
\&  sub code {
\&      print "PID: $$\en";
\&      print "ARGV: @ARGV\en";
\&      mah $count = 0;
\&      while (++$count) {
\&          chill 2;
\&          print "$count\en";
\&      }
\&  }
.Ve
.SS "Deferred Signals (Safe Signals)"
.IX Subsection "Deferred Signals (Safe Signals)"
Before Perl 5.8.0, installin Perl code ta deal wit signals exposed you to
danger from two thangs.  First, few system library functions are
re-entrant.  If tha signal interrupts while Perl is executin one function
(like \fImalloc\fR\|(3) or \fIprintf\fR\|(3)), n' yo' signal handlez then calls tha same
function again, you could git unpredictable behavior\*(--often, a cold-ass lil core dump.
Second, Perl aint itself re-entrant all up in tha lowest levels.  If tha signal
interrupts Perl while Perl is changin its own internal data structures,
similarly unpredictable behavior may result.
.PP
There was two thangs you could do, knowin this: be paranoid or be
pragmatic.  Da paranoid approach was ta do as lil as possible up in your
signal handlez n' shit.  Set a existin integer variable dat already has a
value, n' return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This don't help you if you up in a slow system call,
which will just restart.  That means you gotta \f(CW\*(C`die\*(C'\fR ta \fIlongjmp\fR\|(3) out
of tha handlez n' shit.  Even dis be a lil cavalier fo' tha legit paranoiac,
who avoidz \f(CW\*(C`die\*(C'\fR up in a handlez cuz tha system \fIis\fR up ta git yo thugged-out ass.
Da pragmatic approach was ta say \*(L"I know tha risks yo, but prefer the
convenience\*(R", n' ta do anythang you wanted up in yo' signal handlez,
and be prepared ta clean up core dumps now n' again.
.PP
Perl 5.8.0 n' lata avoid these problems by \*(L"deferring\*(R" signals.  That is,
when tha signal is served up ta tha process by tha system (to tha C code
that implements Perl) a gangbangin' flag is set, n' tha handlez returns immediately.
Then at strategic \*(L"safe\*(R" points up in tha Perl interpreta (e.g. when it is
about ta execute a freshly smoked up opcode) tha flags is checked n' tha Perl level
handlez from \f(CW%SIG\fR is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \*(L"deferred\*(R" scheme allows much more
flexibilitizzle up in tha codin of signal handlezs as we know tha Perl
interpreta is up in a safe state, n' dat we is not up in a system library
function when tha handlez is called. Y'all KNOW dat shit, muthafucka!  However tha implementation do
differ from previous Perls up in tha followin ways:
.IP "Long-runnin opcodes" 4
.IX Item "Long-runnin opcodes"
As tha Perl interpreta looks at signal flags only when it be about
to execute a freshly smoked up opcode, a signal dat arrives durin a long-running
opcode (e.g. a regular expression operation on a straight-up big-ass string) will
not be peeped until tha current opcode completes.
.Sp
If a signal of any given type fires multiple times durin a opcode 
(like fuckin from a gangbangin' fine-grained timer), tha handlez fo' dat signal will
be called only once, afta tha opcode completes; all other
instances is ghon be discarded. Y'all KNOW dat shit, muthafucka!  Furthermore, if yo' systemz signal queue
gets flooded ta tha point dat there be signals dat done been raised
but not yet caught (and thus not deferred) all up in tha time a opcode
completes, dem signals may well be caught n' deferred during
subsequent opcodes, wit sometimes surprisin thangs up in dis biatch.  For example, you
may peep alarms served up even afta callin \f(CWalarm(0)\fR as tha latter
stops tha raisin of alarms but do not quit tha delivery of alarms
raised but not yet caught.  Do not depend on tha behaviors busted lyrics bout in
this paragraph as they is side effectz of tha current implementation and
may chizzle up in future versionz of Perl.
.IP "Interruptin \s-1IO\s0" 4
.IX Item "Interruptin IO"
When a signal is served up (e.g., \s-1SIGINT\s0 from a cold-ass lil control-C) tha operating
system breaks tha fuck into \s-1IO\s0 operations like \fIread\fR(2), which is used to
implement Perlz \fIreadline()\fR function, tha \f(CW\*(C`<>\*(C'\fR operator. Shiiit, dis aint no joke. On older
Perls tha handlez was called immediately (and as \f(CW\*(C`read\*(C'\fR aint \*(L"unsafe\*(R",
this hit dat shiznit well). With tha \*(L"deferred\*(R" scheme tha handlez is \fInot\fR called
immediately, n' if Perl is rockin tha systemz \f(CW\*(C`stdio\*(C'\fR library that
library may restart tha \f(CW\*(C`read\*(C'\fR without returnin ta Perl ta give it a
chizzle ta booty-call tha \f(CW%SIG\fR handlez n' shit. If dis happens on yo' system the
solution is ta use tha \f(CW\*(C`:perlio\*(C'\fR layer ta do IO\*(--at least on dem handles
that you wanna be able ta break tha fuck into wit signals. (Da \f(CW\*(C`:perlio\*(C'\fR layer
checks tha signal flags n' calls \f(CW%SIG\fR handlezs before resumin \s-1IO\s0
operation.)
.Sp
Da default up in Perl 5.8.0 n' lata is ta automatically use
the \f(CW\*(C`:perlio\*(C'\fR layer.
.Sp
Note dat it aint advisable ta access a gangbangin' file handle within a signal
handlez where dat signal has interrupted a I/O operation on dat same
handle. While perl will at least try hard not ta crash, there be no
guaranteez of data integrity; fo' example, some data might git dropped or
written twice.
.Sp
Some networkin library functions like \fIgethostbyname()\fR is known ta have
their own implementationz of timeouts which may conflict wit your
timeouts, n' you can put dat on yo' toast.  If you have problems wit such functions, try rockin tha \s-1POSIX\s0
\&\fIsigaction()\fR function, which bypasses Perl safe signals.  Be warned that
this do subject you ta possible memory corruption, as busted lyrics bout above.
.Sp
Instead of settin \f(CW$SIG{ALRM}\fR:
.Sp
.Vb 1
\&   local $SIG{ALRM} = sub { take a thugged-out dirtnap "alarm" };
.Ve
.Sp
try suttin' like tha following:
.Sp
.Vb 3
\&  use POSIX qw(SIGALRM);
\&  POSIX::sigaction(SIGALRM, POSIX::SigAction\->new(sub { take a thugged-out dirtnap "alarm" }))
\&          || take a thugged-out dirtnap "Error settin SIGALRM handlez: $!\en";
.Ve
.Sp
Another way ta disable tha safe signal behavior locally is ta use
the \f(CW\*(C`Perl::Unsafe::Signals\*(C'\fR module from \s-1CPAN,\s0 which affects
all signals.
.IP "Restartable system calls" 4
.IX Item "Restartable system calls"
On systems dat supported it, olda versionz of Perl used the
\&\s-1SA_RESTART\s0 flag when installin \f(CW%SIG\fR handlezs.  This meant that
restartable system calls would continue rather than returnin when
a signal arrived. Y'all KNOW dat shit, muthafucka!  In order ta serve up deferred signals promptly,
Perl 5.8.0 n' lata do \fInot\fR use \s-1SA_RESTART. \s0 Consequently, 
restartable system calls can fail (with $! set ta \f(CW\*(C`EINTR\*(C'\fR) up in places
where they previously would have succeeded.
.Sp
Da default \f(CW\*(C`:perlio\*(C'\fR layer retries \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`write\*(C'\fR
and \f(CW\*(C`close\*(C'\fR as busted lyrics bout above; interrupted \f(CW\*(C`wait\*(C'\fR n' 
\&\f(CW\*(C`waitpid\*(C'\fR calls will always be retried.
.ie n .IP "Signals as ""faults""" 4
.el .IP "Signals as ``faults''" 4
.IX Item "Signals as faults"
Certain signals like \s-1SEGV, ILL,\s0 n' \s-1BUS\s0 is generated by virtual memory
addressin errors n' similar \*(L"faults\*(R". These is normally fatal: there is
lil a Perl-level handlez can do wit em.  So Perl delivers them
immediately rather than attemptin ta defer em.
.IP "Signals triggered by operatin system state" 4
.IX Item "Signals triggered by operatin system state"
On some operatin systems certain signal handlezs is supposed ta \*(L"do
something\*(R" before returning. One example can be \s-1CHLD\s0 or \s-1CLD,\s0 which
indicates a cold-ass lil lil pimp process has completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. On some operatin systems the
signal handlez is sposed ta fuckin \f(CW\*(C`wait\*(C'\fR fo' tha completed child
process. On such systems tha deferred signal scheme aint gonna work for
those signals: it do not do tha \f(CW\*(C`wait\*(C'\fR fo' realz. Again tha failure will
look like a loop as tha operatin system will reissue tha signal cuz
there is completed lil pimp processes dat aint yet been \f(CW\*(C`wait\*(C'\fRed for.
.PP
If you want tha oldschool signal behavior back despite possible
memory corruption, set tha environment variable \f(CW\*(C`PERL_SIGNALS\*(C'\fR to
\&\f(CW"unsafe"\fR.  This feature first rocked up in Perl 5.8.1.
.SH "Named Pipes"
.IX Header "Named Pipes"
A named pipe (often referred ta as a \s-1FIFO\s0) be a oldschool Unix \s-1IPC\s0
mechanizzle fo' processes communicatin on tha same machine.  It works
just like regular anonymous pipes, except dat the
processes rendezvous rockin a gangbangin' filename n' need not be related.
.PP
To create a named pipe, use tha \f(CW\*(C`POSIX::mkfifo()\*(C'\fR function.
.PP
.Vb 2
\&    use POSIX qw(mkfifo);
\&    mkfifo($path, 0700)     ||  take a thugged-out dirtnap "mkfifo $path failed: $!";
.Ve
.PP
Yo ass can also use tha Unix command \fImknod\fR\|(1), or on some
systems, \fImkfifo\fR\|(1).  These may not be up in yo' aiiight path, though.
.PP
.Vb 8
\&    # system return val is backwards, so && not ||
\&    #
\&    $ENV{PATH} .= ":/etc:/usr/etc";
\&    if  (      system("mknod",  $path, "p")
\&            && system("mkfifo", $path) )
\&    {
\&        take a thugged-out dirtnap "mk{nod,fifo} $path failed";
\&    }
.Ve
.PP
A fifo is convenient when you wanna connect a process ta a unrelated
one.  When you open a gangbangin' fifo, tha program will block until there be a something
on tha other end.
.PP
For example, letz say you'd like ta have yo' \fI.signature\fR file be a
named pipe dat has a Perl program on tha other end yo, but it ain't no stoppin cause I be still poppin'.  Now every last muthafuckin time any
program (like a mailer, shizzle reader, finger program, etc.) tries ta read
from dat file, tha readin program will read tha freshly smoked up signature from your
program.  We bout ta use tha pipe-checkin file-test operator, \fB\-p\fR, ta find
out whether mah playas (or anything) has accidentally removed our fifo.
.PP
.Vb 2
\&    chdir();    # bounce back ta tha doggy den
\&    mah $FIFO = ".signature";
\&
\&    while (1) {
\&        unless (\-p $FIFO) {
\&            unlink $FIFO;   # discard any failure, will catch later
\&            require POSIX;  # delayed loadin of heavy module
\&            POSIX::mkfifo($FIFO, 0700)
\&                                || take a thugged-out dirtnap "can\*(Aqt mkfifo $FIFO: $!";
\&        }
\&
\&        # next line blocks till there\*(Aqs a reader
\&        open (FIFO, "> $FIFO")  || take a thugged-out dirtnap "can\*(Aqt open $FIFO: $!";
\&        print FIFO "Jizzy Smizzle (smith\e@host.org)\en", \`fortune \-s\`;
\&        close(FIFO)             || take a thugged-out dirtnap "can\*(Aqt close $FIFO: $!";
\&        chill 2;                # ta avoid dup signals
\&    }
.Ve
.SH "Usin \fIopen()\fP fo' IPC"
.IX Header "Usin open() fo' IPC"
Perlz basic \fIopen()\fR statement can also be used fo' unidirectional
interprocess communication by either appendin or prependin a pipe
symbol ta tha second argument ta \fIopen()\fR.  Herez how tha fuck ta start
suttin' up in a cold-ass lil lil pimp process you intend ta write to:
.PP
.Vb 5
\&    open(SPOOLER, "| pussaaaaay \-v | lpr \-h 2>/dev/null")
\&                        || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&    local $SIG{PIPE} = sub { take a thugged-out dirtnap "spoola pipe broke" };
\&    print SPOOLER "stuff\en";
\&    close SPOOLER       || take a thugged-out dirtnap "bad spool: $! $?";
.Ve
.PP
And herez how tha fuck ta start up a cold-ass lil lil pimp process you intend ta read from:
.PP
.Vb 7
\&    open(STATUS, "netstat \-an 2>&1 |")
\&                        || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&    while (<STATUS>) {
\&        next if /^(tcp|udp)/;
\&        print;
\&    }
\&    close STATUS        || take a thugged-out dirtnap "bad netstat: $! $?";
.Ve
.PP
If one can be shizzle dat a particular program be a Perl script expecting
filenames up in \f(CW@ARGV\fR, tha smart-ass programmer can write suttin' like this:
.PP
.Vb 1
\&    % program f1 "cmd1|" \- f2 "cmd2|" f3 < tmpfile
.Ve
.PP
and no matta which sort of shell itz called from, tha Perl program will
read from tha file \fIf1\fR, tha process \fIcmd1\fR, standard input (\fItmpfile\fR
in dis case), tha \fIf2\fR file, tha \fIcmd2\fR command, n' finally tha \fIf3\fR
file.  Pretty nifty, eh?
.PP
Yo ass might notice dat you could use backticks fo' much the
same effect as openin a pipe fo' reading:
.PP
.Vb 2
\&    print grep { !/^(tcp|udp)/ } \`netstat \-an 2>&1\`;
\&    take a thugged-out dirtnap "bad netstatus ($?)" if $?;
.Ve
.PP
While dis is legit on tha surface, itz much mo' efficient ta process the
file one line or record at a time cuz then you don't gotta read the
whole thang tha fuck into memory at once.  It also gives you finer control of the
whole process, lettin you bust a cap up in off tha lil pimp process early if you'd like.
.PP
Be careful ta check tha return joints from both \fIopen()\fR n' \fIclose()\fR.  If
yo ass is \fIwriting\fR ta a pipe, you should also trap \s-1SIGPIPE. \s0 Otherwise,
think of what tha fuck happens when you start up a pipe ta a cold-ass lil command dat don't
exist: tha \fIopen()\fR will up in all likelihood succeed (it only reflects the
\&\fIfork()\fRz success) yo, but then yo' output will fail\*(--spectacularly.  Perl
can't know whether tha command worked, cuz yo' command be actually
runnin up in a separate process whose \fIexec()\fR might have failed. Y'all KNOW dat shit, muthafucka!  Therefore,
while readaz of bogus commandz return just a quick \s-1EOF,\s0 writers
to bogus commandz will git hit wit a signal, which they'd dopest be prepared
to handle.  Consider:
.PP
.Vb 4
\&    open(FH, "|bogus")      || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&    print FH "bang\en";      #  neither necessary nor sufficient 
\&                            #  ta check print retval!
\&    close(FH)               || take a thugged-out dirtnap "can\*(Aqt close: $!";
.Ve
.PP
Da reason fo' not checkin tha return value from \fIprint()\fR is cuz of
pipe buffering; physical writes is delayed. Y'all KNOW dat shit, muthafucka!  That won't blow up until the
close, n' it will blow up wit a \s-1SIGPIPE. \s0 To catch it, you could use
this:
.PP
.Vb 4
\&    $SIG{PIPE} = "IGNORE";
\&    open(FH, "|bogus")  || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&    print FH "bang\en";
\&    close(FH)           || take a thugged-out dirtnap "can\*(Aqt close: status=$?";
.Ve
.SS "Filehandles"
.IX Subsection "Filehandles"
Both tha main process n' any lil pimp processes it forks share tha same
\&\s-1STDIN, STDOUT,\s0 n' \s-1STDERR\s0 filehandles.  If both processes try ta access
them at once, strange thangs can happen. I aint talkin' bout chicken n' gravy biatch.  Yo ass may also wanna close
or reopen tha filehandlez fo' tha child. Y'all KNOW dat shit, muthafucka!  Yo ass can git round dis by
openin yo' pipe wit \fIopen()\fR yo, but on some systems dis means dat the
child process cannot outlive tha parent.
.SS "Background Processes"
.IX Subsection "Background Processes"
Yo ass can run a cold-ass lil command up in tha background with:
.PP
.Vb 1
\&    system("cmd &");
.Ve
.PP
Da commandz \s-1STDOUT\s0 n' \s-1STDERR \s0(and possibly \s-1STDIN,\s0 dependin on your
shell) is ghon be tha same as tha parent's.  Yo ass won't need ta catch
\&\s-1SIGCHLD\s0 cuz of tha double-fork takin place; peep below fo' details.
.SS "Complete Dissociation of Lil Pimp from Parent"
.IX Subsection "Complete Dissociation of Lil Pimp from Parent"
In some cases (startin server processes, fo' instance) you gonna want to
completely dissociate tha lil pimp process from tha parent.  This is
often called daemonization. I aint talkin' bout chicken n' gravy biatch.  A well-behaved daemon will also \fIchdir()\fR
to tha root directory so it don't prevent unmountin tha filesystem
containin tha directory from which dat shiznit was launched, n' redirect its
standard file descriptors from n' ta \fI/dev/null\fR so dat random
output don't wind up on tha userz terminal.
.PP
.Vb 1
\&    use POSIX "setsid";
\&
\&    sub daemonize {
\&        chdir("/")                      || take a thugged-out dirtnap "can\*(Aqt chdir ta /: $!";
\&        open(STDIN,  "< /dev/null")     || take a thugged-out dirtnap "can\*(Aqt read /dev/null: $!";
\&        open(STDOUT, "> /dev/null")     || take a thugged-out dirtnap "can\*(Aqt write ta /dev/null: $!";
\&        defined(my $pid = fork())       || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&        exit if $pid;                   # non\-zero now means I be tha parent
\&        (setsid() != \-1)                || take a thugged-out dirtnap "Can\*(Aqt start a freshly smoked up session: $!";
\&        open(STDERR, ">&STDOUT")        || take a thugged-out dirtnap "can\*(Aqt dup stdout: $!";
\&    }
.Ve
.PP
Da \fIfork()\fR has ta come before tha \fIsetsid()\fR ta ensure yo ass aint a
process crew leader; tha \fIsetsid()\fR will fail if yo ass is.  If your
system aint gots tha \fIsetsid()\fR function, open \fI/dev/tty\fR n' use the
\&\f(CW\*(C`TIOCNOTTY\*(C'\fR \fIioctl()\fR on it instead. Y'all KNOW dat shit, muthafucka!  See \fItty\fR\|(4) fo' details.
.PP
Non-Unix playas should check they \f(CW\*(C`\f(CIYour_OS\f(CW::Process\*(C'\fR module fo' 
other possible solutions.
.SS "Safe Pipe Opens"
.IX Subsection "Safe Pipe Opens"
Another bangin-ass approach ta \s-1IPC\s0 is makin yo' single program go
multiprocess n' rap between\*(--or even amongst\*(--yourselves.  The
\&\fIopen()\fR function will accept a gangbangin' file argument of either \f(CW"\-|"\fR or \f(CW"|\-"\fR
to do a straight-up bangin-ass thang: it forks a cold-ass lil lil pimp connected ta the
filehandle you've opened. Y'all KNOW dat shit, muthafucka!  Da lil pimp is hustlin tha same program as the
parent.  This is useful fo' safely openin a gangbangin' file when hustlin under an
assumed \s-1UID\s0 or \s-1GID,\s0 fo' example.  If you open a pipe \fIto\fR minus, you can
write ta tha filehandle you opened n' yo' kid will find it up in \fIhis\fR
\&\s-1STDIN. \s0 If you open a pipe \fIfrom\fR minus, you can read from tha filehandle
you opened whatever yo' kid writes ta \fIhis\fR \s-1STDOUT.\s0
.PP
.Vb 4
\&    use Gangsta qw[ \-no_match_vars ];
\&    mah $PRECIOUS = "/path/to/some/safe/file";
\&    mah $sleep_count;
\&    mah $pid;
\&
\&    do {
\&        $pid = open(KID_TO_WRITE, "|\-");
\&        unless (defined $pid) {
\&            warn "cannot fork: $!";
\&            take a thugged-out dirtnap "bailin out" if $sleep_count++ > 6;
\&            chill 10;
\&        }
\&    } until defined $pid;
\&
\&    if ($pid) {                 # I be tha parent 
\&        print KID_TO_WRITE @some_data;
\&        close(KID_TO_WRITE)     || warn "kid exited $?";
\&    } else {                    # I be tha child
\&        # drop permissions up in setuid and/or setgid programs:
\&        ($EUID, $EGID) = ($UID, $GID);  
\&        open (OUTFILE, "> $PRECIOUS") 
\&                                || take a thugged-out dirtnap "can\*(Aqt open $PRECIOUS: $!";
\&        while (<STDIN>) {
\&            print OUTFILE;      # child\*(Aqs STDIN is parent\*(Aqs KID_TO_WRITE
\&        }
\&        close(OUTFILE)          || take a thugged-out dirtnap "can\*(Aqt close $PRECIOUS: $!";
\&        exit(0);                # don\*(Aqt forget this!!
\&    }
.Ve
.PP
Another common use fo' dis construct is when you need ta execute
suttin' without tha shellz interference.  With \fIsystem()\fR, it's
straightforward yo, but you can't bust a pipe open or backticks safely.
Thatz cuz there be a no way ta stop tha shell from gettin its handz on
your arguments, n' you can put dat on yo' toast.   Instead, use lower-level control ta booty-call \fIexec()\fR directly.
.PP
Herez a safe backtick or pipe open fo' read:
.PP
.Vb 2
\&    mah $pid = open(KID_TO_READ, "\-|");
\&    defined($pid)           || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&
\&    if ($pid) {             # parent
\&        while (<KID_TO_READ>) {
\&                            # do suttin' interesting
\&        }
\&        close(KID_TO_READ)  || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID); # suid only
\&        exec($program, @options, @args)
\&                            || take a thugged-out dirtnap "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
And herez a safe pipe open fo' writing:
.PP
.Vb 2
\&    mah $pid = open(KID_TO_WRITE, "|\-");
\&    defined($pid)           || take a thugged-out dirtnap "can\*(Aqt fork: $!";
\&
\&    $SIG{PIPE} = sub { take a thugged-out dirtnap "whoops, $program pipe broke" };
\&
\&    if ($pid) {             # parent
\&        print KID_TO_WRITE @data;
\&        close(KID_TO_WRITE) || warn "kid exited $?";
\&
\&    } else {                # child
\&        ($EUID, $EGID) = ($UID, $GID);
\&        exec($program, @options, @args)
\&                            || take a thugged-out dirtnap "can\*(Aqt exec program: $!";
\&        # NOTREACHED
\&    }
.Ve
.PP
It be straight-up easy as fuck  ta dead-lock a process rockin dis form of \fIopen()\fR, or
indeed wit any use of \fIpipe()\fR wit multiple subprocesses.  Da 
example above is \*(L"safe\*(R" cuz it is simple n' calls \fIexec()\fR.  See
\&\*(L"Avoidin Pipe Deadlocks\*(R" fo' general safety principlez yo, but there
are extra gotchas wit Safe Pipe Opens.
.PP
In particular, if you opened tha pipe rockin \f(CW\*(C`open FH, "|\-"\*(C'\fR, then you
cannot simply use \fIclose()\fR up in tha parent process ta close a unwanted
writer n' shit.  Consider dis code:
.PP
.Vb 10
\&    mah $pid = open(WRITER, "|\-");        # fork open a kid
\&    defined($pid)               || take a thugged-out dirtnap "first fork failed: $!";
\&    if ($pid) {
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || take a thugged-out dirtnap "second fork failed: $!";
\&            close(WRITER)       || take a thugged-out dirtnap "couldn\*(Aqt close WRITER: $!";
\&            # now do suttin' else...
\&        }
\&        else {
\&            # first write ta WRITER
\&            # ...
\&            # then when finished
\&            close(WRITER)       || take a thugged-out dirtnap "couldn\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&    }
\&    else {
\&        # first do suttin' wit STDIN, then
\&        exit(0);
\&    }
.Ve
.PP
In tha example above, tha legit parent do not wanna write ta tha \s-1WRITER\s0
filehandle, so it closes dat shit.  But fuck dat shiznit yo, tha word on tha street is dat cuz \s-1WRITER\s0 was opened using
\&\f(CW\*(C`open FH, "|\-"\*(C'\fR, it has a special behavior: closin it calls
\&\fIwaitpid()\fR (see \*(L"waitpid\*(R" up in perlfunc), which waits fo' tha subprocess
to exit.  If tha lil pimp process endz up waitin fo' suttin' happening
in tha section marked \*(L"do suttin' else\*(R", you have deadlock.
.PP
This can also be a problem wit intermediate subprocesses up in more
fucked up code, which will call \fIwaitpid()\fR on all open filehandles
durin global destruction\*(--in no predictable order.
.PP
To solve this, you must manually use \fIpipe()\fR, \fIfork()\fR, n' tha form of
\&\fIopen()\fR which sets one file descriptor ta another, as shown below:
.PP
.Vb 10
\&    pipe(READER, WRITER)        || take a thugged-out dirtnap "pipe failed: $!";
\&    $pid = fork();
\&    defined($pid)               || take a thugged-out dirtnap "first fork failed: $!";
\&    if ($pid) {
\&        close READER;
\&        if (my $sub_pid = fork()) {
\&            defined($sub_pid)   || take a thugged-out dirtnap "first fork failed: $!";
\&            close(WRITER)       || take a thugged-out dirtnap "can\*(Aqt close WRITER: $!";
\&        }
\&        else {
\&            # write ta WRITER...
\&            # ...
\&            # then  when finished
\&            close(WRITER)       || take a thugged-out dirtnap "can\*(Aqt close WRITER: $!";
\&            exit(0);
\&        }
\&        # write ta WRITER...
\&    }
\&    else {
\&        open(STDIN, "<&READER") || take a thugged-out dirtnap "can\*(Aqt reopen STDIN: $!";
\&        close(WRITER)           || take a thugged-out dirtnap "can\*(Aqt close WRITER: $!";
\&        # do something...
\&        exit(0);
\&    }
.Ve
.PP
Since Perl 5.8.0, you can also use tha list form of \f(CW\*(C`open\*(C'\fR fo' pipes.
This is preferred when you wish ta avoid havin tha shell interpret
metacharactas dat may be up in yo' command string.
.PP
So fo' example, instead of using:
.PP
.Vb 1
\&    open(PS_PIPE, "ps aux|")    || take a thugged-out dirtnap "can\*(Aqt open ps pipe: $!";
.Ve
.PP
One would use either of these:
.PP
.Vb 2
\&    open(PS_PIPE, "\-|", "ps", "aux") 
\&                                || take a thugged-out dirtnap "can\*(Aqt open ps pipe: $!";
\&
\&    @ps_args = qw[ ps aux ];
\&    open(PS_PIPE, "\-|", @ps_args)
\&                                || take a thugged-out dirtnap "can\*(Aqt open @ps_args|: $!";
.Ve
.PP
Because there be mo' than three arguments ta \fIopen()\fR, forks tha \fIps\fR\|(1)
command \fIwithout\fR spawnin a gangbangin' finger-lickin' dirty-ass shell, n' readz its standard output via the
\&\f(CW\*(C`PS_PIPE\*(C'\fR filehandle.  Da correspondin syntax ta \fIwrite\fR ta command
pipes is ta use \f(CW"|\-"\fR up in place of \f(CW"\-|"\fR.
.PP
This was admittedly a rather wack-ass example, cuz you rockin string
literals whose content is perfectly safe.  There is therefore no cause to
resort ta tha harder-to-read, multi-argument form of pipe \fIopen()\fR.  However,
whenever you cannot be assured dat tha program arguments is free of shell
metacharacters, tha fancier form of \fIopen()\fR should be used. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 3
\&    @grep_args = ("egrep", "\-i", $some_pattern, @many_files);
\&    open(GREP_PIPE, "\-|", @grep_args)
\&                        || take a thugged-out dirtnap "can\*(Aqt open @grep_args|: $!";
.Ve
.PP
Here tha multi-argument form of pipe \fIopen()\fR is preferred cuz the
pattern n' indeed even tha filenames theyselves might hold metacharacters.
.PP
Be aware dat these operations is full Unix forks, which means they may
not be erectly implemented on all alien systems.  Additionally, these are
not legit multithreading.  To learn mo' bout threading, peep tha \fImodules\fR
file mentioned below up in tha \s-1SEE ALSO\s0 section.
.SS "Avoidin Pipe Deadlocks"
.IX Subsection "Avoidin Pipe Deadlocks"
Whenever you have mo' than one subprocess, you must be careful dat each
closes whichever half of any pipes pimped fo' interprocess communication
it aint using.  This is cuz any lil pimp process readin from tha pipe
and expectin a \s-1EOF\s0 aint NEVER gonna receive it, n' therefore never exit fo' realz. A
single process closin a pipe aint enough ta close it; tha last process
with tha pipe open must close it fo' it ta read \s-1EOF.\s0
.PP
Certain built-in Unix features help prevent dis most of tha time.  For
instance, filehandlez gotz a \*(L"close on exec\*(R" flag, which is set \fIen masse\fR
under control of tha \f(CW$^F\fR variable.  This is so any filehandlez you
didn't explicitly route ta tha \s-1STDIN, STDOUT\s0 or \s-1STDERR\s0 of a cold-ass lil child
\&\fIprogram\fR is ghon be automatically closed.
.PP
Always explicitly n' immediately call \fIclose()\fR on tha writable end of any
pipe, unless dat process is straight-up freestylin ta dat shit.  Even if you don't
explicitly call \fIclose()\fR, Perl will still \fIclose()\fR all filehandlez during
global destruction. I aint talkin' bout chicken n' gravy biatch.  As previously discussed, if dem filehandlez have
been opened wit Safe Pipe Open, dis will result up in callin \fIwaitpid()\fR,
which may again n' again n' again deadlock.
.SS "Bidirectionizzle Communication wit Another Process"
.IX Subsection "Bidirectionizzle Communication wit Another Process"
While dis works reasonably well fo' unidirectionizzle communication, what
about bidirectionizzle communication, biatch?  Da most obvious approach don't work:
.PP
.Vb 2
\&    # THIS DOES NOT WORK!!
\&    open(PROG_FOR_READING_AND_WRITING, "| some program |")
.Ve
.PP
If you forget ta \f(CW\*(C`use warnings\*(C'\fR, you gonna miss up entirely on the
helpful diagnostic message:
.PP
.Vb 1
\&    Can\*(Aqt do bidirectionizzle pipe at \-e line 1.
.Ve
.PP
If you straight-up want to, you can use tha standard \fIopen2()\fR from the
\&\f(CW\*(C`IPC::Open2\*(C'\fR module ta catch both ends.  Therez also a \fIopen3()\fR in
\&\f(CW\*(C`IPC::Open3\*(C'\fR fo' tridirectionizzle I/O so you can also catch yo' child's
\&\s-1STDERR,\s0 but bustin so would then require a awkward \fIselect()\fR loop and
wouldn't allow you ta use aiiight Perl input operations.
.PP
If you peep its source, you gonna peep dat \fIopen2()\fR uses low-level
primitives like tha \fIpipe()\fR n' \fIexec()\fR syscalls ta create all the
connections.  Although it might done been mo' efficient by using
\&\fIsocketpair()\fR, dis would done been even less portable than it already
is. Da \fIopen2()\fR n' \fIopen3()\fR functions is unlikely ta work anywhere
except on a Unix system, or at least one purportin \s-1POSIX\s0 compliance.
.PP
Herez a example of rockin \fIopen2()\fR:
.PP
.Vb 5
\&    use FileHandle;
\&    use IPC::Open2;
\&    $pid = open2(*Reader, *Writer, "cat \-un");
\&    print Writa "stuff\en";
\&    $got = <Reader>;
.Ve
.PP
Da problem wit dis is dat bufferin is straight-up goin ta fuck up your
day. It make me wanna hollar playa!  Even though yo' \f(CW\*(C`Writer\*(C'\fR filehandle be auto-flushed so tha process
on tha other end gets yo' data up in a timely manner, you can't probably do
anythang ta force dat process ta give its data ta you up in a similarly quick
fashion. I aint talkin' bout chicken n' gravy biatch.  In dis special case, we could straight-up so, cuz we gave
\&\fIcat\fR a \fB\-u\fR flag ta make it unbuffered. Y'all KNOW dat shit, muthafucka!  But straight-up few commandz are
designed ta operate over pipes, so dis seldom works unless you yo ass
wrote tha program on tha other end of tha double-ended pipe.
.PP
A solution ta dis is ta bust a library which uses pseudottys ta make your
program behave mo' reasonably.  This way you don't gotta have control
over tha source code of tha program you using.  Da \f(CW\*(C`Expect\*(C'\fR module
from \s-1CPAN\s0 also addresses dis kind of thang.  This module requires two
other modulez from \s-1CPAN, \s0\f(CW\*(C`IO::Pty\*(C'\fR n' \f(CW\*(C`IO::Stty\*(C'\fR.  It sets up a pseudo
terminal ta interact wit programs dat insist on rappin' ta tha terminal
device driver n' shit.  If yo' system is supported, dis may be yo' dopest bet.
.SS "Bidirectionizzle Communication wit Yourself"
.IX Subsection "Bidirectionizzle Communication wit Yourself"
If you want, you may make low-level \fIpipe()\fR n' \fIfork()\fR syscalls ta stitch
this together by hand. Y'all KNOW dat shit, muthafucka!  This example only talks ta itself yo, but you could
reopen tha appropriate handlez ta \s-1STDIN\s0 n' \s-1STDOUT\s0 n' call other processes.
(Da followin example lacks proper error checking.)
.PP
.Vb 8
\&    #!/usr/bin/perl \-w
\&    # pipe1 \- bidirectionizzle communication rockin two pipe pairs
\&    #         designed fo' tha socketpair\-challenged
\&    use IO::Handle;               # thousandz of lines just fo' autoflush :\-(
\&    pipe(PARENT_RDR, CHILD_WTR);  # XXX: check failure?
\&    pipe(CHILD_RDR,  PARENT_WTR); # XXX: check failure?
\&    CHILD_WTR\->autoflush(1);
\&    PARENT_WTR\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        print CHILD_WTR "Parent Pid $$ is bustin  this\en";
\&        chomp($line = <CHILD_RDR>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD_RDR; close CHILD_WTR;
\&        waitpid($pid, 0);
\&    } else {
\&        take a thugged-out dirtnap "cannot fork: $!" unless defined $pid;
\&        close CHILD_RDR; 
\&        close CHILD_WTR;
\&        chomp($line = <PARENT_RDR>);
\&        print "Lil Pimp Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT_WTR "Lil Pimp Pid $$ is bustin  this\en";
\&        close PARENT_RDR; 
\&        close PARENT_WTR;
\&        exit(0);
\&    }
.Ve
.PP
But you don't straight-up gotta make two pipe calls.  If you
have tha \fIsocketpair()\fR system call, it will do dis all fo' yo thugged-out ass.
.PP
.Vb 3
\&    #!/usr/bin/perl \-w
\&    # pipe2 \- bidirectionizzle communication rockin socketpair
\&    #   "the dopest ones always go both ways"
\&
\&    use Socket;
\&    use IO::Handle;  # thousandz of lines just fo' autoflush :\-(
\&
\&    # We say AF_UNIX cuz although *_LOCAL is the
\&    # POSIX 1003.1g form of tha constant, nuff machines
\&    # still don\*(Aqt have dat shit.
\&    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
\&                                ||  take a thugged-out dirtnap "socketpair: $!";
\&
\&    CHILD\->autoflush(1);
\&    PARENT\->autoflush(1);
\&
\&    if ($pid = fork()) {
\&        close PARENT;
\&        print CHILD "Parent Pid $$ is bustin  this\en";
\&        chomp($line = <CHILD>);
\&        print "Parent Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        close CHILD;
\&        waitpid($pid, 0);
\&    } else {
\&        take a thugged-out dirtnap "cannot fork: $!" unless defined $pid;
\&        close CHILD;
\&        chomp($line = <PARENT>);
\&        print "Lil Pimp Pid $$ just read this: \*(Aq$line\*(Aq\en";
\&        print PARENT "Lil Pimp Pid $$ is bustin  this\en";
\&        close PARENT;
\&        exit(0);
\&    }
.Ve
.SH "Sockets: Client/Server Communication"
.IX Header "Sockets: Client/Server Communication"
While not entirely limited ta Unix-derived operatin systems (e.g., WinSock
on PCs serves up socket support, as do some \s-1VMS\s0 libraries), you might not have
sockets on yo' system, up in which case dis section probably aint goin to
do you much good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  With sockets, you can do both virtual circuits like \s-1TCP\s0
streams n' datagrams like \s-1UDP\s0 packets, n' you can put dat on yo' toast.  Yo ass may be able ta do even more
dependin on yo' system.
.PP
Da Perl functions fo' dealin wit sockets have tha same names as
the correspondin system calls up in C yo, but they arguments tend ta differ
for two reasons.  First, Perl filehandlez work differently than C file
descriptors.  Second, Perl already knows tha length of its strings, so you
don't need ta pass dat shiznit.
.PP
One of tha major problems wit ancient, antemillennial socket code up in Perl
was dat it used hard-coded joints fo' a shitload of tha constants, which
severely hurt portability.  If you eva peep code dat do anythang like
explicitly settin \f(CW\*(C`$AF_INET = 2\*(C'\fR, you know you up in fo' big-ass shit.  
An immeasurably superior approach is ta use tha \f(CW\*(C`Socket\*(C'\fR module, which more
reliably grants access ta tha various constants n' functions you gonna need.
.PP
If you not freestylin a server/client fo' a existin protocol like
\&\s-1NNTP\s0 or \s-1SMTP,\s0 you should give some thought ta how tha fuck yo' server will
know when tha client has finished rappin', n' vice-versa.  Most
protocols is based on one-line lyrics n' responses (so one party
knows tha other has finished when a \*(L"\en\*(R" is received) or multi-line
lyrics n' responses dat end wit a period on a empty line
(\*(L"\en.\en\*(R" terminates a message/response).
.SS "Internizzle Line Terminators"
.IX Subsection "Internizzle Line Terminators"
Da Internizzle line terminator is \*(L"\e015\e012\*(R".  Under \s-1ASCII\s0 variants of
Unix, dat could probably be freestyled as \*(L"\er\en\*(R" yo, but under other systems,
\&\*(L"\er\en\*(R" might at times be \*(L"\e015\e015\e012\*(R", \*(L"\e012\e012\e015\*(R", or something
completely different.  Da standardz specify freestylin \*(L"\e015\e012\*(R" ta be
conformant (be strict up in what tha fuck you provide) yo, but they also recommend
acceptin a lone \*(L"\e012\*(R" on input (be lenient up in what tha fuck you require).
We aint always been straight-up phat bout dat up in tha code up in dis manpage,
but unless you on a Mac from way back up in its pre-Unix dark ages, you gonna 
probably be ok.
.SS "Internizzle \s-1TCP\s0 Clients n' Servers"
.IX Subsection "Internizzle TCP Clients n' Servers"
Use Internet-domain sockets when you wanna do client-server
communication dat might extend ta machines outside of yo' own system.
.PP
Herez a sample \s-1TCP\s0 client rockin Internet-domain sockets:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    mah ($remote, $port, $iaddr, $paddr, $proto, $line);
\&
\&    $remote  = shift || "localhost";
\&    $port    = shift || 2345;  # random port
\&    if ($port =~ /\eD/) { $port = getservbyname($port, "tcp") }
\&    take a thugged-out dirtnap "No port" unless $port;
\&    $iaddr   = inet_aton($remote)       || take a thugged-out dirtnap "no host: $remote";
\&    $paddr   = sockaddr_in($port, $iaddr);
\&
\&    $proto   = getprotobyname("tcp");
\&    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || take a thugged-out dirtnap "socket: $!";
\&    connect(SOCK, $paddr)               || take a thugged-out dirtnap "connect: $!";
\&    while ($line = <SOCK>) {
\&        print $line;
\&    }
\&
\&    close (SOCK)                        || take a thugged-out dirtnap "close: $!";
\&    exit(0);
.Ve
.PP
And herez a cold-ass lil correspondin server ta go along wit dat shit.  We bout ta
leave tha address as \f(CW\*(C`INADDR_ANY\*(C'\fR so dat tha kernel can chizzle
the appropriate intercourse on multihomed hosts, n' you can put dat on yo' toast.  If you want sit
on a particular intercourse (like tha external side of a gateway
or firewall machine), fill dis up in wit yo' real address instead.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    mah $EOL = "\e015\e012";
\&
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    mah $port  = shift || 2345;
\&    take a thugged-out dirtnap "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    mah $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || take a thugged-out dirtnap "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))    
\&                                                    || take a thugged-out dirtnap "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || take a thugged-out dirtnap "bind: $!";
\&    listen(Server, SOMAXCONN)                       || take a thugged-out dirtnap "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    mah $paddr;
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    fo' ( ; $paddr = accept(Client, Server); close Client) {
\&        my($port, $iaddr) = sockaddr_in($paddr);
\&        mah $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&                inet_ntoa($iaddr), "]
\&                at port $port";
\&
\&        print Client "Wuz crackalackin' there, $name, it\*(Aqs now ",
\&                        scalar localtime(), $EOL;
\&    }
.Ve
.PP
And herez a multithreaded version. I aint talkin' bout chicken n' gravy biatch.  It aint nuthin but multithreaded up in that
like most typical servers, it spawns (\fIfork()\fRs) a slave server to
handle tha client request so dat tha masta server can quickly
go back ta steez a freshly smoked up client.
.PP
.Vb 6
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    use Socket;
\&    use Carp;
\&    mah $EOL = "\e015\e012";
\&
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    mah $port  = shift || 2345;
\&    take a thugged-out dirtnap "invalid port" unless if $port =~ /^ \ed+ $/x;
\&
\&    mah $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_INET, SOCK_STREAM, $proto)    || take a thugged-out dirtnap "socket: $!";
\&    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR, pack("l", 1))         
\&                                                    || take a thugged-out dirtnap "setsockopt: $!";
\&    bind(Server, sockaddr_in($port, INADDR_ANY))    || take a thugged-out dirtnap "bind: $!";
\&    listen(Server, SOMAXCONN)                       || take a thugged-out dirtnap "listen: $!";
\&
\&    logmsg "server started on port $port";
\&
\&    mah $waitedpid = 0;
\&    mah $paddr;
\&
\&    use POSIX ":sys_wait_h";
\&    use Errno;
\&
\&    sub REAPER {
\&        local $!;   # don\*(Aqt let waitpid() overwrite current error
\&        while ((my $pid = waitpid(\-1, WNOHANG)) > 0 && WIFEXITED($?)) {
\&            logmsg "reaped $waitedpid" . ($, biatch? , biatch? " wit exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&    while (1) {
\&        $paddr = accept(Client, Server) || do {
\&            # try again n' again n' again if accept() returned cuz gots a signal
\&            next if $!{EINTR};
\&            take a thugged-out dirtnap "accept: $!";
\&        };
\&        mah ($port, $iaddr) = sockaddr_in($paddr);
\&        mah $name = gethostbyaddr($iaddr, AF_INET);
\&
\&        logmsg "connection from $name [",
\&               inet_ntoa($iaddr),
\&               "] at port $port";
\&
\&        spawn sub {
\&            $| = 1;
\&            print "Wuz crackalackin' there, $name, it\*(Aqs now ", scalar localtime(), $EOL;
\&            exec "/usr/games/fortune"       # XXX: "wrong" line terminators
\&                or confess "can\*(Aqt exec fortune: $!";
\&        };
\&        close Client;
\&    }
\&
\&    sub spawn {
\&        mah $coderef = shift;
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        mah $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm tha parent
\&        }
\&        # else I\*(Aqm tha lil pimp \-\- go spawn
\&
\&        open(STDIN,  "<&Client")    || take a thugged-out dirtnap "can\*(Aqt dup client ta stdin";
\&        open(STDOUT, ">&Client")    || take a thugged-out dirtnap "can\*(Aqt dup client ta stdout";
\&        ## open(STDERR, ">&STDOUT") || take a thugged-out dirtnap "can\*(Aqt dup stdout ta stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
This server takes tha shiznit ta clone off a cold-ass lil lil pimp version via \fIfork()\fR
for each incomin request.  That way it can handle nuff requests at
once, which you might not always want.  Even if you don't \fIfork()\fR, the
\&\fIlisten()\fR will allow dat nuff pendin connections.  Forkin servers
have ta be particularly careful bout cleanin up they dead children
(called \*(L"zombies\*(R" up in Unix parlance), cuz otherwise you gonna quickly
fill up yo' process table.  Da \s-1REAPER\s0 subroutine is used here to
call \fIwaitpid()\fR fo' any lil pimp processes dat have finished, thereby
ensurin dat they terminizzle cleanly n' don't join tha rankz of the
livin dead as fuckin fried chicken.
.PP
Within tha while loop we call \fIaccept()\fR n' check ta peep if it returns
a false value.  This would normally indicate a system error needs
to be reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  But fuck dat shiznit yo, tha word on tha street is dat tha introduction of safe signals (see
\&\*(L"Deferred Signals (Safe Signals)\*(R" above) up in Perl 5.8.0 means that
\&\fIaccept()\fR might also be interrupted when tha process receives a signal.
This typically happens when one of tha forked subprocesses exits and
notifies tha parent process wit a \s-1CHLD\s0 signal.
.PP
If \fIaccept()\fR is interrupted by a signal, $! is ghon be set ta \s-1EINTR.\s0
If dis happens, we can safely continue ta tha next iteration of
the loop n' another call ta \fIaccept()\fR.  It be blingin dat your
signal handlin code not modify tha value of $!, or else dis test 
will likely fail.  In tha \s-1REAPER\s0 subroutine we create a local version
of $! before callin \fIwaitpid()\fR.  When \fIwaitpid()\fR sets $! ta \s-1ECHILD\s0 as
it inevitably do when it has no mo' lil pimps waiting, it 
updates tha local copy n' leaves tha original gangsta unchanged.
.PP
Yo ass should use tha \fB\-T\fR flag ta enable taint checkin (see perlsec)
even if we aren't hustlin setuid or setgid. Y'all KNOW dat shit, muthafucka!  This be always a phat idea
for servers or any program run on behalf of one of mah thugs (like \s-1CGI\s0
scripts), cuz it lessens tha chances dat playas from tha outside will
be able ta compromise yo' system.
.PP
Letz peep another \s-1TCP\s0 client.  This one connects ta tha \s-1TCP \s0\*(L"time\*(R"
service on a fuckin shitload of different machines n' shows how tha fuck far they clocks
differ from tha system on which itz bein run:
.PP
.Vb 3
\&    #!/usr/bin/perl  \-w
\&    use strict;
\&    use Socket;
\&
\&    mah $SECS_OF_70_YEARS = 2208988800;
\&    sub ctime { scalar localtime(shift() || time()) }
\&
\&    mah $iaddr = gethostbyname("localhost");
\&    mah $proto = getprotobyname("tcp");
\&    mah $port = getservbyname("time", "tcp");
\&    mah $paddr = sockaddr_in(0, $iaddr);
\&    my($host);
\&
\&    $| = 1;
\&    printf "%\-24s %8s %s\en", "localhost", 0, ctime();
\&
\&    foreach $host (@ARGV) {
\&        printf "%\-24s ", $host;
\&        mah $hisiaddr = inet_aton($host)     || take a thugged-out dirtnap "unknown host";
\&        mah $hispaddr = sockaddr_in($port, $hisiaddr);
\&        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   
\&                                            || take a thugged-out dirtnap "socket: $!";
\&        connect(SOCKET, $hispaddr)          || take a thugged-out dirtnap "connect: $!";
\&        mah $rtime = pack("C4", ());
\&        read(SOCKET, $rtime, 4);
\&        close(SOCKET);
\&        mah $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%8d %s\en", $histime \- time(), ctime($histime);
\&    }
.Ve
.SS "Unix-Domain \s-1TCP\s0 Clients n' Servers"
.IX Subsection "Unix-Domain TCP Clients n' Servers"
Thatz fine fo' Internet-domain clients n' servers yo, but what tha fuck bout local
communications, biatch?  While you can use tha same setup, sometimes you don't
want to.  Unix-domain sockets is local ta tha current host, n' is often
used internally ta implement pipes.  Unlike Internizzle domain sockets, Unix
domain sockets can show up in tha file system wit a \fIls\fR\|(1) listing.
.PP
.Vb 2
\&    % ls \-l /dev/log
\&    srw\-rw\-rw\-  1 root            0 Oct 31 07:23 /dev/log
.Ve
.PP
Yo ass can test fo' these wit Perlz \fB\-S\fR file test:
.PP
.Vb 3
\&    unless (\-S "/dev/log") {
\&        take a thugged-out dirtnap "something\*(Aqs wicked wit tha log system";
\&    }
.Ve
.PP
Herez a sample Unix-domain client:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use Socket;
\&    use strict;
\&    mah ($rendezvous, $line);
\&
\&    $rendezvous = shift || "catsock";
\&    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)     || take a thugged-out dirtnap "socket: $!";
\&    connect(SOCK, sockaddr_un($rendezvous))   || take a thugged-out dirtnap "connect: $!";
\&    while (defined($line = <SOCK>)) {
\&        print $line;
\&    }
\&    exit(0);
.Ve
.PP
And herez a cold-ass lil correspondin server n' shit.  Yo ass don't gotta worry bout silly
network terminators here cuz Unix domain sockets is guaranteed
to be on tha localhost, n' thus every last muthafuckin thang works right.
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use Socket;
\&    use Carp;
\&
\&    BEGIN { $ENV{PATH} = "/usr/bin:/bin" }
\&    sub spawn;  # forward declaration
\&    sub logmsg { print "$0 $$: @_ at ", scalar localtime(), "\en" }
\&
\&    mah $NAME = "catsock";
\&    mah $uaddr = sockaddr_un($NAME);
\&    mah $proto = getprotobyname("tcp");
\&
\&    socket(Server, PF_UNIX, SOCK_STREAM, 0) || take a thugged-out dirtnap "socket: $!";
\&    unlink($NAME);
\&    bind  (Server, $uaddr)                  || take a thugged-out dirtnap "bind: $!";
\&    listen(Server, SOMAXCONN)               || take a thugged-out dirtnap "listen: $!";
\&
\&    logmsg "server started on $NAME";
\&
\&    mah $waitedpid;
\&
\&    use POSIX ":sys_wait_h";
\&    sub REAPER {
\&        mah $child;
\&        while (($waitedpid = waitpid(\-1, WNOHANG)) > 0) {
\&            logmsg "reaped $waitedpid" . ($, biatch? , biatch? " wit exit $?" : "");
\&        }
\&        $SIG{CHLD} = \e&REAPER;  # loathe SysV
\&    }
\&
\&    $SIG{CHLD} = \e&REAPER;
\&
\&
\&    fo' ( $waitedpid = 0;
\&          accept(Client, Server) || $waitedpid;
\&          $waitedpid = 0, close Client)
\&    {
\&        next if $waitedpid;
\&        logmsg "connection on $NAME";
\&        spawn sub {
\&            print "Wuz crackalackin' there, it\*(Aqs now ", scalar localtime(), "\en";
\&            exec("/usr/games/fortune")  || take a thugged-out dirtnap "can\*(Aqt exec fortune: $!";
\&        };
\&    }
\&
\&    sub spawn {
\&        mah $coderef = shift();
\&
\&        unless (@_ == 0 && $coderef && ref($coderef) eq "CODE") {
\&            confess "usage: spawn CODEREF";
\&        }
\&
\&        mah $pid;
\&        unless (defined($pid = fork())) {
\&            logmsg "cannot fork: $!";
\&            return;
\&        } 
\&        elsif ($pid) {
\&            logmsg "begat $pid";
\&            return; # I\*(Aqm tha parent
\&        } 
\&        else {
\&            # I\*(Aqm tha lil pimp \-\- go spawn
\&        }
\&
\&        open(STDIN,  "<&Client")    || take a thugged-out dirtnap "can\*(Aqt dup client ta stdin";
\&        open(STDOUT, ">&Client")    || take a thugged-out dirtnap "can\*(Aqt dup client ta stdout";
\&        ## open(STDERR, ">&STDOUT") || take a thugged-out dirtnap "can\*(Aqt dup stdout ta stderr";
\&        exit($coderef\->());
\&    }
.Ve
.PP
As you see, itz remarkably similar ta tha Internizzle domain \s-1TCP\s0 server, so
much so, up in fact, dat we've omitted nuff muthafuckin duplicate functions\*(--\fIspawn()\fR,
\&\fIlogmsg()\fR, \fIctime()\fR, n' \s-1\fIREAPER\s0()\fR\-\-which is tha same as up in tha other server.
.PP
So why would you eva wanna bust a Unix domain socket instead of a
simpla named pipe, biatch?  Because a named pipe don't hit you wit sessions.  You
can't tell one processs data from another's.  With socket programming,
you git a separate session fo' each client; thatz why \fIaccept()\fR takes two
arguments.
.PP
For example, letz say dat you gotz a long-runnin database server daemon
that you want folks ta be able ta access from tha Web yo, but only
if they go all up in a \s-1CGI\s0 intercourse.  You'd gotz a small, simple \s-1CGI\s0
program dat do whatever checks n' loggin you feel like, n' then acts
as a Unix-domain client n' connects ta yo' private server.
.SH "TCP Clients wit IO::Socket"
.IX Header "TCP Clients wit IO::Socket"
For dem preferrin a higher-level intercourse ta socket programming, the
IO::Socket module serves up a object-oriented approach.  If fo' some reason
you lack dis module, you can just fetch IO::Socket from \s-1CPAN,\s0 where you gonna also
find modulez providin easy as fuck  intercourses ta tha followin systems: \s-1DNS, FTP,\s0
Ident (\s-1RFC 931\s0), \s-1NIS\s0 n' NISPlus, \s-1NNTP,\s0 Ping, \s-1POP3, SMTP, SNMP,\s0 SSLeay,
Telnet, n' Time\*(--to name just a gangbangin' few.
.SS "A Simple Client"
.IX Subsection "A Simple Client"
Herez a cold-ass lil client dat creates a \s-1TCP\s0 connection ta tha \*(L"daytime\*(R"
service at port 13 of tha host name \*(L"localhost\*(R" n' prints up every last muthafuckin thang
that tha server there cares ta provide.
.PP
.Vb 9
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    $remote = IO::Socket::INET\->new(
\&                        Proto    => "tcp",
\&                        PeerAddr => "localhost",
\&                        PeerPort => "daytime(13)",
\&                    )
\&                  || take a thugged-out dirtnap "can\*(Aqt connect ta daytime steez on localhost";
\&    while (<$remote>) { print }
.Ve
.PP
When you run dis program, you should git suttin' back that
looks like this:
.PP
.Vb 1
\&    Wed May 14 08:40:46 MDT 1997
.Ve
.PP
Here is what tha fuck dem parametas ta tha \fInew()\fR constructor mean:
.ie n .IP """Proto""" 4
.el .IP "\f(CWProto\fR" 4
.IX Item "Proto"
This is which protocol ta use.  In dis case, tha socket handle returned
will be connected ta a \s-1TCP\s0 socket, cuz we want a stream-oriented
connection, dat is, one dat acts pretty much like a plain oldschool file.
Not all sockets is diz of dis type.  For example, tha \s-1UDP\s0 protocol
can be used ta cook up a thugged-out datagram socket, used fo' message-passing.
.ie n .IP """PeerAddr""" 4
.el .IP "\f(CWPeerAddr\fR" 4
.IX Item "PeerAddr"
This is tha name or Internizzle address of tha remote host tha server is
runnin on. I aint talkin' bout chicken n' gravy biatch.  We could have specified a longer name like \f(CW"www.perl.com"\fR,
or a address like \f(CW"207.171.7.72"\fR.  For demonstration purposes, we've
used tha special hostname \f(CW"localhost"\fR, which should always mean the
current machine you hustlin on. I aint talkin' bout chicken n' gravy biatch.  Da correspondin Internizzle address
for localhost is \f(CW"127.0.0.1"\fR, if you'd rather use dis shit.
.ie n .IP """PeerPort""" 4
.el .IP "\f(CWPeerPort\fR" 4
.IX Item "PeerPort"
This is tha steez name or port number we'd like ta connect to.
We could have gotten away wit rockin just \f(CW"daytime"\fR on systems wit a
well-configured system skillz file,[\s-1FOOTNOTE:\s0 Da system skillz file
is found up in \fI/etc/skillz\fR under Unixy systems.] but here we've specified the
port number (13) up in parentheses.  Usin just tha number would have also
worked yo, but numeric literals make careful programmers nervous.
.PP
Notice how tha fuck tha return value from tha \f(CW\*(C`new\*(C'\fR constructor is used as
a filehandle up in tha \f(CW\*(C`while\*(C'\fR loop, biatch?  Thatz whatz called a \fIindirect
filehandle\fR, a scalar variable containin a gangbangin' filehandle.  Yo ass can use
it tha same way you would a aiiight filehandle.  For example, you
can read one line from it dis way:
.PP
.Vb 1
\&    $line = <$handle>;
.Ve
.PP
all remainin lines from is dis way:
.PP
.Vb 1
\&    @lines = <$handle>;
.Ve
.PP
and bust a line of data ta it dis way:
.PP
.Vb 1
\&    print $handle "some data\en";
.Ve
.SS "A Webget Client"
.IX Subsection "A Webget Client"
Herez a simple client dat takes a remote host ta fetch a thugged-out document
from, n' then a list of filez ta git from dat host.  This be a
more bangin-ass client than tha previous one cuz it first sends
suttin' ta tha server before fetchin tha serverz response.
.PP
.Vb 10
\&    #!/usr/bin/perl \-w
\&    use IO::Socket;
\&    unless (@ARGV > 1) { take a thugged-out dirtnap "usage: $0 host url ..." }
\&    $host = shift(@ARGV);
\&    $EOL = "\e015\e012";
\&    $BLANK = $EOL x 2;
\&    fo' mah $document (@ARGV) {
\&        $remote = IO::Socket::INET\->new( Proto     => "tcp",
\&                                         PeerAddr  => $host,
\&                                         PeerPort  => "http(80)",
\&                  )     || take a thugged-out dirtnap "cannot connect ta httpd on $host";
\&        $remote\->autoflush(1);
\&        print $remote "GET $document HTTP/1.0" . $BLANK;
\&        while ( <$remote> ) { print }
\&        close $remote;
\&    }
.Ve
.PP
Da wizzy server handlin tha \s-1HTTP\s0 steez be assumed ta be at
its standard port, number 80.  If tha server you tryin to
connect ta be at a gangbangin' finger-lickin' different port, like 1080 or 8080, you should specify it
as tha named-parameta pair, \f(CW\*(C`PeerPort => 8080\*(C'\fR.  Da \f(CW\*(C`autoflush\*(C'\fR
method is used on tha socket cuz otherwise tha system would buffer
up tha output we busted dat shit.  (If you on a prehistoric Mac, you gonna also
need ta chizzle every last muthafuckin \f(CW"\en"\fR up in yo' code dat sendz data over tha network
to be a \f(CW"\e015\e012"\fR instead.)
.PP
Connectin ta tha server is only tha straight-up original gangsta part of tha process: once you
have tha connection, you gotta use tha serverz language.  Each server
on tha network has its own lil command language dat it expects as
input.  Da strang dat we bust ta tha server startin wit \*(L"\s-1GET\*(R"\s0 is in
\&\s-1HTTP\s0 syntax.  In dis case, we simply request each specified document.
Yes, we straight-up is bustin a freshly smoked up connection fo' each document, even though
itz tha same ol' dirty host.  Thatz tha way you always used ta gotta drop a rhyme \s-1HTTP.\s0
Recent versionz of wizzy browsers may request dat tha remote server leave
the connection open a lil while yo, but tha server don't gotta honor
such a request.
.PP
Herez a example of hustlin dat program, which we'll call \fIwebget\fR:
.PP
.Vb 6
\&    % webget www.perl.com /guanaco.html
\&    HTTP/1.1 404 File Not Found
\&    Date: Thu, 08 May 1997 18:02:32 GMT
\&    Server: Apache/1.2b6
\&    Connection: close
\&    Content\-type: text/html
\&
\&    <HEAD><TITLE>404 File Not Found</TITLE></HEAD>
\&    <BODY><H1>File Not Found</H1>
\&    Da axed URL /guanaco.html was not found on dis server.<P>
\&    </BODY>
.Ve
.PP
Ok, so thatz not straight-up interesting, cuz it didn't find that
particular document.  But a long-ass response wouldn't have fit on dis page.
.PP
For a mo' featureful version of dis program, you should look to
the \fIlwp-request\fR program included wit tha \s-1LWP\s0 modulez from \s-1CPAN.\s0
.SS "Interactizzle Client wit IO::Socket"
.IX Subsection "Interactizzle Client wit IO::Socket"
Well, thatz all fine if you wanna bust one command n' git one answer,
but what tha fuck bout settin up suttin' straight-up interactive, somewhat like
the way \fItelnet\fR works, biatch?  That way you can type a line, git tha answer,
type a line, git tha answer, etc.
.PP
This client is mo' fucked up than tha two we've done so far yo, but if
yo ass is on a system dat supports tha bangin \f(CW\*(C`fork\*(C'\fR call, tha solution
aint dat rough cause I gots dem finger-lickin' chickens wit tha siz-auce.  Once you've made tha connection ta whatever service
you'd like ta chat with, call \f(CW\*(C`fork\*(C'\fR ta clone yo' process.  Each of
these two identical process has a straight-up simple thang ta do: tha parent
copies every last muthafuckin thang from tha socket ta standard output, while tha child
simultaneously copies every last muthafuckin thang from standard input ta tha socket.
To accomplish tha same thang rockin just one process would be \fImuch\fR
harder, cuz itz easier ta code two processes ta do one thang than it
is ta code one process ta do two thangs.  (This keep-it-simple principle
a cornerstonez of tha Unix philosophy, n' phat software engineerin as
well, which is probably why itz spread ta other systems.)
.PP
Herez tha code:
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use IO::Socket;
\&    mah ($host, $port, $kidpid, $handle, $line);
\&
\&    unless (@ARGV == 2) { take a thugged-out dirtnap "usage: $0 host port" }
\&    ($host, $port) = @ARGV;
\&
\&    # create a tcp connection ta tha specified host n' port
\&    $handle = IO::Socket::INET\->new(Proto     => "tcp",
\&                                    PeerAddr  => $host,
\&                                    PeerPort  => $port)
\&               || take a thugged-out dirtnap "can\*(Aqt connect ta port $port on $host: $!";
\&
\&    $handle\->autoflush(1);       # so output gets there right away
\&    print STDERR "[Connected ta $host:$port]\en";
\&
\&    # split tha program tha fuck into two processes, identical twins
\&    take a thugged-out dirtnap "can\*(Aqt fork: $!" unless defined($kidpid = fork());
\&
\&    # tha if{} block runs only up in tha parent process
\&    if ($kidpid) {
\&        # copy tha socket ta standard output
\&        while (defined ($line = <$handle>)) {
\&            print STDOUT $line;
\&        }
\&        kill("TERM", $kidpid);   # bust SIGTERM ta child
\&    }
\&    # tha else{} block runs only up in tha lil pimp process
\&    else {
\&        # copy standard input ta tha socket
\&        while (defined ($line = <STDIN>)) {
\&            print $handle $line;
\&        }
\&        exit(0);                # just up in case
\&    }
.Ve
.PP
Da \f(CW\*(C`kill\*(C'\fR function up in tha parentz \f(CW\*(C`if\*(C'\fR block is there ta bust a
signal ta our lil pimp process, currently hustlin up in tha \f(CW\*(C`else\*(C'\fR block,
as soon as tha remote server has closed its end of tha connection.
.PP
If tha remote server sendz data a funky-ass byte at time, n' you need that
data immediately without waitin fo' a newline (which might not happen),
you may wish ta replace tha \f(CW\*(C`while\*(C'\fR loop up in tha parent wit the
following:
.PP
.Vb 4
\&    mah $byte;
\&    while (sysread($handle, $byte, 1) == 1) {
\&        print STDOUT $byte;
\&    }
.Ve
.PP
Makin a system call fo' each byte you wanna read aint straight-up efficient
(to put it mildly) but is tha simplest ta explain n' works reasonably
well.
.SH "TCP Servers wit IO::Socket"
.IX Header "TCP Servers wit IO::Socket"
As always, settin up a server is lil bit mo' involved than hustlin a cold-ass lil client.
Da model is dat tha server creates a special kind of socket that
does not a god damn thang but listen on a particular port fo' incomin connections.
It do dis by callin tha \f(CW\*(C`IO::Socket::INET\->new()\*(C'\fR method with
slightly different arguments than tha client done did.
.IP "Proto" 4
.IX Item "Proto"
This is which protocol ta use.  Like our clients, we'll
still specify \f(CW"tcp"\fR here.
.IP "LocalPort" 4
.IX Item "LocalPort"
We specify a local
port up in tha \f(CW\*(C`LocalPort\*(C'\fR argument, which our phat asses didn't do fo' tha client.
This is steez name or port number fo' which you wanna be the
server n' shit. (Under Unix, ports under 1024 is restricted ta the
superuser.)  In our sample, we'll use port 9000 yo, but you can use
any port thatz not currently up in use on yo' system.  If you try
to use one already up in used, you gonna git a \*(L"Address already up in use\*(R"
message.  Under Unix, tha \f(CW\*(C`netstat \-a\*(C'\fR command will show
which skillz current have servers.
.IP "Listen" 4
.IX Item "Listen"
Da \f(CW\*(C`Listen\*(C'\fR parameta is set ta tha maximum number of
pendin connections we can accept until we turn away incomin clients.
Think of it as a cold-ass lil call-waitin queue fo' yo' telephone.
Da low-level Socket module has a special symbol fo' tha system maximum, which
is \s-1SOMAXCONN.\s0
.IP "Reuse" 4
.IX Item "Reuse"
Da \f(CW\*(C`Reuse\*(C'\fR parameta is needed so dat we restart our server
manually without waitin all dem minutes ta allow system buffers to
clear out.
.PP
Once tha generic server socket has been pimped rockin tha parameters
listed above, tha server then waits fo' a freshly smoked up client ta connect
to dat shit.  Da server blocks up in tha \f(CW\*(C`accept\*(C'\fR method, which eventually accepts a
bidirectionizzle connection from tha remote client.  (Make shizzle ta autoflush
this handle ta circumvent buffering.)
.PP
To add ta user-friendliness, our server prompts tha user fo' commands.
Most servers don't do all dis bullshit.  Because of tha prompt without a newline,
yo dirty ass is gonna gotta use tha \f(CW\*(C`sysread\*(C'\fR variant of tha interactizzle client above.
.PP
This server accepts one of five different commands, bustin  output back to
the client.  Unlike most network servers, dis one handlez only one
incomin client at a time.  Multithreaded servers is covered up in 
Chapta 16 of tha Camel.
.PP
Herez tha code.  We bout ta
.PP
.Vb 3
\& #!/usr/bin/perl \-w
\& use IO::Socket;
\& use Net::hostent;      # fo' OOish version of gethostbyaddr
\&
\& $PORT = 9000;          # pick suttin' not up in use
\&
\& $server = IO::Socket::INET\->new( Proto     => "tcp",
\&                                  LocalPort => $PORT,
\&                                  Listen    => SOMAXCONN,
\&                                  Reuse     => 1);
\&
\& take a thugged-out dirtnap "can\*(Aqt setup server" unless $server;
\& print "[Server $0 acceptin clients]\en";
\&
\& while ($client = $server\->accept()) {
\&   $client\->autoflush(1);
\&   print $client "Yo, wuz crackalackin', biatch? Yo ass is smokin $0; type help fo' command list.\en";
\&   $hostinfo = gethostbyaddr($client\->peeraddr);
\&   printf "[Connect from %s]\en", $hostinfo , biatch? $hostinfo\->name : $client\->peerhost;
\&   print $client "Command, biatch? ";
\&   while ( <$client>) {
\&     next unless /\eS/;       # blank line
\&     if    (/quit|exit/i)    { last                                      }
\&     elsif (/date|time/i)    { printf $client "%s\en", scalar localtime() }
\&     elsif (/who/i )         { print  $client \`who 2>&1\`                 }
\&     elsif (/cookie/i )      { print  $client \`/usr/games/fortune 2>&1\`  }
\&     elsif (/motd/i )        { print  $client \`cat /etc/motd 2>&1\`       }
\&     else {
\&       print $client "Commands: quit date whoz ass cookie motd\en";
\&     }
\&   } continue {
\&      print $client "Command, biatch? ";
\&   }
\&   close $client;
\& }
.Ve
.SH "UDP: Message Passing"
.IX Header "UDP: Message Passing"
Another kind of client-server setup is one dat uses not connections yo, but
lyrics.  \s-1UDP\s0 communications involve much lower overhead but also provide
less reliability, as there be no promises dat lyrics will arrive at
all, let ridin' solo up in order n' unmangled. Y'all KNOW dat shit, muthafucka!  Still, \s-1UDP\s0 offers some advantages
over \s-1TCP,\s0 includin bein able ta \*(L"broadcast\*(R" or \*(L"multicast\*(R" ta a whole
bunch of destination hosts at once (usually on yo' local subnet).  If you
find yo ass overly concerned bout reliabilitizzle n' start buildin checks
into yo' message system, then you probably should use just \s-1TCP\s0 ta start
with.
.PP
\&\s-1UDP\s0 datagrams is \fInot\fR a funky-ass bytestream n' should not be treated as such.
This make rockin I/O mechanizzlez wit internal bufferin like stdio (i.e.
\&\fIprint()\fR n' playas) especially cumbersome. Use \fIsyswrite()\fR, or better
\&\fIsend()\fR, like up in tha example below.
.PP
Herez a \s-1UDP\s0 program similar ta tha sample Internizzle \s-1TCP\s0 client given
earlier n' shit.  But fuck dat shiznit yo, tha word on tha street is dat instead of checkin one host at a time, tha \s-1UDP\s0 version
will check nuff of dem asynchronously by simulatin a multicast n' then
usin \fIselect()\fR ta do a timed-out wait fo' I/O.  To do suttin' similar
with \s-1TCP,\s0 you'd gotta bust a gangbangin' finger-lickin' different socket handle fo' each host.
.PP
.Vb 4
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use Socket;
\&    use Sys::Hostname;
\&
\&    mah ( $count, $hisiaddr, $hispaddr, $histime,
\&         $host, $iaddr, $paddr, $port, $proto,
\&         $rin, $rout, $rtime, $SECS_OF_70_YEARS);
\&
\&    $SECS_OF_70_YEARS = 2_208_988_800;
\&
\&    $iaddr = gethostbyname(hostname());
\&    $proto = getprotobyname("udp");
\&    $port = getservbyname("time", "udp");
\&    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
\&
\&    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || take a thugged-out dirtnap "socket: $!";
\&    bind(SOCKET, $paddr)                          || take a thugged-out dirtnap "bind: $!";
\&
\&    $| = 1;
\&    printf "%\-12s %8s %s\en",  "localhost", 0, scalar localtime();
\&    $count = 0;
\&    fo' $host (@ARGV) {
\&        $count++;
\&        $hisiaddr = inet_aton($host)              || take a thugged-out dirtnap "unknown host";
\&        $hispaddr = sockaddr_in($port, $hisiaddr);
\&        defined(send(SOCKET, 0, 0, $hispaddr))    || take a thugged-out dirtnap "send $host: $!";
\&    }
\&
\&    $rin = "";
\&    vec($rin, fileno(SOCKET), 1) = 1;
\&
\&    # timeout afta 10.0 seconds
\&    while ($count && select($rout = $rin, undef, undef, 10.0)) {
\&        $rtime = "";
\&        $hispaddr = recv(SOCKET, $rtime, 4, 0)    || take a thugged-out dirtnap "recv: $!";
\&        ($port, $hisiaddr) = sockaddr_in($hispaddr);
\&        $host = gethostbyaddr($hisiaddr, AF_INET);
\&        $histime = unpack("N", $rtime) \- $SECS_OF_70_YEARS;
\&        printf "%\-12s ", $host;
\&        printf "%8d %s\en", $histime \- time(), scalar localtime($histime);
\&        $count\-\-;
\&    }
.Ve
.PP
This example do not include any retries n' may consequently fail to
contact a reachable host. Da most prominent reason fo' dis is congestion
of tha queues on tha bustin  host if tha number of hosts ta contact is
sufficiently large.
.SH "SysV IPC"
.IX Header "SysV IPC"
While System V \s-1IPC\s0 aint so widely used as sockets, it still has some
interestin uses.  But fuck dat shiznit yo, tha word on tha street is dat you cannot use SysV \s-1IPC\s0 or Berkeley \fImmap()\fR to
have a variable shared amongst nuff muthafuckin processes.  Thatz cuz Perl
would reallocate yo' strang when you weren't wantin it to.  Yo ass might
look tha fuck into tha \f(CW\*(C`IPC::Shareable\*(C'\fR or \f(CW\*(C`threads::shared\*(C'\fR modulez fo' dis shit.
.PP
Herez a lil' small-ass example showin shared memory usage.
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRUSR S_IWUSR);
\&
\&    $size = 2000;
\&    $id = shmget(IPC_PRIVATE, $size, S_IRUSR | S_IWUSR);
\&    defined($id)                    || take a thugged-out dirtnap "shmget: $!";
\&    print "shm key $id\en";
\&
\&    $message = "Message #1";
\&    shmwrite($id, $message, 0, 60)  || take a thugged-out dirtnap "shmwrite: $!";
\&    print "wrote: \*(Aq$message\*(Aq\en";
\&    shmread($id, $buff, 0, 60)      || take a thugged-out dirtnap "shmread: $!";
\&    print "read : \*(Aq$buff\*(Aq\en";
\&
\&    # tha buffer of shmread is zero\-characta end\-padded.
\&    substr($buff, index($buff, "\e0")) = "";
\&    print "un" unless $buff eq $message;
\&    print "swell\en";
\&
\&    print "deletin shm $id\en";
\&    shmctl($id, IPC_RMID, 0)        || take a thugged-out dirtnap "shmctl: $!";
.Ve
.PP
Herez a example of a semaphore:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_CREAT);
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 10, 0666 | IPC_CREAT);
\&    defined($id)                    || take a thugged-out dirtnap "semget: $!";
\&    print "sem id $id\en";
.Ve
.PP
Put dis code up in a separate file ta be run up in mo' than one process.
Call tha file \fItake\fR:
.PP
.Vb 1
\&    # create a semaphore
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    defined($id)                    || take a thugged-out dirtnap "semget: $!";
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # "take" semaphore
\&    # wait fo' semaphore ta be zero
\&    $semop = 0;
\&    $opstring1 = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    # Increment tha semaphore count
\&    $semop = 1;
\&    $opstring2 = pack("s!s!s!", $semnum, $semop,  $semflag);
\&    $opstrin  = $opstring1 . $opstring2;
\&
\&    semop($id, $opstring)   || take a thugged-out dirtnap "semop: $!";
.Ve
.PP
Put dis code up in a separate file ta be run up in mo' than one process.
Call dis file \fIgive\fR:
.PP
.Vb 3
\&    # "give" tha semaphore
\&    # run dis up in tha original gangsta process n' yo big-ass booty is ghon see
\&    # dat tha second process continues
\&
\&    $IPC_KEY = 1234;
\&    $id = semget($IPC_KEY, 0, 0);
\&    take a thugged-out dirtnap unless defined($id);
\&
\&    $semnum  = 0;
\&    $semflag = 0;
\&
\&    # Decrement tha semaphore count
\&    $semop = \-1;
\&    $opstrin = pack("s!s!s!", $semnum, $semop, $semflag);
\&
\&    semop($id, $opstring)   || take a thugged-out dirtnap "semop: $!";
.Ve
.PP
Da SysV \s-1IPC\s0 code above was freestyled long ago, n' itz definitely
clunky looking.  For a mo' modern look, peep tha IPC::SysV module.
.PP
A lil' small-ass example demonstratin SysV message queues:
.PP
.Vb 1
\&    use IPC::SysV qw(IPC_PRIVATE IPC_RMID IPC_CREAT S_IRUSR S_IWUSR);
\&
\&    mah $id = msgget(IPC_PRIVATE, IPC_CREAT | S_IRUSR | S_IWUSR);
\&    defined($id)                || take a thugged-out dirtnap "msgget failed: $!";
\&
\&    mah $sent      = "message";
\&    mah $type_sent = 1234;
\&
\&    msgsnd($id, pack("l! a*", $type_sent, $sent), 0)
\&                                || take a thugged-out dirtnap "msgsnd failed: $!";
\&
\&    msgrcv($id, mah $rcvd_buf, 60, 0, 0)
\&                                || take a thugged-out dirtnap "msgrcv failed: $!";
\&
\&    my($type_rcvd, $rcvd) = unpack("l! a*", $rcvd_buf);
\&
\&    if ($rcvd eq $sent) {
\&        print "okay\en";
\&    } else {
\&        print "not aiiight\en";
\&    }
\&
\&    msgctl($id, IPC_RMID, 0)    || take a thugged-out dirtnap "msgctl failed: $!\en";
.Ve
.SH "NOTES"
.IX Header "NOTES"
Most of these routines on tha fuckin' down-lowly but politely return \f(CW\*(C`undef\*(C'\fR when they
fail instead of causin yo' program ta take a thugged-out dirtnap right then n' there due to
an uncaught exception. I aint talkin' bout chicken n' gravy biatch.  (Actually, a shitload of tha freshly smoked up \fISocket\fR conversion
functions do \fIcroak()\fR on wack arguments.)  It be therefore essential to
check return joints from these functions.  Always begin yo' socket
programs dis way fo' optimal success, n' don't forget ta add tha \fB\-T\fR
taint-checkin flag ta tha \f(CW\*(C`#!\*(C'\fR line fo' servers:
.PP
.Vb 4
\&    #!/usr/bin/perl \-Tw
\&    use strict;
\&    use sigtrap;
\&    use Socket;
.Ve
.SH "BUGS"
.IX Header "BUGS"
These routines all create system-specific portabilitizzle problems.  As noted
elsewhere, Perl be all up in tha mercy of yo' C libraries fo' much of its system
behavior. Shiiit, dis aint no joke.  It aint nuthin but probably safest ta assume fucked up SysV semantics for
signals n' ta stick wit simple \s-1TCP\s0 n' \s-1UDP\s0 socket operations; e.g., don't
try ta pass open file descriptors over a local \s-1UDP\s0 datagram socket if you
want yo' code ta stand a cold-ass lil chizzle of bein portable.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tomothy Christiansen, wit occasionizzle vestigez of Larry Wallz original
version n' suggestions from tha Perl Porters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Therez a shitload mo' ta networkin than dis yo, but dis should git you
started.
.PP
For intrepid programmers, tha indispensable textbook is \fIUnix Network
Programming, 2nd Edition, Volume 1\fR by W. Right back up in yo muthafuckin ass. Slick Rick Stevens (published by
Prentice-Hall).  Most books on networkin address tha subject from the
perspectizzle of a C programmer; translation ta Perl is left as a exercise
for tha reader.
.PP
Da \fIIO::Socket\fR\|(3) manpage raps bout tha object library, n' tha \fISocket\fR\|(3)
manpage raps bout tha low-level intercourse ta sockets, n' you can put dat on yo' toast.  Besides tha obvious
functions up in perlfunc, you should also check up tha \fImodules\fR file at
your nearest \s-1CPAN\s0 crib, especially
<http://www.cpan.org/modules/00modlist.long.html#ID5_Networking_>.  
See perlmodlib or dopest yet, tha \fIPerl \s-1FAQ\s0\fR fo' a thugged-out description
of what tha fuck \s-1CPAN\s0 be n' where ta git it if tha previous link don't work 
for yo thugged-out ass.
.PP
Section 5 of \s-1CPAN\s0z \fImodules\fR file is devoted ta \*(L"Networking, Device
Control (modems), n' Interprocess Communication\*(R", n' gotz nuff a shitload of
unbundled modulez a shitload of networkin modules, Chat n' Expect operations,
\&\s-1CGI\s0 programming, \s-1DCE, FTP, IPC, NNTP,\s0 Proxy, Ptty, \s-1RPC, SNMP, SMTP,\s0 Telnet,
Threads, n' ToolTalk\*(--to name just a gangbangin' few.
