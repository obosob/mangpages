.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLHACKTIPS 1"
.TH PERLHACKTIPS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlhacktips \- Tips fo' Perl core C code hacking
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document will help you learn tha dopest way ta go bout jackin on
the Perl core C code. Well shiiiit, it covers common problems, debugging, profiling,
and more.
.PP
If you aint read perlhack n' perlhacktut yet, you might want
to do dat first.
.SH "COMMON PROBLEMS"
.IX Header "COMMON PROBLEMS"
Perl source skits by \s-1ANSI C89\s0 rules: no C99 (or \*(C+) extensions. In
some cases we gotta take pre-ANSI requirements tha fuck into consideration.
Yo ass couldn't give a fuckin shiznit bout some particular platform havin fucked up Perl, biatch? I
hear there is still a phat demand fo' J2EE programmers.
.SS "Perl environment problems"
.IX Subsection "Perl environment problems"
.IP "\(bu" 4
Not compilin wit threading
.Sp
Compilin wit threadin (\-Duseithreads) straight-up rewrites the
function prototypez of Perl. Yo ass betta try yo' chizzlez wit dis shit.
Related ta dis is tha difference between \*(L"Perl_\-less\*(R" n' \*(L"Perl_\-ly\*(R"
APIs, fo' example:
.Sp
.Vb 2
\&  Perl_sv_setiv(aTHX_ ...);
\&  sv_setiv(...);
.Ve
.Sp
Da first one explicitly passes up in tha context, which is needed for
e.g. threaded builds. Da second one do dat implicitly; do not get
them mixed. Y'all KNOW dat shit, muthafucka! If yo ass is not passin up in a aTHX_, yo big-ass booty is ghon need ta do a
dTHX (or a thugged-out dVAR) as tha straight-up original gangsta thang up in tha function.
.Sp
See \*(L"How tha fuck multiple interpretas n' concurrency are
supported\*(R" up in perlguts fo' further rap bout context.
.IP "\(bu" 4
Not compilin wit \-DDEBUGGING
.Sp
Da \s-1DEBUGGING\s0 define exposes mo' code ta tha compiler, therefore more
ways fo' thangs ta go wrong. Yo ass should try dat shit.
.IP "\(bu" 4
Introducin (non-read-only) globals
.Sp
Do not introduce any modifiable globals, truly global or file static.
They is wack form n' complicate multithreadin n' other forms of
concurrency. Da right way is ta introduce dem as freshly smoked up interpreter
variables, peep \fIintrpvar.h\fR (at tha straight-up end fo' binary
compatibility).
.Sp
Introducin read-only (const) globals be all gravy, as long as you verify
with e.g. \f(CW\*(C`nm libperl.a|egrep \-v \*(Aq [TURtr] \*(Aq\*(C'\fR (if yo' \f(CW\*(C`nm\*(C'\fR has
BSD-style output) dat tha data you added straight-up is read-only. (If it
is, it shouldn't show up in tha output of dat command.)
.Sp
If you wanna have static strings, make dem constant:
.Sp
.Vb 1
\&  static const char etc[] = "...";
.Ve
.Sp
If you wanna have arrayz of constant strings, note carefully the
right combination of \f(CW\*(C`const\*(C'\fRs:
.Sp
.Vb 2
\&    static const char * const yippee[] =
\&        {"hi", "ho", "silver"};
.Ve
.Sp
There be a way ta straight-up hide any modifiable globals (they is all
moved ta heap), tha compilation setting
\&\f(CW\*(C`\-DPERL_GLOBAL_STRUCT_PRIVATE\*(C'\fR. Well shiiiit, it aint normally used yo, but can be
used fo' testing, read mo' bout it up in \*(L"Background and
\&\s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 up in perlguts.
.IP "\(bu" 4
Not exportin yo' freshly smoked up function
.Sp
Some platforms (Win32, \s-1AIX, VMS, OS/2,\s0 ta name a gangbangin' few) require any
function dat is part of tha hood \s-1API \s0(the shared Perl library) ta be
explicitly marked as exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. See tha rap bout \fIembed.pl\fR in
perlguts.
.IP "\(bu" 4
Exportin yo' freshly smoked up function
.Sp
Da freshly smoked up shiny result of either genuine freshly smoked up functionalitizzle or your
arduous refactorin is now locked n loaded n' erectly exported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. So what tha fuck could
possibly go wrong?
.Sp
Maybe simply dat yo' function did not need ta be exported up in the
first place. Perl has a long-ass n' not so glorious history of exporting
functions dat it should not have.
.Sp
If tha function is used only inside one source code file, make it
static. Right back up in yo muthafuckin ass. See tha rap bout \fIembed.pl\fR up in perlguts.
.Sp
If tha function is used across nuff muthafuckin filez yo, but intended only for
Perlz internal use (and dis should be tha common case), do not export
it ta tha hood \s-1API.\s0 See tha rap bout \fIembed.pl\fR in
perlguts.
.SS "Portabilitizzle problems"
.IX Subsection "Portabilitizzle problems"
Da followin is common causez of compilation and/or execution
failures, not common ta Perl as such. Da C \s-1FAQ\s0 is phat bedtime
reading. Please test yo' chizzlez wit as nuff C compilaz and
platforms as possible; we will, anyway, n' itz sick ta save oneself
from hood embarrassment.
.PP
If rockin gcc, you can add tha \f(CW\*(C`\-std=c89\*(C'\fR option which will hopefully
catch most of these unportabilities. Put ya muthafuckin choppers up if ya feel dis! (However it might also catch
incompatibilitizzles up in yo' systemz header files.)
.PP
Use tha Configure \f(CW\*(C`\-Dgccansipedantic\*(C'\fR flag ta enable tha gcc \f(CW\*(C`\-ansi
\&\-pedantic\*(C'\fR flags which enforce stricta \s-1ANSI\s0 rules.
.PP
If rockin tha \f(CW\*(C`gcc \-Wall\*(C'\fR note dat not all tha possible warnings (like
\&\f(CW\*(C`\-Wunitialized\*(C'\fR) is given unless you also compile wit \f(CW\*(C`\-O\*(C'\fR.
.PP
Note dat if rockin gcc, startin from Perl 5.9.5 tha Perl core source
code filez (the ones all up in tha top level of tha source code distribution,
but not e.g. tha extensions under ext/) is automatically compiled with
as nuff as possible of tha \f(CW\*(C`\-std=c89\*(C'\fR, \f(CW\*(C`\-ansi\*(C'\fR, \f(CW\*(C`\-pedantic\*(C'\fR, n' a
selection of \f(CW\*(C`\-W\*(C'\fR flags (see cflags.SH).
.PP
Also study perlport carefully ta avoid any wack assumptions bout the
operatin system, filesystems, n' so forth.
.PP
Yo ass may once up in a while try a \*(L"make microperl\*(R" ta peep whether we can
still compile Perl wit just tha bare minimum of intercourses. (See
\&\s-1README\s0.micro.)
.PP
Do not assume a operatin system indicates a cold-ass lil certain compiler.
.IP "\(bu" 4
Castin pointas ta integers or castin integers ta pointers
.Sp
.Vb 3
\&    void castaway(U8* p)
\&    {
\&      IV i = p;
.Ve
.Sp
or
.Sp
.Vb 3
\&    void castaway(U8* p)
\&    {
\&      IV i = (IV)p;
.Ve
.Sp
Both is bad, n' broken, n' unportable. Use tha \s-1\fIPTR2IV\s0()\fR macro that
does it right. (Likewise, there be \s-1\fIPTR2UV\s0()\fR, \s-1\fIPTR2NV\s0()\fR, \s-1\fIINT2PTR\s0()\fR, and
\&\s-1\fINUM2PTR\s0()\fR.)
.IP "\(bu" 4
Castin between data function pointas n' data pointers
.Sp
Technically bustin lyrics castin between function pointas n' data
pointas is unportable n' undefined yo, but practically bustin lyrics it seems
to work yo, but you should use tha \s-1\fIFPTR2DPTR\s0()\fR n' \s-1\fIDPTR2FPTR\s0()\fR macros.
Sometimes you can also play game wit unions.
.IP "\(bu" 4
Assumin sizeof(int) == sizeof(long)
.Sp
There is platforms where longs is 64 bits, n' platforms where ints
are 64 bits, n' while we is up ta shock you, even platforms where
shorts is 64 bits, n' you can put dat on yo' toast. This be all legal accordin ta tha C standard. Y'all KNOW dat shit, muthafucka! (In
other lyrics, \*(L"long long\*(R" aint a portable way ta specify 64 bits, and
\&\*(L"long long\*(R" aint even guaranteed ta be any wider than \*(L"long\*(R".)
.Sp
Instead, use tha definitions \s-1IV, UV, IVSIZE, I32SIZE,\s0 n' so forth.
Avoid thangs like I32 cuz they is \fBnot\fR guaranteed ta be
\&\fIexactly\fR 32 bits, they is \fIat least\fR 32 bits, nor is they
guaranteed ta be \fBint\fR or \fBlong\fR. If you straight-up explicitly need
64\-bit variables, use I64 n' U64 yo, but only if guarded by \s-1HAS_QUAD.\s0
.IP "\(bu" 4
Assumin one can dereference any type of pointa fo' any type of data
.Sp
.Vb 2
\&  char *p = ...;
\&  long pony = *p;    /* BAD */
.Ve
.Sp
Many platforms, like rightly so, will hit you wit a cold-ass lil core dump instead of
a pony if tha p happens not ta be erectly aligned.
.IP "\(bu" 4
Lvalue casts
.Sp
.Vb 1
\&  (int)*p = ...;    /* BAD */
.Ve
.Sp
Simply not portable. Git yo' lvalue ta be of tha right type, or maybe
use temporary variables, or dirty tricks wit unions.
.IP "\(bu" 4
Assume \fBanything\fR bout structs (especially tha ones you don't
control, like tha ones comin from tha system headers)
.RS 4
.IP "\(bu" 8
That a cold-ass lil certain field exists up in a struct
.IP "\(bu" 8
That no other fieldz exist besides tha ones you know of
.IP "\(bu" 8
That a gangbangin' field iz of certain signedness, sizeof, or type
.IP "\(bu" 8
That tha fieldz is up in a cold-ass lil certain order
.RS 8
.IP "\(bu" 8
While C guarantees tha orderin specified up in tha struct definition,
between different platforms tha definitions might differ
.RE
.RS 8
.RE
.IP "\(bu" 8
That tha sizeof(struct) or tha alignments is tha same everywhere
.RS 8
.IP "\(bu" 8
There might be paddin bytes between tha fieldz ta align tha fieldz \-
the bytes can be anything
.IP "\(bu" 8
Structs is required ta be aligned ta tha maximum alignment required by
the fieldz \- which fo' natizzle types is fo' probably equivalent to
\&\fIsizeof()\fR of tha field
.RE
.RS 8
.RE
.RE
.RS 4
.RE
.IP "\(bu" 4
Assumin tha characta set is ASCIIish
.Sp
Perl can compile n' run under \s-1EBCDIC\s0 platforms. Right back up in yo muthafuckin ass. See perlebcdic.
This is transparent fo' da most thugged-out part yo, but cuz tha characta sets
differ, you shouldn't use numeric (decimal, octal, nor hex) constants
to refer ta characters. Yo ass can safely say 'A' yo, but not 0x41. Yo ass can
safely say '\en' yo, but not \e012. If a cold-ass lil characta aint gots a trivial
input form, you should add it ta tha list in
\&\fIregen/unicode_constants.pl\fR, n' have Perl create #defines fo' you,
based on tha current platform.
.Sp
Also, tha range 'A' \- 'Z' up in \s-1ASCII\s0 be a unbroken sequence of 26 upper
case alphabetic characters. That aint legit up in \s-1EBCDIC.\s0 Nor fo' 'a' to
\&'z'. But '0' \- '9' be a unbroken range up in both systems. Don't assume
anythang bout other ranges.
.Sp
Many of tha comments up in tha existin code ignore tha possibilitizzle of
\&\s-1EBCDIC,\s0 n' may be wack therefore, even if tha code works. This is
actually a tribute ta tha successful transparent insertion of being
able ta handle \s-1EBCDIC\s0 without havin ta chizzle pre-existin code.
.Sp
\&\s-1UTF\-8\s0 n' UTF-EBCDIC is two different encodings used ta represent
Unicode code points as sequencez of bytes. Macros  wit tha same names
(but different definitions) up in \f(CW\*(C`utf8.h\*(C'\fR n' \f(CW\*(C`utfebcdic.h\*(C'\fR is used to
allow tha callin code ta be thinkin dat there is only one such encoding.
This be almost always referred ta as \f(CW\*(C`utf8\*(C'\fR yo, but it means tha \s-1EBCDIC\s0
version as well fo' realz. Again, comments up in tha code may well be wack even if
the code itself is right. For example, tha concept of \f(CW\*(C`invariant
characters\*(C'\fR differs between \s-1ASCII\s0 n' \s-1EBCDIC.\s0 On \s-1ASCII\s0 platforms, only
charactas dat aint gots tha high-order bit set (i.e. whose ordinals
are strict \s-1ASCII, 0 \- 127\s0) is invariant, n' tha documentation and
comments up in tha code may assume that, often referrin ta something
like, say, \f(CW\*(C`hibit\*(C'\fR. Da thang differs n' aint so simple on
\&\s-1EBCDIC\s0 machines yo, but as long as tha code itself uses the
\&\f(CW\*(C`NATIVE_IS_INVARIANT()\*(C'\fR macro appropriately, it works, even if the
comments is wrong.
.IP "\(bu" 4
Assumin tha characta set is just \s-1ASCII\s0
.Sp
\&\s-1ASCII\s0 be a 7 bit encodin yo, but bytes have 8 bits up in em. Da 128 extra
charactas have different meanings dependin on tha locale.  Absent a
locale, currently these extra charactas is generally considered ta be
unassigned, n' dis has presented some problems. This is bein chizzled
startin up in 5.12 so dat these charactas is ghon be considered ta be
Latin\-1 (\s-1ISO\-8859\-1\s0).
.IP "\(bu" 4
Mixin #define n' #ifdef
.Sp
.Vb 6
\&  #define BURGLE(x) ... \e
\&  #ifdef BURGLE_OLD_STYLE        /* BAD */
\&  ... do it tha oldschool way ... \e
\&  #else
\&  ... do it tha freshly smoked up way ... \e
\&  #endif
.Ve
.Sp
Yo ass cannot portably \*(L"stack\*(R" cpp directives. For example up in tha above
you need two separate \s-1\fIBURGLE\s0()\fR #defines, one fo' each #ifdef branch.
.IP "\(bu" 4
Addin non-comment shiznit afta #endif or #else
.Sp
.Vb 5
\&  #ifdef SNOSH
\&  ...
\&  #else !SNOSH    /* BAD */
\&  ...
\&  #endif SNOSH    /* BAD */
.Ve
.Sp
Da #endif n' #else cannot portably have anythang non-comment after
them. If you wanna document what tha fuck is goin (which be a phat idea
especially if tha branches is long), use (C) comments:
.Sp
.Vb 5
\&  #ifdef SNOSH
\&  ...
\&  #else /* !SNOSH */
\&  ...
\&  #endif /* SNOSH */
.Ve
.Sp
Da gcc option \f(CW\*(C`\-Wendif\-labels\*(C'\fR warns bout tha wack variant (by
default on startin from Perl 5.9.4).
.IP "\(bu" 4
Havin a cold-ass lil comma afta tha last element of a enum list
.Sp
.Vb 5
\&  enum color {
\&    CERULEAN,
\&    CHARTREUSE,
\&    CINNABAR,     /* BAD */
\&  };
.Ve
.Sp
is not portable. Leave up tha last comma.
.Sp
Also note dat whether enums is implicitly morphable ta ints varies
between compilers, you might need ta (int).
.IP "\(bu" 4
Usin //\-comments
.Sp
.Vb 1
\&  // This function bamfoodlez tha zorklator. Shiiit, dis aint no joke.   /* BAD */
.Ve
.Sp
That is C99 or \*(C+. Perl is C89. Usin tha //\-comments is silently
allowed by nuff C compilaz but crankin up tha \s-1ANSI C89\s0 strictness
(which our slick asses like ta do) causes tha compilation ta fail.
.IP "\(bu" 4
Mixin declarations n' code
.Sp
.Vb 5
\&  void zorklator()
\&  {
\&    int n = 3;
\&    set_zorkmids(n);    /* BAD */
\&    int q = 4;
.Ve
.Sp
That is C99 or \*(C+. Right back up in yo muthafuckin ass. Some C compilaz allow dat yo, but you shouldn't.
.Sp
Da gcc option \f(CW\*(C`\-Wdeclaration\-after\-statements\*(C'\fR scans fo' such
problems (by default on startin from Perl 5.9.4).
.IP "\(bu" 4
Introducin variablez inside \fIfor()\fR
.Sp
.Vb 1
\&  for(int i = ...; ...; ...) {    /* BAD */
.Ve
.Sp
That is C99 or \*(C+. While it would indeed be awfully sick ta have that
also up in C89, ta limit tha scope of tha loop variable, alas, we cannot.
.IP "\(bu" 4
Mixin signed char pointas wit unsigned char pointers
.Sp
.Vb 4
\&  int foo(char *s) { ... }
\&  ...
\&  unsigned char *t = ...; /* Or U8* t = ... */
\&  foo(t);   /* BAD */
.Ve
.Sp
While dis is legal practice, it is certainly dubious, n' downright
fatal up in at least one platform: fo' example \s-1VMS\s0 cc considaz dis a
fatal error. Shiiit, dis aint no joke. One cause fo' playas often makin dis fuck up is dat a
\&\*(L"naked char\*(R" n' therefore dereferencin a \*(L"naked char pointer\*(R" have an
undefined signedness: it dependz on tha compila n' tha flagz of the
compila n' tha underlyin platform whether tha result is signed or
unsigned. Y'all KNOW dat shit, muthafucka! For dis straight-up same reason rockin a 'char' as a array index is
bad.
.IP "\(bu" 4
Macros dat have strang constants n' they arguments as substrings of
the strang constants
.Sp
.Vb 2
\&  #define FOO(n) printf("number = %d\en", n)    /* BAD */
\&  FOO(10);
.Ve
.Sp
Pre-ANSI semantics fo' dat was equivalent to
.Sp
.Vb 1
\&  printf("10umber = %d\e10");
.Ve
.Sp
which is probably not what tha fuck you was expecting. Unfortunately at least
one reasonably common n' modern C compila do \*(L"real backward
compatibility\*(R" here, up in \s-1AIX\s0 dat is what tha fuck still happens even though the
rest of tha \s-1AIX\s0 compila is straight-up happily C89.
.IP "\(bu" 4
Usin printf formats fo' non-basic C types
.Sp
.Vb 2
\&   IV i = ...;
\&   printf("i = %d\en", i);    /* BAD */
.Ve
.Sp
While dis might by accident work up in some platform (where \s-1IV\s0 happens to
be a \f(CW\*(C`int\*(C'\fR), up in general it cannot. \s-1IV\s0 might be suttin' larger n' shit. Even
worse tha thang is wit mo' specific types (defined by Perl's
configuration step up in \fIconfig.h\fR):
.Sp
.Vb 2
\&   Uid_t whoz ass = ...;
\&   printf("who = %d\en", who);    /* BAD */
.Ve
.Sp
Da problem here is dat Uid_t might be not only not \f(CW\*(C`int\*(C'\fR\-wide but it
might also be unsigned, up in which case big-ass uidz would be printed as
negatizzle joints.
.Sp
There is no simple solution ta dis cuz of \fIprintf()\fRz limited
intelligence yo, but fo' nuff types tha right format be available as with
either 'f' or '_f' suffix, fo' example:
.Sp
.Vb 2
\&   IVdf /* IV up in decimal */
\&   UVxf /* UV is hexadecimal */
\&
\&   printf("i = %"IVdf"\en", i); /* Da IVdf be a strang constant. */
\&
\&   Uid_t_f /* Uid_t up in decimal */
\&
\&   printf("who = %"Uid_t_f"\en", who);
.Ve
.Sp
Or you can try castin ta a \*(L"wide enough\*(R" type:
.Sp
.Vb 1
\&   printf("i = %"IVdf"\en", (IV)something_very_small_and_signed);
.Ve
.Sp
Also remember dat tha \f(CW%p\fR format straight-up do require a void pointer:
.Sp
.Vb 2
\&   U8* p = ...;
\&   printf("p = %p\en", (void*)p);
.Ve
.Sp
Da gcc option \f(CW\*(C`\-Wformat\*(C'\fR scans fo' such problems.
.IP "\(bu" 4
Blindly rockin variadic macros
.Sp
gcc has had dem fo' a while wit its own syntax, n' C99 brought them
with a standardized syntax. Don't use tha former, n' use tha latter
only if tha \s-1HAS_C99_VARIADIC_MACROS\s0 is defined.
.IP "\(bu" 4
Blindly passin va_list
.Sp
Not all platforms support passin va_list ta further varargs (stdarg)
functions. Da right thang ta do is ta copy tha va_list rockin the
\&\fIPerl_va_copy()\fR if tha \s-1NEED_VA_COPY\s0 is defined.
.IP "\(bu" 4
Usin gcc statement expressions
.Sp
.Vb 1
\&   val = ({...;...;...});    /* BAD */
.Ve
.Sp
While a sick extension, it aint portable. Da Perl code do
admittedly use dem if available ta bust some extra speed (essentially
as a gangbangin' funky form of inlining) yo, but you shouldn't.
.IP "\(bu" 4
Bindin together nuff muthafuckin statements up in a macro
.Sp
Use tha macros \s-1STMT_START\s0 n' \s-1STMT_END.\s0
.Sp
.Vb 3
\&   STMT_START {
\&      ...
\&   } STMT_END
.Ve
.IP "\(bu" 4
Testin fo' operatin systems or versions when should be testin for
features
.Sp
.Vb 3
\&  #ifdef _\|_FOONIX_\|_    /* BAD */
\&  foo = quux();
\&  #endif
.Ve
.Sp
Unless you know wit 100% certainty dat \fIquux()\fR is only eva available
for tha \*(L"Foonix\*(R" operatin system \fBand\fR dat be available \fBand\fR
correctly hustlin fo' \fBall\fR past, present, \fBand\fR future versions of
\&\*(L"Foonix\*(R", tha above is straight-up wrong. This is mo' erect (though still
not perfect, cuz tha below be a cold-ass lil compile-time check):
.Sp
.Vb 3
\&  #ifdef HAS_QUUX
\&  foo = quux();
\&  #endif
.Ve
.Sp
How tha fuck do tha \s-1HAS_QUUX\s0 become defined where it need ta be, biatch?  Well, if
Foonix happens ta be Unixy enough ta be able ta run tha Configure
script, n' Configure has been taught bout detectin n' testing
\&\fIquux()\fR, tha \s-1HAS_QUUX\s0 is ghon be erectly defined. Y'all KNOW dat shit, muthafucka! In other platforms, the
correspondin configuration step will hopefully do tha same.
.Sp
In a pinch, if you cannot wait fo' Configure ta be educated, or if you
have a phat hunch of where \fIquux()\fR might be available, you can
temporarily try tha following:
.Sp
.Vb 3
\&  #if (defined(_\|_FOONIX_\|_) || defined(_\|_BARNIX_\|_))
\&  # define HAS_QUUX
\&  #endif
\&
\&  ...
\&
\&  #ifdef HAS_QUUX
\&  foo = quux();
\&  #endif
.Ve
.Sp
But up in any case, try ta keep tha features n' operatin systems
separate.
.SS "Problematic System Interfaces"
.IX Subsection "Problematic System Interfaces"
.IP "\(bu" 4
\&\fImalloc\fR\|(0), \fIrealloc\fR\|(0), calloc(0, 0) is non-portable. To be portable
allocate at least one byte. (In general you should rarely need ta work
at dis low level yo, but instead use tha various malloc wrappers.)
.IP "\(bu" 4
\&\fIsnprintf()\fR \- tha return type is unportable. Use \fImy_snprintf()\fR instead.
.SS "Securitizzle problems"
.IX Subsection "Securitizzle problems"
Last but not least, here is various tips fo' less thuggy coding.
.IP "\(bu" 4
Do not use \fIgets()\fR
.Sp
Or we will publicly ridicule yo thugged-out ass. Right back up in yo muthafuckin ass. Seriously.
.IP "\(bu" 4
Do not use \fIstrcpy()\fR or \fIstrcat()\fR or \fIstrncpy()\fR or \fIstrncat()\fR
.Sp
Use \fImy_strlcpy()\fR n' \fImy_strlcat()\fR instead: they either use tha native
implementation, or Perlz own implementation (borrowed from tha public
domain implementation of \s-1INN\s0).
.IP "\(bu" 4
Do not use \fIsprintf()\fR or \fIvsprintf()\fR
.Sp
If you straight-up want just plain byte strings, use \fImy_snprintf()\fR and
\&\fImy_vsnprintf()\fR instead, which will try ta use \fIsnprintf()\fR and
\&\fIvsnprintf()\fR if dem less thuggy APIs is available. If you want something
fancier than a plain byte string, use SVs n' \fIPerl_sv_catpvf()\fR.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
Yo ass can compile a special debuggin version of Perl, which allows you
to use tha \f(CW\*(C`\-D\*(C'\fR option of Perl ta tell mo' bout what tha fuck Perl is bustin.
But sometimes there is no alternatizzle than ta dive up in wit a thugged-out debugger,
either ta peep tha stack trace of a cold-ass lil core dump (very useful up in a funky-ass bug
report), or tryin ta figure up what tha fuck went wack before tha core dump
happened, or how tha fuck did we end up havin wack or unexpected thangs up in dis biatch.
.SS "Pokin at Perl"
.IX Subsection "Pokin at Perl"
To straight-up poke round wit Perl, you gonna probably wanna build Perl for
debugging, like this:
.PP
.Vb 2
\&    ./Configure \-d \-D optimize=\-g
\&    make
.Ve
.PP
\&\f(CW\*(C`\-g\*(C'\fR be a gangbangin' flag ta tha C compila ta have it produce debugging
information which will allow our asses ta step all up in a hustlin program, and
to peep up in which C function we is at (without tha debuggin shiznit
we might peep only tha numerical addressez of tha functions, which is
not straight-up helpful).
.PP
\&\fIConfigure\fR will also turn on tha \f(CW\*(C`DEBUGGING\*(C'\fR compilation symbol
which enablez all tha internal debuggin code up in Perl. There is a
whole bunch of thangs you can debug wit this: perlrun lists them
all, n' tha dopest way ta smoke up bout dem is ta play bout with
them. Da most useful options is probably
.PP
.Vb 4
\&    l  Context (loop) stack processing
\&    t  Trace execution
\&    o  Method n' overloadin resolution
\&    c  String/numeric conversions
.Ve
.PP
Some of tha functionalitizzle of tha debuggin code can be  bigged up  using
\&\s-1XS\s0 modules.
.PP
.Vb 2
\&    \-Dr => use re \*(Aqdebug\*(Aq
\&    \-Dx => use O \*(AqDebug\*(Aq
.Ve
.SS "Usin a source-level debugger"
.IX Subsection "Usin a source-level debugger"
If tha debuggin output of \f(CW\*(C`\-D\*(C'\fR don't help you, itz time ta step
all up in perlz execution wit a source-level debugger.
.IP "\(bu" 3
We bout ta use \f(CW\*(C`gdb\*(C'\fR fo' our examplez here; tha principlez will apply to
any debugger (many vendors call they debugger \f(CW\*(C`dbx\*(C'\fR) yo, but check the
manual of tha one you using.
.PP
To fire up tha debugger, type
.PP
.Vb 1
\&    gdb ./perl
.Ve
.PP
Or if you gotz a cold-ass lil core dump:
.PP
.Vb 1
\&    gdb ./perl core
.Ve
.PP
You'll wanna do dat up in yo' Perl source tree so tha debugger can
read tha source code. Yo ass should peep tha copyright message, followed by
the prompt.
.PP
.Vb 1
\&    (gdb)
.Ve
.PP
\&\f(CW\*(C`help\*(C'\fR will git you tha fuck into tha documentation yo, but here is da most thugged-out
useful commands:
.IP "\(bu" 3
run [args]
.Sp
Run tha program wit tha given arguments.
.IP "\(bu" 3
break function_name
.IP "\(bu" 3
break source.c:xxx
.Sp
Tells tha debugger dat we'll wanna pause execution when we reach
either tha named function (but peep \*(L"Internal Functions\*(R" up in perlguts!) or
the given line up in tha named source file.
.IP "\(bu" 3
step
.Sp
Steps all up in tha program a line at a time.
.IP "\(bu" 3
next
.Sp
Steps all up in tha program a line at a time, without descendin into
functions.
.IP "\(bu" 3
continue
.Sp
Run until tha next breakpoint.
.IP "\(bu" 3
finish
.Sp
Run until tha end of tha current function, then stop again.
.IP "\(bu" 3
\&'enter'
.Sp
Just pressin Enta will do da most thugged-out recent operation again n' again n' again \- itz a
blessin when steppin all up in milez of source code.
.IP "\(bu" 3
print
.Sp
Execute tha given C code n' print its thangs up in dis biatch. \fB\s-1WARNING\s0\fR: Perl makes
heavy use of macros, n' \fIgdb\fR do not necessarily support macros
(see lata \*(L"gdb macro support\*(R"). You'll gotta substitute them
yo ass, or ta invoke cpp on tha source code filez (see \*(L"Da .i
Targets\*(R") So, fo' instance, you can't say
.Sp
.Vb 1
\&    print SvPV_nolen(sv)
.Ve
.Sp
but you gotta say
.Sp
.Vb 1
\&    print Perl_sv_2pv_nolen(sv)
.Ve
.PP
Yo ass may find it helpful ta git a \*(L"macro dictionary\*(R", which you can
produce by sayin \f(CW\*(C`cpp \-dM perl.c | sort\*(C'\fR. Even then, \fIcpp\fR won't
recursively apply dem macros fo' yo thugged-out ass.
.SS "gdb macro support"
.IX Subsection "gdb macro support"
Recent versionz of \fIgdb\fR have fairly phat macro support yo, but up in order
to use it you gonna need ta compile perl wit macro definitions included
in tha debuggin shiznit. I aint talkin' bout chicken n' gravy biatch. Usin \fIgcc\fR version 3.1, dis means
configurin wit \f(CW\*(C`\-Doptimize=\-g3\*(C'\fR. Other compilaz might use a
different switch (if they support debuggin macros at all).
.SS "Dumpin Perl Data Structures"
.IX Subsection "Dumpin Perl Data Structures"
One way ta git round dis macro hell is ta use tha dumpin functions
in \fIdump.c\fR; these work a lil like a internal
Devel::Peek yo, but they also cover OPs n' other
structures dat you can't git at from Perl. Letz take a example.
We bout ta use tha \f(CW\*(C`$a = $b + $c\*(C'\fR we used before yo, but give it a lil' bit of
context: \f(CW\*(C`$b = "6XXXX"; $c = 2.3;\*(C'\fR. Wherez a phat place ta stop and
poke around?
.PP
What bout \f(CW\*(C`pp_add\*(C'\fR, tha function we examined earlier ta implement the
\&\f(CW\*(C`+\*(C'\fR operator:
.PP
.Vb 2
\&    (gdb) break Perl_pp_add
\&    Breakpoint 1 at 0x46249f: file pp_hot.c, line 309.
.Ve
.PP
Notice we use \f(CW\*(C`Perl_pp_add\*(C'\fR n' not \f(CW\*(C`pp_add\*(C'\fR \- see
\&\*(L"Internal Functions\*(R" up in perlguts, n' you can put dat on yo' toast. With tha breakpoint up in place, we can
run our program:
.PP
.Vb 1
\&    (gdb) run \-e \*(Aq$b = "6XXXX"; $c = 2.3; $a = $b + $c\*(Aq
.Ve
.PP
Lotz of junk will go past as gdb readz up in tha relevant source filez and
libraries, n' then:
.PP
.Vb 5
\&    Breakpoint 1, Perl_pp_add () at pp_hot.c:309
\&    309         dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
\&    (gdb) step
\&    311           dPOPTOPnnrl_ul;
\&    (gdb)
.Ve
.PP
We looked at dis bit of code before, n' we holla'd that
\&\f(CW\*(C`dPOPTOPnnrl_ul\*(C'\fR arranges fo' two \f(CW\*(C`NV\*(C'\fRs ta be placed tha fuck into \f(CW\*(C`left\*(C'\fR and
\&\f(CW\*(C`right\*(C'\fR \- letz slightly expand it:
.PP
.Vb 3
\& #define dPOPTOPnnrl_ul  NV right = POPn; \e
\&                         SV *leftsv = TOPs; \e
\&                         NV left = USE_LEFT(leftsv) , biatch? SvNV(leftsv) : 0.0
.Ve
.PP
\&\f(CW\*(C`POPn\*(C'\fR takes tha \s-1SV\s0 from tha top of tha stack n' obtains its \s-1NV\s0
either directly (if \f(CW\*(C`SvNOK\*(C'\fR is set) or by callin tha \f(CW\*(C`sv_2nv\*(C'\fR
function. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`TOPs\*(C'\fR takes tha next \s-1SV\s0 from tha top of tha stack \- fo'sho,
\&\f(CW\*(C`POPn\*(C'\fR uses \f(CW\*(C`TOPs\*(C'\fR \- but don't remove dat shit. We then use \f(CW\*(C`SvNV\*(C'\fR to
get tha \s-1NV\s0 from \f(CW\*(C`leftsv\*(C'\fR up in tha same way as before \- fo'sho, \f(CW\*(C`POPn\*(C'\fR uses
\&\f(CW\*(C`SvNV\*(C'\fR.
.PP
Since our phat asses aint gots a \s-1NV\s0 fo' \f(CW$b\fR, we'll gotta use \f(CW\*(C`sv_2nv\*(C'\fR to
convert dat shit. If we step again, we'll find ourselves there:
.PP
.Vb 3
\&    Perl_sv_2nv (sv=0xa0675d0) at sv.c:1669
\&    1669        if (!sv)
\&    (gdb)
.Ve
.PP
We can now use \f(CW\*(C`Perl_sv_dump\*(C'\fR ta rewind tha \s-1SV:\s0
.PP
.Vb 7
\&    SV = PV(0xa057cc0) at 0xa0675d0
\&    REFCNT = 1
\&    FLAGS = (POK,pPOK)
\&    PV = 0xa06a510 "6XXXX"\e0
\&    CUR = 5
\&    LEN = 6
\&    $1 = void
.Ve
.PP
We know we goin ta git \f(CW6\fR from this, so letz finish the
subroutine:
.PP
.Vb 4
\&    (gdb) finish
\&    Run till exit from #0  Perl_sv_2nv (sv=0xa0675d0) at sv.c:1671
\&    0x462669 up in Perl_pp_add () at pp_hot.c:311
\&    311           dPOPTOPnnrl_ul;
.Ve
.PP
We can also dump up dis op: tha current op be always stored in
\&\f(CW\*(C`PL_op\*(C'\fR, n' we can dump it wit \f(CW\*(C`Perl_op_dump\*(C'\fR. This'll give us
similar output ta B::Debug.
.PP
.Vb 10
\&    {
\&    13  TYPE = add  ===> 14
\&        TARG = 1
\&        FLAGS = (SCALAR,KIDS)
\&        {
\&            TYPE = null  ===> (12)
\&              (was rv2sv)
\&            FLAGS = (SCALAR,KIDS)
\&            {
\&    11          TYPE = gvsv  ===> 12
\&                FLAGS = (SCALAR)
\&                GV = main::b
\&            }
\&        }
.Ve
.PP
# finish dis lata #
.SH "SOURCE CODE STATIC ANALYSIS"
.IX Header "SOURCE CODE STATIC ANALYSIS"
Various tools exist fo' analysin C source code \fBstatically\fR, as
opposed ta \fBdynamically\fR, dat is, without executin tha code. Well shiiiit, it is
possible ta detect resource leaks, undefined behaviour, type
mismatches, portabilitizzle problems, code paths dat would cause illegal
memory accesses, n' other similar problems by just parsin tha C code
and lookin all up in tha resultin graph, what tha fuck do it tell bout the
execution n' data flows fo' realz. As a matta of fact, dis is exactly how tha fuck C
compilaz know ta give warnings bout dubious code.
.SS "lint, splint"
.IX Subsection "lint, splint"
Da phat oldschool C code qualitizzle inspector, \f(CW\*(C`lint\*(C'\fR, be available up in several
platforms yo, but please be aware dat there be nuff muthafuckin different
implementationz of it by different vendors, which means dat tha flags
are not identical across different platforms.
.PP
There be a lint variant called \f(CW\*(C`splint\*(C'\fR (Secure Programmin Lint)
available from http://www.splint.org/ dat should compile on any
Unix-like platform.
.PP
There is \f(CW\*(C`lint\*(C'\fR n' <splint> targets up in Makefile yo, but you may have to
diddle wit tha flags (see above).
.SS "Coverity"
.IX Subsection "Coverity"
Coveritizzle (http://www.coverity.com/) be a thang similar ta lint n' as
a testbed fo' they thang they periodically check nuff muthafuckin open source
projects, n' they give up accounts ta open source pimpers ta the
defect databases.
.SS "cpd (cut-and-paste detector)"
.IX Subsection "cpd (cut-and-paste detector)"
Da cpd tool detects cut-and-paste coding. If one instizzle of the
cut-and-pasted code chizzles, all tha other spots should probably be
changed, like a muthafucka. Therefore such code should probably be turned tha fuck into a
subroutine or a macro.
.PP
cpd (http://pmd.sourceforge.net/cpd.html) is part of tha pmd project
(http://pmd.sourceforge.net/). pmd was originally freestyled fo' static
analysiz of Java code yo, but lata tha cpd part of dat shiznit was extended to
parse also C n' \*(C+.
.PP
Downlizzle tha pmd\-bin\-X.Y.zip () from tha SourceForge crib, extract the
pmd\-X.Y.jar from it, n' then run dat on source code thusly:
.PP
.Vb 2
\&  java \-cp pmd\-X.Y.jar net. Put yo muthafuckin choppers up if ya feel this!sourceforge.pmd.cpd.CPD \e
\&   \-\-minimum\-tokens 100 \-\-filez /some/where/src \-\-language c > cpd.txt
.Ve
.PP
Yo ass may run tha fuck into memory limits, up in which case you should use tha \-Xmx
option:
.PP
.Vb 1
\&  java \-Xmx512M ...
.Ve
.SS "gcc warnings"
.IX Subsection "gcc warnings"
Though much can be freestyled bout tha inconsistency n' coverage
problemz of gcc warnings (like \f(CW\*(C`\-Wall\*(C'\fR not meanin \*(L"all tha warnings\*(R",
or some common portabilitizzle problems not bein covered by \f(CW\*(C`\-Wall\*(C'\fR, or
\&\f(CW\*(C`\-ansi\*(C'\fR n' \f(CW\*(C`\-pedantic\*(C'\fR both bein a skankyly defined collection of
warnings, n' so forth), gcc is still a useful tool up in keepin our
codin nozzle clean.
.PP
Da \f(CW\*(C`\-Wall\*(C'\fR is by default on.
.PP
Da \f(CW\*(C`\-ansi\*(C'\fR (and its sidekick, \f(CW\*(C`\-pedantic\*(C'\fR) would be sick ta be on
always yo, but unfortunately they is not safe on all platforms, they can
for example cause fatal conflicts wit tha system headaz (Solaris
bein a prime example). If Configure \f(CW\*(C`\-Dgccansipedantic\*(C'\fR is used, the
\&\f(CW\*(C`cflags\*(C'\fR frontend selects \f(CW\*(C`\-ansi \-pedantic\*(C'\fR fo' tha platforms where
they is known ta be safe.
.PP
Startin from Perl 5.9.4 tha followin extra flags is added:
.IP "\(bu" 4
\&\f(CW\*(C`\-Wendif\-labels\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\-Wextra\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\-Wdeclaration\-after\-statement\*(C'\fR
.PP
Da followin flags would be sick ta have but they would first need
their own Augean stablemaster:
.IP "\(bu" 4
\&\f(CW\*(C`\-Wpointer\-arith\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\-Wshadow\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`\-Wstrict\-prototypes\*(C'\fR
.PP
Da \f(CW\*(C`\-Wtraditional\*(C'\fR be another example of tha buggin tendency of gcc
to bundle a shitload of warnings under one switch (it would be impossible to
deploy up in practice cuz it would diss a lot) but it do contain
some warnings dat would be beneficial ta have available on they own,
like fuckin tha warnin bout strang constants inside macros containin the
macro arguments: dis behaved differently pre-ANSI than it do in
\&\s-1ANSI,\s0 n' some C compilaz is still up in transition, \s-1AIX\s0 bein an
example.
.SS "Warningz of other C compilers"
.IX Subsection "Warningz of other C compilers"
Other C compilaz (yes, there \fBare\fR other C compilaz than gcc) often
have they \*(L"strict \s-1ANSI\*(R"\s0 or \*(L"strict \s-1ANSI\s0 wit some portability
extensions\*(R" modes on, like fo' example tha Sun Workshop has its \f(CW\*(C`\-Xa\*(C'\fR
mode on (though implicitly), or tha \s-1DEC \s0(these days, \s-1HP...\s0) has its
\&\f(CW\*(C`\-std1\*(C'\fR mode on.
.SH "MEMORY DEBUGGERS"
.IX Header "MEMORY DEBUGGERS"
\&\fB\s-1NOTE 1\s0\fR: Hustlin under olda memory debuggers like fuckin Purify,
valgrind or Third Degree pimped outly slows down tha execution: seconds
become minutes, minutes become hours. For example az of Perl 5.8.1, the
ext/Encode/t/Unicode.t takes extraordinarily long ta complete under
e.g. Purify, Third Degree, n' valgrind. Y'all KNOW dat shit, muthafucka! Under valgrind it takes more
than six hours, even on a snappy computer n' shit. Da holla'd test must be bustin
suttin' dat is like unfriendly fo' memory debuggers. If you don't
feel like waiting, dat you can simply bust a cap up in away tha perl process.
Roughly valgrind slows down execution by factor 10, AddressSanitizer by
factor 2.
.PP
\&\fB\s-1NOTE 2\s0\fR: To minimize tha number of memory leak false alarms (see
\&\*(L"\s-1PERL_DESTRUCT_LEVEL\*(R"\s0 fo' mo' shiznit), you gotta set the
environment variable \s-1PERL_DESTRUCT_LEVEL\s0 ta 2.
.PP
For csh-like shells:
.PP
.Vb 1
\&    setenv PERL_DESTRUCT_LEVEL 2
.Ve
.PP
For Bourne-type shells:
.PP
.Vb 2
\&    PERL_DESTRUCT_LEVEL=2
\&    export PERL_DESTRUCT_LEVEL
.Ve
.PP
In Unixy environments you can also use tha \f(CW\*(C`env\*(C'\fR command:
.PP
.Vb 1
\&    env PERL_DESTRUCT_LEVEL=2 valgrind ./perl \-Ilib ...
.Ve
.PP
\&\fB\s-1NOTE 3\s0\fR: There is known memory leaks when there be compile-time
errors within eval or require, seein \f(CW\*(C`S_doeval\*(C'\fR up in tha call stack is
a phat sign of these n' you can put dat on yo' toast. Fixin these leaks is non-trivial, unfortunately,
but they must be fixed eventually.
.PP
\&\fB\s-1NOTE 4\s0\fR: DynaLoader aint gonna clean up afta itself straight-up
unless Perl is built wit tha Configure option
\&\f(CW\*(C`\-Accflags=\-DDL_UNLOAD_ALL_AT_EXIT\*(C'\fR.
.SS "Rationizzle Softwarez Purify"
.IX Subsection "Rationizzle Softwarez Purify"
Purify be a cold-ass lil commercial tool dat is helpful up in identifyin memory
overruns, wild pointers, memory leaks n' other such badness. Perl must
be compiled up in a specific way fo' optimal testin wit Purify.  Purify
is available under Windows \s-1NT,\s0 Solaris, HP-UX, \s-1SGI,\s0 n' Siemens Unix.
.PP
\fIPurify on Unix\fR
.IX Subsection "Purify on Unix"
.PP
On Unix, Purify creates a freshly smoked up Perl binary. To git da most thugged-out benefit out
of Purify, you should create tha perl ta Purify using:
.PP
.Vb 2
\&    sh Configure \-Accflags=\-DPURIFY \-Doptimize=\*(Aq\-g\*(Aq \e
\&     \-Uusemymalloc \-Dusemultiplicity
.Ve
.PP
where these arguments mean:
.IP "\(bu" 4
\&\-Accflags=\-DPURIFY
.Sp
Disablez Perlz arena memory allocation functions, as well as forcing
use of memory allocation functions derived from tha system malloc.
.IP "\(bu" 4
\&\-Doptimize='\-g'
.Sp
Addz debuggin shiznit so dat you peep tha exact source statements
where tha problem occurs. Without dis flag, all yo big-ass booty is ghon peep is the
source filename of where tha error occurred.
.IP "\(bu" 4
\&\-Uusemymalloc
.Sp
Disable Perlz malloc so dat Purify can mo' closely monitor
allocations n' leaks. Usin Perlz malloc will make Purify report most
leaks up in tha \*(L"potential\*(R" leaks category.
.IP "\(bu" 4
\&\-Dusemultiplicity
.Sp
Enablin tha multiplicitizzle option allows perl ta clean up thoroughly
when tha interpreta shuts down, which reduces tha number of bogus leak
reports from Purify.
.PP
Once you've compiled a perl suitable fo' Purify'ing, then you can just:
.PP
.Vb 1
\&    make pureperl
.Ve
.PP
which creates a funky-ass binary named 'pureperl' dat has been Purify'ed. Y'all KNOW dat shit, muthafucka! This
binary is used up in place of tha standard 'perl' binary when you want to
debug Perl memory problems.
.PP
As a example, ta show any memory leaks produced durin tha standard
Perl testset you would create n' run tha Purify'ed perl as:
.PP
.Vb 3
\&    make pureperl
\&    cd t
\&    ../pureperl \-I../lib harness
.Ve
.PP
which would run Perl on test.pl n' report any memory problems.
.PP
Purify outputs lyrics up in \*(L"Viewer\*(R" windows by default. If you don't
have a windowin environment or if you simply want tha Purify output to
unobtrusively git all up in a log file instead of ta tha interactizzle window,
use these followin options ta output ta tha log file \*(L"perl.log\*(R":
.PP
.Vb 2
\&    setenv PURIFYOPTIONS "\-chain\-length=25 \-windows=no \e
\&     \-log\-file=perl.log \-append\-logfile=yes"
.Ve
.PP
If you plan ta use tha \*(L"Viewer\*(R" windows, then you only need this
option:
.PP
.Vb 1
\&    setenv PURIFYOPTIONS "\-chain\-length=25"
.Ve
.PP
In Bourne-type shells:
.PP
.Vb 2
\&    PURIFYOPTIONS="..."
\&    export PURIFYOPTIONS
.Ve
.PP
or if you have tha \*(L"env\*(R" utility:
.PP
.Vb 1
\&    env PURIFYOPTIONS="..." ../pureperl ...
.Ve
.PP
\fIPurify on \s-1NT\s0\fR
.IX Subsection "Purify on NT"
.PP
Purify on Windows \s-1NT\s0 instruments tha Perl binary 'perl.exe' on tha fly.
 There is nuff muthafuckin options up in tha makefile you should chizzle ta git the
most use outta Purify:
.IP "\(bu" 4
\&\s-1DEFINES\s0
.Sp
Yo ass should add \-DPURIFY ta tha \s-1DEFINES\s0 line so tha \s-1DEFINES\s0 line looks
suttin' like:
.Sp
.Vb 1
\&   DEFINES = \-DWIN32 \-D_CONSOLE \-DNO_STRICT $(CRYPT_FLAG) \-DPURIFY=1
.Ve
.Sp
to disable Perlz arena memory allocation functions, as well as to
force use of memory allocation functions derived from tha system
malloc.
.IP "\(bu" 4
\&\s-1USE_MULTI\s0 = define
.Sp
Enablin tha multiplicitizzle option allows perl ta clean up thoroughly
when tha interpreta shuts down, which reduces tha number of bogus leak
reports from Purify.
.IP "\(bu" 4
#PERL_MALLOC = define
.Sp
Disable Perlz malloc so dat Purify can mo' closely monitor
allocations n' leaks. Usin Perlz malloc will make Purify report most
leaks up in tha \*(L"potential\*(R" leaks category.
.IP "\(bu" 4
\&\s-1CFG\s0 = Debug
.Sp
Addz debuggin shiznit so dat you peep tha exact source statements
where tha problem occurs. Without dis flag, all yo big-ass booty is ghon peep is the
source filename of where tha error occurred.
.PP
As a example, ta show any memory leaks produced durin tha standard
Perl testset you would create n' run Purify as:
.PP
.Vb 4
\&    cd win32
\&    make
\&    cd ../t
\&    purify ../perl \-I../lib harness
.Ve
.PP
which would instrument Perl up in memory, run Perl on test.pl, then
finally report any memory problems.
.SS "valgrind"
.IX Subsection "valgrind"
Da valgrind tool can be used ta smoke up both memory leaks n' illegal
heap memory accesses fo' realz. Az of version 3.3.0, Valgrind only supports Linux
on x86, x86\-64 n' PowerPC n' Darwin (\s-1OS X\s0) on x86 n' x86\-64). The
special \*(L"test.valgrind\*(R" target can be used ta run tha tests under
valgrind. Y'all KNOW dat shit, muthafucka! Found errors n' memory leaks is logged up in filez named
\&\fItestfile.valgrind\fR.
.PP
Valgrind also serves up a cold-ass lil cachegrind tool, invoked on perl as:
.PP
.Vb 1
\&    VG_OPTS=\-\-tool=cachegrind make test.valgrind
.Ve
.PP
As system libraries (most notably glibc) is also triggerin errors,
valgrind allows ta suppress such errors rockin suppression files. The
default suppression file dat comes wit valgrind already catches a lot
of em. Right back up in yo muthafuckin ass. Some additionizzle suppressions is defined up in \fIt/perl.supp\fR.
.PP
To git valgrind n' fo' mo' shiznit see
.PP
.Vb 1
\&    http://valgrind.org/
.Ve
.SS "AddressSanitizer"
.IX Subsection "AddressSanitizer"
AddressSanitizer be a cold-ass lil clang extension, included up in clang since v3.1. It
checks illegal heap pointers, global pointers, stack pointas n' use
afta free errors, n' is fast enough dat you can easily compile your
debuggin or optimized perl wit dat shit. Well shiiiit, it do not check memory leaks
though cause I gots dem finger-lickin' chickens wit tha siz-auce fo' realz. AddressSanitizer be available fo' linux, Mac \s-1OS X\s0 n' soon on
Windows.
.PP
To build perl wit AddressSanitizer, yo' Configure invocation should
look like:
.PP
.Vb 3
\&    sh Configure \-des \-Dcc=clang \e
\&       \-Accflags=\-faddress\-sanitizer \-Aldflags=\-faddress\-sanitizer \e
\&       \-Alddlflags=\-shared\e \-faddress\-sanitizer
.Ve
.PP
where these arguments mean:
.IP "\(bu" 4
\&\-Dcc=clang
.Sp
This should be replaced by tha full path ta yo' clang executable if it
is not up in yo' path.
.IP "\(bu" 4
\&\-Accflags=\-faddress\-sanitizer
.Sp
Compile perl n' extensions sources wit AddressSanitizer.
.IP "\(bu" 4
\&\-Aldflags=\-faddress\-sanitizer
.Sp
Link tha perl executable wit AddressSanitizer.
.IP "\(bu" 4
\&\-Alddlflags=\-shared\e \-faddress\-sanitizer
.Sp
Link dynamic extensions wit AddressSanitizer n' shit. Yo ass must manually
specify \f(CW\*(C`\-shared\*(C'\fR cuz rockin \f(CW\*(C`\-Alddlflags=\-shared\*(C'\fR will prevent
Configure from settin a thugged-out default value fo' \f(CW\*(C`lddlflags\*(C'\fR, which usually
gotz nuff \f(CW\*(C`\-shared\*(C'\fR (at least on linux).
.PP
See also
<http://code.google.com/p/address\-sanitizer/wiki/AddressSanitizer>.
.SH "PROFILING"
.IX Header "PROFILING"
Dependin on yo' platform there be various wayz of profilin Perl.
.PP
There is two commonly used steez of profilin executables:
\&\fIstatistical time-sampling\fR n' \fIbasic-block counting\fR.
.PP
Da first method takes periodically samplez of tha \s-1CPU\s0 program counter,
and since tha program counta can be correlated wit tha code generated
for functions, we git a statistical view of up in which functions the
program is bustin its time. Da caveats is dat straight-up small/fast
functions have lower probabilitizzle of showin up in tha profile, n' that
periodically interruptin tha program (this is probably done rather
frequently, up in tha scale of milliseconds) imposes a additional
overhead dat may skew tha thangs up in dis biatch. Da first problem can be alleviated
by hustlin tha code fo' longer (in general dis be a phat scam for
profiling), tha second problem is probably kept up in guard by the
profilin tools theyselves.
.PP
Da second method divides up tha generated code tha fuck into \fIbasic blocks\fR.
Basic blocks is sectionz of code dat is entered only up in the
beginnin n' exited only all up in tha end yo, but it ain't no stoppin cause I be still poppin'. For example, a cold-ass lil conditionizzle jump
starts a funky-ass basic block. Basic block profilin probably works by
\&\fIinstrumenting\fR tha code by addin \fIenta basic block #nnnn\fR
book-keepin code ta tha generated code. Durin tha execution of the
code tha basic block countas is then updated appropriately. The
caveat is dat tha added extra code can skew tha thangs up in dis biatch: again, the
profilin tools probably try ta factor they own effects outta the
results.
.SS "Gprof Profiling"
.IX Subsection "Gprof Profiling"
gprof be a profilin tool available up in nuff Unix platforms, it uses
\&\fIstatistical time-sampling\fR.
.PP
Yo ass can build a profiled version of perl called \*(L"perl.gprof\*(R" by
invokin tha make target \*(L"perl.gprof\*(R"  (What tha fuck iz required is dat Perl
must be compiled rockin tha \f(CW\*(C`\-pg\*(C'\fR flag, you may need ta re-Configure).
Hustlin tha profiled version of Perl will create a output file called
\&\fIgmon.out\fR is pimped which gotz nuff tha profilin data collected
durin tha execution.
.PP
Da gprof tool can then display tha collected data up in various ways.
Usually gprof understandz tha followin options:
.IP "\(bu" 4
\&\-a
.Sp
Suppress statically defined functions from tha profile.
.IP "\(bu" 4
\&\-b
.Sp
Suppress tha verbose descriptions up in tha profile.
.IP "\(bu" 4
\&\-e routine
.Sp
Exclude tha given routine n' its descendants from tha profile.
.IP "\(bu" 4
\&\-f routine
.Sp
Display only tha given routine n' its descendants up in tha profile.
.IP "\(bu" 4
\&\-s
.Sp
Generate a summary file called \fIgmon.sum\fR which then may be given to
subsequent gprof runs ta accumulate data over nuff muthafuckin runs.
.IP "\(bu" 4
\&\-z
.Sp
Display routines dat have zero usage.
.PP
For mo' detailed explanation of tha available commandz n' output
formats, peep yo' own local documentation of gprof.
.PP
quick hint:
.PP
.Vb 4
\&    $ sh Configure \-des \-Dusedevel \-Doptimize=\*(Aq\-pg\*(Aq && make perl.gprof
\&    $ ./perl.gprof someprog # creates gmon.out up in current directory
\&    $ gprof ./perl.gprof > out
\&    $ view out
.Ve
.SS "\s-1GCC\s0 gcov Profiling"
.IX Subsection "GCC gcov Profiling"
Startin from \s-1GCC 3.0 \s0\fIbasic block profiling\fR is officially available
for tha \s-1GNU CC.\s0
.PP
Yo ass can build a profiled version of perl called \fIperl.gcov\fR by
invokin tha make target \*(L"perl.gcov\*(R" (what is required dat Perl must
be compiled rockin gcc wit tha flags \f(CW\*(C`\-fprofile\-arcs \-ftest\-coverage\*(C'\fR,
you may need ta re-Configure).
.PP
Hustlin tha profiled version of Perl will cause flava output ta be
generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For each source file a accompanyin \*(L".da\*(R" file will be
created.
.PP
To display tha thangs up in dis biatch you use tha \*(L"gcov\*(R" utilitizzle (which should be
installed if you have gcc 3.0 or newer installed). \fIgcov\fR is run on
source code files, like this
.PP
.Vb 1
\&    gcov sv.c
.Ve
.PP
which will cause \fIsv.c.gcov\fR ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fI.gcov\fR filez contain
the source code annotated wit relatizzle frequenciez of execution
indicated by \*(L"#\*(R" markers.
.PP
Useful optionz of \fIgcov\fR include \f(CW\*(C`\-b\*(C'\fR which will summarise tha basic
block, branch, n' function call coverage, n' \f(CW\*(C`\-c\*(C'\fR which instead of
relatizzle frequencies will use tha actual counts, n' you can put dat on yo' toast. For mo' shiznit
on tha use of \fIgcov\fR n' basic block profilin wit gcc, peep the
latest \s-1GNU CC\s0 manual, az of \s-1GCC 3.0\s0 see
.PP
.Vb 1
\&    http://gcc.gnu.org/onlinedocs/gcc\-3.0/gcc.html
.Ve
.PP
and its section titled \*(L"8. gcov: a Test Coverage Program\*(R"
.PP
.Vb 1
\&    http://gcc.gnu.org/onlinedocs/gcc\-3.0/gcc_8.html#SEC132
.Ve
.PP
quick hint:
.PP
.Vb 7
\&    $ sh Configure \-des \-Dusedevel \-Doptimize=\*(Aq\-g\*(Aq \e
\&        \-Accflags=\*(Aq\-fprofile\-arcs \-ftest\-coverage\*(Aq \e
\&        \-Aldflags=\*(Aq\-fprofile\-arcs \-ftest\-coverage\*(Aq && make perl.gcov
\&    $ rm \-f regexec.c.gcov regexec.gcda
\&    $ ./perl.gcov
\&    $ gcov regexec.c
\&    $ view regexec.c.gcov
.Ve
.SH "MISCELLANEOUS TRICKS"
.IX Header "MISCELLANEOUS TRICKS"
.SS "\s-1PERL_DESTRUCT_LEVEL\s0"
.IX Subsection "PERL_DESTRUCT_LEVEL"
If you wanna run any of tha tests yo ass manually rockin e.g.
valgrind, or tha pureperl or perl.third executables, please note that
by default perl \fBdoes not\fR explicitly cleanup all tha memory it has
allocated (like fuckin global memory arenas) but instead lets tha \fIexit()\fR of
the whole program \*(L"take care\*(R" of such allocations, also known as
\&\*(L"global destruction of objects\*(R".
.PP
There be a way ta tell perl ta do complete cleanup: set tha environment
variable \s-1PERL_DESTRUCT_LEVEL\s0 ta a non-zero value. Da t/TEST wrapper
does set dis ta 2, n' dis is what tha fuck you need ta do too, if you don't
wanna peep tha \*(L"global leaks\*(R": For example, fo' \*(L"third-degreed\*(R" Perl:
.PP
.Vb 1
\&        env PERL_DESTRUCT_LEVEL=2 ./perl.third \-Ilib t/foo/bar.t
.Ve
.PP
(Note: tha mod_perl apache module uses also dis environment variable
for its own purposes n' extended its semantics. Refer ta tha mod_perl
documentation fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. Also, spawned threadz do the
equivalent of settin dis variable ta tha value 1.)
.PP
If, all up in tha end of a run you git tha message \fIN scalars leaked\fR, you
can recompile wit \f(CW\*(C`\-DDEBUG_LEAKING_SCALARS\*(C'\fR, which will cause the
addressez of all dem leaked SVs ta be dumped along wit details as to
where each \s-1SV\s0 was originally allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This shiznit be also
displayed by Devel::Peek. Note dat tha extra details recorded with
each \s-1SV\s0 increases memory usage, so it shouldn't be used up in thang
environments, n' you can put dat on yo' toast. Well shiiiit, it also converts \f(CW\*(C`new_SV()\*(C'\fR from a macro tha fuck into a real
function, so you can use yo' most straight-up bangin debugger ta discover where
those pesky SVs was allocated.
.PP
If you peep dat you leakin memory at runtime yo, but neither valgrind
nor \f(CW\*(C`\-DDEBUG_LEAKING_SCALARS\*(C'\fR will find anything, you probably
leakin SVs dat is still reachable n' is ghon be properly cleaned up
durin destruction of tha interpreter n' shit. In such cases, rockin tha \f(CW\*(C`\-Dm\*(C'\fR
switch can point you ta tha source of tha leak. If tha executable was
built wit \f(CW\*(C`\-DDEBUG_LEAKING_SCALARS\*(C'\fR, \f(CW\*(C`\-Dm\*(C'\fR will output \s-1SV\s0
allocations up in addizzle ta memory allocations. Each \s-1SV\s0 allocation has a
distinct serial number dat is ghon be freestyled on creation n' destruction
of tha \s-1SV.\s0 So if you executin tha leakin code up in a loop, you need
to look fo' SVs dat is pimped yo, but never destroyed between each
cycle. If such a \s-1SV\s0 is found, set a cold-ass lil conditionizzle breakpoint within
\&\f(CW\*(C`new_SV()\*(C'\fR n' make it break only when \f(CW\*(C`PL_sv_serial\*(C'\fR is equal ta the
serial number of tha leakin \s-1SV.\s0 Then yo big-ass booty is ghon catch tha interpreta in
exactly tha state where tha leakin \s-1SV\s0 be allocated, which is
sufficient up in nuff cases ta find tha source of tha leak.
.PP
As \f(CW\*(C`\-Dm\*(C'\fR is rockin tha PerlIO layer fo' output, it will by itself
allocate like a funky-ass bunch of SVs, which is hidden ta avoid recursion. I aint talkin' bout chicken n' gravy biatch. You
can bypass tha PerlIO layer if you use tha \s-1SV\s0 loggin provided by
\&\f(CW\*(C`\-DPERL_MEM_LOG\*(C'\fR instead.
.SS "\s-1PERL_MEM_LOG\s0"
.IX Subsection "PERL_MEM_LOG"
If compiled wit \f(CW\*(C`\-DPERL_MEM_LOG\*(C'\fR, both memory n' \s-1SV\s0 allocations go
all up in loggin functions, which is handy fo' breakpoint setting.
.PP
Unless \f(CW\*(C`\-DPERL_MEM_LOG_NOIMPL\*(C'\fR be also compiled, tha loggin functions
read \f(CW$ENV\fR{\s-1PERL_MEM_LOG\s0} ta determine whether ta log tha event, n' if
so how:
.PP
.Vb 4
\&    $ENV{PERL_MEM_LOG} =~ /m/           Log all memory ops
\&    $ENV{PERL_MEM_LOG} =~ /s/           Log all SV ops
\&    $ENV{PERL_MEM_LOG} =~ /t/           include timestamp up in Log
\&    $ENV{PERL_MEM_LOG} =~ /^(\ed+)/      write ta FD given (default is 2)
.Ve
.PP
Memory loggin is somewhat similar ta \f(CW\*(C`\-Dm\*(C'\fR but is independent of
\&\f(CW\*(C`\-DDEBUGGING\*(C'\fR, n' at a higher level; all usez of \fINewx()\fR, \fIRenew()\fR, and
\&\fISafefree()\fR is logged wit tha callerz source code file n' line
number (and C function name, if supported by tha C compiler). In
contrast, \f(CW\*(C`\-Dm\*(C'\fR is directly all up in tha deal wit \f(CW\*(C`malloc()\*(C'\fR. \s-1SV\s0 loggin is
similar.
.PP
Since tha loggin don't use PerlIO, all \s-1SV\s0 allocations is logged and
no extra \s-1SV\s0 allocations is introduced by enablin tha logging. If
compiled wit \f(CW\*(C`\-DDEBUG_LEAKING_SCALARS\*(C'\fR, tha serial number fo' each \s-1SV\s0
allocation be also logged.
.SS "\s-1DDD\s0 over gdb"
.IX Subsection "DDD over gdb"
Those debuggin perl wit tha \s-1DDD\s0 frontend over gdb may find the
followin useful:
.PP
Yo ass can extend tha data conversion shortcuts menu, so fo' example you
can display a \s-1SV\s0z \s-1IV\s0 value wit one click, without bustin any typing.
To do dat simply edit ~/.ddd/init file n' add after:
.PP
.Vb 6
\&  ! Display shortcuts.
\&  Ddd*gdbDisplayShortcuts: \e
\&  /t ()   // Convert ta Bin\en\e
\&  /d ()   // Convert ta Dec\en\e
\&  /x ()   // Convert ta Hex\en\e
\&  /o ()   // Convert ta Oct(\en\e
.Ve
.PP
the followin two lines:
.PP
.Vb 2
\&  ((XPV*) (())\->sv_any )\->xpv_pv  // 2pvx\en\e
\&  ((XPVIV*) (())\->sv_any )\->xiv_iv // 2ivx
.Ve
.PP
so now you can do ivx n' pvx lookups or you can plug there tha sv_peek
\&\*(L"conversion\*(R":
.PP
.Vb 1
\&  Perl_sv_peek(my_perl, (SV*)()) // sv_peek
.Ve
.PP
(Da my_perl is fo' threaded builds.) Just remember dat every last muthafuckin line,
but tha last one, should end wit \en\e
.PP
Alternatively edit tha init file interactively via: 3rd mouse button \->
New Display \-> Edit Menu
.PP
Note: you can define up ta 20 conversion shortcuts up in tha gdb section.
.SS "Poison"
.IX Subsection "Poison"
If you peep up in a thugged-out debugger a memory area mysteriously full of 0xABABABAB
or 0xEFEFEFEF, you may be seein tha effect of tha \fIPoison()\fR macros, see
perlclib.
.SS "Read-only optrees"
.IX Subsection "Read-only optrees"
Under ithreadz tha optree is read only. If you wanna enforce this, to
check fo' write accesses from buggy code, compile with
\&\f(CW\*(C`\-DPERL_DEBUG_READONLY_OPS\*(C'\fR ta enable code dat allocates op memory
via \f(CW\*(C`mmap\*(C'\fR, n' sets it read-only when it be attached ta a subroutine fo' realz. Any
write access ta a op thangs up in dis biatch up in a \f(CW\*(C`SIGBUS\*(C'\fR n' abort.
.PP
This code is intended fo' pimpment only, n' may not be portable
even ta all Unix variants fo' realz. Also, it be a 80% solution, up in dat it
aint able ta make all ops read only. Right back up in yo muthafuckin ass. Specifically it do not apply ta op
slabs belongin ta \f(CW\*(C`BEGIN\*(C'\fR blocks.
.PP
But fuck dat shiznit yo, tha word on tha street is dat as a 80% solution it is still effective, as it has caught bugs in
the past.
.SS "Da .i Targets"
.IX Subsection "Da .i Targets"
Yo ass can expand tha macros up in a \fIfoo.c\fR file by saying
.PP
.Vb 1
\&    make foo.i
.Ve
.PP
which will expand tha macros rockin cpp.  Don't be scared by the
results.
.SH "AUTHOR"
.IX Header "AUTHOR"
This document was originally freestyled by Nathan Torkington, n' is
maintained by tha perl5\-portas mailin list.
