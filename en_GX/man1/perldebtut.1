.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDEBTUT 1"
.TH PERLDEBTUT 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldebtut \- Perl debuggin tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A (very) lightweight introduction up in tha use of tha perl debugger, n' a
pointa ta existing, deeper sourcez of shiznit on tha subject of debugging
perl programs.
.PP
Therez a extraordinary number of playas up there whoz ass don't step tha fuck up ta know
anythang bout rockin tha perl debugger, though they use tha language every
day. It make me wanna hollar playa!  
This is fo' em.
.SH "use strict"
.IX Header "use strict"
First of all, there be a all dem thangs you can do ta make yo' game a shitload more
straightforward when it comes ta debuggin perl programs, without rockin the
debugger at all.  To demonstrate, herez a simple script, named \*(L"hello\*(R", with
a problem:
.PP
.Vb 1
\&        #!/usr/bin/perl
\&
\&        $var1 = \*(AqWuz crackalackin' World\*(Aq; # always wanted ta do dat :\-)
\&        $var2 = "$varl\en";
\&
\&        print $var2; 
\&        exit;
.Ve
.PP
While dis compilez n' runs happily, it probably won't do whatz expected,
namely it don't print \*(L"Wuz crackalackin' World\en\*(R" at all;  It will on tha other hand do
exactly what tha fuck dat shiznit was holla'd at ta do, computas bein a lil' bit dat way inclined. Y'all KNOW dat shit, muthafucka!  That
is, it will print up a newline character, n' you gonna git what tha fuck be lookin like a
blank line.  It be lookin like there be a 2 variablez when (because of tha typo)
therez straight-up 3:
.PP
.Vb 3
\&        $var1 = \*(AqWuz crackalackin' World\*(Aq;
\&        $varl = undef;
\&        $var2 = "\en";
.Ve
.PP
To catch dis kind of problem, we can force each variable ta be declared
before use by pullin up in tha strict module, by puttin 'use strict;' afta the
first line of tha script.
.PP
Now when you run it, perl bitches bout tha 3 undeclared variablez n' we
get four error lyrics cuz one variable is referenced twice:
.PP
.Vb 5
\& Global symbol "$var1" requires explicit package name at ./t1 line 4.
\& Global symbol "$var2" requires explicit package name at ./t1 line 5.
\& Global symbol "$varl" requires explicit package name at ./t1 line 5.
\& Global symbol "$var2" requires explicit package name at ./t1 line 7.
\& Execution of ./wassup aborted cuz of compilation errors.
.Ve
.PP
Luvverly dawwwwg! n' ta fix dis our phat asses declare all variablez explicitly n' now our
script be lookin like this:
.PP
.Vb 2
\&        #!/usr/bin/perl
\&        use strict;
\&
\&        mah $var1 = \*(AqWuz crackalackin' World\*(Aq;
\&        mah $varl = undef;
\&        mah $var2 = "$varl\en";
\&
\&        print $var2; 
\&        exit;
.Ve
.PP
We then do (always a phat idea) a syntax check before we try ta run it again:
.PP
.Vb 2
\&        > perl \-c hello
\&        wassup syntax OK
.Ve
.PP
And now when we run it, we git \*(L"\en\*(R" still yo, but at least we know why.  Just
gettin dis script ta compile has exposed tha '$varl' (with tha letta 'l')
variable, n' simply changin \f(CW$varl\fR ta \f(CW$var1\fR solves tha problem.
.SH "Lookin at data n' \-w n' v"
.IX Header "Lookin at data n' -w n' v"
Ok yo, but how tha fuck bout when you wanna straight-up peep yo' data, whatz up in that
dynamic variable, just before rockin it?
.PP
.Vb 2
\&        #!/usr/bin/perl 
\&        use strict;
\&
\&        mah $key = \*(Aqwelcome\*(Aq;
\&        mah %data = (
\&                \*(Aqthis\*(Aq => qw(that), 
\&                \*(Aqtom\*(Aq => qw(and jerry),
\&                \*(Aqwelcome\*(Aq => q(Wuz crackalackin' World),
\&                \*(Aqzip\*(Aq => q(welcome),
\&        );
\&        mah @data = keys %data;
\&
\&        print "$data{$key}\en";
\&        exit;
.Ve
.PP
Looks \s-1OK,\s0 afta itz been all up in tha syntax check (perl \-c scriptname), we
run it n' all we git be a funky-ass blank line again!  Hmmmm.
.PP
One common debuggin approach here, would be ta liberally sprinkle all dem print
statements, ta add a cold-ass lil check just before we print up our data, n' another just
after:
.PP
.Vb 3
\&        print "All OK\en" if grep($key, keys %data);
\&        print "$data{$key}\en";
\&        print "done: \*(Aq$data{$key}\*(Aq\en";
.Ve
.PP
And try again:
.PP
.Vb 2
\&        > perl data
\&        All OK     
\&
\&        done: \*(Aq\*(Aq
.Ve
.PP
Afta much starin all up in tha same piece of code n' not seein tha wood fo' the
trees fo' some time, we git a cold-ass lil cup of fruity-ass malt liquor n' try another approach.  That
is, we brang up in tha cavalry by givin perl tha '\fB\-d\fR' switch on tha command
line:
.PP
.Vb 2
\&        > perl \-d data 
\&        Default take a thugged-out dirtnap handlez restored.
\&
\&        Loadin DB routines from perl5db.pl version 1.07
\&        Editor support available.
\&
\&        Enta h or \`h h\*(Aq fo' help, or \`man perldebug\*(Aq fo' mo' help.
\&
\&        main::(./data:4):     mah $key = \*(Aqwelcome\*(Aq;
.Ve
.PP
Now, what tha fuck we've done here is ta launch tha built-in perl debugger on our
script.  It aint nuthin but stopped all up in tha straight-up original gangsta line of executable code n' is waitin for
input.
.PP
Before we go any further, you gonna wanna know how tha fuck ta quit tha debugger: use
just tha letta '\fBq\fR', not tha lyrics 'quit' or 'exit':
.PP
.Vb 2
\&        DB<1> q
\&        >
.Ve
.PP
Thatz it, you back on home turf again.
.SH "help"
.IX Header "help"
Fire tha debugger up again n' again n' again on yo' script n' we'll peep tha help menu fo'sho. 
Therez a cold-ass lil couple wayz of callin help: a simple '\fBh\fR' will git tha summary 
help list, '\fB|h\fR' (pipe-h) will pipe tha help all up in yo' pager (which is 
(probably 'more' or 'less'), n' finally, '\fBh h\fR' (h\-space-h) will hit you wit 
the entire help screen. I aint talkin' bout chicken n' gravy biatch.  Here is tha summary page:
.PP
D\fB1\fRh
.PP
.Vb 10
\& List/search source lines:               Control script execution:
\&  l [ln|sub]  List source code            T           Stack trace
\&  \- or .      List previous/current line  s [expr]    Single step [in expr]
\&  v [line]    View round line            n [expr]    Next, steps over subs
\&  f filename  View source up in file         <CR/Enter>  Repeat last n or s
\&  /pattern/ ?patt?   Search forw/backw    r           Return from subroutine
\&  M           Show module versions        c [ln|sub]  Continue until position
\& Debugger controls:                       L           List break/watch/actions
\&  o [...]     Set debugger options        t [expr]    Toggle trace [trace expr]
\&  <[<]|{[{]|>[>] [cmd] Do pre/post\-prompt b [ln|event|sub] [cnd] Set breakpoint
\&  ! [N|pat]   Redo a previous command     B ln|*      Delete a/all breakpoints
\&  H [\-num]    Display last num commandz   a [ln] cmd  Do cmd before line
\&  = [a val]   Define/list a alias        A ln|*      Delete a/all actions
\&  h [db_cmd]  Git help on command         w expr      Add a peep expression
\&  h h         Complete help page          W expr|*    Delete a/all peep exprs
\&  |[|]db_cmd  Send output ta pager        ![!] syscmd Run cmd up in a subprocess
\&  q or ^D     Quit                        R           Attempt a restart
\& Data Examination:     expr     Execute perl code, also see: s,n,t expr
\&  x|m expr       Evals expr up in list context, dumps tha result or lists methods.
\&  p expr         Print expression (uses script\*(Aqs current package).
\&  S [[!]pat]     List subroutine names [not] matchin pattern
\&  V [Pk [Vars]]  List Variablez up in Package.  Vars can be ~pattern or !pattern.
\&  X [Vars]       Same as "V current_package [Vars]".
\&  y [n [Vars]]   List lexicals up in higher scope <n>.  Vars same as V.
\& For mo' help, type h cmd_letter, or run playa perldebug fo' all docs.
.Ve
.PP
Mo' confusin options than you can shake a funky-ass big-ass stick at son!  It aint nuthin but not as wack as
it looks n' itz straight-up useful ta know mo' bout all of it, n' funk too!
.PP
Therez a cold-ass lil couple useful ones ta know bout straight away.  Yo ass wouldn't
think we rockin any libraries at all all up in tha moment yo, but '\fBM\fR' will show
which modulez is currently loaded, n' they version number, while '\fBm\fR' 
will show tha methods, n' '\fBS\fR' shows all subroutines (by pattern) as 
shown below.  '\fBV\fR' n' '\fBX\fR' show variablez up in tha program by package 
scope n' can be constrained by pattern.
.PP
.Vb 5
\&        DB<2>S str 
\&        dumpvar::stringify
\&        strict::bits
\&        strict::import
\&        strict::unimport
.Ve
.PP
Usin 'X' n' cousins requires you not ta use tha type identifiers ($@%), just
the 'name':
.PP
.Vb 2
\&        DM<3>X ~err
\&        FileHandle(stderr) => fileno(2)
.Ve
.PP
Remember we up in our tiny program wit a problem, we should gotz a peep
where we are, n' what tha fuck our data looks like. First of all letz view some code 
at our present posizzle (the first line of code up in dis case), via '\fBv\fR':
.PP
.Vb 11
\&        DB<4> v
\&        1       #!/usr/bin/perl
\&        2:      use strict;
\&        3
\&        4==>    mah $key = \*(Aqwelcome\*(Aq;
\&        5:      mah %data = (
\&        6               \*(Aqthis\*(Aq => qw(that),
\&        7               \*(Aqtom\*(Aq => qw(and jerry),
\&        8               \*(Aqwelcome\*(Aq => q(Wuz crackalackin' World),
\&        9               \*(Aqzip\*(Aq => q(welcome),
\&        10      );
.Ve
.PP
At line number 4 be a helpful pointer, dat  drops some lyrics ta you where yo ass is now, nahmeean?  To
see mo' code, type 'v' again:
.PP
.Vb 9
\&        DB<4> v
\&        8               \*(Aqwelcome\*(Aq => q(Wuz crackalackin' World),
\&        9               \*(Aqzip\*(Aq => q(welcome),
\&        10      );
\&        11:     mah @data = keys %data;
\&        12:     print "All OK\en" if grep($key, keys %data);
\&        13:     print "$data{$key}\en";
\&        14:     print "done: \*(Aq$data{$key}\*(Aq\en";
\&        15:     exit;
.Ve
.PP
And if you wanted ta list line 5 again, type 'l 5', (note tha space):
.PP
.Vb 2
\&        DB<4> l 5
\&        5:      mah %data = (
.Ve
.PP
In dis case, there be a not much ta peep yo, but of course normally there be a pages of
shiznit ta wade through, n' 'l' can be straight-up useful naaahhmean?  To reset yo' view ta the
line we bout ta execute, type a lone period '.':
.PP
.Vb 2
\&        DB<5> .
\&        main::(./data_a:4):     mah $key = \*(Aqwelcome\*(Aq;
.Ve
.PP
Da line shown is tha one dat be bout ta be executed \fBnext\fR, it aint
happened yet.  So while we can print a variable wit tha letta '\fBp\fR', at
this point all we'd git be a empty (undefined) value back.  What we need to
do is ta step all up in tha next executable statement wit a '\fBs\fR':
.PP
.Vb 7
\&        DB<6> s
\&        main::(./data_a:5):     mah %data = (
\&        main::(./data_a:6):             \*(Aqthis\*(Aq => qw(that),
\&        main::(./data_a:7):             \*(Aqtom\*(Aq => qw(and jerry),
\&        main::(./data_a:8):             \*(Aqwelcome\*(Aq => q(Wuz crackalackin' World),
\&        main::(./data_a:9):             \*(Aqzip\*(Aq => q(welcome),
\&        main::(./data_a:10):    );
.Ve
.PP
Now we can gotz a peep dat first ($key) variable:
.PP
.Vb 2
\&        DB<7> p $key 
\&        welcome
.Ve
.PP
line 13 is where tha action is, so letz continue down ta there via tha letter
\&'\fBc\fR', which by tha way, bangs a 'one\-time\-only' breakpoint all up in tha given
line or sub routine:
.PP
.Vb 3
\&        DB<8> c 13
\&        All OK
\&        main::(./data_a:13):    print "$data{$key}\en";
.Ve
.PP
We've gone past our check (where 'All \s-1OK\s0' was printed) n' have stopped just
before tha meat of our task.  We could try ta print up a cold-ass lil couple variables
to peep what tha fuck is happening:
.PP
.Vb 1
\&        DB<9> p $data{$key}
.Ve
.PP
Not much up in there, lets gotz a peep our hash:
.PP
.Vb 2
\&        DB<10> p %data
\&        Wuz crackalackin' Worldziptomandwelcomejerrywelcomethisthat 
\&
\&        DB<11> p keys %data
\&        Wuz crackalackin' Worldtomwelcomejerrythis
.Ve
.PP
Well, dis aint straight-up easy as fuck  ta read, n' rockin tha helpful manual (\fBh h\fR), the
\&'\fBx\fR' command looks promising:
.PP
.Vb 11
\&        DB<12> x %data
\&        0  \*(AqWuz crackalackin' World\*(Aq
\&        1  \*(Aqzip\*(Aq
\&        2  \*(Aqtom\*(Aq
\&        3  \*(Aqand\*(Aq
\&        4  \*(Aqwelcome\*(Aq
\&        5  undef
\&        6  \*(Aqjerry\*(Aq
\&        7  \*(Aqwelcome\*(Aq
\&        8  \*(Aqthis\*(Aq
\&        9  \*(Aqthat\*(Aq
.Ve
.PP
Thatz not much help, a cold-ass lil couple welcomes up in there yo, but no indication of
which is keys, n' which is joints, itz just a listed array dump and, in
this case, not particularly helpful naaahhmean?  Da trick here, is ta bust a \fBreference\fR
to tha data structure:
.PP
.Vb 7
\&        DB<13> x \e%data
\&        0  HASH(0x8194bc4)
\&           \*(AqWuz crackalackin' World\*(Aq => \*(Aqzip\*(Aq
\&           \*(Aqjerry\*(Aq => \*(Aqwelcome\*(Aq
\&           \*(Aqthis\*(Aq => \*(Aqthat\*(Aq
\&           \*(Aqtom\*(Aq => \*(Aqand\*(Aq
\&           \*(Aqwelcome\*(Aq => undef
.Ve
.PP
Da reference is truly dumped n' we can finally peep what tha fuck our phat asses dealin with. 
Our quotin was perfectly valid but wack fo' our purposes, wit 'and jerry'
bein treated as 2 separate lyrics rather than a phrase, thus throwin the
evenly paired hash structure outta alignment.
.PP
Da '\fB\-w\fR' switch would have holla'd at our asses bout this, had we used it all up in tha start,
and saved our asses a shitload of shit:
.PP
.Vb 2
\&        > perl \-w data
\&        Odd number of elements up in hash assignment at ./data line 5.
.Ve
.PP
We fix our quoting: 'tom' => q(and jerry), n' run it again, dis time we get
our expected output:
.PP
.Vb 2
\&        > perl \-w data
\&        Wuz crackalackin' World
.Ve
.PP
While our crazy asses here, take a cold-ass lil closer peep tha '\fBx\fR' command, itz straight-up useful
and will merrily dump up nested references, complete objects, partial objects
\&\- just bout whatever you throw at it:
.PP
Letz cook up a quick object n' x\-plode it, first we'll start tha debugger:
it wants some form of input from \s-1STDIN,\s0 so we give it suttin' non-committal,
a zero:
.PP
.Vb 2
\&        > perl \-de 0
\&        Default take a thugged-out dirtnap handlez restored.
\&
\&        Loadin DB routines from perl5db.pl version 1.07
\&        Editor support available.
\&
\&        Enta h or \`h h\*(Aq fo' help, or \`man perldebug\*(Aq fo' mo' help.
\&
\&        main::(\-e:1):   0
.Ve
.PP
Now build a on-the-fly object over a cold-ass lil couple lines (note tha backslash):
.PP
.Vb 2
\&        DB<1> $obj = bless({\*(Aqunique_id\*(Aq=>\*(Aq123\*(Aq, \*(Aqattr\*(Aq=> \e
\&        cont:   {\*(Aqcol\*(Aq => \*(Aqblack\*(Aq, \*(Aqthings\*(Aq => [qw(this dat etc)]}}, \*(AqMY_class\*(Aq)
.Ve
.PP
And letz gotz a peep it:
.PP
.Vb 10
\&        DB<2> x $obj
\&        0  MY_class=HASH(0x828ad98)
\&                \*(Aqattr\*(Aq => HASH(0x828ad68)
\&        \*(Aqcol\*(Aq => \*(Aqblack\*(Aq
\&        \*(Aqthings\*(Aq => ARRAY(0x828abb8)
\&                0  \*(Aqthis\*(Aq
\&                1  \*(Aqthat\*(Aq
\&                2  \*(Aqetc\*(Aq
\&                \*(Aqunique_id\*(Aq => 123       
\&        DB<3>
.Ve
.PP
Useful, huh?  Yo ass can eval nearly anythang up in there, n' experiment wit bits
of code or regexes until tha cows come home:
.PP
.Vb 1
\&        DB<3> @data = qw(this dat tha other atheizzle leather theory scythe)
\&
\&        DB<4> p \*(Aqsaw \-> \*(Aq.($cnt += map { print "\et:\et$_\en" } grep(/the/, sort @data))
\&        atheism
\&        leather
\&        other
\&        scythe
\&        the
\&        theory  
\&        saw \-> 6
.Ve
.PP
If you wanna peep tha command History, type a '\fBH\fR':
.PP
.Vb 7
\&        DB<5> H
\&        4: p \*(Aqsaw \-> \*(Aq.($cnt += map { print "\et:\et$_\en" } grep(/the/, sort @data))
\&        3: @data = qw(this dat tha other atheizzle leather theory scythe)
\&        2: x $obj
\&        1: $obj = bless({\*(Aqunique_id\*(Aq=>\*(Aq123\*(Aq, \*(Aqattr\*(Aq=>
\&        {\*(Aqcol\*(Aq => \*(Aqblack\*(Aq, \*(Aqthings\*(Aq => [qw(this dat etc)]}}, \*(AqMY_class\*(Aq)
\&        DB<5>
.Ve
.PP
And if you wanna repeat any previous command, use tha exclamation: '\fB!\fR':
.PP
.Vb 9
\&        DB<5> !4
\&        p \*(Aqsaw \-> \*(Aq.($cnt += map { print "$_\en" } grep(/the/, sort @data))
\&        atheism
\&        leather
\&        other
\&        scythe
\&        the
\&        theory  
\&        saw \-> 12
.Ve
.PP
For mo' on references peep perlref n' perlreftut
.SH "Steppin all up in code"
.IX Header "Steppin all up in code"
Herez a simple program which converts between Celsius n' Fahrenheit, it too
has a problem:
.PP
.Vb 2
\&        #!/usr/bin/perl \-w
\&        use strict;
\&
\&        mah $arg = $ARGV[0] || \*(Aq\-c20\*(Aq;
\&
\&        if ($arg =~ /^\e\-(c|f)((\e\-|\e+)*\ed+(\e.\ed+)*)$/) {
\&                mah ($deg, $num) = ($1, $2);
\&                mah ($in, $out) = ($num, $num);
\&                if ($deg eq \*(Aqc\*(Aq) {
\&                        $deg = \*(Aqf\*(Aq;
\&                        $out = &c2f($num);
\&                } else {
\&                        $deg = \*(Aqc\*(Aq;
\&                        $out = &f2c($num);
\&                }
\&                $out = sprintf(\*(Aq%0.2f\*(Aq, $out);
\&                $out =~ s/^((\e\-|\e+)*\ed+)\e.0+$/$1/;
\&                print "$out $deg\en";
\&        } else {
\&                print "Usage: $0 \-[c|f] num\en";
\&        }
\&        exit;
\&
\&        sub f2c {
\&                mah $f = shift;
\&                mah $c = 5 * $f \- 32 / 9;
\&                return $c;
\&        }
\&
\&        sub c2f {
\&                mah $c = shift;
\&                mah $f = 9 * $c / 5 + 32;
\&                return $f;
\&        }
.Ve
.PP
For some reason, tha Fahrenheit ta Celsius conversion fails ta return the
expected output.  This is what tha fuck it do:
.PP
.Vb 2
\&        > temp \-c0.72
\&        33.30 f
\&
\&        > temp \-f33.3
\&        162.94 c
.Ve
.PP
Not straight-up consistent son!  We bout ta set a funky-ass breakpoint up in tha code manually n' run it
under tha debugger ta peep what tha fuck be happenin. I aint talkin' bout chicken n' gravy biatch.  A breakpoint be a gangbangin' flag, ta which
the debugger will run without interruption, when it reaches tha breakpoint, it
will stop execution n' offer a prompt fo' further interaction. I aint talkin' bout chicken n' gravy biatch.  In normal
use, these debugger commandz is straight-up ignored, n' they is safe \- if a
lil messy, ta leave up in thang code.
.PP
.Vb 4
\&        mah ($in, $out) = ($num, $num);
\&        $DB::single=2; # bang at line 9!
\&        if ($deg eq \*(Aqc\*(Aq) 
\&                ...
\&
\&        > perl \-d temp \-f33.3
\&        Default take a thugged-out dirtnap handlez restored.
\&
\&        Loadin DB routines from perl5db.pl version 1.07
\&        Editor support available.
\&
\&        Enta h or \`h h\*(Aq fo' help, or \`man perldebug\*(Aq fo' mo' help.
\&
\&        main::(temp:4): mah $arg = $ARGV[0] || \*(Aq\-c100\*(Aq;
.Ve
.PP
We bout ta simply continue down ta our pre-set breakpoint wit a '\fBc\fR':
.PP
.Vb 2
\&        DB<1> c
\&        main::(temp:10):                if ($deg eq \*(Aqc\*(Aq) {
.Ve
.PP
Followed by a view command ta peep where we are:
.PP
.Vb 11
\&        DB<1> v
\&        7:              mah ($deg, $num) = ($1, $2);
\&        8:              mah ($in, $out) = ($num, $num);
\&        9:              $DB::single=2;
\&        10==>           if ($deg eq \*(Aqc\*(Aq) {
\&        11:                     $deg = \*(Aqf\*(Aq;
\&        12:                     $out = &c2f($num);
\&        13              } else {
\&        14:                     $deg = \*(Aqc\*(Aq;
\&        15:                     $out = &f2c($num);
\&        16              }
.Ve
.PP
And a print ta show what tha fuck joints we currently using:
.PP
.Vb 2
\&        DB<1> p $deg, $num
\&        f33.3
.Ve
.PP
We can put another break point on any line beginnin wit a cold-ass lil colon, we'll use
line 17 as thatz just as we come outta tha subroutine, n' we'd like to
pause there lata on:
.PP
.Vb 1
\&        DB<2> b 17
.Ve
.PP
Therez no feedback from dis yo, but you can peep what tha fuck breakpoints is set by
usin tha list 'L' command:
.PP
.Vb 4
\&        DB<3> L
\&        temp:
\&                17:            print "$out $deg\en";
\&                break if (1)
.Ve
.PP
Note dat ta delete a funky-ass breakpoint you use 'B'.
.PP
Now we'll continue down tha fuck into our subroutine, dis time rather than by line
number, we'll use tha subroutine name, followed by tha now familiar 'v':
.PP
.Vb 2
\&        DB<3> c f2c
\&        main::f2c(temp:30):             mah $f = shift;  
\&
\&        DB<4> v
\&        24:     exit;
\&        25
\&        26      sub f2c {
\&        27==>           mah $f = shift;
\&        28:             mah $c = 5 * $f \- 32 / 9; 
\&        29:             return $c;
\&        30      }
\&        31
\&        32      sub c2f {
\&        33:             mah $c = shift;
.Ve
.PP
Note dat if there was a subroutine call between our asses n' line 29, n' we wanted
to \fBsingle-step\fR all up in it, we could use tha '\fBs\fR' command, n' ta step
over it we would use '\fBn\fR' which would execute tha sub yo, but not descend into
it fo' inspection. I aint talkin' bout chicken n' gravy biatch.  In dis case though, we simply continue down ta line 29:
.PP
.Vb 2
\&        DB<4> c 29  
\&        main::f2c(temp:29):             return $c;
.Ve
.PP
And gotz a peep tha return value:
.PP
.Vb 2
\&        DB<5> p $c
\&        162.944444444444
.Ve
.PP
This aint tha right answer at all yo, but tha sum looks erect.  I wonder if
itz anythang ta do wit operator precedence?  We bout ta try a cold-ass lil couple other
possibilitizzles wit our sum:
.PP
.Vb 2
\&        DB<6> p (5 * $f \- 32 / 9)
\&        162.944444444444
\&
\&        DB<7> p 5 * $f \- (32 / 9) 
\&        162.944444444444
\&
\&        DB<8> p (5 * $f) \- 32 / 9
\&        162.944444444444
\&
\&        DB<9> p 5 * ($f \- 32) / 9
\&        0.722222222222221
.Ve
.PP
:\-) thatz mo' like dat shiznit son!  Ok, now we can set our return variable n' we'll
return outta tha sub wit a 'r':
.PP
.Vb 1
\&        DB<10> $c = 5 * ($f \- 32) / 9
\&
\&        DB<11> r
\&        scalar context return from main::f2c: 0.722222222222221
.Ve
.PP
Looks good, letz just continue off tha end of tha script:
.PP
.Vb 5
\&        DB<12> c
\&        0.72 c 
\&        Debugged program terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use q ta quit or R ta restart,
\&        use O inhibit_exit ta avoid stoppin afta program termination,
\&        h q, h R or h O ta git additionizzle info.
.Ve
.PP
A quick fix ta tha offendin line (insert tha missin parentheses) up in the
actual program n' we finished.
.SH "Placeholda fo' a, w, t, T"
.IX Header "Placeholda fo' a, w, t, T"
Actions, peep variables, stack traces etc.: on tha \s-1TODO\s0 list.
.PP
.Vb 1
\&        a 
\&
\&        w 
\&
\&        t 
\&
\&        T
.Ve
.SH "REGULAR EXPRESSIONS"
.IX Header "REGULAR EXPRESSIONS"
Ever wanted ta know what tha fuck a regex looked like?  You'll need perl compiled with
the \s-1DEBUGGING\s0 flag fo' dis one:
.PP
.Vb 10
\&        > perl \-Dr \-e \*(Aq/^pe(a)*rl$/i\*(Aq
\&        Compilin REx \`^pe(a)*rl$\*(Aq
\&        size 17 first at 2
\&        rarest char
\&         at 0
\&           1: BOL(2)
\&           2: EXACTF <pe>(4)
\&           4: CURLYN[1] {0,32767}(14)
\&           6:   NOTHING(8)
\&           8:   EXACTF <a>(0)
\&          12:   WHILEM(0)
\&          13: NOTHING(14)
\&          14: EXACTF <rl>(16)
\&          16: EOL(17)
\&          17: END(0)
\&        floatin \`\*(Aq$ at 4..2147483647 (checkin floating) stclass \`EXACTF <pe>\*(Aq
\&anchored(BOL) minlen 4
\&        Omittin $\` $& $\*(Aq support.
\&
\&        EXECUTING...
\&
\&        Freein REx: \`^pe(a)*rl$\*(Aq
.Ve
.PP
Did yo dirty ass straight-up wanna know? :\-)
For mo' gory details on gettin regular expressions ta work, gotz a peep
perlre, perlretut, n' ta decode tha mysterious labels (\s-1BOL\s0 n' \s-1CURLYN,\s0
etc. above), peep perldebguts.
.SH "OUTPUT TIPS"
.IX Header "OUTPUT TIPS"
To git all tha output from yo' error log, n' not miss any lyrics via
helpful operatin system buffering, bang a line like this, all up in tha start of
your script:
.PP
.Vb 1
\&        $|=1;
.Ve
.PP
To peep tha tail of a thugged-out dynamically growin logfile, (from tha command line):
.PP
.Vb 1
\&        tail \-f $error_log
.Ve
.PP
Rappin bout all take a thugged-out dirtnap calls up in a handlez routine can be useful ta peep how, n' from
where, they bein called, perlvar has mo' shiznit:
.PP
.Vb 1
\&        BEGIN { $SIG{_\|_DIE_\|_} = sub { require Carp; Carp::confess(@_) } }
.Ve
.PP
Various useful steez fo' tha redirection of \s-1STDOUT\s0 n' \s-1STDERR\s0 filehandles
are explained up in perlopentut n' perlfaq8.
.SH "CGI"
.IX Header "CGI"
Just a quick hint here fo' all dem \s-1CGI\s0 programmers whoz ass can't figure up how
on earth ta git past dat 'waitin fo' input' prompt, when hustlin they \s-1CGI\s0
script from tha command-line, try suttin' like this:
.PP
.Vb 1
\&        > perl \-d my_cgi.pl \-nodebug
.Ve
.PP
Of course \s-1CGI\s0 n' perlfaq9 will rap  more.
.SH "GUIs"
.IX Header "GUIs"
Da command line intercourse is tightly integrated wit a \fBemacs\fR extension
and there be a a \fBvi\fR intercourse like a muthafucka.
.PP
Yo ass don't gotta do dis all on tha command line, though, there be all dem \s-1GUI\s0
options up there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da sick thang bout these is you can wave a mouse over a
variable n' a thugged-out dump of its data will step tha fuck up in a appropriate window, or up in a
popup balloon, no mo' tiresome typin of 'x \f(CW$varname\fR' :\-)
.PP
In particular gotz a hunt round fo' tha following:
.PP
\&\fBptkdb\fR perlTK based wrapper fo' tha built-in debugger
.PP
\&\fBddd\fR data display debugger
.PP
\&\fBPerlDevKit\fR n' \fBPerlBuilder\fR is \s-1NT\s0 specific
.PP
\&\s-1NB. \s0(more info on these n' others would be appreciated).
.SH "SUMMARY"
.IX Header "SUMMARY"
We've peeped how tha fuck ta encourage phat codin practices wit \fBuse strict\fR and
\&\fB\-w\fR.  We can run tha perl debugger \fBperl \-d scriptname\fR ta inspect your
data from within tha perl debugger wit tha \fBp\fR n' \fBx\fR commands.  Yo ass can
walk all up in yo' code, set breakpoints wit \fBb\fR n' step all up in dat code
with \fBs\fR or \fBn\fR, continue wit \fBc\fR n' return from a sub wit \fBr\fR.  Fairly
intuitizzle shiznit when you git down ta dat shit.
.PP
There iz of course fuckin shitloadz mo' ta smoke up about, dis has just scratched the
surface.  Da dopest way ta learn mo' is ta use perldoc ta smoke up mo' about
the language, ta read tha on-line help (perldebug is probably tha next
place ta go), n' of course, experiment.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perldebug, 
perldebguts, 
perldiag,
perlrun
.SH "AUTHOR"
.IX Header "AUTHOR"
Slick Rick Foley <richard.foley@rfi.net> Copyright (c) 2000
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Various playas have made helpful suggestions n' contributions, up in particular:
.PP
Ronald J Kimbizzle <rjk@linguist.dartmouth.edu>
.PP
Hugo van der Sanden <hv@crypt0.demon.co.uk>
.PP
Peta Scott <Peter@PSDT.com>
