.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLUNIFAQ 1"
.TH PERLUNIFAQ 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlunifaq \- Perl Unicode FAQUIZZY
.SH "Q n' A"
.IX Header "Q n' A"
This be a list of thangs n' lyrics bout Unicode up in Perl, intended ta be
read afta perlunitut.
.SS "perlunitut aint straight-up a Unicode tutorial, is it?"
.IX Subsection "perlunitut aint straight-up a Unicode tutorial, is it?"
Fuck dat shit, n' dis aint straight-up a Unicode \s-1FAQ.\s0
.PP
Perl has a abstracted intercourse fo' all supported characta encodings, so this
is straight-up a generic \f(CW\*(C`Encode\*(C'\fR tutorial n' \f(CW\*(C`Encode\*(C'\fR \s-1FAQ.\s0 But nuff people
think dat Unicode is special n' magical, n' I didn't wanna disappoint
them, so I decided ta booty-call tha document a Unicode tutorial.
.SS "What characta encodings do Perl support?"
.IX Subsection "What characta encodings do Perl support?"
To smoke up which characta encodings yo' Perl supports, run:
.PP
.Vb 1
\&    perl \-MEncode \-le "print fo' Encode\->encodings(\*(Aq:all\*(Aq)"
.Ve
.SS "Which version of perl should I use?"
.IX Subsection "Which version of perl should I use?"
Well, if you can, upgrade ta da most thugged-out recent yo, but certainly \f(CW5.8.1\fR or newer.
Da tutorial n' \s-1FAQ\s0 assume tha sickest fuckin release.
.PP
Yo ass should also check yo' modules, n' upgrade dem if necessary. For example,
HTML::Entitizzles requires version >= 1.32 ta function erectly, even though the
changelog is silent bout all dis bullshit.
.SS "What bout binary data, like images?"
.IX Subsection "What bout binary data, like images?"
Well, apart from a funky-ass bare \f(CW\*(C`binmode $fh\*(C'\fR, you shouldn't treat dem specially.
(Da binmode is needed cuz otherwise Perl may convert line endings on Win32
systems.)
.PP
Be careful, though, ta never combine text strings wit binary strings. If you
need text up in a funky-ass binary stream, encode yo' text strings first rockin the
appropriate encoding, then join dem wit binary strings. Right back up in yo muthafuckin ass. See also: \*(L"What if I
don't encode?\*(R".
.SS "When should I decode or encode?"
.IX Subsection "When should I decode or encode?"
Whenever you communicatin text wit anythang dat is external ta yo' perl
process, like a thugged-out database, a text file, a socket, or another program. Even if
the thang you communicatin wit be also freestyled up in Perl.
.SS "What if I don't decode?"
.IX Subsection "What if I don't decode?"
Whenever yo' encoded, binary strang is used together wit a text string, Perl
will assume dat yo' binary strang was encoded wit \s-1ISO\-8859\-1,\s0 also known as
latin\-1. If it wasn't latin\-1, then yo' data is unpleasantly converted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For
example, if dat shiznit was \s-1UTF\-8,\s0 tha individual bytez of multibyte charactas is seen
as separate characters, n' then again n' again n' again converted ta \s-1UTF\-8.\s0 Such double encoding
can be compared ta double \s-1HTML\s0 encodin (\f(CW\*(C`&amp;gt;\*(C'\fR), or double \s-1URI\s0 encoding
(\f(CW%253E\fR).
.PP
This silent implicit decodin is known as \*(L"upgrading\*(R". That may sound
positizzle yo, but itz dopest ta avoid dat shit.
.SS "What if I don't encode?"
.IX Subsection "What if I don't encode?"
Yo crazy-ass text strang is ghon be busted rockin tha bytes up in Perlz internal format. In
some cases, Perl will warn you dat you bustin suttin' wrong, wit a
friendly warning:
.PP
.Vb 1
\&    Wide characta up in print at example.pl line 2.
.Ve
.PP
Because tha internal format is often \s-1UTF\-8,\s0 these bugs is hard ta spot,
because \s-1UTF\-8\s0 is probably tha encodin you wanted hommie! But don't be lazy, n' don't
use tha fact dat Perlz internal format is \s-1UTF\-8\s0 ta yo' advantage. Encode
explicitly ta avoid weird bugs, n' ta show ta maintenizzle programmers dat you
thought dis through.
.SS "Is there a way ta automatically decode or encode?"
.IX Subsection "Is there a way ta automatically decode or encode?"
If all data dat be reppin a cold-ass lil certain handle is encoded up in exactly tha same
way, you can tell tha PerlIO system ta automatically decode every last muthafuckin thang, with
the \f(CW\*(C`encoding\*(C'\fR layer n' shit. If you do this, you can't accidentally forget ta decode
or encode no mo', on thangs dat use tha layered handle.
.PP
Yo ass can provide dis layer when \f(CW\*(C`open\*(C'\fRin tha file:
.PP
.Vb 2
\&  open mah $fh, \*(Aq>:encoding(UTF\-8)\*(Aq, $filename;  # auto encodin on write
\&  open mah $fh, \*(Aq<:encoding(UTF\-8)\*(Aq, $filename;  # auto decodin on read
.Ve
.PP
Or if you already have a open filehandle:
.PP
.Vb 1
\&  binmode $fh, \*(Aq:encoding(UTF\-8)\*(Aq;
.Ve
.PP
Some database drivers fo' \s-1DBI\s0 can also automatically encode n' decode yo, but
that is sometimes limited ta tha \s-1UTF\-8\s0 encoding.
.SS "What if I don't give a fuck which encodin was used?"
.IX Subsection "What if I don't give a fuck which encodin was used?"
Do whatever you can ta smoke up, n' if you have to: guess. (Don't forget to
document yo' guess wit a cold-ass lil comment.)
.PP
Yo ass could open tha document up in a wizzy browser, n' chizzle tha characta set or
characta encodin until you can visually confirm dat all charactas look the
way they should.
.PP
There is no way ta reliably detect tha encodin automatically, so if people
keep bustin  you data without charset indication, you may gotta educate em.
.SS "Can I use Unicode up in mah Perl sources?"
.IX Subsection "Can I use Unicode up in mah Perl sources?"
Yes, you can! If yo' sources is \s-1UTF\-8\s0 encoded, you can indicate dat wit the
\&\f(CW\*(C`use utf8\*(C'\fR pragma.
.PP
.Vb 1
\&    use utf8;
.Ve
.PP
This don't do anythang ta yo' input, or ta yo' output. Well shiiiit, it only influences
the way yo' sources is read. Y'all KNOW dat shit, muthafucka! Yo ass can use Unicode up in strang literals, in
identifiers (but they still gotta be \*(L"word characters\*(R" accordin ta \f(CW\*(C`\ew\*(C'\fR),
and even up in custom delimiters.
.SS "Data::Dumper don't restore tha \s-1UTF8\s0 flag; is it broken?"
.IX Subsection "Data::Dumper don't restore tha UTF8 flag; is it broken?"
Fuck dat shit, Data::Dumperz Unicode abilitizzles is as they should be. There have been
some disses dat it should restore tha \s-1UTF8\s0 flag when tha data is read
again wit \f(CW\*(C`eval\*(C'\fR. But fuck dat shiznit yo, tha word on tha street is dat you should straight-up not peep tha flag, and
nothang indicates dat Data::Dumper should break dis rule.
.PP
Herez what tha fuck happens: when Perl readz up in a strang literal, it sticks ta 8 bit
encodin as long as it can. I aint talkin' bout chicken n' gravy biatch. (But like originally dat shiznit was internally encoded
as \s-1UTF\-8,\s0 when you dumped dat shit.) When it has ta give dat up cuz other
charactas is added ta tha text string, it silently upgrades tha strang to
\&\s-1UTF\-8. \s0
.PP
If you properly encode yo' strings fo' output, none of dis iz of your
concern, n' you can just \f(CW\*(C`eval\*(C'\fR dumped data as always.
.SS "Why do regex characta classes sometimes match only up in tha \s-1ASCII\s0 range?"
.IX Subsection "Why do regex characta classes sometimes match only up in tha ASCII range?"
.SS "Why do some charactas not uppercase or lowercase erectly?"
.IX Subsection "Why do some charactas not uppercase or lowercase erectly?"
Startin up in Perl 5.14 (and partially up in Perl 5.12), just put a
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR near tha beginnin of yo' program.
Within its lexical scope you shouldn't have dis problem.  It also is
automatically enabled under \f(CW\*(C`use feature \*(Aq:5.12\*(Aq\*(C'\fR or \f(CW\*(C`use v5.12\*(C'\fR or
usin \f(CW\*(C`\-E\*(C'\fR on tha command line fo' Perl 5.12 or higher.
.PP
Da rationale fo' requirin dis is ta not break olda programs that
rely on tha way thangs hit dat shiznit before Unicode came along.  Those older
programs knew only bout tha \s-1ASCII\s0 characta set, n' so may not work
properly fo' additionizzle characters.  When a strang is encoded up in \s-1UTF\-8,\s0
Perl assumes dat tha program is prepared ta deal wit Unicode yo, but when
the strang aint, Perl assumes dat only \s-1ASCII\s0
is wanted, n' so dem charactas dat is not \s-1ASCII\s0
charactas aren't recognized as ta what tha fuck they would be up in Unicode.
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR  drops some lyrics ta Perl ta treat all charactas as
Unicode, whether tha strang is encoded up in \s-1UTF\-8\s0 or not, thus avoiding
the problem.
.PP
But fuck dat shiznit yo, tha word on tha street is dat on earlier Perls, or if you pass strings ta subroutines outside
the featurez scope, you can force Unicode semantics by changin the
encodin ta \s-1UTF\-8\s0 by bustin \f(CW\*(C`utf8::upgrade($string)\*(C'\fR. This can be used
safely on any string, as it checks n' do not chizzle strings dat have
already been upgraded.
.PP
For a mo' detailed rap, peep Unicode::Semantics on \s-1CPAN.\s0
.SS "How tha fuck can I determine if a strang be a text strang or a funky-ass binary string?"
.IX Subsection "How tha fuck can I determine if a strang be a text strang or a funky-ass binary string?"
Yo ass can't. Right back up in yo muthafuckin ass. Some use tha \s-1UTF8\s0 flag fo' dis yo, but thatz misuse, n' make well
behaved modulez like Data::Dumper look bad. Y'all KNOW dat shit, muthafucka! Da flag is useless fo' this
purpose, cuz itz off when a 8 bit encodin (by default \s-1ISO\-8859\-1\s0) is
used ta store tha string.
.PP
This is suttin' you, tha programmer, has ta keep track of; sorry bout dat bullshit. Yo ass could
consider adoptin a kind of \*(L"Hungarian notation\*(R" ta help wit all dis bullshit.
.SS "How tha fuck do I convert from encodin \s-1FOO\s0 ta encodin \s-1BAR\s0?"
.IX Subsection "How tha fuck do I convert from encodin FOO ta encodin BAR?"
By first convertin tha FOO-encoded byte strang ta a text string, n' then the
text strang ta a BAR-encoded byte string:
.PP
.Vb 2
\&    mah $text_strin = decode(\*(AqFOO\*(Aq, $foo_string);
\&    mah $bar_strin  = encode(\*(AqBAR\*(Aq, $text_string);
.Ve
.PP
or by skippin tha text strang part, n' goin directly from one binary
encodin ta tha other:
.PP
.Vb 2
\&    use Encode qw(from_to);
\&    from_to($string, \*(AqFOO\*(Aq, \*(AqBAR\*(Aq);  # chizzlez contentz of $string
.Ve
.PP
or by lettin automatic decodin n' encodin do all tha work:
.PP
.Vb 3
\&    open mah $foofh, \*(Aq<:encoding(FOO)\*(Aq, \*(Aqexample.foo.txt\*(Aq;
\&    open mah $barfh, \*(Aq>:encoding(BAR)\*(Aq, \*(Aqexample.bar.txt\*(Aq;
\&    print { $barfh } $_ while <$foofh>;
.Ve
.ie n .SS "What is ""decode_utf8"" n' ""encode_utf8""?"
.el .SS "What is \f(CWdecode_utf8\fP n' \f(CWencode_utf8\fP?"
.IX Subsection "What is decode_utf8 n' encode_utf8?"
These is alternate syntaxes fo' \f(CW\*(C`decode(\*(Aqutf8\*(Aq, ...)\*(C'\fR n' \f(CW\*(C`encode(\*(Aqutf8\*(Aq,
\&...)\*(C'\fR.
.ie n .SS "What tha fuck iz a ""wide character""?"
.el .SS "What tha fuck iz a ``wide character''?"
.IX Subsection "What tha fuck iz a wide character?"
This be a term used both fo' charactas wit a ordinal value pimped outa than 127,
charactas wit a ordinal value pimped outa than 255, or any characta occupying
more than one byte, dependin on tha context.
.PP
Da Perl warnin \*(L"Wide characta up in ...\*(R" is caused by a cold-ass lil characta wit an
ordinal value pimped outa than 255. With no specified encodin layer, Perl tries to
fit thangs up in \s-1ISO\-8859\-1\s0 fo' backward compatibilitizzle reasons. When it can't, it
emits dis warnin (if warnings is enabled), n' outputs \s-1UTF\-8\s0 encoded data
instead.
.PP
To avoid dis warnin n' ta avoid havin different output encodings up in a single
stream, always specify a encodin explicitly, fo' example wit a PerlIO layer:
.PP
.Vb 1
\&    binmode STDOUT, ":encoding(UTF\-8)";
.Ve
.SH "INTERNALS"
.IX Header "INTERNALS"
.ie n .SS "What tha fuck iz ""the \s-1UTF8\s0 flag""?"
.el .SS "What tha fuck iz ``the \s-1UTF8\s0 flag''?"
.IX Subsection "What tha fuck iz tha UTF8 flag?"
Please, unless you jackin tha internals, or debuggin weirdness, don't
think bout tha \s-1UTF8\s0 flag at all. That means dat you straight-up probably shouldn't
use \f(CW\*(C`is_utf8\*(C'\fR, \f(CW\*(C`_utf8_on\*(C'\fR or \f(CW\*(C`_utf8_off\*(C'\fR at all.
.PP
Da \s-1UTF8\s0 flag, also called SvUTF8, be a internal flag dat indicates dat the
current internal representation is \s-1UTF\-8.\s0 Without tha flag, it be assumed ta be
\&\s-1ISO\-8859\-1.\s0 Perl converts between these automatically.  (Actually Perl usually
assumes tha representation is \s-1ASCII\s0; peep \*(L"Why do regex characta classes
sometimes match only up in tha \s-1ASCII\s0 range?\*(R" above.)
.PP
One of Perlz internal formats happens ta be \s-1UTF\-8.\s0 Unfortunately, Perl can't
keep a secret, so mah playas knows bout all dis bullshit. That is tha source of much
confusion. I aint talkin' bout chicken n' gravy biatch. It aint nuthin but betta ta pretend dat tha internal format is some unknown
encoding, n' dat you always gotta encode n' decode explicitly.
.ie n .SS "What bout tha ""use bytes"" pragma?"
.el .SS "What bout tha \f(CWuse bytes\fP pragma?"
.IX Subsection "What bout tha use bytes pragma?"
Don't use dat shit. Well shiiiit, it make no sense ta deal wit bytes up in a text string, n' it
makes no sense ta deal wit charactas up in a funky-ass byte string. Do tha proper
conversions (by decoding/encoding), n' thangs will work up well: you get
characta counts fo' decoded data, n' byte counts fo' encoded data.
.PP
\&\f(CW\*(C`use bytes\*(C'\fR is probably a gangbangin' failed attempt ta do suttin' useful naaahhmean, biatch? Just forget
about dat shit.
.ie n .SS "What bout tha ""use encoding"" pragma?"
.el .SS "What bout tha \f(CWuse encoding\fP pragma?"
.IX Subsection "What bout tha use encodin pragma?"
Don't use dat shit. Unfortunately, it assumes dat tha programmerz environment and
that of tha user will use tha same encoding. Well shiiiit, it will use tha same encodin for
the source code n' fo' \s-1STDIN\s0 n' \s-1STDOUT.\s0 When a program is copied ta another
machine, tha source code do not chizzle yo, but tha \s-1STDIO\s0 environment might.
.PP
If you need non-ASCII charactas up in yo' source code, make it a \s-1UTF\-8\s0 encoded
file n' \f(CW\*(C`use utf8\*(C'\fR.
.PP
If you need ta set tha encodin fo' \s-1STDIN, STDOUT,\s0 n' \s-1STDERR,\s0 fo' example
based on tha userz locale, \f(CW\*(C`use open\*(C'\fR.
.ie n .SS "What tha fuck iz tha difference between "":encoding"" n' "":utf8""?"
.el .SS "What tha fuck iz tha difference between \f(CW:encoding\fP n' \f(CW:utf8\fP?"
.IX Subsection "What tha fuck iz tha difference between :encodin n' :utf8?"
Because \s-1UTF\-8\s0 is one of Perlz internal formats, you can often just skip the
encodin or decodin step, n' manipulate tha \s-1UTF8\s0 flag directly.
.PP
Instead of \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR, you can simply use \f(CW\*(C`:utf8\*(C'\fR, which skips the
encodin step if tha data was already represented as \s-1UTF8\s0 internally. This is
widely accepted as phat behavior when you writin yo, but it can be dangerous
when reading, cuz it causes internal inconsistency when you have invalid
byte sequences. Usin \f(CW\*(C`:utf8\*(C'\fR fo' input can sometimes result up in security
breaches, so please use \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR instead.
.PP
Instead of \f(CW\*(C`decode\*(C'\fR n' \f(CW\*(C`encode\*(C'\fR, you could use \f(CW\*(C`_utf8_on\*(C'\fR n' \f(CW\*(C`_utf8_off\*(C'\fR,
but dis is considered wack style. Especially \f(CW\*(C`_utf8_on\*(C'\fR can be dangerous, for
the same reason dat \f(CW\*(C`:utf8\*(C'\fR can.
.PP
There is some shortcuts fo' oneliners;
see \-C up in perlrun.
.ie n .SS "Whatz tha difference between ""UTF\-8"" n' ""utf8""?"
.el .SS "Whatz tha difference between \f(CWUTF\-8\fP n' \f(CWutf8\fP?"
.IX Subsection "Whatz tha difference between UTF-8 n' utf8?"
\&\f(CW\*(C`UTF\-8\*(C'\fR is tha straight-up legit standard. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`utf8\*(C'\fR is Perlz way of bein liberal in
what it accepts, n' you can put dat on yo' toast. If you gotta rap wit thangs dat aren't so liberal,
you may wanna consider rockin \f(CW\*(C`UTF\-8\*(C'\fR. If you gotta rap wit thangs
that is too liberal, you may gotta use \f(CW\*(C`utf8\*(C'\fR. Da full explanation is in
Encode.
.PP
\&\f(CW\*(C`UTF\-8\*(C'\fR is internally known as \f(CW\*(C`utf\-8\-strict\*(C'\fR. Da tutorial uses \s-1UTF\-8\s0
consistently, even where utf8 is straight-up used internally, cuz the
distinction can be hard ta make, n' is mostly irrelevant.
.PP
For example, utf8 can be used fo' code points dat don't exist up in Unicode, like
9999999 yo, but if you encode dat ta \s-1UTF\-8,\s0 you git a substitution characta (by
default; peep \*(L"Handlin Malformed Data\*(R" up in Encode fo' mo' wayz of dealin with
this.)
.PP
Okay, if you insist: tha \*(L"internal format\*(R" is utf8, not \s-1UTF\-8. \s0(When itz not
some other encoding.)
.SS "I lost track; what tha fuck encodin is tha internal format straight-up?"
.IX Subsection "I lost track; what tha fuck encodin is tha internal format straight-up?"
It aint nuthin but phat dat you lost track, cuz you shouldn't depend on tha internal
format bein any specific encoding. But since you asked: by default, the
internal format is either \s-1ISO\-8859\-1 \s0(latin\-1), or utf8, dependin on the
history of tha string. On \s-1EBCDIC\s0 platforms, dis may be different even.
.PP
Perl knows how tha fuck it stored tha strang internally, n' will use dat knowledge
when you \f(CW\*(C`encode\*(C'\fR. In other lyrics: don't try ta smoke up what tha fuck tha internal
encodin fo' a cold-ass lil certain strang is yo, but instead just encode it tha fuck into tha encoding
that you want.
.SH "AUTHOR"
.IX Header "AUTHOR"
Juerd Waalboer <#####@juerd.nl>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunicode, perluniintro, Encode
