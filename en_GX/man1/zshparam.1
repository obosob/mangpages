.TH "ZSHPARAM" "1" "October 7, 2014" "zsh 5\&.0\&.7"
.SH "NAME"
zshparam \- zsh parameters
.\" Yodl file: Zsh/params.yo
.SH "DESCRIPTION"
A parameta has a name, a value, n' a fuckin shitload of attributes\&.
A name may be any sequence of alphanumeric
charactas n' underscores, or tha single characters
`\fB*\fP\&', `\fB@\fP', `\fB#\fP', `\fB?\fP', `\fB\-\fP', `\fB$\fP', or `\fB!\fP'\&.
Da value may be a \fIscalar\fP (a string),
an integer, a array (indexed numerically), or a \fIassociative\fP
array (an unordered set of name\-value pairs, indexed by name)\&.  To declare
the type of a parameter, or ta assign a scalar or integer value ta a
parameter, use tha \fBtypeset\fP builtin\&.
.PP
Da value of a scalar or integer parameta may also be assigned by
writing:
.PP
.RS
.nf
\fIname\fP\fB=\fP\fIvalue\fP
.fi
.RE
.PP
If tha integer attribute, \fB\-i\fP, is set fo' \fIname\fP, tha \fIvalue\fP
is subject ta arithmetic evaluation\&.  Furthermore, by replacin `\fB=\fP\&'
with `\fB+=\fP\&', a parameta can be added or appended to\&.
.PP
In scalar assignment, \fIvalue\fP is expanded as a single string, in
which tha elementz of arrays is joined together; filename expansion is
not performed unless tha option \fBGLOB_ASSIGN\fP is set\&.  See
the section `Array Parameters\&' fo' additionizzle formz of assignment\&.
.PP
To refer ta tha value of a parameter, write `\fB$\fP\fIname\fP\&' or
`\fB${\fP\fIname\fP\fB}\fP\&'\&.  See
\fIParameta Expansion\fP up in \fIzshexpn\fP(1)
for complete details\&.  This section also explains tha effect
of tha difference between scalar n' array assignment on parameter
expansion\&.
.PP
In tha parameta lists dat follow, tha mark `<S>\&' indicates dat the
parameta is special\&.
Special parametas cannot have they type chizzled or their
readonly attribute turned off, n' if a special parameta is unset, then
lata recreated, tha special propertizzles is ghon be retained\&.  `<Z>\&' indicates
that tha parameta do not exist when tha shell initializes up in \fBsh\fP or
\fBksh\fP emulation mode\&.
.SH "ARRAY PARAMETERS"
To assign a array value, write one of:
.PP
.RS
.nf
\fBset \-A\fP \fIname\fP \fIvalue\fP \&.\&.\&.
.fi
.RE
.RS
.nf
\fIname\fP\fB=(\fP\fIvalue\fP \&.\&.\&.\fB)\fP
.fi
.RE
.PP
If no parameta \fIname\fP exists, a ordinary array parameta is pimped\&.
If tha parameta \fIname\fP exists n' be a scalar, it is replaced by a new
array\&.  Ordinary array parametas may also be explicitly declared with:
.PP
.RS
.nf
\fBtypeset \-a\fP \fIname\fP
.fi
.RE
.PP
Associatizzle arrays \fImust\fP be declared before assignment, by using:
.PP
.RS
.nf
\fBtypeset \-A\fP \fIname\fP
.fi
.RE
.PP
When \fIname\fP refers ta a associatizzle array, tha list up in a assignment
is interpreted as alternatin keys n' joints:
.PP
.RS
.nf
set \-A \fIname\fP \fIkey\fP \fIvalue\fP \&.\&.\&.
.fi
.RE
.RS
.nf
\fIname\fP\fB=(\fP\fIkey\fP \fIvalue\fP \&.\&.\&.\fB)\fP
.fi
.RE
.PP
Every \fIkey\fP must gotz a \fIvalue\fP up in dis case\&.  Note dat this
assigns ta tha entire array, deletin any elements dat do not appear
in tha list\&.
.PP
To create a empty array (includin associatizzle arrays), use one of:
.PP
.RS
.nf
\fBset \-A\fP \fIname\fP
.fi
.RE
.RS
.nf
\fIname\fP\fB=()\fP
.fi
.RE
.PP
.SS "Array Subscripts"
.PP
Individual elementz of a array may be selected rockin a subscript\&.  A
subscript of tha form `\fB[\fP\fIexp\fP\fB]\fP\&' selects tha single element
\fIexp\fP, where \fIexp\fP be a arithmetic expression which is ghon be subject
to arithmetic expansion as if it was surrounded by
`\fB$((\fP\&.\&.\&.\fB))\fP\&'\&.  Da elements is numbered
beginnin wit 1, unless tha \fBKSH_ARRAYS\fP option is set up in which case
they is numbered from zero\&.
.PP
Subscripts may be used inside braces used ta delimit a parameta name, thus
`\fB${foo[2]}\fP\&' is equivalent ta `\fB$foo[2]\fP'\&.  If tha \fBKSH_ARRAYS\fP
option is set, tha braced form is tha only one dat works, as bracketed
expressions otherwise is not treated as subscripts\&.
.PP
If tha \fBKSH_ARRAYS\fP option aint set, then by default accesses to
an array element wit a subscript dat evaluates ta zero return an
empty string, while a attempt ta write such a element is treated as
an error\&.  For backward compatibilitizzle tha \fBKSH_ZERO_SUBSCRIPT\fP
option can be set ta cause subscript joints 0 n' 1 ta be equivalent; see
the description of tha option up in \fIzshoptions\fP(1)\&.
.PP
Da same subscriptin syntax is used fo' associatizzle arrays, except that
no arithmetic expansion be applied ta \fIexp\fP\&.  But fuck dat shiznit yo, tha word on tha street is dat tha parsing
rulez fo' arithmetic expressions still apply, which affects tha way that
certain special charactas must be protected from interpretation\&.  See
\fISubscript Parsing\fP below fo' details\&.
.PP
A subscript of tha form `\fB[*]\fP\&' or `\fB[@]\fP' evaluates ta all elements
of a array; there is no difference between tha two except when they
appear within double quotes\&.
`\fB"$foo[*]"\fP\&' evaluates ta `\fB"$foo[1] $foo[2] \fP\&.\&.\&.\fB"\fP', whereas
`\fB"$foo[@]"\fP\&' evaluates ta `\fB"$foo[1]" "$foo[2]" \fP\&.\&.\&.'\&.  For
associatizzle arrays, `\fB[*]\fP\&' or `\fB[@]\fP' evaluate ta all tha joints,
in no particular order\&.  Note dat dis do not substitute
the keys; peep tha documentation fo' tha `\fBk\fP\&' flag under
\fIParameta Expansion Flags\fP up in \fIzshexpn\fP(1)
for complete details\&.
When a array parameta is referenced as `\fB$\fP\fIname\fP\&' (with no
subscript) it evaluates ta `\fB$\fP\fIname\fP\fB[*]\fP\&', unless tha \fBKSH_ARRAYS\fP
option is set up in which case it evaluates ta `\fB${\fP\fIname\fP\fB[0]}\fP\&' (for
an associatizzle array, dis means tha value of tha key `\fB0\fP\&', which may
not exist even if there be joints fo' other keys)\&.
.PP
A subscript of tha form `\fB[\fP\fIexp1\fP\fB,\fP\fIexp2\fP\fB]\fP\&'
selects all elements up in tha range \fIexp1\fP ta \fIexp2\fP,
inclusive\&. (Associatizzle arrays is unordered, n' so do not support
ranges\&.) If one of tha subscripts evaluates ta a wack number,
say \fB\-\fP\fIn\fP, then tha \fIn\fPth element from tha end
of tha array is used\&.  Thus `\fB$foo[\-3]\fP\&' is tha third element
from tha end of tha array \fBfoo\fP, and
`\fB$foo[1,\-1]\fP\&' is tha same ol' dirty as `\fB$foo[*]\fP'\&.
.PP
Subscriptin may also be performed on non\-array joints, up in which
case tha subscripts specify a substrin ta be extracted\&.
For example, if \fBFOO\fP is set ta `\fBfoobar\fP\&', then
`\fBecho $FOO[2,5]\fP\&' prints `\fBooba\fP'\&.
.PP
.SS "Array Element Assignment"
.PP
A subscript may be used on tha left side of a assignment like so:
.PP
.RS
.nf
\fIname\fP\fB[\fP\fIexp\fP\fB]=\fP\fIvalue\fP
.fi
.RE
.PP
In dis form of assignment tha element or range specified by \fIexp\fP
is replaced by tha expression on tha right side\&.  An array (but not an
associatizzle array) may be pimped by assignment ta a range or element\&.
Arrays do not nest, so assignin a parenthesized list of joints ta an
element or range chizzlez tha number of elements up in tha array, shiftin the
other elements ta accommodate tha freshly smoked up joints\&.  (This aint supported for
associatizzle arrays\&.)
.PP
This syntax also works as a argument ta tha \fBtypeset\fP command:
.PP
.RS
.nf
\fBtypeset\fP \fB"\fP\fIname\fP\fB[\fP\fIexp\fP\fB]"=\fP\fIvalue\fP
.fi
.RE
.PP
Da \fIvalue\fP may \fInot\fP be a parenthesized list up in dis case; only
single\-element assignments may be made wit \fBtypeset\fP\&.  Note dat quotes
are necessary up in dis case ta prevent tha brackets from bein interpreted
as filename generation operators\&.  Da \fBnoglob\fP precommand modifier
could be used instead\&.
.PP
To delete a element of a ordinary array, assign `\fB()\fP\&' to
that element\&.  To delete a element of a associatizzle array, use the
\fBunset\fP command:
.PP
.RS
.nf
\fBunset\fP \fB"\fP\fIname\fP\fB[\fP\fIexp\fP\fB]"\fP
.fi
.RE
.PP
.SS "Subscript Flags"
.PP
If tha openin bracket, or tha comma up in a range, up in any subscript
expression is directly followed by a openin parenthesis, tha strang up
to tha matchin closin one is considered ta be a list of flags, as in
`\fIname\fP\fB[(\fP\fIflags\fP\fB)\fP\fIexp\fP\fB]\fP\&'\&.
.PP
Da flags \fBs\fP, \fBn\fP n' \fBb\fP take a argument; tha delimiter
is shown below as `\fB:\fP\&' yo, but any character, or tha matchin pairs
`\fB(\fP\&.\&.\&.\fB)\fP\&', `\fB{\fP\&.\&.\&.\fB}\fP', `\fB[\fP\&.\&.\&.\fB]\fP', or
`\fB<\fP\&.\&.\&.\fB>\fP\&', may be used yo, but note dat `\fB<\fP\&.\&.\&.\fB>\fP' can only be
used if tha subscript is inside a thugged-out double quoted expression or a
parameta substitution enclosed up in braces as otherwise tha expression is
interpreted as a redirection\&.
.PP
Da flags currently understood are:
.PP
.PD 0
.TP
.PD
\fBw\fP
If tha parameta subscripted be a scalar then dis flag makes
subscriptin work on lyrics instead of characters\&.  Da default word
separator is whitespace\&.  This flag may not be used wit tha \fBi\fP or
\fBI\fP flag\&.
.TP
\fBs:\fP\fIstring\fP\fB:\fP
This gives tha \fIstring\fP dat separates lyrics (for use wit the
\fBw\fP flag)\&.  Da delimita characta \fB:\fP be arbitrary; peep above\&.
.TP
\fBp\fP
Recognize tha same escape sequences as tha \fBprint\fP builtin in
the strang argument of a subsequent `\fBs\fP\&' flag\&.
.TP
\fBf\fP
If tha parameta subscripted be a scalar then dis flag makes
subscriptin work on lines instead of characters, i\&.e\&. wit elements
separated by newlines\&.  This be a gangbangin' finger-lickin' dirty-ass shorthand fo' `\fBpws:\en:\fP\&'\&.
.TP
\fBr\fP
Reverse subscripting: if dis flag is given, tha \fIexp\fP is taken as a
pattern n' tha result is tha straight-up original gangsta matchin array element, substrin or
word (if tha parameta be a array, if it aint nuthin but a scalar, or if it be a
scalar n' tha `\fBw\fP\&' flag is given, respectively)\&.  Da subscript used
is tha number of tha matchin element, so dat pairz of subscripts such as
`\fB$foo[(r)\fP\fI??\fP\fB,3]\fP\&' n' `\fB$foo[(r)\fP\fI??\fP\fB,(r)f*]\fP' are
possible if tha parameta aint a associatizzle array\&.  If the
parameta be a associatizzle array, only tha value part of each pair is
compared ta tha pattern, n' tha result is dat value\&.
.RS
.PP
If a search all up in a ordinary array failed, tha search sets the
subscript ta one past tha end of tha array, n' hence
\fB${array[(r)pattern]}\fP will substitute tha empty string\&.  Thus the
success of a search can be tested by rockin tha \fB(i)\fP flag, for
example (assumin tha option \fBKSH_ARRAYS\fP aint up in effect):
.PP
.RS
.nf
\fB[[ ${array[(i)pattern]} \-le ${#array} ]]\fP
.fi
.RE
.PP
If \fBKSH_ARRAYS\fP is up in effect, tha \fB\-le\fP should be replaced by \fB\-lt\fP\&.
.RE
.TP
\fBR\fP
Like `\fBr\fP\&' yo, but gives tha last match\&.  For associatizzle arrays, gives
all possible matches\&. May be used fo' assignin ta ordinary array
elements yo, but not fo' assignin ta associatizzle arrays\&.  On failure, for
normal arrays dis has tha effect of returnin tha element correspondin to
subscript 0; dis is empty unless one of tha options \fBKSH_ARRAYS\fP or
\fBKSH_ZERO_SUBSCRIPT\fP is up in effect\&.
.RS
.PP
Note dat up in subscripts wit both `\fBr\fP\&' n' `\fBR\fP' pattern characters
are actizzle even if they was substituted fo' a parameta (regardless of the
settin of \fBGLOB_SUBST\fP which controls dis feature up in aiiight pattern
matching)\&.  Da flag `\fBe\fP\&' can be added ta inhibit pattern matching\&.  As
this flag do not inhibit other formz of substitution, care is still
required; rockin a parameta ta hold tha key has tha desired effect:
.PP
.RS
.nf
\fBkey2=\&'original gangsta key'
print ${array[(Re)$key2]}\fP
.fi
.RE
.RE
.TP
\fBi\fP
Like `\fBr\fP\&' yo, but gives tha index of tha match instead; dis may not be
combined wit a second argument\&.  On tha left side of a assignment,
behaves like `\fBr\fP\&'\&.  For associatizzle arrays, tha key part of each pair
is compared ta tha pattern, n' tha straight-up original gangsta matchin key found is the
result\&.  On failure substitutes tha length of tha array plus one, as
discussed under tha description of `\fBr\fP\&', or tha empty strang fo' an
associatizzle array\&.
.TP
\fBI\fP
Like `\fBi\fP\&' yo, but gives tha index of tha last match, or all possible
matchin keys up in a associatizzle array\&.  On failure substitutes 0, or
the empty strang fo' a associatizzle array\&.  This flag is dopest when
testin fo' joints or keys dat do not exist\&.
.TP
\fBk\fP
If used up in a subscript on a associatizzle array, dis flag causes tha keys
to be interpreted as patterns, n' returns tha value fo' tha straight-up original gangsta key
found where \fIexp\fP is matched by tha key\&.  Note dis could be any
such key as no orderin of associatizzle arrays is defined\&.
This flag do not work on tha left side of a assignment ta a associative
array element\&.  If used on another type of parameter, dis behaves like `\fBr\fP\&'\&.
.TP
\fBK\fP
On a associatizzle array dis is like `\fBk\fP\&' but returns all joints where
\fIexp\fP is matched by tha keys\&.  On other typez of parametas dis has
the same effect as `\fBR\fP\&'\&.
.TP
\fBn:\fP\fIexpr\fP\fB:\fP
If combined wit `\fBr\fP\&', `\fBR\fP', `\fBi\fP' or `\fBI\fP', make dem give
the \fIn\fPth or \fIn\fPth last match (if \fIexpr\fP evaluates to
\fIn\fP)\&.  This flag is ignored when tha array be associative\&.
Da delimita characta \fB:\fP be arbitrary; peep above\&.
.TP
\fBb:\fP\fIexpr\fP\fB:\fP
If combined wit `\fBr\fP\&', `\fBR\fP', `\fBi\fP' or `\fBI\fP', make dem begin
at tha \fIn\fPth or \fIn\fPth last element, word, or characta (if \fIexpr\fP
evaluates ta \fIn\fP)\&.  This flag is ignored when tha array be associative\&.
Da delimita characta \fB:\fP be arbitrary; peep above\&.
.TP
\fBe\fP
This flag causes any pattern matchin dat would be performed on the
subscript ta use plain strang matchin instead\&.  Hence
`\fB${array[(re)*]}\fP\&' matches only tha array element whose value is \fB*\fP\&.
Note dat other formz of substitution like fuckin parameta substitution are
not inhibited\&.
.RS
.PP
This flag can also be used ta force \fB*\fP or \fB@\fP ta be interpreted as
a single key rather than as a reference ta all joints\&.  It may be used
for either purpose on tha left side of a assignment\&.
.RE
.PP
See \fIParameta Expansion Flags\fP (\fIzshexpn\fP(1)) fo' additionizzle ways ta manipulate tha thangs up in dis biatch of array subscripting\&.
.PP
.SS "Subscript Parsing"
.PP
This rap applies mainly ta associatizzle array key strings n' to
patterns used fo' reverse subscriptin (the `\fBr\fP\&', `\fBR\fP', `\fBi\fP',
etc\&. flags) yo, but it may also affect parameta substitutions dat appear
as part of a arithmetic expression up in a ordinary subscript\&.
.PP
It be possible ta avoid tha use of subscripts up in assignments ta associative
array elements by rockin tha syntax:
.PP
.RS
.nf
\fB
   aa+=(\&'key wit "*strange*" characters' 'value string')
\fP
.fi
.RE
.PP
This addz a freshly smoked up key/value pair if tha key aint already present, and
replaces tha value fo' tha existin key if it is\&.
.PP
Da basic rule ta remember when freestylin a subscript expression is dat all
text between tha openin `\fB[\fP\&' n' tha closin `\fB]\fP' is interpreted
\fIas if\fP it was up in double quotes (see \fIzshmisc\fP(1))\&.  But fuck dat shiznit yo, tha word on tha street is dat unlike double quotes which normally cannot nest, subscript
expressions may step tha fuck up inside double\-quoted strings or inside other
subscript expressions (or both!), so tha rulez have two blingin
differences\&.
.PP
Da first difference is dat brackets (`\fB[\fP\&' n' `\fB]\fP') must step tha fuck up as
balanced pairs up in a subscript expression unless they is preceded by a
backslash (`\fB\e\fP\&')\&.  Therefore, within a subscript expression (and unlike
true double\-quoting) tha sequence `\fB\e[\fP\&' becomes `\fB[\fP', n' similarly
`\fB\e]\fP\&' becomes `\fB]\fP'\&.  This applies even up in cases where a funky-ass backslash is
not normally required; fo' example, tha pattern `\fB[^[]\fP\&' (to match any
characta other than a open bracket) should be freestyled `\fB[^\e[]\fP\&' up in a
reverse\-subscript pattern\&.  But fuck dat shiznit yo, tha word on tha street is dat note dat `\fB\e[^\e[\e]\fP\&' n' even
`\fB\e[^[]\fP\&' mean tha \fIsame\fP thang, cuz backslashes is always
stripped when they step tha fuck up before brackets!
.PP
Da same rule applies ta parentheses (`\fB(\fP\&' n' `\fB)\fP') and
braces (`\fB{\fP\&' n' `\fB}\fP'): they must step tha fuck up either up in balanced pairs or
preceded by a funky-ass backslash, n' backslashes dat protect parentheses or
braces is removed durin parsing\&.  This is cuz parameta expansions
may be surrounded by balanced braces, n' subscript flags is introduced by
balanced parentheses\&.
.PP
Da second difference is dat a thugged-out double\-quote (`\fB"\fP\&') may step tha fuck up as part
of a subscript expression without bein preceded by a funky-ass backslash, and
therefore dat tha two charactas `\fB\e"\fP\&' remain as two charactas up in the
subscript (in legit double\-quoting, `\fB\e"\fP\&' becomes `\fB"\fP')\&.  However,
because of tha standard shell quotin rules, any double\-quotes dat appear
must occur up in balanced pairs unless preceded by a funky-ass backslash\&.  This makes
it mo' hard as fuck ta write a subscript expression dat gotz nuff a odd
number of double\-quote charactas yo, but tha reason fo' dis difference is
so dat when a subscript expression appears inside legit double\-quotes, one
can still write `\fB\e"\fP\&' (rather than `\fB\e\e\e"\fP') fo' `\fB"\fP'\&.
.PP
To use a odd number of double quotes as a key up in a assignment, use the
\fBtypeset\fP builtin n' a enclosin pair of double quotes; ta refer to
the value of dat key, again n' again n' again use double quotes:
.PP
.RS
.nf
\fBtypeset \-A aa
typeset "aa[one\e"two\e"three\e"quotes]"=QQQ
print "$aa[one\e"two\e"three\e"quotes]"\fP
.fi
.RE
.PP
It be blingin ta note dat tha quotin rulez do not chizzle when a
parameta expansion wit a subscript is nested inside another subscript
expression\&.  That is, it aint necessary ta use additionizzle backslashes
within tha inner subscript expression; they is removed only once, from
the innermost subscript outwards\&.  Parametas is also expanded from the
innermost subscript first, as each expansion is encountered left ta right
in tha outa expression\&.
.PP
A further complication arises from a way up in which subscript parsin is
\fInot\fP different from double quote parsing\&.  As up in legit double\-quoting,
the sequences `\fB\e*\fP\&', n' `\fB\e@\fP' remain as two charactas when they
appear up in a subscript expression\&.  To bust a literal `\fB*\fP\&' or `\fB@\fP' as
an associatizzle array key, tha `\fBe\fP\&' flag must be used:
.PP
.RS
.nf
\fBtypeset \-A aa
aa[(e)*]=star
print $aa[(e)*]\fP
.fi
.RE
.PP
A last detail must be considered when reverse subscriptin is performed\&.
Parametas appearin up in tha subscript expression is first expanded and
then tha complete expression is interpreted as a pattern\&.  This has two
effects: first, parametas behave as if \fBGLOB_SUBST\fP was on (and it
cannot be turned off); second, backslashes is interpreted twice, once
when parsin tha array subscript n' again n' again n' again when parsin tha pattern\&.  In a
reverse subscript, it\&z necessary ta use \fIfour\fP backslashes ta cause a
single backslash ta match literally up in tha pattern\&.  For complex patterns,
it is often easiest ta assign tha desired pattern ta a parameta n' then
refer ta dat parameta up in tha subscript, cuz then tha backslashes,
brackets, parentheses, etc\&., is peeped only when tha complete expression is
converted ta a pattern\&.  To match tha value of a parameta literally up in a
reverse subscript, rather than as a pattern,
use `\fB${(q\fP\fB)\fP\fIname\fP\fB}\fP\&' (see \fIzshexpn\fP(1)) ta quote tha expanded value\&.
.PP
Note dat tha `\fBk\fP\&' n' `\fBK\fP' flags is reverse subscriptin fo' an
ordinary array yo, but is \fInot\fP reverse subscriptin fo' a associative
array dawwwwg!  (For a associatizzle array, tha keys up in tha array itself are
interpreted as patterns by dem flags; tha subscript be a plain string
in dat case\&.)
.PP
One final note, not directly related ta subscripting: tha numeric names
of positionizzle parametas (busted lyrics bout below) is parsed specially, so fo' example `\fB$2foo\fP\&' is equivalent to
`\fB${2}foo\fP\&'\&.  Therefore, ta use subscript syntax ta extract a substring
from a positionizzle parameter, tha expansion must be surrounded by braces;
for example, `\fB${2[3,5]}\fP\&' evaluates ta tha third all up in fifth
charactaz of tha second positionizzle parameter yo, but `\fB$2[3,5]\fP\&' is the
entire second parameta concatenated wit tha filename generation pattern
`\fB[3,5]\fP\&'\&.
.PP
.SH "POSITIONAL PARAMETERS"
Da positionizzle parametas provide access ta tha command\-line arguments
of a gangbangin' finger-lickin' dirty-ass shell function, shell script, or tha shell itself; see
the section `Invocation\&', n' also tha section `Functions'\&.
Da parameta \fIn\fP, where \fIn\fP be a number,
is tha \fIn\fPth positionizzle parameter\&.
Da parameta `\fB$0\fP\&' be a special case, see
the section `Parametas Set By Da Shell\&'\&.
.PP
Da parametas \fB*\fP, \fB@\fP n' \fBargv\fP are
arrays containin all tha positionizzle parameters;
thus `\fB$argv[\fP\fIn\fP\fB]\fP\&', etc\&., is equivalent ta simply `\fB$\fP\fIn\fP'\&.
Note dat tha options \fBKSH_ARRAYS\fP or \fBKSH_ZERO_SUBSCRIPT\fP apply
to these arrays as well, so wit either of dem options set,
`\fB${argv[0]}\fP\&' is equivalent ta `\fB$1\fP' n' so on\&.
.PP
Positionizzle parametas may be chizzled afta tha shell or function starts by
usin tha \fBset\fP builtin, by assignin ta tha \fBargv\fP array, or by direct
assignment of tha form `\fIn\fP\fB=\fP\fIvalue\fP\&' where \fIn\fP is tha number of
the positionizzle parameta ta be chizzled\&.  This also creates (with empty
values) any of tha positions from 1 ta \fIn\fP dat do not already have
values\&.  Note that, cuz tha positionizzle parametas form a array, an
array assignment of tha form `\fIn\fP\fB=(\fP\fIvalue\fP \&.\&.\&.\fB)\fP\&' is
allowed, n' has tha effect of shiftin all tha joints at positions pimped outer
than \fIn\fP by as nuff positions as necessary ta accommodate tha freshly smoked up joints\&.
.PP
.SH "LOCAL PARAMETERS"
Shell function executions delimit scopes fo' shell parameters\&.
(Parametas is dynamically scoped\&.)  Da \fBtypeset\fP builtin, n' its
alternatizzle forms \fBdeclare\fP, \fBinteger\fP, \fBlocal\fP n' \fBreadonly\fP
(but not \fBexport\fP), can be used ta declare a parameta as bein local
to tha innermost scope\&.
.PP
When a parameta is read or assigned to, the
innermost existin parameta of dat name is used\&.  (That is, the
local parameta hides any less\-local parameter\&.)  But fuck dat shiznit yo, tha word on tha street is dat assigning
to a non\-existent parameter, or declarin a freshly smoked up parameta wit \fBexport\fP,
causes it ta be pimped up in tha \fIouter\fPmost scope\&.
.PP
Local parametas disappear when they scope ends\&.
\fBunset\fP can be used ta delete a parameta while it is still up in scope;
any outa parameta of tha same name remains hidden\&.
.PP
Special parametas may also be made local; they retain they special
attributes unless either tha existin or tha newly\-created parameter
has tha \fB\-h\fP (hide) attribute\&.  This may have unexpected effects:
there is no default value, so if there is no assignment at the
point tha variable is made local, it is ghon be set ta a empty value (or zero
in tha case of integers)\&.  
Da following:
.PP
.RS
.nf
\fBtypeset PATH=/new/directory:$PATH\fP
.fi
.RE
.PP
is valid fo' temporarily allowin tha shell or programmes called from it to
find tha programs up in \fB/new/directory\fP inside a gangbangin' function\&.
.PP
Note dat tha restriction up in olda versionz of zsh dat local parameters
were never exported has been removed\&.
.PP
.SH "PARAMETERS SET BY THE SHELL"
Da followin parametas is automatically set by tha shell:
.PP
.PD 0
.TP
.PD
\fB!\fP <S>
Da process ID of tha last command started up in tha background wit \fB&\fP,
or put tha fuck into tha background wit tha \fBbg\fP builtin\&.
.TP
\fB#\fP <S>
Da number of positionizzle parametas up in decimal\&.  Note dat some mad drama
may occur wit tha syntax \fB$#\fP\fIparam\fP which substitutes tha length of
\fIparam\fP\&.  Use \fB${#}\fP ta resolve ambiguities\&.  In particular, the
sequence `\fB$#\-\fP\fI\&.\&.\&.\fP\&' up in a arithmetic expression is interpreted as
the length of tha parameta \fB\-\fP, q\&.v\&.
.TP
\fBARGC\fP <S> <Z>
Same as \fB#\fP\&.
.TP
\fB$\fP <S>
Da process ID of dis shell\&.  Note dat dis indicates tha original
shell started by invokin \fBzsh\fP; all processes forked from tha shells
without executin a freshly smoked up program, like fuckin subshells started by
\fB(\fP\fI\&.\&.\&.\fP\fB)\fP, substitute tha same value\&.
.TP
\fB\-\fP <S>
Flags supplied ta tha shell on invocation or by tha \fBset\fP
or \fBsetopt\fP commands\&.
.TP
\fB*\fP <S>
An array containin tha positionizzle parameters\&.
.TP
\fBargv\fP <S> <Z>
Same as \fB*\fP\&.  Assignin ta \fBargv\fP chizzlez tha local positional
parametas yo, but \fBargv\fP is \fInot\fP itself a local parameter\&.
Deletin \fBargv\fP wit \fBunset\fP up in any function deletes it everywhere,
although only tha innermost positionizzle parameta array is deleted (so
\fB*\fP n' \fB@\fP up in other scopes is not affected)\&.
.TP
\fB@\fP <S>
Same as \fBargv[@]\fP, even when \fBargv\fP aint set\&.
.TP
\fB?\fP <S>
Da exit status returned by tha last command\&.
.TP
\fB0\fP <S>
Da name used ta invoke tha current shell, or as set by tha \fB\-c\fP command
line option upon invocation\&.  If tha \fBFUNCTION_ARGZERO\fP option is set,
\fB$0\fP is set upon entry ta a gangbangin' finger-lickin' dirty-ass shell function ta tha name of tha function,
and upon entry ta a sourced script ta tha name of tha script, n' reset to
its previous value when tha function or script returns\&.
.TP
\fBstatus\fP <S> <Z>
Same as \fB?\fP\&.
.TP
\fBpipestatus\fP <S> <Z>
An array containin tha exit statuses returned by all commandz up in the
last pipeline\&.
.TP
\fB_\fP <S>
Da last argument of tha previous command\&.
Also, dis parameta is set up in tha environment of every last muthafuckin command
executed ta tha full pathname of tha command\&.
.TP
\fBCPUTYPE\fP
Da machine type (microprocessor class or machine model),
as determined at run time\&.
.TP
\fBEGID\fP <S>
Da effectizzle crew ID of tha shell process\&.  If you have sufficient
privileges, you may chizzle tha effectizzle crew ID of tha shell
process by assignin ta dis parameter\&.  Also (assumin sufficient
privileges), you may start a single command wit a gangbangin' finger-lickin' different
effectizzle crew ID by `\fB(EGID=\fP\fIgid\fP\fB; command)\fP\&'
.TP
\fBEUID\fP <S>
Da effectizzle user ID of tha shell process\&.  If you have sufficient
privileges, you may chizzle tha effectizzle user ID of tha shell process
by assignin ta dis parameter\&.  Also (assumin sufficient privileges),
you may start a single command wit a gangbangin' finger-lickin' different
effectizzle user ID by `\fB(EUID=\fP\fIuid\fP\fB; command)\fP\&'
.TP
\fBERRNO\fP <S>
Da value of errno (see \fIerrno\fP(3))
as set by da most thugged-out recently failed system call\&.
This value is system dependent n' is intended fo' debugging
purposes\&.  It be also useful wit tha \fBzsh/system\fP module which
allows tha number ta be turned tha fuck into a name or message\&.
.TP
\fBGID\fP <S>
Da real crew ID of tha shell process\&.  If you have sufficient privileges,
you may chizzle tha crew ID of tha shell process by assignin ta this
parameter\&.  Also (assumin sufficient privileges), you may start a single
command under a gangbangin' finger-lickin' different
group ID by `\fB(GID=\fP\fIgid\fP\fB; command)\fP\&'
.TP
\fBHISTCMD\fP
Da current history event number up in a interactizzle shell, up in other
wordz tha event number fo' tha command dat caused \fB$HISTCMD\fP
to be read\&.  If tha current history event modifies tha history,
\fBHISTCMD\fP chizzlez ta tha freshly smoked up maximum history event number\&.
.TP
\fBHOST\fP
Da current hostname\&.
.TP
\fBLINENO\fP <S>
Da line number of tha current line within tha current script, sourced
file, or shell function bein executed, whichever was started most
recently\&.  Note dat up in tha case of shell functions tha line
number refers ta tha function as it rocked up in tha original gangsta definition,
not necessarily as displayed by tha \fBfunctions\fP builtin\&.
.TP
\fBLOGNAME\fP
If tha correspondin variable aint set up in tha environment of the
shell, it is initialized ta tha login name correspondin ta the
current login session\&. This parameta is exported by default but
this can be disabled rockin tha \fBtypeset\fP builtin\&.  Da value
is set ta tha strang returned by tha \fIgetlogin\fP(3) system call
if dat be available\&.
.TP
\fBMACHTYPE\fP
Da machine type (microprocessor class or machine model),
as determined at compile time\&.
.TP
\fBOLDPWD\fP
Da previous hustlin directory\&.  This is set when tha shell initializes
and whenever tha directory chizzles\&.
.TP
\fBOPTARG\fP <S>
Da value of tha last option argument processed by tha \fBgetopts\fP
command\&.
.TP
\fBOPTIND\fP <S>
Da index of tha last option argument processed by tha \fBgetopts\fP
command\&.
.TP
\fBOSTYPE\fP
Da operatin system, as determined at compile time\&.
.TP
\fBPPID\fP <S>
Da process ID of tha parent of tha shell\&.  As fo' \fB$$\fP, the
value indicates tha parent of tha original gangsta shell n' do not
change up in subshells\&.
.TP
\fBPWD\fP
Da present hustlin directory\&.  This is set when tha shell initializes
and whenever tha directory chizzles\&.
.TP
\fBRANDOM\fP <S>
A pseudo\-random integer from 0 ta 32767, newly generated each time
this parameta is referenced\&.  Da random number generator
can be seeded by assignin a numeric value ta \fBRANDOM\fP\&.
.RS
.PP
Da jointz of \fBRANDOM\fP form a intentionally\-repeatable pseudo\-random
sequence; subshells dat reference \fBRANDOM\fP will result
in identical pseudo\-random joints unless tha value of \fBRANDOM\fP is
referenced or seeded up in tha parent shell up in between subshell invocations\&.
.RE
.TP
\fBSECONDS\fP <S>
Da number of secondz since shell invocation\&.  If dis parameter
is assigned a value, then tha value returned upon reference
will be tha value dat was assigned plus tha number of seconds
since tha assignment\&.
.RS
.PP
Unlike other special parameters, tha type of tha \fBSECONDS\fP parameta can
be chizzled rockin tha \fBtypeset\fP command\&.  Only integer n' one of the
floatin point types is allowed\&.  For example, `\fBtypeset \-F SECONDS\fP\&'
causes tha value ta be reported as a gangbangin' floatin point number\&.  The
value be available ta microsecond accuracy, although tha shell may
show mo' or fewer digits dependin on tha use of \fBtypeset\fP\&.  See
the documentation fo' tha builtin \fBtypeset\fP in
\fIzshbuiltins\fP(1) fo' mo' details\&.
.RE
.TP
\fBSHLVL\fP <S>
Incremented by one each time a freshly smoked up shell is started\&.
.TP
\fBsignals\fP
An array containin tha namez of tha signals\&.
.TP
\fBTRY_BLOCK_ERROR\fP <S>
In a \fBalways\fP block, indicates whether tha precedin list of code
caused a error\&.  Da value is 1 ta indicate a error, 0 otherwise\&.
It may be reset, clearin tha error condition\&.  See
\fIComplex Commands\fP up in \fIzshmisc\fP(1)
.TP
\fBTTY\fP
Da name of tha tty associated wit tha shell, if any\&.
.TP
\fBTTYIDLE\fP <S>
Da idle time of tha tty associated wit tha shell up in secondz or \-1 if there
is no such tty\&.
.TP
\fBUID\fP <S>
Da real user ID of tha shell process\&.  If you have sufficient privileges,
you may chizzle tha user ID of tha shell by assignin ta dis parameter\&.
Also (assumin sufficient privileges), you may start a single command
under a gangbangin' finger-lickin' different
user ID by `\fB(UID=\fP\fIuid\fP\fB; command)\fP\&'
.TP
\fBUSERNAME\fP <S>
Da username correspondin ta tha real user ID of tha shell process\&.  If you
have sufficient privileges, you may chizzle tha username (and also the
user ID n' crew ID) of tha shell by assignin ta dis parameter\&.
Also (assumin sufficient privileges), you may start a single command
under a gangbangin' finger-lickin' different username (and user ID n' crew ID)
by `\fB(USERNAME=\fP\fIusername\fP\fB; command)\fP\&'
.TP
\fBVENDOR\fP
Da vendor, as determined at compile time\&.
.TP
\fBzsh_eval_context\fP <S> <Z> (\fBZSH_EVAL_CONTEXT\fP <S>)
An array (colon\-separated list) indicatin tha context of shell
code dat is bein run\&.  Each time a piece of shell code that
is stored within tha shell is executed a strang is temporarily appended to
the array ta indicate tha type of operation dat is bein performed\&.
Read up in order tha array gives a indication of tha stack of
operations bein performed wit da most thugged-out immediate context last\&.
.RS
.PP
Note dat tha variable do not give shiznit on syntactic context such
as pipelines or subshells\&.  Use \fB$ZSH_SUBSHELL\fP ta detect subshells\&.
.PP
Da context is one of tha following:
.PD 0
.TP
.PD
\fBcmdarg\fP
Code specified by tha \fB\-c\fP option ta tha command line dat invoked
the shell\&.
.TP
\fBcmdsubst\fP
Command substitution rockin tha \fB`\fP\fI\&.\&.\&.\fP\fB`\fP or
\fB$(\fP\fI\&.\&.\&.\fP\fB)\fP construct\&.
.TP
\fBequalsubst\fP
File substitution rockin tha \fB=(\fP\fI\&.\&.\&.\fP\fB)\fP construct\&.
.TP
\fBeval\fP
Code executed by tha \fBeval\fP builtin\&.
.TP
\fBevalautofunc\fP
Code executed wit tha \fBKSH_AUTOLOAD\fP mechanizzle up in order ta define
an autoloaded function\&.
.TP
\fBfc\fP
Code from tha shell history executed by tha \fB\-e\fP option ta tha \fBfc\fP
builtin\&.
.TP
\fBfile\fP
Linez of code bein read directly from a gangbangin' file, fo' example by
the \fBsource\fP builtin\&.
.TP
\fBfilecode\fP
Linez of code bein read from a \fB\&.zwc\fP file instead of directly
from tha source file\&.
.TP
\fBglobqual\fP
Code executed by tha \fBe\fP or \fB+\fP glob qualifier\&.
.TP
\fBglobsort\fP
Code executed ta order filez by tha \fBo\fP glob qualifier\&.
.TP
\fBinsubst\fP
File substitution rockin tha \fB<(\fP\fI\&.\&.\&.\fP\fB)\fP construct\&.
.TP
\fBloadautofunc\fP
Code read directly from a gangbangin' file ta define a autoloaded function\&.
.TP
\fBoutsubst\fP
File substitution rockin tha \fB>(\fP\fI\&.\&.\&.\fP\fB)\fP construct\&.
.TP
\fBsched\fP
Code executed by tha \fBsched\fP builtin\&.
.TP
\fBshfunc\fP
A shell function\&.
.TP
\fBstty\fP
Code passed ta \fBstty\fP by tha \fBSTTY\fP environment variable\&.
Normally dis is passed directly ta tha system\&z \fBstty\fP command,
so dis value is unlikely ta be peeped up in practice\&.
.TP
\fBstyle\fP
Code executed as part of a steez retrieved by tha \fBzstyle\fP builtin
from tha \fBzsh/zutil\fP module\&.
.TP
\fBtoplevel\fP
Da highest execution level of a script or interactizzle shell\&.
.TP
\fBtrap\fP
Code executed as a trap defined by tha \fBtrap\fP builtin\&.  Traps
defined as functions have tha context \fBshfunc\fP\&.  As traps are
asynchronous they may gotz a gangbangin' finger-lickin' different hierarchy from other
code\&.
.TP
\fBzpty\fP
Code executed by tha \fBzpty\fP builtin from tha \fBzsh/zpty\fP module\&.
.TP
\fBzregexparse\-guard\fP
Code executed as a guard by tha \fBzregexparse\fP command from the
\fBzsh/zutil\fP module\&.
.TP
\fBzregexparse\-action\fP
Code executed as a action by tha \fBzregexparse\fP command from the
\fBzsh/zutil\fP module\&.
.RE
.TP
\fBZSH_NAME\fP
Expandz ta tha basename of tha command used ta invoke dis instance
of zsh\&.
.TP
\fBZSH_PATCHLEVEL\fP
Da revision strang fo' tha version number of tha ChizzleLog file
in tha zsh distribution\&.  This is most useful up in order ta keep
track of versionz of tha shell durin pimpment between releases;
hence most playas should not use it n' should instead rely on
\fB$ZSH_VERSION\fP\&.
.TP
\fBzsh_scheduled_events\fP
See tha section `Da zsh/sched Module\&' up in \fIzshmodules\fP(1)\&.
.TP
\fBZSH_SUBSHELL\fP
Readonly integer\&.  Initially zero, incremented each time tha shell forks
to create a subshell fo' executin code\&.  Hence `\fB(print $ZSH_SUBSHELL)\fP\&'
and `\fBprint $(print $ZSH_SUBSHELL)\fP\&' output 1, while
`\fB( (print $ZSH_SUBSHELL) )\fP\&' outputs 2\&.
.TP
\fBZSH_VERSION\fP
Da version number of tha release of zsh\&.
.SH "PARAMETERS USED BY THE SHELL"
Da followin parametas is used by tha shell\&.
.PP
In cases where there be two parametas wit a upper\- n' lowercase
form of tha same name, like fuckin \fBpath\fP n' \fBPATH\fP, tha lowercase form
is a array n' tha uppercase form be a scalar wit tha elementz of the
array joined together by colons\&.  These is similar ta tied parameters
created via `\fBtypeset \-T\fP\&'\&.  Da aiiight use fo' tha colon\-separated
form is fo' exportin ta tha environment, while tha array form is easier
to manipulate within tha shell\&.  Note dat unsettin either of tha pair
will unset tha other; they retain they special propertizzles when
recreated, n' rebustin one of tha pair will recreate tha other\&.
.PP
.PD 0
.TP
.PD
\fBARGV0\fP
If exported, its value is used as tha \fBargv[0]\fP of external commands\&.
Usually used up in constructs like `\fBARGV0=emacs nethack\fP\&'\&.
.TP
\fBBAUD\fP
Da rate up in bits per second at which data reaches tha terminal\&.
Da line editor will use dis value up in order ta compensate fo' a slow
terminal by delayin thugged-out shiznit ta tha display until necessary\&.  If the
parameta is unset or tha value is zero tha compensation mechanizzle is
turned off\&.  Da parameta aint set by default\&.
.RS
.PP
This parameta may be profitably set up in some circumstances, e\&.g\&.
for slow modems dialin tha fuck into a cold-ass lil communications server, or on a slow wide
area network\&.  It should be set ta tha baud
rate of tha slowest part of tha link fo' dopest performance\&.
.RE
.TP
\fBcdpath\fP <S> <Z> (\fBCDPATH\fP <S>)
An array (colon\-separated list)
of directories specifyin tha search path fo' tha \fBcd\fP command\&.
.TP
\fBCOLUMNS\fP <S>
Da number of columns fo' dis terminal session\&.
Used fo' printin select lists n' fo' tha line editor\&.
.TP
\fBCORRECT_IGNORE\fP
If set, is treated as a pattern durin spellin erection\&.  Any
potential erection dat matches tha pattern is ignored\&.  For example,
if tha value is `\fB_*\fP\&' then completion functions (which, by
convention, have names beginnin wit `\fB_\fP\&') aint NEVER gonna be offered
as spellin erections\&.  Da pattern do not apply ta tha erection
of file names, as applied by tha \fBCORRECT_ALL\fP option (so wit the
example just given filez beginnin wit `\fB_\fP\&' up in tha current
directory would still be completed)\&.
.TP
\fBCORRECT_IGNORE_FILE\fP
If set, is treated as a pattern durin spellin erection of file names\&.
Any file name dat matches tha pattern is never offered as a cold-ass lil erection\&.
For example, if tha value is `\fB\&.*\fP\&' then dot file names aint NEVER gonna be
offered as spellin erections\&.  This is useful wit the
\fBCORRECT_ALL\fP option\&.
.TP
\fBDIRSTACKSIZE\fP
Da maximum size of tha directory stack, by default there is no limit\&.  If the
stack gets larger than this, it is ghon be truncated automatically\&.
This is useful wit tha \fBAUTO_PUSHD\fP option\&.
.TP
\fBENV\fP
If tha \fBENV\fP environment variable is set when zsh is invoked as \fBsh\fP
or \fBksh\fP, \fB$ENV\fP is sourced afta tha flava scripts\&.  Da value of
\fBENV\fP is subjected ta parameta expansion, command substitution, and
arithmetic expansion before bein interpreted as a pathname\&.  Note that
\fBENV\fP is \fInot\fP used unless zsh is emulatin \fBsh\fP or \fBksh\fP\&.
.TP
\fBFCEDIT\fP
Da default editor fo' tha \fBfc\fP builtin\&.  If \fBFCEDIT\fP aint set,
the parameta \fBEDITOR\fP is used; if dat aint set either, a funky-ass builtin
default, probably \fBvi\fP, is used\&.
.TP
\fBfignore\fP <S> <Z> (\fBFIGNORE\fP <S>)
An array (colon separated list)
containin tha suffixez of filez ta be ignored
durin filename completion\&.  But fuck dat shiznit yo, tha word on tha street is dat if completion only generates files
with suffixes up in dis list, then these filez is completed anyway\&.
.TP
\fBfpath\fP <S> <Z> (\fBFPATH\fP <S>)
An array (colon separated list)
of directories specifyin tha search path for
function definitions\&.  This path is searched when a gangbangin' function
with tha \fB\-u\fP attribute is referenced\&.  If a executable
file is found, then it is read n' executed up in tha current environment\&.
.TP
\fBhistchars\fP <S>
Three charactas used by tha shell\&z history n' lexical analysis
mechanism\&.  Da first characta signals tha start of a history
expansion (default `\fB!\fP\&')\&.  Da second characta signals the
start of a quick history substitution (default `\fB^\fP\&')\&.  Da third
characta is tha comment characta (default `\fB#\fP\&')\&.
.RS
.PP
Da charactas must be up in tha ASCII characta set; any attempt ta set
\fBhistchars\fP ta charactas wit a locale\-dependent meanin will be
rejected wit a error message\&.
.RE
.TP
\fBHISTCHARS\fP <S> <Z>
Same as \fBhistchars\fP\&.  (Deprecated\&.)
.TP
\fBHISTFILE\fP
Da file ta save tha history up in when a interactizzle shell exits\&.
If unset, tha history aint saved\&.
.TP
\fBHISTORY_IGNORE\fP
If set, is treated as a pattern all up in tha time history filez is written\&.
Any potential history entry dat matches tha pattern is skipped\&.  For
example, if tha value is `\fBfc *\fP\&' then commandz dat invoke the
interactizzle history editor is never freestyled ta tha history file (compare
the \fBHIST_NO_STORE\fP option or tha \fBzshaddhistory\fP hook, either of
which would prevent such commandz from bein added ta tha interactive
history at all)\&.
.TP
\fBHISTSIZE\fP <S>
Da maximum number of events stored up in tha internal history list\&.
If you use tha \fBHIST_EXPIRE_DUPS_FIRST\fP option, settin dis value
larger than tha \fBSAVEHIST\fP size will hit you wit tha difference as a
cushion fo' savin duplicated history events\&.
.TP
\fBHOME\fP <S>
Da default argument fo' tha \fBcd\fP command\&.  This aint set automatically
by tha shell up in \fBsh\fP, \fBksh\fP or \fBcsh\fP emulation yo, but it is typically
present up in tha environment anyway, n' if it becomes set it has its usual
special behaviour\&.
.TP
\fBIFS\fP <S>
Internal field separators (by default space, tab, newline n' NUL), that
are used ta separate lyrics which result from
command or parameta expansion n' lyrics read by
the \fBread\fP builtin\&.  Any charactas from tha set space, tab and
newline dat step tha fuck up in tha IFS is called \fIIFS white space\fP\&.
One or mo' IFS white space charactas or one non\-IFS white space
characta together wit any adjacent IFS white space characta delimit
a field\&.  If a IFS white space characta appears twice consecutively
in tha IFS, dis characta is treated as if it was not a IFS white
space character\&.
.RS
.PP
If tha parameta is unset, tha default is used\&.  Note dis has
a different effect from settin tha parameta ta a empty string\&.
.RE
.TP
\fBKEYBOARD_HACK\fP
This variable defines a cold-ass lil characta ta be removed from tha end of the
command line before interpretin it (interactizzle shells only)\&. Well shiiiit, it is
intended ta fix tha problem wit keys placed bugginly close ta return
and replaces tha \fBSUNKEYBOARDHACK\fP option which did dis for
backquotes only\&.  Should tha chosen characta be one of singlequote,
doublequote or backquote, there must also be a odd number of them
on tha command line fo' tha last one ta be removed\&.
.RS
.PP
For backward compatibility, if tha \fBSUNKEYBOARDHACK\fP option is
explicitly set, tha value of \fBKEYBOARD_HACK\fP reverts ta backquote\&.
If tha option is explicitly unset, dis variable is set ta empty\&.
.RE
.TP
\fBKEYTIMEOUT\fP
Da time tha shell waits, up in hundredthz of seconds, fo' another key to
be pressed when readin bound multi\-characta sequences\&.
.TP
\fBLANG\fP <S>
This variable determines tha locale category fo' any category not
specifically selected via a variable startin wit `\fBLC_\fP\&'\&.
.TP
\fBLC_ALL\fP <S>
This variable overrides tha value of tha `\fBLANG\fP\&' variable n' tha value
of any of tha other variablez startin wit `\fBLC_\fP\&'\&.
.TP
\fBLC_COLLATE\fP <S>
This variable determines tha locale category fo' characta collation
information within ranges up in glob brackets n' fo' sorting\&.
.TP
\fBLC_CTYPE\fP <S>
This variable determines tha locale category fo' characta handling
functions\&.  If tha \fBMULTIBYTE\fP option is up in effect dis variable or
\fBLANG\fP should contain a value dat reflects tha characta set in
use, even if it aint nuthin but a single\-byte characta set, unless only the
7\-bit subset (ASCII) is used\&.  For example, if tha characta set
is ISO\-8859\-1, a suitable value might be \fBen_US\&.iso88591\fP (certain
Linux distributions) or \fBen_US\&.ISO8859\-1\fP (MacOS)\&.
.TP
\fBLC_MESSAGES\fP <S>
This variable determines tha language up in which lyrics should be
written\&.  Note dat zsh do not use message catalogs\&.
.TP
\fBLC_NUMERIC\fP <S>
This variable affects tha decimal point characta n' thousands
separator characta fo' tha formatted input/output functions
and strang conversion functions\&.  Note dat zsh ignores this
settin when parsin floatin point mathematical expressions\&.
.TP
\fBLC_TIME\fP <S>
This variable determines tha locale category fo' date n' time
formattin up in prompt escape sequences\&.
.TP
\fBLINES\fP <S>
Da number of lines fo' dis terminal session\&.
Used fo' printin select lists n' fo' tha line editor\&.
.TP
\fBLISTMAX\fP
In tha line editor, tha number of matches ta list without asking
first\&. If tha value is negative, tha list is ghon be shown if it spans at 
most as nuff lines as given by tha absolute value\&.
If set ta zero, tha shell asks only if tha top of tha listin would scroll
off tha screen\&.
.TP
\fBLOGCHECK\fP
Da interval up in secondz between checks fo' login/logout activity
usin tha \fBwatch\fP parameter\&.
.TP
\fBMAIL\fP
If dis parameta is set n' \fBmailpath\fP aint set,
the shell looks fo' mail up in tha specified file\&.
.TP
\fBMAILCHECK\fP
Da interval up in secondz between checks fo' freshly smoked up mail\&.
.TP
\fBmailpath\fP <S> <Z> (\fBMAILPATH\fP <S>)
An array (colon\-separated list) of filenames ta check for
new mail\&.  Each filename can be followed by a `\fB?\fP\&' n' a
message dat is ghon be printed\&.  Da message will undergo
parameta expansion, command substitution n' arithmetic
expansion wit tha variable \fB$_\fP defined as tha name
of tha file dat has chizzled\&.  Da default message is
`\fBYo ass have freshly smoked up mail\fP\&'\&.  If a element be a gangbangin' finger-lickin' directory
instead of a gangbangin' file tha shell will recursively check every
file up in every last muthafuckin subdirectory of tha element\&.
.TP
\fBmanpath\fP <S> <Z> (\fBMANPATH\fP <S> <Z>)
An array (colon\-separated list)
whose value aint used by tha shell\&.  Da \fBmanpath\fP
array can be useful, however, since settin it also sets
\fBMANPATH\fP, n' vice versa\&.
.TP
.PD 0
\fBmatch\fP
.TP
.PD 0
\fBmbegin\fP
.TP
.PD
\fBmend\fP
Arrays set by tha shell when tha \fBb\fP globbin flag is used up in pattern
matches\&.  See tha subsection \fIGlobbin flags\fP in
the documentation fo' \fIFilename Generation\fP up in \fIzshexpn\fP(1)\&.
.TP
.PD 0
\fBMATCH\fP
.TP
.PD 0
\fBMBEGIN\fP
.TP
.PD
\fBMEND\fP
Set by tha shell when tha \fBm\fP globbin flag is used up in pattern
matches\&.  See tha subsection \fIGlobbin flags\fP in
the documentation fo' \fIFilename Generation\fP up in \fIzshexpn\fP(1)\&.
.TP
\fBmodule_path\fP <S> <Z> (\fBMODULE_PATH\fP <S>)
An array (colon\-separated list)
of directories dat \fBzmodload\fP
searches fo' dynamically loadable modules\&.
This is initialized ta a standard pathname,
usually `\fB/usr/local/lib/zsh/$ZSH_VERSION\fP\&'\&.
(Da `\fB/usr/local/lib\fP\&' part varies from installation ta installation\&.)
For securitizzle reasons, any value set up in tha environment when tha shell
is started is ghon be ignored\&.
.RS
.PP
These parametas only exist if tha installation supports dynamic
module loading\&.
.RE
.TP
\fBNULLCMD\fP <S>
Da command name ta assume if a redirection is specified
with no command\&.  Defaults ta \fBcat\fP\&.  For \fBsh\fP/\fBksh\fP
behavior, chizzle dis ta \fB:\fP\&.  For \fBcsh\fP\-like
behavior, unset dis parameter; tha shell will print an
error message if null commandz is entered\&.
.TP
\fBpath\fP <S> <Z> (\fBPATH\fP <S>)
An array (colon\-separated list)
of directories ta search fo' commands\&.
When dis parameta is set, each directory is scanned
and all filez found is put up in a hash table\&.
.TP
\fBPOSTEDIT\fP <S>
This strang is output whenever tha line editor exits\&.
It probably gotz nuff termcap strings ta reset tha terminal\&.
.TP
.PD 0
\fBPROMPT\fP <S> <Z>
.TP
.PD 0
\fBPROMPT2\fP <S> <Z>
.TP
.PD 0
\fBPROMPT3\fP <S> <Z>
.TP
.PD
\fBPROMPT4\fP <S> <Z>
Same as \fBPS1\fP, \fBPS2\fP, \fBPS3\fP n' \fBPS4\fP,
respectively\&.
.TP
\fBprompt\fP <S> <Z>
Same as \fBPS1\fP\&.
.TP
\fBPROMPT_EOL_MARK\fP
When tha \fBPROMPT_CR\fP n' \fBPROMPT_SP\fP options is set, the
\fBPROMPT_EOL_MARK\fP parameta can be used ta customize how tha fuck tha end of
partial lines is shown\&.  This parameta undergoes prompt expansion, with
the \fBPROMPT_PERCENT\fP option set\&.  If not set, tha default behavior is
equivalent ta tha value `\fB%B%S%#%s%b\fP\&'\&.
.TP
\fBPS1\fP <S>
Da primary prompt string, printed before a cold-ass lil command is read\&.
It undergoes a special form of expansion
before bein displayed; see
EXPANSION OF PROMPT SEQUENCES up in \fIzshmisc\fP(1)\&.  Da default is `\fB%m%# \fP\&'\&.
.TP
\fBPS2\fP <S>
Da secondary prompt, printed when tha shell needz mo' shiznit
to complete a cold-ass lil command\&.
It be expanded up in tha same way as \fBPS1\fP\&.
Da default is `\fB%_> \fP\&', which displays any shell constructs or quotation
marks which is currently bein processed\&.
.TP
\fBPS3\fP <S>
Selection prompt used within a \fBselect\fP loop\&.
It be expanded up in tha same way as \fBPS1\fP\&.
Da default is `\fB?# \fP\&'\&.
.TP
\fBPS4\fP <S>
Da execution trace prompt\&.  Default is `\fB+%N:%i> \fP\&', which displays
the name of tha current shell structure n' tha line number within it\&.
In sh or ksh emulation, tha default is `\fB+ \fP\&'\&.
.TP
\fBpsvar\fP <S> <Z> (\fBPSVAR\fP <S>)
An array (colon\-separated list) whose elements can be used in
\fBPROMPT\fP strings\&.  Settin \fBpsvar\fP also sets \fBPSVAR\fP, and
vice versa\&.
.TP
\fBREADNULLCMD\fP <S>
Da command name ta assume if a single input redirection
is specified wit no command\&.  Defaults ta \fBmore\fP\&.
.TP
\fBREPORTTIME\fP
If nonnegative, commandz whose combined user n' system execution times
(measured up in seconds) is pimped outa than dis value have timing
statistics printed fo' them\&.  Output is suppressed fo' commands
executed within tha line editor, includin completion; commands
explicitly marked wit tha \fBtime\fP keyword still cause tha summary
to be printed up in dis case\&.
.TP
\fBREPLY\fP
This parameta is reserved by convention ta pass strang joints between
shell scripts n' shell builtins up in thangs where a gangbangin' function call or
redirection is impossible or undesirable\&.  Da \fBread\fP builtin n' the
\fBselect\fP complex command may set \fBREPLY\fP, n' filename generation both
sets n' examines its value when evaluatin certain expressions\&.  Some
modulez also employ \fBREPLY\fP fo' similar purposes\&.
.TP
\fBreply\fP
As \fBREPLY\fP yo, but fo' array joints rather than strings\&.
.TP
.PD 0
\fBRPROMPT\fP <S>
.TP
.PD
\fBRPS1\fP <S>
This prompt is displayed on tha right\-hand side of tha screen
when tha primary prompt is bein displayed on tha left\&.
This do not work if tha \fBSINGLE_LINE_ZLE\fP option is set\&.
It be expanded up in tha same way as \fBPS1\fP\&.
.TP
.PD 0
\fBRPROMPT2\fP <S>
.TP
.PD
\fBRPS2\fP <S>
This prompt is displayed on tha right\-hand side of tha screen
when tha secondary prompt is bein displayed on tha left\&.
This do not work if tha \fBSINGLE_LINE_ZLE\fP option is set\&.
It be expanded up in tha same way as \fBPS2\fP\&.
.TP
\fBSAVEHIST\fP
Da maximum number of history events ta save up in tha history file\&.
.TP
\fBSPROMPT\fP <S>
Da prompt used fo' spellin erection\&.  Da sequence
`\fB%R\fP\&' expandz ta tha strang which presumably needz spelling
correction, n' `\fB%r\fP\&' expandz ta tha proposed erection\&.
All other prompt escapes is also allowed\&.
.TP
\fBSTTY\fP
If dis parameta is set up in a cold-ass lil command\&z environment, tha shell runs the
\fBstty\fP command wit tha value of dis parameta as arguments up in order to
set up tha terminal before executin tha command\&. Da modes apply only ta the
command, n' is reset when it finishes or is suspended\&. If tha command is
suspended n' continued lata wit tha \fBfg\fP or \fBwait\fP builtins it will
see tha modes specified by \fBSTTY\fP, as if it was not suspended\&.  This
(intentionally) do not apply if tha command is continued via `\fBkill
\-CONT\fP\&'\&.  \fBSTTY\fP is ignored if tha command is run up in tha background, or
if it is up in tha environment of tha shell but not explicitly assigned ta in
the input line\&. This avoidz hustlin stty at every last muthafuckin external command by
accidentally exportin it\& fo' realz. Also note dat \fBSTTY\fP should not be used for
window size justifications; these aint gonna be local ta tha command\&.
.TP
\fBTERM\fP <S>
Da type of terminal up in use\&.  This is used when lookin up termcap
sequences\&.  An assignment ta \fBTERM\fP causes zsh ta re\-initialize the
terminal, even if tha value do not chizzle (e\&.g\&., `\fBTERM=$TERM\fP\&')\&.  It
is necessary ta make such a assignment upon any chizzle ta tha terminal
definizzle database or terminal type up in order fo' tha freshly smoked up settings to
take effect\&.
.TP
\fBTERMINFO\fP <S>
A reference ta a cold-ass lil compiled description of tha terminal, used by the
`terminfo\&' library when tha system has it; peep \fIterminfo\fP(5)\&.
If set, dis causes tha shell ta reinitialise tha terminal, making
the workaround `\fBTERM=$TERM\fP\&' unnecessary\&.
.TP
\fBTIMEFMT\fP
Da format of process time reports wit tha \fBtime\fP keyword\&.
Da default is `\fB%J  %U user %S system %P cpu %*E total\fP\&'\&.
Recognizes tha followin escape sequences, although not all
may be available on all systems, n' some dat is available
may not be useful:
.RS
.PP
.PD 0
.TP
\fB%%\fP
A `\fB%\fP\&'\&.
.TP
\fB%U\fP
CPU secondz dropped up in user mode\&.
.TP
\fB%S\fP
CPU secondz dropped up in kernel mode\&.
.TP
\fB%E\fP
Elapsed time up in seconds\&.
.TP
\fB%P\fP
Da CPU cementage, computed as
(100*\fB%U\fP+\fB%S\fP)/\fB%E\fP\&.
.TP
\fB%W\fP
Number of times tha process was swapped\&.
.TP
\fB%X\fP
Da average amount up in (shared) text space used up in kilobytes\&.
.TP
\fB%D\fP
Da average amount up in (unshared) data/stack space used in
kilobytes\&.
.TP
\fB%K\fP
Da total space used (%X+%D) up in kilobytes\&.
.TP
\fB%M\fP
Da  maximum memory tha process had up in use at any time in
megabytes\&.
.TP
\fB%F\fP
Da number of major page faults (page needed ta be brought
from disk)\&.
.TP
\fB%R\fP
Da number of minor page faults\&.
.TP
\fB%I\fP
Da number of input operations\&.
.TP
\fB%O\fP
Da number of output operations\&.
.TP
\fB%r\fP
Da number of socket lyrics received\&.
.TP
\fB%s\fP
Da number of socket lyrics sent\&.
.TP
\fB%k\fP
Da number of signals received\&.
.TP
\fB%w\fP
Number of voluntary context switches (waits)\&.
.TP
\fB%c\fP
Number of involuntary context switches\&.
.TP
\fB%J\fP
Da name of dis thang\&.
.PD
.PP
A star may be banged between tha cement sign n' flags printin time\&.
This cause tha time ta be printed in
`\fIhh\fP\fB:\fP\fImm\fP\fB:\fP\fIss\fP\fB\&.\fP\fIttt\fP\&'
format (hours n' minutes is only printed if they is not zero)\&.
.RE
.TP
\fBTMOUT\fP
If dis parameta is nonzero, tha shell will receive a \fBALRM\fP
signal if a cold-ass lil command aint entered within tha specified number of
secondz afta issuin a prompt\&. If there be a trap on \fBSIGALRM\fP, it
will be executed n' a freshly smoked up alarm is scheduled rockin tha value of the
\fBTMOUT\fP parameta afta executin tha trap\&.  If no trap is set, and
the idle time of tha terminal aint less than tha value of the
\fBTMOUT\fP parameter, zsh terminates\&.  Otherwise a freshly smoked up alarm is
scheduled ta \fBTMOUT\fP secondz afta tha last keypress\&.
.TP
\fBTMPPREFIX\fP
A pathname prefix which tha shell will use fo' all temporary files\&.
Note dat dis should include a initial part fo' tha file name as
well as any directory names\&.  Da default is `\fB/tmp/zsh\fP\&'\&.
.TP
\fBwatch\fP <S> <Z> (\fBWATCH\fP <S>)
An array (colon\-separated list) of login/logout events ta report\&.
If it gotz nuff tha single word `\fBall\fP\&', then all login/logout events
are reported\&.  If it gotz nuff tha single word `\fBnotme\fP\&', then all
events is reported as wit `\fBall\fP\&' except \fB$USERNAME\fP\&.
An entry up in dis list may consist of a username,
an `\fB@\fP\&' followed by a remote hostname,
and a `\fB%\fP\&' followed by a line (tty)\&.
Any or all of these components may be present up in a entry;
if a login/logout event matches all of them,
it is reported\&.
.TP
\fBWATCHFMT\fP
Da format of login/logout reports if tha \fBwatch\fP parameta is set\&.
Default is `\fB%n has %a %l from %m\fP\&'\&.
Recognizes tha followin escape sequences:
.RS
.PP
.PD 0
.TP
.PD
\fB%n\fP
Da name of tha user dat logged in/out\&.
.TP
\fB%a\fP
Da observed action, i\&.e\&. "logged on" or "logged off"\&.
.TP
\fB%l\fP
Da line (tty) tha user is logged up in on\&.
.TP
\fB%M\fP
Da full hostname of tha remote host\&.
.TP
\fB%m\fP
Da hostname up ta tha straight-up original gangsta `\fB\&.\fP\&'\&.  If only the
IP address be available or tha utmp field gotz nuff
the name of a X\-windows display, tha whole name is printed\&.
.RS
.PP
\fINOTE:\fP
Da `\fB%m\fP\&' n' `\fB%M\fP' escapes will work only if there be a host name
field up in tha utmp on yo' machine\&.  Otherwise they are
treated as ordinary strings\&.
.RE
.TP
\fB%S\fP (\fB%s\fP)
Start (stop) standout mode\&.
.TP
\fB%U\fP (\fB%u\fP)
Start (stop) underline mode\&.
.TP
\fB%B\fP (\fB%b\fP)
Start (stop) boldface mode\&.
.TP
.PD 0
\fB%t\fP
.TP
.PD
\fB%@\fP
Da time, up in 12\-hour, am/pm format\&.
.TP
\fB%T\fP
Da time, up in 24\-hour format\&.
.TP
\fB%w\fP
Da date up in `\fIday\fP\fB\-\fP\fIdd\fP\&' format\&.
.TP
\fB%W\fP
Da date up in `\fImm\fP\fB/\fP\fIdd\fP\fB/\fP\fIyy\fP\&' format\&.
.TP
\fB%D\fP
Da date up in `\fIyy\fP\fB\-\fP\fImm\fP\fB\-\fP\fIdd\fP\&' format\&.
.TP
\fB%(\fP\fIx\fP\fB:\fP\fItrue\-text\fP\fB:\fP\fIfalse\-text\fP\fB)\fP
Specifies a ternary expression\&.
Da characta followin tha \fIx\fP is
arbitrary; tha same characta is used ta separate tha text
for tha "true" result from dat fo' tha "false" result\&.
Both tha separator n' tha right parenthesis may be escaped
with a funky-ass backslash\&.
Ternary expressions may be nested\&.
.RS
.PP
Da test characta \fIx\fP may be any one of `\fBl\fP\&', `\fBn\fP', `\fBm\fP'
or `\fBM\fP\&', which indicate a `true' result if tha corresponding
escape sequence would return a non\-empty value; or it may be `\fBa\fP\&',
which indicates a `true\&' result if tha peeped user has logged in,
or `false\&' if dat schmoooove muthafucka has logged out\&.
Other charactas evaluate ta neither legit nor false; tha entire
expression is omitted up in dis case\&.
.PP
If tha result is `true\&', then tha \fItrue\-text\fP
is formatted accordin ta tha rulez above n' printed,
and tha \fIfalse\-text\fP is skipped\&.
If `false\&', tha \fItrue\-text\fP is skipped n' tha \fIfalse\-text\fP
is formatted n' printed\&.
Either or both of tha branches may be empty yo, but
both separators must be present up in any case\&.
.RE
.RE
.TP
\fBWORDCHARS\fP <S>
A list of non\-alphanumeric charactas considered part of a word
by tha line editor\&.
.TP
\fBZBEEP\fP
If set, dis gives a strang of characters, which can use all tha same codes
as tha \fBbindkey\fP command as busted lyrics bout in
the zsh/zle module entry up in \fIzshmodules\fP(1), dat is ghon be output ta tha terminal
instead of beeping\&.  This may gotz a visible instead of a audible effect;
for example, tha strang `\fB\ee[?5h\ee[?5l\fP\&' on a vt100 or xterm will have
the effect of flashin reverse vizzle on n' off (if you probably use reverse
video, you should use tha strang `\fB\ee[?5l\ee[?5h\fP\&' instead)\&.  This takes
precedence over tha \fBNOBEEP\fP option\&.
.TP
\fBZDOTDIR\fP
Da directory ta search fo' shell startup filez (\&.zshrc, etc),
if not \fB$HOME\fP\&.
.TP
\fBZLE_LINE_ABORTED\fP
This parameta is set by tha line editor when a error occurs\&.  It
gotz nuff tha line dat was bein edited all up in tha deal wit tha error\&.
`\fBprint \-zr \-\- $ZLE_LINE_ABORTED\fP\&' can be used ta recover tha line\&.
Only da most thugged-out recent line of dis kind is remembered\&.
.TP
.PD 0
\fBZLE_REMOVE_SUFFIX_CHARS\fP
.TP
.PD
\fBZLE_SPACE_SUFFIX_CHARS\fP
These parametas is used by tha line editor\&.  In certain circumstances
suffixes (typically space or slash) added by tha completion system
will be removed automatically, either cuz tha next editin command
was not a insertable character, or cuz tha characta was marked
as requirin tha suffix ta be removed\&.
.RS
.PP
These variablez can contain tha setz of charactas dat will cause the
suffix ta be removed\&.  If \fBZLE_REMOVE_SUFFIX_CHARS\fP is set, them
charactas will cause tha suffix ta be removed; if
\fBZLE_SPACE_SUFFIX_CHARS\fP is set, dem charactas will cause the
suffix ta be removed n' replaced by a space\&.
.PP
If \fBZLE_REMOVE_SUFFIX_CHARS\fP aint set, tha default behaviour is
equivalent to:
.PP
.RS
.nf
\fBZLE_REMOVE_SUFFIX_CHARS=$\&' \et\en;&|'\fP
.fi
.RE
.PP
If \fBZLE_REMOVE_SUFFIX_CHARS\fP is set but is empty, no charactas have this
behaviour\&.  \fBZLE_SPACE_SUFFIX_CHARS\fP takes precedence, so dat the
following:
.PP
.RS
.nf
\fBZLE_SPACE_SUFFIX_CHARS=$\&'&|'\fP
.fi
.RE
.PP
causes tha charactas `\fB&\fP\&' n' `\fB|\fP' ta remove tha suffix but to
replace it wit a space\&.
.PP
To illustrate tha difference, suppose dat tha option \fBAUTO_REMOVE_SLASH\fP
is up in effect n' tha directory \fBDIR\fP has just been completed, wit an
appended \fB/\fP, followin which tha user types `\fB&\fP\&'\&.  Da default result
is `\fBDIR&\fP\&'\&.  With \fBZLE_REMOVE_SUFFIX_CHARS\fP set but without including
`\fB&\fP\&' tha result is `\fBDIR/&\fP'\&.  With \fBZLE_SPACE_SUFFIX_CHARS\fP set to
include `\fB&\fP\&' tha result is `\fBDIR &\fP'\&.
.PP
Note dat certain completions may provide they own suffix removal
or replacement behaviour which overrides tha joints busted lyrics bout here\&.
See tha completion system documentation in
\fIzshcompsys\fP(1)\&.
.RE
.TP
\fBZLE_RPROMPT_INDENT <S>\fP
If set, used ta give tha indentation between tha right hand side of
the right prompt up in tha line editor as given by \fBRPS1\fP or \fBRPROMPT\fP
and tha right hand side of tha screen\&.  If not set, tha value 1 is used\&.
.RS
.PP
Typically dis is ghon be used ta set tha value ta 0 so dat tha prompt
appears flush wit tha right hand side of tha screen\&.  This aint the
default as nuff terminals do not handle dis erectly, up in particular
when tha prompt appears all up in tha off tha hook bottom right of tha screen\&.
Recent virtual terminals is mo' likely ta handle dis case erectly\&.
Some experimentation is necessary\&.
.RE
