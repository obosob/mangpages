'\" t
.\"     Title: git-stash
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-STASH" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-stash \- Stash tha chizzlez up in a gangbangin' finger-lickin' dirty hustlin directory away
.SH "SYNOPSIS"
.sp
.nf
\fIgit stash\fR list [<options>]
\fIgit stash\fR show [<stash>]
\fIgit stash\fR drop [\-q|\-\-quiet] [<stash>]
\fIgit stash\fR ( pop | apply ) [\-\-index] [\-q|\-\-quiet] [<stash>]
\fIgit stash\fR branch <branchname> [<stash>]
\fIgit stash\fR [save [\-p|\-\-patch] [\-k|\-\-[no\-]keep\-index] [\-q|\-\-quiet]
             [\-u|\-\-include\-untracked] [\-a|\-\-all] [<message>]]
\fIgit stash\fR clear
\fIgit stash\fR create [<message>]
\fIgit stash\fR store [\-m|\-\-message <message>] [\-q|\-\-quiet] <commit>
.fi
.sp
.SH "DESCRIPTION"
.sp
Use git stash when you wanna record tha current state of tha hustlin directory n' tha index yo, but wanna go back ta a cold-ass lil clean hustlin directory\&. Da command saves yo' local modifications away n' reverts tha hustlin directory ta match tha HEAD commit\&.
.sp
Da modifications stashed away by dis command can be listed wit git stash list, inspected wit git stash show, n' restored (potentially on top of a gangbangin' finger-lickin' different commit) wit git stash apply\&. Callin git stash without any arguments is equivalent ta git stash save\& fo' realz. A stash is by default listed as "WIP on \fIbranchname\fR \&..." yo, but you can give a mo' descriptizzle message on tha command line when you create one\&.
.sp
Da sickest fuckin stash you pimped is stored up in refs/stash; olda stashes is found up in tha reflog of dis reference n' can be named rockin tha usual reflog syntax (e\&.g\&. stash@{0} is da most thugged-out recently pimped stash, stash@{1} is tha one before it, stash@{2\&.hours\&.ago} be also possible)\&.
.SH "OPTIONS"
.PP
save [\-p|\-\-patch] [\-\-[no\-]keep\-index] [\-u|\-\-include\-untracked] [\-a|\-\-all] [\-q|\-\-quiet] [<message>]
.RS 4
Save yo' local modifications ta a new
\fIstash\fR, n' run
git reset \-\-hard
to revert them\&. Da <message> part is optionizzle n' gives tha description along wit tha stashed state\&. For quickly bustin a snapshot, you can omit
\fIboth\fR
"save" n' <message> yo, but givin only <message> do not trigger dis action ta prevent a misspelled subcommand from bustin a unwanted stash\&.
.sp
If the
\-\-keep\-index
option is used, all chizzlez already added ta tha index is left intact\&.
.sp
If the
\-\-include\-untracked
option is used, all untracked filez is also stashed n' then cleaned up with
git clean, leavin tha hustlin directory up in a straight-up clean state\&. If the
\-\-all
option is used instead then tha ignored filez is stashed n' cleaned up in addizzle ta tha untracked files\&.
.sp
With
\-\-patch, you can interactively select hunks from tha diff between HEAD n' tha hustlin tree ta be stashed\&. Da stash entry is constructed such dat its index state is tha same ol' dirty as tha index state of yo' repository, n' its worktree gotz nuff only tha chizzlez you selected interactively\&. Da selected chizzlez is then rolled back from yo' worktree\&. Right back up in yo muthafuckin ass. See tha \(lqInteractizzle Mode\(rq section of
\fBgit-add\fR(1)
to learn how tha fuck ta operate the
\-\-patch
mode\&.
.sp
The
\-\-patch
option implies
\-\-keep\-index\&. Yo ass can use
\-\-no\-keep\-index
to override this\&.
.RE
.PP
list [<options>]
.RS 4
List tha stashes dat you currently have\&. Each
\fIstash\fR
is listed wit its name (e\&.g\&.
stash@{0}
is tha sickest fuckin stash,
stash@{1}
is tha one before, etc\&.), tha name of tha branch dat was current when tha stash was made, n' a gangbangin' finger-lickin' dirty-ass short description of tha commit tha stash was based on\&.
.sp
.if n \{\
.RS 4
.\}
.nf
stash@{0}: WIP on submit: 6ebd0e2\&.\&.\&. Update git\-stash documentation
stash@{1}: On master: 9cc0589\&.\&.\& fo' realz. Add git\-stash
.fi
.if n \{\
.RE
.\}
.sp
Da command takes options applicable ta the
\fIgit log\fR
command ta control what tha fuck is shown n' how\&. Right back up in yo muthafuckin ass. See
\fBgit-log\fR(1)\&.
.RE
.PP
show [<stash>]
.RS 4
Show tha chizzlez recorded up in tha stash as a gangbangin' finger-lickin' diff between tha stashed state n' its original gangsta parent\&. When no
<stash>
is given, shows tha sickest fuckin one\&. By default, tha command shows tha diffstat yo, but it will accept any format known to
\fIgit diff\fR
(e\&.g\&.,
git stash show \-p stash@{1}
to view tha second most recent stash up in patch form)\&.
.RE
.PP
pop [\-\-index] [\-q|\-\-quiet] [<stash>]
.RS 4
Remove a single stashed state from tha stash list n' apply it on top of tha current hustlin tree state, i\&.e\&., do tha inverse operation of
git stash save\&. Da hustlin directory must match tha index\&.
.sp
Applyin tha state can fail wit conflicts; up in dis case, it aint removed from tha stash list\&. Yo ass need ta resolve tha conflicts by hand n' call
git stash drop
manually afterwards\&.
.sp
If the
\-\-index
option is used, then tries ta reinstate not only tha hustlin tree\(cqs chizzlez yo, but also tha index\(cqs ones\&. But fuck dat shiznit yo, tha word on tha street is dat dis can fail, when you have conflicts (which is stored up in tha index, where you therefore can no longer apply tha chizzlez as they was originally)\&.
.sp
When no
<stash>
is given,
stash@{0}
is assumed, otherwise
<stash>
must be a reference of tha form
stash@{<revision>}\&.
.RE
.PP
apply [\-\-index] [\-q|\-\-quiet] [<stash>]
.RS 4
Like
pop yo, but do not remove tha state from tha stash list\&. Unlike
pop,
<stash>
may be any commit dat be lookin like a cold-ass lil commit pimped by
stash save
or
stash create\&.
.RE
.PP
branch <branchname> [<stash>]
.RS 4
Creates n' checks up a freshly smoked up branch named
<branchname>
startin from tha commit at which the
<stash>
was originally pimped, applies tha chizzlez recorded in
<stash>
to tha freshly smoked up hustlin tree n' index\&. If dat succeeds, and
<stash>
is a reference of tha form
stash@{<revision>}, it then drops the
<stash>\&. When no
<stash>
is given, applies tha sickest fuckin one\&.
.sp
This is useful if tha branch on which you ran
git stash save
has chizzled enough that
git stash apply
fails cuz of conflicts\&. Right back up in yo muthafuckin ass. Since tha stash be applied on top of tha commit dat was HEAD all up in tha time
git stash
was run, it restores tha originally stashed state wit no conflicts\&.
.RE
.PP
clear
.RS 4
Remove all tha stashed states\&. Note dat dem states will then be subject ta pruning, n' may be impossible ta recover (see
\fIExamples\fR
below fo' a possible game)\&.
.RE
.PP
drop [\-q|\-\-quiet] [<stash>]
.RS 4
Remove a single stashed state from tha stash list\&. When no
<stash>
is given, it removes tha sickest fuckin one\&. i\&.e\&.
stash@{0}, otherwise
<stash>
must be a valid stash log reference of tha form
stash@{<revision>}\&.
.RE
.PP
create
.RS 4
Smoke a stash (which be a regular commit object) n' return its object name, without storin it anywhere up in tha ref namespace\&. This is intended ta be useful fo' scripts\&. Well shiiiit, it is probably not tha command you wanna use; peep "save" above\&.
.RE
.PP
store
.RS 4
Store a given stash pimped via
\fIgit stash create\fR
(which be a thugged-out danglin merge commit) up in tha stash ref, uppimpin tha stash reflog\&. This is intended ta be useful fo' scripts\&. Well shiiiit, it is probably not tha command you wanna use; peep "save" above\&.
.RE
.SH "DISCUSSION"
.sp
A stash is represented as a cold-ass lil commit whose tree recordz tha state of tha hustlin directory, n' its first parent is tha commit at HEAD when tha stash was pimped\&. Da tree of tha second parent recordz tha state of tha index when tha stash is made, n' it is done cooked up a cold-ass lil lil pimp of tha HEAD commit\&. Da ancestry graph be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
       \&.\-\-\-\-W
      /    /
\-\-\-\-\-H\-\-\-\-I
.fi
.if n \{\
.RE
.\}
.sp
where H is tha HEAD commit, I be a cold-ass lil commit dat recordz tha state of tha index, n' W be a cold-ass lil commit dat recordz tha state of tha hustlin tree\&.
.SH "EXAMPLES"
.PP
Pullin tha fuck into a gangbangin' finger-lickin' dirty tree
.RS 4
When yo ass is up in tha middle of something, you learn dat there be upstream chizzlez dat is possibly relevant ta what tha fuck yo ass is bustin\&. When yo' local chizzlez do not conflict wit tha chizzlez up in tha upstream, a simple
git pull
will let you move forward\&.
.sp
But fuck dat shiznit yo, tha word on tha street is dat there be cases up in which yo' local chizzlez do conflict wit tha upstream chizzles, and
git pull
refuses ta overwrite yo' chizzles\&. In such a cold-ass lil case, you can stash yo' chizzlez away, big-ass up a pull, n' then unstash, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git pull
 \&.\&.\&.
file foobar not up ta date, cannot merge\&.
$ git stash
$ git pull
$ git stash pop
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Interrupted workflow
.RS 4
When yo ass is up in tha middle of something, yo' boss comes up in n' demandz dat you fix suttin' immediately\&. Traditionally, you would cook up a cold-ass lil commit ta a temporary branch ta store yo' chizzlez away, n' return ta yo' original gangsta branch ta make tha emergency fix, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
# \&.\&.\&. hack hack hack \&.\&.\&.
$ git checkout \-b my_wip
$ git commit \-a \-m "WIP"
$ git checkout master
$ edit emergency fix
$ git commit \-a \-m "Fix up in a hurry"
$ git checkout my_wip
$ git reset \-\-soft HEAD^
# \&.\&.\&. continue jackin \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
Yo ass can use
\fIgit stash\fR
to simplify tha above, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
# \&.\&.\&. hack hack hack \&.\&.\&.
$ git stash
$ edit emergency fix
$ git commit \-a \-m "Fix up in a hurry"
$ git stash pop
# \&.\&.\&. continue jackin \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Testin partial commits
.RS 4
Yo ass can use
git stash save \-\-keep\-index
when you wanna make two or mo' commits outta tha chizzlez up in tha work tree, n' you wanna test each chizzle before committing:
.sp
.if n \{\
.RS 4
.\}
.nf
# \&.\&.\&. hack hack hack \&.\&.\&.
$ git add \-\-patch foo            # add just first part ta tha index
$ git stash save \-\-keep\-index    # save all other chizzlez ta tha stash
$ edit/build/test first part
$ git commit \-m \(aqFirst part\(aq     # commit straight-up tested chizzle
$ git stash pop                  # prepare ta work on all other chizzles
# \&.\&.\&. repeat above five steps until one commit remains \&.\&.\&.
$ edit/build/test remainin parts
$ git commit foo \-m \(aqRemainin parts\(aq
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
Recoverin stashes dat was cleared/dropped erroneously
.RS 4
If you mistakenly drop or clear stashes, they cannot be recovered all up in tha aiiight safety mechanisms\&. But fuck dat shiznit yo, tha word on tha street is dat you can try tha followin incantation ta git a list of stashes dat is still up in yo' repository yo, but not reachable any more:
.sp
.if n \{\
.RS 4
.\}
.nf
git fsck \-\-unreachable |
grep commit | cut \-d\e  \-f3 |
xargs git log \-\-merges \-\-no\-walk \-\-grep=WIP
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "SEE ALSO"
.sp
\fBgit-checkout\fR(1), \fBgit-commit\fR(1), \fBgit-reflog\fR(1), \fBgit-reset\fR(1)
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
