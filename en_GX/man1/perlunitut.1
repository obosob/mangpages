.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLUNITUT 1"
.TH PERLUNITUT 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlunitut \- Perl Unicode Tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da minutez of just flingin strings round is over n' shit. It aint nuthin but well established that
modern programs need ta be capable of communicatin funky accented letters, and
things like euro symbols. This means dat programmers need freshly smoked up habits, n' you can put dat on yo' toast. It's
easy ta program Unicode capable software yo, but it do require discipline ta do
it right.
.PP
Therez a shitload ta know bout characta sets, n' text encodings. It aint nuthin but probably
best ta spend a gangbangin' full dizzle peepin' all dis yo, but tha basics can be hustled in
minutes.
.PP
These is not tha straight-up basics, though cause I gots dem finger-lickin' chickens wit tha siz-auce. Well shiiiit, it be assumed dat you already
know tha difference between bytes n' characters, n' realise (and accept!)
that there be nuff different characta sets n' encodings, n' dat your
program has ta be explicit bout em. Recommended readin is \*(L"Da Absolute
Minimum Every Software Developer Absolutely, Positively Must Know Bout Unicode
and Characta Sets (No Excuses!)\*(R" by Joel Spolsky, at
<http://joelonsoftware.com/articles/Unicode.html>.
.PP
This tutorial speaks up in rather absolute terms, n' serves up only a limited view
of tha wealth of characta strang related features dat Perl has ta offer n' shit. For
most projects, dis shiznit will probably suffice.
.SS "Definitions"
.IX Subsection "Definitions"
It aint nuthin but blingin ta set all dem thangs straight first. This is da most thugged-out blingin
part of dis tutorial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. This view may conflict wit other shiznit dat you
may have found on tha wizzy yo, but thatz mostly cuz nuff sources is wrong.
.PP
Yo ass may gotta re-read dis entire section all dem times...
.PP
\fIUnicode\fR
.IX Subsection "Unicode"
.PP
\&\fBUnicode\fR be a cold-ass lil characta set wit room fo' fuckin shitloadz of characters. Da ordinal
value of a cold-ass lil characta is called a \fBcode point\fR.   (But up in practice, the
distinction between code point n' characta is blurred, so tha terms often
are used interchangeably.)
.PP
There is many, nuff code points yo, but computas work wit bytes, n' a funky-ass byte has
room fo' only 256 joints, n' you can put dat on yo' toast.  Unicode has nuff mo' charactas than that,
so you need a method ta make these accessible.
.PP
Unicode is encoded rockin nuff muthafuckin competin encodings, of which \s-1UTF\-8\s0 is the
most used. Y'all KNOW dat shit, muthafucka! In a Unicode encoding, multiple subsequent bytes can be used to
store a single code point, or simply: character.
.PP
\fI\s-1UTF\-8\s0\fR
.IX Subsection "UTF-8"
.PP
\&\fB\s-1UTF\-8\s0\fR be a Unicode encoding. Many playas be thinkin dat Unicode n' \s-1UTF\-8\s0 are
the same thang yo, but they not. There is mo' Unicode encodings yo, but much of
the ghetto has standardized on \s-1UTF\-8. \s0
.PP
\&\s-1UTF\-8\s0 treats tha straight-up original gangsta 128 codepoints, 0..127, tha same as \s-1ASCII.\s0 They take
only one byte per character n' shiznit fo' realz. All other charactas is encoded as two or more
(up ta six) bytes rockin a cold-ass lil complex scheme. Fortunately, Perl handlez dis for
us, so our phat asses don't gotta worry bout all dis bullshit.
.PP
\fIText strings (characta strings)\fR
.IX Subsection "Text strings (characta strings)"
.PP
\&\fBText strings\fR, or \fBcharacta strings\fR is made of characters. Bytes are
irrelevant here, n' so is encodings. Each characta is just that: the
character.
.PP
On a text string, you would do thangs like:
.PP
.Vb 4
\&    $text =~ s/foo/bar/;
\&    if ($strin =~ /^\ed+$/) { ... }
\&    $text = ucfirst $text;
\&    mah $character_count = length $text;
.Ve
.PP
Da value of a cold-ass lil characta (\f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`chr\*(C'\fR) is tha correspondin Unicode code
point.
.PP
\fIBinary strings (byte strings)\fR
.IX Subsection "Binary strings (byte strings)"
.PP
\&\fBBinary strings\fR, or \fBbyte strings\fR is made of bytes yo. Here, you don't have
characters, just bytes fo' realz. All communication wit tha outside ghetto (anything
outside of yo' current Perl process) is done up in binary.
.PP
On a funky-ass binary string, you would do thangs like:
.PP
.Vb 4
\&    mah (@length_content) = unpack "(V/a)*", $binary;
\&    $binary =~ s/\ex00\ex0F/\exFF\exF0/;  # fo' tha brave :)
\&    print {$fh} $binary;
\&    mah $byte_count = length $binary;
.Ve
.PP
\fIEncoding\fR
.IX Subsection "Encoding"
.PP
\&\fBEncoding\fR (as a verb) is tha conversion from \fItext\fR ta \fIbinary\fR. To encode,
you gotta supply tha target encoding, fo' example \f(CW\*(C`iso\-8859\-1\*(C'\fR or \f(CW\*(C`UTF\-8\*(C'\fR.
Some encodings, like tha \f(CW\*(C`iso\-8859\*(C'\fR (\*(L"latin\*(R") range, do not support tha full
Unicode standard; charactas dat can't be represented is lost up in the
conversion.
.PP
\fIDecoding\fR
.IX Subsection "Decoding"
.PP
\&\fBDecoding\fR is tha conversion from \fIbinary\fR ta \fItext\fR. To decode, you have to
know what tha fuck encodin was used durin tha encodin phase fo' realz. And most of all, it must
be suttin' decodable. Well shiiiit, it don't make much sense ta decode a \s-1PNG\s0 image tha fuck into a
text string.
.PP
\fIInternal format\fR
.IX Subsection "Internal format"
.PP
Perl has a \fBinternal format\fR, a encodin dat it uses ta encode text strings
so it can store dem up in memory fo' realz. All text strings is up in dis internal format.
In fact, text strings is never up in any other format!
.PP
Yo ass shouldn't worry bout what tha fuck dis format is, cuz conversion is
automatically done when you decode or encode.
.SS "Yo crazy-ass freshly smoked up toolkit"
.IX Subsection "Yo crazy-ass freshly smoked up toolkit"
Add ta yo' standard headin tha followin line:
.PP
.Vb 1
\&    use Encode qw(encode decode);
.Ve
.PP
Or, if you lazy, just:
.PP
.Vb 1
\&    use Encode;
.Ve
.SS "I/O flow (the actual 5 minute tutorial)"
.IX Subsection "I/O flow (the actual 5 minute tutorial)"
Da typical input/output flow of a program is:
.PP
.Vb 3
\&    1. Receive n' decode
\&    2. Process
\&    3. Encode n' output
.Ve
.PP
If yo' input is binary, n' is supposed ta remain binary, you shouldn't decode
it ta a text string, of course. But up in all other cases, you should decode dat shit.
.PP
Decodin can't happen reliably if you don't give a fuck how tha fuck tha data was encoded. Y'all KNOW dat shit, muthafucka! If
you git ta chizzle, itz a phat scam ta standardize on \s-1UTF\-8.\s0
.PP
.Vb 3
\&    mah $foo   = decode(\*(AqUTF\-8\*(Aq, git \*(Aqhttp://example.com/\*(Aq);
\&    mah $bar   = decode(\*(AqISO\-8859\-1\*(Aq, readline STDIN);
\&    mah $xyzzy = decode(\*(AqWindows\-1251\*(Aq, $cgi\->param(\*(Aqfoo\*(Aq));
.Ve
.PP
Processin happens as you knew before. Da only difference is dat you now
usin charactas instead of bytes. Thatz straight-up useful if you use thangs like
\&\f(CW\*(C`substr\*(C'\fR, or \f(CW\*(C`length\*(C'\fR.
.PP
It aint nuthin but blingin ta realize dat there be no bytes up in a text string. Of course,
Perl has its internal encodin ta store tha strang up in memory yo, but ignore dis shit.
If you gotta do anythang wit tha number of bytes, itz probably dopest ta move
that part ta step 3, just afta you've encoded tha string. Then you know
exactly how tha fuck nuff bytes it is ghon be up in tha destination string.
.PP
Da syntax fo' encodin text strings ta binary strings be as simple as decoding:
.PP
.Vb 1
\&    $body = encode(\*(AqUTF\-8\*(Aq, $body);
.Ve
.PP
If you needed ta know tha length of tha strang up in bytes, nowz tha slick time
for dis shit. Because \f(CW$body\fR is now a funky-ass byte string, \f(CW\*(C`length\*(C'\fR will report the
number of bytes, instead of tha number of characters. Da number of
charactas is no longer known, cuz charactas only exist up in text strings.
.PP
.Vb 1
\&    mah $byte_count = length $body;
.Ve
.PP
And if tha protocol you rockin supports a way of lettin tha recipient know
which characta encodin you used, please help tha receivin end by rockin that
feature biaaatch! For example, E\-mail n' \s-1HTTP\s0 support \s-1MIME\s0 headers, so you can use the
\&\f(CW\*(C`Content\-Type\*(C'\fR header n' shit. They can also have \f(CW\*(C`Content\-Length\*(C'\fR ta indicate the
number of \fIbytes\fR, which be always a phat scam ta supply if tha number is
known.
.PP
.Vb 2
\&    "Content\-Type: text/plain; charset=UTF\-8",
\&    "Content\-Length: $byte_count"
.Ve
.SH "SUMMARY"
.IX Header "SUMMARY"
Decode every last muthafuckin thang you receive, encode every last muthafuckin thang you bust out. (If itz text
data.)
.SH "Q n' A (or FAQUIZZY)"
.IX Header "Q n' A (or FAQUIZZY)"
Afta readin dis document, you ought ta read perlunifaq like a muthafucka.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks ta Johan Vromans from Squirrel Consultancy yo. His \s-1UTF\-8\s0 rants durin the
Amsterdam Perl Mongers meetings gots me interested n' determined ta smoke up
how ta use characta encodings up in Perl up in ways dat don't break doggystyle.
.PP
Thanks ta Gerard Goossen from \s-1TTY.\s0 His presentation \*(L"\s-1UTF\-8\s0 up in tha wild\*(R" (Dutch
Perl Workshop 2006) inspired mah crazy ass ta publish mah thoughts n' write dis tutorial.
.PP
Thanks ta tha playas whoz ass axed bout dis kind of shiznit up in nuff muthafuckin Perl \s-1IRC\s0
channels, n' have constantly reminded mah crazy ass dat a simpla explanation was
needed.
.PP
Thanks ta tha playas whoz ass reviewed dis document fo' me, before it went public.
They are: Benjamin Smizzle, Jan-Pieta Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.
.SH "AUTHOR"
.IX Header "AUTHOR"
Juerd Waalboer <#####@juerd.nl>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunifaq, perlunicode, perluniintro, Encode
