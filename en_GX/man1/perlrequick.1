.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREQUICK 1"
.TH PERLREQUICK 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlrequick \- Perl regular expressions quick start
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page covers tha straight-up basics of understanding, bustin and
usin regular expressions ('regexes') up in Perl.
.SH "Da Guide"
.IX Header "Da Guide"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
Da simplest regex is simply a word, or mo' generally, a strang of
characters.  A regex consistin of a word matches any strang that
gotz nuff dat word:
.PP
.Vb 1
\&    "Wuz crackalackin' World" =~ /World/;  # matches
.Ve
.PP
In dis statement, \f(CW\*(C`World\*(C'\fR be a regex n' tha \f(CW\*(C`//\*(C'\fR enclosing
\&\f(CW\*(C`/World/\*(C'\fR  drops some lyrics ta Perl ta search a strang fo' a match.  Da operator
\&\f(CW\*(C`=~\*(C'\fR associates tha strang wit tha regex match n' produces a true
value if tha regex matched, or false if tha regex did not match.  In
our case, \f(CW\*(C`World\*(C'\fR matches tha second word up in \f(CW"Wuz crackalackin' World"\fR, so the
expression is true.  This scam has nuff muthafuckin variations.
.PP
Expressions like dis is useful up in conditionals:
.PP
.Vb 1
\&    print "It matches\en" if "Wuz crackalackin' World" =~ /World/;
.Ve
.PP
Da sense of tha match can be reversed by rockin \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 1
\&    print "It don\*(Aqt match\en" if "Wuz crackalackin' World" !~ /World/;
.Ve
.PP
Da literal strang up in tha regex can be replaced by a variable:
.PP
.Vb 2
\&    $greetin = "World";
\&    print "It matches\en" if "Wuz crackalackin' World" =~ /$greeting/;
.Ve
.PP
If you matchin against \f(CW$_\fR, tha \f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 2
\&    $_ = "Wuz crackalackin' World";
\&    print "It matches\en" if /World/;
.Ve
.PP
Finally, tha \f(CW\*(C`//\*(C'\fR default delimitas fo' a match can be chizzled to
arbitrary delimitas by puttin a \f(CW\*(Aqm\*(Aq\fR up front:
.PP
.Vb 4
\&    "Wuz crackalackin' World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Wuz crackalackin' World" =~ m{World};   # matches, note tha matchin \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches afta \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes a ordinary char
.Ve
.PP
Regexes must match a part of tha strang \fIexactly\fR up in order fo' the
statement ta be true:
.PP
.Vb 3
\&    "Wuz crackalackin' World" =~ /world/;  # don\*(Aqt match, case sensitive
\&    "Wuz crackalackin' World" =~ /o W/;    # matches, \*(Aq \*(Aq be a ordinary char
\&    "Wuz crackalackin' World" =~ /Ghetto /; # don\*(Aqt match, no \*(Aq \*(Aq at end
.Ve
.PP
Perl will always match all up in tha earliest possible point up in tha string:
.PP
.Vb 2
\&    "Wuz crackalackin' World" =~ /o/;       # matches \*(Aqo\*(Aq up in \*(AqHello\*(Aq
\&    "That basebizzle cap is red" =~ /hat/; # matches \*(Aqhat\*(Aq up in \*(AqThat\*(Aq
.Ve
.PP
Not all charactas can be used 'as is' up in a match.  Some characters,
called \fBmetacharacters\fR, is reserved fo' use up in regex notation.
Da metacharactas are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
A metacharacta can be matched by puttin a funky-ass backslash before it:
.PP
.Vb 4
\&    "2+2=4" =~ /2+2/;    # don\*(Aqt match, + be a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like a ordinary +
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;                       # matches
\&    "/usr/bin/perl" =~ /\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In tha last regex, tha forward slash \f(CW\*(Aq/\*(Aq\fR be also backslashed,
because it is used ta delimit tha regex.
.PP
Non-printable \s-1ASCII\s0 charactas is represented by \fBescape sequences\fR.
Common examplez is \f(CW\*(C`\et\*(C'\fR fo' a tab, \f(CW\*(C`\en\*(C'\fR fo' a newline, n' \f(CW\*(C`\er\*(C'\fR
for a cold-ass lil carriage return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Arbitrary bytes is represented by octal
escape sequences, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape sequences,
e.g., \f(CW\*(C`\ex1B\*(C'\fR:
.PP
.Vb 2
\&    "1000\et2000" =~ m(0\et2)      # matches
\&    "cat"      =~ /\e143\ex61\ex74/ # matches up in ASCII yo, but a weird way ta spell cat
.Ve
.PP
Regexes is treated mostly as double-quoted strings, so variable
substitution works:
.PP
.Vb 3
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
With all of tha regexes above, if tha regex matched anywhere up in the
string, dat shiznit was considered a match.  To specify \fIwhere\fR it should
match, we would use tha \fBanchor\fR metacharactas \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match all up in tha beginnin of tha strang n' tha anchor
\&\f(CW\*(C`$\*(C'\fR means match all up in tha end of tha string, or before a newline at the
end of tha string.  Some examples:
.PP
.Vb 5
\&    "housekeeper" =~ /keeper/;         # matches
\&    "housekeeper" =~ /^keeper/;        # don\*(Aqt match
\&    "housekeeper" =~ /keeper$/;        # matches
\&    "housekeeper\en" =~ /keeper$/;      # matches
\&    "housekeeper" =~ /^housekeeper$/;  # matches
.Ve
.SS "Usin characta classes"
.IX Subsection "Usin characta classes"
A \fBcharacta class\fR allows a set of possible characters, rather than
just a single character, ta match at a particular point up in a regex.
Characta classes is denoted by brackets \f(CW\*(C`[...]\*(C'\fR, wit tha set of
charactas ta be possibly matched inside.  Here is some examples:
.PP
.Vb 3
\&    /cat/;            # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;        # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    "abc" =~ /[cab]/; # matches \*(Aqa\*(Aq
.Ve
.PP
In tha last statement, even though \f(CW\*(Aqc\*(Aq\fR is tha straight-up original gangsta characta in
the class, tha earliest point at which tha regex can match is \f(CW\*(Aqa\*(Aq\fR.
.PP
.Vb 3
\&    /[yY][eE][sS]/; # match \*(Aqyes\*(Aq up in a cold-ass lil case\-insensitizzle way
\&                    # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
\&    /yes/i;         # also match \*(Aqyes\*(Aq up in a cold-ass lil case\-insensitizzle way
.Ve
.PP
Da last example shows a match wit a \f(CW\*(Aqi\*(Aq\fR \fBmodifier\fR, which makes
the match case-insensitive.
.PP
Characta classes also have ordinary n' special charactas yo, but the
setz of ordinary n' special charactas inside a cold-ass lil characta class are
different than dem outside a cold-ass lil characta class.  Da special
charactas fo' a cold-ass lil characta class is \f(CW\*(C`\-]\e^$\*(C'\fR n' is matched rockin an
escape:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
Da special characta \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so dat tha unwieldy \f(CW\*(C`[0123456789]\*(C'\fR n' \f(CW\*(C`[abc...xyz]\*(C'\fR
become tha svelte \f(CW\*(C`[0\-9]\*(C'\fR n' \f(CW\*(C`[a\-z]\*(C'\fR:
.PP
.Vb 2
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is tha straight-up original gangsta or last characta up in a cold-ass lil characta class, it is
treated as a ordinary character.
.PP
Da special characta \f(CW\*(C`^\*(C'\fR up in tha straight-up original gangsta posizzle of a cold-ass lil characta class
denotes a \fBnegated characta class\fR, which matches any characta but
those up in tha brackets, n' you can put dat on yo' toast.  Both \f(CW\*(C`[...]\*(C'\fR n' \f(CW\*(C`[^...]\*(C'\fR must match a
character, or tha match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # don\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq yo, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Perl has nuff muthafuckin abbreviations fo' common characta classes. (These
definitions is dem dat Perl uses up in ASCII-safe mode wit tha \f(CW\*(C`/a\*(C'\fR modifier.
Otherwise they could match nuff mo' non-ASCII Unicode charactas as
well.  See \*(L"Backslash sequences\*(R" up in perlrecharclass fo' details.)
.IP "\(bu" 4
\&\ed be a gangbangin' finger-lickin' digit n' represents
.Sp
.Vb 1
\&    [0\-9]
.Ve
.IP "\(bu" 4
\&\es be a whitespace characta n' represents
.Sp
.Vb 1
\&    [\e \et\er\en\ef]
.Ve
.IP "\(bu" 4
\&\ew be a word characta (alphanumeric or _) n' represents
.Sp
.Vb 1
\&    [0\-9a\-zA\-Z_]
.Ve
.IP "\(bu" 4
\&\eD be a negated \ed; it represents any characta but a gangbangin' finger-lickin' digit
.Sp
.Vb 1
\&    [^0\-9]
.Ve
.IP "\(bu" 4
\&\eS be a negated \es; it represents any non-whitespace character
.Sp
.Vb 1
\&    [^\es]
.Ve
.IP "\(bu" 4
\&\eW be a negated \ew; it represents any non-word character
.Sp
.Vb 1
\&    [^\ew]
.Ve
.IP "\(bu" 4
Da period '.' matches any characta but \*(L"\en\*(R"
.PP
Da \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside n' outside
of characta classes.  Here is some up in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thang, matches \*(Aqend.\*(Aq
.Ve
.PP
Da \fBword\ anchor\fR\  \f(CW\*(C`\eb\*(C'\fR matches a funky-ass boundary between a word
characta n' a non-word characta \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 4
\&    $x = "Housecat catenates doggy den n' cat";
\&    $x =~ /\ebcat/;  # matches pussaaaaay up in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches pussaaaaay up in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
In tha last example, tha end of tha strang is considered a word
boundary.
.SS "Matchin dis or that"
.IX Subsection "Matchin dis or that"
We can match different characta strings wit tha \fBalternation\fR
metacharacta \f(CW\*(Aq|\*(Aq\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we form tha regex
\&\f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try ta match tha regex at the
earliest possible point up in tha string.  At each characta position,
Perl will first try ta match tha straight-up original gangsta alternative, \f(CW\*(C`dog\*(C'\fR.  If
\&\f(CW\*(C`dog\*(C'\fR don't match, Perl will then try tha next alternative, \f(CW\*(C`cat\*(C'\fR.
If \f(CW\*(C`cat\*(C'\fR don't match either, then tha match fails n' Perl moves to
the next posizzle up in tha string.  Some examples:
.PP
.Vb 2
\&    "cats n' dawgs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats n' dawgs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is tha straight-up original gangsta alternatizzle up in tha second regex,
\&\f(CW\*(C`cat\*(C'\fR be able ta match earlier up in tha string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
At a given characta position, tha straight-up original gangsta alternatizzle dat allows the
regex match ta succeed is ghon be tha one dat matches yo. Here, all the
alternatives match all up in tha straight-up original gangsta strang position, so tha straight-up original gangsta matches.
.SS "Groupin thangs n' hierarchical matching"
.IX Subsection "Groupin thangs n' hierarchical matching"
Da \fBgrouping\fR metacharactas \f(CW\*(C`()\*(C'\fR allow a part of a regex ta be
treated as a single unit.  Partz of a regex is grouped by enclosing
them up in parentheses.  Da regex \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some mo' examples
are
.PP
.Vb 2
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of strang or \*(Aqbc\*(Aq anywhere
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note crews can be nested.
\&
\&    "20" =~ /(19|20|)\ed\ed/;  # matches tha null alternatizzle \*(Aq()\ed\ed\*(Aq,
\&                             # cuz \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.SS "Extractin matches"
.IX Subsection "Extractin matches"
Da groupin metacharactas \f(CW\*(C`()\*(C'\fR also allow tha extraction of the
partz of a strang dat matched. Y'all KNOW dat shit, muthafucka!  For each grouping, tha part that
matched inside goes tha fuck into tha special variablez \f(CW$1\fR, \f(CW$2\fR, etc.
They can be used just as ordinary variables:
.PP
.Vb 5
\&    # extract hours, minutes, seconds
\&    $time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/;  # match hh:mm:ss format
\&    $hours = $1;
\&    $minutes = $2;
\&    $secondz = $3;
.Ve
.PP
In list context, a match \f(CW\*(C`/regex/\*(C'\fR wit groupings will return the
list of matched joints \f(CW\*(C`($1,$2,...)\*(C'\fR.  So we could rewrite it as
.PP
.Vb 1
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If tha groupings up in a regex is nested, \f(CW$1\fR gets tha crew wit the
leftmost openin parenthesis, \f(CW$2\fR tha next openin parenthesis,
etc.  For example, here be a cold-ass lil complex regex n' tha matchin variables
indicated below it:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
Associated wit tha matchin variablez \f(CW$1\fR, \f(CW$2\fR, ... are
the \fBbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR, ...  Backreferences are
matchin variablez dat can be used \fIinside\fR a regex:
.PP
.Vb 1
\&    /(\ew\ew\ew)\es\eg1/; # find sequences like \*(Aqthe the\*(Aq up in string
.Ve
.PP
\&\f(CW$1\fR, \f(CW$2\fR, ... should only be used outside of a regex, n' \f(CW\*(C`\eg1\*(C'\fR,
\&\f(CW\*(C`\eg2\*(C'\fR, ... only inside a regex.
.SS "Matchin repetitions"
.IX Subsection "Matchin repetitions"
Da \fBquantifier\fR metacharactas \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, n' \f(CW\*(C`{}\*(C'\fR allow us
to determine tha number of repeatz of a portion of a regex we
consider ta be a match.  Quantifiers is put immediately afta the
character, characta class, or groupin dat we wanna specify.  They
have tha followin meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR = match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR = match 'a' 0 or mo' times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR = match 'a' 1 or mo' times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR times yo, but not mo' than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR = match at least \f(CW\*(C`n\*(C'\fR or mo' times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR = match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here is some examples:
.PP
.Vb 6
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least some space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled lyrics of arbitrary length
\&    $year =~ /^\ed{2,4}$/;  # make shizzle year be at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # betta match; throw up 3 digit dates
.Ve
.PP
These quantifiers will try ta match as much of tha strang as possible,
while still allowin tha regex ta match.  So our crazy asses have
.PP
.Vb 5
\&    $x = \*(Aqthe pussaaaaay up in tha hat\*(Aq;
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe pussaaaaay up in tha h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.PP
Da first quantifier \f(CW\*(C`.*\*(C'\fR grabs as much of tha strang as possible
while still havin tha regex match. Da second quantifier \f(CW\*(C`.*\*(C'\fR has
no strang left ta it, so it matches 0 times.
.SS "Mo' matching"
.IX Subsection "Mo' matching"
There is all dem mo' thangs you might wanna know bout matching
operators.
Da global modifier \f(CW\*(C`//g\*(C'\fR allows tha matchin operator ta match
within a strang as nuff times as possible.  In scalar context,
successive matches against a strang gonna git \f(CW\*(C`//g\*(C'\fR jump from match
to match, keepin track of posizzle up in tha strang as it goes along.
Yo ass can git or set tha posizzle wit tha \f(CW\*(C`pos()\*(C'\fR function.
For example,
.PP
.Vb 4
\&    $x = "cat dawg house"; # 3 lyrics
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, endz at posizzle ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, endz at posizzle 3
\&    Word is dog, endz at posizzle 7
\&    Word is house, endz at posizzle 13
.Ve
.PP
A failed match or changin tha target strang resets tha position. I aint talkin' bout chicken n' gravy biatch.  If
you don't want tha posizzle reset afta failure ta match, add the
\&\f(CW\*(C`//c\*(C'\fR, as up in \f(CW\*(C`/regex/gc\*(C'\fR.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there is no groupings, a list of matches ta tha whole regex.  So
.PP
.Vb 4
\&    @wordz = ($x =~ /(\ew+)/g);  # matches,
\&                                # $word[0] = \*(Aqcat\*(Aq
\&                                # $word[1] = \*(Aqdog\*(Aq
\&                                # $word[2] = \*(Aqhouse\*(Aq
.Ve
.SS "Search n' replace"
.IX Subsection "Search n' replace"
Search n' replace is performed rockin \f(CW\*(C`s/regex/replacement/modifiers\*(C'\fR.
Da \f(CW\*(C`replacement\*(C'\fR be a Perl double-quoted strang dat replaces up in the
strin whatever is matched wit tha \f(CW\*(C`regex\*(C'\fR.  Da operator \f(CW\*(C`=~\*(C'\fR is
also used here ta associate a strang wit \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, tha \f(CW\*(C`$_\ =~\*(C'\fR can be dropped. Y'all KNOW dat shit, muthafucka!  If there be a match,
\&\f(CW\*(C`s///\*(C'\fR returns tha number of substitutions made; otherwise it returns
false.  Here is all dem examples:
.PP
.Vb 5
\&    $x = "Time ta feed tha cat!";
\&    $x =~ s/cat/hacker/;   # $x gotz nuff "Time ta feed tha hacker!"
\&    $y = "\*(Aqquoted lyrics\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y gotz nuff "quoted lyrics"
.Ve
.PP
With tha \f(CW\*(C`s///\*(C'\fR operator, tha matched variablez \f(CW$1\fR, \f(CW$2\fR, etc.
are immediately available fo' use up in tha replacement expression. I aint talkin' bout chicken n' gravy biatch. With
the global modifier, \f(CW\*(C`s///g\*(C'\fR will search n' replace all occurrences
of tha regex up in tha string:
.PP
.Vb 4
\&    $x = "I batted 4 fo' 4";
\&    $x =~ s/4/four/;   # $x gotz nuff "I batted four fo' 4"
\&    $x = "I batted 4 fo' 4";
\&    $x =~ s/4/four/g;  # $x gotz nuff "I batted four fo' four"
.Ve
.PP
Da non-destructizzle modifier \f(CW\*(C`s///r\*(C'\fR causes tha result of tha substitution
to be returned instead of modifyin \f(CW$_\fR (or whatever variable the
substitute was bound ta wit \f(CW\*(C`=~\*(C'\fR):
.PP
.Vb 3
\&    $x = "I wanna bust a nut on dawgs.";
\&    $y = $x =~ s/dawgs/cats/r;
\&    print "$x $y\en"; # prints "I wanna bust a nut on dawgs. I wanna bust a nut on cats."
\&
\&    $x = "Pussies is pimped out.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs is pimped out."
\&
\&    @foo = map { s/[a\-z]/X/r } qw(a b c 1 2 3);
\&    # @foo is now qw(X X X 1 2 3)
.Ve
.PP
Da evaluation modifier \f(CW\*(C`s///e\*(C'\fR wraps a \f(CW\*(C`eval{...}\*(C'\fR round the
replacement strang n' tha evaluated result is substituted fo' the
matched substring.  Some examples:
.PP
.Vb 3
\&    # reverse all tha lyrics up in a string
\&    $x = "the pussaaaaay up in tha hat";
\&    $x =~ s/(\ew+)/reverse $1/ge;   # $x gotz nuff "eht tac ni eht tah"
\&
\&    # convert cementage ta decimal
\&    $x = "A 39% hit rate";
\&    $x =~ s!(\ed+)%!$1/100!e;       # $x gotz nuff "A 0.39 hit rate"
.Ve
.PP
Da last example shows dat \f(CW\*(C`s///\*(C'\fR can use other delimiters, such as
\&\f(CW\*(C`s!!!\*(C'\fR n' \f(CW\*(C`s{}{}\*(C'\fR, n' even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes is used
\&\f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then tha regex n' replacement is treated as single-quoted
strings.
.SS "Da split operator"
.IX Subsection "Da split operator"
\&\f(CW\*(C`split /regex/, string\*(C'\fR splits \f(CW\*(C`string\*(C'\fR tha fuck into a list of substrings
and returns dat list.  Da regex determines tha characta sequence
that \f(CW\*(C`string\*(C'\fR is split wit respect to.  For example, ta split a
strin tha fuck into lyrics, use
.PP
.Vb 4
\&    $x = "Calvin n' Hobbes";
\&    @word = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                              # $word[1] = \*(Aqand\*(Aq
\&                              # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
To extract a cold-ass lil comma-delimited list of numbers, use
.PP
.Vb 4
\&    $x = "1.618,2.718,   3.142";
\&    @const = split /,\es*/, $x;  # $const[0] = \*(Aq1.618\*(Aq
\&                                # $const[1] = \*(Aq2.718\*(Aq
\&                                # $const[2] = \*(Aq3.142\*(Aq
.Ve
.PP
If tha empty regex \f(CW\*(C`//\*(C'\fR is used, tha strang is split tha fuck into individual
characters.  If tha regex has groupings, then tha list produced gotz nuff
the matched substrings from tha groupings as well:
.PP
.Vb 6
\&    $x = "/usr/bin";
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
.Ve
.PP
Since tha straight-up original gangsta characta of \f(CW$x\fR matched tha regex, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element ta tha list.
.SH "BUGS"
.IX Header "BUGS"
None.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a quick start guide.  For a mo' in-depth tutorial on
regexes, peep perlretut n' fo' tha reference page, peep perlre.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All muthafuckin rights reserved.
.PP
This document may be distributed under tha same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
Da lyricist wanna give props ta Mark-Jizzo Dominus, Tomothy Christiansen,
Ilya Zakharevich, Brad Hughes, n' Mike Giroux fo' all they helpful
comments.
