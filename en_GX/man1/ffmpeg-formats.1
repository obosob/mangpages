.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-FORMATS 1"
.TH FFMPEG-FORMATS 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-formats \- FFmpeg formats
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout tha supported formats (muxers n' demuxers)
provided by tha libavformat library.
.SH "FORMAT OPTIONS"
.IX Header "FORMAT OPTIONS"
Da libavformat library serves up some generic global options, which
can be set on all tha muxers n' demuxers. In addizzle each muxer or
demuxer may support so-called private options, which is specific for
that component.
.PP
Options may be set by specifyin \-\fIoption\fR \fIvalue\fR up in the
FFmpeg tools, or by settin tha value explicitly up in the
\&\f(CW\*(C`AVFormatContext\*(C'\fR options or rockin tha \fIlibavutil/opt.h\fR \s-1API\s0
for programmatic use.
.PP
Da list of supported options bigs up:
.IP "\fBavioflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "avioflags flags (input/output)"
Possible joints:
.RS 4
.IP "\fBdirect\fR" 4
.IX Item "direct"
Reduce buffering.
.RE
.RS 4
.RE
.IP "\fBprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "probesize integer (input)"
Set probin size up in bytes, i.e. tha size of tha data ta analyze ta get
stream shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. A higher value will allow ta detect more
information up in case it is dispersed tha fuck into tha stream yo, but will increase
latency. Must be a integer not lesser than 32. Well shiiiit, it is 5000000 by default.
.IP "\fBpacketsize\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "packetsize integer (output)"
Set packet size.
.IP "\fBfflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fflags flags (input/output)"
Set format flags.
.Sp
Possible joints:
.RS 4
.IP "\fBignidx\fR" 4
.IX Item "ignidx"
Ignore index.
.IP "\fBgenpts\fR" 4
.IX Item "genpts"
Generate \s-1PTS.\s0
.IP "\fBnofillin\fR" 4
.IX Item "nofillin"
Do not fill up in missin joints dat can be exactly calculated.
.IP "\fBnoparse\fR" 4
.IX Item "noparse"
Disable AVParsers, dis needz \f(CW\*(C`+nofillin\*(C'\fR like a muthafucka.
.IP "\fBigndts\fR" 4
.IX Item "igndts"
Ignore \s-1DTS.\s0
.IP "\fBdiscardcorrupt\fR" 4
.IX Item "discardcorrupt"
Discard corrupted frames.
.IP "\fBsortdts\fR" 4
.IX Item "sortdts"
Try ta interleave output packets by \s-1DTS.\s0
.IP "\fBkeepside\fR" 4
.IX Item "keepside"
Do not merge side data.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Enable \s-1RTP MP4A\-LATM\s0 payload.
.IP "\fBnobuffer\fR" 4
.IX Item "nobuffer"
Reduce tha latency introduced by optionizzle buffering
.RE
.RS 4
.RE
.IP "\fBseek2any\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "seek2any integer (input)"
Allow seekin ta non-keyframes on demuxer level when supported if set ta 1.
Default is 0.
.IP "\fBanalyzeduration\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "analyzeduration integer (input)"
Specify how tha fuck nuff microsecondz is analyzed ta probe tha input fo' realz. A
higher value will allow ta detect mo' accurate shiznit yo, but will
increase latency. Well shiiiit, it defaults ta 5,000,000 microsecondz = 5 seconds.
.IP "\fBcryptokey\fR \fIhexadecimal string\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "cryptokey hexadecimal strang (input)"
Set decryption key.
.IP "\fBindexmem\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "indexmem integer (input)"
Set max memory used fo' timestamp index (per stream).
.IP "\fBrtbufsize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "rtbufsize integer (input)"
Set max memory used fo' bufferin real-time frames.
.IP "\fBfdebug\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "fdebug flags (input/output)"
Print specific debug info.
.Sp
Possible joints:
.RS 4
.IP "\fBts\fR" 4
.IX Item "ts"
.RE
.RS 4
.RE
.PD 0
.IP "\fBmax_delay\fR \fIinteger\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "max_delay integer (input/output)"
.PD
Set maximum muxin or demuxin delay up in microseconds.
.IP "\fBfpsprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "fpsprobesize integer (input)"
Set number of frames used ta probe fps.
.IP "\fBaudio_preload\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "audio_preload integer (output)"
Set microsecondz by which audio packets should be interleaved earlier.
.IP "\fBchunk_duration\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_duration integer (output)"
Set microsecondz fo' each chunk.
.IP "\fBchunk_size\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "chunk_size integer (output)"
Set size up in bytes fo' each chunk.
.IP "\fBerr_detect, f_err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "err_detect, f_err_detect flags (input)"
Set error detection flags. \f(CW\*(C`f_err_detect\*(C'\fR is deprecated and
should be used only via tha \fBffmpeg\fR tool.
.Sp
Possible joints:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
Verify embedded CRCs.
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
Detect bitstream justification deviations.
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
Detect improper bitstream length.
.IP "\fBexplode\fR" 4
.IX Item "explode"
Abort decodin on minor error detection.
.IP "\fBcareful\fR" 4
.IX Item "careful"
Consider thangs dat violate tha spec n' aint been peeped up in the
wild as errors.
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
Consider all spec non compliancies as errors.
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
Consider thangs dat a sane encoder should not do as a error.
.RE
.RS 4
.RE
.IP "\fBuse_wallclock_as_timestamps\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "use_wallclock_as_timestamps integer (input)"
Use wallclock as timestamps.
.IP "\fBavoid_negative_ts\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "avoid_negative_ts integer (output)"
Shift timestamps ta make dem non-negatizzle fo' realz. A value of 1 enablez shifting,
a value of 0 disablez it, tha default value of \-1 enablez shifting
when required by tha target format.
.Sp
When shiftin is enabled, all output timestamps is shifted by the
same amount fo' realz. Audio, vizzle, n' subtitlez desynchin n' relative
timestamp differences is preserved compared ta how tha fuck they would have
been without shifting.
.Sp
Also note dat dis affects only leadin wack timestamps, n' not
non-monotonic wack timestamps.
.IP "\fBskip_initial_bytes\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "skip_initial_bytes integer (input)"
Set number of bytes ta skip before readin header n' frames if set ta 1.
Default is 0.
.IP "\fBcorrect_ts_overflow\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "correct_ts_overflow integer (input)"
Correct single timestamp overflows if set ta 1. Default is 1.
.IP "\fBflush_packets\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "flush_packets integer (output)"
Flush tha underlyin I/O stream afta each packet. Default 1 enablez it, and
has tha effect of reducin tha latency; 0 disablez it n' may slightly
increase performizzle up in some cases.
.SS "Format stream specifiers"
.IX Subsection "Format stream specifiers"
Format stream specifiers allow selection of one or mo' streams that
match specific properties.
.PP
Possible formz of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches tha stream wit dis index.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of following: 'v' fo' vizzle, 'a' fo' audio,
\&'s' fo' subtitle, 'd' fo' data, n' 't' fo' attachments, n' you can put dat on yo' toast. If
\&\fIstream_index\fR is given, then it matches tha stream number
\&\fIstream_index\fR of dis type. Otherwise, it matches all streams of
this type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then it matches tha stream wit number
\&\fIstream_index\fR up in tha program wit tha id
\&\fIprogram_id\fR. Otherwise, it matches all streams up in tha program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches tha stream by a gangbangin' format-specific \s-1ID.\s0
.PP
Da exact semantics of stream specifiers is defined by the
\&\f(CW\*(C`avformat_match_stream_specifier()\*(C'\fR function declared up in the
\&\fIlibavformat/avformat.h\fR header.
.SH "DEMUXERS"
.IX Header "DEMUXERS"
Demuxers is configured elements up in FFmpeg dat can read the
multimedia streams from a particular type of file.
.PP
When you configure yo' FFmpeg build, all tha supported demuxers
are enabled by default. Yo ass can list all available ones rockin the
configure option \f(CW\*(C`\-\-list\-demuxers\*(C'\fR.
.PP
Yo ass can disable all tha demuxers rockin tha configure option
\&\f(CW\*(C`\-\-disable\-demuxers\*(C'\fR, n' selectively enable a single demuxer with
the option \f(CW\*(C`\-\-enable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR, or disable it
with tha option \f(CW\*(C`\-\-disable\-demuxer=\f(CIDEMUXER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-formats\*(C'\fR of tha ff* tools will display tha list of
enabled demuxers.
.PP
Da description of a shitload of tha currently available demuxers bigs up.
.SS "applehttp"
.IX Subsection "applehttp"
Applez \s-1HTTP\s0 Live Streamin demuxer.
.PP
This demuxer presents all AVStreams from all variant streams.
Da id field is set ta tha bitrate variant index number n' shit. By setting
the discard flags on AVStreams (by pressin 'a' or 'v' up in ffplay),
the calla can decizzle which variant streams ta straight-up receive.
Da total bitrate of tha variant dat tha stream belongs ta is
available up in a metadata key named \*(L"variant_bitrate\*(R".
.SS "asf"
.IX Subsection "asf"
Advanced Systems Format demuxer.
.PP
This demuxer is used ta demux \s-1ASF\s0 filez n' \s-1MMS\s0 network streams.
.IP "\fB\-no_resync_search\fR \fIbool\fR" 4
.IX Item "-no_resync_search bool"
Do not try ta resynchronize by lookin fo' a cold-ass lil certain optionizzle start code.
.SS "concat"
.IX Subsection "concat"
Virtual concatenation script demuxer.
.PP
This demuxer readz a list of filez n' other directives from a text file and
demuxes dem one afta tha other, as if all they packet had been muxed
together.
.PP
Da timestamps up in tha filez is adjusted so dat tha straight-up original gangsta file starts at 0
and each next file starts where tha previous one finishes. Note dat it is
done globally n' may cause gaps if all streams aint gots exactly tha same
length.
.PP
All filez must have tha same streams (same codecs, same time base, etc.).
.PP
Da duration of each file is used ta adjust tha timestampz of tha next file:
if tha duration is incorrect (because dat shiznit was computed rockin tha bit-rate or
because tha file is truncated, fo' example), it can cause artifacts, n' you can put dat on yo' toast. The
\&\f(CW\*(C`duration\*(C'\fR directizzle can be used ta override tha duration stored in
each file.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
Da script be a text file up in extended-ASCII, wit one directizzle per line.
Empty lines, leadin spaces n' lines startin wit '#' is ignored. Y'all KNOW dat shit, muthafucka! The
followin directizzle is recognized:
.ie n .IP "\fB\fB""file \f(BIpath\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBfile \f(CBpath\f(CB\fB\fR" 4
.IX Item "file path"
Path ta a gangbangin' file ta read; special charactas n' spaces must be escaped with
backslash or single quotes.
.Sp
All subsequent directives apply ta dat file.
.ie n .IP "\fB\fB""ffconcat version 1.0""\fB\fR" 4
.el .IP "\fB\f(CBffconcat version 1.0\fB\fR" 4
.IX Item "ffconcat version 1.0"
Identify tha script type n' version. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also sets tha \fBsafe\fR option
to 1 if dat shiznit was ta its default \-1.
.Sp
To make FFmpeg recognize tha format automatically, dis directizzle must
appears exactly as is (no extra space or byte-order-mark) on tha straight-up first
line of tha script.
.ie n .IP "\fB\fB""duration \f(BIdur\f(CB""\fB\fR" 4
.el .IP "\fB\f(CBduration \f(CBdur\f(CB\fB\fR" 4
.IX Item "duration dur"
Duration of tha file. This shiznit can be specified from tha file;
specifyin it here may be mo' efficient or help if tha shiznit from the
file aint available or accurate.
.Sp
If tha duration is set fo' all files, then it is possible ta seek up in the
whole concatenated vizzle.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
This demuxer accepts tha followin option:
.IP "\fBsafe\fR" 4
.IX Item "safe"
If set ta 1, reject unsafe file paths fo' realz. A file path is considered safe if it
does not contain a protocol justification n' is relatizzle n' all components
only contain charactas from tha portable characta set (letters, digits,
period, underscore n' hyphen) n' have no period all up in tha beginnin of a
component.
.Sp
If set ta 0, any file name be accepted.
.Sp
Da default is \-1, it is equivalent ta 1 if tha format was automatically
probed n' 0 otherwise.
.SS "flv"
.IX Subsection "flv"
Adobe Flash Video Format demuxer.
.PP
This demuxer is used ta demux \s-1FLV\s0 filez n' \s-1RTMP\s0 network streams.
.IP "\fB\-flv_metadata\fR \fIbool\fR" 4
.IX Item "-flv_metadata bool"
Allocate tha streams accordin ta tha onMetaData array content.
.SS "libgme"
.IX Subsection "libgme"
Da Game Music Emu library be a cold-ass lil collection of vizzle game noize file emulators.
.PP
See <\fBhttp://code.google.com/p/game\-music\-emu/\fR> fo' mo' shiznit.
.PP
Some filez have multiple tracks. Da demuxer will pick tha straight-up original gangsta track by
default. Da \fBtrack_index\fR option can be used ta select a gangbangin' finger-lickin' different
track. Track indexes start at 0. Da demuxer exports tha number of tracks as
\&\fItracks\fR meta data entry.
.PP
For straight-up big-ass files, tha \fBmax_size\fR option may gotta be adjusted.
.SS "libquvi"
.IX Subsection "libquvi"
Play media from Internizzle skillz rockin tha quvi project.
.PP
Da demuxer accepts a \fBformat\fR option ta request a specific quality. It
is by default set ta \fIbest\fR.
.PP
See <\fBhttp://quvi.sourceforge.net/\fR> fo' mo' shiznit.
.PP
FFmpeg need ta be built wit \f(CW\*(C`\-\-enable\-libquvi\*(C'\fR fo' dis demuxer ta be
enabled.
.SS "image2"
.IX Subsection "image2"
Image file demuxer.
.PP
This demuxer readz from a list of image filez specified by a pattern.
Da syntax n' meanin of tha pattern is specified by the
option \fIpattern_type\fR.
.PP
Da pattern may contain a suffix which is used ta automatically
determine tha format of tha images contained up in tha files.
.PP
Da size, tha pixel format, n' tha format of each image must be the
same fo' all tha filez up in tha sequence.
.PP
This demuxer accepts tha followin options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set tha frame rate fo' tha vizzle stream. Well shiiiit, it defaults ta 25.
.IP "\fBloop\fR" 4
.IX Item "loop"
If set ta 1, loop over tha input. Default value is 0.
.IP "\fBpattern_type\fR" 4
.IX Item "pattern_type"
Select tha pattern type used ta interpret tha provided filename.
.Sp
\&\fIpattern_type\fR accepts one of tha followin joints.
.RS 4
.IP "\fBsequence\fR" 4
.IX Item "sequence"
Select a sequence pattern type, used ta specify a sequence of files
indexed by sequential numbers.
.Sp
A sequence pattern may contain tha strang \*(L"%d\*(R" or "%0\fIN\fRd\*(L", which
specifies tha posizzle of tha charactas representin a sequential
number up in each filename matched by tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If tha form
\&\*(R"%d0\fIN\fRd" is used, tha strang representin tha number up in each
filename is 0\-padded n' \fIN\fR is tha total number of 0\-padded
digits representin tha number n' shit. Da literal characta '%' can be
specified up in tha pattern wit tha strang \*(L"%%\*(R".
.Sp
If tha sequence pattern gotz nuff \*(L"%d\*(R" or "%0\fIN\fRd", tha straight-up original gangsta filename of
the file list specified by tha pattern must contain a number
inclusively contained between \fIstart_number\fR and
\&\fIstart_number\fR+\fIstart_number_range\fR\-1, n' all tha following
numbers must be sequential.
.Sp
For example tha pattern \*(L"img\-%03d.bmp\*(R" will match a sequence of
filenamez of tha form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.; tha pattern \*(L"i%%m%%g\-%d.jpg\*(R" will match a
sequence of filenamez of tha form \fIi%m%g\-1.jpg\fR,
\&\fIi%m%g\-2.jpg\fR, ..., \fIi%m%g\-10.jpg\fR, etc.
.Sp
Note dat tha pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", fo' example ta convert a single image file
\&\fIimg.jpeg\fR you can employ tha command:
.Sp
.Vb 1
\&        ffmpeg \-i img.jpeg img.png
.Ve
.IP "\fBglob\fR" 4
.IX Item "glob"
Select a glob wildcard pattern type.
.Sp
Da pattern is interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This is only
selectable if libavformat was compiled wit globbin support.
.IP "\fBglob_sequence\fR \fI(deprecated, is ghon be removed)\fR" 4
.IX Item "glob_sequence (deprecated, is ghon be removed)"
Select a mixed glob wildcard/sequence pattern.
.Sp
If yo' version of libavformat was compiled wit globbin support, and
the provided pattern gotz nuff at least one glob meta characta among
\&\f(CW\*(C`%*?[]{}\*(C'\fR dat is preceded by a unescaped \*(L"%\*(R", tha pattern is
interpreted like a \f(CW\*(C`glob()\*(C'\fR pattern, otherwise it is interpreted
like a sequence pattern.
.Sp
All glob special charactas \f(CW\*(C`%*?[]{}\*(C'\fR must be prefixed
with \*(L"%\*(R". To escape a literal \*(L"%\*(R" you shall use \*(L"%%\*(R".
.Sp
For example tha pattern \f(CW\*(C`foo\-%*.jpeg\*(C'\fR will match all the
filenames prefixed by \*(L"foo\-\*(R" n' terminatin wit \*(L".jpeg\*(R", and
\&\f(CW\*(C`foo\-%?%?%?.jpeg\*(C'\fR will match all tha filenames prefixed with
\&\*(L"foo\-\*(R", followed by a sequence of three characters, n' terminating
with \*(L".jpeg\*(R".
.Sp
This pattern type is deprecated up in favor of \fIglob\fR and
\&\fIsequence\fR.
.RE
.RS 4
.Sp
Default value is \fIglob_sequence\fR.
.RE
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set tha pixel format of tha images ta read. Y'all KNOW dat shit, muthafucka! If not specified tha pixel
format is guessed from tha straight-up original gangsta image file up in tha sequence.
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Set tha index of tha file matched by tha image file pattern ta start
to read from. Default value is 0.
.IP "\fBstart_number_range\fR" 4
.IX Item "start_number_range"
Set tha index interval range ta check when lookin fo' tha straight-up original gangsta image
file up in tha sequence, startin from \fIstart_number\fR. Default value
is 5.
.IP "\fBts_from_file\fR" 4
.IX Item "ts_from_file"
If set ta 1, will set frame timestamp ta modification time of image file. Note
that monotonitizzle of timestamps aint provided: images go up in tha same order as
without dis option. I aint talkin' bout chicken n' gravy biatch. Default value is 0.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha vizzle size of tha images ta read. Y'all KNOW dat shit, muthafucka! If not specified tha vizzle
size is guessed from tha straight-up original gangsta image file up in tha sequence.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use \fBffmpeg\fR fo' bustin a vizzle from tha images up in tha file
sequence \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ..., assumin an
input frame rate of 10 frames per second:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
As above yo, but start by readin from a gangbangin' file wit index 100 up in tha sequence:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-start_number 100 \-i \*(Aqimg\-%03d.jpeg\*(Aq out.mkv
.Ve
.IP "\(bu" 4
Read images matchin tha \*(L"*.png\*(R" glob pattern , dat be all tha files
terminatin wit tha \*(L".png\*(R" suffix:
.Sp
.Vb 1
\&        ffmpeg \-framerate 10 \-pattern_type glob \-i "*.png" out.mkv
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\-2\s0 transhiznit stream demuxer.
.IP "\fBfix_teletext_pts\fR" 4
.IX Item "fix_teletext_pts"
Overrides teletext packet \s-1PTS\s0 n' \s-1DTS\s0 joints wit tha timestamps calculated
from tha \s-1PCR\s0 of tha straight-up original gangsta program which tha teletext stream is part of n' is
not discarded. Y'all KNOW dat shit, muthafucka! Default value is 1, set dis option ta 0 if you want your
teletext packet \s-1PTS\s0 n' \s-1DTS\s0 joints untouched.
.SS "rawvideo"
.IX Subsection "rawvideo"
Raw vizzle demuxer.
.PP
This demuxer allows ta read raw vizzle data. Right back up in yo muthafuckin ass. Since there is no header
specifyin tha assumed vizzle parameters, tha user must specify them
in order ta be able ta decode tha data erectly.
.PP
This demuxer accepts tha followin options:
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Set input vizzle frame rate. Default value is 25.
.IP "\fBpixel_format\fR" 4
.IX Item "pixel_format"
Set tha input vizzle pixel format. Default value is \f(CW\*(C`yuv420p\*(C'\fR.
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Set tha input vizzle size. This value must be specified explicitly.
.PP
For example ta read a rawvideo file \fIinput.raw\fR with
\&\fBffplay\fR, assumin a pixel format of \f(CW\*(C`rgb24\*(C'\fR, a vizzle
size of \f(CW\*(C`320x240\*(C'\fR, n' a gangbangin' frame rate of 10 images per second, use
the command:
.PP
.Vb 1
\&        ffplay \-f rawvideo \-pixel_format rgb24 \-video_size 320x240 \-framerate 10 input.raw
.Ve
.SS "sbg"
.IX Subsection "sbg"
SBaGen script demuxer.
.PP
This demuxer readz tha script language used by SBaGen
<\fBhttp://uazu.net/sbagen/\fR> ta generate binaural beats sessions fo' realz. A \s-1SBG\s0
script be lookin like that:
.PP
.Vb 9
\&        \-SE
\&        a: 300\-2.5/3 440+4.5/0
\&        b: 300\-2.5/0 440+4.5/3
\&        off: \-
\&        NOW      == a
\&        +0:07:00 == b
\&        +0:14:00 == a
\&        +0:21:00 == b
\&        +0:30:00    off
.Ve
.PP
A \s-1SBG\s0 script can mix absolute n' relatizzle timestamps. If tha script uses
either only absolute timestamps (includin tha script start time) or only
relatizzle ones, then its layout is fixed, n' tha conversion is
straightforward. Y'all KNOW dat shit, muthafucka! On tha other hand, if tha script mixes both kind of
timestamps, then tha \fI\s-1NOW\s0\fR reference fo' relatizzle timestamps will be
taken from tha current time of dizzle all up in tha time tha script is read, n' the
script layout is ghon be frozen accordin ta dat reference. That means dat if
the script is directly played, tha actual times will match tha absolute
timestamps up ta tha sound controllerz clock accuracy yo, but if tha user
somehow pauses tha playback or seeks, all times is ghon be shifted accordingly.
.SS "tedcaptions"
.IX Subsection "tedcaptions"
\&\s-1JSON\s0 captions used fo' <\fBhttp://www.ted.com/\fR>.
.PP
\&\s-1TED\s0 do not provide links ta tha captions yo, but they can be guessed from the
page. Da file \fItools/bookmarklets.html\fR from tha FFmpeg source tree
gotz nuff a funky-ass bookmarklet ta expose em.
.PP
This demuxer accepts tha followin option:
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Set tha start time of tha \s-1TED\s0 talk, up in milliseconds. Da default is 15000
(15s). Well shiiiit, it is used ta sync tha captions wit tha downloadable vizzles, cuz
they include a 15s intro.
.PP
Example: convert tha captions ta a gangbangin' format most playas understand:
.PP
.Vb 1
\&        ffmpeg \-i http://www.ted.com/talks/subtitles/id/1/lang/en talk1\-en.srt
.Ve
.SH "MUXERS"
.IX Header "MUXERS"
Muxers is configured elements up in FFmpeg which allow writing
multimedia streams ta a particular type of file.
.PP
When you configure yo' FFmpeg build, all tha supported muxers
are enabled by default. Yo ass can list all available muxers rockin the
configure option \f(CW\*(C`\-\-list\-muxers\*(C'\fR.
.PP
Yo ass can disable all tha muxers wit tha configure option
\&\f(CW\*(C`\-\-disable\-muxers\*(C'\fR n' selectively enable / disable single muxers
with tha options \f(CW\*(C`\-\-enable\-muxer=\f(CIMUXER\f(CW\*(C'\fR /
\&\f(CW\*(C`\-\-disable\-muxer=\f(CIMUXER\f(CW\*(C'\fR.
.PP
Da option \f(CW\*(C`\-formats\*(C'\fR of tha ff* tools will display tha list of
enabled muxers.
.PP
A description of a shitload of tha currently available muxers bigs up.
.SS "aiff"
.IX Subsection "aiff"
Audio Interchange File Format muxer.
.PP
It accepts tha followin options:
.IP "\fBwrite_id3v2\fR" 4
.IX Item "write_id3v2"
Enable ID3v2 tags freestylin when set ta 1. Default is 0 (disabled).
.IP "\fBid3v2_version\fR" 4
.IX Item "id3v2_version"
Select ID3v2 version ta write. Currently only version 3 n' 4 (aka.
ID3v2.3 n' ID3v2.4) is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default is version 4.
.SS "crc"
.IX Subsection "crc"
\&\s-1CRC \s0(Cyclic Redundancy Check) testin format.
.PP
This muxer computes n' prints tha Adler\-32 \s-1CRC\s0 of all tha input audio
and vizzle frames. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
\&\s-1CRC.\s0
.PP
Da output of tha muxer consistz of a single line of tha form:
CRC=0x\fI\s-1CRC\s0\fR, where \fI\s-1CRC\s0\fR be a hexadecimal number 0\-padded to
8 digits containin tha \s-1CRC\s0 fo' all tha decoded input frames.
.PP
For example ta compute tha \s-1CRC\s0 of tha input, n' store it up in tha file
\&\fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc out.crc
.Ve
.PP
Yo ass can print tha \s-1CRC\s0 ta stdout wit tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f crc \-
.Ve
.PP
Yo ass can select tha output format of each frame wit \fBffmpeg\fR by
specifyin tha audio n' vizzle codec n' format. For example to
compute tha \s-1CRC\s0 of tha input audio converted ta \s-1PCM\s0 unsigned 8\-bit
and tha input vizzle converted ta \s-1MPEG\-2\s0 vizzle, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f crc \-
.Ve
.PP
See also tha framecrc muxer.
.SS "framecrc"
.IX Subsection "framecrc"
Per-packet \s-1CRC \s0(Cyclic Redundancy Check) testin format.
.PP
This muxer computes n' prints tha Adler\-32 \s-1CRC\s0 fo' each audio
and vizzle packet. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
\&\s-1CRC.\s0
.PP
Da output of tha muxer consistz of a line fo' each audio n' vizzle
packet of tha form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, 0x<CRC>
.Ve
.PP
\&\fI\s-1CRC\s0\fR be a hexadecimal number 0\-padded ta 8 digits containin the
\&\s-1CRC\s0 of tha packet.
.PP
For example ta compute tha \s-1CRC\s0 of tha audio n' vizzle frames in
\&\fI\s-1INPUT\s0\fR, converted ta raw audio n' vizzle packets, n' store it
in tha file \fIout.crc\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc out.crc
.Ve
.PP
To print tha shiznit ta stdout, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framecrc \-
.Ve
.PP
With \fBffmpeg\fR, you can select tha output format ta which the
audio n' vizzle frames is encoded before computin tha \s-1CRC\s0 fo' each
packet by specifyin tha audio n' vizzle codec. For example, to
compute tha \s-1CRC\s0 of each decoded input audio frame converted ta \s-1PCM\s0
unsigned 8\-bit n' of each decoded input vizzle frame converted to
\&\s-1MPEG\-2\s0 vizzle, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-c:a pcm_u8 \-c:v mpeg2video \-f framecrc \-
.Ve
.PP
See also tha crc muxer.
.SS "framemd5"
.IX Subsection "framemd5"
Per-packet \s-1MD5\s0 testin format.
.PP
This muxer computes n' prints tha \s-1MD5\s0 hash fo' each audio
and vizzle packet. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
hash.
.PP
Da output of tha muxer consistz of a line fo' each audio n' vizzle
packet of tha form:
.PP
.Vb 1
\&        <stream_index>, <packet_dts>, <packet_pts>, <packet_duration>, <packet_size>, <MD5>
.Ve
.PP
\&\fI\s-1MD5\s0\fR be a hexadecimal number representin tha computed \s-1MD5\s0 hash
for tha packet.
.PP
For example ta compute tha \s-1MD5\s0 of tha audio n' vizzle frames in
\&\fI\s-1INPUT\s0\fR, converted ta raw audio n' vizzle packets, n' store it
in tha file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 out.md5
.Ve
.PP
To print tha shiznit ta stdout, use tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f framemd5 \-
.Ve
.PP
See also tha md5 muxer.
.SS "hls"
.IX Subsection "hls"
Applez \s-1HTTP\s0 Live Streamin muxer dat segments MPEG-TS accordin to
the \s-1HTTP\s0 Live Streamin justification.
.PP
It creates a playlist file n' numbered segment files. Da output
filename specifies tha playlist filename; tha segment filenames
receive tha same basename as tha playlist, a sequential number and
a .ts extension.
.PP
.Vb 1
\&        ffmpeg \-i in.nut out.m3u8
.Ve
.IP "\fB\-hls_time\fR \fIseconds\fR" 4
.IX Item "-hls_time seconds"
Set tha segment length up in seconds.
.IP "\fB\-hls_list_size\fR \fIsize\fR" 4
.IX Item "-hls_list_size size"
Set tha maximum number of playlist entries.
.IP "\fB\-hls_wrap\fR \fIwrap\fR" 4
.IX Item "-hls_wrap wrap"
Set tha number afta which index wraps.
.IP "\fB\-start_number\fR \fInumber\fR" 4
.IX Item "-start_number number"
Start tha sequence from \fInumber\fR.
.SS "ico"
.IX Subsection "ico"
\&\s-1ICO\s0 file muxer.
.PP
Microsoftz icon file format (\s-1ICO\s0) has some strict limitations dat should be noted:
.IP "\(bu" 4
Size cannot exceed 256 pixels up in any dimension
.IP "\(bu" 4
Only \s-1BMP\s0 n' \s-1PNG\s0 images can be stored
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must be one of tha followin pixel formats:
.Sp
.Vb 7
\&        BMP Bit Depth      FFmpeg Pixel Format
\&        1bit               pal8
\&        4bit               pal8
\&        8bit               pal8
\&        16bit              rgb555le
\&        24bit              bgr24
\&        32bit              bgra
.Ve
.IP "\(bu" 4
If a \s-1BMP\s0 image is used, it must use tha \s-1BITMAPINFOHEADER DIB\s0 header
.IP "\(bu" 4
If a \s-1PNG\s0 image is used, it must use tha rgba pixel format
.SS "image2"
.IX Subsection "image2"
Image file muxer.
.PP
Da image file muxer writes vizzle frames ta image files.
.PP
Da output filenames is specified by a pattern, which can be used to
produce sequentially numbered seriez of files.
Da pattern may contain tha strang \*(L"%d\*(R" or "%0\fIN\fRd\*(L", dis string
specifies tha posizzle of tha charactas representin a numberin in
the filenames. If tha form \*(R"%0\fIN\fRd" is used, tha string
representin tha number up in each filename is 0\-padded ta \fIN\fR
digits, n' you can put dat on yo' toast. Da literal characta '%' can be specified up in tha pattern with
the strang \*(L"%%\*(R".
.PP
If tha pattern gotz nuff \*(L"%d\*(R" or "%0\fIN\fRd", tha straight-up original gangsta filename of
the file list specified will contain tha number 1, all tha following
numbers is ghon be sequential.
.PP
Da pattern may contain a suffix which is used ta automatically
determine tha format of tha image filez ta write.
.PP
For example tha pattern \*(L"img\-%03d.bmp\*(R" will specify a sequence of
filenamez of tha form \fIimg\-001.bmp\fR, \fIimg\-002.bmp\fR, ...,
\&\fIimg\-010.bmp\fR, etc.
Da pattern \*(L"img%%\-%d.jpg\*(R" will specify a sequence of filenamez of the
form \fIimg%\-1.jpg\fR, \fIimg%\-2.jpg\fR, ..., \fIimg%\-10.jpg\fR,
etc.
.PP
Da followin example shows how tha fuck ta use \fBffmpeg\fR fo' bustin a
sequence of filez \fIimg\-001.jpeg\fR, \fIimg\-002.jpeg\fR, ...,
takin one image every last muthafuckin second from tha input vizzle:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \-f image2 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note dat wit \fBffmpeg\fR, if tha format aint specified wit the
\&\f(CW\*(C`\-f\*(C'\fR option n' tha output filename specifies a image file
format, tha image2 muxer be automatically selected, so tha previous
command can be freestyled as:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vsync 1 \-r 1 \*(Aqimg\-%03d.jpeg\*(Aq
.Ve
.PP
Note also dat tha pattern must not necessarily contain \*(L"%d\*(R" or
"%0\fIN\fRd", fo' example ta create a single image file
\&\fIimg.jpeg\fR from tha input vizzle you can employ tha command:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-f image2 \-frames:v 1 img.jpeg
.Ve
.IP "\fBstart_number\fR \fInumber\fR" 4
.IX Item "start_number number"
Start tha sequence from \fInumber\fR. Default value is 1. Must be a
non-negatizzle number.
.IP "\fB\-update\fR \fInumber\fR" 4
.IX Item "-update number"
If \fInumber\fR is nonzero, tha filename will always be interpreted as just a
filename, not a pattern, n' dis file is ghon be continuously overwritten wit new
images.
.PP
Da image muxer supports tha .Y.U.V image file format. This format is
special up in dat that each image frame consistz of three files, for
each of tha \s-1YUV420P\s0 components, n' you can put dat on yo' toast. To read or write dis image file format,
specify tha name of tha '.Y' file. Da muxer will automatically open the
\&'.U' n' '.V' filez as required.
.SS "matroska"
.IX Subsection "matroska"
Matroska container muxer.
.PP
This muxer implements tha matroska n' webm container specs.
.PP
Da recognized metadata settings up in dis muxer are:
.IP "\fBtitle=\fR\fItitle name\fR" 4
.IX Item "title=title name"
Name provided ta a single track
.IP "\fBlanguage=\fR\fIlanguage name\fR" 4
.IX Item "language=language name"
Specifies tha language of tha track up in tha Matroska languages form
.IP "\fBstereo_mode=\fR\fImode\fR" 4
.IX Item "stereo_mode=mode"
Stereo 3D vizzle layout of two views up in a single vizzle track
.RS 4
.IP "\fBmono\fR" 4
.IX Item "mono"
video aint stereo
.IP "\fBleft_right\fR" 4
.IX Item "left_right"
Both views is arranged side by side, Left-eye view is on tha left
.IP "\fBbottom_top\fR" 4
.IX Item "bottom_top"
Both views is arranged up in top-bottom orientation, Left-eye view be at bottom
.IP "\fBtop_bottom\fR" 4
.IX Item "top_bottom"
Both views is arranged up in top-bottom orientation, Left-eye view is on top
.IP "\fBcheckerboard_rl\fR" 4
.IX Item "checkerboard_rl"
Each view be arranged up in a cold-ass lil checkerboard interleaved pattern, Left-eye view bein first
.IP "\fBcheckerboard_lr\fR" 4
.IX Item "checkerboard_lr"
Each view be arranged up in a cold-ass lil checkerboard interleaved pattern, Right-eye view bein first
.IP "\fBrow_interleaved_rl\fR" 4
.IX Item "row_interleaved_rl"
Each view is constituted by a row based interleaving, Right-eye view is first row
.IP "\fBrow_interleaved_lr\fR" 4
.IX Item "row_interleaved_lr"
Each view is constituted by a row based interleaving, Left-eye view is first row
.IP "\fBcol_interleaved_rl\fR" 4
.IX Item "col_interleaved_rl"
Both views is arranged up in a cold-ass lil column based interleavin manner, Right-eye view is first column
.IP "\fBcol_interleaved_lr\fR" 4
.IX Item "col_interleaved_lr"
Both views is arranged up in a cold-ass lil column based interleavin manner, Left-eye view is first column
.IP "\fBanaglyph_cyan_red\fR" 4
.IX Item "anaglyph_cyan_red"
All frames is up in anaglyph format viewable all up in red-cyan filters
.IP "\fBright_left\fR" 4
.IX Item "right_left"
Both views is arranged side by side, Right-eye view is on tha left
.IP "\fBanaglyph_green_magenta\fR" 4
.IX Item "anaglyph_green_magenta"
All frames is up in anaglyph format viewable all up in green-magenta filters
.IP "\fBblock_lr\fR" 4
.IX Item "block_lr"
Both eyes laced up in one Block, Left-eye view is first
.IP "\fBblock_rl\fR" 4
.IX Item "block_rl"
Both eyes laced up in one Block, Right-eye view is first
.RE
.RS 4
.RE
.PP
For example a 3D WebM clip can be pimped rockin tha followin command line:
.PP
.Vb 1
\&        ffmpeg \-i sample_left_right_clip.mpg \-an \-c:v libvpx \-metadata stereo_mode=left_right \-y stereo_clip.webm
.Ve
.PP
This muxer supports tha followin options:
.IP "\fBreserve_index_space\fR" 4
.IX Item "reserve_index_space"
By default, dis muxer writes tha index fo' seekin (called cues up in Matroska
terms) all up in tha end of tha file, cuz it cannot know up in advizzle how tha fuck much space
to leave fo' tha index all up in tha beginnin of tha file yo. However fo' some use cases
\&\*(-- e.g.  streamin where seekin is possible but slow \*(-- it is useful ta put the
index all up in tha beginnin of tha file.
.Sp
If dis option is set ta a non-zero value, tha muxer will reserve a given amount
of space up in tha file header n' then try ta write tha cues there when tha muxing
finishes. If tha available space do not suffice, muxin will fail fo' realz. A safe size
for most use cases should be bout 50kB per minute of vizzle.
.Sp
Note dat cues is only freestyled if tha output is seekable n' dis option will
have no effect if it is not.
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 testin format.
.PP
This muxer computes n' prints tha \s-1MD5\s0 hash of all tha input audio
and vizzle frames. By default audio frames is converted ta signed
16\-bit raw audio n' vizzle frames ta raw vizzle before computin the
hash.
.PP
Da output of tha muxer consistz of a single line of tha form:
MD5=\fI\s-1MD5\s0\fR, where \fI\s-1MD5\s0\fR be a hexadecimal number representing
the computed \s-1MD5\s0 hash.
.PP
For example ta compute tha \s-1MD5\s0 hash of tha input converted ta raw
audio n' vizzle, n' store it up in tha file \fIout.md5\fR:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 out.md5
.Ve
.PP
Yo ass can print tha \s-1MD5\s0 ta stdout wit tha command:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f md5 \-
.Ve
.PP
See also tha framemd5 muxer.
.SS "\s-1MOV/MP4/ISMV\s0"
.IX Subsection "MOV/MP4/ISMV"
Da mov/mp4/ismv muxer supports fragmentation. I aint talkin' bout chicken n' gravy biatch. Normally, a \s-1MOV/MP4\s0
file has all tha metadata bout all packets stored up in one location
(written all up in tha end of tha file, it can be moved ta tha start for
betta playback by addin \fIfaststart\fR ta tha \fImovflags\fR, or
usin tha \fBqt-faststart\fR tool) fo' realz. A fragmented
file consistz of a fuckin shitload of fragments, where packets n' metadata
about these packets is stored together n' shit. Freestylin a gangbangin' fragmented
file has tha advantage dat tha file is decodable even if the
writin is interrupted (while a aiiight \s-1MOV/MP4\s0 is undecodable if
it aint properly finished), n' it requires less memory when writing
very long filez (since freestylin aiiight \s-1MOV/MP4\s0 filez stores info about
every single packet up in memory until tha file is closed). Da downside
is dat it is less compatible wit other applications.
.PP
Fragmentation is enabled by settin one of tha AVOptions dat define
how ta cut tha file tha fuck into fragments:
.IP "\fB\-moov_size\fR \fIbytes\fR" 4
.IX Item "-moov_size bytes"
Reserves space fo' tha moov atom all up in tha beginnin of tha file instead of placin the
moov atom all up in tha end yo, but it ain't no stoppin cause I be still poppin'. If tha space reserved is insufficient, muxin will fail.
.IP "\fB\-movflags frag_keyframe\fR" 4
.IX Item "-movflags frag_keyframe"
Start a freshly smoked up fragment at each vizzle keyframe.
.IP "\fB\-frag_duration\fR \fIduration\fR" 4
.IX Item "-frag_duration duration"
Smoke fragments dat is \fIduration\fR microsecondz long.
.IP "\fB\-frag_size\fR \fIsize\fR" 4
.IX Item "-frag_size size"
Smoke fragments dat contain up ta \fIsize\fR bytez of payload data.
.IP "\fB\-movflags frag_custom\fR" 4
.IX Item "-movflags frag_custom"
Allow tha calla ta manually chizzle when ta cut fragments, by
callin \f(CW\*(C`av_write_frame(ctx, NULL)\*(C'\fR ta write a gangbangin' fragment with
the packets freestyled so far. Shiiit, dis aint no joke. (This is only useful wit other
applications integratin libavformat, not from \fBffmpeg\fR.)
.IP "\fB\-min_frag_duration\fR \fIduration\fR" 4
.IX Item "-min_frag_duration duration"
Don't create fragments dat is shorta than \fIduration\fR microsecondz long.
.PP
If mo' than one condizzle is specified, fragments is cut when
one of tha specified conditions is fulfilled. Y'all KNOW dat shit, muthafucka! Da exception ta dis is
\&\f(CW\*(C`\-min_frag_duration\*(C'\fR, which has ta be fulfilled fo' any of tha other
conditions ta apply.
.PP
Additionally, tha way tha output file is freestyled can be adjusted
all up in all dem other options:
.IP "\fB\-movflags empty_moov\fR" 4
.IX Item "-movflags empty_moov"
Write a initial moov atom directly all up in tha start of tha file, without
describin any samplez up in dat shit. Generally, a mdat/moov pair is written
at tha start of tha file, as a aiiight \s-1MOV/MP4\s0 file, containin only
a short portion of tha file. With dis option set, there is no initial
mdat atom, n' tha moov atom only raps bout tha tracks but has
a zero duration.
.Sp
Filez freestyled wit dis option set do not work up in QuickTime.
This option is implicitly set when freestylin ismv (Smooth Streaming) files.
.IP "\fB\-movflags separate_moof\fR" 4
.IX Item "-movflags separate_moof"
Write a separate moof (movie fragment) atom fo' each track. Normally,
packets fo' all tracks is freestyled up in a moof atom (which is slightly
more efficient) yo, but wit dis option set, tha muxer writes one moof/mdat
pair fo' each track, makin it easier ta separate tracks.
.Sp
This option is implicitly set when freestylin ismv (Smooth Streaming) files.
.IP "\fB\-movflags faststart\fR" 4
.IX Item "-movflags faststart"
Run a second pass movin tha index (moov atom) ta tha beginnin of tha file.
This operation can take a while, n' aint gonna work up in various thangs such
as fragmented output, thus it aint enabled by default.
.IP "\fB\-movflags rtphint\fR" 4
.IX Item "-movflags rtphint"
Add \s-1RTP\s0 hintin tracks ta tha output file.
.PP
Smooth Streamin content can be pushed up in real time ta a publishing
point on \s-1IIS\s0 wit dis muxer n' shit. Example:
.PP
.Vb 1
\&        ffmpeg \-re <<normal input/transcodin options>> \-movflags isml+frag_keyframe \-f ismv http://server/publishingpoint.isml/Streams(Encoder1)
.Ve
.SS "mp3"
.IX Subsection "mp3"
Da \s-1MP3\s0 muxer writes a raw \s-1MP3\s0 stream wit a ID3v2 header all up in tha beginnin and
optionally a ID3v1 tag all up in tha end yo, but it ain't no stoppin cause I be still poppin'. ID3v2.3 n' ID3v2.4 is supported, the
\&\f(CW\*(C`id3v2_version\*(C'\fR option controls which one is used. Y'all KNOW dat shit, muthafucka! Da legacy ID3v1 tag is
not freestyled by default yo, but may be enabled wit tha \f(CW\*(C`write_id3v1\*(C'\fR option.
.PP
For seekable output tha muxer also writes a Xin frame all up in tha beginning, which
gotz nuff tha number of frames up in tha file. Well shiiiit, it is useful fo' computin duration
of \s-1VBR\s0 files.
.PP
Da muxer supports freestylin ID3v2 attached pictures (\s-1APIC\s0 frames). Da pictures
are supplied ta tha muxer up in form of a vizzle stream wit a single packet. There
can be any number of dem streams, each will correspond ta a single \s-1APIC\s0 frame.
Da stream metadata tags \fItitle\fR n' \fIcomment\fR map ta \s-1APIC
\&\s0\fIdescription\fR n' \fIpicture type\fR respectively. Right back up in yo muthafuckin ass. See
<\fBhttp://id3.org/id3v2.4.0\-frames\fR> fo' allowed picture types.
.PP
Note dat tha \s-1APIC\s0 frames must be freestyled all up in tha beginning, so tha muxer will
buffer tha audio frames until it gets all tha pictures. Well shiiiit, it is therefore advised
to provide tha pictures quicker than a muthafucka ta avoid excessive buffering.
.PP
Examples:
.PP
Write a mp3 wit a ID3v2.3 header n' a ID3v1 footer:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-id3v2_version 3 \-write_id3v1 1 out.mp3
.Ve
.PP
To attach a picture ta a mp3 file select both tha audio n' tha picture stream
with \f(CW\*(C`map\*(C'\fR:
.PP
.Vb 2
\&        ffmpeg \-i input.mp3 \-i cover.png \-c copy \-map 0 \-map 1
\&        \-metadata:s:v title="Album cover" \-metadata:s:v comment="Cover (Front)" out.mp3
.Ve
.SS "mpegts"
.IX Subsection "mpegts"
\&\s-1MPEG\s0 transhiznit stream muxer.
.PP
This muxer implements \s-1ISO 13818\-1\s0 n' part of \s-1ETSI EN 300 468.\s0
.PP
Da muxer options are:
.IP "\fB\-mpegts_original_network_id\fR \fInumber\fR" 4
.IX Item "-mpegts_original_network_id number"
Set tha original_network_id (default 0x0001). This is unique identifier
of a network up in \s-1DVB.\s0 Its main use is up in tha unique identification of a
service all up in tha path Original_Network_ID, Transport_Stream_ID.
.IP "\fB\-mpegts_transport_stream_id\fR \fInumber\fR" 4
.IX Item "-mpegts_transport_stream_id number"
Set tha transport_stream_id (default 0x0001). This identifies a
transponder up in \s-1DVB.\s0
.IP "\fB\-mpegts_service_id\fR \fInumber\fR" 4
.IX Item "-mpegts_service_id number"
Set tha service_id (default 0x0001) also known as program up in \s-1DVB.\s0
.IP "\fB\-mpegts_pmt_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_pmt_start_pid number"
Set tha straight-up original gangsta \s-1PID\s0 fo' \s-1PMT \s0(default 0x1000, max 0x1f00).
.IP "\fB\-mpegts_start_pid\fR \fInumber\fR" 4
.IX Item "-mpegts_start_pid number"
Set tha straight-up original gangsta \s-1PID\s0 fo' data packets (default 0x0100, max 0x0f00).
.IP "\fB\-mpegts_m2ts_mode\fR \fInumber\fR" 4
.IX Item "-mpegts_m2ts_mode number"
Enable m2ts mode if set ta 1. Default value is \-1 which disablez m2ts mode.
.IP "\fB\-muxrate\fR \fInumber\fR" 4
.IX Item "-muxrate number"
Set muxrate.
.IP "\fB\-pes_payload_size\fR \fInumber\fR" 4
.IX Item "-pes_payload_size number"
Set minimum \s-1PES\s0 packet payload up in bytes.
.IP "\fB\-mpegts_flags\fR \fIflags\fR" 4
.IX Item "-mpegts_flags flags"
Set flags (see below).
.IP "\fB\-mpegts_copyts\fR \fInumber\fR" 4
.IX Item "-mpegts_copyts number"
Preserve original gangsta timestamps, if value is set ta 1. Default value is \-1, which
results up in shiftin timestamps so dat they start from 0.
.IP "\fB\-tables_version\fR \fInumber\fR" 4
.IX Item "-tables_version number"
Set \s-1PAT, PMT\s0 n' \s-1SDT\s0 version (default 0, valid joints is from 0 ta 31, inclusively).
This option allows uppimpin stream structure so dat standard thug may
detect tha chizzle. To do so, reopen output AVFormatContext (in case of \s-1API\s0
usage) or restart ffmpeg instance, cyclically changin tables_version value:
.Sp
.Vb 7
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
\&        ffmpeg \-i source3.ts \-codec copy \-f mpegts \-tables_version 31 udp://1.1.1.1:1111
\&        ffmpeg \-i source1.ts \-codec copy \-f mpegts \-tables_version 0 udp://1.1.1.1:1111
\&        ffmpeg \-i source2.ts \-codec copy \-f mpegts \-tables_version 1 udp://1.1.1.1:1111
\&        ...
.Ve
.PP
Option mpegts_flags may take a set of such flags:
.IP "\fBresend_headers\fR" 4
.IX Item "resend_headers"
Reemit \s-1PAT/PMT\s0 before freestylin tha next packet.
.IP "\fBlatm\fR" 4
.IX Item "latm"
Use \s-1LATM\s0 packetization fo' \s-1AAC.\s0
.PP
Da recognized metadata settings up in mpegts muxer is \f(CW\*(C`service_provider\*(C'\fR
and \f(CW\*(C`service_name\*(C'\fR. If they is not set tha default for
\&\f(CW\*(C`service_provider\*(C'\fR is \*(L"FFmpeg\*(R" n' tha default for
\&\f(CW\*(C`service_name\*(C'\fR is \*(L"Service01\*(R".
.PP
.Vb 9
\&        ffmpeg \-i file.mpg \-c copy \e
\&             \-mpegts_original_network_id 0x1122 \e
\&             \-mpegts_transport_stream_id 0x3344 \e
\&             \-mpegts_service_id 0x5566 \e
\&             \-mpegts_pmt_start_pid 0x1500 \e
\&             \-mpegts_start_pid 0x150 \e
\&             \-metadata service_provider="Some provider" \e
\&             \-metadata service_name="Some Channel" \e
\&             \-y out.ts
.Ve
.SS "null"
.IX Subsection "null"
Null muxer.
.PP
This muxer do not generate any output file, it is mainly useful for
testin or benchmarkin purposes.
.PP
For example ta benchmark decodin wit \fBffmpeg\fR you can use the
command:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null out.null
.Ve
.PP
Note dat tha above command do not read or write tha \fIout.null\fR
file yo, but specifyin tha output file is required by tha \fBffmpeg\fR
syntax.
.PP
Alternatively you can write tha command as:
.PP
.Vb 1
\&        ffmpeg \-benchmark \-i INPUT \-f null \-
.Ve
.SS "ogg"
.IX Subsection "ogg"
Ogg container muxer.
.IP "\fB\-page_duration\fR \fIduration\fR" 4
.IX Item "-page_duration duration"
Preferred page duration, up in microseconds. Da muxer will attempt ta create
pages dat is approximately \fIduration\fR microsecondz long. This allows the
user ta compromise between seek granularitizzle n' container overhead. Y'all KNOW dat shit, muthafucka! Da default
is 1 second. Y'all KNOW dat shit, muthafucka! A value of 0 will fill all segments, makin pages as big-ass as
possible fo' realz. A value of 1 will effectively use 1 packet-per-page up in most
situations, givin a lil' small-ass seek granularitizzle all up in tha cost of additionizzle container
overhead.
.SS "segment, stream_segment, ssegment"
.IX Subsection "segment, stream_segment, ssegment"
Basic stream segmenter.
.PP
Da segmenta muxer outputs streams ta a fuckin shitload of separate filez of nearly
fixed duration. I aint talkin' bout chicken n' gravy biatch. Output filename pattern can be set up in a gangbangin' fashizzle similar to
image2.
.PP
\&\f(CW\*(C`stream_segment\*(C'\fR be a variant of tha muxer used ta write to
streamin output formats, i.e. which do not require global headers,
and is recommended fo' outputtin e.g. ta \s-1MPEG\s0 transhiznit stream segments.
\&\f(CW\*(C`ssegment\*(C'\fR be a gangbangin' finger-lickin' dirty-ass shorta alias fo' \f(CW\*(C`stream_segment\*(C'\fR.
.PP
Every segment starts wit a keyframe of tha selected reference stream,
which is set all up in tha \fBreference_stream\fR option.
.PP
Note dat if you want accurate splittin fo' a vizzle file, you need to
make tha input key frames correspond ta tha exact splittin times
expected by tha segmenter, or tha segment muxer will start tha new
segment wit tha key frame found next afta tha specified start
time.
.PP
Da segment muxer works dopest wit a single constant frame rate vizzle.
.PP
Optionally it can generate a list of tha pimped segments, by setting
the option \fIsegment_list\fR. Da list type is specified by the
\&\fIsegment_list_type\fR option.
.PP
Da segment muxer supports tha followin options:
.IP "\fBreference_stream\fR \fIspecifier\fR" 4
.IX Item "reference_stream specifier"
Set tha reference stream, as specified by tha strang \fIspecifier\fR.
If \fIspecifier\fR is set ta \f(CW\*(C`auto\*(C'\fR, tha reference is chizzlen
automatically. Otherwise it must be a stream specifier (see tha ``Stream
specifiers'' chapta up in tha ffmpeg manual) which specifies the
reference stream. Da default value is \f(CW\*(C`auto\*(C'\fR.
.IP "\fBsegment_format\fR \fIformat\fR" 4
.IX Item "segment_format format"
Override tha inner container format, by default it is guessed by tha filename
extension.
.IP "\fBsegment_list\fR \fIname\fR" 4
.IX Item "segment_list name"
Generate also a listfile named \fIname\fR. If not specified no
listfile is generated.
.IP "\fBsegment_list_flags\fR \fIflags\fR" 4
.IX Item "segment_list_flags flags"
Set flags affectin tha segment list generation.
.Sp
It currently supports tha followin flags:
.RS 4
.IP "\fBcache\fR" 4
.IX Item "cache"
Allow cachin (only affects M3U8 list files).
.IP "\fBlive\fR" 4
.IX Item "live"
Allow live-friendly file generation.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`samp\*(C'\fR.
.RE
.IP "\fBsegment_list_size\fR \fIsize\fR" 4
.IX Item "segment_list_size size"
Update tha list file so dat it gotz nuff at most tha last \fIsize\fR
segments, n' you can put dat on yo' toast. If 0 tha list file will contain all tha segments, n' you can put dat on yo' toast. Default
value is 0.
.IP "\fBsegment_list_type\fR \fItype\fR" 4
.IX Item "segment_list_type type"
Specify tha format fo' tha segment list file.
.Sp
Da followin joints is recognized:
.RS 4
.IP "\fBflat\fR" 4
.IX Item "flat"
Generate a gangbangin' flat list fo' tha pimped segments, one segment per line.
.IP "\fBcsv, ext\fR" 4
.IX Item "csv, ext"
Generate a list fo' tha pimped segments, one segment per line,
each line matchin tha format (comma-separated joints):
.Sp
.Vb 1
\&        <segment_filename>,<segment_start_time>,<segment_end_time>
.Ve
.Sp
\&\fIsegment_filename\fR is tha name of tha output file generated by the
muxer accordin ta tha provided pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. \s-1CSV\s0 escapin (accordin to
\&\s-1RFC4180\s0) be applied if required.
.Sp
\&\fIsegment_start_time\fR n' \fIsegment_end_time\fR specify
the segment start n' end time expressed up in seconds.
.Sp
A list file wit tha suffix \f(CW".csv"\fR or \f(CW".ext"\fR will
auto-select dis format.
.Sp
\&\fBext\fR is deprecated up in favor or \fBcsv\fR.
.IP "\fBffconcat\fR" 4
.IX Item "ffconcat"
Generate a ffconcat file fo' tha pimped segments, n' you can put dat on yo' toast. Da resultin file
can be read rockin tha FFmpeg concat demuxer.
.Sp
A list file wit tha suffix \f(CW".ffcat"\fR or \f(CW".ffconcat"\fR will
auto-select dis format.
.IP "\fBm3u8\fR" 4
.IX Item "m3u8"
Generate a extended M3U8 file, version 3, compliant with
<\fBhttp://tools.ietf.org/id/draft\-pantos\-http\-live\-streaming\fR>.
.Sp
A list file wit tha suffix \f(CW".m3u8"\fR will auto-select dis format.
.RE
.RS 4
.Sp
If not specified tha type is guessed from tha list file name suffix.
.RE
.IP "\fBsegment_time\fR \fItime\fR" 4
.IX Item "segment_time time"
Set segment duration ta \fItime\fR, tha value must be a thugged-out duration
specification. I aint talkin' bout chicken n' gravy biatch. Default value is \*(L"2\*(R". Right back up in yo muthafuckin ass. See also the
\&\fBsegment_times\fR option.
.Sp
Note dat splittin may not be accurate, unless you force the
reference stream key-frames all up in tha given time. Right back up in yo muthafuckin ass. See tha introductory
notice n' tha examplez below.
.IP "\fBsegment_time_delta\fR \fIdelta\fR" 4
.IX Item "segment_time_delta delta"
Specify tha accuracy time when selectin tha start time fo' a
segment, expressed as a thugged-out duration justification. I aint talkin' bout chicken n' gravy biatch. Default value is \*(L"0\*(R".
.Sp
When delta is specified a key-frame will start a freshly smoked up segment if its
\&\s-1PTS\s0 satisfies tha relation:
.Sp
.Vb 1
\&        PTS >= start_time \- time_delta
.Ve
.Sp
This option is useful when splittin vizzle content, which be always
split at \s-1GOP\s0 boundaries, up in case a key frame is found just before the
specified split time.
.Sp
In particular may be used up in combination wit tha \fIffmpeg\fR option
\&\fIforce_key_frames\fR. Da key frame times specified by
\&\fIforce_key_frames\fR may not be set accurately cuz of rounding
issues, wit tha consequence dat a key frame time may result set just
before tha specified time. For constant frame rate vizzlez a value of
1/2*\fIframe_rate\fR should address da most thugged-out shitty case mismatch between
the specified time n' tha time set by \fIforce_key_frames\fR.
.IP "\fBsegment_times\fR \fItimes\fR" 4
.IX Item "segment_times times"
Specify a list of split points, n' you can put dat on yo' toast. \fItimes\fR gotz nuff a list of comma
separated duration justifications, up in increasin order n' shit. Right back up in yo muthafuckin ass. See also
the \fBsegment_time\fR option.
.IP "\fBsegment_frames\fR \fIframes\fR" 4
.IX Item "segment_frames frames"
Specify a list of split vizzle frame numbers. \fIframes\fR gotz nuff a
list of comma separated integer numbers, up in increasin order.
.Sp
This option specifies ta start a freshly smoked up segment whenever a reference
stream key frame is found n' tha sequential number (startin from 0)
of tha frame is pimped outa or equal ta tha next value up in tha list.
.IP "\fBsegment_wrap\fR \fIlimit\fR" 4
.IX Item "segment_wrap limit"
Wrap round segment index once it reaches \fIlimit\fR.
.IP "\fBsegment_start_number\fR \fInumber\fR" 4
.IX Item "segment_start_number number"
Set tha sequence number of tha straight-up original gangsta segment. Defaults ta \f(CW0\fR.
.IP "\fBreset_timestamps\fR \fI1|0\fR" 4
.IX Item "reset_timestamps 1|0"
Reset timestamps all up in tha begin of each segment, so dat each segment
will start wit near-zero timestamps. Well shiiiit, it is meant ta ease tha playback
of tha generated segments, n' you can put dat on yo' toast. May not work wit some combinations of
muxers/codecs. Well shiiiit, it is set ta \f(CW0\fR by default.
.IP "\fBinitial_offset\fR \fIoffset\fR" 4
.IX Item "initial_offset offset"
Specify timestamp offset ta apply ta tha output packet timestamps. The
argument must be a time duration justification, n' defaults ta 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
To remux tha content of file \fIin.mkv\fR ta a list of segments
\&\fIout\-000.nut\fR, \fIout\-001.nut\fR, etc., n' write tha list of
generated segments ta \fIout.list\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.list out%03d.nut
.Ve
.IP "\(bu" 4
As tha example above yo, but segment tha input file accordin ta tha split
points specified by tha \fIsegment_times\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 out%03d.nut
.Ve
.IP "\(bu" 4
As tha example above yo, but use tha \fBffmpeg\fR \fBforce_key_frames\fR
option ta force key frames up in tha input all up in tha specified location, together
with tha segment option \fBsegment_time_delta\fR ta account for
possible roundings operated when settin key frame times.
.Sp
.Vb 2
\&        ffmpeg \-i in.mkv \-force_key_frames 1,2,3,5,8,13,21 \-codec:v mpeg4 \-codec:a pcm_s16le \-map 0 \e
\&        \-f segment \-segment_list out.csv \-segment_times 1,2,3,5,8,13,21 \-segment_time_delta 0.05 out%03d.nut
.Ve
.Sp
In order ta force key frames on tha input file, transcodin is
required.
.IP "\(bu" 4
Segment tha input file by splittin tha input file accordin ta the
frame numbers sequence specified wit tha \fBsegment_frames\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list out.csv \-segment_frames 100,200,300,500,800 out%03d.nut
.Ve
.IP "\(bu" 4
To convert tha \fIin.mkv\fR ta \s-1TS\s0 segments rockin tha \f(CW\*(C`libx264\*(C'\fR
and \f(CW\*(C`libfaac\*(C'\fR encoders:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-map 0 \-codec:v libx264 \-codec:a libfaac \-f ssegment \-segment_list out.list out%03d.ts
.Ve
.IP "\(bu" 4
Segment tha input file, n' create a M3U8 live playlist (can be used
as live \s-1HLS\s0 source):
.Sp
.Vb 2
\&        ffmpeg \-re \-i in.mkv \-codec copy \-map 0 \-f segment \-segment_list playlist.m3u8 \e
\&        \-segment_list_flags +live \-segment_time 10 out%03d.mkv
.Ve
.SS "tee"
.IX Subsection "tee"
Da tee muxer can be used ta write tha same data ta nuff muthafuckin filez or any
other kind of muxer n' shit. Well shiiiit, it can be used, fo' example, ta both stream a vizzle to
the network n' save it ta disk all up in tha same time.
.PP
It be different from specifyin nuff muthafuckin outputs ta tha \fBffmpeg\fR
command-line tool cuz tha audio n' vizzle data is ghon be encoded only once
with tha tee muxer; encodin can be a straight-up high-rollin' process. Well shiiiit, it is not
useful when rockin tha libavformat \s-1API\s0 directly cuz it is then possible
to feed tha same packets ta nuff muthafuckin muxers directly.
.PP
Da slave outputs is specified up in tha file name given ta tha muxer,
separated by '|'. If any of tha slave name gotz nuff tha '|' separator,
leadin or trailin spaces or any special character, it must be
escaped (see tha ``Quotin n' escaping'' section up in tha ffmpeg-utils
manual).
.PP
Muxer options can be specified fo' each slave by prependin dem as a list of
\&\fIkey\fR=\fIvalue\fR pairs separated by ':', between square brackets, n' you can put dat on yo' toast. If
the options joints contain a special characta or tha ':' separator, they
must be escaped; note dat dis be a second level escaping.
.PP
Da followin special options is also recognized:
.IP "\fBf\fR" 4
.IX Item "f"
Specify tha format name. Useful if it cannot be guessed from the
output name suffix.
.IP "\fBbsfs[/\fR\fIspec\fR\fB]\fR" 4
.IX Item "bsfs[/spec]"
Specify a list of bitstream filtas ta apply ta tha specified
output. Well shiiiit, it is possible ta specify ta which streams a given bitstream
filta applies, by appendin a stream specifier ta tha option
separated by \f(CW\*(C`/\*(C'\fR. If tha stream specifier aint specified, the
bistream filtas is ghon be applied ta all streams up in tha output.
.Sp
Several bitstream filtas can be specified, separated by \*(L",\*(R".
.IP "\fBselect\fR" 4
.IX Item "select"
Select tha streams dat should be mapped ta tha slave output,
specified by a stream specifier n' shit. If not specified, dis defaults to
all tha input streams.
.PP
Some examplez follow.
.IP "\(bu" 4
Encode suttin' n' both archive it up in a WebM file n' stream it
as MPEG-TS over \s-1UDP \s0(the streams need ta be explicitly mapped):
.Sp
.Vb 2
\&        ffmpeg \-i ... \-c:v libx264 \-c:a mp2 \-f tee \-map 0:v \-map 0:a
\&          "archive\-20121107.mkv|[f=mpegts]udp://10.0.1.255:1234/"
.Ve
.IP "\(bu" 4
Use \fBffmpeg\fR ta encode tha input, n' bust tha output
to three different destinations. Da \f(CW\*(C`dump_extra\*(C'\fR bitstream
filta is used ta add extradata shiznit ta all tha output vizzle
keyframes packets, as axed by tha MPEG-TS format. Da select
option be applied ta \fIout.aac\fR up in order ta make it contain only
audio packets.
.Sp
.Vb 2
\&        ffmpeg \-i ... \-map 0 \-flags +global_header \-c:v libx264 \-c:a aac \-strict experimental
\&               \-f tee "[bsfs/v=dump_extra]out.ts|[movflags=+faststart]out.mp4|[select=a]out.aac"
.Ve
.PP
Note: some codecs may need different options dependin on tha output format;
the auto-detection of dis can not work wit tha tee muxer n' shit. Da main example
is tha \fBglobal_header\fR flag.
.SH "METADATA"
.IX Header "METADATA"
FFmpeg be able ta dump metadata from media filez tha fuck into a simple UTF\-8\-encoded
INI-like text file n' then load it back rockin tha metadata muxer/demuxer.
.PP
Da file format be as bigs up:
.IP "1." 4
A file consistz of a header n' a fuckin shitload of metadata tags divided tha fuck into sections,
each on its own line.
.IP "2." 4
Da header be a ';FFMETADATA' string, followed by a version number (now 1).
.IP "3." 4
Metadata tags iz of tha form 'key=value'
.IP "4." 4
Immediately afta header bigs up global metadata
.IP "5." 4
Afta global metadata there may be sections wit per\-stream/per\-chapter
metadata.
.IP "6." 4
A section starts wit tha section name up in uppercase (i.e. \s-1STREAM\s0 or \s-1CHAPTER\s0) in
brackets ('[', ']') n' endz wit next section or end of file.
.IP "7." 4
At tha beginnin of a cold-ass lil chapta section there may be a optionizzle timebase ta be
used fo' start/end joints, n' you can put dat on yo' toast. Well shiiiit, it must be up in form 'TIMEBASE=num/den', where num and
den is integers. If tha timebase is missin then start/end times is assumed to
be up in milliseconds.
Next a cold-ass lil chapta section must contain chapta start n' end times up in form
\&'START=num', 'END=num', where num be a positizzle integer.
.IP "8." 4
Empty lines n' lines startin wit ';' or '#' is ignored.
.IP "9." 4
Metadata keys or joints containin special charactas ('=', ';', '#', '\e' n' a
newline) must be escaped wit a funky-ass backslash '\e'.
.IP "10." 4
Note dat whitespace up in metadata (e.g. foo = bar) is considered ta be a part of
the tag (in tha example above key is 'foo ', value is ' bar').
.PP
A ffmetadata file might be lookin like this:
.PP
.Vb 4
\&        ;FFMETADATA1
\&        title=bike\e\eshed
\&        ;this be a cold-ass lil comment
\&        artist=FFmpeg troll crew
\&        
\&        [CHAPTER]
\&        TIMEBASE=1/1000
\&        START=0
\&        #chapta endz at 0:01:00
\&        END=60000
\&        title=chapta \e#1
\&        [STREAM]
\&        title=multi\e
\&        line
.Ve
.PP
By rockin tha ffmetadata muxer n' demuxer it is possible ta extract
metadata from a input file ta a ffmetadata file, n' then transcode
the file tha fuck into a output file wit tha edited ffmetadata file.
.PP
Extractin a ffmetadata file wit \fIffmpeg\fR goes as bigs up:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-f ffmetadata FFMETADATAFILE
.Ve
.PP
Reinsertin edited metadata shiznit from tha \s-1FFMETADATAFILE\s0 file can
be done as:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-i FFMETADATAFILE \-map_metadata 1 \-codec copy OUTPUT
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavformat\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
