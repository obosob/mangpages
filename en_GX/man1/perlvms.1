.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLVMS 1"
.TH PERLVMS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlvms \- VMS\-specific documentation fo' Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Gathered below is notes describin detailz of Perl 5z 
behavior on \s-1VMS. \s0 They is a supplement ta tha regular Perl 5 
documentation, so our crazy asses have focussed on tha ways up in which Perl 
5 functions differently under \s-1VMS\s0 than it do under Unix, 
and on tha interactions between Perl n' tha rest of tha 
operatin system.  We aint tried ta duplicate complete 
descriptionz of Perl features from tha main Perl 
documentation, which can be found up in tha \fI[.pod]\fR 
subdirectory of tha Perl distribution.
.PP
Our thugged-out asses hope these notes will save you from mad drama n' lost 
sleep when freestylin Perl scripts on \s-1VMS. \s0 If you find we've 
missed suttin' you be thinkin should step tha fuck up here, please don't 
hesitate ta drop a line ta vmsperl@perl.org.
.SH "Installation"
.IX Header "Installation"
Directions fo' buildin n' installin Perl 5 can be found up in 
the file \fI\s-1README\s0.vms\fR up in tha main source directory of tha 
Perl distribution..
.SH "Organization of Perl Images"
.IX Header "Organization of Perl Images"
.SS "Core Images"
.IX Subsection "Core Images"
Durin tha installation process, three Perl images is produced.
\&\fIMiniperl.Exe\fR be a executable image which gotz nuff all of
the basic functionalitizzle of Perl yo, but cannot take advantage of
Perl extensions.  It be used ta generate nuff muthafuckin filez needed
to build tha complete Perl n' various extensions.  Once you've
finished installin Perl, you can delete dis image.
.PP
Most of tha complete Perl resides up in tha shareable image
\&\fIPerlShr.Exe\fR, which serves up a cold-ass lil core ta which tha Perl executable
image n' all Perl extensions is linked. Y'all KNOW dat shit, muthafucka!  Yo ass should place this
image up in \fISys$Share\fR, or define tha logical name \fIPerlShr\fR to
translate ta tha full file justification of dis image.  It should
be ghetto readable.  (Remember dat if a user has execute only access
to \fIPerlShr\fR, \s-1VMS\s0 will treat it as if it was a privileged shareable
image, n' will therefore require all downstream shareable images ta be
INSTALLed, etc.)
.PP
Finally, \fIPerl.Exe\fR be a executable image containin tha main
entry point fo' Perl, as well as some initialization code.  It
should be placed up in a hood directory, n' made ghetto executable.
In order ta run Perl wit command line arguments, you should
define a gangbangin' foreign command ta invoke dis image.
.SS "Perl Extensions"
.IX Subsection "Perl Extensions"
Perl extensions is packages which provide both \s-1XS\s0 n' Perl code
to add freshly smoked up functionalitizzle ta perl.  (\s-1XS\s0 be a meta-language which
simplifies freestylin C code which interacts wit Perl, see
perlxs fo' mo' details.)  Da Perl code fo' an
extension is treated like any other library module \- it's
made available up in yo' script all up in tha appropriate
\&\f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR statement, n' probably defines a Perl
package containin tha extension.
.PP
Da portion of tha extension provided by tha \s-1XS\s0 code may be
connected ta tha rest of Perl up in either of two ways.  In the
\&\fBstatic\fR configuration, tha object code fo' tha extension is
linked directly tha fuck into \fIPerlShr.Exe\fR, n' is initialized whenever
Perl is invoked. Y'all KNOW dat shit, muthafucka!  In tha \fBdynamic\fR configuration, tha extension's
machine code is placed tha fuck into a separate shareable image, which is
mapped by Perlz DynaLoader when tha extension is \f(CW\*(C`use\*(C'\fRd or
\&\f(CW\*(C`require\*(C'\fRd up in yo' script.  This allows you ta maintain the
extension as a separate entity, all up in tha cost of keepin track of the
additionizzle shareable image.  Most extensions can be set up as either
static or dynamic.
.PP
Da source code fo' a extension probably resides up in its own
directory.  At least three filez is generally provided:
\&\fIExtshortname\fR\fI.xs\fR (where \fIExtshortname\fR is tha portion of
the extensionz name followin tha last \f(CW\*(C`::\*(C'\fR), containing
the \s-1XS\s0 code, \fIExtshortname\fR\fI.pm\fR, tha Perl library module
for tha extension, n' \fIMakefile.PL\fR, a Perl script which uses
the \f(CW\*(C`MakeMaker\*(C'\fR library modulez supplied wit Perl ta generate
a \fIDescrip.MMS\fR file fo' tha extension.
.SS "Installin static extensions"
.IX Subsection "Installin static extensions"
Since static extensions is incorporated directly into
\&\fIPerlShr.Exe\fR, you gonna gotta rebuild Perl ta incorporate a
new extension. I aint talkin' bout chicken n' gravy biatch.  Yo ass should edit tha main \fIDescrip.MMS\fR or \fIMakefile\fR
you use ta build Perl, addin tha extensionz name ta tha \f(CW\*(C`ext\*(C'\fR
macro, n' tha extensionz object file ta tha \f(CW\*(C`extobj\*(C'\fR macro.
You'll also need ta build tha extensionz object file, either
by addin dependencies ta tha main \fIDescrip.MMS\fR, or rockin a
separate \fIDescrip.MMS\fR fo' tha extension. I aint talkin' bout chicken n' gravy biatch.  Then, rebuild
\&\fIPerlShr.Exe\fR ta incorporate tha freshly smoked up code.
.PP
Finally, you gonna need ta copy tha extensionz Perl library
module ta tha \fI[.\fR\fIExtname\fR\fI]\fR subdirectory under one
of tha directories up in \f(CW@INC\fR, where \fIExtname\fR is tha name
of tha extension, wit all \f(CW\*(C`::\*(C'\fR replaced by \f(CW\*(C`.\*(C'\fR (e.g.
the library module fo' extension Foo::Bar would be copied
to a \fI[.Foo.Bar]\fR subdirectory).
.SS "Installin dynamic extensions"
.IX Subsection "Installin dynamic extensions"
In general, tha distributed kit fo' a Perl extension includes
a file named Makefile.PL, which be a Perl program which is used
to create a \fIDescrip.MMS\fR file which can be used ta build and
install tha filez required by tha extension. I aint talkin' bout chicken n' gravy biatch.  Da kit should be
unpacked tha fuck into a gangbangin' finger-lickin' directory tree \fBnot\fR under tha main Perl source
directory, n' tha procedure fo' buildin tha extension is simply
.PP
.Vb 4
\&    $ perl Makefile.PL  ! Smoke Descrip.MMS
\&    $ mmk               ! Build necessary files
\&    $ mmk test          ! Run test code, if supplied
\&    $ mmk install       ! Install tha fuck into hood Perl tree
.Ve
.PP
\&\fIN.B.\fR Da procedure by which extensions is built and
tested creates nuff muthafuckin levels (at least 4) under the
directory up in which tha extensionz source filez live.
For dis reason if yo ass is hustlin a version of \s-1VMS\s0 prior
to V7.1 you shouldn't nest tha source directory
too deeply up in yo' directory structure lest you exceed \s-1RMS\s0'
maximum of 8 levelz of subdirectory up in a gangbangin' filespec.  (You
can use rooted logical names ta git another 8 levels of
nesting, if you can't place tha filez near tha top of
the physical directory structure.)
.PP
\&\s-1VMS\s0 support fo' dis process up in tha current release of Perl
is sufficient ta handle most extensions.  But fuck dat shiznit yo, tha word on tha street is dat it do
not yet recognize extra libraries required ta build shareable
images which is part of a extension, so these must be added
to tha linker options file fo' tha extension by hand. Y'all KNOW dat shit, muthafucka!  For
instance, if tha \fI\s-1PGPLOT\s0\fR extension ta Perl requires the
\&\fI\s-1PGPLOTSHR.EXE\s0\fR shareable image up in order ta properly link
the Perl extension, then tha line \f(CW\*(C`PGPLOTSHR/Share\*(C'\fR must
be added ta tha linker options file \fI\s-1PGPLOT\s0.Opt\fR produced
durin tha build process fo' tha Perl extension.
.PP
By default, tha shareable image fo' a extension is placed in
the \fI[.lib.site_perl.auto\fR\fIArch\fR.\fIExtname\fR\fI]\fR directory of the
installed Perl directory tree (where \fIArch\fR is \fI\s-1VMS_VAX\s0\fR or
\&\fI\s-1VMS_AXP\s0\fR, n' \fIExtname\fR is tha name of tha extension, with
each \f(CW\*(C`::\*(C'\fR translated ta \f(CW\*(C`.\*(C'\fR).  (See tha MakeMaker documentation
for mo' details on installation options fo' extensions.)
But fuck dat shiznit yo, tha word on tha street is dat it can be manually placed up in any of nuff muthafuckin locations:
.IP "\(bu" 4
the \fI[.Lib.Auto.\fR\fIArch\fR\fI\f(CI$PVers\fI\fR\fIExtname\fR\fI]\fR subdirectory
of one of tha directories up in \f(CW@INC\fR (where \fIPVers\fR
is tha version of Perl you using, as supplied up in \f(CW$]\fR,
with '.' converted ta '_'), or
.IP "\(bu" 4
one of tha directories up in \f(CW@INC\fR, or
.IP "\(bu" 4
a directory which tha extensions Perl library module
passes ta tha DynaLoader when askin it ta map
the shareable image, or
.IP "\(bu" 4
\&\fISys$Share\fR or \fISys$Library\fR.
.PP
If tha shareable image aint up in any of these places, you gonna need
to define a logical name \fIExtshortname\fR, where \fIExtshortname\fR
is tha portion of tha extensionz name afta tha last \f(CW\*(C`::\*(C'\fR, which
translates ta tha full file justification of tha shareable image.
.SH "File justifications"
.IX Header "File justifications"
.SS "Syntax"
.IX Subsection "Syntax"
Our thugged-out asses have tried ta make Perl aware of both VMS-style n' Unix-style file
specifications wherever possible.  Yo ass may use either style, or both,
on tha command line n' up in scripts yo, but you may not combine tha two
stylez within a single file justification. I aint talkin' bout chicken n' gravy biatch.  \s-1VMS\s0 Perl interprets Unix
pathnames up in much tha same way as tha \s-1CRTL \s0(\fIe.g.\fR tha straight-up original gangsta component
of a absolute path is read as tha thang name fo' tha \s-1VMS\s0 file
specification).  There is a set of functions provided up in the
\&\f(CW\*(C`VMS::Filespec\*(C'\fR package fo' explicit interconversion between \s-1VMS\s0 and
Unix syntax; its documentation serves up mo' details.
.PP
We've tried ta minimize tha dependence of Perl library
modulez on Unix syntax yo, but you may find dat a shitload of these,
as well as some scripts freestyled fo' Unix systems, will
require dat you use Unix syntax, since they will assume that
\&'/' is tha directory separator, \fIetc.\fR  If you find instances
of dis up in tha Perl distribution itself, please let our asses know,
so we can try ta work round em.
.PP
Also when hustlin on Perl programs on \s-1VMS,\s0 if you need a syntax
in a specific operatin system format, then you need either to
check tha appropriate \s-1DECC$\s0 feature logical, or call a cold-ass lil conversion
routine ta force it ta dat format.
.PP
Da feature logical name \s-1DECC$FILENAME_UNIX_REPORT\s0 modifies traditional
Perl behavior up in tha conversion of file justifications from Unix ta \s-1VMS\s0
format up in order ta follow tha extended characta handlin rulez now
expected by tha \s-1CRTL. \s0 Specifically, when dis feature is up in effect, the
\&\f(CW\*(C`./.../\*(C'\fR up in a Unix path is now translated ta \f(CW\*(C`[.^.^.^.]\*(C'\fR instead of
the traditionizzle \s-1VMS \s0\f(CW\*(C`[...]\*(C'\fR.  To be compatible wit what tha fuck MakeMaker
expects, if a \s-1VMS\s0 path cannot be translated ta a Unix path, it is
passed all up in unchanged, so \f(CW\*(C`unixify("[...]")\*(C'\fR will return \f(CW\*(C`[...]\*(C'\fR.
.PP
Da handlin of extended charactas is largely complete up in the
VMS-specific C infrastructure of Perl yo, but mo' work is still needed to
fully support extended syntax filenames up in nuff muthafuckin core modules.  In
particular, at dis freestylin PathTools has only partial support for
directories containin some extended characters.
.PP
There is nuff muthafuckin ambiguous cases where a cold-ass lil conversion routine cannot
determine whether a input filename is up in Unix format or up in \s-1VMS\s0 format,
since now both \s-1VMS\s0 n' Unix file justifications may have charactas in
them dat could be mistaken fo' syntax delimitaz of tha other type. Right back up in yo muthafuckin ass. So
some pathnames simply cannot be used up in a mode dat allows either type
of pathname ta be present.  Perl will tend ta assume dat a ambiguous
filename is up in Unix format.
.PP
Allowin \*(L".\*(R" as a version delimita is simply incompatible with
determinin whether a pathname is up in \s-1VMS\s0 format or up in Unix format with
extended file syntax.  There is no way ta know whether \*(L"perl\-5.8.6\*(R" be a
Unix \*(L"perl\-5.8.6\*(R" or a \s-1VMS \s0\*(L"perl\-5.8;6\*(R" when passin it ta \fIunixify()\fR or
\&\fIvmsify()\fR.
.PP
Da \s-1DECC$FILENAME_UNIX_REPORT\s0 logical name controls how tha fuck Perl interprets
filenames ta tha extent dat Perl uses tha \s-1CRTL\s0 internally fo' many
purposes, n' attempts ta follow \s-1CRTL\s0 conventions fo' reporting
filenames.  Da \s-1DECC$FILENAME_UNIX_ONLY\s0 feature differs up in dat it
expects all filenames passed ta tha C run-time ta be already up in Unix
format.  This feature aint yet supported up in Perl since Perl uses
traditionizzle OpenVMS file justifications internally n' up in tha test
harness, n' it aint yet clear whether dis mode is ghon be useful or
useable.  Da feature logical name \s-1DECC$POSIX_COMPLIANT_PATHNAMES\s0 is new
with tha \s-1RMS\s0 Symbolic Link \s-1SDK\s0 n' included wit OpenVMS v8.3 yo, but is
not yet supported up in Perl.
.SS "Filename Case"
.IX Subsection "Filename Case"
Perl bigs up \s-1VMS\s0 defaults n' override settings up in preservin (or not
preserving) filename case.  Case aint preserved on \s-1ODS\-2\s0 formatted
volumes on any architecture.  On \s-1ODS\-5\s0 volumes, filenames may be case
preserved dependin on process n' feature settings.  Perl now honors
\&\s-1DECC$EFS_CASE_PRESERVE\s0 n' \s-1DECC$ARGV_PARSE_STYLE\s0 on dem systems where
the \s-1CRTL\s0 supports these features.  When these features is not enabled
or tha \s-1CRTL\s0 do not support them, Perl bigs up tha traditionizzle \s-1CRTL\s0
behavior of downcasin command-line arguments n' returnin file
specifications up in lower case only.
.PP
\&\fIN. B.\fR  It be straight-up easy as fuck  ta git tripped up rockin a mixture of other
programs, external utilities, n' Perl scripts dat is up in varying
statez of bein able ta handle case preservation. I aint talkin' bout chicken n' gravy biatch.  For example, a gangbangin' file
created by a olda version of a archive utilitizzle or a funky-ass build utility
like fuckin \s-1MMK\s0 or \s-1MMS\s0 may generate a gangbangin' filename up in all upper case even on an
\&\s-1ODS\-5\s0 volume.  If dis filename is lata retrieved by a Perl script or
module up in a cold-ass lil case preservin environment, dat upper case name may not
match tha mixed-case or lower-case exceptionz of tha Perl code.  Your
best bet is ta follow a all-or-nothang approach ta case preservation:
either don't use it at all, or make shizzle yo' entire toolchain and
application environment support n' use dat shit.
.PP
OpenVMS Alpha v7.3\-1 n' lata n' all version of OpenVMS I64 support
case sensitivitizzle as a process settin (see \f(CW\*(C`SET PROCESS
/CASE_LOOKUP=SENSITIVE\*(C'\fR). Perl do not currently support case
sensitivitizzle on \s-1VMS,\s0 but it may up in tha future, so Perl programs should
use tha \f(CW\*(C`File::Spec\->case_tolerant\*(C'\fR method ta determine tha state, and
not tha \f(CW$^O\fR variable.
.SS "Symbolic Links"
.IX Subsection "Symbolic Links"
When built on a \s-1ODS\-5\s0 volume wit symbolic links enabled, Perl by
default supports symbolic links when tha requisite support be available
in tha filesystem n' \s-1CRTL \s0(generally 64\-bit OpenVMS v8.3 n' later). 
There is a fuckin shitload of limitations n' caveats ta be aware of when
workin wit symbolic links on \s-1VMS. \s0 Most notably, tha target of a valid
symbolic link must be expressed as a Unix-style path n' it must exist
on a volume visible from yo' \s-1POSIX\s0 root (see tha \f(CW\*(C`SHOW ROOT\*(C'\fR command
in \s-1DCL\s0 help).  For further details on symbolic link capabilitizzles and
requirements, peep chapta 12 of tha \s-1CRTL\s0 manual dat ships wit OpenVMS
v8.3 or later.
.SS "Wildcard expansion"
.IX Subsection "Wildcard expansion"
File justifications containin wildcardz is allowed both on 
the command line n' within Perl globs (e.g. \f(CW\*(C`<*.c>\*(C'\fR).  If
the wildcard filespec uses \s-1VMS\s0 syntax, tha resultant 
filespecs will follow \s-1VMS\s0 syntax; if a Unix-style filespec is 
passed in, Unix-style filespecs is ghon be returned.
Similar ta tha behavior of wildcard globbin fo' a Unix shell,
one can escape command line wildcardz wit double quotation
marks \f(CW\*(C`"\*(C'\fR round a perl program command line argument.  However,
owin ta tha strippin of \f(CW\*(C`"\*(C'\fR charactas carried up by tha C
handlin of argv yo big-ass booty is ghon need ta escape a cold-ass lil construct such as
this one (in a gangbangin' finger-lickin' directory containin tha filez \fI\s-1PERL.C\s0\fR, \fI\s-1PERL.EXE\s0\fR,
\&\fI\s-1PERL.H\s0\fR, n' \fI\s-1PERL.OBJ\s0\fR):
.PP
.Vb 2
\&    $ perl \-e "print join(\*(Aq \*(Aq,@ARGV)" perl.*
\&    perl.c perl.exe perl.h perl.obj
.Ve
.PP
in tha followin triple quoted manner:
.PP
.Vb 2
\&    $ perl \-e "print join(\*(Aq \*(Aq,@ARGV)" """perl.*"""
\&    perl.*
.Ve
.PP
In both tha case of unquoted command line arguments or up in calls
to \f(CW\*(C`glob()\*(C'\fR \s-1VMS\s0 wildcard expansion is performed. Y'all KNOW dat shit, muthafucka! (csh-style
wildcard expansion be available if you use \f(CW\*(C`File::Glob::glob\*(C'\fR.)
If tha wildcard filespec gotz nuff a thang or directory 
specification, then tha resultant filespecs will also contain 
a thang n' directory; otherwise, thang n' directory 
information is removed. Y'all KNOW dat shit, muthafucka!  VMS-style resultant filespecs will 
contain a gangbangin' full thang n' directory, while Unix-style 
resultant filespecs will contain only as much of a gangbangin' finger-lickin' directory 
path as was present up in tha input filespec.  For example, if 
your default directory is Perl_Root:[000000], tha expansion 
of \f(CW\*(C`[.t]*.*\*(C'\fR will yield filespecs  like 
\&\*(L"perl_root:[t]base.dir\*(R", while tha expansion of \f(CW\*(C`t/*/*\*(C'\fR will 
yield filespecs like \*(L"t/base.dir\*(R".  (This is done ta match 
the behavior of glob expansion performed by Unix shells.)
.PP
Similarly, tha resultant filespec will contain tha file version
only if one was present up in tha input filespec.
.SS "Pipes"
.IX Subsection "Pipes"
Input n' output pipes ta Perl filehandlez is supported; tha 
\&\*(L"file name\*(R" is passed ta lib$\fIspawn()\fR fo' asynchronous 
execution. I aint talkin' bout chicken n' gravy biatch.  Yo ass should be careful ta close any pipes you have 
opened up in a Perl script, lest you leave any \*(L"orphaned\*(R" 
subprocesses round when Perl exits.
.PP
Yo ass may also use backticks ta invoke a \s-1DCL\s0 subprocess, whose 
output is used as tha return value of tha expression. I aint talkin' bout chicken n' gravy biatch.  Da 
strin between tha backticks is handled as if it was the
argument ta tha \f(CW\*(C`system\*(C'\fR operator (see below).  In dis case,
Perl will wait fo' tha subprocess ta complete before continuing.
.PP
Da mailbox (\s-1MBX\s0) dat perl can create ta rap wit a pipe
defaults ta a funky-ass buffer size of 8192 on 64\-bit systems, 512 on \s-1VAX. \s0 The
default buffer size be adjustable via tha logical name \s-1PERL_MBX_SIZE\s0
provided dat tha value falls between 128 n' tha \s-1SYSGEN\s0 parameter
\&\s-1MAXBUF\s0 inclusive.  For example, ta set tha mailbox size ta 32767 use
\&\f(CW\*(C`$ENV{\*(AqPERL_MBX_SIZE\*(Aq} = 32767;\*(C'\fR n' then open n' use pipe constructs, n' you can put dat on yo' toast. 
An alternatizzle would be ta issue tha command:
.PP
.Vb 1
\&    $ Define PERL_MBX_SIZE 32767
.Ve
.PP
before hustlin yo' wide record pipe program.  A larger value may
improve performizzle all up in tha expense of tha \s-1BYTLM UAF\s0 quota.
.SH "PERL5LIB n' PERLLIB"
.IX Header "PERL5LIB n' PERLLIB"
Da \s-1PERL5LIB\s0 n' \s-1PERLLIB\s0 logical names work as documented up in perl,
except dat tha element separator is '|' instead of ':'.  The
directory justifications may use either \s-1VMS\s0 or Unix syntax.
.SH "Da Perl Forked Debugger"
.IX Header "Da Perl Forked Debugger"
Da Perl forked debugger places tha debugger commandz n' output up in a
separate X\-11 terminal window so dat commandz n' output from multiple
processes is not mixed together.
.PP
Perl on \s-1VMS\s0 supports a emulation of tha forked debugger when Perl is
run on a \s-1VMS\s0 system dat has X11 support installed.
.PP
To use tha forked debugger, you need ta have tha default display set ta an
X\-11 Server n' some environment variablez set dat Unix expects.
.PP
Da forked debugger requires tha environment variable \f(CW\*(C`TERM\*(C'\fR ta be \f(CW\*(C`xterm\*(C'\fR,
and tha environment variable \f(CW\*(C`DISPLAY\*(C'\fR ta exist.  \f(CW\*(C`xterm\*(C'\fR must be in
lower case.
.PP
.Vb 1
\&  $define TERM "xterm"
\&
\&  $define DISPLAY "hostname:0.0"
.Ve
.PP
Currently tha value of \f(CW\*(C`DISPLAY\*(C'\fR is ignored. Y'all KNOW dat shit, muthafucka!  It be recommended dat it be set
to be tha hostname of tha display, tha server n' screen up in Unix notation. I aint talkin' bout chicken n' gravy biatch.  In
the future tha value of \s-1DISPLAY\s0 may be honored by Perl instead of rockin the
default display.
.PP
It may be helpful ta always use tha forked debugger so dat script I/O is
separated from debugger I/O.  Yo ass can force tha debugger ta be forked by
assignin a value ta tha logical name <\s-1PERLDB_PIDS\s0> dat aint a process
identification number.
.PP
.Vb 1
\&  $define PERLDB_PIDS XXXX
.Ve
.SH "PERL_VMS_EXCEPTION_DEBUG"
.IX Header "PERL_VMS_EXCEPTION_DEBUG"
Da \s-1PERL_VMS_EXCEPTION_DEBUG\s0 bein defined as \*(L"\s-1ENABLE\*(R"\s0 will cause tha \s-1VMS\s0
debugger ta be invoked if a gangbangin' fatal exception dat aint otherwise
handled is raised. Y'all KNOW dat shit, muthafucka!  Da purpose of dis is ta allow debuggin of
internal Perl problems dat would cause such a cold-ass lil condition.
.PP
This allows tha programmer ta peep tha execution stack n' variablez to
smoke up tha cause of tha exception. I aint talkin' bout chicken n' gravy biatch.  As tha debugger is bein invoked as
the Perl interpreta be bout ta do a gangbangin' fatal exit, continuin tha execution
in debug mode is probably not practical.
.PP
Startin Perl up in tha \s-1VMS\s0 debugger may chizzle tha program execution
profile up in a way dat such problems is not reproduced.
.PP
Da \f(CW\*(C`kill\*(C'\fR function can be used ta test dis functionalitizzle from within
a program.
.PP
In typical \s-1VMS\s0 style, only tha straight-up original gangsta letta of tha value of dis logical
name is straight-up checked up in a cold-ass lil case insensitizzle mode, n' it is considered
enabled if it is tha value \*(L"T\*(R",\*(L"1\*(R" or \*(L"E\*(R".
.PP
This logical name must be defined before Perl is started.
.SH "Command line"
.IX Header "Command line"
.SS "I/O redirection n' backgrounding"
.IX Subsection "I/O redirection n' backgrounding"
Perl fo' \s-1VMS\s0 supports redirection of input n' output on tha 
command line, rockin a subset of Bourne shell syntax:
.IP "\(bu" 4
\&\f(CW\*(C`<file\*(C'\fR readz stdin from \f(CW\*(C`file\*(C'\fR,
.IP "\(bu" 4
\&\f(CW\*(C`>file\*(C'\fR writes stdout ta \f(CW\*(C`file\*(C'\fR,
.IP "\(bu" 4
\&\f(CW\*(C`>>file\*(C'\fR appendz stdout ta \f(CW\*(C`file\*(C'\fR,
.IP "\(bu" 4
\&\f(CW\*(C`2>file\*(C'\fR writes stderr ta \f(CW\*(C`file\*(C'\fR,
.IP "\(bu" 4
\&\f(CW\*(C`2>>file\*(C'\fR appendz stderr ta \f(CW\*(C`file\*(C'\fR, and
.IP "\(bu" 4
\&\f(CW\*(C`2>&1\*(C'\fR redirects stderr ta stdout.
.PP
In addition, output may be piped ta a subprocess, rockin tha  
characta '|'.  Anythang afta dis characta on tha command 
line is passed ta a subprocess fo' execution; tha subprocess 
takes tha output of Perl as its input.
.PP
Finally, if tha command line endz wit '&', tha entire 
command is run up in tha background as a asynchronous 
subprocess.
.SS "Command line switches"
.IX Subsection "Command line switches"
Da followin command line switches behave differently under
\&\s-1VMS\s0 than busted lyrics bout up in perlrun. I aint talkin' bout chicken n' gravy biatch.  Note also dat up in order
to pass uppercase switches ta Perl, you need ta enclose
them up in double-quotes on tha command line, since tha \s-1CRTL\s0
downcases all unquoted strings.
.PP
On newer 64 bit versionz of OpenVMS, a process settin now
controls if tha quotin is needed ta preserve tha case of
command line arguments.
.IP "\-i" 4
.IX Item "-i"
If tha \f(CW\*(C`\-i\*(C'\fR switch is present but no extension fo' a funky-ass backup
copy is given, then inplace editin creates a freshly smoked up version of
a file; tha existin copy aint deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Note dat if
an extension is given, a existin file is renamed ta tha backup
file, as is tha case under other operatin systems, so it do
not remain as a previous version under tha original gangsta filename.)
.IP "\-S" 4
.IX Item "-S"
If tha \f(CW"\-S"\fR or \f(CW\*(C`\-"S"\*(C'\fR switch is present \fIand\fR tha script
name do not contain a gangbangin' finger-lickin' directory, then Perl translates the
logical name \s-1DCL$PATH\s0 as a searchlist, rockin each translation
as a gangbangin' finger-lickin' directory up in which ta look fo' tha script.  In addition,
if no file type is specified, Perl looks up in each directory
for a gangbangin' file matchin tha name specified, wit a funky-ass blank type,
a type of \fI.pl\fR, n' a type of \fI.com\fR, up in dat order.
.IP "\-u" 4
.IX Item "-u"
Da \f(CW\*(C`\-u\*(C'\fR switch causes tha \s-1VMS\s0 debugger ta be invoked
afta tha Perl program is compiled yo, but before it has
run. I aint talkin' bout chicken n' gravy biatch.  It do not create a cold-ass lil core dump file.
.SH "Perl functions"
.IX Header "Perl functions"
Az of tha time dis document was last revised, tha followin 
Perl functions was implemented up in tha \s-1VMS\s0 port of Perl 
(functions marked wit * is discussed up in mo' detail below):
.PP
.Vb 10
\&    file tests*, abs, alarm, atan, backticks*, binmode*, bless,
\&    caller, chdir, chmod, chown, chomp, chop, chr,
\&    close, closedir, cos, crypt*, defined, delete, die, do, dump*, 
\&    each, endgrent, endpwent, eof, eval, exec*, exists, exit, exp, 
\&    fileno, flock  getc, getgrent*, getgrgid*, getgrnam, getlogin, getppid,
\&    getpwent*, getpwnam*, getpwuid*, glob, gmtime*, goto,
\&    grep, hex, ioctl, import, index, int, join, keys, kill*,
\&    last, lc, lcfirst, lchown*, length, link*, local, localtime, log, lstat, m//,
\&    map, mkdir, my, next, no, oct, open, opendir, ord, pack,
\&    pipe, pop, pos, print, printf, push, q//, qq//, qw//,
\&    qx//*, quotemeta, rand, read, readdir, readlink*, redo, ref, rename,
\&    require, reset, return, reverse, rewinddir, rindex,
\&    rmdir, s///, scalar, seek, seekdir, select(internal),
\&    select (system call)*, setgrent, setpwent, shift, sin, chill,
\&    socketpair, sort, splice, split, sprintf, sqrt, srand, stat,
\&    study, substr, symlink*, sysread, system*, syswrite, tell,
\&    telldir, tie, time, times*, tr///, uc, ucfirst, umask,
\&    undef, unlink*, unpack, untie, unshift, use, utime*,
\&    joints, vec, wait, waitpid*, wantarray, warn, write, y///
.Ve
.PP
Da followin functions was not implemented up in tha \s-1VMS\s0 port, 
and callin dem produces a gangbangin' fatal error (usually) or 
undefined behavior (rarely, our crazy asses hope):
.PP
.Vb 4
\&    chroot, dbmclose, dbmopen, fork*, getpgrp, getpriority,  
\&    msgctl, msgget, msgsend, msgrcv, semctl,
\&    semget, semop, setpgrp, setpriority, shmctl, shmget,
\&    shmread, shmwrite, syscall
.Ve
.PP
Da followin functions is available on Perls compiled wit Dec C
5.2 or pimped outa n' hustlin \s-1VMS 7.0\s0 or pimped outer:
.PP
.Vb 1
\&    truncate
.Ve
.PP
Da followin functions is available on Perls built on \s-1VMS 7.2\s0 or
greater:
.PP
.Vb 1
\&    fcntl (without locking)
.Ve
.PP
Da followin functions may or may not be implemented, 
dependin on what tha fuck type of socket support you've built tha fuck into 
your copy of Perl:
.PP
.Vb 9
\&    accept, bind, connect, getpeername,
\&    gethostbyname, getnetbyname, getprotobyname,
\&    getservbyname, gethostbyaddr, getnetbyaddr,
\&    getprotobynumber, getservbyport, gethostent,
\&    getnetent, getprotoent, getservent, sethostent,
\&    setnetent, setprotoent, setservent, endhostent,
\&    endnetent, endprotoent, endservent, getsockname,
\&    getsockopt, listen, recv, select(system call)*,
\&    send, setsockopt, shutdown, socket
.Ve
.PP
Da followin function be available on Perls built on 64 bit OpenVMS v8.2
with hard links enabled on a \s-1ODS\-5\s0 formatted build disk.  \s-1CRTL\s0 support
is up in principle available az of OpenVMS v7.3\-1, n' betta configuration
support could detect all dis bullshit.
.PP
.Vb 1
\&    link
.Ve
.PP
Da followin functions is available on Perls built on 64 bit OpenVMS
v8.2 n' later n' shit.  \s-1CRTL\s0 support is up in principle available az of OpenVMS
v7.3\-2, n' betta configuration support could detect all dis bullshit.
.PP
.Vb 2
\&   getgrgid, getgrnam, getpwnam, getpwuid,
\&   setgrent, ttyname
.Ve
.PP
Da followin functions is available on Perls built on 64 bit OpenVMS v8.2
and later.
.PP
.Vb 1
\&   statvfs, socketpair
.Ve
.IP "File tests" 4
.IX Item "File tests"
Da tests \f(CW\*(C`\-b\*(C'\fR, \f(CW\*(C`\-B\*(C'\fR, \f(CW\*(C`\-c\*(C'\fR, \f(CW\*(C`\-C\*(C'\fR, \f(CW\*(C`\-d\*(C'\fR, \f(CW\*(C`\-e\*(C'\fR, \f(CW\*(C`\-f\*(C'\fR,
\&\f(CW\*(C`\-o\*(C'\fR, \f(CW\*(C`\-M\*(C'\fR, \f(CW\*(C`\-s\*(C'\fR, \f(CW\*(C`\-S\*(C'\fR, \f(CW\*(C`\-t\*(C'\fR, \f(CW\*(C`\-T\*(C'\fR, n' \f(CW\*(C`\-z\*(C'\fR work as
advertised. Y'all KNOW dat shit, muthafucka!  Da return joints fo' \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, n' \f(CW\*(C`\-x\*(C'\fR
tell you whether you can straight-up access tha file; dis may
not reflect tha UIC-based file protections.  Since real and
effectizzle \s-1UIC\s0 don't differ under \s-1VMS, \s0\f(CW\*(C`\-O\*(C'\fR, \f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR,
and \f(CW\*(C`\-X\*(C'\fR is equivalent ta \f(CW\*(C`\-o\*(C'\fR, \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, n' \f(CW\*(C`\-x\*(C'\fR.
Similarly, nuff muthafuckin other tests, includin \f(CW\*(C`\-A\*(C'\fR, \f(CW\*(C`\-g\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR,
\&\f(CW\*(C`\-l\*(C'\fR, \f(CW\*(C`\-p\*(C'\fR, n' \f(CW\*(C`\-u\*(C'\fR, aren't particularly meaningful under
\&\s-1VMS,\s0 n' tha joints returned by these tests reflect whatever
your \s-1CRTL \s0\f(CW\*(C`stat()\*(C'\fR routine do ta tha equivalent bits up in the
st_mode field. Y'all KNOW dat shit, muthafucka!  Finally, \f(CW\*(C`\-d\*(C'\fR returns legit if passed a thugged-out device
specification without a explicit directory (e.g. \f(CW\*(C`DUA1:\*(C'\fR), as
well as if passed a gangbangin' finger-lickin' directory.
.Sp
There is \s-1DECC\s0 feature logical names \s-1AND ODS\-5\s0 volume attributes that
also control what tha fuck joints is returned fo' tha date fields.
.Sp
Note: Some cribs have reported problems when rockin tha file-access
tests (\f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, n' \f(CW\*(C`\-x\*(C'\fR) on filez accessed via \s-1DEC\s0z \s-1DFS.\s0
Specifically, since \s-1DFS\s0 do not currently provide access ta the
extended file header of filez on remote volumes, attempts to
examine tha \s-1ACL\s0 fail, n' tha file tests will return false,
with \f(CW$!\fR indicatin dat tha file do not exist.  Yo ass can
use \f(CW\*(C`stat\*(C'\fR on these files, since dat checks UIC-based protection
only, n' then manually check tha appropriate bits, as defined by
your C compilerz \fIstat.h\fR, up in tha mode value it returns, if you
need a approximation of tha filez protections.
.IP "backticks" 4
.IX Item "backticks"
Backticks create a subprocess, n' pass tha enclosed string
to it fo' execution as a \s-1DCL\s0 command. Y'all KNOW dat shit, muthafucka!  Since tha subprocess is
created directly via \f(CW\*(C`lib$spawn()\*(C'\fR, any valid \s-1DCL\s0 command string
may be specified.
.IP "binmode \s-1FILEHANDLE\s0" 4
.IX Item "binmode FILEHANDLE"
Da \f(CW\*(C`binmode\*(C'\fR operator will attempt ta insure dat no translation
of carriage control occurs on input from or output ta dis filehandle.
Since dis involves reopenin tha file n' then restorin its
file posizzle indicator, if dis function returns \s-1FALSE,\s0 the
underlyin filehandle may no longer point ta a open file, or may
point ta a gangbangin' finger-lickin' different posizzle up in tha file than before \f(CW\*(C`binmode\*(C'\fR
was called.
.Sp
Note dat \f(CW\*(C`binmode\*(C'\fR is generally not necessary when rockin normal
filehandles; it is provided so dat you can control I/O ta existing
record-structured filez when necessary.  Yo ass can also use the
\&\f(CW\*(C`vmsfopen\*(C'\fR function up in tha VMS::Stdio extension ta bust finer
control of I/O ta filez n' devices wit different record structures.
.IP "crypt \s-1PLAINTEXT, USER\s0" 4
.IX Item "crypt PLAINTEXT, USER"
Da \f(CW\*(C`crypt\*(C'\fR operator uses tha \f(CW\*(C`sys$hash_password\*(C'\fR system
service ta generate tha hashed representation of \s-1PLAINTEXT.\s0
If \s-1USER\s0 be a valid username, tha algorithm n' salt joints
are taken from dat userz \s-1UAF\s0 record. Y'all KNOW dat shit, muthafucka!  If it is not, then
the preferred algorithm n' a salt of 0 is used. Y'all KNOW dat shit, muthafucka!  The
quadword encrypted value is returned as a 8\-characta string.
.Sp
Da value returned by \f(CW\*(C`crypt\*(C'\fR may be compared against
the encrypted password from tha \s-1UAF\s0 returned by tha \f(CW\*(C`getpw*\*(C'\fR
functions, up in order ta authenticate users.  If you is
goin ta do this, remember dat tha encrypted password in
the \s-1UAF\s0 was generated rockin uppercase username and
password strings; you gonna gotta upcase tha arguments to
\&\f(CW\*(C`crypt\*(C'\fR ta insure dat you gonna git tha proper value:
.Sp
.Vb 9
\&    sub validate_passwd {
\&        my($user,$passwd) = @_;
\&        my($pwdhash);
\&        if ( !($pwdhash = (getpwnam($user))[1]) ||
\&               $pwdhash ne crypt("\eU$passwd","\eU$name") ) {
\&            intruder_alert($name);
\&        }
\&        return 1;
\&    }
.Ve
.IP "die" 4
.IX Item "die"
\&\f(CW\*(C`die\*(C'\fR will force tha natizzle \s-1VMS\s0 exit status ta be a \s-1SS$_ABORT\s0 code
if neither of tha $! or $? status joints is ones dat would cause
the natizzle status ta be interpreted as bein what tha fuck \s-1VMS\s0 classifies as
\&\s-1SEVERE_ERROR\s0 severitizzle fo' \s-1DCL\s0 error handling.
.Sp
When \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR be actizzle (see \*(L"$?\*(R" below), tha natizzle \s-1VMS\s0 exit
status value gonna git either one of tha \f(CW$!\fR or \f(CW$?\fR or \f(CW$^E\fR or
the Unix value 255 encoded tha fuck into it up in a way dat tha effectizzle original
value can be decoded by other programs freestyled up in C, includin Perl
and tha \s-1GNV\s0 package.  As per tha aiiight non-VMS behavior of \f(CW\*(C`die\*(C'\fR if
either \f(CW$!\fR or \f(CW$?\fR is non-zero, one of dem joints will be
encoded tha fuck into a natizzle \s-1VMS\s0 status value.  If both of tha Unix status
values is 0, n' tha \f(CW$^E\fR value is set one of \s-1ERROR\s0 or \s-1SEVERE_ERROR\s0
severity, then tha \f(CW$^E\fR value is ghon be used as tha exit code as is.
If none of tha above apply, tha Unix value of 255 is ghon be encoded into
a natizzle \s-1VMS\s0 exit status value.
.Sp
Please note a thugged-out dope difference up in tha behavior of \f(CW\*(C`die\*(C'\fR in
the \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR mode is dat it do not force a \s-1VMS
SEVERE_ERROR\s0 status on exit.  Da Unix exit jointz of 2 through
255 is ghon be encoded up in \s-1VMS\s0 status joints wit severitizzle levels of
\&\s-1SUCCESS. \s0 Da Unix exit value of 1 is ghon be encoded up in a \s-1VMS\s0 status
value wit a severitizzle level of \s-1ERROR. \s0 This is ta be compatible with
how tha \s-1VMS C\s0 library encodes these joints.
.Sp
Da minimum severitizzle level set by \f(CW\*(C`die\*(C'\fR up in \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR mode
may be chizzled ta be \s-1ERROR\s0 or higher up in tha future dependin on tha 
resultz of testin n' further review.
.Sp
See \*(L"$?\*(R" fo' a thugged-out description of tha encodin of tha Unix value to
produce a natizzle \s-1VMS\s0 status containin dat shit.
.IP "dump" 4
.IX Item "dump"
Rather than causin Perl ta abort n' dump core, tha \f(CW\*(C`dump\*(C'\fR
operator invokes tha \s-1VMS\s0 debugger n' shit.  If you continue to
execute tha Perl program under tha debugger, control will
be transferred ta tha label specified as tha argument to
\&\f(CW\*(C`dump\*(C'\fR, or, if no label was specified, back ta the
beginnin of tha program.  All other state of tha program
(\fIe.g.\fR jointz of variables, open file handles) is not
affected by callin \f(CW\*(C`dump\*(C'\fR.
.IP "exec \s-1LIST\s0" 4
.IX Item "exec LIST"
A call ta \f(CW\*(C`exec\*(C'\fR will cause Perl ta exit, n' ta invoke tha command
given as a argument ta \f(CW\*(C`exec\*(C'\fR via \f(CW\*(C`lib$do_command\*(C'\fR.  If the
argument begins wit '@' or '$' (other than as part of a gangbangin' filespec),
then it is executed as a \s-1DCL\s0 command. Y'all KNOW dat shit, muthafucka!  Otherwise, tha straight-up original gangsta token on
the command line is treated as tha filespec of a image ta run, and
an attempt is made ta invoke it (usin \fI.Exe\fR n' tha process
defaults ta expand tha filespec) n' pass tha rest of \f(CW\*(C`exec\*(C'\fR's
argument ta it as parameters.  If tha token has no file type, and
matches a gangbangin' file wit null type, then a attempt is made ta determine
whether tha file be a executable image which should be invoked
usin \f(CW\*(C`MCR\*(C'\fR or a text file which should be passed ta \s-1DCL\s0 as a
command procedure.
.IP "fork" 4
.IX Item "fork"
While up in principle tha \f(CW\*(C`fork\*(C'\fR operator could be implemented via
(and wit tha same rather severe limitations as) tha \s-1CRTL \s0\f(CW\*(C`vfork()\*(C'\fR
routine, n' while some internal support ta do just dat is in
place, tha implementation has never been completed, makin \f(CW\*(C`fork\*(C'\fR
currently unavailable.  A legit kernel \f(CW\*(C`fork()\*(C'\fR is expected up in a
future version of \s-1VMS,\s0 n' tha pseudo-fork based on interpreter
threadz may be available up in a gangbangin' future version of Perl on \s-1VMS \s0(see
perlfork).  In tha meantime, use \f(CW\*(C`system\*(C'\fR, backticks, or piped
filehandlez ta create subprocesses.
.IP "getpwent" 4
.IX Item "getpwent"
.PD 0
.IP "getpwnam" 4
.IX Item "getpwnam"
.IP "getpwuid" 4
.IX Item "getpwuid"
.PD
These operators obtain tha shiznit busted lyrics bout up in perlfunc,
if you have tha privileges necessary ta retrieve tha named user's
\&\s-1UAF\s0 shiznit via \f(CW\*(C`sys$getuai\*(C'\fR.  If not, then only tha \f(CW$name\fR,
\&\f(CW$uid\fR, n' \f(CW$gid\fR shit is returned. Y'all KNOW dat shit, muthafucka!  Da \f(CW$dir\fR item gotz nuff
the login directory up in \s-1VMS\s0 syntax, while tha \f(CW$comment\fR item
gotz nuff tha login directory up in Unix syntax. Da \f(CW$gcos\fR item
gotz nuff tha balla field from tha \s-1UAF\s0 record. Y'all KNOW dat shit, muthafucka!  Da \f(CW$quota\fR
item aint used.
.IP "gmtime" 4
.IX Item "gmtime"
Da \f(CW\*(C`gmtime\*(C'\fR operator will function properly if you have a
workin \s-1CRTL \s0\f(CW\*(C`gmtime()\*(C'\fR routine, or if tha logical name
\&\s-1SYS$TIMEZONE_DIFFERENTIAL\s0 is defined as tha number of seconds
which must be added ta \s-1UTC\s0 ta yield local time.  (This logical
name is defined automatically if yo ass is hustlin a version of
\&\s-1VMS\s0 wit built-in \s-1UTC\s0 support.)  If neither of these cases is
true, a warnin message is printed, n' \f(CW\*(C`undef\*(C'\fR is returned.
.IP "kill" 4
.IX Item "kill"
In most cases, \f(CW\*(C`kill\*(C'\fR is implemented via tha undocumented system
service \f(CW$SIGPRC\fR, which has tha same ol' dirty callin sequence as \f(CW$FORCEX\fR yo, but
throws a exception up in tha target process rather than forcin it ta call
\&\f(CW$EXIT\fR.  Generally bustin lyrics, \f(CW\*(C`kill\*(C'\fR bigs up tha behavior of the
\&\s-1CRTL\s0z \f(CW\*(C`kill()\*(C'\fR function yo, but unlike dat function can be called from
within a signal handlez n' shit.  Also, unlike tha \f(CW\*(C`kill\*(C'\fR up in some versions of
the \s-1CRTL,\s0 Perlz \f(CW\*(C`kill\*(C'\fR checks tha validitizzle of tha signal passed up in and
returns a error rather than attemptin ta bust a unrecognized signal.
.Sp
Also, wack signal joints don't do anythang special under
\&\s-1VMS\s0; they just converted ta tha correspondin positizzle value.
.IP "qx//" 4
.IX Item "qx//"
See tha entry on \f(CW\*(C`backticks\*(C'\fR above.
.IP "select (system call)" 4
.IX Item "select (system call)"
If Perl was not built wit socket support, tha system call
version of \f(CW\*(C`select\*(C'\fR aint available at all.  If socket
support is present, then tha system call version of
\&\f(CW\*(C`select\*(C'\fR functions only fo' file descriptors attached
to sockets, n' you can put dat on yo' toast.  It aint gonna provide shiznit bout regular
filez or pipes, since tha \s-1CRTL \s0\f(CW\*(C`select()\*(C'\fR routine do not
provide dis functionality.
.IP "stat \s-1EXPR\s0" 4
.IX Item "stat EXPR"
Since \s-1VMS\s0 keeps track of filez accordin ta a gangbangin' finger-lickin' different scheme
than Unix, it aint straight-up possible ta represent tha filez \s-1ID\s0
in tha \f(CW\*(C`st_dev\*(C'\fR n' \f(CW\*(C`st_ino\*(C'\fR fieldz of a \f(CW\*(C`struct stat\*(C'\fR.  Perl
tries its best, though, n' tha joints it uses is pretty unlikely
to be tha same fo' two different files.  We can't guarantee this,
though, so caveat scriptor.
.IP "system \s-1LIST\s0" 4
.IX Item "system LIST"
Da \f(CW\*(C`system\*(C'\fR operator creates a subprocess, n' passes its 
arguments ta tha subprocess fo' execution as a \s-1DCL\s0 command. Y'all KNOW dat shit, muthafucka!  
Since tha subprocess is pimped directly via \f(CW\*(C`lib$spawn()\*(C'\fR, any 
valid \s-1DCL\s0 command strang may be specified. Y'all KNOW dat shit, muthafucka!  If tha strang begins with
\&'@', it is treated as a \s-1DCL\s0 command unconditionally.  Otherwise, if
the first token gotz nuff a cold-ass lil characta used as a thugged-out delimita up in file
specification (e.g. \f(CW\*(C`:\*(C'\fR or \f(CW\*(C`]\*(C'\fR), a attempt is made ta expand it
usin  a thugged-out default type of \fI.Exe\fR n' tha process defaults, n' if
successful, tha resultin file is invoked via \f(CW\*(C`MCR\*(C'\fR. This allows you
to invoke a image directly simply by passin tha file justification
to \f(CW\*(C`system\*(C'\fR, a cold-ass lil common Unixish idiom.  If tha token has no file type,
and matches a gangbangin' file wit null type, then a attempt is made to
determine whether tha file be a executable image which should be
invoked rockin \f(CW\*(C`MCR\*(C'\fR or a text file which should be passed ta \s-1DCL\s0
as a cold-ass lil command procedure.
.Sp
If \s-1LIST\s0 consistz of tha empty string, \f(CW\*(C`system\*(C'\fR spawns an
interactizzle \s-1DCL\s0 subprocess, up in tha same fashizzle as typing
\&\fB\s-1SPAWN\s0\fR all up in tha \s-1DCL\s0 prompt.
.Sp
Perl waits fo' tha subprocess ta complete before continuing
execution up in tha current process.  As busted lyrics bout up in perlfunc,
the return value of \f(CW\*(C`system\*(C'\fR be a gangbangin' fake \*(L"status\*(R" which bigs up
\&\s-1POSIX\s0 semantics unless tha pragma \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR is in
effect; peep tha description of \f(CW$?\fR up in dis document fo' mo' 
detail.
.IP "time" 4
.IX Item "time"
Da value returned by \f(CW\*(C`time\*(C'\fR is tha offset up in secondz from
01\-JAN\-1970 00:00:00 (just like tha \s-1CRTL\s0z \fItimes()\fR routine), up in order
to make game easier fo' code comin up in from tha POSIX/Unix ghetto. Right back up in yo muthafuckin ass.
.IP "times" 4
.IX Item "times"
Da array returned by tha \f(CW\*(C`times\*(C'\fR operator is divided up 
accordin ta tha same rulez tha \s-1CRTL \s0\f(CW\*(C`times()\*(C'\fR routine.  
Therefore, tha \*(L"system time\*(R" elements will always be 0, since 
there is no difference between \*(L"user time\*(R" n' \*(L"system\*(R" time 
under \s-1VMS,\s0 n' tha time accumulated by a subprocess may or may 
not step tha fuck up separately up in tha \*(L"child time\*(R" field, dependin on 
whether \f(CW\*(C`times()\*(C'\fR keeps track of subprocesses separately.  Note
especially dat tha \s-1VAXCRTL \s0(at least) keeps track only of
subprocesses spawned rockin \f(CW\*(C`fork()\*(C'\fR n' \f(CW\*(C`exec()\*(C'\fR; it will not
accumulate tha timez of subprocesses spawned via pipes, \f(CW\*(C`system()\*(C'\fR,
or backticks.
.IP "unlink \s-1LIST\s0" 4
.IX Item "unlink LIST"
\&\f(CW\*(C`unlink\*(C'\fR will delete tha highest version of a gangbangin' file only; in
order ta delete all versions, you need ta say
.Sp
.Vb 1
\&    1 while unlink LIST;
.Ve
.Sp
Yo ass may need ta make dis chizzle ta scripts freestyled fo' a
Unix system which expect dat afta a cold-ass lil call ta \f(CW\*(C`unlink\*(C'\fR,
no filez wit tha names passed ta \f(CW\*(C`unlink\*(C'\fR will exist.
(Note: This can be chizzled at compile time; if you
\&\f(CW\*(C`use Config\*(C'\fR n' \f(CW$Config{\*(Aqd_unlink_all_versions\*(Aq}\fR is
\&\f(CW\*(C`define\*(C'\fR, then \f(CW\*(C`unlink\*(C'\fR will delete all versionz of a
file on tha straight-up original gangsta call.)
.Sp
\&\f(CW\*(C`unlink\*(C'\fR will delete a gangbangin' file if at all possible, even if it
requires changin file protection (though it won't try to
change tha protection of tha parent directory).  Yo ass can tell
whether you've gots explicit delete access ta a gangbangin' file by rockin the
\&\f(CW\*(C`VMS::Filespec::candelete\*(C'\fR operator. Shiiit, dis aint no joke.  For instance, up in order
to delete only filez ta which you have delete access, you could
say suttin' like
.Sp
.Vb 8
\&    sub safe_unlink {
\&        my($file,$num);
\&        foreach $file (@_) {
\&            next unless VMS::Filespec::candelete($file);
\&            $num += unlink $file;
\&        }
\&        $num;
\&    }
.Ve
.Sp
(or you could just use \f(CW\*(C`VMS::Stdio::remove\*(C'\fR, if you've installed
the VMS::Stdio extension distributed wit Perl). If \f(CW\*(C`unlink\*(C'\fR has to
change tha file protection ta delete tha file, n' you interrupt it
in midstream, tha file may be left intact yo, but wit a cold-ass lil chizzled \s-1ACL\s0
allowin you delete access.
.Sp
This behavior of \f(CW\*(C`unlink\*(C'\fR is ta be compatible wit \s-1POSIX\s0 behavior
and not traditionizzle \s-1VMS\s0 behavior.
.IP "utime \s-1LIST\s0" 4
.IX Item "utime LIST"
This operator chizzlez only tha modification time of tha file (\s-1VMS \s0
revision date) on \s-1ODS\-2\s0 volumes n' \s-1ODS\-5\s0 volumes without access 
dates enabled. Y'all KNOW dat shit, muthafucka! On \s-1ODS\-5\s0 volumes wit access dates enabled, tha 
true access time is modified.
.IP "waitpid \s-1PID,FLAGS\s0" 4
.IX Item "waitpid PID,FLAGS"
If \s-1PID\s0 be a subprocess started by a piped \f(CW\*(C`open()\*(C'\fR (see open), 
\&\f(CW\*(C`waitpid\*(C'\fR will wait fo' dat subprocess, n' return its final status
value up in \f(CW$?\fR.  If \s-1PID\s0 be a subprocess pimped up in some other way (e.g.
SPAWNed before Perl was invoked), \f(CW\*(C`waitpid\*(C'\fR will simply check once per
second whether tha process has completed, n' return when it has.  (If
\&\s-1PID\s0 specifies a process dat aint a subprocess of tha current process,
and you invoked Perl wit tha \f(CW\*(C`\-w\*(C'\fR switch, a warnin is ghon be issued.)
.Sp
Returns \s-1PID\s0 on success, \-1 on error. Shiiit, dis aint no joke.  Da \s-1FLAGS\s0 argument is ignored
in all cases.
.SH "Perl variables"
.IX Header "Perl variables"
Da followin VMS-specific shiznit applies ta tha indicated
\&\*(L"special\*(R" Perl variables, up in addizzle ta tha general shiznit
in perlvar. Shiiit, dis aint no joke.  Where there be a cold-ass lil conflict, dis shiznit
takes precedence.
.ie n .IP "%ENV" 4
.el .IP "\f(CW%ENV\fR" 4
.IX Item "%ENV"
Da operation of tha \f(CW%ENV\fR array dependz on tha translation
of tha logical name \fI\s-1PERL_ENV_TABLES\s0\fR.  If defined, it should
be a search list, each element of which specifies a location
for \f(CW%ENV\fR elements, n' you can put dat on yo' toast.  If you tell Perl ta read or set the
element \f(CW\*(C`$ENV{\*(C'\fR\fIname\fR\f(CW\*(C`}\*(C'\fR, then Perl uses tha translations of
\&\fI\s-1PERL_ENV_TABLES\s0\fR as bigs up:
.RS 4
.IP "\s-1CRTL_ENV\s0" 4
.IX Item "CRTL_ENV"
This strang  drops some lyrics ta Perl ta consult tha \s-1CRTL\s0z internal \f(CW\*(C`environ\*(C'\fR
array of key-value pairs, rockin \fIname\fR as tha key.  In most cases,
this gotz nuff only all dem keys yo, but if Perl was invoked via tha C
\&\f(CW\*(C`exec[lv]e()\*(C'\fR function, as is tha case fo' \s-1CGI\s0 processin by some
\&\s-1HTTP\s0 servers, then tha \f(CW\*(C`environ\*(C'\fR array may done been populated by
the callin program.
.IP "CLISYM_[\s-1LOCAL\s0]" 4
.IX Item "CLISYM_[LOCAL]"
A strang beginnin wit \f(CW\*(C`CLISYM_\*(C'\fR drops some lyrics ta Perl ta consult tha \s-1CLI\s0's
symbol tables, rockin \fIname\fR as tha name of tha symbol.  When reading
an element of \f(CW%ENV\fR, tha local symbol table is scanned first, followed
by tha global symbol table..  Da charactas followin \f(CW\*(C`CLISYM_\*(C'\fR are
significant when a element of \f(CW%ENV\fR is set or deleted: if the
complete strang is \f(CW\*(C`CLISYM_LOCAL\*(C'\fR, tha chizzle is made up in tha local
symbol table; otherwise tha global symbol table is chizzled.
.IP "Any other string" 4
.IX Item "Any other string"
If a element of \fI\s-1PERL_ENV_TABLES\s0\fR translates ta any other string,
that strang is used as tha name of a logical name table, which is
consulted rockin \fIname\fR as tha logical name.  Da aiiight search
order of access modes is used.
.RE
.RS 4
.Sp
\&\fI\s-1PERL_ENV_TABLES\s0\fR is translated once when Perl starts up; any chizzles
you make while Perl is hustlin do not affect tha behavior of \f(CW%ENV\fR.
If \fI\s-1PERL_ENV_TABLES\s0\fR aint defined, then Perl defaults ta consulting
first tha logical name tablez specified by \fI\s-1LNM$FILE_DEV\s0\fR, n' then
the \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR array.
.Sp
In all operations on \f(CW%ENV\fR, tha key strang is treated as if it 
were entirely uppercase, regardless of tha case straight-up 
specified up in tha Perl expression.
.Sp
When a element of \f(CW%ENV\fR is read, tha locations ta which
\&\fI\s-1PERL_ENV_TABLES\s0\fR points is checked up in order, n' tha value
obtained from tha straight-up original gangsta successful lookup is returned. Y'all KNOW dat shit, muthafucka!  If the
name of tha \f(CW%ENV\fR element gotz nuff a semi-colon, it and
any charactas afta it is removed. Y'all KNOW dat shit, muthafucka!  These is ignored when
the \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR array or a \s-1CLI\s0 symbol table is consulted.
But fuck dat shiznit yo, tha word on tha street is dat tha name is looked up in a logical name table, the
suffix afta tha semi-colon is treated as tha translation index
to be used fo' tha lookup.   This lets you look up successive joints
for search list logical names.  For instance, if you say
.Sp
.Vb 3
\&   $  Define STORY  once,upon,a,time,there,was
\&   $  perl \-e "for ($i = 0; $i <= 6; $i++) " \-
\&   _$ \-e "{ print $ENV{\*(Aqstory;\*(Aq.$i},\*(Aq \*(Aq}"
.Ve
.Sp
Perl will print \f(CW\*(C`ONCE UPON A TIME THERE WAS\*(C'\fR, assuming, of course,
that \fI\s-1PERL_ENV_TABLES\s0\fR is set up so dat tha logical name \f(CW\*(C`story\*(C'\fR
is found, rather than a \s-1CLI\s0 symbol or \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR element with
the same name.
.Sp
When a element of \f(CW%ENV\fR is set ta a thugged-out defined string, the
correspondin definizzle is made up in tha location ta which the
first translation of \fI\s-1PERL_ENV_TABLES\s0\fR points, n' you can put dat on yo' toast.  If dis causes a
logical name ta be pimped, it is defined up in supervisor mode.
(Da same is done if a existin logical name was defined in
executizzle or kernel mode; a existin user or supervisor mode
logical name is reset ta tha freshly smoked up value.)  If tha value be a empty
string, tha logical namez translation is defined as a single \s-1NUL
\&\s0(\s-1ASCII 00\s0) character, since a logical name cannot translate ta a
zero-length string.  (This restriction do not apply ta \s-1CLI\s0 symbols
or \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR joints; they is set ta tha empty string.)
An element of tha \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR array can be set only if your
copy of Perl knows bout tha \s-1CRTL\s0z \f(CW\*(C`setenv()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  (This is
present only up in some versionz of tha \s-1DECCRTL\s0; check \f(CW$Config{d_setenv}\fR
to peep whether yo' copy of Perl was built wit a \s-1CRTL\s0 dat has this
function.)
.Sp
When a element of \f(CW%ENV\fR is set ta \f(CW\*(C`undef\*(C'\fR,
the element is looked up as if it was bein read, n' if it is
found, it is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (An item \*(L"deleted\*(R" from tha \s-1CRTL \s0\f(CW\*(C`environ\*(C'\fR
array is set ta tha empty string; dis can only be done if your
copy of Perl knows bout tha \s-1CRTL \s0\f(CW\*(C`setenv()\*(C'\fR function.)  Using
\&\f(CW\*(C`delete\*(C'\fR ta remove a element from \f(CW%ENV\fR has a similar effect,
but afta tha element is deleted, another attempt is made to
look up tha element, so a inner-mode logical name or a name in
another location will replace tha logical name just deleted.
In either case, only tha straight-up original gangsta value found searchin \s-1PERL_ENV_TABLES\s0
is altered. Y'all KNOW dat shit, muthafucka!  It aint possible at present ta define a search list
logical name via \f(CW%ENV\fR.
.Sp
Da element \f(CW$ENV{DEFAULT}\fR is special: when read, it returns
Perlz current default thang n' directory, n' when set, it
resets them, regardless of tha definizzle of \fI\s-1PERL_ENV_TABLES\s0\fR.
It cannot be cleared or deleted; attempts ta do so is silently
ignored.
.Sp
Note dat if you wanna pass on any elementz of the
C\-local environ array ta a subprocess which aint
started by fork/exec, or aint hustlin a C program, you
can \*(L"promote\*(R" dem ta logical names up in tha current
process, which will then be inherited by all subprocesses,
by saying
.Sp
.Vb 4
\&    foreach mah $key (qw[C\-local keys you want promoted]) {
\&        mah $temp = $ENV{$key}; # read from C\-local array
\&        $ENV{$key} = $temp;    # n' define as logical name
\&    }
.Ve
.Sp
(Yo ass can't just say \f(CW$ENV{$key} = $ENV{$key}\fR, since the
Perl optimizer is smart-ass enough ta elide tha expression.)
.Sp
Don't try ta clear \f(CW%ENV\fR by sayin \f(CW\*(C`%ENV = ();\*(C'\fR, it will throw
a fatal error. Shiiit, dis aint no joke.  This is equivalent ta bustin tha followin from \s-1DCL:\s0
.Sp
.Vb 1
\&    DELETE/LOGICAL *
.Ve
.Sp
Yo ass can imagine how tha fuck wack thangs would be if, fo' example, tha \s-1SYS$MANAGER\s0
or \s-1SYS$SYSTEM\s0 logical names was deleted.
.Sp
At present, tha last time you iterate over \f(CW%ENV\fR using
\&\f(CW\*(C`keys\*(C'\fR, or \f(CW\*(C`values\*(C'\fR,  yo big-ass booty is ghon incur a time penalty as all
logical names is read, up in order ta straight-up populate \f(CW%ENV\fR.
Subsequent iterations aint gonna reread logical names, so they
won't be as slow yo, but they also won't reflect any chizzles
to logical name tablez caused by other programs.
.Sp
Yo ass do need ta be careful wit tha logical names representing
process-permanent files, like fuckin \f(CW\*(C`SYS$INPUT\*(C'\fR n' \f(CW\*(C`SYS$OUTPUT\*(C'\fR.
Da translations fo' these logical names is prepended wit a
two-byte binary value (0x1B 0x00) dat need ta be stripped off
if you wantto use dat shit. (In previous versionz of Perl it wasn't
possible ta git tha jointz of these logical names, as tha null
byte acted as a end-of-strin marker)
.RE
.IP "$!" 4
Da strang value of \f(CW$!\fR is dat returned by tha \s-1CRTL\s0's
\&\fIstrerror()\fR function, so it will include tha \s-1VMS\s0 message for
VMS-specific errors.  Da numeric value of \f(CW$!\fR is the
value of \f(CW\*(C`errno\*(C'\fR, except if errno is \s-1EVMSERR,\s0 up in which
case \f(CW$!\fR gotz nuff tha value of vaxc$errno.  Settin \f(CW$!\fR
always sets errno ta tha value specified. Y'all KNOW dat shit, muthafucka!  If dis value is
\&\s-1EVMSERR,\s0 it also sets vaxc$errno ta 4 (NONAME-F-NOMSG), so
that tha strang value of \f(CW$!\fR won't reflect tha \s-1VMS\s0 error
message from before \f(CW$!\fR was set.
.IP "$^E" 4
.IX Item "$^E"
This variable serves up direct access ta \s-1VMS\s0 status joints
in vaxc$errno, which is often mo' specific than the
generic Unix-style error lyrics up in \f(CW$!\fR.  Its numeric value
is tha value of vaxc$errno, n' its strang value is the
correspondin \s-1VMS\s0 message string, as retrieved by sys$\fIgetmsg()\fR.
Settin \f(CW$^E\fR sets vaxc$errno ta tha value specified.
.Sp
While Perl attempts ta keep tha vaxc$errno value ta be current, if
errno aint \s-1EVMSERR,\s0 it may not be from tha current operation.
.IP "$?" 4
Da \*(L"status value\*(R" returned up in \f(CW$?\fR is synthesized from the
actual exit statuz of tha subprocess up in a way dat approximates
\&\s-1POSIX\s0 \fIwait\fR\|(5) semantics, up in order ta allow Perl programs to
portably test fo' successful completion of subprocesses.  The
low order 8 bitz of \f(CW$?\fR is always 0 under \s-1VMS,\s0 since the
termination statuz of a process may or may not have been
generated by a exception.
.Sp
Da next 8 bits contain tha termination statuz of tha program.
.Sp
If tha lil pimp process bigs up tha convention of C programs
compiled wit tha _POSIX_EXIT macro set, tha status value will
contain tha actual value of 0 ta 255 returned by dat program
on a aiiight exit.
.Sp
With tha _POSIX_EXIT macro set, tha Unix exit value of zero is
represented as a \s-1VMS\s0 natizzle statuz of 1, n' tha Unix joints
from 2 ta 255 is encoded by tha equation:
.Sp
.Vb 1
\&   VMS_status = 0x35a000 + (unix_value * 8) + 1.
.Ve
.Sp
And up in tha special case of Unix value 1 tha encodin is:
.Sp
.Vb 1
\&   VMS_status = 0x35a000 + 8 + 2 + 0x10000000.
.Ve
.Sp
For other termination statuses, tha severitizzle portion of the
subprocesss exit status is used: if tha severitizzle was success or
informational, these bits is all 0; if tha severitizzle was
warning, they contain a value of 1; if tha severitizzle was
error or fatal error, they contain tha actual severitizzle bits,
which turns up ta be a value of 2 fo' error n' 4 fo' severe_error.
Fatal be another term fo' tha severe_error status.
.Sp
As a result, \f(CW$?\fR will always be zero if tha subprocesss exit
status indicated successful completion, n' non-zero if a
warnin or error occurred or a program compliant wit encoding
_POSIX_EXIT joints was run n' set a status.
.Sp
How tha fuck can you tell tha difference between a non-zero status dat is
the result of a \s-1VMS\s0 natizzle error status or a encoded Unix status?
Yo ass can not unless you peep tha ${^CHILD_ERROR_NATIVE} value.
Da ${^CHILD_ERROR_NATIVE} value returns tha actual \s-1VMS\s0 status value
and check tha severitizzle bits, n' you can put dat on yo' toast. If tha severitizzle bits is equal ta 1,
then if tha numeric value fo' \f(CW$?\fR is between 2 n' 255 or 0, then
\&\f(CW$?\fR accurately reflects a value passed back from a Unix application.
If \f(CW$?\fR is 1, n' tha severitizzle bits indicate a \s-1VMS\s0 error (2), then
\&\f(CW$?\fR is from a Unix application exit value.
.Sp
In practice, Perl scripts dat call programs dat return _POSIX_EXIT
type status joints is ghon be expectin dem joints, n' programs that
call traditionizzle \s-1VMS\s0 programs will either be expectin tha previous
behavior or just checkin fo' a non-zero status.
.Sp
And success be always tha value 0 up in all behaviors.
.Sp
When tha actual \s-1VMS\s0 termination statuz of tha lil pimp be a error,
internally tha \f(CW$!\fR value is ghon be set ta tha closest Unix errno
value ta dat error so dat Perl scripts dat test fo' error
lyrics will peep tha expected Unix steez error message instead
of a \s-1VMS\s0 message.
.Sp
Conversely, when settin \f(CW$?\fR up in a \s-1END\s0 block, a attempt is made
to convert tha \s-1POSIX\s0 value tha fuck into a natizzle status intelligible to
the operatin system upon exitin Perl.  What dis boils down to
is dat settin \f(CW$?\fR ta zero thangs up in dis biatch up in tha generic success value
\&\s-1SS$_NORMAL,\s0 n' settin \f(CW$?\fR ta a non-zero value thangs up in dis biatch up in the
generic failure status \s-1SS$_ABORT. \s0 See also \*(L"exit\*(R" up in perlport.
.Sp
With tha \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR logical name defined as \*(L"\s-1ENABLE\*(R",\s0
settin \f(CW$?\fR will cause tha freshly smoked up value ta be encoded tha fuck into \f(CW$^E\fR
so dat either tha original gangsta parent or lil pimp exit status joints 
 0 ta 255 can be automatically recovered by C programs expecting
_POSIX_EXIT behavior. Shiiit, dis aint no joke.  If both a parent n' a cold-ass lil lil pimp exit value are
non-zero, then it is ghon be assumed dat dis is straight-up a \s-1VMS\s0 native
status value ta be passed all up in cause I gots dem finger-lickin' chickens wit tha siz-auce.  Da special value of 0xFFFF is
almost a \s-1NOOP\s0 as it will cause tha current natizzle \s-1VMS\s0 status up in the
C library ta become tha current natizzle Perl \s-1VMS\s0 status, n' is handled
this way as it is known ta not be a valid natizzle \s-1VMS\s0 status value.
It be recommend dat only joints up in tha range of aiiight Unix parent or
child status numbers, 0 ta 255 is used.
.Sp
Da pragma \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR make \f(CW$?\fR reflect tha actual 
\&\s-1VMS\s0 exit status instead of tha default emulation of \s-1POSIX\s0 status 
busted lyrics bout above.  This pragma also disablez tha conversion of
non-zero joints ta \s-1SS$_ABORT\s0 when settin \f(CW$?\fR up in a \s-1END\s0
block (but zero will still be converted ta \s-1SS$_NORMAL\s0).
.Sp
Do not use tha pragma \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR wit \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR
enabled, as they is at times requestin conflictin actions n' the
consequence of ignorin dis lyrics is ghon be undefined ta allow future
improvements up in tha \s-1POSIX\s0 exit handling.
.Sp
In general, wit \f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR enabled, mo' detailed shiznit
will be available up in tha exit status fo' \s-1DCL\s0 scripts or other natizzle \s-1VMS\s0 tools,
and will give tha expected shiznit fo' Posix programs.  It has not been
made tha default up in order ta preserve backward compatibility.
.Sp
N.B. Right back up in yo muthafuckin ass. Settin \f(CW\*(C`DECC$FILENAME_UNIX_REPORT\*(C'\fR implicitly enablez 
\&\f(CW\*(C`PERL_VMS_POSIX_EXIT\*(C'\fR.
.IP "$|" 4
Settin \f(CW$|\fR fo' a I/O stream causes data ta be flushed
all tha way ta disk on each write (\fIi.e.\fR not just to
the underlyin \s-1RMS\s0 buffers fo' a gangbangin' file).  In other lyrics,
itz equivalent ta callin \fIfflush()\fR n' \fIfsync()\fR from C.
.SH "Standard modulez wit VMS-specific differences"
.IX Header "Standard modulez wit VMS-specific differences"
.SS "SDBM_File"
.IX Subsection "SDBM_File"
SDBM_File works properly on \s-1VMS.\s0 It has, however, one minor
difference. Da database directory file pimped has a \fI.sdbm_dir\fR
extension rather than a \fI.dir\fR extension. I aint talkin' bout chicken n' gravy biatch. \fI.dir\fR filez is \s-1VMS\s0 filesystem
directory files, n' rockin dem fo' other purposes could cause unacceptable
problems.
.SH "Revision date"
.IX Header "Revision date"
Please peep tha git repository fo' revision history.
.SH "AUTHOR"
.IX Header "AUTHOR"
Charlez Bailey  bailey@cor.newman.upenn.edu
Craig Berry  craigberry@mac.com
Don Juan Sugalski  dan@sidhe.org
Jizzy Malmberg wb8tyw@qsl.net
