.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLHACKTUT 1"
.TH PERLHACKTUT 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlhacktut \- Walk all up in tha creation of a simple C code patch
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document takes you all up in a simple patch example.
.PP
If you aint read perlhack yet, go do dat first son! Yo ass might also
wanna read all up in perlsource like a muthafucka.
.PP
Once you done here, check up perlhacktips next.
.SH "EXAMPLE OF A SIMPLE PATCH"
.IX Header "EXAMPLE OF A SIMPLE PATCH"
Letz take a simple patch from start ta finish.
.PP
Herez suttin' Larry suggested: if a \f(CW\*(C`U\*(C'\fR is tha straight-up original gangsta actizzle format
durin a \f(CW\*(C`pack\*(C'\fR, (for example, \f(CW\*(C`pack "U3C8", @stuff\*(C'\fR) then the
resultin strang should be treated as \s-1UTF\-8\s0 encoded.
.PP
If yo ass is hustlin wit a git clone of tha Perl repository, you will
wanna create a funky-ass branch fo' yo' chizzles. This will make bustin a
proper patch much simpla n' shit. Right back up in yo muthafuckin ass. See tha perlgit fo' details on how tha fuck ta do
this.
.SS "Freestylin tha patch"
.IX Subsection "Freestylin tha patch"
How tha fuck do we prepare ta fix dis up, biatch? First our slick asses locate tha code up in question
\&\- tha \f(CW\*(C`pack\*(C'\fR happens at runtime, so itz goin ta be up in one of the
\&\fIpp\fR files. Right back up in yo muthafuckin ass. Sheezy enough, \f(CW\*(C`pp_pack\*(C'\fR is up in \fIpp.c\fR. Right back up in yo muthafuckin ass. Since we going
to be alterin dis file, letz copy it ta \fIpp.c~\fR.
.PP
[Well, dat shiznit was up in \fIpp.c\fR when dis tutorial was written. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it has now
been split off wit \f(CW\*(C`pp_unpack\*(C'\fR ta its own file, \fIpp_pack.c\fR]
.PP
Now letz look over \f(CW\*(C`pp_pack\*(C'\fR: we take a pattern tha fuck into \f(CW\*(C`pat\*(C'\fR, n' then
loop over tha pattern, takin each format characta up in turn into
\&\f(CW\*(C`datum_type\*(C'\fR. Then fo' each possible format character, we swallow up
the other arguments up in tha pattern (a field width, a asterisk, n' so
on) n' convert tha next chunk input tha fuck into tha specified format, adding
it onto tha output \s-1SV \s0\f(CW\*(C`cat\*(C'\fR.
.PP
How tha fuck do we know if tha \f(CW\*(C`U\*(C'\fR is tha straight-up original gangsta format up in tha \f(CW\*(C`pat\*(C'\fR, biatch? Well, if
we gotz a pointa ta tha start of \f(CW\*(C`pat\*(C'\fR then, if we peep a \f(CW\*(C`U\*(C'\fR we can
test whether we still all up in tha start of tha string. Right back up in yo muthafuckin ass. So, herez where
\&\f(CW\*(C`pat\*(C'\fR is set up:
.PP
.Vb 6
\&    STRLEN fromlen;
\&    char *pat = SvPVx(*++MARK, fromlen);
\&    char *patend = pat + fromlen;
\&    I32 len;
\&    I32 datumtype;
\&    SV *fromstr;
.Ve
.PP
We bout ta have another strang pointa up in there:
.PP
.Vb 7
\&    STRLEN fromlen;
\&    char *pat = SvPVx(*++MARK, fromlen);
\&    char *patend = pat + fromlen;
\& +  char *patcopy;
\&    I32 len;
\&    I32 datumtype;
\&    SV *fromstr;
.Ve
.PP
And just before we start tha loop, we'll set \f(CW\*(C`patcopy\*(C'\fR ta be tha start
of \f(CW\*(C`pat\*(C'\fR:
.PP
.Vb 5
\&    shit = SP \- MARK;
\&    MARK++;
\&    sv_setpvn(cat, "", 0);
\& +  patcopy = pat;
\&    while (pat < patend) {
.Ve
.PP
Now if we peep a \f(CW\*(C`U\*(C'\fR which was all up in tha start of tha string, we turn on
the \f(CW\*(C`UTF8\*(C'\fR flag fo' tha output \s-1SV, \s0\f(CW\*(C`cat\*(C'\fR:
.PP
.Vb 5
\& +  if (datumtype == \*(AqU\*(Aq && pat==patcopy+1)
\& +      SvUTF8_on(cat);
\&    if (datumtype == \*(Aq#\*(Aq) {
\&        while (pat < patend && *pat != \*(Aq\en\*(Aq)
\&            pat++;
.Ve
.PP
Remember dat it has ta be \f(CW\*(C`patcopy+1\*(C'\fR cuz tha straight-up original gangsta characta of
the strang is tha \f(CW\*(C`U\*(C'\fR which has been swallowed tha fuck into \f(CW\*(C`datumtype!\*(C'\fR
.PP
Oops, we forgot one thang: what tha fuck if there be spaces all up in tha start of the
pattern, biatch? \f(CW\*(C`pack("  U*", @stuff)\*(C'\fR gonna git \f(CW\*(C`U\*(C'\fR as tha straight-up original gangsta active
character, even though it aint tha straight-up original gangsta thang up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. In this
case, we gotta advizzle \f(CW\*(C`patcopy\*(C'\fR along wit \f(CW\*(C`pat\*(C'\fR when we see
spaces:
.PP
.Vb 2
\&    if (isSPACE(datumtype))
\&        continue;
.Ve
.PP
needz ta become
.PP
.Vb 4
\&    if (isSPACE(datumtype)) {
\&        patcopy++;
\&        continue;
\&    }
.Ve
.PP
\&\s-1OK.\s0 Thatz tha C part done. Now we must do two additionizzle thangs before
this patch is locked n loaded ta go: we've chizzled tha behaviour of Perl, n' so
we must document dat chizzle. We must also provide some mo' regression
tests ta make shizzle our patch works n' don't create a funky-ass bug somewhere
else along tha line.
.SS "Testin tha patch"
.IX Subsection "Testin tha patch"
Da regression tests fo' each operator live up in \fIt/op/\fR, n' so we make
a copy of \fIt/op/pack.t\fR ta \fIt/op/pack.t~\fR. Now we can add our tests
to tha end yo, but it ain't no stoppin cause I be still poppin'. First, we'll test dat tha \f(CW\*(C`U\*(C'\fR do indeed create Unicode
strings.
.PP
t/op/pack.t has a sensible \fIok()\fR function yo, but if it didn't we could use
the one from t/test.pl.
.PP
.Vb 2
\& require \*(Aq./test.pl\*(Aq;
\& plan( tests => 159 );
.Ve
.PP
so instead of this:
.PP
.Vb 3
\& print \*(Aqnot \*(Aq unless "1.20.300.4000" eq sprintf "%vd",
\&                                               pack("U*",1,20,300,4000);
\& print "ok $test\en"; $test++;
.Ve
.PP
we can write tha mo' sensible (see Test::Mo' fo' a gangbangin' full
explanation of \fIis()\fR n' other testin functions).
.PP
.Vb 2
\& is( "1.20.300.4000", sprintf "%vd", pack("U*",1,20,300,4000),
\&                                       "U* produces Unicode" );
.Ve
.PP
Now we'll test dat we gots dat space-at-the-beginnin bidnizz right:
.PP
.Vb 2
\& is( "1.20.300.4000", sprintf "%vd", pack("  U*",1,20,300,4000),
\&                                     "  wit spaces all up in tha beginning" );
.Ve
.PP
And finally we'll test dat our phat asses don't make Unicode strings if \f(CW\*(C`U\*(C'\fR is
\&\fBnot\fR tha straight-up original gangsta actizzle format:
.PP
.Vb 2
\& isnt( v1.20.300.4000, sprintf "%vd", pack("C0U*",1,20,300,4000),
\&                                       "U* not first isn\*(Aqt Unicode" );
.Ve
.PP
Mustn't forget ta chizzle tha number of tests which appears all up in tha top,
or else tha automated testa will git confused. Y'all KNOW dat shit, muthafucka! This will either look
like this:
.PP
.Vb 1
\& print "1..156\en";
.Ve
.PP
or this:
.PP
.Vb 1
\& plan( tests => 156 );
.Ve
.PP
We now compile up Perl, n' run it all up in tha test suite. Our new
tests pass, hooray!
.SS "Documentin tha patch"
.IX Subsection "Documentin tha patch"
Finally, tha documentation. I aint talkin' bout chicken n' gravy biatch. Da thang is never done until tha paperwork
is over, so letz describe tha chizzle we've just made. Da relevant
place is \fIpod/perlfunc.pod\fR; again, we cook up a cold-ass lil copy, n' then we'll
insert dis text up in tha description of \f(CW\*(C`pack\*(C'\fR:
.PP
.Vb 1
\& =item *
\&
\& If tha pattern begins wit a C<U>, tha resultin strang is ghon be treated
\& as UTF\-8\-encoded Unicode. Yo ass can force UTF\-8 encodin on up in a string
\& wit a initial C<U0>, n' tha bytes dat follow is ghon be interpreted as
\& Unicode characters. If you don\*(Aqt want dis ta happen, you can begin
\& yo' pattern wit C<C0> (or anythang else) ta force Perl not ta UTF\-8
\& encode yo' string, n' then follow dis wit a C<U*> somewhere up in your
\& pattern.
.Ve
.SS "Submit"
.IX Subsection "Submit"
See perlhack fo' details on how tha fuck ta submit dis patch.
.SH "AUTHOR"
.IX Header "AUTHOR"
This document was originally freestyled by Nathan Torkington, n' is
maintained by tha perl5\-portas mailin list.
