.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLEXWARN 1"
.TH PERLLEXWARN 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllexwarn \- Perl Lexical Warnings
.IX Xref "warning, lexical warnings warning"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \f(CW\*(C`use warnings\*(C'\fR pragma enablez ta control precisely what tha fuck warnings are
to be enabled up in which partz of a Perl program. It aint nuthin but a mo' flexible
alternatizzle fo' both tha command line flag \fB\-w\fR n' tha equivalent Perl
variable, \f(CW$^W\fR.
.PP
This pragma works just like tha \f(CW\*(C`strict\*(C'\fR pragma.
This means dat tha scope of tha warnin pragma is limited ta the
enclosin block. Well shiiiit, it also means dat tha pragma settin will not
leak across filez (via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR). This allows
authors ta independently define tha degree of warnin checks dat will
be applied ta they module.
.PP
By default, optionizzle warnings is disabled, so any legacy code that
doesn't attempt ta control tha warnings will work unchanged.
.PP
All warnings is enabled up in a funky-ass block by either of these:
.PP
.Vb 2
\&    use warnings;
\&    use warnings \*(Aqall\*(Aq;
.Ve
.PP
Similarly all warnings is disabled up in a funky-ass block by either of these:
.PP
.Vb 2
\&    no warnings;
\&    no warnings \*(Aqall\*(Aq;
.Ve
.PP
For example, consider tha code below:
.PP
.Vb 7
\&    use warnings;
\&    mah @a;
\&    {
\&        no warnings;
\&        mah $b = @a[0];
\&    }
\&    mah $c = @a[0];
.Ve
.PP
Da code up in tha enclosin block has warnings enabled yo, but tha inner
block has dem disabled. Y'all KNOW dat shit, muthafucka! In dis case dat means tha assignment ta the
scalar \f(CW$c\fR will trip tha \f(CW"Scalar value @a[0] betta freestyled as $a[0]"\fR
warnin yo, but tha assignment ta tha scalar \f(CW$b\fR will not.
.SS "Default Warnings n' Optionizzle Warnings"
.IX Subsection "Default Warnings n' Optionizzle Warnings"
Before tha introduction of lexical warnings, Perl had two classes of
warnings: mandatory n' optional.
.PP
As its name suggests, if yo' code tripped a mandatory warning, you
would git a warnin whether you wanted it or not.
For example, tha code below would always produce a \f(CW"isn\*(Aqt numeric"\fR
warnin bout tha \*(L"2:\*(R".
.PP
.Vb 1
\&    mah $a = "2:" + 3;
.Ve
.PP
With tha introduction of lexical warnings, mandatory warnings now become
\&\fIdefault\fR warnings. Da difference is dat although tha previously
mandatory warnings is still enabled by default, they can then be
subsequently enabled or disabled wit tha lexical warnin pragma. For
example, up in tha code below, a \f(CW"isn\*(Aqt numeric"\fR warnin will only
be reported fo' tha \f(CW$a\fR variable.
.PP
.Vb 3
\&    mah $a = "2:" + 3;
\&    no warnings;
\&    mah $b = "2:" + 3;
.Ve
.PP
Note dat neither tha \fB\-w\fR flag or tha \f(CW$^W\fR can be used to
disable/enable default warnings. They is still mandatory up in dis case.
.ie n .SS "Whatz wack wit \fB\-w\fP n' $^W"
.el .SS "Whatz wack wit \fB\-w\fP n' \f(CW$^W\fP"
.IX Subsection "Whatz wack wit -w n' $^W"
Although straight-up useful, tha big-ass problem wit rockin \fB\-w\fR on tha command
line ta enable warnings is dat it be all or nothing. Take tha typical
scenario when yo ass is freestylin a Perl program. Partz of tha code you
will write yo ass yo, but itz straight-up likely dat yo big-ass booty is ghon make use of
pre-written Perl modules. If you use tha \fB\-w\fR flag up in dis case, you
end up enablin warnings up in piecez of code dat you aint written.
.PP
Similarly, rockin \f(CW$^W\fR ta either disable or enable blockz of code is
fundamentally flawed. Y'all KNOW dat shit, muthafucka! For a start, say you wanna disable warnings in
a block of code. Yo ass might expect dis ta be enough ta do tha trick:
.PP
.Vb 5
\&     {
\&         local ($^W) = 0;
\&         mah $a =+ 2;
\&         mah $b; chop $b;
\&     }
.Ve
.PP
When dis code is run wit tha \fB\-w\fR flag, a warnin is ghon be produced
for tha \f(CW$a\fR line:  \f(CW"Reversed += operator"\fR.
.PP
Da problem is dat Perl has both compile-time n' run-time warnings. To
disable compile-time warnings you need ta rewrite tha code like this:
.PP
.Vb 5
\&     {
\&         BEGIN { $^W = 0 }
\&         mah $a =+ 2;
\&         mah $b; chop $b;
\&     }
.Ve
.PP
Da other big-ass problem wit \f(CW$^W\fR is tha way you can inadvertently
change tha warnin settin up in unexpected places up in yo' code. For example,
when tha code below is run (without tha \fB\-w\fR flag), tha second call
to \f(CW\*(C`doit\*(C'\fR will trip a \f(CW"Use of uninitialized value"\fR warning, whereas
the first will not.
.PP
.Vb 4
\&    sub doit
\&    {
\&        mah $b; chop $b;
\&    }
\&
\&    doit();
\&
\&    {
\&        local ($^W) = 1;
\&        doit()
\&    }
.Ve
.PP
This be a side-effect of \f(CW$^W\fR bein dynamically scoped.
.PP
Lexical warnings git round these limitations by allowin finer control
over where warnings can or can't be tripped.
.SS "Controllin Warnings from tha Command Line"
.IX Subsection "Controllin Warnings from tha Command Line"
There is three Command Line flags dat can be used ta control when
warnings is (or aren't) produced:
.IP "\fB\-w\fR" 5
.IX Xref "-w"
.IX Item "-w"
This is  tha existin flag. If tha lexical warnings pragma is \fBnot\fR
used up in any of y'all code, or any of tha modulez dat you use, dis flag
will enable warnings everywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Right back up in yo muthafuckin ass. See \*(L"Backward Compatibility\*(R" for
detailz of how tha fuck dis flag interacts wit lexical warnings.
.IP "\fB\-W\fR" 5
.IX Xref "-W"
.IX Item "-W"
If tha \fB\-W\fR flag is used on tha command line, it will enable all warnings
all up in tha program regardless of whether warnings was disabled
locally rockin \f(CW\*(C`no warnings\*(C'\fR or \f(CW\*(C`$^W =0\*(C'\fR. This includes all filez dat get
included via \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR.
Think of it as tha Perl equivalent of tha \*(L"lint\*(R" command.
.IP "\fB\-X\fR" 5
.IX Xref "-X"
.IX Item "-X"
Do tha exact opposite ta tha \fB\-W\fR flag, i.e. it disablez all warnings.
.SS "Backward Compatibility"
.IX Subsection "Backward Compatibility"
If yo ass is used ta hustlin wit a version of Perl prior ta the
introduction of lexically scoped warnings, or have code dat uses both
lexical warnings n' \f(CW$^W\fR, dis section will describe how tha fuck they interact.
.PP
How tha fuck Lexical Warnings interact wit \fB\-w\fR/\f(CW$^W\fR:
.IP "1." 5
If none of tha three command line flags (\fB\-w\fR, \fB\-W\fR or \fB\-X\fR) that
control warnings is used n' neither \f(CW$^W\fR nor tha \f(CW\*(C`warnings\*(C'\fR pragma
are used, then default warnings is ghon be enabled n' optionizzle warnings
disabled.
This means dat legacy code dat don't attempt ta control tha warnings
will work unchanged.
.IP "2." 5
Da \fB\-w\fR flag just sets tha global \f(CW$^W\fR variable as up in 5.005. This
means dat any legacy code dat currently relies on manipulatin \f(CW$^W\fR
to control warnin behavior will still work as is.
.IP "3." 5
Apart from now bein a funky-ass boolean, tha \f(CW$^W\fR variable operates up in exactly
the same wack uncontrolled global way, except dat it cannot
disable/enable default warnings.
.IP "4." 5
If a piece of code is under tha control of tha \f(CW\*(C`warnings\*(C'\fR pragma,
both tha \f(CW$^W\fR variable n' tha \fB\-w\fR flag is ghon be ignored fo' the
scope of tha lexical warning.
.IP "5." 5
Da only way ta override a lexical warnings settin is wit tha \fB\-W\fR
or \fB\-X\fR command line flags.
.PP
Da combined effect of 3 & 4 is dat it will allow code which uses
the \f(CW\*(C`warnings\*(C'\fR pragma ta control tha warnin behavior of $^W\-type
code (usin a \f(CW\*(C`local $^W=0\*(C'\fR) if it straight-up wants ta yo, but not vice-versa.
.SS "Category Hierarchy"
.IX Xref "warning, categories"
.IX Subsection "Category Hierarchy"
A hierarchy of \*(L"categories\*(R" done been defined ta allow crewz of warnings
to be enabled/disabled up in isolation.
.PP
Da current hierarchy is:
.PP
.Vb 10
\&    all \-+
\&         |
\&         +\- closure
\&         |
\&         +\- deprecated
\&         |
\&         +\- exiting
\&         |
\&         +\- experimenstrual \-\-+
\&         |                 |
\&         |                 +\- experimental::lexical_subs
\&         |
\&         +\- glob
\&         |
\&         +\- imprecision
\&         |
\&         +\- io \-\-\-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- closed
\&         |                 |
\&         |                 +\- exec
\&         |                 |
\&         |                 +\- layer
\&         |                 |
\&         |                 +\- newline
\&         |                 |
\&         |                 +\- pipe
\&         |                 |
\&         |                 +\- unopened
\&         |
\&         +\- misc
\&         |
\&         +\- numeric
\&         |
\&         +\- once
\&         |
\&         +\- overflow
\&         |
\&         +\- pack
\&         |
\&         +\- portable
\&         |
\&         +\- recursion
\&         |
\&         +\- redefine
\&         |
\&         +\- regexp
\&         |
\&         +\- severe \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- debugging
\&         |                 |
\&         |                 +\- inplace
\&         |                 |
\&         |                 +\- internal
\&         |                 |
\&         |                 +\- malloc
\&         |
\&         +\- signal
\&         |
\&         +\- substr
\&         |
\&         +\- syntax \-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- ambiguous
\&         |                 |
\&         |                 +\- bareword
\&         |                 |
\&         |                 +\- digit
\&         |                 |
\&         |                 +\- illegalproto
\&         |                 |
\&         |                 +\- parenthesis
\&         |                 |
\&         |                 +\- precedence
\&         |                 |
\&         |                 +\- printf
\&         |                 |
\&         |                 +\- prototype
\&         |                 |
\&         |                 +\- qw
\&         |                 |
\&         |                 +\- reserved
\&         |                 |
\&         |                 +\- semicolon
\&         |
\&         +\- taint
\&         |
\&         +\- threads
\&         |
\&         +\- uninitialized
\&         |
\&         +\- unpack
\&         |
\&         +\- untie
\&         |
\&         +\- utf8 \-\-\-\-\-\-\-\-\-\-+
\&         |                 |
\&         |                 +\- non_unicode
\&         |                 |
\&         |                 +\- nonchar
\&         |                 |
\&         |                 +\- surrogate
\&         |
\&         +\- void
.Ve
.PP
Just like tha \*(L"strict\*(R" pragma any of these categories can be combined
.PP
.Vb 2
\&    use warnings qw(void redefine);
\&    no warnings qw(io syntax untie);
.Ve
.PP
Also like tha \*(L"strict\*(R" pragma, if there is mo' than one instizzle of the
\&\f(CW\*(C`warnings\*(C'\fR pragma up in a given scope tha cumulatizzle effect be additive.
.PP
.Vb 5
\&    use warnings qw(void); # only "void" warnings enabled
\&    ...
\&    use warnings qw(io);   # only "void" & "io" warnings enabled
\&    ...
\&    no warnings qw(void);  # only "io" warnings enabled
.Ve
.PP
To determine which category a specific warnin has been assigned ta see
perldiag.
.PP
Note: In Perl 5.6.1, tha lexical warnings category \*(L"deprecated\*(R" was a
sub-category of tha \*(L"syntax\*(R" category. Well shiiiit, it is now a top-level category
in its own right.
.SS "Fatal Warnings"
.IX Xref "warning, fatal"
.IX Subsection "Fatal Warnings"
Da presence of tha word \*(L"\s-1FATAL\*(R"\s0 up in tha category list will escalate any
warnings detected from tha categories specified up in tha lexical scope
into fatal errors. In tha code below, tha use of \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`length\*(C'\fR
and \f(CW\*(C`join\*(C'\fR can all produce a \f(CW"Useless use of xxx up in void context"\fR
warning.
.PP
.Vb 1
\&    use warnings;
\&
\&    time;
\&
\&    {
\&        use warnings FATAL => qw(void);
\&        length "abc";
\&    }
\&
\&    join "", 1,2,3;
\&
\&    print "done\en";
.Ve
.PP
When run it produces dis output
.PP
.Vb 2
\&    Useless use of time up in void context at fatal line 3.
\&    Useless use of length up in void context at fatal line 7.
.Ve
.PP
Da scope where \f(CW\*(C`length\*(C'\fR is used has blew tha fuck up tha \f(CW\*(C`void\*(C'\fR warnings
category tha fuck into a gangbangin' fatal error, so tha program terminates immediately it
encountas tha warning.
.PP
To explicitly turn off a \*(L"\s-1FATAL\*(R"\s0 warnin you just disable tha warning
it be associated with.  So, fo' example, ta disable tha \*(L"void\*(R" warning
in tha example above, either of these will do tha trick:
.PP
.Vb 2
\&    no warnings qw(void);
\&    no warnings FATAL => qw(void);
.Ve
.PP
If you wanna downgrade a warnin dat has been blew tha fuck up tha fuck into a gangbangin' fatal
error back ta a aiiight warning, you can use tha \*(L"\s-1NONFATAL\*(R"\s0 keyword. Y'all KNOW dat shit, muthafucka! For
example, tha code below will promote all warnings tha fuck into fatal errors,
except fo' dem up in tha \*(L"syntax\*(R" category.
.PP
.Vb 1
\&    use warnings FATAL => \*(Aqall\*(Aq, NONFATAL => \*(Aqsyntax\*(Aq;
.Ve
.SS "Reportin Warnings from a Module"
.IX Xref "warning, reportin warning, registering"
.IX Subsection "Reportin Warnings from a Module"
Da \f(CW\*(C`warnings\*(C'\fR pragma serves up a fuckin shitload of functions dat is useful for
module authors. These is used when you wanna report a module-specific
warnin ta a cold-ass lil callin module has enabled warnings via tha \f(CW\*(C`warnings\*(C'\fR
pragma.
.PP
Consider tha module \f(CW\*(C`MyMod::Abc\*(C'\fR below.
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    use warnings::register;
\&
\&    sub open {
\&        mah $path = shift;
\&        if ($path !~ m#^/#) {
\&            warnings::warn("changin relatizzle path ta /var/abc")
\&                if warnings::enabled();
\&            $path = "/var/abc/$path";
\&        }
\&    }
\&
\&    1;
.Ve
.PP
Da call ta \f(CW\*(C`warnings::register\*(C'\fR will create a freshly smoked up warnings category
called \*(L"MyMod::Abc\*(R", i.e. tha freshly smoked up category name matches tha current
package name. Da \f(CW\*(C`open\*(C'\fR function up in tha module will display a warning
message if it gets given a relatizzle path as a parameter n' shit. This warnings
will only be displayed if tha code dat uses \f(CW\*(C`MyMod::Abc\*(C'\fR has actually
enabled dem wit tha \f(CW\*(C`warnings\*(C'\fR pragma like below.
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    abc::open("../fred.txt");
.Ve
.PP
It be also possible ta test whether tha pre-defined warnings categories are
set up in tha callin module wit tha \f(CW\*(C`warnings::enabled\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Consider
this snippet of code:
.PP
.Vb 1
\&    package MyMod::Abc;
\&
\&    sub open {
\&        warnings::warnif("deprecated", 
\&                         "open is deprecated, use freshly smoked up instead");
\&        new(@_);
\&    }
\&
\&    sub new
\&    ...
\&    1;
.Ve
.PP
Da function \f(CW\*(C`open\*(C'\fR has been deprecated, so code has been included to
display a warnin message whenever tha callin module has (at least) the
\&\*(L"deprecated\*(R" warnings category enabled. Y'all KNOW dat shit, muthafucka! Somethang like this, say.
.PP
.Vb 4
\&    use warnings \*(Aqdeprecated\*(Aq;
\&    use MyMod::Abc;
\&    ...
\&    MyMod::Abc::open($filename);
.Ve
.PP
Either tha \f(CW\*(C`warnings::warn\*(C'\fR or \f(CW\*(C`warnings::warnif\*(C'\fR function should be
used ta straight-up display tha warnings message. This is cuz they can
make use of tha feature dat allows warnings ta be blew tha fuck up tha fuck into fatal
errors. Right back up in yo muthafuckin ass. So up in dis case
.PP
.Vb 4
\&    use MyMod::Abc;
\&    use warnings FATAL => \*(AqMyMod::Abc\*(Aq;
\&    ...
\&    MyMod::Abc::open(\*(Aq../fred.txt\*(Aq);
.Ve
.PP
the \f(CW\*(C`warnings::warnif\*(C'\fR function will detect dis n' take a thugged-out dirtnap after
displayin tha warnin message.
.PP
Da three warnings functions, \f(CW\*(C`warnings::warn\*(C'\fR, \f(CW\*(C`warnings::warnif\*(C'\fR
and \f(CW\*(C`warnings::enabled\*(C'\fR can optionally take a object reference up in place
of a cold-ass lil category name. In dis case tha functions will use tha class name
of tha object as tha warnings category.
.PP
Consider dis example:
.PP
.Vb 1
\&    package Original;
\&
\&    no warnings;
\&    use warnings::register;
\&
\&    sub new
\&    {
\&        mah $class = shift;
\&        bless [], $class;
\&    }
\&
\&    sub check
\&    {
\&        mah $self = shift;
\&        mah $value = shift;
\&
\&        if ($value % 2 && warnings::enabled($self))
\&          { warnings::warn($self, "Odd numbers is unsafe") }
\&    }
\&
\&    sub doit
\&    {
\&        mah $self = shift;
\&        mah $value = shift;
\&        $self\->check($value);
\&        # ...
\&    }
\&
\&    1;
\&
\&    package Derived;
\&
\&    use warnings::register;
\&    use Original;
\&    our @ISA = qw( Original Gangsta );
\&    sub new
\&    {
\&        mah $class = shift;
\&        bless [], $class;
\&    }
\&
\&
\&    1;
.Ve
.PP
Da code below make use of both modulez yo, but it only enablez warnings from 
\&\f(CW\*(C`Derived\*(C'\fR.
.PP
.Vb 7
\&    use Original;
\&    use Derived;
\&    use warnings \*(AqDerived\*(Aq;
\&    mah $a = Original\->new();
\&    $a\->doit(1);
\&    mah $b = Derived\->new();
\&    $a\->doit(1);
.Ve
.PP
When dis code is run only tha \f(CW\*(C`Derived\*(C'\fR object, \f(CW$b\fR, will generate
a warning.
.PP
.Vb 1
\&    Odd numbers is unsafe at main.pl line 7
.Ve
.PP
Notice also dat tha warnin is reported all up in tha line where tha object is first
used.
.PP
When registerin freshly smoked up categoriez of warning, you can supply mo' names to
warnings::regista like this:
.PP
.Vb 2
\&    package MyModule;
\&    use warnings::regista qw(format precision);
\&
\&    ...
\&
\&    warnings::warnif(\*(AqMyModule::format\*(Aq, \*(Aq...\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
warnings, perldiag.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess
