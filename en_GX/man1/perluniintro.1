.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLUNIINTRO 1"
.TH PERLUNIINTRO 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perluniintro \- Perl Unicode introduction
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document gives a general scam of Unicode n' how tha fuck ta use Unicode
in Perl.  See \*(L"Further Resources\*(R" fo' references ta mo' in-depth
treatmentz of Unicode.
.SS "Unicode"
.IX Subsection "Unicode"
Unicode be a cold-ass lil characta set standard which plans ta codify all of the
writin systemz of tha ghetto, plus nuff other symbols.
.PP
Unicode n' \s-1ISO/IEC 10646\s0 is coordinated standardz dat unify
almost all other modern characta set standards,
coverin mo' than 80 freestylin systems n' hundredz of languages,
includin all commercially-important modern languages.  All characters
in tha phattest Chinese, Japanese, n' Korean dictionaries is also
encoded. Y'all KNOW dat shit, muthafucka! Da standardz will eventually cover almost all charactas in
more than 250 freestylin systems n' thousandz of languages.
Unicode 1.0 was busted out up in October 1991, n' 6.0 up in October 2010.
.PP
A Unicode \fIcharacter\fR be a abstract entity.  It aint bound ta any
particular integer width, especially not ta tha C language \f(CW\*(C`char\*(C'\fR.
Unicode is language-neutral n' display-neutral: it do not encode the
language of tha text, n' it do not generally define fonts or other graphical
layout details.  Unicode operates on charactas n' on text built from
those characters.
.PP
Unicode defines charactas like \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR or \f(CW\*(C`GREEK
SMALL LETTER ALPHA\*(C'\fR n' unique numbers fo' tha characters, up in this
case 0x0041 n' 0x03B1, respectively.  These unique numbers is called
\&\fIcode points\fR.  A code point is essentially tha posizzle of the
characta within tha set of all possible Unicode characters, n' thus in
Perl, tha term \fIordinal\fR is often used interchangeably wit dat shit.
.PP
Da Unicode standard prefers rockin hexadecimal notation fo' tha code
points, n' you can put dat on yo' toast.  If numbers like \f(CW0x0041\fR is unfamiliar ta you, take a peek
at a lata section, \*(L"Hexadecimal Notation\*(R".  Da Unicode standard
uses tha notation \f(CW\*(C`U+0041 LATIN CAPITAL LETTER A\*(C'\fR, ta give the
hexadecimal code point n' tha normatizzle name of tha character.
.PP
Unicode also defines various \fIproperties\fR fo' tha characters, like
\&\*(L"uppercase\*(R" or \*(L"lowercase\*(R", \*(L"decimal digit\*(R", or \*(L"punctuation\*(R";
these propertizzles is independent of tha namez of tha characters.
Furthermore, various operations on tha charactas like uppercasing,
lowercasing, n' collatin (sorting) is defined.
.PP
A Unicode \fIlogical\fR \*(L"character\*(R" can straight-up consist of mo' than one internal
\&\fIactual\fR \*(L"character\*(R" or code point.  For Westside languages, dis be adequately
modelled by a \fIbase character\fR (like \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR) followed
by one or mo' \fImodifiers\fR (like \f(CW\*(C`COMBINING ACUTE ACCENT\*(C'\fR).  This sequence of
base characta n' modifiers is called a \fIcombinin character
sequence\fR.  Some non-western languages require mo' fucked up
models, so Unicode pimped tha \fIgrapheme cluster\fR concept, which was
lata further refined tha fuck into tha \fIextended grapheme cluster\fR.  For
example, a Korean Hangul syllable is considered a single logical
character yo, but most often consistz of three actual
Unicode characters: a leadin consonant followed by a interior vowel followed
by a trailin consonant.
.PP
Whether ta booty-call these extended grapheme clustas \*(L"characters\*(R" dependz on your
point of view. If yo ass be a programmer, you probably would tend towardz seeing
each element up in tha sequences as one unit, or \*(L"character\*(R".  However from
the userz point of view, tha whole sequence could be peeped as one
\&\*(L"character\*(R" since thatz probably what tha fuck it be lookin like up in tha context of the
userz language.  In dis document, we take tha programmerz point of
view: one \*(L"character\*(R" is one Unicode code point.
.PP
For some combinationz of base characta n' modifiers, there are
\&\fIprecomposed\fR characters.  There be a single characta equivalent, for
example, ta tha sequence \f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR followed by
\&\f(CW\*(C`COMBINING ACUTE ACCENT\*(C'\fR.  It be called  \f(CW\*(C`LATIN CAPITAL LETTER A WITH
ACUTE\*(C'\fR.  These precomposed charactas are, however, only available for
some combinations, n' is mainly meant ta support round-trip
conversions between Unicode n' legacy standardz (like \s-1ISO 8859\s0).  Using
sequences, as Unicode do, allows fo' needin fewer basic buildin blocks
(code points) ta express nuff mo' potential grapheme clusters.  To
support conversion between equivalent forms, various \fInormalization
forms\fR is also defined. Y'all KNOW dat shit, muthafucka!  Thus, \f(CW\*(C`LATIN CAPITAL LETTER A WITH ACUTE\*(C'\fR is
in \fINormalization Form Composed\fR, (abbreviated \s-1NFC\s0), n' tha sequence
\&\f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR followed by \f(CW\*(C`COMBINING ACUTE ACCENT\*(C'\fR
represents tha same ol' dirty characta up in \fINormalization Form Decomposed\fR (\s-1NFD\s0).
.PP
Because of backward compatibilitizzle wit legacy encodings, tha \*(L"a unique
number fo' every last muthafuckin character\*(R" scam breaks down a funky-ass bit: instead, there is
\&\*(L"at least one number fo' every last muthafuckin character\*(R".  Da same characta could
be represented differently up in nuff muthafuckin legacy encodings.  The
converse aint also true: some code points aint gots a assigned
character n' shit.  Firstly, there be unallocated code points within
otherwise used blocks.  Secondly, there be special Unicode control
charactas dat do not represent legit characters.
.PP
When Unicode was first conceived, dat shiznit was thought dat all tha ghetto's
charactas could be represented rockin a 16\-bit word; dat be a maximum of
\&\f(CW0x10000\fR (or 65536) charactas from \f(CW0x0000\fR ta \f(CW0xFFFF\fR would be
needed. Y'all KNOW dat shit, muthafucka!  This soon proved ta be false, n' since Unicode 2.0 (July
1996), Unicode has been defined all tha way up ta 21 bits (\f(CW0x10FFFF\fR),
and Unicode 3.1 (March 2001) defined tha straight-up original gangsta charactas above \f(CW0xFFFF\fR.
Da first \f(CW0x10000\fR charactas is called tha \fIPlane 0\fR, or the
\&\fIBasic Multilingual Plane\fR (\s-1BMP\s0).  With Unicode 3.1, 17 (yes,
seventeen) planes up in all was defined\*(--but they is nowhere near full of
defined characters, yet.
.PP
When a freshly smoked up language is bein encoded, Unicode generally will chizzle a
\&\f(CW\*(C`block\*(C'\fR of consecutizzle unallocated code points fo' its characters.  So
far, tha number of code points up in these blocks has always been evenly
divisible by 16.  Extras up in a funky-ass block, not currently needed, is left
unallocated, fo' future growth.  But there done been occasions when
a lata relase needed mo' code points than tha available extras, n' a
new block had ta allocated somewhere else, not contiguous ta tha initial
one, ta handle tha overflow.  Thus, it became apparent early on that
\&\*(L"block\*(R" wasn't a adequate organizin principal, n' so tha \f(CW\*(C`Script\*(C'\fR
property was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Lata a improved script property was added as
well, tha \f(CW\*(C`Script_Extensions\*(C'\fR property.)  Those code points dat is in
overflow blocks can still
have tha same script as tha original gangsta ones.  Da script concept fits more
closely wit natural language: there is \f(CW\*(C`Latin\*(C'\fR script, \f(CW\*(C`Greek\*(C'\fR
script, n' so on; n' there be nuff muthafuckin artificial scripts, like
\&\f(CW\*(C`Common\*(C'\fR fo' charactas dat is used up in multiple scripts, such as
mathematical symbols.  Scripts probably span varied partz of several
blocks.  For mo' shiznit bout scripts, peep \*(L"Scripts\*(R" up in perlunicode.
Da division tha fuck into blocks exists yo, but it be almost straight-up
accidental\*(--an artifact of how tha fuck tha charactas done been n' still are
allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Note dat dis paragraph has oversimplified thangs fo' the
sake of dis bein a introduction. I aint talkin' bout chicken n' gravy biatch.  Unicode don't straight-up encode
languages yo, but tha freestylin systems fo' them\*(--their scripts; n' one
script can be used by nuff languages.  Unicode also encodes thangs that
aren't straight-up bout languages, like fuckin symbols like \f(CW\*(C`BAGGAGE CLAIM\*(C'\fR.)
.PP
Da Unicode code points is just abstract numbers.  To input and
output these abstract numbers, tha numbers must be \fIencoded\fR or
\&\fIserialised\fR somehow.  Unicode defines nuff muthafuckin \fIcharacta encoding
forms\fR, of which \fI\s-1UTF\-8\s0\fR is like da most thugged-out popular. Shiiit, dis aint no joke.  \s-1UTF\-8\s0 be a
variable length encodin dat encodes Unicode charactas as 1 ta 6
bytes.  Other encodings
include \s-1UTF\-16\s0 n' \s-1UTF\-32\s0 n' they big\- n' lil-endian variants
(\s-1UTF\-8\s0 is byte-order independent).  Da \s-1ISO/IEC 10646\s0 defines tha \s-1UCS\-2\s0
and \s-1UCS\-4\s0 encodin forms.
.PP
For mo' shiznit bout encodings\*(--for instance, ta learn what
\&\fIsurrogates\fR n' \fIbyte order marks\fR (BOMs) are\*(--see perlunicode.
.SS "Perlz Unicode Support"
.IX Subsection "Perlz Unicode Support"
Startin from Perl v5.6.0, Perl has had tha capacitizzle ta handle Unicode
natively.  Perl v5.8.0, however, is tha straight-up original gangsta recommended release for
serious Unicode work.  Da maintenizzle release 5.6.1 fixed nuff of the
problemz of tha initial Unicode implementation yo, but fo' example
regular expressions still do not work wit Unicode up in 5.6.1.
Perl v5.14.0 is tha straight-up original gangsta release where Unicode support is
(almost) seamlessly integrable without some gotchas (the exception being
some differences up in quotemeta, which is fixed
startin up in Perl 5.16.0).   To enable this
seamless support, you should \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (which is
automatically selected if you \f(CW\*(C`use 5.012\*(C'\fR or higher).  See feature.
(5.14 also fixes a fuckin shitload of bugs n' departures from tha Unicode
standard.)
.PP
Before Perl v5.8.0, tha use of \f(CW\*(C`use utf8\*(C'\fR was used ta declare
that operations up in tha current block or file would be Unicode-aware.
This model was found ta be wrong, or at least clumsy: tha \*(L"Unicodeness\*(R"
is now carried wit tha data, instead of bein attached ta the
operations.
Startin wit Perl v5.8.0, only one case remains where a explicit \f(CW\*(C`use
utf8\*(C'\fR is needed: if yo' Perl script itself is encoded up in \s-1UTF\-8,\s0 you can
use \s-1UTF\-8\s0 up in yo' identifier names, n' up in strang n' regular expression
literals, by sayin \f(CW\*(C`use utf8\*(C'\fR.  This aint tha default cuz
scripts wit legacy 8\-bit data up in dem would break.  See utf8.
.SS "Perlz Unicode Model"
.IX Subsection "Perlz Unicode Model"
Perl supports both pre\-5.6 stringz of eight-bit natizzle bytes, and
stringz of Unicode characters.  Da general principle is dat Perl tries
to keep its data as eight-bit bytes fo' as long as possible yo, but as soon
as Unicodenizz cannot be avoided, tha data is transparently upgraded
to Unicode.  Prior ta Perl v5.14.0, tha upgrade was not straight-up
transparent (see \*(L"Da \*(R"Unicode Bug"" up in perlunicode), n' fo' backwards
compatibility, full transparency aint gained unless \f(CW\*(C`use feature
\&\*(Aqunicode_strings\*(Aq\*(C'\fR (see feature) or \f(CW\*(C`use 5.012\*(C'\fR (or higher) is
selected.
.PP
Internally, Perl currently uses either whatever tha natizzle eight-bit
characta set of tha platform (for example Latin\-1) is, defaultin to
\&\s-1UTF\-8,\s0 ta encode Unicode strings. Right back up in yo muthafuckin ass. Specifically, if all code points in
the strang is \f(CW0xFF\fR or less, Perl uses tha natizzle eight-bit
characta set.  Otherwise, it uses \s-1UTF\-8.\s0
.PP
A user of Perl do not normally need ta know nor care how tha fuck Perl
happens ta encode its internal strings yo, but it becomes relevant when
outputtin Unicode strings ta a stream without a PerlIO layer (one with
the \*(L"default\*(R" encoding).  In such a cold-ass lil case, tha raw bytes used internally
(the natizzle characta set or \s-1UTF\-8,\s0 as appropriate fo' each string)
will be used, n' a \*(L"Wide character\*(R" warnin is ghon be issued if them
strings contain a cold-ass lil characta beyond 0x00FF.
.PP
For example,
.PP
.Vb 1
\&      perl \-e \*(Aqprint "\ex{DF}\en", "\ex{0100}\ex{DF}\en"\*(Aq
.Ve
.PP
produces a gangbangin' fairly useless mixture of natizzle bytes n' \s-1UTF\-8,\s0 as well
as a warning:
.PP
.Vb 1
\&     Wide characta up in print at ...
.Ve
.PP
To output \s-1UTF\-8,\s0 use tha \f(CW\*(C`:encoding\*(C'\fR or \f(CW\*(C`:utf8\*(C'\fR output layer n' shit.  Prepending
.PP
.Vb 1
\&      binmode(STDOUT, ":utf8");
.Ve
.PP
to dis sample program ensures dat tha output is straight-up \s-1UTF\-8,\s0
and removes tha programz warning.
.PP
Yo ass can enable automatic UTF\-8\-ification of yo' standard file
handles, default \f(CW\*(C`open()\*(C'\fR layer, n' \f(CW@ARGV\fR by rockin either
the \f(CW\*(C`\-C\*(C'\fR command line switch or tha \f(CW\*(C`PERL_UNICODE\*(C'\fR environment
variable, peep perlrun fo' tha documentation of tha \f(CW\*(C`\-C\*(C'\fR switch.
.PP
Note dat dis means dat Perl expects other software ta work tha same
way:
if Perl has been hustled ta believe dat \s-1STDIN\s0 should be \s-1UTF\-8,\s0 but then
\&\s-1STDIN\s0 comin up in from another command aint \s-1UTF\-8,\s0 Perl will likely
diss bout tha malformed \s-1UTF\-8.\s0
.PP
All features dat combine Unicode n' I/O also require rockin tha new
PerlIO feature.  Almost all Perl 5.8 platforms do use PerlIO, though:
you can peep whether yours is by hustlin \*(L"perl \-V\*(R" n' lookin for
\&\f(CW\*(C`useperlio=define\*(C'\fR.
.SS "Unicode n' \s-1EBCDIC\s0"
.IX Subsection "Unicode n' EBCDIC"
Perl 5.8.0 also supports Unicode on \s-1EBCDIC\s0 platforms.  There,
Unicode support is somewhat mo' complex ta implement since
additionizzle conversions is needed at every last muthafuckin step.
.PP
Lata Perl releases have added code dat aint gonna work on \s-1EBCDIC\s0 platforms, and
no one has complained, so tha divergence has continued. Y'all KNOW dat shit, muthafucka!  If you wanna run
Perl on a \s-1EBCDIC\s0 platform, bust email ta perlbug@perl.org
.PP
On \s-1EBCDIC\s0 platforms, tha internal Unicode encodin form is UTF-EBCDIC
instead of \s-1UTF\-8. \s0 Da difference is dat as \s-1UTF\-8\s0 is \*(L"ASCII-safe\*(R" in
that \s-1ASCII\s0 charactas encode ta \s-1UTF\-8\s0 as-is, while UTF-EBCDIC is
\&\*(L"EBCDIC-safe\*(R".
.SS "Creatin Unicode"
.IX Subsection "Creatin Unicode"
To create Unicode charactas up in literals fo' code points above \f(CW0xFF\fR,
use tha \f(CW\*(C`\ex{...}\*(C'\fR notation up in double-quoted strings:
.PP
.Vb 1
\&    mah $smiley = "\ex{263a}";
.Ve
.PP
Similarly, it can be used up in regular expression literals
.PP
.Vb 1
\&    $smiley =~ /\ex{263a}/;
.Ve
.PP
At run-time you can use \f(CW\*(C`chr()\*(C'\fR:
.PP
.Vb 1
\&    mah $hebrew_alef = chr(0x05d0);
.Ve
.PP
See \*(L"Further Resources\*(R" fo' how tha fuck ta find all these numeric codes.
.PP
Naturally, \f(CW\*(C`ord()\*(C'\fR will do tha reverse: it turns a cold-ass lil characta into
a code point.
.PP
Note dat \f(CW\*(C`\ex..\*(C'\fR (no \f(CW\*(C`{}\*(C'\fR n' only two hexadecimal digits), \f(CW\*(C`\ex{...}\*(C'\fR,
and \f(CW\*(C`chr(...)\*(C'\fR fo' arguments less than \f(CW0x100\fR (decimal 256)
generate a eight-bit characta fo' backward compatibilitizzle wit older
Perls.  For argumentz of \f(CW0x100\fR or more, Unicode charactas are
always produced. Y'all KNOW dat shit, muthafucka! If you wanna force tha thang of Unicode
charactas regardless of tha numeric value, use \f(CW\*(C`pack("U", ...)\*(C'\fR
instead of \f(CW\*(C`\ex..\*(C'\fR, \f(CW\*(C`\ex{...}\*(C'\fR, or \f(CW\*(C`chr()\*(C'\fR.
.PP
Yo ass can invoke characters
by name up in double-quoted strings:
.PP
.Vb 1
\&    mah $arabic_alef = "\eN{ARABIC LETTER ALEF}";
.Ve
.PP
And, as mentioned above, you can also \f(CW\*(C`pack()\*(C'\fR numbers tha fuck into Unicode
characters:
.PP
.Vb 1
\&   mah $georgian_an  = pack("U", 0x10a0);
.Ve
.PP
Note dat both \f(CW\*(C`\ex{...}\*(C'\fR n' \f(CW\*(C`\eN{...}\*(C'\fR is compile-time string
constants: you cannot use variablez up in em.  if you want similar
run-time functionality, use \f(CW\*(C`chr()\*(C'\fR n' \f(CW\*(C`charnames::string_vianame()\*(C'\fR.
.PP
If you wanna force tha result ta Unicode characters, use tha special
\&\f(CW"U0"\fR prefix.  It consumes no arguments but causes tha followin bytes
to be interpreted as tha \s-1UTF\-8\s0 encodin of Unicode characters:
.PP
.Vb 1
\&   mah $chars = pack("U0W*", 0x80, 0x42);
.Ve
.PP
Likewise, you can stop such \s-1UTF\-8\s0 interpretation by rockin tha special
\&\f(CW"C0"\fR prefix.
.SS "Handlin Unicode"
.IX Subsection "Handlin Unicode"
Handlin Unicode is fo' da most thugged-out part transparent: just use the
strings as usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Functions like \f(CW\*(C`index()\*(C'\fR, \f(CW\*(C`length()\*(C'\fR, and
\&\f(CW\*(C`substr()\*(C'\fR will work on tha Unicode characters; regular expressions
will work on tha Unicode charactas (see perlunicode n' perlretut).
.PP
Note dat Perl considaz grapheme clustas ta be separate characters, so for
example
.PP
.Vb 2
\& print length("\eN{LATIN CAPITAL LETTER A}\eN{COMBINING ACUTE ACCENT}"),
\&       "\en";
.Ve
.PP
will print 2, not 1.  Da only exception is dat regular expressions
have \f(CW\*(C`\eX\*(C'\fR fo' matchin a extended grapheme clusta n' shit.  (Thus \f(CW\*(C`\eX\*(C'\fR up in a
regular expression would match tha entire sequence of both tha example
characters.)
.PP
Life aint like so transparent, however, when hustlin wit legacy
encodings, I/O, n' certain special cases:
.SS "Legacy Encodings"
.IX Subsection "Legacy Encodings"
When you combine legacy data n' Unicode, tha legacy data needs
to be upgraded ta Unicode.  Normally tha legacy data be assumed ta be
\&\s-1ISO 8859\-1 \s0(or \s-1EBCDIC,\s0 if applicable).
.PP
Da \f(CW\*(C`Encode\*(C'\fR module knows bout nuff encodings n' has intercourses
for bustin conversions between dem encodings:
.PP
.Vb 2
\&    use Encode \*(Aqdecode\*(Aq;
\&    $data = decode("iso\-8859\-3", $data); # convert from legacy ta utf\-8
.Ve
.SS "Unicode I/O"
.IX Subsection "Unicode I/O"
Normally, freestylin up Unicode data
.PP
.Vb 1
\&    print FH $some_string_with_unicode, "\en";
.Ve
.PP
produces raw bytes dat Perl happens ta use ta internally encode the
Unicode string.  Perlz internal encodin dependz on tha system as
well as what tha fuck charactas happen ta be up in tha strang all up in tha time. If
any of tha charactas is at code points \f(CW0x100\fR or above, yo big-ass booty is ghon get
a warning.  To ensure dat tha output is explicitly rendered up in the
encodin you desire\*(--and ta avoid tha warning\*(--open tha stream with
the desired encoding. Right back up in yo muthafuckin ass. Some examples:
.PP
.Vb 1
\&    open FH, ">:utf8", "file";
\&
\&    open FH, ">:encoding(ucs2)",      "file";
\&    open FH, ">:encoding(UTF\-8)",     "file";
\&    open FH, ">:encoding(shift_jis)", "file";
.Ve
.PP
and on already open streams, use \f(CW\*(C`binmode()\*(C'\fR:
.PP
.Vb 1
\&    binmode(STDOUT, ":utf8");
\&
\&    binmode(STDOUT, ":encoding(ucs2)");
\&    binmode(STDOUT, ":encoding(UTF\-8)");
\&    binmode(STDOUT, ":encoding(shift_jis)");
.Ve
.PP
Da matchin of encodin names is loose: case do not matter, and
many encodings have nuff muthafuckin aliases.  Note dat tha \f(CW\*(C`:utf8\*(C'\fR layer
must always be specified exactly like that; it is \fInot\fR subject to
the loose matchin of encodin names fo' realz. Also note dat currently \f(CW\*(C`:utf8\*(C'\fR is unsafe for
input, cuz it accepts tha data without valipimpin dat it is indeed valid
\&\s-1UTF\-8\s0; you should instead use \f(CW\*(C`:encoding(utf\-8)\*(C'\fR (with or without a
hyphen).
.PP
See PerlIO fo' tha \f(CW\*(C`:utf8\*(C'\fR layer, PerlIO::encodin and
Encode::PerlIO fo' tha \f(CW\*(C`:encoding()\*(C'\fR layer, and
Encode::Supported fo' nuff encodings supported by tha \f(CW\*(C`Encode\*(C'\fR
module.
.PP
Readin up in a gangbangin' file dat you know happens ta be encoded up in one of the
Unicode or legacy encodings do not magically turn tha data into
Unicode up in Perlz eyes.  To do that, specify tha appropriate
layer when openin files
.PP
.Vb 2
\&    open(my $fh,\*(Aq<:encoding(utf8)\*(Aq, \*(Aqanything\*(Aq);
\&    mah $line_of_unicode = <$fh>;
\&
\&    open(my $fh,\*(Aq<:encoding(Big5)\*(Aq, \*(Aqanything\*(Aq);
\&    mah $line_of_unicode = <$fh>;
.Ve
.PP
Da I/O layers can also be specified mo' flexibly with
the \f(CW\*(C`open\*(C'\fR pragma.  See open, or peep tha followin example.
.PP
.Vb 8
\&    use open \*(Aq:encoding(utf8)\*(Aq; # input/output default encodin will be
\&                                # UTF\-8
\&    open X, ">file";
\&    print X chr(0x100), "\en";
\&    close X;
\&    open Y, "<file";
\&    printf "%#x\en", ord(<Y>); # dis should print 0x100
\&    close Y;
.Ve
.PP
With tha \f(CW\*(C`open\*(C'\fR pragma you can use tha \f(CW\*(C`:locale\*(C'\fR layer
.PP
.Vb 10
\&    BEGIN { $ENV{LC_ALL} = $ENV{LANG} = \*(Aqru_RU.KOI8\-R\*(Aq }
\&    # tha :locale will probe tha locale environment variablez like
\&    # LC_ALL
\&    use open OUT => \*(Aq:locale\*(Aq; # russki parusski
\&    open(O, ">koi8");
\&    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8\-R 0xc1
\&    close O;
\&    open(I, "<koi8");
\&    printf "%#x\en", ord(<I>), "\en"; # dis should print 0xc1
\&    close I;
.Ve
.PP
These methodz install a transparent filta on tha I/O stream that
converts data from tha specified encodin when it is read up in from the
stream.  Da result be always Unicode.
.PP
Da open pragma affects all tha \f(CW\*(C`open()\*(C'\fR calls afta tha pragma by
settin default layers.  If you wanna affect only certain
streams, use explicit layers directly up in tha \f(CW\*(C`open()\*(C'\fR call.
.PP
Yo ass can switch encodings on a already opened stream by using
\&\f(CW\*(C`binmode()\*(C'\fR; peep \*(L"binmode\*(R" up in perlfunc.
.PP
Da \f(CW\*(C`:locale\*(C'\fR do not currently work with
\&\f(CW\*(C`open()\*(C'\fR n' \f(CW\*(C`binmode()\*(C'\fR, only wit tha \f(CW\*(C`open\*(C'\fR pragma.  The
\&\f(CW\*(C`:utf8\*(C'\fR n' \f(CW\*(C`:encoding(...)\*(C'\fR methodz do work wit all of \f(CW\*(C`open()\*(C'\fR,
\&\f(CW\*(C`binmode()\*(C'\fR, n' tha \f(CW\*(C`open\*(C'\fR pragma.
.PP
Similarly, you may use these I/O layers on output streams to
automatically convert Unicode ta tha specified encodin when it is
written ta tha stream. For example, tha followin snippet copies the
contentz of tha file \*(L"text.jis\*(R" (encoded as \s-1ISO\-2022\-JP,\s0 aka \s-1JIS\s0) to
the file \*(L"text.utf8\*(R", encoded as \s-1UTF\-8:\s0
.PP
.Vb 3
\&    open(my $nihongo, \*(Aq<:encoding(iso\-2022\-jp)\*(Aq, \*(Aqtext.jis\*(Aq);
\&    open(my $unicode, \*(Aq>:utf8\*(Aq,                  \*(Aqtext.utf8\*(Aq);
\&    while (<$nihongo>) { print $unicode $_ }
.Ve
.PP
Da namin of encodings, both by tha \f(CW\*(C`open()\*(C'\fR n' by tha \f(CW\*(C`open\*(C'\fR
pragma allows fo' flexible names: \f(CW\*(C`koi8\-r\*(C'\fR n' \f(CW\*(C`KOI8R\*(C'\fR will both be
understood.
.PP
Common encodings recognized by \s-1ISO, MIME, IANA,\s0 n' various other
standardisation organisations is recognised; fo' a mo' detailed
list peep Encode::Supported.
.PP
\&\f(CW\*(C`read()\*(C'\fR readz charactas n' returns tha number of characters.
\&\f(CW\*(C`seek()\*(C'\fR n' \f(CW\*(C`tell()\*(C'\fR operate on byte counts, as do \f(CW\*(C`sysread()\*(C'\fR
and \f(CW\*(C`sysseek()\*(C'\fR.
.PP
Notice dat cuz of tha default behaviour of not bustin any
conversion upon input if there is no default layer,
it is easy as fuck  ta mistakenly write code dat keeps on expandin a gangbangin' file
by repeatedly encodin tha data:
.PP
.Vb 8
\&    # BAD CODE WARNING
\&    open F, "file";
\&    local $/; ## read up in tha whole file of 8\-bit characters
\&    $t = <F>;
\&    close F;
\&    open F, ">:encoding(utf8)", "file";
\&    print F $t; ## convert ta UTF\-8 on output
\&    close F;
.Ve
.PP
If you run dis code twice, tha contentz of tha \fIfile\fR is ghon be twice
\&\s-1UTF\-8\s0 encoded. Y'all KNOW dat shit, muthafucka!  A \f(CW\*(C`use open \*(Aq:encoding(utf8)\*(Aq\*(C'\fR would have avoided the
bug, or explicitly openin also tha \fIfile\fR fo' input as \s-1UTF\-8.\s0
.PP
\&\fB\s-1NOTE\s0\fR: tha \f(CW\*(C`:utf8\*(C'\fR n' \f(CW\*(C`:encoding\*(C'\fR features work only if your
Perl has been built wit tha freshly smoked up PerlIO feature (which is tha default
on most systems).
.SS "Displayin Unicode As Text"
.IX Subsection "Displayin Unicode As Text"
Sometimes you might wanna display Perl scalars containin Unicode as
simple \s-1ASCII \s0(or \s-1EBCDIC\s0) text.  Da followin subroutine converts
its argument so dat Unicode charactas wit code points pimped outa than
255 is displayed as \f(CW\*(C`\ex{...}\*(C'\fR, control charactas (like \f(CW\*(C`\en\*(C'\fR) are
displayed as \f(CW\*(C`\ex..\*(C'\fR, n' tha rest of tha charactas as theyselves:
.PP
.Vb 9
\& sub sick_strin {
\&     join("",
\&       map { $_ > 255 , biatch?                  # if wide character...
\&              sprintf("\e\ex{%04X}", $_) :  # \ex{...}
\&              chr($_) =~ /[[:cntrl:]]/ , biatch?  # else if control character...
\&              sprintf("\e\ex%02X", $_) :    # \ex..
\&              quotemeta(chr($_))          # else quoted or as theyselves
\&         } unpack("W*", $_[0]));           # unpack Unicode characters
\&   }
.Ve
.PP
For example,
.PP
.Vb 1
\&   sick_string("foo\ex{100}bar\en")
.Ve
.PP
returns tha string
.PP
.Vb 1
\&   \*(Aqfoo\ex{0100}bar\ex0A\*(Aq
.Ve
.PP
which is locked n loaded ta be printed.
.SS "Special Cases"
.IX Subsection "Special Cases"
.IP "\(bu" 4
Bit Complement Operator ~ And \fIvec()\fR
.Sp
Da bit complement operator \f(CW\*(C`~\*(C'\fR may produce surprisin thangs up in dis biatch if
used on strings containin charactas wit ordinal joints above
255. In such a cold-ass lil case, tha thangs up in dis biatch is consistent wit tha internal
encodin of tha charactas yo, but not wit much else. Right back up in yo muthafuckin ass. So don't do
dat shit. Right back up in yo muthafuckin ass. Similarly fo' \f(CW\*(C`vec()\*(C'\fR: yo big-ass booty is ghon be operatin on the
internally-encoded bit patternz of tha Unicode characters, not on
the code point joints, which is straight-up probably not what tha fuck you want.
.IP "\(bu" 4
Peekin At Perlz Internal Encoding
.Sp
Normal playaz of Perl should never care how tha fuck Perl encodes any particular
Unicode strang (because tha aiiight ways ta git all up in tha contentz of a
strin wit Unicode\*(--via input n' output\*(--should always be via
explicitly-defined I/O layers). But if you must, there be two
wayz of lookin behind tha scenes.
.Sp
One way of peekin inside tha internal encodin of Unicode characters
is ta use \f(CW\*(C`unpack("C*", ...\*(C'\fR ta git tha bytez of whatever tha string
encodin happens ta be, or \f(CW\*(C`unpack("U0..", ...)\*(C'\fR ta git tha bytez of the
\&\s-1UTF\-8\s0 encoding:
.Sp
.Vb 2
\&    # dis prints  c4 80  fo' tha UTF\-8 bytes 0xc4 0x80
\&    print join(" ", unpack("U0(H2)*", pack("U", 0x100))), "\en";
.Ve
.Sp
Yet another way would be ta use tha Devel::Peek module:
.Sp
.Vb 1
\&    perl \-MDevel::Peek \-e \*(AqDump(chr(0x100))\*(Aq
.Ve
.Sp
That shows tha \f(CW\*(C`UTF8\*(C'\fR flag up in \s-1FLAGS\s0 n' both tha \s-1UTF\-8\s0 bytes
and Unicode charactas up in \f(CW\*(C`PV\*(C'\fR.  See also lata up in dis document
the rap bout tha \f(CW\*(C`utf8::is_utf8()\*(C'\fR function.
.SS "Advanced Topics"
.IX Subsection "Advanced Topics"
.IP "\(bu" 4
Strin Equivalence
.Sp
Da question of strang equivalence turns somewhat fucked up
in Unicode: what tha fuck do you mean by \*(L"equal\*(R"?
.Sp
(Is \f(CW\*(C`LATIN CAPITAL LETTER A WITH ACUTE\*(C'\fR equal to
\&\f(CW\*(C`LATIN CAPITAL LETTER A\*(C'\fR?)
.Sp
Da short answer is dat by default Perl compares equivalence (\f(CW\*(C`eq\*(C'\fR,
\&\f(CW\*(C`ne\*(C'\fR) based only on code pointz of tha characters.  In tha above
case, tha answer is no (because 0x00C1 != 0x0041).  But sometimes, any
\&\s-1CAPITAL LETTER A\s0z should be considered equal, or even Az of any case.
.Sp
Da long answer is dat you need ta consider characta normalization
and casin issues: peep Unicode::Normalize, Unicode Technical Report #15,
Unicode Normalization Forms <http://www.unicode.org/unicode/reports/tr15> and
sections on case mappin up in tha Unicode Standard <http://www.unicode.org>.
.Sp
Az of Perl 5.8.0, tha \*(L"Full\*(R" case-foldin of \fICase
Mappings/SpecialCasing\fR is implemented yo, but bugs remain up in \f(CW\*(C`qr//i\*(C'\fR wit them,
mostly fixed by 5.14.
.IP "\(bu" 4
Strin Collation
.Sp
Muthafuckas like ta peep they strings sickly sorted\*(--or as Unicode
parlizzle goes, collated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  But again, what tha fuck do you mean by collate?
.Sp
(Do \f(CW\*(C`LATIN CAPITAL LETTER A WITH ACUTE\*(C'\fR come before or after
\&\f(CW\*(C`LATIN CAPITAL LETTER A WITH GRAVE\*(C'\fR?)
.Sp
Da short answer is dat by default, Perl compares strings (\f(CW\*(C`lt\*(C'\fR,
\&\f(CW\*(C`le\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`gt\*(C'\fR) based only on tha code pointz of the
characters.  In tha above case, tha answer is \*(L"after\*(R", since
\&\f(CW0x00C1\fR > \f(CW0x00C0\fR.
.Sp
Da long answer is dat \*(L"it depends\*(R", n' a phat answer cannot be
given without knowin (at tha straight-up least) tha language context.
See Unicode::Collate, n' \fIUnicode Collation Algorithm\fR
<http://www.unicode.org/unicode/reports/tr10/>
.SS "Miscellaneous"
.IX Subsection "Miscellaneous"
.IP "\(bu" 4
Characta Ranges n' Classes
.Sp
Characta ranges up in regular expression bracketed characta classes ( e.g.,
\&\f(CW\*(C`/[a\-z]/\*(C'\fR) n' up in tha \f(CW\*(C`tr///\*(C'\fR (also known as \f(CW\*(C`y///\*(C'\fR) operator is not
magically Unicode-aware.  What dis means is dat \f(CW\*(C`[A\-Za\-z]\*(C'\fR will not
magically start ta mean \*(L"all alphabetic letters\*(R" (not dat it do mean that
even fo' 8\-bit characters; fo' them, if yo ass is rockin localez (perllocale),
use \f(CW\*(C`/[[:alpha:]]/\*(C'\fR; n' if not, use tha 8\-bit\-aware property \f(CW\*(C`\ep{alpha}\*(C'\fR).
.Sp
All tha propertizzles dat begin wit \f(CW\*(C`\ep\*(C'\fR (and its inverse \f(CW\*(C`\eP\*(C'\fR) is actually
characta classes dat is Unicode-aware.  There is dozenz of them, see
perluniprops.
.Sp
Yo ass can use Unicode code points as tha end pointz of characta ranges, n' the
range will include all Unicode code points dat lie between dem end points.
.IP "\(bu" 4
String-To-Number Conversions
.Sp
Unicode do define nuff muthafuckin other decimal\*(--and numeric\*(--characters
besides tha familiar 0 ta 9, like fuckin tha Arabic n' Indic digits.
Perl do not support string-to-number conversion fo' digits other
than \s-1ASCII 0\s0 ta 9 (and \s-1ASCII\s0 a ta f fo' hexadecimal).
To git safe conversions from any Unicode string, use
\&\*(L"\fInum()\fR\*(R" up in Unicode::UCD.
.SS "Thangs With Lyrics"
.IX Subsection "Thangs With Lyrics"
.IP "\(bu" 4
Will My fuckin Oldskool Scripts Break?
.Sp
Straight-up probably not.  Unless yo ass is generatin Unicode characters
somehow, oldschool behaviour should be preserved. Y'all KNOW dat shit, muthafucka!  Bout tha only behaviour
that has chizzled n' which could start generatin Unicode is tha old
behaviour of \f(CW\*(C`chr()\*(C'\fR where supplyin a argument mo' than 255
produced a cold-ass lil characta modulo 255.  \f(CW\*(C`chr(300)\*(C'\fR, fo' example, was equal
to \f(CW\*(C`chr(45)\*(C'\fR or \*(L"\-\*(R" (in \s-1ASCII\s0), now it is \s-1LATIN CAPITAL LETTER I WITH
BREVE.\s0
.IP "\(bu" 4
How tha fuck Do I Make My fuckin Scripts Work With Unicode?
.Sp
Straight-up lil work should be needed since not a god damn thang chizzlez until you
generate Unicode data.  Da most blingin thang is gettin input as
Unicode; fo' that, peep tha earlier I/O rap.
To git full seamless Unicode support, add
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (or \f(CW\*(C`use 5.012\*(C'\fR or higher) ta your
script.
.IP "\(bu" 4
How tha fuck Do I Know Whether My fuckin Strin Is In Unicode?
.Sp
Yo ass shouldn't gotta care.  But you may if yo' Perl is before 5.14.0
or you aint specified \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR or \f(CW\*(C`use
5.012\*(C'\fR (or higher) cuz otherwise tha semantics of tha code points
in tha range 128 ta 255 is different dependin on
whether tha strang they is contained within is up in Unicode or not.
(See \*(L"When Unicode Do Not Happen\*(R" up in perlunicode.)
.Sp
To determine if a strang is up in Unicode, use:
.Sp
.Vb 1
\&    print utf8::is_utf8($string) , biatch? 1 : 0, "\en";
.Ve
.Sp
But note dat dis don't mean dat any of tha charactas up in the
strin is necessary \s-1UTF\-8\s0 encoded, or dat any of tha charactas have
code points pimped outa than 0xFF (255) or even 0x80 (128), or dat the
strin has any charactas at all.  All tha \f(CW\*(C`is_utf8()\*(C'\fR do is to
return tha value of tha internal \*(L"utf8ness\*(R" flag attached ta the
\&\f(CW$string\fR.  If tha flag is off, tha bytes up in tha scalar is interpreted
as a single byte encoding.  If tha flag is on, tha bytes up in tha scalar
are interpreted as tha (variable-length, potentially multi-byte) \s-1UTF\-8\s0 encoded
code pointz of tha characters.  Bytes added ta a \s-1UTF\-8\s0 encoded strang are
automatically upgraded ta \s-1UTF\-8. \s0 If mixed non\-UTF\-8 n' \s-1UTF\-8\s0 scalars
are merged (double-quoted interpolation, explicit concatenation, or
printf/sprintf parameta substitution), tha result is ghon be \s-1UTF\-8\s0 encoded
as if copiez of tha byte strings was upgraded ta \s-1UTF\-8:\s0 fo' example,
.Sp
.Vb 3
\&    $a = "ab\ex80c";
\&    $b = "\ex{100}";
\&    print "$a = $b\en";
.Ve
.Sp
the output strang is ghon be UTF\-8\-encoded \f(CW\*(C`ab\ex80c = \ex{100}\en\*(C'\fR yo, but
\&\f(CW$a\fR will stay byte-encoded.
.Sp
Sometimes you might straight-up need ta know tha byte length of a string
instead of tha characta length. For dat use either the
\&\f(CW\*(C`Encode::encode_utf8()\*(C'\fR function or tha \f(CW\*(C`bytes\*(C'\fR pragma
and tha \f(CW\*(C`length()\*(C'\fR function:
.Sp
.Vb 8
\&    mah $unicode = chr(0x100);
\&    print length($unicode), "\en"; # will print 1
\&    require Encode;
\&    print length(Encode::encode_utf8($unicode)),"\en"; # will print 2
\&    use bytes;
\&    print length($unicode), "\en"; # will also print 2
\&                                  # (the 0xC4 0x80 of tha UTF\-8)
\&    no bytes;
.Ve
.IP "\(bu" 4
How tha fuck Do I Smoke Up What Encodin a File Has?
.Sp
Yo ass might try Encode::Guess yo, but it has a fuckin shitload of limitations.
.IP "\(bu" 4
How tha fuck Do I Detect Data Thatz Not Valid In a Particular Encoding?
.Sp
Use tha \f(CW\*(C`Encode\*(C'\fR package ta try convertin dat shit.
For example,
.Sp
.Vb 1
\&    use Encode \*(Aqdecode_utf8\*(Aq;
\&
\&    if (eval { decode_utf8($string, Encode::FB_CROAK); 1 }) {
\&        # $strin is valid utf8
\&    } else {
\&        # $strin aint valid utf8
\&    }
.Ve
.Sp
Or use \f(CW\*(C`unpack\*(C'\fR ta try decodin it:
.Sp
.Vb 2
\&    use warnings;
\&    @chars = unpack("C0U*", $string_of_bytes_that_I_think_is_utf8);
.Ve
.Sp
If invalid, a \f(CW\*(C`Malformed UTF\-8 character\*(C'\fR warnin is produced. Y'all KNOW dat shit, muthafucka! Da \*(L"C0\*(R" means
\&\*(L"process tha strang characta per character\*(R".  Without that, the
\&\f(CW\*(C`unpack("U*", ...)\*(C'\fR would work up in \f(CW\*(C`U0\*(C'\fR mode (the default if tha format
strin starts wit \f(CW\*(C`U\*(C'\fR) n' it would return tha bytes makin up tha \s-1UTF\-8\s0
encodin of tha target string, suttin' dat will always work.
.IP "\(bu" 4
How tha fuck Do I Convert Binary Data Into a Particular Encoding, Or Vice Versa?
.Sp
This probably aint as useful as you might think.
Normally, you shouldn't need to.
.Sp
In one sense, what tha fuck yo ass be askin don't make much sense: encodings
are fo' characters, n' binary data is not \*(L"characters\*(R", so converting
\&\*(L"data\*(R" tha fuck into some encodin aint meaningful unless you know up in what
characta set n' encodin tha binary data is in, up in which case it's
not just binary data, now is it?
.Sp
If you gotz a raw sequence of bytes dat you know should be
interpreted via a particular encoding, you can use \f(CW\*(C`Encode\*(C'\fR:
.Sp
.Vb 2
\&    use Encode \*(Aqfrom_to\*(Aq;
\&    from_to($data, "iso\-8859\-1", "utf\-8"); # from latin\-1 ta utf\-8
.Ve
.Sp
Da call ta \f(CW\*(C`from_to()\*(C'\fR chizzlez tha bytes up in \f(CW$data\fR yo, but nothing
material bout tha nature of tha strang has chizzled as far as Perl is
concerned. Y'all KNOW dat shit, muthafucka!  Both before n' afta tha call, tha strang \f(CW$data\fR
gotz nuff just a funky-ass bunch of 8\-bit bytes fo' realz. As far as Perl is concerned,
the encodin of tha strang remains as \*(L"system-natizzle 8\-bit bytes\*(R".
.Sp
Yo ass might relate dis ta a gangbangin' fictionizzle 'Translate' module:
.Sp
.Vb 4
\&   use Translate;
\&   mah $phrase = "Yes";
\&   Translate::from_to($phrase, \*(Aqenglish\*(Aq, \*(Aqdeutsch\*(Aq);
\&   ## phrase now gotz nuff "Ja"
.Ve
.Sp
Da contentz of tha strang chizzlez yo, but not tha nature of tha string.
Perl don't give a fuck any mo' afta tha call than before dat the
contentz of tha strang indicates tha affirmative.
.Sp
Back ta convertin data.  If you have (or want) data up in yo' system's
natizzle 8\-bit encodin (e.g. Latin\-1, \s-1EBCDIC,\s0 etc.), you can use
pack/unpack ta convert to/from Unicode.
.Sp
.Vb 2
\&    $native_strin  = pack("W*", unpack("U*", $Unicode_string));
\&    $Unicode_strin = pack("U*", unpack("W*", $native_string));
.Ve
.Sp
If you gotz a sequence of bytes you \fBknow\fR is valid \s-1UTF\-8,\s0
but Perl don't give a fuck it yet, you can make Perl a funky-ass believer, too:
.Sp
.Vb 2
\&    use Encode \*(Aqdecode_utf8\*(Aq;
\&    $Unicode = decode_utf8($bytes);
.Ve
.Sp
or:
.Sp
.Vb 1
\&    $Unicode = pack("U0a*", $bytes);
.Ve
.Sp
Yo ass can find tha bytes dat make up a \s-1UTF\-8\s0 sequence with
.Sp
.Vb 1
\&    @bytes = unpack("C*", $Unicode_string)
.Ve
.Sp
and you can create well-formed Unicode with
.Sp
.Vb 1
\&    $Unicode_strin = pack("U*", 0xff, ...)
.Ve
.IP "\(bu" 4
How tha fuck Do I Display Unicode, biatch?  How tha fuck Do I Input Unicode?
.Sp
See <http://www.alanwood.net/unicode/> and
<http://www.cl.cam.ac.uk/~mgk25/unicode.html>
.IP "\(bu" 4
How tha fuck Do Unicode Work With Traditionizzle Locales?
.Sp
Startin up in Perl 5.16, you can specify
.Sp
.Vb 1
\&    use locale \*(Aq:not_characters\*(Aq;
.Ve
.Sp
to git Perl ta work well wit tradtionizzle locales.  Da catch is dat you
have ta translate from tha locale characta set to/from Unicode
yo ass.  See \*(L"Unicode I/O\*(R" above fo' how tha fuck to
.Sp
.Vb 1
\&    use open \*(Aq:locale\*(Aq;
.Ve
.Sp
to accomplish dis yo, but full details is up in \*(L"Unicode and
\&\s-1UTF\-8\*(R"\s0 up in perllocale, includin gotchas dat happen if you don't specifiy
\&\f(CW\*(C`:not_characters\*(C'\fR.
.SS "Hexadecimal Notation"
.IX Subsection "Hexadecimal Notation"
Da Unicode standard prefers rockin hexadecimal notation cuz
that mo' clearly shows tha division of Unicode tha fuck into blockz of 256 characters.
Hexadecimal be also simply shorta than decimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Yo ass can use decimal
notation, too yo, but peepin' ta use hexadecimal just make game easier
with tha Unicode standard. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`U+HHHH\*(C'\fR notation uses hexadecimal,
for example.
.PP
Da \f(CW\*(C`0x\*(C'\fR prefix means a hexadecimal number, tha digits is 0\-9 \fIand\fR
a\-f (or A\-F, case don't matter).  Each hexadecimal digit represents
four bits, or half a funky-ass byte.  \f(CW\*(C`print 0x..., "\en"\*(C'\fR will show a
hexadecimal number up in decimal, n' \f(CW\*(C`printf "%x\en", $decimal\*(C'\fR will
show a thugged-out decimal number up in hexadecimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If you have just the
\&\*(L"hex digits\*(R" of a hexadecimal number, you can use tha \f(CW\*(C`hex()\*(C'\fR function.
.PP
.Vb 6
\&    print 0x0009, "\en";    # 9
\&    print 0x000a, "\en";    # 10
\&    print 0x000f, "\en";    # 15
\&    print 0x0010, "\en";    # 16
\&    print 0x0011, "\en";    # 17
\&    print 0x0100, "\en";    # 256
\&
\&    print 0x0041, "\en";    # 65
\&
\&    printf "%x\en",  65;    # 41
\&    printf "%#x\en", 65;    # 0x41
\&
\&    print hex("41"), "\en"; # 65
.Ve
.SS "Further Resources"
.IX Subsection "Further Resources"
.IP "\(bu" 4
Unicode Consortium
.Sp
<http://www.unicode.org/>
.IP "\(bu" 4
Unicode \s-1FAQ\s0
.Sp
<http://www.unicode.org/unicode/faq/>
.IP "\(bu" 4
Unicode Glossary
.Sp
<http://www.unicode.org/glossary/>
.IP "\(bu" 4
Unicode Recommended Readin List
.Sp
Da Unicode Consortium has a list of articlez n' books, a shitload of which
give a much mo' up in depth treatment of Unicode:
<http://unicode.org/resources/readinglist.html>
.IP "\(bu" 4
Unicode Useful Resources
.Sp
<http://www.unicode.org/unicode/onlinedat/resources.html>
.IP "\(bu" 4
Unicode n' Multilingual Support up in \s-1HTML,\s0 Fonts, Web Browsers n' Other Applications
.Sp
<http://www.alanwood.net/unicode/>
.IP "\(bu" 4
\&\s-1UTF\-8\s0 n' Unicode \s-1FAQ\s0 fo' Unix/Linux
.Sp
<http://www.cl.cam.ac.uk/~mgk25/unicode.html>
.IP "\(bu" 4
Legacy Characta Sets
.Sp
<http://www.czyborra.com/>
<http://www.eki.ee/letter/>
.IP "\(bu" 4
Yo ass can explore various shiznit from tha Unicode data filez using
the \f(CW\*(C`Unicode::UCD\*(C'\fR module.
.SH "UNICODE IN OLDER PERLS"
.IX Header "UNICODE IN OLDER PERLS"
If you cannot upgrade yo' Perl ta 5.8.0 or later, you can still
do some Unicode processin by rockin tha modulez \f(CW\*(C`Unicode::String\*(C'\fR,
\&\f(CW\*(C`Unicode::Map8\*(C'\fR, n' \f(CW\*(C`Unicode::Map\*(C'\fR, available from \s-1CPAN.\s0
If you have tha \s-1GNU\s0 recode installed, you can also use the
Perl front-end \f(CW\*(C`Convert::Recode\*(C'\fR fo' characta conversions.
.PP
Da followin is fast conversions from \s-1ISO 8859\-1 \s0(Latin\-1) bytes
to \s-1UTF\-8\s0 bytes n' back, tha code works even wit olda Perl 5 versions.
.PP
.Vb 2
\&    # ISO 8859\-1 ta UTF\-8
\&    s/([\ex80\-\exFF])/chr(0xC0|ord($1)>>6).chr(0x80|ord($1)&0x3F)/eg;
\&
\&    # UTF\-8 ta ISO 8859\-1
\&    s/([\exC2\exC3])([\ex80\-\exBF])/chr(ord($1)<<6&0xC0|ord($2)&0x3F)/eg;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunitut, perlunicode, Encode, open, utf8, bytes,
perlretut, perlrun, Unicode::Collate, Unicode::Normalize,
Unicode::UCD
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Thanks ta tha kind readaz of tha perl5\-porters@perl.org,
perl\-unicode@perl.org, linux\-utf8@nl.linux.org, n' unicore@unicode.org
mailin lists fo' they valuable feedback.
.SH "AUTHOR, COPYRIGHT, AND LICENSE"
.IX Header "AUTHOR, COPYRIGHT, AND LICENSE"
Copyright 2001\-2011 Jarkko Hietaniemi <jhi@iki.fi>
.PP
This document may be distributed under tha same terms as Perl itself.
