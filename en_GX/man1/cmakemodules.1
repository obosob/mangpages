.TH cmakemodulez 1 "February 11, 2014" "cmake 2.8.12.2"
.SH NAME
.PP
cmakemodulez \- Reference of available CMake modules.

.SH DESCRIPTION
.PP
Da "cmake" executable is tha CMake command\-line intercourse.  It may be used ta configure projects up in scripts, n' you can put dat on yo' toast.  Project configuration settings may be specified on tha command line wit tha \-D option. I aint talkin' bout chicken n' gravy biatch.  Da \-i option will cause cmake ta interactively prompt fo' such settings.

.PP
CMake be a cold-ass lil cross\-platform build system generator. Shiiit, dis aint no joke.  Projects specify they build process wit platform\-independent CMake listfilez included up in each directory of a source tree wit tha name CMakeLists.txt. Users build a project by rockin CMake ta generate a funky-ass build system fo' a natizzle tool on they platform.

.SH MODULES
.PP
Da followin modulez is provided wit CMake. They can be used wit INCLUDE(ModuleName).

.PP
.nf
  CMake Modulez \- Modulez comin wit CMake, tha Cross\-Platform Makefile Generator.
.fi

.PP
This is tha documentation fo' tha modulez n' scripts comin wit CMake. Usin these modulez you can check tha computa system fo' installed software packages, featurez of tha compila n' tha existence of headaz ta name just a gangbangin' few.

.TP
.B AddFileDependencies
ADD_FILE_DEPENDENCIES(source_file depend_files...)

Addz tha given filez as dependencies ta source_file


.TP
.B BundleUtilities
Functions ta help assemble a standalone bundle application.

A collection of CMake utilitizzle functions useful fo' dealin wit .app bundlez on tha Mac n' bundle\-like directories on any OS.


Da followin functions is provided by dis module:


.nf
   fixup_bundle
   copy_and_fixup_bundle
   verify_app
   get_bundle_main_executable
   get_dotapp_dir
   get_bundle_and_executable
   get_bundle_all_executables
   get_item_key
   clear_bundle_keys
   set_bundle_key_values
   get_bundle_keys
   copy_resolved_item_into_bundle
   copy_resolved_framework_into_bundle
   fixup_bundle_item
   verify_bundle_prerequisites
   verify_bundle_symlinks
.fi

Requires CMake 2.6 or pimped outa cuz it uses function, break n' PARENT_SCOPE fo' realz. Also dependz on GetPrerequisites.cmake.


.nf
  FIXUP_BUNDLE(<app> <libs> <dirs>)
.fi

Fix up a funky-ass bundle in\-place n' make it standalone, such dat it can be drag\-n\-drop copied ta another machine n' run on dat machine as long as all of tha system libraries is compatible.


If you pass plugins ta fixup_bundle as tha libs parameter, you should install dem or copy dem tha fuck into tha bundle before callin fixup_bundle. Da "libs" parameta be a list of libraries dat must be fixed up yo, but dat cannot be determined by otool output analysis. (i.e., plugins)


Gather all tha keys fo' all tha executablez n' libraries up in a funky-ass bundle, n' then, fo' each key, copy each prerequisite tha fuck into tha bundle. Then fix each one up accordin ta its own list of prerequisites.


Then clear all tha keys n' call verify_app on tha final bundle ta ensure dat it is truly standalone.


.nf
  COPY_AND_FIXUP_BUNDLE(<src> <dst> <libs> <dirs>)
.fi

Makes a cold-ass lil copy of tha bundle <src> at location <dst> n' then fixes up tha freshly smoked up copied bundle in\-place at <dst>...


.nf
  VERIFY_APP(<app>)
.fi

Verifies dat a application <app> appears valid based on hustlin analysis tools on dat shit. Calls "message(FATAL_ERROR" if tha application aint verified.


.nf
  GET_BUNDLE_MAIN_EXECUTABLE(<bundle> <result_var>)
.fi

Da result is ghon be tha full path name of tha bundlez main executable file or a "error:" prefixed strang if it could not be determined.


.nf
  GET_DOTAPP_DIR(<exe> <dotapp_dir_var>)
.fi

Returns tha nearest parent dir whose name endz wit ".app" given tha full path ta a executable. If there is no such parent dir, then simply return tha dir containin tha executable.


Da returned directory may or may not exist.


.nf
  GET_BUNDLE_AND_EXECUTABLE(<app> <bundle_var> <executable_var> <valid_var>)
.fi

Takes either a ".app" directory name or tha name of a executable nested inside a ".app" directory n' returns tha path ta tha ".app" directory up in <bundle_var> n' tha path ta its main executable up in <executable_var>


.nf
  GET_BUNDLE_ALL_EXECUTABLES(<bundle> <exes_var>)
.fi

Scans tha given bundle recursively fo' all executable filez n' accumulates dem tha fuck into a variable.


.nf
  GET_ITEM_KEY(<item> <key_var>)
.fi

Given a gangbangin' file (item) name, generate a key dat should be unique thankin bout tha set of libraries dat need copyin or fixin up ta cook up a funky-ass bundle standalone. This is essentially tha file name includin extension wit "." replaced by "_"


This key is used as a prefix fo' CMake variablez so dat we can associate a set of variablez wit a given item based on its key.


.nf
  CLEAR_BUNDLE_KEYS(<keys_var>)
.fi

Loop over tha list of keys, clearin all tha variablez associated wit each key fo' realz. Afta tha loop, clear tha list of keys itself.


Calla of get_bundle_keys should call clear_bundle_keys when done wit list of keys.


.nf
  SET_BUNDLE_KEY_VALUES(<keys_var> <context> <item> <exepath> <dirs>
                        <copyflag>)
.fi

Add a key ta tha list (if necessary) fo' tha given item. If added, also set all tha variablez associated wit dat key.


.nf
  GET_BUNDLE_KEYS(<app> <libs> <dirs> <keys_var>)
.fi

Loop over all tha executable n' library filez within tha bundle (and given as extra <libs>) n' accumulate a list of keys representin em. Right back up in yo muthafuckin ass. Set joints associated wit each key such dat we can loop over all of dem n' copy prerequisite libs tha fuck into tha bundle n' then do appropriate install_name_tool fixups.


.nf
  COPY_RESOLVED_ITEM_INTO_BUNDLE(<resolved_item> <resolved_embedded_item>)
.fi

Copy a resolved item tha fuck into tha bundle if necessary. Copy aint necessary if tha resolved_item is "the same as" tha resolved_embedded_item.


.nf
  COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE(<resolved_item> <resolved_embedded_item>)
.fi

Copy a resolved framework tha fuck into tha bundle if necessary. Copy aint necessary if tha resolved_item is "the same as" tha resolved_embedded_item.


By default, BU_COPY_FULL_FRAMEWORK_CONTENTS aint set. If you want full frameworks embedded up in yo' bundles, set BU_COPY_FULL_FRAMEWORK_CONTENTS ta ON before callin fixup_bundle. By default, COPY_RESOLVED_FRAMEWORK_INTO_BUNDLE copies tha framework dylib itself plus tha framework Resources directory.


.nf
  FIXUP_BUNDLE_ITEM(<resolved_embedded_item> <exepath> <dirs>)
.fi

Git tha direct/non\-system prerequisitez of tha resolved embedded item. For each prerequisite, chizzle tha way it is referenced ta tha value of tha _EMBEDDED_ITEM keyed variable fo' dat prerequisite. (Most likely changin ta a "@executable_path" steez reference.)


This function requires dat tha resolved_embedded_item be "inside" tha bundle already. In other lyrics, if you pass plugins ta fixup_bundle as tha libs parameter, you should install dem or copy dem tha fuck into tha bundle before callin fixup_bundle. Da "libs" parameta be a list of libraries dat must be fixed up yo, but dat cannot be determined by otool output analysis. (i.e., plugins)


Also, chizzle tha id of tha item bein fixed up ta its own _EMBEDDED_ITEM value.


Accumulate chizzlez up in a local variable n' make *one* call ta install_name_tool all up in tha end of tha function wit all tha chizzlez at once.


If tha BU_CHMOD_BUNDLE_ITEMS variable is set then bundle shit is ghon be marked writable before install_name_tool tries ta chizzle em.


.nf
  VERIFY_BUNDLE_PREREQUISITES(<bundle> <result_var> <info_var>)
.fi

Verifies dat tha sum of all prerequisitez of all filez inside tha bundle is contained within tha bundle or is "system" libraries, presumed ta exist all over dis biiiatch.


.nf
  VERIFY_BUNDLE_SYMLINKS(<bundle> <result_var> <info_var>)
.fi

Verifies dat any symlinks found up in tha bundle point ta other filez dat is already also up in tha bundle.. fo' realz. Anythang dat points ta a external file causes dis function ta fail tha verification.

.TP
.B CMakeAddFortranSubdirectory
Use MinGW gfortran from VS if a gangbangin' fortran compila aint found.

Da 'add_fortran_subdirectory' function addz a subdirectory ta a project dat gotz nuff a gangbangin' fortran only sub\-project. Da module will check tha current compila n' peep if it can support fortran. I aint talkin' bout chicken n' gravy biatch. If no fortran compila is found n' tha compila is MSVC, then dis module will find tha MinGW gfortran. I aint talkin' bout chicken n' gravy biatch.  It will then use a external project ta build wit tha MinGW tools.  It will also create imported targets fo' tha libraries pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This will only work if tha fortran code is built tha fuck into a thugged-out dll, so BUILD_SHARED_LIBS is turned on up in tha project.  In addizzle tha CMAKE_GNUtoMS option is set ta on, so dat tha MS .lib filez is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Usage be as bigs up:


.nf
  cmake_add_fortran_subdirectory(
   <subdir>                # name of subdirectory
   PROJECT <project_name>  # project name up in subdir top CMakeLists.txt
   ARCHIVE_DIR <dir>       # dir where project places .lib files
   RUNTIME_DIR <dir>       # dir where project places .dll files
   LIBRARIES <lib>...      # namez of library targets ta import
   LINK_LIBRARIES          # link intercourse libraries fo' LIBRARIES
    [LINK_LIBS <lib> <dep>...]...
   CMAKE_COMMAND_LINE ...  # extra command line flags ta pass ta cmake
   NO_EXTERNAL_INSTALL     # skip installation of external project
   )
.fi

Relatizzle paths up in ARCHIVE_DIR n' RUNTIME_DIR is interpreted wit respect ta tha build directory correspondin ta tha source directory up in which tha function is invoked.


Limitations:


NO_EXTERNAL_INSTALL is required fo' forward compatibilitizzle wit a gangbangin' future version dat supports installation of tha external project binaries durin "make install".

.TP
.B CMakeBackwardCompatibilityCXX
define a funky-ass bunch of backwardz compatibilitizzle variables

.nf
  CMAKE_ANSI_CXXFLAGS \- flag fo' ansi c++
  CMAKE_HAS_ANSI_STRING_STREAM \- has <strstream>
  include(TestForANSIStreamHeaders)
  include(CheckIncludeFileCXX)
  include(TestForSTDNamespace)
  include(TestForANSIForScope)
.fi

.TP
.B CMakeDependentOption
Macro ta provide a option dependent on other options.

This macro presents a option ta tha user only if a set of other conditions is true.  When tha option aint presented a thugged-out default value is used yo, but any value set by tha user is preserved fo' when tha option is presented again. I aint talkin' bout chicken n' gravy biatch. Example invocation:


.nf
  CMAKE_DEPENDENT_OPTION(USE_FOO "Use Foo" ON
                         "USE_BAR;NOT USE_ZOT" OFF)
.fi

If USE_BAR is legit n' USE_ZOT is false, dis serves up a option called USE_FOO dat defaults ta ON.  Otherwise, it sets USE_FOO ta OFF.  If tha statuz of USE_BAR or USE_ZOT eva chizzles, any value fo' tha USE_FOO option is saved so dat when tha option is re\-enabled it retains its oldschool value.

.TP
.B CMakeDetermineVSServicePack
Determine tha Visual Studio steez ounce ta tha bounce of tha 'cl' up in use.

Da functionalitizzle of dis module has been superseded by tha platform variable CMAKE_<LANG>_COMPILER_VERSION dat gotz nuff tha compila version number.


Usage:


.nf
  if(MSVC)
    include(CMakeDetermineVSServicePack)
    DetermineVSServicePack( my_service_pack )
    if( my_service_pack )
      message(STATUS "Detected: ${my_service_pack}")
    endif()
  endif()
.fi

Function DetermineVSServicePack sets tha given variable ta one of tha followin joints or a empty strang if unknown:


.nf
  vc80, vc80sp1
  vc90, vc90sp1
  vc100, vc100sp1
  vc110, vc110sp1, vc110sp2
.fi

.TP
.B CMakeExpandImportedTargets
.nf
 
.fi

CMAKE_EXPAND_IMPORTED_TARGETS(<var> LIBRARIES lib1 lib2...libN


.nf
                                     [CONFIGURATION <config>] )
.fi




CMAKE_EXPAND_IMPORTED_TARGETS() takes a list of libraries n' replaces all imported targets contained up in dis list wit they actual file pathz of tha referenced libraries on disk, includin tha libraries from they link intercourses. If a CONFIGURATION is given, it uses tha respectizzle configuration of tha imported targets if it exists, n' you can put dat on yo' toast. If no CONFIGURATION is given, it uses tha straight-up original gangsta configuration from ${CMAKE_CONFIGURATION_TYPES} if set, otherwise ${CMAKE_BUILD_TYPE}. This macro is used by all Check*.cmake filez which use try_compile() or try_run() n' support CMAKE_REQUIRED_LIBRARIES , so dat these checks support imported targets up in CMAKE_REQUIRED_LIBRARIES:


.nf
    cmake_expand_imported_targets(expandedLibs LIBRARIES ${CMAKE_REQUIRED_LIBRARIES}
                                               CONFIGURATION "${CMAKE_TRY_COMPILE_CONFIGURATION}" )
.fi

.TP
.B CMakeFindFrameworks
helper module ta find OSX frameworks

.TP
.B CMakeFindPackageMode
.nf
 
.fi

This file is executed by cmake when invoked wit \-\-find\-package. Well shiiiit, it expects dat tha followin variablez is set rockin \-D:


.nf
   NAME = name of tha package
   COMPILER_ID = tha CMake compila ID fo' which tha result is, i.e. GNU/Intel/Clang/MSVC, etc.
   LANGUAGE = language fo' which tha result is ghon be used, i.e. C/CXX/Fortan/ASM
   MODE = EXIST : only check fo' existence of tha given package
          COMPILE : print tha flags needed fo' compilin a object file which uses tha given package
          LINK : print tha flags needed fo' linkin when rockin tha given package
   QUIET = if TRUE, don't print anything
.fi

.TP
.B CMakeForceCompiler
.nf
 
.fi

This module defines macros intended fo' use by cross\-compilin toolchain filez when CMake aint able ta automatically detect tha compila identification.


Macro CMAKE_FORCE_C_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_C_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_C_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_C_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


Macro CMAKE_FORCE_CXX_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_CXX_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_CXX_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_CXX_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


Macro CMAKE_FORCE_Fortran_COMPILER has tha followin signature:


.nf
   CMAKE_FORCE_Fortran_COMPILER(<compiler> <compiler\-id>)
.fi

It sets CMAKE_Fortran_COMPILER ta tha given compila n' tha cmake internal variable CMAKE_Fortran_COMPILER_ID ta tha given compiler\-id. Y'all KNOW dat shit, muthafucka! Well shiiiit, it also bypasses tha check fo' hustlin compila n' basic compila shiznit tests.


So a simple toolchain file could be lookin like this:


.nf
   include (CMakeForceCompiler)
   set(CMAKE_SYSTEM_NAME Generic)
   CMAKE_FORCE_C_COMPILER   (chc12 MetrowerksHicross)
   CMAKE_FORCE_CXX_COMPILER (chc12 MetrowerksHicross)
.fi

.TP
.B CMakeGraphVizOptions
Da builtin graphviz support of CMake.

CMake can generate graphviz files, showin tha dependencies between tha targets up in a project n' also external libraries which is linked against. When CMake is run wit tha \-\-graphiz=foo option, it will produce


.nf
    * a gangbangin' foo.dot file showin all dependencies up in tha project
    * a gangbangin' foo.dot.<target> file fo' each target, file showin on which other targets tha respectizzle target depends
    * a gangbangin' foo.dot.<target>.dependaz file, showin which other targets depend on tha respectizzle target
.fi




This can result up in big-ass graphs. Usin tha file CMakeGraphVizOptions.cmake tha look n' content of tha generated graphs can be influenced. Y'all KNOW dat shit, muthafucka! This file is searched first up in ${CMAKE_BINARY_DIR} n' then up in ${CMAKE_SOURCE_DIR}. If found, it is read n' tha variablez set up in it is used ta adjust options fo' tha generated graphviz files.


.nf
  GRAPHVIZ_GRAPH_TYPE \- Da graph type
     Mandatory : NO
     Default   : "digraph"
  GRAPHVIZ_GRAPH_NAME \- Da graph name.
     Mandatory : NO
     Default   : "GG"
  GRAPHVIZ_GRAPH_HEADER \- Da header freestyled all up in tha top of tha graphviz file.
     Mandatory : NO
     Default   : "node [n  fontsize = "12"];"
  GRAPHVIZ_NODE_PREFIX \- Da prefix fo' each node up in tha graphviz file.
     Mandatory : NO
     Default   : "node"
  GRAPHVIZ_EXECUTABLES \- Set dis ta FALSE ta exclude executablez from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_STATIC_LIBS \- Set dis ta FALSE ta exclude static libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_SHARED_LIBS \- Set dis ta FALSE ta exclude shared libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_MODULE_LIBS \- Set dis ta FALSE ta exclude static libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_EXTERNAL_LIBS \- Set dis ta FALSE ta exclude external libraries from tha generated graphs.
     Mandatory : NO
     Default   : TRUE
  GRAPHVIZ_IGNORE_TARGETS \- A list of regular expressions fo' ignorin targets.
     Mandatory : NO
     Default   : empty
.fi

.TP
.B CMakePackageConfigHelpers
CONFIGURE_PACKAGE_CONFIG_FILE(), WRITE_BASIC_PACKAGE_VERSION_FILE()




.nf
    CONFIGURE_PACKAGE_CONFIG_FILE(<input> <output> INSTALL_DESTINATION <path>
                                                   [PATH_VARS <var1> <var2> ... <varN>]
                                                   [NO_SET_AND_CHECK_MACRO]
                                                   [NO_CHECK_REQUIRED_COMPONENTS_MACRO])
.fi




CONFIGURE_PACKAGE_CONFIG_FILE() should be used instead of tha plain configure_file() command when bustin tha <Name>Config.cmake or <Name>\-config.cmake file fo' installin a project or library. Well shiiiit, it helps makin tha resultin package relocatable by avoidin hardcoded paths up in tha installed Config.cmake file.


In a FooConfig.cmake file there may be code like dis ta make tha install destinations know ta tha rockin project:


.nf
   set(FOO_INCLUDE_DIR   "@CMAKE_INSTALL_FULL_INCLUDEDIR@" )
   set(FOO_DATA_DIR   "@CMAKE_INSTALL_PREFIX@/@RELATIVE_DATA_INSTALL_DIR@" )
   set(FOO_ICONS_DIR   "@CMAKE_INSTALL_PREFIX@/share/icons" )
   ...logic ta determine installedPrefix from tha own location...
   set(FOO_CONFIG_DIR  "${installedPrefix}/@CONFIG_INSTALL_DIR@" )
.fi

All 4 options shown above is not sufficient, since tha straight-up original gangsta 3 hardcode tha absolute directory locations, n' tha 4th case works only if tha logic ta determine tha installedPrefix is erect, n' if CONFIG_INSTALL_DIR gotz nuff a relatizzle path, which up in general cannot be guaranteed. Y'all KNOW dat shit, muthafucka! This has tha effect dat tha resultin FooConfig.cmake file would work skankyly under Windows n' OSX, where playas is used ta chizzle tha install location of a funky-ass binary package at install time, independent from how tha fuck CMAKE_INSTALL_PREFIX was set at build/cmake time.


Usin CONFIGURE_PACKAGE_CONFIG_FILE() helps. If used erectly, it make tha resultin FooConfig.cmake file relocatable. Usage:


.nf
   1. write a FooConfig.cmake.in file as yo ass is used to
   2. bang a line containin only tha strang "@PACKAGE_INIT@"
   3. instead of set(FOO_DIR "@SOME_INSTALL_DIR@"), use set(FOO_DIR "@PACKAGE_SOME_INSTALL_DIR@")
      (this must be afta tha @PACKAGE_INIT@ line)
   4. instead of rockin tha aiiight configure_file(), use CONFIGURE_PACKAGE_CONFIG_FILE()
.fi




Da <input> n' <output> arguments is tha input n' output file, tha same way as up in configure_file().


Da <path> given ta INSTALL_DESTINATION must be tha destination where tha FooConfig.cmake file is ghon be installed to. This can either be a relatizzle or absolute path, both work.


Da variablez <var1> ta <varN> given as PATH_VARS is tha variablez which contain install destinations. For each of dem tha macro will create a helper variable PACKAGE_<var...>. These helper variablez must be used up in tha FooConfig.cmake.in file fo' settin tha installed location. I aint talkin' bout chicken n' gravy biatch. They is calculated by CONFIGURE_PACKAGE_CONFIG_FILE() so dat they is always relatizzle ta tha installed location of tha package. This works both fo' relatizzle n' also fo' absolute locations. For absolute locations it works only if tha absolute location be a subdirectory of CMAKE_INSTALL_PREFIX.


By default configure_package_config_file() also generates two helper macros, set_and_check() n' check_required_components() tha fuck into tha FooConfig.cmake file.


set_and_check() should be used instead of tha aiiight set() command fo' settin directories n' file locations fo' realz. Additionally ta settin tha variable it also checks dat tha referenced file or directory straight-up exists n' fails wit a FATAL_ERROR otherwise. This make shizzle dat tha pimped FooConfig.cmake file do not contain wack references. When rockin tha NO_SET_AND_CHECK_MACRO, dis macro aint generated tha fuck into tha FooConfig.cmake file.


check_required_components(<package_name>) should be called all up in tha end of tha FooConfig.cmake file if tha package supports components, n' you can put dat on yo' toast. This macro checks whether all requested, non\-optionizzle components done been found, n' if dis aint tha case, sets tha Foo_FOUND variable ta FALSE, so dat tha package is considered ta be not found. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do dat by testin tha Foo_<Component>_FOUND variablez fo' all axed required components, n' you can put dat on yo' toast. When rockin tha NO_CHECK_REQUIRED_COMPONENTS option, dis macro aint generated tha fuck into tha FooConfig.cmake file.


For a example peep below tha documentation fo' WRITE_BASIC_PACKAGE_VERSION_FILE().





.nf
  WRITE_BASIC_PACKAGE_VERSION_FILE( filename VERSION major.minor.patch COMPATIBILITY (AnyNewerVersion|SameMajorVersion|ExactVersion) )
.fi




Writes a gangbangin' file fo' use as <package>ConfigVersion.cmake file ta <filename>. Right back up in yo muthafuckin ass. See tha documentation of find_package() fo' details on all dis bullshit.


.nf
    filename is tha output filename, it should be up in tha build tree.
    major.minor.patch is tha version number of tha project ta be installed
.fi

Da COMPATIBILITY mode AnyNewerVersion means dat tha installed package version is ghon be considered compatible if it is newer or exactly tha same as tha axed version. I aint talkin' bout chicken n' gravy biatch. This mode should be used fo' packages which is straight-up backward compatible, also across major versions. If SameMajorVersion is used instead, then tha behaviour differs from AnyNewerVersion up in dat tha major version number must be tha same as requested, e.g. version 2.0 aint gonna be considered compatible if 1.0 is requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This mode should be used fo' packages which guarantee backward compatibilitizzle within tha same major version. I aint talkin' bout chicken n' gravy biatch. If ExactVersion is used, then tha package is only considered compatible if tha axed version matches exactly its own version number (not thankin bout tha tweak version). For example, version 1.2.3 of a package is only considered compatible ta axed version 1.2.3. This mode is fo' packages without compatibilitizzle guarantees. If yo' project has mo' elaborated version matchin rules, yo big-ass booty is ghon need ta write yo' own custom ConfigVersion.cmake file instead of rockin dis macro.


Internally, dis macro executes configure_file() ta create tha resultin version file. Dependin on tha COMPATIBLITY, either tha file BasicConfigVersion\-SameMajorVersion.cmake.in or BasicConfigVersion\-AnyNewerVersion.cmake.in is used. Y'all KNOW dat shit, muthafucka! Please note dat these two filez is internal ta CMake n' you should not call configure_file() on dem yo ass yo, but they can be used as startin point ta create mo' sophisticted custom ConfigVersion.cmake files.





Example rockin both configure_package_config_file() n' write_basic_package_version_file(): CMakeLists.txt:


.nf
   set(INCLUDE_INSTALL_DIR include/ ... CACHE )
   set(LIB_INSTALL_DIR lib/ ... CACHE )
   set(SYSCONFIG_INSTALL_DIR etc/foo/ ... CACHE )
   ...
   include(CMakePackageConfigHelpers)
   configure_package_config_file(FooConfig.cmake.in ${CMAKE_CURRENT_BINARY_DIR}/FooConfig.cmake
                                 INSTALL_DESTINATION ${LIB_INSTALL_DIR}/Foo/cmake
                                 PATH_VARS INCLUDE_INSTALL_DIR SYSCONFIG_INSTALL_DIR)
   write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/FooConfigVersion.cmake
                                    VERSION 1.2.3
                                    COMPATIBILITY SameMajorVersion )
   install(FILES ${CMAKE_CURRENT_BINARY_DIR}/FooConfig.cmake ${CMAKE_CURRENT_BINARY_DIR}/FooConfigVersion.cmake
           DESTINATION ${LIB_INSTALL_DIR}/Foo/cmake )
.fi




With a FooConfig.cmake.in:


.nf
   set(FOO_VERSION x.y.z)
   ...
   @PACKAGE_INIT@
   ...
   set_and_check(FOO_INCLUDE_DIR "@PACKAGE_INCLUDE_INSTALL_DIR@")
   set_and_check(FOO_SYSCONFIG_DIR "@PACKAGE_SYSCONFIG_INSTALL_DIR@")
.fi




.nf
   check_required_components(Foo)
.fi

.TP
.B CMakeParseArguments
.nf
 
.fi

CMAKE_PARSE_ARGUMENTS(<prefix> <options> <one_value_keywords> <multi_value_keywords> args...)


CMAKE_PARSE_ARGUMENTS() is intended ta be used up in macros or functions fo' parsin tha arguments given ta dat macro or function. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it processes tha arguments n' defines a set of variablez which hold tha jointz of tha respectizzle options.


Da <options> argument gotz nuff all options fo' tha respectizzle macro, i.e. keywordz which can be used when callin tha macro without any value following, like e.g. tha OPTIONAL keyword of tha install() command.


Da <one_value_keywords> argument gotz nuff all keywordz fo' dis macro which is followed by one value, like e.g. DESTINATION keyword of tha install() command.


Da <multi_value_keywords> argument gotz nuff all keywordz fo' dis macro which can be followed by mo' than one value, like e.g. tha TARGETS or FILES keywordz of tha install() command.


When done, CMAKE_PARSE_ARGUMENTS() gonna git defined fo' each of tha keywordz listed up in <options>, <one_value_keywords> n' <multi_value_keywords> a variable composed of tha given <prefix> followed by "_" n' tha name of tha respectizzle keyword. Y'all KNOW dat shit, muthafucka! These variablez will then hold tha respectizzle value from tha argument list. For tha <options> keywordz dis is ghon be TRUE or FALSE.


All remainin arguments is collected up in a variable <prefix>_UNPARSED_ARGUMENTS, dis can be checked afterwardz ta peep whether yo' macro was called wit unrecognized parameters.


As a example here a my_install() macro, which takes similar arguments as tha real install() command:


.nf
   function(MY_INSTALL)
     set(options OPTIONAL FAST)
     set(oneValueArgs DESTINATION RENAME)
     set(multiValueArgs TARGETS CONFIGURATIONS)
     cmake_parse_arguments(MY_INSTALL "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN} )
     ...
.fi




Assume my_install() has been called like this:


.nf
   my_install(TARGETS foo bar DESTINATION bin OPTIONAL blub)
.fi




Afta tha cmake_parse_arguments() call tha macro gonna git set tha followin variables:


.nf
   MY_INSTALL_OPTIONAL = TRUE
   MY_INSTALL_FAST = FALSE (this option was not used when callin my_install()
   MY_INSTALL_DESTINATION = "bin"
   MY_INSTALL_RENAME = "" (was not used)
   MY_INSTALL_TARGETS = "foo;bar"
   MY_INSTALL_CONFIGURATIONS = "" (was not used)
   MY_INSTALL_UNPARSED_ARGUMENTS = "blub" (no value expected afta "OPTIONAL"
.fi




Yo ass can then continue n' process these variables.


Keywordz terminizzle listz of joints, e.g. if directly afta a one_value_keyword another recognized keyword bigs up, dis is interpreted as tha beginnin of tha freshly smoked up option. I aint talkin' bout chicken n' gravy biatch. E.g. my_install(TARGETS foo DESTINATION OPTIONAL) would result up in MY_INSTALL_DESTINATION set ta "OPTIONAL" yo, but MY_INSTALL_DESTINATION would be empty n' MY_INSTALL_OPTIONAL would be set ta TRUE therefor.

.TP
.B CMakePrintHelpers
Convenience macros fo' printin propertizzles n' variables, useful e.g. fo' debugging.







CMAKE_PRINT_PROPERTIES([TARGETS target1 .. targetN]


.nf
                        [SOURCES source1 .. sourceN]
                        [DIRECTORIES dir1 .. dirN]
                        [TESTS test1 .. testN]
                        [CACHE_ENTRIES entry1 .. entryN]
                        PROPERTIES prop1 .. propN )
.fi




This macro prints tha jointz of tha propertizzlez of tha given targets, source files, directories, tests or cache entries. Put ya muthafuckin choppers up if ya feel dis! Exactly one of tha scope keywordz must be used. Y'all KNOW dat shit, muthafucka! Example:


.nf
   cmake_print_properties(TARGETS foo bar PROPERTIES LOCATION INTERFACE_INCLUDE_DIRS)
.fi

This will print tha LOCATION n' INTERFACE_INCLUDE_DIRS propertizzles fo' both targets foo n' bar.





CMAKE_PRINT_VARIABLES(var1 var2 .. varN)


This macro will print tha name of each variable followed by its value. Example:


.nf
   cmake_print_variables(CMAKE_C_COMPILER CMAKE_MAJOR_VERSION THIS_ONE_DOES_NOT_EXIST)
.fi

Gives:


.nf
   \-\- CMAKE_C_COMPILER="/usr/bin/gcc" ; CMAKE_MAJOR_VERSION="2" ; THIS_ONE_DOES_NOT_EXIST=""
.fi

.TP
.B CMakePrintSystemInformation
print system shiznit

This file can be used fo' diagnostic purposes just include it up in a project ta peep various internal CMake variables.

.TP
.B CMakePushCheckState
.nf
 
.fi

This module defines three macros: CMAKE_PUSH_CHECK_STATE() CMAKE_POP_CHECK_STATE() n' CMAKE_RESET_CHECK_STATE() These macros can be used ta save, restore n' reset (i.e., clear contents) tha state of tha variablez CMAKE_REQUIRED_FLAGS, CMAKE_REQUIRED_DEFINITIONS, CMAKE_REQUIRED_LIBRARIES n' CMAKE_REQUIRED_INCLUDES used by tha various Check\-filez comin wit CMake, like e.g. check_function_exists() etc. Da variable contents is pushed on a stack, pushin multiple times is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This is useful e.g. when executin such tests up in a Find\-module, where they gotta be set yo, but afta tha Find\-module has been executed they should have tha same value as they had before.


CMAKE_PUSH_CHECK_STATE() macro receives optionizzle argument RESET. Whether itz specified, CMAKE_PUSH_CHECK_STATE() will set all CMAKE_REQUIRED_* variablez ta empty joints, same as CMAKE_RESET_CHECK_STATE() call will do.


Usage:


.nf
   cmake_push_check_state(RESET)
   set(CMAKE_REQUIRED_DEFINITIONS \-DSOME_MORE_DEF)
   check_function_exists(...)
   cmake_reset_check_state()
   set(CMAKE_REQUIRED_DEFINITIONS \-DANOTHER_DEF)
   check_function_exists(...)
   cmake_pop_check_state()
.fi

.TP
.B CMakeVerifyManifest
.nf
 
.fi

CMakeVerifyManifest.cmake


This script is used ta verify dat embeded manifests n' side by side manifests fo' a project match.  To run dis script, cd ta a gangbangin' finger-lickin' directory n' run tha script wit cmake \-P. On tha command line you can pass up in versions dat is OK even if not found up in tha .manifest files. For example, cmake \-Dallow_versions=8.0.50608.0 \-PCmakeVerifyManifest.cmake could be used ta allow a embeded manifest of 8.0.50608.0 ta be used up in a project even if dat version was not found up in tha .manifest file.

.TP
.B CPack
Build binary n' source package installers.

Da CPack module generates binary n' source installaz up in a variety of formats rockin tha cpack program. Inclusion of tha CPack module addz two freshly smoked up targets ta tha resultin makefiles, package n' package_source, which build tha binary n' source installers, respectively. Da generated binary installaz contain every last muthafuckin thang installed via CMakez INSTALL command (and tha deprecated INSTALL_FILES, INSTALL_PROGRAMS, n' INSTALL_TARGETS commands).


For certain kindz of binary installaz (includin tha graphical installaz on Mac OS X n' Windows), CPack generates installaz dat allow playas ta select individual application components ta install. Right back up in yo muthafuckin ass. See CPackComponent module fo' dis shit.


Da CPACK_GENERATOR variable has different meanings up in different contexts, n' you can put dat on yo' toast. In yo' CMakeLists.txt file, CPACK_GENERATOR be a *list of generators*: when run wit no other arguments, CPack will iterate over dat list n' produce one package fo' each generator. Shiiit, dis aint no joke. In a CPACK_PROJECT_CONFIG_FILE, though, CPACK_GENERATOR be a *strin namin a single generator*. If you need per\-cpack\- generator logic ta control *other* cpack settings, then you need a CPACK_PROJECT_CONFIG_FILE.


Da CMake source tree itself gotz nuff a CPACK_PROJECT_CONFIG_FILE. Right back up in yo muthafuckin ass. See tha top level file CMakeCPackOptions.cmake.in fo' a example.


If set, tha CPACK_PROJECT_CONFIG_FILE is included automatically on a per\-generator basis. Well shiiiit, it only need contain overrides.


Herez how tha fuck it works:


.nf
  \- cpack runs
  \- it includes CPackConfig.cmake
  \- it iterates over tha generators listed up in dat file's
    CPACK_GENERATOR list variable (unless holla'd at ta use just a
    specific one via \-G on tha command line...)
.fi




.nf
  \- foreach generator, it then
    \- sets CPACK_GENERATOR ta tha one currently bein iterated
    \- includes tha CPACK_PROJECT_CONFIG_FILE
    \- produces tha package fo' dat generator
.fi




This is tha key: For each generator listed up in CPACK_GENERATOR up in CPackConfig.cmake, cpack will *reset* CPACK_GENERATOR internally ta *the one currently bein used* n' then include tha CPACK_PROJECT_CONFIG_FILE.


Before includin dis CPack module up in yo' CMakeLists.txt file, there be a variety of variablez dat can be set ta customize tha resultin installers. Da most commonly\-used variablez are:


.nf
  CPACK_PACKAGE_NAME \- Da name of tha package (or application). If
  not specified, defaults ta tha project name.
.fi




.nf
  CPACK_PACKAGE_VENDOR \- Da name of tha package vendor. Shiiit, dis aint no joke. (e.g.,
  "Kitware").
.fi




.nf
  CPACK_PACKAGE_DIRECTORY \- Da directory up in which CPack is bustin its
  packaging. If it aint set then dis will default (internally) ta the
  build dir. Shiiit, dis aint no joke. This variable may be defined up in CPack config file or from
  tha cpack command line option "\-B". If set tha command line option
  override tha value found up in tha config file.
.fi




.nf
  CPACK_PACKAGE_VERSION_MAJOR \- Package major Version
.fi




.nf
  CPACK_PACKAGE_VERSION_MINOR \- Package minor Version
.fi




.nf
  CPACK_PACKAGE_VERSION_PATCH \- Package patch Version
.fi




.nf
  CPACK_PACKAGE_DESCRIPTION_FILE \- A text file used ta describe the
  project. Used, fo' example, tha introduction screen of a
  CPack\-generated Windows installa ta describe tha project.
.fi




.nf
  CPACK_PACKAGE_DESCRIPTION_SUMMARY \- Short description of the
  project (only all dem lyrics).
.fi




.nf
  CPACK_PACKAGE_FILE_NAME \- Da name of tha package file ta generate,
  not includin tha extension. I aint talkin' bout chicken n' gravy biatch. For example, cmake\-2.6.1\-Linux\-i686.
  Da default value is
.fi




.nf
  ${CPACK_PACKAGE_NAME}\-${CPACK_PACKAGE_VERSION}\-${CPACK_SYSTEM_NAME}.
.fi




.nf
  CPACK_PACKAGE_INSTALL_DIRECTORY \- Installation directory on the
  target system. This may be used by some CPack generators
  like NSIS ta create a installation directory e.g., "CMake 2.5"
  below tha installation prefix fo' realz. All installed element will be
  put inside dis directory.
.fi




.nf
   CPACK_PACKAGE_ICON \- A brandin image dat is ghon be displayed inside
   tha installa (used by GUI installers).
.fi




.nf
  CPACK_PROJECT_CONFIG_FILE \- CPack\-time project CPack configuration
  file. This file included at cpack time, once per
  generator afta CPack has set CPACK_GENERATOR ta tha actual generator
  bein used. Y'all KNOW dat shit, muthafucka! Well shiiiit, it allows per\-generator settin of CPACK_* variablez at
  cpack time.
.fi




.nf
  CPACK_RESOURCE_FILE_LICENSE \- License ta be embedded up in tha installa n' shit. It
  will typically be displayed ta tha user by tha produced installer
  (often wit a explicit "Accept" button, fo' graphical installers)
  prior ta installation. I aint talkin' bout chicken n' gravy biatch. This license file is NOT added ta installed
  file but is used by some CPack generators like NSIS. If you want
  ta install a license file (may be tha same as dis one)
  along wit yo' project you must add a appropriate CMake INSTALL
  command up in yo' CMakeLists.txt.
.fi




.nf
  CPACK_RESOURCE_FILE_README \- ReadMe file ta be embedded up in tha installa n' shit. It
  typically raps bout up in some detail tha purpose of tha project
  durin tha installation. I aint talkin' bout chicken n' gravy biatch. Not all CPack generators uses
  dis file.
.fi




.nf
  CPACK_RESOURCE_FILE_WELCOME \- Welcome file ta be embedded up in the
  installa n' shit. Well shiiiit, it welcomes playas ta dis installer.
  Typically used up in tha graphical installaz on Windows n' Mac OS X.
.fi




.nf
  CPACK_MONOLITHIC_INSTALL \- Disablez tha component\-based
  installation mechanism. When set tha component justification is ignored
  n' all installed shit is put up in a single "MONOLITHIC" package.
  Some CPack generators do monolithic packagin by default and
  may be axed ta do component packagin by setting
  CPACK_<GENNAME>_COMPONENT_INSTALL ta 1/TRUE.
.fi




.nf
  CPACK_GENERATOR \- List of CPack generators ta use. If not
  specified, CPack will create a set of options CPACK_BINARY_<GENNAME> (e.g.,
  CPACK_BINARY_NSIS) allowin tha user ta enable/disable individual
  generators. This variable may be used on tha command line
  as well as in:
.fi




.nf
    cpack \-D CPACK_GENERATOR="ZIP;TGZ" /path/to/build/tree
.fi




.nf
  CPACK_OUTPUT_CONFIG_FILE \- Da name of tha CPack binary configuration
  file. This file is tha CPack configuration generated by tha CPack module
  fo' binary installers. Defaults ta CPackConfig.cmake.
.fi




.nf
  CPACK_PACKAGE_EXECUTABLES \- Lists each of tha executablez n' associated
  text label ta be used ta create Start Menu shortcuts, n' you can put dat on yo' toast. For example,
  settin dis ta tha list ccmake;CMake will
  create a gangbangin' finger-lickin' dirty-ass shortcut named "CMake" dat will execute tha installed
  executable ccmake. Not all CPack generators use it (at least NSIS and
  OSXX11 do).
.fi




.nf
  CPACK_STRIP_FILES \- List of filez ta be stripped. Y'all KNOW dat shit, muthafucka! Startin with
  CMake 2.6.0 CPACK_STRIP_FILES is ghon be a funky-ass boolean variable which
  enablez strippin of all filez (a list of filez evaluates ta TRUE
  up in CMake, so dis chizzle is compatible).
.fi




Da followin CPack variablez is specific ta source packages, n' aint gonna affect binary packages:


.nf
  CPACK_SOURCE_PACKAGE_FILE_NAME \- Da name of tha source package. For
  example cmake\-2.6.1.
.fi




.nf
  CPACK_SOURCE_STRIP_FILES \- List of filez up in tha source tree that
  is ghon be stripped. Y'all KNOW dat shit, muthafucka! Startin wit CMake 2.6.0
  CPACK_SOURCE_STRIP_FILES is ghon be a funky-ass boolean variable which enables
  strippin of all filez (a list of filez evaluates ta TRUE up in CMake,
  so dis chizzle is compatible).
.fi




.nf
  CPACK_SOURCE_GENERATOR \- List of generators used fo' tha source
  packages fo' realz. As wit CPACK_GENERATOR, if dis aint specified then
  CPack will create a set of options (e.g., CPACK_SOURCE_ZIP)
  allowin playas ta select which packages is ghon be generated.
.fi




.nf
  CPACK_SOURCE_OUTPUT_CONFIG_FILE \- Da name of tha CPack source
  configuration file. This file is tha CPack configuration generated by the
  CPack module fo' source installers. Defaults ta CPackSourceConfig.cmake.
.fi




.nf
  CPACK_SOURCE_IGNORE_FILES \- Pattern of filez up in tha source tree
  dat won't be packaged when buildin a source package. This be a
  list of regular expression patterns (that must be properly escaped),
  e.g., /CVS/;/\\\\.svn/;\\\\.swp$;\\\\.#;/#;.*~;cscope.*
.fi




Da followin variablez is fo' advanced usez of CPack:


.nf
  CPACK_CMAKE_GENERATOR \- What CMake generator should be used if the
  project is CMake project. Defaults ta tha value of CMAKE_GENERATOR
  few playas will wanna chizzle dis setting.
.fi




.nf
  CPACK_INSTALL_CMAKE_PROJECTS \- List of four joints dat specify
  what tha fuck project ta install. Da four joints are: Build directory,
  Project Name, Project Component, Directory. If omitted, CPack will
  build a installa dat installaz every last muthafuckin thang.
.fi




.nf
  CPACK_SYSTEM_NAME \- System name, defaults ta tha value of
  ${CMAKE_SYSTEM_NAME}.
.fi




.nf
  CPACK_PACKAGE_VERSION \- Package full version, used internally. By
  default, dis is built from CPACK_PACKAGE_VERSION_MAJOR,
  CPACK_PACKAGE_VERSION_MINOR, n' CPACK_PACKAGE_VERSION_PATCH.
.fi




.nf
  CPACK_TOPLEVEL_TAG \- Directory fo' tha installed files.
.fi




.nf
  CPACK_INSTALL_COMMANDS \- Extra commandz ta install components.
.fi




.nf
  CPACK_INSTALLED_DIRECTORIES \- Extra directories ta install.
.fi




.nf
   CPACK_PACKAGE_INSTALL_REGISTRY_KEY \- Registry key used when
   installin dis project. This is only used by installa fo' Windows.
   Da default value is based on tha installation directory.
   CPACK_CREATE_DESKTOP_LINKS \- List of desktop links ta create.
.fi




.TP
.B CPackBundle
CPack Bundle generator (Mac OS X) specific options




Installaz built on Mac OS X rockin tha Bundle generator use tha aforementioned DragNDrop (CPACK_DMG_xxx) variables, plus tha followin Bundle\-specific parametas (CPACK_BUNDLE_xxx).


.nf
  CPACK_BUNDLE_NAME \- Da name of tha generated bundle. This
  appears up in tha OSX finder as tha bundle name. Required.
.fi




.nf
  CPACK_BUNDLE_PLIST \- Path ta a OSX plist file dat is ghon be used
  fo' tha generated bundle. This assumes dat tha calla has generated
  or specified they own Info.plist file. Required.
.fi




.nf
  CPACK_BUNDLE_ICON \- Path ta a OSX icon file dat is ghon be used as
  tha icon fo' tha generated bundle. This is tha icon dat appears up in the
  OSX finder fo' tha bundle, n' up in tha OSX dock when tha bundle is opened.
  Required.
.fi




.nf
  CPACK_BUNDLE_STARTUP_COMMAND \- Path ta a startup script. This be a path to
  a executable or script dat is ghon be run whenever a end\-user double\-clicks
  tha generated bundle up in tha OSX Finder n' shit. Optional.
.fi

.TP
.B CPackComponent
Build binary n' source package installers




Da CPackComponent module is tha module which handlez tha component part of CPack. Right back up in yo muthafuckin ass. See CPack module fo' general shiznit bout CPack.


For certain kindz of binary installaz (includin tha graphical installaz on Mac OS X n' Windows), CPack generates installaz dat allow playas ta select individual application components ta install. Da contentz of each of tha components is identified by tha COMPONENT argument of CMakez INSTALL command. Y'all KNOW dat shit, muthafucka! These components can be annotated wit user\-friendly names n' descriptions, inter\-component dependencies, etc., n' grouped up in various ways ta customize tha resultin installa n' shit. Right back up in yo muthafuckin ass. See tha cpack_add_* commands, busted lyrics bout below, fo' mo' shiznit bout component\-specific installations.


Component\-specific installation allows playas ta select specific setz of components ta install durin tha install process. Installation components is identified by tha COMPONENT argument of CMakez INSTALL commands, n' should be further busted lyrics bout by tha followin CPack commands:


.nf
  CPACK_COMPONENTS_ALL \- Da list of component ta install.
.fi




Da default value of dis variable is computed by CPack n' gotz nuff all components defined by tha project. Da user may set it ta only include tha specified components.


.nf
  CPACK_<GENNAME>_COMPONENT_INSTALL \- Enable/Disable component install for
  CPack generator <GENNAME>.
.fi




Each CPack Generator (RPM, DEB, ARCHIVE, NSIS, DMG, etc...) has a legacy default behavior. Shiiit, dis aint no joke. e.g. RPM buildz monolithic whereas NSIS buildz component. One can chizzle tha default behavior by settin dis variable ta 0/1 or OFF/ON.


.nf
  CPACK_COMPONENTS_GROUPING \- Specify how tha fuck components is grouped fo' multi\-package
  component\-aware CPack generators.
.fi




Some generators like RPM or ARCHIVE crew (TGZ, ZIP, ...) generates nuff muthafuckin packages filez when axed fo' component packaging. They crew tha component differently dependin on tha value of dis variable:


.nf
  \- ONE_PER_GROUP (default): creates one package file per component group
  \- ALL_COMPONENTS_IN_ONE : creates a single package wit all (requested) component
  \- IGNORE : creates one package per component, i.e. IGNORE component group
.fi

One can specify different groupin fo' different CPack generator by rockin a CPACK_PROJECT_CONFIG_FILE.


.nf
  CPACK_COMPONENT_<compName>_DISPLAY_NAME \- Da name ta be displayed fo' a cold-ass lil component.
  CPACK_COMPONENT_<compName>_DESCRIPTION \- Da description of a cold-ass lil component.
  CPACK_COMPONENT_<compName>_GROUP \- Da crew of a cold-ass lil component.
  CPACK_COMPONENT_<compName>_DEPENDS \- Da dependencies (list of components)
  on which dis component depends.
  CPACK_COMPONENT_<compName>_REQUIRED \- True is dis component is required.
.fi

cpack_add_component \- Describes a CPack installation component named by tha COMPONENT argument ta a CMake INSTALL command.


.nf
  cpack_add_component(compname
                      [DISPLAY_NAME name]
                      [DESCRIPTION description]
                      [HIDDEN | REQUIRED | DISABLED ]
                      [GROUP group]
                      [DEPENDS comp1 comp2 ... ]
                      [INSTALL_TYPES type1 type2 ... ]
                      [DOWNLOADED]
                      [ARCHIVE_FILE filename])
.fi




Da cmake_add_component command raps bout a installation component, which tha user can opt ta install or remove as part of tha graphical installation process. compname is tha name of tha component, as provided ta tha COMPONENT argument of one or mo' CMake INSTALL commands.


DISPLAY_NAME is tha displayed name of tha component, used up in graphical installaz ta display tha component name. This value can be any string.


DESCRIPTION be a extended description of tha component, used up in graphical installaz ta give tha user additionizzle shiznit bout tha component. Descriptions can span multiple lines rockin "\\n" as tha line separator. Shiiit, dis aint no joke. Typically, these descriptions should be no mo' than all dem lines long.


HIDDEN indicates dat dis component is ghon be hidden up in tha graphical installer, so dat tha user cannot directly chizzle whether it is installed or not.


REQUIRED indicates dat dis component is required, n' therefore will always be installed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is ghon be visible up in tha graphical installa yo, but it cannot be unselected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Typically, required components is shown greyed out).


DISABLED indicates dat dis component should be disabled (unselected) by default. Da user is free ta select dis component fo' installation, unless it be also HIDDEN.


DEPENDS lists tha components on which dis component depends. If dis component is selected, then each of tha components listed must also be selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da dependency shiznit is encoded within tha installa itself, so dat playas cannot install inconsistent setz of components.


GROUP names tha component crew of which dis component be a part. If not provided, tha component is ghon be a standalone component, not part of any component group. Component crews is busted lyrics bout wit tha cpack_add_component_group command, detailed below.


INSTALL_TYPES lists tha installation typez of which dis component be a part. When one of these installations types is selected, dis component will automatically be selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Installation types is busted lyrics bout wit tha cpack_add_install_type command, detailed below.


DOWNLOADED indicates dat dis component should be downloaded on\-the\-fly by tha installer, rather than packaged up in wit tha installa itself. For mo' shiznit, peep tha cpack_configure_downloadz command.


ARCHIVE_FILE serves up a name fo' tha archive file pimped by CPack ta be used fo' downloaded components, n' you can put dat on yo' toast. If not supplied, CPack will create a gangbangin' file wit some name based on CPACK_PACKAGE_FILE_NAME n' tha name of tha component. Right back up in yo muthafuckin ass. See cpack_configure_downloadz fo' mo' shiznit.


cpack_add_component_group \- Describes a crew of related CPack installation components.


.nf
  cpack_add_component_group(groupname
                           [DISPLAY_NAME name]
                           [DESCRIPTION description]
                           [PARENT_GROUP parent]
                           [EXPANDED]
                           [BOLD_TITLE])
.fi




Da cpack_add_component_group raps on some crew of installation components, which is ghon be placed together within tha listin of options. Typically, component crews allow tha user ta select/deselect all of tha components within a single crew via a single group\-level option. I aint talkin' bout chicken n' gravy biatch. Use component crews ta reduce tha complexitizzle of installaz wit nuff options. groupname be a arbitrary name used ta identify tha crew up in tha GROUP argument of tha cpack_add_component command, which is used ta place a cold-ass lil component up in a group. Da name of tha crew must not conflict wit tha name of any component.


DISPLAY_NAME is tha displayed name of tha component group, used up in graphical installaz ta display tha component crew name. This value can be any string.


DESCRIPTION be a extended description of tha component group, used up in graphical installaz ta give tha user additionizzle shiznit bout tha components within dat group. Descriptions can span multiple lines rockin "\\n" as tha line separator. Shiiit, dis aint no joke. Typically, these descriptions should be no mo' than all dem lines long.


PARENT_GROUP, if supplied, names tha parent crew of dis group. Parent crews is used ta establish a hierarchy of groups, providin a arbitrary hierarchy of groups.


EXPANDED indicates that, by default, tha crew should show up as "expanded", so dat tha user immediately sees all of tha components within tha group. Otherwise, tha crew will initially show up as a single entry.


BOLD_TITLE indicates dat tha crew title should step tha fuck up in bold, ta booty-call tha userz attention ta tha group.


cpack_add_install_type \- Add a freshly smoked up installation type containin a set of predefined component selections ta tha graphical installer.


.nf
  cpack_add_install_type(typename
                         [DISPLAY_NAME name])
.fi




Da cpack_add_install_type command identifies a set of preselected components dat represents a cold-ass lil common use case fo' a application. I aint talkin' bout chicken n' gravy biatch. For example, a "Developer" install type might include a application along wit its header n' library files, while a "End user" install type might just include tha applicationz executable. Each component identifies itself wit one or mo' install types via tha INSTALL_TYPES argument ta cpack_add_component.


DISPLAY_NAME is tha displayed name of tha install type, which will typically show up in a thugged-out drop\-down box within a graphical installa n' shit. This value can be any string.


cpack_configure_downloadz \- Configure CPack ta downlizzle selected components on\-the\-fly as part of tha installation process.


.nf
  cpack_configure_downloads(site
                            [UPLOAD_DIRECTORY dirname]
                            [ALL]
                            [ADD_REMOVE|NO_ADD_REMOVE])
.fi




Da cpack_configure_downloadz command configures installation\-time downloadz of selected components, n' you can put dat on yo' toast. For each downloadable component, CPack will create a archive containin tha contentz of dat component, which should be uploaded ta tha given crib. When tha user selects dat component fo' installation, tha installa will downlizzle n' extract tha component up in place. This feature is useful fo' bustin lil' small-ass installaz dat only downlizzle tha axed components, savin bandwidth fo' realz. Additionally, tha installaz is lil' small-ass enough dat they is ghon be installed as part of tha aiiight installation process, n' tha "Change" button up in Windows Add/Remove Programs control panel will allow one ta add or remove partz of tha application afta tha original gangsta installation. I aint talkin' bout chicken n' gravy biatch. On Windows, tha downloaded\-components functionalitizzle requires tha ZipDLL plug\-in fo' NSIS, available at:


.nf
  http://nsis.sourceforge.net/ZipDLL_plug\-in
.fi




On Mac OS X, installaz dat downlizzle components on\-the\-fly can only be built n' installed on system rockin Mac OS X 10.5 or later.


Da joint argument be a URL where tha archives fo' downloadable components will reside, e.g., http://www.cmake.org/files/2.6.1/installer/ All of tha archives produced by CPack should be uploaded ta dat location.


UPLOAD_DIRECTORY is tha local directory where CPack will create tha various archives fo' each of tha components, n' you can put dat on yo' toast. Da contentz of dis directory should be uploaded ta a location accessible by tha URL given up in tha joint argument. If omitted, CPack will use tha directory CPackUploadz inside tha CMake binary directory ta store tha generated archives.


Da ALL flag indicates dat all components be downloaded. Y'all KNOW dat shit, muthafucka! Otherwise, only dem components explicitly marked as DOWNLOADED or dat gotz a specified ARCHIVE_FILE is ghon be downloaded. Y'all KNOW dat shit, muthafucka! Additionally, tha ALL option implies ADD_REMOVE (unless NO_ADD_REMOVE is specified).


ADD_REMOVE indicates dat CPack should install a cold-ass lil copy of tha installa dat can be called from Windows' Add/Remove Programs dialog (via tha "Modify" button) ta chizzle tha set of installed components, n' you can put dat on yo' toast. NO_ADD_REMOVE turns off dis behavior. Shiiit, dis aint no joke. This option is ignored on Mac OS X.

.TP
.B CPackCygwin
Cygwin CPack generator (Cygwin).

Da followin variable is specific ta installaz build on and/or fo' Cygwin:


.nf
   CPACK_CYGWIN_PATCH_NUMBER \- Da Cygwin patch number.
   FIXME: This documentation is incomplete.
   CPACK_CYGWIN_PATCH_FILE \- Da Cygwin patch file.
   FIXME: This documentation is incomplete.
   CPACK_CYGWIN_BUILD_SCRIPT \- Da Cygwin build script.
   FIXME: This documentation is incomplete.
.fi

.TP
.B CPackDMG
DragNDrop CPack generator (Mac OS X).

Da followin variablez is specific ta tha DragNDrop installaz built on Mac OS X:


.nf
  CPACK_DMG_VOLUME_NAME \- Da volume name of tha generated disk
  image. Defaults ta CPACK_PACKAGE_FILE_NAME.
.fi




.nf
  CPACK_DMG_FORMAT \- Da disk image format. Common joints is UDRO
  (UDIF read\-only), UDZO (UDIF zlib\-compressed) or UDBZ (UDIF
  bzip2\-compressed). Refer ta hdiutil(1) fo' mo' shiznit on
  other available formats.
.fi




.nf
  CPACK_DMG_DS_STORE \- Path ta a cold-ass lil custom DS_Store file. This .DS_Store
  file e.g. can be used ta specify tha Finder window
  position/geometry n' layout (like fuckin hidden toolbars, placement of the
  icons etc.). This file has ta be generated by tha Finder (either manually or
  all up in OSA\-script) rockin a aiiight folda from which tha .DS_Store
  file can then be extracted.
.fi




.nf
  CPACK_DMG_BACKGROUND_IMAGE \- Path ta a funky-ass background image file. This
  file is ghon be used as tha background fo' tha Finder Window when tha disk
  image is opened. Y'all KNOW dat shit, muthafucka!  By default no background image is set. Da background
  image be applied afta applyin tha custom .DS_Store file.
.fi




.nf
  CPACK_COMMAND_HDIUTIL \- Path ta tha hdiutil(1) command used to
  operate on disk image filez on Mac OS X. This variable can be used
  ta override tha automatically detected command (or specify its
  location if tha auto\-detection fails ta find dat shit.)
.fi




.nf
  CPACK_COMMAND_SETFILE \- Path ta tha SetFile(1) command used ta set
  extended attributes on filez n' directories on Mac OS X. This
  variable can be used ta override tha automatically detected
  command (or specify its location if tha auto\-detection fails to
  find dat shit.)
.fi




.nf
  CPACK_COMMAND_REZ \- Path ta tha Rez(1) command used ta compile
  resources on Mac OS X. This variable can be used ta override the
  automatically detected command (or specify its location if the
  auto\-detection fails ta find dat shit.)
.fi

.TP
.B CPackDeb
Da builtin (binary) CPack Deb generator (Unix only)

CPackDeb may be used ta create Deb package rockin CPack. CPackDeb be a CPack generator thus it uses tha CPACK_XXX variablez used by CPack : http://www.cmake.org/Wiki/CMake:CPackConfiguration. I aint talkin' bout chicken n' gravy biatch. CPackDeb generator should work on any linux host but it will produce betta deb package when Debian specific tools 'dpkg\-xxx' is usable on tha build system.


CPackDeb has specific features which is controlled by tha specifics CPACK_DEBIAN_XXX variables.You'll find a thugged-out detailed usage on tha wiki:


.nf
  http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#DEB_.28UNIX_only.29
.fi

However as a handy reminder here comes tha list of specific variables:


CPACK_DEBIAN_PACKAGE_NAME


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_NAME (lower case)
     Da debian package summary
.fi

CPACK_DEBIAN_PACKAGE_VERSION


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_VERSION
     Da debian package version
.fi

CPACK_DEBIAN_PACKAGE_ARCHITECTURE


.nf
     Mandatory : YES
     Default   : Output of dpkg \-\-print\-architecture (or i386 if dpkg aint found)
     Da debian package architecture
.fi

CPACK_DEBIAN_PACKAGE_DEPENDS


.nf
     Mandatory : NO
     Default   : \-
     May be used ta set deb dependencies.
.fi

CPACK_DEBIAN_PACKAGE_MAINTAINER


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_CONTACT
     Da debian package maintainer
.fi

CPACK_DEBIAN_PACKAGE_DESCRIPTION


.nf
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
     Da debian package description
.fi

CPACK_DEBIAN_PACKAGE_SECTION


.nf
     Mandatory : YES
     Default   : 'devel'
     Da debian package section
.fi

CPACK_DEBIAN_PACKAGE_PRIORITY


.nf
     Mandatory : YES
     Default   : 'optional'
     Da debian package priority
.fi

CPACK_DEBIAN_PACKAGE_HOMEPAGE


.nf
     Mandatory : NO
     Default   : \-
     Da URL of tha wizzy joint fo' dis package, preferably (when applicable) the
     joint from which tha original gangsta source can be obtained n' any additional
     upstream documentation or shiznit may be found.
     Da content of dis field be a simple URL without any surrounding
     charactas like fuckin <>.
.fi

CPACK_DEBIAN_PACKAGE_SHLIBDEPS


.nf
     Mandatory : NO
     Default   : OFF
     May be set ta ON up in order ta use dpkg\-shlibdeps ta generate
     betta package dependency list.
     Yo ass may need set CMAKE_INSTALL_RPATH toi appropriate value
     if you use dis feature, cuz if you don't dpkg\-shlibdeps
     may fail ta find yo' own shared libs.
     See http://www.cmake.org/Wiki/CMake_RPATH_handling.
.fi

CPACK_DEBIAN_PACKAGE_DEBUG


.nf
     Mandatory : NO
     Default   : \-
     May be set when invokin cpack up in order ta trace debug shiznit
     durin CPackDeb run.
.fi

CPACK_DEBIAN_PACKAGE_PREDEPENDS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     This field is like Depends, except dat it also forces dpkg ta complete installation of
     tha packages named before even startin tha installation of tha package which declares
     tha pre\-dependency.
.fi

CPACK_DEBIAN_PACKAGE_ENHANCES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     This field is similar ta Suggests but works up in tha opposite direction.
     It be used ta declare dat a package can enhizzle tha functionalitizzle of another package.
.fi

CPACK_DEBIAN_PACKAGE_BREAKS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     When one binary package declares dat it breaks another, dpkg will refuse ta allow the
     package which declares Breaks be installed unless tha fucked up package is deconfigured first,
     n' it will refuse ta allow tha fucked up package ta be reconfigured.
.fi

CPACK_DEBIAN_PACKAGE_CONFLICTS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     When one binary package declares a cold-ass lil conflict wit another rockin a Conflicts field,
     dpkg will refuse ta allow dem ta be installed on tha system all up in tha same time.
.fi

CPACK_DEBIAN_PACKAGE_PROVIDES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     A virtual package is one which appears up in tha Provides control field of another package.
.fi

CPACK_DEBIAN_PACKAGE_REPLACES


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Packages can declare up in they control file dat they should overwrite
     filez up in certain other packages, or straight-up replace other packages.
.fi

CPACK_DEBIAN_PACKAGE_RECOMMENDS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Allows packages ta declare a strong yo, but not absolute, dependency on other packages.
.fi

CPACK_DEBIAN_PACKAGE_SUGGESTS


.nf
     Mandatory : NO
     Default   : \-
     peep http://www.debian.org/doc/debian\-policy/ch\-relationships.html#s\-binarydeps
     Allows packages ta declare a suggested package install grouping.
.fi

CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA


.nf
     Mandatory : NO
     Default   : \-
     This variable allow advanced user ta add custom script ta tha control.tar.gz
     Typical usage is fo' conffiles, postinst, postrm, prerm.
     Usage: set(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA
            "${CMAKE_CURRENT_SOURCE_DIR/prerm;${CMAKE_CURRENT_SOURCE_DIR}/postrm")
.fi

.TP
.B CPackNSIS
CPack NSIS generator specific options




Da followin variablez is specific ta tha graphical installaz built on Windows rockin tha Nullsoft Installation System.


.nf
   CPACK_NSIS_INSTALL_ROOT \- Da default installation directory presented
   ta tha end user by tha NSIS installa is under dis root dir. Shiiit, dis aint no joke. Da full
   directory presented ta tha end user is:
   ${CPACK_NSIS_INSTALL_ROOT}/${CPACK_PACKAGE_INSTALL_DIRECTORY}
.fi




.nf
   CPACK_NSIS_MUI_ICON \- An icon filename.
   Da name of a *.ico file used as tha main icon fo' tha generated
   install program.
.fi




.nf
   CPACK_NSIS_MUI_UNIICON \- An icon filename.
   Da name of a *.ico file used as tha main icon fo' tha generated
   uninstall program.
.fi




.nf
   CPACK_NSIS_INSTALLER_MUI_ICON_CODE \- undocumented.
.fi




.nf
   CPACK_NSIS_EXTRA_PREINSTALL_COMMANDS \- Extra NSIS commandz that
   is ghon be added ta tha beginnin of tha install Section, before your
   install tree be available on tha target system.
.fi




.nf
   CPACK_NSIS_EXTRA_INSTALL_COMMANDS \- Extra NSIS commandz that
   is ghon be added ta tha end of tha install Section, afta your
   install tree be available on tha target system.
.fi




.nf
   CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS \- Extra NSIS commandz dat will
   be added ta tha uninstall Section, before yo' install tree is
   removed from tha target system.
.fi




.nf
   CPACK_NSIS_COMPRESSOR \- Da arguments dat is ghon be passed ta the
   NSIS SetCompressor command.
.fi




.nf
   CPACK_NSIS_ENABLE_UNINSTALL_BEFORE_INSTALL \- Ask bout uninstalling
   previous versions first.
   If dis is set ta "ON", then a installa will look fo' previous
   installed versions n' if one is found, ask tha user whether to
   uninstall it before proceedin wit tha install.
.fi




.nf
   CPACK_NSIS_MODIFY_PATH \- Modify PATH toggle.
   If dis is set ta "ON", then a extra page
   will step tha fuck up in tha installa dat will allow tha user ta chizzle
   whether tha program directory should be added ta tha system PATH
   variable.
.fi




.nf
   CPACK_NSIS_DISPLAY_NAME \- Da display name strang dat appears in
   tha Windows Add/Remove Program control panel
.fi




.nf
   CPACK_NSIS_PACKAGE_NAME \- Da title displayed all up in tha top of the
   installer.
.fi




.nf
   CPACK_NSIS_INSTALLED_ICON_NAME \- A path ta tha executable that
   gotz nuff tha installa icon.
.fi




.nf
   CPACK_NSIS_HELP_LINK \- URL ta a wizzy joint providin assistizzle in
   installin yo' application.
.fi




.nf
   CPACK_NSIS_URL_INFO_ABOUT \- URL ta a wizzy joint providin more
   shiznit bout yo' application.
.fi




.nf
   CPACK_NSIS_CONTACT \- Contact shiznit fo' thangs n' comments
   bout tha installation process.
.fi




.nf
   CPACK_NSIS_CREATE_ICONS_EXTRA \- Additionizzle NSIS commandz for
   bustin start menu shortcuts.
.fi




.nf
   CPACK_NSIS_DELETE_ICONS_EXTRA \-Additionizzle NSIS commandz to
   uninstall start menu shortcuts.
.fi




.nf
   CPACK_NSIS_EXECUTABLES_DIRECTORY \- Creatin NSIS start menu links
   assumes dat they is up in 'bin' unless dis variable is set.
   For example, you would set dis ta 'exec' if yo' executablez are
   up in a exec directory.
.fi




.nf
   CPACK_NSIS_MUI_FINISHPAGE_RUN \- Specify a executable ta add a option
   ta run on tha finish page of tha NSIS installer.
   CPACK_NSIS_MENU_LINKS \- Specify links up in [application] menu.
   This should contain a list of pair "link" "link name". Da link
   may be a URL or a path relatizzle ta installation prefix.
   Like:
     set(CPACK_NSIS_MENU_LINKS
         "doc/cmake\-@CMake_VERSION_MAJOR@.@CMake_VERSION_MINOR@/cmake.html" "CMake Help"
         "http://www.cmake.org" "CMake Web Joint")
.fi

.TP
.B CPackPackageMaker
PackageMaker CPack generator (Mac OS X).

Da followin variable is specific ta installaz built on Mac OS X rockin PackageMaker:


.nf
  CPACK_OSX_PACKAGE_VERSION \- Da version of Mac OS X dat the
  resultin PackageMaker archive should be compatible with. Different
  versionz of Mac OS X support different
  features. For example, CPack can only build component\-based
  installaz fo' Mac OS X 10.4 or newer, n' can only build
  installaz dat downlizzle component son\-the\-fly fo' Mac OS X 10.5
  or newer n' shit. If left blank, dis value is ghon be set ta tha minimum
  version of Mac OS X dat supports tha axed features. Right back up in yo muthafuckin ass. Set this
  variable ta some value (e.g., 10.4) only if you wanna guarantee
  dat yo' installa will work on dat version of Mac OS X, and
  don't mind missin extra features available up in tha installer
  shippin wit lata versionz of Mac OS X.
.fi

.TP
.B CPackRPM
Da builtin (binary) CPack RPM generator (Unix only)

CPackRPM may be used ta create RPM package rockin CPack. CPackRPM be a CPack generator thus it uses tha CPACK_XXX variablez used by CPack : http://www.cmake.org/Wiki/CMake:CPackConfiguration


However CPackRPM has specific features which is controlled by tha specifics CPACK_RPM_XXX variables. CPackRPM be a cold-ass lil component aware generator so when CPACK_RPM_COMPONENT_INSTALL is ON some mo' CPACK_RPM_<ComponentName>_XXXX variablez may be used up in order ta have component specific joints, n' you can put dat on yo' toast. Note however dat <componentName> refers ta tha **groupin name**. This may be either a cold-ass lil component name or a cold-ass lil component GROUP name. Usually dem vars correspond ta RPM spec file entities, one may find shiznit bout spec filez here http://www.rpm.org/wiki/Docs. You'll find a thugged-out detailed usage of CPackRPM on tha wiki:


.nf
  http://www.cmake.org/Wiki/CMake:CPackPackageGenerators#RPM_.28Unix_Only.29
.fi

However as a handy reminder here comes tha list of specific variables:


.nf
  CPACK_RPM_PACKAGE_SUMMARY \- Da RPM package summary.
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_SUMMARY
  CPACK_RPM_PACKAGE_NAME \- Da RPM package name.
     Mandatory : YES
     Default   : CPACK_PACKAGE_NAME
  CPACK_RPM_PACKAGE_VERSION \- Da RPM package version.
     Mandatory : YES
     Default   : CPACK_PACKAGE_VERSION
  CPACK_RPM_PACKAGE_ARCHITECTURE \- Da RPM package architecture.
     Mandatory : NO
     Default   : \-
     This may be set ta "noarch" if you
     know yo ass is buildin a noarch package.
  CPACK_RPM_PACKAGE_RELEASE \- Da RPM package release.
     Mandatory : YES
     Default   : 1
     This is tha numberin of tha RPM package
     itself, i.e. tha version of tha packagin n' not tha version of the
     content (see CPACK_RPM_PACKAGE_VERSION). One may chizzle tha default
     value if tha previous packagin was buggy and/or you wanna put here
     a gangbangin' fancy Linux distro specific numbering.
  CPACK_RPM_PACKAGE_LICENSE \- Da RPM package license policy.
     Mandatory : YES
     Default   : "unknown"
  CPACK_RPM_PACKAGE_GROUP \- Da RPM package group.
     Mandatory : YES
     Default   : "unknown"
  CPACK_RPM_PACKAGE_VENDOR \- Da RPM package vendor.
     Mandatory : YES
     Default   : CPACK_PACKAGE_VENDOR if set or "unknown"
  CPACK_RPM_PACKAGE_URL \- Da projects URL.
     Mandatory : NO
     Default   : \-
  CPACK_RPM_PACKAGE_DESCRIPTION \- RPM package description.
     Mandatory : YES
     Default   : CPACK_PACKAGE_DESCRIPTION_FILE if set or "no package description available"
  CPACK_RPM_COMPRESSION_TYPE \- RPM compression type.
     Mandatory : NO
     Default   : \-
     May be used ta override RPM compression type ta be used
     ta build tha RPM. For example some Linux distribution now default
     ta lzma or xz compression whereas olda cannot use such RPM.
     Usin dis one can enforce compression type ta be used.
     Possible value are: lzma, xz, bzip2 n' gzip.
  CPACK_RPM_PACKAGE_REQUIRES \- RPM spec requires field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM dependencies (requires).
     Note dat you must enclose tha complete requires strang between quotes,
     fo' example:
     set(CPACK_RPM_PACKAGE_REQUIRES "python >= 2.5.0, cmake >= 2.8")
     Da required package list of a RPM file could be printed with
     rpm \-qp \-\-requires file.rpm
  CPACK_RPM_PACKAGE_SUGGESTS \- RPM spec suggest field.
     Mandatory : NO
     Default   : \-
     May be used ta set weak RPM dependencies (suggests).
     Note dat you must enclose tha complete requires strang between quotes.
  CPACK_RPM_PACKAGE_PROVIDES \- RPM spec serves up field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM dependencies (provides).
     Da provided package list of a RPM file could be printed with
     rpm \-qp \-\-provides file.rpm
  CPACK_RPM_PACKAGE_OBSOLETES \- RPM spec obsoletes field.
     Mandatory : NO
     Default   : \-
     May be used ta set RPM packages dat is obsoleted by dis one.
  CPACK_RPM_PACKAGE_RELOCATABLE \- build a relocatable RPM.
     Mandatory : NO
     Default   : CPACK_PACKAGE_RELOCATABLE
     If dis variable is set ta TRUE or ON CPackRPM will try
     ta build a relocatable RPM package fo' realz. A relocatable RPM may
     be installed rockin rpm \-\-prefix or \-\-relocate up in order to
     install it at a alternate place peep rpm(8).
     Note dat currently dis may fail if CPACK_SET_DESTDIR is set ta ON.
     If CPACK_SET_DESTDIR is set then yo big-ass booty is ghon git a warnin message
     but if there is file installed wit absolute path you gonna get
     unexpected behavior.
  CPACK_RPM_SPEC_INSTALL_POST \- [deprecated].
     Mandatory : NO
     Default   : \-
     This way of specifyin post\-install script is deprecated use
     CPACK_RPM_POST_INSTALL_SCRIPT_FILE
     May be used ta set a RPM post\-install command inside tha spec file.
     For example settin it ta "/bin/true" may be used ta prevent
     rpmbuild ta strip binaries.
  CPACK_RPM_SPEC_MORE_DEFINE \- RPM extended spec definitions lines.
     Mandatory : NO
     Default   : \-
     May be used ta add any %define lines ta tha generated spec file.
  CPACK_RPM_PACKAGE_DEBUG \- Toggle CPackRPM debug output.
     Mandatory : NO
     Default   : \-
     May be set when invokin cpack up in order ta trace debug shiznit
     durin CPack RPM run. I aint talkin' bout chicken n' gravy biatch. For example you may launch CPack like this
     cpack \-D CPACK_RPM_PACKAGE_DEBUG=1 \-G RPM
  CPACK_RPM_USER_BINARY_SPECFILE \- A user provided spec file.
     Mandatory : NO
     Default   : \-
     May be set by tha user up in order ta specify a USER binary spec file
     ta be used by CPackRPM instead of generatin tha file.
     Da specified file is ghon be processed by configure_file( @ONLY).
     One can provide a cold-ass lil component specific file by setting
     CPACK_RPM_<componentName>_USER_BINARY_SPECFILE.
  CPACK_RPM_GENERATE_USER_BINARY_SPECFILE_TEMPLATE \- Spec file template.
     Mandatory : NO
     Default   : \-
     If set CPack will generate a template fo' USER specified binary
     spec file n' stop wit a error. Shiiit, dis aint no joke. For example launch CPack like this
     cpack \-D CPACK_RPM_GENERATE_USER_BINARY_SPECFILE_TEMPLATE=1 \-G RPM
     Da user may then use dis file up in order ta hand\-craft is own
     binary spec file which may be used wit CPACK_RPM_USER_BINARY_SPECFILE.
  CPACK_RPM_PRE_INSTALL_SCRIPT_FILE
  CPACK_RPM_PRE_UNINSTALL_SCRIPT_FILE
     Mandatory : NO
     Default   : \-
     May be used ta embed a pre (un)installation script up in tha spec file.
     Da refered script file(s) is ghon be read n' directly
     put afta tha %pre or %preun section
     If CPACK_RPM_COMPONENT_INSTALL is set ta ON tha (un)install script for
     each component can be overridden with
     CPACK_RPM_<COMPONENT>_PRE_INSTALL_SCRIPT_FILE and
     CPACK_RPM_<COMPONENT>_PRE_UNINSTALL_SCRIPT_FILE
     One may verify which scriptlet has been included with
      rpm \-qp \-\-scripts  package.rpm
  CPACK_RPM_POST_INSTALL_SCRIPT_FILE
  CPACK_RPM_POST_UNINSTALL_SCRIPT_FILE
     Mandatory : NO
     Default   : \-
     May be used ta embed a post (un)installation script up in tha spec file.
     Da refered script file(s) is ghon be read n' directly
     put afta tha %post or %postun section
     If CPACK_RPM_COMPONENT_INSTALL is set ta ON tha (un)install script for
     each component can be overridden with
     CPACK_RPM_<COMPONENT>_POST_INSTALL_SCRIPT_FILE and
     CPACK_RPM_<COMPONENT>_POST_UNINSTALL_SCRIPT_FILE
     One may verify which scriptlet has been included with
      rpm \-qp \-\-scripts  package.rpm
  CPACK_RPM_USER_FILELIST
  CPACK_RPM_<COMPONENT>_USER_FILELIST
     Mandatory : NO
     Default   : \-
     May be used ta explicitly specify %(<directive>) file line
     up in tha spec file. Like %config(noreplace) or any other directive
     dat be found up in tha %filez section. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since CPackRPM is generating
     tha list of filez (and directories) tha user specified filez of
     tha CPACK_RPM_<COMPONENT>_USER_FILELIST list is ghon be removed from tha generated list.
  CPACK_RPM_CHANGELOG_FILE \- RPM chizzlelog file.
     Mandatory : NO
     Default   : \-
     May be used ta embed a cold-ass lil chizzlelog up in tha spec file.
     Da refered file is ghon be read n' directly put afta tha %changelog
     section.
  CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST \- list of path ta be excluded.
     Mandatory : NO
     Default   : /etc /etc/init.d /usr /usr/share /usr/share/doc /usr/bin /usr/lib /usr/lib64 /usr/include
     May be used ta exclude path (directories or files) from tha auto\-generated
     list of paths discovered by CPack RPM. Da defaut value gotz nuff a reasonable
     set of joints if tha variable aint defined by tha user n' shit. If tha variable
     is defined by tha user then CPackRPM will NOT any of tha default path.
     If you wanna add some path ta tha default list then you can use
     CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION variable.
  CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION \- additionizzle list of path ta be excluded.
     Mandatory : NO
     Default   : \-
     May be used ta add mo' exclude path (directories or files) from tha initial
     default list of excluded paths. Right back up in yo muthafuckin ass. See CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST.
.fi

.TP
.B CPackWIX
CPack WiX generator specific options




Da followin variablez is specific ta tha installaz built on Windows rockin WiX.


.nf
  CPACK_WIX_UPGRADE_GUID \- Upgrade GUID (Product/@UpgradeCode)
.fi




Will be automatically generated unless explicitly provided.


It should be explicitly set ta a cold-ass lil constant generated gloabally unique identifier (GUID) ta allow yo' installaz ta replace existin installations dat use tha same GUID.


Yo ass may fo' example explicitly set dis variable up in yo' CMakeLists.txt ta tha value dat has been generated per default. Yo ass should not use GUIDs dat you did not generate yo ass or which may belong ta other projects.


A GUID shall have tha followin fixed length syntax: XXXXXXXX\-XXXX\-XXXX\-XXXX\-XXXXXXXXXXXX


.nf
  (each X represents a uppercase hexadecimal digit)
  CPACK_WIX_PRODUCT_GUID \- Product GUID (Product/@Id)
.fi




Will be automatically generated unless explicitly provided.


If explicitly provided dis will set tha Product Id of yo' installer.


Da installa will abort if it detects a pre\-existin installation dat uses tha same ol' dirty GUID.


Da GUID shall use tha syntax busted lyrics bout fo' CPACK_WIX_UPGRADE_GUID.


.nf
  CPACK_WIX_LICENSE_RTF \- RTF License File
.fi




If CPACK_RESOURCE_FILE_LICENSE has a .rtf extension it is used as\-is.


If CPACK_RESOURCE_FILE_LICENSE has a .txt extension it is implicitly converted ta RTF by tha WiX Generator.


With CPACK_WIX_LICENSE_RTF you can override tha license file used by tha WiX Generator up in case CPACK_RESOURCE_FILE_LICENSE is up in a unsupported format or tha .txt \-> .rtf conversion do not work as expected.





CPACK_WIX_PRODUCT_ICON \- Da Icon shown next ta tha program name up in Add/Remove programs.


If set, dis icon is used up in place of tha default icon.





CPACK_WIX_UI_BANNER \- Da bitmap will step tha fuck up all up in tha top of all installa pages other than tha welcome n' completion dialogs.


If set, dis image will replace tha default banner image.


This image must be 493 by 58 pixels.





CPACK_WIX_UI_DIALOG \- Background bitmap used on tha welcome n' completion dialogs.


If dis variable is set, tha installa will replace tha default dialog image.


This image must be 493 by 312 pixels.





CPACK_WIX_PROGRAM_MENU_FOLDER \- Start menu folda name fo' launcher.


If dis variable aint set, it is ghon be initialized wit CPACK_PACKAGE_NAME


CPACK_WIX_CULTURES \- Language(s) of tha installer


Languages is compiled tha fuck into tha WixUI extension library. To use them, simply provide tha name of tha culture.  If you specify mo' than one culture identifier up in a cold-ass lil comma or semicolon delimited list, tha straight-up original gangsta one dat is found is ghon be used. Y'all KNOW dat shit, muthafucka!  Yo ass can find a list of supported languages at: http://wix.sourceforge.net/manual\-wix3/WixUI_localization.htm


CPACK_WIX_TEMPLATE \- Template file fo' WiX generation


If dis variable is set, tha specified template is ghon be used ta generate tha WiX wxs file. This should be used if further customization of tha output is required.


If dis variable aint set, tha default MSI template included wit CMake is ghon be used.


.TP
.B CTest
Configure a project fo' testin wit CTest/CDash

Include dis module up in tha top CMakeLists.txt file of a project ta enable testin wit CTest n' dashboard submissions ta CDash:


.nf
   project(MyProject)
   ...
   include(CTest)
.fi

Da module automatically creates a BUILD_TESTING option dat selects whether ta enable testin support (ON by default).  Afta includin tha module, use code like


.nf
   if(BUILD_TESTING)
     # ... CMake code ta create tests ...
   endif()
.fi

to bustin tests when testin is enabled.


To enable submissions ta a CDash server, create a CTestConfig.cmake file all up in tha top of tha project wit content such as


.nf
   set(CTEST_PROJECT_NAME "MyProject")
   set(CTEST_NIGHTLY_START_TIME "01:00:00 UTC")
   set(CTEST_DROP_METHOD "http")
   set(CTEST_DROP_SITE "my.cdash.org")
   set(CTEST_DROP_LOCATION "/submit.php?project=MyProject")
   set(CTEST_DROP_SITE_CDASH TRUE)
.fi

(the CDash server can provide tha file ta a project administrator whoz ass configures 'MyProject'). Right back up in yo muthafuckin ass. Settings up in tha config file is shared by both dis CTest module n' tha CTest command\-line toolz dashboard script mode (ctest \-S).


While buildin a project fo' submission ta CDash, CTest scans tha build output fo' errors n' warnings n' reports dem wit surroundin context from tha build log.  This generic approach works fo' all build tools yo, but do not give details bout tha command invocation dat produced a given problem.  One may git mo' detailed reports by adding


.nf
   set(CTEST_USE_LAUNCHERS 1)
.fi

to tha CTestConfig.cmake file.  When dis option is enabled, tha CTest module  drops some lyrics ta CMakez Makefile generators ta invoke every last muthafuckin command up in tha generated build system all up in a CTest launcher program.  (Currently tha CTEST_USE_LAUNCHERS option is ignored on non\-Makefile generators.)  Durin a manual build each launcher transparently runs tha command it wraps.  Durin a CTest\-driven build fo' submission ta CDash each launcher reports detailed shiznit when its command fails or warns. (Settin CTEST_USE_LAUNCHERS up in CTestConfig.cmake is convenient yo, but also addz tha launcher overhead even fo' manual builds.  One may instead set it up in a CTest dashboard script n' add it ta tha CMake cache fo' tha build tree.)

.TP
.B CTestScriptMode
.nf
 
.fi

This file is read by ctest up in script mode (\-S)

.TP
.B CTestUseLaunchers
Set tha RULE_LAUNCH_* global propertizzles when CTEST_USE_LAUNCHERS is on.

CTestUseLaunchers be automatically included when you include(CTest). But fuck dat shiznit yo, tha word on tha street is dat it is split up tha fuck into its own module file so projects can use tha CTEST_USE_LAUNCHERS functionalitizzle independently.


To use launchers, set CTEST_USE_LAUNCHERS ta ON up in a cold-ass lil ctest \-S dashboard script, n' then also set it up in tha cache of tha configured project. Both cmake n' ctest need ta know tha value of it fo' tha launchers ta work properly. CMake need ta know up in order ta generate proper build rules, n' ctest, up in order ta produce tha proper error n' warnin analysis.


For convenience, you may set tha ENV variable CTEST_USE_LAUNCHERS_DEFAULT up in yo' ctest \-S script, like a muthafucka. Then, as long as yo' CMakeLists uses include(CTest) or include(CTestUseLaunchers), it will use tha value of tha ENV variable ta initialize a CTEST_USE_LAUNCHERS cache variable. This cache variable initialization only occurs if CTEST_USE_LAUNCHERS aint already defined.

.TP
.B CheckCCompilerFlag
Peep whether tha C compila supports a given flag.

CHECK_C_COMPILER_FLAG(<flag> <var>)


.nf
  <flag> \- tha compila flag
  <var>  \- variable ta store tha result
.fi

This internally calls tha check_c_source_compilez macro n' sets CMAKE_REQUIRED_DEFINITIONS ta <flag>. Right back up in yo muthafuckin ass. See help fo' CheckCSourceCompilez fo' a listin of variablez dat can otherwise modify tha build. Y'all KNOW dat shit, muthafucka! Da result only  drops some lyrics ta dat tha compila do not give a error message when it encountas tha flag. If tha flag has any effect or even a specific one is beyond tha scope of dis module.

.TP
.B CheckCSourceCompiles
Peep if given C source compilez n' links tha fuck into a executable

CHECK_C_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail\-regex>])


.nf
  <code>       \- source code ta try ta compile, must define 'main'
  <var>        \- variable ta store whether tha source code compiled
  <fail\-regex> \- fail if test output matches dis regex
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCSourceRuns
Peep if tha given C source code compilez n' runs.

CHECK_C_SOURCE_RUNS(<code> <var>)


.nf
  <code>   \- source code ta try ta compile
  <var>    \- variable ta store tha result
             (1 fo' success, empty fo' failure)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXCompilerFlag
Peep whether tha CXX compila supports a given flag.

CHECK_CXX_COMPILER_FLAG(<flag> <var>)


.nf
  <flag> \- tha compila flag
  <var>  \- variable ta store tha result
.fi

This internally calls tha check_cxx_source_compilez macro n' sets CMAKE_REQUIRED_DEFINITIONS ta <flag>. Right back up in yo muthafuckin ass. See help fo' CheckCXXSourceCompilez fo' a listin of variablez dat can otherwise modify tha build. Y'all KNOW dat shit, muthafucka! Da result only  drops some lyrics ta dat tha compila do not give a error message when it encountas tha flag. If tha flag has any effect or even a specific one is beyond tha scope of dis module.

.TP
.B CheckCXXSourceCompiles
Peep if given C++ source compilez n' links tha fuck into a executable

CHECK_CXX_SOURCE_COMPILES(<code> <var> [FAIL_REGEX <fail\-regex>])


.nf
  <code>       \- source code ta try ta compile, must define 'main'
  <var>        \- variable ta store whether tha source code compiled
  <fail\-regex> \- fail if test output matches dis regex
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXSourceRuns
Peep if tha given C++ source code compilez n' runs.

CHECK_CXX_SOURCE_RUNS(<code> <var>)


.nf
  <code>   \- source code ta try ta compile
  <var>    \- variable ta store tha result
             (1 fo' success, empty fo' failure)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckCXXSymbolExists
Peep if a symbol exists as a gangbangin' function, variable, or macro up in C++

CHECK_CXX_SYMBOL_EXISTS(<symbol> <files> <variable>)


Peep dat tha <symbol> be available afta includin given header <files> n' store tha result up in a <variable>.  Specify tha list of filez up in one argument as a semicolon\-separated list. CHECK_CXX_SYMBOL_EXISTS() can be used ta check up in C++ files, as opposed ta CHECK_SYMBOL_EXISTS(), which works only fo' C.


If tha header filez define tha symbol as a macro it is considered available n' assumed ta work.  If tha header filez declare tha symbol as a gangbangin' function or variable then tha symbol must also be available fo' linking.  If tha symbol be a type or enum value it aint gonna be recognized (consider rockin CheckTypeSize or CheckCSourceCompiles).


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckFortranFunctionExists
macro which checks if tha Fortran function exists

CHECK_FORTRAN_FUNCTION_EXISTS(FUNCTION VARIABLE)


.nf
  FUNCTION \- tha name of tha Fortran function
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckFunctionExists
Peep if a C function can be linked

CHECK_FUNCTION_EXISTS(<function> <variable>)


Peep dat tha <function> is provided by libraries on tha system n' store tha result up in a <variable>.  This do not verify dat any system header file declares tha function, only dat it can be found at link time (consider rockin CheckSymbolExists).


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckIncludeFile
macro which checks tha include file exists.

CHECK_INCLUDE_FILE(INCLUDE VARIABLE)


.nf
  INCLUDE  \- name of include file
  VARIABLE \- variable ta return result
.fi




an optionizzle third argument is tha CFlags ta add ta tha compile line or you can use CMAKE_REQUIRED_FLAGS


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




.TP
.B CheckIncludeFileCXX
Peep if tha include file exists.

.nf
  CHECK_INCLUDE_FILE_CXX(INCLUDE VARIABLE)
.fi




.nf
  INCLUDE  \- name of include file
  VARIABLE \- variable ta return result
.fi




An optionizzle third argument is tha CFlags ta add ta tha compile line or you can use CMAKE_REQUIRED_FLAGS.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




.TP
.B CheckIncludeFiles
Peep if tha filez can be included




CHECK_INCLUDE_FILES(INCLUDE VARIABLE)


.nf
  INCLUDE  \- list of filez ta include
  VARIABLE \- variable ta return result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi

.TP
.B CheckLanguage
Peep if a language can be enabled

Usage:


.nf
  check_language(<lang>)
.fi

where <lang> be a language dat may be passed ta enable_language() like fuckin "Fortran".  If CMAKE_<lang>_COMPILER be already defined tha check do nothing.  Otherwise it tries enablin tha language up in a test project.  Da result is cached up in CMAKE_<lang>_COMPILER as tha compila dat was found, or NOTFOUND if tha language cannot be enabled.


Example:


.nf
  check_language(Fortran)
  if(CMAKE_Fortran_COMPILER)
    enable_language(Fortran)
  else()
    message(STATUS "No Fortran support")
  endif()
.fi

.TP
.B CheckLibraryExists
Peep if tha function exists.

CHECK_LIBRARY_EXISTS (LIBRARY FUNCTION LOCATION VARIABLE)


.nf
  LIBRARY  \- tha name of tha library yo ass is lookin for
  FUNCTION \- tha name of tha function
  LOCATION \- location where tha library should be found
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckPrototypeDefinition
Peep if tha protoype we expect is erect.

check_prototype_definition(FUNCTION PROTOTYPE RETURN HEADER VARIABLE)


.nf
  FUNCTION \- Da name of tha function (used ta check if prototype exists)
  PROTOTYPE\- Da prototype ta check.
  RETURN \- Da return value of tha function.
  HEADER \- Da header filez required.
  VARIABLE \- Da variable ta store tha result.
.fi

Example:


.nf
  check_prototype_definition(getpwent_r
   "struct passwd *getpwent_r(struct passwd *src, char *buf, int buflen)"
   "NULL"
   "unistd.h;pwd.h"
   SOLARIS_GETPWENT_R)
.fi

Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckStructHasMember
Peep if tha given struct or class has tha specified member variable

CHECK_STRUCT_HAS_MEMBER (STRUCT MEMBER HEADER VARIABLE)


.nf
  STRUCT \- tha name of tha struct or class yo ass is interested in
  MEMBER \- tha member which existence you wanna check
  HEADER \- tha header(s) where tha prototype should be declared
  VARIABLE \- variable ta store tha result
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
.fi




Example: CHECK_STRUCT_HAS_MEMBER("struct timeval" tv_sec sys/select.h HAVE_TIMEVAL_TV_SEC)

.TP
.B CheckSymbolExists
Peep if a symbol exists as a gangbangin' function, variable, or macro

CHECK_SYMBOL_EXISTS(<symbol> <files> <variable>)


Peep dat tha <symbol> be available afta includin given header <files> n' store tha result up in a <variable>.  Specify tha list of filez up in one argument as a semicolon\-separated list.


If tha header filez define tha symbol as a macro it is considered available n' assumed ta work.  If tha header filez declare tha symbol as a gangbangin' function or variable then tha symbol must also be available fo' linking.  If tha symbol be a type or enum value it aint gonna be recognized (consider rockin CheckTypeSize or CheckCSourceCompiles). If tha check need ta be done up in C++, consider rockin CHECK_CXX_SYMBOL_EXISTS(), which do tha same as CHECK_SYMBOL_EXISTS() yo, but up in C++.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B CheckTypeSize
Peep sizeof a type

.nf
  CHECK_TYPE_SIZE(TYPE VARIABLE [BUILTIN_TYPES_ONLY])
.fi

Peep if tha type exists n' determine its size. On return, "HAVE_${VARIABLE}" holdz tha existence of tha type, n' "${VARIABLE}" holdz one of tha following:


.nf
   <size> = type has non\-zero size <size>
   "0"    = type has arch\-dependent size (see below)
   ""     = type do not exist
.fi

Furthermore, tha variable "${VARIABLE}_CODE" holdz C preprocessor code ta define tha macro "${VARIABLE}" ta tha size of tha type, or leave tha macro undefined if tha type do not exist.


Da variable "${VARIABLE}" may be "0" when CMAKE_OSX_ARCHITECTURES has multiple architectures fo' buildin OS X universal binaries. Put ya muthafuckin choppers up if ya feel dis! This indicates dat tha type size varies across architectures. In dis case "${VARIABLE}_CODE" gotz nuff C preprocessor tests mappin from each architecture macro ta tha correspondin type size. Da list of architecture macros is stored up in "${VARIABLE}_KEYS", n' tha value fo' each key is stored up in "${VARIABLE}\-${KEY}".


If tha BUILTIN_TYPES_ONLY option aint given, tha macro checks fo' headaz <sys/types.h>, <stdint.h>, n' <stddef.h>, n' saves thangs up in dis biatch up in HAVE_SYS_TYPES_H, HAVE_STDINT_H, n' HAVE_STDDEF_H.  Da type size check automatically includes tha available headers, thus supportin checkz of types defined up in tha headers.


Despite tha name of tha macro you may use it ta check tha size of mo' complex expressions, like a muthafucka. To check e.g. fo' tha size of a struct member you can do suttin' like this:


.nf
  check_type_size("((struct something*)0)\->member" SIZEOF_MEMBER)
.fi




Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_INCLUDES = list of include directories
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
  CMAKE_EXTRA_INCLUDE_FILES = list of extra headaz ta include
.fi

.TP
.B CheckVariableExists
Peep if tha variable exists.

.nf
  CHECK_VARIABLE_EXISTS(VAR VARIABLE)
.fi




.nf
  VAR      \- tha name of tha variable
  VARIABLE \- variable ta store tha result
.fi




This macro is only fo' C variables.


Da followin variablez may be set before callin dis macro ta modify tha way tha check is run:


.nf
  CMAKE_REQUIRED_FLAGS = strang of compile command line flags
  CMAKE_REQUIRED_DEFINITIONS = list of macros ta define (\-DFOO=bar)
  CMAKE_REQUIRED_LIBRARIES = list of libraries ta link
.fi

.TP
.B Dart
Configure a project fo' testin wit CTest or oldschool Dart Tcl Client

This file is tha backwards\-compatibilitizzle version of tha CTest module. Well shiiiit, it supports rockin tha oldschool Dart 1 Tcl client fo' rollin dashboard submissions as well as testin wit CTest.  This module should be included up in tha CMakeLists.txt file all up in tha top of a project.  Typical usage:


.nf
  include(Dart)
  if(BUILD_TESTING)
    # ... testin related CMake code ...
  endif()
.fi

Da BUILD_TESTING option is pimped by tha Dart module ta determine whether testin support should be enabled. Y'all KNOW dat shit, muthafucka!  Da default is ON.

.TP
.B DeployQt4
Functions ta help assemble a standalone Qt4 executable.

A collection of CMake utilitizzle functions useful fo' deployin Qt4 executables.


Da followin functions is provided by dis module:


.nf
   write_qt4_conf
   resolve_qt4_paths
   fixup_qt4_executable
   install_qt4_plugin_path
   install_qt4_plugin
   install_qt4_executable
.fi

Requires CMake 2.6 or pimped outa cuz it uses function n' PARENT_SCOPE fo' realz. Also dependz on BundleUtilities.cmake.


.nf
  WRITE_QT4_CONF(<qt_conf_dir> <qt_conf_contents>)
.fi

Writes a qt.conf file wit tha <qt_conf_contents> tha fuck into <qt_conf_dir>.


.nf
  RESOLVE_QT4_PATHS(<paths_var> [<executable_path>])
.fi

Loop all up in <paths_var> list n' if any don't exist resolve dem relatizzle ta tha <executable_path> (if supplied) or tha CMAKE_INSTALL_PREFIX.


.nf
  FIXUP_QT4_EXECUTABLE(<executable> [<qtplugins> <libs> <dirs> <plugins_dir> <request_qt_conf>])
.fi

Copies Qt plugins, writes a Qt configuration file (if needed) n' fixes up a Qt4 executable rockin BundleUtilitizzles so it is standalone n' can be drag\-and\-drop copied ta another machine as long as all of tha system libraries is compatible.


<executable> should point ta tha executable ta be fixed\-up.


<qtplugins> should contain a list of tha names or pathz of any Qt plugins ta be installed.


<libs> is ghon be passed ta BundleUtilitizzles n' should be a list of any already installed plugins, libraries or executablez ta also be fixed\-up.


<dirs> is ghon be passed ta BundleUtilitizzles n' should contain n' directories ta be searched ta find library dependencies.


<plugins_dir> allows a custom plugins directory ta be used.


<request_qt_conf> will force a qt.conf file ta be freestyled even if not needed.


.nf
  INSTALL_QT4_PLUGIN_PATH(plugin executable copy installed_plugin_path_var <plugins_dir> <component> <configurations>)
.fi

Install (or copy) a resolved <plugin> ta tha default plugins directory (or <plugins_dir>) relatizzle ta <executable> n' store tha result up in <installed_plugin_path_var>.


If <copy> is set ta TRUE then tha plugins is ghon be copied rather than installed. Y'all KNOW dat shit, muthafucka! This is ta allow dis module ta be used at CMake time rather than install time.


If <component> is set then anythang installed will use dis COMPONENT.


.nf
  INSTALL_QT4_PLUGIN(plugin executable copy installed_plugin_path_var <plugins_dir> <component>)
.fi

Install (or copy) a unresolved <plugin> ta tha default plugins directory (or <plugins_dir>) relatizzle ta <executable> n' store tha result up in <installed_plugin_path_var>. Right back up in yo muthafuckin ass. See documentation of INSTALL_QT4_PLUGIN_PATH.


.nf
  INSTALL_QT4_EXECUTABLE(<executable> [<qtplugins> <libs> <dirs> <plugins_dir> <request_qt_conf> <component>])
.fi

Installs Qt plugins, writes a Qt configuration file (if needed) n' fixes up a Qt4 executable rockin BundleUtilitizzles so it is standalone n' can be drag\-and\-drop copied ta another machine as long as all of tha system libraries is compatible. Da executable is ghon be fixed\-up at install time. <component> is tha COMPONENT used fo' bundle fixup n' plugin installation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See documentation of FIXUP_QT4_BUNDLE.

.TP
.B Documentation
DocumentationVTK.cmake

This file serves up support fo' tha VTK documentation framework. Well shiiiit, it relies on nuff muthafuckin tools (Doxygen, Perl, etc).

.TP
.B ExternalData
Manage data filez stored outside source tree

Use dis module ta unambiguously reference data filez stored outside tha source tree n' fetch dem at build time from arbitrary local n' remote content\-addressed locations.  Functions provided by dis module recognize arguments wit tha syntax "DATA{<name>}" as references ta external data, replace dem wit full paths ta local copiez of dem data, n' create build rulez ta fetch n' update tha local copies.


Da DATA{} syntax is literal n' tha <name> be a gangbangin' full or relatizzle path within tha source tree.  Da source tree must contain either a real data file at <name> or a "content link" at <name><ext> containin a hash of tha real file rockin a hash algorithm correspondin ta <ext>.  For example, tha argument "DATA{img.png}" may be satisfied by either a real "img.png" file up in tha current source directory or a "img.png.md5" file containin its MD5 sum.


Da 'ExternalData_Expand_Arguments' function evaluates DATA{} references up in its arguments n' constructs a freshly smoked up list of arguments:


.nf
  ExternalData_Expand_Arguments(
    <target>   # Name of data pimpment target
    <outVar>   # Output variable
    [args...]  # Input arguments, DATA{} allowed
    )
.fi

It replaces each DATA{} reference up in a argument wit tha full path of a real data file on disk dat will exist afta tha <target> builds.


Da 'ExternalData_Add_Test' function wraps round tha CMake add_test() command but supports DATA{} references up in its arguments:


.nf
  ExternalData_Add_Test(
    <target>   # Name of data pimpment target
    ...        # Argumentz of add_test(), DATA{} allowed
    )
.fi

It passes its arguments all up in ExternalData_Expand_Arguments n' then invokes add_test() rockin tha thangs up in dis biatch.


Da 'ExternalData_Add_Target' function creates a cold-ass lil custom target ta manage local instancez of data filez stored externally:


.nf
  ExternalData_Add_Target(
    <target>   # Name of data pimpment target
    )
.fi

It creates custom commandz up in tha target as necessary ta make data filez available fo' each DATA{} reference previously evaluated by other functions provided by dis module.  A list of URL templates must be provided up in tha variable ExternalData_URL_TEMPLATES rockin tha placeholdaz "%(algo)" n' "%(hash)" up in each template.  Data fetch rulez try each URL template up in order by substitutin tha hash algorithm name fo' "%(algo)" n' tha hash value fo' "%(hash)".


Da followin hash algorithms is supported:


.nf
    %(algo)     <ext>     Description
    \-\-\-\-\-\-\-     \-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-
    MD5         .md5      Message\-Digest Algorithm 5, RFC 1321
    SHA1        .sha1     US Secure Hash Algorithm 1, RFC 3174
    SHA224      .sha224   US Secure Hash Algorithms, RFC 4634
    SHA256      .sha256   US Secure Hash Algorithms, RFC 4634
    SHA384      .sha384   US Secure Hash Algorithms, RFC 4634
    SHA512      .sha512   US Secure Hash Algorithms, RFC 4634
.fi

Note dat tha hashes is used only fo' unique data identification n' downlizzle verification. I aint talkin' bout chicken n' gravy biatch.  This aint securitizzle software.


Example usage:


.nf
   include(ExternalData)
   set(ExternalData_URL_TEMPLATES "file:///local/%(algo)/%(hash)"
                                  "http://data.org/%(algo)/%(hash)")
   ExternalData_Add_Test(MyData
     NAME MyTest
     COMMAND MyExe DATA{MyInput.png}
     )
   ExternalData_Add_Target(MyData)
.fi

When test "MyTest" runs tha "DATA{MyInput.png}" argument is ghon be replaced by tha full path ta a real instizzle of tha data file "MyInput.png" on disk.  If tha source tree gotz nuff a cold-ass lil content link like fuckin "MyInput.png.md5" then tha "MyData" target creates a real "MyInput.png" up in tha build tree.


Da DATA{} syntax can be holla'd at ta fetch a gangbangin' file series rockin tha form "DATA{<name>,:}", where tha ":" is literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha source tree gotz nuff a crew of filez or content links named like a series then a reference ta one member addz rulez ta fetch all of em.  Although all thugz of a series is fetched, only tha file originally named by tha DATA{} argument is substituted fo' dat shit.  Da default configuration recognizes file series names endin wit "#.ext", "_#.ext", ".#.ext", or "\-#.ext" where "#" be a sequence of decimal digits n' ".ext" be any single extension. I aint talkin' bout chicken n' gravy biatch.  Configure it wit a regex dat parses <number> n' <suffix> parts from tha end of <name>:


.nf
  ExternalData_SERIES_PARSE = regex of tha form (<number>)(<suffix>)$
.fi

For mo' fucked up cases set:


.nf
  ExternalData_SERIES_PARSE = regex wit at least two () groups
  ExternalData_SERIES_PARSE_PREFIX = <prefix> regex crew number, if any
  ExternalData_SERIES_PARSE_NUMBER = <number> regex crew number
  ExternalData_SERIES_PARSE_SUFFIX = <suffix> regex crew number
.fi

Configure series number matchin wit a regex dat matches tha <number> part of series thugz named <prefix><number><suffix>:


.nf
  ExternalData_SERIES_MATCH = regex matchin <number> up in all series members
.fi

Note dat tha <suffix> of a series do not include a hash\-algorithm extension.


Da DATA{} syntax can alternatively match filez associated wit tha named file n' contained up in tha same directory.  Associated filez may be specified by options rockin tha syntax DATA{<name>,<opt1>,<opt2>,...}.  Each option may specify one file by name or specify a regular expression ta match file names rockin tha syntax REGEX:<regex>.  For example, tha arguments


.nf
   DATA{MyData/MyInput.mhd,MyInput.img}                   # File pair
   DATA{MyData/MyFrames00.png,REGEX:MyFrames[0\-9]+\\\\.png} # Series
.fi

will pass MyInput.mha n' MyFrames00.png on tha command line but ensure dat tha associated filez is present next ta em.


Da DATA{} syntax may reference a gangbangin' finger-lickin' directory rockin a trailin slash n' a list of associated files.  Da form DATA{<name>/,<opt1>,<opt2>,...} addz rulez ta fetch any filez up in tha directory dat match one of tha associated file options.  For example, tha argument DATA{MyDataDir/,REGEX:.*} will pass tha full path ta a MyDataDir directory on tha command line n' ensure dat tha directory gotz nuff filez correspondin ta every last muthafuckin file or content link up in tha MyDataDir source directory.


Da variable ExternalData_LINK_CONTENT may be set ta tha name of a supported hash algorithm ta enable automatic conversion of real data filez referenced by tha DATA{} syntax tha fuck into content links.  For each such <file> a cold-ass lil content link named "<file><ext>" is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da original gangsta file is renamed ta tha form ".ExternalData_<algo>_<hash>" ta stage it fo' future transmission ta one of tha locations up in tha list of URL templates (by means outside tha scope of dis module).  Da data fetch rule pimped fo' tha content link will use tha staged object if it cannot be found rockin any URL template.


Da variable ExternalData_OBJECT_STORES may be set ta a list of local directories dat store objects rockin tha layout <dir>/%(algo)/%(hash). These directories is ghon be searched first fo' a needed object.  If tha object aint available up in any store then it is ghon be fetched remotely rockin tha URL templates n' added ta tha straight-up original gangsta local store listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no stores is specified tha default be a location inside tha build tree.


Da variable ExternalData_SOURCE_ROOT may be set ta tha highest source directory containin any path named by a DATA{} reference.  Da default is CMAKE_SOURCE_DIR.  ExternalData_SOURCE_ROOT n' CMAKE_SOURCE_DIR must refer ta directories within a single source distribution (e.g. they come together up in one tarball).


Da variable ExternalData_BINARY_ROOT may be set ta tha directory ta hold tha real data filez named by expanded DATA{} references.  Da default is CMAKE_BINARY_DIR.  Da directory layout will mirror dat of content links under ExternalData_SOURCE_ROOT.


Variablez ExternalData_TIMEOUT_INACTIVITY n' ExternalData_TIMEOUT_ABSOLUTE set tha downlizzle inactivitizzle n' absolute timeouts, up in seconds.  Da defaults is 60 secondz n' 300 seconds, respectively.  Set either timeout ta 0 secondz ta disable enforcement.

.TP
.B ExternalProject
Smoke custom targets ta build projects up in external trees

Da 'ExternalProject_Add' function creates a cold-ass lil custom target ta drive download, update/patch, configure, build, install n' test stepz of a external project:


.nf
  ExternalProject_Add(<name>    # Name fo' custom target
    [DEPENDS projects...]       # Targets on which tha project depends
    [PREFIX dir]                # Root dir fo' entire project
    [LIST_SEPARATOR sep]        # Sep ta be replaced by ; up in cmd lines
    [TMP_DIR dir]               # Directory ta store temporary files
    [STAMP_DIR dir]             # Directory ta store step timestamps
   #\-\-Downlizzle step\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [DOWNLOAD_NAME fname]       # File name ta store (if not end of URL)
    [DOWNLOAD_DIR dir]          # Directory ta store downloaded files
    [DOWNLOAD_COMMAND cmd...]   # Command ta downlizzle source tree
    [CVS_REPOSITORY cvsroot]    # CVSROOT of CVS repository
    [CVS_MODULE mod]            # Module ta checkout from CVS repo
    [CVS_TAG tag]               # Tag ta checkout from CVS repo
    [SVN_REPOSITORY url]        # URL of Subversion repo
    [SVN_REVISION rev]          # Revision ta checkout from Subversion repo
    [SVN_USERNAME john ]        # Username fo' Subversion checkout n' update
    [SVN_PASSWORD doe ]         # Password fo' Subversion checkout n' update
    [SVN_TRUST_CERT 1 ]         # Trust tha Subversion server joint certificate
    [GIT_REPOSITORY url]        # URL of git repo
    [GIT_TAG tag]               # Git branch name, commit id or tag
    [HG_REPOSITORY url]         # URL of mercurial repo
    [HG_TAG tag]                # Mercurial branch name, commit id or tag
    [URL /.../src.tgz]          # Full path or URL of source
    [URL_HASH ALGO=value]       # Hash of file at URL
    [URL_MD5 md5]               # Equivalent ta URL_HASH MD5=md5
    [TLS_VERIFY bool]           # Should certificate fo' https be checked
    [TLS_CAINFO file]           # Path ta a cold-ass lil certificate authoritizzle file
    [TIMEOUT seconds]           # Time allowed fo' file downlizzle operations
   #\-\-Update/Patch step\-\-\-\-\-\-\-\-\-\-
    [UPDATE_COMMAND cmd...]     # Source work\-tree update command
    [PATCH_COMMAND cmd...]      # Command ta patch downloaded source
   #\-\-Configure step\-\-\-\-\-\-\-\-\-\-\-\-\-
    [SOURCE_DIR dir]            # Source dir ta be used fo' build
    [CONFIGURE_COMMAND cmd...]  # Build tree configuration command
    [CMAKE_COMMAND /.../cmake]  # Specify alternatizzle cmake executable
    [CMAKE_GENERATOR gen]       # Specify generator fo' natizzle build
    [CMAKE_GENERATOR_TOOLSET t] # Generator\-specific toolset name
    [CMAKE_ARGS args...]        # Arguments ta CMake command line
    [CMAKE_CACHE_ARGS args...]  # Initial cache arguments, of tha form \-Dvar:string=on
   #\-\-Build step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [BINARY_DIR dir]            # Specify build dir location
    [BUILD_COMMAND cmd...]      # Command ta drive tha natizzle build
    [BUILD_IN_SOURCE 1]         # Use source dir fo' build dir
   #\-\-Install step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [INSTALL_DIR dir]           # Installation prefix
    [INSTALL_COMMAND cmd...]    # Command ta drive install afta build
   #\-\-Test step\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
    [TEST_BEFORE_INSTALL 1]     # Add test step executed before install step
    [TEST_AFTER_INSTALL 1]      # Add test step executed afta install step
    [TEST_COMMAND cmd...]       # Command ta drive test
   #\-\-Output logging\-\-\-\-\-\-\-\-\-\-\-\-\-
    [LOG_DOWNLOAD 1]            # Wrap downlizzle up in script ta log output
    [LOG_UPDATE 1]              # Wrap update up in script ta log output
    [LOG_CONFIGURE 1]           # Wrap configure up in script ta log output
    [LOG_BUILD 1]               # Wrap build up in script ta log output
    [LOG_TEST 1]                # Wrap test up in script ta log output
    [LOG_INSTALL 1]             # Wrap install up in script ta log output
   #\-\-Custom targets\-\-\-\-\-\-\-\-\-\-\-\-\-
    [STEP_TARGETS st1 st2 ...]  # Generate custom targets fo' these steps
    )
.fi

Da *_DIR options specify directories fo' tha project, wit default directories computed as bigs up. If tha PREFIX option is given ta ExternalProject_Add() or tha EP_PREFIX directory property is set, then a external project is built n' installed under tha specified prefix:


.nf
   TMP_DIR      = <prefix>/tmp
   STAMP_DIR    = <prefix>/src/<name>\-stamp
   DOWNLOAD_DIR = <prefix>/src
   SOURCE_DIR   = <prefix>/src/<name>
   BINARY_DIR   = <prefix>/src/<name>\-build
   INSTALL_DIR  = <prefix>
.fi

Otherwise, if tha EP_BASE directory property is set then componentz of a external project is stored under tha specified base:


.nf
   TMP_DIR      = <base>/tmp/<name>
   STAMP_DIR    = <base>/Stamp/<name>
   DOWNLOAD_DIR = <base>/Download/<name>
   SOURCE_DIR   = <base>/Source/<name>
   BINARY_DIR   = <base>/Build/<name>
   INSTALL_DIR  = <base>/Install/<name>
.fi

If no PREFIX, EP_PREFIX, or EP_BASE is specified then tha default is ta set PREFIX ta "<name>\-prefix". Relatizzle paths is interpreted wit respect ta tha build directory correspondin ta tha source directory up in which ExternalProject_Add is invoked.


If SOURCE_DIR is explicitly set ta a existin directory tha project is ghon be built from dat shit. Otherwise a thugged-out downlizzle step must be specified rockin one of tha DOWNLOAD_COMMAND, CVS_*, SVN_*, or URL options. Da URL option may refer locally ta a gangbangin' finger-lickin' directory or source tarball, or refer ta a remote tarbizzle (e.g. http://.../src.tgz).


Da 'ExternalProject_Add_Step' function addz a cold-ass lil custom step ta a external project:


.nf
  ExternalProject_Add_Step(<name> <step> # Namez of project n' custom step
    [COMMAND cmd...]        # Command line invoked by dis step
    [COMMENT "text..."]     # Text printed when step executes
    [DEPENDEES steps...]    # Steps on which dis step depends
    [DEPENDERS steps...]    # Steps dat depend on dis step
    [DEPENDS files...]      # Filez on which dis step depends
    [ALWAYS 1]              # No stamp file, step always runs
    [WORKING_DIRECTORY dir] # Workin directory fo' command
    [LOG 1]                 # Wrap step up in script ta log output
    )
.fi

Da command line, comment, n' hustlin directory of every last muthafuckin standard n' custom step is processed ta replace tokens <SOURCE_DIR>, <BINARY_DIR>, <INSTALL_DIR>, n' <TMP_DIR> wit correspondin property joints.


Any builtin step dat specifies a "<step>_COMMAND cmd..." or custom step dat specifies a "COMMAND cmd..." may specify additionizzle command lines rockin tha form "COMMAND cmd...".  At build time tha commandz is ghon be executed up in order n' aborted if any one fails.  For example:


.nf
  ... BUILD_COMMAND make COMMAND echo done ...
.fi

specifies ta run "make" n' then "echo done" durin tha build step. Whether tha current hustlin directory is preserved between commandz aint defined. Y'all KNOW dat shit, muthafucka!  Behavior of shell operators like "&&" aint defined.


Da 'ExternalProject_Get_Property' function retrieves external project target properties:


.nf
  ExternalProject_Get_Property(<name> [prop1 [prop2 [...]]])
.fi

It stores property joints up in variablez of tha same name. Property names correspond ta tha keyword argument namez of 'ExternalProject_Add'.


Da 'ExternalProject_Add_StepTargets' function generates custom targets fo' tha steps listed:


.nf
  ExternalProject_Add_StepTargets(<name> [step1 [step2 [...]]])
.fi




If STEP_TARGETS is set then ExternalProject_Add_StepTargets be automatically called all up in tha end of matchin calls ta ExternalProject_Add_Step. Pass STEP_TARGETS explicitly ta individual ExternalProject_Add calls, or implicitly ta all ExternalProject_Add calls by settin tha directory property EP_STEP_TARGETS.


If STEP_TARGETS aint set, clients may still manually call ExternalProject_Add_StepTargets afta callin ExternalProject_Add or ExternalProject_Add_Step.


This functionalitizzle is provided ta make it easy as fuck  ta drive tha steps independently of each other by specifyin targets on build command lines. For example, you may be submittin ta a sub\-project based dashboard, where you wanna drive tha configure portion of tha build, then submit ta tha dashboard, followed by tha build portion, followed by tests, n' you can put dat on yo' toast. If you invoke a cold-ass lil custom target dat dependz on a step halfway all up in tha step dependency chain, then all tha previous steps will also run ta ensure every last muthafuckin thang is up ta date.


For example, ta drive configure, build n' test steps independently fo' each ExternalProject_Add call up in yo' project, write tha followin line prior ta any ExternalProject_Add calls up in yo' CMakeLists file:


.nf
   set_property(DIRECTORY PROPERTY EP_STEP_TARGETS configure build test)
.fi

.TP
.B FeatureSummary
Macros fo' generatin a summary of enabled/disabled features




This module serves up tha macros feature_summary(), set_package_properties() n' add_feature_info(). For compatibilitizzle it also still serves up set_package_info(), set_feature_info(), print_enabled_features() n' print_disabled_features().


These macros can be used ta generate a summary of enabled n' disabled packages and/or feature fo' a funky-ass build tree:


.nf
    \-\- Da followin OPTIONAL packages done been found:
    LibXml2 (required version >= 2.4) , XML processin library. , <http://xmlsoft.org>
       * Enablez HTML\-import up in MyWordProcessor
       * Enablez odt\-export up in MyWordProcessor
    PNG , A PNG image library. , <http://www.libpng.org/pub/png/>
       * Enablez savin screenshots
    \-\- Da followin OPTIONAL packages aint been found:
    Lua51 , Da Lua scriptin language. , <http://www.lua.org>
       * Enablez macros up in MyWordProcessor
    Foo , Foo serves up def stuff.
.fi







.nf
    FEATURE_SUMMARY( [FILENAME <file>]
                     [APPEND]
                     [VAR <variable_name>]
                     [INCLUDE_QUIET_PACKAGES]
                     [FATAL_ON_MISSING_REQUIRED_PACKAGES]
                     [DESCRIPTION "Found packages:"]
                     WHAT (ALL | PACKAGES_FOUND | PACKAGES_NOT_FOUND
                          | ENABLED_FEATURES | DISABLED_FEATURES]
                   )
.fi




Da FEATURE_SUMMARY() macro can be used ta print shiznit bout enabled or disabled packages or featurez of a project. By default, only tha namez of tha features/packages is ghon be printed n' they required version when one was specified. Y'all KNOW dat shit, muthafucka! Use SET_PACKAGE_PROPERTIES() ta add mo' useful shiznit, like e.g. a thugged-out downlizzle URL fo' tha respectizzle package or they purpose up in tha project.


Da WHAT option is tha only mandatory option. I aint talkin' bout chicken n' gravy biatch yo. Here you specify what tha fuck shiznit is ghon be printed:


.nf
    ALL: print every last muthafuckin thang
    ENABLED_FEATURES: tha list of all features which is enabled
    DISABLED_FEATURES: tha list of all features which is disabled
    PACKAGES_FOUND: tha list of all packages which done been found
    PACKAGES_NOT_FOUND: tha list of all packages which aint been found
    OPTIONAL_PACKAGES_FOUND: only dem packages which done been found which have tha type OPTIONAL
    OPTIONAL_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type OPTIONAL
    RECOMMENDED_PACKAGES_FOUND: only dem packages which done been found which have tha type RECOMMENDED
    RECOMMENDED_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type RECOMMENDED
    REQUIRED_PACKAGES_FOUND: only dem packages which done been found which have tha type REQUIRED
    REQUIRED_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type REQUIRED
    RUNTIME_PACKAGES_FOUND: only dem packages which done been found which have tha type RUNTIME
    RUNTIME_PACKAGES_NOT_FOUND: only dem packages which aint been found which have tha type RUNTIME
.fi




If a FILENAME is given, tha shiznit is printed tha fuck into dis file. If APPEND is used, it be appended ta dis file, otherwise tha file is overwritten if it already existed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha VAR option is used, tha shiznit is "printed" tha fuck into tha specified variable. If FILENAME aint used, tha shiznit is printed ta tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Usin tha DESCRIPTION option a thugged-out description or headline can be set which is ghon be printed above tha actual content. If INCLUDE_QUIET_PACKAGES is given, packages which done been searched wit find_package(... QUIET) will also be listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. By default they is skipped. Y'all KNOW dat shit, muthafucka! If FATAL_ON_MISSING_REQUIRED_PACKAGES is given, CMake will abort if a package which is marked as REQUIRED has not been found.


Example 1, append every last muthafuckin thang ta a gangbangin' file:


.nf
   feature_summary(WHAT ALL
                   FILENAME ${CMAKE_BINARY_DIR}/all.log APPEND)
.fi




Example 2, print tha enabled features tha fuck into tha variable enabledFeaturesText, includin QUIET packages:


.nf
   feature_summary(WHAT ENABLED_FEATURES
                   INCLUDE_QUIET_PACKAGES
                   DESCRIPTION "Enabled Features:"
                   VAR enabledFeaturesText)
   message(STATUS "${enabledFeaturesText}")
.fi







.nf
    SET_PACKAGE_PROPERTIES(<name> PROPERTIES [ URL <url> ]
                                             [ DESCRIPTION <description> ]
                                             [ TYPE (RUNTIME|OPTIONAL|RECOMMENDED|REQUIRED) ]
                                             [ PURPOSE <purpose> ]
                          )
.fi




Use dis macro ta set up shiznit bout tha named package, which can then be displayed via FEATURE_SUMMARY(). This can be done either directly up in tha Find\-module or up in tha project which uses tha module afta tha find_package() call. Da features fo' which shiznit can be set is added automatically by tha find_package() command.


URL: dis should be tha homepizzy of tha package, or suttin' similar. Shiiit, dis aint no joke. Ideally dis is set already directly up in tha Find\-module.


DESCRIPTION: A short description what tha fuck dat package is, at most one sentence. Ideally dis is set already directly up in tha Find\-module.


TYPE: What type of dependency has tha rockin project on dat package. Default is OPTIONAL. In dis case it aint nuthin but a package which can be used by tha project when available at buildtime yo, but it also work without. RECOMMENDED is similar ta OPTIONAL, i.e. tha project will build if tha package aint present yo, but tha functionalitizzle of tha resultin binaries is ghon be severly limited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a REQUIRED package aint available at buildtime, tha project may not even build. Y'all KNOW dat shit, muthafucka! This can be combined wit tha FATAL_ON_MISSING_REQUIRED_PACKAGES argument fo' feature_summary(). Last, a RUNTIME package be a package which is straight-up not used at all durin tha build yo, but which is required fo' straight-up hustlin tha resultin binaries. Put ya muthafuckin choppers up if ya feel dis! Right back up in yo muthafuckin ass. So if such a package is missing, tha project can still be built yo, but it may not work lata on. I aint talkin' bout chicken n' gravy biatch. If set_package_properties() is called multiple times fo' tha same package wit different TYPEs, tha TYPE is only chizzled ta higher TYPEs ( RUNTIME < OPTIONAL < RECOMMENDED < REQUIRED ), lower TYPEs is ignored. Y'all KNOW dat shit, muthafucka! Da TYPE property is project\-specific, so it cannot be set by tha Find\-module yo, but must be set up in tha project.


PURPOSE: This raps bout which features dis package enablez up in tha project, i.e. it  drops some lyrics ta tha user what tha fuck functionalitizzle he gets up in tha resultin binaries. Put ya muthafuckin choppers up if ya feel dis! If set_package_properties() is called multiple times fo' a package, all PURPOSE propertizzles is appended ta a list of purposez of tha package up in tha project fo' realz. As tha TYPE property, also tha PURPOSE property is project\-specific, so it cannot be set by tha Find\-module yo, but must be set up in tha project.





Example fo' settin tha info fo' a package:


.nf
   find_package(LibXml2)
   set_package_properties(LibXml2 PROPERTIES DESCRIPTION "A XML processin library."
                                             URL "http://xmlsoft.org/")
.fi




.nf
   set_package_properties(LibXml2 PROPERTIES TYPE RECOMMENDED
                                             PURPOSE "Enablez HTML\-import up in MyWordProcessor")
   ...
   set_package_properties(LibXml2 PROPERTIES TYPE OPTIONAL
                                             PURPOSE "Enablez odt\-export up in MyWordProcessor")
.fi




.nf
   find_package(DBUS)
   set_package_properties(DBUS PROPERTIES TYPE RUNTIME
                                             PURPOSE "Necessary ta disable tha screensaver durin a presentation" )
.fi




.nf
    ADD_FEATURE_INFO(<name> <enabled> <description>)
.fi

Use dis macro ta add shiznit on some gangbangin' feature wit tha given <name>. <enabled> gotz nuff whether dis feature is enabled or not, <description> be a text describin tha feature. Da shiznit can be displayed rockin feature_summary() fo' ENABLED_FEATURES n' DISABLED_FEATURES respectively.


Example fo' settin tha info fo' a gangbangin' feature:


.nf
   option(WITH_FOO "Help fo' foo" ON)
   add_feature_info(Foo WITH_FOO "Da Foo feature serves up straight-up def stuff.")
.fi







Da followin macros is provided fo' compatibilitizzle wit previous CMake versions:


.nf
    SET_PACKAGE_INFO(<name> <description> [<url> [<purpose>] ] )
.fi

Use dis macro ta set up shiznit bout tha named package, which can then be displayed via FEATURE_SUMMARY(). This can be done either directly up in tha Find\-module or up in tha project which uses tha module afta tha find_package() call. Da features fo' which shiznit can be set is added automatically by tha find_package() command.


.nf
    PRINT_ENABLED_FEATURES()
.fi

Do tha same as FEATURE_SUMMARY(WHAT ENABLED_FEATURES  DESCRIPTION "Enabled features:")


.nf
    PRINT_DISABLED_FEATURES()
.fi

Do tha same as FEATURE_SUMMARY(WHAT DISABLED_FEATURES  DESCRIPTION "Disabled features:")


.nf
    SET_FEATURE_INFO(<name> <description> [<url>] )
.fi

Do tha same as SET_PACKAGE_INFO(<name> <description> <url> )

.TP
.B FindALSA
Find alsa

Find tha alsa libraries (asound)


.nf
  This module defines tha followin variables:
     ALSA_FOUND       \- True if ALSA_INCLUDE_DIR & ALSA_LIBRARY is found
     ALSA_LIBRARIES   \- Set when ALSA_LIBRARY is found
     ALSA_INCLUDE_DIRS \- Set when ALSA_INCLUDE_DIR is found
.fi




.nf
     ALSA_INCLUDE_DIR \- where ta find asoundlib.h, etc.
     ALSA_LIBRARY     \- tha asound library
     ALSA_VERSION_STRING \- tha version of alsa found (since CMake 2.8.8)
.fi




.TP
.B FindASPELL
Try ta find ASPELL

Once done dis will define


.nf
  ASPELL_FOUND \- system has ASPELL
  ASPELL_EXECUTABLE \- tha ASPELL executable
  ASPELL_INCLUDE_DIR \- tha ASPELL include directory
  ASPELL_LIBRARIES \- Da libraries needed ta use ASPELL
  ASPELL_DEFINITIONS \- Compila switches required fo' rockin ASPELL
.fi

.TP
.B FindAVIFile
Locate AVIFILE library n' include paths

AVIFILE (http://avifile.sourceforge.net/)is a set of libraries fo' i386 machines ta use various AVI codecs. Right back up in yo muthafuckin ass. Support is limited beyond Linux. Windows serves up natizzle AVI support, n' so don't need dis library. This module defines


.nf
  AVIFILE_INCLUDE_DIR, where ta find avifile.h , etc.
  AVIFILE_LIBRARIES, tha libraries ta link against
  AVIFILE_DEFINITIONS, definitions ta use when compiling
  AVIFILE_FOUND, If false, don't try ta use AVIFILE
.fi

.TP
.B FindArmadillo
Find Armadillo

Find tha Armadillo C++ library


Usin Armadillo:


.nf
  find_package(Armadillo REQUIRED)
  include_directories(${ARMADILLO_INCLUDE_DIRS})
  add_executable(foo foo.cc)
  target_link_libraries(foo ${ARMADILLO_LIBRARIES})
.fi

This module sets tha followin variables:


.nf
  ARMADILLO_FOUND \- set ta legit if tha library is found
  ARMADILLO_INCLUDE_DIRS \- list of required include directories
  ARMADILLO_LIBRARIES \- list of libraries ta be linked
  ARMADILLO_VERSION_MAJOR \- major version number
  ARMADILLO_VERSION_MINOR \- minor version number
  ARMADILLO_VERSION_PATCH \- patch version number
  ARMADILLO_VERSION_STRING \- version number as a strang (ex: "1.0.4")
  ARMADILLO_VERSION_NAME \- name of tha version (ex: "Antipodean Antileech")
.fi

.TP
.B FindBISON
Find bison executable n' serves up macros ta generate custom build rules

Da module defines tha followin variables:


.nf
  BISON_EXECUTABLE \- path ta tha bison program
  BISON_VERSION \- version of bison
  BISON_FOUND \- legit if tha program was found
.fi




Da minimum required version of bison can be specified rockin tha standard CMake syntax, e.g. find_package(BISON 2.1.3)


If bison is found, tha module defines tha macros:


.nf
  BISON_TARGET(<Name> <YaccInput> <CodeOutput> [VERBOSE <file>]
              [COMPILE_FLAGS <string>])
.fi

which will create  a cold-ass lil custom rule ta generate  a parser n' shit. <YaccInput> is tha path ta  a yacc file. <CodeOutput> is tha name  of tha source file generated by bison. I aint talkin' bout chicken n' gravy biatch.  A header file be also  be generated, n' gotz nuff tha  token  list.  If  COMPILE_FLAGS  option is  specified,  tha  next parameta is  added up in tha bison  command line.  if  VERBOSE option is specified, <file> is pimped  n' gotz nuff verbose descriptionz of tha grammar n' parser n' shit. Da macro defines a set of variables:


.nf
  BISON_${Name}_DEFINED \- legit is tha macro ran successfully
  BISON_${Name}_INPUT \- Da input source file, a alias fo' <YaccInput>
  BISON_${Name}_OUTPUT_SOURCE \- Da source file generated by bison
  BISON_${Name}_OUTPUT_HEADER \- Da header file generated by bison
  BISON_${Name}_OUTPUTS \- Da sources filez generated by bison
  BISON_${Name}_COMPILE_FLAGS \- Options used up in tha bison command line
.fi




.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(BISON)
   BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
   add_executable(Foo main.cpp ${BISON_MyParser_OUTPUTS})
  ====================================================================
.fi

.TP
.B FindBLAS
Find BLAS library

This module findz a installed fortran library dat implements tha BLAS linear\-algebra intercourse (see http://www.netlib.org/blas/). Da list of libraries searched fo' is taken from tha autoconf macro file, acx_blas.m4 (distributed at http://ac\-archive.sourceforge.net/ac\-archive/acx_blas.html).


This module sets tha followin variables:


.nf
  BLAS_FOUND \- set ta legit if a library implementin tha BLAS intercourse
    is found
  BLAS_LINKER_FLAGS \- uncached list of required linker flags (excludin \-l
    n' \-L).
  BLAS_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use BLAS
  BLAS95_LIBRARIES \- uncached list of libraries (usin full path name)
    ta link against ta use BLAS95 intercourse
  BLAS95_FOUND \- set ta legit if a library implementin tha BLAS f95 intercourse
    is found
  BLA_STATIC  if set on dis determines what tha fuck kind of linkage our phat asses do (static)
  BLA_VENDOR  if set checks only tha specified vendor, if not set checks
     all tha possibilities
  BLA_F95     if set on tries ta find tha f95 intercourses fo' BLAS/LAPACK
.fi

C/CXX should be enabled ta use Intel mkl

.TP
.B FindBZip2
Try ta find BZip2

Once done dis will define


.nf
  BZIP2_FOUND \- system has BZip2
  BZIP2_INCLUDE_DIR \- tha BZip2 include directory
  BZIP2_LIBRARIES \- Link these ta use BZip2
  BZIP2_NEED_PREFIX \- dis is set if tha functions is prefixed wit BZ2_
  BZIP2_VERSION_STRING \- tha version of BZip2 found (since CMake 2.8.8)
.fi

.TP
.B FindBoost
Find Boost include dirs n' libraries

Use dis module by invokin find_package wit tha form:


.nf
  find_package(Boost
    [version] [EXACT]      # Minimum or EXACT version e.g. 1.36.0
    [REQUIRED]             # Fail wit error if Boost aint found
    [COMPONENTS <libs>...] # Boost libraries by they canonical name
    )                      # e.g. "date_time" fo' "libboost_date_time"
.fi

This module findz headaz n' axed component libraries OR a CMake package configuration file provided by a "Boost CMake" build. Y'all KNOW dat shit, muthafucka!  For tha latta case skip ta tha "Boost CMake" section below.  For tha forma case thangs up in dis biatch is reported up in variables:


.nf
  Boost_FOUND            \- True if headaz n' axed libraries was found
  Boost_INCLUDE_DIRS     \- Boost include directories
  Boost_LIBRARY_DIRS     \- Link directories fo' Boost libraries
  Boost_LIBRARIES        \- Boost component libraries ta be linked
  Boost_<C>_FOUND        \- True if component <C> was found (<C> is upper\-case)
  Boost_<C>_LIBRARY      \- Libraries ta link fo' component <C> (may include
                           target_link_libraries debug/optimized keywords)
  Boost_VERSION          \- BOOST_VERSION value from boost/version.hpp
  Boost_LIB_VERSION      \- Version strang appended ta library filenames
  Boost_MAJOR_VERSION    \- Boost major version number (X up in X.y.z)
  Boost_MINOR_VERSION    \- Boost minor version number (Y up in x.Y.z)
  Boost_SUBMINOR_VERSION \- Boost subminor version number (Z up in x.y.Z)
  Boost_LIB_DIAGNOSTIC_DEFINITIONS (Windows)
                         \- Pass ta add_definitions() ta have diagnostic
                           shiznit bout Boostz automatic linking
                           displayed durin compilation
.fi




This module readz hints bout search locations from variables:


.nf
  BOOST_ROOT             \- Preferred installation prefix
   (or BOOSTROOT)
  BOOST_INCLUDEDIR       \- Preferred include directory e.g. <prefix>/include
  BOOST_LIBRARYDIR       \- Preferred library directory e.g. <prefix>/lib
  Boost_NO_SYSTEM_PATHS  \- Set ta ON ta disable searchin up in locations not
                           specified by these hint variables. Default is OFF.
  Boost_ADDITIONAL_VERSIONS
                         \- List of Boost versions not known ta dis module
                           (Boost install locations may contain tha version)
.fi

and saves search thangs up in dis biatch persistently up in CMake cache entries:


.nf
  Boost_INCLUDE_DIR         \- Directory containin Boost headers
  Boost_LIBRARY_DIR         \- Directory containin Boost libraries
  Boost_<C>_LIBRARY_DEBUG   \- Component <C> library debug variant
  Boost_<C>_LIBRARY_RELEASE \- Component <C> library release variant
.fi

Users may set these hints or thangs up in dis biatch as cache entries. Put ya muthafuckin choppers up if ya feel dis!  Projects should not read these entries directly but instead use tha above result variables. Note dat some hint names start up in upper\-case "BOOST".  One may specify these as environment variablez if they is not specified as CMake variablez or cache entries.


This module first searches fo' tha Boost header filez rockin tha above hint variablez (excludin BOOST_LIBRARYDIR) n' saves tha result up in Boost_INCLUDE_DIR.  Then it searches fo' axed component libraries rockin tha above hints (excludin BOOST_INCLUDEDIR n' Boost_ADDITIONAL_VERSIONS), "lib" directories near Boost_INCLUDE_DIR, n' tha library name configuration settings below.  It saves tha library directory up in Boost_LIBRARY_DIR n' individual library locations up in Boost_<C>_LIBRARY_DEBUG n' Boost_<C>_LIBRARY_RELEASE.  When one chizzlez settings used by previous searches up in tha same build tree (excludin environment variables) dis module discardz previous search thangs up in dis biatch affected by tha chizzlez n' searches again.


Boost libraries come up in nuff variants encoded up in they file name.  Users or projects may tell dis module which variant ta find by settin variables:


.nf
  Boost_USE_MULTITHREADED  \- Set ta OFF ta use tha non\-multithreaded
                             libraries ('mt' tag).  Default is ON.
  Boost_USE_STATIC_LIBS    \- Set ta ON ta force tha use of tha static
                             libraries. Put ya muthafuckin choppers up if ya feel dis!  Default is OFF.
  Boost_USE_STATIC_RUNTIME \- Set ta ON or OFF ta specify whether ta use
                             libraries linked statically ta tha C++ runtime
                             ('s' tag).  Default is platform dependent.
  Boost_USE_DEBUG_PYTHON   \- Set ta ON ta use libraries compiled wit a
                             debug Python build ('y' tag). Default is OFF.
  Boost_USE_STLPORT        \- Set ta ON ta use libraries compiled with
                             STLPort ('p' tag).  Default is OFF.
  Boost_USE_STLPORT_DEPRECATED_NATIVE_IOSTREAMS
                           \- Set ta ON ta use libraries compiled with
                             STLPort deprecated "natizzle iostreams"
                             ('n' tag).  Default is OFF.
  Boost_COMPILER           \- Set ta tha compiler\-specific library suffix
                             (e.g. "\-gcc43").  Default be auto\-computed
                             fo' tha C++ compila up in use.
  Boost_THREADAPI          \- Suffix fo' "thread" component library name,
                             like fuckin "pthread" or "win32".  Names with
                             n' without dis suffix will both be tried.
.fi

Other variablez one may set ta control dis module are:


.nf
  Boost_DEBUG              \- Set ta ON ta enable debug output from FindBoost.
                             Please enable dis before filin any bug report.
  Boost_DETAILED_FAILURE_MSG
                           \- Set ta ON ta add detailed shiznit ta the
                             failure message even when tha REQUIRED option
                             aint given ta tha find_package call.
  Boost_REALPATH           \- Set ta ON ta resolve symlinks fo' discovered
                             libraries ta assist wit packaging.  For example,
                             tha "system" component library may be resolved to
                             "/usr/lib/libboost_system.so.1.42.0" instead of
                             "/usr/lib/libboost_system.so".  This do not
                             affect linkin n' should not be enabled unless
                             tha user needz dis shiznit.
.fi

On Visual Studio n' Borland compilaz Boost headaz request automatic linkin ta correspondin libraries. Put ya muthafuckin choppers up if ya feel dis!  This requires matchin libraries ta be linked explicitly or available up in tha link library search path.  In dis case settin Boost_USE_STATIC_LIBS ta OFF may not big up dynamic linking. Boost automatic linkin typically requests static libraries wit all dem exceptions (like fuckin Boost.Python).  Use


.nf
  add_definitions(${Boost_LIB_DIAGNOSTIC_DEFINITIONS})
.fi

to ask Boost ta report shiznit bout automatic linkin requests.


Example ta find Boost headaz only:


.nf
  find_package(Boost 1.36.0)
  if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    add_executable(foo foo.cc)
  endif()
.fi

Example ta find Boost headaz n' some libraries:


.nf
  set(Boost_USE_STATIC_LIBS        ON)
  set(Boost_USE_MULTITHREADED      ON)
  set(Boost_USE_STATIC_RUNTIME    OFF)
  find_package(Boost 1.36.0 COMPONENTS date_time filesystem system ...)
  if(Boost_FOUND)
    include_directories(${Boost_INCLUDE_DIRS})
    add_executable(foo foo.cc)
    target_link_libraries(foo ${Boost_LIBRARIES})
  endif()
.fi




Boost CMake \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-


If Boost was built rockin tha boost\-cmake project it serves up a package configuration file fo' use wit find_packagez Config mode.  This module looks fo' tha package configuration file called BoostConfig.cmake or boost\-config.cmake n' stores tha result up in cache entry "Boost_DIR".  If found, tha package configuration file is loaded n' dis module returns wit no further action. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha Boost CMake package configuration fo' details on what tha fuck it provides.


Set Boost_NO_BOOST_CMAKE ta ON ta disable tha search fo' boost\-cmake.

.TP
.B FindBullet
Try ta find tha Cap physics engine




.nf
  This module defines tha followin variables
.fi




.nf
  BULLET_FOUND \- Was cap found
  BULLET_INCLUDE_DIRS \- tha Cap include directories
  BULLET_LIBRARIES \- Link ta this, by default it includes
                     all cap components (Dynamics,
                     Collision, LinearMath, & SoftBody)
.fi




.nf
  This module accepts tha followin variables
.fi




.nf
  BULLET_ROOT \- Can be set ta cap install path or Windows build path
.fi




.TP
.B FindCABLE
Find CABLE

This module findz if CABLE is installed n' determines where tha include filez n' libraries are.  This code sets tha followin variables:


.nf
  CABLE             tha path ta tha cable executable
  CABLE_TCL_LIBRARY tha path ta tha Tcl wrapper library
  CABLE_INCLUDE_DIR tha path ta tha include directory
.fi




To build Tcl wrappers, you should add shared library n' link it ta ${CABLE_TCL_LIBRARY}.  Yo ass should also add ${CABLE_INCLUDE_DIR} as a include directory.

.TP
.B FindCUDA
Tools fo' buildin CUDA C files: libraries n' build dependencies.

This script locates tha NVIDIA CUDA C tools. Well shiiiit, it should work on linux, windows, n' mac n' should be reasonably up ta date wit CUDA C releases.


This script make use of tha standard find_package argumentz of <VERSION>, REQUIRED n' QUIET.  CUDA_FOUND will report if a aaight version of CUDA was found.


Da script will prompt tha user ta specify CUDA_TOOLKIT_ROOT_DIR if tha prefix cannot be determined by tha location of nvcc up in tha system path n' REQUIRED is specified ta find_package(). To bust a gangbangin' finger-lickin' different installed version of tha toolkit set tha environment variable CUDA_BIN_PATH before hustlin cmake (e.g. CUDA_BIN_PATH=/usr/local/cuda1.0 instead of tha default /usr/local/cuda) or set CUDA_TOOLKIT_ROOT_DIR afta configuring.  If you chizzle tha value of CUDA_TOOLKIT_ROOT_DIR, various components dat depend on tha path is ghon be relocated.


It might be necessary ta set CUDA_TOOLKIT_ROOT_DIR manually on certain platforms, or ta bust a cold-ass lil cuda runtime not installed up in tha default location. I aint talkin' bout chicken n' gravy biatch. In newer versionz of tha toolkit tha cuda library is included wit tha graphics driver\- be shizzle dat tha driver version matches what tha fuck is needed by tha cuda runtime version.


Da followin variablez affect tha behavior of tha macros up in tha script (in alphebetical order).  Note dat any of these flags can be chizzled multiple times up in tha same directory before callin CUDA_ADD_EXECUTABLE, CUDA_ADD_LIBRARY, CUDA_COMPILE, CUDA_COMPILE_PTX or CUDA_WRAP_SRCS.


.nf
  CUDA_64_BIT_DEVICE_CODE (Default matches host bit size)
  \-\- Set ta ON ta compile fo' 64 bit thang code, OFF fo' 32 bit thang code.
     Note dat makin dis different from tha host code when generatin object
     or C filez from CUDA code just won't work, cuz size_t gets defined by
     nvcc up in tha generated source.  If you compile ta PTX n' then load the
     file yo ass, you can mix bit sizes between thang n' host.
.fi




.nf
  CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE (Default ON)
  \-\- Set ta ON if you want tha custom build rule ta be attached ta tha source
     file up in Visual Studio.  Turn OFF if you add tha same cuda file ta multiple
     targets.
.fi




.nf
     This allows tha user ta build tha target from tha CUDA file; however, bad
     thangs can happen if tha CUDA source file be added ta multiple targets.
     When struttin parallel buildz it is possible fo' tha custom build
     command ta be run mo' than once n' up in parallel causin cryptic build
     errors.  VS runs tha rulez fo' every last muthafuckin source file up in tha target, n' a
     source can have only one rule no matta how tha fuck nuff projects it be added to.
     When tha rule is run from multiple targets race conditions can occur on
     tha generated file.  Eventually every last muthafuckin thang will git built yo, but if tha user
     is unaware of dis behavior, there may be mad drama.  It would be sick if
     dis script could detect tha reuse of source filez across multiple targets
     n' turn tha option off fo' tha user yo, but no phat solution could be found.
.fi




.nf
  CUDA_BUILD_CUBIN (Default OFF)
  \-\- Set ta ON ta enable n' extra compilation pass wit tha \-cubin option in
     Device mode. Da output is parsed n' register, shared memory usage is
     printed durin build.
.fi




.nf
  CUDA_BUILD_EMULATION (Default OFF fo' thang mode)
  \-\- Set ta ON fo' Emulation mode. \-D_DEVICEEMU is defined fo' CUDA C files
     when CUDA_BUILD_EMULATION is TRUE.
.fi




.nf
  CUDA_GENERATED_OUTPUT_DIR (Default CMAKE_CURRENT_BINARY_DIR)
  \-\- Set ta tha path you wish ta have tha generated filez placed. Y'all KNOW dat shit, muthafucka!  If it is
     blank output filez is ghon be placed up in CMAKE_CURRENT_BINARY_DIR.
     Intermediate filez will always be placed in
     CMAKE_CURRENT_BINARY_DIR/CMakeFiles.
.fi




.nf
  CUDA_HOST_COMPILATION_CPP (Default ON)
  \-\- Set ta OFF fo' C compilation of host code.
.fi




.nf
  CUDA_HOST_COMPILER (Default CMAKE_C_COMPILER, $(VCInstallDir)/bin fo' VS)
  \-\- Set tha host compila ta be used by nvcc.  Ignored if \-ccbin or
     \-\-compiler\-bindir be already present up in tha CUDA_NVCC_FLAGS or
     CUDA_NVCC_FLAGS_<CONFIG> variables.  For Visual Studio targets
     $(VCInstallDir)/bin be a special value dat expandz up ta tha path when
     tha command is run from withang VS.
.fi




.nf
  CUDA_NVCC_FLAGS
  CUDA_NVCC_FLAGS_<CONFIG>
  \-\- Additionizzle NVCC command line arguments, n' you can put dat on yo' toast.  NOTE: multiple arguments must be
     semi\-colon delimited (e.g. \-\-compiler\-options;\-Wall)
.fi




.nf
  CUDA_PROPAGATE_HOST_FLAGS (Default ON)
  \-\- Set ta ON ta propagate CMAKE_{C,CXX}_FLAGS n' they configuration
     dependent counterparts (e.g. CMAKE_C_FLAGS_DEBUG) automatically ta the
     host compila all up in nvccs \-Xcompila flag.  This helps make the
     generated host code match tha rest of tha system mo' betta n' shit.  Sometimes
     certain flags give nvcc problems, n' dis will help you turn tha flag
     propagation off.  This do not affect tha flags supplied directly ta nvcc
     via CUDA_NVCC_FLAGS or all up in tha OPTION flags specified through
     CUDA_ADD_LIBRARY, CUDA_ADD_EXECUTABLE, or CUDA_WRAP_SRCS.  Flags used for
     shared library compilation is not affected by dis flag.
.fi




.nf
  CUDA_SEPARABLE_COMPILATION (Default OFF)
  \-\- If set dis will enable separable compilation fo' all CUDA runtime object
     files.  If used outside of CUDA_ADD_EXECUTABLE n' CUDA_ADD_LIBRARY
     (e.g. callin CUDA_WRAP_SRCS directly),
     CUDA_COMPUTE_SEPARABLE_COMPILATION_OBJECT_FILE_NAME and
     CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS should be called.
.fi




.nf
  CUDA_VERBOSE_BUILD (Default OFF)
  \-\- Set ta ON ta peep all tha commandz used when buildin tha CUDA file.  When
     rockin a Makefile generator tha value defaults ta VERBOSE (run make
     VERBOSE=1 ta peep output), although settin CUDA_VERBOSE_BUILD ta ON will
     always print tha output.
.fi




Da script creates tha followin macros (in alphebetical order):


.nf
  CUDA_ADD_CUFFT_TO_TARGET( cuda_target )
  \-\- Addz tha cufft library ta tha target (can be any target).  Handlez whether
     yo ass is up in emulation mode or not.
.fi




.nf
  CUDA_ADD_CUBLAS_TO_TARGET( cuda_target )
  \-\- Addz tha cublas library ta tha target (can be any target).  Handles
     whether yo ass is up in emulation mode or not.
.fi




.nf
  CUDA_ADD_EXECUTABLE( cuda_target file0 file1 ...
                       [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
  \-\- Creates a executable "cuda_target" which is made up of tha files
     specified. Y'all KNOW dat shit, muthafucka!  All of tha non CUDA C filez is compiled rockin tha standard
     build rulez specified by CMAKE n' tha cuda filez is compiled ta object
     filez rockin nvcc n' tha host compila n' shit.  In addizzle CUDA_INCLUDE_DIRS is
     added automatically ta include_directories().  Some standard CMake target
     calls can be used on tha target afta callin dis macro
     (e.g. set_target_propertizzles n' target_link_libraries) yo, but setting
     propertizzles dat adjust compilation flags aint gonna affect code compiled by
     nvcc.  Such flags should be modified before callin CUDA_ADD_EXECUTABLE,
     CUDA_ADD_LIBRARY or CUDA_WRAP_SRCS.
.fi




.nf
  CUDA_ADD_LIBRARY( cuda_target file0 file1 ...
                    [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [OPTIONS ...] )
  \-\- Same as CUDA_ADD_EXECUTABLE except dat a library is pimped.
.fi




.nf
  CUDA_BUILD_CLEAN_TARGET()
  \-\- Creates a cold-ass lil convience target dat deletes all tha dependency files
     generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass should make clean afta hustlin dis target ta ensure the
     dependency filez git regenerated.
.fi




.nf
  CUDA_COMPILE( generated_filez file0 file1 ... [STATIC | SHARED | MODULE]
                [OPTIONS ...] )
  \-\- Returns a list of generated filez from tha input source filez ta be used
     wit ADD_LIBRARY or ADD_EXECUTABLE.
.fi




.nf
  CUDA_COMPILE_PTX( generated_filez file0 file1 ... [OPTIONS ...] )
  \-\- Returns a list of PTX filez generated from tha input source files.
.fi




.nf
  CUDA_COMPUTE_SEPARABLE_COMPILATION_OBJECT_FILE_NAME( output_file_var
                                                       cuda_target
                                                       object_filez )
  \-\- Compute tha name of tha intermediate link file used fo' separable
     compilation. I aint talkin' bout chicken n' gravy biatch.  This file name is typically passed into
     CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS.  output_file_var is produced
     based on cuda_target tha list of objects filez dat need separable
     compilation as specified by object_files.  If tha object_filez list is
     empty, then output_file_var is ghon be empty.  This function is called
     automatically fo' CUDA_ADD_LIBRARY n' CUDA_ADD_EXECUTABLE.  Note that
     dis be a gangbangin' function n' not a macro.
.fi




.nf
  CUDA_INCLUDE_DIRECTORIES( path0 path1 ... )
  \-\- Sets tha directories dat should be passed ta nvcc
     (e.g. nvcc \-Ipath0 \-Ipath1 ... ). These paths probably contain other .cu
     files.
.fi







.nf
  CUDA_LINK_SEPARABLE_COMPILATION_OBJECTS( output_file_var cuda_target
                                           nvcc_flags object_files)
.fi




.nf
  \-\- Generates tha link object required by separable compilation from tha given
     object files.  This is called automatically fo' CUDA_ADD_EXECUTABLE and
     CUDA_ADD_LIBRARY yo, but can be called manually when rockin CUDA_WRAP_SRCS
     directly.  When called from CUDA_ADD_LIBRARY or CUDA_ADD_EXECUTABLE the
     nvcc_flags passed up in is tha same as tha flags passed up in via tha OPTIONS
     argument.  Da only nvcc flag added automatically is tha bitnizz flag as
     specified by CUDA_64_BIT_DEVICE_CODE.  Note dat dis be a gangbangin' function
     instead of a macro.
.fi




.nf
  CUDA_WRAP_SRCS ( cuda_target format generated_filez file0 file1 ...
                   [STATIC | SHARED | MODULE] [OPTIONS ...] )
  \-\- This is where all tha magic happens.  CUDA_ADD_EXECUTABLE,
     CUDA_ADD_LIBRARY, CUDA_COMPILE, n' CUDA_COMPILE_PTX all call this
     function under tha hood.
.fi




.nf
     Given tha list of filez (file0 file1 ... fileN) dis macro generates
     custom commandz dat generate either PTX or linkable objects (use "PTX" or
     "OBJ" fo' tha format argument ta switch).  Filez dat don't end wit .cu
     or have tha HEADER_FILE_ONLY property is ignored.
.fi




.nf
     Da arguments passed up in afta OPTIONS is extra command line options to
     give ta nvcc.  Yo ass can also specify per configuration options by
     specifyin tha name of tha configuration followed by tha options.  General
     options must preceed configuration specific options.  Not all
     configurations need ta be specified, only tha ones provided is ghon be used.
.fi




.nf
        OPTIONS \-DFLAG=2 "\-DFLAG_OTHER=space up in flag"
        DEBUG \-g
        RELEASE \-\-use_fast_math
        RELWITHDEBINFO \-\-use_fast_math;\-g
        MINSIZEREL \-\-use_fast_math
.fi




.nf
     For certain configurations (namely VS generatin object filez with
     CUDA_ATTACH_VS_BUILD_RULE_TO_CUDA_FILE set ta ON), no generated file will
     be produced fo' tha given cuda file.  This is cuz when you add the
     cuda file ta Visual Studio it knows dat dis file produces a object file
     n' will link up in tha resultin object file automatically.
.fi




.nf
     This script will also generate a separate cmake script dat is used at
     build time ta invoke nvcc.  This is fo' nuff muthafuckin reasons.
.fi




.nf
       1. nvcc can return wack numbers as return joints which confuses
       Visual Studio tha fuck into thankin dat tha command succeeded. Y'all KNOW dat shit, muthafucka!  Da script now
       checks tha error codes n' produces errors when there was a problem.
.fi




.nf
       2. nvcc has been known ta not delete incomplete thangs up in dis biatch when it
       encountas problems.  This confuses build systems tha fuck into thankin the
       target was generated when up in fact a unusable file exists, n' you can put dat on yo' toast.  Da script
       now deletes tha output filez if there was a error.
.fi




.nf
       3. By puttin all tha options dat affect tha build tha fuck into a gangbangin' file n' then
       make tha build rule dependent on tha file, tha output filez will be
       regenerated when tha options chizzle.
.fi




.nf
     This script also looks at optionizzle arguments STATIC, SHARED, or MODULE to
     determine when ta target tha object compilation fo' a gangbangin' finger-lickin' dirty-ass shared library.
     BUILD_SHARED_LIBS is ignored up in CUDA_WRAP_SRCS yo, but it is bigged up in
     CUDA_ADD_LIBRARY.  On some systems special flags is added fo' building
     objects intended fo' shared libraries. Put ya muthafuckin choppers up if ya feel dis!  A preprocessor macro,
     <target_name>_EXPORTS is defined when a gangbangin' finger-lickin' dirty-ass shared library compilation is
     detected.
.fi




.nf
     Flags passed tha fuck into add_definitions wit \-D or /D is passed along ta nvcc.
.fi




Da script defines tha followin variables:


.nf
  CUDA_VERSION_MAJOR    \-\- Da major version of cuda as reported by nvcc.
  CUDA_VERSION_MINOR    \-\- Da minor version.
  CUDA_VERSION
  CUDA_VERSION_STRING   \-\- CUDA_VERSION_MAJOR.CUDA_VERSION_MINOR
.fi




.nf
  CUDA_TOOLKIT_ROOT_DIR \-\- Path ta tha CUDA Toolkit (defined if not set).
  CUDA_SDK_ROOT_DIR     \-\- Path ta tha CUDA SDK.  Use dis ta find filez up in the
                           SDK.  This script aint gonna directly support finding
                           specific libraries or headers, as dat aint
                           supported by NVIDIA.  If you wanna chizzle
                           libraries when tha path chizzlez peep the
                           FindCUDA.cmake script fo' a example of how tha fuck ta clear
                           these variables.  There is also examplez of how tha fuck to
                           use tha CUDA_SDK_ROOT_DIR ta locate headaz or
                           libraries, if you so chizzle (at yo' own risk).
  CUDA_INCLUDE_DIRS     \-\- Include directory fo' cuda headers.  Added automatically
                           fo' CUDA_ADD_EXECUTABLE n' CUDA_ADD_LIBRARY.
  CUDA_LIBRARIES        \-\- Cuda RT library.
  CUDA_CUFFT_LIBRARIES  \-\- Device or emulation library fo' tha Cuda FFT
                           implementation (alternatizzle to:
                           CUDA_ADD_CUFFT_TO_TARGET macro)
  CUDA_CUBLAS_LIBRARIES \-\- Device or emulation library fo' tha Cuda BLAS
                           implementation (alteratizzle to:
                           CUDA_ADD_CUBLAS_TO_TARGET macro).
  CUDA_cupti_LIBRARY    \-\- CUDA Profilin Tools Interface library.
                           Only available fo' CUDA version 4.0+.
  CUDA_curand_LIBRARY   \-\- CUDA Random Number Generation library.
                           Only available fo' CUDA version 3.2+.
  CUDA_cusparse_LIBRARY \-\- CUDA Sparse Matrix library.
                           Only available fo' CUDA version 3.2+.
  CUDA_npp_LIBRARY      \-\- NVIDIA Performizzle Primitives library.
                           Only available fo' CUDA version 4.0+.
  CUDA_nppc_LIBRARY      \-\- NVIDIA Performizzle Primitives library (core).
                           Only available fo' CUDA version 5.5+.
  CUDA_nppi_LIBRARY      \-\- NVIDIA Performizzle Primitives library (image processing).
                           Only available fo' CUDA version 5.5+.
  CUDA_npps_LIBRARY      \-\- NVIDIA Performizzle Primitives library (signal processing).
                           Only available fo' CUDA version 5.5+.
  CUDA_nvcuvenc_LIBRARY \-\- CUDA Video Encoder library.
                           Only available fo' CUDA version 3.2+.
                           Windows only.
  CUDA_nvcuvid_LIBRARY  \-\- CUDA Video Decoder library.
                           Only available fo' CUDA version 3.2+.
                           Windows only.
.fi







.nf
  Jizzy Bigler, NVIDIA Corp (nvidia.com \- jbigler)
  Abe Stephens, SCI Institute \-\- http://www.sci.utah.edu/~abe/FindCuda.html
.fi




.nf
  Copyright (c) 2008 \- 2009 NVIDIA Corporation. I aint talkin' bout chicken n' gravy biatch.  All muthafuckin rights reserved.
.fi




.nf
  Copyright (c) 2007\-2009
  Scientific Computin n' Imagin Institute, Universitizzle of Utah
.fi




.nf
  This code is licensed under tha MIT License.  See tha FindCUDA.cmake script
  fo' tha text of tha license.
.fi

.TP
.B FindCURL
Find curl

Find tha natizzle CURL headaz n' libraries.


.nf
  CURL_INCLUDE_DIRS   \- where ta find curl/curl.h, etc.
  CURL_LIBRARIES      \- List of libraries when rockin curl.
  CURL_FOUND          \- True if curl found.
  CURL_VERSION_STRING \- tha version of curl found (since CMake 2.8.8)
.fi

.TP
.B FindCVS
.nf
 
.fi

Da module defines tha followin variables:


.nf
   CVS_EXECUTABLE \- path ta cvs command line client
   CVS_FOUND \- legit if tha command line client was found
.fi

Example usage:


.nf
   find_package(CVS)
   if(CVS_FOUND)
     message("CVS found: ${CVS_EXECUTABLE}")
   endif()
.fi

.TP
.B FindCoin3D
Find Coin3D (Open Inventor)

Coin3D be a implementation of tha Open Inventor API. Well shiiiit, it serves up data structures n' algorithms fo' 3D visualization http://www.coin3d.org/


This module defines tha followin variables


.nf
  COIN3D_FOUND         \- system has Coin3D \- Open Inventor
  COIN3D_INCLUDE_DIRS  \- where tha Inventor include directory can be found
  COIN3D_LIBRARIES     \- Link ta dis ta use Coin3D
.fi




.TP
.B FindCups
Try ta find tha Cups printin system

Once done dis will define


.nf
  CUPS_FOUND \- system has Cups
  CUPS_INCLUDE_DIR \- tha Cups include directory
  CUPS_LIBRARIES \- Libraries needed ta use Cups
  CUPS_VERSION_STRING \- version of Cups found (since CMake 2.8.8)
  Set CUPS_REQUIRE_IPP_DELETE_ATTRIBUTE ta TRUE if you need a version which
  features dis function (i.e. at least 1.1.19)
.fi

.TP
.B FindCurses
Find tha curses include file n' library




.nf
  CURSES_FOUND \- system has Curses
  CURSES_INCLUDE_DIR \- tha Curses include directory
  CURSES_LIBRARIES \- Da libraries needed ta use Curses
  CURSES_HAVE_CURSES_H \- legit if curses.h be available
  CURSES_HAVE_NCURSES_H \- legit if ncurses.h be available
  CURSES_HAVE_NCURSES_NCURSES_H \- legit if ncurses/ncurses.h be available
  CURSES_HAVE_NCURSES_CURSES_H \- legit if ncurses/curses.h be available
  CURSES_LIBRARY \- set fo' backwardz compatibilitizzle wit 2.4 CMake
.fi




Set CURSES_NEED_NCURSES ta TRUE before tha find_package() command if NCurses functionalitizzle is required.

.TP
.B FindCxxTest
Find CxxTest

Find tha CxxTest suite n' declare a helper macro fo' bustin unit tests n' integratin dem wit CTest. For mo' details on CxxTest peep http://cxxtest.tigris.org


INPUT Variables


.nf
   CXXTEST_USE_PYTHON [deprecated since 1.3]
       Only used up in tha case both Python & Perl
       is detected on tha system ta control
       which CxxTest code generator is used.
       Valid only fo' CxxTest version 3.
.fi




.nf
       NOTE: In olda versionz of dis Find Module,
       dis variable controlled if tha Python test
       generator was used instead of tha Perl one,
       regardless of which scriptin language the
       user had installed.
.fi




.nf
   CXXTEST_TESTGEN_ARGS (since CMake 2.8.3)
       Specify a list of options ta pass ta tha CxxTest code
       generator. Shiiit, dis aint no joke.  If not defined, \-\-error\-printa is
       passed.
.fi




OUTPUT Variables


.nf
   CXXTEST_FOUND
       True if tha CxxTest framework was found
   CXXTEST_INCLUDE_DIRS
       Where ta find tha CxxTest include directory
   CXXTEST_PERL_TESTGEN_EXECUTABLE
       Da perl\-based test generator
   CXXTEST_PYTHON_TESTGEN_EXECUTABLE
       Da python\-based test generator
   CXXTEST_TESTGEN_EXECUTABLE (since CMake 2.8.3)
       Da test generator dat is straight-up used (chosen rockin user preferences
       n' interpretas found up in tha system)
   CXXTEST_TESTGEN_INTERPRETER (since CMake 2.8.3)
       Da full path ta tha Perl or Python executable on tha system
.fi




MACROS fo' optionizzle use by CMake users:


.nf
    CXXTEST_ADD_TEST(<test_name> <gen_source_file> <input_files_to_testgen...>)
       Creates a CxxTest runner n' addz it ta tha CTest testin suite
       Parameters:
           test_name               Da name of tha test
           gen_source_file         Da generated source filename ta be
                                   generated by CxxTest
           input_files_to_testgen  Da list of header filez containin the
                                   CxxTest::TestSuitez ta be included in
                                   dis runner
.fi




.nf
       #==============
       Example Usage:
.fi




.nf
           find_package(CxxTest)
           if(CXXTEST_FOUND)
               include_directories(${CXXTEST_INCLUDE_DIR})
               enable_testing()
.fi




.nf
               CXXTEST_ADD_TEST(unittest_foo foo_test.cc
                                 ${CMAKE_CURRENT_SOURCE_DIR}/foo_test.h)
               target_link_libraries(unittest_foo foo) # as needed
           endif()
.fi




.nf
              This will (if CxxTest is found):
              1. Invoke tha testgen executable ta autogenerate foo_test.cc up in the
                 binary tree from "foo_test.h" up in tha current source directory.
              2. Right back up in yo muthafuckin ass. Smoke a executable n' test called unittest_foo.
.fi




.nf
      #=============
      Example foo_test.h:
.fi




.nf
          #include <cxxtest/TestSuite.h>
.fi




.nf
          class MyTestSuite : hood CxxTest::TestSuite
          {
          public:
             void testAddition( void )
             {
                TS_ASSERT( 1 + 1 > 1 );
                TS_ASSERT_EQUALS( 1 + 1, 2 );
             }
          };
.fi




.TP
.B FindCygwin
this module looks fo' Cygwin




.TP
.B FindDCMTK
find DCMTK libraries n' applications




.TP
.B FindDart
Find DART

This module looks fo' tha dart testin software n' sets DART_ROOT ta point ta where it found dat shit.


.TP
.B FindDevIL
.nf
 
.fi

This module locates tha pimperz image library. http://openil.sourceforge.net/


This module sets:


.nf
   IL_LIBRARIES \-   tha name of tha IL library. These include tha full path to
                    tha core DevIL library. This one has ta be linked tha fuck into the
                    application.
   ILU_LIBRARIES \-  tha name of tha ILU library fo' realz. Again, tha full path. This
                    library is fo' filtas n' effects, not actual loading. It
                    don't gotta be linked if tha functionalitizzle it provides
                    aint used.
   ILUT_LIBRARIES \- tha name of tha ILUT library. Full path. This part of the
                    library intercourses wit OpenGL. Well shiiiit, it aint strictly needed
                    up in applications.
   IL_INCLUDE_DIR \- where ta find tha il.h, ilu.h n' ilut.h files.
   IL_FOUND \-       dis is set ta TRUE if all tha above variablez was set.
                    This is ghon be set ta false if ILU or ILUT is not found,
                    even if they is not needed. Y'all KNOW dat shit, muthafucka! In most systems, if one
                    library is found all tha others is as well. Thatz the
                    way tha DevIL pimpers release dat shit.
.fi

.TP
.B FindDoxygen
This module looks fo' Doxygen n' tha path ta Graphvizz dot

Doxygen be a thugged-out documentation generation tool.  Please peep http://www.doxygen.org


This module accepts tha followin optionizzle variables:


.nf
   DOXYGEN_SKIP_DOT       = If legit dis module will skip tryin ta find Dot
                            (an optionizzle component often used by Doxygen)
.fi




This modulez defines tha followin variables:


.nf
   DOXYGEN_EXECUTABLE     = Da path ta tha doxygen command.
   DOXYGEN_FOUND          = Was Doxygen found or not?
   DOXYGEN_VERSION        = Da version reported by doxygen \-\-version
.fi




.nf
   DOXYGEN_DOT_EXECUTABLE = Da path ta tha dot program used by doxygen.
   DOXYGEN_DOT_FOUND      = Was Dot found or not?
   DOXYGEN_DOT_PATH       = Da path ta dot not includin tha executable
.fi







.TP
.B FindEXPAT
Find expat

Find tha natizzle EXPAT headaz n' libraries.


.nf
  EXPAT_INCLUDE_DIRS \- where ta find expat.h, etc.
  EXPAT_LIBRARIES    \- List of libraries when rockin expat.
  EXPAT_FOUND        \- True if expat found.
.fi

.TP
.B FindFLEX
Find flex executable n' serves up a macro ta generate custom build rules




Da module defines tha followin variables:


.nf
  FLEX_FOUND \- legit is flex executable is found
  FLEX_EXECUTABLE \- tha path ta tha flex executable
  FLEX_VERSION \- tha version of flex
  FLEX_LIBRARIES \- Da flex libraries
  FLEX_INCLUDE_DIRS \- Da path ta tha flex headers
.fi




Da minimum required version of flex can be specified rockin tha standard syntax, e.g. find_package(FLEX 2.5.13)





If flex is found on tha system, tha module serves up tha macro:


.nf
  FLEX_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>])
.fi

which creates a cold-ass lil custom command  ta generate tha <FlexOutput> file from tha <FlexInput> file.  If  COMPILE_FLAGS option is specified, tha next parameta be added ta tha flex  command line. Name be a alias used ta git  detailz of  dis custom  command. Y'all KNOW dat shit, muthafucka!  Indeed tha  macro defines  tha followin variables:


.nf
  FLEX_${Name}_DEFINED \- legit is tha macro ran successfully
  FLEX_${Name}_OUTPUTS \- tha source file generated by tha custom rule, an
  alias fo' FlexOutput
  FLEX_${Name}_INPUT \- tha flex source file, a alias fo' ${FlexInput}
.fi




Flex scanners oftenly use tokens  defined by Bison: tha code generated by Flex  dependz of tha header  generated by Bison. I aint talkin' bout chicken n' gravy biatch.   This module also defines a macro:


.nf
  ADD_FLEX_BISON_DEPENDENCY(FlexTarget BisonTarget)
.fi

which  addz tha  required dependency  between a  scanner n'  a parser where  <FlexTarget>  n' <BisonTarget>  is  tha  first parametas  of respectively FLEX_TARGET n' BISON_TARGET macros.


.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(BISON)
   find_package(FLEX)
.fi




.nf
   BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
   FLEX_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
   ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser)
.fi




.nf
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
   add_executable(Foo
      Foo.cc
      ${BISON_MyParser_OUTPUTS}
      ${FLEX_MyScanner_OUTPUTS}
   )
  ====================================================================
.fi

.TP
.B FindFLTK
Find tha natizzle FLTK includes n' library




By default FindFLTK.cmake will search fo' all of tha FLTK components n' add dem ta tha FLTK_LIBRARIES variable.


.nf
   Yo ass can limit tha components which git placed up in FLTK_LIBRARIES by
   definin one or mo' of tha followin three options:
.fi




.nf
     FLTK_SKIP_OPENGL, set ta legit ta disable searchin fo' opengl and
                       tha FLTK GL library
     FLTK_SKIP_FORMS, set ta legit ta disable searchin fo' fltk_forms
     FLTK_SKIP_IMAGES, set ta legit ta disable searchin fo' fltk_images
.fi




.nf
     FLTK_SKIP_FLUID, set ta legit if tha fluid binary need not be present
                      at build time
.fi




Da followin variablez is ghon be defined:


.nf
     FLTK_FOUND, True if all components not skipped was found
     FLTK_INCLUDE_DIR, where ta find include files
     FLTK_LIBRARIES, list of fltk libraries you should link against
     FLTK_FLUID_EXECUTABLE, where ta find tha Fluid tool
     FLTK_WRAP_UI, This enablez tha FLTK_WRAP_UI command
.fi




Da followin cache variablez is assigned but should not be used. Y'all KNOW dat shit, muthafucka! See tha FLTK_LIBRARIES variable instead.


.nf
     FLTK_BASE_LIBRARY   = tha full path ta fltk.lib
     FLTK_GL_LIBRARY     = tha full path ta fltk_gl.lib
     FLTK_FORMS_LIBRARY  = tha full path ta fltk_forms.lib
     FLTK_IMAGES_LIBRARY = tha full path ta fltk_images.lib
.fi

.TP
.B FindFLTK2
Find tha natizzle FLTK2 includes n' library

Da followin settings is defined


.nf
  FLTK2_FLUID_EXECUTABLE, where ta find tha Fluid tool
  FLTK2_WRAP_UI, This enablez tha FLTK2_WRAP_UI command
  FLTK2_INCLUDE_DIR, where ta find include files
  FLTK2_LIBRARIES, list of fltk2 libraries
  FLTK2_FOUND, Don't use FLTK2 if false.
.fi

Da followin settings should not be used up in general.


.nf
  FLTK2_BASE_LIBRARY   = tha full path ta fltk2.lib
  FLTK2_GL_LIBRARY     = tha full path ta fltk2_gl.lib
  FLTK2_IMAGES_LIBRARY = tha full path ta fltk2_images.lib
.fi

.TP
.B FindFreetype
Locate FreeType library

This module defines


.nf
  FREETYPE_LIBRARIES, tha library ta link against
  FREETYPE_FOUND, if false, do not try ta link ta FREETYPE
  FREETYPE_INCLUDE_DIRS, where ta find headers.
  FREETYPE_VERSION_STRING, tha version of freetype found (since CMake 2.8.8)
  This is tha concatenation of tha paths:
  FREETYPE_INCLUDE_DIR_ft2build
  FREETYPE_INCLUDE_DIR_freetype2
.fi




$FREETYPE_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$FREETYPE_DIR used up in buildin FREETYPE.

.TP
.B FindGCCXML
Find tha GCC\-XML front\-end executable.




This module will define tha followin variables:


.nf
  GCCXML \- tha GCC\-XML front\-end executable.
.fi

.TP
.B FindGDAL
.nf
 
.fi

Locate gdal


This module accepts tha followin environment variables:


.nf
    GDAL_DIR or GDAL_ROOT \- Specify tha location of GDAL
.fi




This module defines tha followin CMake variables:


.nf
    GDAL_FOUND \- True if libgdal is found
    GDAL_LIBRARY \- A variable pointin ta tha GDAL library
    GDAL_INCLUDE_DIR \- Where ta find tha headers
.fi

.TP
.B FindGIF
.nf
 
.fi

This module searches giflib n' defines GIF_LIBRARIES \- libraries ta link ta up in order ta use GIF GIF_FOUND, if false, do not try ta link GIF_INCLUDE_DIR, where ta find tha headaz GIF_VERSION, reports either version 4 or 3 (for every last muthafuckin thang before version 4)


Da minimum required version of giflib can be specified rockin tha standard syntax, e.g. find_package(GIF 4)


$GIF_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$GIF_DIR

.TP
.B FindGLEW
Find tha OpenGL Extension Wrangla Library (GLEW)

This module defines tha followin variables:


.nf
  GLEW_INCLUDE_DIRS \- include directories fo' GLEW
  GLEW_LIBRARIES \- libraries ta link against GLEW
  GLEW_FOUND \- legit if GLEW has been found n' can be used
.fi

.TP
.B FindGLUT
try ta find glut library n' include files

.nf
  GLUT_INCLUDE_DIR, where ta find GL/glut.h, etc.
  GLUT_LIBRARIES, tha libraries ta link against
  GLUT_FOUND, If false, do not try ta use GLUT.
.fi

Also defined yo, but not fo' general use are:


.nf
  GLUT_glut_LIBRARY = tha full path ta tha glut library.
  GLUT_Xmu_LIBRARY  = tha full path ta tha Xmu library.
  GLUT_Xi_LIBRARY   = tha full path ta tha Xi Library.
.fi

.TP
.B FindGTK
try ta find GTK (and glib) n' GTKGLArea

.nf
  GTK_INCLUDE_DIR   \- Directories ta include ta use GTK
  GTK_LIBRARIES     \- Filez ta link against ta use GTK
  GTK_FOUND         \- GTK was found
  GTK_GL_FOUND      \- GTKz GL features was found
.fi

.TP
.B FindGTK2
FindGTK2.cmake

This module can find tha GTK2 widget libraries n' nuff muthafuckin of its other optionizzle components like gtkmm, glade, n' glademm.


NOTE: If you intend ta use version checking, CMake 2.6.2 or lata is


.nf
       required.
.fi




Specify one or mo' of tha followin components as you call dis find module. Right back up in yo muthafuckin ass. See example below.


.nf
   gtk
   gtkmm
   glade
   glademm
.fi




Da followin variablez is ghon be defined fo' yo' use


.nf
   GTK2_FOUND \- Were all of yo' specified components found?
   GTK2_INCLUDE_DIRS \- All include directories
   GTK2_LIBRARIES \- All libraries
   GTK2_DEFINITIONS \- Additionizzle compila flags
.fi




.nf
   GTK2_VERSION \- Da version of GTK2 found (x.y.z)
   GTK2_MAJOR_VERSION \- Da major version of GTK2
   GTK2_MINOR_VERSION \- Da minor version of GTK2
   GTK2_PATCH_VERSION \- Da patch version of GTK2
.fi




Optionizzle variablez you can define prior ta callin dis module:


.nf
   GTK2_DEBUG \- Enablez verbose debuggin of tha module
   GTK2_ADDITIONAL_SUFFIXES \- Allows definin additionizzle directories to
                              search fo' include files
.fi




================= Example Usage:


.nf
   Call find_package() once, here is some examplez ta pick from:
.fi




.nf
   Require GTK 2.6 or later
       find_package(GTK2 2.6 REQUIRED gtk)
.fi




.nf
   Require GTK 2.10 or lata n' Glade
       find_package(GTK2 2.10 REQUIRED gtk glade)
.fi




.nf
   Search fo' GTK/GTKMM 2.8 or later
       find_package(GTK2 2.8 COMPONENTS gtk gtkmm)
.fi




.nf
   if(GTK2_FOUND)
      include_directories(${GTK2_INCLUDE_DIRS})
      add_executable(mygui mygui.cc)
      target_link_libraries(mygui ${GTK2_LIBRARIES})
   endif()
.fi




.TP
.B FindGTest
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

Locate tha Gizoogle C++ Testin Framework.


Defines tha followin variables:


.nf
   GTEST_FOUND \- Found tha Gizoogle Testin framework
   GTEST_INCLUDE_DIRS \- Include directories
.fi




Also defines tha library variablez below as aiiight variables.  These contain debug/optimized keywordz when a thugged-out debuggin library is found.


.nf
   GTEST_BOTH_LIBRARIES \- Both libgtest & libgtest\-main
   GTEST_LIBRARIES \- libgtest
   GTEST_MAIN_LIBRARIES \- libgtest\-main
.fi




Accepts tha followin variablez as input:


.nf
   GTEST_ROOT \- (as a CMake or environment variable)
                Da root directory of tha gtest install prefix
.fi




.nf
   GTEST_MSVC_SEARCH \- If compilin wit MSVC, dis variable can be set to
                       "MD" or "MT" ta enable searchin a GTest build tree
                       (defaults: "MD")
.fi




Example Usage:


.nf
    enable_testing()
    find_package(GTest REQUIRED)
    include_directories(${GTEST_INCLUDE_DIRS})
.fi




.nf
    add_executable(foo foo.cc)
    target_link_libraries(foo ${GTEST_BOTH_LIBRARIES})
.fi




.nf
    add_test(AllTestsInFoo foo)
.fi







If you wanna each Gizoogle test ta show up in CTest as a test you may use tha followin macro. NOTE: It will slow down yo' tests by hustlin a executable fo' each test n' test fixture.  Yo ass will also gotta rerun CMake afta addin or removin tests or test fixtures.


GTEST_ADD_TESTS(executable extra_args ARGN)


.nf
    executable = Da path ta tha test executable
    extra_args = Pass a list of extra arguments ta be passed to
                 executable enclosed up in quotes (or "" fo' none)
    ARGN =       A list of source filez ta search fo' tests & test
                 fixtures.
.fi




.nf
  Example:
     set(FooTestArgs \-\-foo 1 \-\-bar 2)
     add_executable(FooTest FooUnitTest.cc)
     GTEST_ADD_TESTS(FooTest "${FooTestArgs}" FooUnitTest.cc)
.fi

.TP
.B FindGettext
Find GNU gettext tools

This module looks fo' tha GNU gettext tools. This module defines tha followin joints:


.nf
  GETTEXT_MSGMERGE_EXECUTABLE: tha full path ta tha msgmerge tool.
  GETTEXT_MSGFMT_EXECUTABLE: tha full path ta tha msgfmt tool.
  GETTEXT_FOUND: True if gettext has been found.
  GETTEXT_VERSION_STRING: tha version of gettext found (since CMake 2.8.8)
.fi




Additionally it serves up tha followin macros: GETTEXT_CREATE_TRANSLATIONS ( outputFile [ALL] file1 ... fileN )


.nf
    This will create a target "translations" which will convert the
    given input po filez tha fuck into tha binary output mo file. If the
    ALL option is used, tha translations will also be pimped when
    buildin tha default target.
.fi

GETTEXT_PROCESS_POT( <potfile> [ALL] [INSTALL_DESTINATION <destdir>] LANGUAGES <lang1> <lang2> ... )


.nf
     Process tha given pot file ta mo files.
     If INSTALL_DESTINATION is given then automatically install rulez is ghon be pimped,
     tha language subdirectory is ghon be taken tha fuck into account (by default use share/locale/).
     If ALL is specified, tha pot file is processed when buildin tha all traget.
     It creates a cold-ass lil custom target "potfile".
.fi

GETTEXT_PROCESS_PO_FILES( <lang> [ALL] [INSTALL_DESTINATION <dir>] PO_FILES <po1> <po2> ... )


.nf
     Process tha given po filez ta mo filez fo' tha given language.
     If INSTALL_DESTINATION is given then automatically install rulez is ghon be pimped,
     tha language subdirectory is ghon be taken tha fuck into account (by default use share/locale/).
     If ALL is specified, tha po filez is processed when buildin tha all traget.
     It creates a cold-ass lil custom target "pofiles".
.fi

.TP
.B FindGit
.nf
 
.fi

Da module defines tha followin variables:


.nf
   GIT_EXECUTABLE \- path ta git command line client
   GIT_FOUND \- legit if tha command line client was found
   GIT_VERSION_STRING \- tha version of git found (since CMake 2.8.8)
.fi

Example usage:


.nf
   find_package(Git)
   if(GIT_FOUND)
     message("git found: ${GIT_EXECUTABLE}")
   endif()
.fi

.TP
.B FindGnuTLS
Try ta find tha GNU Transhiznit Layer Securitizzle library (gnutls)




Once done dis will define


.nf
  GNUTLS_FOUND \- System has gnutls
  GNUTLS_INCLUDE_DIR \- Da gnutls include directory
  GNUTLS_LIBRARIES \- Da libraries needed ta use gnutls
  GNUTLS_DEFINITIONS \- Compila switches required fo' rockin gnutls
.fi

.TP
.B FindGnuplot
this module looks fo' gnuplot




Once done dis will define


.nf
  GNUPLOT_FOUND \- system has Gnuplot
  GNUPLOT_EXECUTABLE \- tha Gnuplot executable
  GNUPLOT_VERSION_STRING \- tha version of Gnuplot found (since CMake 2.8.8)
.fi




GNUPLOT_VERSION_STRING aint gonna work fo' oldschool versions like 3.7.1.

.TP
.B FindHDF5
Find HDF5, a library fo' readin n' freestylin self describin array data.




This module invokes tha HDF5 wrapper compila dat should be installed alongside HDF5.  Dependin upon tha HDF5 Configuration, tha wrapper compila is called either h5cc or h5pcc.  If dis succeeds, tha module will then call tha compila wit tha \-show argument ta peep what tha fuck flags is used when compilin a HDF5 client application.


Da module will optionally accept tha COMPONENTS argument.  If no COMPONENTS is specified, then tha find module will default ta findin only tha HDF5 C library.  If one or mo' COMPONENTS is specified, tha module will attempt ta find tha language bindings fo' tha specified components, n' you can put dat on yo' toast.  Da only valid components is C, CXX, Fortran, HL, n' Fortran_HL.  If tha COMPONENTS argument aint given, tha module will attempt ta find only tha C bindings.


On UNIX systems, dis module will read tha variable HDF5_USE_STATIC_LIBRARIES ta determine whether or not ta prefer a static link ta a thugged-out dynamic link fo' HDF5 n' all of itz dependencies. Put ya muthafuckin choppers up if ya feel dis!  To use dis feature, make shizzle dat tha HDF5_USE_STATIC_LIBRARIES variable is set before tha call ta find_package.


To provide tha module wit a hint bout where ta find yo' HDF5 installation, you can set tha environment variable HDF5_ROOT.  Da Find module will then look up in dis path when searchin fo' HDF5 executables, paths, n' libraries.


In addizzle ta findin tha includes n' libraries required ta compile a HDF5 client application, dis module also make a effort ta find tools dat come wit tha HDF5 distribution dat may be useful fo' regression testing.


This module will define tha followin variables:


.nf
  HDF5_INCLUDE_DIRS \- Location of tha hdf5 includes
  HDF5_INCLUDE_DIR \- Location of tha hdf5 includes (deprecated)
  HDF5_DEFINITIONS \- Required compila definitions fo' HDF5
  HDF5_C_LIBRARIES \- Required libraries fo' tha HDF5 C bindings.
  HDF5_CXX_LIBRARIES \- Required libraries fo' tha HDF5 C++ bindings
  HDF5_Fortran_LIBRARIES \- Required libraries fo' tha HDF5 Fortran bindings
  HDF5_HL_LIBRARIES \- Required libraries fo' tha HDF5 high level API
  HDF5_Fortran_HL_LIBRARIES \- Required libraries fo' tha high level Fortran
                              bindings.
  HDF5_LIBRARIES \- Required libraries fo' all axed bindings
  HDF5_FOUND \- legit if HDF5 was found on tha system
  HDF5_LIBRARY_DIRS \- tha full set of library directories
  HDF5_IS_PARALLEL \- Whether or not HDF5 was found wit parallel IO support
  HDF5_C_COMPILER_EXECUTABLE \- tha path ta tha HDF5 C wrapper compiler
  HDF5_CXX_COMPILER_EXECUTABLE \- tha path ta tha HDF5 C++ wrapper compiler
  HDF5_Fortran_COMPILER_EXECUTABLE \- tha path ta tha HDF5 Fortran wrapper compiler
  HDF5_DIFF_EXECUTABLE \- tha path ta tha HDF5 dataset comparison tool
.fi

.TP
.B FindHSPELL
Try ta find Hspell

Once done dis will define


.nf
  HSPELL_FOUND \- system has Hspell
  HSPELL_INCLUDE_DIR \- tha Hspell include directory
  HSPELL_LIBRARIES \- Da libraries needed ta use Hspell
  HSPELL_DEFINITIONS \- Compila switches required fo' rockin Hspell
.fi




.nf
  HSPELL_VERSION_STRING \- Da version of Hspell found (x.y)
  HSPELL_MAJOR_VERSION  \- tha major version of Hspell
  HSPELL_MINOR_VERSION  \- Da minor version of Hspell
.fi

.TP
.B FindHTMLHelp
This module looks fo' Microsizzlez HTML Help Compiler

It defines:


.nf
   HTML_HELP_COMPILER     : full path ta tha Compila (hhc.exe)
   HTML_HELP_INCLUDE_PATH : include path ta tha API (htmlhelp.h)
   HTML_HELP_LIBRARY      : full path ta tha library (htmlhelp.lib)
.fi




.TP
.B FindHg
.nf
 
.fi

Da module defines tha followin variables:


.nf
   HG_EXECUTABLE \- path ta mercurial command line client (hg)
   HG_FOUND \- legit if tha command line client was found
   HG_VERSION_STRING \- tha version of mercurial found
.fi

Example usage:


.nf
   find_package(Hg)
   if(HG_FOUND)
     message("hg found: ${HG_EXECUTABLE}")
   endif()
.fi

.TP
.B FindITK
Find a ITK installation or build tree.

.TP
.B FindIcotool
Find icotool

This module looks fo' icotool. This module defines tha followin joints:


.nf
  ICOTOOL_EXECUTABLE: tha full path ta tha icotool tool.
  ICOTOOL_FOUND: True if icotool has been found.
  ICOTOOL_VERSION_STRING: tha version of icotool found.
.fi




.TP
.B FindImageMagick
Find tha ImageMagick binary suite.

This module will search fo' a set of ImageMagick tools specified as components up in tha FIND_PACKAGE call. Typical components include yo, but is not limited ta (future versionz of ImageMagick might have additionizzle components not listed here):


.nf
  animate
  compare
  composite
  conjure
  convert
  display
  identify
  import
  mogrify
  montage
  stream
.fi




If no component is specified up in tha FIND_PACKAGE call, then it only searches fo' tha ImageMagick executable directory. This code defines tha followin variables:


.nf
  ImageMagick_FOUND                  \- TRUE if all components is found.
  ImageMagick_EXECUTABLE_DIR         \- Full path ta executablez directory.
  ImageMagick_<component>_FOUND      \- TRUE if <component> is found.
  ImageMagick_<component>_EXECUTABLE \- Full path ta <component> executable.
  ImageMagick_VERSION_STRING         \- tha version of ImageMagick found
                                       (since CMake 2.8.8)
.fi




ImageMagick_VERSION_STRING aint gonna work fo' oldschool versions like 5.2.3.


There is also components fo' tha followin ImageMagick APIs:


.nf
  Magick++
  MagickWand
  MagickCore
.fi




For these components tha followin variablez is set:


.nf
  ImageMagick_FOUND                    \- TRUE if all components is found.
  ImageMagick_INCLUDE_DIRS             \- Full paths ta all include dirs.
  ImageMagick_LIBRARIES                \- Full paths ta all libraries.
  ImageMagick_<component>_FOUND        \- TRUE if <component> is found.
  ImageMagick_<component>_INCLUDE_DIRS \- Full path ta <component> include dirs.
  ImageMagick_<component>_LIBRARIES    \- Full path ta <component> libraries.
.fi




Example Usages:


.nf
  find_package(ImageMagick)
  find_package(ImageMagick COMPONENTS convert)
  find_package(ImageMagick COMPONENTS convert mogrify display)
  find_package(ImageMagick COMPONENTS Magick++)
  find_package(ImageMagick COMPONENTS Magick++ convert)
.fi




Note dat tha standard FIND_PACKAGE features is supported (i.e., QUIET, REQUIRED, etc.).

.TP
.B FindJNI
Find JNI java libraries.

This module findz if Java is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  JNI_INCLUDE_DIRS      = tha include dirs ta use
  JNI_LIBRARIES         = tha libraries ta use
  JNI_FOUND             = TRUE if JNI headaz n' libraries was found.
  JAVA_AWT_LIBRARY      = tha path ta tha jawt library
  JAVA_JVM_LIBRARY      = tha path ta tha jvm library
  JAVA_INCLUDE_PATH     = tha include path ta jni.h
  JAVA_INCLUDE_PATH2    = tha include path ta jni_md.h
  JAVA_AWT_INCLUDE_PATH = tha include path ta jawt.h
.fi




.TP
.B FindJPEG
Find JPEG

Find tha natizzle JPEG includes n' library This module defines


.nf
  JPEG_INCLUDE_DIR, where ta find jpeglib.h, etc.
  JPEG_LIBRARIES, tha libraries needed ta use JPEG.
  JPEG_FOUND, If false, do not try ta use JPEG.
.fi

also defined yo, but not fo' general use are


.nf
  JPEG_LIBRARY, where ta find tha JPEG library.
.fi

.TP
.B FindJasper
Try ta find tha Jasper JPEG2000 library

Once done dis will define


.nf
  JASPER_FOUND \- system has Jasper
  JASPER_INCLUDE_DIR \- tha Jasper include directory
  JASPER_LIBRARIES \- tha libraries needed ta use Jasper
  JASPER_VERSION_STRING \- tha version of Jasper found (since CMake 2.8.8)
.fi

.TP
.B FindJava
Find Java

This module findz if Java is installed n' determines where tha include filez n' libraries are. This code sets tha followin variables:


.nf
  Java_JAVA_EXECUTABLE    = tha full path ta tha Java runtime
  Java_JAVAC_EXECUTABLE   = tha full path ta tha Java compiler
  Java_JAVAH_EXECUTABLE   = tha full path ta tha Java header generator
  Java_JAVADOC_EXECUTABLE = tha full path ta tha Java documention generator
  Java_JAR_EXECUTABLE     = tha full path ta tha Java archiver
  Java_VERSION_STRING     = Version of tha package found (java version), eg. 1.6.0_12
  Java_VERSION_MAJOR      = Da major version of tha package found.
  Java_VERSION_MINOR      = Da minor version of tha package found.
  Java_VERSION_PATCH      = Da patch version of tha package found.
  Java_VERSION_TWEAK      = Da tweak version of tha package found (afta '_')
  Java_VERSION            = This is set to: $major.$minor.$patch(.$tweak)
.fi




Da minimum required version of Java can be specified rockin tha standard CMake syntax, e.g. find_package(Java 1.5)


NOTE: ${Java_VERSION} n' ${Java_VERSION_STRING} is not guaranteed ta be identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example some java version may return: Java_VERSION_STRING = 1.5.0_17 n' Java_VERSION        = 1.5.0.17


another example is tha Java OEM, with: Java_VERSION_STRING = 1.6.0\-oem n' Java_VERSION        = 1.6.0


For these components tha followin variablez is set:


.nf
  Java_FOUND                    \- TRUE if all components is found.
  Java_INCLUDE_DIRS             \- Full paths ta all include dirs.
  Java_LIBRARIES                \- Full paths ta all libraries.
  Java_<component>_FOUND        \- TRUE if <component> is found.
.fi




Example Usages:


.nf
  find_package(Java)
  find_package(Java COMPONENTS Runtime)
  find_package(Java COMPONENTS Development)
.fi




.TP
.B FindKDE3
Find tha KDE3 include n' library dirs, KDE preprocessors n' define a some macros




This module defines tha followin variables:


.nf
  KDE3_DEFINITIONS         \- compila definitions required fo' compilin KDE software
  KDE3_INCLUDE_DIR         \- tha KDE include directory
  KDE3_INCLUDE_DIRS        \- tha KDE n' tha Qt include directory, fo' use wit include_directories()
  KDE3_LIB_DIR             \- tha directory where tha KDE libraries is installed, fo' use wit link_directories()
  QT_AND_KDECORE_LIBS      \- dis gotz nuff both tha Qt n' tha kdecore library
  KDE3_DCOPIDL_EXECUTABLE  \- tha dcopidl executable
  KDE3_DCOPIDL2CPP_EXECUTABLE \- tha dcopidl2cpp executable
  KDE3_KCFGC_EXECUTABLE    \- tha kconfig_compila executable
  KDE3_FOUND               \- set ta TRUE if all of tha above has been found
.fi




Da followin user adjustable options is provided:


.nf
  KDE3_BUILD_TESTS \- enable dis ta build KDE testcases
.fi







It also addz tha followin macros (from KDE3Macros.cmake) SRCS_VAR be always tha variable which gotz nuff tha list of source filez fo' yo' application or library.


KDE3_AUTOMOC(file1 ... fileN)


.nf
    Call dis if you wanna have automatic moc file handling.
    This means if you include "foo.moc" up in tha source file foo.cpp
    a moc file fo' tha header foo.h is ghon be pimped automatically.
    Yo ass can set tha property SKIP_AUTOMAKE rockin set_source_files_properties()
    ta exclude some filez up in tha list from bein processed.
.fi




KDE3_ADD_MOC_FILES(SRCS_VAR file1 ... fileN )


.nf
    If you don't use tha KDE3_AUTOMOC() macro, fo' tha files
    listed here moc filez is ghon be pimped (named "foo.moc.cpp")
.fi




KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h ... headerN.h )


.nf
    Use dis ta generate DCOP skeletions from tha listed headers.
.fi




KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h ... headerN.h )


.nf
     Use dis ta generate DCOP stubs from tha listed headers.
.fi




KDE3_ADD_UI_FILES(SRCS_VAR file1.ui ... fileN.ui )


.nf
    Use dis ta add tha Qt designer ui filez ta yo' application/library.
.fi




KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc ... fileN.kcfgc )


.nf
    Use dis ta add KDE kconfig compila filez ta yo' application/library.
.fi




KDE3_INSTALL_LIBTOOL_FILE(target)


.nf
    This will create n' install a simple libtool file fo' tha given target.
.fi




KDE3_ADD_EXECUTABLE(name file1 ... fileN )


.nf
    Currently identical ta add_executable(), may provide some advanced features up in tha future.
.fi




KDE3_ADD_KPART(name [WITH_PREFIX] file1 ... fileN )


.nf
    Smoke a KDE plugin (KPart, kioslave, etc.) from tha given source files.
    If WITH_PREFIX is given, tha resultin plugin gonna git tha prefix "lib", otherwise it won't.
    It creates n' installs a appropriate libtool la\-file.
.fi




KDE3_ADD_KDEINIT_EXECUTABLE(name file1 ... fileN )


.nf
    Smoke a KDE application up in tha form of a module loadable via kdeinit.
    A library named kdeinit_<name> is ghon be pimped n' a lil' small-ass executable which links ta dat shit.
.fi




Da option KDE3_ENABLE_FINAL ta enable all\-in\-one compilation is no longer supported.





Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindKDE4
.nf
 
.fi

Find KDE4 n' provide all necessary variablez n' macros ta compile software fo' dat shit. Well shiiiit, it looks fo' KDE 4 up in tha followin directories up in tha given order:


.nf
  CMAKE_INSTALL_PREFIX
  KDEDIRS
  /opt/kde4
.fi




Please look up in FindKDE4Internal.cmake n' KDE4Macros.cmake fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. They is installed wit tha KDE 4 libraries up in $KDEDIRS/share/apps/cmake/modules/.


Author: Alexander Neundorf <neundorf@kde.org>

.TP
.B FindLAPACK
Find LAPACK library

This module findz a installed fortran library dat implements tha LAPACK linear\-algebra intercourse (see http://www.netlib.org/lapack/).


Da approach bigs up dat taken fo' tha autoconf macro file, acx_lapack.m4 (distributed at http://ac\-archive.sourceforge.net/ac\-archive/acx_lapack.html).


This module sets tha followin variables:


.nf
  LAPACK_FOUND \- set ta legit if a library implementin tha LAPACK intercourse
    is found
  LAPACK_LINKER_FLAGS \- uncached list of required linker flags (excludin \-l
    n' \-L).
  LAPACK_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use LAPACK
  LAPACK95_LIBRARIES \- uncached list of libraries (usin full path name) to
    link against ta use LAPACK95
  LAPACK95_FOUND \- set ta legit if a library implementin tha LAPACK f95
    intercourse is found
  BLA_STATIC  if set on dis determines what tha fuck kind of linkage our phat asses do (static)
  BLA_VENDOR  if set checks only tha specified vendor, if not set checks
     all tha possibilities
  BLA_F95     if set on tries ta find tha f95 intercourses fo' BLAS/LAPACK
.fi

.TP
.B FindLATEX
Find Latex

This module findz if Latex is installed n' determines where tha executablez are. This code sets tha followin variables:


.nf
  LATEX_COMPILER:       path ta tha LaTeX compiler
  PDFLATEX_COMPILER:    path ta tha PdfLaTeX compiler
  BIBTEX_COMPILER:      path ta tha BibTeX compiler
  MAKEINDEX_COMPILER:   path ta tha MakeIndex compiler
  DVIPS_CONVERTER:      path ta tha DVIPS converter
  PS2PDF_CONVERTER:     path ta tha PS2PDF converter
  LATEX2HTML_CONVERTER: path ta tha LaTeX2Html converter
.fi




.TP
.B FindLibArchive
Find libarchive library n' headers

Da module defines tha followin variables:


.nf
  LibArchive_FOUND        \- legit if libarchive was found
  LibArchive_INCLUDE_DIRS \- include search path
  LibArchive_LIBRARIES    \- libraries ta link
  LibArchive_VERSION      \- libarchive 3\-component version number
.fi

.TP
.B FindLibLZMA
Find LibLZMA

Find LibLZMA headaz n' library


.nf
  LIBLZMA_FOUND             \- True if liblzma is found.
  LIBLZMA_INCLUDE_DIRS      \- Directory where liblzma headaz is located.
  LIBLZMA_LIBRARIES         \- Lzma libraries ta link against.
  LIBLZMA_HAS_AUTO_DECODER  \- True if lzma_auto_decoder() is found (required).
  LIBLZMA_HAS_EASY_ENCODER  \- True if lzma_easy_encoder() is found (required).
  LIBLZMA_HAS_LZMA_PRESET   \- True if lzma_lzma_preset() is found (required).
  LIBLZMA_VERSION_MAJOR     \- Da major version of lzma
  LIBLZMA_VERSION_MINOR     \- Da minor version of lzma
  LIBLZMA_VERSION_PATCH     \- Da patch version of lzma
  LIBLZMA_VERSION_STRING    \- version number as a strang (ex: "5.0.3")
.fi

.TP
.B FindLibXml2
Try ta find tha LibXml2 xml processin library

Once done dis will define


.nf
  LIBXML2_FOUND \- System has LibXml2
  LIBXML2_INCLUDE_DIR \- Da LibXml2 include directory
  LIBXML2_LIBRARIES \- Da libraries needed ta use LibXml2
  LIBXML2_DEFINITIONS \- Compila switches required fo' rockin LibXml2
  LIBXML2_XMLLINT_EXECUTABLE \- Da XML checkin tool xmllint comin wit LibXml2
  LIBXML2_VERSION_STRING \- tha version of LibXml2 found (since CMake 2.8.8)
.fi

.TP
.B FindLibXslt
Try ta find tha LibXslt library

Once done dis will define


.nf
  LIBXSLT_FOUND \- system has LibXslt
  LIBXSLT_INCLUDE_DIR \- tha LibXslt include directory
  LIBXSLT_LIBRARIES \- Link these ta LibXslt
  LIBXSLT_DEFINITIONS \- Compila switches required fo' rockin LibXslt
  LIBXSLT_VERSION_STRING \- version of LibXslt found (since CMake 2.8.8)
.fi

Additionally, tha followin two variablez is set (but not required fo' rockin xslt):


.nf
  LIBXSLT_EXSLT_LIBRARIES \- Link ta these if you need ta link against tha exslt library
  LIBXSLT_XSLTPROC_EXECUTABLE \- Gotz Nuff tha full path ta tha xsltproc executable if found
.fi

.TP
.B FindLua50
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA50_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES, both lua n' lualib
  LUA_INCLUDE_DIR, where ta find lua.h n' lualib.h (and probably lauxlib.h)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindLua51
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA51_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES
  LUA_INCLUDE_DIR, where ta find lua.h
  LUA_VERSION_STRING, tha version of Lua found (since CMake 2.8.8)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindLua52
.nf
 
.fi

Locate Lua library This module defines


.nf
  LUA52_FOUND, if false, do not try ta link ta Lua
  LUA_LIBRARIES
  LUA_INCLUDE_DIR, where ta find lua.h
  LUA_VERSION_STRING, tha version of Lua found (since CMake 2.8.8)
.fi




Note dat tha expected include convention is


.nf
  #include "lua.h"
.fi

and not


.nf
  #include <lua/lua.h>
.fi

This is cuz, tha lua location aint standardized n' may exist up in locations other than lua/

.TP
.B FindMFC
Find MFC on Windows

Find tha natizzle MFC \- i.e. decizzle if a application can link ta tha MFC libraries.


.nf
  MFC_FOUND \- Was MFC support found
.fi

Yo ass don't need ta include anythang or link anythang ta use dat shit.

.TP
.B FindMPEG
Find tha natizzle MPEG includes n' library

This module defines


.nf
  MPEG_INCLUDE_DIR, where ta find MPEG.h, etc.
  MPEG_LIBRARIES, tha libraries required ta use MPEG.
  MPEG_FOUND, If false, do not try ta use MPEG.
.fi

also defined yo, but not fo' general use are


.nf
  MPEG_mpeg2_LIBRARY, where ta find tha MPEG library.
  MPEG_vo_LIBRARY, where ta find tha vo library.
.fi

.TP
.B FindMPEG2
Find tha natizzle MPEG2 includes n' library

This module defines


.nf
  MPEG2_INCLUDE_DIR, path ta mpeg2dec/mpeg2.h, etc.
  MPEG2_LIBRARIES, tha libraries required ta use MPEG2.
  MPEG2_FOUND, If false, do not try ta use MPEG2.
.fi

also defined yo, but not fo' general use are


.nf
  MPEG2_mpeg2_LIBRARY, where ta find tha MPEG2 library.
  MPEG2_vo_LIBRARY, where ta find tha vo library.
.fi

.TP
.B FindMPI
Find a Message Passin Interface (MPI) implementation

Da Message Passin Interface (MPI) be a library used ta write high\-performizzle distributed\-memory parallel applications, n' is typically deployed on a cold-ass lil clusta n' shit. MPI be a standard intercourse (defined by tha MPI forum) fo' which nuff implementations is available fo' realz. All of dem have somewhat different include paths, libraries ta link against, etc., n' dis module tries ta smooth up dem differences.


=== Variablez ===


This module will set tha followin variablez per language up in yo' project, where <lang> is one of C, CXX, or Fortran:


.nf
   MPI_<lang>_FOUND           TRUE if FindMPI found MPI flags fo' <lang>
   MPI_<lang>_COMPILER        MPI Compila wrapper fo' <lang>
   MPI_<lang>_COMPILE_FLAGS   Compilation flags fo' MPI programs
   MPI_<lang>_INCLUDE_PATH    Include path(s) fo' MPI header
   MPI_<lang>_LINK_FLAGS      Linkin flags fo' MPI programs
   MPI_<lang>_LIBRARIES       All libraries ta link MPI programs against
.fi

Additionally, FindMPI sets tha followin variablez fo' hustlin MPI programs from tha command line:


.nf
   MPIEXEC                    Executable fo' hustlin MPI programs
   MPIEXEC_NUMPROC_FLAG       Flag ta pass ta MPIEXEC before giving
                              it tha number of processors ta run on
   MPIEXEC_PREFLAGS           Flags ta pass ta MPIEXEC directly
                              before tha executable ta run.
   MPIEXEC_POSTFLAGS          Flags ta pass ta MPIEXEC afta other flags
.fi

=== Usage ===


To use dis module, simply call FindMPI from a CMakeLists.txt file, or run find_package(MPI), then run CMake.  If yo ass be aiiight wit tha auto\- detected configuration fo' yo' language, then you done.  If not, you have two options:


.nf
   1. Right back up in yo muthafuckin ass. Set MPI_<lang>_COMPILER ta tha MPI wrapper (mpicc, etc.) of your
      chizzle n' reconfigure.  FindMPI'ma attempt ta determine all the
      necessary variablez rockin THAT compilerz compile n' link flags.
   2. If dis fails, or if yo' MPI implementation do not come with
      a cold-ass lil compila wrapper, then set both MPI_<lang>_LIBRARIES and
      MPI_<lang>_INCLUDE_PATH.  Yo ass may also set any other variables
      listed above yo, but these two is required. Y'all KNOW dat shit, muthafucka!  This will circumvent
      autodetection entirely.
.fi

When configuration is successful, MPI_<lang>_COMPILER is ghon be set ta tha compila wrapper fo' <lang>, if dat shiznit was found. Y'all KNOW dat shit, muthafucka!  MPI_<lang>_FOUND n' other variablez above is ghon be set if any MPI implementation was found fo' <lang>, regardless of whether a cold-ass lil compila was found.


When rockin MPIEXEC ta execute MPI applications, you should typically use all of tha MPIEXEC flags as bigs up:


.nf
   ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} PROCS
     ${MPIEXEC_PREFLAGS} EXECUTABLE ${MPIEXEC_POSTFLAGS} ARGS
.fi

where PROCS is tha number of processors on which ta execute tha program, EXECUTABLE is tha MPI program, n' ARGS is tha arguments ta pass ta tha MPI program.


=== Backward Compatibilitizzle ===


For backward compatibilitizzle wit olda versionz of FindMPI, these variablez is set yo, but deprecated:


.nf
   MPI_FOUND           MPI_COMPILER        MPI_LIBRARY
   MPI_COMPILE_FLAGS   MPI_INCLUDE_PATH    MPI_EXTRA_LIBRARY
   MPI_LINK_FLAGS      MPI_LIBRARIES
.fi

In freshly smoked up projects, please use tha MPI_<lang>_XXX equivalents.

.TP
.B FindMatlab
this module looks fo' Matlab

Defines:


.nf
  MATLAB_INCLUDE_DIR: include path fo' mex.h, engine.h
  MATLAB_LIBRARIES:   required libraries: libmex, etc
  MATLAB_MEX_LIBRARY: path ta libmex.lib
  MATLAB_MX_LIBRARY:  path ta libmx.lib
  MATLAB_ENG_LIBRARY: path ta libeng.lib
.fi

.TP
.B FindMotif
Try ta find Motif (or lesstif)

Once done dis will define:


.nf
  MOTIF_FOUND        \- system has MOTIF
  MOTIF_INCLUDE_DIR  \- include paths ta use Motif
  MOTIF_LIBRARIES    \- Link these ta use Motif
.fi

.TP
.B FindOpenAL
.nf
 
.fi

Locate OpenAL This module defines OPENAL_LIBRARY OPENAL_FOUND, if false, do not try ta link ta OpenAL OPENAL_INCLUDE_DIR, where ta find tha headers


$OPENALDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OPENALDIR used up in buildin OpenAL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module.

.TP
.B FindOpenGL
Try ta find OpenGL

Once done dis will define


.nf
  OPENGL_FOUND        \- system has OpenGL
  OPENGL_XMESA_FOUND  \- system has XMESA
  OPENGL_GLU_FOUND    \- system has GLU
  OPENGL_INCLUDE_DIR  \- tha GL include directory
  OPENGL_LIBRARIES    \- Link these ta use OpenGL n' GLU
.fi




If you wanna use just GL you can use these joints


.nf
  OPENGL_gl_LIBRARY   \- Path ta OpenGL Library
  OPENGL_glu_LIBRARY  \- Path ta GLU Library
.fi




On OSX default ta rockin tha framework version of opengl Muthafuckas will gotta chizzle tha cache jointz of OPENGL_glu_LIBRARY n' OPENGL_gl_LIBRARY ta use OpenGL wit X11 on OSX

.TP
.B FindOpenMP
Findz OpenMP support

This module can be used ta detect OpenMP support up in a cold-ass lil compila n' shit. If tha compila supports OpenMP, tha flags required ta compile wit OpenMP support is returned up in variablez fo' tha different languages. Da variablez may be empty if tha compila do not need a special flag ta support OpenMP.


Da followin variablez is set:


.nf
   OpenMP_C_FLAGS \- flags ta add ta tha C compila fo' OpenMP support
   OpenMP_CXX_FLAGS \- flags ta add ta tha CXX compila fo' OpenMP support
   OPENMP_FOUND \- legit if openmp is detected
.fi




Supported compilaz can be found at http://openmp.org/wp/openmp\-compilers/

.TP
.B FindOpenSSL
Try ta find tha OpenSSL encryption library

Once done dis will define


.nf
  OPENSSL_ROOT_DIR \- Set dis variable ta tha root installation of OpenSSL
.fi




Read\-Only variables:


.nf
  OPENSSL_FOUND \- system has tha OpenSSL library
  OPENSSL_INCLUDE_DIR \- tha OpenSSL include directory
  OPENSSL_LIBRARIES \- Da libraries needed ta use OpenSSL
  OPENSSL_VERSION \- This is set ta $major.$minor.$revision$path (eg. 0.9.8s)
.fi

.TP
.B FindOpenSceneGraph
Find OpenSceneGraph

This module searches fo' tha OpenSceneGraph core "osg" library as well as OpenThreads, n' whatever additionizzle COMPONENTS (nodekits) dat you specify.


.nf
    See http://www.openscenegraph.org
.fi




NOTE: To use dis module effectively you must either require CMake >= 2.6.3 wit cmake_minimum_required(VERSION 2.6.3) or downlizzle n' place FindOpenThreads.cmake, Findosg_functions.cmake, Findosg.cmake, n' Find<etc>.cmake filez tha fuck into yo' CMAKE_MODULE_PATH.


==================================


This module accepts tha followin variablez (note mixed case)


.nf
    OpenSceneGraph_DEBUG \- Enable debuggin output
.fi




.nf
    OpenSceneGraph_MARK_AS_ADVANCED \- Mark cache variablez as advanced
                                      automatically
.fi




Da followin environment variablez is also bigged up fo' findin tha OSG n' itz various components, n' you can put dat on yo' toast.  CMAKE_PREFIX_PATH can also be used fo' dis (see find_library() CMake documentation).


.nf
    <MODULE>_DIR (where MODULE iz of tha form "OSGVOLUME" n' there be a FindosgVolume.cmake file)
    OSG_DIR
    OSGDIR
    OSG_ROOT
.fi




[CMake 2.8.10]: Da CMake variable OSG_DIR can now be used as well ta influence detection, instead of needin ta specify a environment variable.


This module defines tha followin output variables:


.nf
    OPENSCENEGRAPH_FOUND \- Was tha OSG n' all of tha specified components found?
.fi




.nf
    OPENSCENEGRAPH_VERSION \- Da version of tha OSG which was found
.fi




.nf
    OPENSCENEGRAPH_INCLUDE_DIRS \- Where ta find tha headers
.fi




.nf
    OPENSCENEGRAPH_LIBRARIES \- Da OSG libraries
.fi




================================== Example Usage:


.nf
  find_package(OpenSceneGraph 2.0.0 REQUIRED osgDB osgUtil)
      # libOpenThreadz & libosg automatically searched
  include_directories(${OPENSCENEGRAPH_INCLUDE_DIRS})
.fi




.nf
  add_executable(foo foo.cc)
  target_link_libraries(foo ${OPENSCENEGRAPH_LIBRARIES})
.fi




.TP
.B FindOpenThreads
.nf
 
.fi

OpenThreadz be a C++ based threadin library. Its phattest userbase seems ta OpenSceneGraph so you might notice I accept OSGDIR as a environment path. I consider dis part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module.


Locate OpenThreadz This module defines OPENTHREADS_LIBRARY OPENTHREADS_FOUND, if false, do not try ta link ta OpenThreadz OPENTHREADS_INCLUDE_DIR, where ta find tha headers


$OPENTHREADS_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OPENTHREADS_DIR used up in buildin osg.


[CMake 2.8.10]: Da CMake variablez OPENTHREADS_DIR or OSG_DIR can now be used as well ta influence detection, instead of needin ta specify a environment variable.


Created by Eric Wing.

.TP
.B FindPHP4
Find PHP4

This module findz if PHP4 is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PHP4_INCLUDE_PATH       = path ta where php.h can be found
  PHP4_EXECUTABLE         = full path ta tha php4 binary
.fi




.TP
.B FindPNG
Find tha natizzle PNG includes n' library




This module searches libpng, tha library fo' hustlin wit PNG images.


It defines tha followin variables


.nf
  PNG_INCLUDE_DIRS, where ta find png.h, etc.
  PNG_LIBRARIES, tha libraries ta link against ta use PNG.
  PNG_DEFINITIONS \- Yo ass should add_definitons(${PNG_DEFINITIONS}) before compilin code dat includes png library files.
  PNG_FOUND, If false, do not try ta use PNG.
  PNG_VERSION_STRING \- tha version of tha PNG library found (since CMake 2.8.8)
.fi

Also defined yo, but not fo' general use are


.nf
  PNG_LIBRARY, where ta find tha PNG library.
.fi

For backward compatiblitizzle tha variable PNG_INCLUDE_DIR be also set. Well shiiiit, it has tha same ol' dirty value as PNG_INCLUDE_DIRS.


Since PNG dependz on tha ZLib compression library, none of tha above is ghon be defined unless ZLib can be found.

.TP
.B FindPackageHandleStandardArgs
.nf
 
.fi

FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> ... )


This function is intended ta be used up in FindXXX.cmake modulez files. Well shiiiit, it handlez tha REQUIRED, QUIET n' version\-related arguments ta find_package(). Well shiiiit, it also sets tha <packagename>_FOUND variable. Da package is considered found if all variablez <var1>... listed contain valid thangs up in dis biatch, e.g. valid filepaths.


There is two modez of dis function. I aint talkin' bout chicken n' gravy biatch. Da first argument up in both modes is tha name of tha Find\-module where it is called (in original gangsta casing).


Da first simple mode be lookin like this:


.nf
    FIND_PACKAGE_HANDLE_STANDARD_ARGS(<name> (DEFAULT_MSG|"Custom failure message") <var1>...<varN> )
.fi

If tha variablez <var1> ta <varN> is all valid, then <UPPERCASED_NAME>_FOUND is ghon be set ta TRUE. If DEFAULT_MSG is given as second argument, then tha function will generate itself useful success n' error lyrics. Yo ass can also supply a cold-ass lil custom error message fo' tha failure case. This aint recommended.


Da second mode is mo' bangin n' also supports version checking:


.nf
    FIND_PACKAGE_HANDLE_STANDARD_ARGS(NAME [FOUND_VAR <resultVar>]
                                           [REQUIRED_VARS <var1>...<varN>]
                                           [VERSION_VAR   <versionvar>]
                                           [HANDLE_COMPONENTS]
                                           [CONFIG_MODE]
                                           [FAIL_MESSAGE "Custom failure message"] )
.fi




In dis mode, tha name of tha result\-variable can be set either ta either <UPPERCASED_NAME>_FOUND or <OriginalCase_Name>_FOUND rockin tha FOUND_VAR option. I aint talkin' bout chicken n' gravy biatch. Other names fo' tha result\-variable is not allowed. Y'all KNOW dat shit, muthafucka! So fo' a Find\-module named FindFooBar.cmake, tha two possible names is FooBar_FOUND n' FOOBAR_FOUND. Well shiiiit, it is recommended ta use tha original gangsta case version. I aint talkin' bout chicken n' gravy biatch. If tha FOUND_VAR option aint used, tha default is <UPPERCASED_NAME>_FOUND.


As up in tha simple mode, if <var1> all up in <varN> is all valid, <packagename>_FOUND is ghon be set ta TRUE fo' realz. Afta REQUIRED_VARS tha variablez which is required fo' dis package is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Peepin VERSION_VAR tha name of tha variable can be specified which holdz tha version of tha package which has been found. Y'all KNOW dat shit, muthafucka! If dis is done, dis version is ghon be checked against tha (potentially) specified required version used up in tha find_package() call. Da EXACT keyword be also handled. Y'all KNOW dat shit, muthafucka! Da default lyrics include shiznit bout tha required version n' tha version which has been straight-up found, both if tha version be aiiight or not. If tha package supports components, use tha HANDLE_COMPONENTS option ta enable handlin em. In dis case, find_package_handle_standard_args() will report which components done been found n' which is missing, n' tha <packagename>_FOUND variable is ghon be set ta FALSE if any of tha required components (i.e. not tha ones listed afta OPTIONAL_COMPONENTS) is missing. Use tha option CONFIG_MODE if yo' FindXXX.cmake module be a wrapper fo' a gangbangin' find_package(... NO_MODULE) call.  In dis case VERSION_VAR is ghon be set ta <NAME>_VERSION n' tha macro will automatically check whether tha Config module was found. Y'all KNOW dat shit, muthafucka! Via FAIL_MESSAGE a cold-ass lil custom failure message can be specified, if dis aint used, tha default message is ghon be displayed.


Example fo' mode 1:


.nf
    find_package_handle_standard_args(LibXml2  DEFAULT_MSG  LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR)
.fi




LibXml2 is considered ta be found, if both LIBXML2_LIBRARY n' LIBXML2_INCLUDE_DIR is valid. Y'all KNOW dat shit, muthafucka! Then also LIBXML2_FOUND is set ta TRUE. If it aint found n' REQUIRED was used, it fails wit FATAL_ERROR, independent whether QUIET was used or not. If it is found, success is ghon be reported, includin tha content of <var1>. On repeated Cmake runs, tha same message won't be printed again.


Example fo' mode 2:


.nf
    find_package_handle_standard_args(LibXslt FOUND_VAR LibXslt_FOUND
                                             REQUIRED_VARS LibXslt_LIBRARIES LibXslt_INCLUDE_DIRS
                                             VERSION_VAR LibXslt_VERSION_STRING)
.fi

In dis case, LibXslt is considered ta be found if tha variable(s) listed afta REQUIRED_VAR is all valid, i.e. LibXslt_LIBRARIES n' LibXslt_INCLUDE_DIRS up in dis case. Da result will then be stored up in LibXslt_FOUND  fo' realz. Also tha version of LibXslt is ghon be checked by rockin tha version contained up in LibXslt_VERSION_STRING. Right back up in yo muthafuckin ass. Since no FAIL_MESSAGE is given, tha default lyrics is ghon be printed.


Another example fo' mode 2:


.nf
    find_package(Automoc4 QUIET NO_MODULE HINTS /opt/automoc4)
    find_package_handle_standard_args(Automoc4  CONFIG_MODE)
.fi

In dis case, FindAutmoc4.cmake wraps a cold-ass lil call ta find_package(Automoc4 NO_MODULE) n' addz a additionizzle search directory fo' automoc4 yo. Here tha result is ghon be stored up in AUTOMOC4_FOUND. Da followin FIND_PACKAGE_HANDLE_STANDARD_ARGS() call produces a proper success/error message.

.TP
.B FindPackageMessage
.nf
 
.fi

FIND_PACKAGE_MESSAGE(<name> "message fo' user" "find result details")


This macro is intended ta be used up in FindXXX.cmake modulez files. Well shiiiit, it will print a message once fo' each unique find result. This is useful fo' spittin some lyrics ta tha user where a package was found. Y'all KNOW dat shit, muthafucka! Da first argument specifies tha name (XXX) of tha package. Da second argument specifies tha message ta display. Da third argument lists details bout tha find result so dat if they chizzle tha message is ghon be displayed again. I aint talkin' bout chicken n' gravy biatch. Da macro also obeys tha QUIET argument ta tha find_package command.


Example:


.nf
  if(X11_FOUND)
    FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
      "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
  else()
   ...
  endif()
.fi

.TP
.B FindPerl
Find perl

this module looks fo' Perl


.nf
  PERL_EXECUTABLE     \- tha full path ta perl
  PERL_FOUND          \- If false, don't attempt ta use perl.
  PERL_VERSION_STRING \- version of perl found (since CMake 2.8.8)
.fi

.TP
.B FindPerlLibs
Find Perl libraries

This module findz if PERL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PERLLIBS_FOUND    = True if perl.h & libperl was found
  PERL_INCLUDE_PATH = path ta where perl.h is found
  PERL_LIBRARY      = path ta libperl
  PERL_EXECUTABLE   = full path ta tha perl binary
.fi




Da minimum required version of Perl can be specified rockin tha standard syntax, e.g. find_package(PerlLibs 6.0)


.nf
  Da followin variablez is also available if needed
  (introduced afta CMake 2.6.4)
.fi




.nf
  PERL_SITESEARCH    = path ta tha cribsearch install dir
  PERL_SITELIB       = path ta tha criblib install directory
  PERL_VENDORARCH    = path ta tha vendor arch install directory
  PERL_VENDORLIB     = path ta tha vendor lib install directory
  PERL_ARCHLIB       = path ta tha arch lib install directory
  PERL_PRIVLIB       = path ta tha priv lib install directory
  PERL_EXTRA_C_FLAGS = Compilation flags used ta build perl
.fi




.TP
.B FindPhysFS
.nf
 
.fi

Locate PhysFS library This module defines PHYSFS_LIBRARY, tha name of tha library ta link against PHYSFS_FOUND, if false, do not try ta link ta PHYSFS PHYSFS_INCLUDE_DIR, where ta find physfs.h


$PHYSFSDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$PHYSFSDIR used up in buildin PHYSFS.


Created by Eric Wing.

.TP
.B FindPike
Find Pike

This module findz if PIKE is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PIKE_INCLUDE_PATH       = path ta where program.h is found
  PIKE_EXECUTABLE         = full path ta tha pike binary
.fi




.TP
.B FindPkgConfig
a pkg\-config module fo' CMake




Usage:


.nf
   pkg_check_modules(<PREFIX> [REQUIRED] [QUIET] <MODULE> [<MODULE>]*)
     checks fo' all tha given modules
.fi




.nf
   pkg_search_module(<PREFIX> [REQUIRED] [QUIET] <MODULE> [<MODULE>]*)
     checks fo' given modulez n' uses tha straight-up original gangsta hustlin one
.fi




When tha 'REQUIRED' argument was set, macros will fail wit a error when module(s) could not be found


When tha 'QUIET' argument is set, no status lyrics is ghon be printed.


It sets tha followin variables:


.nf
   PKG_CONFIG_FOUND          ... if pkg\-config executable was found
   PKG_CONFIG_EXECUTABLE     ... pathname of tha pkg\-config program
   PKG_CONFIG_VERSION_STRING ... tha version of tha pkg\-config program found
                                 (since CMake 2.8.8)
.fi




For tha followin variablez two setz of joints exist; first one is tha common one n' has tha given PREFIX. Da second set gotz nuff flags which is given up when pkgconfig was called wit tha '\-\-static' option.


.nf
   <XPREFIX>_FOUND          ... set ta 1 if module(s) exist
   <XPREFIX>_LIBRARIES      ... only tha libraries (w/o tha '\-l')
   <XPREFIX>_LIBRARY_DIRS   ... tha pathz of tha libraries (w/o tha '\-L')
   <XPREFIX>_LDFLAGS        ... all required linker flags
   <XPREFIX>_LDFLAGS_OTHER  ... all other linker flags
   <XPREFIX>_INCLUDE_DIRS   ... tha '\-I' preprocessor flags (w/o tha '\-I')
   <XPREFIX>_CFLAGS         ... all required cflags
   <XPREFIX>_CFLAGS_OTHER   ... tha other compila flags
.fi




.nf
   <XPREFIX> = <PREFIX>        fo' common case
   <XPREFIX> = <PREFIX>_STATIC fo' static linking
.fi




There is some special variablez whose prefix dependz on tha count of given modules. When there is only one module, <PREFIX> stays unchanged. Y'all KNOW dat shit, muthafucka! When there be multiple modules, tha prefix is ghon be chizzled ta <PREFIX>_<MODNAME>:


.nf
   <XPREFIX>_VERSION    ... version of tha module
   <XPREFIX>_PREFIX     ... prefix\-directory of tha module
   <XPREFIX>_INCLUDEDIR ... include\-dir of tha module
   <XPREFIX>_LIBDIR     ... lib\-dir of tha module
.fi




.nf
   <XPREFIX> = <PREFIX>  when |MODULES| == 1, else
   <XPREFIX> = <PREFIX>_<MODNAME>
.fi




A <MODULE> parameta can have tha followin formats:


.nf
   {MODNAME}            ... matches any version
   {MODNAME}>={VERSION} ... at least version <VERSION> is required
   {MODNAME}={VERSION}  ... exactly version <VERSION> is required
   {MODNAME}<={VERSION} ... modulez must not be newer than <VERSION>
.fi




Examples


.nf
   pkg_check_modulez (GLIB2   glib\-2.0)
.fi




.nf
   pkg_check_modulez (GLIB2   glib\-2.0>=2.10)
     requires at least version 2.10 of glib2 n' defines e.g.
       GLIB2_VERSION=2.10.3
.fi




.nf
   pkg_check_modulez (FOO     glib\-2.0>=2.10 gtk+\-2.0)
     requires both glib2 n' gtk2, n' defines e.g.
       FOO_glib\-2.0_VERSION=2.10.3
       FOO_gtk+\-2.0_VERSION=2.8.20
.fi




.nf
   pkg_check_modulez (XRENDER REQUIRED xrender)
     defines e.g.:
       XRENDER_LIBRARIES=Xrender;X11
       XRENDER_STATIC_LIBRARIES=Xrender;X11;pthread;Xau;Xdmcp
.fi




.nf
   pkg_search_module (BAR     libxml\-2.0 libxml2 libxml>=2)
.fi

.TP
.B FindPostgreSQL
Find tha PostgreSQL installation.

In Windows, we make tha assumption that, if tha PostgreSQL filez is installed, tha default directory is ghon be C:\\Program Files\\PostgreSQL.


This module defines


.nf
  PostgreSQL_LIBRARIES \- tha PostgreSQL libraries needed fo' linking
  PostgreSQL_INCLUDE_DIRS \- tha directoriez of tha PostgreSQL headers
  PostgreSQL_VERSION_STRING \- tha version of PostgreSQL found (since CMake 2.8.8)
.fi

.TP
.B FindProducer
.nf
 
.fi

Though Producer aint directly part of OpenSceneGraph, its primary user is OSG so I consider dis part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. You'll notice dat I accept OSGDIR as a environment path.


Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL (and OpenThreads?) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate Producer This module defines PRODUCER_LIBRARY PRODUCER_FOUND, if false, do not try ta link ta Producer PRODUCER_INCLUDE_DIR, where ta find tha headers


$PRODUCER_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$PRODUCER_DIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindProtobuf
.nf
 
.fi

Locate n' configure tha Gizoogle Protocol Buffers library.


Da followin variablez can be set n' is optional:


.nf
   PROTOBUF_SRC_ROOT_FOLDER \- When compilin wit MSVC, if dis cache variable is set
                              tha protobuf\-default VS project build locations
                              (vsprojects/Debug & vsprojects/Release) is ghon be searched
                              fo' libraries n' binaries.
.fi




.nf
   PROTOBUF_IMPORT_DIRS     \- List of additionizzle directories ta be searched for
                              imported .proto files. (New up in CMake 2.8.8)
.fi




Defines tha followin variables:


.nf
   PROTOBUF_FOUND \- Found tha Gizoogle Protocol Buffers library (libprotobuf & header files)
   PROTOBUF_INCLUDE_DIRS \- Include directories fo' Gizoogle Protocol Buffers
   PROTOBUF_LIBRARIES \- Da protobuf libraries
.fi

[New up in CMake 2.8.5]


.nf
   PROTOBUF_PROTOC_LIBRARIES \- Da protoc libraries
   PROTOBUF_LITE_LIBRARIES \- Da protobuf\-lite libraries
.fi




Da followin cache variablez is also available ta set or use:


.nf
   PROTOBUF_LIBRARY \- Da protobuf library
   PROTOBUF_PROTOC_LIBRARY   \- Da protoc library
   PROTOBUF_INCLUDE_DIR \- Da include directory fo' protocol buffers
   PROTOBUF_PROTOC_EXECUTABLE \- Da protoc compiler
.fi

[New up in CMake 2.8.5]


.nf
   PROTOBUF_LIBRARY_DEBUG \- Da protobuf library (debug)
   PROTOBUF_PROTOC_LIBRARY_DEBUG   \- Da protoc library (debug)
   PROTOBUF_LITE_LIBRARY \- Da protobuf lite library
   PROTOBUF_LITE_LIBRARY_DEBUG \- Da protobuf lite library (debug)
.fi




.nf
  ====================================================================
  Example:
.fi




.nf
   find_package(Protobuf REQUIRED)
   include_directories(${PROTOBUF_INCLUDE_DIRS})
.fi




.nf
   include_directories(${CMAKE_CURRENT_BINARY_DIR})
   PROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS foo.proto)
   add_executable(bar bar.cc ${PROTO_SRCS} ${PROTO_HDRS})
   target_link_libraries(bar ${PROTOBUF_LIBRARIES})
.fi




NOTE: Yo ass may need ta link against pthreads, depending


.nf
       on tha platform.
.fi




NOTE: Da PROTOBUF_GENERATE_CPP macro & add_executable() or add_library()


.nf
       calls only work properly within tha same directory.
.fi




.nf
  ====================================================================
.fi




PROTOBUF_GENERATE_CPP (hood function)


.nf
   SRCS = Variable ta define wit autogenerated
          source files
   HDRS = Variable ta define wit autogenerated
          header files
   ARGN = proto files
.fi




.nf
  ====================================================================
.fi

.TP
.B FindPythonInterp
Find python interpreter

This module findz if Python interpreta is installed n' determines where tha executablez are. This code sets tha followin variables:


.nf
  PYTHONINTERP_FOUND         \- Was tha Python executable found
  PYTHON_EXECUTABLE          \- path ta tha Python interpreter
.fi




.nf
  PYTHON_VERSION_STRING      \- Python version found e.g. 2.5.2
  PYTHON_VERSION_MAJOR       \- Python major version found e.g. 2
  PYTHON_VERSION_MINOR       \- Python minor version found e.g. 5
  PYTHON_VERSION_PATCH       \- Python patch version found e.g. 2
.fi




Da Python_ADDITIONAL_VERSIONS variable can be used ta specify a list of version numbers dat should be taken tha fuck into account when searchin fo' Python. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta set dis variable before callin find_package(PythonInterp).

.TP
.B FindPythonLibs
Find python libraries

This module findz if Python is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  PYTHONLIBS_FOUND           \- have tha Python libs been found
  PYTHON_LIBRARIES           \- path ta tha python library
  PYTHON_INCLUDE_PATH        \- path ta where Python.h is found (deprecated)
  PYTHON_INCLUDE_DIRS        \- path ta where Python.h is found
  PYTHON_DEBUG_LIBRARIES     \- path ta tha debug library (deprecated)
  PYTHONLIBS_VERSION_STRING  \- version of tha Python libs found (since CMake 2.8.8)
.fi




Da Python_ADDITIONAL_VERSIONS variable can be used ta specify a list of version numbers dat should be taken tha fuck into account when searchin fo' Python. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta set dis variable before callin find_package(PythonLibs).


If you'd like ta specify tha installation of Python ta use, you should modify tha followin cache variables:


.nf
  PYTHON_LIBRARY             \- path ta tha python library
  PYTHON_INCLUDE_DIR         \- path ta where Python.h is found
.fi

.TP
.B FindQt
Searches fo' all installed versionz of Qt.

This should only be used if yo' project can work wit multiple versionz of Qt.  If not, you should just directly use FindQt4 or FindQt3. If multiple versionz of Qt is found on tha machine, then Da user must set tha option DESIRED_QT_VERSION ta tha version they wanna use.  If only one version of qt is found on tha machine, then tha DESIRED_QT_VERSION is set ta dat version n' tha matchin FindQt3 or FindQt4 module is included. Y'all KNOW dat shit, muthafucka! Once tha user sets DESIRED_QT_VERSION, then tha FindQt3 or FindQt4 module is included.


.nf
  QT_REQUIRED if dis is set ta TRUE then if CMake can
              not find Qt4 or Qt3 a error is raised
              n' a message is busted ta tha user.
.fi




.nf
  DESIRED_QT_VERSION OPTION is pimped
  QT4_INSTALLED is set ta TRUE if qt4 is found.
  QT3_INSTALLED is set ta TRUE if qt3 is found.
.fi

.TP
.B FindQt3
Locate Qt include paths n' libraries

This module defines:


.nf
  QT_INCLUDE_DIR    \- where ta find qt.h, etc.
  QT_LIBRARIES      \- tha libraries ta link against ta use Qt.
  QT_DEFINITIONS    \- definitions ta use when
                      compilin code dat uses Qt.
  QT_FOUND          \- If false, don't try ta use Qt.
  QT_VERSION_STRING \- tha version of Qt found
.fi




If you need tha multithreaded version of Qt, set QT_MT_REQUIRED ta TRUE


Also defined yo, but not fo' general use are:


.nf
  QT_MOC_EXECUTABLE, where ta find tha moc tool.
  QT_UIC_EXECUTABLE, where ta find tha uic tool.
  QT_QT_LIBRARY, where ta find tha Qt library.
  QT_QTMAIN_LIBRARY, where ta find tha qtmain
   library. This is only required by Qt3 on Windows.
.fi

.TP
.B FindQt4
Find Qt 4

This module can be used ta find Qt4. Da most blingin issue is dat tha Qt4 qmake be available via tha system path. This qmake is then used ta detect basically every last muthafuckin thang else. This module defines a fuckin shitload of key variablez n' macros. Da variable QT_USE_FILE is set which is tha path ta a CMake file dat can be included ta compile Qt 4 applications n' libraries. Put ya muthafuckin choppers up if ya feel dis!  It sets up tha compilation environment fo' include directories, preprocessor defines n' populates a QT_LIBRARIES variable.


Typical usage could be suttin' like:


.nf
   find_package(Qt4 4.4.3 REQUIRED QtCore QtGui QtXml)
   include(${QT_USE_FILE})
   add_executable(myexe main.cpp)
   target_link_libraries(myexe ${QT_LIBRARIES})
.fi




Da minimum required version can be specified rockin tha standard find_package()\-syntax (see example above). For compatibilitizzle wit olda versionz of FindQt4.cmake it be also possible ta set tha variable QT_MIN_VERSION ta tha minimum required version of Qt4 before tha find_package(Qt4) command. Y'all KNOW dat shit, muthafucka! If both is used, tha version used up in tha find_package() command overrides tha one from QT_MIN_VERSION.


When rockin tha components argument, QT_USE_QT* variablez is automatically set fo' tha QT_USE_FILE ta pick up.  If one wishes ta manually set them, tha available ones ta set include:


.nf
                    QT_DONT_USE_QTCORE
                    QT_DONT_USE_QTGUI
                    QT_USE_QT3SUPPORT
                    QT_USE_QTASSISTANT
                    QT_USE_QAXCONTAINER
                    QT_USE_QAXSERVER
                    QT_USE_QTDESIGNER
                    QT_USE_QTMOTIF
                    QT_USE_QTMAIN
                    QT_USE_QTMULTIMEDIA
                    QT_USE_QTNETWORK
                    QT_USE_QTNSPLUGIN
                    QT_USE_QTOPENGL
                    QT_USE_QTSQL
                    QT_USE_QTXML
                    QT_USE_QTSVG
                    QT_USE_QTTEST
                    QT_USE_QTUITOOLS
                    QT_USE_QTDBUS
                    QT_USE_QTSCRIPT
                    QT_USE_QTASSISTANTCLIENT
                    QT_USE_QTHELP
                    QT_USE_QTWEBKIT
                    QT_USE_QTXMLPATTERNS
                    QT_USE_PHONON
                    QT_USE_QTSCRIPTTOOLS
                    QT_USE_QTDECLARATIVE
.fi




.nf
  QT_USE_IMPORTED_TARGETS
        If dis variable is set ta TRUE, FindQt4.cmake will create imported
        library targets fo' tha various Qt libraries n' set the
        library variablez like QT_QTCORE_LIBRARY ta point at these imported
        targets instead of tha library file on disk. This serves up much better
        handlin of tha release n' debug versionz of tha Qt libraries n' is
       also always backwardz compatible, except fo' tha case dat dependencies
       of libraries is exported, these will then also list tha namez of the
       imported targets as dependency n' not tha file location on disk. This
       is much mo' flexible yo, but requires dat FindQt4.cmake is executed before
       such a exported dependency file is processed.
.fi




.nf
       Note dat if rockin IMPORTED targets, tha qtmain.lib static library is
       automatically linked on Windows. To disable dat globally, set the
       QT4_NO_LINK_QTMAIN variable before findin Qt4. To disable dat fo' a
       particular executable, set tha QT4_NO_LINK_QTMAIN target property to
       True on tha executable.
.fi




.nf
  QT_INCLUDE_DIRS_NO_SYSTEM
        If dis variable is set ta TRUE, tha Qt include directories
        up in tha QT_USE_FILE will NOT have tha SYSTEM keyword set.
.fi




There is also some filez dat need processin by some Qt tools like fuckin moc n' uic.  Listed below is macros dat may be used ta process dem files.


.nf
  macro QT4_WRAP_CPP(outfilez inputfile ... OPTIONS ...)
        create moc code from a list of filez containin Qt class with
        tha Q_OBJECT declaration. I aint talkin' bout chicken n' gravy biatch.  Per\-directory preprocessor definitions
        is also added. Y'all KNOW dat shit, muthafucka!  Options may be given ta moc, like fuckin dem found
        when executin "moc \-help".
.fi




.nf
  macro QT4_WRAP_UI(outfilez inputfile ... OPTIONS ...)
        create code from a list of Qt designer ui files.
        Options may be given ta uic, like fuckin dem found
        when executin "uic \-help"
.fi




.nf
  macro QT4_ADD_RESOURCES(outfilez inputfile ... OPTIONS ...)
        create code from a list of Qt resource files.
        Options may be given ta rcc, like fuckin dem found
        when executin "rcc \-help"
.fi




.nf
  macro QT4_GENERATE_MOC(inputfile outputfile )
        creates a rule ta run moc on infile n' create outfile.
        Use dis if fo' some reason QT4_WRAP_CPP() aint appropriate, e.g.
        cuz you need a cold-ass lil custom filename fo' tha moc file or suttin' similar.
.fi




.nf
  macro QT4_AUTOMOC(sourcefile1 sourcefile2 ... )
        Da qt4_automoc macro is obsolete.  Use tha CMAKE_AUTOMOC feature instead.
        This macro is still experimental.
        It can be used ta have moc automatically handled.
        So if you have tha filez foo.h n' foo.cpp, n' up in foo.h a
        a cold-ass lil class uses tha Q_OBJECT macro, moc has ta run on dat shit. If you don't
        wanna use QT4_WRAP_CPP() (which is reliable n' mature), you can insert
        #include "foo.moc"
        up in foo.cpp n' then give foo.cpp as argument ta QT4_AUTOMOC(). This will the
        scan all listed filez at cmake\-time fo' such included moc filez n' if it finds
        dem cause a rule ta be generated ta run moc at build time on the
        accompanyin header file foo.h.
        If a source file has tha SKIP_AUTOMOC property set it is ghon be ignored by dis macro.
.fi




.nf
        Yo ass should gotz a look on tha AUTOMOC property fo' targets ta big up tha same thangs up in dis biatch.
.fi




.nf
  macro QT4_ADD_DBUS_INTERFACE(outfilez intercourse basename)
        Smoke tha intercourse header n' implementation filez wit the
        given basename from tha given intercourse xml file n' add it to
        tha list of sources.
.fi




.nf
        Yo ass can pass additionizzle parametas ta tha qdbusxml2cpp call by setting
        propertizzles on tha input file:
.fi




.nf
        INCLUDE tha given file is ghon be included up in tha generate intercourse header
.fi




.nf
        CLASSNAME tha generated class is named accordingly
.fi




.nf
        NO_NAMESPACE tha generated class aint wrapped up in a namespace
.fi




.nf
  macro QT4_ADD_DBUS_INTERFACES(outfilez inputfile ... )
        Smoke tha intercourse header n' implementation files
        fo' all listed intercourse xml files.
        Da basename is ghon be automatically determined from tha name of tha xml file.
.fi




.nf
        Da source file propertizzles busted lyrics bout fo' QT4_ADD_DBUS_INTERFACE also apply here.
.fi




.nf
  macro QT4_ADD_DBUS_ADAPTOR(outfilez xmlfile parentheader parentclassname [basename] [classname])
        create a thugged-out dbus adaptor (header n' implementation file) from tha xml file
        describin tha intercourse, n' add it ta tha list of sources. Da adaptor
        forwardz tha calls ta a parent class, defined up in parentheader n' named
        parentclassname. Da name of tha generated filez will be
        <basename>adaptor.{cpp,h} where basename defaults ta tha basename of tha xml file.
        If <classname> is provided, then it is ghon be used as tha classname of the
        adaptor itself.
.fi




.nf
  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] OPTIONS ...)
        generate tha xml intercourse file from tha given header.
        If tha optionizzle argument intercoursename is omitted, tha name of the
        intercourse file is constructed from tha basename of tha header with
        tha suffix .xml appended.
        Options may be given ta qdbuscpp2xml, like fuckin dem found when executin "qdbuscpp2xml \-\-help"
.fi




.nf
  macro QT4_CREATE_TRANSLATION( qm_filez directories ... sources ...
                                ts_filez ... OPTIONS ...)
        out: qm_files
        in:  directories sources ts_files
        options: flags ta pass ta lupdate, like fuckin \-extensions ta specify
        extensions fo' a gangbangin' finger-lickin' directory scan.
        generates commandz ta create .ts (vie lupdate) n' .qm
        (via lrelease) \- filez from directories and/or sources. Da ts filez are
        pimped and/or updated up in tha source tree (unless given wit full paths).
        Da qm filez is generated up in tha build tree.
        Uppimpin tha translations can be done by addin tha qm_files
        ta tha source list of yo' library/executable, so they are
        always updated, or by addin a cold-ass lil custom target ta control when
        they git updated/generated.
.fi




.nf
  macro QT4_ADD_TRANSLATION( qm_filez ts_filez ... )
        out: qm_files
        in:  ts_files
        generates commandz ta create .qm from .ts \- files. Da generated
        filenames can be found up in qm_files. Da ts_files
        must exist n' is not updated up in any way.
.fi




function QT4_USE_MODULES( target [link_type] modules...)


.nf
        This function is obsolete. Use target_link_libraries wit IMPORTED targets instead.
        Make <target> use tha <modules> from Qt. Usin a Qt module means
        ta link ta tha library, add tha relevant include directories fo' tha module,
        n' add tha relevant compila defines fo' rockin tha module.
        Modulez is roughly equivalent ta componentz of Qt4, so usage would be
        suttin' like:
         qt4_use_modules(myexe Core Gui Declarative)
        ta use QtCore, QtGui n' QtDeclarative. Da optionizzle <link_type> argument can
        be specified as either LINK_PUBLIC or LINK_PRIVATE ta specify tha same argument
        ta tha target_link_libraries call.
.fi







.nf
  Below be a thugged-out detailed list of variablez dat FindQt4.cmake sets.
  QT_FOUND         If false, don't try ta use Qt.
  Qt4_FOUND        If false, don't try ta use Qt 4.
  QT4_FOUND        If false, don't try ta use Qt 4. This variable is fo' compatibilitizzle only.
.fi




.nf
  QT_VERSION_MAJOR Da major version of Qt found.
  QT_VERSION_MINOR Da minor version of Qt found.
  QT_VERSION_PATCH Da patch version of Qt found.
.fi




.nf
  QT_EDITION               Set ta tha edizzle of Qt (i.e. DesktopLight)
  QT_EDITION_DESKTOPLIGHT  True if QT_EDITION == DesktopLight
  QT_QTCORE_FOUND          True if QtCore was found.
  QT_QTGUI_FOUND           True if QtGui was found.
  QT_QT3SUPPORT_FOUND      True if Qt3Support was found.
  QT_QTASSISTANT_FOUND     True if QtAssistant was found.
  QT_QTASSISTANTCLIENT_FOUND  True if QtAssistantClient was found.
  QT_QAXCONTAINER_FOUND    True if QAxContainer was found (Windows only).
  QT_QAXSERVER_FOUND       True if QAxServer was found (Windows only).
  QT_QTDBUS_FOUND          True if QtDBus was found.
  QT_QTDESIGNER_FOUND      True if QtDesigner was found.
  QT_QTDESIGNERCOMPONENTS  True if QtDesignerComponents was found.
  QT_QTHELP_FOUND          True if QtHelp was found.
  QT_QTMOTIF_FOUND         True if QtMotif was found.
  QT_QTMULTIMEDIA_FOUND    True if QtMultimedia was found (since Qt 4.6.0).
  QT_QTNETWORK_FOUND       True if QtNetwork was found.
  QT_QTNSPLUGIN_FOUND      True if QtNsPlugin was found.
  QT_QTOPENGL_FOUND        True if QtOpenGL was found.
  QT_QTSQL_FOUND           True if QtSql was found.
  QT_QTSVG_FOUND           True if QtSvg was found.
  QT_QTSCRIPT_FOUND        True if QtScript was found.
  QT_QTSCRIPTTOOLS_FOUND   True if QtScriptTools was found.
  QT_QTTEST_FOUND          True if QtTest was found.
  QT_QTUITOOLS_FOUND       True if QtUiTools was found.
  QT_QTWEBKIT_FOUND        True if QtWebKit was found.
  QT_QTXML_FOUND           True if QtXml was found.
  QT_QTXMLPATTERNS_FOUND   True if QtXmlPatterns was found.
  QT_PHONON_FOUND          True if phonon was found.
  QT_QTDECLARATIVE_FOUND   True if QtDeclaratizzle was found.
.fi




.nf
  QT_MAC_USE_COCOA    For Mac OS X, its whether Cocoa or Carbon is used.
                      In general, dis should not be used yo, but its useful
                      when havin platform specific code.
.fi




.nf
  QT_DEFINITIONS   Definitions ta use when compilin code dat uses Qt.
                   Yo ass do not need ta use dis if you include QT_USE_FILE.
                   Da QT_USE_FILE will also define QT_DEBUG n' QT_NO_DEBUG
                   ta fit yo' current build type.  Those is not contained
                   up in QT_DEFINITIONS.
.fi




.nf
  QT_INCLUDES      List of paths ta all include directories of
                   Qt4 QT_INCLUDE_DIR n' QT_QTCORE_INCLUDE_DIR are
                   always up in dis variable even if NOTFOUND,
                   all other INCLUDE_DIRS are
                   only added if they is found.
                   Yo ass do not need ta use dis if you include QT_USE_FILE.
.fi







.nf
  Include directories fo' tha Qt modulez is listed here.
  Yo ass do not need ta use these variablez if you include QT_USE_FILE.
.fi




.nf
  QT_INCLUDE_DIR              Path ta "include" of Qt4
  QT_QT3SUPPORT_INCLUDE_DIR   Path ta "include/Qt3Support"
  QT_QTASSISTANT_INCLUDE_DIR  Path ta "include/QtAssistant"
  QT_QTASSISTANTCLIENT_INCLUDE_DIR       Path ta "include/QtAssistant"
  QT_QAXCONTAINER_INCLUDE_DIR Path ta "include/ActiveQt" (Windows only)
  QT_QAXSERVER_INCLUDE_DIR    Path ta "include/ActiveQt" (Windows only)
  QT_QTCORE_INCLUDE_DIR       Path ta "include/QtCore"
  QT_QTDBUS_INCLUDE_DIR       Path ta "include/QtDBus"
  QT_QTDESIGNER_INCLUDE_DIR   Path ta "include/QtDesigner"
  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path ta "include/QtDesigner"
  QT_QTGUI_INCLUDE_DIR        Path ta "include/QtGui"
  QT_QTHELP_INCLUDE_DIR       Path ta "include/QtHelp"
  QT_QTMOTIF_INCLUDE_DIR      Path ta "include/QtMotif"
  QT_QTMULTIMEDIA_INCLUDE_DIR Path ta "include/QtMultimedia"
  QT_QTNETWORK_INCLUDE_DIR    Path ta "include/QtNetwork"
  QT_QTNSPLUGIN_INCLUDE_DIR   Path ta "include/QtNsPlugin"
  QT_QTOPENGL_INCLUDE_DIR     Path ta "include/QtOpenGL"
  QT_QTSCRIPT_INCLUDE_DIR     Path ta "include/QtScript"
  QT_QTSQL_INCLUDE_DIR        Path ta "include/QtSql"
  QT_QTSVG_INCLUDE_DIR        Path ta "include/QtSvg"
  QT_QTTEST_INCLUDE_DIR       Path ta "include/QtTest"
  QT_QTWEBKIT_INCLUDE_DIR     Path ta "include/QtWebKit"
  QT_QTXML_INCLUDE_DIR        Path ta "include/QtXml"
  QT_QTXMLPATTERNS_INCLUDE_DIR  Path ta "include/QtXmlPatterns"
  QT_PHONON_INCLUDE_DIR       Path ta "include/phonon"
  QT_QTSCRIPTTOOLS_INCLUDE_DIR       Path ta "include/QtScriptTools"
  QT_QTDECLARATIVE_INCLUDE_DIR       Path ta "include/QtDeclarative"
.fi




.nf
  QT_BINARY_DIR               Path ta "bin" of Qt4
  QT_LIBRARY_DIR              Path ta "lib" of Qt4
  QT_PLUGINS_DIR              Path ta "plugins" fo' Qt4
  QT_TRANSLATIONS_DIR         Path ta "translations" of Qt4
  QT_IMPORTS_DIR              Path ta "imports" of Qt4
  QT_DOC_DIR                  Path ta "doc" of Qt4
  QT_MKSPECS_DIR              Path ta "mkspecs" of Qt4
.fi







Da Qt toolkit may contain both debug n' release libraries. Put ya muthafuckin choppers up if ya feel dis! In dat case, tha followin library variablez will contain both. Yo ass do not need ta use these variablez if you include QT_USE_FILE, n' use QT_LIBRARIES.


.nf
  QT_QT3SUPPORT_LIBRARY            Da Qt3Support library
  QT_QTASSISTANT_LIBRARY           Da QtAssistant library
  QT_QTASSISTANTCLIENT_LIBRARY     Da QtAssistantClient library
  QT_QAXCONTAINER_LIBRARY           Da QAxContainer library (Windows only)
  QT_QAXSERVER_LIBRARY                Da QAxServer library (Windows only)
  QT_QTCORE_LIBRARY                Da QtCore library
  QT_QTDBUS_LIBRARY                Da QtDBus library
  QT_QTDESIGNER_LIBRARY            Da QtDesigner library
  QT_QTDESIGNERCOMPONENTS_LIBRARY  Da QtDesignerComponents library
  QT_QTGUI_LIBRARY                 Da QtGui library
  QT_QTHELP_LIBRARY                Da QtHelp library
  QT_QTMOTIF_LIBRARY               Da QtMotif library
  QT_QTMULTIMEDIA_LIBRARY          Da QtMultimedia library
  QT_QTNETWORK_LIBRARY             Da QtNetwork library
  QT_QTNSPLUGIN_LIBRARY            Da QtNsPLugin library
  QT_QTOPENGL_LIBRARY              Da QtOpenGL library
  QT_QTSCRIPT_LIBRARY              Da QtScript library
  QT_QTSQL_LIBRARY                 Da QtSql library
  QT_QTSVG_LIBRARY                 Da QtSvg library
  QT_QTTEST_LIBRARY                Da QtTest library
  QT_QTUITOOLS_LIBRARY             Da QtUiTools library
  QT_QTWEBKIT_LIBRARY              Da QtWebKit library
  QT_QTXML_LIBRARY                 Da QtXml library
  QT_QTXMLPATTERNS_LIBRARY         Da QtXmlPatterns library
  QT_QTMAIN_LIBRARY                Da qtmain library fo' Windows
  QT_PHONON_LIBRARY                Da phonon library
  QT_QTSCRIPTTOOLS_LIBRARY         Da QtScriptTools library
.fi




Da QtDeclaratizzle library:             QT_QTDECLARATIVE_LIBRARY


also defined yo, but NOT fo' general use are


.nf
  QT_MOC_EXECUTABLE                   Where ta find tha moc tool.
  QT_UIC_EXECUTABLE                   Where ta find tha uic tool.
  QT_UIC3_EXECUTABLE                  Where ta find tha uic3 tool.
  QT_RCC_EXECUTABLE                   Where ta find tha rcc tool
  QT_DBUSCPP2XML_EXECUTABLE           Where ta find tha qdbuscpp2xml tool.
  QT_DBUSXML2CPP_EXECUTABLE           Where ta find tha qdbusxml2cpp tool.
  QT_LUPDATE_EXECUTABLE               Where ta find tha lupdate tool.
  QT_LRELEASE_EXECUTABLE              Where ta find tha lrelease tool.
  QT_QCOLLECTIONGENERATOR_EXECUTABLE  Where ta find tha qcollectiongenerator tool.
  QT_DESIGNER_EXECUTABLE              Where ta find tha Qt designer tool.
  QT_LINGUIST_EXECUTABLE              Where ta find tha Qt linguist tool.
.fi







These is round fo' backwardz compatibilitizzle they is ghon be set


.nf
  QT_WRAP_CPP  Set legit if QT_MOC_EXECUTABLE is found
  QT_WRAP_UI   Set legit if QT_UIC_EXECUTABLE is found
.fi




These variablez do _NOT_ have any effect no mo' (compared ta FindQt.cmake)


.nf
  QT_MT_REQUIRED         Qt4 is now always multithreaded
.fi




These variablez is set ta "" Because Qt structure chizzled (They make no sense up in Qt4)


.nf
  QT_QT_LIBRARY        Qt\-Library is now split
.fi

.TP
.B FindQuickTime
.nf
 
.fi

Locate QuickTime This module defines QUICKTIME_LIBRARY QUICKTIME_FOUND, if false, do not try ta link ta gdal QUICKTIME_INCLUDE_DIR, where ta find tha headers


$QUICKTIME_DIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$QUICKTIME_DIR


Created by Eric Wing.

.TP
.B FindRTI
Try ta find M&S HLA RTI libraries

This module findz if any HLA RTI is installed n' locates tha standard RTI include filez n' libraries.


RTI be a simulation infrastructure standardized by IEEE n' SISO. Well shiiiit, it has a well defined C++ API dat assures dat simulation applications is independent on a particular RTI implementation.


.nf
  http://en.wikipedia.org/wiki/Run\-Time_Infrastructure_(simulation)
.fi




This code sets tha followin variables:


.nf
  RTI_INCLUDE_DIR = tha directory where RTI includes file is found
  RTI_LIBRARIES = Da libraries ta link against ta use RTI
  RTI_DEFINITIONS = \-DRTI_USES_STD_FSTREAM
  RTI_FOUND = Set ta FALSE if any HLA RTI was not found
.fi




Report problems ta <certi\-devel@nongnu.org>

.TP
.B FindRuby
Find Ruby

This module findz if Ruby is installed n' determines where tha include filez n' libraries are. Ruby 1.8 n' 1.9 is supported.


Da minimum required version of Ruby can be specified rockin tha standard syntax, e.g. find_package(Ruby 1.8)


It also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  RUBY_EXECUTABLE   = full path ta tha ruby binary
  RUBY_INCLUDE_DIRS = include dirs ta be used when rockin tha ruby library
  RUBY_LIBRARY      = full path ta tha ruby library
  RUBY_VERSION      = tha version of ruby which was found, e.g. "1.8.7"
  RUBY_FOUND        = set ta legit if ruby ws found successfully
.fi




.nf
  RUBY_INCLUDE_PATH = same as RUBY_INCLUDE_DIRS, only provided fo' compatibilitizzle reasons, don't use it
.fi

.TP
.B FindSDL
Locate SDL library

This module defines


.nf
  SDL_LIBRARY, tha name of tha library ta link against
  SDL_FOUND, if false, do not try ta link ta SDL
  SDL_INCLUDE_DIR, where ta find SDL.h
  SDL_VERSION_STRING, human\-readable strang containin tha version of SDL
.fi




This module respondz ta tha the flag:


.nf
  SDL_BUILDING_LIBRARY
    If dis is defined, then no SDL_main is ghon be linked up in cuz
    only applications need main().
    Otherwise, it be assumed yo ass is buildin a application n' this
    module will attempt ta locate n' set tha the proper link flags
    as part of tha returned SDL_LIBRARY variable.
.fi




Don't forget ta include SDLmain.h n' SDLmain.m yo' project fo' tha OS X framework based version. I aint talkin' bout chicken n' gravy biatch. (Other versions link ta \-lSDLmain which dis module will try ta find on yo' behalf.) Also fo' OS X, dis module will automatically add tha \-framework Cocoa on yo' behalf.





Additionizzle Note: If you peep a empty SDL_LIBRARY_TEMP up in yo' configuration n' no SDL_LIBRARY, it means CMake did not find yo' SDL library (SDL.dll, libsdl.so, SDL.framework, etc). Right back up in yo muthafuckin ass. Set SDL_LIBRARY_TEMP ta point ta yo' SDL library, n' configure again. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Similarly, if you peep a empty SDLMAIN_LIBRARY, you should set dis value as appropriate. These joints is used ta generate tha final SDL_LIBRARY variable yo, but when these joints is unset, SDL_LIBRARY do not git pimped.





$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL. l.e.galup  9\-20\-02


Modified by Eric Win fo' realz. Added code ta assist wit automated buildin by rockin environmenstrual variablez n' providin a mo' controlled/consistent search behavior fo' realz. Added freshly smoked up modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc) fo' realz. Also erected tha header search path ta follow "proper" SDL guidelines fo' realz. Added a search fo' SDLmain which is needed by some platforms fo' realz. Added a search fo' threadz which is needed by some platforms fo' realz. Added needed compile switches fo' MinGW.


On OSX, dis will prefer tha Framework version (if found) over others. Muthafuckas will gotta manually chizzle tha cache jointz of SDL_LIBRARY ta override dis selection or set tha CMake environment CMAKE_INCLUDE_PATH ta modify tha search paths.


Note dat tha header path has chizzled from SDL/SDL.h ta just SDL.h This needed ta chizzle cuz "proper" SDL convention is #include "SDL.h", not <SDL/SDL.h>. This is done fo' portabilitizzle reasons cuz not all systems place thangs up in SDL/ (see FreeBSD).

.TP
.B FindSDL_image
Locate SDL_image library

This module defines:


.nf
  SDL_IMAGE_LIBRARIES, tha name of tha library ta link against
  SDL_IMAGE_INCLUDE_DIRS, where ta find tha headers
  SDL_IMAGE_FOUND, if false, do not try ta link against
  SDL_IMAGE_VERSION_STRING \- human\-readable strang containin tha version of SDL_image
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLIMAGE_LIBRARY (same value as SDL_IMAGE_LIBRARIES)
  SDLIMAGE_INCLUDE_DIR (same value as SDL_IMAGE_INCLUDE_DIRS)
  SDLIMAGE_FOUND (same value as SDL_IMAGE_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_mixer
Locate SDL_mixer library

This module defines:


.nf
  SDL_MIXER_LIBRARIES, tha name of tha library ta link against
  SDL_MIXER_INCLUDE_DIRS, where ta find tha headers
  SDL_MIXER_FOUND, if false, do not try ta link against
  SDL_MIXER_VERSION_STRING \- human\-readable strang containin tha version of SDL_mixer
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLMIXER_LIBRARY (same value as SDL_MIXER_LIBRARIES)
  SDLMIXER_INCLUDE_DIR (same value as SDL_MIXER_INCLUDE_DIRS)
  SDLMIXER_FOUND (same value as SDL_MIXER_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_net
Locate SDL_net library

This module defines:


.nf
  SDL_NET_LIBRARIES, tha name of tha library ta link against
  SDL_NET_INCLUDE_DIRS, where ta find tha headers
  SDL_NET_FOUND, if false, do not try ta link against
  SDL_NET_VERSION_STRING \- human\-readable strang containin tha version of SDL_net
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLNET_LIBRARY (same value as SDL_NET_LIBRARIES)
  SDLNET_INCLUDE_DIR (same value as SDL_NET_INCLUDE_DIRS)
  SDLNET_FOUND (same value as SDL_NET_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSDL_sound
Locates tha SDL_sound library




This module dependz on SDL bein found n' must be called AFTER FindSDL.cmake is called.


This module defines


.nf
  SDL_SOUND_INCLUDE_DIR, where ta find SDL_sound.h
  SDL_SOUND_FOUND, if false, do not try ta link ta SDL_sound
  SDL_SOUND_LIBRARIES, dis gotz nuff tha list of libraries dat you need
    ta link against. This be a read\-only variable n' is marked INTERNAL.
  SDL_SOUND_EXTRAS, dis be a optionizzle variable fo' you ta add yo' own
    flags ta SDL_SOUND_LIBRARIES. This is prepended ta SDL_SOUND_LIBRARIES.
    This be available mostly fo' cases dis module failed ta anticipate for
    n' you must add additionizzle flags. This is marked as ADVANCED.
  SDL_SOUND_VERSION_STRING, human\-readable strang containin tha version of SDL_sound
.fi




This module also defines (but you shouldn't need ta use directly)


.nf
   SDL_SOUND_LIBRARY, tha name of just tha SDL_sound library you would link
   against. Use SDL_SOUND_LIBRARIES fo' you link instructions n' not dis one.
.fi

And might define tha followin as needed


.nf
   MIKMOD_LIBRARY
   MODPLUG_LIBRARY
   OGG_LIBRARY
   VORBIS_LIBRARY
   SMPEG_LIBRARY
   FLAC_LIBRARY
   SPEEX_LIBRARY
.fi




Typically, you should not use these variablez directly, n' you should use SDL_SOUND_LIBRARIES which gotz nuff SDL_SOUND_LIBRARY n' tha other audio libraries (if needed) ta successfully compile on yo' system.


Created by Eric Wing. This module be a lil' bit mo' fucked up than tha other FindSDL* crew modules. Da reason is dat SDL_sound can be compiled up in a big-ass variety of different ways which is independent of platform. Right back up in yo muthafuckin ass. SDL_sound may dynamically link against other 3rd jam libraries ta git additionizzle codec support, like fuckin Ogg Vorbis, SMPEG, ModPlug, MikMod, FLAC, Speex, n' potentially others. Under some circumstances which I don't straight-up understand, there seems ta be a requirement dat dependent librariez of libraries you use must also be explicitly linked against up in order ta successfully compile. Right back up in yo muthafuckin ass. SDL_sound do not currently have any system up in place ta know how tha fuck dat shiznit was compiled. Y'all KNOW dat shit, muthafucka! So dis CMake module do tha mad bullshit up in tryin ta discover which 3rd jam libraries is required fo' buildin (if any). This module uses a funky-ass brute force approach ta create a test program dat uses SDL_sound, n' then tries ta build dat shit. If tha build fails, it parses tha error output fo' known symbol names ta figure up which libraries is needed.


Respondz ta tha $SDLDIR n' $SDLSOUNDDIR environmenstrual variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


On OSX, dis will prefer tha Framework version (if found) over others. Muthafuckas will gotta manually chizzle tha cache jointz of SDL_LIBRARY ta override dis selectionor set tha CMake environment CMAKE_INCLUDE_PATH ta modify tha search paths.

.TP
.B FindSDL_ttf
Locate SDL_ttf library

This module defines:


.nf
  SDL_TTF_LIBRARIES, tha name of tha library ta link against
  SDL_TTF_INCLUDE_DIRS, where ta find tha headers
  SDL_TTF_FOUND, if false, do not try ta link against
  SDL_TTF_VERSION_STRING \- human\-readable strang containin tha version of SDL_ttf
.fi




For backward compatiblitizzle tha followin variablez is also set:


.nf
  SDLTTF_LIBRARY (same value as SDL_TTF_LIBRARIES)
  SDLTTF_INCLUDE_DIR (same value as SDL_TTF_INCLUDE_DIRS)
  SDLTTF_FOUND (same value as SDL_TTF_FOUND)
.fi




$SDLDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$SDLDIR used up in buildin SDL.


Created by Eric Wing. This was hyped up by tha FindSDL.cmake module yo, but wit modifications ta recognize OS X frameworks n' additionizzle Unix paths (FreeBSD, etc).

.TP
.B FindSWIG
Find SWIG

This module findz a installed SWIG.  It sets tha followin variables:


.nf
  SWIG_FOUND \- set ta legit if SWIG is found
  SWIG_DIR \- tha directory where swig is installed
  SWIG_EXECUTABLE \- tha path ta tha swig executable
  SWIG_VERSION   \- tha version number of tha swig executable
.fi




Da minimum required version of SWIG can be specified rockin tha standard syntax, e.g. find_package(SWIG 1.1)


All shiznit is collected from tha SWIG_EXECUTABLE so tha version ta be found can be chizzled from tha command line by meanz of settin SWIG_EXECUTABLE


.TP
.B FindSelfPackers
Find upx

This module looks fo' some executable packers (i.e. software dat compress executablez or shared libs tha fuck into on\-the\-fly self\-extractin executablez or shared libs. Examples:


.nf
  UPX: http://wildsau.idv.uni\-linz.ac.at/mfx/upx.html
.fi

.TP
.B FindSquish
\-\- Typical Use




This module can be used ta find Squish. Currently Squish versions 3 n' 4 is supported.


.nf
  SQUISH_FOUND                    If false, don't try ta use Squish
  SQUISH_VERSION                  Da full version of Squish found
  SQUISH_VERSION_MAJOR            Da major version of Squish found
  SQUISH_VERSION_MINOR            Da minor version of Squish found
  SQUISH_VERSION_PATCH            Da patch version of Squish found
.fi




.nf
  SQUISH_INSTALL_DIR              Da Squish installation directory (containin bin, lib, etc)
  SQUISH_SERVER_EXECUTABLE        Da squishserver executable
  SQUISH_CLIENT_EXECUTABLE        Da squishrunner executable
.fi




.nf
  SQUISH_INSTALL_DIR_FOUND        Was tha install directory found?
  SQUISH_SERVER_EXECUTABLE_FOUND  Was tha server executable found?
  SQUISH_CLIENT_EXECUTABLE_FOUND  Was tha client executable found?
.fi




It serves up tha function squish_v4_add_test() fo' addin a squish test ta cmake rockin Squish 4.x:


.nf
   squish_v4_add_test(cmakeTestName AUT targetName SUITE suiteName TEST squishTestName
                   [SETTINGSGROUP group] [PRE_COMMAND command] [POST_COMMAND command] )
.fi




Da arguments have tha followin meaning:


.nf
   cmakeTestName: dis is ghon be used as tha straight-up original gangsta argument fo' add_test()
   AUT targetName: tha name of tha cmake target which is ghon be used as AUT, i.e. the
                   executable which is ghon be tested.
   SUITE suiteName: dis is either tha full path ta tha squish suite, or just the
                    last directory of tha suite, i.e. tha suite name. In dis case
                    tha CMakeLists.txt which calls squish_add_test() must be located
                    up in tha parent directory of tha suite directory.
   TEST squishTestName: tha name of tha squish test, i.e. tha name of tha subdirectory
                        of tha test inside tha suite directory.
   SETTINGSGROUP group: if specified, tha given settings crew is ghon be used fo' executin tha test.
                        If not specified, tha groupname is ghon be "CTest_<username>"
   PRE_COMMAND command:  if specified, tha given command is ghon be executed before startin tha squish test.
   POST_COMMAND command: same as PRE_COMMAND yo, but afta tha squish test has been executed.
.fi




.nf
   enable_testing()
   find_package(Squish 4.0)
   if (SQUISH_FOUND)
      squish_v4_add_test(myTestName AUT myApp SUITE ${CMAKE_SOURCE_DIR}/tests/mySuite TEST someSquishTest SETTINGSGROUP myGroup )
   endif ()
.fi







For playaz of Squish version 3.x tha macro squish_v3_add_test() is provided:


.nf
   squish_v3_add_test(testName applicationUnderTest testCase envVars testWrapper)
   Use dis macro ta add a test rockin Squish 3.x.
.fi




.nf
  enable_testing()
  find_package(Squish)
  if (SQUISH_FOUND)
    squish_v3_add_test(myTestName myApplication testCase envVars testWrapper)
  endif ()
.fi




macro SQUISH_ADD_TEST(testName applicationUnderTest testCase envVars testWrapper)


.nf
   This is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use SQUISH_V3_ADD_TEST() if yo ass is rockin Squish 3.x instead.
.fi

.TP
.B FindSubversion
Extract shiznit from a subversion hustlin copy

Da module defines tha followin variables:


.nf
  Subversion_SVN_EXECUTABLE \- path ta svn command line client
  Subversion_VERSION_SVN \- version of svn command line client
  Subversion_FOUND \- legit if tha command line client was found
  SUBVERSION_FOUND \- same as Subversion_FOUND, set fo' compatiblitizzle reasons
.fi




Da minimum required version of Subversion can be specified rockin tha standard syntax, e.g. find_package(Subversion 1.4)


If tha command line client executable is found two macros is defined:


.nf
  Subversion_WC_INFO(<dir> <var\-prefix>)
  Subversion_WC_LOG(<dir> <var\-prefix>)
.fi

Subversion_WC_INFO extracts shiznit of a subversion hustlin copy at a given location. I aint talkin' bout chicken n' gravy biatch. This macro defines tha followin variables:


.nf
  <var\-prefix>_WC_URL \- url of tha repository (at <dir>)
  <var\-prefix>_WC_ROOT \- root url of tha repository
  <var\-prefix>_WC_REVISION \- current revision
  <var\-prefix>_WC_LAST_CHANGED_AUTHOR \- lyricist of last commit
  <var\-prefix>_WC_LAST_CHANGED_DATE \- date of last commit
  <var\-prefix>_WC_LAST_CHANGED_REV \- revision of last commit
  <var\-prefix>_WC_INFO \- output of command `svn info <dir>'
.fi

Subversion_WC_LOG retrieves tha log message of tha base revision of a subversion hustlin copy at a given location. I aint talkin' bout chicken n' gravy biatch. This macro defines tha variable:


.nf
  <var\-prefix>_LAST_CHANGED_LOG \- last log of base revision
.fi

Example usage:


.nf
  find_package(Subversion)
  if(SUBVERSION_FOUND)
    Subversion_WC_INFO(${PROJECT_SOURCE_DIR} Project)
    message("Current revision is ${Project_WC_REVISION}")
    Subversion_WC_LOG(${PROJECT_SOURCE_DIR} Project)
    message("Last chizzled log is ${Project_LAST_CHANGED_LOG}")
  endif()
.fi

.TP
.B FindTCL
TK_INTERNAL_PATH was removed.

This module findz if Tcl is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TCL_FOUND              = Tcl was found
  TK_FOUND               = Tk was found
  TCLTK_FOUND            = Tcl n' Tk was found
  TCL_LIBRARY            = path ta Tcl library (tcl tcl80)
  TCL_INCLUDE_PATH       = path ta where tcl.h can be found
  TCL_TCLSH              = path ta tclsh binary (tcl tcl80)
  TK_LIBRARY             = path ta Tk library (tk tk80 etc)
  TK_INCLUDE_PATH        = path ta where tk.h can be found
  TK_WISH                = full path ta tha wish executable
.fi




In a effort ta remove some clutta n' clear up some thangs fo' playas whoz ass is not necessarily Tcl/Tk gurus/developpers, some variablez was moved or removed. Y'all KNOW dat shit, muthafucka! Chizzlez compared ta CMake 2.4 are:


.nf
   => they was only useful fo' playas freestylin Tcl/Tk extensions.
   => these libs is not packaged by default wit Tcl/Tk distributions.
      Even when Tcl/Tk is built from source, nuff muthafuckin flavorz of debug libs
      is pimped n' there is no real reason ta pick a single one
      specifically (say, amongst tcl84g, tcl84gs, or tcl84sgx).
      Letz leave dat chizzle ta tha user by allowin his ass ta assign
      TCL_LIBRARY ta any Tcl library, debug or not.
   => dis ended up bein only a Win32 variable, n' there be a shitload of
      mad drama regardin tha location of dis file up in a installed Tcl/Tk
      tree anyway (see 8.5 fo' example). If you need tha internal path at
      dis point it is less thuggy you ask directly where tha *source* tree is
      n' dig from there.
.fi

.TP
.B FindTIFF
Find TIFF library

Find tha natizzle TIFF includes n' library This module defines


.nf
  TIFF_INCLUDE_DIR, where ta find tiff.h, etc.
  TIFF_LIBRARIES, libraries ta link against ta use TIFF.
  TIFF_FOUND, If false, do not try ta use TIFF.
.fi

also defined yo, but not fo' general use are


.nf
  TIFF_LIBRARY, where ta find tha TIFF library.
.fi

.TP
.B FindTclStub
TCL_STUB_LIBRARY_DEBUG n' TK_STUB_LIBRARY_DEBUG was removed.

This module findz Tcl stub libraries. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it first findz Tcl include filez n' libraries by callin FindTCL.cmake yo. How tha fuck ta Use tha Tcl Stubs Library:


.nf
   http://tcl.activestate.com/doc/howto/stubs.html
.fi

Usin Stub Libraries:


.nf
   http://safari.oreilly.com/0130385603/ch48lev1sec3
.fi

This code sets tha followin variables:


.nf
  TCL_STUB_LIBRARY       = path ta Tcl stub library
  TK_STUB_LIBRARY        = path ta Tk stub library
  TTK_STUB_LIBRARY       = path ta ttk stub library
.fi




In a effort ta remove some clutta n' clear up some thangs fo' playas whoz ass is not necessarily Tcl/Tk gurus/developpers, some variablez was moved or removed. Y'all KNOW dat shit, muthafucka! Chizzlez compared ta CMake 2.4 are:


.nf
   => these libs is not packaged by default wit Tcl/Tk distributions.
      Even when Tcl/Tk is built from source, nuff muthafuckin flavorz of debug libs
      is pimped n' there is no real reason ta pick a single one
      specifically (say, amongst tclstub84g, tclstub84gs, or tclstub84sgx).
      Letz leave dat chizzle ta tha user by allowin his ass ta assign
      TCL_STUB_LIBRARY ta any Tcl library, debug or not.
.fi

.TP
.B FindTclsh
Find tclsh

This module findz if TCL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TCLSH_FOUND = TRUE if tclsh has been found
  TCL_TCLSH = tha path ta tha tclsh executable
.fi

In cygwin, look fo' tha cygwin version first.  Don't look fo' it lata ta avoid findin tha cygwin version on a Win32 build.

.TP
.B FindThreads
This module determines tha thread library of tha system.

Da followin variablez is set


.nf
  CMAKE_THREAD_LIBS_INIT     \- tha thread library
  CMAKE_USE_SPROC_INIT       \- is we rockin sproc?
  CMAKE_USE_WIN32_THREADS_INIT \- rockin WIN32 threads?
  CMAKE_USE_PTHREADS_INIT    \- is we rockin pthreads
  CMAKE_HP_PTHREADS_INIT     \- is we rockin hp pthreads
.fi

For systems wit multiple thread libraries, calla can set


.nf
  CMAKE_THREAD_PREFER_PTHREAD
.fi

.TP
.B FindUnixCommands
Find unix commandz from cygwin

This module looks fo' some usual Unix commands.


.TP
.B FindVTK
Find a VTK installation or build tree.

Da followin variablez is set if VTK is found. Y'all KNOW dat shit, muthafucka!  If VTK aint found, VTK_FOUND is set ta false.


.nf
  VTK_FOUND         \- Set ta legit when VTK is found.
  VTK_USE_FILE      \- CMake file ta use VTK.
  VTK_MAJOR_VERSION \- Da VTK major version number.
  VTK_MINOR_VERSION \- Da VTK minor version number
                       (odd non\-release).
  VTK_BUILD_VERSION \- Da VTK patch level
                       (meaningless fo' odd minor).
  VTK_INCLUDE_DIRS  \- Include directories fo' VTK
  VTK_LIBRARY_DIRS  \- Link directories fo' VTK libraries
  VTK_KITS          \- List of VTK kits, up in CAPS
                      (COMMON,IO,) etc.
  VTK_LANGUAGES     \- List of wrapped languages, up in CAPS
                      (TCL, PYHTON,) etc.
.fi

Da followin cache entries must be set by tha user ta locate VTK:


.nf
  VTK_DIR  \- Da directory containin VTKConfig.cmake.
             This is either tha root of tha build tree,
             or tha lib/vtk directory.  This is the
             only cache entry.
.fi

Da followin variablez is set fo' backward compatibilitizzle n' should not be used up in freshly smoked up code:


.nf
  USE_VTK_FILE \- Da full path ta tha UseVTK.cmake file.
                 This is provided fo' backward
                 compatibility.  Use VTK_USE_FILE
                 instead.
.fi




.TP
.B FindWget
Find wget

This module looks fo' wget. This module defines tha followin joints:


.nf
  WGET_EXECUTABLE: tha full path ta tha wget tool.
  WGET_FOUND: True if wget has been found.
.fi

.TP
.B FindWish
Find wish installation

This module findz if TCL is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. This code sets tha followin variables:


.nf
  TK_WISH = tha path ta tha wish executable
.fi




if UNIX is defined, then it will look fo' tha cygwin version first

.TP
.B FindX11
Find X11 installation

Try ta find X11 on UNIX systems. Da followin joints is defined


.nf
  X11_FOUND        \- True if X11 be available
  X11_INCLUDE_DIR  \- include directories ta use X11
  X11_LIBRARIES    \- link against these ta use X11
.fi




and also tha followin mo' fine grained variables: Include paths: X11_ICE_INCLUDE_PATH,          X11_ICE_LIB,        X11_ICE_FOUND


.nf
                X11_SM_INCLUDE_PATH,           X11_SM_LIB,         X11_SM_FOUND
                X11_X11_INCLUDE_PATH,          X11_X11_LIB
                X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
                X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
                X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
                X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
                X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
                X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
                X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
                                               X11_Xext_LIB,       X11_Xext_FOUND
                X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
                X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
                X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
                X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
                X11_xf86vmode_INCLUDE_PATH,    X11_Xxf86vm_LIB     X11_xf86vmode_FOUND
                X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
                X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
                X11_Xi_INCLUDE_PATH,           X11_Xi_LIB,         X11_Xi_FOUND
                X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
                X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
                X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
                X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
                X11_Xkbfile_INCLUDE_PATH,      X11_Xkbfile_LIB,    X11_Xkbfile_FOUND
                X11_Xmu_INCLUDE_PATH,          X11_Xmu_LIB,        X11_Xmu_FOUND
                X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
                X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
                X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
                X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
                X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
                X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
                X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
                X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND
                X11_XSync_INCLUDE_PATH,        (in X11_Xext_LIB),  X11_XSync_FOUND
.fi

.TP
.B FindXMLRPC
Find xmlrpc

Find tha natizzle XMLRPC headaz n' libraries.


.nf
  XMLRPC_INCLUDE_DIRS      \- where ta find xmlrpc.h, etc.
  XMLRPC_LIBRARIES         \- List of libraries when rockin xmlrpc.
  XMLRPC_FOUND             \- True if xmlrpc found.
.fi

XMLRPC modulez may be specified as components fo' dis find module. Modulez may be listed by hustlin "xmlrpc\-c\-config".  Modulez include:


.nf
  c++            C++ wrapper code
  libwww\-client  libwww\-based client
  cgi\-server     CGI\-based server
  abyss\-server   ABYSS\-based server
.fi

Typical usage:


.nf
  find_package(XMLRPC REQUIRED libwww\-client)
.fi

.TP
.B FindZLIB
Find zlib

Find tha natizzle ZLIB includes n' library. Once done dis will define


.nf
  ZLIB_INCLUDE_DIRS   \- where ta find zlib.h, etc.
  ZLIB_LIBRARIES      \- List of libraries when rockin zlib.
  ZLIB_FOUND          \- True if zlib found.
.fi




.nf
  ZLIB_VERSION_STRING \- Da version of zlib found (x.y.z)
  ZLIB_VERSION_MAJOR  \- Da major version of zlib
  ZLIB_VERSION_MINOR  \- Da minor version of zlib
  ZLIB_VERSION_PATCH  \- Da patch version of zlib
  ZLIB_VERSION_TWEAK  \- Da tweak version of zlib
.fi




Da followin variable is provided fo' backward compatibility


.nf
  ZLIB_MAJOR_VERSION  \- Da major version of zlib
  ZLIB_MINOR_VERSION  \- Da minor version of zlib
  ZLIB_PATCH_VERSION  \- Da patch version of zlib
.fi




An includer may set ZLIB_ROOT ta a zlib installation root ta tell dis module where ta look.

.TP
.B Findosg
.nf
 
.fi




NOTE: It be highly recommended dat you use tha freshly smoked up FindOpenSceneGraph.cmake introduced up in CMake 2.6.3 n' not use dis Find module directly.


This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osg This module defines


OSG_FOUND \- Was tha Osg found? OSG_INCLUDE_DIR \- Where ta find tha headaz OSG_LIBRARIES \- Da libraries ta link against fo' tha OSG (use this)


OSG_LIBRARY \- Da OSG library OSG_LIBRARY_DEBUG \- Da OSG debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgAnimation
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgAnimation This module defines


OSGANIMATION_FOUND \- Was osgAnimation found? OSGANIMATION_INCLUDE_DIR \- Where ta find tha headaz OSGANIMATION_LIBRARIES \- Da libraries ta link against fo' tha OSG (use this)


OSGANIMATION_LIBRARY \- Da OSG library OSGANIMATION_LIBRARY_DEBUG \- Da OSG debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgDB
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgDB This module defines


OSGDB_FOUND \- Was osgDB found? OSGDB_INCLUDE_DIR \- Where ta find tha headaz OSGDB_LIBRARIES \- Da libraries ta link against fo' tha osgDB (use this)


OSGDB_LIBRARY \- Da osgDB library OSGDB_LIBRARY_DEBUG \- Da osgDB debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgFX
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgFX This module defines


OSGFX_FOUND \- Was osgFX found? OSGFX_INCLUDE_DIR \- Where ta find tha headaz OSGFX_LIBRARIES \- Da libraries ta link against fo' tha osgFX (use this)


OSGFX_LIBRARY \- Da osgFX library OSGFX_LIBRARY_DEBUG \- Da osgFX debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgGA
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgGA This module defines


OSGGA_FOUND \- Was osgGA found? OSGGA_INCLUDE_DIR \- Where ta find tha headaz OSGGA_LIBRARIES \- Da libraries ta link against fo' tha osgGA (use this)


OSGGA_LIBRARY \- Da osgGA library OSGGA_LIBRARY_DEBUG \- Da osgGA debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgIntrospection
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgINTROSPECTION This module defines


OSGINTROSPECTION_FOUND \- Was osgIntrospection found? OSGINTROSPECTION_INCLUDE_DIR \- Where ta find tha headaz OSGINTROSPECTION_LIBRARIES \- Da libraries ta link fo' osgIntrospection (use this)


OSGINTROSPECTION_LIBRARY \- Da osgIntrospection library OSGINTROSPECTION_LIBRARY_DEBUG \- Da osgIntrospection debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgManipulator
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgManipulator This module defines


OSGMANIPULATOR_FOUND \- Was osgManipulator found? OSGMANIPULATOR_INCLUDE_DIR \- Where ta find tha headaz OSGMANIPULATOR_LIBRARIES \- Da libraries ta link fo' osgManipulator (use this)


OSGMANIPULATOR_LIBRARY \- Da osgManipulator library OSGMANIPULATOR_LIBRARY_DEBUG \- Da osgManipulator debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgParticle
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgParticle This module defines


OSGPARTICLE_FOUND \- Was osgParticle found? OSGPARTICLE_INCLUDE_DIR \- Where ta find tha headaz OSGPARTICLE_LIBRARIES \- Da libraries ta link fo' osgParticle (use this)


OSGPARTICLE_LIBRARY \- Da osgParticle library OSGPARTICLE_LIBRARY_DEBUG \- Da osgParticle debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgPresentation
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgPresentation This module defines


OSGPRESENTATION_FOUND \- Was osgPresentation found? OSGPRESENTATION_INCLUDE_DIR \- Where ta find tha headaz OSGPRESENTATION_LIBRARIES \- Da libraries ta link fo' osgPresentation (use this)


OSGPRESENTATION_LIBRARY \- Da osgPresentation library OSGPRESENTATION_LIBRARY_DEBUG \- Da osgPresentation debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing. Modified ta work wit osgPresentation by Robert Osfield, January 2012.

.TP
.B FindosgProducer
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgProducer This module defines


OSGPRODUCER_FOUND \- Was osgProducer found? OSGPRODUCER_INCLUDE_DIR \- Where ta find tha headaz OSGPRODUCER_LIBRARIES \- Da libraries ta link fo' osgProducer (use this)


OSGPRODUCER_LIBRARY \- Da osgProducer library OSGPRODUCER_LIBRARY_DEBUG \- Da osgProducer debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgQt
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgQt This module defines


OSGQT_FOUND \- Was osgQt found? OSGQT_INCLUDE_DIR \- Where ta find tha headaz OSGQT_LIBRARIES \- Da libraries ta link fo' osgQt (use this)


OSGQT_LIBRARY \- Da osgQt library OSGQT_LIBRARY_DEBUG \- Da osgQt debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing. Modified ta work wit osgQt by Robert Osfield, January 2012.

.TP
.B FindosgShadow
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgShadow This module defines


OSGSHADOW_FOUND \- Was osgShadow found? OSGSHADOW_INCLUDE_DIR \- Where ta find tha headaz OSGSHADOW_LIBRARIES \- Da libraries ta link fo' osgShadow (use this)


OSGSHADOW_LIBRARY \- Da osgShadow library OSGSHADOW_LIBRARY_DEBUG \- Da osgShadow debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgSim
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgSim This module defines


OSGSIM_FOUND \- Was osgSim found? OSGSIM_INCLUDE_DIR \- Where ta find tha headaz OSGSIM_LIBRARIES \- Da libraries ta link fo' osgSim (use this)


OSGSIM_LIBRARY \- Da osgSim library OSGSIM_LIBRARY_DEBUG \- Da osgSim debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgTerrain
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgTerrain This module defines


OSGTERRAIN_FOUND \- Was osgTerrain found? OSGTERRAIN_INCLUDE_DIR \- Where ta find tha headaz OSGTERRAIN_LIBRARIES \- Da libraries ta link fo' osgTerrain (use this)


OSGTERRAIN_LIBRARY \- Da osgTerrain library OSGTERRAIN_LIBRARY_DEBUG \- Da osgTerrain debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgText
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgText This module defines


OSGTEXT_FOUND \- Was osgText found? OSGTEXT_INCLUDE_DIR \- Where ta find tha headaz OSGTEXT_LIBRARIES \- Da libraries ta link fo' osgText (use this)


OSGTEXT_LIBRARY \- Da osgText library OSGTEXT_LIBRARY_DEBUG \- Da osgText debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgUtil
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgUtil This module defines


OSGUTIL_FOUND \- Was osgUtil found? OSGUTIL_INCLUDE_DIR \- Where ta find tha headaz OSGUTIL_LIBRARIES \- Da libraries ta link fo' osgUtil (use this)


OSGUTIL_LIBRARY \- Da osgUtil library OSGUTIL_LIBRARY_DEBUG \- Da osgUtil debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgViewer
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgViewer This module defines


OSGVIEWER_FOUND \- Was osgViewer found? OSGVIEWER_INCLUDE_DIR \- Where ta find tha headaz OSGVIEWER_LIBRARIES \- Da libraries ta link fo' osgViewer (use this)


OSGVIEWER_LIBRARY \- Da osgViewer library OSGVIEWER_LIBRARY_DEBUG \- Da osgViewer debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgVolume
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgVolume This module defines


OSGVOLUME_FOUND \- Was osgVolume found? OSGVOLUME_INCLUDE_DIR \- Where ta find tha headaz OSGVOLUME_LIBRARIES \- Da libraries ta link fo' osgVolume (use this)


OSGVOLUME_LIBRARY \- Da osgVolume library OSGVOLUME_LIBRARY_DEBUG \- Da osgVolume debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


Created by Eric Wing.

.TP
.B FindosgWidget
.nf
 
.fi

This is part of tha Findosg* suite used ta find OpenSceneGraph components, n' you can put dat on yo' toast. Each component is separate n' you must opt up in ta each module. Yo ass must also opt tha fuck into OpenGL n' OpenThreadz (and Producer if needed) as these modulez won't do it fo' yo thugged-out ass. This is ta allow you control over yo' own system piece by piece up in case you need ta opt outta certain components or chizzle tha Find behavior fo' a particular module (like cuz tha default FindOpenGL.cmake module don't work wit yo' system as a example). If you wanna bust a mo' convenient module dat includes every last muthafuckin thang, use tha FindOpenSceneGraph.cmake instead of tha Findosg*.cmake modules.


Locate osgWidget This module defines


OSGWIDGET_FOUND \- Was osgWidget found? OSGWIDGET_INCLUDE_DIR \- Where ta find tha headaz OSGWIDGET_LIBRARIES \- Da libraries ta link fo' osgWidget (use this)


OSGWIDGET_LIBRARY \- Da osgWidget library OSGWIDGET_LIBRARY_DEBUG \- Da osgWidget debug library


$OSGDIR be a environment variable dat would correspond ta tha ./configure \-\-prefix=$OSGDIR used up in buildin osg.


FindosgWidget.cmake tweaked from Findosg* suite as pimped by Eric Wing.

.TP
.B Findosg_functions
.nf
 
.fi




This CMake file gotz nuff two macros ta assist wit searchin fo' OSG libraries n' nodekits, n' you can put dat on yo' toast.  Please peep FindOpenSceneGraph.cmake fo' full documentation.


.TP
.B FindwxWidgets
Find a wxWidgets (a.k.a., wxWindows) installation.

This module findz if wxWidgets is installed n' selects a thugged-out default configuration ta use. wxWidgets be a modular library. To specify tha modulez dat yo big-ass booty is ghon use, you need ta name dem as components ta tha package:


find_package(wxWidgets COMPONENTS core base ...)


There is two search branches: a windows steez n' a unix style. For windows, tha followin variablez is searched fo' n' set ta defaults up in case of multiple chizzles. Chizzle dem if tha defaults is not desired (i.e., these is tha only variablez you should chizzle ta select a cold-ass lil configuration):


.nf
  wxWidgets_ROOT_DIR      \- Base wxWidgets directory
                            (e.g., C:/wxWidgets\-2.6.3).
  wxWidgets_LIB_DIR       \- Path ta wxWidgets libraries
                            (e.g., C:/wxWidgets\-2.6.3/lib/vc_lib).
  wxWidgets_CONFIGURATION \- Configuration ta use
                            (e.g., msw, mswd, mswu, mswunivud, etc.)
  wxWidgets_EXCLUDE_COMMON_LIBRARIES
                          \- Set ta TRUE ta exclude linkin of
                            commonly required libs (e.g., png tiff
                            jpeg zlib regex expat).
.fi




For unix steez it uses tha wx\-config utility. Yo ass can select between debug/release, unicode/ansi, universal/non\-universal, n' static/shared up in tha QtDialog or ccmake intercourses by turnin ON/OFF tha followin variables:


.nf
  wxWidgets_USE_DEBUG
  wxWidgets_USE_UNICODE
  wxWidgets_USE_UNIVERSAL
  wxWidgets_USE_STATIC
.fi




There be also a wxWidgets_CONFIG_OPTIONS variable fo' all other options dat need ta be passed ta tha wx\-config utility. For example, ta use tha base toolkit found up in tha /usr/local path, set tha variable (before callin tha FIND_PACKAGE command) as such:


.nf
  set(wxWidgets_CONFIG_OPTIONS \-\-toolkit=base \-\-prefix=/usr)
.fi




Da followin is set afta tha configuration is done fo' both windows n' unix style:


.nf
  wxWidgets_FOUND            \- Set ta TRUE if wxWidgets was found.
  wxWidgets_INCLUDE_DIRS     \- Include directories fo' WIN32
                               i.e., where ta find "wx/wx.h" and
                               "wx/setup.h"; possibly empty fo' unices.
  wxWidgets_LIBRARIES        \- Path ta tha wxWidgets libraries.
  wxWidgets_LIBRARY_DIRS     \- compile time link dirs, useful for
                               rpath on UNIX. Typically a empty string
                               up in WIN32 environment.
  wxWidgets_DEFINITIONS      \- Gotz Nuff defines required ta compile/link
                               against WX, e.g. WXUSINGDLL
  wxWidgets_DEFINITIONS_DEBUG\- Gotz Nuff defines required ta compile/link
                               against WX debug builds, e.g. __WXDEBUG__
  wxWidgets_CXX_FLAGS        \- Include dirs n' compila flags for
                               unices, empty on WIN32. Essentially
                               "`wx\-config \-\-cxxflags`".
  wxWidgets_USE_FILE         \- Convenience include file.
.fi




Sample usage:


.nf
   # Note dat fo' MinGW playas tha order of libs is blingin!
   find_package(wxWidgets COMPONENTS net gl core base)
   if(wxWidgets_FOUND)
     include(${wxWidgets_USE_FILE})
     # n' fo' each of yo' dependent executable/library targets:
     target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
   endif()
.fi




If wxWidgets is required (i.e., not a optionizzle part):


.nf
   find_package(wxWidgets REQUIRED net gl core base)
   include(${wxWidgets_USE_FILE})
   # n' fo' each of yo' dependent executable/library targets:
   target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
.fi

.TP
.B FindwxWindows
Find wxWindows (wxWidgets) installation

This module findz if wxWindows/wxWidgets is installed n' determines where tha include filez n' libraries are. Well shiiiit, it also determines what tha fuck tha name of tha library is. Please note dis file is DEPRECATED n' replaced by FindwxWidgets.cmake. This code sets tha followin variables:


.nf
  WXWINDOWS_FOUND     = system has WxWindows
  WXWINDOWS_LIBRARIES = path ta tha wxWindows libraries
                        on Unix/Linux wit additional
                        linker flags from
                        "wx\-config \-\-libs"
  CMAKE_WXWINDOWS_CXX_FLAGS  = Compila flags fo' wxWindows,
                               essentially "`wx\-config \-\-cxxflags`"
                               on Linux
  WXWINDOWS_INCLUDE_DIR      = where ta find "wx/wx.h" n' "wx/setup.h"
  WXWINDOWS_LINK_DIRECTORIES = link directories, useful fo' rpath on
                                Unix
  WXWINDOWS_DEFINITIONS      = extra defines
.fi




OPTIONS If you need OpenGL support please


.nf
  set(WXWINDOWS_USE_GL 1)
.fi

in yo' CMakeLists.txt *before* you include dis file.


.nf
  HAVE_ISYSTEM      \- legit required ta replace \-I by \-isystem on g++
.fi




For convenience include Use_wxWindows.cmake up in yo' projectz CMakeLists.txt rockin include(${CMAKE_CURRENT_LIST_DIR}/Use_wxWindows.cmake).


USAGE


.nf
  set(WXWINDOWS_USE_GL 1)
  find_package(wxWindows)
.fi




NOTES wxWidgets 2.6.x is supported fo' monolithic buildz e.g. compiled  up in wx/build/msw dir as:


.nf
  nmake \-f makefile.vc BUILD=debug SHARED=0 USE_OPENGL=1 MONOLITHIC=1
.fi




DEPRECATED


.nf
  CMAKE_WX_CAN_COMPILE
  WXWINDOWS_LIBRARY
  CMAKE_WX_CXX_FLAGS
  WXWINDOWS_INCLUDE_PATH
.fi




AUTHOR Jan Woetzel <http://www.mip.informatik.uni\-kiel.de/~jw> (07/2003\-01/2006)

.TP
.B FortranCInterface
Fortran/C Interface Detection

This module automatically detects tha API by which C n' Fortran languages interact.  Variablez indicate if tha manglin is found:


.nf
   FortranCInterface_GLOBAL_FOUND = Global subroutines n' functions
   FortranCInterface_MODULE_FOUND = Module subroutines n' functions
                                    (declared by "MODULE PROCEDURE")
.fi

A function is provided ta generate a C header file containin macros ta mangle symbol names:


.nf
   FortranCInterface_HEADER(<file>
                            [MACRO_NAMESPACE <macro\-ns>]
                            [SYMBOL_NAMESPACE <ns>]
                            [SYMBOLS [<module>:]<function> ...])
.fi

It generates up in <file> definitionz of tha followin macros:


.nf
   #define FortranCInterface_GLOBAL (name,NAME) ...
   #define FortranCInterface_GLOBAL_(name,NAME) ...
   #define FortranCInterface_MODULE (mod,name, MOD,NAME) ...
   #define FortranCInterface_MODULE_(mod,name, MOD,NAME) ...
.fi

These macros mangle four categoriez of Fortran symbols, respectively:


.nf
   \- Global symbols without '_': call mysub()
   \- Global symbols wit '_'   : call my_sub()
   \- Module symbols without '_': use mymod; call mysub()
   \- Module symbols wit '_'   : use mymod; call my_sub()
.fi

If manglin fo' a cold-ass lil category aint known, its macro is left undefined. Y'all KNOW dat shit, muthafucka! All macros require raw names up in both lower case n' upper case. Da MACRO_NAMESPACE option replaces tha default "FortranCInterface_" prefix wit a given namespace "<macro\-ns>".


Da SYMBOLS option lists symbols ta mangle automatically wit C preprocessor definitions:


.nf
   <function>          ==> #define <ns><function> ...
   <module>:<function> ==> #define <ns><module>_<function> ...
.fi

If tha manglin fo' some symbol aint known then no preprocessor definizzle is pimped, n' a warnin is displayed. Y'all KNOW dat shit, muthafucka! Da SYMBOL_NAMESPACE option prefixes all preprocessor definitions generated by tha SYMBOLS option wit a given namespace "<ns>".


Example usage:


.nf
   include(FortranCInterface)
   FortranCInterface_HEADER(FC.h MACRO_NAMESPACE "FC_")
.fi

This creates a "FC.h" header dat defines manglin macros FC_GLOBAL(), FC_GLOBAL_(), FC_MODULE(), n' FC_MODULE_().


Example usage:


.nf
   include(FortranCInterface)
   FortranCInterface_HEADER(FCMangle.h
                            MACRO_NAMESPACE "FC_"
                            SYMBOL_NAMESPACE "FC_"
                            SYMBOLS mysub mymod:my_sub)
.fi

This creates a "FCMangle.h" header dat defines tha same ol' dirty FC_*() manglin macros as tha previous example plus preprocessor symbols FC_mysub n' FC_mymod_my_sub.


Another function is provided ta verify dat tha Fortran n' C/C++ compilaz work together:


.nf
   FortranCInterface_VERIFY([CXX] [QUIET])
.fi

It tests whether a simple test executable rockin Fortran n' C (and C++ when tha CXX option is given) compilez n' links successfully. Da result is stored up in tha cache entry FortranCInterface_VERIFIED_C (or FortranCInterface_VERIFIED_CXX if CXX is given) as a funky-ass boolean. I aint talkin' bout chicken n' gravy biatch. If tha check fails n' QUIET aint given tha function terminates wit a FATAL_ERROR message describin tha problem.  Da purpose of dis check is ta stop a funky-ass build early fo' incompatible compila combinations.  Da test is built up in tha Release configuration.


FortranCInterface be aware of possible GLOBAL n' MODULE manglings fo' nuff Fortran compilaz yo, but it also serves up a intercourse ta specify freshly smoked up possible manglings.  Set tha variables


.nf
   FortranCInterface_GLOBAL_SYMBOLS
   FortranCInterface_MODULE_SYMBOLS
.fi

before includin FortranCInterface ta specify manglingz of tha symbols "MySub", "My_Sub", "MyModule:MySub", n' "My_Module:My_Sub". For example, tha code:


.nf
   set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub__ MYSUB_)
     #                                  ^^^^^  ^^^^^^   ^^^^^
   set(FortranCInterface_MODULE_SYMBOLS
       __mymodule_MOD_mysub __my_module_MOD_my_sub)
     #   ^^^^^^^^     ^^^^^   ^^^^^^^^^     ^^^^^^
   include(FortranCInterface)
.fi

 drops some lyrics ta FortranCInterface ta try given GLOBAL n' MODULE manglings. (Da carets point at raw symbol names fo' claritizzle up in dis example but is not needed.)

.TP
.B GNUInstallDirs
Define GNU standard installation directories

Provides install directory variablez as defined fo' GNU software:


.nf
  http://www.gnu.org/prep/standards/html_node/Directory\-Variables.html
.fi

Inclusion of dis module defines tha followin variables:


.nf
  CMAKE_INSTALL_<dir>      \- destination fo' filez of a given type
  CMAKE_INSTALL_FULL_<dir> \- correspondin absolute path
.fi

where <dir> is one of:


.nf
  BINDIR           \- user executablez (bin)
  SBINDIR          \- system admin executablez (sbin)
  LIBEXECDIR       \- program executablez (libexec)
  SYSCONFDIR       \- read\-only single\-machine data (etc)
  SHAREDSTATEDIR   \- modifiable architecture\-independent data (com)
  LOCALSTATEDIR    \- modifiable single\-machine data (var)
  LIBDIR           \- object code libraries (lib or lib64 or lib/<multiarch\-tuple> on Debian)
  INCLUDEDIR       \- C header filez (include)
  OLDINCLUDEDIR    \- C header filez fo' non\-gcc (/usr/include)
  DATAROOTDIR      \- read\-only architecture\-independent data root (share)
  DATADIR          \- read\-only architecture\-independent data (DATAROOTDIR)
  INFODIR          \- info documentation (DATAROOTDIR/info)
  LOCALEDIR        \- locale\-dependent data (DATAROOTDIR/locale)
  MANDIR           \- playa documentation (DATAROOTDIR/man)
  DOCDIR           \- documentation root (DATAROOTDIR/doc/PROJECT_NAME)
.fi

Each CMAKE_INSTALL_<dir> value may be passed ta tha DESTINATION optionz of install() commandz fo' tha correspondin file type.  If tha includer do not define a value tha above\-shown default is ghon be used n' tha value will step tha fuck up in tha cache fo' editin by tha user n' shit. Each CMAKE_INSTALL_FULL_<dir> value gotz nuff a absolute path constructed from tha correspondin destination by prependin (if necessary) tha value of CMAKE_INSTALL_PREFIX.

.TP
.B GenerateExportHeader
Function fo' generation of export macros fo' libraries

This module serves up tha function GENERATE_EXPORT_HEADER() n' tha accompanyin ADD_COMPILER_EXPORT_FLAGS() function.


Da GENERATE_EXPORT_HEADER function can be used ta generate a gangbangin' file suitable fo' preprocessor inclusion which gotz nuff EXPORT macros ta be used up in library classes.


GENERATE_EXPORT_HEADER( LIBRARY_TARGET


.nf
             [BASE_NAME <base_name>]
             [EXPORT_MACRO_NAME <export_macro_name>]
             [EXPORT_FILE_NAME <export_file_name>]
             [DEPRECATED_MACRO_NAME <deprecated_macro_name>]
             [NO_EXPORT_MACRO_NAME <no_export_macro_name>]
             [STATIC_DEFINE <static_define>]
             [NO_DEPRECATED_MACRO_NAME <no_deprecated_macro_name>]
             [DEFINE_NO_DEPRECATED]
             [PREFIX_NAME <prefix_name>]
.fi

)


ADD_COMPILER_EXPORT_FLAGS( [<output_variable>] )


By default GENERATE_EXPORT_HEADER() generates macro names up in a gangbangin' file name determined by tha name of tha library. Da ADD_COMPILER_EXPORT_FLAGS function addz \-fvisibility=hidden ta CMAKE_CXX_FLAGS if supported, n' be a no\-op on Windows which do not need extra compila flags fo' exportin support. Yo ass may optionally pass a single argument ta ADD_COMPILER_EXPORT_FLAGS dat is ghon be populated wit tha required CXX_FLAGS required ta enable visibilitizzle support fo' tha compiler/architecture up in use.


This means dat up in tha simplest case, playaz of these functions is ghon be equivalent to:


.nf
   add_compiler_export_flags()
   add_library(somelib someclass.cpp)
   generate_export_header(somelib)
   install(TARGETS somelib DESTINATION ${LIBRARY_INSTALL_DIR})
   install(FILES
    someclass.h
    ${PROJECT_BINARY_DIR}/somelib_export.h DESTINATION ${INCLUDE_INSTALL_DIR}
   )
.fi




And up in tha ABI header files:


.nf
   #include "somelib_export.h"
   class SOMELIB_EXPORT SomeClass {
     ...
   };
.fi




Da CMake fragment will generate a gangbangin' file up in tha ${CMAKE_CURRENT_BINARY_DIR} called somelib_export.h containin tha macros SOMELIB_EXPORT, SOMELIB_NO_EXPORT, SOMELIB_DEPRECATED, SOMELIB_DEPRECATED_EXPORT n' SOMELIB_DEPRECATED_NO_EXPORT. Da resultin file should be installed wit other headaz up in tha library.


Da BASE_NAME argument can be used ta override tha file name n' tha names used fo' tha macros


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     BASE_NAME other_name
   )
.fi




Generates a gangbangin' file called other_name_export.h containin tha macros OTHER_NAME_EXPORT, OTHER_NAME_NO_EXPORT n' OTHER_NAME_DEPRECATED etc.


Da BASE_NAME may be overridden by specifiyin other options up in tha function. I aint talkin' bout chicken n' gravy biatch. For example:


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     EXPORT_MACRO_NAME OTHER_NAME_EXPORT
   )
.fi




creates tha macro OTHER_NAME_EXPORT instead of SOMELIB_EXPORT yo, but other macros n' tha generated file name be as default.


.nf
   add_library(somelib someclass.cpp)
   generate_export_header(somelib
     DEPRECATED_MACRO_NAME KDE_DEPRECATED
   )
.fi




creates tha macro KDE_DEPRECATED instead of SOMELIB_DEPRECATED.


If LIBRARY_TARGET be a static library, macros is defined without joints.


If tha same sources is used ta create both a gangbangin' finger-lickin' dirty-ass shared n' a static library, tha uppercased symbol ${BASE_NAME}_STATIC_DEFINE should be used when buildin tha static library


.nf
   add_library(shared_variant SHARED ${lib_SRCS})
   add_library(static_variant ${lib_SRCS})
   generate_export_header(shared_variant BASE_NAME libshared_and_static)
   set_target_properties(static_variant PROPERTIES
     COMPILE_FLAGS \-DLIBSHARED_AND_STATIC_STATIC_DEFINE)
.fi




This will cause tha export macros ta expand ta not a god damn thang when buildin tha static library.


If DEFINE_NO_DEPRECATED is specified, then a macro ${BASE_NAME}_NO_DEPRECATED is ghon be defined This macro can be used ta remove deprecated code from preprocessor output.


.nf
   option(EXCLUDE_DEPRECATED "Exclude deprecated partz of tha library" FALSE)
   if (EXCLUDE_DEPRECATED)
     set(NO_BUILD_DEPRECATED DEFINE_NO_DEPRECATED)
   endif()
   generate_export_header(somelib ${NO_BUILD_DEPRECATED})
.fi




And then up in somelib:


.nf
   class SOMELIB_EXPORT SomeClass
   {
   public:
   #ifndef SOMELIB_NO_DEPRECATED
     SOMELIB_DEPRECATED void oldMethod();
   #endif
   };
.fi




.nf
   #ifndef SOMELIB_NO_DEPRECATED
   void SomeClass::oldMethod() {  }
   #endif
.fi




If PREFIX_NAME is specified, tha argument is ghon be used as a prefix ta all generated macros.


For example:


.nf
   generate_export_header(somelib PREFIX_NAME VTK_)
.fi




Generates tha macros VTK_SOMELIB_EXPORT etc.

.TP
.B GetPrerequisites
Functions ta analyze n' list executable file prerequisites.

This module serves up functions ta list tha .dll, .dylib or .so filez dat a executable or shared library file dependz on. I aint talkin' bout chicken n' gravy biatch. (Its prerequisites.)


It uses various tools ta obtain tha list of required shared library files:


.nf
   dumpbin (Windows)
   objdump (MinGW on Windows)
   ldd (Linux/Unix)
   otool (Mac OSX)
.fi

Da followin functions is provided by dis module:


.nf
   get_prerequisites
   list_prerequisites
   list_prerequisites_by_glob
   gp_append_unique
   is_file_executable
   gp_item_default_embedded_path
     (projects can override wit gp_item_default_embedded_path_override)
   gp_resolve_item
     (projects can override wit gp_resolve_item_override)
   gp_resolved_file_type
     (projects can override wit gp_resolved_file_type_override)
   gp_file_type
.fi

Requires CMake 2.6 or pimped outa cuz it uses function, break, return n' PARENT_SCOPE.


.nf
  GET_PREREQUISITES(<target> <prerequisites_var> <exclude_system> <recurse>
                    <exepath> <dirs>)
.fi

Git tha list of shared library filez required by <target>. Da list up in tha variable named <prerequisites_var> should be empty on first entry ta dis function. I aint talkin' bout chicken n' gravy biatch. On exit, <prerequisites_var> will contain tha list of required shared library files.


<target> is tha full path ta a executable file. <prerequisites_var> is tha name of a CMake variable ta contain tha thangs up in dis biatch. <exclude_system> must be 0 or 1 indicatin whether ta include or exclude "system" prerequisites. If <recurse> is set ta 1 all prerequisites is ghon be found recursively, if set ta 0 only direct prerequisites is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. <exepath> is tha path ta tha top level executable used fo' @executable_path replacment on tha Mac. <dirs> be a list of paths where libraries might be found: these paths is searched first when a target without any path info is given. I aint talkin' bout chicken n' gravy biatch. Then standard system locations is also searched: PATH, Framework locations, /usr/lib...


.nf
  LIST_PREREQUISITES(<target> [<recurse> [<exclude_system> [<verbose>]]])
.fi

Print a message listin tha prerequisitez of <target>.


<target> is tha name of a gangbangin' finger-lickin' dirty-ass shared library or executable target or tha full path ta a gangbangin' finger-lickin' dirty-ass shared library or executable file. If <recurse> is set ta 1 all prerequisites is ghon be found recursively, if set ta 0 only direct prerequisites is listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. <exclude_system> must be 0 or 1 indicatin whether ta include or exclude "system" prerequisites. With <verbose> set ta 0 only tha full path namez of tha prerequisites is printed, set ta 1 extra informatin is ghon be displayed.


.nf
  LIST_PREREQUISITES_BY_GLOB(<glob_arg> <glob_exp>)
.fi

Print tha prerequisitez of shared library n' executable filez matchin a globbin pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. <glob_arg> is GLOB or GLOB_RECURSE n' <glob_exp> be a globbin expression used wit "file(GLOB" or "file(GLOB_RECURSE" ta retrieve a list of matchin files. If a matchin file is executable, its prerequisites is listed.


Any additionizzle (optional) arguments provided is passed along as tha optionizzle arguments ta tha list_prerequisites calls.


.nf
  GP_APPEND_UNIQUE(<list_var> <value>)
.fi

Append <value> ta tha list variable <list_var> only if tha value aint already up in tha list.


.nf
  IS_FILE_EXECUTABLE(<file> <result_var>)
.fi

Return 1 up in <result_var> if <file> be a funky-ass binary executable, 0 otherwise.


.nf
  GP_ITEM_DEFAULT_EMBEDDED_PATH(<item> <default_embedded_path_var>)
.fi

Return tha path dat others should refer ta tha item by when tha item is embedded inside a funky-ass bundle.


Override on a per\-project basis by providin a project\-specific gp_item_default_embedded_path_override function.


.nf
  GP_RESOLVE_ITEM(<context> <item> <exepath> <dirs> <resolved_item_var>)
.fi

Resolve a item tha fuck into a existin full path file.


Override on a per\-project basis by providin a project\-specific gp_resolve_item_override function.


.nf
  GP_RESOLVED_FILE_TYPE(<original_file> <file> <exepath> <dirs> <type_var>)
.fi

Return tha type of <file> wit respect ta <original_file>. Right back up in yo muthafuckin ass. Strin describin type of prerequisite is returned up in variable named <type_var>.


Use <exepath> n' <dirs> if necessary ta resolve non\-absolute <file> joints \-\- but only fo' non\-embedded items.


Possible types are:


.nf
   system
   local
   embedded
   other
.fi

Override on a per\-project basis by providin a project\-specific gp_resolved_file_type_override function.


.nf
  GP_FILE_TYPE(<original_file> <file> <type_var>)
.fi

Return tha type of <file> wit respect ta <original_file>. Right back up in yo muthafuckin ass. Strin describin type of prerequisite is returned up in variable named <type_var>.


Possible types are:


.nf
   system
   local
   embedded
   other
.fi

.TP
.B InstallRequiredSystemLibraries
.nf
 
.fi

By includin dis file, all library filez listed up in tha variable CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS is ghon be installed wit install(PROGRAMS ...) tha fuck into bin fo' WIN32 n' lib fo' non\-WIN32. If CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP is set ta TRUE before includin dis file, then tha INSTALL command aint called. Y'all KNOW dat shit, muthafucka! Da user can use tha variable CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS ta bust a cold-ass lil custom install command n' install dem however they want. If it is tha MSVC compiler, then tha microsizzlez run time libraries is ghon be found n' automatically added ta tha CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS, n' installed. Y'all KNOW dat shit, muthafucka! If CMAKE_INSTALL_DEBUG_LIBRARIES is set n' it is tha MSVC compiler, then tha debug libraries is installed when available. If CMAKE_INSTALL_DEBUG_LIBRARIES_ONLY is set then only tha debug libraries is installed when both debug n' release is available. If CMAKE_INSTALL_MFC_LIBRARIES is set then tha MFC run time libraries is installed as well as tha CRT run time libraries. Put ya muthafuckin choppers up if ya feel dis! If CMAKE_INSTALL_SYSTEM_RUNTIME_DESTINATION is set then tha libraries is installed ta dat directory rather than tha default. If CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS is NOT set, then dis file warns bout required filez dat do not exist. Yo ass can set dis variable ta ON before includin dis file ta avoid tha warning. For example, tha Visual Studio Express editions do not include tha redistributable files, so if you include dis file on a machine wit only VS Express installed, you gonna git tha warning.

.TP
.B MacroAddFileDependencies
MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...)

Usin tha macro MACRO_ADD_FILE_DEPENDENCIES() is discouraged. Y'all KNOW dat shit, muthafucka! There is probably betta ways ta specify tha erect dependencies.


MACRO_ADD_FILE_DEPENDENCIES(<_file> depend_files...) is just a cold-ass lil convenience wrapper round tha OBJECT_DEPENDS source file property. Yo ass can just use set_property(SOURCE <file> APPEND PROPERTY OBJECT_DEPENDS depend_files) instead.

.TP
.B ProcessorCount
ProcessorCount(var)

Determine tha number of processors/cores n' save value up in ${var}


Sets tha variable named ${var} ta tha number of physical cores available on tha machine if tha shiznit can be determined. Y'all KNOW dat shit, muthafucka! Otherwise it is set ta 0. Currently dis functionalitizzle is implemented fo' AIX, cygwin, FreeBSD, HPUX, IRIX, Linux, Mac OS X, QNX, Sun n' Windows.


This function is guaranteed ta return a positizzle integer (>=1) if it succeeds. Well shiiiit, it returns 0 if there be a a problem determinin tha processor count.


Example use, up in a cold-ass lil ctest \-S dashboard script:


.nf
   include(ProcessorCount)
   ProcessorCount(N)
   if(NOT N EQUAL 0)
     set(CTEST_BUILD_FLAGS \-j${N})
     set(ctest_test_args ${ctest_test_args} PARALLEL_LEVEL ${N})
   endif()
.fi




This function is intended ta offer a approximation of tha value of tha number of compute cores available on tha current machine, such dat you may use dat value fo' parallel buildin n' parallel testing. Well shiiiit, it is meant ta help utilize as much of tha machine as seems reasonable. Of course, knowledge of what tha fuck else might be hustlin on tha machine simultaneously should be used when decidin whether ta request a machinez full capacitizzle all fo' yo ass.

.TP
.B Qt4ConfigDependentSettings
.nf
 
.fi

This file is included by FindQt4.cmake, don't include it directly.

.TP
.B Qt4Macros
.nf
 
.fi

This file is included by FindQt4.cmake, don't include it directly.

.TP
.B SelectLibraryConfigurations
.nf
 
.fi

select_library_configurations( basename )


This macro takes a library base name as a argument, n' will chizzle phat joints fo' basename_LIBRARY, basename_LIBRARIES, basename_LIBRARY_DEBUG, n' basename_LIBRARY_RELEASE dependin on what tha fuck has been found n' set.  If only basename_LIBRARY_RELEASE is defined, basename_LIBRARY is ghon be set ta tha release value, n' basename_LIBRARY_DEBUG is ghon be set ta basename_LIBRARY_DEBUG\-NOTFOUND.  If only basename_LIBRARY_DEBUG is defined, then basename_LIBRARY will take tha debug value, n' basename_LIBRARY_RELEASE is ghon be set ta basename_LIBRARY_RELEASE\-NOTFOUND.


If tha generator supports configuration types, then basename_LIBRARY n' basename_LIBRARIES is ghon be set wit debug n' optimized flags specifyin tha library ta be used fo' tha given configuration. I aint talkin' bout chicken n' gravy biatch.  If no build type has been set or tha generator up in use do not support configuration types, then basename_LIBRARY n' basename_LIBRARIES will take only tha release value, or tha debug value if tha release one aint set.

.TP
.B SquishTestScript
.nf
 
.fi




This script launches a GUI test rockin Squish.  Yo ass should not call tha script directly; instead, you should access it via tha SQUISH_ADD_TEST macro dat is defined up in FindSquish.cmake.


This script starts tha Squish server, launches tha test on tha client, n' finally stops tha squish server n' shit.  If any of these steps fail (includin if tha tests do not pass) then a gangbangin' fatal error is raised.


.TP
.B TestBigEndian
Define macro ta determine endian type

Peep if tha system is big-ass endian or lil endian


.nf
  TEST_BIG_ENDIAN(VARIABLE)
  VARIABLE \- variable ta store tha result to
.fi




.TP
.B TestCXXAcceptsFlag
Test CXX compila fo' a gangbangin' flag

Peep if tha CXX compila accepts a gangbangin' flag


.nf
  Macro CHECK_CXX_ACCEPTS_FLAG(FLAGS VARIABLE) \-
     checks if tha function exists
  FLAGS \- tha flags ta try
  VARIABLE \- variable ta store tha result
.fi




.TP
.B TestForANSIForScope
Peep fo' ANSI fo' scope support

Peep if tha compila restricts tha scope of variablez declared up in a gangbangin' for\-init\-statement ta tha loop body.


.nf
  CMAKE_NO_ANSI_FOR_SCOPE \- holdz result
.fi




.TP
.B TestForANSIStreamHeaders
Test fo' compila support of ANSI stream headaz iostream, etc.

check if tha compila supports tha standard ANSI iostream header (without tha .h)


.nf
  CMAKE_NO_ANSI_STREAM_HEADERS \- defined by tha thangs up in dis biatch
.fi




.TP
.B TestForSSTREAM
Test fo' compila support of ANSI sstream header

check if tha compila supports tha standard ANSI sstream header


.nf
  CMAKE_NO_ANSI_STRING_STREAM \- defined by tha thangs up in dis biatch
.fi




.TP
.B TestForSTDNamespace
Test fo' std:: namespace support

check if tha compila supports std:: on stl classes


.nf
  CMAKE_NO_STD_NAMESPACE \- defined by tha thangs up in dis biatch
.fi




.TP
.B UseEcos
This module defines variablez n' macros required ta build eCos application.

This file gotz nuff tha followin macros: ECOS_ADD_INCLUDE_DIRECTORIES() \- add tha eCos include dirs ECOS_ADD_EXECUTABLE(name source1 ... sourceN ) \- create a eCos executable ECOS_ADJUST_DIRECTORY(VAR source1 ... sourceN ) \- adjusts tha path of tha source filez n' puts tha result tha fuck into VAR


Macros fo' selectin tha toolchain: ECOS_USE_ARM_ELF_TOOLS()       \- enable tha ARM ELF toolchain fo' tha directory where it is called ECOS_USE_I386_ELF_TOOLS()      \- enable tha i386 ELF toolchain fo' tha directory where it is called ECOS_USE_PPC_EABI_TOOLS()      \- enable tha PowerPC toolchain fo' tha directory where it is called


It gotz nuff tha followin variables: ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE               \- defaults ta ecos.ecc, if yo' eCos configuration file has a gangbangin' finger-lickin' different name, adjust dis variable fo' internal use only:


.nf
  ECOS_ADD_TARGET_LIB
.fi

.TP
.B UseJava
Use Module fo' Java

This file serves up functions fo' Java. Well shiiiit, it be assumed dat FindJava.cmake has already been loaded. Y'all KNOW dat shit, muthafucka!  See FindJava.cmake fo' shiznit on how tha fuck ta load Java tha fuck into yo' CMake project.


add_jar(target_name


.nf
         [SOURCES] source1 [source2 ...] [resource1 ...]
         [INCLUDE_JARS jar1 [jar2 ...]]
         [ENTRY_POINT entry]
         [VERSION version]
         [OUTPUT_NAME name]
         [OUTPUT_DIR dir]
        )
.fi




This command creates a <target_name>.jar. Shiiit, dis aint no joke. Well shiiiit, it compilez tha given source filez (source) n' addz tha given resource filez (resource) ta tha jar file. If only resource filez is given then just a jar file is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da list of include jars is added ta tha classpath when compilin tha java sources n' also ta tha dependenciez of tha target. INCLUDE_JARS also accepts other target names pimped by add_jar. Shiiit, dis aint no joke. For backwardz compatibility, jar filez listed as sources is ignored (as they done been since tha straight-up original gangsta version of dis module).


Da default OUTPUT_DIR can also be chizzled by settin tha variable CMAKE_JAVA_TARGET_OUTPUT_DIR.


Additionizzle instructions:


.nf
   To add compile flags ta tha target you can set these flags with
   tha followin variable:
.fi




.nf
       set(CMAKE_JAVA_COMPILE_FLAGS \-nowarn)
.fi




.nf
   To add a path or a jar file ta tha class path you can do this
   wit tha CMAKE_JAVA_INCLUDE_PATH variable.
.fi




.nf
       set(CMAKE_JAVA_INCLUDE_PATH /usr/share/java/shibboleet.jar)
.fi




.nf
   To bust a gangbangin' finger-lickin' different output name fo' tha target you can set it with:
.fi




.nf
       add_jar(foobar foobar.java OUTPUT_NAME shibboleet.jar)
.fi




.nf
   To bust a gangbangin' finger-lickin' different output directory than CMAKE_CURRENT_BINARY_DIR
   you can set it with:
.fi




.nf
       add_jar(foobar foobar.java OUTPUT_DIR ${PROJECT_BINARY_DIR}/bin)
.fi




.nf
   To define a entry point up in yo' jar you can set it wit tha ENTRY_POINT
   named argument:
.fi




.nf
       add_jar(example ENTRY_POINT com/examples/MyProject/Main)
.fi




.nf
   To add a VERSION ta tha target output name you can set it using
   tha VERSION named argument ta add_jar. Shiiit, dis aint no joke. This will create a jar file wit the
   name shibboleet\-1.0.0.jar n' will create a symlink shibboleet.jar
   pointin ta tha jar wit tha version shiznit.
.fi




.nf
       add_jar(shibboleet shibbotleet.java VERSION 1.2.0)
.fi




.nf
    If tha target be a JNI library, utilize tha followin commandz to
    create a JNI symbolic link:
.fi




.nf
       set(CMAKE_JNI_TARGET TRUE)
       add_jar(shibboleet shibbotleet.java VERSION 1.2.0)
       install_jar(shibboleet ${LIB_INSTALL_DIR}/shibboleet)
       install_jni_symlink(shibboleet ${JAVA_LIB_INSTALL_DIR})
.fi




.nf
    If a single target need ta produce mo' than one jar from its
    java source code, ta prevent tha accumulation of duplicate class
    filez up in subsequent jars, set/reset CMAKE_JAR_CLASSES_PREFIX prior
    ta callin tha add_jar() function:
.fi




.nf
       set(CMAKE_JAR_CLASSES_PREFIX com/redhat/foo)
       add_jar(foo foo.java)
.fi




.nf
       set(CMAKE_JAR_CLASSES_PREFIX com/redhat/bar)
       add_jar(bar bar.java)
.fi




Target Properties:


.nf
   Da add_jar() functions sets some target properties. Put ya muthafuckin choppers up if ya feel dis! Yo ass can git these
   propertizzles wit the
      get_property(TARGET <target_name> PROPERTY <propery_name>)
   command.
.fi




.nf
   INSTALL_FILES      Da filez which should be installed. Y'all KNOW dat shit, muthafucka! This is used by
                      install_jar().
   JNI_SYMLINK        Da JNI symlink which should be installed.
                      This is used by install_jni_symlink().
   JAR_FILE           Da location of tha jar file so dat you can include
                      dat shit.
   CLASS_DIR          Da directory where tha class filez can be found. Y'all KNOW dat shit, muthafucka! For
                      example ta use dem wit javah.
.fi




find_jar(<VAR>


.nf
          name | NAMES name1 [name2 ...]
          [PATHS path1 [path2 ... ENV var]]
          [VERSIONS version1 [version2]]
          [DOC "cache documentation string"]
         )
.fi




This command is used ta find a gangbangin' full path ta tha named jar fo' realz. A cache entry named by <VAR> is pimped ta stor tha result of dis command. Y'all KNOW dat shit, muthafucka! If tha full path ta a jar is found tha result is stored up in tha variable n' tha search aint gonna repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka! If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again next time find_jar is invoked wit tha same variable. Da name of tha full path ta a gangbangin' file dat is searched fo' is specified by tha names listed afta NAMES argument fo' realz. Additionizzle search locations can be specified afta tha PATHS argument. If you require special a version of a jar file you can specify it wit tha VERSIONS argument. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.


install_jar(TARGET_NAME DESTINATION)


This command installs tha TARGET_NAME filez ta tha given DESTINATION. Well shiiiit, it should be called up in tha same scope as add_jar() or it will fail.


install_jni_symlink(TARGET_NAME DESTINATION)


This command installs tha TARGET_NAME JNI symlinks ta tha given DESTINATION. Well shiiiit, it should be called up in tha same scope as add_jar() or it will fail.


create_javadoc(<VAR>


.nf
                PACKAGES pkg1 [pkg2 ...]
                [SOURCEPATH <sourcepath>]
                [CLASSPATH <classpath>]
                [INSTALLPATH <install path>]
                [DOCTITLE "the documentation title"]
                [WINDOWTITLE "the title of tha document"]
                [AUTHOR TRUE|FALSE]
                [USE TRUE|FALSE]
                [VERSION TRUE|FALSE]
               )
.fi




Smoke java documentation based on filez or packages. For mo' details please read tha javadoc manpage.


There is two main signatures fo' create_javadoc. Da first signature works wit package names on a path wit source files:


.nf
   Example:
   create_javadoc(my_example_doc
     PACKAGES com.exmaple.foo com.example.bar
     SOURCEPATH "${CMAKE_CURRENT_SOURCE_DIR}"
     CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH}
     WINDOWTITLE "My fuckin example"
     DOCTITLE "<h1>I be a gangsta yo, but y'all knew dat n' mah example</h1>"
     AUTHOR TRUE
     USE TRUE
     VERSION TRUE
   )
.fi




Da second signature fo' create_javadoc works on a given list of files.


.nf
   create_javadoc(<VAR>
                  FILES file1 [file2 ...]
                  [CLASSPATH <classpath>]
                  [INSTALLPATH <install path>]
                  [DOCTITLE "the documentation title"]
                  [WINDOWTITLE "the title of tha document"]
                  [AUTHOR TRUE|FALSE]
                  [USE TRUE|FALSE]
                  [VERSION TRUE|FALSE]
                 )
.fi




Example:


.nf
   create_javadoc(my_example_doc
     FILES ${example_SRCS}
     CLASSPATH ${CMAKE_JAVA_INCLUDE_PATH}
     WINDOWTITLE "My fuckin example"
     DOCTITLE "<h1>I be a gangsta yo, but y'all knew dat n' mah example</h1>"
     AUTHOR TRUE
     USE TRUE
     VERSION TRUE
   )
.fi




Both signatures share most of tha options. These options is tha same as what tha fuck you can find up in tha javadoc manpage. Please peep tha manpage fo' CLASSPATH, DOCTITLE, WINDOWTITLE, AUTHOR, USE n' VERSION.


Da documentation is ghon be by default installed to


.nf
   ${CMAKE_INSTALL_PREFIX}/share/javadoc/<VAR>
.fi




if you don't set tha INSTALLPATH.


.TP
.B UseJavaClassFilelist
.nf
 
.fi




This script create a list of compiled Java class filez ta be added ta a jar file. This avoidz includin cmake filez which git pimped up in tha binary directory.


.TP
.B UseJavaSymlinks
.nf
 
.fi




Helper script fo' UseJava.cmake


.TP
.B UsePkgConfig
Obsolete pkg\-config module fo' CMake, use FindPkgConfig instead.




This module defines tha followin macro:


PKGCONFIG(package includedir libdir linkflags cflags)


Callin PKGCONFIG will fill tha desired shiznit tha fuck into tha 4 given arguments, e.g. PKGCONFIG(libart\-2.0 LIBART_INCLUDE_DIR LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS) if pkg\-config was NOT found or tha specified software package don't exist, tha variable is ghon be empty when tha function returns, otherwise they will contain tha respectizzle shiznit


.TP
.B UseQt4
Use Module fo' QT4

Sets up C n' C++ ta use Qt 4.  It be assumed dat FindQt.cmake has already been loaded. Y'all KNOW dat shit, muthafucka!  See FindQt.cmake fo' shiznit on how tha fuck ta load Qt 4 tha fuck into yo' CMake project.

.TP
.B UseSWIG
SWIG module fo' CMake

Defines tha followin macros:


.nf
   SWIG_ADD_MODULE(name language [ filez ])
     \- Define swig module wit given name n' specified language
   SWIG_LINK_LIBRARIES(name [ libraries ])
     \- Link libraries ta swig module
.fi

All other macros is fo' internal use only. To git tha actual name of tha swig module, use: ${SWIG_MODULE_${name}_REAL_NAME}. Right back up in yo muthafuckin ass. Set Source filez propertizzles like fuckin CPLUSPLUS n' SWIG_FLAGS ta specify special behavior of SWIG fo' realz. Also global CMAKE_SWIG_FLAGS can be used ta add special flags ta all swig calls fo' realz. Another special variable is CMAKE_SWIG_OUTDIR, it allows one ta specify where ta write all tha swig generated module (swig \-outdir option) Da name\-specific variable SWIG_MODULE_<name>_EXTRA_DEPS may be used ta specify extra dependencies fo' tha generated modules. If tha source file generated by swig need some special flag you can use set_source_files_properties( ${swig_generated_file_fullname}


.nf
        PROPERTIES COMPILE_FLAGS "\-bla")
.fi

.TP
.B Use_wxWindows
\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-




This convenience include findz if wxWindows is installed n' set tha appropriate libs, incdirs, flags etc. lyricist Jan Woetzel <jw \-at\- mip.informatik.uni\-kiel.de> (07/2003) USAGE:


.nf
   just include Use_wxWindows.cmake
   up in yo' projects CMakeLists.txt
.fi

include( ${CMAKE_MODULE_PATH}/Use_wxWindows.cmake)


.nf
   if yo ass is shizzle you need GL then
.fi

set(WXWINDOWS_USE_GL 1)


.nf
   *before* you include dis file.
.fi

.TP
.B UsewxWidgets
Convenience include fo' rockin wxWidgets library.

Determines if wxWidgets was FOUND n' sets tha appropriate libs, incdirs, flags, etc. INCLUDE_DIRECTORIES n' LINK_DIRECTORIES is called.


USAGE


.nf
  # Note dat fo' MinGW playas tha order of libs is blingin!
  find_package(wxWidgets REQUIRED net gl core base)
  include(${wxWidgets_USE_FILE})
  # n' fo' each of yo' dependent executable/library targets:
  target_link_libraries(<YourTarget> ${wxWidgets_LIBRARIES})
.fi




DEPRECATED


.nf
  LINK_LIBRARIES aint called up in favor of addin dependencies per target.
.fi




AUTHOR


.nf
  Jan Woetzel <jw \-at\- mip.informatik.uni\-kiel.de>
.fi

.TP
.B WriteBasicConfigVersionFile
.nf
 
.fi

.nf
  WRITE_BASIC_CONFIG_VERSION_FILE( filename VERSION major.minor.patch COMPATIBILITY (AnyNewerVersion|SameMajorVersion) )
.fi




Deprecated, peep WRITE_BASIC_PACKAGE_VERSION_FILE(), it is identical.

.SH COPYRIGHT
.PP
Copyright 2000\-2012 Kitware, Inc., Insight Software Consortium.  All muthafuckin rights reserved.

.PP
Redistribution n' use up in source n' binary forms, wit or without modification, is permitted provided dat tha followin conditions is met:

.PP
Redistributionz of source code must retain tha above copyright notice, dis list of conditions n' tha followin disclaimer.

.PP
Redistributions up in binary form must reproduce tha above copyright notice, dis list of conditions n' tha followin disclaimer up in tha documentation and/or other shiznit provided wit tha distribution.

.PP
Neither tha namez of Kitware, Inc., tha Insight Software Consortium, nor tha namez of they contributors may be used ta endorse or promote shizzle derived from dis software without specific prior freestyled permission.

.PP
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.SH SEE ALSO
.PP
.B ccmake(1), cpack(1), ctest(1), cmakecommands(1), cmakecompat(1), cmakemodules(1), cmakeprops(1), cmakevars(1)

.PP
Da followin resources is available ta git help rockin CMake:

.TP
.B Home Page
http://www.cmake.org

Da primary startin point fo' peepin' bout CMake.

.TP
.B Frequently Axed Questions
http://www.cmake.org/Wiki/CMake_FAQ

A Wiki is provided containin lyrics ta frequently axed thangs. 

.TP
.B Online Documentation
http://www.cmake.org/HTML/Documentation.html

Links ta available documentation may be found on dis wizzy page.

.TP
.B Mailin List
http://www.cmake.org/HTML/MailingLists.html

For help n' rap bout rockin cmake, a mailin list is provided at cmake@cmake.org. Da list is member\-post\-only but one may sign up on tha CMake wizzy page. Please first read tha full documentation at http://www.cmake.org before postin thangs ta tha list.

