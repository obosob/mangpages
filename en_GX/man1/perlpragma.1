.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPRAGMA 1"
.TH PERLPRAGMA 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpragma \- how tha fuck ta write a user pragma
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A pragma be a module which influences some aspect of tha compile time or run
time behaviour of Perl, like fuckin \f(CW\*(C`strict\*(C'\fR or \f(CW\*(C`warnings\*(C'\fR. With Perl 5.10 you
are no longer limited ta tha built up in pragmata; you can now create user
pragmata dat modify tha behaviour of user functions within a lexical scope.
.SH "A basic example"
.IX Header "A basic example"
For example, say you need ta create a cold-ass lil class implementin overloaded
mathematical operators, n' wanna provide yo' own pragma that
functions much like \f(CW\*(C`use integer;\*(C'\fR You'd like dis code
.PP
.Vb 1
\&    use MyMaths;
\&
\&    mah $l = MyMaths\->new(1.2);
\&    mah $r = MyMaths\->new(3.4);
\&
\&    print "A: ", $l + $r, "\en";
\&
\&    use myint;
\&    print "B: ", $l + $r, "\en";
\&
\&    {
\&        no myint;
\&        print "C: ", $l + $r, "\en";
\&    }
\&
\&    print "D: ", $l + $r, "\en";
\&
\&    no myint;
\&    print "E: ", $l + $r, "\en";
.Ve
.PP
to give tha output
.PP
.Vb 5
\&    A: 4.6
\&    B: 4
\&    C: 4.6
\&    D: 4
\&    E: 4.6
.Ve
.PP
\&\fIi.e.\fR, where \f(CW\*(C`use myint;\*(C'\fR is up in effect, addizzle operations is forced
to integer, whereas by default they is not, wit tha default behaviour being
restored via \f(CW\*(C`no myint;\*(C'\fR
.PP
Da minimal implementation of tha package \f(CW\*(C`MyMaths\*(C'\fR would be suttin' like
this:
.PP
.Vb 10
\&    package MyMaths;
\&    use warnings;
\&    use strict;
\&    use myint();
\&    use overload \*(Aq+\*(Aq => sub {
\&        mah ($l, $r) = @_;
\&        # Pass 1 ta check up one call level from here
\&        if (myint::in_effect(1)) {
\&            int($$l) + int($$r);
\&        } else {
\&            $$l + $$r;
\&        }
\&    };
\&
\&    sub freshly smoked up {
\&        mah ($class, $value) = @_;
\&        bless \e$value, $class;
\&    }
\&
\&    1;
.Ve
.PP
Note how tha fuck our slick asses load tha user pragma \f(CW\*(C`myint\*(C'\fR wit a empty list \f(CW\*(C`()\*(C'\fR to
prevent its \f(CW\*(C`import\*(C'\fR bein called.
.PP
Da interaction wit tha Perl compilation happens inside package \f(CW\*(C`myint\*(C'\fR:
.PP
.Vb 1
\&    package myint;
\&
\&    use strict;
\&    use warnings;
\&
\&    sub import {
\&        $^H{"myint/in_effect"} = 1;
\&    }
\&
\&    sub unimport {
\&        $^H{"myint/in_effect"} = 0;
\&    }
\&
\&    sub in_effect {
\&        mah $level = shift // 0;
\&        mah $hinthash = (caller($level))[10];
\&        return $hinthash\->{"myint/in_effect"};
\&    }
\&
\&    1;
.Ve
.PP
As pragmata is implemented as modules, like any other module, \f(CW\*(C`use myint;\*(C'\fR
becomes
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->import();
\&    }
.Ve
.PP
and \f(CW\*(C`no myint;\*(C'\fR is
.PP
.Vb 4
\&    BEGIN {
\&        require myint;
\&        myint\->unimport();
\&    }
.Ve
.PP
Hence tha \f(CW\*(C`import\*(C'\fR n' \f(CW\*(C`unimport\*(C'\fR routines is called at \fBcompile time\fR
for tha userz code.
.PP
User pragmata store they state by freestylin ta tha magical hash \f(CW\*(C`%^H\*(C'\fR,
hence these two routines manipulate dat shit. Da state shiznit up in \f(CW\*(C`%^H\*(C'\fR is
stored up in tha optree, n' can be retrieved read-only at runtime wit \f(CW\*(C`caller()\*(C'\fR,
at index 10 of tha list of returned thangs up in dis biatch. In tha example pragma, retrieval
is encapsulated tha fuck into tha routine \f(CW\*(C`in_effect()\*(C'\fR, which takes as parameter
the number of call frames ta go up ta find tha value of tha pragma up in the
userz script. This uses \f(CW\*(C`caller()\*(C'\fR ta determine tha value of
\&\f(CW$^H{"myint/in_effect"}\fR when each line of tha userz script was called, and
therefore provide tha erect semantics up in tha subroutine implementin the
overloaded addition.
.SH "Key naming"
.IX Header "Key naming"
There is only a single \f(CW\*(C`%^H\*(C'\fR yo, but arbitrarily nuff modulez dat want
to use its scopin semantics.  To avoid steppin on each otherz toes,
they need ta be shizzle ta use different keys up in tha hash.  It be therefore
conventionizzle fo' a module ta use only keys dat begin wit tha module's
name (the name of its main package) n' a \*(L"/\*(R" character n' shit.  Afta this
module-identifyin prefix, tha rest of tha key is entirely up ta the
module: it may include any charactas whatsoever n' shit.  For example, a module
\&\f(CW\*(C`Foo::Bar\*(C'\fR should use keys like fuckin \f(CW\*(C`Foo::Bar/baz\*(C'\fR n' \f(CW\*(C`Foo::Bar/$%/_!\*(C'\fR.
Modulez followin dis convention all play sickly wit each other.
.PP
Da Perl core uses a handful of keys up in \f(CW\*(C`%^H\*(C'\fR which do not follow this
convention, cuz they predate dat shit.  Keys dat follow tha convention
won't conflict wit tha corez oldschool keys.
.SH "Implementation details"
.IX Header "Implementation details"
Da optree is shared between threads.  This means there be a possibilitizzle that
the optree will outlive tha particular thread (and therefore tha interpreter
instance) dat pimped it, so legit Perl scalars cannot be stored up in the
optree.  Instead a cold-ass lil compact form is used, which can only store joints dat are
integers (signed n' unsigned), strings or \f(CW\*(C`undef\*(C'\fR \- references and
floatin point joints is stringified. Y'all KNOW dat shit, muthafucka!  If you need ta store multiple joints
or complex structures, you should serialise them, fo' example wit \f(CW\*(C`pack\*(C'\fR.
Da deletion of a hash key from \f(CW\*(C`%^H\*(C'\fR is recorded, n' as eva can be
distinguished from tha existence of a key wit value \f(CW\*(C`undef\*(C'\fR with
\&\f(CW\*(C`exists\*(C'\fR.
.PP
\&\fBDon't\fR attempt ta store references ta data structures as integers which
are retrieved via \f(CW\*(C`caller\*(C'\fR n' converted back, as dis aint gonna be threadsafe.
Accesses would be ta tha structure without lockin (which aint safe for
Perlz scalars), n' either tha structure has ta leak, or it has ta be
freed when its bustin thread terminates, which may be before tha optree
referencin it is deleted, if other threadz outlive dat shit.
