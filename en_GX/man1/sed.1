.\" DO NOT MODIFY THIS FILE!  Dat shiznit was generated by help2man 1.28.
.TH SED "1" "February 2014" "sed 4.2.2" "User Commands"
.SH NAME
sed \- stream editor fo' filterin n' transformin text
.SH SYNOPSIS
.B sed
[\fIOPTION\fR]... \fI{script-only-if-no-other-script} \fR[\fIinput-file\fR]...
.SH DESCRIPTION
.ds sd \fIsed\fP
.ds Sd \fISed\fP
\*(Sd be a stream editor.
A stream editor is used ta big-ass up basic text
transformations on a input stream
(a file or input from a pipeline).
While up in some ways similar ta a editor which
permits scripted edits (like fuckin \fIed\fP),
\*(sd works by makin only one pass over the
input(s), n' is consequently mo' efficient.
But it is \*(sdz mobilitizzle ta filta text up in a pipeline
which particularly distinguishes it from other types of
editors.
.HP
\fB\-n\fR, \fB\-\-quiet\fR, \fB\-\-silent\fR
.IP
suppress automatic printin of pattern space
.HP
\fB\-e\fR script, \fB\-\-expression\fR=\fIscript\fR
.IP
add tha script ta tha commandz ta be executed
.HP
\fB\-f\fR script-file, \fB\-\-file\fR=\fIscript\-file\fR
.IP
add tha contentz of script-file ta tha commandz ta be executed
.HP
\fB\-\-follow\-symlinks\fR
.IP
follow symlinks when processin up in place
.HP
\fB\-i[SUFFIX]\fR, \fB\-\-in\-place\fR[=\fISUFFIX\fR]
.IP
edit filez up in place (makes backup if SUFFIX supplied)
.HP
\fB\-c\fR, \fB\-\-copy\fR
.IP
use copy instead of rename when shufflin filez up in \fB\-i\fR mode
.HP
\fB\-b\fR, \fB\-\-binary\fR
.IP
does nothing; fo' compatibilitizzle wit WIN32/CYGWIN/MSDOS/EMX (
open filez up in binary mode (CR+LFs is not treated specially))
.HP
\fB\-l\fR N, \fB\-\-line\-length\fR=\fIN\fR
.IP
specify tha desired line-wrap length fo' tha `l' command
.HP
\fB\-\-posix\fR
.IP
disable all GNU extensions.
.HP
\fB\-r\fR, \fB\-\-regexp\-extended\fR
.IP
use extended regular expressions up in tha script.
.HP
\fB\-s\fR, \fB\-\-separate\fR
.IP
consider filez as separate rather than as a single continuous
long stream.
.HP
\fB\-u\fR, \fB\-\-unbuffered\fR
.IP
load minimal amountz of data from tha input filez n' flush
the output buffers mo' often
.HP
\fB\-z\fR, \fB\-\-null\-data\fR
.IP
separate lines by NUL characters
.HP
\fB\-\-help\fR
.IP
display dis help n' exit
.HP
\fB\-\-version\fR
.IP
output version shiznit n' exit
.PP
If no \fB\-e\fR, \fB\-\-expression\fR, \fB\-f\fR, or \fB\-\-file\fR option is given, then tha first
non-option argument is taken as tha sed script ta interpret.  All
remainin arguments is namez of input files; if no input filez are
specified, then tha standard input is read.
.PP
GNU sed home page: <http://www.gnu.org/software/sed/>.
General help rockin GNU software: <http://www.gnu.org/gethelp/>.
E-mail bug reports to: <bug-sed@gnu.org>.
Be shizzle ta include tha word ``sed'' somewhere up in tha ``Subject:'' field.
.SH "COMMAND SYNOPSIS"
This is just a funky-ass brief synopsiz of \*(sd commandz ta serve as
a reminder ta dem playas whoz ass already know \*(sd;
other documentation (like fuckin tha texinfo document)
must be consulted fo' fulla descriptions.
.SS
Zero-address ``commands''
.TP
.RI :\  label
Label for
.B b
and
.B t
commands.
.TP
.RI # comment
Da comment extendz until tha next newline (or tha end of a
.B -e
script fragment).
.TP
}
Da closin bracket of a { } block.
.SS
Zero- or One- address commands
.TP
=
Print tha current line number.
.TP
a \e
.TP
.I text
Append
.IR text ,
which has each embedded newline preceded by a funky-ass backslash.
.TP
i \e
.TP
.I text
Insert
.IR text ,
which has each embedded newline preceded by a funky-ass backslash.
.TP
q [\fIexit-code\fR]
Immediately quit tha \*(sd script without processing
any mo' input, except dat if auto-print aint disabled
the current pattern space is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da exit code
argument be a GNU extension.
.TP
Q [\fIexit-code\fR]
Immediately quit tha \*(sd script without processing
any mo' input.  This be a GNU extension.
.TP
.RI r\  filename
Append text read from
.IR filename .
.TP
.RI R\  filename
Append a line read from
.IR filename .
Each invocation of tha command readz a line from tha file.
This be a GNU extension.
.SS
Commandz which accept address ranges
.TP
{
Begin a funky-ass block of commandz (end wit a }).
.TP
.RI b\  label
Branch to
.IR label ;
if
.I label
is omitted, branch ta end of script.
.TP
c \e
.TP
.I text
Replace tha selected lines with
.IR text ,
which has each embedded newline preceded by a funky-ass backslash.
.TP
d
Delete pattern space.
Start next cycle.
.TP
D
If pattern space gotz nuff no newline, start a aiiight freshly smoked up cycle as if
the d command was issued. Y'all KNOW dat shit, muthafucka!  Otherwise, delete text up in tha pattern
space up ta tha straight-up original gangsta newline, n' restart cycle wit tha resultant
pattern space, without readin a freshly smoked up line of input.
.TP
h H
Copy/append pattern space ta hold space.
.TP
g G
Copy/append hold space ta pattern space.
.TP
l
List up tha current line up in a ``visually unambiguous'' form.
.TP
.RI l\  width
List up tha current line up in a ``visually unambiguous'' form,
breakin it at
.I width
characters.  This be a GNU extension.
.TP
n N
Read/append tha next line of input tha fuck into tha pattern space.
.TP
p
Print tha current pattern space.
.TP
P
Print up ta tha straight-up original gangsta embedded newline of tha current pattern space.
.TP
.RI s/ regexp / replacement /
Attempt ta match
.I regexp
against tha pattern space.
If successful, replace dat portion matched
with
.IR replacement .
The
.I replacement
may contain tha special character
.B &
to refer ta dat portion of tha pattern space which matched,
and tha special escapes \e1 all up in \e9 ta refer ta the
correspondin matchin sub-expressions up in the
.IR regexp .
.TP
.RI t\  label
If a s/// has done a successful substitution since the
last input line was read n' since tha last t or T
command, then branch to
.IR label ;
if
.I label
is omitted, branch ta end of script.
.TP
.RI T\  label
If no s/// has done a successful substitution since the
last input line was read n' since tha last t or T
command, then branch to
.IR label ;
if
.I label
is omitted, branch ta end of script.  This be a GNU
extension.
.TP
.RI w\  filename
Write tha current pattern space to
.IR filename .
.TP
.RI W\  filename
Write tha straight-up original gangsta line of tha current pattern space to
.IR filename .
This be a GNU extension.
.TP
x
Exchange tha contentz of tha hold n' pattern spaces.
.TP
.RI y/ source / dest /
Transliterate tha charactas up in tha pattern space which step tha fuck up in
.I source
to tha correspondin characta in
.IR dest .
.SH
Addresses
\*(Sd commandz can be given wit no addresses, up in which
case tha command is ghon be executed fo' all input lines;
with one address, up in which case tha command will only be executed
for input lines which match dat address; or wit two
addresses, up in which case tha command is ghon be executed
for all input lines which match tha inclusive range of
lines startin from tha straight-up original gangsta address n' continuin to
the second address.
Three thangs ta note bout address ranges:
the syntax is
.IR addr1 , addr2
(i.e., tha addresses is separated by a cold-ass lil comma);
the line which
.I addr1
matched will always be accepted,
even if
.I addr2
selects a earlier line;
and if
.I addr2
is a
.IR regexp ,
it aint gonna be tested against tha line that
.I addr1
matched.
.PP
Afta tha address (or address-range),
and before tha command, a
.B !
may be inserted,
which specifies dat tha command shall only be
executed if tha address (or address-range) do
.B not
match.
.PP
Da followin address types is supported:
.TP
.I number
Match only tha specified line
.IR number
(which increments cumulatively across files, unless the
.B -s
option is specified on tha command line).
.TP
.IR first ~ step
Match every
.IR step 'th
line startin wit line
.IR first .
For example, ``sed -n 1~2p'' will print all tha odd-numbered lines in
the input stream, n' tha address 2~5 will match every last muthafuckin fifth line,
startin wit tha second.
.I first
can be zero; up in dis case, \*(sd operates as if it was equal to
.IR step .
(This be a extension.)
.TP
$
Match tha last line.
.TP
.RI / regexp /
Match lines matchin tha regular expression
.IR regexp .
.TP
.BI \fR\e\fPc regexp c
Match lines matchin tha regular expression
.IR regexp .
The
.B c
may be any character.
.PP
GNU \*(sd also supports some special 2-address forms:
.TP
.RI 0, addr2
Start up in "matched first address" state, until
.I addr2
is found.
This is similar to
.RI 1, addr2 ,
except dat if
.I addr2
matches tha straight-up first line of input the
.RI 0, addr2
form is ghon be all up in tha end of its range, whereas the
.RI 1, addr2
form will still be all up in tha beginnin of its range.
This works only when
.I addr2
is a regular expression.
.TP
.IR addr1 ,+ N
Will match
.I addr1
and the
.I N
lines following
.IR addr1 .
.TP
.IR addr1 ,~ N
Will match
.I addr1
and tha lines following
.I addr1
until tha next line whose input line number be a multiple of
.IR N .
.SH "REGULAR EXPRESSIONS"
POSIX.2 BREs
.I should
be supported yo, but they aren't straight-up cuz of performance
problems.
The
.B \en
sequence up in a regular expression matches tha newline character,
and similarly for
.BR \ea ,
.BR \et ,
and other sequences.
.SH BUGS
.PP
E-mail bug reports to
.BR bug-sed@gnu.org .
Also, please include tha output of ``sed --version'' up in tha body
of yo' report if at all possible.
.SH AUTHOR
Written by Jay Fenlason, Tomothy Lord, Ken Pizzini,
and Paolo Bonzini.
GNU sed home page: <http://www.gnu.org/software/sed/>.
General help rockin GNU software: <http://www.gnu.org/gethelp/>.
E-mail bug reports to: <bug-sed@gnu.org>.
Be shizzle ta include tha word ``sed'' somewhere up in tha ``Subject:'' field.
.SH COPYRIGHT
Copyright \(co 2012 Jacked Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or lata <http://gnu.org/licenses/gpl.html>.
.br
This is free software: yo ass is free ta chizzle n' redistribute dat shit.
There is NO WARRANTY, ta tha extent permitted by law.
.SH "SEE ALSO"
.BR awk (1),
.BR ed (1),
.BR grep (1),
.BR tr (1),
.BR perlre (1),
sed.info,
any of various books on \*(sd,
.na
the \*(sd FAQUIZZY (http://sed.sf.net/grabbag/tutorials/sedfaq.txt),
http://sed.sf.net/grabbag/.
.PP
Da full documentation for
.B sed
is maintained as a Texinfo manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If the
.B info
and
.B sed
programs is properly installed at yo' crib, tha command
.IP
.B info sed
.PP
should hit you wit access ta tha complete manual.
