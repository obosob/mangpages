.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "QEMU-IMG 1"
.TH QEMU-IMG 1 "2014-12-09" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
qemu\-img \- QEMU disk image utility
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
usage: qemu-img command [command options]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
qemu-img allows you ta create, convert n' modify images offline. Well shiiiit, it can handle
all image formats supported by \s-1QEMU.\s0
.PP
\&\fBWarning:\fR Never use qemu-img ta modify images up in use by a hustlin virtual
machine or any other process; dis may destroy tha image fo' realz. Also, be aware that
queryin a image dat is bein modified by another process may encounter
inconsistent state.
.SH "OPTIONS"
.IX Header "OPTIONS"
Da followin commandz is supported:
.IP "\fBcheck [\-q] [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-r [leaks | all]]\fR \fIfilename\fR" 4
.IX Item "check [-q] [-f fmt] [--output=ofmt] [-r [leaks | all]] filename"
.PD 0
.IP "\fBcreate [\-q] [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
.IX Item "create [-q] [-f fmt] [-o options] filename [size]"
.IP "\fBcommit [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB]\fR \fIfilename\fR" 4
.IX Item "commit [-q] [-f fmt] [-t cache] filename"
.IP "\fBcompare [\-f\fR \fIfmt\fR\fB] [\-F\fR \fIfmt\fR\fB] [\-p] [\-q] [\-s]\fR \fIfilename1\fR\fB \fR\fIfilename2\fR" 4
.IX Item "compare [-f fmt] [-F fmt] [-p] [-q] [-s] filename1 filename2"
.IP "\fBconvert [\-c] [\-p] [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_name\fR\fB] [\-S\fR \fIsparse_size\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
.IX Item "convert [-c] [-p] [-q] [-f fmt] [-t cache] [-O output_fmt] [-o options] [-s snapshot_name] [-S sparse_size] filename [filename2 [...]] output_filename"
.IP "\fBinfo [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-\-backing\-chain]\fR \fIfilename\fR" 4
.IX Item "info [-f fmt] [--output=ofmt] [--backing-chain] filename"
.IP "\fBsnapshot [\-q] [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR\fB]\fR \fIfilename\fR" 4
.IX Item "snapshot [-q] [-l | -a snapshot | -c snapshot | -d snapshot] filename"
.IP "\fBrebase [\-q] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-p] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
.IX Item "rebase [-q] [-f fmt] [-t cache] [-p] [-u] -b backing_file [-F backing_fmt] filename"
.IP "\fBresize [\-q]\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
.IX Item "resize [-q] filename [+ | -]size"
.PD
.PP
Command parameters:
.IP "\fIfilename\fR" 4
.IX Item "filename"
.Vb 1
\& be a gangbangin' finger-lickin' disk image filename
.Ve
.IP "\fIfmt\fR" 4
.IX Item "fmt"
is tha disk image format. Well shiiiit, it is guessed automatically up in most cases. Right back up in yo muthafuckin ass. See below
for a thugged-out description of tha supported disk formats.
.IP "\fI\-\-backing\-chain\fR" 4
.IX Item "--backing-chain"
will enumerate shiznit bout backin filez up in a gangbangin' finger-lickin' disk image chain. I aint talkin' bout chicken n' gravy biatch. Refer
below fo' further description.
.IP "\fIsize\fR" 4
.IX Item "size"
is tha disk image size up in bytes. Optionizzle suffixes \f(CW\*(C`k\*(C'\fR or \f(CW\*(C`K\*(C'\fR
(kilobyte, 1024) \f(CW\*(C`M\*(C'\fR (megabyte, 1024k) n' \f(CW\*(C`G\*(C'\fR (gigabyte, 1024M)
and T (terabyte, 1024G) is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \f(CW\*(C`b\*(C'\fR is ignored.
.IP "\fIoutput_filename\fR" 4
.IX Item "output_filename"
is tha destination disk image filename
.IP "\fIoutput_fmt\fR" 4
.IX Item "output_fmt"
.Vb 1
\& is tha destination format
.Ve
.IP "\fIoptions\fR" 4
.IX Item "options"
is a cold-ass lil comma separated list of format specific options up in a
name=value format. Use \f(CW\*(C`\-o ?\*(C'\fR fo' a overview of tha options supported
by tha used format or peep tha format descriptions below fo' details.
.IP "\fI\-c\fR" 4
.IX Item "-c"
indicates dat target image must be compressed (qcow format only)
.IP "\fI\-h\fR" 4
.IX Item "-h"
with or without a cold-ass lil command shows help n' lists tha supported formats
.IP "\fI\-p\fR" 4
.IX Item "-p"
display progress bar (convert n' rebase commandz only)
.IP "\fI\-q\fR" 4
.IX Item "-q"
Quiet mode \- do not print any output (except errors). Therez no progress bar
in case both \fI\-q\fR n' \fI\-p\fR options is used.
.IP "\fI\-S\fR \fIsize\fR" 4
.IX Item "-S size"
indicates tha consecutizzle number of bytes dat must contain only zeros
for qemu-img ta create a sparse image durin conversion. I aint talkin' bout chicken n' gravy biatch. This value is rounded
down ta tha nearest 512 bytes. Yo ass may use tha common size suffixes like
\&\f(CW\*(C`k\*(C'\fR fo' kilobytes.
.IP "\fI\-t\fR \fIcache\fR" 4
.IX Item "-t cache"
specifies tha cache mode dat should be used wit tha (destination) file. Right back up in yo muthafuckin ass. See
the documentation of tha emulatorz \f(CW\*(C`\-drive cache=...\*(C'\fR option fo' allowed
values.
.PP
Parametas ta snapshot subcommand:
.IP "\fBsnapshot\fR" 4
.IX Item "snapshot"
is tha name of tha snapshot ta create, apply or delete
.IP "\fB\-a\fR" 4
.IX Item "-a"
applies a snapshot (revert disk ta saved state)
.IP "\fB\-c\fR" 4
.IX Item "-c"
creates a snapshot
.IP "\fB\-d\fR" 4
.IX Item "-d"
deletes a snapshot
.IP "\fB\-l\fR" 4
.IX Item "-l"
lists all snapshots up in tha given image
.PP
Parametas ta compare subcommand:
.IP "\fB\-f\fR" 4
.IX Item "-f"
First image format
.IP "\fB\-F\fR" 4
.IX Item "-F"
Second image format
.IP "\fB\-s\fR" 4
.IX Item "-s"
Strict mode \- fail on on different image size or sector allocation
.PP
Command description:
.IP "\fBcheck [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-r [leaks | all]]\fR \fIfilename\fR" 4
.IX Item "check [-f fmt] [--output=ofmt] [-r [leaks | all]] filename"
Perform a cold-ass lil consistency check on tha disk image \fIfilename\fR. Da command can
output up in tha format \fIofmt\fR which is either \f(CW\*(C`human\*(C'\fR or \f(CW\*(C`json\*(C'\fR.
.Sp
If \f(CW\*(C`\-r\*(C'\fR is specified, qemu-img tries ta repair any inconsistencies found
durin tha check. \f(CW\*(C`\-r leaks\*(C'\fR repairs only clusta leaks, whereas
\&\f(CW\*(C`\-r all\*(C'\fR fixes all kindz of errors, wit a higher risk of choosin the
wrong fix or hidin corruption dat has already occurred.
.Sp
Only tha formats \f(CW\*(C`qcow2\*(C'\fR, \f(CW\*(C`qed\*(C'\fR n' \f(CW\*(C`vdi\*(C'\fR support
consistency checks.
.IP "\fBcreate [\-f\fR \fIfmt\fR\fB] [\-o\fR \fIoptions\fR\fB]\fR \fIfilename\fR \fB[\fR\fIsize\fR\fB]\fR" 4
.IX Item "create [-f fmt] [-o options] filename [size]"
Smoke tha freshly smoked up disk image \fIfilename\fR of size \fIsize\fR n' format
\&\fIfmt\fR. Dependin on tha file format, you can add one or mo' \fIoptions\fR
that enable additionizzle featurez of dis format.
.Sp
If tha option \fIbacking_file\fR is specified, then tha image will record
only tha differences from \fIbacking_file\fR. No size need ta be specified in
this case. \fIbacking_file\fR aint NEVER gonna be modified unless you use the
\&\f(CW\*(C`commit\*(C'\fR monitor command (or qemu-img commit).
.Sp
Da size can also be specified rockin tha \fIsize\fR option wit \f(CW\*(C`\-o\*(C'\fR,
it don't need ta be specified separately up in dis case.
.IP "\fBcommit [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB]\fR \fIfilename\fR" 4
.IX Item "commit [-f fmt] [-t cache] filename"
Commit tha chizzlez recorded up in \fIfilename\fR up in its base image.
.IP "\fBcompare [\-f\fR \fIfmt\fR\fB] [\-F\fR \fIfmt\fR\fB] [\-p] [\-s] [\-q]\fR \fIfilename1\fR\fB \fR\fIfilename2\fR" 4
.IX Item "compare [-f fmt] [-F fmt] [-p] [-s] [-q] filename1 filename2"
Peep if two images have tha same content. Yo ass can compare images with
different format or settings.
.Sp
Da format is probed unless you specify it by \fI\-f\fR (used for
\&\fIfilename1\fR) and/or \fI\-F\fR (used fo' \fIfilename2\fR) option.
.Sp
By default, images wit different size is considered identical if tha larger
image gotz nuff only unallocated and/or zeroed sectors up in tha area afta tha end
of tha other image. In addition, if any sector aint allocated up in one image
and gotz nuff only zero bytes up in tha second one, it is evaluated as equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. You
can use Strict mode by specifyin tha \fI\-s\fR option. I aint talkin' bout chicken n' gravy biatch. When compare runs in
Strict mode, it fails up in case image size differs or a sector be allocated in
one image n' aint allocated up in tha second one.
.Sp
By default, compare prints up a result message. This message displays
information dat both images is same or tha posizzle of tha straight-up original gangsta different
byte. In addition, result message can report different image size up in case
Strict mode is used.
.Sp
Compare exits wit \f(CW0\fR up in case tha images is equal n' wit \f(CW1\fR
in case tha images differ n' shit. Other exit codes mean a error occurred during
execution n' standard error output should contain a error message.
Da followin table sumarizes all exit codez of tha compare subcommand:
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
Images is identical
.IP "\fB1\fR" 4
.IX Item "1"
Images differ
.IP "\fB2\fR" 4
.IX Item "2"
Error on openin a image
.IP "\fB3\fR" 4
.IX Item "3"
Error on checkin a sector allocation
.IP "\fB4\fR" 4
.IX Item "4"
Error on readin data
.RE
.RS 4
.RE
.IP "\fBconvert [\-c] [\-p] [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-O\fR \fIoutput_fmt\fR\fB] [\-o\fR \fIoptions\fR\fB] [\-s\fR \fIsnapshot_name\fR\fB] [\-S\fR \fIsparse_size\fR\fB]\fR \fIfilename\fR \fB[\fR\fIfilename2\fR \fB[...]]\fR \fIoutput_filename\fR" 4
.IX Item "convert [-c] [-p] [-f fmt] [-t cache] [-O output_fmt] [-o options] [-s snapshot_name] [-S sparse_size] filename [filename2 [...]] output_filename"
Convert tha disk image \fIfilename\fR or a snapshot \fIsnapshot_name\fR ta disk image \fIoutput_filename\fR
usin format \fIoutput_fmt\fR. Well shiiiit, it can be optionally compressed (\f(CW\*(C`\-c\*(C'\fR
option) or use any format specific options like encryption (\f(CW\*(C`\-o\*(C'\fR option).
.Sp
Only tha formats \f(CW\*(C`qcow\*(C'\fR n' \f(CW\*(C`qcow2\*(C'\fR support compression. I aint talkin' bout chicken n' gravy biatch. The
compression is read-only. Well shiiiit, it means dat if a cold-ass lil compressed sector is
rewritten, then it is rewritten as uncompressed data.
.Sp
Image conversion be also useful ta git smalla image when rockin a
growable format like fuckin \f(CW\*(C`qcow\*(C'\fR or \f(CW\*(C`cow\*(C'\fR: tha empty sectors
are detected n' suppressed from tha destination image.
.Sp
Yo ass can use tha \fIbacking_file\fR option ta force tha output image ta be
created as a cold-ass lil copy on write image of tha specified base image; the
\&\fIbacking_file\fR should have tha same content as tha inputz base image,
however tha path, image format, etc may differ.
.IP "\fBinfo [\-f\fR \fIfmt\fR\fB] [\-\-output=\fR\fIofmt\fR\fB] [\-\-backing\-chain]\fR \fIfilename\fR" 4
.IX Item "info [-f fmt] [--output=ofmt] [--backing-chain] filename"
Give shiznit bout tha disk image \fIfilename\fR. Use it in
particular ta know tha size reserved on disk which can be different
from tha displayed size. If \s-1VM\s0 snapshots is stored up in tha disk image,
they is displayed like a muthafucka. Da command can output up in tha format \fIofmt\fR
which is either \f(CW\*(C`human\*(C'\fR or \f(CW\*(C`json\*(C'\fR.
.Sp
If a gangbangin' finger-lickin' disk image has a funky-ass backin file chain, shiznit bout each disk image in
the chain can be recursively enumerated by rockin tha option \f(CW\*(C`\-\-backing\-chain\*(C'\fR.
.Sp
For instance, if you have a image chain like:
.Sp
.Vb 1
\&        base.qcow2 <\- snap1.qcow2 <\- snap2.qcow2
.Ve
.Sp
To enumerate shiznit bout each disk image up in tha above chain, startin from top ta base, do:
.Sp
.Vb 1
\&        qemu\-img info \-\-backing\-chain snap2.qcow2
.Ve
.IP "\fBsnapshot [\-l | \-a\fR \fIsnapshot\fR \fB| \-c\fR \fIsnapshot\fR \fB| \-d\fR \fIsnapshot\fR \fB]\fR \fIfilename\fR" 4
.IX Item "snapshot [-l | -a snapshot | -c snapshot | -d snapshot ] filename"
List, apply, create or delete snapshots up in image \fIfilename\fR.
.IP "\fBrebase [\-f\fR \fIfmt\fR\fB] [\-t\fR \fIcache\fR\fB] [\-p] [\-u] \-b\fR \fIbacking_file\fR \fB[\-F\fR \fIbacking_fmt\fR\fB]\fR \fIfilename\fR" 4
.IX Item "rebase [-f fmt] [-t cache] [-p] [-u] -b backing_file [-F backing_fmt] filename"
Changes tha backin file of a image. Only tha formats \f(CW\*(C`qcow2\*(C'\fR and
\&\f(CW\*(C`qed\*(C'\fR support changin tha backin file.
.Sp
Da backin file is chizzled ta \fIbacking_file\fR n' (if tha image format of
\&\fIfilename\fR supports this) tha backin file format is chizzled to
\&\fIbacking_fmt\fR. If \fIbacking_file\fR is specified as "" (the empty
string), then tha image is rebased onto no backin file (i.e. it will exist
independently of any backin file).
.Sp
There is two different modes up in which \f(CW\*(C`rebase\*(C'\fR can operate:
.RS 4
.IP "\fBSafe mode\fR" 4
.IX Item "Safe mode"
This is tha default mode n' performs a real rebase operation. I aint talkin' bout chicken n' gravy biatch. Da freshly smoked up backing
file may differ from tha oldschool one n' qemu-img rebase will take care of keeping
the guest-visible content of \fIfilename\fR unchanged.
.Sp
In order ta bust dis, any clustas dat differ between \fIbacking_file\fR
and tha oldschool backin file of \fIfilename\fR is merged tha fuck into \fIfilename\fR
before straight-up changin tha backin file.
.Sp
Note dat tha safe mode be a high-rollin' operation, comparable ta converting
an image. Well shiiiit, it only works if tha oldschool backin file still exists.
.IP "\fBUnsafe mode\fR" 4
.IX Item "Unsafe mode"
qemu-img uses tha unsafe mode if \f(CW\*(C`\-u\*(C'\fR is specified. Y'all KNOW dat shit, muthafucka! In dis mode, only the
backin file name n' format of \fIfilename\fR is chizzled without any checks
on tha file contents, n' you can put dat on yo' toast. Da user must take care of specifyin tha erect new
backin file, or tha guest-visible content of tha image is ghon be corrupted.
.Sp
This mode is useful fo' renamin or movin tha backin file ta somewhere else.
It can be used without a accessible oldschool backin file, i.e. you can use it to
fix a image whose backin file has already been moved/renamed.
.RE
.RS 4
.Sp
Yo ass can use \f(CW\*(C`rebase\*(C'\fR ta big-ass up a \*(L"diff\*(R" operation on two
disk images.  This can be useful when you have copied or cloned
a guest, n' you wanna git back ta a thin image on top of a
template or base image.
.Sp
Say dat \f(CW\*(C`base.img\*(C'\fR has been cloned as \f(CW\*(C`modified.img\*(C'\fR by
copyin it, n' dat tha \f(CW\*(C`modified.img\*(C'\fR hommie has run so there
are now some chizzlez compared ta \f(CW\*(C`base.img\*(C'\fR.  To construct a thin
image called \f(CW\*(C`diff.qcow2\*(C'\fR dat gotz nuff just tha differences, do:
.Sp
.Vb 2
\&        qemu\-img create \-f qcow2 \-b modified.img diff.qcow2
\&        qemu\-img rebase \-b base.img diff.qcow2
.Ve
.Sp
At dis point, \f(CW\*(C`modified.img\*(C'\fR can be discarded, since
\&\f(CW\*(C`base.img + diff.qcow2\*(C'\fR gotz nuff tha same ol' dirty shiznit.
.RE
.IP "\fBresize\fR \fIfilename\fR \fB[+ | \-]\fR\fIsize\fR" 4
.IX Item "resize filename [+ | -]size"
Change tha disk image as if it had been pimped wit \fIsize\fR.
.Sp
Before rockin dis command ta shrink a gangbangin' finger-lickin' disk image, you \s-1MUST\s0 use file system and
partitionin tools inside tha \s-1VM\s0 ta reduce allocated file systems n' partition
sizes accordingly.  Failure ta do so will result up in data loss!
.Sp
Afta rockin dis command ta grow a gangbangin' finger-lickin' disk image, you must use file system and
partitionin tools inside tha \s-1VM\s0 ta straight-up begin rockin tha freshly smoked up space on the
device.
.SH "NOTES"
.IX Header "NOTES"
Supported image file formats:
.IP "\fBraw\fR" 4
.IX Item "raw"
Raw disk image format (default). This format has tha advantage of
bein simple n' easily exportable ta all other emulators. If your
file system supports \fIholes\fR (for example up in ext2 or ext3 on
Linux or \s-1NTFS\s0 on Windows), then only tha freestyled sectors will reserve
space. Use \f(CW\*(C`qemu\-img info\*(C'\fR ta know tha real size used by the
image or \f(CW\*(C`ls \-ls\*(C'\fR on Unix/Linux.
.IP "\fBqcow2\fR" 4
.IX Item "qcow2"
\&\s-1QEMU\s0 image format, da most thugged-out versatile format. Use it ta have smaller
images (useful if yo' filesystem do not supports holes, fo' example
on Windows), optionizzle \s-1AES\s0 encryption, zlib based compression and
support of multiple \s-1VM\s0 snapshots.
.Sp
Supported options:
.RS 4
.ie n .IP """compat""" 4
.el .IP "\f(CWcompat\fR" 4
.IX Item "compat"
Determines tha qcow2 version ta use. \f(CW\*(C`compat=0.10\*(C'\fR uses tha traditional
image format dat can be read by any \s-1QEMU\s0 since 0.10 (this is tha default).
\&\f(CW\*(C`compat=1.1\*(C'\fR enablez image format extensions dat only \s-1QEMU 1.1\s0 and
newer understand. Y'all KNOW dat shit, muthafucka! Amongst others, dis includes zero clusters, which allow
efficient copy-on-read fo' sparse images.
.ie n .IP """backing_file""" 4
.el .IP "\f(CWbacking_file\fR" 4
.IX Item "backing_file"
File name of a funky-ass base image (see \fBcreate\fR subcommand)
.ie n .IP """backing_fmt""" 4
.el .IP "\f(CWbacking_fmt\fR" 4
.IX Item "backing_fmt"
Image format of tha base image
.ie n .IP """encryption""" 4
.el .IP "\f(CWencryption\fR" 4
.IX Item "encryption"
If dis option is set ta \f(CW\*(C`on\*(C'\fR, tha image is encrypted.
.Sp
Encryption uses tha \s-1AES\s0 format which is straight-up secure (128 bit keys). Use
a long password (16 characters) ta git maximum protection.
.ie n .IP """cluster_size""" 4
.el .IP "\f(CWcluster_size\fR" 4
.IX Item "cluster_size"
Changes tha qcow2 clusta size (must be between 512 n' 2M). Right back up in yo muthafuckin ass. Smalla cluster
sizes can improve tha image file size whereas larger clusta sizes generally
provide betta performance.
.ie n .IP """preallocation""" 4
.el .IP "\f(CWpreallocation\fR" 4
.IX Item "preallocation"
Preallocation mode (allowed joints: off, metadata) fo' realz. An image wit preallocated
metadata is initially larger but can improve performizzle when tha image needs
to grow.
.ie n .IP """lazy_refcounts""" 4
.el .IP "\f(CWlazy_refcounts\fR" 4
.IX Item "lazy_refcounts"
If dis option is set ta \f(CW\*(C`on\*(C'\fR, reference count thugged-out shiznit is postponed with
the goal of avoidin metadata I/O n' pimpin-out performance. This is
particularly bangin-ass wit \fBcache=writethrough\fR which don't batch
metadata thugged-out shit. Da tradeoff is dat afta a host crash, tha reference count
tablez must be rebuilt, i.e. on tha next open a (automatic) \f(CW\*(C`qemu\-img
check \-r all\*(C'\fR is required, which may take some time.
.Sp
This option can only be enabled if \f(CW\*(C`compat=1.1\*(C'\fR is specified.
.RE
.RS 4
.RE
.IP "\fBOther\fR" 4
.IX Item "Other"
\&\s-1QEMU\s0 also supports various other image file formats fo' compatibilitizzle with
olda \s-1QEMU\s0 versions or other hypervisors, includin \s-1VMDK, VDI, VHD \s0(vpc), qcow1
and \s-1QED.\s0 For a gangbangin' full list of supported formats peep \f(CW\*(C`qemu\-img \-\-help\*(C'\fR.
For a mo' detailed description of these formats, peep tha \s-1QEMU\s0 Emulation User
Documentation.
.Sp
Da main purpose of tha block drivers fo' these formats is image conversion.
For hustlin VMs, it is recommended ta convert tha disk images ta either raw or
qcow2 up in order ta big up phat performance.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da \s-1HTML\s0 documentation of \s-1QEMU\s0 fo' mo' precise shiznit n' Linux
user mode emulator invocation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Fabrice Bellard
