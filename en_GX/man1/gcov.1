.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GCOV 1"
.TH GCOV 1 "2014-09-11" "gcc-4.8.3" "GNU"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
gcov \- coverage testin tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
gcov [\fB\-v\fR|\fB\-\-version\fR] [\fB\-h\fR|\fB\-\-help\fR]
     [\fB\-a\fR|\fB\-\-all\-blocks\fR]
     [\fB\-b\fR|\fB\-\-branch\-probabilities\fR]
     [\fB\-c\fR|\fB\-\-branch\-counts\fR]
     [\fB\-u\fR|\fB\-\-unconditional\-branches\fR]
     [\fB\-n\fR|\fB\-\-no\-output\fR]
     [\fB\-l\fR|\fB\-\-long\-file\-names\fR]
     [\fB\-p\fR|\fB\-\-preserve\-paths\fR]
     [\fB\-r\fR|\fB\-\-relative\-only\fR]
     [\fB\-f\fR|\fB\-\-function\-summaries\fR]
     [\fB\-o\fR|\fB\-\-object\-directory\fR \fIdirectory|file\fR]
     [\fB\-s\fR|\fB\-\-source\-prefix\fR \fIdirectory\fR]
     [\fB\-d\fR|\fB\-\-display\-progress\fR]
     \fIfiles\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBgcov\fR be a test coverage program.  Use it up in gangbang wit \s-1GCC\s0
to analyze yo' programs ta help create mo' efficient, fasta hustlin
code n' ta discover untested partz of yo' program.  Yo ass can use
\&\fBgcov\fR as a profilin tool ta help discover where your
optimization efforts will dopest affect yo' code.  Yo ass can also use
\&\fBgcov\fR along wit tha other profilin tool, \fBgprof\fR, to
assess which partz of yo' code use tha top billin amount of computing
time.
.PP
Profilin tools help you analyze yo' codez performance.  Usin a
profila like fuckin \fBgcov\fR or \fBgprof\fR, you can smoke up some
basic performizzle statistics, such as:
.IP "\(bu" 4
how often each line of code executes
.IP "\(bu" 4
what linez of code is straight-up executed
.IP "\(bu" 4
how much computin time each section of code uses
.PP
Once you know these thangs bout how tha fuck yo' code works when compiled, you
can peep each module ta peep which modulez should be optimized.
\&\fBgcov\fR helps you determine where ta work on optimization.
.PP
Software pimpers also use coverage testin up in gangbang with
testsuites, ta make shizzle software is straight-up phat enough fo' a release.
Testsuites can verify dat a program works as expected; a cold-ass lil coverage
program tests ta peep how tha fuck much of tha program is exercised by the
testsuite.  Developers can then determine what tha fuck kindz of test cases need
to be added ta tha testsuites ta create both betta testin n' a funky-ass better
final product.
.PP
Yo ass should compile yo' code without optimization if you plan ta use
\&\fBgcov\fR cuz tha optimization, by combinin some linez of code
into one function, may not hit you wit as much shiznit as you need to
look fo' `hot spots' where tha code is rockin a pimped out deal of computer
time.  Likewise, cuz \fBgcov\fR accumulates statistics by line (at
the lowest resolution), it works dopest wit a programmin steez that
places only one statement on each line.  If you use fucked up macros
that expand ta loops or ta other control structures, tha statistics are
less helpful\-\-\-they only report on tha line where tha macro call
appears.  If yo' complex macros behave like functions, you can replace
them wit inline functions ta solve dis problem.
.PP
\&\fBgcov\fR creates a logfile called \fI\fIsourcefile\fI.gcov\fR which
indicates how tha fuck nuff times each line of a source file \fI\fIsourcefile\fI.c\fR
has executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Yo ass can use these logfilez along wit \fBgprof\fR ta aid
in fine-tunin tha performizzle of yo' programs.  \fBgprof\fR gives
timin shiznit you can use along wit tha shiznit you git from
\&\fBgcov\fR.
.PP
\&\fBgcov\fR works only on code compiled wit \s-1GCC. \s0 It be not
compatible wit any other profilin or test coverage mechanism.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-h\fR" 4
.IX Item "-h"
.PD 0
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
.PD
Display help bout rockin \fBgcov\fR (on tha standard output), and
exit without bustin any further processing.
.IP "\fB\-v\fR" 4
.IX Item "-v"
.PD 0
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
.PD
Display tha \fBgcov\fR version number (on tha standard output),
and exit without bustin any further processing.
.IP "\fB\-a\fR" 4
.IX Item "-a"
.PD 0
.IP "\fB\-\-all\-blocks\fR" 4
.IX Item "--all-blocks"
.PD
Write individual execution counts fo' every last muthafuckin basic block.  Normally gcov
outputs execution counts only fo' tha main blockz of a line.  With this
option you can determine if blocks within a single line is not being
executed.
.IP "\fB\-b\fR" 4
.IX Item "-b"
.PD 0
.IP "\fB\-\-branch\-probabilities\fR" 4
.IX Item "--branch-probabilities"
.PD
Write branch frequencies ta tha output file, n' write branch summary
info ta tha standard output.  This option allows you ta peep how tha fuck often
each branch up in yo' program was taken. I aint talkin' bout chicken n' gravy biatch.  Unconditionizzle branches will not
be shown, unless tha \fB\-u\fR option is given.
.IP "\fB\-c\fR" 4
.IX Item "-c"
.PD 0
.IP "\fB\-\-branch\-counts\fR" 4
.IX Item "--branch-counts"
.PD
Write branch frequencies as tha number of branches taken, rather than
the cementage of branches taken.
.IP "\fB\-n\fR" 4
.IX Item "-n"
.PD 0
.IP "\fB\-\-no\-output\fR" 4
.IX Item "--no-output"
.PD
Do not create tha \fBgcov\fR output file.
.IP "\fB\-l\fR" 4
.IX Item "-l"
.PD 0
.IP "\fB\-\-long\-file\-names\fR" 4
.IX Item "--long-file-names"
.PD
Smoke long file names fo' included source files.  For example, if the
header file \fIx.h\fR gotz nuff code, n' was included up in tha file
\&\fIa.c\fR, then hustlin \fBgcov\fR on tha file \fIa.c\fR will
produce a output file called \fIa.c##x.h.gcov\fR instead of
\&\fIx.h.gcov\fR.  This can be useful if \fIx.h\fR is included in
multiple source filez n' you wanna peep tha individual
contributions.  If you use tha \fB\-p\fR option, both tha including
and included file names is ghon be complete path names.
.IP "\fB\-p\fR" 4
.IX Item "-p"
.PD 0
.IP "\fB\-\-preserve\-paths\fR" 4
.IX Item "--preserve-paths"
.PD
Preserve complete path shiznit up in tha namez of generated
\&\fI.gcov\fR files.  Without dis option, just tha filename component is
used. Y'all KNOW dat shit, muthafucka!  With dis option, all directories is used, wit \fB/\fR characters
translated ta \fB#\fR characters, \fI.\fR directory components
removed n' unremoveable \fI..\fR
components renamed ta \fB^\fR.  This is useful if sourcefilez is up in several
different directories.
.IP "\fB\-r\fR" 4
.IX Item "-r"
.PD 0
.IP "\fB\-\-relative\-only\fR" 4
.IX Item "--relative-only"
.PD
Only output shiznit bout source filez wit a relatizzle pathname
(afta source prefix elision).  Absolute paths is probably system
header filez n' coverage of any inline functions therein is normally
uninteresting.
.IP "\fB\-f\fR" 4
.IX Item "-f"
.PD 0
.IP "\fB\-\-function\-summaries\fR" 4
.IX Item "--function-summaries"
.PD
Output summaries fo' each function up in addizzle ta tha file level summary.
.IP "\fB\-o\fR \fIdirectory|file\fR" 4
.IX Item "-o directory|file"
.PD 0
.IP "\fB\-\-object\-directory\fR \fIdirectory\fR" 4
.IX Item "--object-directory directory"
.IP "\fB\-\-object\-file\fR \fIfile\fR" 4
.IX Item "--object-file file"
.PD
Specify either tha directory containin tha gcov data files, or the
object path name.  Da \fI.gcno\fR, and
\&\fI.gcda\fR data filez is searched fo' rockin dis option. I aint talkin' bout chicken n' gravy biatch.  If a gangbangin' finger-lickin' directory
is specified, tha data filez is up in dat directory n' named afta the
input file name, without its extension. I aint talkin' bout chicken n' gravy biatch.  If a gangbangin' file is specified here,
the data filez is named afta dat file, without its extension.
.IP "\fB\-s\fR \fIdirectory\fR" 4
.IX Item "-s directory"
.PD 0
.IP "\fB\-\-source\-prefix\fR \fIdirectory\fR" 4
.IX Item "--source-prefix directory"
.PD
A prefix fo' source file names ta remove when generatin tha output
coverage files.  This option is useful when buildin up in a separate
directory, n' tha pathname ta tha source directory aint wanted when
determinin tha output file names.  Note dat dis prefix detection is
applied before determinin whether tha source file be absolute.
.IP "\fB\-u\fR" 4
.IX Item "-u"
.PD 0
.IP "\fB\-\-unconditional\-branches\fR" 4
.IX Item "--unconditional-branches"
.PD
When branch probabilitizzles is given, include dem of unconditionizzle branches.
Unconditionizzle branches is normally not interesting.
.IP "\fB\-d\fR" 4
.IX Item "-d"
.PD 0
.IP "\fB\-\-display\-progress\fR" 4
.IX Item "--display-progress"
.PD
Display tha progress on tha standard output.
.PP
\&\fBgcov\fR should be run wit tha current directory tha same as that
when you invoked tha compila n' shit.  Otherwise it aint gonna be able ta locate
the source files.  \fBgcov\fR produces filez called
\&\fI\fImangledname\fI.gcov\fR up in tha current directory.  These contain
the coverage shiznit of tha source file they correspond to.
One \fI.gcov\fR file is produced fo' each source (or header) file
containin code,
which was compiled ta produce tha data files.  Da \fImangledname\fR part
of tha output file name is probably simply tha source file name yo, but can
be suttin' mo' fucked up if tha \fB\-l\fR or \fB\-p\fR options are
given. I aint talkin' bout chicken n' gravy biatch.  Refer ta dem options fo' details.
.PP
If you invoke \fBgcov\fR wit multiple input files, the
contributions from each input file is summed. Y'all KNOW dat shit, muthafucka!  Typically you would
invoke it wit tha same list of filez as tha final link of yo' executable.
.PP
Da \fI.gcov\fR filez contain tha \fB:\fR separated fieldz along with
program source code.  Da format is
.PP
.Vb 1
\&        <execution_count>:<line_number>:<source line text>
.Ve
.PP
Additionizzle block shiznit may succeed each line, when axed by
command line option. I aint talkin' bout chicken n' gravy biatch.  Da \fIexecution_count\fR is \fB\-\fR fo' lines
containin no code.  Unexecuted lines is marked \fB#####\fR or
\&\fB====\fR, dependin on whether they is reachable by
non-exceptionizzle paths or only exceptionizzle paths like fuckin \*(C+ exception
handlezs, respectively.
.PP
Some linez of shiznit all up in tha start have \fIline_number\fR of zero.
These preamble lines iz of tha form
.PP
.Vb 1
\&        \-:0:<tag>:<value>
.Ve
.PP
Da orderin n' number of these preamble lines is ghon be augmented as
\&\fBgcov\fR pimpment progresses \-\-\- do not rely on dem remaining
unchanged. Y'all KNOW dat shit, muthafucka!  Use \fItag\fR ta locate a particular preamble line.
.PP
Da additionizzle block shiznit iz of tha form
.PP
.Vb 1
\&        <tag> <information>
.Ve
.PP
Da \fIinformation\fR is human readable yo, but designed ta be simple
enough fo' machine parsin like a muthafucka.
.PP
When printin cementages, 0% n' 100% is only printed when tha joints
are \fIexactly\fR 0% n' 100% respectively.  Other joints which would
conventionally be rounded ta 0% or 100% is instead printed as the
nearest non-boundary value.
.PP
When rockin \fBgcov\fR, you must first compile yo' program wit two
special \s-1GCC\s0 options: \fB\-fprofile\-arcs \-ftest\-coverage\fR.
This  drops some lyrics ta tha compila ta generate additionizzle shiznit needed by
gcov (basically a gangbangin' flow graph of tha program) n' also includes
additionizzle code up in tha object filez fo' generatin tha extra profiling
information needed by gcov.  These additionizzle filez is placed up in the
directory where tha object file is located.
.PP
Hustlin tha program will cause flava output ta be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For each
source file compiled wit \fB\-fprofile\-arcs\fR, a accompanying
\&\fI.gcda\fR file is ghon be placed up in tha object file directory.
.PP
Hustlin \fBgcov\fR wit yo' programz source file names as arguments
will now produce a listin of tha code along wit frequency of execution
for each line.  For example, if yo' program is called \fItmp.c\fR, this
is what tha fuck you peep when you use tha basic \fBgcov\fR facility:
.PP
.Vb 5
\&        $ gcc \-fprofile\-arcs \-ftest\-coverage tmp.c
\&        $ a.out
\&        $ gcov tmp.c
\&        90.00% of 10 source lines executed up in file tmp.c
\&        Creatin tmp.c.gcov.
.Ve
.PP
Da file \fItmp.c.gcov\fR gotz nuff output from \fBgcov\fR.
Here be a sample:
.PP
.Vb 10
\&                \-:    0:Source:tmp.c
\&                \-:    0:Graph:tmp.gcno
\&                \-:    0:Data:tmp.gcda
\&                \-:    0:Runs:1
\&                \-:    0:Programs:1
\&                \-:    1:#include <stdio.h>
\&                \-:    2:
\&                \-:    3:int main (void)
\&                1:    4:{
\&                1:    5:  int i, total;
\&                \-:    6:
\&                1:    7:  total = 0;
\&                \-:    8:
\&               11:    9:  fo' (i = 0; i < 10; i++)
\&               10:   10:    total += i;
\&                \-:   11:
\&                1:   12:  if (total != 45)
\&            #####:   13:    printf ("Failure\en");
\&                \-:   14:  else
\&                1:   15:    printf ("Success\en");
\&                1:   16:  return 0;
\&                \-:   17:}
.Ve
.PP
When you use tha \fB\-a\fR option, yo big-ass booty is ghon git individual block
counts, n' tha output be lookin like this:
.PP
.Vb 10
\&                \-:    0:Source:tmp.c
\&                \-:    0:Graph:tmp.gcno
\&                \-:    0:Data:tmp.gcda
\&                \-:    0:Runs:1
\&                \-:    0:Programs:1
\&                \-:    1:#include <stdio.h>
\&                \-:    2:
\&                \-:    3:int main (void)
\&                1:    4:{
\&                1:    4\-block  0
\&                1:    5:  int i, total;
\&                \-:    6:
\&                1:    7:  total = 0;
\&                \-:    8:
\&               11:    9:  fo' (i = 0; i < 10; i++)
\&               11:    9\-block  0
\&               10:   10:    total += i;
\&               10:   10\-block  0
\&                \-:   11:
\&                1:   12:  if (total != 45)
\&                1:   12\-block  0
\&            #####:   13:    printf ("Failure\en");
\&            $$$$$:   13\-block  0
\&                \-:   14:  else
\&                1:   15:    printf ("Success\en");
\&                1:   15\-block  0
\&                1:   16:  return 0;
\&                1:   16\-block  0
\&                \-:   17:}
.Ve
.PP
In dis mode, each basic block is only shown on one line \*(-- tha last
line of tha block.  A multi-line block will only contribute ta the
execution count of dat last line, n' other lines aint gonna be shown
to contain code, unless previous blocks end on dem lines.
Da total execution count of a line is shown n' subsequent lines show
the execution counts fo' individual blocks dat end on dat line.  Afta each
block, tha branch n' call countz of tha block is ghon be shown, if the
\&\fB\-b\fR option is given.
.PP
Because of tha way \s-1GCC\s0 instruments calls, a cold-ass lil call count can be shown
afta a line wit no individual blocks.
As you can see, line 13 gotz nuff a funky-ass basic block dat was not executed.
.PP
When you use tha \fB\-b\fR option, yo' output be lookin like this:
.PP
.Vb 6
\&        $ gcov \-b tmp.c
\&        90.00% of 10 source lines executed up in file tmp.c
\&        80.00% of 5 branches executed up in file tmp.c
\&        80.00% of 5 branches taken at least once up in file tmp.c
\&        50.00% of 2 calls executed up in file tmp.c
\&        Creatin tmp.c.gcov.
.Ve
.PP
Here be a sample of a resultin \fItmp.c.gcov\fR file:
.PP
.Vb 10
\&                \-:    0:Source:tmp.c
\&                \-:    0:Graph:tmp.gcno
\&                \-:    0:Data:tmp.gcda
\&                \-:    0:Runs:1
\&                \-:    0:Programs:1
\&                \-:    1:#include <stdio.h>
\&                \-:    2:
\&                \-:    3:int main (void)
\&        function main called 1 returned 1 blocks executed 75%
\&                1:    4:{
\&                1:    5:  int i, total;
\&                \-:    6:
\&                1:    7:  total = 0;
\&                \-:    8:
\&               11:    9:  fo' (i = 0; i < 10; i++)
\&        branch  0 taken 91% (fallthrough)
\&        branch  1 taken 9%
\&               10:   10:    total += i;
\&                \-:   11:
\&                1:   12:  if (total != 45)
\&        branch  0 taken 0% (fallthrough)
\&        branch  1 taken 100%
\&            #####:   13:    printf ("Failure\en");
\&        call    0 never executed
\&                \-:   14:  else
\&                1:   15:    printf ("Success\en");
\&        call    0 called 1 returned 100%
\&                1:   16:  return 0;
\&                \-:   17:}
.Ve
.PP
For each function, a line is printed showin how tha fuck nuff times tha function
is called, how tha fuck nuff times it returns n' what tha fuck cementage of the
functionz blocks was executed.
.PP
For each basic block, a line is printed afta tha last line of tha basic
block describin tha branch or call dat endz tha basic block.  There can
be multiple branches n' calls listed fo' a single source line if there
are multiple basic blocks dat end on dat line.  In dis case, the
branches n' calls is each given a number n' shit.  There is no simple way ta map
these branches n' calls back ta source constructs, n' you can put dat on yo' toast.  In general, though,
the lowest numbered branch or call will correspond ta tha leftmost construct
on tha source line.
.PP
For a funky-ass branch, if dat shiznit was executed at least once, then a cementage
indicatin tha number of times tha branch was taken divided by the
number of times tha branch was executed is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Otherwise, the
message \*(L"never executed\*(R" is printed.
.PP
For a cold-ass lil call, if dat shiznit was executed at least once, then a cementage
indicatin tha number of times tha call returned divided by tha number
of times tha call was executed is ghon be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This will probably be
100% yo, but may be less fo' functions dat call \f(CW\*(C`exit\*(C'\fR or \f(CW\*(C`longjmp\*(C'\fR,
and thus may not return every last muthafuckin time they is called.
.PP
Da execution counts is cumulative.  If tha example program were
executed again n' again n' again without removin tha \fI.gcda\fR file, tha count fo' the
number of times each line up in tha source was executed would be added to
the thangs up in dis biatch of tha previous run(s).  This is potentially useful in
several ways.  For example, it could be used ta accumulate data over a
number of program runs as part of a test verification suite, or to
provide mo' accurate long-term shiznit over a big-ass number of
program runs.
.PP
Da data up in tha \fI.gcda\fR filez is saved immediately before tha program
exits, n' you can put dat on yo' toast.  For each source file compiled wit \fB\-fprofile\-arcs\fR, the
profilin code first attempts ta read up in a existin \fI.gcda\fR file; if
the file don't match tha executable (differin number of basic block
counts) it will ignore tha contentz of tha file.  It then addz up in the
new execution counts n' finally writes tha data ta tha file.
.SS "Usin \fBgcov\fP wit \s-1GCC\s0 Optimization"
.IX Subsection "Usin gcov wit GCC Optimization"
If you plan ta use \fBgcov\fR ta help optimize yo' code, you must
first compile yo' program wit two special \s-1GCC\s0 options:
\&\fB\-fprofile\-arcs \-ftest\-coverage\fR.  Aside from that, you can use any
other \s-1GCC\s0 options; but if you wanna prove dat every last muthafuckin single line
in yo' program was executed, you should not compile wit optimization
at tha same time.  On some machines tha optimizer can eliminizzle some
simple code lines by combinin dem wit other lines.  For example, code
like this:
.PP
.Vb 4
\&        if (a != b)
\&          c = 1;
\&        else
\&          c = 0;
.Ve
.PP
can be compiled tha fuck into one instruction on some machines.  In dis case,
there is no way fo' \fBgcov\fR ta calculate separate execution counts
for each line cuz there aint separate code fo' each line.  Hence
the \fBgcov\fR output be lookin like dis if you compiled tha program with
optimization:
.PP
.Vb 4
\&              100:   12:if (a != b)
\&              100:   13:  c = 1;
\&              100:   14:else
\&              100:   15:  c = 0;
.Ve
.PP
Da output shows dat dis block of code, combined by optimization,
executed 100 times.  In one sense dis result is erect, cuz there
was only one instruction representin all four of these lines.  However,
the output do not indicate how tha fuck nuff times tha result was 0 n' how
many times tha result was 1.
.PP
Inlineable functions can create unexpected line counts, n' you can put dat on yo' toast.  Line counts are
shown fo' tha source code of tha inlineable function yo, but what tha fuck is shown
dependz on where tha function is inlined, or if it aint inlined at all.
.PP
If tha function aint inlined, tha compila must emit a outta line
copy of tha function, up in any object file dat needz dat shit.  If
\&\fIfileA.o\fR n' \fIfileB.o\fR both contain outta line bodiez of a
particular inlineable function, they will also both contain coverage
counts fo' dat function. I aint talkin' bout chicken n' gravy biatch.  When \fIfileA.o\fR n' \fIfileB.o\fR are
linked together, tha linker will, on nuff systems, select one of them
out of line bodies fo' all calls ta dat function, n' remove or ignore
the other n' shit.  Unfortunately, it aint gonna remove tha coverage countas for
the unused function body.  Hence when instrumented, all but one use of
that function will show zero counts.
.PP
If tha function is inlined up in nuff muthafuckin places, tha block structure in
each location might not be tha same.  For instance, a cold-ass lil condizzle might
now be calculable at compile time up in some instances.  Because the
coverage of all tha usez of tha inline function is ghon be shown fo' the
same source lines, tha line counts theyselves might seem inconsistent.
.PP
Long-runnin applications can use tha \f(CW\*(C`_gcov_reset\*(C'\fR n' \f(CW\*(C`_gcov_dump\*(C'\fR
facilitizzles ta restrict flava collection ta tha program region of
interest. Callin \f(CW\*(C`_gcov_reset(void)\*(C'\fR will clear all flava counters
to zero, n' callin \f(CW\*(C`_gcov_dump(void)\*(C'\fR will cause tha flava shiznit
collected at dat point ta be dumped ta \fI.gcda\fR output files.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIgpl\fR\|(7), \fIgfdl\fR\|(7), \fIfsf\-funding\fR\|(7), \fIgcc\fR\|(1) n' tha Info entry fo' \fIgcc\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996\-2013 Jacked Software Foundation, Inc.
.PP
Permission is granted ta copy, distribute and/or modify dis document
under tha termz of tha \s-1GNU\s0 Jacked Documentation License, Version 1.3 or
any lata version published by tha Jacked Software Foundation; wit the
Invariant Sections bein \*(L"\s-1GNU\s0 General Public License\*(R" n' \*(L"Funding
Jacked Software\*(R", tha Front-Cover texts bein (a) (see below), n' with
the Back-Cover Texts bein (b) (see below).  A copy of tha license is
included up in tha \fIgfdl\fR\|(7) playa page.
.PP
(a) Da \s-1FSF\s0z Front-Cover Text is:
.PP
.Vb 1
\&     A GNU Manual
.Ve
.PP
(b) Da \s-1FSF\s0z Back-Cover Text is:
.PP
.Vb 3
\&     Yo ass have freedom ta copy n' modify dis GNU Manual, like GNU
\&     software.  Copies published by tha Jacked Software Foundation raise
\&     fundz fo' GNU pimpment.
.Ve
