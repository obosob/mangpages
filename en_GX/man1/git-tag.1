'\" t
.\"     Title: git-tag
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-TAG" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-tag \- Create, list, delete or verify a tag object signed wit GPG
.SH "SYNOPSIS"
.sp
.nf
\fIgit tag\fR [\-a | \-s | \-u <key\-id>] [\-f] [\-m <msg> | \-F <file>]
        <tagname> [<commit> | <object>]
\fIgit tag\fR \-d <tagname>\&...
\fIgit tag\fR [\-n[<num>]] \-l [\-\-gotz nuff <commit>] [\-\-points\-at <object>]
        [\-\-column[=<options>] | \-\-no\-column] [<pattern>\&...]
        [<pattern>\&...]
\fIgit tag\fR \-v <tagname>\&...
.fi
.sp
.SH "DESCRIPTION"
.sp
Add a tag reference up in refs/tags/, unless \-d/\-l/\-v is given ta delete, list or verify tags\&.
.sp
Unless \-f is given, tha named tag must not yet exist\&.
.sp
If one of \-a, \-s, or \-u <key\-id> is passed, tha command creates a \fItag\fR object, n' requires a tag message\&. Unless \-m <msg> or \-F <file> is given, a editor is started fo' tha user ta type up in tha tag message\&.
.sp
If \-m <msg> or \-F <file> is given n' \-a, \-s, n' \-u <key\-id> is absent, \-a is implied\&.
.sp
Otherwise just a tag reference fo' tha SHA\-1 object name of tha commit object is pimped (i\&.e\&. a lightweight tag)\&.
.sp
A GnuPG signed tag object is ghon be pimped when \-s or \-u <key\-id> is used\&. When \-u <key\-id> aint used, tha committa identitizzle fo' tha current user is used ta find tha GnuPG key fo' signing\&. Da configuration variable gpg\&.program is used ta specify custom GnuPG binary\&.
.sp
Tag objects (created wit \-a, s, or \-u) is called "annotated" tags; they contain a cold-ass lil creation date, tha tagger name n' e\-mail, a taggin message, n' a optionizzle GnuPG signature\&. Whereas a "lightweight" tag is simply a name fo' a object (usually a cold-ass lil commit object)\&.
.sp
Annotated tags is meant fo' release while lightweight tags is meant fo' private or temporary object labels\&. For dis reason, some git commandz fo' namin objects (like git describe) will ignore lightweight tags by default\&.
.SH "OPTIONS"
.PP
\-a, \-\-annotate
.RS 4
Make a unsigned, annotated tag object
.RE
.PP
\-s, \-\-sign
.RS 4
Make a GPG\-signed tag, rockin tha default e\-mail address\(cqs key\&.
.RE
.PP
\-u <key\-id>, \-\-local\-user=<key\-id>
.RS 4
Make a GPG\-signed tag, rockin tha given key\&.
.RE
.PP
\-f, \-\-force
.RS 4
Replace a existin tag wit tha given name (instead of failing)
.RE
.PP
\-d, \-\-delete
.RS 4
Delete existin tags wit tha given names\&.
.RE
.PP
\-v, \-\-verify
.RS 4
Verify tha gpg signature of tha given tag names\&.
.RE
.PP
\-n<num>
.RS 4
<num> specifies how tha fuck nuff lines from tha annotation, if any, is printed when rockin \-l\&. Da default aint ta print any annotation lines\&. If no number is given to
\-n, only tha straight-up original gangsta line is printed\&. If tha tag aint annotated, tha commit message is displayed instead\&.
.RE
.PP
\-l <pattern>, \-\-list <pattern>
.RS 4
List tags wit names dat match tha given pattern (or all if no pattern is given)\&. Hustlin "git tag" without arguments also lists all tags\&. Da pattern be a gangbangin' finger-lickin' dirty-ass shell wildcard (i\&.e\&., matched rockin fnmatch(3))\&. Multiple patterns may be given; if any of dem matches, tha tag is shown\&.
.RE
.PP
\-\-column[=<options>], \-\-no\-column
.RS 4
Display tag listin up in columns\&. Right back up in yo muthafuckin ass. See configuration variable column\&.tag fo' option syntax\&.\-\-column
and
\-\-no\-column
without options is equivalent to
\fIalways\fR
and
\fInever\fR
respectively\&.
.sp
This option is only applicable when listin tags without annotation lines\&.
.RE
.PP
\-\-gotz nuff [<commit>]
.RS 4
Only list tags which contain tha specified commit (HEAD if not specified)\&.
.RE
.PP
\-\-points\-at <object>
.RS 4
Only list tagz of tha given object\&.
.RE
.PP
\-m <msg>, \-\-message=<msg>
.RS 4
Use tha given tag message (instead of prompting)\&. If multiple
\-m
options is given, they joints is concatenated as separate paragraphs\&. Implies
\-a
if none of
\-a,
\-s, or
\-u <key\-id>
is given\&.
.RE
.PP
\-F <file>, \-\-file=<file>
.RS 4
Take tha tag message from tha given file\&. Use
\fI\-\fR
to read tha message from tha standard input\&. Implies
\-a
if none of
\-a,
\-s, or
\-u <key\-id>
is given\&.
.RE
.PP
\-\-cleanup=<mode>
.RS 4
This option sets how tha fuck tha tag message is cleaned up\&. The
\fI<mode>\fR
can be one of
\fIverbatim\fR,
\fIwhitespace\fR
and
\fIstrip\fR\&. The
\fIstrip\fR
mode is default\&. The
\fIverbatim\fR
mode do not chizzle message at all,
\fIwhitespace\fR
removes just leading/trailin whitespace lines and
\fIstrip\fR
removes both whitespace n' commentary\&.
.RE
.PP
<tagname>
.RS 4
Da name of tha tag ta create, delete, or describe\&. Da freshly smoked up tag name must pass all checks defined by
\fBgit-check-ref-format\fR(1)\&. Right back up in yo muthafuckin ass. Some of these checks may restrict tha charactas allowed up in a tag name\&.
.RE
.PP
<commit>, <object>
.RS 4
Da object dat tha freshly smoked up tag will refer to, probably a cold-ass lil commit\&. Defaults ta HEAD\&.
.RE
.SH "CONFIGURATION"
.sp
By default, \fIgit tag\fR up in sign\-with\-default mode (\-s) will use yo' committa identitizzle (of tha form "Yo crazy-ass Name <your@email\&.address>") ta find a key\&. If you wanna bust a gangbangin' finger-lickin' different default key, you can specify it up in tha repository configuration as bigs up:
.sp
.if n \{\
.RS 4
.\}
.nf
[user]
    signingkey = <gpg\-key\-id>
.fi
.if n \{\
.RE
.\}
.sp
.SH "DISCUSSION"
.SS "On Re\-tagging"
.sp
What should you do when you tag a wack commit n' you would wanna re\-tag?
.sp
If you never pushed anythang out, just re\-tag it\&. Use "\-f" ta replace tha oldschool one\& fo' realz. And you\(cqre done\&.
.sp
But if you have pushed thangs up (or others could just read yo' repository directly), then others gonna git already peeped tha oldschool tag\&. In dat case you can do one of two thangs:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Da sane thang\&. Just admit you screwed up, n' bust a gangbangin' finger-lickin' different name\&. Others have already peeped one tag\-name, n' if you keep tha same name, you may be up in tha thang dat two playas both have "version X" yo, but they straight-up have
\fIdifferent\fR
"X"\(aqs\&. Right back up in yo muthafuckin ass. So just call it "X\&.1" n' be done wit it\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Da crazy thang\&. Yo ass straight-up wanna call tha freshly smoked up version "X" too,
\fIeven though\fR
others have already peeped tha oldschool one\&. Right back up in yo muthafuckin ass. So just use
\fIgit tag \-f\fR
again, as if you hadn\(cqt already published tha oldschool one\&.
.RE
.sp
But fuck dat shiznit yo, tha word on tha street is dat Git do \fBnot\fR (and it should not) chizzle tags behind playas back\&. Right back up in yo muthafuckin ass. So if some muthafucka already gots tha oldschool tag, bustin a \fIgit pull\fR on yo' tree shouldn\(cqt just make dem overwrite tha oldschool one\&.
.sp
If some muthafucka gots a release tag from you, you cannot just chizzle tha tag fo' dem by uppimpin yo' own one\&. This be a funky-ass big-ass securitizzle issue, up in dat playas MUST be able ta trust they tag\-names\&. If you straight-up wanna do tha crazy thang, you need ta just fess up ta it, n' tell playas dat you messed up\&. Yo ass can do dat by bustin a straight-up hood announcement saying:
.sp
.if n \{\
.RS 4
.\}
.nf
Ok, I messed up, n' I pushed up a earlier version tagged as X\&. I
then fixed something, n' retagged tha *fixed* tree as X again\&.

If you gots tha wack tag, n' want tha freshly smoked up one, please delete
the oldschool one n' fetch tha freshly smoked up one by bustin:

        git tag \-d X
        git fetch origin tag X

to git mah updated tag\&.

Yo ass can test which tag you have by bustin

        git rev\-parse X

which should return 0123456789abcdef\&.\&. if you have tha freshly smoked up version\&.

Sorry fo' tha inconvenience\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
Do dis seem a lil' bit fucked up, biatch? It \fBshould\fR be\&. There is no way dat it would be erect ta just "fix" it automatically\&. Muthafuckas need ta know dat they tags might done been chizzled\&.
.SS "On Automatic following"
.sp
If yo ass is followin some muthafucka else\(cqs tree, yo ass is most likely rockin remote\-trackin branches (refs/heads/origin up in traditionizzle layout, or refs/remotes/origin/masta up in tha separate\-remote layout)\&. Yo ass probably want tha tags from tha other end\&.
.sp
On tha other hand, if yo ass is fetchin cuz you would want a one\-shot merge from some muthafucka else, you typically do not wanna git tags from there\&. This happens mo' often fo' playas near tha toplevel but not limited ta them\&. Mere mortals when pullin from each other do not necessarily wanna automatically git private anchor point tags from tha other person\&.
.sp
Often, "please pull" lyrics on tha mailin list just provide two piecez of shiznit: a repo URL n' a funky-ass branch name; dis is designed ta be easily cut&pasted all up in tha end of a \fIgit fetch\fR command line:
.sp
.if n \{\
.RS 4
.\}
.nf
Linus, please pull from

        git://git\&.\&.\&.\&./proj\&.git master

to git tha followin thugged-out shit\&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
becomes:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git pull git://git\&.\&.\&.\&./proj\&.git master
.fi
.if n \{\
.RE
.\}
.sp
.sp
In such a cold-ass lil case, you do not wanna automatically follow tha other person\(cqs tags\&.
.sp
One blingin aspect of Git is its distributed nature, which largely means there is no inherent "upstream" or "downstream" up in tha system\&. On tha grill of it, tha above example might seem ta indicate dat tha tag namespace is owned by tha upper echelon of playas n' dat tags only flow downwardz yo, but dat aint tha case\&. Well shiiiit, it only shows dat tha usage pattern determines whoz ass is horny bout whose tags\&.
.sp
A one\-shot pull be a sign dat a cold-ass lil commit history is now crossin tha boundary between one circle of playas (e\&.g\&. "people whoz ass is primarily horny bout tha networkin part of tha kernel") whoz ass may have they own set of tags (e\&.g\&. "this is tha third release muthafucka from tha networkin crew ta be proposed fo' general consumption wit 2\&.6\&.21 release") ta another circle of playas (e\&.g\&. "people whoz ass integrate various subsystem improvements")\&. Da latta is probably not horny bout tha detailed tags used internally up in tha forma crew (that is what tha fuck "internal" means)\&. That is why it is desirable not ta follow tags automatically up in dis case\&.
.sp
It may well be dat among networkin people, they may wanna exchange tha tags internal ta they crew yo, but up in dat workflow they is most likely trackin each other\(cqs progress by havin remote\-trackin branches\& fo' realz. Again, tha heuristic ta automatically follow such tags be a phat thang\&.
.SS "On Backpimpin Tags"
.sp
If you have imported some chizzlez from another VCS n' wanna add tags fo' major releasez of yo' work, it is useful ta be able ta specify tha date ta embed inside of tha tag object; such data up in tha tag object affects, fo' example, tha orderin of tags up in tha gitweb intercourse\&.
.sp
To set tha date used up in future tag objects, set tha environment variable GIT_COMMITTER_DATE (see tha lata rap of possible joints; da most thugged-out common form is "YYYY\-MM\-DD HH:MM")\&.
.sp
For example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ GIT_COMMITTER_DATE="2006\-10\-02 10:31" git tag \-s v1\&.0\&.1
.fi
.if n \{\
.RE
.\}
.sp
.SH "DATE FORMATS"
.sp
Da GIT_AUTHOR_DATE, GIT_COMMITTER_DATE environment variablez support tha followin date formats:
.PP
Git internal format
.RS 4
It is
<unix timestamp> <time unit offset>, where
<unix timestamp>
is tha number of secondz since tha UNIX epoch\&.
<time unit offset>
is a positizzle or wack offset from UTC\&. For example CET (which is 2 minutes ahead UTC) is
+0200\&.
.RE
.PP
RFC 2822
.RS 4
Da standard email format as busted lyrics bout by RFC 2822, fo' example
Thu, 07 Apr 2005 22:13:13 +0200\&.
.RE
.PP
ISO 8601
.RS 4
Time n' date specified by tha ISO 8601 standard, fo' example
2005\-04\-07T22:13:13\&. Da parser accepts a space instead of the
T
characta as well\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In addition, tha date part be accepted up in tha followin formats:
YYYY\&.MM\&.DD,
MM/DD/YYYY
and
DD\&.MM\&.YYYY\&.
.sp .5v
.RE
.RE
.SH "SEE ALSO"
.sp
\fBgit-check-ref-format\fR(1)\&.
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
