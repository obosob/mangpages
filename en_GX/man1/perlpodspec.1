.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSPEC 1"
.TH PERLPODSPEC 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodspec \- Plain Oldskool Documentation: format justification n' notes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is detailed notes on tha Pod markup language.  Most
people will only gotta read perlpod ta know how tha fuck ta write
in Pod yo, but dis document may answer some incidental thangs ta do
with parsin n' renderin Pod.
.PP
In dis document, \*(L"must\*(R" / \*(L"must not\*(R", \*(L"should\*(R" /
\&\*(L"should not\*(R", n' \*(L"may\*(R" have they conventionizzle (cf. \s-1RFC 2119\s0)
meanings: \*(L"X must do Y\*(R" means dat if X don't do Y, itz against
this justification, n' should straight-up be fixed. Y'all KNOW dat shit, muthafucka!  \*(L"X should do Y\*(R"
means dat itz recommended yo, but X may fail ta do Y, if there be a a
phat reason. I aint talkin' bout chicken n' gravy biatch.  \*(L"X may do Y\*(R" is merely a note dat X can do Y at
will (although it is up ta tha reader ta detect any connotation of
"and I be thinkin it would be \fInice\fR if X did Y\*(L" versus \*(R"it wouldn't
really \fIbother\fR me if X did Y").
.PP
Notably, when I say \*(L"the parser should do Y\*(R", the
parser may fail ta do Y, if tha callin application explicitly
requests dat tha parser \fInot\fR do Y.  I often phrase dis as
\&\*(L"the parser should, by default, do Y.\*(R"  This don't \fIrequire\fR
the parser ta provide a option fo' turnin off whatever
feature Y is (like expandin tabs up in verbatim paragraphs), although
it implicates dat such a option \fImay\fR be provided.
.SH "Pod Definitions"
.IX Header "Pod Definitions"
Pod is embedded up in files, typically Perl source files, although you
can write a gangbangin' file thatz not a god damn thang but Pod.
.PP
A \fBline\fR up in a gangbangin' file consistz of zero or mo' non-newline characters,
terminated by either a newline or tha end of tha file.
.PP
A \fBnewline sequence\fR is probably a platform-dependent concept yo, but
Pod parsers should KNOW it ta mean any of \s-1CR \s0(\s-1ASCII 13\s0), \s-1LF
\&\s0(\s-1ASCII 10\s0), or a \s-1CRLF \s0(\s-1ASCII 13\s0 followed immediately by \s-1ASCII 10\s0), in
addizzle ta any other system-specific meaning.  Da first \s-1CR/CRLF/LF\s0
sequence up in tha file may be used as tha basis fo' identifyin the
newline sequence fo' parsin tha rest of tha file.
.PP
A \fBblank line\fR be a line consistin entirely of zero or mo' spaces
(\s-1ASCII 32\s0) or tabs (\s-1ASCII 9\s0), n' terminated by a newline or end-of-file.
A \fBnon-blank line\fR be a line containin one or mo' charactas other
than space or tab (and terminated by a newline or end-of-file).
.PP
(\fINote:\fR Many olda Pod parsers did not accept a line consistin of
spaces/tabs n' then a newline as a funky-ass blank line. Da only lines they
considered blank was lines consistin of \fIno charactas at all\fR,
terminated by a newline.)
.PP
\&\fBWhitespace\fR is used up in dis document as a funky-ass blanket term fo' spaces,
tabs, n' newline sequences.  (By itself, dis term probably refers
to literal whitespace.  That is, sequencez of whitespace characters
in Pod source, as opposed ta \*(L"E<32>\*(R", which be a gangbangin' formatting
code dat \fIdenotes\fR a whitespace character.)
.PP
A \fBPod parser\fR be a module meant fo' parsin Pod (regardless of
whether dis involves callin callbacks or buildin a parse tree or
directly formattin it).  A \fBPod formatter\fR (or \fBPod translator\fR)
is a module or program dat converts Pod ta some other format (\s-1HTML,\s0
plaintext, TeX, PostScript, \s-1RTF\s0).  A \fBPod processor\fR might be a
formatta or translator, or might be a program dat do something
else wit tha Pod (like countin lyrics, scannin fo' index points,
etc.).
.PP
Pod content is contained up in \fBPod blocks\fR.  A Pod block starts wit a
line dat matches <m/\eA=[a\-zA\-Z]/>, n' continues up ta tha next line
that matches \f(CW\*(C`m/\eA=cut/\*(C'\fR or up ta tha end of tha file if there is
no \f(CW\*(C`m/\eA=cut/\*(C'\fR line.
.PP
Within a Pod block, there be \fBPod paragraphs\fR.  A Pod paragraph
consistz of non-blank linez of text, separated by one or mo' blank
lines.
.PP
For purposez of Pod processing, there be four typez of paragraphs in
a Pod block:
.IP "\(bu" 4
A command paragraph (also called a \*(L"directive\*(R").  Da first line of
this paragraph must match \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  Command paragraphs are
typically one line, as in:
.Sp
.Vb 1
\&  =head1 NOTES
\&
\&  =item *
.Ve
.Sp
But they may span nuff muthafuckin (non-blank) lines:
.Sp
.Vb 3
\&  =for comment
\&  Hm, I wonder what tha fuck it would be lookin like if
\&  you tried ta write a BNF fo' Pod from all dis bullshit.
\&
\&  =head3 Dr. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Strangelove, or: How tha fuck I Learned to
\&  Quit Worryin n' Ludd tha Bomb
.Ve
.Sp
\&\fISome\fR command paragraphs allow formattin codes up in they content
(i.e., afta tha part dat matches \f(CW\*(C`m/\eA=[a\-zA\-Z]\eS*\es*/\*(C'\fR), as in:
.Sp
.Vb 1
\&  =head1 Did Yo ass Remember ta C<use strict;>?
.Ve
.Sp
In other lyrics, tha Pod processin handlez fo' \*(L"head1\*(R" will apply the
same processin ta \*(L"Did Yo ass Remember ta C<use strict;>?\*(R" dat it
would ta a ordinary paragraph (i.e., formattin codes like
\&\*(L"C<...>\*(R") is parsed n' presumably formatted appropriately, and
whitespace up in tha form of literal spaces and/or tabs is not
significant.
.IP "\(bu" 4
A \fBverbatim paragraph\fR.  Da first line of dis paragraph must be a
literal space or tab, n' dis paragraph must not be inside a "=begin
\&\fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" sequence unless
\&\*(R"\fIidentifier\fR\*(L" begins wit a cold-ass lil colon (\*(R":").  That is, if a paragraph
starts wit a literal space or tab yo, but \fIis\fR inside a
"=begin \fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" region, then it's
a data paragraph, unless \*(R"\fIidentifier\fR" begins wit a cold-ass lil colon.
.Sp
Whitespace \fIis\fR dope up in verbatim paragraphs (although, in
processing, tabs is probably expanded).
.IP "\(bu" 4
An \fBordinary paragraph\fR.  A paragraph be a ordinary paragraph
if its first line matches neither \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR nor
\&\f(CW\*(C`m/\eA[ \et]/\*(C'\fR, \fIand\fR if it aint inside a "=begin \fIidentifier\fR\*(L",
\&... \*(R"=end \fIidentifier\fR\*(L" sequence unless \*(R"\fIidentifier\fR\*(L" begins with
a colon (\*(R":").
.IP "\(bu" 4
A \fBdata paragraph\fR.  This be a paragraph dat \fIis\fR inside a "=begin
\&\fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR\*(L" sequence where
\&\*(R"\fIidentifier\fR" do \fInot\fR begin wit a literal colon (\*(L":\*(R").  In
some sense, a thugged-out data paragraph aint part of Pod at all (i.e.,
effectively itz \*(L"out-of-band\*(R"), since it aint subject ta most kinds
of Pod parsing; but it is specified here, since Pod
parsers need ta be able ta booty-call a event fo' it, or store it up in some
form up in a parse tree, or at least just parse \fIaround\fR dat shit.
.PP
For example: consider tha followin paragraphs:
.PP
.Vb 1
\&  # <\- that\*(Aqs tha 0th column
\&
\&  =head1 Foo
\&
\&  Stuff
\&
\&    $foo\->bar
\&
\&  =cut
.Ve
.PP
Here, \*(L"=head1 Foo\*(R" n' \*(L"=cut\*(R" is command paragraphs cuz tha first
line of each matches \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  "\fI[space][space]\fR\f(CW$foo\fR\->bar\*(L"
is a verbatim paragraph, cuz its first line starts wit a literal
whitespace characta (and there be a no \*(R"=begin\*(L"...\*(R"=end" region around).
.PP
Da "=begin \fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR" commandz stop
paragraphs dat they surround from bein parsed as ordinary or verbatim
paragraphs, if \fIidentifier\fR don't begin wit a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch.  This
is discussed up in detail up in tha section
\&\*(L"Bout Data Paragraphs n' \*(R"=begin/=end\*(L" Regions\*(R".
.SH "Pod Commands"
.IX Header "Pod Commands"
This section is intended ta supplement n' clarify tha rap in
\&\*(L"Command Paragraph\*(R" up in perlpod. Y'all KNOW dat shit, muthafucka!  These is tha currently recognized
Pod commands:
.ie n .IP """=head1"", ""=head2"", ""=head3"", ""=head4""" 4
.el .IP "``=head1'', ``=head2'', ``=head3'', ``=head4''" 4
.IX Item "=head1, =head2, =head3, =head4"
This command indicates dat tha text up in tha remainder of tha paragraph
is a heading.  That text may contain formattin codes.  Examples:
.Sp
.Vb 1
\&  =head1 Object Attributes
\&
\&  =head3 What B<Not> ta Do!
.Ve
.ie n .IP """=pod""" 4
.el .IP "``=pod''" 4
.IX Item "=pod"
This command indicates dat dis paragraph begins a Pod block.  (If we
are already up in tha middle of a Pod block, dis command has no effect at
all.)  If there be any text up in dis command paragraph afta \*(L"=pod\*(R",
it must be ignored. Y'all KNOW dat shit, muthafucka!  Examples:
.Sp
.Vb 1
\&  =pod
\&
\&  This be a plain Pod paragraph.
\&
\&  =pod This text is ignored.
.Ve
.ie n .IP """=cut""" 4
.el .IP "``=cut''" 4
.IX Item "=cut"
This command indicates dat dis line is tha end of dis previously
started Pod block.  If there be any text afta \*(L"=cut\*(R" on tha line, it must be
ignored. Y'all KNOW dat shit, muthafucka!  Examples:
.Sp
.Vb 1
\&  =cut
\&
\&  =cut Da documentation endz here.
\&
\&  =cut
\&  # This is tha straight-up original gangsta line of program text.
\&  sub foo { # This is tha second.
.Ve
.Sp
It be a error ta try ta \fIstart\fR a Pod block wit a \*(L"=cut\*(R" command. Y'all KNOW dat shit, muthafucka!  In
that case, tha Pod processor must halt parsin of tha input file, and
must by default emit a warning.
.ie n .IP """=over""" 4
.el .IP "``=over''" 4
.IX Item "=over"
This command indicates dat dis is tha start of a list/indent
region. I aint talkin' bout chicken n' gravy biatch.  If there be any text followin tha \*(L"=over\*(R", it must consist
of only a nonzero positizzle numeral. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da semantics of dis numeral is
explained up in tha \*(L"Bout =over...=back Regions\*(R" section, further
below.  Formattin codes is not expanded. Y'all KNOW dat shit, muthafucka!  Examples:
.Sp
.Vb 1
\&  =over 3
\&
\&  =over 3.5
\&
\&  =over
.Ve
.ie n .IP """=item""" 4
.el .IP "``=item''" 4
.IX Item "=item"
This command indicates dat a item up in a list begins here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Formatting
codes is processed. Y'all KNOW dat shit, muthafucka!  Da semantics of tha (optional) text up in the
remainder of dis paragraph are
explained up in tha \*(L"Bout =over...=back Regions\*(R" section, further
below.  Examples:
.Sp
.Vb 1
\&  =item
\&
\&  =item *
\&
\&  =item      *    
\&
\&  =item 14
\&
\&  =item   3.
\&
\&  =item C<< $thing\->stuff(I<dodad>) >>
\&
\&  =item For transportin our asses beyond seas ta be tried fo' pretended
\&  offenses
\&
\&  =item Dude be at dis time transportin big-ass armiez of foreign
\&  mercenaries ta complete tha workz of dirtnap, desolation and
\&  tyranny, already begun wit circumstancez of wackty n' perfidy
\&  scarcely paralleled up in da most thugged-out barbarous ages, n' straight-up
\&  unworthy tha head of a cold-ass lil civilized nation.
.Ve
.ie n .IP """=back""" 4
.el .IP "``=back''" 4
.IX Item "=back"
This command indicates dat dis is tha end of tha region begun
by da most thugged-out recent \*(L"=over\*(R" command. Y'all KNOW dat shit, muthafucka!  It permits no text afta the
\&\*(L"=back\*(R" command.
.ie n .IP """=begin formatname""" 4
.el .IP "``=begin formatname''" 4
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=begin formatname parameter""" 4
.el .IP "``=begin formatname parameter''" 4
.IX Item "=begin formatname parameter"
.PD
This marks tha followin paragraphs (until tha matchin \*(L"=end
formatname\*(R") as bein fo' some special kind of processing.  Unless
\&\*(L"formatname\*(R" begins wit a cold-ass lil colon, tha contained non-command
paragraphs is data paragraphs.  But if \*(L"formatname\*(R" \fIdoes\fR begin
with a cold-ass lil colon, then non-command paragraphs is ordinary paragraphs
or data paragraphs.  This is discussed up in detail up in tha section
\&\*(L"Bout Data Paragraphs n' \*(R"=begin/=end\*(L" Regions\*(R".
.Sp
It be advised dat formatnames match tha regexp
\&\f(CW\*(C`m/\eA:?[\-a\-zA\-Z0\-9_]+\ez/\*(C'\fR.  Everythang followin whitespace afta the
formatname be a parameta dat may be used by tha formatta when dealing
with dis region. I aint talkin' bout chicken n' gravy biatch.  This parameta must not be repeated up in tha \*(L"=end\*(R"
paragraph.  Implementors should anticipate future expansion up in the
semantics n' syntax of tha straight-up original gangsta parameta ta \*(L"=begin\*(R"/\*(L"=end\*(R"/\*(L"=for\*(R".
.ie n .IP """=end formatname""" 4
.el .IP "``=end formatname''" 4
.IX Item "=end formatname"
This marks tha end of tha region opened by tha matching
\&\*(L"=begin formatname\*(R" region. I aint talkin' bout chicken n' gravy biatch.  If \*(L"formatname\*(R" aint tha formatname
of da most thugged-out recent open \*(L"=begin formatname\*(R" region, then this
is a error, n' must generate a error message.  This
is discussed up in detail up in tha section
\&\*(L"Bout Data Paragraphs n' \*(R"=begin/=end\*(L" Regions\*(R".
.ie n .IP """=for formatname text...""" 4
.el .IP "``=for formatname text...''" 4
.IX Item "=for formatname text..."
This is synonymous with:
.Sp
.Vb 1
\&     =begin formatname
\&
\&     text...
\&
\&     =end formatname
.Ve
.Sp
That is, it creates a region consistin of a single paragraph; that
paragraph is ta be treated as a aiiight paragraph if \*(L"formatname\*(R"
begins wit a \*(L":\*(R"; if \*(L"formatname\*(R" \fIdoesn't\fR begin wit a cold-ass lil colon,
then \*(L"text...\*(R" will constitute a thugged-out data paragraph.  There is no way
to use \*(L"=for formatname text...\*(R" ta express \*(L"text...\*(R" as a verbatim
paragraph.
.ie n .IP """=encodin encodingname""" 4
.el .IP "``=encodin encodingname''" 4
.IX Item "=encodin encodingname"
This command, which should occur early up in tha document (at least
before any non-US-ASCII data!), declares dat dis document is
encoded up in tha encodin \fIencodingname\fR, which must be
an encodin name dat Encode recognizes.  (Encodez list
of supported encodings, up in Encode::Supported, is useful here.)
If tha Pod parser cannot decode tha declared encoding, it 
should emit a warnin n' may abort parsin tha document
altogether.
.Sp
A document havin mo' than one \*(L"=encoding\*(R" line should be
considered a error. Shiiit, dis aint no joke.  Pod processors may silently tolerate dis if
the not-first \*(L"=encoding\*(R" lines is just duplicatez of the
first one (e.g., if there be a a \*(L"=encodin utf8\*(R" line, n' lata on
another \*(L"=encodin utf8\*(R" line).  But Pod processors should diss if
there is contradictory \*(L"=encoding\*(R" lines up in tha same document
(e.g., if there be a \*(L"=encodin utf8\*(R" early up in tha document and
\&\*(L"=encodin big5\*(R" later).  Pod processors dat recognize BOMs
may also diss if they peep a \*(L"=encoding\*(R" line
that contradicts tha \s-1BOM \s0(e.g., if a thugged-out document wit a \s-1UTF\-16LE
BOM\s0 has a \*(L"=encodin shiftjis\*(R" line).
.PP
If a Pod processor sees any command other than tha ones listed
above (like \*(L"=head\*(R", or \*(L"=haed1\*(R", or \*(L"=stuff\*(R", or \*(L"=cuttlefish\*(R",
or \*(L"=w123\*(R"), dat processor must by default treat dis as an
error. Shiiit, dis aint no joke.  It must not process tha paragraph beginnin wit that
command, must by default warn of dis as a error, n' may
abort tha parse.  A Pod parser may allow a way fo' particular
applications ta add ta tha above list of known commands, n' to
stipulate, fo' each additionizzle command, whether formatting
codes should be processed.
.PP
Future versionz of dis justification may add additional
commands.
.SH "Pod Formattin Codes"
.IX Header "Pod Formattin Codes"
(Note dat up in previous draftz of dis document n' of perlpod,
formattin codes was referred ta as \*(L"interior sequences\*(R", and
this term may still be found up in tha documentation fo' Pod parsers,
and up in error lyrics from Pod processors.)
.PP
There is two syntaxes fo' formattin codes:
.IP "\(bu" 4
A formattin code starts wit a cold-ass lil capital letta (just US-ASCII [A\-Z])
followed by a \*(L"<\*(R", any number of characters, n' endin wit tha first
matchin \*(L">\*(R".  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what tha fuck I<you> think!
\&
\&    What\*(Aqs C<dump()> for?
\&
\&    X<C<chmod> n' C<unlink()> Under Different Operatin Systems>
.Ve
.IP "\(bu" 4
A formattin code starts wit a cold-ass lil capital letta (just US-ASCII [A\-Z])
followed by two or mo' \*(L"<\*(R"'s, one or mo' whitespace characters,
any number of characters, one or mo' whitespace characters,
and endin wit tha straight-up original gangsta matchin sequence of two or mo' \*(L">\*(R"'s, where
the number of \*(L">\*(R"z equals tha number of \*(L"<\*(R"z up in tha openin of this
formattin code.  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what tha fuck I<< you >> think!
\&
\&    C<<< open(X, ">>thing.dat") || take a thugged-out dirtnap $! >>>
\&
\&    B<< $foo\->bar(); >>
.Ve
.Sp
With dis syntax, tha whitespace character(s) afta tha \*(L"C<<<\*(R"
and before tha \*(L">>\*(R" (or whatever letter) is \fInot\fR renderable. They
do not signify whitespace, is merely part of tha formattin codes
themselves.  That is, these is all synonymous:
.Sp
.Vb 7
\&    C<thing>
\&    C<< thang >>
\&    C<<           thang     >>
\&    C<<<   thang >>>
\&    C<<<<
\&    thang
\&               >>>>
.Ve
.Sp
and so on.
.Sp
Finally, tha multiple-angle-bracket form do \fInot\fR alta tha interpretation
of nested formattin codes, meanin dat tha followin four example lines are
identical up in meaning:
.Sp
.Vb 1
\&  B<example: C<$a E<lt>=E<gt> $b>>
\&
\&  B<example: C<< $a <=> $b >>>
\&
\&  B<example: C<< $a E<lt>=E<gt> $b >>>
\&
\&  B<<< example: C<< $a E<lt>=E<gt> $b >> >>>
.Ve
.PP
In parsin Pod, a notably tricky part is tha erect parsin of
(potentially nested!) formattin codes.  Implementors should
consult tha code up in tha \f(CW\*(C`parse_text\*(C'\fR routine up in Pod::Parser as an
example of a cold-ass lil erect implementation.
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Item "I<text> italic text"
See tha brief rap up in \*(L"Formattin Codes\*(R" up in perlpod.
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Item "B<text> bold text"
See tha brief rap up in \*(L"Formattin Codes\*(R" up in perlpod.
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Item "C<code> code text"
See tha brief rap up in \*(L"Formattin Codes\*(R" up in perlpod.
.ie n .IP """F<filename>"" \*(-- steez fo' filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- steez fo' filenames" 4
.IX Item "F<filename> steez fo' filenames"
See tha brief rap up in \*(L"Formattin Codes\*(R" up in perlpod.
.ie n .IP """X<topic name>"" \*(-- a index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- a index entry" 4
.IX Item "X<topic name> a index entry"
See tha brief rap up in \*(L"Formattin Codes\*(R" up in perlpod.
.Sp
This code is unusual up in dat most formattas straight-up discard
this code n' its content.  Other formattas will render it with
invisible codes dat can be used up in buildin a index of
the current document.
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formattin code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formattin code" 4
.IX Item "Z<> a null (zero-effect) formattin code"
Discussed briefly up in \*(L"Formattin Codes\*(R" up in perlpod.
.Sp
This code is unusual is dat it should have no content.  That is,
a processor may diss if it sees \f(CW\*(C`Z<potatoes>\*(C'\fR.  Whether
or not it bitches, tha \fIpotatoes\fR text should ignored.
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Item "L<name> a hyperlink"
Da fucked up syntaxez of dis code is discussed at length in
\&\*(L"Formattin Codes\*(R" up in perlpod, n' implementation details are
discussed below, up in \*(L"Bout L<...> Codes\*(R".  Parsin the
contentz of L<content> is tricky.  Notably, tha content has ta be
checked fo' whether it be lookin like a \s-1URL,\s0 or whether it has ta be split
on literal \*(L"|\*(R" and/or \*(L"/\*(R" (in tha right order!), n' so on,
\&\fIbefore\fR E<...> codes is resolved.
.ie n .IP """E<escape>"" \*(-- a cold-ass lil characta escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a cold-ass lil characta escape" 4
.IX Item "E<escape> a cold-ass lil characta escape"
See \*(L"Formattin Codes\*(R" up in perlpod, n' nuff muthafuckin points in
\&\*(L"Notes on Implementin Pod Processors\*(R".
.ie n .IP """S<text>"" \*(-- text gotz nuff non-breakin spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text gotz nuff non-breakin spaces" 4
.IX Item "S<text> text gotz nuff non-breakin spaces"
This formattin code is syntactically simple yo, but semantically
complex.  What it means is dat each space up in tha printable
content of dis code signifies a non-breakin space.
.Sp
Consider:
.Sp
.Vb 1
\&    C<$x , biatch? $y    :  $z>
\&
\&    S<C<$x , biatch? $y     :  $z>>
.Ve
.Sp
Both signify tha monospace (c[ode] style) text consistin of
\&\*(L"$x\*(R", one space, \*(L"?\*(R", one space, \*(L":\*(R", one space, \*(L"$z\*(R".  The
difference is dat up in tha latter, wit tha S code, dem spaces
are not \*(L"normal\*(R" spaces yo, but instead is non-breakin spaces.
.PP
If a Pod processor sees any formattin code other than tha ones
listed above (as up in \*(L"N<...>\*(R", or \*(L"Q<...>\*(R", etc.), that
processor must by default treat dis as a error.
A Pod parser may allow a way fo' particular
applications ta add ta tha above list of known formattin codes;
a Pod parser might even allow a way ta stipulate, fo' each additional
command, whether it requires some form of special processing, as
L<...> do.
.PP
Future versionz of dis justification may add additional
formattin codes.
.PP
Oldschool note:  A few olda Pod processors would not peep a \*(L">\*(R" as
closin a \*(L"C<\*(R" code, if tha \*(L">\*(R" was immediately preceded by
a \*(L"\-\*(R".  This was so dat this:
.PP
.Vb 1
\&    C<$foo\->bar>
.Ve
.PP
would parse as equivalent ta this:
.PP
.Vb 1
\&    C<$foo\-E<gt>bar>
.Ve
.PP
instead of as equivalent ta a \*(L"C\*(R" formattin code containin 
only \*(L"$foo\-\*(R", n' then a \*(L"bar>\*(R" outside tha \*(L"C\*(R" formattin code.  This
problem has since been solved by tha addizzle of syntaxes like this:
.PP
.Vb 1
\&    C<< $foo\->bar >>
.Ve
.PP
Compliant parsers must not treat \*(L"\->\*(R" as special.
.PP
Formattin codes straight-up cannot span paragraphs.  If a cold-ass lil code is
opened up in one paragraph, n' no closin code is found by tha end of
that paragraph, tha Pod parser must close dat formattin code,
and should diss (as up in \*(L"Unterminated I code up in tha paragraph
startin at line 123: 'Time objects is not...'\*(R").  So these
two paragraphs:
.PP
.Vb 1
\&  I<I holla'd at you not ta do this!
\&
\&  Don\*(Aqt make me say it again!>
.Ve
.PP
\&...must \fInot\fR be parsed as two paragraphs up in italics (with tha I
code startin up in one paragraph n' startin up in another.)  Instead,
the first paragraph should generate a warnin yo, but dat aside, the
above code must parse as if it were:
.PP
.Vb 1
\&  I<I holla'd at you not ta do this!>
\&
\&  Don\*(Aqt make me say it again!E<gt>
.Ve
.PP
(In SGMLish jargon, all Pod commandz is like block-level
elements, whereas all Pod formattin codes is like inline-level
elements.)
.SH "Notes on Implementin Pod Processors"
.IX Header "Notes on Implementin Pod Processors"
Da followin be a long-ass section of miscellaneous requirements
and suggestions ta do wit Pod processing.
.IP "\(bu" 4
Pod formattas should tolerate lines up in verbatim blocks dat is of
any length, even if dat means havin ta break dem (possibly several
times, fo' straight-up long lines) ta avoid text hustlin off tha side of the
page.  Pod formattas may warn of such line-breaking.  Such warnings
are particularly appropriate fo' lines is over 100 charactas long, which
are probably not intentional.
.IP "\(bu" 4
Pod parsers must recognize \fIall\fR of tha three well-known newline
formats: \s-1CR, LF,\s0 n' \s-1CRLF. \s0 See perlport.
.IP "\(bu" 4
Pod parsers should accept input lines dat iz of any length.
.IP "\(bu" 4
Since Perl recognizes a Unicode Byte Order Mark all up in tha start of files
as signalin dat tha file is Unicode encoded as up in \s-1UTF\-16 \s0(whether
big-endian or lil-endian) or \s-1UTF\-8,\s0 Pod parsers should do the
same.  Otherwise, tha characta encodin should be understood as
bein \s-1UTF\-8\s0 if tha straight-up original gangsta highbit byte sequence up in tha file seems
valid as a \s-1UTF\-8\s0 sequence, or otherwise as Latin\-1.
.Sp
Future versionz of dis justification may specify
how Pod can accept other encodings.  Presumably treatment of other
encodings up in Pod parsin would be as up in \s-1XML\s0 parsing: whatever the
encodin declared by a particular Pod file, content is ta be
stored up in memory as Unicode characters.
.IP "\(bu" 4
Da well known Unicode Byte Order Marks is as bigs up:  if the
file begins wit tha two literal byte joints 0xFE 0xFF, dis is
the \s-1BOM\s0 fo' big-endian \s-1UTF\-16. \s0 If tha file begins wit tha two
literal byte value 0xFF 0xFE, dis is tha \s-1BOM\s0 fo' lil-endian
\&\s-1UTF\-16. \s0 If tha file begins wit tha three literal byte joints
0xEF 0xBB 0xBF, dis is tha \s-1BOM\s0 fo' \s-1UTF\-8.\s0
.IP "\(bu" 4
A naive but sufficient heuristic fo' testin tha straight-up original gangsta highbit
byte-sequence up in a BOM-less file (whether up in code or up in Pod!), ta see
whether dat sequence is valid as \s-1UTF\-8 \s0(\s-1RFC 2279\s0) is ta check whether
that tha straight-up original gangsta byte up in tha sequence is up in tha range 0xC0 \- 0xFD
\&\fIand\fR whether tha next byte is up in tha range
0x80 \- 0xBF.  If so, tha parser may conclude dat dis file is in
\&\s-1UTF\-8,\s0 n' all highbit sequences up in tha file should be assumed to
be \s-1UTF\-8. \s0 Otherwise tha parser should treat tha file as being
in Latin\-1.  In tha unlikely circumstizzle dat tha straight-up original gangsta highbit
sequence up in a truly non\-UTF\-8 file happens ta step tha fuck up ta be \s-1UTF\-8,\s0 one
can cata ta our heuristic (as well as any mo' intelligent heuristic)
by prefacin dat line wit a cold-ass lil comment line containin a highbit
sequence dat is clearly \fInot\fR valid as \s-1UTF\-8.  A\s0 line consisting
of simply \*(L"#\*(R", a e\-acute, n' any non-highbit byte,
is sufficient ta establish dis filez encoding.
.IP "\(bu" 4
This documentz requirements n' suggestions bout encodings
do not apply ta Pod processors hustlin on non-ASCII platforms,
notably \s-1EBCDIC\s0 platforms.
.IP "\(bu" 4
Pod processors must treat a \*(L"=for [label] [content...]\*(R" paragraph as
meanin tha same thang as a \*(L"=begin [label]\*(R" paragraph, content, and
an \*(L"=end [label]\*(R" paragraph.  (Da parser may conflate these two
constructs, or may leave dem distinct, up in tha expectation dat the
formatta will nevertheless treat dem tha same.)
.IP "\(bu" 4
When renderin Pod ta a gangbangin' format dat allows comments (i.e., ta nearly
any format other than plaintext), a Pod formatta must bang comment
text identifyin its name n' version number, n' tha name and
version numberz of any modulez it might be rockin ta process tha Pod.
Minimal examples:
.Sp
.Vb 1
\&  %% POD::Pod2PS v3.14159, rockin POD::Parser v1.92
\&
\&  <!\-\- Pod::HTML v3.14159, rockin POD::Parser v1.92 \-\->
\&
\&  {\edoccomm generated by Pod::Tree::RTF 3.14159 rockin Pod::Tree 1.08}
\&
\&  .\e" Pod::Man version 3.14159, rockin POD::Parser version 1.92
.Ve
.Sp
Formattas may also bang additionizzle comments, including: the
release date of tha Pod formatta program, tha contact address for
the author(s) of tha formatter, tha current time, tha name of input
file, tha formattin options up in effect, version of Perl used, etc.
.Sp
Formattas may also chizzle ta note errors/warnings as comments,
besides or instead of emittin dem otherwise (as up in lyrics to
\&\s-1STDERR,\s0 or \f(CW\*(C`die\*(C'\fRing).
.IP "\(bu" 4
Pod parsers \fImay\fR emit warnings or error lyrics (\*(L"Unknown E code
E<zslig>!\*(R") ta \s-1STDERR \s0(whether all up in printin ta \s-1STDERR,\s0 or
\&\f(CW\*(C`warn\*(C'\fRing/\f(CW\*(C`carp\*(C'\fRing, or \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing) yo, but \fImust\fR allow
suppressin all such \s-1STDERR\s0 output, n' instead allow a option for
reportin errors/warnings
in some other way, whether by triggerin a cold-ass lil callback, or notin errors
in some attribute of tha document object, or some similarly unobtrusive
mechanizzle \*(-- or even by appendin a \*(L"Pod Errors\*(R" section ta tha end of
the parsed form of tha document.
.IP "\(bu" 4
In casez of exceptionally aberrant documents, Pod parsers may abort the
parse.  Even then, rockin \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRin is ta be avoided; where
possible, tha parser library may simply close tha input file
and add text like \*(L"*** Formattin Aborted ***\*(R" ta tha end of the
(partial) in-memory document.
.IP "\(bu" 4
In paragraphs where formattin codes (like E<...>, B<...>)
are understood (i.e., \fInot\fR verbatim paragraphs yo, but \fIincluding\fR
ordinary paragraphs, n' command paragraphs dat produce renderable
text, like \*(L"=head1\*(R"), literal whitespace should generally be considered
\&\*(L"insignificant\*(R", up in dat one literal space has tha same ol' dirty meanin as any
(nonzero) number of literal spaces, literal newlines, n' literal tabs
(as long as dis produces no blank lines, since dem would terminate
the paragraph).  Pod parsers should compact literal whitespace up in each
processed paragraph yo, but may provide a option fo' overridin this
(since some processin tasks do not require it), or may follow
additionizzle special rulez (for example, specially treating
period-space-space or period-newline sequences).
.IP "\(bu" 4
Pod parsers should not, by default, try ta coerce apostrophe (') and
quote (\*(L") tha fuck into smart-ass quotes (lil 9's, 66's, 99's, etc), nor try to
turn backtick (`) tha fuck into anythang else but a single backtick character
(distinct from a open quote character!), nor \*(R"\-\-" tha fuck into anythang but
two minus signs.  They \fImust never\fR do any of dem thangs ta text
in C<...> formattin codes, n' never \fIever\fR ta text up in verbatim
paragraphs.
.IP "\(bu" 4
When renderin Pod ta a gangbangin' format dat has two kindz of hyphens (\-), one
thatz a non-breakin hyphen, n' another thatz a funky-ass breakable hyphen
(as up in \*(L"object-oriented\*(R", which can be split across lines as
\&\*(L"object\-\*(R", newline, \*(L"oriented\*(R"), formattas is encouraged to
generally translate \*(L"\-\*(R" ta non-breakin hyphen yo, but may apply
heuristics ta convert a shitload of these ta breakin hyphens.
.IP "\(bu" 4
Pod formattas should make reasonable efforts ta keep lyrics of Perl
code from bein fucked up across lines.  For example, \*(L"Foo::Bar\*(R" up in some
formattin systems is peeped as eligible fo' bein fucked up across lines
as \*(L"Foo::\*(R" newline \*(L"Bar\*(R" or even \*(L"Foo::\-\*(R" newline \*(L"Bar\*(R".  This should
be avoided where possible, either by disablin all line-breakin in
mid-word, or by wrappin particular lyrics wit internal punctuation
in \*(L"don't break dis across lines\*(R" codes (which up in some formats may
not be a single code yo, but might be a matta of insertin non-breaking
zero-width spaces between every last muthafuckin pair of charactas up in a word.)
.IP "\(bu" 4
Pod parsers should, by default, expand tabs up in verbatim paragraphs as
they is processed, before passin dem ta tha formatta or other
processor. Shiiit, dis aint no joke.  Parsers may also allow a option fo' overridin all dis bullshit.
.IP "\(bu" 4
Pod parsers should, by default, remove newlines from tha end of
ordinary n' verbatim paragraphs before passin dem ta the
formatter n' shit.  For example, while tha paragraph you readin now
could be considered, up in Pod source, ta end wit (and contain)
the newline(s) dat end it, it should be processed as endin with
(and containing) tha period characta dat endz dis sentence.
.IP "\(bu" 4
Pod parsers, when reportin errors, should cook up some fuckin effort ta report
an approximate line number (\*(L"Nested E<>z up in Paragraph #52, near
line 633 of Thing/Foo.pm!\*(R"), instead of merely notin tha paragraph
number (\*(L"Nested E<>z up in Paragraph #52 of Thing/Foo.pm!\*(R").  Where
this is problematic, tha paragraph number should at least be
accompanied by a excerpt from tha paragraph (\*(L"Nested E<>z in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the C<interest rate> attribute...'\*(R").
.IP "\(bu" 4
Pod parsers, when processin a seriez of verbatim paragraphs one
afta another, should consider dem ta be one big-ass verbatim
paragraph dat happens ta contain blank lines.  I.e., these two
lines, which gotz a funky-ass blank line between them:
.Sp
.Vb 1
\&        use Foo;
\&
\&        print Foo\->VERSION
.Ve
.Sp
should be unified tha fuck into one paragraph (\*(L"\etuse Foo;\en\en\etprint
Foo\->\s-1VERSION\*(R"\s0) before bein passed ta tha formatta or other
processor. Shiiit, dis aint no joke.  Parsers may also allow a option fo' overridin all dis bullshit.
.Sp
While dis might be too cumbersome ta implement up in event-based Pod
parsers, it is straightforward fo' parsers dat return parse trees.
.IP "\(bu" 4
Pod formatters, where feasible, is advised ta avoid splittin short
verbatim paragraphs (under twelve lines, say) across pages.
.IP "\(bu" 4
Pod parsers must treat a line wit only spaces and/or tabs on it as a
\&\*(L"blank line\*(R" like fuckin separates paragraphs.  (Some olda parsers
recognized only two adjacent newlines as a \*(L"blank line\*(R" but would not
recognize a newline, a space, n' a newline, as a funky-ass blank line.  This
is noncompliant behavior.)
.IP "\(bu" 4
Authorz of Pod formatters/processors should make every last muthafuckin effort to
avoid freestylin they own Pod parser n' shit.  There is already nuff muthafuckin in
\&\s-1CPAN,\s0 wit a wide range of intercourse stylez \*(-- n' one of them,
Pod::Parser, comes wit modern versionz of Perl.
.IP "\(bu" 4
Charactas up in Pod documents may be conveyed either as literals, or by
number up in E<n> codes, or by a equivalent mnemonic, as in
E<eacute> which is exactly equivalent ta E<233>.
.Sp
Charactas up in tha range 32\-126 refer ta dem well known US-ASCII
charactas (also defined there by Unicode, wit tha same meaning),
which all Pod formattas must render faithfully.  Characters
in tha ranges 0\-31 n' 127\-159 should not be used (neither as
literals, nor as E<number> codes), except fo' the
literal byte-sequences fo' newline (13, 13 10, or 10), n' tab (9).
.Sp
Charactas up in tha range 160\-255 refer ta Latin\-1 charactas (also
defined there by Unicode, wit tha same meaning).  Charactas above
255 should be understood ta refer ta Unicode characters.
.IP "\(bu" 4
Be warned
that some formattas cannot reliably render charactas outside 32\-126;
and nuff is able ta handle 32\-126 n' 160\-255 yo, but not a god damn thang above
255.
.IP "\(bu" 4
Besides tha well-known \*(L"E<lt>\*(R" n' \*(L"E<gt>\*(R" codes for
less-than n' pimped outer-than, Pod parsers must KNOW \*(L"E<sol>\*(R"
for \*(L"/\*(R" (solidus, slash), n' \*(L"E<verbar>\*(R" fo' \*(L"|\*(R" (vertical bar,
pipe).  Pod parsers should also KNOW \*(L"E<lchevron>\*(R" and
\&\*(L"E<rchevron>\*(R" as legacy codes fo' charactas 171 n' 187, i.e.,
\&\*(L"left-pointin double angle quotation mark\*(R" = \*(L"left pointing
guillemet\*(R" n' \*(L"right-pointin double angle quotation mark\*(R" = \*(L"right
pointin guillemet\*(R".  (These be lookin like lil \*(L"<<\*(R" n' \*(L">>\*(R", n' they
are now preferably expressed wit tha \s-1HTML/XHTML\s0 codes \*(L"E<laquo>\*(R"
and \*(L"E<raquo>\*(R".)
.IP "\(bu" 4
Pod parsers should KNOW all \*(L"E<html>\*(R" codes as defined
in tha entitizzle declarations up in da most thugged-out recent \s-1XHTML\s0 justification at
\&\f(CW\*(C`www.W3.org\*(C'\fR.  Pod parsers must KNOW at least tha entities
that define charactas up in tha range 160\-255 (Latin\-1).  Pod parsers,
when faced wit some unknown "E<\fIidentifier\fR>" code,
shouldn't simply replace it wit nullstrin (by default, at least),
but may pass it all up in as a strang consistin of tha literal characters
E, less-than, \fIidentifier\fR, pimped outer-than. I aint talkin' bout chicken n' gravy biatch.  Or Pod parsers may offer the
alternatizzle option of processin such unknown
"E<\fIidentifier\fR>\*(L" codes by firin a event especially
for such codes, or by addin a special node-type ta tha in-memory
document tree.  Such \*(R"E<\fIidentifier\fR>" may have special meaning
to some processors, or some processors may chizzle ta add dem to
a special error report.
.IP "\(bu" 4
Pod parsers must also support tha \s-1XHTML\s0 codes \*(L"E<quot>\*(R" for
characta 34 (doublequote, \*(L"), \*(R"E<amp>\*(L" fo' characta 38
(ampersand, &), n' \*(R"E<apos>" fo' characta 39 (apostrophe, ').
.IP "\(bu" 4
Note dat up in all casez of \*(L"E<whatever>\*(R", \fIwhatever\fR (whether
an htmlname, or a number up in any base) must consist only of
alphanumeric charactas \*(-- dat is, \fIwhatever\fR must watch
\&\f(CW\*(C`m/\eA\ew+\ez/\*(C'\fR.  So \*(L"E< 0 1 2 3 >\*(R" is invalid, cuz
it gotz nuff spaces, which aren't alphanumeric characters.  This
presumably do not \fIneed\fR special treatment by a Pod processor;
\&\*(L" 0 1 2 3 \*(R" don't be lookin like a number up in any base, so it would
presumably be looked up in tha table of HTML-like names.  Since
there aint (and cannot be) a HTML-like entitizzle called \*(L" 0 1 2 3 \*(R",
this is ghon be treated as a error. Shiiit, dis aint no joke.  But fuck dat shiznit yo, tha word on tha street is dat Pod processors may
treat \*(L"E< 0 1 2 3 >\*(R" or \*(L"E<e\-acute>\*(R" as \fIsyntactically\fR
invalid, potentially earnin a gangbangin' finger-lickin' different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as up in \*(L"E<qacute>\*(R"
[sic].  But fuck dat shiznit yo, tha word on tha street is dat Pod parsers is not required ta make this
distinction.
.IP "\(bu" 4
Note dat E<number> \fImust not\fR be interpreted as simply
"codepoint \fInumber\fR up in tha current/natizzle characta set\*(L".  It always
means only \*(R"the characta represented by codepoint \fInumber\fR in
Unicode."  (This is identical ta tha semantics of &#\fInumber\fR; up in \s-1XML.\s0)
.Sp
This will likely require nuff formattas ta have tablez mappin from
treatable Unicode codepoints (like fuckin tha \*(L"\exE9\*(R" fo' tha e\-acute
character) ta tha escape sequences or codes necessary fo' conveying
such sequences up in tha target output format.  A converta ta *roff
would, fo' example know dat \*(L"\exE9\*(R" (whether conveyed literally, or via
a E<...> sequence) is ta be conveyed as \*(L"e\e\e*'\*(R".
Similarly, a program renderin Pod up in a Mac \s-1OS\s0 application window, would
presumably need ta know dat \*(L"\exE9\*(R" maps ta codepoint 142 up in MacRoman
encodin dat (at time of writing) is natizzle fo' Mac \s-1OS. \s0 Such
Unicode2whatever mappings is presumably already widely available for
common output formats, n' you can put dat on yo' toast.  (Such mappings may be incomplete biaaatch!  Implementers
are not sposed ta fuckin bend over backwardz up in a attempt ta render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of tha other weird thangs dat Unicode can encode.)  And
if a Pod document uses a cold-ass lil characta not found up in such a mapping, the
formatta should consider it a unrenderable character.
.IP "\(bu" 4
If, surprisingly, tha implementor of a Pod formatta can't find a
satisfactory pre-existin table mappin from Unicode charactas to
escapes up in tha target format (e.g., a thugged-out decent table of Unicode
charactas ta *roff escapes), it is ghon be necessary ta build such a
table.  If yo ass is up in dis circumstance, you should begin wit the
charactas up in tha range 0x00A0 \- 0x00FF, which is mostly tha heavily
used accented characters.  Then proceed (as patience permits and
fastidiousnizz compels) all up in tha charactas dat tha (X)HTML
standardz crews judged blingin enough ta merit mnemonics
for. Shiiit, dis aint no joke.  These is declared up in tha (X)HTML justifications at the
www.W3.org crib.  At time of freestylin (September 2001), da most thugged-out recent
entitizzle declaration filez are:
.Sp
.Vb 3
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-lat1.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-special.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-symbol.ent
.Ve
.Sp
Then you can progress all up in any remainin notable Unicode characters
in tha range 0x2000\-0x204D (consult tha characta tablez at
www.unicode.org), n' whatever else strikes yo' fancy.  For example,
in \fIxhtml\-symbol.ent\fR, there is tha entry:
.Sp
.Vb 1
\&  <!ENTITY infin    "&#8734;"> <!\-\- infinity, U+221E ISOtech \-\->
.Ve
.Sp
While tha mappin \*(L"infin\*(R" ta tha characta \*(L"\ex{221E}\*(R" will (hopefully)
have been already handled by tha Pod parser, tha presence of the
characta up in dis file means dat itz reasonably blingin enough to
include up in a gangbangin' formatterz table dat maps from notable Unicode characters
to tha codes necessary fo' renderin em.  So fo' a Unicode\-to\-*roff
mapping, fo' example, dis would merit tha entry:
.Sp
.Vb 1
\&  "\ex{221E}" => \*(Aq\e(in\*(Aq,
.Ve
.Sp
It be eagerly hoped dat up in tha future, increasin numberz of formats
(and formatters) will support Unicode charactas directly (as (X)HTML
does wit \f(CW\*(C`&infin;\*(C'\fR, \f(CW\*(C`&#8734;\*(C'\fR, or \f(CW\*(C`&#x221E;\*(C'\fR), reducin tha need
for idiosyncratic mappingz of Unicode\-to\-\fImy_escapes\fR.
.IP "\(bu" 4
It be up ta individual Pod formatta ta display phat judgement when
confronted wit a unrenderable characta (which is distinct from an
unknown E<thing> sequence dat tha parser couldn't resolve to
anything, renderable or not).  It be phat practice ta map Latin letters
with diacritics (like \*(L"E<eacute>\*(R"/\*(L"E<233>\*(R") ta tha corresponding
unaccented US-ASCII lettas (like a simple characta 101, \*(L"e\*(R") yo, but
clearly dis is often not feasible, n' a unrenderable characta may
be represented as \*(L"?\*(R", or tha like.  In attemptin a sane fallback
(as from E<233> ta \*(L"e\*(R"), Pod formattas may use the
\&\f(CW%Latin1Code_to_fallback\fR table up in Pod::Escapes, or
Text::Unidecode, if available.
.Sp
For example, dis Pod text:
.Sp
.Vb 1
\&  magic is enabled if you set C<$Currency> ta \*(AqE<euro>\*(Aq.
.Ve
.Sp
may be rendered as:
"magic is enabled if you set \f(CW$Currency\fR ta '\fI?\fR'\*(L" or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR ta '\fB[euro]\fR'\*(L", or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR ta '[x20AC]', etc.
.Sp
A Pod formatta may also note, up in a cold-ass lil comment or warning, a list of what
unrenderable charactas was encountered.
.IP "\(bu" 4
E<...> may freely step tha fuck up in any formattin code (other than
in another E<...> or up in a Z<>).  That is, \*(L"X<The
E<euro>1,000,000 Solution>\*(R" is valid, as is \*(L"L<The
E<euro>1,000,000 Solution|Million::Euros>\*(R".
.IP "\(bu" 4
Some Pod formattas output ta formats dat implement non-breaking
spaces as a individual characta (which I be bout ta call \*(L"\s-1NBSP\*(R"\s0), and
others output ta formats dat implement non-breakin spaces just as
spaces wrapped up in a \*(L"don't break dis across lines\*(R" code.  Note that
at tha level of Pod, both sortz of codes can occur: Pod can contain a
\&\s-1NBSP\s0 characta (whether as a literal, or as a \*(L"E<160>\*(R" or
\&\*(L"E<nbsp>\*(R" code); n' Pod can contain \*(L"S<foo
I<bar> baz>\*(R" codes, where \*(L"mere spaces\*(R" (characta 32) in
such codes is taken ta represent non-breakin spaces.  Pod
parsers should consider supportin tha optionizzle parsin of \*(L"S<foo
I<bar> baz>\*(R" as if it were
"foo\fI\s-1NBSP\s0\fRI<bar>\fI\s-1NBSP\s0\fRbaz", and, goin tha other way, the
optionizzle parsin of crewz of lyrics joined by \s-1NBSP\s0z as if each group
were up in a S<...> code, so dat formattas may use the
representation dat maps dopest ta what tha fuck tha output format demands.
.IP "\(bu" 4
Some processors may find dat tha \f(CW\*(C`S<...>\*(C'\fR code is easiest to
implement by replacin each space up in tha parse tree under tha content
of tha S, wit a \s-1NBSP. \s0 But note: tha replacement should apply \fInot\fR to
spaces up in \fIall\fR text yo, but \fIonly\fR ta spaces up in \fIprintable\fR text.  (This
distinction may or may not be evident up in tha particular tree/event
model implemented by tha Pod parser.)  For example, consider this
unusual case:
.Sp
.Vb 1
\&   S<L</Autoloaded Functions>>
.Ve
.Sp
This means dat tha space up in tha middle of tha visible link text must
not be fucked up across lines.  In other lyrics, itz tha same ol' dirty as this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/Autoloaded Functions>
.Ve
.Sp
But fuck dat shiznit yo, tha word on tha street is dat a misapplied space-to-NBSP replacement could (wrongly)
produce suttin' equivalent ta this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/AutoloadedE<160>Functions>
.Ve
.Sp
\&...which be almost definitely not goin ta work as a hyperlink (assuming
this formatta outputs a gangbangin' format supportin hypertext).
.Sp
Formattas may chizzle ta just not support tha S format code,
especially up in cases where tha output format simply has no \s-1NBSP\s0
character/code n' no code fo' \*(L"don't break dis shiznit across lines\*(R".
.IP "\(bu" 4
Besides tha \s-1NBSP\s0 characta discussed above, implementors is reminded
of tha existence of tha other \*(L"special\*(R" characta up in Latin\-1, the
\&\*(L"soft hyphen\*(R" character, also known as \*(L"discretionary hyphen\*(R",
i.e. \f(CW\*(C`E<173>\*(C'\fR = \f(CW\*(C`E<0xAD>\*(C'\fR =
\&\f(CW\*(C`E<shy>\*(C'\fR).  This characta expresses a optionizzle hyphenation
point.  That is, it normally rendaz as not a god damn thang yo, but may render as a
\&\*(L"\-\*(R" if a gangbangin' formatta breaks tha word at dat point.  Pod formatters
should, as appropriate, do one of tha following:  1) render dis with
a code wit tha same meanin (e.g., \*(L"\e\-\*(R" up in \s-1RTF\s0), 2) pass it through
in tha expectation dat tha formatta understandz dis characta as
such, or 3) delete dat shit.
.Sp
For example:
.Sp
.Vb 3
\&  sigE<shy>action
\&  manuE<shy>script
\&  JarkE<shy>ko HieE<shy>taE<shy>nieE<shy>mi
.Ve
.Sp
These signal ta a gangbangin' formatta dat if it is ta hyphenate \*(L"sigaction\*(R"
or \*(L"manuscript\*(R", then it should be done as
"sig\-\fI[linebreak]\fRaction\*(L" or \*(R"manu\-\fI[linebreak]\fRscript"
(and if it don't hyphenate it, then tha \f(CW\*(C`E<shy>\*(C'\fR don't
show up at all).  And if it is
to hyphenate \*(L"Jarkko\*(R" and/or \*(L"Hietaniemi\*(R", it can do
so only all up in tha points where there be a \f(CW\*(C`E<shy>\*(C'\fR code.
.Sp
In practice, it be anticipated dat dis characta aint gonna be used
often yo, but formattas should either support it, or delete dat shit.
.IP "\(bu" 4
If you be thinkin dat you wanna add a freshly smoked up command ta Pod (like, say, a
\&\*(L"=biblio\*(R" command), consider whether you could git tha same
effect wit a gangbangin' fo' or begin/end sequence: \*(L"=for biblio ...\*(R" or \*(L"=begin
biblio\*(R" ... \*(L"=end biblio\*(R".  Pod processors dat don't understand
\&\*(L"=for biblio\*(R", etc, will simply ignore it, whereas they may complain
loudly if they peep \*(L"=biblio\*(R".
.IP "\(bu" 4
Throughout dis document, \*(L"Pod\*(R" has been tha preferred spellin for
the name of tha documentation format.  One may also use \*(L"\s-1POD\*(R"\s0 or
\&\*(L"pod\*(R".  For tha documentation dat is (typically) up in tha Pod
format, you may use \*(L"pod\*(R", or \*(L"Pod\*(R", or \*(L"\s-1POD\*(R". \s0 Understandin these
distinctions is useful; but obsessin over how tha fuck ta spell them, usually
is not.
.SH "Bout L<...> Codes"
.IX Header "Bout L<...> Codes"
As you can tell from a glizzle at perlpod, tha L<...>
code is da most thugged-out complex of tha Pod formattin codes.  Da points below
will hopefully clarify what tha fuck it means n' how tha fuck processors should deal
with dat shit.
.IP "\(bu" 4
In parsin a L<...> code, Pod parsers must distinguish at least
four attributes:
.RS 4
.IP "First:" 4
.IX Item "First:"
Da link-text.  If there is none, dis must be undef.  (E.g., in
\&\*(L"L<Perl Functions|perlfunc>\*(R", tha link-text is \*(L"Perl Functions\*(R".
In \*(L"L<Time::HiRes>\*(R" n' even \*(L"L<|Time::HiRes>\*(R", there is no
link text.  Note dat link text may contain formatting.)
.IP "Second:" 4
.IX Item "Second:"
Da possibly inferred link-text; i.e., if there was no real link
text, then dis is tha text dat we'll infer up in its place.  (E.g., for
\&\*(L"L<Getopt::Std>\*(R", tha inferred link text is \*(L"Getopt::Std\*(R".)
.IP "Third:" 4
.IX Item "Third:"
Da name or \s-1URL,\s0 or undef if none.  (E.g., up in \*(L"L<Perl
Functions|perlfunc>\*(R", tha name (also sometimes called tha page)
is \*(L"perlfunc\*(R".  In \*(L"L</CAVEATS>\*(R", tha name is undef.)
.IP "Fourth:" 4
.IX Item "Fourth:"
Da section (\s-1AKA \s0\*(L"item\*(R" up in olda perlpods), or undef if none.  E.g.,
in \*(L"L<Getopt::Std/DESCRIPTION>\*(R", \*(L"\s-1DESCRIPTION\*(R"\s0 is tha section. I aint talkin' bout chicken n' gravy biatch.  (Note
that dis aint tha same as a manpage section like tha \*(L"5\*(R" up in \*(L"man 5
crontab\*(R".  \*(L"Section Foo\*(R" up in tha Pod sense means tha part of tha text
thatz introduced by tha headin or item whose text is \*(L"Foo\*(R".)
.RE
.RS 4
.Sp
Pod parsers may also note additionizzle attributes including:
.IP "Fifth:" 4
.IX Item "Fifth:"
A flag fo' whether item 3 (if present) be a \s-1URL \s0(like
\&\*(L"http://lists.perl.org\*(R" is), up in which case there should be no section
attribute; a Pod name (like \*(L"perldoc\*(R" n' \*(L"Getopt::Std\*(R" are); or
possibly a playa page name (like \*(L"\fIcrontab\fR\|(5)\*(R" is).
.IP "Sixth:" 4
.IX Item "Sixth:"
Da raw original gangsta L<...> content, before text is split on
\&\*(L"|\*(R", \*(L"/\*(R", etc, n' before E<...> codes is expanded.
.RE
.RS 4
.Sp
(Da above was numbered only fo' concise reference below.  It be not
a requirement dat these be passed as a actual list or array.)
.Sp
For example:
.Sp
.Vb 7
\&  L<Foo::Bar>
\&    =>  undef,                          # link text
\&        "Foo::Bar",                     # possibly inferred link text
\&        "Foo::Bar",                     # name
\&        undef,                          # section
\&        \*(Aqpod\*(Aq,                          # what tha fuck sort of link
\&        "Foo::Bar"                      # original gangsta content
\&
\&  L<Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines>
\&    =>  "Perlport\*(Aqs section on NL\*(Aqs",   # link text
\&        "Perlport\*(Aqs section on NL\*(Aqs",   # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what tha fuck sort of link
\&        "Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines" # orig. content
\&
\&  L<perlport/Newlines>
\&    =>  undef,                          # link text
\&        \*(Aq"Newlines" up in perlport\*(Aq,       # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what tha fuck sort of link
\&        "perlport/Newlines"             # original gangsta content
\&
\&  L<crontab(5)/"DESCRIPTION">
\&    =>  undef,                          # link text
\&        \*(Aq"DESCRIPTION" up in crontab(5)\*(Aq,  # possibly inferred link text
\&        "crontab(5)",                   # name
\&        "DESCRIPTION",                  # section
\&        \*(Aqman\*(Aq,                          # what tha fuck sort of link
\&        \*(Aqcrontab(5)/"DESCRIPTION"\*(Aq      # original gangsta content
\&
\&  L</Object Attributes>
\&    =>  undef,                          # link text
\&        \*(Aq"Object Attributes"\*(Aq,          # possibly inferred link text
\&        undef,                          # name
\&        "Object Attributes",            # section
\&        \*(Aqpod\*(Aq,                          # what tha fuck sort of link
\&        "/Object Attributes"            # original gangsta content
\&
\&  L<http://www.perl.org/>
\&    =>  undef,                          # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what tha fuck sort of link
\&        "http://www.perl.org/"          # original gangsta content
\&
\&  L<Perl.org|http://www.perl.org/>
\&    =>  "Perl.org",                     # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what tha fuck sort of link
\&        "Perl.org|http://www.perl.org/" # original gangsta content
.Ve
.Sp
Note dat you can distinguish URL-links from anythang else by the
fact dat they match \f(CW\*(C`m/\eA\ew+:[^:\es]\eS*\ez/\*(C'\fR.  So
\&\f(CW\*(C`L<http://www.perl.com>\*(C'\fR be a \s-1URL,\s0 but
\&\f(CW\*(C`L<HTTP::Response>\*(C'\fR aint.
.RE
.IP "\(bu" 4
In case of L<...> codes wit no \*(L"text|\*(R" part up in them,
olda formattas have exhibited pimped out variation up in straight-up displaying
the link or cross reference.  For example, L<\fIcrontab\fR\|(5)> would render
as "the \f(CWcrontab(5)\fR manpage\*(L", or \*(R"in tha \f(CWcrontab(5)\fR manpage\*(L"
or just \*(R"\f(CWcrontab(5)\fR".
.Sp
Pod processors must now treat \*(L"text|\*(R"\-less links as bigs up:
.Sp
.Vb 3
\&  L<name>         =>  L<name|name>
\&  L</section>     =>  L<"section"|/section>
\&  L<name/section> =>  L<"section" up in name|name/section>
.Ve
.IP "\(bu" 4
Note dat section names might contain markup.  I.e., if a section
starts with:
.Sp
.Vb 1
\&  =head2 Bout tha C<\-M> Operator
.Ve
.Sp
or with:
.Sp
.Vb 1
\&  =item Bout tha C<\-M> Operator
.Ve
.Sp
then a link ta it would be lookin like this:
.Sp
.Vb 1
\&  L<somedoc/Bout tha C<\-M> Operator>
.Ve
.Sp
Formattas may chizzle ta ignore tha markup fo' purposez of resolving
the link n' use only tha renderable charactas up in tha section name,
as in:
.Sp
.Vb 2
\&  <h1><a name="About_the_\-M_Operator">Bout tha <code>\-M</code>
\&  Operator</h1>
\&
\&  ...
\&
\&  <a href="somedoc#About_the_\-M_Operator">Bout tha <code>\-M</code>
\&  Operator" up in somedoc</a>
.Ve
.IP "\(bu" 4
Previous versionz of perlpod distinguished \f(CW\*(C`L<name/"section">\*(C'\fR
links from \f(CW\*(C`L<name/item>\*(C'\fR links (and they targets).  These
have been merged syntactically n' semantically up in tha current
specification, n' \fIsection\fR can refer either ta a "=head\fIn\fR Heading
Content\*(L" command or ta a \*(R"=item Item Content" command. Y'all KNOW dat shit, muthafucka!  This
specification do not specify what tha fuck behavior should be up in tha case
of a given document havin nuff muthafuckin thangs all seemin ta produce the
same \fIsection\fR identifier (e.g., up in \s-1HTML,\s0 nuff muthafuckin thangs all producing
the same \fIanchorname\fR up in <a name="\fIanchorname\fR">...</a>
elements).  Where Pod processors can control dis behavior, they should
use tha straight-up original gangsta such anchor. Shiiit, dis aint no joke.  That is, \f(CW\*(C`L<Foo/Bar>\*(C'\fR refers ta the
\&\fIfirst\fR \*(L"Bar\*(R" section up in Foo.
.Sp
But fo' some processors/formats dis cannot be easily controlled; as
with tha \s-1HTML\s0 example, tha behavior of multiple ambiguous
<a name="\fIanchorname\fR">...</a> is most easily just left up to
browsers ta decide.
.IP "\(bu" 4
In a \f(CW\*(C`L<text|...>\*(C'\fR code, text may contain formattin codes
for formattin or fo' E<...> escapes, as in:
.Sp
.Vb 1
\&  L<B<ummE<234>stuff>|...>
.Ve
.Sp
For \f(CW\*(C`L<...>\*(C'\fR codes without a \*(L"name|\*(R" part, only
\&\f(CW\*(C`E<...>\*(C'\fR n' \f(CW\*(C`Z<>\*(C'\fR codes may occur. Shiiit, dis aint no joke.  That is,
authors should not use "\f(CW\*(C`L<B<Foo::Bar>>\*(C'\fR".
.Sp
Note, however, dat formattin codes n' Z<>z can occur up in any
and all partz of a L<...> (i.e., up in \fIname\fR, \fIsection\fR, \fItext\fR,
and \fIurl\fR).
.Sp
Authors must not nest L<...> codes.  For example, \*(L"L<The
L<Foo::Bar> playa page>\*(R" should be treated as a error.
.IP "\(bu" 4
Note dat Pod authors may use formattin codes inside tha \*(L"text\*(R"
part of \*(L"L<text|name>\*(R" (and so on fo' L<text|/\*(L"sec\*(R">).
.Sp
In other lyrics, dis is valid:
.Sp
.Vb 1
\&  Go read L<the docs on C<$.>|perlvar/"$.">
.Ve
.Sp
Some output formats dat do allow renderin \*(L"L<...>\*(R" codes as
hypertext, might not allow tha link-text ta be formatted; in
that case, formattas will gotta just ignore dat formatting.
.IP "\(bu" 4
At time of writing, \f(CW\*(C`L<name>\*(C'\fR joints iz of two types:
either tha name of a Pod page like \f(CW\*(C`L<Foo::Bar>\*(C'\fR (which
might be a real Perl module or program up in a \f(CW@INC\fR / \s-1PATH\s0
directory, or a .pod file up in dem places); or tha name of a Unix
man page, like \f(CW\*(C`L<crontab(5)>\*(C'\fR.  In theory, \f(CW\*(C`L<chmod>\*(C'\fR
in ambiguous between a Pod page called \*(L"chmod\*(R", or tha Unix playa page
\&\*(L"chmod\*(R" (in whatever man-section).  But fuck dat shiznit yo, tha word on tha street is dat tha presence of a string
in parens, as up in \*(L"\fIcrontab\fR\|(5)\*(R", is sufficient ta signal dat what
is bein discussed aint a Pod page, n' so is presumably a
Unix playa page.  Da distinction iz of no importizzle ta many
Pod processors yo, but some processors dat render ta hypertext formats
may need ta distinguish dem up in order ta know how tha fuck ta render a
given \f(CW\*(C`L<foo>\*(C'\fR code.
.IP "\(bu" 4
Previous versionz of perlpod allowed fo' a \f(CW\*(C`L<section>\*(C'\fR syntax (as in
\&\f(CW\*(C`L<Object Attributes>\*(C'\fR), which was not easily distinguishable from
\&\f(CW\*(C`L<name>\*(C'\fR syntax n' fo' \f(CW\*(C`L<"section">\*(C'\fR which was only
slightly less ambiguous.  This syntax is no longer up in tha justification, and
has been replaced by tha \f(CW\*(C`L</section>\*(C'\fR syntax (where tha slash was
formerly optional).  Pod parsers should tolerate tha \f(CW\*(C`L<"section">\*(C'\fR
syntax, fo' a while at least.  Da suggested heuristic fo' distinguishing
\&\f(CW\*(C`L<section>\*(C'\fR from \f(CW\*(C`L<name>\*(C'\fR is dat if it gotz nuff any
whitespace, itz a \fIsection\fR.  Pod processors should warn bout dis being
deprecated syntax.
.SH "Bout =over...=back Regions"
.IX Header "Bout =over...=back Regions"
\&\*(L"=over\*(R"...\*(L"=back\*(R" regions is used fo' various kindz of list-like
structures.  (I use tha term \*(L"region\*(R" here simply as a cold-ass lil collective
term fo' every last muthafuckin thang from tha \*(L"=over\*(R" ta tha matchin \*(L"=back\*(R".)
.IP "\(bu" 4
Da non-zero numeric \fIindentlevel\fR up in "=over \fIindentlevel\fR\*(L" ...
\&\*(R"=back\*(L" is used fo' givin tha formatta a cold-ass lil clue as ta how tha fuck many
\&\*(R"spaces" (ems, or roughly equivalent units) it should tab over,
although nuff formattas will gotta convert dis ta a absolute
measurement dat may not exactly match wit tha size of spaces (or M's)
in tha documentz base font.  Other formattas may gotta straight-up
ignore tha number n' shit.  Da lack of any explicit \fIindentlevel\fR parameta is
equivalent ta a \fIindentlevel\fR value of 4.  Pod processors may
diss if \fIindentlevel\fR is present but aint a positizzle number
matchin \f(CW\*(C`m/\eA(\ed*\e.)?\ed+\ez/\*(C'\fR.
.IP "\(bu" 4
Authorz of Pod formattas is reminded dat \*(L"=over\*(R" ... \*(L"=back\*(R" may
map ta nuff muthafuckin different constructs up in yo' output format.  For
example, up in convertin Pod ta (X)HTML, it can map ta any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, \*(L"=item\*(R" can map ta <li> or
<dt>.
.IP "\(bu" 4
Each \*(L"=over\*(R" ... \*(L"=back\*(R" region should be one of tha following:
.RS 4
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containin only \*(L"=item *\*(R" commands,
each followed by some number of ordinary/verbatim paragraphs, other
nested \*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and
\&\*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
(Pod processors must tolerate a funky-ass bare \*(L"=item\*(R" as if it was \*(L"=item
*\*(R".)  Whether \*(L"*\*(R" is rendered as a literal asterisk, a \*(L"o\*(R", or as
some kind of real cap character, is left up ta tha Pod formatter,
and may depend on tha level of nesting.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containin only
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR paragraphs, each one (or each crew of them)
followed by some number of ordinary/verbatim paragraphs, other nested
\&\*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and/or
\&\*(L"=begin\*(R"...\*(L"=end\*(R" codes.  Note dat tha numbers must start at 1
in each section, n' must proceed up in order n' without skipping
numbers.
.Sp
(Pod processors must tolerate lines like \*(L"=item 1\*(R" as if they were
\&\*(L"=item 1.\*(R", wit tha period.)
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containin only \*(L"=item [text]\*(R"
commands, each one (or each crew of them) followed by some number of
ordinary/verbatim paragraphs, other nested \*(L"=over\*(R" ... \*(L"=back\*(R"
regions, or \*(L"=for...\*(R" paragraphs, n' \*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
Da \*(L"=item [text]\*(R" paragraph should not match
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR or \f(CW\*(C`m/\eA=item\es+\e*\es*\ez/\*(C'\fR, nor should it
match just \f(CW\*(C`m/\eA=item\es*\ez/\*(C'\fR.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containin no \*(L"=item\*(R" paragraphs at
all, n' containin only some number of 
ordinary/verbatim paragraphs, n' possibly also some nested \*(L"=over\*(R"
\&... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, n' \*(L"=begin\*(R"...\*(L"=end\*(R"
regions.  Such a itemless \*(L"=over\*(R" ... \*(L"=back\*(R" region up in Pod is
equivalent up in meanin ta a \*(L"<blockquote>...</blockquote>\*(R" element in
\&\s-1HTML.\s0
.RE
.RS 4
.Sp
Note dat wit all tha above cases, you can determine which type of
\&\*(L"=over\*(R" ... \*(L"=back\*(R" you have, by examinin tha straight-up original gangsta (non\-\*(L"=cut\*(R", 
non\-\*(L"=pod\*(R") Pod paragraph afta tha \*(L"=over\*(R" command.
.RE
.IP "\(bu" 4
Pod formattas \fImust\fR tolerate arbitrarily big-ass amountz of text
in tha "=item \fItext...\fR" paragraph.  In practice, most such
paragraphs is short, as in:
.Sp
.Vb 1
\&  =item For cuttin off our trade wit all partz of tha ghetto
.Ve
.Sp
But they may be arbitrarily long:
.Sp
.Vb 2
\&  =item For transportin our asses beyond seas ta be tried fo' pretended
\&  offenses
\&
\&  =item Dude be at dis time transportin big-ass armiez of foreign
\&  mercenaries ta complete tha workz of dirtnap, desolation and
\&  tyranny, already begun wit circumstancez of wackty n' perfidy
\&  scarcely paralleled up in da most thugged-out barbarous ages, n' straight-up
\&  unworthy tha head of a cold-ass lil civilized nation.
.Ve
.IP "\(bu" 4
Pod processors should tolerate \*(L"=item *\*(R" / "=item \fInumber\fR" commands
with no accompanyin paragraph.  Da middle item be a example:
.Sp
.Vb 1
\&  =over
\&
\&  =item 1
\&
\&  Pick up dry cleaning.
\&
\&  =item 2
\&
\&  =item 3
\&
\&  Quit by tha store.  Git Abba Zabas, Stoli, n' skanky lawn chairs.
\&
\&  =back
.Ve
.IP "\(bu" 4
No \*(L"=over\*(R" ... \*(L"=back\*(R" region can contain headings.  Processors may
treat such a headin as a error.
.IP "\(bu" 4
Note dat a \*(L"=over\*(R" ... \*(L"=back\*(R" region should have some
content.  That is, authors should not have a empty region like this:
.Sp
.Vb 1
\&  =over
\&
\&  =back
.Ve
.Sp
Pod processors seein such a cold-ass lil contentless \*(L"=over\*(R" ... \*(L"=back\*(R" region,
may ignore it, or may report it as a error.
.IP "\(bu" 4
Processors must tolerate a \*(L"=over\*(R" list dat goes off tha end of the
document (i.e., which has no matchin \*(L"=back\*(R") yo, but they may warn
about such a list.
.IP "\(bu" 4
Authorz of Pod formattas should note dat dis construct:
.Sp
.Vb 1
\&  =item Neque
\&
\&  =item Porro
\&
\&  =item Quisquam Est
\&
\&  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
\&  velit, sed quia non numquam eius modi tempora incidunt ut
\&  labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  =item Ut Enim
.Ve
.Sp
is semantically ambiguous, up in a way dat make formattin decisions
a bit difficult.  On tha one hand, it could be mention of a item
\&\*(L"Neque\*(R", mention of another item \*(L"Porro\*(R", n' mention of another
item \*(L"Quisquam Est\*(R", wit just tha last one requirin tha explanatory
paragraph \*(L"Qui dolorem ipsum quia dolor...\*(R"; n' then a item
\&\*(L"Ut Enim\*(R".  In dat case, you'd wanna format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But it could equally well be a gangbangin' finger-lickin' rap of three (related or equivalent)
items, \*(L"Neque\*(R", \*(L"Porro\*(R", n' \*(L"Quisquam Est\*(R", followed by a paragraph
explainin dem all, n' then a freshly smoked up item \*(L"Ut Enim\*(R".  In dat case, you'd
probably wanna format it like so:
.Sp
.Vb 6
\&  Neque
\&  Porro
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But (for tha foreseeable future), Pod do not provide any way fo' Pod
authors ta distinguish which groupin is meant by tha above
\&\*(L"=item\*(R"\-clusta structure.  So formattas should format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
That is, there should be (at least roughly) equal spacin between
items as between paragraphs (although dat spacin may well be less
than tha full height of a line of text).  This leaves it ta tha reader
to use (con)textual cues ta figure up whether tha \*(L"Qui dolorem
ipsum...\*(R" paragraph applies ta tha \*(L"Quisquam Est\*(R" item or ta all three
items \*(L"Neque\*(R", \*(L"Porro\*(R", n' \*(L"Quisquam Est\*(R".  While not a ideal
situation, dis is preferable ta providin formattin cues dat may
be straight-up contrary ta tha authorz intent.
.ie n .SH "Bout Data Paragraphs n' ""=begin/=end"" Regions"
.el .SH "Bout Data Paragraphs n' ``=begin/=end'' Regions"
.IX Header "Bout Data Paragraphs n' =begin/=end Regions"
Data paragraphs is typically used fo' inlinin non-Pod data dat is
to be used (typically passed through) when renderin tha document to
a specific format:
.PP
.Vb 1
\&  =begin rtf
\&
\&  \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
\&
\&  =end rtf
.Ve
.PP
Da exact same effect could, incidentally, be  bigged up  wit a single
\&\*(L"=for\*(R" paragraph:
.PP
.Vb 1
\&  =for rtf \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
.Ve
.PP
(Although dat aint formally a thugged-out data paragraph, it has tha same
meanin as one, n' Pod parsers may parse it as one.)
.PP
Another example of a thugged-out data paragraph:
.PP
.Vb 1
\&  =begin html
\&
\&  I wanna bust a nut on <em>PIE</em>!
\&
\&  <hr>Especially pecan pie!
\&
\&  =end html
.Ve
.PP
If these was ordinary paragraphs, tha Pod parser would try to
expand tha \*(L"E</em>\*(R" (in tha straight-up original gangsta paragraph) as a gangbangin' formatting
code, just like \*(L"E<lt>\*(R" or \*(L"E<eacute>\*(R".  But since this
is up in a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region \fIand\fR
the identifier \*(L"html\*(R" don't begin gotz a \*(L":\*(R" prefix, tha contents
of dis region is stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they fuckin started wit a spaces
and/or tabs, as verbatim paragraphs).
.PP
As a gangbangin' further example: At time of writing, no \*(L"biblio\*(R" identifier is
supported yo, but suppose some processor was freestyled ta recognize it as
a way of (say) denotin a funky-ass bibliographic reference (necessarily
containin formattin codes up in ordinary paragraphs).  Da fact that
\&\*(L"biblio\*(R" paragraphs was meant fo' ordinary processin would be
indicated by prefacin each \*(L"biblio\*(R" identifier wit a cold-ass lil colon:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =end :biblio
.Ve
.PP
This would signal ta tha parser dat paragraphs up in dis begin...end
region is subject ta aiiight handlin as ordinary/verbatim paragraphs
(while still tagged as meant only fo' processors dat KNOW the
\&\*(L"biblio\*(R" identifier).  Da same effect could be had with:
.PP
.Vb 3
\&  =for :biblio
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
.Ve
.PP
Da \*(L":\*(R" on these identifiers means simply \*(L"process dis stuff
normally, even though tha result is ghon be fo' some special target\*(R".
I suggest dat parser APIs report \*(L"biblio\*(R" as tha target identifier,
but also report dat it had a \*(L":\*(R" prefix.  (And similarly, wit the
above \*(L"html\*(R", report \*(L"html\*(R" as tha target identifier, n' note the
\&\fIlack\fR of a \*(L":\*(R" prefix.)
.PP
Note dat a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region where
\&\fIidentifier\fR begins wit a cold-ass lil colon, \fIcan\fR contain commands.  For example:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs funky-ass be available up in nuff muthafuckin editions, including:
\&
\&  =for comment
\&   hm, check abebooks.com fo' how tha fuck much used copies cost.
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs up in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  =end :biblio
.Ve
.PP
Note, however, a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR"
region where \fIidentifier\fR do \fInot\fR begin wit a cold-ass lil colon, should not
directly contain \*(L"=head1\*(R" ... \*(L"=head4\*(R" commands, nor \*(L"=over\*(R", nor \*(L"=back\*(R",
nor \*(L"=item\*(R".  For example, dis may be considered invalid:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This be a thugged-out data paragraph.
\&
\&  =head1 Don\*(Aqt do this!
\&
\&  This be a thugged-out data paragraph like a muthafucka.
\&
\&  =end somedata
.Ve
.PP
A Pod processor may signal dat tha above (specifically tha \*(L"=head1\*(R"
paragraph) be a error. Shiiit, dis aint no joke.  Note, however, dat tha followin should
\&\fInot\fR be treated as a error:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This be a thugged-out data paragraph.
\&
\&  =cut
\&
\&  # Yup, dis isn\*(Aqt Pod no mo'.
\&  sub excl { (rand() > .5) , biatch? "hoo!" : "hah!" }
\&
\&  =pod
\&
\&  This be a thugged-out data paragraph like a muthafucka.
\&
\&  =end somedata
.Ve
.PP
And dis too is valid:
.PP
.Vb 1
\&  =begin someformat
\&
\&  This be a thugged-out data paragraph.
\&
\&    And dis be a thugged-out data paragraph.
\&
\&  =begin someotherformat
\&
\&  This be a thugged-out data paragraph like a muthafucka.
\&
\&    And dis be a thugged-out data paragraph like a muthafucka.
\&
\&  =begin :yetanotherformat
\&
\&  =head2 This be a cold-ass lil command paragraph!
\&
\&  This be a ordinary paragraph!
\&
\&    And dis be a verbatim paragraph!
\&
\&  =end :yetanotherformat
\&
\&  =end someotherformat
\&
\&  Another data paragraph!
\&
\&  =end someformat
.Ve
.PP
Da contentz of tha above \*(L"=begin :yetanotherformat\*(R" ...
\&\*(L"=end :yetanotherformat\*(R" region \fIaren't\fR data paragraphs, cuz
the immediately containin regionz identifier (\*(L":yetanotherformat\*(R")
begins wit a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch.  In practice, most regions dat contain
data paragraphs will contain \fIonly\fR data paragraphs; however, 
the above nestin is syntactically valid as Pod, even if it is
rare.  But fuck dat shiznit yo, tha word on tha street is dat tha handlezs fo' some formats, like \*(L"html\*(R",
will accept only data paragraphs, not nested regions; n' they may
diss if they peep (targeted fo' them) nested regions, or commands,
other than \*(L"=end\*(R", \*(L"=pod\*(R", n' \*(L"=cut\*(R".
.PP
Also consider dis valid structure:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs funky-ass be available up in nuff muthafuckin editions, including:
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs up in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  Loot loot buy!
\&
\&  =begin html
\&
\&  <img src=\*(Aqwirth_spokesmodeling_book.png\*(Aq>
\&
\&  <hr>
\&
\&  =end html
\&
\&  Now now now!
\&
\&  =end :biblio
.Ve
.PP
There, tha \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is nested inside
the larger \*(L"=begin :biblio\*(R"...\*(L"=end :biblio\*(R" region. I aint talkin' bout chicken n' gravy biatch.  Note dat the
content of tha \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is data
paragraph(s), cuz tha immediately containin regionz identifier
(\*(L"html\*(R") \fIdoesn't\fR begin wit a cold-ass lil colon.
.PP
Pod parsers, when processin a seriez of data paragraphs one
afta another (within a single region), should consider dem to
be one big-ass data paragraph dat happens ta contain blank lines.  So
the content of tha above \*(L"=begin html\*(R"...\*(L"=end html\*(R" \fImay\fR be stored
as two data paragraphs (one consistin of
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\*(R"
and another consistin of \*(L"<hr>\en\*(R") yo, but \fIshould\fR be stored as
a single data paragraph (consistin of 
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\en<hr>\en\*(R").
.PP
Pod processors should tolerate empty
"=begin \fIsomething\fR\*(L"...\*(R"=end \fIsomething\fR\*(L" regions,
empty \*(R"=begin :\fIsomething\fR\*(L"...\*(R"=end :\fIsomething\fR\*(L" regions, and
contentless \*(R"=for \fIsomething\fR\*(L" n' \*(R"=for :\fIsomething\fR"
paragraphs.  I.e., these should be tolerated:
.PP
.Vb 1
\&  =for html
\&
\&  =begin html
\&
\&  =end html
\&
\&  =begin :biblio
\&
\&  =end :biblio
.Ve
.PP
Incidentally, note dat there be a no easy as fuck  way ta express a thugged-out data
paragraph startin wit suttin' dat be lookin like a cold-ass lil command. Y'all KNOW dat shit, muthafucka!  Consider:
.PP
.Vb 1
\&  =begin stuff
\&
\&  =shazbot
\&
\&  =end stuff
.Ve
.PP
There, \*(L"=shazbot\*(R" is ghon be parsed as a Pod command \*(L"shazbot\*(R", not as a thugged-out data
paragraph \*(L"=shazbot\en\*(R".  But fuck dat shiznit yo, tha word on tha street is dat you can express a thugged-out data paragraph consisting
of \*(L"=shazbot\en\*(R" rockin dis code:
.PP
.Vb 1
\&  =for shiznit =shazbot
.Ve
.PP
Da thang where dis is necessary, is presumably like rare.
.PP
Note dat =end commandz must match tha currently open =begin command. Y'all KNOW dat shit, muthafucka!  That
is, they must properly nest.  For example, dis is valid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end inner
\&
\&  Z
\&
\&  =end outer
.Ve
.PP
while dis is invalid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end outer
\&
\&  Z
\&
\&  =end inner
.Ve
.PP
This latta is improper cuz when tha \*(L"=end outer\*(R" command is seen, the
currently open region has tha formatname \*(L"inner\*(R", not \*(L"outer\*(R".  (It just
happens dat \*(L"outer\*(R" is tha format name of a higher-up region.)  This is
an error. Shiiit, dis aint no joke.  Processors must by default report dis as a error, n' may halt
processin tha document containin dat error. Shiiit, dis aint no joke.  A corollary of dis is that
regions cannot \*(L"overlap\*(R". That is, tha latta block above do not represent
a region called \*(L"outer\*(R" which gotz nuff X n' Y, overlappin a region called
\&\*(L"inner\*(R" which gotz nuff Y n' Z.  But cuz it is invalid (as all
apparently overlappin regions would be), it don't represent that, or
anythang at all.
.PP
Similarly, dis is invalid:
.PP
.Vb 1
\&  =begin thang
\&
\&  =end hting
.Ve
.PP
This be a error cuz tha region is opened by \*(L"thing\*(R", n' tha \*(L"=end\*(R"
tries ta close \*(L"hting\*(R" [sic].
.PP
This be also invalid:
.PP
.Vb 1
\&  =begin thang
\&
\&  =end
.Ve
.PP
This is invalid cuz every last muthafuckin \*(L"=end\*(R" command must gotz a gangbangin' formatname
parameter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpod, \*(L"PODs: Embedded Documentation\*(R" up in perlsyn,
podchecker
.SH "AUTHOR"
.IX Header "AUTHOR"
Shizzle M. Burke
