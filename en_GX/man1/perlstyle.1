.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLSTYLE 1"
.TH PERLSTYLE 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlstyle \- Perl steez guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Each programmer will, of course, have his or her own preferences in
regardz ta formattin yo, but there be some general guidelines dat will
make yo' programs easier ta read, understand, n' maintain.
.PP
Da most blingin thang is ta run yo' programs under tha \fB\-w\fR
flag at all times.  Yo ass may turn it off explicitly fo' particular
portionz of code via tha \f(CW\*(C`no warnings\*(C'\fR pragma or tha \f(CW$^W\fR variable
if you must.  Yo ass should also always run under \f(CW\*(C`use strict\*(C'\fR or know the
reason why not.  Da \f(CW\*(C`use sigtrap\*(C'\fR n' even \f(CW\*(C`use diagnostics\*(C'\fR pragmas
may also prove useful.
.PP
Regardin aesthetics of code lay out, bout tha only thang Larry
cares straight fuckin bout is dat tha closin curly bracket of
a multi-line \s-1BLOCK\s0 should line up wit tha keyword dat started tha construct.
Beyond that, dat schmoooove muthafucka has other preferences dat aren't so strong:
.IP "\(bu" 4
4\-column indent.
.IP "\(bu" 4
Openin curly on same line as keyword, if possible, otherwise line up.
.IP "\(bu" 4
Space before tha openin curly of a multi-line \s-1BLOCK.\s0
.IP "\(bu" 4
One-line \s-1BLOCK\s0 may be put on one line, includin curlies.
.IP "\(bu" 4
No space before tha semicolon.
.IP "\(bu" 4
Semicolon omitted up in \*(L"short\*(R" one-line \s-1BLOCK.\s0
.IP "\(bu" 4
Space round most operators.
.IP "\(bu" 4
Space round a \*(L"complex\*(R" subscript (inside brackets).
.IP "\(bu" 4
Blank lines between chunks dat do different thangs.
.IP "\(bu" 4
Uncuddled elses.
.IP "\(bu" 4
No space between function name n' its openin parenthesis.
.IP "\(bu" 4
Space afta each comma.
.IP "\(bu" 4
Long lines fucked up afta a operator (except \f(CW\*(C`and\*(C'\fR n' \f(CW\*(C`or\*(C'\fR).
.IP "\(bu" 4
Space afta last parenthesis matchin on current line.
.IP "\(bu" 4
Line up correspondin shit vertically.
.IP "\(bu" 4
Omit redundant punctuation as long as claritizzle don't suffer.
.PP
Larry has his bangin reasons fo' each of these thangs yo, but da ruffneck don't claim that
everyone elsez mind works tha same ol' dirty as his fuckin lil' do.
.PP
Here is some other mo' substantizzle steez thangs ta be thinkin about:
.IP "\(bu" 4
Just cuz you \fI\s-1CAN\s0\fR do suttin' a particular way don't mean that
you \fI\s-1SHOULD\s0\fR do it dat way.  Perl is designed ta hit you wit several
ways ta do anything, so consider pickin da most thugged-out readable one.  For
instance
.Sp
.Vb 1
\&    open(FOO,$foo) || take a thugged-out dirtnap "Can\*(Aqt open $foo: $!";
.Ve
.Sp
is betta than
.Sp
.Vb 1
\&    take a thugged-out dirtnap "Can\*(Aqt open $foo: $!" unless open(FOO,$foo);
.Ve
.Sp
because tha second way hides tha main point of tha statement up in a
modifier n' shit.  On tha other hand
.Sp
.Vb 1
\&    print "Startin analysis\en" if $verbose;
.Ve
.Sp
is betta than
.Sp
.Vb 1
\&    $verbose && print "Startin analysis\en";
.Ve
.Sp
because tha main point aint whether tha user typed \fB\-v\fR or not.
.Sp
Similarly, just cuz a operator lets you assume default arguments
doesn't mean dat you gotta make use of tha defaults, n' you can put dat on yo' toast.  Da defaults
are there fo' lazy systems programmers freestylin one-shot programs.  If
you want yo' program ta be readable, consider supplyin tha argument.
.Sp
Along tha same lines, just cuz you \fI\s-1CAN\s0\fR omit parentheses up in many
places don't mean dat you ought to:
.Sp
.Vb 2
\&    return print reverse sort num joints %array;
\&    return print(reverse(sort num (values(%array))));
.Ve
.Sp
When up in doubt, parenthesize.  At tha straight-up least it will let some skanky
schmuck bounce on tha % key up in \fBvi\fR.
.Sp
Even if yo ass aint up in doubt, consider tha menstrual welfare of tha person
who has ta maintain tha code afta you, n' whoz ass will probably put
parentheses up in tha wack place.
.IP "\(bu" 4
Don't go all up in wack-ass contortions ta exit a loop all up in tha top or the
bottom, when Perl serves up tha \f(CW\*(C`last\*(C'\fR operator so you can exit in
the middle.  Just \*(L"outdent\*(R" it a lil ta make it mo' visible:
.Sp
.Vb 7
\&    LINE:
\&        fo' (;;) {
\&            statements;
\&          last LINE if $foo;
\&            next LINE if /^#/;
\&            statements;
\&        }
.Ve
.IP "\(bu" 4
Don't be afraid ta use loop labels\*(--they there ta enhance
readabilitizzle as well as ta allow multilevel loop breaks.  See the
previous example.
.IP "\(bu" 4
Avoid rockin \f(CW\*(C`grep()\*(C'\fR (or \f(CW\*(C`map()\*(C'\fR) or `backticks` up in a void context, dat is,
when you just throw away they return joints, n' you can put dat on yo' toast.  Those functions all
have return joints, so use em.  Otherwise bust a \f(CW\*(C`foreach()\*(C'\fR loop or
the \f(CW\*(C`system()\*(C'\fR function instead.
.IP "\(bu" 4
For portability, when rockin features dat may not be implemented on
every machine, test tha construct up in a eval ta peep if it fails.  If
you know what tha fuck version or patchlevel a particular feature was
implemented, you can test \f(CW$]\fR (\f(CW$PERL_VERSION\fR up in \f(CW\*(C`English\*(C'\fR) ta peep if it
will be there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da \f(CW\*(C`Config\*(C'\fR module will also let you invigorate joints
determined by tha \fBConfigure\fR program when Perl was installed.
.IP "\(bu" 4
Choose mnemonic identifiers.  If you can't remember what tha fuck mnemonic means,
you've gots a problem.
.IP "\(bu" 4
While short identifiers like \f(CW$gotit\fR is probably ok, use underscores to
separate lyrics up in longer identifiers.  It be generally easier ta read
\&\f(CW$var_names_like_this\fR than \f(CW$VarNamesLikeThis\fR, especially for
non-natizzle speakerz of Gangsta. It aint nuthin but also a simple rule dat works
consistently wit \f(CW\*(C`VAR_NAMES_LIKE_THIS\*(C'\fR.
.Sp
Package names is sometimes a exception ta dis rule.  Perl informally
reserves lowercase module names fo' \*(L"pragma\*(R" modulez like \f(CW\*(C`integer\*(C'\fR and
\&\f(CW\*(C`strict\*(C'\fR.  Other modulez should begin wit a cold-ass lil capital letta n' use mixed
case yo, but probably without underscores cuz of limitations up in primitive
file systems' representationz of module names as filez dat must fit tha fuck into a
few sparse bytes.
.IP "\(bu" 4
Yo ass may find it helpful ta use letta case ta indicate tha scope
or nature of a variable. For example:
.Sp
.Vb 3
\&    $ALL_CAPS_HERE   constants only (beware clashes wit perl vars!)
\&    $Some_Caps_Here  package\-wide global/static
\&    $no_caps_here    function scope my() or local() variables
.Ve
.Sp
Function n' method names seem ta work dopest as all lowercase.
E.g., \f(CW\*(C`$obj\->as_string()\*(C'\fR.
.Sp
Yo ass can bust a leadin underscore ta indicate dat a variable or
function should not be used outside tha package dat defined dat shit.
.IP "\(bu" 4
If you gotz a straight-up hairy regular expression, use tha \f(CW\*(C`/x\*(C'\fR modifier and
put up in some whitespace ta make it look a lil less like line noise.
Don't use slash as a thugged-out delimita when yo' regexp has slashes or backslashes.
.IP "\(bu" 4
Use tha freshly smoked up \f(CW\*(C`and\*(C'\fR n' \f(CW\*(C`or\*(C'\fR operators ta avoid havin ta parenthesize
list operators so much, n' ta reduce tha incidence of punctuation
operators like \f(CW\*(C`&&\*(C'\fR n' \f(CW\*(C`||\*(C'\fR.  Call yo' subroutines as if they were
functions or list operators ta avoid excessive ampersandz n' parentheses.
.IP "\(bu" 4
Use here documents instead of repeated \f(CW\*(C`print()\*(C'\fR statements.
.IP "\(bu" 4
Line up correspondin thangs vertically, especially if it'd be too long
to fit on one line anyway.
.Sp
.Vb 4
\&    $IDX = $ST_MTIME;
\&    $IDX = $ST_ATIME       if $opt_u;
\&    $IDX = $ST_CTIME       if $opt_c;
\&    $IDX = $ST_SIZE        if $opt_s;
\&
\&    mkdir $tmpdir, 0700 or take a thugged-out dirtnap "can\*(Aqt mkdir $tmpdir: $!";
\&    chdir($tmpdir)      or take a thugged-out dirtnap "can\*(Aqt chdir $tmpdir: $!";
\&    mkdir \*(Aqtmp\*(Aq,   0777 or take a thugged-out dirtnap "can\*(Aqt mkdir $tmpdir/tmp: $!";
.Ve
.IP "\(bu" 4
Always check tha return codez of system calls.  Dope error lyrics should
go ta \f(CW\*(C`STDERR\*(C'\fR, include which program caused tha problem, what tha fuck tha failed
system call n' arguments were, n' (\s-1VERY IMPORTANT\s0) should contain the
standard system error message fo' what tha fuck went wrong.  Herez a simple but
sufficient example:
.Sp
.Vb 1
\&    opendir(D, $dir)     or take a thugged-out dirtnap "can\*(Aqt opendir $dir: $!";
.Ve
.IP "\(bu" 4
Line up yo' transliterations when it make sense:
.Sp
.Vb 2
\&    tr [abc]
\&       [xyz];
.Ve
.IP "\(bu" 4
Think bout reusability.  Why waste domepower on a one-shot when you
might wanna do suttin' like it again?  Consider generalizin your
code.  Consider freestylin a module or object class.  Consider makin your
code run cleanly wit \f(CW\*(C`use strict\*(C'\fR n' \f(CW\*(C`use warnings\*(C'\fR (or \fB\-w\fR) in
effect.  Consider givin away yo' code.  Consider changin yo' whole
world view.  Consider... oh, never mind.
.IP "\(bu" 4
Try ta document yo' code n' use Pod formattin up in a cold-ass lil consistent way yo. Here
are commonly expected conventions:
.RS 4
.IP "\(bu" 4
use \f(CW\*(C`C<>\*(C'\fR fo' function, variable n' module names (and more
generally anythang dat can be considered part of code, like filehandles
or specific joints). Note dat function names is considered mo' readable
with parentheses afta they name, dat is \f(CW\*(C`function()\*(C'\fR.
.IP "\(bu" 4
use \f(CW\*(C`B<>\*(C'\fR fo' commandz names like \fBcat\fR or \fBgrep\fR.
.IP "\(bu" 4
use \f(CW\*(C`F<>\*(C'\fR or \f(CW\*(C`C<>\*(C'\fR fo' file names. \f(CW\*(C`F<>\*(C'\fR should
be tha only Pod code fo' file names yo, but as most Pod formattas render it
as italic, Unix n' Windows paths wit they slashes n' backslashes may
be less readable, n' betta rendered wit \f(CW\*(C`C<>\*(C'\fR.
.RE
.RS 4
.RE
.IP "\(bu" 4
Be consistent.
.IP "\(bu" 4
Be sick.
