.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDEBGUTS 1"
.TH PERLDEBGUTS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldebguts \- Gutz of Perl debugging
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This aint perldebug, which  drops some lyrics ta you how tha fuck ta use
the debugger n' shit.  This manpage raps bout low-level details concerning
the debuggerz internals, which range from hard as fuck ta impossible
to KNOW fo' mah playas whoz ass aint incredibly intimate wit Perlz guts.
Caveat lector.
.SH "Debugger Internals"
.IX Header "Debugger Internals"
Perl has special debuggin hooks at compile-time n' run-time used
to create debuggin environments, n' you can put dat on yo' toast.  These hooks is not ta be confused
with tha \fIperl \-Dxxx\fR command busted lyrics bout up in perlrun, which is
usable only if a special Perl is built per tha instructions up in the
\&\fI\s-1INSTALL\s0\fR podpage up in tha Perl source tree.
.PP
For example, whenever you call Perlz built-in \f(CW\*(C`caller\*(C'\fR function
from tha package \f(CW\*(C`DB\*(C'\fR, tha arguments dat tha correspondin stack
frame was called wit is copied ta tha \f(CW@DB::args\fR array.  These
mechanizzlez is enabled by callin Perl wit tha \fB\-d\fR switch.
Specifically, tha followin additionizzle features is enabled
(cf. \*(L"$^P\*(R" up in perlvar):
.IP "\(bu" 4
Perl bangs tha contentz of \f(CW$ENV{PERL5DB}\fR (or \f(CW\*(C`BEGIN {require
\&\*(Aqperl5db.pl\*(Aq}\*(C'\fR if not present) before tha straight-up original gangsta line of yo' program.
.IP "\(bu" 4
Each array \f(CW\*(C`@{"_<$filename"}\*(C'\fR holdz tha linez of \f(CW$filename\fR fo' a
file compiled by Perl.  Da same be also legit fo' \f(CW\*(C`eval\*(C'\fRed strings
that contain subroutines, or which is currently bein executed.
Da \f(CW$filename\fR fo' \f(CW\*(C`eval\*(C'\fRed strings be lookin like \f(CW\*(C`(eval 34)\*(C'\fR.
.Sp
Values up in dis array is magical up in numeric context: they compare
equal ta zero only if tha line aint breakable.
.IP "\(bu" 4
Each hash \f(CW\*(C`%{"_<$filename"}\*(C'\fR gotz nuff breakpoints n' actions keyed
by line number n' shit.  Individual entries (as opposed ta tha whole hash)
are settable.  Perl only cares bout Boolean legit here, although
the joints used by \fIperl5db.pl\fR have tha form
\&\f(CW"$break_condition\e0$action"\fR.
.Sp
Da same holdz fo' evaluated strings dat contain subroutines, or
which is currently bein executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW$filename\fR fo' \f(CW\*(C`eval\*(C'\fRed strings
looks like \f(CW\*(C`(eval 34)\*(C'\fR.
.IP "\(bu" 4
Each scalar \f(CW\*(C`${"_<$filename"}\*(C'\fR gotz nuff \f(CW"_<$filename"\fR.  This is
also tha case fo' evaluated strings dat contain subroutines, or
which is currently bein executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW$filename\fR fo' \f(CW\*(C`eval\*(C'\fRed
strings be lookin like \f(CW\*(C`(eval 34)\*(C'\fR.
.IP "\(bu" 4
Afta each \f(CW\*(C`require\*(C'\fRd file is compiled yo, but before it is executed,
\&\f(CW\*(C`DB::postponed(*{"_<$filename"})\*(C'\fR is called if tha subroutine
\&\f(CW\*(C`DB::postponed\*(C'\fR exists, n' you can put dat on yo' toast.  Here, tha \f(CW$filename\fR is tha expanded name of
the \f(CW\*(C`require\*(C'\fRd file, as found up in tha jointz of \f(CW%INC\fR.
.IP "\(bu" 4
Afta each subroutine \f(CW\*(C`subname\*(C'\fR is compiled, tha existence of
\&\f(CW$DB::postponed{subname}\fR is checked. Y'all KNOW dat shit, muthafucka!  If dis key exists,
\&\f(CW\*(C`DB::postponed(subname)\*(C'\fR is called if tha \f(CW\*(C`DB::postponed\*(C'\fR subroutine
also exists.
.IP "\(bu" 4
A hash \f(CW%DB::sub\fR is maintained, whose keys is subroutine names
and whose joints have tha form \f(CW\*(C`filename:startline\-endline\*(C'\fR.
\&\f(CW\*(C`filename\*(C'\fR has tha form \f(CW\*(C`(eval 34)\*(C'\fR fo' subroutines defined inside
\&\f(CW\*(C`eval\*(C'\fRs.
.IP "\(bu" 4
When tha execution of yo' program reaches a point dat can hold a
breakpoint, tha \f(CW\*(C`DB::DB()\*(C'\fR subroutine is called if any of tha variables
\&\f(CW$DB::trace\fR, \f(CW$DB::single\fR, or \f(CW$DB::signal\fR is true.  These variables
are not \f(CW\*(C`local\*(C'\fRizable.  This feature is disabled when executing
inside \f(CW\*(C`DB::DB()\*(C'\fR, includin functions called from it 
unless \f(CW\*(C`$^D & (1<<30)\*(C'\fR is true.
.IP "\(bu" 4
When execution of tha program reaches a subroutine call, a cold-ass lil call to
\&\f(CW&DB::sub\fR(\fIargs\fR) is made instead, wit \f(CW$DB::sub\fR holdin the
name of tha called subroutine. (This don't happen if tha subroutine
was compiled up in tha \f(CW\*(C`DB\*(C'\fR package.)
.PP
Note dat if \f(CW&DB::sub\fR needz external data fo' it ta work, no
subroutine call is possible without it fo' realz. As a example, tha standard
debuggerz \f(CW&DB::sub\fR dependz on tha \f(CW$DB::deep\fR variable
(it defines how tha fuck nuff levelz of recursion deep tha fuck into tha debugger you can go
before a mandatory break).  If \f(CW$DB::deep\fR aint defined, subroutine
calls is not possible, even though \f(CW&DB::sub\fR exists.
.SS "Freestylin Yo crazy-ass Own Debugger"
.IX Subsection "Freestylin Yo crazy-ass Own Debugger"
\fIEnvironment Variables\fR
.IX Subsection "Environment Variables"
.PP
Da \f(CW\*(C`PERL5DB\*(C'\fR environment variable can be used ta define a thugged-out debugger.
For example, tha minimal \*(L"working\*(R" debugger (it straight-up don't do anything)
consistz of one line:
.PP
.Vb 1
\&  sub DB::DB {}
.Ve
.PP
It can easily be defined like this:
.PP
.Vb 1
\&  $ PERL5DB="sub DB::DB {}" perl \-d your\-script
.Ve
.PP
Another brief debugger, slightly mo' useful, can be pimped
with only tha line:
.PP
.Vb 1
\&  sub DB::DB {print ++$i; scalar <STDIN>}
.Ve
.PP
This debugger prints a number which increments fo' each statement
encountered n' waits fo' you ta hit a newline before continuing
to tha next statement.
.PP
Da followin debugger is straight-up useful:
.PP
.Vb 5
\&  {
\&    package DB;
\&    sub DB  {}
\&    sub sub {print ++$i, " $sub\en"; &$sub}
\&  }
.Ve
.PP
It prints tha sequence number of each subroutine call n' tha name of the
called subroutine.  Note dat \f(CW&DB::sub\fR is bein compiled tha fuck into the
package \f(CW\*(C`DB\*(C'\fR all up in tha use of tha \f(CW\*(C`package\*(C'\fR directive.
.PP
When it starts, tha debugger readz yo' rc file (\fI./.perldb\fR or
\&\fI~/.perldb\fR under Unix), which can set blingin options.
(A subroutine (\f(CW&afterinit\fR) can be defined here as well; it is executed
afta tha debugger completes its own initialization.)
.PP
Afta tha rc file is read, tha debugger readz tha \s-1PERLDB_OPTS\s0
environment variable n' uses it ta set debugger options. The
contentz of dis variable is treated as if they was tha argument
of a \f(CW\*(C`o ...\*(C'\fR debugger command (q.v. up in \*(L"Configurable Options\*(R" up in perldebug).
.PP
\fIDebugger Internal Variables\fR
.IX Subsection "Debugger Internal Variables"
.PP
In addizzle ta tha file n' subroutine-related variablez mentioned above,
the debugger also maintains various magical internal variables.
.IP "\(bu" 4
\&\f(CW@DB::dbline\fR be a alias fo' \f(CW\*(C`@{"::_<current_file"}\*(C'\fR, which
holdz tha linez of tha currently-selected file (compiled by Perl), either
explicitly chosen wit tha debuggerz \f(CW\*(C`f\*(C'\fR command, or implicitly by flow
of execution.
.Sp
Values up in dis array is magical up in numeric context: they compare
equal ta zero only if tha line aint breakable.
.IP "\(bu" 4
\&\f(CW%DB::dbline\fR be a alias fo' \f(CW\*(C`%{"::_<current_file"}\*(C'\fR, which
gotz nuff breakpoints n' actions keyed by line number in
the currently-selected file, either explicitly chosen wit the
debuggerz \f(CW\*(C`f\*(C'\fR command, or implicitly by flow of execution.
.Sp
As previously noted, individual entries (as opposed ta tha whole hash)
are settable.  Perl only cares bout Boolean legit here, although
the joints used by \fIperl5db.pl\fR have tha form
\&\f(CW"$break_condition\e0$action"\fR.
.PP
\fIDebugger Customization Functions\fR
.IX Subsection "Debugger Customization Functions"
.PP
Some functions is provided ta simplify customization.
.IP "\(bu" 4
See \*(L"Configurable Options\*(R" up in perldebug fo' a thugged-out description of options parsed by
\&\f(CW\*(C`DB::parse_options(string)\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`DB::dump_trace(skip[,count])\*(C'\fR skips tha specified number of frames
and returns a list containin shiznit bout tha callin frames (all
of them, if \f(CW\*(C`count\*(C'\fR is missing).  Each entry is reference ta a hash
with keys \f(CW\*(C`context\*(C'\fR (either \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`$\*(C'\fR, or \f(CW\*(C`@\*(C'\fR), \f(CW\*(C`sub\*(C'\fR (subroutine
name, or info bout \f(CW\*(C`eval\*(C'\fR), \f(CW\*(C`args\*(C'\fR (\f(CW\*(C`undef\*(C'\fR or a reference to
an array), \f(CW\*(C`file\*(C'\fR, n' \f(CW\*(C`line\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`DB::print_trace(FH, skip[, count[, short]])\*(C'\fR prints
formatted info bout calla frames.  Da last two functions may be
convenient as arguments ta \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`<<\*(C'\fR commands.
.PP
Note dat any variablez n' functions dat is not documented in
this manpages (or up in perldebug) is considered fo' internal   
use only, n' as such is subject ta chizzle without notice.
.SH "Frame Listin Output Examples"
.IX Header "Frame Listin Output Examples"
Da \f(CW\*(C`frame\*(C'\fR option can be used ta control tha output of frame 
information. I aint talkin' bout chicken n' gravy biatch.  For example, contrast dis expression trace:
.PP
.Vb 2
\& $ perl \-de 42
\& Stack dump durin take a thugged-out dirtnap enabled outside of evals.
\&
\& Loadin DB routines from perl5db.pl patch level 0.94
\& Emacs support available.
\&
\& Enta h or \*(Aqh h\*(Aq fo' help.
\&
\& main::(\-e:1):   0
\&   DB<1> sub foo { 14 }
\&
\&   DB<2> sub bar { 3 }
\&
\&   DB<3> t print foo() * bar()
\& main::((eval 172):3):   print foo() + bar();
\& main::foo((eval 168):2):
\& main::bar((eval 170):2):
\& 42
.Ve
.PP
with dis one, once tha \f(CW\*(C`o\*(C'\fRption \f(CW\*(C`frame=2\*(C'\fR has been set:
.PP
.Vb 11
\&   DB<4> o f=2
\&                frame = \*(Aq2\*(Aq
\&   DB<5> t print foo() * bar()
\& 3:      foo() * bar()
\& enterin main::foo
\&  2:     sub foo { 14 };
\& exited main::foo
\& enterin main::bar
\&  2:     sub bar { 3 };
\& exited main::bar
\& 42
.Ve
.PP
By way of demonstration, we present below a laborious listing
resultin from settin yo' \f(CW\*(C`PERLDB_OPTS\*(C'\fR environment variable to
the value \f(CW\*(C`f=n N\*(C'\fR, n' hustlin \fIperl \-d \-V\fR from tha command line.
Examplez rockin various jointz of \f(CW\*(C`n\*(C'\fR is shown ta hit you wit a gangbangin' feel
for tha difference between settings.  Long though it may be, this
is not a cold-ass lil complete listin yo, but only excerpts.
.IP "1." 4
.Vb 10
\&  enterin main::BEGIN
\&   enterin Config::BEGIN
\&    Package lib/Exporter.pm.
\&    Package lib/Carp.pm.
\&   Package lib/Config.pm.
\&   enterin Config::TIEHASH
\&   enterin Exporter::import
\&    enterin Exporter::export
\&  enterin Config::myconfig
\&   enterin Config::FETCH
\&   enterin Config::FETCH
\&   enterin Config::FETCH
\&   enterin Config::FETCH
.Ve
.IP "2." 4
.Vb 10
\&  enterin main::BEGIN
\&   enterin Config::BEGIN
\&    Package lib/Exporter.pm.
\&    Package lib/Carp.pm.
\&   exited Config::BEGIN
\&   Package lib/Config.pm.
\&   enterin Config::TIEHASH
\&   exited Config::TIEHASH
\&   enterin Exporter::import
\&    enterin Exporter::export
\&    exited Exporter::export
\&   exited Exporter::import
\&  exited main::BEGIN
\&  enterin Config::myconfig
\&   enterin Config::FETCH
\&   exited Config::FETCH
\&   enterin Config::FETCH
\&   exited Config::FETCH
\&   enterin Config::FETCH
.Ve
.IP "3." 4
.Vb 10
\&  up in  $=main::BEGIN() from /dev/null:0
\&   up in  $=Config::BEGIN() from lib/Config.pm:2
\&    Package lib/Exporter.pm.
\&    Package lib/Carp.pm.
\&   Package lib/Config.pm.
\&   up in  $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:644
\&   up in  $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&    up in  $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from li
\&  up in  @=Config::myconfig() from /dev/null:0
\&   up in  $=Config::FETCH(ref(Config), \*(Aqpackage\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(Aqbaserev\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(AqPERL_VERSION\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(AqPERL_SUBVERSION\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(Aqosname\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(Aqosvers\*(Aq) from lib/Config.pm:574
.Ve
.IP "4." 4
.Vb 10
\&  up in  $=main::BEGIN() from /dev/null:0
\&   up in  $=Config::BEGIN() from lib/Config.pm:2
\&    Package lib/Exporter.pm.
\&    Package lib/Carp.pm.
\&   up $=Config::BEGIN() from lib/Config.pm:0
\&   Package lib/Config.pm.
\&   up in  $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:644
\&   up $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:644
\&   up in  $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&    up in  $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/
\&    up $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/
\&   up $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&  up $=main::BEGIN() from /dev/null:0
\&  up in  @=Config::myconfig() from /dev/null:0
\&   up in  $=Config::FETCH(ref(Config), \*(Aqpackage\*(Aq) from lib/Config.pm:574
\&   up $=Config::FETCH(ref(Config), \*(Aqpackage\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(Aqbaserev\*(Aq) from lib/Config.pm:574
\&   up $=Config::FETCH(ref(Config), \*(Aqbaserev\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(AqPERL_VERSION\*(Aq) from lib/Config.pm:574
\&   up $=Config::FETCH(ref(Config), \*(AqPERL_VERSION\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(ref(Config), \*(AqPERL_SUBVERSION\*(Aq) from lib/Config.pm:574
.Ve
.IP "5." 4
.Vb 10
\&  up in  $=main::BEGIN() from /dev/null:0
\&   up in  $=Config::BEGIN() from lib/Config.pm:2
\&    Package lib/Exporter.pm.
\&    Package lib/Carp.pm.
\&   up $=Config::BEGIN() from lib/Config.pm:0
\&   Package lib/Config.pm.
\&   up in  $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:644
\&   up $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:644
\&   up in  $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&    up in  $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/E
\&    up $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/E
\&   up $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&  up $=main::BEGIN() from /dev/null:0
\&  up in  @=Config::myconfig() from /dev/null:0
\&   up in  $=Config::FETCH(\*(AqConfig=HASH(0x1aa444)\*(Aq, \*(Aqpackage\*(Aq) from lib/Config.pm:574
\&   up $=Config::FETCH(\*(AqConfig=HASH(0x1aa444)\*(Aq, \*(Aqpackage\*(Aq) from lib/Config.pm:574
\&   up in  $=Config::FETCH(\*(AqConfig=HASH(0x1aa444)\*(Aq, \*(Aqbaserev\*(Aq) from lib/Config.pm:574
\&   up $=Config::FETCH(\*(AqConfig=HASH(0x1aa444)\*(Aq, \*(Aqbaserev\*(Aq) from lib/Config.pm:574
.Ve
.IP "6." 4
.Vb 10
\&  up in  $=CODE(0x15eca4)() from /dev/null:0
\&   up in  $=CODE(0x182528)() from lib/Config.pm:2
\&    Package lib/Exporter.pm.
\&   up $=CODE(0x182528)() from lib/Config.pm:0
\&   scalar context return from CODE(0x182528): undef
\&   Package lib/Config.pm.
\&   up in  $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:628
\&   up $=Config::TIEHASH(\*(AqConfig\*(Aq) from lib/Config.pm:628
\&   scalar context return from Config::TIEHASH:   empty hash
\&   up in  $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&    up in  $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/Exporter.pm:171
\&    up $=Exporter::export(\*(AqConfig\*(Aq, \*(Aqmain\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from lib/Exporter.pm:171
\&    scalar context return from Exporter::export: \*(Aq\*(Aq
\&   up $=Exporter::import(\*(AqConfig\*(Aq, \*(Aqmyconfig\*(Aq, \*(Aqconfig_vars\*(Aq) from /dev/null:0
\&   scalar context return from Exporter::import: \*(Aq\*(Aq
.Ve
.PP
In all cases shown above, tha line indentation shows tha call tree.
If bit 2 of \f(CW\*(C`frame\*(C'\fR is set, a line is printed on exit from a
subroutine as well.  If bit 4 is set, tha arguments is printed
along wit tha calla info.  If bit 8 is set, tha arguments are
printed even if they is tied or references.  If bit 16 is set, the
return value is printed, like a muthafucka.
.PP
When a package is compiled, a line like this
.PP
.Vb 1
\&    Package lib/Carp.pm.
.Ve
.PP
is printed wit proper indentation.
.SH "Debuggin Regular Expressions"
.IX Header "Debuggin Regular Expressions"
There is two ways ta enable debuggin output fo' regular expressions.
.PP
If yo' perl is compiled wit \f(CW\*(C`\-DDEBUGGING\*(C'\fR, you may use the
\&\fB\-Dr\fR flag on tha command line.
.PP
Otherwise, one can \f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR, which has effects at
compile time n' run time.  Since Perl 5.9.5, dis pragma is lexically
scoped.
.SS "Compile-time Output"
.IX Subsection "Compile-time Output"
Da debuggin output at compile time be lookin like this:
.PP
.Vb 10
\&  Compilin REx \*(Aq[bc]d(ef*g)+h[ij]k$\*(Aq
\&  size 45 Got 364 bytes fo' offset annotations.
\&  first at 1
\&  rarest char g at 0
\&  rarest char d at 0
\&     1: ANYOF[bc](12)
\&    12: EXACT <d>(14)
\&    14: CURLYX[0] {1,32767}(28)
\&    16:   OPEN1(18)
\&    18:     EXACT <e>(20)
\&    20:     STAR(23)
\&    21:       EXACT <f>(0)
\&    23:     EXACT <g>(25)
\&    25:   CLOSE1(27)
\&    27:   WHILEM[1/1](0)
\&    28: NOTHING(29)
\&    29: EXACT <h>(31)
\&    31: ANYOF[ij](42)
\&    42: EXACT <k>(44)
\&    44: EOL(45)
\&    45: END(0)
\&  anchored \*(Aqde\*(Aq at 1 floatin \*(Aqgh\*(Aq at 3..2147483647 (checkin floating) 
\&        stclass \*(AqANYOF[bc]\*(Aq minlen 7 
\&  Offsets: [45]
\&        1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
\&        0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
\&        11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
\&        0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]  
\&  Omittin $\` $& $\*(Aq support.
.Ve
.PP
Da first line shows tha pre-compiled form of tha regex.  Da second
shows tha size of tha compiled form (in arbitrary units, usually
4\-byte lyrics) n' tha total number of bytes allocated fo' the
offset/length table, probably 4+\f(CW\*(C`size\*(C'\fR*8.  Da next line shows the
label \fIid\fR of tha straight-up original gangsta node dat do a match.
.PP
The
.PP
.Vb 2
\&  anchored \*(Aqde\*(Aq at 1 floatin \*(Aqgh\*(Aq at 3..2147483647 (checkin floating) 
\&        stclass \*(AqANYOF[bc]\*(Aq minlen 7
.Ve
.PP
line (split tha fuck into two lines above) gotz nuff optimizer
information. I aint talkin' bout chicken n' gravy biatch.  In tha example shown, tha optimizer found dat tha match 
should contain a substrin \f(CW\*(C`de\*(C'\fR at offset 1, plus substrin \f(CW\*(C`gh\*(C'\fR
at some offset between 3 n' infinity.  Mo'over, when checkin for
these substrings (to abandon impossible matches quickly), Perl will check
for tha substrin \f(CW\*(C`gh\*(C'\fR before checkin fo' tha substrin \f(CW\*(C`de\*(C'\fR.  The
optimizer may also use tha knowledge dat tha match starts (at the
\&\f(CW\*(C`first\*(C'\fR \fIid\fR) wit a cold-ass lil characta class, n' no strang 
shorta than 7 charactas can possibly match.
.PP
Da fieldz of interest which may step tha fuck up in dis line are
.ie n .IP """anchored"" \fI\s-1STRING\s0\fR ""at"" \fI\s-1POS\s0\fR" 4
.el .IP "\f(CWanchored\fR \fI\s-1STRING\s0\fR \f(CWat\fR \fI\s-1POS\s0\fR" 4
.IX Item "anchored STRING at POS"
.PD 0
.ie n .IP """floating"" \fI\s-1STRING\s0\fR ""at"" \fI\s-1POS1..POS2\s0\fR" 4
.el .IP "\f(CWfloating\fR \fI\s-1STRING\s0\fR \f(CWat\fR \fI\s-1POS1..POS2\s0\fR" 4
.IX Item "floatin STRING at POS1..POS2"
.PD
See above.
.ie n .IP """matchin floating/anchored""" 4
.el .IP "\f(CWmatchin floating/anchored\fR" 4
.IX Item "matchin floating/anchored"
Which substrin ta check first.
.ie n .IP """minlen""" 4
.el .IP "\f(CWminlen\fR" 4
.IX Item "minlen"
Da minimal length of tha match.
.ie n .IP """stclass"" \fI\s-1TYPE\s0\fR" 4
.el .IP "\f(CWstclass\fR \fI\s-1TYPE\s0\fR" 4
.IX Item "stclass TYPE"
Type of first matchin node.
.ie n .IP """noscan""" 4
.el .IP "\f(CWnoscan\fR" 4
.IX Item "noscan"
Don't scan fo' tha found substrings.
.ie n .IP """isall""" 4
.el .IP "\f(CWisall\fR" 4
.IX Item "isall"
Means dat tha optimizer shiznit be all dat tha regular
expression gotz nuff, n' thus one do not need ta enta tha regex engine at
all.
.ie n .IP """GPOS""" 4
.el .IP "\f(CWGPOS\fR" 4
.IX Item "GPOS"
Set if tha pattern gotz nuff \f(CW\*(C`\eG\*(C'\fR.
.ie n .IP """plus""" 4
.el .IP "\f(CWplus\fR" 4
.IX Item "plus"
Set if tha pattern starts wit a repeated char (as up in \f(CW\*(C`x+y\*(C'\fR).
.ie n .IP """implicit""" 4
.el .IP "\f(CWimplicit\fR" 4
.IX Item "implicit"
Set if tha pattern starts wit \f(CW\*(C`.*\*(C'\fR.
.ie n .IP """with eval""" 4
.el .IP "\f(CWwith eval\fR" 4
.IX Item "with eval"
Set if tha pattern contain eval-groups, like fuckin \f(CW\*(C`(?{ code })\*(C'\fR and
\&\f(CW\*(C`(??{ code })\*(C'\fR.
.ie n .IP """anchored(TYPE)""" 4
.el .IP "\f(CWanchored(TYPE)\fR" 4
.IX Item "anchored(TYPE)"
If tha pattern may match only at a handful of places, wit \f(CW\*(C`TYPE\*(C'\fR
bein \f(CW\*(C`BOL\*(C'\fR, \f(CW\*(C`MBOL\*(C'\fR, or \f(CW\*(C`GPOS\*(C'\fR.  See tha table below.
.PP
If a substrin is known ta match at end-of-line only, it may be
followed by \f(CW\*(C`$\*(C'\fR, as up in \f(CW\*(C`floatin \*(Aqk\*(Aq$\*(C'\fR.
.PP
Da optimizer-specific shiznit is used ta avoid enterin (a slow) regex
engine on strings dat aint gonna definitely match.  If tha \f(CW\*(C`isall\*(C'\fR flag
is set, a cold-ass lil call ta tha regex engine may be avoided even when tha optimizer
found a appropriate place fo' tha match.
.PP
Above tha optimizer section is tha list of \fInodes\fR of tha compiled
form of tha regex.  Each line has format
.PP
\&\f(CW\*(C`   \*(C'\fR\fIid\fR: \fI\s-1TYPE\s0\fR \fIOPTIONAL-INFO\fR (\fInext-id\fR)
.SS "Typez of Nodes"
.IX Subsection "Typez of Nodes"
Here is tha possible types, wit short descriptions:
.PP
.Vb 1
\& # TYPE arg\-description [num\-args] [longjump\-len] DESCRIPTION
\&
\& # Exit points
\&
\& END                no         End of program.
\& SUCCEED            no         Return from a subroutine, basically.
\&
\& # Anchors:
\&
\& BOL                no         Match "" at beginnin of line.
\& MBOL               no         Same, assumin multiline.
\& SBOL               no         Same, assumin singleline.
\& EOS                no         Match "" at end of string.
\& EOL                no         Match "" at end of line.
\& MEOL               no         Same, assumin multiline.
\& SEOL               no         Same, assumin singleline.
\& BOUND              no         Match "" at any word boundary using
\&                               natizzle charset semantics fo' non\-utf8
\& BOUNDL             no         Match "" at any locale word boundary
\& BOUNDU             no         Match "" at any word boundary using
\&                               Unicode semantics
\& BOUNDA             no         Match "" at any word boundary rockin ASCII
\&                               semantics
\& NBOUND             no         Match "" at any word non\-boundary using
\&                               natizzle charset semantics fo' non\-utf8
\& NBOUNDL            no         Match "" at any locale word non\-boundary
\& NBOUNDU            no         Match "" at any word non\-boundary using
\&                               Unicode semantics
\& NBOUNDA            no         Match "" at any word non\-boundary using
\&                               ASCII semantics
\& GPOS               no         Matches where last m//g left off.
\&
\& # [Special] alternatives:
\&
\& REG_ANY            no         Match any one characta (except newline).
\& SANY               no         Match any one character.
\& CANY               no         Match any one byte.
\& ANYOF              sv         Match characta up in (or not in) this
\&                               class, single char match only
\& ANYOF_WARN_SUPER   sv         Match characta up in (or not in) this
\&                               class, warn (if enabled) upon matchin a
\&                               char above Unicode max;
\& ANYOF_SYNTHETIC    sv         Synthetic start class
\&
\& POSIXD             none       Some [[:class:]] under /d; tha FLAGS
\&                               field gives which one
\& POSIXL             none       Some [[:class:]] under /l; tha FLAGS
\&                               field gives which one
\& POSIXU             none       Some [[:class:]] under /u; tha FLAGS
\&                               field gives which one
\& POSIXA             none       Some [[:class:]] under /a; tha FLAGS
\&                               field gives which one
\& NPOSIXD            none       complement of POSIXD, [[:^class:]]
\& NPOSIXL            none       complement of POSIXL, [[:^class:]]
\& NPOSIXU            none       complement of POSIXU, [[:^class:]]
\& NPOSIXA            none       complement of POSIXA, [[:^class:]]
\&
\& CLUMP              no         Match any extended grapheme cluster
\&                               sequence
\&
\& # Alternation
\&
\& # BRANCH        Da set of branches constitutin a single chizzle are
\& #               hooked together wit they "next" pointers, since
\& #               precedence prevents anythang bein concatenated to
\& #               any individual branch.  Da "next" pointa of tha last
\& #               BRANCH up in a cold-ass lil chizzle points ta tha thang followin the
\& #               whole chizzle.  This be also where tha final "next"
\& #               pointa of each individual branch points; each branch
\& #               starts wit tha operand node of a BRANCH node.
\& #
\& BRANCH             node       Match dis alternative, or tha next...
\&
\& # Back pointer
\&
\& # BACK          Normal "next" pointas all implicitly point forward;
\& #               BACK exists ta make loop structures possible.
\& # not used
\& BACK               no         Match "", "next" ptr points backward.
\&
\& # Literals
\&
\& EXACT              str        Match dis strang (preceded by length).
\& EXACTF             str        Match dis non\-UTF\-8 strang (not
\&                               guaranteed ta be folded) rockin /id rules
\&                               (w/len).
\& EXACTFL            str        Match dis strang (not guaranteed ta be
\&                               folded) rockin /il rulez (w/len).
\& EXACTFU            str        Match dis strang (folded iff up in UTF\-8,
\&                               length up in foldin don\*(Aqt chizzle if not
\&                               up in UTF\-8) rockin /iu rulez (w/len).
\& EXACTFA            str        Match dis strang (not guaranteed ta be
\&                               folded) rockin /iaa rulez (w/len).
\& EXACTFU_SS         str        Match dis strang (folded iff up in UTF\-8,
\&                               length up in foldin may chizzle even if not
\&                               up in UTF\-8) rockin /iu rulez (w/len).
\& EXACTFU_TRICKYFOLD str        Match dis folded UTF\-8 strang rockin /iu
\&                               rules
\&
\& # Do not a god damn thang types
\&
\& NOTHING            no         Match empty string.
\& # A variant of above which delimits a group, thus stops optimizations
\& TAIL               no         Match empty string. Can jump here from
\&                               outside.
\&
\& # Loops
\&
\& # STAR,PLUS    \*(Aq?\*(Aq, n' complex \*(Aq*\*(Aq n' \*(Aq+\*(Aq, is implemented as
\& #               circular BRANCH structures rockin BACK.  Simple cases
\& #               (one characta per match) is implemented wit STAR
\& #               n' PLUS fo' speed n' ta minimize recursive plunges.
\& #
\& STAR               node       Match dis (simple) thang 0 or more
\&                               times.
\& PLUS               node       Match dis (simple) thang 1 or more
\&                               times.
\&
\& CURLY              sv 2       Match dis simple thang {n,m} times.
\& CURLYN             no 2       Capture next\-after\-this simple thang
\& CURLYM             no 2       Capture dis medium\-complex thang {n,m}
\&                               times.
\& CURLYX             sv 2       Match dis complex thang {n,m} times.
\&
\& # This terminator creates a loop structure fo' CURLYX
\& WHILEM             no         Do curly processin n' peep if rest
\&                               matches.
\&
\& # Buffer related
\&
\& # OPEN,CLOSE,GROUPP     ...are numbered at compile time.
\& OPEN               num 1      Mark dis point up in input as start of #n.
\& CLOSE              num 1      Analogous ta OPEN.
\&
\& REF                num 1      Match some already matched string
\& REFF               num 1      Match already matched string, folded
\&                               rockin natizzle charset semantics fo' non\-
\&                               utf8
\& REFFL              num 1      Match already matched string, folded in
\&                               loc.
\& REFFU              num 1      Match already matched string, folded
\&                               rockin unicode semantics fo' non\-utf8
\& REFFA              num 1      Match already matched string, folded
\&                               rockin unicode semantics fo' non\-utf8, no
\&                               mixin ASCII, non\-ASCII
\&
\& # Named references.  Code up in regcomp.c assumes dat these all is after
\& # tha numbered references
\& NREF               no\-sv 1    Match some already matched string
\& NREFF              no\-sv 1    Match already matched string, folded
\&                               rockin natizzle charset semantics fo' non\-
\&                               utf8
\& NREFFL             no\-sv 1    Match already matched string, folded in
\&                               loc.
\& NREFFU             num 1      Match already matched string, folded
\&                               rockin unicode semantics fo' non\-utf8
\& NREFFA             num 1      Match already matched string, folded
\&                               rockin unicode semantics fo' non\-utf8, no
\&                               mixin ASCII, non\-ASCII
\&
\& IFMATCH            off 1 2    Succeedz if tha followin matches.
\& UNLESSM            off 1 2    Fails if tha followin matches.
\& SUSPEND            off 1 1    "Independent" sub\-RE.
\& IFTHEN             off 1 1    Switch, should be preceded by switcher.
\& GROUPP             num 1      Whether tha crew matched.
\&
\& # Support fo' long RE
\&
\& LONGJMP            off 1 1    Jump far away.
\& BRANCHJ            off 1 1    BRANCH wit long offset.
\&
\& # Da heavy worker
\&
\& EVAL               evl 1      Execute some Perl code.
\&
\& # Modifiers
\&
\& MINMOD             no         Next operator aint greedy.
\& LOGICAL            no         Next opcode should set tha flag only.
\&
\& # This aint used yet
\& RENUM              off 1 1    Group wit independently numbered parens.
\&
\& # Trie Related
\&
\& # Behave tha same as A|LIST|OF|WORDS would. Y'all KNOW dat shit, muthafucka! Da \*(Aq..C\*(Aq variants
\& # have inline charclass data (ascii only), tha \*(AqC\*(Aq store it up in the
\& # structure.
\&
\& TRIE               trie 1     Match nuff EXACT(F[ALU]?)? at once.
\&                               flags==type
\& TRIEC              trie       Same as TRIE yo, but wit embedded charclass
\&                    charclass  data
\&
\& AHOCORASICK        trie 1     Aho Corasick stclass. flags==type
\& AHOCORASICKC       trie       Same as AHOCORASICK yo, but wit embedded
\&                    charclass  charclass data
\&
\& # Regex Subroutines
\& GOSUB              num/ofs 2L recurse ta paren arg1 at (signed) ofs
\&                               arg2
\& GOSTART            no         recurse ta start of pattern
\&
\& # Special conditionals
\& NGROUPP            no\-sv 1    Whether tha crew matched.
\& INSUBP             num 1      Whether we is up in a specific recurse.
\& DEFINEP            none 1     Never execute directly.
\&
\& # Backtrackin Verbs
\& ENDLIKE            none       Used only fo' tha type field of verbs
\& OPFAIL             none       Same as (?!)
\& ACCEPT             parno 1    Accepts tha current matched string.
\&
\& # Verbs With Arguments
\& VERB               no\-sv 1    Used only fo' tha type field of verbs
\& PRUNE              no\-sv 1    Pattern fails at dis startpoint if no\-
\&                               backtrackin all up in this
\& MARKPOINT          no\-sv 1    Push tha current location fo' rollback by
\&                               cut.
\& SKIP               no\-sv 1    On failure skip forward (to tha mark)
\&                               before retrying
\& COMMIT             no\-sv 1    Pattern fails outright if backtracking
\&                               all up in this
\& CUTGROUP           no\-sv 1    On failure git all up in tha next alternation in
\&                               tha group
\&
\& # Control what tha fuck ta keep up in $&.
\& KEEPS              no         $& begins here.
\&
\& # New charclass like patterns
\& LNBREAK            none       generic newline pattern
\&
\& # SPECIAL  REGOPS
\&
\& # This aint straight-up a node yo, but a optimized away piece of a "long"
\& # node.  To simplify debuggin output, we mark it as if it was a node
\& OPTIMIZED          off        Placeholda fo' dump.
\&
\& # Special opcode wit tha property dat no opcode up in a cold-ass lil compiled program
\& # will eva be of dis type. Thus it can be used as a gangbangin' flag value that
\& # no other opcode has been seen. I aint talkin' bout chicken n' gravy biatch. END is used similarly, up in dat a END
\& # node cant be optimized. Y'all KNOW dat shit, muthafucka! So END implies "unoptimizable" n' PSEUDO
\& # mean "not peeped anythang ta optimize yet".
\& PSEUDO             off        Pseudo opcode fo' internal use.
.Ve
.PP
Peepin tha optimizer shiznit be a thugged-out dump of tha offset/length
table, here split across nuff muthafuckin lines:
.PP
.Vb 5
\&  Offsets: [45]
\&        1[4] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 5[1]
\&        0[0] 12[1] 0[0] 6[1] 0[0] 7[1] 0[0] 9[1] 8[1] 0[0] 10[1] 0[0]
\&        11[1] 0[0] 12[0] 12[0] 13[1] 0[0] 14[4] 0[0] 0[0] 0[0] 0[0]
\&        0[0] 0[0] 0[0] 0[0] 0[0] 0[0] 18[1] 0[0] 19[1] 20[0]
.Ve
.PP
Da first line here indicates dat tha offset/length table gotz nuff 45
entries. Put ya muthafuckin choppers up if ya feel dis!  Each entry be a pair of integers, denoted by \f(CW\*(C`offset[length]\*(C'\fR.
Entries is numbered startin wit 1, so entry #1 here is \f(CW\*(C`1[4]\*(C'\fR and
entry #12 is \f(CW\*(C`5[1]\*(C'\fR.  \f(CW\*(C`1[4]\*(C'\fR indicates dat tha node labeled \f(CW\*(C`1:\*(C'\fR
(the \f(CW\*(C`1: ANYOF[bc]\*(C'\fR) begins at characta posizzle 1 up in the
pre-compiled form of tha regex, n' has a length of 4 characters.
\&\f(CW\*(C`5[1]\*(C'\fR up in posizzle 12 
indicates dat tha node labeled \f(CW\*(C`12:\*(C'\fR
(the \f(CW\*(C`12: EXACT <d>\*(C'\fR) begins at characta posizzle 5 up in the
pre-compiled form of tha regex, n' has a length of 1 character.
\&\f(CW\*(C`12[1]\*(C'\fR up in posizzle 14 
indicates dat tha node labeled \f(CW\*(C`14:\*(C'\fR
(the \f(CW\*(C`14: CURLYX[0] {1,32767}\*(C'\fR) begins at characta posizzle 12 up in the
pre-compiled form of tha regex, n' has a length of 1 character\-\-\-that
is, it correspondz ta tha \f(CW\*(C`+\*(C'\fR symbol up in tha precompiled regex.
.PP
\&\f(CW\*(C`0[0]\*(C'\fR shit indicate dat there is no correspondin node.
.SS "Run-time Output"
.IX Subsection "Run-time Output"
First of all, when bustin a match, one may git no run-time output even
if debuggin is enabled. Y'all KNOW dat shit, muthafucka!  This means dat tha regex engine was never
entered n' dat all of tha thang was therefore done by tha optimizer.
.PP
If tha regex engine was entered, tha output may be lookin like this:
.PP
.Vb 10
\&  Matchin \*(Aq[bc]d(ef*g)+h[ij]k$\*(Aq against \*(Aqabcdefg_\|_gh_\|_\*(Aq
\&    Settin a EVAL scope, savestack=3
\&     2 <ab> <cdefg_\|_gh_>    |  1: ANYOF
\&     3 <abc> <defg_\|_gh_>    | 11: EXACT <d>
\&     4 <abcd> <efg_\|_gh_>    | 13: CURLYX {1,32767}
\&     4 <abcd> <efg_\|_gh_>    | 26:   WHILEM
\&                                0 outta 1..32767  cc=effff31c
\&     4 <abcd> <efg_\|_gh_>    | 15:     OPEN1
\&     4 <abcd> <efg_\|_gh_>    | 17:     EXACT <e>
\&     5 <abcde> <fg_\|_gh_>    | 19:     STAR
\&                             EXACT <f> can match 1 times outta 32767...
\&    Settin a EVAL scope, savestack=3
\&     6 <bcdef> <g_\|_gh_\|_>    | 22:       EXACT <g>
\&     7 <bcdefg> <_\|_gh_\|_>    | 24:       CLOSE1
\&     7 <bcdefg> <_\|_gh_\|_>    | 26:       WHILEM
\&                                    1 outta 1..32767  cc=effff31c
\&    Settin a EVAL scope, savestack=12
\&     7 <bcdefg> <_\|_gh_\|_>    | 15:         OPEN1
\&     7 <bcdefg> <_\|_gh_\|_>    | 17:         EXACT <e>
\&       restorin \e1 ta 4(4)..7
\&                                    failed, try continuation...
\&     7 <bcdefg> <_\|_gh_\|_>    | 27:         NOTHING
\&     7 <bcdefg> <_\|_gh_\|_>    | 28:         EXACT <h>
\&                                    failed...
\&                                failed...
.Ve
.PP
Da most dope shiznit up in tha output be bout tha particular \fInode\fR
of tha compiled regex dat is currently bein tested against tha target string.
Da format of these lines is
.PP
\&\f(CW\*(C`    \*(C'\fR\fISTRING-OFFSET\fR <\fIPRE-STRING\fR> <\fIPOST-STRING\fR>   |\fI\s-1ID\s0\fR:  \fI\s-1TYPE\s0\fR
.PP
Da \fI\s-1TYPE\s0\fR info is indented wit respect ta tha backtrackin level.
Other incidental shiznit appears interspersed within.
.SH "Debuggin Perl Memory Usage"
.IX Header "Debuggin Perl Memory Usage"
Perl be a profligate wastrel when it comes ta memory use.  There
is a sayin dat ta estimate memory usage of Perl, assume a reasonable
algorithm fo' memory allocation, multiply dat estimate by 10, and
while you still may miss tha mark, at least you won't be like so
astonished. Y'all KNOW dat shit, muthafucka!  This aint straight-up true yo, but may provide a good
grasp of what tha fuck happens.
.PP
Assume dat a integer cannot take less than 20 bytez of memory, a
float cannot take less than 24 bytes, a strang cannot take less
than 32 bytes (all these examplez assume 32\-bit architectures, the
result is like a lil' bit worse on 64\-bit architectures).  If a variable
is accessed up in two of three different ways (which require a integer,
a float, or a string), tha memory footprint may increase yet another
20 bytes.  A sloppy \fImalloc\fR\|(3) implementation can inflate these
numbers dramatically.
.PP
On tha opposite end of tha scale, a thugged-out declaration like
.PP
.Vb 1
\&  sub foo;
.Ve
.PP
may take up ta 500 bytez of memory, dependin on which release of Perl
yo ass is hustlin.
.PP
Anecdotal estimatez of source-to-compiled code bloat suggest an
eightfold increase.  This means dat tha compiled form of reasonable
(normally commented, properly indented etc.) code will take
about eight times mo' space up in memory than tha code took
on disk.
.PP
Da \fB\-DL\fR command-line switch is obsolete since circa Perl 5.6.0
(it was available only if Perl was built wit \f(CW\*(C`\-DDEBUGGING\*(C'\fR).
Da switch was used ta track Perlz memory allocations n' possible
memory leaks.  These minutes tha use of malloc debuggin tools like
\&\fIPurify\fR or \fIvalgrind\fR is suggested instead. Y'all KNOW dat shit, muthafucka!  See also
\&\*(L"\s-1PERL_MEM_LOG\*(R"\s0 up in perlhacktips.
.PP
One way ta smoke up how tha fuck much memory is bein used by Perl data
structures is ta install tha Devel::Size module from \s-1CPAN:\s0 it gives
you tha minimum number of bytes required ta store a particular data
structure.  Please be mindful of tha difference between tha \fIsize()\fR
and \fItotal_size()\fR.
.PP
If Perl has been compiled rockin Perlz malloc you can analyze Perl
memory usage by settin \f(CW$ENV\fR{\s-1PERL_DEBUG_MSTATS\s0}.
.ie n .SS "Usin $ENV{PERL_DEBUG_MSTATS}"
.el .SS "Usin \f(CW$ENV{PERL_DEBUG_MSTATS}\fP"
.IX Subsection "Usin $ENV{PERL_DEBUG_MSTATS}"
If yo' perl is rockin Perlz \fImalloc()\fR n' was compiled wit the
necessary switches (this is tha default), then it will print memory
usage statistics afta compilin yo' code when \f(CW\*(C`$ENV{PERL_DEBUG_MSTATS}
> 1\*(C'\fR, n' before termination of tha program when \f(CW\*(C`$ENV{PERL_DEBUG_MSTATS} >= 1\*(C'\fR.  Da report format is similar to
the followin example:
.PP
.Vb 10
\&  $ PERL_DEBUG_MSTATS=2 perl \-e "require Carp"
\&  Memory allocation statistics afta compilation: (buckets 4(4)..8188(8192)
\&     14216 free:   130   117    28     7     9   0   2     2   1 0 0
\&                437    61    36     0     5
\&     60924 used:   125   137   161    55     7   8   6    16   2 0 1
\&                 74   109   304    84    20
\&  Total sbrk(): 77824/21:119. Odd ends: pad+heads+chain+tail: 0+636+0+2048.
\&  Memory allocation statistics afta execution:   (buckets 4(4)..8188(8192)
\&     30888 free:   245    78    85    13     6   2   1     3   2 0 1
\&                315   162    39    42    11
\&    175816 used:   265   176  1112   111    26  22  11    27   2 1 1
\&                196   178  1066   798    39
\&  Total sbrk(): 215040/47:145. Odd ends: pad+heads+chain+tail: 0+2192+0+6144.
.Ve
.PP
It be possible ta ask fo' such a statistic at arbitrary points in
your execution rockin tha \fImstat()\fR function outta tha standard
Devel::Peek module.
.PP
Here is some explanation of dat format:
.ie n .IP """buckets SMALLEST(APPROX)..GREATEST(APPROX)""" 4
.el .IP "\f(CWbuckets SMALLEST(APPROX)..GREATEST(APPROX)\fR" 4
.IX Item "buckets SMALLEST(APPROX)..GREATEST(APPROX)"
Perlz \fImalloc()\fR uses bucketed allocations.  Every request is rounded
up ta tha closest bucket size available, n' a funky-ass bucket is taken from
the pool of bucketz of dat size.
.Sp
Da line above raps bout tha limitz of buckets currently up in use.
Each bucket has two sizes: memory footprint n' tha maximal size
of user data dat can fit tha fuck into dis bucket.  Suppose up in tha above
example dat tha smallest bucket was size 4.  Da freshest bucket
would have usable size 8188, n' tha memory footprint would be 8192.
.Sp
In a Perl built fo' debugging, some buckets may have wack usable
size.  This means dat these buckets cannot (and will not) be used.
For larger buckets, tha memory footprint may be one page pimped outer
than a juice of 2.  If so, tha correspondin juice of two is
printed up in tha \f(CW\*(C`APPROX\*(C'\fR field above.
.IP "Free/Used" 4
.IX Item "Free/Used"
Da 1 or 2 rowz of numbers followin dat correspond ta tha number
of bucketz of each size between \f(CW\*(C`SMALLEST\*(C'\fR n' \f(CW\*(C`GREATEST\*(C'\fR.  In
the first row, tha sizes (memory footprints) of buckets is powers
of two\*(--or possibly one page pimped outer n' shit.  In tha second row, if present,
the memory footprintz of tha buckets is between tha memory footprints
of two buckets \*(L"above\*(R".
.Sp
For example, suppose under tha previous example, tha memory footprints
were
.Sp
.Vb 2
\&     free:    8     16    32    64    128  256 512 1024 2048 4096 8192
\&           4     12    24    48    80
.Ve
.Sp
With a non\-\f(CW\*(C`DEBUGGING\*(C'\fR perl, tha buckets startin from \f(CW128\fR have
a 4\-byte overhead, n' thus a 8192\-long bucket may take up to
8188\-byte allocations.
.ie n .IP """Total sbrk(): SBRKed/SBRKs:CONTINUOUS""" 4
.el .IP "\f(CWTotal sbrk(): SBRKed/SBRKs:CONTINUOUS\fR" 4
.IX Item "Total sbrk(): SBRKed/SBRKs:CONTINUOUS"
Da first two fieldz give tha total amount of memory perl \fIsbrk\fR\|(2)ed
(ess-broken? :\-) n' number of \fIsbrk\fR\|(2)s used. Y'all KNOW dat shit, muthafucka!  Da third number is
what perl be thinkin bout continuitizzle of returned chunks.  So long as
this number is positive, \fImalloc()\fR will assume dat it is probable
that \fIsbrk\fR\|(2) will provide continuous memory.
.Sp
Memory allocated by external libraries aint counted.
.ie n .IP """pad: 0""" 4
.el .IP "\f(CWpad: 0\fR" 4
.IX Item "pad: 0"
Da amount of \fIsbrk\fR\|(2)ed memory needed ta keep buckets aligned.
.ie n .IP """heads: 2192""" 4
.el .IP "\f(CWheads: 2192\fR" 4
.IX Item "heads: 2192"
Although memory overhead of bigger buckets is kept inside tha bucket, for
smalla buckets, it is kept up in separate areas.  This field gives the
total size of these areas.
.ie n .IP """chain: 0""" 4
.el .IP "\f(CWchain: 0\fR" 4
.IX Item "chain: 0"
\&\fImalloc()\fR may wanna subdivide a funky-ass bigger bucket tha fuck into smalla buckets.
If only a part of tha deceased bucket is left unsubdivided, tha rest
is kept as a element of a linked list.  This field gives tha total
size of these chunks.
.ie n .IP """tail: 6144""" 4
.el .IP "\f(CWtail: 6144\fR" 4
.IX Item "tail: 6144"
To minimize tha number of \fIsbrk\fR\|(2)s, \fImalloc()\fR asks fo' mo' memory.  This
field gives tha size of tha yet unused part, which is \fIsbrk\fR\|(2)ed yo, but
never touched.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perldebug,
perlguts,
perlrun
re,
and
Devel::DProf.
