.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-FILTERS 1"
.TH FFMPEG-FILTERS 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-filtas \- FFmpeg filters
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout filters, sources, n' sinks provided by the
libavfilta library.
.SH "FILTERING INTRODUCTION"
.IX Header "FILTERING INTRODUCTION"
Filterin up in FFmpeg is enabled all up in tha libavfilta library.
.PP
In libavfilter, a gangbangin' filta can have multiple inputs n' multiple
outputs.
To illustrate tha sortz of thangs dat is possible, we consider the
followin filtergraph.
.PP
.Vb 5
\&                        [main]
\&        input \-\-> split \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> overlay \-\-> output
\&                    |                             ^
\&                    |[tmp]                  [flip]|
\&                    +\-\-\-\-\-> crop \-\-> vflip \-\-\-\-\-\-\-+
.Ve
.PP
This filtergraph splits tha input stream up in two streams, sendz one
stream all up in tha crop filta n' tha vflip filta before mergin it
back wit tha other stream by overlayin it on top. Yo ass can use the
followin command ta bust dis:
.PP
.Vb 1
\&        ffmpeg \-i INPUT \-vf "split [main][tmp]; [tmp] crop=iw:ih/2:0:0, vflip [flip]; [main][flip] overlay=0:H/2" OUTPUT
.Ve
.PP
Da result is ghon be dat up in output tha top half of tha vizzle is mirrored
onto tha bottom half.
.PP
Filtas up in tha same linear chain is separated by commas, n' distinct
linear chainz of filtas is separated by semicolons. In our example,
\&\fIcrop,vflip\fR is up in one linear chain, \fIsplit\fR and
\&\fIoverlay\fR is separately up in another n' shit. Da points where tha linear
chains join is labelled by names enclosed up in square brackets, n' you can put dat on yo' toast. In the
example, tha split filta generates two outputs dat is associated to
the labels \fI[main]\fR n' \fI[tmp]\fR.
.PP
Da stream busted ta tha second output of \fIsplit\fR, labelled as
\&\fI[tmp]\fR, is processed all up in tha \fIcrop\fR filter, which crops
away tha lower half part of tha vizzle, n' then vertically flipped. Y'all KNOW dat shit, muthafucka! The
\&\fIoverlay\fR filta takes up in input tha straight-up original gangsta unchanged output of the
split filta (which was labelled as \fI[main]\fR), n' overlay on its
lower half tha output generated by tha \fIcrop,vflip\fR filterchain.
.PP
Some filtas take up in input a list of parameters: they is specified
afta tha filta name n' a equal sign, n' is separated from each other
by a cold-ass lil colon.
.PP
There exist so-called \fIsource filters\fR dat aint gots an
audio/video input, n' \fIsink filters\fR dat aint gonna have audio/video
output.
.SH "GRAPH"
.IX Header "GRAPH"
Da \fIgraph2dot\fR program included up in tha FFmpeg \fItools\fR
directory can be used ta parse a gangbangin' filtergraph description n' issue a
correspondin textual representation up in tha dot language.
.PP
Invoke tha command:
.PP
.Vb 1
\&        graph2dot \-h
.Ve
.PP
to peep how tha fuck ta use \fIgraph2dot\fR.
.PP
Yo ass can then pass tha dot description ta tha \fIdot\fR program (from
the graphviz suite of programs) n' obtain a graphical representation
of tha filtergraph.
.PP
For example tha sequence of commands:
.PP
.Vb 4
\&        echo <GRAPH_DESCRIPTION> | \e
\&        tools/graph2dot \-o graph.tmp && \e
\&        dot \-Tpng graph.tmp \-o graph.png && \e
\&        display graph.png
.Ve
.PP
can be used ta create n' display a image representin tha graph
busted lyrics bout by tha \fI\s-1GRAPH_DESCRIPTION\s0\fR string. Note dat dis strang must be
a complete self-contained graph, wit its inputs n' outputs explicitly defined.
For example if yo' command line iz of tha form:
.PP
.Vb 1
\&        ffmpeg \-i infile \-vf scale=640:360 outfile
.Ve
.PP
your \fI\s-1GRAPH_DESCRIPTION\s0\fR strang will need ta be of tha form:
.PP
.Vb 1
\&        nullsrc,scale=640:360,nullsink
.Ve
.PP
you may also need ta set tha \fInullsrc\fR parametas n' add a \fIformat\fR
filta up in order ta simulate a specific input file.
.SH "FILTERGRAPH DESCRIPTION"
.IX Header "FILTERGRAPH DESCRIPTION"
A filtergraph be a gangbangin' finger-lickin' pimped up graph of connected filters. Well shiiiit, it can contain
cycles, n' there can be multiple links between a pair of
filters. Each link has one input pad on one side connectin it ta one
filta from which it takes its input, n' one output pad on tha other
side connectin it ta tha one filta acceptin its output.
.PP
Each filta up in a gangbangin' filtergraph be a instizzle of a gangbangin' filta class
registered up in tha application, which defines tha features n' the
number of input n' output padz of tha filter.
.PP
A filta wit no input padz is called a \*(L"source\*(R", a gangbangin' filta wit no
output padz is called a \*(L"sink\*(R".
.SS "Filtergraph syntax"
.IX Subsection "Filtergraph syntax"
A filtergraph can be represented rockin a textual representation, which is
recognized by tha \fB\-filter\fR/\fB\-vf\fR n' \fB\-filter_complex\fR
options up in \fBffmpeg\fR n' \fB\-vf\fR up in \fBffplay\fR, n' by the
\&\f(CW\*(C`avfilter_graph_parse()\*(C'\fR/\f(CW\*(C`avfilter_graph_parse2()\*(C'\fR function defined in
\&\fIlibavfilter/avfilter.h\fR.
.PP
A filterchain consistz of a sequence of connected filters, each one
connected ta tha previous one up in tha sequence fo' realz. A filterchain is
represented by a list of \*(L",\*(R"\-separated filta descriptions.
.PP
A filtergraph consistz of a sequence of filterchains fo' realz. A sequence of
filterchains is represented by a list of \*(L";\*(R"\-separated filterchain
descriptions.
.PP
A filta is represented by a strang of tha form:
[\fIin_link_1\fR]...[\fIin_link_N\fR]\fIfilter_name\fR=\fIarguments\fR[\fIout_link_1\fR]...[\fIout_link_M\fR]
.PP
\&\fIfilter_name\fR is tha name of tha filta class of which the
busted lyrics bout filta be a instizzle of, n' has ta be tha name of one of
the filta classes registered up in tha program.
Da name of tha filta class is optionally followed by a string
"=\fIarguments\fR".
.PP
\&\fIarguments\fR be a strang which gotz nuff tha parametas used to
initialize tha filta instance. Well shiiiit, it may have one of tha followin forms:
.IP "\(bu" 4
A ':'\-separated list of \fIkey=value\fR pairs.
.IP "\(bu" 4
A ':'\-separated list of \fIvalue\fR. In dis case, tha keys is assumed ta be
the option names up in tha order they is declared. Y'all KNOW dat shit, muthafucka! E.g. tha \f(CW\*(C`fade\*(C'\fR filter
declares three options up in dis order \*(-- \fBtype\fR, \fBstart_frame\fR and
\&\fBnb_frames\fR. Then tha parameta list \fIin:0:30\fR means dat tha value
\&\fIin\fR be assigned ta tha option \fBtype\fR, \fI0\fR to
\&\fBstart_frame\fR n' \fI30\fR ta \fBnb_frames\fR.
.IP "\(bu" 4
A ':'\-separated list of mixed direct \fIvalue\fR n' long \fIkey=value\fR
pairs. Da direct \fIvalue\fR must precede tha \fIkey=value\fR pairs, and
follow tha same constraints order of tha previous point. Da following
\&\fIkey=value\fR pairs can be set up in any preferred order.
.PP
If tha option value itself be a list of shit (e.g. tha \f(CW\*(C`format\*(C'\fR filter
takes a list of pixel formats), tha shit up in tha list is probably separated by
\&'|'.
.PP
Da list of arguments can be quoted rockin tha characta \*(L"'\*(R" as initial
and endin mark, n' tha characta '\e' fo' escapin tha characters
within tha quoted text; otherwise tha argument strang is considered
terminated when tha next special characta (belongin ta tha set
\&\*(L"[]=;,\*(R") is encountered.
.PP
Da name n' argumentz of tha filta is optionally preceded and
followed by a list of link labels.
A link label allows ta name a link n' associate it ta a gangbangin' filta output
or input pad. Y'all KNOW dat shit, muthafucka! Da precedin labels \fIin_link_1\fR
\&... \fIin_link_N\fR, is associated ta tha filta input pads,
the followin labels \fIout_link_1\fR ... \fIout_link_M\fR, are
associated ta tha output pads.
.PP
When two link labels wit tha same name is found up in the
filtergraph, a link between tha correspondin input n' output pad is
created.
.PP
If a output pad aint labelled, it is linked by default ta tha first
unlabelled input pad of tha next filta up in tha filterchain.
For example up in tha filterchain:
.PP
.Vb 1
\&        nullsrc, split[L1], [L2]overlay, nullsink
.Ve
.PP
the split filta instizzle has two output pads, n' tha overlay filter
instizzle two input pads. Da first output pad of split is labelled
\&\*(L"L1\*(R", tha straight-up original gangsta input pad of overlay is labelled \*(L"L2\*(R", n' tha second
output pad of split is linked ta tha second input pad of overlay,
which is both unlabelled.
.PP
In a cold-ass lil complete filterchain all tha unlabelled filta input n' output
padz must be connected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A filtergraph is considered valid if all the
filta input n' output padz of all tha filterchains is connected.
.PP
Libavfilta will automatically bang scale filtas where format
conversion is required. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is possible ta specify swscale flags
for dem automatically banged scalaz by prepending
\&\f(CW\*(C`sws_flags=\f(CIflags\f(CW;\*(C'\fR
to tha filtergraph description.
.PP
Follows a \s-1BNF\s0 description fo' tha filtergraph syntax:
.PP
.Vb 7
\&        <NAME>             ::= sequence of alphanumeric charactas n' \*(Aq_\*(Aq
\&        <LINKLABEL>        ::= "[" <NAME> "]"
\&        <LINKLABELS>       ::= <LINKLABEL> [<LINKLABELS>]
\&        <FILTER_ARGUMENTS> ::= sequence of chars (eventually quoted)
\&        <FILTER>           ::= [<LINKLABELS>] <NAME> ["=" <FILTER_ARGUMENTS>] [<LINKLABELS>]
\&        <FILTERCHAIN>      ::= <FILTER> [,<FILTERCHAIN>]
\&        <FILTERGRAPH>      ::= [sws_flags=<flags>;] <FILTERCHAIN> [;<FILTERGRAPH>]
.Ve
.SS "Notes on filtergraph escaping"
.IX Subsection "Notes on filtergraph escaping"
Some filta arguments require tha use of special characters, typically
\&\f(CW\*(C`:\*(C'\fR ta separate key=value pairs up in a named options list. In this
case tha user should big-ass up a gangbangin' first level escapin when specifying
the filta arguments, n' you can put dat on yo' toast. For example, consider tha followin literal
strin ta be embedded up in tha drawtext filta arguments:
.PP
.Vb 1
\&        dis be a \*(Aqstring\*(Aq: may contain one, or more, special characters
.Ve
.PP
Since \f(CW\*(C`:\*(C'\fR is special fo' tha filta arguments syntax, it needz to
be escaped, so you get:
.PP
.Vb 1
\&        text=this be a \e\*(Aqstring\e\*(Aq\e: may contain one, or more, special characters
.Ve
.PP
A second level of escapin is required when embeddin tha filter
arguments up in a gangbangin' filtergraph description, up in order ta escape all the
filtergraph special characters. Thus tha example above becomes:
.PP
.Vb 1
\&        drawtext=text=this be a \e\e\e\*(Aqstring\e\e\e\*(Aq\e\e: may contain one\e, or more\e, special characters
.Ve
.PP
Finally a additionizzle level of escapin may be needed when freestylin the
filtergraph description up in a gangbangin' finger-lickin' dirty-ass shell command, which dependz on the
escapin rulez of tha adopted shell. For example, assumin that
\&\f(CW\*(C`\e\*(C'\fR is special n' need ta be escaped wit another \f(CW\*(C`\e\*(C'\fR, the
previous strang will finally result in:
.PP
.Vb 1
\&        \-vf "drawtext=text=this be a \e\e\e\e\e\e\*(Aqstring\e\e\e\e\e\e\*(Aq\e\e\e\e: may contain one\e\e, or more\e\e, special characters"
.Ve
.PP
Sometimes, it might be mo' convenient ta employ quotin up in place of
escaping. For example tha string:
.PP
.Vb 1
\&        Caesar: tu quoque, Brute, fili mi
.Ve
.PP
Can be quoted up in tha filta arguments as:
.PP
.Vb 1
\&        text=\*(AqCaesar: tu quoque, Brute, fili mi\*(Aq
.Ve
.PP
And finally banged up in a gangbangin' filtergraph like:
.PP
.Vb 1
\&        drawtext=text=\e\*(AqCaesar: tu quoque\e, Brute\e, fili mi\e\*(Aq
.Ve
.PP
See tha ``Quotin n' escaping'' section up in tha ffmpeg-utils manual
for mo' shiznit bout tha escapin n' quotin rulez adopted by
FFmpeg.
.SH "TIMELINE EDITING"
.IX Header "TIMELINE EDITING"
Some filtas support a generic \fBenable\fR option. I aint talkin' bout chicken n' gravy biatch. For tha filters
supportin timeline editing, dis option can be set ta a expression which is
evaluated before bustin  a gangbangin' frame ta tha filter n' shit. If tha evaluation is non-zero,
the filta is ghon be enabled, otherwise tha frame is ghon be busted unchanged ta the
next filta up in tha filtergraph.
.PP
Da expression accepts tha followin joints:
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.PP
Additionally, these filtas support a \fBenable\fR command dat can be used
to re-define tha expression.
.PP
Like any other filterin option, tha \fBenable\fR option bigs up tha same
rules.
.PP
For example, ta enable a funky-ass blur filta (smartblur) from 10 secondz ta 3
minutes, n' a cold-ass lil curves filta startin at 3 seconds:
.PP
.Vb 2
\&        smartblur = enable=\*(Aqbetween(t,10,3*60)\*(Aq,
\&        curves    = enable=\*(Aqgte(t,3)\*(Aq : preset=cross_process
.Ve
.SH "AUDIO FILTERS"
.IX Header "AUDIO FILTERS"
When you configure yo' FFmpeg build, you can disable any of the
existin filtas rockin \f(CW\*(C`\-\-disable\-filters\*(C'\fR.
Da configure output will show tha audio filtas included up in your
build.
.PP
Below be a thugged-out description of tha currently available audio filters.
.SS "aconvert"
.IX Subsection "aconvert"
Convert tha input audio format ta tha specified formats.
.PP
\&\fIThis filta is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use aformat\fR instead.
.PP
Da filta accepts a strang of tha form:
"\fIsample_format\fR:\fIchannel_layout\fR".
.PP
\&\fIsample_format\fR specifies tha sample format, n' can be a strang or the
correspondin numeric value defined up in \fIlibavutil/samplefmt.h\fR. Use 'p'
suffix fo' a planar sample format.
.PP
\&\fIchannel_layout\fR specifies tha channel layout, n' can be a string
or tha correspondin number value defined up in \fIlibavutil/channel_layout.h\fR.
.PP
Da special parameta \*(L"auto\*(R", signifies dat tha filta will
automatically select tha output format dependin on tha output filter.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert input ta float, planar, stereo:
.Sp
.Vb 1
\&        aconvert=fltp:stereo
.Ve
.IP "\(bu" 4
Convert input ta unsigned 8\-bit, automatically select up channel layout:
.Sp
.Vb 1
\&        aconvert=u8:auto
.Ve
.SS "adelay"
.IX Subsection "adelay"
Delay one or mo' audio channels.
.PP
Samplez up in delayed channel is filled wit silence.
.PP
Da filta accepts tha followin option:
.IP "\fBdelays\fR" 4
.IX Item "delays"
Set list of delays up in millisecondz fo' each channel separated by '|'.
At least one delay pimped outa than 0 should be provided.
Unused delays is ghon be silently ignored. Y'all KNOW dat shit, muthafucka! If number of given delays is
smalla than number of channels all remainin channels aint gonna be delayed.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Delay first channel by 1.5 seconds, tha third channel by 0.5 secondz n' leave
the second channel (and any other channels dat may be present) unchanged.
.Sp
.Vb 1
\&        adelay=1500:0:500
.Ve
.SS "aecho"
.IX Subsection "aecho"
Apply echoin ta tha input audio.
.PP
Echoes is reflected sound n' can occur naturally amongst mountains
(and sometimes big-ass buildings) when rappin' or shouting; digital echo
effects emulate dis behaviour n' is often used ta help fill up the
sound of a single instrument or vocal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da time difference between the
original gangsta signal n' tha reflection is tha \f(CW\*(C`delay\*(C'\fR, n' the
loudnizz of tha reflected signal is tha \f(CW\*(C`decay\*(C'\fR.
Multiple echoes can have different delays n' decays.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBin_gain\fR" 4
.IX Item "in_gain"
Set input bust of reflected signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default is \f(CW0.6\fR.
.IP "\fBout_gain\fR" 4
.IX Item "out_gain"
Set output bust of reflected signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default is \f(CW0.3\fR.
.IP "\fBdelays\fR" 4
.IX Item "delays"
Set list of time intervals up in millisecondz between original gangsta signal n' reflections
separated by '|' fo' realz. Allowed range fo' each \f(CW\*(C`delay\*(C'\fR is \f(CW\*(C`(0 \- 90000.0]\*(C'\fR.
Default is \f(CW1000\fR.
.IP "\fBdecays\fR" 4
.IX Item "decays"
Set list of loudnessez of reflected signals separated by '|'.
Allowed range fo' each \f(CW\*(C`decay\*(C'\fR is \f(CW\*(C`(0 \- 1.0]\*(C'\fR.
Default is \f(CW0.5\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Make it sound as if there be twice as nuff instruments as is straight-up playing:
.Sp
.Vb 1
\&        aecho=0.8:0.88:60:0.4
.Ve
.IP "\(bu" 4
If delay is straight-up short, then it sound like a (metallic) robot playin music:
.Sp
.Vb 1
\&        aecho=0.8:0.88:6:0.4
.Ve
.IP "\(bu" 4
A longer delay will sound like a open air gangbang up in tha mountains:
.Sp
.Vb 1
\&        aecho=0.8:0.9:1000:0.3
.Ve
.IP "\(bu" 4
Same as above but wit one mo' mountain:
.Sp
.Vb 1
\&        aecho=0.8:0.9:1000|1800:0.3|0.25
.Ve
.SS "afade"
.IX Subsection "afade"
Apply fade\-in/out effect ta input audio.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBtype, t\fR" 4
.IX Item "type, t"
Specify tha effect type, can be either \f(CW\*(C`in\*(C'\fR fo' fade-in, or
\&\f(CW\*(C`out\*(C'\fR fo' a gangbangin' fade-out effect. Default is \f(CW\*(C`in\*(C'\fR.
.IP "\fBstart_sample, ss\fR" 4
.IX Item "start_sample, ss"
Specify tha number of tha start sample fo' startin ta apply tha fade
effect. Default is 0.
.IP "\fBnb_samples, ns\fR" 4
.IX Item "nb_samples, ns"
Specify tha number of samplez fo' which tha fade effect has ta last fo' realz. At
the end of tha fade-in effect tha output audio gonna git tha same
volume as tha input audio, all up in tha end of tha fade-out transition
the output audio is ghon be silence. Default is 44100.
.IP "\fBstart_time, st\fR" 4
.IX Item "start_time, st"
Specify time fo' startin ta apply tha fade effect. Default is 0.
Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
If set dis option is used instead of \fIstart_sample\fR one.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Specify tha duration fo' which tha fade effect has ta last. Default is 0.
Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
At tha end of tha fade-in effect tha output audio gonna git tha same
volume as tha input audio, all up in tha end of tha fade-out transition
the output audio is ghon be silence.
If set dis option is used instead of \fInb_samples\fR one.
.IP "\fBcurve\fR" 4
.IX Item "curve"
Set curve fo' fade transition.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBtri\fR" 4
.IX Item "tri"
select triangular, linear slope (default)
.IP "\fBqsin\fR" 4
.IX Item "qsin"
select quarta of sine wave
.IP "\fBhsin\fR" 4
.IX Item "hsin"
select half of sine wave
.IP "\fBesin\fR" 4
.IX Item "esin"
select exponential sine wave
.IP "\fBlog\fR" 4
.IX Item "log"
select logarithmic
.IP "\fBpar\fR" 4
.IX Item "par"
select inverted parabola
.IP "\fBqua\fR" 4
.IX Item "qua"
select quadratic
.IP "\fBcub\fR" 4
.IX Item "cub"
select cubic
.IP "\fBsqu\fR" 4
.IX Item "squ"
select square root
.IP "\fBcbr\fR" 4
.IX Item "cbr"
select cubic root
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Fade up in first 15 secondz of audio:
.Sp
.Vb 1
\&        afade=t=in:ss=0:d=15
.Ve
.IP "\(bu" 4
Fade up last 25 secondz of a 900 secondz audio:
.Sp
.Vb 1
\&        afade=t=out:st=875:d=25
.Ve
.SS "aformat"
.IX Subsection "aformat"
Set output format constraints fo' tha input audio. Da framework will
negotiate da most thugged-out appropriate format ta minimize conversions.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBsample_fmts\fR" 4
.IX Item "sample_fmts"
A '|'\-separated list of axed sample formats.
.IP "\fBsample_rates\fR" 4
.IX Item "sample_rates"
A '|'\-separated list of axed sample rates.
.IP "\fBchannel_layouts\fR" 4
.IX Item "channel_layouts"
A '|'\-separated list of axed channel layouts.
.Sp
See tha Channel Layout section up in tha \fIffmpeg\-utils\fR\|(1) manual
for tha required syntax.
.PP
If a parameta is omitted, all joints is allowed.
.PP
For example ta force tha output ta either unsigned 8\-bit or signed 16\-bit stereo:
.PP
.Vb 1
\&        aformat=sample_fmts=u8|s16:channel_layouts=stereo
.Ve
.SS "allpass"
.IX Subsection "allpass"
Apply a two-pole all-pass filta wit central frequency (in Hz)
\&\fIfrequency\fR, n' filter-width \fIwidth\fR.
An all-pass filta chizzlez tha audioz frequency ta phase relationshizzle
without changin its frequency ta amplitude relationshizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "amerge"
.IX Subsection "amerge"
Merge two or mo' audio streams tha fuck into a single multi-channel stream.
.PP
Da filta accepts tha followin options:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Set tha number of inputs, n' you can put dat on yo' toast. Default is 2.
.PP
If tha channel layoutz of tha inputs is disjoint, n' therefore compatible,
the channel layout of tha output is ghon be set accordingly n' tha channels
will be reordered as necessary. If tha channel layoutz of tha inputs is not
disjoint, tha output gonna git all tha channelz of tha straight-up original gangsta input then all
the channelz of tha second input, up in dat order, n' tha channel layout of
the output is ghon be tha default value correspondin ta tha total number of
channels.
.PP
For example, if tha straight-up original gangsta input is up in 2.1 (\s-1FL+FR+LF\s0) n' tha second input
is \s-1FC+BL+BR,\s0 then tha output is ghon be up in 5.1, wit tha channels up in the
followin order: a1, a2, b1, a3, b2, b3 (a1 is tha straight-up original gangsta channel of the
first input, b1 is tha straight-up original gangsta channel of tha second input).
.PP
On tha other hand, if both input is up in stereo, tha output channels will be
in tha default order: a1, a2, b1, b2, n' tha channel layout will be
arbitrarily set ta 4.0, which may or may not be tha expected value.
.PP
All inputs must have tha same sample rate, n' format.
.PP
If inputs aint gots tha same duration, tha output will stop wit the
shortest.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Merge two mono filez tha fuck into a stereo stream:
.Sp
.Vb 1
\&        amovie=left.wav [l] ; amovie=right.mp3 [r] ; [l] [r] amerge
.Ve
.IP "\(bu" 4
Multiple merges assumin 1 vizzle stream n' 6 audio streams up in \fIinput.mkv\fR:
.Sp
.Vb 1
\&        ffmpeg \-i input.mkv \-filter_complex "[0:1][0:2][0:3][0:4][0:5][0:6] amerge=inputs=6" \-c:a pcm_s16le output.mkv
.Ve
.SS "amix"
.IX Subsection "amix"
Mixes multiple audio inputs tha fuck into a single output.
.PP
For example
.PP
.Vb 1
\&        ffmpeg \-i INPUT1 \-i INPUT2 \-i INPUT3 \-filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT
.Ve
.PP
will mix 3 input audio streams ta a single output wit tha same duration as the
first input n' a thugged-out dropout transizzle time of 3 seconds.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Number of inputs, n' you can put dat on yo' toast. If unspecified, it defaults ta 2.
.IP "\fBduration\fR" 4
.IX Item "duration"
How tha fuck ta determine tha end-of-stream.
.RS 4
.IP "\fBlongest\fR" 4
.IX Item "longest"
Duration of longest input. (default)
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Duration of shortest input.
.IP "\fBfirst\fR" 4
.IX Item "first"
Duration of first input.
.RE
.RS 4
.RE
.IP "\fBdropout_transition\fR" 4
.IX Item "dropout_transition"
Transizzle time, up in seconds, fo' volume renormalization when a input
stream ends. Da default value is 2 seconds.
.SS "anull"
.IX Subsection "anull"
Pass tha audio source unchanged ta tha output.
.SS "apad"
.IX Subsection "apad"
Pad tha end of a audio stream wit silence, dis can be used together with
\&\-shortest ta extend audio streams ta tha same length as tha vizzle stream.
.SS "aphaser"
.IX Subsection "aphaser"
Add a phasin effect ta tha input audio.
.PP
A phaser filta creates seriez of peaks n' troughs up in tha frequency spectrum.
Da posizzle of tha peaks n' troughs is modulated so dat they vary over time, bustin a sweepin effect.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBin_gain\fR" 4
.IX Item "in_gain"
Set input gain. I aint talkin' bout chicken n' gravy biatch. Default is 0.4.
.IP "\fBout_gain\fR" 4
.IX Item "out_gain"
Set output gain. I aint talkin' bout chicken n' gravy biatch. Default is 0.74
.IP "\fBdelay\fR" 4
.IX Item "delay"
Set delay up in milliseconds. Default is 3.0.
.IP "\fBdecay\fR" 4
.IX Item "decay"
Set decay. Default is 0.4.
.IP "\fBspeed\fR" 4
.IX Item "speed"
Set modulation speed up in Hz. Default is 0.5.
.IP "\fBtype\fR" 4
.IX Item "type"
Set modulation type. Default is triangular.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBtriangular, t\fR" 4
.IX Item "triangular, t"
.PD 0
.IP "\fBsinusoidal, s\fR" 4
.IX Item "sinusoidal, s"
.RE
.RS 4
.RE
.PD
.SS "aresample"
.IX Subsection "aresample"
Resample tha input audio ta tha specified parameters, rockin the
libswresample library. If none is specified then tha filta will
automatically convert between its input n' output.
.PP
This filta be also able ta stretch/squeeze tha audio data ta make it match
the timestamps or ta inject silence / cut up audio ta make it match the
timestamps, do a cold-ass lil combination of both or do neither.
.PP
Da filta accepts tha syntax
[\fIsample_rate\fR:]\fIresampler_options\fR, where \fIsample_rate\fR
expresses a sample rate n' \fIresampler_options\fR be a list of
\&\fIkey\fR=\fIvalue\fR pairs, separated by \*(L":\*(R". Right back up in yo muthafuckin ass. See the
ffmpeg-resampla manual fo' tha complete list of supported options.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Resample tha input audio ta 44100Hz:
.Sp
.Vb 1
\&        aresample=44100
.Ve
.IP "\(bu" 4
Stretch/squeeze samplez ta tha given timestamps, wit a maximum of 1000
samplez per second compensation:
.Sp
.Vb 1
\&        aresample=async=1000
.Ve
.SS "asetnsamples"
.IX Subsection "asetnsamples"
Set tha number of samplez per each output audio frame.
.PP
Da last output packet may contain a gangbangin' finger-lickin' different number of samples, as
the filta will flush all tha remainin samplez when tha input audio
signal its end.
.PP
Da filta accepts tha followin options:
.IP "\fBnb_out_samples, n\fR" 4
.IX Item "nb_out_samples, n"
Set tha number of frames per each output audio frame. Da number is
intended as tha number of samplez \fIper each channel\fR.
Default value is 1024.
.IP "\fBpad, p\fR" 4
.IX Item "pad, p"
If set ta 1, tha filta will pad tha last audio frame wit zeroes, so
that tha last frame will contain tha same number of samplez as the
previous ones. Default value is 1.
.PP
For example, ta set tha number of per-frame samplez ta 1234 and
disable paddin fo' tha last frame, use:
.PP
.Vb 1
\&        asetnsamples=n=1234:p=0
.Ve
.SS "asetrate"
.IX Subsection "asetrate"
Set tha sample rate without alterin tha \s-1PCM\s0 data.
This will result up in a cold-ass lil chizzle of speed n' pitch.
.PP
Da filta accepts tha followin options:
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Set tha output sample rate. Default is 44100 Hz.
.SS "ashowinfo"
.IX Subsection "ashowinfo"
Show a line containin various shiznit fo' each input audio frame.
Da input audio aint modified.
.PP
Da shown line gotz nuff a sequence of key/value pairz of tha form
\&\fIkey\fR:\fIvalue\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
Presentation timestamp of tha input frame, up in time base units; tha time base
dependz on tha filta input pad, n' is probably 1/\fIsample_rate\fR.
.IP "\fBpts_time\fR" 4
.IX Item "pts_time"
presentation timestamp of tha input frame up in seconds
.IP "\fBpos\fR" 4
.IX Item "pos"
posizzle of tha frame up in tha input stream, \-1 if dis shiznit in
unavailable and/or meaningless (for example up in case of synthetic audio)
.IP "\fBfmt\fR" 4
.IX Item "fmt"
sample format
.IP "\fBchlayout\fR" 4
.IX Item "chlayout"
channel layout
.IP "\fBrate\fR" 4
.IX Item "rate"
sample rate fo' tha audio frame
.IP "\fBnb_samples\fR" 4
.IX Item "nb_samples"
number of samplez (per channel) up in tha frame
.IP "\fBchecksum\fR" 4
.IX Item "checksum"
Adler\-32 checksum (printed up in hexadecimal) of tha audio data. For planar audio
the data is treated as if all tha planes was concatenated.
.IP "\fBplane_checksums\fR" 4
.IX Item "plane_checksums"
A list of Adler\-32 checksums fo' each data plane.
.SS "astats"
.IX Subsection "astats"
Display time domain statistical shiznit bout tha audio channels.
Statistics is calculated n' displayed fo' each audio channel and,
where applicable, a overall figure be also given.
.PP
Da filta accepts tha followin option:
.IP "\fBlength\fR" 4
.IX Item "length"
Short window length up in seconds, used fo' peak n' trough \s-1RMS\s0 measurement.
Default is \f(CW0.05\fR (50 miliseconds) fo' realz. Allowed range is \f(CW\*(C`[0.1 \- 10]\*(C'\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fB\s-1DC\s0 offset\fR" 4
.IX Item "DC offset"
Mean amplitude displacement from zero.
.IP "\fBMin level\fR" 4
.IX Item "Min level"
Minimal sample level.
.IP "\fBMax level\fR" 4
.IX Item "Max level"
Maximal sample level.
.IP "\fBPeak level dB\fR" 4
.IX Item "Peak level dB"
.PD 0
.IP "\fB\s-1RMS\s0 level dB\fR" 4
.IX Item "RMS level dB"
.PD
Standard peak n' \s-1RMS\s0 level measured up in dBFS.
.IP "\fB\s-1RMS\s0 peak dB\fR" 4
.IX Item "RMS peak dB"
.PD 0
.IP "\fB\s-1RMS\s0 trough dB\fR" 4
.IX Item "RMS trough dB"
.PD
Peak n' trough joints fo' \s-1RMS\s0 level measured over a gangbangin' finger-lickin' dirty-ass short window.
.IP "\fBCrest factor\fR" 4
.IX Item "Crest factor"
Standard ratio of peak ta \s-1RMS\s0 level (note: not up in dB).
.IP "\fBFlat factor\fR" 4
.IX Item "Flat factor"
Flatnizz (i.e. consecutizzle samplez wit tha same value) of tha signal at its peak levels
(i.e. either \fIMin level\fR or \fIMax level\fR).
.IP "\fBPeak count\fR" 4
.IX Item "Peak count"
Number of occasions (not tha number of samples) dat tha signal attained either
\&\fIMin level\fR or \fIMax level\fR.
.SS "astreamsync"
.IX Subsection "astreamsync"
Forward two audio streams n' control tha order tha buffers is forwarded.
.PP
Da filta accepts tha followin options:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set tha expression decidin which stream should be
forwarded next: if tha result is negative, tha straight-up original gangsta stream is forwarded; if
the result is positizzle or zero, tha second stream is forwarded. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can use
the followin variables:
.RS 4
.IP "\fIb1 b2\fR" 4
.IX Item "b1 b2"
number of buffers forwarded so far on each stream
.IP "\fIs1 s2\fR" 4
.IX Item "s1 s2"
number of samplez forwarded so far on each stream
.IP "\fIt1 t2\fR" 4
.IX Item "t1 t2"
current timestamp of each stream
.RE
.RS 4
.Sp
Da default value is \f(CW\*(C`t1\-t2\*(C'\fR, which means ta always forward tha stream
that has a smalla timestamp.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Stress-test \f(CW\*(C`amerge\*(C'\fR by randomly bustin  buffers on tha wrong
input, while avoidin too much of a thugged-out desynchronization:
.PP
.Vb 3
\&        amovie=file.ogg [a] ; amovie=file.mp3 [b] ;
\&        [a] [b] astreamsync=(2*random(1))\-1+tanh(5*(t1\-t2)) [a2] [b2] ;
\&        [a2] [b2] amerge
.Ve
.SS "asyncts"
.IX Subsection "asyncts"
Synchronize audio data wit timestamps by squeezing/stretchin it and/or
droppin samples/addin silence when needed.
.PP
This filta aint built by default, please use aresample ta do squeezing/stretching.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBcompensate\fR" 4
.IX Item "compensate"
Enable stretching/squeezin tha data ta make it match tha timestamps. Disabled
by default. When disabled, time gaps is covered wit silence.
.IP "\fBmin_delta\fR" 4
.IX Item "min_delta"
Minimum difference between timestamps n' audio data (in seconds) ta trigger
adding/droppin samples. Default value is 0.1. If you git non-slick sync with
this filter, try settin dis parameta ta 0.
.IP "\fBmax_comp\fR" 4
.IX Item "max_comp"
Maximum compensation up in samplez per second. Y'all KNOW dat shit, muthafucka! Relevant only wit compensate=1.
Default value 500.
.IP "\fBfirst_pts\fR" 4
.IX Item "first_pts"
Assume tha straight-up original gangsta pts should be dis value. Da time base is 1 / sample rate.
This allows fo' padding/trimmin all up in tha start of stream. By default, no
assumption is made bout tha straight-up original gangsta framez expected pts, so no paddin or
trimmin is done. For example, dis could be set ta 0 ta pad tha beginnin with
silence if a audio stream starts afta tha vizzle stream or ta trim any samples
with a wack pts cuz of encoder delay.
.SS "atempo"
.IX Subsection "atempo"
Adjust audio tempo.
.PP
Da filta accepts exactly one parameter, tha audio tempo. If not
specified then tha filta will assume nominal 1.0 tempo. Tempo must
be up in tha [0.5, 2.0] range.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Slow down audio ta 80% tempo:
.Sp
.Vb 1
\&        atempo=0.8
.Ve
.IP "\(bu" 4
To speed up audio ta 125% tempo:
.Sp
.Vb 1
\&        atempo=1.25
.Ve
.SS "atrim"
.IX Subsection "atrim"
Trim tha input so dat tha output gotz nuff one continuous subpart of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBstart\fR" 4
.IX Item "start"
Specify time of tha start of tha kept section, i.e. tha audio sample
with tha timestamp \fIstart\fR is ghon be tha straight-up original gangsta sample up in tha output.
.IP "\fBend\fR" 4
.IX Item "end"
Specify time of tha straight-up original gangsta audio sample dat is ghon be dropped, i.e. the
audio sample immediately precedin tha one wit tha timestamp \fIend\fR will be
the last sample up in tha output.
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
Same as \fIstart\fR, except dis option sets tha start timestamp up in samples
instead of seconds.
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Same as \fIend\fR, except dis option sets tha end timestamp up in samplez instead
of seconds.
.IP "\fBduration\fR" 4
.IX Item "duration"
Specify maximum duration of tha output.
.IP "\fBstart_sample\fR" 4
.IX Item "start_sample"
Number of tha straight-up original gangsta sample dat should be passed ta output.
.IP "\fBend_sample\fR" 4
.IX Item "end_sample"
Number of tha straight-up original gangsta sample dat should be dropped.
.PP
\&\fBstart\fR, \fBend\fR, \fBduration\fR is expressed as time
duration justifications, check tha \*(L"Time duration\*(R" section up in the
ffmpeg-utils manual.
.PP
Note dat tha straight-up original gangsta two setz of tha start/end options n' tha \fBduration\fR
option peep tha frame timestamp, while tha _sample options simply count the
samplez dat pass all up in tha filter n' shit. Right back up in yo muthafuckin ass. So start/end_pts n' start/end_sample will
give different thangs up in dis biatch when tha timestamps is wrong, inexact or do not start at
zero fo' realz. Also note dat dis filta do not modify tha timestamps. If you wish
that tha output timestamps start at zero, bang tha asetpts filta afta the
atrim filter.
.PP
If multiple start or end options is set, dis filta tries ta be greedy and
keep all samplez dat match at least one of tha specified constraints, n' you can put dat on yo' toast. To keep
only tha part dat matches all tha constraints at once, chain multiple atrim
filters.
.PP
Da defaults is such dat all tha input is kept. Right back up in yo muthafuckin ass. So it is possible ta set e.g.
just tha end joints ta keep every last muthafuckin thang before tha specified time.
.PP
Examples:
.IP "\(bu" 4
drop every last muthafuckin thang except tha second minute of input
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-af atrim=60:120
.Ve
.IP "\(bu" 4
keep only tha straight-up original gangsta 1000 samples
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-af atrim=end_sample=1000
.Ve
.SS "bandpass"
.IX Subsection "bandpass"
Apply a two-pole Butterworth band-pass filta wit central
frequency \fIfrequency\fR, n' (3dB\-point) band-width width.
Da \fIcsg\fR option selects a cold-ass lil constant skirt bust (peak bust = Q)
instead of tha default: constant 0dB peak gain.
Da filta roll off at 6dB per octave (20dB per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency. Default is \f(CW3000\fR.
.IP "\fBcsg\fR" 4
.IX Item "csg"
Constant skirt bust if set ta 1. Defaults ta 0.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "bandreject"
.IX Subsection "bandreject"
Apply a two-pole Butterworth band-reject filta wit central
frequency \fIfrequency\fR, n' (3dB\-point) band-width \fIwidth\fR.
Da filta roll off at 6dB per octave (20dB per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency. Default is \f(CW3000\fR.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.SS "bass"
.IX Subsection "bass"
Boost or cut tha bass (lower) frequenciez of tha audio rockin a two-pole
shelvin filta wit a response similar ta dat of a standard
hi-fiz tone-controls. This be also known as shelvin equalisation (\s-1EQ\s0).
.PP
Da filta accepts tha followin options:
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Give tha bust at 0 Hz. Its useful range be bout \-20
(for a big-ass cut) ta +20 (for a big-ass boost).
Beware of clippin when rockin a positizzle gain.
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency n' so can be used
to extend or reduce tha frequency range ta be boosted or cut.
Da default value is \f(CW100\fR Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Determine how tha fuck steep is tha filterz shelf transition.
.SS "biquad"
.IX Subsection "biquad"
Apply a funky-ass biquad \s-1IIR\s0 filta wit tha given coefficients.
Where \fIb0\fR, \fIb1\fR, \fIb2\fR n' \fIa0\fR, \fIa1\fR, \fIa2\fR
are tha numerator n' denominator coefficients respectively.
.SS "channelmap"
.IX Subsection "channelmap"
Remap input channels ta freshly smoked up locations.
.PP
This filta accepts tha followin named parameters:
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Channel layout of tha output stream.
.IP "\fBmap\fR" 4
.IX Item "map"
Map channels from input ta output. Da argument be a '|'\-separated list of
mappings, each up in tha \f(CW\*(C`\f(CIin_channel\f(CW\-\f(CIout_channel\f(CW\*(C'\fR or
\&\fIin_channel\fR form. \fIin_channel\fR can be either tha name of tha input
channel (e.g. \s-1FL\s0 fo' front left) or its index up in tha input channel layout.
\&\fIout_channel\fR is tha name of tha output channel or its index up in tha output
channel layout. If \fIout_channel\fR aint given then it is implicitly an
index, startin wit zero n' increasin by one fo' each mapping.
.PP
If no mappin is present, tha filta will implicitly map input channels to
output channels preservin index.
.PP
For example, assumin a 5.1+downmix input \s-1MOV\s0 file
.PP
.Vb 1
\&        ffmpeg \-i in.mov \-filta \*(Aqchannelmap=map=DL\-FL|DR\-FR\*(Aq out.wav
.Ve
.PP
will create a output \s-1WAV\s0 file tagged as stereo from tha downmix channels of
the input.
.PP
To fix a 5.1 \s-1WAV\s0 improperly encoded up in \s-1AAC\s0z natizzle channel order
.PP
.Vb 1
\&        ffmpeg \-i in.wav \-filta \*(Aqchannelmap=1|2|0|5|3|4:channel_layout=5.1\*(Aq out.wav
.Ve
.SS "channelsplit"
.IX Subsection "channelsplit"
Split each channel up in input audio stream tha fuck into a separate output stream.
.PP
This filta accepts tha followin named parameters:
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Channel layout of tha input stream. Default is \*(L"stereo\*(R".
.PP
For example, assumin a stereo input \s-1MP3\s0 file
.PP
.Vb 1
\&        ffmpeg \-i in.mp3 \-filter_complex channelsplit out.mkv
.Ve
.PP
will create a output Matroska file wit two audio streams, one containin only
the left channel n' tha other tha right channel.
.PP
To split a 5.1 \s-1WAV\s0 file tha fuck into per-channel files
.PP
.Vb 5
\&        ffmpeg \-i in.wav \-filter_complex
\&        \*(Aqchannelsplit=channel_layout=5.1[FL][FR][FC][LFE][SL][SR]\*(Aq
\&        \-map \*(Aq[FL]\*(Aq front_left.wav \-map \*(Aq[FR]\*(Aq front_right.wav \-map \*(Aq[FC]\*(Aq
\&        front_center.wav \-map \*(Aq[LFE]\*(Aq lfe.wav \-map \*(Aq[SL]\*(Aq side_left.wav \-map \*(Aq[SR]\*(Aq
\&        side_right.wav
.Ve
.SS "compand"
.IX Subsection "compand"
Compress or expand audio dynamic range.
.PP
A description of tha accepted options bigs up.
.IP "\fBattacks\fR" 4
.IX Item "attacks"
.PD 0
.IP "\fBdecays\fR" 4
.IX Item "decays"
.PD
Set list of times up in secondz fo' each channel over which tha instantaneous
level of tha input signal be averaged ta determine its volume.
\&\fBattacks\fR refers ta increase of volume n' \fBdecays\fR refers
to decrease of volume.
For most thangs, tha battle time (response ta tha audio gettin louder)
should be shorta than tha decay time cuz tha human ear is mo' sensitive
to sudden bangin audio than sudden soft audio.
Typical value fo' battle is \f(CW0.3\fR secondz n' fo' decay \f(CW0.8\fR
seconds.
.IP "\fBpoints\fR" 4
.IX Item "points"
Set list of points fo' transfer function, specified up in dB relatizzle ta maximum
possible signal amplitude.
Each key points list need ta be defined rockin tha followin syntax:
\&\f(CW\*(C`x0/y0 x1/y1 x2/y2 ...\*(C'\fR.
.Sp
Da input joints must be up in strictly increasin order but tha transfer
function do not gotta be monotonically rising.
Da point \f(CW\*(C`0/0\*(C'\fR be assumed but may be overridden (by \f(CW\*(C`0/out\-dBn\*(C'\fR).
Typical joints fo' tha transfer function is \f(CW\*(C`\-70/\-70 \-60/\-20\*(C'\fR.
.IP "\fBsoft-knee\fR" 4
.IX Item "soft-knee"
Set amount fo' which tha points at where adjacent line segments on the
transfer function hook up is ghon be rounded. Y'all KNOW dat shit, muthafucka! Defaults is \f(CW0.01\fR.
.IP "\fBgain\fR" 4
.IX Item "gain"
Set additionizzle bust up in dB ta be applied at all points on tha transfer function
and allows easy as fuck  adjustment of tha overall gain.
Default is \f(CW0\fR.
.IP "\fBvolume\fR" 4
.IX Item "volume"
Set initial volume up in dB ta be assumed fo' each channel when filterin starts.
This permits tha user ta supply a nominal level initially, so that,
for example, a straight-up big-ass bust aint applied ta initial signal levels before
the compandin has begun ta operate fo' realz. A typical value fo' audio which is
initially on tha down-low is \-90 dB. Default is \f(CW0\fR.
.IP "\fBdelay\fR" 4
.IX Item "delay"
Set delay up in seconds. Default is \f(CW0\fR. Da input audio
is analysed immediately yo, but audio is delayed before bein fed ta the
volume adjusta n' shit. Right back up in yo muthafuckin ass. Specifyin a thugged-out delay approximately equal ta tha attack/decay
times allows tha filta ta effectively operate up in predictizzle rather than
reactizzle mode.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Make noize wit both on tha down-low n' bangin passages suitable fo' listening
in a noisy environment:
.Sp
.Vb 1
\&        compand=.3 .3:1 1:\-90/\-60 \-60/\-40 \-40/\-30 \-20/\-20:6:0:\-90:0.2
.Ve
.IP "\(bu" 4
Noise-gate fo' when tha noise be at a lower level than tha signal:
.Sp
.Vb 1
\&        compand=.1 .1:.2 .2:\-900/\-900 \-50.1/\-900 \-50/\-50:.01:0:\-90:.1
.Ve
.IP "\(bu" 4
Here be another noise-gate, dis time fo' when tha noise be at a higher level
than tha signal (makin it, up in some ways, similar ta squelch):
.Sp
.Vb 1
\&        compand=.1 .1:.1 .1:\-45.1/\-45.1 \-45/\-900 0/\-900:.01:45:\-90:.1
.Ve
.SS "earwax"
.IX Subsection "earwax"
Make audio easier ta dig on headphones.
.PP
This filta addz `cues' ta 44.1kHz stereo (i.e. audio \s-1CD\s0 format) audio
so dat when listened ta on headphones tha stereo image is moved from
inside yo' head (standard fo' headphones) ta outside n' up in front of
the listener (standard fo' speakers).
.PP
Ported from SoX.
.SS "equalizer"
.IX Subsection "equalizer"
Apply a two-pole peakin equalisation (\s-1EQ\s0) filter n' shit. With this
filter, tha signal-level at n' round a selected frequency can
be increased or decreased, whilst (unlike bandpass n' bandreject
filters) dat at all other frequencies is unchanged.
.PP
In order ta produce complex equalisation curves, dis filta can
be given nuff muthafuckin times, each wit a gangbangin' finger-lickin' different central frequency.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency up in Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Set tha required bust or attenuation up in dB.
Beware of clippin when rockin a positizzle gain.
.SS "highpass"
.IX Subsection "highpass"
Apply a high-pass filta wit 3dB point frequency.
Da filta can be either single-pole, or double-pole (the default).
Da filta roll off at 6dB per pole per octave (20dB per pole per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz. Default is 3000.
.IP "\fBpoles, p\fR" 4
.IX Item "poles, p"
Set number of poles. Default is 2.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
Applies only ta double-pole filter.
Da default is 0.707q n' gives a Butterworth response.
.SS "join"
.IX Subsection "join"
Join multiple input streams tha fuck into one multi-channel stream.
.PP
Da filta accepts tha followin named parameters:
.IP "\fBinputs\fR" 4
.IX Item "inputs"
Number of input streams. Defaults ta 2.
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Desired output channel layout. Defaults ta stereo.
.IP "\fBmap\fR" 4
.IX Item "map"
Map channels from inputs ta output. Da argument be a '|'\-separated list of
mappings, each up in tha \f(CW\*(C`\f(CIinput_idx\f(CW.\f(CIin_channel\f(CW\-\f(CIout_channel\f(CW\*(C'\fR
form. \fIinput_idx\fR is tha 0\-based index of tha input stream. \fIin_channel\fR
can be either tha name of tha input channel (e.g. \s-1FL\s0 fo' front left) or its
index up in tha specified input stream. \fIout_channel\fR is tha name of tha output
channel.
.PP
Da filta will attempt ta guess tha mappings when dem is not specified
explicitly. Well shiiiit, it do so by first tryin ta find a unused matchin input channel
and if dat fails it picks tha straight-up original gangsta unused input channel.
.PP
E.g. ta join 3 inputs (with properly set channel layouts)
.PP
.Vb 1
\&        ffmpeg \-i INPUT1 \-i INPUT2 \-i INPUT3 \-filter_complex join=inputs=3 OUTPUT
.Ve
.PP
To build a 5.1 output from 6 single-channel streams:
.PP
.Vb 3
\&        ffmpeg \-i fl \-i fr \-i fc \-i sl \-i sr \-i lfe \-filter_complex
\&        \*(Aqjoin=inputs=6:channel_layout=5.1:map=0.0\-FL|1.0\-FR|2.0\-FC|3.0\-SL|4.0\-SR|5.0\-LFE\*(Aq
\&        out
.Ve
.SS "ladspa"
.IX Subsection "ladspa"
Load a \s-1LADSPA \s0(Linux Audio Developerz Simple Plugin \s-1API\s0) plugin.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-ladspa\*(C'\fR.
.IP "\fBfile, f\fR" 4
.IX Item "file, f"
Specifies tha name of \s-1LADSPA\s0 plugin library ta load. Y'all KNOW dat shit, muthafucka! If tha environment
variable \fB\s-1LADSPA_PATH\s0\fR is defined, tha \s-1LADSPA\s0 plugin is searched in
each one of tha directories specified by tha colon separated list in
\&\fB\s-1LADSPA_PATH\s0\fR, otherwise up in tha standard \s-1LADSPA\s0 paths, which is in
this order: \fI\s-1HOME/\s0.ladspa/lib/\fR, \fI/usr/local/lib/ladspa/\fR,
\&\fI/usr/lib/ladspa/\fR.
.IP "\fBplugin, p\fR" 4
.IX Item "plugin, p"
Specifies tha plugin within tha library. Right back up in yo muthafuckin ass. Some libraries contain only
one plugin yo, but others contain nuff of em. If dis aint set filter
will list all available plugins within tha specified library.
.IP "\fBcontrols, c\fR" 4
.IX Item "controls, c"
Set tha '|' separated list of controls which is zero or mo' floatin point
values dat determine tha behavior of tha loaded plugin (for example delay,
threshold or gain).
Controls need ta be defined rockin tha followin syntax:
c0=\fIvalue0\fR|c1=\fIvalue1\fR|c2=\fIvalue2\fR|..., where
\&\fIvaluei\fR is tha value set on tha \fIi\fR\-th control.
If \fBcontrols\fR is set ta \f(CW\*(C`help\*(C'\fR, all available controls and
their valid ranges is printed.
.IP "\fBsample_rate, s\fR" 4
.IX Item "sample_rate, s"
Specify tha sample rate, default ta 44100. Only used if plugin have
zero inputs.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per channel per each output frame, default
is 1024. Only used if plugin have zero inputs.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha minimum duration of tha sourced audio. Right back up in yo muthafuckin ass. See tha function
\&\f(CW\*(C`av_parse_time()\*(C'\fR fo' tha accepted format, also check tha \*(L"Time duration\*(R"
section up in tha ffmpeg-utils manual.
Note dat tha resultin duration may be pimped outa than tha specified duration,
as tha generated audio be always cut all up in tha end of a cold-ass lil complete frame.
If not specified, or tha expressed duration is negative, tha audio is
supposed ta be generated alllll muthafuckin day.
Only used if plugin have zero inputs.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
List all available plugins within amp (\s-1LADSPA\s0 example plugin) library:
.Sp
.Vb 1
\&        ladspa=file=amp
.Ve
.IP "\(bu" 4
List all available controls n' they valid ranges fo' \f(CW\*(C`vcf_notch\*(C'\fR
plugin from \f(CW\*(C`VCF\*(C'\fR library:
.Sp
.Vb 1
\&        ladspa=f=vcf:p=vcf_notch:c=help
.Ve
.IP "\(bu" 4
Simulate low qualitizzle audio shiznit rockin \f(CW\*(C`Computa Music Toolkit\*(C'\fR (\s-1CMT\s0)
plugin library:
.Sp
.Vb 1
\&        ladspa=file=cmt:plugin=lofi:controls=c0=22|c1=12|c2=12
.Ve
.IP "\(bu" 4
Add reverberation ta tha audio rockin TAP-plugins
(Tomz Audio Processin plugins):
.Sp
.Vb 1
\&        ladspa=file=tap_reverb:tap_reverb
.Ve
.IP "\(bu" 4
Generate white noise, wit 0.2 amplitude:
.Sp
.Vb 1
\&        ladspa=file=cmt:noise_source_white:c=c0=.2
.Ve
.IP "\(bu" 4
Generate 20 bpm clicks rockin plugin \f(CW\*(C`C* Click \- Metronome\*(C'\fR from the
\&\f(CW\*(C`C* Audio Plugin Suite\*(C'\fR (\s-1CAPS\s0) library:
.Sp
.Vb 1
\&        ladspa=file=caps:Click:c=c1=20\*(Aq
.Ve
.IP "\(bu" 4
Apply \f(CW\*(C`C* Eq10X2 \- Stereo 10\-band equaliser\*(C'\fR effect:
.Sp
.Vb 1
\&        ladspa=caps:Eq10X2:c=c0=\-48|c9=\-24|c3=12|c4=2
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBcN\fR" 4
.IX Item "cN"
Modify tha \fIN\fR\-th control value.
.Sp
If tha specified value aint valid, it is ignored n' prior one is kept.
.SS "lowpass"
.IX Subsection "lowpass"
Apply a low-pass filta wit 3dB point frequency.
Da filta can be either single-pole or double-pole (the default).
Da filta roll off at 6dB per pole per octave (20dB per pole per decade).
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set frequency up in Hz. Default is 500.
.IP "\fBpoles, p\fR" 4
.IX Item "poles, p"
Set number of poles. Default is 2.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Specify tha band-width of a gangbangin' filta up in width_type units.
Applies only ta double-pole filter.
Da default is 0.707q n' gives a Butterworth response.
.SS "pan"
.IX Subsection "pan"
Mix channels wit specific bust levels. Da filta accepts tha output
channel layout followed by a set of channels definitions.
.PP
This filta be also designed ta remap efficiently tha channelz of a audio
stream.
.PP
Da filta accepts parametaz of tha form:
"\fIl\fR:\fIoutdef\fR:\fIoutdef\fR:..."
.IP "\fBl\fR" 4
.IX Item "l"
output channel layout or number of channels
.IP "\fBoutdef\fR" 4
.IX Item "outdef"
output channel justification, of tha form:
"\fIout_name\fR=[\fIgain\fR*]\fIin_name\fR[+[\fIgain\fR*]\fIin_name\fR...]"
.IP "\fBout_name\fR" 4
.IX Item "out_name"
output channel ta define, either a cold-ass lil channel name (\s-1FL, FR,\s0 etc.) or a cold-ass lil channel
number (c0, c1, etc.)
.IP "\fBgain\fR" 4
.IX Item "gain"
multiplicatizzle coefficient fo' tha channel, 1 leavin tha volume unchanged
.IP "\fBin_name\fR" 4
.IX Item "in_name"
input channel ta use, peep out_name fo' details; it aint possible ta mix
named n' numbered input channels
.PP
If tha `=' up in a cold-ass lil channel justification is replaced by `<', then tha gains for
that justification is ghon be renormalized so dat tha total is 1, thus
avoidin clippin noise.
.PP
\fIMixin examples\fR
.IX Subsection "Mixin examples"
.PP
For example, if you wanna down-mix from stereo ta mono yo, but wit a funky-ass bigger
factor fo' tha left channel:
.PP
.Vb 1
\&        pan=1:c0=0.9*c0+0.1*c1
.Ve
.PP
A customized down-mix ta stereo dat works automatically fo' 3\-, 4\-, 5\- and
7\-channels surround:
.PP
.Vb 1
\&        pan=stereo: FL < FL + 0.5*FC + 0.6*BL + 0.6*SL : FR < FR + 0.5*FC + 0.6*BR + 0.6*SR
.Ve
.PP
Note dat \fBffmpeg\fR integrates a thugged-out default down-mix (and up-mix) system
that should be preferred (see \*(L"\-ac\*(R" option) unless you have straight-up specific
needs.
.PP
\fIRemappin examples\fR
.IX Subsection "Remappin examples"
.PP
Da channel remappin is ghon be effectizzle if, n' only if:
.IP "*<gain coefficients is zeroes or ones,>" 4
.IX Item "*<gain coefficients is zeroes or ones,>"
.PD 0
.IP "*<only one input per channel output,>" 4
.IX Item "*<only one input per channel output,>"
.PD
.PP
If all these conditions is satisfied, tha filta will notify tha user (\*(L"Pure
channel mappin detected\*(R"), n' use a optimized n' lossless method ta do the
remapping.
.PP
For example, if you gotz a 5.1 source n' want a stereo audio stream by
droppin tha extra channels:
.PP
.Vb 1
\&        pan="stereo: c0=FL : c1=FR"
.Ve
.PP
Given tha same source, you can also switch front left n' front right channels
and keep tha input channel layout:
.PP
.Vb 1
\&        pan="5.1: c0=c1 : c1=c0 : c2=c2 : c3=c3 : c4=c4 : c5=c5"
.Ve
.PP
If tha input be a stereo audio stream, you can mute tha front left channel (and
still keep tha stereo channel layout) with:
.PP
.Vb 1
\&        pan="stereo:c1=c1"
.Ve
.PP
Still wit a stereo audio stream input, you can copy tha right channel up in both
front left n' right:
.PP
.Vb 1
\&        pan="stereo: c0=FR : c1=FR"
.Ve
.SS "replaygain"
.IX Subsection "replaygain"
ReplayGain scanner filter n' shit. This filta takes a audio stream as a input and
outputs it unchanged.
At end of filterin it displays \f(CW\*(C`track_gain\*(C'\fR n' \f(CW\*(C`track_peak\*(C'\fR.
.SS "resample"
.IX Subsection "resample"
Convert tha audio sample format, sample rate n' channel layout. This filta is
not meant ta be used directly.
.SS "silencedetect"
.IX Subsection "silencedetect"
Detect silence up in a audio stream.
.PP
This filta logs a message when it detects dat tha input audio volume is less
or equal ta a noise tolerizzle value fo' a thugged-out duration pimped outa or equal ta the
minimum detected noise duration.
.PP
Da printed times n' duration is expressed up in seconds.
.PP
Da filta accepts tha followin options:
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set silence duration until notification (default is 2 seconds).
.IP "\fBnoise, n\fR" 4
.IX Item "noise, n"
Set noise tolerance. Can be specified up in dB (in case \*(L"dB\*(R" be appended ta the
specified value) or amplitude ratio. Default is \-60dB, or 0.001.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Detect 5 secondz of silence wit \-50dB noise tolerance:
.Sp
.Vb 1
\&        silencedetect=n=\-50dB:d=5
.Ve
.IP "\(bu" 4
Complete example wit \fBffmpeg\fR ta detect silence wit 0.0001 noise
tolerizzle up in \fIsilence.mp3\fR:
.Sp
.Vb 1
\&        ffmpeg \-i silence.mp3 \-af silencedetect=noise=0.0001 \-f null \-
.Ve
.SS "treble"
.IX Subsection "treble"
Boost or cut treble (upper) frequenciez of tha audio rockin a two-pole
shelvin filta wit a response similar ta dat of a standard
hi-fiz tone-controls. This be also known as shelvin equalisation (\s-1EQ\s0).
.PP
Da filta accepts tha followin options:
.IP "\fBgain, g\fR" 4
.IX Item "gain, g"
Give tha bust at whichever is tha lower of ~22 kHz n' the
Nyquist frequency. Its useful range be bout \-20 (for a big-ass cut)
to +20 (for a big-ass boost). Beware of clippin when rockin a positizzle gain.
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha filterz central frequency n' so can be used
to extend or reduce tha frequency range ta be boosted or cut.
Da default value is \f(CW3000\fR Hz.
.IP "\fBwidth_type\fR" 4
.IX Item "width_type"
Set method ta specify band-width of filter.
.RS 4
.IP "\fBh\fR" 4
.IX Item "h"
Hz
.IP "\fBq\fR" 4
.IX Item "q"
Q\-Factor
.IP "\fBo\fR" 4
.IX Item "o"
octave
.IP "\fBs\fR" 4
.IX Item "s"
slope
.RE
.RS 4
.RE
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
Determine how tha fuck steep is tha filterz shelf transition.
.SS "volume"
.IX Subsection "volume"
Adjust tha input audio volume.
.PP
Da filta accepts tha followin options:
.IP "\fBvolume\fR" 4
.IX Item "volume"
Expresses how tha fuck tha audio volume is ghon be increased or decreased.
.Sp
Output joints is clipped ta tha maximum value.
.Sp
Da output audio volume is given by tha relation:
.Sp
.Vb 1
\&        <output_volume> = <volume> * <input_volume>
.Ve
.Sp
Default value fo' \fIvolume\fR is 1.0.
.IP "\fBprecision\fR" 4
.IX Item "precision"
Set tha mathematical precision.
.Sp
This determines which input sample formats is ghon be allowed, which affects the
precision of tha volume scaling.
.RS 4
.IP "\fBfixed\fR" 4
.IX Item "fixed"
8\-bit fixed-point; limits input sample format ta U8, S16, n' S32.
.IP "\fBfloat\fR" 4
.IX Item "float"
32\-bit floating-point; limits input sample format ta \s-1FLT. \s0(default)
.IP "\fBdouble\fR" 4
.IX Item "double"
64\-bit floating-point; limits input sample format ta \s-1DBL.\s0
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Halve tha input audio volume:
.Sp
.Vb 3
\&        volume=volume=0.5
\&        volume=volume=1/2
\&        volume=volume=\-6.0206dB
.Ve
.Sp
In all tha above example tha named key fo' \fBvolume\fR can be
omitted, fo' example like in:
.Sp
.Vb 1
\&        volume=0.5
.Ve
.IP "\(bu" 4
Increase input audio juice by 6 decibels rockin fixed-point precision:
.Sp
.Vb 1
\&        volume=volume=6dB:precision=fixed
.Ve
.SS "volumedetect"
.IX Subsection "volumedetect"
Detect tha volume of tha input vizzle.
.PP
Da filta has no parameters. Da input aint modified. Y'all KNOW dat shit, muthafucka! Statistics about
the volume is ghon be printed up in tha log when tha input stream end is reached.
.PP
In particular it will show tha mean volume (root mean square), maximum
volume (on a per-sample basis), n' tha beginnin of a histogram of the
registered volume joints (from tha maximum value ta a cold-ass lil cumulated 1/1000 of
the samples).
.PP
All volumes is up in decibels relatizzle ta tha maximum \s-1PCM\s0 value.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Here be a excerpt of tha output:
.PP
.Vb 9
\&        [Parsed_volumedetect_0  0xa23120] mean_volume: \-27 dB
\&        [Parsed_volumedetect_0  0xa23120] max_volume: \-4 dB
\&        [Parsed_volumedetect_0  0xa23120] histogram_4db: 6
\&        [Parsed_volumedetect_0  0xa23120] histogram_5db: 62
\&        [Parsed_volumedetect_0  0xa23120] histogram_6db: 286
\&        [Parsed_volumedetect_0  0xa23120] histogram_7db: 1042
\&        [Parsed_volumedetect_0  0xa23120] histogram_8db: 2551
\&        [Parsed_volumedetect_0  0xa23120] histogram_9db: 4609
\&        [Parsed_volumedetect_0  0xa23120] histogram_10db: 8409
.Ve
.PP
It means that:
.IP "\(bu" 4
Da mean square juice be approximately \-27 dB, or 10^\-2.7.
.IP "\(bu" 4
Da phattest sample be at \-4 dB, or mo' precisely between \-4 dB n' \-5 dB.
.IP "\(bu" 4
There is 6 samplez at \-4 dB, 62 at \-5 dB, 286 at \-6 dB, etc.
.PP
In other lyrics, raisin tha volume by +4 dB do not cause any clipping,
raisin it by +5 dB causes clippin fo' 6 samples, etc.
.SH "AUDIO SOURCES"
.IX Header "AUDIO SOURCES"
Below be a thugged-out description of tha currently available audio sources.
.SS "abuffer"
.IX Subsection "abuffer"
Buffer audio frames, n' make dem available ta tha filta chain.
.PP
This source is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/asrc_abuffer.h\fR.
.PP
It accepts tha followin named parameters:
.IP "\fBtime_base\fR" 4
.IX Item "time_base"
Timebase which is ghon be used fo' timestampz of submitted frames. Well shiiiit, it must be
either a gangbangin' floating-point number or up in \fInumerator\fR/\fIdenominator\fR form.
.IP "\fBsample_rate\fR" 4
.IX Item "sample_rate"
Da sample rate of tha incomin audio buffers.
.IP "\fBsample_fmt\fR" 4
.IX Item "sample_fmt"
Da sample format of tha incomin audio buffers.
Either a sample format name or its correspongin integer representation from
the enum AVSampleFormat up in \fIlibavutil/samplefmt.h\fR
.IP "\fBchannel_layout\fR" 4
.IX Item "channel_layout"
Da channel layout of tha incomin audio buffers.
Either a cold-ass lil channel layout name from channel_layout_map in
\&\fIlibavutil/channel_layout.c\fR or its correspondin integer representation
from tha AV_CH_LAYOUT_* macros up in \fIlibavutil/channel_layout.h\fR
.IP "\fBchannels\fR" 4
.IX Item "channels"
Da number of channelz of tha incomin audio buffers.
If both \fIchannels\fR n' \fIchannel_layout\fR is specified, then they
must be consistent.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
.Vb 1
\&        abuffer=sample_rate=44100:sample_fmt=s16p:channel_layout=stereo
.Ve
.PP
will instruct tha source ta accept planar 16bit signed stereo at 44100Hz.
Since tha sample format wit name \*(L"s16p\*(R" correspondz ta tha number
6 n' tha \*(L"stereo\*(R" channel layout correspondz ta tha value 0x3, dis is
equivalent to:
.PP
.Vb 1
\&        abuffer=sample_rate=44100:sample_fmt=6:channel_layout=0x3
.Ve
.SS "aevalsrc"
.IX Subsection "aevalsrc"
Generate a audio signal specified by a expression.
.PP
This source accepts up in input one or mo' expressions (one fo' each
channel), which is evaluated n' used ta generate a cold-ass lil corresponding
audio signal.
.PP
This source accepts tha followin options:
.IP "\fBexprs\fR" 4
.IX Item "exprs"
Set tha '|'\-separated expressions list fo' each separate channel. In case the
\&\fBchannel_layout\fR option aint specified, tha selected channel layout
dependz on tha number of provided expressions.
.IP "\fBchannel_layout, c\fR" 4
.IX Item "channel_layout, c"
Set tha channel layout. Da number of channels up in tha specified layout
must be equal ta tha number of specified expressions.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha minimum duration of tha sourced audio. Right back up in yo muthafuckin ass. See tha function
\&\f(CW\*(C`av_parse_time()\*(C'\fR fo' tha accepted format.
Note dat tha resultin duration may be pimped outa than tha specified
duration, as tha generated audio be always cut all up in tha end of a
complete frame.
.Sp
If not specified, or tha expressed duration is negative, tha audio is
supposed ta be generated alllll muthafuckin day.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per channel per each output frame,
default ta 1024.
.IP "\fBsample_rate, s\fR" 4
.IX Item "sample_rate, s"
Specify tha sample rate, default ta 44100.
.PP
Each expression up in \fIexprs\fR can contain tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
number of tha evaluated sample, startin from 0
.IP "\fBt\fR" 4
.IX Item "t"
time of tha evaluated sample expressed up in seconds, startin from 0
.IP "\fBs\fR" 4
.IX Item "s"
sample rate
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Generate silence:
.Sp
.Vb 1
\&        aevalsrc=0
.Ve
.IP "\(bu" 4
Generate a sin signal wit frequency of 440 Hz, set sample rate to
8000 Hz:
.Sp
.Vb 1
\&        aevalsrc="sin(440*2*PI*t):s=8000"
.Ve
.IP "\(bu" 4
Generate a two channels signal, specify tha channel layout (Front
Centa + Back Center) explicitly:
.Sp
.Vb 1
\&        aevalsrc="sin(420*2*PI*t)|cos(430*2*PI*t):c=FC|BC"
.Ve
.IP "\(bu" 4
Generate white noise:
.Sp
.Vb 1
\&        aevalsrc="\-2+random(0)"
.Ve
.IP "\(bu" 4
Generate a amplitude modulated signal:
.Sp
.Vb 1
\&        aevalsrc="sin(10*2*PI*t)*sin(880*2*PI*t)"
.Ve
.IP "\(bu" 4
Generate 2.5 Hz binaural beats on a 360 Hz carrier:
.Sp
.Vb 1
\&        aevalsrc="0.1*sin(2*PI*(360\-2.5/2)*t) | 0.1*sin(2*PI*(360+2.5/2)*t)"
.Ve
.SS "anullsrc"
.IX Subsection "anullsrc"
Null audio source, return unprocessed audio frames. Well shiiiit, it is mainly useful
as a template n' ta be employed up in analysis / debuggin tools, or as
the source fo' filtas which ignore tha input data (for example tha sox
synth filter).
.PP
This source accepts tha followin options:
.IP "\fBchannel_layout, cl\fR" 4
.IX Item "channel_layout, cl"
Specify tha channel layout, n' can be either a integer or a string
representin a cold-ass lil channel layout. Da default value of \fIchannel_layout\fR
is \*(L"stereo\*(R".
.Sp
Peep tha channel_layout_map definizzle in
\&\fIlibavutil/channel_layout.c\fR fo' tha mappin between strings and
channel layout joints.
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Specify tha sample rate, n' defaults ta 44100.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha number of samplez per axed frames.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha sample rate ta 48000 Hz n' tha channel layout ta \s-1AV_CH_LAYOUT_MONO.\s0
.Sp
.Vb 1
\&        anullsrc=r=48000:cl=4
.Ve
.IP "\(bu" 4
Do tha same operation wit a mo' obvious syntax:
.Sp
.Vb 1
\&        anullsrc=r=48000:cl=mono
.Ve
.PP
All tha parametas need ta be explicitly defined.
.SS "flite"
.IX Subsection "flite"
Synthesize a voice utterizzle rockin tha libflite library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libflite\*(C'\fR.
.PP
Note dat tha flite library aint thread-safe.
.PP
Da filta accepts tha followin options:
.IP "\fBlist_voices\fR" 4
.IX Item "list_voices"
If set ta 1, list tha namez of tha available voices n' exit
immediately. Default value is 0.
.IP "\fBnb_samples, n\fR" 4
.IX Item "nb_samples, n"
Set tha maximum number of samplez per frame. Default value is 512.
.IP "\fBtextfile\fR" 4
.IX Item "textfile"
Set tha filename containin tha text ta speak.
.IP "\fBtext\fR" 4
.IX Item "text"
Set tha text ta speak.
.IP "\fBvoice, v\fR" 4
.IX Item "voice, v"
Set tha voice ta use fo' tha rap synthesis. Default value is
\&\f(CW\*(C`kal\*(C'\fR. Right back up in yo muthafuckin ass. See also tha \fIlist_voices\fR option.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read from file \fIspeech.txt\fR, n' synthetize tha text rockin the
standard flite voice:
.Sp
.Vb 1
\&        flite=textfile=speech.txt
.Ve
.IP "\(bu" 4
Read tha specified text selectin tha \f(CW\*(C`slt\*(C'\fR voice:
.Sp
.Vb 1
\&        flite=text=\*(AqSo fare thee well, skanky devil of a Sub\-Sub, whose commentator I am\*(Aq:voice=slt
.Ve
.IP "\(bu" 4
Input text ta ffmpeg:
.Sp
.Vb 1
\&        ffmpeg \-f lavfi \-i flite=text=\*(AqSo fare thee well, skanky devil of a Sub\-Sub, whose commentator I am\*(Aq:voice=slt
.Ve
.IP "\(bu" 4
Make \fIffplay\fR drop a rhyme tha specified text, rockin \f(CW\*(C`flite\*(C'\fR and
the \f(CW\*(C`lavfi\*(C'\fR device:
.Sp
.Vb 1
\&        ffplay \-f lavfi flite=text=\*(AqNo mo' be grieved fo' which dat thou hast done.\*(Aq
.Ve
.PP
For mo' shiznit bout libflite, check:
<\fBhttp://www.speech.cs.cmu.edu/flite/\fR>
.SS "sine"
.IX Subsection "sine"
Generate a audio signal made of a sine wave wit amplitude 1/8.
.PP
Da audio signal is bit-exact.
.PP
Da filta accepts tha followin options:
.IP "\fBfrequency, f\fR" 4
.IX Item "frequency, f"
Set tha carrier frequency. Default is 440 Hz.
.IP "\fBbeep_factor, b\fR" 4
.IX Item "beep_factor, b"
Enable a periodic beep every last muthafuckin second wit frequency \fIbeep_factor\fR times
the carrier frequency. Default is 0, meanin tha beep is disabled.
.IP "\fBsample_rate, r\fR" 4
.IX Item "sample_rate, r"
Specify tha sample rate, default is 44100.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Specify tha duration of tha generated audio stream.
.IP "\fBsamples_per_frame\fR" 4
.IX Item "samples_per_frame"
Set tha number of samplez per output frame, default is 1024.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Generate a simple 440 Hz sine wave:
.Sp
.Vb 1
\&        sine
.Ve
.IP "\(bu" 4
Generate a 220 Hz sine wave wit a 880 Hz beep each second, fo' 5 seconds:
.Sp
.Vb 3
\&        sine=220:4:d=5
\&        sine=f=220:b=4:d=5
\&        sine=frequency=220:beep_factor=4:duration=5
.Ve
.SH "AUDIO SINKS"
.IX Header "AUDIO SINKS"
Below be a thugged-out description of tha currently available audio sinks.
.SS "abuffersink"
.IX Subsection "abuffersink"
Buffer audio frames, n' make dem available ta tha end of filta chain.
.PP
This sink is mainly intended fo' programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/buffersink.h\fR
or tha options system.
.PP
It accepts a pointa ta a AVABufferSinkContext structure, which
defines tha incomin buffers' formats, ta be passed as tha opaque
parameta ta \f(CW\*(C`avfilter_init_filter\*(C'\fR fo' initialization.
.SS "anullsink"
.IX Subsection "anullsink"
Null audio sink, do straight-up not a god damn thang wit tha input audio. Well shiiiit, it is
mainly useful as a template n' ta be employed up in analysis / debugging
tools.
.SH "VIDEO FILTERS"
.IX Header "VIDEO FILTERS"
When you configure yo' FFmpeg build, you can disable any of the
existin filtas rockin \f(CW\*(C`\-\-disable\-filters\*(C'\fR.
Da configure output will show tha vizzle filtas included up in your
build.
.PP
Below be a thugged-out description of tha currently available vizzle filters.
.SS "alphaextract"
.IX Subsection "alphaextract"
Extract tha alpha component from tha input as a grayscale vizzle. This
is especially useful wit tha \fIalphamerge\fR filter.
.SS "alphamerge"
.IX Subsection "alphamerge"
Add or replace tha alpha component of tha primary input wit the
grayscale value of a second input. This is intended fo' use with
\&\fIalphaextract\fR ta allow tha transmission or storage of frame
sequences dat have alpha up in a gangbangin' format dat don't support a alpha
channel.
.PP
For example, ta reconstruct full frames from a aiiight YUV-encoded vizzle
and a separate vizzle pimped wit \fIalphaextract\fR, you might use:
.PP
.Vb 1
\&        porno=in_alpha.mkv [alpha]; [in][alpha] alphamerge [out]
.Ve
.PP
Since dis filta is designed fo' reconstruction, it operates on frame
sequences without thankin bout timestamps, n' terminates when either
input reaches end of stream. This will cause problems if yo' encoding
pipeline drops frames. If you tryin ta apply a image as an
overlay ta a vizzle stream, consider tha \fIoverlay\fR filta instead.
.SS "ass"
.IX Subsection "ass"
Same as tha subtitlez filter, except dat it don't require libavcodec
and libavformat ta work. On tha other hand, it is limited ta \s-1ASS \s0(Advanced
Substation Alpha) subtitlez files.
.SS "bbox"
.IX Subsection "bbox"
Compute tha boundin box fo' tha non-black pixels up in tha input frame
luminizzle plane.
.PP
This filta computes tha boundin box containin all tha pixels wit a
luminizzle value pimped outa than tha minimum allowed value.
Da parametas describin tha boundin box is printed on tha filter
log.
.PP
Da filta accepts tha followin option:
.IP "\fBmin_val\fR" 4
.IX Item "min_val"
Set tha minimal luminizzle value. Default is \f(CW16\fR.
.SS "blackdetect"
.IX Subsection "blackdetect"
Detect vizzle intervals dat is (almost) straight-up black. Can be
useful ta detect chapta transitions, commercials, or invalid
recordings. Output lines gotz nuff tha time fo' tha start, end and
duration of tha detected black interval expressed up in seconds.
.PP
In order ta display tha output lines, you need ta set tha loglevel at
least ta tha \s-1AV_LOG_INFO\s0 value.
.PP
Da filta accepts tha followin options:
.IP "\fBblack_min_duration, d\fR" 4
.IX Item "black_min_duration, d"
Set tha minimum detected black duration expressed up in seconds. Well shiiiit, it must
be a non-negatizzle floatin point number.
.Sp
Default value is 2.0.
.IP "\fBpicture_black_ratio_th, pic_th\fR" 4
.IX Item "picture_black_ratio_th, pic_th"
Set tha threshold fo' thankin bout a picture \*(L"black\*(R".
Express tha minimum value fo' tha ratio:
.Sp
.Vb 1
\&        <nb_black_pixels> / <nb_pixels>
.Ve
.Sp
for which a picture is considered black.
Default value is 0.98.
.IP "\fBpixel_black_th, pix_th\fR" 4
.IX Item "pixel_black_th, pix_th"
Set tha threshold fo' thankin bout a pixel \*(L"black\*(R".
.Sp
Da threshold expresses tha maximum pixel luminizzle value fo' which a
pixel is considered \*(L"black\*(R". Da provided value is scaled accordin to
the followin equation:
.Sp
.Vb 1
\&        <absolute_threshold> = <luminance_minimum_value> + <pixel_black_th> * <luminance_range_size>
.Ve
.Sp
\&\fIluminance_range_size\fR n' \fIluminance_minimum_value\fR depend on
the input vizzle format, tha range is [0\-255] fo' \s-1YUV\s0 full-range
formats n' [16\-235] fo' \s-1YUV\s0 non full-range formats.
.Sp
Default value is 0.10.
.PP
Da followin example sets tha maximum pixel threshold ta tha minimum
value, n' detects only black intervalz of 2 or mo' seconds:
.PP
.Vb 1
\&        blackdetect=d=2:pix_th=0.00
.Ve
.SS "blackframe"
.IX Subsection "blackframe"
Detect frames dat is (almost) straight-up black. Can be useful to
detect chapta transitions or commercials. Output lines consist of
the frame number of tha detected frame, tha cementage of blackness,
the posizzle up in tha file if known or \-1 n' tha timestamp up in seconds.
.PP
In order ta display tha output lines, you need ta set tha loglevel at
least ta tha \s-1AV_LOG_INFO\s0 value.
.PP
Da filta accepts tha followin options:
.IP "\fBamount\fR" 4
.IX Item "amount"
Set tha cementage of tha pixels dat gotta be below tha threshold, defaults
to \f(CW98\fR.
.IP "\fBthreshold, thresh\fR" 4
.IX Item "threshold, thresh"
Set tha threshold below which a pixel value is considered black, defaults to
\&\f(CW32\fR.
.SS "blend"
.IX Subsection "blend"
Blend two vizzle frames tha fuck into each other.
.PP
It takes two input streams n' outputs one stream, tha straight-up original gangsta input is the
\&\*(L"top\*(R" layer n' second input is \*(L"bottom\*(R" layer.
Output terminates when shortest input terminates.
.PP
A description of tha accepted options bigs up.
.IP "\fBc0_mode\fR" 4
.IX Item "c0_mode"
.PD 0
.IP "\fBc1_mode\fR" 4
.IX Item "c1_mode"
.IP "\fBc2_mode\fR" 4
.IX Item "c2_mode"
.IP "\fBc3_mode\fR" 4
.IX Item "c3_mode"
.IP "\fBall_mode\fR" 4
.IX Item "all_mode"
.PD
Set blend mode fo' specific pixel component or all pixel components up in case
of \fIall_mode\fR. Default value is \f(CW\*(C`normal\*(C'\fR.
.Sp
Available joints fo' component modes are:
.RS 4
.IP "\fBaddition\fR" 4
.IX Item "addition"
.PD 0
.IP "\fBand\fR" 4
.IX Item "and"
.IP "\fBaverage\fR" 4
.IX Item "average"
.IP "\fBburn\fR" 4
.IX Item "burn"
.IP "\fBdarken\fR" 4
.IX Item "darken"
.IP "\fBdifference\fR" 4
.IX Item "difference"
.IP "\fBdivide\fR" 4
.IX Item "divide"
.IP "\fBdodge\fR" 4
.IX Item "dodge"
.IP "\fBexclusion\fR" 4
.IX Item "exclusion"
.IP "\fBhardlight\fR" 4
.IX Item "hardlight"
.IP "\fBlighten\fR" 4
.IX Item "lighten"
.IP "\fBmultiply\fR" 4
.IX Item "multiply"
.IP "\fBnegation\fR" 4
.IX Item "negation"
.IP "\fBnormal\fR" 4
.IX Item "normal"
.IP "\fBor\fR" 4
.IX Item "or"
.IP "\fBoverlay\fR" 4
.IX Item "overlay"
.IP "\fBphoenix\fR" 4
.IX Item "phoenix"
.IP "\fBpinlight\fR" 4
.IX Item "pinlight"
.IP "\fBreflect\fR" 4
.IX Item "reflect"
.IP "\fBscreen\fR" 4
.IX Item "screen"
.IP "\fBsoftlight\fR" 4
.IX Item "softlight"
.IP "\fBsubtract\fR" 4
.IX Item "subtract"
.IP "\fBvividlight\fR" 4
.IX Item "vividlight"
.IP "\fBxor\fR" 4
.IX Item "xor"
.RE
.RS 4
.RE
.IP "\fBc0_opacity\fR" 4
.IX Item "c0_opacity"
.IP "\fBc1_opacity\fR" 4
.IX Item "c1_opacity"
.IP "\fBc2_opacity\fR" 4
.IX Item "c2_opacity"
.IP "\fBc3_opacity\fR" 4
.IX Item "c3_opacity"
.IP "\fBall_opacity\fR" 4
.IX Item "all_opacity"
.PD
Set blend opacitizzle fo' specific pixel component or all pixel components up in case
of \fIall_opacity\fR. Only used up in combination wit pixel component blend modes.
.IP "\fBc0_expr\fR" 4
.IX Item "c0_expr"
.PD 0
.IP "\fBc1_expr\fR" 4
.IX Item "c1_expr"
.IP "\fBc2_expr\fR" 4
.IX Item "c2_expr"
.IP "\fBc3_expr\fR" 4
.IX Item "c3_expr"
.IP "\fBall_expr\fR" 4
.IX Item "all_expr"
.PD
Set blend expression fo' specific pixel component or all pixel components up in case
of \fIall_expr\fR. Note dat related mode options is ghon be ignored if dem is set.
.Sp
Da expressions can use tha followin variables:
.RS 4
.IP "\fBN\fR" 4
.IX Item "N"
Da sequential number of tha filtered frame, startin from \f(CW0\fR.
.IP "\fBX\fR" 4
.IX Item "X"
.PD 0
.IP "\fBY\fR" 4
.IX Item "Y"
.PD
the coordinatez of tha current sample
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
the width n' height of currently filtered plane
.IP "\fB\s-1SW\s0\fR" 4
.IX Item "SW"
.PD 0
.IP "\fB\s-1SH\s0\fR" 4
.IX Item "SH"
.PD
Width n' height scale dependin on tha currently filtered plane. Well shiiiit, it is the
ratio between tha correspondin luma plane number of pixels n' tha current
plane ones. E.g. fo' \s-1YUV4:2:0\s0 tha joints is \f(CW\*(C`1,1\*(C'\fR fo' tha luma plane, and
\&\f(CW\*(C`0.5,0.5\*(C'\fR fo' chroma planes.
.IP "\fBT\fR" 4
.IX Item "T"
Time of tha current frame, expressed up in seconds.
.IP "\fB\s-1TOP, A\s0\fR" 4
.IX Item "TOP, A"
Value of pixel component at current location fo' first vizzle frame (top layer).
.IP "\fB\s-1BOTTOM, B\s0\fR" 4
.IX Item "BOTTOM, B"
Value of pixel component at current location fo' second vizzle frame (bottom layer).
.RE
.RS 4
.RE
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Force termination when tha shortest input terminates. Default is \f(CW0\fR.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
Continue applyin tha last bottom frame afta tha end of tha stream fo' realz. A value of
\&\f(CW0\fR disable tha filta afta tha last frame of tha bottom layer is reached.
Default is \f(CW1\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply transizzle from bottom layer ta top layer up in first 10 seconds:
.Sp
.Vb 1
\&        blend=all_expr=\*(AqA*(if(gte(T,10),1,T/10))+B*(1\-(if(gte(T,10),1,T/10)))\*(Aq
.Ve
.IP "\(bu" 4
Apply 1x1 checkerboard effect:
.Sp
.Vb 1
\&        blend=all_expr=\*(Aqif(eq(mod(X,2),mod(Y,2)),A,B)\*(Aq
.Ve
.SS "boxblur"
.IX Subsection "boxblur"
Apply boxblur algorithm ta tha input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
.PD 0
.IP "\fBluma_power, lp\fR" 4
.IX Item "luma_power, lp"
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
.IP "\fBchroma_power, cp\fR" 4
.IX Item "chroma_power, cp"
.IP "\fBalpha_radius, ar\fR" 4
.IX Item "alpha_radius, ar"
.IP "\fBalpha_power, ap\fR" 4
.IX Item "alpha_power, ap"
.PD
.PP
A description of tha accepted options bigs up.
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
.PD 0
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
.IP "\fBalpha_radius, ar\fR" 4
.IX Item "alpha_radius, ar"
.PD
Set a expression fo' tha box radius up in pixels used fo' blurrin the
correspondin input plane.
.Sp
Da radius value must be a non-negatizzle number, n' must not be
greata than tha value of tha expression \f(CW\*(C`min(w,h)/2\*(C'\fR fo' the
luma n' alpha planes, n' of \f(CW\*(C`min(cw,ch)/2\*(C'\fR fo' tha chroma
planes.
.Sp
Default value fo' \fBluma_radius\fR is \*(L"2\*(R". If not specified,
\&\fBchroma_radius\fR n' \fBalpha_radius\fR default ta the
correspondin value set fo' \fBluma_radius\fR.
.Sp
Da expressions can contain tha followin constants:
.RS 4
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
the input width n' height up in pixels
.IP "\fBcw\fR" 4
.IX Item "cw"
.PD 0
.IP "\fBch\fR" 4
.IX Item "ch"
.PD
the input chroma image width n' height up in pixels
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.RE
.RS 4
.RE
.IP "\fBluma_power, lp\fR" 4
.IX Item "luma_power, lp"
.PD 0
.IP "\fBchroma_power, cp\fR" 4
.IX Item "chroma_power, cp"
.IP "\fBalpha_power, ap\fR" 4
.IX Item "alpha_power, ap"
.PD
Specify how tha fuck nuff times tha boxblur filta be applied ta the
correspondin plane.
.Sp
Default value fo' \fBluma_power\fR is 2. If not specified,
\&\fBchroma_power\fR n' \fBalpha_power\fR default ta the
correspondin value set fo' \fBluma_power\fR.
.Sp
A value of 0 will disable tha effect.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply a funky-ass boxblur filta wit luma, chroma, n' alpha radius
set ta 2:
.Sp
.Vb 2
\&        boxblur=luma_radius=2:luma_power=1
\&        boxblur=2:1
.Ve
.IP "\(bu" 4
Set luma radius ta 2, alpha n' chroma radius ta 0:
.Sp
.Vb 1
\&        boxblur=2:1:cr=0:ar=0
.Ve
.IP "\(bu" 4
Set luma n' chroma radius ta a gangbangin' fraction of tha vizzle dimension:
.Sp
.Vb 1
\&        boxblur=luma_radius=min(h\e,w)/10:luma_power=1:chroma_radius=min(cw\e,ch)/10:chroma_power=1
.Ve
.SS "colorbalance"
.IX Subsection "colorbalance"
Modify intensitizzle of primary flavas (red, chronic n' blue) of input frames.
.PP
Da filta allows a input frame ta be adjusted up in tha shadows, midtones or highlights
regions fo' tha red-cyan, green-magenta or blue-yellow balance.
.PP
A positizzle adjustment value shifts tha balizzle towardz tha primary color, a negative
value towardz tha complementary color.
.PP
Da filta accepts tha followin options:
.IP "\fBrs\fR" 4
.IX Item "rs"
.PD 0
.IP "\fBgs\fR" 4
.IX Item "gs"
.IP "\fBbs\fR" 4
.IX Item "bs"
.PD
Adjust red, chronic n' blue shadows (darkest pixels).
.IP "\fBrm\fR" 4
.IX Item "rm"
.PD 0
.IP "\fBgm\fR" 4
.IX Item "gm"
.IP "\fBbm\fR" 4
.IX Item "bm"
.PD
Adjust red, chronic n' blue midtones (medium pixels).
.IP "\fBrh\fR" 4
.IX Item "rh"
.PD 0
.IP "\fBgh\fR" 4
.IX Item "gh"
.IP "\fBbh\fR" 4
.IX Item "bh"
.PD
Adjust red, chronic n' blue highlights (brightest pixels).
.Sp
Allowed ranges fo' options is \f(CW\*(C`[\-1.0, 1.0]\*(C'\fR. Defaults is \f(CW0\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Add red color cast ta shadows:
.Sp
.Vb 1
\&        colorbalance=rs=.3
.Ve
.SS "colorchannelmixer"
.IX Subsection "colorchannelmixer"
Adjust vizzle input frames by re-mixin color channels.
.PP
This filta modifies a cold-ass lil color channel by addin tha joints associated to
the other channelz of tha same pixels. For example if tha value to
modify is red, tha output value will be:
.PP
.Vb 1
\&        <red>=<red>*<rr> + <blue>*<rb> + <green>*<rg> + <alpha>*<ra>
.Ve
.PP
Da filta accepts tha followin options:
.IP "\fBrr\fR" 4
.IX Item "rr"
.PD 0
.IP "\fBrg\fR" 4
.IX Item "rg"
.IP "\fBrb\fR" 4
.IX Item "rb"
.IP "\fBra\fR" 4
.IX Item "ra"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output red channel.
Default is \f(CW1\fR fo' \fIrr\fR, n' \f(CW0\fR fo' \fIrg\fR, \fIrb\fR n' \fIra\fR.
.IP "\fBgr\fR" 4
.IX Item "gr"
.PD 0
.IP "\fBgg\fR" 4
.IX Item "gg"
.IP "\fBgb\fR" 4
.IX Item "gb"
.IP "\fBga\fR" 4
.IX Item "ga"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output chronic channel.
Default is \f(CW1\fR fo' \fIgg\fR, n' \f(CW0\fR fo' \fIgr\fR, \fIgb\fR n' \fIga\fR.
.IP "\fBbr\fR" 4
.IX Item "br"
.PD 0
.IP "\fBbg\fR" 4
.IX Item "bg"
.IP "\fBbb\fR" 4
.IX Item "bb"
.IP "\fBba\fR" 4
.IX Item "ba"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output blue channel.
Default is \f(CW1\fR fo' \fIbb\fR, n' \f(CW0\fR fo' \fIbr\fR, \fIbg\fR n' \fIba\fR.
.IP "\fBar\fR" 4
.IX Item "ar"
.PD 0
.IP "\fBag\fR" 4
.IX Item "ag"
.IP "\fBab\fR" 4
.IX Item "ab"
.IP "\fBaa\fR" 4
.IX Item "aa"
.PD
Adjust contribution of input red, green, blue n' alpha channels fo' output alpha channel.
Default is \f(CW1\fR fo' \fIaa\fR, n' \f(CW0\fR fo' \fIar\fR, \fIag\fR n' \fIab\fR.
.Sp
Allowed ranges fo' options is \f(CW\*(C`[\-2.0, 2.0]\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert source ta grayscale:
.Sp
.Vb 1
\&        colorchannelmixer=.3:.4:.3:0:.3:.4:.3:0:.3:.4:.3
.Ve
.IP "\(bu" 4
Simulate sepia tones:
.Sp
.Vb 1
\&        colorchannelmixer=.393:.769:.189:0:.349:.686:.168:0:.272:.534:.131
.Ve
.SS "colormatrix"
.IX Subsection "colormatrix"
Convert color matrix.
.PP
Da filta accepts tha followin options:
.IP "\fBsrc\fR" 4
.IX Item "src"
.PD 0
.IP "\fBdst\fR" 4
.IX Item "dst"
.PD
Specify tha source n' destination color matrix. Both joints must be
specified.
.Sp
Da accepted joints are:
.RS 4
.IP "\fBbt709\fR" 4
.IX Item "bt709"
\&\s-1BT.709\s0
.IP "\fBbt601\fR" 4
.IX Item "bt601"
\&\s-1BT.601\s0
.IP "\fBsmpte240m\fR" 4
.IX Item "smpte240m"
\&\s-1SMPTE\-240M\s0
.IP "\fBfcc\fR" 4
.IX Item "fcc"
\&\s-1FCC\s0
.RE
.RS 4
.RE
.PP
For example ta convert from \s-1BT.601\s0 ta \s-1SMPTE\-240M,\s0 use tha command:
.PP
.Vb 1
\&        colormatrix=bt601:smpte240m
.Ve
.SS "copy"
.IX Subsection "copy"
Copy tha input source unchanged ta tha output. Mainly useful for
testin purposes.
.SS "crop"
.IX Subsection "crop"
Crop tha input vizzle ta given dimensions.
.PP
Da filta accepts tha followin options:
.IP "\fBw, out_w\fR" 4
.IX Item "w, out_w"
Width of tha output vizzle. Well shiiiit, it defaults ta \f(CW\*(C`iw\*(C'\fR.
This expression is evaluated only once durin tha filter
configuration.
.IP "\fBh, out_h\fR" 4
.IX Item "h, out_h"
Height of tha output vizzle. Well shiiiit, it defaults ta \f(CW\*(C`ih\*(C'\fR.
This expression is evaluated only once durin tha filter
configuration.
.IP "\fBx\fR" 4
.IX Item "x"
Horizontal position, up in tha input vizzle, of tha left edge of tha output vizzle.
It defaults ta \f(CW\*(C`(in_w\-out_w)/2\*(C'\fR.
This expression is evaluated per-frame.
.IP "\fBy\fR" 4
.IX Item "y"
Vertical position, up in tha input vizzle, of tha top edge of tha output vizzle.
It defaults ta \f(CW\*(C`(in_h\-out_h)/2\*(C'\fR.
This expression is evaluated per-frame.
.IP "\fBkeep_aspect\fR" 4
.IX Item "keep_aspect"
If set ta 1 will force tha output display aspect ratio
to be tha same of tha input, by changin tha output sample aspect
ratio. Well shiiiit, it defaults ta 0.
.PP
Da \fIout_w\fR, \fIout_h\fR, \fIx\fR, \fIy\fR parametas are
expressions containin tha followin constants:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the computed joints fo' \fIx\fR n' \fIy\fR. They is evaluated for
each freshly smoked up frame.
.IP "\fBin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fBin_h\fR" 4
.IX Item "in_h"
.PD
the input width n' height
.IP "\fBiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fBih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fBout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fBout_h\fR" 4
.IX Item "out_h"
.PD
the output (cropped) width n' height
.IP "\fBow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fBoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fBa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIiw\fR / \fIih\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.PP
Da expression fo' \fIout_w\fR may depend on tha value of \fIout_h\fR,
and tha expression fo' \fIout_h\fR may depend on \fIout_w\fR yo, but they
cannot depend on \fIx\fR n' \fIy\fR, as \fIx\fR n' \fIy\fR are
evaluated afta \fIout_w\fR n' \fIout_h\fR.
.PP
Da \fIx\fR n' \fIy\fR parametas specify tha expressions fo' the
posizzle of tha top-left corner of tha output (non-cropped) area. They
are evaluated fo' each frame. If tha evaluated value aint valid, it
is approximated ta tha nearest valid value.
.PP
Da expression fo' \fIx\fR may depend on \fIy\fR, n' tha expression
for \fIy\fR may depend on \fIx\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Crop area wit size 100x100 at posizzle (12,34).
.Sp
.Vb 1
\&        crop=100:100:12:34
.Ve
.Sp
Usin named options, tha example above becomes:
.Sp
.Vb 1
\&        crop=w=100:h=100:x=12:y=34
.Ve
.IP "\(bu" 4
Crop tha central input area wit size 100x100:
.Sp
.Vb 1
\&        crop=100:100
.Ve
.IP "\(bu" 4
Crop tha central input area wit size 2/3 of tha input vizzle:
.Sp
.Vb 1
\&        crop=2/3*in_w:2/3*in_h
.Ve
.IP "\(bu" 4
Crop tha input vizzle central square:
.Sp
.Vb 2
\&        crop=out_w=in_h
\&        crop=in_h
.Ve
.IP "\(bu" 4
Delimit tha rectangle wit tha top-left corner placed at position
100:100 n' tha right-bottom corner correspondin ta tha right-bottom
corner of tha input image:
.Sp
.Vb 1
\&        crop=in_w\-100:in_h\-100:100:100
.Ve
.IP "\(bu" 4
Crop 10 pixels from tha left n' right borders, n' 20 pixels from
the top n' bottom borders
.Sp
.Vb 1
\&        crop=in_w\-2*10:in_h\-2*20
.Ve
.IP "\(bu" 4
Keep only tha bottom right quarta of tha input image:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:in_w/2:in_h/2
.Ve
.IP "\(bu" 4
Crop height fo' gettin Greek harmony:
.Sp
.Vb 1
\&        crop=in_w:1/PHI*in_w
.Ve
.IP "\(bu" 4
Appply tremblin effect:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:(in_w\-out_w)/2+((in_w\-out_w)/2)*sin(n/10):(in_h\-out_h)/2 +((in_h\-out_h)/2)*sin(n/7)
.Ve
.IP "\(bu" 4
Apply erratic camera effect dependin on timestamp:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:(in_w\-out_w)/2+((in_w\-out_w)/2)*sin(t*10):(in_h\-out_h)/2 +((in_h\-out_h)/2)*sin(t*13)"
.Ve
.IP "\(bu" 4
Set x dependin on tha value of y:
.Sp
.Vb 1
\&        crop=in_w/2:in_h/2:y:10+10*sin(n/10)
.Ve
.SS "cropdetect"
.IX Subsection "cropdetect"
Auto-detect crop size.
.PP
Calculate necessary croppin parametas n' prints tha recommended
parametas all up in tha loggin system. Da detected dimensions
correspond ta tha non-black area of tha input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBlimit\fR" 4
.IX Item "limit"
Set higher black value threshold, which can be optionally specified
from not a god damn thang (0) ta every last muthafuckin thang (255) fo' realz. An intensitizzle value pimped outer
to tha set value is considered non-black. Default value is 24.
.IP "\fBround\fR" 4
.IX Item "round"
Set tha value fo' which tha width/height should be divisible by. The
offset be automatically adjusted ta centa tha vizzle. Use 2 ta get
only even dimensions (needed fo' 4:2:2 vizzle). 16 is dopest when
encodin ta most vizzle codecs. Default value is 16.
.IP "\fBreset_count, reset\fR" 4
.IX Item "reset_count, reset"
Set tha counta dat determines afta how tha fuck nuff frames cropdetect will
reset tha previously detected phattest vizzle area n' start over to
detect tha current optimal crop area. Default value is 0.
.Sp
This can be useful when channel logos distort tha vizzle area. 0
indicates never reset n' return tha phattest area encountered during
playback.
.SS "curves"
.IX Subsection "curves"
Apply color adjustments rockin curves.
.PP
This filta is similar ta tha Adobe Photoshop n' \s-1GIMP\s0 curves tools. Each
component (red, chronic n' blue) has its joints defined by \fIN\fR key points
tied from each other rockin a smooth curve. Da x\-axis represents tha pixel
values from tha input frame, n' tha y\-axis tha freshly smoked up pixel joints ta be set for
the output frame.
.PP
By default, a cold-ass lil component curve is defined by tha two points \fI(0;0)\fR and
\&\fI(1;1)\fR. This creates a straight line where each original gangsta pixel value is
\&\*(L"adjusted\*(R" ta its own value, which means no chizzle ta tha image.
.PP
Da filta allows you ta redefine these two points n' add some mo' n' mo' n' mo' fo' realz. A new
curve (usin a natural cubic spline interpolation) is ghon be define ta pass
smoothly all up in all these freshly smoked up coordinates. Da freshly smoked up defined points need ta be
strictly increasin over tha x\-axis, n' they \fIx\fR n' \fIy\fR joints must
be up in tha \fI[0;1]\fR interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha computed curves happened ta go outside
the vector spaces, tha joints is ghon be clipped accordingly.
.PP
If there is no key point defined up in \f(CW\*(C`x=0\*(C'\fR, tha filta will automatically
insert a \fI(0;0)\fR point. In tha same way, if there is no key point defined
in \f(CW\*(C`x=1\*(C'\fR, tha filta will automatically bang a \fI(1;1)\fR point.
.PP
Da filta accepts tha followin options:
.IP "\fBpreset\fR" 4
.IX Item "preset"
Select one of tha available color presets, n' you can put dat on yo' toast. This option can be used up in addition
to tha \fBr\fR, \fBg\fR, \fBb\fR parameters; up in dis case, tha later
options takes prioritizzle on tha preset joints.
Available presets are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
.PD 0
.IP "\fBcolor_negative\fR" 4
.IX Item "color_negative"
.IP "\fBcross_process\fR" 4
.IX Item "cross_process"
.IP "\fBdarker\fR" 4
.IX Item "darker"
.IP "\fBincrease_contrast\fR" 4
.IX Item "increase_contrast"
.IP "\fBlighter\fR" 4
.IX Item "lighter"
.IP "\fBlinear_contrast\fR" 4
.IX Item "linear_contrast"
.IP "\fBmedium_contrast\fR" 4
.IX Item "medium_contrast"
.IP "\fBnegative\fR" 4
.IX Item "negative"
.IP "\fBstrong_contrast\fR" 4
.IX Item "strong_contrast"
.IP "\fBvintage\fR" 4
.IX Item "vintage"
.RE
.RS 4
.PD
.Sp
Default is \f(CW\*(C`none\*(C'\fR.
.RE
.IP "\fBmaster, m\fR" 4
.IX Item "master, m"
Set tha masta key points, n' you can put dat on yo' toast. These points will define a second pass mapping. It
is sometimes called a \*(L"luminance\*(R" or \*(L"value\*(R" mapping. Well shiiiit, it can be used with
\&\fBr\fR, \fBg\fR, \fBb\fR or \fBall\fR since it acts like a
post-processin \s-1LUT.\s0
.IP "\fBred, r\fR" 4
.IX Item "red, r"
Set tha key points fo' tha red component.
.IP "\fBgreen, g\fR" 4
.IX Item "green, g"
Set tha key points fo' tha chronic component.
.IP "\fBblue, b\fR" 4
.IX Item "blue, b"
Set tha key points fo' tha blue component.
.IP "\fBall\fR" 4
.IX Item "all"
Set tha key points fo' all components (not includin master).
Can be used up in addizzle ta tha other key points component
options. In dis case, tha unset component(s) will fallback on this
\&\fBall\fR setting.
.IP "\fBpsfile\fR" 4
.IX Item "psfile"
Specify a Photoshop curves file (\f(CW\*(C`.asv\*(C'\fR) ta import tha settings from.
.PP
To avoid some filtergraph syntax conflicts, each key points list need ta be
defined rockin tha followin syntax: \f(CW\*(C`x0/y0 x1/y1 x2/y2 ...\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Increase slightly tha middle level of blue:
.Sp
.Vb 1
\&        curves=blue=\*(Aq0.5/0.58\*(Aq
.Ve
.IP "\(bu" 4
Vintage effect:
.Sp
.Vb 1
\&        curves=r=\*(Aq0/0.11 .42/.51 1/0.95\*(Aq:g=\*(Aq0.50/0.48\*(Aq:b=\*(Aq0/0.22 .49/.44 1/0.8\*(Aq
.Ve
.Sp
Here we obtain tha followin coordinates fo' each components:
.RS 4
.IP "\fIred\fR" 4
.IX Item "red"
\&\f(CW\*(C`(0;0.11) (0.42;0.51) (1;0.95)\*(C'\fR
.IP "\fIgreen\fR" 4
.IX Item "green"
\&\f(CW\*(C`(0;0) (0.50;0.48) (1;1)\*(C'\fR
.IP "\fIblue\fR" 4
.IX Item "blue"
\&\f(CW\*(C`(0;0.22) (0.49;0.44) (1;0.80)\*(C'\fR
.RE
.RS 4
.RE
.IP "\(bu" 4
Da previous example can also be  bigged up  wit tha associated built-in preset:
.Sp
.Vb 1
\&        curves=preset=vintage
.Ve
.IP "\(bu" 4
Or simply:
.Sp
.Vb 1
\&        curves=vintage
.Ve
.IP "\(bu" 4
Use a Photoshop preset n' redefine tha pointz of tha chronic component:
.Sp
.Vb 1
\&        curves=psfile=\*(AqMyCurvesPresets/purple.asv\*(Aq:green=\*(Aq0.45/0.53\*(Aq
.Ve
.SS "dctdnoiz"
.IX Subsection "dctdnoiz"
Denoise frames rockin 2D \s-1DCT \s0(frequency domain filtering).
.PP
This filta aint designed fo' real time n' can be mad slow.
.PP
Da filta accepts tha followin options:
.IP "\fBsigma, s\fR" 4
.IX Item "sigma, s"
Set tha noise sigma constant.
.Sp
This \fIsigma\fR defines a hard threshold of \f(CW\*(C`3 * sigma\*(C'\fR; every last muthafuckin \s-1DCT\s0
coefficient (absolute value) below dis threshold wit be dropped.
.Sp
If you need a mo' advanced filtering, peep \fBexpr\fR.
.Sp
Default is \f(CW0\fR.
.IP "\fBoverlap\fR" 4
.IX Item "overlap"
Set number overlappin pixels fo' each block. Each block iz of size
\&\f(CW\*(C`16x16\*(C'\fR. Right back up in yo muthafuckin ass. Since tha filta can be slow, you may wanna reduce dis value,
at tha cost of a less effectizzle filta n' tha risk of various artefacts.
.Sp
If tha overlappin value don't allow ta process tha whole input width or
height, a warnin is ghon be displayed n' accordin bordaz won't be denoised.
.Sp
Default value is \f(CW15\fR.
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set tha coefficient factor expression.
.Sp
For each coefficient of a \s-1DCT\s0 block, dis expression is ghon be evaluated as a
multiplier value fo' tha coefficient.
.Sp
If dis is option is set, tha \fBsigma\fR option is ghon be ignored.
.Sp
Da absolute value of tha coefficient can be accessed all up in tha \fIc\fR
variable.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Apply a thugged-out denoise wit a \fBsigma\fR of \f(CW4.5\fR:
.PP
.Vb 1
\&        dctdnoiz=4.5
.Ve
.PP
Da same operation can be  bigged up  rockin tha expression system:
.PP
.Vb 1
\&        dctdnoiz=e=\*(Aqgte(c, 4.5*3)\*(Aq
.Ve
.SS "decimate"
.IX Subsection "decimate"
Drop duplicated frames at regular intervals.
.PP
Da filta accepts tha followin options:
.IP "\fBcycle\fR" 4
.IX Item "cycle"
Set tha number of frames from which one is ghon be dropped. Y'all KNOW dat shit, muthafucka! Settin dis to
\&\fIN\fR means one frame up in every last muthafuckin batch of \fIN\fR frames is ghon be dropped.
Default is \f(CW5\fR.
.IP "\fBdupthresh\fR" 4
.IX Item "dupthresh"
Set tha threshold fo' duplicate detection. I aint talkin' bout chicken n' gravy biatch. If tha difference metric fo' a gangbangin' frame
is less than or equal ta dis value, then it is declared as duplicate. Default
is \f(CW1.1\fR
.IP "\fBscthresh\fR" 4
.IX Item "scthresh"
Set scene chizzle threshold. Y'all KNOW dat shit, muthafucka! Default is \f(CW15\fR.
.IP "\fBblockx\fR" 4
.IX Item "blockx"
.PD 0
.IP "\fBblocky\fR" 4
.IX Item "blocky"
.PD
Set tha size of tha x n' y\-axis blocks used durin metric calculations.
Larger blocks give betta noise suppression yo, but also give worse detection of
small movements, n' you can put dat on yo' toast. Must be a juice of two. Default is \f(CW32\fR.
.IP "\fBppsrc\fR" 4
.IX Item "ppsrc"
Mark main input as a pre-processed input n' activate clean source input
stream. This allows tha input ta be pre-processed wit various filtas ta help
the metrics calculation while keepin tha frame selection lossless. When set to
\&\f(CW1\fR, tha straight-up original gangsta stream is fo' tha pre-processed input, n' tha second
stream is tha clean source from where tha kept frames is chosen. I aint talkin' bout chicken n' gravy biatch. Default is
\&\f(CW0\fR.
.IP "\fBchroma\fR" 4
.IX Item "chroma"
Set whether or not chroma is considered up in tha metric calculations. Default is
\&\f(CW1\fR.
.SS "delogo"
.IX Subsection "delogo"
Suppress a \s-1TV\s0 station logo by a simple interpolation of tha surrounding
pixels. Just set a rectangle coverin tha logo n' peep it disappear
(and sometimes suttin' even uglier step tha fuck up \- yo' mileage may vary).
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Specify tha top left corner coordinatez of tha logo. They must be
specified.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Specify tha width n' height of tha logo ta clear. Shiiit, dis aint no joke. They must be
specified.
.IP "\fBband, t\fR" 4
.IX Item "band, t"
Specify tha thicknizz of tha fuzzy edge of tha rectangle (added to
\&\fIw\fR n' \fIh\fR). Da default value is 4.
.IP "\fBshow\fR" 4
.IX Item "show"
When set ta 1, a chronic rectangle is drawn on tha screen ta simplify
findin tha right \fIx\fR, \fIy\fR, \fIw\fR, n' \fIh\fR parameters.
Da default value is 0.
.Sp
Da rectangle is drawn on tha outermost pixels which is ghon be (partly)
replaced wit interpolated joints, n' you can put dat on yo' toast. Da jointz of tha next pixels
immediately outside dis rectangle up in each direction is ghon be used to
compute tha interpolated pixel joints inside tha rectangle.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set a rectangle coverin tha area wit top left corner coordinates 0,0
and size 100x77, settin a funky-ass crew of size 10:
.Sp
.Vb 1
\&        delogo=x=0:y=0:w=100:h=77:band=10
.Ve
.SS "deshake"
.IX Subsection "deshake"
Attempt ta fix lil' small-ass chizzlez up in horizontal and/or vertical shift. This
filta helps remove camera shake from hand-holdin a cold-ass lil camera, bumpin a
tripod, movin on a vehicle, etc.
.PP
Da filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.IP "\fBw\fR" 4
.IX Item "w"
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Specify a rectangular area where ta limit tha search fo' motion
vectors.
If desired tha search fo' motion vectors can be limited ta a
rectangular area of tha frame defined by its top left corner, width
and height. These parametas have tha same meanin as tha drawbox
filta which can be used ta visualise tha posizzle of tha bounding
box.
.Sp
This is useful when simultaneous movement of subjects within tha frame
might be trippin fo' camera motion by tha motion vector search.
.Sp
If any or all of \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR is set ta \-1
then tha full frame is used. Y'all KNOW dat shit, muthafucka! This allows lata options ta be set
without specifyin tha boundin box fo' tha motion vector search.
.Sp
Default \- search tha whole frame.
.IP "\fBrx\fR" 4
.IX Item "rx"
.PD 0
.IP "\fBry\fR" 4
.IX Item "ry"
.PD
Specify tha maximum extent of movement up in x n' y directions up in the
range 0\-64 pixels. Default 16.
.IP "\fBedge\fR" 4
.IX Item "edge"
Specify how tha fuck ta generate pixels ta fill blanks all up in tha edge of the
frame fo' realz. Available joints are:
.RS 4
.IP "\fBblank, 0\fR" 4
.IX Item "blank, 0"
Fill zeroes at blank locations
.IP "\fBoriginal, 1\fR" 4
.IX Item "original, 1"
Original Gangsta image at blank locations
.IP "\fBclamp, 2\fR" 4
.IX Item "clamp, 2"
Extruded edge value at blank locations
.IP "\fBmirror, 3\fR" 4
.IX Item "mirror, 3"
Mirrored edge at blank locations
.RE
.RS 4
.Sp
Default value is \fBmirror\fR.
.RE
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Specify tha blocksize ta use fo' motion search. Range 4\-128 pixels,
default 8.
.IP "\fBcontrast\fR" 4
.IX Item "contrast"
Specify tha contrast threshold fo' blocks. Only blocks wit mo' than
the specified contrast (difference between darkest n' lightest
pixels) is ghon be considered. Y'all KNOW dat shit, muthafucka! Range 1\-255, default 125.
.IP "\fBsearch\fR" 4
.IX Item "search"
Specify tha search game fo' realz. Available joints are:
.RS 4
.IP "\fBexhaustive, 0\fR" 4
.IX Item "exhaustive, 0"
Set exhaustizzle search
.IP "\fBless, 1\fR" 4
.IX Item "less, 1"
Set less exhaustizzle search.
.RE
.RS 4
.Sp
Default value is \fBexhaustive\fR.
.RE
.IP "\fBfilename\fR" 4
.IX Item "filename"
If set then a thugged-out detailed log of tha motion search is freestyled ta the
specified file.
.IP "\fBopencl\fR" 4
.IX Item "opencl"
If set ta 1, specify rockin OpenCL capabilities, only available if
FFmpeg was configured wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR. Default value is 0.
.SS "drawbox"
.IX Subsection "drawbox"
Draw a cold-ass lil colored box on tha input image.
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha top left corner coordinatez of tha box. Default ta 0.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Da expressions which specify tha width n' height of tha box, if 0 they is interpreted as
the input width n' height. Default ta 0.
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha box ta write. For tha general syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special
value \f(CW\*(C`invert\*(C'\fR is used, tha box edge color is tha same ol' dirty as the
video wit inverted luma.
.IP "\fBthickness, t\fR" 4
.IX Item "thickness, t"
Da expression which sets tha thicknizz of tha box edge. Default value is \f(CW3\fR.
.Sp
See below fo' tha list of accepted constants.
.PP
Da parametas fo' \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR n' \fIt\fR is expressions containin the
followin constants:
.IP "\fBdar\fR" 4
.IX Item "dar"
Da input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD 0
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD
Da input width n' height.
.IP "\fBsar\fR" 4
.IX Item "sar"
Da input sample aspect ratio.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da x n' y offset coordinates where tha box is drawn.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Da width n' height of tha drawn box.
.IP "\fBt\fR" 4
.IX Item "t"
Da thicknizz of tha drawn box.
.Sp
These constants allow tha \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR n' \fIt\fR expressions ta refer to
each other, so you may fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR or \f(CW\*(C`h=w/dar\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw a funky-ass black box round tha edge of tha input image:
.Sp
.Vb 1
\&        drawbox
.Ve
.IP "\(bu" 4
Draw a funky-ass box wit color red n' a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawbox=10:20:200:60:red@0.5
.Ve
.Sp
Da previous example can be specified as:
.Sp
.Vb 1
\&        drawbox=x=10:y=20:w=200:h=60:color=red@0.5
.Ve
.IP "\(bu" 4
Fill tha box wit pink color:
.Sp
.Vb 1
\&        drawbox=x=10:y=10:w=100:h=100:color=pink@0.5:t=max
.Ve
.IP "\(bu" 4
Draw a 2\-pixel red 2.40:1 mask:
.Sp
.Vb 1
\&        drawbox=x=\-t:y=0.5*(ih\-iw/2.4)\-t:w=iw+t*2:h=iw/2.4+t*2:t=2:c=red
.Ve
.SS "drawgrid"
.IX Subsection "drawgrid"
Draw a grid on tha input image.
.PP
This filta accepts tha followin options:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha coordinatez of some point of grid intersection (meant ta configure offset). Both default ta 0.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Da expressions which specify tha width n' height of tha grid cell, if 0 they is interpreted as the
input width n' height, respectively, minus \f(CW\*(C`thickness\*(C'\fR, so image gets
framed. Y'all KNOW dat shit, muthafucka! Default ta 0.
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha grid. Y'all KNOW dat shit, muthafucka! For tha general syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special
value \f(CW\*(C`invert\*(C'\fR is used, tha grid color is tha same ol' dirty as the
video wit inverted luma.
.IP "\fBthickness, t\fR" 4
.IX Item "thickness, t"
Da expression which sets tha thicknizz of tha grid line. Default value is \f(CW1\fR.
.Sp
See below fo' tha list of accepted constants.
.PP
Da parametas fo' \fIx\fR, \fIy\fR, \fIw\fR n' \fIh\fR n' \fIt\fR is expressions containin the
followin constants:
.IP "\fBdar\fR" 4
.IX Item "dar"
Da input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD 0
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD
Da input grid cell width n' height.
.IP "\fBsar\fR" 4
.IX Item "sar"
Da input sample aspect ratio.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da x n' y coordinatez of some point of grid intersection (meant ta configure offset).
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
Da width n' height of tha drawn cell.
.IP "\fBt\fR" 4
.IX Item "t"
Da thicknizz of tha drawn cell.
.Sp
These constants allow tha \fIx\fR, \fIy\fR, \fIw\fR, \fIh\fR n' \fIt\fR expressions ta refer to
each other, so you may fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR or \f(CW\*(C`h=w/dar\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw a grid wit cell 100x100 pixels, thicknizz 2 pixels, wit color red n' a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawgrid=width=100:height=100:thickness=2:color=red@0.5
.Ve
.IP "\(bu" 4
Draw a white 3x3 grid wit a opacitizzle of 50%:
.Sp
.Vb 1
\&        drawgrid=w=iw/3:h=ih/3:t=2:c=white@0.5
.Ve
.SS "drawtext"
.IX Subsection "drawtext"
Draw text strang or text from specified file on top of vizzle rockin the
libfreetype library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libfreetype\*(C'\fR.
.PP
\fISyntax\fR
.IX Subsection "Syntax"
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBbox\fR" 4
.IX Item "box"
Used ta draw a funky-ass box round text rockin background color.
Value should be either 1 (enable) or 0 (disable).
Da default value of \fIbox\fR is 0.
.IP "\fBboxcolor\fR" 4
.IX Item "boxcolor"
Da color ta be used fo' drawin box round text. For tha syntax of this
option, check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIboxcolor\fR is \*(L"white\*(R".
.IP "\fBexpansion\fR" 4
.IX Item "expansion"
Select how tha fuck tha \fItext\fR is expanded. Y'all KNOW dat shit, muthafucka! Can be either \f(CW\*(C`none\*(C'\fR,
\&\f(CW\*(C`strftime\*(C'\fR (deprecated) or
\&\f(CW\*(C`normal\*(C'\fR (default). Right back up in yo muthafuckin ass. See tha drawtext_expansion, Text expansion section
below fo' details.
.IP "\fBfix_bounds\fR" 4
.IX Item "fix_bounds"
If true, check n' fix text coordz ta avoid clipping.
.IP "\fBfontcolor\fR" 4
.IX Item "fontcolor"
Da color ta be used fo' drawin fonts, n' you can put dat on yo' toast. For tha syntax of dis option, check
the \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIfontcolor\fR is \*(L"black\*(R".
.IP "\fBfontfile\fR" 4
.IX Item "fontfile"
Da font file ta be used fo' drawin text. Path must be included.
This parameta is mandatory.
.IP "\fBfontsize\fR" 4
.IX Item "fontsize"
Da font size ta be used fo' drawin text.
Da default value of \fIfontsize\fR is 16.
.IP "\fBft_load_flags\fR" 4
.IX Item "ft_load_flags"
Flags ta be used fo' loadin tha fonts.
.Sp
Da flags map tha correspondin flags supported by libfreetype, n' are
a combination of tha followin joints:
.RS 4
.IP "\fIdefault\fR" 4
.IX Item "default"
.PD 0
.IP "\fIno_scale\fR" 4
.IX Item "no_scale"
.IP "\fIno_hinting\fR" 4
.IX Item "no_hinting"
.IP "\fIrender\fR" 4
.IX Item "render"
.IP "\fIno_bitmap\fR" 4
.IX Item "no_bitmap"
.IP "\fIvertical_layout\fR" 4
.IX Item "vertical_layout"
.IP "\fIforce_autohint\fR" 4
.IX Item "force_autohint"
.IP "\fIcrop_bitmap\fR" 4
.IX Item "crop_bitmap"
.IP "\fIpedantic\fR" 4
.IX Item "pedantic"
.IP "\fIignore_global_advance_width\fR" 4
.IX Item "ignore_global_advance_width"
.IP "\fIno_recurse\fR" 4
.IX Item "no_recurse"
.IP "\fIignore_transform\fR" 4
.IX Item "ignore_transform"
.IP "\fImonochrome\fR" 4
.IX Item "monochrome"
.IP "\fIlinear_design\fR" 4
.IX Item "linear_design"
.IP "\fIno_autohint\fR" 4
.IX Item "no_autohint"
.RE
.RS 4
.PD
.Sp
Default value is \*(L"render\*(R".
.Sp
For mo' shiznit consult tha documentation fo' tha FT_LOAD_*
libfreetype flags.
.RE
.IP "\fBshadowcolor\fR" 4
.IX Item "shadowcolor"
Da color ta be used fo' drawin a gangbangin' finger-lickin' dirty-ass shadow behind tha drawn text. For the
syntax of dis option, check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIshadowcolor\fR is \*(L"black\*(R".
.IP "\fBshadowx\fR" 4
.IX Item "shadowx"
.PD 0
.IP "\fBshadowy\fR" 4
.IX Item "shadowy"
.PD
Da x n' y offsets fo' tha text shadow posizzle wit respect ta the
posizzle of tha text. They can be either positizzle or negative
values. Default value fo' both is \*(L"0\*(R".
.IP "\fBstart_number\fR" 4
.IX Item "start_number"
Da startin frame number fo' tha n/frame_num variable. Da default value
is \*(L"0\*(R".
.IP "\fBtabsize\fR" 4
.IX Item "tabsize"
Da size up in number of spaces ta use fo' renderin tha tab.
Default value is 4.
.IP "\fBtimecode\fR" 4
.IX Item "timecode"
Set tha initial timecode representation up in \*(L"hh:mm:ss[:;.]ff\*(R"
format. Well shiiiit, it can be used wit or without text parameter n' shit. \fItimecode_rate\fR
option must be specified.
.IP "\fBtimecode_rate, rate, r\fR" 4
.IX Item "timecode_rate, rate, r"
Set tha timecode frame rate (timecode only).
.IP "\fBtext\fR" 4
.IX Item "text"
Da text strang ta be drawn. I aint talkin' bout chicken n' gravy biatch. Da text must be a sequence of \s-1UTF\-8\s0
encoded characters.
This parameta is mandatory if no file is specified wit tha parameter
\&\fItextfile\fR.
.IP "\fBtextfile\fR" 4
.IX Item "textfile"
A text file containin text ta be drawn. I aint talkin' bout chicken n' gravy biatch. Da text must be a sequence
of \s-1UTF\-8\s0 encoded characters.
.Sp
This parameta is mandatory if no text strang is specified wit the
parameta \fItext\fR.
.Sp
If both \fItext\fR n' \fItextfile\fR is specified, a error is thrown.
.IP "\fBreload\fR" 4
.IX Item "reload"
If set ta 1, tha \fItextfile\fR is ghon be reloaded before each frame.
Be shizzle ta update it atomically, or it may be read partially, or even fail.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Da expressions which specify tha offsets where text is ghon be drawn
within tha vizzle frame. They is relatizzle ta tha top/left border of the
output image.
.Sp
Da default value of \fIx\fR n' \fIy\fR is \*(L"0\*(R".
.Sp
See below fo' tha list of accepted constants n' functions.
.PP
Da parametas fo' \fIx\fR n' \fIy\fR is expressions containin the
followin constants n' functions:
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIw\fR / \fIh\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBline_h, lh\fR" 4
.IX Item "line_h, lh"
the height of each text line
.IP "\fBmain_h, h, H\fR" 4
.IX Item "main_h, h, H"
the input height
.IP "\fBmain_w, w, W\fR" 4
.IX Item "main_w, w, W"
the input width
.IP "\fBmax_glyph_a, ascent\fR" 4
.IX Item "max_glyph_a, ascent"
the maximum distizzle from tha baseline ta tha highest/upper grid
coordinizzle used ta place a glyph outline point, fo' all tha rendered
glyphs.
It be a positizzle value, cuz of tha gridz orientation wit tha Y axis
upwards.
.IP "\fBmax_glyph_d, descent\fR" 4
.IX Item "max_glyph_d, descent"
the maximum distizzle from tha baseline ta tha lowest grid coordinate
used ta place a glyph outline point, fo' all tha rendered glyphs.
This be a wack value, cuz of tha gridz orientation, wit tha Y axis
upwards.
.IP "\fBmax_glyph_h\fR" 4
.IX Item "max_glyph_h"
maximum glyph height, dat is tha maximum height fo' all tha glyphs
contained up in tha rendered text, it is equivalent ta \fIascent\fR \-
\&\fIdescent\fR.
.IP "\fBmax_glyph_w\fR" 4
.IX Item "max_glyph_w"
maximum glyph width, dat is tha maximum width fo' all tha glyphs
contained up in tha rendered text
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBrand(min, max)\fR" 4
.IX Item "rand(min, max)"
return a random number included between \fImin\fR n' \fImax\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBtext_h, th\fR" 4
.IX Item "text_h, th"
the height of tha rendered text
.IP "\fBtext_w, tw\fR" 4
.IX Item "text_w, tw"
the width of tha rendered text
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the x n' y offset coordinates where tha text is drawn.
.Sp
These parametas allow tha \fIx\fR n' \fIy\fR expressions ta refer
each other, so you can fo' example specify \f(CW\*(C`y=x/dar\*(C'\fR.
.PP
If libavfilta was built wit \f(CW\*(C`\-\-enable\-fontconfig\*(C'\fR, then
\&\fBfontfile\fR can be a gangbangin' fontconfig pattern or omitted.
.PP
\fIText expansion\fR
.IX Subsection "Text expansion"
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`strftime\*(C'\fR,
the filta recognizes \fIstrftime()\fR sequences up in tha provided text and
expandz dem accordingly. Peep tha documentation of \fIstrftime()\fR. This
feature is deprecated.
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`none\*(C'\fR, tha text is printed verbatim.
.PP
If \fBexpansion\fR is set ta \f(CW\*(C`normal\*(C'\fR (which is tha default),
the followin expansion mechanizzle is used.
.PP
Da backslash characta '\e', followed by any character, always expandz to
the second character.
.PP
Sequence of tha form \f(CW\*(C`%{...}\*(C'\fR is expanded. Y'all KNOW dat shit, muthafucka! Da text between the
braces be a gangbangin' function name, possibly followed by arguments separated by ':'.
If tha arguments contain special charactas or delimitas (':' or '}'),
they should be escaped.
.PP
Note dat they probably must also be escaped as tha value fo' the
\&\fBtext\fR option up in tha filta argument strang n' as tha filter
argument up in tha filtergraph description, n' possibly also fo' tha shell,
that make up ta four levelz of escaping; rockin a text file avoidz these
problems.
.PP
Da followin functions is available:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Da expression evaluation result.
.Sp
It must take one argument specifyin tha expression ta be evaluated,
which accepts tha same ol' dirty constants n' functions as tha \fIx\fR and
\&\fIy\fR joints, n' you can put dat on yo' toast. Note dat not all constants should be used, for
example tha text size aint known when evaluatin tha expression, so
the constants \fItext_w\fR n' \fItext_h\fR gonna git a undefined
value.
.IP "\fBgmtime\fR" 4
.IX Item "gmtime"
Da time at which tha filta is hustlin, expressed up in \s-1UTC.\s0
It can accept a argument: a \fIstrftime()\fR format string.
.IP "\fBlocaltime\fR" 4
.IX Item "localtime"
Da time at which tha filta is hustlin, expressed up in tha local time unit.
It can accept a argument: a \fIstrftime()\fR format string.
.IP "\fBmetadata\fR" 4
.IX Item "metadata"
Frame metadata. Well shiiiit, it must take one argument specifyin metadata key.
.IP "\fBn, frame_num\fR" 4
.IX Item "n, frame_num"
Da frame number, startin from 0.
.IP "\fBpict_type\fR" 4
.IX Item "pict_type"
A 1 characta description of tha current picture type.
.IP "\fBpts\fR" 4
.IX Item "pts"
Da timestamp of tha current frame, up in seconds, wit microsecond accuracy.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw \*(L"Test Text\*(R" wit font FreeSerif, rockin tha default joints fo' the
optionizzle parameters.
.Sp
.Vb 1
\&        drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text=\*(AqTest Text\*(Aq"
.Ve
.IP "\(bu" 4
Draw 'Test Text' wit font FreeSerif of size 24 at posizzle x=100
and y=50 (countin from tha top-left corner of tha screen), text is
yellow wit a red box round dat shit. Both tha text n' tha box have an
opacitizzle of 20%.
.Sp
.Vb 2
\&        drawtext="fontfile=/usr/share/fonts/truetype/freefont/FreeSerif.ttf: text=\*(AqTest Text\*(Aq:\e
\&                  x=100: y=50: fontsize=24: fontcolor=yellow@0.2: box=1: boxcolor=red@0.2"
.Ve
.Sp
Note dat tha double quotes is not necessary if spaces is not used
within tha parameta list.
.IP "\(bu" 4
Show tha text all up in tha centa of tha vizzle frame:
.Sp
.Vb 1
\&        drawtext="fontsize=30:fontfile=FreeSerif.ttf:text=\*(Aqwassup ghetto\*(Aq:x=(w\-text_w)/2:y=(h\-text_h\-line_h)/2"
.Ve
.IP "\(bu" 4
Show a text line slidin from right ta left up in tha last row of tha vizzle
frame. Da file \fI\s-1LONG_LINE\s0\fR be assumed ta contain a single line
with no newlines.
.Sp
.Vb 1
\&        drawtext="fontsize=15:fontfile=FreeSerif.ttf:text=LONG_LINE:y=h\-line_h:x=\-50*t"
.Ve
.IP "\(bu" 4
Show tha content of file \fI\s-1CREDITS\s0\fR off tha bottom of tha frame n' scroll up.
.Sp
.Vb 1
\&        drawtext="fontsize=20:fontfile=FreeSerif.ttf:textfile=CREDITS:y=h\-20*t"
.Ve
.IP "\(bu" 4
Draw a single chronic letta \*(L"g\*(R", all up in tha centa of tha input vizzle.
Da glyph baseline is placed at half screen height.
.Sp
.Vb 1
\&        drawtext="fontsize=60:fontfile=FreeSerif.ttf:fontcolor=green:text=g:x=(w\-max_glyph_w)/2:y=h/2\-ascent"
.Ve
.IP "\(bu" 4
Show text fo' 1 second every last muthafuckin 3 seconds:
.Sp
.Vb 1
\&        drawtext="fontfile=FreeSerif.ttf:fontcolor=white:x=100:y=x/dar:enable=lt(mod(t\e,3)\e,1):text=\*(Aqblink\*(Aq"
.Ve
.IP "\(bu" 4
Use fontconfig ta set tha font. Note dat tha colons need ta be escaped.
.Sp
.Vb 1
\&        drawtext=\*(Aqfontfile=Linux Libertine O\-40\e:style=Semibold:text=FFmpeg\*(Aq
.Ve
.IP "\(bu" 4
Print tha date of a real-time encodin (see \fIstrftime\fR\|(3)):
.Sp
.Vb 1
\&        drawtext=\*(Aqfontfile=FreeSans.ttf:text=%{localtime:%a %b %d %Y}\*(Aq
.Ve
.PP
For mo' shiznit bout libfreetype, check:
<\fBhttp://www.freetype.org/\fR>.
.PP
For mo' shiznit bout fontconfig, check:
<\fBhttp://freedesktop.org/software/fontconfig/fontconfig\-user.html\fR>.
.SS "edgedetect"
.IX Subsection "edgedetect"
Detect n' draw edges. Da filta uses tha Canny Edge Detection algorithm.
.PP
Da filta accepts tha followin options:
.IP "\fBlow\fR" 4
.IX Item "low"
.PD 0
.IP "\fBhigh\fR" 4
.IX Item "high"
.PD
Set low n' high threshold joints used by tha Canny thresholding
algorithm.
.Sp
Da high threshold selects tha \*(L"strong\*(R" edge pixels, which is then
connected all up in 8\-connectivitizzle wit tha \*(L"weak\*(R" edge pixels selected
by tha low threshold.
.Sp
\&\fIlow\fR n' \fIhigh\fR threshold joints must be chizzlen up in tha range
[0,1], n' \fIlow\fR should be lesser or equal ta \fIhigh\fR.
.Sp
Default value fo' \fIlow\fR is \f(CW\*(C`20/255\*(C'\fR, n' default value fo' \fIhigh\fR
is \f(CW\*(C`50/255\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&        edgedetect=low=0.1:high=0.4
.Ve
.SS "extractplanes"
.IX Subsection "extractplanes"
Extract color channel components from input vizzle stream into
separate grayscale vizzle streams.
.PP
Da filta accepts tha followin option:
.IP "\fBplanes\fR" 4
.IX Item "planes"
Set plane(s) ta extract.
.Sp
Available joints fo' planes are:
.RS 4
.IP "\fBy\fR" 4
.IX Item "y"
.PD 0
.IP "\fBu\fR" 4
.IX Item "u"
.IP "\fBv\fR" 4
.IX Item "v"
.IP "\fBa\fR" 4
.IX Item "a"
.IP "\fBr\fR" 4
.IX Item "r"
.IP "\fBg\fR" 4
.IX Item "g"
.IP "\fBb\fR" 4
.IX Item "b"
.RE
.RS 4
.PD
.Sp
Choosin planes not available up in tha input will result up in a error.
That means you cannot select \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`g\*(C'\fR, \f(CW\*(C`b\*(C'\fR planes
with \f(CW\*(C`y\*(C'\fR, \f(CW\*(C`u\*(C'\fR, \f(CW\*(C`v\*(C'\fR planes at same time.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Extract luma, u n' v color channel component from input vizzle frame
into 3 grayscale outputs:
.Sp
.Vb 1
\&        ffmpeg \-i vizzle.avi \-filter_complex \*(Aqextractplanes=y+u+v[y][u][v]\*(Aq \-map \*(Aq[y]\*(Aq y.avi \-map \*(Aq[u]\*(Aq u.avi \-map \*(Aq[v]\*(Aq v.avi
.Ve
.SS "fade"
.IX Subsection "fade"
Apply fade\-in/out effect ta input vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBtype, t\fR" 4
.IX Item "type, t"
Da effect type \*(-- can be either \*(L"in\*(R" fo' fade-in, or \*(L"out\*(R" fo' a gangbangin' fade-out
effect.
Default is \f(CW\*(C`in\*(C'\fR.
.IP "\fBstart_frame, s\fR" 4
.IX Item "start_frame, s"
Specify tha number of tha start frame fo' startin ta apply tha fade
effect. Default is 0.
.IP "\fBnb_frames, n\fR" 4
.IX Item "nb_frames, n"
Da number of frames fo' which tha fade effect has ta last fo' realz. At tha end of the
fade-in effect tha output vizzle gonna git tha same intensitizzle as tha input vizzle,
at tha end of tha fade-out transizzle tha output vizzle is ghon be straight-up black.
Default is 25.
.IP "\fBalpha\fR" 4
.IX Item "alpha"
If set ta 1, fade only alpha channel, if one exists on tha input.
Default value is 0.
.IP "\fBstart_time, st\fR" 4
.IX Item "start_time, st"
Specify tha timestamp (in seconds) of tha frame ta start ta apply tha fade
effect. If both start_frame n' start_time is specified, tha fade will start at
whichever comes last.  Default is 0.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Da number of secondz fo' which tha fade effect has ta last fo' realz. At tha end of the
fade-in effect tha output vizzle gonna git tha same intensitizzle as tha input vizzle,
at tha end of tha fade-out transizzle tha output vizzle is ghon be straight-up black.
If both duration n' nb_frames is specified, duration is used. Y'all KNOW dat shit, muthafucka! Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Fade up in first 30 framez of vizzle:
.Sp
.Vb 1
\&        fade=in:0:30
.Ve
.Sp
Da command above is equivalent to:
.Sp
.Vb 1
\&        fade=t=in:s=0:n=30
.Ve
.IP "\(bu" 4
Fade up last 45 framez of a 200\-frame vizzle:
.Sp
.Vb 2
\&        fade=out:155:45
\&        fade=type=out:start_frame=155:nb_frames=45
.Ve
.IP "\(bu" 4
Fade up in first 25 frames n' fade up last 25 framez of a 1000\-frame vizzle:
.Sp
.Vb 1
\&        fade=in:0:25, fade=out:975:25
.Ve
.IP "\(bu" 4
Make first 5 frames black, then fade up in from frame 5\-24:
.Sp
.Vb 1
\&        fade=in:5:20
.Ve
.IP "\(bu" 4
Fade up in alpha over first 25 framez of vizzle:
.Sp
.Vb 1
\&        fade=in:0:25:alpha=1
.Ve
.IP "\(bu" 4
Make first 5.5 secondz black, then fade up in fo' 0.5 seconds:
.Sp
.Vb 1
\&        fade=t=in:st=5.5:d=0.5
.Ve
.SS "field"
.IX Subsection "field"
Extract a single field from a interlaced image rockin stride
arithmetic ta avoid wastin \s-1CPU\s0 time. Da output frames is marked as
non-interlaced.
.PP
Da filta accepts tha followin options:
.IP "\fBtype\fR" 4
.IX Item "type"
Specify whether ta extract tha top (if tha value is \f(CW0\fR or
\&\f(CW\*(C`top\*(C'\fR) or tha bottom field (if tha value is \f(CW1\fR or
\&\f(CW\*(C`bottom\*(C'\fR).
.SS "fieldmatch"
.IX Subsection "fieldmatch"
Field matchin filta fo' inverse telecine. Well shiiiit, it is meant ta reconstruct the
progressive frames from a telecined stream. Da filta do not drop duplicated
frames, so ta big up a cold-ass lil complete inverse telecine \f(CW\*(C`fieldmatch\*(C'\fR need ta be
followed by a thugged-out decimation filta like fuckin decimate up in tha filtergraph.
.PP
Da separation of tha field matchin n' tha decimation is notably motivated by
the possibilitizzle of insertin a thugged-out de-interlacin filta fallback between tha two.
If tha source has mixed telecined n' real interlaced content,
\&\f(CW\*(C`fieldmatch\*(C'\fR aint gonna be able ta match fieldz fo' tha interlaced parts.
But these remainin combed frames is ghon be marked as interlaced, n' thus can be
de-interlaced by a lata filta like fuckin yadif before decimation.
.PP
In addizzle ta tha various configuration options, \f(CW\*(C`fieldmatch\*(C'\fR can take an
optionizzle second stream, activated all up in tha \fBppsrc\fR option. I aint talkin' bout chicken n' gravy biatch. If
enabled, tha frames reconstruction is ghon be based on tha fieldz n' frames from
this second stream. This allows tha straight-up original gangsta input ta be pre-processed up in order to
help tha various algorithmz of tha filter, while keepin tha output lossless
(assumin tha fieldz is matched properly). Typically, a gangbangin' field-aware denoiser,
or brightness/contrast adjustments can help.
.PP
Note dat dis filta uses tha same ol' dirty algorithms as \s-1TIVTC/TFM \s0(AviSynth project)
and \s-1VIVTC/VFM \s0(VapourSynth project). Da lata be a light clone of \s-1TFM\s0 from
which \f(CW\*(C`fieldmatch\*(C'\fR is based on. I aint talkin' bout chicken n' gravy biatch. While tha semantic n' usage is hella
close, some behaviour n' options names can differ.
.PP
Da filta accepts tha followin options:
.IP "\fBorder\fR" 4
.IX Item "order"
Specify tha assumed field order of tha input stream fo' realz. Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Auto detect paritizzle (use FFmpegz internal paritizzle value).
.IP "\fBbff\fR" 4
.IX Item "bff"
Assume bottom field first.
.IP "\fBtff\fR" 4
.IX Item "tff"
Assume top field first.
.RE
.RS 4
.Sp
Note dat it is sometimes recommended not ta trust tha paritizzle announced by the
stream.
.Sp
Default value is \fIauto\fR.
.RE
.IP "\fBmode\fR" 4
.IX Item "mode"
Set tha matchin mode or game ta use. \fBpc\fR mode is tha safest up in the
sense dat it won't risk bustin jerkinizz cuz of duplicate frames when
possible yo, but if there be wack edits or blended fieldz it will end up
outputtin combed frames when a phat match might straight-up exist. On tha other
hand, \fBpcn_ub\fR mode is da most thugged-out risky up in termz of bustin jerkiness,
but will almost always find a phat frame if there is one. Da other joints are
all somewhere up in between \fBpc\fR n' \fBpcn_ub\fR up in termz of risking
jerkinizz n' bustin duplicate frames versus findin phat matches up in sections
with wack edits, orphaned fields, blended fields, etc.
.Sp
Mo' details bout p/c/n/u/b is available up in p/c/n/u/b meanin section.
.Sp
Available joints are:
.RS 4
.IP "\fBpc\fR" 4
.IX Item "pc"
2\-way matchin (p/c)
.IP "\fBpc_n\fR" 4
.IX Item "pc_n"
2\-way matching, n' tryin 3rd match if still combed (p/c + n)
.IP "\fBpc_u\fR" 4
.IX Item "pc_u"
2\-way matching, n' tryin 3rd match (same order) if still combed (p/c + u)
.IP "\fBpc_n_ub\fR" 4
.IX Item "pc_n_ub"
2\-way matching, tryin 3rd match if still combed, n' tryin 4th/5th matches if
still combed (p/c + n + u/b)
.IP "\fBpcn\fR" 4
.IX Item "pcn"
3\-way matchin (p/c/n)
.IP "\fBpcn_ub\fR" 4
.IX Item "pcn_ub"
3\-way matching, n' tryin 4th/5th matches if all 3 of tha original gangsta matches are
detected as combed (p/c/n + u/b)
.RE
.RS 4
.Sp
Da parenthesis all up in tha end indicate tha matches dat would be used fo' that
mode assumin \fBorder\fR=\fItff\fR (and \fBfield\fR on \fIauto\fR or
\&\fItop\fR).
.Sp
In termz of speed \fBpc\fR mode is by far tha fastest n' \fBpcn_ub\fR is
the slowest.
.Sp
Default value is \fIpc_n\fR.
.RE
.IP "\fBppsrc\fR" 4
.IX Item "ppsrc"
Mark tha main input stream as a pre-processed input, n' enable tha secondary
input stream as tha clean source ta pick tha fieldz from. Right back up in yo muthafuckin ass. See tha filter
introduction fo' mo' details. Well shiiiit, it is similar ta tha \fBclip2\fR feature from
\&\s-1VFM/TFM.\s0
.Sp
Default value is \f(CW0\fR (disabled).
.IP "\fBfield\fR" 4
.IX Item "field"
Set tha field ta match from. Well shiiiit, it is recommended ta set dis ta tha same value as
\&\fBorder\fR unless you experience matchin failures wit dat setting. In
certain circumstances changin tha field dat is used ta match from can have a
pimpin' impact on matchin performizzle fo' realz. Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Automatic (same value as \fBorder\fR).
.IP "\fBbottom\fR" 4
.IX Item "bottom"
Match from tha bottom field.
.IP "\fBtop\fR" 4
.IX Item "top"
Match from tha top field.
.RE
.RS 4
.Sp
Default value is \fIauto\fR.
.RE
.IP "\fBmchroma\fR" 4
.IX Item "mchroma"
Set whether or not chroma is included durin tha match comparisons. In most
cases it is recommended ta leave dis enabled. Y'all KNOW dat shit, muthafucka! Yo ass should set dis ta \f(CW0\fR
only if yo' clip has wack chroma problems like fuckin heavy rainbowin or other
artifacts, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Settin dis ta \f(CW0\fR could also be used ta speed thangs up at
the cost of some accuracy.
.Sp
Default value is \f(CW1\fR.
.IP "\fBy0\fR" 4
.IX Item "y0"
.PD 0
.IP "\fBy1\fR" 4
.IX Item "y1"
.PD
These define a exclusion crew which excludes tha lines between \fBy0\fR and
\&\fBy1\fR from bein included up in tha field matchin decision. I aint talkin' bout chicken n' gravy biatch fo' realz. An exclusion
band can be used ta ignore subtitles, a logo, or other thangs dat may
interfere wit tha matching. \fBy0\fR sets tha startin scan line and
\&\fBy1\fR sets tha endin line; all lines up in between \fBy0\fR and
\&\fBy1\fR (includin \fBy0\fR n' \fBy1\fR) is ghon be ignored. Y'all KNOW dat shit, muthafucka! Setting
\&\fBy0\fR n' \fBy1\fR ta tha same value will disable tha feature.
\&\fBy0\fR n' \fBy1\fR defaults ta \f(CW0\fR.
.IP "\fBscthresh\fR" 4
.IX Item "scthresh"
Set tha scene chizzle detection threshold as a cementage of maximum chizzle on
the luma plane. Dope joints is up in tha \f(CW\*(C`[8.0, 14.0]\*(C'\fR range. Right back up in yo muthafuckin ass. Scene chizzle
detection is only relevant up in case \fBcombmatch\fR=\fIsc\fR.  Da range for
\&\fBscthresh\fR is \f(CW\*(C`[0.0, 100.0]\*(C'\fR.
.Sp
Default value is \f(CW12.0\fR.
.IP "\fBcombmatch\fR" 4
.IX Item "combmatch"
When \fBcombatch\fR aint \fInone\fR, \f(CW\*(C`fieldmatch\*(C'\fR will take into
account tha combed scorez of matches when decidin what tha fuck match ta use as the
final match fo' realz. Available joints are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
No final matchin based on combed scores.
.IP "\fBsc\fR" 4
.IX Item "sc"
Combed scores is only used when a scene chizzle is detected.
.IP "\fBfull\fR" 4
.IX Item "full"
Use combed scores all tha time.
.RE
.RS 4
.Sp
Default is \fIsc\fR.
.RE
.IP "\fBcombdbg\fR" 4
.IX Item "combdbg"
Force \f(CW\*(C`fieldmatch\*(C'\fR ta calculate tha combed metrics fo' certain matches and
print em. This settin is known as \fBmicout\fR up in \s-1TFM/VFM\s0 vocabulary.
Available joints are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
No forced calculation.
.IP "\fBpcn\fR" 4
.IX Item "pcn"
Force p/c/n calculations.
.IP "\fBpcnub\fR" 4
.IX Item "pcnub"
Force p/c/n/u/b calculations.
.RE
.RS 4
.Sp
Default value is \fInone\fR.
.RE
.IP "\fBcthresh\fR" 4
.IX Item "cthresh"
This is tha area combin threshold used fo' combed frame detection. I aint talkin' bout chicken n' gravy biatch. This
essentially controls how tha fuck \*(L"strong\*(R" or \*(L"visible\*(R" combin must be ta be detected.
Larger joints mean combin must be mo' visible n' smalla joints mean combing
can be less visible or phat n' still be detected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Valid settings is from
\&\f(CW\*(C`\-1\*(C'\fR (every pixel is ghon be detected as combed) ta \f(CW255\fR (no pixel will
be detected as combed). This is basically a pixel difference value fo' realz. A good
range is \f(CW\*(C`[8, 12]\*(C'\fR.
.Sp
Default value is \f(CW9\fR.
.IP "\fBchroma\fR" 4
.IX Item "chroma"
Sets whether or not chroma is considered up in tha combed frame decision. I aint talkin' bout chicken n' gravy biatch.  Only
disable dis if yo' source has chroma problems (rainbowing, etc.) dat are
causin problems fo' tha combed frame detection wit chroma enabled. Y'all KNOW dat shit, muthafucka! Actually,
usin \fBchroma\fR=\fI0\fR is probably mo' reliable, except fo' tha case
where there is chroma only combin up in tha source.
.Sp
Default value is \f(CW0\fR.
.IP "\fBblockx\fR" 4
.IX Item "blockx"
.PD 0
.IP "\fBblocky\fR" 4
.IX Item "blocky"
.PD
Respectively set tha x\-axis n' y\-axis size of tha window used durin combed
frame detection. I aint talkin' bout chicken n' gravy biatch. This has ta do wit tha size of tha area up in which
\&\fBcombpel\fR pixels is required ta be detected as combed fo' a gangbangin' frame ta be
declared combed. Y'all KNOW dat shit, muthafucka! See tha \fBcombpel\fR parameta description fo' mo' info.
Possible joints is any number dat be a juice of 2 startin at 4 n' goin up
to 512.
.Sp
Default value is \f(CW16\fR.
.IP "\fBcombpel\fR" 4
.IX Item "combpel"
Da number of combed pixels inside any of tha \fBblocky\fR by
\&\fBblockx\fR size blocks on tha frame fo' tha frame ta be detected as
combed. Y'all KNOW dat shit, muthafucka! While \fBcthresh\fR controls how tha fuck \*(L"visible\*(R" tha combin must be, this
settin controls \*(L"how much\*(R" combin there must be up in any localized area (a
window defined by tha \fBblockx\fR n' \fBblocky\fR settings) on the
frame. Minimum value is \f(CW0\fR n' maximum is \f(CW\*(C`blocky x blockx\*(C'\fR (at
which point no frames will eva be detected as combed). This settin is known
as \fB\s-1MI\s0\fR up in \s-1TFM/VFM\s0 vocabulary.
.Sp
Default value is \f(CW80\fR.
.PP
\fIp/c/n/u/b meaning\fR
.IX Subsection "p/c/n/u/b meaning"
.PP
p/c/n
.IX Subsection "p/c/n"
.PP
We assume tha followin telecined stream:
.PP
.Vb 2
\&        Top fields:     1 2 2 3 4
\&        Bottom fields:  1 2 3 4 4
.Ve
.PP
Da numbers correspond ta tha progressive frame tha fieldz relate ta yo. Here, the
first two frames is progressive, tha 3rd n' 4th is combed, n' so on.
.PP
When \f(CW\*(C`fieldmatch\*(C'\fR is configured ta run a matchin from bottom
(\fBfield\fR=\fIbottom\fR) dis is how tha fuck dis input stream git transformed:
.PP
.Vb 3
\&        Input stream:
\&                        T     1 2 2 3 4
\&                        B     1 2 3 4 4   <\-\- matchin reference
\&        
\&        Matches:              c c n n c
\&        
\&        Output stream:
\&                        T     1 2 3 4 4
\&                        B     1 2 3 4 4
.Ve
.PP
As a result of tha field matching, we can peep dat some frames git duplicated.
To big-ass up a cold-ass lil complete inverse telecine, you need ta rely on a thugged-out decimation filter
afta dis operation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See fo' instizzle tha decimate filter.
.PP
Da same operation now matchin from top fieldz (\fBfield\fR=\fItop\fR)
looks like this:
.PP
.Vb 3
\&        Input stream:
\&                        T     1 2 2 3 4   <\-\- matchin reference
\&                        B     1 2 3 4 4
\&        
\&        Matches:              c c p p c
\&        
\&        Output stream:
\&                        T     1 2 2 3 4
\&                        B     1 2 2 3 4
.Ve
.PP
In these examples, we can peep what tha fuck \fIp\fR, \fIc\fR n' \fIn\fR mean;
basically, they refer ta tha frame n' field of tha opposite parity:
.IP "*<\fIp\fR matches tha field of tha opposite paritizzle up in tha previous frame>" 4
.IX Item "*<p matches tha field of tha opposite paritizzle up in tha previous frame>"
.PD 0
.IP "*<\fIc\fR matches tha field of tha opposite paritizzle up in tha current frame>" 4
.IX Item "*<c matches tha field of tha opposite paritizzle up in tha current frame>"
.IP "*<\fIn\fR matches tha field of tha opposite paritizzle up in tha next frame>" 4
.IX Item "*<n matches tha field of tha opposite paritizzle up in tha next frame>"
.PD
.PP
u/b
.IX Subsection "u/b"
.PP
Da \fIu\fR n' \fIb\fR matchin is a lil' bit special up in tha sense dat they match
from tha opposite paritizzle flag. In tha followin examples, we assume dat we are
currently matchin tha 2nd frame (Top:2, bottom:2) fo' realz. Accordin ta tha match, a
\&'x' is placed above n' below each matched fields.
.PP
With bottom matchin (\fBfield\fR=\fIbottom\fR):
.PP
.Vb 1
\&        Match:           c         p           n          b          u
\&        
\&                         x       x               x        x          x
\&          Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
\&          Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
\&                         x         x           x        x              x
\&        
\&        Output frames:
\&                         2          1          2          2          2
\&                         2          2          2          1          3
.Ve
.PP
With top matchin (\fBfield\fR=\fItop\fR):
.PP
.Vb 1
\&        Match:           c         p           n          b          u
\&        
\&                         x         x           x        x              x
\&          Top          1 2 2     1 2 2       1 2 2      1 2 2      1 2 2
\&          Bottom       1 2 3     1 2 3       1 2 3      1 2 3      1 2 3
\&                         x       x               x        x          x
\&        
\&        Output frames:
\&                         2          2          2          1          2
\&                         2          1          3          2          2
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Simple \s-1IVTC\s0 of a top field first telecined stream:
.PP
.Vb 1
\&        fieldmatch=order=tff:combmatch=none, decimate
.Ve
.PP
Advanced \s-1IVTC,\s0 wit fallback on yadif fo' still combed frames:
.PP
.Vb 1
\&        fieldmatch=order=tff:combmatch=full, yadif=deint=interlaced, decimate
.Ve
.SS "fieldorder"
.IX Subsection "fieldorder"
Transform tha field order of tha input vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBorder\fR" 4
.IX Item "order"
Output field order n' shit. Valid joints is \fItff\fR fo' top field first or \fIbff\fR
for bottom field first.
.PP
Default value is \fBtff\fR.
.PP
Transformation be  bigged up  by shiftin tha picture content up or down
by one line, n' fillin tha remainin line wit appropriate picture content.
This method is consistent wit most broadcast field order converters.
.PP
If tha input vizzle aint flagged as bein interlaced, or it be already
flagged as bein of tha required output field order then dis filta do
not alta tha incomin vizzle.
.PP
This filta is straight-up useful when convertin ta or from \s-1PAL DV\s0 material,
which is bottom field first.
.PP
For example:
.PP
.Vb 1
\&        ffmpeg \-i in.vob \-vf "fieldorder=bff" out.dv
.Ve
.SS "fifo"
.IX Subsection "fifo"
Buffer input images n' bust dem when they is requested.
.PP
This filta is mainly useful when auto-inserted by tha libavfilter
framework.
.PP
Da filta do not take parameters.
.SS "format"
.IX Subsection "format"
Convert tha input vizzle ta one of tha specified pixel formats.
Libavfilta will try ta pick one dat is supported fo' tha input to
the next filter.
.PP
This filta accepts tha followin parameters:
.IP "\fBpix_fmts\fR" 4
.IX Item "pix_fmts"
A '|'\-separated list of pixel format names, fo' example
\&\*(L"pix_fmts=yuv420p|monow|rgb24\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert tha input vizzle ta tha format \fIyuv420p\fR
.Sp
.Vb 1
\&        format=pix_fmts=yuv420p
.Ve
.Sp
Convert tha input vizzle ta any of tha formats up in tha list
.Sp
.Vb 1
\&        format=pix_fmts=yuv420p|yuv444p|yuv410p
.Ve
.SS "fps"
.IX Subsection "fps"
Convert tha vizzle ta specified constant frame rate by duplicatin or dropping
frames as necessary.
.PP
This filta accepts tha followin named parameters:
.IP "\fBfps\fR" 4
.IX Item "fps"
Desired output frame rate. Da default is \f(CW25\fR.
.IP "\fBround\fR" 4
.IX Item "round"
Roundin method.
.Sp
Possible joints are:
.RS 4
.IP "\fBzero\fR" 4
.IX Item "zero"
zero round towardz 0
.IP "\fBinf\fR" 4
.IX Item "inf"
round away from 0
.IP "\fBdown\fR" 4
.IX Item "down"
round towardz \-infinity
.IP "\fBup\fR" 4
.IX Item "up"
round towardz +infinity
.IP "\fBnear\fR" 4
.IX Item "near"
round ta nearest
.RE
.RS 4
.Sp
Da default is \f(CW\*(C`near\*(C'\fR.
.RE
.IP "\fBstart_time\fR" 4
.IX Item "start_time"
Assume tha straight-up original gangsta \s-1PTS\s0 should be tha given value, up in seconds. This allows for
padding/trimmin all up in tha start of stream. By default, no assumption is made
about tha straight-up original gangsta framez expected \s-1PTS,\s0 so no paddin or trimmin is done.
For example, dis could be set ta 0 ta pad tha beginnin wit duplicates of
the first frame if a vizzle stream starts afta tha audio stream or ta trim any
frames wit a wack \s-1PTS.\s0
.PP
Alternatively, tha options can be specified as a gangbangin' flat string:
\&\fIfps\fR[:\fIround\fR].
.PP
See also tha setpts filter.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
A typical usage up in order ta set tha fps ta 25:
.Sp
.Vb 1
\&        fps=fps=25
.Ve
.IP "\(bu" 4
Sets tha fps ta 24, rockin abbreviation n' roundin method ta round ta nearest:
.Sp
.Vb 1
\&        fps=fps=film:round=near
.Ve
.SS "framestep"
.IX Subsection "framestep"
Select one frame every last muthafuckin N\-th frame.
.PP
This filta accepts tha followin option:
.IP "\fBstep\fR" 4
.IX Item "step"
Select frame afta every last muthafuckin \f(CW\*(C`step\*(C'\fR frames.
Allowed joints is positizzle integers higher than 0. Default value is \f(CW1\fR.
.SS "frei0r"
.IX Subsection "frei0r"
Apply a gangbangin' frei0r effect ta tha input vizzle.
.PP
To enable compilation of dis filta you need ta install tha frei0r
header n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-frei0r\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name ta tha frei0r effect ta load. Y'all KNOW dat shit, muthafucka! If tha environment variable
\&\fB\s-1FREI0R_PATH\s0\fR is defined, tha frei0r effect is searched up in each one of the
directories specified by tha colon separated list up in \fB\s-1FREIOR_PATH\s0\fR,
otherwise up in tha standard frei0r paths, which is up in dis order:
\&\fI\s-1HOME/\s0.frei0r\-1/lib/\fR, \fI/usr/local/lib/frei0r\-1/\fR,
\&\fI/usr/lib/frei0r\-1/\fR.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
A '|'\-separated list of parametas ta pass ta tha frei0r effect.
.PP
A frei0r effect parameta can be a funky-ass boolean (whose joints is specified
with \*(L"y\*(R" n' \*(L"n\*(R"), a thugged-out double, a cold-ass lil color (specified by tha syntax
\&\fIR\fR/\fIG\fR/\fIB\fR, (\fIR\fR, \fIG\fR, n' \fIB\fR bein float
numbers from 0.0 ta 1.0) or by a cold-ass lil color description specified up in tha \*(L"Color\*(R"
section up in tha ffmpeg-utils manual), a posizzle (specified by tha syntax \fIX\fR/\fIY\fR,
\&\fIX\fR n' \fIY\fR bein float numbers) n' a string.
.PP
Da number n' kind of parametas depend on tha loaded effect. If an
effect parameta aint specified tha default value is set.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply tha distort0r effect, set tha straight-up original gangsta two double parameters:
.Sp
.Vb 1
\&        frei0r=filter_name=distort0r:filter_params=0.5|0.01
.Ve
.IP "\(bu" 4
Apply tha colordistizzle effect, take a cold-ass lil color as first parameter:
.Sp
.Vb 3
\&        frei0r=colordistance:0.2/0.3/0.4
\&        frei0r=colordistance:violet
\&        frei0r=colordistance:0x112233
.Ve
.IP "\(bu" 4
Apply tha perspectizzle effect, specify tha top left n' top right image
positions:
.Sp
.Vb 1
\&        frei0r=perspective:0.2/0.2|0.8/0.2
.Ve
.PP
For mo' shiznit see:
<\fBhttp://frei0r.dyne.org\fR>
.SS "geq"
.IX Subsection "geq"
Da filta accepts tha followin options:
.IP "\fBlum_expr, lum\fR" 4
.IX Item "lum_expr, lum"
Set tha luminizzle expression.
.IP "\fBcb_expr, cb\fR" 4
.IX Item "cb_expr, cb"
Set tha chrominizzle blue expression.
.IP "\fBcr_expr, cr\fR" 4
.IX Item "cr_expr, cr"
Set tha chrominizzle red expression.
.IP "\fBalpha_expr, a\fR" 4
.IX Item "alpha_expr, a"
Set tha alpha expression.
.IP "\fBred_expr, r\fR" 4
.IX Item "red_expr, r"
Set tha red expression.
.IP "\fBgreen_expr, g\fR" 4
.IX Item "green_expr, g"
Set tha chronic expression.
.IP "\fBblue_expr, b\fR" 4
.IX Item "blue_expr, b"
Set tha blue expression.
.PP
Da colorspace is selected accordin ta tha specified options. If one
of tha \fBlum_expr\fR, \fBcb_expr\fR, or \fBcr_expr\fR
options is specified, tha filta will automatically select a YCbCr
colorspace. If one of tha \fBred_expr\fR, \fBgreen_expr\fR, or
\&\fBblue_expr\fR options is specified, it will select a \s-1RGB\s0
colorspace.
.PP
If one of tha chrominizzle expression aint defined, it falls back on tha other
one. If no alpha expression is specified it will evaluate ta opaque value.
If none of chrominizzle expressions is specified, they will evaluate
to tha luminizzle expression.
.PP
Da expressions can use tha followin variablez n' functions:
.IP "\fBN\fR" 4
.IX Item "N"
Da sequential number of tha filtered frame, startin from \f(CW0\fR.
.IP "\fBX\fR" 4
.IX Item "X"
.PD 0
.IP "\fBY\fR" 4
.IX Item "Y"
.PD
Da coordinatez of tha current sample.
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
Da width n' height of tha image.
.IP "\fB\s-1SW\s0\fR" 4
.IX Item "SW"
.PD 0
.IP "\fB\s-1SH\s0\fR" 4
.IX Item "SH"
.PD
Width n' height scale dependin on tha currently filtered plane. Well shiiiit, it is the
ratio between tha correspondin luma plane number of pixels n' tha current
plane ones. E.g. fo' \s-1YUV4:2:0\s0 tha joints is \f(CW\*(C`1,1\*(C'\fR fo' tha luma plane, and
\&\f(CW\*(C`0.5,0.5\*(C'\fR fo' chroma planes.
.IP "\fBT\fR" 4
.IX Item "T"
Time of tha current frame, expressed up in seconds.
.IP "\fBp(x, y)\fR" 4
.IX Item "p(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha current
plane.
.IP "\fBlum(x, y)\fR" 4
.IX Item "lum(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha luminance
plane.
.IP "\fBcb(x, y)\fR" 4
.IX Item "cb(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
blue-difference chroma plane. Return 0 if there is no such plane.
.IP "\fBcr(x, y)\fR" 4
.IX Item "cr(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
red-difference chroma plane. Return 0 if there is no such plane.
.IP "\fBr(x, y)\fR" 4
.IX Item "r(x, y)"
.PD 0
.IP "\fBg(x, y)\fR" 4
.IX Item "g(x, y)"
.IP "\fBb(x, y)\fR" 4
.IX Item "b(x, y)"
.PD
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of the
red/green/blue component. Return 0 if there is no such component.
.IP "\fBalpha(x, y)\fR" 4
.IX Item "alpha(x, y)"
Return tha value of tha pixel at location (\fIx\fR,\fIy\fR) of tha alpha
plane. Return 0 if there is no such plane.
.PP
For functions, if \fIx\fR n' \fIy\fR is outside tha area, tha value will be
automatically clipped ta tha closer edge.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Flip tha image horizontally:
.Sp
.Vb 1
\&        geq=p(W\-X\e,Y)
.Ve
.IP "\(bu" 4
Generate a funky-ass bidimensionizzle sine wave, wit angle \f(CW\*(C`PI/3\*(C'\fR n' a
wavelength of 100 pixels:
.Sp
.Vb 1
\&        geq=128 + 100*sin(2*(PI/100)*(cos(PI/3)*(X\-50*T) + sin(PI/3)*Y)):128:128
.Ve
.IP "\(bu" 4
Generate a gangbangin' fancy enigmatic movin light:
.Sp
.Vb 1
\&        nullsrc=s=256x256,geq=random(1)/hypot(X\-cos(N*0.07)*W/2\-W/2\e,Y\-sin(N*0.09)*H/2\-H/2)^2*1000000*sin(N*0.02):128:128
.Ve
.IP "\(bu" 4
Generate a quick emboss effect:
.Sp
.Vb 1
\&        format=gray,geq=lum_expr=\*(Aq(p(X,Y)+(256\-p(X\-4,Y\-4)))/2\*(Aq
.Ve
.IP "\(bu" 4
Modify \s-1RGB\s0 components dependin on pixel position:
.Sp
.Vb 1
\&        geq=r=\*(AqX/W*r(X,Y)\*(Aq:g=\*(Aq(1\-X/W)*g(X,Y)\*(Aq:b=\*(Aq(H\-Y)/H*b(X,Y)\*(Aq
.Ve
.SS "gradfun"
.IX Subsection "gradfun"
Fix tha bandin artifacts dat is sometimes introduced tha fuck into nearly flat
regions by truncation ta 8bit color depth.
Interpolate tha gradients dat should go where tha bandz are, and
dither em.
.PP
This filta is designed fo' playback only.  Do not use it prior to
lossy compression, cuz compression tendz ta lose tha dither and
brin back tha bands.
.PP
This filta accepts tha followin options:
.IP "\fBstrength\fR" 4
.IX Item "strength"
Da maximum amount by which tha filta will chizzle any one pixel fo' realz. Also the
threshold fo' detectin nearly flat regions fo' realz. Acceptable joints range from .51 to
64, default value is 1.2, out-of-range joints is ghon be clipped ta tha valid
range.
.IP "\fBradius\fR" 4
.IX Item "radius"
Da hood ta fit tha gradient ta fo' realz. A larger radius make fo' smoother
gradients yo, but also prevents tha filta from modifyin tha pixels near detailed
regions fo' realz. Acceptable joints is 8\-32, default value is 16, out-of-range joints
will be clipped ta tha valid range.
.PP
Alternatively, tha options can be specified as a gangbangin' flat string:
\&\fIstrength\fR[:\fIradius\fR]
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply tha filta wit a \f(CW3.5\fR strength n' radiuz of \f(CW8\fR:
.Sp
.Vb 1
\&        gradfun=3.5:8
.Ve
.IP "\(bu" 4
Specify radius, omittin tha strength (which will fall-back ta tha default
value):
.Sp
.Vb 1
\&        gradfun=radius=8
.Ve
.SS "haldclut"
.IX Subsection "haldclut"
Apply a Hald \s-1CLUT\s0 ta a vizzle stream.
.PP
First input is tha vizzle stream ta process, n' second one is tha Hald \s-1CLUT.\s0
Da Hald \s-1CLUT\s0 input can be a simple picture or a cold-ass lil complete vizzle stream.
.PP
Da filta accepts tha followin options:
.IP "\fBshortest\fR" 4
.IX Item "shortest"
Force termination when tha shortest input terminates. Default is \f(CW0\fR.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
Continue applyin tha last \s-1CLUT\s0 afta tha end of tha stream fo' realz. A value of
\&\f(CW0\fR disable tha filta afta tha last frame of tha \s-1CLUT\s0 is reached.
Default is \f(CW1\fR.
.PP
\&\f(CW\*(C`haldclut\*(C'\fR also has tha same ol' dirty interpolation options as lut3d (both
filtas share tha same internals).
.PP
Mo' shiznit bout tha Hald \s-1CLUT\s0 can be found on Eskil Steenbergz joint
(Hald \s-1CLUT\s0 author) at <\fBhttp://www.quelsolaar.com/technology/clut.html\fR>.
.PP
\fIWorkflow examples\fR
.IX Subsection "Workflow examples"
.PP
Hald \s-1CLUT\s0 vizzle stream
.IX Subsection "Hald CLUT vizzle stream"
.PP
Generate a identitizzle Hald \s-1CLUT\s0 stream altered wit various effects:
.PP
.Vb 1
\&        ffmpeg \-f lavfi \-i haldclutsrc=8 \-vf "hue=H=2*PI*t:s=sin(2*PI*t)+1, curves=cross_process" \-t 10 \-c:v ffv1 clut.nut
.Ve
.PP
Note: make shizzle you bust a lossless codec.
.PP
Then use it wit \f(CW\*(C`haldclut\*(C'\fR ta apply it on some random stream:
.PP
.Vb 1
\&        ffmpeg \-f lavfi \-i mandelbrot \-i clut.nut \-filter_complex \*(Aq[0][1] haldclut\*(Aq \-t 20 mandelclut.mkv
.Ve
.PP
Da Hald \s-1CLUT\s0 is ghon be applied ta tha 10 first secondz (duration of
\&\fIclut.nut\fR), then tha sickest fuckin picture of dat \s-1CLUT\s0 stream is ghon be applied
to tha remainin framez of tha \f(CW\*(C`mandelbrot\*(C'\fR stream.
.PP
Hald \s-1CLUT\s0 wit peepshow
.IX Subsection "Hald CLUT wit peepshow"
.PP
A Hald \s-1CLUT\s0 is supposed ta be a squared image of \f(CW\*(C`Level*Level*Level\*(C'\fR by
\&\f(CW\*(C`Level*Level*Level\*(C'\fR pixels. For a given Hald \s-1CLUT,\s0 FFmpeg will select the
biggest possible square startin all up in tha top left of tha picture. Da remaining
paddin pixels (bottom or right) is ghon be ignored. Y'all KNOW dat shit, muthafucka! This area can be used ta add
a peepshow of tha Hald \s-1CLUT.\s0
.PP
Typically, tha followin generated Hald \s-1CLUT\s0 is ghon be supported by the
\&\f(CW\*(C`haldclut\*(C'\fR filter:
.PP
.Vb 5
\&        ffmpeg \-f lavfi \-i haldclutsrc=8 \-vf "
\&           pad=iw+320 [padded_clut];
\&           smptebars=s=320x256, split [a][b];
\&           [padded_clut][a] overlay=W\-320:h, curves=color_negatizzle [main];
\&           [main][b] overlay=W\-320" \-frames:v 1 clut.png
.Ve
.PP
It gotz nuff tha original gangsta n' a peepshow of tha effect of tha \s-1CLUT: SMPTE\s0 color
bars is displayed on tha right-top, n' below tha same color bars processed by
the color chizzles.
.PP
Then, tha effect of dis Hald \s-1CLUT\s0 can be visualized with:
.PP
.Vb 1
\&        ffplay input.mkv \-vf "movie=clut.png, [in] haldclut"
.Ve
.SS "hflip"
.IX Subsection "hflip"
Flip tha input vizzle horizontally.
.PP
For example ta horizontally flip tha input vizzle wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vf "hflip" out.avi
.Ve
.SS "histeq"
.IX Subsection "histeq"
This filta applies a global color histogram equalization on a
per-frame basis.
.PP
It can be used ta erect vizzle dat has a cold-ass lil compressed range of pixel
intensities. Put ya muthafuckin choppers up if ya feel dis!  Da filta redistributes tha pixel intensitizzles to
equalize they distribution across tha intensitizzle range. Well shiiiit, it may be
viewed as a \*(L"automatically adjustin contrast filter\*(R". This filta is
useful only fo' erectin degraded or skankyly captured source
video.
.PP
Da filta accepts tha followin options:
.IP "\fBstrength\fR" 4
.IX Item "strength"
Determine tha amount of equalization ta be applied. Y'all KNOW dat shit, muthafucka!  As tha strength
is reduced, tha distribution of pixel intensitizzles more-and-more
approaches dat of tha input frame. Da value must be a gangbangin' float number
in tha range [0,1] n' defaults ta 0.200.
.IP "\fBintensity\fR" 4
.IX Item "intensity"
Set tha maximum intensitizzle dat can generated n' scale tha output
values appropriately.  Da strength should be set as desired n' then
the intensitizzle can be limited if needed ta avoid washing-out. Da value
must be a gangbangin' float number up in tha range [0,1] n' defaults ta 0.210.
.IP "\fBantibanding\fR" 4
.IX Item "antibanding"
Set tha antibandin level. If enabled tha filta will randomly vary
the luminizzle of output pixels by a lil' small-ass amount ta avoid bandin of
the histogram. Possible joints is \f(CW\*(C`none\*(C'\fR, \f(CW\*(C`weak\*(C'\fR or
\&\f(CW\*(C`strong\*(C'\fR. Well shiiiit, it defaults ta \f(CW\*(C`none\*(C'\fR.
.SS "histogram"
.IX Subsection "histogram"
Compute n' draw a cold-ass lil color distribution histogram fo' tha input vizzle.
.PP
Da computed histogram be a representation of distribution of color components
in a image.
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Set histogram mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlevels\fR" 4
.IX Item "levels"
standard histogram dat display color components distribution up in a image.
Displays color graph fo' each color component. Right back up in yo muthafuckin ass. Shows distribution
of tha Y, U, V, A or R, G, B components, dependin on input format,
in current frame. Bellow each graph is color component scale meter.
.IP "\fBcolor\fR" 4
.IX Item "color"
chroma joints up in vectorscope, if brighta mo' such chroma joints are
distributed up in a image.
Displays chroma joints (U/V color placement) up in two dimensionizzle graph
(which is called a vectorscope). Well shiiiit, it can be used ta read of tha hue and
saturation of tha current frame fo' realz. At a same time it aint nuthin but a histogram.
Da whita a pixel up in tha vectorscope, tha mo' pixelz of tha input frame
correspond ta dat pixel (that is tha mo' pixels have dis chroma value).
Da V component is displayed on tha horizontal (X) axis, wit tha leftmost
side bein V = 0 n' tha rightmost side bein V = 255.
Da U component is displayed on tha vertical (Y) axis, wit tha top
representin U = 0 n' tha bottom representin U = 255.
.Sp
Da posizzle of a white pixel up in tha graph correspondz ta tha chroma value
of a pixel of tha input clip. Right back up in yo muthafuckin ass. So tha graph can be used ta read of the
hue (color flavor) n' tha saturation (the dominizzle of tha hue up in tha color).
As tha hue of a cold-ass lil color chizzles, it moves round tha square fo' realz. At tha centa of
the square, tha saturation is zero, which means dat tha correspondin pixel
has no color. Shiiit, dis aint no joke. If you increase tha amount of a specific color, while leaving
the other flavas unchanged, tha saturation increases, n' you move towards
the edge of tha square.
.IP "\fBcolor2\fR" 4
.IX Item "color2"
chroma joints up in vectorscope, similar as \f(CW\*(C`color\*(C'\fR but actual chroma joints
are displayed.
.IP "\fBwaveform\fR" 4
.IX Item "waveform"
per row/column color component graph. In row mode graph up in tha left side represents
color component value 0 n' right side represents value = 255. In column mode top
side represents color component value = 0 n' bottom side represents value = 255.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`levels\*(C'\fR.
.RE
.IP "\fBlevel_height\fR" 4
.IX Item "level_height"
Set height of level up in \f(CW\*(C`levels\*(C'\fR. Default value is \f(CW200\fR.
Allowed range is [50, 2048].
.IP "\fBscale_height\fR" 4
.IX Item "scale_height"
Set height of color scale up in \f(CW\*(C`levels\*(C'\fR. Default value is \f(CW12\fR.
Allowed range is [0, 40].
.IP "\fBstep\fR" 4
.IX Item "step"
Set step fo' \f(CW\*(C`waveform\*(C'\fR mode. Right back up in yo muthafuckin ass. Smalla joints is useful ta smoke up how tha fuck much
of same luminizzle joints across input rows/columns is distributed.
Default value is \f(CW10\fR fo' realz. Allowed range is [1, 255].
.IP "\fBwaveform_mode\fR" 4
.IX Item "waveform_mode"
Set mode fo' \f(CW\*(C`waveform\*(C'\fR. Can be either \f(CW\*(C`row\*(C'\fR, or \f(CW\*(C`column\*(C'\fR.
Default is \f(CW\*(C`row\*(C'\fR.
.IP "\fBwaveform_mirror\fR" 4
.IX Item "waveform_mirror"
Set mirrorin mode fo' \f(CW\*(C`waveform\*(C'\fR. \f(CW0\fR means unmirrored, \f(CW1\fR
means mirrored. Y'all KNOW dat shit, muthafucka! In mirrored mode, higher joints is ghon be represented on tha left
side fo' \f(CW\*(C`row\*(C'\fR mode n' all up in tha top fo' \f(CW\*(C`column\*(C'\fR mode. Default is
\&\f(CW0\fR (unmirrored).
.IP "\fBdisplay_mode\fR" 4
.IX Item "display_mode"
Set display mode fo' \f(CW\*(C`waveform\*(C'\fR n' \f(CW\*(C`levels\*(C'\fR.
It accepts tha followin joints:
.RS 4
.IP "\fBparade\fR" 4
.IX Item "parade"
Display separate graph fo' tha color components side by side in
\&\f(CW\*(C`row\*(C'\fR waveform mode or one below other up in \f(CW\*(C`column\*(C'\fR waveform mode
for \f(CW\*(C`waveform\*(C'\fR histogram mode. For \f(CW\*(C`levels\*(C'\fR histogram mode
per color component graphs is placed one bellow other.
.Sp
This display mode up in \f(CW\*(C`waveform\*(C'\fR histogram mode make it easy as fuck  ta spot
color casts up in tha highlights n' shadowz of a image, by comparin the
contourz of tha top n' tha bottom of each waveform.
Since whites, grays, n' blacks is characterized by
exactly equal amountz of red, green, n' blue, neutral areaz of the
picture should display three waveformz of roughly equal width/height.
If not, tha erection is easy as fuck  ta make by makin adjustments ta level the
three waveforms.
.IP "\fBoverlay\fR" 4
.IX Item "overlay"
Presents shiznit thatz identical ta dat up in tha \f(CW\*(C`parade\*(C'\fR, except
that tha graphs representin color components is superimposed directly
over one another.
.Sp
This display mode up in \f(CW\*(C`waveform\*(C'\fR histogram mode can make it easier ta spot
the relatizzle differences or similaritizzles up in overlappin areaz of tha color
components dat is supposed ta be identical, like fuckin neutral whites, grays,
or blacks.
.RE
.RS 4
.Sp
Default is \f(CW\*(C`parade\*(C'\fR.
.RE
.IP "\fBlevels_mode\fR" 4
.IX Item "levels_mode"
Set mode fo' \f(CW\*(C`levels\*(C'\fR. Can be either \f(CW\*(C`linear\*(C'\fR, or \f(CW\*(C`logarithmic\*(C'\fR.
Default is \f(CW\*(C`linear\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Calculate n' draw histogram:
.Sp
.Vb 1
\&        ffplay \-i input \-vf histogram
.Ve
.SS "hqdn3d"
.IX Subsection "hqdn3d"
High precision/qualitizzle 3d denoise filter n' shit. This filta aims ta reduce
image noise producin smooth images n' makin still images straight-up
still. Well shiiiit, it should enhizzle compressibility.
.PP
It accepts tha followin optionizzle parameters:
.IP "\fBluma_spatial\fR" 4
.IX Item "luma_spatial"
a non-negatizzle float number which specifies spatial luma strength,
defaults ta 4.0
.IP "\fBchroma_spatial\fR" 4
.IX Item "chroma_spatial"
a non-negatizzle float number which specifies spatial chroma strength,
defaults ta 3.0*\fIluma_spatial\fR/4.0
.IP "\fBluma_tmp\fR" 4
.IX Item "luma_tmp"
a float number which specifies luma temporal strength, defaults to
6.0*\fIluma_spatial\fR/4.0
.IP "\fBchroma_tmp\fR" 4
.IX Item "chroma_tmp"
a float number which specifies chroma temporal strength, defaults to
\&\fIluma_tmp\fR*\fIchroma_spatial\fR/\fIluma_spatial\fR
.SS "hue"
.IX Subsection "hue"
Modify tha hue and/or tha saturation of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBh\fR" 4
.IX Item "h"
Specify tha hue angle as a fuckin shitload of degrees. Well shiiiit, it accepts a expression,
and defaults ta \*(L"0\*(R".
.IP "\fBs\fR" 4
.IX Item "s"
Specify tha saturation up in tha [\-10,10] range. Well shiiiit, it accepts a expression and
defaults ta \*(L"1\*(R".
.IP "\fBH\fR" 4
.IX Item "H"
Specify tha hue angle as a fuckin shitload of radians. Well shiiiit, it accepts an
expression, n' defaults ta \*(L"0\*(R".
.IP "\fBb\fR" 4
.IX Item "b"
Specify tha brightnizz up in tha [\-10,10] range. Well shiiiit, it accepts a expression and
defaults ta \*(L"0\*(R".
.PP
\&\fBh\fR n' \fBH\fR is mutually exclusive, n' can't be
specified all up in tha same time.
.PP
Da \fBb\fR, \fBh\fR, \fBH\fR n' \fBs\fR option joints are
expressions containin tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
frame count of tha input frame startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
presentation timestamp of tha input frame expressed up in time base units
.IP "\fBr\fR" 4
.IX Item "r"
frame rate of tha input vizzle, \s-1NAN\s0 if tha input frame rate is unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.IP "\fBtb\fR" 4
.IX Item "tb"
time base of tha input vizzle
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha hue ta 90 degrees n' tha saturation ta 1.0:
.Sp
.Vb 1
\&        hue=h=90:s=1
.Ve
.IP "\(bu" 4
Same command but expressin tha hue up in radians:
.Sp
.Vb 1
\&        hue=H=PI/2:s=1
.Ve
.IP "\(bu" 4
Rotate hue n' make tha saturation swin between 0
and 2 over a period of 1 second:
.Sp
.Vb 1
\&        hue="H=2*PI*t: s=sin(2*PI*t)+1"
.Ve
.IP "\(bu" 4
Apply a 3 secondz saturation fade-in effect startin at 0:
.Sp
.Vb 1
\&        hue="s=min(t/3\e,1)"
.Ve
.Sp
Da general fade-in expression can be freestyled as:
.Sp
.Vb 1
\&        hue="s=min(0\e, max((t\-START)/DURATION\e, 1))"
.Ve
.IP "\(bu" 4
Apply a 3 secondz saturation fade-out effect startin at 5 seconds:
.Sp
.Vb 1
\&        hue="s=max(0\e, min(1\e, (8\-t)/3))"
.Ve
.Sp
Da general fade-out expression can be freestyled as:
.Sp
.Vb 1
\&        hue="s=max(0\e, min(1\e, (START+DURATION\-t)/DURATION))"
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBb\fR" 4
.IX Item "b"
.PD 0
.IP "\fBs\fR" 4
.IX Item "s"
.IP "\fBh\fR" 4
.IX Item "h"
.IP "\fBH\fR" 4
.IX Item "H"
.PD
Modify tha hue and/or tha saturation and/or brightnizz of tha input vizzle.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.SS "idet"
.IX Subsection "idet"
Detect vizzle interlacin type.
.PP
This filta tries ta detect if tha input is interlaced or progressive,
top or bottom field first.
.PP
Da filta accepts tha followin options:
.IP "\fBintl_thres\fR" 4
.IX Item "intl_thres"
Set interlacin threshold.
.IP "\fBprog_thres\fR" 4
.IX Item "prog_thres"
Set progressive threshold.
.SS "il"
.IX Subsection "il"
Deinterleave or interleave fields.
.PP
This filta allows ta process interlaced images fieldz without
deinterlacin em. Deinterleavin splits tha input frame tha fuck into 2
fieldz (so called half pictures). Odd lines is moved ta tha top
half of tha output image, even lines ta tha bottom half.
Yo ass can process (filter) dem independently n' then re-interleave em.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_mode, l\fR" 4
.IX Item "luma_mode, l"
.PD 0
.IP "\fBchroma_mode, c\fR" 4
.IX Item "chroma_mode, c"
.IP "\fBalpha_mode, a\fR" 4
.IX Item "alpha_mode, a"
.PD
Available joints fo' \fIluma_mode\fR, \fIchroma_mode\fR and
\&\fIalpha_mode\fR are:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Do nothing.
.IP "\fBdeinterleave, d\fR" 4
.IX Item "deinterleave, d"
Deinterleave fields, placin one above tha other.
.IP "\fBinterleave, i\fR" 4
.IX Item "interleave, i"
Interleave fields. Reverse tha effect of deinterleaving.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`none\*(C'\fR.
.RE
.IP "\fBluma_swap, ls\fR" 4
.IX Item "luma_swap, ls"
.PD 0
.IP "\fBchroma_swap, cs\fR" 4
.IX Item "chroma_swap, cs"
.IP "\fBalpha_swap, as\fR" 4
.IX Item "alpha_swap, as"
.PD
Swap luma/chroma/alpha fields. Exchange even & odd lines. Default value is \f(CW0\fR.
.SS "interlace"
.IX Subsection "interlace"
Simple interlacin filta from progressive contents, n' you can put dat on yo' toast. This interleaves upper (or
lower) lines from odd frames wit lower (or upper) lines from even frames,
halvin tha frame rate n' preservin image height.
.PP
.Vb 9
\&           Original Gangsta        Original Gangsta             New Frame
\&           Frame \*(Aqj\*(Aq      Frame \*(Aqj+1\*(Aq             (tff)
\&          ==========      ===========       ==================
\&            Line 0  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->    Frame \*(Aqj\*(Aq Line 0
\&            Line 1          Line 1  \-\-\-\->   Frame \*(Aqj+1\*(Aq Line 1
\&            Line 2 \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->    Frame \*(Aqj\*(Aq Line 2
\&            Line 3          Line 3  \-\-\-\->   Frame \*(Aqj+1\*(Aq Line 3
\&             ...             ...                   ...
\&        New Frame + 1 is ghon be generated by Frame \*(Aqj+2\*(Aq n' Frame \*(Aqj+3\*(Aq n' so on
.Ve
.PP
It accepts tha followin optionizzle parameters:
.IP "\fBscan\fR" 4
.IX Item "scan"
determines whether tha interlaced frame is taken from tha even (tff \- default)
or odd (bff) linez of tha progressive frame.
.IP "\fBlowpass\fR" 4
.IX Item "lowpass"
Enable (default) or disable tha vertical lowpass filta ta avoid twitter
interlacin n' reduce moire patterns.
.SS "kerndeint"
.IX Subsection "kerndeint"
Deinterlace input vizzle by applyin Dizzle Graftz adaptizzle kernel
deinterling. Work on interlaced partz of a vizzle ta produce
progressive frames.
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBthresh\fR" 4
.IX Item "thresh"
Set tha threshold which affects tha filterz tolerizzle when
determinin if a pixel line must be processed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it must be a integer
in tha range [0,255] n' defaults ta 10 fo' realz. A value of 0 will result in
applyin tha process on every last muthafuckin pixels.
.IP "\fBmap\fR" 4
.IX Item "map"
Paint pixels exceedin tha threshold value ta white if set ta 1.
Default is 0.
.IP "\fBorder\fR" 4
.IX Item "order"
Set tha fieldz order n' shit. Right back up in yo muthafuckin ass. Swap fieldz if set ta 1, leave fieldz ridin' solo if
0. Default is 0.
.IP "\fBsharp\fR" 4
.IX Item "sharp"
Enable additionizzle sharpenin if set ta 1. Default is 0.
.IP "\fBtwoway\fR" 4
.IX Item "twoway"
Enable twoway sharpenin if set ta 1. Default is 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply default joints:
.Sp
.Vb 1
\&        kerndeint=thresh=10:map=0:order=0:sharp=0:twoway=0
.Ve
.IP "\(bu" 4
Enable additionizzle sharpening:
.Sp
.Vb 1
\&        kerndeint=sharp=1
.Ve
.IP "\(bu" 4
Paint processed pixels up in white:
.Sp
.Vb 1
\&        kerndeint=map=1
.Ve
.SS "lut3d"
.IX Subsection "lut3d"
Apply a 3D \s-1LUT\s0 ta a input vizzle.
.PP
Da filta accepts tha followin options:
.IP "\fBfile\fR" 4
.IX Item "file"
Set tha 3D \s-1LUT\s0 file name.
.Sp
Currently supported formats:
.RS 4
.IP "\fB3dl\fR" 4
.IX Item "3dl"
AfterEffects
.IP "\fBcube\fR" 4
.IX Item "cube"
Iridas
.IP "\fBdat\fR" 4
.IX Item "dat"
DaVinci
.IP "\fBm3d\fR" 4
.IX Item "m3d"
Pandora
.RE
.RS 4
.RE
.IP "\fBinterp\fR" 4
.IX Item "interp"
Select interpolation mode.
.Sp
Available joints are:
.RS 4
.IP "\fBnearest\fR" 4
.IX Item "nearest"
Use joints from tha nearest defined point.
.IP "\fBtrilinear\fR" 4
.IX Item "trilinear"
Interpolate joints rockin tha 8 points definin a cold-ass lil cube.
.IP "\fBtetrahedral\fR" 4
.IX Item "tetrahedral"
Interpolate joints rockin a tetrahedron.
.RE
.RS 4
.RE
.SS "lut, lutrgb, lutyuv"
.IX Subsection "lut, lutrgb, lutyuv"
Compute a look-up table fo' bindin each pixel component input value
to a output value, n' apply it ta input vizzle.
.PP
\&\fIlutyuv\fR applies a lookup table ta a \s-1YUV\s0 input vizzle, \fIlutrgb\fR
to a \s-1RGB\s0 input vizzle.
.PP
These filtas accept tha followin options:
.IP "\fBc0\fR" 4
.IX Item "c0"
set first pixel component expression
.IP "\fBc1\fR" 4
.IX Item "c1"
set second pixel component expression
.IP "\fBc2\fR" 4
.IX Item "c2"
set third pixel component expression
.IP "\fBc3\fR" 4
.IX Item "c3"
set fourth pixel component expression, correspondz ta tha alpha component
.IP "\fBr\fR" 4
.IX Item "r"
set red component expression
.IP "\fBg\fR" 4
.IX Item "g"
set chronic component expression
.IP "\fBb\fR" 4
.IX Item "b"
set blue component expression
.IP "\fBa\fR" 4
.IX Item "a"
alpha component expression
.IP "\fBy\fR" 4
.IX Item "y"
set Y/luminizzle component expression
.IP "\fBu\fR" 4
.IX Item "u"
set U/Cb component expression
.IP "\fBv\fR" 4
.IX Item "v"
set V/Cr component expression
.PP
Each of dem specifies tha expression ta use fo' computin tha lookup table for
the correspondin pixel component joints.
.PP
Da exact component associated ta each of tha \fIc*\fR options dependz on the
format up in input.
.PP
Da \fIlut\fR filta requires either \s-1YUV\s0 or \s-1RGB\s0 pixel formats up in input,
\&\fIlutrgb\fR requires \s-1RGB\s0 pixel formats up in input, n' \fIlutyuv\fR requires \s-1YUV.\s0
.PP
Da expressions can contain tha followin constants n' functions:
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
the input width n' height
.IP "\fBval\fR" 4
.IX Item "val"
input value fo' tha pixel component
.IP "\fBclipval\fR" 4
.IX Item "clipval"
the input value clipped up in tha \fIminval\fR\-\fImaxval\fR range
.IP "\fBmaxval\fR" 4
.IX Item "maxval"
maximum value fo' tha pixel component
.IP "\fBminval\fR" 4
.IX Item "minval"
minimum value fo' tha pixel component
.IP "\fBnegval\fR" 4
.IX Item "negval"
the negated value fo' tha pixel component value clipped up in the
\&\fIminval\fR\-\fImaxval\fR range , it correspondz ta tha expression
\&\*(L"maxval\-clipval+minval\*(R"
.IP "\fBclip(val)\fR" 4
.IX Item "clip(val)"
the computed value up in \fIval\fR clipped up in the
\&\fIminval\fR\-\fImaxval\fR range
.IP "\fBgammaval(gamma)\fR" 4
.IX Item "gammaval(gamma)"
the computed gamma erection value of tha pixel component value
clipped up in tha \fIminval\fR\-\fImaxval\fR range, correspondz ta the
expression
"pow((clipval\-minval)/(maxval\-minval)\e,\fIgamma\fR)*(maxval\-minval)+minval"
.PP
All expressions default ta \*(L"val\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Negate input vizzle:
.Sp
.Vb 2
\&        lutrgb="r=maxval+minval\-val:g=maxval+minval\-val:b=maxval+minval\-val"
\&        lutyuv="y=maxval+minval\-val:u=maxval+minval\-val:v=maxval+minval\-val"
.Ve
.Sp
Da above is tha same ol' dirty as:
.Sp
.Vb 2
\&        lutrgb="r=negval:g=negval:b=negval"
\&        lutyuv="y=negval:u=negval:v=negval"
.Ve
.IP "\(bu" 4
Negate luminance:
.Sp
.Vb 1
\&        lutyuv=y=negval
.Ve
.IP "\(bu" 4
Remove chroma components, turns tha vizzle tha fuck into a graytone image:
.Sp
.Vb 1
\&        lutyuv="u=128:v=128"
.Ve
.IP "\(bu" 4
Apply a luma burnin effect:
.Sp
.Vb 1
\&        lutyuv="y=2*val"
.Ve
.IP "\(bu" 4
Remove chronic n' blue components:
.Sp
.Vb 1
\&        lutrgb="g=0:b=0"
.Ve
.IP "\(bu" 4
Set a cold-ass lil constant alpha channel value on input:
.Sp
.Vb 1
\&        format=rgba,lutrgb=a="maxval\-minval/2"
.Ve
.IP "\(bu" 4
Correct luminizzle gamma by a 0.5 factor:
.Sp
.Vb 1
\&        lutyuv=y=gammaval(0.5)
.Ve
.IP "\(bu" 4
Discard least dope bitz of luma:
.Sp
.Vb 1
\&        lutyuv=y=\*(Aqbitand(val, 128+64+32)\*(Aq
.Ve
.SS "mergeplanes"
.IX Subsection "mergeplanes"
Merge color channel components from nuff muthafuckin vizzle streams.
.PP
Da filta accepts up ta 4 input streams, n' merge selected input
planes ta tha output vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBmapping\fR" 4
.IX Item "mapping"
Set input ta output plane mapping. Default is \f(CW0\fR.
.Sp
Da mappings is specified as a funky-ass bitmap. Well shiiiit, it should be specified as a
hexadecimal number up in tha form 0xAa[Bb[Cc[Dd]]]. 'Aa' raps bout the
mappin fo' tha straight-up original gangsta plane of tha output stream. 'A' sets tha number of
the input stream ta use (from 0 ta 3), n' 'a' tha plane number of the
correspondin input ta use (from 0 ta 3). Da rest of tha mappings is
similar, 'Bb' raps bout tha mappin fo' tha output stream second
plane, 'Cc' raps bout tha mappin fo' tha output stream third plane and
\&'Dd' raps bout tha mappin fo' tha output stream fourth plane.
.IP "\fBformat\fR" 4
.IX Item "format"
Set output pixel format. Default is \f(CW\*(C`yuva444p\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Merge three gray vizzle streamz of same width n' height tha fuck into single vizzle stream:
.Sp
.Vb 1
\&        [a0][a1][a2]mergeplanes=0x001020:yuv444p
.Ve
.IP "\(bu" 4
Merge 1st yuv444p stream n' 2nd gray vizzle stream tha fuck into yuva444p vizzle stream:
.Sp
.Vb 1
\&        [a0][a1]mergeplanes=0x00010210:yuva444p
.Ve
.IP "\(bu" 4
Swap Y n' A plane up in yuva444p stream:
.Sp
.Vb 1
\&        format=yuva444p,mergeplanes=0x03010200:yuva444p
.Ve
.IP "\(bu" 4
Swap U n' V plane up in yuv420p stream:
.Sp
.Vb 1
\&        format=yuv420p,mergeplanes=0x000201:yuv420p
.Ve
.IP "\(bu" 4
Cast a rgb24 clip ta yuv444p:
.Sp
.Vb 1
\&        format=rgb24,mergeplanes=0x000102:yuv444p
.Ve
.SS "mcdeint"
.IX Subsection "mcdeint"
Apply motion-compensation deinterlacing.
.PP
It needz one field per frame as input n' must thus be used together
with yadif=1/3 or equivalent.
.PP
This filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Set tha deinterlacin mode.
.Sp
It accepts one of tha followin joints:
.RS 4
.IP "\fBfast\fR" 4
.IX Item "fast"
.PD 0
.IP "\fBmedium\fR" 4
.IX Item "medium"
.IP "\fBslow\fR" 4
.IX Item "slow"
.PD
use iteratizzle motion estimation
.IP "\fBextra_slow\fR" 4
.IX Item "extra_slow"
like \fBslow\fR yo, but use multiple reference frames.
.RE
.RS 4
.Sp
Default value is \fBfast\fR.
.RE
.IP "\fBparity\fR" 4
.IX Item "parity"
Set tha picture field paritizzle assumed fo' tha input vizzle. Well shiiiit, it must be
one of tha followin joints:
.RS 4
.IP "\fB0, tff\fR" 4
.IX Item "0, tff"
assume top field first
.IP "\fB1, bff\fR" 4
.IX Item "1, bff"
assume bottom field first
.RE
.RS 4
.Sp
Default value is \fBbff\fR.
.RE
.IP "\fBqp\fR" 4
.IX Item "qp"
Set per-block quantization parameta (\s-1QP\s0) used by tha internal
encoder.
.Sp
Higher joints should result up in a smoother motion vector field but less
optimal individual vectors. Default value is 1.
.SS "mp"
.IX Subsection "mp"
Apply a MPlayer filta ta tha input vizzle.
.PP
This filta serves up a wrapper round a shitload of tha filtas of
MPlayer/MEncoder.
.PP
This wrapper is considered experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Some of tha wrapped filters
may not work properly n' we may drop support fo' them, as they will
be implemented natively tha fuck into FFmpeg. Thus you should avoid
dependin on dem when freestylin portable scripts.
.PP
Da filta accepts tha parameters:
\&\fIfilter_name\fR[:=]\fIfilter_params\fR
.PP
\&\fIfilter_name\fR is tha name of a supported MPlayer filter,
\&\fIfilter_params\fR be a strang containin tha parametas accepted by
the named filter.
.PP
Da list of tha currently supported filtas bigs up:
.IP "\fIeq2\fR" 4
.IX Item "eq2"
.PD 0
.IP "\fIeq\fR" 4
.IX Item "eq"
.IP "\fIfspp\fR" 4
.IX Item "fspp"
.IP "\fIilpack\fR" 4
.IX Item "ilpack"
.IP "\fIpp7\fR" 4
.IX Item "pp7"
.IP "\fIsoftpulldown\fR" 4
.IX Item "softpulldown"
.IP "\fIuspp\fR" 4
.IX Item "uspp"
.PD
.PP
Da parameta syntax n' behavior fo' tha listed filtas is tha same
of tha correspondin MPlayer filters. For detailed instructions check
the \*(L"\s-1VIDEO FILTERS\*(R"\s0 section up in tha MPlayer manual.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Adjust gamma, brightness, contrast:
.Sp
.Vb 1
\&        mp=eq2=1.0:2:0.5
.Ve
.PP
See also \fImplayer\fR\|(1), <\fBhttp://www.mplayerhq.hu/\fR>.
.SS "mpdecimate"
.IX Subsection "mpdecimate"
Drop frames dat do not differ pimped outly from tha previous frame in
order ta reduce frame rate.
.PP
Da main use of dis filta is fo' hella-low-bitrate encoding
(e.g. streamin over dialup modem) yo, but it could up in theory be used for
fixin pornos dat was inverse-telecined incorrectly.
.PP
A description of tha accepted options bigs up.
.IP "\fBmax\fR" 4
.IX Item "max"
Set tha maximum number of consecutizzle frames which can be dropped (if
positive), or tha minimum interval between dropped frames (if
negative). If tha value is 0, tha frame is dropped unregardin the
number of previous sequentially dropped frames.
.Sp
Default value is 0.
.IP "\fBhi\fR" 4
.IX Item "hi"
.PD 0
.IP "\fBlo\fR" 4
.IX Item "lo"
.IP "\fBfrac\fR" 4
.IX Item "frac"
.PD
Set tha droppin threshold joints.
.Sp
Values fo' \fBhi\fR n' \fBlo\fR is fo' 8x8 pixel blocks and
represent actual pixel value differences, so a threshold of 64
correspondz ta 1 unit of difference fo' each pixel, or tha same spread
out differently over tha block.
.Sp
A frame be a cold-ass lil muthafucka fo' droppin if no 8x8 blocks differ by more
than a threshold of \fBhi\fR, n' if no mo' than \fBfrac\fR blocks (1
meanin tha whole image) differ by mo' than a threshold of \fBlo\fR.
.Sp
Default value fo' \fBhi\fR is 64*12, default value fo' \fBlo\fR is
64*5, n' default value fo' \fBfrac\fR is 0.33.
.SS "negate"
.IX Subsection "negate"
Negate input vizzle.
.PP
This filta accepts a integer up in input, if non-zero it negates the
alpha component (if available). Da default value up in input is 0.
.SS "noformat"
.IX Subsection "noformat"
Force libavfilta not ta use any of tha specified pixel formats fo' the
input ta tha next filter.
.PP
This filta accepts tha followin parameters:
.IP "\fBpix_fmts\fR" 4
.IX Item "pix_fmts"
A '|'\-separated list of pixel format names, fo' example
\&\*(L"pix_fmts=yuv420p|monow|rgb24\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Force libavfilta ta bust a gangbangin' format different from \fIyuv420p\fR fo' the
input ta tha vflip filter:
.Sp
.Vb 1
\&        noformat=pix_fmts=yuv420p,vflip
.Ve
.IP "\(bu" 4
Convert tha input vizzle ta any of tha formats not contained up in tha list:
.Sp
.Vb 1
\&        noformat=yuv420p|yuv444p|yuv410p
.Ve
.SS "noise"
.IX Subsection "noise"
Add noise on vizzle input frame.
.PP
Da filta accepts tha followin options:
.IP "\fBall_seed\fR" 4
.IX Item "all_seed"
.PD 0
.IP "\fBc0_seed\fR" 4
.IX Item "c0_seed"
.IP "\fBc1_seed\fR" 4
.IX Item "c1_seed"
.IP "\fBc2_seed\fR" 4
.IX Item "c2_seed"
.IP "\fBc3_seed\fR" 4
.IX Item "c3_seed"
.PD
Set noise seed fo' specific pixel component or all pixel components up in case
of \fIall_seed\fR. Default value is \f(CW123457\fR.
.IP "\fBall_strength, alls\fR" 4
.IX Item "all_strength, alls"
.PD 0
.IP "\fBc0_strength, c0s\fR" 4
.IX Item "c0_strength, c0s"
.IP "\fBc1_strength, c1s\fR" 4
.IX Item "c1_strength, c1s"
.IP "\fBc2_strength, c2s\fR" 4
.IX Item "c2_strength, c2s"
.IP "\fBc3_strength, c3s\fR" 4
.IX Item "c3_strength, c3s"
.PD
Set noise strength fo' specific pixel component or all pixel components up in case
\&\fIall_strength\fR. Default value is \f(CW0\fR fo' realz. Allowed range is [0, 100].
.IP "\fBall_flags, allf\fR" 4
.IX Item "all_flags, allf"
.PD 0
.IP "\fBc0_flags, c0f\fR" 4
.IX Item "c0_flags, c0f"
.IP "\fBc1_flags, c1f\fR" 4
.IX Item "c1_flags, c1f"
.IP "\fBc2_flags, c2f\fR" 4
.IX Item "c2_flags, c2f"
.IP "\fBc3_flags, c3f\fR" 4
.IX Item "c3_flags, c3f"
.PD
Set pixel component flags or set flags fo' all components if \fIall_flags\fR.
Available joints fo' component flags are:
.RS 4
.IP "\fBa\fR" 4
.IX Item "a"
averaged temporal noise (smoother)
.IP "\fBp\fR" 4
.IX Item "p"
mix random noise wit a (semi)regular pattern
.IP "\fBt\fR" 4
.IX Item "t"
temporal noise (noise pattern chizzlez between frames)
.IP "\fBu\fR" 4
.IX Item "u"
uniform noise (gaussian otherwise)
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Add temporal n' uniform noise ta input vizzle:
.PP
.Vb 1
\&        noise=alls=20:allf=t+u
.Ve
.SS "null"
.IX Subsection "null"
Pass tha vizzle source unchanged ta tha output.
.SS "ocv"
.IX Subsection "ocv"
Apply vizzle transform rockin libopencv.
.PP
To enable dis filta install libopencv library n' headaz and
configure FFmpeg wit \f(CW\*(C`\-\-enable\-libopencv\*(C'\fR.
.PP
This filta accepts tha followin parameters:
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name of tha libopencv filta ta apply.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
Da parametas ta pass ta tha libopencv filter n' shit. If not specified tha default
values is assumed.
.PP
Refer ta tha straight-up legit libopencv documentation fo' mo' precise
information:
<\fBhttp://opencv.willowgarage.com/documentation/c/image_filtering.html\fR>
.PP
Follows tha list of supported libopencv filters.
.PP
\fIdilate\fR
.IX Subsection "dilate"
.PP
Dilate a image by rockin a specific structurin element.
This filta correspondz ta tha libopencv function \f(CW\*(C`cvDilate\*(C'\fR.
.PP
It accepts tha parameters: \fIstruct_el\fR|\fInb_iterations\fR.
.PP
\&\fIstruct_el\fR represents a structurin element, n' has tha syntax:
\&\fIcols\fRx\fIrows\fR+\fIanchor_x\fRx\fIanchor_y\fR/\fIshape\fR
.PP
\&\fIcols\fR n' \fIrows\fR represent tha number of columns n' rows of
the structurin element, \fIanchor_x\fR n' \fIanchor_y\fR tha anchor
point, n' \fIshape\fR tha shape fo' tha structurin element, and
can be one of tha joints \*(L"rect\*(R", \*(L"cross\*(R", \*(L"ellipse\*(R", \*(L"custom\*(R".
.PP
If tha value fo' \fIshape\fR is \*(L"custom\*(R", it must be followed by a
strin of tha form "=\fIfilename\fR". Da file wit name
\&\fIfilename\fR be assumed ta represent a funky-ass binary image, wit each
printable characta correspondin ta a funky-ass bright pixel. When a cold-ass lil custom
\&\fIshape\fR is used, \fIcols\fR n' \fIrows\fR is ignored, tha number
or columns n' rowz of tha read file is assumed instead.
.PP
Da default value fo' \fIstruct_el\fR is \*(L"3x3+0x0/rect\*(R".
.PP
\&\fInb_iterations\fR specifies tha number of times tha transform is
applied ta tha image, n' defaults ta 1.
.PP
Big up some example:
.PP
.Vb 2
\&        # use tha default joints
\&        ocv=dilate
\&        
\&        # dilate rockin a structurin element wit a 5x5 cross, iterate two times
\&        ocv=filter_name=dilate:filter_params=5x5+2x2/cross|2
\&        
\&        # read tha shape from tha file diamond.shape, iterate two times
\&        # tha file diamond.shape may contain a pattern of charactas like this:
\&        #   *
\&        #  ***
\&        # *****
\&        #  ***
\&        #   *
\&        # tha specified cols n' rows is ignored (but not tha anchor point coordinates)
\&        ocv=dilate:0x0+2x2/custom=diamond.shape|2
.Ve
.PP
\fIerode\fR
.IX Subsection "erode"
.PP
Erode a image by rockin a specific structurin element.
This filta correspondz ta tha libopencv function \f(CW\*(C`cvErode\*(C'\fR.
.PP
Da filta accepts tha parameters: \fIstruct_el\fR:\fInb_iterations\fR,
with tha same syntax n' semantics as tha dilate filter.
.PP
\fIsmooth\fR
.IX Subsection "smooth"
.PP
Smooth tha input vizzle.
.PP
Da filta takes tha followin parameters:
\&\fItype\fR|\fIparam1\fR|\fIparam2\fR|\fIparam3\fR|\fIparam4\fR.
.PP
\&\fItype\fR is tha type of smooth filta ta apply, n' can be one of
the followin joints: \*(L"blur\*(R", \*(L"blur_no_scale\*(R", \*(L"median\*(R", \*(L"gaussian\*(R",
\&\*(L"bilateral\*(R". Da default value is \*(L"gaussian\*(R".
.PP
\&\fIparam1\fR, \fIparam2\fR, \fIparam3\fR, n' \fIparam4\fR are
parametas whose meanings depend on smooth type. \fIparam1\fR and
\&\fIparam2\fR accept integer positizzle joints or 0, \fIparam3\fR and
\&\fIparam4\fR accept float joints.
.PP
Da default value fo' \fIparam1\fR is 3, tha default value fo' the
other parametas is 0.
.PP
These parametas correspond ta tha parametas assigned ta the
libopencv function \f(CW\*(C`cvSmooth\*(C'\fR.
.SS "overlay"
.IX Subsection "overlay"
Overlay one vizzle on top of another.
.PP
It takes two inputs n' one output, tha straight-up original gangsta input is tha \*(L"main\*(R"
video on which tha second input is overlayed.
.PP
This filta accepts tha followin parameters:
.PP
A description of tha accepted options bigs up.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Set tha expression fo' tha x n' y coordinatez of tha overlayed vizzle
on tha main vizzle. Default value is \*(L"0\*(R" fo' both expressions. In case
the expression is invalid, it is set ta a big-ass value (meanin dat the
overlay aint gonna be displayed within tha output visible area).
.IP "\fBeval\fR" 4
.IX Item "eval"
Set when tha expressions fo' \fBx\fR, n' \fBy\fR is evaluated.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBinit\fR" 4
.IX Item "init"
only evaluate expressions once durin tha filta initialization or
when a cold-ass lil command is processed
.IP "\fBframe\fR" 4
.IX Item "frame"
evaluate expressions fo' each incomin frame
.RE
.RS 4
.Sp
Default value is \fBframe\fR.
.RE
.IP "\fBshortest\fR" 4
.IX Item "shortest"
If set ta 1, force tha output ta terminizzle when tha shortest input
terminates. Default value is 0.
.IP "\fBformat\fR" 4
.IX Item "format"
Set tha format fo' tha output vizzle.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fByuv420\fR" 4
.IX Item "yuv420"
force \s-1YUV420\s0 output
.IP "\fByuv444\fR" 4
.IX Item "yuv444"
force \s-1YUV444\s0 output
.IP "\fBrgb\fR" 4
.IX Item "rgb"
force \s-1RGB\s0 output
.RE
.RS 4
.Sp
Default value is \fByuv420\fR.
.RE
.IP "\fBrgb\fR \fI(deprecated)\fR" 4
.IX Item "rgb (deprecated)"
If set ta 1, force tha filta ta accept inputs up in tha \s-1RGB\s0
color space. Default value is 0. This option is deprecated, use
\&\fBformat\fR instead.
.IP "\fBrepeatlast\fR" 4
.IX Item "repeatlast"
If set ta 1, force tha filta ta draw tha last overlay frame over the
main input until tha end of tha stream fo' realz. A value of 0 disablez this
behavior. Shiiit, dis aint no joke. Default value is 1.
.PP
Da \fBx\fR, n' \fBy\fR expressions can contain tha following
parameters.
.IP "\fBmain_w, W\fR" 4
.IX Item "main_w, W"
.PD 0
.IP "\fBmain_h, H\fR" 4
.IX Item "main_h, H"
.PD
main input width n' height
.IP "\fBoverlay_w, w\fR" 4
.IX Item "overlay_w, w"
.PD 0
.IP "\fBoverlay_h, h\fR" 4
.IX Item "overlay_h, h"
.PD
overlay input width n' height
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
the computed joints fo' \fIx\fR n' \fIy\fR. They is evaluated for
each freshly smoked up frame.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample jointz of tha output
format. For example fo' tha pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 and
\&\fIvsub\fR is 1.
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha input frame, \s-1NAN\s0 if unknown
.IP "\fBt\fR" 4
.IX Item "t"
timestamp expressed up in seconds, \s-1NAN\s0 if tha input timestamp is unknown
.PP
Note dat tha \fIn\fR, \fIpos\fR, \fIt\fR variablez is available only
when evaluation is done \fIper frame\fR, n' will evaluate ta \s-1NAN\s0
when \fBeval\fR is set ta \fBinit\fR.
.PP
Be aware dat frames is taken from each input vizzle up in timestamp
order, hence, if they initial timestamps differ, it aint nuthin but a phat idea
to pass tha two inputs all up in a \fIsetpts=PTS\-STARTPTS\fR filta to
have dem begin up in tha same zero timestamp, as it do tha example for
the \fImovie\fR filter.
.PP
Yo ass can chain together mo' overlays but you should test the
efficiency of such approach.
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
This filta supports tha followin commands:
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Modify tha x n' y of tha overlay input.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Draw tha overlay at 10 pixels from tha bottom right corner of tha main
video:
.Sp
.Vb 1
\&        overlay=main_w\-overlay_w\-10:main_h\-overlay_h\-10
.Ve
.Sp
Usin named options tha example above becomes:
.Sp
.Vb 1
\&        overlay=x=main_w\-overlay_w\-10:y=main_h\-overlay_h\-10
.Ve
.IP "\(bu" 4
Insert a transparent \s-1PNG\s0 logo up in tha bottom left corner of tha input,
usin tha \fBffmpeg\fR tool wit tha \f(CW\*(C`\-filter_complex\*(C'\fR option:
.Sp
.Vb 1
\&        ffmpeg \-i input \-i logo \-filter_complex \*(Aqoverlay=10:main_h\-overlay_h\-10\*(Aq output
.Ve
.IP "\(bu" 4
Insert 2 different transparent \s-1PNG\s0 logos (second logo on bottom
right corner) rockin tha \fBffmpeg\fR tool:
.Sp
.Vb 1
\&        ffmpeg \-i input \-i logo1 \-i logo2 \-filter_complex \*(Aqoverlay=x=10:y=H\-h\-10,overlay=x=W\-w\-10:y=H\-h\-10\*(Aq output
.Ve
.IP "\(bu" 4
Add a transparent color layer on top of tha main vizzle, \f(CW\*(C`WxH\*(C'\fR
must specify tha size of tha main input ta tha overlay filter:
.Sp
.Vb 1
\&        color=color=red@.3:size=WxH [over]; [in][over] overlay [out]
.Ve
.IP "\(bu" 4
Play a original gangsta vizzle n' a gangbangin' filtered version (here wit tha deshake
filter) side by side rockin tha \fBffplay\fR tool:
.Sp
.Vb 1
\&        ffplay input.avi \-vf \*(Aqsplit[a][b]; [a]pad=iw*2:ih[src]; [b]deshake[filt]; [src][filt]overlay=w\*(Aq
.Ve
.Sp
Da above command is tha same ol' dirty as:
.Sp
.Vb 1
\&        ffplay input.avi \-vf \*(Aqsplit[b], pad=iw*2[src], [b]deshake, [src]overlay=w\*(Aq
.Ve
.IP "\(bu" 4
Make a slidin overlay appearin from tha left ta tha right top part of the
screen startin since time 2:
.Sp
.Vb 1
\&        overlay=x=\*(Aqif(gte(t,2), \-w+(t\-2)*20, NAN)\*(Aq:y=0
.Ve
.IP "\(bu" 4
Compose output by puttin two input vizzlez side ta side:
.Sp
.Vb 7
\&        ffmpeg \-i left.avi \-i right.avi \-filter_complex "
\&        nullsrc=size=200x100 [background];
\&        [0:v] setpts=PTS\-STARTPTS, scale=100x100 [left];
\&        [1:v] setpts=PTS\-STARTPTS, scale=100x100 [right];
\&        [background][left]       overlay=shortest=1       [background+left];
\&        [background+left][right] overlay=shortest=1:x=100 [left+right]
\&        "
.Ve
.IP "\(bu" 4
Chain nuff muthafuckin overlays up in cascade:
.Sp
.Vb 6
\&        nullsrc=s=200x200 [bg];
\&        testsrc=s=100x100, split=4 [in0][in1][in2][in3];
\&        [in0] lutrgb=r=0, [bg]   overlay=0:0     [mid0];
\&        [in1] lutrgb=g=0, [mid0] overlay=100:0   [mid1];
\&        [in2] lutrgb=b=0, [mid1] overlay=0:100   [mid2];
\&        [in3] null,       [mid2] overlay=100:100 [out0]
.Ve
.SS "owdenoise"
.IX Subsection "owdenoise"
Apply Overcomplete Wavelet denoiser.
.PP
Da filta accepts tha followin options:
.IP "\fBdepth\fR" 4
.IX Item "depth"
Set depth.
.Sp
Larger depth joints will denoise lower frequency components mo' yo, but
slow down filtering.
.Sp
Must be a int up in tha range 8\-16, default is \f(CW8\fR.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set luma strength.
.Sp
Must be a thugged-out double value up in tha range 0\-1000, default is \f(CW1.0\fR.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set chroma strength.
.Sp
Must be a thugged-out double value up in tha range 0\-1000, default is \f(CW1.0\fR.
.SS "pad"
.IX Subsection "pad"
Add paddings ta tha input image, n' place tha original gangsta input at the
given coordinates \fIx\fR, \fIy\fR.
.PP
This filta accepts tha followin parameters:
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Specify a expression fo' tha size of tha output image wit the
paddings added. Y'all KNOW dat shit, muthafucka! If tha value fo' \fIwidth\fR or \fIheight\fR is 0, the
correspondin input size is used fo' tha output.
.Sp
Da \fIwidth\fR expression can reference tha value set by the
\&\fIheight\fR expression, n' vice versa.
.Sp
Da default value of \fIwidth\fR n' \fIheight\fR is 0.
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
Specify a expression fo' tha offsets where ta place tha input image
in tha padded area wit respect ta tha top/left border of tha output
image.
.Sp
Da \fIx\fR expression can reference tha value set by tha \fIy\fR
expression, n' vice versa.
.Sp
Da default value of \fIx\fR n' \fIy\fR is 0.
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify tha color of tha padded area. For tha syntax of dis option,
check tha \*(L"Color\*(R" section up in tha ffmpeg-utils manual.
.Sp
Da default value of \fIcolor\fR is \*(L"black\*(R".
.PP
Da value fo' tha \fIwidth\fR, \fIheight\fR, \fIx\fR, n' \fIy\fR
options is expressions containin tha followin constants:
.IP "\fBin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fBin_h\fR" 4
.IX Item "in_h"
.PD
the input vizzle width n' height
.IP "\fBiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fBih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fBout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fBout_h\fR" 4
.IX Item "out_h"
.PD
the output width n' height, dat is tha size of tha padded area as
specified by tha \fIwidth\fR n' \fIheight\fR expressions
.IP "\fBow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fBoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fBx\fR" 4
.IX Item "x"
.PD 0
.IP "\fBy\fR" 4
.IX Item "y"
.PD
x n' y offsets as specified by tha \fIx\fR n' \fIy\fR
expressions, or \s-1NAN\s0 if not yet specified
.IP "\fBa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fBsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fBdar\fR" 4
.IX Item "dar"
input display aspect ratio, it is tha same ol' dirty as (\fIiw\fR / \fIih\fR) * \fIsar\fR
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Add paddings wit color \*(L"violet\*(R" ta tha input vizzle. Output vizzle
size is 640x480, tha top-left corner of tha input vizzle is placed at
column 0, row 40:
.Sp
.Vb 1
\&        pad=640:480:0:40:violet
.Ve
.Sp
Da example above is equivalent ta tha followin command:
.Sp
.Vb 1
\&        pad=width=640:height=480:x=0:y=40:color=violet
.Ve
.IP "\(bu" 4
Pad tha input ta git a output wit dimensions increased by 3/2,
and put tha input vizzle all up in tha centa of tha padded area:
.Sp
.Vb 1
\&        pad="3/2*iw:3/2*ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Pad tha input ta git a squared output wit size equal ta tha maximum
value between tha input width n' height, n' put tha input vizzle at
the centa of tha padded area:
.Sp
.Vb 1
\&        pad="max(iw\e,ih):ow:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Pad tha input ta git a gangbangin' final w/h ratio of 16:9:
.Sp
.Vb 1
\&        pad="ih*16/9:ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
In case of anamorphic vizzle, up in order ta set tha output display aspect
correctly, it is necessary ta use \fIsar\fR up in tha expression,
accordin ta tha relation:
.Sp
.Vb 2
\&        (ih * X / ih) * sar = output_dar
\&        X = output_dar / sar
.Ve
.Sp
Thus tha previous example need ta be modified to:
.Sp
.Vb 1
\&        pad="ih*16/9/sar:ih:(ow\-iw)/2:(oh\-ih)/2"
.Ve
.IP "\(bu" 4
Double output size n' put tha input vizzle up in tha bottom-right
corner of tha output padded area:
.Sp
.Vb 1
\&        pad="2*iw:2*ih:ow\-iw:oh\-ih"
.Ve
.SS "perspective"
.IX Subsection "perspective"
Correct perspectizzle of vizzle not recorded perpendicular ta tha screen.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBx0\fR" 4
.IX Item "x0"
.PD 0
.IP "\fBy0\fR" 4
.IX Item "y0"
.IP "\fBx1\fR" 4
.IX Item "x1"
.IP "\fBy1\fR" 4
.IX Item "y1"
.IP "\fBx2\fR" 4
.IX Item "x2"
.IP "\fBy2\fR" 4
.IX Item "y2"
.IP "\fBx3\fR" 4
.IX Item "x3"
.IP "\fBy3\fR" 4
.IX Item "y3"
.PD
Set coordinates expression fo' top left, top right, bottom left n' bottom right corners.
Default joints is \f(CW\*(C`0:0:W:0:0:H:W:H\*(C'\fR wit which perspectizzle will remain unchanged.
.Sp
Da expressions can use tha followin variables:
.RS 4
.IP "\fBW\fR" 4
.IX Item "W"
.PD 0
.IP "\fBH\fR" 4
.IX Item "H"
.PD
the width n' height of vizzle frame.
.RE
.RS 4
.RE
.IP "\fBinterpolation\fR" 4
.IX Item "interpolation"
Set interpolation fo' perspectizzle erection.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlinear\fR" 4
.IX Item "linear"
.PD 0
.IP "\fBcubic\fR" 4
.IX Item "cubic"
.RE
.RS 4
.PD
.Sp
Default value is \fBlinear\fR.
.RE
.SS "phase"
.IX Subsection "phase"
Delay interlaced vizzle by one field time so dat tha field order chizzles.
.PP
Da intended use is ta fix \s-1PAL\s0 pornos dat done been captured wit the
opposite field order ta tha film-to-video transfer.
.PP
A description of tha accepted parametas bigs up.
.IP "\fBmode\fR" 4
.IX Item "mode"
Set phase mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBt\fR" 4
.IX Item "t"
Capture field order top-first, transfer bottom-first.
Filta will delay tha bottom field.
.IP "\fBb\fR" 4
.IX Item "b"
Capture field order bottom-first, transfer top-first.
Filta will delay tha top field.
.IP "\fBp\fR" 4
.IX Item "p"
Capture n' transfer wit tha same field order n' shit. This mode only exists
for tha documentation of tha other options ta refer ta yo, but if you
actually select it, tha filta will faithfully do nothing.
.IP "\fBa\fR" 4
.IX Item "a"
Capture field order determined automatically by field flags, transfer
opposite.
Filta selects among \fBt\fR n' \fBb\fR modes on a gangbangin' frame by frame
basis rockin field flags. If no field shiznit be available,
then dis works just like \fBu\fR.
.IP "\fBu\fR" 4
.IX Item "u"
Capture unknown or varying, transfer opposite.
Filta selects among \fBt\fR n' \fBb\fR on a gangbangin' frame by frame basis by
analyzin tha images n' selectin tha alternatizzle dat produces best
match between tha fields.
.IP "\fBT\fR" 4
.IX Item "T"
Capture top-first, transfer unknown or varying.
Filta selects among \fBt\fR n' \fBp\fR rockin image analysis.
.IP "\fBB\fR" 4
.IX Item "B"
Capture bottom-first, transfer unknown or varying.
Filta selects among \fBb\fR n' \fBp\fR rockin image analysis.
.IP "\fBA\fR" 4
.IX Item "A"
Capture determined by field flags, transfer unknown or varying.
Filta selects among \fBt\fR, \fBb\fR n' \fBp\fR rockin field flags and
image analysis. If no field shiznit be available, then dis works just
like \fBU\fR. This is tha default mode.
.IP "\fBU\fR" 4
.IX Item "U"
Both capture n' transfer unknown or varying.
Filta selects among \fBt\fR, \fBb\fR n' \fBp\fR rockin image analysis only.
.RE
.RS 4
.RE
.SS "pixdesctest"
.IX Subsection "pixdesctest"
Pixel format descriptor test filter, mainly useful fo' internal
testing. Da output vizzle should be equal ta tha input vizzle.
.PP
For example:
.PP
.Vb 1
\&        format=monow, pixdesctest
.Ve
.PP
can be used ta test tha monowhite pixel format descriptor definition.
.SS "pp"
.IX Subsection "pp"
Enable tha specified chain of postprocessin subfiltas rockin libpostproc. This
library should be automatically selected wit a \s-1GPL\s0 build (\f(CW\*(C`\-\-enable\-gpl\*(C'\fR).
Subfiltas must be separated by '/' n' can be disabled by prependin a '\-'.
Each subfilta n' some options gotz a gangbangin' finger-lickin' dirty-ass short n' a long-ass name dat can be used
interchangeably, i.e. dr/derin is tha same.
.PP
Da filtas accept tha followin options:
.IP "\fBsubfilters\fR" 4
.IX Item "subfilters"
Set postprocessin subfiltas string.
.PP
All subfiltas share common options ta determine they scope:
.IP "\fBa/autoq\fR" 4
.IX Item "a/autoq"
Honor tha qualitizzle commandz fo' dis subfilter.
.IP "\fBc/chrom\fR" 4
.IX Item "c/chrom"
Do chrominizzle filtering, too (default).
.IP "\fBy/nochrom\fR" 4
.IX Item "y/nochrom"
Do luminizzle filterin only (no chrominance).
.IP "\fBn/noluma\fR" 4
.IX Item "n/noluma"
Do chrominizzle filterin only (no luminance).
.PP
These options can be appended afta tha subfilta name, separated by a '|'.
.PP
Available subfiltas are:
.IP "\fBhb/hdeblock[|difference[|flatness]]\fR" 4
.IX Item "hb/hdeblock[|difference[|flatness]]"
Horizontal deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBvb/vdeblock[|difference[|flatness]]\fR" 4
.IX Item "vb/vdeblock[|difference[|flatness]]"
Vertical deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBha/hadeblock[|difference[|flatness]]\fR" 4
.IX Item "ha/hadeblock[|difference[|flatness]]"
Accurate horizontal deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.IP "\fBva/vadeblock[|difference[|flatness]]\fR" 4
.IX Item "va/vadeblock[|difference[|flatness]]"
Accurate vertical deblockin filter
.RS 4
.IP "\fBdifference\fR" 4
.IX Item "difference"
Difference factor where higher joints mean mo' deblockin (default: \f(CW32\fR).
.IP "\fBflatness\fR" 4
.IX Item "flatness"
Flatnizz threshold where lower joints mean mo' deblockin (default: \f(CW39\fR).
.RE
.RS 4
.RE
.PP
Da horizontal n' vertical deblockin filtas share tha difference and
flatnizz joints so you cannot set different horizontal n' vertical
thresholds.
.IP "\fBh1/x1hdeblock\fR" 4
.IX Item "h1/x1hdeblock"
Experimenstrual horizontal deblockin filter
.IP "\fBv1/x1vdeblock\fR" 4
.IX Item "v1/x1vdeblock"
Experimenstrual vertical deblockin filter
.IP "\fBdr/dering\fR" 4
.IX Item "dr/dering"
Deringin filter
.IP "\fBtn/tmpnoise[|threshold1[|threshold2[|threshold3]]], temporal noise reducer\fR" 4
.IX Item "tn/tmpnoise[|threshold1[|threshold2[|threshold3]]], temporal noise reducer"
.RS 4
.PD 0
.IP "\fBthreshold1\fR" 4
.IX Item "threshold1"
.PD
larger \-> stronger filtering
.IP "\fBthreshold2\fR" 4
.IX Item "threshold2"
larger \-> stronger filtering
.IP "\fBthreshold3\fR" 4
.IX Item "threshold3"
larger \-> stronger filtering
.RE
.RS 4
.RE
.IP "\fBal/autolevels[:f/fullyrange], automatic brightnizz / contrast erection\fR" 4
.IX Item "al/autolevels[:f/fullyrange], automatic brightnizz / contrast erection"
.RS 4
.PD 0
.IP "\fBf/fullyrange\fR" 4
.IX Item "f/fullyrange"
.PD
Stretch luminizzle ta \f(CW\*(C`0\-255\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fBlb/linblenddeint\fR" 4
.IX Item "lb/linblenddeint"
Linear blend deinterlacin filta dat deinterlaces tha given block by
filterin all lines wit a \f(CW\*(C`(1 2 1)\*(C'\fR filter.
.IP "\fBli/linipoldeint\fR" 4
.IX Item "li/linipoldeint"
Linear interpolatin deinterlacin filta dat deinterlaces tha given block by
linearly interpolatin every last muthafuckin second line.
.IP "\fBci/cubicipoldeint\fR" 4
.IX Item "ci/cubicipoldeint"
Cubic interpolatin deinterlacin filta deinterlaces tha given block by
cubically interpolatin every last muthafuckin second line.
.IP "\fBmd/mediandeint\fR" 4
.IX Item "md/mediandeint"
Median deinterlacin filta dat deinterlaces tha given block by applyin a
median filta ta every last muthafuckin second line.
.IP "\fBfd/ffmpegdeint\fR" 4
.IX Item "fd/ffmpegdeint"
FFmpeg deinterlacin filta dat deinterlaces tha given block by filterin every
second line wit a \f(CW\*(C`(\-1 4 2 4 \-1)\*(C'\fR filter.
.IP "\fBl5/lowpass5\fR" 4
.IX Item "l5/lowpass5"
Vertically applied \s-1FIR\s0 lowpass deinterlacin filta dat deinterlaces tha given
block by filterin all lines wit a \f(CW\*(C`(\-1 2 6 2 \-1)\*(C'\fR filter.
.IP "\fBfq/forceQuant[|quantizer]\fR" 4
.IX Item "fq/forceQuant[|quantizer]"
Overrides tha quantizer table from tha input wit tha constant quantizer you
specify.
.RS 4
.IP "\fBquantizer\fR" 4
.IX Item "quantizer"
Quantizer ta use
.RE
.RS 4
.RE
.IP "\fBde/default\fR" 4
.IX Item "de/default"
Default pp filta combination (\f(CW\*(C`hb|a,vb|a,dr|a\*(C'\fR)
.IP "\fBfa/fast\fR" 4
.IX Item "fa/fast"
Fast pp filta combination (\f(CW\*(C`h1|a,v1|a,dr|a\*(C'\fR)
.IP "\fBac\fR" 4
.IX Item "ac"
High qualitizzle pp filta combination (\f(CW\*(C`ha|a|128|7,va|a,dr|a\*(C'\fR)
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply horizontal n' vertical deblocking, deringin n' automatic
brightness/contrast:
.Sp
.Vb 1
\&        pp=hb/vb/dr/al
.Ve
.IP "\(bu" 4
Apply default filtas without brightness/contrast erection:
.Sp
.Vb 1
\&        pp=de/\-al
.Ve
.IP "\(bu" 4
Apply default filtas n' temporal denoiser:
.Sp
.Vb 1
\&        pp=default/tmpnoise|1|2|3
.Ve
.IP "\(bu" 4
Apply deblockin on luminizzle only, n' switch vertical deblockin on or off
automatically dependin on available \s-1CPU\s0 time:
.Sp
.Vb 1
\&        pp=hb|y/vb|a
.Ve
.SS "psnr"
.IX Subsection "psnr"
Obtain tha average, maximum n' minimum \s-1PSNR \s0(Peak Signal ta Noise
Ratio) between two input vizzles.
.PP
This filta takes up in input two input vizzles, tha straight-up original gangsta input is
considered tha \*(L"main\*(R" source n' is passed unchanged ta the
output. Da second input is used as a \*(L"reference\*(R" vizzle fo' computing
the \s-1PSNR.\s0
.PP
Both vizzle inputs must have tha same resolution n' pixel format for
this filta ta work erectly fo' realz. Also it assumes dat both inputs
have tha same number of frames, which is compared one by one.
.PP
Da obtained average \s-1PSNR\s0 is printed all up in tha loggin system.
.PP
Da filta stores tha accumulated \s-1MSE \s0(mean squared error) of each
frame, n' all up in tha end of tha processin it be averaged across all frames
equally, n' tha followin formula be applied ta obtain tha \s-1PSNR:\s0
.PP
.Vb 1
\&        PSNR = 10*log10(MAX^2/MSE)
.Ve
.PP
Where \s-1MAX\s0 is tha average of tha maximum jointz of each component of the
image.
.PP
Da description of tha accepted parametas bigs up.
.IP "\fBstats_file, f\fR" 4
.IX Item "stats_file, f"
If specified tha filta will use tha named file ta save tha \s-1PSNR\s0 of
each individual frame.
.PP
Da file printed if \fIstats_file\fR is selected, gotz nuff a sequence of
key/value pairz of tha form \fIkey\fR:\fIvalue\fR fo' each compared
couple frames.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 1
.IP "\fBmse_avg\fR" 4
.IX Item "mse_avg"
Mean Square Error pixel-by-pixel average difference of tha compared
frames, averaged over all tha image components.
.IP "\fBmse_y, mse_u, mse_v, mse_r, mse_g, mse_g, mse_a\fR" 4
.IX Item "mse_y, mse_u, mse_v, mse_r, mse_g, mse_g, mse_a"
Mean Square Error pixel-by-pixel average difference of tha compared
frames fo' tha component specified by tha suffix.
.IP "\fBpsnr_y, psnr_u, psnr_v, psnr_r, psnr_g, psnr_b, psnr_a\fR" 4
.IX Item "psnr_y, psnr_u, psnr_v, psnr_r, psnr_g, psnr_b, psnr_a"
Peak Signal ta Noise ratio of tha compared frames fo' tha component
specified by tha suffix.
.PP
For example:
.PP
.Vb 2
\&        porno=ref_movie.mpg, setpts=PTS\-STARTPTS [main];
\&        [main][ref] psnr="stats_file=stats.log" [out]
.Ve
.PP
On dis example tha input file bein processed is compared wit the
reference file \fIref_movie.mpg\fR. Da \s-1PSNR\s0 of each individual frame
is stored up in \fIstats.log\fR.
.SS "pullup"
.IX Subsection "pullup"
Pulldown reversal (inverse telecine) filter, capable of handlin mixed
hard-telecine, 24000/1001 fps progressive, n' 30000/1001 fps progressive
content.
.PP
Da pullup filta is designed ta take advantage of future context up in making
its decisions. This filta is stateless up in tha sense dat it do not lock
onto a pattern ta follow yo, but it instead looks forward ta tha following
fieldz up in order ta identify matches n' rebuild progressive frames.
.PP
To produce content wit a even framerate, bang tha fps filta after
pullup, use \f(CW\*(C`fps=24000/1001\*(C'\fR if tha input frame rate is 29.97fps,
\&\f(CW\*(C`fps=24\*(C'\fR fo' 30fps n' tha (rare) telecined 25fps input.
.PP
Da filta accepts tha followin options:
.IP "\fBjl\fR" 4
.IX Item "jl"
.PD 0
.IP "\fBjr\fR" 4
.IX Item "jr"
.IP "\fBjt\fR" 4
.IX Item "jt"
.IP "\fBjb\fR" 4
.IX Item "jb"
.PD
These options set tha amount of \*(L"junk\*(R" ta ignore all up in tha left, right, top, and
bottom of tha image, respectively. Left n' right is up in unitz of 8 pixels,
while top n' bottom is up in unitz of 2 lines.
Da default is 8 pixels on each side.
.IP "\fBsb\fR" 4
.IX Item "sb"
Set tha strict breaks. Right back up in yo muthafuckin ass. Settin dis option ta 1 will reduce tha chances of
filta generatin a occasionizzle mismatched frame yo, but it may also cause an
excessive number of frames ta be dropped durin high motion sequences.
Conversely, settin it ta \-1 will make filta match fieldz mo' doggystyle.
This may help processin of vizzle where there is slight blurrin between
the fieldz yo, but may also cause there ta be interlaced frames up in tha output.
Default value is \f(CW0\fR.
.IP "\fBmp\fR" 4
.IX Item "mp"
Set tha metric plane ta use. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fBl\fR" 4
.IX Item "l"
Use luma plane.
.IP "\fBu\fR" 4
.IX Item "u"
Use chroma blue plane.
.IP "\fBv\fR" 4
.IX Item "v"
Use chroma red plane.
.RE
.RS 4
.Sp
This option may be set ta use chroma plane instead of tha default luma plane
for bustin filterz computations. This may improve accuracy on straight-up clean
source material yo, but mo' likely will decrease accuracy, especially if there
is chroma noise (rainbow effect) or any grayscale vizzle.
Da main purpose of settin \fBmp\fR ta a cold-ass lil chroma plane is ta reduce \s-1CPU\s0
load n' make pullup usable up in realtime on slow machines.
.RE
.PP
For dopest thangs up in dis biatch (without duplicated frames up in tha output file) it is
necessary ta chizzle tha output frame rate. For example, ta inverse
telecine \s-1NTSC\s0 input:
.PP
.Vb 1
\&        ffmpeg \-i input \-vf pullup \-r 24000/1001 ...
.Ve
.SS "removelogo"
.IX Subsection "removelogo"
Suppress a \s-1TV\s0 station logo, rockin a image file ta determine which
pixels comprise tha logo. Well shiiiit, it works by fillin up in tha pixels that
comprise tha logo wit neighborin pixels.
.PP
Da filta accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filta bitmap file, which can be any image format supported by
libavformat. Da width n' height of tha image file must match dem of the
video stream bein processed.
.PP
Pixels up in tha provided bitmap image wit a value of zero is not
considered part of tha logo, non-zero pixels is considered part of
the logo. If you use white (255) fo' tha logo n' black (0) fo' the
rest, yo big-ass booty is ghon be safe. For makin tha filta bitmap, it is
recommended ta take a screen capture of a funky-ass black frame wit tha logo
visible, n' then rockin a threshold filta followed by tha erode
filta once or twice.
.PP
If needed, lil splotches can be fixed manually. Remember dat if
logo pixels is not covered, tha filta qualitizzle is ghon be much
reduced. Y'all KNOW dat shit, muthafucka! Markin too nuff pixels as part of tha logo do not hurt as
much yo, but it will increase tha amount of blurrin needed ta cover over
the image n' will destroy mo' shiznit than necessary, n' extra
pixels will slow thangs down on a big-ass logo.
.SS "rotate"
.IX Subsection "rotate"
Rotate vizzle by a arbitrary angle expressed up in radians.
.PP
Da filta accepts tha followin options:
.PP
A description of tha optionizzle parametas bigs up.
.IP "\fBangle, a\fR" 4
.IX Item "angle, a"
Set a expression fo' tha angle by which ta rotate tha input vizzle
clockwise, expressed as a fuckin shitload of radians fo' realz. A wack value will
result up in a cold-ass lil counter-clockwise rotation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \*(L"0\*(R".
.Sp
This expression is evaluated fo' each frame.
.IP "\fBout_w, ow\fR" 4
.IX Item "out_w, ow"
Set tha output width expression, default value is \*(L"iw\*(R".
This expression is evaluated just once durin configuration.
.IP "\fBout_h, oh\fR" 4
.IX Item "out_h, oh"
Set tha output height expression, default value is \*(L"ih\*(R".
This expression is evaluated just once durin configuration.
.IP "\fBbilinear\fR" 4
.IX Item "bilinear"
Enable bilinear interpolation if set ta 1, a value of 0 disables
it. Default value is 1.
.IP "\fBfillcolor, c\fR" 4
.IX Item "fillcolor, c"
Set tha color used ta fill tha output area not covered by tha rotated
image. For tha generalsyntax of dis option, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha special value \*(L"none\*(R" is selected then no
background is printed (useful fo' example if tha background is never shown).
.Sp
Default value is \*(L"black\*(R".
.PP
Da expressions fo' tha angle n' tha output size can contain the
followin constants n' functions:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0. Well shiiiit, it be always \s-1NAN\s0
before tha straight-up original gangsta frame is filtered.
.IP "\fBt\fR" 4
.IX Item "t"
time up in secondz of tha input frame, it is set ta 0 when tha filta is
configured. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be always \s-1NAN\s0 before tha straight-up original gangsta frame is filtered.
.IP "\fBhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fBvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.IP "\fBin_w, iw\fR" 4
.IX Item "in_w, iw"
.PD 0
.IP "\fBin_h, ih\fR" 4
.IX Item "in_h, ih"
.PD
the input vizzle width n' heigth
.IP "\fBout_w, ow\fR" 4
.IX Item "out_w, ow"
.PD 0
.IP "\fBout_h, oh\fR" 4
.IX Item "out_h, oh"
.PD
the output width n' heigth, dat is tha size of tha padded area as
specified by tha \fIwidth\fR n' \fIheight\fR expressions
.IP "\fBrotw(a)\fR" 4
.IX Item "rotw(a)"
.PD 0
.IP "\fBroth(a)\fR" 4
.IX Item "roth(a)"
.PD
the minimal width/height required fo' straight-up containin tha input
video rotated by \fIa\fR radians.
.Sp
These is only available when computin tha \fBout_w\fR and
\&\fBout_h\fR expressions.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Rotate tha input by \s-1PI/6\s0 radians clockwise:
.Sp
.Vb 1
\&        rotate=PI/6
.Ve
.IP "\(bu" 4
Rotate tha input by \s-1PI/6\s0 radians counter-clockwise:
.Sp
.Vb 1
\&        rotate=\-PI/6
.Ve
.IP "\(bu" 4
Apply a cold-ass lil constant rotation wit period T, startin from a angle of \s-1PI/3:\s0
.Sp
.Vb 1
\&        rotate=PI/3+2*PI*t/T
.Ve
.IP "\(bu" 4
Make tha input vizzle rotation oscillatin wit a period of T
secondz n' a amplitude of A radians:
.Sp
.Vb 1
\&        rotate=A*sin(2*PI/T*t)
.Ve
.IP "\(bu" 4
Rotate tha vizzle, output size is chizzlen so dat tha whole rotating
input vizzle be always straight-up contained up in tha output:
.Sp
.Vb 1
\&        rotate=\*(Aq2*PI*t:ow=hypot(iw,ih):oh=ow\*(Aq
.Ve
.IP "\(bu" 4
Rotate tha vizzle, reduce tha output size so dat no background is ever
shown:
.Sp
.Vb 1
\&        rotate=2*PI*t:ow=\*(Aqmin(iw,ih)/sqrt(2)\*(Aq:oh=ow:c=none
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
Da filta supports tha followin commands:
.IP "\fBa, angle\fR" 4
.IX Item "a, angle"
Set tha angle expression.
Da command accepts tha same ol' dirty syntax of tha correspondin option.
.Sp
If tha specified expression aint valid, it is kept at its current
value.
.SS "sab"
.IX Subsection "sab"
Apply Shape Adaptizzle Blur.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
Set luma blur filta strength, must be a value up in range 0.1\-4.0, default
value is 1.0 fo' realz. A pimped outa value will result up in a mo' blurred image, and
in slower processing.
.IP "\fBluma_pre_filter_radius, lpfr\fR" 4
.IX Item "luma_pre_filter_radius, lpfr"
Set luma pre-filta radius, must be a value up in tha 0.1\-2.0 range, default
value is 1.0.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set luma maximum difference between pixels ta still be considered, must
be a value up in tha 0.1\-100.0 range, default value is 1.0.
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
Set chroma blur filta strength, must be a value up in range 0.1\-4.0 fo' realz. A
greata value will result up in a mo' blurred image, n' up in slower
processing.
.IP "\fBchroma_pre_filter_radius, cpfr\fR" 4
.IX Item "chroma_pre_filter_radius, cpfr"
Set chroma pre-filta radius, must be a value up in tha 0.1\-2.0 range.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set chroma maximum difference between pixels ta still be considered,
must be a value up in tha 0.1\-100.0 range.
.PP
Each chroma option value, if not explicitly specified, is set ta the
correspondin luma option value.
.SS "scale"
.IX Subsection "scale"
Scale (resize) tha input vizzle, rockin tha libswscale library.
.PP
Da scale filta forces tha output display aspect ratio ta be tha same
of tha input, by changin tha output sample aspect ratio.
.PP
If tha input image format is different from tha format axed by
the next filter, tha scale filta will convert tha input ta the
axed format.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
Da filta accepts tha followin options, or any of tha options
supported by tha libswscale scaler.
.PP
See tha ffmpeg-scala manual for
the complete list of scala options.
.IP "\fBwidth, w\fR" 4
.IX Item "width, w"
.PD 0
.IP "\fBheight, h\fR" 4
.IX Item "height, h"
.PD
Set tha output vizzle dimension expression. I aint talkin' bout chicken n' gravy biatch. Default value is tha input
dimension.
.Sp
If tha value is 0, tha input width is used fo' tha output.
.Sp
If one of tha joints is \-1, tha scale filta will bust a value that
maintains tha aspect ratio of tha input image, calculated from the
other specified dimension. I aint talkin' bout chicken n' gravy biatch. If both of dem is \-1, tha input size is
used
.Sp
See below fo' tha list of accepted constants fo' use up in tha dimension
expression.
.IP "\fBinterl\fR" 4
.IX Item "interl"
Set tha interlacin mode. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Force interlaced aware scaling.
.IP "\fB0\fR" 4
.IX Item "0"
Do not apply interlaced scaling.
.IP "\fB\-1\fR" 4
.IX Item "-1"
Select interlaced aware scalin dependin on whether tha source frames
are flagged as interlaced or not.
.RE
.RS 4
.Sp
Default value is \fB0\fR.
.RE
.IP "\fBflags\fR" 4
.IX Item "flags"
Set libswscale scalin flags. Right back up in yo muthafuckin ass. See
the ffmpeg-scala manual fo' the
complete list of joints, n' you can put dat on yo' toast. If not explictly specified tha filta applies
the default flags.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha vizzle size. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual.
.IP "\fBin_color_matrix\fR" 4
.IX Item "in_color_matrix"
.PD 0
.IP "\fBout_color_matrix\fR" 4
.IX Item "out_color_matrix"
.PD
Set in/output YCbCr color space type.
.Sp
This allows tha autodetected value ta be overridden as well as allows forcing
a specific value used fo' tha output n' encoder.
.Sp
If not specified, tha color space type dependz on tha pixel format.
.Sp
Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Choose automatically.
.IP "\fBbt709\fR" 4
.IX Item "bt709"
Format conformin ta Internationistic Telecommunication Union (\s-1ITU\s0)
Recommendation \s-1BT.709.\s0
.IP "\fBfcc\fR" 4
.IX Item "fcc"
Set color space conformin ta tha United Hoodz Federal Communications
Commission (\s-1FCC\s0) Code of Federal Regulations (\s-1CFR\s0) Title 47 (2003) 73.682 (a).
.IP "\fBbt601\fR" 4
.IX Item "bt601"
Set color space conformin to:
.RS 4
.IP "\(bu" 4
\&\s-1ITU\s0 Radiocommunication Sector (ITU-R) Recommendation \s-1BT.601\s0
.IP "\(bu" 4
ITU-R Rec. \s-1BT.470\-6 \s0(1998) Systems B, B1, n' G
.IP "\(bu" 4
Posse of Motion Picture n' Televizzle Engineers (\s-1SMPTE\s0) \s-1ST 170:2004\s0
.RE
.RS 4
.RE
.IP "\fBsmpte240m\fR" 4
.IX Item "smpte240m"
Set color space conformin ta \s-1SMPTE ST 240:1999.\s0
.RE
.RS 4
.RE
.IP "\fBin_range\fR" 4
.IX Item "in_range"
.PD 0
.IP "\fBout_range\fR" 4
.IX Item "out_range"
.PD
Set in/output YCbCr sample range.
.Sp
This allows tha autodetected value ta be overridden as well as allows forcing
a specific value used fo' tha output n' encoder n' shit. If not specified, the
range dependz on tha pixel format. Possible joints:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Choose automatically.
.IP "\fBjpeg/full/pc\fR" 4
.IX Item "jpeg/full/pc"
Set full range (0\-255 up in case of 8\-bit luma).
.IP "\fBmpeg/tv\fR" 4
.IX Item "mpeg/tv"
Set \*(L"\s-1MPEG\*(R"\s0 range (16\-235 up in case of 8\-bit luma).
.RE
.RS 4
.RE
.IP "\fBforce_original_aspect_ratio\fR" 4
.IX Item "force_original_aspect_ratio"
Enable decreasin or increasin output vizzle width or height if necessary to
keep tha original gangsta aspect ratio. Possible joints:
.RS 4
.IP "\fBdisable\fR" 4
.IX Item "disable"
Scale tha vizzle as specified n' disable dis feature.
.IP "\fBdecrease\fR" 4
.IX Item "decrease"
Da output vizzle dimensions will automatically be decreased if needed.
.IP "\fBincrease\fR" 4
.IX Item "increase"
Da output vizzle dimensions will automatically be increased if needed.
.RE
.RS 4
.Sp
One useful instizzle of dis option is dat when you know a specific device's
maximum allowed resolution, you can use dis ta limit tha output vizzle to
that, while retainin tha aspect ratio. For example, thang A allows
1280x720 playback, n' yo' vizzle is 1920x800. Usin dis option (set it to
decrease) n' specifyin 1280x720 ta tha command line make tha output
1280x533.
.Sp
Please note dat dis be a gangbangin' finger-lickin' different thang than specifyin \-1 fo' \fBw\fR
or \fBh\fR, you still need ta specify tha output resolution fo' dis option
to work.
.RE
.PP
Da jointz of tha \fBw\fR n' \fBh\fR options is expressions
containin tha followin constants:
.IP "\fIin_w\fR" 4
.IX Item "in_w"
.PD 0
.IP "\fIin_h\fR" 4
.IX Item "in_h"
.PD
the input width n' height
.IP "\fIiw\fR" 4
.IX Item "iw"
.PD 0
.IP "\fIih\fR" 4
.IX Item "ih"
.PD
same as \fIin_w\fR n' \fIin_h\fR
.IP "\fIout_w\fR" 4
.IX Item "out_w"
.PD 0
.IP "\fIout_h\fR" 4
.IX Item "out_h"
.PD
the output (scaled) width n' height
.IP "\fIow\fR" 4
.IX Item "ow"
.PD 0
.IP "\fIoh\fR" 4
.IX Item "oh"
.PD
same as \fIout_w\fR n' \fIout_h\fR
.IP "\fIa\fR" 4
.IX Item "a"
same as \fIiw\fR / \fIih\fR
.IP "\fIsar\fR" 4
.IX Item "sar"
input sample aspect ratio
.IP "\fIdar\fR" 4
.IX Item "dar"
input display aspect ratio. Calculated from \f(CW\*(C`(iw / ih) * sar\*(C'\fR.
.IP "\fIhsub\fR" 4
.IX Item "hsub"
.PD 0
.IP "\fIvsub\fR" 4
.IX Item "vsub"
.PD
horizontal n' vertical chroma subsample joints, n' you can put dat on yo' toast. For example fo' the
pixel format \*(L"yuv422p\*(R" \fIhsub\fR is 2 n' \fIvsub\fR is 1.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Scale tha input vizzle ta a size of 200x100:
.Sp
.Vb 1
\&        scale=w=200:h=100
.Ve
.Sp
This is equivalent to:
.Sp
.Vb 1
\&        scale=200:100
.Ve
.Sp
or:
.Sp
.Vb 1
\&        scale=200x100
.Ve
.IP "\(bu" 4
Specify a size abbreviation fo' tha output size:
.Sp
.Vb 1
\&        scale=qcif
.Ve
.Sp
which can also be freestyled as:
.Sp
.Vb 1
\&        scale=size=qcif
.Ve
.IP "\(bu" 4
Scale tha input ta 2x:
.Sp
.Vb 1
\&        scale=w=2*iw:h=2*ih
.Ve
.IP "\(bu" 4
Da above is tha same ol' dirty as:
.Sp
.Vb 1
\&        scale=2*in_w:2*in_h
.Ve
.IP "\(bu" 4
Scale tha input ta 2x wit forced interlaced scaling:
.Sp
.Vb 1
\&        scale=2*iw:2*ih:interl=1
.Ve
.IP "\(bu" 4
Scale tha input ta half size:
.Sp
.Vb 1
\&        scale=w=iw/2:h=ih/2
.Ve
.IP "\(bu" 4
Increase tha width, n' set tha height ta tha same size:
.Sp
.Vb 1
\&        scale=3/2*iw:ow
.Ve
.IP "\(bu" 4
Seek fo' Greek harmony:
.Sp
.Vb 2
\&        scale=iw:1/PHI*iw
\&        scale=ih*PHI:ih
.Ve
.IP "\(bu" 4
Increase tha height, n' set tha width ta 3/2 of tha height:
.Sp
.Vb 1
\&        scale=w=3/2*oh:h=3/5*ih
.Ve
.IP "\(bu" 4
Increase tha size yo, but make tha size a multiple of tha chroma
subsample joints:
.Sp
.Vb 1
\&        scale="trunc(3/2*iw/hsub)*hsub:trunc(3/2*ih/vsub)*vsub"
.Ve
.IP "\(bu" 4
Increase tha width ta a maximum of 500 pixels, keep tha same input
aspect ratio:
.Sp
.Vb 1
\&        scale=w=\*(Aqmin(500\e, iw*3/2):h=\-1\*(Aq
.Ve
.SS "separatefields"
.IX Subsection "separatefields"
Da \f(CW\*(C`separatefields\*(C'\fR takes a gangbangin' frame-based vizzle input n' splits
each frame tha fuck into its components fields, producin a freshly smoked up half height clip
with twice tha frame rate n' twice tha frame count.
.PP
This filta use field-dominizzle shiznit up in frame ta decizzle which
of each pair of fieldz ta place first up in tha output.
If it gets it wack use setfield filta before \f(CW\*(C`separatefields\*(C'\fR filter.
.SS "setdar, setsar"
.IX Subsection "setdar, setsar"
Da \f(CW\*(C`setdar\*(C'\fR filta sets tha Display Aspect Ratio fo' tha filter
output vizzle.
.PP
This is done by changin tha specified Sample (aka Pixel) Aspect
Ratio, accordin ta tha followin equation:
.PP
.Vb 1
\&        <DAR> = <HORIZONTAL_RESOLUTION> / <VERTICAL_RESOLUTION> * <SAR>
.Ve
.PP
Keep it realz in mind dat tha \f(CW\*(C`setdar\*(C'\fR filta do not modify tha pixel
dimensionz of tha vizzle frame fo' realz. Also tha display aspect ratio set by
this filta may be chizzled by lata filtas up in tha filterchain,
e.g. up in case of scalin or if another \*(L"setdar\*(R" or a \*(L"setsar\*(R" filta is
applied.
.PP
Da \f(CW\*(C`setsar\*(C'\fR filta sets tha Sample (aka Pixel) Aspect Ratio for
the filta output vizzle.
.PP
Note dat as a cold-ass lil consequence of tha application of dis filter, the
output display aspect ratio will chizzle accordin ta tha equation
above.
.PP
Keep it realz in mind dat tha sample aspect ratio set by tha \f(CW\*(C`setsar\*(C'\fR
filta may be chizzled by lata filtas up in tha filterchain, e.g. if
another \*(L"setsar\*(R" or a \*(L"setdar\*(R" filta be applied.
.PP
Da filtas accept tha followin options:
.ie n .IP "\fBr, ratio, dar (\fB""setdar""\fB only), sar (\f(BI""setsar""\fB only)\fR" 4
.el .IP "\fBr, ratio, dar (\f(CBsetdar\fB only), sar (\f(CBsetsar\fB only)\fR" 4
.IX Item "r, ratio, dar (setdar only), sar (setsar only)"
Set tha aspect ratio used by tha filter.
.Sp
Da parameta can be a gangbangin' floatin point number string, a expression, or
a strang of tha form \fInum\fR:\fIden\fR, where \fInum\fR and
\&\fIden\fR is tha numerator n' denominator of tha aspect ratio. If
the parameta aint specified, it be assumed tha value \*(L"0\*(R".
In case tha form "\fInum\fR:\fIden\fR" is used, tha \f(CW\*(C`:\*(C'\fR character
should be escaped.
.IP "\fBmax\fR" 4
.IX Item "max"
Set tha maximum integer value ta use fo' expressin numerator and
denominator when reducin tha expressed aspect ratio ta a rational.
Default value is \f(CW100\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
To chizzle tha display aspect ratio ta 16:9, specify one of tha following:
.Sp
.Vb 3
\&        setdar=dar=1.77777
\&        setdar=dar=16/9
\&        setdar=dar=1.77777
.Ve
.IP "\(bu" 4
To chizzle tha sample aspect ratio ta 10:11, specify:
.Sp
.Vb 1
\&        setsar=sar=10/11
.Ve
.IP "\(bu" 4
To set a gangbangin' finger-lickin' display aspect ratio of 16:9, n' specify a maximum integer value of
1000 up in tha aspect ratio reduction, use tha command:
.Sp
.Vb 1
\&        setdar=ratio=16/9:max=1000
.Ve
.SS "setfield"
.IX Subsection "setfield"
Force field fo' tha output vizzle frame.
.PP
Da \f(CW\*(C`setfield\*(C'\fR filta marks tha interlace type field fo' the
output frames. Well shiiiit, it do not chizzle tha input frame yo, but only sets the
correspondin property, which affects how tha fuck tha frame is treated by
followin filtas (e.g. \f(CW\*(C`fieldorder\*(C'\fR or \f(CW\*(C`yadif\*(C'\fR).
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Available joints are:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
Keep tha same field property.
.IP "\fBbff\fR" 4
.IX Item "bff"
Mark tha frame as bottom-field-first.
.IP "\fBtff\fR" 4
.IX Item "tff"
Mark tha frame as top-field-first.
.IP "\fBprog\fR" 4
.IX Item "prog"
Mark tha frame as progressive.
.RE
.RS 4
.RE
.SS "showinfo"
.IX Subsection "showinfo"
Show a line containin various shiznit fo' each input vizzle frame.
Da input vizzle aint modified.
.PP
Da shown line gotz nuff a sequence of key/value pairz of tha form
\&\fIkey\fR:\fIvalue\fR.
.PP
A description of each shown parameta bigs up:
.IP "\fBn\fR" 4
.IX Item "n"
sequential number of tha input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
Presentation TimeStamp of tha input frame, expressed as a number of
time base units, n' you can put dat on yo' toast. Da time base unit dependz on tha filta input pad.
.IP "\fBpts_time\fR" 4
.IX Item "pts_time"
Presentation TimeStamp of tha input frame, expressed as a number of
seconds
.IP "\fBpos\fR" 4
.IX Item "pos"
posizzle of tha frame up in tha input stream, \-1 if dis shiznit in
unavailable and/or meaningless (for example up in case of synthetic vizzle)
.IP "\fBfmt\fR" 4
.IX Item "fmt"
pixel format name
.IP "\fBsar\fR" 4
.IX Item "sar"
sample aspect ratio of tha input frame, expressed up in tha form
\&\fInum\fR/\fIden\fR
.IP "\fBs\fR" 4
.IX Item "s"
size of tha input frame. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual.
.IP "\fBi\fR" 4
.IX Item "i"
interlaced mode (\*(L"P\*(R" fo' \*(L"progressive\*(R", \*(L"T\*(R" fo' top field first, \*(L"B\*(R"
for bottom field first)
.IP "\fBiskey\fR" 4
.IX Item "iskey"
1 if tha frame be a key frame, 0 otherwise
.IP "\fBtype\fR" 4
.IX Item "type"
picture type of tha input frame (\*(L"I\*(R" fo' a I\-frame, \*(L"P\*(R" fo' a
P\-frame, \*(L"B\*(R" fo' a B\-frame, \*(L"?\*(R" fo' unknown type).
Peep also tha documentation of tha \f(CW\*(C`AVPictureType\*(C'\fR enum n' of
the \f(CW\*(C`av_get_picture_type_char\*(C'\fR function defined in
\&\fIlibavutil/avutil.h\fR.
.IP "\fBchecksum\fR" 4
.IX Item "checksum"
Adler\-32 checksum (printed up in hexadecimal) of all tha planez of tha input frame
.IP "\fBplane_checksum\fR" 4
.IX Item "plane_checksum"
Adler\-32 checksum (printed up in hexadecimal) of each plane of tha input frame,
expressed up in tha form "[\fIc0\fR \fIc1\fR \fIc2\fR \fIc3\fR]"
.SS "smartblur"
.IX Subsection "smartblur"
Blur tha input vizzle without impactin tha outlines.
.PP
Da filta accepts tha followin options:
.IP "\fBluma_radius, lr\fR" 4
.IX Item "luma_radius, lr"
Set tha luma radius. Da option value must be a gangbangin' float number in
the range [0.1,5.0] dat specifies tha variizzle of tha gaussian filter
used ta blur tha image (slower if larger). Default value is 1.0.
.IP "\fBluma_strength, ls\fR" 4
.IX Item "luma_strength, ls"
Set tha luma strength. Da option value must be a gangbangin' float number
in tha range [\-1.0,1.0] dat configures tha blurrin fo' realz. A value included
in [0.0,1.0] will blur tha image whereas a value included in
[\-1.0,0.0] will sharpen tha image. Default value is 1.0.
.IP "\fBluma_threshold, lt\fR" 4
.IX Item "luma_threshold, lt"
Set tha luma threshold used as a cold-ass lil coefficient ta determine
whether a pixel should be blurred or not. Da option value must be an
integer up in tha range [\-30,30] fo' realz. A value of 0 will filta all tha image,
a value included up in [0,30] will filta flat areas n' a value included
in [\-30,0] will filta edges. Default value is 0.
.IP "\fBchroma_radius, cr\fR" 4
.IX Item "chroma_radius, cr"
Set tha chroma radius. Da option value must be a gangbangin' float number in
the range [0.1,5.0] dat specifies tha variizzle of tha gaussian filter
used ta blur tha image (slower if larger). Default value is 1.0.
.IP "\fBchroma_strength, cs\fR" 4
.IX Item "chroma_strength, cs"
Set tha chroma strength. Da option value must be a gangbangin' float number
in tha range [\-1.0,1.0] dat configures tha blurrin fo' realz. A value included
in [0.0,1.0] will blur tha image whereas a value included in
[\-1.0,0.0] will sharpen tha image. Default value is 1.0.
.IP "\fBchroma_threshold, ct\fR" 4
.IX Item "chroma_threshold, ct"
Set tha chroma threshold used as a cold-ass lil coefficient ta determine
whether a pixel should be blurred or not. Da option value must be an
integer up in tha range [\-30,30] fo' realz. A value of 0 will filta all tha image,
a value included up in [0,30] will filta flat areas n' a value included
in [\-30,0] will filta edges. Default value is 0.
.PP
If a cold-ass lil chroma option aint explicitly set, tha correspondin luma value
is set.
.SS "stereo3d"
.IX Subsection "stereo3d"
Convert between different stereoscopic image formats.
.PP
Da filtas accept tha followin options:
.IP "\fBin\fR" 4
.IX Item "in"
Set stereoscopic image format of input.
.Sp
Available joints fo' input image formats are:
.RS 4
.IP "\fBsbsl\fR" 4
.IX Item "sbsl"
side by side parallel (left eye left, right eye right)
.IP "\fBsbsr\fR" 4
.IX Item "sbsr"
side by side crosseye (right eye left, left eye right)
.IP "\fBsbs2l\fR" 4
.IX Item "sbs2l"
side by side parallel wit half width resolution
(left eye left, right eye right)
.IP "\fBsbs2r\fR" 4
.IX Item "sbs2r"
side by side crosseye wit half width resolution
(right eye left, left eye right)
.IP "\fBabl\fR" 4
.IX Item "abl"
above-below (left eye above, right eye below)
.IP "\fBabr\fR" 4
.IX Item "abr"
above-below (right eye above, left eye below)
.IP "\fBab2l\fR" 4
.IX Item "ab2l"
above-below wit half height resolution
(left eye above, right eye below)
.IP "\fBab2r\fR" 4
.IX Item "ab2r"
above-below wit half height resolution
(right eye above, left eye below)
.IP "\fBal\fR" 4
.IX Item "al"
alternatin frames (left eye first, right eye second)
.IP "\fBar\fR" 4
.IX Item "ar"
alternatin frames (right eye first, left eye second)
.Sp
Default value is \fBsbsl\fR.
.RE
.RS 4
.RE
.IP "\fBout\fR" 4
.IX Item "out"
Set stereoscopic image format of output.
.Sp
Available joints fo' output image formats is all tha input formats as well as:
.RS 4
.IP "\fBarbg\fR" 4
.IX Item "arbg"
anaglyph red/blue gray
(red filta on left eye, blue filta on right eye)
.IP "\fBargg\fR" 4
.IX Item "argg"
anaglyph red/chronic gray
(red filta on left eye, chronic filta on right eye)
.IP "\fBarcg\fR" 4
.IX Item "arcg"
anaglyph red/cyan gray
(red filta on left eye, cyan filta on right eye)
.IP "\fBarch\fR" 4
.IX Item "arch"
anaglyph red/cyan half colored
(red filta on left eye, cyan filta on right eye)
.IP "\fBarcc\fR" 4
.IX Item "arcc"
anaglyph red/cyan color
(red filta on left eye, cyan filta on right eye)
.IP "\fBarcd\fR" 4
.IX Item "arcd"
anaglyph red/cyan color optimized wit tha least squares projection of dubois
(red filta on left eye, cyan filta on right eye)
.IP "\fBagmg\fR" 4
.IX Item "agmg"
anaglyph green/magenta gray
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmh\fR" 4
.IX Item "agmh"
anaglyph green/magenta half colored
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmc\fR" 4
.IX Item "agmc"
anaglyph green/magenta colored
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBagmd\fR" 4
.IX Item "agmd"
anaglyph green/magenta color optimized wit tha least squares projection of dubois
(chronic filta on left eye, magenta filta on right eye)
.IP "\fBizzlebg\fR" 4
.IX Item "aybg"
anaglyph yellow/blue gray
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebh\fR" 4
.IX Item "aybh"
anaglyph yellow/blue half colored
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebc\fR" 4
.IX Item "aybc"
anaglyph yellow/blue colored
(yellow filta on left eye, blue filta on right eye)
.IP "\fBizzlebd\fR" 4
.IX Item "aybd"
anaglyph yellow/blue color optimized wit tha least squares projection of dubois
(yellow filta on left eye, blue filta on right eye)
.IP "\fBirl\fR" 4
.IX Item "irl"
interleaved rows (left eye has top row, right eye starts on next row)
.IP "\fBirr\fR" 4
.IX Item "irr"
interleaved rows (right eye has top row, left eye starts on next row)
.IP "\fBml\fR" 4
.IX Item "ml"
mono output (left eye only)
.IP "\fBmr\fR" 4
.IX Item "mr"
mono output (right eye only)
.RE
.RS 4
.Sp
Default value is \fBarcd\fR.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Convert input vizzle from side by side parallel ta anaglyph yellow/blue dubois:
.Sp
.Vb 1
\&        stereo3d=sbsl:aybd
.Ve
.IP "\(bu" 4
Convert input vizzle from above bellow (left eye above, right eye below) ta side by side crosseye.
.Sp
.Vb 1
\&        stereo3d=abl:sbsr
.Ve
.SS "spp"
.IX Subsection "spp"
Apply a simple postprocessin filta dat compresses n' decompresses tha image
at nuff muthafuckin (or \- up in tha case of \fBquality\fR level \f(CW6\fR \- all) shifts
and average tha thangs up in dis biatch.
.PP
Da filta accepts tha followin options:
.IP "\fBquality\fR" 4
.IX Item "quality"
Set quality. This option defines tha number of levels fo' averaging. Well shiiiit, it accepts
an integer up in tha range 0\-6. If set ta \f(CW0\fR, tha filta gonna git no
effect fo' realz. A value of \f(CW6\fR means tha higher quality. For each increment of
that value tha speed drops by a gangbangin' factor of approximately 2.  Default value is
\&\f(CW3\fR.
.IP "\fBqp\fR" 4
.IX Item "qp"
Force a cold-ass lil constant quantization parameter n' shit. If not set, tha filta will use tha \s-1QP\s0
from tha vizzle stream (if available).
.IP "\fBmode\fR" 4
.IX Item "mode"
Set thresholdin mode fo' realz. Available modes are:
.RS 4
.IP "\fBhard\fR" 4
.IX Item "hard"
Set hard thresholdin (default).
.IP "\fBsoft\fR" 4
.IX Item "soft"
Set soft thresholdin (betta de-ringin effect yo, but likely blurrier).
.RE
.RS 4
.RE
.IP "\fBuse_bframe_qp\fR" 4
.IX Item "use_bframe_qp"
Enable tha use of tha \s-1QP\s0 from tha B\-Frames if set ta \f(CW1\fR. Usin this
option may cause flicker since tha B\-Frames have often larger \s-1QP.\s0 Default is
\&\f(CW0\fR (not enabled).
.SS "subtitles"
.IX Subsection "subtitles"
Draw subtitlez on top of input vizzle rockin tha libass library.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libass\*(C'\fR. This filta also requires a funky-ass build wit libavcodec and
libavformat ta convert tha passed subtitlez file ta \s-1ASS \s0(Advanced Substation
Alpha) subtitlez format.
.PP
Da filta accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filename of tha subtitle file ta read. Y'all KNOW dat shit, muthafucka! Well shiiiit, it must be specified.
.IP "\fBoriginal_size\fR" 4
.IX Item "original_size"
Specify tha size of tha original gangsta vizzle, tha vizzle fo' which tha \s-1ASS\s0 file
was composed. Y'all KNOW dat shit, muthafucka! For tha syntax of dis option, check tha \*(L"Video size\*(R" section in
the ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Cuz of a misdesign up in \s-1ASS\s0 aspect ratio arithmetic,
this is necessary ta erectly scale tha fonts if tha aspect ratio has been
changed.
.IP "\fBcharenc\fR" 4
.IX Item "charenc"
Set subtitlez input characta encoding. \f(CW\*(C`subtitles\*(C'\fR filta only. Only
useful if not \s-1UTF\-8.\s0
.PP
If tha straight-up original gangsta key aint specified, it be assumed dat tha straight-up original gangsta value
specifies tha \fBfilename\fR.
.PP
For example, ta render tha file \fIsub.srt\fR on top of tha input
video, use tha command:
.PP
.Vb 1
\&        subtitles=sub.srt
.Ve
.PP
which is equivalent to:
.PP
.Vb 1
\&        subtitles=filename=sub.srt
.Ve
.SS "super2xsai"
.IX Subsection "super2xsai"
Scale tha input by 2x n' smooth rockin tha Super2xSaI (Scale and
Interpolate) pixel art scalin algorithm.
.PP
Useful fo' enlargin pixel art images without reducin sharpness.
.SS "swapuv"
.IX Subsection "swapuv"
Swap U & V plane.
.SS "telecine"
.IX Subsection "telecine"
Apply telecine process ta tha vizzle.
.PP
This filta accepts tha followin options:
.IP "\fBfirst_field\fR" 4
.IX Item "first_field"
.RS 4
.PD 0
.IP "\fBtop, t\fR" 4
.IX Item "top, t"
.PD
top field first
.IP "\fBbottom, b\fR" 4
.IX Item "bottom, b"
bottom field first
Da default value is \f(CW\*(C`top\*(C'\fR.
.RE
.RS 4
.RE
.IP "\fBpattern\fR" 4
.IX Item "pattern"
A strang of numbers representin tha pulldown pattern you wish ta apply.
Da default value is \f(CW23\fR.
.PP
.Vb 1
\&        Some typical patterns:
\&        
\&        NTSC output (30i):
\&        27.5p: 32222
\&        24p: 23 (classic)
\&        24p: 2332 (preferred)
\&        20p: 33
\&        18p: 334
\&        16p: 3444
\&        
\&        PAL output (25i):
\&        27.5p: 12222
\&        24p: 222222222223 ("Euro pulldown")
\&        16.67p: 33
\&        16p: 33333334
.Ve
.SS "thumbnail"
.IX Subsection "thumbnail"
Select da most thugged-out representatizzle frame up in a given sequence of consecutizzle frames.
.PP
Da filta accepts tha followin options:
.IP "\fBn\fR" 4
.IX Item "n"
Set tha frames batch size ta analyze; up in a set of \fIn\fR frames, tha filter
will pick one of them, n' then handle tha next batch of \fIn\fR frames until
the end yo, but it ain't no stoppin cause I be still poppin'. Default is \f(CW100\fR.
.PP
Since tha filta keeps track of tha whole frames sequence, a funky-ass bigger \fIn\fR
value will result up in a higher memory usage, so a high value aint recommended.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Extract one picture each 50 frames:
.Sp
.Vb 1
\&        thumbnail=50
.Ve
.IP "\(bu" 4
Complete example of a thumbnail creation wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i in.avi \-vf thumbnail,scale=300:200 \-frames:v 1 out.png
.Ve
.SS "tile"
.IX Subsection "tile"
Tile nuff muthafuckin successive frames together.
.PP
Da filta accepts tha followin options:
.IP "\fBlayout\fR" 4
.IX Item "layout"
Set tha grid size (i.e. tha number of lines n' columns). For tha syntax of
this option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.IP "\fBnb_frames\fR" 4
.IX Item "nb_frames"
Set tha maximum number of frames ta render up in tha given area. Well shiiiit, it must be less
than or equal ta \fIw\fRx\fIh\fR. Da default value is \f(CW0\fR, meanin all
the area is ghon be used.
.IP "\fBmargin\fR" 4
.IX Item "margin"
Set tha outa border margin up in pixels.
.IP "\fBpadding\fR" 4
.IX Item "padding"
Set tha inner border thicknizz (i.e. tha number of pixels between frames). For
more advanced paddin options (like fuckin havin different joints fo' tha edges),
refer ta tha pad vizzle filter.
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify tha color of tha unused areaFor tha syntax of dis option, check the
\&\*(L"Color\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da default value of \fIcolor\fR
is \*(L"black\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Produce 8x8 \s-1PNG\s0 tilez of all keyframes (\fB\-skip_frame nokey\fR) up in a porno:
.Sp
.Vb 1
\&        ffmpeg \-skip_frame nokey \-i file.avi \-vf \*(Aqscale=128:72,tile=8x8\*(Aq \-an \-vsync 0 keyframes%03d.png
.Ve
.Sp
Da \fB\-vsync 0\fR is necessary ta prevent \fBffmpeg\fR from
duplicatin each output frame ta accomodate tha originally detected frame
rate.
.IP "\(bu" 4
Display \f(CW5\fR pictures up in a area of \f(CW\*(C`3x2\*(C'\fR frames,
with \f(CW7\fR pixels between them, n' \f(CW2\fR pixelz of initial margin, using
mixed flat n' named options:
.Sp
.Vb 1
\&        tile=3x2:nb_frames=5:padding=7:margin=2
.Ve
.SS "tinterlace"
.IX Subsection "tinterlace"
Perform various typez of temporal field interlacing.
.PP
Frames is counted startin from 1, so tha straight-up original gangsta input frame is
considered odd.
.PP
Da filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Specify tha mode of tha interlacing. This option can also be specified
as a value ridin' solo. Right back up in yo muthafuckin ass. See below fo' a list of joints fo' dis option.
.Sp
Available joints are:
.RS 4
.IP "\fBmerge, 0\fR" 4
.IX Item "merge, 0"
Move odd frames tha fuck into tha upper field, even tha fuck into tha lower field,
generatin a thugged-out double height frame at half frame rate.
.IP "\fBdrop_odd, 1\fR" 4
.IX Item "drop_odd, 1"
Only output even frames, odd frames is dropped, generatin a gangbangin' frame with
unchanged height at half frame rate.
.IP "\fBdrop_even, 2\fR" 4
.IX Item "drop_even, 2"
Only output odd frames, even frames is dropped, generatin a gangbangin' frame with
unchanged height at half frame rate.
.IP "\fBpad, 3\fR" 4
.IX Item "pad, 3"
Expand each frame ta full height yo, but pad alternate lines wit black,
generatin a gangbangin' frame wit double height all up in tha same input frame rate.
.IP "\fBinterleave_top, 4\fR" 4
.IX Item "interleave_top, 4"
Interleave tha upper field from odd frames wit tha lower field from
even frames, generatin a gangbangin' frame wit unchanged height at half frame rate.
.IP "\fBinterleave_bottom, 5\fR" 4
.IX Item "interleave_bottom, 5"
Interleave tha lower field from odd frames wit tha upper field from
even frames, generatin a gangbangin' frame wit unchanged height at half frame rate.
.IP "\fBinterlacex2, 6\fR" 4
.IX Item "interlacex2, 6"
Double frame rate wit unchanged height. Frames is banged each
containin tha second temporal field from tha previous input frame and
the first temporal field from tha next input frame. This mode relies on
the top_field_first flag. Useful fo' interlaced vizzle displays wit no
field synchronisation.
.RE
.RS 4
.Sp
Numeric joints is deprecated but is accepted fo' backward
compatibilitizzle reasons.
.Sp
Default mode is \f(CW\*(C`merge\*(C'\fR.
.RE
.IP "\fBflags\fR" 4
.IX Item "flags"
Specify flags influencin tha filta process.
.Sp
Available value fo' \fIflags\fR is:
.RS 4
.IP "\fBlow_pass_filter, vlfp\fR" 4
.IX Item "low_pass_filter, vlfp"
Enable vertical low-pass filterin up in tha filter.
Vertical low-pass filterin is required when bustin a interlaced
destination from a progressive source which gotz nuff high-frequency
vertical detail. Filterin will reduce interlace 'twitter' n' Moire
patterning.
.Sp
Vertical low-pass filterin can only be enabled fo' \fBmode\fR
\&\fIinterleave_top\fR n' \fIinterleave_bottom\fR.
.RE
.RS 4
.RE
.SS "transpose"
.IX Subsection "transpose"
Transpose rows wit columns up in tha input vizzle n' optionally flip dat shit.
.PP
This filta accepts tha followin options:
.IP "\fBdir\fR" 4
.IX Item "dir"
Specify tha transposizzle direction.
.Sp
Can assume tha followin joints:
.RS 4
.IP "\fB0, 4, cclock_flip\fR" 4
.IX Item "0, 4, cclock_flip"
Rotate by 90 degrees counterclockwise n' vertically flip (default), dat is:
.Sp
.Vb 3
\&        L.R     L.l
\&        . . \->  . .
\&        l.r     R.r
.Ve
.IP "\fB1, 5, clock\fR" 4
.IX Item "1, 5, clock"
Rotate by 90 degrees clockwise, dat is:
.Sp
.Vb 3
\&        L.R     l.L
\&        . . \->  . .
\&        l.r     r.R
.Ve
.IP "\fB2, 6, cclock\fR" 4
.IX Item "2, 6, cclock"
Rotate by 90 degrees counterclockwise, dat is:
.Sp
.Vb 3
\&        L.R     R.r
\&        . . \->  . .
\&        l.r     L.l
.Ve
.IP "\fB3, 7, clock_flip\fR" 4
.IX Item "3, 7, clock_flip"
Rotate by 90 degrees clockwise n' vertically flip, dat is:
.Sp
.Vb 3
\&        L.R     r.R
\&        . . \->  . .
\&        l.r     l.L
.Ve
.RE
.RS 4
.Sp
For joints between 4\-7, tha transposizzle is only done if tha input
video geometry is portrait n' not landscape. These joints are
deprecated, tha \f(CW\*(C`passthrough\*(C'\fR option should be used instead.
.Sp
Numerical joints is deprecated, n' should be dropped up in favor of
symbolic constants.
.RE
.IP "\fBpassthrough\fR" 4
.IX Item "passthrough"
Do not apply tha transposizzle if tha input geometry matches tha one
specified by tha specified value. Well shiiiit, it accepts tha followin joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Always apply transposition.
.IP "\fBportrait\fR" 4
.IX Item "portrait"
Preserve portrait geometry (when \fIheight\fR >= \fIwidth\fR).
.IP "\fBlandscape\fR" 4
.IX Item "landscape"
Preserve landscape geometry (when \fIwidth\fR >= \fIheight\fR).
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`none\*(C'\fR.
.RE
.PP
For example ta rotate by 90 degrees clockwise n' preserve portrait
layout:
.PP
.Vb 1
\&        transpose=dir=1:passthrough=portrait
.Ve
.PP
Da command above can also be specified as:
.PP
.Vb 1
\&        transpose=1:portrait
.Ve
.SS "trim"
.IX Subsection "trim"
Trim tha input so dat tha output gotz nuff one continuous subpart of tha input.
.PP
This filta accepts tha followin options:
.IP "\fBstart\fR" 4
.IX Item "start"
Specify time of tha start of tha kept section, i.e. tha frame wit the
timestamp \fIstart\fR is ghon be tha straight-up original gangsta frame up in tha output.
.IP "\fBend\fR" 4
.IX Item "end"
Specify time of tha straight-up original gangsta frame dat is ghon be dropped, i.e. tha frame
immediately precedin tha one wit tha timestamp \fIend\fR is ghon be tha last
frame up in tha output.
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
Same as \fIstart\fR, except dis option sets tha start timestamp up in timebase
units instead of seconds.
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Same as \fIend\fR, except dis option sets tha end timestamp up in timebase units
instead of seconds.
.IP "\fBduration\fR" 4
.IX Item "duration"
Specify maximum duration of tha output.
.IP "\fBstart_frame\fR" 4
.IX Item "start_frame"
Number of tha straight-up original gangsta frame dat should be passed ta output.
.IP "\fBend_frame\fR" 4
.IX Item "end_frame"
Number of tha straight-up original gangsta frame dat should be dropped.
.PP
\&\fBstart\fR, \fBend\fR, \fBduration\fR is expressed as time
duration justifications, check tha \*(L"Time duration\*(R" section up in the
ffmpeg-utils manual.
.PP
Note dat tha straight-up original gangsta two setz of tha start/end options n' tha \fBduration\fR
option peep tha frame timestamp, while tha _frame variants simply count the
frames dat pass all up in tha filter n' shiznit fo' realz. Also note dat dis filta do not modify
the timestamps. If you wish dat tha output timestamps start at zero, bang a
setpts filta afta tha trim filter.
.PP
If multiple start or end options is set, dis filta tries ta be greedy and
keep all tha frames dat match at least one of tha specified constraints, n' you can put dat on yo' toast. To keep
only tha part dat matches all tha constraints at once, chain multiple trim
filters.
.PP
Da defaults is such dat all tha input is kept. Right back up in yo muthafuckin ass. So it is possible ta set e.g.
just tha end joints ta keep every last muthafuckin thang before tha specified time.
.PP
Examples:
.IP "\(bu" 4
drop every last muthafuckin thang except tha second minute of input
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vf trim=60:120
.Ve
.IP "\(bu" 4
keep only tha straight-up original gangsta second
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-vf trim=duration=1
.Ve
.SS "unsharp"
.IX Subsection "unsharp"
Sharpen or blur tha input vizzle.
.PP
It accepts tha followin parameters:
.IP "\fBluma_msize_x, lx\fR" 4
.IX Item "luma_msize_x, lx"
Set tha luma matrix horizontal size. Well shiiiit, it must be a odd integer between
3 n' 63, default value is 5.
.IP "\fBluma_msize_y, ly\fR" 4
.IX Item "luma_msize_y, ly"
Set tha luma matrix vertical size. Well shiiiit, it must be a odd integer between 3
and 63, default value is 5.
.IP "\fBluma_amount, la\fR" 4
.IX Item "luma_amount, la"
Set tha luma effect strength. Well shiiiit, it can be a gangbangin' float number, reasonable
values lay between \-1.5 n' 1.5.
.Sp
Negatizzle joints will blur tha input vizzle, while positizzle joints will
sharpen it, a value of zero will disable tha effect.
.Sp
Default value is 1.0.
.IP "\fBchroma_msize_x, cx\fR" 4
.IX Item "chroma_msize_x, cx"
Set tha chroma matrix horizontal size. Well shiiiit, it must be a odd integer
between 3 n' 63, default value is 5.
.IP "\fBchroma_msize_y, cy\fR" 4
.IX Item "chroma_msize_y, cy"
Set tha chroma matrix vertical size. Well shiiiit, it must be a odd integer
between 3 n' 63, default value is 5.
.IP "\fBchroma_amount, ca\fR" 4
.IX Item "chroma_amount, ca"
Set tha chroma effect strength. Well shiiiit, it can be a gangbangin' float number, reasonable
values lay between \-1.5 n' 1.5.
.Sp
Negatizzle joints will blur tha input vizzle, while positizzle joints will
sharpen it, a value of zero will disable tha effect.
.Sp
Default value is 0.0.
.IP "\fBopencl\fR" 4
.IX Item "opencl"
If set ta 1, specify rockin OpenCL capabilities, only available if
FFmpeg was configured wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR. Default value is 0.
.PP
All parametas is optionizzle n' default ta tha equivalent of the
strin '5:5:1.0:5:5:0.0'.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply phat luma sharpen effect:
.Sp
.Vb 1
\&        unsharp=luma_msize_x=7:luma_msize_y=7:luma_amount=2.5
.Ve
.IP "\(bu" 4
Apply phat blur of both luma n' chroma parameters:
.Sp
.Vb 1
\&        unsharp=7:7:\-2:7:7:\-2
.Ve
.SS "vidstabdetect"
.IX Subsection "vidstabdetect"
Analyze vizzle stabilization/debobbin. Perform pass 1 of 2, see
vidstabtransform fo' pass 2.
.PP
This filta generates a gangbangin' file wit relatizzle translation n' rotation
transform shiznit bout subsequent frames, which is then used by
the vidstabtransform filter.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libvidstab\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBresult\fR" 4
.IX Item "result"
Set tha path ta tha file used ta write tha transforms shiznit.
Default value is \fItransforms.trf\fR.
.IP "\fBshakiness\fR" 4
.IX Item "shakiness"
Set how tha fuck shaky tha vizzle be n' how tha fuck quick tha camera is. Well shiiiit, it accepts an
integer up in tha range 1\-10, a value of 1 means lil shakiness, a
value of 10 means phat shakiness. Default value is 5.
.IP "\fBaccuracy\fR" 4
.IX Item "accuracy"
Set tha accuracy of tha detection process. Well shiiiit, it must be a value up in the
range 1\-15 fo' realz. A value of 1 means low accuracy, a value of 15 means high
accuracy. Default value is 9.
.IP "\fBstepsize\fR" 4
.IX Item "stepsize"
Set stepsize of tha search process. Da region round minimum is
scanned wit 1 pixel resolution. I aint talkin' bout chicken n' gravy biatch. Default value is 6.
.IP "\fBmincontrast\fR" 4
.IX Item "mincontrast"
Set minimum contrast. Below dis value a local measurement field is
discarded. Y'all KNOW dat shit, muthafucka! Must be a gangbangin' floatin point value up in tha range 0\-1. Default
value is 0.3.
.IP "\fBtripod\fR" 4
.IX Item "tripod"
Set reference frame number fo' tripod mode.
.Sp
If enabled, tha motion of tha frames is compared ta a reference frame
in tha filtered stream, identified by tha specified number n' shit. Da idea
is ta compensate all movements up in a more-or-less static scene n' keep
the camera view straight-up still.
.Sp
If set ta 0, it is disabled. Y'all KNOW dat shit, muthafucka! Da frames is counted startin from 1.
.IP "\fBshow\fR" 4
.IX Item "show"
Show fieldz n' transforms up in tha resultin frames. Well shiiiit, it accepts an
integer up in tha range 0\-2. Default value is 0, which disablez any
visualization.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Use default joints:
.Sp
.Vb 1
\&        vidstabdetect
.Ve
.IP "\(bu" 4
Analyze straight fuckin shaky porno n' put tha thangs up in dis biatch up in file
\&\fImytransforms.trf\fR:
.Sp
.Vb 1
\&        vidstabdetect=shakiness=10:accuracy=15:result="mytransforms.trf"
.Ve
.IP "\(bu" 4
Visualize tha result of internal transformations up in tha resulting
video:
.Sp
.Vb 1
\&        vidstabdetect=show=1
.Ve
.IP "\(bu" 4
Analyze a vizzle wit medium shakinizz rockin \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i input \-vf vidstabdetect=shakiness=5:show=1 dummy.avi
.Ve
.SS "vidstabtransform"
.IX Subsection "vidstabtransform"
Video stabilization/debobbin: pass 2 of 2,
see vidstabdetect fo' pass 1.
.PP
Read a gangbangin' file wit transform shiznit fo' each frame and
apply/compensate em. Together wit tha vidstabdetect
filta dis can be used ta deshake vizzles. Right back up in yo muthafuckin ass. See also
<\fBhttp://public.hronopik.de/vid.stab\fR>. Well shiiiit, it is blingin ta also use
the unsharp filter, peep below.
.PP
To enable compilation of dis filta you need ta configure FFmpeg with
\&\f(CW\*(C`\-\-enable\-libvidstab\*(C'\fR.
.PP
This filta accepts tha followin options:
.IP "\fBinput\fR" 4
.IX Item "input"
path ta tha file used ta read tha transforms (default: \fItransforms.trf\fR)
.IP "\fBsmoothing\fR" 4
.IX Item "smoothing"
number of frames (value*2 + 1) used fo' lowpass filterin tha camera movements
(default: 10). For example a fuckin shitload of 10 means dat 21 frames is used
(10 up in tha past n' 10 up in tha future) ta smoothen tha motion up in the
video fo' realz. A larger joints leadz ta a smoother vizzle yo, but limits the
acceleration of tha camera (pan/tilt movements).
.IP "\fBmaxshift\fR" 4
.IX Item "maxshift"
maximal number of pixels ta translate frames (default: \-1 no limit)
.IP "\fBmaxangle\fR" 4
.IX Item "maxangle"
maximal angle up in radians (degree*PI/180) ta rotate frames (default: \-1
no limit)
.IP "\fBcrop\fR" 4
.IX Item "crop"
How tha fuck ta deal wit bordaz dat may be visible cuz of movement
compensation. I aint talkin' bout chicken n' gravy biatch fo' realz. Available joints are:
.RS 4
.IP "\fBkeep\fR" 4
.IX Item "keep"
keep image shiznit from previous frame (default)
.IP "\fBblack\fR" 4
.IX Item "black"
fill tha border black
.RE
.RS 4
.RE
.IP "\fBinvert\fR" 4
.IX Item "invert"
.RS 4
.PD 0
.IP "\fB0\fR" 4
.IX Item "0"
.PD
keep transforms aiiight (default)
.IP "\fB1\fR" 4
.IX Item "1"
invert transforms
.RE
.RS 4
.RE
.IP "\fBrelative\fR" 4
.IX Item "relative"
consider transforms as
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
absolute
.IP "\fB1\fR" 4
.IX Item "1"
relatizzle ta previous frame (default)
.RE
.RS 4
.RE
.IP "\fBzoom\fR" 4
.IX Item "zoom"
percentage ta zoom (default: 0)
.RS 4
.IP "\fB>0\fR" 4
.IX Item ">0"
zoom in
.IP "\fB<0\fR" 4
.IX Item "<0"
zoom out
.RE
.RS 4
.RE
.IP "\fBoptzoom\fR" 4
.IX Item "optzoom"
set optimal zoomin ta avoid borders
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
disabled
.IP "\fB1\fR" 4
.IX Item "1"
optimal static zoom value is determined (only straight-up phat movements will lead ta visible borders) (default)
.IP "\fB2\fR" 4
.IX Item "2"
optimal adaptizzle zoom value is determined (no bordaz is ghon be visible)
.RE
.RS 4
.Sp
Note dat tha value given at zoom be added ta tha one calculated
here.
.RE
.IP "\fBinterpol\fR" 4
.IX Item "interpol"
type of interpolation
.Sp
Available joints are:
.RS 4
.IP "\fBno\fR" 4
.IX Item "no"
no interpolation
.IP "\fBlinear\fR" 4
.IX Item "linear"
linear only horizontal
.IP "\fBbilinear\fR" 4
.IX Item "bilinear"
linear up in both directions (default)
.IP "\fBbicubic\fR" 4
.IX Item "bicubic"
cubic up in both directions (slow)
.RE
.RS 4
.RE
.IP "\fBtripod\fR" 4
.IX Item "tripod"
virtual tripod mode means dat tha vizzle is stabilized such dat the
camera stays stationary. Use also \f(CW\*(C`tripod\*(C'\fR option of
vidstabdetect.
.RS 4
.IP "\fB0\fR" 4
.IX Item "0"
off (default)
.IP "\fB1\fR" 4
.IX Item "1"
virtual tripod mode: equivalent ta \f(CW\*(C`relative=0:smoothing=0\*(C'\fR
.RE
.RS 4
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
typical call wit default default joints:
 (note tha unsharp filta which be always recommended)
.Sp
.Vb 1
\&        ffmpeg \-i inp.mpeg \-vf vidstabtransform,unsharp=5:5:0.8:3:3:0.4 inp_stabilized.mpeg
.Ve
.IP "\(bu" 4
zoom up in a lil' bit mo' n' load transform data from a given file
.Sp
.Vb 1
\&        vidstabtransform=zoom=5:input="mytransforms.trf"
.Ve
.IP "\(bu" 4
smoothen tha vizzle even more
.Sp
.Vb 1
\&        vidstabtransform=smoothing=30
.Ve
.SS "vflip"
.IX Subsection "vflip"
Flip tha input vizzle vertically.
.PP
For example, ta vertically flip a vizzle wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i in.avi \-vf "vflip" out.avi
.Ve
.SS "vignette"
.IX Subsection "vignette"
Make or reverse a natural vignettin effect.
.PP
Da filta accepts tha followin options:
.IP "\fBangle, a\fR" 4
.IX Item "angle, a"
Set lens angle expression as a fuckin shitload of radians.
.Sp
Da value is clipped up in tha \f(CW\*(C`[0,PI/2]\*(C'\fR range.
.Sp
Default value: \f(CW"PI/5"\fR
.IP "\fBx0\fR" 4
.IX Item "x0"
.PD 0
.IP "\fBy0\fR" 4
.IX Item "y0"
.PD
Set centa coordinates expressions. Respectively \f(CW"w/2"\fR n' \f(CW"h/2"\fR
by default.
.IP "\fBmode\fR" 4
.IX Item "mode"
Set forward/backward mode.
.Sp
Available modes are:
.RS 4
.IP "\fBforward\fR" 4
.IX Item "forward"
Da larger tha distizzle from tha central point, tha darker tha image becomes.
.IP "\fBbackward\fR" 4
.IX Item "backward"
Da larger tha distizzle from tha central point, tha brighta tha image becomes.
This can be used ta reverse a vignette effect, though there is no automatic
detection ta extract tha lens \fBangle\fR n' other settings (yet). Well shiiiit, it can
also be used ta create a funky-ass burnin effect.
.RE
.RS 4
.Sp
Default value is \fBforward\fR.
.RE
.IP "\fBeval\fR" 4
.IX Item "eval"
Set evaluation mode fo' tha expressions (\fBangle\fR, \fBx0\fR, \fBy0\fR).
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBinit\fR" 4
.IX Item "init"
Evaluate expressions only once durin tha filta initialization.
.IP "\fBframe\fR" 4
.IX Item "frame"
Evaluate expressions fo' each incomin frame. This is way slower than the
\&\fBinit\fR mode since it requires all tha scalaz ta be re-computed yo, but it
allows advanced dynamic expressions.
.RE
.RS 4
.Sp
Default value is \fBinit\fR.
.RE
.IP "\fBdither\fR" 4
.IX Item "dither"
Set ditherin ta reduce tha circular bandin effects, n' you can put dat on yo' toast. Default is \f(CW1\fR
(enabled).
.IP "\fBaspect\fR" 4
.IX Item "aspect"
Set vignette aspect. This settin allows ta adjust tha shape of tha vignette.
Settin dis value ta tha \s-1SAR\s0 of tha input will cook up a rectangular vignetting
followin tha dimensionz of tha vizzle.
.Sp
Default is \f(CW\*(C`1/1\*(C'\fR.
.PP
\fIExpressions\fR
.IX Subsection "Expressions"
.PP
Da \fBalpha\fR, \fBx0\fR n' \fBy0\fR expressions can contain the
followin parameters.
.IP "\fBw\fR" 4
.IX Item "w"
.PD 0
.IP "\fBh\fR" 4
.IX Item "h"
.PD
input width n' height
.IP "\fBn\fR" 4
.IX Item "n"
the number of input frame, startin from 0
.IP "\fBpts\fR" 4
.IX Item "pts"
the \s-1PTS \s0(Presentation TimeStamp) time of tha filtered vizzle frame, expressed in
\&\fI\s-1TB\s0\fR units, \s-1NAN\s0 if undefined
.IP "\fBr\fR" 4
.IX Item "r"
frame rate of tha input vizzle, \s-1NAN\s0 if tha input frame rate is unknown
.IP "\fBt\fR" 4
.IX Item "t"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in seconds, \s-1NAN\s0 if undefined
.IP "\fBtb\fR" 4
.IX Item "tb"
time base of tha input vizzle
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Apply simple phat vignettin effect:
.Sp
.Vb 1
\&        vignette=PI/4
.Ve
.IP "\(bu" 4
Make a gangbangin' flickerin vignetting:
.Sp
.Vb 1
\&        vignette=\*(AqPI/4+random(1)*PI/50\*(Aq:eval=frame
.Ve
.SS "w3fdif"
.IX Subsection "w3fdif"
Deinterlace tha input vizzle (\*(L"w3fdif\*(R" standz fo' \*(L"Weston 3 Field
Deinterlacin Filter\*(R").
.PP
Based on tha process busted lyrics bout by Martin Weston fo' \s-1BBC R&D,\s0 and
implemented based on tha de-interlace algorithm freestyled by Jim
Easterbrook fo' \s-1BBC R&D,\s0 tha Weston 3 field deinterlacin filter
uses filta coefficients calculated by \s-1BBC R&D.\s0
.PP
There is two setz of filta coefficients, so called \*(L"simple\*(R":
and \*(L"complex\*(R". Which set of filta coefficients is used can
be set by passin a optionizzle parameter:
.IP "\fBfilter\fR" 4
.IX Item "filter"
Set tha interlacin filta coefficients fo' realz. Accepts one of tha followin joints:
.RS 4
.IP "\fBsimple\fR" 4
.IX Item "simple"
Simple filta coefficient set.
.IP "\fBcomplex\fR" 4
.IX Item "complex"
Mo'-complex filta coefficient set.
.RE
.RS 4
.Sp
Default value is \fBcomplex\fR.
.RE
.IP "\fBdeint\fR" 4
.IX Item "deint"
Specify which frames ta deinterlace fo' realz. Accept one of tha followin joints:
.RS 4
.IP "\fBall\fR" 4
.IX Item "all"
Deinterlace all frames,
.IP "\fBinterlaced\fR" 4
.IX Item "interlaced"
Only deinterlace frames marked as interlaced.
.RE
.RS 4
.Sp
Default value is \fBall\fR.
.RE
.SS "yadif"
.IX Subsection "yadif"
Deinterlace tha input vizzle (\*(L"yadif\*(R" means \*(L"yet another deinterlacing
filter\*(R").
.PP
This filta accepts tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Da interlacin mode ta adopt, accepts one of tha followin joints:
.RS 4
.IP "\fB0, send_frame\fR" 4
.IX Item "0, send_frame"
output 1 frame fo' each frame
.IP "\fB1, send_field\fR" 4
.IX Item "1, send_field"
output 1 frame fo' each field
.IP "\fB2, send_frame_nospatial\fR" 4
.IX Item "2, send_frame_nospatial"
like \f(CW\*(C`send_frame\*(C'\fR but skip spatial interlacin check
.IP "\fB3, send_field_nospatial\fR" 4
.IX Item "3, send_field_nospatial"
like \f(CW\*(C`send_field\*(C'\fR but skip spatial interlacin check
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`send_frame\*(C'\fR.
.RE
.IP "\fBparity\fR" 4
.IX Item "parity"
Da picture field paritizzle assumed fo' tha input interlaced vizzle, accepts one of
the followin joints:
.RS 4
.IP "\fB0, tff\fR" 4
.IX Item "0, tff"
assume top field first
.IP "\fB1, bff\fR" 4
.IX Item "1, bff"
assume bottom field first
.IP "\fB\-1, auto\fR" 4
.IX Item "-1, auto"
enable automatic detection
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`auto\*(C'\fR.
If interlacin is unknown or decoder do not export dis shiznit,
top field first is ghon be assumed.
.RE
.IP "\fBdeint\fR" 4
.IX Item "deint"
Specify which frames ta deinterlace fo' realz. Accept one of tha following
values:
.RS 4
.IP "\fB0, all\fR" 4
.IX Item "0, all"
deinterlace all frames
.IP "\fB1, interlaced\fR" 4
.IX Item "1, interlaced"
only deinterlace frames marked as interlaced
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`all\*(C'\fR.
.RE
.SH "VIDEO SOURCES"
.IX Header "VIDEO SOURCES"
Below be a thugged-out description of tha currently available vizzle sources.
.SS "buffer"
.IX Subsection "buffer"
Buffer vizzle frames, n' make dem available ta tha filta chain.
.PP
This source is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/vsrc_buffer.h\fR.
.PP
This source accepts tha followin options:
.IP "\fBvideo_size\fR" 4
.IX Item "video_size"
Specify tha size (width n' height) of tha buffered vizzle frames. For the
syntax of dis option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils
manual.
.IP "\fBwidth\fR" 4
.IX Item "width"
Input vizzle width.
.IP "\fBheight\fR" 4
.IX Item "height"
Input vizzle height.
.IP "\fBpix_fmt\fR" 4
.IX Item "pix_fmt"
A strang representin tha pixel format of tha buffered vizzle frames.
It may be a number correspondin ta a pixel format, or a pixel format
name.
.IP "\fBtime_base\fR" 4
.IX Item "time_base"
Specify tha timebase assumed by tha timestampz of tha buffered frames.
.IP "\fBframe_rate\fR" 4
.IX Item "frame_rate"
Specify tha frame rate expected fo' tha vizzle stream.
.IP "\fBpixel_aspect, sar\fR" 4
.IX Item "pixel_aspect, sar"
Specify tha sample aspect ratio assumed by tha vizzle frames.
.IP "\fBsws_param\fR" 4
.IX Item "sws_param"
Specify tha optionizzle parametas ta be used fo' tha scale filta which
is automatically banged when a input chizzle is detected up in the
input size or format.
.PP
For example:
.PP
.Vb 1
\&        buffer=width=320:height=240:pix_fmt=yuv410p:time_base=1/24:sar=1
.Ve
.PP
will instruct tha source ta accept vizzle frames wit size 320x240 and
with format \*(L"yuv410p\*(R", assumin 1/24 as tha timestamps timebase and
square pixels (1:1 sample aspect ratio).
Since tha pixel format wit name \*(L"yuv410p\*(R" correspondz ta tha number 6
(check tha enum AVPixelFormat definizzle up in \fIlibavutil/pixfmt.h\fR),
this example correspondz to:
.PP
.Vb 1
\&        buffer=size=320x240:pixfmt=6:time_base=1/24:pixel_aspect=1/1
.Ve
.PP
Alternatively, tha options can be specified as a gangbangin' flat strin yo, but this
syntax is deprecated:
.PP
\&\fIwidth\fR:\fIheight\fR:\fIpix_fmt\fR:\fItime_base.num\fR:\fItime_base.den\fR:\fIpixel_aspect.num\fR:\fIpixel_aspect.den\fR[:\fIsws_param\fR]
.SS "cellauto"
.IX Subsection "cellauto"
Smoke a pattern generated by a elementary cellular automaton.
.PP
Da initial state of tha cellular automaton can be defined all up in the
\&\fBfilename\fR, n' \fBpattern\fR options. If such options are
not specified a initial state is pimped randomly.
.PP
At each freshly smoked up frame a freshly smoked up row up in tha vizzle is filled wit tha result of
the cellular automaton next generation. I aint talkin' bout chicken n' gravy biatch. Da behavior when tha whole
frame is filled is defined by tha \fBscroll\fR option.
.PP
This source accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Read tha initial cellular automaton state, i.e. tha startin row, from
the specified file.
In tha file, each non-whitespace characta is considered a kickin it
cell, a newline will terminizzle tha row, n' further charactas up in the
file is ghon be ignored.
.IP "\fBpattern, p\fR" 4
.IX Item "pattern, p"
Read tha initial cellular automaton state, i.e. tha startin row, from
the specified string.
.Sp
Each non-whitespace characta up in tha strang is considered a kickin it
cell, a newline will terminizzle tha row, n' further charactas up in the
strin is ghon be ignored.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha vizzle rate, dat is tha number of frames generated per second.
Default is 25.
.IP "\fBrandom_fill_ratio, ratio\fR" 4
.IX Item "random_fill_ratio, ratio"
Set tha random fill ratio fo' tha initial cellular automaton row. It
is a gangbangin' floatin point number value rangin from 0 ta 1, defaults to
1/PHI.
.Sp
This option is ignored when a gangbangin' file or a pattern is specified.
.IP "\fBrandom_seed, seed\fR" 4
.IX Item "random_seed, seed"
Set tha seed fo' fillin randomly tha initial row, must be a integer
included between 0 n' \s-1UINT32_MAX.\s0 If not specified, or if explicitly
set ta \-1, tha filta will try ta bust a phat random seed on a funky-ass best
effort basis.
.IP "\fBrule\fR" 4
.IX Item "rule"
Set tha cellular automaton rule, it aint nuthin but a number rangin from 0 ta 255.
Default value is 110.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha size of tha output vizzle. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.Sp
If \fBfilename\fR or \fBpattern\fR is specified, tha size is set
by default ta tha width of tha specified initial state row, n' the
height is set ta \fIwidth\fR * \s-1PHI.\s0
.Sp
If \fBsize\fR is set, it must contain tha width of tha specified
pattern string, n' tha specified pattern is ghon be centered up in the
larger row.
.Sp
If a gangbangin' filename or a pattern strang aint specified, tha size value
defaults ta \*(L"320x518\*(R" (used fo' a randomly generated initial state).
.IP "\fBscroll\fR" 4
.IX Item "scroll"
If set ta 1, scroll tha output upward when all tha rows up in tha output
have been already filled. Y'all KNOW dat shit, muthafucka! If set ta 0, tha freshly smoked up generated row will be
written over tha top row just afta tha bottom row is filled.
Defaults ta 1.
.IP "\fBstart_full, full\fR" 4
.IX Item "start_full, full"
If set ta 1, straight-up fill tha output wit generated rows before
outputtin tha straight-up original gangsta frame.
This is tha default behavior, fo' disablin set tha value ta 0.
.IP "\fBstitch\fR" 4
.IX Item "stitch"
If set ta 1, stitch tha left n' right row edges together.
This is tha default behavior, fo' disablin set tha value ta 0.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read tha initial state from \fIpattern\fR, n' specify a output of
size 200x400.
.Sp
.Vb 1
\&        cellauto=f=pattern:s=200x400
.Ve
.IP "\(bu" 4
Generate a random initial row wit a width of 200 cells, wit a gangbangin' fill
ratio of 2/3:
.Sp
.Vb 1
\&        cellauto=ratio=2/3:s=200x200
.Ve
.IP "\(bu" 4
Smoke a pattern generated by rule 18 startin by a single kickin it cell
centered on a initial row wit width 100:
.Sp
.Vb 1
\&        cellauto=p=@s=100x400:full=0:rule=18
.Ve
.IP "\(bu" 4
Specify a mo' elaborated initial pattern:
.Sp
.Vb 1
\&        cellauto=p=\*(Aq@@ @ @@\*(Aq:s=100x400:full=0:rule=18
.Ve
.SS "mandelbrot"
.IX Subsection "mandelbrot"
Generate a Mandelbrot set fractal, n' progressively zoom towardz the
point specified wit \fIstart_x\fR n' \fIstart_y\fR.
.PP
This source accepts tha followin options:
.IP "\fBend_pts\fR" 4
.IX Item "end_pts"
Set tha terminal pts value. Default value is 400.
.IP "\fBend_scale\fR" 4
.IX Item "end_scale"
Set tha terminal scale value.
Must be a gangbangin' floatin point value. Default value is 0.3.
.IP "\fBinner\fR" 4
.IX Item "inner"
Set tha inner colorin mode, dat is tha algorithm used ta draw the
Mandelbrot fractal internal region.
.Sp
It shall assume one of tha followin joints:
.RS 4
.IP "\fBblack\fR" 4
.IX Item "black"
Set black mode.
.IP "\fBconvergence\fR" 4
.IX Item "convergence"
Show time until convergence.
.IP "\fBmincol\fR" 4
.IX Item "mincol"
Set color based on point closest ta tha origin of tha iterations.
.IP "\fBperiod\fR" 4
.IX Item "period"
Set period mode.
.RE
.RS 4
.Sp
Default value is \fImincol\fR.
.RE
.IP "\fBbailout\fR" 4
.IX Item "bailout"
Set tha bailout value. Default value is 10.0.
.IP "\fBmaxiter\fR" 4
.IX Item "maxiter"
Set tha maximum of iterations performed by tha rendering
algorithm. Default value is 7189.
.IP "\fBouter\fR" 4
.IX Item "outer"
Set outa colorin mode.
It shall assume one of followin joints:
.RS 4
.IP "\fBiteration_count\fR" 4
.IX Item "iteration_count"
Set iteration cound mode.
.IP "\fBnormalized_iteration_count\fR" 4
.IX Item "normalized_iteration_count"
set normalized iteration count mode.
.RE
.RS 4
.Sp
Default value is \fInormalized_iteration_count\fR.
.RE
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set frame rate, expressed as number of frames per second. Y'all KNOW dat shit, muthafucka! Default
value is \*(L"25\*(R".
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set frame size. For tha syntax of dis option, check tha \*(L"Video
size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is \*(L"640x480\*(R".
.IP "\fBstart_scale\fR" 4
.IX Item "start_scale"
Set tha initial scale value. Default value is 3.0.
.IP "\fBstart_x\fR" 4
.IX Item "start_x"
Set tha initial x position. I aint talkin' bout chicken n' gravy biatch. Must be a gangbangin' floatin point value between
\&\-100 n' 100. Default value is \-0.743643887037158704752191506114774.
.IP "\fBstart_y\fR" 4
.IX Item "start_y"
Set tha initial y position. I aint talkin' bout chicken n' gravy biatch. Must be a gangbangin' floatin point value between
\&\-100 n' 100. Default value is \-0.131825904205311970493132056385139.
.SS "mptestsrc"
.IX Subsection "mptestsrc"
Generate various test patterns, as generated by tha MPlayer test filter.
.PP
Da size of tha generated vizzle is fixed, n' is 256x256.
This source is useful up in particular fo' testin encodin features.
.PP
This source accepts tha followin options:
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Specify tha frame rate of tha sourced vizzle, as tha number of frames
generated per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has ta be a strang up in tha format
\&\fIframe_rate_num\fR/\fIframe_rate_den\fR, a integer number, a gangbangin' float
number or a valid vizzle frame rate abbreviation. I aint talkin' bout chicken n' gravy biatch. Da default value is
\&\*(L"25\*(R".
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha vizzle duration of tha sourced vizzle. Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH:MM:SS[.m...]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
.Sp
If not specified, or tha expressed duration is negative, tha vizzle is
supposed ta be generated alllll muthafuckin day.
.IP "\fBtest, t\fR" 4
.IX Item "test, t"
Set tha number or tha name of tha test ta perform. Right back up in yo muthafuckin ass. Supported tests are:
.RS 4
.IP "\fBdc_luma\fR" 4
.IX Item "dc_luma"
.PD 0
.IP "\fBdc_chroma\fR" 4
.IX Item "dc_chroma"
.IP "\fBfreq_luma\fR" 4
.IX Item "freq_luma"
.IP "\fBfreq_chroma\fR" 4
.IX Item "freq_chroma"
.IP "\fBamp_luma\fR" 4
.IX Item "amp_luma"
.IP "\fBamp_chroma\fR" 4
.IX Item "amp_chroma"
.IP "\fBcbp\fR" 4
.IX Item "cbp"
.IP "\fBmv\fR" 4
.IX Item "mv"
.IP "\fBring1\fR" 4
.IX Item "ring1"
.IP "\fBring2\fR" 4
.IX Item "ring2"
.IP "\fBall\fR" 4
.IX Item "all"
.RE
.RS 4
.PD
.Sp
Default value is \*(L"all\*(R", which will cycle all up in tha list of all tests.
.RE
.PP
For example tha following:
.PP
.Vb 1
\&        testsrc=t=dc_luma
.Ve
.PP
will generate a \*(L"dc_luma\*(R" test pattern.
.SS "frei0r_src"
.IX Subsection "frei0r_src"
Provide a gangbangin' frei0r source.
.PP
To enable compilation of dis filta you need ta install tha frei0r
header n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-frei0r\*(C'\fR.
.PP
This source accepts tha followin options:
.IP "\fBsize\fR" 4
.IX Item "size"
Da size of tha vizzle ta generate. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.IP "\fBframerate\fR" 4
.IX Item "framerate"
Framerate of tha generated vizzle, may be a strang of tha form
\&\fInum\fR/\fIden\fR or a gangbangin' frame rate abbreviation.
.IP "\fBfilter_name\fR" 4
.IX Item "filter_name"
Da name ta tha frei0r source ta load. Y'all KNOW dat shit, muthafucka! For mo' shiznit regardin frei0r and
how ta set tha parametas read tha section frei0r up in tha description of
the vizzle filters.
.IP "\fBfilter_params\fR" 4
.IX Item "filter_params"
A '|'\-separated list of parametas ta pass ta tha frei0r source.
.PP
For example, ta generate a gangbangin' frei0r partik0l source wit size 200x200
and frame rate 10 which is overlayed on tha overlay filta main input:
.PP
.Vb 1
\&        frei0r_src=size=200x200:framerate=10:filter_name=partik0l:filter_params=1234 [overlay]; [in][overlay] overlay
.Ve
.SS "life"
.IX Subsection "life"
Generate a game pattern.
.PP
This source is based on a generalization of Jizzy Conwayz game game.
.PP
Da sourced input represents a game grid, each pixel represents a cold-ass lil cell
which can be up in one of two possible states, kickin it or dead as fuckin fried chicken. I aint talkin' bout chicken n' gravy biatch. Every cell
interacts wit its eight neighbours, which is tha cells dat are
horizontally, vertically, or diagonally adjacent.
.PP
At each interaction tha grid evolves accordin ta tha adopted rule,
which specifies tha number of neighbor kickin it cells which will make a
cell stay kickin it or born, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Da \fBrule\fR option allows ta specify
the rule ta adopt.
.PP
This source accepts tha followin options:
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha file from which ta read tha initial grid state. In tha file,
each non-whitespace characta is considered a kickin it cell, n' newline
is used ta delimit tha end of each row.
.Sp
If dis option aint specified, tha initial grid is generated
randomly.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha vizzle rate, dat is tha number of frames generated per second.
Default is 25.
.IP "\fBrandom_fill_ratio, ratio\fR" 4
.IX Item "random_fill_ratio, ratio"
Set tha random fill ratio fo' tha initial random grid. Y'all KNOW dat shit, muthafucka! Well shiiiit, it be a
floatin point number value rangin from 0 ta 1, defaults ta 1/PHI.
It be ignored when a gangbangin' file is specified.
.IP "\fBrandom_seed, seed\fR" 4
.IX Item "random_seed, seed"
Set tha seed fo' fillin tha initial random grid, must be a integer
included between 0 n' \s-1UINT32_MAX.\s0 If not specified, or if explicitly
set ta \-1, tha filta will try ta bust a phat random seed on a funky-ass best
effort basis.
.IP "\fBrule\fR" 4
.IX Item "rule"
Set tha game rule.
.Sp
A rule can be specified wit a cold-ass lil code of tha kind "S\fI\s-1NS\s0\fR/B\fI\s-1NB\s0\fR",
where \fI\s-1NS\s0\fR n' \fI\s-1NB\s0\fR is sequencez of numbers up in tha range 0\-8,
\&\fI\s-1NS\s0\fR specifies tha number of kickin it neighbor cells which make a
live cell stay kickin it, n' \fI\s-1NB\s0\fR tha number of kickin it neighbor cells
which cook up a thugged-out dead cell ta become kickin it (i.e. ta \*(L"born\*(R").
\&\*(L"s\*(R" n' \*(L"b\*(R" can be used up in place of \*(L"S\*(R" n' \*(L"B\*(R", respectively.
.Sp
Alternatively a rule can be specified by a 18\-bits integer n' shit. Da 9
high order bits is used ta encode tha next cell state if it is kickin it
for each number of neighbor kickin it cells, tha low order bits specify
the rule fo' \*(L"borning\*(R" freshly smoked up cells yo. Higher order bits encode fo' an
higher number of neighbor cells.
For example tha number 6153 = \f(CW\*(C`(12<<9)+9\*(C'\fR specifies a stay kickin it
rule of 12 n' a funky-ass born rule of 9, which correspondz ta \*(L"S23/B03\*(R".
.Sp
Default value is \*(L"S23/B3\*(R", which is tha original gangsta Conwayz game of game
rule, n' will keep a cold-ass lil cell kickin it if it has 2 or 3 neighbor kickin it
cells, n' will born a freshly smoked up cell if there be three kickin it cells around
a dead cell.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha size of tha output vizzle. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual.
.Sp
If \fBfilename\fR is specified, tha size is set by default ta the
same size of tha input file. If \fBsize\fR is set, it must contain
the size specified up in tha input file, n' tha initial grid defined in
that file is centered up in tha larger resultin area.
.Sp
If a gangbangin' filename aint specified, tha size value defaults ta \*(L"320x240\*(R"
(used fo' a randomly generated initial grid).
.IP "\fBstitch\fR" 4
.IX Item "stitch"
If set ta 1, stitch tha left n' right grid edges together, n' the
top n' bottom edges also. Defaults ta 1.
.IP "\fBmold\fR" 4
.IX Item "mold"
Set cell mold speed. Y'all KNOW dat shit, muthafucka! If set, a thugged-out dead cell will go from \fBdeath_color\fR to
\&\fBmold_color\fR wit a step of \fBmold\fR. \fBmold\fR can have a
value from 0 ta 255.
.IP "\fBlife_color\fR" 4
.IX Item "life_color"
Set tha color of livin (or freshly smoked up born) cells.
.IP "\fBdeath_color\fR" 4
.IX Item "death_color"
Set tha color of dead cells. If \fBmold\fR is set, dis is tha straight-up original gangsta color
used ta represent a thugged-out dead cell.
.IP "\fBmold_color\fR" 4
.IX Item "mold_color"
Set mold color, fo' definitely dead n' moldy cells.
.Sp
For tha syntax of these 3 color options, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Read a grid from \fIpattern\fR, n' centa it on a grid of size
300x300 pixels:
.Sp
.Vb 1
\&        game=f=pattern:s=300x300
.Ve
.IP "\(bu" 4
Generate a random grid of size 200x200, wit a gangbangin' fill ratio of 2/3:
.Sp
.Vb 1
\&        game=ratio=2/3:s=200x200
.Ve
.IP "\(bu" 4
Specify a cold-ass lil custom rule fo' evolvin a randomly generated grid:
.Sp
.Vb 1
\&        game=rule=S14/B34
.Ve
.IP "\(bu" 4
Full example wit slow dirtnap effect (mold) rockin \fBffplay\fR:
.Sp
.Vb 1
\&        ffplay \-f lavfi game=s=300x200:mold=10:r=60:ratio=0.1:death_color=#C83232:life_color=#00ff00,scale=1200:800:flags=16
.Ve
.SS "color, haldclutsrc, nullsrc, rgbtestsrc, smptebars, smptehdbars, testsrc"
.IX Subsection "color, haldclutsrc, nullsrc, rgbtestsrc, smptebars, smptehdbars, testsrc"
Da \f(CW\*(C`color\*(C'\fR source serves up a uniformly colored input.
.PP
Da \f(CW\*(C`haldclutsrc\*(C'\fR source serves up a identitizzle Hald \s-1CLUT.\s0 See also
haldclut filter.
.PP
Da \f(CW\*(C`nullsrc\*(C'\fR source returns unprocessed vizzle frames. Well shiiiit, it is
mainly useful ta be employed up in analysis / debuggin tools, or as the
source fo' filtas which ignore tha input data.
.PP
Da \f(CW\*(C`rgbtestsrc\*(C'\fR source generates a \s-1RGB\s0 test pattern useful for
detectin \s-1RGB\s0 vs \s-1BGR\s0 issues. Yo ass should peep a red, chronic n' blue
stripe from top ta bottom.
.PP
Da \f(CW\*(C`smptebars\*(C'\fR source generates a cold-ass lil color bars pattern, based on
the \s-1SMPTE\s0 Engineerin Guideline \s-1EG 1\-1990.\s0
.PP
Da \f(CW\*(C`smptehdbars\*(C'\fR source generates a cold-ass lil color bars pattern, based on
the \s-1SMPTE RP 219\-2002.\s0
.PP
Da \f(CW\*(C`testsrc\*(C'\fR source generates a test vizzle pattern, showin a
color pattern, a scrollin gradient n' a timestamp. This is mainly
intended fo' testin purposes.
.PP
Da sources accept tha followin options:
.IP "\fBcolor, c\fR" 4
.IX Item "color, c"
Specify tha color of tha source, only available up in tha \f(CW\*(C`color\*(C'\fR
source. For tha syntax of dis option, check tha \*(L"Color\*(R" section up in the
ffmpeg-utils manual.
.IP "\fBlevel\fR" 4
.IX Item "level"
Specify tha level of tha Hald \s-1CLUT,\s0 only available up in tha \f(CW\*(C`haldclutsrc\*(C'\fR
source fo' realz. A level of \f(CW\*(C`N\*(C'\fR generates a picture of \f(CW\*(C`N*N*N\*(C'\fR by \f(CW\*(C`N*N*N\*(C'\fR
pixels ta be used as identitizzle matrix fo' 3D lookup tables. Each component is
coded on a \f(CW\*(C`1/(N*N)\*(C'\fR scale.
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha size of tha sourced vizzle. For tha syntax of dis option, check the
\&\*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da default value is
\&\*(L"320x240\*(R".
.Sp
This option aint available wit tha \f(CW\*(C`haldclutsrc\*(C'\fR filter.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Specify tha frame rate of tha sourced vizzle, as tha number of frames
generated per second. Y'all KNOW dat shit, muthafucka! Well shiiiit, it has ta be a strang up in tha format
\&\fIframe_rate_num\fR/\fIframe_rate_den\fR, a integer number, a gangbangin' float
number or a valid vizzle frame rate abbreviation. I aint talkin' bout chicken n' gravy biatch. Da default value is
\&\*(L"25\*(R".
.IP "\fBsar\fR" 4
.IX Item "sar"
Set tha sample aspect ratio of tha sourced vizzle.
.IP "\fBduration, d\fR" 4
.IX Item "duration, d"
Set tha vizzle duration of tha sourced vizzle. Da accepted syntax is:
.Sp
.Vb 2
\&        [\-]HH[:MM[:SS[.m...]]]
\&        [\-]S+[.m...]
.Ve
.Sp
See also tha function \f(CW\*(C`av_parse_time()\*(C'\fR.
.Sp
If not specified, or tha expressed duration is negative, tha vizzle is
supposed ta be generated alllll muthafuckin day.
.IP "\fBdecimals, n\fR" 4
.IX Item "decimals, n"
Set tha number of decimals ta show up in tha timestamp, only available up in the
\&\f(CW\*(C`testsrc\*(C'\fR source.
.Sp
Da displayed timestamp value will correspond ta tha original
timestamp value multiplied by tha juice of 10 of tha specified
value. Default value is 0.
.PP
For example tha following:
.PP
.Vb 1
\&        testsrc=duration=5.3:size=qcif:rate=10
.Ve
.PP
will generate a vizzle wit a thugged-out duration of 5.3 seconds, wit size
176x144 n' a gangbangin' frame rate of 10 frames per second.
.PP
Da followin graph description will generate a red source
with a opacitizzle of 0.2, wit size \*(L"qcif\*(R" n' a gangbangin' frame rate of 10
frames per second.
.PP
.Vb 1
\&        color=c=red@0.2:s=qcif:r=10
.Ve
.PP
If tha input content is ta be ignored, \f(CW\*(C`nullsrc\*(C'\fR can be used. Y'all KNOW dat shit, muthafucka! The
followin command generates noise up in tha luminizzle plane by employing
the \f(CW\*(C`geq\*(C'\fR filter:
.PP
.Vb 1
\&        nullsrc=s=256x256, geq=random(1)*255:128:128
.Ve
.PP
\fICommands\fR
.IX Subsection "Commands"
.PP
Da \f(CW\*(C`color\*(C'\fR source supports tha followin commands:
.IP "\fBc, color\fR" 4
.IX Item "c, color"
Set tha color of tha pimped image fo' realz. Accepts tha same ol' dirty syntax of the
correspondin \fBcolor\fR option.
.SH "VIDEO SINKS"
.IX Header "VIDEO SINKS"
Below be a thugged-out description of tha currently available vizzle sinks.
.SS "buffersink"
.IX Subsection "buffersink"
Buffer vizzle frames, n' make dem available ta tha end of tha filter
graph.
.PP
This sink is mainly intended fo' a programmatic use, up in particular
all up in tha intercourse defined up in \fIlibavfilter/buffersink.h\fR
or tha options system.
.PP
It accepts a pointa ta a AVBufferSinkContext structure, which
defines tha incomin buffers' formats, ta be passed as tha opaque
parameta ta \f(CW\*(C`avfilter_init_filter\*(C'\fR fo' initialization.
.SS "nullsink"
.IX Subsection "nullsink"
Null vizzle sink, do straight-up not a god damn thang wit tha input vizzle. Well shiiiit, it is
mainly useful as a template n' ta be employed up in analysis / debugging
tools.
.SH "MULTIMEDIA FILTERS"
.IX Header "MULTIMEDIA FILTERS"
Below be a thugged-out description of tha currently available multimedia filters.
.SS "avectorscope"
.IX Subsection "avectorscope"
Convert input audio ta a vizzle output, representin tha audio vector
scope.
.PP
Da filta is used ta measure tha difference between channelz of stereo
audio stream fo' realz. A monoaural signal, consistin of identical left n' right
signal, thangs up in dis biatch up in straight vertical line fo' realz. Any stereo separation is visible
as a thugged-out deviation from dis line, bustin a Lissajous figure.
If tha straight (or deviation from it) but horizontal line appears this
indicates dat tha left n' right channels is outta phase.
.PP
Da filta accepts tha followin options:
.IP "\fBmode, m\fR" 4
.IX Item "mode, m"
Set tha vectorscope mode.
.Sp
Available joints are:
.RS 4
.IP "\fBlissajous\fR" 4
.IX Item "lissajous"
Lissajous rotated by 45 degrees.
.IP "\fBlissajous_xy\fR" 4
.IX Item "lissajous_xy"
Same as above but not rotated.
.RE
.RS 4
.Sp
Default value is \fBlissajous\fR.
.RE
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Set tha vizzle size fo' tha output. For tha syntax of dis option, check tha \*(L"Video size\*(R"
section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is \f(CW\*(C`400x400\*(C'\fR.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha output frame rate. Default value is \f(CW25\fR.
.IP "\fBrc\fR" 4
.IX Item "rc"
.PD 0
.IP "\fBgc\fR" 4
.IX Item "gc"
.IP "\fBbc\fR" 4
.IX Item "bc"
.PD
Specify tha red, chronic n' blue contrast. Default joints is \f(CW40\fR, \f(CW160\fR n' \f(CW80\fR.
Allowed range is \f(CW\*(C`[0, 255]\*(C'\fR.
.IP "\fBrf\fR" 4
.IX Item "rf"
.PD 0
.IP "\fBgf\fR" 4
.IX Item "gf"
.IP "\fBbf\fR" 4
.IX Item "bf"
.PD
Specify tha red, chronic n' blue fade. Default joints is \f(CW15\fR, \f(CW10\fR n' \f(CW5\fR.
Allowed range is \f(CW\*(C`[0, 255]\*(C'\fR.
.IP "\fBzoom\fR" 4
.IX Item "zoom"
Set tha zoom factor. Shiiit, dis aint no joke. Default value is \f(CW1\fR fo' realz. Allowed range is \f(CW\*(C`[1, 10]\*(C'\fR.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Complete example rockin \fBffplay\fR:
.Sp
.Vb 2
\&        ffplay \-f lavfi \*(Aqamovie=input.mp3, asplit [a][out1];
\&                     [a] avectorscope=zoom=1.3:rc=2:gc=200:bc=10:rf=1:gf=8:bf=7 [out0]\*(Aq
.Ve
.SS "concat"
.IX Subsection "concat"
Concatenate audio n' vizzle streams, joinin dem together one afta the
other.
.PP
Da filta works on segmentz of synchronized vizzle n' audio streams fo' realz. All
segments must have tha same number of streamz of each type, n' dat will
also be tha number of streams at output.
.PP
Da filta accepts tha followin options:
.IP "\fBn\fR" 4
.IX Item "n"
Set tha number of segments, n' you can put dat on yo' toast. Default is 2.
.IP "\fBv\fR" 4
.IX Item "v"
Set tha number of output vizzle streams, dat be also tha number of vizzle
streams up in each segment. Default is 1.
.IP "\fBa\fR" 4
.IX Item "a"
Set tha number of output audio streams, dat be also tha number of vizzle
streams up in each segment. Default is 0.
.IP "\fBunsafe\fR" 4
.IX Item "unsafe"
Activate unsafe mode: do not fail if segments gotz a gangbangin' finger-lickin' different format.
.PP
Da filta has \fIv\fR+\fIa\fR outputs: first \fIv\fR vizzle outputs, then
\&\fIa\fR audio outputs.
.PP
There is \fIn\fRx(\fIv\fR+\fIa\fR) inputs: first tha inputs fo' tha first
segment, up in tha same order as tha outputs, then tha inputs fo' tha second
segment, etc.
.PP
Related streams do not always have exactly tha same duration, fo' various
reasons includin codec frame size or sloppy authoring. For dat reason,
related synchronized streams (e.g. a vizzle n' its audio track) should be
concatenated at once. Da concat filta will use tha duration of tha longest
stream up in each segment (except tha last one), n' if necessary pad shorter
audio streams wit silence.
.PP
For dis filta ta work erectly, all segments must start at timestamp 0.
.PP
All correspondin streams must have tha same parametas up in all segments; the
filterin system will automatically select a cold-ass lil common pixel format fo' vizzle
streams, n' a cold-ass lil common sample format, sample rate n' channel layout for
audio streams yo, but other settings, like fuckin resolution, must be converted
explicitly by tha user.
.PP
Different frame rates is aaight but will result up in variable frame rate
at output; be shizzle ta configure tha output file ta handle dat shit.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Concatenate a opening, a episode n' a ending, all up in bilingual version
(video up in stream 0, audio up in streams 1 n' 2):
.Sp
.Vb 4
\&        ffmpeg \-i opening.mkv \-i episode.mkv \-i ending.mkv \-filter_complex \e
\&          \*(Aq[0:0] [0:1] [0:2] [1:0] [1:1] [1:2] [2:0] [2:1] [2:2]
\&           concat=n=3:v=1:a=2 [v] [a1] [a2]\*(Aq \e
\&          \-map \*(Aq[v]\*(Aq \-map \*(Aq[a1]\*(Aq \-map \*(Aq[a2]\*(Aq output.mkv
.Ve
.IP "\(bu" 4
Concatenate two parts, handlin audio n' vizzle separately, rockin the
(a)movie sources, n' adjustin tha resolution:
.Sp
.Vb 3
\&        porno=part1.mp4, scale=512:288 [v1] ; amovie=part1.mp4 [a1] ;
\&        porno=part2.mp4, scale=512:288 [v2] ; amovie=part2.mp4 [a2] ;
\&        [v1] [v2] concat [outv] ; [a1] [a2] concat=v=0:a=1 [outa]
.Ve
.Sp
Note dat a thugged-out desync will happen all up in tha stitch if tha audio n' vizzle streams
do not have exactly tha same duration up in tha straight-up original gangsta file.
.SS "ebur128"
.IX Subsection "ebur128"
\&\s-1EBU R128\s0 scanner filter n' shit. This filta takes a audio stream as input n' outputs
it unchanged. Y'all KNOW dat shit, muthafucka! By default, it logs a message at a gangbangin' frequency of 10Hz wit the
Momentary loudnizz (identified by \f(CW\*(C`M\*(C'\fR), Short-term loudnizz (\f(CW\*(C`S\*(C'\fR),
Integrated loudnizz (\f(CW\*(C`I\*(C'\fR) n' Loudnizz Range (\f(CW\*(C`LRA\*(C'\fR).
.PP
Da filta also has a vizzle output (see tha \fIvideo\fR option) wit a real
time graph ta observe tha loudnizz evolution. I aint talkin' bout chicken n' gravy biatch. Da graphic gotz nuff tha logged
message mentioned above, so it aint printed no mo' when dis option is set,
unless tha verbose loggin is set. Da main graphin area gotz nuff the
short-term loudnizz (3 secondz of analysis), n' tha gauge on tha right is for
the momentary loudnizz (400 milliseconds).
.PP
Mo' shiznit bout tha Loudnizz Recommendation \s-1EBU R128\s0 on
<\fBhttp://tech.ebu.ch/loudness\fR>.
.PP
Da filta accepts tha followin options:
.IP "\fBvideo\fR" 4
.IX Item "video"
Activate tha vizzle output. Da audio stream is passed unchanged whether this
option is set or no. Da vizzle stream is ghon be tha straight-up original gangsta output stream if
activated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Default is \f(CW0\fR.
.IP "\fBsize\fR" 4
.IX Item "size"
Set tha vizzle size. This option is fo' vizzle only. For tha syntax of this
option, check tha \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default
and minimum resolution is \f(CW\*(C`640x480\*(C'\fR.
.IP "\fBmeter\fR" 4
.IX Item "meter"
Set tha \s-1EBU\s0 scale meter n' shit. Default is \f(CW9\fR. Common joints is \f(CW9\fR and
\&\f(CW18\fR, respectively fo' \s-1EBU\s0 scale meta +9 n' \s-1EBU\s0 scale meta +18 fo' realz. Any
other integer value between dis range be allowed.
.IP "\fBmetadata\fR" 4
.IX Item "metadata"
Set metadata injection. I aint talkin' bout chicken n' gravy biatch. If set ta \f(CW1\fR, tha audio input is ghon be segmented
into 100ms output frames, each of dem containin various loudnizz shiznit
in metadata.  All tha metadata keys is prefixed wit \f(CW\*(C`lavfi.r128.\*(C'\fR.
.Sp
Default is \f(CW0\fR.
.IP "\fBframelog\fR" 4
.IX Item "framelog"
Force tha frame loggin level.
.Sp
Available joints are:
.RS 4
.IP "\fBinfo\fR" 4
.IX Item "info"
information loggin level
.IP "\fBverbose\fR" 4
.IX Item "verbose"
verbose loggin level
.RE
.RS 4
.Sp
By default, tha loggin level is set ta \fIinfo\fR. If tha \fBvideo\fR or
the \fBmetadata\fR options is set, it switches ta \fIverbose\fR.
.RE
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Real-time graph rockin \fBffplay\fR, wit a \s-1EBU\s0 scale meta +18:
.Sp
.Vb 1
\&        ffplay \-f lavfi \-i "amovie=input.mp3,ebur128=video=1:meter=18 [out0][out1]"
.Ve
.IP "\(bu" 4
Run a analysis wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-nostats \-i input.mp3 \-filter_complex ebur128 \-f null \-
.Ve
.SS "interleave, ainterleave"
.IX Subsection "interleave, ainterleave"
Temporally interleave frames from nuff muthafuckin inputs.
.PP
\&\f(CW\*(C`interleave\*(C'\fR works wit vizzle inputs, \f(CW\*(C`ainterleave\*(C'\fR wit audio.
.PP
These filtas read frames from nuff muthafuckin inputs n' bust tha oldest
queued frame ta tha output.
.PP
Input streams must gotz a well defined, monotonically increasin frame
timestamp joints.
.PP
In order ta submit one frame ta output, these filtas need ta enqueue
at least one frame fo' each input, so they cannot work up in case one
input aint yet terminated n' aint gonna receive incomin frames.
.PP
For example consider tha case when one input be a \f(CW\*(C`select\*(C'\fR filter
which always drop input frames. Da \f(CW\*(C`interleave\*(C'\fR filta will keep
readin from dat input yo, but it aint NEVER gonna be able ta bust freshly smoked up frames
to output until tha input will bust a end-of-stream signal.
.PP
Also, dependin on inputs synchronization, tha filtas will drop
frames up in case one input receives mo' frames than tha other ones, and
the queue be already filled.
.PP
These filtas accept tha followin options:
.IP "\fBnb_inputs, n\fR" 4
.IX Item "nb_inputs, n"
Set tha number of different inputs, it is 2 by default.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Interleave frames belongin ta different streams rockin \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i bambi.avi \-i pr0n.mkv \-filter_complex "[0:v][1:v] interleave" out.avi
.Ve
.IP "\(bu" 4
Add flickerin blur effect:
.Sp
.Vb 1
\&        select=\*(Aqif(gt(random(0), 0.2), 1, 2)\*(Aq:n=2 [tmp], boxblur=2:2, [tmp] interleave
.Ve
.SS "perms, aperms"
.IX Subsection "perms, aperms"
Set read/write permissions fo' tha output frames.
.PP
These filtas is mainly aimed at pimpers ta test direct path up in the
followin filta up in tha filtergraph.
.PP
Da filtas accept tha followin options:
.IP "\fBmode\fR" 4
.IX Item "mode"
Select tha permissions mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
Do nothing. This is tha default.
.IP "\fBro\fR" 4
.IX Item "ro"
Set all tha output frames read-only.
.IP "\fBrw\fR" 4
.IX Item "rw"
Set all tha output frames directly writable.
.IP "\fBtoggle\fR" 4
.IX Item "toggle"
Make tha frame read-only if writable, n' writable if read-only.
.IP "\fBrandom\fR" 4
.IX Item "random"
Set each output frame read-only or writable randomly.
.RE
.RS 4
.RE
.IP "\fBseed\fR" 4
.IX Item "seed"
Set tha seed fo' tha \fIrandom\fR mode, must be a integer included between
\&\f(CW0\fR n' \f(CW\*(C`UINT32_MAX\*(C'\fR. If not specified, or if explicitly set to
\&\f(CW\*(C`\-1\*(C'\fR, tha filta will try ta bust a phat random seed on a funky-ass dopest effort
basis.
.PP
Note: up in case of auto-inserted filta between tha permission filta n' the
followin one, tha permission might not be received as expected up in that
followin filter n' shit. Insertin a gangbangin' format or aformat filta before the
perms/aperms filta can avoid dis problem.
.SS "select, aselect"
.IX Subsection "select, aselect"
Select frames ta pass up in output.
.PP
This filta accepts tha followin options:
.IP "\fBexpr, e\fR" 4
.IX Item "expr, e"
Set expression, which is evaluated fo' each input frame.
.Sp
If tha expression is evaluated ta zero, tha frame is discarded.
.Sp
If tha evaluation result is wack or NaN, tha frame is busted ta the
first output; otherwise it is busted ta tha output wit index
\&\f(CW\*(C`ceil(val)\-1\*(C'\fR, assumin dat tha input index starts from 0.
.Sp
For example a value of \f(CW1.2\fR correspondz ta tha output wit index
\&\f(CW\*(C`ceil(1.2)\-1 = 2\-1 = 1\*(C'\fR, dat is tha second output.
.IP "\fBoutputs, n\fR" 4
.IX Item "outputs, n"
Set tha number of outputs, n' you can put dat on yo' toast. Da output ta which ta bust tha selected
frame is based on tha result of tha evaluation. I aint talkin' bout chicken n' gravy biatch. Default value is 1.
.PP
Da expression can contain tha followin constants:
.IP "\fBn\fR" 4
.IX Item "n"
the sequential number of tha filtered frame, startin from 0
.IP "\fBselected_n\fR" 4
.IX Item "selected_n"
the sequential number of tha selected frame, startin from 0
.IP "\fBprev_selected_n\fR" 4
.IX Item "prev_selected_n"
the sequential number of tha last selected frame, \s-1NAN\s0 if undefined
.IP "\fB\s-1TB\s0\fR" 4
.IX Item "TB"
timebase of tha input timestamps
.IP "\fBpts\fR" 4
.IX Item "pts"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in \fI\s-1TB\s0\fR units, \s-1NAN\s0 if undefined
.IP "\fBt\fR" 4
.IX Item "t"
the \s-1PTS \s0(Presentation TimeStamp) of tha filtered vizzle frame,
expressed up in seconds, \s-1NAN\s0 if undefined
.IP "\fBprev_pts\fR" 4
.IX Item "prev_pts"
the \s-1PTS\s0 of tha previously filtered vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBprev_selected_pts\fR" 4
.IX Item "prev_selected_pts"
the \s-1PTS\s0 of tha last previously filtered vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBprev_selected_t\fR" 4
.IX Item "prev_selected_t"
the \s-1PTS\s0 of tha last previously selected vizzle frame, \s-1NAN\s0 if undefined
.IP "\fBstart_pts\fR" 4
.IX Item "start_pts"
the \s-1PTS\s0 of tha straight-up original gangsta vizzle frame up in tha vizzle, \s-1NAN\s0 if undefined
.IP "\fBstart_t\fR" 4
.IX Item "start_t"
the time of tha straight-up original gangsta vizzle frame up in tha vizzle, \s-1NAN\s0 if undefined
.IP "\fBpict_type\fR \fI(video only)\fR" 4
.IX Item "pict_type (video only)"
the type of tha filtered frame, can assume one of tha following
values:
.RS 4
.IP "\fBI\fR" 4
.IX Item "I"
.PD 0
.IP "\fBP\fR" 4
.IX Item "P"
.IP "\fBB\fR" 4
.IX Item "B"
.IP "\fBS\fR" 4
.IX Item "S"
.IP "\fB\s-1SI\s0\fR" 4
.IX Item "SI"
.IP "\fB\s-1SP\s0\fR" 4
.IX Item "SP"
.IP "\fB\s-1BI\s0\fR" 4
.IX Item "BI"
.RE
.RS 4
.RE
.IP "\fBinterlace_type\fR \fI(video only)\fR" 4
.IX Item "interlace_type (video only)"
.PD
the frame interlace type, can assume one of tha followin joints:
.RS 4
.IP "\fB\s-1PROGRESSIVE\s0\fR" 4
.IX Item "PROGRESSIVE"
the frame is progressive (not interlaced)
.IP "\fB\s-1TOPFIRST\s0\fR" 4
.IX Item "TOPFIRST"
the frame is top-field-first
.IP "\fB\s-1BOTTOMFIRST\s0\fR" 4
.IX Item "BOTTOMFIRST"
the frame is bottom-field-first
.RE
.RS 4
.RE
.IP "\fBconsumed_sample_n\fR \fI(audio only)\fR" 4
.IX Item "consumed_sample_n (audio only)"
the number of selected samplez before tha current frame
.IP "\fBsamples_n\fR \fI(audio only)\fR" 4
.IX Item "samples_n (audio only)"
the number of samplez up in tha current frame
.IP "\fBsample_rate\fR \fI(audio only)\fR" 4
.IX Item "sample_rate (audio only)"
the input sample rate
.IP "\fBkey\fR" 4
.IX Item "key"
1 if tha filtered frame be a key-frame, 0 otherwise
.IP "\fBpos\fR" 4
.IX Item "pos"
the posizzle up in tha file of tha filtered frame, \-1 if tha shiznit
is not available (e.g. fo' synthetic vizzle)
.IP "\fBscene\fR \fI(video only)\fR" 4
.IX Item "scene (video only)"
value between 0 n' 1 ta indicate a freshly smoked up scene; a low value reflects a low
probabilitizzle fo' tha current frame ta introduce a freshly smoked up scene, while a higher
value means tha current frame is mo' likely ta be one (see tha example below)
.PP
Da default value of tha select expression is \*(L"1\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Select all frames up in input:
.Sp
.Vb 1
\&        select
.Ve
.Sp
Da example above is tha same ol' dirty as:
.Sp
.Vb 1
\&        select=1
.Ve
.IP "\(bu" 4
Skip all frames:
.Sp
.Vb 1
\&        select=0
.Ve
.IP "\(bu" 4
Select only I\-frames:
.Sp
.Vb 1
\&        select=\*(Aqeq(pict_type\e,I)\*(Aq
.Ve
.IP "\(bu" 4
Select one frame every last muthafuckin 100:
.Sp
.Vb 1
\&        select=\*(Aqnot(mod(n\e,100))\*(Aq
.Ve
.IP "\(bu" 4
Select only frames contained up in tha 10\-20 time interval:
.Sp
.Vb 1
\&        select=between(t\e,10\e,20)
.Ve
.IP "\(bu" 4
Select only I frames contained up in tha 10\-20 time interval:
.Sp
.Vb 1
\&        select=between(t\e,10\e,20)*eq(pict_type\e,I)
.Ve
.IP "\(bu" 4
Select frames wit a minimum distizzle of 10 seconds:
.Sp
.Vb 1
\&        select=\*(Aqisnan(prev_selected_t)+gte(t\-prev_selected_t\e,10)\*(Aq
.Ve
.IP "\(bu" 4
Use aselect ta select only audio frames wit samplez number > 100:
.Sp
.Vb 1
\&        aselect=\*(Aqgt(samples_n\e,100)\*(Aq
.Ve
.IP "\(bu" 4
Smoke a mosaic of tha straight-up original gangsta scenes:
.Sp
.Vb 1
\&        ffmpeg \-i vizzle.avi \-vf select=\*(Aqgt(scene\e,0.4)\*(Aq,scale=160:120,tile \-frames:v 1 peepshow.png
.Ve
.Sp
Comparin \fIscene\fR against a value between 0.3 n' 0.5 is generally a sane
choice.
.IP "\(bu" 4
Send even n' odd frames ta separate outputs, n' compose them:
.Sp
.Vb 1
\&        select=n=2:e=\*(Aqmod(n, 2)+1\*(Aq [odd][even]; [odd] pad=h=2*ih [tmp]; [tmp][even] overlay=y=h
.Ve
.SS "sendcmd, asendcmd"
.IX Subsection "sendcmd, asendcmd"
Send commandz ta filtas up in tha filtergraph.
.PP
These filtas read commandz ta be busted ta other filtas up in the
filtergraph.
.PP
\&\f(CW\*(C`sendcmd\*(C'\fR must be banged between two vizzle filters,
\&\f(CW\*(C`asendcmd\*(C'\fR must be banged between two audio filtas yo, but apart
from dat they act tha same way.
.PP
Da justification of commandz can be provided up in tha filta arguments
with tha \fIcommands\fR option, or up in a gangbangin' file specified by the
\&\fIfilename\fR option.
.PP
These filtas accept tha followin options:
.IP "\fBcommands, c\fR" 4
.IX Item "commands, c"
Set tha commandz ta be read n' busted ta tha other filters.
.IP "\fBfilename, f\fR" 4
.IX Item "filename, f"
Set tha filename of tha commandz ta be read n' busted ta tha other
filters.
.PP
\fICommandz syntax\fR
.IX Subsection "Commandz syntax"
.PP
A commandz description consistz of a sequence of interval
specifications, comprisin a list of commandz ta be executed when a
particular event related ta dat interval occurs. Da occurrin event
is typically tha current frame time enterin or leavin a given time
interval.
.PP
An interval is specified by tha followin syntax:
.PP
.Vb 1
\&        <START>[\-<END>] <COMMANDS>;
.Ve
.PP
Da time interval is specified by tha \fI\s-1START\s0\fR n' \fI\s-1END\s0\fR times.
\&\fI\s-1END\s0\fR is optionizzle n' defaults ta tha maximum time.
.PP
Da current frame time is considered within tha specified interval if
it is included up in tha interval [\fI\s-1START\s0\fR, \fI\s-1END\s0\fR), dat is when
the time is pimped outa or equal ta \fI\s-1START\s0\fR n' is lesser than
\&\fI\s-1END\s0\fR.
.PP
\&\fI\s-1COMMANDS\s0\fR consistz of a sequence of one or mo' command
specifications, separated by \*(L",\*(R", relatin ta dat interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  The
syntax of a cold-ass lil command justification is given by:
.PP
.Vb 1
\&        [<FLAGS>] <TARGET> <COMMAND> <ARG>
.Ve
.PP
\&\fI\s-1FLAGS\s0\fR is optionizzle n' specifies tha type of events relatin to
the time interval which enable bustin  tha specified command, n' must
be a non-null sequence of identifier flags separated by \*(L"+\*(R" or \*(L"|\*(R" and
enclosed between \*(L"[\*(R" n' \*(L"]\*(R".
.PP
Da followin flags is recognized:
.IP "\fBenter\fR" 4
.IX Item "enter"
Da command is busted when tha current frame timestamp entas the
specified interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In other lyrics, tha command is busted when the
previous frame timestamp was not up in tha given interval, n' the
current is.
.IP "\fBleave\fR" 4
.IX Item "leave"
Da command is busted when tha current frame timestamp leaves the
specified interval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. In other lyrics, tha command is busted when the
previous frame timestamp was up in tha given interval, n' the
current is not.
.PP
If \fI\s-1FLAGS\s0\fR aint specified, a thugged-out default value of \f(CW\*(C`[enter]\*(C'\fR is
assumed.
.PP
\&\fI\s-1TARGET\s0\fR specifies tha target of tha command, probably tha name of
the filta class or a specific filta instizzle name.
.PP
\&\fI\s-1COMMAND\s0\fR specifies tha name of tha command fo' tha target filter.
.PP
\&\fI\s-1ARG\s0\fR is optionizzle n' specifies tha optionizzle list of argument for
the given \fI\s-1COMMAND\s0\fR.
.PP
Between one interval justification n' another, whitespaces, or
sequencez of charactas startin wit \f(CW\*(C`#\*(C'\fR until tha end of line,
are ignored n' can be used ta annotate comments.
.PP
A simplified \s-1BNF\s0 description of tha commandz justification syntax
bigs up:
.PP
.Vb 6
\&        <COMMAND_FLAG>  ::= "enter" | "leave"
\&        <COMMAND_FLAGS> ::= <COMMAND_FLAG> [(+|"|")<COMMAND_FLAG>]
\&        <COMMAND>       ::= ["[" <COMMAND_FLAGS> "]"] <TARGET> <COMMAND> [<ARG>]
\&        <COMMANDS>      ::= <COMMAND> [,<COMMANDS>]
\&        <INTERVAL>      ::= <START>[\-<END>] <COMMANDS>
\&        <INTERVALS>     ::= <INTERVAL>[;<INTERVALS>]
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Specify audio tempo chizzle at second 4:
.Sp
.Vb 1
\&        asendcmd=c=\*(Aq4.0 atempo tempo 1.5\*(Aq,atempo
.Ve
.IP "\(bu" 4
Specify a list of drawtext n' hue commandz up in a gangbangin' file.
.Sp
.Vb 3
\&        # show text up in tha interval 5\-10
\&        5.0\-10.0 [enter] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=wassup ghetto\*(Aq,
\&                 [leave] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=\*(Aq;
\&        
\&        # desaturate tha image up in tha interval 15\-20
\&        15.0\-20.0 [enter] hue s 0,
\&                  [enter] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=nocolor\*(Aq,
\&                  [leave] hue s 1,
\&                  [leave] drawtext reinit \*(Aqfontfile=FreeSerif.ttf:text=color\*(Aq;
\&        
\&        # apply a exponential saturation fade\-out effect, startin from time 25
\&        25 [enter] hue s exp(25\-t)
.Ve
.Sp
A filtergraph allowin ta read n' process tha above command list
stored up in a gangbangin' file \fItest.cmd\fR, can be specified with:
.Sp
.Vb 1
\&        sendcmd=f=test.cmd,drawtext=fontfile=FreeSerif.ttf:text=\*(Aq\*(Aq,hue
.Ve
.SS "setpts, asetpts"
.IX Subsection "setpts, asetpts"
Change tha \s-1PTS \s0(presentation timestamp) of tha input frames.
.PP
\&\f(CW\*(C`setpts\*(C'\fR works on vizzle frames, \f(CW\*(C`asetpts\*(C'\fR on audio frames.
.PP
This filta accepts tha followin options:
.IP "\fBexpr\fR" 4
.IX Item "expr"
Da expression which is evaluated fo' each frame ta construct its timestamp.
.PP
Da expression is evaluated all up in tha eval \s-1API\s0 n' can contain tha following
constants:
.IP "\fB\s-1FRAME_RATE\s0\fR" 4
.IX Item "FRAME_RATE"
frame rate, only defined fo' constant frame-rate vizzle
.IP "\fB\s-1PTS\s0\fR" 4
.IX Item "PTS"
the presentation timestamp up in input
.IP "\fBN\fR" 4
.IX Item "N"
the count of tha input frame fo' vizzle or tha number of consumed samples,
not includin tha current frame fo' audio, startin from 0.
.IP "\fB\s-1NB_CONSUMED_SAMPLES\s0\fR" 4
.IX Item "NB_CONSUMED_SAMPLES"
the number of consumed samples, not includin tha current frame (only
audio)
.IP "\fB\s-1NB_SAMPLES, S\s0\fR" 4
.IX Item "NB_SAMPLES, S"
the number of samplez up in tha current frame (only audio)
.IP "\fB\s-1SAMPLE_RATE, SR\s0\fR" 4
.IX Item "SAMPLE_RATE, SR"
audio sample rate
.IP "\fB\s-1STARTPTS\s0\fR" 4
.IX Item "STARTPTS"
the \s-1PTS\s0 of tha straight-up original gangsta frame
.IP "\fB\s-1STARTT\s0\fR" 4
.IX Item "STARTT"
the time up in secondz of tha straight-up original gangsta frame
.IP "\fB\s-1INTERLACED\s0\fR" 4
.IX Item "INTERLACED"
tell if tha current frame is interlaced
.IP "\fBT\fR" 4
.IX Item "T"
the time up in secondz of tha current frame
.IP "\fB\s-1POS\s0\fR" 4
.IX Item "POS"
original gangsta posizzle up in tha file of tha frame, or undefined if undefined
for tha current frame
.IP "\fB\s-1PREV_INPTS\s0\fR" 4
.IX Item "PREV_INPTS"
previous input \s-1PTS\s0
.IP "\fB\s-1PREV_INT\s0\fR" 4
.IX Item "PREV_INT"
previous input time up in seconds
.IP "\fB\s-1PREV_OUTPTS\s0\fR" 4
.IX Item "PREV_OUTPTS"
previous output \s-1PTS\s0
.IP "\fB\s-1PREV_OUTT\s0\fR" 4
.IX Item "PREV_OUTT"
previous output time up in seconds
.IP "\fB\s-1RTCTIME\s0\fR" 4
.IX Item "RTCTIME"
wallclock (\s-1RTC\s0) time up in microseconds. This is deprecated, use \fItime\fR\|(0)
instead.
.IP "\fB\s-1RTCSTART\s0\fR" 4
.IX Item "RTCSTART"
wallclock (\s-1RTC\s0) time all up in tha start of tha porno up in microseconds
.IP "\fB\s-1TB\s0\fR" 4
.IX Item "TB"
timebase of tha input timestamps
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Start countin \s-1PTS\s0 from zero
.Sp
.Vb 1
\&        setpts=PTS\-STARTPTS
.Ve
.IP "\(bu" 4
Apply fast motion effect:
.Sp
.Vb 1
\&        setpts=0.5*PTS
.Ve
.IP "\(bu" 4
Apply slow motion effect:
.Sp
.Vb 1
\&        setpts=2.0*PTS
.Ve
.IP "\(bu" 4
Set fixed rate of 25 frames per second:
.Sp
.Vb 1
\&        setpts=N/(25*TB)
.Ve
.IP "\(bu" 4
Set fixed rate 25 fps wit some jitter:
.Sp
.Vb 1
\&        setpts=\*(Aq1/(25*TB) * (N + 0.05 * sin(N*2*PI/25))\*(Aq
.Ve
.IP "\(bu" 4
Apply a offset of 10 secondz ta tha input \s-1PTS:\s0
.Sp
.Vb 1
\&        setpts=PTS+10/TB
.Ve
.IP "\(bu" 4
Generate timestamps from a \*(L"live source\*(R" n' rebase onto tha current timebase:
.Sp
.Vb 1
\&        setpts=\*(Aq(RTCTIME \- RTCSTART) / (TB * 1000000)\*(Aq
.Ve
.IP "\(bu" 4
Generate timestamps by countin samples:
.Sp
.Vb 1
\&        asetpts=N/SR/TB
.Ve
.SS "settb, asettb"
.IX Subsection "settb, asettb"
Set tha timebase ta use fo' tha output frames timestamps.
It be mainly useful fo' testin timebase configuration.
.PP
This filta accepts tha followin options:
.IP "\fBexpr, tb\fR" 4
.IX Item "expr, tb"
Da expression which is evaluated tha fuck into tha output timebase.
.PP
Da value fo' \fBtb\fR be a arithmetic expression representin a
rational. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da expression can contain tha constants \*(L"\s-1AVTB\*(R" \s0(the default
timebase), \*(L"intb\*(R" (the input timebase) n' \*(L"sr\*(R" (the sample rate,
audio only). Default value is \*(L"intb\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Set tha timebase ta 1/25:
.Sp
.Vb 1
\&        settb=expr=1/25
.Ve
.IP "\(bu" 4
Set tha timebase ta 1/10:
.Sp
.Vb 1
\&        settb=expr=0.1
.Ve
.IP "\(bu" 4
Set tha timebase ta 1001/1000:
.Sp
.Vb 1
\&        settb=1+0.001
.Ve
.IP "\(bu" 4
Set tha timebase ta 2*intb:
.Sp
.Vb 1
\&        settb=2*intb
.Ve
.IP "\(bu" 4
Set tha default timebase value:
.Sp
.Vb 1
\&        settb=AVTB
.Ve
.SS "showspectrum"
.IX Subsection "showspectrum"
Convert input audio ta a vizzle output, representin tha audio frequency
spectrum.
.PP
Da filta accepts tha followin options:
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha vizzle size fo' tha output. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value is
\&\f(CW\*(C`640x512\*(C'\fR.
.IP "\fBslide\fR" 4
.IX Item "slide"
Specify if tha spectrum should slide along tha window. Default value is
\&\f(CW0\fR.
.IP "\fBmode\fR" 4
.IX Item "mode"
Specify display mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBcombined\fR" 4
.IX Item "combined"
all channels is displayed up in tha same row
.IP "\fBseparate\fR" 4
.IX Item "separate"
all channels is displayed up in separate rows
.RE
.RS 4
.Sp
Default value is \fBcombined\fR.
.RE
.IP "\fBcolor\fR" 4
.IX Item "color"
Specify display color mode.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBchannel\fR" 4
.IX Item "channel"
each channel is displayed up in a separate color
.IP "\fBintensity\fR" 4
.IX Item "intensity"
each channel is is displayed rockin tha same color scheme
.RE
.RS 4
.Sp
Default value is \fBchannel\fR.
.RE
.IP "\fBscale\fR" 4
.IX Item "scale"
Specify scale used fo' calculatin intensitizzle color joints.
.Sp
It accepts tha followin joints:
.RS 4
.IP "\fBlin\fR" 4
.IX Item "lin"
linear
.IP "\fBsqrt\fR" 4
.IX Item "sqrt"
square root, default
.IP "\fBcbrt\fR" 4
.IX Item "cbrt"
cubic root
.IP "\fBlog\fR" 4
.IX Item "log"
logarithmic
.RE
.RS 4
.Sp
Default value is \fBsqrt\fR.
.RE
.IP "\fBsaturation\fR" 4
.IX Item "saturation"
Set saturation modifier fo' displayed colors. Negatizzle joints provide
alternatizzle color scheme. \f(CW0\fR is no saturation at all.
Saturation must be up in [\-10.0, 10.0] range.
Default value is \f(CW1\fR.
.PP
Da usage is straight-up similar ta tha showwaves filter; peep tha examplez up in that
section.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Big-Ass window wit logarithmic color scaling:
.Sp
.Vb 1
\&        showspectrum=s=1280x480:scale=log
.Ve
.IP "\(bu" 4
Complete example fo' a cold-ass lil colored n' slidin spectrum per channel rockin \fBffplay\fR:
.Sp
.Vb 2
\&        ffplay \-f lavfi \*(Aqamovie=input.mp3, asplit [a][out1];
\&                     [a] showspectrum=mode=separate:color=intensity:slide=1:scale=cbrt [out0]\*(Aq
.Ve
.SS "showwaves"
.IX Subsection "showwaves"
Convert input audio ta a vizzle output, representin tha samplez waves.
.PP
Da filta accepts tha followin options:
.IP "\fBsize, s\fR" 4
.IX Item "size, s"
Specify tha vizzle size fo' tha output. For tha syntax of dis option, check
the \*(L"Video size\*(R" section up in tha ffmpeg-utils manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Default value
is \*(L"600x240\*(R".
.IP "\fBmode\fR" 4
.IX Item "mode"
Set display mode.
.Sp
Available joints are:
.RS 4
.IP "\fBpoint\fR" 4
.IX Item "point"
Draw a point fo' each sample.
.IP "\fBline\fR" 4
.IX Item "line"
Draw a vertical line fo' each sample.
.RE
.RS 4
.Sp
Default value is \f(CW\*(C`point\*(C'\fR.
.RE
.IP "\fBn\fR" 4
.IX Item "n"
Set tha number of samplez which is printed on tha same column. I aint talkin' bout chicken n' gravy biatch fo' realz. A
larger value will decrease tha frame rate. Must be a positive
integer n' shit. This option can be set only if tha value fo' \fIrate\fR
is not explicitly specified.
.IP "\fBrate, r\fR" 4
.IX Item "rate, r"
Set tha (approximate) output frame rate. This is done by settin the
option \fIn\fR. Default value is \*(L"25\*(R".
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Output tha input file audio n' tha correspondin vizzle representation
at tha same time:
.Sp
.Vb 1
\&        amovie=a.mp3,asplit[out0],showwaves[out1]
.Ve
.IP "\(bu" 4
Smoke a synthetic signal n' show it wit showwaves, forcin a
frame rate of 30 frames per second:
.Sp
.Vb 1
\&        aevalsrc=sin(1*2*PI*t)*sin(880*2*PI*t):cos(2*PI*200*t),asplit[out0],showwaves=r=30[out1]
.Ve
.SS "split, asplit"
.IX Subsection "split, asplit"
Split input tha fuck into nuff muthafuckin identical outputs.
.PP
\&\f(CW\*(C`asplit\*(C'\fR works wit audio input, \f(CW\*(C`split\*(C'\fR wit vizzle.
.PP
Da filta accepts a single parameta which specifies tha number of outputs, n' you can put dat on yo' toast. If
unspecified, it defaults ta 2.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Smoke two separate outputs from tha same input:
.Sp
.Vb 1
\&        [in] split [out0][out1]
.Ve
.IP "\(bu" 4
To create 3 or mo' outputs, you need ta specify tha number of
outputs, like in:
.Sp
.Vb 1
\&        [in] asplit=3 [out0][out1][out2]
.Ve
.IP "\(bu" 4
Smoke two separate outputs from tha same input, one cropped and
one padded:
.Sp
.Vb 3
\&        [in] split [splitout1][splitout2];
\&        [splitout1] crop=100:100:0:0    [cropout];
\&        [splitout2] pad=200:200:100:100 [padout];
.Ve
.IP "\(bu" 4
Smoke 5 copiez of tha input audio wit \fBffmpeg\fR:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-filter_complex asplit=5 OUTPUT
.Ve
.SS "zmq, azmq"
.IX Subsection "zmq, azmq"
Receive commandz busted all up in a libzmq client, n' forward dem to
filtas up in tha filtergraph.
.PP
\&\f(CW\*(C`zmq\*(C'\fR n' \f(CW\*(C`azmq\*(C'\fR work as a pass-all up in filters. \f(CW\*(C`zmq\*(C'\fR
must be banged between two vizzle filters, \f(CW\*(C`azmq\*(C'\fR between two
audio filters.
.PP
To enable these filtas you need ta install tha libzmq library and
headaz n' configure FFmpeg wit \f(CW\*(C`\-\-enable\-libzmq\*(C'\fR.
.PP
For mo' shiznit bout libzmq see:
<\fBhttp://www.zeromq.org/\fR>
.PP
Da \f(CW\*(C`zmq\*(C'\fR n' \f(CW\*(C`azmq\*(C'\fR filtas work as a libzmq server, which
receives lyrics busted all up in a network intercourse defined by the
\&\fBbind_address\fR option.
.PP
Da received message must be up in tha form:
.PP
.Vb 1
\&        <TARGET> <COMMAND> [<ARG>]
.Ve
.PP
\&\fI\s-1TARGET\s0\fR specifies tha target of tha command, probably tha name of
the filta class or a specific filta instizzle name.
.PP
\&\fI\s-1COMMAND\s0\fR specifies tha name of tha command fo' tha target filter.
.PP
\&\fI\s-1ARG\s0\fR is optionizzle n' specifies tha optionizzle argument list fo' the
given \fI\s-1COMMAND\s0\fR.
.PP
Upon reception, tha message is processed n' tha correspondin command
is injected tha fuck into tha filtergraph. Dependin on tha result, tha filter
will bust a reply ta tha client, adoptin tha format:
.PP
.Vb 2
\&        <ERROR_CODE> <ERROR_REASON>
\&        <MESSAGE>
.Ve
.PP
\&\fI\s-1MESSAGE\s0\fR is optional.
.PP
\fIExamples\fR
.IX Subsection "Examples"
.PP
Look at \fItools/zmqsend\fR fo' a example of a zmq client which can
be used ta bust commandz processed by these filters.
.PP
Consider tha followin filtergraph generated by \fBffplay\fR
.PP
.Vb 6
\&        ffplay \-dumpgraph 1 \-f lavfi "
\&        color=s=100x100:c=red  [l];
\&        color=s=100x100:c=blue [r];
\&        nullsrc=s=200x100, zmq [bg];
\&        [bg][l]   overlay      [bg+l];
\&        [bg+l][r] overlay=x=100 "
.Ve
.PP
To chizzle tha color of tha left side of tha vizzle, tha following
command can be used:
.PP
.Vb 1
\&        echo Parsed_color_0 c yellow | tools/zmqsend
.Ve
.PP
To chizzle tha right side:
.PP
.Vb 1
\&        echo Parsed_color_1 c pink | tools/zmqsend
.Ve
.SH "MULTIMEDIA SOURCES"
.IX Header "MULTIMEDIA SOURCES"
Below be a thugged-out description of tha currently available multimedia sources.
.SS "amovie"
.IX Subsection "amovie"
This is tha same ol' dirty as porno source, except it selects a audio
stream by default.
.SS "movie"
.IX Subsection "movie"
Read audio and/or vizzle stream(s) from a porno container.
.PP
This filta accepts tha followin options:
.IP "\fBfilename\fR" 4
.IX Item "filename"
Da name of tha resource ta read (not necessarily a gangbangin' file but also a thang or a
stream accessed all up in some protocol).
.IP "\fBformat_name, f\fR" 4
.IX Item "format_name, f"
Specifies tha format assumed fo' tha porno ta read, n' can be either
the name of a cold-ass lil container or a input device. If not specified the
format is guessed from \fImovie_name\fR or by probing.
.IP "\fBseek_point, sp\fR" 4
.IX Item "seek_point, sp"
Specifies tha seek point up in seconds, tha frames is ghon be output
startin from dis seek point, tha parameta is evaluated with
\&\f(CW\*(C`av_strtod\*(C'\fR so tha numerical value may be suffixed by a \s-1IS\s0
postfix. Default value is \*(L"0\*(R".
.IP "\fBstreams, s\fR" 4
.IX Item "streams, s"
Specifies tha streams ta read. Y'all KNOW dat shit, muthafucka! Several streams can be specified,
separated by \*(L"+\*(R". Da source will then have as nuff outputs, up in the
same order n' shit. Da syntax is explained up in tha ``Stream specifiers''
section up in tha ffmpeg manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Two special names, \*(L"dv\*(R" n' \*(L"da\*(R" specify
respectively tha default (best suited) vizzle n' audio stream. Default
is \*(L"dv\*(R", or \*(L"da\*(R" if tha filta is called as \*(L"amovie\*(R".
.IP "\fBstream_index, si\fR" 4
.IX Item "stream_index, si"
Specifies tha index of tha vizzle stream ta read. Y'all KNOW dat shit, muthafucka! If tha value is \-1,
the dopest suited vizzle stream is ghon be automatically selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Default
value is \*(L"\-1\*(R". Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha filta is called \*(L"amovie\*(R", it will select
audio instead of vizzle.
.IP "\fBloop\fR" 4
.IX Item "loop"
Specifies how tha fuck nuff times ta read tha stream up in sequence.
If tha value is less than 1, tha stream is ghon be read again n' again n' again n' again.
Default value is \*(L"1\*(R".
.Sp
Note dat when tha porno is looped tha source timestamps is not
changed, so it will generate non monotonically increasin timestamps.
.PP
This filta allows ta overlay a second vizzle on top of main input of
a filtergraph as shown up in dis graph:
.PP
.Vb 4
\&        input \-\-\-\-\-\-\-\-\-\-\-> deltapts0 \-\-> overlay \-\-> output
\&                                            ^
\&                                            |
\&        porno \-\-> scale\-\-> deltapts1 \-\-\-\-\-\-\-+
.Ve
.PP
\fIExamples\fR
.IX Subsection "Examples"
.IP "\(bu" 4
Skip 3.2 secondz from tha start of tha avi file in.avi, n' overlay it
on top of tha input labelled as \*(L"in\*(R":
.Sp
.Vb 3
\&        porno=in.avi:seek_point=3.2, scale=180:\-1, setpts=PTS\-STARTPTS [over];
\&        [in] setpts=PTS\-STARTPTS [main];
\&        [main][over] overlay=16:16 [out]
.Ve
.IP "\(bu" 4
Read from a vizzle4linux2 device, n' overlay it on top of tha input
labelled as \*(L"in\*(R":
.Sp
.Vb 3
\&        porno=/dev/video0:f=video4linux2, scale=180:\-1, setpts=PTS\-STARTPTS [over];
\&        [in] setpts=PTS\-STARTPTS [main];
\&        [main][over] overlay=16:16 [out]
.Ve
.IP "\(bu" 4
Read tha straight-up original gangsta vizzle stream n' tha audio stream wit id 0x81 from
dvd.vob; tha vizzle is connected ta tha pad named \*(L"video\*(R" n' tha audio is
connected ta tha pad named \*(L"audio\*(R":
.Sp
.Vb 1
\&        porno=dvd.vob:s=v:0+#0x81 [video] [audio]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavfilter\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
