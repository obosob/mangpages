.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ3 1"
.TH PERLFAQ3 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq3 \- Programmin Tools
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of tha \s-1FAQ\s0 lyrics thangs related ta programmer tools
and programmin support.
.SS "How tha fuck do I do (anything)?"
.IX Subsection "How tha fuck do I do (anything)?"
Has you done looked at \s-1CPAN \s0(see perlfaq2)? Da chances is that
someone has already freestyled a module dat can solve yo' problem.
Has you done read tha appropriate manpages? Herez a funky-ass brief index:
.IP "Basics" 4
.IX Item "Basics"
.RS 4
.PD 0
.IP "perldata \- Perl data types" 4
.IX Item "perldata - Perl data types"
.IP "perlvar \- Perl pre-defined variables" 4
.IX Item "perlvar - Perl pre-defined variables"
.IP "perlsyn \- Perl syntax" 4
.IX Item "perlsyn - Perl syntax"
.IP "perlop \- Perl operators n' precedence" 4
.IX Item "perlop - Perl operators n' precedence"
.IP "perlsub \- Perl subroutines" 4
.IX Item "perlsub - Perl subroutines"
.RE
.RS 4
.RE
.IP "Execution" 4
.IX Item "Execution"
.RS 4
.IP "perlrun \- how tha fuck ta execute tha Perl interpreter" 4
.IX Item "perlrun - how tha fuck ta execute tha Perl interpreter"
.IP "perldebug \- Perl debugging" 4
.IX Item "perldebug - Perl debugging"
.RE
.RS 4
.RE
.IP "Functions" 4
.IX Item "Functions"
.RS 4
.IP "perlfunc \- Perl builtin functions" 4
.IX Item "perlfunc - Perl builtin functions"
.RE
.RS 4
.RE
.IP "Objects" 4
.IX Item "Objects"
.RS 4
.IP "perlref \- Perl references n' nested data structures" 4
.IX Item "perlref - Perl references n' nested data structures"
.IP "perlmod \- Perl modulez (packages n' symbol tables)" 4
.IX Item "perlmod - Perl modulez (packages n' symbol tables)"
.IP "perlobj \- Perl objects" 4
.IX Item "perlobj - Perl objects"
.IP "perltie \- how tha fuck ta hide a object class up in a simple variable" 4
.IX Item "perltie - how tha fuck ta hide a object class up in a simple variable"
.RE
.RS 4
.RE
.IP "Data Structures" 4
.IX Item "Data Structures"
.RS 4
.IP "perlref \- Perl references n' nested data structures" 4
.IX Item "perlref - Perl references n' nested data structures"
.IP "perllol \- Manipulatin arrayz of arrays up in Perl" 4
.IX Item "perllol - Manipulatin arrayz of arrays up in Perl"
.IP "perldsc \- Perl Data Structures Cookbook" 4
.IX Item "perldsc - Perl Data Structures Cookbook"
.RE
.RS 4
.RE
.IP "Modules" 4
.IX Item "Modules"
.RS 4
.IP "perlmod \- Perl modulez (packages n' symbol tables)" 4
.IX Item "perlmod - Perl modulez (packages n' symbol tables)"
.IP "perlmodlib \- constructin freshly smoked up Perl modulez n' findin existin ones" 4
.IX Item "perlmodlib - constructin freshly smoked up Perl modulez n' findin existin ones"
.RE
.RS 4
.RE
.IP "Regexes" 4
.IX Item "Regexes"
.RS 4
.IP "perlre \- Perl regular expressions" 4
.IX Item "perlre - Perl regular expressions"
.IP "perlfunc \- Perl builtin functions>" 4
.IX Item "perlfunc - Perl builtin functions>"
.IP "perlop \- Perl operators n' precedence" 4
.IX Item "perlop - Perl operators n' precedence"
.IP "perllocale \- Perl locale handlin (internationalization n' localization)" 4
.IX Item "perllocale - Perl locale handlin (internationalization n' localization)"
.RE
.RS 4
.RE
.IP "Movin ta perl5" 4
.IX Item "Movin ta perl5"
.RS 4
.IP "perltrap \- Perl traps fo' tha unwary" 4
.IX Item "perltrap - Perl traps fo' tha unwary"
.IP "perl" 4
.IX Item "perl"
.RE
.RS 4
.RE
.IP "Linkin wit C" 4
.IX Item "Linkin wit C"
.RS 4
.IP "perlxstut \- Tutorial fo' freestylin XSUBs" 4
.IX Item "perlxstut - Tutorial fo' freestylin XSUBs"
.IP "perlxs \- \s-1XS\s0 language reference manual" 4
.IX Item "perlxs - XS language reference manual"
.IP "perlcall \- Perl callin conventions from C" 4
.IX Item "perlcall - Perl callin conventions from C"
.IP "perlguts \- Introduction ta tha Perl \s-1API\s0" 4
.IX Item "perlguts - Introduction ta tha Perl API"
.IP "perlembed \- how tha fuck ta embed perl up in yo' C program" 4
.IX Item "perlembed - how tha fuck ta embed perl up in yo' C program"
.RE
.RS 4
.RE
.IP "Various" 4
.IX Item "Various"
.PD
<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>
(not a man-page but still useful, a cold-ass lil collection of various essays on
Perl steez)
.PP
A crude table of contents fo' tha Perl manpage set is found up in perltoc.
.SS "How tha fuck can I use Perl interactively?"
.IX Subsection "How tha fuck can I use Perl interactively?"
Da typical approach uses tha Perl debugger, busted lyrics bout up in the
\&\fIperldebug\fR\|(1) manpage, on a \*(L"empty\*(R" program, like this:
.PP
.Vb 1
\&    perl \-de 42
.Ve
.PP
Now just type up in any legal Perl code, n' it is ghon be immediately
evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass can also examine tha symbol table, git stack
backtraces, check variable joints, set breakpoints, n' other
operations typically found up in symbolic debuggers.
.PP
Yo ass can also use Devel::REPL which be a interactizzle shell fo' Perl,
commonly known as a \s-1REPL \-\s0 Read, Evaluate, Print, Loop. Well shiiiit, it provides
various handy features.
.SS "How tha fuck do I find which modulez is installed on mah system?"
.IX Subsection "How tha fuck do I find which modulez is installed on mah system?"
From tha command line, you can use tha \f(CW\*(C`cpan\*(C'\fR commandz \f(CW\*(C`\-l\*(C'\fR switch:
.PP
.Vb 1
\&    $ cpan \-l
.Ve
.PP
Yo ass can also use \f(CW\*(C`cpan\*(C'\fRz \f(CW\*(C`\-a\*(C'\fR switch ta create a autobundle file
that \f(CW\*(C`CPAN.pm\*(C'\fR understandz n' can use ta re-install every last muthafuckin module:
.PP
.Vb 1
\&    $ cpan \-a
.Ve
.PP
Inside a Perl program, you can use tha ExtUtils::Installed module to
show all installed distributions, although it can take awhile ta do
its magic. Da standard library which comes wit Perl just shows up
as \*(L"Perl\*(R" (although you can git dem wit Module::CoreList).
.PP
.Vb 1
\&    use ExtUtils::Installed;
\&
\&    mah $inst    = ExtUtils::Installed\->new();
\&    mah @modulez = $inst\->modules();
.Ve
.PP
If you want a list of all of tha Perl module filenames, you
can use File::Find::Rule:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    mah @filez = File::Find::Rule\->
\&        extras({follow => 1})\->
\&        file()\->
\&        name( \*(Aq*.pm\*(Aq )\->
\&        in( @INC )
\&        ;
.Ve
.PP
If you aint gots dat module, you can do tha same thang
with File::Find which is part of tha standard library:
.PP
.Vb 2
\&    use File::Find;
\&    mah @files;
\&
\&    find(
\&        {
\&        wanted => sub {
\&            push @files, $File::Find::fullname
\&            if \-f $File::Find::fullname && /\e.pm$/
\&        },
\&        follow => 1,
\&        follow_skip => 2,
\&        },
\&        @INC
\&    );
\&
\&    print join "\en", @files;
.Ve
.PP
If you simply need ta check quickly ta peep if a module is
available, you can check fo' its documentation. I aint talkin' bout chicken n' gravy biatch. If you can
read tha documentation tha module is most likely installed.
If you cannot read tha documentation, tha module might not
have any (in rare cases):
.PP
.Vb 1
\&    $ perldoc Module::Name
.Ve
.PP
Yo ass can also try ta include tha module up in a one-liner ta peep if
perl findz it:
.PP
.Vb 1
\&    $ perl \-MModule::Name \-e1
.Ve
.PP
(If you don't receive a \*(L"Can't locate ... up in \f(CW@INC\fR\*(R" error message, then Perl
found tha module name you axed for.)
.SS "How tha fuck do I debug mah Perl programs?"
.IX Subsection "How tha fuck do I debug mah Perl programs?"
(contributed by brian d foy)
.PP
Before you do anythang else, you can help yo ass by ensurin that
you let Perl rap  bout problem areas up in yo' code. By turning
on warnings n' strictures, you can head off nuff problems before
they git too big. Yo ass can smoke up mo' bout these up in strict
and warnings.
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.PP
Beyond that, tha simplest debugger is tha \f(CW\*(C`print\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Use it
to peep joints as you run yo' program:
.PP
.Vb 1
\&    print STDERR "Da value is [$value]\en";
.Ve
.PP
Da Data::Dumper module can pretty-print Perl data structures:
.PP
.Vb 2
\&    use Data::Dumper qw( Dumper );
\&    print STDERR "Da hash is " . Dumper( \e%hash ) . "\en";
.Ve
.PP
Perl comes wit a interactizzle debugger, which you can start wit the
\&\f(CW\*(C`\-d\*(C'\fR switch. It aint nuthin but straight-up explained up in perldebug.
.PP
If you'd like a graphical user intercourse n' you have Tk, you can use
\&\f(CW\*(C`ptkdb\*(C'\fR. It aint nuthin but on \s-1CPAN\s0 n' available fo' free.
.PP
If you need suttin' much mo' sophisticated n' controllable, Leon
Brocardz Devel::ebug (which you can call wit tha \f(CW\*(C`\-D\*(C'\fR switch as \f(CW\*(C`\-Debug\*(C'\fR)
gives you tha programmatic hooks tha fuck into every last muthafuckin thang you need ta write your
own (without too much pain n' suffering).
.PP
Yo ass can also bust a cold-ass lil commercial debugger like fuckin Affrus (Mac \s-1OS X\s0), Komodo
from Activestate (Windows n' Mac \s-1OS X\s0), or \s-1EPIC \s0(most platforms).
.SS "How tha fuck do I flava mah Perl programs?"
.IX Subsection "How tha fuck do I flava mah Perl programs?"
(contributed by brian d foy, updated Fri Jul 25 12:22:26 \s-1PDT 2008\s0)
.PP
Da \f(CW\*(C`Devel\*(C'\fR namespace has nuff muthafuckin modulez which you can use to
profile yo' Perl programs.
.PP
Da Devel::NYTProf (New York Times Profiler) do both statement
and subroutine profiling. It aint nuthin but available from \s-1CPAN\s0 n' you also invoke
it wit tha \f(CW\*(C`\-d\*(C'\fR switch:
.PP
.Vb 1
\&    perl \-d:NYTProf some_perl.pl
.Ve
.PP
It creates a thugged-out database of tha flava shiznit dat you can turn into
reports, n' you can put dat on yo' toast. Da \f(CW\*(C`nytprofhtml\*(C'\fR command turns tha data tha fuck into a \s-1HTML\s0 report
similar ta tha Devel::Cover report:
.PP
.Vb 1
\&    nytprofhtml
.Ve
.PP
Yo ass might also be horny bout rockin tha Benchmark to
measure n' compare code snippets.
.PP
Yo ass can read mo' bout profilin up in \fIProgrammin Perl\fR, chapta 20,
or \fIMasterin Perl\fR, chapta 5.
.PP
perldebguts documents bustin a cold-ass lil custom debugger if you need to
create a special sort of profila n' shit. brian d foy raps bout tha process
in \fIDa Perl Journal\fR, \*(L"Creatin a Perl Debugger\*(R",
<http://www.ddj.com/184404522> , n' \*(L"Profilin up in Perl\*(R"
<http://www.ddj.com/184404580> .
.PP
Perl.com has two bangin-ass articlez on profiling: \*(L"Profilin Perl\*(R",
by Semen Cozens, <http://www.perl.com/lpt/a/850> n' \*(L"Debuggin and
Profilin mod_perl Applications\*(R", by Frank Wiles,
<http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html> .
.PP
Randal L. Right back up in yo muthafuckin ass. Schwartz writes bout profilin up in \*(L"Speedin up Yo crazy-ass Perl
Programs\*(R" fo' \fIUnix Review\fR,
<http://www.stonehenge.com/merlyn/UnixReview/col49.html> , n' \*(L"Profiling
in Template Toolkit via Overriding\*(R" fo' \fILinux Magazine\fR,
<http://www.stonehenge.com/merlyn/LinuxMag/col75.html> .
.SS "How tha fuck do I cross-reference mah Perl programs?"
.IX Subsection "How tha fuck do I cross-reference mah Perl programs?"
Da B::Xref module can be used ta generate cross-reference reports
for Perl programs.
.PP
.Vb 1
\&    perl \-MO=Xref[,OPTIONS] scriptname.plx
.Ve
.SS "Is there a pretty-printa (formatter) fo' Perl?"
.IX Subsection "Is there a pretty-printa (formatter) fo' Perl?"
Perl::Tidy comes wit a perl script perltidy which indents and
reformats Perl scripts ta make dem easier ta read by tryin ta follow
the rulez of tha perlstyle. If you write Perl, or spend much time reading
Perl, yo big-ass booty is ghon probably find it useful.
.PP
Of course, if you simply follow tha guidelines up in perlstyle,
you shouldn't need ta reformat. Da g-thang of formattin yo' code
as you write it will help prevent bugs. Yo crazy-ass editor can n' should
help you wit all dis bullshit. Da perl-mode or newer cperl-mode fo' emacs
can provide remarkable amountz of help wit most (but not all)
code, n' even less programmable editors can provide significant
assistance. Tomothy Christiansen n' nuff other \s-1VI\s0 playas swear by
the followin settings up in vi n' its clones:
.PP
.Vb 2
\&    set ai sw=4
\&    map! ^O {^M}^[O^T
.Ve
.PP
Put dat up in yo' \fI.exrc\fR file (replacin tha caret characters
with control characters) n' away you go. In bang mode, ^T is
for indenting, ^D is fo' undenting, n' ^O is fo' blockdenting\*(--as
it were, so peek-a-boo, clear tha way, I be comin' thru fo'sho fo' realz. A mo' complete example, wit comments, can be found at
<http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz>
.SS "Is there a \s-1IDE\s0 or Windows Perl Editor?"
.IX Subsection "Is there a IDE or Windows Perl Editor?"
Perl programs is just plain text, so any editor will do.
.PP
If you on Unix, you already have a IDE\*(--Unix itself. Da Unix
philosophy is tha philosophy of nuff muthafuckin lil' small-ass tools dat each do one
thang n' do it well. It aint nuthin but like a cold-ass lil carpenterz toolbox.
.PP
If you want a \s-1IDE,\s0 check tha followin (in alphabetical order, not
order of preference):
.IP "Eclipse" 4
.IX Item "Eclipse"
<http://e\-p\-i\-c.sf.net/>
.Sp
Da Eclipse Perl Integration Project integrates Perl
editing/debuggin wit Eclipse.
.IP "Enginsite" 4
.IX Item "Enginsite"
<http://www.enginsite.com/>
.Sp
Perl Editor by EngInSite be a cold-ass lil complete integrated pimpment
environment (\s-1IDE\s0) fo' bustin, testing, n'  debuggin  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.
.IP "Kephra" 4
.IX Item "Kephra"
<http://kephra.sf.net>
.Sp
\&\s-1GUI\s0 Editor freestyled up in Perl rockin wxWidgets n' Scintilla wit fuckin shitloadz of smalla features.
Aims fo' a \s-1UI\s0 based on Perls principlez like \s-1TIMTWTDI\s0 n' \*(L"easy thinkd should be ..\*(R".
.IP "Komodo" 4
.IX Item "Komodo"
<http://www.ActiveState.com/Products/Komodo/>
.Sp
ActiveStatez cross-platform (az of October 2004, thatz Windows, Linux,
and Solaris), multi-language \s-1IDE\s0 has Perl support, includin a regular expression
debugger n' remote debugging.
.IP "Notepad++" 4
.IX Item "Notepad++"
<http://notepad\-plus.sourceforge.net/>
.IP "Open Perl \s-1IDE\s0" 4
.IX Item "Open Perl IDE"
<http://open\-perl\-ide.sourceforge.net/>
.Sp
Open Perl \s-1IDE\s0 be a integrated pimpment environment fo' writing
and debuggin Perl scripts wit ActiveStatez ActivePerl distribution
under Windows 95/98/NT/2000.
.IP "OptiPerl" 4
.IX Item "OptiPerl"
<http://www.optiperl.com/>
.Sp
OptiPerl be a Windows \s-1IDE\s0 wit simulated \s-1CGI\s0 environment, including
debugger n' syntax-highlightin editor.
.IP "Padre" 4
.IX Item "Padre"
<http://padre.perlide.org/>
.Sp
Padre is cross-platform \s-1IDE\s0 fo' Perl freestyled up in Perl rockin wxWidgets ta provide
a natizzle look n' feel. It aint nuthin but open source under tha Artistic License. It
is one of tha newer Perl IDEs.
.IP "PerlBuilder" 4
.IX Item "PerlBuilder"
<http://www.solutionsoft.com/perl.htm>
.Sp
PerlBuilder be a integrated pimpment environment fo' Windows that
supports Perl pimpment.
.IP "visiPerl+" 4
.IX Item "visiPerl+"
<http://helpconsulting.net/visiperl/index.html>
.Sp
From Help Consulting, fo' Windows.
.IP "Visual Perl" 4
.IX Item "Visual Perl"
<http://www.activestate.com/Products/Visual_Perl/>
.Sp
Visual Perl be a Visual Studio.NET plug-in from ActiveState.
.IP "Zeus" 4
.IX Item "Zeus"
<http://www.zeusedit.com/lookmain.html>
.Sp
Zeus fo' Windows be another Win32 multi-language editor/IDE
that comes wit support fo' Perl.
.PP
For editors: if you on Unix you probably have vi or a vi clone
already, n' possibly a emacs too, so you may not need ta download
anything. In any emacs tha cperl-mode (M\-x cperl-mode) gives you
like tha dopest available Perl editin mode up in any editor.
.PP
If yo ass is rockin Windows, you can use any editor dat lets you work
with plain text, like fuckin NotePad or WordPad. Y'all KNOW dat shit, muthafucka! Word processors, such as
Microsizzlez Word or WordPerfect, typically do not work since they insert
all sortz of behind-the-scenes shiznit, although some allow you to
save filez as \*(L"Text Only\*(R". Yo ass can also downlizzle text editors designed
specifically fo' programming, like fuckin Textpad (
<http://www.textpad.com/> ) n' UltraEdit ( <http://www.ultraedit.com/> ),
among others.
.PP
If yo ass is rockin MacOS, tha same concerns apply. MacPerl (for Classic
environments) comes wit a simple editor. Shiiit, dis aint no joke. Ghettofab external editors are
BBEdit ( <http://www.bbedit.com/> ) or Alpha (
<http://www.his.com/~jguyer/Alpha/Alpha8.html> ). MacOS X playas can use
Unix editors as well.
.IP "\s-1GNU\s0 Emacs" 4
.IX Item "GNU Emacs"
<http://www.gnu.org/software/emacs/windows/ntemacs.html>
.IP "MicroEMACS" 4
.IX Item "MicroEMACS"
<http://www.microemacs.de/>
.IP "XEmacs" 4
.IX Item "XEmacs"
<http://www.xemacs.org/Download/index.html>
.IP "Jed" 4
.IX Item "Jed"
<http://space.mit.edu/~davis/jed/>
.PP
or a vi clone such as
.IP "Vim" 4
.IX Item "Vim"
<http://www.vim.org/>
.IP "Vile" 4
.IX Item "Vile"
<http://dickey.his.com/vile/vile.html>
.PP
Da followin is Win32 multilanguage editor/IDEs dat support Perl:
.IP "Codewright" 4
.IX Item "Codewright"
<http://www.borland.com/codewright/>
.IP "MultiEdit" 4
.IX Item "MultiEdit"
<http://www.MultiEdit.com/>
.IP "SlickEdit" 4
.IX Item "SlickEdit"
<http://www.slickedit.com/>
.IP "ConTEXT" 4
.IX Item "ConTEXT"
<http://www.contexteditor.org/>
.PP
There be also a toyedit Text widget based editor freestyled up in Perl
that is distributed wit tha Tk module on \s-1CPAN.\s0 Da ptkdb
( <http://ptkdb.sourceforge.net/> ) be a Perl/Tk\-based debugger that
acts as a thugged-out pimpment environment of sorts, n' you can put dat on yo' toast. Perl Composer
( <http://perlcomposer.sourceforge.net/> ) be a \s-1IDE\s0 fo' Perl/Tk
\&\s-1GUI\s0 creation.
.PP
In addizzle ta a editor/IDE you might be horny bout a more
powerful shell environment fo' Win32. Yo crazy-ass options include
.IP "Bash" 4
.IX Item "Bash"
from tha Cygwin package ( <http://sources.redhat.com/cygwin/> )
.IP "Ksh" 4
.IX Item "Ksh"
from tha \s-1MKS\s0 Toolkit ( <http://www.mkssoftware.com/> ), or tha Bourne shell of
the U/WIN environment ( <http://www.research.att.com/sw/tools/uwin/> )
.IP "Tcsh" 4
.IX Item "Tcsh"
<ftp://ftp.astron.com/pub/tcsh/> , peep also
<http://www.primate.wisc.edu/software/csh\-tcsh\-book/>
.IP "Zsh" 4
.IX Item "Zsh"
<http://www.zsh.org/>
.PP
\&\s-1MKS\s0 n' U/WIN is commercial (U/WIN is free fo' ejaculationizzle and
research purposes), Cygwin is covered by tha \s-1GNU\s0 General Public
License (but dat shouldn't matta fo' Perl use). Da Cygwin, \s-1MKS,\s0
and U/WIN all contain (in addizzle ta tha shells) a cold-ass lil comprehensive set
of standard Unix toolkit utilities.
.PP
If you transferrin text filez between Unix n' Windows rockin \s-1FTP\s0
be shizzle ta transfer dem up in \s-1ASCII\s0 mode so tha endz of lines are
appropriately converted.
.PP
On Mac \s-1OS\s0 tha MacPerl Application comes wit a simple 32k text editor
that behaves like a rudimentary \s-1IDE.\s0 In contrast ta tha MacPerl Application
the \s-1MPW\s0 Perl tool can make use of tha \s-1MPW\s0 Shell itself as a editor (with
no 32k limit).
.IP "Affrus" 4
.IX Item "Affrus"
is a gangbangin' full Perl pimpment environment wit full debugger support
( <http://www.latenightsw.com> ).
.IP "Alpha" 4
.IX Item "Alpha"
is a editor, freestyled n' extensible up in Tcl, dat nonetheless has
built-in support fo' nuff muthafuckin ghettofab markup n' programmin languages,
includin Perl n' \s-1HTML \s0( <http://www.his.com/~jguyer/Alpha/Alpha8.html> ).
.IP "BBEdit n' BBEdit Lite" 4
.IX Item "BBEdit n' BBEdit Lite"
are text editors fo' Mac \s-1OS\s0 dat gotz a Perl sensitivitizzle mode
( <http://web.barebones.com/> ).
.SS "Where can I git Perl macros fo' vi?"
.IX Subsection "Where can I git Perl macros fo' vi?"
For a cold-ass lil complete version of Tomothy Christiansenz vi configuration file,
see <http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz> ,
the standard benchmark file fo' vi emulators. Da file runs dopest wit nvi,
the current version of vi outta Berkeley, which incidentally can be built
with a embedded Perl interpreter\*(--see <http://www.cpan.org/src/misc/> .
.SS "Where can I git perl-mode or cperl-mode fo' emacs?"
.IX Xref "emacs"
.IX Subsection "Where can I git perl-mode or cperl-mode fo' emacs?"
Since Emacs version 19 patchlevel 22 or so, there done been both a
perl\-mode.el n' support fo' tha Perl debugger built in. I aint talkin' bout chicken n' gravy biatch. These should
come wit tha standard Emacs 19 distribution.
.PP
Note dat tha perl-mode of emacs gonna git fits wit \f(CW"main\*(Aqfoo"\fR
(single quote), n' mess up tha indentation n' highlighting. You
are probably rockin \f(CW"main::foo"\fR up in freshly smoked up Perl code anyway, so this
shouldn't be a issue.
.PP
For CPerlMode, peep <http://www.emacswiki.org/cgi\-bin/wiki/CPerlMode>
.SS "How tha fuck can I use curses wit Perl?"
.IX Subsection "How tha fuck can I use curses wit Perl?"
Da Curses module from \s-1CPAN\s0 serves up a thugged-out dynamically loadable object
module intercourse ta a cold-ass lil curses library fo' realz. A lil' small-ass demo can be found at the
directory <http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz> ;
this program repeats a cold-ass lil command n' thugged-out shiznit tha screen as needed, rendering
\&\fBrep ps axu\fR similar ta \fBtop\fR.
.SS "How tha fuck can I write a \s-1GUI \s0(X, Tk, Gtk, etc.) up in Perl?"
.IX Xref "GUI Tk Wx WxWidgets Gtk Gtk2 CamelBones Qt"
.IX Subsection "How tha fuck can I write a GUI (X, Tk, Gtk, etc.) up in Perl?"
(contributed by Lil' Bow Wow Morrow)
.PP
There is a fuckin shitload of modulez which let you write GUIs up in Perl. Most
\&\s-1GUI\s0 toolkits gotz a perl intercourse: a incomplete list bigs up.
.IP "Tk" 4
.IX Item "Tk"
This works under Unix n' Windows, n' tha current version don't
look half as wack under Windows as it used to. Right back up in yo muthafuckin ass. Some of tha gui elements
still don't 'feel' like right, though cause I gots dem finger-lickin' chickens wit tha siz-auce. Da intercourse is straight-up natural
and 'perlish', makin it easy as fuck  ta use up in lil' small-ass scripts dat just need a
simple gui. Well shiiiit, it aint been updated up in a while.
.IP "Wx" 4
.IX Item "Wx"
This be a Perl bindin fo' tha cross-platform wxWidgets toolkit
( <http://www.wxwidgets.org> ). Well shiiiit, it works under Unix, Win32 n' Mac \s-1OS X,\s0
usin natizzle widgets (Gtk under Unix). Da intercourse bigs up tha \*(C+
interface closely yo, but tha documentation be a lil sparse fo' one of mah thugs
who don't give a fuck tha library, mostly just referrin you ta tha \*(C+
documentation.
.IP "Gtk n' Gtk2" 4
.IX Item "Gtk n' Gtk2"
These is Perl bindings fo' tha Gtk toolkit ( <http://www.gtk.org> ). The
interface chizzled hella between versions 1 n' 2 so they have
separate Perl modules. Well shiiiit, it runs under Unix, Win32 n' Mac \s-1OS X \s0(currently
it requires a X server on Mac \s-1OS,\s0 but a 'native' port is underway), and
the widgets look tha same on every last muthafuckin platform: i.e., they don't match the
natizzle widgets fo' realz. As wit Wx, tha Perl bindings follow tha C \s-1API\s0 closely,
and tha documentation requires you ta read tha C documentation to
understand dat shit.
.IP "Win32::GUI" 4
.IX Item "Win32::GUI"
This serves up access ta most of tha Win32 \s-1GUI\s0 widgets from Perl.
Obviously, it only runs under Win32, n' uses natizzle widgets, n' you can put dat on yo' toast. Da Perl
interface don't straight-up follow tha C intercourse: itz been made more
Perlish, n' tha documentation is pretty good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg! Mo' advanced shiznit may
require familiaritizzle wit tha C Win32 APIs, or reference ta \s-1MSDN.\s0
.IP "CamelBones" 4
.IX Item "CamelBones"
CamelBones ( <http://camelbones.sourceforge.net> ) be a Perl intercourse to
Mac \s-1OS X\s0z Cocoa \s-1GUI\s0 toolkit, n' as such can be used ta produce native
GUIs on Mac \s-1OS X.\s0 It aint nuthin but not on \s-1CPAN,\s0 as it requires frameworks that
\&\s-1CPAN\s0.pm don't give a fuck how tha fuck ta install yo, but installation is via the
standard \s-1OSX\s0 package installa n' shit. Da Perl \s-1API\s0 is, again, straight-up close to
the ObjC \s-1API\s0 itz wrapping, n' tha documentation just  drops some lyrics ta you how tha fuck to
translate from one ta tha other.
.IP "Qt" 4
.IX Item "Qt"
There be a Perl intercourse ta TrollTechz Qt toolkit yo, but it do not
appear ta be maintained.
.IP "Athena" 4
.IX Item "Athena"
Sx be a intercourse ta tha Athena widget set which comes wit X yo, but
again it appears not ta be much used nowadays.
.SS "How tha fuck can I make mah Perl program run faster?"
.IX Subsection "How tha fuck can I make mah Perl program run faster?"
Da dopest way ta do dis is ta come up wit a funky-ass betta algorithm. This
can often cook up a thugged-out dramatic difference. Jizzle Bentleyz book
\&\fIProgrammin Pearls\fR (thatz not a misspelling!)  has some phat tips
on optimization, like a muthafucka fo' realz. Real shiznit on benchmarkin boils down to: benchmark
and flava ta make shizzle you optimizin tha right part, look for
betta algorithms instead of microtunin yo' code, n' when all else
fails consider just buyin fasta hardware. Yo ass will probably want to
read tha answer ta tha earlier question \*(L"How tha fuck do I flava mah Perl
programs?\*(R" if you aint done so already.
.PP
A different approach is ta autoload seldom-used Perl code. Right back up in yo muthafuckin ass. See the
AutoSplit n' AutoLoader modulez up in tha standard distribution for
dat shit. Or you could locate tha bottleneck n' be thinkin bout freestylin just
that part up in C, tha way we used ta take bottlenecks up in C code and
write dem up in assembla n' shit. Right back up in yo muthafuckin ass. Similar ta rewritin up in C, modulez dat have
critical sections can be freestyled up in C (for instance, tha \s-1PDL\s0 module
from \s-1CPAN\s0).
.PP
If you currently linkin yo' perl executable ta a gangbangin' finger-lickin' dirty-ass shared
\&\fIlibc.so\fR, you can often bust a 10\-25% performizzle benefit by
rebuildin it ta link wit a static libc.a instead. Y'all KNOW dat shit, muthafucka! This will make a
bigger perl executable yo, but yo' Perl programs (and programmers) may
fuck you fo' dat shit. Right back up in yo muthafuckin ass. See tha \fI\s-1INSTALL\s0\fR file up in tha source distribution
for mo' shiznit.
.PP
Da undump program was a ancient attempt ta speed up Perl program by
storin tha already-compiled form ta disk. This is no longer a viable
option, as it only hit dat shiznit on all dem architectures, n' wasn't a good
solution anyway.
.SS "How tha fuck can I make mah Perl program take less memory?"
.IX Subsection "How tha fuck can I make mah Perl program take less memory?"
When it comes ta time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem. Right back up in yo muthafuckin ass. Scalars up in Perl use mo' memory than
strings up in C, arrays take mo' than that, n' hashes use even mo' n' mo' n' mo'. While
therez still a shitload ta be done, recent releases done been addressing
these issues. For example, az of 5.004, duplicate hash keys are
shared amongst all hashes rockin them, so require no reallocation.
.PP
In some cases, rockin \fIsubstr()\fR or \fIvec()\fR ta simulate arrays can be
highly beneficial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. For example, a array of a thousand booleans will
take at least 20,000 bytez of space yo, but it can be turned tha fuck into one
125\-byte bit vector\*(--a considerable memory savings. Da standard
Tie::SubstrHash module can also help fo' certain typez of data
structure. If you hustlin wit specialist data structures
(matrices, fo' instance) modulez dat implement these up in C may use
less memory than equivalent Perl modules.
.PP
Another thang ta try is peepin' whether yo' Perl was compiled with
the system malloc or wit Perlz builtin malloc. Whichever one it
is, try rockin tha other one n' peep whether dis cook up a gangbangin' finger-lickin' difference.
Hype bout malloc is up in tha \fI\s-1INSTALL\s0\fR file up in tha source
distribution. I aint talkin' bout chicken n' gravy biatch. Yo ass can smoke up whether yo ass is rockin perlz malloc by
typin \f(CW\*(C`perl \-V:usemymalloc\*(C'\fR.
.PP
Of course, tha dopest way ta save memory is ta not do anythang ta waste
it up in tha straight-up original gangsta place. Dope programmin practices can go a long-ass way
toward this:
.IP "Don't slurp!" 4
.IX Item "Don't slurp!"
Don't read a entire file tha fuck into memory if you can process it line
by line. Or mo' concretely, bust a loop like this:
.Sp
.Vb 6
\&    #
\&    # Dope Idea
\&    #
\&    while (my $line = <$file_handle>) {
\&       # ...
\&    }
.Ve
.Sp
instead of this:
.Sp
.Vb 7
\&    #
\&    # Wack Idea
\&    #
\&    mah @data = <$file_handle>;
\&    foreach (@data) {
\&        # ...
\&    }
.Ve
.Sp
When tha filez you processin is small, it don't much matta which
way you do it yo, but it cook up a big-ass difference when they start getting
larger.
.IP "Use map n' grep selectively" 4
.IX Item "Use map n' grep selectively"
Remember dat both map n' grep expect a \s-1LIST\s0 argument, so bustin this:
.Sp
.Vb 1
\&        @wanted = grep {/pattern/} <$file_handle>;
.Ve
.Sp
will cause tha entire file ta be slurped. Y'all KNOW dat shit, muthafucka! For big-ass files, itz better
to loop:
.Sp
.Vb 3
\&        while (<$file_handle>) {
\&                push(@wanted, $_) if /pattern/;
\&        }
.Ve
.IP "Avoid unnecessary quotes n' stringification" 4
.IX Item "Avoid unnecessary quotes n' stringification"
Don't quote big-ass strings unless straight-up necessary:
.Sp
.Vb 1
\&        mah $copy = "$large_string";
.Ve
.Sp
makes 2 copiez of \f(CW$large_string\fR (one fo' \f(CW$copy\fR n' another fo' the
quotes), whereas
.Sp
.Vb 1
\&        mah $copy = $large_string;
.Ve
.Sp
only make one copy.
.Sp
Ditto fo' stringifyin big-ass arrays:
.Sp
.Vb 4
\&    {
\&    local $, = "\en";
\&    print @big_array;
\&    }
.Ve
.Sp
is much mo' memory-efficient than either
.Sp
.Vb 1
\&    print join "\en", @big_array;
.Ve
.Sp
or
.Sp
.Vb 4
\&    {
\&    local $" = "\en";
\&    print "@big_array";
\&    }
.Ve
.IP "Pass by reference" 4
.IX Item "Pass by reference"
Pass arrays n' hashes by reference, not by value. For one thang, it's
the only way ta pass multiple lists or hashes (or both) up in a single
call/return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it also avoidz bustin a cold-ass lil copy of all tha contents, n' you can put dat on yo' toast. This
requires some judgement, however, cuz any chizzlez is ghon be propagated
back ta tha original gangsta data. If you straight-up wanna mangle (er, modify) a
copy, you gonna gotta sacrifice tha memory needed ta make one.
.IP "Tie big-ass variablez ta disk" 4
.IX Item "Tie big-ass variablez ta disk"
For \*(L"big\*(R" data stores (i.e. ones dat exceed available memory) consider
usin one of tha \s-1DB\s0 modulez ta store it on disk instead of up in \s-1RAM.\s0 This
will incur a penalty up in access time yo, but thatz probably betta than
causin yo' hard disk ta thrash cuz of massive swapping.
.SS "Is it safe ta return a reference ta local or lexical data?"
.IX Subsection "Is it safe ta return a reference ta local or lexical data?"
Yes yes y'all. Perlz garbage collection system takes care of dis so
everythang works up right.
.PP
.Vb 4
\&    sub makeone {
\&        mah @a = ( 1 .. 10 );
\&        return \e@a;
\&    }
\&
\&    fo' ( 1 .. 10 ) {
\&        push @many, makeone();
\&    }
\&
\&    print $many[4][5], "\en";
\&
\&    print "@many\en";
.Ve
.SS "How tha fuck can I free a array or hash so mah program shrinks?"
.IX Subsection "How tha fuck can I free a array or hash so mah program shrinks?"
(contributed by Mike Carman)
.PP
Yo ass probably can't. Memory allocated ta lexicals (i.e. \fImy()\fR variables)
cannot be reclaimed or reused even if they go outta scope. Well shiiiit, it is
reserved up in case tha variablez come back tha fuck into scope. Memory allocated
to global variablez can be reused (within yo' program) by using
\&\fIundef()\fR and/or \fIdelete()\fR.
.PP
On most operatin systems, memory allocated ta a program can never be
returned ta tha system. Thatz why long-runnin programs sometimes re\-
exec theyselves. Right back up in yo muthafuckin ass. Some operatin systems (notably, systems dat use
\&\fImmap\fR\|(2) fo' allocatin big-ass chunkz of memory) can reclaim memory that
is no longer used yo, but on such systems, perl must be configured and
compiled ta use tha \s-1OS\s0z malloc, not perl's.
.PP
In general, memory allocation n' de-allocation aint suttin' you can
or should be worryin bout much up in Perl.
.PP
See also \*(L"How tha fuck can I make mah Perl program take less memory?\*(R"
.SS "How tha fuck can I make mah \s-1CGI\s0 script mo' efficient?"
.IX Subsection "How tha fuck can I make mah CGI script mo' efficient?"
Beyond tha aiiight measures busted lyrics bout ta make general Perl programs
fasta or smaller, a \s-1CGI\s0 program has additionizzle issues. Well shiiiit, it may be run
several times per second. Y'all KNOW dat shit, muthafucka! Given dat each time it runs it will need
to be re-compiled n' will often allocate a megabyte or mo' of system
memory, dis can be a killa n' shit. Compilin tha fuck into C \fBaint goin ta help
you\fR cuz tha process start-up overhead is where tha bottleneck is.
.PP
There is three ghettofab ways ta avoid dis overhead. Y'all KNOW dat shit, muthafucka! One solution
involves hustlin tha Apache \s-1HTTP\s0 server (available from
<http://www.apache.org/> ) wit either of tha mod_perl or mod_fastcgi
plugin modules.
.PP
With mod_perl n' tha Apache::Registry module (distributed with
mod_perl), httpd will run wit a embedded Perl interpreta which
pre-compilez yo' script n' then executes it within tha same address
space without forking. Da Apache extension also gives Perl access to
the internal server \s-1API,\s0 so modulez freestyled up in Perl can do just about
anythang a module freestyled up in C can. I aint talkin' bout chicken n' gravy biatch. For mo' on mod_perl, see
<http://perl.apache.org/>
.PP
With tha \s-1FCGI\s0 module (from \s-1CPAN\s0) n' tha mod_fastcgi
module (available from <http://www.fastcgi.com/> ) each of yo' Perl
programs becomes a permanent \s-1CGI\s0 daemon process.
.PP
Finally, Plack be a Perl module n' toolkit dat gotz nuff \s-1PSGI\s0 middleware,
helpers n' adaptas ta wizzy servers, allowin you ta easily deploy scripts which
can continue hustlin, n' serves up flexibilitizzle wit regardz ta which wizzy server
you use. Well shiiiit, it can allow existin \s-1CGI\s0 scripts ta trip off dis flexibilitizzle and
performizzle wit minimal chizzles, or can be used along wit modern Perl web
frameworks ta make freestylin n' deployin wizzy skillz wit Perl a funky-ass breeze.
.PP
These solutions can have far-reachin effects on yo' system n' on tha way you
write yo' \s-1CGI\s0 programs, so rewind dem wit care.
.PP
See also
<http://www.cpan.org/modules/by\-category/15_World_Wide_Web_HTML_HTTP_CGI/> .
.SS "How tha fuck can I hide tha source fo' mah Perl program?"
.IX Subsection "How tha fuck can I hide tha source fo' mah Perl program?"
Delete dat shit. :\-) Seriously, there be a fuckin shitload of (mostly
unsatisfactory) solutions wit varyin levelz of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, cuz
the source code has ta be readable up in order ta be compiled and
interpreted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (That don't mean dat a \s-1CGI\s0 scriptz source is
readable by playas on tha web, though\*(--only by playas wit access to
the filesystem.)  So you gotta leave tha permissions all up in tha hoodly
friendly 0755 level.
.PP
Some playas regard dis as a securitizzle problem. If yo' program do
insecure thangs n' relies on playas not knowin how tha fuck ta exploit them
insecurities, it aint secure. Well shiiiit, it is often possible fo' one of mah thugs to
determine tha insecure thangs n' exploit dem without viewin the
source. Right back up in yo muthafuckin ass. Securitizzle all up in obscurity, tha name fo' hidin yo' bugs
instead of fixin them, is lil securitizzle indeed.
.PP
Yo ass can try rockin encryption via source filtas (Startin from Perl
5.8 tha Filter::Simple n' Filter::Util::Call modulez is included in
the standard distribution) yo, but any decent programmer is ghon be able to
decrypt dat shit. Yo ass can try rockin tha byte code compila n' interpreter
busted lyrics bout lata up in perlfaq3 yo, but tha curious might still be able to
de-compile dat shit. Yo ass can try rockin tha native-code compila busted lyrics about
later yo, but crackers might be able ta disassemble dat shit. These pose
varyin degreez of hang-up ta playas wantin ta git at yo' code,
but none can definitively conceal it (true of every last muthafuckin language, not just
Perl).
.PP
It be straight-up easy as fuck  ta recover tha source of Perl programs. Yo ass simply
feed tha program ta tha perl interpreta n' use tha modulez in
the B:: hierarchy. Da B::Deparse module should be able to
defeat most attempts ta hide source fo' realz. Again, dis is not
unique ta Perl.
.PP
If you concerned bout playas profitin from yo' code, then the
bottom line is dat not a god damn thang but a restrictizzle license will give you
legal security. License yo' software n' pepper it wit threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Yo crazy-ass access ta it do not hit you wit permission ta use it blah blah
blah.\*(R"  Our asses aint lawyers, of course, so you should peep a lawyer if
you wanna be shizzle yo' licensez wordin will stand up in court.
.SS "How tha fuck can I compile mah Perl program tha fuck into byte code or C?"
.IX Subsection "How tha fuck can I compile mah Perl program tha fuck into byte code or C?"
(contributed by brian d foy)
.PP
In general, you can't do all dis bullshit. There is some thangs dat may work
for yo' thang though cause I gots dem finger-lickin' chickens wit tha siz-auce. Muthafuckas probably ask dis question
because they wanna distribute they works without givin away
the source code, n' most solutions trade disk space fo' convenience.
Yo ass probably won't peep much of a speed increase either, since most
solutions simply bundle a Perl interpreta up in tha final product
(but peep \*(L"How tha fuck can I make mah Perl program run faster?\*(R").
.PP
Da Perl Archive Toolkit ( <http://par.perl.org/> ) is Perl's
analog ta Javaz \s-1JAR.\s0 It aint nuthin but freely available n' on \s-1CPAN \s0(
<http://search.cpan.org/dist/PAR/> ).
.PP
There is also some commercial shizzle dat may work fo' you, although
you gotta loot a license fo' em.
.PP
Da Perl Dev Kit ( <http://www.activestate.com/Products/Perl_Dev_Kit/> )
from ActiveState can \*(L"Turn yo' Perl programs tha fuck into ready-to-run
executablez fo' HP-UX, Linux, Solaris n' Windows.\*(R"
.PP
Perl2Exe ( <http://www.indigostar.com/perl2exe.htm> ) be a cold-ass lil command line
program fo' convertin perl scripts ta executable files. Well shiiiit, it targets both
Windows n' Unix platforms.
.ie n .SS "How tha fuck can I git ""#!perl"" ta work on [\s-1MS\-DOS,NT,...\s0]?"
.el .SS "How tha fuck can I git \f(CW#!perl\fP ta work on [\s-1MS\-DOS,NT,...\s0]?"
.IX Subsection "How tha fuck can I git #!perl ta work on [MS-DOS,NT,...]?"
For \s-1OS/2\s0 just use
.PP
.Vb 1
\&    extproc perl \-S \-your_switches
.Ve
.PP
as tha straight-up original gangsta line up in \f(CW\*(C`*.cmd\*(C'\fR file (\f(CW\*(C`\-S\*(C'\fR cuz of a funky-ass bug up in cmd.exe's
\&\*(L"extproc\*(R" handling). For \s-1DOS\s0 one should first invent a cold-ass lil corresponding
batch file n' codify it up in \f(CW\*(C`ALTERNATE_SHEBANG\*(C'\fR (see the
\&\fIdosish.h\fR file up in tha source distribution fo' mo' shiznit).
.PP
Da Win95/NT installation, when rockin tha ActiveState port of Perl,
will modify tha Registry ta associate tha \f(CW\*(C`.pl\*(C'\fR extension wit the
perl interpreter n' shit. If you install another port, like even building
your own Win95/NT Perl from tha standard sources by rockin a Windows port
of gcc (e.g., wit cygwin or mingw32), then you gonna gotta modify
the Registry yo ass. In addizzle ta associatin \f(CW\*(C`.pl\*(C'\fR wit the
interpreter, \s-1NT\s0 playas can use: \f(CW\*(C`SET PATHEXT=%PATHEXT%;.PL\*(C'\fR ta let them
run tha program \f(CW\*(C`install\-linux.pl\*(C'\fR merely by typin \f(CW\*(C`install\-linux\*(C'\fR.
.PP
Under \*(L"Classic\*(R" MacOS, a perl program gonna git tha appropriate Creator and
Type, so dat double-clickin dem will invoke tha MacPerl application.
Under Mac \s-1OS X,\s0 clickable apps can be made from any \f(CW\*(C`#!\*(C'\fR script rockin Wil
Sanchez' DropScript utility: <http://www.wsanchez.net/software/> .
.PP
\&\fI\s-1IMPORTANT\s0!\fR: Whatever you do, \s-1PLEASE\s0 don't git frustrated, n' just
throw tha perl interpreta tha fuck into yo' cgi-bin directory, up in order to
get yo' programs hustlin fo' a wizzy server n' shit. This be a \s-1EXTREMELY\s0 big
securitizzle risk. Take tha time ta figure up how tha fuck ta do it erectly.
.SS "Can I write useful Perl programs on tha command line?"
.IX Subsection "Can I write useful Perl programs on tha command line?"
Yes yes y'all. Read perlrun fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Some examplez follow.
(These assume standard Unix shell quotin rules.)
.PP
.Vb 2
\&    # sum first n' last fields
\&    perl \-lane \*(Aqprint $F[0] + $F[\-1]\*(Aq *
\&
\&    # identify text files
\&    perl \-le \*(Aqfor(@ARGV) {print if \-f && \-T _}\*(Aq *
\&
\&    # remove (most) comments from C program
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
\&
\&    # make file a month younger than todizzle, defeatin reaper daemons
\&    perl \-e \*(Aq$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)\*(Aq *
\&
\&    # find first unused uid
\&    perl \-le \*(Aq$i++ while getpwuid($i); print $i\*(Aq
\&
\&    # display reasonable manpath
\&    echo $PATH | perl \-nl \-072 \-e \*(Aq
\&    s![^/+]*$!man!&&\-d&&!$s{$_}++&&push@m,$_;END{print"@m"}\*(Aq
.Ve
.PP
\&\s-1OK,\s0 tha last one was straight-up a Obfuscated Perl Contest entry. :\-)
.SS "Why don't Perl one-liners work on mah DOS/Mac/VMS system?"
.IX Subsection "Why don't Perl one-liners work on mah DOS/Mac/VMS system?"
Da problem is probably dat tha command interpretas on dem systems
have rather different scams bout quotin than tha Unix shells under
which tha one-liners was pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. On some systems, you may have to
change single-quotes ta double ones, which you must \fI\s-1NOT\s0\fR do on Unix
or Plan9 systems. Yo ass might also gotta chizzle a single % ta a %%.
.PP
For example:
.PP
.Vb 2
\&    # Unix (includin Mac OS X)
\&    perl \-e \*(Aqprint "Wuz crackalackin' ghetto\en"\*(Aq
\&
\&    # DOS, etc.
\&    perl \-e "print \e"Wuz crackalackin' ghetto\en\e""
\&
\&    # Mac Classic
\&    print "Wuz crackalackin' ghetto\en"
\&     (then Run "Myscript" or Shift\-Command\-R)
\&
\&    # MPW
\&    perl \-e \*(Aqprint "Wuz crackalackin' ghetto\en"\*(Aq
\&
\&    # VMS
\&    perl \-e "print ""Wuz crackalackin' ghetto\en"""
.Ve
.PP
Da problem is dat none of these examplez is reliable: they depend on the
command interpreter n' shit. Under Unix, tha straight-up original gangsta two often work. Under \s-1DOS,\s0
itz entirely possible dat neither works. If 4DOS was tha command shell,
you'd probably have betta luck like this:
.PP
.Vb 1
\&  perl \-e "print <Ctrl\-x>"Wuz crackalackin' ghetto\en<Ctrl\-x>""
.Ve
.PP
Under tha Mac, it dependz which environment yo ass is using. Da MacPerl
shell, or \s-1MPW,\s0 is much like Unix shells up in its support fo' several
quotin variants, except dat it make free use of tha Macs non-ASCII
charactas as control characters.
.PP
Usin \fIqq()\fR, q(), n' \fIqx()\fR, instead of \*(L"double quotes\*(R", 'single
quotes', n' `backticks`, may make one-liners easier ta write.
.PP
There is no general solution ta all of all dis bullshit. Well shiiiit, it aint nuthin but a mess.
.PP
[Some of dis answer was contributed by Kenneth Albanowski.]
.SS "Where can I learn bout \s-1CGI\s0 or Web programmin up in Perl?"
.IX Subsection "Where can I learn bout CGI or Web programmin up in Perl?"
For modules, git tha \s-1CGI\s0 or \s-1LWP\s0 modulez from \s-1CPAN.\s0 For textbooks,
see tha two especially all bout wizzy shiznit up in tha question on
books. For problems n' thangs related ta tha web, like \*(L"Why
do I git 500 Errors\*(R" or \*(L"Why don't it run from tha browser right
when it runs fine on tha command line\*(R", peep tha shitshooting
guides n' references up in perlfaq9 or up in tha \s-1CGI\s0 MetaFAQ:
.PP
.Vb 1
\&    L<http://www.perl.org/CGI_MetaFAQ.html>
.Ve
.PP
Lookin up in ta Plack n' modern Perl wizzy frameworks is highly recommended,
though; wizzy programmin up in Perl has evolved a long-ass way from tha oldschool minutes of
simple \s-1CGI\s0 scripts.
.SS "Where can I learn bout object-oriented Perl programming?"
.IX Subsection "Where can I learn bout object-oriented Perl programming?"
A phat place ta start is perltoot, n' you can use perlobj,
perlboot, perltoot, perltooc, n' perlbot fo' reference.
.PP
A phat book on \s-1OO\s0 on Perl is tha \*(L"Object-Oriented Perl\*(R"
by Damian Conway from Mannin Publications, or \*(L"Intermediate Perl\*(R"
by Randal Schwartz, brian d foy, n' Tomothy Phoenix from O'Reilly Media.
.SS "Where can I learn bout linkin C wit Perl?"
.IX Subsection "Where can I learn bout linkin C wit Perl?"
If you wanna call C from Perl, start wit perlxstut,
movin on ta perlxs, xsubpp, n' perlguts, n' you can put dat on yo' toast. If you want to
call Perl from C, then read perlembed, perlcall, and
perlguts, n' you can put dat on yo' toast. Don't forget dat you can learn a shitload from lookin at
how tha authorz of existin extension modulez freestyled they code and
solved they problems.
.PP
Yo ass might not need all tha juice of \s-1XS.\s0 Da Inline::C module lets
you put C code directly up in yo' Perl source. Well shiiiit, it handlez all the
magic ta make it work. Yo ass still gotta learn at least some of
the perl \s-1API\s0 but you won't gotta deal wit tha complexitizzle of the
\&\s-1XS\s0 support files.
.SS "I've read perlembed, perlguts, etc. yo, but I can't embed perl up in mah C program; what tha fuck is I bustin wrong?"
.IX Subsection "I've read perlembed, perlguts, etc. yo, but I can't embed perl up in mah C program; what tha fuck is I bustin wrong?"
Downlizzle tha ExtUtils::Embed kit from \s-1CPAN\s0 n' run `make test'. If
the tests pass, read tha podz again n' again n' again n' again n' again n' again n' again. I aint talkin' bout chicken n' gravy biatch. If they
fail, peep perlbug n' bust a funky-ass bug report wit tha output of
\&\f(CW\*(C`make test TEST_VERBOSE=1\*(C'\fR along wit \f(CW\*(C`perl \-V\*(C'\fR.
.SS "When I tried ta run mah script, I gots dis message. What do it mean?"
.IX Subsection "When I tried ta run mah script, I gots dis message. What do it mean?"
A complete list of Perlz error lyrics n' warnings wit explanatory
text can be found up in perldiag. Yo ass can also use tha splain program
(distributed wit Perl) ta explain tha error lyrics:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [\-v] [\-p] diag.out
.Ve
.PP
or chizzle yo' program ta explain tha lyrics fo' you:
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
or
.PP
.Vb 1
\&    use diagnostics \-verbose;
.Ve
.SS "Whatz MakeMaker?"
.IX Subsection "Whatz MakeMaker?"
(contributed by brian d foy)
.PP
Da ExtUtils::MakeMaker module, betta known simply as \*(L"MakeMaker\*(R",
turns a Perl script, typically called \f(CW\*(C`Makefile.PL\*(C'\fR, tha fuck into a Makefile.
Da Unix tool \f(CW\*(C`make\*(C'\fR uses dis file ta manage dependencies n' actions
to process n' install a Perl distribution.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez here is up in tha public
domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted n' encouraged ta use dis code n' any
derivatives thereof up in yo' own programs fo' funk or fo' profit as you
see fit fo' realz. A simple comment up in tha code givin credit ta tha \s-1FAQ\s0 would
be courteous but aint required.
