.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFORK 1"
.TH PERLFORK 1 "2014-09-26" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfork \- Perlz fork() emulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    NOTE:  Az of tha 5.8.0 release, fork() emulation has considerably
\&    matured. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat there be still all dem known bugs n' differences
\&    from real fork() dat might affect yo thugged-out ass.  See tha "BUGS" and
\&    "CAVEATS AND LIMITATIONS" sections below.
.Ve
.PP
Perl serves up a \fIfork()\fR keyword dat correspondz ta tha Unix system call
of tha same name.  On most Unix-like platforms where tha \fIfork()\fR system
call be available, Perlz \fIfork()\fR simply calls dat shit.
.PP
On some platforms like fuckin Windows where tha \fIfork()\fR system call is not
available, Perl can be built ta emulate \fIfork()\fR all up in tha interpreta level.
While tha emulation is designed ta be as compatible as possible wit the
real \fIfork()\fR all up in tha level of tha Perl program, there be certain
important differences dat stem from tha fact dat all tha pseudo child
\&\*(L"processes\*(R" pimped dis way live up in tha same real process as far as the
operatin system is concerned.
.PP
This document serves up a general overview of tha capabilitizzles and
limitationz of tha \fIfork()\fR emulation. I aint talkin' bout chicken n' gravy biatch.  Note dat tha thangs discussed here
are not applicable ta platforms where a real \fIfork()\fR be available n' Perl
has been configured ta use dat shit.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fIfork()\fR emulation is implemented all up in tha level of tha Perl interpreter.
What dis means up in general is dat hustlin \fIfork()\fR will straight-up clone the
runnin interpreta n' all its state, n' run tha cloned interpreta in
a separate thread, beginnin execution up in tha freshly smoked up thread just afta the
point where tha \fIfork()\fR was called up in tha parent.  Us thugs will refer ta the
thread dat implements dis lil pimp \*(L"process\*(R" as tha pseudo-process.
.PP
To tha Perl program dat called \fIfork()\fR, all dis is designed ta be
transparent.  Da parent returns from tha \fIfork()\fR wit a pseudo-process
\&\s-1ID\s0 dat can be subsequently used up in any process-manipulation functions;
the lil pimp returns from tha \fIfork()\fR wit a value of \f(CW0\fR ta signify that
it is tha lil pimp pseudo-process.
.SS "Behavior of other Perl features up in forked pseudo-processes"
.IX Subsection "Behavior of other Perl features up in forked pseudo-processes"
Most Perl features behave up in a natural way within pseudo-processes.
.ie n .IP "$$ or $PROCESS_ID" 8
.el .IP "$$ or \f(CW$PROCESS_ID\fR" 8
.IX Item "$$ or $PROCESS_ID"
This special variable is erectly set ta tha pseudo-process \s-1ID.\s0
It can be used ta identify pseudo-processes within a particular
session. I aint talkin' bout chicken n' gravy biatch.  Note dat dis value is subject ta recyclin if any
pseudo-processes is launched afta others done been \fIwait()\fR\-ed on.
.ie n .IP "%ENV" 8
.el .IP "\f(CW%ENV\fR" 8
.IX Item "%ENV"
Each pseudo-process maintains its own virtual environment.  Modifications
to \f(CW%ENV\fR affect tha virtual environment, n' is only visible within that
pseudo-process, n' up in any processes (or pseudo-processes) launched from
it.
.IP "\fIchdir()\fR n' all other builtins dat accept filenames" 8
.IX Item "chdir() n' all other builtins dat accept filenames"
Each pseudo-process maintains its own virtual scam of tha current directory.
Modifications ta tha current directory rockin \fIchdir()\fR is only visible within
that pseudo-process, n' up in any processes (or pseudo-processes) launched from
it.  All file n' directory accesses from tha pseudo-process will erectly
map tha virtual hustlin directory ta tha real hustlin directory appropriately.
.IP "\fIwait()\fR n' \fIwaitpid()\fR" 8
.IX Item "wait() n' waitpid()"
\&\fIwait()\fR n' \fIwaitpid()\fR can be passed a pseudo-process \s-1ID\s0 returned by \fIfork()\fR.
These calls will properly wait fo' tha termination of tha pseudo-process
and return its status.
.IP "\fIkill()\fR" 8
.IX Item "kill()"
\&\f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR can be used ta terminizzle a pseudo-process by
passin it tha \s-1ID\s0 returned by \fIfork()\fR. Da outcome of bust a cap up in on a pseudo-process
is unpredictable n' it should not be used except
under dire circumstances, cuz tha operatin system may not
guarantee integritizzle of tha process resources when a hustlin thread is
terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da process which implements tha pseudo-processes can be blocked
and tha Perl interpreta hangs. Note dat rockin \f(CW\*(C`kill(\*(AqKILL\*(Aq, ...)\*(C'\fR on a
pseudo\-\fIprocess()\fR may typically cause memory leaks, cuz tha thread
that implements tha pseudo-process do not git a cold-ass lil chizzle ta clean up
its resources.
.Sp
\&\f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR can also be used on pseudo-processes yo, but the
signal aint gonna be served up while tha pseudo-process is blocked by a
system call, e.g. waitin fo' a socket ta connect, or tryin ta read
from a socket wit no data available.  Startin up in Perl 5.14 the
parent process aint gonna wait fo' lil pimps ta exit once they have been
signalled wit \f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR ta avoid deadlock durin process
exit.  Yo ass will gotta explicitly call \fIwaitpid()\fR ta make shizzle the
child has time ta clean-up itself yo, but yo ass is then also responsible
that tha lil pimp aint blockin on I/O either.
.IP "\fIexec()\fR" 8
.IX Item "exec()"
Callin \fIexec()\fR within a pseudo-process straight-up spawns tha requested
executable up in a separate process n' waits fo' it ta complete before
exitin wit tha same exit status as dat process.  This means dat the
process \s-1ID\s0 reported within tha hustlin executable is ghon be different from
what tha earlier Perl \fIfork()\fR might have returned. Y'all KNOW dat shit, muthafucka!  Similarly, any process
manipulation functions applied ta tha \s-1ID\s0 returned by \fIfork()\fR will affect the
waitin pseudo-process dat called \fIexec()\fR, not tha real process it is
waitin fo' afta tha \fIexec()\fR.
.Sp
When \fIexec()\fR is called inside a pseudo-process then \s-1DESTROY\s0 methodz and
\&\s-1END\s0 blocks will still be called afta tha external process returns.
.IP "\fIexit()\fR" 8
.IX Item "exit()"
\&\fIexit()\fR always exits just tha executin pseudo-process, afta automatically
\&\fIwait()\fR\-in fo' any outstandin lil pimp pseudo-processes.  Note dat dis means
that tha process as a whole aint gonna exit unless all hustlin pseudo-processes
have exited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See below fo' some limitations wit open filehandles.
.IP "Open handlez ta files, directories n' network sockets" 8
.IX Item "Open handlez ta files, directories n' network sockets"
All open handlez is \fIdup()\fR\-ed up in pseudo-processes, so dat closing
any handlez up in one process do not affect tha others.  See below for
some limitations.
.SS "Resource limits"
.IX Subsection "Resource limits"
In tha eyez of tha operatin system, pseudo-processes pimped via tha \fIfork()\fR
emulation is simply threadz up in tha same process.  This means dat any
process-level limits imposed by tha operatin system apply ta all
pseudo-processes taken together n' shit.  This includes any limits imposed by the
operatin system on tha number of open file, directory n' socket handles,
limits on disk space usage, limits on memory size, limits on \s-1CPU\s0 utilization
etc.
.SS "Bustin' tha parent process"
.IX Subsection "Bustin' tha parent process"
If tha parent process is capped (either rockin Perlz \fIkill()\fR builtin, or
usin some external means) all tha pseudo-processes is capped as well,
and tha whole process exits.
.SS "Lifetime of tha parent process n' pseudo-processes"
.IX Subsection "Lifetime of tha parent process n' pseudo-processes"
Durin tha aiiight course of events, tha parent process n' every
pseudo-process started by it will wait fo' they respectizzle pseudo-children
to complete before they exit.  This means dat tha parent n' every
pseudo-child pimped by it dat be also a pseudo-parent will only exit
afta they pseudo-lil pimps have exited.
.PP
Startin wit Perl 5.14 a parent aint gonna \fIwait()\fR automatically
for any lil pimp dat has been signalled wit \f(CW\*(C`kill(\*(AqTERM\*(Aq, ...)\*(C'\fR
to avoid a thugged-out deadlock up in case tha lil pimp is blockin on I/O and
never receives tha signal.
.SH "CAVEATS AND LIMITATIONS"
.IX Header "CAVEATS AND LIMITATIONS"
.IP "\s-1BEGIN\s0 blocks" 8
.IX Item "BEGIN blocks"
Da \fIfork()\fR emulation aint gonna work entirely erectly when called from
within a \s-1BEGIN\s0 block.  Da forked copy will run tha contentz of the
\&\s-1BEGIN\s0 block yo, but aint gonna continue parsin tha source stream afta the
\&\s-1BEGIN\s0 block.  For example, consider tha followin code:
.Sp
.Vb 5
\&    BEGIN {
\&        fork n' exit;          # fork lil pimp n' exit tha parent
\&        print "inner\en";
\&    }
\&    print "outer\en";
.Ve
.Sp
This will print:
.Sp
.Vb 1
\&    inner
.Ve
.Sp
rather than tha expected:
.Sp
.Vb 2
\&    inner
\&    outer
.Ve
.Sp
This limitation arises from fundamenstrual technical bullshit in
clonin n' restartin tha stacks used by tha Perl parser up in the
middle of a parse.
.IP "Open filehandles" 8
.IX Item "Open filehandles"
Any filehandlez open all up in tha time of tha \fIfork()\fR is ghon be \fIdup()\fR\-ed. Y'all KNOW dat shit, muthafucka!  Thus,
the filez can be closed independently up in tha parent n' lil pimp yo, but beware
that tha \fIdup()\fR\-ed handlez will still share tha same seek pointer n' shit.  Changing
the seek posizzle up in tha parent will chizzle it up in tha lil pimp n' vice-versa.
One can avoid dis by openin filez dat need distinct seek pointers
separately up in tha child.
.Sp
On some operatin systems, notably Solaris n' Unixware, callin \f(CW\*(C`exit()\*(C'\fR
from a cold-ass lil lil pimp process will flush n' close open filehandlez up in tha parent,
thereby corruptin tha filehandles.  On these systems, callin \f(CW\*(C`_exit()\*(C'\fR
is suggested instead. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`_exit()\*(C'\fR be available up in Perl all up in tha 
\&\f(CW\*(C`POSIX\*(C'\fR module.  Please consult yo' systemz manpages fo' mo' shiznit
on all dis bullshit.
.IP "Open directory handles" 8
.IX Item "Open directory handles"
Perl will straight-up read from all open directory handlez until they
reach tha end of tha stream.  It will then \fIseekdir()\fR back ta the
original gangsta location n' all future \fIreaddir()\fR requests is ghon be fulfilled
from tha cache buffer n' shit.  That means dat neither tha directory handle held
by tha parent process nor tha one held by tha lil pimp process will see
any chizzlez made ta tha directory afta tha \fIfork()\fR call.
.Sp
Note dat \fIrewinddir()\fR has a similar limitation on Windows n' will not
force \fIreaddir()\fR ta read tha directory again n' again n' again either n' shit.  Only a newly
opened directory handle will reflect chizzlez ta tha directory.
.IP "Forkin pipe \fIopen()\fR not yet implemented" 8
.IX Item "Forkin pipe open() not yet implemented"
Da \f(CW\*(C`open(FOO, "|\-")\*(C'\fR n' \f(CW\*(C`open(BAR, "\-|")\*(C'\fR constructs is not yet
implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This limitation can be easily hit dat shiznit round up in freshly smoked up code
by bustin a pipe explicitly.  Da followin example shows how tha fuck to
write ta a gangbangin' forked child:
.Sp
.Vb 10
\&    # simulate open(FOO, "|\-")
\&    sub pipe_to_fork ($) {
\&        mah $parent = shift;
\&        pipe mah $child, $parent or die;
\&        mah $pid = fork();
\&        take a thugged-out dirtnap "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDIN, "<&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_to_fork(\*(AqFOO\*(Aq)) {
\&        # parent
\&        print FOO "pipe_to_fork\en";
\&        close FOO;
\&    }
\&    else {
\&        # child
\&        while (<STDIN>) { print; }
\&        exit(0);
\&    }
.Ve
.Sp
And dis one readz from tha child:
.Sp
.Vb 10
\&    # simulate open(FOO, "\-|")
\&    sub pipe_from_fork ($) {
\&        mah $parent = shift;
\&        pipe $parent, mah $child or die;
\&        mah $pid = fork();
\&        take a thugged-out dirtnap "fork() failed: $!" unless defined $pid;
\&        if ($pid) {
\&            close $child;
\&        }
\&        else {
\&            close $parent;
\&            open(STDOUT, ">&=" . fileno($child)) or die;
\&        }
\&        $pid;
\&    }
\&
\&    if (pipe_from_fork(\*(AqBAR\*(Aq)) {
\&        # parent
\&        while (<BAR>) { print; }
\&        close BAR;
\&    }
\&    else {
\&        # child
\&        print "pipe_from_fork\en";
\&        exit(0);
\&    }
.Ve
.Sp
Forkin pipe \fIopen()\fR constructs is ghon be supported up in future.
.IP "Global state maintained by XSUBs" 8
.IX Item "Global state maintained by XSUBs"
External subroutines (XSUBs) dat maintain they own global state may
not work erectly.  Such XSUBs will either need ta maintain locks to
protect simultaneous access ta global data from different pseudo-processes,
or maintain all they state on tha Perl symbol table, which is copied
naturally when \fIfork()\fR is called. Y'all KNOW dat shit, muthafucka!  A callback mechanizzle dat provides
extensions a opportunitizzle ta clone they state is ghon be provided up in the
near future.
.IP "Interpreta embedded up in larger application" 8
.IX Item "Interpreta embedded up in larger application"
Da \fIfork()\fR emulation may not behave as expected when it is executed up in an
application which embedz a Perl interpreta n' calls Perl APIs dat can
evaluate bitz of Perl code.  This stems from tha fact dat tha emulation
only has knowledge bout tha Perl interpreterz own data structures and
knows not a god damn thang bout tha containin applicationz state.  For example, any
state carried on tha applicationz own call stack is outta reach.
.IP "Thread-safety of extensions" 8
.IX Item "Thread-safety of extensions"
Since tha \fIfork()\fR emulation runs code up in multiple threads, extensions
callin tha fuck into non-thread-safe libraries may not work reliably when
callin \fIfork()\fR.  As Perlz threadin support gradually becomes more
widely adopted even on platforms wit a natizzle \fIfork()\fR, such extensions
are sposed ta fuckin be fixed fo' thread-safety.
.SH "PORTABILITY CAVEATS"
.IX Header "PORTABILITY CAVEATS"
In portable Perl code, \f(CW\*(C`kill(9, $child)\*(C'\fR must not be used on forked processes.
Bustin' a gangbangin' forked process is unsafe n' has unpredictable thangs up in dis biatch.
See \*(L"\fIkill()\fR\*(R", above.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 8
Havin pseudo-process IDs be wack integers breaks down fo' tha integer
\&\f(CW\*(C`\-1\*(C'\fR cuz tha \fIwait()\fR n' \fIwaitpid()\fR functions treat dis number as
bein special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da tacit assumption up in tha current implementation is that
the system never allocates a thread \s-1ID\s0 of \f(CW1\fR fo' user threads.  A better
representation fo' pseudo-process IDs is ghon be implemented up in future.
.IP "\(bu" 8
In certain cases, tha OS-level handlez pimped by tha \fIpipe()\fR, \fIsocket()\fR,
and \fIaccept()\fR operators is apparently not duplicated accurately in
pseudo-processes.  This only happens up in some thangs yo, but where it
does happen, it may result up in deadlocks between tha read n' write ends
of pipe handles, or inabilitizzle ta bust or receive data across socket
handles.
.IP "\(bu" 8
This document may be incomplete up in some respects.
.SH "AUTHOR"
.IX Header "AUTHOR"
Support fo' concurrent interpretas n' tha \fIfork()\fR emulation was implemented
by ActiveState, wit fundin from Microsizzlez Corporation.
.PP
This document be authored n' maintained by Gurusamy Sarathy
<gsar@activestate.com>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"fork\*(R" up in perlfunc, perlipc
