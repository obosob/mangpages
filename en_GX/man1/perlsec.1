.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLSEC 1"
.TH PERLSEC 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlsec \- Perl security
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl is designed ta make it easy as fuck  ta program securely even when hustlin
with extra privileges, like setuid or setgid programs.  Unlike most
command line shells, which is based on multiple substitution passes on
each line of tha script, Perl uses a mo' conventionizzle evaluation scheme
with fewer hidden snags.  Additionally, cuz tha language has more
builtin functionality, it can rely less upon external (and possibly
untrustworthy) programs ta accomplish its purposes.
.SH "SECURITY VULNERABILITY CONTACT INFORMATION"
.IX Header "SECURITY VULNERABILITY CONTACT INFORMATION"
If you believe you have found a securitizzle vulnerabilitizzle up in Perl, please email
perl5\-security\-report@perl.org wit details.  This points ta a cold-ass lil closed
subscription, unarchived mailin list.  Please only use dis address for
securitizzle thangs up in tha Perl core, not fo' modulez independently distributed on
\&\s-1CPAN.\s0
.SH "SECURITY MECHANISMS AND CONCERNS"
.IX Header "SECURITY MECHANISMS AND CONCERNS"
.SS "Taint mode"
.IX Subsection "Taint mode"
Perl automatically enablez a set of special securitizzle checks, called \fItaint
mode\fR, when it detects its program hustlin wit differin real n' effective
user or crew IDs.  Da setuid bit up in Unix permissions is mode 04000, the
setgid bit mode 02000; either or both may be set.  Yo ass can also enable taint
mode explicitly by rockin tha \fB\-T\fR command line flag. This flag is
\&\fIstrongly\fR suggested fo' server programs n' any program run on behalf of
someone else, like fuckin a \s-1CGI\s0 script. Once taint mode is on, itz on for
the remainder of yo' script.
.PP
While up in dis mode, Perl takes special precautions called \fItaint
checks\fR ta prevent both obvious n' subtle traps.  Some of these checks
are reasonably simple, like fuckin verifyin dat path directories aren't
writable by others; careful programmers have always used checks like
these n' you can put dat on yo' toast.  Other checks, however, is dopest supported by tha language itself,
and it is these checks especially dat contribute ta bustin a set-id Perl
program mo' secure than tha correspondin C program.
.PP
Yo ass may not use data derived from outside yo' program ta affect
suttin' else outside yo' program\*(--at least, not by accident.  All
command line arguments, environment variables, locale shiznit (see
perllocale), thangs up in dis biatch of certain system calls (\f(CW\*(C`readdir()\*(C'\fR,
\&\f(CW\*(C`readlink()\*(C'\fR, tha variable of \f(CW\*(C`shmread()\*(C'\fR, tha lyrics returned by
\&\f(CW\*(C`msgrcv()\*(C'\fR, tha password, gcos n' shell fieldz returned by the
\&\f(CW\*(C`getpwxxx()\*(C'\fR calls), n' all file input is marked as \*(L"tainted\*(R".
Tainted data may not be used directly or indirectly up in any command
that invokes a sub-shell, nor up in any command dat modifies files,
directories, or processes, \fBwith tha followin exceptions\fR:
.IP "\(bu" 4
Arguments ta \f(CW\*(C`print\*(C'\fR n' \f(CW\*(C`syswrite\*(C'\fR is \fBnot\fR checked fo' taintedness.
.IP "\(bu" 4
Symbolic methods
.Sp
.Vb 1
\&    $obj\->$method(@args);
.Ve
.Sp
and symbolic sub references
.Sp
.Vb 2
\&    &{$foo}(@args);
\&    $foo\->(@args);
.Ve
.Sp
are not checked fo' taintedness.  This requires extra carefulness
unless you want external data ta affect yo' control flow.  Unless
you carefully limit what tha fuck these symbolic joints are, playas is able
to call functions \fBoutside\fR yo' Perl code, like fuckin POSIX::system,
in which case they is able ta run arbitrary external code.
.IP "\(bu" 4
Hash keys is \fBnever\fR tainted.
.PP
For efficiency reasons, Perl takes a cold-ass lil conservatizzle view of
whether data is tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If a expression gotz nuff tainted data,
any subexpression may be considered tainted, even if tha value
of tha subexpression aint itself affected by tha tainted data.
.PP
Because taintednizz be associated wit each scalar value, some
elementz of a array or hash can be tainted n' others not.
Da keyz of a hash is \fBnever\fR tainted.
.PP
For example:
.PP
.Vb 8
\&    $arg = shift;               # $arg is tainted
\&    $hid = $arg . \*(Aqbar\*(Aq;        # $hid be also tainted
\&    $line = <>;                 # Tainted
\&    $line = <STDIN>;            # Also tainted
\&    open FOO, "/home/me/bar" or take a thugged-out dirtnap $!;
\&    $line = <FOO>;              # Still tainted
\&    $path = $ENV{\*(AqPATH\*(Aq};       # Tainted yo, but peep below
\&    $data = \*(Aqabc\*(Aq;              # Not tainted
\&
\&    system "echo $arg";         # Insecure
\&    system "/bin/echo", $arg;   # Considered insecure
\&                                # (Perl don\*(Aqt know bout /bin/echo)
\&    system "echo $hid";         # Insecure
\&    system "echo $data";        # Insecure until PATH set
\&
\&    $path = $ENV{\*(AqPATH\*(Aq};       # $path now tainted
\&
\&    $ENV{\*(AqPATH\*(Aq} = \*(Aq/bin:/usr/bin\*(Aq;
\&    delete @ENV{\*(AqIFS\*(Aq, \*(AqCDPATH\*(Aq, \*(AqENV\*(Aq, \*(AqBASH_ENV\*(Aq};
\&
\&    $path = $ENV{\*(AqPATH\*(Aq};       # $path now NOT tainted
\&    system "echo $data";        # Is secure now!
\&
\&    open(FOO, "< $arg");        # OK \- read\-only file
\&    open(FOO, "> $arg");        # Not OK \- tryin ta write
\&
\&    open(FOO,"echo $arg|");     # Not OK
\&    open(FOO,"\-|")
\&        or exec \*(Aqecho\*(Aq, $arg;   # Also not OK
\&
\&    $shout = \`echo $arg\`;       # Insecure, $shout now tainted
\&
\&    unlink $data, $arg;         # Insecure
\&    umask $arg;                 # Insecure
\&
\&    exec "echo $arg";           # Insecure
\&    exec "echo", $arg;          # Insecure
\&    exec "sh", \*(Aq\-c\*(Aq, $arg;      # Straight-up insecure!
\&
\&    @filez = <*.c>;             # insecure (uses readdir() or similar)
\&    @filez = glob(\*(Aq*.c\*(Aq);       # insecure (uses readdir() or similar)
\&
\&    # In either case, tha thangs up in dis biatch of glob is tainted, since tha list of
\&    # filenames be reppin outside of tha program.
\&
\&    $bad = ($arg, 23);          # $bad is ghon be tainted
\&    $arg, \`true\`;               # Insecure (although it isn\*(Aqt straight-up)
.Ve
.PP
If you try ta do suttin' insecure, yo big-ass booty is ghon git a gangbangin' fatal error saying
suttin' like \*(L"Insecure dependency\*(R" or \*(L"Insecure \f(CW$ENV\fR{\s-1PATH\s0}\*(R".
.PP
Da exception ta tha principle of \*(L"one tainted value taints tha whole
expression\*(R" is wit tha ternary conditionizzle operator \f(CW\*(C`?:\*(C'\fR.  Since code
with a ternary conditional
.PP
.Vb 1
\&    $result = $tainted_value , biatch? "Untainted" : "Also untainted";
.Ve
.PP
is effectively
.PP
.Vb 5
\&    if ( $tainted_value ) {
\&        $result = "Untainted";
\&    } else {
\&        $result = "Also untainted";
\&    }
.Ve
.PP
it don't make sense fo' \f(CW$result\fR ta be tainted.
.SS "Launderin n' Detectin Tainted Data"
.IX Subsection "Launderin n' Detectin Tainted Data"
To test whether a variable gotz nuff tainted data, n' whose use would
thus trigger a \*(L"Insecure dependency\*(R" message, you can use the
\&\f(CW\*(C`tainted()\*(C'\fR function of tha Scalar::Util module, available up in your
nearby \s-1CPAN\s0 mirror, n' included up in Perl startin from tha release 5.8.0.
Or you may be able ta use tha followin \f(CW\*(C`is_tainted()\*(C'\fR function.
.PP
.Vb 4
\&    sub is_tainted {
\&        local $@;   # Don\*(Aqt pollute caller\*(Aqs value.
\&        return ! eval { eval("#" . substr(join("", @_), 0, 0)); 1 };
\&    }
.Ve
.PP
This function make use of tha fact dat tha presence of tainted data
anywhere within a expression rendaz tha entire expression tainted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It
would be inefficient fo' every last muthafuckin operator ta test every last muthafuckin argument for
taintedness.  Instead, tha slightly mo' efficient n' conservative
approach is used dat if any tainted value has been accessed within the
same expression, tha whole expression is considered tainted.
.PP
But testin fo' taintednizz gets you only so far. Shiiit, dis aint no joke.  Sometimes you have just
to clear yo' dataz taintedness.  Values may be untainted by rockin them
as keys up in a hash; otherwise tha only way ta bypass tha tainting
mechanizzle is by referencin subpatterns from a regular expression match.
Perl presumes dat if you reference a substrin rockin \f(CW$1\fR, \f(CW$2\fR, etc., that
you knew what tha fuck you was bustin when you freestyled tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  That means using
a bit of thought\*(--don't just blindly untaint anything, or you defeat the
entire mechanism.  It aint nuthin but betta ta verify dat tha variable has only good
charactas (for certain jointz of \*(L"good\*(R") rather than checkin whether it
has any wack characters.  Thatz cuz itz far too easy as fuck  ta miss bad
charactas dat you never thought of.
.PP
Herez a test ta make shizzle dat tha data gotz nuff not a god damn thang but \*(L"word\*(R"
charactas (alphabetics, numerics, n' underscores), a hyphen, a at sign,
or a thugged-out dot.
.PP
.Vb 5
\&    if ($data =~ /^([\-\e@\ew.]+)$/) {
\&        $data = $1;                     # $data now untainted
\&    } else {
\&        take a thugged-out dirtnap "Wack data up in \*(Aq$data\*(Aq";      # log dis somewhere
\&    }
.Ve
.PP
This is fairly secure cuz \f(CW\*(C`/\ew+/\*(C'\fR don't normally match shell
metacharacters, nor is dot, dash, or at goin ta mean suttin' special
to tha shell.  Use of \f(CW\*(C`/.+/\*(C'\fR would done been insecure up in theory cuz
it lets every last muthafuckin thang all up in yo, but Perl don't check fo' dis shit.  Da lesson
is dat when untainting, you must be exceedingly careful wit yo' patterns.
Launderin data rockin regular expression is tha \fIonly\fR mechanizzle for
untaintin dirty data, unless you use tha game detailed below ta fork
a lil pimp of lesser privilege.
.PP
Da example do not untaint \f(CW$data\fR if \f(CW\*(C`use locale\*(C'\fR is up in effect,
because tha charactas matched by \f(CW\*(C`\ew\*(C'\fR is determined by tha locale.
Perl considaz dat locale definitions is untrustworthy cuz they
contain data from outside tha program.  If yo ass is freestylin a
locale-aware program, n' wanna launder data wit a regular expression
containin \f(CW\*(C`\ew\*(C'\fR, put \f(CW\*(C`no locale\*(C'\fR ahead of tha expression up in tha same
block.  See \*(L"\s-1SECURITY\*(R"\s0 up in perllocale fo' further rap n' examples.
.ie n .SS "Switches On tha ""#!"" Line"
.el .SS "Switches On tha ``#!'' Line"
.IX Subsection "Switches On tha #! Line"
When you cook up a script executable, up in order ta make it usable as a
command, tha system will pass switches ta perl from tha scriptz #!
line.  Perl checks dat any command line switches given ta a setuid
(or setgid) script straight-up match tha ones set on tha #! line.  Some
Unix n' Unix-like environments impose a one-switch limit on tha #!
line, so you may need ta use suttin' like \f(CW\*(C`\-wU\*(C'\fR instead of \f(CW\*(C`\-w \-U\*(C'\fR
under such systems.  (This issue should arise only up in Unix or
Unix-like environments dat support #! n' setuid or setgid scripts.)
.ie n .SS "Taint mode n' @INC"
.el .SS "Taint mode n' \f(CW@INC\fP"
.IX Subsection "Taint mode n' @INC"
When tha taint mode (\f(CW\*(C`\-T\*(C'\fR) is up in effect, tha \*(L".\*(R" directory is removed
from \f(CW@INC\fR, n' tha environment variablez \f(CW\*(C`PERL5LIB\*(C'\fR n' \f(CW\*(C`PERLLIB\*(C'\fR
are ignored by Perl. Yo ass can still adjust \f(CW@INC\fR from outside the
program by rockin tha \f(CW\*(C`\-I\*(C'\fR command line option as explained in
perlrun. I aint talkin' bout chicken n' gravy biatch. Da two environment variablez is ignored cuz
they is obscured, n' a user hustlin a program could be unaware that
they is set, whereas tha \f(CW\*(C`\-I\*(C'\fR option is clearly visible and
therefore permitted.
.PP
Another way ta modify \f(CW@INC\fR without modifyin tha program, is ta use
the \f(CW\*(C`lib\*(C'\fR pragma, e.g.:
.PP
.Vb 1
\&  perl \-Mlib=/foo program
.Ve
.PP
Da benefit of rockin \f(CW\*(C`\-Mlib=/foo\*(C'\fR over \f(CW\*(C`\-I/foo\*(C'\fR, is dat tha former
will automagically remove any duplicated directories, while tha later
will not.
.PP
Note dat if a tainted strang be added ta \f(CW@INC\fR, tha following
problem is ghon be reported:
.PP
.Vb 1
\&  Insecure dependency up in require while hustlin wit \-T switch
.Ve
.SS "Cleanin Up Yo crazy-ass Path"
.IX Subsection "Cleanin Up Yo crazy-ass Path"
For "Insecure \f(CW$ENV{PATH}\fR" lyrics, you need ta set \f(CW$ENV{\*(AqPATH\*(Aq}\fR to
a known value, n' each directory up in tha path must be absolute and
non-writable by others than its balla n' group.  Yo ass may be surprised to
get dis message even if tha pathname ta yo' executable is fully
qualified. Y'all KNOW dat shit, muthafucka!  This is \fInot\fR generated cuz you didn't supply a gangbangin' full path
to tha program; instead, itz generated cuz you never set yo' \s-1PATH\s0
environment variable, or you didn't set it ta suttin' dat was safe.
Because Perl can't guarantee dat tha executable up in question aint itself
goin ta turn round n' execute some other program dat is dependent on
your \s-1PATH,\s0 it make shizzle you set tha \s-1PATH.\s0
.PP
Da \s-1PATH\s0 aint tha only environment variable which can cause problems.
Because some shells may use tha variablez \s-1IFS, CDPATH, ENV,\s0 and
\&\s-1BASH_ENV,\s0 Perl checks dat dem is either empty or untainted when
startin subprocesses. Yo ass may wish ta add suttin' like dis ta your
setid n' taint-checkin scripts.
.PP
.Vb 1
\&    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};   # Make %ENV safer
.Ve
.PP
It aint nuthin but also possible ta git tha fuck into shiznit wit other operations dat don't
care whether they use tainted joints, n' you can put dat on yo' toast.  Make judicious use of tha file
tests up in dealin wit any user-supplied filenames.  When possible, do
opens n' such \fBafter\fR properly droppin any special user (or group!)
privileges. Perl don't prevent you from openin tainted filenames fo' reading,
so be careful what tha fuck you print out.  Da taintin mechanizzle is intended to
prevent wack mistakes, not ta remove tha need fo' thought.
.PP
Perl do not call tha shell ta expand wild cardz when you pass \f(CW\*(C`system\*(C'\fR
and \f(CW\*(C`exec\*(C'\fR explicit parameta lists instead of strings wit possible shell
wildcardz up in em.  Unfortunately, tha \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`glob\*(C'\fR, and
backtick functions provide no such alternate callin convention, so more
subterfuge is ghon be required.
.PP
Perl serves up a reasonably safe way ta open a gangbangin' file or pipe from a setuid
or setgid program: just create a cold-ass lil lil pimp process wit reduced privilege who
does tha dirty work fo' yo thugged-out ass.  First, fork a cold-ass lil lil pimp rockin tha special
\&\f(CW\*(C`open\*(C'\fR syntax dat connects tha parent n' lil pimp by a pipe.  Now the
child resets its \s-1ID\s0 set n' any other per-process attributes, like
environment variables, umasks, current hustlin directories, back ta the
originals or known safe joints, n' you can put dat on yo' toast.  Then tha lil pimp process, which no longer
has any special permissions, do tha \f(CW\*(C`open\*(C'\fR or other system call.
Finally, tha lil pimp passes tha data it managed ta access back ta the
parent.  Because tha file or pipe was opened up in tha lil pimp while hustlin
under less privilege than tha parent, it aint apt ta be tricked into
fuckin wit suttin' it shouldn't.
.PP
Herez a way ta do backticks reasonably safely.  Notice how tha fuck tha \f(CW\*(C`exec\*(C'\fR is
not called wit a strang dat tha shell could expand. Y'all KNOW dat shit, muthafucka!  This is by far the
best way ta booty-call suttin' dat might be subjected ta shell escapes: just
never call tha shell at all.
.PP
.Vb 10
\&        use Gangsta \*(Aq\-no_match_vars\*(Aq;
\&        take a thugged-out dirtnap "Can\*(Aqt fork: $!" unless defined($pid = open(KID, "\-|"));
\&        if ($pid) {           # parent
\&            while (<KID>) {
\&                # do something
\&            }
\&            close KID;
\&        } else {
\&            mah @temp     = ($EUID, $EGID);
\&            mah $orig_uid = $UID;
\&            mah $orig_gid = $GID;
\&            $EUID = $UID;
\&            $EGID = $GID;
\&            # Drop privileges
\&            $UID  = $orig_uid;
\&            $GID  = $orig_gid;
\&            # Make shizzle privs is straight-up gone
\&            ($EUID, $EGID) = @temp;
\&            take a thugged-out dirtnap "Can\*(Aqt drop privileges"
\&                unless $UID == $EUID  && $GID eq $EGID;
\&            $ENV{PATH} = "/bin:/usr/bin"; # Minimal PATH.
\&            # Consider sanitizin tha environment even more.
\&            exec \*(Aqmyprog\*(Aq, \*(Aqarg1\*(Aq, \*(Aqarg2\*(Aq
\&                or take a thugged-out dirtnap "can\*(Aqt exec myprog: $!";
\&        }
.Ve
.PP
A similar game would work fo' wildcard expansion via \f(CW\*(C`glob\*(C'\fR, although
you can use \f(CW\*(C`readdir\*(C'\fR instead.
.PP
Taint checkin is most useful when although you trust yo ass not ta have
written a program ta give away tha farm, you don't necessarily trust them
who end up rockin it not ta try ta trick it tha fuck into bustin suttin' bad. Y'all KNOW dat shit, muthafucka!  This
is tha kind of securitizzle checkin thatz useful fo' set-id programs and
programs launched on one of mah thugsz behalf, like \s-1CGI\s0 programs.
.PP
This is like different, however, from not even trustin tha writa of the
code not ta try ta do suttin' evil.  Thatz tha kind of trust needed
when one of mah thugs handz you a program you've never peeped before n' says, \*(L"Here,
run all dis bullshit.\*(R"  For dat kind of safety, you might wanna check up tha Safe
module, included standard up in tha Perl distribution. I aint talkin' bout chicken n' gravy biatch.  This module allows the
programmer ta set up special compartments up in which all system operations
are trapped n' namespace access is carefully controlled. Y'all KNOW dat shit, muthafucka!  Safe should
not be considered bullet-proof, though: it aint gonna prevent tha foreign
code ta set up infinite loops, allocate gigabytez of memory, or even
abusin perl bugs ta make tha host interpreta crash or behave in
unpredictable ways. In any case itz betta avoided straight-up if you is
really concerned bout security.
.SS "Securitizzle Bugs"
.IX Subsection "Securitizzle Bugs"
Beyond tha obvious problems dat stem from givin special privileges to
systems as flexible as scripts, on nuff versionz of Unix, set-id scripts
are inherently insecure right from tha start.  Da problem be a race
condizzle up in tha kernel.  Between tha time tha kernel opens tha file to
see which interpreta ta run n' when tha (now-set-id) interpreta turns
around n' reopens tha file ta interpret it, tha file up in question may have
changed, especially if you have symbolic links on yo' system.
.PP
Fortunately, sometimes dis kernel \*(L"feature\*(R" can be disabled.
Unfortunately, there be two ways ta disable dat shit.  Da system can simply
outlaw scripts wit any set-id bit set, which don't help much.
Alternately, it can simply ignore tha set-id bits on scripts.
.PP
But fuck dat shiznit yo, tha word on tha street is dat if tha kernel set-id script feature aint disabled, Perl will
diss loudly dat yo' set-id script is insecure.  You'll need to
either disable tha kernel set-id script feature, or put a C wrapper around
the script.  A C wrapper is just a cold-ass lil compiled program dat do nothing
except call yo' Perl program.   Compiled programs is not subject ta the
kernel bug dat plagues set-id scripts, n' you can put dat on yo' toast.  Herez a simple wrapper, written
in C:
.PP
.Vb 6
\&    #define REAL_PATH "/path/to/script"
\&    main(ac, av)
\&        char **av;
\&    {
\&        execv(REAL_PATH, av);
\&    }
.Ve
.PP
Compile dis wrapper tha fuck into a funky-ass binary executable n' then make \fIit\fR rather
than yo' script setuid or setgid.
.PP
In recent years, vendors have begun ta supply systems free of this
inherent securitizzle bug.  On such systems, when tha kernel passes tha name
of tha set-id script ta open ta tha interpreter, rather than rockin a
pathname subject ta meddling, it instead passes \fI/dev/fd/3\fR.  This be a
special file already opened on tha script, so dat there can be no race
condizzle fo' evil scripts ta exploit.  On these systems, Perl should be
compiled wit \f(CW\*(C`\-DSETUID_SCRIPTS_ARE_SECURE_NOW\*(C'\fR.  Da \fIConfigure\fR
program dat buildz Perl tries ta figure dis up fo' itself, so you
should never gotta specify dis yo ass.  Most modern releases of
SysVr4 n' \s-1BSD 4.4\s0 use dis approach ta avoid tha kernel race condition.
.SS "Protectin Yo crazy-ass Programs"
.IX Subsection "Protectin Yo crazy-ass Programs"
There is a fuckin shitload of ways ta hide tha source ta yo' Perl programs,
with varyin levelz of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, cuz
the source code has ta be readable up in order ta be compiled and
interpreted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (That don't mean dat a \s-1CGI\s0 scriptz source is
readable by playas on tha web, though.)  So you gotta leave the
permissions all up in tha hoodly thugged-out 0755 level.  This lets 
people on yo' local system only peep yo' source.
.PP
Some playas mistakenly regard dis as a securitizzle problem.  If yo' program do
insecure thangs, n' relies on playas not knowin how tha fuck ta exploit them
insecurities, it aint secure.  It be often possible fo' one of mah thugs to
determine tha insecure thangs n' exploit dem without viewin the
source.  Securitizzle all up in obscurity, tha name fo' hidin yo' bugs
instead of fixin them, is lil securitizzle indeed.
.PP
Yo ass can try rockin encryption via source filtas (Filter::* from \s-1CPAN,\s0
or Filter::Util::Call n' Filter::Simple since Perl 5.8).
But crackers might be able ta decrypt dat shit.  Yo ass can try rockin tha byte
code compila n' interpreta busted lyrics bout below yo, but crackers might be
able ta de-compile dat shit.  Yo ass can try rockin tha native-code compiler
busted lyrics bout below yo, but crackers might be able ta disassemble dat shit.  These
pose varyin degreez of hang-up ta playas wantin ta git at your
code yo, but none can definitively conceal it (this is legit of every
language, not just Perl).
.PP
If you concerned bout playas profitin from yo' code, then the
bottom line is dat not a god damn thang but a restrictizzle license will give you
legal security.  License yo' software n' pepper it wit threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Yo crazy-ass access ta it do not hit you wit permission ta use it blah blah
blah.\*(R"  Yo ass should peep a lawyer ta be shizzle yo' licensez wordin will
stand up in court.
.SS "Unicode"
.IX Subsection "Unicode"
Unicode be a freshly smoked up n' complex technologizzle n' one may easily overlook
certain securitizzle pitfalls.  See perluniintro fo' a overview and
perlunicode fo' details, n' \*(L"Securitizzle Implications
of Unicode\*(R" up in perlunicode fo' securitizzle implications up in particular.
.SS "Algorithmic Complexitizzle Attacks"
.IX Subsection "Algorithmic Complexitizzle Attacks"
Certain internal algorithms used up in tha implementation of Perl can
be beat down by choosin tha input carefully ta consume big-ass amounts
of either time or space or both.  This can lead tha fuck into tha so-called
\&\fIDenial of Service\fR (DoS) attacks.
.IP "\(bu" 4
Hash Algorithm \- Hash algorithms like tha one used up in Perl is well
known ta be vulnerable ta collision attacks on they hash function.
Such attacks involve constructin a set of keys which collide into
the same bucket producin inefficient behavior. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. Such attacks often
depend on discoverin tha seed of tha hash function used ta map the
keys ta buckets, n' you can put dat on yo' toast. That seed is then used ta brute-force a key set which
can be used ta mount a thugged-out denial of steez attack. In Perl 5.8.1 chizzles
were introduced ta harden Perl ta such attacks, n' then lata in
Perl 5.18.0 these features was enhanced n' additionizzle protections
added.
.Sp
At tha time of dis writing, Perl 5.18.0 is considered ta be
well-hardened against algorithmic complexitizzle attacks on its hash
implementation. I aint talkin' bout chicken n' gravy biatch. This is largely owed ta tha followin measures
mitigate attacks:
.RS 4
.IP "Hash Seed Randomization" 4
.IX Item "Hash Seed Randomization"
In order ta make it impossible ta know what tha fuck seed ta generate a attack
key set for, dis seed is randomly initialized at process start. This
may be overridden by rockin tha \s-1PERL_HASH_SEED\s0 environment variable, see
\&\*(L"\s-1PERL_HASH_SEED\*(R"\s0 up in perlrun. I aint talkin' bout chicken n' gravy biatch. This environment variable controls how
items is straight-up stored, not how tha fuck they is presented via
\&\f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR n' \f(CW\*(C`each\*(C'\fR.
.IP "Hash Traversal Randomization" 4
.IX Item "Hash Traversal Randomization"
Independent of which seed is used up in tha hash function, \f(CW\*(C`keys\*(C'\fR,
\&\f(CW\*(C`values\*(C'\fR, n' \f(CW\*(C`each\*(C'\fR return shit up in a per-hash randomized order.
Modifyin a hash by insertion will chizzle tha iteration order of dat hash.
This behavior can be overridden by rockin \f(CW\*(C`hash_traversal_mask()\*(C'\fR from
Hash::Util or by rockin tha \s-1PERL_PERTURB_KEYS\s0 environment variable,
see \*(L"\s-1PERL_PERTURB_KEYS\*(R"\s0 up in perlrun. I aint talkin' bout chicken n' gravy biatch. Note dat dis feature controls the
\&\*(L"visible\*(R" order of tha keys, n' not tha actual order they is stored in.
.IP "Bucket Order Perturbance" 4
.IX Item "Bucket Order Perturbance"
When shit collide tha fuck into a given hash bucket tha order they is stored in
the chain is no longer predictable up in Perl 5.18. This has tha intention
to make it harder ta observe a cold-ass lil collisions. This behavior can be overridden by using
the \s-1PERL_PERTURB_KEYS\s0 environment variable, peep \*(L"\s-1PERL_PERTURB_KEYS\*(R"\s0 up in perlrun.
.IP "New Default Hash Function" 4
.IX Item "New Default Hash Function"
Da default hash function has been modified wit tha intention of making
it harder ta infer tha hash seed.
.IP "Alternatizzle Hash Functions" 4
.IX Item "Alternatizzle Hash Functions"
Da source code includes multiple hash algorithms ta chizzle from.  While we
believe dat tha default perl hash is robust ta attack, our crazy asses have included the
hash function Siphash as a gangbangin' fall-back option. I aint talkin' bout chicken n' gravy biatch fo' realz. At tha time of release of
Perl 5.18.0 Siphash is believed ta be of cryptographic strength.  This is
not tha default as it is much slower than tha default hash.
.RE
.RS 4
.Sp
Without compilin a special Perl, there is no way ta git tha exact same
behavior of any versions prior ta Perl 5.18.0. Da closest one can get
is by settin \s-1PERL_PERTURB_KEYS\s0 ta 0 n' settin tha \s-1PERL_HASH_SEED\s0
to a known value. Us dudes do not advise dem settings fo' thang use
due ta tha above securitizzle considerations.
.Sp
\&\fBPerl has never guaranteed any orderin of tha hash keys\fR, and
the orderin has already chizzled nuff muthafuckin times durin tha gametime of
Perl 5.  Also, tha orderin of hash keys has always been, n' continues
to be, affected by tha insertion order n' tha history of chizzlez made
to tha hash over its gametime.
.Sp
Also note dat while tha order of tha hash elements might be
randomized, dis \*(L"pseudo-ordering\*(R" should \fBnot\fR be used for
applications like shufflin a list randomly (use \f(CW\*(C`List::Util::shuffle()\*(C'\fR
for that, peep List::Util, a standard core module since Perl 5.8.0;
or tha \s-1CPAN\s0 module \f(CW\*(C`Algorithm::Numerical::Shuffle\*(C'\fR), or fo' generating
permutations (use e.g. tha \s-1CPAN\s0 modulez \f(CW\*(C`Algorithm::Permute\*(C'\fR or
\&\f(CW\*(C`Algorithm::FastPermute\*(C'\fR), or fo' any cryptographic applications.
.RE
.IP "\(bu" 4
Regular expressions \- Perlz regular expression engine is so called \s-1NFA
\&\s0(Non-deterministic Finite Automaton), which among other thangs means that
it can rather easily consume big-ass amountz of both time n' space if the
regular expression may match up in nuff muthafuckin ways.  Careful craftin of the
regular expressions can help but like often there straight-up aint much
one can do (the book \*(L"Masterin Regular Expressions\*(R" is required
reading, peep perlfaq2).  Hustlin outta space manifests itself by
Perl hustlin outta memory.
.IP "\(bu" 4
Sortin \- tha quicksort algorithm used up in Perls before 5.8.0 to
implement tha \fIsort()\fR function is straight-up easy as fuck  ta trick tha fuck into misbehaving
so dat it consumes a shitload of time.  Startin from Perl 5.8.0 a gangbangin' finger-lickin' different
sortin algorithm, mergesort, is used by default.  Mergesort cannot
misbehave on any input.
.PP
See <http://www.cs.rice.edu/~scrosby/hash/> fo' mo' shiznit,
and any computa science textbook on algorithmic complexity.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlrun fo' its description of cleanin up environment variables.
