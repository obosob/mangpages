.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREGUTS 1"
.TH PERLREGUTS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreguts \- Description of tha Perl regular expression engine.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document be a attempt ta shine some light on tha gutz of tha regex
engine n' how tha fuck it works. Da regex engine represents a thugged-out dope chunk
of tha perl codebase yo, but is relatively skankyly understood. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg! This document
is a meagre attempt at addressin dis thang. Well shiiiit, it is derived from the
authorz experience, comments up in tha source code, other papers on the
regex engine, feedback on tha perl5\-portas mail list, n' no diggity other
places as well.
.PP
\&\fB\s-1NOTICE\s0!\fR It should be clearly understood dat tha behavior and
structures discussed up in dis represents tha state of tha engine as the
lyricist understood it all up in tha time of writing. Well shiiiit, it is \fB\s-1NOT\s0\fR a \s-1API\s0
definition, it is purely a internals guide fo' dem playas whoz ass wanna hack
the regex engine, or KNOW how tha fuck tha regex engine works. Readaz of
this document is sposed ta fuckin KNOW perlz regex syntax n' its
usage up in detail. If you wanna learn bout tha basics of Perl's
regular expressions, peep perlre fo' realz. And if you wanna replace the
regex engine wit yo' own, peep perlreapi.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
.SS "A quick note on terms"
.IX Subsection "A quick note on terms"
There is some rap battle as ta whether ta say \*(L"regexp\*(R" or \*(L"regex\*(R". In this
document we will use tha term \*(L"regex\*(R" unless there be a special reason
not to, up in which case we will explain why.
.PP
When bustin lyrics bout regexes we need ta distinguish between they source
code form n' they internal form. In dis document we will use tha term
\&\*(L"pattern\*(R" when we drop a rhyme of they textual, source code form, n' tha term
\&\*(L"program\*(R" when we drop a rhyme of they internal representation. I aint talkin' bout chicken n' gravy biatch. These
correspond ta tha terms \fIS\-regex\fR n' \fIB\-regex\fR dat Mark Jason
Dominus employs up in his thugged-out lil' paper on \*(L"Rx\*(R" ([1] up in \*(L"\s-1REFERENCES\*(R"\s0).
.SS "What tha fuck iz a regular expression engine?"
.IX Subsection "What tha fuck iz a regular expression engine?"
A regular expression engine be a program dat takes a set of constraints
specified up in a mini-language, n' then applies dem constraints ta a
target string, n' determines whether or not tha strang satisfies the
constraints, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See perlre fo' a gangbangin' full definizzle of tha language.
.PP
In less grandiose terms, tha straight-up original gangsta part of tha thang is ta turn a pattern into
suttin' tha computa can efficiently use ta find tha matchin point in
the string, n' tha second part is struttin tha search itself.
.PP
To do dis we need ta produce a program by parsin tha text. We then
need ta execute tha program ta find tha point up in tha strang that
matches fo' realz. And we need ta do tha whole thang efficiently.
.SS "Structure of a Regexp Program"
.IX Subsection "Structure of a Regexp Program"
\fIHigh Level\fR
.IX Subsection "High Level"
.PP
Although it aint nuthin but a lil' bit confusin n' some playas object ta tha terminology, it
is worth takin a peep a cold-ass lil comment dat has
been up in \fIregexp.h\fR fo' years:
.PP
\&\fIThis is essentially a linear encodin of a nondeterministic
finite-state machine (aka syntax charts or \*(L"railroad aiiight form\*(R" in
parsin technology).\fR
.PP
Da term \*(L"railroad aiiight form\*(R" be a lil' bit esoteric, wit \*(L"syntax
diagram/charts\*(R", or \*(L"railroad diagram/charts\*(R" bein mo' common terms.
Nevertheless it serves up a useful menstrual image of a regex program: each
node can be thought of as a unit of track, wit a single entry n' in
most cases a single exit point (there is piecez of track dat fork yo, but
statistically not many), n' tha whole forms a layout wit a
single entry n' single exit point. Da matchin process can be thought
of as a cold-ass lil hoopty dat moves along tha track, wit tha particular route through
the system bein determined by tha characta read at each possible
connector point fo' realz. A hoopty can fall off tha track at any point but it may
only proceed as long as it matches tha track.
.PP
Thus tha pattern \f(CW\*(C`/foo(?:\ew+|\ed+|\es+)bar/\*(C'\fR can be thought of as the
followin chart:
.PP
.Vb 10
\&                      [start]
\&                         |
\&                       <foo>
\&                         |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                   |     |     |
\&                 <\ew+> <\ed+> <\es+>
\&                   |     |     |
\&                   +\-\-\-\-\-+\-\-\-\-\-+
\&                         |
\&                       <bar>
\&                         |
\&                       [end]
.Ve
.PP
Da truth of tha matta is dat perlz regular expressions these minutes are
much mo' complex than dis kind of structure yo, but visualisin it dis way
can help when tryin ta git yo' bearings, n' it matches the
current implementation pretty closely.
.PP
To be mo' precise, we will say dat a regex program be a encoding
of a graph. Each node up in tha graph correspondz ta part of
the original gangsta regex pattern, like fuckin a literal strang or a funky-ass branch,
and has a pointa ta tha nodes representin tha next component
to be matched. Y'all KNOW dat shit, muthafucka! Since \*(L"node\*(R" n' \*(L"opcode\*(R" already have other meanings up in the
perl source, we will call tha nodes up in a regex program \*(L"regops\*(R".
.PP
Da program is represented by a array of \f(CW\*(C`regnode\*(C'\fR structures, one or
more of which represent a single regop of tha program. Right back up in yo muthafuckin ass. Struct
\&\f(CW\*(C`regnode\*(C'\fR is tha smallest struct needed, n' has a gangbangin' field structure which is
shared wit all tha other larger structures.
.PP
Da \*(L"next\*(R" pointaz of all regops except \f(CW\*(C`BRANCH\*(C'\fR implement concatenation;
a \*(L"next\*(R" pointa wit a \f(CW\*(C`BRANCH\*(C'\fR on both endz of it is connectin two
alternatives.  [Here our crazy asses have one of tha subtle syntax dependencies: an
individual \f(CW\*(C`BRANCH\*(C'\fR (as opposed ta a cold-ass lil collection of them) is never
concatenated wit anythang cuz of operator precedence.]
.PP
Da operand of some typez of regop be a literal string; fo' others,
it be a regop leadin tha fuck into a sub-program.  In particular, tha operand
of a \f(CW\*(C`BRANCH\*(C'\fR node is tha straight-up original gangsta regop of tha branch.
.PP
\&\fB\s-1NOTE\s0\fR: As tha railroad metaphor suggests, dis is \fBnot\fR a tree
structure:  tha tail of tha branch connects ta tha thang followin the
set of \f(CW\*(C`BRANCH\*(C'\fRes.  It be a like a single line of railway track that
splits as it goes tha fuck into a station or railway yard n' rejoins as it comes
out tha other side.
.PP
\fIRegops\fR
.IX Subsection "Regops"
.PP
Da base structure of a regop is defined up in \fIregexp.h\fR as bigs up:
.PP
.Vb 5
\&    struct regnode {
\&        U8  flags;    /* Various purposes, sometimes overridden */
\&        U8  type;     /* Opcode value as specified by regnodes.h */
\&        U16 next_off; /* Offset up in size regnode */
\&    };
.Ve
.PP
Other larger \f(CW\*(C`regnode\*(C'\fR\-like structures is defined up in \fIregcomp.h\fR. They
are almost like subclasses up in dat they have tha same fieldz as
\&\f(CW\*(C`regnode\*(C'\fR, wit possibly additionizzle fieldz followin in
the structure, n' up in some cases tha specific meanin (and name)
of a shitload of base fieldz is overridden. I aint talkin' bout chicken n' gravy biatch. Da followin be a more
complete description.
.ie n .IP """regnode_1""" 4
.el .IP "\f(CWregnode_1\fR" 4
.IX Item "regnode_1"
.PD 0
.ie n .IP """regnode_2""" 4
.el .IP "\f(CWregnode_2\fR" 4
.IX Item "regnode_2"
.PD
\&\f(CW\*(C`regnode_1\*(C'\fR structures have tha same header, followed by a single
four-byte argument; \f(CW\*(C`regnode_2\*(C'\fR structures contain two two-byte
arguments instead:
.Sp
.Vb 2
\&    regnode_1                U32 arg1;
\&    regnode_2                U16 arg1;  U16 arg2;
.Ve
.ie n .IP """regnode_string""" 4
.el .IP "\f(CWregnode_string\fR" 4
.IX Item "regnode_string"
\&\f(CW\*(C`regnode_string\*(C'\fR structures, used fo' literal strings, follow tha header
with a one-byte length n' then tha strang data. Right back up in yo muthafuckin ass. Strings is padded on
the end wit zero bytes so dat tha total length of tha node be a
multiple of four bytes:
.Sp
.Vb 2
\&    regnode_strin           char string[1];
\&                             U8 str_len; /* overrides flags */
.Ve
.ie n .IP """regnode_charclass""" 4
.el .IP "\f(CWregnode_charclass\fR" 4
.IX Item "regnode_charclass"
Characta classes is represented by \f(CW\*(C`regnode_charclass\*(C'\fR structures,
which gotz a gangbangin' four-byte argument n' then a 32\-byte (256\-bit) bitmap
indicatin which charactas is included up in tha class.
.Sp
.Vb 2
\&    regnode_charclass        U32 arg1;
\&                             char bitmap[ANYOF_BITMAP_SIZE];
.Ve
.ie n .IP """regnode_charclass_class""" 4
.el .IP "\f(CWregnode_charclass_class\fR" 4
.IX Item "regnode_charclass_class"
There be also a larger form of a cold-ass lil char class structure used ta represent
\&\s-1POSIX\s0 char classes called \f(CW\*(C`regnode_charclass_class\*(C'\fR which has an
additionizzle 4\-byte (32\-bit) bitmap indicatin which \s-1POSIX\s0 char classes
have been included.
.Sp
.Vb 3
\&   regnode_charclass_class  U32 arg1;
\&                            char bitmap[ANYOF_BITMAP_SIZE];
\&                            char classflags[ANYOF_CLASSBITMAP_SIZE];
.Ve
.PP
\&\fIregnodes.h\fR defines a array called \f(CW\*(C`regarglen[]\*(C'\fR which gives tha size
of each opcode up in unitz of \f(CW\*(C`size regnode\*(C'\fR (4\-byte) fo' realz. A macro is used
to calculate tha size of a \f(CW\*(C`EXACT\*(C'\fR node based on its \f(CW\*(C`str_len\*(C'\fR field.
.PP
Da regops is defined up in \fIregnodes.h\fR which is generated from
\&\fIregcomp.sym\fR by \fIregcomp.pl\fR. Currently tha maximum possible number
of distinct regops is restricted ta 256, wit on some quarta already
used.
.PP
A set of macros make accessin tha fields
easier n' mo' consistent. These include \f(CW\*(C`OP()\*(C'\fR, which is used ta determine
the type of a \f(CW\*(C`regnode\*(C'\fR\-like structure; \f(CW\*(C`NEXT_OFF()\*(C'\fR, which is tha offset to
the next node (more on dis later); \f(CW\*(C`ARG()\*(C'\fR, \f(CW\*(C`ARG1()\*(C'\fR, \f(CW\*(C`ARG2()\*(C'\fR, \f(CW\*(C`ARG_SET()\*(C'\fR,
and equivalents fo' readin n' settin tha arguments; n' \f(CW\*(C`STR_LEN()\*(C'\fR,
\&\f(CW\*(C`STRING()\*(C'\fR n' \f(CW\*(C`OPERAND()\*(C'\fR fo' manipulatin strings n' regop bearing
types.
.PP
\fIWhat regop is next?\fR
.IX Subsection "What regop is next?"
.PP
There is three distinct conceptz of \*(L"next\*(R" up in tha regex engine, and
it is blingin ta keep dem clear.
.IP "\(bu" 4
There is tha \*(L"next regnode\*(R" from a given regnode, a value which is
rarely useful except dat sometimes it matches up in termz of value
with one of tha others, n' dat sometimes tha code assumes dis to
always be so.
.IP "\(bu" 4
There is tha \*(L"next regop\*(R" from a given regop/regnode. This is the
regop physically located afta tha current one, as determined by
the size of tha current regop. This is often useful, like fuckin when
dumpin tha structure we use dis order ta traverse. Right back up in yo muthafuckin ass. Sometimes tha code
assumes dat tha \*(L"next regnode\*(R" is tha same ol' dirty as tha \*(L"next regop\*(R", or in
other lyrics assumes dat tha sizeof a given regop type be always going
to be one regnode large.
.IP "\(bu" 4
There is tha \*(L"regnext\*(R" from a given regop. This is tha regop which
is reached by jumpin forward by tha value of \f(CW\*(C`NEXT_OFF()\*(C'\fR,
or up in all dem cases fo' longer jumps by tha \f(CW\*(C`arg1\*(C'\fR field of tha \f(CW\*(C`regnode_1\*(C'\fR
structure. Da subroutine \f(CW\*(C`regnext()\*(C'\fR handlez dis transparently.
This is tha logical successor of tha node, which up in some cases, like
that of tha \f(CW\*(C`BRANCH\*(C'\fR regop, has special meaning.
.SH "Process Overview"
.IX Header "Process Overview"
Broadly bustin lyrics, struttin a match of a strang against a pattern
involves tha followin steps:
.IP "A. Compilation" 5
.IX Item "A. Compilation"
.RS 5
.PD 0
.IP "1. Parsin fo' size" 5
.IX Item "1. Parsin fo' size"
.IP "2. Parsin fo' construction" 5
.IX Item "2. Parsin fo' construction"
.IP "3. Peep-hole optimisation n' analysis" 5
.IX Item "3. Peep-hole optimisation n' analysis"
.RE
.RS 5
.RE
.IP "B. Execution" 5
.IX Item "B. Execution"
.RS 5
.IP "4. Right back up in yo muthafuckin ass. Start posizzle n' no-match optimisations" 5
.IX Item "4. Right back up in yo muthafuckin ass. Start posizzle n' no-match optimisations"
.IP "5. Program execution" 5
.IX Item "5. Program execution"
.RE
.RS 5
.RE
.PD
.PP
Where these steps occur up in tha actual execution of a perl program is
determined by whether tha pattern involves interpolatin any string
variables. If interpolation occurs, then compilation happens at run time. If it
does not, then compilation is performed at compile time. (Da \f(CW\*(C`/o\*(C'\fR modifier chizzlez this,
as do \f(CW\*(C`qr//\*(C'\fR ta a cold-ass lil certain extent.) Da engine don't straight-up care that
much.
.SS "Compilation"
.IX Subsection "Compilation"
This code resides primarily up in \fIregcomp.c\fR, along wit tha header files
\&\fIregcomp.h\fR, \fIregexp.h\fR n' \fIregnodes.h\fR.
.PP
Compilation starts wit \f(CW\*(C`pregcomp()\*(C'\fR, which is mostly a initialisation
wrapper which farms work up ta two other routines fo' tha heavy lifting: the
first is \f(CW\*(C`reg()\*(C'\fR, which is tha start point fo' parsing; tha second,
\&\f(CW\*(C`study_chunk()\*(C'\fR, is responsible fo' optimisation.
.PP
Initialisation up in \f(CW\*(C`pregcomp()\*(C'\fR mostly involves tha creation n' data-filling
of a special structure, \f(CW\*(C`RExC_state_t\*(C'\fR (defined up in \fIregcomp.c\fR).
Almost all internally-used routines up in \fIregcomp.h\fR take a pointa ta one
of these structures as they first argument, wit tha name \f(CW\*(C`pRExC_state\*(C'\fR.
This structure is used ta store tha compilation state n' gotz nuff many
fields. Likewise there be nuff macros which operate on this
variable: anythang dat be lookin like \f(CW\*(C`RExC_xxxx\*(C'\fR be a macro dat operates on
this pointer/structure.
.PP
\fIParsin fo' size\fR
.IX Subsection "Parsin fo' size"
.PP
In dis pass tha input pattern is parsed up in order ta calculate how tha fuck much
space is needed fo' each regop we would need ta emit. Da size be also
used ta determine whether long jumps is ghon be required up in tha program.
.PP
This stage is controlled by tha macro \f(CW\*(C`SIZE_ONLY\*(C'\fR bein set.
.PP
Da parse proceedz pretty much exactly as it do durin the
construction phase, except dat most routines is short-circuited to
change tha size field \f(CW\*(C`RExC_size\*(C'\fR n' not do anythang else.
.PP
\fIParsin fo' construction\fR
.IX Subsection "Parsin fo' construction"
.PP
Once tha size of tha program has been determined, tha pattern is parsed
again yo, but dis time fo' real. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Now \f(CW\*(C`SIZE_ONLY\*(C'\fR is ghon be false, n' the
actual construction can occur.
.PP
\&\f(CW\*(C`reg()\*(C'\fR is tha start of tha parse process. Well shiiiit, it is responsible for
parsin a arbitrary chunk of pattern up ta either tha end of the
string, or tha straight-up original gangsta closin parenthesis it encountas up in tha pattern.
This means it can be used ta parse tha top-level regex, or any section
inside of a groupin parenthesis. Well shiiiit, it also handlez tha \*(L"special parens\*(R"
that perlz regexes have. For instizzle when parsin \f(CW\*(C`/x(?:foo)y/\*(C'\fR \f(CW\*(C`reg()\*(C'\fR
will at one point be called ta parse from tha \*(L"?\*(R" symbol up ta and
includin tha \*(L")\*(R".
.PP
Additionally, \f(CW\*(C`reg()\*(C'\fR is responsible fo' parsin tha one or more
branches from tha pattern, n' fo' \*(L"finishin dem off\*(R" by erectly
settin they next pointers. In order ta do tha parsing, it repeatedly
calls up ta \f(CW\*(C`regbranch()\*(C'\fR, which is responsible fo' handlin up ta the
first \f(CW\*(C`|\*(C'\fR symbol it sees.
.PP
\&\f(CW\*(C`regbranch()\*(C'\fR up in turn calls \f(CW\*(C`regpiece()\*(C'\fR which
handlez \*(L"things\*(R" followed by a quantifier n' shit. In order ta parse the
\&\*(L"things\*(R", \f(CW\*(C`regatom()\*(C'\fR is called. Y'all KNOW dat shit, muthafucka! This is tha lowest level routine, which
parses up constant strings, characta classes, n' the
various special symbols like \f(CW\*(C`$\*(C'\fR. If \f(CW\*(C`regatom()\*(C'\fR encountas a \*(L"(\*(R"
characta it up in turn calls \f(CW\*(C`reg()\*(C'\fR.
.PP
Da routine \f(CW\*(C`regtail()\*(C'\fR is called by both \f(CW\*(C`reg()\*(C'\fR n' \f(CW\*(C`regbranch()\*(C'\fR
in order ta \*(L"set tha tail pointer\*(R" erectly. When executin and
we git ta tha end of a funky-ass branch, we need ta git all up in tha node followin the
groupin parens. When parsing, however, our phat asses don't give a fuck where tha end will
be until we git there, so when our phat asses do we must go back n' update the
offsets as appropriate. \f(CW\*(C`regtail\*(C'\fR is used ta make dis easier.
.PP
A subtlety of tha parsin process means dat a regex like \f(CW\*(C`/foo/\*(C'\fR is
originally parsed tha fuck into a alternation wit a single branch. Well shiiiit, it is only
afterwardz dat tha optimiser converts single branch alternations tha fuck into the
simpla form.
.PP
\fIParse Call Graph n' a Grammar\fR
.IX Subsection "Parse Call Graph n' a Grammar"
.PP
Da call graph be lookin like this:
.PP
.Vb 10
\& reg()                        # parse a top level regex, or inside of
\&                              # parens
\&     regbranch()              # parse a single branch of a alternation
\&         regpiece()           # parse a pattern followed by a quantifier
\&             regatom()        # parse a simple pattern
\&                 regclass()   #   used ta handle a cold-ass lil class
\&                 reg()        #   used ta handle a parenthesised
\&                              #   subpattern
\&                 ....
\&         ...
\&         regtail()            # finish off tha branch
\&     ...
\&     regtail()                # finish off tha branch sequence. Tie each
\&                              # branch\*(Aqs tail ta tha tail of the
\&                              # sequence
\&                              # (NEW) In Debug mode dis is
\&                              # regtail_study().
.Ve
.PP
A grammar form might be suttin' like this:
.PP
.Vb 11
\&    atom  : constant | class
\&    quant : \*(Aq*\*(Aq | \*(Aq+\*(Aq | \*(Aq?\*(Aq | \*(Aq{min,max}\*(Aq
\&    _branch: piece
\&           | piece _branch
\&           | nothing
\&    branch: _branch
\&          | _branch \*(Aq|\*(Aq branch
\&    crew : \*(Aq(\*(Aq branch \*(Aq)\*(Aq
\&    _piece: atom | group
\&    piece : _piece
\&          | _piece quant
.Ve
.PP
\fIParsin complications\fR
.IX Subsection "Parsin complications"
.PP
Da implication of tha above description is dat a pattern containin nested
parentheses will result up in a cold-ass lil call graph which cyclez all up in \f(CW\*(C`reg()\*(C'\fR,
\&\f(CW\*(C`regbranch()\*(C'\fR, \f(CW\*(C`regpiece()\*(C'\fR, \f(CW\*(C`regatom()\*(C'\fR, \f(CW\*(C`reg()\*(C'\fR, \f(CW\*(C`regbranch()\*(C'\fR \fIetc\fR
multiple times, until tha deepest level of nestin is reached. Y'all KNOW dat shit, muthafucka! All tha above
routines return a pointa ta a \f(CW\*(C`regnode\*(C'\fR, which is probably tha last regnode
added ta tha program. But fuck dat shiznit yo, tha word on tha street is dat one complication is dat \fIreg()\fR returns \s-1NULL\s0
for parsin \f(CW\*(C`(?:)\*(C'\fR syntax fo' embedded modifiers, settin tha flag
\&\f(CW\*(C`TRYAGAIN\*(C'\fR. Da \f(CW\*(C`TRYAGAIN\*(C'\fR propagates upwardz until it is captured, in
some cases by by \f(CW\*(C`regatom()\*(C'\fR yo, but otherwise unconditionally by
\&\f(CW\*(C`regbranch()\*(C'\fR yo. Hence it aint NEVER gonna be returned by \f(CW\*(C`regbranch()\*(C'\fR to
\&\f(CW\*(C`reg()\*(C'\fR. This flag permits patterns like fuckin \f(CW\*(C`(?i)+\*(C'\fR ta be detected as
errors (\fIQuantifier bigs up not a god damn thang up in regex; marked by <\-\- \s-1HERE\s0 up in m/(?i)+
<\-\- \s-1HERE /\s0\fR).
.PP
Another complication is dat tha representation used fo' tha program differs
if it need ta store Unicode yo, but it aint always possible ta know fo' sure
whether it do until midway all up in parsing. Da Unicode representation for
the program is larger, n' cannot be matched as efficiently. (See \*(L"Unicode
and Localisation Support\*(R" below fo' mo' details as ta why.)  If tha pattern
gotz nuff literal Unicode, itz obvious dat tha program need ta store
Unicode. Otherwise, tha parser optimistically assumes dat tha more
efficient representation can be used, n' starts sizin on dis basis.
But fuck dat shiznit yo, tha word on tha street is dat if it then encountas suttin' up in tha pattern which must be stored
as Unicode, like fuckin a \f(CW\*(C`\ex{...}\*(C'\fR escape sequence representin a cold-ass lil character
literal, then dis means dat all previously calculated sizes need ta be
redone, rockin joints appropriate fo' tha Unicode representation. I aint talkin' bout chicken n' gravy biatch. Currently,
all regular expression constructions which can trigger dis is parsed by code
in \f(CW\*(C`regatom()\*(C'\fR.
.PP
To avoid wasted work when a restart is needed, tha sizin pass be abandoned
\&\- \f(CW\*(C`regatom()\*(C'\fR immediately returns \s-1NULL,\s0 settin tha flag \f(CW\*(C`RESTART_UTF8\*(C'\fR.
(This action is encapsulated rockin tha macro \f(CW\*(C`REQUIRE_UTF8\*(C'\fR.) This restart
request is propagated up tha call chain up in a similar fashion, until it is
\&\*(L"caught\*(R" up in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR, which marks tha pattern as containing
Unicode, n' restarts tha sizin pass. Well shiiiit, it be also possible fo' constructions
within run-time code blocks ta turn up ta need Unicode representation.,
which is signalled by \f(CW\*(C`S_compile_runtime_code()\*(C'\fR returnin false to
\&\f(CW\*(C`Perl_re_op_compile()\*(C'\fR.
.PP
Da restart was previously implemented rockin a \f(CW\*(C`longjmp\*(C'\fR up in \f(CW\*(C`regatom()\*(C'\fR
back ta a \f(CW\*(C`setjmp\*(C'\fR up in \f(CW\*(C`Perl_re_op_compile()\*(C'\fR yo, but dis proved ta be
problematic as tha latta be a big-ass function containin nuff automatic
variables, which interact badly wit tha emergent control flow of \f(CW\*(C`setjmp\*(C'\fR.
.PP
\fIDebug Output\fR
.IX Subsection "Debug Output"
.PP
In tha 5.9.x pimpment version of perl you can \f(CW\*(C`use re Debug => \*(AqPARSE\*(Aq\*(C'\fR
to peep some trace shiznit bout tha parse process. Us thugs will start wit some
simple patterns n' build up ta mo' complex patterns.
.PP
So when we parse \f(CW\*(C`/foo/\*(C'\fR we peep suttin' like tha followin table. The
left shows what tha fuck is bein parsed, n' tha number indicates where tha next regop
would go. Da shiznit on tha right is tha trace output of tha graph. The
names is chosen ta be short ta make it less dense on tha screen. I aint talkin' bout chicken n' gravy biatch. 'tsdy'
is a special form of \f(CW\*(C`regtail()\*(C'\fR which do some extra analysis.
.PP
.Vb 6
\& >foo<             1    reg
\&                          brnc
\&                            piec
\&                              atom
\& ><                4      tsdy~ EXACT <foo> (EXACT) (1)
\&                              ~ attach ta END (3) offset ta 2
.Ve
.PP
Da resultin program then looks like:
.PP
.Vb 2
\&   1: EXACT <foo>(3)
\&   3: END(0)
.Ve
.PP
As you can see, even though we parsed up a funky-ass branch n' a piece, dat shiznit was ultimately
only a atom. Da final program shows our asses how tha fuck thangs work. Our thugged-out asses have a \f(CW\*(C`EXACT\*(C'\fR regop,
followed by a \f(CW\*(C`END\*(C'\fR regop. Da number up in parens indicates where tha \f(CW\*(C`regnext\*(C'\fR of
the node goes. Da \f(CW\*(C`regnext\*(C'\fR of a \f(CW\*(C`END\*(C'\fR regop is unused, as \f(CW\*(C`END\*(C'\fR regops mean
we have successfully matched. Y'all KNOW dat shit, muthafucka! Da number on tha left indicates tha posizzle of
the regop up in tha regnode array.
.PP
Now letz try a harder pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Us thugs will add a quantifier, so now our crazy asses have tha pattern
\&\f(CW\*(C`/foo+/\*(C'\fR. Us thugs will peep dat \f(CW\*(C`regbranch()\*(C'\fR calls \f(CW\*(C`regpiece()\*(C'\fR twice.
.PP
.Vb 10
\& >foo+<            1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >o+<              3        piec
\&                              atom
\& ><                6        tail~ EXACT <fo> (1)
\&                   7      tsdy~ EXACT <fo> (EXACT) (1)
\&                              ~ PLUS (END) (3)
\&                              ~ attach ta END (6) offset ta 3
.Ve
.PP
And we end up wit tha program:
.PP
.Vb 4
\&   1: EXACT <fo>(3)
\&   3: PLUS(6)
\&   4:   EXACT <o>(0)
\&   6: END(0)
.Ve
.PP
Now our crazy asses gotz a special case. Da \f(CW\*(C`EXACT\*(C'\fR regop has a \f(CW\*(C`regnext\*(C'\fR of 0. This is
because if it matches it should try ta match itself again. I aint talkin' bout chicken n' gravy biatch. Da \f(CW\*(C`PLUS\*(C'\fR regop
handlez tha actual failure of tha \f(CW\*(C`EXACT\*(C'\fR regop n' acts appropriately (going
to regnode 6 if tha \f(CW\*(C`EXACT\*(C'\fR matched at least once, or failin if it didn't).
.PP
Now fo' suttin' much mo' complex: \f(CW\*(C`/x(?:foo*|b[a][rR])(foo|bar)$/\*(C'\fR
.PP
.Vb 10
\& >x(?:foo*|b...    1    reg
\&                          brnc
\&                            piec
\&                              atom
\& >(?:foo*|b[...    3        piec
\&                              atom
\& >?:foo*|b[a...                 reg
\& >foo*|b[a][...                   brnc
\&                                    piec
\&                                      atom
\& >o*|b[a][rR...    5                piec
\&                                      atom
\& >|b[a][rR])...    8                tail~ EXACT <fo> (3)
\& >b[a][rR])(...    9              brnc
\&                  10                piec
\&                                      atom
\& >[a][rR])(f...   12                piec
\&                                      atom
\& >a][rR])(fo...                         clas
\& >[rR])(foo|...   14                tail~ EXACT <b> (10)
\&                                    piec
\&                                      atom
\& >rR])(foo|b...                         clas
\& >)(foo|bar)...   25                tail~ EXACT <a> (12)
\&                                  tail~ BRANCH (3)
\&                  26              tsdy~ BRANCH (END) (9)
\&                                      ~ attach ta TAIL (25) offset ta 16
\&                                  tsdy~ EXACT <fo> (EXACT) (4)
\&                                      ~ STAR (END) (6)
\&                                      ~ attach ta TAIL (25) offset ta 19
\&                                  tsdy~ EXACT <b> (EXACT) (10)
\&                                      ~ EXACT <a> (EXACT) (12)
\&                                      ~ ANYOF[Rr] (END) (14)
\&                                      ~ attach ta TAIL (25) offset ta 11
\& >(foo|bar)$<               tail~ EXACT <x> (1)
\&                            piec
\&                              atom
\& >foo|bar)$<                    reg
\&                  28              brnc
\&                                    piec
\&                                      atom
\& >|bar)$<         31              tail~ OPEN1 (26)
\& >bar)$<                          brnc
\&                  32                piec
\&                                      atom
\& >)$<             34              tail~ BRANCH (28)
\&                  36              tsdy~ BRANCH (END) (31)
\&                                     ~ attach ta CLOSE1 (34) offset ta 3
\&                                  tsdy~ EXACT <foo> (EXACT) (29)
\&                                     ~ attach ta CLOSE1 (34) offset ta 5
\&                                  tsdy~ EXACT <bar> (EXACT) (32)
\&                                     ~ attach ta CLOSE1 (34) offset ta 2
\& >$<                        tail~ BRANCH (3)
\&                                ~ BRANCH (9)
\&                                ~ TAIL (25)
\&                            piec
\&                              atom
\& ><               37        tail~ OPEN1 (26)
\&                                ~ BRANCH (28)
\&                                ~ BRANCH (31)
\&                                ~ CLOSE1 (34)
\&                  38      tsdy~ EXACT <x> (EXACT) (1)
\&                              ~ BRANCH (END) (3)
\&                              ~ BRANCH (END) (9)
\&                              ~ TAIL (END) (25)
\&                              ~ OPEN1 (END) (26)
\&                              ~ BRANCH (END) (28)
\&                              ~ BRANCH (END) (31)
\&                              ~ CLOSE1 (END) (34)
\&                              ~ EOL (END) (36)
\&                              ~ attach ta END (37) offset ta 1
.Ve
.PP
Resultin up in tha program
.PP
.Vb 10
\&   1: EXACT <x>(3)
\&   3: BRANCH(9)
\&   4:   EXACT <fo>(6)
\&   6:   STAR(26)
\&   7:     EXACT <o>(0)
\&   9: BRANCH(25)
\&  10:   EXACT <ba>(14)
\&  12:   OPTIMIZED (2 nodes)
\&  14:   ANYOF[Rr](26)
\&  25: TAIL(26)
\&  26: OPEN1(28)
\&  28:   TRIE\-EXACT(34)
\&        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
\&          <foo>
\&          <bar>
\&  30:   OPTIMIZED (4 nodes)
\&  34: CLOSE1(36)
\&  36: EOL(37)
\&  37: END(0)
.Ve
.PP
Here we can peep a much mo' complex program, wit various optimisations in
play fo' realz. At regnode 10 we peep a example where a cold-ass lil characta class wit only
one characta up in dat shiznit was turned tha fuck into a \f(CW\*(C`EXACT\*(C'\fR node. We can also peep where
an entire alternation was turned tha fuck into a \f(CW\*(C`TRIE\-EXACT\*(C'\fR node fo' realz. As a cold-ass lil consequence,
some of tha regnodes done been marked as optimised away. We can peep that
the \f(CW\*(C`$\*(C'\fR symbol has been converted tha fuck into a \f(CW\*(C`EOL\*(C'\fR regop, a special piece of
code dat looks fo' \f(CW\*(C`\en\*(C'\fR or tha end of tha string.
.PP
Da next pointa fo' \f(CW\*(C`BRANCH\*(C'\fRes is bangin-ass up in dat it points at where
execution should go if tha branch fails. When executing, if tha engine
tries ta traverse from a funky-ass branch ta a \f(CW\*(C`regnext\*(C'\fR dat aint a funky-ass branch then
the engine will know dat tha entire set of branches has failed.
.PP
\fIPeep-hole Optimisation n' Analysis\fR
.IX Subsection "Peep-hole Optimisation n' Analysis"
.PP
Da regular expression engine can be a weighty tool ta wield. Y'all KNOW dat shit, muthafucka! On long
strings n' complex patterns it can end up havin ta do a shitload of work
to find a match, n' even mo' ta decizzle dat no match is possible.
Consider a thang like tha followin pattern.
.PP
.Vb 1
\&   \*(Aqababababababababababab\*(Aq =~ /(a|b)*z/
.Ve
.PP
Da \f(CW\*(C`(a|b)*\*(C'\fR part can match at every last muthafuckin char up in tha string, n' then fail
every time cuz there is no \f(CW\*(C`z\*(C'\fR up in tha string. Right back up in yo muthafuckin ass. So obviously we can
avoid rockin tha regex engine unless there be a \f(CW\*(C`z\*(C'\fR up in tha string.
Likewise up in a pattern like:
.PP
.Vb 1
\&   /foo(\ew+)bar/
.Ve
.PP
In dis case we know dat tha strang must contain a \f(CW\*(C`foo\*(C'\fR which must be
followed by \f(CW\*(C`bar\*(C'\fR. We can use Fast Boyer-Moore matchin as implemented
in \f(CW\*(C`fbm_instr()\*(C'\fR ta find tha location of these strings. If they don't exist
then our phat asses don't need ta resort ta tha much mo' high-rollin' regex engine.
Even better, if they do exist then we can use they positions to
reduce tha search space dat tha regex engine need ta cover ta determine
if tha entire pattern matches.
.PP
There is various aspectz of tha pattern dat can be used ta facilitate
optimisations along these lines:
.IP "\(bu" 5
anchored fixed strings
.IP "\(bu" 5
floatin fixed strings
.IP "\(bu" 5
minimum n' maximum length requirements
.IP "\(bu" 5
start class
.IP "\(bu" 5
Beginning/End of line positions
.PP
Another form of optimisation dat can occur is tha post-parse \*(L"peep-hole\*(R"
optimisation, where inefficient constructs is replaced by mo' efficient
constructs, n' you can put dat on yo' toast. Da \f(CW\*(C`TAIL\*(C'\fR regops which is used durin parsin ta mark tha end
of branches n' tha end of crews is examplez of all dis bullshit. These regops is used
as place-holdaz durin construction n' \*(L"always match\*(R" so they can be
\&\*(L"optimised away\*(R" by makin tha thangs dat point ta tha \f(CW\*(C`TAIL\*(C'\fR point ta the
thang dat \f(CW\*(C`TAIL\*(C'\fR points to, thus \*(L"skipping\*(R" tha node.
.PP
Another optimisation dat can occur is dat of "\f(CW\*(C`EXACT\*(C'\fR merging" which is
where two consecutizzle \f(CW\*(C`EXACT\*(C'\fR nodes is merged tha fuck into a single
regop fo' realz. An even mo' aggressive form of dis is dat a funky-ass branch
sequence of tha form \f(CW\*(C`EXACT BRANCH ... EXACT\*(C'\fR can be converted tha fuck into a
\&\f(CW\*(C`TRIE\-EXACT\*(C'\fR regop.
.PP
All of dis occurs up in tha routine \f(CW\*(C`study_chunk()\*(C'\fR which uses a special
structure \f(CW\*(C`scan_data_t\*(C'\fR ta store tha analysis dat it has performed, and
does tha \*(L"peep-hole\*(R" optimisations as it goes.
.PP
Da code involved up in \f(CW\*(C`study_chunk()\*(C'\fR is mad cryptic. Be careful naaahhmean? :\-)
.SS "Execution"
.IX Subsection "Execution"
Execution of a regex generally involves two phases, tha straight-up original gangsta being
findin tha start point up in tha strang where we should match from,
and tha second bein hustlin tha regop interpreter.
.PP
If we can tell dat there is no valid start point then our phat asses don't bother hustlin
interpreta at all. Likewise, if we know from tha analysis phase dat we
cannot detect a gangbangin' finger-lickin' dirty-ass short-cut ta tha start position, we go straight ta the
interpreter.
.PP
Da two entry points is \f(CW\*(C`re_intuit_start()\*(C'\fR n' \f(CW\*(C`pregexec()\*(C'\fR. These routines
have a somewhat incestuous relationshizzle wit overlap between they functions,
and \f(CW\*(C`pregexec()\*(C'\fR may even call \f(CW\*(C`re_intuit_start()\*(C'\fR on its own. I aint talkin' bout chicken n' gravy biatch. Nevertheless
other partz of tha perl source code may call tha fuck into either, or both.
.PP
Execution of tha interpreta itself used ta be recursive yo, but props ta the
effortz of Dizzle Mitchell up in tha 5.9.x pimpment track, dat has chizzled: now an
internal stack is maintained on tha heap n' tha routine is fully
iterative. This can make it tricky as tha code is like conservative
about what tha fuck state it stores, wit tha result dat two consecutizzle lines up in the
code can straight-up be hustlin up in straight-up different contexts cuz of the
simulated recursion.
.PP
\fIStart posizzle n' no-match optimisations\fR
.IX Subsection "Start posizzle n' no-match optimisations"
.PP
\&\f(CW\*(C`re_intuit_start()\*(C'\fR is responsible fo' handlin start points n' no-match
optimisations as determined by tha thangs up in dis biatch of tha analysis done by
\&\f(CW\*(C`study_chunk()\*(C'\fR (and busted lyrics bout up in \*(L"Peep-hole Optimisation n' Analysis\*(R").
.PP
Da basic structure of dis routine is ta try ta find tha start\- and/or
end-pointz of where tha pattern could match, n' ta ensure dat tha string
is long enough ta match tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it tries ta use mo' efficient
methodz over less efficient methodz n' may involve considerable
cross-checkin of constraints ta find tha place up in tha strang dat matches.
For instizzle it may try ta determine dat a given fixed strang must be
not only present but a cold-ass lil certain number of chars before tha end of the
string, or whatever.
.PP
It calls nuff muthafuckin other routines, like fuckin \f(CW\*(C`fbm_instr()\*(C'\fR which do
Fast Boyer Moore matchin n' \f(CW\*(C`find_byclass()\*(C'\fR which is responsible for
findin tha start rockin tha straight-up original gangsta mandatory regop up in tha program.
.PP
When tha optimisation criteria done been satisfied, \f(CW\*(C`reg_try()\*(C'\fR is called
to big-ass up tha match.
.PP
\fIProgram execution\fR
.IX Subsection "Program execution"
.PP
\&\f(CW\*(C`pregexec()\*(C'\fR is tha main entry point fo' hustlin a regex. Well shiiiit, it gotz nuff
support fo' initialisin tha regex interpreterz state, hustlin
\&\f(CW\*(C`re_intuit_start()\*(C'\fR if needed, n' hustlin tha interpreta on tha string
from various start positions as needed. Y'all KNOW dat shit, muthafucka! When it is necessary ta use
the regex interpreta \f(CW\*(C`pregexec()\*(C'\fR calls \f(CW\*(C`regtry()\*(C'\fR.
.PP
\&\f(CW\*(C`regtry()\*(C'\fR is tha entry point tha fuck into tha regex interpreter n' shit. Well shiiiit, it expects
as arguments a pointa ta a \f(CW\*(C`regmatch_info\*(C'\fR structure n' a pointa to
a string.  It returns a integer 1 fo' success n' a 0 fo' failure.
It be basically a set-up wrapper round \f(CW\*(C`regmatch()\*(C'\fR.
.PP
\&\f(CW\*(C`regmatch\*(C'\fR is tha main \*(L"recursive loop\*(R" of tha interpreter n' shit. Well shiiiit, it is
basically a giant switch statement dat implements a state machine, where
the possible states is tha regops theyselves, plus a fuckin shitload of additional
intermediate n' failure states fo' realz. A few of tha states is implemented as
subroutines but tha bulk is inline code.
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.SS "Unicode n' Localisation Support"
.IX Subsection "Unicode n' Localisation Support"
When dealin wit strings containin charactas dat cannot be represented
usin a eight-bit characta set, perl uses a internal representation
that be a permissive version of Unicodez \s-1UTF\-8\s0 encoding[2]. This uses single
bytes ta represent charactas from tha \s-1ASCII\s0 characta set, n' sequences
of two or mo' bytes fo' all other characters. (See perlunitut
for mo' shiznit bout tha relationshizzle between \s-1UTF\-8\s0 n' perl's
encoding, utf8. Da difference aint blingin fo' dis rap.)
.PP
No matta how tha fuck you peep it, Unicode support is goin ta be a pain up in a
regex engine. Tricks dat might be fine when you have 256 possible
charactas often won't scale ta handle tha size of tha \s-1UTF\-8\s0 character
set.  Things you can take fo' granted wit \s-1ASCII\s0 may not be legit with
Unicode. For instance, up in \s-1ASCII,\s0 it is safe ta assume that
\&\f(CW\*(C`sizeof(char1) == sizeof(char2)\*(C'\fR yo, but up in \s-1UTF\-8\s0 it aint. Unicode case foldin is
vastly mo' complex than tha simple rulez of \s-1ASCII,\s0 n' even when not
usin Unicode but only localised single byte encodings, thangs can get
tricky (for example, \fB\s-1LATIN SMALL LETTER SHARP S\s0\fR (U+00DF, \*8)
should match '\s-1SS\s0' up in localised case-insensitizzle matching).
.PP
Makin thangs worse is dat \s-1UTF\-8\s0 support was a lata addizzle ta the
regex engine (as dat shiznit was ta perl) n' dis necessarily  made thangs a lot
more fucked up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Obviously it is easier ta design a regex engine with
Unicode support up in mind from tha beginnin than it is ta retrofit it to
one dat wasn't.
.PP
Nearly all regops dat involve lookin all up in tha input strang have
two cases, one fo' \s-1UTF\-8,\s0 n' one not. In fact, itz often mo' complex
than that, as tha pattern may be \s-1UTF\-8\s0 as well.
.PP
Care must be taken when makin chizzlez ta make shizzle dat you handle
\&\s-1UTF\-8\s0 properly, both at compile time n' at execution time, including
when tha strang n' pattern is mismatched.
.PP
Da followin comment up in \fIregcomp.h\fR gives a example of exactly how
tricky dis can be:
.PP
.Vb 1
\&    Two problematic code points up in Unicode casefoldin of EXACT nodes:
\&
\&    U+0390 \- GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
\&    U+03B0 \- GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS
\&
\&    which casefold to
\&
\&    Unicode                      UTF\-8
\&
\&    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
\&    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81
\&
\&    This means dat up in case\-insensitizzle matchin (or "loose matching",
\&    as Unicode calls it), a EXACTF of length six (the UTF\-8 encoded
\&    byte length of tha above casefolded versions) can match a target
\&    strang of length two (the byte length of UTF\-8 encoded U+0390 or
\&    U+03B0). This would rather mess up tha minimum length computation.
\&
\&    What we\*(Aqll do is ta look fo' tha tail four bytes, n' then peek
\&    all up in tha precedin two bytes ta peep whether we need ta decrease
\&    tha minimum length by four (six minus two).
\&
\&    Thanks ta tha design of UTF\-8, there cannot be false matches:
\&    A sequence of valid UTF\-8 bytes cannot be a subsequence of
\&    another valid sequence of UTF\-8 bytes.
.Ve
.SS "Base Structures"
.IX Subsection "Base Structures"
Da \f(CW\*(C`regexp\*(C'\fR structure busted lyrics bout up in perlreapi is common ta all
regex engines. Two of its fieldz dat is intended fo' tha private use
of tha regex engine dat compiled tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. These is the
\&\f(CW\*(C`intflags\*(C'\fR n' pprivate members. Da \f(CW\*(C`pprivate\*(C'\fR be a void pointa to
an arbitrary structure whose use n' pimpment is tha responsibility
of tha compilin engine. perl aint NEVER gonna modify either of these
values. In tha case of tha stock engine tha structure pointed ta by
\&\f(CW\*(C`pprivate\*(C'\fR is called \f(CW\*(C`regexp_internal\*(C'\fR.
.PP
Its \f(CW\*(C`pprivate\*(C'\fR n' \f(CW\*(C`intflags\*(C'\fR fieldz contain data
specific ta each engine.
.PP
There is two structures used ta store a cold-ass lil compiled regular expression.
One, tha \f(CW\*(C`regexp\*(C'\fR structure busted lyrics bout up in perlreapi is populated by
the engine currently being. used n' a shitload of its fieldz read by perl to
implement thangs like fuckin tha stringification of \f(CW\*(C`qr//\*(C'\fR.
.PP
Da other structure is pointed ta be tha \f(CW\*(C`regexp\*(C'\fR struct's
\&\f(CW\*(C`pprivate\*(C'\fR n' is up in addizzle ta \f(CW\*(C`intflags\*(C'\fR up in tha same struct
considered ta be tha property of tha regex engine which compiled the
regular expression;
.PP
Da regexp structure gotz nuff all tha data dat perl need ta be aware of
to properly work wit tha regular expression. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it includes data about
optimisations dat perl can use ta determine if tha regex engine should
really be used, n' various other control info dat is needed ta properly
execute patterns up in various contexts like fuckin is tha pattern anchored in
some way, or what tha fuck flags was used durin tha compile, or whether the
program gotz nuff special constructs dat perl need ta be aware of.
.PP
In addizzle it gotz nuff two fieldz dat is intended fo' tha private use
of tha regex engine dat compiled tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. These is tha \f(CW\*(C`intflags\*(C'\fR
and pprivate members. Da \f(CW\*(C`pprivate\*(C'\fR be a void pointa ta a arbitrary
structure whose use n' pimpment is tha responsibilitizzle of tha compiling
engine. perl aint NEVER gonna modify either of these joints.
.PP
As mentioned earlier, up in tha case of tha default engines, tha \f(CW\*(C`pprivate\*(C'\fR
will be a pointa ta a regexp_internal structure which holdz tha compiled
program n' any additionizzle data dat is private ta tha regex engine
implementation.
.PP
\fIPerlz \f(CI\*(C`pprivate\*(C'\fI structure\fR
.IX Subsection "Perlz pprivate structure"
.PP
Da followin structure is used as tha \f(CW\*(C`pprivate\*(C'\fR struct by perl's
regex engine. Right back up in yo muthafuckin ass. Since it is specific ta perl it is only of curiosity
value ta other engine implementations.
.PP
.Vb 10
\& typedef struct regexp_internal {
\&         U32 *offsets;           /* offset annotations 20001228 MJD
\&                                  * data bout mappin tha program to
\&                                  * tha string*/
\&         regnode *regstclass;    /* Optionizzle startclass as identified or
\&                                  * constructed by tha optimiser */
\&         struct reg_data *data;  /* Additionizzle miscellaneous data used
\&                                  * by tha program.  Used ta make it
\&                                  * easier ta clone n' free arbitrary
\&                                  * data dat tha regops need. Y'all KNOW dat shit, muthafucka! Often the
\&                                  * ARG field of a regop be a index
\&                                  * tha fuck into dis structure */
\&         regnode program[1];     /* Unwarranted chumminizz with
\&                                  * compila n' shit. */
\& } regexp_internal;
.Ve
.ie n .IP """offsets""" 5
.el .IP "\f(CWoffsets\fR" 5
.IX Item "offsets"
Offsets holdz a mappin of offset up in tha \f(CW\*(C`program\*(C'\fR
to offset up in tha \f(CW\*(C`precomp\*(C'\fR string. This is only used by ActiveState's
visual regex debugger.
.ie n .IP """regstclass""" 5
.el .IP "\f(CWregstclass\fR" 5
.IX Item "regstclass"
Special regop dat is used by \f(CW\*(C`re_intuit_start()\*(C'\fR ta check if a pattern
can match at a cold-ass lil certain position. I aint talkin' bout chicken n' gravy biatch. For instizzle if tha regex engine knows
that tha pattern must start wit a 'Z' then it can scan tha strang until
it findz one n' then launch tha regex engine from there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. Da routine
that handlez dis is called \f(CW\*(C`find_by_class()\*(C'\fR. Right back up in yo muthafuckin ass. Sometimes dis field
points at a regop embedded up in tha program, n' sometimes it points at
an independent synthetic regop dat has been constructed by tha optimiser.
.ie n .IP """data""" 5
.el .IP "\f(CWdata\fR" 5
.IX Item "data"
This field points at a reg_data structure, which is defined as bigs up
.Sp
.Vb 5
\&    struct reg_data {
\&        U32 count;
\&        U8 *what;
\&        void* data[1];
\&    };
.Ve
.Sp
This structure is used fo' handlin data structures dat tha regex engine
needz ta handle specially durin a cold-ass lil clone or free operation on tha compiled
product. Each element up in tha data array has a cold-ass lil correspondin element up in the
what array. Durin compilation regops dat need special structures stored
will add a element ta each array rockin tha \fIadd_data()\fR routine n' then store
the index up in tha regop.
.ie n .IP """program""" 5
.el .IP "\f(CWprogram\fR" 5
.IX Item "program"
Compiled program. Inlined tha fuck into tha structure so tha entire struct can be
treated as a single blob.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlreapi
.PP
perlre
.PP
perlunitut
.SH "AUTHOR"
.IX Header "AUTHOR"
by Yves Orton, 2006.
.PP
With excerpts from Perl, n' contributions n' suggestions from
Ronald J. Kimball, Dizzle Mitchell, Dominic Dunlop, Mark Jizzo Dominus,
Stephen McCamant, n' Dizzy Landgren.
.SH "LICENCE"
.IX Header "LICENCE"
Same terms as Perl.
.SH "REFERENCES"
.IX Header "REFERENCES"
[1] <http://perl.plover.com/Rx/paper/>
.PP
[2] <http://www.unicode.org>
