.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDBMFILTER 1"
.TH PERLDBMFILTER 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldbmfilta \- Perl DBM Filters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    $db = tie %hash, \*(AqDBM\*(Aq, ...
\&
\&    $old_filta = $db\->filter_store_key  ( sub { ... } );
\&    $old_filta = $db\->filter_store_value( sub { ... } );
\&    $old_filta = $db\->filter_fetch_key  ( sub { ... } );
\&    $old_filta = $db\->filter_fetch_value( sub { ... } );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da four \f(CW\*(C`filter_*\*(C'\fR methodz shown above is available up in all tha \s-1DBM\s0
modulez dat shizzle wit Perl, namely DB_File, GDBM_File, NDBM_File,
ODBM_File n' SDBM_File.
.PP
Each of tha methodz works identically, n' is used ta install (or
uninstall) a single \s-1DBM\s0 Filter n' shit. Da only difference between dem is the
place dat tha filta is installed.
.PP
To summarise:
.IP "\fBfilter_store_key\fR" 5
.IX Item "filter_store_key"
If a gangbangin' filta has been installed wit dis method, it is ghon be invoked
every time you write a key ta a \s-1DBM\s0 database.
.IP "\fBfilter_store_value\fR" 5
.IX Item "filter_store_value"
If a gangbangin' filta has been installed wit dis method, it is ghon be invoked
every time you write a value ta a \s-1DBM\s0 database.
.IP "\fBfilter_fetch_key\fR" 5
.IX Item "filter_fetch_key"
If a gangbangin' filta has been installed wit dis method, it is ghon be invoked
every time you read a key from a \s-1DBM\s0 database.
.IP "\fBfilter_fetch_value\fR" 5
.IX Item "filter_fetch_value"
If a gangbangin' filta has been installed wit dis method, it is ghon be invoked
every time you read a value from a \s-1DBM\s0 database.
.PP
Yo ass can use any combination of tha methodz from none ta all four.
.PP
All filta methodz return tha existin filter, if present, or \f(CW\*(C`undef\*(C'\fR
if not.
.PP
To delete a gangbangin' filta pass \f(CW\*(C`undef\*(C'\fR ta dat shit.
.SS "Da Filter"
.IX Subsection "Da Filter"
When each filta is called by Perl, a local copy of \f(CW$_\fR will contain
the key or value ta be filtered. Y'all KNOW dat shit, muthafucka! Filterin be  bigged up  by modifying
the contentz of \f(CW$_\fR. Da return code from tha filta is ignored.
.SS "An Example: tha \s-1NULL\s0 termination problem."
.IX Subsection "An Example: tha NULL termination problem."
\&\s-1DBM\s0 Filtas is useful fo' a cold-ass lil class of problems where you \fIalways\fR
wanna make tha same transformation ta all keys, all joints or both.
.PP
For example, consider tha followin scenario. Yo ass gotz a \s-1DBM\s0 database
that you need ta share wit a third-party C application. I aint talkin' bout chicken n' gravy biatch. Da C application
assumes dat \fIall\fR keys n' joints is \s-1NULL\s0 terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Unfortunately
when Perl writes ta \s-1DBM\s0 databases it don't use \s-1NULL\s0 termination, so
your Perl application will gotta manage \s-1NULL\s0 termination itself. When
you write ta tha database yo big-ass booty is ghon gotta use suttin' like this:
.PP
.Vb 1
\&    $hash{"$key\e0"} = "$value\e0";
.Ve
.PP
Similarly tha \s-1NULL\s0 need ta be taken tha fuck into account when yo ass is thankin bout
the length of existin keys/values.
.PP
It would be much betta if you could ignore tha \s-1NULL\s0 terminations issue
in tha main application code n' gotz a mechanizzle dat automatically
added tha terminatin \s-1NULL\s0 ta all keys n' joints whenever you write to
the database n' have dem removed when you read from tha database fo' realz. As I'm
sure you have already guessed, dis be a problem dat \s-1DBM\s0 Filtas can
fix straight-up doggystyle.
.PP
.Vb 4
\&    use strict;
\&    use warnings;
\&    use SDBM_File;
\&    use Fcntl;
\&
\&    mah %hash;
\&    mah $filename = "filt";
\&    unlink $filename;
\&
\&    mah $db = tie(%hash, \*(AqSDBM_File\*(Aq, $filename, O_RDWR|O_CREAT, 0640)
\&      or take a thugged-out dirtnap "Cannot open $filename: $!\en";
\&
\&    # Install DBM Filters
\&    $db\->filter_fetch_key  ( sub { s/\e0$//    } );
\&    $db\->filter_store_key  ( sub { $_ .= "\e0" } );
\&    $db\->filter_fetch_value( 
\&        sub { no warnings \*(Aquninitialized\*(Aq; s/\e0$// } );
\&    $db\->filter_store_value( sub { $_ .= "\e0" } );
\&
\&    $hash{"abc"} = "def";
\&    mah $a = $hash{"ABC"};
\&    # ...
\&    undef $db;
\&    untie %hash;
.Ve
.PP
Da code above uses SDBM_File yo, but it will work wit any of tha \s-1DBM\s0
modules.
.PP
Hopefully tha contentz of each of tha filtas should be
self-explanatory. Both \*(L"fetch\*(R" filtas remove tha terminatin \s-1NULL,\s0
and both \*(L"store\*(R" filtas add a terminatin \s-1NULL.\s0
.SS "Another Example: Key be a C int."
.IX Subsection "Another Example: Key be a C int."
Here be another real-life example. By default, whenever Perl writes to
a \s-1DBM\s0 database it always writes tha key n' value as strings. Right back up in yo muthafuckin ass. So when
you use this:
.PP
.Vb 1
\&    $hash{12345} = "something";
.Ve
.PP
the key 12345 will git stored up in tha \s-1DBM\s0 database as tha 5 byte string
\&\*(L"12345\*(R". If you straight-up want tha key ta be stored up in tha \s-1DBM\s0 database
as a C int, yo big-ass booty is ghon gotta use \f(CW\*(C`pack\*(C'\fR when writing, n' \f(CW\*(C`unpack\*(C'\fR
when reading.
.PP
Here be a \s-1DBM\s0 Filta dat do it:
.PP
.Vb 6
\&    use strict;
\&    use warnings;
\&    use DB_File;
\&    mah %hash;
\&    mah $filename = "filt";
\&    unlink $filename;
\&
\&
\&    mah $db = tie %hash, \*(AqDB_File\*(Aq, $filename, O_CREAT|O_RDWR, 0666, $DB_HASH 
\&      or take a thugged-out dirtnap "Cannot open $filename: $!\en";
\&
\&    $db\->filter_fetch_key  ( sub { $_ = unpack("i", $_) } );
\&    $db\->filter_store_key  ( sub { $_ = pack ("i", $_) } );
\&    $hash{123} = "def";
\&    # ...
\&    undef $db;
\&    untie %hash;
.Ve
.PP
Da code above uses DB_File yo, but again n' again n' again it will work wit any of the
\&\s-1DBM\s0 modules.
.PP
This time only two filtas done been used; we only need ta manipulate
the contentz of tha key, so it wasn't necessary ta install any value
filters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DB_File, GDBM_File, NDBM_File, ODBM_File n' SDBM_File.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess
