'\" t
.\"  Copyright (c) 1998, 2013, Oracle and/or its affiliates fo' realz. All muthafuckin rights reserved.
.\"
.\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
.\"
.\" This code is free software; you can redistribute it and/or modify it
.\" under tha termz of tha GNU General Public License version 2 only, as
.\" published by tha Jacked Software Foundation.
.\"
.\" This code is distributed up in tha hope dat it is ghon be useful yo, but WITHOUT
.\" ANY WARRANTY; without even tha implied warranty of MERCHANTABILITY or
.\" FITNESS FOR A PARTICULAR PURPOSE. Right back up in yo muthafuckin ass. See tha GNU General Public License
.\" version 2 fo' mo' details (a copy is included up in tha LICENSE file that
.\" accompanied dis code).
.\"
.\" Yo ass should have received a cold-ass lil copy of tha GNU General Public License version
.\" 2 along wit dis work; if not, write ta tha Jacked Software Foundation,
.\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
.\"
.\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
.\" or visit www.oracle.com if you need additionizzle shiznit or have any
.\" thangs.
.\"
.\"     Arch: generic
.\"     Software: JDK 7
.\"     Date: 6 August 2013
.\"     SectDesc: Securitizzle Tools
.\"     Title: jarsigner.1
.\"
.if n .pl 99999
.TH jarsigner 1 "6 August 2013" "JDK 7" "Securitizzle Tools"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------

.SH NAME    
jarsigner \- Signs n' verifies Java Archive (JAR) files\&.
.SH SYNOPSIS    
.sp     
.nf     

\fBjarsigner\fR [ \fIoptions\fR ] \fIjar\-file\fR \fIalias\fR
.fi     
.nf     

\fBjarsigner\fR \fB\-verify\fR [ \fIoptions\fR ] \fIjar\-file\fR [\fIalias \&.\&.\&.\fR]
.fi     
.sp     
.TP     
\fIoptions\fR
Da command-line options\&. Right back up in yo muthafuckin ass. See Options\&.
.TP
-verify
.br
Da \f3-verify\fR option can take zero or mo' keystore alias names afta tha JAR file name\&. When tha \f3-verify\fR option is specified, tha \f3jarsigner\fR command checks dat tha certificate used ta verify each signed entry up in tha JAR file matches one of tha keystore aliases\&. Da aliases is defined up in tha keystore specified by \f3-keystore\fR or tha default keystore\&.

If you also specified tha \f3-strict\fR option, n' tha \f3jarsigner\fR command detected severe warnings, tha message, "jar verified, wit signer errors" is displayed\&.
.TP     
\fIjar-file\fR
Da JAR file ta be signed\&.

If you also specified tha \f3-strict\fR option, n' tha \f3jarsigner\fR command detected severe warnings, tha message, "jar signed, wit signer errors" is displayed\&.
.TP     
\fIalias\fR
Da aliases is defined up in tha keystore specified by \f3-keystore\fR or tha default keystore\&.
.SH DESCRIPTION    
Da \f3jarsigner\fR tool has two purposes:
.TP 0.2i    
\(bu
To sign Java Archive (JAR) files\&.
.TP 0.2i    
\(bu
To verify tha signatures n' integritizzle of signed JAR files\&.
.PP
Da JAR feature enablez tha packagin of class files, images, sounds, n' other digital data up in a single file fo' fasta n' easier distribution\& fo' realz. A tool named \f3jar\fR enablez pimpers ta produce JAR files\&. (Technically, any zip file can also be considered a JAR file, although when pimped by tha \f3jar\fR command or processed by tha \f3jarsigner\fR command, JAR filez also contain a \f3META-INF/MANIFEST\&.MF\fR file\&.)
.PP
A digital signature be a strang of bits dat is computed from some data (the data bein signed) n' tha private key of a entitizzle (a person, company, n' so on)\&. Right back up in yo muthafuckin ass. Similar ta a handwritten signature, a gangbangin' finger-lickin' digital signature has nuff useful characteristics:
.TP 0.2i    
\(bu
Its authenticitizzle can be verified by a cold-ass lil computation dat uses tha hood key correspondin ta tha private key used ta generate tha signature\&.
.TP 0.2i    
\(bu
It cannot be forged, assumin tha private key is kept secret\&.
.TP 0.2i    
\(bu
It be a gangbangin' function of tha data signed n' thus cannot be fronted ta be tha signature fo' other data as well\&.
.TP 0.2i    
\(bu
Da signed data cannot be chizzled\&. If tha data is chizzled, then tha signature cannot be verified as authentic\&.
.PP
To generate a entity\&z signature fo' a gangbangin' file, tha entitizzle must first gotz a public/private key pair associated wit it n' one or mo' certificates dat authenticate its hood key\& fo' realz. A certificate be a gangbangin' finger-lickin' digitally signed statement from one entitizzle dat say dat tha hood key of another entitizzle has a particular value\&.
.PP
Da \f3jarsigner\fR command uses key n' certificate shiznit from a keystore ta generate digital signatures fo' JAR files\& fo' realz. A keystore be a thugged-out database of private keys n' they associated X\&.509 certificate chains dat authenticate tha correspondin hood keys\&. Da \f3keytool\fR command is used ta create n' administa keystores\&.
.PP
Da \f3jarsigner\fR command uses a entity\&z private key ta generate a signature\&. Da signed JAR file gotz nuff, among other thangs, a cold-ass lil copy of tha certificate from tha keystore fo' tha hood key correspondin ta tha private key used ta sign tha file\&. Da \f3jarsigner\fR command can verify tha digital signature of tha signed JAR file rockin tha certificate inside it (in its signature block file)\&.
.PP
Da \f3jarsigner\fR command can generate signatures dat include a time stamp dat lets a systems or deployer (includin Java Plug-in) ta check whether tha JAR file was signed while tha signin certificate was still valid\&. In addition, APIs allow applications ta obtain tha timestamp shiznit\&.
.PP
At dis time, tha \f3jarsigner\fR command can only sign JAR filez pimped by tha \f3jar\fR command or zip files\&. JAR filez is tha same as zip files, except they also gotz a \f3META-INF/MANIFEST\&.MF\fR file\& fo' realz. A \f3META-INF/MANIFEST\&.MF\fR file is pimped when tha \f3jarsigner\fR command signs a zip file\&.
.PP
Da default \f3jarsigner\fR command behavior is ta sign a JAR or zip file\&. Use tha \f3-verify\fR option ta verify a signed JAR file\&.
.PP
Da \f3jarsigner\fR command also attempts ta validate tha signer\&z certificate afta signin or verifying\&. If there be a validation error or any other problem, tha command generates warnin lyrics\&. If you specify tha \f3-strict\fR option, then tha command treats severe warnings as errors\&. Right back up in yo muthafuckin ass. See Errors n' Warnings\&.
.SS KEYSTORE\ ALIASES    
All keystore entitizzles is accessed wit unique aliases\&.
.PP
When you use tha \f3jarsigner\fR command ta sign a JAR file, you must specify tha alias fo' tha keystore entry dat gotz nuff tha private key needed ta generate tha signature\&. For example, tha followin command signs tha JAR file named \f3MyJARFile\&.jar\fR wit tha private key associated wit tha alias \f3duke\fR up in tha keystore named \f3mystore\fR up in tha \f3working\fR directory\&. Because no output file is specified, it overwrites \f3MyJARFile\&.jar\fR wit tha signed JAR file\&.
.sp     
.nf     
\f3jarsigner \-keystore /working/mystore \-storepass <keystore password>\fP
.fi     
.nf     
\f3      \-keypass <private key password> MyJARFile\&.jar duke\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
Keystores is protected wit a password, so tha store password must be specified\&. Yo ass is prompted fo' it when you do not specify it on tha command line\&. Right back up in yo muthafuckin ass. Similarly, private keys is protected up in a keystore wit a password, so tha private key\&z password must be specified, n' yo ass is prompted fo' tha password when you do not specify it on tha command line n' it aint tha same as tha store password\&.
.SS KEYSTORE\ LOCATION    
Da \f3jarsigner\fR command has a \f3-keystore\fR option fo' specifyin tha URL of tha keystore ta be used\&. Da keystore is by default stored up in a gangbangin' file named \f3\&.keystore\fR up in tha user\&z home directory, as determined by tha \f3user\&.home\fR system property\&.
.PP
On Oracle Solaris systems, \f3user\&.home\fR defaults ta tha user\&z home directory\&.
.PP
Da input stream from tha \f3-keystore\fR option is passed ta tha \f3KeyStore\&.load\fR method\&. If \f3NONE\fR is specified as tha URL, then a null stream is passed ta tha \f3KeyStore\&.load\fR method\&. \f3NONE\fR should be specified when tha \f3KeyStore\fR class aint file based, fo' example, when it resides on a hardware token device\&.
.SS KEYSTORE\ IMPLEMENTATION    
Da \f3KeyStore\fR class provided up in tha \f3java\&.security\fR package supplies a fuckin shitload of well-defined intercourses ta access n' modify tha shiznit up in a keystore\&. Yo ass can have multiple different concrete implementations, where each implementation is fo' a particular type of keystore\&.
.PP
Currently, there be two command-line tools dat use keystore implementations (\f3keytool\fR n' \f3jarsigner\fR), n' a GUI-based tool named Policy Tool\&. Because tha \f3KeyStore\fR class is publicly available, JDK playas can write additionizzle securitizzle applications dat use it\&.
.PP
There be a funky-ass built-in default implementation provided by Oracle dat implements tha keystore as a gangbangin' file, dat uses a proprietary keystore type (format) named JKS\&. Da built-in implementation protects each private key wit its individual password n' protects tha integritizzle of tha entire keystore wit a (possibly different) password\&.
.PP
Keystore implementations is provider-based, which means tha application intercourses supplied by tha \f3KeyStore\fR class is implemented up in termz of a Service Provider Interface (SPI)\&. There be a cold-ass lil correspondin abstract \f3KeystoreSpi\fR class, also up in tha \f3java\&.securitizzle package\fR, dat defines tha Service Provider Interface methodz dat providaz must implement\&. Da term provider refers ta a package or a set of packages dat supply a cold-ass lil concrete implementation of a subset of skillz dat can be accessed by tha Java Securitizzle API\&. To provide a keystore implementation, clients must implement a provider n' supply a \f3KeystoreSpi\fR subclass implementation, as busted lyrics bout up in How tha fuck ta Implement a Provider up in tha Java Cryptography Architecture at http://docs\&.oracle\&.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider\&.html
.PP
Applications can chizzle different typez of keystore implementations from different providers, wit tha \f3getInstance\fR factory method up in tha \f3KeyStore\fR class\& fo' realz. A keystore type defines tha storage n' data format of tha keystore shiznit n' tha algorithms used ta protect private keys up in tha keystore n' tha integritizzle of tha keystore itself\&. Keystore implementationz of different types is not compatible\&.
.PP
Da \f3jarsigner\fR n' \f3policytool\fR commandz can read file-based keystores from any location dat can be specified rockin a URL\&. In addition, these commandz can read non-file-based keystores like fuckin dem provided by MSCAPI on Windows n' PKCS11 on all platforms\&.
.PP
For tha \f3jarsigner\fR n' \f3keytool\fR commands, you can specify a keystore type all up in tha command line wit tha \f3-storetype\fR option\&. For Policy Tool, you can specify a keystore type wit tha \fIEdit\fR command up in tha \fIKeyStore\fR menu\&.
.PP
If you do not explicitly specify a keystore type, then tha tools chizzle a keystore implementation based on tha value of tha \f3keystore\&.type\fR property specified up in tha securitizzle propertizzles file\&. Da securitizzle propertizzles file is called \f3java\&.security\fR, n' it resides up in tha JDK securitizzle propertizzles directory, \f3java\&.home/lib/security\fR, where \f3java\&.home\fR is tha runtime environment\&z directory\&. Da \f3jre\fR directory up in tha JDK or tha top-level directory of tha Java Runtime Environment (JRE)\&.
.PP
Each tool gets tha \f3keystore\&.type\fR value n' then examines all tha installed providaz until it findz one dat implements keystorez of dat type\&. Well shiiiit, it then uses tha keystore implementation from dat provider\&.
.PP
Da \f3KeyStore\fR class defines a static method named \f3getDefaultType\fR dat lets applications n' applets retrieve tha value of tha \f3keystore\&.type\fR property\&. Da followin line of code creates a instizzle of tha default keystore type as specified up in tha \f3keystore\&.type property\fR:
.sp     
.nf     
\f3KeyStore keyStore = KeyStore\&.getInstance(KeyStore\&.getDefaultType());\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
Da default keystore type is \f3jks\fR (the proprietary type of tha keystore implementation provided by Oracle)\&. This is specified by tha followin line up in tha securitizzle propertizzles file:
.sp     
.nf     
\f3keystore\&.type=jks\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
Case do not matta up in keystore type designations\&. For example, \f3JKS\fR is tha same ol' dirty as \f3jks\fR\&.
.PP
To have tha tools bust a keystore implementation other than tha default, chizzle dat line ta specify a gangbangin' finger-lickin' different keystore type\&. For example, if you gotz a provider package dat supplies a keystore implementation fo' a keystore type called \f3pkcs12\fR, then chizzle tha line ta tha following:
.sp     
.nf     
\f3keystore\&.type=pkcs12\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
\fINote:\fR If you use tha PKCS 11 provider package, then peep "KeyTool" n' "JarSigner" up in Java PKCS #11 Reference Guide at http://docs\&.oracle\&.com/javase/7/docs/technotes/guides/security/p11guide\&.html
.SS SUPPORTED\ ALGORITHMS    
By default, tha \f3jarsigner\fR command signs a JAR file rockin one of tha followin algorithms:
.TP 0.2i    
\(bu
Digital Signature Algorithm (DSA) wit tha SHA1 digest algorithm
.TP 0.2i    
\(bu
RSA algorithm wit tha SHA256 digest algorithm
.TP 0.2i    
\(bu
Elliptic Curve (EC) cryptography algorithm wit tha SHA256 wit Elliptic Curve Digital Signature Algorithm (ECDSA)\&.
.PP
If tha signer\&z hood n' private keys is DSA keys, then \f3jarsigner\fR signs tha JAR file wit tha \f3SHA1withDSA\fR algorithm\&. If tha signer\&z keys is RSA keys, then \f3jarsigner\fR attempts ta sign tha JAR file wit tha \f3SHA256withRSA\fR algorithm\&. If tha signer\&z keys is EC keys, then \f3jarsigner\fR signs tha JAR file wit tha \f3SHA256withECDSA\fR algorithm\&.
.PP
These default signature algorithms can be overridden rockin tha \f3-sigalg\fR option\&.
.SS THE\ SIGNED\ JAR\ FILE    
When tha \f3jarsigner\fR command is used ta sign a JAR file, tha output signed JAR file is exactly tha same as tha input JAR file, except dat it has two additionizzle filez placed up in tha META-INF directory:
.TP 0.2i    
\(bu
A signature file wit a \f3\&.SF\fR extension
.TP 0.2i    
\(bu
A signature block file wit a \f3\&.DSA\fR, \f3\&.RSA\fR, or \f3\&.EC\fR extension
.PP
Da base file names fo' these two filez come from tha value of tha \f3-sigFile\fR option\&. For example, when tha option is \f3-sigFile MKSIGN\fR, tha filez is named \f3MKSIGN\&.SF\fR n' \f3MKSIGN\&.DSA\fR
.PP
If no \f3-sigfile\fR option appears on tha command line, then tha base file name fo' tha \f3\&.SF\fR n' \f3\&.DSA\fR filez is tha straight-up original gangsta 8 charactaz of tha alias name specified on tha command line, all converted ta uppercase\&. If tha alias name has fewer than 8 characters, then tha full alias name is used\&. If tha alias name gotz nuff any charactas dat is not allowed up in a signature file name, then each such characta is converted ta a underscore (_) characta up in formin tha file name\&. Valid charactas include letters, digits, underscores, n' hyphens\&.
.PP
Signature File

A signature file (\f3\&.SF\fR file) looks similar ta tha manifest file dat be always included up in a JAR file when tha \f3jarsigner\fR command is used ta sign tha file\&. For each source file included up in tha JAR file, tha \f3\&.SF\fR file has three lines, like fuckin up in tha manifest file, dat list tha following:
.TP 0.2i    
\(bu
File name
.TP 0.2i    
\(bu
Name of tha digest algorithm (SHA)
.TP 0.2i    
\(bu
SHA digest value
.PP
In tha manifest file, tha SHA digest value fo' each source file is tha digest (hash) of tha binary data up in tha source file\&. In tha \f3\&.SF\fR file, tha digest value fo' a specified source file is tha hash of tha three lines up in tha manifest file fo' tha source file\&.
.PP
Da signature file, by default, includes a header wit a hash of tha whole manifest file\&. Da header also gotz nuff a hash of tha manifest header\&. Da presence of tha header enablez verification optimization\&. Right back up in yo muthafuckin ass. See JAR File Verification\&.
.PP
Signature Block File

Da \f3\&.SF\fR file is signed n' tha signature is placed up in tha signature block file\&. This file also gotz nuff, encoded inside it, tha certificate or certificate chain from tha keystore dat authenticates tha hood key correspondin ta tha private key used fo' signing\&. Da file has tha extension \f3\&.DSA\fR, \f3\&.RSA\fR, or \f3\&.EC\fR, dependin on tha digest algorithm used\&.
.SS SIGNATURE\ TIME\ STAMP    
Da \f3jarsigner\fR command can generate n' store a signature time stamp when signin a JAR file\&. In addition, \f3jarsigner\fR supports alternatizzle signin mechanisms\&. This behavior is optionizzle n' is controlled by tha user all up in tha time of signin all up in these options\&. Right back up in yo muthafuckin ass. See Options\&.
.sp     
.nf     
\f3\-tsa \fIurl\fR\fP
.fi     
.nf     
\f3\-tsacert \fIalias\fR\fP
.fi     
.nf     
\f3\-altsigner \fIclass\fR\fP
.fi     
.nf     
\f3\-altsignerpath \fIclasspathlist\fR\fP
.fi     
.nf     
\f3\-tsapolicyid \fIpolicyid\fR\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
.SS JAR\ FILE\ VERIFICATION    
A successful JAR file verification occurs when tha signatures is valid, n' none of tha filez dat was up in tha JAR file when tha signatures was generated have chizzled since then\&. JAR file verification involves tha followin steps:
.TP 0.4i    
1\&.
Verify tha signature of tha \f3\&.SF\fR file\&.

Da verification ensures dat tha signature stored up in each signature block (\f3\&.DSA\fR) file was generated rockin tha private key correspondin ta tha hood key whose certificate (or certificate chain) also appears up in tha \f3\&.DSA\fR file\&. Well shiiiit, it also ensures dat tha signature be a valid signature of tha correspondin signature (\f3\&.SF\fR) file, n' thus tha \f3\&.SF\fR file was not tampered with\&.
.TP 0.4i    
2\&.
Verify tha digest listed up in each entry up in tha \f3\&.SF\fR file wit each correspondin section up in tha manifest\&.

Da \f3\&.SF\fR file by default includes a header dat gotz nuff a hash of tha entire manifest file\&. When tha header is present, tha verification can check ta peep whether or not tha hash up in tha header matches tha hash of tha manifest file\&. If there be a match, then verification proceedz ta tha next step\&.

If there is no match, then a less optimized verification is required ta ensure dat tha hash up in each source file shiznit section up in tha \f3\&.SF\fR file equals tha hash of its correspondin section up in tha manifest file\&. Right back up in yo muthafuckin ass. See Signature File\&.

One reason tha hash of tha manifest file dat is stored up in tha \f3\&.SF\fR file header might not equal tha hash of tha current manifest file is dat one or mo' filez was added ta tha JAR file (with tha \f3jar\fR tool) afta tha signature n' \f3\&.SF\fR file was generated\&. When tha \f3jar\fR tool is used ta add files, tha manifest file is chizzled by addin sections ta it fo' tha freshly smoked up filez yo, but tha \f3\&.SF\fR file aint chizzled\& fo' realz. A verification is still considered successful when none of tha filez dat was up in tha JAR file when tha signature was generated done been chizzled since then\&. This happens when tha hashes up in tha non-header sectionz of tha \f3\&.SF\fR file equal tha hashez of tha correspondin sections up in tha manifest file\&.
.TP 0.4i    
3\&.
Read each file up in tha JAR file dat has a entry up in tha \f3\&.SF\fR file\&. While reading, compute tha file\&z digest n' compare tha result wit tha digest fo' dis file up in tha manifest section\&. Da digests should be tha same or verification fails\&.

If any straight-up verification failures occur durin tha verification process, then tha process is stopped n' a securitizzle exception is thrown\&. Da \f3jarsigner\fR command catches n' displays tha exception\&.
.PP
\fINote:\fR Yo ass should read any addizzle warnings (or errors if you specified tha \f3-strict\fR option), as well as tha content of tha certificate (by specifyin tha \f3-verbose\fR n' \f3-certs\fR options) ta determine if tha signature can be trusted\&.
.SS MULTIPLE\ SIGNATURES\ FOR\ A\ JAR\ FILE    
A JAR file can be signed by multiple playas by hustlin tha \f3jarsigner\fR command on tha file multiple times n' specifyin tha alias fo' a gangbangin' finger-lickin' different thug each time, as bigs up:
.sp     
.nf     
\f3jarsigner myBundle\&.jar susan\fP
.fi     
.nf     
\f3jarsigner myBundle\&.jar kevin\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
When a JAR file is signed multiple times, there be multiple \f3\&.SF\fR n' \f3\&.DSA\fR filez up in tha resultin JAR file, one pair fo' each signature\&. In tha previous example, tha output JAR file includes filez wit tha followin names:
.sp     
.nf     
\f3SUSAN\&.SF\fP
.fi     
.nf     
\f3SUSAN\&.DSA\fP
.fi     
.nf     
\f3KEVIN\&.SF\fP
.fi     
.nf     
\f3KEVIN\&.DSA\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
\fINote:\fR It be also possible fo' a JAR file ta have mixed signatures, some generated by tha JDK 1\&.1 by tha \f3javakey\fR command n' others by \f3jarsigner\fR\&. Da \f3jarsigner\fR command can be used ta sign JAR filez dat is already signed wit tha \f3javakey\fR command\&.
.SH OPTIONS    
Da followin sections describe tha various \f3jarsigner\fR options\&. Be aware of tha followin standards:
.TP 0.2i    
\(bu
All option names is preceded by a minus sign (-)\&.
.TP 0.2i    
\(bu
Da options can be provided up in any order\&.
.TP 0.2i    
\(bu
Items dat is up in italics or underlined (option joints) represent tha actual joints dat must be supplied\&.
.TP 0.2i    
\(bu
Da \f3-storepass\fR, \f3-keypass\fR, \f3-sigfile\fR, \f3-sigalg\fR, \f3-digestalg\fR, \f3-signedjar\fR, n' TSA-related options is only relevant when signin a JAR file; they is not relevant when verifyin a signed JAR file\&. Da \f3-keystore\fR option is relevant fo' signin n' verifyin a JAR file\&. In addition, aliases is specified when signin n' verifyin a JAR file\&.
.TP
-keystore \fIurl\fR
.br
Specifies tha URL dat  drops some lyrics ta tha keystore location\&. This defaults ta tha file \f3\&.keystore\fR up in tha user\&z home directory, as determined by tha \f3user\&.home\fR system property\&.

A keystore is required when signing\&. Yo ass must explicitly specify a keystore when tha default keystore do not exist or if you wanna use one other than tha default\&.

A keystore aint required when verifyin yo, but if one is specified or tha default exists n' tha \f3-verbose\fR option was also specified, then additionizzle shiznit is output regardin whether or not any of tha certificates used ta verify tha JAR file is contained up in dat keystore\&.

Da \f3-keystore\fR argument can be a gangbangin' file name n' path justification rather than a URL, up in which case it is treated tha same as a gangbangin' file: URL, fo' example, tha followin is equivalent:
.sp     
.nf     
\f3\-keystore \fIfilePathAndName\fR\fP
.fi     
.nf     
\f3\-keystore file:\fIfilePathAndName\fR\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     


If tha Sun PKCS #11 provider was configured up in tha \f3java\&.security\fR securitizzle propertizzles file (located up in tha JRE\&z \f3$JAVA_HOME/lib/securitizzle directory\fR), then tha \f3keytool\fR n' \f3jarsigner\fR tools can operate on tha PKCS #11 token by specifyin these options:
.sp     
.nf     
\f3\-keystore NONE\fP
.fi     
.nf     
\f3\-storetype PKCS11\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     


For example, tha followin command lists tha contentz of tha configured PKCS#11 token:
.sp     
.nf     
\f3keytool \-keystore NONE \-storetype PKCS11 \-list\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     

.TP
-storetype \fIstoretype\fR
.br
Specifies tha type of keystore ta be instantiated\&. Da default keystore type is tha one dat is specified as tha value of tha \f3keystore\&.type\fR property up in tha securitizzle propertizzles file, which is returned by tha static \f3getDefaultType\fR method up in \f3java\&.security\&.KeyStore\fR\&.

Da PIN fo' a PCKS #11 token can also be specified wit tha \f3-storepass\fR option\&. If none is specified, then tha \f3keytool\fR n' \f3jarsigner\fR commandz prompt fo' tha token PIN\&. If tha token has a protected authentication path (like fuckin a thugged-out dedicated PIN-pad or a funky-ass biometric reader), then tha \f3-protected\fR option must be specified n' no password options can be specified\&.
.TP
-storepass[:env | :file] \fIargument\fR
.br
Specifies tha password dat is required ta access tha keystore\&. This is only needed when signin (not verifying) a JAR file\&. In dat case, if a \f3-storepass\fR option aint provided all up in tha command line, then tha user is prompted fo' tha password\&.

If tha modifier \f3env\fR or \f3file\fR aint specified, then tha password has tha value \fIargument\fR\&. Otherwise, tha password is retrieved as bigs up:
.RS     
.TP 0.2i    
\(bu
\f3env\fR: Retrieve tha password from tha environment variable named \f3argument\fR\&.
.TP 0.2i    
\(bu
\f3file\fR: Retrieve tha password from tha file named \f3argument\fR\&.
.RE     


\fINote:\fR Da password should not be specified on tha command line or up in a script unless it is fo' testin purposes, or yo ass is on a secure system\&.
.TP
-keypass [:env | :file] \fIargument\fR
.br
Specifies tha password used ta protect tha private key of tha keystore entry addressed by tha alias specified on tha command line\&. Da password is required when rockin \f3jarsigner\fR ta sign a JAR file\&. If no password is provided on tha command line, n' tha required password is different from tha store password, then tha user is prompted fo' it\&.

If tha modifier \f3env\fR or \f3file\fR aint specified, then tha password has tha value \f3argument\fR\&. Otherwise, tha password is retrieved as bigs up:
.RS     
.TP 0.2i    
\(bu
\f3env\fR: Retrieve tha password from tha environment variable named \f3argument\fR\&.
.TP 0.2i    
\(bu
\f3file\fR: Retrieve tha password from tha file named \f3argument\fR\&.
.RE     


\fINote:\fR Da password should not be specified on tha command line or up in a script unless it is fo' testin purposes, or yo ass is on a secure system\&.
.TP
-sigfile \fIfile\fR
.br
Specifies tha base file name ta be used fo' tha generated \f3\&.SF\fR n' \f3\&.DSA\fR files\&. For example, if file is \f3DUKESIGN\fR, then tha generated \f3\&.SF\fR n' \f3\&.DSA\fR filez is named \f3DUKESIGN\&.SF\fR n' \f3DUKESIGN\&.DSA\fR, n' placed up in tha \f3META-INF\fR directory of tha signed JAR file\&.

Da charactas up in tha file must come from tha set \f3a-zA-Z0-9_-\fR\&. Only letters, numbers, underscore, n' hyphen charactas is allowed\& fo' realz. All lowercase charactas is converted ta uppercase fo' tha \f3\&.SF\fR n' \f3\&.DSA\fR file names\&.

If no \f3-sigfile\fR option appears on tha command line, then tha base file name fo' tha \f3\&.SF\fR n' \f3\&.DSA\fR filez is tha straight-up original gangsta 8 charactaz of tha alias name specified on tha command line, all converted ta upper case\&. If tha alias name has fewer than 8 characters, then tha full alias name is used\&. If tha alias name gotz nuff any charactas dat is not valid up in a signature file name, then each such characta is converted ta a underscore (_) characta ta form tha file name\&.
.TP
-sigalg \fIalgorithm\fR
.br
Specifies tha name of tha signature algorithm ta use ta sign tha JAR file\&.

For a list of standard signature algorithm names, peep "Appendix A: Standard Names" up in tha Java Cryptography Architecture (JCA) Reference Guide at http://docs\&.oracle\&.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec\&.html#AppA

This algorithm must be compatible wit tha private key used ta sign tha JAR file\&. If dis option aint specified, then \f3SHA1withDSA\fR, \f3SHA256withRSA\fR, or \f3SHA256withECDSA\fR is used dependin on tha type of private key\&. There must either be a statically installed provider supplyin a implementation of tha specified algorithm or tha user must specify one wit tha \f3-providerClass\fR option; otherwise, tha command aint gonna succeed\&.
.TP
-digestalg \fIalgorithm\fR
.br
Specifies tha name of tha message digest algorithm ta use when digestin tha entriez of a JAR file\&.

For a list of standard message digest algorithm names, peep "Appendix A: Standard Names" up in tha Java Cryptography Architecture (JCA) Reference Guide at http://docs\&.oracle\&.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec\&.html#AppA

If dis option aint specified, then \f3SHA256\fR is used\&. There must either be a statically installed provider supplyin a implementation of tha specified algorithm or tha user must specify one wit tha \f3-providerClass\fR option; otherwise, tha command aint gonna succeed\&.
.TP
-certs
.br
If tha \f3-certs\fR option appears on tha command line wit tha \f3-verify\fR n' \f3-verbose\fR options, then tha output includes certificate shiznit fo' each signer of tha JAR file\&. This shiznit includes tha name of tha type of certificate (stored up in tha \f3\&.DSA\fR file) dat certifies tha signer\&z hood key, n' if tha certificate be a X\&.509 certificate (an instizzle of tha \f3java\&.security\&.cert\&.X509Certificate\fR), then tha distinguished name of tha signer\&.

Da keystore be also examined\&. If no keystore value is specified on tha command line, then tha default keystore file (if any) is checked\&. If tha hood key certificate fo' a signer matches a entry up in tha keystore, then tha alias name fo' tha keystore entry fo' dat signer is displayed up in parentheses\&. If tha signer be reppin a JDK 1\&.1 identitizzle database instead of from a keystore, then tha alias name displays up in brackets instead of parentheses\&.
.TP
-certchain \fIfile\fR
.br
Specifies tha certificate chain ta be used when tha certificate chain associated wit tha private key of tha keystore entry dat be addressed by tha alias specified on tha command line aint complete\&. This can happen when tha keystore is located on a hardware token where there aint enough capacitizzle ta hold a cold-ass lil complete certificate chain\&. Da file can be a sequence of concatenated X\&.509 certificates, or a single PKCS#7 formatted data block, either up in binary encodin format or up in printable encodin format (also known as Base64 encoding) as defined by tha Internizzle RFC 1421 standard\&. Right back up in yo muthafuckin ass. See tha section Internizzle RFC 1421 Certificate Encodin Standard up in \f3keytool\fR n' http://tools\&.ietf\&.org/html/rfc1421\&.
.TP
-verbose
.br
When tha \f3-verbose\fR option appears on tha command line, it indicates verbose mode, which causes \f3jarsigner\fR ta output extra shiznit bout tha progress of tha JAR signin or verification\&.
.TP
-internalsf
.br
In tha past, tha \f3\&.DSA\fR (signature block) file generated when a JAR file was signed included a cold-ass lil complete encoded copy of tha \f3\&.SF\fR file (signature file) also generated\&. This behavior has been chizzled\&. To reduce tha overall size of tha output JAR file, tha \f3\&.DSA\fR file by default do not contain a cold-ass lil copy of tha \f3\&.SF\fR file no mo'\&. If \f3-internalsf\fR appears on tha command line, then tha oldschool behavior is utilized\&. This option is useful fo' testing\&. In practice, do not use tha \f3-internalsf\fR option cuz it incurs higher overhead\&.
.TP
-sectionsonly
.br
If tha \f3-sectionsonly\fR option appears on tha command line, then tha \f3\&.SF\fR file (signature file) generated when a JAR file is signed do not include a header dat gotz nuff a hash of tha whole manifest file\&. Well shiiiit, it gotz nuff only tha shiznit n' hashes related ta each individual source file included up in tha JAR file\&. Right back up in yo muthafuckin ass. See Signature File\&.

By default, dis header be added, as a optimization\&. When tha header is present, whenever tha JAR file is verified, tha verification can first check ta peep whether tha hash up in tha header matches tha hash of tha whole manifest file\&. When there be a match, verification proceedz ta tha next step\&. When there is no match, it is necessary ta do a less optimized verification dat tha hash up in each source file shiznit section up in tha \f3\&.SF\fR file equals tha hash of its correspondin section up in tha manifest file\&. Right back up in yo muthafuckin ass. See JAR File Verification\&.

Da \f3-sectionsonly\fR option is primarily used fo' testing\&. Well shiiiit, it should not be used other than fo' testin cuz rockin it incurs higher overhead\&.
.TP
-protected
.br
Values can be either \f3true\fR or \f3false\fR\&. Right back up in yo muthafuckin ass. Specify \f3true\fR when a password must be specified all up in a protected authentication path like fuckin a thugged-out dedicated PIN reader\&.
.TP
-providerClass \fIprovider-class-name\fR
.br
Used ta specify tha name of cryptographic steez provider\&z masta class file when tha steez provider aint listed up in tha \f3java\&.security\fR securitizzle propertizzles file\&.

Used wit tha \f3-providerArg ConfigFilePath\fR option, tha \f3keytool\fR n' \f3jarsigner\fR tools install tha provider dynamically n' use \fIConfigFilePath\fR fo' tha path ta tha token configuration file\&. Da followin example shows a cold-ass lil command ta list a \f3PKCS #11\fR keystore when tha Oracle PKCS #11 provider was not configured up in tha securitizzle propertizzles file\&.
.sp     
.nf     
\f3jarsigner \-keystore NONE \-storetype PKCS11 \e\fP
.fi     
.nf     
\f3          \-providerClass sun\&.security\&.pkcs11\&.SunPKCS11 \e\fP
.fi     
.nf     
\f3          \-providerArg /mydir1/mydir2/token\&.config \e\fP
.fi     
.nf     
\f3          \-list\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     

.TP
-providerName \fIproviderName\fR
.br
If mo' than one provider was configured up in tha \f3java\&.security\fR securitizzle propertizzles file, then you can use tha \f3-providerName\fR option ta target a specific provider instance\&. Da argument ta dis option is tha name of tha provider\&.

For tha Oracle PKCS #11 provider, \fIproviderName\fR iz of tha form \f3SunPKCS11-\fR\fITokenName\fR, where \fITokenName\fR is tha name suffix dat tha provider instizzle has been configured with, as detailed up in tha configuration attributes table\&. For example, tha followin command lists tha contentz of tha \f3PKCS #11\fR keystore provider instizzle wit name suffix \f3SmartCard\fR:
.sp     
.nf     
\f3jarsigner \-keystore NONE \-storetype PKCS11 \e\fP
.fi     
.nf     
\f3        \-providerName SunPKCS11\-SmartCard \e\fP
.fi     
.nf     
\f3        \-list\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     

.TP
-J\fIjavaoption\fR
.br
Passes all up in tha specified \fIjavaoption\fR strang directly ta tha Java interpreter\&. Da \f3jarsigner\fR command be a wrapper round tha interpreter\&. This option should not contain any spaces\&. Well shiiiit, it is useful fo' adjustin tha execution environment or memory usage\&. For a list of possible interpreta options, type \f3java -h\fR or \f3java -X\fR all up in tha command line\&.
.TP
-tsa \fIurl\fR
.br
If \f3-tsa http://example\&.tsa\&.url\fR appears on tha command line when signin a JAR file then a time stamp is generated fo' tha signature\&. Da URL, \f3http://example\&.tsa\&.url\fR, identifies tha location of tha Time Stampin Authoritizzle (TSA) n' overrides any URL found wit tha \f3-tsacert\fR option\&. Da \f3-tsa\fR option do not require tha TSA hood key certificate ta be present up in tha keystore\&.

To generate tha time stamp, \f3jarsigner\fR communicates wit tha TSA wit tha Time-Stamp Protocol (TSP) defined up in RFC 3161\&. When successful, tha time stamp token returned by tha TSA is stored wit tha signature up in tha signature block file\&.
.TP
-tsacert \fIalias\fR
.br
When \f3-tsacert alias\fR appears on tha command line when signin a JAR file, a time stamp is generated fo' tha signature\&. Da alias identifies tha TSA hood key certificate up in tha keystore dat is up in effect\&. Da entry\&z certificate is examined fo' a Subject Hype Access extension dat gotz nuff a URL identifyin tha location of tha TSA\&.

Da TSA hood key certificate must be present up in tha keystore when rockin tha \f3-tsacert\fR option\&.
.TP
-tsapolicyid \fIpolicyid\fR
.br
Specifies tha object identifier (OID) dat identifies tha policy ID ta be busted ta tha TSA server\&. If dis option aint specified, no policy ID is busted n' tha TSA server will chizzle a thugged-out default policy ID\&.

Object identifiers is defined by X\&.696, which be a ITU Telecommunication Standardization Sector (ITU-T) standard\&. These identifiers is typically period-separated setz of non-negatizzle digits like \f31\&.2\&.3\&.4\fR, fo' example\&.
.TP
-altsigner \fIclass\fR
.br
This option specifies a alternatizzle signin mechanism\&. Da straight-up qualified class name identifies a cold-ass lil class file dat extendz tha \f3com\&.sun\&.jarsigner\&.ContentSigner\fR abstract class\&. Da path ta dis class file is defined by tha \f3-altsignerpath\fR option\&. If tha \f3-altsigner\fR option is used, then tha \f3jarsigner\fR command uses tha signin mechanizzle provided by tha specified class\&. Otherwise, tha \f3jarsigner\fR command uses its default signin mechanism\&.

For example, ta use tha signin mechanizzle provided by a cold-ass lil class named \f3com\&.sun\&.sun\&.jarsigner\&.AuthSigner\fR, use tha jarsigner option \f3-altsigner com\&.sun\&.jarsigner\&.AuthSigner\fR\&.
.TP
-altsignerpath \fIclasspathlist\fR
.br
Specifies tha path ta tha class file n' any JAR file it dependz on\&. Da class file name is specified wit tha \f3-altsigner\fR option\&. If tha class file is up in a JAR file, then dis option specifies tha path ta dat JAR file\&.

An absolute path or a path relatizzle ta tha current directory can be specified\&. If \fIclasspathlist\fR gotz nuff multiple paths or JAR files, then they should be separated wit a cold-ass lil colon (:) on Oracle Solaris n' a semicolon (;) on Windows\&. This option aint necessary when tha class be already up in tha search path\&.

Da followin example shows how tha fuck ta specify tha path ta a JAR file dat gotz nuff tha class file\&. Da JAR file name is included\&.
.sp     
.nf     
\f3\-altsignerpath /home/user/lib/authsigner\&.jar\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     


Da followin example shows how tha fuck ta specify tha path ta tha JAR file dat gotz nuff tha class file\&. Da JAR file name is omitted\&.
.sp     
.nf     
\f3\-altsignerpath /home/user/classes/com/sun/tools/jarsigner/\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     

.TP
-strict
.br
Durin tha signin or verifyin process, tha command may issue warnin lyrics\&. If you specify dis option, tha exit code of tha tool reflects tha severe warnin lyrics dat dis command found\&. Right back up in yo muthafuckin ass. See Errors n' Warnings\&.
.TP
-verbose \fIsuboptions\fR
.br
For tha verifyin process, tha \f3-verbose\fR option takes suboptions ta determine how tha fuck much shiznit is shown\&. If tha \f3-certs\fR option be also specified, then tha default mode (or suboption \f3all\fR) displays each entry as it is bein processed, n' afta that, tha certificate shiznit fo' each signer of tha JAR file\&. If tha \f3-certs\fR n' tha \f3-verbose:grouped\fR suboptions is specified, then entries wit tha same signer info is grouped n' displayed together wit they certificate shiznit\&. If \f3-certs\fR n' tha \f3-verbose:summary\fR suboptions is specified, then entries wit tha same signer shiznit is grouped n' displayed together wit they certificate shiznit\&. Details bout each entry is summarized n' displayed as \fIone entry (and more)\fR\&. Right back up in yo muthafuckin ass. See Examples\&.
.SH ERRORS\ AND\ WARNINGS    
Durin tha signin or verifyin process, tha \f3jarsigner\fR command may issue various errors or warnings\&.
.PP
If there be a gangbangin' failure, tha \f3jarsigner\fR command exits wit code 1\&. If there is no failure yo, but there be one or mo' severe warnings, tha \f3jarsigner\fR command exits wit code 0 when tha \f3-strict\fR option is \fInot\fR specified, or exits wit tha OR-value of tha warnin codes when tha \f3-strict\fR is specified\&. If there is only shiznital warnings or no warnin at all, tha command always exits wit code 0\&.
.PP
For example, if a cold-ass lil certificate used ta sign a entry is expired n' has a KeyUsage extension dat do not allow it ta sign a gangbangin' file, tha \f3jarsigner\fR command exits wit code 12 (=4+8) when tha \f3-strict\fR option is specified\&.
.PP
\fINote:\fR Exit codes is reused cuz only tha joints from 0 ta 255 is legal on Unix-based operatin systems\&.
.PP
Da followin sections raps bout tha names, codes, n' descriptionz of tha errors n' warnings dat tha \f3jarsigner\fR command can issue\&.
.SS FAILURE    
Reasons why tha \f3jarsigner\fR command fails include (but is not limited to) a cold-ass lil command line parsin error, tha inabilitizzle ta find a keypair ta sign tha JAR file, or tha verification of a signed JAR fails\&.
.TP     
failure
Code 1\&. Da signin or verifyin fails\&.
.SS SEVERE\ WARNINGS    
\fINote:\fR Severe warnings is reported as errors if you specify tha \f3-strict\fR option\&.
.PP
Reasons why tha \f3jarsigner\fR command thangs a severe warnin include tha certificate used ta sign tha JAR file has a error or tha signed JAR file has other problems\&.
.TP     
hasExpiredCert
Code 4\&. This jar gotz nuff entries whose signer certificate has expired\&.
.TP     
notYetValidCert
Code 4\&. This jar gotz nuff entries whose signer certificate aint yet valid\&.
.TP     
chainNotValidated
Code 4\&. This jar gotz nuff entries whose certificate chain cannot be erectly validated\&.
.TP     
badKeyUsage
Code 8\&. This jar gotz nuff entries whose signer certificate\&z KeyUsage extension don\&'t allow code signing\&.
.TP     
badExtendedKeyUsage
Code 8\&. This jar gotz nuff entries whose signer certificate\&z ExtendedKeyUsage extension don\&'t allow code signing\&.
.TP     
badNetscapeCertType
Code 8\&. This jar gotz nuff entries whose signer certificate\&z NetscapeCertType extension don\&'t allow code signing\&.
.TP     
hasUnsignedEntry
Code 16\&. This jar gotz nuff unsigned entries which aint been integrity-checked\&.
.TP     
notSignedByAlias
Code 32\&. This jar gotz nuff signed entries which is not signed by tha specified alias(es)\&.
.TP     
aliasNotInStore
Code 32\&. This jar gotz nuff signed entries dat is not signed by alias up in dis keystore\&.
.SS INFORMATIONAL\ WARNINGS    
Informationizzle warnings include dem dat is not errors but regarded as wack practice\&. They aint gots a cold-ass lil code\&.
.TP     
hasExpiringCert
This jar gotz nuff entries whose signer certificate will expire within six months\&.
.TP     
noTimestamp
This jar gotz nuff signatures dat do not include a timestamp\&. Without a timestamp, playas may not be able ta validate dis JAR file afta tha signer certificate\&z expiration date (\f3YYYY-MM-DD\fR) or afta any future revocation date\&.
.SH EXAMPLES    
.SS SIGN\ A\ JAR\ FILE    
Use tha followin command ta sign bundle\&.jar wit tha private key of a user whose keystore alias is \f3jane\fR up in a keystore named \f3mystore\fR up in tha \f3working\fR directory n' name tha signed JAR file \f3sbundle\&.jar\fR:
.sp     
.nf     
\f3jarsigner \-keystore /working/mystore\fP
.fi     
.nf     
\f3    \-storepass <keystore password>\fP
.fi     
.nf     
\f3    \-keypass <private key password>\fP
.fi     
.nf     
\f3    \-signedjar sbundle\&.jar bundle\&.jar jane\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
There is no \f3-sigfile\fR specified up in tha previous command so tha generated \f3\&.SF\fR n' \f3\&.DSA\fR filez ta be placed up in tha signed JAR file have default names based on tha alias name\&. They is named \f3JANE\&.SF\fR n' \f3JANE\&.DSA\fR\&.
.PP
If you wanna be prompted fo' tha store password n' tha private key password, then you could shorten tha previous command ta tha following:
.sp     
.nf     
\f3jarsigner \-keystore /working/mystore\fP
.fi     
.nf     
\f3    \-signedjar sbundle\&.jar bundle\&.jar jane\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
If tha keystore is tha default keystore (\&.keystore up in yo' home directory), then you do not need ta specify a keystore, as bigs up:
.sp     
.nf     
\f3jarsigner \-signedjar sbundle\&.jar bundle\&.jar jane\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
If you want tha signed JAR file ta overwrite tha input JAR file (bundle\&.jar), then you do not need ta specify a \f3-signedjar\fR option, as bigs up:
.sp     
.nf     
\f3jarsigner bundle\&.jar jane\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
.SS VERIFY\ A\ SIGNED\ JAR\ FILE    
To verify a signed JAR file ta ensure dat tha signature is valid n' tha JAR file was not been tampered with, bust a cold-ass lil command like fuckin tha following:
.sp     
.nf     
\f3jarsigner \-verify sbundle\&.jar\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
When tha verification is successful, \f3jar verified\fR is displayed\&. Otherwise, a error message is displayed\&. Yo ass can git mo' shiznit when you use tha \f3-verbose\fR option\& fo' realz. A sample use of \f3jarsigner\fR wit the\f3-verbose\fR option bigs up:
.sp     
.nf     
\f3jarsigner \-verify \-verbose sbundle\&.jar\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3           198 Fri Sep 26 16:14:06 PDT 1997 META\-INF/MANIFEST\&.MF\fP
.fi     
.nf     
\f3           199 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.SF\fP
.fi     
.nf     
\f3          1013 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.DSA\fP
.fi     
.nf     
\f3    smk   2752 Fri Sep 26 16:12:30 PDT 1997 AclEx\&.class\fP
.fi     
.nf     
\f3    smk    849 Fri Sep 26 16:12:46 PDT 1997 test\&.class\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3      s = signature was verified\fP
.fi     
.nf     
\f3      m = entry is listed up in manifest\fP
.fi     
.nf     
\f3      k = at least one certificate was found up in keystore\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3    jar verified\&.\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
.SS VERIFICATION\ WITH\ CERTIFICATE\ INFORMATION    
If you specify tha \f3-certs\fR option wit tha \f3-verify\fR n' \f3-verbose\fR options, then tha output includes certificate shiznit fo' each signer of tha JAR file\&. Da shiznit includes tha certificate type, tha signer distinguished name shiznit (when it be a X\&.509 certificate), n' up in parentheses, tha keystore alias fo' tha signer when tha hood key certificate up in tha JAR file matches tha one up in a keystore entry, fo' example:
.sp     
.nf     
\f3jarsigner \-keystore /working/mystore \-verify \-verbose \-certs myTest\&.jar\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3           198 Fri Sep 26 16:14:06 PDT 1997 META\-INF/MANIFEST\&.MF\fP
.fi     
.nf     
\f3           199 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.SF\fP
.fi     
.nf     
\f3          1013 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.DSA\fP
.fi     
.nf     
\f3           208 Fri Sep 26 16:23:30 PDT 1997 META\-INF/JAVATEST\&.SF\fP
.fi     
.nf     
\f3          1087 Fri Sep 26 16:23:30 PDT 1997 META\-INF/JAVATEST\&.DSA\fP
.fi     
.nf     
\f3    smk   2752 Fri Sep 26 16:12:30 PDT 1997 Tst\&.class\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3      X\&.509, CN=Test Group, OU=Java Software, O=Oracle, L=CUP, S=CA, C=US (javatest)\fP
.fi     
.nf     
\f3      X\&.509, CN=Jane Smizzle, OU=Java Software, O=Oracle, L=cup, S=ca, C=us (jane)\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3      s = signature was verified\fP
.fi     
.nf     
\f3      m = entry is listed up in manifest\fP
.fi     
.nf     
\f3      k = at least one certificate was found up in keystore\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3    jar verified\&.\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
If tha certificate fo' a signer aint a X\&.509 certificate, then there is no distinguished name shiznit\&. In dat case, just tha certificate type n' tha alias is shown\&. For example, if tha certificate be a PGP certificate, n' tha alias is \f3bob\fR, then you would get: \f3PGP, (bob)\fR\&.
.SS VERIFICATION\ THAT\ INCLUDES\ IDENTITY\ DATABASE\ SIGNERS    
If a JAR file was signed wit tha JDK 1\&.1 \f3javakey\fR tool, n' tha signer be a alias up in a identitizzle database, then tha verification output includes a \f3i\fR\&. If tha JAR file was signed by both a alias up in a identitizzle database n' a alias up in a keystore, then both \f3k\fR n' \f3i\fR appear\&.
.PP
When tha \f3-certs\fR option is used, any identitizzle database aliases is shown up in brackets rather than tha parentheses used fo' keystore aliases, fo' example:
.sp     
.nf     
\f3    jarsigner \-keystore /working/mystore \-verify \-verbose \-certs writeFile\&.jar\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3           198 Fri Sep 26 16:14:06 PDT 1997 META\-INF/MANIFEST\&.MF\fP
.fi     
.nf     
\f3           199 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.SF\fP
.fi     
.nf     
\f3          1013 Fri Sep 26 16:22:10 PDT 1997 META\-INF/JANE\&.DSA\fP
.fi     
.nf     
\f3           199 Fri Sep 27 12:22:30 PDT 1997 META\-INF/DUKE\&.SF\fP
.fi     
.nf     
\f3          1013 Fri Sep 27 12:22:30 PDT 1997 META\-INF/DUKE\&.DSA\fP
.fi     
.nf     
\f3   smki   2752 Fri Sep 26 16:12:30 PDT 1997 writeFile\&.html\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3      X\&.509, CN=Jane Smizzle, OU=Java Software, O=Oracle, L=cup, S=ca, C=us (jane)\fP
.fi     
.nf     
\f3      X\&.509, CN=Duke, OU=Java Software, O=Oracle, L=cup, S=ca, C=us [duke]\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3      s = signature was verified\fP
.fi     
.nf     
\f3      m = entry is listed up in manifest\fP
.fi     
.nf     
\f3      k = at least one certificate was found up in keystore\fP
.fi     
.nf     
\f3      i = at least one certificate was found up in identitizzle scope\fP
.fi     
.nf     
\f3\fR
.fi     
.nf     
\f3    jar verified\&.\fP
.fi     
.nf     
\f3\fR
.fi     
.sp     
\fINote:\fR Da alias \f3duke\fR is up in brackets ta denote dat it be a identitizzle database alias, n' not a keystore alias\&.
.SH JDK\ 1\&.1\ COMPATIBILITY    
Da \f3keytool\fR n' \f3jarsigner\fR tools replace tha \f3javakey\fR tool up in JDK 1\&.1\&. These freshly smoked up tools provide mo' features than \f3javakey\fR, includin tha mobilitizzle ta protect tha keystore n' private keys wit passwords, n' tha mobilitizzle ta verify signatures up in addizzle ta generatin them\&.
.PP
Da freshly smoked up keystore architecture replaces tha identitizzle database dat \f3javakey\fR pimped n' managed\&. There is no backward compatibilitizzle between tha keystore format n' tha database format used by \f3javakey\fR up in JDK 1\&.1\&. But fuck dat shiznit yo, tha word on tha street is dat be aware of tha following:
.TP 0.2i    
\(bu
It be possible ta import tha shiznit from a identitizzle database tha fuck into a keystore all up in tha \f3keytool -identitydb\fR command\&.
.TP 0.2i    
\(bu
Da \f3jarsigner\fR command can sign JAR filez dat was signed wit tha \f3javakey\fR command\&.
.TP 0.2i    
\(bu
Da \f3jarsigner\fR command can verify JAR filez signed wit \f3javakey\fR\&. Da \f3jarsigner\fR command recognizes n' can work wit signer aliases dat is from a JDK 1\&.1 identitizzle database rather than a JDK keystore\&.
.SS UNSIGNED\ JARS    
Unsigned JARs have tha default privileges dat is granted ta all code\&.
.SS SIGNED\ JARS    
Signed JARs have tha privilege configurations based on they JDK 1\&.1\&.\fIn\fR identitizzle n' policy file status as busted lyrics about\&. Only trusted identitizzles can be imported tha fuck into tha JDK keystore\&.
.PP
Default Privileges Granted ta All Code

Identitizzle up in 1\&.1 database: \fINo\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fINo\fR
.br     
Policy file grants privileges ta identity/alias: \fINo\fR
.PP

.PP
Identitizzle up in 1\&.1 database: \fINo\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fIYes\fR
.br     
Policy file grants privileges ta identity/alias: \fINo\fR
.PP

.PP
Identitizzle up in 1\&.1 database: Yes/Untrusted
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fINo\fR
.br     
Policy file grants privileges ta identity/alias: \fINo\fR
.br     
See 3 up in Notes Regardin Privilegez of Signed JARs\&.
.PP

.PP
Identitizzle up in 1\&.1 database: Yes/Untrusted
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fINo\fR
.br     
Policy file grants privileges ta identity/alias: \fIYes\fR
.br     
See 1 n' 3 up in Notes Regardin Privilegez of Signed JARs\&.
.PP
Default Privileges n' Policy File Privileges Granted

Identitizzle up in 1\&.1 database: \fINo\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fIYes\fR
.br     
Policy file grants privileges ta identity/alias: \fIYes\fR
.PP

.PP
Identitizzle up in 1\&.1 database: \fIYes/Trusted\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fIYes\fR
.br     
Policy file grants privileges ta identity/alias: \fIYes\fR
.br     
See 2 up in Notes Regardin Privilegez of Signed JARs\&.
.PP
All Privileges Granted

Identitizzle up in 1\&.1 database: \fIYes/Trusted\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fINo\fR
.br     
Policy file grants privileges ta identity/alias: \fINo\fR
.PP

.PP
Identitizzle up in 1\&.1 database: \fIYes/Trusted\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fIYes\fR
.br     
Policy file grants privileges ta identity/alias: \fINo\fR
.br     
See 1 up in Notes Regardin Privilegez of Signed JARs\&.
.PP
Identitizzle up in 1\&.1 database: \fIYes/Trusted\fR
.br     
Trusted identitizzle imported tha fuck into Java keystore from 1\&.1\&. database: \fINo\fR
.br     
Policy file grants privileges ta identity/alias: \fIYes\fR
.br     
See 1 up in Notes Regardin Privilegez of Signed JARs\&.
.PP
Notes Regardin Privilegez of Signed JARs
.TP 0.4i    
1\&.
If a identitizzle or alias is mentioned up in tha policy file, then it must be imported tha fuck into tha keystore fo' tha policy file ta have any effect on privileges granted\&.
.TP 0.4i    
2\&.
Da policy file/keystore combination has precedence over a trusted identitizzle up in tha identitizzle database\&.
.TP 0.4i    
3\&.
Untrusted identitizzles is ignored up in tha Java platform\&.
.SH SEE\ ALSO    
.TP 0.2i    
\(bu
\f3jar\fR
.TP 0.2i    
\(bu
\f3keytool\fR
.TP 0.2i    
\(bu
Trail: Securitizzle Features up in Java SE at http://docs\&.oracle\&.com/javase/tutorial/security/index\&.html
.RE
.br
'pl 8.5i
'bp
