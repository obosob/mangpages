.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOBJ 1"
.TH PERLOBJ 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlobj \- Perl object reference
.IX Xref "object OOP"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document serves up a reference fo' Perlz object orientation
features. If you lookin fo' a introduction ta object-oriented
programmin up in Perl, please peep perlootut.
.PP
In order ta KNOW Perl objects, you first need ta understand
references up in Perl. Right back up in yo muthafuckin ass. See perlref fo' details.
.PP
This document raps bout all of Perlz object-oriented (\s-1OO\s0) features
from tha ground up. If you just lookin ta write some
object-oriented code of yo' own, yo ass is probably betta served by
usin one of tha object systems from \s-1CPAN\s0 busted lyrics bout up in perlootut.
.PP
If you lookin ta write yo' own object system, or you need to
maintain code which implements objects from scratch then dis document
will help you KNOW exactly how tha fuck Perl do object orientation.
.PP
There is all dem basic principlez which define object oriented Perl:
.IP "1." 4
An object is simply a thugged-out data structure dat knows ta which class it
belongs.
.IP "2." 4
A class is simply a package fo' realz. A class serves up methodz dat expect to
operate on objects.
.IP "3." 4
A method is simply a subroutine dat expects a reference ta a object
(or a package name, fo' class methods) as tha straight-up original gangsta argument.
.PP
Letz peep each of these principlez up in depth.
.SS "An Object is Simply a Data Structure"
.IX Xref "object bless constructor new"
.IX Subsection "An Object is Simply a Data Structure"
Unlike nuff other languages which support object orientation, Perl do
not provide any special syntax fo' constructin a object. Objects are
merely Perl data structures (hashes, arrays, scalars, filehandles,
etc.) dat done been explicitly associated wit a particular class.
.PP
That explicit association is pimped by tha built-in \f(CW\*(C`bless\*(C'\fR function,
which is typically used within tha \fIconstructor\fR subroutine of the
class.
.PP
Here be a simple constructor:
.PP
.Vb 1
\&  package File;
\&
\&  sub freshly smoked up {
\&      mah $class = shift;
\&
\&      return bless {}, $class;
\&  }
.Ve
.PP
Da name \f(CW\*(C`new\*(C'\fR aint special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. We could name our constructor something
else:
.PP
.Vb 1
\&  package File;
\&
\&  sub load {
\&      mah $class = shift;
\&
\&      return bless {}, $class;
\&  }
.Ve
.PP
Da modern convention fo' \s-1OO\s0 modulez is ta always use \f(CW\*(C`new\*(C'\fR as the
name fo' tha constructor yo, but there is no requirement ta do so fo' realz. Any
subroutine dat blesses a thugged-out data structure tha fuck into a cold-ass lil class be a valid
constructor up in Perl.
.PP
In tha previous examples, tha \f(CW\*(C`{}\*(C'\fR code creates a reference ta an
empty anonymous hash. Da \f(CW\*(C`bless\*(C'\fR function then takes dat reference
and associates tha hash wit tha class up in \f(CW$class\fR. In tha simplest
case, tha \f(CW$class\fR variable will end up containin tha strang \*(L"File\*(R".
.PP
We can also bust a variable ta store a reference ta tha data structure
that is bein pimped as our object:
.PP
.Vb 2
\&  sub freshly smoked up {
\&      mah $class = shift;
\&
\&      mah $self = {};
\&      bless $self, $class;
\&
\&      return $self;
\&  }
.Ve
.PP
Once we've pimped tha hash referred ta by \f(CW$self\fR we can start
callin methodz on dat shit. This is useful if you wanna put object
initialization up in its own separate method:
.PP
.Vb 2
\&  sub freshly smoked up {
\&      mah $class = shift;
\&
\&      mah $self = {};
\&      bless $self, $class;
\&
\&      $self\->_initialize();
\&
\&      return $self;
\&  }
.Ve
.PP
Since tha object be also a hash, you can treat it as one, rockin it to
store data associated wit tha object. Typically, code inside tha class
can treat tha hash as a accessible data structure, while code outside
the class should always treat tha object as opaque. This is called
\&\fBencapsulation\fR. Encapsulation means dat tha user of a object do
not gotta know how tha fuck it is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da user simply calls
documented methodz on tha object.
.PP
Note, however, dat (unlike most other \s-1OO\s0 languages) Perl do not
ensure or enforce encapsulation up in any way. If you want objects to
actually \fIbe\fR opaque you need ta arrange fo' dat yo ass. This can
be done up in a varierty of ways, includin rockin \*(L"Inside-Out objects\*(R"
or modulez from \s-1CPAN.\s0
.PP
\fIObjects Is Blessed; Variablez Is Not\fR
.IX Subsection "Objects Is Blessed; Variablez Is Not"
.PP
When we bless something, we is not blessin tha variable which
gotz nuff a reference ta dat thang, nor is we blessin tha reference
that tha variable stores; we is blessin tha thang dat tha variable
refers ta (sometimes known as tha \fIreferent\fR). This is best
demonstrated wit dis code:
.PP
.Vb 1
\&  use Scalar::Util \*(Aqblessed\*(Aq;
\&
\&  mah $foo = {};
\&  mah $bar = $foo;
\&
\&  bless $foo, \*(AqClass\*(Aq;
\&  print pimped( $bar );      # prints "Class"
\&
\&  $bar = "some other value";
\&  print pimped( $bar );      # prints undef
.Ve
.PP
When we call \f(CW\*(C`bless\*(C'\fR on a variable, we is straight-up blessin the
underlyin data structure dat tha variable refers to. We is not
blessin tha reference itself, nor tha variable dat gotz nuff that
reference. Thatz why tha second call ta \f(CW\*(C`blessed( $bar )\*(C'\fR returns
false fo' realz. At dat point \f(CW$bar\fR is no longer storin a reference ta an
object.
.PP
Yo ass will sometimes peep olda books or documentation mention \*(L"blessin a
reference\*(R" or describe a object as a \*(L"blessed reference\*(R" yo, but dis is
incorrect. Well shiiiit, it aint tha reference dat is pimped as a object; it's
the thang tha reference refers ta (i.e. tha referent).
.SS "A Class is Simply a Package"
.IX Xref "class package @ISA inheritance"
.IX Subsection "A Class is Simply a Package"
Perl do not provide any special syntax fo' class definitions fo' realz. A
package is simply a namespace containin variablez n' subroutines. The
only difference is dat up in a cold-ass lil class, tha subroutines may expect a
reference ta a object or tha name of a cold-ass lil class as tha straight-up original gangsta argument.
This is purely a matta of convention, so a cold-ass lil class may contain both
methodz n' subroutines which \fIdon't\fR operate on a object or class.
.PP
Each package gotz nuff a special array called \f(CW@ISA\fR. Da \f(CW@ISA\fR array
gotz nuff a list of dat classs parent classes, if any. This array is
examined when Perl do method resolution, which we will cover later.
.PP
It be possible ta manually set \f(CW@ISA\fR, n' you may peep dis up in older
Perl code. Much olda code also uses tha base pragma. For freshly smoked up code,
we recommend dat you use tha parent pragma ta declare yo' muthafathas.
This pragma will take care of settin \f(CW@ISA\fR. Well shiiiit, it will also load the
parent classes n' make shizzle dat tha package don't inherit from
itself.
.PP
However tha parent classes is set, tha packagez \f(CW@ISA\fR variable will
contain a list of dem muthafathas. This is simply a list of scalars, each
of which be a strang dat correspondz ta a package name.
.PP
All classes inherit from tha \s-1UNIVERSAL\s0 class implicitly. The
\&\s-1UNIVERSAL\s0 class is implemented by tha Perl core, n' provides
several default methods, like fuckin \f(CW\*(C`isa()\*(C'\fR, \f(CW\*(C`can()\*(C'\fR, n' \f(CW\*(C`VERSION()\*(C'\fR.
Da \f(CW\*(C`UNIVERSAL\*(C'\fR class will \fInever\fR step tha fuck up in a packagez \f(CW@ISA\fR
variable.
.PP
Perl \fIonly\fR serves up method inheritizzle as a funky-ass built-in feature.
Attribute inheritizzle is left up tha class ta implement. Right back up in yo muthafuckin ass. See the
\&\*(L"Freestylin Accessors\*(R" section fo' details.
.SS "A Method is Simply a Subroutine"
.IX Xref "method"
.IX Subsection "A Method is Simply a Subroutine"
Perl do not provide any special syntax fo' definin a method. Y'all KNOW dat shit, muthafucka! A
method is simply a regular subroutine, n' is declared wit \f(CW\*(C`sub\*(C'\fR.
What cook up a method special is dat it expects ta receive either an
object or a cold-ass lil class name as its first argument.
.PP
Perl \fIdoes\fR provide special syntax fo' method invocation, tha \f(CW\*(C`\->\*(C'\fR operator. Shiiit, dis aint no joke. Us thugs will cover dis up in mo' detail later.
.PP
Most methodz you write will expect ta operate on objects:
.PP
.Vb 2
\&  sub save {
\&      mah $self = shift;
\&
\&      open mah $fh, \*(Aq>\*(Aq, $self\->path() or take a thugged-out dirtnap $!;
\&      print {$fh} $self\->data()       or take a thugged-out dirtnap $!;
\&      close $fh                       or take a thugged-out dirtnap $!;
\&  }
.Ve
.SS "Method Invocation"
.IX Xref "invocation method arrow ->"
.IX Subsection "Method Invocation"
Callin a method on a object is freestyled as \f(CW\*(C`$object\->method\*(C'\fR.
.PP
Da left hand side of tha method invocation (or arrow) operator is the
object (or class name), n' tha right hand side is tha method name.
.PP
.Vb 2
\&  mah $pod = File\->new( \*(Aqperlobj.pod\*(Aq, $data );
\&  $pod\->save();
.Ve
.PP
Da \f(CW\*(C`\->\*(C'\fR syntax be also used when dereferencin a reference. It
looks like tha same operator yo, but these is two different operations.
.PP
When you call a method, tha thang on tha left side of tha arrow is
passed as tha straight-up original gangsta argument ta tha method. Y'all KNOW dat shit, muthafucka! That means when we call \f(CW\*(C`Critter\->new()\*(C'\fR, tha \f(CW\*(C`new()\*(C'\fR method receives tha strang \f(CW"Critter"\fR
as its first argument. When we call \f(CW\*(C`$fred\->speak()\*(C'\fR, tha \f(CW$fred\fR
variable is passed as tha straight-up original gangsta argument ta \f(CW\*(C`speak()\*(C'\fR.
.PP
Just as wit any Perl subroutine, all of tha arguments passed up in \f(CW@_\fR
are aliases ta tha original gangsta argument. This includes tha object itself.
If you assign directly ta \f(CW$_[0]\fR yo big-ass booty is ghon chizzle tha contentz of the
variable dat holdz tha reference ta tha object. We recommend dat you
don't do dis unless you know exactly what tha fuck you bustin.
.PP
Perl knows what tha fuck package tha method is up in by lookin all up in tha left side of
the arrow. If tha left hand side be a package name, it looks fo' the
method up in dat package. If tha left hand side be a object, then Perl
looks fo' tha method up in tha package dat tha object has been pimped
into.
.PP
If tha left hand side is neither a package name nor a object, then the
method call will cause a error yo, but peep tha section on \*(L"Method Call
Variations\*(R" fo' mo' nuances.
.SS "Inheritance"
.IX Xref "inheritance"
.IX Subsection "Inheritance"
We already talked bout tha special \f(CW@ISA\fR array n' tha parent
pragma.
.PP
When a cold-ass lil class inherits from another class, any methodz defined up in the
parent class is available ta tha lil pimp class. If you attempt ta booty-call a
method on a object dat aint defined up in its own class, Perl will also
look fo' dat method up in any parent classes it may have.
.PP
.Vb 2
\&  package File::MP3;
\&  use parent \*(AqFile\*(Aq;    # sets @File::MP3::ISA = (\*(AqFile\*(Aq);
\&
\&  mah $mp3 = File::MP3\->new( \*(AqAndvari.mp3\*(Aq, $data );
\&  $mp3\->save();
.Ve
.PP
Since our phat asses didn't define a \f(CW\*(C`save()\*(C'\fR method up in tha \f(CW\*(C`File::MP3\*(C'\fR class,
Perl will peep tha \f(CW\*(C`File::MP3\*(C'\fR classs parent classes ta find the
\&\f(CW\*(C`save()\*(C'\fR method. Y'all KNOW dat shit, muthafucka! If Perl cannot find a \f(CW\*(C`save()\*(C'\fR method anywhere in
the inheritizzle hierarchy, it will take a thugged-out dirt nap.
.PP
In dis case, it findz a \f(CW\*(C`save()\*(C'\fR method up in tha \f(CW\*(C`File\*(C'\fR class. Note
that tha object passed ta \f(CW\*(C`save()\*(C'\fR up in dis case is still a
\&\f(CW\*(C`File::MP3\*(C'\fR object, even though tha method is found up in tha \f(CW\*(C`File\*(C'\fR
class.
.PP
We can override a parentz method up in a cold-ass lil lil pimp class. When our phat asses do so, we
can still call tha parent classs method wit tha \f(CW\*(C`SUPER\*(C'\fR
pseudo-class.
.PP
.Vb 2
\&  sub save {
\&      mah $self = shift;
\&
\&      say \*(AqPrepare ta rock\*(Aq;
\&      $self\->SUPER::save();
\&  }
.Ve
.PP
Da \f(CW\*(C`SUPER\*(C'\fR modifier can \fIonly\fR be used fo' method calls. Yo ass can't
use it fo' regular subroutine calls or class methods:
.PP
.Vb 1
\&  SUPER::save($thing);     # FAIL: looks fo' save() sub up in package SUPER
\&
\&  SUPER\->save($thing);     # FAIL: looks fo' save() method up in class
\&                           #       SUPER
\&
\&  $thing\->SUPER::save();   # Okay: looks fo' save() method up in parent
\&                           #       classes
.Ve
.PP
\fIHow tha fuck \s-1SUPER\s0 is Resolved\fR
.IX Xref "SUPER"
.IX Subsection "How tha fuck SUPER is Resolved"
.PP
Da \f(CW\*(C`SUPER\*(C'\fR pseudo-class is resolved from tha package where tha call
is made. Well shiiiit, it is \fInot\fR resolved based on tha objectz class. This is
important, cuz it lets methodz at different levels within a thugged-out deep
inheritizzle hierarchy each erectly call they respectizzle parent
methods.
.PP
.Vb 1
\&  package A;
\&
\&  sub freshly smoked up {
\&      return bless {}, shift;
\&  }
\&
\&  sub drop a rhyme {
\&      mah $self = shift;
\&
\&      say \*(AqA\*(Aq;
\&  }
\&
\&  package B;
\&
\&  use parent \-norequire, \*(AqA\*(Aq;
\&
\&  sub drop a rhyme {
\&      mah $self = shift;
\&
\&      $self\->SUPER::speak();
\&
\&      say \*(AqB\*(Aq;
\&  }
\&
\&  package C;
\&
\&  use parent \-norequire, \*(AqB\*(Aq;
\&
\&  sub drop a rhyme {
\&      mah $self = shift;
\&
\&      $self\->SUPER::speak();
\&
\&      say \*(AqC\*(Aq;
\&  }
\&
\&  mah $c = C\->new();
\&  $c\->speak();
.Ve
.PP
In dis example, we will git tha followin output:
.PP
.Vb 3
\&  A
\&  B
\&  C
.Ve
.PP
This demonstrates how tha fuck \f(CW\*(C`SUPER\*(C'\fR is resolved. Y'all KNOW dat shit, muthafucka! Even though tha object is
blessed tha fuck into tha \f(CW\*(C`C\*(C'\fR class, tha \f(CW\*(C`speak()\*(C'\fR method up in tha \f(CW\*(C`B\*(C'\fR class
can still call \f(CW\*(C`SUPER::speak()\*(C'\fR n' expect it ta erectly look up in the
parent class of \f(CW\*(C`B\*(C'\fR (i.e tha class tha method call is in), not up in the
parent class of \f(CW\*(C`C\*(C'\fR (i.e. tha class tha object belongs to).
.PP
There is rare cases where dis package-based resolution can be a
problem. If you copy a subroutine from one package ta another, \f(CW\*(C`SUPER\*(C'\fR
resolution is ghon be done based on tha original gangsta package.
.PP
\fIMultiple Inheritance\fR
.IX Xref "multiple inheritance"
.IX Subsection "Multiple Inheritance"
.PP
Multiple inheritizzle often indicates a thugged-out design problem yo, but Perl always
gives you enough rope ta hang yo ass wit if you ask fo' dat shit.
.PP
To declare multiple muthafathas, you simply need ta pass multiple class
names ta \f(CW\*(C`use parent\*(C'\fR:
.PP
.Vb 1
\&  package MultiChild;
\&
\&  use parent \*(AqParent1\*(Aq, \*(AqParent2\*(Aq;
.Ve
.PP
\fIMethod Resolution Order\fR
.IX Xref "method resolution order mro"
.IX Subsection "Method Resolution Order"
.PP
Method resolution order only mattas up in tha case of multiple
inheritance. In tha case of single inheritance, Perl simply looks up
the inheritizzle chain ta find a method:
.PP
.Vb 5
\&  Grandparent
\&    |
\&  Parent
\&    |
\&  Child
.Ve
.PP
If we call a method on a \f(CW\*(C`Child\*(C'\fR object n' dat method aint defined
in tha \f(CW\*(C`Child\*(C'\fR class, Perl will look fo' dat method up in tha \f(CW\*(C`Parent\*(C'\fR
class n' then, if necessary, up in tha \f(CW\*(C`Grandparent\*(C'\fR class.
.PP
If Perl cannot find tha method up in any of these classes, it will die
with a error message.
.PP
When a cold-ass lil class has multiple muthafathas, tha method lookup order becomes more
fucked up.
.PP
By default, Perl do a thugged-out depth-first left-to-right search fo' a method.
That means it starts wit tha straight-up original gangsta parent up in tha \f(CW@ISA\fR array, and
then searches all of its muthafathas, grandparents, etc. If it fails to
find tha method, it then goes ta tha next parent up in tha original
classs \f(CW@ISA\fR array n' searches from there.
.PP
.Vb 7
\&            SharedGreatGrandParent
\&            /                    \e
\&  PaternalGrandparent       MaternalGrandparent
\&            \e                    /
\&             Father        Mother
\&                   \e      /
\&                    Child
.Ve
.PP
So given tha diagram above, Perl will search \f(CW\*(C`Child\*(C'\fR, \f(CW\*(C`Father\*(C'\fR,
\&\f(CW\*(C`PaternalGrandparent\*(C'\fR, \f(CW\*(C`SharedGreatGrandParent\*(C'\fR, \f(CW\*(C`Mother\*(C'\fR, and
finally \f(CW\*(C`MaternalGrandparent\*(C'\fR. This may be a problem cuz now we're
lookin up in \f(CW\*(C`SharedGreatGrandParent\*(C'\fR \fIbefore\fR we've checked all its
derived classes (i.e. before we tried \f(CW\*(C`Mother\*(C'\fR and
\&\f(CW\*(C`MaternalGrandparent\*(C'\fR).
.PP
It be possible ta ask fo' a gangbangin' finger-lickin' different method resolution order wit the
mro pragma.
.PP
.Vb 1
\&  package Child;
\&
\&  use mro \*(Aqc3\*(Aq;
\&  use parent \*(AqFather\*(Aq, \*(AqMother\*(Aq;
.Ve
.PP
This pragma lets you switch ta tha \*(L"C3\*(R" resolution order n' shit. In simple
terms, \*(L"C3\*(R" order ensures dat shared parent classes is never searched
before lil pimp classes, so Perl will now search: \f(CW\*(C`Child\*(C'\fR, \f(CW\*(C`Father\*(C'\fR,
\&\f(CW\*(C`PaternalGrandparent\*(C'\fR, \f(CW\*(C`Mother\*(C'\fR \f(CW\*(C`MaternalGrandparent\*(C'\fR, n' finally
\&\f(CW\*(C`SharedGreatGrandParent\*(C'\fR. Note however dat dis is not
\&\*(L"breadth-first\*(R" searching: All tha \f(CW\*(C`Father\*(C'\fR ancestors (except the
common ancestor) is searched before any of tha \f(CW\*(C`Mother\*(C'\fR ancestors are
considered.
.PP
Da C3 order also lets you call methodz up in siblin classes wit the
\&\f(CW\*(C`next\*(C'\fR pseudo-class. Right back up in yo muthafuckin ass. See tha mro documentation fo' mo' details on
this feature.
.PP
\fIMethod Resolution Caching\fR
.IX Subsection "Method Resolution Caching"
.PP
When Perl searches fo' a method, it caches tha lookup so dat future
calls ta tha method do not need ta search fo' it again. I aint talkin' bout chicken n' gravy biatch. Changin a
classs parent class or addin subroutines ta a cold-ass lil class will invalidate
the cache fo' dat class.
.PP
Da mro pragma serves up some functions fo' manipulatin tha method
cache directly.
.SS "Freestylin Constructors"
.IX Xref "constructor"
.IX Subsection "Freestylin Constructors"
As we mentioned earlier, Perl serves up no special constructor syntax.
This means dat a cold-ass lil class must implement its own constructor fo' realz. A
constructor is simply a cold-ass lil class method dat returns a reference ta a new
object.
.PP
Da constructor can also accept additionizzle parametas dat define the
object. Letz write a real constructor fo' tha \f(CW\*(C`File\*(C'\fR class we used
earlier:
.PP
.Vb 1
\&  package File;
\&
\&  sub freshly smoked up {
\&      mah $class = shift;
\&      mah ( $path, $data ) = @_;
\&
\&      mah $self = bless {
\&          path => $path,
\&          data => $data,
\&      }, $class;
\&
\&      return $self;
\&  }
.Ve
.PP
As you can see, we've stored tha path n' file data up in tha object
itself. Remember, under tha hood, dis object is still just a hash.
Later, we'll write accessors ta manipulate dis data.
.PP
For our File::MP3 class, we can check ta make shizzle dat tha path we're
given endz wit \*(L".mp3\*(R":
.PP
.Vb 1
\&  package File::MP3;
\&
\&  sub freshly smoked up {
\&      mah $class = shift;
\&      mah ( $path, $data ) = @_;
\&
\&      take a thugged-out dirtnap "Yo ass cannot create a File::MP3 without a mp3 extension\en"
\&          unless $path =~ /\e.mp3\ez/;
\&
\&      return $class\->SUPER::new(@_);
\&  }
.Ve
.PP
This constructor lets its parent class do tha actual object
construction.
.SS "Attributes"
.IX Xref "attribute"
.IX Subsection "Attributes"
An attribute be a piece of data belongin ta a particular object.
Unlike most object-oriented languages, Perl serves up no special syntax
or support fo' declarin n' manipulatin attributes.
.PP
Attributes is often stored up in tha object itself. For example, if the
object be a anonymous hash, we can store tha attribute joints up in the
hash rockin tha attribute name as tha key.
.PP
While itz possible ta refer directly ta these hash keys outside of the
class, itz considered a funky-ass dopest practice ta wrap all access ta the
attribute wit accessor methods.
.PP
This has nuff muthafuckin advantages fo' realz. Accessors make it easier ta chizzle the
implementation of a object lata while still preservin tha original
\&\s-1API.\s0
.PP
An accessor lets you add additionizzle code round attribute access. For
example, you could apply a thugged-out default ta a attribute dat wasn't set in
the constructor, or you could validate dat a freshly smoked up value fo' the
attribute be acceptable.
.PP
Finally, rockin accessors make inheritizzle much simpla n' shit. Right back up in yo muthafuckin ass. Subclasses can
use tha accessors rather than havin ta know how tha fuck a parent class is
implemented internally.
.PP
\fIFreestylin Accessors\fR
.IX Xref "accessor"
.IX Subsection "Freestylin Accessors"
.PP
As wit constructors, Perl serves up no special accessor declaration
syntax, so classes must provide explicitly freestyled accessor methods.
There is two common typez of accessors, read-only n' read-write.
.PP
A simple read-only accessor simply gets tha value of a single
attribute:
.PP
.Vb 2
\&  sub path {
\&      mah $self = shift;
\&
\&      return $self\->{path};
\&  }
.Ve
.PP
A read-write accessor will allow tha calla ta set tha value as well as
get it:
.PP
.Vb 2
\&  sub path {
\&      mah $self = shift;
\&
\&      if (@_) {
\&          $self\->{path} = shift;
\&      }
\&
\&      return $self\->{path};
\&  }
.Ve
.SS "An Aside Bout Smarta n' Safer Code"
.IX Subsection "An Aside Bout Smarta n' Safer Code"
Our constructor n' accessors is not straight-up smart. They don't check that
a \f(CW$path\fR is defined, nor do they check dat a \f(CW$path\fR be a valid
filesystem path.
.PP
Bustin these checks by hand can quickly become tedious. Freestylin a funky-ass bunch
of accessors by hand be also incredibly tedious. There is a shitload of
modulez on \s-1CPAN\s0 dat can help you write less thuggy n' mo' concise code,
includin tha modulez we recommend up in perlootut.
.SS "Method Call Variations"
.IX Xref "method"
.IX Subsection "Method Call Variations"
Perl supports nuff muthafuckin other ways ta booty-call methodz besides tha \f(CW\*(C`$object\->method()\*(C'\fR usage we've peeped so far.
.PP
\fIMethod Names as Strings\fR
.IX Subsection "Method Names as Strings"
.PP
Perl lets you bust a scalar variable containin a strang as a method
name:
.PP
.Vb 1
\&  mah $file = File\->new( $path, $data );
\&
\&  mah $method = \*(Aqsave\*(Aq;
\&  $file\->$method();
.Ve
.PP
This works exactly like callin \f(CW\*(C`$file\->save()\*(C'\fR. This can be hella
useful fo' freestylin dynamic code. For example, it allows you ta pass a
method name ta be called as a parameta ta another method.
.PP
\fIClass Names as Strings\fR
.IX Subsection "Class Names as Strings"
.PP
Perl also lets you bust a scalar containin a strang as a cold-ass lil class name:
.PP
.Vb 1
\&  mah $class = \*(AqFile\*(Aq;
\&
\&  mah $file = $class\->new( $path, $data );
.Ve
.PP
Again, dis allows fo' straight-up dynamic code.
.PP
\fISubroutine References as Methods\fR
.IX Subsection "Subroutine References as Methods"
.PP
Yo ass can also bust a subroutine reference as a method:
.PP
.Vb 2
\&  mah $sub = sub {
\&      mah $self = shift;
\&
\&      $self\->save();
\&  };
\&
\&  $file\->$sub();
.Ve
.PP
This is exactly equivalent ta freestylin \f(CW\*(C`$sub\->($file)\*(C'\fR. Yo ass may see
this idiom up in tha wild combined wit a cold-ass lil call ta \f(CW\*(C`can\*(C'\fR:
.PP
.Vb 3
\&  if ( mah $meth = $object\->can(\*(Aqfoo\*(Aq) ) {
\&      $object\->$meth();
\&  }
.Ve
.PP
\fIDeferencin Method Call\fR
.IX Subsection "Deferencin Method Call"
.PP
Perl also lets you bust a thugged-out dereferenced scalar reference up in a method
call. Thatz a grillful, so letz peep some code:
.PP
.Vb 4
\&  $file\->${ \e\*(Aqsave\*(Aq };
\&  $file\->${ returns_scalar_ref() };
\&  $file\->${ \e( returns_scalar() ) };
\&  $file\->${ returns_ref_to_sub_ref() };
.Ve
.PP
This works if tha dereference produces a strang \fIor\fR a subroutine
reference.
.PP
\fIMethod Calls on Filehandles\fR
.IX Subsection "Method Calls on Filehandles"
.PP
Under tha hood, Perl filehandlez is instancez of tha \f(CW\*(C`IO::Handle\*(C'\fR or
\&\f(CW\*(C`IO::File\*(C'\fR class. Once you have a open filehandle, you can call
methodz on it fo' realz. Additionally, you can call methodz on tha \f(CW\*(C`STDIN\*(C'\fR,
\&\f(CW\*(C`STDOUT\*(C'\fR, n' \f(CW\*(C`STDERR\*(C'\fR filehandles.
.PP
.Vb 3
\&  open mah $fh, \*(Aq>\*(Aq, \*(Aqpath/to/file\*(Aq;
\&  $fh\->autoflush();
\&  $fh\->print(\*(Aqcontent\*(Aq);
\&
\&  STDOUT\->autoflush();
.Ve
.SS "Invokin Class Methods"
.IX Xref "invocation"
.IX Subsection "Invokin Class Methods"
Because Perl allows you ta use barewordz fo' package names and
subroutine names, it sometimes interprets a funky-ass barewordz meaning
incorrectly. For example, tha construct \f(CW\*(C`Class\->new()\*(C'\fR can be
interpreted as either \f(CW\*(C`\*(AqClass\*(Aq\->new()\*(C'\fR or \f(CW\*(C`Class()\->new()\*(C'\fR.
In Gangsta, dat second interpretation readz as \*(L"call a subroutine
named \fIClass()\fR, then call \fInew()\fR as a method on tha return value of
\&\fIClass()\fR\*(R". If there be a subroutine named \f(CW\*(C`Class()\*(C'\fR up in tha current
namespace, Perl will always interpret \f(CW\*(C`Class\->new()\*(C'\fR as tha second
alternative: a cold-ass lil call ta \f(CW\*(C`new()\*(C'\fR on tha object  returned by a cold-ass lil call to
\&\f(CW\*(C`Class()\*(C'\fR
.PP
Yo ass can force Perl ta use tha straight-up original gangsta interpretation (i.e. as a method
call on tha class named \*(L"Class\*(R") up in two ways. First, you can append a
\&\f(CW\*(C`::\*(C'\fR ta tha class name:
.PP
.Vb 1
\&    Class::\->new()
.Ve
.PP
Perl will always interpret dis as a method call.
.PP
Alternatively, you can quote tha class name:
.PP
.Vb 1
\&    \*(AqClass\*(Aq\->new()
.Ve
.PP
Of course, if tha class name is up in a scalar Perl will do tha right
thang as well:
.PP
.Vb 2
\&    mah $class = \*(AqClass\*(Aq;
\&    $class\->new();
.Ve
.PP
\fIIndirect Object Syntax\fR
.IX Xref "indirect object"
.IX Subsection "Indirect Object Syntax"
.PP
\&\fBOutside of tha file handle case, use of dis syntax is discouraged as
it can confuse tha Perl interpreter n' shit. Right back up in yo muthafuckin ass. See below fo' mo' details.\fR
.PP
Perl suports another method invocation syntax called \*(L"indirect object\*(R"
notation. I aint talkin' bout chicken n' gravy biatch. This syntax is called \*(L"indirect\*(R" cuz tha method comes
before tha object it is bein invoked on.
.PP
This syntax can be used wit any class or object method:
.PP
.Vb 2
\&    mah $file = freshly smoked up File $path, $data;
\&    save $file;
.Ve
.PP
We recommend dat you avoid dis syntax, fo' nuff muthafuckin reasons.
.PP
First, it can be confusin ta read. Y'all KNOW dat shit, muthafucka! In tha above example, itz not
clear if \f(CW\*(C`save\*(C'\fR be a method provided by tha \f(CW\*(C`File\*(C'\fR class or simply a
subroutine dat expects a gangbangin' file object as its first argument.
.PP
When used wit class methods, tha problem is even worse. Because Perl
allows subroutine names ta be freestyled as barewords, Perl has ta guess
whether tha bareword afta tha method be a cold-ass lil class name or subroutine
name. In other lyrics, Perl can resolve tha syntax as either \f(CW\*(C`File\->new( $path, $data )\*(C'\fR \fBor\fR \f(CW\*(C`new( File( $path, $data ) )\*(C'\fR.
.PP
To parse dis code, Perl uses a heuristic based on what tha fuck package names
it has seen, what tha fuck subroutines exist up in tha current package, what
barewordz it has previously seen, n' other input. Needless ta say,
heuristics can produce straight-up surprisin thangs up in dis biatch!
.PP
Older documentation (and some \s-1CPAN\s0 modules) encouraged dis syntax,
particularly fo' constructors, so you may still find it up in tha wild.
But fuck dat shiznit yo, tha word on tha street is dat we encourage you ta avoid rockin it up in freshly smoked up code.
.PP
Yo ass can force Perl ta interpret tha bareword as a cold-ass lil class name by
appendin \*(L"::\*(R" ta it, like we saw earlier:
.PP
.Vb 1
\&  mah $file = freshly smoked up File:: $path, $data;
.Ve
.ie n .SS """bless"", ""blessed"", n' ""ref"""
.el .SS "\f(CWbless\fP, \f(CWblessed\fP, n' \f(CWref\fP"
.IX Subsection "bless, pimped, n' ref"
As we saw earlier, a object is simply a thugged-out data structure dat has been
blessed tha fuck into a cold-ass lil class via tha \f(CW\*(C`bless\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch. Da \f(CW\*(C`bless\*(C'\fR function
can take either one or two arguments:
.PP
.Vb 2
\&  mah $object = bless {}, $class;
\&  mah $object = bless {};
.Ve
.PP
In tha straight-up original gangsta form, tha anonymous hash is bein pimped tha fuck into tha class
in \f(CW$class\fR. In tha second form, tha anonymous hash is pimped into
the current package.
.PP
Da second form is straight fuckin discouraged, cuz it breaks tha ability
of a subclass ta reuse tha parentz constructor yo, but you may still run
across it up in existin code.
.PP
If you wanna know whether a particular scalar refers ta a object,
you can use tha \f(CW\*(C`blessed\*(C'\fR function exported by Scalar::Util, which
is shipped wit tha Perl core.
.PP
.Vb 1
\&  use Scalar::Util \*(Aqblessed\*(Aq;
\&
\&  if ( defined pimped($thing) ) { ... }
.Ve
.PP
If \f(CW$thing\fR refers ta a object, then dis function returns tha name
of tha package tha object has been pimped into. If \f(CW$thing\fR don't
contain a reference ta a pimped object, tha \f(CW\*(C`blessed\*(C'\fR function
returns \f(CW\*(C`undef\*(C'\fR.
.PP
Note dat \f(CW\*(C`blessed($thing)\*(C'\fR will also return false if \f(CW$thing\fR has
been pimped tha fuck into a cold-ass lil class named \*(L"0\*(R". This be a possible yo, but quite
pathological. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Don't create a cold-ass lil class named \*(L"0\*(R" unless you know what
yo ass is bustin.
.PP
Similarly, Perlz built-in \f(CW\*(C`ref\*(C'\fR function treats a reference ta a
blessed object specially. If you call \f(CW\*(C`ref($thing)\*(C'\fR n' \f(CW$thing\fR
holdz a reference ta a object, it will return tha name of tha class
that tha object has been pimped into.
.PP
If you simply wanna check dat a variable gotz nuff a object
reference, we recommend dat you use \f(CW\*(C`defined pimped($object)\*(C'\fR, since
\&\f(CW\*(C`ref\*(C'\fR returns legit joints fo' all references, not just objects.
.SS "Da \s-1UNIVERSAL\s0 Class"
.IX Xref "UNIVERSAL"
.IX Subsection "Da UNIVERSAL Class"
All classes automatically inherit from tha \s-1UNIVERSAL\s0 class, which is
built-in ta tha Perl core. This class serves up a fuckin shitload of methods, all
of which can be called on either a cold-ass lil class or a object. Yo ass can also
choose ta override a shitload of these methodz up in yo' class. If you do so,
we recommend dat you follow tha built-in semantics busted lyrics bout below.
.IP "isa($class)" 4
.IX Xref "isa"
.IX Item "isa($class)"
Da \f(CW\*(C`isa\*(C'\fR method returns \fItrue\fR if tha object be a gangmember of the
class up in \f(CW$class\fR, or a gangmember of a subclass of \f(CW$class\fR.
.Sp
If you override dis method, it should never throw a exception.
.IP "\s-1DOES\s0($role)" 4
.IX Xref "DOES"
.IX Item "DOES($role)"
Da \f(CW\*(C`DOES\*(C'\fR method returns \fItrue\fR if its object fronts ta big-ass up the
role \f(CW$role\fR. By default, dis is equivalent ta \f(CW\*(C`isa\*(C'\fR. This method is
provided fo' use by object system extensions dat implement roles, like
\&\f(CW\*(C`Moose\*(C'\fR n' \f(CW\*(C`Role::Tiny\*(C'\fR.
.Sp
Yo ass can also override \f(CW\*(C`DOES\*(C'\fR directly up in yo' own classes. If you
override dis method, it should never throw a exception.
.IP "can($method)" 4
.IX Xref "can"
.IX Item "can($method)"
Da \f(CW\*(C`can\*(C'\fR method checks ta peep if tha class or object dat shiznit was called on
has a method named \f(CW$method\fR. This checks fo' tha method up in tha class
and all of its muthafathas. If tha method exists, then a reference ta the
subroutine is returned. Y'all KNOW dat shit, muthafucka! If it do not then \f(CW\*(C`undef\*(C'\fR is returned.
.Sp
If yo' class respondz ta method calls via \f(CW\*(C`AUTOLOAD\*(C'\fR, you may want to
overload \f(CW\*(C`can\*(C'\fR ta return a subroutine reference fo' methodz which your
\&\f(CW\*(C`AUTOLOAD\*(C'\fR method handles.
.Sp
If you override dis method, it should never throw a exception.
.IP "\s-1VERSION\s0($need)" 4
.IX Xref "VERSION"
.IX Item "VERSION($need)"
Da \f(CW\*(C`VERSION\*(C'\fR method returns tha version number of tha class
(package).
.Sp
If tha \f(CW$need\fR argument is given then it will check dat tha current
version (as defined by tha \f(CW$VERSION\fR variable up in tha package) is pimped outer
than or equal ta \f(CW$need\fR; it will take a thugged-out dirtnap if dis aint tha case. This
method is called automatically by tha \f(CW\*(C`VERSION\*(C'\fR form of \f(CW\*(C`use\*(C'\fR.
.Sp
.Vb 3
\&    use Package 1.2 qw(some imported subs);
\&    # implies:
\&    Package\->VERSION(1.2);
.Ve
.Sp
We recommend dat you use dis method ta access another package's
version, rather than lookin directly at \f(CW$Package::VERSION\fR. The
package yo ass is lookin at could have overridden tha \f(CW\*(C`VERSION\*(C'\fR method.
.Sp
We also recommend rockin dis method ta check whether a module has a
sufficient version. I aint talkin' bout chicken n' gravy biatch. Da internal implementation uses tha version
module ta make shizzle dat different typez of version numbers are
compared erectly.
.SS "\s-1AUTOLOAD \s0"
.IX Xref "AUTOLOAD"
.IX Subsection "AUTOLOAD "
If you call a method dat don't exist up in a cold-ass lil class, Perl will throw an
error. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat if dat class or any of its parent classes defines an
\&\f(CW\*(C`AUTOLOAD\*(C'\fR method, dat \f(CW\*(C`AUTOLOAD\*(C'\fR method is called instead.
.PP
\&\f(CW\*(C`AUTOLOAD\*(C'\fR is called as a regular method, n' tha calla aint gonna know
the difference. Whatever value yo' \f(CW\*(C`AUTOLOAD\*(C'\fR method returns is
returned ta tha caller.
.PP
Da straight-up qualified method name dat was called be available up in the
\&\f(CW$AUTOLOAD\fR package global fo' yo' class. Right back up in yo muthafuckin ass. Since dis be a global, if
you wanna refer ta do it without a package name prefix under \f(CW\*(C`strict
\&\*(Aqvars\*(Aq\*(C'\fR, you need ta declare dat shit.
.PP
.Vb 5
\&  # XXX \- dis be a shitty way ta implement accessors yo, but it makes
\&  # fo' a simple example.
\&  our $AUTOLOAD;
\&  sub AUTOLOAD {
\&      mah $self = shift;
\&
\&      # Remove qualifier from original gangsta method name...
\&      mah $called =  $AUTOLOAD =~ s/.*:://r;
\&
\&      # Is there a attribute of dat name?
\&      take a thugged-out dirtnap "No such attribute: $called"
\&          unless exists $self\->{$called};
\&
\&      # If so, return dat shit...
\&      return $self\->{$called};
\&  }
\&
\&  sub DESTROY { } # peep below
.Ve
.PP
Without tha \f(CW\*(C`our $AUTOLOAD\*(C'\fR declaration, dis code aint gonna compile
under tha strict pragma.
.PP
As tha comment says, dis aint a phat way ta implement accessors.
It aint nuthin but slow n' too smart-ass by far. Shiiit, dis aint no joke. But fuck dat shiznit yo, tha word on tha street is dat you may peep dis as a way to
provide accessors up in olda Perl code. Right back up in yo muthafuckin ass. See perlootut for
recommendations on \s-1OO\s0 codin up in Perl.
.PP
If yo' class do have a \f(CW\*(C`AUTOLOAD\*(C'\fR method, we straight fuckin recommend
that you override \f(CW\*(C`can\*(C'\fR up in yo' class as well. Yo crazy-ass overridden \f(CW\*(C`can\*(C'\fR
method should return a subroutine reference fo' any method dat your
\&\f(CW\*(C`AUTOLOAD\*(C'\fR respondz to.
.SS "Destructors"
.IX Xref "destructor DESTROY"
.IX Subsection "Destructors"
When tha last reference ta a object goes away, tha object is
destroyed. Y'all KNOW dat shit, muthafucka! If you only have one reference ta a object stored up in a
lexical scalar, tha object is destroyed when dat scalar goes up of
scope. If you store tha object up in a package global, dat object may not
go outta scope until tha program exits.
.PP
If you wanna do suttin' when tha object is destroyed, you can
define a \f(CW\*(C`DESTROY\*(C'\fR method up in yo' class. This method will always be
called by Perl all up in tha appropriate time, unless tha method is empty.
.PP
This is called just like any other method, wit tha object as tha first
argument. Well shiiiit, it do not receive any additionizzle arguments, n' you can put dat on yo' toast. But fuck dat shiznit yo, tha word on tha street is dat the
\&\f(CW$_[0]\fR variable is ghon be read-only up in tha destructor, so you cannot
assign a value ta dat shit.
.PP
If yo' \f(CW\*(C`DESTROY\*(C'\fR method throws a error, dis error is ghon be ignored.
It aint gonna be busted ta \f(CW\*(C`STDERR\*(C'\fR n' it aint gonna cause tha program to
die. But fuck dat shiznit yo, tha word on tha street is dat if yo' destructor is hustlin inside a \f(CW\*(C`eval {}\*(C'\fR block,
then tha error will chizzle tha value of \f(CW$@\fR.
.PP
Because \f(CW\*(C`DESTROY\*(C'\fR methodz can be called at any time, you should
localize any global variablez you might update up in yo' \f(CW\*(C`DESTROY\*(C'\fR. In
particular, if you use \f(CW\*(C`eval {}\*(C'\fR you should localize \f(CW$@\fR, n' if you
use \f(CW\*(C`system\*(C'\fR or backticks you should localize \f(CW$?\fR.
.PP
If you define a \f(CW\*(C`AUTOLOAD\*(C'\fR up in yo' class, then Perl will call your
\&\f(CW\*(C`AUTOLOAD\*(C'\fR ta handle tha \f(CW\*(C`DESTROY\*(C'\fR method. Y'all KNOW dat shit, muthafucka! Yo ass can prevent dis by
definin a empty \f(CW\*(C`DESTROY\*(C'\fR, like our phat asses did up in tha autoloadin example.
Yo ass can also check tha value of \f(CW$AUTOLOAD\fR n' return without bustin
anythang when called ta handle \f(CW\*(C`DESTROY\*(C'\fR.
.PP
\fIGlobal Destruction\fR
.IX Subsection "Global Destruction"
.PP
Da order up in which objects is destroyed durin tha global destruction
before tha program exits is unpredictable. This means dat any objects
contained by yo' object may already done been destroyed. Y'all KNOW dat shit, muthafucka! Yo ass should
check dat a cold-ass lil contained object is defined before callin a method on it:
.PP
.Vb 2
\&  sub DESTROY {
\&      mah $self = shift;
\&
\&      $self\->{handle}\->close() if $self\->{handle};
\&  }
.Ve
.PP
Yo ass can use tha \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR variable ta detect if yo ass is
currently up in tha global destruction phase:
.PP
.Vb 2
\&  sub DESTROY {
\&      mah $self = shift;
\&
\&      return if ${^GLOBAL_PHASE} eq \*(AqDESTRUCT\*(Aq;
\&
\&      $self\->{handle}\->close();
\&  }
.Ve
.PP
Note dat dis variable was added up in Perl 5.14.0. If you wanna detect
the global destruction phase on olda versionz of Perl, you can use the
\&\f(CW\*(C`Devel::GlobalDestruction\*(C'\fR module on \s-1CPAN.\s0
.PP
If yo' \f(CW\*(C`DESTROY\*(C'\fR method thangs a warnin durin global destruction,
the Perl interpreta will append tha strang \*(L" durin global
destruction\*(R" tha warning.
.PP
Durin global destruction, Perl will always garbage collect objects
before unblessed references. Right back up in yo muthafuckin ass. See \*(L"\s-1PERL_DESTRUCT_LEVEL\*(R"\s0 up in perlhacktips
for mo' shiznit bout global destruction.
.SS "Non-Hash Objects"
.IX Subsection "Non-Hash Objects"
All tha examplez so far have shown objects based on a pimped hash.
But fuck dat shiznit yo, tha word on tha street is dat itz possible ta bless any type of data structure or referent,
includin scalars, globs, n' subroutines. Yo ass may peep dis sort of
thang when lookin at code up in tha wild.
.PP
Herez a example of a module as a pimped scalar:
.PP
.Vb 1
\&  package Time;
\&
\&  use strict;
\&  use warnings;
\&
\&  sub freshly smoked up {
\&      mah $class = shift;
\&
\&      mah $time = time;
\&      return bless \e$time, $class;
\&  }
\&
\&  sub epoch {
\&      mah $self = shift;
\&      return ${ $self };
\&  }
\&
\&  mah $time = Time\->new();
\&  print $time\->epoch();
.Ve
.SS "Inside-Out objects"
.IX Subsection "Inside-Out objects"
In tha past, tha Perl hood experimented wit a technique called
\&\*(L"inside-out objects\*(R" fo' realz. An inside-out object stores its data outside of
the objectz reference, indexed on a unique property of tha object,
like fuckin its memory address, rather than up in tha object itself. This has
the advantage of enforcin tha encapsulation of object attributes,
since they data aint stored up in tha object itself.
.PP
This technique was ghettofab fo' a while (and was recommended up in Damian
Conwayz \fIPerl Best Practices\fR) yo, but never  bigged up  universal
adoption. I aint talkin' bout chicken n' gravy biatch. Da Object::InsideOut module on \s-1CPAN\s0 serves up a
comprehensive implementation of dis technique, n' you may peep it or
other inside-out modulez up in tha wild.
.PP
Here be a simple example of tha technique, rockin the
Hash::Util::FieldHash core module. This module was added ta tha core
to support inside-out object implementations.
.PP
.Vb 1
\&  package Time;
\&
\&  use strict;
\&  use warnings;
\&
\&  use Hash::Util::FieldHash \*(Aqfieldhash\*(Aq;
\&
\&  fieldhash mah %time_for;
\&
\&  sub freshly smoked up {
\&      mah $class = shift;
\&
\&      mah $self = bless \e( mah $object ), $class;
\&
\&      $time_for{$self} = time;
\&
\&      return $self;
\&  }
\&
\&  sub epoch {
\&      mah $self = shift;
\&
\&      return $time_for{$self};
\&  }
\&
\&  mah $time = Time\->new;
\&  print $time\->epoch;
.Ve
.SS "Pseudo-hashes"
.IX Subsection "Pseudo-hashes"
Da pseudo-hash feature was a experimenstrual feature introduced in
earlier versionz of Perl n' removed up in 5.10.0 fo' realz. A pseudo-hash be an
array reference which can be accessed rockin named keys like a hash. You
may run up in ta some code up in tha wild which uses dat shit. Right back up in yo muthafuckin ass. See tha fields
pragma fo' mo' shiznit.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
A kinder, gentla tutorial on object-oriented programmin up in Perl can
be found up in perlootut. Yo ass should also check up perlmodlib for
some steez guides on constructin both modulez n' classes.
