.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ENC 1"
.TH ENC 1 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
enc \- symmetric cipher routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBopenssl enc \-ciphername\fR
[\fB\-in filename\fR]
[\fB\-out filename\fR]
[\fB\-pass arg\fR]
[\fB\-e\fR]
[\fB\-d\fR]
[\fB\-a/\-base64\fR]
[\fB\-A\fR]
[\fB\-k password\fR]
[\fB\-kfile filename\fR]
[\fB\-K key\fR]
[\fB\-iv \s-1IV\s0\fR]
[\fB\-S salt\fR]
[\fB\-salt\fR]
[\fB\-nosalt\fR]
[\fB\-z\fR]
[\fB\-md\fR]
[\fB\-p\fR]
[\fB\-P\fR]
[\fB\-bufsize number\fR]
[\fB\-nopad\fR]
[\fB\-debug\fR]
[\fB\-none\fR]
[\fB\-engine id\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da symmetric cipher commandz allow data ta be encrypted or decrypted
usin various block n' stream ciphers rockin keys based on passwords
or explicitly provided. Y'all KNOW dat shit, muthafucka! Base64 encodin or decodin can also be performed
either by itself or up in addizzle ta tha encryption or decryption.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-in filename\fR" 4
.IX Item "-in filename"
the input filename, standard input by default.
.IP "\fB\-out filename\fR" 4
.IX Item "-out filename"
the output filename, standard output by default.
.IP "\fB\-pass arg\fR" 4
.IX Item "-pass arg"
the password source. For mo' shiznit bout tha format of \fBarg\fR
see tha \fB\s-1PASS PHRASE ARGUMENTS\s0\fR section up in \fIopenssl\fR\|(1).
.IP "\fB\-salt\fR" 4
.IX Item "-salt"
use a salt up in tha key derivation routines. This is tha default.
.IP "\fB\-nosalt\fR" 4
.IX Item "-nosalt"
don't bust a salt up in tha key derivation routines. This option \fB\s-1SHOULD NOT\s0\fR be
used except fo' test purposes or compatibilitizzle wit ancient versionz of OpenSSL
and SSLeay.
.IP "\fB\-e\fR" 4
.IX Item "-e"
encrypt tha input data: dis is tha default.
.IP "\fB\-d\fR" 4
.IX Item "-d"
decrypt tha input data.
.IP "\fB\-a\fR" 4
.IX Item "-a"
base64 process tha data. This means dat if encryption is takin place
the data is base64 encoded afta encryption. I aint talkin' bout chicken n' gravy biatch. If decryption is set then
the input data is base64 decoded before bein decrypted.
.IP "\fB\-base64\fR" 4
.IX Item "-base64"
same as \fB\-a\fR
.IP "\fB\-A\fR" 4
.IX Item "-A"
if tha \fB\-a\fR option is set then base64 process tha data on one line.
.IP "\fB\-k password\fR" 4
.IX Item "-k password"
the password ta derive tha key from. This is fo' compatibilitizzle wit previous
versionz of OpenSSL. Right back up in yo muthafuckin ass. Superseded by tha \fB\-pass\fR argument.
.IP "\fB\-kfile filename\fR" 4
.IX Item "-kfile filename"
read tha password ta derive tha key from tha straight-up original gangsta line of \fBfilename\fR.
This is fo' compatibilitizzle wit previous versionz of OpenSSL. Right back up in yo muthafuckin ass. Superseded by
the \fB\-pass\fR argument.
.IP "\fB\-nosalt\fR" 4
.IX Item "-nosalt"
do not bust a salt
.IP "\fB\-salt\fR" 4
.IX Item "-salt"
use salt (randomly generated or provide wit \fB\-S\fR option) when
encryptin (this is tha default).
.IP "\fB\-S salt\fR" 4
.IX Item "-S salt"
the actual salt ta use: dis must be represented as a strang of hex digits.
.IP "\fB\-K key\fR" 4
.IX Item "-K key"
the actual key ta use: dis must be represented as a strang comprised only
of hex digits, n' you can put dat on yo' toast. If only tha key is specified, tha \s-1IV\s0 must additionally specified
usin tha \fB\-iv\fR option. I aint talkin' bout chicken n' gravy biatch. When both a key n' a password is specified, the
key given wit tha \fB\-K\fR option is ghon be used n' tha \s-1IV\s0 generated from the
password is ghon be taken. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it probably do not make much sense ta specify
both key n' password.
.IP "\fB\-iv \s-1IV\s0\fR" 4
.IX Item "-iv IV"
the actual \s-1IV\s0 ta use: dis must be represented as a strang comprised only
of hex digits, n' you can put dat on yo' toast. When only tha key is specified rockin tha \fB\-K\fR option, the
\&\s-1IV\s0 must explicitly be defined. Y'all KNOW dat shit, muthafucka! When a password is bein specified using
one of tha other options, tha \s-1IV\s0 is generated from dis password.
.IP "\fB\-p\fR" 4
.IX Item "-p"
print up tha key n' \s-1IV\s0 used.
.IP "\fB\-P\fR" 4
.IX Item "-P"
print up tha key n' \s-1IV\s0 used then immediately exit: don't do any encryption
or decryption.
.IP "\fB\-bufsize number\fR" 4
.IX Item "-bufsize number"
set tha buffer size fo' I/O
.IP "\fB\-nopad\fR" 4
.IX Item "-nopad"
disable standard block padding
.IP "\fB\-debug\fR" 4
.IX Item "-debug"
debug tha BIOs used fo' I/O.
.IP "\fB\-z\fR" 4
.IX Item "-z"
Compress or decompress clear text rockin zlib before encryption or after
decryption. I aint talkin' bout chicken n' gravy biatch. This option exists only if OpenSSL wit compiled wit zlib
or zlib-dynamic option.
.IP "\fB\-none\fR" 4
.IX Item "-none"
Use \s-1NULL\s0 cipher (no encryption or decryption of input).
.SH "NOTES"
.IX Header "NOTES"
Da program can be called either as \fBopenssl ciphername\fR or
\&\fBopenssl enc \-ciphername\fR. But tha straight-up original gangsta form don't work with
engine-provided ciphers, cuz dis form is processed before the
configuration file is read n' any ENGINEs loaded.
.PP
Engines which provide entirely freshly smoked up encryption algorithms (like fuckin ccgost
engine which serves up gost89 algorithm) should be configured up in the
configuration file. Engines, specified up in tha command line rockin \-engine
options can only be used fo' hadrware-assisted implementations of
ciphers, which is supported by OpenSSL core or other engine, specified
in tha configuration file.
.PP
When enc command lists supported ciphers, ciphers provided by engines,
specified up in tha configuration filez is listed like a muthafucka.
.PP
A password is ghon be prompted fo' ta derive tha key n' \s-1IV\s0 if necessary.
.PP
Da \fB\-salt\fR option should \fB\s-1ALWAYS\s0\fR be used if tha key is bein derived
from a password unless you want compatibilitizzle wit previous versions of
OpenSSL n' SSLeay.
.PP
Without tha \fB\-salt\fR option it is possible ta big-ass up efficient dictionary
attacks on tha password n' ta battle stream cipher encrypted data. Da reason
for dis is dat without tha salt tha same password always generates tha same
encryption key. When tha salt is bein used tha straight-up original gangsta eight bytez of the
encrypted data is reserved fo' tha salt: it is generated at random when
encryptin a gangbangin' file n' read from tha encrypted file when it is decrypted.
.PP
Some of tha ciphers aint gots big-ass keys n' others have security
implications if not used erectly fo' realz. A beginner be advised ta just use
a phat block cipher up in \s-1CBC\s0 mode like fuckin bf or des3.
.PP
All tha block ciphers normally use PKCS#5 paddin also known as standard block
padding: dis allows a rudimentary integritizzle or password check ta be
performed. Y'all KNOW dat shit, muthafucka! However since tha chizzle of random data passin tha test is
betta than 1 up in 256 it aint a straight-up phat test.
.PP
If paddin is disabled then tha input data must be a multiple of tha cipher
block length.
.PP
All \s-1RC2\s0 ciphers have tha same key n' effectizzle key length.
.PP
Blowfish n' \s-1RC5\s0 algorithms bust a 128 bit key.
.SH "SUPPORTED CIPHERS"
.IX Header "SUPPORTED CIPHERS"
Note dat a shitload of these ciphers can be disabled at compile time
and some is available only if a appropriate engine is configured
in tha configuration file. Da output of tha \fBenc\fR command run with
unsupported options (for example \fBopenssl enc \-help\fR) includes a
list of ciphers, supported by yo' versesion of OpenSSL, including
ones provided by configured engines.
.PP
.Vb 1
\& base64             Base 64
\&
\& bf\-cbc             Blowfish up in STD mode
\& bf                 Alias fo' bf\-cbc
\& bf\-cfb             Blowfish up in CFB mode
\& bf\-ecb             Blowfish up in ECB mode
\& bf\-ofb             Blowfish up in OFB mode
\&
\& cast\-cbc           CAST up in STD mode
\& cast               Alias fo' cast\-cbc
\& cast5\-cbc          CAST5 up in STD mode
\& cast5\-cfb          CAST5 up in CFB mode
\& cast5\-ecb          CAST5 up in ECB mode
\& cast5\-ofb          CAST5 up in OFB mode
\&
\& des\-cbc            DES up in STD mode
\& des                Alias fo' des\-cbc
\& des\-cfb            DES up in STD mode
\& des\-ofb            DES up in OFB mode
\& des\-ecb            DES up in ECB mode
\&
\& des\-ede\-cbc        Two key triple DES EDE up in STD mode
\& des\-ede            Two key triple DES EDE up in ECB mode
\& des\-ede\-cfb        Two key triple DES EDE up in CFB mode
\& des\-ede\-ofb        Two key triple DES EDE up in OFB mode
\&
\& des\-ede3\-cbc       Three key triple DES EDE up in STD mode
\& des\-ede3           Three key triple DES EDE up in ECB mode
\& des3               Alias fo' des\-ede3\-cbc
\& des\-ede3\-cfb       Three key triple DES EDE CFB mode
\& des\-ede3\-ofb       Three key triple DES EDE up in OFB mode
\&
\& desx               DESX algorithm.
\&
\& gost89             GOST 28147\-89 up in CFB mode (provided by ccgost engine)
\& gost89\-cnt        \`GOST 28147\-89 up in CNT mode (provided by ccgost engine) 
\&
\& idea\-cbc           IDEA algorithm up in STD mode
\& scam               same as idea\-cbc
\& idea\-cfb           IDEA up in CFB mode
\& idea\-ecb           IDEA up in ECB mode
\& idea\-ofb           IDEA up in OFB mode
\&
\& rc2\-cbc            128 bit RC2 up in STD mode
\& rc2                Alias fo' rc2\-cbc
\& rc2\-cfb            128 bit RC2 up in CFB mode
\& rc2\-ecb            128 bit RC2 up in ECB mode
\& rc2\-ofb            128 bit RC2 up in OFB mode
\& rc2\-64\-cbc         64 bit RC2 up in STD mode
\& rc2\-40\-cbc         40 bit RC2 up in STD mode
\&
\& rc4                128 bit RC4
\& rc4\-64             64 bit RC4
\& rc4\-40             40 bit RC4
\&
\& rc5\-cbc            RC5 cipher up in STD mode
\& rc5                Alias fo' rc5\-cbc
\& rc5\-cfb            RC5 cipher up in CFB mode
\& rc5\-ecb            RC5 cipher up in ECB mode
\& rc5\-ofb            RC5 cipher up in OFB mode
\&
\& aes\-[128|192|256]\-cbc  128/192/256 bit AES up in STD mode
\& aes\-[128|192|256]      Alias fo' aes\-[128|192|256]\-cbc
\& aes\-[128|192|256]\-cfb  128/192/256 bit AES up in 128 bit CFB mode
\& aes\-[128|192|256]\-cfb1 128/192/256 bit AES up in 1 bit CFB mode
\& aes\-[128|192|256]\-cfb8 128/192/256 bit AES up in 8 bit CFB mode
\& aes\-[128|192|256]\-ecb  128/192/256 bit AES up in ECB mode
\& aes\-[128|192|256]\-ofb  128/192/256 bit AES up in OFB mode
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Just base64 encode a funky-ass binary file:
.PP
.Vb 1
\& openssl base64 \-in file.bin \-out file.b64
.Ve
.PP
Decode tha same file
.PP
.Vb 1
\& openssl base64 \-d \-in file.b64 \-out file.bin
.Ve
.PP
Encrypt a gangbangin' file rockin triple \s-1DES\s0 up in \s-1CBC\s0 mode rockin a prompted password:
.PP
.Vb 1
\& openssl des3 \-salt \-in file.txt \-out file.des3
.Ve
.PP
Decrypt a gangbangin' file rockin a supplied password:
.PP
.Vb 1
\& openssl des3 \-d \-salt \-in file.des3 \-out file.txt \-k mypassword
.Ve
.PP
Encrypt a gangbangin' file then base64 encode it (so it can be busted via mail fo' example)
usin Blowfish up in \s-1CBC\s0 mode:
.PP
.Vb 1
\& openssl bf \-a \-salt \-in file.txt \-out file.bf
.Ve
.PP
Base64 decode a gangbangin' file then decrypt it:
.PP
.Vb 1
\& openssl bf \-d \-salt \-a \-in file.bf \-out file.txt
.Ve
.PP
Decrypt some data rockin a supplied 40 bit \s-1RC4\s0 key:
.PP
.Vb 1
\& openssl rc4\-40 \-in file.rc4 \-out file.txt \-K 0102030405
.Ve
.SH "BUGS"
.IX Header "BUGS"
Da \fB\-A\fR option when used wit big-ass filez don't work properly.
.PP
There should be a option ta allow a iteration count ta be included.
.PP
Da \fBenc\fR program only supports a gangbangin' fixed number of algorithms with
certain parameters. Right back up in yo muthafuckin ass. So if, fo' example, you wanna use \s-1RC2\s0 wit a
76 bit key or \s-1RC4\s0 wit a 84 bit key you can't use dis program.
