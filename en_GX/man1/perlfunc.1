.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFUNC 1"
.TH PERLFUNC 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfunc \- Perl builtin functions
.IX Xref "function"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da functions up in dis section can serve as terms up in a expression.
They fall tha fuck into two major categories: list operators n' named unary
operators.  These differ up in they precedence relationshizzle wit a
followin comma.  (See tha precedence table up in perlop.)  List
operators take mo' than one argument, while unary operators can never
take mo' than one argument.  Thus, a cold-ass lil comma terminates tha argument of
a unary operator yo, but merely separates tha argumentz of a list
operator. Shiiit, dis aint no joke.  A unary operator generally serves up scalar context ta its
argument, while a list operator may provide either scalar or list
contexts fo' its arguments, n' you can put dat on yo' toast.  If it do both, scalar arguments 
come first n' list argument follow, n' there can only ever
be one such list argument.  For instance, \fIsplice()\fR has three scalar
arguments followed by a list, whereas \fIgethostbyname()\fR has four scalar
arguments.
.PP
In tha syntax descriptions dat follow, list operators dat expect a
list (and provide list context fo' elementz of tha list) is shown
with \s-1LIST\s0 as a argument.  Such a list may consist of any combination
of scalar arguments or list joints; tha list joints is ghon be included
in tha list as if each individual element was interpolated at that
point up in tha list, formin a longer single-dimensionizzle list value.
Commas should separate literal elementz of tha \s-1LIST.\s0
.PP
Any function up in tha list below may be used either wit or without
parentheses round its arguments, n' you can put dat on yo' toast.  (Da syntax descriptions omit the
parentheses.)  If you use parentheses, tha simple but occasionally 
surprisin rule is this: It \fIlooks\fR like a gangbangin' function, therefore it \fIis\fR a
function, n' precedence don't matter n' shit.  Otherwise itz a list
operator or unary operator, n' precedence do matter n' shit.  Whitespace
between tha function n' left parenthesis don't count, so sometimes
you need ta be careful:
.PP
.Vb 5
\&    print 1+2+4;      # Prints 7.
\&    print(1+2) + 4;   # Prints 3.
\&    print (1+2)+4;    # Also prints 3!
\&    print +(1+2)+4;   # Prints 7.
\&    print ((1+2)+4);  # Prints 7.
.Ve
.PP
If you run Perl wit tha \fB\-w\fR switch it can warn you bout all dis bullshit.  For
example, tha third line above produces:
.PP
.Vb 2
\&    print (...) interpreted as function at \- line 1.
\&    Useless use of integer addizzle up in void context at \- line 1.
.Ve
.PP
A few functions take no arguments at all, n' therefore work as neither
unary nor list operators.  These include such functions as \f(CW\*(C`time\*(C'\fR
and \f(CW\*(C`endpwent\*(C'\fR.  For example, \f(CW\*(C`time+86_400\*(C'\fR always means
\&\f(CW\*(C`time() + 86_400\*(C'\fR.
.PP
For functions dat can be used up in either a scalar or list context,
nonabortizzle failure is generally indicated up in scalar context by
returnin tha undefined value, n' up in list context by returnin the
empty list.
.PP
Remember tha followin blingin rule: There is \fBno rule\fR dat relates
the behavior of a expression up in list context ta its behavior up in scalar
context, or vice versa.  It might do two straight-up different thangs.
Each operator n' function decides which sort of value would be most
appropriate ta return up in scalar context.  Some operators return the
length of tha list dat would done been returned up in list context.  Some
operators return tha straight-up original gangsta value up in tha list.  Some operators return the
last value up in tha list.  Some operators return a cold-ass lil count of successful
operations.  In general, they do what tha fuck you want, unless you want
consistency.
.IX Xref "context"
.PP
A named array up in scalar context is like different from what tha fuck would at
first glizzle step tha fuck up ta be a list up in scalar context.  Yo ass can't git a list
like \f(CW\*(C`(1,2,3)\*(C'\fR tha fuck into bein up in scalar context, cuz tha compila knows
the context at compile time.  It would generate tha scalar comma operator
there, not tha list construction version of tha comma.  That means it
was never a list ta start with.
.PP
In general, functions up in Perl dat serve as wrappers fo' system calls (\*(L"syscalls\*(R")
of tha same name (like \fIchown\fR\|(2), \fIfork\fR\|(2), \fIclosedir\fR\|(2), etc.) return
true when they succeed n' \f(CW\*(C`undef\*(C'\fR otherwise, as is probably mentioned
in tha descriptions below.  This is different from tha C intercourses,
which return \f(CW\*(C`\-1\*(C'\fR on failure.  Exceptions ta dis rule include \f(CW\*(C`wait\*(C'\fR,
\&\f(CW\*(C`waitpid\*(C'\fR, n' \f(CW\*(C`syscall\*(C'\fR.  System calls also set tha special \f(CW$!\fR
variable on failure.  Other functions do not, except accidentally.
.PP
Extension modulez can also hook tha fuck into tha Perl parser ta define new
kindz of keyword-headed expression. I aint talkin' bout chicken n' gravy biatch.  These may be lookin like functions yo, but
may also look straight-up different.  Da syntax followin tha keyword
is defined entirely by tha extension. I aint talkin' bout chicken n' gravy biatch.  If yo ass be a implementor, see
\&\*(L"PL_keyword_plugin\*(R" up in perlapi fo' tha mechanism.  If yo ass is rockin such
a module, peep tha modulez documentation fo' detailz of tha syntax that
it defines.
.SS "Perl Functions by Category"
.IX Xref "function"
.IX Subsection "Perl Functions by Category"
Here is Perlz functions (includin thangs dat look like
functions, like some keywordz n' named operators)
arranged by category.  Some functions step tha fuck up in more
than one place.
.IP "Functions fo' SCALARs or strings" 4
.IX Xref "scalar strang character"
.IX Item "Functions fo' SCALARs or strings"
\&\f(CW\*(C`chomp\*(C'\fR, \f(CW\*(C`chop\*(C'\fR, \f(CW\*(C`chr\*(C'\fR, \f(CW\*(C`crypt\*(C'\fR, \f(CW\*(C`fc\*(C'\fR, \f(CW\*(C`hex\*(C'\fR, \f(CW\*(C`index\*(C'\fR, \f(CW\*(C`lc\*(C'\fR,
\&\f(CW\*(C`lcfirst\*(C'\fR, \f(CW\*(C`length\*(C'\fR, \f(CW\*(C`oct\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`q//\*(C'\fR, \f(CW\*(C`qq//\*(C'\fR, \f(CW\*(C`reverse\*(C'\fR,
\&\f(CW\*(C`rindex\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`substr\*(C'\fR, \f(CW\*(C`tr///\*(C'\fR, \f(CW\*(C`uc\*(C'\fR, \f(CW\*(C`ucfirst\*(C'\fR, \f(CW\*(C`y///\*(C'\fR
.Sp
\&\f(CW\*(C`fc\*(C'\fR be available only if tha \f(CW"fc"\fR feature is enabled or if it is
prefixed wit \f(CW\*(C`CORE::\*(C'\fR.  Da \f(CW"fc"\fR feature is enabled automatically
with a \f(CW\*(C`use v5.16\*(C'\fR (or higher) declaration up in tha current scope.
.IP "Regular expressions n' pattern matching" 4
.IX Xref "regular expression regex regexp"
.IX Item "Regular expressions n' pattern matching"
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`pos\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR, \f(CW\*(C`quotemeta\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`split\*(C'\fR, \f(CW\*(C`study\*(C'\fR
.IP "Numeric functions" 4
.IX Xref "numeric number trigonometric trigonometry"
.IX Item "Numeric functions"
\&\f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`atan2\*(C'\fR, \f(CW\*(C`cos\*(C'\fR, \f(CW\*(C`exp\*(C'\fR, \f(CW\*(C`hex\*(C'\fR, \f(CW\*(C`int\*(C'\fR, \f(CW\*(C`log\*(C'\fR, \f(CW\*(C`oct\*(C'\fR, \f(CW\*(C`rand\*(C'\fR,
\&\f(CW\*(C`sin\*(C'\fR, \f(CW\*(C`sqrt\*(C'\fR, \f(CW\*(C`srand\*(C'\fR
.ie n .IP "Functions fo' real @ARRAYs" 4
.el .IP "Functions fo' real \f(CW@ARRAYs\fR" 4
.IX Xref "array"
.IX Item "Functions fo' real @ARRAYs"
\&\f(CW\*(C`each\*(C'\fR, \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`splice\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, \f(CW\*(C`values\*(C'\fR
.IP "Functions fo' list data" 4
.IX Xref "list"
.IX Item "Functions fo' list data"
\&\f(CW\*(C`grep\*(C'\fR, \f(CW\*(C`join\*(C'\fR, \f(CW\*(C`map\*(C'\fR, \f(CW\*(C`qw//\*(C'\fR, \f(CW\*(C`reverse\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR
.ie n .IP "Functions fo' real %HASHes" 4
.el .IP "Functions fo' real \f(CW%HASHes\fR" 4
.IX Xref "hash"
.IX Item "Functions fo' real %HASHes"
\&\f(CW\*(C`delete\*(C'\fR, \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`exists\*(C'\fR, \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR
.IP "Input n' output functions" 4
.IX Xref "I O input output dbm"
.IX Item "Input n' output functions"
\&\f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`close\*(C'\fR, \f(CW\*(C`closedir\*(C'\fR, \f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`eof\*(C'\fR,
\&\f(CW\*(C`fileno\*(C'\fR, \f(CW\*(C`flock\*(C'\fR, \f(CW\*(C`format\*(C'\fR, \f(CW\*(C`getc\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`read\*(C'\fR,
\&\f(CW\*(C`readdir\*(C'\fR, \f(CW\*(C`readline\*(C'\fR \f(CW\*(C`rewinddir\*(C'\fR, \f(CW\*(C`say\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`seekdir\*(C'\fR, \f(CW\*(C`select\*(C'\fR,
\&\f(CW\*(C`syscall\*(C'\fR, \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysseek\*(C'\fR, \f(CW\*(C`syswrite\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, \f(CW\*(C`telldir\*(C'\fR,
\&\f(CW\*(C`truncate\*(C'\fR, \f(CW\*(C`warn\*(C'\fR, \f(CW\*(C`write\*(C'\fR
.Sp
\&\f(CW\*(C`say\*(C'\fR be available only if tha \f(CW"say"\fR feature is enabled or if it is
prefixed wit \f(CW\*(C`CORE::\*(C'\fR.  Da \f(CW"say"\fR feature is enabled automatically
with a \f(CW\*(C`use v5.10\*(C'\fR (or higher) declaration up in tha current scope.
.IP "Functions fo' fixed-length data or records" 4
.IX Item "Functions fo' fixed-length data or records"
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`syscall\*(C'\fR, \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysseek\*(C'\fR, \f(CW\*(C`syswrite\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR,
\&\f(CW\*(C`vec\*(C'\fR
.IP "Functions fo' filehandles, files, or directories" 4
.IX Xref "file filehandle directory pipe link symlink"
.IX Item "Functions fo' filehandles, files, or directories"
\&\f(CW\*(C`\-\f(CIX\f(CW\*(C'\fR, \f(CW\*(C`chdir\*(C'\fR, \f(CW\*(C`chmod\*(C'\fR, \f(CW\*(C`chown\*(C'\fR, \f(CW\*(C`chroot\*(C'\fR, \f(CW\*(C`fcntl\*(C'\fR, \f(CW\*(C`glob\*(C'\fR,
\&\f(CW\*(C`ioctl\*(C'\fR, \f(CW\*(C`link\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, \f(CW\*(C`mkdir\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`opendir\*(C'\fR,
\&\f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`rmdir\*(C'\fR, \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR,
\&\f(CW\*(C`umask\*(C'\fR, \f(CW\*(C`unlink\*(C'\fR, \f(CW\*(C`utime\*(C'\fR
.IP "Keywordz related ta tha control flow of yo' Perl program" 4
.IX Xref "control flow"
.IX Item "Keywordz related ta tha control flow of yo' Perl program"
\&\f(CW\*(C`break\*(C'\fR, \f(CW\*(C`caller\*(C'\fR, \f(CW\*(C`continue\*(C'\fR, \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`do\*(C'\fR,
\&\f(CW\*(C`dump\*(C'\fR, \f(CW\*(C`eval\*(C'\fR, \f(CW\*(C`evalbytes\*(C'\fR \f(CW\*(C`exit\*(C'\fR,
\&\f(CW\*(C`_\|_FILE_\|_\*(C'\fR, \f(CW\*(C`goto\*(C'\fR, \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`_\|_LINE_\|_\*(C'\fR, \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR,
\&\f(CW\*(C`redo\*(C'\fR, \f(CW\*(C`return\*(C'\fR, \f(CW\*(C`sub\*(C'\fR, \f(CW\*(C`_\|_SUB_\|_\*(C'\fR, \f(CW\*(C`wantarray\*(C'\fR
.Sp
\&\f(CW\*(C`break\*(C'\fR be available only if you enable tha experimenstrual \f(CW"switch"\fR
feature or use tha \f(CW\*(C`CORE::\*(C'\fR prefix. Da \f(CW"switch"\fR feature also enables
the \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`given\*(C'\fR n' \f(CW\*(C`when\*(C'\fR statements, which is documented in
\&\*(L"Switch Statements\*(R" up in perlsyn. I aint talkin' bout chicken n' gravy biatch. Da \f(CW"switch"\fR feature is enabled
automatically wit a \f(CW\*(C`use v5.10\*(C'\fR (or higher) declaration up in tha current
scope. In Perl v5.14 n' earlier, \f(CW\*(C`continue\*(C'\fR required tha \f(CW"switch"\fR
feature, like tha other keywords.
.Sp
\&\f(CW\*(C`evalbytes\*(C'\fR is only available wit tha \f(CW"evalbytes"\fR feature (see
feature) or if prefixed wit \f(CW\*(C`CORE::\*(C'\fR.  \f(CW\*(C`_\|_SUB_\|_\*(C'\fR is only available
with tha \f(CW"current_sub"\fR feature or if prefixed wit \f(CW\*(C`CORE::\*(C'\fR. Both
the \f(CW"evalbytes"\fR n' \f(CW"current_sub"\fR features is enabled automatically
with a \f(CW\*(C`use v5.16\*(C'\fR (or higher) declaration up in tha current scope.
.IP "Keywordz related ta scoping" 4
.IX Item "Keywordz related ta scoping"
\&\f(CW\*(C`caller\*(C'\fR, \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`local\*(C'\fR, \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`our\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`state\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.Sp
\&\f(CW\*(C`state\*(C'\fR be available only if tha \f(CW"state"\fR feature is enabled or if it is
prefixed wit \f(CW\*(C`CORE::\*(C'\fR.  Da \f(CW"state"\fR feature is enabled automatically
with a \f(CW\*(C`use v5.10\*(C'\fR (or higher) declaration up in tha current scope.
.IP "Miscellaneous functions" 4
.IX Item "Miscellaneous functions"
\&\f(CW\*(C`defined\*(C'\fR, \f(CW\*(C`formline\*(C'\fR, \f(CW\*(C`lock\*(C'\fR, \f(CW\*(C`prototype\*(C'\fR, \f(CW\*(C`reset\*(C'\fR, \f(CW\*(C`scalar\*(C'\fR, \f(CW\*(C`undef\*(C'\fR
.IP "Functions fo' processes n' process groups" 4
.IX Xref "process pid process id"
.IX Item "Functions fo' processes n' process groups"
\&\f(CW\*(C`alarm\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`getpgrp\*(C'\fR, \f(CW\*(C`getppid\*(C'\fR, \f(CW\*(C`getpriority\*(C'\fR, \f(CW\*(C`kill\*(C'\fR,
\&\f(CW\*(C`pipe\*(C'\fR, \f(CW\*(C`qx//\*(C'\fR, \f(CW\*(C`readpipe\*(C'\fR, \f(CW\*(C`setpgrp\*(C'\fR,
\&\f(CW\*(C`setpriority\*(C'\fR, \f(CW\*(C`sleep\*(C'\fR, \f(CW\*(C`system\*(C'\fR,
\&\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`wait\*(C'\fR, \f(CW\*(C`waitpid\*(C'\fR
.IP "Keywordz related ta Perl modules" 4
.IX Xref "module"
.IX Item "Keywordz related ta Perl modules"
\&\f(CW\*(C`do\*(C'\fR, \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`require\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.IP "Keywordz related ta classes n' object-orientation" 4
.IX Xref "object class package"
.IX Item "Keywordz related ta classes n' object-orientation"
\&\f(CW\*(C`bless\*(C'\fR, \f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`package\*(C'\fR, \f(CW\*(C`ref\*(C'\fR, \f(CW\*(C`tie\*(C'\fR, \f(CW\*(C`tied\*(C'\fR,
\&\f(CW\*(C`untie\*(C'\fR, \f(CW\*(C`use\*(C'\fR
.IP "Low-level socket functions" 4
.IX Xref "socket sock"
.IX Item "Low-level socket functions"
\&\f(CW\*(C`accept\*(C'\fR, \f(CW\*(C`bind\*(C'\fR, \f(CW\*(C`connect\*(C'\fR, \f(CW\*(C`getpeername\*(C'\fR, \f(CW\*(C`getsockname\*(C'\fR,
\&\f(CW\*(C`getsockopt\*(C'\fR, \f(CW\*(C`listen\*(C'\fR, \f(CW\*(C`recv\*(C'\fR, \f(CW\*(C`send\*(C'\fR, \f(CW\*(C`setsockopt\*(C'\fR, \f(CW\*(C`shutdown\*(C'\fR,
\&\f(CW\*(C`socket\*(C'\fR, \f(CW\*(C`socketpair\*(C'\fR
.IP "System V interprocess communication functions" 4
.IX Xref "IPC System V semaphore shared memory memory message"
.IX Item "System V interprocess communication functions"
\&\f(CW\*(C`msgctl\*(C'\fR, \f(CW\*(C`msgget\*(C'\fR, \f(CW\*(C`msgrcv\*(C'\fR, \f(CW\*(C`msgsnd\*(C'\fR, \f(CW\*(C`semctl\*(C'\fR, \f(CW\*(C`semget\*(C'\fR, \f(CW\*(C`semop\*(C'\fR,
\&\f(CW\*(C`shmctl\*(C'\fR, \f(CW\*(C`shmget\*(C'\fR, \f(CW\*(C`shmread\*(C'\fR, \f(CW\*(C`shmwrite\*(C'\fR
.IP "Fetchin user n' crew info" 4
.IX Xref "user crew password uid gid passwd etc passwd"
.IX Item "Fetchin user n' crew info"
\&\f(CW\*(C`endgrent\*(C'\fR, \f(CW\*(C`endhostent\*(C'\fR, \f(CW\*(C`endnetent\*(C'\fR, \f(CW\*(C`endpwent\*(C'\fR, \f(CW\*(C`getgrent\*(C'\fR,
\&\f(CW\*(C`getgrgid\*(C'\fR, \f(CW\*(C`getgrnam\*(C'\fR, \f(CW\*(C`getlogin\*(C'\fR, \f(CW\*(C`getpwent\*(C'\fR, \f(CW\*(C`getpwnam\*(C'\fR,
\&\f(CW\*(C`getpwuid\*(C'\fR, \f(CW\*(C`setgrent\*(C'\fR, \f(CW\*(C`setpwent\*(C'\fR
.IP "Fetchin network info" 4
.IX Xref "network protocol host hostname IP address service"
.IX Item "Fetchin network info"
\&\f(CW\*(C`endprotoent\*(C'\fR, \f(CW\*(C`endservent\*(C'\fR, \f(CW\*(C`gethostbyaddr\*(C'\fR, \f(CW\*(C`gethostbyname\*(C'\fR,
\&\f(CW\*(C`gethostent\*(C'\fR, \f(CW\*(C`getnetbyaddr\*(C'\fR, \f(CW\*(C`getnetbyname\*(C'\fR, \f(CW\*(C`getnetent\*(C'\fR,
\&\f(CW\*(C`getprotobyname\*(C'\fR, \f(CW\*(C`getprotobynumber\*(C'\fR, \f(CW\*(C`getprotoent\*(C'\fR,
\&\f(CW\*(C`getservbyname\*(C'\fR, \f(CW\*(C`getservbyport\*(C'\fR, \f(CW\*(C`getservent\*(C'\fR, \f(CW\*(C`sethostent\*(C'\fR,
\&\f(CW\*(C`setnetent\*(C'\fR, \f(CW\*(C`setprotoent\*(C'\fR, \f(CW\*(C`setservent\*(C'\fR
.IP "Time-related functions" 4
.IX Xref "time date"
.IX Item "Time-related functions"
\&\f(CW\*(C`gmtime\*(C'\fR, \f(CW\*(C`localtime\*(C'\fR, \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`times\*(C'\fR
.IP "Non-function keywords" 4
.IX Item "Non-function keywords"
\&\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`AUTOLOAD\*(C'\fR, \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`CORE\*(C'\fR, \f(CW\*(C`_\|_DATA_\|_\*(C'\fR,
\&\f(CW\*(C`default\*(C'\fR, \f(CW\*(C`DESTROY\*(C'\fR, \f(CW\*(C`else\*(C'\fR, \f(CW\*(C`elseif\*(C'\fR, \f(CW\*(C`elsif\*(C'\fR, \f(CW\*(C`END\*(C'\fR, \f(CW\*(C`_\|_END_\|_\*(C'\fR,
\&\f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`for\*(C'\fR, \f(CW\*(C`foreach\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`given\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, \f(CW\*(C`le\*(C'\fR,
\&\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`not\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`unless\*(C'\fR, \f(CW\*(C`until\*(C'\fR, \f(CW\*(C`when\*(C'\fR,
\&\f(CW\*(C`while\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`xor\*(C'\fR
.SS "Portability"
.IX Xref "portabilitizzle Unix portable"
.IX Subsection "Portability"
Perl started doin thangs up in Unix n' can therefore access all common Unix
system calls.  In non-Unix environments, tha functionalitizzle of some
Unix system calls may not be available or detailz of tha available
functionalitizzle may differ slightly.  Da Perl functions affected
by dis are:
.PP
\&\f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`chmod\*(C'\fR, \f(CW\*(C`chown\*(C'\fR, \f(CW\*(C`chroot\*(C'\fR, \f(CW\*(C`crypt\*(C'\fR,
\&\f(CW\*(C`dbmclose\*(C'\fR, \f(CW\*(C`dbmopen\*(C'\fR, \f(CW\*(C`dump\*(C'\fR, \f(CW\*(C`endgrent\*(C'\fR, \f(CW\*(C`endhostent\*(C'\fR,
\&\f(CW\*(C`endnetent\*(C'\fR, \f(CW\*(C`endprotoent\*(C'\fR, \f(CW\*(C`endpwent\*(C'\fR, \f(CW\*(C`endservent\*(C'\fR, \f(CW\*(C`exec\*(C'\fR,
\&\f(CW\*(C`fcntl\*(C'\fR, \f(CW\*(C`flock\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`getgrent\*(C'\fR, \f(CW\*(C`getgrgid\*(C'\fR, \f(CW\*(C`gethostbyname\*(C'\fR,
\&\f(CW\*(C`gethostent\*(C'\fR, \f(CW\*(C`getlogin\*(C'\fR, \f(CW\*(C`getnetbyaddr\*(C'\fR, \f(CW\*(C`getnetbyname\*(C'\fR, \f(CW\*(C`getnetent\*(C'\fR,
\&\f(CW\*(C`getppid\*(C'\fR, \f(CW\*(C`getpgrp\*(C'\fR, \f(CW\*(C`getpriority\*(C'\fR, \f(CW\*(C`getprotobynumber\*(C'\fR,
\&\f(CW\*(C`getprotoent\*(C'\fR, \f(CW\*(C`getpwent\*(C'\fR, \f(CW\*(C`getpwnam\*(C'\fR, \f(CW\*(C`getpwuid\*(C'\fR,
\&\f(CW\*(C`getservbyport\*(C'\fR, \f(CW\*(C`getservent\*(C'\fR, \f(CW\*(C`getsockopt\*(C'\fR, \f(CW\*(C`glob\*(C'\fR, \f(CW\*(C`ioctl\*(C'\fR,
\&\f(CW\*(C`kill\*(C'\fR, \f(CW\*(C`link\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, \f(CW\*(C`msgctl\*(C'\fR, \f(CW\*(C`msgget\*(C'\fR, \f(CW\*(C`msgrcv\*(C'\fR,
\&\f(CW\*(C`msgsnd\*(C'\fR, \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`rename\*(C'\fR, \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`semctl\*(C'\fR,
\&\f(CW\*(C`semget\*(C'\fR, \f(CW\*(C`semop\*(C'\fR, \f(CW\*(C`setgrent\*(C'\fR, \f(CW\*(C`sethostent\*(C'\fR, \f(CW\*(C`setnetent\*(C'\fR,
\&\f(CW\*(C`setpgrp\*(C'\fR, \f(CW\*(C`setpriority\*(C'\fR, \f(CW\*(C`setprotoent\*(C'\fR, \f(CW\*(C`setpwent\*(C'\fR,
\&\f(CW\*(C`setservent\*(C'\fR, \f(CW\*(C`setsockopt\*(C'\fR, \f(CW\*(C`shmctl\*(C'\fR, \f(CW\*(C`shmget\*(C'\fR, \f(CW\*(C`shmread\*(C'\fR,
\&\f(CW\*(C`shmwrite\*(C'\fR, \f(CW\*(C`socket\*(C'\fR, \f(CW\*(C`socketpair\*(C'\fR,
\&\f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`syscall\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \f(CW\*(C`system\*(C'\fR,
\&\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`truncate\*(C'\fR, \f(CW\*(C`umask\*(C'\fR, \f(CW\*(C`unlink\*(C'\fR,
\&\f(CW\*(C`utime\*(C'\fR, \f(CW\*(C`wait\*(C'\fR, \f(CW\*(C`waitpid\*(C'\fR
.PP
For mo' shiznit bout tha portabilitizzle of these functions, see
perlport n' other available platform-specific documentation.
.SS "Alphabetical Listin of Perl Functions"
.IX Subsection "Alphabetical Listin of Perl Functions"
.IP "\-X \s-1FILEHANDLE \s0" 4
.IX Xref "-r -w -x -o -R -W -X -O -e -z -s -f -d -l -p -S -b -c -t -u -g -k -T -B -M -A -C"
.IX Item "-X FILEHANDLE "
.PD 0
.IP "\-X \s-1EXPR\s0" 4
.IX Item "-X EXPR"
.IP "\-X \s-1DIRHANDLE\s0" 4
.IX Item "-X DIRHANDLE"
.IP "\-X" 4
.IX Item "-X"
.PD
A file test, where X is one of tha lettas listed below.  This unary
operator takes one argument, either a gangbangin' filename, a gangbangin' filehandle, or a gangbangin' finger-lickin' dirhandle, 
and tests tha associated file ta peep if suttin' is legit bout dat shit.  If the
argument is omitted, tests \f(CW$_\fR, except fo' \f(CW\*(C`\-t\*(C'\fR, which tests \s-1STDIN.\s0
Unless otherwise documented, it returns \f(CW1\fR fo' legit n' \f(CW\*(Aq\*(Aq\fR fo' false, or
the undefined value if tha file don't exist.  Despite tha funky
names, precedence is tha same ol' dirty as any other named unary operator. Shiiit, dis aint no joke.  The
operator may be any of:
.Sp
.Vb 4
\&    \-r  File is readable by effectizzle uid/gid.
\&    \-w  File is writable by effectizzle uid/gid.
\&    \-x  File is executable by effectizzle uid/gid.
\&    \-o  File is owned by effectizzle uid.
\&
\&    \-R  File is readable by real uid/gid.
\&    \-W  File is writable by real uid/gid.
\&    \-X  File is executable by real uid/gid.
\&    \-O  File is owned by real uid.
\&
\&    \-e  File exists.
\&    \-z  File has zero size (is empty).
\&    \-s  File has nonzero size (returns size up in bytes).
\&
\&    \-f  File be a plain file.
\&    \-d  File be a gangbangin' finger-lickin' directory.
\&    \-l  File be a symbolic link.
\&    \-p  File be a named pipe (FIFO), or Filehandle be a pipe.
\&    \-S  File be a socket.
\&    \-b  File be a funky-ass block special file.
\&    \-c  File be a cold-ass lil characta special file.
\&    \-t  Filehandle is opened ta a tty.
\&
\&    \-u  File has setuid bit set.
\&    \-g  File has setgid bit set.
\&    \-k  File has sticky bit set.
\&
\&    \-T  File be a ASCII text file (heuristic guess).
\&    \-B  File be a "binary" file (opposite of \-T).
\&
\&    \-M  Script start time minus file modification time, up in days.
\&    \-A  Same fo' access time.
\&    \-C  Same fo' inode chizzle time (Unix, may differ fo' other
\&        platforms)
.Ve
.Sp
Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chomp;
\&        next unless \-f $_;  # ignore specials
\&        #...
\&    }
.Ve
.Sp
Note dat \f(CW\*(C`\-s/a/b/\*(C'\fR do not do a negated substitution. I aint talkin' bout chicken n' gravy biatch.  Saying
\&\f(CW\*(C`\-exp($foo)\*(C'\fR still works as expected, however: only single letters
followin a minus is interpreted as file tests.
.Sp
These operators is exempt from tha \*(L"looks like a gangbangin' function rule\*(R" busted lyrics about
above.  That is, a openin parenthesis afta tha operator do not affect
how much of tha followin code constitutes tha argument.  Put tha opening
parentheses before tha operator ta separate it from code dat bigs up (this
applies only ta operators wit higher precedence than unary operators, of
course):
.Sp
.Vb 2
\&    \-s($file) + 1024   # probably wrong; same as \-s($file + 1024)
\&    (\-s $file) + 1024  # erect
.Ve
.Sp
Da interpretation of tha file permission operators \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-R\*(C'\fR,
\&\f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, n' \f(CW\*(C`\-X\*(C'\fR is by default based solely on tha mode
of tha file n' tha uidz n' gidz of tha user n' shit.  There may be other
reasons you can't straight-up read, write, or execute tha file: for
example network filesystem access controls, ACLs (access control lists),
read-only filesystems, n' unrecognized executable formats, n' you can put dat on yo' toast.  Note
that tha use of these six specific operators ta verify if some operation
is possible is probably a mistake, cuz it may be open ta race
conditions.
.Sp
Also note that, fo' tha superuser on tha local filesystems, tha \f(CW\*(C`\-r\*(C'\fR,
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, n' \f(CW\*(C`\-W\*(C'\fR tests always return 1, n' \f(CW\*(C`\-x\*(C'\fR n' \f(CW\*(C`\-X\*(C'\fR return 1
if any execute bit is set up in tha mode.  Scripts run by tha superuser
may thus need ta do a \fIstat()\fR ta determine tha actual mode of tha file,
or temporarily set they effectizzle uid ta suttin' else.
.Sp
If yo ass is rockin ACLs, there be a pragma called \f(CW\*(C`filetest\*(C'\fR dat may
produce mo' accurate thangs up in dis biatch than tha bare \fIstat()\fR mode bits.
When under \f(CW\*(C`use filetest \*(Aqaccess\*(Aq\*(C'\fR tha above-mentioned filetests
test whether tha permission can(not) be granted rockin the
\&\fIaccess\fR\|(2) crew of system calls.  Also note dat tha \f(CW\*(C`\-x\*(C'\fR n' \f(CW\*(C`\-X\*(C'\fR may
under dis pragma return legit even if there be no execute permission
bits set (nor any extra execute permission ACLs).  This strangenizz is
due ta tha underlyin system calls' definitions.  Note also that, due to
the implementation of \f(CW\*(C`use filetest \*(Aqaccess\*(Aq\*(C'\fR, tha \f(CW\*(C`_\*(C'\fR special
filehandle won't cache tha thangs up in dis biatch of tha file tests when dis pragma is
in effect.  Read tha documentation fo' tha \f(CW\*(C`filetest\*(C'\fR pragma fo' more
information.
.Sp
Da \f(CW\*(C`\-T\*(C'\fR n' \f(CW\*(C`\-B\*(C'\fR switches work as bigs up.  Da first block or so of the
file is examined fo' odd charactas like fuckin strange control codes or
charactas wit tha high bit set.  If too nuff strange charactas (>30%)
are found, itz a \f(CW\*(C`\-B\*(C'\fR file; otherwise itz a \f(CW\*(C`\-T\*(C'\fR file.  Also, any file
containin a zero byte up in tha straight-up original gangsta block is considered a funky-ass binary file.  If \f(CW\*(C`\-T\*(C'\fR
or \f(CW\*(C`\-B\*(C'\fR is used on a gangbangin' filehandle, tha current \s-1IO\s0 buffer is examined
rather than tha straight-up original gangsta block.  Both \f(CW\*(C`\-T\*(C'\fR n' \f(CW\*(C`\-B\*(C'\fR return legit on a empty
file, or a gangbangin' file at \s-1EOF\s0 when testin a gangbangin' filehandle.  Because you have to
read a gangbangin' file ta do tha \f(CW\*(C`\-T\*(C'\fR test, on most occasions you wanna bust a \f(CW\*(C`\-f\*(C'\fR
against tha file first, as up in \f(CW\*(C`next unless \-f $file && \-T $file\*(C'\fR.
.Sp
If any of tha file tests (or either tha \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR operator) is given
the special filehandle consistin of a solitary underline, then tha stat
structure of tha previous file test (or stat operator) is used, saving
a system call.  (This don't work wit \f(CW\*(C`\-t\*(C'\fR, n' you need ta remember
that \fIlstat()\fR n' \f(CW\*(C`\-l\*(C'\fR leave joints up in tha stat structure fo' the
symbolic link, not tha real file.)  (Also, if tha stat buffer was filled by
an \f(CW\*(C`lstat\*(C'\fR call, \f(CW\*(C`\-T\*(C'\fR n' \f(CW\*(C`\-B\*(C'\fR will reset it wit tha thangs up in dis biatch of \f(CW\*(C`stat _\*(C'\fR).
Example:
.Sp
.Vb 1
\&    print "Can do.\en" if \-r $a || \-w _ || \-x _;
\&
\&    stat($filename);
\&    print "Readable\en" if \-r _;
\&    print "Writable\en" if \-w _;
\&    print "Executable\en" if \-x _;
\&    print "Setuid\en" if \-u _;
\&    print "Setgid\en" if \-g _;
\&    print "Sticky\en" if \-k _;
\&    print "Text\en" if \-T _;
\&    print "Binary\en" if \-B _;
.Ve
.Sp
Az of Perl 5.10.0, as a gangbangin' form of purely syntactic sugar, you can stack file
test operators, up in a way dat \f(CW\*(C`\-f \-w \-x $file\*(C'\fR is equivalent to
\&\f(CW\*(C`\-x $file && \-w _ && \-f _\*(C'\fR.  (This is only fancy fancy: if you use
the return value of \f(CW\*(C`\-f $file\*(C'\fR as a argument ta another filetest
operator, no special magic will happen.)
.Sp
Portabilitizzle issues: \*(L"\-X\*(R" up in perlport.
.Sp
To avoid confusin would-be playaz of yo' code wit mysterious
syntax errors, put suttin' like dis all up in tha top of yo' script:
.Sp
.Vb 1
\&    use 5.010;  # so filetest ops can stack
.Ve
.IP "abs \s-1VALUE \s0" 4
.IX Xref "abs absolute"
.IX Item "abs VALUE "
.PD 0
.IP "abs" 4
.IX Item "abs"
.PD
Returns tha absolute value of its argument.
If \s-1VALUE\s0 is omitted, uses \f(CW$_\fR.
.IP "accept \s-1NEWSOCKET,GENERICSOCKET \s0" 4
.IX Xref "accept"
.IX Item "accept NEWSOCKET,GENERICSOCKET "
Accepts a incomin socket connect, just as \fIaccept\fR\|(2) 
does.  Returns tha packed address if it succeeded, false otherwise.
See tha example up in \*(L"Sockets: Client/Server Communication\*(R" up in perlipc.
.Sp
On systems dat support a cold-ass lil close-on-exec flag on files, tha flag will
be set fo' tha newly opened file descriptor, as determined by the
value of $^F.  See \*(L"$^F\*(R" up in perlvar.
.IP "alarm \s-1SECONDS \s0" 4
.IX Xref "alarm SIGALRM timer"
.IX Item "alarm SECONDS "
.PD 0
.IP "alarm" 4
.IX Item "alarm"
.PD
Arranges ta git a \s-1SIGALRM\s0 served up ta dis process afta the
specified number of wallclock secondz has elapsed. Y'all KNOW dat shit, muthafucka!  If \s-1SECONDS\s0 is not
specified, tha value stored up in \f(CW$_\fR is used. Y'all KNOW dat shit, muthafucka!  (On some machines,
unfortunately, tha elapsed time may be up ta one second less or more
than you specified cuz of how tha fuck secondz is counted, n' process
schedulin may delay tha delivery of tha signal even further.)
.Sp
Only one timer may be countin at once.  Each call disablez the
previous timer, n' a argument of \f(CW0\fR may be supplied ta quit the
previous timer without startin a freshly smoked up one.  Da returned value is the
amount of time remainin on tha previous timer.
.Sp
For delayz of finer granularitizzle than one second, tha Time::HiRes module
(from \s-1CPAN,\s0 n' startin from Perl 5.8 part of tha standard
distribution) serves up \fIualarm()\fR.  Yo ass may also use Perlz four-argument
version of \fIselect()\fR leavin tha straight-up original gangsta three arguments undefined, or you
might be able ta use tha \f(CW\*(C`syscall\*(C'\fR intercourse ta access \fIsetitimer\fR\|(2) if
your system supports dat shit.  See perlfaq8 fo' details.
.Sp
It be probably a gangbangin' fuck up ta intermix \f(CW\*(C`alarm\*(C'\fR n' \f(CW\*(C`sleep\*(C'\fR calls, cuz
\&\f(CW\*(C`sleep\*(C'\fR may be internally implemented on yo' system wit \f(CW\*(C`alarm\*(C'\fR.
.Sp
If you wanna use \f(CW\*(C`alarm\*(C'\fR ta time up a system call you need ta use an
\&\f(CW\*(C`eval\*(C'\fR/\f(CW\*(C`die\*(C'\fR pair. Shiiit, dis aint no joke.  Yo ass can't rely on tha alarm causin tha system call to
fail wit \f(CW$!\fR set ta \f(CW\*(C`EINTR\*(C'\fR cuz Perl sets up signal handlezs to
restart system calls on some systems.  Usin \f(CW\*(C`eval\*(C'\fR/\f(CW\*(C`die\*(C'\fR always works,
modulo tha caveats given up in \*(L"Signals\*(R" up in perlipc.
.Sp
.Vb 10
\&    eval {
\&        local $SIG{ALRM} = sub { take a thugged-out dirtnap "alarm\en" }; # NB: \en required
\&        alarm $timeout;
\&        $nread = sysread SOCKET, $buffer, $size;
\&        alarm 0;
\&    };
\&    if ($@) {
\&        take a thugged-out dirtnap unless $@ eq "alarm\en";   # propagate unexpected errors
\&        # timed out
\&    }
\&    else {
\&        # didn\*(Aqt
\&    }
.Ve
.Sp
For mo' shiznit peep perlipc.
.Sp
Portabilitizzle issues: \*(L"alarm\*(R" up in perlport.
.IP "atan2 Y,X" 4
.IX Xref "atan2 arctangent tan tangent"
.IX Item "atan2 Y,X"
Returns tha arctangent of Y/X up in tha range \-PI ta \s-1PI.\s0
.Sp
For tha tangent operation, you may use tha \f(CW\*(C`Math::Trig::tan\*(C'\fR
function, or use tha familiar relation:
.Sp
.Vb 1
\&    sub tan { sin($_[0]) / cos($_[0])  }
.Ve
.Sp
Da return value fo' \f(CW\*(C`atan2(0,0)\*(C'\fR is implementation-defined; consult
your \fIatan2\fR\|(3) manpage fo' mo' shiznit.
.Sp
Portabilitizzle issues: \*(L"atan2\*(R" up in perlport.
.IP "bind \s-1SOCKET,NAME \s0" 4
.IX Xref "bind"
.IX Item "bind SOCKET,NAME "
Bindz a network address ta a socket, just as \fIbind\fR\|(2)
does.  Returns legit if it succeeded, false otherwise.  \s-1NAME\s0 should be a
packed address of tha appropriate type fo' tha socket.  See tha examplez in
\&\*(L"Sockets: Client/Server Communication\*(R" up in perlipc.
.IP "binmode \s-1FILEHANDLE, LAYER \s0" 4
.IX Xref "binmode binary text DOS Windows"
.IX Item "binmode FILEHANDLE, LAYER "
.PD 0
.IP "binmode \s-1FILEHANDLE\s0" 4
.IX Item "binmode FILEHANDLE"
.PD
Arranges fo' \s-1FILEHANDLE\s0 ta be read or freestyled up in \*(L"binary\*(R" or \*(L"text\*(R"
mode on systems where tha run-time libraries distinguish between
binary n' text files.  If \s-1FILEHANDLE\s0 be a expression, tha value is
taken as tha name of tha filehandle.  Returns legit on success,
otherwise it returns \f(CW\*(C`undef\*(C'\fR n' sets \f(CW$!\fR (errno).
.Sp
On some systems (in general, \s-1DOS\-\s0 n' Windows-based systems) \fIbinmode()\fR
is necessary when you not hustlin wit a text file.  For tha sake
of portabilitizzle it aint nuthin but a phat scam always ta use it when appropriate,
and never ta use it when it aint appropriate.  Also, playas can
set they I/O ta be by default UTF8\-encoded Unicode, not bytes.
.Sp
In other lyrics: regardless of platform, use \fIbinmode()\fR on binary data,
like images, fo' example.
.Sp
If \s-1LAYER\s0 is present it aint nuthin but a single strin yo, but may contain multiple
directives.  Da directives alta tha behaviour of tha filehandle.
When \s-1LAYER\s0 is present, rockin binmode on a text file make sense.
.Sp
If \s-1LAYER\s0 is omitted or specified as \f(CW\*(C`:raw\*(C'\fR tha filehandle is made
suitable fo' passin binary data.  This includes turnin off possible \s-1CRLF\s0
translation n' markin it as bytes (as opposed ta Unicode characters).
Note that, despite what tha fuck may be implied up in \fI\*(L"Programmin Perl\*(R"\fR (the
Camel, 3rd edition) or elsewhere, \f(CW\*(C`:raw\*(C'\fR is \fInot\fR simply tha inverse of \f(CW\*(C`:crlf\*(C'\fR.
Other layers dat would affect tha binary nature of tha stream are
\&\fIalso\fR disabled. Y'all KNOW dat shit, muthafucka!  See PerlIO, perlrun, n' tha rap bout the
\&\s-1PERLIO\s0 environment variable.
.Sp
Da \f(CW\*(C`:bytes\*(C'\fR, \f(CW\*(C`:crlf\*(C'\fR, \f(CW\*(C`:utf8\*(C'\fR, n' any other directivez of the
form \f(CW\*(C`:...\*(C'\fR, is called I/O \fIlayers\fR.  Da \f(CW\*(C`open\*(C'\fR pragma can be used to
establish default I/O layers.  See open.
.Sp
\&\fIDa \s-1LAYER\s0 parameta of tha \fIbinmode()\fI function is busted lyrics bout as \*(L"\s-1DISCIPLINE\*(R"\s0
in \*(L"Programmin Perl, 3rd Edition\*(R".  But fuck dat shiznit yo, tha word on tha street is dat since tha publishin of this
book, by nuff known as \*(L"Camel \s-1III\*(R",\s0 tha consensuz of tha namin of this
functionalitizzle has moved from \*(L"discipline\*(R" ta \*(L"layer\*(R".  All documentation
of dis version of Perl therefore refers ta \*(L"layers\*(R" rather than to
\&\*(L"disciplines\*(R".  Now back ta tha regularly scheduled documentation...\fR
.Sp
To mark \s-1FILEHANDLE\s0 as \s-1UTF\-8,\s0 use \f(CW\*(C`:utf8\*(C'\fR or \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR.
\&\f(CW\*(C`:utf8\*(C'\fR just marks tha data as \s-1UTF\-8\s0 without further checking,
while \f(CW\*(C`:encoding(UTF\-8)\*(C'\fR checks tha data fo' straight-up bein valid
\&\s-1UTF\-8. \s0 Mo' details can be found up in PerlIO::encoding.
.Sp
In general, \fIbinmode()\fR should be called afta \fIopen()\fR but before any I/O
is done on tha filehandle.  Callin \fIbinmode()\fR normally flushes any
pendin buffered output data (and like pendin input data) on the
handle.  An exception ta dis is tha \f(CW\*(C`:encoding\*(C'\fR layer that
changes tha default characta encodin of tha handle; peep \*(L"open\*(R".
Da \f(CW\*(C`:encoding\*(C'\fR layer sometimes need ta be called in
mid-stream, n' it don't flush tha stream.  Da \f(CW\*(C`:encoding\*(C'\fR
also implicitly pushes on top of itself tha \f(CW\*(C`:utf8\*(C'\fR layer cuz
internally Perl operates on UTF8\-encoded Unicode characters.
.Sp
Da operatin system, thang drivers, C libraries, n' Perl run-time
system all conspire ta let tha programmer treat a single
characta (\f(CW\*(C`\en\*(C'\fR) as tha line terminator, irrespectizzle of external
representation. I aint talkin' bout chicken n' gravy biatch.  On nuff operatin systems, tha natizzle text file
representation matches tha internal representation yo, but on some
platforms tha external representation of \f(CW\*(C`\en\*(C'\fR is made up of mo' than
one character.
.Sp
All variantz of Unix, Mac \s-1OS \s0(old n' new), n' Stream_LF filez on \s-1VMS\s0 use
a single characta ta end each line up in tha external representation of text
(even though dat single characta is \s-1CARRIAGE RETURN\s0 on old, pre-Darwin
flavorz of Mac \s-1OS,\s0 n' is \s-1LINE FEED\s0 on Unix n' most \s-1VMS\s0 files).  In other
systems like \s-1OS/2, DOS,\s0 n' tha various flavorz of MS-Windows, yo' program
sees a \f(CW\*(C`\en\*(C'\fR as a simple \f(CW\*(C`\ecJ\*(C'\fR yo, but whatz stored up in text filez is the
two charactas \f(CW\*(C`\ecM\ecJ\*(C'\fR.  That means dat if you don't use \fIbinmode()\fR on
these systems, \f(CW\*(C`\ecM\ecJ\*(C'\fR sequences on disk is ghon be converted ta \f(CW\*(C`\en\*(C'\fR on
input, n' any \f(CW\*(C`\en\*(C'\fR up in yo' program is ghon be converted back ta \f(CW\*(C`\ecM\ecJ\*(C'\fR on
output.  This is what tha fuck you want fo' text filez yo, but it can be disastrous for
binary files.
.Sp
Another consequence of rockin \fIbinmode()\fR (on some systems) is that
special end-of-file markers is ghon be peeped as part of tha data stream.
For systems from tha Microsizzlez crew dis means that, if yo' binary
data contain \f(CW\*(C`\ecZ\*(C'\fR, tha I/O subsystem will regard it as tha end of
the file, unless you use \fIbinmode()\fR.
.Sp
\&\fIbinmode()\fR is blingin not only fo' \fIreadline()\fR n' \fIprint()\fR operations,
but also when rockin \fIread()\fR, \fIseek()\fR, \fIsysread()\fR, \fIsyswrite()\fR n' \fItell()\fR
(see perlport fo' mo' details).  See tha \f(CW$/\fR n' \f(CW\*(C`$\e\*(C'\fR variables
in perlvar fo' how tha fuck ta manually set yo' input n' output
line-termination sequences.
.Sp
Portabilitizzle issues: \*(L"binmode\*(R" up in perlport.
.IP "bless \s-1REF,CLASSNAME \s0" 4
.IX Xref "bless"
.IX Item "bless REF,CLASSNAME "
.PD 0
.IP "bless \s-1REF\s0" 4
.IX Item "bless REF"
.PD
This function  drops some lyrics ta tha thangy referenced by \s-1REF\s0 dat it is now a object
in tha \s-1CLASSNAME\s0 package.  If \s-1CLASSNAME\s0 is omitted, tha current package
is used. Y'all KNOW dat shit, muthafucka!  Because a \f(CW\*(C`bless\*(C'\fR is often tha last thang up in a cold-ass lil constructor,
it returns tha reference fo' convenience.  Always use tha two-argument
version if a thugged-out derived class might inherit tha function bustin tha blessing.
See perlobj fo' mo' bout tha blessin (and blessings) of objects.
.Sp
Consider always blessin objects up in CLASSNAMEs dat is mixed case.
Namespaces wit all lowercase names is considered reserved for
Perl pragmata.  Builtin types have all uppercase names.  To prevent
confusion, you may wish ta avoid such package names as well.  Make sure
that \s-1CLASSNAME\s0 be a legit value.
.Sp
See \*(L"Perl Modules\*(R" up in perlmod.
.IP "break" 4
.IX Item "break"
Break outta a \f(CW\*(C`given()\*(C'\fR block.
.Sp
This keyword is enabled by tha \f(CW"switch"\fR feature; peep feature for
more shiznit on \f(CW"switch"\fR.  Yo ass can also access it by prefixin it
with \f(CW\*(C`CORE::\*(C'\fR.  Alternatively, include a \f(CW\*(C`use v5.10\*(C'\fR or lata ta the
current scope.
.IP "calla \s-1EXPR \s0" 4
.IX Xref "calla call stack stack stack trace"
.IX Item "calla EXPR "
.PD 0
.IP "caller" 4
.IX Item "caller"
.PD
Returns tha context of tha current subroutine call.  In scalar context,
returns tha callerz package name if there \fIis\fR a cold-ass lil calla (that is, if
we're up in a subroutine or \f(CW\*(C`eval\*(C'\fR or \f(CW\*(C`require\*(C'\fR) n' tha undefined value
otherwise.  In list context, returns
.Sp
.Vb 2
\&    # 0         1          2
\&    ($package, $filename, $line) = caller;
.Ve
.Sp
With \s-1EXPR,\s0 it returns some extra shiznit dat tha debugger uses to
print a stack trace.  Da value of \s-1EXPR\s0 indicates how tha fuck nuff call frames
to go back before tha current one.
.Sp
.Vb 2
\&    #  0         1          2      3            4
\&    ($package, $filename, $line, $subroutine, $hasargs,
\&
\&    #  5          6          7            8       9         10
\&    $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
\&     = caller($i);
.Ve
.Sp
Here \f(CW$subroutine\fR may be \f(CW\*(C`(eval)\*(C'\fR if tha frame aint a subroutine
call yo, but a \f(CW\*(C`eval\*(C'\fR.  In such a cold-ass lil case additionizzle elements \f(CW$evaltext\fR and
\&\f(CW$is_require\fR is set: \f(CW$is_require\fR is legit if tha frame is pimped by a
\&\f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR statement, \f(CW$evaltext\fR gotz nuff tha text of the
\&\f(CW\*(C`eval EXPR\*(C'\fR statement.  In particular, fo' a \f(CW\*(C`eval BLOCK\*(C'\fR statement,
\&\f(CW$subroutine\fR is \f(CW\*(C`(eval)\*(C'\fR yo, but \f(CW$evaltext\fR is undefined. Y'all KNOW dat shit, muthafucka!  (Note also that
each \f(CW\*(C`use\*(C'\fR statement creates a \f(CW\*(C`require\*(C'\fR frame inside a \f(CW\*(C`eval EXPR\*(C'\fR
frame.)  \f(CW$subroutine\fR may also be \f(CW\*(C`(unknown)\*(C'\fR if dis particular
subroutine happens ta done been deleted from tha symbol table.
\&\f(CW$hasargs\fR is legit if a freshly smoked up instizzle of \f(CW@_\fR was set up fo' tha frame.
\&\f(CW$hints\fR n' \f(CW$bitmask\fR contain pragmatic hints dat tha calla was
compiled with.  \f(CW$hints\fR correspondz ta \f(CW$^H\fR, n' \f(CW$bitmask\fR
correspondz ta \f(CW\*(C`${^WARNING_BITS}\*(C'\fR.  The
\&\f(CW$hints\fR n' \f(CW$bitmask\fR joints is subject
to chizzle between versionz of Perl, n' is not meant fo' external use.
.Sp
\&\f(CW$hinthash\fR be a reference ta a hash containin tha value of \f(CW\*(C`%^H\*(C'\fR when the
calla was compiled, or \f(CW\*(C`undef\*(C'\fR if \f(CW\*(C`%^H\*(C'\fR was empty.  Do not modify tha joints
of dis hash, as they is tha actual joints stored up in tha optree.
.Sp
Furthermore, when called from within tha \s-1DB\s0 package in
list context, n' wit a argument, calla returns more
detailed shiznit: it sets tha list variable \f(CW@DB::args\fR ta be the
arguments wit which tha subroutine was invoked.
.Sp
Be aware dat tha optimizer might have optimized call frames away before
\&\f(CW\*(C`caller\*(C'\fR had a cold-ass lil chizzle ta git tha shiznit. I aint talkin' bout chicken n' gravy biatch.  That means dat \f(CWcaller(N)\fR
might not return shiznit bout tha call frame you expect it to, for
\&\f(CW\*(C`N > 1\*(C'\fR.  In particular, \f(CW@DB::args\fR might have shiznit from the
previous time \f(CW\*(C`caller\*(C'\fR was called.
.Sp
Be aware dat settin \f(CW@DB::args\fR is \fIbest effort\fR, intended for
debuggin or generatin backtraces, n' should not be relied upon. I aint talkin' bout chicken n' gravy biatch.  In
particular, as \f(CW@_\fR gotz nuff aliases ta tha callerz arguments, Perl do
not take a cold-ass lil copy of \f(CW@_\fR, so \f(CW@DB::args\fR will contain modifications the
subroutine make ta \f(CW@_\fR or its contents, not tha original gangsta joints at call
time.  \f(CW@DB::args\fR, like \f(CW@_\fR, do not hold explicit references ta its
elements, so under certain cases its elements may have become freed and
reallocated fo' other variablez or temporary joints, n' you can put dat on yo' toast.  Finally, a side effect
of tha current implementation is dat tha effectz of \f(CW\*(C`shift @_\*(C'\fR can
\&\fInormally\fR be undone (but not \f(CW\*(C`pop @_\*(C'\fR or other splicing, \fIand\fR not if a
reference ta \f(CW@_\fR has been taken, \fIand\fR subject ta tha caveat bout reallocated
elements), so \f(CW@DB::args\fR is straight-up a hybrid of tha current state and
initial state of \f(CW@_\fR.  Buyer beware.
.IP "chdir \s-1EXPR \s0" 4
.IX Xref "chdir cd directory, chizzle"
.IX Item "chdir EXPR "
.PD 0
.IP "chdir \s-1FILEHANDLE\s0" 4
.IX Item "chdir FILEHANDLE"
.IP "chdir \s-1DIRHANDLE\s0" 4
.IX Item "chdir DIRHANDLE"
.IP "chdir" 4
.IX Item "chdir"
.PD
Changes tha hustlin directory ta \s-1EXPR,\s0 if possible.  If \s-1EXPR\s0 is omitted,
changes ta tha directory specified by \f(CW$ENV{HOME}\fR, if set; if not,
changes ta tha directory specified by \f(CW$ENV{LOGDIR}\fR.  (Under \s-1VMS,\s0 the
variable \f(CW$ENV{SYS$LOGIN}\fR be also checked, n' used if it is set.)  If
neither is set, \f(CW\*(C`chdir\*(C'\fR do nothing.  It returns legit on success,
false otherwise.  See tha example under \f(CW\*(C`die\*(C'\fR.
.Sp
On systems dat support \fIfchdir\fR\|(2), you may pass a gangbangin' filehandle or
directory handle as tha argument.  On systems dat don't support \fIfchdir\fR\|(2),
passin handlez raises a exception.
.IP "chmod \s-1LIST \s0" 4
.IX Xref "chmod permission mode"
.IX Item "chmod LIST "
Changes tha permissionz of a list of files.  Da first element of the
list must be tha numeric mode, which should probably be a octal
number, n' which definitely should \fInot\fR be a strang of octal digits:
\&\f(CW0644\fR be all gravy yo, but \f(CW"0644"\fR is not.  Returns tha number of files
successfully chizzled. Y'all KNOW dat shit, muthafucka!  See also \*(L"oct\*(R" if all you have be a string.
.Sp
.Vb 6
\&    $cnt = chmod 0755, "foo", "bar";
\&    chmod 0755, @executables;
\&    $mode = "0644"; chmod $mode, "foo";      # !!! sets mode to
\&                                             # \-\-w\-\-\-\-r\-T
\&    $mode = "0644"; chmod oct($mode), "foo"; # dis is better
\&    $mode = 0644;   chmod $mode, "foo";      # dis is best
.Ve
.Sp
On systems dat support \fIfchmod\fR\|(2), you may pass filehandlez among the
files.  On systems dat don't support \fIfchmod\fR\|(2), passin filehandlez raises
an exception. I aint talkin' bout chicken n' gravy biatch.  Filehandlez must be passed as globs or glob references ta be
recognized; barewordz is considered filenames.
.Sp
.Vb 3
\&    open(my $fh, "<", "foo");
\&    mah $perm = (stat $fh)[2] & 07777;
\&    chmod($perm | 0600, $fh);
.Ve
.Sp
Yo ass can also import tha symbolic \f(CW\*(C`S_I*\*(C'\fR constants from tha \f(CW\*(C`Fcntl\*(C'\fR
module:
.Sp
.Vb 3
\&    use Fcntl qw( :mode );
\&    chmod S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH, @executables;
\&    # Identical ta tha chmod 0755 of tha example above.
.Ve
.Sp
Portabilitizzle issues: \*(L"chmod\*(R" up in perlport.
.IP "chomp \s-1VARIABLE \s0" 4
.IX Xref "chomp INPUT_RECORD_SEPARATOR $ newline eol"
.IX Item "chomp VARIABLE "
.PD 0
.IP "chomp( \s-1LIST \s0)" 4
.IX Item "chomp( LIST )"
.IP "chomp" 4
.IX Item "chomp"
.PD
This less thuggy version of \*(L"chop\*(R" removes any trailin string
that correspondz ta tha current value of \f(CW$/\fR (also known as
\&\f(CW$INPUT_RECORD_SEPARATOR\fR up in tha \f(CW\*(C`English\*(C'\fR module).  It returns tha total
number of charactas removed from all its arguments, n' you can put dat on yo' toast.  It aint nuthin but often used to
remove tha newline from tha end of a input record when you worried
that tha final record may be missin its newline.  When up in paragraph
mode (\f(CW\*(C`$/ = ""\*(C'\fR), it removes all trailin newlines from tha string.
When up in slurp mode (\f(CW\*(C`$/ = undef\*(C'\fR) or fixed-length record mode (\f(CW$/\fR is
a reference ta a integer or tha like; peep perlvar) \fIchomp()\fR won't
remove anything.
If \s-1VARIABLE\s0 is omitted, it chomps \f(CW$_\fR.  Example:
.Sp
.Vb 5
\&    while (<>) {
\&        chomp;  # avoid \en on last field
\&        @array = split(/:/);
\&        # ...
\&    }
.Ve
.Sp
If \s-1VARIABLE\s0 be a hash, it chomps tha hashz joints yo, but not its keys.
.Sp
Yo ass can straight-up chomp anythang thatz a lvalue, includin a assignment:
.Sp
.Vb 2
\&    chomp($cwd = \`pwd\`);
\&    chomp($answer = <STDIN>);
.Ve
.Sp
If you chomp a list, each element is chomped, n' tha total number of
charactas removed is returned.
.Sp
Note dat parentheses is necessary when you chompin anything
that aint a simple variable.  This is cuz \f(CW\*(C`chomp $cwd = \`pwd\`;\*(C'\fR
is interpreted as \f(CW\*(C`(chomp $cwd) = \`pwd\`;\*(C'\fR, rather than as
\&\f(CW\*(C`chomp( $cwd = \`pwd\` )\*(C'\fR which you might expect.  Similarly,
\&\f(CW\*(C`chomp $a, $b\*(C'\fR is interpreted as \f(CW\*(C`chomp($a), $b\*(C'\fR rather than
as \f(CW\*(C`chomp($a, $b)\*(C'\fR.
.IP "chop \s-1VARIABLE \s0" 4
.IX Xref "chop"
.IX Item "chop VARIABLE "
.PD 0
.IP "chop( \s-1LIST \s0)" 4
.IX Item "chop( LIST )"
.IP "chop" 4
.IX Item "chop"
.PD
Chops off tha last characta of a strang n' returns tha character
chopped. Y'all KNOW dat shit, muthafucka!  It be much mo' efficient than \f(CW\*(C`s/.$//s\*(C'\fR cuz it neither
scans nor copies tha string.  If \s-1VARIABLE\s0 is omitted, chops \f(CW$_\fR.
If \s-1VARIABLE\s0 be a hash, it chops tha hashz joints yo, but not its keys.
.Sp
Yo ass can straight-up chop anythang thatz a lvalue, includin a assignment.
.Sp
If you chop a list, each element is chopped. Y'all KNOW dat shit, muthafucka!  Only tha value of the
last \f(CW\*(C`chop\*(C'\fR is returned.
.Sp
Note dat \f(CW\*(C`chop\*(C'\fR returns tha last character n' shit.  To return all but tha last
character, use \f(CW\*(C`substr($string, 0, \-1)\*(C'\fR.
.Sp
See also \*(L"chomp\*(R".
.IP "chown \s-1LIST \s0" 4
.IX Xref "chown balla user group"
.IX Item "chown LIST "
Changes tha balla (and group) of a list of files.  Da first two
elementz of tha list must be tha \fInumeric\fR uid n' gid, up in that
order n' shit.  A value of \-1 up in either posizzle is interpreted by most
systems ta leave dat value unchanged. Y'all KNOW dat shit, muthafucka!  Returns tha number of files
successfully chizzled.
.Sp
.Vb 2
\&    $cnt = chown $uid, $gid, \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq;
\&    chown $uid, $gid, @filenames;
.Ve
.Sp
On systems dat support \fIfchown\fR\|(2), you may pass filehandlez among the
files.  On systems dat don't support \fIfchown\fR\|(2), passin filehandlez raises
an exception. I aint talkin' bout chicken n' gravy biatch.  Filehandlez must be passed as globs or glob references ta be
recognized; barewordz is considered filenames.
.Sp
Herez a example dat looks up nonnumeric uidz up in tha passwd file:
.Sp
.Vb 4
\&    print "User: ";
\&    chomp($user = <STDIN>);
\&    print "Files: ";
\&    chomp($pattern = <STDIN>);
\&
\&    ($login,$pass,$uid,$gid) = getpwnam($user)
\&        or take a thugged-out dirtnap "$user not up in passwd file";
\&
\&    @ary = glob($pattern);  # expand filenames
\&    chown $uid, $gid, @ary;
.Ve
.Sp
On most systems, yo ass is not allowed ta chizzle tha ballershizzle of the
file unless you tha superuser, although you should be able ta chizzle
the crew ta any of yo' secondary groups.  On insecure systems, these
restrictions may be chillaxed yo, but dis aint a portable assumption.
On \s-1POSIX\s0 systems, you can detect dis condizzle dis way:
.Sp
.Vb 2
\&    use POSIX qw(sysconf _PC_CHOWN_RESTRICTED);
\&    $can_chown_giveaway = not sysconf(_PC_CHOWN_RESTRICTED);
.Ve
.Sp
Portabilitizzle issues: \*(L"chmod\*(R" up in perlport.
.IP "chr \s-1NUMBER \s0" 4
.IX Xref "chr characta ASCII Unicode"
.IX Item "chr NUMBER "
.PD 0
.IP "chr" 4
.IX Item "chr"
.PD
Returns tha characta represented by dat \s-1NUMBER\s0 up in tha characta set.
For example, \f(CW\*(C`chr(65)\*(C'\fR is \f(CW"A"\fR up in either \s-1ASCII\s0 or Unicode, and
chr(0x263a) be a Unicode smiley face.
.Sp
Negatizzle joints give tha Unicode replacement characta (\fIchr\fR\|(0xfffd)),
except under tha bytes pragma, where tha low eight bitz of tha value
(truncated ta a integer) is used.
.Sp
If \s-1NUMBER\s0 is omitted, uses \f(CW$_\fR.
.Sp
For tha reverse, use \*(L"ord\*(R".
.Sp
Note dat charactas from 128 ta 255 (inclusive) is by default
internally not encoded as \s-1UTF\-8\s0 fo' backward compatibilitizzle reasons.
.Sp
See perlunicode fo' mo' bout Unicode.
.IP "chroot \s-1FILENAME \s0" 4
.IX Xref "chroot root"
.IX Item "chroot FILENAME "
.PD 0
.IP "chroot" 4
.IX Item "chroot"
.PD
This function works like tha system call by tha same name: it make the
named directory tha freshly smoked up root directory fo' all further pathnames that
begin wit a \f(CW\*(C`/\*(C'\fR by yo' process n' all its lil' thugs.  (It don't
change yo' current hustlin directory, which is unaffected.)  For security
reasons, dis call is restricted ta tha superuser n' shit.  If \s-1FILENAME\s0 is
omitted, do a \f(CW\*(C`chroot\*(C'\fR ta \f(CW$_\fR.
.Sp
Portabilitizzle issues: \*(L"chroot\*(R" up in perlport.
.IP "close \s-1FILEHANDLE \s0" 4
.IX Xref "close"
.IX Item "close FILEHANDLE "
.PD 0
.IP "close" 4
.IX Item "close"
.PD
Closes tha file or pipe associated wit tha filehandle, flushes tha \s-1IO\s0
buffers, n' closes tha system file descriptor. Shiiit, dis aint no joke.  Returns legit if them
operations succeed n' if no error was reported by any PerlIO
layer n' shit.  Closes tha currently selected filehandle if tha argument is
omitted.
.Sp
Yo ass don't gotta close \s-1FILEHANDLE\s0 if yo ass is immediately goin ta do
another \f(CW\*(C`open\*(C'\fR on it, cuz \f(CW\*(C`open\*(C'\fR closes it fo' yo thugged-out ass.  (See
open.)  But fuck dat shiznit yo, tha word on tha street is dat a explicit \f(CW\*(C`close\*(C'\fR on a input file resets tha line
counta (\f(CW$.\fR), while tha implicit close done by \f(CW\*(C`open\*(C'\fR do not.
.Sp
If tha filehandle came from a piped open, \f(CW\*(C`close\*(C'\fR returns false if one of
the other syscalls involved fails or if its program exits wit non-zero
status.  If tha only problem was dat tha program exited non-zero, \f(CW$!\fR
will be set ta \f(CW0\fR.  Closin a pipe also waits fo' tha process executing
on tha pipe ta exit\*(--in case you wish ta peep tha output of tha pipe
afterwards\*(--and implicitly puts tha exit status value of dat command into
\&\f(CW$?\fR n' \f(CW\*(C`${^CHILD_ERROR_NATIVE}\*(C'\fR.
.Sp
If there be multiple threadz hustlin, \f(CW\*(C`close\*(C'\fR on a gangbangin' filehandle from a
piped open returns legit without waitin fo' tha lil pimp process ta terminate,
if tha filehandle is still open up in another thread.
.Sp
Closin tha read end of a pipe before tha process freestylin ta it at the
other end is done freestylin thangs up in dis biatch up in tha writa receivin a \s-1SIGPIPE. \s0 If
the other end can't handle that, be shizzle ta read all tha data before
closin tha pipe.
.Sp
Example:
.Sp
.Vb 8
\&    open(OUTPUT, \*(Aq|sort >foo\*(Aq)  # pipe ta sort
\&        or take a thugged-out dirtnap "Can\*(Aqt start sort: $!";
\&    #...                        # print shiznit ta output
\&    close OUTPUT                # wait fo' sort ta finish
\&        or warn $! , biatch? "Error closin sort pipe: $!"
\&                   : "Exit status $, biatch? from sort";
\&    open(INPUT, \*(Aqfoo\*(Aq)          # git sort\*(Aqs thangs up in dis biatch
\&        or take a thugged-out dirtnap "Can\*(Aqt open \*(Aqfoo\*(Aq fo' input: $!";
.Ve
.Sp
\&\s-1FILEHANDLE\s0 may be a expression whose value can be used as a indirect
filehandle, probably tha real filehandle name or a autovivified handle.
.IP "closedir \s-1DIRHANDLE \s0" 4
.IX Xref "closedir"
.IX Item "closedir DIRHANDLE "
Closes a gangbangin' finger-lickin' directory opened by \f(CW\*(C`opendir\*(C'\fR n' returns tha success of that
system call.
.IP "connect \s-1SOCKET,NAME \s0" 4
.IX Xref "connect"
.IX Item "connect SOCKET,NAME "
Attempts ta connect ta a remote socket, just like \fIconnect\fR\|(2).
Returns legit if it succeeded, false otherwise.  \s-1NAME\s0 should be a
packed address of tha appropriate type fo' tha socket.  See tha examplez in
\&\*(L"Sockets: Client/Server Communication\*(R" up in perlipc.
.IP "continue \s-1BLOCK \s0" 4
.IX Xref "continue"
.IX Item "continue BLOCK "
.PD 0
.IP "continue" 4
.IX Item "continue"
.PD
When followed by a \s-1BLOCK, \s0\f(CW\*(C`continue\*(C'\fR is straight-up a
flow control statement rather than a gangbangin' function. I aint talkin' bout chicken n' gravy biatch.  If
there be a \f(CW\*(C`continue\*(C'\fR \s-1BLOCK\s0 attached ta a \s-1BLOCK \s0(typically up in a \f(CW\*(C`while\*(C'\fR or
\&\f(CW\*(C`foreach\*(C'\fR), it be always executed just before tha conditionizzle be bout to
be evaluated again, just like tha third part of a \f(CW\*(C`for\*(C'\fR loop up in C.  Thus
it can be used ta increment a loop variable, even when tha loop has been
continued via tha \f(CW\*(C`next\*(C'\fR statement (which is similar ta tha C \f(CW\*(C`continue\*(C'\fR
statement).
.Sp
\&\f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR may step tha fuck up within a \f(CW\*(C`continue\*(C'\fR
block; \f(CW\*(C`last\*(C'\fR n' \f(CW\*(C`redo\*(C'\fR behave as if they had been executed within
the main block.  So will \f(CW\*(C`next\*(C'\fR yo, but since it will execute a \f(CW\*(C`continue\*(C'\fR
block, it may be mo' entertaining.
.Sp
.Vb 9
\&    while (EXPR) {
\&        ### redo always comes here
\&        do_something;
\&    } continue {
\&        ### next always comes here
\&        do_something_else;
\&        # then back tha top ta re\-check EXPR
\&    }
\&    ### last always comes here
.Ve
.Sp
Omittin tha \f(CW\*(C`continue\*(C'\fR section is equivalent ta rockin an
empty one, logically enough, so \f(CW\*(C`next\*(C'\fR goes directly back
to check tha condizzle all up in tha top of tha loop.
.Sp
When there is no \s-1BLOCK, \s0\f(CW\*(C`continue\*(C'\fR be a gangbangin' function that
falls all up in tha current \f(CW\*(C`when\*(C'\fR or \f(CW\*(C`default\*(C'\fR block instead of iterating
a dynamically enclosin \f(CW\*(C`foreach\*(C'\fR or exitin a lexically enclosin \f(CW\*(C`given\*(C'\fR.
In Perl 5.14 n' earlier, dis form of \f(CW\*(C`continue\*(C'\fR was
only available when tha \f(CW"switch"\fR feature was enabled.
See feature n' \*(L"Switch Statements\*(R" up in perlsyn fo' more
information.
.IP "cos \s-1EXPR \s0" 4
.IX Xref "cos cosine acos arccosine"
.IX Item "cos EXPR "
.PD 0
.IP "cos" 4
.IX Item "cos"
.PD
Returns tha cosine of \s-1EXPR \s0(expressed up in radians).  If \s-1EXPR\s0 is omitted,
takes tha cosine of \f(CW$_\fR.
.Sp
For tha inverse cosine operation, you may use tha \f(CW\*(C`Math::Trig::acos()\*(C'\fR
function, or use dis relation:
.Sp
.Vb 1
\&    sub acos { atan2( sqrt(1 \- $_[0] * $_[0]), $_[0] ) }
.Ve
.IP "crypt \s-1PLAINTEXT,SALT \s0" 4
.IX Xref "crypt digest hash salt plaintext password decrypt cryptography passwd encrypt"
.IX Item "crypt PLAINTEXT,SALT "
Creates a gangbangin' finger-lickin' digest strang exactly like tha \fIcrypt\fR\|(3) function up in tha C
library (assumin dat you straight-up gotz a version there dat has not
been extirpated as a potential munition).
.Sp
\&\fIcrypt()\fR be a one-way hash function. I aint talkin' bout chicken n' gravy biatch.  Da \s-1PLAINTEXT\s0 n' \s-1SALT\s0 is turned
into a gangbangin' finger-lickin' dirty-ass short string, called a gangbangin' finger-lickin' digest, which is returned. Y'all KNOW dat shit, muthafucka!  Da same
\&\s-1PLAINTEXT\s0 n' \s-1SALT\s0 will always return tha same strin yo, but there is no
(known) way ta git tha original gangsta \s-1PLAINTEXT\s0 from tha hash.  Small
changes up in tha \s-1PLAINTEXT\s0 or \s-1SALT\s0 will result up in big-ass chizzlez up in the
digest.
.Sp
There is no decrypt function. I aint talkin' bout chicken n' gravy biatch.  This function aint all dat useful for
cryptography (for that, look fo' \fICrypt\fR modulez on yo' nearby \s-1CPAN\s0
mirror) n' tha name \*(L"crypt\*(R" be a lil' bit of a misnomer n' shit.  Instead it is
primarily used ta check if two piecez of text is tha same without
havin ta transmit or store tha text itself.  An example is checking
if a cold-ass lil erect password is given. I aint talkin' bout chicken n' gravy biatch.  Da digest of tha password is stored,
not tha password itself.  Da user types up in a password dat is
\&\fIcrypt()\fR'd wit tha same salt as tha stored digest.  If tha two digests
match, tha password is erect.
.Sp
When verifyin a existin digest strang you should use tha digest as
the salt (like \f(CW\*(C`crypt($plain, $digest) eq $digest\*(C'\fR).  Da \s-1SALT\s0 used
to create tha digest is visible as part of tha digest.  This ensures
\&\fIcrypt()\fR will hash tha freshly smoked up strang wit tha same salt as tha digest.
This allows yo' code ta work wit tha standard crypt and
with mo' horny-ass implementations.  In other lyrics, assume
nothang bout tha returned strang itself nor bout how tha fuck nuff bytes 
of \s-1SALT\s0 may matter.
.Sp
Traditionally tha result be a strang of 13 bytes: two first bytes of
the salt, followed by 11 bytes from tha set \f(CW\*(C`[./0\-9A\-Za\-z]\*(C'\fR, n' only
the first eight bytez of \s-1PLAINTEXT\s0 mattered. Y'all KNOW dat shit, muthafucka!  But alternative
hashin schemes (like \s-1MD5\s0), higher level securitizzle schemes (like C2),
and implementations on non-Unix platforms may produce different
strings.
.Sp
When choosin a freshly smoked up salt create a random two characta strang whose
charactas come from tha set \f(CW\*(C`[./0\-9A\-Za\-z]\*(C'\fR (like \f(CW\*(C`join \*(Aq\*(Aq, (\*(Aq.\*(Aq,
\&\*(Aq/\*(Aq, 0..9, \*(AqA\*(Aq..\*(AqZ\*(Aq, \*(Aqa\*(Aq..\*(Aqz\*(Aq)[rand 64, rand 64]\*(C'\fR).  This set of
charactas is just a recommendation; tha charactas allowed in
the salt depend solely on yo' systemz crypt library, n' Perl can't
restrict what tha fuck salts \f(CW\*(C`crypt()\*(C'\fR accepts.
.Sp
Herez a example dat make shizzle dat whoever runs dis program knows
their password:
.Sp
.Vb 1
\&    $pwd = (getpwuid($<))[1];
\&
\&    system "stty \-echo";
\&    print "Password: ";
\&    chomp($word = <STDIN>);
\&    print "\en";
\&    system "stty echo";
\&
\&    if (crypt($word, $pwd) ne $pwd) {
\&        take a thugged-out dirtnap "Sorry...\en";
\&    } else {
\&        print "ok\en";
\&    }
.Ve
.Sp
Of course, typin up in yo' own password ta whoever asks you
for it is unwise.
.Sp
Da crypt function is unsuitable fo' hashin big-ass quantities
of data, not least of all cuz you can't git tha shiznit
back.  Look all up in tha Digest module fo' mo' robust algorithms.
.Sp
If rockin \fIcrypt()\fR on a Unicode strang (which \fIpotentially\fR has
charactas wit codepoints above 255), Perl tries ta make sense
of tha thang by tryin ta downgrade (a copy of)
the strang back ta a eight-bit byte strang before callin \fIcrypt()\fR
(on dat copy).  If dat works, good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  If not, \fIcrypt()\fR takes a thugged-out dirt nap with
\&\f(CW\*(C`Wide characta up in crypt\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"crypt\*(R" up in perlport.
.IP "dbmclose \s-1HASH \s0" 4
.IX Xref "dbmclose"
.IX Item "dbmclose HASH "
[This function has been largely superseded by tha \f(CW\*(C`untie\*(C'\fR function.]
.Sp
Breaks tha bindin between a \s-1DBM\s0 file n' a hash.
.Sp
Portabilitizzle issues: \*(L"dbmclose\*(R" up in perlport.
.IP "dbmopen \s-1HASH,DBNAME,MASK \s0" 4
.IX Xref "dbmopen dbm ndbm sdbm gdbm"
.IX Item "dbmopen HASH,DBNAME,MASK "
[This function has been largely superseded by the
tie function.]
.Sp
This bindz a \fIdbm\fR\|(3), \fIndbm\fR\|(3), \fIsdbm\fR\|(3), \fIgdbm\fR\|(3), or Berkeley \s-1DB\s0 file ta a
hash.  \s-1HASH\s0 is tha name of tha hash.  (Unlike aiiight \f(CW\*(C`open\*(C'\fR, tha first
argument is \fInot\fR a gangbangin' filehandle, even though it be lookin like one).  \s-1DBNAME\s0
is tha name of tha database (without tha \fI.dir\fR or \fI.pag\fR extension if
any).  If tha database do not exist, it is pimped wit protection
specified by \s-1MASK \s0(as modified by tha \f(CW\*(C`umask\*(C'\fR).  To prevent creation of
the database if it don't exist, you may specify a \s-1MODE\s0
of 0, n' tha function will return a gangbangin' false value if it
can't find a existin database.  If yo' system supports
only tha olda \s-1DBM\s0 functions, you may make only one \f(CW\*(C`dbmopen\*(C'\fR call up in your
program.  In olda versionz of Perl, if yo' system had neither \s-1DBM\s0 nor
ndbm, callin \f(CW\*(C`dbmopen\*(C'\fR produced a gangbangin' fatal error; it now falls back to
\&\fIsdbm\fR\|(3).
.Sp
If you aint gots write access ta tha \s-1DBM\s0 file, you can only read hash
variables, not set em.  If you wanna test whether you can write,
either use file tests or try settin a thugged-out dummy hash entry inside a \f(CW\*(C`eval\*(C'\fR 
to trap tha error.
.Sp
Note dat functions like fuckin \f(CW\*(C`keys\*(C'\fR n' \f(CW\*(C`values\*(C'\fR may return big-ass lists
when used on big-ass \s-1DBM\s0 files.  Yo ass may prefer ta use tha \f(CW\*(C`each\*(C'\fR
function ta iterate over big-ass \s-1DBM\s0 files.  Example:
.Sp
.Vb 6
\&    # print up history file offsets
\&    dbmopen(%HIST,\*(Aq/usr/lib/news/history\*(Aq,0666);
\&    while (($key,$val) = each %HIST) {
\&        print $key, \*(Aq = \*(Aq, unpack(\*(AqL\*(Aq,$val), "\en";
\&    }
\&    dbmclose(%HIST);
.Ve
.Sp
See also AnyDBM_File fo' a mo' general description of tha pros and
conz of tha various dbm approaches, as well as DB_File fo' a particularly
rich implementation.
.Sp
Yo ass can control which \s-1DBM\s0 library you use by loadin dat library
before you call \fIdbmopen()\fR:
.Sp
.Vb 3
\&    use DB_File;
\&    dbmopen(%NS_Hist, "$ENV{HOME}/.netscape/history.db")
\&        or take a thugged-out dirtnap "Can\*(Aqt open netscape history file: $!";
.Ve
.Sp
Portabilitizzle issues: \*(L"dbmopen\*(R" up in perlport.
.IP "defined \s-1EXPR \s0" 4
.IX Xref "defined undef undefined"
.IX Item "defined EXPR "
.PD 0
.IP "defined" 4
.IX Item "defined"
.PD
Returns a Boolean value spittin some lyrics ta whether \s-1EXPR\s0 has a value other than
the undefined value \f(CW\*(C`undef\*(C'\fR.  If \s-1EXPR\s0 aint present, \f(CW$_\fR is
checked.
.Sp
Many operations return \f(CW\*(C`undef\*(C'\fR ta indicate failure, end of file,
system error, uninitialized variable, n' other exceptional
conditions.  This function allows you ta distinguish \f(CW\*(C`undef\*(C'\fR from
other joints, n' you can put dat on yo' toast.  (A simple Boolean test aint gonna distinguish among
\&\f(CW\*(C`undef\*(C'\fR, zero, tha empty string, n' \f(CW"0"\fR, which is all equally
false.)  Note dat since \f(CW\*(C`undef\*(C'\fR be a valid scalar, its presence
doesn't \fInecessarily\fR indicate a exceptionizzle condition: \f(CW\*(C`pop\*(C'\fR
returns \f(CW\*(C`undef\*(C'\fR when its argument be a empty array, \fIor\fR when the
element ta return happens ta be \f(CW\*(C`undef\*(C'\fR.
.Sp
Yo ass may also use \f(CW\*(C`defined(&func)\*(C'\fR ta check whether subroutine \f(CW&func\fR
has eva been defined. Y'all KNOW dat shit, muthafucka!  Da return value is unaffected by any forward
declarationz of \f(CW&func\fR.  A subroutine dat aint defined
may still be callable: its package may have a \f(CW\*(C`AUTOLOAD\*(C'\fR method that
makes it sprang tha fuck into existence tha last time dat it is called; see
perlsub.
.Sp
Use of \f(CW\*(C`defined\*(C'\fR on aggregates (hashes n' arrays) is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It
used ta report whether memory fo' dat aggregate had eva been
allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This behavior may disappear up in future versionz of Perl.
Yo ass should instead bust a simple test fo' size:
.Sp
.Vb 2
\&    if (@an_array) { print "has array elements\en" }
\&    if (%a_hash)   { print "has hash members\en"   }
.Ve
.Sp
When used on a hash element, it  drops some lyrics ta you whether tha value is defined,
not whether tha key exists up in tha hash.  Use \*(L"exists\*(R" fo' tha latter
purpose.
.Sp
Examples:
.Sp
.Vb 6
\&    print if defined $switch{D};
\&    print "$val\en" while defined($val = pop(@ary));
\&    take a thugged-out dirtnap "Can\*(Aqt readlink $sym: $!"
\&        unless defined($value = readlink $sym);
\&    sub foo { defined &$bar , biatch? &$bar(@_) : take a thugged-out dirtnap "No bar"; }
\&    $debuggin = 0 unless defined $debugging;
.Ve
.Sp
Note:  Many folks tend ta overuse \f(CW\*(C`defined\*(C'\fR n' is then surprised to
discover dat tha number \f(CW0\fR n' \f(CW""\fR (the zero-length string) are, up in fact,
defined joints, n' you can put dat on yo' toast.  For example, if you say
.Sp
.Vb 1
\&    "ab" =~ /a(.*)b/;
.Ve
.Sp
Da pattern match succeedz n' \f(CW$1\fR is defined, although it
matched \*(L"nothing\*(R".  It didn't straight-up fail ta match anything.  Rather, it
matched suttin' dat happened ta be zero charactas long.  This be all
very above-board n' honest.  When a gangbangin' function returns a undefined value,
itz a admission dat it couldn't hit you wit a real answer n' shit.  So you
should use \f(CW\*(C`defined\*(C'\fR only when dissin tha integritizzle of what
yo ass is tryin ta do.  At other times, a simple comparison ta \f(CW0\fR or \f(CW""\fR is
what you want.
.Sp
See also \*(L"undef\*(R", \*(L"exists\*(R", \*(L"ref\*(R".
.IP "delete \s-1EXPR \s0" 4
.IX Xref "delete"
.IX Item "delete EXPR "
Given a expression dat specifies a element or slice of a hash, \f(CW\*(C`delete\*(C'\fR
deletes tha specified elements from dat hash so dat \fIexists()\fR on dat element
no longer returns true.  Settin a hash element ta tha undefined value do
not remove its key yo, but deletin it do; peep \*(L"exists\*(R".
.Sp
In list context, returns tha value or joints deleted, or tha last such
element up in scalar context.  Da return listz length always matches dat of
the argument list: deletin non-existent elements returns tha undefined value
in they correspondin positions.
.Sp
\&\fIdelete()\fR may also be used on arrays n' array slices yo, but its behavior is less
straightforward. Y'all KNOW dat shit, muthafucka!  Although \fIexists()\fR will return false fo' deleted entries,
deletin array elements never chizzlez indicez of existin joints; use \fIshift()\fR
or \fIsplice()\fR fo' dis shit.  But fuck dat shiznit yo, tha word on tha street is dat if all deleted elements fall all up in tha end of an
array, tha arrayz size shrinks ta tha posizzle of tha highest element that
still tests legit fo' \fIexists()\fR, or ta 0 if none do.
.Sp
\&\fB\s-1WARNING:\s0\fR Callin delete on array joints is deprecated n' likely to
be removed up in a gangbangin' future version of Perl.
.Sp
Deletin from \f(CW%ENV\fR modifies tha environment.  Deletin from a hash tied to
a \s-1DBM\s0 file deletes tha entry from tha \s-1DBM\s0 file.  Deletin from a \f(CW\*(C`tied\*(C'\fR hash
or array may not necessarily return anything; it dependz on tha implementation
of tha \f(CW\*(C`tied\*(C'\fR packagez \s-1DELETE\s0 method, which may do whatever it pleases.
.Sp
Da \f(CW\*(C`delete local EXPR\*(C'\fR construct localizes tha deletion ta tha current
block at run time.  Until tha block exits, elements locally deleted
temporarily no longer exist.  See \*(L"Localized deletion of elements
of composite types\*(R" up in perlsub.
.Sp
.Vb 4
\&    %hash = (foo => 11, bar => 22, baz => 33);
\&    $scalar = delete $hash{foo};         # $scalar is 11
\&    $scalar = delete @hash{qw(foo bar)}; # $scalar is 22
\&    @array  = delete @hash{qw(foo baz)}; # @array  is (undef,33)
.Ve
.Sp
Da followin (inefficiently) deletes all tha jointz of \f(CW%HASH\fR n' \f(CW@ARRAY:\fR
.Sp
.Vb 3
\&    foreach $key (keys %HASH) {
\&        delete $HASH{$key};
\&    }
\&
\&    foreach $index (0 .. $#ARRAY) {
\&        delete $ARRAY[$index];
\&    }
.Ve
.Sp
And so do these:
.Sp
.Vb 1
\&    delete @HASH{keys %HASH};
\&
\&    delete @ARRAY[0 .. $#ARRAY];
.Ve
.Sp
But both is slower than assignin tha empty list
or undefinin \f(CW%HASH\fR or \f(CW@ARRAY\fR, which is tha customary 
way ta empty up a aggregate:
.Sp
.Vb 2
\&    %HASH = ();     # straight-up empty %HASH
\&    undef %HASH;    # forget %HASH eva existed
\&
\&    @ARRAY = ();    # straight-up empty @ARRAY
\&    undef @ARRAY;   # forget @ARRAY eva existed
.Ve
.Sp
Da \s-1EXPR\s0 can be arbitrarily fucked up provided its
final operation be a element or slice of a aggregate:
.Sp
.Vb 2
\&    delete $ref\->[$x][$y]{$key};
\&    delete @{$ref\->[$x][$y]}{$key1, $key2, @morekeys};
\&
\&    delete $ref\->[$x][$y][$index];
\&    delete @{$ref\->[$x][$y]}[$index1, $index2, @moreindices];
.Ve
.IP "die \s-1LIST \s0" 4
.IX Xref "die throw exception raise $@ abort"
.IX Item "die LIST "
\&\f(CW\*(C`die\*(C'\fR raises a exception. I aint talkin' bout chicken n' gravy biatch.  Inside a \f(CW\*(C`eval\*(C'\fR tha error message is stuffed
into \f(CW$@\fR n' tha \f(CW\*(C`eval\*(C'\fR is terminated wit tha undefined value.
If tha exception is outside of all enclosin \f(CW\*(C`eval\*(C'\fRs, then tha uncaught
exception prints \s-1LIST\s0 ta \f(CW\*(C`STDERR\*(C'\fR n' exits wit a non-zero value.  If you
need ta exit tha process wit a specific exit code, peep \*(L"exit\*(R".
.Sp
Equivalent examples:
.Sp
.Vb 2
\&    take a thugged-out dirtnap "Can\*(Aqt cd ta spool: $!\en" unless chdir \*(Aq/usr/spool/news\*(Aq;
\&    chdir \*(Aq/usr/spool/news\*(Aq or take a thugged-out dirtnap "Can\*(Aqt cd ta spool: $!\en"
.Ve
.Sp
If tha last element of \s-1LIST\s0 do not end up in a newline, tha current
script line number n' input line number (if any) is also printed,
and a newline is supplied. Y'all KNOW dat shit, muthafucka!  Note dat tha \*(L"input line number\*(R" (also
known as \*(L"chunk\*(R") is subject ta whatever notion of \*(L"line\*(R" happens to
be currently up in effect, n' be also available as tha special variable
\&\f(CW$.\fR.  See \*(L"$/\*(R" up in perlvar n' \*(L"$.\*(R" up in perlvar.
.Sp
Hint: sometimes appendin \f(CW", stopped"\fR ta yo' message will cause it
to make betta sense when tha strang \f(CW"at foo line 123"\fR be appended.
Suppose yo ass is hustlin script \*(L"canasta\*(R".
.Sp
.Vb 2
\&    take a thugged-out dirtnap "/etc/game is no good";
\&    take a thugged-out dirtnap "/etc/game is no good, stopped";
.Ve
.Sp
produce, respectively
.Sp
.Vb 2
\&    /etc/game is no phat at canasta line 123.
\&    /etc/game is no good, stopped at canasta line 123.
.Ve
.Sp
If tha output is empty n' \f(CW$@\fR already gotz nuff a value (typically from a
previous eval) dat value is reused afta appendin \f(CW"\et...propagated"\fR.
This is useful fo' propagatin exceptions:
.Sp
.Vb 2
\&    eval { ... };
\&    take a thugged-out dirtnap unless $@ =~ /Expected exception/;
.Ve
.Sp
If tha output is empty n' \f(CW$@\fR gotz nuff a object reference dat has a
\&\f(CW\*(C`PROPAGATE\*(C'\fR method, dat method is ghon be called wit additionizzle file
and line number parameters.  Da return value replaces tha value in
\&\f(CW$@\fR;  i.e., as if \f(CW\*(C`$@ = eval { $@\->PROPAGATE(_\|_FILE_\|_, _\|_LINE_\|_) };\*(C'\fR
were called.
.Sp
If \f(CW$@\fR is empty then tha strang \f(CW"Died"\fR is used.
.Sp
If a uncaught exception thangs up in dis biatch up in interpreta exit, tha exit code is
determined from tha jointz of \f(CW$!\fR n' \f(CW$?\fR wit dis pseudocode:
.Sp
.Vb 3
\&    exit $! if $!;              # errno
\&    exit $, biatch? >> 8 if $, biatch? >> 8;    # lil pimp exit status
\&    exit 255;                   # last resort
.Ve
.Sp
Da intent is ta squeeze as much possible shiznit bout tha likely cause
into tha limited space of tha system exit
code.  But fuck dat shiznit yo, tha word on tha street is dat as \f(CW$!\fR is tha value
of Cz \f(CW\*(C`errno\*(C'\fR, which can be set by any system call, dis means dat tha value
of tha exit code used by \f(CW\*(C`die\*(C'\fR can be non-predictable, so should not be relied
upon, other than ta be non-zero.
.Sp
Yo ass can also call \f(CW\*(C`die\*(C'\fR wit a reference argument, n' if dis is trapped
within a \f(CW\*(C`eval\*(C'\fR, \f(CW$@\fR gotz nuff dat reference.  This permits more
elaborate exception handlin rockin objects dat maintain arbitrary state
about tha exception. I aint talkin' bout chicken n' gravy biatch.  Such a scheme is sometimes preferable ta matching
particular strang jointz of \f(CW$@\fR wit regular expressions.  Because \f(CW$@\fR 
is a global variable n' \f(CW\*(C`eval\*(C'\fR may be used within object implementations,
be careful dat analyzin tha error object don't replace tha reference in
the global variable.  It aint nuthin but easiest ta cook up a local copy of tha reference
before any manipulations.  Herez a example:
.Sp
.Vb 1
\&    use Scalar::Util "blessed";
\&
\&    eval { ... ; take a thugged-out dirtnap Some::Module::Exception\->new( FOO => "bar" ) };
\&    if (my $ev_err = $@) {
\&        if (blessed($ev_err)
\&            && $ev_err\->isa("Some::Module::Exception")) {
\&            # handle Some::Module::Exception
\&        }
\&        else {
\&            # handle all other possible exceptions
\&        }
\&    }
.Ve
.Sp
Because Perl stringifies uncaught exception lyrics before display,
yo dirty ass is gonna probably wanna overload stringification operations on
exception objects, n' you can put dat on yo' toast.  See overload fo' details bout dis shit.
.Sp
Yo ass can arrange fo' a cold-ass lil callback ta be run just before tha \f(CW\*(C`die\*(C'\fR
does its deed, by settin tha \f(CW$SIG{_\|_DIE_\|_}\fR hook.  Da associated
handlez is called wit tha error text n' can chizzle tha error
message, if it sees fit, by callin \f(CW\*(C`die\*(C'\fR again. I aint talkin' bout chicken n' gravy biatch.  See
\&\*(L"%SIG\*(R" up in perlvar fo' details on settin \f(CW%SIG\fR entries, and
\&\*(L"eval \s-1BLOCK\*(R"\s0 fo' some examples.  Although dis feature was 
to be run only right before yo' program was ta exit, dis is not
currently so: tha \f(CW$SIG{_\|_DIE_\|_}\fR hook is currently called
even inside \fIeval()\fRed blocks/strings muthafucka!  If one wants tha hook ta do
nothang up in such thangs, put
.Sp
.Vb 1
\&    take a thugged-out dirtnap @_ if $^S;
.Ve
.Sp
as tha straight-up original gangsta line of tha handlez (see \*(L"$^S\*(R" up in perlvar).  Because
this promotes strange action at a gangbangin' finger-lickin' distance, dis counterintuitive
behavior may be fixed up in a gangbangin' future release.
.Sp
See also \fIexit()\fR, \fIwarn()\fR, n' tha Carp module.
.IP "do \s-1BLOCK \s0" 4
.IX Xref "do block"
.IX Item "do BLOCK "
Not straight-up a gangbangin' function. I aint talkin' bout chicken n' gravy biatch.  Returns tha value of tha last command up in the
sequence of commandz indicated by \s-1BLOCK. \s0 When modified by tha \f(CW\*(C`while\*(C'\fR or
\&\f(CW\*(C`until\*(C'\fR loop modifier, executes tha \s-1BLOCK\s0 once before testin tha loop
condition. I aint talkin' bout chicken n' gravy biatch.  (On other statements tha loop modifiers test tha conditional
first.)
.Sp
\&\f(CW\*(C`do BLOCK\*(C'\fR do \fInot\fR count as a loop, so tha loop control statements
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR cannot be used ta leave or restart tha block.
See perlsyn fo' alternatizzle strategies.
.IP "do \s-1SUBROUTINE\s0(\s-1LIST\s0)" 4
.IX Xref "do"
.IX Item "do SUBROUTINE(LIST)"
This form of subroutine call is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \s-1SUBROUTINE\s0 can be a funky-ass bareword
or scalar variable.
.IP "do \s-1EXPR \s0" 4
.IX Xref "do"
.IX Item "do EXPR "
Uses tha value of \s-1EXPR\s0 as a gangbangin' filename n' executes tha contentz of the
file as a Perl script.
.Sp
.Vb 1
\&    do \*(Aqstat.pl\*(Aq;
.Ve
.Sp
is largely like
.Sp
.Vb 1
\&    eval \`cat stat.pl\`;
.Ve
.Sp
except dat itz mo' concise, runs no external processes, keeps track of
the current
filename fo' error lyrics, searches tha \f(CW@INC\fR directories, n' thugged-out shit
\&\f(CW%INC\fR if tha file is found. Y'all KNOW dat shit, muthafucka!  See \*(L"@INC\*(R" up in perlvar n' \*(L"%INC\*(R" up in perlvar for
these variables.  It also differs up in dat code evaluated wit \f(CW\*(C`do FILENAME\*(C'\fR
cannot peep lexicals up in tha enclosin scope; \f(CW\*(C`eval STRING\*(C'\fR do.  It aint nuthin but the
same, however, up in dat it do reparse tha file every last muthafuckin time you call it,
so you probably don't wanna do dis inside a loop.
.Sp
If \f(CW\*(C`do\*(C'\fR can read tha file but cannot compile it, it returns \f(CW\*(C`undef\*(C'\fR n' sets
an error message up in \f(CW$@\fR.  If \f(CW\*(C`do\*(C'\fR cannot read tha file, it returns undef
and sets \f(CW$!\fR ta tha error. Shiiit, dis aint no joke.  Always check \f(CW$@\fR first, as compilation
could fail up in a way dat also sets \f(CW$!\fR.  If tha file is successfully
compiled, \f(CW\*(C`do\*(C'\fR returns tha value of tha last expression evaluated.
.Sp
Inclusion of library modulez is betta done wit the
\&\f(CW\*(C`use\*(C'\fR n' \f(CW\*(C`require\*(C'\fR operators, which also do automatic error checking
and raise a exception if there be a a problem.
.Sp
Yo ass might like ta use \f(CW\*(C`do\*(C'\fR ta read up in a program configuration
file.  Manual error checkin can be done dis way:
.Sp
.Vb 10
\&    # read up in config files: system first, then user
\&    fo' $file ("/share/prog/defaults.rc",
\&               "$ENV{HOME}/.someprogrc")
\&    {
\&        unless ($return = do $file) {
\&            warn "couldn\*(Aqt parse $file: $@" if $@;
\&            warn "couldn\*(Aqt do $file: $!"    unless defined $return;
\&            warn "couldn\*(Aqt run $file"       unless $return;
\&        }
\&    }
.Ve
.IP "dump \s-1LABEL \s0" 4
.IX Xref "dump core undump"
.IX Item "dump LABEL "
.PD 0
.IP "dump \s-1EXPR\s0" 4
.IX Item "dump EXPR"
.IP "dump" 4
.IX Item "dump"
.PD
This function causes a immediate core dump.  See also tha \fB\-u\fR
command-line switch up in perlrun, which do tha same thang.
Primarily dis is so dat you can use tha \fBundump\fR program (not
supplied) ta turn yo' core dump tha fuck into a executable binary after
havin initialized all yo' variablez all up in tha beginnin of the
program.  When tha freshly smoked up binary is executed it will begin by executing
a \f(CW\*(C`goto LABEL\*(C'\fR (with all tha restrictions dat \f(CW\*(C`goto\*(C'\fR suffers).
Think of it as a goto wit a intervenin core dump n' reincarnation.
If \f(CW\*(C`LABEL\*(C'\fR is omitted, restarts tha program from tha top.  The
\&\f(CW\*(C`dump EXPR\*(C'\fR form, available startin up in Perl 5.18.0, allows a name ta be
computed at run time, bein otherwise identical ta \f(CW\*(C`dump LABEL\*(C'\fR.
.Sp
\&\fB\s-1WARNING\s0\fR: Any filez opened all up in tha time of tha dump will \fInot\fR
be open any mo' when tha program is reincarnated, wit possible
resultin mad drama by Perl.
.Sp
This function is now largely obsolete, mostly cuz itz straight-up hard to
convert a cold-ass lil core file tha fuck into a executable.  Thatz why you should now invoke
it as \f(CW\*(C`CORE::dump()\*(C'\fR, if you don't wanna be warned against a possible
typo.
.Sp
Unlike most named operators, dis has tha same ol' dirty precedence as assignment.
It be also exempt from tha looks-like-a-function rule, so
\&\f(CW\*(C`dump ("foo")."bar"\*(C'\fR will cause \*(L"bar\*(R" ta be part of tha argument to
\&\f(CW\*(C`dump\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"dump\*(R" up in perlport.
.IP "each \s-1HASH \s0" 4
.IX Xref "each hash, iterator"
.IX Item "each HASH "
.PD 0
.IP "each \s-1ARRAY \s0" 4
.IX Xref "array, iterator"
.IX Item "each ARRAY "
.IP "each \s-1EXPR\s0" 4
.IX Item "each EXPR"
.PD
When called on a hash up in list context, returns a 2\-element list
consistin of tha key n' value fo' tha next element of a hash.  In Perl
5.12 n' lata only, it will also return tha index n' value fo' tha next
element of a array so dat you can iterate over it; olda Perls consider
this a syntax error. Shiiit, dis aint no joke.  When called up in scalar context, returns only tha key
(not tha value) up in a hash, or tha index up in a array.
.Sp
Hash entries is returned up in a apparently random order n' shit.  Da actual random
order is specific ta a given hash; tha exact same seriez of operations
on two hashes may result up in a gangbangin' finger-lickin' different order fo' each hash fo' realz. Any insertion
into tha hash may chizzle tha order, as will any deletion, wit tha exception
that da most thugged-out recent key returned by \f(CW\*(C`each\*(C'\fR or \f(CW\*(C`keys\*(C'\fR may be deleted
without changin tha order n' shit. Right back up in yo muthafuckin ass. So long as a given hash is unmodified you may
rely on \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR n' \f(CW\*(C`each\*(C'\fR ta repeatedly return tha same order
as each other n' shit. Right back up in yo muthafuckin ass. See \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec for
details on why hash order is randomized. Y'all KNOW dat shit, muthafucka! Aside from tha guarantees
provided here tha exact detailz of Perlz hash algorithm n' tha hash
traversal order is subject ta chizzle up in any release of Perl.
.Sp
Afta \f(CW\*(C`each\*(C'\fR has returned all entries from tha hash or array, tha next
call ta \f(CW\*(C`each\*(C'\fR returns tha empty list up in list context n' \f(CW\*(C`undef\*(C'\fR in
scalar context; tha next call followin \fIthat\fR one restarts iteration.
Each hash or array has its own internal iterator, accessed by \f(CW\*(C`each\*(C'\fR,
\&\f(CW\*(C`keys\*(C'\fR, n' \f(CW\*(C`values\*(C'\fR.  Da iterator is implicitly reset when \f(CW\*(C`each\*(C'\fR has
reached tha end as just busted lyrics about; it can be explicitly reset by calling
\&\f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR on tha hash or array.  If you add or delete a hash's
elements while iteratin over it, entries may be skipped or duplicated\*(--so
don't do dis shit.  Exception: In tha current implementation, it be always safe
to delete tha item most recently returned by \f(CW\*(C`each()\*(C'\fR, so tha following
code works properly:
.Sp
.Vb 4
\&        while (($key, $value) = each %hash) {
\&          print $key, "\en";
\&          delete $hash{$key};   # This is safe
\&        }
.Ve
.Sp
This prints up yo' environment like tha \fIprintenv\fR\|(1) program,
but up in a gangbangin' finger-lickin' different order:
.Sp
.Vb 3
\&    while (($key,$value) = each %ENV) {
\&        print "$key=$value\en";
\&    }
.Ve
.Sp
Startin wit Perl 5.14, \f(CW\*(C`each\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold
reference ta a unblessed hash or array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`each\*(C'\fR is considered highly experimental.
Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
.Vb 1
\&    while (($key,$value) = each $hashref) { ... }
.Ve
.Sp
Az of Perl 5.18 you can bust a funky-ass bare \f(CW\*(C`each\*(C'\fR up in a \f(CW\*(C`while\*(C'\fR loop,
which will set \f(CW$_\fR on every last muthafuckin iteration.
.Sp
.Vb 3
\&    while(each %ENV) {
\&        print "$_=$ENV{$_}\en";
\&    }
.Ve
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 3
\&    use 5.012;  # so keys/values/each work on arrays
\&    use 5.014;  # so keys/values/each work on scalars (experimental)
\&    use 5.018;  # so each assigns ta $_ up in a lone while test
.Ve
.Sp
See also \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, n' \f(CW\*(C`sort\*(C'\fR.
.IP "eof \s-1FILEHANDLE \s0" 4
.IX Xref "eof end of file end-of-file"
.IX Item "eof FILEHANDLE "
.PD 0
.IP "eof ()" 4
.IX Item "eof ()"
.IP "eof" 4
.IX Item "eof"
.PD
Returns 1 if tha next read on \s-1FILEHANDLE\s0 will return end of file \fIor\fR if
\&\s-1FILEHANDLE\s0 aint open. I aint talkin' bout chicken n' gravy biatch.  \s-1FILEHANDLE\s0 may be a expression whose value
gives tha real filehandle.  (Note dat dis function actually
readz a cold-ass lil characta n' then \f(CW\*(C`ungetc\*(C'\fRs it, so aint useful up in an
interactizzle context.)  Do not read from a terminal file (or call
\&\f(CW\*(C`eof(FILEHANDLE)\*(C'\fR on it) afta end-of-file is reached. Y'all KNOW dat shit, muthafucka!  File types such
as terminals may lose tha end-of-file condizzle if you do.
.Sp
An \f(CW\*(C`eof\*(C'\fR without a argument uses tha last file read. Y'all KNOW dat shit, muthafucka!  Usin \f(CW\*(C`eof()\*(C'\fR
with empty parentheses is different.  It refers ta tha pseudo file
formed from tha filez listed on tha command line n' accessed via the
\&\f(CW\*(C`<>\*(C'\fR operator. Shiiit, dis aint no joke.  Since \f(CW\*(C`<>\*(C'\fR aint explicitly opened,
as a aiiight filehandle is, a \f(CW\*(C`eof()\*(C'\fR before \f(CW\*(C`<>\*(C'\fR has been
used will cause \f(CW@ARGV\fR ta be examined ta determine if input is
available.   Similarly, a \f(CW\*(C`eof()\*(C'\fR afta \f(CW\*(C`<>\*(C'\fR has returned
end-of-file will assume yo ass is processin another \f(CW@ARGV\fR list,
and if you aint set \f(CW@ARGV\fR, will read input from \f(CW\*(C`STDIN\*(C'\fR;
see \*(L"I/O Operators\*(R" up in perlop.
.Sp
In a \f(CW\*(C`while (<>)\*(C'\fR loop, \f(CW\*(C`eof\*(C'\fR or \f(CW\*(C`eof(ARGV)\*(C'\fR can be used to
detect tha end of each file, whereas \f(CW\*(C`eof()\*(C'\fR will detect tha end 
of tha straight-up last file only.  Examples:
.Sp
.Vb 7
\&    # reset line numberin on each input file
\&    while (<>) {
\&        next if /^\es*#/;  # skip comments
\&        print "$.\et$_";
\&    } continue {
\&        close ARGV if eof;  # Not eof()!
\&    }
\&
\&    # bang dashes just before last line of last file
\&    while (<>) {
\&        if (eof()) {  # check fo' end of last file
\&            print "\-\-\-\-\-\-\-\-\-\-\-\-\-\-\en";
\&        }
\&        print;
\&        last if eof();     # needed if we\*(Aqre readin from a terminal
\&    }
.Ve
.Sp
Practical hint: you almost never need ta use \f(CW\*(C`eof\*(C'\fR up in Perl, cuz the
input operators typically return \f(CW\*(C`undef\*(C'\fR when they run outta data or 
encounta a error.
.IP "eval \s-1EXPR \s0" 4
.IX Xref "eval try catch evaluate parse execute error, handlin exception, handling"
.IX Item "eval EXPR "
.PD 0
.IP "eval \s-1BLOCK\s0" 4
.IX Item "eval BLOCK"
.IP "eval" 4
.IX Item "eval"
.PD
In tha straight-up original gangsta form, tha return value of \s-1EXPR\s0 is parsed n' executed as if it
were a lil Perl program.  Da value of tha expression (which is itself
determined within scalar context) is first parsed, n' if there was no
errors, executed as a funky-ass block within tha lexical context of tha current Perl
program.  This means, dat up in particular, any outa lexical variablez are
visible ta it, n' any package variable settings or subroutine n' format
definitions remain afterwards.
.Sp
Note dat tha value is parsed every last muthafuckin time tha \f(CW\*(C`eval\*(C'\fR executes.
If \s-1EXPR\s0 is omitted, evaluates \f(CW$_\fR.  This form is typically used to
delay parsin n' subsequent execution of tha text of \s-1EXPR\s0 until run time.
.Sp
If tha \f(CW\*(C`unicode_eval\*(C'\fR feature is enabled (which is tha default under a
\&\f(CW\*(C`use 5.16\*(C'\fR or higher declaration), \s-1EXPR\s0 or \f(CW$_\fR is treated as a strang of
characters, so \f(CW\*(C`use utf8\*(C'\fR declarations have no effect, n' source filters
are forbidden. I aint talkin' bout chicken n' gravy biatch.  In tha absence of tha \f(CW\*(C`unicode_eval\*(C'\fR feature, tha string
will sometimes be treated as charactas n' sometimes as bytes, depending
on tha internal encoding, n' source filtas activated within tha \f(CW\*(C`eval\*(C'\fR
exhibit tha erratic yo, but historical, behaviour of affectin some outa file
scope dat is still compiling.  See also tha \*(L"evalbytes\*(R" keyword, which
always treats its input as a funky-ass byte stream n' works properly wit source
filters, n' tha feature pragma.
.Sp
In tha second form, tha code within tha \s-1BLOCK\s0 is parsed only once\*(--at the
same time tha code surroundin tha \f(CW\*(C`eval\*(C'\fR itself was parsed\*(--and executed
within tha context of tha current Perl program.  This form is typically
used ta trap exceptions mo' efficiently than tha straight-up original gangsta (see below), while
also providin tha benefit of checkin tha code within \s-1BLOCK\s0 at compile
time.
.Sp
Da final semicolon, if any, may be omitted from tha value of \s-1EXPR\s0 or within
the \s-1BLOCK.\s0
.Sp
In both forms, tha value returned is tha value of tha last expression
evaluated inside tha mini-program; a return statement may be also used, just
as wit subroutines.  Da expression providin tha return value is evaluated
in void, scalar, or list context, dependin on tha context of tha \f(CW\*(C`eval\*(C'\fR 
itself.  See \*(L"wantarray\*(R" fo' mo' on how tha fuck tha evaluation context can be 
determined.
.Sp
If there be a syntax error or runtime error, or a \f(CW\*(C`die\*(C'\fR statement is
executed, \f(CW\*(C`eval\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR up in scalar context
or a empty list up in list context, n' \f(CW$@\fR is set ta tha error
message.  (Prior ta 5.16, a funky-ass bug caused \f(CW\*(C`undef\*(C'\fR ta be returned
in list context fo' syntax errors yo, but not fo' runtime errors.)
If there was no error, \f(CW$@\fR is set ta tha empty string.  A
control flow operator like \f(CW\*(C`last\*(C'\fR or \f(CW\*(C`goto\*(C'\fR can bypass tha settin of
\&\f(CW$@\fR.  Beware dat rockin \f(CW\*(C`eval\*(C'\fR neither silences Perl from printing
warnings ta \s-1STDERR,\s0 nor do it shiznit tha text of warnin lyrics tha fuck into \f(CW$@\fR.
To do either of them, you gotta use tha \f(CW$SIG{_\|_WARN_\|_}\fR facility, or
turn off warnings inside tha \s-1BLOCK\s0 or \s-1EXPR\s0 rockin \f(CW\*(C`no\ warnings\ \*(Aqall\*(Aq\*(C'\fR.
See \*(L"warn\*(R", perlvar, warnings n' perllexwarn.
.Sp
Note that, cuz \f(CW\*(C`eval\*(C'\fR traps otherwise-fatal errors, it is useful for
determinin whether a particular feature (like fuckin \f(CW\*(C`socket\*(C'\fR or \f(CW\*(C`symlink\*(C'\fR)
is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It be also Perlz exception-trappin mechanism, where
the take a thugged-out dirtnap operator is used ta raise exceptions.
.Sp
If you wanna trap errors when loadin a \s-1XS\s0 module, some problems with
the binary intercourse (like fuckin Perl version skew) may be fatal even with
\&\f(CW\*(C`eval\*(C'\fR unless \f(CW$ENV{PERL_DL_NONLAZY}\fR is set.  See perlrun.
.Sp
If tha code ta be executed don't vary, you may use tha eval-BLOCK
form ta trap run-time errors without incurrin tha penalty of
recompilin each time.  Da error, if any, is still returned up in \f(CW$@\fR.
Examples:
.Sp
.Vb 2
\&    # make divide\-by\-zero nonfatal
\&    eval { $answer = $a / $b; }; warn $@ if $@;
\&
\&    # same thang yo, but less efficient
\&    eval \*(Aq$answer = $a / $b\*(Aq; warn $@ if $@;
\&
\&    # a cold-ass lil compile\-time error
\&    eval { $answer = }; # WRONG
\&
\&    # a run\-time error
\&    eval \*(Aq$answer =\*(Aq;   # sets $@
.Ve
.Sp
Usin tha \f(CW\*(C`eval{}\*(C'\fR form as a exception trap up in libraries do have some
issues.  Cuz of tha current arguably fucked up state of \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks, you
may wish not ta trigger any \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks dat user code may have installed.
Yo ass can use tha \f(CW\*(C`local $SIG{_\|_DIE_\|_}\*(C'\fR construct fo' dis purpose,
as dis example shows:
.Sp
.Vb 3
\&    # a private exception trap fo' divide\-by\-zero
\&    eval { local $SIG{\*(Aq_\|_DIE_\|_\*(Aq}; $answer = $a / $b; };
\&    warn $@ if $@;
.Ve
.Sp
This is especially significant, given dat \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hooks can call
\&\f(CW\*(C`die\*(C'\fR again, which has tha effect of changin they error lyrics:
.Sp
.Vb 7
\&    # _\|_DIE_\|_ hooks may modify error lyrics
\&    {
\&       local $SIG{\*(Aq_\|_DIE_\|_\*(Aq} =
\&              sub { (my $x = $_[0]) =~ s/foo/bar/g; take a thugged-out dirtnap $x };
\&       eval { take a thugged-out dirtnap "foo lives here" };
\&       print $@ if $@;                # prints "bar lives here"
\&    }
.Ve
.Sp
Because dis promotes action at a gangbangin' finger-lickin' distance, dis counterintuitizzle behavior
may be fixed up in a gangbangin' future release.
.Sp
With a \f(CW\*(C`eval\*(C'\fR, you should be especially careful ta remember what's
bein looked at when:
.Sp
.Vb 2
\&    eval $x;        # CASE 1
\&    eval "$x";      # CASE 2
\&
\&    eval \*(Aq$x\*(Aq;      # CASE 3
\&    eval { $x };    # CASE 4
\&
\&    eval "\e$$x++";  # CASE 5
\&    $$x++;          # CASE 6
.Ve
.Sp
Cases 1 n' 2 above behave identically: they run tha code contained in
the variable \f(CW$x\fR.  (Although case 2 has misleadin double quotes making
the reader wonder what tha fuck else might be goin down (nothang is).)  Cases 3
and 4 likewise behave up in tha same way: they run tha code \f(CW\*(Aq$x\*(Aq\fR, which
does not a god damn thang but return tha value of \f(CW$x\fR.  (Case 4 is preferred for
purely visual reasons yo, but it also has tha advantage of compilin at
compile-time instead of at run-time.)  Case 5 be a place where
normally you \fIwould\fR like ta use double quotes, except dat up in this
particular thang, you can just use symbolic references instead, as
in case 6.
.Sp
Before Perl 5.14, tha assignment ta \f(CW$@\fR occurred before restoration 
of localized variables, which means dat fo' yo' code ta run on older
versions, a temporary is required if you wanna mask some but not all
errors:
.Sp
.Vb 11
\&    # alta $@ on nefarious repugnancy only
\&    {
\&       mah $e;
\&       {
\&         local $@; # protect existin $@
\&         eval { test_repugnancy() };
\&         # $@ =~ /nefarious/ n' take a thugged-out dirtnap $@; # Perl 5.14 n' higher only
\&         $@ =~ /nefarious/ n' $e = $@;
\&       }
\&       take a thugged-out dirtnap $e if defined $e
\&    }
.Ve
.Sp
\&\f(CW\*(C`eval BLOCK\*(C'\fR do \fInot\fR count as a loop, so tha loop control statements
\&\f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR cannot be used ta leave or restart tha block.
.Sp
An \f(CW\*(C`eval \*(Aq\*(Aq\*(C'\fR executed within a subroutine defined
in tha \f(CW\*(C`DB\*(C'\fR package don't peep tha usual
surroundin lexical scope yo, but rather tha scope of tha straight-up original gangsta non-DB piece
of code dat called dat shit.  Yo ass don't normally need ta worry bout dis unless
yo ass is freestylin a Perl debugger.
.IP "evalbytes \s-1EXPR \s0" 4
.IX Xref "evalbytes"
.IX Item "evalbytes EXPR "
.PD 0
.IP "evalbytes" 4
.IX Item "evalbytes"
.PD
This function is like \*(L"eval\*(R" wit a strang argument, except it always
parses its argument, or \f(CW$_\fR if \s-1EXPR\s0 is omitted, as a strang of bytes.  A
strin containin charactas whose ordinal value exceedz 255 thangs up in dis biatch up in an
error. Shiiit, dis aint no joke.  Source filtas activated within tha evaluated code apply ta the
code itself.
.Sp
This function is only available under tha \f(CW\*(C`evalbytes\*(C'\fR feature, a
\&\f(CW\*(C`use v5.16\*(C'\fR (or higher) declaration, or wit a \f(CW\*(C`CORE::\*(C'\fR prefix.  See
feature fo' mo' shiznit.
.IP "exec \s-1LIST \s0" 4
.IX Xref "exec execute"
.IX Item "exec LIST "
.PD 0
.IP "exec \s-1PROGRAM LIST\s0" 4
.IX Item "exec PROGRAM LIST"
.PD
Da \f(CW\*(C`exec\*(C'\fR function executes a system command \fIand never returns\fR;
use \f(CW\*(C`system\*(C'\fR instead of \f(CW\*(C`exec\*(C'\fR if you want it ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  It fails and
returns false only if tha command do not exist \fIand\fR it is executed
directly instead of via yo' systemz command shell (see below).
.Sp
Since itz a cold-ass lil common fuck up ta use \f(CW\*(C`exec\*(C'\fR instead of \f(CW\*(C`system\*(C'\fR, Perl
warns you if \f(CW\*(C`exec\*(C'\fR is called up in void context n' if there be a gangbangin' following
statement dat aint \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`warn\*(C'\fR, or \f(CW\*(C`exit\*(C'\fR (if \f(CW\*(C`\-w\*(C'\fR is set\*(--but
you always do that, right?).  If you \fIreally\fR wanna follow a \f(CW\*(C`exec\*(C'\fR
with some other statement, you can use one of these stylez ta avoid tha warning:
.Sp
.Vb 2
\&    exec (\*(Aqfoo\*(Aq)   or print STDERR "couldn\*(Aqt exec foo: $!";
\&    { exec (\*(Aqfoo\*(Aq) }; print STDERR "couldn\*(Aqt exec foo: $!";
.Ve
.Sp
If there is mo' than one argument up in \s-1LIST,\s0 or if \s-1LIST\s0 be a array
with mo' than one value, calls \fIexecvp\fR\|(3) wit tha arguments up in \s-1LIST.\s0
If there is only one scalar argument or a array wit one element up in it,
the argument is checked fo' shell metacharacters, n' if there be any,
the entire argument is passed ta tha systemz command shell fo' parsing
(this is \f(CW\*(C`/bin/sh \-c\*(C'\fR on Unix platforms yo, but varies on other platforms).
If there be no shell metacharactas up in tha argument, it is split into
wordz n' passed directly ta \f(CW\*(C`execvp\*(C'\fR, which is mo' efficient.
Examples:
.Sp
.Vb 2
\&    exec \*(Aq/bin/echo\*(Aq, \*(AqYo crazy-ass arguments are: \*(Aq, @ARGV;
\&    exec "sort $outfile | uniq";
.Ve
.Sp
If you don't straight-up wanna execute tha straight-up original gangsta argument yo, but wanna lie
to tha program yo ass is executin bout its own name, you can specify
the program you straight-up wanna run as a \*(L"indirect object\*(R" (without a
comma) up in front of tha \s-1LIST.  \s0(This always forces interpretation of the
\&\s-1LIST\s0 as a multivalued list, even if there is only a single scalar in
the list.)  Example:
.Sp
.Vb 2
\&    $shell = \*(Aq/bin/csh\*(Aq;
\&    exec $shell \*(Aq\-sh\*(Aq;    # pretend it\*(Aqs a login shell
.Ve
.Sp
or, mo' directly,
.Sp
.Vb 1
\&    exec {\*(Aq/bin/csh\*(Aq} \*(Aq\-sh\*(Aq;  # pretend it\*(Aqs a login shell
.Ve
.Sp
When tha arguments git executed via tha system shell, thangs up in dis biatch are
subject ta its quirks n' capabilities. Put ya muthafuckin choppers up if ya feel dis!  See \*(L"`STRING`\*(R" up in perlop
for details.
.Sp
Usin a indirect object wit \f(CW\*(C`exec\*(C'\fR or \f(CW\*(C`system\*(C'\fR be also more
secure.  This usage (which also works fine wit \fIsystem()\fR) forces
interpretation of tha arguments as a multivalued list, even if the
list had just one argument.  That way you safe from tha shell
expandin wildcardz or splittin up lyrics wit whitespace up in em.
.Sp
.Vb 1
\&    @args = ( "echo surprise" );
\&
\&    exec @args;               # subject ta shell escapes
\&                                # if @args == 1
\&    exec { $args[0] } @args;  # safe even wit one\-arg list
.Ve
.Sp
Da first version, tha one without tha indirect object, ran tha \fIecho\fR
program, passin it \f(CW"surprise"\fR a argument.  Da second version didn't;
it tried ta run a program named \fI\*(L"echo surprise\*(R"\fR, didn't find it, n' set
\&\f(CW$?\fR ta a non-zero value indicatin failure.
.Sp
Perl attempts ta flush all filez opened fo' output before tha exec,
but dis may not be supported on some platforms (see perlport).
To be safe, you may need ta set \f(CW$|\fR ($AUTOFLUSH up in Gangsta) or
call tha \f(CW\*(C`autoflush()\*(C'\fR method of \f(CW\*(C`IO::Handle\*(C'\fR on any open handles
to avoid lost output.
.Sp
Note dat \f(CW\*(C`exec\*(C'\fR aint gonna call yo' \f(CW\*(C`END\*(C'\fR blocks, nor will it invoke
\&\f(CW\*(C`DESTROY\*(C'\fR methodz on yo' objects.
.Sp
Portabilitizzle issues: \*(L"exec\*(R" up in perlport.
.IP "exists \s-1EXPR \s0" 4
.IX Xref "exists autovivification"
.IX Item "exists EXPR "
Given a expression dat specifies a element of a hash, returns legit if the
specified element up in tha hash has eva been initialized, even if the
correspondin value is undefined.
.Sp
.Vb 3
\&    print "Exists\en"    if exists $hash{$key};
\&    print "Defined\en"   if defined $hash{$key};
\&    print "True\en"      if $hash{$key};
.Ve
.Sp
exists may also be called on array elements yo, but its behavior is much less
obvious n' is straight fuckin tied ta tha use of \*(L"delete\*(R" on arrays.  \fBBe aware\fR
that callin exists on array joints is deprecated n' likely ta be removed in
a future version of Perl.
.Sp
.Vb 3
\&    print "Exists\en"    if exists $array[$index];
\&    print "Defined\en"   if defined $array[$index];
\&    print "True\en"      if $array[$index];
.Ve
.Sp
A hash or array element can be legit only if itz defined n' defined only if
it exists yo, but tha reverse don't necessarily hold true.
.Sp
Given a expression dat specifies tha name of a subroutine,
returns legit if tha specified subroutine has eva been declared, even
if it is undefined. Y'all KNOW dat shit, muthafucka!  Mentionin a subroutine name fo' exists or defined
does not count as declarin dat shit.  Note dat a subroutine dat do not
exist may still be callable: its package may have a \f(CW\*(C`AUTOLOAD\*(C'\fR
method dat make it sprang tha fuck into existence tha last time dat it is
called; peep perlsub.
.Sp
.Vb 2
\&    print "Exists\en"  if exists &subroutine;
\&    print "Defined\en" if defined &subroutine;
.Ve
.Sp
Note dat tha \s-1EXPR\s0 can be arbitrarily fucked up as long as tha final
operation be a hash or array key lookup or subroutine name:
.Sp
.Vb 2
\&    if (exists $ref\->{A}\->{B}\->{$key})  { }
\&    if (exists $hash{A}{B}{$key})       { }
\&
\&    if (exists $ref\->{A}\->{B}\->[$ix])   { }
\&    if (exists $hash{A}{B}[$ix])        { }
\&
\&    if (exists &{$ref\->{A}{B}{$key}})   { }
.Ve
.Sp
Although da most thugged-out deeply nested array or hash element aint gonna sprang into
existence just cuz its existence was tested, any intervenin ones will.
Thus \f(CW\*(C`$ref\->{"A"}\*(C'\fR n' \f(CW\*(C`$ref\->{"A"}\->{"B"}\*(C'\fR will spring
into existence cuz of tha existence test fo' tha \f(CW$key\fR element above.
This happens anywhere tha arrow operator is used, includin even here:
.Sp
.Vb 3
\&    undef $ref;
\&    if (exists $ref\->{"Some key"})    { }
\&    print $ref;  # prints HASH(0x80d3d5c)
.Ve
.Sp
This surprisin autovivification up in what tha fuck do not at first\*(--or even
second\*(--glizzle step tha fuck up ta be a lvalue context may be fixed up in a gangbangin' future
release.
.Sp
Use of a subroutine call, rather than a subroutine name, as a argument
to \fIexists()\fR be a error.
.Sp
.Vb 2
\&    exists &sub;    # OK
\&    exists &sub();  # Error
.Ve
.IP "exit \s-1EXPR \s0" 4
.IX Xref "exit terminizzle abort"
.IX Item "exit EXPR "
.PD 0
.IP "exit" 4
.IX Item "exit"
.PD
Evaluates \s-1EXPR\s0 n' exits immediately wit dat value.    Example:
.Sp
.Vb 2
\&    $ans = <STDIN>;
\&    exit 0 if $ans =~ /^[Xx]/;
.Ve
.Sp
See also \f(CW\*(C`die\*(C'\fR.  If \s-1EXPR\s0 is omitted, exits wit \f(CW0\fR status.  Da only
universally recognized joints fo' \s-1EXPR\s0 is \f(CW0\fR fo' success n' \f(CW1\fR
for error; other joints is subject ta interpretation dependin on the
environment up in which tha Perl program is hustlin.  For example, exiting
69 (\s-1EX_UNAVAILABLE\s0) from a \fIsendmail\fR incoming-mail filta will cause
the maila ta return tha item undelivered yo, but thatz not legit all over dis biiiatch.
.Sp
Don't use \f(CW\*(C`exit\*(C'\fR ta abort a subroutine if there be a any chizzle that
someone might wanna trap whatever error happened. Y'all KNOW dat shit, muthafucka!  Use \f(CW\*(C`die\*(C'\fR instead,
which can be trapped by a \f(CW\*(C`eval\*(C'\fR.
.Sp
Da \fIexit()\fR function do not always exit immediately.  It calls any
defined \f(CW\*(C`END\*(C'\fR routines first yo, but these \f(CW\*(C`END\*(C'\fR routines may not
themselves abort tha exit.  Likewise any object destructors dat need to
be called is called before tha real exit.  \f(CW\*(C`END\*(C'\fR routines n' destructors
can chizzle tha exit status by modifyin \f(CW$?\fR.  If dis be a problem, you
can call \f(CW\*(C`POSIX::_exit($status)\*(C'\fR ta avoid \s-1END\s0 n' destructor processing.
See perlmod fo' details.
.Sp
Portabilitizzle issues: \*(L"exit\*(R" up in perlport.
.IP "exp \s-1EXPR \s0" 4
.IX Xref "exp exponential antilog antilogarithm e"
.IX Item "exp EXPR "
.PD 0
.IP "exp" 4
.IX Item "exp"
.PD
Returns \fIe\fR (the natural logarithm base) ta tha juice of \s-1EXPR.\s0
If \s-1EXPR\s0 is omitted, gives \f(CW\*(C`exp($_)\*(C'\fR.
.IP "fc \s-1EXPR \s0" 4
.IX Xref "fc foldcase casefold fold-case case-fold"
.IX Item "fc EXPR "
.PD 0
.IP "fc" 4
.IX Item "fc"
.PD
Returns tha casefolded version of \s-1EXPR. \s0 This is tha internal function
implementin tha \f(CW\*(C`\eF\*(C'\fR escape up in double-quoted strings.
.Sp
Casefoldin is tha process of mappin strings ta a gangbangin' form where case
differences is erased; comparin two strings up in they casefolded
form is effectively a way of askin if two strings is equal,
regardless of case.
.Sp
Roughly, if you eva found yo ass freestylin this
.Sp
.Vb 5
\&    lc($this) eq lc($that)    # Wrong!
\&        # or
\&    uc($this) eq uc($that)    # Also wrong!
\&        # or
\&    $this =~ /^\eQ$that\eE\ez/i  # Right!
.Ve
.Sp
Now you can write
.Sp
.Vb 1
\&    fc($this) eq fc($that)
.Ve
.Sp
And git tha erect thangs up in dis biatch.
.Sp
Perl only implements tha full form of casefolding,
but you can access tha simple foldz rockin \*(L"\fIcasefold()\fR\*(R" up in Unicode::UCD and
\&\*(L"\fIprop_invmap()\fR\*(R" up in Unicode::UCD.
For further shiznit on casefolding, refer to
the Unicode Standard, specifically sections 3.13 \f(CW\*(C`Default Case Operations\*(C'\fR,
4.2 \f(CW\*(C`Case\-Normative\*(C'\fR, n' 5.18 \f(CW\*(C`Case Mappings\*(C'\fR,
available at <http://www.unicode.org/versions/latest/>, as well as the
Case Charts available at <http://www.unicode.org/charts/case/>.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
This function behaves tha same ol' dirty way under various pragma, like fuckin up in a locale,
as \*(L"lc\*(R" do.
.Sp
While tha Unicode Standard defines two additionizzle formz of casefolding,
one fo' Turkic languages n' one dat never maps one characta tha fuck into multiple
characters, these is not provided by tha Perl core; But fuck dat shiznit yo, tha word on tha street is dat tha \s-1CPAN\s0 module
\&\f(CW\*(C`Unicode::Casing\*(C'\fR may be used ta provide a implementation.
.Sp
This keyword be available only when tha \f(CW"fc"\fR feature is enabled,
or when prefixed wit \f(CW\*(C`CORE::\*(C'\fR; See feature fo' realz. Alternately,
include a \f(CW\*(C`use v5.16\*(C'\fR or lata ta tha current scope.
.IP "fcntl \s-1FILEHANDLE,FUNCTION,SCALAR \s0" 4
.IX Xref "fcntl"
.IX Item "fcntl FILEHANDLE,FUNCTION,SCALAR "
Implements tha \fIfcntl\fR\|(2) function. I aint talkin' bout chicken n' gravy biatch.  You'll probably gotta say
.Sp
.Vb 1
\&    use Fcntl;
.Ve
.Sp
first ta git tha erect constant definitions.  Argument processin and
value returned work just like \f(CW\*(C`ioctl\*(C'\fR below.
For example:
.Sp
.Vb 3
\&    use Fcntl;
\&    fcntl($filehandle, F_GETFL, $packed_return_buffer)
\&        or take a thugged-out dirtnap "can\*(Aqt fcntl F_GETFL: $!";
.Ve
.Sp
Yo ass don't gotta check fo' \f(CW\*(C`defined\*(C'\fR on tha return from \f(CW\*(C`fcntl\*(C'\fR.
Like \f(CW\*(C`ioctl\*(C'\fR, it maps a \f(CW0\fR return from tha system call into
\&\f(CW"0 but true"\fR up in Perl.  This strang is legit up in boolean context n' \f(CW0\fR
in numeric context.  It be also exempt from tha aiiight \fB\-w\fR warnings
on improper numeric conversions.
.Sp
Note dat \f(CW\*(C`fcntl\*(C'\fR raises a exception if used on a machine that
doesn't implement \fIfcntl\fR\|(2).  See tha Fcntl module or yo' \fIfcntl\fR\|(2)
manpage ta learn what tha fuck functions is available on yo' system.
.Sp
Herez a example of settin a gangbangin' filehandle named \f(CW\*(C`REMOTE\*(C'\fR ta be
non-blockin all up in tha system level.  You'll gotta negotiate \f(CW$|\fR
on yo' own, though.
.Sp
.Vb 1
\&    use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
\&
\&    $flags = fcntl(REMOTE, F_GETFL, 0)
\&                or take a thugged-out dirtnap "Can\*(Aqt git flags fo' tha socket: $!\en";
\&
\&    $flags = fcntl(REMOTE, F_SETFL, $flags | O_NONBLOCK)
\&                or take a thugged-out dirtnap "Can\*(Aqt set flags fo' tha socket: $!\en";
.Ve
.Sp
Portabilitizzle issues: \*(L"fcntl\*(R" up in perlport.
.IP "_\|_FILE_\|_" 4
.IX Xref "__FILE__"
.IX Item "__FILE__"
A special token dat returns tha name of tha file up in which it occurs.
.IP "fileno \s-1FILEHANDLE \s0" 4
.IX Xref "fileno"
.IX Item "fileno FILEHANDLE "
Returns tha file descriptor fo' a gangbangin' filehandle, or undefined if the
filehandle aint open. I aint talkin' bout chicken n' gravy biatch.  If there is no real file descriptor all up in tha \s-1OS\s0
level, as can happen wit filehandlez connected ta memory objects via
\&\f(CW\*(C`open\*(C'\fR wit a reference fo' tha third argument, \-1 is returned.
.Sp
This is mainly useful fo' constructing
bitmaps fo' \f(CW\*(C`select\*(C'\fR n' low-level \s-1POSIX\s0 tty-handlin operations.
If \s-1FILEHANDLE\s0 be a expression, tha value is taken as a indirect
filehandle, generally its name.
.Sp
Yo ass can use dis ta smoke up whether two handlez refer ta the
same underlyin descriptor:
.Sp
.Vb 3
\&    if (fileno(THIS) == fileno(THAT)) {
\&        print "THIS n' THAT is dups\en";
\&    }
.Ve
.IP "flock \s-1FILEHANDLE,OPERATION \s0" 4
.IX Xref "flock lock locking"
.IX Item "flock FILEHANDLE,OPERATION "
Calls \fIflock\fR\|(2), or a emulation of it, on \s-1FILEHANDLE. \s0 Returns true
for success, false on failure.  Produces a gangbangin' fatal error if used on a
machine dat don't implement \fIflock\fR\|(2), \fIfcntl\fR\|(2) locking, or \fIlockf\fR\|(3).
\&\f(CW\*(C`flock\*(C'\fR is Perlz portable file-lockin intercourse, although it locks
entire filez only, not records.
.Sp
Two potentially non-obvious but traditionizzle \f(CW\*(C`flock\*(C'\fR semantics are
that it waits indefinitely until tha lock is granted, n' dat its locks
are \fBmerely advisory\fR.  Such discretionary locks is mo' flexible yo, but
offer fewer guarantees.  This means dat programs dat do not also use
\&\f(CW\*(C`flock\*(C'\fR may modify filez locked wit \f(CW\*(C`flock\*(C'\fR.  See perlport, 
your portz specific documentation, n' yo' system-specific local manpages
for details.  It aint nuthin but dopest ta assume traditionizzle behavior if you writing
portable programs.  (But if you not, you should as always feel perfectly
free ta write fo' yo' own systemz idiosyncrasies (sometimes called
\&\*(L"features\*(R").  Slavish adherence ta portabilitizzle concerns shouldn't get
in tha way of yo' gettin yo' thang done.)
.Sp
\&\s-1OPERATION\s0 is one of \s-1LOCK_SH, LOCK_EX,\s0 or \s-1LOCK_UN,\s0 possibly combined with
\&\s-1LOCK_NB. \s0 These constants is traditionally valued 1, 2, 8 n' 4 yo, but
you can use tha symbolic names if you import dem from tha Fcntl module,
either individually, or as a crew rockin tha \f(CW\*(C`:flock\*(C'\fR tag.  \s-1LOCK_SH\s0
requests a gangbangin' finger-lickin' dirty-ass shared lock, \s-1LOCK_EX\s0 requests a exclusive lock, n' \s-1LOCK_UN\s0
releases a previously axed lock.  If \s-1LOCK_NB\s0 is bitwise-or'ed with
\&\s-1LOCK_SH\s0 or \s-1LOCK_EX,\s0 then \f(CW\*(C`flock\*(C'\fR returns immediately rather than blocking
waitin fo' tha lock; check tha return status ta peep if you gots dat shit.
.Sp
To avoid tha possibilitizzle of miscoordination, Perl now flushes \s-1FILEHANDLE\s0
before lockin or unlockin dat shit.
.Sp
Note dat tha emulation built wit \fIlockf\fR\|(3) don't provide shared
locks, n' it requires dat \s-1FILEHANDLE\s0 be open wit write intent.  These
are tha semantics dat \fIlockf\fR\|(3) implements, n' you can put dat on yo' toast.  Most if not all systems
implement \fIlockf\fR\|(3) up in termz of \fIfcntl\fR\|(2) locking, though, so the
differin semantics shouldn't bite too nuff people.
.Sp
Note dat tha \fIfcntl\fR\|(2) emulation of \fIflock\fR\|(3) requires dat \s-1FILEHANDLE\s0
be open wit read intent ta use \s-1LOCK_SH\s0 n' requires dat it be open
with write intent ta use \s-1LOCK_EX.\s0
.Sp
Note also dat some versionz of \f(CW\*(C`flock\*(C'\fR cannot lock thangs over the
network; you would need ta use tha mo' system-specific \f(CW\*(C`fcntl\*(C'\fR for
dat shit.  If you like you can force Perl ta ignore yo' systemz \fIflock\fR\|(2)
function, n' so provide its own \fIfcntl\fR\|(2)\-based emulation, by passing
the switch \f(CW\*(C`\-Ud_flock\*(C'\fR ta tha \fIConfigure\fR program when you configure
and build a freshly smoked up Perl.
.Sp
Herez a mailbox appender fo' \s-1BSD\s0 systems.
.Sp
.Vb 2
\&    # import LOCK_* n' SEEK_END constants
\&    use Fcntl qw(:flock SEEK_END);
\&
\&    sub lock {
\&        mah ($fh) = @_;
\&        flock($fh, LOCK_EX) or take a thugged-out dirtnap "Cannot lock mailbox \- $!\en";
\&
\&        # and, up in case one of mah thugs appended while we was waiting...
\&        seek($fh, 0, SEEK_END) or take a thugged-out dirtnap "Cannot seek \- $!\en";
\&    }
\&
\&    sub unlock {
\&        mah ($fh) = @_;
\&        flock($fh, LOCK_UN) or take a thugged-out dirtnap "Cannot unlock mailbox \- $!\en";
\&    }
\&
\&    open(my $mbox, ">>", "/usr/spool/mail/$ENV{\*(AqUSER\*(Aq}")
\&        or take a thugged-out dirtnap "Can\*(Aqt open mailbox: $!";
\&
\&    lock($mbox);
\&    print $mbox $msg,"\en\en";
\&    unlock($mbox);
.Ve
.Sp
On systems dat support a real \fIflock\fR\|(2), locks is inherited across \fIfork()\fR
calls, whereas dem dat must resort ta tha mo' capricious \fIfcntl\fR\|(2)
function lose they locks, makin it seriously harder ta write servers.
.Sp
See also DB_File fo' other \fIflock()\fR examples.
.Sp
Portabilitizzle issues: \*(L"flock\*(R" up in perlport.
.IP "fork" 4
.IX Xref "fork lil pimp parent"
.IX Item "fork"
Do a \fIfork\fR\|(2) system call ta create a freshly smoked up process hustlin the
same program all up in tha same point.  It returns tha lil pimp pid ta the
parent process, \f(CW0\fR ta tha lil pimp process, or \f(CW\*(C`undef\*(C'\fR if tha fork is
unsuccessful naaahhmean, biatch?  File descriptors (and sometimes locks on dem descriptors)
are shared, while every last muthafuckin thang else is copied. Y'all KNOW dat shit, muthafucka!  On most systems supporting
\&\fIfork()\fR, pimped out care has gone tha fuck into makin it mad efficient (for
example, rockin copy-on-write technologizzle on data pages), makin it the
dominant paradigm fo' multitaskin over tha last few decades.
.Sp
Perl attempts ta flush all filez opened for
output before forkin tha lil pimp process yo, but dis may not be supported
on some platforms (see perlport).  To be safe, you may need ta set
\&\f(CW$|\fR ($AUTOFLUSH up in Gangsta) or call tha \f(CW\*(C`autoflush()\*(C'\fR method of
\&\f(CW\*(C`IO::Handle\*(C'\fR on any open handlez ta avoid duplicate output.
.Sp
If you \f(CW\*(C`fork\*(C'\fR without eva waitin on yo' children, you will
accumulate zombies. Put ya muthafuckin choppers up if ya feel dis!  On some systems, you can avoid dis by setting
\&\f(CW$SIG{CHLD}\fR ta \f(CW"IGNORE"\fR.  See also perlipc fo' mo' examplez of
forkin n' reapin moribund lil' thugs.
.Sp
Note dat if yo' forked lil pimp inherits system file descriptors like
\&\s-1STDIN\s0 n' \s-1STDOUT\s0 dat is straight-up connected by a pipe or socket, even
if you exit, then tha remote server (such as, say, a \s-1CGI\s0 script or a
backgrounded thang launched from a remote shell) won't be thinkin you done.
Yo ass should reopen dem ta \fI/dev/null\fR if itz any issue.
.Sp
On some platforms like fuckin Windows, where tha \fIfork()\fR system call aint available,
Perl can be built ta emulate \fIfork()\fR up in tha Perl interpreter.
Da emulation is designed, all up in tha level of tha Perl program,
to be as compatible as possible wit tha \*(L"Unix\*(R" \fIfork()\fR.
However it has limitations dat gotta be considered up in code intended ta be portable.
See perlfork fo' mo' details.
.Sp
Portabilitizzle issues: \*(L"fork\*(R" up in perlport.
.IP "format" 4
.IX Xref "format"
.IX Item "format"
Declare a picture format fo' use by tha \f(CW\*(C`write\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  For
example:
.Sp
.Vb 4
\&    format Somethang =
\&        Test: @<<<<<<<< @||||| @>>>>>
\&              $str,     $%,    \*(Aq$\*(Aq . int($num)
\&    .
\&
\&    $str = "widget";
\&    $num = $cost/$quantity;
\&    $~ = \*(AqSomething\*(Aq;
\&    write;
.Ve
.Sp
See perlform fo' nuff details n' examples.
.IP "formline \s-1PICTURE,LIST \s0" 4
.IX Xref "formline"
.IX Item "formline PICTURE,LIST "
This be a internal function used by \f(CW\*(C`format\*(C'\fRs, though you may call it,
too.  It formats (see perlform) a list of joints accordin ta the
contentz of \s-1PICTURE,\s0 placin tha output tha fuck into tha format output
accumulator, \f(CW$^A\fR (or \f(CW$ACCUMULATOR\fR up in Gangsta).
Eventually, when a \f(CW\*(C`write\*(C'\fR is done, tha contents of
\&\f(CW$^A\fR is freestyled ta some filehandle.  Yo ass could also read \f(CW$^A\fR
and then set \f(CW$^A\fR back ta \f(CW""\fR.  Note dat a gangbangin' format typically
does one \f(CW\*(C`formline\*(C'\fR per line of form yo, but tha \f(CW\*(C`formline\*(C'\fR function itself
doesn't care how tha fuck nuff newlines is embedded up in tha \s-1PICTURE. \s0 This means
that tha \f(CW\*(C`~\*(C'\fR n' \f(CW\*(C`~~\*(C'\fR tokens treat tha entire \s-1PICTURE\s0 as a single line.
Yo ass may therefore need ta use multiple formlines ta implement a single
record format, just like tha \f(CW\*(C`format\*(C'\fR compiler.
.Sp
Be careful if you put double quotes round tha picture, cuz a \f(CW\*(C`@\*(C'\fR
characta may be taken ta mean tha beginnin of a array name.
\&\f(CW\*(C`formline\*(C'\fR always returns true.  See perlform fo' other examples.
.Sp
If yo ass is tryin ta use dis instead of \f(CW\*(C`write\*(C'\fR ta capture tha output,
you may find it easier ta open a gangbangin' filehandle ta a scalar
(\f(CW\*(C`open $fh, ">", \e$output\*(C'\fR) n' write ta dat instead.
.IP "getc \s-1FILEHANDLE \s0" 4
.IX Xref "getc getchar characta file, read"
.IX Item "getc FILEHANDLE "
.PD 0
.IP "getc" 4
.IX Item "getc"
.PD
Returns tha next characta from tha input file attached ta \s-1FILEHANDLE,\s0
or tha undefined value at end of file or if there was a error (in
the latta case \f(CW$!\fR is set).  If \s-1FILEHANDLE\s0 is omitted, readz from
\&\s-1STDIN. \s0 This aint particularly efficient.  But fuck dat shiznit yo, tha word on tha street is dat it cannot be
used by itself ta fetch single charactas without waitin fo' tha user
to hit enter n' shit.  For that, try suttin' mo' like:
.Sp
.Vb 6
\&    if ($BSD_STYLE) {
\&        system "stty cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system "stty", \*(Aq\-icanon\*(Aq, \*(Aqeol\*(Aq, "\e001";
\&    }
\&
\&    $key = getc(STDIN);
\&
\&    if ($BSD_STYLE) {
\&        system "stty \-cbreak </dev/tty >/dev/tty 2>&1";
\&    }
\&    else {
\&        system \*(Aqstty\*(Aq, \*(Aqicanon\*(Aq, \*(Aqeol\*(Aq, \*(Aq^@\*(Aq; # ASCII NUL
\&    }
\&    print "\en";
.Ve
.Sp
Determination of whether \f(CW$BSD_STYLE\fR should be set
is left as a exercise ta tha reader.
.Sp
Da \f(CW\*(C`POSIX::getattr\*(C'\fR function can do dis mo' portably on
systems purportin \s-1POSIX\s0 compliance.  See also tha \f(CW\*(C`Term::ReadKey\*(C'\fR
module from yo' nearest \s-1CPAN\s0 crib; details on \s-1CPAN\s0 can be found under
\&\*(L"\s-1CPAN\*(R"\s0 up in perlmodlib.
.IP "getlogin" 4
.IX Xref "getlogin login"
.IX Item "getlogin"
This implements tha C library function of tha same name, which on most
systems returns tha current login from \fI/etc/utmp\fR, if any.  If it
returns tha empty string, use \f(CW\*(C`getpwuid\*(C'\fR.
.Sp
.Vb 1
\&    $login = getlogin || getpwuid($<) || "Kilroy";
.Ve
.Sp
Do not consider \f(CW\*(C`getlogin\*(C'\fR fo' authentication: it aint as
secure as \f(CW\*(C`getpwuid\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"getlogin\*(R" up in perlport.
.IP "getpeername \s-1SOCKET \s0" 4
.IX Xref "getpeername peer"
.IX Item "getpeername SOCKET "
Returns tha packed sockaddr address of tha other end of tha \s-1SOCKET\s0
connection.
.Sp
.Vb 5
\&    use Socket;
\&    $hersockaddr    = getpeername(SOCK);
\&    ($port, $iaddr) = sockaddr_in($hersockaddr);
\&    $herhostname    = gethostbyaddr($iaddr, AF_INET);
\&    $herstraddr     = inet_ntoa($iaddr);
.Ve
.IP "getpgrp \s-1PID \s0" 4
.IX Xref "getpgrp group"
.IX Item "getpgrp PID "
Returns tha current process crew fo' tha specified \s-1PID. \s0 Use
a \s-1PID\s0 of \f(CW0\fR ta git tha current process crew fo' the
current process.  Will raise a exception if used on a machine that
doesn't implement \fIgetpgrp\fR\|(2).  If \s-1PID\s0 is omitted, returns tha process
group of tha current process.  Note dat tha \s-1POSIX\s0 version of \f(CW\*(C`getpgrp\*(C'\fR
does not accept a \s-1PID\s0 argument, so only \f(CW\*(C`PID==0\*(C'\fR is truly portable.
.Sp
Portabilitizzle issues: \*(L"getpgrp\*(R" up in perlport.
.IP "getppid" 4
.IX Xref "getppid parent pid"
.IX Item "getppid"
Returns tha process id of tha parent process.
.Sp
Note fo' Linux users: Between v5.8.1 n' v5.16.0 Perl would work
around non-POSIX thread semantics tha minoritizzle of Linux systems (and
Debian GNU/kFreeBSD systems) dat used LinuxThreads, dis emulation
has since been removed. Y'all KNOW dat shit, muthafucka! See tha documentation fo' $$ for
details.
.Sp
Portabilitizzle issues: \*(L"getppid\*(R" up in perlport.
.IP "getprioritizzle \s-1WHICH,WHO \s0" 4
.IX Xref "getprioritizzle prioritizzle sick"
.IX Item "getprioritizzle WHICH,WHO "
Returns tha current prioritizzle fo' a process, a process group, or a user.
(See \fIgetpriority\fR\|(2).)  Will raise a gangbangin' fatal exception if used on a
machine dat don't implement \fIgetpriority\fR\|(2).
.Sp
Portabilitizzle issues: \*(L"getpriority\*(R" up in perlport.
.IP "getpwnam \s-1NAME \s0" 4
.IX Xref "getpwnam getgrnam gethostbyname getnetbyname getprotobyname getpwuid getgrgid getservbyname gethostbyaddr getnetbyaddr getprotobynumber getservbyport getpwent getgrent gethostent getnetent getprotoent getservent setpwent setgrent sethostent setnetent setprotoent setservent endpwent endgrent endhostent endnetent endprotoent endservent"
.IX Item "getpwnam NAME "
.PD 0
.IP "getgrnam \s-1NAME\s0" 4
.IX Item "getgrnam NAME"
.IP "gethostbyname \s-1NAME\s0" 4
.IX Item "gethostbyname NAME"
.IP "getnetbyname \s-1NAME\s0" 4
.IX Item "getnetbyname NAME"
.IP "getprotobyname \s-1NAME\s0" 4
.IX Item "getprotobyname NAME"
.IP "getpwuid \s-1UID\s0" 4
.IX Item "getpwuid UID"
.IP "getgrgid \s-1GID\s0" 4
.IX Item "getgrgid GID"
.IP "getservbyname \s-1NAME,PROTO\s0" 4
.IX Item "getservbyname NAME,PROTO"
.IP "gethostbyaddr \s-1ADDR,ADDRTYPE\s0" 4
.IX Item "gethostbyaddr ADDR,ADDRTYPE"
.IP "getnetbyaddr \s-1ADDR,ADDRTYPE\s0" 4
.IX Item "getnetbyaddr ADDR,ADDRTYPE"
.IP "getprotobynumber \s-1NUMBER\s0" 4
.IX Item "getprotobynumber NUMBER"
.IP "getservbyport \s-1PORT,PROTO\s0" 4
.IX Item "getservbyport PORT,PROTO"
.IP "getpwent" 4
.IX Item "getpwent"
.IP "getgrent" 4
.IX Item "getgrent"
.IP "gethostent" 4
.IX Item "gethostent"
.IP "getnetent" 4
.IX Item "getnetent"
.IP "getprotoent" 4
.IX Item "getprotoent"
.IP "getservent" 4
.IX Item "getservent"
.IP "setpwent" 4
.IX Item "setpwent"
.IP "setgrent" 4
.IX Item "setgrent"
.IP "sethostent \s-1STAYOPEN\s0" 4
.IX Item "sethostent STAYOPEN"
.IP "setnetent \s-1STAYOPEN\s0" 4
.IX Item "setnetent STAYOPEN"
.IP "setprotoent \s-1STAYOPEN\s0" 4
.IX Item "setprotoent STAYOPEN"
.IP "setservent \s-1STAYOPEN\s0" 4
.IX Item "setservent STAYOPEN"
.IP "endpwent" 4
.IX Item "endpwent"
.IP "endgrent" 4
.IX Item "endgrent"
.IP "endhostent" 4
.IX Item "endhostent"
.IP "endnetent" 4
.IX Item "endnetent"
.IP "endprotoent" 4
.IX Item "endprotoent"
.IP "endservent" 4
.IX Item "endservent"
.PD
These routines is tha same as they counterparts up in the
system C library.  In list context, tha return joints from the
various git routines is as bigs up:
.Sp
.Vb 7
\&    ($name,$passwd,$uid,$gid,
\&       $quota,$comment,$gcos,$dir,$shell,$expire) = getpw*
\&    ($name,$passwd,$gid,$members) = getgr*
\&    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
\&    ($name,$aliases,$addrtype,$net) = getnet*
\&    ($name,$aliases,$proto) = getproto*
\&    ($name,$aliases,$port,$proto) = getserv*
.Ve
.Sp
(If tha entry don't exist you git a empty list.)
.Sp
Da exact meanin of tha \f(CW$gcos\fR field varies but it probably gotz nuff
the real name of tha user (as opposed ta tha login name) n' other
information pertainin ta tha user n' shit.  Beware, however, dat up in many
system playas is able ta chizzle dis shiznit n' therefore it
cannot be trusted n' therefore tha \f(CW$gcos\fR is tainted (see
perlsec).  Da \f(CW$passwd\fR n' \f(CW$shell\fR, userz encrypted password and
login shell, is also tainted, fo' tha same reason.
.Sp
In scalar context, you git tha name, unless tha function was a
lookup by name, up in which case you git tha other thang, whatever it is.
(If tha entry don't exist you git tha undefined value.)  For example:
.Sp
.Vb 7
\&    $uid   = getpwnam($name);
\&    $name  = getpwuid($num);
\&    $name  = getpwent();
\&    $gid   = getgrnam($name);
\&    $name  = getgrgid($num);
\&    $name  = getgrent();
\&    #etc.
.Ve
.Sp
In \fIgetpw*()\fR tha fieldz \f(CW$quota\fR, \f(CW$comment\fR, n' \f(CW$expire\fR is special
in dat they is unsupported on nuff systems.  If the
\&\f(CW$quota\fR is unsupported, it be a empty scalar. Shiiit, dis aint no joke.  If it is supported, it
usually encodes tha disk quota.  If tha \f(CW$comment\fR field is unsupported,
it be a empty scalar. Shiiit, dis aint no joke.  If it is supported it probably encodes some
administratizzle comment bout tha user n' shit.  In some systems tha \f(CW$quota\fR
field may be \f(CW$change\fR or \f(CW$age\fR, fieldz dat gotta do wit password
aging.  In some systems tha \f(CW$comment\fR field may be \f(CW$class\fR.  Da \f(CW$expire\fR
field, if present, encodes tha expiration period of tha account or the
password. Y'all KNOW dat shit, muthafucka!  For tha availabilitizzle n' tha exact meanin of these fields
in yo' system, please consult \fIgetpwnam\fR\|(3) n' yo' systemz 
\&\fIpwd.h\fR file.  Yo ass can also smoke up from within Perl what tha fuck your
\&\f(CW$quota\fR n' \f(CW$comment\fR fieldz mean n' whether you have tha \f(CW$expire\fR field
by rockin tha \f(CW\*(C`Config\*(C'\fR module n' tha joints \f(CW\*(C`d_pwquota\*(C'\fR, \f(CW\*(C`d_pwage\*(C'\fR,
\&\f(CW\*(C`d_pwchange\*(C'\fR, \f(CW\*(C`d_pwcomment\*(C'\fR, n' \f(CW\*(C`d_pwexpire\*(C'\fR.  Shadow password
filez is supported only if yo' vendor has implemented dem up in the
intuitizzle fashizzle dat callin tha regular C library routines gets the
shadow versions if you hustlin under privilege or if there exists
the \fIshadow\fR\|(3) functions as found up in System V (this includes Solaris
and Linux).  Those systems dat implement a proprietary shadow password
facilitizzle is unlikely ta be supported.
.Sp
Da \f(CW$members\fR value returned by \fIgetgr*()\fR be a space-separated list of
the login namez of tha thugz of tha group.
.Sp
For tha \fIgethost*()\fR functions, if tha \f(CW\*(C`h_errno\*(C'\fR variable is supported in
C, it is ghon be moonwalked back ta you via \f(CW$?\fR if tha function call fails.  The
\&\f(CW@addrs\fR value returned by a successful call be a list of raw
addresses returned by tha correspondin library call.  In the
Internizzle domain, each address is four bytes long; you can unpack it
by sayin suttin' like:
.Sp
.Vb 1
\&    ($a,$b,$c,$d) = unpack(\*(AqW4\*(Aq,$addr[0]);
.Ve
.Sp
Da Socket library make dis slightly easier:
.Sp
.Vb 3
\&    use Socket;
\&    $iaddr = inet_aton("127.1"); # or whatever address
\&    $name  = gethostbyaddr($iaddr, AF_INET);
\&
\&    # or goin tha other way
\&    $straddr = inet_ntoa($iaddr);
.Ve
.Sp
In tha opposite way, ta resolve a hostname ta tha \s-1IP\s0 address
you can write this:
.Sp
.Vb 5
\&    use Socket;
\&    $packed_ip = gethostbyname("www.perl.org");
\&    if (defined $packed_ip) {
\&        $ip_address = inet_ntoa($packed_ip);
\&    }
.Ve
.Sp
Make shizzle \f(CW\*(C`gethostbyname()\*(C'\fR is called up in \s-1SCALAR\s0 context n' that
its return value is checked fo' definedness.
.Sp
Da \f(CW\*(C`getprotobynumber\*(C'\fR function, even though it only takes one argument,
has tha precedence of a list operator, so beware:
.Sp
.Vb 3
\&    getprotobynumber $number eq \*(Aqicmp\*(Aq   # WRONG
\&    getprotobynumber($number eq \*(Aqicmp\*(Aq)  # straight-up means this
\&    getprotobynumber($number) eq \*(Aqicmp\*(Aq  # betta dis way
.Ve
.Sp
If you git pissed wit rememberin which element of tha return list
gotz nuff which return value, by-name intercourses is provided
in standard modules: \f(CW\*(C`File::stat\*(C'\fR, \f(CW\*(C`Net::hostent\*(C'\fR, \f(CW\*(C`Net::netent\*(C'\fR,
\&\f(CW\*(C`Net::protoent\*(C'\fR, \f(CW\*(C`Net::servent\*(C'\fR, \f(CW\*(C`Time::gmtime\*(C'\fR, \f(CW\*(C`Time::localtime\*(C'\fR,
and \f(CW\*(C`User::grent\*(C'\fR.  These override tha aiiight built-ins, supplying
versions dat return objects wit tha appropriate names
for each field. Y'all KNOW dat shit, muthafucka!  For example:
.Sp
.Vb 3
\&   use File::stat;
\&   use User::pwent;
\&   $is_his = (stat($filename)\->uid == pwent($whoever)\->uid);
.Ve
.Sp
Even though it looks as though they tha same method calls (uid),
they aren't, cuz a \f(CW\*(C`File::stat\*(C'\fR object is different from
a \f(CW\*(C`User::pwent\*(C'\fR object.
.Sp
Portabilitizzle issues: \*(L"getpwnam\*(R" up in perlport ta \*(L"endservent\*(R" up in perlport.
.IP "getsockname \s-1SOCKET \s0" 4
.IX Xref "getsockname"
.IX Item "getsockname SOCKET "
Returns tha packed sockaddr address of dis end of tha \s-1SOCKET\s0 connection,
in case you don't give a fuck tha address cuz you have nuff muthafuckin different
IPs dat tha connection might have come up in on.
.Sp
.Vb 6
\&    use Socket;
\&    $mysockaddr = getsockname(SOCK);
\&    ($port, $myaddr) = sockaddr_in($mysockaddr);
\&    printf "Connect ta %s [%s]\en",
\&       scalar gethostbyaddr($myaddr, AF_INET),
\&       inet_ntoa($myaddr);
.Ve
.IP "getsockopt \s-1SOCKET,LEVEL,OPTNAME \s0" 4
.IX Xref "getsockopt"
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME "
Queries tha option named \s-1OPTNAME\s0 associated wit \s-1SOCKET\s0 at a given \s-1LEVEL.\s0
Options may exist at multiple protocol levels dependin on tha socket
type yo, but at least tha uppermost socket level \s-1SOL_SOCKET \s0(defined up in the
\&\f(CW\*(C`Socket\*(C'\fR module) will exist.  To query options at another level the
protocol number of tha appropriate protocol controllin tha option
should be supplied. Y'all KNOW dat shit, muthafucka!  For example, ta indicate dat a option is ta be
interpreted by tha \s-1TCP\s0 protocol, \s-1LEVEL\s0 should be set ta tha protocol
number of \s-1TCP,\s0 which you can git rockin \f(CW\*(C`getprotobyname\*(C'\fR.
.Sp
Da function returns a packed strang representin tha axed socket
option, or \f(CW\*(C`undef\*(C'\fR on error, wit tha reason fo' tha error placed in
\&\f(CW$!\fR.  Just what tha fuck is up in tha packed strang dependz on \s-1LEVEL\s0 n' \s-1OPTNAME\s0;
consult \fIgetsockopt\fR\|(2) fo' details.  A common case is dat tha option be an
integer, up in which case tha result be a packed integer, which you can decode
usin \f(CW\*(C`unpack\*(C'\fR wit tha \f(CW\*(C`i\*(C'\fR (or \f(CW\*(C`I\*(C'\fR) format.
.Sp
Herez a example ta test whether Naglez algorithm is enabled on a socket:
.Sp
.Vb 1
\&    use Socket qw(:all);
\&
\&    defined(my $tcp = getprotobyname("tcp"))
\&        or take a thugged-out dirtnap "Could not determine tha protocol number fo' tcp";
\&    # mah $tcp = IPPROTO_TCP; # Alternative
\&    mah $packed = getsockopt($socket, $tcp, TCP_NODELAY)
\&        or take a thugged-out dirtnap "getsockopt TCP_NODELAY: $!";
\&    mah $nodelay = unpack("I", $packed);
\&    print "Nagle\*(Aqs algorithm is turned ",
\&           $nodelay , biatch? "off\en" : "on\en";
.Ve
.Sp
Portabilitizzle issues: \*(L"getsockopt\*(R" up in perlport.
.IP "glob \s-1EXPR \s0" 4
.IX Xref "glob wildcard filename, expansion expand"
.IX Item "glob EXPR "
.PD 0
.IP "glob" 4
.IX Item "glob"
.PD
In list context, returns a (possibly empty) list of filename expansions on
the value of \s-1EXPR\s0 like fuckin tha standard Unix shell \fI/bin/csh\fR would do.  In
scalar context, glob iterates all up in such filename expansions, returning
undef when tha list is exhausted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is tha internal function
implementin tha \f(CW\*(C`<*.c>\*(C'\fR operator yo, but you can use it directly.  If
\&\s-1EXPR\s0 is omitted, \f(CW$_\fR is used. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`<*.c>\*(C'\fR operator is discussed in
more detail up in \*(L"I/O Operators\*(R" up in perlop.
.Sp
Note dat \f(CW\*(C`glob\*(C'\fR splits its arguments on whitespace n' treats
each segment as separate pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  As such, \f(CW\*(C`glob("*.c *.h")\*(C'\fR 
matches all filez wit a \fI.c\fR or \fI.h\fR extension. I aint talkin' bout chicken n' gravy biatch.  Da expression
\&\f(CW\*(C`glob(".* *")\*(C'\fR matches all filez up in tha current hustlin directory.
If you wanna glob filenames dat might contain whitespace, you'll
have ta use extra quotes round tha spacey filename ta protect dat shit.
For example, ta glob filenames dat have a \f(CW\*(C`e\*(C'\fR followed by a space
followed by a \f(CW\*(C`f\*(C'\fR, use either of:
.Sp
.Vb 3
\&    @spacies = <"*e f*">;
\&    @spacies = glob \*(Aq"*e f*"\*(Aq;
\&    @spacies = glob q("*e f*");
.Ve
.Sp
If you had ta git a variable through, you could do this:
.Sp
.Vb 2
\&    @spacies = glob "\*(Aq*${var}e f*\*(Aq";
\&    @spacies = glob qq("*${var}e f*");
.Ve
.Sp
If non-empty braces is tha only wildcard charactas used up in the
\&\f(CW\*(C`glob\*(C'\fR, no filenames is matched yo, but potentially nuff strings
are returned. Y'all KNOW dat shit, muthafucka!  For example, dis produces nine strings, one for
each pairin of fruits n' colors:
.Sp
.Vb 1
\&    @many =  glob "{apple,tomato,cherry}={green,yellow,red}";
.Ve
.Sp
This operator is implemented rockin tha standard
\&\f(CW\*(C`File::Glob\*(C'\fR extension. I aint talkin' bout chicken n' gravy biatch.  See File::Glob fo' details, including
\&\f(CW\*(C`bsd_glob\*(C'\fR which do not treat whitespace as a pattern separator.
.Sp
Portabilitizzle issues: \*(L"glob\*(R" up in perlport.
.IP "gmtime \s-1EXPR \s0" 4
.IX Xref "gmtime UTC Greenwich"
.IX Item "gmtime EXPR "
.PD 0
.IP "gmtime" 4
.IX Item "gmtime"
.PD
Works just like \*(L"localtime\*(R" but tha returned joints are
localized fo' tha standard Greenwich time unit.
.Sp
Note: When called up in list context, \f(CW$isdst\fR, tha last value
returned by gmtime, be always \f(CW0\fR.  There is no
Daylight Savin Time up in \s-1GMT.\s0
.Sp
Portabilitizzle issues: \*(L"gmtime\*(R" up in perlport.
.IP "goto \s-1LABEL \s0" 4
.IX Xref "goto jump jmp"
.IX Item "goto LABEL "
.PD 0
.IP "goto \s-1EXPR\s0" 4
.IX Item "goto EXPR"
.IP "goto &NAME" 4
.IX Item "goto &NAME"
.PD
Da \f(CW\*(C`goto\-LABEL\*(C'\fR form findz tha statement labeled wit \s-1LABEL\s0 and
resumes execution there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  It can't be used ta git outta a funky-ass block or
subroutine given ta \f(CW\*(C`sort\*(C'\fR.  It can be used ta go almost anywhere
else within tha dynamic scope, includin outta subroutines yo, but it's
usually betta ta use some other construct like fuckin \f(CW\*(C`last\*(C'\fR or \f(CW\*(C`die\*(C'\fR.
Da lyricist of Perl has never felt tha need ta use dis form of \f(CW\*(C`goto\*(C'\fR
(in Perl, dat is; C be another matter).  (Da difference is dat C
does not offer named loops combined wit loop control.  Perl do, and
this replaces most structured usez of \f(CW\*(C`goto\*(C'\fR up in other languages.)
.Sp
Da \f(CW\*(C`goto\-EXPR\*(C'\fR form expects a label name, whose scope is ghon be resolved
dynamically.  This allows fo' computed \f(CW\*(C`goto\*(C'\fRs per \s-1FORTRAN,\s0 but aint
necessarily recommended if you optimizin fo' maintainability:
.Sp
.Vb 1
\&    goto ("FOO", "BAR", "GLARCH")[$i];
.Ve
.Sp
As shown up in dis example, \f(CW\*(C`goto\-EXPR\*(C'\fR is exempt from tha \*(L"looks like a
function\*(R" rule.  A pair of parentheses followin it do not (necessarily)
delimit its argument.  \f(CW\*(C`goto("NE")."XT"\*(C'\fR is equivalent ta \f(CW\*(C`goto NEXT\*(C'\fR.
Also, unlike most named operators, dis has tha same ol' dirty precedence as
assignment.
.Sp
Use of \f(CW\*(C`goto\-LABEL\*(C'\fR or \f(CW\*(C`goto\-EXPR\*(C'\fR ta jump tha fuck into a cold-ass lil construct is
deprecated n' will issue a warning.  Even then, it may not be used to
go tha fuck into any construct dat requires initialization, like fuckin a
subroutine or a \f(CW\*(C`foreach\*(C'\fR loop.  It also can't be used ta go tha fuck into a
construct dat is optimized away.
.Sp
Da \f(CW\*(C`goto\-&NAME\*(C'\fR form is like different from tha other forms of
\&\f(CW\*(C`goto\*(C'\fR.  In fact, it aint a goto up in tha aiiight sense at all, and
doesn't have tha stigma associated wit other gotos.  Instead, it
exits tha current subroutine (losin any chizzlez set by \fIlocal()\fR) and
immediately calls up in its place tha named subroutine rockin tha current
value of \f(CW@_\fR.  This is used by \f(CW\*(C`AUTOLOAD\*(C'\fR subroutines dat wish to
load another subroutine n' then pretend dat tha other subroutine had
been called up in tha straight-up original gangsta place (except dat any modifications ta \f(CW@_\fR
in tha current subroutine is propagated ta tha other subroutine.)
Afta tha \f(CW\*(C`goto\*(C'\fR, not even \f(CW\*(C`caller\*(C'\fR is ghon be able ta tell dat this
routine was called first.
.Sp
\&\s-1NAME\s0 needn't be tha name of a subroutine; it can be a scalar variable
containin a cold-ass lil code reference or a funky-ass block dat evaluates ta a cold-ass lil code
reference.
.IP "grep \s-1BLOCK LIST \s0" 4
.IX Xref "grep"
.IX Item "grep BLOCK LIST "
.PD 0
.IP "grep \s-1EXPR,LIST\s0" 4
.IX Item "grep EXPR,LIST"
.PD
This is similar up in spirit ta yo, but not tha same as, \fIgrep\fR\|(1) n' its
relatives.  In particular, it aint limited ta rockin regular expressions.
.Sp
Evaluates tha \s-1BLOCK\s0 or \s-1EXPR\s0 fo' each element of \s-1LIST \s0(locally setting
\&\f(CW$_\fR ta each element) n' returns tha list value consistin of them
elements fo' which tha expression evaluated ta true.  In scalar
context, returns tha number of times tha expression was true.
.Sp
.Vb 1
\&    @foo = grep(!/^#/, @bar);    # chronic up comments
.Ve
.Sp
or equivalently,
.Sp
.Vb 1
\&    @foo = grep {!/^#/} @bar;    # chronic up comments
.Ve
.Sp
Note dat \f(CW$_\fR be a alias ta tha list value, so it can be used to
modify tha elementz of tha \s-1LIST. \s0 While dis is useful n' supported,
it can cause bizarre thangs up in dis biatch if tha elementz of \s-1LIST\s0 is not variables.
Similarly, grep returns aliases tha fuck into tha original gangsta list, much as a gangbangin' for
loopz index variable aliases tha list elements, n' you can put dat on yo' toast.  That is, modifyin an
element of a list returned by grep (for example, up in a \f(CW\*(C`foreach\*(C'\fR, \f(CW\*(C`map\*(C'\fR
or another \f(CW\*(C`grep\*(C'\fR) straight-up modifies tha element up in tha original gangsta list.
This is probably suttin' ta be avoided when freestylin clear code.
.Sp
If \f(CW$_\fR is lexical up in tha scope where tha \f(CW\*(C`grep\*(C'\fR appears (because it has
been declared wit tha deprecated \f(CW\*(C`my $_\*(C'\fR construct)
then, up in addizzle ta bein locally aliased to
the list elements, \f(CW$_\fR keeps bein lexical inside tha block; i.e., it
can't be peeped from tha outside, avoidin any potential side-effects.
.Sp
See also \*(L"map\*(R" fo' a list composed of tha thangs up in dis biatch of tha \s-1BLOCK\s0 or \s-1EXPR.\s0
.IP "hex \s-1EXPR \s0" 4
.IX Xref "hex hexadecimal"
.IX Item "hex EXPR "
.PD 0
.IP "hex" 4
.IX Item "hex"
.PD
Interprets \s-1EXPR\s0 as a hex strang n' returns tha correspondin value.
(To convert strings dat might start wit either \f(CW0\fR, \f(CW\*(C`0x\*(C'\fR, or \f(CW\*(C`0b\*(C'\fR, see
\&\*(L"oct\*(R".)  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
.Vb 2
\&    print hex \*(Aq0xAf\*(Aq; # prints \*(Aq175\*(Aq
\&    print hex \*(AqaF\*(Aq;   # same
.Ve
.Sp
Hex strings may only represent integers.  Strings dat would cause
integer overflow trigger a warning.  Leadin whitespace aint stripped,
unlike \fIoct()\fR.  To present suttin' as hex, look tha fuck into \*(L"printf\*(R",
\&\*(L"sprintf\*(R", n' \*(L"unpack\*(R".
.IP "import \s-1LIST \s0" 4
.IX Xref "import"
.IX Item "import LIST "
There is no builtin \f(CW\*(C`import\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  It be just a ordinary
method (subroutine) defined (or inherited) by modulez dat wish ta export
names ta another module.  Da \f(CW\*(C`use\*(C'\fR function calls tha \f(CW\*(C`import\*(C'\fR method
for tha package used. Y'all KNOW dat shit, muthafucka!  See also \*(L"use\*(R", perlmod, n' Exporter.
.IP "index \s-1STR,SUBSTR,POSITION \s0" 4
.IX Xref "index indexOf InStr"
.IX Item "index STR,SUBSTR,POSITION "
.PD 0
.IP "index \s-1STR,SUBSTR\s0" 4
.IX Item "index STR,SUBSTR"
.PD
Da index function searches fo' one strang within another yo, but without
the wildcard-like behavior of a gangbangin' full regular-expression pattern match.
It returns tha posizzle of tha straight-up original gangsta occurrence of \s-1SUBSTR\s0 up in \s-1STR\s0 at
or afta \s-1POSITION. \s0 If \s-1POSITION\s0 is omitted, starts searchin from the
beginnin of tha string.  \s-1POSITION\s0 before tha beginnin of tha string
or afta its end is treated as if it was tha beginnin or tha end,
respectively.  \s-1POSITION\s0 n' tha return value is based at zero.
If tha substrin aint found, \f(CW\*(C`index\*(C'\fR returns \-1.
.IP "int \s-1EXPR \s0" 4
.IX Xref "int integer truncate trunc floor"
.IX Item "int EXPR "
.PD 0
.IP "int" 4
.IX Item "int"
.PD
Returns tha integer portion of \s-1EXPR. \s0 If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
Yo ass should not use dis function fo' rounding: one cuz it truncates
towardz \f(CW0\fR, n' two cuz machine representationz of floating-point
numbers can sometimes produce counterintuitizzle thangs up in dis biatch.  For example,
\&\f(CW\*(C`int(\-6.725/0.025)\*(C'\fR produces \-268 rather than tha erect \-269; that's
because itz straight-up mo' like \-268.99999999999994315658 instead. Y'all KNOW dat shit, muthafucka!  Usually,
the \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, or tha \f(CW\*(C`POSIX::floor\*(C'\fR n' \f(CW\*(C`POSIX::ceil\*(C'\fR
functions will serve you betta than will \fIint()\fR.
.IP "ioctl \s-1FILEHANDLE,FUNCTION,SCALAR \s0" 4
.IX Xref "ioctl"
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR "
Implements tha \fIioctl\fR\|(2) function. I aint talkin' bout chicken n' gravy biatch.  You'll probably first gotta say
.Sp
.Vb 2
\&    require "sys/ioctl.ph";  # probably in
\&                             # $Config{archlib}/sys/ioctl.ph
.Ve
.Sp
to git tha erect function definitions.  If \fIsys/ioctl.ph\fR don't
exist or aint gots tha erect definitions you gonna gotta roll your
own, based on yo' C header filez like fuckin \fI<sys/ioctl.h>\fR.
(There be a Perl script called \fBh2ph\fR dat comes wit tha Perl kit that
may help you up in dis yo, but itz nontrivial.)  \s-1SCALAR\s0 is ghon be read and/or
written dependin on tha \s-1FUNCTION\s0; a C pointa ta tha strang value of \s-1SCALAR\s0
will be passed as tha third argument of tha actual \f(CW\*(C`ioctl\*(C'\fR call.  (If \s-1SCALAR\s0
has no strang value but do gotz a numeric value, dat value will be
passed rather than a pointa ta tha strang value.  To guarantee dis ta be
true, add a \f(CW0\fR ta tha scalar before rockin dat shit.)  Da \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR
functions may be needed ta manipulate tha jointz of structures used by
\&\f(CW\*(C`ioctl\*(C'\fR.
.Sp
Da return value of \f(CW\*(C`ioctl\*(C'\fR (and \f(CW\*(C`fcntl\*(C'\fR) be as bigs up:
.Sp
.Vb 4
\&    if OS returns:      then Perl returns:
\&        \-1               undefined value
\&         0              strang "0 but true"
\&    anythang else           dat number
.Ve
.Sp
Thus Perl returns legit on success n' false on failure, yet you can
still easily determine tha actual value returned by tha operating
system:
.Sp
.Vb 2
\&    $retval = ioctl(...) || \-1;
\&    printf "System returned %d\en", $retval;
.Ve
.Sp
Da special strang \f(CW"0 but true"\fR is exempt from \fB\-w\fR disses
about improper numeric conversions.
.Sp
Portabilitizzle issues: \*(L"ioctl\*(R" up in perlport.
.IP "join \s-1EXPR,LIST \s0" 4
.IX Xref "join"
.IX Item "join EXPR,LIST "
Joins tha separate stringz of \s-1LIST\s0 tha fuck into a single strang wit fields
separated by tha value of \s-1EXPR,\s0 n' returns dat freshly smoked up string.  Example:
.Sp
.Vb 1
\&    $rec = join(\*(Aq:\*(Aq, $login,$passwd,$uid,$gid,$gcos,$home,$shell);
.Ve
.Sp
Beware dat unlike \f(CW\*(C`split\*(C'\fR, \f(CW\*(C`join\*(C'\fR don't take a pattern as its
first argument.  Compare \*(L"split\*(R".
.IP "keys \s-1HASH \s0" 4
.IX Xref "keys key"
.IX Item "keys HASH "
.PD 0
.IP "keys \s-1ARRAY\s0" 4
.IX Item "keys ARRAY"
.IP "keys \s-1EXPR\s0" 4
.IX Item "keys EXPR"
.PD
Called up in list context, returns a list consistin of all tha keyz of the
named hash, or up in Perl 5.12 or lata only, tha indicez of a array.  Perl
releases prior ta 5.12 will produce a syntax error if you try ta use an
array argument.  In scalar context, returns tha number of keys or indices.
.Sp
Hash entries is returned up in a apparently random order n' shit.  Da actual random
order is specific ta a given hash; tha exact same seriez of operations
on two hashes may result up in a gangbangin' finger-lickin' different order fo' each hash fo' realz. Any insertion
into tha hash may chizzle tha order, as will any deletion, wit tha exception
that da most thugged-out recent key returned by \f(CW\*(C`each\*(C'\fR or \f(CW\*(C`keys\*(C'\fR may be deleted
without changin tha order n' shit. Right back up in yo muthafuckin ass. So long as a given hash is unmodified you may
rely on \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR n' \f(CW\*(C`each\*(C'\fR ta repeatedly return tha same order
as each other n' shit. Right back up in yo muthafuckin ass. See \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec for
details on why hash order is randomized. Y'all KNOW dat shit, muthafucka! Aside from tha guarantees
provided here tha exact detailz of Perlz hash algorithm n' tha hash
traversal order is subject ta chizzle up in any release of Perl.
.Sp
As a side effect, callin \fIkeys()\fR resets tha internal iterator of tha \s-1HASH\s0 or
\&\s-1ARRAY \s0(see \*(L"each\*(R").  In particular, callin \fIkeys()\fR up in void context resets
the iterator wit no other overhead.
.Sp
Here is yet another way ta print yo' environment:
.Sp
.Vb 5
\&    @keys = keys %ENV;
\&    @values = joints %ENV;
\&    while (@keys) {
\&        print pop(@keys), \*(Aq=\*(Aq, pop(@values), "\en";
\&    }
.Ve
.Sp
or how tha fuck bout sorted by key:
.Sp
.Vb 3
\&    foreach $key (sort(keys %ENV)) {
\&        print $key, \*(Aq=\*(Aq, $ENV{$key}, "\en";
\&    }
.Ve
.Sp
Da returned joints is copiez of tha original gangsta keys up in tha hash, so
modifyin dem aint gonna affect tha original gangsta hash.  Compare \*(L"values\*(R".
.Sp
To sort a hash by value, you gonna need ta bust a \f(CW\*(C`sort\*(C'\fR function.
Herez a thugged-out descendin numeric sort of a hash by its joints:
.Sp
.Vb 3
\&    foreach $key (sort { $hash{$b} <=> $hash{$a} } keys %hash) {
\&        printf "%4d %s\en", $hash{$key}, $key;
\&    }
.Ve
.Sp
Used as a lvalue, \f(CW\*(C`keys\*(C'\fR allows you ta increase tha number of hash buckets
allocated fo' tha given hash.  This can bust you a measure of efficiency if
you know tha hash is goin ta git big.  (This is similar ta pre-extending
an array by assignin a larger number ta $#array.)  If you say
.Sp
.Vb 1
\&    keys %hash = 200;
.Ve
.Sp
then \f(CW%hash\fR gonna git at least 200 buckets allocated fo' it\-\-256 of them,
in fact, since it roundz up ta tha next juice of two.  These
buckets is ghon be retained even if you do \f(CW\*(C`%hash = ()\*(C'\fR, use \f(CW\*(C`undef
%hash\*(C'\fR if you wanna free tha storage while \f(CW%hash\fR is still up in scope.
Yo ass can't shrink tha number of buckets allocated fo' tha hash using
\&\f(CW\*(C`keys\*(C'\fR up in dis way (but you needn't worry bout bustin dis by accident,
as tryin has no effect).  \f(CW\*(C`keys @array\*(C'\fR up in a lvalue context be a syntax
error.
.Sp
Startin wit Perl 5.14, \f(CW\*(C`keys\*(C'\fR can take a scalar \s-1EXPR,\s0 which must contain
a reference ta a unblessed hash or array.  Da argument will be
dereferenced automatically.  This aspect of \f(CW\*(C`keys\*(C'\fR is considered highly
experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
.Vb 2
\&    fo' (keys $hashref) { ... }
\&    fo' (keys $obj\->get_arrayref) { ... }
.Ve
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 2
\&    use 5.012;  # so keys/values/each work on arrays
\&    use 5.014;  # so keys/values/each work on scalars (experimental)
.Ve
.Sp
See also \f(CW\*(C`each\*(C'\fR, \f(CW\*(C`values\*(C'\fR, n' \f(CW\*(C`sort\*(C'\fR.
.IP "kill \s-1SIGNAL, LIST\s0" 4
.IX Item "kill SIGNAL, LIST"
.PD 0
.IP "kill \s-1SIGNAL \s0" 4
.IX Xref "kill signal"
.IX Item "kill SIGNAL "
.PD
Sendz a signal ta a list of processes.  Returns tha number of
processes successfully signaled (which aint necessarily the
same as tha number straight-up capped).
.Sp
.Vb 2
\&    $cnt = bust a cap up in \*(AqHUP\*(Aq, $child1, $child2;
\&    bust a cap up in \*(AqKILL\*(Aq, @goners;
.Ve
.Sp
\&\s-1SIGNAL\s0 may be either a signal name (a string) or a signal number n' shit.  A signal
name may start wit a \f(CW\*(C`SIG\*(C'\fR prefix, thus \f(CW\*(C`FOO\*(C'\fR n' \f(CW\*(C`SIGFOO\*(C'\fR refer ta the
same signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da strang form of \s-1SIGNAL\s0 is recommended fo' portabilitizzle cuz
the same signal may have different numbers up in different operatin systems.
.Sp
A list of signal names supported by tha current platform can be found in
\&\f(CW$Config{sig_name}\fR, which is provided by tha \f(CW\*(C`Config\*(C'\fR module. Right back up in yo muthafuckin ass. See Config
for mo' details.
.Sp
A wack signal name is tha same ol' dirty as a wack signal number, cappin' process
groups instead of processes.  For example, \f(CW\*(C`kill \*(Aq\-KILL\*(Aq, $pgrp\*(C'\fR and
\&\f(CW\*(C`kill \-9, $pgrp\*(C'\fR will bust \f(CW\*(C`SIGKILL\*(C'\fR ta tha entire process crew specified. Y'all KNOW dat shit, muthafucka! That
means you probably wanna use positizzle not wack signals.
.Sp
If \s-1SIGNAL\s0 is either tha number 0 or tha strang \f(CW\*(C`ZERO\*(C'\fR (or \f(CW\*(C`SIGZZERO\*(C'\fR),
no signal is busted to
the process yo, but \f(CW\*(C`kill\*(C'\fR checks whether itz \fIpossible\fR ta bust a signal ta it
(that means, ta be brief, dat tha process is owned by tha same user, or we are
the super-user).  This is useful ta check dat a cold-ass lil lil pimp process is still
kickin it (even if only as a zombie) n' aint chizzled its \s-1UID. \s0 See
perlport fo' notes on tha portabilitizzle of dis construct.
.Sp
Da behavior of bust a cap up in when a \fI\s-1PROCESS\s0\fR number is zero or wack dependz on
the operatin system.  For example, on POSIX-conformin systems, zero will
signal tha current process group, \-1 will signal all processes, n' any
other wack \s-1PROCESS\s0 number will act as a wack signal number and
kill tha entire process crew specified.
.Sp
If both tha \s-1SIGNAL\s0 n' tha \s-1PROCESS\s0 is negative, tha thangs up in dis biatch is undefined.
A warnin may be produced up in a gangbangin' future version.
.Sp
See \*(L"Signals\*(R" up in perlipc fo' mo' details.
.Sp
On some platforms like fuckin Windows where tha \fIfork()\fR system call aint available.
Perl can be built ta emulate \fIfork()\fR all up in tha interpreta level.
This emulation has limitations related ta bust a cap up in dat gotta be considered,
for code hustlin on Windows n' up in code intended ta be portable.
.Sp
See perlfork fo' mo' details.
.Sp
If there is no \fI\s-1LIST\s0\fR of processes, no signal is sent, n' tha return
value is 0.  This form is sometimes used, however, cuz it causes
taintin checks ta be run. I aint talkin' bout chicken n' gravy biatch.  But see
\&\*(L"Launderin n' Detectin Tainted Data\*(R" up in perlsec.
.Sp
Portabilitizzle issues: \*(L"kill\*(R" up in perlport.
.IP "last \s-1LABEL \s0" 4
.IX Xref "last break"
.IX Item "last LABEL "
.PD 0
.IP "last \s-1EXPR\s0" 4
.IX Item "last EXPR"
.IP "last" 4
.IX Item "last"
.PD
Da \f(CW\*(C`last\*(C'\fR command is like tha \f(CW\*(C`break\*(C'\fR statement up in C (as used in
loops); it immediately exits tha loop up in question. I aint talkin' bout chicken n' gravy biatch.  If tha \s-1LABEL\s0 is
omitted, tha command refers ta tha innermost enclosing
loop.  Da \f(CW\*(C`last EXPR\*(C'\fR form, available startin up in Perl
5.18.0, allows a label name ta be computed at run time,
and is otherwise identical ta \f(CW\*(C`last LABEL\*(C'\fR.  The
\&\f(CW\*(C`continue\*(C'\fR block, if any, aint executed:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        last LINE if /^$/;  # exit when done wit header
\&        #...
\&    }
.Ve
.Sp
\&\f(CW\*(C`last\*(C'\fR cannot be used ta exit a funky-ass block dat returns a value such as
\&\f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR, or \f(CW\*(C`do {}\*(C'\fR, n' should not be used ta exit
a \fIgrep()\fR or \fImap()\fR operation.
.Sp
Note dat a funky-ass block by itself is semantically identical ta a loop
that executes once.  Thus \f(CW\*(C`last\*(C'\fR can be used ta effect a early
exit outta such a funky-ass block.
.Sp
See also \*(L"continue\*(R" fo' a illustration of how tha fuck \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, and
\&\f(CW\*(C`redo\*(C'\fR work.
.Sp
Unlike most named operators, dis has tha same ol' dirty precedence as assignment.
It be also exempt from tha looks-like-a-function rule, so
\&\f(CW\*(C`last ("foo")."bar"\*(C'\fR will cause \*(L"bar\*(R" ta be part of tha argument to
\&\f(CW\*(C`last\*(C'\fR.
.IP "lc \s-1EXPR \s0" 4
.IX Xref "lc lowercase"
.IX Item "lc EXPR "
.PD 0
.IP "lc" 4
.IX Item "lc"
.PD
Returns a lowercased version of \s-1EXPR. \s0 This is tha internal function
implementin tha \f(CW\*(C`\eL\*(C'\fR escape up in double-quoted strings.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
What gets returned dependz on nuff muthafuckin factors:
.RS 4
.ie n .IP "If ""use bytes"" is up in effect:" 4
.el .IP "If \f(CWuse bytes\fR is up in effect:" 4
.IX Item "If use bytes is up in effect:"
Da thangs up in dis biatch follow \s-1ASCII\s0 semantics.  Only charactas \f(CW\*(C`A\-Z\*(C'\fR chizzle, ta \f(CW\*(C`a\-z\*(C'\fR
respectively.
.ie n .IP "Otherwise, if ""use locale"" (but not ""use locale \*(Aq:not_characters\*(Aq"") is up in effect:" 4
.el .IP "Otherwise, if \f(CWuse locale\fR (but not \f(CWuse locale \*(Aq:not_characters\*(Aq\fR) is up in effect:" 4
.IX Item "Otherwise, if use locale (but not use locale :not_characters) is up in effect:"
Respects current \s-1LC_CTYPE\s0 locale fo' code points < 256; n' uses Unicode
semantics fo' tha remainin code points (this last can only happen if
the \s-1UTF8\s0 flag be also set).  See perllocale.
.Sp
A deficiency up in dis is dat case chizzlez dat cross tha 255/256
boundary is not well-defined. Y'all KNOW dat shit, muthafucka!  For example, tha lower case of \s-1LATIN CAPITAL
LETTER SHARP S \s0(U+1E9E) up in Unicode semantics is U+00DF (on \s-1ASCII\s0
platforms).   But under \f(CW\*(C`use locale\*(C'\fR, tha lower case of U+1E9E is
itself, cuz 0xDF may not be \s-1LATIN SMALL LETTER SHARP S\s0 up in the
current locale, n' Perl has no way of knowin if dat characta even
exists up in tha locale, much less what tha fuck code point it is.  Perl returns
the input characta unchanged, fo' all instances (and there aren't
many) where tha 255/256 boundary would otherwise be crossed.
.IP "Otherwise, If \s-1EXPR\s0 has tha \s-1UTF8\s0 flag set:" 4
.IX Item "Otherwise, If EXPR has tha UTF8 flag set:"
Unicode semantics is used fo' tha case chizzle.
.ie n .IP "Otherwise, if ""use feature \*(Aqunicode_strings\*(Aq"" or ""use locale \*(Aq:not_characters\*(Aq"" is up in effect:" 4
.el .IP "Otherwise, if \f(CWuse feature \*(Aqunicode_strings\*(Aq\fR or \f(CWuse locale \*(Aq:not_characters\*(Aq\fR is up in effect:" 4
.IX Item "Otherwise, if use feature unicode_strings or use locale :not_charactas is up in effect:"
Unicode semantics is used fo' tha case chizzle.
.IP "Otherwise:" 4
.IX Item "Otherwise:"
\&\s-1ASCII\s0 semantics is used fo' tha case chizzle.  Da lowercase of any character
outside tha \s-1ASCII\s0 range is tha characta itself.
.RE
.RS 4
.RE
.IP "lcfirst \s-1EXPR \s0" 4
.IX Xref "lcfirst lowercase"
.IX Item "lcfirst EXPR "
.PD 0
.IP "lcfirst" 4
.IX Item "lcfirst"
.PD
Returns tha value of \s-1EXPR\s0 wit tha straight-up original gangsta characta lowercased. Y'all KNOW dat shit, muthafucka!  This
is tha internal function implementin tha \f(CW\*(C`\el\*(C'\fR escape in
double-quoted strings.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
This function behaves tha same ol' dirty way under various pragmata, like fuckin up in a locale,
as \*(L"lc\*(R" do.
.IP "length \s-1EXPR \s0" 4
.IX Xref "length size"
.IX Item "length EXPR "
.PD 0
.IP "length" 4
.IX Item "length"
.PD
Returns tha length up in \fIcharacters\fR of tha value of \s-1EXPR. \s0 If \s-1EXPR\s0 is
omitted, returns tha length of \f(CW$_\fR.  If \s-1EXPR\s0 is undefined, returns
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
This function cannot be used on a entire array or hash ta smoke up how
many elements these have.  For that, use \f(CW\*(C`scalar @array\*(C'\fR n' \f(CW\*(C`scalar keys
%hash\*(C'\fR, respectively.
.Sp
Like all Perl characta operations, \fIlength()\fR normally deals up in logical
characters, not physical bytes.  For how tha fuck nuff bytes a strang encoded as
\&\s-1UTF\-8\s0 would take up, use \f(CW\*(C`length(Encode::encode_utf8(EXPR))\*(C'\fR (yo dirty ass is gonna have
to \f(CW\*(C`use Encode\*(C'\fR first).  See Encode n' perlunicode.
.IP "_\|_LINE_\|_" 4
.IX Xref "__LINE__"
.IX Item "__LINE__"
A special token dat compilez ta tha current line number.
.IP "link \s-1OLDFILE,NEWFILE \s0" 4
.IX Xref "link"
.IX Item "link OLDFILE,NEWFILE "
Creates a freshly smoked up filename linked ta tha oldschool filename.  Returns legit for
success, false otherwise.
.Sp
Portabilitizzle issues: \*(L"link\*(R" up in perlport.
.IP "listen \s-1SOCKET,QUEUESIZE \s0" 4
.IX Xref "listen"
.IX Item "listen SOCKET,QUEUESIZE "
Do tha same thang dat tha \fIlisten\fR\|(2) system call do.  Returns legit if
it succeeded, false otherwise.  See tha example in
\&\*(L"Sockets: Client/Server Communication\*(R" up in perlipc.
.IP "local \s-1EXPR \s0" 4
.IX Xref "local"
.IX Item "local EXPR "
Yo ass straight-up probably wanna be rockin \f(CW\*(C`my\*(C'\fR instead, cuz \f(CW\*(C`local\*(C'\fR aint
what most playas be thinkin of as \*(L"local\*(R".  See
\&\*(L"Private Variablez via \fImy()\fR\*(R" up in perlsub fo' details.
.Sp
A local modifies tha listed variablez ta be local ta tha enclosing
block, file, or eval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If mo' than one value is listed, tha list must
be placed up in parentheses.  See \*(L"Temporary Values via \fIlocal()\fR\*(R" up in perlsub
for details, includin thangs wit tied arrays n' hashes.
.Sp
Da \f(CW\*(C`delete local EXPR\*(C'\fR construct can also be used ta localize tha deletion
of array/hash elements ta tha current block.
See \*(L"Localized deletion of elementz of composite types\*(R" up in perlsub.
.IP "localtime \s-1EXPR \s0" 4
.IX Xref "localtime ctime"
.IX Item "localtime EXPR "
.PD 0
.IP "localtime" 4
.IX Item "localtime"
.PD
Converts a time as returned by tha time function ta a 9\-element list
with tha time analyzed fo' tha local time unit.  Typically used as
bigs up:
.Sp
.Vb 3
\&    #  0    1    2     3     4    5     6     7     8
\&    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
\&                                                localtime(time);
.Ve
.Sp
All list elements is numeric n' come straight outta tha C `struct
tm'.  \f(CW$sec\fR, \f(CW$min\fR, n' \f(CW$hour\fR is tha seconds, minutes, n' hours
of tha specified time.
.Sp
\&\f(CW$mday\fR is tha dizzle of tha month n' \f(CW$mon\fR tha month in
the range \f(CW0..11\fR, wit 0 indicatin January n' 11 indicatin December.
This make it easy as fuck  ta git a month name from a list:
.Sp
.Vb 3
\&    mah @abbr = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
\&    print "$abbr[$mon] $mday";
\&    # $mon=9, $mday=18 gives "Oct 18"
.Ve
.Sp
\&\f(CW$year\fR gotz nuff tha number of muthafuckin years since 1900.  To git a 4\-digit
year write:
.Sp
.Vb 1
\&    $year += 1900;
.Ve
.Sp
To git tha last two digitz of tha year (e.g., \*(L"01\*(R" up in 2001) do:
.Sp
.Vb 1
\&    $year = sprintf("%02d", $year % 100);
.Ve
.Sp
\&\f(CW$wday\fR is tha dizzle of tha week, wit 0 indicatin Sundizzle n' 3 indicating
Wednesday. It make me wanna hollar playa!  \f(CW$yday\fR is tha dizzle of tha year, up in tha range \f(CW0..364\fR
(or \f(CW0..365\fR up in leap years.)
.Sp
\&\f(CW$isdst\fR is legit if tha specified time occurs durin Daylight Saving
Time, false otherwise.
.Sp
If \s-1EXPR\s0 is omitted, \f(CW\*(C`localtime()\*(C'\fR uses tha current time (as returned
by \fItime\fR\|(3)).
.Sp
In scalar context, \f(CW\*(C`localtime()\*(C'\fR returns tha \fIctime\fR\|(3) value:
.Sp
.Vb 1
\&    $now_strin = localtime;  # e.g., "Thu Oct 13 04:54:34 1994"
.Ve
.Sp
Da format of dis scalar value is \fBnot\fR locale-dependent
but built tha fuck into Perl.  For \s-1GMT\s0 instead of local
time use tha \*(L"gmtime\*(R" builtin. I aint talkin' bout chicken n' gravy biatch.  See also the
\&\f(CW\*(C`Time::Local\*(C'\fR module (for convertin seconds, minutes, hours, n' such back to
the integer value returned by \fItime()\fR), n' tha \s-1POSIX\s0 modulez \fIstrftime\fR\|(3)
and \fImktime\fR\|(3) functions.
.Sp
To git somewhat similar but locale-dependent date strings, set up your
locale environment variablez appropriately (please peep perllocale) and
try fo' example:
.Sp
.Vb 4
\&    use POSIX qw(strftime);
\&    $now_strin = strftime "%a %b %e %H:%M:%S %Y", localtime;
\&    # or fo' GMT formatted appropriately fo' yo' locale:
\&    $now_strin = strftime "%a %b %e %H:%M:%S %Y", gmtime;
.Ve
.Sp
Note dat tha \f(CW%a\fR n' \f(CW%b\fR, tha short formz of tha dizzle of tha week
and tha month of tha year, may not necessarily be three charactas wide.
.Sp
Da Time::gmtime n' Time::localtime modulez provide a cold-ass lil convenient,
by-name access mechanizzle ta tha \fIgmtime()\fR n' \fIlocaltime()\fR functions,
respectively.
.Sp
For a cold-ass lil comprehensive date n' time representation peep the
DateTime module on \s-1CPAN.\s0
.Sp
Portabilitizzle issues: \*(L"localtime\*(R" up in perlport.
.IP "lock \s-1THING \s0" 4
.IX Xref "lock"
.IX Item "lock THING "
This function places a advisory lock on a gangbangin' finger-lickin' dirty-ass shared variable or referenced
object contained up in \fI\s-1THING\s0\fR until tha lock goes outta scope.
.Sp
Da value returned is tha scalar itself, if tha argument be a scalar, or a
reference, if tha argument be a hash, array or subroutine.
.Sp
\&\fIlock()\fR be a \*(L"weak keyword\*(R" : dis means dat if you've defined a gangbangin' function
by dis name (before any calls ta it), dat function is ghon be called
instead. Y'all KNOW dat shit, muthafucka!  If yo ass is not under \f(CW\*(C`use threads::shared\*(C'\fR dis do nothing.
See threads::shared.
.IP "log \s-1EXPR \s0" 4
.IX Xref "log logarithm e ln base"
.IX Item "log EXPR "
.PD 0
.IP "log" 4
.IX Item "log"
.PD
Returns tha natural logarithm (base \fIe\fR) of \s-1EXPR. \s0 If \s-1EXPR\s0 is omitted,
returns tha log of \f(CW$_\fR.  To git the
log of another base, use basic algebra:
Da base-N log of a number is equal ta tha natural log of dat number
divided by tha natural log of N.  For example:
.Sp
.Vb 4
\&    sub log10 {
\&        mah $n = shift;
\&        return log($n)/log(10);
\&    }
.Ve
.Sp
See also \*(L"exp\*(R" fo' tha inverse operation.
.IP "lstat \s-1FILEHANDLE \s0" 4
.IX Xref "lstat"
.IX Item "lstat FILEHANDLE "
.PD 0
.IP "lstat \s-1EXPR\s0" 4
.IX Item "lstat EXPR"
.IP "lstat \s-1DIRHANDLE\s0" 4
.IX Item "lstat DIRHANDLE"
.IP "lstat" 4
.IX Item "lstat"
.PD
Do tha same thang as tha \f(CW\*(C`stat\*(C'\fR function (includin settin the
special \f(CW\*(C`_\*(C'\fR filehandle) but stats a symbolic link instead of tha file
the symbolic link points to.  If symbolic links is unimplemented on
your system, a aiiight \f(CW\*(C`stat\*(C'\fR is done.  For much mo' detailed
information, please peep tha documentation fo' \f(CW\*(C`stat\*(C'\fR.
.Sp
If \s-1EXPR\s0 is omitted, stats \f(CW$_\fR.
.Sp
Portabilitizzle issues: \*(L"lstat\*(R" up in perlport.
.IP "m//" 4
.IX Item "m//"
Da match operator. Shiiit, dis aint no joke.  See \*(L"Regexp Quote-Like Operators\*(R" up in perlop.
.IP "map \s-1BLOCK LIST \s0" 4
.IX Xref "map"
.IX Item "map BLOCK LIST "
.PD 0
.IP "map \s-1EXPR,LIST\s0" 4
.IX Item "map EXPR,LIST"
.PD
Evaluates tha \s-1BLOCK\s0 or \s-1EXPR\s0 fo' each element of \s-1LIST \s0(locally setting
\&\f(CW$_\fR ta each element) n' returns tha list value composed of the
resultz of each such evaluation. I aint talkin' bout chicken n' gravy biatch.  In scalar context, returns the
total number of elements so generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Evaluates \s-1BLOCK\s0 or \s-1EXPR\s0 in
list context, so each element of \s-1LIST\s0 may produce zero, one, or
more elements up in tha returned value.
.Sp
.Vb 1
\&    @chars = map(chr, @numbers);
.Ve
.Sp
translates a list of numbers ta tha correspondin characters.
.Sp
.Vb 1
\&    mah @squares = map { $_ * $_ } @numbers;
.Ve
.Sp
translates a list of numbers ta they squared joints.
.Sp
.Vb 1
\&    mah @squares = map { $_ > 5 , biatch? ($_ * $_) : () } @numbers;
.Ve
.Sp
shows dat number of returned elements can differ from tha number of
input elements, n' you can put dat on yo' toast.  To omit a element, return a empty list ().
This could also be  bigged up  by writing
.Sp
.Vb 1
\&    mah @squares = map { $_ * $_ } grep { $_ > 5 } @numbers;
.Ve
.Sp
which make tha intention mo' clear.
.Sp
Map always returns a list, which can be
assigned ta a hash such dat tha elements
become key/value pairs.  See perldata fo' mo' details.
.Sp
.Vb 1
\&    %hash = map { get_a_key_for($_) => $_ } @array;
.Ve
.Sp
is just a gangbangin' funky way ta write
.Sp
.Vb 4
\&    %hash = ();
\&    foreach (@array) {
\&        $hash{get_a_key_for($_)} = $_;
\&    }
.Ve
.Sp
Note dat \f(CW$_\fR be a alias ta tha list value, so it can be used to
modify tha elementz of tha \s-1LIST. \s0 While dis is useful n' supported,
it can cause bizarre thangs up in dis biatch if tha elementz of \s-1LIST\s0 is not variables.
Usin a regular \f(CW\*(C`foreach\*(C'\fR loop fo' dis purpose would be clearer in
most cases.  See also \*(L"grep\*(R" fo' a array composed of dem shit of
the original gangsta list fo' which tha \s-1BLOCK\s0 or \s-1EXPR\s0 evaluates ta true.
.Sp
If \f(CW$_\fR is lexical up in tha scope where tha \f(CW\*(C`map\*(C'\fR appears (because it has
been declared wit tha deprecated \f(CW\*(C`my $_\*(C'\fR construct),
then, up in addizzle ta bein locally aliased to
the list elements, \f(CW$_\fR keeps bein lexical inside tha block; dat is, it
can't be peeped from tha outside, avoidin any potential side-effects.
.Sp
\&\f(CW\*(C`{\*(C'\fR starts both hash references n' blocks, so \f(CW\*(C`map { ...\*(C'\fR could be either
the start of map \s-1BLOCK LIST\s0 or map \s-1EXPR, LIST. \s0 Because Perl don't look
ahead fo' tha closin \f(CW\*(C`}\*(C'\fR it has ta take a guess at which itz dealin with
based on what tha fuck it findz just afta the
\&\f(CW\*(C`{\*(C'\fR.  Usually it gets it right yo, but if it
doesn't it won't realize suttin' is wack until it gets ta tha \f(CW\*(C`}\*(C'\fR and
encountas tha missin (or unexpected) comma.  Da syntax error will be
reported close ta tha \f(CW\*(C`}\*(C'\fR yo, but you gonna need ta chizzle suttin' near tha \f(CW\*(C`{\*(C'\fR
like fuckin rockin a unary \f(CW\*(C`+\*(C'\fR ta give Perl some help:
.Sp
.Vb 5
\&    %hash = map {  "\eL$_" => 1  } @array # perl guesses EXPR. wrong
\&    %hash = map { +"\eL$_" => 1  } @array # perl guesses BLOCK. right
\&    %hash = map { ("\eL$_" => 1) } @array # dis also works
\&    %hash = map {  lc($_) => 1  } @array # as do all dis bullshit.
\&    %hash = map +( lc($_) => 1 ), @array # dis is EXPR n' works!
\&
\&    %hash = map  ( lc($_), 1 ),   @array # evaluates ta (1, @array)
.Ve
.Sp
or ta force a anon hash constructor use \f(CW\*(C`+{\*(C'\fR:
.Sp
.Vb 2
\&    @hashes = map +{ lc($_) => 1 }, @array # EXPR, so needs
\&                                           # comma at end
.Ve
.Sp
to git a list of anonymous hashes each wit only one entry apiece.
.IP "mkdir \s-1FILENAME,MASK \s0" 4
.IX Xref "mkdir md directory, create"
.IX Item "mkdir FILENAME,MASK "
.PD 0
.IP "mkdir \s-1FILENAME\s0" 4
.IX Item "mkdir FILENAME"
.IP "mkdir" 4
.IX Item "mkdir"
.PD
Creates tha directory specified by \s-1FILENAME,\s0 wit permissions
specified by \s-1MASK \s0(as modified by \f(CW\*(C`umask\*(C'\fR).  If it succeedz it
returns true; otherwise it returns false n' sets \f(CW$!\fR (errno).
\&\s-1MASK\s0 defaults ta 0777 if omitted, n' \s-1FILENAME\s0 defaults
to \f(CW$_\fR if omitted.
.Sp
In general, it is betta ta create directories wit a permissive \s-1MASK\s0
and let tha user modify dat wit they \f(CW\*(C`umask\*(C'\fR than it is ta supply
a restrictizzle \s-1MASK\s0 n' give tha user no way ta be mo' permissive.
Da exceptions ta dis rule is when tha file or directory should be
kept private (mail files, fo' instance).  Da \fIperlfunc\fR\|(1) entry on
\&\f(CW\*(C`umask\*(C'\fR discusses tha chizzle of \s-1MASK\s0 up in mo' detail.
.Sp
Note dat accordin ta tha \s-1POSIX 1003.1\-1996\s0 tha \s-1FILENAME\s0 may have any
number of trailin slashes.  Some operatin n' filesystems do not get
this right, so Perl automatically removes all trailin slashes ta keep
everyone horny.
.Sp
To recursively create a gangbangin' finger-lickin' directory structure, peep
the \f(CW\*(C`mkpath\*(C'\fR function of tha File::Path module.
.IP "msgctl \s-1ID,CMD,ARG \s0" 4
.IX Xref "msgctl"
.IX Item "msgctl ID,CMD,ARG "
Calls tha System V \s-1IPC\s0 function \fImsgctl\fR\|(2).  You'll probably gotta say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
.Sp
first ta git tha erect constant definitions.  If \s-1CMD\s0 is \f(CW\*(C`IPC_STAT\*(C'\fR,
then \s-1ARG\s0 must be a variable dat will hold tha returned \f(CW\*(C`msqid_ds\*(C'\fR
structure.  Returns like \f(CW\*(C`ioctl\*(C'\fR: tha undefined value fo' error,
\&\f(CW"0 but true"\fR fo' zero, or tha actual return value otherwise.  See also
\&\*(L"SysV \s-1IPC\*(R"\s0 up in perlipc n' tha documentation fo' \f(CW\*(C`IPC::SysV\*(C'\fR and
\&\f(CW\*(C`IPC::Semaphore\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"msgctl\*(R" up in perlport.
.IP "msgget \s-1KEY,FLAGS \s0" 4
.IX Xref "msgget"
.IX Item "msgget KEY,FLAGS "
Calls tha System V \s-1IPC\s0 function \fImsgget\fR\|(2).  Returns tha message queue
id, or \f(CW\*(C`undef\*(C'\fR on error. Shiiit, dis aint no joke.  See also
\&\*(L"SysV \s-1IPC\*(R"\s0 up in perlipc n' tha documentation fo' \f(CW\*(C`IPC::SysV\*(C'\fR and
\&\f(CW\*(C`IPC::Msg\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"msgget\*(R" up in perlport.
.IP "msgrcv \s-1ID,VAR,SIZE,TYPE,FLAGS \s0" 4
.IX Xref "msgrcv"
.IX Item "msgrcv ID,VAR,SIZE,TYPE,FLAGS "
Calls tha System V \s-1IPC\s0 function msgrcv ta receive a message from
message queue \s-1ID\s0 tha fuck into variable \s-1VAR\s0 wit a maximum message size of
\&\s-1SIZE. \s0 Note dat when a message is received, tha message type as a
natizzle long integer is ghon be tha straight-up original gangsta thang up in \s-1VAR,\s0 followed by the
actual message.  This packin may be opened wit \f(CW\*(C`unpack("l! a*")\*(C'\fR.
Taints tha variable.  Returns legit if successful, false 
on error. Shiiit, dis aint no joke.  See also \*(L"SysV \s-1IPC\*(R"\s0 up in perlipc n' tha documentation for
\&\f(CW\*(C`IPC::SysV\*(C'\fR n' \f(CW\*(C`IPC::SysV::Msg\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"msgrcv\*(R" up in perlport.
.IP "msgsnd \s-1ID,MSG,FLAGS \s0" 4
.IX Xref "msgsnd"
.IX Item "msgsnd ID,MSG,FLAGS "
Calls tha System V \s-1IPC\s0 function msgsnd ta bust tha message \s-1MSG\s0 ta the
message queue \s-1ID.  MSG\s0 must begin wit tha natizzle long integer message
type, be followed by tha length of tha actual message, n' then finally
the message itself.  This kind of packin can be  bigged up  with
\&\f(CW\*(C`pack("l! a*", $type, $message)\*(C'\fR.  Returns legit if successful,
false on error. Shiiit, dis aint no joke.  See also tha \f(CW\*(C`IPC::SysV\*(C'\fR
and \f(CW\*(C`IPC::SysV::Msg\*(C'\fR documentation.
.Sp
Portabilitizzle issues: \*(L"msgsnd\*(R" up in perlport.
.IP "my \s-1EXPR \s0" 4
.IX Xref "my"
.IX Item "my EXPR "
.PD 0
.IP "my \s-1TYPE EXPR\s0" 4
.IX Item "my TYPE EXPR"
.IP "my \s-1EXPR : ATTRS\s0" 4
.IX Item "my EXPR : ATTRS"
.IP "my \s-1TYPE EXPR : ATTRS\s0" 4
.IX Item "my TYPE EXPR : ATTRS"
.PD
A \f(CW\*(C`my\*(C'\fR declares tha listed variablez ta be local (lexically) ta the
enclosin block, file, or \f(CW\*(C`eval\*(C'\fR.  If mo' than one value is listed,
the list must be placed up in parentheses.
.Sp
Da exact semantics n' intercourse of \s-1TYPE\s0 n' \s-1ATTRS\s0 is still
evolving.  \s-1TYPE\s0 is currently bound ta tha use of tha \f(CW\*(C`fields\*(C'\fR pragma,
and attributes is handled rockin tha \f(CW\*(C`attributes\*(C'\fR pragma, or starting
from Perl 5.8.0 also via tha \f(CW\*(C`Attribute::Handlezs\*(C'\fR module.  See
\&\*(L"Private Variablez via \fImy()\fR\*(R" up in perlsub fo' details, n' fields,
attributes, n' Attribute::Handlezs.
.IP "next \s-1LABEL \s0" 4
.IX Xref "next continue"
.IX Item "next LABEL "
.PD 0
.IP "next \s-1EXPR\s0" 4
.IX Item "next EXPR"
.IP "next" 4
.IX Item "next"
.PD
Da \f(CW\*(C`next\*(C'\fR command is like tha \f(CW\*(C`continue\*(C'\fR statement up in C; it starts
the next iteration of tha loop:
.Sp
.Vb 4
\&    LINE: while (<STDIN>) {
\&        next LINE if /^#/;  # discard comments
\&        #...
\&    }
.Ve
.Sp
Note dat if there was a \f(CW\*(C`continue\*(C'\fR block on tha above, it would get
executed even on discarded lines.  If \s-1LABEL\s0 is omitted, tha command
refers ta tha innermost enclosin loop.  Da \f(CW\*(C`next EXPR\*(C'\fR form, available
az of Perl 5.18.0, allows a label name ta be computed at run time, being
otherwise identical ta \f(CW\*(C`next LABEL\*(C'\fR.
.Sp
\&\f(CW\*(C`next\*(C'\fR cannot be used ta exit a funky-ass block which returns a value such as
\&\f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR, or \f(CW\*(C`do {}\*(C'\fR, n' should not be used ta exit
a \fIgrep()\fR or \fImap()\fR operation.
.Sp
Note dat a funky-ass block by itself is semantically identical ta a loop
that executes once.  Thus \f(CW\*(C`next\*(C'\fR will exit such a funky-ass block early.
.Sp
See also \*(L"continue\*(R" fo' a illustration of how tha fuck \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, and
\&\f(CW\*(C`redo\*(C'\fR work.
.Sp
Unlike most named operators, dis has tha same ol' dirty precedence as assignment.
It be also exempt from tha looks-like-a-function rule, so
\&\f(CW\*(C`next ("foo")."bar"\*(C'\fR will cause \*(L"bar\*(R" ta be part of tha argument to
\&\f(CW\*(C`next\*(C'\fR.
.IP "no \s-1MODULE VERSION LIST \s0" 4
.IX Xref "no declarations unimporting"
.IX Item "no MODULE VERSION LIST "
.PD 0
.IP "no \s-1MODULE VERSION\s0" 4
.IX Item "no MODULE VERSION"
.IP "no \s-1MODULE LIST\s0" 4
.IX Item "no MODULE LIST"
.IP "no \s-1MODULE\s0" 4
.IX Item "no MODULE"
.IP "no \s-1VERSION\s0" 4
.IX Item "no VERSION"
.PD
See tha \f(CW\*(C`use\*(C'\fR function, of which \f(CW\*(C`no\*(C'\fR is tha opposite.
.IP "oct \s-1EXPR \s0" 4
.IX Xref "oct octal hex hexadecimal binary bin"
.IX Item "oct EXPR "
.PD 0
.IP "oct" 4
.IX Item "oct"
.PD
Interprets \s-1EXPR\s0 as a octal strang n' returns tha corresponding
value.  (If \s-1EXPR\s0 happens ta start off wit \f(CW\*(C`0x\*(C'\fR, interprets it as a
hex string.  If \s-1EXPR\s0 starts off wit \f(CW\*(C`0b\*(C'\fR, it is interpreted as a
binary string.  Leadin whitespace is ignored up in all three cases.)
Da followin will handle decimal, binary, octal, n' hex up in standard
Perl notation:
.Sp
.Vb 1
\&    $val = oct($val) if $val =~ /^0/;
.Ve
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.   To go tha other way (produce a number
in octal), use \fIsprintf()\fR or \fIprintf()\fR:
.Sp
.Vb 2
\&    $dec_perms = (stat("filename"))[2] & 07777;
\&    $oct_perm_str = sprintf "%o", $perms;
.Ve
.Sp
Da \fIoct()\fR function is commonly used when a strang like fuckin \f(CW644\fR needs
to be converted tha fuck into a gangbangin' file mode, fo' example.  Although Perl 
automatically converts strings tha fuck into numbers as needed, dis automatic
conversion assumes base 10.
.Sp
Leadin white space is ignored without warning, as too is any trailin 
non-digits, like fuckin a thugged-out decimal point (\f(CW\*(C`oct\*(C'\fR only handlez non-negative
integers, not wack integers or floatin point).
.IP "open \s-1FILEHANDLE,EXPR \s0" 4
.IX Xref "open pipe file, open fopen"
.IX Item "open FILEHANDLE,EXPR "
.PD 0
.IP "open \s-1FILEHANDLE,MODE,EXPR\s0" 4
.IX Item "open FILEHANDLE,MODE,EXPR"
.IP "open \s-1FILEHANDLE,MODE,EXPR,LIST\s0" 4
.IX Item "open FILEHANDLE,MODE,EXPR,LIST"
.IP "open \s-1FILEHANDLE,MODE,REFERENCE\s0" 4
.IX Item "open FILEHANDLE,MODE,REFERENCE"
.IP "open \s-1FILEHANDLE\s0" 4
.IX Item "open FILEHANDLE"
.PD
Opens tha file whose filename is given by \s-1EXPR,\s0 n' associates it with
\&\s-1FILEHANDLE.\s0
.Sp
Simple examplez ta open a gangbangin' file fo' reading:
.Sp
.Vb 2
\&    open(my $fh, "<", "input.txt") 
\&        or take a thugged-out dirtnap "cannot open < input.txt: $!";
.Ve
.Sp
and fo' writing:
.Sp
.Vb 2
\&    open(my $fh, ">", "output.txt") 
\&        or take a thugged-out dirtnap "cannot open > output.txt: $!";
.Ve
.Sp
(Da followin be a cold-ass lil comprehensive reference ta \fIopen()\fR: fo' a gentler
introduction you may consider perlopentut.)
.Sp
If \s-1FILEHANDLE\s0 be a undefined scalar variable (or array or hash element), a
new filehandle be autovivified, meanin dat tha variable be assigned a
reference ta a newly allocated anonymous filehandle.  Otherwise if
\&\s-1FILEHANDLE\s0 be a expression, its value is tha real filehandle.  (This is
considered a symbolic reference, so \f(CW\*(C`use strict "refs"\*(C'\fR should \fInot\fR be
in effect.)
.Sp
If \s-1EXPR\s0 is omitted, tha global (package) scalar variable of tha same
name as tha \s-1FILEHANDLE\s0 gotz nuff tha filename.  (Note dat lexical 
variables\*(--those declared wit \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR\-\-will not work fo' this
purpose; so if you rockin \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR, specify \s-1EXPR\s0 up in your
call ta open.)
.Sp
If three (or more) arguments is specified, tha open mode (including
optionizzle encoding) up in tha second argument is distinct from tha filename in
the third. Y'all KNOW dat shit, muthafucka!  If \s-1MODE\s0 is \f(CW\*(C`<\*(C'\fR or nothing, tha file is opened fo' input.
If \s-1MODE\s0 is \f(CW\*(C`>\*(C'\fR, tha file is opened fo' output, wit existin files
first bein truncated (\*(L"clobbered\*(R") n' nonexistin filez newly pimped.
If \s-1MODE\s0 is \f(CW\*(C`>>\*(C'\fR, tha file is opened fo' appending, again n' again n' again being
created if necessary.
.Sp
Yo ass can put a \f(CW\*(C`+\*(C'\fR up in front of tha \f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR to
indicate dat you want both read n' write access ta tha file; thus
\&\f(CW\*(C`+<\*(C'\fR be almost always preferred fo' read/write thugged-out shit\*(--the 
\&\f(CW\*(C`+>\*(C'\fR mode would clobber tha file first.  Yo ass can't probably use
either read-write mode fo' uppimpin textfiles, since they have
variable-length records.  See tha \fB\-i\fR switch up in perlrun fo' a
betta approach.  Da file is pimped wit permissionz of \f(CW0666\fR
modified by tha processs \f(CW\*(C`umask\*(C'\fR value.
.Sp
These various prefixes correspond ta tha \fIfopen\fR\|(3) modez of \f(CW\*(C`r\*(C'\fR,
\&\f(CW\*(C`r+\*(C'\fR, \f(CW\*(C`w\*(C'\fR, \f(CW\*(C`w+\*(C'\fR, \f(CW\*(C`a\*(C'\fR, n' \f(CW\*(C`a+\*(C'\fR.
.Sp
In tha one\- n' two-argument formz of tha call, tha mode n' filename
should be concatenated (in dat order), preferably separated by white
space.  Yo ass can\*(--but shouldn't\*(--omit tha mode up in these forms when dat mode
is \f(CW\*(C`<\*(C'\fR.  It be always safe ta use tha two-argument form of \f(CW\*(C`open\*(C'\fR if
the filename argument be a known literal.
.Sp
For three or mo' arguments if \s-1MODE\s0 is \f(CW\*(C`|\-\*(C'\fR, tha filename is
interpreted as a cold-ass lil command ta which output is ta be piped, n' if \s-1MODE\s0
is \f(CW\*(C`\-|\*(C'\fR, tha filename is interpreted as a cold-ass lil command dat pipes
output ta us.  In tha two-argument (and one-argument) form, one should
replace dash (\f(CW\*(C`\-\*(C'\fR) wit tha command.
See \*(L"Usin \fIopen()\fR fo' \s-1IPC\*(R"\s0 up in perlipc fo' mo' examplez of all dis bullshit.
(Yo ass aint allowed ta \f(CW\*(C`open\*(C'\fR ta a cold-ass lil command dat pipes both up in \fIand\fR
out yo, but peep IPC::Open2, IPC::Open3, and
\&\*(L"Bidirectionizzle Communication wit Another Process\*(R" up in perlipc for
alternatives.)
.Sp
In tha form of pipe opens takin three or mo' arguments, if \s-1LIST\s0 is specified
(extra arguments afta tha command name) then \s-1LIST\s0 becomes arguments
to tha command invoked if tha platform supports dat shit.  Da meanin of
\&\f(CW\*(C`open\*(C'\fR wit mo' than three arguments fo' non-pipe modes aint yet
defined yo, but experimenstrual \*(L"layers\*(R" may give extra \s-1LIST\s0 arguments
meaning.
.Sp
In tha two-argument (and one-argument) form, openin \f(CW\*(C`<\-\*(C'\fR 
or \f(CW\*(C`\-\*(C'\fR opens \s-1STDIN\s0 n' openin \f(CW\*(C`>\-\*(C'\fR opens \s-1STDOUT.\s0
.Sp
Yo ass may (and probably should) use tha three-argument form of open ta specify
I/O layers (sometimes referred ta as \*(L"disciplines\*(R") ta apply ta tha handle
that affect how tha fuck tha input n' output is processed (see open and
PerlIO fo' mo' details).  For example:
.Sp
.Vb 2
\&  open(my $fh, "<:encoding(UTF\-8)", "filename")
\&    || take a thugged-out dirtnap "can\*(Aqt open UTF\-8 encoded filename: $!";
.Ve
.Sp
opens tha UTF8\-encoded file containin Unicode characters;
see perluniintro.  Note dat if layers is specified up in the
three-argument form, then default layers stored up in ${^OPEN} (see perlvar;
usually set by tha \fBopen\fR pragma or tha switch \fB\-CioD\fR) is ignored.
Those layers will also be ignored if you specifyin a cold-ass lil colon wit no name
followin dat shit.  In dat case tha default layer fo' tha operatin system
(:raw on Unix, :crlf on Windows) is used.
.Sp
Open returns nonzero on success, tha undefined value otherwise.  If
the \f(CW\*(C`open\*(C'\fR involved a pipe, tha return value happens ta be tha pid of
the subprocess.
.Sp
If you hustlin Perl on a system dat distinguishes between text
filez n' binary files, then you should check up \*(L"binmode\*(R" fo' tips
for dealin wit all dis bullshit.  Da key distinction between systems dat need
\&\f(CW\*(C`binmode\*(C'\fR n' dem dat don't is they text file formats, n' you can put dat on yo' toast.  Systems
like Unix, Mac \s-1OS,\s0 n' Plan 9, dat end lines wit a single
characta n' encode dat characta up in C as \f(CW"\en"\fR do not
need \f(CW\*(C`binmode\*(C'\fR.  Da rest need dat shit.
.Sp
When openin a gangbangin' file, itz seldom a phat scam ta continue 
if tha request failed, so \f(CW\*(C`open\*(C'\fR is frequently used with
\&\f(CW\*(C`die\*(C'\fR.  Even if \f(CW\*(C`die\*(C'\fR won't do what tha fuck you want (say, up in a \s-1CGI\s0 script,
where you wanna format a suitable error message (but there are
modulez dat can help wit dat problem)) always check
the return value from openin a gangbangin' file.
.Sp
As a special case tha three-argument form wit a read/write mode n' tha third
argument bein \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 1
\&    open(my $tmp, "+>", undef) or take a thugged-out dirtnap ...
.Ve
.Sp
opens a gangbangin' filehandle ta a anonymous temporary file.  Also rockin \f(CW\*(C`+<\*(C'\fR
works fo' symmetry yo, but you straight-up should consider freestylin something
to tha temporary file first.  Yo ass will need ta \fIseek()\fR ta do the
reading.
.Sp
Perl is built rockin PerlIO by default; Unless you've
changed dis (like fuckin buildin Perl wit \f(CW\*(C`Configure \-Uuseperlio\*(C'\fR), you can
open filehandlez directly ta Perl scalars via:
.Sp
.Vb 1
\&    open($fh, ">", \e$variable) || ..
.Ve
.Sp
To (re)open \f(CW\*(C`STDOUT\*(C'\fR or \f(CW\*(C`STDERR\*(C'\fR as a in-memory file, close it first:
.Sp
.Vb 3
\&    close STDOUT;
\&    open(STDOUT, ">", \e$variable)
\&        or take a thugged-out dirtnap "Can\*(Aqt open STDOUT: $!";
.Ve
.Sp
General examples:
.Sp
.Vb 3
\&    $ARTICLE = 100;
\&    open(ARTICLE) or take a thugged-out dirtnap "Can\*(Aqt find article $ARTICLE: $!\en";
\&    while (<ARTICLE>) {...
\&
\&    open(LOG, ">>/usr/spool/news/twitlog");  # (log is reserved)
\&    # if tha open fails, output is discarded
\&
\&    open(my $dbase, "+<", "dbase.mine")      # open fo' update
\&        or take a thugged-out dirtnap "Can\*(Aqt open \*(Aqdbase.mine\*(Aq fo' update: $!";
\&
\&    open(my $dbase, "+<dbase.mine")          # ditto
\&        or take a thugged-out dirtnap "Can\*(Aqt open \*(Aqdbase.mine\*(Aq fo' update: $!";
\&
\&    open(ARTICLE, "\-|", "caesar <$article")  # decrypt article
\&        or take a thugged-out dirtnap "Can\*(Aqt start caesar: $!";
\&
\&    open(ARTICLE, "caesar <$article |")      # ditto
\&        or take a thugged-out dirtnap "Can\*(Aqt start caesar: $!";
\&
\&    open(EXTRACT, "|sort >Tmp$$")            # $$ is our process id
\&        or take a thugged-out dirtnap "Can\*(Aqt start sort: $!";
\&
\&    # in\-memory files
\&    open(MEMORY, ">", \e$var)
\&        or take a thugged-out dirtnap "Can\*(Aqt open memory file: $!";
\&    print MEMORY "foo!\en";              # output will step tha fuck up in $var
\&
\&    # process argument list of filez along wit any includes
\&
\&    foreach $file (@ARGV) {
\&        process($file, "fh00");
\&    }
\&
\&    sub process {
\&        my($filename, $input) = @_;
\&        $input++;    # dis be a strang increment
\&        unless (open($input, "<", $filename)) {
\&            print STDERR "Can\*(Aqt open $filename: $!\en";
\&            return;
\&        }
\&
\&        local $_;
\&        while (<$input>) {    # note use of indirection
\&            if (/^#include "(.*)"/) {
\&                process($1, $input);
\&                next;
\&            }
\&            #...          # whatever
\&        }
\&    }
.Ve
.Sp
See perliol fo' detailed info on PerlIO.
.Sp
Yo ass may also, up in tha Bourne shell tradition, specify a \s-1EXPR\s0 beginning
with \f(CW\*(C`>&\*(C'\fR, up in which case tha rest of tha strang is interpreted
as tha name of a gangbangin' filehandle (or file descriptor, if numeric) ta be
duped (as \f(CWdup(2)\fR) n' opened. Y'all KNOW dat shit, muthafucka!  Yo ass may use \f(CW\*(C`&\*(C'\fR afta \f(CW\*(C`>\*(C'\fR,
\&\f(CW\*(C`>>\*(C'\fR, \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`+>\*(C'\fR, \f(CW\*(C`+>>\*(C'\fR, n' \f(CW\*(C`+<\*(C'\fR.
Da mode you specify should match tha mode of tha original gangsta filehandle.
(Dupin a gangbangin' filehandle do not take tha fuck into account any existin contents
of \s-1IO\s0 buffers.)  If you use tha three-argument
form, then you can pass either a
number, tha name of a gangbangin' filehandle, or tha aiiight \*(L"reference ta a glob\*(R".
.Sp
Here be a script dat saves, redirects, n' restores \f(CW\*(C`STDOUT\*(C'\fR and
\&\f(CW\*(C`STDERR\*(C'\fR rockin various methods:
.Sp
.Vb 3
\&    #!/usr/bin/perl
\&    open(my $oldout, ">&STDOUT")     or take a thugged-out dirtnap "Can\*(Aqt dup STDOUT: $!";
\&    open(OLDERR,     ">&", \e*STDERR) or take a thugged-out dirtnap "Can\*(Aqt dup STDERR: $!";
\&
\&    open(STDOUT, \*(Aq>\*(Aq, "foo.out") or take a thugged-out dirtnap "Can\*(Aqt redirect STDOUT: $!";
\&    open(STDERR, ">&STDOUT")     or take a thugged-out dirtnap "Can\*(Aqt dup STDOUT: $!";
\&
\&    select STDERR; $| = 1;  # make unbuffered
\&    select STDOUT; $| = 1;  # make unbuffered
\&
\&    print STDOUT "stdout 1\en";  # dis works for
\&    print STDERR "stderr 1\en";  # subprocesses too
\&
\&    open(STDOUT, ">&", $oldout) or take a thugged-out dirtnap "Can\*(Aqt dup \e$oldout: $!";
\&    open(STDERR, ">&OLDERR")    or take a thugged-out dirtnap "Can\*(Aqt dup OLDERR: $!";
\&
\&    print STDOUT "stdout 2\en";
\&    print STDERR "stderr 2\en";
.Ve
.Sp
If you specify \f(CW\*(Aq<&=X\*(Aq\fR, where \f(CW\*(C`X\*(C'\fR be a gangbangin' file descriptor number
or a gangbangin' filehandle, then Perl will do a equivalent of Cz \f(CW\*(C`fdopen\*(C'\fR of
that file descriptor (and not call \f(CWdup(2)\fR); dis is more
parsimoniouz of file descriptors.  For example:
.Sp
.Vb 2
\&    # open fo' input, reusin tha fileno of $fd
\&    open(FILEHANDLE, "<&=$fd")
.Ve
.Sp
or
.Sp
.Vb 1
\&    open(FILEHANDLE, "<&=", $fd)
.Ve
.Sp
or
.Sp
.Vb 2
\&    # open fo' append, rockin tha fileno of OLDFH
\&    open(FH, ">>&=", OLDFH)
.Ve
.Sp
or
.Sp
.Vb 1
\&    open(FH, ">>&=OLDFH")
.Ve
.Sp
Bein parsimonious on filehandlez be also useful (besides being
parsimonious) fo' example when suttin' is dependent on file
descriptors, like fo' example lockin rockin \fIflock()\fR.  If you do just
\&\f(CW\*(C`open(A, ">>&B")\*(C'\fR, tha filehandle A aint gonna have tha same file
descriptor as B, n' therefore flock(A) aint gonna flock(B) nor vice
versa.  But wit \f(CW\*(C`open(A, ">>&=B")\*(C'\fR, tha filehandlez will share
the same underlyin system file descriptor.
.Sp
Note dat under Perls olda than 5.8.0, Perl uses tha standard C library's'
\&\fIfdopen()\fR ta implement tha \f(CW\*(C`=\*(C'\fR functionality.  On nuff Unix systems,
\&\fIfdopen()\fR fails when file descriptors exceed a cold-ass lil certain value, typically 255.
For Perls 5.8.0 n' later, PerlIO is (most often) tha default.
.Sp
Yo ass can peep whether yo' Perl was built wit PerlIO by hustlin \f(CW\*(C`perl \-V\*(C'\fR
and lookin fo' tha \f(CW\*(C`useperlio=\*(C'\fR line.  If \f(CW\*(C`useperlio\*(C'\fR is \f(CW\*(C`define\*(C'\fR, you
have PerlIO; otherwise you don't.
.Sp
If you open a pipe on tha command \f(CW\*(C`\-\*(C'\fR (that is, specify either \f(CW\*(C`|\-\*(C'\fR or \f(CW\*(C`\-|\*(C'\fR
with tha one\- or two-argument formz of \f(CW\*(C`open\*(C'\fR), 
an implicit \f(CW\*(C`fork\*(C'\fR is done, so \f(CW\*(C`open\*(C'\fR returns twice: up in tha parent
process it returns tha pid
of tha lil pimp process, n' up in tha lil pimp process it returns (a defined) \f(CW0\fR.
Use \f(CW\*(C`defined($pid)\*(C'\fR or \f(CW\*(C`//\*(C'\fR ta determine whether tha open was successful.
.Sp
For example, use either
.Sp
.Vb 1
\&    $child_pid = open(FROM_KID, "\-|")   // take a thugged-out dirtnap "can\*(Aqt fork: $!";
.Ve
.Sp
or
.Sp
.Vb 1
\&    $child_pid = open(TO_KID,   "|\-")   // take a thugged-out dirtnap "can\*(Aqt fork: $!";
.Ve
.Sp
followed by
.Sp
.Vb 10
\&    if ($child_pid) {
\&        # be tha parent:
\&        # either write TO_KID or else read FROM_KID
\&        ...
\&       waitpid $child_pid, 0;
\&    } else {
\&        # be tha child; use STDIN/STDOUT normally
\&        ...
\&        exit;
\&    }
.Ve
.Sp
Da filehandle behaves normally fo' tha parent yo, but I/O ta that
filehandle is piped from/to tha \s-1STDOUT/STDIN\s0 of tha lil pimp process.
In tha lil pimp process, tha filehandle aint opened\*(--I/O happens from/to
the freshly smoked up \s-1STDOUT/STDIN. \s0 Typically dis is used like tha normal
piped open when you wanna exercise mo' control over just how tha fuck the
pipe command gets executed, like fuckin when hustlin setuid and
you don't wanna gotta scan shell commandz fo' metacharacters.
.Sp
Da followin blocks is mo' or less equivalent:
.Sp
.Vb 4
\&    open(FOO, "|tr \*(Aq[a\-z]\*(Aq \*(Aq[A\-Z]\*(Aq");
\&    open(FOO, "|\-", "tr \*(Aq[a\-z]\*(Aq \*(Aq[A\-Z]\*(Aq");
\&    open(FOO, "|\-") || exec \*(Aqtr\*(Aq, \*(Aq[a\-z]\*(Aq, \*(Aq[A\-Z]\*(Aq;
\&    open(FOO, "|\-", "tr", \*(Aq[a\-z]\*(Aq, \*(Aq[A\-Z]\*(Aq);
\&
\&    open(FOO, "cat \-n \*(Aq$file\*(Aq|");
\&    open(FOO, "\-|", "cat \-n \*(Aq$file\*(Aq");
\&    open(FOO, "\-|") || exec "cat", "\-n", $file;
\&    open(FOO, "\-|", "cat", "\-n", $file);
.Ve
.Sp
Da last two examplez up in each block show tha pipe as \*(L"list form\*(R", which is
not yet supported on all platforms.  A phat rule of thumb is dat if
your platform has a real \f(CW\*(C`fork()\*(C'\fR (in other lyrics, if yo' platform is
Unix, includin Linux n' MacOS X), you can use tha list form.  Yo ass would 
wanna use tha list form of tha pipe so you can pass literal arguments
to tha command without risk of tha shell interpretin any shell metacharacters
in em.  But fuck dat shiznit yo, tha word on tha street is dat dis also bars you from openin pipes ta commands
that intentionally contain shell metacharacters, such as:
.Sp
.Vb 2
\&    open(FOO, "|cat \-n | expand \-4 | lpr")
\&        // take a thugged-out dirtnap "Can\*(Aqt open pipeline ta lpr: $!";
.Ve
.Sp
See \*(L"Safe Pipe Opens\*(R" up in perlipc fo' mo' examplez of all dis bullshit.
.Sp
Perl will attempt ta flush all filez opened for
output before any operation dat may do a gangbangin' fork yo, but dis may not be
supported on some platforms (see perlport).  To be safe, you may need
to set \f(CW$|\fR ($AUTOFLUSH up in Gangsta) or call tha \f(CW\*(C`autoflush()\*(C'\fR method
of \f(CW\*(C`IO::Handle\*(C'\fR on any open handles.
.Sp
On systems dat support a cold-ass lil close-on-exec flag on files, tha flag will
be set fo' tha newly opened file descriptor as determined by tha value
of \f(CW$^F\fR.  See \*(L"$^F\*(R" up in perlvar.
.Sp
Closin any piped filehandle causes tha parent process ta wait fo' the
child ta finish, then returns tha status value up in \f(CW$?\fR and
\&\f(CW\*(C`${^CHILD_ERROR_NATIVE}\*(C'\fR.
.Sp
Da filename passed ta tha one\- n' two-argument formz of \fIopen()\fR will
have leadin n' trailin whitespace deleted n' normal
redirection charactas honored. Y'all KNOW dat shit, muthafucka!  This property, known as \*(L"magic open\*(R",
can often be used ta phat effect.  A user could specify a gangbangin' filename of
\&\fI\*(L"rsh pussaaaaay file |\*(R"\fR, or you could chizzle certain filenames as needed:
.Sp
.Vb 2
\&    $filename =~ s/(.*\e.gz)\es*$/gzip \-dc < $1|/;
\&    open(FH, $filename) or take a thugged-out dirtnap "Can\*(Aqt open $filename: $!";
.Ve
.Sp
Use tha three-argument form ta open a gangbangin' file wit arbitrary weird charactas up in it,
.Sp
.Vb 2
\&    open(FOO, "<", $file)
\&        || take a thugged-out dirtnap "can\*(Aqt open < $file: $!";
.Ve
.Sp
otherwise itz necessary ta protect any leadin n' trailin whitespace:
.Sp
.Vb 3
\&    $file =~ s#^(\es)#./$1#;
\&    open(FOO, "< $file\e0")
\&        || take a thugged-out dirtnap "open failed: $!";
.Ve
.Sp
(this may not work on some bizarre filesystems).  One should
conscientiously chizzle between tha \fImagic\fR n' \fIthree-argument\fR form
of \fIopen()\fR:
.Sp
.Vb 1
\&    open(IN, $ARGV[0]) || take a thugged-out dirtnap "can\*(Aqt open $ARGV[0]: $!";
.Ve
.Sp
will allow tha user ta specify a argument of tha form \f(CW"rsh pussaaaaay file |"\fR,
but aint gonna work on a gangbangin' filename dat happens ta git a trailin space, while
.Sp
.Vb 2
\&    open(IN, "<", $ARGV[0])
\&        || take a thugged-out dirtnap "can\*(Aqt open < $ARGV[0]: $!";
.Ve
.Sp
will have exactly tha opposite restrictions.
.Sp
If you want a \*(L"real\*(R" C \f(CW\*(C`open\*(C'\fR (see \fIopen\fR\|(2) on yo' system), then you
should use tha \f(CW\*(C`sysopen\*(C'\fR function, which involves no such magic (but may
use subtly different filemodes than Perl \fIopen()\fR, which is mapped ta C
\&\fIfopen()\fR).  This be another way ta protect yo' filenames from
interpretation. I aint talkin' bout chicken n' gravy biatch.  For example:
.Sp
.Vb 7
\&    use IO::Handle;
\&    sysopen(HANDLE, $path, O_RDWR|O_CREAT|O_EXCL)
\&        or take a thugged-out dirtnap "sysopen $path: $!";
\&    $oldfh = select(HANDLE); $| = 1; select($oldfh);
\&    print HANDLE "shiznit $$\en";
\&    seek(HANDLE, 0, 0);
\&    print "File gotz nuff: ", <HANDLE>;
.Ve
.Sp
Usin tha constructor from tha \f(CW\*(C`IO::Handle\*(C'\fR package (or one of its
subclasses, like fuckin \f(CW\*(C`IO::File\*(C'\fR or \f(CW\*(C`IO::Socket\*(C'\fR), you can generate anonymous
filehandlez dat have tha scope of tha variablez used ta hold them, then
automatically (but silently) close once they reference counts become
zero, typically at scope exit:
.Sp
.Vb 10
\&    use IO::File;
\&    #...
\&    sub read_myfile_munged {
\&        mah $ALL = shift;
\&        # or just leave it undef ta autoviv
\&        mah $handle = IO::File\->new;
\&        open($handle, "<", "myfile") or take a thugged-out dirtnap "myfile: $!";
\&        $first = <$handle>
\&            or return ();     # Automatically closed here.
\&        mung($first) or take a thugged-out dirtnap "mung failed";  # Or here.
\&        return (first, <$handle>) if $ALL;  # Or here.
\&        return $first;                      # Or here.
\&    }
.Ve
.Sp
\&\fB\s-1WARNING:\s0\fR Da previous example has a funky-ass bug cuz tha automatic
close dat happens when tha refcount on \f(CW\*(C`handle\*(C'\fR reaches zero do not
properly detect n' report failures.  \fIAlways\fR close tha handle
yo ass n' inspect tha return value.
.Sp
.Vb 2
\&    close($handle) 
\&        || warn "close failed: $!";
.Ve
.Sp
See \*(L"seek\*(R" fo' some details bout mixin readin n' writing.
.Sp
Portabilitizzle issues: \*(L"open\*(R" up in perlport.
.IP "opendir \s-1DIRHANDLE,EXPR \s0" 4
.IX Xref "opendir"
.IX Item "opendir DIRHANDLE,EXPR "
Opens a gangbangin' finger-lickin' directory named \s-1EXPR\s0 fo' processin by \f(CW\*(C`readdir\*(C'\fR, \f(CW\*(C`telldir\*(C'\fR,
\&\f(CW\*(C`seekdir\*(C'\fR, \f(CW\*(C`rewinddir\*(C'\fR, n' \f(CW\*(C`closedir\*(C'\fR.  Returns legit if successful.
\&\s-1DIRHANDLE\s0 may be a expression whose value can be used as a indirect
dirhandle, probably tha real dirhandle name.  If \s-1DIRHANDLE\s0 be a undefined
scalar variable (or array or hash element), tha variable be assigned a
reference ta a freshly smoked up anonymous dirhandle; dat is, itz autovivified.
DIRHANDLEs have they own namespace separate from FILEHANDLEs.
.Sp
See tha example at \f(CW\*(C`readdir\*(C'\fR.
.IP "ord \s-1EXPR \s0" 4
.IX Xref "ord encoding"
.IX Item "ord EXPR "
.PD 0
.IP "ord" 4
.IX Item "ord"
.PD
Returns tha numeric value of tha straight-up original gangsta characta of \s-1EXPR.\s0
If \s-1EXPR\s0 be a empty string, returns 0.  If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
(Note \fIcharacter\fR, not byte.)
.Sp
For tha reverse, peep \*(L"chr\*(R".
See perlunicode fo' mo' bout Unicode.
.IP "our \s-1EXPR \s0" 4
.IX Xref "our global"
.IX Item "our EXPR "
.PD 0
.IP "our \s-1TYPE EXPR\s0" 4
.IX Item "our TYPE EXPR"
.IP "our \s-1EXPR : ATTRS\s0" 4
.IX Item "our EXPR : ATTRS"
.IP "our \s-1TYPE EXPR : ATTRS\s0" 4
.IX Item "our TYPE EXPR : ATTRS"
.PD
\&\f(CW\*(C`our\*(C'\fR cook up a lexical alias ta a package variable of tha same name up in tha current
package fo' use within tha current lexical scope.
.Sp
\&\f(CW\*(C`our\*(C'\fR has tha same ol' dirty scopin rulez as \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR yo, but \f(CW\*(C`our\*(C'\fR only
declares a alias, whereas \f(CW\*(C`my\*(C'\fR or \f(CW\*(C`state\*(C'\fR both declare a variable name and
allocate storage fo' dat name within tha current scope.
.Sp
This means dat when \f(CW\*(C`use strict \*(Aqvars\*(Aq\*(C'\fR is up in effect, \f(CW\*(C`our\*(C'\fR lets you use
a package variable without qualifyin it wit tha package name yo, but only within
the lexical scope of tha \f(CW\*(C`our\*(C'\fR declaration. I aint talkin' bout chicken n' gravy biatch.  In dis way, \f(CW\*(C`our\*(C'\fR differs from
\&\f(CW\*(C`use vars\*(C'\fR, which allows use of a unqualified name \fIonly\fR within the
affected package yo, but across scopes.
.Sp
If mo' than one value is listed, tha list must be placed
in parentheses.
.Sp
.Vb 2
\&    our $foo;
\&    our($bar, $baz);
.Ve
.Sp
An \f(CW\*(C`our\*(C'\fR declaration declares a alias fo' a package variable dat is ghon be visible
across its entire lexical scope, even across package boundaries. Put ya muthafuckin choppers up if ya feel dis!  The
package up in which tha variable is entered is determined all up in tha point
of tha declaration, not all up in tha deal wit use.  This means tha following
behavior holds:
.Sp
.Vb 3
\&    package Foo;
\&    our $bar;      # declares $Foo::bar fo' rest of lexical scope
\&    $bar = 20;
\&
\&    package Bar;
\&    print $bar;    # prints 20, as it refers ta $Foo::bar
.Ve
.Sp
Multiple \f(CW\*(C`our\*(C'\fR declarations wit tha same name up in tha same lexical
scope is allowed if they is up in different packages.  If they happen
to be up in tha same package, Perl will emit warnings if you have asked
for them, just like multiple \f(CW\*(C`my\*(C'\fR declarations.  Unlike a second
\&\f(CW\*(C`my\*(C'\fR declaration, which will bind tha name ta a gangbangin' fresh variable, a
second \f(CW\*(C`our\*(C'\fR declaration up in tha same package, up in tha same scope, is
merely redundant.
.Sp
.Vb 4
\&    use warnings;
\&    package Foo;
\&    our $bar;      # declares $Foo::bar fo' rest of lexical scope
\&    $bar = 20;
\&
\&    package Bar;
\&    our $bar = 30; # declares $Bar::bar fo' rest of lexical scope
\&    print $bar;    # prints 30
\&
\&    our $bar;      # emits warnin but has no other effect
\&    print $bar;    # still prints 30
.Ve
.Sp
An \f(CW\*(C`our\*(C'\fR declaration may also gotz a list of attributes associated
with dat shit.
.Sp
Da exact semantics n' intercourse of \s-1TYPE\s0 n' \s-1ATTRS\s0 is still
evolving.  \s-1TYPE\s0 is currently bound ta tha use of tha \f(CW\*(C`fields\*(C'\fR pragma,
and attributes is handled rockin tha \f(CW\*(C`attributes\*(C'\fR pragma, or, starting
from Perl 5.8.0, also via tha \f(CW\*(C`Attribute::Handlezs\*(C'\fR module.  See
\&\*(L"Private Variablez via \fImy()\fR\*(R" up in perlsub fo' details, n' fields,
attributes, n' Attribute::Handlezs.
.IP "pack \s-1TEMPLATE,LIST \s0" 4
.IX Xref "pack"
.IX Item "pack TEMPLATE,LIST "
Takes a \s-1LIST\s0 of joints n' converts it tha fuck into a strang rockin tha rules
given by tha \s-1TEMPLATE. \s0 Da resultin strang is tha concatenation of
the converted joints, n' you can put dat on yo' toast.  Typically, each converted value looks
like its machine-level representation. I aint talkin' bout chicken n' gravy biatch.  For example, on 32\-bit machines
an integer may be represented by a sequence of 4 bytes, which  will in
Perl be presented as a strang thatz 4 charactas long.
.Sp
See perlpacktut fo' a introduction ta dis function.
.Sp
Da \s-1TEMPLATE\s0 be a sequence of charactas dat give tha order n' type
of joints, as bigs up:
.Sp
.Vb 3
\&    a  A strang wit arbitrary binary data, is ghon be null padded.
\&    A  A text (ASCII) string, is ghon be space padded.
\&    Z  A null\-terminated (ASCIZ) string, is ghon be null padded.
\&
\&    b  A bit strang (ascendin bit order inside each byte,
\&       like vec()).
\&    B  A bit strang (descendin bit order inside each byte).
\&    h  A hex strang (low nybble first).
\&    H  A hex strang (high nybble first).
\&
\&    c  A signed char (8\-bit) value.
\&    C  An unsigned char (octet) value.
\&    W  An unsigned char value (can be pimped outa than 255).
\&
\&    s  A signed short (16\-bit) value.
\&    S  An unsigned short value.
\&
\&    l  A signed long (32\-bit) value.
\&    L  An unsigned long value.
\&
\&    q  A signed quad (64\-bit) value.
\&    Q  An unsigned quad value.
\&         (Quadz is available only if yo' system supports 64\-bit
\&          integer joints _and_ if Perl has been compiled ta support
\&          them.  Raises a exception otherwise.)
\&
\&    i  A signed integer value.
\&    I  A unsigned integer value.
\&         (This \*(Aqinteger\*(Aq is _at_least_ 32 bits wide.  Its exact
\&          size dependz on what tha fuck a local C compila calls \*(Aqint\*(Aq.)
\&
\&    n  An unsigned short (16\-bit) up in "network" (big\-endian) order.
\&    N  An unsigned long (32\-bit) up in "network" (big\-endian) order.
\&    v  An unsigned short (16\-bit) up in "VAX" (lil\-endian) order.
\&    V  An unsigned long (32\-bit) up in "VAX" (lil\-endian) order.
\&
\&    j  A Perl internal signed integer value (IV).
\&    J  A Perl internal unsigned integer value (UV).
\&
\&    f  A single\-precision float up in natizzle format.
\&    d  A double\-precision float up in natizzle format.
\&
\&    F  A Perl internal floating\-point value (NV) up in natizzle format
\&    D  A float of long\-double precision up in natizzle format.
\&         (Long doublez is available only if yo' system supports
\&          long double joints _and_ if Perl has been compiled to
\&          support them.  Raises a exception otherwise.)
\&
\&    p  A pointa ta a null\-terminated string.
\&    P  A pointa ta a structure (fixed\-length string).
\&
\&    u  A uuencoded string.
\&    U  A Unicode characta number n' shit.  Encodes ta a cold-ass lil characta up in char\-
\&       acta mode n' UTF\-8 (or UTF\-EBCDIC up in EBCDIC platforms) in
\&       byte mode.
\&
\&    w  A BER compressed integer (not a ASN.1 BER, peep perlpacktut
\&       fo' details).  Its bytes represent a unsigned integer in
\&       base 128, most dope digit first, wit as few digits
\&       as possible.  Bit eight (the high bit) is set on each byte
\&       except tha last.
\&
\&    x  A null byte (a.k.a ASCII NUL, "\e000", chr(0))
\&    X  Back up a funky-ass byte.
\&    @  Null\-fill or truncate ta absolute position, counted from the
\&       start of tha innermost ()\-group.
\&    .  Null\-fill or truncate ta absolute posizzle specified by
\&       tha value.
\&    (  Start of a ()\-group.
.Ve
.Sp
One or mo' modifiers below may optionally follow certain lettas up in the
\&\s-1TEMPLATE \s0(the second column lists lettas fo' which tha modifier is valid):
.Sp
.Vb 2
\&    !   sSlLiI     Forces natizzle (short, long, int) sizes instead
\&                   of fixed (16\-/32\-bit) sizes.
\&
\&        xX         Make x n' X act as alignment commands.
\&
\&        nNvV       Treat integers as signed instead of unsigned.
\&
\&        @.         Specify posizzle as byte offset up in tha internal
\&                   representation of tha packed string.  Efficient
\&                   but dangerous.
\&
\&    >   sSiIlLqQ   Force big\-endian byte\-order on tha type.
\&        jJfFdDpP   (Da "bangin' end" touches tha construct.)
\&
\&    <   sSiIlLqQ   Force lil\-endian byte\-order on tha type.
\&        jJfFdDpP   (Da "lil end" touches tha construct.)
.Ve
.Sp
Da \f(CW\*(C`>\*(C'\fR n' \f(CW\*(C`<\*(C'\fR modifiers can also be used on \f(CW\*(C`()\*(C'\fR crews 
to force a particular byte-order on all components up in dat group, 
includin all its subgroups.
.Sp
Da followin rulez apply:
.RS 4
.IP "\(bu" 4
Each letta may optionally be followed by a number indicatin tha repeat
count.  A numeric repeat count may optionally be enclosed up in brackets, as
in \f(CW\*(C`pack("C[80]", @arr)\*(C'\fR.  Da repeat count gobblez dat nuff joints from
the \s-1LIST\s0 when used wit all format types other than \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`A\*(C'\fR, \f(CW\*(C`Z\*(C'\fR, \f(CW\*(C`b\*(C'\fR,
\&\f(CW\*(C`B\*(C'\fR, \f(CW\*(C`h\*(C'\fR, \f(CW\*(C`H\*(C'\fR, \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`.\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`X\*(C'\fR, n' \f(CW\*(C`P\*(C'\fR, where it means
suttin' else, busted lyrics bout below.  Supplyin a \f(CW\*(C`*\*(C'\fR fo' tha repeat count
instead of a number means ta use however nuff shit is left, except for:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`@\*(C'\fR, \f(CW\*(C`x\*(C'\fR, n' \f(CW\*(C`X\*(C'\fR, where it is equivalent ta \f(CW0\fR.
.IP "\(bu" 4
<.>, where it means relatizzle ta tha start of tha string.
.IP "\(bu" 4
\&\f(CW\*(C`u\*(C'\fR, where it is equivalent ta 1 (or 45, which here is equivalent).
.RE
.RS 4
.Sp
One can replace a numeric repeat count wit a template letta enclosed in
brackets ta use tha packed byte length of tha bracketed template fo' the
repeat count.
.Sp
For example, tha template \f(CW\*(C`x[L]\*(C'\fR skips as nuff bytes as up in a packed long,
and tha template \f(CW"$t X[$t] $t"\fR unpacks twice whatever \f(CW$t\fR (when
variable-expanded) unpacks.  If tha template up in brackets gotz nuff alignment
commandz (like fuckin \f(CW\*(C`x![d]\*(C'\fR), its packed length is calculated as if the
start of tha template had tha maximal possible alignment.
.Sp
When used wit \f(CW\*(C`Z\*(C'\fR, a \f(CW\*(C`*\*(C'\fR as tha repeat count is guaranteed ta add a
trailin null byte, so tha resultin strang be always one byte longer than
the byte length of tha item itself.
.Sp
When used wit \f(CW\*(C`@\*(C'\fR, tha repeat count represents a offset from tha start
of tha innermost \f(CW\*(C`()\*(C'\fR group.
.Sp
When used wit \f(CW\*(C`.\*(C'\fR, tha repeat count determines tha startin posizzle to
calculate tha value offset as bigs up:
.IP "\(bu" 4
If tha repeat count is \f(CW0\fR, itz relatizzle ta tha current position.
.IP "\(bu" 4
If tha repeat count is \f(CW\*(C`*\*(C'\fR, tha offset is relatizzle ta tha start of the
packed string.
.IP "\(bu" 4
And if itz a integer \fIn\fR, tha offset is relatizzle ta tha start of the
\&\fIn\fRth innermost \f(CW\*(C`( )\*(C'\fR group, or ta tha start of tha strang if \fIn\fR is
bigger then tha crew level.
.RE
.RS 4
.Sp
Da repeat count fo' \f(CW\*(C`u\*(C'\fR is interpreted as tha maximal number of bytes
to encode per line of output, wit 0, 1 n' 2 replaced by 45.  Da repeat 
count should not be mo' than 65.
.RE
.IP "\(bu" 4
Da \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`A\*(C'\fR, n' \f(CW\*(C`Z\*(C'\fR types gobble just one value yo, but pack it as a
strin of length count, paddin wit nulls or spaces as needed. Y'all KNOW dat shit, muthafucka!  When
unpacking, \f(CW\*(C`A\*(C'\fR strips trailin whitespace n' nulls, \f(CW\*(C`Z\*(C'\fR strips every last muthafuckin thang
afta tha straight-up original gangsta null, n' \f(CW\*(C`a\*(C'\fR returns data wit no strippin at all.
.Sp
If tha value ta pack is too long, tha result is truncated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If itz too
long n' a explicit count is provided, \f(CW\*(C`Z\*(C'\fR packs only \f(CW\*(C`$count\-1\*(C'\fR bytes,
followed by a null byte.  Thus \f(CW\*(C`Z\*(C'\fR always packs a trailin null, except
when tha count is 0.
.IP "\(bu" 4
Likewise, tha \f(CW\*(C`b\*(C'\fR n' \f(CW\*(C`B\*(C'\fR formats pack a strang thatz dat nuff bits long.
Each such format generates 1 bit of tha result.  These is typically followed
by a repeat count like \f(CW\*(C`B8\*(C'\fR or \f(CW\*(C`B64\*(C'\fR.
.Sp
Each result bit is based on tha least-significant bit of tha corresponding
input character, i.e., on \f(CW\*(C`ord($char)%2\*(C'\fR.  In particular, charactas \f(CW"0"\fR
and \f(CW"1"\fR generate bits 0 n' 1, as do charactas \f(CW"\e000"\fR n' \f(CW"\e001"\fR.
.Sp
Startin from tha beginnin of tha input string, each 8\-tuple
of charactas is converted ta 1 characta of output.  With format \f(CW\*(C`b\*(C'\fR,
the first characta of tha 8\-tuple determines tha least-significant bit of a
character; wit format \f(CW\*(C`B\*(C'\fR, it determines da most thugged-out-significant bit of
a character.
.Sp
If tha length of tha input strang aint evenly divisible by 8, the
remainder is packed as if tha input strang was padded by null characters
at tha end yo, but it ain't no stoppin cause I be still poppin'.  Similarly durin unpacking, \*(L"extra\*(R" bits is ignored.
.Sp
If tha input strang is longer than needed, remainin charactas is ignored.
.Sp
A \f(CW\*(C`*\*(C'\fR fo' tha repeat count uses all charactaz of tha input field. Y'all KNOW dat shit, muthafucka!  
On unpacking, bits is converted ta a strang of \f(CW0\fRs n' \f(CW1\fRs.
.IP "\(bu" 4
Da \f(CW\*(C`h\*(C'\fR n' \f(CW\*(C`H\*(C'\fR formats pack a strang dat nuff nybblez (4\-bit groups,
representable as hexadecimal digits, \f(CW"0".."9"\fR \f(CW"a".."f"\fR) long.
.Sp
For each such format, \fIpack()\fR generates 4 bitz of result.
With non-alphabetical characters, tha result is based on tha 4 least-significant
bitz of tha input character, i.e., on \f(CW\*(C`ord($char)%16\*(C'\fR.  In particular,
charactas \f(CW"0"\fR n' \f(CW"1"\fR generate nybblez 0 n' 1, as do bytes
\&\f(CW"\e000"\fR n' \f(CW"\e001"\fR.  For charactas \f(CW"a".."f"\fR n' \f(CW"A".."F"\fR, tha result
is compatible wit tha usual hexadecimal digits, so dat \f(CW"a"\fR and
\&\f(CW"A"\fR both generate tha nybble \f(CW\*(C`0xA==10\*(C'\fR.  Use only these specific hex 
charactas wit dis format.
.Sp
Startin from tha beginnin of tha template ta \fIpack()\fR, each pair
of charactas is converted ta 1 characta of output.  With format \f(CW\*(C`h\*(C'\fR, the
first characta of tha pair determines tha least-significant nybble of the
output character; wit format \f(CW\*(C`H\*(C'\fR, it determines da most thugged-out-significant
nybble.
.Sp
If tha length of tha input strang aint even, it behaves as if padded by
a null characta all up in tha end yo, but it ain't no stoppin cause I be still poppin'.  Similarly, \*(L"extra\*(R" nybblez is ignored during
unpacking.
.Sp
If tha input strang is longer than needed, extra charactas is ignored.
.Sp
A \f(CW\*(C`*\*(C'\fR fo' tha repeat count uses all charactaz of tha input field. Y'all KNOW dat shit, muthafucka!  For
\&\fIunpack()\fR, nybblez is converted ta a strang of hexadecimal digits.
.IP "\(bu" 4
Da \f(CW\*(C`p\*(C'\fR format packs a pointa ta a null-terminated string.  Yo ass are
responsible fo' ensurin dat tha strang aint a temporary value, as that
could potentially git deallocated before you gots round ta rockin tha packed
result.  Da \f(CW\*(C`P\*(C'\fR format packs a pointa ta a structure of tha size indicated
by tha length.  A null pointa is pimped if tha correspondin value for
\&\f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR is \f(CW\*(C`undef\*(C'\fR; similarly wit \fIunpack()\fR, where a null pointer
unpacks tha fuck into \f(CW\*(C`undef\*(C'\fR.
.Sp
If yo' system has a strange pointa size\*(--meanin a pointa is neither as
bangin' as a int nor as big-ass as a long\*(--it may not be possible ta pack or
unpack pointas up in big\- or lil-endian byte order n' shit.  Attemptin ta do
so raises a exception.
.IP "\(bu" 4
Da \f(CW\*(C`/\*(C'\fR template characta allows packin n' unpackin of a sequence of
items where tha packed structure gotz nuff a packed item count followed by
the packed shit theyselves.  This is useful when tha structure you is
unpackin has encoded tha sizes or repeat counts fo' a shitload of its fields
within tha structure itself as separate fields.
.Sp
For \f(CW\*(C`pack\*(C'\fR, you write \fIlength-item\fR\f(CW\*(C`/\*(C'\fR\fIsequence-item\fR, n' the
\&\fIlength-item\fR raps bout how tha fuck tha length value is packed. Y'all KNOW dat shit, muthafucka!  Formats likely
to be of most use is integer-packin ones like \f(CW\*(C`n\*(C'\fR fo' Java strings,
\&\f(CW\*(C`w\*(C'\fR fo' \s-1ASN.1\s0 or \s-1SNMP,\s0 n' \f(CW\*(C`N\*(C'\fR fo' Sun \s-1XDR.\s0
.Sp
For \f(CW\*(C`pack\*(C'\fR, \fIsequence-item\fR may gotz a repeat count, up in which case
the minimum of dat n' tha number of available shit is used as tha argument
for \fIlength-item\fR.  If it has no repeat count or uses a '*', tha number
of available shit is used.
.Sp
For \f(CW\*(C`unpack\*(C'\fR, a internal stack of integer arguments unpacked so far is
used. Y'all KNOW dat shit, muthafucka!  Yo ass write \f(CW\*(C`/\*(C'\fR\fIsequence-item\fR n' tha repeat count is obtained by
poppin off tha last element from tha stack.  Da \fIsequence-item\fR must not
have a repeat count.
.Sp
If \fIsequence-item\fR refers ta a strang type (\f(CW"A"\fR, \f(CW"a"\fR, or \f(CW"Z"\fR),
the \fIlength-item\fR is tha strang length, not tha number of strings.  With
an explicit repeat count fo' pack, tha packed strang be adjusted ta that
length.  For example:
.Sp
.Vb 1
\& This code:                             gives dis result:
\&
\& unpack("W/a", "\e004Gurusamy")          ("Guru")
\& unpack("a3/A A*", "007 Bond  J ")      (" Bond", "J")
\& unpack("a3 x2 /A A*", "007: Bond, J.") ("Bond, J", ".")
\&
\& pack("n/a* w/a","hello,","world")     "\e000\e006hello,\e005world"
\& pack("a/W2", ord("a") .. ord("z"))    "2ab"
.Ve
.Sp
Da \fIlength-item\fR aint returned explicitly from \f(CW\*(C`unpack\*(C'\fR.
.Sp
Supplyin a cold-ass lil count ta tha \fIlength-item\fR format letta is only useful with
\&\f(CW\*(C`A\*(C'\fR, \f(CW\*(C`a\*(C'\fR, or \f(CW\*(C`Z\*(C'\fR.  Packin wit a \fIlength-item\fR of \f(CW\*(C`a\*(C'\fR or \f(CW\*(C`Z\*(C'\fR may
introduce \f(CW"\e000"\fR characters, which Perl do not regard as legal in
numeric strings.
.IP "\(bu" 4
Da integer types \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`l\*(C'\fR, n' \f(CW\*(C`L\*(C'\fR may be
followed by a \f(CW\*(C`!\*(C'\fR modifier ta specify natizzle shorts or
longs.  As shown up in tha example above, a funky-ass bare \f(CW\*(C`l\*(C'\fR means
exactly 32 bits, although tha natizzle \f(CW\*(C`long\*(C'\fR as peeped by tha local C compiler
may be larger n' shit.  This is mainly a issue on 64\-bit platforms.  Yo ass can
see whether rockin \f(CW\*(C`!\*(C'\fR make any difference dis way:
.Sp
.Vb 2
\&    printf "format s is %d, s muthafucka! is %d\en", 
\&        length pack("s"), length pack("s!");
\&
\&    printf "format l is %d, l! is %d\en", 
\&        length pack("l"), length pack("l!");
.Ve
.Sp
\&\f(CW\*(C`i!\*(C'\fR n' \f(CW\*(C`I!\*(C'\fR is also allowed yo, but only fo' completeness' sake:
they is identical ta \f(CW\*(C`i\*(C'\fR n' \f(CW\*(C`I\*(C'\fR.
.Sp
Da actual sizes (in bytes) of natizzle shorts, ints, longs, n' long
longs on tha platform where Perl was built is also available from
the command line:
.Sp
.Vb 5
\&    $ perl \-V:{short,int,long{,long}}size
\&    shortsize=\*(Aq2\*(Aq;
\&    intsize=\*(Aq4\*(Aq;
\&    longsize=\*(Aq4\*(Aq;
\&    longlongsize=\*(Aq8\*(Aq;
.Ve
.Sp
or programmatically via tha \f(CW\*(C`Config\*(C'\fR module:
.Sp
.Vb 5
\&       use Config;
\&       print $Config{shortsize},    "\en";
\&       print $Config{intsize},      "\en";
\&       print $Config{longsize},     "\en";
\&       print $Config{longlongsize}, "\en";
.Ve
.Sp
\&\f(CW$Config{longlongsize}\fR is undefined on systems without 
long long support.
.IP "\(bu" 4
Da integer formats \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`i\*(C'\fR, \f(CW\*(C`I\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`L\*(C'\fR, \f(CW\*(C`j\*(C'\fR, n' \f(CW\*(C`J\*(C'\fR are
inherently non-portable between processors n' operatin systems cuz
they obey natizzle byteorder n' endianness.  For example, a 4\-byte integer
0x12345678 (305419896 decimal) would be ordered natively (arranged up in and
handled by tha \s-1CPU\s0 registers) tha fuck into bytes as
.Sp
.Vb 2
\&    0x12 0x34 0x56 0x78  # big\-endian
\&    0x78 0x56 0x34 0x12  # lil\-endian
.Ve
.Sp
Basically, Intel n' \s-1VAX\s0 CPUs is lil-endian, while dem hoes else,
includin Motorola m68k/88k, \s-1PPC,\s0 Sparc, \s-1HP PA,\s0 Power, n' Cray, are
big-endian. I aint talkin' bout chicken n' gravy biatch.  Alpha n' \s-1MIPS\s0 can be either: Digital/Compaq uses (well, used) 
them up in lil-endian mode yo, but SGI/Cray uses dem up in big-endian mode.
.Sp
Da names \fIbig-endian\fR n' \fIlil-endian\fR is comic references ta the
egg-eatin habitz of tha lil-endian Lilliputians n' tha big-endian
Blefuscudians from tha funky-ass Jonathan Swift satire, \fIGulliverz Travels\fR.
This entered computa lingo via tha paper \*(L"On Holy Wars n' a Plea for
Peace\*(R" by Danny Cohen, \s-1USC/ISI IEN 137,\s0 April 1, 1980.
.Sp
Some systems may have even weirder byte ordaz such as
.Sp
.Vb 2
\&   0x56 0x78 0x12 0x34
\&   0x34 0x12 0x78 0x56
.Ve
.Sp
Yo ass can determine yo' system endiannizz wit dis incantation:
.Sp
.Vb 1
\&   printf("%#02x ", $_) fo' unpack("W*", pack L=>0x12345678);
.Ve
.Sp
Da byteorder on tha platform where Perl was built be also available
via Config:
.Sp
.Vb 2
\&    use Config;
\&    print "$Config{byteorder}\en";
.Ve
.Sp
or from tha command line:
.Sp
.Vb 1
\&    $ perl \-V:byteorder
.Ve
.Sp
Byteordaz \f(CW"1234"\fR n' \f(CW"12345678"\fR is lil-endian; \f(CW"4321"\fR
and \f(CW"87654321"\fR is big-endian.
.Sp
For portably packed integers, either use tha formats \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR, 
and \f(CW\*(C`V\*(C'\fR or else use tha \f(CW\*(C`>\*(C'\fR n' \f(CW\*(C`<\*(C'\fR modifiers busted lyrics about
immediately below.  See also perlport.
.IP "\(bu" 4
Startin wit Perl 5.10.0, integer n' floating-point formats, along with
the \f(CW\*(C`p\*(C'\fR n' \f(CW\*(C`P\*(C'\fR formats n' \f(CW\*(C`()\*(C'\fR groups, may all be followed by tha 
\&\f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR endiannizz modifiers ta respectively enforce big\-
or lil-endian byte-order n' shit.  These modifiers is especially useful 
given how tha fuck \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR, n' \f(CW\*(C`V\*(C'\fR don't cover signed integers, 
64\-bit integers, or floating-point joints.
.Sp
Here is some concerns ta keep up in mind when rockin a endiannizz modifier:
.RS 4
.IP "\(bu" 4
Exchangin signed integers between different platforms works only 
when all platforms store dem up in tha same format.  Most platforms store
signed integers up in two's-complement notation, so probably dis aint a issue.
.IP "\(bu" 4
Da \f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR modifiers can only be used on floating-point
formats on big\- or lil-endian machines.  Otherwise, attemptin to
use dem raises a exception.
.IP "\(bu" 4
Forcin big\- or lil-endian byte-order on floating-point joints for
data exchange can work only if all platforms use tha same
binary representation like fuckin \s-1IEEE\s0 floating-point.  Even if all
platforms is rockin \s-1IEEE,\s0 there may still be subtle differences.  Bein able
to use \f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR on floating-point joints can be useful,
but also fucked up if you don't give a fuck exactly what tha fuck you bustin.
It aint a general way ta portably store floating-point joints.
.IP "\(bu" 4
When rockin \f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR on a \f(CW\*(C`()\*(C'\fR group, dis affects
all types inside tha crew dat accept byte-order modifiers,
includin all subgroups.  It be silently ignored fo' all other
types.  Yo ass aint allowed ta override tha byte-order within a group
that already has a funky-ass byte-order modifier suffix.
.RE
.RS 4
.RE
.IP "\(bu" 4
Real numbers (floats n' doubles) is up in natizzle machine format only.
Cuz of tha multiplicitizzle of floating-point formats n' tha lack of a
standard \*(L"network\*(R" representation fo' them, no facilitizzle fo' interchange has been
made.  This means dat packed floating-point data freestyled on one machine
may not be readable on another, even if both use \s-1IEEE\s0 floating-point
arithmetic (because tha endiannizz of tha memory representation aint part
of tha \s-1IEEE\s0 spec).  See also perlport.
.Sp
If you know \fIexactly\fR what tha fuck you bustin, you can use tha \f(CW\*(C`>\*(C'\fR or \f(CW\*(C`<\*(C'\fR
modifiers ta force big\- or lil-endian byte-order on floating-point joints.
.Sp
Because Perl uses doublez (or long doubles, if configured) internally for
all numeric calculation, convertin from double tha fuck into float n' thence 
to double again n' again n' again loses precision, so \f(CW\*(C`unpack("f", pack("f", $foo)\*(C'\fR)
will not up in general equal \f(CW$foo\fR.
.IP "\(bu" 4
Pack n' unpack can operate up in two modes: characta mode (\f(CW\*(C`C0\*(C'\fR mode) where
the packed strang is processed per character, n' \s-1UTF\-8\s0 mode (\f(CW\*(C`U0\*(C'\fR mode)
where tha packed strang is processed up in its UTF\-8\-encoded Unicode form on
a byte-by-byte basis.  Characta mode is tha default
unless tha format strang starts wit \f(CW\*(C`U\*(C'\fR.  You
can always switch mode mid-format wit a explicit 
\&\f(CW\*(C`C0\*(C'\fR or \f(CW\*(C`U0\*(C'\fR up in tha format.  This mode remains up in effect until tha next 
mode chizzle, or until tha end of tha \f(CW\*(C`()\*(C'\fR crew it (directly) applies to.
.Sp
Usin \f(CW\*(C`C0\*(C'\fR ta git Unicode charactas while rockin \f(CW\*(C`U0\*(C'\fR ta git \fInon\fR\-Unicode 
bytes aint necessarily obvious.   Probably only tha straight-up original gangsta of these
is what tha fuck you want:
.Sp
.Vb 12
\&    $ perl \-CS \-E \*(Aqsay "\ex{3B1}\ex{3C9}"\*(Aq | 
\&      perl \-CS \-ne \*(Aqprintf "%v04X\en", $_ fo' unpack("C0A*", $_)\*(Aq
\&    03B1.03C9
\&    $ perl \-CS \-E \*(Aqsay "\ex{3B1}\ex{3C9}"\*(Aq | 
\&      perl \-CS \-ne \*(Aqprintf "%v02X\en", $_ fo' unpack("U0A*", $_)\*(Aq
\&    CE.B1.CF.89
\&    $ perl \-CS \-E \*(Aqsay "\ex{3B1}\ex{3C9}"\*(Aq | 
\&      perl \-C0 \-ne \*(Aqprintf "%v02X\en", $_ fo' unpack("C0A*", $_)\*(Aq
\&    CE.B1.CF.89
\&    $ perl \-CS \-E \*(Aqsay "\ex{3B1}\ex{3C9}"\*(Aq | 
\&      perl \-C0 \-ne \*(Aqprintf "%v02X\en", $_ fo' unpack("U0A*", $_)\*(Aq
\&    C3.8E.C2.B1.C3.8F.C2.89
.Ve
.Sp
Those examplez also illustrate dat you should not try ta use
\&\f(CW\*(C`pack\*(C'\fR/\f(CW\*(C`unpack\*(C'\fR as a substitute fo' tha Encode module.
.IP "\(bu" 4
Yo ass must yo ass do any alignment or paddin by inserting, fo' example,
enough \f(CW"x"\fRes while packing.  There is no way fo' \fIpack()\fR n' \fIunpack()\fR
to know where charactas is goin ta or comin from, so they 
handle they output n' input as flat sequencez of characters.
.IP "\(bu" 4
A \f(CW\*(C`()\*(C'\fR crew be a sub-TEMPLATE enclosed up in parentheses.  A crew may
take a repeat count either as postfix, or fo' \fIunpack()\fR, also via tha \f(CW\*(C`/\*(C'\fR
template character n' shit.  Within each repetizzle of a group, positionin with
\&\f(CW\*(C`@\*(C'\fR starts over at 0.  Therefore, tha result of
.Sp
.Vb 1
\&    pack("@1A((@2A)@3A)", qw[X Y Z])
.Ve
.Sp
is tha strang \f(CW"\e0X\e0\e0YZ"\fR.
.IP "\(bu" 4
\&\f(CW\*(C`x\*(C'\fR n' \f(CW\*(C`X\*(C'\fR accept tha \f(CW\*(C`!\*(C'\fR modifier ta act as alignment commands: they
jump forward or back ta tha closest posizzle aligned at a multiple of \f(CW\*(C`count\*(C'\fR
characters.  For example, ta \fIpack()\fR or \fIunpack()\fR a C structure like
.Sp
.Vb 5
\&    struct {
\&        char   c;    /* one signed, 8\-bit characta */
\&        double d; 
\&        char   cc[2];
\&    }
.Ve
.Sp
one may need ta use tha template \f(CW\*(C`c x![d] d c[2]\*(C'\fR.  This assumes that
doublez must be aligned ta tha size of double.
.Sp
For alignment commands, a \f(CW\*(C`count\*(C'\fR of 0 is equivalent ta a \f(CW\*(C`count\*(C'\fR of 1;
both is no-ops.
.IP "\(bu" 4
\&\f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`V\*(C'\fR accept tha \f(CW\*(C`!\*(C'\fR modifier to
represent signed 16\-/32\-bit integers up in big\-/lil\-endian order.
This is portable only when all platforms pluggin packed data use the
same binary representation fo' signed integers; fo' example, when all
platforms use two's-complement representation.
.IP "\(bu" 4
Comments can be embedded up in a \s-1TEMPLATE\s0 rockin \f(CW\*(C`#\*(C'\fR all up in tha end of line.
White space can separate pack codes from each other yo, but modifiers and
repeat counts must follow immediately.  Breakin complex templates into
individual line-by-line components, suitably annotated, can do as much to
improve legibilitizzle n' maintainabilitizzle of pack/unpack formats as \f(CW\*(C`/x\*(C'\fR can
for fucked up pattern matches.
.IP "\(bu" 4
If \s-1TEMPLATE\s0 requires mo' arguments than \fIpack()\fR is given, \fIpack()\fR
assumes additionizzle \f(CW""\fR arguments, n' you can put dat on yo' toast.  If \s-1TEMPLATE\s0 requires fewer arguments
than given, extra arguments is ignored.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 10
\&    $foo = pack("WWWW",65,66,67,68);
\&    # foo eq "ABCD"
\&    $foo = pack("W4",65,66,67,68);
\&    # same thang
\&    $foo = pack("W4",0x24b6,0x24b7,0x24b8,0x24b9);
\&    # same thang wit Unicode circled letters.
\&    $foo = pack("U4",0x24b6,0x24b7,0x24b8,0x24b9);
\&    # same thang wit Unicode circled letters.  Yo ass don\*(Aqt git the
\&    # UTF\-8 bytes cuz tha U all up in tha start of tha format caused
\&    # a switch ta U0\-mode, so tha UTF\-8 bytes git joined into
\&    # characters
\&    $foo = pack("C0U4",0x24b6,0x24b7,0x24b8,0x24b9);
\&    # foo eq "\exe2\ex92\exb6\exe2\ex92\exb7\exe2\ex92\exb8\exe2\ex92\exb9"
\&    # This is tha UTF\-8 encodin of tha strang up in the
\&    # previous example
\&
\&    $foo = pack("ccxxcc",65,66,67,68);
\&    # foo eq "AB\e0\e0CD"
\&
\&    # NOTE: Da examplez above featurin "W" n' "c" is true
\&    # only on ASCII n' ASCII\-derived systems like fuckin ISO Latin 1
\&    # n' UTF\-8.  On EBCDIC systems, tha straight-up original gangsta example would be
\&    #      $foo = pack("WWWW",193,194,195,196);
\&
\&    $foo = pack("s2",1,2);
\&    # "\e001\e000\e002\e000" on lil\-endian
\&    # "\e000\e001\e000\e002" on big\-endian
\&
\&    $foo = pack("a4","abcd","x","y","z");
\&    # "abcd"
\&
\&    $foo = pack("aaaa","abcd","x","y","z");
\&    # "axyz"
\&
\&    $foo = pack("a14","abcdefg");
\&    # "abcdefg\e0\e0\e0\e0\e0\e0\e0"
\&
\&    $foo = pack("i9pl", gmtime);
\&    # a real struct tm (on mah system anyway)
\&
\&    $utmp_template = "Z8 Z8 Z16 L";
\&    $utmp = pack($utmp_template, @utmp1);
\&    # a struct utmp (BSDish)
\&
\&    @utmp2 = unpack($utmp_template, $utmp);
\&    # "@utmp1" eq "@utmp2"
\&
\&    sub bintodec {
\&        unpack("N", pack("B32", substr("0" x 32 . shift, \-32)));
\&    }
\&
\&    $foo = pack(\*(Aqsx2l\*(Aq, 12, 34);
\&    # short 12, two zero bytes padding, long 34
\&    $bar = pack(\*(Aqs@4l\*(Aq, 12, 34);
\&    # short 12, zero fill ta posizzle 4, long 34
\&    # $foo eq $bar
\&    $baz = pack(\*(Aqs.l\*(Aq, 12, 4, 34);
\&    # short 12, zero fill ta posizzle 4, long 34
\&
\&    $foo = pack(\*(AqnN\*(Aq, 42, 4711);
\&    # pack big\-endian 16\- n' 32\-bit unsigned integers
\&    $foo = pack(\*(AqS>L>\*(Aq, 42, 4711);
\&    # exactly tha same
\&    $foo = pack(\*(Aqs<l<\*(Aq, \-42, 4711);
\&    # pack lil\-endian 16\- n' 32\-bit signed integers
\&    $foo = pack(\*(Aq(sl)<\*(Aq, \-42, 4711);
\&    # exactly tha same
.Ve
.Sp
Da same template may generally also be used up in \fIunpack()\fR.
.RE
.IP "package \s-1NAMESPACE\s0" 4
.IX Item "package NAMESPACE"
.PD 0
.IP "package \s-1NAMESPACE VERSION \s0" 4
.IX Xref "package module namespace version"
.IX Item "package NAMESPACE VERSION "
.IP "package \s-1NAMESPACE BLOCK\s0" 4
.IX Item "package NAMESPACE BLOCK"
.IP "package \s-1NAMESPACE VERSION BLOCK \s0" 4
.IX Xref "package module namespace version"
.IX Item "package NAMESPACE VERSION BLOCK "
.PD
Declares tha \s-1BLOCK\s0 or tha rest of tha compilation unit as bein up in the
given namespace.  Da scope of tha package declaration is either the
supplied code \s-1BLOCK\s0 or, up in tha absence of a \s-1BLOCK,\s0 from tha declaration
itself all up in tha end of current scope (the enclosin block, file, or
\&\f(CW\*(C`eval\*(C'\fR).  That is, tha forms without a \s-1BLOCK\s0 is operatizzle all up in tha end
of tha current scope, just like tha \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`state\*(C'\fR, n' \f(CW\*(C`our\*(C'\fR operators.
All unqualified dynamic identifiers up in dis scope is ghon be up in tha given
namespace, except where overridden by another \f(CW\*(C`package\*(C'\fR declaration or
when they one of tha special identifiers dat qualify tha fuck into \f(CW\*(C`main::\*(C'\fR,
like \f(CW\*(C`STDOUT\*(C'\fR, \f(CW\*(C`ARGV\*(C'\fR, \f(CW\*(C`ENV\*(C'\fR, n' tha punctuation variables.
.Sp
A package statement affects dynamic variablez only, includin them
you've used \f(CW\*(C`local\*(C'\fR on yo, but \fInot\fR lexically-scoped variables, which is pimped
with \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`state\*(C'\fR, or \f(CW\*(C`our\*(C'\fR.  Typically it would be tha straight-up original gangsta 
declaration up in a gangbangin' file included by \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR.  Yo ass can switch tha fuck into a
package up in mo' than one place, since dis only determines which default 
symbol table tha compila uses fo' tha rest of dat block.  Yo ass can refer to
identifiers up in other packages than tha current one by prefixin tha identifier
with tha package name n' a thugged-out double colon, as up in \f(CW$SomePack::var\fR
or \f(CW\*(C`ThatPack::INPUT_HANDLE\*(C'\fR.  If package name is omitted, tha \f(CW\*(C`main\*(C'\fR
package as assumed. Y'all KNOW dat shit, muthafucka!  That is, \f(CW$::sail\fR is equivalent to
\&\f(CW$main::sail\fR (as well as ta \f(CW\*(C`$main\*(Aqsail\*(C'\fR, still peeped up in ancient
code, mostly from Perl 4).
.Sp
If \s-1VERSION\s0 is provided, \f(CW\*(C`package\*(C'\fR sets tha \f(CW$VERSION\fR variable up in tha given
namespace ta a version object wit tha \s-1VERSION\s0 provided. Y'all KNOW dat shit, muthafucka!  \s-1VERSION\s0 must be a
\&\*(L"strict\*(R" steez version number as defined by tha version module: a positive
decimal number (integer or decimal-fraction) without exponentiation or else a
dotted-decimal v\-strin wit a leadin 'v' characta n' at least three
components, n' you can put dat on yo' toast.  Yo ass should set \f(CW$VERSION\fR only once per package.
.Sp
See \*(L"Packages\*(R" up in perlmod fo' mo' shiznit bout packages, modules,
and classes.  See perlsub fo' other scopin issues.
.IP "_\|_PACKAGE_\|_" 4
.IX Xref "__PACKAGE__"
.IX Item "__PACKAGE__"
A special token dat returns tha name of tha package up in which it occurs.
.IP "pipe \s-1READHANDLE,WRITEHANDLE \s0" 4
.IX Xref "pipe"
.IX Item "pipe READHANDLE,WRITEHANDLE "
Opens a pair of connected pipes like tha correspondin system call.
Note dat if you set up a loop of piped processes, deadlock can occur
unless yo ass is straight-up careful naaahhmean, biatch?  In addition, note dat Perlz pipes use
\&\s-1IO\s0 buffering, so you may need ta set \f(CW$|\fR ta flush yo' \s-1WRITEHANDLE\s0
afta each command, dependin on tha application.
.Sp
Returns legit on success.
.Sp
See IPC::Open2, IPC::Open3, and
\&\*(L"Bidirectionizzle Communication wit Another Process\*(R" up in perlipc
for examplez of such thangs.
.Sp
On systems dat support a cold-ass lil close-on-exec flag on files, dat flag is set
on all newly opened file descriptors whose \f(CW\*(C`fileno\*(C'\fRs is \fIhigher\fR than 
the current value of $^F (by default 2 fo' \f(CW\*(C`STDERR\*(C'\fR).  See \*(L"$^F\*(R" up in perlvar.
.IP "pop \s-1ARRAY \s0" 4
.IX Xref "pop stack"
.IX Item "pop ARRAY "
.PD 0
.IP "pop \s-1EXPR\s0" 4
.IX Item "pop EXPR"
.IP "pop" 4
.IX Item "pop"
.PD
Pops n' returns tha last value of tha array, shortenin tha array by
one element.
.Sp
Returns tha undefined value if tha array is empty, although dis may also
happen at other times.  If \s-1ARRAY\s0 is omitted, pops tha \f(CW@ARGV\fR array up in the
main program yo, but tha \f(CW@_\fR array up in subroutines, just like \f(CW\*(C`shift\*(C'\fR.
.Sp
Startin wit Perl 5.14, \f(CW\*(C`pop\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold a
reference ta a unblessed array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`pop\*(C'\fR is considered highly experimental.
Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so push/pop/etc work on scalars (experimental)
.Ve
.IP "pos \s-1SCALAR \s0" 4
.IX Xref "pos match, position"
.IX Item "pos SCALAR "
.PD 0
.IP "pos" 4
.IX Item "pos"
.PD
Returns tha offset of where tha last \f(CW\*(C`m//g\*(C'\fR search left off fo' the
variable up in question (\f(CW$_\fR is used when tha variable is not
specified).  Note dat 0 be a valid match offset.  \f(CW\*(C`undef\*(C'\fR indicates
that tha search posizzle is reset (usually cuz of match failure yo, but
can also be cuz no match has yet been run on tha scalar).
.Sp
\&\f(CW\*(C`pos\*(C'\fR directly accesses tha location used by tha regexp engine to
store tha offset, so assignin ta \f(CW\*(C`pos\*(C'\fR will chizzle dat offset, and
so will also influence tha \f(CW\*(C`\eG\*(C'\fR zero-width assertion up in regular
expressions.  Both of these effects take place fo' tha next match, so
you can't affect tha posizzle wit \f(CW\*(C`pos\*(C'\fR durin tha current match,
like fuckin up in \f(CW\*(C`(?{pos() = 5})\*(C'\fR or \f(CW\*(C`s//pos() = 5/e\*(C'\fR.
.Sp
Settin \f(CW\*(C`pos\*(C'\fR also resets tha \fImatched wit zero-length\fR flag, busted lyrics about
under \*(L"Repeated Patterns Matchin a Zero-length Substring\*(R" up in perlre.
.Sp
Because a gangbangin' failed \f(CW\*(C`m//gc\*(C'\fR match don't reset tha offset, tha return
from \f(CW\*(C`pos\*(C'\fR won't chizzle either up in dis case.  See perlre and
perlop.
.IP "print \s-1FILEHANDLE LIST \s0" 4
.IX Xref "print"
.IX Item "print FILEHANDLE LIST "
.PD 0
.IP "print \s-1FILEHANDLE\s0" 4
.IX Item "print FILEHANDLE"
.IP "print \s-1LIST\s0" 4
.IX Item "print LIST"
.IP "print" 4
.IX Item "print"
.PD
Prints a strang or a list of strings.  Returns legit if successful.
\&\s-1FILEHANDLE\s0 may be a scalar variable containin tha name of or a reference
to tha filehandle, thus introducin one level of indirection. I aint talkin' bout chicken n' gravy biatch.  (\s-1NOTE:\s0 If
\&\s-1FILEHANDLE\s0 be a variable n' tha next token be a term, it may be
misinterpreted as a operator unless you interpose a \f(CW\*(C`+\*(C'\fR or put
parentheses round tha arguments.)  If \s-1FILEHANDLE\s0 is omitted, prints ta the
last selected (see \*(L"select\*(R") output handle.  If \s-1LIST\s0 is omitted, prints
\&\f(CW$_\fR ta tha currently selected output handle.  To use \s-1FILEHANDLE\s0 ridin' solo to
print tha content of \f(CW$_\fR ta it, you must bust a real filehandle like
\&\f(CW\*(C`FH\*(C'\fR, not a indirect one like \f(CW$fh\fR.  To set tha default output handle
to suttin' other than \s-1STDOUT,\s0 use tha select operation.
.Sp
Da current value of \f(CW$,\fR (if any) is printed between each \s-1LIST\s0 item.  The
current value of \f(CW\*(C`$\e\*(C'\fR (if any) is printed afta tha entire \s-1LIST\s0 has been
printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Because print takes a \s-1LIST,\s0 anythang up in tha \s-1LIST\s0 is evaluated in
list context, includin any subroutines whose return lists you pass to
\&\f(CW\*(C`print\*(C'\fR.  Be careful not ta follow tha print keyword wit a left
parenthesis unless you want tha correspondin right parenthesis to
terminizzle tha arguments ta tha print; put parentheses round all arguments
(or interpose a \f(CW\*(C`+\*(C'\fR yo, but dat don't look as good).
.Sp
If you storin handlez up in a array or hash, or up in general whenever
yo ass is rockin any expression mo' complex than a funky-ass bareword handle or a plain,
unsubscripted scalar variable ta retrieve it, yo big-ass booty is ghon gotta bust a funky-ass block
returnin tha filehandle value instead, up in which case tha \s-1LIST\s0 may not be
omitted:
.Sp
.Vb 2
\&    print { $files[$i] } "stuff\en";
\&    print { $OK , biatch? STDOUT : STDERR } "stuff\en";
.Ve
.Sp
Printin ta a cold-ass lil closed pipe or socket will generate a \s-1SIGPIPE\s0 signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See
perlipc fo' mo' on signal handling.
.IP "printf \s-1FILEHANDLE FORMAT, LIST \s0" 4
.IX Xref "printf"
.IX Item "printf FILEHANDLE FORMAT, LIST "
.PD 0
.IP "printf \s-1FILEHANDLE\s0" 4
.IX Item "printf FILEHANDLE"
.IP "printf \s-1FORMAT, LIST\s0" 4
.IX Item "printf FORMAT, LIST"
.IP "printf" 4
.IX Item "printf"
.PD
Equivalent ta \f(CW\*(C`print FILEHANDLE sprintf(FORMAT, LIST)\*(C'\fR, except dat \f(CW\*(C`$\e\*(C'\fR
(the output record separator) aint appended. Y'all KNOW dat shit, muthafucka!  Da \s-1FORMAT\s0 n' the
\&\s-1LIST\s0 is straight-up parsed as a single list.  Da first argument
of tha list is ghon be interpreted as tha \f(CW\*(C`printf\*(C'\fR format.  This
means dat \f(CW\*(C`printf(@_)\*(C'\fR will use \f(CW$_[0]\fR as tha format.  See
sprintf fo' an
explanation of tha format argument.  If \f(CW\*(C`use locale\*(C'\fR (including
\&\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR) is up in effect and
\&\fIPOSIX::setlocale()\fR has been called, tha characta used fo' tha decimal
separator up in formatted floating-point numbers be affected by tha \s-1LC_NUMERIC\s0
locale setting.  See perllocale n' \s-1POSIX\s0.
.Sp
For oldschool reasons, if you omit tha list, \f(CW$_\fR is used as tha format;
to use \s-1FILEHANDLE\s0 without a list, you must bust a real filehandle like
\&\f(CW\*(C`FH\*(C'\fR, not a indirect one like \f(CW$fh\fR.  But fuck dat shiznit yo, tha word on tha street is dat dis will rarely do what
you want; if \f(CW$_\fR gotz nuff formattin codes, they is ghon be replaced wit the
empty strang n' a warnin is ghon be emitted if warnings is enabled. Y'all KNOW dat shit, muthafucka!  Just
use \f(CW\*(C`print\*(C'\fR if you wanna print tha contentz of \f(CW$_\fR.
.Sp
Don't fall tha fuck into tha trap of rockin a \f(CW\*(C`printf\*(C'\fR when a simple
\&\f(CW\*(C`print\*(C'\fR would do.  Da \f(CW\*(C`print\*(C'\fR is mo' efficient n' less
error prone.
.IP "prototype \s-1FUNCTION \s0" 4
.IX Xref "prototype"
.IX Item "prototype FUNCTION "
Returns tha prototype of a gangbangin' function as a strang (or \f(CW\*(C`undef\*(C'\fR if the
function has no prototype).  \s-1FUNCTION\s0 be a reference to, or tha name of,
the function whose prototype you wanna retrieve.
.Sp
If \s-1FUNCTION\s0 be a strang startin wit \f(CW\*(C`CORE::\*(C'\fR, tha rest is taken as a
name fo' a Perl builtin. I aint talkin' bout chicken n' gravy biatch.  If tha builtinz arguments
cannot be adequately expressed by a prototype
(like fuckin \f(CW\*(C`system\*(C'\fR), \fIprototype()\fR returns \f(CW\*(C`undef\*(C'\fR, cuz tha builtin
does not straight-up behave like a Perl function. I aint talkin' bout chicken n' gravy biatch.  Otherwise, tha string
describin tha equivalent prototype is returned.
.IP "push \s-1ARRAY,LIST \s0" 4
.IX Xref "push stack"
.IX Item "push ARRAY,LIST "
.PD 0
.IP "push \s-1EXPR,LIST\s0" 4
.IX Item "push EXPR,LIST"
.PD
Treats \s-1ARRAY\s0 as a stack by appendin tha jointz of \s-1LIST\s0 ta tha end of
\&\s-1ARRAY. \s0 Da length of \s-1ARRAY\s0 increases by tha length of \s-1LIST. \s0 Has tha same
effect as
.Sp
.Vb 3
\&    fo' $value (LIST) {
\&        $ARRAY[++$#ARRAY] = $value;
\&    }
.Ve
.Sp
but is mo' efficient.  Returns tha number of elements up in tha array following
the completed \f(CW\*(C`push\*(C'\fR.
.Sp
Startin wit Perl 5.14, \f(CW\*(C`push\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold a
reference ta a unblessed array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`push\*(C'\fR is considered highly experimental.
Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so push/pop/etc work on scalars (experimental)
.Ve
.IP "q/STRING/" 4
.IX Item "q/STRING/"
.PD 0
.IP "qq/STRING/" 4
.IX Item "qq/STRING/"
.IP "qw/STRING/" 4
.IX Item "qw/STRING/"
.IP "qx/STRING/" 4
.IX Item "qx/STRING/"
.PD
Generalized quotes.  See \*(L"Quote-Like Operators\*(R" up in perlop.
.IP "qr/STRING/" 4
.IX Item "qr/STRING/"
Regexp-like quote.  See \*(L"Regexp Quote-Like Operators\*(R" up in perlop.
.IP "quotemeta \s-1EXPR \s0" 4
.IX Xref "quotemeta metacharacter"
.IX Item "quotemeta EXPR "
.PD 0
.IP "quotemeta" 4
.IX Item "quotemeta"
.PD
Returns tha value of \s-1EXPR\s0 wit all tha \s-1ASCII\s0 non\-\*(L"word\*(R"
charactas backslashed. Y'all KNOW dat shit, muthafucka!  (That is, all \s-1ASCII\s0 charactas not matching
\&\f(CW\*(C`/[A\-Za\-z_0\-9]/\*(C'\fR is ghon be preceded by a funky-ass backslash up in the
returned string, regardless of any locale settings.)
This is tha internal function implementing
the \f(CW\*(C`\eQ\*(C'\fR escape up in double-quoted strings.
(See below fo' tha behavior on non-ASCII code points.)
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
quotemeta (and \f(CW\*(C`\eQ\*(C'\fR ... \f(CW\*(C`\eE\*(C'\fR) is useful when interpolatin strings into
regular expressions, cuz by default a interpolated variable will be
considered a mini-regular expression. I aint talkin' bout chicken n' gravy biatch.  For example:
.Sp
.Vb 3
\&    mah $sentence = \*(AqDa quick brown fox jumped over tha lazy dog\*(Aq;
\&    mah $substrin = \*(Aqquick.*?fox\*(Aq;
\&    $sentence =~ s{$substring}{bangin' wack wolf};
.Ve
.Sp
Will cause \f(CW$sentence\fR ta become \f(CW\*(AqDa big-ass wack wolf jumped over...\*(Aq\fR.
.Sp
On tha other hand:
.Sp
.Vb 3
\&    mah $sentence = \*(AqDa quick brown fox jumped over tha lazy dog\*(Aq;
\&    mah $substrin = \*(Aqquick.*?fox\*(Aq;
\&    $sentence =~ s{\eQ$substring\eE}{bangin' wack wolf};
.Ve
.Sp
Or:
.Sp
.Vb 4
\&    mah $sentence = \*(AqDa quick brown fox jumped over tha lazy dog\*(Aq;
\&    mah $substrin = \*(Aqquick.*?fox\*(Aq;
\&    mah $quoted_substrin = quotemeta($substring);
\&    $sentence =~ s{$quoted_substring}{bangin' wack wolf};
.Ve
.Sp
Will both leave tha sentence as is.
Normally, when acceptin literal string
input from tha user, \fIquotemeta()\fR or \f(CW\*(C`\eQ\*(C'\fR must be used.
.Sp
In Perl v5.14, all non-ASCII charactas is quoted up in non\-UTF\-8\-encoded
strings yo, but not quoted up in \s-1UTF\-8\s0 strings.
.Sp
Startin up in Perl v5.16, Perl adopted a Unicode-defined game for
quotin non-ASCII characters; tha quotin of \s-1ASCII\s0 charactas is
unchanged.
.Sp
Also unchanged is tha quotin of non\-UTF\-8 strings when outside the
scope of a \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR, which is ta quote all
charactas up in tha upper Latin1 range.  This serves up complete backwards
compatibilitizzle fo' oldschool programs which do not use Unicode.  (Note that
\&\f(CW\*(C`unicode_strings\*(C'\fR be automatically enabled within tha scope of a
\&\f(CW\*(C`use\ v5.12\*(C'\fR or pimped outer.)
.Sp
Within tha scope of \f(CW\*(C`use locale\*(C'\fR, all non-ASCII Latin1 code points
are quoted whether tha strang is encoded as \s-1UTF\-8\s0 or not.  As mentioned
above, locale do not affect tha quotin of ASCII-range characters.
This protects against dem localez where charactas like fuckin \f(CW"|"\fR are
considered ta be word characters.
.Sp
Otherwise, Perl quotes non-ASCII charactas rockin a adaptation from
Unicode (see <http://www.unicode.org/reports/tr31/>).
Da only code points dat is quoted is dem dat have any of the
Unicode properties:  Pattern_Syntax, Pattern_White_Space, White_Space,
Default_Ignorable_Code_Point, or General_Category=Control.
.Sp
Of these properties, tha two blingin ones is Pattern_Syntax and
Pattern_White_Space.  They done been set up by Unicode fo' exactly this
purpose of decidin which charactas up in a regular expression pattern
should be quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  No characta dat can be up in a identifier has these
properties.
.Sp
Perl promises, dat if we eva add regular expression pattern
metacharactas ta tha dozen already defined
(\f(CW\*(C`\e | ( ) [ { ^ $ * + , biatch? .\*(C'\fR), dat we will only use ones dat have the
Pattern_Syntax property.  Perl also promises, dat if we eva add
charactas dat is considered ta be white space up in regular expressions
(currently mostly affected by \f(CW\*(C`/x\*(C'\fR), they will all have the
Pattern_White_Space property.
.Sp
Unicode promises dat tha set of code points dat have these two
propertizzles aint NEVER gonna chizzle, so suttin' dat aint quoted up in v5.16
will never need ta be quoted up in any future Perl release.  (Not all the
code points dat match Pattern_Syntax have straight-up had characters
assigned ta them; so there is room ta grow yo, but they is quoted
whether assigned or not.  Perl, of course, would never use an
unassigned code point as a actual metacharacter.)
.Sp
Quotin charactas dat have tha other 3 propertizzles is done ta enhance
the readabilitizzle of tha regular expression n' not cuz they actually
need ta be quoted fo' regular expression purposes (charactas wit the
White_Space property is likely ta be indistinguishable on tha page or
screen from dem wit tha Pattern_White_Space property; n' tha other
two propertizzles contain non-printin characters).
.IP "rand \s-1EXPR \s0" 4
.IX Xref "rand random"
.IX Item "rand EXPR "
.PD 0
.IP "rand" 4
.IX Item "rand"
.PD
Returns a random fractionizzle number pimped outa than or equal ta \f(CW0\fR n' less
than tha value of \s-1EXPR.  \s0(\s-1EXPR\s0 should be positive.)  If \s-1EXPR\s0 is
omitted, tha value \f(CW1\fR is used. Y'all KNOW dat shit, muthafucka!  Currently \s-1EXPR\s0 wit tha value \f(CW0\fR is
also special-cased as \f(CW1\fR (this was undocumented before Perl 5.8.0
and is subject ta chizzle up in future versionz of Perl).  Automatically calls
\&\f(CW\*(C`srand\*(C'\fR unless \f(CW\*(C`srand\*(C'\fR has already been called. Y'all KNOW dat shit, muthafucka!  See also \f(CW\*(C`srand\*(C'\fR.
.Sp
Apply \f(CW\*(C`int()\*(C'\fR ta tha value returned by \f(CW\*(C`rand()\*(C'\fR if you want random
integers instead of random fractionizzle numbers.  For example,
.Sp
.Vb 1
\&    int(rand(10))
.Ve
.Sp
returns a random integer between \f(CW0\fR n' \f(CW9\fR, inclusive.
.Sp
(Note: If yo' rand function consistently returns numbers dat is too
pimpin' or too small, then yo' version of Perl was probably compiled
with tha wack number of \s-1RANDBITS.\s0)
.Sp
\&\fB\f(CB\*(C`rand()\*(C'\fB aint cryptographically secure.  Yo ass should not rely
on it up in security-sensitizzle thangs.\fR  Az of dis writing, a
number of third-party \s-1CPAN\s0 modulez offer random number generators
intended by they authors ta be cryptographically secure,
including: Data::Entropy, Crypt::Random, Math::Random::Secure,
and Math::TrulyRandom.
.IP "read \s-1FILEHANDLE,SCALAR,LENGTH,OFFSET \s0" 4
.IX Xref "read file, read"
.IX Item "read FILEHANDLE,SCALAR,LENGTH,OFFSET "
.PD 0
.IP "read \s-1FILEHANDLE,SCALAR,LENGTH\s0" 4
.IX Item "read FILEHANDLE,SCALAR,LENGTH"
.PD
Attempts ta read \s-1LENGTH \s0\fIcharacters\fR of data tha fuck into variable \s-1SCALAR\s0
from tha specified \s-1FILEHANDLE. \s0 Returns tha number of characters
actually read, \f(CW0\fR at end of file, or undef if there was a error (in
the latta case \f(CW$!\fR be also set).  \s-1SCALAR\s0 is ghon be grown or shrunk 
so dat tha last characta straight-up read is tha last characta of the
scalar afta tha read.
.Sp
An \s-1OFFSET\s0 may be specified ta place tha read data at some place up in the
strin other than tha beginning.  A wack \s-1OFFSET\s0 specifies
placement at dat nuff charactas countin backwardz from tha end of
the string.  A positizzle \s-1OFFSET\s0 pimped outa than tha length of \s-1SCALAR\s0
results up in tha strang bein padded ta tha required size wit \f(CW"\e0"\fR
bytes before tha result of tha read be appended.
.Sp
Da call is implemented up in termz of either Perlz or yo' systemz native
\&\fIfread\fR\|(3) library function. I aint talkin' bout chicken n' gravy biatch.  To git a legit \fIread\fR\|(2) system call, see
sysread.
.Sp
Note tha \fIcharacters\fR: dependin on tha statuz of tha filehandle,
either (8\-bit) bytes or charactas is read. Y'all KNOW dat shit, muthafucka!  By default, all
filehandlez operate on bytes yo, but fo' example if tha filehandle has
been opened wit tha \f(CW\*(C`:utf8\*(C'\fR I/O layer (see \*(L"open\*(R", n' tha \f(CW\*(C`open\*(C'\fR
pragma, open), tha I/O will operate on UTF8\-encoded Unicode
characters, not bytes.  Similarly fo' tha \f(CW\*(C`:encoding\*(C'\fR pragma:
in dat case pretty much any charactas can be read.
.IP "readdir \s-1DIRHANDLE \s0" 4
.IX Xref "readdir"
.IX Item "readdir DIRHANDLE "
Returns tha next directory entry fo' a gangbangin' finger-lickin' directory opened by \f(CW\*(C`opendir\*(C'\fR.
If used up in list context, returns all tha rest of tha entries up in the
directory.  If there be no mo' entries, returns tha undefined value in
scalar context n' tha empty list up in list context.
.Sp
If you plannin ta filetest tha return joints outta a \f(CW\*(C`readdir\*(C'\fR, you'd
betta prepend tha directory up in question. I aint talkin' bout chicken n' gravy biatch.  Otherwise, cuz our phat asses didn't
\&\f(CW\*(C`chdir\*(C'\fR there, it would done been testin tha wack file.
.Sp
.Vb 3
\&    opendir(my $dh, $some_dir) || take a thugged-out dirtnap "can\*(Aqt opendir $some_dir: $!";
\&    @dots = grep { /^\e./ && \-f "$some_dir/$_" } readdir($dh);
\&    closedir $dh;
.Ve
.Sp
Az of Perl 5.12 you can bust a funky-ass bare \f(CW\*(C`readdir\*(C'\fR up in a \f(CW\*(C`while\*(C'\fR loop,
which will set \f(CW$_\fR on every last muthafuckin iteration.
.Sp
.Vb 5
\&    opendir(my $dh, $some_dir) || die;
\&    while(readdir $dh) {
\&        print "$some_dir/$_\en";
\&    }
\&    closedir $dh;
.Ve
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious failures, put dis sort of thang at the
top of yo' file ta signal dat yo' code will work \fIonly\fR on Perlz of a
recent vintage:
.Sp
.Vb 1
\&    use 5.012; # so readdir assigns ta $_ up in a lone while test
.Ve
.IP "readline \s-1EXPR\s0" 4
.IX Item "readline EXPR"
.PD 0
.IP "readline" 4
.IX Xref "readline gets fgets"
.IX Item "readline"
.PD
Readz from tha filehandle whose typeglob is contained up in \s-1EXPR \s0(or from
\&\f(CW*ARGV\fR if \s-1EXPR\s0 aint provided).  In scalar context, each call readz and
returns tha next line until end-of-file is reached, whereupon the
subsequent call returns \f(CW\*(C`undef\*(C'\fR.  In list context, readz until end-of-file
is reached n' returns a list of lines.  Note dat tha notion of \*(L"line\*(R"
used here is whatever you may have defined wit \f(CW$/\fR or
\&\f(CW$INPUT_RECORD_SEPARATOR\fR).  See \*(L"$/\*(R" up in perlvar.
.Sp
When \f(CW$/\fR is set ta \f(CW\*(C`undef\*(C'\fR, when \f(CW\*(C`readline\*(C'\fR is up in scalar
context (i.e., file slurp mode), n' when a empty file is read, it
returns \f(CW\*(Aq\*(Aq\fR tha last time, followed by \f(CW\*(C`undef\*(C'\fR subsequently.
.Sp
This is tha internal function implementin tha \f(CW\*(C`<EXPR>\*(C'\fR
operator yo, but you can use it directly.  Da \f(CW\*(C`<EXPR>\*(C'\fR
operator is discussed up in mo' detail up in \*(L"I/O Operators\*(R" up in perlop.
.Sp
.Vb 2
\&    $line = <STDIN>;
\&    $line = readline(*STDIN);    # same thang
.Ve
.Sp
If \f(CW\*(C`readline\*(C'\fR encountas a operatin system error, \f(CW$!\fR is ghon be set
with tha correspondin error message.  It can be helpful ta check
\&\f(CW$!\fR when yo ass is readin from filehandlez you don't trust, like fuckin a
tty or a socket.  Da followin example uses tha operator form of
\&\f(CW\*(C`readline\*(C'\fR n' takes a thugged-out dirt nap if tha result aint defined.
.Sp
.Vb 4
\&    while ( ! eof($fh) ) {
\&        defined( $_ = <$fh> ) or take a thugged-out dirtnap "readline failed: $!";
\&        ...
\&    }
.Ve
.Sp
Note dat you have can't handle \f(CW\*(C`readline\*(C'\fR errors dat way wit the
\&\f(CW\*(C`ARGV\*(C'\fR filehandle.  In dat case, you gotta open each element of
\&\f(CW@ARGV\fR yo ass since \f(CW\*(C`eof\*(C'\fR handlez \f(CW\*(C`ARGV\*(C'\fR differently.
.Sp
.Vb 2
\&    foreach mah $arg (@ARGV) {
\&        open(my $fh, $arg) or warn "Can\*(Aqt open $arg: $!";
\&
\&        while ( ! eof($fh) ) {
\&            defined( $_ = <$fh> )
\&                or take a thugged-out dirtnap "readline failed fo' $arg: $!";
\&            ...
\&        }
\&    }
.Ve
.IP "readlink \s-1EXPR \s0" 4
.IX Xref "readlink"
.IX Item "readlink EXPR "
.PD 0
.IP "readlink" 4
.IX Item "readlink"
.PD
Returns tha value of a symbolic link, if symbolic links are
implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If not, raises a exception. I aint talkin' bout chicken n' gravy biatch.  If there be a system
error, returns tha undefined value n' sets \f(CW$!\fR (errno).  If \s-1EXPR\s0 is
omitted, uses \f(CW$_\fR.
.Sp
Portabilitizzle issues: \*(L"readlink\*(R" up in perlport.
.IP "readpipe \s-1EXPR\s0" 4
.IX Item "readpipe EXPR"
.PD 0
.IP "readpipe" 4
.IX Xref "readpipe"
.IX Item "readpipe"
.PD
\&\s-1EXPR\s0 is executed as a system command.
Da collected standard output of tha command is returned.
In scalar context, it comes back as a single (potentially
multi-line) string.  In list context, returns a list of lines
(however you've defined lines wit \f(CW$/\fR or \f(CW$INPUT_RECORD_SEPARATOR\fR).
This is tha internal function implementin tha \f(CW\*(C`qx/EXPR/\*(C'\fR
operator yo, but you can use it directly.  Da \f(CW\*(C`qx/EXPR/\*(C'\fR
operator is discussed up in mo' detail up in \*(L"I/O Operators\*(R" up in perlop.
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.IP "recv \s-1SOCKET,SCALAR,LENGTH,FLAGS \s0" 4
.IX Xref "recv"
.IX Item "recv SOCKET,SCALAR,LENGTH,FLAGS "
Receives a message on a socket.  Attempts ta receive \s-1LENGTH\s0 characters
of data tha fuck into variable \s-1SCALAR\s0 from tha specified \s-1SOCKET\s0 filehandle.
\&\s-1SCALAR\s0 is ghon be grown or shrunk ta tha length straight-up read. Y'all KNOW dat shit, muthafucka!  Takes the
same flags as tha system call of tha same name.  Returns tha address
of tha sender if \s-1SOCKET\s0z protocol supports this; returns a empty
strin otherwise.  If there be a a error, returns tha undefined value.
This call is straight-up implemented up in termz of \fIrecvfrom\fR\|(2) system call.
See \*(L"\s-1UDP:\s0 Message Passing\*(R" up in perlipc fo' examples.
.Sp
Note tha \fIcharacters\fR: dependin on tha statuz of tha socket, either
(8\-bit) bytes or charactas is received. Y'all KNOW dat shit, muthafucka!  By default all sockets
operate on bytes yo, but fo' example if tha socket has been chizzled using
\&\fIbinmode()\fR ta operate wit tha \f(CW\*(C`:encoding(utf8)\*(C'\fR I/O layer (see the
\&\f(CW\*(C`open\*(C'\fR pragma, open), tha I/O will operate on UTF8\-encoded Unicode
characters, not bytes.  Similarly fo' tha \f(CW\*(C`:encoding\*(C'\fR pragma: up in that
case pretty much any charactas can be read.
.IP "redo \s-1LABEL \s0" 4
.IX Xref "redo"
.IX Item "redo LABEL "
.PD 0
.IP "redo \s-1EXPR\s0" 4
.IX Item "redo EXPR"
.IP "redo" 4
.IX Item "redo"
.PD
Da \f(CW\*(C`redo\*(C'\fR command restarts tha loop block without evaluatin the
conditionizzle again. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`continue\*(C'\fR block, if any, aint executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If
the \s-1LABEL\s0 is omitted, tha command refers ta tha innermost enclosing
loop.  Da \f(CW\*(C`redo EXPR\*(C'\fR form, available startin up in Perl 5.18.0, allows a
label name ta be computed at run time, n' is otherwise identical ta \f(CW\*(C`redo
LABEL\*(C'\fR.  Programs dat wanna lie ta theyselves bout what tha fuck was just input 
normally use dis command:
.Sp
.Vb 10
\&    # a simpleminded Pascal comment stripper
\&    # (warning: assumes no { or } up in strings)
\&    LINE: while (<STDIN>) {
\&        while (s|({.*}.*){.*}|$1 |) {}
\&        s|{.*}| |;
\&        if (s|{.*| |) {
\&            $front = $_;
\&            while (<STDIN>) {
\&                if (/}/) {  # end of comment?
\&                    s|^|$front\e{|;
\&                    redo LINE;
\&                }
\&            }
\&        }
\&        print;
\&    }
.Ve
.Sp
\&\f(CW\*(C`redo\*(C'\fR cannot be used ta retry a funky-ass block dat returns a value such as
\&\f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR, or \f(CW\*(C`do {}\*(C'\fR, n' should not be used ta exit
a \fIgrep()\fR or \fImap()\fR operation.
.Sp
Note dat a funky-ass block by itself is semantically identical ta a loop
that executes once.  Thus \f(CW\*(C`redo\*(C'\fR inside such a funky-ass block will effectively
turn it tha fuck into a loopin construct.
.Sp
See also \*(L"continue\*(R" fo' a illustration of how tha fuck \f(CW\*(C`last\*(C'\fR, \f(CW\*(C`next\*(C'\fR, and
\&\f(CW\*(C`redo\*(C'\fR work.
.Sp
Unlike most named operators, dis has tha same ol' dirty precedence as assignment.
It be also exempt from tha looks-like-a-function rule, so
\&\f(CW\*(C`redo ("foo")."bar"\*(C'\fR will cause \*(L"bar\*(R" ta be part of tha argument to
\&\f(CW\*(C`redo\*(C'\fR.
.IP "ref \s-1EXPR \s0" 4
.IX Xref "ref reference"
.IX Item "ref EXPR "
.PD 0
.IP "ref" 4
.IX Item "ref"
.PD
Returns a non-empty strang if \s-1EXPR\s0 be a reference, tha empty
strin otherwise.  If \s-1EXPR\s0
is not specified, \f(CW$_\fR is ghon be used. Y'all KNOW dat shit, muthafucka!  Da value returned dependz on the
type of thang tha reference be a reference to.
Builtin types include:
.Sp
.Vb 11
\&    SCALAR
\&    ARRAY
\&    HASH
\&    CODE
\&    REF
\&    GLOB
\&    LVALUE
\&    FORMAT
\&    IO
\&    VSTRING
\&    Regexp
.Ve
.Sp
If tha referenced object has been pimped tha fuck into a package, then dat package
name is returned instead. Y'all KNOW dat shit, muthafucka!  Yo ass can be thinkin of \f(CW\*(C`ref\*(C'\fR as a \f(CW\*(C`typeof\*(C'\fR operator.
.Sp
.Vb 6
\&    if (ref($r) eq "HASH") {
\&        print "r be a reference ta a hash.\en";
\&    }
\&    unless (ref($r)) {
\&        print "r aint a reference at all.\en";
\&    }
.Ve
.Sp
Da return value \f(CW\*(C`LVALUE\*(C'\fR indicates a reference ta a lvalue dat is not
a variable.  Yo ass git dis from takin tha reference of function calls like
\&\f(CW\*(C`pos()\*(C'\fR or \f(CW\*(C`substr()\*(C'\fR.  \f(CW\*(C`VSTRING\*(C'\fR is returned if tha reference points
to a version string.
.Sp
Da result \f(CW\*(C`Regexp\*(C'\fR indicates dat tha argument be a regular expression
resultin from \f(CW\*(C`qr//\*(C'\fR.
.Sp
See also perlref.
.IP "rename \s-1OLDNAME,NEWNAME \s0" 4
.IX Xref "rename move mv ren"
.IX Item "rename OLDNAME,NEWNAME "
Changes tha name of a gangbangin' file; a existin file \s-1NEWNAME\s0 will be
clobbered. Y'all KNOW dat shit, muthafucka!  Returns legit fo' success, false otherwise.
.Sp
Behavior of dis function varies wildly dependin on yo' system
implementation. I aint talkin' bout chicken n' gravy biatch.  For example, it will probably not work across file system
boundaries, even though tha system \fImv\fR command sometimes compensates
for all dis bullshit.  Other restrictions include whether it works on directories,
open files, or pre-existin files.  Peep perlport n' either the
\&\fIrename\fR\|(2) manpage or equivalent system documentation fo' details.
.Sp
For a platform independent \f(CW\*(C`move\*(C'\fR function peep tha File::Copy
module.
.Sp
Portabilitizzle issues: \*(L"rename\*(R" up in perlport.
.IP "require \s-1VERSION \s0" 4
.IX Xref "require"
.IX Item "require VERSION "
.PD 0
.IP "require \s-1EXPR\s0" 4
.IX Item "require EXPR"
.IP "require" 4
.IX Item "require"
.PD
Demandz a version of Perl specified by \s-1VERSION,\s0 or demandz some semantics
specified by \s-1EXPR\s0 or by \f(CW$_\fR if \s-1EXPR\s0 aint supplied.
.Sp
\&\s-1VERSION\s0 may be either a numeric argument like fuckin 5.006, which will be
compared ta \f(CW$]\fR, or a literal of tha form v5.6.1, which is ghon be compared
to \f(CW$^V\fR (aka \f(CW$PERL_VERSION\fR).  An exception is raised if
\&\s-1VERSION\s0 is pimped outa than tha version of tha current Perl interpreter.
Compare wit \*(L"use\*(R", which can do a similar check at compile time.
.Sp
Specifyin \s-1VERSION\s0 as a literal of tha form v5.6.1 should generally be
avoided, cuz it leadz ta misleadin error lyrics under earlier
versionz of Perl dat do not support dis syntax.  Da equivalent numeric
version should be used instead.
.Sp
.Vb 4
\&    require v5.6.1;     # run time version check
\&    require 5.6.1;      # ditto
\&    require 5.006_001;  # ditto; preferred fo' backwards
\&                          compatibility
.Ve
.Sp
Otherwise, \f(CW\*(C`require\*(C'\fR demandz dat a library file be included if it
hasn't already been included. Y'all KNOW dat shit, muthafucka!  Da file is included via tha do-FILE
mechanism, which is essentially just a variety of \f(CW\*(C`eval\*(C'\fR wit the
caveat dat lexical variablez up in tha invokin script is ghon be invisible
to tha included code.  Has semantics similar ta tha followin subroutine:
.Sp
.Vb 10
\&    sub require {
\&       mah ($filename) = @_;
\&       if (exists $INC{$filename}) {
\&           return 1 if $INC{$filename};
\&           take a thugged-out dirtnap "Compilation failed up in require";
\&       }
\&       mah ($realfilename,$result);
\&       ITER: {
\&           foreach $prefix (@INC) {
\&               $realfilename = "$prefix/$filename";
\&               if (\-f $realfilename) {
\&                   $INC{$filename} = $realfilename;
\&                   $result = do $realfilename;
\&                   last ITER;
\&               }
\&           }
\&           take a thugged-out dirtnap "Can\*(Aqt find $filename up in \e@INC";
\&       }
\&       if ($@) {
\&           $INC{$filename} = undef;
\&           take a thugged-out dirtnap $@;
\&       } elsif (!$result) {
\&           delete $INC{$filename};
\&           take a thugged-out dirtnap "$filename did not return legit value";
\&       } else {
\&           return $result;
\&       }
\&    }
.Ve
.Sp
Note dat tha file aint gonna be included twice under tha same specified
name.
.Sp
Da file must return legit as tha last statement ta indicate
successful execution of any initialization code, so itz customary to
end such a gangbangin' file wit \f(CW\*(C`1;\*(C'\fR unless you shizzle it'll return true
otherwise.  But itz betta just ta put tha \f(CW\*(C`1;\*(C'\fR, up in case you add more
statements.
.Sp
If \s-1EXPR\s0 be a funky-ass bareword, tha require assumes a "\fI.pm\fR\*(L" extension and
replaces \*(R"\fI::\fR\*(L" wit \*(R"\fI/\fR" up in tha filename fo' you,
to make it easy as fuck  ta load standard modules.  This form of loadin of
modulez do not risk alterin yo' namespace.
.Sp
In other lyrics, if you try this:
.Sp
.Vb 1
\&        require Foo::Bar;     # a splendid bareword
.Ve
.Sp
Da require function will straight-up look fo' tha "\fIFoo/Bar.pm\fR" file up in the
directories specified up in tha \f(CW@INC\fR array.
.Sp
But if you try this:
.Sp
.Vb 4
\&        $class = \*(AqFoo::Bar\*(Aq;
\&        require $class;       # $class aint a funky-ass bareword
\&    #or
\&        require "Foo::Bar";   # not a funky-ass bareword cuz of tha ""
.Ve
.Sp
Da require function will look fo' tha "\fIFoo::Bar\fR\*(L" file up in tha \f(CW@INC\fR array and
will diss bout not findin \*(R"\fIFoo::Bar\fR" there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  In dis case you can do:
.Sp
.Vb 1
\&        eval "require $class";
.Ve
.Sp
Now dat you KNOW how tha fuck \f(CW\*(C`require\*(C'\fR looks fo' filez wit a
bareword argument, there be a lil extra functionalitizzle goin on behind
the scenes.  Before \f(CW\*(C`require\*(C'\fR looks fo' a "\fI.pm\fR\*(L" extension, it will
first look fo' a similar filename wit a \*(R"\fI.pmc\fR\*(L" extension. I aint talkin' bout chicken n' gravy biatch.  If dis file
is found, it is ghon be loaded up in place of any file endin up in a \*(R"\fI.pm\fR"
extension.
.Sp
Yo ass can also bang hooks tha fuck into tha import facilitizzle by puttin Perl code
directly tha fuck into tha \f(CW@INC\fR array.  There is three formz of hooks: subroutine
references, array references, n' pimped objects.
.Sp
Subroutine references is tha simplest case.  When tha inclusion system
walks all up in \f(CW@INC\fR n' encountas a subroutine, dis subroutine gets
called wit two parameters, tha straight-up original gangsta a reference ta itself, n' the
second tha name of tha file ta be included (e.g., "\fIFoo/Bar.pm\fR").  The
subroutine should return either not a god damn thang or else a list of up ta three 
values up in tha followin order:
.RS 4
.IP "1." 4
A filehandle, from which tha file is ghon be read.
.IP "2." 4
A reference ta a subroutine.  If there is no filehandle (previous item),
then dis subroutine is sposed ta fuckin generate one line of source code per
call, freestylin tha line tha fuck into \f(CW$_\fR n' returnin 1, then finally at end of
file returnin 0.  If there be a gangbangin' filehandle, then tha subroutine will be
called ta act as a simple source filter, wit tha line as read up in \f(CW$_\fR.
Again, return 1 fo' each valid line, n' 0 afta all lines have been
returned.
.IP "3." 4
Optionizzle state fo' tha subroutine.  Da state is passed up in as \f(CW$_[1]\fR.  A
reference ta tha subroutine itself is passed up in as \f(CW$_[0]\fR.
.RE
.RS 4
.Sp
If a empty list, \f(CW\*(C`undef\*(C'\fR, or not a god damn thang dat matches tha straight-up original gangsta 3 joints above
is returned, then \f(CW\*(C`require\*(C'\fR looks all up in tha remainin elementz of \f(CW@INC\fR.
Note dat dis filehandle must be a real filehandle (strictly a typeglob
or reference ta a typeglob, whether pimped or unblessed); tied filehandlez 
will be ignored n' processin will stop there.
.Sp
If tha hook be a array reference, its first element must be a subroutine
reference.  This subroutine is called as above yo, but tha straight-up original gangsta parameta is
the array reference.  This lets you indirectly pass arguments to
the subroutine.
.Sp
In other lyrics, you can write:
.Sp
.Vb 5
\&    push @INC, \e&my_sub;
\&    sub my_sub {
\&        mah ($coderef, $filename) = @_;  # $coderef is \e&my_sub
\&        ...
\&    }
.Ve
.Sp
or:
.Sp
.Vb 7
\&    push @INC, [ \e&my_sub, $x, $y, ... ];
\&    sub my_sub {
\&        mah ($arrayref, $filename) = @_;
\&        # Retrieve $x, $y, ...
\&        mah @parametas = @$arrayref[1..$#$arrayref];
\&        ...
\&    }
.Ve
.Sp
If tha hook be a object, it must provide a \s-1INC\s0 method dat will be
called as above, tha straight-up original gangsta parameta bein tha object itself.  (Note that
you must straight-up qualify tha subz name, as unqualified \f(CW\*(C`INC\*(C'\fR be always forced
into package \f(CW\*(C`main\*(C'\fR.)  Here be a typical code layout:
.Sp
.Vb 7
\&    # In Foo.pm
\&    package Foo;
\&    sub freshly smoked up { ... }
\&    sub Foo::INC {
\&        mah ($self, $filename) = @_;
\&        ...
\&    }
\&
\&    # In tha main program
\&    push @INC, Foo\->new(...);
.Ve
.Sp
These hooks is also permitted ta set tha \f(CW%INC\fR entry
correspondin ta tha filez they have loaded. Y'all KNOW dat shit, muthafucka!  See \*(L"%INC\*(R" up in perlvar.
.Sp
For a yet-more-powerful import facility, peep \*(L"use\*(R" n' perlmod.
.RE
.IP "reset \s-1EXPR \s0" 4
.IX Xref "reset"
.IX Item "reset EXPR "
.PD 0
.IP "reset" 4
.IX Item "reset"
.PD
Generally used up in a \f(CW\*(C`continue\*(C'\fR block all up in tha end of a loop ta clear
variablez n' reset \f(CW\*(C`??\*(C'\fR searches so dat they work again. I aint talkin' bout chicken n' gravy biatch.  The
expression is interpreted as a list of single charactas (hyphens
allowed fo' ranges).  All variablez n' arrays beginnin wit one of
those lettas is reset ta they pristine state.  If tha expression is
omitted, one-match searches (\f(CW\*(C`?pattern?\*(C'\fR) is reset ta match again. I aint talkin' bout chicken n' gravy biatch.  
Only resets variablez or searches up in tha current package.  Always returns
1.  Examples:
.Sp
.Vb 3
\&    reset \*(AqX\*(Aq;      # reset all X variables
\&    reset \*(Aqa\-z\*(Aq;    # reset lower case variables
\&    reset;          # just reset ?one\-time, biatch? searches
.Ve
.Sp
Resettin \f(CW"A\-Z"\fR aint recommended cuz you gonna wipe up your
\&\f(CW@ARGV\fR n' \f(CW@INC\fR arrays n' yo' \f(CW%ENV\fR hash.  Resets only package
variables; lexical variablez is unaffected yo, but they clean theyselves
up on scope exit anyway, so you gonna probably wanna use dem instead.
See \*(L"my\*(R".
.IP "return \s-1EXPR \s0" 4
.IX Xref "return"
.IX Item "return EXPR "
.PD 0
.IP "return" 4
.IX Item "return"
.PD
Returns from a subroutine, \f(CW\*(C`eval\*(C'\fR, or \f(CW\*(C`do FILE\*(C'\fR wit tha value
given up in \s-1EXPR. \s0 Evaluation of \s-1EXPR\s0 may be up in list, scalar, or void
context, dependin on how tha fuck tha return value is ghon be used, n' tha context
may vary from one execution ta tha next (see \*(L"wantarray\*(R").  If no \s-1EXPR\s0
is given, returns a empty list up in list context, tha undefined value in
scalar context, n' (of course) not a god damn thang at all up in void context.
.Sp
(In tha absence of a explicit \f(CW\*(C`return\*(C'\fR, a subroutine, eval,
or do \s-1FILE\s0 automatically returns tha value of tha last expression
evaluated.)
.Sp
Unlike most named operators, dis be also exempt from the
looks-like-a-function rule, so \f(CW\*(C`return ("foo")."bar"\*(C'\fR will
cause \*(L"bar\*(R" ta be part of tha argument ta \f(CW\*(C`return\*(C'\fR.
.IP "reverse \s-1LIST \s0" 4
.IX Xref "reverse rev invert"
.IX Item "reverse LIST "
In list context, returns a list value consistin of tha elements
of \s-1LIST\s0 up in tha opposite order n' shit.  In scalar context, concatenates the
elementz of \s-1LIST\s0 n' returns a strang value wit all characters
in tha opposite order.
.Sp
.Vb 1
\&    print join(", ", reverse "world", "Hello"); # Yo muthafucka, ghetto
\&
\&    print scalar reverse "dlrow ,", "olleH";    # Yo muthafucka, ghetto
.Ve
.Sp
Used without arguments up in scalar context, \fIreverse()\fR reverses \f(CW$_\fR.
.Sp
.Vb 3
\&    $_ = "dlrow ,olleH";
\&    print reverse;                         # No output, list context
\&    print scalar reverse;                  # Yo muthafucka, ghetto
.Ve
.Sp
Note dat reversin a array ta itself (as up in \f(CW\*(C`@a = reverse @a\*(C'\fR) will
preserve non-existent elements whenever possible; i.e., fo' non-magical
arrays or fo' tied arrays wit \f(CW\*(C`EXISTS\*(C'\fR n' \f(CW\*(C`DELETE\*(C'\fR methods.
.Sp
This operator be also handy fo' invertin a hash, although there be some
caveats, n' you can put dat on yo' toast.  If a value is duplicated up in tha original gangsta hash, only one of them
can be represented as a key up in tha inverted hash.  Also, dis has to
unwind one hash n' build a whole freshly smoked up one, which may take some time
on a big-ass hash, like fuckin from a \s-1DBM\s0 file.
.Sp
.Vb 1
\&    %by_name = reverse %by_address;  # Invert tha hash
.Ve
.IP "rewinddir \s-1DIRHANDLE \s0" 4
.IX Xref "rewinddir"
.IX Item "rewinddir DIRHANDLE "
Sets tha current posizzle ta tha beginnin of tha directory fo' the
\&\f(CW\*(C`readdir\*(C'\fR routine on \s-1DIRHANDLE.\s0
.Sp
Portabilitizzle issues: \*(L"rewinddir\*(R" up in perlport.
.IP "rindex \s-1STR,SUBSTR,POSITION \s0" 4
.IX Xref "rindex"
.IX Item "rindex STR,SUBSTR,POSITION "
.PD 0
.IP "rindex \s-1STR,SUBSTR\s0" 4
.IX Item "rindex STR,SUBSTR"
.PD
Works just like \fIindex()\fR except dat it returns tha posizzle of tha \fIlast\fR
occurrence of \s-1SUBSTR\s0 up in \s-1STR. \s0 If \s-1POSITION\s0 is specified, returns the
last occurrence beginnin at or before dat position.
.IP "rmdir \s-1FILENAME \s0" 4
.IX Xref "rmdir rd directory, remove"
.IX Item "rmdir FILENAME "
.PD 0
.IP "rmdir" 4
.IX Item "rmdir"
.PD
Deletes tha directory specified by \s-1FILENAME\s0 if dat directory is
empty.  If it succeedz it returns true; otherwise it returns false and
sets \f(CW$!\fR (errno).  If \s-1FILENAME\s0 is omitted, uses \f(CW$_\fR.
.Sp
To remove a gangbangin' finger-lickin' directory tree recursively (\f(CW\*(C`rm \-rf\*(C'\fR on Unix) peep
the \f(CW\*(C`rmtree\*(C'\fR function of tha File::Path module.
.IP "s///" 4
.IX Item "s///"
Da substitution operator. Shiiit, dis aint no joke.  See \*(L"Regexp Quote-Like Operators\*(R" up in perlop.
.IP "say \s-1FILEHANDLE LIST \s0" 4
.IX Xref "say"
.IX Item "say FILEHANDLE LIST "
.PD 0
.IP "say \s-1FILEHANDLE\s0" 4
.IX Item "say FILEHANDLE"
.IP "say \s-1LIST\s0" 4
.IX Item "say LIST"
.IP "say" 4
.IX Item "say"
.PD
Just like \f(CW\*(C`print\*(C'\fR yo, but implicitly appendz a newline.  \f(CW\*(C`say LIST\*(C'\fR is
simply a abbreviation fo' \f(CW\*(C`{ local $\e = "\en"; print LIST }\*(C'\fR.  To use
\&\s-1FILEHANDLE\s0 without a \s-1LIST\s0 ta print tha contentz of \f(CW$_\fR ta it, you must
use a real filehandle like \f(CW\*(C`FH\*(C'\fR, not a indirect one like \f(CW$fh\fR.
.Sp
This keyword be available only when tha \f(CW"say"\fR feature
is enabled, or when prefixed wit \f(CW\*(C`CORE::\*(C'\fR; see
feature.  Alternately, include a \f(CW\*(C`use v5.10\*(C'\fR or lata ta tha current
scope.
.IP "scalar \s-1EXPR \s0" 4
.IX Xref "scalar context"
.IX Item "scalar EXPR "
Forces \s-1EXPR\s0 ta be interpreted up in scalar context n' returns tha value
of \s-1EXPR.\s0
.Sp
.Vb 1
\&    @counts = ( scalar @a, scalar @b, scalar @c );
.Ve
.Sp
There is no equivalent operator ta force a expression to
be interpolated up in list context cuz up in practice, dis is never
needed. Y'all KNOW dat shit, muthafucka!  If you straight-up wanted ta do so, however, you could use
the construction \f(CW\*(C`@{[ (some expression) ]}\*(C'\fR yo, but probably a simple
\&\f(CW\*(C`(some expression)\*(C'\fR suffices.
.Sp
Because \f(CW\*(C`scalar\*(C'\fR be a unary operator, if you accidentally use a
parenthesized list fo' tha \s-1EXPR,\s0 dis behaves as a scalar comma expression,
evaluatin all but tha last element up in void context n' returnin tha final
element evaluated up in scalar context.  This is seldom what tha fuck you want.
.Sp
Da followin single statement:
.Sp
.Vb 1
\&    print uc(scalar(&foo,$bar)),$baz;
.Ve
.Sp
is tha moral equivalent of these two:
.Sp
.Vb 2
\&    &foo;
\&    print(uc($bar),$baz);
.Ve
.Sp
See perlop fo' mo' details on unary operators n' tha comma operator.
.IP "seek \s-1FILEHANDLE,POSITION,WHENCE \s0" 4
.IX Xref "seek fseek filehandle, position"
.IX Item "seek FILEHANDLE,POSITION,WHENCE "
Sets \s-1FILEHANDLE\s0z position, just like tha \f(CW\*(C`fseek\*(C'\fR call of \f(CW\*(C`stdio\*(C'\fR.
\&\s-1FILEHANDLE\s0 may be a expression whose value gives tha name of the
filehandle.  Da joints fo' \s-1WHENCE\s0 is \f(CW0\fR ta set tha freshly smoked up position
\&\fIin bytes\fR ta \s-1POSITION\s0; \f(CW1\fR ta set it ta tha current posizzle plus
\&\s-1POSITION\s0; n' \f(CW2\fR ta set it ta \s-1EOF\s0 plus \s-1POSITION,\s0 typically
negative.  For \s-1WHENCE\s0 you may use tha constants \f(CW\*(C`SEEK_SET\*(C'\fR,
\&\f(CW\*(C`SEEK_CUR\*(C'\fR, n' \f(CW\*(C`SEEK_END\*(C'\fR (start of tha file, current position, end
of tha file) from tha Fcntl module.  Returns \f(CW1\fR on success, false
otherwise.
.Sp
Note tha \fIin bytes\fR: even if tha filehandle has been set to
operate on charactas (for example by rockin tha \f(CW\*(C`:encoding(utf8)\*(C'\fR open
layer), \fItell()\fR will return byte offsets, not characta offsets
(because implementin dat would render \fIseek()\fR n' \fItell()\fR rather slow).
.Sp
If you wanna posizzle tha file fo' \f(CW\*(C`sysread\*(C'\fR or \f(CW\*(C`syswrite\*(C'\fR, don't use
\&\f(CW\*(C`seek\*(C'\fR, cuz bufferin make its effect on tha filez read-write position
unpredictable n' non-portable.  Use \f(CW\*(C`sysseek\*(C'\fR instead.
.Sp
Cuz of tha rulez n' rigorz of \s-1ANSI C,\s0 on some systems you gotta do a
seek whenever you switch between readin n' writing.  Amongst other
things, dis may have tha effect of callin stdioz \fIclearerr\fR\|(3).
A \s-1WHENCE\s0 of \f(CW1\fR (\f(CW\*(C`SEEK_CUR\*(C'\fR) is useful fo' not movin tha file position:
.Sp
.Vb 1
\&    seek(TEST,0,1);
.Ve
.Sp
This be also useful fo' applications emulatin \f(CW\*(C`tail \-f\*(C'\fR.  Once you hit
\&\s-1EOF\s0 on yo' read n' then chill fo' a while, you (probably) gotta stick up in a
dummy \fIseek()\fR ta reset thangs.  Da \f(CW\*(C`seek\*(C'\fR don't chizzle tha position,
but it \fIdoes\fR clear tha end-of-file condizzle on tha handle, so dat the
next \f(CW\*(C`<FILE>\*(C'\fR make Perl try again n' again n' again ta read something.  (Our thugged-out asses hope.)
.Sp
If dat don't work (some I/O implementations is particularly
cantankerous), you might need suttin' like this:
.Sp
.Vb 8
\&    fo' (;;) {
\&        fo' ($curpos = tell(FILE); $_ = <FILE>;
\&             $curpos = tell(FILE)) {
\&            # search fo' some shiznit n' put it tha fuck into files
\&        }
\&        chill($for_a_while);
\&        seek(FILE, $curpos, 0);
\&    }
.Ve
.IP "seekdir \s-1DIRHANDLE,POS \s0" 4
.IX Xref "seekdir"
.IX Item "seekdir DIRHANDLE,POS "
Sets tha current posizzle fo' tha \f(CW\*(C`readdir\*(C'\fR routine on \s-1DIRHANDLE.  POS\s0
must be a value returned by \f(CW\*(C`telldir\*(C'\fR.  \f(CW\*(C`seekdir\*(C'\fR also has tha same ol' dirty caveats
about possible directory compaction as tha correspondin system library
routine.
.IP "select \s-1FILEHANDLE \s0" 4
.IX Xref "select filehandle, default"
.IX Item "select FILEHANDLE "
.PD 0
.IP "select" 4
.IX Item "select"
.PD
Returns tha currently selected filehandle.  If \s-1FILEHANDLE\s0 is supplied,
sets tha freshly smoked up current default filehandle fo' output.  This has two
effects: first, a \f(CW\*(C`write\*(C'\fR or a \f(CW\*(C`print\*(C'\fR without a gangbangin' filehandle 
default ta dis \s-1FILEHANDLE. \s0 Second, references ta variablez related to
output will refer ta dis output channel.
.Sp
For example, ta set tha top-of-form format fo' mo' than one
output channel, you might do tha following:
.Sp
.Vb 4
\&    select(REPORT1);
\&    $^ = \*(Aqreport1_top\*(Aq;
\&    select(REPORT2);
\&    $^ = \*(Aqreport2_top\*(Aq;
.Ve
.Sp
\&\s-1FILEHANDLE\s0 may be a expression whose value gives tha name of the
actual filehandle.  Thus:
.Sp
.Vb 1
\&    $oldfh = select(STDERR); $| = 1; select($oldfh);
.Ve
.Sp
Some programmers may prefer ta be thinkin of filehandlez as objects with
methods, preferrin ta write tha last example as:
.Sp
.Vb 2
\&    use IO::Handle;
\&    STDERR\->autoflush(1);
.Ve
.Sp
Portabilitizzle issues: \*(L"select\*(R" up in perlport.
.IP "select \s-1RBITS,WBITS,EBITS,TIMEOUT \s0" 4
.IX Xref "select"
.IX Item "select RBITS,WBITS,EBITS,TIMEOUT "
This calls tha \fIselect\fR\|(2) syscall wit tha bit masks specified, which
can be constructed rockin \f(CW\*(C`fileno\*(C'\fR n' \f(CW\*(C`vec\*(C'\fR, along these lines:
.Sp
.Vb 4
\&    $rin = $win = $ein = \*(Aq\*(Aq;
\&    vec($rin, fileno(STDIN),  1) = 1;
\&    vec($win, fileno(STDOUT), 1) = 1;
\&    $ein = $rin | $win;
.Ve
.Sp
If you wanna select on nuff filehandles, you may wish ta write a
subroutine like this:
.Sp
.Vb 9
\&    sub fhbits {
\&        mah @fhlist = @_;
\&        mah $bits = "";
\&        fo' mah $fh (@fhlist) {
\&            vec($bits, fileno($fh), 1) = 1;
\&        }
\&        return $bits;
\&    }
\&    $rin = fhbits(*STDIN, *TTY, *MYSOCK);
.Ve
.Sp
Da usual idiom is:
.Sp
.Vb 2
\&    ($nfound,$timeleft) =
\&      select($rout=$rin, $wout=$win, $eout=$ein, $timeout);
.Ve
.Sp
or ta block until suttin' becomes locked n loaded just do this
.Sp
.Vb 1
\&    $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);
.Ve
.Sp
Most systems do not bother ta return anythang useful up in \f(CW$timeleft\fR, so
callin \fIselect()\fR up in scalar context just returns \f(CW$nfound\fR.
.Sp
Any of tha bit masks can also be undef.  Da timeout, if specified, is
in seconds, which may be fractional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Note: not all implementations are
capable of returnin tha \f(CW$timeleft\fR.  If not, they always return
\&\f(CW$timeleft\fR equal ta tha supplied \f(CW$timeout\fR.
.Sp
Yo ass can effect a chill of 250 millisecondz dis way:
.Sp
.Vb 1
\&    select(undef, undef, undef, 0.25);
.Ve
.Sp
Note dat whether \f(CW\*(C`select\*(C'\fR gets restarted afta signals (say, \s-1SIGALRM\s0)
is implementation-dependent.  See also perlport fo' notes on the
portabilitizzle of \f(CW\*(C`select\*(C'\fR.
.Sp
On error, \f(CW\*(C`select\*(C'\fR behaves just like \fIselect\fR\|(2): it returns
\&\-1 n' sets \f(CW$!\fR.
.Sp
On some Unixes, \fIselect\fR\|(2) may report a socket file descriptor as \*(L"ready for
reading\*(R" even when no data be available, n' thus any subsequent \f(CW\*(C`read\*(C'\fR
would block.  This can be avoided if you always use O_NONBLOCK on the
socket.  See \fIselect\fR\|(2) n' \fIfcntl\fR\|(2) fo' further details.
.Sp
Da standard \f(CW\*(C`IO::Select\*(C'\fR module serves up a user-friendlier intercourse
to \f(CW\*(C`select\*(C'\fR, mostly cuz it do all tha bit-mask work fo' yo thugged-out ass.
.Sp
\&\fB\s-1WARNING\s0\fR: One should not attempt ta mix buffered I/O (like \f(CW\*(C`read\*(C'\fR
or <\s-1FH\s0>) wit \f(CW\*(C`select\*(C'\fR, except as permitted by \s-1POSIX,\s0 n' even
then only on \s-1POSIX\s0 systems.  Yo ass gotta use \f(CW\*(C`sysread\*(C'\fR instead.
.Sp
Portabilitizzle issues: \*(L"select\*(R" up in perlport.
.IP "semctl \s-1ID,SEMNUM,CMD,ARG \s0" 4
.IX Xref "semctl"
.IX Item "semctl ID,SEMNUM,CMD,ARG "
Calls tha System V \s-1IPC\s0 function \fIsemctl\fR\|(2).  You'll probably gotta say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
.Sp
first ta git tha erect constant definitions.  If \s-1CMD\s0 is \s-1IPC_STAT\s0 or
\&\s-1GETALL,\s0 then \s-1ARG\s0 must be a variable dat will hold tha returned
semid_dz structure or semaphore value array.  Returns like \f(CW\*(C`ioctl\*(C'\fR:
the undefined value fo' error, "\f(CW\*(C`0 but true\*(C'\fR" fo' zero, or tha actual
return value otherwise.  Da \s-1ARG\s0 must consist of a vector of native
short integers, which may be pimped wit \f(CW\*(C`pack("s!",(0)x$nsem)\*(C'\fR.
See also \*(L"SysV \s-1IPC\*(R"\s0 up in perlipc, \f(CW\*(C`IPC::SysV\*(C'\fR, \f(CW\*(C`IPC::Semaphore\*(C'\fR
documentation.
.Sp
Portabilitizzle issues: \*(L"semctl\*(R" up in perlport.
.IP "semget \s-1KEY,NSEMS,FLAGS \s0" 4
.IX Xref "semget"
.IX Item "semget KEY,NSEMS,FLAGS "
Calls tha System V \s-1IPC\s0 function \fIsemget\fR\|(2).  Returns tha semaphore id, or
the undefined value on error. Shiiit, dis aint no joke.  See also
\&\*(L"SysV \s-1IPC\*(R"\s0 up in perlipc, \f(CW\*(C`IPC::SysV\*(C'\fR, \f(CW\*(C`IPC::SysV::Semaphore\*(C'\fR
documentation.
.Sp
Portabilitizzle issues: \*(L"semget\*(R" up in perlport.
.IP "semop \s-1KEY,OPSTRING \s0" 4
.IX Xref "semop"
.IX Item "semop KEY,OPSTRING "
Calls tha System V \s-1IPC\s0 function \fIsemop\fR\|(2) fo' semaphore operations
like fuckin signallin n' waiting.  \s-1OPSTRING\s0 must be a packed array of
semop structures.  Each semop structure can be generated with
\&\f(CW\*(C`pack("s!3", $semnum, $semop, $semflag)\*(C'\fR.  Da length of \s-1OPSTRING \s0
implies tha number of semaphore operations.  Returns legit if
successful, false on error. Shiiit, dis aint no joke.  As a example, the
followin code waits on semaphore \f(CW$semnum\fR of semaphore id \f(CW$semid:\fR
.Sp
.Vb 2
\&    $semop = pack("s!3", $semnum, \-1, 0);
\&    take a thugged-out dirtnap "Semaphore shit: $!\en" unless semop($semid, $semop);
.Ve
.Sp
To signal tha semaphore, replace \f(CW\*(C`\-1\*(C'\fR wit \f(CW1\fR.  See also
\&\*(L"SysV \s-1IPC\*(R"\s0 up in perlipc, \f(CW\*(C`IPC::SysV\*(C'\fR, n' \f(CW\*(C`IPC::SysV::Semaphore\*(C'\fR
documentation.
.Sp
Portabilitizzle issues: \*(L"semop\*(R" up in perlport.
.IP "send \s-1SOCKET,MSG,FLAGS,TO \s0" 4
.IX Xref "send"
.IX Item "send SOCKET,MSG,FLAGS,TO "
.PD 0
.IP "send \s-1SOCKET,MSG,FLAGS\s0" 4
.IX Item "send SOCKET,MSG,FLAGS"
.PD
Sendz a message on a socket.  Attempts ta bust tha scalar \s-1MSG\s0 ta tha \s-1SOCKET\s0
filehandle.  Takes tha same ol' dirty flags as tha system call of tha same name.  On
unconnected sockets, you must specify a thugged-out destination ta \fIsend to\fR, up in which
case it do a \fIsendto\fR\|(2) syscall.  Returns tha number of charactas sent,
or tha undefined value on error. Shiiit, dis aint no joke.  Da \fIsendmsg\fR\|(2) syscall is currently
unimplemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See \*(L"\s-1UDP:\s0 Message Passing\*(R" up in perlipc fo' examples.
.Sp
Note tha \fIcharacters\fR: dependin on tha statuz of tha socket, either
(8\-bit) bytes or charactas is sent.  By default all sockets operate
on bytes yo, but fo' example if tha socket has been chizzled using
\&\fIbinmode()\fR ta operate wit tha \f(CW\*(C`:encoding(utf8)\*(C'\fR I/O layer (see
\&\*(L"open\*(R", or tha \f(CW\*(C`open\*(C'\fR pragma, open), tha I/O will operate on \s-1UTF\-8\s0
encoded Unicode characters, not bytes.  Similarly fo' tha \f(CW\*(C`:encoding\*(C'\fR
pragma: up in dat case pretty much any charactas can be sent.
.IP "setpgrp \s-1PID,PGRP \s0" 4
.IX Xref "setpgrp group"
.IX Item "setpgrp PID,PGRP "
Sets tha current process crew fo' tha specified \s-1PID, \s0\f(CW0\fR fo' tha current
process.  Raises a exception when used on a machine dat don't
implement \s-1POSIX\s0 \fIsetpgid\fR\|(2) or \s-1BSD\s0 \fIsetpgrp\fR\|(2).  If tha arguments is omitted,
it defaults ta \f(CW\*(C`0,0\*(C'\fR.  Note dat tha \s-1BSD 4.2\s0 version of \f(CW\*(C`setpgrp\*(C'\fR do not
accept any arguments, so only \f(CW\*(C`setpgrp(0,0)\*(C'\fR is portable.  See also
\&\f(CW\*(C`POSIX::setsid()\*(C'\fR.
.Sp
Portabilitizzle issues: \*(L"setpgrp\*(R" up in perlport.
.IP "setprioritizzle \s-1WHICH,WHO,PRIORITY \s0" 4
.IX Xref "setprioritizzle prioritizzle sick renice"
.IX Item "setprioritizzle WHICH,WHO,PRIORITY "
Sets tha current prioritizzle fo' a process, a process group, or a user.
(See \fIsetpriority\fR\|(2).)  Raises a exception when used on a machine
that don't implement \fIsetpriority\fR\|(2).
.Sp
Portabilitizzle issues: \*(L"setpriority\*(R" up in perlport.
.IP "setsockopt \s-1SOCKET,LEVEL,OPTNAME,OPTVAL \s0" 4
.IX Xref "setsockopt"
.IX Item "setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL "
Sets tha socket option requested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns \f(CW\*(C`undef\*(C'\fR on error.
Use integer constants provided by tha \f(CW\*(C`Socket\*(C'\fR module for
\&\s-1LEVEL\s0 n' \s-1OPNAME. \s0 Values fo' \s-1LEVEL\s0 can also be obtained from
getprotobyname.  \s-1OPTVAL\s0 might either be a packed strang or a integer.
An integer \s-1OPTVAL\s0 is shorthand fo' pack(\*(L"i\*(R", \s-1OPTVAL\s0).
.Sp
An example disablin Naglez algorithm on a socket:
.Sp
.Vb 2
\&    use Socket qw(IPPROTO_TCP TCP_NODELAY);
\&    setsockopt($socket, IPPROTO_TCP, TCP_NODELAY, 1);
.Ve
.Sp
Portabilitizzle issues: \*(L"setsockopt\*(R" up in perlport.
.IP "shift \s-1ARRAY \s0" 4
.IX Xref "shift"
.IX Item "shift ARRAY "
.PD 0
.IP "shift \s-1EXPR\s0" 4
.IX Item "shift EXPR"
.IP "shift" 4
.IX Item "shift"
.PD
Shifts tha straight-up original gangsta value of tha array off n' returns it, shortenin the
array by 1 n' movin every last muthafuckin thang down. I aint talkin' bout chicken n' gravy biatch.  If there be no elements up in the
array, returns tha undefined value.  If \s-1ARRAY\s0 is omitted, shifts the
\&\f(CW@_\fR array within tha lexical scope of subroutines n' formats, n' the
\&\f(CW@ARGV\fR array outside a subroutine n' also within tha lexical scopes
established by tha \f(CW\*(C`eval STRING\*(C'\fR, \f(CW\*(C`BEGIN {}\*(C'\fR, \f(CW\*(C`INIT {}\*(C'\fR, \f(CW\*(C`CHECK {}\*(C'\fR,
\&\f(CW\*(C`UNITCHECK {}\*(C'\fR, n' \f(CW\*(C`END {}\*(C'\fR constructs.
.Sp
Startin wit Perl 5.14, \f(CW\*(C`shift\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold a
reference ta a unblessed array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`shift\*(C'\fR is considered highly experimental.
Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so push/pop/etc work on scalars (experimental)
.Ve
.Sp
See also \f(CW\*(C`unshift\*(C'\fR, \f(CW\*(C`push\*(C'\fR, n' \f(CW\*(C`pop\*(C'\fR.  \f(CW\*(C`shift\*(C'\fR n' \f(CW\*(C`unshift\*(C'\fR do the
same thang ta tha left end of a array dat \f(CW\*(C`pop\*(C'\fR n' \f(CW\*(C`push\*(C'\fR do ta the
right end.
.IP "shmctl \s-1ID,CMD,ARG \s0" 4
.IX Xref "shmctl"
.IX Item "shmctl ID,CMD,ARG "
Calls tha System V \s-1IPC\s0 function shmctl.  You'll probably gotta say
.Sp
.Vb 1
\&    use IPC::SysV;
.Ve
.Sp
first ta git tha erect constant definitions.  If \s-1CMD\s0 is \f(CW\*(C`IPC_STAT\*(C'\fR,
then \s-1ARG\s0 must be a variable dat will hold tha returned \f(CW\*(C`shmid_ds\*(C'\fR
structure.  Returns like ioctl: \f(CW\*(C`undef\*(C'\fR fo' error; "\f(CW0\fR but
true" fo' zero; n' tha actual return value otherwise.
See also \*(L"SysV \s-1IPC\*(R"\s0 up in perlipc n' \f(CW\*(C`IPC::SysV\*(C'\fR documentation.
.Sp
Portabilitizzle issues: \*(L"shmctl\*(R" up in perlport.
.IP "shmget \s-1KEY,SIZE,FLAGS \s0" 4
.IX Xref "shmget"
.IX Item "shmget KEY,SIZE,FLAGS "
Calls tha System V \s-1IPC\s0 function shmget.  Returns tha shared memory
segment id, or \f(CW\*(C`undef\*(C'\fR on error.
See also \*(L"SysV \s-1IPC\*(R"\s0 up in perlipc n' \f(CW\*(C`IPC::SysV\*(C'\fR documentation.
.Sp
Portabilitizzle issues: \*(L"shmget\*(R" up in perlport.
.IP "shmread \s-1ID,VAR,POS,SIZE \s0" 4
.IX Xref "shmread shmwrite"
.IX Item "shmread ID,VAR,POS,SIZE "
.PD 0
.IP "shmwrite \s-1ID,STRING,POS,SIZE\s0" 4
.IX Item "shmwrite ID,STRING,POS,SIZE"
.PD
Readz or writes tha System V shared memory segment \s-1ID\s0 startin at
posizzle \s-1POS\s0 fo' size \s-1SIZE\s0 by attachin ta it, copyin in/out, and
detachin from dat shit.  When reading, \s-1VAR\s0 must be a variable dat will
hold tha data read. Y'all KNOW dat shit, muthafucka!  When writing, if \s-1STRING\s0 is too long, only \s-1SIZE\s0
bytes is used; if \s-1STRING\s0 is too short, nulls is freestyled ta fill out
\&\s-1SIZE\s0 bytes.  Return legit if successful, false on error.
\&\fIshmread()\fR taints tha variable.  See also \*(L"SysV \s-1IPC\*(R"\s0 up in perlipc,
\&\f(CW\*(C`IPC::SysV\*(C'\fR, n' tha \f(CW\*(C`IPC::Shareable\*(C'\fR module from \s-1CPAN.\s0
.Sp
Portabilitizzle issues: \*(L"shmread\*(R" up in perlport n' \*(L"shmwrite\*(R" up in perlport.
.IP "shutdown \s-1SOCKET,HOW \s0" 4
.IX Xref "shutdown"
.IX Item "shutdown SOCKET,HOW "
Shuts down a socket connection up in tha manner indicated by \s-1HOW,\s0 which
has tha same ol' dirty interpretation as up in tha syscall of tha same name.
.Sp
.Vb 3
\&    shutdown(SOCKET, 0);    # I/we have stopped readin data
\&    shutdown(SOCKET, 1);    # I/we have stopped freestylin data
\&    shutdown(SOCKET, 2);    # I/we have stopped rockin dis socket
.Ve
.Sp
This is useful wit sockets when you wanna tell tha other
side you done freestylin but not done reading, or vice versa.
It aint nuthin but also a mo' insistent form of close cuz it also
disablez tha file descriptor up in any forked copies up in other
processes.
.Sp
Returns \f(CW1\fR fo' success; on error, returns \f(CW\*(C`undef\*(C'\fR if
the first argument aint a valid filehandle, or returns \f(CW0\fR n' sets
\&\f(CW$!\fR fo' any other failure.
.IP "sin \s-1EXPR \s0" 4
.IX Xref "sin sine asin arcsine"
.IX Item "sin EXPR "
.PD 0
.IP "sin" 4
.IX Item "sin"
.PD
Returns tha sine of \s-1EXPR \s0(expressed up in radians).  If \s-1EXPR\s0 is omitted,
returns sine of \f(CW$_\fR.
.Sp
For tha inverse sine operation, you may use tha \f(CW\*(C`Math::Trig::asin\*(C'\fR
function, or use dis relation:
.Sp
.Vb 1
\&    sub asin { atan2($_[0], sqrt(1 \- $_[0] * $_[0])) }
.Ve
.IP "sleep \s-1EXPR \s0" 4
.IX Xref "sleep pause"
.IX Item "sleep EXPR "
.PD 0
.IP "sleep" 4
.IX Item "sleep"
.PD
Causes tha script ta chill fo' (integer) \s-1EXPR\s0 seconds, or forever if no 
argument is given. I aint talkin' bout chicken n' gravy biatch.  Returns tha integer number of secondz straight-up slept.
.Sp
May be interrupted if tha process receives a signal like fuckin \f(CW\*(C`SIGALRM\*(C'\fR.
.Sp
.Vb 5
\&    eval {
\&        local $SIG{ALARM} = sub { take a thugged-out dirtnap "Alarm!\en" };
\&        chill;
\&    };
\&    take a thugged-out dirtnap $@ unless $@ eq "Alarm!\en";
.Ve
.Sp
Yo ass probably cannot mix \f(CW\*(C`alarm\*(C'\fR n' \f(CW\*(C`sleep\*(C'\fR calls, cuz \f(CW\*(C`sleep\*(C'\fR
is often implemented rockin \f(CW\*(C`alarm\*(C'\fR.
.Sp
On some olda systems, it may chill up ta a gangbangin' full second less than what
you requested, dependin on how tha fuck it counts seconds.  Most modern systems
always chill tha full amount.  They may step tha fuck up ta chill longer than that,
however, cuz yo' process might not be scheduled right away up in a
busy multitaskin system.
.Sp
For delayz of finer granularitizzle than one second, tha Time::HiRes module
(from \s-1CPAN,\s0 n' startin from Perl 5.8 part of tha standard
distribution) serves up \fIusleep()\fR.  Yo ass may also use Perlz four-argument
version of \fIselect()\fR leavin tha straight-up original gangsta three arguments undefined, or you
might be able ta use tha \f(CW\*(C`syscall\*(C'\fR intercourse ta access \fIsetitimer\fR\|(2) if
your system supports dat shit.  See perlfaq8 fo' details.
.Sp
See also tha \s-1POSIX\s0 modulez \f(CW\*(C`pause\*(C'\fR function.
.IP "socket \s-1SOCKET,DOMAIN,TYPE,PROTOCOL \s0" 4
.IX Xref "socket"
.IX Item "socket SOCKET,DOMAIN,TYPE,PROTOCOL "
Opens a socket of tha specified kind n' attaches it ta filehandle
\&\s-1SOCKET.  DOMAIN, TYPE,\s0 n' \s-1PROTOCOL\s0 is specified tha same as for
the syscall of tha same name.  Yo ass should \f(CW\*(C`use Socket\*(C'\fR first
to git tha proper definitions imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See tha examplez in
\&\*(L"Sockets: Client/Server Communication\*(R" up in perlipc.
.Sp
On systems dat support a cold-ass lil close-on-exec flag on files, tha flag will
be set fo' tha newly opened file descriptor, as determined by the
value of $^F.  See \*(L"$^F\*(R" up in perlvar.
.IP "socketpair \s-1SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL \s0" 4
.IX Xref "socketpair"
.IX Item "socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL "
Creates a unnamed pair of sockets up in tha specified domain, of the
specified type.  \s-1DOMAIN, TYPE,\s0 n' \s-1PROTOCOL\s0 is specified tha same as
for tha syscall of tha same name.  If unimplemented, raises a exception.
Returns legit if successful.
.Sp
On systems dat support a cold-ass lil close-on-exec flag on files, tha flag will
be set fo' tha newly opened file descriptors, as determined by tha value
of $^F.  See \*(L"$^F\*(R" up in perlvar.
.Sp
Some systems defined \f(CW\*(C`pipe\*(C'\fR up in termz of \f(CW\*(C`socketpair\*(C'\fR, up in which a cold-ass lil call
to \f(CW\*(C`pipe(Rdr, Wtr)\*(C'\fR is essentially:
.Sp
.Vb 4
\&    use Socket;
\&    socketpair(Rdr, Wtr, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
\&    shutdown(Rdr, 1);        # no mo' freestylin fo' reader
\&    shutdown(Wtr, 0);        # no mo' readin fo' writer
.Ve
.Sp
See perlipc fo' a example of socketpair use.  Perl 5.8 n' lata will
emulate socketpair rockin \s-1IP\s0 sockets ta localhost if yo' system implements
sockets but not socketpair.
.Sp
Portabilitizzle issues: \*(L"socketpair\*(R" up in perlport.
.IP "sort \s-1SUBNAME LIST \s0" 4
.IX Xref "sort qsort quicksort mergesort"
.IX Item "sort SUBNAME LIST "
.PD 0
.IP "sort \s-1BLOCK LIST\s0" 4
.IX Item "sort BLOCK LIST"
.IP "sort \s-1LIST\s0" 4
.IX Item "sort LIST"
.PD
In list context, dis sorts tha \s-1LIST\s0 n' returns tha sorted list value.
In scalar context, tha behaviour of \f(CW\*(C`sort()\*(C'\fR is undefined.
.Sp
If \s-1SUBNAME\s0 or \s-1BLOCK\s0 is omitted, \f(CW\*(C`sort\*(C'\fRs up in standard strang comparison
order n' shit.  If \s-1SUBNAME\s0 is specified, it gives tha name of a subroutine
that returns a integer less than, equal to, or pimped outa than \f(CW0\fR,
dependin on how tha fuck tha elementz of tha list is ta be ordered. Y'all KNOW dat shit, muthafucka!  (Da 
\&\f(CW\*(C`<=>\*(C'\fR n' \f(CW\*(C`cmp\*(C'\fR operators is mad useful up in such routines.)
\&\s-1SUBNAME\s0 may be a scalar variable name (unsubscripted), up in which case
the value serves up tha name of (or a reference to) tha actual
subroutine ta use.  In place of a \s-1SUBNAME,\s0 you can provide a \s-1BLOCK\s0 as
an anonymous, in-line sort subroutine.
.Sp
If tha subroutinez prototype is \f(CW\*(C`($$)\*(C'\fR, tha elements ta be compared are
passed by reference up in \f(CW@_\fR, as fo' a aiiight subroutine.  This is slower
than unprototyped subroutines, where tha elements ta be compared is passed
into tha subroutine as tha package global variablez \f(CW$a\fR n' \f(CW$b\fR (see example
below).  Note dat up in tha latta case, it is probably highly counter-productive
to declare \f(CW$a\fR n' \f(CW$b\fR as lexicals.
.Sp
If tha subroutine be a \s-1XSUB,\s0 tha elements ta be compared is pushed on to
the stack, tha way arguments is probably passed ta XSUBs.  \f(CW$a\fR n' \f(CW$b\fR are
not set.
.Sp
Da joints ta be compared is always passed by reference n' should not
be modified.
.Sp
Yo ass also cannot exit outta tha sort block or subroutine rockin any of the
loop control operators busted lyrics bout up in perlsyn or wit \f(CW\*(C`goto\*(C'\fR.
.Sp
When \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use locale \*(Aqnot_characters\*(Aq\*(C'\fR) is in
effect, \f(CW\*(C`sort LIST\*(C'\fR sorts \s-1LIST\s0 accordin ta the
current collation locale.  See perllocale.
.Sp
\&\fIsort()\fR returns aliases tha fuck into tha original gangsta list, much as a gangbangin' fo' loopz index
variable aliases tha list elements, n' you can put dat on yo' toast.  That is, modifyin a element of a
list returned by \fIsort()\fR (for example, up in a \f(CW\*(C`foreach\*(C'\fR, \f(CW\*(C`map\*(C'\fR or \f(CW\*(C`grep\*(C'\fR)
actually modifies tha element up in tha original gangsta list.  This is usually
suttin' ta be avoided when freestylin clear code.
.Sp
Perl 5.6 n' earlier used a quicksort algorithm ta implement sort.
That algorithm was not stable, so \fIcould\fR go quadratic.  (A \fIstable\fR sort
preserves tha input order of elements dat compare equal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Although
quicksortz run time is O(NlogN) when averaged over all arrays of
length N, tha time can be O(N**2), \fIquadratic\fR behavior, fo' some
inputs.)  In 5.7, tha quicksort implementation was replaced with
a stable mergesort algorithm whose worst-case behavior is O(NlogN).
But benchmarks indicated dat fo' some inputs, on some platforms,
the original gangsta quicksort was fasta n' shit.  5.8 has a sort pragma for
limited control of tha sort.  Its rather blunt control of the
underlyin algorithm may not persist tha fuck into future Perls yo, but the
abilitizzle ta characterize tha input or output up in implementation
independent ways like probably will.  See tha sort pragma.
.Sp
Examples:
.Sp
.Vb 2
\&    # sort lexically
\&    @articlez = sort @files;
\&
\&    # same thang yo, but wit explicit sort routine
\&    @articlez = sort {$a cmp $b} @files;
\&
\&    # now case\-insensitively
\&    @articlez = sort {fc($a) cmp fc($b)} @files;
\&
\&    # same thang up in reversed order
\&    @articlez = sort {$b cmp $a} @files;
\&
\&    # sort numerically ascending
\&    @articlez = sort {$a <=> $b} @files;
\&
\&    # sort numerically descending
\&    @articlez = sort {$b <=> $a} @files;
\&
\&    # dis sorts tha %age hash by value instead of key
\&    # rockin a in\-line function
\&    @eldest = sort { $age{$b} <=> $age{$a} } keys %age;
\&
\&    # sort rockin explicit subroutine name
\&    sub byage {
\&        $age{$a} <=> $age{$b};  # presumin numeric
\&    }
\&    @sortedclass = sort byage @class;
\&
\&    sub backwardz { $b cmp $a }
\&    @harry  = qw(dog pussaaaaay x Cain Abel);
\&    @george = qw(gone chased yz Punished Axed);
\&    print sort @harry;
\&        # prints AbelCaincatdogx
\&    print sort backwardz @harry;
\&        # prints xdogcatCainAbel
\&    print sort @george, \*(Aqto\*(Aq, @harry;
\&        # prints AbelAxedCainPunishedcatchaseddoggonetoxyz
\&
\&    # inefficiently sort by descendin numeric compare using
\&    # tha straight-up original gangsta integer afta tha straight-up original gangsta = sign, or the
\&    # whole record case\-insensitively otherwise
\&
\&    mah @new = sort {
\&        ($b =~ /=(\ed+)/)[0] <=> ($a =~ /=(\ed+)/)[0]
\&                            ||
\&                    fc($a)  cmp  fc($b)
\&    } @old;
\&
\&    # same thang yo, but much mo' efficiently;
\&    # we\*(Aqll build auxiliary indices instead
\&    # fo' speed
\&    mah @nums = @caps = ();
\&    fo' (@old) {
\&        push @nums, ( /=(\ed+)/ , biatch? $1 : undef );
\&        push @caps, fc($_);
\&    }
\&
\&    mah @new = @old[ sort {
\&                           $nums[$b] <=> $nums[$a]
\&                                    ||
\&                           $caps[$a] cmp $caps[$b]
\&                         } 0..$#old
\&                  ];
\&
\&    # same thang yo, but without any temps
\&    @new = map { $_\->[0] }
\&           sort { $b\->[1] <=> $a\->[1]
\&                           ||
\&                  $a\->[2] cmp $b\->[2]
\&           } map { [$_, /=(\ed+)/, fc($_)] } @old;
\&
\&    # rockin a prototype allows you ta use any comparison subroutine
\&    # as a sort subroutine (includin other package\*(Aqs subroutines)
\&    package other;
\&    sub backwardz ($$) { $_[1] cmp $_[0]; }  # $a n' $b are
\&                                             # not set here    
\&    package main;
\&    @new = sort other::backwardz @old;
\&
\&    # guarantee stability, regardless of algorithm
\&    use sort \*(Aqstable\*(Aq;
\&    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;
\&
\&    # force use of mergesort (not portable outside Perl 5.8)
\&    use sort \*(Aq_mergesort\*(Aq;  # note discouragin _
\&    @new = sort { substr($a, 3, 5) cmp substr($b, 3, 5) } @old;
.Ve
.Sp
Warning: syntactical care is required when sortin tha list returned from
a function. I aint talkin' bout chicken n' gravy biatch.  If you wanna sort tha list returned by tha function call
\&\f(CW\*(C`find_records(@key)\*(C'\fR, you can use:
.Sp
.Vb 4
\&    @contact = sort { $a cmp $b } find_recordz @key;
\&    @contact = sort +find_records(@key);
\&    @contact = sort &find_records(@key);
\&    @contact = sort(find_records(@key));
.Ve
.Sp
If instead you wanna sort tha array \f(CW@key\fR wit tha comparison routine
\&\f(CW\*(C`find_records()\*(C'\fR then you can use:
.Sp
.Vb 4
\&    @contact = sort { find_records() } @key;
\&    @contact = sort find_records(@key);
\&    @contact = sort(find_recordz @key);
\&    @contact = sort(find_recordz (@key));
.Ve
.Sp
If you rockin strict, you \fImust not\fR declare \f(CW$a\fR
and \f(CW$b\fR as lexicals.  They is package globals.  That means
that if you up in tha \f(CW\*(C`main\*(C'\fR package n' type
.Sp
.Vb 1
\&    @articlez = sort {$b <=> $a} @files;
.Ve
.Sp
then \f(CW$a\fR n' \f(CW$b\fR is \f(CW$main::a\fR n' \f(CW$main::b\fR (or \f(CW$::a\fR n' \f(CW$::b\fR),
but if you up in tha \f(CW\*(C`FooPack\*(C'\fR package, itz tha same ol' dirty as typing
.Sp
.Vb 1
\&    @articlez = sort {$FooPack::b <=> $FooPack::a} @files;
.Ve
.Sp
Da comparison function is required ta behave.  If it returns
inconsistent thangs up in dis biatch (sometimes sayin \f(CW$x[1]\fR is less than \f(CW$x[2]\fR and
sometimes sayin tha opposite, fo' example) tha thangs up in dis biatch is not
well-defined.
.Sp
Because \f(CW\*(C`<=>\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR when either operand is \f(CW\*(C`NaN\*(C'\fR
(not-a-number), be careful when sortin wit a
comparison function like \f(CW\*(C`$a <=> $b\*(C'\fR any lists dat might contain a
\&\f(CW\*(C`NaN\*(C'\fR.  Da followin example takes advantage dat \f(CW\*(C`NaN != NaN\*(C'\fR to
eliminizzle any \f(CW\*(C`NaN\*(C'\fRs from tha input list.
.Sp
.Vb 1
\&    @result = sort { $a <=> $b } grep { $_ == $_ } @input;
.Ve
.IP "splice \s-1ARRAY\s0 or \s-1EXPR,OFFSET,LENGTH,LIST \s0" 4
.IX Xref "splice"
.IX Item "splice ARRAY or EXPR,OFFSET,LENGTH,LIST "
.PD 0
.IP "splice \s-1ARRAY\s0 or \s-1EXPR,OFFSET,LENGTH\s0" 4
.IX Item "splice ARRAY or EXPR,OFFSET,LENGTH"
.IP "splice \s-1ARRAY\s0 or \s-1EXPR,OFFSET\s0" 4
.IX Item "splice ARRAY or EXPR,OFFSET"
.IP "splice \s-1ARRAY\s0 or \s-1EXPR\s0" 4
.IX Item "splice ARRAY or EXPR"
.PD
Removes tha elements designated by \s-1OFFSET\s0 n' \s-1LENGTH\s0 from a array, and
replaces dem wit tha elementz of \s-1LIST,\s0 if any.  In list context,
returns tha elements removed from tha array.  In scalar context,
returns tha last element removed, or \f(CW\*(C`undef\*(C'\fR if no elements are
removed. Y'all KNOW dat shit, muthafucka!  Da array grows or shrinks as necessary.
If \s-1OFFSET\s0 is wack then it starts dat far from tha end of tha array.
If \s-1LENGTH\s0 is omitted, removes every last muthafuckin thang from \s-1OFFSET\s0 onward.
If \s-1LENGTH\s0 is negative, removes tha elements from \s-1OFFSET\s0 onward
except fo' \-LENGTH elements all up in tha end of tha array.
If both \s-1OFFSET\s0 n' \s-1LENGTH\s0 is omitted, removes every last muthafuckin thang.  If \s-1OFFSET\s0 is
past tha end of tha array, Perl thangs a warning, n' splices at the
end of tha array.
.Sp
Da followin equivalences hold (assumin \f(CW\*(C`$#a >= $i\*(C'\fR )
.Sp
.Vb 5
\&    push(@a,$x,$y)      splice(@a,@a,0,$x,$y)
\&    pop(@a)             splice(@a,\-1)
\&    shift(@a)           splice(@a,0,1)
\&    unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
\&    $a[$i] = $y         splice(@a,$i,1,$y)
.Ve
.Sp
Example, assumin array lengths is passed before arrays:
.Sp
.Vb 10
\&    sub aeq {  # compare two list joints
\&        my(@a) = splice(@_,0,shift);
\&        my(@b) = splice(@_,0,shift);
\&        return 0 unless @a == @b;  # same len?
\&        while (@a) {
\&            return 0 if pop(@a) ne pop(@b);
\&        }
\&        return 1;
\&    }
\&    if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }
.Ve
.Sp
Startin wit Perl 5.14, \f(CW\*(C`splice\*(C'\fR can take scalar \s-1EXPR,\s0 which must hold a
reference ta a unblessed array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`splice\*(C'\fR is considered highly experimental.
Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so push/pop/etc work on scalars (experimental)
.Ve
.IP "split /PATTERN/,EXPR,LIMIT" 4
.IX Xref "split"
.IX Item "split /PATTERN/,EXPR,LIMIT"
.PD 0
.IP "split /PATTERN/,EXPR" 4
.IX Item "split /PATTERN/,EXPR"
.IP "split /PATTERN/" 4
.IX Item "split /PATTERN/"
.IP "split" 4
.IX Item "split"
.PD
Splits tha strang \s-1EXPR\s0 tha fuck into a list of strings n' returns the
list up in list context, or tha size of tha list up in scalar context.
.Sp
If only \s-1PATTERN\s0 is given, \s-1EXPR\s0 defaults ta \f(CW$_\fR.
.Sp
Anythang up in \s-1EXPR\s0 dat matches \s-1PATTERN\s0 is taken ta be a separator
that separates tha \s-1EXPR\s0 tha fuck into substrings (called "\fIfields\fR") that
do \fBnot\fR include tha separator. Shiiit, dis aint no joke.  Note dat a separator may be
longer than one characta or even have no charactas at all (the
empty string, which be a zero-width match).
.Sp
Da \s-1PATTERN\s0 need not be constant; a expression may be used
to specify a pattern dat varies at runtime.
.Sp
If \s-1PATTERN\s0 matches tha empty string, tha \s-1EXPR\s0 is split all up in tha match
posizzle (between characters).  As a example, tha following:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(\*(Aqb\*(Aq, \*(Aqabc\*(Aq)), "\en";
.Ve
.Sp
uses tha 'b' up in 'abc' as a separator ta produce tha output 'a:c'.
But fuck dat shiznit yo, tha word on tha street is dat this:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(\*(Aq\*(Aq, \*(Aqabc\*(Aq)), "\en";
.Ve
.Sp
uses empty strang matches as separators ta produce tha output
\&'a:b:c'; thus, tha empty strang may be used ta split \s-1EXPR\s0 tha fuck into a
list of its component characters.
.Sp
As a special case fo' \f(CW\*(C`split\*(C'\fR, tha empty pattern given in
match operator syntax (\f(CW\*(C`//\*(C'\fR) specifically matches tha empty string, which is contrary ta its usual
interpretation as tha last successful match.
.Sp
If \s-1PATTERN\s0 is \f(CW\*(C`/^/\*(C'\fR, then it is treated as if it used the
multiline modifier (\f(CW\*(C`/^/m\*(C'\fR), since it
aint much use otherwise.
.Sp
As another special case, \f(CW\*(C`split\*(C'\fR emulates tha default behavior of the
command line tool \fBawk\fR when tha \s-1PATTERN\s0 is either omitted or a \fIliteral
string\fR composed of a single space characta (like fuckin \f(CW\*(Aq\ \*(Aq\fR or
\&\f(CW"\ex20"\fR yo, but not e.g. \f(CW\*(C`/\ /\*(C'\fR).  In dis case, any leading
whitespace up in \s-1EXPR\s0 is removed before splittin occurs, n' tha \s-1PATTERN\s0 is
instead treated as if it was \f(CW\*(C`/\es+/\*(C'\fR; up in particular, dis means that
\&\fIany\fR contiguous whitespace (not just a single space character) is used as
a separator. Shiiit, dis aint no joke.  But fuck dat shiznit yo, tha word on tha street is dat dis special treatment can be avoided by specifying
the pattern \f(CW\*(C`/\ /\*(C'\fR instead of tha strang \f(CW"\ "\fR, thereby allowing
only a single space characta ta be a separator. Shiiit, dis aint no joke. In earlier Perlz this
special case was restricted ta tha use of a plain \f(CW"\ "\fR as the
pattern argument ta split, up in Perl 5.18.0 n' lata dis special case is
triggered by any expression which evaluates as tha simple strang \f(CW"\ "\fR.
.Sp
If omitted, \s-1PATTERN\s0 defaults ta a single space, \f(CW"\ "\fR, triggering
the previously busted lyrics bout \fIawk\fR emulation.
.Sp
If \s-1LIMIT\s0 is specified n' positive, it represents tha maximum number
of fieldz tha fuck into which tha \s-1EXPR\s0 may be split; up in other lyrics, \s-1LIMIT\s0 is
one pimped outa than tha maximum number of times \s-1EXPR\s0 may be split.  Thus,
the \s-1LIMIT\s0 value \f(CW1\fR means dat \s-1EXPR\s0 may be split a maximum of zero
times, producin a maximum of one field (namely, tha entire value of
\&\s-1EXPR\s0).  For instance:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aqabc\*(Aq, 1)), "\en";
.Ve
.Sp
produces tha output 'abc', n' this:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aqabc\*(Aq, 2)), "\en";
.Ve
.Sp
produces tha output 'a:bc', n' each of these:
.Sp
.Vb 2
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aqabc\*(Aq, 3)), "\en";
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aqabc\*(Aq, 4)), "\en";
.Ve
.Sp
produces tha output 'a:b:c'.
.Sp
If \s-1LIMIT\s0 is negative, it is treated as if it was instead arbitrarily
large; as nuff fieldz as possible is produced.
.Sp
If \s-1LIMIT\s0 is omitted (or, equivalently, zero), then it is usually
treated as if it was instead wack but wit tha exception that
trailin empty fieldz is stripped (empty leadin fieldz is always
preserved); if all fieldz is empty, then all fieldz is considered to
be trailin (and is thus stripped up in dis case).  Thus, tha following:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(\*(Aq,\*(Aq, \*(Aqa,b,c,,,\*(Aq)), "\en";
.Ve
.Sp
produces tha output 'a:b:c' yo, but tha following:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(\*(Aq,\*(Aq, \*(Aqa,b,c,,,\*(Aq, \-1)), "\en";
.Ve
.Sp
produces tha output 'a:b:c:::'.
.Sp
In time-critical applications, it is worthwhile ta avoid splitting
into mo' fieldz than necessary.  Thus, when assignin ta a list,
if \s-1LIMIT\s0 is omitted (or zero), then \s-1LIMIT\s0 is treated as though it
were one larger than tha number of variablez up in tha list; fo' the
following, \s-1LIMIT\s0 is implicitly 3:
.Sp
.Vb 1
\&    ($login, $passwd) = split(/:/);
.Ve
.Sp
Note dat splittin a \s-1EXPR\s0 dat evaluates ta tha empty strang always
produces zero fields, regardless of tha \s-1LIMIT\s0 specified.
.Sp
An empty leadin field is produced when there be a positive-width
match all up in tha beginnin of \s-1EXPR. \s0 For instance:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(/ /, \*(Aq abc\*(Aq)), "\en";
.Ve
.Sp
produces tha output ':abc'.  But fuck dat shiznit yo, tha word on tha street is dat a zero-width match at the
beginnin of \s-1EXPR\s0 never produces a empty field, so that:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aq abc\*(Aq));
.Ve
.Sp
produces tha output '\ :a:b:c' (rather than ':\ :a:b:c').
.Sp
An empty trailin field, on tha other hand, is produced when there be a
match all up in tha end of \s-1EXPR,\s0 regardless of tha length of tha match
(of course, unless a non-zero \s-1LIMIT\s0 is given explicitly, such fieldz are
removed, as up in tha last example).  Thus:
.Sp
.Vb 1
\&    print join(\*(Aq:\*(Aq, split(//, \*(Aq abc\*(Aq, \-1)), "\en";
.Ve
.Sp
produces tha output '\ :a:b:c:'.
.Sp
If tha \s-1PATTERN\s0 gotz nuff
capturin groups,
then fo' each separator, a additionizzle field is produced fo' each substring
captured by a crew (in tha order up in which tha crews is specified,
as per backreferences); if any crew do not
match, then it captures tha \f(CW\*(C`undef\*(C'\fR value instead of a substring.  Also,
note dat any such additionizzle field is produced whenever there be a
separator (that is, whenever a split occurs), n' such a additionizzle field
does \fBnot\fR count towardz tha \s-1LIMIT. \s0 Consider tha followin expressions
evaluated up in list context (each returned list is provided up in tha associated
comment):
.Sp
.Vb 2
\&    split(/\-|,/, "1\-10,20", 3)
\&    # (\*(Aq1\*(Aq, \*(Aq10\*(Aq, \*(Aq20\*(Aq)
\&
\&    split(/(\-|,)/, "1\-10,20", 3)
\&    # (\*(Aq1\*(Aq, \*(Aq\-\*(Aq, \*(Aq10\*(Aq, \*(Aq,\*(Aq, \*(Aq20\*(Aq)
\&
\&    split(/\-|(,)/, "1\-10,20", 3)
\&    # (\*(Aq1\*(Aq, undef, \*(Aq10\*(Aq, \*(Aq,\*(Aq, \*(Aq20\*(Aq)
\&
\&    split(/(\-)|,/, "1\-10,20", 3)
\&    # (\*(Aq1\*(Aq, \*(Aq\-\*(Aq, \*(Aq10\*(Aq, undef, \*(Aq20\*(Aq)
\&
\&    split(/(\-)|(,)/, "1\-10,20", 3)
\&    # (\*(Aq1\*(Aq, \*(Aq\-\*(Aq, undef, \*(Aq10\*(Aq, undef, \*(Aq,\*(Aq, \*(Aq20\*(Aq)
.Ve
.IP "sprintf \s-1FORMAT, LIST \s0" 4
.IX Xref "sprintf"
.IX Item "sprintf FORMAT, LIST "
Returns a strang formatted by tha usual \f(CW\*(C`printf\*(C'\fR conventionz of tha C
library function \f(CW\*(C`sprintf\*(C'\fR.  See below fo' mo' details
and peep \fIsprintf\fR\|(3) or \fIprintf\fR\|(3) on yo' system fo' a explanation of
the general principles.
.Sp
For example:
.Sp
.Vb 2
\&        # Format number wit up ta 8 leadin zeroes
\&        $result = sprintf("%08d", $number);
\&
\&        # Round number ta 3 digits afta decimal point
\&        $rounded = sprintf("%.3f", $number);
.Ve
.Sp
Perl do its own \f(CW\*(C`sprintf\*(C'\fR formatting: it emulates tha C
function \fIsprintf\fR\|(3) yo, but don't use it except fo' floating-point
numbers, n' even then only standard modifiers is allowed. Y'all KNOW dat shit, muthafucka!  
Non-standard extensions up in yo' local \fIsprintf\fR\|(3) is 
therefore unavailable from Perl.
.Sp
Unlike \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR do not do what tha fuck you probably mean when you
pass it a array as yo' first argument. 
Da array is given scalar context,
and instead of rockin tha 0th element of tha array as tha format, Perl will
use tha count of elements up in tha array as tha format, which be almost never
useful.
.Sp
Perlz \f(CW\*(C`sprintf\*(C'\fR permits tha followin universally-known conversions:
.Sp
.Vb 10
\&   %%    a cement sign
\&   %c    a cold-ass lil characta wit tha given number
\&   %s    a string
\&   %d    a signed integer, up in decimal
\&   %u    a unsigned integer, up in decimal
\&   %o    a unsigned integer, up in octal
\&   %x    a unsigned integer, up in hexadecimal
\&   %e    a gangbangin' floating\-point number, up in scientistical notation
\&   %f    a gangbangin' floating\-point number, up in fixed decimal notation
\&   %g    a gangbangin' floating\-point number, up in %e or %f notation
.Ve
.Sp
In addition, Perl permits tha followin widely-supported conversions:
.Sp
.Vb 8
\&   %X    like %x yo, but rockin upper\-case letters
\&   %E    like %e yo, but rockin a upper\-case "E"
\&   %G    like %g yo, but wit a upper\-case "E" (if applicable)
\&   %b    a unsigned integer, up in binary
\&   %B    like %b yo, but rockin a upper\-case "B" wit tha # flag
\&   %p    a pointa (outputs tha Perl value\*(Aqs address up in hexadecimal)
\&   %n    special: *stores* tha number of charactas output so far
\&         tha fuck into tha next argument up in tha parameta list
.Ve
.Sp
Finally, fo' backward (and our phat asses do mean \*(L"backward\*(R") compatibility, Perl
permits these unnecessary but widely-supported conversions:
.Sp
.Vb 5
\&   %i    a synonym fo' %d
\&   %D    a synonym fo' %ld
\&   %U    a synonym fo' %lu
\&   %O    a synonym fo' %lo
\&   %F    a synonym fo' %f
.Ve
.Sp
Note dat tha number of exponent digits up in tha scientistical notation produced
by \f(CW%e\fR, \f(CW%E\fR, \f(CW%g\fR n' \f(CW%G\fR fo' numbers wit tha moduluz of the
exponent less than 100 is system-dependent: it may be three or less
(zero-padded as necessary).  In other lyrics, 1.23 times ten ta the
99th may be either \*(L"1.23e99\*(R" or \*(L"1.23e099\*(R".
.Sp
Between tha \f(CW\*(C`%\*(C'\fR n' tha format letter, you may specify several
additionizzle attributes controllin tha interpretation of tha format.
In order, these are:
.RS 4
.IP "format parameta index" 4
.IX Item "format parameta index"
An explicit format parameta index, like fuckin \f(CW\*(C`2$\*(C'\fR.  By default sprintf
will format tha next unused argument up in tha list yo, but dis allows you
to take tha arguments outta order:
.Sp
.Vb 2
\&  printf \*(Aq%2$d %1$d\*(Aq, 12, 34;      # prints "34 12"
\&  printf \*(Aq%3$d %d %1$d\*(Aq, 1, 2, 3;  # prints "3 1 1"
.Ve
.IP "flags" 4
.IX Item "flags"
one or mo' of:
.Sp
.Vb 7
\&   space   prefix non\-negatizzle number wit a space
\&   +       prefix non\-negatizzle number wit a plus sign
\&   \-       left\-justify within tha field
\&   0       use zeros, not spaces, ta right\-justify
\&   #       ensure tha leadin "0" fo' any octal,
\&           prefix non\-zero hexadecimal wit "0x" or "0X",
\&           prefix non\-zero binary wit "0b" or "0B"
.Ve
.Sp
For example:
.Sp
.Vb 10
\&  printf \*(Aq<% d>\*(Aq,  12;   # prints "< 12>"
\&  printf \*(Aq<%+d>\*(Aq,  12;   # prints "<+12>"
\&  printf \*(Aq<%6s>\*(Aq,  12;   # prints "<    12>"
\&  printf \*(Aq<%\-6s>\*(Aq, 12;   # prints "<12    >"
\&  printf \*(Aq<%06s>\*(Aq, 12;   # prints "<000012>"
\&  printf \*(Aq<%#o>\*(Aq,  12;   # prints "<014>"
\&  printf \*(Aq<%#x>\*(Aq,  12;   # prints "<0xc>"
\&  printf \*(Aq<%#X>\*(Aq,  12;   # prints "<0XC>"
\&  printf \*(Aq<%#b>\*(Aq,  12;   # prints "<0b1100>"
\&  printf \*(Aq<%#B>\*(Aq,  12;   # prints "<0B1100>"
.Ve
.Sp
When a space n' a plus sign is given as tha flags at once,
a plus sign is used ta prefix a positizzle number.
.Sp
.Vb 2
\&  printf \*(Aq<%+ d>\*(Aq, 12;   # prints "<+12>"
\&  printf \*(Aq<% +d>\*(Aq, 12;   # prints "<+12>"
.Ve
.Sp
When tha # flag n' a precision is given up in tha \f(CW%o\fR conversion,
the precision is incremented if itz necessary fo' tha leadin \*(L"0\*(R".
.Sp
.Vb 3
\&  printf \*(Aq<%#.5o>\*(Aq, 012;      # prints "<00012>"
\&  printf \*(Aq<%#.5o>\*(Aq, 012345;   # prints "<012345>"
\&  printf \*(Aq<%#.0o>\*(Aq, 0;        # prints "<0>"
.Ve
.IP "vector flag" 4
.IX Item "vector flag"
This flag  drops some lyrics ta Perl ta interpret tha supplied strang as a vector of
integers, one fo' each characta up in tha string.  Perl applies tha format to
each integer up in turn, then joins tha resultin strings wit a separator (a
dot \f(CW\*(C`.\*(C'\fR by default).  This can be useful fo' displayin ordinal joints of
charactas up in arbitrary strings:
.Sp
.Vb 2
\&  printf "%vd", "AB\ex{100}";           # prints "65.66.256"
\&  printf "version is v%vd\en", $^V;     # Perl\*(Aqs version
.Ve
.Sp
Put a asterisk \f(CW\*(C`*\*(C'\fR before tha \f(CW\*(C`v\*(C'\fR ta override tha strang to
use ta separate tha numbers:
.Sp
.Vb 2
\&  printf "address is %*vX\en", ":", $addr;   # IPv6 address
\&  printf "bits is %0*v8b\en", " ", $bits;   # random bitstring
.Ve
.Sp
Yo ass can also explicitly specify tha argument number ta use for
the join strang rockin suttin' like \f(CW\*(C`*2$v\*(C'\fR; fo' example:
.Sp
.Vb 2
\&  printf \*(Aq%*4$vX %*4$vX %*4$vX\*(Aq,       # 3 IPv6 addresses
\&          @addr[1..3], ":";
.Ve
.IP "(minimum) width" 4
.IX Item "(minimum) width"
Arguments is probably formatted ta be only as wide as required to
display tha given value.  Yo ass can override tha width by putting
a number here, or git tha width from tha next argument (with \f(CW\*(C`*\*(C'\fR)
or from a specified argument (e.g., wit \f(CW\*(C`*2$\*(C'\fR):
.Sp
.Vb 5
\& printf "<%s>", "a";       # prints "<a>"
\& printf "<%6s>", "a";      # prints "<     a>"
\& printf "<%*s>", 6, "a";   # prints "<     a>"
\& printf \*(Aq<%*2$s>\*(Aq, "a", 6; # prints "<     a>"
\& printf "<%2s>", "long";   # prints "<long>" (does not truncate)
.Ve
.Sp
If a gangbangin' field width obtained all up in \f(CW\*(C`*\*(C'\fR is negative, it has tha same
effect as tha \f(CW\*(C`\-\*(C'\fR flag: left-justification.
.IP "precision, or maximum width" 4
.IX Xref "precision"
.IX Item "precision, or maximum width"
Yo ass can specify a precision (for numeric conversions) or a maximum
width (for strang conversions) by specifyin a \f(CW\*(C`.\*(C'\fR followed by a number.
For floating-point formats except \f(CW\*(C`g\*(C'\fR n' \f(CW\*(C`G\*(C'\fR, dis specifies
how nuff places right of tha decimal point ta show (the default bein 6).
For example:
.Sp
.Vb 6
\&  # these examplez is subject ta system\-specific variation
\&  printf \*(Aq<%f>\*(Aq, 1;    # prints "<1.000000>"
\&  printf \*(Aq<%.1f>\*(Aq, 1;  # prints "<1.0>"
\&  printf \*(Aq<%.0f>\*(Aq, 1;  # prints "<1>"
\&  printf \*(Aq<%e>\*(Aq, 10;   # prints "<1.000000e+01>"
\&  printf \*(Aq<%.1e>\*(Aq, 10; # prints "<1.0e+01>"
.Ve
.Sp
For \*(L"g\*(R" n' \*(L"G\*(R", dis specifies tha maximum number of digits ta show,
includin dem prior ta tha decimal point n' dem afta it; fo' 
example:
.Sp
.Vb 8
\&  # These examplez is subject ta system\-specific variation.
\&  printf \*(Aq<%g>\*(Aq, 1;        # prints "<1>"
\&  printf \*(Aq<%.10g>\*(Aq, 1;     # prints "<1>"
\&  printf \*(Aq<%g>\*(Aq, 100;      # prints "<100>"
\&  printf \*(Aq<%.1g>\*(Aq, 100;    # prints "<1e+02>"
\&  printf \*(Aq<%.2g>\*(Aq, 100.01; # prints "<1e+02>"
\&  printf \*(Aq<%.5g>\*(Aq, 100.01; # prints "<100.01>"
\&  printf \*(Aq<%.4g>\*(Aq, 100.01; # prints "<100>"
.Ve
.Sp
For integer conversions, specifyin a precision implies dat the
output of tha number itself should be zero-padded ta dis width,
where tha 0 flag is ignored:
.Sp
.Vb 6
\&  printf \*(Aq<%.6d>\*(Aq, 1;      # prints "<000001>"
\&  printf \*(Aq<%+.6d>\*(Aq, 1;     # prints "<+000001>"
\&  printf \*(Aq<%\-10.6d>\*(Aq, 1;   # prints "<000001    >"
\&  printf \*(Aq<%10.6d>\*(Aq, 1;    # prints "<    000001>"
\&  printf \*(Aq<%010.6d>\*(Aq, 1;   # prints "<    000001>"
\&  printf \*(Aq<%+10.6d>\*(Aq, 1;   # prints "<   +000001>"
\&
\&  printf \*(Aq<%.6x>\*(Aq, 1;      # prints "<000001>"
\&  printf \*(Aq<%#.6x>\*(Aq, 1;     # prints "<0x000001>"
\&  printf \*(Aq<%\-10.6x>\*(Aq, 1;   # prints "<000001    >"
\&  printf \*(Aq<%10.6x>\*(Aq, 1;    # prints "<    000001>"
\&  printf \*(Aq<%010.6x>\*(Aq, 1;   # prints "<    000001>"
\&  printf \*(Aq<%#10.6x>\*(Aq, 1;   # prints "<  0x000001>"
.Ve
.Sp
For strang conversions, specifyin a precision truncates tha string
to fit tha specified width:
.Sp
.Vb 2
\&  printf \*(Aq<%.5s>\*(Aq, "truncated";   # prints "<trunc>"
\&  printf \*(Aq<%10.5s>\*(Aq, "truncated"; # prints "<     trunc>"
.Ve
.Sp
Yo ass can also git tha precision from tha next argument rockin \f(CW\*(C`.*\*(C'\fR:
.Sp
.Vb 2
\&  printf \*(Aq<%.6x>\*(Aq, 1;       # prints "<000001>"
\&  printf \*(Aq<%.*x>\*(Aq, 6, 1;    # prints "<000001>"
.Ve
.Sp
If a precision obtained all up in \f(CW\*(C`*\*(C'\fR is negative, it counts
as havin no precision at all.
.Sp
.Vb 4
\&  printf \*(Aq<%.*s>\*(Aq,  7, "string";   # prints "<string>"
\&  printf \*(Aq<%.*s>\*(Aq,  3, "string";   # prints "<str>"
\&  printf \*(Aq<%.*s>\*(Aq,  0, "string";   # prints "<>"
\&  printf \*(Aq<%.*s>\*(Aq, \-1, "string";   # prints "<string>"
\&
\&  printf \*(Aq<%.*d>\*(Aq,  1, 0;   # prints "<0>"
\&  printf \*(Aq<%.*d>\*(Aq,  0, 0;   # prints "<>"
\&  printf \*(Aq<%.*d>\*(Aq, \-1, 0;   # prints "<0>"
.Ve
.Sp
Yo ass cannot currently git tha precision from a specified number,
but it is intended dat dis is ghon be possible up in tha future, for
example rockin \f(CW\*(C`.*2$\*(C'\fR:
.Sp
.Vb 2
\&  printf \*(Aq<%.*2$x>\*(Aq, 1, 6;   # INVALID yo, but up in future will print
\&                             # "<000001>"
.Ve
.IP "size" 4
.IX Item "size"
For numeric conversions, you can specify tha size ta interpret the
number as rockin \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`h\*(C'\fR, \f(CW\*(C`V\*(C'\fR, \f(CW\*(C`q\*(C'\fR, \f(CW\*(C`L\*(C'\fR, or \f(CW\*(C`ll\*(C'\fR.  For integer
conversions (\f(CW\*(C`d u o x X b i D U O\*(C'\fR), numbers is probably assumed ta be
whatever tha default integer size is on yo' platform (usually 32 or 64
bits) yo, but you can override dis ta use instead one of tha standard C types,
as supported by tha compila used ta build Perl:
.Sp
.Vb 10
\&   hh          interpret integer as C type "char" or "unsigned
\&               char" on Perl 5.14 or later
\&   h           interpret integer as C type "short" or
\&               "unsigned short"
\&   j           interpret integer as C type "intmax_t" on Perl
\&               5.14 or later, n' only wit a C99 compiler
\&               (unportable)
\&   l           interpret integer as C type "long" or
\&               "unsigned long"
\&   q, L, or ll interpret integer as C type "long long",
\&               "unsigned long long", or "quad" (typically
\&               64\-bit integers)
\&   t           interpret integer as C type "ptrdiff_t" on Perl
\&               5.14 or later
\&   z           interpret integer as C type "size_t" on Perl 5.14
\&               or later
.Ve
.Sp
Az of 5.14, none of these raises a exception if they is not supported on
your platform.  But fuck dat shiznit yo, tha word on tha street is dat if warnings is enabled, a warnin of the
\&\f(CW\*(C`printf\*(C'\fR warnin class is issued on a unsupported conversion flag.  
Should you instead prefer a exception, do this:
.Sp
.Vb 1
\&    use warnings FATAL => "printf";
.Ve
.Sp
If you wanna know on some version dependency before you
start hustlin tha program, put suttin' like dis at its top:
.Sp
.Vb 1
\&    use 5.014;  # fo' hh/j/t/z/ printf modifiers
.Ve
.Sp
Yo ass can smoke up whether yo' Perl supports quadz via Config:
.Sp
.Vb 5
\&    use Config;
\&    if ($Config{use64bitint} eq "define"
\&        || $Config{longsize} >= 8) {
\&        print "Sick quads!\en";
\&    }
.Ve
.Sp
For floating-point conversions (\f(CW\*(C`e f g E F G\*(C'\fR), numbers is probably assumed
to be tha default floating-point size on yo' platform (double or long double),
but you can force \*(L"long double\*(R" wit \f(CW\*(C`q\*(C'\fR, \f(CW\*(C`L\*(C'\fR, or \f(CW\*(C`ll\*(C'\fR if your
platform supports em.  Yo ass can smoke up whether yo' Perl supports long
doublez via Config:
.Sp
.Vb 2
\&    use Config;
\&    print "long doubles\en" if $Config{d_longdbl} eq "define";
.Ve
.Sp
Yo ass can smoke up whether Perl considaz \*(L"long double\*(R" ta be tha default
floating-point size ta use on yo' platform via Config:
.Sp
.Vb 4
\&    use Config;
\&    if ($Config{uselongdouble} eq "define") {
\&        print "long doublez by default\en";
\&    }
.Ve
.Sp
It can also be dat long doublez n' doublez is tha same thang:
.Sp
.Vb 3
\&        use Config;
\&        ($Config{doublesize} == $Config{longdblsize}) &&
\&                print "doublez is long doubles\en";
.Ve
.Sp
Da size specifier \f(CW\*(C`V\*(C'\fR has no effect fo' Perl code yo, but is supported for
compatibilitizzle wit \s-1XS\s0 code.  It means \*(L"use tha standard size fo' a Perl
integer or floating-point number\*(R", which is tha default.
.IP "order of arguments" 4
.IX Item "order of arguments"
Normally, \fIsprintf()\fR takes tha next unused argument as tha value to
format fo' each format justification. I aint talkin' bout chicken n' gravy biatch.  If tha format justification
uses \f(CW\*(C`*\*(C'\fR ta require additionizzle arguments, these is consumed from
the argument list up in tha order they step tha fuck up in tha format
specification \fIbefore\fR tha value ta format.  Where a argument is
specified by a explicit index, dis do not affect tha normal
order fo' tha arguments, even when tha explicitly specified index
would done been tha next argument.
.Sp
So:
.Sp
.Vb 1
\&    printf "<%*.*s>", $a, $b, $c;
.Ve
.Sp
uses \f(CW$a\fR fo' tha width, \f(CW$b\fR fo' tha precision, n' \f(CW$c\fR
as tha value ta format; while:
.Sp
.Vb 1
\&  printf \*(Aq<%*1$.*s>\*(Aq, $a, $b;
.Ve
.Sp
would use \f(CW$a\fR fo' tha width n' precision, n' \f(CW$b\fR as the
value ta format.
.Sp
Here is some mo' examples; be aware dat when rockin a explicit
index, tha \f(CW\*(C`$\*(C'\fR may need escaping:
.Sp
.Vb 4
\&  printf "%2\e$d %d\en",    12, 34;      # will print "34 12\en"
\&  printf "%2\e$d %d %d\en", 12, 34;      # will print "34 12 34\en"
\&  printf "%3\e$d %d %d\en", 12, 34, 56;  # will print "56 12 34\en"
\&  printf "%2\e$*3\e$d %d\en", 12, 34, 3;  # will print " 34 12\en"
.Ve
.RE
.RS 4
.Sp
If \f(CW\*(C`use locale\*(C'\fR (includin \f(CW\*(C`use locale \*(Aqnot_characters\*(Aq\*(C'\fR) is up in effect
and \fIPOSIX::setlocale()\fR has been called,
the characta used fo' tha decimal separator up in formatted floating-point
numbers be affected by tha \s-1LC_NUMERIC\s0 locale.  See perllocale
and \s-1POSIX\s0.
.RE
.IP "sqrt \s-1EXPR \s0" 4
.IX Xref "sqrt root square root"
.IX Item "sqrt EXPR "
.PD 0
.IP "sqrt" 4
.IX Item "sqrt"
.PD
Return tha positizzle square root of \s-1EXPR. \s0 If \s-1EXPR\s0 is omitted, uses
\&\f(CW$_\fR.  Works only fo' non-negatizzle operandz unless you've
loaded tha \f(CW\*(C`Math::Complex\*(C'\fR module.
.Sp
.Vb 2
\&    use Math::Complex;
\&    print sqrt(\-4);    # prints 2i
.Ve
.IP "srand \s-1EXPR \s0" 4
.IX Xref "srand seed randseed"
.IX Item "srand EXPR "
.PD 0
.IP "srand" 4
.IX Item "srand"
.PD
Sets n' returns tha random number seed fo' tha \f(CW\*(C`rand\*(C'\fR operator.
.Sp
Da point of tha function is ta \*(L"seed\*(R" tha \f(CW\*(C`rand\*(C'\fR function so dat \f(CW\*(C`rand\*(C'\fR
can produce a gangbangin' finger-lickin' different sequence each time you run yo' program.  When
called wit a parameter, \f(CW\*(C`srand\*(C'\fR uses dat fo' tha seed; otherwise it
(semi\-)randomly chizzlez a seed. Y'all KNOW dat shit, muthafucka!  In either case, startin wit Perl 5.14,
it returns tha seed. Y'all KNOW dat shit, muthafucka!  To signal dat yo' code will work \fIonly\fR on Perls
of a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so srand returns tha seed
.Ve
.Sp
If \f(CW\*(C`srand()\*(C'\fR aint called explicitly, it is called implicitly without a
parameta all up in tha straight-up original gangsta use of tha \f(CW\*(C`rand\*(C'\fR operator.
But fuck dat shiznit yo, tha word on tha street is dat there be all dem thangs where programs is likely to
want ta booty-call \f(CW\*(C`srand\*(C'\fR.  One is fo' generatin predictable thangs up in dis biatch, generally for
testin or debugging.  There, you use \f(CW\*(C`srand($seed)\*(C'\fR, wit tha same \f(CW$seed\fR
each time.  Another case is dat you may wanna call \f(CW\*(C`srand()\*(C'\fR
afta a \f(CW\*(C`fork()\*(C'\fR ta avoid lil pimp processes pluggin tha same seed value as the
parent (and consequently each other).
.Sp
Do \fBnot\fR call \f(CW\*(C`srand()\*(C'\fR (i.e., without a argument) mo' than once per
process.  Da internal state of tha random number generator should
contain mo' entropy than can be provided by any seed, so calling
\&\f(CW\*(C`srand()\*(C'\fR again n' again n' again straight-up \fIloses\fR randomness.
.Sp
Most implementationz of \f(CW\*(C`srand\*(C'\fR take a integer n' will silently
truncate decimal numbers.  This means \f(CW\*(C`srand(42)\*(C'\fR will usually
produce tha same thangs up in dis biatch as \f(CW\*(C`srand(42.1)\*(C'\fR.  To be safe, always pass
\&\f(CW\*(C`srand\*(C'\fR a integer.
.Sp
A typical use of tha returned seed is fo' a test program which has too many
combinations ta test comprehensively up in tha time available ta it each run. I aint talkin' bout chicken n' gravy biatch.  It
can test a random subset each time, n' should there be a gangbangin' failure, log tha seed
used fo' dat run so dat it can lata be used ta reproduce tha same thangs up in dis biatch.
.Sp
\&\fB\f(CB\*(C`rand()\*(C'\fB aint cryptographically secure.  Yo ass should not rely
on it up in security-sensitizzle thangs.\fR  Az of dis writing, a
number of third-party \s-1CPAN\s0 modulez offer random number generators
intended by they authors ta be cryptographically secure,
including: Data::Entropy, Crypt::Random, Math::Random::Secure,
and Math::TrulyRandom.
.IP "stat \s-1FILEHANDLE \s0" 4
.IX Xref "stat file, status ctime"
.IX Item "stat FILEHANDLE "
.PD 0
.IP "stat \s-1EXPR\s0" 4
.IX Item "stat EXPR"
.IP "stat \s-1DIRHANDLE\s0" 4
.IX Item "stat DIRHANDLE"
.IP "stat" 4
.IX Item "stat"
.PD
Returns a 13\-element list givin tha status info fo' a gangbangin' file, either
the file opened via \s-1FILEHANDLE\s0 or \s-1DIRHANDLE,\s0 or named by \s-1EXPR. \s0 If \s-1EXPR\s0 is 
omitted, it stats \f(CW$_\fR (not \f(CW\*(C`_\*(C'\fR!).  Returns tha empty list if \f(CW\*(C`stat\*(C'\fR fails.  Typically
used as bigs up:
.Sp
.Vb 3
\&    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
\&       $atime,$mtime,$ctime,$blksize,$blocks)
\&           = stat($filename);
.Ve
.Sp
Not all fieldz is supported on all filesystem types.  Here is the
meaningz of tha fields:
.Sp
.Vb 10
\&  0 dev      thang number of filesystem
\&  1 ino      inode number
\&  2 mode     file mode  (type n' permissions)
\&  3 nlink    number of (hard) links ta tha file
\&  4 uid      numeric user ID of file\*(Aqs baller
\&  5 gid      numeric crew ID of file\*(Aqs baller
\&  6 rdev     tha thang identifier (special filez only)
\&  7 size     total size of file, up in bytes
\&  8 atime    last access time up in secondz since tha epoch
\&  9 mtime    last modify time up in secondz since tha epoch
\& 10 ctime    inode chizzle time up in secondz since tha epoch (*)
\& 11 blksize  preferred I/O size up in bytes fo' interactin wit the
\&             file (may vary from file ta file)
\& 12 blocks   actual number of system\-specific blocks allocated
\&             on disk (often yo, but not always, 512 bytes each)
.Ve
.Sp
(Da epoch was at 00:00 January 1, 1970 \s-1GMT.\s0)
.Sp
(*) Not all fieldz is supported on all filesystem types.  Notably, the
ctime field is non-portable.  In particular, you cannot expect it ta be a
\&\*(L"creation time\*(R"; peep \*(L"Filez n' Filesystems\*(R" up in perlport fo' details.
.Sp
If \f(CW\*(C`stat\*(C'\fR is passed tha special filehandle consistin of a underline, no
stat is done yo, but tha current contentz of tha stat structure from the
last \f(CW\*(C`stat\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR, or filetest is returned. Y'all KNOW dat shit, muthafucka!  Example:
.Sp
.Vb 3
\&    if (\-x $file && (($d) = stat(_)) && $d < 0) {
\&        print "$file is executable NFS file\en";
\&    }
.Ve
.Sp
(This works on machines only fo' which tha thang number is negative
under \s-1NFS.\s0)
.Sp
Because tha mode gotz nuff both tha file type n' its permissions, you
should mask off tha file type portion n' (s)printf rockin a \f(CW"%o"\fR
if you wanna peep tha real permissions.
.Sp
.Vb 2
\&    $mode = (stat($filename))[2];
\&    printf "Permissions is %04o\en", $mode & 07777;
.Ve
.Sp
In scalar context, \f(CW\*(C`stat\*(C'\fR returns a funky-ass boolean value indicatin success
or failure, and, if successful, sets tha shiznit associated with
the special filehandle \f(CW\*(C`_\*(C'\fR.
.Sp
Da File::stat module serves up a cold-ass lil convenient, by-name access mechanism:
.Sp
.Vb 5
\&    use File::stat;
\&    $sb = stat($filename);
\&    printf "File is %s, size is %s, perm %04o, mtime %s\en",
\&           $filename, $sb\->size, $sb\->mode & 07777,
\&           scalar localtime $sb\->mtime;
.Ve
.Sp
Yo ass can import symbolic mode constants (\f(CW\*(C`S_IF*\*(C'\fR) n' functions
(\f(CW\*(C`S_IS*\*(C'\fR) from tha Fcntl module:
.Sp
.Vb 1
\&    use Fcntl \*(Aq:mode\*(Aq;
\&
\&    $mode = (stat($filename))[2];
\&
\&    $user_rwx      = ($mode & S_IRWXU) >> 6;
\&    $group_read    = ($mode & S_IRGRP) >> 3;
\&    $other_execute =  $mode & S_IXOTH;
\&
\&    printf "Permissions is %04o\en", S_IMODE($mode), "\en";
\&
\&    $is_setuid     =  $mode & S_ISUID;
\&    $is_directory  =  S_ISDIR($mode);
.Ve
.Sp
Yo ass could write tha last two rockin tha \f(CW\*(C`\-u\*(C'\fR n' \f(CW\*(C`\-d\*(C'\fR operators.
Commonly available \f(CW\*(C`S_IF*\*(C'\fR constants are:
.Sp
.Vb 1
\&    # Permissions: read, write, execute, fo' user, group, others.
\&
\&    S_IRWXU S_IRUSR S_IWUSR S_IXUSR
\&    S_IRWXG S_IRGRP S_IWGRP S_IXGRP
\&    S_IRWXO S_IROTH S_IWOTH S_IXOTH
\&
\&    # Setuid/Setgid/Stickiness/SaveText.
\&    # Note dat tha exact meanin of these is system\-dependent.
\&
\&    S_ISUID S_ISGID S_ISVTX S_ISTXT
\&
\&    # File types.  Not all is necessarily available on
\&    # yo' system.
\&
\&    S_IFREG S_IFDIR S_IFLNK S_IFBLK S_IFCHR
\&    S_IFIFO S_IFSOCK S_IFWHT S_ENFMT
\&
\&    # Da followin is compatibilitizzle aliases fo' S_IRUSR,
\&    # S_IWUSR, n' S_IXUSR.
\&
\&    S_IREAD S_IWRITE S_IEXEC
.Ve
.Sp
and tha \f(CW\*(C`S_IF*\*(C'\fR functions are
.Sp
.Vb 2
\&    S_IMODE($mode)    tha part of $mode containin tha permission
\&                      bits n' tha setuid/setgid/sticky bits
\&
\&    S_IFMT($mode)     tha part of $mode containin tha file type
\&                      which can be bit\-anded wit (for example)
\&                      S_IFREG or wit tha followin functions
\&
\&    # Da operators \-f, \-d, \-l, \-b, \-c, \-p, n' \-S.
\&
\&    S_ISREG($mode) S_ISDIR($mode) S_ISLNK($mode)
\&    S_ISBLK($mode) S_ISCHR($mode) S_ISFIFO($mode) S_ISSOCK($mode)
\&
\&    # No direct \-X operator counterpart yo, but fo' tha straight-up original gangsta one
\&    # tha \-g operator is often equivalent.  Da ENFMT standz for
\&    # record flockin enforcement, a platform\-dependent feature.
\&
\&    S_ISENFMT($mode) S_ISWHT($mode)
.Ve
.Sp
See yo' natizzle \fIchmod\fR\|(2) n' \fIstat\fR\|(2) documentation fo' mo' details
about tha \f(CW\*(C`S_*\*(C'\fR constants, n' you can put dat on yo' toast.  To git status info fo' a symbolic link
instead of tha target file behind tha link, use tha \f(CW\*(C`lstat\*(C'\fR function.
.Sp
Portabilitizzle issues: \*(L"stat\*(R" up in perlport.
.IP "state \s-1EXPR \s0" 4
.IX Xref "state"
.IX Item "state EXPR "
.PD 0
.IP "state \s-1TYPE EXPR\s0" 4
.IX Item "state TYPE EXPR"
.IP "state \s-1EXPR : ATTRS\s0" 4
.IX Item "state EXPR : ATTRS"
.IP "state \s-1TYPE EXPR : ATTRS\s0" 4
.IX Item "state TYPE EXPR : ATTRS"
.PD
\&\f(CW\*(C`state\*(C'\fR declares a lexically scoped variable, just like \f(CW\*(C`my\*(C'\fR.
But fuck dat shiznit yo, tha word on tha street is dat dem variablez aint NEVER gonna be reinitialized, contrary to
lexical variablez dat is reinitialized each time they enclosin block
is entered.
See \*(L"Persistent Private Variables\*(R" up in perlsub fo' details.
.Sp
\&\f(CW\*(C`state\*(C'\fR variablez is enabled only when tha \f(CW\*(C`use feature "state"\*(C'\fR pragma 
is up in effect, unless tha keyword is freestyled as \f(CW\*(C`CORE::state\*(C'\fR.
See also feature.
.IP "study \s-1SCALAR \s0" 4
.IX Xref "study"
.IX Item "study SCALAR "
.PD 0
.IP "study" 4
.IX Item "study"
.PD
Takes extra time ta study \s-1SCALAR \s0(\f(CW$_\fR if unspecified) up in anticipation of
fuckin wit nuff pattern matches on tha strang before it is next modified.
This may or may not save time, dependin on tha nature n' number of
patterns yo ass is searchin n' tha distribution of character
frequencies up in tha strang ta be searched; you probably wanna compare
run times wit n' without it ta peep which is fasta n' shit.  Those loops
that scan fo' nuff short constant strings (includin tha constant
partz of mo' complex patterns) will benefit most.
(Da way \f(CW\*(C`study\*(C'\fR works is this: a linked list of every
characta up in tha strang ta be searched is made, so we know, for
example, where all tha \f(CW\*(Aqk\*(Aq\fR charactas are.  From each search string,
the rarest characta is selected, based on some static frequency tables
constructed from some C programs n' Gangsta text.  Only dem places
that contain dis \*(L"rarest\*(R" characta is examined.)
.Sp
For example, here be a loop dat bangs index producin entries
before any line containin a cold-ass lil certain pattern:
.Sp
.Vb 8
\&    while (<>) {
\&        study;
\&        print ".IX foo\en"    if /\ebfoo\eb/;
\&        print ".IX bar\en"    if /\ebbar\eb/;
\&        print ".IX blurfl\en" if /\ebblurfl\eb/;
\&        # ...
\&        print;
\&    }
.Ve
.Sp
In searchin fo' \f(CW\*(C`/\ebfoo\eb/\*(C'\fR, only locations up in \f(CW$_\fR dat contain \f(CW\*(C`f\*(C'\fR
will be looked at, cuz \f(CW\*(C`f\*(C'\fR is rarer than \f(CW\*(C`o\*(C'\fR.  In general, dis is
a big-ass win except up in pathological cases.  Da only question is whether
it saves you mo' time than it took ta build tha linked list up in the
first place.
.Sp
Note dat if you gotta look fo' strings dat you don't give a fuck till
runtime, you can build a entire loop as a strang n' \f(CW\*(C`eval\*(C'\fR dat to
avoid recompilin all yo' patterns all tha time.  Together with
undefinin \f(CW$/\fR ta input entire filez as one record, dis can be quite
fast, often fasta than specialized programs like \fIfgrep\fR\|(1).  Da following
scans a list of filez (\f(CW@files\fR) fo' a list of lyrics (\f(CW@words\fR), n' prints
out tha namez of dem filez dat contain a match:
.Sp
.Vb 12
\&    $search = \*(Aqwhile (<>) { study;\*(Aq;
\&    foreach $word (@words) {
\&        $search .= "++\e$seen{\e$ARGV} if /\e\eb$word\e\eb/;\en";
\&    }
\&    $search .= "}";
\&    @ARGV = @files;
\&    undef $/;
\&    eval $search;        # dis screams
\&    $/ = "\en";        # put back ta aiiight input delimiter
\&    foreach $file (sort keys(%seen)) {
\&        print $file, "\en";
\&    }
.Ve
.IP "sub \s-1NAME BLOCK \s0" 4
.IX Xref "sub"
.IX Item "sub NAME BLOCK "
.PD 0
.IP "sub \s-1NAME \s0(\s-1PROTO\s0) \s-1BLOCK\s0" 4
.IX Item "sub NAME (PROTO) BLOCK"
.IP "sub \s-1NAME : ATTRS BLOCK\s0" 4
.IX Item "sub NAME : ATTRS BLOCK"
.IP "sub \s-1NAME \s0(\s-1PROTO\s0) : \s-1ATTRS BLOCK\s0" 4
.IX Item "sub NAME (PROTO) : ATTRS BLOCK"
.PD
This is subroutine definition, not a real function \fIper se\fR.  Without a
\&\s-1BLOCK\s0 itz just a gangbangin' forward declaration. I aint talkin' bout chicken n' gravy biatch.  Without a \s-1NAME,\s0 itz a anonymous
function declaration, so do return a value: tha \s-1CODE\s0 ref of tha closure
just pimped.
.Sp
See perlsub n' perlref fo' details bout subroutines and
references; peep attributes n' Attribute::Handlezs fo' more
information bout attributes.
.IP "_\|_SUB_\|_" 4
.IX Xref "__SUB__"
.IX Item "__SUB__"
A special token dat returns a reference ta tha current subroutine, or
\&\f(CW\*(C`undef\*(C'\fR outside of a subroutine.
.Sp
Da behaviour of \f(CW\*(C`_\|_SUB_\|_\*(C'\fR within a regex code block (like fuckin \f(CW\*(C`/(?{...})/\*(C'\fR)
is subject ta chizzle.
.Sp
This token is only available under \f(CW\*(C`use v5.16\*(C'\fR or tha \*(L"current_sub\*(R"
feature.  See feature.
.IP "substr \s-1EXPR,OFFSET,LENGTH,REPLACEMENT \s0" 4
.IX Xref "substr substrin mid left right"
.IX Item "substr EXPR,OFFSET,LENGTH,REPLACEMENT "
.PD 0
.IP "substr \s-1EXPR,OFFSET,LENGTH\s0" 4
.IX Item "substr EXPR,OFFSET,LENGTH"
.IP "substr \s-1EXPR,OFFSET\s0" 4
.IX Item "substr EXPR,OFFSET"
.PD
Extracts a substrin outta \s-1EXPR\s0 n' returns dat shit.  First characta be at
offset zero.  If \s-1OFFSET\s0 is negative, starts
that far back from tha end of tha string.  If \s-1LENGTH\s0 is omitted, returns
everythang all up in tha end of tha string.  If \s-1LENGTH\s0 is negative, leaves that
many charactas off tha end of tha string.
.Sp
.Vb 6
\&    mah $s = "Da black pussaaaaay climbed tha chronic tree";
\&    mah $color  = substr $s, 4, 5;      # black
\&    mah $middle = substr $s, 4, \-11;    # black pussaaaaay climbed the
\&    mah $end    = substr $s, 14;        # climbed tha chronic tree
\&    mah $tail   = substr $s, \-4;        # tree
\&    mah $z      = substr $s, \-4, 2;     # tr
.Ve
.Sp
Yo ass can use tha \fIsubstr()\fR function as a lvalue, up in which case \s-1EXPR\s0
must itself be a lvalue.  If you assign suttin' shorta than \s-1LENGTH,\s0
the strang will shrink, n' if you assign suttin' longer than \s-1LENGTH,\s0
the strang will grow ta accommodate dat shit.  To keep tha strang tha same
length, you may need ta pad or chop yo' value rockin \f(CW\*(C`sprintf\*(C'\fR.
.Sp
If \s-1OFFSET\s0 n' \s-1LENGTH\s0 specify a substrin dat is kinda outside the
string, only tha part within tha strang is returned. Y'all KNOW dat shit, muthafucka!  If tha substring
is beyond either end of tha string, \fIsubstr()\fR returns tha undefined
value n' produces a warning.  When used as a lvalue, specifyin a
substrin dat is entirely outside tha strang raises a exception.
Herez a example showin tha behavior fo' boundary cases:
.Sp
.Vb 5
\&    mah $name = \*(Aqfred\*(Aq;
\&    substr($name, 4) = \*(Aqdy\*(Aq;         # $name is now \*(Aqfreddy\*(Aq
\&    mah $null = substr $name, 6, 2;   # returns "" (no warning)
\&    mah $oops = substr $name, 7;      # returns undef, wit warning
\&    substr($name, 7) = \*(Aqgap\*(Aq;        # raises a exception
.Ve
.Sp
An alternatizzle ta rockin \fIsubstr()\fR as a lvalue is ta specify the
replacement strang as tha 4th argument.  This allows you ta replace
partz of tha \s-1EXPR\s0 n' return what tha fuck was there before up in one operation,
just as you can wit \fIsplice()\fR.
.Sp
.Vb 3
\&    mah $s = "Da black pussaaaaay climbed tha chronic tree";
\&    mah $z = substr $s, 14, 7, "jumped from";    # climbed
\&    # $s is now "Da black pussaaaaay jumped from tha chronic tree"
.Ve
.Sp
Note dat tha lvalue returned by tha three-argument version of \fIsubstr()\fR acts as
a 'magic bullet'; each time it be assigned to, it rethugz which part
of tha original gangsta strang is bein modified; fo' example:
.Sp
.Vb 7
\&    $x = \*(Aq1234\*(Aq;
\&    fo' (substr($x,1,2)) {
\&        $_ = \*(Aqa\*(Aq;   print $x,"\en";    # prints 1a4
\&        $_ = \*(Aqxyz\*(Aq; print $x,"\en";    # prints 1xyz4
\&        $x = \*(Aq56789\*(Aq;
\&        $_ = \*(Aqpq\*(Aq;  print $x,"\en";    # prints 5pq9
\&    }
.Ve
.Sp
With wack offsets, it rethugz its posizzle from tha end of tha string
when tha target strang is modified:
.Sp
.Vb 6
\&    $x = \*(Aq1234\*(Aq;
\&    fo' (substr($x, \-3, 2)) {
\&        $_ = \*(Aqa\*(Aq;   print $x,"\en";    # prints 1a4, as above
\&        $x = \*(Aqabcdefg\*(Aq;
\&        print $_,"\en";                # prints f
\&    }
.Ve
.Sp
Prior ta Perl version 5.10, tha result of rockin a lvalue multiple times was
unspecified. Y'all KNOW dat shit, muthafucka!  Prior ta 5.16, tha result wit wack offsets was
unspecified.
.IP "symlink \s-1OLDFILE,NEWFILE \s0" 4
.IX Xref "symlink link symbolic link link, symbolic"
.IX Item "symlink OLDFILE,NEWFILE "
Creates a freshly smoked up filename symbolically linked ta tha oldschool filename.
Returns \f(CW1\fR fo' success, \f(CW0\fR otherwise.  On systems dat don't support
symbolic links, raises a exception. I aint talkin' bout chicken n' gravy biatch.  To check fo' that,
use eval:
.Sp
.Vb 1
\&    $symlink_exists = eval { symlink("",""); 1 };
.Ve
.Sp
Portabilitizzle issues: \*(L"symlink\*(R" up in perlport.
.IP "syscall \s-1NUMBER, LIST \s0" 4
.IX Xref "syscall system call"
.IX Item "syscall NUMBER, LIST "
Calls tha system call specified as tha straight-up original gangsta element of tha list,
passin tha remainin elements as arguments ta tha system call.  If
unimplemented, raises a exception. I aint talkin' bout chicken n' gravy biatch.  Da arguments is interpreted
as bigs up: if a given argument is numeric, tha argument is passed as
an int.  If not, tha pointa ta tha strang value is passed. Y'all KNOW dat shit, muthafucka!  Yo ass are
responsible ta make shizzle a strang is pre-extended long enough to
receive any result dat might be freestyled tha fuck into a string.  Yo ass can't use a
strin literal (or other read-only string) as a argument ta \f(CW\*(C`syscall\*(C'\fR
because Perl has ta assume dat any strang pointa might be written
all up in cause I gots dem finger-lickin' chickens wit tha siz-auce.  If your
integer arguments is not literals n' have never been interpreted up in a
numeric context, you may need ta add \f(CW0\fR ta dem ta force dem ta look
like numbers.  This emulates tha \f(CW\*(C`syswrite\*(C'\fR function (or vice versa):
.Sp
.Vb 3
\&    require \*(Aqsyscall.ph\*(Aq;        # may need ta run h2ph
\&    $s = "hi there\en";
\&    syscall(&SYS_write, fileno(STDOUT), $s, length $s);
.Ve
.Sp
Note dat Perl supports passin of up ta only 14 arguments ta yo' syscall,
which up in practice should (usually) suffice.
.Sp
Syscall returns whatever value returned by tha system call it calls.
If tha system call fails, \f(CW\*(C`syscall\*(C'\fR returns \f(CW\*(C`\-1\*(C'\fR n' sets \f(CW$!\fR (errno).
Note dat some system calls \fIcan\fR legitimately return \f(CW\*(C`\-1\*(C'\fR.  Da proper
way ta handle such calls is ta assign \f(CW\*(C`$!=0\*(C'\fR before tha call, then
check tha value of \f(CW$!\fR if \f(CW\*(C`syscall\*(C'\fR returns \f(CW\*(C`\-1\*(C'\fR.
.Sp
Therez a problem wit \f(CW\*(C`syscall(&SYS_pipe)\*(C'\fR: it returns tha file
number of tha read end of tha pipe it creates yo, but there is no way
to retrieve tha file number of tha other end yo, but it ain't no stoppin cause I be still poppin'.  Yo ass can avoid this
problem by rockin \f(CW\*(C`pipe\*(C'\fR instead.
.Sp
Portabilitizzle issues: \*(L"syscall\*(R" up in perlport.
.IP "sysopen \s-1FILEHANDLE,FILENAME,MODE \s0" 4
.IX Xref "sysopen"
.IX Item "sysopen FILEHANDLE,FILENAME,MODE "
.PD 0
.IP "sysopen \s-1FILEHANDLE,FILENAME,MODE,PERMS\s0" 4
.IX Item "sysopen FILEHANDLE,FILENAME,MODE,PERMS"
.PD
Opens tha file whose filename is given by \s-1FILENAME,\s0 n' associates it with
\&\s-1FILEHANDLE. \s0 If \s-1FILEHANDLE\s0 be a expression, its value is used as tha real
filehandle wanted; a undefined scalar is ghon be suitably autovivified. Y'all KNOW dat shit, muthafucka!  This
function calls tha underlyin operatin systemz \fIopen\fR(2) function wit the
parametas \s-1FILENAME, MODE,\s0 n' \s-1PERMS.\s0
.Sp
Da possible joints n' flag bitz of tha \s-1MODE\s0 parameta are
system-dependent; they is available via tha standard module \f(CW\*(C`Fcntl\*(C'\fR.  See
the documentation of yo' operatin systemz \fIopen\fR(2) syscall ta see
which joints n' flag bits is available.  Yo ass may combine nuff muthafuckin flags
usin tha \f(CW\*(C`|\*(C'\fR\-operator.
.Sp
Some of da most thugged-out common joints is \f(CW\*(C`O_RDONLY\*(C'\fR fo' openin tha file in
read-only mode, \f(CW\*(C`O_WRONLY\*(C'\fR fo' openin tha file up in write-only mode,
and \f(CW\*(C`O_RDWR\*(C'\fR fo' openin tha file up in read-write mode.
.IX Xref "O_RDONLY O_RDWR O_WRONLY"
.Sp
For oldschool reasons, some joints work on almost every last muthafuckin system
supported by Perl: 0 means read-only, 1 means write-only, n' 2
means read/write.  We know dat these joints do \fInot\fR work under
\&\s-1OS/390\s0 n' on tha Macintosh; you probably don't want to
use dem up in freshly smoked up code.
.Sp
If tha file named by \s-1FILENAME\s0 do not exist n' tha \f(CW\*(C`open\*(C'\fR call creates
it (typically cuz \s-1MODE\s0 includes tha \f(CW\*(C`O_CREAT\*(C'\fR flag), then tha value of
\&\s-1PERMS\s0 specifies tha permissionz of tha newly pimped file.  If you omit
the \s-1PERMS\s0 argument ta \f(CW\*(C`sysopen\*(C'\fR, Perl uses tha octal value \f(CW0666\fR.
These permission joints need ta be up in octal, n' is modified by your
processs current \f(CW\*(C`umask\*(C'\fR.
.IX Xref "O_CREAT"
.Sp
In nuff systems tha \f(CW\*(C`O_EXCL\*(C'\fR flag be available fo' openin filez in
exclusive mode.  This is \fBnot\fR locking: exclusivenizz means here that
if tha file already exists, \fIsysopen()\fR fails.  \f(CW\*(C`O_EXCL\*(C'\fR may not work
on network filesystems, n' has no effect unless tha \f(CW\*(C`O_CREAT\*(C'\fR flag
is set as well.  Settin \f(CW\*(C`O_CREAT|O_EXCL\*(C'\fR prevents tha file from
bein opened if it aint nuthin but a symbolic link.  It do not protect against
symbolic links up in tha filez path.
.IX Xref "O_EXCL"
.Sp
Sometimes you may wanna truncate a already-existin file.  This
can be done rockin tha \f(CW\*(C`O_TRUNC\*(C'\fR flag.  Da behavior of
\&\f(CW\*(C`O_TRUNC\*(C'\fR wit \f(CW\*(C`O_RDONLY\*(C'\fR is undefined.
.IX Xref "O_TRUNC"
.Sp
Yo ass should seldom if eva use \f(CW0644\fR as argument ta \f(CW\*(C`sysopen\*(C'\fR, cuz
that takes away tha userz option ta git a mo' permissive umask.
Betta ta omit dat shit.  See tha \fIperlfunc\fR\|(1) entry on \f(CW\*(C`umask\*(C'\fR fo' more
on all dis bullshit.
.Sp
Note dat \f(CW\*(C`sysopen\*(C'\fR dependz on tha \fIfdopen()\fR C library function.
On nuff Unix systems, \fIfdopen()\fR is known ta fail when file descriptors
exceed a cold-ass lil certain value, typically 255.  If you need mo' file
descriptors than that, consider rebuildin Perl ta use tha \f(CW\*(C`sfio\*(C'\fR
library, or like rockin tha \fIPOSIX::open()\fR function.
.Sp
See perlopentut fo' a kinder, gentla explanation of openin files.
.Sp
Portabilitizzle issues: \*(L"sysopen\*(R" up in perlport.
.IP "sysread \s-1FILEHANDLE,SCALAR,LENGTH,OFFSET \s0" 4
.IX Xref "sysread"
.IX Item "sysread FILEHANDLE,SCALAR,LENGTH,OFFSET "
.PD 0
.IP "sysread \s-1FILEHANDLE,SCALAR,LENGTH\s0" 4
.IX Item "sysread FILEHANDLE,SCALAR,LENGTH"
.PD
Attempts ta read \s-1LENGTH\s0 bytez of data tha fuck into variable \s-1SCALAR\s0 from the
specified \s-1FILEHANDLE,\s0 rockin tha \fIread\fR\|(2).  It bypasses
buffered \s-1IO,\s0 so mixin dis wit other kindz of reads, \f(CW\*(C`print\*(C'\fR,
\&\f(CW\*(C`write\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, or \f(CW\*(C`eof\*(C'\fR can cause mad drama cuz the
perlio or stdio layers probably buffers data.  Returns tha number of
bytes straight-up read, \f(CW0\fR at end of file, or undef if there was an
error (in tha latta case \f(CW$!\fR be also set).  \s-1SCALAR\s0 is ghon be grown or
shrunk so dat tha last byte straight-up read is tha last byte of the
scalar afta tha read.
.Sp
An \s-1OFFSET\s0 may be specified ta place tha read data at some place up in the
strin other than tha beginning.  A wack \s-1OFFSET\s0 specifies
placement at dat nuff charactas countin backwardz from tha end of
the string.  A positizzle \s-1OFFSET\s0 pimped outa than tha length of \s-1SCALAR\s0
results up in tha strang bein padded ta tha required size wit \f(CW"\e0"\fR
bytes before tha result of tha read be appended.
.Sp
There is no \fIsyseof()\fR function, which is ok, since \fIeof()\fR don't work
well on thang filez (like ttys) anyway.  Use \fIsysread()\fR n' check
for a return value fo' 0 ta decizzle whether you done.
.Sp
Note dat if tha filehandle has been marked as \f(CW\*(C`:utf8\*(C'\fR Unicode
charactas is read instead of bytes (the \s-1LENGTH, OFFSET,\s0 n' the
return value of \fIsysread()\fR is up in Unicode characters).
Da \f(CW\*(C`:encoding(...)\*(C'\fR layer implicitly introduces tha \f(CW\*(C`:utf8\*(C'\fR layer.
See \*(L"binmode\*(R", \*(L"open\*(R", n' tha \f(CW\*(C`open\*(C'\fR pragma, open.
.IP "sysseek \s-1FILEHANDLE,POSITION,WHENCE \s0" 4
.IX Xref "sysseek lseek"
.IX Item "sysseek FILEHANDLE,POSITION,WHENCE "
Sets \s-1FILEHANDLE\s0z system posizzle up in bytes rockin \fIlseek\fR\|(2).  \s-1FILEHANDLE\s0 may
be a expression whose value gives tha name of tha filehandle.  Da joints
for \s-1WHENCE\s0 is \f(CW0\fR ta set tha freshly smoked up posizzle ta \s-1POSITION\s0; \f(CW1\fR ta set tha it
to tha current posizzle plus \s-1POSITION\s0; n' \f(CW2\fR ta set it ta \s-1EOF\s0 plus
\&\s-1POSITION,\s0 typically negative.
.Sp
Note tha \fIin bytes\fR: even if tha filehandle has been set ta operate
on charactas (for example by rockin tha \f(CW\*(C`:encoding(utf8)\*(C'\fR I/O layer),
\&\fItell()\fR will return byte offsets, not characta offsets (because
implementin dat would render \fIsysseek()\fR unacceptably slow).
.Sp
\&\fIsysseek()\fR bypasses aiiight buffered \s-1IO,\s0 so mixin it wit readz other
than \f(CW\*(C`sysread\*(C'\fR (for example \f(CW\*(C`<>\*(C'\fR or \fIread()\fR) \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`write\*(C'\fR,
\&\f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, or \f(CW\*(C`eof\*(C'\fR may cause mad drama.
.Sp
For \s-1WHENCE,\s0 you may also use tha constants \f(CW\*(C`SEEK_SET\*(C'\fR, \f(CW\*(C`SEEK_CUR\*(C'\fR,
and \f(CW\*(C`SEEK_END\*(C'\fR (start of tha file, current position, end of tha file)
from tha Fcntl module.  Use of tha constants be also mo' portable
than relyin on 0, 1, n' 2.  For example ta define a \*(L"systell\*(R" function:
.Sp
.Vb 2
\&    use Fcntl \*(AqSEEK_CUR\*(Aq;
\&    sub systell { sysseek($_[0], 0, SEEK_CUR) }
.Ve
.Sp
Returns tha freshly smoked up position, or tha undefined value on failure.  A position
of zero is returned as tha strang \f(CW"0 but true"\fR; thus \f(CW\*(C`sysseek\*(C'\fR returns
true on success n' false on failure, yet you can still easily determine
the freshly smoked up position.
.IP "system \s-1LIST \s0" 4
.IX Xref "system shell"
.IX Item "system LIST "
.PD 0
.IP "system \s-1PROGRAM LIST\s0" 4
.IX Item "system PROGRAM LIST"
.PD
Do exactly tha same thang as \f(CW\*(C`exec LIST\*(C'\fR, except dat a gangbangin' fork is
done first n' tha parent process waits fo' tha lil pimp process to
exit.  Note dat argument processin varies dependin on the
number of arguments, n' you can put dat on yo' toast.  If there is mo' than one argument up in \s-1LIST,\s0
or if \s-1LIST\s0 be a array wit mo' than one value, starts tha program
given by tha straight-up original gangsta element of tha list wit arguments given by the
rest of tha list.  If there is only one scalar argument, tha argument
is checked fo' shell metacharacters, n' if there be any, the
entire argument is passed ta tha systemz command shell fo' parsing
(this is \f(CW\*(C`/bin/sh \-c\*(C'\fR on Unix platforms yo, but varies on other
platforms).  If there be no shell metacharactas up in tha argument,
it is split tha fuck into lyrics n' passed directly ta \f(CW\*(C`execvp\*(C'\fR, which is
more efficient.
.Sp
Perl will attempt ta flush all filez opened for
output before any operation dat may do a gangbangin' fork yo, but dis may not be
supported on some platforms (see perlport).  To be safe, you may need
to set \f(CW$|\fR ($AUTOFLUSH up in Gangsta) or call tha \f(CW\*(C`autoflush()\*(C'\fR method
of \f(CW\*(C`IO::Handle\*(C'\fR on any open handles.
.Sp
Da return value is tha exit statuz of tha program as returned by the
\&\f(CW\*(C`wait\*(C'\fR call.  To git tha actual exit value, shift right by eight (see
below).  See also \*(L"exec\*(R".  This is \fInot\fR what tha fuck you wanna use ta capture
the output from a cold-ass lil command; fo' dat you should use merely backticks or
\&\f(CW\*(C`qx//\*(C'\fR, as busted lyrics bout up in \*(L"`STRING`\*(R" up in perlop.  Return value of \-1
indicates a gangbangin' failure ta start tha program or a error of tha \fIwait\fR\|(2) system
call (inspect $! fo' tha reason).
.Sp
If you'd like ta make \f(CW\*(C`system\*(C'\fR (and nuff other bitz of Perl) take a thugged-out dirtnap on error,
have a peep tha autodie pragma.
.Sp
Like \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`system\*(C'\fR allows you ta lie ta a program bout its name if
you use tha \f(CW\*(C`system PROGRAM LIST\*(C'\fR syntax.  Again, peep \*(L"exec\*(R".
.Sp
Since \f(CW\*(C`SIGINT\*(C'\fR n' \f(CW\*(C`SIGQUIT\*(C'\fR is ignored durin tha execution of
\&\f(CW\*(C`system\*(C'\fR, if you expect yo' program ta terminizzle on receipt of these
signals yo big-ass booty is ghon need ta arrange ta do so yo ass based on tha return
value.
.Sp
.Vb 3
\&    @args = ("command", "arg1", "arg2");
\&    system(@args) == 0
\&        or take a thugged-out dirtnap "system @args failed: $?"
.Ve
.Sp
If you'd like ta manually inspect \f(CW\*(C`system\*(C'\fRz failure, you can check all
possible failure modes by inspectin \f(CW$?\fR like this:
.Sp
.Vb 10
\&    if ($, biatch? == \-1) {
\&        print "failed ta execute: $!\en";
\&    }
\&    elsif ($, biatch? & 127) {
\&        printf "child took a dirt nap wit signal %d, %s coredump\en",
\&            ($, biatch? & 127),  ($, biatch? & 128) , biatch? \*(Aqwith\*(Aq : \*(Aqwithout\*(Aq;
\&    }
\&    else {
\&        printf "child exited wit value %d\en", $, biatch? >> 8;
\&    }
.Ve
.Sp
Alternatively, you may inspect tha value of \f(CW\*(C`${^CHILD_ERROR_NATIVE}\*(C'\fR
with tha \f(CW\*(C`W*()\*(C'\fR calls from tha \s-1POSIX\s0 module.
.Sp
When \f(CW\*(C`system\*(C'\fRz arguments is executed indirectly by tha shell, 
results n' return codes is subject ta its quirks.
See \*(L"`STRING`\*(R" up in perlop n' \*(L"exec\*(R" fo' details.
.Sp
Since \f(CW\*(C`system\*(C'\fR do a \f(CW\*(C`fork\*(C'\fR n' \f(CW\*(C`wait\*(C'\fR it may affect a \f(CW\*(C`SIGCHLD\*(C'\fR
handlez n' shit.  See perlipc fo' details.
.Sp
Portabilitizzle issues: \*(L"system\*(R" up in perlport.
.IP "syswrite \s-1FILEHANDLE,SCALAR,LENGTH,OFFSET \s0" 4
.IX Xref "syswrite"
.IX Item "syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET "
.PD 0
.IP "syswrite \s-1FILEHANDLE,SCALAR,LENGTH\s0" 4
.IX Item "syswrite FILEHANDLE,SCALAR,LENGTH"
.IP "syswrite \s-1FILEHANDLE,SCALAR\s0" 4
.IX Item "syswrite FILEHANDLE,SCALAR"
.PD
Attempts ta write \s-1LENGTH\s0 bytez of data from variable \s-1SCALAR\s0 ta the
specified \s-1FILEHANDLE,\s0 rockin \fIwrite\fR\|(2).  If \s-1LENGTH\s0 is
not specified, writes whole \s-1SCALAR. \s0 It bypasses buffered \s-1IO,\s0 so
mixin dis wit readz (other than \f(CWsysread())\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`write\*(C'\fR,
\&\f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, or \f(CW\*(C`eof\*(C'\fR may cause mad drama cuz tha perlio and
stdio layers probably buffer data.  Returns tha number of bytes
actually written, or \f(CW\*(C`undef\*(C'\fR if there was a error (in dis case the
errno variable \f(CW$!\fR be also set).  If tha \s-1LENGTH\s0 is pimped outa than the
data available up in tha \s-1SCALAR\s0 afta tha \s-1OFFSET,\s0 only as much data as is
available is ghon be written.
.Sp
An \s-1OFFSET\s0 may be specified ta write tha data from some part of the
strin other than tha beginning.  A wack \s-1OFFSET\s0 specifies writing
that nuff charactas countin backwardz from tha end of tha string.
If \s-1SCALAR\s0 iz of length zero, you can only use a \s-1OFFSET\s0 of 0.
.Sp
\&\fB\s-1WARNING\s0\fR: If tha filehandle is marked \f(CW\*(C`:utf8\*(C'\fR, Unicode characters
encoded up in \s-1UTF\-8\s0 is freestyled instead of bytes, n' tha \s-1LENGTH, OFFSET,\s0 and
return value of \fIsyswrite()\fR is up in (UTF8\-encoded Unicode) characters.
Da \f(CW\*(C`:encoding(...)\*(C'\fR layer implicitly introduces tha \f(CW\*(C`:utf8\*(C'\fR layer.
Alternately, if tha handle aint marked wit a encodin but you
attempt ta write charactas wit code points over 255, raises a exception.
See \*(L"binmode\*(R", \*(L"open\*(R", n' tha \f(CW\*(C`open\*(C'\fR pragma, open.
.IP "tell \s-1FILEHANDLE \s0" 4
.IX Xref "tell"
.IX Item "tell FILEHANDLE "
.PD 0
.IP "tell" 4
.IX Item "tell"
.PD
Returns tha current posizzle \fIin bytes\fR fo' \s-1FILEHANDLE,\s0 or \-1 on
error. Shiiit, dis aint no joke.  \s-1FILEHANDLE\s0 may be a expression whose value gives tha name of
the actual filehandle.  If \s-1FILEHANDLE\s0 is omitted, assumes tha file
last read.
.Sp
Note tha \fIin bytes\fR: even if tha filehandle has been set to
operate on charactas (for example by rockin tha \f(CW\*(C`:encoding(utf8)\*(C'\fR open
layer), \fItell()\fR will return byte offsets, not characta offsets (because
that would render \fIseek()\fR n' \fItell()\fR rather slow).
.Sp
Da return value of \fItell()\fR fo' tha standard streams like tha \s-1STDIN\s0
dependz on tha operatin system: it may return \-1 or suttin' else.
\&\fItell()\fR on pipes, fifos, n' sockets probably returns \-1.
.Sp
There is no \f(CW\*(C`systell\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Use \f(CW\*(C`sysseek(FH, 0, 1)\*(C'\fR fo' dis shit.
.Sp
Do not use \fItell()\fR (or other buffered I/O operations) on a gangbangin' filehandle
that has been manipulated by \fIsysread()\fR, \fIsyswrite()\fR, or \fIsysseek()\fR.
Those functions ignore tha buffering, while \fItell()\fR do not.
.IP "telldir \s-1DIRHANDLE \s0" 4
.IX Xref "telldir"
.IX Item "telldir DIRHANDLE "
Returns tha current posizzle of tha \f(CW\*(C`readdir\*(C'\fR routines on \s-1DIRHANDLE.\s0
Value may be given ta \f(CW\*(C`seekdir\*(C'\fR ta access a particular location up in a
directory.  \f(CW\*(C`telldir\*(C'\fR has tha same ol' dirty caveats bout possible directory
compaction as tha correspondin system library routine.
.IP "tie \s-1VARIABLE,CLASSNAME,LIST \s0" 4
.IX Xref "tie"
.IX Item "tie VARIABLE,CLASSNAME,LIST "
This function bindz a variable ta a package class dat will provide the
implementation fo' tha variable.  \s-1VARIABLE\s0 is tha name of tha variable
to be enchanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \s-1CLASSNAME\s0 is tha name of a cold-ass lil class implementin objects
of erect type.  Any additionizzle arguments is passed ta the
appropriate constructor
method of tha class (meanin \f(CW\*(C`TIESCALAR\*(C'\fR, \f(CW\*(C`TIEHANDLE\*(C'\fR, \f(CW\*(C`TIEARRAY\*(C'\fR,
or \f(CW\*(C`TIEHASH\*(C'\fR).  Typically these is arguments like fuckin might be passed
to tha \f(CW\*(C`dbm_open()\*(C'\fR function of C.  Da object returned by the
constructor be also returned by tha \f(CW\*(C`tie\*(C'\fR function, which would be useful
if you wanna access other methodz up in \s-1CLASSNAME.\s0
.Sp
Note dat functions like fuckin \f(CW\*(C`keys\*(C'\fR n' \f(CW\*(C`values\*(C'\fR may return big-ass lists
when used on big-ass objects, like \s-1DBM\s0 files.  Yo ass may prefer ta use the
\&\f(CW\*(C`each\*(C'\fR function ta iterate over such.  Example:
.Sp
.Vb 7
\&    # print up history file offsets
\&    use NDBM_File;
\&    tie(%HIST, \*(AqNDBM_File\*(Aq, \*(Aq/usr/lib/news/history\*(Aq, 1, 0);
\&    while (($key,$val) = each %HIST) {
\&        print $key, \*(Aq = \*(Aq, unpack(\*(AqL\*(Aq,$val), "\en";
\&    }
\&    untie(%HIST);
.Ve
.Sp
A class implementin a hash should have tha followin methods:
.Sp
.Vb 11
\&    TIEHASH classname, LIST
\&    FETCH this, key
\&    STORE this, key, value
\&    DELETE this, key
\&    CLEAR this
\&    EXISTS this, key
\&    FIRSTKEY this
\&    NEXTKEY this, lastkey
\&    SCALAR this
\&    DESTROY this
\&    UNTIE this
.Ve
.Sp
A class implementin a ordinary array should have tha followin methods:
.Sp
.Vb 10
\&    TIEARRAY classname, LIST
\&    FETCH this, key
\&    STORE this, key, value
\&    FETCHSIZE this
\&    STORESIZE this, count
\&    CLEAR this
\&    PUSH this, LIST
\&    POP this
\&    SHIFT this
\&    UNSHIFT this, LIST
\&    SPLICE this, offset, length, LIST
\&    EXTEND this, count
\&    DELETE this, key
\&    EXISTS this, key
\&    DESTROY this
\&    UNTIE this
.Ve
.Sp
A class implementin a gangbangin' filehandle should have tha followin methods:
.Sp
.Vb 10
\&    TIEHANDLE classname, LIST
\&    READ this, scalar, length, offset
\&    READLINE this
\&    GETC this
\&    WRITE this, scalar, length, offset
\&    PRINT this, LIST
\&    PRINTF this, format, LIST
\&    BINMODE this
\&    EOF this
\&    FILENO this
\&    SEEK this, position, whence
\&    TELL this
\&    OPEN this, mode, LIST
\&    CLOSE this
\&    DESTROY this
\&    UNTIE this
.Ve
.Sp
A class implementin a scalar should have tha followin methods:
.Sp
.Vb 5
\&    TIESCALAR classname, LIST
\&    FETCH this,
\&    STORE this, value
\&    DESTROY this
\&    UNTIE this
.Ve
.Sp
Not all methodz indicated above need be implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See perltie,
Tie::Hash, Tie::Array, Tie::Scalar, n' Tie::Handle.
.Sp
Unlike \f(CW\*(C`dbmopen\*(C'\fR, tha \f(CW\*(C`tie\*(C'\fR function aint gonna \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR a module
for you; you need ta do dat explicitly yo ass.  See DB_File
or tha \fIConfig\fR module fo' bangin-ass \f(CW\*(C`tie\*(C'\fR implementations.
.Sp
For further details peep perltie, \*(L"tied \s-1VARIABLE\*(R"\s0.
.IP "tied \s-1VARIABLE \s0" 4
.IX Xref "tied"
.IX Item "tied VARIABLE "
Returns a reference ta tha object underlyin \s-1VARIABLE \s0(the same value
that was originally returned by tha \f(CW\*(C`tie\*(C'\fR call dat bound tha variable
to a package.)  Returns tha undefined value if \s-1VARIABLE\s0 aint tied ta a
package.
.IP "time" 4
.IX Xref "time epoch"
.IX Item "time"
Returns tha number of non-leap secondz since whatever time tha system
considaz ta be tha epoch, suitable fo' feedin ta \f(CW\*(C`gmtime\*(C'\fR and
\&\f(CW\*(C`localtime\*(C'\fR.  On most systems tha epoch is 00:00:00 \s-1UTC,\s0 January 1, 1970;
a prominent exception bein Mac \s-1OS\s0 Funky-Ass which uses 00:00:00, January 1,
1904 up in tha current local time unit fo' its epoch.
.Sp
For measurin time up in betta granularitizzle than one second, use the
Time::HiRes module from Perl 5.8 onwardz (or from \s-1CPAN\s0 before then), or,
if you have \fIgettimeofday\fR\|(2), you may be able ta use tha \f(CW\*(C`syscall\*(C'\fR
interface of Perl.  See perlfaq8 fo' details.
.Sp
For date n' time processin peep tha nuff related modulez on \s-1CPAN.\s0
For a cold-ass lil comprehensive date n' time representation peep the
DateTime module.
.IP "times" 4
.IX Xref "times"
.IX Item "times"
Returns a gangbangin' four-element list givin tha user n' system times in
secondz fo' dis process n' any exited lil pimpz of dis process.
.Sp
.Vb 1
\&    ($user,$system,$cuser,$csystem) = times;
.Ve
.Sp
In scalar context, \f(CW\*(C`times\*(C'\fR returns \f(CW$user\fR.
.Sp
Childrenz times is only included fo' terminated lil' thugs.
.Sp
Portabilitizzle issues: \*(L"times\*(R" up in perlport.
.IP "tr///" 4
.IX Item "tr///"
Da transliteration operator. Shiiit, dis aint no joke.  Same as \f(CW\*(C`y///\*(C'\fR.  See
\&\*(L"Quote n' Quote-like Operators\*(R" up in perlop.
.IP "truncate \s-1FILEHANDLE,LENGTH \s0" 4
.IX Xref "truncate"
.IX Item "truncate FILEHANDLE,LENGTH "
.PD 0
.IP "truncate \s-1EXPR,LENGTH\s0" 4
.IX Item "truncate EXPR,LENGTH"
.PD
Truncates tha file opened on \s-1FILEHANDLE,\s0 or named by \s-1EXPR,\s0 ta the
specified length.  Raises a exception if truncate aint implemented
on yo' system.  Returns legit if successful, \f(CW\*(C`undef\*(C'\fR on error.
.Sp
Da behavior is undefined if \s-1LENGTH\s0 is pimped outa than tha length of the
file.
.Sp
Da posizzle up in tha file of \s-1FILEHANDLE\s0 is left unchanged. Y'all KNOW dat shit, muthafucka!  Yo ass may want to
call seek before freestylin ta tha file.
.Sp
Portabilitizzle issues: \*(L"truncate\*(R" up in perlport.
.IP "uc \s-1EXPR \s0" 4
.IX Xref "uc uppercase toupper"
.IX Item "uc EXPR "
.PD 0
.IP "uc" 4
.IX Item "uc"
.PD
Returns a uppercased version of \s-1EXPR. \s0 This is tha internal function
implementin tha \f(CW\*(C`\eU\*(C'\fR escape up in double-quoted strings.
It do not attempt ta do titlecase mappin on initial letters.  See
\&\*(L"ucfirst\*(R" fo' dis shit.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
This function behaves tha same ol' dirty way under various pragma, like fuckin up in a locale,
as \*(L"lc\*(R" do.
.IP "ucfirst \s-1EXPR \s0" 4
.IX Xref "ucfirst uppercase"
.IX Item "ucfirst EXPR "
.PD 0
.IP "ucfirst" 4
.IX Item "ucfirst"
.PD
Returns tha value of \s-1EXPR\s0 wit tha straight-up original gangsta characta up in uppercase
(titlecase up in Unicode).  This is tha internal function implementing
the \f(CW\*(C`\eu\*(C'\fR escape up in double-quoted strings.
.Sp
If \s-1EXPR\s0 is omitted, uses \f(CW$_\fR.
.Sp
This function behaves tha same ol' dirty way under various pragma, like fuckin up in a locale,
as \*(L"lc\*(R" do.
.IP "umask \s-1EXPR \s0" 4
.IX Xref "umask"
.IX Item "umask EXPR "
.PD 0
.IP "umask" 4
.IX Item "umask"
.PD
Sets tha umask fo' tha process ta \s-1EXPR\s0 n' returns tha previous value.
If \s-1EXPR\s0 is omitted, merely returns tha current umask.
.Sp
Da Unix permission \f(CW\*(C`rwxr\-x\-\-\-\*(C'\fR is represented as three setz of three
bits, or three octal digits: \f(CW0750\fR (the leadin 0 indicates octal
and aint one of tha digits).  Da \f(CW\*(C`umask\*(C'\fR value is such a number
representin disabled permissions bits, n' you can put dat on yo' toast.  Da permission (or \*(L"mode\*(R")
values you pass \f(CW\*(C`mkdir\*(C'\fR or \f(CW\*(C`sysopen\*(C'\fR is modified by yo' umask, so
even if you tell \f(CW\*(C`sysopen\*(C'\fR ta create a gangbangin' file wit permissions \f(CW0777\fR,
if yo' umask is \f(CW0022\fR, then tha file will straight-up be pimped with
permissions \f(CW0755\fR.  If yo' \f(CW\*(C`umask\*(C'\fR was \f(CW0027\fR (group can't
write; others can't read, write, or execute), then passing
\&\f(CW\*(C`sysopen\*(C'\fR \f(CW0666\fR would create a gangbangin' file wit mode \f(CW0640\fR (because 
\&\f(CW\*(C`0666 &~ 027\*(C'\fR is \f(CW0640\fR).
.Sp
Herez some lyrics: supply a cold-ass lil creation mode of \f(CW0666\fR fo' regular
filez (in \f(CW\*(C`sysopen\*(C'\fR) n' one of \f(CW0777\fR fo' directories (in
\&\f(CW\*(C`mkdir\*(C'\fR) n' executable files.  This gives playas tha freedom of
choice: if they want protected files, they might chizzle process umasks
of \f(CW022\fR, \f(CW027\fR, or even tha particularly antisocial mask of \f(CW077\fR.
Programs should rarely if eva make policy decisions betta left to
the user n' shit.  Da exception ta dis is when freestylin filez dat should be
kept private: mail files, wizzy browser cookies, \fI.rhosts\fR files, and
so on.
.Sp
If \fIumask\fR\|(2) aint implemented on yo' system n' yo ass is tryin to
restrict access fo' \fIyo ass\fR (i.e., \f(CW\*(C`(EXPR & 0700) > 0\*(C'\fR), 
raises a exception. I aint talkin' bout chicken n' gravy biatch.  If \fIumask\fR\|(2) aint implemented n' yo ass is
not tryin ta restrict access fo' yo ass, returns \f(CW\*(C`undef\*(C'\fR.
.Sp
Remember dat a umask be a number, probably given up in octal; it is \fInot\fR a
strin of octal digits, n' you can put dat on yo' toast.  See also \*(L"oct\*(R", if all you have be a string.
.Sp
Portabilitizzle issues: \*(L"umask\*(R" up in perlport.
.IP "undef \s-1EXPR \s0" 4
.IX Xref "undef undefine"
.IX Item "undef EXPR "
.PD 0
.IP "undef" 4
.IX Item "undef"
.PD
Undefines tha value of \s-1EXPR,\s0 which must be a lvalue.  Use only on a
scalar value, a array (usin \f(CW\*(C`@\*(C'\fR), a hash (usin \f(CW\*(C`%\*(C'\fR), a subroutine
(usin \f(CW\*(C`&\*(C'\fR), or a typeglob (usin \f(CW\*(C`*\*(C'\fR).  Sayin \f(CW\*(C`undef $hash{$key}\*(C'\fR
will probably not do what tha fuck you expect on most predefined variablez or
\&\s-1DBM\s0 list joints, so don't do that; peep \*(L"delete\*(R".  Always returns the
undefined value.  Yo ass can omit tha \s-1EXPR,\s0 up in which case not a god damn thang is
undefined yo, but you still git a undefined value dat you could, for
instance, return from a subroutine, assign ta a variable, or pass as a
parameter n' shit.  Examples:
.Sp
.Vb 9
\&    undef $foo;
\&    undef $bar{\*(Aqblurfl\*(Aq};      # Compare to: delete $bar{\*(Aqblurfl\*(Aq};
\&    undef @ary;
\&    undef %hash;
\&    undef &mysub;
\&    undef *xyz;       # destroys $xyz, @xyz, %xyz, &xyz, etc.
\&    return (wantarray , biatch? (undef, $errmsg) : undef) if $they_blew_it;
\&    select undef, undef, undef, 0.25;
\&    ($a, $b, undef, $c) = &foo;       # Ignore third value returned
.Ve
.Sp
Note dat dis be a unary operator, not a list operator.
.IP "unlink \s-1LIST \s0" 4
.IX Xref "unlink delete remove rm del"
.IX Item "unlink LIST "
.PD 0
.IP "unlink" 4
.IX Item "unlink"
.PD
Deletes a list of files.  On success, it returns tha number of files
it successfully deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  On failure, it returns false n' sets \f(CW$!\fR
(errno):
.Sp
.Vb 3
\&    mah $unlinked = unlink \*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq;
\&    unlink @goners;
\&    unlink glob "*.bak";
.Ve
.Sp
On error, \f(CW\*(C`unlink\*(C'\fR aint gonna rap  which filez it could not remove.
If you wanna know which filez you could not remove, try dem one
at a time:
.Sp
.Vb 3
\&     foreach mah $file ( @goners ) {
\&         unlink $file or warn "Could not unlink $file: $!";
\&     }
.Ve
.Sp
Note: \f(CW\*(C`unlink\*(C'\fR aint gonna attempt ta delete directories unless yo ass is
superuser n' tha \fB\-U\fR flag is supplied ta Perl.  Even if these
conditions is met, be warned dat unlinkin a gangbangin' finger-lickin' directory can inflict
damage on yo' filesystem.  Finally, rockin \f(CW\*(C`unlink\*(C'\fR on directories is
not supported on nuff operatin systems.  Use \f(CW\*(C`rmdir\*(C'\fR instead.
.Sp
If \s-1LIST\s0 is omitted, \f(CW\*(C`unlink\*(C'\fR uses \f(CW$_\fR.
.IP "unpack \s-1TEMPLATE,EXPR \s0" 4
.IX Xref "unpack"
.IX Item "unpack TEMPLATE,EXPR "
.PD 0
.IP "unpack \s-1TEMPLATE\s0" 4
.IX Item "unpack TEMPLATE"
.PD
\&\f(CW\*(C`unpack\*(C'\fR do tha reverse of \f(CW\*(C`pack\*(C'\fR: it takes a string
and expandz it up tha fuck into a list of joints.
(In scalar context, it returns merely tha straight-up original gangsta value produced.)
.Sp
If \s-1EXPR\s0 is omitted, unpacks tha \f(CW$_\fR string.
See perlpacktut fo' a introduction ta dis function.
.Sp
Da strang is fucked up tha fuck into chunks busted lyrics bout by tha \s-1TEMPLATE. \s0 Each chunk
is converted separately ta a value.  Typically, either tha strang be a result
of \f(CW\*(C`pack\*(C'\fR, or tha charactaz of tha strang represent a C structure of some
kind.
.Sp
Da \s-1TEMPLATE\s0 has tha same ol' dirty format as up in tha \f(CW\*(C`pack\*(C'\fR function.
Herez a subroutine dat do substring:
.Sp
.Vb 4
\&    sub substr {
\&        my($what,$where,$howmuch) = @_;
\&        unpack("x$where a$howmuch", $what);
\&    }
.Ve
.Sp
and then there's
.Sp
.Vb 1
\&    sub ordinal { unpack("W",$_[0]); } # same as ord()
.Ve
.Sp
In addizzle ta fieldz allowed up in \fIpack()\fR, you may prefix a gangbangin' field with
a %<number> ta indicate that
you want a <number>\-bit checksum of tha shit instead of tha items
themselves.  Default be a 16\-bit checksum.  Checksum is calculated by
summin numeric jointz of expanded joints (for strang fieldz tha sum of
\&\f(CW\*(C`ord($char)\*(C'\fR is taken; fo' bit fieldz tha sum of zeroes n' ones).
.Sp
For example, tha following
computes tha same ol' dirty number as tha System V sum program:
.Sp
.Vb 4
\&    $checksum = do {
\&        local $/;  # slurp!
\&        unpack("%32W*",<>) % 65535;
\&    };
.Ve
.Sp
Da followin efficiently counts tha number of set bits up in a lil' bit vector:
.Sp
.Vb 1
\&    $setbits = unpack("%32b*", $selectmask);
.Ve
.Sp
Da \f(CW\*(C`p\*(C'\fR n' \f(CW\*(C`P\*(C'\fR formats should be used wit care.  Since Perl
has no way of checkin whether tha value passed ta \f(CW\*(C`unpack()\*(C'\fR
correspondz ta a valid memory location, passin a pointa value that's
not known ta be valid is likely ta have disastrous consequences.
.Sp
If there be mo' pack codes or if tha repeat count of a gangbangin' field or a group
is larger than what tha fuck tha remainder of tha input strang allows, tha result
is not well defined: tha repeat count may be decreased, or
\&\f(CW\*(C`unpack()\*(C'\fR may produce empty strings or zeros, or it may raise a exception.
If tha input strang is longer than one busted lyrics bout by tha \s-1TEMPLATE,\s0
the remainder of dat input strang is ignored.
.Sp
See \*(L"pack\*(R" fo' mo' examplez n' notes.
.IP "unshift \s-1ARRAY,LIST \s0" 4
.IX Xref "unshift"
.IX Item "unshift ARRAY,LIST "
.PD 0
.IP "unshift \s-1EXPR,LIST\s0" 4
.IX Item "unshift EXPR,LIST"
.PD
Do tha opposite of a \f(CW\*(C`shift\*(C'\fR.  Or tha opposite of a \f(CW\*(C`push\*(C'\fR,
dependin on how tha fuck you peep dat shit.  Prependz list ta tha front of the
array n' returns tha freshly smoked up number of elements up in tha array.
.Sp
.Vb 1
\&    unshift(@ARGV, \*(Aq\-e\*(Aq) unless $ARGV[0] =~ /^\-/;
.Ve
.Sp
Note tha \s-1LIST\s0 is prepended whole, not one element at a time, so the
prepended elements stay up in tha same order n' shit.  Use \f(CW\*(C`reverse\*(C'\fR ta do the
reverse.
.Sp
Startin wit Perl 5.14, \f(CW\*(C`unshift\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold
a reference ta a unblessed array.  Da argument is ghon be dereferenced
automatically.  This aspect of \f(CW\*(C`unshift\*(C'\fR is considered highly
experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 1
\&    use 5.014;  # so push/pop/etc work on scalars (experimental)
.Ve
.IP "untie \s-1VARIABLE \s0" 4
.IX Xref "untie"
.IX Item "untie VARIABLE "
Breaks tha bindin between a variable n' a package.
(See tie.)
Has no effect if tha variable aint tied.
.IP "use Module \s-1VERSION LIST \s0" 4
.IX Xref "use module import"
.IX Item "use Module VERSION LIST "
.PD 0
.IP "use Module \s-1VERSION\s0" 4
.IX Item "use Module VERSION"
.IP "use Module \s-1LIST\s0" 4
.IX Item "use Module LIST"
.IP "use Module" 4
.IX Item "use Module"
.IP "use \s-1VERSION\s0" 4
.IX Item "use VERSION"
.PD
Imports some semantics tha fuck into tha current package from tha named module,
generally by aliasin certain subroutine or variable names tha fuck into your
package.  It be exactly equivalent to
.Sp
.Vb 1
\&    BEGIN { require Module; Module\->import( LIST ); }
.Ve
.Sp
except dat Module \fImust\fR be a funky-ass bareword.
Da importation can be made conditionizzle by rockin tha if module.
.Sp
In tha peculiar \f(CW\*(C`use VERSION\*(C'\fR form, \s-1VERSION\s0 may be either a positive
decimal fraction like fuckin 5.006, which is ghon be compared ta \f(CW$]\fR, or a v\-string
of tha form v5.6.1, which is ghon be compared ta \f(CW$^V\fR (aka \f(CW$PERL_VERSION\fR).  An
exception is raised if \s-1VERSION\s0 is pimped outa than tha version of the
current Perl interpreter; Perl aint gonna attempt ta parse tha rest of the
file.  Compare wit \*(L"require\*(R", which can do a similar check at run time.
Symmetrically, \f(CW\*(C`no VERSION\*(C'\fR allows you ta specify dat you want a version
of Perl olda than tha specified one.
.Sp
Specifyin \s-1VERSION\s0 as a literal of tha form v5.6.1 should generally be
avoided, cuz it leadz ta misleadin error lyrics under earlier
versionz of Perl (that is, prior ta 5.6.0) dat do not support this
syntax.  Da equivalent numeric version should be used instead.
.Sp
.Vb 3
\&    use v5.6.1;     # compile time version check
\&    use 5.6.1;      # ditto
\&    use 5.006_001;  # ditto; preferred fo' backwardz compatibility
.Ve
.Sp
This is often useful if you need ta check tha current Perl version before
\&\f(CW\*(C`use\*(C'\fRin library modulez dat won't work wit olda versionz of Perl.
(We try not ta do dis mo' than our crazy asses have to.)
.Sp
\&\f(CW\*(C`use VERSION\*(C'\fR also enablez all features available up in tha requested
version as defined by tha \f(CW\*(C`feature\*(C'\fR pragma, disablin any features
not up in tha axed versionz feature bundle.  See feature.
Similarly, if tha specified Perl version is pimped outa than or equal to
5.12.0, strictures is enabled lexically as
with \f(CW\*(C`use strict\*(C'\fR.  Any explicit use of
\&\f(CW\*(C`use strict\*(C'\fR or \f(CW\*(C`no strict\*(C'\fR overrides \f(CW\*(C`use VERSION\*(C'\fR, even if it comes
before dat shit.  In both cases, tha \fIfeature.pm\fR n' \fIstrict.pm\fR filez are
not straight-up loaded.
.Sp
Da \f(CW\*(C`BEGIN\*(C'\fR forces tha \f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`import\*(C'\fR ta happen at compile time.  The
\&\f(CW\*(C`require\*(C'\fR make shizzle tha module is loaded tha fuck into memory if it aint been
yet.  Da \f(CW\*(C`import\*(C'\fR aint a funky-ass builtin; itz just a ordinary static method
call tha fuck into tha \f(CW\*(C`Module\*(C'\fR package ta tell tha module ta import tha list of
features back tha fuck into tha current package.  Da module can implement its
\&\f(CW\*(C`import\*(C'\fR method any way it likes, though most modulez just chizzle to
derive they \f(CW\*(C`import\*(C'\fR method via inheritizzle from tha \f(CW\*(C`Exporter\*(C'\fR class that
is defined up in tha \f(CW\*(C`Exporter\*(C'\fR module.  See Exporter n' shit.  If no \f(CW\*(C`import\*(C'\fR
method can be found then tha call is skipped, even if there be a \s-1AUTOLOAD\s0
method.
.Sp
If you do not wanna call tha packagez \f(CW\*(C`import\*(C'\fR method (for instance,
to stop yo' namespace from bein altered), explicitly supply tha empty list:
.Sp
.Vb 1
\&    use Module ();
.Ve
.Sp
That is exactly equivalent to
.Sp
.Vb 1
\&    BEGIN { require Module }
.Ve
.Sp
If tha \s-1VERSION\s0 argument is present between Module n' \s-1LIST,\s0 then the
\&\f(CW\*(C`use\*(C'\fR will call tha \s-1VERSION\s0 method up in class Module wit tha given
version as a argument.  Da default \s-1VERSION\s0 method, inherited from
the \s-1UNIVERSAL\s0 class, croaks if tha given version is larger than the
value of tha variable \f(CW$Module::VERSION\fR.
.Sp
Again, there be a gangbangin' finger-lickin' distinction between omittin \s-1LIST \s0(\f(CW\*(C`import\*(C'\fR called
with no arguments) n' a explicit empty \s-1LIST \s0\f(CW\*(C`()\*(C'\fR (\f(CW\*(C`import\*(C'\fR not
called).  Note dat there is no comma afta \s-1VERSION\s0!
.Sp
Because dis be a wide-open intercourse, pragmas (compila directives)
are also implemented dis way.  Currently implemented pragmas are:
.Sp
.Vb 8
\&    use constant;
\&    use diagnostics;
\&    use integer;
\&    use sigtrap  qw(SEGV BUS);
\&    use strict   qw(subs vars refs);
\&    use subs     qw(afunc blurfl);
\&    use warnings qw(all);
\&    use sort     qw(stable _quicksort _mergesort);
.Ve
.Sp
Some of these pseudo-modulez import semantics tha fuck into tha current
block scope (like \f(CW\*(C`strict\*(C'\fR or \f(CW\*(C`integer\*(C'\fR, unlike ordinary modules,
which import symbols tha fuck into tha current package (which is effective
all up in tha end of tha file).
.Sp
Because \f(CW\*(C`use\*(C'\fR takes effect at compile time, it don't respect the
ordinary flow control of tha code bein compiled. Y'all KNOW dat shit, muthafucka!  In particular, putting
a \f(CW\*(C`use\*(C'\fR inside tha false branch of a cold-ass lil conditionizzle don't prevent it
from bein processed. Y'all KNOW dat shit, muthafucka!  If a module or pragma only need ta be loaded 
conditionally, dis can be done rockin tha if pragma:
.Sp
.Vb 2
\&    use if $] < 5.008, "utf8";
\&    use if WANT_WARNINGS, warnings => qw(all);
.Ve
.Sp
Therez a cold-ass lil correspondin \f(CW\*(C`no\*(C'\fR declaration dat unimports meanings imported
by \f(CW\*(C`use\*(C'\fR, i.e., it calls \f(CW\*(C`unimport Module LIST\*(C'\fR instead of \f(CW\*(C`import\*(C'\fR.
It behaves just as \f(CW\*(C`import\*(C'\fR do wit \s-1VERSION,\s0 a omitted or empty \s-1LIST, \s0
or no unimport method bein found.
.Sp
.Vb 3
\&    no integer;
\&    no strict \*(Aqrefs\*(Aq;
\&    no warnings;
.Ve
.Sp
Care should be taken when rockin tha \f(CW\*(C`no VERSION\*(C'\fR form of \f(CW\*(C`no\*(C'\fR.  It is
\&\fIonly\fR meant ta be used ta assert dat tha hustlin Perl iz of a earlier
version than its argument n' \fInot\fR ta undo tha feature-enablin side effects
of \f(CW\*(C`use VERSION\*(C'\fR.
.Sp
See perlmodlib fo' a list of standard modulez n' pragmas.  See perlrun
for tha \f(CW\*(C`\-M\*(C'\fR n' \f(CW\*(C`\-m\*(C'\fR command-line options ta Perl dat give \f(CW\*(C`use\*(C'\fR
functionalitizzle from tha command-line.
.IP "utime \s-1LIST \s0" 4
.IX Xref "utime"
.IX Item "utime LIST "
Changes tha access n' modification times on each file of a list of
files.  Da first two elementz of tha list must be tha \s-1NUMERIC\s0 access
and modification times, up in dat order n' shit.  Returns tha number of files
successfully chizzled. Y'all KNOW dat shit, muthafucka!  Da inode chizzle time of each file is set
to tha current time.  For example, dis code has tha same ol' dirty effect as the
Unix \fItouch\fR\|(1) command when tha filez \fIalready exist\fR n' belong to
the user hustlin tha program:
.Sp
.Vb 3
\&    #!/usr/bin/perl
\&    $atime = $mtime = time;
\&    utime $atime, $mtime, @ARGV;
.Ve
.Sp
Since Perl 5.8.0, if tha straight-up original gangsta two elementz of tha list is \f(CW\*(C`undef\*(C'\fR, 
the \fIutime\fR\|(2) syscall from yo' C library is called wit a null second
argument.  On most systems, dis will set tha filez access and
modification times ta tha current time (i.e., equivalent ta tha example
above) n' will work even on filez you don't own provided you have write
permission:
.Sp
.Vb 4
\&    fo' $file (@ARGV) {
\&        utime(undef, undef, $file) 
\&            || warn "couldn\*(Aqt bust a nut on $file: $!";
\&    }
.Ve
.Sp
Under \s-1NFS\s0 dis will use tha time of tha \s-1NFS\s0 server, not tha time of
the local machine.  If there be a time synchronization problem, the
\&\s-1NFS\s0 server n' local machine gonna git different times.  Da Unix
\&\fItouch\fR\|(1) command will up in fact normally use dis form instead of the
one shown up in tha straight-up original gangsta example.
.Sp
Passin only one of tha straight-up original gangsta two elements as \f(CW\*(C`undef\*(C'\fR is
equivalent ta passin a 0 n' aint gonna have tha effect 
busted lyrics bout when both is \f(CW\*(C`undef\*(C'\fR.  This also triggers an
uninitialized warning.
.Sp
On systems dat support \fIfutimes\fR\|(2), you may pass filehandlez among the
files.  On systems dat don't support \fIfutimes\fR\|(2), passin filehandlez raises
an exception. I aint talkin' bout chicken n' gravy biatch.  Filehandlez must be passed as globs or glob references ta be
recognized; barewordz is considered filenames.
.Sp
Portabilitizzle issues: \*(L"utime\*(R" up in perlport.
.IP "values \s-1HASH \s0" 4
.IX Xref "values"
.IX Item "values HASH "
.PD 0
.IP "values \s-1ARRAY\s0" 4
.IX Item "values ARRAY"
.IP "values \s-1EXPR\s0" 4
.IX Item "values EXPR"
.PD
In list context, returns a list consistin of all tha jointz of tha named
hash.  In Perl 5.12 or lata only, will also return a list of tha joints of
an array; prior ta dat release, attemptin ta use a array argument will
produce a syntax error. Shiiit, dis aint no joke.  In scalar context, returns tha number of joints.
.Sp
Hash entries is returned up in a apparently random order n' shit.  Da actual random
order is specific ta a given hash; tha exact same seriez of operations
on two hashes may result up in a gangbangin' finger-lickin' different order fo' each hash fo' realz. Any insertion
into tha hash may chizzle tha order, as will any deletion, wit tha exception
that da most thugged-out recent key returned by \f(CW\*(C`each\*(C'\fR or \f(CW\*(C`keys\*(C'\fR may be deleted
without changin tha order n' shit. Right back up in yo muthafuckin ass. So long as a given hash is unmodified you may
rely on \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR n' \f(CW\*(C`each\*(C'\fR ta repeatedly return tha same order
as each other n' shit. Right back up in yo muthafuckin ass. See \*(L"Algorithmic Complexitizzle Attacks\*(R" up in perlsec for
details on why hash order is randomized. Y'all KNOW dat shit, muthafucka! Aside from tha guarantees
provided here tha exact detailz of Perlz hash algorithm n' tha hash
traversal order is subject ta chizzle up in any release of Perl.
.Sp
As a side effect, callin \fIvalues()\fR resets tha \s-1HASH\s0 or \s-1ARRAY\s0z internal
iterator, peep \*(L"each\*(R".  (In particular, callin \fIvalues()\fR up in void context
resets tha iterator wit no other overhead. Y'all KNOW dat shit, muthafucka!  Apart from resettin the
iterator, \f(CW\*(C`values @array\*(C'\fR up in list context is tha same ol' dirty as plain \f(CW@array\fR.
(We recommend dat you use void context \f(CW\*(C`keys @array\*(C'\fR fo' dis yo, but
reasoned dat takin \f(CW\*(C`values @array\*(C'\fR up would require more
documentation than leavin it in.)
.Sp
Note dat tha joints is not copied, which means modifyin dem will
modify tha contentz of tha hash:
.Sp
.Vb 2
\&    fo' (values %hash)      { s/foo/bar/g }  # modifies %hash joints
\&    fo' (@hash{keys %hash}) { s/foo/bar/g }  # same
.Ve
.Sp
Startin wit Perl 5.14, \f(CW\*(C`values\*(C'\fR can take a scalar \s-1EXPR,\s0 which must hold
a reference ta a unblessed hash or array.  Da argument will be
dereferenced automatically.  This aspect of \f(CW\*(C`values\*(C'\fR is considered highly
experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da exact behaviour may chizzle up in a gangbangin' future version of Perl.
.Sp
.Vb 2
\&    fo' (values $hashref) { ... }
\&    fo' (values $obj\->get_arrayref) { ... }
.Ve
.Sp
To avoid confusin would-be playaz of yo' code whoz ass is hustlin earlier
versionz of Perl wit mysterious syntax errors, put dis sort of thang at
the top of yo' file ta signal dat yo' code will work \fIonly\fR on Perls of
a recent vintage:
.Sp
.Vb 2
\&    use 5.012;  # so keys/values/each work on arrays
\&    use 5.014;  # so keys/values/each work on scalars (experimental)
.Ve
.Sp
See also \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`each\*(C'\fR, n' \f(CW\*(C`sort\*(C'\fR.
.IP "vec \s-1EXPR,OFFSET,BITS \s0" 4
.IX Xref "vec bit bit vector"
.IX Item "vec EXPR,OFFSET,BITS "
Treats tha strang up in \s-1EXPR\s0 as a lil' bit vector made up of elements of
width \s-1BITS\s0 n' returns tha value of tha element specified by \s-1OFFSET\s0
as a unsigned integer n' shit.  \s-1BITS\s0 therefore specifies tha number of bits
that is reserved fo' each element up in tha bit vector. Shiiit, dis aint no joke.  This must
be a juice of two from 1 ta 32 (or 64, if yo' platform supports
that).
.Sp
If \s-1BITS\s0 is 8, \*(L"elements\*(R" coincizzle wit bytez of tha input string.
.Sp
If \s-1BITS\s0 is 16 or more, bytez of tha input strang is grouped tha fuck into chunks
of size \s-1BITS/8,\s0 n' each crew is converted ta a number as with
\&\fIpack()\fR/\fIunpack()\fR wit big-endian formats \f(CW\*(C`n\*(C'\fR/\f(CW\*(C`N\*(C'\fR (and analogously
for BITS==64).  See \*(L"pack\*(R" fo' details.
.Sp
If bits is 4 or less, tha strang is fucked up tha fuck into bytes, then tha bits
of each byte is fucked up tha fuck into 8/BITS groups.  Bitz of a funky-ass byte are
numbered up in a lil-endian-ish way, as up in \f(CW0x01\fR, \f(CW0x02\fR,
\&\f(CW0x04\fR, \f(CW0x08\fR, \f(CW0x10\fR, \f(CW0x20\fR, \f(CW0x40\fR, \f(CW0x80\fR.  For example,
breakin tha single input byte \f(CW\*(C`chr(0x36)\*(C'\fR tha fuck into two crews gives a list
\&\f(CW\*(C`(0x6, 0x3)\*(C'\fR; breakin it tha fuck into 4 crews gives \f(CW\*(C`(0x2, 0x1, 0x3, 0x0)\*(C'\fR.
.Sp
\&\f(CW\*(C`vec\*(C'\fR may also be assigned to, up in which case parentheses is needed
to give tha expression tha erect precedence as in
.Sp
.Vb 1
\&    vec($image, $max_x * $x + $y, 8) = 3;
.Ve
.Sp
If tha selected element is outside tha string, tha value 0 is returned.
If a element off tha end of tha strang is freestyled to, Perl will first
extend tha strang wit sufficiently nuff zero bytes.   It be a error
to try ta write off tha beginnin of tha strang (i.e., wack \s-1OFFSET\s0).
.Sp
If tha strang happens ta be encoded as \s-1UTF\-8\s0 internally (and thus has
the \s-1UTF8\s0 flag set), dis is ignored by \f(CW\*(C`vec\*(C'\fR, n' it operates on the
internal byte string, not tha conceptual characta string, even if you
only have charactas wit joints less than 256.
.Sp
Strings pimped wit \f(CW\*(C`vec\*(C'\fR can also be manipulated wit tha logical
operators \f(CW\*(C`|\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`^\*(C'\fR, n' \f(CW\*(C`~\*(C'\fR.  These operators will assume a funky-ass bit
vector operation is desired when both operandz is strings.
See \*(L"Bitwise Strin Operators\*(R" up in perlop.
.Sp
Da followin code will build up a \s-1ASCII\s0 strang sayin \f(CW\*(AqPerlPerlPerl\*(Aq\fR.
Da comments show tha strang afta each step.  Note dat dis code works
in tha same way on big-endian or lil-endian machines.
.Sp
.Vb 2
\&    mah $foo = \*(Aq\*(Aq;
\&    vec($foo,  0, 32) = 0x5065726C; # \*(AqPerl\*(Aq
\&
\&    # $foo eq "Perl" eq "\ex50\ex65\ex72\ex6C", 32 bits
\&    print vec($foo, 0, 8);  # prints 80 == 0x50 == ord(\*(AqP\*(Aq)
\&
\&    vec($foo,  2, 16) = 0x5065; # \*(AqPerlPe\*(Aq
\&    vec($foo,  3, 16) = 0x726C; # \*(AqPerlPerl\*(Aq
\&    vec($foo,  8,  8) = 0x50;   # \*(AqPerlPerlP\*(Aq
\&    vec($foo,  9,  8) = 0x65;   # \*(AqPerlPerlPe\*(Aq
\&    vec($foo, 20,  4) = 2;      # \*(AqPerlPerlPe\*(Aq   . "\ex02"
\&    vec($foo, 21,  4) = 7;      # \*(AqPerlPerlPer\*(Aq
\&                                   # \*(Aqr\*(Aq is "\ex72"
\&    vec($foo, 45,  2) = 3;      # \*(AqPerlPerlPer\*(Aq  . "\ex0c"
\&    vec($foo, 93,  1) = 1;      # \*(AqPerlPerlPer\*(Aq  . "\ex2c"
\&    vec($foo, 94,  1) = 1;      # \*(AqPerlPerlPerl\*(Aq
\&                                   # \*(Aql\*(Aq is "\ex6c"
.Ve
.Sp
To transform a lil' bit vector tha fuck into a strang or list of 0z n' 1's, use these:
.Sp
.Vb 2
\&    $bits = unpack("b*", $vector);
\&    @bits = split(//, unpack("b*", $vector));
.Ve
.Sp
If you know tha exact length up in bits, it can be used up in place of tha \f(CW\*(C`*\*(C'\fR.
.Sp
Here be a example ta illustrate how tha fuck tha bits straight-up fall up in place:
.Sp
.Vb 1
\&  #!/usr/bin/perl \-wl
\&
\&  print <<\*(AqEOT\*(Aq;
\&                                    0         1         2         3
\&                     unpack("V",$_) 01234567890123456789012345678901
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  EOT
\&
\&  fo' $w (0..3) {
\&      $width = 2**$w;
\&      fo' ($shift=0; $shift < $width; ++$shift) {
\&          fo' ($off=0; $off < 32/$width; ++$off) {
\&              $str = pack("B*", "0"x32);
\&              $bits = (1<<$shift);
\&              vec($str, $off, $width) = $bits;
\&              $res = unpack("b*",$str);
\&              $val = unpack("V", $str);
\&              write;
\&          }
\&      }
\&  }
\&
\&  format STDOUT =
\&  vec($_,@#,@#) = @<< == @######### @>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
\&  $off, $width, $bits, $val, $res
\&  .
\&  _\|_END_\|_
.Ve
.Sp
Regardless of tha machine architecture on which it runs, tha 
example above should print tha followin table:
.Sp
.Vb 10
\&                                    0         1         2         3
\&                     unpack("V",$_) 01234567890123456789012345678901
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  vec($_, 0, 1) = 1   ==          1 10000000000000000000000000000000
\&  vec($_, 1, 1) = 1   ==          2 01000000000000000000000000000000
\&  vec($_, 2, 1) = 1   ==          4 00100000000000000000000000000000
\&  vec($_, 3, 1) = 1   ==          8 00010000000000000000000000000000
\&  vec($_, 4, 1) = 1   ==         16 00001000000000000000000000000000
\&  vec($_, 5, 1) = 1   ==         32 00000100000000000000000000000000
\&  vec($_, 6, 1) = 1   ==         64 00000010000000000000000000000000
\&  vec($_, 7, 1) = 1   ==        128 00000001000000000000000000000000
\&  vec($_, 8, 1) = 1   ==        256 00000000100000000000000000000000
\&  vec($_, 9, 1) = 1   ==        512 00000000010000000000000000000000
\&  vec($_,10, 1) = 1   ==       1024 00000000001000000000000000000000
\&  vec($_,11, 1) = 1   ==       2048 00000000000100000000000000000000
\&  vec($_,12, 1) = 1   ==       4096 00000000000010000000000000000000
\&  vec($_,13, 1) = 1   ==       8192 00000000000001000000000000000000
\&  vec($_,14, 1) = 1   ==      16384 00000000000000100000000000000000
\&  vec($_,15, 1) = 1   ==      32768 00000000000000010000000000000000
\&  vec($_,16, 1) = 1   ==      65536 00000000000000001000000000000000
\&  vec($_,17, 1) = 1   ==     131072 00000000000000000100000000000000
\&  vec($_,18, 1) = 1   ==     262144 00000000000000000010000000000000
\&  vec($_,19, 1) = 1   ==     524288 00000000000000000001000000000000
\&  vec($_,20, 1) = 1   ==    1048576 00000000000000000000100000000000
\&  vec($_,21, 1) = 1   ==    2097152 00000000000000000000010000000000
\&  vec($_,22, 1) = 1   ==    4194304 00000000000000000000001000000000
\&  vec($_,23, 1) = 1   ==    8388608 00000000000000000000000100000000
\&  vec($_,24, 1) = 1   ==   16777216 00000000000000000000000010000000
\&  vec($_,25, 1) = 1   ==   33554432 00000000000000000000000001000000
\&  vec($_,26, 1) = 1   ==   67108864 00000000000000000000000000100000
\&  vec($_,27, 1) = 1   ==  134217728 00000000000000000000000000010000
\&  vec($_,28, 1) = 1   ==  268435456 00000000000000000000000000001000
\&  vec($_,29, 1) = 1   ==  536870912 00000000000000000000000000000100
\&  vec($_,30, 1) = 1   == 1073741824 00000000000000000000000000000010
\&  vec($_,31, 1) = 1   == 2147483648 00000000000000000000000000000001
\&  vec($_, 0, 2) = 1   ==          1 10000000000000000000000000000000
\&  vec($_, 1, 2) = 1   ==          4 00100000000000000000000000000000
\&  vec($_, 2, 2) = 1   ==         16 00001000000000000000000000000000
\&  vec($_, 3, 2) = 1   ==         64 00000010000000000000000000000000
\&  vec($_, 4, 2) = 1   ==        256 00000000100000000000000000000000
\&  vec($_, 5, 2) = 1   ==       1024 00000000001000000000000000000000
\&  vec($_, 6, 2) = 1   ==       4096 00000000000010000000000000000000
\&  vec($_, 7, 2) = 1   ==      16384 00000000000000100000000000000000
\&  vec($_, 8, 2) = 1   ==      65536 00000000000000001000000000000000
\&  vec($_, 9, 2) = 1   ==     262144 00000000000000000010000000000000
\&  vec($_,10, 2) = 1   ==    1048576 00000000000000000000100000000000
\&  vec($_,11, 2) = 1   ==    4194304 00000000000000000000001000000000
\&  vec($_,12, 2) = 1   ==   16777216 00000000000000000000000010000000
\&  vec($_,13, 2) = 1   ==   67108864 00000000000000000000000000100000
\&  vec($_,14, 2) = 1   ==  268435456 00000000000000000000000000001000
\&  vec($_,15, 2) = 1   == 1073741824 00000000000000000000000000000010
\&  vec($_, 0, 2) = 2   ==          2 01000000000000000000000000000000
\&  vec($_, 1, 2) = 2   ==          8 00010000000000000000000000000000
\&  vec($_, 2, 2) = 2   ==         32 00000100000000000000000000000000
\&  vec($_, 3, 2) = 2   ==        128 00000001000000000000000000000000
\&  vec($_, 4, 2) = 2   ==        512 00000000010000000000000000000000
\&  vec($_, 5, 2) = 2   ==       2048 00000000000100000000000000000000
\&  vec($_, 6, 2) = 2   ==       8192 00000000000001000000000000000000
\&  vec($_, 7, 2) = 2   ==      32768 00000000000000010000000000000000
\&  vec($_, 8, 2) = 2   ==     131072 00000000000000000100000000000000
\&  vec($_, 9, 2) = 2   ==     524288 00000000000000000001000000000000
\&  vec($_,10, 2) = 2   ==    2097152 00000000000000000000010000000000
\&  vec($_,11, 2) = 2   ==    8388608 00000000000000000000000100000000
\&  vec($_,12, 2) = 2   ==   33554432 00000000000000000000000001000000
\&  vec($_,13, 2) = 2   ==  134217728 00000000000000000000000000010000
\&  vec($_,14, 2) = 2   ==  536870912 00000000000000000000000000000100
\&  vec($_,15, 2) = 2   == 2147483648 00000000000000000000000000000001
\&  vec($_, 0, 4) = 1   ==          1 10000000000000000000000000000000
\&  vec($_, 1, 4) = 1   ==         16 00001000000000000000000000000000
\&  vec($_, 2, 4) = 1   ==        256 00000000100000000000000000000000
\&  vec($_, 3, 4) = 1   ==       4096 00000000000010000000000000000000
\&  vec($_, 4, 4) = 1   ==      65536 00000000000000001000000000000000
\&  vec($_, 5, 4) = 1   ==    1048576 00000000000000000000100000000000
\&  vec($_, 6, 4) = 1   ==   16777216 00000000000000000000000010000000
\&  vec($_, 7, 4) = 1   ==  268435456 00000000000000000000000000001000
\&  vec($_, 0, 4) = 2   ==          2 01000000000000000000000000000000
\&  vec($_, 1, 4) = 2   ==         32 00000100000000000000000000000000
\&  vec($_, 2, 4) = 2   ==        512 00000000010000000000000000000000
\&  vec($_, 3, 4) = 2   ==       8192 00000000000001000000000000000000
\&  vec($_, 4, 4) = 2   ==     131072 00000000000000000100000000000000
\&  vec($_, 5, 4) = 2   ==    2097152 00000000000000000000010000000000
\&  vec($_, 6, 4) = 2   ==   33554432 00000000000000000000000001000000
\&  vec($_, 7, 4) = 2   ==  536870912 00000000000000000000000000000100
\&  vec($_, 0, 4) = 4   ==          4 00100000000000000000000000000000
\&  vec($_, 1, 4) = 4   ==         64 00000010000000000000000000000000
\&  vec($_, 2, 4) = 4   ==       1024 00000000001000000000000000000000
\&  vec($_, 3, 4) = 4   ==      16384 00000000000000100000000000000000
\&  vec($_, 4, 4) = 4   ==     262144 00000000000000000010000000000000
\&  vec($_, 5, 4) = 4   ==    4194304 00000000000000000000001000000000
\&  vec($_, 6, 4) = 4   ==   67108864 00000000000000000000000000100000
\&  vec($_, 7, 4) = 4   == 1073741824 00000000000000000000000000000010
\&  vec($_, 0, 4) = 8   ==          8 00010000000000000000000000000000
\&  vec($_, 1, 4) = 8   ==        128 00000001000000000000000000000000
\&  vec($_, 2, 4) = 8   ==       2048 00000000000100000000000000000000
\&  vec($_, 3, 4) = 8   ==      32768 00000000000000010000000000000000
\&  vec($_, 4, 4) = 8   ==     524288 00000000000000000001000000000000
\&  vec($_, 5, 4) = 8   ==    8388608 00000000000000000000000100000000
\&  vec($_, 6, 4) = 8   ==  134217728 00000000000000000000000000010000
\&  vec($_, 7, 4) = 8   == 2147483648 00000000000000000000000000000001
\&  vec($_, 0, 8) = 1   ==          1 10000000000000000000000000000000
\&  vec($_, 1, 8) = 1   ==        256 00000000100000000000000000000000
\&  vec($_, 2, 8) = 1   ==      65536 00000000000000001000000000000000
\&  vec($_, 3, 8) = 1   ==   16777216 00000000000000000000000010000000
\&  vec($_, 0, 8) = 2   ==          2 01000000000000000000000000000000
\&  vec($_, 1, 8) = 2   ==        512 00000000010000000000000000000000
\&  vec($_, 2, 8) = 2   ==     131072 00000000000000000100000000000000
\&  vec($_, 3, 8) = 2   ==   33554432 00000000000000000000000001000000
\&  vec($_, 0, 8) = 4   ==          4 00100000000000000000000000000000
\&  vec($_, 1, 8) = 4   ==       1024 00000000001000000000000000000000
\&  vec($_, 2, 8) = 4   ==     262144 00000000000000000010000000000000
\&  vec($_, 3, 8) = 4   ==   67108864 00000000000000000000000000100000
\&  vec($_, 0, 8) = 8   ==          8 00010000000000000000000000000000
\&  vec($_, 1, 8) = 8   ==       2048 00000000000100000000000000000000
\&  vec($_, 2, 8) = 8   ==     524288 00000000000000000001000000000000
\&  vec($_, 3, 8) = 8   ==  134217728 00000000000000000000000000010000
\&  vec($_, 0, 8) = 16  ==         16 00001000000000000000000000000000
\&  vec($_, 1, 8) = 16  ==       4096 00000000000010000000000000000000
\&  vec($_, 2, 8) = 16  ==    1048576 00000000000000000000100000000000
\&  vec($_, 3, 8) = 16  ==  268435456 00000000000000000000000000001000
\&  vec($_, 0, 8) = 32  ==         32 00000100000000000000000000000000
\&  vec($_, 1, 8) = 32  ==       8192 00000000000001000000000000000000
\&  vec($_, 2, 8) = 32  ==    2097152 00000000000000000000010000000000
\&  vec($_, 3, 8) = 32  ==  536870912 00000000000000000000000000000100
\&  vec($_, 0, 8) = 64  ==         64 00000010000000000000000000000000
\&  vec($_, 1, 8) = 64  ==      16384 00000000000000100000000000000000
\&  vec($_, 2, 8) = 64  ==    4194304 00000000000000000000001000000000
\&  vec($_, 3, 8) = 64  == 1073741824 00000000000000000000000000000010
\&  vec($_, 0, 8) = 128 ==        128 00000001000000000000000000000000
\&  vec($_, 1, 8) = 128 ==      32768 00000000000000010000000000000000
\&  vec($_, 2, 8) = 128 ==    8388608 00000000000000000000000100000000
\&  vec($_, 3, 8) = 128 == 2147483648 00000000000000000000000000000001
.Ve
.IP "wait" 4
.IX Xref "wait"
.IX Item "wait"
Behaves like \fIwait\fR\|(2) on yo' system: it waits fo' a cold-ass lil child
process ta terminizzle n' returns tha pid of tha deceased process, or
\&\f(CW\*(C`\-1\*(C'\fR if there be no lil pimp processes.  Da status is returned up in \f(CW$?\fR
and \f(CW\*(C`${^CHILD_ERROR_NATIVE}\*(C'\fR.
Note dat a return value of \f(CW\*(C`\-1\*(C'\fR could mean dat lil pimp processes are
bein automatically reaped, as busted lyrics bout up in perlipc.
.Sp
If you use wait up in yo' handlez fo' \f(CW$SIG\fR{\s-1CHLD\s0} it may accidentally fo' the
child pimped by \fIqx()\fR or \fIsystem()\fR.  See perlipc fo' details.
.Sp
Portabilitizzle issues: \*(L"wait\*(R" up in perlport.
.IP "waitpid \s-1PID,FLAGS \s0" 4
.IX Xref "waitpid"
.IX Item "waitpid PID,FLAGS "
Waits fo' a particular lil pimp process ta terminizzle n' returns tha pid of
the deceased process, or \f(CW\*(C`\-1\*(C'\fR if there is no such lil pimp process.  On some
systems, a value of 0 indicates dat there be processes still hustlin.
Da status is returned up in \f(CW$?\fR n' \f(CW\*(C`${^CHILD_ERROR_NATIVE}\*(C'\fR.  If you say
.Sp
.Vb 5
\&    use POSIX ":sys_wait_h";
\&    #...
\&    do {
\&        $kid = waitpid(\-1, WNOHANG);
\&    } while $kid > 0;
.Ve
.Sp
then you can do a non-blockin wait fo' all pendin zombie processes.
Non-blockin wait be available on machines supportin either the
\&\fIwaitpid\fR\|(2) or \fIwait4\fR\|(2) syscalls.  But fuck dat shiznit yo, tha word on tha street is dat waitin fo' a particular
pid wit \s-1FLAGS\s0 of \f(CW0\fR is implemented everywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  (Perl emulates the
system call by rememberin tha status jointz of processes dat have
exited but aint been harvested by tha Perl script yet.)
.Sp
Note dat on some systems, a return value of \f(CW\*(C`\-1\*(C'\fR could mean dat child
processes is bein automatically reaped. Y'all KNOW dat shit, muthafucka!  See perlipc fo' details,
and fo' other examples.
.Sp
Portabilitizzle issues: \*(L"waitpid\*(R" up in perlport.
.IP "wantarray" 4
.IX Xref "wantarray context"
.IX Item "wantarray"
Returns legit if tha context of tha currently executin subroutine or
\&\f(CW\*(C`eval\*(C'\fR is lookin fo' a list value.  Returns false if tha context is
lookin fo' a scalar. Shiiit, dis aint no joke.  Returns tha undefined value if tha context is
lookin fo' no value (void context).
.Sp
.Vb 3
\&    return unless defined wantarray; # don\*(Aqt bother bustin more
\&    mah @a = complex_calculation();
\&    return wantarray , biatch? @a : "@a";
.Ve
.Sp
\&\f(CW\*(C`wantarray()\*(C'\fRz result is unspecified up in tha top level of a gangbangin' file,
in a \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR or \f(CW\*(C`END\*(C'\fR block, or
in a \f(CW\*(C`DESTROY\*(C'\fR method.
.Sp
This function should done been named \fIwantlist()\fR instead.
.IP "warn \s-1LIST \s0" 4
.IX Xref "warn warnin STDERR"
.IX Item "warn LIST "
Prints tha value of \s-1LIST\s0 ta \s-1STDERR. \s0 If tha last element of \s-1LIST\s0 do
not end up in a newline, it appendz tha same ol' dirty file/line number text as \f(CW\*(C`die\*(C'\fR
does.
.Sp
If tha output is empty n' \f(CW$@\fR already gotz nuff a value (typically from a
previous eval) dat value is used afta appendin \f(CW"\et...caught"\fR
to \f(CW$@\fR.  This is useful fo' stayin almost yo, but not entirely similar to
\&\f(CW\*(C`die\*(C'\fR.
.Sp
If \f(CW$@\fR is empty then tha strang \f(CW"Warning: Something\*(Aqs wrong"\fR is used.
.Sp
No message is printed if there be a \f(CW$SIG{_\|_WARN_\|_}\fR handlez
installed. Y'all KNOW dat shit, muthafucka!  It be tha handlezz responsibilitizzle ta deal wit tha message
as it sees fit (like, fo' instance, convertin it tha fuck into a \f(CW\*(C`die\*(C'\fR).  Most
handlezs must therefore arrange ta straight-up display the
warnings dat they is not prepared ta deal with, by callin \f(CW\*(C`warn\*(C'\fR
again up in tha handlez n' shit.  Note dat dis is like safe n' will not
produce a endless loop, since \f(CW\*(C`_\|_WARN_\|_\*(C'\fR hooks is not called from
inside one.
.Sp
Yo ass will find dis behavior is slightly different from dat of
\&\f(CW$SIG{_\|_DIE_\|_}\fR handlezs (which don't suppress tha error text yo, but can
instead call \f(CW\*(C`die\*(C'\fR again n' again n' again ta chizzle it).
.Sp
Usin a \f(CW\*(C`_\|_WARN_\|_\*(C'\fR handlez serves up a bangin way ta silence all
warnings (even tha so-called mandatory ones).  An example:
.Sp
.Vb 7
\&    # wipe up *all* compile\-time warnings
\&    BEGIN { $SIG{\*(Aq_\|_WARN_\|_\*(Aq} = sub { warn $_[0] if $DOWARN } }
\&    mah $foo = 10;
\&    mah $foo = 20;          # no warnin bout duplicate mah $foo,
\&                           # but hey, you axed fo' dat shiznit son!
\&    # no compile\-time or run\-time warnings before here
\&    $DOWARN = 1;
\&
\&    # run\-time warnings enabled afta here
\&    warn "\e$foo is kickin it n' $foo!";     # do show up
.Ve
.Sp
See perlvar fo' details on settin \f(CW%SIG\fR entries n' fo' more
examples.  See tha Carp module fo' other kindz of warnings rockin its
\&\fIcarp()\fR n' \fIcluck()\fR functions.
.IP "write \s-1FILEHANDLE \s0" 4
.IX Xref "write"
.IX Item "write FILEHANDLE "
.PD 0
.IP "write \s-1EXPR\s0" 4
.IX Item "write EXPR"
.IP "write" 4
.IX Item "write"
.PD
Writes a gangbangin' formatted record (possibly multi-line) ta tha specified \s-1FILEHANDLE,\s0
usin tha format associated wit dat file.  By default tha format for
a file is tha one havin tha same name as tha filehandle yo, but the
format fo' tha current output channel (see tha \f(CW\*(C`select\*(C'\fR function) may be set
explicitly by assignin tha name of tha format ta tha \f(CW$~\fR variable.
.Sp
Top of form processin is handled automatically:  if there is insufficient
room on tha current page fo' tha formatted record, tha page be advanced by
writin a gangbangin' form feed, a special top-of-page format is used ta format tha new
page header before tha record is written. I aint talkin' bout chicken n' gravy biatch.  By default, tha top-of-page
format is tha name of tha filehandle wit \*(L"_TOP\*(R" appended. Y'all KNOW dat shit, muthafucka!  This would be a
problem wit autovivified filehandlez yo, but it may be dynamically set ta the
format of yo' chizzle by assignin tha name ta tha \f(CW$^\fR variable while
that filehandle is selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da number of lines remainin on tha current
page is up in variable \f(CW\*(C`$\-\*(C'\fR, which can be set ta \f(CW0\fR ta force a freshly smoked up page.
.Sp
If \s-1FILEHANDLE\s0 is unspecified, output goes ta tha current default output
channel, which starts up as \s-1STDOUT\s0 but may be chizzled by the
\&\f(CW\*(C`select\*(C'\fR operator. Shiiit, dis aint no joke.  If tha \s-1FILEHANDLE\s0 be a \s-1EXPR,\s0 then tha expression
is evaluated n' tha resultin strang is used ta look up tha name of
the \s-1FILEHANDLE\s0 at run time.  For mo' on formats, peep perlform.
.Sp
Note dat write is \fInot\fR tha opposite of \f(CW\*(C`read\*(C'\fR.  Unfortunately.
.IP "y///" 4
.IX Item "y///"
Da transliteration operator. Shiiit, dis aint no joke.  Same as \f(CW\*(C`tr///\*(C'\fR.  See
\&\*(L"Quote n' Quote-like Operators\*(R" up in perlop.
.SS "Non-function Keywordz by Cross-reference"
.IX Subsection "Non-function Keywordz by Cross-reference"
\fIperldata\fR
.IX Subsection "perldata"
.IP "_\|_DATA_\|_" 4
.IX Item "__DATA__"
.PD 0
.IP "_\|_END_\|_" 4
.IX Item "__END__"
.PD
These keywordz is documented up in \*(L"Special Literals\*(R" up in perldata.
.PP
\fIperlmod\fR
.IX Subsection "perlmod"
.IP "\s-1BEGIN\s0" 4
.IX Item "BEGIN"
.PD 0
.IP "\s-1CHECK\s0" 4
.IX Item "CHECK"
.IP "\s-1END\s0" 4
.IX Item "END"
.IP "\s-1INIT\s0" 4
.IX Item "INIT"
.IP "\s-1UNITCHECK\s0" 4
.IX Item "UNITCHECK"
.PD
These compile phase keywordz is documented up in \*(L"\s-1BEGIN, UNITCHECK, CHECK, INIT\s0 n' \s-1END\*(R"\s0 up in perlmod.
.PP
\fIperlobj\fR
.IX Subsection "perlobj"
.IP "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
This method keyword is documented up in \*(L"Destructors\*(R" up in perlobj.
.PP
\fIperlop\fR
.IX Subsection "perlop"
.IP "and" 4
.IX Item "and"
.PD 0
.IP "cmp" 4
.IX Item "cmp"
.IP "eq" 4
.IX Item "eq"
.IP "ge" 4
.IX Item "ge"
.IP "gt" 4
.IX Item "gt"
.IP "if" 4
.IX Item "if"
.IP "le" 4
.IX Item "le"
.IP "lt" 4
.IX Item "lt"
.IP "ne" 4
.IX Item "ne"
.IP "not" 4
.IX Item "not"
.IP "or" 4
.IX Item "or"
.IP "x" 4
.IX Item "x"
.IP "xor" 4
.IX Item "xor"
.PD
These operators is documented up in perlop.
.PP
\fIperlsub\fR
.IX Subsection "perlsub"
.IP "\s-1AUTOLOAD\s0" 4
.IX Item "AUTOLOAD"
This keyword is documented up in \*(L"Autoloading\*(R" up in perlsub.
.PP
\fIperlsyn\fR
.IX Subsection "perlsyn"
.IP "else" 4
.IX Item "else"
.PD 0
.IP "elseif" 4
.IX Item "elseif"
.IP "elsif" 4
.IX Item "elsif"
.IP "for" 4
.IX Item "for"
.IP "foreach" 4
.IX Item "foreach"
.IP "unless" 4
.IX Item "unless"
.IP "until" 4
.IX Item "until"
.IP "while" 4
.IX Item "while"
.PD
These flow-control keywordz is documented up in \*(L"Compound Statements\*(R" up in perlsyn.
.IP "default" 4
.IX Item "default"
.PD 0
.IP "given" 4
.IX Item "given"
.IP "when" 4
.IX Item "when"
.PD
These flow-control keywordz related ta tha experimenstrual switch feature are
documented up in \*(L"Switch Statements\*(R" up in perlsyn .
