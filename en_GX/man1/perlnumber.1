.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLNUMBER 1"
.TH PERLNUMBER 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlnumber \- semantics of numbers n' numeric operations up in Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&    $n = 1234;              # decimal integer
\&    $n = 0b1110011;         # binary integer
\&    $n = 01234;             # octal integer
\&    $n = 0x1234;            # hexadecimal integer
\&    $n = 12.34e\-56;         # exponential notation
\&    $n = "\-12.34e56";       # number specified as a string
\&    $n = "1234";            # number specified as a string
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout how tha fuck Perl internally handlez numeric joints.
.PP
Perlz operator overloadin facilitizzle is straight-up ignored here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Operator
overloadin allows user-defined behaviors fo' numbers, like fuckin operations
over arbitrarily big-ass integers, floatin points numbers wit arbitrary
precision, operations over \*(L"exotic\*(R" numbers like fuckin modular arithmetic or
p\-adic arithmetic, n' so on. I aint talkin' bout chicken n' gravy biatch.  See overload fo' details.
.SH "Storin numbers"
.IX Header "Storin numbers"
Perl can internally represent numbers up in 3 different ways: as native
integers, as natizzle floatin point numbers, n' as decimal strings.
Decimal strings may have a exponential notation part, as up in \f(CW"12.34e\-56"\fR.
\&\fINative\fR here means \*(L"a format supported by tha C compila which was used
to build perl\*(R".
.PP
Da term \*(L"native\*(R" do not mean like as much when we rap bout native
integers, as it do when natizzle floatin point numbers is involved.
Da only implication of tha term \*(L"native\*(R" on integers is dat tha limits for
the maximal n' tha minimal supported legit integral quantitizzles is close to
powerz of 2.  But fuck dat shiznit yo, tha word on tha street is dat \*(L"native\*(R" floats gotz a most fundamental
restriction: they may represent only dem numbers which gotz a relatively
\&\*(L"short\*(R" representation when converted ta a funky-ass binary fraction. I aint talkin' bout chicken n' gravy biatch.  For example,
0.9 cannot be represented by a natizzle float, since tha binary fraction
for 0.9 is infinite:
.PP
.Vb 1
\&  binary0.1110011001100...
.Ve
.PP
with tha sequence \f(CW1100\fR repeatin again n' again n' again n' again. I aint talkin' bout chicken n' gravy biatch.  In addizzle ta this
limitation,  tha exponent of tha binary number be also restricted when it
is represented as a gangbangin' floatin point number n' shit.  On typical hardware, floating
point joints can store numbers wit up ta 53 binary digits, n' wit binary
exponents between \-1024 n' 1024.  In decimal representation dis is close
to 16 decimal digits n' decimal exponents up in tha range of \-304..304.
Da upshot of all dis is dat Perl cannot store a number like
12345678901234567 as a gangbangin' floatin point number on such architectures without
loss of shiznit.
.PP
Similarly, decimal strings can represent only dem numbers which have a
finite decimal expansion. I aint talkin' bout chicken n' gravy biatch.  Bein strings, n' thuz of arbitrary length, there
is no practical limit fo' tha exponent or number of decimal digits fo' these
numbers.  (But realize dat what tha fuck we is discussin tha rulez fo' just the
\&\fIstorage\fR of these numbers.  Da fact dat you can store such \*(L"large\*(R" numbers
does not mean dat tha \fIoperations\fR over these numbers will use all
of tha dope digits.
See \*(L"Numeric operators n' numeric conversions\*(R" fo' details.)
.PP
In fact numbers stored up in tha natizzle integer format may be stored either
in tha signed natizzle form, or up in tha unsigned natizzle form.  Thus tha limits
for Perl numbers stored as natizzle integers would typically be \-2**31..2**32\-1,
with appropriate modifications up in tha case of 64\-bit integers.  Again, this
does not mean dat Perl can do operations only over integers up in dis range:
it is possible ta store nuff mo' integers up in floatin point format.
.PP
Summin up, Perl numeric joints can store only dem numbers which have
a finite decimal expansion or a \*(L"short\*(R" binary expansion.
.SH "Numeric operators n' numeric conversions"
.IX Header "Numeric operators n' numeric conversions"
As mentioned earlier, Perl can store a number up in any one of three formats,
but most operators typically KNOW only one of dem formats, n' you can put dat on yo' toast.  When
a numeric value is passed as a argument ta such a operator, it will be
converted ta tha format understood by tha operator.
.PP
Six such conversions is possible:
.PP
.Vb 6
\&  natizzle integer        \-\-> natizzle floatin point       (*)
\&  natizzle integer        \-\-> decimal string
\&  natizzle floating_point \-\-> natizzle integer              (*)
\&  natizzle floating_point \-\-> decimal strang              (*)
\&  decimal strang        \-\-> natizzle integer
\&  decimal strang        \-\-> natizzle floatin point       (*)
.Ve
.PP
These conversions is governed by tha followin general rules:
.IP "\(bu" 4
If tha source number can be represented up in tha target form, that
representation is used.
.IP "\(bu" 4
If tha source number is outside of tha limits representable up in tha target form,
a representation of tha closest limit is used. Y'all KNOW dat shit, muthafucka!  (\fILoss of shiznit\fR)
.IP "\(bu" 4
If tha source number is between two numbers representable up in tha target form,
a representation of one of these numbers is used. Y'all KNOW dat shit, muthafucka!  (\fILoss of shiznit\fR)
.IP "\(bu" 4
In \f(CW\*(C`natizzle floatin point \-\-> natizzle integer\*(C'\fR conversions tha magnitude
of tha result is less than or equal ta tha magnitude of tha source.
(\fI\*(L"Roundin ta zero\*(R".\fR)
.IP "\(bu" 4
If tha \f(CW\*(C`decimal strang \-\-> natizzle integer\*(C'\fR conversion cannot be done
without loss of shiznit, tha result is compatible wit tha conversion
sequence \f(CW\*(C`decimal_strin \-\-> native_floating_point \-\-> native_integer\*(C'\fR.
In particular, roundin is straight fuckin biased ta 0, though a number like
\&\f(CW"0.99999999999999999999"\fR has a cold-ass lil chizzle of bein rounded ta 1.
.PP
\&\fB\s-1RESTRICTION\s0\fR: Da conversions marked wit \f(CW\*(C`(*)\*(C'\fR above involve steps
performed by tha C compila n' shit.  In particular, bugs/featurez of tha compiler
used may lead ta breakage of a shitload of tha above rules.
.SH "Flavorz of Perl numeric operations"
.IX Header "Flavorz of Perl numeric operations"
Perl operations which take a numeric argument treat dat argument up in one
of four different ways: they may force it ta one of tha integer/floating/
strin formats, or they may behave differently dependin on tha format of
the operand. Y'all KNOW dat shit, muthafucka!  Forcin a numeric value ta a particular format do not
change tha number stored up in tha value.
.PP
All tha operators which need a argument up in tha integer format treat the
argument as up in modular arithmetic, e.g., \f(CW\*(C`mod 2**32\*(C'\fR on a 32\-bit
architecture.  \f(CW\*(C`sprintf "%u", \-1\*(C'\fR therefore serves up tha same result as
\&\f(CW\*(C`sprintf "%u", ~0\*(C'\fR.
.IP "Arithmetic operators" 4
.IX Item "Arithmetic operators"
Da binary operators \f(CW\*(C`+\*(C'\fR \f(CW\*(C`\-\*(C'\fR \f(CW\*(C`*\*(C'\fR \f(CW\*(C`/\*(C'\fR \f(CW\*(C`%\*(C'\fR \f(CW\*(C`==\*(C'\fR \f(CW\*(C`!=\*(C'\fR \f(CW\*(C`>\*(C'\fR \f(CW\*(C`<\*(C'\fR
\&\f(CW\*(C`>=\*(C'\fR \f(CW\*(C`<=\*(C'\fR n' tha unary operators \f(CW\*(C`\-\*(C'\fR \f(CW\*(C`abs\*(C'\fR n' \f(CW\*(C`\-\-\*(C'\fR will
attempt ta convert arguments ta integers.  If both conversions is possible
without loss of precision, n' tha operation can be performed without
loss of precision then tha integer result is used. Y'all KNOW dat shit, muthafucka!  Otherwise arguments are
converted ta floatin point format n' tha floatin point result is used.
Da cachin of conversions (as busted lyrics bout above) means dat tha integer
conversion do not throw away fractionizzle parts on floatin point numbers.
.IP "++" 4
\&\f(CW\*(C`++\*(C'\fR behaves as tha other operators above, except dat if it aint nuthin but a string
matchin tha format \f(CW\*(C`/^[a\-zA\-Z]*[0\-9]*\ez/\*(C'\fR tha strang increment busted lyrics about
in perlop is used.
.ie n .IP "Arithmetic operators durin ""use integer""" 4
.el .IP "Arithmetic operators durin \f(CWuse integer\fR" 4
.IX Item "Arithmetic operators durin use integer"
In scopes where \f(CW\*(C`use integer;\*(C'\fR is up in force, nearly all tha operators listed
above will force they argument(s) tha fuck into integer format, n' return a integer
result.  Da exceptions, \f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`++\*(C'\fR n' \f(CW\*(C`\-\-\*(C'\fR, do not chizzle their
behavior wit \f(CW\*(C`use integer;\*(C'\fR
.IP "Other mathematical operators" 4
.IX Item "Other mathematical operators"
Operators like fuckin \f(CW\*(C`**\*(C'\fR, \f(CW\*(C`sin\*(C'\fR n' \f(CW\*(C`exp\*(C'\fR force arguments ta floatin point
format.
.IP "Bitwise operators" 4
.IX Item "Bitwise operators"
Arguments is forced tha fuck into tha integer format if not strings.
.ie n .IP "Bitwise operators durin ""use integer""" 4
.el .IP "Bitwise operators durin \f(CWuse integer\fR" 4
.IX Item "Bitwise operators durin use integer"
forces arguments ta integer format fo' realz. Also shift operations internally use
signed integers rather than tha default unsigned.
.IP "Operators which expect a integer" 4
.IX Item "Operators which expect a integer"
force tha argument tha fuck into tha integer format.  This be applicable
to tha third n' fourth argumentz of \f(CW\*(C`sysread\*(C'\fR, fo' example.
.IP "Operators which expect a string" 4
.IX Item "Operators which expect a string"
force tha argument tha fuck into tha strang format.  For example, dis is
applicable ta \f(CW\*(C`printf "%s", $value\*(C'\fR.
.PP
Though forcin a argument tha fuck into a particular form do not chizzle the
stored number, Perl rethugz tha result of such conversions.  In
particular, though tha straight-up original gangsta such conversion may be time-consuming,
repeated operations aint gonna need ta redo tha conversion.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich \f(CW\*(C`ilya@math.ohio\-state.edu\*(C'\fR
.PP
Editorial adjustments by Gurusamy Sarathy <gsar@ActiveState.com>
.PP
Updates fo' 5.8.0 by Nicholas Clark <nick@ccl4.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
overload, perlop
