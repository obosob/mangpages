.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLSYN 1"
.TH PERLSYN 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlsyn \- Perl syntax
.IX Xref "syntax"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Perl program consistz of a sequence of declarations n' statements
which run from tha top ta tha bottom.  Loops, subroutines, n' other
control structures allow you ta jump round within tha code.
.PP
Perl be a \fBfree-form\fR language: you can format n' indent it however
you like.  Whitespace serves mostly ta separate tokens, unlike
languages like Python where it be a blingin part of tha syntax,
or Fortran where it is immaterial.
.PP
Many of Perlz syntactic elements is \fBoptional\fR.  Rather than
requirin you ta put parentheses round every last muthafuckin function call and
declare every last muthafuckin variable, you can often leave such explicit elements off
and Perl will figure up what tha fuck you meant.  This is known as \fBDo What I
Mean\fR, abbreviated \fB\s-1DWIM\s0\fR.  It allows programmers ta be \fBlazy\fR n' to
code up in a steez wit which they is comfortable.
.PP
Perl \fBborrows syntax\fR n' concepts from nuff languages: awk, sed, C,
Bourne Shell, Smalltalk, Lisp n' even Gangsta.  Other
languages have borrowed syntax from Perl, particularly its regular
expression extensions.  So if you have programmed up in another language
you will peep familiar pieces up in Perl.  They often work tha same yo, but
see perltrap fo' shiznit bout how tha fuck they differ.
.SS "Declarations"
.IX Xref "declaration undef undefined uninitialized"
.IX Subsection "Declarations"
Da only thangs you need ta declare up in Perl is report formats and
subroutines (and sometimes not even subroutines).  A scalar variable holds
the undefined value (\f(CW\*(C`undef\*(C'\fR) until it has been assigned a thugged-out defined
value, which be anythang other than \f(CW\*(C`undef\*(C'\fR.  When used as a number,
\&\f(CW\*(C`undef\*(C'\fR is treated as \f(CW0\fR; when used as a string, it is treated as
the empty string, \f(CW""\fR; n' when used as a reference dat aint being
assigned to, it is treated as a error. Shiiit, dis aint no joke.  If you enable warnings,
yo dirty ass is gonna be notified of a uninitialized value whenever you treat
\&\f(CW\*(C`undef\*(C'\fR as a strang or a number n' shit.  Well, usually.  Boolean contexts,
such as:
.PP
.Vb 1
\&    if ($a) {}
.Ve
.PP
are exempt from warnings (because they care bout truth rather than
definedness).  Operators like fuckin \f(CW\*(C`++\*(C'\fR, \f(CW\*(C`\-\-\*(C'\fR, \f(CW\*(C`+=\*(C'\fR,
\&\f(CW\*(C`\-=\*(C'\fR, n' \f(CW\*(C`.=\*(C'\fR, dat operate on undefined variablez such as:
.PP
.Vb 2
\&    undef $a;
\&    $a++;
.Ve
.PP
are also always exempt from such warnings.
.PP
A declaration can be put anywhere a statement can yo, but has no effect on
the execution of tha primary sequence of statements: declarations all
take effect at compile time.  All declarations is typically put at
the beginnin or tha end of tha script.  But fuck dat shiznit yo, tha word on tha street is dat if you using
lexically-scoped private variablez pimped wit \f(CW\*(C`my()\*(C'\fR,
\&\f(CW\*(C`state()\*(C'\fR, or \f(CW\*(C`our()\*(C'\fR, you gonna gotta make sure
your format or subroutine definizzle is within tha same block scope
as tha mah if you expect ta be able ta access dem private variables.
.PP
Declarin a subroutine allows a subroutine name ta be used as if it was a
list operator from dat point forward up in tha program.  Yo ass can declare a
subroutine without definin it by sayin \f(CW\*(C`sub name\*(C'\fR, thus:
.IX Xref "subroutine, declaration"
.PP
.Vb 2
\&    sub myname;
\&    $me = myname $0             or take a thugged-out dirtnap "can\*(Aqt git myname";
.Ve
.PP
A bare declaration like dat declares tha function ta be a list operator,
not a unary operator, so you gotta be careful ta use parentheses (or
\&\f(CW\*(C`or\*(C'\fR instead of \f(CW\*(C`||\*(C'\fR.)  Da \f(CW\*(C`||\*(C'\fR operator bindz too tightly ta use after
list operators; it becomes part of tha last element.  Yo ass can always use
parentheses round tha list operators arguments ta turn tha list operator
back tha fuck into suttin' dat behaves mo' like a gangbangin' function call.  Alternatively,
you can use tha prototype \f(CW\*(C`($)\*(C'\fR ta turn tha subroutine tha fuck into a unary
operator:
.PP
.Vb 2
\&  sub myname ($);
\&  $me = myname $0             || take a thugged-out dirtnap "can\*(Aqt git myname";
.Ve
.PP
That now parses as you'd expect yo, but you still ought ta git up in tha g-thang of
usin parentheses up in dat thang.  For mo' on prototypes, see
perlsub
.PP
Subroutines declarations can also be loaded up wit tha \f(CW\*(C`require\*(C'\fR statement
or both loaded n' imported tha fuck into yo' namespace wit a \f(CW\*(C`use\*(C'\fR statement.
See perlmod fo' details on all dis bullshit.
.PP
A statement sequence may contain declarationz of lexically-scoped
variablez yo, but apart from declarin a variable name, tha declaration acts
like a ordinary statement, n' is elaborated within tha sequence of
statements as if it was a ordinary statement.  That means it actually
has both compile-time n' run-time effects.
.SS "Comments"
.IX Xref "comment #"
.IX Subsection "Comments"
Text from a \f(CW"#"\fR characta until tha end of tha line be a cold-ass lil comment,
and is ignored. Y'all KNOW dat shit, muthafucka!  Exceptions include \f(CW"#"\fR inside a strang or regular
expression.
.SS "Simple Statements"
.IX Xref "statement semicolon expression ;"
.IX Subsection "Simple Statements"
Da only kind of simple statement be a expression evaluated fo' its
side-effects, n' you can put dat on yo' toast.  Every simple statement must be terminated wit a
semicolon, unless it is tha final statement up in a funky-ass block, up in which case
the semicolon is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  But put tha semicolon up in anyway if the
block takes up mo' than one line, cuz you may eventually add
another line.  Note dat there be operators like \f(CW\*(C`eval {}\*(C'\fR, \f(CW\*(C`sub {}\*(C'\fR, and
\&\f(CW\*(C`do {}\*(C'\fR dat \fIlook\fR like compound statements yo, but aren't\*(--they just
TERMs up in a expression\*(--and thus need a explicit termination when used
as tha last item up in a statement.
.SS "Truth n' Falsehood"
.IX Xref "truth falsehood legit false ! not negation 0"
.IX Subsection "Truth n' Falsehood"
Da number 0, tha strings \f(CW\*(Aq0\*(Aq\fR n' \f(CW""\fR, tha empty list \f(CW\*(C`()\*(C'\fR, and
\&\f(CW\*(C`undef\*(C'\fR is all false up in a funky-ass boolean context.  All other joints is true.
Negation of a legit value by \f(CW\*(C`!\*(C'\fR or \f(CW\*(C`not\*(C'\fR returns a special false value.
When evaluated as a strang it is treated as \f(CW""\fR yo, but as a number, it
is treated as 0.  Most Perl operators
that return legit or false behave dis way.
.SS "Statement Modifiers"
.IX Xref "statement modifier modifier if unless while until when foreach for"
.IX Subsection "Statement Modifiers"
Any simple statement may optionally be followed by a \fI\s-1SINGLE\s0\fR modifier,
just before tha terminatin semicolon (or block ending).  Da possible
modifiers are:
.PP
.Vb 7
\&    if EXPR
\&    unless EXPR
\&    while EXPR
\&    until EXPR
\&    fo' LIST
\&    foreach LIST
\&    when EXPR
.Ve
.PP
Da \f(CW\*(C`EXPR\*(C'\fR followin tha modifier is referred ta as tha \*(L"condition\*(R".
Its truth or falsehood determines how tha fuck tha modifier will behave.
.PP
\&\f(CW\*(C`if\*(C'\fR executes tha statement once \fIif\fR n' only if tha condizzle is
true.  \f(CW\*(C`unless\*(C'\fR is tha opposite, it executes tha statement \fIunless\fR
the condizzle is legit (that is, if tha condizzle is false).
.PP
.Vb 2
\&    print "Basset houndz gots long ears" if length $ear >= 10;
\&    go_outside() n' play() unless $is_raining;
.Ve
.PP
Da \f(CW\*(C`for(each)\*(C'\fR modifier be a iterator: it executes tha statement once
for each item up in tha \s-1LIST \s0(with \f(CW$_\fR aliased ta each item up in turn).
.PP
.Vb 1
\&    print "Wuz crackalackin' $_!\en" fo' qw(world Dolly nurse);
.Ve
.PP
\&\f(CW\*(C`while\*(C'\fR repeats tha statement \fIwhile\fR tha condizzle is true.
\&\f(CW\*(C`until\*(C'\fR do tha opposite, it repeats tha statement \fIuntil\fR the
condizzle is legit (or while tha condizzle is false):
.PP
.Vb 3
\&    # Both of these count from 0 ta 10.
\&    print $i++ while $i <= 10;
\&    print $j++ until $j >  10;
.Ve
.PP
Da \f(CW\*(C`while\*(C'\fR n' \f(CW\*(C`until\*(C'\fR modifiers have tha usual "\f(CW\*(C`while\*(C'\fR loop"
semantics (conditionizzle evaluated first), except when applied ta a
\&\f(CW\*(C`do\*(C'\fR\-BLOCK (or ta tha Perl4 \f(CW\*(C`do\*(C'\fR\-SUBROUTINE statement), in
which case tha block executes once before tha conditionizzle is
evaluated.
.PP
This is so dat you can write loops like:
.PP
.Vb 4
\&    do {
\&        $line = <STDIN>;
\&        ...
\&    } until !defined($line) || $line eq ".\en"
.Ve
.PP
See \*(L"do\*(R" up in perlfunc.  Note also dat tha loop control statements busted lyrics about
lata will \fI\s-1NOT\s0\fR work up in dis construct, cuz modifiers don't take
loop labels.  Sorry.  Yo ass can always put another block inside of it
(for \f(CW\*(C`next\*(C'\fR) or round it (for \f(CW\*(C`last\*(C'\fR) ta do dat sort of thang.
For \f(CW\*(C`next\*(C'\fR, just double tha braces:
.IX Xref "next last redo"
.PP
.Vb 4
\&    do {{
\&        next if $x == $y;
\&        # do suttin' here
\&    }} until $x++ > $z;
.Ve
.PP
For \f(CW\*(C`last\*(C'\fR, you gotta be mo' elaborate:
.IX Xref "last"
.PP
.Vb 6
\&    LOOP: { 
\&            do {
\&                last if $x = $y**2;
\&                # do suttin' here
\&            } while $x++ <= $z;
\&    }
.Ve
.PP
\&\fB\s-1NOTE:\s0\fR Da behaviour of a \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`state\*(C'\fR, or
\&\f(CW\*(C`our\*(C'\fR modified wit a statement modifier conditional
or loop construct (for example, \f(CW\*(C`my $x if ...\*(C'\fR) is
\&\fBundefined\fR.  Da value of tha \f(CW\*(C`my\*(C'\fR variable may be \f(CW\*(C`undef\*(C'\fR, any
previously assigned value, or possibly anythang else.  Don't rely on
it.  Future versionz of perl might do suttin' different from the
version of perl you try it up on. I aint talkin' bout chicken n' gravy biatch.  Here be dragons.
.IX Xref "my"
.PP
Da \f(CW\*(C`when\*(C'\fR modifier be a experimenstrual feature dat first rocked up in Perl
5.14.  To use it, you should include a \f(CW\*(C`use v5.14\*(C'\fR declaration.
(Technically, it requires only tha \f(CW\*(C`switch\*(C'\fR feature yo, but dat aspect of it
was not available before 5.14.)  Operatizzle only from within a \f(CW\*(C`foreach\*(C'\fR
loop or a \f(CW\*(C`given\*(C'\fR block, it executes tha statement only if tha smartmatch
\&\f(CW\*(C`$_ ~~ \f(CIEXPR\f(CW\*(C'\fR is true.  If tha statement executes, it is followed by
a \f(CW\*(C`next\*(C'\fR from inside a \f(CW\*(C`foreach\*(C'\fR n' \f(CW\*(C`break\*(C'\fR from inside a \f(CW\*(C`given\*(C'\fR.
.PP
Under tha current implementation, tha \f(CW\*(C`foreach\*(C'\fR loop can be
anywhere within tha \f(CW\*(C`when\*(C'\fR modifierz dynamic scope yo, but must be
within tha \f(CW\*(C`given\*(C'\fR blockz lexical scope.  This restricted may
be chillaxed up in a gangbangin' future release.  See \*(L"Switch Statements\*(R" below.
.SS "Compound Statements"
.IX Xref "statement, compound block bracket, curly curly bracket brace { } if unless given while until foreach fo' continue"
.IX Subsection "Compound Statements"
In Perl, a sequence of statements dat defines a scope is called a funky-ass block.
Sometimes a funky-ass block is delimited by tha file containin it (in tha case
of a required file, or tha program as a whole), n' sometimes a funky-ass block
is delimited by tha extent of a strang (in tha case of a eval).
.PP
But generally, a funky-ass block is delimited by curly brackets, also known as braces.
Us thugs will call dis syntactic construct a \s-1BLOCK.\s0
.PP
Da followin compound statements may be used ta control flow:
.PP
.Vb 4
\&    if (EXPR) BLOCK
\&    if (EXPR) BLOCK else BLOCK
\&    if (EXPR) BLOCK elsif (EXPR) BLOCK ...
\&    if (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
\&
\&    unless (EXPR) BLOCK
\&    unless (EXPR) BLOCK else BLOCK
\&    unless (EXPR) BLOCK elsif (EXPR) BLOCK ...
\&    unless (EXPR) BLOCK elsif (EXPR) BLOCK ... else BLOCK
\&
\&    given (EXPR) BLOCK
\&
\&    LABEL while (EXPR) BLOCK
\&    LABEL while (EXPR) BLOCK continue BLOCK
\&
\&    LABEL until (EXPR) BLOCK
\&    LABEL until (EXPR) BLOCK continue BLOCK
\&
\&    LABEL fo' (EXPR; EXPR; EXPR) BLOCK
\&    LABEL fo' VAR (LIST) BLOCK
\&    LABEL fo' VAR (LIST) BLOCK continue BLOCK
\&
\&    LABEL foreach (EXPR; EXPR; EXPR) BLOCK
\&    LABEL foreach VAR (LIST) BLOCK
\&    LABEL foreach VAR (LIST) BLOCK continue BLOCK
\&
\&    LABEL BLOCK
\&    LABEL BLOCK continue BLOCK
\&
\&    PHASE BLOCK
.Ve
.PP
Da experimenstrual \f(CW\*(C`given\*(C'\fR statement is \fInot automatically enabled\fR; peep 
\&\*(L"Switch Statements\*(R" below fo' how tha fuck ta do so, n' tha attendant caveats.
.PP
Unlike up in C n' Pascal, up in Perl these is all defined up in termz of BLOCKs,
not statements, n' you can put dat on yo' toast.  This means dat tha curly brackets is \fIrequired\fR\-\-no
danglin statements allowed. Y'all KNOW dat shit, muthafucka!  If you wanna write conditionals without
curly brackets, there be nuff muthafuckin other ways ta do dat shit.  Da following
all do tha same thang:
.PP
.Vb 5
\&    if (!open(FOO)) { take a thugged-out dirtnap "Can\*(Aqt open $FOO: $!" }
\&    take a thugged-out dirtnap "Can\*(Aqt open $FOO: $!" unless open(FOO);
\&    open(FOO)  || take a thugged-out dirtnap "Can\*(Aqt open $FOO: $!";
\&    open(FOO) ? () : take a thugged-out dirtnap "Can\*(Aqt open $FOO: $!";
\&                        # a lil' bit exotic, dat last one
.Ve
.PP
Da \f(CW\*(C`if\*(C'\fR statement is straightforward. Y'all KNOW dat shit, muthafucka!  Because BLOCKs is always
bounded by curly brackets, there is never any ambiguitizzle bout which
\&\f(CW\*(C`if\*(C'\fR a \f(CW\*(C`else\*(C'\fR goes with.  If you use \f(CW\*(C`unless\*(C'\fR up in place of \f(CW\*(C`if\*(C'\fR,
the sense of tha test is reversed. Y'all KNOW dat shit, muthafucka!  Like \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`unless\*(C'\fR can be followed
by \f(CW\*(C`else\*(C'\fR.  \f(CW\*(C`unless\*(C'\fR can even be followed by one or mo' \f(CW\*(C`elsif\*(C'\fR
statements, though you may wanna be thinkin twice before rockin dat particular
language construct, as mah playas readin yo' code will gotta be thinkin at least
twice before they can KNOW what tha fuck be happenin.
.PP
Da \f(CW\*(C`while\*(C'\fR statement executes tha block as long as tha expression is
true.
Da \f(CW\*(C`until\*(C'\fR statement executes tha block as long as tha expression is
false.
Da \s-1LABEL\s0 is optional, n' if present, consistz of a identifier followed
by a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch.  Da \s-1LABEL\s0 identifies tha loop fo' tha loop control
statements \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, n' \f(CW\*(C`redo\*(C'\fR.
If tha \s-1LABEL\s0 is omitted, tha loop control statement
refers ta tha innermost enclosin loop.  This may include dynamically
lookin back yo' call-stack at run time ta find tha \s-1LABEL. \s0 Such
desperate behavior triggers a warnin if you use tha \f(CW\*(C`use warnings\*(C'\fR
pragma or tha \fB\-w\fR flag.
.PP
If there be a \f(CW\*(C`continue\*(C'\fR \s-1BLOCK,\s0 it be always executed just before the
conditionizzle be bout ta be evaluated again. I aint talkin' bout chicken n' gravy biatch.  Thus it can be used to
increment a loop variable, even when tha loop has been continued via
the \f(CW\*(C`next\*(C'\fR statement.
.PP
When a funky-ass block is precedin by a cold-ass lil compilation phase keyword like fuckin \f(CW\*(C`BEGIN\*(C'\fR,
\&\f(CW\*(C`END\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, or \f(CW\*(C`UNITCHECK\*(C'\fR, then tha block will run only
durin tha correspondin phase of execution. I aint talkin' bout chicken n' gravy biatch.  See perlmod fo' mo' details.
.PP
Extension modulez can also hook tha fuck into tha Perl parser ta define new
kindz of compound statements, n' you can put dat on yo' toast.  These is introduced by a keyword which
the extension recognizes, n' tha syntax followin tha keyword is
defined entirely by tha extension. I aint talkin' bout chicken n' gravy biatch.  If yo ass be a implementor, see
\&\*(L"PL_keyword_plugin\*(R" up in perlapi fo' tha mechanism.  If yo ass is rockin such
a module, peep tha modulez documentation fo' detailz of tha syntax that
it defines.
.SS "Loop Control"
.IX Xref "loop control loop, control next last redo continue"
.IX Subsection "Loop Control"
Da \f(CW\*(C`next\*(C'\fR command starts tha next iteration of tha loop:
.PP
.Vb 4
\&    LINE: while (<STDIN>) {
\&        next LINE if /^#/;      # discard comments
\&        ...
\&    }
.Ve
.PP
Da \f(CW\*(C`last\*(C'\fR command immediately exits tha loop up in question. I aint talkin' bout chicken n' gravy biatch.  The
\&\f(CW\*(C`continue\*(C'\fR block, if any, aint executed:
.PP
.Vb 4
\&    LINE: while (<STDIN>) {
\&        last LINE if /^$/;      # exit when done wit header
\&        ...
\&    }
.Ve
.PP
Da \f(CW\*(C`redo\*(C'\fR command restarts tha loop block without evaluatin the
conditionizzle again. I aint talkin' bout chicken n' gravy biatch.  Da \f(CW\*(C`continue\*(C'\fR block, if any, is \fInot\fR executed.
This command is normally used by programs dat wanna lie ta theyselves
about what tha fuck was just input.
.PP
For example, when processin a gangbangin' file like \fI/etc/termcap\fR.
If yo' input lines might end up in backslashes ta indicate continuation, you
wanna skip ahead n' git tha next record.
.PP
.Vb 8
\&    while (<>) {
\&        chomp;
\&        if (s/\e\e$//) {
\&            $_ .= <>;
\&            redo unless eof();
\&        }
\&        # now process $_
\&    }
.Ve
.PP
which is Perl shorthand fo' tha mo' explicitly freestyled version:
.PP
.Vb 8
\&    LINE: while (defined($line = <ARGV>)) {
\&        chomp($line);
\&        if ($line =~ s/\e\e$//) {
\&            $line .= <ARGV>;
\&            redo LINE unless eof(); # not eof(ARGV)!
\&        }
\&        # now process $line
\&    }
.Ve
.PP
Note dat if there was a \f(CW\*(C`continue\*(C'\fR block on tha above code, it would
get executed only on lines discarded by tha regex (since redo skips the
continue block).  A continue block is often used ta reset line counters
or \f(CW\*(C`m?pat?\*(C'\fR one-time matches:
.PP
.Vb 10
\&    # inspired by :1,$g/fred/s//WILMA/
\&    while (<>) {
\&        m?(fred)?    && s//WILMA $1 WILMA/;
\&        m?(barney)?  && s//BETTY $1 BETTY/;
\&        m?(homer)?   && s//MARGE $1 MARGE/;
\&    } continue {
\&        print "$ARGV $.: $_";
\&        close ARGV  if eof;             # reset $.
\&        reset       if eof;             # reset ?pat?
\&    }
.Ve
.PP
If tha word \f(CW\*(C`while\*(C'\fR is replaced by tha word \f(CW\*(C`until\*(C'\fR, tha sense of the
test is reversed yo, but tha conditionizzle is still tested before tha first
iteration.
.PP
Loop control statements don't work up in a \f(CW\*(C`if\*(C'\fR or \f(CW\*(C`unless\*(C'\fR, since
they aren't loops.  Yo ass can double tha braces ta make dem such, though.
.PP
.Vb 6
\&    if (/pattern/) {{
\&        last if /fred/;
\&        next if /barney/; # same effect as "last",
\&                          # but don\*(Aqt document as well
\&        # do suttin' here
\&    }}
.Ve
.PP
This is caused by tha fact dat a funky-ass block by itself acts as a loop that
executes once, peep \*(L"Basic BLOCKs\*(R".
.PP
Da form \f(CW\*(C`while/if BLOCK BLOCK\*(C'\fR, available up in Perl 4, is no longer
available.   Replace any occurrence of \f(CW\*(C`if BLOCK\*(C'\fR by \f(CW\*(C`if (do BLOCK)\*(C'\fR.
.SS "For Loops"
.IX Xref "for foreach"
.IX Subsection "For Loops"
Perlz C\-style \f(CW\*(C`for\*(C'\fR loop works like tha correspondin \f(CW\*(C`while\*(C'\fR loop;
that means dat this:
.PP
.Vb 3
\&    fo' ($i = 1; $i < 10; $i++) {
\&        ...
\&    }
.Ve
.PP
is tha same ol' dirty as this:
.PP
.Vb 6
\&    $i = 1;
\&    while ($i < 10) {
\&        ...
\&    } continue {
\&        $i++;
\&    }
.Ve
.PP
There is one minor difference: if variablez is declared wit \f(CW\*(C`my\*(C'\fR
in tha initialization section of tha \f(CW\*(C`for\*(C'\fR, tha lexical scope of
those variablez is exactly tha \f(CW\*(C`for\*(C'\fR loop (the body of tha loop
and tha control sections).
.IX Xref "my"
.PP
Besides tha aiiight array index looping, \f(CW\*(C`for\*(C'\fR can lend itself
to nuff other bangin-ass applications.  Herez one dat avoidz the
problem you git tha fuck into if you explicitly test fo' end-of-file on
an interactizzle file descriptor causin yo' program ta step tha fuck up to
hang.
.IX Xref "eof end-of-file end of file"
.PP
.Vb 5
\&    $on_a_tty = \-t STDIN && \-t STDOUT;
\&    sub prompt { print "yes? " if $on_a_tty }
\&    fo' ( prompt(); <STDIN>; prompt() ) {
\&        # do something
\&    }
.Ve
.PP
Usin \f(CW\*(C`readline\*(C'\fR (or tha operator form, \f(CW\*(C`<EXPR>\*(C'\fR) as the
conditionizzle of a \f(CW\*(C`for\*(C'\fR loop is shorthand fo' tha following.  This
behaviour is tha same ol' dirty as a \f(CW\*(C`while\*(C'\fR loop conditional.
.IX Xref "readline <>"
.PP
.Vb 3
\&    fo' ( prompt(); defined( $_ = <STDIN> ); prompt() ) {
\&        # do something
\&    }
.Ve
.SS "Foreach Loops"
.IX Xref "for foreach"
.IX Subsection "Foreach Loops"
Da \f(CW\*(C`foreach\*(C'\fR loop iterates over a aiiight list value n' sets the
variable \s-1VAR\s0 ta be each element of tha list up in turn, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  If tha variable
is preceded wit tha keyword \f(CW\*(C`my\*(C'\fR, then it is lexically scoped, and
is therefore visible only within tha loop.  Otherwise, tha variable is
implicitly local ta tha loop n' regains its forma value upon exiting
the loop.  If tha variable was previously declared wit \f(CW\*(C`my\*(C'\fR, it uses
that variable instead of tha global one yo, but itz still localized to
the loop.  This implicit localization occurs \fIonly\fR up in a \f(CW\*(C`foreach\*(C'\fR
loop.
.IX Xref "my local"
.PP
Da \f(CW\*(C`foreach\*(C'\fR keyword is straight-up a synonym fo' tha \f(CW\*(C`for\*(C'\fR keyword, so
you can use either n' shit.  If \s-1VAR\s0 is omitted, \f(CW$_\fR is set ta each value.
.IX Xref "$_"
.PP
If any element of \s-1LIST\s0 be a lvalue, you can modify it by modifying
\&\s-1VAR\s0 inside tha loop.  Conversely, if any element of \s-1LIST\s0 is \s-1NOT\s0 an
lvalue, any attempt ta modify dat element will fail.  In other lyrics,
the \f(CW\*(C`foreach\*(C'\fR loop index variable be a implicit alias fo' each item
in tha list dat you loopin over.
.IX Xref "alias"
.PP
If any part of \s-1LIST\s0 be a array, \f(CW\*(C`foreach\*(C'\fR will git straight-up trippin if
you add or remove elements within tha loop body, fo' example with
\&\f(CW\*(C`splice\*(C'\fR.   So don't do dis shit.
.IX Xref "splice"
.PP
\&\f(CW\*(C`foreach\*(C'\fR probably won't do what tha fuck you expect if \s-1VAR\s0 be a tied or other
special variable.   Don't do dat either.
.PP
Examples:
.PP
.Vb 1
\&    fo' (@ary) { s/foo/bar/ }
\&
\&    fo' mah $elem (@elements) {
\&        $elem *= 2;
\&    }
\&
\&    fo' $count (reverse(1..10), "BOOM") {
\&        print $count, "\en";
\&        chill(1);
\&    }
\&
\&    fo' (1..15) { print "Merry Chrizzle\en"; }
\&
\&    foreach $item (split(/:[\e\e\en:]*/, $ENV{TERMCAP})) {
\&        print "Item: $item\en";
\&    }
.Ve
.PP
Herez how tha fuck a C programmer might code up a particular algorithm up in Perl:
.PP
.Vb 9
\&    fo' (my $i = 0; $i < @ary1; $i++) {
\&        fo' (my $j = 0; $j < @ary2; $j++) {
\&            if ($ary1[$i] > $ary2[$j]) {
\&                last; # can\*(Aqt git all up in outa :\-(
\&            }
\&            $ary1[$i] += $ary2[$j];
\&        }
\&        # dis is where dat last takes me
\&    }
.Ve
.PP
Whereas herez how tha fuck a Perl programmer mo' laid back wit tha idiom might
do it:
.PP
.Vb 6
\&    OUTER: fo' mah $wid (@ary1) {
\&    INNER:   fo' mah $jet (@ary2) {
\&                next OUTER if $wid > $jet;
\&                $wid += $jet;
\&             }
\&          }
.Ve
.PP
See how tha fuck much easier dis is?  It aint nuthin but cleaner, safer, n' fasta n' shit.  It's
cleaner cuz itz less noisy.  It aint nuthin but less thuggy cuz if code gets added
between tha inner n' outa loops lata on, tha freshly smoked up code won't be
accidentally executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \f(CW\*(C`next\*(C'\fR explicitly iterates tha other loop
rather than merely terminatin tha inner one.  And itz fasta cuz
Perl executes a \f(CW\*(C`foreach\*(C'\fR statement mo' rapidly than it would the
equivalent \f(CW\*(C`for\*(C'\fR loop.
.SS "Basic BLOCKs"
.IX Xref "block"
.IX Subsection "Basic BLOCKs"
A \s-1BLOCK\s0 by itself (labeled or not) is semantically equivalent ta a
loop dat executes once.  Thus you can use any of tha loop control
statements up in it ta leave or restart tha block.  (Note dat dis is
\&\fI\s-1NOT\s0\fR legit up in \f(CW\*(C`eval{}\*(C'\fR, \f(CW\*(C`sub{}\*(C'\fR, or contrary ta ghettofab belief
\&\f(CW\*(C`do{}\*(C'\fR blocks, which do \fI\s-1NOT\s0\fR count as loops.)  Da \f(CW\*(C`continue\*(C'\fR
block is optional.
.PP
Da \s-1BLOCK\s0 construct can be used ta emulate case structures.
.PP
.Vb 6
\&    SWITCH: {
\&        if (/^abc/) { $abc = 1; last SWITCH; }
\&        if (/^def/) { $def = 1; last SWITCH; }
\&        if (/^xyz/) { $xyz = 1; last SWITCH; }
\&        $nothang = 1;
\&    }
.Ve
.PP
You'll also find dat \f(CW\*(C`foreach\*(C'\fR loop used ta create a topicalizer
and a switch:
.PP
.Vb 7
\&    SWITCH:
\&    fo' ($var) {
\&        if (/^abc/) { $abc = 1; last SWITCH; }
\&        if (/^def/) { $def = 1; last SWITCH; }
\&        if (/^xyz/) { $xyz = 1; last SWITCH; }
\&        $nothang = 1;
\&    }
.Ve
.PP
Such constructs is like frequently used, both cuz olda versions of
Perl had no straight-up legit \f(CW\*(C`switch\*(C'\fR statement, n' also cuz tha freshly smoked up version
busted lyrics bout immediately below remains experimenstrual n' can sometimes be confusing.
.SS "Switch Statements"
.IX Subsection "Switch Statements"

.IX Xref "switch case given when default"
.PP
Startin from Perl 5.10.1 (well, 5.10.0 yo, but it didn't work
right), you can say
.PP
.Vb 1
\&    use feature "switch";
.Ve
.PP
to enable a experimenstrual switch feature.  This is loosely based on an
old version of a Perl 6 proposal yo, but it no longer resemblez tha Perl 6
construct.   Yo ass also git tha switch feature whenever you declare dat your
code prefers ta run under a version of Perl dat is 5.10 or later n' shit.  For
example:
.PP
.Vb 1
\&    use v5.14;
.Ve
.PP
Under tha \*(L"switch\*(R" feature, Perl gains tha experimenstrual keywords
\&\f(CW\*(C`given\*(C'\fR, \f(CW\*(C`when\*(C'\fR, \f(CW\*(C`default\*(C'\fR, \f(CW\*(C`continue\*(C'\fR, n' \f(CW\*(C`break\*(C'\fR.
Startin from Perl 5.16, one can prefix tha switch
keywordz wit \f(CW\*(C`CORE::\*(C'\fR ta access tha feature without a \f(CW\*(C`use feature\*(C'\fR
statement.  Da keywordz \f(CW\*(C`given\*(C'\fR and
\&\f(CW\*(C`when\*(C'\fR is analogous ta \f(CW\*(C`switch\*(C'\fR and
\&\f(CW\*(C`case\*(C'\fR up in other languages, so tha code up in tha previous section could be
rewritten as
.PP
.Vb 7
\&    use v5.10.1;
\&    fo' ($var) {
\&        when (/^abc/) { $abc = 1 }
\&        when (/^def/) { $def = 1 }
\&        when (/^xyz/) { $xyz = 1 }
\&        default       { $nothang = 1 }
\&    }
.Ve
.PP
Da \f(CW\*(C`foreach\*(C'\fR is tha non-experimenstrual way ta set a topicalizer.
If you wish ta use tha highly experimenstrual \f(CW\*(C`given\*(C'\fR, dat could be
written like this:
.PP
.Vb 7
\&    use v5.10.1;
\&    given ($var) {
\&        when (/^abc/) { $abc = 1 }
\&        when (/^def/) { $def = 1 }
\&        when (/^xyz/) { $xyz = 1 }
\&        default       { $nothang = 1 }
\&    }
.Ve
.PP
Az of 5.14, dat can also be freestyled dis way:
.PP
.Vb 7
\&    use v5.14;
\&    fo' ($var) {
\&        $abc = 1 when /^abc/;
\&        $def = 1 when /^def/;
\&        $xyz = 1 when /^xyz/;
\&        default { $nothang = 1 }
\&    }
.Ve
.PP
Or if you couldn't give a fuckin shiznit ta play it safe, like this:
.PP
.Vb 7
\&    use v5.14;
\&    given ($var) {
\&        $abc = 1 when /^abc/;
\&        $def = 1 when /^def/;
\&        $xyz = 1 when /^xyz/;
\&        default { $nothang = 1 }
\&    }
.Ve
.PP
Da arguments ta \f(CW\*(C`given\*(C'\fR n' \f(CW\*(C`when\*(C'\fR is up in scalar context,
and \f(CW\*(C`given\*(C'\fR assigns tha \f(CW$_\fR variable its topic value.
.PP
Exactly what tha fuck tha \fI\s-1EXPR\s0\fR argument ta \f(CW\*(C`when\*(C'\fR do is hard ta describe
precisely yo, but up in general, it tries ta guess what tha fuck you want done.  Sometimes
it is interpreted as \f(CW\*(C`$_ ~~ \f(CIEXPR\f(CW\*(C'\fR, n' sometimes it is not.  It
also behaves differently when lexically enclosed by a \f(CW\*(C`given\*(C'\fR block than
it do when dynamically enclosed by a \f(CW\*(C`foreach\*(C'\fR loop.  Da rulez is far
too hard as fuck ta KNOW ta be busted lyrics bout here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  See \*(L"Experimenstrual Details
on given n' when\*(R" lata on.
.PP
Cuz of a fucked up bug up in how tha fuck \f(CW\*(C`given\*(C'\fR was implemented between Perl 5.10
and 5.16, under dem implementations tha version of \f(CW$_\fR governed by
\&\f(CW\*(C`given\*(C'\fR is merely a lexically scoped copy of tha original, not a
dynamically scoped alias ta tha original, as it would be if it was a
\&\f(CW\*(C`foreach\*(C'\fR or under both tha original gangsta n' tha current Perl 6 language
specification. I aint talkin' bout chicken n' gravy biatch.  This bug was fixed up in Perl
5.18.  If you straight-up want a lexical \f(CW$_\fR,
specify dat explicitly yo, but note dat \f(CW\*(C`my $_\*(C'\fR
is now deprecated n' will warn unless warnings
have been disabled:
.PP
.Vb 1
\&    given(my $_ = EXPR) { ... }
.Ve
.PP
If yo' code still need ta run on olda versions,
stick ta \f(CW\*(C`foreach\*(C'\fR fo' yo' topicalizer and
you is ghon be less bugged out.
.SS "Goto"
.IX Xref "goto"
.IX Subsection "Goto"
Although not fo' tha faint of ass, Perl do support a \f(CW\*(C`goto\*(C'\fR
statement.  There is three forms: \f(CW\*(C`goto\*(C'\fR\-LABEL, \f(CW\*(C`goto\*(C'\fR\-EXPR, and
\&\f(CW\*(C`goto\*(C'\fR\-&NAME.  A loopz \s-1LABEL\s0 aint straight-up a valid target for
a \f(CW\*(C`goto\*(C'\fR; itz just tha name of tha loop.
.PP
Da \f(CW\*(C`goto\*(C'\fR\-LABEL form findz tha statement labeled wit \s-1LABEL\s0 n' resumes
execution there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  It may not be used ta go tha fuck into any construct that
requires initialization, like fuckin a subroutine or a \f(CW\*(C`foreach\*(C'\fR loop.  It
also can't be used ta go tha fuck into a cold-ass lil construct dat is optimized away.  It
can be used ta go almost anywhere else within tha dynamic scope,
includin outta subroutines yo, but itz probably betta ta use some other
construct like fuckin \f(CW\*(C`last\*(C'\fR or \f(CW\*(C`die\*(C'\fR.  Da lyricist of Perl has never felt the
need ta use dis form of \f(CW\*(C`goto\*(C'\fR (in Perl, dat is\*(--C be another matter).
.PP
Da \f(CW\*(C`goto\*(C'\fR\-EXPR form expects a label name, whose scope is ghon be resolved
dynamically.  This allows fo' computed \f(CW\*(C`goto\*(C'\fRs per \s-1FORTRAN,\s0 but aint
necessarily recommended if you optimizin fo' maintainability:
.PP
.Vb 1
\&    goto(("FOO", "BAR", "GLARCH")[$i]);
.Ve
.PP
Da \f(CW\*(C`goto\*(C'\fR\-&NAME form is highly magical, n' substitutes a cold-ass lil call ta the
named subroutine fo' tha currently hustlin subroutine.  This is used by
\&\f(CW\*(C`AUTOLOAD()\*(C'\fR subroutines dat wish ta load another subroutine n' then
pretend dat tha other subroutine had been called up in tha straight-up original gangsta place
(except dat any modifications ta \f(CW@_\fR up in tha current subroutine are
propagated ta tha other subroutine.)  Afta tha \f(CW\*(C`goto\*(C'\fR, not even \f(CW\*(C`caller()\*(C'\fR
will be able ta tell dat dis routine was called first.
.PP
In almost all cases like this, itz probably a gangbangin' far, far betta scam ta use the
structured control flow mechanizzlez of \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`last\*(C'\fR, or \f(CW\*(C`redo\*(C'\fR instead of
resortin ta a \f(CW\*(C`goto\*(C'\fR.  For certain applications, tha catch n' throw pair of
\&\f(CW\*(C`eval{}\*(C'\fR n' \fIdie()\fR fo' exception processin can also be a prudent approach.
.SS "Da Ellipsis Statement"
.IX Xref "... ... statement ellipsis operator elliptical statement unimplemented statement unimplemented operator yada-yada yada-yada operator ... operator whatever operator triple-dot operator"
.IX Subsection "Da Ellipsis Statement"
Beginnin up in Perl 5.12, Perl accepts a ellipsis, "\f(CW\*(C`...\*(C'\fR", as a
placeholda fo' code dat you aint implemented yet.  This form of
ellipsis, tha unimplemented statement, should not be trippin wit the
binary flip-flop \f(CW\*(C`...\*(C'\fR operator. Shiiit, dis aint no joke.  One be a statement n' tha other an
operator. Shiiit, dis aint no joke.  (Perl don't probably confuse dem cuz probably Perl can tell
whether it wants a operator or a statement yo, but peep below fo' exceptions.)
.PP
When Perl 5.12 or lata encountas a ellipsis statement, it parses this
without error yo, but if n' when you should straight-up try ta execute it, Perl
throws a exception wit tha text \f(CW\*(C`Unimplemented\*(C'\fR:
.PP
.Vb 6
\&    use v5.12;
\&    sub unimplemented { ... }
\&    eval { unimplemented() };
\&    if ($@ =~ /^Unimplemented at /) {
\&        say "I found a ellipsis!";
\&    }
.Ve
.PP
Yo ass can only use tha elliptical statement ta stand up in fo' a
complete statement.  These examplez of how tha fuck tha ellipsis works:
.PP
.Vb 10
\&    use v5.12;
\&    { ... }
\&    sub foo { ... }
\&    ...;
\&    eval { ... };
\&    sub somemeth {
\&        mah $self = shift;
\&        ...;
\&    }
\&    $x = do {
\&        mah $n;
\&        ...;
\&        say "Hurrah!";
\&        $n;
\&    };
.Ve
.PP
Da elliptical statement cannot stand up in fo' a expression that
is part of a larger statement, since tha \f(CW\*(C`...\*(C'\fR be also tha three-dot
version of tha flip-flop operator (see \*(L"Range Operators\*(R" up in perlop).
.PP
These examplez of attempts ta use a ellipsis is syntax errors:
.PP
.Vb 1
\&    use v5.12;
\&
\&    print ...;
\&    open(my $fh, ">", "/dev/passwd") or ...;
\&    if ($condizzle && ... ) { say "Howdy" };
.Ve
.PP
There is some cases where Perl can't immediately tell tha difference
between a expression n' a statement.  For instance, tha syntax fo' a
block n' a anonymous hash reference constructor look tha same unless
therez suttin' up in tha braces ta give Perl a hint.  Da ellipsis be a
syntax error if Perl don't guess dat tha \f(CW\*(C`{ ... }\*(C'\fR be a funky-ass block.  In that
case, it don't be thinkin tha \f(CW\*(C`...\*(C'\fR be a ellipsis cuz itz expectin an
expression instead of a statement:
.PP
.Vb 1
\&    @transformed = map { ... } @input;  # syntax error
.Ve
.PP
Yo ass can bust a \f(CW\*(C`;\*(C'\fR inside yo' block ta denote dat tha \f(CW\*(C`{ ...  }\*(C'\fR be a
block n' not a hash reference constructor. Shiiit, dis aint no joke.  Now tha ellipsis works:
.PP
.Vb 1
\&    @transformed = map {; ... } @input; # ; disambiguates
\&
\&    @transformed = map { ...; } @input; # ; disambiguates
.Ve
.PP
Note: Some folks colloquially refer ta dis bit of punctuation as a
\&\*(L"yada-yada\*(R" or \*(L"triple-dot\*(R" yo, but its legit name
is straight-up a ellipsis.  Perl do not yet
accept tha Unicode version, U+2026 \s-1HORIZONTAL ELLIPSIS,\s0 as a alias for
\&\f(CW\*(C`...\*(C'\fR yo, but somedizzle it may.
.SS "PODs: Embedded Documentation"
.IX Xref "POD documentation"
.IX Subsection "PODs: Embedded Documentation"
Perl has a mechanizzle fo' intermixin documentation wit source code.
While itz expectin tha beginnin of a freshly smoked up statement, if tha compiler
encountas a line dat begins wit a equal sign n' a word, like this
.PP
.Vb 1
\&    =head1 Here There Be Pods!
.Ve
.PP
Then dat text n' all remainin text up all up in n' includin a line
beginnin wit \f(CW\*(C`=cut\*(C'\fR is ghon be ignored. Y'all KNOW dat shit, muthafucka!  Da format of tha intervening
text is busted lyrics bout up in perlpod.
.PP
This allows you ta intermix yo' source code
and yo' documentation text freely, as in
.PP
.Vb 1
\&    =item snazzle($)
\&
\&    Da snazzle() function will behave up in da most thugged-out spectacular
\&    form dat you can possibly imagine, not even excepting
\&    cybernetic pyrotechnics.
\&
\&    =cut back ta tha compiler, nuff of dis pod stuff!
\&
\&    sub snazzle($) {
\&        mah $thingie = shift;
\&        .........
\&    }
.Ve
.PP
Note dat pod translators should peep only paragraphs beginning
with a pod directizzle (it make parsin easier), whereas tha compiler
actually knows ta look fo' pod escapes even up in tha middle of a
paragraph.  This means dat tha followin secret shiznit will be
ignored by both tha compila n' tha translators.
.PP
.Vb 5
\&    $a=3;
\&    =secret stuff
\&     warn "Neither POD nor CODE!?"
\&    =cut back
\&    print "got $a\en";
.Ve
.PP
Yo ass probably shouldn't rely upon tha \f(CW\*(C`warn()\*(C'\fR bein podded up alllll muthafuckin day.
Not all pod translators is well-behaved up in dis regard, n' like
the compila will become pickier.
.PP
One may also use pod directives ta quickly comment up a section
of code.
.SS "Plain Oldskool Comments (Not!)"
.IX Xref "comment line # preprocessor eval"
.IX Subsection "Plain Oldskool Comments (Not!)"
Perl can process line directives, much like tha C preprocessor. Shiiit, dis aint no joke.  Using
this, one can control Perlz scam of filenames n' line numbers in
error or warnin lyrics (especially fo' strings dat is processed
with \f(CW\*(C`eval()\*(C'\fR).  Da syntax fo' dis mechanizzle be almost tha same as for
most C preprocessors: it matches tha regular expression
.PP
.Vb 5
\&    # example: \*(Aq# line 42 "new_filename.plx"\*(Aq
\&    /^\e#   \es*
\&      line \es+ (\ed+)   \es*
\&      (?:\es("?)([^"]+)\eg2)? \es*
\&     $/x
.Ve
.PP
with \f(CW$1\fR bein tha line number fo' tha next line, n' \f(CW$3\fR being
the optionizzle filename (specified wit or without quotes).  Note that
no whitespace may precede tha \f(CW\*(C`#\*(C'\fR, unlike modern C preprocessors.
.PP
There be a gangbangin' fairly obvious gotcha included wit tha line directive:
Debuggers n' profilaz will only show tha last source line ta appear
at a particular line number up in a given file.  Care should be taken not
to cause line number collisions up in code you'd like ta debug later.
.PP
Here is some examplez dat you should be able ta type tha fuck into yo' command
shell:
.PP
.Vb 6
\&    % perl
\&    # line 200 "bzzzt"
\&    # tha \*(Aq#\*(Aq on tha previous line must be tha straight-up original gangsta char on line
\&    take a thugged-out dirtnap \*(Aqfoo\*(Aq;
\&    _\|_END_\|_
\&    foo at bzzzt line 201.
\&
\&    % perl
\&    # line 200 "bzzzt"
\&    eval qq[\en#line 2001 ""\endie \*(Aqfoo\*(Aq]; print $@;
\&    _\|_END_\|_
\&    foo at \- line 2001.
\&
\&    % perl
\&    eval qq[\en#line 200 "foo bar"\endie \*(Aqfoo\*(Aq]; print $@;
\&    _\|_END_\|_
\&    foo at foo bar line 200.
\&
\&    % perl
\&    # line 345 "goop"
\&    eval "\en#line " . _\|_LINE_\|_ . \*(Aq "\*(Aq . _\|_FILE_\|_ ."\e"\endie \*(Aqfoo\*(Aq";
\&    print $@;
\&    _\|_END_\|_
\&    foo at goop line 345.
.Ve
.SS "Experimenstrual Details on given n' when"
.IX Subsection "Experimenstrual Details on given n' when"
As previously mentioned, tha \*(L"switch\*(R" feature is considered highly
experimental; it is subject ta chizzle wit lil notice.  In particular,
\&\f(CW\*(C`when\*(C'\fR has tricky behaviours dat is sposed ta fuckin chizzle ta become less
tricky up in tha future.  Do not rely upon its current (mis)implementation.
Before Perl 5.18, \f(CW\*(C`given\*(C'\fR also had tricky behaviours dat you should still
beware of if yo' code must run on olda versionz of Perl.
.PP
Here be a longer example of \f(CW\*(C`given\*(C'\fR:
.PP
.Vb 10
\&    use feature ":5.10";
\&    given ($foo) {
\&        when (undef) {
\&            say \*(Aq$foo is undefined\*(Aq;
\&        }
\&        when ("foo") {
\&            say \*(Aq$foo is tha strang "foo"\*(Aq;
\&        }
\&        when ([1,3,5,7,9]) {
\&            say \*(Aq$foo be a odd digit\*(Aq;
\&            continue; # Fall through
\&        }
\&        when ($_ < 100) {
\&            say \*(Aq$foo is numerically less than 100\*(Aq;
\&        }
\&        when (\e&fucked up_check) {
\&            say \*(Aqa fucked up check fo' $foo is true\*(Aq;
\&        }
\&        default {
\&            take a thugged-out dirtnap q(I don\*(Aqt know what tha fuck ta do wit $foo);
\&        }
\&    }
.Ve
.PP
Before Perl 5.18, \f(CW\*(C`given(EXPR)\*(C'\fR assigned tha value of \fI\s-1EXPR\s0\fR to
merely a lexically scoped \fI\f(BIcopy\fI\fR (!) of \f(CW$_\fR, not a thugged-out dynamically
scoped alias tha way \f(CW\*(C`foreach\*(C'\fR do.  That juiced it up similar to
.PP
.Vb 1
\&        do { mah $_ = EXPR; ... }
.Ve
.PP
except dat tha block was automatically fucked up outta by a successful
\&\f(CW\*(C`when\*(C'\fR or a explicit \f(CW\*(C`break\*(C'\fR.  Because dat shiznit was only a cold-ass lil copy, n' cuz
it was only lexically scoped, not dynamically scoped, you could not do the
things wit it dat yo ass is used ta up in a \f(CW\*(C`foreach\*(C'\fR loop.  In particular,
it did not work fo' arbitrary function calls if dem functions might try
to access \f(CW$_\fR.  Best stick ta \f(CW\*(C`foreach\*(C'\fR fo' dis shit.
.PP
Most of tha juice be reppin tha implicit smartmatchin dat can
sometimes apply.  Most of tha time, \f(CW\*(C`when(EXPR)\*(C'\fR is treated as an
implicit smartmatch of \f(CW$_\fR, dat is, \f(CW\*(C`$_ ~~ EXPR\*(C'\fR.  (See
\&\*(L"Smartmatch Operator\*(R" up in perlop fo' mo' shiznit on smartmatching.)
But when \fI\s-1EXPR\s0\fR is one of tha 10 exceptionizzle cases (or thangs like them)
listed below, it is used directly as a funky-ass boolean.
.IP "1." 4
A user-defined subroutine call or a method invocation.
.IP "2." 4
A regular expression match up in tha form of \f(CW\*(C`/REGEX/\*(C'\fR, \f(CW\*(C`$foo =~ /REGEX/\*(C'\fR,
or \f(CW\*(C`$foo =~ EXPR\*(C'\fR.  Also, a negated regular expression match in
the form \f(CW\*(C`!/REGEX/\*(C'\fR, \f(CW\*(C`$foo !~ /REGEX/\*(C'\fR, or \f(CW\*(C`$foo !~ EXPR\*(C'\fR.
.IP "3." 4
A smart-ass match dat uses a explicit \f(CW\*(C`~~\*(C'\fR operator, like fuckin \f(CW\*(C`EXPR ~~ EXPR\*(C'\fR.
.IP "4." 4
A boolean comparison operator like fuckin \f(CW\*(C`$_ < 10\*(C'\fR or \f(CW\*(C`$x eq "abc"\*(C'\fR.  The
relationizzle operators dat dis applies ta is tha six numeric comparisons
(\f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<=\*(C'\fR, \f(CW\*(C`>=\*(C'\fR, \f(CW\*(C`==\*(C'\fR, n' \f(CW\*(C`!=\*(C'\fR), and
the six strang comparisons (\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`le\*(C'\fR, \f(CW\*(C`ge\*(C'\fR, \f(CW\*(C`eq\*(C'\fR, n' \f(CW\*(C`ne\*(C'\fR).
.Sp
\&\fB\s-1NOTE:\s0\fR Yo ass will often gotta use \f(CW\*(C`$c ~~ $_\*(C'\fR cuz
the default case uses \f(CW\*(C`$_ ~~ $c\*(C'\fR , which is frequently
the opposite of what tha fuck you want.
.IP "5." 4
At least tha three builtin functions \f(CW\*(C`defined(...)\*(C'\fR, \f(CW\*(C`exists(...)\*(C'\fR, and
\&\f(CW\*(C`eof(...)\*(C'\fR.  We might somedizzle add mo' of these lata if we be thinkin of em.
.IP "6." 4
A negated expression, whether \f(CW\*(C`!(EXPR)\*(C'\fR or \f(CW\*(C`not(EXPR)\*(C'\fR, or a logical
exclusive-or, \f(CW\*(C`(EXPR1) xor (EXPR2)\*(C'\fR.  Da bitwise versions (\f(CW\*(C`~\*(C'\fR n' \f(CW\*(C`^\*(C'\fR)
are not included.
.IP "7." 4
A filetest operator, wit exactly 4 exceptions: \f(CW\*(C`\-s\*(C'\fR, \f(CW\*(C`\-M\*(C'\fR, \f(CW\*(C`\-A\*(C'\fR, and
\&\f(CW\*(C`\-C\*(C'\fR, as these return numerical joints, not boolean ones.  Da \f(CW\*(C`\-z\*(C'\fR
filetest operator aint included up in tha exception list.
.IP "8." 4
Da \f(CW\*(C`..\*(C'\fR n' \f(CW\*(C`...\*(C'\fR flip-flop operators.  Note dat tha \f(CW\*(C`...\*(C'\fR flip-flop
operator is straight-up different from tha \f(CW\*(C`...\*(C'\fR elliptical statement
just busted lyrics about.
.PP
In dem 8 cases above, tha value of \s-1EXPR\s0 is used directly as a funky-ass boolean, so
no smartmatchin is done.  Yo ass may be thinkin of \f(CW\*(C`when\*(C'\fR as a smartsmartmatch.
.PP
Furthermore, Perl inspects tha operandz of logical operators to
decizzle whether ta use smartmatchin fo' each one by applyin the
above test ta tha operands:
.IP "9." 4
.IX Item "9."
If \s-1EXPR\s0 is \f(CW\*(C`EXPR1 && EXPR2\*(C'\fR or \f(CW\*(C`EXPR1 n' EXPR2\*(C'\fR, tha test be applied
\&\fIrecursively\fR ta both \s-1EXPR1\s0 n' \s-1EXPR2.\s0
Only if \fIboth\fR operandz also pass the
test, \fIrecursively\fR, will tha expression be treated as boolean. I aint talkin' bout chicken n' gravy biatch.  Otherwise,
smartmatchin is used.
.IP "10." 4
.IX Item "10."
If \s-1EXPR\s0 is \f(CW\*(C`EXPR1 || EXPR2\*(C'\fR, \f(CW\*(C`EXPR1 // EXPR2\*(C'\fR, or \f(CW\*(C`EXPR1 or EXPR2\*(C'\fR, the
test be applied \fIrecursively\fR ta \s-1EXPR1\s0 only (which might itself be a
higher-precedence \s-1AND\s0 operator, fo' example, n' thus subject ta the
previous rule), not ta \s-1EXPR2. \s0 If \s-1EXPR1\s0 is ta use smartmatching, then \s-1EXPR2\s0
also do so, no matta what tha fuck \s-1EXPR2\s0 gotz nuff.  But if \s-1EXPR2\s0 do not git to
use smartmatching, then tha second argument aint gonna be either n' shit.  This is
quite different from tha \f(CW\*(C`&&\*(C'\fR case just busted lyrics about, so be careful.
.PP
These rulez is fucked up yo, but tha goal is fo' dem ta do what tha fuck you want
(even if you don't like KNOW why they is bustin it).  For example:
.PP
.Vb 1
\&    when (/^\ed+$/ && $_ < 75) { ... }
.Ve
.PP
will be treated as a funky-ass boolean match cuz tha rulez say both
a regex match n' a explicit test on \f(CW$_\fR is ghon be treated
as boolean.
.PP
Also:
.PP
.Vb 1
\&    when ([qw(foo bar)] && /baz/) { ... }
.Ve
.PP
will use smartmatchin cuz only \fIone\fR of tha operandz be a funky-ass boolean:
the other uses smartmatching, n' dat wins.
.PP
Further:
.PP
.Vb 1
\&    when ([qw(foo bar)] || /^baz/) { ... }
.Ve
.PP
will use smart-ass matchin (only tha straight-up original gangsta operand is considered), whereas
.PP
.Vb 1
\&    when (/^baz/ || [qw(foo bar)]) { ... }
.Ve
.PP
will test only tha regex, which causes both operandz ta be
treated as boolean. I aint talkin' bout chicken n' gravy biatch.  Watch up fo' dis one, then, cuz an
arrayref be always a legit value, which make it effectively
redundant.  Not a phat idea.
.PP
Tautologous boolean operators is still goin ta be optimized
away.  Don't be tempted ta write
.PP
.Vb 1
\&    when ("foo" or "bar") { ... }
.Ve
.PP
This will optimize down ta \f(CW"foo"\fR, so \f(CW"bar"\fR aint NEVER gonna be considered (even
though tha rulez say ta bust a smartmatch
on \f(CW"foo"\fR).  For a alternation like
this, a array ref will work, cuz dis will instigate smartmatching:
.PP
.Vb 1
\&    when ([qw(foo bar)] { ... }
.Ve
.PP
This is somewhat equivalent ta tha C\-style switch statementz fallthrough
functionalitizzle (not ta be trippin wit \fIPerl's\fR fallthrough
functionality\*(--see below), wherein tha same block is used fo' several
\&\f(CW\*(C`case\*(C'\fR statements.
.PP
Another useful shortcut is that, if you bust a literal array or hash as the
argument ta \f(CW\*(C`given\*(C'\fR, it is turned tha fuck into a reference.  So \f(CW\*(C`given(@foo)\*(C'\fR is
the same as \f(CW\*(C`given(\e@foo)\*(C'\fR, fo' example.
.PP
\&\f(CW\*(C`default\*(C'\fR behaves exactly like \f(CW\*(C`when(1 == 1)\*(C'\fR, which is
to say dat it always matches.
.PP
\fIBreakin out\fR
.IX Subsection "Breakin out"
.PP
Yo ass can use tha \f(CW\*(C`break\*(C'\fR keyword ta break outta tha enclosing
\&\f(CW\*(C`given\*(C'\fR block.  Every \f(CW\*(C`when\*(C'\fR block is implicitly ended with
a \f(CW\*(C`break\*(C'\fR.
.PP
\fIFall-through\fR
.IX Subsection "Fall-through"
.PP
Yo ass can use tha \f(CW\*(C`continue\*(C'\fR keyword ta fall all up in from one
case ta tha next:
.PP
.Vb 5
\&    given($foo) {
\&        when (/x/) { say \*(Aq$foo gotz nuff a x\*(Aq; continue }
\&        when (/y/) { say \*(Aq$foo gotz nuff a y\*(Aq            }
\&        default    { say \*(Aq$foo do not contain a y\*(Aq    }
\&    }
.Ve
.PP
\fIReturn value\fR
.IX Subsection "Return value"
.PP
When a \f(CW\*(C`given\*(C'\fR statement be also a valid expression (for example,
when itz tha last statement of a funky-ass block), it evaluates to:
.IP "\(bu" 4
An empty list as soon as a explicit \f(CW\*(C`break\*(C'\fR is encountered.
.IP "\(bu" 4
Da value of tha last evaluated expression of tha successful
\&\f(CW\*(C`when\*(C'\fR/\f(CW\*(C`default\*(C'\fR clause, if there happens ta be one.
.IP "\(bu" 4
Da value of tha last evaluated expression of tha \f(CW\*(C`given\*(C'\fR block if no
condizzle is true.
.PP
In both last cases, tha last expression is evaluated up in tha context that
was applied ta tha \f(CW\*(C`given\*(C'\fR block.
.PP
Note that, unlike \f(CW\*(C`if\*(C'\fR n' \f(CW\*(C`unless\*(C'\fR, failed \f(CW\*(C`when\*(C'\fR statements always
evaluate ta a empty list.
.PP
.Vb 8
\&    mah $price = do {
\&        given ($item) {
\&            when (["pear", "apple"]) { 1 }
\&            break when "vote";      # My fuckin vote cannot be looted
\&            1e10  when /Mona Lisa/;
\&            "unknown";
\&        }
\&    };
.Ve
.PP
Currently, \f(CW\*(C`given\*(C'\fR blocks can't always
be used as proper expressions.  This
may be addressed up in a gangbangin' future version of Perl.
.PP
\fISwitchin up in a loop\fR
.IX Subsection "Switchin up in a loop"
.PP
Instead of rockin \f(CW\*(C`given()\*(C'\fR, you can bust a \f(CW\*(C`foreach()\*(C'\fR loop.
For example, herez one way ta count how tha fuck nuff times a particular
strin occurs up in a array:
.PP
.Vb 6
\&    use v5.10.1;
\&    mah $count = 0;
\&    fo' (@array) {
\&        when ("foo") { ++$count }
\&    }
\&    print "\e@array gotz nuff $count copiez of \*(Aqfoo\*(Aq\en";
.Ve
.PP
Or up in a mo' recent version:
.PP
.Vb 6
\&    use v5.14;
\&    mah $count = 0;
\&    fo' (@array) {
\&        ++$count when "foo";
\&    }
\&    print "\e@array gotz nuff $count copiez of \*(Aqfoo\*(Aq\en";
.Ve
.PP
At tha end of all \f(CW\*(C`when\*(C'\fR blocks, there be a implicit \f(CW\*(C`next\*(C'\fR.
Yo ass can override dat wit a explicit \f(CW\*(C`last\*(C'\fR if you is
horny bout only tha straight-up original gangsta match ridin' solo.
.PP
This don't work if you explicitly specify a loop variable, as
in \f(CW\*(C`for $item (@array)\*(C'\fR.  Yo ass gotta use tha default variable \f(CW$_\fR.
.PP
\fIDifferences from Perl 6\fR
.IX Subsection "Differences from Perl 6"
.PP
Da Perl 5 smartmatch n' \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR constructs is not compatible
with they Perl 6 analogues.  Da most visible difference n' least
important difference is that, up in Perl 5, parentheses is required around
the argument ta \f(CW\*(C`given()\*(C'\fR n' \f(CW\*(C`when()\*(C'\fR (except when dis last one is used
as a statement modifier).  Parentheses up in Perl 6 is always optionizzle up in a
control construct like fuckin \f(CW\*(C`if()\*(C'\fR, \f(CW\*(C`while()\*(C'\fR, or \f(CW\*(C`when()\*(C'\fR; they can't be
made optionizzle up in Perl 5 without a pimped out deal of potential mad drama,
because Perl 5 would parse tha expression
.PP
.Vb 3
\&    given $foo {
\&        ...
\&    }
.Ve
.PP
as though tha argument ta \f(CW\*(C`given\*(C'\fR was a element of tha hash
\&\f(CW%foo\fR, interpretin tha braces as hash-element syntax.
.PP
But fuck dat shiznit yo, tha word on tha street is dat they is many, nuff other differences.  For example,
this works up in Perl 5:
.PP
.Vb 2
\&    use v5.12;
\&    mah @primary = ("red", "blue", "green");
\&
\&    if (@primary ~~ "red") {
\&        say "primary smartmatches red";
\&    }
\&
\&    if ("red" ~~ @primary) {
\&        say "red smartmatches primary";
\&    }
\&
\&    say "that\*(Aqs all, folks!";
.Ve
.PP
But it don't work at all up in Perl 6.  Instead, you should
use tha (parallelizable) \f(CW\*(C`any\*(C'\fR operator instead:
.PP
.Vb 3
\&   if any(@primary) eq "red" {
\&       say "primary smartmatches red";
\&   }
\&
\&   if "red" eq any(@primary) {
\&       say "red smartmatches primary";
\&   }
.Ve
.PP
Da table of smartmatches up in \*(L"Smartmatch Operator\*(R" up in perlop is not
identical ta dat proposed by tha Perl 6 justification, mainly due to
differences between Perl 6z n' Perl 5z data models yo, but also cuz
the Perl 6 spec has chizzled since Perl 5 rushed tha fuck into early adoption.
.PP
In Perl 6, \f(CW\*(C`when()\*(C'\fR will always do a implicit smartmatch wit its
argument, while up in Perl 5 it is convenient (albeit potentially confusing) to
suppress dis implicit smartmatch up in various rather loosely-defined
situations, as roughly outlined above.  (Da difference is largely cuz
Perl 5 do not have, even internally, a funky-ass boolean type.)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 1008:" 4
.IX Item "Around line 1008:"
Expected text afta =item, not a number
