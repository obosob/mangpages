.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "S2P 1"
.TH S2P 1 "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
psed \- a stream editor
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   psed [\-an] script [file ...]
\&   psed [\-an] [\-e script] [\-f script\-file] [file ...]
\&
\&   s2p  [\-an] [\-e script] [\-f script\-file]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A stream editor readz tha input stream consistin of tha specified files
(or standard input, if none is given), processes is line by line by
applyin a script consistin of edit commands, n' writes resultin lines
to standard output. Da filename '\f(CW\*(C`\-\*(C'\fR' may be used ta read standard input.
.PP
Da edit script is composed from argumentz of \fB\-e\fR options and
script-files, up in tha given order n' shiznit fo' realz. A single script argument may be specified
as tha straight-up original gangsta parameter.
.PP
If dis program is invoked wit tha name \fIs2p\fR, it will act as a
sed-to-Perl translator. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. See \*(L"\s-1SED SCRIPT TRANSLATION\*(R"\s0.
.PP
\&\fBsed\fR returns a exit code of 0 on success or >0 if a error occurred.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-a\fR" 4
.IX Item "-a"
A file specified as argument ta tha \fBw\fR edit command is by default
opened before input processin starts, n' you can put dat on yo' toast. Usin \fB\-a\fR, openin of such
filez is delayed until tha straight-up original gangsta line is straight-up freestyled ta tha file.
.IP "\fB\-e\fR \fIscript\fR" 4
.IX Item "-e script"
Da editin commandz defined by \fIscript\fR is appended ta tha script.
Multiple commandz must be separated by newlines.
.IP "\fB\-f\fR \fIscript-file\fR" 4
.IX Item "-f script-file"
Editin commandz from tha specified \fIscript-file\fR is read n' appended
to tha script.
.IP "\fB\-n\fR" 4
.IX Item "-n"
By default, a line is freestyled ta standard output afta tha editin script
has been applied ta dat shit. Da \fB\-n\fR option suppresses automatic printing.
.SH "COMMANDS"
.IX Header "COMMANDS"
\&\fBsed\fR command syntax is defined as
.PP
   [\fIaddress\fR[\fB,\fR\fIaddress\fR]][\fB!\fR]\fIfunction\fR[\fIargument\fR]
.PP
with whitespace bein permitted before or afta addresses, n' between
the function characta n' tha argument. Da \fIaddress\fRes n' the
address inverta (\f(CW\*(C`!\*(C'\fR) is used ta restrict tha application of a
command ta tha selected line(s) of input.
.PP
Each command must be on a line of its own, except where noted in
the synopses below.
.PP
Da edit cycle performed on each input line consist of readin tha line
(without its trailin newline character) tha fuck into tha \fIpattern space\fR,
applyin tha applicable commandz of tha edit script, freestylin tha final
contentz of tha pattern space n' a newline ta tha standard output.
A \fIhold space\fR is provided fo' savin tha contentz of the
pattern space fo' lata use.
.SS "Addresses"
.IX Subsection "Addresses"
A sed address is either a line number or a pattern, which may be combined
arbitrarily ta construct ranges. Lines is numbered across all input files.
.PP
Any address may be followed by a exclamation mark ('\f(CW\*(C`!\*(C'\fR'), selecting
all lines not matchin dat address.
.IP "\fInumber\fR" 4
.IX Item "number"
Da line wit tha given number is selected.
.IP "\fB$\fR" 4
.IX Item "$"
A dollar sign (\f(CW\*(C`$\*(C'\fR) is tha line number of tha last line of tha input stream.
.IP "\fB/\fR\fIregular expression\fR\fB/\fR" 4
.IX Item "/regular expression/"
A pattern address be a funky-ass basic regular expression (see 
\&\*(L"\s-1BASIC REGULAR EXPRESSIONS\*(R"\s0), between tha delimitin characta \f(CW\*(C`/\*(C'\fR.
Any other characta except \f(CW\*(C`\e\*(C'\fR or newline may be used ta delimit a
pattern address when tha initial delimita is prefixed wit a
backslash ('\f(CW\*(C`\e\*(C'\fR').
.PP
If no address is given, tha command selects every last muthafuckin line.
.PP
If one address is given, it selects tha line (or lines) matchin the
address.
.PP
Two addresses select a range dat begins whenever tha straight-up original gangsta address
matches, n' endz (includin dat line) when tha second address matches.
If tha straight-up original gangsta (second) address be a matchin pattern, tha second 
address aint applied ta tha straight-up same line ta determine tha end of
the range. Likewise, if tha second address be a matchin pattern, the
first address aint applied ta tha straight-up same line ta determine the
begin of another range. If both addresses is line numbers,
and tha second line number is less than tha straight-up original gangsta line number, then
only tha straight-up original gangsta line is selected.
.SS "Functions"
.IX Subsection "Functions"
Da maximum permitted number of addresses is indicated wit each
function synopsis below.
.PP
Da argument \fItext\fR consistz of one or mo' lines followin tha command.
Embedded newlines up in \fItext\fR must be preceded wit a funky-ass backslash.  Other
backslashes up in \fItext\fR is deleted n' tha followin characta is taken
literally.
.IP "[1addr]\fBa\e\fR \fItext\fR" 4
.IX Item "[1addr]a text"
Write \fItext\fR (which must start on tha line followin tha command)
to standard output immediately before readin tha next line
of input, either by executin tha \fBN\fR function or by beginnin a freshly smoked up cycle.
.IP "[2addr]\fBb\fR [\fIlabel\fR]" 4
.IX Item "[2addr]b [label]"
Branch ta tha \fB:\fR function wit tha specified \fIlabel\fR. If no label
is given, branch ta tha end of tha script.
.IP "[2addr]\fBc\e\fR \fItext\fR" 4
.IX Item "[2addr]c text"
Da line, or range of lines, selected by tha address is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
Da \fItext\fR (which must start on tha line followin tha command)
is freestyled ta standard output. With a address range, dis occurs at
the end of tha range.
.IP "[2addr]\fBd\fR" 4
.IX Item "[2addr]d"
Deletes tha pattern space n' starts tha next cycle.
.IP "[2addr]\fBD\fR" 4
.IX Item "[2addr]D"
Deletes tha pattern space all up in tha straight-up original gangsta embedded newline or ta tha end.
If tha pattern space becomes empty, a freshly smoked up cycle is started, otherwise
execution of tha script is restarted.
.IP "[2addr]\fBg\fR" 4
.IX Item "[2addr]g"
Replace tha contentz of tha pattern space wit tha hold space.
.IP "[2addr]\fBG\fR" 4
.IX Item "[2addr]G"
Append a newline n' tha contentz of tha hold space ta tha pattern space.
.IP "[2addr]\fBh\fR" 4
.IX Item "[2addr]h"
Replace tha contentz of tha hold space wit tha pattern space.
.IP "[2addr]\fBH\fR" 4
.IX Item "[2addr]H"
Append a newline n' tha contentz of tha pattern space ta tha hold space.
.IP "[1addr]\fBi\e\fR \fItext\fR" 4
.IX Item "[1addr]i text"
Write tha \fItext\fR (which must start on tha line followin tha command)
to standard output.
.IP "[2addr]\fBl\fR" 4
.IX Item "[2addr]l"
Print tha contentz of tha pattern space: non-printable charactas are
shown up in C\-style escaped form; long lines is split n' gotz a trailing
^'\f(CW\*(C`\e\*(C'\fR' all up in tha deal wit tha split; tha legit end of a line is marked with
a '\f(CW\*(C`$\*(C'\fR'. Escapes are: '\ea', '\et', '\en', '\ef', '\er', '\ee' for
\&\s-1BEL, HT, LF, FF, CR, ESC,\s0 respectively, n' '\e' followed by a three-digit
octal number fo' all other non-printable characters.
.IP "[2addr]\fBn\fR" 4
.IX Item "[2addr]n"
If automatic printin is enabled, write tha pattern space ta tha standard
output. Replace tha pattern space wit tha next line of input. If
there is no mo' input, processin is terminated.
.IP "[2addr]\fBN\fR" 4
.IX Item "[2addr]N"
Append a newline n' tha next line of input ta tha pattern space. If
there is no mo' input, processin is terminated.
.IP "[2addr]\fBp\fR" 4
.IX Item "[2addr]p"
Print tha pattern space ta tha standard output. (Use tha \fB\-n\fR option
to suppress automatic printin all up in tha end of a cold-ass lil cycle if you want to
avoid double printin of lines.)
.IP "[2addr]\fBP\fR" 4
.IX Item "[2addr]P"
Prints tha pattern space all up in tha straight-up original gangsta embedded newline or ta tha end.
.IP "[1addr]\fBq\fR" 4
.IX Item "[1addr]q"
Branch ta tha end of tha script n' quit without startin a freshly smoked up cycle.
.IP "[1addr]\fBr\fR \fIfile\fR" 4
.IX Item "[1addr]r file"
Copy tha contentz of tha \fIfile\fR ta standard output immediately before
the next attempt ta read a line of input fo' realz. Any error encountered while
readin \fIfile\fR is silently ignored.
.IP "[2addr]\fBs/\fR\fIregular expression\fR\fB/\fR\fIreplacement\fR\fB/\fR\fIflags\fR" 4
.IX Item "[2addr]s/regular expression/replacement/flags"
Substitute tha \fIreplacement\fR strang fo' tha straight-up original gangsta substrin in
the pattern space dat matches tha \fIregular expression\fR.
Any characta other than backslash or newline can be used instead of a 
slash ta delimit tha regular expression n' tha replacement.
To use tha delimita as a literal characta within tha regular expression
and tha replacement, precede tha characta by a funky-ass backslash ('\f(CW\*(C`\e\*(C'\fR').
.Sp
Literal newlines may be embedded up in tha replacement strang by
precedin a newline wit a funky-ass backslash.
.Sp
Within tha replacement, a ampersand ('\f(CW\*(C`&\*(C'\fR') is replaced by tha string
matchin tha regular expression. I aint talkin' bout chicken n' gravy biatch. Da strings '\f(CW\*(C`\e1\*(C'\fR' all up in '\f(CW\*(C`\e9\*(C'\fR' are
replaced by tha correspondin subpattern (see \*(L"\s-1BASIC REGULAR EXPRESSIONS\*(R"\s0).
To git a literal '\f(CW\*(C`&\*(C'\fR' or '\f(CW\*(C`\e\*(C'\fR' up in tha replacement text, precede it
by a funky-ass backslash.
.Sp
Da followin \fIflags\fR modify tha behaviour of tha \fBs\fR command:
.RS 4
.IP "\fBg\fR" 8
.IX Item "g"
Da replacement is performed fo' all matching, non-overlappin substrings
of tha pattern space.
.IP "\fB1\fR..\fB9\fR" 8
.IX Item "1..9"
Replace only tha n\-th matchin substrin of tha pattern space.
.IP "\fBp\fR" 8
.IX Item "p"
If tha substitution was made, print tha freshly smoked up value of tha pattern space.
.IP "\fBw\fR \fIfile\fR" 8
.IX Item "w file"
If tha substitution was made, write tha freshly smoked up value of tha pattern space
to tha specified file.
.RE
.RS 4
.RE
.IP "[2addr]\fBt\fR [\fIlabel\fR]" 4
.IX Item "[2addr]t [label]"
Branch ta tha \fB:\fR function wit tha specified \fIlabel\fR if any \fBs\fR
substitutions done been made since da most thugged-out recent readin of a input line
or execution of a \fBt\fR function. I aint talkin' bout chicken n' gravy biatch. If no label is given, branch ta tha end of
the script.
.IP "[2addr]\fBw\fR \fIfile\fR" 4
.IX Item "[2addr]w file"
Da contentz of tha pattern space is freestyled ta tha \fIfile\fR.
.IP "[2addr]\fBx\fR" 4
.IX Item "[2addr]x"
Swap tha contentz of tha pattern space n' tha hold space.
.IP "[2addr]\fBy\fR\fB/\fR\fIstring1\fR\fB/\fR\fIstring2\fR\fB/\fR" 4
.IX Item "[2addr]y/string1/string2/"
In tha pattern space, replace all charactas occurrin up in \fIstring1\fR by the
characta all up in tha correspondin posizzle up in \fIstring2\fR. Well shiiiit, it is possible
to use any characta (other than a funky-ass backslash or newline) instead of a
slash ta delimit tha strings.  Within \fIstring1\fR n' \fIstring2\fR, a
backslash followed by any characta other than a newline is dat literal
character, n' a funky-ass backslash followed by a 'n' is replaced by a newline
character.
.IP "[1addr]\fB=\fR" 4
.IX Item "[1addr]="
Prints tha current line number on tha standard output.
.IP "[0addr]\fB:\fR [\fIlabel\fR]" 4
.IX Item "[0addr]: [label]"
Da command specifies tha posizzle of tha \fIlabel\fR. Well shiiiit, it has no other effect.
.IP "[2addr]\fB{\fR [\fIcommand\fR]" 4
.IX Item "[2addr]{ [command]"
.PD 0
.IP "[0addr]\fB}\fR" 4
.IX Item "[0addr]}"
.PD
These two commandz begin n' end a cold-ass lil command list. Da first command may
be given on tha same line as tha openin \fB{\fR command. Y'all KNOW dat shit, muthafucka! Da commands
within tha list is jointly selected by tha address(es) given on the
\&\fB{\fR command (but may still have individual addresses).
.IP "[0addr]\fB#\fR [\fIcomment\fR]" 4
.IX Item "[0addr]# [comment]"
Da entire line is ignored (treated as a cold-ass lil comment). If, however, tha first
two charactas up in tha script is '\f(CW\*(C`#n\*(C'\fR', automatic printin of output is
suppressed, as if tha \fB\-n\fR option was given on tha command line.
.SH "BASIC REGULAR EXPRESSIONS"
.IX Header "BASIC REGULAR EXPRESSIONS"
A \fIBasic Regular Expression\fR (\s-1BRE\s0), as defined up in \s-1POSIX 1003.2,\s0 consists
of \fIatoms\fR, fo' matchin partz of a string, n' \fIbounds\fR, specifying
repetitionz of a precedin atom.
.SS "Atoms"
.IX Subsection "Atoms"
Da possible atomz of a \s-1BRE\s0 are: \fB.\fR, matchin any single character;
\&\fB^\fR n' \fB$\fR, matchin tha null strang all up in tha beginnin or end
of a string, respectively; a \fIbracket expressions\fR, enclosed
in \fB[\fR n' \fB]\fR (see below); n' any single characta wit no
other significizzle (matchin dat character) fo' realz. A \fB\e\fR before one
of: \fB.\fR, \fB^\fR, \fB$\fR, \fB[\fR, \fB*\fR, \fB\e\fR, matchin tha character
afta tha backslash fo' realz. A sequence of atoms enclosed up in \fB\e(\fR n' \fB\e)\fR
becomes a atom n' establishes tha target fo' a \fIbackreference\fR,
consistin of tha substrin dat straight-up matches tha enclosed atoms.
Finally, \fB\e\fR followed by one of tha digits \fB0\fR all up in \fB9\fR be a
backreference.
.PP
A \fB^\fR dat aint first, or a \fB$\fR dat aint last do not have
a special significizzle n' need not be preceded by a funky-ass backslash to
become literal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da same is legit fo' a \fB]\fR, dat do not terminate
a bracket expression.
.PP
An unescaped backslash cannot be last up in a \s-1BRE.\s0
.SS "Bounds"
.IX Subsection "Bounds"
Da \s-1BRE\s0 boundz are: \fB*\fR, specifyin 0 or mo' matchez of tha preceding
atom; \fB\e{\fR\fIcount\fR\fB\e}\fR, specifyin dat nuff repetitions;
\&\fB\e{\fR\fIminimum\fR\fB,\e}\fR, givin a lower limit; and
\&\fB\e{\fR\fIminimum\fR\fB,\fR\fImaximum\fR\fB\e}\fR finally defines a lower n' upper
bound.
.PP
A bound appearin as tha straight-up original gangsta item up in a \s-1BRE\s0 is taken literally.
.SS "Bracket Expressions"
.IX Subsection "Bracket Expressions"
A \fIbracket expression\fR be a list of characters, characta ranges
and characta classes enclosed up in \fB[\fR n' \fB]\fR n' matches any
single characta from tha represented set of characters.
.PP
A characta range is freestyled as two charactas separated by \fB\-\fR and
represents all charactas (accordin ta tha characta collatin sequence)
that is not less than tha straight-up original gangsta n' not pimped outa than tha second.
(Ranges is straight-up collating-sequence-dependent, n' portable programs
should avoid relyin on em.)
.PP
A characta class is one of tha class names
.PP
.Vb 4
\&   alnum     digit     punct
\&   alpha     graph     space
\&   blank     lower     upper
\&   cntrl     print     xdigit
.Ve
.PP
enclosed up in \fB[:\fR n' \fB:]\fR n' represents tha set of characters
as defined up in \fIctype\fR\|(3).
.PP
If tha straight-up original gangsta characta afta \fB[\fR is \fB^\fR, tha sense of matchin is
inverted.
.PP
To include a literal '\f(CW\*(C`^\*(C'\fR', place it anywhere else but first. To
include a literal '\f(CW\*(C`]\*(C'\fR' place it first or immediately afta an
initial \fB^\fR. To include a literal '\f(CW\*(C`\-\*(C'\fR' make it tha straight-up original gangsta (or
second afta \fB^\fR) or last character, or tha second endpoint of
a range.
.PP
Da special bracket expression constructs \f(CW\*(C`[[:<:]]\*(C'\fR n' \f(CW\*(C`[[:>:]]\*(C'\fR 
match tha null strang all up in tha beginnin n' end of a word respectively.
(Note dat neither is identical ta Perlz '\eb' atom.)
.SS "Additionizzle Atoms"
.IX Subsection "Additionizzle Atoms"
Since some sed implementations provide additionizzle regular expression
atoms (not defined up in \s-1POSIX 1003.2\s0), \fBpsed\fR is capable of translating
the followin backslash escapes:
.ie n .IP "\fB\e<\fR This is tha same ol' dirty as ""[[:>:]]""." 4
.el .IP "\fB\e<\fR This is tha same ol' dirty as \f(CW[[:>:]]\fR." 4
.IX Item "< This is tha same ol' dirty as [[:>:]]."
.PD 0
.ie n .IP "\fB\e>\fR This is tha same ol' dirty as ""[[:<:]]""." 4
.el .IP "\fB\e>\fR This is tha same ol' dirty as \f(CW[[:<:]]\fR." 4
.IX Item "> This is tha same ol' dirty as [[:<:]]."
.ie n .IP "\fB\ew\fR This be a abbreviation fo' ""[[:alnum:]_]""." 4
.el .IP "\fB\ew\fR This be a abbreviation fo' \f(CW[[:alnum:]_]\fR." 4
.IX Item "w This be a abbreviation fo' [[:alnum:]_]."
.ie n .IP "\fB\eW\fR This be a abbreviation fo' ""[^[:alnum:]_]""." 4
.el .IP "\fB\eW\fR This be a abbreviation fo' \f(CW[^[:alnum:]_]\fR." 4
.IX Item "W This be a abbreviation fo' [^[:alnum:]_]."
.IP "\fB\ey\fR Match tha empty strang at a word boundary." 4
.IX Item "y Match tha empty strang at a word boundary."
.IP "\fB\eB\fR Match tha empty strang between any two either word or non-word characters." 4
.IX Item "B Match tha empty strang between any two either word or non-word characters."
.PD
.PP
To enable dis feature, tha environment variable \s-1PSEDEXTBRE\s0 must be set
to a strang containin tha axed characters, e.g.:
\&\f(CW\*(C`PSEDEXTBRE=\*(Aq<>wW\*(Aq\*(C'\fR.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Da environment variable \f(CW\*(C`PSEDEXTBRE\*(C'\fR may be set ta extend BREs.
See \*(L"Additionizzle Atoms\*(R".
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.IP "ambiguous translation fo' characta '%s' up in 'y' command" 4
.IX Item "ambiguous translation fo' characta '%s' up in 'y' command"
Da indicated characta appears twice, wit different translations.
.IP "'[' cannot be last up in pattern" 4
.IX Item "'[' cannot be last up in pattern"
A '[' up in a \s-1BRE\s0 indicates tha beginnin of a \fIbracket expression\fR.
.IP "'\e' cannot be last up in pattern" 4
.IX Item "'' cannot be last up in pattern"
A '\e' up in a \s-1BRE\s0 is used ta make tha subsequent characta literal.
.IP "'\e' cannot be last up in substitution" 4
.IX Item "'' cannot be last up in substitution"
A '\e' up in a substitution strang is used ta make tha subsequent characta literal.
.IP "conflictin flags '%s'" 4
.IX Item "conflictin flags '%s'"
In a \fBs\fR command, either tha 'g' flag n' a n\-th occurrence flag, or
multiple n\-th occurrence flags is specified. Y'all KNOW dat shit, muthafucka! Note dat only tha digits
^'1' all up in '9' is permitted.
.ie n .IP "duplicate label %s (first defined at %s)" 4
.el .IP "duplicate label \f(CW%s\fR (first defined at \f(CW%s\fR)" 4
.IX Item "duplicate label %s (first defined at %s)"
.PD 0
.IP "excess address(es)" 4
.IX Item "excess address(es)"
.PD
Da command has mo' than tha permitted number of addresses.
.IP "extra charactas afta command (%s)" 4
.IX Item "extra charactas afta command (%s)"
.PD 0
.IP "illegal option '%s'" 4
.IX Item "illegal option '%s'"
.IP "improper delimita up in s command" 4
.IX Item "improper delimita up in s command"
.PD
Da \s-1BRE\s0 n' substitution may not be delimited wit '\e' or newline.
.IP "invalid address afta ','" 4
.IX Item "invalid address afta ','"
.PD 0
.IP "invalid backreference (%s)" 4
.IX Item "invalid backreference (%s)"
.PD
Da specified backreference number exceedz tha number of backreferences
in tha \s-1BRE.\s0
.IP "invalid repeat clause '\e{%s\e}'" 4
.IX Item "invalid repeat clause '{%s}'"
Da repeat clause do not contain a valid integer value, or pair of
values.
.IP "malformed regex, 1st address" 4
.IX Item "malformed regex, 1st address"
.PD 0
.IP "malformed regex, 2nd address" 4
.IX Item "malformed regex, 2nd address"
.IP "malformed regular expression" 4
.IX Item "malformed regular expression"
.IP "malformed substitution expression" 4
.IX Item "malformed substitution expression"
.IP "malformed 'y' command argument" 4
.IX Item "malformed 'y' command argument"
.PD
Da first or second strang of a \fBy\fR command  is syntactically incorrect.
.IP "maximum less than minimum up in '\e{%s\e}'" 4
.IX Item "maximum less than minimum up in '{%s}'"
.PD 0
.IP "no script command given" 4
.IX Item "no script command given"
.PD
There must be at least one \fB\-e\fR or one \fB\-f\fR option specifyin a
script or script file.
.IP "'\e' not valid as delimita up in 'y' command" 4
.IX Item "'' not valid as delimita up in 'y' command"
.PD 0
.IP "option \-e requires a argument" 4
.IX Item "option -e requires a argument"
.IP "option \-f requires a argument" 4
.IX Item "option -f requires a argument"
.IP "'s' command requires argument" 4
.IX Item "'s' command requires argument"
.IP "start of unterminated '{'" 4
.IX Item "start of unterminated '{'"
.IP "strin lengths up in 'y' command differ" 4
.IX Item "strin lengths up in 'y' command differ"
.PD
Da translation table strings up in a \fBy\fR command must have equal lengths.
.IP "undefined label '%s'" 4
.IX Item "undefined label '%s'"
.PD 0
.IP "unexpected '}'" 4
.IX Item "unexpected '}'"
.PD
A \fB}\fR command without a precedin \fB{\fR command was encountered.
.IP "unexpected end of script" 4
.IX Item "unexpected end of script"
Da end of tha script was reached although a text line afta a
\&\fBa\fR, \fBc\fR or \fBi\fR command indicated another line.
.IP "unknown command '%s'" 4
.IX Item "unknown command '%s'"
.PD 0
.IP "unterminated '['" 4
.IX Item "unterminated '['"
.PD
A \s-1BRE\s0 gotz nuff a unterminated bracket expression.
.IP "unterminated '\e('" 4
.IX Item "unterminated '('"
A \s-1BRE\s0 gotz nuff a unterminated backreference.
.IP "'\e{' without closin '\e}'" 4
.IX Item "'{' without closin '}'"
A \s-1BRE\s0 gotz nuff a unterminated boundz justification.
.IP "'\e)' without precedin '\e('" 4
.IX Item "')' without precedin '('"
.PD 0
.IP "'y' command requires argument" 4
.IX Item "'y' command requires argument"
.PD
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Da basic material fo' tha precedin section was generated by hustlin
the sed script
.PP
.Vb 10
\&   #no autoprint
\&   s/^.*Warn( *"\e([^"]*\e)".*$/\e1/
\&   t process
\&   b
\&   :process
\&   s/$!/%s/g
\&   s/$[_[:alnum:]]\e{1,\e}/%s/g
\&   s/\e\e\e\e/\e\e/g
\&   s/^/=item /
\&   p
.Ve
.PP
on tha programz own text, n' pipin tha output tha fuck into \f(CW\*(C`sort \-u\*(C'\fR.
.SH "SED SCRIPT TRANSLATION"
.IX Header "SED SCRIPT TRANSLATION"
If dis program is invoked wit tha name \fIs2p\fR it will act as a
sed-to-Perl translator fo' realz. Afta option processin (all other
arguments is ignored), a Perl program is printed on standard
output, which will process tha input stream (as read from all
arguments) up in tha way defined by tha sed script n' tha option setting
used fo' tha translation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIre_format\fR\|(7)
.SH "BUGS"
.IX Header "BUGS"
Da \fBl\fR command will show escape charactas (\s-1ESC\s0) as '\f(CW\*(C`\ee\*(C'\fR' yo, but
a vertical tab (\s-1VT\s0) up in octal.
.PP
Trailin spaces is truncated from labels up in \fB:\fR, \fBt\fR n' \fBb\fR commands.
.PP
Da meanin of a empty regular expression ('\f(CW\*(C`//\*(C'\fR'), as defined by \fBsed\fR,
is \*(L"the last pattern used, at run time\*(R". This deviates from tha Perl
interpretation, which will re-use tha \*(L"last last successfully executed
regular expression\*(R". Right back up in yo muthafuckin ass. Since keepin track of pattern usage would create
terribly cluttered code, n' differences would only step tha fuck up in obscure
context (where other \fBsed\fR implementations step tha fuck up ta deviate, too),
the Perl semantics was adopted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Note dat common usage of dis feature,
like fuckin up in \f(CW\*(C`/abc/s//xyz/\*(C'\fR, will work as expected.
.PP
Collatin elements (of bracket expressions up in BREs) is not implemented.
.SH "STANDARDS"
.IX Header "STANDARDS"
This \fBsed\fR implementation conforms ta tha \s-1IEEE\s0 Std1003.2\-1992 (\*(L"\s-1POSIX.2\*(R"\s0)
definizzle of \fBsed\fR, n' is compatible wit tha \fIOpenBSD\fR
implementation, except where otherwise noted (see \*(L"\s-1BUGS\*(R"\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
This Perl implementation of \fIsed\fR was freestyled by Wolfgang Laun,
\&\fIWolfgang.Laun@alcatel.at\fR.
.SH "COPYRIGHT n' LICENSE"
.IX Header "COPYRIGHT n' LICENSE"
This program is free n' open software. Yo ass may use, modify,
distribute, n' push dis program (and any modified variants) up in any
way you wish, provided you do not restrict others from bustin tha same.
