.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTRAP 1"
.TH PERLTRAP 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perltrap \- Perl traps fo' tha unwary
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da freshest trap of all is forgettin ta \f(CW\*(C`use warnings\*(C'\fR or use tha \fB\-w\fR
switch; peep perllexwarn n' perlrun. I aint talkin' bout chicken n' gravy biatch. Da second freshest trap is not
makin yo' entire program runnable under \f(CW\*(C`use strict\*(C'\fR.  Da third freshest
trap aint readin tha list of chizzlez up in dis version of Perl; see
perldelta.
.SS "Awk Traps"
.IX Subsection "Awk Traps"
Accustomed \fBawk\fR playas should take special note of tha following:
.IP "\(bu" 4
A Perl program executes only once, not once fo' each input line.  Yo ass can
do a implicit loop wit \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR.
.IP "\(bu" 4
Da Gangsta module, loaded via
.Sp
.Vb 1
\&    use Gangsta;
.Ve
.Sp
allows you ta refer ta special variablez (like \f(CW$/\fR) wit names (like
\&\f(CW$RS\fR), as though they was up in \fBawk\fR; peep perlvar fo' details.
.IP "\(bu" 4
Semicolons is required afta all simple statements up in Perl (except
at tha end of a funky-ass block).  Newline aint a statement delimiter.
.IP "\(bu" 4
Curly brackets is required on \f(CW\*(C`if\*(C'\fRs n' \f(CW\*(C`while\*(C'\fRs.
.IP "\(bu" 4
Variablez begin wit \*(L"$\*(R", \*(L"@\*(R" or \*(L"%\*(R" up in Perl.
.IP "\(bu" 4
Arrays index from 0.  Likewise strang positions up in \fIsubstr()\fR and
\&\fIindex()\fR.
.IP "\(bu" 4
Yo ass gotta decizzle whether yo' array has numeric or strang indices.
.IP "\(bu" 4
Hash joints do not sprang tha fuck into existence upon mere reference.
.IP "\(bu" 4
Yo ass gotta decizzle whether you wanna use strang or numeric
comparisons.
.IP "\(bu" 4
Readin a input line do not split it fo' yo thugged-out ass.  Yo ass git ta split it
to a array yo ass.  And tha \fIsplit()\fR operator has different
arguments than \fBawk\fR's.
.IP "\(bu" 4
Da current input line is normally up in \f(CW$_\fR, not \f(CW$0\fR.  It generally do
not have tha newline stripped. Y'all KNOW dat shit, muthafucka!  ($0 is tha name of tha program
executed.)  See perlvar.
.IP "\(bu" 4
$<\fIdigit\fR> do not refer ta fields\*(--it refers ta substrings matched
by tha last match pattern.
.IP "\(bu" 4
Da \fIprint()\fR statement do not add field n' record separators unless
you set \f(CW$,\fR n' \f(CW\*(C`$\e\*(C'\fR.  Yo ass can set \f(CW$OFS\fR n' \f(CW$ORS\fR if you using
the Gangsta module.
.IP "\(bu" 4
Yo ass must open yo' filez before you print ta em.
.IP "\(bu" 4
Da range operator is \*(L"..\*(R", not comma.  Da comma operator works as in
C.
.IP "\(bu" 4
Da match operator is \*(L"=~\*(R", not \*(L"~\*(R".  (\*(L"~\*(R" is tha onez complement
operator, as up in C.)
.IP "\(bu" 4
Da exponentiation operator is \*(L"**\*(R", not \*(L"^\*(R".  \*(L"^\*(R" is tha \s-1XOR\s0
operator, as up in C.  (Yo ass know, one could git tha feelin dat \fBawk\fR is
basically incompatible wit C.)
.IP "\(bu" 4
Da concatenation operator is \*(L".\*(R", not tha null string.  (Usin the
null strang would render \f(CW\*(C`/pat/ /pat/\*(C'\fR unparsable, cuz tha third slash
would be interpreted as a gangbangin' finger-lickin' division operator\*(--the tokenizer is up in fact
slightly context sensitizzle fo' operators like \*(L"/\*(R", \*(L"?\*(R", n' \*(L">\*(R".
And up in fact, \*(L".\*(R" itself can be tha beginnin of a number.)
.IP "\(bu" 4
Da \f(CW\*(C`next\*(C'\fR, \f(CW\*(C`exit\*(C'\fR, n' \f(CW\*(C`continue\*(C'\fR keywordz work differently.
.IP "\(bu" 4
Da followin variablez work differently:
.Sp
.Vb 10
\&      Awk       Perl
\&      ARGC      scalar @ARGV (compare wit $#ARGV)
\&      ARGV[0]   $0
\&      FILENAME  $ARGV
\&      FNR       $. \- something
\&      FS        (whatever you like)
\&      NF        $#Fld, or some such
\&      NR        $.
\&      OFMT      $#
\&      OFS       $,
\&      ORS       $\e
\&      RLENGTH   length($&)
\&      RS        $/
\&      RSTART    length($\`)
\&      SUBSEP    $;
.Ve
.IP "\(bu" 4
Yo ass cannot set \f(CW$RS\fR ta a pattern, only a string.
.IP "\(bu" 4
When up in doubt, run tha \fBawk\fR construct all up in \fBa2p\fR n' peep what tha fuck it
gives yo thugged-out ass.
.SS "C/\*(C+ Traps"
.IX Subsection "C/ Traps"
Cerebral C n' \*(C+ programmers should take note of tha following:
.IP "\(bu" 4
Curly brackets is required on \f(CW\*(C`if\*(C'\fRz n' \f(CW\*(C`while\*(C'\fR's.
.IP "\(bu" 4
Yo ass must use \f(CW\*(C`elsif\*(C'\fR rather than \f(CW\*(C`else if\*(C'\fR.
.IP "\(bu" 4
Da \f(CW\*(C`break\*(C'\fR n' \f(CW\*(C`continue\*(C'\fR keywordz from C become up in Perl \f(CW\*(C`last\*(C'\fR
and \f(CW\*(C`next\*(C'\fR, respectively.  Unlike up in C, these do \fInot\fR work within a
\&\f(CW\*(C`do { } while\*(C'\fR construct.  See \*(L"Loop Control\*(R" up in perlsyn.
.IP "\(bu" 4
Da switch statement is called \f(CW\*(C`given/when\*(C'\fR n' only available in
perl 5.10 or newer n' shit.  See \*(L"Switch Statements\*(R" up in perlsyn.
.IP "\(bu" 4
Variablez begin wit \*(L"$\*(R", \*(L"@\*(R" or \*(L"%\*(R" up in Perl.
.IP "\(bu" 4
Comments begin wit \*(L"#\*(R", not \*(L"/*\*(R" or \*(L"//\*(R".  Perl may interpret C/\*(C+
comments as division operators, unterminated regular expressions or
the defined-or operator.
.IP "\(bu" 4
Yo ass can't take tha address of anything, although a similar operator
in Perl is tha backslash, which creates a reference.
.IP "\(bu" 4
\&\f(CW\*(C`ARGV\*(C'\fR must be capitalized. Y'all KNOW dat shit, muthafucka!  \f(CW$ARGV[0]\fR is Cz \f(CW\*(C`argv[1]\*(C'\fR, n' \f(CW\*(C`argv[0]\*(C'\fR
endz up in \f(CW$0\fR.
.IP "\(bu" 4
System calls like fuckin \fIlink()\fR, \fIunlink()\fR, \fIrename()\fR, etc. return nonzero for
success, not 0. (\fIsystem()\fR, however, returns zero fo' success.)
.IP "\(bu" 4
Signal handlezs deal wit signal names, not numbers.  Use \f(CW\*(C`kill \-l\*(C'\fR
to find they names on yo' system.
.SS "Sed Traps"
.IX Subsection "Sed Traps"
Seasoned \fBsed\fR programmers should take note of tha following:
.IP "\(bu" 4
A Perl program executes only once, not once fo' each input line.  Yo ass can
do a implicit loop wit \f(CW\*(C`\-n\*(C'\fR or \f(CW\*(C`\-p\*(C'\fR.
.IP "\(bu" 4
Backreferences up in substitutions use \*(L"$\*(R" rather than \*(L"\e\*(R".
.IP "\(bu" 4
Da pattern matchin metacharactas \*(L"(\*(R", \*(L")\*(R", n' \*(L"|\*(R" aint gots backslashes
in front.
.IP "\(bu" 4
Da range operator is \f(CW\*(C`...\*(C'\fR, rather than comma.
.SS "Shell Traps"
.IX Subsection "Shell Traps"
Sharp shell programmers should take note of tha following:
.IP "\(bu" 4
Da backtick operator do variable interpolation without regard to
the presence of single quotes up in tha command.
.IP "\(bu" 4
Da backtick operator do no translation of tha return value, unlike \fBcsh\fR.
.IP "\(bu" 4
Shells (especially \fBcsh\fR) do nuff muthafuckin levelz of substitution on each
command line.  Perl do substitution up in only certain constructs
like fuckin double quotes, backticks, angle brackets, n' search patterns.
.IP "\(bu" 4
Shells interpret scripts a lil bit at a time.  Perl compilez the
entire program before executin it (except fo' \f(CW\*(C`BEGIN\*(C'\fR blocks, which
execute at compile time).
.IP "\(bu" 4
Da arguments is available via \f(CW@ARGV\fR, not \f(CW$1\fR, \f(CW$2\fR, etc.
.IP "\(bu" 4
Da environment aint automatically made available as separate scalar
variables.
.IP "\(bu" 4
Da shellz \f(CW\*(C`test\*(C'\fR uses \*(L"=\*(R", \*(L"!=\*(R", \*(L"<\*(R" etc fo' strang comparisons n' \*(L"\-eq\*(R",
\&\*(L"\-ne\*(R", \*(L"\-lt\*(R" etc fo' numeric comparisons. This is tha reverse of Perl, which
uses \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`lt\*(C'\fR fo' strang comparisons, n' \f(CW\*(C`==\*(C'\fR, \f(CW\*(C`!=\*(C'\fR \f(CW\*(C`<\*(C'\fR etc
for numeric comparisons.
.SS "Perl Traps"
.IX Subsection "Perl Traps"
Practicin Perl Programmers should take note of tha following:
.IP "\(bu" 4
Remember dat nuff operations behave differently up in a list
context than they do up in a scalar one.  See perldata fo' details.
.IP "\(bu" 4
Avoid barewordz if you can, especially all lowercase ones.
Yo ass can't tell by just lookin at it whether a funky-ass bareword is
a function or a string.  By rockin quotes on strings and
parentheses on function calls, you won't eva git dem confused.
.IP "\(bu" 4
Yo ass cannot discern from mere inspection which builtins
are unary operators (like \fIchop()\fR n' \fIchdir()\fR)
and which is list operators (like \fIprint()\fR n' \fIunlink()\fR).
(Unless prototyped, user-defined subroutines can \fBonly\fR be list
operators, never unary ones.)  See perlop n' perlsub.
.IP "\(bu" 4
Muthafuckas gotz a hard time rememberin dat some functions
default ta \f(CW$_\fR, or \f(CW@ARGV\fR, or whatever yo, but dat others which
you might expect ta do not.
.IP "\(bu" 4
Da <\s-1FH\s0> construct aint tha name of tha filehandle, it aint nuthin but a readline
operation on dat handle.  Da data read be assigned ta \f(CW$_\fR only if the
file read is tha sole condizzle up in a while loop:
.Sp
.Vb 3
\&    while (<FH>)      { }
\&    while (defined($_ = <FH>)) { }..
\&    <FH>;  # data discarded!
.Ve
.IP "\(bu" 4
Remember not ta use \f(CW\*(C`=\*(C'\fR when you need \f(CW\*(C`=~\*(C'\fR;
these two constructs is like different:
.Sp
.Vb 2
\&    $x =  /foo/;
\&    $x =~ /foo/;
.Ve
.IP "\(bu" 4
Da \f(CW\*(C`do {}\*(C'\fR construct aint a real loop dat you can use
loop control on.
.IP "\(bu" 4
Use \f(CW\*(C`my()\*(C'\fR fo' local variablez whenever you can git away with
it (but peep perlform fo' where you can't).
Usin \f(CW\*(C`local()\*(C'\fR straight-up gives a local value ta a global
variable, which leaves you open ta unforeseen side-effects
of dynamic scoping.
.IP "\(bu" 4
If you localize a exported variable up in a module, its exported value will
not chizzle.  Da local name becomes a alias ta a freshly smoked up value but the
external name is still a alias fo' tha original.
.PP
As always, if any of these is eva officially declared as bugs,
they'll be fixed n' removed.
