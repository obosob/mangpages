.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREF 1"
.TH PERLREF 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlref \- Perl references n' nested data structures
.IX Xref "reference pointa data structure structure struct"
.SH "NOTE"
.IX Header "NOTE"
This is complete documentation bout all aspectz of references.
For a gangbangin' finger-lickin' dirty-ass shorter, tutorial introduction ta just tha essential features,
see perlreftut.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Before release 5 of Perl dat shiznit was hard as fuck ta represent complex data
structures, cuz all references had ta be symbolic\*(--and even then
it was hard as fuck ta refer ta a variable instead of a symbol table entry.
Perl now not only make it easier ta use symbolic references ta variables,
but also lets you have \*(L"hard\*(R" references ta any piece of data or code.
Any scalar may hold a hard reference.  Because arrays n' hashes contain
scalars, you can now easily build arrayz of arrays, arrayz of hashes,
hashez of arrays, arrayz of hashez of functions, n' so on.
.PP
Hard references is smart\*(--they keep track of reference counts fo' you,
automatically freein tha thang referred ta when its reference count goes
to zero.  (Reference counts fo' joints up in self-referential or
cyclic data structures may not git all up in zero without a lil help; see
\&\*(L"Circular References\*(R" fo' a thugged-out detailed explanation.)
If dat thang happens ta be a object, tha object is destructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See
perlobj fo' mo' bout objects, n' you can put dat on yo' toast.  (In a sense, every last muthafuckin thang up in Perl be an
object yo, but we probably reserve tha word fo' references ta objects that
have been officially \*(L"blessed\*(R" tha fuck into a cold-ass lil class package.)
.PP
Symbolic references is namez of variablez or other objects, just as a
symbolic link up in a Unix filesystem gotz nuff merely tha name of a gangbangin' file.
Da \f(CW*glob\fR notation is suttin' of a symbolic reference.  (Symbolic
references is sometimes called \*(L"soft references\*(R" yo, but please don't call
them that; references is confusin enough without useless synonyms.)
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.PP
In contrast, hard references is mo' like hard links up in a Unix file
system: They is used ta access a underlyin object without concern for
what its (other) name is.  When tha word \*(L"reference\*(R" is used without an
adjective, as up in tha followin paragraph, it is probably rappin' bout a
hard reference.
.IX Xref "reference, hard hard reference"
.PP
References is easy as fuck  ta use up in Perl.  There is just one overriding
principle: up in general, Perl do no implicit referencin or dereferencing.
When a scalar is holdin a reference, it always behaves as a simple scalar.
It don't magically start bein a array or hash or subroutine; you have to
tell it explicitly ta do so, by dereferencin dat shit.
.PP
That holla'd, be aware dat Perl version 5.14 introduces a exception
to tha rule, fo' syntactic convenience.  Experimenstrual array n' hash container
function behavior allows array n' hash references ta be handled by Perl as
if they had been explicitly syntactically dereferenced. Y'all KNOW dat shit, muthafucka!  See
\&\*(L"Syntactical Enhancements\*(R" up in perl5140delta
and perlfunc fo' details.
.SS "Makin References"
.IX Xref "reference, creation referencing"
.IX Subsection "Makin References"
References can be pimped up in nuff muthafuckin ways.
.IP "1." 4
.IX Xref "\\ backslash"
.IX Item "1."
By rockin tha backslash operator on a variable, subroutine, or value.
(This works much like tha & (address-of) operator up in C.)  
This typically creates \fIanother\fR reference ta a variable, cuz
therez already a reference ta tha variable up in tha symbol table.  But
the symbol table reference might go away, n' you gonna still have the
reference dat tha backslash returned. Y'all KNOW dat shit, muthafucka!  Here is some examples:
.Sp
.Vb 5
\&    $scalarref = \e$foo;
\&    $arrayref  = \e@ARGV;
\&    $hashref   = \e%ENV;
\&    $coderef   = \e&handlez;
\&    $globref   = \e*foo;
.Ve
.Sp
It aint possible ta create a legit reference ta a \s-1IO\s0 handle (filehandle
or dirhandle) rockin tha backslash operator. Shiiit, dis aint no joke.  Da most you can git be a
reference ta a typeglob, which is straight-up a cold-ass lil complete symbol table entry.
But peep tha explanation of tha \f(CW*foo{THING}\fR syntax below.  However,
you can still use type globs n' globrefs as though they was \s-1IO\s0 handles.
.IP "2." 4
.IX Xref "array, anonymous [ [] square bracket bracket, square arrayref array reference reference, array"
.IX Item "2."
A reference ta a anonymous array can be pimped rockin square
brackets:
.Sp
.Vb 1
\&    $arrayref = [1, 2, [\*(Aqa\*(Aq, \*(Aqb\*(Aq, \*(Aqc\*(Aq]];
.Ve
.Sp
Here we've pimped a reference ta a anonymous array of three elements
whose final element is itself a reference ta another anonymous array of three
elements, n' you can put dat on yo' toast.  (Da multidimensionizzle syntax busted lyrics bout lata can be used to
access all dis bullshit.  For example, afta tha above, \f(CW\*(C`$arrayref\->[2][1]\*(C'\fR would have
the value \*(L"b\*(R".)
.Sp
Takin a reference ta a enumerated list aint tha same
as rockin square brackets\*(--instead itz tha same ol' dirty as bustin
a list of references!
.Sp
.Vb 2
\&    @list = (\e$a, \e@b, \e%c);
\&    @list = \e($a, @b, %c);      # same thang!
.Ve
.Sp
As a special case, \f(CW\*(C`\e(@foo)\*(C'\fR returns a list of references ta tha contents
of \f(CW@foo\fR, not a reference ta \f(CW@foo\fR itself.  Likewise fo' \f(CW%foo\fR,
except dat tha key references is ta copies (since tha keys is just
strings rather than full-fledged scalars).
.IP "3." 4
.IX Xref "hash, anonymous { {} curly bracket bracket, curly brace hashref hash reference reference, hash"
.IX Item "3."
A reference ta a anonymous hash can be pimped rockin curly
brackets:
.Sp
.Vb 4
\&    $hashref = {
\&        \*(AqAdam\*(Aq  => \*(AqEve\*(Aq,
\&        \*(AqClyde\*(Aq => \*(AqBonnie\*(Aq,
\&    };
.Ve
.Sp
Anonymous hash n' array composers like these can be intermixed freely to
produce as fucked up a structure as you want.  Da multidimensional
syntax busted lyrics bout below works fo' these like a muthafucka.  Da joints above are
literals yo, but variablez n' expressions would work just as well, cuz
assignment operators up in Perl (even within \fIlocal()\fR or \fImy()\fR) is executable
statements, not compile-time declarations.
.Sp
Because curly brackets (braces) is used fo' nuff muthafuckin other thangs
includin BLOCKs, you may occasionally gotta disambiguate braces at the
beginnin of a statement by puttin a \f(CW\*(C`+\*(C'\fR or a \f(CW\*(C`return\*(C'\fR up in front so
that Perl realizes tha openin brace aint startin a \s-1BLOCK. \s0 Da economizzle and
mnemonic value of rockin curlies is deemed worth dis occasionizzle extra
hassle.
.Sp
For example, if you wanted a gangbangin' function ta cook up a freshly smoked up hash n' return a
reference ta it, you have these options:
.Sp
.Vb 3
\&    sub hashem {        { @_ } }   # silently wrong
\&    sub hashem {       +{ @_ } }   # ok
\&    sub hashem { return { @_ } }   # ok
.Ve
.Sp
On tha other hand, if you want tha other meaning, you can do this:
.Sp
.Vb 3
\&    sub showem {        { @_ } }   # ambiguous (currently aiiight yo, but may chizzle)
\&    sub showem {       {; @_ } }   # ok
\&    sub showem { { return @_ } }   # ok
.Ve
.Sp
Da leadin \f(CW\*(C`+{\*(C'\fR n' \f(CW\*(C`{;\*(C'\fR always serve ta disambiguate
the expression ta mean either tha \s-1HASH\s0 reference, or tha \s-1BLOCK.\s0
.IP "4." 4
.IX Xref "subroutine, anonymous subroutine, reference reference, subroutine scope, lexical closure lexical lexical scope"
.IX Item "4."
A reference ta a anonymous subroutine can be pimped by using
\&\f(CW\*(C`sub\*(C'\fR without a subname:
.Sp
.Vb 1
\&    $coderef = sub { print "Boink!\en" };
.Ve
.Sp
Note tha semicolon. I aint talkin' bout chicken n' gravy biatch.  Except fo' tha code
inside not bein immediately executed, a \f(CW\*(C`sub {}\*(C'\fR aint so much a
declaration as it be a operator, like \f(CW\*(C`do{}\*(C'\fR or \f(CW\*(C`eval{}\*(C'\fR.  (But fuck dat shiznit yo, tha word on tha street is dat no
matta how tha fuck nuff times you execute dat particular line (unless you up in an
\&\f(CW\*(C`eval("...")\*(C'\fR), \f(CW$coderef\fR will still gotz a reference ta tha \fIsame\fR
anonymous subroutine.)
.Sp
Anonymous subroutines act as closures wit respect ta \fImy()\fR variables,
that is, variablez lexically visible within tha current scope.  Closure
is a notion outta tha Lisp ghetto dat say if you define a anonymous
function up in a particular lexical context, it pretendz ta run up in that
context even when itz called outside tha context.
.Sp
In human terms, itz a gangbangin' funky way of passin arguments ta a subroutine when
you define it as well as when you call dat shit.  It aint nuthin but useful fo' settin up
lil bitz of code ta run later, like fuckin callbacks.  Yo ass can even
do object-oriented shiznit wit it, though Perl already serves up a gangbangin' finger-lickin' different
mechanizzle ta do that\*(--see perlobj.
.Sp
Yo ass might also be thinkin of closure as a way ta write a subroutine
template without rockin \fIeval()\fR.  Herez a lil' small-ass example of how
closures work:
.Sp
.Vb 6
\&    sub newprint {
\&        mah $x = shift;
\&        return sub { mah $y = shift; print "$x, $y!\en"; };
\&    }
\&    $h = newprint("Howdy");
\&    $g = newprint("Greetings");
\&
\&    # Time passes...
\&
\&    &$h("world");
\&    &$g("earthlings");
.Ve
.Sp
This prints
.Sp
.Vb 2
\&    Howdy, ghetto!
\&    Greetings, earthlings!
.Ve
.Sp
Note particularly dat \f(CW$x\fR continues ta refer ta tha value passed
into \fInewprint()\fR \fIdespite\fR \*(L"my \f(CW$x\fR\*(R" havin gone outta scope by the
time tha anonymous subroutine runs.  Thatz what tha fuck a cold-ass lil closure be all
about.
.Sp
This applies only ta lexical variables, by tha way.  Dynamic variables
continue ta work as they have always worked. Y'all KNOW dat shit, muthafucka!  Closure aint something
that most Perl programmers need shiznit theyselves bout ta begin with.
.IP "5." 4
.IX Xref "constructor new"
.IX Item "5."
References is often returned by special subroutines called constructors.  Perl
objects is just references ta a special type of object dat happens ta know
which package itz associated with.  Constructors is just special subroutines
that know how tha fuck ta create dat association. I aint talkin' bout chicken n' gravy biatch.  They do so by startin wit an
ordinary reference, n' it remains a ordinary reference even while itz also
bein a object.  Constructors is often named \f(CW\*(C`new()\*(C'\fR.  Yo ass \fIcan\fR call them
indirectly:
.Sp
.Vb 1
\&    $objref = freshly smoked up Doggie( Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq );
.Ve
.Sp
But dat can produce ambiguous syntax up in certain cases, so itz often
betta ta use tha direct method invocation approach:
.Sp
.Vb 1
\&    $objref   = Doggie\->new(Tail => \*(Aqshort\*(Aq, Ears => \*(Aqlong\*(Aq);
\&
\&    use Term::Cap;
\&    $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 });
\&
\&    use Tk;
\&    $main    = MainWindow\->new();
\&    $menubar = $main\->Frame(\-relief              => "raised",
\&                            \-borderwidth         => 2)
.Ve
.IP "6." 4
.IX Xref "autovivification"
.IX Item "6."
Referencez of tha appropriate type can sprang tha fuck into existence if you
dereference dem up in a cold-ass lil context dat assumes they exist.  Because our crazy asses haven't
talked bout dereferencin yet, we can't show you any examplez yet.
.IP "7." 4
.IX Xref "*foo{THING} *"
.IX Item "7."
A reference can be pimped by rockin a special syntax, gangbanginly known as
the *foo{\s-1THING\s0} syntax.  *foo{\s-1THING\s0} returns a reference ta tha \s-1THING\s0
slot up in *foo (which is tha symbol table entry which holdz every last muthafuckin thang
known as foo).
.Sp
.Vb 9
\&    $scalarref = *foo{SCALAR};
\&    $arrayref  = *ARGV{ARRAY};
\&    $hashref   = *ENV{HASH};
\&    $coderef   = *handlez{CODE};
\&    $ioref     = *STDIN{IO};
\&    $globref   = *foo{GLOB};
\&    $formatref = *foo{FORMAT};
\&    $globname  = *foo{NAME};    # "foo"
\&    $pkgname   = *foo{PACKAGE}; # "main"
.Ve
.Sp
Most of these is self-explanatory yo, but \f(CW*foo{IO}\fR
deserves special attention. I aint talkin' bout chicken n' gravy biatch.  It returns
the \s-1IO\s0 handle, used fo' file handlez (\*(L"open\*(R" up in perlfunc), sockets
(\*(L"socket\*(R" up in perlfunc n' \*(L"socketpair\*(R" up in perlfunc), n' directory
handlez (\*(L"opendir\*(R" up in perlfunc).  For compatibilitizzle wit previous
versionz of Perl, \f(CW*foo{FILEHANDLE}\fR be a synonym fo' \f(CW*foo{IO}\fR, though it
is deprecated az of 5.8.0.  If deprecation warnings is up in effect, it will warn
of its use.
.Sp
\&\f(CW*foo{THING}\fR returns undef if dat particular \s-1THING\s0 aint been used yet,
except up in tha case of scalars.  \f(CW*foo{SCALAR}\fR returns a reference ta an
anonymous scalar if \f(CW$foo\fR aint been used yet.  This might chizzle up in a
future release.
.Sp
\&\f(CW*foo{NAME}\fR n' \f(CW*foo{PACKAGE}\fR is tha exception, up in dat they return
strings, rather than references.  These return tha package n' name of the
typeglob itself, rather than one dat has been assigned ta dat shit.  So, after
\&\f(CW\*(C`*foo=*Foo::bar\*(C'\fR, \f(CW*foo\fR will become \*(L"*Foo::bar\*(R" when used as a string,
but \f(CW*foo{PACKAGE}\fR n' \f(CW*foo{NAME}\fR will continue ta produce \*(L"main\*(R" and
\&\*(L"foo\*(R", respectively.
.Sp
\&\f(CW*foo{IO}\fR be a alternatizzle ta tha \f(CW*HANDLE\fR mechanizzle given in
\&\*(L"Typeglobs n' Filehandles\*(R" up in perldata fo' passin filehandles
into or outta subroutines, or storin tha fuck into larger data structures.
Its disadvantage is dat it won't create a freshly smoked up filehandle fo' yo thugged-out ass.
Its advantage is dat you have less risk of clobberin mo' than
you wanna wit a typeglob assignment.  (It still conflates file
and directory handles, though.)  But fuck dat shiznit yo, tha word on tha street is dat if you assign tha incoming
value ta a scalar instead of a typeglob as our phat asses do up in tha examples
below, there be a no risk of dat happening.
.Sp
.Vb 2
\&    splutter(*STDOUT);          # pass tha whole glob
\&    splutter(*STDOUT{IO});      # pass both file n' dir handles
\&
\&    sub splutta {
\&        mah $fh = shift;
\&        print $fh "her um well a hmmm\en";
\&    }
\&
\&    $rec = get_rec(*STDIN);     # pass tha whole glob
\&    $rec = get_rec(*STDIN{IO}); # pass both file n' dir handles
\&
\&    sub get_rec {
\&        mah $fh = shift;
\&        return scalar <$fh>;
\&    }
.Ve
.SS "Usin References"
.IX Xref "reference, use dereferencin dereference"
.IX Subsection "Usin References"
Thatz it fo' bustin references.  By now you probably dyin to
know how tha fuck ta use references ta git back ta yo' long-lost data.  There
are nuff muthafuckin basic methods.
.IP "1." 4
Anywhere you'd put a identifier (or chain of identifiers) as part
of a variable or subroutine name, you can replace tha identifier with
a simple scalar variable containin a reference of tha erect type:
.Sp
.Vb 6
\&    $bar = $$scalarref;
\&    push(@$arrayref, $filename);
\&    $$arrayref[0] = "January";
\&    $$hashref{"KEY"} = "VALUE";
\&    &$coderef(1,2,3);
\&    print $globref "output\en";
.Ve
.Sp
It aint nuthin but blingin ta KNOW dat we is specifically \fInot\fR dereferencing
\&\f(CW$arrayref[0]\fR or \f(CW$hashref{"KEY"}\fR there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da dereference of the
scalar variable happens \fIbefore\fR it do any key lookups.  Anythang more
fucked up than a simple scalar variable must use methodz 2 or 3 below.
But fuck dat shiznit yo, tha word on tha street is dat a \*(L"simple scalar\*(R" includes a identifier dat itself uses method
1 recursively.  Therefore, tha followin prints \*(L"howdy\*(R".
.Sp
.Vb 2
\&    $refrefref = \e\e\e"howdy";
\&    print $$$$refrefref;
.Ve
.IP "2." 4
Anywhere you'd put a identifier (or chain of identifiers) as part of a
variable or subroutine name, you can replace tha identifier wit a
\&\s-1BLOCK\s0 returnin a reference of tha erect type.  In other lyrics, the
previous examplez could be freestyled like this:
.Sp
.Vb 6
\&    $bar = ${$scalarref};
\&    push(@{$arrayref}, $filename);
\&    ${$arrayref}[0] = "January";
\&    ${$hashref}{"KEY"} = "VALUE";
\&    &{$coderef}(1,2,3);
\&    $globref\->print("output\en");  # iff IO::Handle is loaded
.Ve
.Sp
Admittedly, itz a lil wack-ass ta use tha curlies up in dis case yo, but
the \s-1BLOCK\s0 can contain any arbitrary expression, up in particular,
subscripted expressions:
.Sp
.Vb 1
\&    &{ $dispatch{$index} }(1,2,3);      # call erect routine
.Ve
.Sp
Because of bein able ta omit tha curlies fo' tha simple case of \f(CW$$x\fR,
people often make tha fuck up of viewin tha dereferencin symbols as
proper operators, n' wonder bout they precedence.  If they were,
though, you could use parentheses instead of braces.  Thatz not tha case.
Consider tha difference below; case 0 be a gangbangin' finger-lickin' dirty-ass short-hand version of case 1,
\&\fInot\fR case 2:
.Sp
.Vb 4
\&    $$hashref{"KEY"}   = "VALUE";       # CASE 0
\&    ${$hashref}{"KEY"} = "VALUE";       # CASE 1
\&    ${$hashref{"KEY"}} = "VALUE";       # CASE 2
\&    ${$hashref\->{"KEY"}} = "VALUE";     # CASE 3
.Ve
.Sp
Case 2 be also deceptizzle up in dat you accessin a variable
called \f(CW%hashref\fR, not dereferencin all up in \f(CW$hashref\fR ta tha hash
itz presumably referencing.  That would be case 3.
.IP "3." 4
Subroutine calls n' lookupz of individual array elements arise often
enough dat it gets cumbersome ta use method 2.  As a gangbangin' form of
syntactic sugar, tha examplez fo' method 2 may be written:
.Sp
.Vb 3
\&    $arrayref\->[0] = "January";   # Array element
\&    $hashref\->{"KEY"} = "VALUE";  # Hash element
\&    $coderef\->(1,2,3);            # Subroutine call
.Ve
.Sp
Da left side of tha arrow can be any expression returnin a reference,
includin a previous dereference.  Note dat \f(CW$array[$x]\fR is \fInot\fR the
same thang as \f(CW\*(C`$array\->[$x]\*(C'\fR here:
.Sp
.Vb 1
\&    $array[$x]\->{"foo"}\->[0] = "January";
.Ve
.Sp
This is one of tha cases we mentioned earlier up in which references could
sprin tha fuck into existence when up in a lvalue context.  Before this
statement, \f(CW$array[$x]\fR may done been undefined. Y'all KNOW dat shit, muthafucka!  If so, it's
automatically defined wit a hash reference so dat we can look up
\&\f(CW\*(C`{"foo"}\*(C'\fR up in dat shit.  Likewise \f(CW\*(C`$array[$x]\->{"foo"}\*(C'\fR will automatically get
defined wit a array reference so dat we can look up \f(CW\*(C`[0]\*(C'\fR up in dat shit.
This process is called \fIautovivification\fR.
.Sp
One mo' thang here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Da arrow is optionizzle \fIbetween\fR brackets
subscripts, so you can shrink tha above down to
.Sp
.Vb 1
\&    $array[$x]{"foo"}[0] = "January";
.Ve
.Sp
Which, up in tha degenerate case of rockin only ordinary arrays, gives you
multidimensionizzle arrays just like C's:
.Sp
.Vb 1
\&    $score[$x][$y][$z] += 42;
.Ve
.Sp
Well, aiiight, not entirely like Cz arrays, actually.  C don't give a fuck how
to grow its arrays on demand. Y'all KNOW dat shit, muthafucka!  Perl do.
.IP "4." 4
If a reference happens ta be a reference ta a object, then there are
probably methodz ta access tha thangs referred to, n' you should probably
stick ta dem methodz unless you up in tha class package dat defines the
objectz methods.  In other lyrics, be sick, n' don't violate tha object's
encapsulation without a straight-up phat reason. I aint talkin' bout chicken n' gravy biatch.  Perl do not enforce
encapsulation. I aint talkin' bout chicken n' gravy biatch.  Our asses aint totalitarians here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Us dudes do expect some basic
civilitizzle though.
.PP
Usin a strang or number as a reference produces a symbolic reference,
as explained above.  Usin a reference as a number produces an
integer representin its storage location up in memory.  Da only
useful thang ta be done wit dis is ta compare two references
numerically ta peep whether they refer ta tha same location.
.IX Xref "reference, numeric context"
.PP
.Vb 3
\&    if ($ref1 == $ref2) {  # skanky numeric compare of references
\&        print "refs 1 n' 2 refer ta tha same thang\en";
\&    }
.Ve
.PP
Usin a reference as a strang produces both its referentz type,
includin any package blessin as busted lyrics bout up in perlobj, as well
as tha numeric address expressed up in hex.  Da \fIref()\fR operator returns
just tha type of thang tha reference is pointin to, without the
address.  See \*(L"ref\*(R" up in perlfunc fo' details n' examplez of its use.
.IX Xref "reference, strang context"
.PP
Da \fIbless()\fR operator may be used ta associate tha object a reference
points ta wit a package functionin as a object class.  See perlobj.
.PP
A typeglob may be dereferenced tha same way a reference can, cuz
the dereference syntax always indicates tha type of reference desired.
So \f(CW\*(C`${*foo}\*(C'\fR n' \f(CW\*(C`${\e$foo}\*(C'\fR both indicate tha same scalar variable.
.PP
Herez a trick fo' interpolatin a subroutine call tha fuck into a string:
.PP
.Vb 1
\&    print "My fuckin sub returned @{[mysub(1,2,3)]} dat time.\en";
.Ve
.PP
Da way it works is dat when tha \f(CW\*(C`@{...}\*(C'\fR is peeped up in tha double-quoted
string, itz evaluated as a funky-ass block.  Da block creates a reference ta an
anonymous array containin tha thangs up in dis biatch of tha call ta \f(CW\*(C`mysub(1,2,3)\*(C'\fR.  So
the whole block returns a reference ta a array, which is then
dereferenced by \f(CW\*(C`@{...}\*(C'\fR n' stuck tha fuck into tha double-quoted string. This
chicanery be also useful fo' arbitrary expressions:
.PP
.Vb 1
\&    print "That yieldz @{[$n + 5]} widgets\en";
.Ve
.PP
Similarly, a expression dat returns a reference ta a scalar can be
dereferenced via \f(CW\*(C`${...}\*(C'\fR. Thus, tha above expression may be written
as:
.PP
.Vb 1
\&    print "That yieldz ${\e($n + 5)} widgets\en";
.Ve
.SS "Circular References"
.IX Xref "circular reference reference, circular"
.IX Subsection "Circular References"
It be possible ta create a \*(L"circular reference\*(R" up in Perl, which can lead
to memory leaks fo' realz. A circular reference occurs when two references
contain a reference ta each other, like this:
.PP
.Vb 3
\&    mah $foo = {};
\&    mah $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
.Ve
.PP
Yo ass can also create a cold-ass lil circular reference wit a single variable:
.PP
.Vb 2
\&    mah $foo;
\&    $foo = \e$foo;
.Ve
.PP
In dis case, tha reference count fo' tha variablez aint NEVER gonna reach 0,
and tha references aint NEVER gonna be garbage-collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This can lead to
memory leaks.
.PP
Because objects up in Perl is implemented as references, itz possible to
have circular references wit objects as well. Imagine a TreeNode class
where each node references its parent n' lil pimp nodes fo' realz. Any node wit a
parent is ghon be part of a cold-ass lil circular reference.
.PP
Yo ass can break circular references by bustin a \*(L"weak reference\*(R" fo' realz. A
weak reference do not increment tha reference count fo' a variable,
which means dat tha object can go outta scope n' be destroyed. Y'all KNOW dat shit, muthafucka! You
can weaken a reference wit tha \f(CW\*(C`weaken\*(C'\fR function exported by the
Scalar::Util module.
.PP
Herez how tha fuck we can make tha straight-up original gangsta example safer:
.PP
.Vb 1
\&    use Scalar::Util \*(Aqweaken\*(Aq;
\&
\&    mah $foo = {};
\&    mah $bar = { foo => $foo };
\&    $foo\->{bar} = $bar;
\&
\&    weaken $foo\->{bar};
.Ve
.PP
Da reference from \f(CW$foo\fR ta \f(CW$bar\fR has been weakened. Y'all KNOW dat shit, muthafucka! When the
\&\f(CW$bar\fR variable goes outta scope, it is ghon be garbage-collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. The
next time you peep tha value of tha \f(CW\*(C`$foo\->{bar}\*(C'\fR key, it will
be \f(CW\*(C`undef\*(C'\fR.
.PP
This action at a gangbangin' finger-lickin' distizzle can be confusing, so you should be careful
with yo' use of weaken. I aint talkin' bout chicken n' gravy biatch. Yo ass should weaken tha reference up in the
variable dat will go outta scope \fIfirst\fR. That way, tha longer-lived
variable will contain tha expected reference until it goes up of
scope.
.SS "Symbolic references"
.IX Xref "reference, symbolic reference, soft symbolic reference soft reference"
.IX Subsection "Symbolic references"
We holla'd dat references sprang tha fuck into existence as necessary if they are
undefined yo, but our phat asses didn't say what tha fuck happens if a value used as a
reference be already defined yo, but \fIaint\fR a hard reference.  If you
use it as a reference, it'll be treated as a symbolic
reference.  That is, tha value of tha scalar is taken ta be tha \fIname\fR
of a variable, rather than a gangbangin' finger-lickin' direct link ta a (possibly) anonymous
value.
.PP
Muthafuckas frequently expect it ta work like all dis bullshit.  So it do.
.PP
.Vb 9
\&    $name = "foo";
\&    $$name = 1;                 # Sets $foo
\&    ${$name} = 2;               # Sets $foo
\&    ${$name x 2} = 3;           # Sets $foofoo
\&    $name\->[0] = 4;             # Sets $foo[0]
\&    @$name = ();                # Clears @foo
\&    &$name();                   # Calls &foo()
\&    $pack = "THAT";
\&    ${"${pack}::$name"} = 5;    # Sets $THAT::foo without eval
.Ve
.PP
This is powerful, n' slightly dangerous, up in dat itz possible
to intend (with tha utmost sincerity) ta bust a hard reference, and
accidentally bust a symbolic reference instead. Y'all KNOW dat shit, muthafucka!  To protect against
that, you can say
.PP
.Vb 1
\&    use strict \*(Aqrefs\*(Aq;
.Ve
.PP
and then only hard references is ghon be allowed fo' tha rest of tha enclosing
block.  An inner block may countermand dat with
.PP
.Vb 1
\&    no strict \*(Aqrefs\*(Aq;
.Ve
.PP
Only package variablez (globals, even if localized) is visible to
symbolic references.  Lexical variablez (declared wit \fImy()\fR) aren't in
a symbol table, n' thus is invisible ta dis mechanism.  For example:
.PP
.Vb 6
\&    local $value = 10;
\&    $ref = "value";
\&    {
\&        mah $value = 20;
\&        print $$ref;
\&    }
.Ve
.PP
This will still print 10, not 20.  Remember dat \fIlocal()\fR affects package
variables, which is all \*(L"global\*(R" ta tha package.
.SS "Not-so-symbolic references"
.IX Subsection "Not-so-symbolic references"
Brackets round a symbolic reference can simply
serve ta isolate a identifier or variable name from tha rest of an
expression, just as they always have within a string.  For example,
.PP
.Vb 2
\&    $push = "pop on ";
\&    print "${push}over";
.Ve
.PP
has always meant ta print \*(L"pop on over\*(R", even though push is
a reserved word. Y'all KNOW dat shit, muthafucka!  This is generalized ta work tha same
without tha enclosin double quotes, so that
.PP
.Vb 1
\&    print ${push} . "over";
.Ve
.PP
and even
.PP
.Vb 1
\&    print ${ push } . "over";
.Ve
.PP
will have tha same effect.  This
construct is \fInot\fR considered ta be a symbolic reference when you is
usin strict refs:
.PP
.Vb 3
\&    use strict \*(Aqrefs\*(Aq;
\&    ${ bareword };      # Okay, means $bareword.
\&    ${ "bareword" };    # Error, symbolic reference.
.Ve
.PP
Similarly, cuz of all tha subscriptin dat is done rockin single lyrics,
the same rule applies ta any bareword dat is used fo' subscriptin a hash.
So now, instead of writing
.PP
.Vb 1
\&    $array{ "aaa" }{ "bbb" }{ "ccc" }
.Ve
.PP
you can write just
.PP
.Vb 1
\&    $array{ aaa }{ bbb }{ ccc }
.Ve
.PP
and not worry bout whether tha subscripts is reserved lyrics.  In the
rare event dat you do wish ta do suttin' like
.PP
.Vb 1
\&    $array{ shift }
.Ve
.PP
you can force interpretation as a reserved word by addin anythang that
makes it mo' than a funky-ass bareword:
.PP
.Vb 3
\&    $array{ shift() }
\&    $array{ +shift }
\&    $array{ shift @_ }
.Ve
.PP
Da \f(CW\*(C`use warnings\*(C'\fR pragma or tha \fB\-w\fR switch will warn you if it
interprets a reserved word as a string.
But it will no longer warn you bout rockin lowercase lyrics, cuz the
strin is effectively quoted.
.SS "Pseudo-hashes: Usin a array as a hash"
.IX Xref "pseudo-hash pseudo hash pseudohash"
.IX Subsection "Pseudo-hashes: Usin a array as a hash"
Pseudo-hashes done been removed from Perl.  Da 'fields' pragma
remains available.
.SS "Function Templates"
.IX Xref "scope, lexical closure lexical lexical scope subroutine, nested sub, nested subroutine, local sub, local"
.IX Subsection "Function Templates"
As explained above, a anonymous function wit access ta tha lexical
variablez visible when dat function was compiled, creates a cold-ass lil closure.  It
retains access ta dem variablez even though it don't git run until
later, like fuckin up in a signal handlez or a Tk callback.
.PP
Usin a cold-ass lil closure as a gangbangin' function template allows our asses ta generate nuff functions
that act similarly.  Suppose you wanted functions named afta tha colors
that generated \s-1HTML\s0 font chizzlez fo' tha various colors:
.PP
.Vb 1
\&    print "Be ", red("careful"), "with dat ", green("light");
.Ve
.PP
Da \fIred()\fR n' \fIgreen()\fR functions would be similar. Shiiit, dis aint no joke.  To create these,
we'll assign a cold-ass lil closure ta a typeglob of tha name of tha function we're
tryin ta build.
.PP
.Vb 5
\&    @colors = qw(red blue chronic yellow orange purple violet);
\&    fo' mah $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;       # allow symbol table manipulation
\&        *$name = *{uc $name} = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
Now all dem different functions step tha fuck up ta exist independently.  Yo ass can
call \fIred()\fR, \s-1\fIRED\s0()\fR, \fIblue()\fR, \s-1\fIBLUE\s0()\fR, \fIgreen()\fR, etc.  This technique saves on
both compile time n' memory use, n' is less error-prone as well, since
syntax checks happen at compile time.  It aint nuthin but critical dat any variablez in
the anonymous subroutine be lexicals up in order ta create a proper closure.
Thatz tha reasons fo' tha \f(CW\*(C`my\*(C'\fR on tha loop iteration variable.
.PP
This is one of tha only places where givin a prototype ta a cold-ass lil closure makes
much sense.  If you wanted ta impose scalar context on tha arguments of
these functions (probably not a wise scam fo' dis particular example),
you could have freestyled it dis way instead:
.PP
.Vb 1
\&    *$name = sub ($) { "<FONT COLOR=\*(Aq$name\*(Aq>$_[0]</FONT>" };
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat since prototype checkin happens at compile time, tha assignment
above happens too late ta be of much use.  Yo ass could address dis by
puttin tha whole loop of assignments within a \s-1BEGIN\s0 block, forcin it
to occur durin compilation.
.PP
Access ta lexicals dat chizzle over time\*(--like dem up in tha \f(CW\*(C`for\*(C'\fR loop
above, basically aliases ta elements from tha surroundin lexical scopes\*(--
only works wit anonymous subs, not wit named subroutines. Generally
said, named subroutines do not nest properly n' should only be declared
in tha main package scope.
.PP
This is cuz named subroutines is pimped at compile time so their
lexical variablez git assigned ta tha parent lexicals from tha first
execution of tha parent block. If a parent scope is entered a second
time, its lexicals is pimped again, while tha nested subs still
reference tha oldschool ones.
.PP
Anonymous subroutines git ta capture each time you execute tha \f(CW\*(C`sub\*(C'\fR
operator, as they is pimped on tha fly. If yo ass be accustomed ta using
nested subroutines up in other programmin languages wit they own private
variables, you gonna gotta work at it a lil' bit up in Perl.  Da intuitizzle coding
of dis type of thang incurs mysterious warnings bout \*(L"will not stay
shared\*(R" cuz of tha reasons explained above. 
For example, dis won't work:
.PP
.Vb 5
\&    sub outa {
\&        mah $x = $_[0] + 35;
\&        sub inner { return $x * 19 }   # WRONG
\&        return $x + inner();
\&    }
.Ve
.PP
A work-around is tha following:
.PP
.Vb 5
\&    sub outa {
\&        mah $x = $_[0] + 35;
\&        local *inner = sub { return $x * 19 };
\&        return $x + inner();
\&    }
.Ve
.PP
Now \fIinner()\fR can only be called from within \fIouter()\fR, cuz of the
temporary assignmentz of tha anonymous subroutine. But when it do,
it has aiiight access ta tha lexical variable \f(CW$x\fR from tha scope of
\&\fIouter()\fR all up in tha time outa is invoked.
.PP
This has tha bangin-ass effect of bustin a gangbangin' function local ta another
function, suttin' not normally supported up in Perl.
.SH "WARNING"
.IX Xref "reference, strang context reference, use as hash key"
.IX Header "WARNING"
Yo ass may not (usefully) bust a reference as tha key ta a hash.  It will be
converted tha fuck into a string:
.PP
.Vb 1
\&    $x{ \e$a } = $a;
.Ve
.PP
If you try ta dereference tha key, it won't do a hard dereference, and
you won't accomplish what tha fuck you attempting.  Yo ass might wanna do something
more like
.PP
.Vb 2
\&    $r = \e@a;
\&    $x{ $r } = $r;
.Ve
.PP
And then at least you can use tha \fIvalues()\fR, which will be
real refs, instead of tha \fIkeys()\fR, which won't.
.PP
Da standard Tie::RefHash module serves up a cold-ass lil convenient workaround ta all dis bullshit.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Besides tha obvious documents, source code can be instructive.
Some pathological examplez of tha use of references can be found
in tha \fIt/op/ref.t\fR regression test up in tha Perl source directory.
.PP
See also perldsc n' perllol fo' how tha fuck ta use references ta create
complex data structures, n' perlootut n' perlobj
for how tha fuck ta use dem ta create objects.
