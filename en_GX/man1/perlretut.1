.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRETUT 1"
.TH PERLRETUT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlretut \- Perl regular expressions tutorial
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page serves up a funky-ass basic tutorial on understanding, bustin and
usin regular expressions up in Perl.  It serves as a cold-ass lil complement ta the
reference page on regular expressions perlre.  Regular expressions
are a integral part of tha \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR n' \f(CW\*(C`split\*(C'\fR
operators n' so dis tutorial also overlaps with
\&\*(L"Regexp Quote-Like Operators\*(R" up in perlop n' \*(L"split\*(R" up in perlfunc.
.PP
Perl is widely renowned fo' excellence up in text processing, n' regular
expressions is one of tha big-ass factors behind dis fame.  Perl regular
expressions display a efficiency n' flexibilitizzle unknown up in most
other computa languages.  Masterin even tha basics of regular
expressions will allow you ta manipulate text wit surprisin ease.
.PP
What tha fuck iz a regular expression, biatch?  A regular expression is simply a string
that raps on some pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Patterns is up in common use these days;
examplez is tha patterns typed tha fuck into a search engine ta find wizzy pages
and tha patterns used ta list filez up in a gangbangin' finger-lickin' directory, e.g., \f(CW\*(C`ls *.txt\*(C'\fR
or \f(CW\*(C`dir *.*\*(C'\fR.  In Perl, tha patterns busted lyrics bout by regular expressions
are used ta search strings, extract desired partz of strings, n' to
do search n' replace operations.
.PP
Regular expressions have tha undeserved hype of bein abstract
and hard as fuck ta understand. Y'all KNOW dat shit, muthafucka!  Regular expressions is constructed using
simple concepts like conditionals n' loops n' is no mo' difficult
to KNOW than tha correspondin \f(CW\*(C`if\*(C'\fR conditionals n' \f(CW\*(C`while\*(C'\fR
loops up in tha Perl language itself.  In fact, tha main challenge in
learnin regular expressions is just gettin used ta tha terse
notation used ta express these concepts.
.PP
This tutorial flattens tha peepin' curve by discussin regular
expression concepts, along wit they notation, one at a time n' with
many examples.  Da first part of tha tutorial will progress from the
simplest word searches ta tha basic regular expression concepts, n' you can put dat on yo' toast.  If
you masta tha straight-up original gangsta part, you gonna git all tha tools needed ta solve
about 98% of yo' needs.  Da second part of tha tutorial is fo' them
comfortable wit tha basics n' horny fo' mo' juice tools.  It
discusses tha mo' advanced regular expression operators and
introduces tha sickest fuckin cutting-edge innovations.
.PP
A note: ta save time, 'regular expression' is often abbreviated as
regexp or regex.  Regexp be a mo' natural abbreviation than regex yo, but
is harder ta pronounce.  Da Perl pod documentation is evenly split on
regexp vs regex; up in Perl, there is mo' than one way ta abbreviate dat shit.
We bout ta use regexp up in dis tutorial.
.SH "Part 1: Da basics"
.IX Header "Part 1: Da basics"
.SS "Simple word matching"
.IX Subsection "Simple word matching"
Da simplest regexp is simply a word, or mo' generally, a strang of
characters.  A regexp consistin of a word matches any strang that
gotz nuff dat word:
.PP
.Vb 1
\&    "Wuz crackalackin' World" =~ /World/;  # matches
.Ve
.PP
What tha fuck iz dis Perl statement all about, biatch? \f(CW"Wuz crackalackin' World"\fR be a simple
double-quoted string.  \f(CW\*(C`World\*(C'\fR is tha regular expression n' the
\&\f(CW\*(C`//\*(C'\fR enclosin \f(CW\*(C`/World/\*(C'\fR  drops some lyrics ta Perl ta search a strang fo' a match.
Da operator \f(CW\*(C`=~\*(C'\fR associates tha strang wit tha regexp match and
produces a legit value if tha regexp matched, or false if tha regexp
did not match.  In our case, \f(CW\*(C`World\*(C'\fR matches tha second word in
\&\f(CW"Wuz crackalackin' World"\fR, so tha expression is true.  Expressions like this
are useful up in conditionals:
.PP
.Vb 6
\&    if ("Wuz crackalackin' World" =~ /World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It don\*(Aqt match\en";
\&    }
.Ve
.PP
There is useful variations on dis theme.  Da sense of tha match can
be reversed by rockin tha \f(CW\*(C`!~\*(C'\fR operator:
.PP
.Vb 6
\&    if ("Wuz crackalackin' World" !~ /World/) {
\&        print "It don\*(Aqt match\en";
\&    }
\&    else {
\&        print "It matches\en";
\&    }
.Ve
.PP
Da literal strang up in tha regexp can be replaced by a variable:
.PP
.Vb 7
\&    $greetin = "World";
\&    if ("Wuz crackalackin' World" =~ /$greeting/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It don\*(Aqt match\en";
\&    }
.Ve
.PP
If you matchin against tha special default variable \f(CW$_\fR, the
\&\f(CW\*(C`$_ =~\*(C'\fR part can be omitted:
.PP
.Vb 7
\&    $_ = "Wuz crackalackin' World";
\&    if (/World/) {
\&        print "It matches\en";
\&    }
\&    else {
\&        print "It don\*(Aqt match\en";
\&    }
.Ve
.PP
And finally, tha \f(CW\*(C`//\*(C'\fR default delimitas fo' a match can be chizzled
to arbitrary delimitas by puttin a \f(CW\*(Aqm\*(Aq\fR up front:
.PP
.Vb 4
\&    "Wuz crackalackin' World" =~ m!World!;   # matches, delimited by \*(Aq!\*(Aq
\&    "Wuz crackalackin' World" =~ m{World};   # matches, note tha matchin \*(Aq{}\*(Aq
\&    "/usr/bin/perl" =~ m"/perl"; # matches afta \*(Aq/usr/bin\*(Aq,
\&                                 # \*(Aq/\*(Aq becomes a ordinary char
.Ve
.PP
\&\f(CW\*(C`/World/\*(C'\fR, \f(CW\*(C`m!World!\*(C'\fR, n' \f(CW\*(C`m{World}\*(C'\fR all represent the
same thang.  When, e.g., tha quote (\f(CW\*(C`"\*(C'\fR) is used as a thugged-out delimiter, tha forward
slash \f(CW\*(Aq/\*(Aq\fR becomes a ordinary characta n' can be used up in dis regexp
without shit.
.PP
Letz consider how tha fuck different regexps would match \f(CW"Wuz crackalackin' World"\fR:
.PP
.Vb 4
\&    "Wuz crackalackin' World" =~ /world/;  # don\*(Aqt match
\&    "Wuz crackalackin' World" =~ /o W/;    # matches
\&    "Wuz crackalackin' World" =~ /oW/;     # don\*(Aqt match
\&    "Wuz crackalackin' World" =~ /Ghetto /; # don\*(Aqt match
.Ve
.PP
Da first regexp \f(CW\*(C`world\*(C'\fR don't match cuz regexps are
case-sensitive.  Da second regexp matches cuz tha substring
\&\f(CW\*(Aqo\ W\*(Aq\fR occurs up in tha strang \f(CW"Hello\ World"\fR.  Da space
characta ' ' is treated like any other characta up in a regexp n' is
needed ta match up in dis case.  Da lack of a space characta is the
reason tha third regexp \f(CW\*(AqoW\*(Aq\fR don't match.  Da fourth regexp
\&\f(CW\*(AqGhetto \*(Aq\fR don't match cuz there be a space all up in tha end of the
regexp yo, but not all up in tha end of tha string.  Da lesson here is that
regexps must match a part of tha strang \fIexactly\fR up in order fo' the
statement ta be true.
.PP
If a regexp matches up in mo' than one place up in tha string, Perl will
always match all up in tha earliest possible point up in tha string:
.PP
.Vb 2
\&    "Wuz crackalackin' World" =~ /o/;       # matches \*(Aqo\*(Aq up in \*(AqHello\*(Aq
\&    "That basebizzle cap is red" =~ /hat/; # matches \*(Aqhat\*(Aq up in \*(AqThat\*(Aq
.Ve
.PP
With respect ta characta matching, there be all dem mo' points you
need ta know about.   First of all, not all charactas can be used 'as
is' up in a match.  Some characters, called \fImetacharacters\fR, is reserved
for use up in regexp notation. I aint talkin' bout chicken n' gravy biatch.  Da metacharactas are
.PP
.Vb 1
\&    {}[]()^$.|*+?\e
.Ve
.PP
Da significizzle of each of these is ghon be explained
in tha rest of tha tutorial yo, but fo' now, it is blingin only ta know
that a metacharacta can be matched by puttin a funky-ass backslash before it:
.PP
.Vb 5
\&    "2+2=4" =~ /2+2/;    # don\*(Aqt match, + be a metacharacter
\&    "2+2=4" =~ /2\e+2/;   # matches, \e+ is treated like a ordinary +
\&    "Da interval is [0,1)." =~ /[0,1)./     # be a syntax error!
\&    "Da interval is [0,1)." =~ /\e[0,1\e)\e./  # matches
\&    "#!/usr/bin/perl" =~ /#!\e/usr\e/bin\e/perl/;  # matches
.Ve
.PP
In tha last regexp, tha forward slash \f(CW\*(Aq/\*(Aq\fR be also backslashed,
because it is used ta delimit tha regexp.  This can lead ta \s-1LTS
\&\s0(leanin toothpick syndrome), however, n' it is often mo' readable
to chizzle delimiters.
.PP
.Vb 1
\&    "#!/usr/bin/perl" =~ m!#\e!/usr/bin/perl!;  # easier ta read
.Ve
.PP
Da backslash characta \f(CW\*(Aq\e\*(Aq\fR be a metacharacta itself n' needz to
be backslashed:
.PP
.Vb 1
\&    \*(AqC:\eWIN32\*(Aq =~ /C:\e\eWIN/;   # matches
.Ve
.PP
In addizzle ta tha metacharacters, there be some \s-1ASCII\s0 characters
which aint gots printable characta equivalents n' is instead
represented by \fIescape sequences\fR.  Common examplez is \f(CW\*(C`\et\*(C'\fR fo' a
tab, \f(CW\*(C`\en\*(C'\fR fo' a newline, \f(CW\*(C`\er\*(C'\fR fo' a cold-ass lil carriage return n' \f(CW\*(C`\ea\*(C'\fR fo' a
bell (or alert).  If yo' strang is betta thought of as a sequence of arbitrary
bytes, tha octal escape sequence, e.g., \f(CW\*(C`\e033\*(C'\fR, or hexadecimal escape
sequence, e.g., \f(CW\*(C`\ex1B\*(C'\fR may be a mo' natural representation fo' your
bytes.  Here is some examplez of escapes:
.PP
.Vb 5
\&    "1000\et2000" =~ m(0\et2)   # matches
\&    "1000\en2000" =~ /0\en20/   # matches
\&    "1000\et2000" =~ /\e000\et2/ # don\*(Aqt match, "0" ne "\e000"
\&    "cat"   =~ /\eo{143}\ex61\ex74/ # matches up in ASCII yo, but a weird way
\&                                 # ta spell cat
.Ve
.PP
If you've been round Perl a while, all dis rap of escape sequences
may seem familiar. Shiiit, dis aint no joke.  Similar escape sequences is used up in double-quoted
strings n' up in fact tha regexps up in Perl is mostly treated as
double-quoted strings.  This means dat variablez can be used in
regexps as well.  Just like double-quoted strings, tha jointz of the
variablez up in tha regexp is ghon be substituted up in before tha regexp is
evaluated fo' matchin purposes.  So our crazy asses have:
.PP
.Vb 4
\&    $foo = \*(Aqhouse\*(Aq;
\&    \*(Aqhousecat\*(Aq =~ /$foo/;      # matches
\&    \*(Aqcathouse\*(Aq =~ /cat$foo/;   # matches
\&    \*(Aqhousecat\*(Aq =~ /${foo}cat/; # matches
.Ve
.PP
So far, so good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  With tha knowledge above you can already perform
searches wit just bout any literal strang regexp you can trip up.
Here be a \fIvery simple\fR emulation of tha Unix grep program:
.PP
.Vb 7
\&    % pussaaaaay > simple_grep
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    while (<>) {
\&        print if /$regexp/;
\&    }
\&    ^D
\&
\&    % chmod +x simple_grep
\&
\&    % simple_grep abba /usr/dict/words
\&    Babbage
\&    cabbage
\&    cabbages
\&    sabbath
\&    Sabbathize
\&    Sabbathizes
\&    sabbatical
\&    scabbard
\&    scabbards
.Ve
.PP
This program is easy as fuck  ta understand. Y'all KNOW dat shit, muthafucka!  \f(CW\*(C`#!/usr/bin/perl\*(C'\fR is tha standard
way ta invoke a perl program from tha shell.
\&\f(CW\*(C`$regexp\ =\ shift;\*(C'\fR saves tha straight-up original gangsta command line argument as the
regexp ta be used, leavin tha rest of tha command line arguments to
be treated as files.  \f(CW\*(C`while\ (<>)\*(C'\fR loops over all tha lines in
all tha files.  For each line, \f(CW\*(C`print\ if\ /$regexp/;\*(C'\fR prints the
line if tha regexp matches tha line.  In dis line, both \f(CW\*(C`print\*(C'\fR and
\&\f(CW\*(C`/$regexp/\*(C'\fR use tha default variable \f(CW$_\fR implicitly.
.PP
With all of tha regexps above, if tha regexp matched anywhere up in the
string, dat shiznit was considered a match.  Sometimes, however, we'd like to
specify \fIwhere\fR up in tha strang tha regexp should try ta match.  To do
this, we would use tha \fIanchor\fR metacharactas \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR.  The
anchor \f(CW\*(C`^\*(C'\fR means match all up in tha beginnin of tha strang n' tha anchor
\&\f(CW\*(C`$\*(C'\fR means match all up in tha end of tha string, or before a newline at the
end of tha string.  Here is how tha fuck they is used:
.PP
.Vb 4
\&    "housekeeper" =~ /keeper/;    # matches
\&    "housekeeper" =~ /^keeper/;   # don\*(Aqt match
\&    "housekeeper" =~ /keeper$/;   # matches
\&    "housekeeper\en" =~ /keeper$/; # matches
.Ve
.PP
Da second regexp don't match cuz \f(CW\*(C`^\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR to
match only all up in tha beginnin of tha strin yo, but \f(CW"housekeeper"\fR has
keeper startin up in tha middle.  Da third regexp do match, since the
\&\f(CW\*(C`$\*(C'\fR constrains \f(CW\*(C`keeper\*(C'\fR ta match only all up in tha end of tha string.
.PP
When both \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR is used all up in tha same time, tha regexp has to
match both tha beginnin n' tha end of tha string, i.e., tha regexp
matches tha whole string.  Consider
.PP
.Vb 3
\&    "keeper" =~ /^keep$/;      # don\*(Aqt match
\&    "keeper" =~ /^keeper$/;    # matches
\&    ""       =~ /^$/;          # ^$ matches a empty string
.Ve
.PP
Da first regexp don't match cuz tha strang has mo' ta it than
\&\f(CW\*(C`keep\*(C'\fR.  Since tha second regexp is exactly tha string, it
matches.  Usin both \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR up in a regexp forces tha complete
strin ta match, so it gives you complete control over which strings
match n' which don't.  Suppose yo ass is lookin fo' a gangbangin' fellow named
bert, off up in a strang by his dirty ass:
.PP
.Vb 1
\&    "dogbert" =~ /bert/;   # matches yo, but not what tha fuck you want
\&
\&    "dilbert" =~ /^bert/;  # don\*(Aqt match yo, but ..
\&    "bertram" =~ /^bert/;  # matches, so still not phat enough
\&
\&    "bertram" =~ /^bert$/; # don\*(Aqt match, good
\&    "dilbert" =~ /^bert$/; # don\*(Aqt match, good
\&    "bert"    =~ /^bert$/; # matches, perfect
.Ve
.PP
Of course, up in tha case of a literal string, one could just as easily
use tha strang comparison \f(CW\*(C`$string\ eq\ \*(Aqbert\*(Aq\*(C'\fR n' it would be
more efficient.   Da  \f(CW\*(C`^...$\*(C'\fR regexp straight-up becomes useful when we
add up in tha mo' bangin regexp tools below.
.SS "Usin characta classes"
.IX Subsection "Usin characta classes"
Although one can already do like a shitload wit tha literal string
regexps above, we've only scratched tha surface of regular expression
technology.  In dis n' subsequent sections we will introduce regexp
concepts (and associated metacharacta notations) dat will allow a
regexp ta represent not just a single characta sequence yo, but a \fIwhole
class\fR of em.
.PP
One such concept is dat of a \fIcharacta class\fR.  A characta class
allows a set of possible characters, rather than just a single
character, ta match at a particular point up in a regexp.  Character
classes is denoted by brackets \f(CW\*(C`[...]\*(C'\fR, wit tha set of characters
to be possibly matched inside.  Here is some examples:
.PP
.Vb 4
\&    /cat/;       # matches \*(Aqcat\*(Aq
\&    /[bcr]at/;   # matches \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&    /item[0123456789]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    "abc" =~ /[cab]/;    # matches \*(Aqa\*(Aq
.Ve
.PP
In tha last statement, even though \f(CW\*(Aqc\*(Aq\fR is tha straight-up original gangsta characta in
the class, \f(CW\*(Aqa\*(Aq\fR matches cuz tha straight-up original gangsta characta posizzle up in the
strin is tha earliest point at which tha regexp can match.
.PP
.Vb 2
\&    /[yY][eE][sS]/;      # match \*(Aqyes\*(Aq up in a cold-ass lil case\-insensitizzle way
\&                         # \*(Aqyes\*(Aq, \*(AqYes\*(Aq, \*(AqYES\*(Aq, etc.
.Ve
.PP
This regexp displays a cold-ass lil common task: big-ass up a cold-ass lil case-insensitive
match.  Perl serves up a way of avoidin all dem brackets by simply
appendin a \f(CW\*(Aqi\*(Aq\fR ta tha end of tha match.  Then \f(CW\*(C`/[yY][eE][sS]/;\*(C'\fR
can be rewritten as \f(CW\*(C`/yes/i;\*(C'\fR.  Da \f(CW\*(Aqi\*(Aq\fR standz for
case-insensitizzle n' be a example of a \fImodifier\fR of tha matching
operation. I aint talkin' bout chicken n' gravy biatch.  Us thugs will hook up other modifiers lata up in tha tutorial.
.PP
We saw up in tha section above dat there was ordinary characters, which
represented theyselves, n' special characters, which needed a
backslash \f(CW\*(C`\e\*(C'\fR ta represent theyselves.  Da same is legit up in a
characta class yo, but tha setz of ordinary n' special characters
inside a cold-ass lil characta class is different than dem outside a cold-ass lil character
class.  Da special charactas fo' a cold-ass lil characta class is \f(CW\*(C`\-]\e^$\*(C'\fR (and
the pattern delimiter, whatever it is).
\&\f(CW\*(C`]\*(C'\fR is special cuz it denotes tha end of a cold-ass lil characta class.  \f(CW\*(C`$\*(C'\fR is
special cuz it denotes a scalar variable.  \f(CW\*(C`\e\*(C'\fR is special cuz
it is used up in escape sequences, just like above.  Here is how tha fuck the
special charactas \f(CW\*(C`]$\e\*(C'\fR is handled:
.PP
.Vb 5
\&   /[\e]c]def/; # matches \*(Aq]def\*(Aq or \*(Aqcdef\*(Aq
\&   $x = \*(Aqbcr\*(Aq;
\&   /[$x]at/;   # matches \*(Aqbat\*(Aq, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
\&   /[\e$x]at/;  # matches \*(Aq$at\*(Aq or \*(Aqxat\*(Aq
\&   /[\e\e$x]at/; # matches \*(Aq\eat\*(Aq, \*(Aqbat, \*(Aqcat\*(Aq, or \*(Aqrat\*(Aq
.Ve
.PP
Da last two is a lil tricky.  In \f(CW\*(C`[\e$x]\*(C'\fR, tha backslash protects
the dollar sign, so tha characta class has two thugz \f(CW\*(C`$\*(C'\fR n' \f(CW\*(C`x\*(C'\fR.
In \f(CW\*(C`[\e\e$x]\*(C'\fR, tha backslash is protected, so \f(CW$x\fR is treated as a
variable n' substituted up in double quote fashion.
.PP
Da special characta \f(CW\*(Aq\-\*(Aq\fR acts as a range operator within character
classes, so dat a cold-ass lil contiguous set of charactas can be freestyled as a
range.  With ranges, tha unwieldy \f(CW\*(C`[0123456789]\*(C'\fR n' \f(CW\*(C`[abc...xyz]\*(C'\fR
become tha svelte \f(CW\*(C`[0\-9]\*(C'\fR n' \f(CW\*(C`[a\-z]\*(C'\fR.  Some examplez are
.PP
.Vb 6
\&    /item[0\-9]/;  # matches \*(Aqitem0\*(Aq or ... or \*(Aqitem9\*(Aq
\&    /[0\-9bx\-z]aa/;  # matches \*(Aq0aa\*(Aq, ..., \*(Aq9aa\*(Aq,
\&                    # \*(Aqbaa\*(Aq, \*(Aqxaa\*(Aq, \*(Aqyaa\*(Aq, or \*(Aqzaa\*(Aq
\&    /[0\-9a\-fA\-F]/;  # matches a hexadecimal digit
\&    /[0\-9a\-zA\-Z_]/; # matches a "word" character,
\&                    # like dem up in a Perl variable name
.Ve
.PP
If \f(CW\*(Aq\-\*(Aq\fR is tha straight-up original gangsta or last characta up in a cold-ass lil characta class, it is
treated as a ordinary character; \f(CW\*(C`[\-ab]\*(C'\fR, \f(CW\*(C`[ab\-]\*(C'\fR n' \f(CW\*(C`[a\e\-b]\*(C'\fR are
all equivalent.
.PP
Da special characta \f(CW\*(C`^\*(C'\fR up in tha straight-up original gangsta posizzle of a cold-ass lil characta class
denotes a \fInegated characta class\fR, which matches any characta but
those up in tha brackets, n' you can put dat on yo' toast.  Both \f(CW\*(C`[...]\*(C'\fR n' \f(CW\*(C`[^...]\*(C'\fR must match a
character, or tha match fails.  Then
.PP
.Vb 4
\&    /[^a]at/;  # don\*(Aqt match \*(Aqaat\*(Aq or \*(Aqat\*(Aq yo, but matches
\&               # all other \*(Aqbat\*(Aq, \*(Aqcat, \*(Aq0at\*(Aq, \*(Aq%at\*(Aq, etc.
\&    /[^0\-9]/;  # matches a non\-numeric character
\&    /[a^]at/;  # matches \*(Aqaat\*(Aq or \*(Aq^at\*(Aq; here \*(Aq^\*(Aq is ordinary
.Ve
.PP
Now, even \f(CW\*(C`[0\-9]\*(C'\fR can be a funky-ass bother ta write multiple times, so up in the
interest of savin keystrokes n' makin regexps mo' readable, Perl
has nuff muthafuckin abbreviations fo' common characta classes, as shown below.
Since tha introduction of Unicode, unless tha \f(CW\*(C`//a\*(C'\fR modifier is in
effect, these characta classes match mo' than just all dem charactas in
the \s-1ASCII\s0 range.
.IP "\(bu" 4
\&\ed matches a gangbangin' finger-lickin' digit, not just [0\-9] but also digits from non-roman scripts
.IP "\(bu" 4
\&\es matches a whitespace character, tha set [\e \et\er\en\ef] n' others
.IP "\(bu" 4
\&\ew matches a word characta (alphanumeric or _), not just [0\-9a\-zA\-Z_]
but also digits n' charactas from non-roman scripts
.IP "\(bu" 4
\&\eD be a negated \ed; it represents any other characta than a gangbangin' finger-lickin' digit, or [^\ed]
.IP "\(bu" 4
\&\eS be a negated \es; it represents any non-whitespace characta [^\es]
.IP "\(bu" 4
\&\eW be a negated \ew; it represents any non-word characta [^\ew]
.IP "\(bu" 4
Da period '.' matches any characta but \*(L"\en\*(R" (unless tha modifier \f(CW\*(C`//s\*(C'\fR is
in effect, as explained below).
.IP "\(bu" 4
\&\eN, like tha period, matches any characta but \*(L"\en\*(R" yo, but it do so
regardless of whether tha modifier \f(CW\*(C`//s\*(C'\fR is up in effect.
.PP
Da \f(CW\*(C`//a\*(C'\fR modifier, available startin up in Perl 5.14,  is used to
restrict tha matchez of \ed, \es, n' \ew ta just dem up in tha \s-1ASCII\s0 range.
It be useful ta keep yo' program from bein needlessly exposed ta full
Unicode (and its accompanyin securitizzle considerations) when all you want
is ta process Gangsta-like text.  (Da \*(L"a\*(R" may be doubled, \f(CW\*(C`//aa\*(C'\fR, to
provide even mo' restrictions, preventin case-insensitizzle matchin of
\&\s-1ASCII\s0 wit non-ASCII characters; otherwise a Unicode \*(L"Kelvin Sign\*(R"
would caselessly match a \*(L"k\*(R" or \*(L"K\*(R".)
.PP
Da \f(CW\*(C`\ed\es\ew\eD\eS\eW\*(C'\fR abbreviations can be used both inside n' outside
of characta classes.  Here is some up in use:
.PP
.Vb 7
\&    /\ed\ed:\ed\ed:\ed\ed/; # matches a hh:mm:ss time format
\&    /[\ed\es]/;         # matches any digit or whitespace character
\&    /\ew\eW\ew/;         # matches a word char, followed by a
\&                      # non\-word char, followed by a word char
\&    /..rt/;           # matches any two chars, followed by \*(Aqrt\*(Aq
\&    /end\e./;          # matches \*(Aqend.\*(Aq
\&    /end[.]/;         # same thang, matches \*(Aqend.\*(Aq
.Ve
.PP
Because a period be a metacharacter, it need ta be escaped ta match
as a ordinary period. Y'all KNOW dat shit, muthafucka! Because, fo' example, \f(CW\*(C`\ed\*(C'\fR n' \f(CW\*(C`\ew\*(C'\fR is sets
of characters, it is incorrect ta be thinkin of \f(CW\*(C`[^\ed\ew]\*(C'\fR as \f(CW\*(C`[\eD\eW]\*(C'\fR; in
fact \f(CW\*(C`[^\ed\ew]\*(C'\fR is tha same ol' dirty as \f(CW\*(C`[^\ew]\*(C'\fR, which is tha same ol' dirty as
\&\f(CW\*(C`[\eW]\*(C'\fR. Think DeMorganz laws.
.PP
An anchor useful up in basic regexps is tha \fIword anchor\fR
\&\f(CW\*(C`\eb\*(C'\fR.  This matches a funky-ass boundary between a word characta n' a non-word
characta \f(CW\*(C`\ew\eW\*(C'\fR or \f(CW\*(C`\eW\ew\*(C'\fR:
.PP
.Vb 5
\&    $x = "Housecat catenates doggy den n' cat";
\&    $x =~ /cat/;    # matches pussaaaaay up in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat/;  # matches pussaaaaay up in \*(Aqcatenates\*(Aq
\&    $x =~ /cat\eb/;  # matches pussaaaaay up in \*(Aqhousecat\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq at end of string
.Ve
.PP
Note up in tha last example, tha end of tha strang is considered a word
boundary.
.PP
Yo ass might wonder why \f(CW\*(Aq.\*(Aq\fR matches every last muthafuckin thang but \f(CW"\en"\fR \- why not
every character, biatch? Da reason is dat often one is matchin against
lines n' wanna ignore tha newline characters.  For instance,
while tha strang \f(CW"\en"\fR represents one line, we wanna think
of it as empty.  Then
.PP
.Vb 2
\&    ""   =~ /^$/;    # matches
\&    "\en" =~ /^$/;    # matches, $ anchors before "\en"
\&
\&    ""   =~ /./;      # don\*(Aqt match; it needz a cold-ass lil char
\&    ""   =~ /^.$/;    # don\*(Aqt match; it needz a cold-ass lil char
\&    "\en" =~ /^.$/;    # don\*(Aqt match; it needz a cold-ass lil char other than "\en"
\&    "a"  =~ /^.$/;    # matches
\&    "a\en"  =~ /^.$/;  # matches, $ anchors before "\en"
.Ve
.PP
This behavior is convenient, cuz we probably wanna ignore
newlines when we count n' match charactas up in a line.  Sometimes,
however, we wanna keep track of newlines.  We might even want \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR ta anchor all up in tha beginnin n' end of lines within the
string, rather than just tha beginnin n' end of tha string.  Perl
allows our asses ta chizzle between ignorin n' payin attention ta newlines
by rockin tha \f(CW\*(C`//s\*(C'\fR n' \f(CW\*(C`//m\*(C'\fR modifiers.  \f(CW\*(C`//s\*(C'\fR n' \f(CW\*(C`//m\*(C'\fR stand for
single line n' multi-line n' they determine whether a strang is to
be treated as one continuous string, or as a set of lines.  Da two
modifiers affect two aspectz of how tha fuck tha regexp is interpreted: 1) how
the \f(CW\*(Aq.\*(Aq\fR characta class is defined, n' 2) where tha anchors \f(CW\*(C`^\*(C'\fR
and \f(CW\*(C`$\*(C'\fR is able ta match.  Here is tha four possible combinations:
.IP "\(bu" 4
no modifiers (//): Default behavior. Shiiit, dis aint no joke.  \f(CW\*(Aq.\*(Aq\fR matches any character
except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only all up in tha beginnin of tha strang and
\&\f(CW\*(C`$\*(C'\fR matches only all up in tha end or before a newline all up in tha end.
.IP "\(bu" 4
s modifier (//s): Treat strang as a single long line.  \f(CW\*(Aq.\*(Aq\fR matches
any character, even \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR matches only all up in tha beginnin of
the strang n' \f(CW\*(C`$\*(C'\fR matches only all up in tha end or before a newline at the
end.
.IP "\(bu" 4
m modifier (//m): Treat strang as a set of multiple lines.  \f(CW\*(Aq.\*(Aq\fR
matches any characta except \f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR is able ta match
at tha start or end of \fIany\fR line within tha string.
.IP "\(bu" 4
both s n' m modifiers (//sm): Treat strang as a single long line yo, but
detect multiple lines.  \f(CW\*(Aq.\*(Aq\fR matches any character, even
\&\f(CW"\en"\fR.  \f(CW\*(C`^\*(C'\fR n' \f(CW\*(C`$\*(C'\fR, however, is able ta match all up in tha start or end
of \fIany\fR line within tha string.
.PP
Here is examplez of \f(CW\*(C`//s\*(C'\fR n' \f(CW\*(C`//m\*(C'\fR up in action:
.PP
.Vb 1
\&    $x = "There once was a girl\enDum diddy-dum, here I come biaaatch! Who tha fuck programmed up in Perl\en";
\&
\&    $x =~ /^Who/;   # don\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/s;  # don\*(Aqt match, "Who" not at start of string
\&    $x =~ /^Who/m;  # matches, "Who" at start of second line
\&    $x =~ /^Who/sm; # matches, "Who" at start of second line
\&
\&    $x =~ /girl.Who/;   # don\*(Aqt match, "." don\*(Aqt match "\en"
\&    $x =~ /girl.Who/s;  # matches, "." matches "\en"
\&    $x =~ /girl.Who/m;  # don\*(Aqt match, "." don\*(Aqt match "\en"
\&    $x =~ /girl.Who/sm; # matches, "." matches "\en"
.Ve
.PP
Most of tha time, tha default behavior is what tha fuck is wanted yo, but \f(CW\*(C`//s\*(C'\fR and
\&\f(CW\*(C`//m\*(C'\fR is occasionally straight-up useful naaahhmean, biatch?  If \f(CW\*(C`//m\*(C'\fR is bein used, tha start
of tha strang can still be matched wit \f(CW\*(C`\eA\*(C'\fR n' tha end of tha string
can still be matched wit tha anchors \f(CW\*(C`\eZ\*(C'\fR (matches both tha end and
the newline before, like \f(CW\*(C`$\*(C'\fR), n' \f(CW\*(C`\ez\*(C'\fR (matches only tha end):
.PP
.Vb 2
\&    $x =~ /^Who/m;   # matches, "Who" at start of second line
\&    $x =~ /\eAWho/m;  # don\*(Aqt match, "Who" aint at start of string
\&
\&    $x =~ /girl$/m;  # matches, "girl" at end of first line
\&    $x =~ /girl\eZ/m; # don\*(Aqt match, "girl" aint at end of string
\&
\&    $x =~ /Perl\eZ/m; # matches, "Perl" be at newline before end
\&    $x =~ /Perl\ez/m; # don\*(Aqt match, "Perl" aint at end of string
.Ve
.PP
We now know how tha fuck ta create chizzlez among classez of charactas up in a
regexp.  What bout chizzlez among lyrics or characta strings, biatch? Such
choices is busted lyrics bout up in tha next section.
.SS "Matchin dis or that"
.IX Subsection "Matchin dis or that"
Sometimes we wanna our regexp ta be able ta match different
possible lyrics or characta strings.  This be accomplished by using
the \fIalternation\fR metacharacta \f(CW\*(C`|\*(C'\fR.  To match \f(CW\*(C`dog\*(C'\fR or \f(CW\*(C`cat\*(C'\fR, we
form tha regexp \f(CW\*(C`dog|cat\*(C'\fR.  As before, Perl will try ta match the
regexp all up in tha earliest possible point up in tha string.  At each
characta position, Perl will first try ta match tha first
alternative, \f(CW\*(C`dog\*(C'\fR.  If \f(CW\*(C`dog\*(C'\fR don't match, Perl will then try the
next alternative, \f(CW\*(C`cat\*(C'\fR.  If \f(CW\*(C`cat\*(C'\fR don't match either, then the
match fails n' Perl moves ta tha next posizzle up in tha string.  Some
examples:
.PP
.Vb 2
\&    "cats n' dawgs" =~ /cat|dog|bird/;  # matches "cat"
\&    "cats n' dawgs" =~ /dog|cat|bird/;  # matches "cat"
.Ve
.PP
Even though \f(CW\*(C`dog\*(C'\fR is tha straight-up original gangsta alternatizzle up in tha second regexp,
\&\f(CW\*(C`cat\*(C'\fR be able ta match earlier up in tha string.
.PP
.Vb 2
\&    "cats"          =~ /c|ca|cat|cats/; # matches "c"
\&    "cats"          =~ /cats|cat|ca|c/; # matches "cats"
.Ve
.PP
Here, all tha alternatives match all up in tha straight-up original gangsta strang position, so the
first alternatizzle is tha one dat matches.  If a shitload of the
alternatives is truncationz of tha others, put tha longest ones first
to give dem a cold-ass lil chizzle ta match.
.PP
.Vb 2
\&    "cab" =~ /a|b|c/ # matches "c"
\&                     # /a|b|c/ == /[abc]/
.Ve
.PP
Da last example points up dat characta classes is like
alternationz of characters.  At a given characta position, tha first
alternatizzle dat allows tha regexp match ta succeed is ghon be tha one
that matches.
.SS "Groupin thangs n' hierarchical matching"
.IX Subsection "Groupin thangs n' hierarchical matching"
Alternation allows a regexp ta chizzle among alternatives yo, but by
itself it is unsatisfying.  Da reason is dat each alternatizzle be a whole
regexp yo, but sometime we want alternatives fo' just part of a
regexp.  For instance, suppose we wanna search fo' housecats or
housekeepers.  Da regexp \f(CW\*(C`housecat|housekeeper\*(C'\fR fits tha bill yo, but is
inefficient cuz our crazy asses had ta type \f(CW\*(C`house\*(C'\fR twice.  It would be sick to
have partz of tha regexp be constant, like \f(CW\*(C`house\*(C'\fR, n' some
parts have alternatives, like \f(CW\*(C`cat|keeper\*(C'\fR.
.PP
Da \fIgrouping\fR metacharactas \f(CW\*(C`()\*(C'\fR solve dis problem.  Grouping
allows partz of a regexp ta be treated as a single unit.  Partz of a
regexp is grouped by enclosin dem up in parentheses.  Thus we could solve
the \f(CW\*(C`housecat|housekeeper\*(C'\fR by formin tha regexp as
\&\f(CW\*(C`house(cat|keeper)\*(C'\fR.  Da regexp \f(CW\*(C`house(cat|keeper)\*(C'\fR means match
\&\f(CW\*(C`house\*(C'\fR followed by either \f(CW\*(C`cat\*(C'\fR or \f(CW\*(C`keeper\*(C'\fR.  Some mo' examples
are
.PP
.Vb 4
\&    /(a|b)b/;    # matches \*(Aqab\*(Aq or \*(Aqbb\*(Aq
\&    /(ac|b)b/;   # matches \*(Aqacb\*(Aq or \*(Aqbb\*(Aq
\&    /(^a|b)c/;   # matches \*(Aqac\*(Aq at start of strang or \*(Aqbc\*(Aq anywhere
\&    /(a|[bc])d/; # matches \*(Aqad\*(Aq, \*(Aqbd\*(Aq, or \*(Aqcd\*(Aq
\&
\&    /house(cat|)/;  # matches either \*(Aqhousecat\*(Aq or \*(Aqhouse\*(Aq
\&    /house(cat(s|)|)/;  # matches either \*(Aqhousecats\*(Aq or \*(Aqhousecat\*(Aq or
\&                        # \*(Aqhouse\*(Aq.  Note crews can be nested.
\&
\&    /(19|20|)\ed\ed/;  # match muthafuckin years 19xx, 20xx, or tha Y2K problem, xx
\&    "20" =~ /(19|20|)\ed\ed/;  # matches tha null alternatizzle \*(Aq()\ed\ed\*(Aq,
\&                             # cuz \*(Aq20\ed\ed\*(Aq can\*(Aqt match
.Ve
.PP
Alternations behave tha same way up in crews as outta them: at a given
strin position, tha leftmost alternatizzle dat allows tha regexp to
match is taken. I aint talkin' bout chicken n' gravy biatch.  So up in tha last example all up in tha straight-up original gangsta strang position,
\&\f(CW"20"\fR matches tha second alternatizzle yo, but there is not a god damn thang left over
to match tha next two digits \f(CW\*(C`\ed\ed\*(C'\fR.  So Perl moves on ta tha next
alternative, which is tha null alternatizzle n' dat works, since
\&\f(CW"20"\fR is two digits.
.PP
Da process of tryin one alternative, seein if it matches, and
movin on ta tha next alternative, while goin back up in tha string
from where tha previous alternatizzle was tried, if it don't, is called
\&\fIbacktracking\fR.  Da term 'backtracking' be reppin tha scam that
matchin a regexp is like a strutt up in tha woods.  Successfully matching
a regexp is like arrivin at a thugged-out destination. I aint talkin' bout chicken n' gravy biatch.  There is nuff possible
trailheads, one fo' each strang position, n' each one is tried in
order, left ta right.  From each trailhead there may be nuff paths,
some of which git you there, n' some which is dead ends.  When you
walk along a trail n' hit a thugged-out dead end, you gotta backtrack along the
trail ta a earlier point ta try another trail.  If you hit your
destination, you stop immediately n' forget bout tryin all the
other trails.  Yo ass is persistent, n' only if you have tried all the
trails from all tha trailheadz n' not arrived at yo' destination, do
you declare failure.  To be concrete, here be a step-by-step analysis
of what tha fuck Perl do when it tries ta match tha regexp
.PP
.Vb 1
\&    "abcde" =~ /(abd|abc)(df|d|de)/;
.Ve
.IP "0" 4
Start wit tha straight-up original gangsta letta up in tha strang 'a'.
.IP "1" 4
.IX Item "1"
Try tha straight-up original gangsta alternatizzle up in tha straight-up original gangsta crew 'abd'.
.IP "2" 4
.IX Item "2"
Match 'a' followed by 'b'. Right back up in yo muthafuckin ass. So far so good.
.IP "3" 4
.IX Item "3"
\&'d' up in tha regexp don't match 'c' up in tha strang \- a thugged-out dead
end yo, but it ain't no stoppin cause I be still poppin'.  So backtrack two charactas n' pick tha second alternatizzle in
the first crew 'abc'.
.IP "4" 4
.IX Item "4"
Match 'a' followed by 'b' followed by 'c'.  We is on a roll
and have satisfied tha straight-up original gangsta group. Right back up in yo muthafuckin ass. Set \f(CW$1\fR ta 'abc'.
.IP "5" 4
.IX Item "5"
Move on ta tha second crew n' pick tha straight-up original gangsta alternative
\&'df'.
.IP "6" 4
.IX Item "6"
Match tha 'd'.
.IP "7" 4
.IX Item "7"
\&'f' up in tha regexp don't match 'e' up in tha string, so a thugged-out dead
end yo, but it ain't no stoppin cause I be still poppin'.  Backtrack one characta n' pick tha second alternatizzle up in the
second crew 'd'.
.IP "8" 4
.IX Item "8"
\&'d' matches. Da second groupin is satisfied, so set \f(CW$2\fR to
\&'d'.
.IP "9" 4
.IX Item "9"
We is all up in tha end of tha regexp, so we is done biaaatch! Our thugged-out asses have
matched 'abcd' outta tha strang \*(L"abcde\*(R".
.PP
There is a cold-ass lil couple thangs ta note bout dis analysis.  First, the
third alternatizzle up in tha second crew 'de' also allows a match yo, but we
stopped before we gots ta it \- at a given characta position, leftmost
wins.  Second, we was able ta git a match all up in tha straight-up original gangsta character
posizzle of tha strang 'a'.  If there was no matches all up in tha first
position, Perl would move ta tha second characta posizzle 'b' and
attempt tha match all over again. I aint talkin' bout chicken n' gravy biatch.  Only when all possible paths at all
possible characta positions done been exhausted do Perl give
up n' declare \f(CW\*(C`$string\ =~\ /(abd|abc)(df|d|de)/;\*(C'\fR ta be false.
.PP
Even wit all dis work, regexp matchin happens remarkably fast.  To
speed thangs up, Perl compilez tha regexp tha fuck into a cold-ass lil compact sequence of
opcodes dat can often fit inside a processor cache.  When tha code is
executed, these opcodes can then run at full throttle n' search hella
quickly.
.SS "Extractin matches"
.IX Subsection "Extractin matches"
Da groupin metacharactas \f(CW\*(C`()\*(C'\fR also serve another straight-up
different function: they allow tha extraction of tha partz of a string
that matched. Y'all KNOW dat shit, muthafucka!  This is straight-up useful ta smoke up what tha fuck matched n' for
text processin up in general. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  For each grouping, tha part dat matched
inside goes tha fuck into tha special variablez \f(CW$1\fR, \f(CW$2\fR, etc.  They can be
used just as ordinary variables:
.PP
.Vb 6
\&    # extract hours, minutes, seconds
\&    if ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/) {    # match hh:mm:ss format
\&        $hours = $1;
\&        $minutes = $2;
\&        $secondz = $3;
\&    }
.Ve
.PP
Now, we know dat up in scalar context,
\&\f(CW\*(C`$time\ =~\ /(\ed\ed):(\ed\ed):(\ed\ed)/\*(C'\fR returns a legit or false
value.  In list context, however, it returns tha list of matched joints
\&\f(CW\*(C`($1,$2,$3)\*(C'\fR.  So we could write tha code mo' compactly as
.PP
.Vb 2
\&    # extract hours, minutes, seconds
\&    ($hours, $minutes, $second) = ($time =~ /(\ed\ed):(\ed\ed):(\ed\ed)/);
.Ve
.PP
If tha groupings up in a regexp is nested, \f(CW$1\fR gets tha crew wit the
leftmost openin parenthesis, \f(CW$2\fR tha next openin parenthesis,
etc.  Here be a regexp wit nested groups:
.PP
.Vb 2
\&    /(ab(cd|ef)((gi)|j))/;
\&     1  2      34
.Ve
.PP
If dis regexp matches, \f(CW$1\fR gotz nuff a strang startin with
\&\f(CW\*(Aqab\*(Aq\fR, \f(CW$2\fR is either set ta \f(CW\*(Aqcd\*(Aq\fR or \f(CW\*(Aqef\*(Aq\fR, \f(CW$3\fR equals either
\&\f(CW\*(Aqgi\*(Aq\fR or \f(CW\*(Aqj\*(Aq\fR, n' \f(CW$4\fR is either set ta \f(CW\*(Aqgi\*(Aq\fR, just like \f(CW$3\fR,
or it remains undefined.
.PP
For convenience, Perl sets \f(CW$+\fR ta tha strang held by tha highest numbered
\&\f(CW$1\fR, \f(CW$2\fR,... dat gots assigned (and, somewhat related, \f(CW$^N\fR ta the
value of tha \f(CW$1\fR, \f(CW$2\fR,... most-recently assigned; i.e. tha \f(CW$1\fR,
\&\f(CW$2\fR,... associated wit tha rightmost closin parenthesis used up in the
match).
.SS "Backreferences"
.IX Subsection "Backreferences"
Closely associated wit tha matchin variablez \f(CW$1\fR, \f(CW$2\fR, ... are
the \fIbackreferences\fR \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,...  Backreferences is simply
matchin variablez dat can be used \fIinside\fR a regexp.  This be a
really sick feature; what tha fuck matches lata up in a regexp is made ta depend on
what matched earlier up in tha regexp.  Suppose we wanted ta look
for doubled lyrics up in a text, like 'the the'.  Da followin regexp finds
all 3\-letta doublez wit a space up in between:
.PP
.Vb 1
\&    /\eb(\ew\ew\ew)\es\eg1\eb/;
.Ve
.PP
Da groupin assigns a value ta \eg1, so dat tha same 3\-letta sequence
is used fo' both parts.
.PP
A similar task is ta find lyrics consistin of two identical parts:
.PP
.Vb 7
\&    % simple_grep \*(Aq^(\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew)\eg1$\*(Aq /usr/dict/words
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
Da regexp has a single groupin which considaz 4\-letter
combinations, then 3\-letta combinations, etc., n' uses \f(CW\*(C`\eg1\*(C'\fR ta look for
a repeat.  Although \f(CW$1\fR n' \f(CW\*(C`\eg1\*(C'\fR represent tha same thang, care should be
taken ta use matched variablez \f(CW$1\fR, \f(CW$2\fR,... only \fIoutside\fR a regexp
and backreferences \f(CW\*(C`\eg1\*(C'\fR, \f(CW\*(C`\eg2\*(C'\fR,... only \fIinside\fR a regexp; not bustin
so may lead ta surprisin n' unsatisfactory thangs up in dis biatch.
.SS "Relatizzle backreferences"
.IX Subsection "Relatizzle backreferences"
Countin tha openin parentheses ta git tha erect number fo' a
backreference is error-prone as soon as there is mo' than one
capturin group.  A mo' convenient technique became available
with Perl 5.10: relatizzle backreferences. To refer ta tha immediately
precedin capture crew one now may write \f(CW\*(C`\eg{\-1}\*(C'\fR, tha next but
last be available via \f(CW\*(C`\eg{\-2}\*(C'\fR, n' so on.
.PP
Another phat reason up in addizzle ta readabilitizzle n' maintainability
for rockin relatizzle backreferences is illustrated by tha followin example,
where a simple pattern fo' matchin peculiar strings is used:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg2\eg1\*(Aq;   # matches a11a, g22g, x33x, etc.
.Ve
.PP
Now dat our crazy asses have dis pattern stored as a handy string, we might feel
tempted ta use it as a part of some other pattern:
.PP
.Vb 6
\&    $line = "code=e99e";
\&    if ($line =~ /^(\ew+)=$a99a$/){   # unexpected behavior!
\&        print "$1 is valid\en";
\&    } else {
\&        print "bad line: \*(Aq$line\*(Aq\en";
\&    }
.Ve
.PP
But dis don't match, at least not tha way one might expect. Only
afta insertin tha interpolated \f(CW$a99a\fR n' lookin all up in tha resulting
full text of tha regexp is it obvious dat tha backreferences have
backfired. Y'all KNOW dat shit, muthafucka! Da subexpression \f(CW\*(C`(\ew+)\*(C'\fR has snatched number 1 and
demoted tha crews up in \f(CW$a99a\fR by one rank. This can be avoided by
usin relatizzle backreferences:
.PP
.Vb 1
\&    $a99a = \*(Aq([a\-z])(\ed)\eg{\-1}\eg{\-2}\*(Aq;  # safe fo' bein interpolated
.Ve
.SS "Named backreferences"
.IX Subsection "Named backreferences"
Perl 5.10 also introduced named capture crews n' named backreferences.
To attach a name ta a cold-ass lil capturin group, you write either
\&\f(CW\*(C`(?<name>...)\*(C'\fR or \f(CW\*(C`(?\*(Aqname\*(Aq...)\*(C'\fR.  Da backreference may
then be freestyled as \f(CW\*(C`\eg{name}\*(C'\fR.  It be permissible ta attach the
same name ta mo' than one crew yo, but then only tha leftmost one of the
eponymous set can be referenced. Y'all KNOW dat shit, muthafucka!  Outside of tha pattern a named
capture crew be accessible all up in tha \f(CW\*(C`%+\*(C'\fR hash.
.PP
Assumin dat we gotta match calendar dates which may be given up in one
of tha three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write
three suitable patterns where we use 'd', 'm' n' 'y' respectively as the
namez of tha crews capturin tha pertainin componentz of a thugged-out date. The
matchin operation combines tha three patterns as alternatives:
.PP
.Vb 8
\&    $fmt1 = \*(Aq(?<y>\ed\ed\ed\ed)\-(?<m>\ed\ed)\-(?<d>\ed\ed)\*(Aq;
\&    $fmt2 = \*(Aq(?<m>\ed\ed)/(?<d>\ed\ed)/(?<y>\ed\ed\ed\ed)\*(Aq;
\&    $fmt3 = \*(Aq(?<d>\ed\ed)\e.(?<m>\ed\ed)\e.(?<y>\ed\ed\ed\ed)\*(Aq;
\&    fo' mah $d qw( 2006\-10\-21 15.01.2007 10/31/2005 ){
\&        if ( $d =~ m{$fmt1|$fmt2|$fmt3} ){
\&            print "day=$+{d} month=$+{m} year=$+{y}\en";
\&        }
\&    }
.Ve
.PP
If any of tha alternatives matches, tha hash \f(CW\*(C`%+\*(C'\fR is bound ta contain the
three key-value pairs.
.SS "Alternatizzle capture crew numbering"
.IX Subsection "Alternatizzle capture crew numbering"
Yet another capturin crew numberin technique (also as from Perl 5.10)
deals wit tha problem of referrin ta crews within a set of alternatives.
Consider a pattern fo' matchin a time of tha day, civil or military style:
.PP
.Vb 3
\&    if ( $time =~ /(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed)/ ){
\&        # process minute n' minute
\&    }
.Ve
.PP
Processin tha thangs up in dis biatch requires a additionizzle if statement ta determine
whether \f(CW$1\fR n' \f(CW$2\fR or \f(CW$3\fR n' \f(CW$4\fR contain tha goodies. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it would
be easier if we could use crew numbers 1 n' 2 up in second alternatizzle as
well, n' dis is exactly what tha fuck tha parenthesized construct \f(CW\*(C`(?|...)\*(C'\fR,
set round a alternatizzle achieves yo. Here be a extended version of the
previous pattern:
.PP
.Vb 3
\&    if ( $time =~ /(?|(\ed\ed|\ed):(\ed\ed)|(\ed\ed)(\ed\ed))\es+([A\-Z][A\-Z][A\-Z])/ ){
\&        print "hour=$1 minute=$2 unit=$3\en";
\&    }
.Ve
.PP
Within tha alternatizzle numberin group, crew numbers start all up in tha same
posizzle fo' each alternatizzle fo' realz. Afta tha group, numberin continues
with one higher than tha maximum reached across all tha alternatives.
.SS "Posizzle shiznit"
.IX Subsection "Posizzle shiznit"
In addizzle ta what tha fuck was matched, Perl also serves up the
positionz of what tha fuck was matched as contentz of tha \f(CW\*(C`@\-\*(C'\fR n' \f(CW\*(C`@+\*(C'\fR
arrays. \f(CW\*(C`$\-[0]\*(C'\fR is tha posizzle of tha start of tha entire match and
\&\f(CW$+[0]\fR is tha posizzle of tha end yo, but it ain't no stoppin cause I be still poppin'. Right back up in yo muthafuckin ass. Similarly, \f(CW\*(C`$\-[n]\*(C'\fR is the
posizzle of tha start of tha \f(CW$n\fR match n' \f(CW$+[n]\fR is tha position
of tha end yo, but it ain't no stoppin cause I be still poppin'. If \f(CW$n\fR is undefined, so is \f(CW\*(C`$\-[n]\*(C'\fR n' \f(CW$+[n]\fR. Then
this code
.PP
.Vb 5
\&    $x = "Mmm...donut, thought Homer";
\&    $x =~ /^(Mmm|Yech)\e.\e.\e.(donut|peas)/; # matches
\&    foreach $expr (1..$#\-) {
\&        print "Match $expr: \*(Aq${$expr}\*(Aq at posizzle ($\-[$expr],$+[$expr])\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 2
\&    Match 1: \*(AqMmm\*(Aq at posizzle (0,3)
\&    Match 2: \*(Aqdonut\*(Aq at posizzle (6,11)
.Ve
.PP
Even if there be no groupings up in a regexp, it is still possible to
smoke up what tha fuck exactly matched up in a string.  If you use them, Perl
will set \f(CW\*(C`$\`\*(C'\fR ta tha part of tha strang before tha match, will set \f(CW$&\fR
to tha part of tha strang dat matched, n' will set \f(CW\*(C`$\*(Aq\*(C'\fR ta tha part
of tha strang afta tha match.  An example:
.PP
.Vb 3
\&    $x = "the pussaaaaay caught tha mouse";
\&    $x =~ /cat/;  # $\` = \*(Aqthe \*(Aq, $& = \*(Aqcat\*(Aq, $\*(Aq = \*(Aq caught tha mouse\*(Aq
\&    $x =~ /the/;  # $\` = \*(Aq\*(Aq, $& = \*(Aqthe\*(Aq, $\*(Aq = \*(Aq pussaaaaay caught tha mouse\*(Aq
.Ve
.PP
In tha second match, \f(CW\*(C`$\`\*(C'\fR equals \f(CW\*(Aq\*(Aq\fR cuz tha regexp matched at the
first characta posizzle up in tha strang n' stopped; it never saw the
second 'the'.  It be blingin ta note dat rockin \f(CW\*(C`$\`\*(C'\fR n' \f(CW\*(C`$\*(Aq\*(C'\fR
slows down regexp matchin like a funky-ass bit, while \f(CW$&\fR slows it down ta a
lesser extent, cuz if they is used up in one regexp up in a program,
they is generated fo' \fIall\fR regexps up in tha program.  So if raw
performizzle be a goal of yo' application, they should be avoided.
If you need ta extract tha correspondin substrings, use \f(CW\*(C`@\-\*(C'\fR and
\&\f(CW\*(C`@+\*(C'\fR instead:
.PP
.Vb 3
\&    $\` is tha same ol' dirty as substr( $x, 0, $\-[0] )
\&    $& is tha same ol' dirty as substr( $x, $\-[0], $+[0]\-$\-[0] )
\&    $\*(Aq is tha same ol' dirty as substr( $x, $+[0] )
.Ve
.PP
Az of Perl 5.10, tha \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR n' \f(CW\*(C`${^POSTMATCH}\*(C'\fR
variablez may be used. Y'all KNOW dat shit, muthafucka! These is only set if tha \f(CW\*(C`/p\*(C'\fR modifier is present.
Consequently they do not penalize tha rest of tha program.
.SS "Non-capturin groupings"
.IX Subsection "Non-capturin groupings"
A crew dat is required ta bundle a set of alternatives may or may not be
useful as a cold-ass lil capturin group.  If it aint, it just creates a superfluous
addizzle ta tha set of available capture crew joints, inside as well as
outside tha regexp.  Non-capturin groupings, denoted by \f(CW\*(C`(?:regexp)\*(C'\fR,
still allow tha regexp ta be treated as a single unit yo, but don't establish
a capturin crew all up in tha same time.  Both capturin n' non-capturing
groupings is allowed ta co-exist up in tha same regexp.  Because there is
no extraction, non-capturin groupings is fasta than capturing
groupings.  Non-capturin groupings is also handy fo' choosin exactly
which partz of a regexp is ta be extracted ta matchin variables:
.PP
.Vb 2
\&    # match a number, $1\-$4 is set yo, but we only want $1
\&    /([+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?)/;
\&
\&    # match a number fasta , only $1 is set
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE][+\-]?\ed+)?)/;
\&
\&    # match a number, git $1 = whole number, $2 = exponent
\&    /([+\-]?\e *(?:\ed+(?:\e.\ed*)?|\e.\ed+)(?:[eE]([+\-]?\ed+))?)/;
.Ve
.PP
Non-capturin groupings is also useful fo' removin nuisance
elements gathered from a split operation where parentheses are
required fo' some reason:
.PP
.Vb 3
\&    $x = \*(Aq12aba34ba5\*(Aq;
\&    @num = split /(a|b)+/, $x;    # @num = (\*(Aq12\*(Aq,\*(Aqa\*(Aq,\*(Aq34\*(Aq,\*(Aqa\*(Aq,\*(Aq5\*(Aq)
\&    @num = split /(?:a|b)+/, $x;  # @num = (\*(Aq12\*(Aq,\*(Aq34\*(Aq,\*(Aq5\*(Aq)
.Ve
.SS "Matchin repetitions"
.IX Subsection "Matchin repetitions"
Da examplez up in tha previous section display a buggin weakness.  We
were only matchin 3\-letta lyrics, or chunkz of lyrics of 4 lettas or
less.  We'd like ta be able ta match lyrics or, mo' generally, strings
of any length, without freestylin up tedious alternatives like
\&\f(CW\*(C`\ew\ew\ew\ew|\ew\ew\ew|\ew\ew|\ew\*(C'\fR.
.PP
This is exactly tha problem tha \fIquantifier\fR metacharactas \f(CW\*(C`?\*(C'\fR,
\&\f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR, n' \f(CW\*(C`{}\*(C'\fR was pimped for. Shiiit, dis aint no joke.  They allow our asses ta delimit the
number of repeats fo' a portion of a regexp we consider ta be a
match.  Quantifiers is put immediately afta tha character, character
class, or groupin dat we wanna specify.  They have tha following
meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a?\*(C'\fR means: match 'a' 1 or 0 times
.IP "\(bu" 4
\&\f(CW\*(C`a*\*(C'\fR means: match 'a' 0 or mo' times, i.e., any number of times
.IP "\(bu" 4
\&\f(CW\*(C`a+\*(C'\fR means: match 'a' 1 or mo' times, i.e., at least once
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times yo, but not mo' than \f(CW\*(C`m\*(C'\fR
times.
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR or mo' times
.IP "\(bu" 4
\&\f(CW\*(C`a{n}\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times
.PP
Here is some examples:
.PP
.Vb 10
\&    /[a\-z]+\es+\ed*/;  # match a lowercase word, at least one space, and
\&                     # any number of digits
\&    /(\ew+)\es+\eg1/;    # match doubled lyrics of arbitrary length
\&    /y(es)?/i;       # matches \*(Aqy\*(Aq, \*(AqY\*(Aq, or a cold-ass lil case\-insensitizzle \*(Aqyes\*(Aq
\&    $year =~ /^\ed{2,4}$/;  # make shizzle year be at least 2 but not more
\&                           # than 4 digits
\&    $year =~ /^\ed{4}$|^\ed{2}$/;    # betta match; throw up 3\-digit dates
\&    $year =~ /^\ed{2}(\ed{2})?$/;  # same thang freestyled differently yo. However,
\&                                 # dis captures tha last two digits up in $1
\&                                 # n' tha other do not.
\&
\&    % simple_grep \*(Aq^(\ew+)\eg1$\*(Aq /usr/dict/wordz   # isn\*(Aqt dis easier?
\&    beriberi
\&    booboo
\&    coco
\&    mama
\&    murmur
\&    papa
.Ve
.PP
For all of these quantifiers, Perl will try ta match as much of the
strin as possible, while still allowin tha regexp ta succeed. Y'all KNOW dat shit, muthafucka!  Thus
with \f(CW\*(C`/a?.../\*(C'\fR, Perl will first try ta match tha regexp wit tha \f(CW\*(C`a\*(C'\fR
present; if dat fails, Perl will try ta match tha regexp without the
\&\f(CW\*(C`a\*(C'\fR present.  For tha quantifier \f(CW\*(C`*\*(C'\fR, we git tha following:
.PP
.Vb 5
\&    $x = "the pussaaaaay up in tha hat";
\&    $x =~ /^(.*)(cat)(.*)$/; # matches,
\&                             # $1 = \*(Aqthe \*(Aq
\&                             # $2 = \*(Aqcat\*(Aq
\&                             # $3 = \*(Aq up in tha hat\*(Aq
.Ve
.PP
Which is what tha fuck we might expect, tha match findz tha only \f(CW\*(C`cat\*(C'\fR up in the
strin n' locks onto dat shit.  Consider, however, dis regexp:
.PP
.Vb 4
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe pussaaaaay up in tha h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 charactas match)
.Ve
.PP
One might initially guess dat Perl would find tha \f(CW\*(C`at\*(C'\fR up in \f(CW\*(C`cat\*(C'\fR and
stop there yo, but dat wouldn't give tha longest possible strang ta the
first quantifier \f(CW\*(C`.*\*(C'\fR.  Instead, tha straight-up original gangsta quantifier \f(CW\*(C`.*\*(C'\fR grabs as
much of tha strang as possible while still havin tha regexp match.  In
this example, dat means havin tha \f(CW\*(C`at\*(C'\fR sequence wit tha final \f(CW\*(C`at\*(C'\fR
in tha string.  Da other blingin principle illustrated here is that,
when there be two or mo' elements up in a regexp, tha \fIleftmost\fR
quantifier, if there is one, gets ta grab as much of tha strang as
possible, leavin tha rest of tha regexp ta fight over scraps.  Thus in
our example, tha straight-up original gangsta quantifier \f(CW\*(C`.*\*(C'\fR grabs most of tha string, while
the second quantifier \f(CW\*(C`.*\*(C'\fR gets tha empty string.   Quantifiers that
grab as much of tha strang as possible is called \fImaximal match\fR or
\&\fIgreedy\fR quantifiers.
.PP
When a regexp can match a strang up in nuff muthafuckin different ways, we can use
the principlez above ta predict which way tha regexp will match:
.IP "\(bu" 4
Principle 0: Taken as a whole, any regexp is ghon be matched at the
earliest possible posizzle up in tha string.
.IP "\(bu" 4
Principle 1: In a alternation \f(CW\*(C`a|b|c...\*(C'\fR, tha leftmost alternative
that allows a match fo' tha whole regexp is ghon be tha one used.
.IP "\(bu" 4
Principle 2: Da maximal matchin quantifiers \f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and
\&\f(CW\*(C`{n,m}\*(C'\fR will up in general match as much of tha strang as possible while
still allowin tha whole regexp ta match.
.IP "\(bu" 4
Principle 3: If there be two or mo' elements up in a regexp, the
leftmost greedy quantifier, if any, will match as much of tha string
as possible while still allowin tha whole regexp ta match.  Da next
leftmost greedy quantifier, if any, will try ta match as much of the
strin remainin available ta it as possible, while still allowin the
whole regexp ta match.  And so on, until all tha regexp elements are
satisfied.
.PP
As our crazy asses have peeped above, Principle 0 overrides tha others. Da regexp
will be matched as early as possible, wit tha other principles
determinin how tha fuck tha regexp matches at dat earliest character
position.
.PP
Here be a example of these principlez up in action:
.PP
.Vb 5
\&    $x = "Da programmin rehood of Perl";
\&    $x =~ /^(.+)(e|r)(.*)$/;  # matches,
\&                              # $1 = \*(AqDa programmin rehood of Pe\*(Aq
\&                              # $2 = \*(Aqr\*(Aq
\&                              # $3 = \*(Aql\*(Aq
.Ve
.PP
This regexp matches all up in tha earliest strang position, \f(CW\*(AqT\*(Aq\fR.  One
might be thinkin dat \f(CW\*(C`e\*(C'\fR, bein leftmost up in tha alternation, would be
matched yo, but \f(CW\*(C`r\*(C'\fR produces tha longest strang up in tha straight-up original gangsta quantifier.
.PP
.Vb 3
\&    $x =~ /(m{1,2})(.*)$/;  # matches,
\&                            # $1 = \*(Aqmm\*(Aq
\&                            # $2 = \*(Aqin rehood of Perl\*(Aq
.Ve
.PP
Here, Da earliest possible match be all up in tha straight-up original gangsta \f(CW\*(Aqm\*(Aq\fR in
\&\f(CW\*(C`programming\*(C'\fR. \f(CW\*(C`m{1,2}\*(C'\fR is tha straight-up original gangsta quantifier, so it gets ta match
a maximal \f(CW\*(C`mm\*(C'\fR.
.PP
.Vb 3
\&    $x =~ /.*(m{1,2})(.*)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqin rehood of Perl\*(Aq
.Ve
.PP
Here, tha regexp matches all up in tha start of tha string. Da first
quantifier \f(CW\*(C`.*\*(C'\fR grabs as much as possible, leavin just a single
\&\f(CW\*(Aqm\*(Aq\fR fo' tha second quantifier \f(CW\*(C`m{1,2}\*(C'\fR.
.PP
.Vb 4
\&    $x =~ /(.?)(m{1,2})(.*)$/;  # matches,
\&                                # $1 = \*(Aqa\*(Aq
\&                                # $2 = \*(Aqmm\*(Aq
\&                                # $3 = \*(Aqin rehood of Perl\*(Aq
.Ve
.PP
Here, \f(CW\*(C`.?\*(C'\fR smokes its maximal one characta all up in tha earliest possible
posizzle up in tha string, \f(CW\*(Aqa\*(Aq\fR up in \f(CW\*(C`programming\*(C'\fR, leavin \f(CW\*(C`m{1,2}\*(C'\fR
the opportunitizzle ta match both \f(CW\*(C`m\*(C'\fR's. Finally,
.PP
.Vb 1
\&    "aXXXb" =~ /(X*)/; # matches wit $1 = \*(Aq\*(Aq
.Ve
.PP
because it can match zero copiez of \f(CW\*(AqX\*(Aq\fR all up in tha beginnin of the
string.  If you definitely wanna match at least one \f(CW\*(AqX\*(Aq\fR, use
\&\f(CW\*(C`X+\*(C'\fR, not \f(CW\*(C`X*\*(C'\fR.
.PP
Sometimes greed aint good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  At times, we wanna quantifiers to
match a \fIminimal\fR piece of string, rather than a maximal piece.  For
this purpose, Larry Wall pimped tha \fIminimal match\fR or
\&\fInon-greedy\fR quantifiers \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, n' \f(CW\*(C`{}?\*(C'\fR.  These are
the usual quantifiers wit a \f(CW\*(C`?\*(C'\fR appended ta em.  They have the
followin meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a??\*(C'\fR means: match 'a' 0 or 1 times. Try 0 first, then 1.
.IP "\(bu" 4
\&\f(CW\*(C`a*?\*(C'\fR means: match 'a' 0 or mo' times, i.e., any number of times,
but as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a+?\*(C'\fR means: match 'a' 1 or mo' times, i.e., at least once yo, but
as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not mo' than \f(CW\*(C`m\*(C'\fR
times, as few times as possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}?\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times yo, but as few times as
possible
.IP "\(bu" 4
\&\f(CW\*(C`a{n}?\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  Because we match exactly
\&\f(CW\*(C`n\*(C'\fR times, \f(CW\*(C`a{n}?\*(C'\fR is equivalent ta \f(CW\*(C`a{n}\*(C'\fR n' is just there for
notationizzle consistency.
.PP
Letz peep tha example above yo, but wit minimal quantifiers:
.PP
.Vb 5
\&    $x = "Da programmin rehood of Perl";
\&    $x =~ /^(.+?)(e|r)(.*)$/; # matches,
\&                              # $1 = \*(AqTh\*(Aq
\&                              # $2 = \*(Aqe\*(Aq
\&                              # $3 = \*(Aq programmin rehood of Perl\*(Aq
.Ve
.PP
Da minimal strang dat will allow both tha start of tha strang \f(CW\*(C`^\*(C'\fR
and tha alternation ta match is \f(CW\*(C`Th\*(C'\fR, wit tha alternation \f(CW\*(C`e|r\*(C'\fR
matchin \f(CW\*(C`e\*(C'\fR.  Da second quantifier \f(CW\*(C`.*\*(C'\fR is free ta gobble up the
rest of tha string.
.PP
.Vb 3
\&    $x =~ /(m{1,2}?)(.*?)$/;  # matches,
\&                              # $1 = \*(Aqm\*(Aq
\&                              # $2 = \*(Aqmin rehood of Perl\*(Aq
.Ve
.PP
Da first strang posizzle dat dis regexp can match be all up in tha first
\&\f(CW\*(Aqm\*(Aq\fR up in \f(CW\*(C`programming\*(C'\fR fo' realz. At dis position, tha minimal \f(CW\*(C`m{1,2}?\*(C'\fR
matches just one \f(CW\*(Aqm\*(Aq\fR.  Although tha second quantifier \f(CW\*(C`.*?\*(C'\fR would
prefer ta match no characters, it is constrained by tha end-of-string
anchor \f(CW\*(C`$\*(C'\fR ta match tha rest of tha string.
.PP
.Vb 4
\&    $x =~ /(.*?)(m{1,2}?)(.*)$/;  # matches,
\&                                  # $1 = \*(AqDa progra\*(Aq
\&                                  # $2 = \*(Aqm\*(Aq
\&                                  # $3 = \*(Aqmin rehood of Perl\*(Aq
.Ve
.PP
In dis regexp, you might expect tha straight-up original gangsta minimal quantifier \f(CW\*(C`.*?\*(C'\fR
to match tha empty string, cuz it aint constrained by a \f(CW\*(C`^\*(C'\fR
anchor ta match tha beginnin of tha word. Y'all KNOW dat shit, muthafucka!  Principle 0 applies here,
however n' shit.  Because it is possible fo' tha whole regexp ta match at the
start of tha string, it \fIwill\fR match all up in tha start of tha string.  Thus
the first quantifier has ta match every last muthafuckin thang up ta tha straight-up original gangsta \f(CW\*(C`m\*(C'\fR.  The
second minimal quantifier matches just one \f(CW\*(C`m\*(C'\fR n' tha third
quantifier matches tha rest of tha string.
.PP
.Vb 4
\&    $x =~ /(.??)(m{1,2})(.*)$/;  # matches,
\&                                 # $1 = \*(Aqa\*(Aq
\&                                 # $2 = \*(Aqmm\*(Aq
\&                                 # $3 = \*(Aqin rehood of Perl\*(Aq
.Ve
.PP
Just as up in tha previous regexp, tha straight-up original gangsta quantifier \f(CW\*(C`.??\*(C'\fR can match
earliest at posizzle \f(CW\*(Aqa\*(Aq\fR, so it do.  Da second quantifier is
greedy, so it matches \f(CW\*(C`mm\*(C'\fR, n' tha third matches tha rest of the
string.
.PP
We can modify principle 3 above ta take tha fuck into account non-greedy
quantifiers:
.IP "\(bu" 4
Principle 3: If there be two or mo' elements up in a regexp, the
leftmost greedy (non-greedy) quantifier, if any, will match as much
(lil) of tha strang as possible while still allowin tha whole
regexp ta match.  Da next leftmost greedy (non-greedy) quantifier, if
any, will try ta match as much (lil) of tha strang remaining
available ta it as possible, while still allowin tha whole regexp to
match.  And so on, until all tha regexp elements is satisfied.
.PP
Just like alternation, quantifiers is also susceptible to
backtracking.  Here be a step-by-step analysiz of tha example
.PP
.Vb 5
\&    $x = "the pussaaaaay up in tha hat";
\&    $x =~ /^(.*)(at)(.*)$/; # matches,
\&                            # $1 = \*(Aqthe pussaaaaay up in tha h\*(Aq
\&                            # $2 = \*(Aqat\*(Aq
\&                            # $3 = \*(Aq\*(Aq   (0 matches)
.Ve
.IP "0" 4
Start wit tha straight-up original gangsta letta up in tha strang 't'.
.IP "1" 4
.IX Item "1"
Da first quantifier '.*' starts up by matchin tha whole
strin 'the pussaaaaay up in tha hat'.
.IP "2" 4
.IX Item "2"
\&'a' up in tha regexp element 'at' don't match tha end of the
string.  Backtrack one character.
.IP "3" 4
.IX Item "3"
\&'a' up in tha regexp element 'at' still don't match tha last
letta of tha strang 't', so backtrack one mo' character.
.IP "4" 4
.IX Item "4"
Now we can match tha 'a' n' tha 't'.
.IP "5" 4
.IX Item "5"
Move on ta tha third element '.*'.  Since we is all up in tha end of
the strang n' '.*' can match 0 times, assign it tha empty string.
.IP "6" 4
.IX Item "6"
We is done!
.PP
Most of tha time, all dis movin forward n' backtrackin happens
quickly n' searchin is fast. There is some pathological regexps,
however, whose execution time exponentially grows wit tha size of the
string.  A typical structure dat blows up in yo' grill iz of tha form
.PP
.Vb 1
\&    /(a|b+)*/;
.Ve
.PP
Da problem is tha nested indeterminizzle quantifiers.  There is many
different wayz of partitionin a strang of length n between tha \f(CW\*(C`+\*(C'\fR
and \f(CW\*(C`*\*(C'\fR: one repetizzle wit \f(CW\*(C`b+\*(C'\fR of length n, two repetitions with
the first \f(CW\*(C`b+\*(C'\fR length k n' tha second wit length n\-k, m repetitions
whose bits add up ta length n, etc.  In fact there be a exponential
number of ways ta partizzle a strang as a gangbangin' function of its length.  A
regexp may git dirty n' match early up in tha process yo, but if there is
no match, Perl will try \fIevery\fR possibilitizzle before givin up.  So be
careful wit nested \f(CW\*(C`*\*(C'\fR's, \f(CW\*(C`{n,m}\*(C'\fR's, n' \f(CW\*(C`+\*(C'\fR's.  Da book
\&\fIMasterin Regular Expressions\fR by Jeffrey Friedl gives a wonderful
rap of dis n' other efficiency issues.
.SS "Possessive quantifiers"
.IX Subsection "Possessive quantifiers"
Backtrackin durin tha relentless search fo' a match may be a waste
of time, particularly when tha match is bound ta fail.  Consider
the simple pattern
.PP
.Vb 1
\&    /^\ew+\es+\ew+$/; # a word, spaces, a word
.Ve
.PP
Whenever dis be applied ta a strang which don't like hook up the
patternz expectations like fuckin \f(CW"abc\ \ "\fR or \f(CW"abc\ \ def\ "\fR,
the regex engine will backtrack, approximately once fo' each character
in tha string.  But we know dat there is no way round takin \fIall\fR
of tha initial word charactas ta match tha straight-up original gangsta repetition, dat \fIall\fR
spaces must be smoked by tha middle part, n' tha same goes fo' tha second
word.
.PP
With tha introduction of tha \fIpossessive quantifiers\fR up in Perl 5.10, we
have a way of instructin tha regex engine not ta backtrack, wit the
usual quantifiers wit a \f(CW\*(C`+\*(C'\fR appended ta em.  This make dem greedy as
well as stingy; once they succeed they won't give anythang back ta permit
another solution. I aint talkin' bout chicken n' gravy biatch. They have tha followin meanings:
.IP "\(bu" 4
\&\f(CW\*(C`a{n,m}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times, not mo' than \f(CW\*(C`m\*(C'\fR times,
as nuff times as possible, n' don't give anythang up. \f(CW\*(C`a?+\*(C'\fR is short
for \f(CW\*(C`a{0,1}+\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`a{n,}+\*(C'\fR means: match at least \f(CW\*(C`n\*(C'\fR times yo, but as nuff times as possible,
and don't give anythang up. \f(CW\*(C`a*+\*(C'\fR is short fo' \f(CW\*(C`a{0,}+\*(C'\fR n' \f(CW\*(C`a++\*(C'\fR is
short fo' \f(CW\*(C`a{1,}+\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`a{n}+\*(C'\fR means: match exactly \f(CW\*(C`n\*(C'\fR times.  It be just there for
notationizzle consistency.
.PP
These possessive quantifiers represent a special case of a mo' general
concept, tha \fIindependent subexpression\fR, peep below.
.PP
As a example where a possessive quantifier is suitable we consider
matchin a quoted string, as it appears up in nuff muthafuckin programmin languages.
Da backslash is used as a escape characta dat indicates dat the
next characta is ta be taken literally, as another characta fo' the
string.  Therefore, afta tha openin quote, we expect a (possibly
empty) sequence of alternatives: either some characta except an
unescaped quote or backslash or a escaped character.
.PP
.Vb 1
\&    /"(?:[^"\e\e]++|\e\e.)*+"/;
.Ve
.SS "Buildin a regexp"
.IX Subsection "Buildin a regexp"
At dis point, our crazy asses have all tha basic regexp concepts covered, so let's
give a mo' involved example of a regular expression. I aint talkin' bout chicken n' gravy biatch.  Us thugs will build a
regexp dat matches numbers.
.PP
Da first task up in buildin a regexp is ta decizzle what tha fuck we wanna match
and what tha fuck we wanna exclude.  In our case, we wanna match both
integers n' floatin point numbers n' we wanna reject any string
that aint a number.
.PP
Da next task is ta break tha problem down tha fuck into smalla problems that
are easily converted tha fuck into a regexp.
.PP
Da simplest case is integers.  These consist of a sequence of digits,
with a optionizzle sign up in front.  Da digits we can represent with
\&\f(CW\*(C`\ed+\*(C'\fR n' tha sign can be matched wit \f(CW\*(C`[+\-]\*(C'\fR.  Thus tha integer
regexp is
.PP
.Vb 1
\&    /[+\-]?\ed+/;  # matches integers
.Ve
.PP
A floatin point number potentially has a sign, a integral part, a
decimal point, a gangbangin' fractionizzle part, n' a exponent.  One or mo' of these
parts is optional, so we need ta check up tha different
possibilities. Put ya muthafuckin choppers up if ya feel dis!  Floatin point numbers which is up in proper form include
123., 0.345, .34, \-1e6, n' 25.4E\-72.  As wit integers, tha sign out
front is straight-up optionizzle n' can be matched by \f(CW\*(C`[+\-]?\*(C'\fR.  We can
see dat if there is no exponent, floatin point numbers must have a
decimal point, otherwise they is integers.  We might be tempted to
model these wit \f(CW\*(C`\ed*\e.\ed*\*(C'\fR yo, but dis would also match just a single
decimal point, which aint a number n' shit.  So tha three casez of floating
point number without exponent are
.PP
.Vb 3
\&   /[+\-]?\ed+\e./;  # 1., 321., etc.
\&   /[+\-]?\e.\ed+/;  # .1, .234, etc.
\&   /[+\-]?\ed+\e.\ed+/;  # 1.0, 30.56, etc.
.Ve
.PP
These can be combined tha fuck into a single regexp wit a three-way alternation:
.PP
.Vb 1
\&   /[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+)/;  # floatin point, no exponent
.Ve
.PP
In dis alternation, it is blingin ta put \f(CW\*(Aq\ed+\e.\ed+\*(Aq\fR before
\&\f(CW\*(Aq\ed+\e.\*(Aq\fR.  If \f(CW\*(Aq\ed+\e.\*(Aq\fR was first, tha regexp would happily match that
and ignore tha fractionizzle part of tha number.
.PP
Now consider floatin point numbers wit exponents, n' you can put dat on yo' toast.  Da key
observation here is dat \fIboth\fR integers n' numbers wit decimal
points is allowed up in front of a exponent.  Then exponents, like the
overall sign, is independent of whether we is matchin numbers with
or without decimal points, n' can be 'decoupled' from the
mantissa.  Da overall form of tha regexp now becomes clear:
.PP
.Vb 1
\&    /^(optionizzle sign)(integer | f.p. mantissa)(optionizzle exponent)$/;
.Ve
.PP
Da exponent be a \f(CW\*(C`e\*(C'\fR or \f(CW\*(C`E\*(C'\fR, followed by a integer n' shit.  So the
exponent regexp is
.PP
.Vb 1
\&   /[eE][+\-]?\ed+/;  # exponent
.Ve
.PP
Puttin all tha parts together, we git a regexp dat matches numbers:
.PP
.Vb 1
\&   /^[+\-]?(\ed+\e.\ed+|\ed+\e.|\e.\ed+|\ed+)([eE][+\-]?\ed+)?$/;  # Ta da!
.Ve
.PP
Long regexps like dis may impress yo' playaz yo, but can be hard to
decipher n' shit.  In complex thangs like this, tha \f(CW\*(C`//x\*(C'\fR modifier fo' a
match is invaluable.  It allows one ta put nearly arbitrary whitespace
and comments tha fuck into a regexp without affectin they meaning.  Usin it,
we can rewrite our 'extended' regexp up in tha mo' pleasin form
.PP
.Vb 10
\&   /^
\&      [+\-], biatch?         # first, match a optionizzle sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of tha form a.b
\&         |\ed+\e.     # mantissa of tha form a.
\&         |\e.\ed+     # mantissa of tha form .b
\&         |\ed+       # integer of tha form a
\&      )
\&      ([eE][+\-]?\ed+), biatch?  # finally, optionally match a exponent
\&   $/x;
.Ve
.PP
If whitespace is mostly irrelevant, how tha fuck do one include space
charactas up in a extended regexp, biatch? Da answer is ta backslash it
\&\f(CW\*(Aq\e\ \*(Aq\fR or put it up in a cold-ass lil characta class \f(CW\*(C`[\ ]\*(C'\fR.  Da same thang
goes fo' pound signs: use \f(CW\*(C`\e#\*(C'\fR or \f(CW\*(C`[#]\*(C'\fR.  For instance, Perl allows
a space between tha sign n' tha mantissa or integer, n' we could add
this ta our regexp as bigs up:
.PP
.Vb 10
\&   /^
\&      [+\-]?\e *      # first, match a optionizzle sign *and space*
\&      (             # then match integers or f.p. mantissas:
\&          \ed+\e.\ed+  # mantissa of tha form a.b
\&         |\ed+\e.     # mantissa of tha form a.
\&         |\e.\ed+     # mantissa of tha form .b
\&         |\ed+       # integer of tha form a
\&      )
\&      ([eE][+\-]?\ed+), biatch?  # finally, optionally match a exponent
\&   $/x;
.Ve
.PP
In dis form, it is easier ta peep a way ta simplify the
alternation. I aint talkin' bout chicken n' gravy biatch.  Alternatives 1, 2, n' 4 all start wit \f(CW\*(C`\ed+\*(C'\fR, so it
could be factored out:
.PP
.Vb 11
\&   /^
\&      [+\-]?\e *      # first, match a optionizzle sign
\&      (             # then match integers or f.p. mantissas:
\&          \ed+       # start up wit a ...
\&          (
\&              \e.\ed* # mantissa of tha form a.b or a.
\&          ), biatch?        # , biatch? takes care of integerz of tha form a
\&         |\e.\ed+     # mantissa of tha form .b
\&      )
\&      ([eE][+\-]?\ed+), biatch?  # finally, optionally match a exponent
\&   $/x;
.Ve
.PP
or freestyled up in tha compact form,
.PP
.Vb 1
\&    /^[+\-]?\e *(\ed+(\e.\ed*)?|\e.\ed+)([eE][+\-]?\ed+)?$/;
.Ve
.PP
This is our final regexp.  To recap, we built a regexp by
.IP "\(bu" 4
specifyin tha task up in detail,
.IP "\(bu" 4
breakin down tha problem tha fuck into smalla parts,
.IP "\(bu" 4
translatin tha lil' small-ass parts tha fuck into regexps,
.IP "\(bu" 4
combinin tha regexps,
.IP "\(bu" 4
and optimizin tha final combined regexp.
.PP
These is also tha typical steps involved up in freestylin a cold-ass lil computer
program.  This make slick sense, cuz regular expressions are
essentially programs freestyled up in a lil computa language dat specifies
patterns.
.SS "Usin regular expressions up in Perl"
.IX Subsection "Usin regular expressions up in Perl"
Da last topic of Part 1 briefly covers how tha fuck regexps is used up in Perl
programs.  Where do they fit tha fuck into Perl syntax?
.PP
Our thugged-out asses have already introduced tha matchin operator up in its default
\&\f(CW\*(C`/regexp/\*(C'\fR n' arbitrary delimita \f(CW\*(C`m!regexp!\*(C'\fR forms.  Our thugged-out asses have used
the bindin operator \f(CW\*(C`=~\*(C'\fR n' its negation \f(CW\*(C`!~\*(C'\fR ta test fo' string
matches.  Associated wit tha matchin operator, our crazy asses have discussed the
single line \f(CW\*(C`//s\*(C'\fR, multi-line \f(CW\*(C`//m\*(C'\fR, case-insensitizzle \f(CW\*(C`//i\*(C'\fR and
extended \f(CW\*(C`//x\*(C'\fR modifiers.  There is all dem mo' thangs you might
wanna know bout matchin operators.
.PP
\fIProhibitin substitution\fR
.IX Subsection "Prohibitin substitution"
.PP
If you chizzle \f(CW$pattern\fR afta tha straight-up original gangsta substitution happens, Perl
will ignore dat shit.  If you don't want any substitutions at all, use the
special delimita \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    @pattern = (\*(AqSeuss\*(Aq);
\&    while (<>) {
\&        print if m\*(Aq@pattern\*(Aq;  # matches literal \*(Aq@pattern\*(Aq, not \*(AqSeuss\*(Aq
\&    }
.Ve
.PP
Similar ta strings, \f(CW\*(C`m\*(Aq\*(Aq\*(C'\fR acts like apostrophes on a regexp; all other
\&\f(CW\*(C`m\*(C'\fR delimitas act like quotes.  If tha regexp evaluates ta tha empty string,
the regexp up in tha \fIlast successful match\fR is used instead. Y'all KNOW dat shit, muthafucka!  So our crazy asses have
.PP
.Vb 2
\&    "dog" =~ /d/;  # \*(Aqd\*(Aq matches
\&    "dogbert =~ //;  # dis matches tha \*(Aqd\*(Aq regexp used before
.Ve
.PP
\fIGlobal matching\fR
.IX Subsection "Global matching"
.PP
Da final two modifiers we will say shit bout here,
\&\f(CW\*(C`//g\*(C'\fR n' \f(CW\*(C`//c\*(C'\fR, concern multiple matches.
Da modifier \f(CW\*(C`//g\*(C'\fR standz fo' global matchin n' allows the
matchin operator ta match within a strang as nuff times as possible.
In scalar context, successive invocations against a strang will have
\&\f(CW\*(C`//g\*(C'\fR jump from match ta match, keepin track of posizzle up in the
strin as it goes along.  Yo ass can git or set tha posizzle wit the
\&\f(CW\*(C`pos()\*(C'\fR function.
.PP
Da use of \f(CW\*(C`//g\*(C'\fR is shown up in tha followin example.  Suppose our crazy asses have
a strang dat consistz of lyrics separated by spaces.  If we know how
many lyrics there be up in advance, we could extract tha lyrics using
groupings:
.PP
.Vb 5
\&    $x = "cat dawg house"; # 3 lyrics
\&    $x =~ /^\es*(\ew+)\es+(\ew+)\es+(\ew+)\es*$/; # matches,
\&                                           # $1 = \*(Aqcat\*(Aq
\&                                           # $2 = \*(Aqdog\*(Aq
\&                                           # $3 = \*(Aqhouse\*(Aq
.Ve
.PP
But what tha fuck if our crazy asses had a indeterminizzle number of lyrics, biatch? This is tha sort
of task \f(CW\*(C`//g\*(C'\fR was made for. Shiiit, dis aint no joke.  To extract all lyrics, form tha simple
regexp \f(CW\*(C`(\ew+)\*(C'\fR n' loop over all matches wit \f(CW\*(C`/(\ew+)/g\*(C'\fR:
.PP
.Vb 3
\&    while ($x =~ /(\ew+)/g) {
\&        print "Word is $1, endz at posizzle ", pos $x, "\en";
\&    }
.Ve
.PP
prints
.PP
.Vb 3
\&    Word is cat, endz at posizzle 3
\&    Word is dog, endz at posizzle 7
\&    Word is house, endz at posizzle 13
.Ve
.PP
A failed match or changin tha target strang resets tha position. I aint talkin' bout chicken n' gravy biatch.  If
you don't want tha posizzle reset afta failure ta match, add the
\&\f(CW\*(C`//c\*(C'\fR, as up in \f(CW\*(C`/regexp/gc\*(C'\fR.  Da current posizzle up in tha strang is
associated wit tha string, not tha regexp.  This means dat different
strings have different positions n' they respectizzle positions can be
set or read independently.
.PP
In list context, \f(CW\*(C`//g\*(C'\fR returns a list of matched groupings, or if
there is no groupings, a list of matches ta tha whole regexp.  So if
we wanted just tha lyrics, we could use
.PP
.Vb 4
\&    @wordz = ($x =~ /(\ew+)/g);  # matches,
\&                                # $words[0] = \*(Aqcat\*(Aq
\&                                # $words[1] = \*(Aqdog\*(Aq
\&                                # $words[2] = \*(Aqhouse\*(Aq
.Ve
.PP
Closely associated wit tha \f(CW\*(C`//g\*(C'\fR modifier is tha \f(CW\*(C`\eG\*(C'\fR anchor. Shiiit, dis aint no joke.  The
\&\f(CW\*(C`\eG\*(C'\fR anchor matches all up in tha point where tha previous \f(CW\*(C`//g\*(C'\fR match left
off.  \f(CW\*(C`\eG\*(C'\fR allows our asses ta easily do context-sensitizzle matching:
.PP
.Vb 12
\&    $metric = 1;  # use metric units
\&    ...
\&    $x = <FILE>;  # read up in measurement
\&    $x =~ /^([+\-]?\ed+)\es*/g;  # git magnitude
\&    $weight = $1;
\&    if ($metric) { # error checking
\&        print "Units error!" unless $x =~ /\eGkg\e./g;
\&    }
\&    else {
\&        print "Units error!" unless $x =~ /\eGlbs\e./g;
\&    }
\&    $x =~ /\eG\es+(widget|sprocket)/g;  # continue processing
.Ve
.PP
Da combination of \f(CW\*(C`//g\*(C'\fR n' \f(CW\*(C`\eG\*(C'\fR allows our asses ta process tha strang a
bit at a time n' use arbitrary Perl logic ta decizzle what tha fuck ta do next.
Currently, tha \f(CW\*(C`\eG\*(C'\fR anchor is only straight-up supported when used ta anchor
to tha start of tha pattern.
.PP
\&\f(CW\*(C`\eG\*(C'\fR be also invaluable up in processin fixed-length recordz with
regexps.  Suppose our crazy asses gotz a snippet of codin region \s-1DNA,\s0 encoded as
base pair lettas \f(CW\*(C`ATCGTTGAAT...\*(C'\fR n' we wanna find all tha stop
codons \f(CW\*(C`TGA\*(C'\fR.  In a cold-ass lil codin region, codons is 3\-letta sequences, so
we can be thinkin of tha \s-1DNA\s0 snippet as a sequence of 3\-letta records.  The
naive regexp
.PP
.Vb 3
\&    # expanded, dis is "ATC GTT GAA TGC AAA TGA CAT GAC"
\&    $dna = "ATCGTTGAATGCAAATGACATGAC";
\&    $dna =~ /TGA/;
.Ve
.PP
doesn't work; it may match a \f(CW\*(C`TGA\*(C'\fR yo, but there is no guarantee that
the match be aligned wit codon boundaries, e.g., tha substring
\&\f(CW\*(C`GTT\ GAA\*(C'\fR gives a match.  A betta solution is
.PP
.Vb 3
\&    while ($dna =~ /(\ew\ew\ew)*?TGA/g) {  # note tha minimal *?
\&        print "Got a TGA stop codon at posizzle ", pos $dna, "\en";
\&    }
.Ve
.PP
which prints
.PP
.Vb 2
\&    Got a TGA stop codon at posizzle 18
\&    Got a TGA stop codon at posizzle 23
.Ve
.PP
Posizzle 18 is phat yo, but posizzle 23 is bogus.  What happened?
.PP
Da answer is dat our regexp works well until we git past tha last
real match.  Then tha regexp will fail ta match a synchronized \f(CW\*(C`TGA\*(C'\fR
and start steppin ahead one characta posizzle at a time, not what tha fuck we
want.  Da solution is ta use \f(CW\*(C`\eG\*(C'\fR ta anchor tha match ta tha codon
alignment:
.PP
.Vb 3
\&    while ($dna =~ /\eG(\ew\ew\ew)*?TGA/g) {
\&        print "Got a TGA stop codon at posizzle ", pos $dna, "\en";
\&    }
.Ve
.PP
This prints
.PP
.Vb 1
\&    Got a TGA stop codon at posizzle 18
.Ve
.PP
which is tha erect answer n' shit.  This example illustrates dat it is
important not only ta match what tha fuck is desired yo, but ta reject what tha fuck is not
desired.
.PP
(There is other regexp modifiers dat is available, such as
\&\f(CW\*(C`//o\*(C'\fR yo, but they specialized uses is beyond the
scope of dis introduction. I aint talkin' bout chicken n' gravy biatch.  )
.PP
\fISearch n' replace\fR
.IX Subsection "Search n' replace"
.PP
Regular expressions also play a funky-ass big-ass role up in \fIsearch n' replace\fR
operations up in Perl.  Search n' replace be accomplished wit the
\&\f(CW\*(C`s///\*(C'\fR operator. Shiiit, dis aint no joke.  Da general form is
\&\f(CW\*(C`s/regexp/replacement/modifiers\*(C'\fR, wit every last muthafuckin thang we know about
regexps n' modifiers applyin up in dis case as well.  The
\&\f(CW\*(C`replacement\*(C'\fR be a Perl double-quoted strang dat replaces up in the
strin whatever is matched wit tha \f(CW\*(C`regexp\*(C'\fR.  Da operator \f(CW\*(C`=~\*(C'\fR is
also used here ta associate a strang wit \f(CW\*(C`s///\*(C'\fR.  If matching
against \f(CW$_\fR, tha \f(CW\*(C`$_\ =~\*(C'\fR can be dropped. Y'all KNOW dat shit, muthafucka!  If there be a match,
\&\f(CW\*(C`s///\*(C'\fR returns tha number of substitutions made; otherwise it returns
false.  Here is all dem examples:
.PP
.Vb 8
\&    $x = "Time ta feed tha cat!";
\&    $x =~ s/cat/hacker/;   # $x gotz nuff "Time ta feed tha hacker!"
\&    if ($x =~ s/^(Time.*hacker)!$/$1 now!/) {
\&        $more_insistent = 1;
\&    }
\&    $y = "\*(Aqquoted lyrics\*(Aq";
\&    $y =~ s/^\*(Aq(.*)\*(Aq$/$1/;  # strip single quotes,
\&                           # $y gotz nuff "quoted lyrics"
.Ve
.PP
In tha last example, tha whole strang was matched yo, but only tha part
inside tha single quotes was grouped. Y'all KNOW dat shit, muthafucka!  With tha \f(CW\*(C`s///\*(C'\fR operator, the
matched variablez \f(CW$1\fR, \f(CW$2\fR, etc. is immediately available fo' use
in tha replacement expression, so we use \f(CW$1\fR ta replace tha quoted
strin wit just what tha fuck was quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  With tha global modifier, \f(CW\*(C`s///g\*(C'\fR
will search n' replace all occurrencez of tha regexp up in tha string:
.PP
.Vb 6
\&    $x = "I batted 4 fo' 4";
\&    $x =~ s/4/four/;   # don\*(Aqt do it all:
\&                       # $x gotz nuff "I batted four fo' 4"
\&    $x = "I batted 4 fo' 4";
\&    $x =~ s/4/four/g;  # do it all:
\&                       # $x gotz nuff "I batted four fo' four"
.Ve
.PP
If you prefer 'regex' over 'regexp' up in dis tutorial, you could use
the followin program ta replace it:
.PP
.Vb 9
\&    % pussaaaaay > simple_replace
\&    #!/usr/bin/perl
\&    $regexp = shift;
\&    $replacement = shift;
\&    while (<>) {
\&        s/$regexp/$replacement/g;
\&        print;
\&    }
\&    ^D
\&
\&    % simple_replace regexp regex perlretut.pod
.Ve
.PP
In \f(CW\*(C`simple_replace\*(C'\fR we used tha \f(CW\*(C`s///g\*(C'\fR modifier ta replace all
occurrencez of tha regexp on each line.  (Even though tha regular
expression appears up in a loop, Perl is smart-ass enough ta compile it
only once.)  As wit \f(CW\*(C`simple_grep\*(C'\fR, both the
\&\f(CW\*(C`print\*(C'\fR n' tha \f(CW\*(C`s/$regexp/$replacement/g\*(C'\fR use \f(CW$_\fR implicitly.
.PP
If you don't want \f(CW\*(C`s///\*(C'\fR ta chizzle yo' original gangsta variable you can use
the non-destructizzle substitute modifier, \f(CW\*(C`s///r\*(C'\fR.  This chizzlez the
behavior so dat \f(CW\*(C`s///r\*(C'\fR returns tha final substituted string
(instead of tha number of substitutions):
.PP
.Vb 3
\&    $x = "I wanna bust a nut on dawgs.";
\&    $y = $x =~ s/dawgs/cats/r;
\&    print "$x $y\en";
.Ve
.PP
That example will print \*(L"I wanna bust a nut on dawgs. I wanna bust a nut on cats\*(R". Notice tha original
\&\f(CW$x\fR variable has not been affected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da overall
result of tha substitution is instead stored up in \f(CW$y\fR. If the
substitution don't affect anythang then tha original gangsta strang is
returned:
.PP
.Vb 3
\&    $x = "I wanna bust a nut on dawgs.";
\&    $y = $x =~ s/elephants/cougars/r;
\&    print "$x $y\en"; # prints "I wanna bust a nut on dawgs. I wanna bust a nut on dawgs."
.Ve
.PP
One other bangin-ass thang dat tha \f(CW\*(C`s///r\*(C'\fR flag allows is chaining
substitutions:
.PP
.Vb 3
\&    $x = "Pussies is pimped out.";
\&    print $x =~ s/Cats/Dogs/r =~ s/Dogs/Frogs/r =~ s/Frogs/Hedgehogs/r, "\en";
\&    # prints "Hedgehogs is pimped out."
.Ve
.PP
A modifier available specifically ta search n' replace is the
\&\f(CW\*(C`s///e\*(C'\fR evaluation modifier n' shit.  \f(CW\*(C`s///e\*(C'\fR treats the
replacement text as Perl code, rather than a thugged-out double-quoted
string.  Da value dat tha code returns is substituted fo' the
matched substring.  \f(CW\*(C`s///e\*(C'\fR is useful if you need ta do a lil' bit of
computation up in tha process of replacin text.  This example counts
characta frequencies up in a line:
.PP
.Vb 4
\&    $x = "Bizzle tha cat";
\&    $x =~ s/(.)/$chars{$1}++;$1/eg;  # final $1 replaces char wit itself
\&    print "frequency of \*(Aq$_\*(Aq is $chars{$_}\en"
\&        foreach (sort {$chars{$b} <=> $chars{$a}} keys %chars);
.Ve
.PP
This prints
.PP
.Vb 9
\&    frequency of \*(Aq \*(Aq is 2
\&    frequency of \*(Aqt\*(Aq is 2
\&    frequency of \*(Aql\*(Aq is 2
\&    frequency of \*(AqB\*(Aq is 1
\&    frequency of \*(Aqc\*(Aq is 1
\&    frequency of \*(Aqe\*(Aq is 1
\&    frequency of \*(Aqh\*(Aq is 1
\&    frequency of \*(Aqi\*(Aq is 1
\&    frequency of \*(Aqa\*(Aq is 1
.Ve
.PP
As wit tha match \f(CW\*(C`m//\*(C'\fR operator, \f(CW\*(C`s///\*(C'\fR can use other delimiters,
like fuckin \f(CW\*(C`s!!!\*(C'\fR n' \f(CW\*(C`s{}{}\*(C'\fR, n' even \f(CW\*(C`s{}//\*(C'\fR.  If single quotes are
used \f(CW\*(C`s\*(Aq\*(Aq\*(Aq\*(C'\fR, then tha regexp n' replacement are
treated as single-quoted strings n' there be no
variable substitutions.  \f(CW\*(C`s///\*(C'\fR up in list context
returns tha same ol' dirty thang as up in scalar context, i.e., tha number of
matches.
.PP
\fIDa split function\fR
.IX Subsection "Da split function"
.PP
Da \f(CW\*(C`split()\*(C'\fR function be another place where a regexp is used.
\&\f(CW\*(C`split /regexp/, string, limit\*(C'\fR separates tha \f(CW\*(C`string\*(C'\fR operand into
a list of substrings n' returns dat list.  Da regexp must be designed
to match whatever constitutes tha separators fo' tha desired substrings.
Da \f(CW\*(C`limit\*(C'\fR, if present, constrains splittin tha fuck into no mo' than \f(CW\*(C`limit\*(C'\fR
number of strings.  For example, ta split a strang tha fuck into lyrics, use
.PP
.Vb 4
\&    $x = "Calvin n' Hobbes";
\&    @wordz = split /\es+/, $x;  # $word[0] = \*(AqCalvin\*(Aq
\&                               # $word[1] = \*(Aqand\*(Aq
\&                               # $word[2] = \*(AqHobbes\*(Aq
.Ve
.PP
If tha empty regexp \f(CW\*(C`//\*(C'\fR is used, tha regexp always matches and
the strang is split tha fuck into individual characters.  If tha regexp has
groupings, then tha resultin list gotz nuff tha matched substrings from the
groupings as well.  For instance,
.PP
.Vb 12
\&    $x = "/usr/bin/perl";
\&    @dirs = split m!/!, $x;  # $dirs[0] = \*(Aq\*(Aq
\&                             # $dirs[1] = \*(Aqusr\*(Aq
\&                             # $dirs[2] = \*(Aqbin\*(Aq
\&                             # $dirs[3] = \*(Aqperl\*(Aq
\&    @parts = split m!(/)!, $x;  # $parts[0] = \*(Aq\*(Aq
\&                                # $parts[1] = \*(Aq/\*(Aq
\&                                # $parts[2] = \*(Aqusr\*(Aq
\&                                # $parts[3] = \*(Aq/\*(Aq
\&                                # $parts[4] = \*(Aqbin\*(Aq
\&                                # $parts[5] = \*(Aq/\*(Aq
\&                                # $parts[6] = \*(Aqperl\*(Aq
.Ve
.PP
Since tha straight-up original gangsta characta of \f(CW$x\fR matched tha regexp, \f(CW\*(C`split\*(C'\fR prepended
an empty initial element ta tha list.
.PP
If you have read dis far, props muthafucka! Yo ass now have all tha basic
tools needed ta use regular expressions ta solve a wide range of text
processin problems.  If dis is yo' last time all up in tha tutorial,
why not stop here n' play round wit regexps a while....  Part\ 2
concerns tha mo' esoteric aspectz of regular expressions n' them
concepts certainly aren't needed right all up in tha start.
.SH "Part 2: Juice tools"
.IX Header "Part 2: Juice tools"
\&\s-1OK,\s0 you know tha basics of regexps n' you wanna know mo' n' mo' n' mo'.  If
matchin regular expressions be analogous ta a strutt up in tha woods, then
the tools discussed up in Part 1 is analogous ta topo maps n' a
compass, basic tools we use all tha time.  Most of tha tools up in part 2
are analogous ta flare glocks n' satellite phones.  They aren't used
too often on a hike yo, but when we is stuck, they can be invaluable.
.PP
What bigs up is tha mo' advanced, less used, or sometimes esoteric
capabilitizzlez of Perl regexps.  In Part 2, we will assume yo ass is
comfortable wit tha basics n' concentrate on tha advanced features.
.SS "Mo' on characters, strings, n' characta classes"
.IX Subsection "Mo' on characters, strings, n' characta classes"
There is a fuckin shitload of escape sequences n' characta classes dat we
haven't covered yet.
.PP
There is nuff muthafuckin escape sequences dat convert charactas or strings
between upper n' lower case, n' they is also available within
patterns.  \f(CW\*(C`\el\*(C'\fR n' \f(CW\*(C`\eu\*(C'\fR convert tha next characta ta lower or
upper case, respectively:
.PP
.Vb 4
\&    $x = "perl";
\&    $strin =~ /\eu$x/;  # matches \*(AqPerl\*(Aq up in $string
\&    $x = "M(rs?|s)\e\e."; # note tha double backslash
\&    $strin =~ /\el$x/;  # matches \*(Aqmr.\*(Aq, \*(Aqmrs.\*(Aq, n' \*(Aqms.\*(Aq,
.Ve
.PP
A \f(CW\*(C`\eL\*(C'\fR or \f(CW\*(C`\eU\*(C'\fR indicates a lastin conversion of case, until
terminated by \f(CW\*(C`\eE\*(C'\fR or thrown over by another \f(CW\*(C`\eU\*(C'\fR or \f(CW\*(C`\eL\*(C'\fR:
.PP
.Vb 4
\&    $x = "This word is up in lower case:\eL SHOUT\eE";
\&    $x =~ /shout/;       # matches
\&    $x = "I STILL KEYPUNCH CARDS FOR MY 360"
\&    $x =~ /\eUkeypunch/;  # matches punch card string
.Ve
.PP
If there is no \f(CW\*(C`\eE\*(C'\fR, case is converted until tha end of the
string. Da regexps \f(CW\*(C`\eL\eu$word\*(C'\fR or \f(CW\*(C`\eu\eL$word\*(C'\fR convert tha first
characta of \f(CW$word\fR ta uppercase n' tha rest of tha charactas to
lowercase.
.PP
Control charactas can be escaped wit \f(CW\*(C`\ec\*(C'\fR, so dat a cold-ass lil control-Z
characta would be matched wit \f(CW\*(C`\ecZ\*(C'\fR.  Da escape sequence
\&\f(CW\*(C`\eQ\*(C'\fR...\f(CW\*(C`\eE\*(C'\fR quotes, or protects most non-alphabetic characters.   For
instance,
.PP
.Vb 2
\&    $x = "\eQThat !^*&%~& cat!";
\&    $x =~ /\eQ!^*&%~&\eE/;  # check fo' rough language
.Ve
.PP
It do not protect \f(CW\*(C`$\*(C'\fR or \f(CW\*(C`@\*(C'\fR, so dat variablez can still be
substituted.
.PP
\&\f(CW\*(C`\eQ\*(C'\fR, \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR n' \f(CW\*(C`\eE\*(C'\fR is straight-up part of
double-quotish syntax, n' not part of regexp syntax proper n' shit.  They will
work if they step tha fuck up in a regular expression embedded directly up in a
program yo, but not when contained up in a strang dat is interpolated up in a
pattern.
.PP
Perl regexps can handle mo' than just the
standard \s-1ASCII\s0 characta set.  Perl supports \fIUnicode\fR, a standard
for representin tha alphabets from virtually all of tha ghettoz written
languages, n' a host of symbols.  Perlz text strings is Unicode strings, so
they can contain charactas wit a value (codepoint or characta number) higher
than 255.
.PP
What do dis mean fo' regexps, biatch? Well, regexp playas don't need ta know
much bout Perlz internal representation of strings.  But they do need
to know 1) how tha fuck ta represent Unicode charactas up in a regexp n' 2) that
a matchin operation will treat tha strang ta be searched as a sequence
of characters, not bytes.  Da answer ta 1) is dat Unicode characters
greata than \f(CW\*(C`chr(255)\*(C'\fR is represented rockin tha \f(CW\*(C`\ex{hex}\*(C'\fR notation, cuz
\&\ex hex (without curly braces) don't go further than 255.  (Startin up in Perl
5.14, if you a octal fan, you can also use \f(CW\*(C`\eo{oct}\*(C'\fR.)
.PP
.Vb 1
\&    /\ex{263a}/;  # match a Unicode smiley grill :)
.Ve
.PP
\&\fB\s-1NOTE\s0\fR: In Perl 5.6.0 it used ta be dat one needed ta say \f(CW\*(C`use
utf8\*(C'\fR ta use any Unicode features.  This is no mo' tha case: for
almost all Unicode processing, tha explicit \f(CW\*(C`utf8\*(C'\fR pragma is not
needed. Y'all KNOW dat shit, muthafucka!  (Da only case where it mattas is if yo' Perl script is in
Unicode n' encoded up in \s-1UTF\-8,\s0 then a explicit \f(CW\*(C`use utf8\*(C'\fR is needed.)
.PP
Figurin up tha hexadecimal sequence of a Unicode characta you want
or decipherin one of mah thugsz hexadecimal Unicode regexp be bout as
much funk as programmin up in machine code.  So another way ta specify
Unicode charactas is ta use tha \fInamed character\fR escape
sequence \f(CW\*(C`\eN{\f(CIname\f(CW}\*(C'\fR.  \fIname\fR be a name fo' tha Unicode character, as
specified up in tha Unicode standard. Y'all KNOW dat shit, muthafucka!  For instance, if we wanted to
represent or match tha astrological sign fo' tha hood Mercury, we
could use
.PP
.Vb 2
\&    $x = "abc\eN{MERCURY}def";
\&    $x =~ /\eN{MERCURY}/;   # matches
.Ve
.PP
One can also use \*(L"short\*(R" names:
.PP
.Vb 2
\&    print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\&    print "\eN{greek:Sigma} be a upper\-case sigma.\en";
.Ve
.PP
Yo ass can also restrict names ta a cold-ass lil certain alphabet by specifyin the
charnames pragma:
.PP
.Vb 2
\&    use charnames qw(greek);
\&    print "\eN{sigma} is Greek sigma\en";
.Ve
.PP
An index of characta names be available on-line from tha Unicode
Consortium, <http://www.unicode.org/charts/charindex.html>; explanatory
material wit links ta other resources at
<http://www.unicode.org/standard/where>.
.PP
Da answer ta requirement 2) is dat a regexp (mostly)
uses Unicode characters.  Da \*(L"mostly\*(R" is fo' messy backward
compatibilitizzle reasons yo, but startin up in Perl 5.14, any regex compiled in
the scope of a \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (which be automatically
turned on within tha scope of a \f(CW\*(C`use 5.012\*(C'\fR or higher) will turn that
\&\*(L"mostly\*(R" tha fuck into \*(L"always\*(R".  If you wanna handle Unicode properly, you
should ensure dat \f(CW\*(Aqunicode_strings\*(Aq\fR is turned on.
Internally, dis is encoded ta bytes rockin either \s-1UTF\-8\s0 or a natizzle 8
bit encoding, dependin on tha history of tha strin yo, but conceptually
it be a sequence of characters, not bytes. Right back up in yo muthafuckin ass. See perlunitut fo' a
tutorial bout dis shit.
.PP
Let our asses now say shit bout Unicode characta classes.  Just as wit Unicode
characters, there be named Unicode characta classes represented by the
\&\f(CW\*(C`\ep{name}\*(C'\fR escape sequence.  Closely associated is tha \f(CW\*(C`\eP{name}\*(C'\fR
characta class, which is tha negation of tha \f(CW\*(C`\ep{name}\*(C'\fR class.  For
example, ta match lower n' uppercase characters,
.PP
.Vb 5
\&    $x = "BOB";
\&    $x =~ /^\ep{IsUpper}/;   # matches, uppercase char class
\&    $x =~ /^\eP{IsUpper}/;   # don\*(Aqt match, char class sans uppercase
\&    $x =~ /^\ep{IsLower}/;   # don\*(Aqt match, lowercase char class
\&    $x =~ /^\eP{IsLower}/;   # matches, char class sans lowercase
.Ve
.PP
(Da \*(L"Is\*(R" is optional.)
.PP
Here is tha association between some Perl named classes n' the
traditionizzle Unicode classes:
.PP
.Vb 1
\&    Perl class name  Unicode class name or regular expression
\&
\&    IsAlpha          /^[LM]/
\&    IsAlnum          /^[LMN]/
\&    IsASCII          $code <= 127
\&    IsCntrl          /^C/
\&    IsBlank          $code =~ /^(0020|0009)$/ || /^Z[^lp]/
\&    IsDigit          Nd
\&    IsGraph          /^([LMNPS]|Co)/
\&    IsLower          Ll
\&    IsPrint          /^([LMNPS]|Co|Zs)/
\&    IsPunct          /^P/
\&    IsSpace          /^Z/ || ($code =~ /^(0009|000A|000B|000C|000D)$/
\&    IsSpacePerl      /^Z/ || ($code =~ /^(0009|000A|000C|000D|0085|2028|2029)$/
\&    IsUpper          /^L[ut]/
\&    IsWord           /^[LMN]/ || $code eq "005F"
\&    IsXDigit         $code =~ /^00(3[0\-9]|[46][1\-6])$/
.Ve
.PP
Yo ass can also use tha straight-up legit Unicode class names wit \f(CW\*(C`\ep\*(C'\fR and
\&\f(CW\*(C`\eP\*(C'\fR, like \f(CW\*(C`\ep{L}\*(C'\fR fo' Unicode 'letters', \f(CW\*(C`\ep{Lu}\*(C'\fR fo' uppercase
letters, or \f(CW\*(C`\eP{Nd}\*(C'\fR fo' non-digits, n' you can put dat on yo' toast.  If a \f(CW\*(C`name\*(C'\fR is just one
letter, tha braces can be dropped. Y'all KNOW dat shit, muthafucka!  For instance, \f(CW\*(C`\epM\*(C'\fR is the
characta class of Unicode 'marks', fo' example accent marks.
For tha full list peep perlunicode.
.PP
Unicode has also been separated tha fuck into various setz of characters
which you can test wit \f(CW\*(C`\ep{...}\*(C'\fR (in) n' \f(CW\*(C`\eP{...}\*(C'\fR (not in).
To test whether a cold-ass lil characta is (or is not) a element of a script
you would use tha script name, fo' example \f(CW\*(C`\ep{Latin}\*(C'\fR, \f(CW\*(C`\ep{Greek}\*(C'\fR,
or \f(CW\*(C`\eP{Katakana}\*(C'\fR.
.PP
What our crazy asses have busted lyrics bout so far is tha single form of tha \f(CW\*(C`\ep{...}\*(C'\fR character
classes.  There be also a cold-ass lil compound form which you may run into.  These
look like \f(CW\*(C`\ep{name=value}\*(C'\fR or \f(CW\*(C`\ep{name:value}\*(C'\fR (the equals sign n' colon
can be used interchangeably).  These is mo' general than tha single form,
and up in fact most of tha single forms is just Perl-defined shortcuts fo' common
compound forms.  For example, tha script examplez up in tha previous paragraph
could be freestyled equivalently as \f(CW\*(C`\ep{Script=Latin}\*(C'\fR, \f(CW\*(C`\ep{Script:Greek}\*(C'\fR, and
\&\f(CW\*(C`\eP{script=katakana}\*(C'\fR (case is irrelevant between tha \f(CW\*(C`{}\*(C'\fR braces).  Yo ass may
never gotta use tha compound forms yo, but sometimes it is necessary, n' their
use can make yo' code easier ta understand.
.PP
\&\f(CW\*(C`\eX\*(C'\fR be a abbreviation fo' a cold-ass lil characta class dat comprises
a Unicode \fIextended grapheme cluster\fR.  This represents a \*(L"logical character\*(R":
what appears ta be a single character yo, but may be represented internally by more
than one.  As a example, rockin tha Unicode full names, e.g., \f(CW\*(C`A\ +\ COMBINING\ RING\*(C'\fR be a grapheme clusta wit base characta \f(CW\*(C`A\*(C'\fR n' combinin character
\&\f(CW\*(C`COMBINING\ RING\*(C'\fR, which translates up in Danish ta A wit tha circle atop it,
as up in tha word Angstrom.
.PP
For tha full n' sickest fuckin shiznit bout Unicode peep tha sickest fuckin
Unicode standard, or tha Unicode Consortiumz joint <http://www.unicode.org>
.PP
As if all dem classes weren't enough, Perl also defines POSIX-style
characta classes.  These have tha form \f(CW\*(C`[:name:]\*(C'\fR, wit \f(CW\*(C`name\*(C'\fR the
name of tha \s-1POSIX\s0 class.  Da \s-1POSIX\s0 classes is \f(CW\*(C`alpha\*(C'\fR, \f(CW\*(C`alnum\*(C'\fR,
\&\f(CW\*(C`ascii\*(C'\fR, \f(CW\*(C`cntrl\*(C'\fR, \f(CW\*(C`digit\*(C'\fR, \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`lower\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`punct\*(C'\fR,
\&\f(CW\*(C`space\*(C'\fR, \f(CW\*(C`upper\*(C'\fR, n' \f(CW\*(C`xdigit\*(C'\fR, n' two extensions, \f(CW\*(C`word\*(C'\fR (a Perl
extension ta match \f(CW\*(C`\ew\*(C'\fR), n' \f(CW\*(C`blank\*(C'\fR (a \s-1GNU\s0 extension).  Da \f(CW\*(C`//a\*(C'\fR
modifier restricts these ta matchin just up in tha \s-1ASCII\s0 range; otherwise
they can match tha same as they correspondin Perl Unicode classes:
\&\f(CW\*(C`[:upper:]\*(C'\fR is tha same ol' dirty as \f(CW\*(C`\ep{IsUpper}\*(C'\fR, etc.  (There is some
exceptions n' gotchas wit this; peep perlrecharclass fo' a gangbangin' full
rap.) Da \f(CW\*(C`[:digit:]\*(C'\fR, \f(CW\*(C`[:word:]\*(C'\fR, and
\&\f(CW\*(C`[:space:]\*(C'\fR correspond ta tha familiar \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, n' \f(CW\*(C`\es\*(C'\fR
characta classes.  To negate a \s-1POSIX\s0 class, put a \f(CW\*(C`^\*(C'\fR up in front of
the name, so that, e.g., \f(CW\*(C`[:^digit:]\*(C'\fR correspondz ta \f(CW\*(C`\eD\*(C'\fR and, under
Unicode, \f(CW\*(C`\eP{IsDigit}\*(C'\fR.  Da Unicode n' \s-1POSIX\s0 characta classes can
be used just like \f(CW\*(C`\ed\*(C'\fR, wit tha exception dat \s-1POSIX\s0 character
classes can only be used inside of a cold-ass lil characta class:
.PP
.Vb 6
\&    /\es+[abc[:digit:]xyz]\es*/;  # match a,b,c,x,y,z, or a gangbangin' finger-lickin' digit
\&    /^=item\es[[:digit:]]/;      # match \*(Aq=item\*(Aq,
\&                                # followed by a space n' a gangbangin' finger-lickin' digit
\&    /\es+[abc\ep{IsDigit}xyz]\es+/;  # match a,b,c,x,y,z, or a gangbangin' finger-lickin' digit
\&    /^=item\es\ep{IsDigit}/;        # match \*(Aq=item\*(Aq,
\&                                  # followed by a space n' a gangbangin' finger-lickin' digit
.Ve
.PP
Whew! That be all tha rest of tha charactas n' characta classes.
.SS "Compilin n' savin regular expressions"
.IX Subsection "Compilin n' savin regular expressions"
In Part 1 we mentioned dat Perl compilez a regexp tha fuck into a cold-ass lil compact
sequence of opcodes.  Thus, a cold-ass lil compiled regexp be a thugged-out data structure
that can be stored once n' used again n' again n' again n' again. I aint talkin' bout chicken n' gravy biatch.  Da regexp quote
\&\f(CW\*(C`qr//\*(C'\fR do exactly that: \f(CW\*(C`qr/string/\*(C'\fR compilez tha \f(CW\*(C`string\*(C'\fR as a
regexp n' transforms tha result tha fuck into a gangbangin' form dat can be assigned ta a
variable:
.PP
.Vb 1
\&    $reg = qr/foo+bar?/;  # reg gotz nuff a cold-ass lil compiled regexp
.Ve
.PP
Then \f(CW$reg\fR can be used as a regexp:
.PP
.Vb 3
\&    $x = "fooooba";
\&    $x =~ $reg;     # matches, just like /foo+bar?/
\&    $x =~ /$reg/;   # same thang, alternate form
.Ve
.PP
\&\f(CW$reg\fR can also be interpolated tha fuck into a larger regexp:
.PP
.Vb 1
\&    $x =~ /(abc)?$reg/;  # still matches
.Ve
.PP
As wit tha matchin operator, tha regexp quote can use different
delimiters, e.g., \f(CW\*(C`qr!!\*(C'\fR, \f(CW\*(C`qr{}\*(C'\fR or \f(CW\*(C`qr~~\*(C'\fR.  Apostrophes
as delimitas (\f(CW\*(C`qr\*(Aq\*(Aq\*(C'\fR) inhibit any interpolation.
.PP
Pre-compiled regexps is useful fo' bustin dynamic matches that
don't need ta be recompiled each time they is encountered. Y'all KNOW dat shit, muthafucka!  Using
pre-compiled regexps, we write a \f(CW\*(C`grep_step\*(C'\fR program which greps
for a sequence of patterns, advancin ta tha next pattern as soon
as one has been satisfied.
.PP
.Vb 4
\&    % pussaaaaay > grep_step
\&    #!/usr/bin/perl
\&    # grep_step \- match <number> regexps, one afta tha other
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    @compiled = map qr/$_/, @regexp;
\&    while ($line = <>) {
\&        if ($line =~ /$compiled[0]/) {
\&            print $line;
\&            shift @compiled;
\&            last unless @compiled;
\&        }
\&    }
\&    ^D
\&
\&    % grep_step 3 shift print last grep_step
\&    $number = shift;
\&            print $line;
\&            last unless @compiled;
.Ve
.PP
Storin pre-compiled regexps up in a array \f(CW@compiled\fR allows our asses to
simply loop all up in tha regexps without any recompilation, thus gaining
flexibilitizzle without sacrificin speed.
.SS "Composin regular expressions at runtime"
.IX Subsection "Composin regular expressions at runtime"
Backtrackin is mo' efficient than repeated tries wit different regular
expressions.  If there be nuff muthafuckin regular expressions n' a match with
any of dem be acceptable, then it is possible ta combine dem tha fuck into a set
of alternatives.  If tha individual expressions is input data, this
can be done by programmin a join operation. I aint talkin' bout chicken n' gravy biatch.  We bout ta exploit dis scam in
an improved version of tha \f(CW\*(C`simple_grep\*(C'\fR program: a program dat matches
multiple patterns:
.PP
.Vb 4
\&    % pussaaaaay > multi_grep
\&    #!/usr/bin/perl
\&    # multi_grep \- match any of <number> regexps
\&    # usage: multi_grep <number> regexp1 regexp2 ... file1 file2 ...
\&
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
\&    $pattern = join \*(Aq|\*(Aq, @regexp;
\&
\&    while ($line = <>) {
\&        print $line if $line =~ /$pattern/;
\&    }
\&    ^D
\&
\&    % multi_grep 2 shift fo' multi_grep
\&    $number = shift;
\&    $regexp[$_] = shift foreach (0..$number\-1);
.Ve
.PP
Sometimes it be advantageous ta construct a pattern from tha \fIinput\fR
that is ta be analyzed n' use tha permissible joints on tha left
hand side of tha matchin operations.  As a example fo' dis somewhat
paradoxical thang, letz assume dat our input gotz nuff a cold-ass lil command
verb which should match one outta a set of available command verbs,
with tha additionizzle twist dat commandz may be abbreviated as long as
the given strang is unique. Da program below demonstrates tha basic
algorithm.
.PP
.Vb 10
\&    % pussaaaaay > keymatch
\&    #!/usr/bin/perl
\&    $kwdz = \*(Aqcopy compare list print\*(Aq;
\&    while( $command = <> ){
\&        $command =~ s/^\es+|\es+$//g;  # trim leadin n' trailin spaces
\&        if( ( @matches = $kwdz =~ /\eb$command\ew*/g ) == 1 ){
\&            print "command: \*(Aq@matches\*(Aq\en";
\&        } elsif( @matches == 0 ){
\&            print "no such command: \*(Aq$command\*(Aq\en";
\&        } else {
\&            print "not unique: \*(Aq$command\*(Aq (could be one of: @matches)\en";
\&        }
\&    }
\&    ^D
\&
\&    % keymatch
\&    li
\&    command: \*(Aqlist\*(Aq
\&    co
\&    not unique: \*(Aqco\*(Aq (could be one of: copy compare)
\&    printer
\&    no such command: \*(Aqprinter\*(Aq
.Ve
.PP
Rather than tryin ta match tha input against tha keywords, we match the
combined set of keywordz against tha input.  Da pattern matching
operation \f(CW\*(C`$kwds\ =~\ /\eb($command\ew*)/g\*(C'\fR do nuff muthafuckin thangs at the
same time. Well shiiiit, it make shizzle dat tha given command begins where a keyword
begins (\f(CW\*(C`\eb\*(C'\fR). Well shiiiit, it tolerates abbreviations cuz of tha added \f(CW\*(C`\ew*\*(C'\fR. It
 drops some lyrics ta our asses tha number of matches (\f(CW\*(C`scalar @matches\*(C'\fR) n' all tha keywords
that was straight-up matched. Y'all KNOW dat shit, muthafucka!  Yo ass could hardly ask fo' more.
.SS "Embeddin comments n' modifiers up in a regular expression"
.IX Subsection "Embeddin comments n' modifiers up in a regular expression"
Startin wit dis section, we is ghon be discussin Perlz set of
\&\fIextended patterns\fR.  These is extensions ta tha traditionizzle regular
expression syntax dat provide bangin freshly smoked up tools fo' pattern
matching.  Our thugged-out asses have already peeped extensions up in tha form of tha minimal
matchin constructs \f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}?\*(C'\fR, n' \f(CW\*(C`{n,}?\*(C'\fR.  Most
of tha extensions below have tha form \f(CW\*(C`(?char...)\*(C'\fR, where the
\&\f(CW\*(C`char\*(C'\fR be a cold-ass lil characta dat determines tha type of extension.
.PP
Da first extension be a embedded comment \f(CW\*(C`(?#text)\*(C'\fR.  This embedz a
comment tha fuck into tha regular expression without affectin its meaning.  The
comment should not have any closin parentheses up in tha text.  An
example is
.PP
.Vb 1
\&    /(?# Match a integer:)[+\-]?\ed+/;
.Ve
.PP
This steez of commentin has been largely superseded by tha raw,
freeform commentin dat be allowed wit tha \f(CW\*(C`//x\*(C'\fR modifier.
.PP
Most modifiers, like fuckin \f(CW\*(C`//i\*(C'\fR, \f(CW\*(C`//m\*(C'\fR, \f(CW\*(C`//s\*(C'\fR n' \f(CW\*(C`//x\*(C'\fR (or any
combination thereof) can also be embedded in
a regexp rockin \f(CW\*(C`(?i)\*(C'\fR, \f(CW\*(C`(?m)\*(C'\fR, \f(CW\*(C`(?s)\*(C'\fR, n' \f(CW\*(C`(?x)\*(C'\fR.  For instance,
.PP
.Vb 7
\&    /(?i)yes/;  # match \*(Aqyes\*(Aq case insensitively
\&    /yes/i;     # same thang
\&    /(?x)(          # freeform version of a integer regexp
\&             [+\-], biatch?  # match a optionizzle sign
\&             \ed+    # match a sequence of digits
\&         )
\&    /x;
.Ve
.PP
Embedded modifiers can have two blingin advantages over tha usual
modifiers.  Embedded modifiers allow a cold-ass lil custom set of modifiers to
\&\fIeach\fR regexp pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This is pimped out fo' matchin a array of regexps
that must have different modifiers:
.PP
.Vb 8
\&    $pattern[0] = \*(Aq(?i)doctor\*(Aq;
\&    $pattern[1] = \*(AqJohnson\*(Aq;
\&    ...
\&    while (<>) {
\&        foreach $patt (@pattern) {
\&            print if /$patt/;
\&        }
\&    }
.Ve
.PP
Da second advantage is dat embedded modifiers (except \f(CW\*(C`//p\*(C'\fR, which
modifies tha entire regexp) only affect tha regexp
inside tha crew tha embedded modifier is contained in. I aint talkin' bout chicken n' gravy biatch.  So grouping
can be used ta localize tha modifierz effects:
.PP
.Vb 1
\&    /Answer: ((?i)yes)/;  # matches \*(AqAnswer: yes\*(Aq, \*(AqAnswer: YES\*(Aq, etc.
.Ve
.PP
Embedded modifiers can also turn off any modifiers already present
by using, e.g., \f(CW\*(C`(?\-i)\*(C'\fR.  Modifiers can also be combined into
a single expression, e.g., \f(CW\*(C`(?s\-i)\*(C'\fR turns on single line mode and
turns off case insensitivity.
.PP
Embedded modifiers may also be added ta a non-capturin grouping.
\&\f(CW\*(C`(?i\-m:regexp)\*(C'\fR be a non-capturin groupin dat matches \f(CW\*(C`regexp\*(C'\fR
case insensitively n' turns off multi-line mode.
.SS "Lookin ahead n' lookin behind"
.IX Subsection "Lookin ahead n' lookin behind"
This section concerns tha lookahead n' lookbehind assertions.  First,
a lil background.
.PP
In Perl regular expressions, most regexp elements 'eat up' a cold-ass lil certain
amount of strang when they match.  For instance, tha regexp element
\&\f(CW\*(C`[abc}]\*(C'\fR smokes up one characta of tha strang when it matches, up in the
sense dat Perl moves ta tha next characta posizzle up in tha string
afta tha match.  There is some elements, however, dat don't smoke up
charactas (advizzle tha characta position) if they match.  Da examples
we have peeped so far is tha anchors.  Da anchor \f(CW\*(C`^\*(C'\fR matches the
beginnin of tha line yo, but don't smoke any characters.  Similarly, the
word boundary anchor \f(CW\*(C`\eb\*(C'\fR matches wherever a cold-ass lil characta matchin \f(CW\*(C`\ew\*(C'\fR
is next ta a cold-ass lil characta dat don't yo, but it don't smoke up any
charactas itself.  Anchors is examplez of \fIzero-width assertions\fR:
zero-width, cuz they consume
no characters, n' assertions, cuz they test some property of the
string.  In tha context of our strutt up in tha woodz analogy ta regexp
matching, most regexp elements move our asses along a trail yo, but anchors have
us stop a moment n' check our surroundings.  If tha local environment
checks out, we can proceed forward. Y'all KNOW dat shit, muthafucka!  But if tha local environment
doesn't satisfy us, we must backtrack.
.PP
Checkin tha environment entails either lookin ahead on tha trail,
lookin behind, or both.  \f(CW\*(C`^\*(C'\fR looks behind, ta peep dat there be no
charactas before.  \f(CW\*(C`$\*(C'\fR looks ahead, ta peep dat there be no
charactas afta n' shit.  \f(CW\*(C`\eb\*(C'\fR looks both ahead n' behind, ta peep if the
charactas on either side differ up in they \*(L"word-ness\*(R".
.PP
Da lookahead n' lookbehind assertions is generalizationz of the
anchor concept.  Lookahead n' lookbehind is zero-width assertions
that let our asses specify which charactas we wanna test for. Shiiit, dis aint no joke.  The
lookahead assertion is denoted by \f(CW\*(C`(?=regexp)\*(C'\fR n' tha lookbehind
assertion is denoted by \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR.  Some examplez are
.PP
.Vb 8
\&    $x = "I catch tha housecat \*(AqTom\-cat\*(Aq wit catnip";
\&    $x =~ /cat(?=\es)/;   # matches \*(Aqcat\*(Aq up in \*(Aqhousecat\*(Aq
\&    @catwordz = ($x =~ /(?<=\es)cat\ew+/g);  # matches,
\&                                           # $catwords[0] = \*(Aqcatch\*(Aq
\&                                           # $catwords[1] = \*(Aqcatnip\*(Aq
\&    $x =~ /\ebcat\eb/;  # matches \*(Aqcat\*(Aq up in \*(AqTom\-cat\*(Aq
\&    $x =~ /(?<=\es)cat(?=\es)/; # don\*(Aqt match; no isolated \*(Aqcat\*(Aq in
\&                              # middle of $x
.Ve
.PP
Note dat tha parentheses up in \f(CW\*(C`(?=regexp)\*(C'\fR n' \f(CW\*(C`(?<=regexp)\*(C'\fR are
non-capturing, since these is zero-width assertions.  Thus up in the
second regexp, tha substrings captured is dem of tha whole regexp
itself.  Lookahead \f(CW\*(C`(?=regexp)\*(C'\fR can match arbitrary regexps yo, but
lookbehind \f(CW\*(C`(?<=fixed\-regexp)\*(C'\fR only works fo' regexpz of fixed
width, i.e., a gangbangin' fixed number of charactas long.  Thus
\&\f(CW\*(C`(?<=(ab|bc))\*(C'\fR is fine yo, but \f(CW\*(C`(?<=(ab)*)\*(C'\fR is not.  The
negated versionz of tha lookahead n' lookbehind assertions are
denoted by \f(CW\*(C`(?!regexp)\*(C'\fR n' \f(CW\*(C`(?<!fixed\-regexp)\*(C'\fR respectively.
They evaluate legit if tha regexps do \fInot\fR match:
.PP
.Vb 4
\&    $x = "foobar";
\&    $x =~ /foo(?!bar)/;  # don\*(Aqt match, \*(Aqbar\*(Aq bigs up \*(Aqfoo\*(Aq
\&    $x =~ /foo(?!baz)/;  # matches, \*(Aqbaz\*(Aq don\*(Aqt follow \*(Aqfoo\*(Aq
\&    $x =~ /(?<!\es)foo/;  # matches, there is no \es before \*(Aqfoo\*(Aq
.Ve
.PP
Da \f(CW\*(C`\eC\*(C'\fR is unsupported up in lookbehind, cuz tha already
treacherous definizzle of \f(CW\*(C`\eC\*(C'\fR would become even mo' so
when goin backwards.
.PP
Here be a example where a strang containin blank-separated lyrics,
numbers n' single dashes is ta be split tha fuck into its components.
Usin \f(CW\*(C`/\es+/\*(C'\fR ridin' solo won't work, cuz spaces is not required between
dashes, or a word or a thugged-out dash fo' realz. Additionizzle places fo' a split is established
by lookin ahead n' behind:
.PP
.Vb 5
\&    $str = "one two \- \-\-6\-8";
\&    @toks = split / \es+              # a run of spaces
\&                  | (?<=\eS) (?=\-)    # any non\-space followed by \*(Aq\-\*(Aq
\&                  | (?<=\-)  (?=\eS)   # a \*(Aq\-\*(Aq followed by any non\-space
\&                  /x, $str;          # @toks = qw(one two \- \- \- 6 \- 8)
.Ve
.SS "Usin independent subexpressions ta prevent backtracking"
.IX Subsection "Usin independent subexpressions ta prevent backtracking"
\&\fIIndependent subexpressions\fR is regular expressions, up in the
context of a larger regular expression, dat function independently of
the larger regular expression. I aint talkin' bout chicken n' gravy biatch.  That is, they consume as much or as
lil of tha strang as they wish without regard fo' tha mobilitizzle of
the larger regexp ta match.  Independent subexpressions is represented
by \f(CW\*(C`(?>regexp)\*(C'\fR.  We can illustrate they behavior by first
thankin bout a ordinary regexp:
.PP
.Vb 2
\&    $x = "ab";
\&    $x =~ /a*ab/;  # matches
.Ve
.PP
This obviously matches yo, but up in tha process of matching, the
subexpression \f(CW\*(C`a*\*(C'\fR first grabbed tha \f(CW\*(C`a\*(C'\fR.  Bustin so, however,
wouldn't allow tha whole regexp ta match, so afta backtracking, \f(CW\*(C`a*\*(C'\fR
eventually gave back tha \f(CW\*(C`a\*(C'\fR n' matched tha empty string.  Here, what
\&\f(CW\*(C`a*\*(C'\fR matched was \fIdependent\fR on what tha fuck tha rest of tha regexp matched.
.PP
Contrast dat wit a independent subexpression:
.PP
.Vb 1
\&    $x =~ /(?>a*)ab/;  # don\*(Aqt match!
.Ve
.PP
Da independent subexpression \f(CW\*(C`(?>a*)\*(C'\fR don't care bout tha rest
of tha regexp, so it sees a \f(CW\*(C`a\*(C'\fR n' grabs dat shit.  Then tha rest of the
regexp \f(CW\*(C`ab\*(C'\fR cannot match.  Because \f(CW\*(C`(?>a*)\*(C'\fR is independent, there
is no backtrackin n' tha independent subexpression do not give
up its \f(CW\*(C`a\*(C'\fR.  Thus tha match of tha regexp as a whole fails.  A similar
behavior occurs wit straight-up independent regexps:
.PP
.Vb 3
\&    $x = "ab";
\&    $x =~ /a*/g;   # matches, smokes a \*(Aqa\*(Aq
\&    $x =~ /\eGab/g; # don\*(Aqt match, no \*(Aqa\*(Aq available
.Ve
.PP
Here \f(CW\*(C`//g\*(C'\fR n' \f(CW\*(C`\eG\*(C'\fR create a 'tag crew' handoff of tha strang from
one regexp ta tha other n' shit.  Regexps wit a independent subexpression are
much like this, wit a handoff of tha strang ta tha independent
subexpression, n' a handoff of tha strang back ta tha enclosing
regexp.
.PP
Da mobilitizzle of a independent subexpression ta prevent backtracking
can be like useful naaahhmean, biatch?  Suppose we wanna match a non-empty string
enclosed up in parentheses up ta two levels deep.  Then tha following
regexp matches:
.PP
.Vb 2
\&    $x = "abc(de(fg)h";  # unbalanced parentheses
\&    $x =~ /\e( ( [^()]+ | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
Da regexp matches a open parenthesis, one or mo' copiez of an
alternation, n' a cold-ass lil close parenthesis.  Da alternation is two-way, with
the first alternatizzle \f(CW\*(C`[^()]+\*(C'\fR matchin a substrin wit no
parentheses n' tha second alternatizzle \f(CW\*(C`\e([^()]*\e)\*(C'\fR  matchin a
substrin delimited by parentheses.  Da problem wit dis regexp is
that it is pathological: it has nested indeterminizzle quantifiers
of tha form \f(CW\*(C`(a+|b)+\*(C'\fR.  Us dudes discussed up in Part 1 how tha fuck nested quantifiers
like dis could take a exponentially long time ta execute if there
was no match possible.  To prevent tha exponential blowup, we need to
prevent useless backtrackin at some point.  This can be done by
enclosin tha inner quantifier as a independent subexpression:
.PP
.Vb 1
\&    $x =~ /\e( ( (?>[^()]+) | \e([^()]*\e) )+ \e)/x;
.Ve
.PP
Here, \f(CW\*(C`(?>[^()]+)\*(C'\fR breaks tha degeneracy of strang partitioning
by gobblin up as much of tha strang as possible n' keepin dat shit.   Then
match failures fail much mo' doggystyle.
.SS "Conditionizzle expressions"
.IX Subsection "Conditionizzle expressions"
A \fIconditionizzle expression\fR be a gangbangin' form of if-then-else statement
that allows one ta chizzle which patterns is ta be matched, based on
some condition. I aint talkin' bout chicken n' gravy biatch.  There is two typez of conditionizzle expression:
\&\f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR and
\&\f(CW\*(C`(?(condition)yes\-regexp|no\-regexp)\*(C'\fR.  \f(CW\*(C`(?(condition)yes\-regexp)\*(C'\fR is
like a \f(CW\*(Aqif\ ()\ {}\*(Aq\fR statement up in Perl.  If tha \f(CW\*(C`condition\*(C'\fR is true,
the \f(CW\*(C`yes\-regexp\*(C'\fR is ghon be matched. Y'all KNOW dat shit, muthafucka!  If tha \f(CW\*(C`condition\*(C'\fR is false, the
\&\f(CW\*(C`yes\-regexp\*(C'\fR is ghon be skipped n' Perl will move onto tha next regexp
element.  Da second form is like a \f(CW\*(Aqif\ ()\ {}\ else\ {}\*(Aq\fR statement
in Perl.  If tha \f(CW\*(C`condition\*(C'\fR is true, tha \f(CW\*(C`yes\-regexp\*(C'\fR will be
matched, otherwise tha \f(CW\*(C`no\-regexp\*(C'\fR is ghon be matched.
.PP
Da \f(CW\*(C`condition\*(C'\fR can have nuff muthafuckin forms.  Da first form is simply an
integer up in parentheses \f(CW\*(C`(integer)\*(C'\fR.  It be legit if tha corresponding
backreference \f(CW\*(C`\einteger\*(C'\fR matched earlier up in tha regexp.  Da same
thang can be done wit a name associated wit a cold-ass lil capture group, written
as \f(CW\*(C`(<name>)\*(C'\fR or \f(CW\*(C`(\*(Aqname\*(Aq)\*(C'\fR.  Da second form be a funky-ass bare
zero-width assertion \f(CW\*(C`(?...)\*(C'\fR, either a lookahead, a lookbehind, or a
code assertion (discussed up in tha next section).  Da third set of forms
provides tests dat return legit if tha expression is executed within
a recursion (\f(CW\*(C`(R)\*(C'\fR) or is bein called from some capturin group,
referenced either by number (\f(CW\*(C`(R1)\*(C'\fR, \f(CW\*(C`(R2)\*(C'\fR,...) or by name
(\f(CW\*(C`(R&name)\*(C'\fR).
.PP
Da integer or name form of tha \f(CW\*(C`condition\*(C'\fR allows our asses ta chizzle,
with mo' flexibility, what tha fuck ta match based on what tha fuck matched earlier up in the
regexp. This searches fo' lyrics of tha form \f(CW"$x$x"\fR or \f(CW"$x$y$y$x"\fR:
.PP
.Vb 9
\&    % simple_grep \*(Aq^(\ew+)(\ew+)?(?(2)\eg2\eg1|\eg1)$\*(Aq /usr/dict/words
\&    beriberi
\&    coco
\&    couscous
\&    deed
\&    ...
\&    toot
\&    toto
\&    tutu
.Ve
.PP
Da lookbehind \f(CW\*(C`condition\*(C'\fR allows, along wit backreferences,
an earlier part of tha match ta influence a lata part of the
match.  For instance,
.PP
.Vb 1
\&    /[ATGC]+(?(?<=AA)G|C)$/;
.Ve
.PP
matches a \s-1DNA\s0 sequence such dat it either endz up in \f(CW\*(C`AAG\*(C'\fR, or some
other base pair combination n' \f(CW\*(C`C\*(C'\fR.  Note dat tha form is
\&\f(CW\*(C`(?(?<=AA)G|C)\*(C'\fR n' not \f(CW\*(C`(?((?<=AA))G|C)\*(C'\fR; fo' the
lookahead, lookbehind or code assertions, tha parentheses round the
conditionizzle is not needed.
.SS "Definin named patterns"
.IX Subsection "Definin named patterns"
Some regular expressions use identical subpatterns up in nuff muthafuckin places.
Startin wit Perl 5.10, it is possible ta define named subpatterns in
a section of tha pattern so dat they can be called up by name
anywhere up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This syntactic pattern fo' dis definition
group is \f(CW\*(C`(?(DEFINE)(?<name>pattern)...)\*(C'\fR.  An insertion
of a named pattern is freestyled as \f(CW\*(C`(?&name)\*(C'\fR.
.PP
Da example below illustrates dis feature rockin tha pattern for
floatin point numbers dat was presented earlier on. I aint talkin' bout chicken n' gravy biatch.  Da three
subpatterns dat is used mo' than once is tha optionizzle sign, the
digit sequence fo' a integer n' tha decimal fraction. I aint talkin' bout chicken n' gravy biatch.  Da \s-1DEFINE\s0
group all up in tha end of tha pattern gotz nuff they definition. I aint talkin' bout chicken n' gravy biatch.  Notice
that tha decimal fraction pattern is tha straight-up original gangsta place where we can
reuse tha integer pattern.
.PP
.Vb 8
\&   /^ (?&osg)\e * ( (?&int)(?&dec), biatch? | (?&dec) )
\&      (?: [eE](?&osg)(?&int) )?
\&    $
\&    (?(DEFINE)
\&      (?<osg>[\-+]?)         # optionizzle sign
\&      (?<int>\ed++)          # integer
\&      (?<dec>\e.(?&int))     # decimal fraction
\&    )/x
.Ve
.SS "Recursive patterns"
.IX Subsection "Recursive patterns"
This feature (introduced up in Perl 5.10) hella extendz the
power of Perlz pattern matching.  By referrin ta some other
capture crew anywhere up in tha pattern wit tha construct
\&\f(CW\*(C`(?group\-ref)\*(C'\fR, tha \fIpattern\fR within tha referenced crew is used
as a independent subpattern up in place of tha crew reference itself.
Because tha crew reference may be contained \fIwithin\fR tha crew it
refers to, it is now possible ta apply pattern matchin ta tasks that
hitherto required a recursive parser.
.PP
To illustrate dis feature, we'll design a pattern dat matches if
a strang gotz nuff a palindrome. (This be a word or a sentence that,
while ignorin spaces, interpunctuation n' case, readz tha same ol' dirty backwards
as forwards. We begin by observin dat tha empty strang or a string
containin just one word characta be a palindrome. Otherwise it must
have a word characta up front n' tha same at its end, wit another
palindrome up in between.
.PP
.Vb 1
\&    /(?: (\ew) (?...Here be a palindrome...) \eg{\-1} | \ew, biatch? )/x
.Ve
.PP
Addin \f(CW\*(C`\eW*\*(C'\fR at either end ta eliminizzle what tha fuck is ta be ignored, we already
have tha full pattern:
.PP
.Vb 4
\&    mah $pp = qr/^(\eW* (?: (\ew) (?1) \eg{\-1} | \ew, biatch? ) \eW*)$/ix;
\&    fo' $s ( "saippuakauppias", "A dude, a plan, a cold-ass lil canal: Panama!" ){
\&        print "\*(Aq$s\*(Aq be a palindrome\en" if $s =~ /$pp/;
\&    }
.Ve
.PP
In \f(CW\*(C`(?...)\*(C'\fR both absolute n' relatizzle backreferences may be used.
Da entire pattern can be reinserted wit \f(CW\*(C`(?R)\*(C'\fR or \f(CW\*(C`(?0)\*(C'\fR.
If you prefer ta name yo' groups, you can use \f(CW\*(C`(?&name)\*(C'\fR to
recurse tha fuck into dat group.
.SS "A bit of magic: executin Perl code up in a regular expression"
.IX Subsection "A bit of magic: executin Perl code up in a regular expression"
Normally, regexps is a part of Perl expressions.
\&\fICode evaluation\fR expressions turn dat round by allowing
arbitrary Perl code ta be a part of a regexp.  A code evaluation
expression is denoted \f(CW\*(C`(?{code})\*(C'\fR, wit \fIcode\fR a strang of Perl
statements.
.PP
Be warned dat dis feature is considered experimental, n' may be
changed without notice.
.PP
Code expressions is zero-width assertions, n' tha value they return
dependz on they environment.  There is two possibilities: either the
code expression is used as a cold-ass lil conditionizzle up in a cold-ass lil conditionizzle expression
\&\f(CW\*(C`(?(condition)...)\*(C'\fR, or it is not.  If tha code expression be a
conditional, tha code is evaluated n' tha result (i.e., tha result of
the last statement) is used ta determine truth or falsehood. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  If the
code expression aint used as a cold-ass lil conditional, tha assertion always
evaluates legit n' tha result is put tha fuck into tha special variable
\&\f(CW$^R\fR.  Da variable \f(CW$^R\fR can then be used up in code expressions later
in tha regexp.  Here is some wack-ass examples:
.PP
.Vb 5
\&    $x = "abcdef";
\&    $x =~ /abc(?{print "Yo Mom!";})def/; # matches,
\&                                         # prints \*(AqYo Mom!\*(Aq
\&    $x =~ /aaa(?{print "Yo Mom!";})def/; # don\*(Aqt match,
\&                                         # no \*(AqYo Mom!\*(Aq
.Ve
.PP
Pay careful attention ta tha next example:
.PP
.Vb 3
\&    $x =~ /abc(?{print "Yo Mom!";})ddd/; # don\*(Aqt match,
\&                                         # no \*(AqYo Mom!\*(Aq
\&                                         # but why not?
.Ve
.PP
At first glance, you'd be thinkin dat it shouldn't print, cuz obviously
the \f(CW\*(C`ddd\*(C'\fR aint goin ta match tha target string. But peep this
example:
.PP
.Vb 2
\&    $x =~ /abc(?{print "Yo Mom!";})[dD]dd/; # don\*(Aqt match,
\&                                            # but _does_ print
.Ve
.PP
Hmm. What happened here, biatch? If you've been followin along, you know that
the above pattern should be effectively (almost) tha same as tha last one;
enclosin tha \f(CW\*(C`d\*(C'\fR up in a cold-ass lil characta class aint goin ta chizzle what tha fuck it
matches. Right back up in yo muthafuckin ass. So why do tha straight-up original gangsta not print while tha second one do?
.PP
Da answer lies up in tha optimizations tha regex engine makes. In tha first
case, all tha engine sees is plain oldschool charactas (aside from the
\&\f(CW\*(C`?{}\*(C'\fR construct). It aint nuthin but smart-ass enough ta realize dat tha strang 'ddd'
doesn't occur up in our target strang before straight-up hustlin tha pattern
all up in cause I gots dem finger-lickin' chickens wit tha siz-auce. But up in tha second case, we've tricked it tha fuck into thankin dat our
pattern is mo' fucked up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Well shiiiit, it takes a look, sees our
characta class, n' decides dat it will gotta straight-up run the
pattern ta determine whether or not it matches, n' up in tha process of
runnin it hits tha print statement before it discovers dat our phat asses don't
have a match.
.PP
To take a cold-ass lil closer peep how tha fuck tha engine do optimizations, peep the
section \*(L"Pragmas n' debugging\*(R" below.
.PP
Mo' funk wit \f(CW\*(C`?{}\*(C'\fR:
.PP
.Vb 6
\&    $x =~ /(?{print "Yo Mom!";})/;       # matches,
\&                                         # prints \*(AqYo Mom!\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$c";})/;  # matches,
\&                                           # prints \*(Aq1\*(Aq
\&    $x =~ /(?{$c = 1;})(?{print "$^R";})/; # matches,
\&                                           # prints \*(Aq1\*(Aq
.Ve
.PP
Da bit of magic mentioned up in tha section title occurs when tha regexp
backtracks up in tha process of searchin fo' a match.  If tha regexp
backtracks over a cold-ass lil code expression n' if tha variablez used within are
localized rockin \f(CW\*(C`local\*(C'\fR, tha chizzlez up in tha variablez produced by the
code expression is undone biaaatch! Thus, if we wanted ta count how tha fuck nuff times
a characta gots matched inside a group, we could use, e.g.,
.PP
.Vb 11
\&    $x = "aaaa";
\&    $count = 0;  # initialize \*(Aqa\*(Aq count
\&    $c = "bob";  # test if $c gets clobbered
\&    $x =~ /(?{local $c = 0;})         # initialize count
\&           ( a                        # match \*(Aqa\*(Aq
\&             (?{local $c = $c + 1;})  # increment count
\&           )*                         # do dis any number of times,
\&           aa                         # but match \*(Aqaa\*(Aq all up in tha end
\&           (?{$count = $c;})          # copy local $c var tha fuck into $count
\&          /x;
\&    print "\*(Aqa\*(Aq count is $count, \e$c variable is \*(Aq$c\*(Aq\en";
.Ve
.PP
This prints
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 2, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
If we replace tha \f(CW\*(C`\ (?{local\ $c\ =\ $c\ +\ 1;})\*(C'\fR with
\&\f(CW\*(C`\ (?{$c\ =\ $c\ +\ 1;})\*(C'\fR, tha variable chizzlez is \fInot\fR undone
durin backtracking, n' we get
.PP
.Vb 1
\&    \*(Aqa\*(Aq count is 4, $c variable is \*(Aqbob\*(Aq
.Ve
.PP
Note dat only localized variable chizzlez is undone.  Other side
effectz of code expression execution is permanent.  Thus
.PP
.Vb 2
\&    $x = "aaaa";
\&    $x =~ /(a(?{print "Yow\en";}))*aa/;
.Ve
.PP
produces
.PP
.Vb 4
\&   Yow
\&   Yow
\&   Yow
\&   Yow
.Ve
.PP
Da result \f(CW$^R\fR be automatically localized, so dat it will behave
properly up in tha presence of backtracking.
.PP
This example uses a cold-ass lil code expression up in a cold-ass lil conditionizzle ta match a
definite article, either 'the' up in Gangsta or 'der|die|das' up in German:
.PP
.Vb 11
\&    $lang = \*(AqDE\*(Aq;  # use German
\&    ...
\&    $text = "das";
\&    print "matched\en"
\&        if $text =~ /(?(?{
\&                          $lang eq \*(AqEN\*(Aq; # is tha language Gangsta?
\&                         })
\&                       tha |             # if so, then match \*(Aqthe\*(Aq
\&                       (der|die|das)     # else, match \*(Aqder|die|das\*(Aq
\&                     )
\&                    /xi;
.Ve
.PP
Note dat tha syntax here is \f(CW\*(C`(?(?{...})yes\-regexp|no\-regexp)\*(C'\fR, not
\&\f(CW\*(C`(?((?{...}))yes\-regexp|no\-regexp)\*(C'\fR.  In other lyrics, up in tha case of a
code expression, our phat asses don't need tha extra parentheses round the
conditional.
.PP
If you try ta use code expressions where tha code text is contained within
an interpolated variable, rather than appearin literally up in tha pattern,
Perl may surprise you:
.PP
.Vb 5
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo(?{ $bar })bar/; # compilez ok, $bar not interpolated
\&    /foo(?{ 1 })$bar/;   # compilez ok, $bar interpolated
\&    /foo${pat}bar/;      # compile error!
\&
\&    $pat = qr/(?{ $foo = 1 })/;  # precompile code regexp
\&    /foo${pat}bar/;      # compilez ok
.Ve
.PP
If a regexp has a variable dat interpolates a cold-ass lil code expression, Perl
treats tha regexp as a error. Shiiit, dis aint no joke. If tha code expression is precompiled into
a variable, however, interpolatin is ok. Da question is, why is dis an
error?
.PP
Da reason is dat variable interpolation n' code expressions
together pose a securitizzle risk.  Da combination is fucked up cuz
many programmers whoz ass write search engines often take user input and
plug it directly tha fuck into a regexp:
.PP
.Vb 3
\&    $regexp = <>;       # read user\-supplied regexp
\&    $chomp $regexp;     # git rid of possible newline
\&    $text =~ /$regexp/; # search $text fo' tha $regexp
.Ve
.PP
If tha \f(CW$regexp\fR variable gotz nuff a cold-ass lil code expression, tha user could
then execute arbitrary Perl code.  For instance, some joker could
search fo' \f(CW\*(C`system(\*(Aqrm\ \-rf\ *\*(Aq);\*(C'\fR ta erase yo' files.  In this
sense, tha combination of interpolation n' code expressions \fItaints\fR
your regexp.  So by default, rockin both interpolation n' code
expressions up in tha same regexp aint allowed. Y'all KNOW dat shit, muthafucka!  If you not
concerned bout malicious users, it is possible ta bypass this
securitizzle check by invokin \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq\*(C'\fR:
.PP
.Vb 4
\&    use re \*(Aqeval\*(Aq;       # throw caution up tha door
\&    $bar = 5;
\&    $pat = \*(Aq(?{ 1 })\*(Aq;
\&    /foo${pat}bar/;      # compilez ok
.Ve
.PP
Another form of code expression is tha \fIpattern code expression\fR.
Da pattern code expression is like a regular code expression, except
that tha result of tha code evaluation is treated as a regular
expression n' matched immediately.  A simple example is
.PP
.Vb 4
\&    $length = 5;
\&    $char = \*(Aqa\*(Aq;
\&    $x = \*(Aqaaaaabb\*(Aq;
\&    $x =~ /(??{$char x $length})/x; # matches, there be 5 of \*(Aqa\*(Aq
.Ve
.PP
This final example gotz nuff both ordinary n' pattern code
expressions.  It detects whether a funky-ass binary strang \f(CW1101010010001...\fR has a
Fibonacci spacin 0,1,1,2,3,5,...  of tha \f(CW1\fR's:
.PP
.Vb 12
\&    $x = "1101010010001000001";
\&    $z0 = \*(Aq\*(Aq; $z1 = \*(Aq0\*(Aq;   # initial conditions
\&    print "It be a Fibonacci sequence\en"
\&        if $x =~ /^1         # match a initial \*(Aq1\*(Aq
\&                    (?:
\&                       ((??{ $z0 })) # match some \*(Aq0\*(Aq
\&                       1             # n' then a \*(Aq1\*(Aq
\&                       (?{ $z0 = $z1; $z1 .= $^N; })
\&                    )+   # repeat as needed
\&                  $      # dat be all there is
\&                 /x;
\&    printf "Largest sequence matched was %d\en", length($z1)\-length($z0);
.Ve
.PP
Remember dat \f(CW$^N\fR is set ta whatever was matched by tha last
completed capture group. This prints
.PP
.Vb 2
\&    It be a Fibonacci sequence
\&    Largest sequence matched was 5
.Ve
.PP
Ha! Try dat wit yo' garden variety regexp package...
.PP
Note dat tha variablez \f(CW$z0\fR n' \f(CW$z1\fR is not substituted when the
regexp is compiled, as happens fo' ordinary variablez outside a cold-ass lil code
expression. I aint talkin' bout chicken n' gravy biatch.  Rather, tha whole code block is parsed as perl code at the
same time as perl is compilin tha code containin tha literal regexp
pattern.
.PP
Da regexp without tha \f(CW\*(C`//x\*(C'\fR modifier is
.PP
.Vb 1
\&    /^1(?:((??{ $z0 }))1(?{ $z0 = $z1; $z1 .= $^N; }))+$/
.Ve
.PP
which shows dat spaces is still possible up in tha code parts, n' you can put dat on yo' toast. Nevertheless,
when hustlin wit code n' conditionizzle expressions, tha extended form of
regexps be almost necessary up in bustin n' debuggin regexps.
.SS "Backtrackin control verbs"
.IX Subsection "Backtrackin control verbs"
Perl 5.10 introduced a fuckin shitload of control verbs intended ta provide
detailed control over tha backtrackin process, by directly influencing
the regexp engine n' by providin monitorin steez.  As all
the features up in dis crew is experimenstrual n' subject ta chizzle or
removal up in a gangbangin' future version of Perl, tha interested reader is
referred ta \*(L"Special Backtrackin Control Verbs\*(R" up in perlre fo' a
detailed description.
.PP
Below is just one example, illustratin tha control verb \f(CW\*(C`(*FAIL)\*(C'\fR,
which may be abbreviated as \f(CW\*(C`(*F)\*(C'\fR. If dis is banged up in a regexp
it will cause it ta fail, just as it would at some
mismatch between tha pattern n' tha string. Processing
of tha regexp continues as it would afta any \*(L"normal\*(R"
failure, so that, fo' instance, tha next posizzle up in tha strang or another
alternatizzle is ghon be tried. Y'all KNOW dat shit, muthafucka! As failin ta match don't preserve capture
groups or produce thangs up in dis biatch, it may be necessary ta use dis in
combination wit embedded code.
.PP
.Vb 4
\&   %count = ();
\&   "supercalifragilisticexpialidocious" =~
\&       /([aeiou])(?{ $count{$1}++; })(*FAIL)/i;
\&   printf "%3d \*(Aq%s\*(Aq\en", $count{$_}, $_ fo' (sort keys %count);
.Ve
.PP
Da pattern begins wit a cold-ass lil class matchin a subset of letters.  Whenever
this matches, a statement like \f(CW\*(C`$count{\*(Aqa\*(Aq}++;\*(C'\fR is executed, incrementing
the letterz counter n' shit. Then \f(CW\*(C`(*FAIL)\*(C'\fR do what tha fuck it says, and
the regexp engine proceedz accordin ta tha book: as long as tha end of
the strang aint been reached, tha posizzle be advanced before looking
for another vowel. Thus, match or no match make no difference, n' the
regexp engine proceedz until tha entire strang has been inspected.
(It aint nuthin but remarkable dat a alternatizzle solution rockin suttin' like
.PP
.Vb 2
\&   $count{lc($_)}++ fo' split(\*(Aq\*(Aq, "supercalifragilisticexpialidocious");
\&   printf "%3d \*(Aq%s\*(Aq\en", $count2{$_}, $_ fo' ( qw{ a e i o u } );
.Ve
.PP
is considerably slower.)
.SS "Pragmas n' debugging"
.IX Subsection "Pragmas n' debugging"
Speakin of debugging, there be nuff muthafuckin pragmas available ta control
and debug regexps up in Perl.  Our thugged-out asses have already encountered one pragma in
the previous section, \f(CW\*(C`use\ re\ \*(Aqeval\*(Aq;\*(C'\fR, dat allows variable
interpolation n' code expressions ta coexist up in a regexp.  Da other
pragmas are
.PP
.Vb 3
\&    use re \*(Aqtaint\*(Aq;
\&    $tainted = <>;
\&    @parts = ($tainted =~ /(\ew+)\es+(\ew+)/; # @parts is now tainted
.Ve
.PP
Da \f(CW\*(C`taint\*(C'\fR pragma causes any substrings from a match wit a tainted
variable ta be tainted as well.  This aint normally tha case, as
regexps is often used ta extract tha safe bits from a tainted
variable.  Use \f(CW\*(C`taint\*(C'\fR when yo ass is not extractin safe bits yo, but are
performin some other processing.  Both \f(CW\*(C`taint\*(C'\fR n' \f(CW\*(C`eval\*(C'\fR pragmas
are lexically scoped, which means they is up in effect only until
the end of tha block enclosin tha pragmas.
.PP
.Vb 2
\&    use re \*(Aq/m\*(Aq;  # or any other flags
\&    $multiline_strin =~ /^foo/; # /m is implied
.Ve
.PP
Da \f(CW\*(C`re \*(Aq/flags\*(Aq\*(C'\fR pragma (introduced up in Perl
5.14) turns on tha given regular expression flags
until tha end of tha lexical scope.  See
\&\*(L"'/flags' mode\*(R" up in re fo' more
detail.
.PP
.Vb 2
\&    use re \*(Aqdebug\*(Aq;
\&    /^(.*)$/s;       # output debuggin info
\&
\&    use re \*(Aqdebugcolor\*(Aq;
\&    /^(.*)$/s;       # output debuggin info up in livin color
.Ve
.PP
Da global \f(CW\*(C`debug\*(C'\fR n' \f(CW\*(C`debugcolor\*(C'\fR pragmas allow one ta get
detailed debuggin info bout regexp compilation and
execution. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`debugcolor\*(C'\fR is tha same ol' dirty as debug, except tha debugging
information is displayed up in color on terminals dat can display
termcap color sequences.  Here is example output:
.PP
.Vb 10
\&    % perl \-e \*(Aquse re "debug"; "abc" =~ /a*b+c/;\*(Aq
\&    Compilin REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
\&    floatin \*(Aqbc\*(Aq at 0..2147483647 (checkin floating) minlen 2
\&    Guessin start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floatin substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
\&    Matchin REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Settin a EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times outta 32767...
\&      Settin a EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times outta 32767...
\&      Settin a EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freein REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
If you have gotten dis far tha fuck into tha tutorial, you can probably guess
what tha different partz of tha debuggin output tell yo thugged-out ass.  Da first
part
.PP
.Vb 8
\&    Compilin REx \*(Aqa*b+c\*(Aq
\&    size 9 first at 1
\&       1: STAR(4)
\&       2:   EXACT <a>(0)
\&       4: PLUS(7)
\&       5:   EXACT <b>(0)
\&       7: EXACT <c>(9)
\&       9: END(0)
.Ve
.PP
raps bout tha compilation stage.  \f(CWSTAR(4)\fR means dat there be a
starred object, up in dis case \f(CW\*(Aqa\*(Aq\fR, n' if it matches, goto line 4,
i.e., \f(CWPLUS(7)\fR.  Da middle lines describe some heuristics and
optimizations performed before a match:
.PP
.Vb 4
\&    floatin \*(Aqbc\*(Aq at 0..2147483647 (checkin floating) minlen 2
\&    Guessin start of match, REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq...
\&    Found floatin substr \*(Aqbc\*(Aq at offset 1...
\&    Guessed: match at offset 0
.Ve
.PP
Then tha match is executed n' tha remainin lines describe the
process:
.PP
.Vb 12
\&    Matchin REx \*(Aqa*b+c\*(Aq against \*(Aqabc\*(Aq
\&      Settin a EVAL scope, savestack=3
\&       0 <> <abc>             |  1:  STAR
\&                               EXACT <a> can match 1 times outta 32767...
\&      Settin a EVAL scope, savestack=3
\&       1 <a> <bc>             |  4:    PLUS
\&                               EXACT <b> can match 1 times outta 32767...
\&      Settin a EVAL scope, savestack=3
\&       2 <ab> <c>             |  7:      EXACT <c>
\&       3 <abc> <>             |  9:      END
\&    Match successful!
\&    Freein REx: \*(Aqa*b+c\*(Aq
.Ve
.PP
Each step iz of tha form \f(CW\*(C`n\ <x>\ <y>\*(C'\fR, wit \f(CW\*(C`<x>\*(C'\fR the
part of tha strang matched n' \f(CW\*(C`<y>\*(C'\fR tha part not yet
matched. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`|\ \ 1:\ \ STAR\*(C'\fR say dat Perl be at line number 1
in tha compilation list above.  See
\&\*(L"Debuggin Regular Expressions\*(R" up in perldebguts fo' much mo' detail.
.PP
An alternatizzle method of debuggin regexps is ta embed \f(CW\*(C`print\*(C'\fR
statements within tha regexp.  This serves up a funky-ass blow-by-blow account of
the backtrackin up in a alternation:
.PP
.Vb 12
\&    "that this" =~ m@(?{print "Start at posizzle ", pos, "\en";})
\&                     t(?{print "t1\en";})
\&                     h(?{print "h1\en";})
\&                     i(?{print "i1\en";})
\&                     s(?{print "s1\en";})
\&                         |
\&                     t(?{print "t2\en";})
\&                     h(?{print "h2\en";})
\&                     a(?{print "a2\en";})
\&                     t(?{print "t2\en";})
\&                     (?{print "Done at posizzle ", pos, "\en";})
\&                    @x;
.Ve
.PP
prints
.PP
.Vb 8
\&    Start at posizzle 0
\&    t1
\&    h1
\&    t2
\&    h2
\&    a2
\&    t2
\&    Done at posizzle 4
.Ve
.SH "BUGS"
.IX Header "BUGS"
Code expressions, conditionizzle expressions, n' independent expressions
are \fIexperimental\fR.  Don't use dem up in thang code.  Yet.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This is just a tutorial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  For tha full rap on Perl regular
expressions, peep tha perlre regular expressions reference page.
.PP
For mo' shiznit on tha matchin \f(CW\*(C`m//\*(C'\fR n' substitution \f(CW\*(C`s///\*(C'\fR
operators, peep \*(L"Regexp Quote-Like Operators\*(R" up in perlop.  For
information on tha \f(CW\*(C`split\*(C'\fR operation, peep \*(L"split\*(R" up in perlfunc.
.PP
For a pimpin all-around resource on tha care n' feedin of
regular expressions, peep tha book \fIMasterin Regular Expressions\fR by
Jeffrey Friedl (published by O'Reilly, \s-1ISBN 1556592\-257\-3\s0).
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 2000 Mark Kvale
All muthafuckin rights reserved.
.PP
This document may be distributed under tha same terms as Perl itself.
.SS "Acknowledgments"
.IX Subsection "Acknowledgments"
Da inspiration fo' tha stop codon \s-1DNA\s0 example came from tha \s-1ZIP\s0
code example up in chapta 7 of \fIMasterin Regular Expressions\fR.
.PP
Da lyricist wanna give props ta Jeff Pinyan, Andrew Johnson, Peter
Haworth, Ronald J Kimball, n' Joe Smizzle fo' all they helpful
comments.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 643:" 4
.IX Item "Around line 643:"
Expected text afta =item, not a number
.IP "Around line 647:" 4
.IX Item "Around line 647:"
Expected text afta =item, not a number
.IP "Around line 651:" 4
.IX Item "Around line 651:"
Expected text afta =item, not a number
.IP "Around line 657:" 4
.IX Item "Around line 657:"
Expected text afta =item, not a number
.IP "Around line 662:" 4
.IX Item "Around line 662:"
Expected text afta =item, not a number
.IP "Around line 667:" 4
.IX Item "Around line 667:"
Expected text afta =item, not a number
.IP "Around line 671:" 4
.IX Item "Around line 671:"
Expected text afta =item, not a number
.IP "Around line 677:" 4
.IX Item "Around line 677:"
Expected text afta =item, not a number
.IP "Around line 682:" 4
.IX Item "Around line 682:"
Expected text afta =item, not a number
.IP "Around line 1250:" 4
.IX Item "Around line 1250:"
Expected text afta =item, not a number
.IP "Around line 1255:" 4
.IX Item "Around line 1255:"
Expected text afta =item, not a number
.IP "Around line 1260:" 4
.IX Item "Around line 1260:"
Expected text afta =item, not a number
.IP "Around line 1265:" 4
.IX Item "Around line 1265:"
Expected text afta =item, not a number
.IP "Around line 1269:" 4
.IX Item "Around line 1269:"
Expected text afta =item, not a number
.IP "Around line 1274:" 4
.IX Item "Around line 1274:"
Expected text afta =item, not a number
