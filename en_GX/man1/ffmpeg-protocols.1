.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG-PROTOCOLS 1"
.TH FFMPEG-PROTOCOLS 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg\-protocols \- FFmpeg protocols
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout tha input n' output protocols provided by the
libavformat library.
.SH "PROTOCOLS"
.IX Header "PROTOCOLS"
Protocols is configured elements up in FFmpeg dat enable access to
resources dat require specific protocols.
.PP
When you configure yo' FFmpeg build, all tha supported protocols are
enabled by default. Yo ass can list all available ones rockin the
configure option \*(L"\-\-list\-protocols\*(R".
.PP
Yo ass can disable all tha protocols rockin tha configure option
\&\*(L"\-\-disable\-protocols\*(R", n' selectively enable a protocol rockin the
option "\-\-enable\-protocol=\fI\s-1PROTOCOL\s0\fR\*(L", or you can disable a
particular protocol rockin tha option
\&\*(R"\-\-disable\-protocol=\fI\s-1PROTOCOL\s0\fR".
.PP
Da option \*(L"\-protocols\*(R" of tha ff* tools will display tha list of
supported protocols.
.PP
A description of tha currently available protocols bigs up.
.SS "bluray"
.IX Subsection "bluray"
Read BluRay playlist.
.PP
Da accepted options are:
.IP "\fBangle\fR" 4
.IX Item "angle"
BluRay angle
.IP "\fBchapter\fR" 4
.IX Item "chapter"
Start chapta (1...N)
.IP "\fBplaylist\fR" 4
.IX Item "playlist"
Playlist ta read (\s-1BDMV/PLAYLIST/\s0?????.mpls)
.PP
Examples:
.PP
Read longest playlist from BluRay mounted ta /mnt/bluray:
.PP
.Vb 1
\&        bluray:/mnt/bluray
.Ve
.PP
Read angle 2 of playlist 4 from BluRay mounted ta /mnt/bluray, start from chapta 2:
.PP
.Vb 1
\&        \-playlist 4 \-angle 2 \-chapta 2 bluray:/mnt/bluray
.Ve
.SS "cache"
.IX Subsection "cache"
Cachin wrapper fo' input stream.
.PP
Cache tha input stream ta temporary file. Well shiiiit, it brangs seekin capabilitizzle ta live streams.
.PP
.Vb 1
\&        cache:<URL>
.Ve
.SS "concat"
.IX Subsection "concat"
Physical concatenation protocol.
.PP
Allow ta read n' seek from nuff resource up in sequence as if they were
a unique resource.
.PP
A \s-1URL\s0 accepted by dis protocol has tha syntax:
.PP
.Vb 1
\&        concat:<URL1>|<URL2>|...|<URLN>
.Ve
.PP
where \fI\s-1URL1\s0\fR, \fI\s-1URL2\s0\fR, ..., \fI\s-1URLN\s0\fR is tha urlz of the
resource ta be concatenated, each one possibly specifyin a gangbangin' finger-lickin' distinct
protocol.
.PP
For example ta read a sequence of filez \fIsplit1.mpeg\fR,
\&\fIsplit2.mpeg\fR, \fIsplit3.mpeg\fR wit \fBffplay\fR use the
command:
.PP
.Vb 1
\&        ffplay concat:split1.mpeg\e|split2.mpeg\e|split3.mpeg
.Ve
.PP
Note dat you may need ta escape tha characta \*(L"|\*(R" which is special for
many shells.
.SS "crypto"
.IX Subsection "crypto"
AES-encrypted stream readin protocol.
.PP
Da accepted options are:
.IP "\fBkey\fR" 4
.IX Item "key"
Set tha \s-1AES\s0 decryption key binary block from given hexadecimal representation.
.IP "\fBiv\fR" 4
.IX Item "iv"
Set tha \s-1AES\s0 decryption initialization vector binary block from given hexadecimal representation.
.PP
Accepted \s-1URL\s0 formats:
.PP
.Vb 2
\&        crypto:<URL>
\&        crypto+<URL>
.Ve
.SS "data"
.IX Subsection "data"
Data in-line up in tha \s-1URI.\s0 See <\fBhttp://en.wikipedia.org/wiki/Data_URI_scheme\fR>.
.PP
For example, ta convert a \s-1GIF\s0 file given inline wit \fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-i "data:image/gif;base64,R0lGODdhCAAIAMIEAAAAAAAA//8AAP//AP///////////////ywAAAAACAAIAAADF0gEDLojDgdGiJdJqUX02iB4E8Q9jUMkADs=" smiley.png
.Ve
.SS "file"
.IX Subsection "file"
File access protocol.
.PP
Allow ta read from or read ta a gangbangin' file.
.PP
For example ta read from a gangbangin' file \fIinput.mpeg\fR wit \fBffmpeg\fR
use tha command:
.PP
.Vb 1
\&        ffmpeg \-i file:input.mpeg output.mpeg
.Ve
.PP
Da ff* tools default ta tha file protocol, dat be a resource
specified wit tha name \*(L"\s-1FILE\s0.mpeg\*(R" is interpreted as tha \s-1URL
\&\s0\*(L"file:FILE.mpeg\*(R".
.PP
This protocol accepts tha followin options:
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate existin filez on write, if set ta 1 fo' realz. A value of 0 prevents
truncating. Default value is 1.
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Set I/O operation maximum block size, up in bytes. Default value is
\&\f(CW\*(C`INT_MAX\*(C'\fR, which thangs up in dis biatch up in not limitin tha axed block size.
Settin dis value reasonably low improves user termination request erection
time, which is valuable fo' filez on slow medium.
.SS "ftp"
.IX Subsection "ftp"
\&\s-1FTP \s0(File Transfer Protocol).
.PP
Allow ta read from or write ta remote resources rockin \s-1FTP\s0 protocol.
.PP
Peepin syntax is required.
.PP
.Vb 1
\&        ftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg
.Ve
.PP
This protocol accepts tha followin options.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout is
not specified.
.IP "\fBftp-anonymous-password\fR" 4
.IX Item "ftp-anonymous-password"
Password used when login as anonymous user n' shit. Typically a e\-mail address
should be used.
.IP "\fBftp-write-seekable\fR" 4
.IX Item "ftp-write-seekable"
Control seekabilitizzle of connection durin encoding. If set ta 1 the
resource is supposed ta be seekable, if set ta 0 it be assumed not
to be seekable. Default value is 0.
.PP
\&\s-1NOTE:\s0 Protocol can be used as output yo, but it is recommended ta not do
it, unless special care is taken (tests, customized server configuration
etc.). Different \s-1FTP\s0 servers behave up in different way durin seek
operation. I aint talkin' bout chicken n' gravy biatch. ff* tools may produce incomplete content cuz of server limitations.
.SS "gopher"
.IX Subsection "gopher"
Gopher protocol.
.SS "hls"
.IX Subsection "hls"
Read Applez \s-1HTTP\s0 Live Streamin compliant segmented stream as
a uniform one. Da M3U8 playlists describin tha segments can be
remote \s-1HTTP\s0 resources or local files, accessed rockin tha standard
file protocol.
Da nested protocol is declared by specifying
"+\fIproto\fR" afta tha hls \s-1URI\s0 scheme name, where \fIproto\fR
is either \*(L"file\*(R" or \*(L"http\*(R".
.PP
.Vb 2
\&        hls+http://host/path/to/remote/resource.m3u8
\&        hls+file://path/to/local/resource.m3u8
.Ve
.PP
Usin dis protocol is discouraged \- tha hls demuxer should work
just as well (if not, please report tha issues) n' is mo' complete.
To use tha hls demuxer instead, simply use tha direct URLs ta the
m3u8 files.
.SS "http"
.IX Subsection "http"
\&\s-1HTTP \s0(Hyper Text Transfer Protocol).
.PP
This protocol accepts tha followin options.
.IP "\fBseekable\fR" 4
.IX Item "seekable"
Control seekabilitizzle of connection. I aint talkin' bout chicken n' gravy biatch. If set ta 1 tha resource is
supposed ta be seekable, if set ta 0 it be assumed not ta be seekable,
if set ta \-1 it will try ta autodetect if it is seekable. Default
value is \-1.
.IP "\fBchunked_post\fR" 4
.IX Item "chunked_post"
If set ta 1 use chunked transfer-encodin fo' posts, default is 1.
.IP "\fBheaders\fR" 4
.IX Item "headers"
Set custom \s-1HTTP\s0 headers, can override built up in default headers. The
value must be a strang encodin tha headers.
.IP "\fBcontent_type\fR" 4
.IX Item "content_type"
Force a cold-ass lil content type.
.IP "\fBuser-agent\fR" 4
.IX Item "user-agent"
Override User-Agent header n' shit. If not specified tha protocol will use a
strin describin tha libavformat build.
.IP "\fBmultiple_requests\fR" 4
.IX Item "multiple_requests"
Use persistent connections if set ta 1. By default it is 0.
.IP "\fBpost_data\fR" 4
.IX Item "post_data"
Set custom \s-1HTTP\s0 post data.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout is
not specified.
.IP "\fBmime_type\fR" 4
.IX Item "mime_type"
Set \s-1MIME\s0 type.
.IP "\fBicy\fR" 4
.IX Item "icy"
If set ta 1 request \s-1ICY \s0(SHOUTcast) metadata from tha server n' shit. If tha server
supports this, tha metadata has ta be retrieved by tha application by reading
the \fBicy_metadata_headers\fR n' \fBicy_metadata_packet\fR options.
Da default is 0.
.IP "\fBicy_metadata_headers\fR" 4
.IX Item "icy_metadata_headers"
If tha server supports \s-1ICY\s0 metadata, dis gotz nuff tha \s-1ICY\s0 specific \s-1HTTP\s0 reply
headers, separated wit newline characters.
.IP "\fBicy_metadata_packet\fR" 4
.IX Item "icy_metadata_packet"
If tha server supports \s-1ICY\s0 metadata, n' \fBicy\fR was set ta 1, this
gotz nuff tha last non-empty metadata packet busted by tha server.
.IP "\fBcookies\fR" 4
.IX Item "cookies"
Set tha dem scooby snacks ta be busted up in future requests, n' you can put dat on yo' toast. Da format of each cookie is the
same as tha value of a Set-Cookie \s-1HTTP\s0 response field. Y'all KNOW dat shit, muthafucka! Multiple dem scooby snacks can be
delimited by a newline character.
.PP
\fI\s-1HTTP\s0 Cookies\fR
.IX Subsection "HTTP Cookies"
.PP
Some \s-1HTTP\s0 requests is ghon be denied unless cookie joints is passed up in wit the
request. Da \fBcookies\fR option allows these dem scooby snacks ta be specified. Y'all KNOW dat shit, muthafucka! At
the straight-up least, each cookie must specify a value along wit a path n' domain.
\&\s-1HTTP\s0 requests dat match both tha domain n' path will automatically include the
cookie value up in tha \s-1HTTP\s0 Cookie header field. Y'all KNOW dat shit, muthafucka! Multiple dem scooby snacks can be delimited
by a newline.
.PP
Da required syntax ta play a stream specifyin a cold-ass lil cookie is:
.PP
.Vb 1
\&        ffplay \-cookies "nlqptid=nltid=tsn; path=/; domain=somedomain.com;" http://somedomain.com/somestream.m3u8
.Ve
.SS "mmst"
.IX Subsection "mmst"
\&\s-1MMS \s0(Microsizzlez Media Server) protocol over \s-1TCP.\s0
.SS "mmsh"
.IX Subsection "mmsh"
\&\s-1MMS \s0(Microsizzlez Media Server) protocol over \s-1HTTP.\s0
.PP
Da required syntax is:
.PP
.Vb 1
\&        mmsh://<server>[:<port>][/<app>][/<playpath>]
.Ve
.SS "md5"
.IX Subsection "md5"
\&\s-1MD5\s0 output protocol.
.PP
Computes tha \s-1MD5\s0 hash of tha data ta be written, n' on close writes
this ta tha designated output or stdout if none is specified. Y'all KNOW dat shit, muthafucka! Well shiiiit, it can
be used ta test muxers without freestylin a actual file.
.PP
Some examplez follow.
.PP
.Vb 2
\&        # Write tha MD5 hash of tha encoded AVI file ta tha file output.avi.md5.
\&        ffmpeg \-i input.flv \-f avi \-y md5:output.avi.md5
\&        
\&        # Write tha MD5 hash of tha encoded AVI file ta stdout.
\&        ffmpeg \-i input.flv \-f avi \-y md5:
.Ve
.PP
Note dat some formats (typically \s-1MOV\s0) require tha output protocol to
be seekable, so they will fail wit tha \s-1MD5\s0 output protocol.
.SS "pipe"
.IX Subsection "pipe"
\&\s-1UNIX\s0 pipe access protocol.
.PP
Allow ta read n' write from \s-1UNIX\s0 pipes.
.PP
Da accepted syntax is:
.PP
.Vb 1
\&        pipe:[<number>]
.Ve
.PP
\&\fInumber\fR is tha number correspondin ta tha file descriptor of the
pipe (e.g. 0 fo' stdin, 1 fo' stdout, 2 fo' stderr).  If \fInumber\fR
is not specified, by default tha stdout file descriptor is ghon be used
for writing, stdin fo' reading.
.PP
For example ta read from stdin wit \fBffmpeg\fR:
.PP
.Vb 3
\&        pussaaaaay test.wav | ffmpeg \-i pipe:0
\&        # ...this is tha same ol' dirty as...
\&        pussaaaaay test.wav | ffmpeg \-i pipe:
.Ve
.PP
For freestylin ta stdout wit \fBffmpeg\fR:
.PP
.Vb 3
\&        ffmpeg \-i test.wav \-f avi pipe:1 | pussaaaaay > test.avi
\&        # ...this is tha same ol' dirty as...
\&        ffmpeg \-i test.wav \-f avi pipe: | pussaaaaay > test.avi
.Ve
.PP
This protocol accepts tha followin options:
.IP "\fBblocksize\fR" 4
.IX Item "blocksize"
Set I/O operation maximum block size, up in bytes. Default value is
\&\f(CW\*(C`INT_MAX\*(C'\fR, which thangs up in dis biatch up in not limitin tha axed block size.
Settin dis value reasonably low improves user termination request erection
time, which is valuable if data transmission is slow.
.PP
Note dat some formats (typically \s-1MOV\s0), require tha output protocol to
be seekable, so they will fail wit tha pipe output protocol.
.SS "rtmp"
.IX Subsection "rtmp"
Real-Time Messagin Protocol.
.PP
Da Real-Time Messagin Protocol (\s-1RTMP\s0) is used fo' streamin multimedia
content across a \s-1TCP/IP\s0 network.
.PP
Da required syntax is:
.PP
.Vb 1
\&        rtmp://[<username>:<password>@]<server>[:<port>][/<app>][/<instance>][/<playpath>]
.Ve
.PP
Da accepted parametas are:
.IP "\fBusername\fR" 4
.IX Item "username"
An optionizzle username (mostly fo' publishing).
.IP "\fBpassword\fR" 4
.IX Item "password"
An optionizzle password (mostly fo' publishing).
.IP "\fBserver\fR" 4
.IX Item "server"
Da address of tha \s-1RTMP\s0 server.
.IP "\fBport\fR" 4
.IX Item "port"
Da number of tha \s-1TCP\s0 port ta use (by default is 1935).
.IP "\fBapp\fR" 4
.IX Item "app"
It be tha name of tha application ta access. Well shiiiit, it probably correspondz to
the path where tha application is installed on tha \s-1RTMP\s0 server
(e.g. \fI/ondemand/\fR, \fI/flash/live/\fR, etc.). Yo ass can override
the value parsed from tha \s-1URI\s0 all up in tha \f(CW\*(C`rtmp_app\*(C'\fR option, like a muthafucka.
.IP "\fBplaypath\fR" 4
.IX Item "playpath"
It be tha path or name of tha resource ta fuck wit reference ta the
application specified up in \fIapp\fR, may be prefixed by \*(L"mp4:\*(R". You
can override tha value parsed from tha \s-1URI\s0 all up in tha \f(CW\*(C`rtmp_playpath\*(C'\fR
option, like a muthafucka.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Act as a server, listenin fo' a incomin connection.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Maximum time ta wait fo' tha incomin connection. I aint talkin' bout chicken n' gravy biatch. Implies listen.
.PP
Additionally, tha followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBrtmp_app\fR" 4
.IX Item "rtmp_app"
Name of application ta connect on tha \s-1RTMP\s0 server n' shit. This option
overrides tha parameta specified up in tha \s-1URI.\s0
.IP "\fBrtmp_buffer\fR" 4
.IX Item "rtmp_buffer"
Set tha client buffer time up in milliseconds. Da default is 3000.
.IP "\fBrtmp_conn\fR" 4
.IX Item "rtmp_conn"
Extra arbitrary \s-1AMF\s0 connection parameters, parsed from a string,
e.g. like \f(CW\*(C`B:1 S:authMe O:1 NN:code:1.23 NS:flag:ok O:0\*(C'\fR.
Each value is prefixed by a single characta denotin tha type,
B fo' Boolean, N fo' number, S fo' string, O fo' object, or Z fo' null,
followed by a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch. For Booleans tha data must be either 0 or 1 for
\&\s-1FALSE\s0 or \s-1TRUE,\s0 respectively.  Likewise fo' Objects tha data must be 0 or
1 ta end or begin a object, respectively. Data shit up in subobjects may
be named, by prefixin tha type wit 'N' n' specifyin tha name before
the value (i.e. \f(CW\*(C`NB:myFlag:1\*(C'\fR). This option may be used multiple
times ta construct arbitrary \s-1AMF\s0 sequences.
.IP "\fBrtmp_flashver\fR" 4
.IX Item "rtmp_flashver"
Version of tha Flash plugin used ta run tha \s-1SWF\s0 playa n' shit. Da default
is \s-1LNX 9,0,124,2. \s0(When publishing, tha default is \s-1FMLE/3.0 \s0(compatible;
<libavformat version>).)
.IP "\fBrtmp_flush_interval\fR" 4
.IX Item "rtmp_flush_interval"
Number of packets flushed up in tha same request (\s-1RTMPT\s0 only). Da default
is 10.
.IP "\fBrtmp_live\fR" 4
.IX Item "rtmp_live"
Specify dat tha media be a live stream. No resumin or seekin in
live streams is possible. Da default value is \f(CW\*(C`any\*(C'\fR, which means the
subscriber first tries ta play tha live stream specified up in the
playpath. If a live stream of dat name aint found, it skits the
recorded stream. Da other possible joints is \f(CW\*(C`live\*(C'\fR and
\&\f(CW\*(C`recorded\*(C'\fR.
.IP "\fBrtmp_pageurl\fR" 4
.IX Item "rtmp_pageurl"
\&\s-1URL\s0 of tha wizzy page up in which tha media was embedded. Y'all KNOW dat shit, muthafucka! By default no
value is ghon be sent.
.IP "\fBrtmp_playpath\fR" 4
.IX Item "rtmp_playpath"
Stream identifier ta play or ta publish. This option overrides the
parameta specified up in tha \s-1URI.\s0
.IP "\fBrtmp_subscribe\fR" 4
.IX Item "rtmp_subscribe"
Name of live stream ta subscribe to. By default no value is ghon be sent.
It be only busted if tha option is specified or if rtmp_live
is set ta live.
.IP "\fBrtmp_swfhash\fR" 4
.IX Item "rtmp_swfhash"
\&\s-1SHA256\s0 hash of tha decompressed \s-1SWF\s0 file (32 bytes).
.IP "\fBrtmp_swfsize\fR" 4
.IX Item "rtmp_swfsize"
Size of tha decompressed \s-1SWF\s0 file, required fo' SWFVerification.
.IP "\fBrtmp_swfurl\fR" 4
.IX Item "rtmp_swfurl"
\&\s-1URL\s0 of tha \s-1SWF\s0 playa fo' tha media. By default no value is ghon be sent.
.IP "\fBrtmp_swfverify\fR" 4
.IX Item "rtmp_swfverify"
\&\s-1URL\s0 ta playa swf file, compute hash/size automatically.
.IP "\fBrtmp_tcurl\fR" 4
.IX Item "rtmp_tcurl"
\&\s-1URL\s0 of tha target stream. Defaults ta proto://host[:port]/app.
.PP
For example ta read wit \fBffplay\fR a multimedia resource named
\&\*(L"sample\*(R" from tha application \*(L"vod\*(R" from a \s-1RTMP\s0 server \*(L"myserver\*(R":
.PP
.Vb 1
\&        ffplay rtmp://myserver/vod/sample
.Ve
.PP
To publish ta a password protected server, passin tha playpath and
app names separately:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f flv \-rtmp_playpath some/long/path \-rtmp_app long/app/name rtmp://username:password@myserver/
.Ve
.SS "rtmpe"
.IX Subsection "rtmpe"
Encrypted Real-Time Messagin Protocol.
.PP
Da Encrypted Real-Time Messagin Protocol (\s-1RTMPE\s0) is used for
streamin multimedia content within standard cryptographic primitives,
consistin of Diffie-Hellman key exchange n' \s-1HMACSHA256,\s0 generating
a pair of \s-1RC4\s0 keys.
.SS "rtmps"
.IX Subsection "rtmps"
Real-Time Messagin Protocol over a secure \s-1SSL\s0 connection.
.PP
Da Real-Time Messagin Protocol (\s-1RTMPS\s0) is used fo' streaming
multimedia content across a encrypted connection.
.SS "rtmpt"
.IX Subsection "rtmpt"
Real-Time Messagin Protocol tunneled all up in \s-1HTTP.\s0
.PP
Da Real-Time Messagin Protocol tunneled all up in \s-1HTTP \s0(\s-1RTMPT\s0) is used
for streamin multimedia content within \s-1HTTP\s0 requests ta traverse
firewalls.
.SS "rtmpte"
.IX Subsection "rtmpte"
Encrypted Real-Time Messagin Protocol tunneled all up in \s-1HTTP.\s0
.PP
Da Encrypted Real-Time Messagin Protocol tunneled all up in \s-1HTTP \s0(\s-1RTMPTE\s0)
is used fo' streamin multimedia content within \s-1HTTP\s0 requests ta traverse
firewalls.
.SS "rtmpts"
.IX Subsection "rtmpts"
Real-Time Messagin Protocol tunneled all up in \s-1HTTPS.\s0
.PP
Da Real-Time Messagin Protocol tunneled all up in \s-1HTTPS \s0(\s-1RTMPTS\s0) is used
for streamin multimedia content within \s-1HTTPS\s0 requests ta traverse
firewalls.
.SS "libssh"
.IX Subsection "libssh"
Secure File Transfer Protocol via libssh
.PP
Allow ta read from or write ta remote resources rockin \s-1SFTP\s0 protocol.
.PP
Peepin syntax is required.
.PP
.Vb 1
\&        sftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg
.Ve
.PP
This protocol accepts tha followin options.
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Set timeout of socket I/O operations used by tha underlyin low level
operation. I aint talkin' bout chicken n' gravy biatch. By default it is set ta \-1, which means dat tha timeout
is not specified.
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate existin filez on write, if set ta 1 fo' realz. A value of 0 prevents
truncating. Default value is 1.
.PP
Example: Play a gangbangin' file stored on remote server.
.PP
.Vb 1
\&        ffplay sftp://user:password@server_address:22/home/user/resource.mpeg
.Ve
.SS "librtmp rtmp, rtmpe, rtmps, rtmpt, rtmpte"
.IX Subsection "librtmp rtmp, rtmpe, rtmps, rtmpt, rtmpte"
Real-Time Messagin Protocol n' its variants supported through
librtmp.
.PP
Requires tha presence of tha librtmp headaz n' library during
configuration. I aint talkin' bout chicken n' gravy biatch. Yo ass need ta explicitly configure tha build with
\&\*(L"\-\-enable\-librtmp\*(R". If enabled dis will replace tha natizzle \s-1RTMP\s0
protocol.
.PP
This protocol serves up most client functions n' all dem server
functions needed ta support \s-1RTMP, RTMP\s0 tunneled up in \s-1HTTP \s0(\s-1RTMPT\s0),
encrypted \s-1RTMP \s0(\s-1RTMPE\s0), \s-1RTMP\s0 over \s-1SSL/TLS \s0(\s-1RTMPS\s0) n' tunneled
variantz of these encrypted types (\s-1RTMPTE, RTMPTS\s0).
.PP
Da required syntax is:
.PP
.Vb 1
\&        <rtmp_proto>://<server>[:<port>][/<app>][/<playpath>] <options>
.Ve
.PP
where \fIrtmp_proto\fR is one of tha strings \*(L"rtmp\*(R", \*(L"rtmpt\*(R", \*(L"rtmpe\*(R",
\&\*(L"rtmps\*(R", \*(L"rtmpte\*(R", \*(L"rtmpts\*(R" correspondin ta each \s-1RTMP\s0 variant, and
\&\fIserver\fR, \fIport\fR, \fIapp\fR n' \fIplaypath\fR have tha same
meanin as specified fo' tha \s-1RTMP\s0 natizzle protocol.
\&\fIoptions\fR gotz nuff a list of space-separated optionz of tha form
\&\fIkey\fR=\fIval\fR.
.PP
See tha librtmp manual page (man 3 librtmp) fo' mo' shiznit.
.PP
For example, ta stream a gangbangin' file up in real-time ta a \s-1RTMP\s0 server using
\&\fBffmpeg\fR:
.PP
.Vb 1
\&        ffmpeg \-re \-i myfile \-f flv rtmp://myserver/live/mystream
.Ve
.PP
To play tha same stream rockin \fBffplay\fR:
.PP
.Vb 1
\&        ffplay "rtmp://myserver/live/mystream live=1"
.Ve
.SS "rtp"
.IX Subsection "rtp"
Real-time Transhiznit Protocol.
.PP
Da required syntax fo' a \s-1RTP URL\s0 is:
rtp://\fIhostname\fR[:\fIport\fR][?\fIoption\fR=\fIval\fR...]
.PP
\&\fIport\fR specifies tha \s-1RTP\s0 port ta use.
.PP
Da followin \s-1URL\s0 options is supported:
.IP "\fBttl=\fR\fIn\fR" 4
.IX Item "ttl=n"
Set tha \s-1TTL \s0(Time-To-Live) value (for multicast only).
.IP "\fBrtcpport=\fR\fIn\fR" 4
.IX Item "rtcpport=n"
Set tha remote \s-1RTCP\s0 port ta \fIn\fR.
.IP "\fBlocalrtpport=\fR\fIn\fR" 4
.IX Item "localrtpport=n"
Set tha local \s-1RTP\s0 port ta \fIn\fR.
.IP "\fBlocalrtcpport=\fR\fIn\fR\fB'\fR" 4
.IX Item "localrtcpport=n'"
Set tha local \s-1RTCP\s0 port ta \fIn\fR.
.IP "\fBpkt_size=\fR\fIn\fR" 4
.IX Item "pkt_size=n"
Set max packet size (in bytes) ta \fIn\fR.
.IP "\fBconnect=0|1\fR" 4
.IX Item "connect=0|1"
Do a \f(CW\*(C`connect()\*(C'\fR on tha \s-1UDP\s0 socket (if set ta 1) or not (if set
to 0).
.IP "\fBsources=\fR\fIip\fR\fB[,\fR\fIip\fR\fB]\fR" 4
.IX Item "sources=ip[,ip]"
List allowed source \s-1IP\s0 addresses.
.IP "\fBblock=\fR\fIip\fR\fB[,\fR\fIip\fR\fB]\fR" 4
.IX Item "block=ip[,ip]"
List disallowed (blocked) source \s-1IP\s0 addresses.
.IP "\fBwrite_to_source=0|1\fR" 4
.IX Item "write_to_source=0|1"
Send packets ta tha source address of tha sickest fuckin received packet (if
set ta 1) or ta a thugged-out default remote address (if set ta 0).
.IP "\fBlocalport=\fR\fIn\fR" 4
.IX Item "localport=n"
Set tha local \s-1RTP\s0 port ta \fIn\fR.
.Sp
This be a thugged-out deprecated option. I aint talkin' bout chicken n' gravy biatch. Instead, \fBlocalrtpport\fR should be
used.
.PP
Important notes:
.IP "1." 4
If \fBrtcpport\fR aint set tha \s-1RTCP\s0 port is ghon be set ta tha \s-1RTP\s0
port value plus 1.
.IP "2." 4
If \fBlocalrtpport\fR (the local \s-1RTP\s0 port) aint set any available
port is ghon be used fo' tha local \s-1RTP\s0 n' \s-1RTCP\s0 ports.
.IP "3." 4
If \fBlocalrtcpport\fR (the local \s-1RTCP\s0 port) aint set it will be
set ta tha the local \s-1RTP\s0 port value plus 1.
.SS "rtsp"
.IX Subsection "rtsp"
\&\s-1RTSP\s0 aint technologically a protocol handlez up in libavformat, it aint nuthin but a thugged-out demuxer
and muxer n' shit. Da demuxer supports both aiiight \s-1RTSP \s0(with data transferred
over \s-1RTP\s0; dis is used by e.g fo' realz. Applez n' Microsoft) n' Real-RTSP (with
data transferred over \s-1RDT\s0).
.PP
Da muxer can be used ta bust a stream rockin \s-1RTSP ANNOUNCE\s0 ta a server
supportin it (currently Darwin Streamin Server n' Mischa Spiegelmock's
<\fBhttp://github.com/revmischa/rtsp\-server\fR>).
.PP
Da required syntax fo' a \s-1RTSP\s0 url is:
.PP
.Vb 1
\&        rtsp://<hostname>[:<port>]/<path>
.Ve
.PP
Da followin options (set on tha \fBffmpeg\fR/\fBffplay\fR command
line, or set up in code via \f(CW\*(C`AVOption\*(C'\fRs or up in \f(CW\*(C`avformat_open_input\*(C'\fR),
are supported:
.PP
Flags fo' \f(CW\*(C`rtsp_transport\*(C'\fR:
.IP "\fBudp\fR" 4
.IX Item "udp"
Use \s-1UDP\s0 as lower transhiznit protocol.
.IP "\fBtcp\fR" 4
.IX Item "tcp"
Use \s-1TCP \s0(interleavin within tha \s-1RTSP\s0 control channel) as lower
transhiznit protocol.
.IP "\fBudp_multicast\fR" 4
.IX Item "udp_multicast"
Use \s-1UDP\s0 multicast as lower transhiznit protocol.
.IP "\fBhttp\fR" 4
.IX Item "http"
Use \s-1HTTP\s0 tunnelin as lower transhiznit protocol, which is useful for
passin proxies.
.PP
Multiple lower transhiznit protocols may be specified, up in dat case they are
tried one at a time (if tha setup of one fails, tha next one is tried).
For tha muxer, only tha \f(CW\*(C`tcp\*(C'\fR n' \f(CW\*(C`udp\*(C'\fR options is supported.
.PP
Flags fo' \f(CW\*(C`rtsp_flags\*(C'\fR:
.IP "\fBfilter_src\fR" 4
.IX Item "filter_src"
Accept packets only from negotiated peer address n' port.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Act as a server, listenin fo' a incomin connection.
.PP
When receivin data over \s-1UDP,\s0 tha demuxer tries ta reorder received packets
(since they may arrive outta order, or packets may git lost straight-up). This
can be disabled by settin tha maximum demuxin delay ta zero (via
the \f(CW\*(C`max_delay\*(C'\fR field of AVFormatContext).
.PP
When watchin multi-bitrate Real-RTSP streams wit \fBffplay\fR, the
streams ta display can be chosen wit \f(CW\*(C`\-vst\*(C'\fR \fIn\fR and
\&\f(CW\*(C`\-ast\*(C'\fR \fIn\fR fo' vizzle n' audio respectively, n' can be switched
on tha fly by pressin \f(CW\*(C`v\*(C'\fR n' \f(CW\*(C`a\*(C'\fR.
.PP
Example command lines:
.PP
To peep a stream over \s-1UDP,\s0 wit a max reorderin delay of 0.5 seconds:
.PP
.Vb 1
\&        ffplay \-max_delay 500000 \-rtsp_transhiznit udp rtsp://server/video.mp4
.Ve
.PP
To peep a stream tunneled over \s-1HTTP:\s0
.PP
.Vb 1
\&        ffplay \-rtsp_transhiznit http rtsp://server/video.mp4
.Ve
.PP
To bust a stream up in realtime ta a \s-1RTSP\s0 server, fo' others ta watch:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f rtsp \-muxdelay 0.1 rtsp://server/live.sdp
.Ve
.PP
To receive a stream up in realtime:
.PP
.Vb 1
\&        ffmpeg \-rtsp_flags listen \-i rtsp://ownaddress/live.sdp <output>
.Ve
.IP "\fBstimeout\fR" 4
.IX Item "stimeout"
Socket \s-1IO\s0 timeout up in micro seconds.
.SS "sap"
.IX Subsection "sap"
Session Announcement Protocol (\s-1RFC 2974\s0). This aint technologically a
protocol handlez up in libavformat, it aint nuthin but a muxer n' demuxer.
It be used fo' signallin of \s-1RTP\s0 streams, by announcin tha \s-1SDP\s0 fo' the
streams regularly on a separate port.
.PP
\fIMuxer\fR
.IX Subsection "Muxer"
.PP
Da syntax fo' a \s-1SAP\s0 url given ta tha muxer is:
.PP
.Vb 1
\&        sap://<destination>[:<port>][?<options>]
.Ve
.PP
Da \s-1RTP\s0 packets is busted ta \fIdestination\fR on port \fIport\fR,
or ta port 5004 if no port is specified.
\&\fIoptions\fR be a \f(CW\*(C`&\*(C'\fR\-separated list. Da followin options
are supported:
.IP "\fBannounce_addr=\fR\fIaddress\fR" 4
.IX Item "announce_addr=address"
Specify tha destination \s-1IP\s0 address fo' bustin  tha announcements to.
If omitted, tha announcements is busted ta tha commonly used \s-1SAP\s0
announcement multicast address 224.2.127.254 (sap.mcast.net), or
ff0e::2:7ffe if \fIdestination\fR be a IPv6 address.
.IP "\fBannounce_port=\fR\fIport\fR" 4
.IX Item "announce_port=port"
Specify tha port ta bust tha announcements on, defaults to
9875 if not specified.
.IP "\fBttl=\fR\fIttl\fR" 4
.IX Item "ttl=ttl"
Specify tha time ta live value fo' tha announcements n' \s-1RTP\s0 packets,
defaults ta 255.
.IP "\fBsame_port=\fR\fI0|1\fR" 4
.IX Item "same_port=0|1"
If set ta 1, bust all \s-1RTP\s0 streams on tha same port pair. Shiiit, dis aint no joke. If zero (the
default), all streams is busted on unique ports, wit each stream on a
port 2 numbers higher than tha previous.
VLC/Live555 requires dis ta be set ta 1, ta be able ta receive tha stream.
Da \s-1RTP\s0 stack up in libavformat fo' receivin requires all streams ta be sent
on unique ports.
.PP
Example command lines follow.
.PP
To broadcast a stream on tha local subnet, fo' watchin up in \s-1VLC:\s0
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://224.0.0.255?same_port=1
.Ve
.PP
Similarly, fo' watchin up in \fBffplay\fR:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://224.0.0.255
.Ve
.PP
And fo' watchin up in \fBffplay\fR, over IPv6:
.PP
.Vb 1
\&        ffmpeg \-re \-i <input> \-f sap sap://[ff0e::1:2:3:4]
.Ve
.PP
\fIDemuxer\fR
.IX Subsection "Demuxer"
.PP
Da syntax fo' a \s-1SAP\s0 url given ta tha demuxer is:
.PP
.Vb 1
\&        sap://[<address>][:<port>]
.Ve
.PP
\&\fIaddress\fR is tha multicast address ta listen fo' announcements on,
if omitted, tha default 224.2.127.254 (sap.mcast.net) is used. Y'all KNOW dat shit, muthafucka! \fIport\fR
is tha port dat is listened on, 9875 if omitted.
.PP
Da demuxers listens fo' announcements on tha given address n' port.
Once a announcement is received, it tries ta receive dat particular stream.
.PP
Example command lines follow.
.PP
To play back tha straight-up original gangsta stream announced on tha aiiight \s-1SAP\s0 multicast address:
.PP
.Vb 1
\&        ffplay sap://
.Ve
.PP
To play back tha straight-up original gangsta stream announced on one tha default IPv6 \s-1SAP\s0 multicast address:
.PP
.Vb 1
\&        ffplay sap://[ff0e::2:7ffe]
.Ve
.SS "sctp"
.IX Subsection "sctp"
Stream Control Transmission Protocol.
.PP
Da accepted \s-1URL\s0 syntax is:
.PP
.Vb 1
\&        sctp://<host>:<port>[?<options>]
.Ve
.PP
Da protocol accepts tha followin options:
.IP "\fBlisten\fR" 4
.IX Item "listen"
If set ta any value, listen fo' a incomin connection. I aint talkin' bout chicken n' gravy biatch. Outgoin connection is done by default.
.IP "\fBmax_streams\fR" 4
.IX Item "max_streams"
Set tha maximum number of streams. By default no limit is set.
.SS "srtp"
.IX Subsection "srtp"
Secure Real-time Transhiznit Protocol.
.PP
Da accepted options are:
.IP "\fBsrtp_in_suite\fR" 4
.IX Item "srtp_in_suite"
.PD 0
.IP "\fBsrtp_out_suite\fR" 4
.IX Item "srtp_out_suite"
.PD
Select input n' output encodin suites.
.Sp
Supported joints:
.RS 4
.IP "\fB\s-1AES_CM_128_HMAC_SHA1_80\s0\fR" 4
.IX Item "AES_CM_128_HMAC_SHA1_80"
.PD 0
.IP "\fB\s-1SRTP_AES128_CM_HMAC_SHA1_80\s0\fR" 4
.IX Item "SRTP_AES128_CM_HMAC_SHA1_80"
.IP "\fB\s-1AES_CM_128_HMAC_SHA1_32\s0\fR" 4
.IX Item "AES_CM_128_HMAC_SHA1_32"
.IP "\fB\s-1SRTP_AES128_CM_HMAC_SHA1_32\s0\fR" 4
.IX Item "SRTP_AES128_CM_HMAC_SHA1_32"
.RE
.RS 4
.RE
.IP "\fBsrtp_in_params\fR" 4
.IX Item "srtp_in_params"
.IP "\fBsrtp_out_params\fR" 4
.IX Item "srtp_out_params"
.PD
Set input n' output encodin parameters, which is expressed by a
base64\-encoded representation of a funky-ass binary block. Da first 16 bytes of
this binary block is used as masta key, tha followin 14 bytes are
used as masta salt.
.SS "tcp"
.IX Subsection "tcp"
Trasmission Control Protocol.
.PP
Da required syntax fo' a \s-1TCP\s0 url is:
.PP
.Vb 1
\&        tcp://<hostname>:<port>[?<options>]
.Ve
.IP "\fBlisten\fR" 4
.IX Item "listen"
Listen fo' a incomin connection
.IP "\fBtimeout=\fR\fImicroseconds\fR" 4
.IX Item "timeout=microseconds"
In read mode: if no data arrived up in mo' than dis time interval, raise error.
In write mode: if socket cannot be freestyled up in mo' than dis time interval, raise error.
This also sets timeout on \s-1TCP\s0 connection establishing.
.Sp
.Vb 2
\&        ffmpeg \-i <input> \-f <format> tcp://<hostname>:<port>?listen
\&        ffplay tcp://<hostname>:<port>
.Ve
.SS "tls"
.IX Subsection "tls"
Transhiznit Layer Securitizzle (\s-1TLS\s0) / Secure Sockets Layer (\s-1SSL\s0)
.PP
Da required syntax fo' a \s-1TLS/SSL\s0 url is:
.PP
.Vb 1
\&        tls://<hostname>:<port>[?<options>]
.Ve
.PP
Da followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBca_file, cafile=\fR\fIfilename\fR" 4
.IX Item "ca_file, cafile=filename"
A file containin certificate authoritizzle (\s-1CA\s0) root certificates ta treat
as trusted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If tha linked \s-1TLS\s0 library gotz nuff a thugged-out default dis might not
need ta be specified fo' verification ta work yo, but not all libraries and
setups have defaults built in.
Da file must be up in OpenSSL \s-1PEM\s0 format.
.IP "\fBtls_verify=\fR\fI1|0\fR" 4
.IX Item "tls_verify=1|0"
If enabled, try ta verify tha peer dat we is communicatin with.
Note, if rockin OpenSSL, dis currently only make shizzle dat the
peer certificate is signed by one of tha root certificates up in tha \s-1CA\s0
database yo, but it do not validate dat tha certificate actually
matches tha host name we is tryin ta connect to. (With GnuTLS,
the host name is validated as well.)
.Sp
This is disabled by default since it requires a \s-1CA\s0 database ta be
provided by tha calla up in nuff cases.
.IP "\fBcert_file, cert=\fR\fIfilename\fR" 4
.IX Item "cert_file, cert=filename"
A file containin a cold-ass lil certificate ta use up in tha handshake wit tha peer.
(When operatin as server, up in listen mode, dis is mo' often required
by tha peer, while client certificates only is mandated up in certain
setups.)
.IP "\fBkey_file, key=\fR\fIfilename\fR" 4
.IX Item "key_file, key=filename"
A file containin tha private key fo' tha certificate.
.IP "\fBlisten=\fR\fI1|0\fR" 4
.IX Item "listen=1|0"
If enabled, listen fo' connections on tha provided port, n' assume
the server role up in tha handshake instead of tha client role.
.PP
Example command lines:
.PP
To create a \s-1TLS/SSL\s0 server dat serves a input stream.
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f <format> tls://<hostname>:<port>?listen&cert=<server.crt>&key=<server.key>
.Ve
.PP
To play back a stream from tha \s-1TLS/SSL\s0 server rockin \fBffplay\fR:
.PP
.Vb 1
\&        ffplay tls://<hostname>:<port>
.Ve
.SS "udp"
.IX Subsection "udp"
User Datagram Protocol.
.PP
Da required syntax fo' a \s-1UDP\s0 url is:
.PP
.Vb 1
\&        udp://<hostname>:<port>[?<options>]
.Ve
.PP
\&\fIoptions\fR gotz nuff a list of &\-separated optionz of tha form \fIkey\fR=\fIval\fR.
.PP
In case threadin is enabled on tha system, a cold-ass lil circular buffer is used
to store tha incomin data, which allows ta reduce loss of data due to
\&\s-1UDP\s0 socket buffer overruns. Da \fIfifo_size\fR and
\&\fIoverrun_nonfatal\fR options is related ta dis buffer.
.PP
Da list of supported options bigs up.
.IP "\fBbuffer_size=\fR\fIsize\fR" 4
.IX Item "buffer_size=size"
Set tha \s-1UDP\s0 socket buffer size up in bytes. This is used both fo' the
receivin n' tha bustin  buffer size.
.IP "\fBlocalport=\fR\fIport\fR" 4
.IX Item "localport=port"
Override tha local \s-1UDP\s0 port ta bind with.
.IP "\fBlocaladdr=\fR\fIaddr\fR" 4
.IX Item "localaddr=addr"
Choose tha local \s-1IP\s0 address. This is useful e.g. if bustin  multicast
and tha host has multiple intercourses, where tha user can chizzle
which intercourse ta bust on by specifyin tha \s-1IP\s0 address of dat intercourse.
.IP "\fBpkt_size=\fR\fIsize\fR" 4
.IX Item "pkt_size=size"
Set tha size up in bytez of \s-1UDP\s0 packets.
.IP "\fBreuse=\fR\fI1|0\fR" 4
.IX Item "reuse=1|0"
Explicitly allow or disallow reusin \s-1UDP\s0 sockets.
.IP "\fBttl=\fR\fIttl\fR" 4
.IX Item "ttl=ttl"
Set tha time ta live value (for multicast only).
.IP "\fBconnect=\fR\fI1|0\fR" 4
.IX Item "connect=1|0"
Initialize tha \s-1UDP\s0 socket wit \f(CW\*(C`connect()\*(C'\fR. In dis case, the
destination address can't be chizzled wit ff_udp_set_remote_url later.
If tha destination address aint known all up in tha start, dis option can
be specified up in ff_udp_set_remote_url, like a muthafucka.
This allows findin up tha source address fo' tha packets wit getsockname,
and make writes return wit \s-1AVERROR\s0(\s-1ECONNREFUSED\s0) if \*(L"destination
unreachable\*(R" is received.
For receiving, dis gives tha benefit of only receivin packets from
the specified peer address/port.
.IP "\fBsources=\fR\fIaddress\fR\fB[,\fR\fIaddress\fR\fB]\fR" 4
.IX Item "sources=address[,address]"
Only receive packets busted ta tha multicast crew from one of the
specified sender \s-1IP\s0 addresses.
.IP "\fBblock=\fR\fIaddress\fR\fB[,\fR\fIaddress\fR\fB]\fR" 4
.IX Item "block=address[,address]"
Ignore packets busted ta tha multicast crew from tha specified
sender \s-1IP\s0 addresses.
.IP "\fBfifo_size=\fR\fIunits\fR" 4
.IX Item "fifo_size=units"
Set tha \s-1UDP\s0 receivin circular buffer size, expressed as a number of
packets wit size of 188 bytes. If not specified defaults ta 7*4096.
.IP "\fBoverrun_nonfatal=\fR\fI1|0\fR" 4
.IX Item "overrun_nonfatal=1|0"
Survive up in case of \s-1UDP\s0 receivin circular buffer overrun. I aint talkin' bout chicken n' gravy biatch. Default
value is 0.
.IP "\fBtimeout=\fR\fImicroseconds\fR" 4
.IX Item "timeout=microseconds"
In read mode: if no data arrived up in mo' than dis time interval, raise error.
.PP
Some usage examplez of tha \s-1UDP\s0 protocol wit \fBffmpeg\fR follow.
.PP
To stream over \s-1UDP\s0 ta a remote endpoint:
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f <format> udp://<hostname>:<port>
.Ve
.PP
To stream up in mpegts format over \s-1UDP\s0 rockin 188 sized \s-1UDP\s0 packets, rockin a big-ass input buffer:
.PP
.Vb 1
\&        ffmpeg \-i <input> \-f mpegts udp://<hostname>:<port>?pkt_size=188&buffer_size=65535
.Ve
.PP
To receive over \s-1UDP\s0 from a remote endpoint:
.PP
.Vb 1
\&        ffmpeg \-i udp://[<multicast\-address>]:<port>
.Ve
.SS "unix"
.IX Subsection "unix"
Unix local socket
.PP
Da required syntax fo' a Unix socket \s-1URL\s0 is:
.PP
.Vb 1
\&        unix://<filepath>
.Ve
.PP
Da followin parametas can be set via command line options
(or up in code via \f(CW\*(C`AVOption\*(C'\fRs):
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
Timeout up in ms.
.IP "\fBlisten\fR" 4
.IX Item "listen"
Smoke tha Unix socket up in listenin mode.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1), \fIlibavformat\fR\|(3)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
