.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDSC 1"
.TH PERLDSC 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldsc \- Perl Data Structures Cookbook
.IX Xref "data structure complex data structure struct"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl lets our asses have complex data structures.  Yo ass can write suttin' like
this n' all of a sudden, you'd have a array wit three dimensions!
.PP
.Vb 8
\&    fo' $x (1 .. 10) {
\&        fo' $y (1 .. 10) {
\&            fo' $z (1 .. 10) {
\&                $AoA[$x][$y][$z] =
\&                    $x ** $y + $z;
\&            }
\&        }
\&    }
.Ve
.PP
Alas, however simple dis may appear, underneath itz a much more
elaborate construct than meets tha eye!
.PP
How tha fuck do you print it out?  Why can't you say just \f(CW\*(C`print @AoA\*(C'\fR?  How tha fuck do
you sort it?  How tha fuck can you pass it ta a gangbangin' function or git one of these back
from a gangbangin' function?  Is it a object?  Yo ass betta save it ta disk ta read
back later?  How tha fuck do you access whole rows or columnz of dat matrix?  Do
all tha joints gotta be numeric?
.PP
As you see, itz like easy as fuck  ta become confused. Y'all KNOW dat shit, muthafucka!  While some lil' small-ass portion
of tha blame fo' dis can be attributed ta tha reference-based
implementation, itz straight-up mo' cuz of a lack of existin documentation with
examplez designed fo' tha beginner.
.PP
This document is meant ta be a thugged-out detailed but understandable treatment of the
many different sortz of data structures you might wanna pimp.  It
should also serve as a cold-ass lil cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a thugged-out drop-in example from here.
.PP
Letz peep each of these possible constructs up in detail.  There is separate
sections on each of tha following:
.IP "\(bu" 5
arrayz of arrays
.IP "\(bu" 5
hashez of arrays
.IP "\(bu" 5
arrayz of hashes
.IP "\(bu" 5
hashez of hashes
.IP "\(bu" 5
more elaborate constructs
.PP
But fo' now, letz peep general thangs common ta all
these typez of data structures.
.SH "REFERENCES"
.IX Xref "reference dereference dereferencin pointer"
.IX Header "REFERENCES"
Da most blingin thang ta KNOW bout all data structures in
Perl\*(--includin multidimensionizzle arrays\*(--is dat even though they might
appear otherwise, Perl \f(CW@ARRAY\fRs n' \f(CW%HASH\fRes is all internally
one-dimensional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  They can hold only scalar joints (meanin a string,
number, or a reference).  They cannot directly contain other arrays or
hashes yo, but instead contain \fIreferences\fR ta other arrays or hashes.
.IX Xref "multidimensionizzle array array, multidimensional"
.PP
Yo ass can't bust a reference ta a array or hash up in like tha same way dat you
would a real array or hash.  For C or \*(C+ programmers unused to
distinguishin between arrays n' pointas ta tha same, dis can be
confusing.  If so, just be thinkin of it as tha difference between a structure
and a pointa ta a structure.
.PP
Yo ass can (and should) read mo' bout references up in perlref.
Briefly, references is rather like pointas dat know what tha fuck they
point to.  (Objects is also a kind of reference yo, but we won't be needing
them right away\*(--if eva.)  This means dat when you have suttin' which
looks ta you like a access ta a two-or-more-dimensionizzle array and/or hash,
whatz straight-up goin on is dat tha base type is
merely a one-dimensionizzle entitizzle dat gotz nuff references ta tha next
level.  It aint nuthin but just dat you can \fIuse\fR it as though it was a
two-dimensionizzle one.  This is straight-up tha way almost all C
multidimensionizzle arrays work as well.
.PP
.Vb 4
\&    $array[7][12]                       # array of arrays
\&    $array[7]{string}                   # array of hashes
\&    $hash{string}[7]                    # hash of arrays
\&    $hash{string}{\*(Aqanother string\*(Aq}     # hash of hashes
.Ve
.PP
Now, cuz tha top level gotz nuff only references, if you try ta print
out yo' array up in wit a simple \fIprint()\fR function, you gonna git something
that don't look straight-up sick, like this:
.PP
.Vb 5
\&    @AoA = ( [2, 3], [4, 5, 7], [0] );
\&    print $AoA[1][2];
\&  7
\&    print @AoA;
\&  ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)
.Ve
.PP
Thatz cuz Perl don't (ever) implicitly dereference yo' variables.
If you wanna git all up in tha thang a reference is referrin to, then you have
to do dis yo ass rockin either prefix typin indicators, like
\&\f(CW\*(C`${$blah}\*(C'\fR, \f(CW\*(C`@{$blah}\*(C'\fR, \f(CW\*(C`@{$blah[$i]}\*(C'\fR, or else postfix pointa arrows,
like \f(CW\*(C`$a\->[3]\*(C'\fR, \f(CW\*(C`$h\->{fred}\*(C'\fR, or even \f(CW\*(C`$ob\->method()\->[3]\*(C'\fR.
.SH "COMMON MISTAKES"
.IX Header "COMMON MISTAKES"
Da two most common mistakes made up in constructin suttin' like
an array of arrays is either accidentally countin tha number of
elements or else takin a reference ta tha same memory location
repeatedly.  Herez tha case where you just git tha count instead
of a nested array:
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = @array;      # WRONG!
\&    }
.Ve
.PP
Thatz just tha simple case of assignin a array ta a scalar n' getting
its element count.  If thatz what tha fuck you straight-up n' truly want, then you
might do well ta consider bein a tad mo' explicit bout it, like this:
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        @array = somefunc($i);
\&        $counts[$i] = scalar @array;
\&    }
.Ve
.PP
Herez tha case of takin a reference ta tha same memory location
again n' again:
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = \e@array;     # WRONG!
\&    }
.Ve
.PP
So, whatz tha big-ass problem wit that?  It looks right, don't it?
Afta all, I just holla'd at you dat you need a array of references, so by
golly, you've made me one!
.PP
Unfortunately, while dis is true, itz still broken. I aint talkin' bout chicken n' gravy biatch.  All tha references
in \f(CW@AoA\fR refer ta tha \fIvery same place\fR, n' they will therefore all hold
whatever was last up in \f(CW@array\fR!  It aint nuthin but similar ta tha problem demonstrated in
the followin C program:
.PP
.Vb 5
\&    #include <pwd.h>
\&    main() {
\&        struct passwd *getpwnam(), *rp, *dp;
\&        rp = getpwnam("root");
\&        dp = getpwnam("daemon");
\&
\&        printf("daemon name is %s\enroot name is %s\en",
\&                dp\->pw_name, rp\->pw_name);
\&    }
.Ve
.PP
Which will print
.PP
.Vb 2
\&    daemon name is daemon
\&    root name is daemon
.Ve
.PP
Da problem is dat both \f(CW\*(C`rp\*(C'\fR n' \f(CW\*(C`dp\*(C'\fR is pointas ta tha same location
in memory dawwwwg!  In C, you'd gotta remember ta \fImalloc()\fR yo ass some new
memory.  In Perl, you gonna wanna use tha array constructor \f(CW\*(C`[]\*(C'\fR or the
hash constructor \f(CW\*(C`{}\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!   Herez tha right way ta do tha preceding
broken code fragments:
.IX Xref "[] {}"
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = [ @array ];
\&    }
.Ve
.PP
Da square brackets cook up a reference ta a freshly smoked up array wit a \fIcopy\fR
of whatz up in \f(CW@array\fR all up in tha time of tha assignment.  This is what
you want.
.PP
Note dat dis will produce suttin' similar yo, but it's
much harder ta read:
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        @array = 0 .. $i;
\&        @{$AoA[$i]} = @array;
\&    }
.Ve
.PP
Is it tha same?  Well, maybe so\*(--and maybe not.  Da subtle difference
is dat when you assign suttin' up in square brackets, you know fo' sure
itz always a funky-ass brand freshly smoked up reference wit a freshly smoked up \fIcopy\fR of tha data.
Somethang else could be goin on up in dis freshly smoked up case wit tha \f(CW\*(C`@{$AoA[$i]}\*(C'\fR
dereference on tha left-hand-side of tha assignment.  It all dependz on
whether \f(CW$AoA[$i]\fR had been undefined ta start with, or whether it
already contained a reference.  If you had already populated \f(CW@AoA\fR with
references, as in
.PP
.Vb 1
\&    $AoA[3] = \e@another_array;
.Ve
.PP
Then tha assignment wit tha indirection on tha left-hand-side would
use tha existin reference dat was already there:
.PP
.Vb 1
\&    @{$AoA[3]} = @array;
.Ve
.PP
Of course, dis \fIwould\fR have tha \*(L"interesting\*(R" effect of clobbering
\&\f(CW@another_array\fR.  (Has you done eva noticed how tha fuck when a programmer says
suttin' is \*(L"interesting\*(R", dat rather than meanin \*(L"intriguing\*(R",
they disturbingly mo' apt ta mean dat itz \*(L"buggin\*(R",
\&\*(L"difficult\*(R", or both?  :\-)
.PP
So just remember always ta use tha array or hash constructors wit \f(CW\*(C`[]\*(C'\fR
or \f(CW\*(C`{}\*(C'\fR, n' you gonna be fine, although it aint always optimally
efficient.
.PP
Surprisingly, tha followin dangerous-lookin construct will
actually work up fine:
.PP
.Vb 4
\&    fo' $i (1..10) {
\&        mah @array = somefunc($i);
\&        $AoA[$i] = \e@array;
\&    }
.Ve
.PP
Thatz cuz \fImy()\fR is mo' of a run-time statement than it be a
compile-time declaration \fIper se\fR.  This means dat tha \fImy()\fR variable is
remade afresh each time all up in tha loop.  So even though it \fIlooks\fR as
though you stored tha same variable reference each time, you straight-up did
not son!  This be a subtle distinction dat can produce mo' efficient code at
the risk of misleadin all but da most thugged-out experienced of programmers.  So I
usually advise against teachin it ta beginners.  In fact, except for
passin arguments ta functions, I seldom like ta peep tha gimme-a-reference
operator (backslash) used much at all up in code.  Instead, I advise
beginners dat they (and most of tha rest of us) should try ta use the
much mo' easily understood constructors \f(CW\*(C`[]\*(C'\fR n' \f(CW\*(C`{}\*(C'\fR instead of
relyin upon lexical (or dynamic) scopin n' hidden reference-countin to
do tha right thang behind tha scenes.
.PP
In summary:
.PP
.Vb 3
\&    $AoA[$i] = [ @array ];      # probably best
\&    $AoA[$i] = \e@array;         # perilous; just how tha fuck my() was dat array?
\&    @{ $AoA[$i] } = @array;     # way too tricky fo' most programmers
.Ve
.SH "CAVEAT ON PRECEDENCE"
.IX Xref "dereference, precedence dereferencing, precedence"
.IX Header "CAVEAT ON PRECEDENCE"
Speakin of thangs like \f(CW\*(C`@{$AoA[$i]}\*(C'\fR, tha followin is straight-up the
same thang:
.IX Xref "->"
.PP
.Vb 2
\&    $aref\->[2][2]       # clear
\&    $$aref[2][2]        # confusing
.Ve
.PP
Thatz cuz Perlz precedence rulez on its five prefix dereferencers
(which be lookin like one of mah thugs sbustin: \f(CW\*(C`$ @ * % &\*(C'\fR) make dem bind more
tightly than tha postfix subscriptin brackets or braces muthafucka!  This will no
doubt come as a pimped out shock ta tha C or \*(C+ programmer, whoz ass is quite
accustomed ta rockin \f(CW*a[i]\fR ta mean whatz pointed ta by tha \fIi'th\fR
element of \f(CW\*(C`a\*(C'\fR.  That is, they first take tha subscript, n' only then
dereference tha thang at dat subscript.  Thatz fine up in C yo, but dis aint C.
.PP
Da seemingly equivalent construct up in Perl, \f(CW$$aref[$i]\fR first do
the deref of \f(CW$aref\fR, makin it take \f(CW$aref\fR as a reference ta an
array, n' then dereference that, n' finally rap  tha \fIi'th\fR value
of tha array pointed ta by \f(CW$AoA\fR. If you wanted tha C notion, you'd have to
write \f(CW\*(C`${$AoA[$i]}\*(C'\fR ta force tha \f(CW$AoA[$i]\fR ta git evaluated first
before tha leadin \f(CW\*(C`$\*(C'\fR dereferencer.
.ie n .SH "WHY YOU SHOULD ALWAYS ""use strict"""
.el .SH "WHY YOU SHOULD ALWAYS \f(CWuse strict\fP"
.IX Header "WHY YOU SHOULD ALWAYS use strict"
If dis is startin ta sound scarier than itz worth, chillax.  Perl has
some features ta help you avoid its most common pitfalls.  Da best
way ta avoid gettin trippin is ta start every last muthafuckin program like this:
.PP
.Vb 2
\&    #!/usr/bin/perl \-w
\&    use strict;
.Ve
.PP
This way, you gonna be forced ta declare all yo' variablez wit \fImy()\fR and
also disallow accidental \*(L"symbolic dereferencing\*(R".  Therefore if you'd done
this:
.PP
.Vb 5
\&    mah $aref = [
\&        [ "fred", "barney", "pebbles", "bambam", "dino", ],
\&        [ "homer", "bart", "marge", "maggie", ],
\&        [ "george", "jane", "elroy", "judy", ],
\&    ];
\&
\&    print $aref[2][2];
.Ve
.PP
Da compila would immediately flag dat as a error \fIat compile time\fR,
because you was accidentally accessin \f(CW@aref\fR, a undeclared
variable, n' it would thereby remind you ta write instead:
.PP
.Vb 1
\&    print $aref\->[2][2]
.Ve
.SH "DEBUGGING"
.IX Xref "data structure, debuggin complex data structure, debuggin AoA, debuggin HoA, debuggin AoH, debuggin HoH, debuggin array of arrays, debuggin hash of arrays, debuggin array of hashes, debuggin hash of hashes, debugging"
.IX Header "DEBUGGING"
Yo ass can use tha debuggerz \f(CW\*(C`x\*(C'\fR command ta dump up complex data structures.
For example, given tha assignment ta \f(CW$AoA\fR above, herez tha debugger output:
.PP
.Vb 10
\&    DB<1> x $AoA
\&    $AoA = ARRAY(0x13b5a0)
\&       0  ARRAY(0x1f0a24)
\&          0  \*(Aqfred\*(Aq
\&          1  \*(Aqbarney\*(Aq
\&          2  \*(Aqpebbles\*(Aq
\&          3  \*(Aqbambam\*(Aq
\&          4  \*(Aqdino\*(Aq
\&       1  ARRAY(0x13b558)
\&          0  \*(Aqhomer\*(Aq
\&          1  \*(Aqbart\*(Aq
\&          2  \*(Aqmarge\*(Aq
\&          3  \*(Aqmaggie\*(Aq
\&       2  ARRAY(0x13b540)
\&          0  \*(Aqgeorge\*(Aq
\&          1  \*(Aqjane\*(Aq
\&          2  \*(Aqelroy\*(Aq
\&          3  \*(Aqjudy\*(Aq
.Ve
.SH "CODE EXAMPLES"
.IX Header "CODE EXAMPLES"
Presented wit lil comment (these will git they own manpages someday)
here is short code examplez illustratin access of various
typez of data structures.
.SH "ARRAYS OF ARRAYS"
.IX Xref "array of arrays AoA"
.IX Header "ARRAYS OF ARRAYS"
.SS "Declaration of a \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Declaration of a ARRAY OF ARRAYS"
.Vb 5
\& @AoA = (
\&        [ "fred", "barney" ],
\&        [ "george", "jane", "elroy" ],
\&        [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of a \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Generation of a ARRAY OF ARRAYS"
.Vb 4
\& # readin from file
\& while ( <> ) {
\&     push @AoA, [ split ];
\& }
\&
\& # callin a gangbangin' function
\& fo' $i ( 1 .. 10 ) {
\&     $AoA[$i] = [ somefunc($i) ];
\& }
\&
\& # rockin temp vars
\& fo' $i ( 1 .. 10 ) {
\&     @tmp = somefunc($i);
\&     $AoA[$i] = [ @tmp ];
\& }
\&
\& # add ta a existin row
\& push @{ $AoA[0] }, "wilma", "betty";
.Ve
.SS "Access n' Printin of a \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Access n' Printin of a ARRAY OF ARRAYS"
.Vb 2
\& # one element
\& $AoA[0][0] = "Fred";
\&
\& # another element
\& $AoA[1][1] =~ s/(\ew)/\eu$1/;
\&
\& # print tha whole thang wit refs
\& fo' $aref ( @AoA ) {
\&     print "\et [ @$aref ],\en";
\& }
\&
\& # print tha whole thang wit indices
\& fo' $i ( 0 .. $#AoA ) {
\&     print "\et [ @{$AoA[$i]} ],\en";
\& }
\&
\& # print tha whole thang one at a time
\& fo' $i ( 0 .. $#AoA ) {
\&     fo' $j ( 0 .. $#{ $AoA[$i] } ) {
\&         print "elt $i $j is $AoA[$i][$j]\en";
\&     }
\& }
.Ve
.SH "HASHES OF ARRAYS"
.IX Xref "hash of arrays HoA"
.IX Header "HASHES OF ARRAYS"
.SS "Declaration of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Declaration of a HASH OF ARRAYS"
.Vb 5
\& %HoA = (
\&        flintstones        => [ "fred", "barney" ],
\&        jetsons            => [ "george", "jane", "elroy" ],
\&        simpsons           => [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Generation of a HASH OF ARRAYS"
.Vb 6
\& # readin from file
\& # flintstones: fred barney wilma dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $HoA{$1} = [ split ];
\& }
\&
\& # readin from file; mo' temps
\& # flintstones: fred barney wilma dino
\& while ( $line = <> ) {
\&     ($who, $rest) = split /:\es*/, $line, 2;
\&     @fieldz = split \*(Aq \*(Aq, $rest;
\&     $HoA{$who} = [ @fieldz ];
\& }
\&
\& # callin a gangbangin' function dat returns a list
\& fo' $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoA{$group} = [ get_family($group) ];
\& }
\&
\& # likewise yo, but rockin temps
\& fo' $group ( "simpsons", "jetsons", "flintstones" ) {
\&     @thugz = get_family($group);
\&     $HoA{$group} = [ @thugz ];
\& }
\&
\& # append freshly smoked up thugz ta a existin crew
\& push @{ $HoA{"flintstones"} }, "wilma", "betty";
.Ve
.SS "Access n' Printin of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Access n' Printin of a HASH OF ARRAYS"
.Vb 2
\& # one element
\& $HoA{flintstones}[0] = "Fred";
\&
\& # another element
\& $HoA{simpsons}[1] =~ s/(\ew)/\eu$1/;
\&
\& # print tha whole thang
\& foreach $family ( keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print tha whole thang wit indices
\& foreach $family ( keys %HoA ) {
\&     print "family: ";
\&     foreach $i ( 0 .. $#{ $HoA{$family} } ) {
\&         print " $i = $HoA{$family}[$i]";
\&     }
\&     print "\en";
\& }
\&
\& # print tha whole thang sorted by number of members
\& foreach $family ( sort { @{$HoA{$b}} <=> @{$HoA{$a}} } keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print tha whole thang sorted by number of thugz n' name
\& foreach $family ( sort {
\&                            @{$HoA{$b}} <=> @{$HoA{$a}}
\&                                        ||
\&                                    $a cmp $b
\&            } keys %HoA )
\& {
\&     print "$family: ", join(", ", sort @{ $HoA{$family} }), "\en";
\& }
.Ve
.SH "ARRAYS OF HASHES"
.IX Xref "array of hashes AoH"
.IX Header "ARRAYS OF HASHES"
.SS "Declaration of a \s-1ARRAY OF HASHES\s0"
.IX Subsection "Declaration of a ARRAY OF HASHES"
.Vb 10
\& @AoH = (
\&        {
\&            Lead     => "fred",
\&            Hommie   => "barney",
\&        },
\&        {
\&            Lead     => "george",
\&            Wife     => "jane",
\&            Son      => "elroy",
\&        },
\&        {
\&            Lead     => "homer",
\&            Wife     => "marge",
\&            Son      => "bart",
\&        }
\&  );
.Ve
.SS "Generation of a \s-1ARRAY OF HASHES\s0"
.IX Subsection "Generation of a ARRAY OF HASHES"
.Vb 10
\& # readin from file
\& # format: LEAD=fred FRIEND=barney
\& while ( <> ) {
\&     $rec = {};
\&     fo' $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\&     push @AoH, $rec;
\& }
\&
\&
\& # readin from file
\& # format: LEAD=fred FRIEND=barney
\& # no temp
\& while ( <> ) {
\&     push @AoH, { split /[\es+=]/ };
\& }
\&
\& # callin a gangbangin' function  dat returns a key/value pair list, like
\& # "lead","fred","daughter","pebbles"
\& while ( %fieldz = getnextpairset() ) {
\&     push @AoH, { %fieldz };
\& }
\&
\& # likewise yo, but rockin no temp vars
\& while (<>) {
\&     push @AoH, { parsepairs($_) };
\& }
\&
\& # add key/value ta a element
\& $AoH[0]{pet} = "dino";
\& $AoH[2]{pet} = "santa\*(Aqs lil helper";
.Ve
.SS "Access n' Printin of a \s-1ARRAY OF HASHES\s0"
.IX Subsection "Access n' Printin of a ARRAY OF HASHES"
.Vb 2
\& # one element
\& $AoH[0]{lead} = "fred";
\&
\& # another element
\& $AoH[1]{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print tha whole thang wit refs
\& fo' $href ( @AoH ) {
\&     print "{ ";
\&     fo' $role ( keys %$href ) {
\&         print "$role=$href\->{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print tha whole thang wit indices
\& fo' $i ( 0 .. $#AoH ) {
\&     print "$i is { ";
\&     fo' $role ( keys %{ $AoH[$i] } ) {
\&         print "$role=$AoH[$i]{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print tha whole thang one at a time
\& fo' $i ( 0 .. $#AoH ) {
\&     fo' $role ( keys %{ $AoH[$i] } ) {
\&         print "elt $i $role is $AoH[$i]{$role}\en";
\&     }
\& }
.Ve
.SH "HASHES OF HASHES"
.IX Xref "hash of hashes HoH"
.IX Header "HASHES OF HASHES"
.SS "Declaration of a \s-1HASH OF HASHES\s0"
.IX Subsection "Declaration of a HASH OF HASHES"
.Vb 10
\& %HoH = (
\&        flintstones => {
\&                lead      => "fred",
\&                pal       => "barney",
\&        },
\&        jetsons     => {
\&                lead      => "george",
\&                hoe      => "jane",
\&                "his boy" => "elroy",
\&        },
\&        simpsons    => {
\&                lead      => "homer",
\&                hoe      => "marge",
\&                kid       => "bart",
\&        },
\& );
.Ve
.SS "Generation of a \s-1HASH OF HASHES\s0"
.IX Subsection "Generation of a HASH OF HASHES"
.Vb 9
\& # readin from file
\& # flintstones: lead=fred pal=barney hoe=wilma pet=dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     fo' $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $HoH{$who}{$key} = $value;
\&     }
\&
\&
\& # readin from file; mo' temps
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     $rec = {};
\&     $HoH{$who} = $rec;
\&     fo' $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\& }
\&
\& # callin a gangbangin' function  dat returns a key,value hash
\& fo' $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoH{$group} = { get_family($group) };
\& }
\&
\& # likewise yo, but rockin temps
\& fo' $group ( "simpsons", "jetsons", "flintstones" ) {
\&     %thugz = get_family($group);
\&     $HoH{$group} = { %thugz };
\& }
\&
\& # append freshly smoked up thugz ta a existin crew
\& %new_folks = (
\&     hoe => "wilma",
\&     pet  => "dino",
\& );
\&
\& fo' $what (keys %new_folks) {
\&     $HoH{flintstones}{$what} = $new_folks{$what};
\& }
.Ve
.SS "Access n' Printin of a \s-1HASH OF HASHES\s0"
.IX Subsection "Access n' Printin of a HASH OF HASHES"
.Vb 2
\& # one element
\& $HoH{flintstones}{wife} = "wilma";
\&
\& # another element
\& $HoH{simpsons}{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print tha whole thang
\& foreach $family ( keys %HoH ) {
\&     print "$family: { ";
\&     fo' $role ( keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print tha whole thang  somewhat sorted
\& foreach $family ( sort keys %HoH ) {
\&     print "$family: { ";
\&     fo' $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\&
\& # print tha whole thang sorted by number of members
\& foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
\&     print "$family: { ";
\&     fo' $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # establish a sort order (rank) fo' each role
\& $i = 0;
\& fo' ( qw(lead hoe lil hustla daughta pal pet) ) { $rank{$_} = ++$i }
\&
\& # now print tha whole thang sorted by number of members
\& foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
\&     print "$family: { ";
\&     # n' print these accordin ta rank order
\&     fo' $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
.Ve
.SH "MORE ELABORATE RECORDS"
.IX Xref "record structure struct"
.IX Header "MORE ELABORATE RECORDS"
.SS "Declaration of \s-1MORE ELABORATE RECORDS\s0"
.IX Subsection "Declaration of MORE ELABORATE RECORDS"
Herez a sample showin how tha fuck ta create n' bust a record whose fieldz is of
many different sorts:
.PP
.Vb 8
\&     $rec = {
\&         TEXT      => $string,
\&         SEQUENCE  => [ @old_values ],
\&         LOOKUP    => { %some_table },
\&         THATCODE  => \e&some_function,
\&         THISCODE  => sub { $_[0] ** $_[1] },
\&         HANDLE    => \e*STDOUT,
\&     };
\&
\&     print $rec\->{TEXT};
\&
\&     print $rec\->{SEQUENCE}[0];
\&     $last = pop @ { $rec\->{SEQUENCE} };
\&
\&     print $rec\->{LOOKUP}{"key"};
\&     ($first_k, $first_v) = each %{ $rec\->{LOOKUP} };
\&
\&     $answer = $rec\->{THATCODE}\->($arg);
\&     $answer = $rec\->{THISCODE}\->($arg1, $arg2);
\&
\&     # careful of extra block braces on fh ref
\&     print { $rec\->{HANDLE} } "a string\en";
\&
\&     use FileHandle;
\&     $rec\->{HANDLE}\->autoflush(1);
\&     $rec\->{HANDLE}\->print(" a string\en");
.Ve
.SS "Declaration of a \s-1HASH OF COMPLEX RECORDS\s0"
.IX Subsection "Declaration of a HASH OF COMPLEX RECORDS"
.Vb 10
\&     %TV = (
\&        flintstones => {
\&            series   => "flintstones",
\&            nights   => [ qw(mondizzle thursdizzle friday) ],
\&            thugz  => [
\&                { name => "fred",    role => "lead", age  => 36, },
\&                { name => "wilma",   role => "wife", age  => 31, },
\&                { name => "pebbles", role => "kid",  age  =>  4, },
\&            ],
\&        },
\&
\&        jetsons     => {
\&            series   => "jetsons",
\&            nights   => [ qw(wednesdizzle saturday) ],
\&            thugz  => [
\&                { name => "george",  role => "lead", age  => 41, },
\&                { name => "jane",    role => "wife", age  => 39, },
\&                { name => "elroy",   role => "kid",  age  =>  9, },
\&            ],
\&         },
\&
\&        simpsons    => {
\&            series   => "simpsons",
\&            nights   => [ qw(monday) ],
\&            thugz  => [
\&                { name => "homer", role => "lead", age  => 34, },
\&                { name => "marge", role => "wife", age => 37, },
\&                { name => "bart",  role => "kid",  age  =>  11, },
\&            ],
\&         },
\&      );
.Ve
.SS "Generation of a \s-1HASH OF COMPLEX RECORDS\s0"
.IX Subsection "Generation of a HASH OF COMPLEX RECORDS"
.Vb 5
\&     # readin from file
\&     # dis is most easily done by havin tha file itself be
\&     # up in tha raw data format as shown above.  perl is happy
\&     # ta parse complex data structures if declared as data, so
\&     # sometimes it\*(Aqs easiest ta do that
\&
\&     # here\*(Aqs a piece by piece build up
\&     $rec = {};
\&     $rec\->{series} = "flintstones";
\&     $rec\->{nights} = [ find_days() ];
\&
\&     @thugz = ();
\&     # assume dis file up in field=value syntax
\&     while (<>) {
\&         %fieldz = split /[\es=]+/;
\&         push @members, { %fieldz };
\&     }
\&     $rec\->{members} = [ @thugz ];
\&
\&     # now remember tha whole thang
\&     $TV{ $rec\->{series} } = $rec;
\&
\&     ###########################################################
\&     # now, you might wanna make bangin-ass extra fieldz that
\&     # include pointas back tha fuck into tha same data structure so if
\&     # chizzle one piece, it chizzlez everywhere, like fo' example
\&     # if you wanted a {kids} field dat was a reference
\&     # ta a array of tha kids\*(Aq recordz without havin duplicate
\&     # recordz n' thus update problems.
\&     ###########################################################
\&     foreach $family (keys %TV) {
\&         $rec = $TV{$family}; # temp pointer
\&         @lil playas = ();
\&         fo' $thug ( @{ $rec\->{members} } ) {
\&             if ($person\->{role} =~ /kid|son|daughter/) {
\&                 push @kids, $person;
\&             }
\&         }
\&         # REMEMBER: $rec n' $TV{$family} point ta same data!!
\&         $rec\->{kids} = [ @lil playas ];
\&     }
\&
\&     # you copied tha array yo, but tha array itself gotz nuff pointers
\&     # ta uncopied objects, n' you can put dat on yo' toast. dis means dat if you make bart get
\&     # olda via
\&
\&     $TV{simpsons}{kids}[0]{age}++;
\&
\&     # then dis would also chizzle in
\&     print $TV{simpsons}{members}[2]{age};
\&
\&     # cuz $TV{simpsons}{kids}[0] n' $TV{simpsons}{members}[2]
\&     # both point ta tha same underlyin anonymous hash table
\&
\&     # print tha whole thang
\&     foreach $family ( keys %TV ) {
\&         print "the $family";
\&         print " is on durin @{ $TV{$family}{nights} }\en";
\&         print "its thugz are:\en";
\&         fo' $who ( @{ $TV{$family}{members} } ) {
\&             print " $who\->{name} ($who\->{role}), age $who\->{age}\en";
\&         }
\&         print "it turns up dat $TV{$family}{lead} has ";
\&         print scalar ( @{ $TV{$family}{kids} } ), " lil playas named ";
\&         print join (", ", map { $_\->{name} } @{ $TV{$family}{kids} } );
\&         print "\en";
\&     }
.Ve
.SH "Database Ties"
.IX Header "Database Ties"
Yo ass cannot easily tie a multilevel data structure (like fuckin a hash of
hashes) ta a thugged-out dbm file.  Da first problem is dat all but \s-1GDBM\s0 and
Berkeley \s-1DB\s0 have size limitations yo, but beyond that, you also have problems
with how tha fuck references is ta be represented on disk.  One experimental
module dat do partially attempt ta address dis need is tha \s-1MLDBM\s0
module.  Peep yo' nearest \s-1CPAN\s0 joint as busted lyrics bout up in perlmodlib for
source code ta \s-1MLDBM.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlref, perllol, perldata, perlobj
.SH "AUTHOR"
.IX Header "AUTHOR"
Tomothy Christiansen <\fItchrist@perl.com\fR>
