.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERL56DELTA 1"
.TH PERL56DELTA 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perl56delta \- whatz freshly smoked up fo' perl v5.6.0
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document raps bout differences between tha 5.005 release n' tha 5.6.0
release.
.SH "Core Enhancements"
.IX Header "Core Enhancements"
.SS "Interpreta cloning, threads, n' concurrency"
.IX Subsection "Interpreta cloning, threads, n' concurrency"
Perl 5.6.0 introduces tha beginningz of support fo' hustlin multiple
interpretas concurrently up in different threads.  In conjunction with
the \fIperl_clone()\fR \s-1API\s0 call, which can be used ta selectively duplicate
the state of any given interpreter, it is possible ta compile a
piece of code once up in a interpreter, clone dat interpreter
one or mo' times, n' run all tha resultin interpretas up in distinct
threads.
.PP
On tha Windows platform, dis feature is used ta emulate \fIfork()\fR at the
interpreta level.  See perlfork fo' details bout dis shit.
.PP
This feature is still up in evolution. I aint talkin' bout chicken n' gravy biatch.  It be eventually meant ta be used
to selectively clone a subroutine n' data reachable from that
subroutine up in a separate interpreta n' run tha cloned subroutine
in a separate thread. Y'all KNOW dat shit, muthafucka!  Since there is no shared data between the
interpreters, lil or no lockin is ghon be needed (unless parts of
the symbol table is explicitly shared).  This is obviously intended
to be a easy as fuck -to-use replacement fo' tha existin threadz support.
.PP
Support fo' clonin interpretas n' interpreta concurrency can be
enabled rockin tha \-Dusethreadz Configure option (see win32/Makefile for
how ta enable it on Windows.)  Da resultin perl executable will be
functionally identical ta one dat was built wit \-Dmultiplicitizzle yo, but
the \fIperl_clone()\fR \s-1API\s0 call will only be available up in tha former.
.PP
\&\-Dusethreadz enablez tha cpp macro \s-1USE_ITHREADS\s0 by default, which up in turn
enablez Perl source code chizzlez dat provide a cold-ass lil clear separation between
the op tree n' tha data it operates with.  Da forma is immutable, and
can therefore be shared between a interpreta n' all of its clones,
while tha latta is considered local ta each interpreter, n' is therefore
copied fo' each clone.
.PP
Note dat buildin Perl wit tha \-Dusemultiplicitizzle Configure option
is adequate if you wish ta run multiple \fBindependent\fR interpreters
concurrently up in different threads.  \-Dusethreadz only serves up the
additionizzle functionalitizzle of tha \fIperl_clone()\fR \s-1API\s0 call n' other
support fo' hustlin \fBcloned\fR interpretas concurrently.
.PP
.Vb 2
\&    NOTE: This be a experimenstrual feature.  Implementation details are
\&    subject ta chizzle.
.Ve
.SS "Lexically scoped warnin categories"
.IX Subsection "Lexically scoped warnin categories"
Yo ass can now control tha granularitizzle of warnings emitted by perl at a gangbangin' finer
level rockin tha \f(CW\*(C`use warnings\*(C'\fR pragma.  warnings n' perllexwarn
have copious documentation on dis feature.
.SS "Unicode n' \s-1UTF\-8\s0 support"
.IX Subsection "Unicode n' UTF-8 support"
Perl now uses \s-1UTF\-8\s0 as its internal representation fo' character
strings.  Da \f(CW\*(C`utf8\*(C'\fR n' \f(CW\*(C`bytes\*(C'\fR pragmas is used ta control dis support
in tha current lexical scope.  See perlunicode, utf8 n' bytes for
more shiznit.
.PP
This feature is sposed ta fuckin evolve quickly ta support some form of I/O
disciplines dat can be used ta specify tha kind of input n' output data
(bytes or characters).  Until dat happens, additionizzle modulez from \s-1CPAN\s0
will be needed ta complete tha toolkit fo' dealin wit Unicode.
.PP
.Vb 2
\&    NOTE: This should be considered a experimenstrual feature.  Implementation
\&    details is subject ta chizzle.
.Ve
.SS "Support fo' interpolatin named characters"
.IX Subsection "Support fo' interpolatin named characters"
Da freshly smoked up \f(CW\*(C`\eN\*(C'\fR escape interpolates named charactas within strings.
For example, \f(CW"Hi! \eN{WHITE SMILING FACE}"\fR evaluates ta a string
with a unicode smiley grill all up in tha end.
.ie n .SS """our"" declarations"
.el .SS "``our'' declarations"
.IX Subsection "our declarations"
An \*(L"our\*(R" declaration introduces a value dat can be dopest understood
as a lexically scoped symbolic alias ta a global variable up in the
package dat was current where tha variable was declared. Y'all KNOW dat shit, muthafucka!  This is
mostly useful as a alternatizzle ta tha \f(CW\*(C`vars\*(C'\fR pragma yo, but also provides
the opportunitizzle ta introduce typin n' other attributes fo' such
variables.  See \*(L"our\*(R" up in perlfunc.
.SS "Support fo' strings represented as a vector of ordinals"
.IX Subsection "Support fo' strings represented as a vector of ordinals"
Literalz of tha form \f(CW\*(C`v1.2.3.4\*(C'\fR is now parsed as a strang composed
of charactas wit tha specified ordinals.  This be a alternative, more
readable way ta construct (possibly unicode) strings instead of
interpolatin characters, as up in \f(CW"\ex{1}\ex{2}\ex{3}\ex{4}"\fR.  Da leading
\&\f(CW\*(C`v\*(C'\fR may be omitted if there be mo' than two ordinals, so \f(CW1.2.3\fR is
parsed tha same as \f(CW\*(C`v1.2.3\*(C'\fR.
.PP
Strings freestyled up in dis form is also useful ta represent version \*(L"numbers\*(R".
It be easy as fuck  ta compare such version \*(L"numbers\*(R" (which is straight-up just plain
strings) rockin any of tha usual strang comparison operators \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR,
\&\f(CW\*(C`lt\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, etc., or big-ass up bitwise strang operations on dem rockin \f(CW\*(C`|\*(C'\fR,
\&\f(CW\*(C`&\*(C'\fR, etc.
.PP
In conjunction wit tha freshly smoked up \f(CW$^V\fR magic variable (which gotz nuff
the perl version as a string), such literals can be used as a readable way
to check if you hustlin a particular version of Perl:
.PP
.Vb 4
\&    # dis will parse up in olda versionz of Perl also
\&    if ($^V n' $^V gt v5.6.0) {
\&        # freshly smoked up features supported
\&    }
.Ve
.PP
\&\f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`use\*(C'\fR also have some special magic ta support such
literals yo, but dis particular usage should be avoided cuz it leadz to
misleadin error lyrics under versionz of Perl which don't support vector
strings.  Usin a legit version number will ensure erect behavior up in all
versionz of Perl:
.PP
.Vb 2
\&    require 5.006;    # run time check fo' v5.6
\&    use 5.006_001;    # compile time check fo' v5.6.1
.Ve
.PP
Also, \f(CW\*(C`sprintf\*(C'\fR n' \f(CW\*(C`printf\*(C'\fR support tha Perl-specific format flag \f(CW%v\fR
to print ordinalz of charactas up in arbitrary strings:
.PP
.Vb 3
\&    printf "v%vd", $^V;         # prints current version, like fuckin "v5.5.650"
\&    printf "%*vX", ":", $addr;  # formats IPv6 address
\&    printf "%*vb", " ", $bits;  # displays bitstring
.Ve
.PP
See \*(L"Scalar value constructors\*(R" up in perldata fo' additionizzle shiznit.
.SS "Improved Perl version numberin system"
.IX Subsection "Improved Perl version numberin system"
Beginnin wit Perl version 5.6.0, tha version number convention has been
changed ta a \*(L"dotted integer\*(R" scheme dat is mo' commonly found up in open
source projects.
.PP
Maintenizzle versionz of v5.6.0 is ghon be busted out as v5.6.1, v5.6.2 etc.
Da next pimpment series followin v5.6.0 is ghon be numbered v5.7.x,
beginnin wit v5.7.0, n' tha next major thang release following
v5.6.0 is ghon be v5.8.0.
.PP
Da Gangsta module now sets \f(CW$PERL_VERSION\fR ta $^V (a strang value) rather
than \f(CW$]\fR (a numeric value).  (This be a potential incompatibility.
Send our asses a report via perlbug if yo ass be affected by all dis bullshit.)
.PP
Da v1.2.3 syntax be also now legal up in Perl.
See \*(L"Support fo' strings represented as a vector of ordinals\*(R" fo' mo' on dis shit.
.PP
To cope wit tha freshly smoked up versionin systemz use of at least three significant
digits fo' each version component, tha method used fo' incrementin the
subversion number has also chizzled slightly.  We assume dat versions older
than v5.6.0 done been incrementin tha subversion component up in multiplez of
10.  Versions afta v5.6.0 will increment dem by 1.  Thus, rockin tha new
notation, 5.005_03 is tha \*(L"same\*(R" as v5.5.30, n' tha straight-up original gangsta maintenance
version followin v5.6.0 is ghon be v5.6.1 (which should be read as being
equivalent ta a gangbangin' floatin point value of 5.006_001 up in tha olda format,
stored up in \f(CW$]\fR).
.SS "New syntax fo' declarin subroutine attributes"
.IX Subsection "New syntax fo' declarin subroutine attributes"
Formerly, if you wanted ta mark a subroutine as bein a method call or
as requirin a automatic \fIlock()\fR when it is entered, you had ta declare
that wit a \f(CW\*(C`use attrs\*(C'\fR pragma up in tha body of tha subroutine.
That can now be accomplished wit declaration syntax, like this:
.PP
.Vb 5
\&    sub mymethod : locked method;
\&    ...
\&    sub mymethod : locked method {
\&        ...
\&    }
\&
\&    sub othermethod :locked :method;
\&    ...
\&    sub othermethod :locked :method {
\&        ...
\&    }
.Ve
.PP
(Note how tha fuck only tha straight-up original gangsta \f(CW\*(C`:\*(C'\fR is mandatory, n' whitespace surrounding
the \f(CW\*(C`:\*(C'\fR is optional.)
.PP
\&\fIAutoSplit.pm\fR n' \fISelfLoader.pm\fR done been updated ta keep tha attributes
with tha stubs they provide.  See attributes.
.SS "File n' directory handlez can be autovivified"
.IX Subsection "File n' directory handlez can be autovivified"
Similar ta how tha fuck constructs like fuckin \f(CW\*(C`$x\->[0]\*(C'\fR autovivify a reference,
handle constructors (\fIopen()\fR, \fIopendir()\fR, \fIpipe()\fR, \fIsocketpair()\fR, \fIsysopen()\fR,
\&\fIsocket()\fR, n' \fIaccept()\fR) now autovivify a gangbangin' file or directory handle
if tha handle passed ta dem be a uninitialized scalar variable.  This
allows tha constructs like fuckin \f(CW\*(C`open(my $fh, ...)\*(C'\fR n' \f(CW\*(C`open(local $fh,...)\*(C'\fR
to be used ta create filehandlez dat will conveniently be closed
automatically when tha scope ends, provided there be no other references
to em.  This largely eliminates tha need fo' typeglobs when opening
filehandlez dat must be passed around, as up in tha followin example:
.PP
.Vb 5
\&    sub myopen {
\&        open mah $fh, "@_"
\&             or take a thugged-out dirtnap "Can\*(Aqt open \*(Aq@_\*(Aq: $!";
\&        return $fh;
\&    }
\&
\&    {
\&        mah $f = myopen("</etc/motd");
\&        print <$f>;
\&        # $f implicitly closed here
\&    }
.Ve
.SS "\fIopen()\fP wit mo' than two arguments"
.IX Subsection "open() wit mo' than two arguments"
If \fIopen()\fR is passed three arguments instead of two, tha second argument
is used as tha mode n' tha third argument is taken ta be tha file name.
This is primarily useful fo' protectin against unintended magic behavior
of tha traditionizzle two-argument form.  See \*(L"open\*(R" up in perlfunc.
.SS "64\-bit support"
.IX Subsection "64-bit support"
Any platform dat has 64\-bit integers either
.PP
.Vb 3
\&        (1) natively as longs or ints
\&        (2) via special compila flags
\&        (3) rockin long long or int64_t
.Ve
.PP
is able ta use \*(L"quads\*(R" (64\-bit integers) as bigs up:
.IP "\(bu" 4
constants (decimal, hexadecimal, octal, binary) up in tha code
.IP "\(bu" 4
arguments ta \fIoct()\fR n' \fIhex()\fR
.IP "\(bu" 4
arguments ta \fIprint()\fR, \fIprintf()\fR n' \fIsprintf()\fR (flag prefixes ll, L, q)
.IP "\(bu" 4
printed as such
.IP "\(bu" 4
\&\fIpack()\fR n' \fIunpack()\fR \*(L"q\*(R" n' \*(L"Q\*(R" formats
.IP "\(bu" 4
in basic arithmetics: + \- * / % (\s-1NOTE:\s0 operatin close ta tha limits
of tha integer joints may produce surprisin thangs up in dis biatch)
.IP "\(bu" 4
in bit arithmetics: & | ^ ~ << >> (\s-1NOTE:\s0 these used ta be forced 
to be 32 bits wide but now operate on tha full natizzle width.)
.IP "\(bu" 4
\&\fIvec()\fR
.PP
Note dat unless you have tha case (a) yo big-ass booty is ghon gotta configure
and compile Perl rockin tha \-Duse64bitint Configure flag.
.PP
.Vb 2
\&    NOTE: Da Configure flags \-Duselonglong n' \-Duse64bits have been
\&    deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use \-Duse64bitint instead.
.Ve
.PP
There is straight-up two modez of 64\-bitness: tha straight-up original gangsta one be  bigged up 
usin Configure \-Duse64bitint n' tha second one rockin Configure
\&\-Duse64bitall.  Da difference is dat tha straight-up original gangsta one is minimal and
the second one maximal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da first works up in mo' places than tha second.
.PP
Da \f(CW\*(C`use64bitint\*(C'\fR do only as much as is required ta git 64\-bit
integers tha fuck into Perl (this may mean, fo' example, rockin \*(L"long longs\*(R")
while yo' memory may still be limited ta 2 gigabytes (because your
pointas could still be 32\-bit).  Note dat tha name \f(CW\*(C`64bitint\*(C'\fR do
not imply dat yo' C compila is ghon be rockin 64\-bit \f(CW\*(C`int\*(C'\fRs (it might,
but it aint gots to): tha \f(CW\*(C`use64bitint\*(C'\fR means dat yo big-ass booty is ghon be
able ta have 64 bits wide scalar joints.
.PP
Da \f(CW\*(C`use64bitall\*(C'\fR goes all tha way by attemptin ta switch also
integers (if it can), longs (and pointers) ta bein 64\-bit.  This may
create a even mo' binary incompatible Perl than \-Duse64bitint: the
resultin executable may not run at all up in a 32\-bit box, or you may
have ta reboot/reconfigure/rebuild yo' operatin system ta be 64\-bit
aware.
.PP
Natively 64\-bit systems like Alpha n' Cray need neither \-Duse64bitint
nor \-Duse64bitall.
.PP
Last but not least: note dat cuz of Perlz g-thang of always using
floatin point numbers, tha quadz is still not legit integers.
When quadz overflow they limits (0...18_446_744_073_709_551_615 unsigned,
\&\-9_223_372_036_854_775_808...9_223_372_036_854_775_807 signed), they
are silently promoted ta floatin point numbers, afta which they will
start losin precision (in they lower digits).
.PP
.Vb 4
\&    NOTE: 64\-bit support is still experimenstrual on most platforms.
\&    Existin support only covers tha LP64 data model.  In particular, the
\&    LLP64 data model aint yet supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  64\-bit libraries n' system
\&    APIs on nuff platforms aint stabilized\-\-your mileage may vary.
.Ve
.SS "Big-Ass file support"
.IX Subsection "Big-Ass file support"
If you have filesystems dat support \*(L"pimpin' files\*(R" (filez larger than
2 gigabytes), you may now also be able ta create n' access dem from
Perl.
.PP
.Vb 2
\&    NOTE: Da default action is ta enable big-ass file support, if
\&    available on tha platform.
.Ve
.PP
If tha big-ass file support is on, n' you gotz a Fcntl constant
O_LARGEFILE, tha O_LARGEFILE be automatically added ta tha flags
of \fIsysopen()\fR.
.PP
Beware dat unless yo' filesystem also supports \*(L"sparse files\*(R" seeking
to umpteen petabytes may be inadvisable.
.PP
Note dat up in addizzle ta requirin a proper file system ta do large
filez you may also need ta adjust yo' per-process (or your
per-system, or per-process-group, or per-user-group) maximum filesize
limits before hustlin Perl scripts dat try ta handle big-ass files,
especially if you intend ta write such files.
.PP
Finally, up in addizzle ta yo' process/process crew maximum filesize
limits, you may have quota limits on yo' filesystems dat stop you
(your user id or yo' user crew id) from rockin big-ass files.
.PP
Adjustin yo' process/user/group/file system/operatin system limits
is outside tha scope of Perl core language.  For process limits, you
may try increasin tha limits rockin yo' shellz limits/limit/ulimit
command before hustlin Perl.  Da BSD::Resource extension (not
included wit tha standard Perl distribution) may also be of use, it
offers tha getrlimit/setrlimit intercourse dat can be used ta adjust
process resource usage limits, includin tha maximum filesize limit.
.SS "Long doubles"
.IX Subsection "Long doubles"
In some systems you may be able ta use long doublez ta enhizzle the
range n' precision of yo' double precision floatin point numbers
(that is, Perlz numbers).  Use Configure \-Duselongdouble ta enable
this support (if it be available).
.ie n .SS """more bits"""
.el .SS "``more bits''"
.IX Subsection "more bits"
Yo ass can \*(L"Configure \-Dusemorebits\*(R" ta turn on both tha 64\-bit support
and tha long double support.
.SS "Enhanced support fo' \fIsort()\fP subroutines"
.IX Subsection "Enhanced support fo' sort() subroutines"
Perl subroutines wit a prototype of \f(CW\*(C`($$)\*(C'\fR, n' XSUBs up in general, can
now be used as sort subroutines.  In either case, tha two elements to
be compared is passed as aiiight parametas up in \f(CW@_\fR.  See \*(L"sort\*(R" up in perlfunc.
.PP
For unprototyped sort subroutines, tha oldschool behavior of passin 
the elements ta be compared as tha global variablez \f(CW$a\fR n' \f(CW$b\fR remains
unchanged.
.ie n .SS """sort $coderef @foo"" allowed"
.el .SS "\f(CWsort $coderef @foo\fP allowed"
.IX Subsection "sort $coderef @foo allowed"
\&\fIsort()\fR did not accept a subroutine reference as tha comparison
function up in earlier versions.  This is now permitted.
.SS "File globbin implemented internally"
.IX Subsection "File globbin implemented internally"
Perl now uses tha File::Glob implementation of tha \fIglob()\fR operator
automatically.  This avoidz rockin a external csh process n' the
problems associated wit dat shit.
.PP
.Vb 2
\&    NOTE: This is currently a experimenstrual feature.  Interfaces and
\&    implementation is subject ta chizzle.
.Ve
.SS "Support fo' \s-1CHECK\s0 blocks"
.IX Subsection "Support fo' CHECK blocks"
In addizzle ta \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR, \f(CW\*(C`END\*(C'\fR, \f(CW\*(C`DESTROY\*(C'\fR n' \f(CW\*(C`AUTOLOAD\*(C'\fR,
subroutines named \f(CW\*(C`CHECK\*(C'\fR is now special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  These is queued up during
compilation n' behave similar ta \s-1END\s0 blocks, except they is called at
the end of compilation rather than all up in tha end of execution. I aint talkin' bout chicken n' gravy biatch.  They cannot
be called directly.
.SS "\s-1POSIX\s0 characta class syntax [: :] supported"
.IX Subsection "POSIX characta class syntax [: :] supported"
For example ta match alphabetic charactas use /[[:alpha:]]/.
See perlre fo' details.
.SS "Betta pseudo-random number generator"
.IX Subsection "Betta pseudo-random number generator"
In 5.005_0x n' earlier, perlz \fIrand()\fR function used tha C library
\&\fIrand\fR\|(3) function. I aint talkin' bout chicken n' gravy biatch.  Az of 5.005_52, Configure tests fo' \fIdrand48()\fR,
\&\fIrandom()\fR, n' \fIrand()\fR (in dat order) n' picks tha straight-up original gangsta one it finds.
.PP
These chizzlez should result up in betta random numbers from \fIrand()\fR.
.ie n .SS "Improved ""qw//"" operator"
.el .SS "Improved \f(CWqw//\fP operator"
.IX Subsection "Improved qw// operator"
Da \f(CW\*(C`qw//\*(C'\fR operator is now evaluated at compile time tha fuck into a legit list
instead of bein replaced wit a run time call ta \f(CW\*(C`split()\*(C'\fR.  This
removes tha confusin misbehaviour of \f(CW\*(C`qw//\*(C'\fR up in scalar context, which
had inherited dat behaviour from \fIsplit()\fR.
.PP
Thus:
.PP
.Vb 1
\&    $foo = ($bar) = qw(a b c); print "$foo|$bar\en";
.Ve
.PP
now erectly prints \*(L"3|a\*(R", instead of \*(L"2|a\*(R".
.SS "Betta worst-case behavior of hashes"
.IX Subsection "Betta worst-case behavior of hashes"
Lil Small-Ass chizzlez up in tha hashin algorithm done been implemented in
order ta improve tha distribution of lower order bits up in the
hashed value.  This is sposed ta fuckin yield betta performizzle on
keys dat is repeated sequences.
.SS "\fIpack()\fP format 'Z' supported"
.IX Subsection "pack() format 'Z' supported"
Da freshly smoked up format type 'Z' is useful fo' packin n' unpackin null-terminated
strings.  See \*(L"pack\*(R" up in perlfunc.
.SS "\fIpack()\fP format modifier '!' supported"
.IX Subsection "pack() format modifier '!' supported"
Da freshly smoked up format type modifier '!' is useful fo' packin n' unpacking
natizzle shorts, ints, n' longs.  See \*(L"pack\*(R" up in perlfunc.
.SS "\fIpack()\fP n' \fIunpack()\fP support counted strings"
.IX Subsection "pack() n' unpack() support counted strings"
Da template characta '/' can be used ta specify a cold-ass lil counted string
type ta be packed or unpacked. Y'all KNOW dat shit, muthafucka!  See \*(L"pack\*(R" up in perlfunc.
.SS "Comments up in \fIpack()\fP templates"
.IX Subsection "Comments up in pack() templates"
Da '#' characta up in a template introduces a cold-ass lil comment up to
end of tha line.  This facilitates documentation of \fIpack()\fR
templates.
.SS "Weak references"
.IX Subsection "Weak references"
In previous versionz of Perl, you couldn't cache objects so as
to allow dem ta be deleted if tha last reference from outside 
the cache is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da reference up in tha cache would hold a
reference count on tha object n' tha objects would never be
destroyed.
.PP
Another familiar problem is wit circular references.  When an
object references itself, its reference count would never go
down ta zero, n' it would not git destroyed until tha program
is bout ta exit.
.PP
Weak references solve dis by allowin you ta \*(L"weaken\*(R" any
reference, dat is, make it not count towardz tha reference count.
When tha last non-weak reference ta a object is deleted, tha object
is destroyed n' all tha weak references ta tha object are
automatically undef-ed.
.PP
To use dis feature, you need tha Devel::WeakRef package from \s-1CPAN,\s0 which
gotz nuff additionizzle documentation.
.PP
.Vb 1
\&    NOTE: This be a experimenstrual feature.  Details is subject ta chizzle.
.Ve
.SS "Binary numbers supported"
.IX Subsection "Binary numbers supported"
Binary numbers is now supported as literals, up in s?printf formats, and
\&\f(CW\*(C`oct()\*(C'\fR:
.PP
.Vb 2
\&    $answer = 0b101010;
\&    printf "Da answer is: %b\en", oct("0b101010");
.Ve
.SS "Lvalue subroutines"
.IX Subsection "Lvalue subroutines"
Subroutines can now return modifiable lvalues.
See \*(L"Lvalue subroutines\*(R" up in perlsub.
.PP
.Vb 1
\&    NOTE: This be a experimenstrual feature.  Details is subject ta chizzle.
.Ve
.SS "Some arrows may be omitted up in calls all up in references"
.IX Subsection "Some arrows may be omitted up in calls all up in references"
Perl now allows tha arrow ta be omitted up in nuff constructs
involvin subroutine calls all up in references.  For example,
\&\f(CW\*(C`$foo[10]\->(\*(Aqfoo\*(Aq)\*(C'\fR may now be freestyled \f(CW\*(C`$foo[10](\*(Aqfoo\*(Aq)\*(C'\fR.
This is rather similar ta how tha fuck tha arrow may be omitted from
\&\f(CW\*(C`$foo[10]\->{\*(Aqfoo\*(Aq}\*(C'\fR.  Note however, dat tha arrow is still
required fo' \f(CW\*(C`foo(10)\->(\*(Aqbar\*(Aq)\*(C'\fR.
.SS "Boolean assignment operators is legal lvalues"
.IX Subsection "Boolean assignment operators is legal lvalues"
Constructs like fuckin \f(CW\*(C`($a ||= 2) += 1\*(C'\fR is now allowed.
.SS "\fIexists()\fP is supported on subroutine names"
.IX Subsection "exists() is supported on subroutine names"
Da \fIexists()\fR builtin now works on subroutine names.  A subroutine
is considered ta exist if it has been declared (even if implicitly).
See \*(L"exists\*(R" up in perlfunc fo' examples.
.SS "\fIexists()\fP n' \fIdelete()\fP is supported on array elements"
.IX Subsection "exists() n' delete() is supported on array elements"
Da \fIexists()\fR n' \fIdelete()\fR builtins now work on simple arrays as well.
Da behavior is similar ta dat on hash elements.
.PP
\&\fIexists()\fR can be used ta check whether a array element has been
initialized. Y'all KNOW dat shit, muthafucka!  This avoidz autovivifyin array elements dat don't exist.
If tha array is tied, tha \s-1\fIEXISTS\s0()\fR method up in tha correspondin tied
package is ghon be invoked.
.PP
\&\fIdelete()\fR may be used ta remove a element from tha array n' return
it.  Da array element at dat posizzle returns ta its uninitialized
state, so dat testin fo' tha same element wit \fIexists()\fR will return
false.  If tha element happens ta be tha one all up in tha end, tha size of
the array also shrinks up ta tha highest element dat tests legit for
\&\fIexists()\fR, or 0 if none such is found. Y'all KNOW dat shit, muthafucka!  If tha array is tied, tha \s-1\fIDELETE\s0()\fR 
method up in tha correspondin tied package is ghon be invoked.
.PP
See \*(L"exists\*(R" up in perlfunc n' \*(L"delete\*(R" up in perlfunc fo' examples.
.SS "Pseudo-hashes work better"
.IX Subsection "Pseudo-hashes work better"
Dereferencin some typez of reference joints up in a pseudo-hash,
like fuckin \f(CW\*(C`$ph\->{foo}[1]\*(C'\fR, was accidentally disallowed. Y'all KNOW dat shit, muthafucka!  This has
been erected.
.PP
When applied ta a pseudo-hash element, \fIexists()\fR now reports whether
the specified value exists, not merely if tha key is valid.
.PP
\&\fIdelete()\fR now works on pseudo-hashes.  When given a pseudo-hash element
or slice it deletes tha joints correspondin ta tha keys (but not tha keys
themselves).  See \*(L"Pseudo-hashes: Usin a array as a hash\*(R" up in perlref.
.PP
Pseudo-hash slices wit constant keys is now optimized ta array lookups
at compile-time.
.PP
List assignments ta pseudo-hash slices is now supported.
.PP
Da \f(CW\*(C`fields\*(C'\fR pragma now serves up ways ta create pseudo-hashes, via
\&\fIfields::new()\fR n' \fIfields::phash()\fR.  See fields.
.PP
.Vb 3
\&    NOTE: Da pseudo\-hash data type continues ta be experimental.
\&    Limitin oneself ta tha intercourse elements provided by the
\&    fieldz pragma will provide protection from any future chizzles.
.Ve
.SS "Automatic flushin of output buffers"
.IX Subsection "Automatic flushin of output buffers"
\&\fIfork()\fR, \fIexec()\fR, \fIsystem()\fR, qx//, n' pipe \fIopen()\fRs now flush buffers
of all filez opened fo' output when tha operation was attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This
mostly eliminates confusin bufferin mishaps suffered by playas unaware
of how tha fuck Perl internally handlez I/O.
.PP
This aint supported on some platforms like Solaris where a suitably
correct implementation of fflush(\s-1NULL\s0) aint available.
.SS "Betta diagnostics on meaningless filehandle operations"
.IX Subsection "Betta diagnostics on meaningless filehandle operations"
Constructs like fuckin \f(CW\*(C`open(<FH>)\*(C'\fR n' \f(CW\*(C`close(<FH>)\*(C'\fR
are compile time errors.  Attemptin ta read from filehandlez that
were opened only fo' freestylin will now produce warnings (just as
writin ta read-only filehandlez do).
.SS "Where possible, buffered data discarded from duped input filehandle"
.IX Subsection "Where possible, buffered data discarded from duped input filehandle"
\&\f(CW\*(C`open(NEW, "<&OLD")\*(C'\fR now attempts ta discard any data that
was previously read n' buffered up in \f(CW\*(C`OLD\*(C'\fR before dupin tha handle.
On platforms where bustin dis be allowed, tha next read operation
on \f(CW\*(C`NEW\*(C'\fR will return tha same data as tha correspondin operation
on \f(CW\*(C`OLD\*(C'\fR.  Formerly, it would have returned tha data from tha start
of tha followin disk block instead.
.SS "\fIeof()\fP has tha same ol' dirty oldschool magic as <>"
.IX Subsection "eof() has tha same ol' dirty oldschool magic as <>"
\&\f(CW\*(C`eof()\*(C'\fR would return legit if no attempt ta read from \f(CW\*(C`<>\*(C'\fR had
yet been made.  \f(CW\*(C`eof()\*(C'\fR has been chizzled ta git a lil magic of its
own, it now opens tha \f(CW\*(C`<>\*(C'\fR files.
.SS "\fIbinmode()\fP can be used ta set :crlf n' :raw modes"
.IX Subsection "binmode() can be used ta set :crlf n' :raw modes"
\&\fIbinmode()\fR now accepts a second argument dat specifies a gangbangin' finger-lickin' discipline
for tha handle up in question. I aint talkin' bout chicken n' gravy biatch.  Da two pseudo-disciplines \*(L":raw\*(R" and
\&\*(L":crlf\*(R" is currently supported on DOS-derivatizzle platforms.
See \*(L"binmode\*(R" up in perlfunc n' open.
.ie n .SS """\-T"" filetest recognizes \s-1UTF\-8\s0 encoded filez as ""text"""
.el .SS "\f(CW\-T\fP filetest recognizes \s-1UTF\-8\s0 encoded filez as ``text''"
.IX Subsection "-T filetest recognizes UTF-8 encoded filez as text"
Da algorithm used fo' tha \f(CW\*(C`\-T\*(C'\fR filetest has been enhanced to
correctly identify \s-1UTF\-8\s0 content as \*(L"text\*(R".
.SS "\fIsystem()\fP, backticks n' pipe open now reflect \fIexec()\fP failure"
.IX Subsection "system(), backticks n' pipe open now reflect exec() failure"
On Unix n' similar platforms, \fIsystem()\fR, \fIqx()\fR n' open(\s-1FOO, \s0\*(L"cmd |\*(R")
etc., is implemented via \fIfork()\fR n' \fIexec()\fR.  When tha underlying
\&\fIexec()\fR fails, earlier versions did not report tha error properly,
since tha \fIexec()\fR happened ta be up in a gangbangin' finger-lickin' different process.
.PP
Da lil pimp process now communicates wit tha parent bout the
error up in launchin tha external command, which allows these
constructs ta return wit they usual error value n' set $!.
.SS "Improved diagnostics"
.IX Subsection "Improved diagnostics"
Line numbers is no longer suppressed (under most likely circumstances)
durin tha global destruction phase.
.PP
Diagnostics emitted from code hustlin up in threadz other than tha main
thread is now accompanied by tha thread \s-1ID.\s0
.PP
Embedded null charactas up in diagnostics now straight-up show up.  They
used ta truncate tha message up in prior versions.
.PP
\&\f(CW$foo::a\fR n' \f(CW$foo::b\fR is now exempt from \*(L"possible typo\*(R" warnings only
if \fIsort()\fR is encountered up in package \f(CW\*(C`foo\*(C'\fR.
.PP
Unrecognized alphabetic escapes encountered when parsin quote
constructs now generate a warning, since they may take on new
semantics up in lata versionz of Perl.
.PP
Many diagnostics now report tha internal operation up in which tha warning
was provoked, like so:
.PP
.Vb 2
\&    Use of uninitialized value up in concatenation (.) at (eval 1) line 1.
\&    Use of uninitialized value up in print at (eval 1) line 1.
.Ve
.PP
Diagnostics  dat occur within eval may also report tha file n' line
number where tha eval is located, up in addizzle ta tha eval sequence
number n' tha line number within tha evaluated text itself.  For
example:
.PP
.Vb 1
\&    Not enough arguments fo' scalar at (eval 4)[newlib/perl5db.pl:1411] line 2, at EOF
.Ve
.SS "Diagnostics follow \s-1STDERR\s0"
.IX Subsection "Diagnostics follow STDERR"
Diagnostic output now goes ta whichever file tha \f(CW\*(C`STDERR\*(C'\fR handle
is pointin at, instead of always goin ta tha underlyin C runtime
libraryz \f(CW\*(C`stderr\*(C'\fR.
.SS "Mo' consistent close-on-exec behavior"
.IX Subsection "Mo' consistent close-on-exec behavior"
On systems dat support a cold-ass lil close-on-exec flag on filehandles, the
flag is now set fo' any handlez pimped by \fIpipe()\fR, \fIsocketpair()\fR,
\&\fIsocket()\fR, n' \fIaccept()\fR, if dat is warranted by tha value of $^F
that may be up in effect.  Earlier versions neglected ta set tha flag
for handlez pimped wit these operators.  See \*(L"pipe\*(R" up in perlfunc,
\&\*(L"socketpair\*(R" up in perlfunc, \*(L"socket\*(R" up in perlfunc, \*(L"accept\*(R" up in perlfunc,
and \*(L"$^F\*(R" up in perlvar.
.SS "\fIsyswrite()\fP ease-of-use"
.IX Subsection "syswrite() ease-of-use"
Da length argument of \f(CW\*(C`syswrite()\*(C'\fR has become optional.
.SS "Betta syntax checks on parenthesized unary operators"
.IX Subsection "Betta syntax checks on parenthesized unary operators"
Expressions such as:
.PP
.Vb 3
\&    print defined(&foo,&bar,&baz);
\&    print uc("foo","bar","baz");
\&    undef($foo,&bar);
.Ve
.PP
used ta be accidentally allowed up in earlier versions, n' produced
unpredictable behaviour. Shiiit, dis aint no joke.  Some produced ancillary warnings
when used up in dis way; others silently did tha wack thang.
.PP
Da parenthesized formz of most unary operators dat expect a single
argument now ensure dat they is not called wit mo' than one
argument, makin tha cases shown above syntax errors.  Da usual
behaviour of:
.PP
.Vb 3
\&    print defined &foo, &bar, &baz;
\&    print uc "foo", "bar", "baz";
\&    undef $foo, &bar;
.Ve
.PP
remains unchanged. Y'all KNOW dat shit, muthafucka!  See perlop.
.SS "Bit operators support full natizzle integer width"
.IX Subsection "Bit operators support full natizzle integer width"
Da bit operators (& | ^ ~ << >>) now operate on tha full native
integral width (the exact size of which be available up in \f(CW$Config\fR{ivsize}).
For example, if yo' platform is either natively 64\-bit or if Perl
has been configured ta use 64\-bit integers, these operations apply
to 8 bytes (as opposed ta 4 bytes on 32\-bit platforms).
For portability, be shizzle ta mask off tha excess bits up in tha result of
unary \f(CW\*(C`~\*(C'\fR, e.g., \f(CW\*(C`~$x & 0xffffffff\*(C'\fR.
.SS "Improved securitizzle features"
.IX Subsection "Improved securitizzle features"
Mo' potentially unsafe operations taint they thangs up in dis biatch fo' improved
security.
.PP
Da \f(CW\*(C`passwd\*(C'\fR n' \f(CW\*(C`shell\*(C'\fR fieldz returned by tha \fIgetpwent()\fR, \fIgetpwnam()\fR,
and \fIgetpwuid()\fR is now tainted, cuz tha user can affect they own
encrypted password n' login shell.
.PP
Da variable modified by \fIshmread()\fR, n' lyrics returned by \fImsgrcv()\fR
(and its object-oriented intercourse IPC::SysV::Msg::rcv) is also tainted,
because other untrusted processes can modify lyrics n' shared memory
segments fo' they own nefarious purposes.
.SS "Mo' functionizzle bareword prototype (*)"
.IX Subsection "Mo' functionizzle bareword prototype (*)"
Bareword prototypes done been rationalized ta enable dem ta be used
to override builtins dat accept barewordz n' interpret dem in
a special way, like fuckin \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR.
.PP
Arguments prototyped as \f(CW\*(C`*\*(C'\fR will now be visible within tha subroutine
as either a simple scalar or as a reference ta a typeglob.
See \*(L"Prototypes\*(R" up in perlsub.
.ie n .SS """require"" n' ""do"" may be overridden"
.el .SS "\f(CWrequire\fP n' \f(CWdo\fP may be overridden"
.IX Subsection "require n' do may be overridden"
\&\f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`do \*(Aqfile\*(Aq\*(C'\fR operations may be overridden locally
by importin subroutinez of tha same name tha fuck into tha current package 
(or globally by importin dem tha fuck into tha \s-1CORE::GLOBAL::\s0 namespace).
Overridin \f(CW\*(C`require\*(C'\fR will also affect \f(CW\*(C`use\*(C'\fR, provided tha override
is visible at compile-time.
See \*(L"Overridin Built-in Functions\*(R" up in perlsub.
.SS "$^X variablez may now have names longer than one character"
.IX Subsection "$^X variablez may now have names longer than one character"
Formerly, $^X was synonymous wit ${\*(L"\ecX\*(R"} yo, but $^XY was a syntax
error. Shiiit, dis aint no joke.  Now variable names dat begin wit a cold-ass lil control characta may be
arbitrarily long.  But fuck dat shiznit yo, tha word on tha street is dat fo' compatibilitizzle reasons, these variables
\&\fImust\fR be freestyled wit explicit braces, as \f(CW\*(C`${^XY}\*(C'\fR fo' example.
\&\f(CW\*(C`${^XYZ}\*(C'\fR is synonymous wit ${\*(L"\ecXYZ\*(R"}.  Variable names wit more
than one control character, like fuckin \f(CW\*(C`${^XY^Z}\*(C'\fR, is illegal.
.PP
Da oldschool syntax has not chizzled. Y'all KNOW dat shit, muthafucka!  As before, `^X' may be either a
literal control-X characta or tha two-characta sequence `caret' plus
`X'.  When braces is omitted, tha variable name stops afta the
control character n' shit.  Thus \f(CW"$^XYZ"\fR continues ta be synonymous with
\&\f(CW\*(C`$^X . "YZ"\*(C'\fR as before.
.PP
As before, lexical variablez may not have names beginnin wit control
characters.  As before, variablez whose names begin wit a cold-ass lil control
characta is always forced ta be up in package `main'.  All such variables
are reserved fo' future extensions, except dem dat begin with
\&\f(CW\*(C`^_\*(C'\fR, which may be used by user programs n' is guaranteed not to
acquire special meanin up in any future version of Perl.
.ie n .SS "New variable $^C reflects ""\-c"" switch"
.el .SS "New variable $^C reflects \f(CW\-c\fP switch"
.IX Subsection "New variable $^C reflects -c switch"
\&\f(CW$^C\fR has a funky-ass boolean value dat reflects whether perl is bein run
in compile-only mode (i.e. via tha \f(CW\*(C`\-c\*(C'\fR switch).  Since
\&\s-1BEGIN\s0 blocks is executed under such conditions, dis variable
enablez perl code ta determine whether actions dat make sense
only durin aiiight hustlin is warranted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See perlvar.
.SS "New variable $^V gotz nuff Perl version as a string"
.IX Subsection "New variable $^V gotz nuff Perl version as a string"
\&\f(CW$^V\fR gotz nuff tha Perl version number as a strang composed of
charactas whose ordinals match tha version numbers, i.e. v5.6.0.
This may be used up in strang comparisons.
.PP
See \f(CW\*(C`Support fo' strings represented as a vector of ordinals\*(C'\fR fo' an
example.
.SS "Optionizzle Y2K warnings"
.IX Subsection "Optionizzle Y2K warnings"
If Perl is built wit tha cpp macro \f(CW\*(C`PERL_Y2KWARN\*(C'\fR defined,
it emits optionizzle warnings when concatenatin tha number 19
with another number.
.PP
This behavior must be specifically enabled when hustlin Configure.
See \fI\s-1INSTALL\s0\fR n' \fI\s-1README.Y2K\s0\fR.
.SS "Arrays now always interpolate tha fuck into double-quoted strings"
.IX Subsection "Arrays now always interpolate tha fuck into double-quoted strings"
In double-quoted strings, arrays now interpolate, no matta what.  The
behavior up in earlier versionz of perl 5 was dat arrays would interpolate
into strings if tha array had been mentioned before tha strang was
compiled, n' otherwise Perl would raise a gangbangin' fatal compile-time error.
In versions 5.000 all up in 5.003, tha error was
.PP
.Vb 1
\&        Literal @example now requires backslash
.Ve
.PP
In versions 5.004_01 all up in 5.6.0, tha error was
.PP
.Vb 1
\&        In string, @example now must be freestyled as \e@example
.Ve
.PP
Da scam here was ta git playas tha fuck into tha g-thang of writing
\&\f(CW"fred\e@example.com"\fR when they wanted a literal \f(CW\*(C`@\*(C'\fR sign, just as
they have always freestyled \f(CW"Give me back mah \e$5"\fR when they wanted a
literal \f(CW\*(C`$\*(C'\fR sign.
.PP
Startin wit 5.6.1, when Perl now sees a \f(CW\*(C`@\*(C'\fR sign up in a
double-quoted string, it \fIalways\fR attempts ta interpolate a array,
regardless of whether or not tha array has been used or declared
already.  Da fatal error has been downgraded ta a optionizzle warning:
.PP
.Vb 1
\&        Possible unintended interpolation of @example up in string
.Ve
.PP
This warns you dat \f(CW"fred@example.com"\fR is goin ta turn into
\&\f(CW\*(C`fred.com\*(C'\fR if you don't backslash tha \f(CW\*(C`@\*(C'\fR.
See http://perl.plover.com/at\-error.html fo' mo' details
about tha history here.
.SS "@\- n' @+ provide starting/endin offsetz of regex matches"
.IX Subsection "@- n' @+ provide starting/endin offsetz of regex matches"
Da freshly smoked up magic variablez @\- n' @+ provide tha startin n' ending
offsets, respectively, of $&, \f(CW$1\fR, \f(CW$2\fR, etc.  See perlvar for
details.
.SH "Modulez n' Pragmata"
.IX Header "Modulez n' Pragmata"
.SS "Modules"
.IX Subsection "Modules"
.IP "attributes" 4
.IX Item "attributes"
While used internally by Perl as a pragma, dis module also
provides a way ta fetch subroutine n' variable attributes.
See attributes.
.IP "B" 4
.IX Item "B"
Da Perl Compila suite has been extensively reworked fo' this
release.  Mo' of tha standard Perl test suite passes when run
under tha Compila yo, but there is still a thugged-out dope way to
go ta big up thang qualitizzle compiled executables.
.Sp
.Vb 3
\&    NOTE: Da Compila suite remains highly experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  The
\&    generated code may not be erect, even when it manages ta execute
\&    without errors.
.Ve
.IP "Benchmark" 4
.IX Item "Benchmark"
Overall, Benchmark thangs up in dis biatch exhibit lower average error n' betta timing
accuracy.
.Sp
Yo ass can now run tests fo' \fIn\fR secondz instead of guessin tha right
number of tests ta run: e.g., timethese(\-5, ...) will run each 
code fo' at least 5 \s-1CPU\s0 seconds.  Zero as tha \*(L"number of repetitions\*(R"
means \*(L"for at least 3 \s-1CPU\s0 seconds\*(R".  Da output format has also
changed. Y'all KNOW dat shit, muthafucka!  For example:
.Sp
.Vb 1
\&   use Benchmark;$x=3;timethese(\-5,{a=>sub{$x*$x},b=>sub{$x**2}})
.Ve
.Sp
will now output suttin' like this:
.Sp
.Vb 3
\&   Benchmark: hustlin a, b, each fo' at least 5 CPU seconds...
\&            a:  5 wallclock secs ( 5.77 usr +  0.00 sys =  5.77 CPU) @ 200551.91/s (n=1156516)
\&            b:  4 wallclock secs ( 5.00 usr +  0.02 sys =  5.02 CPU) @ 159605.18/s (n=800686)
.Ve
.Sp
New features: \*(L"each fo' at least N \s-1CPU\s0 seconds...\*(R", \*(L"wallclock secs\*(R",
and tha \*(L"@ operations/CPU second (n=operations)\*(R".
.Sp
\&\fItimethese()\fR now returns a reference ta a hash of Benchmark objects containing
the test thangs up in dis biatch, keyed on tha namez of tha tests.
.Sp
\&\fItimethis()\fR now returns tha iterations field up in tha Benchmark result object
instead of 0.
.Sp
\&\fItimethese()\fR, \fItimethis()\fR, n' tha freshly smoked up \fIcmpthese()\fR (see below) can also take
a format specifier of 'none' ta suppress output.
.Sp
A freshly smoked up function \fIcountit()\fR is just like \fItimeit()\fR except dat it takes a
\&\s-1TIME\s0 instead of a \s-1COUNT.\s0
.Sp
A freshly smoked up function \fIcmpthese()\fR prints a cold-ass lil chart comparin tha thangs up in dis biatch of each test
returned from a \fItimethese()\fR call.  For each possible pair of tests, the
percentage speed difference (iters/sec or seconds/iter) is shown.
.Sp
For other details, peep Benchmark.
.IP "ByteLoader" 4
.IX Item "ByteLoader"
Da ByteLoader be a thugged-out dedicated extension ta generate n' run
Perl bytecode.  See ByteLoader.
.IP "constant" 4
.IX Item "constant"
References can now be used.
.Sp
Da freshly smoked up version also allows a leadin underscore up in constant names yo, but
disallows a thugged-out double leadin underscore (as up in \*(L"_\|_LINE_\|_\*(R").  Some other names
are disallowed or warned against, includin \s-1BEGIN, END,\s0 etc.  Some names
which was forced tha fuck into main:: used ta fail silently up in some cases; now they're
fatal (outside of main::) n' a optionizzle warnin (inside of main::).
Da mobilitizzle ta detect whether a cold-ass lil constant had been set wit a given name has
been added.
.Sp
See constant.
.IP "charnames" 4
.IX Item "charnames"
This pragma implements tha \f(CW\*(C`\eN\*(C'\fR strang escape.  See charnames.
.IP "Data::Dumper" 4
.IX Item "Data::Dumper"
A \f(CW\*(C`Maxdepth\*(C'\fR settin can be specified ta avoid venturing
too deeply tha fuck into deep data structures.  See Data::Dumper.
.Sp
Da \s-1XSUB\s0 implementation of \fIDump()\fR is now automatically called if the
\&\f(CW\*(C`Useqq\*(C'\fR settin aint up in use.
.Sp
Dumpin \f(CW\*(C`qr//\*(C'\fR objects works erectly.
.IP "\s-1DB\s0" 4
.IX Item "DB"
\&\f(CW\*(C`DB\*(C'\fR be a experimenstrual module dat exposes a cold-ass lil clean abstraction
to Perlz debuggin \s-1API.\s0
.IP "DB_File" 4
.IX Item "DB_File"
DB_File can now be built wit Berkeley \s-1DB\s0 versions 1, 2 or 3.
See \f(CW\*(C`ext/DB_File/Changes\*(C'\fR.
.IP "Devel::DProf" 4
.IX Item "Devel::DProf"
Devel::DProf, a Perl source code profila has been added. Y'all KNOW dat shit, muthafucka!  See
Devel::DProf n' dprofpp.
.IP "Devel::Peek" 4
.IX Item "Devel::Peek"
Da Devel::Peek module serves up access ta tha internal representation
of Perl variablez n' data.  It be a thugged-out data debuggin tool fo' tha \s-1XS\s0 programmer.
.IP "Dumpvalue" 4
.IX Item "Dumpvalue"
Da Dumpvalue module serves up screen dumpz of Perl data.
.IP "DynaLoader" 4
.IX Item "DynaLoader"
DynaLoader now supports a \fIdl_unload_file()\fR function on platforms that
support unloadin shared objects rockin \fIdlclose()\fR.
.Sp
Perl can also optionally arrange ta unload all extension shared objects
loaded by Perl.  To enable this, build Perl wit tha Configure option
\&\f(CW\*(C`\-Accflags=\-DDL_UNLOAD_ALL_AT_EXIT\*(C'\fR.  (This maybe useful if yo ass is
usin Apache wit mod_perl.)
.IP "English" 4
.IX Item "English"
\&\f(CW$PERL_VERSION\fR now standz fo' \f(CW$^V\fR (a strang value) rather than fo' \f(CW$]\fR
(a numeric value).
.IP "Env" 4
.IX Item "Env"
Env now supports accessin environment variablez like \s-1PATH\s0 as array
variables.
.IP "Fcntl" 4
.IX Item "Fcntl"
Mo' Fcntl constants added: F_SETLK64, F_SETLKW64, O_LARGEFILE for
pimpin' file (more than 4GB) access (\s-1NOTE:\s0 tha O_LARGEFILE is
automatically added ta \fIsysopen()\fR flags if big-ass file support has been
configured, as is tha default), Free/Net/OpenBSD lockin behaviour
flags F_FLOCK, F_POSIX, Linux F_SHLCK, n' O_ACCMODE: tha combined
mask of O_RDONLY, O_WRONLY, n' O_RDWR.  Da \fIseek()\fR/\fIsysseek()\fR
constants \s-1SEEK_SET, SEEK_CUR,\s0 n' \s-1SEEK_END\s0 is available via the
\&\f(CW\*(C`:seek\*(C'\fR tag.  Da \fIchmod()\fR/\fIstat()\fR S_IF* constants n' S_IS* functions
are available via tha \f(CW\*(C`:mode\*(C'\fR tag.
.IP "File::Compare" 4
.IX Item "File::Compare"
A \fIcompare_text()\fR function has been added, which allows custom
comparison functions.  See File::Compare.
.IP "File::Find" 4
.IX Item "File::Find"
File::Find now works erectly when tha \fIwanted()\fR function is either
autoloaded or be a symbolic reference.
.Sp
A bug dat caused File::Find ta lose track of tha hustlin directory
when prunin top-level directories has been fixed.
.Sp
File::Find now also supports nuff muthafuckin other options ta control its
behavior. Shiiit, dis aint no joke.  It can follow symbolic links if tha \f(CW\*(C`follow\*(C'\fR option is
specified. Y'all KNOW dat shit, muthafucka!  Enablin tha \f(CW\*(C`no_chdir\*(C'\fR option will make File::Find skip
changin tha current directory when struttin directories. Put ya muthafuckin choppers up if ya feel dis!  Da \f(CW\*(C`untaint\*(C'\fR
flag can be useful when hustlin wit taint checks enabled.
.Sp
See File::Find.
.IP "File::Glob" 4
.IX Item "File::Glob"
This extension implements BSD-style file globbing.  By default,
it will also be used fo' tha internal implementation of tha \fIglob()\fR
operator. Shiiit, dis aint no joke.  See File::Glob.
.IP "File::Spec" 4
.IX Item "File::Spec"
New methodz done been added ta tha File::Spec module: \fIdevnull()\fR returns
the name of tha null thang (/dev/null on Unix) n' \fItmpdir()\fR tha name of
the temp directory (normally /tmp on Unix).  There is now also methods
to convert between absolute n' relatizzle filenames: \fIabs2rel()\fR and
\&\fIrel2abs()\fR.  For compatibilitizzle wit operatin systems dat specify volume
names up in file paths, tha \fIsplitpath()\fR, \fIsplitdir()\fR, n' \fIcatdir()\fR methods
have been added.
.IP "File::Spec::Functions" 4
.IX Item "File::Spec::Functions"
Da freshly smoked up File::Spec::Functions modulez serves up a gangbangin' function intercourse
to tha File::Spec module.  Allows shorthand
.Sp
.Vb 1
\&    $fullname = catfile($dir1, $dir2, $file);
.Ve
.Sp
instead of
.Sp
.Vb 1
\&    $fullname = File::Spec\->catfile($dir1, $dir2, $file);
.Ve
.IP "Getopt::Long" 4
.IX Item "Getopt::Long"
Getopt::Long licensin has chizzled ta allow tha Perl Artistic License
as well as tha \s-1GPL.\s0 It used ta be \s-1GPL\s0 only, which gots up in tha way of
non-GPL applications dat wanted ta use Getopt::Long.
.Sp
Getopt::Long encourages tha use of Pod::Usage ta produce help
lyrics. For example:
.Sp
.Vb 7
\&    use Getopt::Long;
\&    use Pod::Usage;
\&    mah $man = 0;
\&    mah $help = 0;
\&    GetOptions(\*(Aqhelp|?\*(Aq => \e$help, playa => \e$man) or pod2usage(2);
\&    pod2usage(1) if $help;
\&    pod2usage(\-exitstatus => 0, \-verbose => 2) if $man;
\&
\&    _\|_END_\|_
\&
\&    =head1 NAME
\&
\&    sample \- Usin Getopt::Long n' Pod::Usage
\&
\&    =head1 SYNOPSIS
\&
\&    sample [options] [file ...]
\&
\&     Options:
\&       \-help            brief help message
\&       \-man             full documentation
\&
\&    =head1 OPTIONS
\&
\&    =over 8
\&
\&    =item B<\-help>
\&
\&    Print a funky-ass brief help message n' exits.
\&
\&    =item B<\-man>
\&
\&    Prints tha manual page n' exits.
\&
\&    =back
\&
\&    =head1 DESCRIPTION
\&
\&    B<This program> will read tha given input file(s) n' do something
\&    useful wit tha contents thereof.
\&
\&    =cut
.Ve
.Sp
See Pod::Usage fo' details.
.Sp
A bug dat prevented tha non-option call-back <> from being
specified as tha straight-up original gangsta argument has been fixed.
.Sp
To specify tha charactas < n' > as option starters, use ><. Note,
however, dat changin option startas is straight fuckin deprecated.
.IP "\s-1IO\s0" 4
.IX Item "IO"
\&\fIwrite()\fR n' \fIsyswrite()\fR will now accept a single-argument
form of tha call, fo' consistency wit Perlz \fIsyswrite()\fR.
.Sp
Yo ass can now create a TCP-based IO::Socket::INET without forcing
a connect attempt.  This allows you ta configure its options
(like makin it non-blocking) n' then call \fIconnect()\fR manually.
.Sp
A bug dat prevented tha \fIIO::Socket::protocol()\fR accessor
from eva returnin tha erect value has been erected.
.Sp
IO::Socket::connect now uses non-blockin \s-1IO\s0 instead of \fIalarm()\fR
to do connect timeouts.
.Sp
IO::Socket::accept now uses \fIselect()\fR instead of \fIalarm()\fR fo' bustin
timeouts.
.Sp
IO::Socket::INET\->new now sets $! erectly on failure. $@ is
still set fo' backwardz compatibility.
.IP "\s-1JPL\s0" 4
.IX Item "JPL"
Java Perl Lingo is now distributed wit Perl.  See jpl/README
for mo' shiznit.
.IP "lib" 4
.IX Item "lib"
\&\f(CW\*(C`use lib\*(C'\fR now weedz up any trailin duplicate entries.
\&\f(CW\*(C`no lib\*(C'\fR removes all named entries.
.IP "Math::BigInt" 4
.IX Item "Math::BigInt"
Da bitwise operations \f(CW\*(C`<<\*(C'\fR, \f(CW\*(C`>>\*(C'\fR, \f(CW\*(C`&\*(C'\fR, \f(CW\*(C`|\*(C'\fR,
and \f(CW\*(C`~\*(C'\fR is now supported on bigints.
.IP "Math::Complex" 4
.IX Item "Math::Complex"
Da accessor methodz Re, Im, arg, abs, rho, n' theta can now also
act as mutators (accessor \f(CW$z\fR\->\fIRe()\fR, mutator \f(CW$z\fR\->\fIRe\fR\|(3)).
.Sp
Da class method \f(CW\*(C`display_format\*(C'\fR n' tha correspondin object method
\&\f(CW\*(C`display_format\*(C'\fR, up in addizzle ta acceptin just one argument, now can
also accept a parameta hash.  Recognized keyz of a parameta hash are
\&\f(CW"style"\fR, which correspondz ta tha oldschool one parameta case, n' two
new parameters: \f(CW"format"\fR, which be a \fIprintf()\fR\-style format string
(defaults probably ta \f(CW"%.15g"\fR, you can revert ta tha default by
settin tha format strang ta \f(CW\*(C`undef\*(C'\fR) used fo' both partz of a
complex number, n' \f(CW"polar_pretty_print"\fR (defaults ta true),
which controls whether a attempt is made ta try ta recognize small
multiplez n' rationalz of pi (2pi, pi/2) all up in tha argument (angle) of a
polar complex number.
.Sp
Da potentially disruptizzle chizzle is dat up in list context both methods
now \fIreturn tha parameta hash\fR, instead of only tha value of the
\&\f(CW"style"\fR parameter.
.IP "Math::Trig" 4
.IX Item "Math::Trig"
A lil bit of radial trigonometry (cylindrical n' spherical),
radial coordinizzle conversions, n' tha pimped out circle distizzle was added.
.IP "Pod::Parser, Pod::InputObjects" 4
.IX Item "Pod::Parser, Pod::InputObjects"
Pod::Parser be a funky-ass base class fo' parsin n' selectin sections of
pod documentation from a input stream.  This module takes care of
identifyin pod paragraphs n' commandz up in tha input n' handz off the
parsed paragraphs n' commandz ta user-defined methodz which is free
to interpret or translate dem as they peep fit.
.Sp
Pod::InputObjects defines some input objects needed by Pod::Parser, and
for advanced playaz of Pod::Parser dat need mo' on some cold-ass lil command besides
its name n' text.
.Sp
Az of release 5.6.0 of Perl, Pod::Parser is now tha officially sanctioned
\&\*(L"base parser code\*(R" recommended fo' use by all pod2xxx translators.
Pod::Text (pod2text) n' Pod::Man (pod2man) have already been converted
to use Pod::Parser n' efforts ta convert Pod::HTML (pod2html) is already
underway.  For any thangs or comments bout pod parsin n' translating
issues n' utilities, please use tha pod\-people@perl.org mailin list.
.Sp
For further shiznit, please peep Pod::Parser n' Pod::InputObjects.
.IP "Pod::Checker, podchecker" 4
.IX Item "Pod::Checker, podchecker"
This utilitizzle checks pod filez fo' erect syntax, accordin to
perlpod. Y'all KNOW dat shit, muthafucka!  Obvious errors is flagged as such, while warnings are
printed fo' mistakes dat can be handled gracefully.  Da checklist is
not complete yet.  See Pod::Checker.
.IP "Pod::ParseUtils, Pod::Find" 4
.IX Item "Pod::ParseUtils, Pod::Find"
These modulez provide a set of gizmos dat is useful mainly fo' pod
translators.  Pod::Find traverses directory structures and
returns found pod files, along wit they canonical names (like
\&\f(CW\*(C`File::Spec::Unix\*(C'\fR).  Pod::ParseUtils gotz nuff
\&\fBPod::List\fR (useful fo' storin pod list shiznit), \fBPod::Hyperlink\fR
(for parsin tha contentz of \f(CW\*(C`L<>\*(C'\fR sequences) n' \fBPod::Cache\fR
(for cachin shiznit bout pod files, e.g., link nodes).
.IP "Pod::Select, podselect" 4
.IX Item "Pod::Select, podselect"
Pod::Select be a subclass of Pod::Parser which serves up a gangbangin' function
named \*(L"\fIpodselect()\fR\*(R" ta filta up user-specified sectionz of raw pod
documentation from a input stream. podselect be a script dat provides
access ta Pod::Select from other scripts ta be used as a gangbangin' filter.
See Pod::Select.
.IP "Pod::Usage, pod2usage" 4
.IX Item "Pod::Usage, pod2usage"
Pod::Usage serves up tha function \*(L"\fIpod2usage()\fR\*(R" ta print usage lyrics for
a Perl script based on its embedded pod documentation. I aint talkin' bout chicken n' gravy biatch.  Da \fIpod2usage()\fR
function is generally useful ta all script authors since it lets them
write n' maintain a single source (the pods) fo' documentation, thus
removin tha need ta create n' maintain redundant usage message text
consistin of shiznit already up in tha pods.
.Sp
There be also a pod2usage script which can be used from other kindz of
scripts ta print usage lyrics from podz (even fo' non-Perl scripts
with podz embedded up in comments).
.Sp
For details n' examples, please peep Pod::Usage.
.IP "Pod::Text n' Pod::Man" 4
.IX Item "Pod::Text n' Pod::Man"
Pod::Text has been rewritten ta use Pod::Parser n' shit.  While \fIpod2text()\fR is
still available fo' backwardz compatibility, tha module now has a new
preferred intercourse.  See Pod::Text fo' tha details.  Da freshly smoked up Pod::Text
module is easily subclassed fo' tweaks ta tha output, n' two such
subclasses (Pod::Text::Termcap fo' man-page-style bold n' underlining
usin termcap shiznit, n' Pod::Text::Color fo' markup wit \s-1ANSI\s0 color
sequences) is now standard.
.Sp
pod2man has been turned tha fuck into a module, Pod::Man, which also uses
Pod::Parser n' shit.  In tha process, nuff muthafuckin outstandin bugs related ta quotes
in section headers, quotin of code escapes, n' nested lists have been
fixed. Y'all KNOW dat shit, muthafucka!  pod2man is now a wrapper script round dis module.
.IP "SDBM_File" 4
.IX Item "SDBM_File"
An \s-1EXISTS\s0 method has been added ta dis module (and \fIsdbm_exists()\fR has
been added ta tha underlyin sdbm library), so one can now call exists
on a SDBM_File tied hash n' git tha erect result, rather than a
runtime error.
.Sp
A bug dat may have caused data loss when mo' than one disk block
happens ta be read from tha database up in a single \s-1\fIFETCH\s0()\fR has been
fixed.
.IP "Sys::Syslog" 4
.IX Item "Sys::Syslog"
Sys::Syslog now uses XSUBs ta access facilitizzles from syslog.h so it
no longer requires syslog.ph ta exist.
.IP "Sys::Hostname" 4
.IX Item "Sys::Hostname"
Sys::Hostname now uses XSUBs ta booty-call tha C libraryz \fIgethostname()\fR or
\&\fIuname()\fR if they exist.
.IP "Term::ANSIColor" 4
.IX Item "Term::ANSIColor"
Term::ANSIColor be a straight-up simple module ta provide easy as fuck  n' readable
access ta tha \s-1ANSI\s0 color n' highlightin escape sequences, supported by
most \s-1ANSI\s0 terminal emulators.  It be now included standard.
.IP "Time::Local" 4
.IX Item "Time::Local"
Da \fItimelocal()\fR n' \fItimegm()\fR functions used ta silently return bogus
results when tha date fell tha fuck outside tha machinez integer range.  They
now consistently \fIcroak()\fR if tha date falls up in a unsupported range.
.IP "Win32" 4
.IX Item "Win32"
Da error return value up in list context has been chizzled fo' all functions
that return a list of joints, n' you can put dat on yo' toast.  Previously these functions returned a list
with a single element \f(CW\*(C`undef\*(C'\fR if a error occurred. Y'all KNOW dat shit, muthafucka!  Now these functions
return tha empty list up in these thangs.  This applies ta tha following
functions:
.Sp
.Vb 2
\&    Win32::FsType
\&    Win32::GetOSVersion
.Ve
.Sp
Da remainin functions is unchanged n' continue ta return \f(CW\*(C`undef\*(C'\fR on
error even up in list context.
.Sp
Da Win32::SetLastError(\s-1ERROR\s0) function has been added as a cold-ass lil complement
to tha \fIWin32::GetLastError()\fR function.
.Sp
Da freshly smoked up Win32::GetFullPathName(\s-1FILENAME\s0) returns tha full absolute
pathname fo' \s-1FILENAME\s0 up in scalar context.  In list context it returns
a two-element list containin tha straight-up qualified directory name and
the filename.  See Win32.
.IP "XSLoader" 4
.IX Item "XSLoader"
Da XSLoader extension be a simpla alternatizzle ta DynaLoader.
See XSLoader.
.IP "\s-1DBM\s0 Filters" 4
.IX Item "DBM Filters"
A freshly smoked up feature called \*(L"\s-1DBM\s0 Filters\*(R" has been added ta all the
\&\s-1DBM\s0 modules\-\-DB_File, GDBM_File, NDBM_File, ODBM_File, n' SDBM_File.
\&\s-1DBM\s0 Filtas add four freshly smoked up methodz ta each \s-1DBM\s0 module:
.Sp
.Vb 4
\&    filter_store_key
\&    filter_store_value
\&    filter_fetch_key
\&    filter_fetch_value
.Ve
.Sp
These can be used ta filta key-value pairs before tha pairs are
written ta tha database or just afta they is read from tha database.
See perldbmfilta fo' further shiznit.
.SS "Pragmata"
.IX Subsection "Pragmata"
\&\f(CW\*(C`use attrs\*(C'\fR is now obsolete, n' is only provided for
backward-compatibility.  It aint nuthin but been replaced by tha \f(CW\*(C`sub : attributes\*(C'\fR
syntax.  See \*(L"Subroutine Attributes\*(R" up in perlsub n' attributes.
.PP
Lexical warnings pragma, \f(CW\*(C`use warnings;\*(C'\fR, ta control optionizzle warnings.
See perllexwarn.
.PP
\&\f(CW\*(C`use filetest\*(C'\fR ta control tha behaviour of filetests (\f(CW\*(C`\-r\*(C'\fR \f(CW\*(C`\-w\*(C'\fR
\&...).  Currently only one subpragma implemented, \*(L"use filetest
\&'access';\*(R", dat uses \fIaccess\fR\|(2) or equivalent ta check permissions
instead of rockin \fIstat\fR\|(2) as usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This mattas up in filesystems
where there be ACLs (access control lists): tha \fIstat\fR\|(2) might lie,
but \fIaccess\fR\|(2) knows better.
.PP
Da \f(CW\*(C`open\*(C'\fR pragma can be used ta specify default disciplines for
handle constructors (e.g. \fIopen()\fR) n' fo' qx//.  Da two
pseudo-disciplines \f(CW\*(C`:raw\*(C'\fR n' \f(CW\*(C`:crlf\*(C'\fR is currently supported on
DOS-derivatizzle platforms (i.e. where binmode aint a no-op).
See also \*(L"\fIbinmode()\fR can be used ta set :crlf n' :raw modes\*(R".
.SH "Utilitizzle Chizzles"
.IX Header "Utilitizzle Chizzles"
.SS "dprofpp"
.IX Subsection "dprofpp"
\&\f(CW\*(C`dprofpp\*(C'\fR is used ta display flava data generated rockin \f(CW\*(C`Devel::DProf\*(C'\fR.
See dprofpp.
.SS "find2perl"
.IX Subsection "find2perl"
Da \f(CW\*(C`find2perl\*(C'\fR utilitizzle now uses tha enhanced featurez of tha File::Find
module.  Da \-depth n' \-follow options is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Pod documentation
is also included up in tha script.
.SS "h2xs"
.IX Subsection "h2xs"
Da \f(CW\*(C`h2xs\*(C'\fR tool can now work up in conjunction wit \f(CW\*(C`C::Scan\*(C'\fR (available
from \s-1CPAN\s0) ta automatically parse real-life header files.  Da \f(CW\*(C`\-M\*(C'\fR,
\&\f(CW\*(C`\-a\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR, n' \f(CW\*(C`\-o\*(C'\fR options is new.
.SS "perlcc"
.IX Subsection "perlcc"
\&\f(CW\*(C`perlcc\*(C'\fR now supports tha C n' Bytecode backends.  By default,
it generates output from tha simple C backend rather than the
optimized C backend.
.PP
Support fo' non-Unix platforms has been improved.
.SS "perldoc"
.IX Subsection "perldoc"
\&\f(CW\*(C`perldoc\*(C'\fR has been reworked ta avoid possible securitizzle holes.
It aint gonna by default let itself be run as tha superuser yo, but you
may still use tha \fB\-U\fR switch ta try ta make it drop privileges
first.
.SS "Da Perl Debugger"
.IX Subsection "Da Perl Debugger"
Many bug fixes n' enhancements was added ta \fIperl5db.pl\fR, the
Perl debugger n' shit.  Da help documentation was rearranged. Y'all KNOW dat shit, muthafucka!  New commands
include \f(CW\*(C`< ?\*(C'\fR, \f(CW\*(C`> ?\*(C'\fR, n' \f(CW\*(C`{ ?\*(C'\fR ta list up current
actions, \f(CW\*(C`man \f(CIdocpage\f(CW\*(C'\fR ta run yo' doc viewer on some perl
docset, n' support fo' quoted options.  Da help shiznit was
rearranged, n' should be viewable once again n' again n' again if you rockin \fBless\fR
as yo' pager n' shit.  A straight-up securitizzle hole was plugged\*(--you should
immediately remove all olda versionz of tha Perl debugger as
installed up in previous releases, all tha way back ta perl3, from
your system ta avoid bein bitten by all dis bullshit.
.SH "Improved Documentation"
.IX Header "Improved Documentation"
Many of tha platform-specific \s-1README\s0 filez is now part of tha perl
installation. I aint talkin' bout chicken n' gravy biatch.  See perl fo' tha complete list.
.IP "perlapi.pod" 4
.IX Item "perlapi.pod"
Da straight-up legit list of hood Perl \s-1API\s0 functions.
.IP "perlboot.pod" 4
.IX Item "perlboot.pod"
A tutorial fo' beginners on object-oriented Perl.
.IP "perlcompile.pod" 4
.IX Item "perlcompile.pod"
An introduction ta rockin tha Perl Compila suite.
.IP "perldbmfilter.pod" 4
.IX Item "perldbmfilter.pod"
A howto document on rockin tha \s-1DBM\s0 filta facility.
.IP "perldebug.pod" 4
.IX Item "perldebug.pod"
All material unrelated ta hustlin tha Perl debugger, plus all
low-level guts-like details dat risked crushin tha casual user
of tha debugger, done been relocated from tha oldschool manpage ta the
next entry below.
.IP "perldebguts.pod" 4
.IX Item "perldebguts.pod"
This freshly smoked up manpage gotz nuff excessively low-level material not related
to tha Perl debugger yo, but slightly related ta debuggin Perl itself.
It also gotz nuff some arcane internal detailz of how tha fuck tha debugging
process works dat may only be of interest ta pimperz of Perl
debuggers.
.IP "perlfork.pod" 4
.IX Item "perlfork.pod"
Notes on tha \fIfork()\fR emulation currently available fo' tha Windows platform.
.IP "perlfilter.pod" 4
.IX Item "perlfilter.pod"
An introduction ta freestylin Perl source filters.
.IP "perlhack.pod" 4
.IX Item "perlhack.pod"
Some guidelines fo' jackin tha Perl source code.
.IP "perlintern.pod" 4
.IX Item "perlintern.pod"
A list of internal functions up in tha Perl source code.
(List is currently empty.)
.IP "perllexwarn.pod" 4
.IX Item "perllexwarn.pod"
Introduction n' reference shiznit bout lexically scoped
warnin categories.
.IP "perlnumber.pod" 4
.IX Item "perlnumber.pod"
Detailed shiznit bout numbers as they is represented up in Perl.
.IP "perlopentut.pod" 4
.IX Item "perlopentut.pod"
A tutorial on rockin \fIopen()\fR effectively.
.IP "perlreftut.pod" 4
.IX Item "perlreftut.pod"
A tutorial dat introduces tha essentialz of references.
.IP "perltootc.pod" 4
.IX Item "perltootc.pod"
A tutorial on managin class data fo' object modules.
.IP "perltodo.pod" 4
.IX Item "perltodo.pod"
Rap of da most thugged-out often wanted features dat may somedizzle be
supported up in Perl.
.IP "perlunicode.pod" 4
.IX Item "perlunicode.pod"
An introduction ta Unicode support features up in Perl.
.SH "Performizzle enhancements"
.IX Header "Performizzle enhancements"
.ie n .SS "Simple \fIsort()\fP rockin { $a <=> $b } n' tha like is optimized"
.el .SS "Simple \fIsort()\fP rockin { \f(CW$a\fP <=> \f(CW$b\fP } n' tha like is optimized"
.IX Subsection "Simple sort() rockin { $a <=> $b } n' tha like is optimized"
Many common \fIsort()\fR operations rockin a simple inlined block is now
optimized fo' fasta performance.
.SS "Optimized assignments ta lexical variables"
.IX Subsection "Optimized assignments ta lexical variables"
Certain operations up in tha \s-1RHS\s0 of assignment statements have been
optimized ta directly set tha lexical variable on tha \s-1LHS,\s0
eliminatin redundant copyin overheads.
.SS "Fasta subroutine calls"
.IX Subsection "Fasta subroutine calls"
Minor chizzlez up in how tha fuck subroutine calls is handled internally
provide marginal improvements up in performance.
.SS "\fIdelete()\fP, \fIeach()\fP, \fIvalues()\fP n' hash iteration is faster"
.IX Subsection "delete(), each(), joints() n' hash iteration is faster"
Da hash joints returned by \fIdelete()\fR, \fIeach()\fR, \fIvalues()\fR n' hashes up in a
list context is tha actual joints up in tha hash, instead of copies.
This thangs up in dis biatch up in hella betta performance, cuz it eliminates
needless copyin up in most thangs.
.SH "Installation n' Configuration Improvements"
.IX Header "Installation n' Configuration Improvements"
.SS "\-Dusethreadz means suttin' different"
.IX Subsection "-Dusethreadz means suttin' different"
Da \-Dusethreadz flag now enablez tha experimenstrual interpreter-based thread
support by default.  To git tha flavor of experimenstrual threadz dat was in
5.005 instead, you need ta run Configure wit \*(L"\-Dusethreadz \-Duse5005threads\*(R".
.PP
Az of v5.6.0, interpreter-threadz support is still lackin a way to
create freshly smoked up threadz from Perl (i.e., \f(CW\*(C`use Thread;\*(C'\fR aint gonna work with
interpreta threads).  \f(CW\*(C`use Thread;\*(C'\fR continues ta be available when you
specify tha \-Duse5005threadz option ta Configure, bugs n' all.
.PP
.Vb 2
\&    NOTE: Support fo' threadz continues ta be a experimenstrual feature.
\&    Interfaces n' implementation is subject ta sudden n' drastic chizzles.
.Ve
.SS "New Configure flags"
.IX Subsection "New Configure flags"
Da followin freshly smoked up flags may be enabled on tha Configure command line
by hustlin Configure wit \f(CW\*(C`\-Dflag\*(C'\fR.
.PP
.Vb 3
\&    usemultiplicity
\&    usethreadz useithreadz      (new interpreta threads: no Perl API yet)
\&    usethreadz use5005threadz   (threadz as they was up in 5.005)
\&
\&    use64bitint                 (equal ta now deprecated \*(Aquse64bits\*(Aq)
\&    use64bitall
\&
\&    uselongdouble
\&    usemorebits
\&    uselargefiles
\&    usesocks                    (only SOCKS v5 supported)
.Ve
.SS "Threadednizz n' 64\-bitnizz now mo' daring"
.IX Subsection "Threadednizz n' 64-bitnizz now mo' daring"
Da Configure options enablin tha use of threadz n' tha use of
64\-bitnizz is now mo' darin up in tha sense dat they no mo' have an
explicit list of operatin systemz of known threads/64\-bit
capabilities. Put ya muthafuckin choppers up if ya feel dis!  In other lyrics: if yo' operatin system has the
necessary APIs n' datatypes, you should be able just ta go ahead and
use them, fo' threadz by Configure \-Dusethreads, n' fo' 64 bits
either explicitly by Configure \-Duse64bitint or implicitly if your
system has 64\-bit wide datatypes.  See also \*(L"64\-bit support\*(R".
.SS "Long Doubles"
.IX Subsection "Long Doubles"
Some platforms have \*(L"long doubles\*(R", floatin point numberz of even
larger range than ordinary \*(L"doubles\*(R".  To enable rockin long doublez for
Perlz scalars, use \-Duselongdouble.
.SS "\-Dusemorebits"
.IX Subsection "-Dusemorebits"
Yo ass can enable both \-Duse64bitint n' \-Duselongdouble wit \-Dusemorebits.
See also \*(L"64\-bit support\*(R".
.SS "\-Duselargefiles"
.IX Subsection "-Duselargefiles"
Some platforms support system APIs dat is capable of handlin big-ass files
(typically, filez larger than two gigabytes).  Perl will try ta use these
APIs if you ask fo' \-Duselargefiles.
.PP
See \*(L"Big-Ass file support\*(R" fo' mo' shiznit.
.SS "installusrbinperl"
.IX Subsection "installusrbinperl"
Yo ass can use \*(L"Configure \-Uinstallusrbinperl\*(R" which causes installperl
to skip installin perl also as /usr/bin/perl.  This is useful if you
prefer not ta modify /usr/bin fo' some reason or another but harmful
because nuff scripts assume ta find Perl up in /usr/bin/perl.
.SS "\s-1SOCKS\s0 support"
.IX Subsection "SOCKS support"
Yo ass can use \*(L"Configure \-Dusesocks\*(R" which causes Perl ta probe
for tha \s-1SOCKS\s0 proxy protocol library (v5, not v4).  For mo' shiznit
on \s-1SOCKS,\s0 see:
.PP
.Vb 1
\&    http://www.socks.nec.com/
.Ve
.ie n .SS """\-A"" flag"
.el .SS "\f(CW\-A\fP flag"
.IX Subsection "-A flag"
Yo ass can \*(L"post-edit\*(R" tha Configure variablez rockin tha Configure \f(CW\*(C`\-A\*(C'\fR
switch.  Da editin happens immediately afta tha platform specific
hints filez done been processed but before tha actual configuration
process starts, n' you can put dat on yo' toast.  Run \f(CW\*(C`Configure \-h\*(C'\fR ta smoke up tha full \f(CW\*(C`\-A\*(C'\fR syntax.
.SS "Enhanced Installation Directories"
.IX Subsection "Enhanced Installation Directories"
Da installation structure has been enriched ta improve tha support
for maintainin multiple versionz of perl, ta provide locations for
vendor-supplied modules, scripts, n' manpages, n' ta ease maintenance
of locally-added modules, scripts, n' manpages.  See tha section on
Installation Directories up in tha \s-1INSTALL\s0 file fo' complete details.
For most playas buildin n' installin from source, tha defaults should
be fine.
.PP
If you previously used \f(CW\*(C`Configure \-Dsitelib\*(C'\fR or \f(CW\*(C`\-Dsitearch\*(C'\fR ta set
special joints fo' library directories, you might wish ta consider using
the freshly smoked up \f(CW\*(C`\-Dsiteprefix\*(C'\fR settin instead. Y'all KNOW dat shit, muthafucka!  Also, if you wish ta re-use a
config.sh file from a earlier version of perl, you should be shizzle to
check dat Configure make sensible chizzlez fo' tha freshly smoked up directories.
See \s-1INSTALL\s0 fo' complete details.
.SH "Platform specific chizzles"
.IX Header "Platform specific chizzles"
.SS "Supported platforms"
.IX Subsection "Supported platforms"
.IP "\(bu" 4
Da Mach CThreadz (\s-1NEXTSTEP, OPENSTEP\s0) is now supported by tha Thread
extension.
.IP "\(bu" 4
GNU/Hurd is now supported.
.IP "\(bu" 4
Rhapsody/Darwin is now supported.
.IP "\(bu" 4
\&\s-1EPOC\s0 is now supported (on Psion 5).
.IP "\(bu" 4
Da cygwin port (formerly cygwin32) has been pimped outly improved.
.SS "\s-1DOS\s0"
.IX Subsection "DOS"
.IP "\(bu" 4
Perl now works wit djgpp 2.02 (and 2.03 alpha).
.IP "\(bu" 4
Environment variable names is not converted ta uppercase any more.
.IP "\(bu" 4
Incorrect exit codes from backticks done been fixed.
.IP "\(bu" 4
This port continues ta use its own builtin globbin (not File::Glob).
.SS "\s-1OS390 \s0(OpenEdizzle \s-1MVS\s0)"
.IX Subsection "OS390 (OpenEdizzle MVS)"
Support fo' dis \s-1EBCDIC\s0 platform has not been renewed up in dis release.
There is bullshit up in reconcilin Perlz standardization on \s-1UTF\-8\s0
as its internal representation fo' charactas wit tha \s-1EBCDIC\s0 character
set, cuz tha two is incompatible.
.PP
It be unclear whether future versions will renew support fo' this
platform yo, but tha possibilitizzle exists.
.SS "\s-1VMS\s0"
.IX Subsection "VMS"
Numerous revisions n' extensions ta configuration, build, testing, and
installation process ta accommodate core chizzlez n' VMS-specific options.
.PP
Expand \f(CW%ENV\fR\-handlin code ta allow runtime mappin ta logical names,
\&\s-1CLI\s0 symbols, n' \s-1CRTL\s0 environ array.
.PP
Extension of subprocess invocation code ta accept filespecs as command
\&\*(L"verbs\*(R".
.PP
Add ta Perl command line processin tha mobilitizzle ta use default file types and
to recognize Unix-style \f(CW\*(C`2>&1\*(C'\fR.
.PP
Expansion of File::Spec::VMS routines, n' integration tha fuck into ExtUtils::MM_VMS.
.PP
Extension of ExtUtils::MM_VMS ta handle complex extensions mo' flexibly.
.PP
Barewordz at start of Unix-syntax paths may be treated as text rather than
only as logical names.
.PP
Optionizzle secure translation of nuff muthafuckin logical names used internally by Perl.
.PP
Miscellaneous bugfixin n' portin of freshly smoked up core code ta \s-1VMS.\s0
.PP
Thanks is gladly extended ta tha nuff playas whoz ass have contributed \s-1VMS\s0
patches, testing, n' ideas.
.SS "Win32"
.IX Subsection "Win32"
Perl can now emulate \fIfork()\fR internally, rockin multiple interpretas hustlin
in different concurrent threads.  This support must be enabled at build
time.  See perlfork fo' detailed shiznit.
.PP
When given a pathname dat consists only of a thugged-out drivename, like fuckin \f(CW\*(C`A:\*(C'\fR,
\&\fIopendir()\fR n' \fIstat()\fR now use tha current hustlin directory fo' tha drive
rather than tha drive root.
.PP
Da builtin \s-1XSUB\s0 functions up in tha Win32:: namespace is documented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See
Win32.
.PP
$^X now gotz nuff tha full path name of tha hustlin executable.
.PP
A \fIWin32::GetLongPathName()\fR function is provided ta complement
\&\fIWin32::GetFullPathName()\fR n' \fIWin32::GetShortPathName()\fR.  See Win32.
.PP
\&\fIPOSIX::uname()\fR is supported.
.PP
system(1,...) now returns legit process IDs rather than process
handles.  \fIkill()\fR accepts any real process id, rather than strictly
return joints from system(1,...).
.PP
For betta compatibilitizzle wit Unix, \f(CW\*(C`kill(0, $pid)\*(C'\fR can now be used to
test whether a process exists.
.PP
Da \f(CW\*(C`Shell\*(C'\fR module is supported.
.PP
Betta support fo' buildin Perl under command.com up in Windows 95
has been added.
.PP
Scripts is read up in binary mode by default ta allow ByteLoader (and
the filta mechanizzle up in general) ta work properly.  For compatibility,
the \s-1DATA\s0 filehandle is ghon be set ta text mode if a cold-ass lil carriage return is
detected all up in tha end of tha line containin tha _\|_END_\|_ or _\|_DATA_\|_
token; if not, tha \s-1DATA\s0 filehandle is ghon be left open up in binary mode.
Earlier versions always opened tha \s-1DATA\s0 filehandle up in text mode.
.PP
Da \fIglob()\fR operator is implemented via tha \f(CW\*(C`File::Glob\*(C'\fR extension,
which supports glob syntax of tha C shell.  This increases tha flexibility
of tha \fIglob()\fR operator yo, but there may be compatibilitizzle thangs for
programs dat relied on tha olda globbin syntax.  If you want to
preserve compatibilitizzle wit tha olda syntax, you might wanna run
perl wit \f(CW\*(C`\-MFile::DosGlob\*(C'\fR.  For details n' compatibilitizzle shiznit,
see File::Glob.
.SH "Significant bug fixes"
.IX Header "Significant bug fixes"
.SS "<\s-1HANDLE\s0> on empty files"
.IX Subsection "<HANDLE> on empty files"
With \f(CW$/\fR set ta \f(CW\*(C`undef\*(C'\fR, \*(L"slurping\*(R" a empty file returns a strang of
zero length (instead of \f(CW\*(C`undef\*(C'\fR, as it used to) tha last time the
\&\s-1HANDLE\s0 is read afta \f(CW$/\fR is set ta \f(CW\*(C`undef\*(C'\fR.  Further readz yield
\&\f(CW\*(C`undef\*(C'\fR.
.PP
This means dat tha followin will append \*(L"foo\*(R" ta a empty file (it used
to do nothing):
.PP
.Vb 1
\&    perl \-0777 \-pi \-e \*(Aqs/^/foo/\*(Aq empty_file
.Ve
.PP
Da behaviour of:
.PP
.Vb 1
\&    perl \-pi \-e \*(Aqs/^/foo/\*(Aq empty_file
.Ve
.PP
is unchanged (it continues ta leave tha file empty).
.ie n .SS """eval \*(Aq...\*(Aq"" improvements"
.el .SS "\f(CWeval \*(Aq...\*(Aq\fP improvements"
.IX Subsection "eval ... improvements"
Line numbers (as reflected by \fIcaller()\fR n' most diagnostics) within
\&\f(CW\*(C`eval \*(Aq...\*(Aq\*(C'\fR was often incorrect where here documents was involved.
This has been erected.
.PP
Lexical lookups fo' variablez appearin up in \f(CW\*(C`eval \*(Aq...\*(Aq\*(C'\fR within
functions dat was theyselves called within a \f(CW\*(C`eval \*(Aq...\*(Aq\*(C'\fR were
searchin tha wack place fo' lexicals.  Da lexical search now
correctly endz all up in tha subroutinez block boundary.
.PP
Da use of \f(CW\*(C`return\*(C'\fR within \f(CW\*(C`eval {...}\*(C'\fR caused $@ not ta be reset
correctly when no exception occurred within tha eval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This has
been fixed.
.PP
Parsin of here documents used ta be flawed when they rocked up as
the replacement expression up in \f(CW\*(C`eval \*(Aqs/.../.../e\*(Aq\*(C'\fR.  This has
been fixed.
.SS "All compilation errors is legit errors"
.IX Subsection "All compilation errors is legit errors"
Some \*(L"errors\*(R" encountered at compile time was by necessitizzle 
generated as warnings followed by eventual termination of the
program.  This enabled mo' such errors ta be reported up in a
single run, rather than causin a hard stop all up in tha straight-up original gangsta error
that was encountered.
.PP
Da mechanizzle fo' reportin such errors has been reimplemented
to queue compile-time errors n' report dem all up in tha end of the
compilation as legit errors rather than as warnings.  This fixes
cases where error lyrics leaked all up in in tha form of warnings
when code was compiled at run time rockin \f(CW\*(C`eval STRING\*(C'\fR, and
also allows such errors ta be reliably trapped rockin \f(CW\*(C`eval "..."\*(C'\fR.
.SS "Implicitly closed filehandlez is safer"
.IX Subsection "Implicitly closed filehandlez is safer"
Sometimes implicitly closed filehandlez (as when they is localized,
and Perl automatically closes dem on exitin tha scope) could
inadvertently set $? or $!.  This has been erected.
.SS "Behavior of list slices is mo' consistent"
.IX Subsection "Behavior of list slices is mo' consistent"
When takin a slice of a literal list (as opposed ta a slice of
an array or hash), Perl used ta return a empty list if the
result happened ta be composed of all undef joints.
.PP
Da freshly smoked up behavior is ta produce a empty list if (and only if)
the original gangsta list was empty.  Consider tha followin example:
.PP
.Vb 1
\&    @a = (1,undef,undef,2)[2,1,2];
.Ve
.PP
Da oldschool behavior would have resulted up in \f(CW@a\fR havin no elements.
Da freshly smoked up behavior ensures it has three undefined elements.
.PP
Note up in particular dat tha behavior of slicez of tha following
cases remains unchanged:
.PP
.Vb 5
\&    @a = ()[1,2];
\&    @a = (getpwent)[7,0];
\&    @a = (anything_returning_empty_list())[2,1,2];
\&    @a = @b[2,1,2];
\&    @a = @c{\*(Aqa\*(Aq,\*(Aqb\*(Aq,\*(Aqc\*(Aq};
.Ve
.PP
See perldata.
.ie n .SS """(\e$)"" prototype n' $foo{a}"
.el .SS "\f(CW(\e$)\fP prototype n' \f(CW$foo{a}\fP"
.IX Subsection "($) prototype n' $foo{a}"
A scalar reference prototype now erectly allows a hash or
array element up in dat slot.
.ie n .SS """goto &sub"" n' \s-1AUTOLOAD\s0"
.el .SS "\f(CWgoto &sub\fP n' \s-1AUTOLOAD\s0"
.IX Subsection "goto &sub n' AUTOLOAD"
Da \f(CW\*(C`goto &sub\*(C'\fR construct works erectly when \f(CW&sub\fR happens
to be autoloaded.
.ie n .SS """\-bareword"" allowed under ""use integer"""
.el .SS "\f(CW\-bareword\fP allowed under \f(CWuse integer\fP"
.IX Subsection "-bareword allowed under use integer"
Da autoquotin of barewordz preceded by \f(CW\*(C`\-\*(C'\fR did not work
in prior versions when tha \f(CW\*(C`integer\*(C'\fR pragma was enabled.
This has been fixed.
.SS "Failures up in \s-1\fIDESTROY\s0()\fP"
.IX Subsection "Failures up in DESTROY()"
When code up in a thugged-out destructor threw a exception, it went unnoticed
in earlier versionz of Perl, unless one of mah thugs happened ta be
lookin up in $@ just afta tha point tha destructor happened to
run. I aint talkin' bout chicken n' gravy biatch.  Such failures is now visible as warnings when warnings are
enabled.
.SS "Locale bugs fixed"
.IX Subsection "Locale bugs fixed"
\&\fIprintf()\fR n' \fIsprintf()\fR previously reset tha numeric locale
back ta tha default \*(L"C\*(R" locale.  This has been fixed.
.PP
Numbers formatted accordin ta tha local numeric locale
(like fuckin rockin a thugged-out decimal comma instead of a thugged-out decimal dot) caused
\&\*(L"aint numeric\*(R" warnings, even while tha operations accessing
those numbers produced erect thangs up in dis biatch.  These warnings have been
discontinued.
.SS "Memory leaks"
.IX Subsection "Memory leaks"
Da \f(CW\*(C`eval \*(Aqreturn sub {...}\*(Aq\*(C'\fR construct could sometimes leak
memory.  This has been fixed.
.PP
Operations dat aren't filehandle constructors used ta leak memory
when used on invalid filehandles.  This has been fixed.
.PP
Constructs dat modified \f(CW@_\fR could fail ta deallocate joints
in \f(CW@_\fR n' thus leak memory.  This has been erected.
.SS "Spurious subroutine stubs afta failed subroutine calls"
.IX Subsection "Spurious subroutine stubs afta failed subroutine calls"
Perl could sometimes create empty subroutine stubs when a
subroutine was not found up in tha package.  Such cases stopped
lata method lookups from progressin tha fuck into base packages.
This has been erected.
.ie n .SS "Taint failures under ""\-U"""
.el .SS "Taint failures under \f(CW\-U\fP"
.IX Subsection "Taint failures under -U"
When hustlin up in unsafe mode, taint violations could sometimes
cause silent failures.  This has been fixed.
.ie n .SS "\s-1END\s0 blocks n' tha ""\-c"" switch"
.el .SS "\s-1END\s0 blocks n' tha \f(CW\-c\fP switch"
.IX Subsection "END blocks n' tha -c switch"
Prior versions used ta run \s-1BEGIN \s0\fBand\fR \s-1END\s0 blocks when Perl was
run up in compile-only mode.  Since dis is typically not tha expected
behavior, \s-1END\s0 blocks is not executed no mo' when tha \f(CW\*(C`\-c\*(C'\fR switch
is used, or if compilation fails.
.PP
See \*(L"Support fo' \s-1CHECK\s0 blocks\*(R" fo' how tha fuck ta run thangs when tha compile 
phase ends.
.SS "Potential ta leak \s-1DATA\s0 filehandles"
.IX Subsection "Potential ta leak DATA filehandles"
Usin tha \f(CW\*(C`_\|_DATA_\|_\*(C'\fR token creates a implicit filehandle to
the file dat gotz nuff tha token. I aint talkin' bout chicken n' gravy biatch.  It be tha program's
responsibilitizzle ta close it when it is done readin from dat shit.
.PP
This caveat is now betta explained up in tha documentation.
See perldata.
.SH "New or Chizzled Diagnostics"
.IX Header "New or Chizzled Diagnostics"
.ie n .IP """%s"" variable %s masks earlier declaration up in same %s" 4
.el .IP "``%s'' variable \f(CW%s\fR masks earlier declaration up in same \f(CW%s\fR" 4
.IX Item "%s variable %s masks earlier declaration up in same %s"
(W misc) A \*(L"my\*(R" or \*(L"our\*(R" variable has been redeclared up in tha current scope or statement,
effectively eliminatin all access ta tha previous instance.  This be almost
always a typographical error. Shiiit, dis aint no joke.  Note dat tha earlier variable will still exist
until tha end of tha scope or until all closure referents ta it are
destroyed.
.ie n .IP """my sub"" not yet implemented" 4
.el .IP "``my sub'' not yet implemented" 4
.IX Item "my sub not yet implemented"
(F) Lexically scoped subroutines is not yet implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Don't try that
yet.
.ie n .IP """our"" variable %s redeclared" 4
.el .IP "``our'' variable \f(CW%s\fR redeclared" 4
.IX Item "our variable %s redeclared"
(W misc) Yo ass seem ta have already declared tha same global once before up in the
current lexical scope.
.ie n .IP "'!' allowed only afta types %s" 4
.el .IP "'!' allowed only afta types \f(CW%s\fR" 4
.IX Item "'!' allowed only afta types %s"
(F) Da '!' be allowed up in \fIpack()\fR n' \fIunpack()\fR only afta certain types.
See \*(L"pack\*(R" up in perlfunc.
.IP "/ cannot take a cold-ass lil count" 4
.IX Item "/ cannot take a cold-ass lil count"
(F) Yo ass had a unpack template indicatin a cold-ass lil counted-length string,
but you have also specified a explicit size fo' tha string.
See \*(L"pack\*(R" up in perlfunc.
.IP "/ must be followed by a, A or Z" 4
.IX Item "/ must be followed by a, A or Z"
(F) Yo ass had a unpack template indicatin a cold-ass lil counted-length string,
which must be followed by one of tha lettas a, A or Z
to indicate what tha fuck sort of strang is ta be unpacked.
See \*(L"pack\*(R" up in perlfunc.
.IP "/ must be followed by a*, A* or Z*" 4
.IX Item "/ must be followed by a*, A* or Z*"
(F) Yo ass had a pack template indicatin a cold-ass lil counted-length string,
Currently tha only thangs dat can have they length counted is a*, A* or Z*.
See \*(L"pack\*(R" up in perlfunc.
.IP "/ must follow a numeric type" 4
.IX Item "/ must follow a numeric type"
(F) Yo ass had a unpack template dat contained a '#',
but dis did not follow some numeric unpack justification.
See \*(L"pack\*(R" up in perlfunc.
.IP "/%s/: Unrecognized escape \e\e%c passed through" 4
.IX Item "/%s/: Unrecognized escape %c passed through"
(W regexp) Yo ass used a funky-ass backslash-characta combination which aint recognized
by Perl.  This combination appears up in a interpolated variable or a
\&\f(CW\*(C`\*(Aq\*(C'\fR\-delimited regular expression. I aint talkin' bout chicken n' gravy biatch.  Da characta was understood literally.
.IP "/%s/: Unrecognized escape \e\e%c up in characta class passed through" 4
.IX Item "/%s/: Unrecognized escape %c up in characta class passed through"
(W regexp) Yo ass used a funky-ass backslash-characta combination which aint recognized
by Perl inside characta classes.  Da characta was understood literally.
.ie n .IP "/%s/ should probably be freestyled as ""%s""" 4
.el .IP "/%s/ should probably be freestyled as ``%s''" 4
.IX Item "/%s/ should probably be freestyled as %s"
(W syntax) Yo ass have used a pattern where Perl sposed ta fuckin find a string,
as up in tha straight-up original gangsta argument ta \f(CW\*(C`join\*(C'\fR.  Perl will treat tha true
or false result of matchin tha pattern against \f(CW$_\fR as tha string,
which is probably not what tha fuck you had up in mind.
.IP "%s() called too early ta check prototype" 4
.IX Item "%s() called too early ta check prototype"
(W prototype) You've called a gangbangin' function dat has a prototype before tha parser saw a
definizzle or declaration fo' it, n' Perl could not check dat tha call
conforms ta tha prototype.  Yo ass need ta either add a early prototype
declaration fo' tha subroutine up in question, or move tha subroutine
definizzle ahead of tha call ta git proper prototype checking.  Alternatively,
if yo ass is certain dat you callin tha function erectly, you may put
an ampersand before tha name ta avoid tha warning.  See perlsub.
.ie n .IP "%s argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element" 4
.el .IP "\f(CW%s\fR argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element" 4
.IX Item "%s argument aint a HASH or ARRAY element"
(F) Da argument ta \fIexists()\fR must be a hash or array element, such as:
.Sp
.Vb 2
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
.Ve
.ie n .IP "%s argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or slice" 4
.el .IP "\f(CW%s\fR argument aint a \s-1HASH\s0 or \s-1ARRAY\s0 element or slice" 4
.IX Item "%s argument aint a HASH or ARRAY element or slice"
(F) Da argument ta \fIdelete()\fR must be either a hash or array element, such as:
.Sp
.Vb 2
\&    $foo{$bar}
\&    $ref\->{"susie"}[12]
.Ve
.Sp
or a hash or array slice, such as:
.Sp
.Vb 2
\&    @foo[$bar, $baz, $xyzzy]
\&    @{$ref\->[12]}{"susie", "queue"}
.Ve
.ie n .IP "%s argument aint a subroutine name" 4
.el .IP "\f(CW%s\fR argument aint a subroutine name" 4
.IX Item "%s argument aint a subroutine name"
(F) Da argument ta \fIexists()\fR fo' \f(CW\*(C`exists &sub\*(C'\fR must be a subroutine
name, n' not a subroutine call.  \f(CW\*(C`exists &sub()\*(C'\fR will generate dis error.
.ie n .IP "%s package attribute may clash wit future reserved word: %s" 4
.el .IP "\f(CW%s\fR package attribute may clash wit future reserved word: \f(CW%s\fR" 4
.IX Item "%s package attribute may clash wit future reserved word: %s"
(W reserved) A lowercase attribute name was used dat had a package-specific handlez.
That name might gotz a meanin ta Perl itself some day, even though it
doesn't yet.  Perhaps you should bust a mixed-case attribute name, instead.
See attributes.
.ie n .IP "(in cleanup) %s" 4
.el .IP "(in cleanup) \f(CW%s\fR" 4
.IX Item "(in cleanup) %s"
(W misc) This prefix probably indicates dat a \s-1\fIDESTROY\s0()\fR method raised
the indicated exception. I aint talkin' bout chicken n' gravy biatch.  Since destructors is probably called by
the system at arbitrary points durin execution, n' often a vast
number of times, tha warnin is issued only once fo' any number
of failures dat would otherwise result up in tha same message being
repeated.
.Sp
Failure of user callbacks dispatched rockin tha \f(CW\*(C`G_KEEPERR\*(C'\fR flag
could also result up in dis warning.  See \*(L"G_KEEPERR\*(R" up in perlcall.
.IP "<> should be quotes" 4
.IX Item "<> should be quotes"
(F) Yo ass freestyled \f(CW\*(C`require <file>\*(C'\fR when you should have written
\&\f(CW\*(C`require \*(Aqfile\*(Aq\*(C'\fR.
.IP "Attempt ta join self" 4
.IX Item "Attempt ta join self"
(F) Yo ass tried ta join a thread from within itself, which be an
impossible task.  Yo ass may be joinin tha wack thread, or you may
need ta move tha \fIjoin()\fR ta some other thread.
.IP "Wack evalled substitution pattern" 4
.IX Item "Wack evalled substitution pattern"
(F) You've used tha /e switch ta evaluate tha replacement fo' a
substitution yo, but perl found a syntax error up in tha code ta evaluate,
most likely a unexpected right brace '}'.
.IP "Wack \fIrealloc()\fR ignored" 4
.IX Item "Wack realloc() ignored"
(S) An internal routine called \fIrealloc()\fR on suttin' dat had never been
\&\fImalloc()\fRed up in tha straight-up original gangsta place. Mandatory yo, but can be disabled by
settin environment variable \f(CW\*(C`PERL_BADFREE\*(C'\fR ta 1.
.IP "Bareword found up in conditional" 4
.IX Item "Bareword found up in conditional"
(W bareword) Da compila found a funky-ass bareword where it expected a cold-ass lil conditional,
which often indicates dat a || or && was parsed as part of the
last argument of tha previous construct, fo' example:
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.Sp
It may also indicate a misspelled constant dat has been interpreted
as a funky-ass bareword:
.Sp
.Vb 2
\&    use constant TYPO => 1;
\&    if (TYOP) { print "foo" }
.Ve
.Sp
Da \f(CW\*(C`strict\*(C'\fR pragma is useful up in avoidin such errors.
.IP "Binary number > 0b11111111111111111111111111111111 non-portable" 4
.IX Item "Binary number > 0b11111111111111111111111111111111 non-portable"
(W portable) Da binary number you specified is larger than 2**32\-1
(4294967295) n' therefore non-portable between systems.  See
perlport fo' mo' on portabilitizzle concerns.
.IP "Bit vector size > 32 non-portable" 4
.IX Item "Bit vector size > 32 non-portable"
(W portable) Usin bit vector sizes larger than 32 is non-portable.
.ie n .IP "Buffer overflow up in prime_env_iter: %s" 4
.el .IP "Buffer overflow up in prime_env_iter: \f(CW%s\fR" 4
.IX Item "Buffer overflow up in prime_env_iter: %s"
(W internal) A warnin peculiar ta \s-1VMS. \s0 While Perl was preparin ta iterate over
\&\f(CW%ENV\fR, it encountered a logical name or symbol definizzle which was too long,
so dat shiznit was truncated ta tha strang shown.
.ie n .IP "Can't check filesystem of script ""%s""" 4
.el .IP "Can't check filesystem of script ``%s''" 4
.IX Item "Can't check filesystem of script %s"
(P) For some reason you can't check tha filesystem of tha script fo' nosuid.
.ie n .IP "Can't declare class fo' non-scalar %s up in ""%s""" 4
.el .IP "Can't declare class fo' non-scalar \f(CW%s\fR up in ``%s''" 4
.IX Item "Can't declare class fo' non-scalar %s up in %s"
(S) Currently, only scalar variablez can declared wit a specific class
qualifier up in a \*(L"my\*(R" or \*(L"our\*(R" declaration. I aint talkin' bout chicken n' gravy biatch.  Da semantics may be extended
for other typez of variablez up in future.
.ie n .IP "Can't declare %s up in ""%s""" 4
.el .IP "Can't declare \f(CW%s\fR up in ``%s''" 4
.IX Item "Can't declare %s up in %s"
(F) Only scalar, array, n' hash variablez may be declared as \*(L"my\*(R" or
\&\*(L"our\*(R" variables.  They must have ordinary identifiers as names.
.IP "Can't ignore signal \s-1CHLD,\s0 forcin ta default" 4
.IX Item "Can't ignore signal CHLD, forcin ta default"
(W signal) Perl has detected dat it is bein run wit tha \s-1SIGCHLD\s0 signal
(sometimes known as \s-1SIGCLD\s0) disabled. Y'all KNOW dat shit, muthafucka!  Since disablin dis signal
will interfere wit proper determination of exit statuz of child
processes, Perl has reset tha signal ta its default value.
This thang typically indicates dat tha parent program under
which Perl may be hustlin (e.g., cron) is bein straight-up careless.
.IP "Can't modify non-lvalue subroutine call" 4
.IX Item "Can't modify non-lvalue subroutine call"
(F) Subroutines meant ta be used up in lvalue context should be declared as
such, peep \*(L"Lvalue subroutines\*(R" up in perlsub.
.IP "Can't read \s-1CRTL\s0 environ" 4
.IX Item "Can't read CRTL environ"
(S) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read a element of \f(CW%ENV\fR
from tha \s-1CRTL\s0z internal environment array n' discovered tha array was
missing.  Yo ass need ta figure up where yo' \s-1CRTL\s0 misplaced its environ
or define \fI\s-1PERL_ENV_TABLES\s0\fR (see perlvms) so dat environ aint searched.
.ie n .IP "Can't remove %s: %s, skippin file" 4
.el .IP "Can't remove \f(CW%s:\fR \f(CW%s\fR, skippin file" 4
.IX Item "Can't remove %s: %s, skippin file"
(S) Yo ass axed a inplace edit without bustin a funky-ass backup file.  Perl
was unable ta remove tha original gangsta file ta replace it wit tha modified
file.  Da file was left unmodified.
.ie n .IP "Can't return %s from lvalue subroutine" 4
.el .IP "Can't return \f(CW%s\fR from lvalue subroutine" 4
.IX Item "Can't return %s from lvalue subroutine"
(F) Perl detected a attempt ta return illegal lvalues (such
as temporary or readonly joints) from a subroutine used as a lvalue.
This aint allowed.
.IP "Can't weaken a nonreference" 4
.IX Item "Can't weaken a nonreference"
(F) Yo ass attempted ta weaken suttin' dat was not a reference.  Only
references can be weakened.
.IP "Characta class [:%s:] unknown" 4
.IX Item "Characta class [:%s:] unknown"
(F) Da class up in tha characta class [: :] syntax is unknown.
See perlre.
.IP "Characta class syntax [%s] belongs inside characta classes" 4
.IX Item "Characta class syntax [%s] belongs inside characta classes"
(W unsafe) Da characta class constructs [: :], [= =], n' [. .]  go
\&\fIinside\fR characta classes, tha [] is part of tha construct,
for example: /[012[:alpha:]345]/.  Note dat [= =] n' [. .]
are not currently implemented; they is simply placeholdaz for
future extensions.
.ie n .IP "Constant aint %s reference" 4
.el .IP "Constant aint \f(CW%s\fR reference" 4
.IX Item "Constant aint %s reference"
(F) A constant value (like declared rockin tha \f(CW\*(C`use constant\*(C'\fR pragma)
is bein dereferenced yo, but it amounts ta tha wack type of reference.  The
message indicates tha type of reference dat was expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. This usually
indicates a syntax error up in dereferencin tha constant value.
See \*(L"Constant Functions\*(R" up in perlsub n' constant.
.ie n .IP "constant(%s): %s" 4
.el .IP "constant(%s): \f(CW%s\fR" 4
.IX Item "constant(%s): %s"
(F) Da parser found inconsistencies either while attemptin ta define an
overloaded constant, or when tryin ta find tha characta name specified
in tha \f(CW\*(C`\eN{...}\*(C'\fR escape.  Perhaps you forgot ta load tha corresponding
\&\f(CW\*(C`overload\*(C'\fR or \f(CW\*(C`charnames\*(C'\fR pragma?  See charnames n' overload.
.IP "CORE::%s aint a keyword" 4
.IX Item "CORE::%s aint a keyword"
(F) Da \s-1CORE::\s0 namespace is reserved fo' Perl keywords.
.IP "defined(@array) is deprecated" 4
.IX Item "defined(@array) is deprecated"
(D) \fIdefined()\fR aint probably useful on arrays cuz it checks fo' an
undefined \fIscalar\fR value.  If you wanna peep if tha array is empty,
just use \f(CW\*(C`if (@array) { # not empty }\*(C'\fR fo' example.
.IP "defined(%hash) is deprecated" 4
.IX Item "defined(%hash) is deprecated"
(D) \fIdefined()\fR aint probably useful on hashes cuz it checks fo' an
undefined \fIscalar\fR value.  If you wanna peep if tha hash is empty,
just use \f(CW\*(C`if (%hash) { # not empty }\*(C'\fR fo' example.
.IP "Did not produce a valid header" 4
.IX Item "Did not produce a valid header"
See Server error.
.ie n .IP "(Did yo dirty ass mean ""local"" instead of ""our""?)" 4
.el .IP "(Did yo dirty ass mean ``local'' instead of ``our''?)" 4
.IX Item "(Did yo dirty ass mean local instead of our?)"
(W misc) Remember dat \*(L"our\*(R" do not localize tha declared global variable.
Yo ass have declared it again n' again n' again up in tha same lexical scope, which seems superfluous.
.IP "Document gotz nuff no data" 4
.IX Item "Document gotz nuff no data"
See Server error.
.ie n .IP "enterin effectizzle %s failed" 4
.el .IP "enterin effectizzle \f(CW%s\fR failed" 4
.IX Item "enterin effectizzle %s failed"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, switchin tha real and
effectizzle uidz or gidz failed.
.ie n .IP "false [] range ""%s"" up in regexp" 4
.el .IP "false [] range ``%s'' up in regexp" 4
.IX Item "false [] range %s up in regexp"
(W regexp) A characta class range must start n' end at a literal character, not
another characta class like \f(CW\*(C`\ed\*(C'\fR or \f(CW\*(C`[:alpha:]\*(C'\fR.  Da \*(L"\-\*(R" up in yo' false
range is interpreted as a literal \*(L"\-\*(R".  Consider quotin tha \*(L"\-\*(R",  \*(L"\e\-\*(R".
See perlre.
.ie n .IP "Filehandle %s opened only fo' output" 4
.el .IP "Filehandle \f(CW%s\fR opened only fo' output" 4
.IX Item "Filehandle %s opened only fo' output"
(W io) Yo ass tried ta read from a gangbangin' filehandle opened only fo' writing.  If you
intended it ta be a read/write filehandle, you needed ta open it with
\&\*(L"+<\*(R" or \*(L"+>\*(R" or \*(L"+>>\*(R" instead of wit \*(L"<\*(R" or nothing.  If
you intended only ta read from tha file, use \*(L"<\*(R".  See
\&\*(L"open\*(R" up in perlfunc.
.ie n .IP "\fIflock()\fR on closed filehandle %s" 4
.el .IP "\fIflock()\fR on closed filehandle \f(CW%s\fR" 4
.IX Item "flock() on closed filehandle %s"
(W closed) Da filehandle you attemptin ta \fIflock()\fR gots itself closed some
time before now, nahmeean?  Peep yo' logic flow.  \fIflock()\fR operates on filehandles.
Is you attemptin ta booty-call \fIflock()\fR on a gangbangin' finger-lickin' dirhandle by tha same name?
.ie n .IP "Global symbol ""%s"" requires explicit package name" 4
.el .IP "Global symbol ``%s'' requires explicit package name" 4
.IX Item "Global symbol %s requires explicit package name"
(F) You've holla'd \*(L"use strict vars\*(R", which indicates dat all variables
must either be lexically scoped (usin \*(L"my\*(R"), declared beforehand using
\&\*(L"our\*(R", or explicitly qualified ta say which package tha global variable
is up in (usin \*(L"::\*(R").
.IP "Hexadecimal number > 0xffffffff non-portable" 4
.IX Item "Hexadecimal number > 0xffffffff non-portable"
(W portable) Da hexadecimal number you specified is larger than 2**32\-1
(4294967295) n' therefore non-portable between systems.  See
perlport fo' mo' on portabilitizzle concerns.
.ie n .IP "Ill-formed \s-1CRTL\s0 environ value ""%s""" 4
.el .IP "Ill-formed \s-1CRTL\s0 environ value ``%s''" 4
.IX Item "Ill-formed CRTL environ value %s"
(W internal) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read tha \s-1CRTL\s0z internal
environ array, n' encountered a element without tha \f(CW\*(C`=\*(C'\fR delimiter
used ta separate keys from joints, n' you can put dat on yo' toast.  Da element is ignored.
.IP "Ill-formed message up in prime_env_iter: |%s|" 4
.IX Item "Ill-formed message up in prime_env_iter: |%s|"
(W internal) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read a logical name
or \s-1CLI\s0 symbol definizzle when preparin ta iterate over \f(CW%ENV\fR, and
didn't peep tha expected delimita between key n' value, so the
line was ignored.
.ie n .IP "Illegal binary digit %s" 4
.el .IP "Illegal binary digit \f(CW%s\fR" 4
.IX Item "Illegal binary digit %s"
(F) Yo ass used a gangbangin' finger-lickin' digit other than 0 or 1 up in a funky-ass binary number.
.ie n .IP "Illegal binary digit %s ignored" 4
.el .IP "Illegal binary digit \f(CW%s\fR ignored" 4
.IX Item "Illegal binary digit %s ignored"
(W digit) Yo ass may have tried ta bust a gangbangin' finger-lickin' digit other than 0 or 1 up in a funky-ass binary number.
Interpretation of tha binary number stopped before tha offendin digit.
.IP "Illegal number of bits up in vec" 4
.IX Item "Illegal number of bits up in vec"
(F) Da number of bits up in \fIvec()\fR (the third argument) must be a juice of
two from 1 ta 32 (or 64, if yo' platform supports that).
.ie n .IP "Integer overflow up in %s number" 4
.el .IP "Integer overflow up in \f(CW%s\fR number" 4
.IX Item "Integer overflow up in %s number"
(W overflow) Da hexadecimal, octal or binary number you have specified either
as a literal or as a argument ta \fIhex()\fR or \fIoct()\fR is too big-ass fo' your
architecture, n' has been converted ta a gangbangin' floatin point number n' shit.  On a
32\-bit architecture tha phattest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note dat Perl
transparently promotes all numbers ta a gangbangin' floatin point representation
internally\*(--subject ta loss of precision errors up in subsequent
operations.
.ie n .IP "Invalid %s attribute: %s" 4
.el .IP "Invalid \f(CW%s\fR attribute: \f(CW%s\fR" 4
.IX Item "Invalid %s attribute: %s"
Da indicated attribute fo' a subroutine or variable was not recognized
by Perl or by a user-supplied handlez n' shit.  See attributes.
.ie n .IP "Invalid %s attributes: %s" 4
.el .IP "Invalid \f(CW%s\fR attributes: \f(CW%s\fR" 4
.IX Item "Invalid %s attributes: %s"
Da indicated attributes fo' a subroutine or variable was not recognized
by Perl or by a user-supplied handlez n' shit.  See attributes.
.ie n .IP "invalid [] range ""%s"" up in regexp" 4
.el .IP "invalid [] range ``%s'' up in regexp" 4
.IX Item "invalid [] range %s up in regexp"
Da offendin range is now explicitly displayed.
.ie n .IP "Invalid separator characta %s up in attribute list" 4
.el .IP "Invalid separator characta \f(CW%s\fR up in attribute list" 4
.IX Item "Invalid separator characta %s up in attribute list"
(F) Somethang other than a cold-ass lil colon or whitespace was peeped between the
elementz of a attribute list.  If tha previous attribute
had a parenthesised parameta list, like dat list was terminated
too soon. I aint talkin' bout chicken n' gravy biatch.  See attributes.
.ie n .IP "Invalid separator characta %s up in subroutine attribute list" 4
.el .IP "Invalid separator characta \f(CW%s\fR up in subroutine attribute list" 4
.IX Item "Invalid separator characta %s up in subroutine attribute list"
(F) Somethang other than a cold-ass lil colon or whitespace was peeped between the
elementz of a subroutine attribute list.  If tha previous attribute
had a parenthesised parameta list, like dat list was terminated
too soon.
.ie n .IP "leavin effectizzle %s failed" 4
.el .IP "leavin effectizzle \f(CW%s\fR failed" 4
.IX Item "leavin effectizzle %s failed"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, switchin tha real and
effectizzle uidz or gidz failed.
.ie n .IP "Lvalue subs returnin %s not implemented yet" 4
.el .IP "Lvalue subs returnin \f(CW%s\fR not implemented yet" 4
.IX Item "Lvalue subs returnin %s not implemented yet"
(F) Cuz of limitations up in tha current implementation, array n' hash
values cannot be returned up in subroutines used up in lvalue context.
See \*(L"Lvalue subroutines\*(R" up in perlsub.
.ie n .IP "Method %s not permitted" 4
.el .IP "Method \f(CW%s\fR not permitted" 4
.IX Item "Method %s not permitted"
See Server error.
.ie n .IP "Missin %sbrace%s on \eN{}" 4
.el .IP "Missin \f(CW%sbrace\fR%s on \eN{}" 4
.IX Item "Missin %sbrace%s on N{}"
(F) Wrong syntax of characta name literal \f(CW\*(C`\eN{charname}\*(C'\fR within
double-quotish context.
.IP "Missin command up in piped open" 4
.IX Item "Missin command up in piped open"
(W pipe) Yo ass used tha \f(CW\*(C`open(FH, "| command")\*(C'\fR or \f(CW\*(C`open(FH, "command |")\*(C'\fR
construction yo, but tha command was missin or blank.
.ie n .IP "Missin name up in ""my sub""" 4
.el .IP "Missin name up in ``my sub''" 4
.IX Item "Missin name up in mah sub"
(F) Da reserved syntax fo' lexically scoped subroutines requires dat they
have a name wit which they can be found.
.ie n .IP "No %s specified fo' \-%c" 4
.el .IP "No \f(CW%s\fR specified fo' \-%c" 4
.IX Item "No %s specified fo' -%c"
(F) Da indicated command line switch needz a mandatory argument yo, but
you aint specified one.
.ie n .IP "No package name allowed fo' variable %s up in ""our""" 4
.el .IP "No package name allowed fo' variable \f(CW%s\fR up in ``our''" 4
.IX Item "No package name allowed fo' variable %s up in our"
(F) Fully qualified variable names is not allowed up in \*(L"our\*(R" declarations,
because dat don't make much sense under existin semantics.  Such
syntax is reserved fo' future extensions.
.IP "No space allowed afta \-%c" 4
.IX Item "No space allowed afta -%c"
(F) Da argument ta tha indicated command line switch must follow immediately
afta tha switch, without intervenin spaces.
.IP "no \s-1UTC\s0 offset shiznit; assumin local time is \s-1UTC\s0" 4
.IX Item "no UTC offset shiznit; assumin local time is UTC"
(S) A warnin peculiar ta \s-1VMS. \s0 Perl was unable ta find tha local
timezone offset, so itz assumin dat local system time is equivalent
to \s-1UTC. \s0 If itz not, define tha logical name \fI\s-1SYS$TIMEZONE_DIFFERENTIAL\s0\fR
to translate ta tha number of secondz which need ta be added ta \s-1UTC\s0 to
get local time.
.IP "Octal number > 037777777777 non-portable" 4
.IX Item "Octal number > 037777777777 non-portable"
(W portable) Da octal number you specified is larger than 2**32\-1 (4294967295)
and therefore non-portable between systems.  See perlport fo' more
on portabilitizzle concerns.
.Sp
See also perlport fo' freestylin portable code.
.IP "panic: del_backref" 4
.IX Item "panic: del_backref"
(P) Failed a internal consistency check while tryin ta reset a weak
reference.
.IP "panic: kid pimpn errno read" 4
.IX Item "panic: kid pimpn errno read"
(F) forked lil pimp returned a incomprehensible message bout its errno.
.IP "panic: magic_killbackrefs" 4
.IX Item "panic: magic_killbackrefs"
(P) Failed a internal consistency check while tryin ta reset all weak
references ta a object.
.ie n .IP "Parentheses missin round ""%s"" list" 4
.el .IP "Parentheses missin round ``%s'' list" 4
.IX Item "Parentheses missin round %s list"
(W parenthesis) Yo ass holla'd suttin' like
.Sp
.Vb 1
\&    mah $foo, $bar = @_;
.Ve
.Sp
when you meant
.Sp
.Vb 1
\&    mah ($foo, $bar) = @_;
.Ve
.Sp
Remember dat \*(L"my\*(R", \*(L"our\*(R", n' \*(L"local\*(R" bind tighta than comma.
.ie n .IP "Possible unintended interpolation of %s up in string" 4
.el .IP "Possible unintended interpolation of \f(CW%s\fR up in string" 4
.IX Item "Possible unintended interpolation of %s up in string"
(W ambiguous) It used ta be dat Perl would try ta guess whether you
wanted a array interpolated or a literal @.  It no longer do this;
arrays is now \fIalways\fR interpolated tha fuck into strings.  This means dat 
if you try suttin' like:
.Sp
.Vb 1
\&        print "fred@example.com";
.Ve
.Sp
and tha array \f(CW@example\fR don't exist, Perl is goin ta print
\&\f(CW\*(C`fred.com\*(C'\fR, which is probably not what tha fuck you wanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  To git a literal
\&\f(CW\*(C`@\*(C'\fR sign up in a string, put a funky-ass backslash before it, just as you would
to git a literal \f(CW\*(C`$\*(C'\fR sign.
.ie n .IP "Possible Y2K bug: %s" 4
.el .IP "Possible Y2K bug: \f(CW%s\fR" 4
.IX Item "Possible Y2K bug: %s"
(W y2k) Yo ass is concatenatin tha number 19 wit another number, which
could be a potential Year 2000 problem.
.ie n .IP "pragma ""attrs"" is deprecated, use ""sub \s-1NAME : ATTRS""\s0 instead" 4
.el .IP "pragma ``attrs'' is deprecated, use ``sub \s-1NAME : ATTRS''\s0 instead" 4
.IX Item "pragma attrs is deprecated, use sub NAME : ATTRS instead"
(W deprecated) Yo ass have freestyled suttin' like this:
.Sp
.Vb 4
\&    sub doit
\&    {
\&        use attrs qw(locked);
\&    }
.Ve
.Sp
Yo ass should use tha freshly smoked up declaration syntax instead.
.Sp
.Vb 3
\&    sub doit : locked
\&    {
\&        ...
.Ve
.Sp
Da \f(CW\*(C`use attrs\*(C'\fR pragma is now obsolete, n' is only provided for
backward-compatibility. Right back up in yo muthafuckin ass. See \*(L"Subroutine Attributes\*(R" up in perlsub.
.IP "Premature end of script headers" 4
.IX Item "Premature end of script headers"
See Server error.
.IP "Repeat count up in pack overflows" 4
.IX Item "Repeat count up in pack overflows"
(F) Yo ass can't specify a repeat count so big-ass dat it overflows
your signed integers.  See \*(L"pack\*(R" up in perlfunc.
.IP "Repeat count up in unpack overflows" 4
.IX Item "Repeat count up in unpack overflows"
(F) Yo ass can't specify a repeat count so big-ass dat it overflows
your signed integers.  See \*(L"unpack\*(R" up in perlfunc.
.IP "\fIrealloc()\fR of freed memory ignored" 4
.IX Item "realloc() of freed memory ignored"
(S) An internal routine called \fIrealloc()\fR on suttin' dat had already
been freed.
.IP "Reference be already weak" 4
.IX Item "Reference be already weak"
(W misc) Yo ass have attempted ta weaken a reference dat be already weak.
Bustin so has no effect.
.IP "setpgrp can't take arguments" 4
.IX Item "setpgrp can't take arguments"
(F) Yo crazy-ass system has tha \fIsetpgrp()\fR from \s-1BSD 4.2,\s0 which takes no arguments,
unlike \s-1POSIX\s0 \fIsetpgid()\fR, which takes a process \s-1ID\s0 n' process crew \s-1ID.\s0
.IP "Strange *+?{} on zero-length expression" 4
.IX Item "Strange *+?{} on zero-length expression"
(W regexp) Yo ass applied a regular expression quantifier up in a place where it
makes no sense, like fuckin on a zero-width assertion.
Try puttin tha quantifier inside tha assertion instead. Y'all KNOW dat shit, muthafucka!  For example,
the way ta match \*(L"abc\*(R" provided dat it is followed by three
repetitionz of \*(L"xyz\*(R" is \f(CW\*(C`/abc(?=(?:xyz){3})/\*(C'\fR, not \f(CW\*(C`/abc(?=xyz){3}/\*(C'\fR.
.ie n .IP "switchin effectizzle %s aint implemented" 4
.el .IP "switchin effectizzle \f(CW%s\fR aint implemented" 4
.IX Item "switchin effectizzle %s aint implemented"
(F) While under tha \f(CW\*(C`use filetest\*(C'\fR pragma, we cannot switch the
real n' effectizzle uidz or gids.
.IP "This Perl can't reset \s-1CRTL\s0 environ elements (%s)" 4
.IX Item "This Perl can't reset CRTL environ elements (%s)"
.PD 0
.IP "This Perl can't set \s-1CRTL\s0 environ elements (%s=%s)" 4
.IX Item "This Perl can't set CRTL environ elements (%s=%s)"
.PD
(W internal) Warnings peculiar ta \s-1VMS. \s0 Yo ass tried ta chizzle or delete a element
of tha \s-1CRTL\s0z internal environ array yo, but yo' copy of Perl wasn't
built wit a \s-1CRTL\s0 dat contained tha \fIsetenv()\fR function. I aint talkin' bout chicken n' gravy biatch.  You'll need to
rebuild Perl wit a \s-1CRTL\s0 dat do, or redefine \fI\s-1PERL_ENV_TABLES\s0\fR (see
perlvms) so dat tha environ array aint tha target of tha chizzle to
\&\f(CW%ENV\fR which produced tha warning.
.ie n .IP "Too late ta run %s block" 4
.el .IP "Too late ta run \f(CW%s\fR block" 4
.IX Item "Too late ta run %s block"
(W void) A \s-1CHECK\s0 or \s-1INIT\s0 block is bein defined durin run time proper,
when tha opportunitizzle ta run dem has already passed. Y'all KNOW dat shit, muthafucka!  Perhaps yo ass is
loadin a gangbangin' file wit \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR when you should be using
\&\f(CW\*(C`use\*(C'\fR instead. Y'all KNOW dat shit, muthafucka!  Or like you should put tha \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`do\*(C'\fR
inside a \s-1BEGIN\s0 block.
.IP "Unknown \fIopen()\fR mode '%s'" 4
.IX Item "Unknown open() mode '%s'"
(F) Da second argument of 3\-argument \fIopen()\fR aint among tha list
of valid modes: \f(CW\*(C`<\*(C'\fR, \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`>>\*(C'\fR, \f(CW\*(C`+<\*(C'\fR,
\&\f(CW\*(C`+>\*(C'\fR, \f(CW\*(C`+>>\*(C'\fR, \f(CW\*(C`\-|\*(C'\fR, \f(CW\*(C`|\-\*(C'\fR.
.ie n .IP "Unknown process %x busted message ta prime_env_iter: %s" 4
.el .IP "Unknown process \f(CW%x\fR busted message ta prime_env_iter: \f(CW%s\fR" 4
.IX Item "Unknown process %x busted message ta prime_env_iter: %s"
(P) An error peculiar ta \s-1VMS. \s0 Perl was readin joints fo' \f(CW%ENV\fR before
iteratin over it, n' one of mah thugs stuck a message up in tha stream of
data Perl expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Someonez straight-up confused, or like tryin to
subvert Perlz population of \f(CW%ENV\fR fo' nefarious purposes.
.IP "Unrecognized escape \e\e%c passed through" 4
.IX Item "Unrecognized escape %c passed through"
(W misc) Yo ass used a funky-ass backslash-characta combination which aint recognized
by Perl.  Da characta was understood literally.
.IP "Unterminated attribute parameta up in attribute list" 4
.IX Item "Unterminated attribute parameta up in attribute list"
(F) Da lexer saw a openin (left) parenthesis characta while parsin an
attribute list yo, but tha matchin closin (right) parenthesis
characta was not found. Y'all KNOW dat shit, muthafucka!  Yo ass may need ta add (or remove) a funky-ass backslash
characta ta git yo' parentheses ta balance.  See attributes.
.IP "Unterminated attribute list" 4
.IX Item "Unterminated attribute list"
(F) Da lexer found suttin' other than a simple identifier all up in tha start
of a attribute, n' it wasn't a semicolon or tha start of a
block.  Perhaps you terminated tha parameta list of tha previous attribute
too soon. I aint talkin' bout chicken n' gravy biatch.  See attributes.
.IP "Unterminated attribute parameta up in subroutine attribute list" 4
.IX Item "Unterminated attribute parameta up in subroutine attribute list"
(F) Da lexer saw a openin (left) parenthesis characta while parsin a
subroutine attribute list yo, but tha matchin closin (right) parenthesis
characta was not found. Y'all KNOW dat shit, muthafucka!  Yo ass may need ta add (or remove) a funky-ass backslash
characta ta git yo' parentheses ta balance.
.IP "Unterminated subroutine attribute list" 4
.IX Item "Unterminated subroutine attribute list"
(F) Da lexer found suttin' other than a simple identifier all up in tha start
of a subroutine attribute, n' it wasn't a semicolon or tha start of a
block.  Perhaps you terminated tha parameta list of tha previous attribute
too soon.
.ie n .IP "Value of \s-1CLI\s0 symbol ""%s"" too long" 4
.el .IP "Value of \s-1CLI\s0 symbol ``%s'' too long" 4
.IX Item "Value of CLI symbol %s too long"
(W misc) A warnin peculiar ta \s-1VMS. \s0 Perl tried ta read tha value of a \f(CW%ENV\fR
element from a \s-1CLI\s0 symbol table, n' found a resultant strang longer
than 1024 characters.  Da return value has been truncated ta 1024
characters.
.IP "Version number must be a cold-ass lil constant number" 4
.IX Item "Version number must be a cold-ass lil constant number"
(P) Da attempt ta translate a \f(CW\*(C`use Module n.n LIST\*(C'\fR statement into
its equivalent \f(CW\*(C`BEGIN\*(C'\fR block found a internal inconsistency with
the version number.
.SH "New tests"
.IX Header "New tests"
.IP "lib/attrs" 4
.IX Item "lib/attrs"
Compatibilitizzle tests fo' \f(CW\*(C`sub : attrs\*(C'\fR vs tha olda \f(CW\*(C`use attrs\*(C'\fR.
.IP "lib/env" 4
.IX Item "lib/env"
Tests fo' freshly smoked up environment scalar capabilitizzle (e.g., \f(CW\*(C`use Env qw($BAR);\*(C'\fR).
.IP "lib/env\-array" 4
.IX Item "lib/env-array"
Tests fo' freshly smoked up environment array capabilitizzle (e.g., \f(CW\*(C`use Env qw(@PATH);\*(C'\fR).
.IP "lib/io_const" 4
.IX Item "lib/io_const"
\&\s-1IO\s0 constants (SEEK_*, _IO*).
.IP "lib/io_dir" 4
.IX Item "lib/io_dir"
Directory-related \s-1IO\s0 methodz (new, read, close, rewind, tied delete).
.IP "lib/io_multihomed" 4
.IX Item "lib/io_multihomed"
\&\s-1INET\s0 sockets wit multi-homed hosts.
.IP "lib/io_poll" 4
.IX Item "lib/io_poll"
\&\s-1IO\s0 \fIpoll()\fR.
.IP "lib/io_unix" 4
.IX Item "lib/io_unix"
\&\s-1UNIX\s0 sockets.
.IP "op/attrs" 4
.IX Item "op/attrs"
Regression tests fo' \f(CW\*(C`my ($x,@y,%z) : attrs\*(C'\fR n' <sub : attrs>.
.IP "op/filetest" 4
.IX Item "op/filetest"
File test operators.
.IP "op/lex_assign" 4
.IX Item "op/lex_assign"
Verify operations dat access pad objects (lexicals n' temporaries).
.IP "op/exists_sub" 4
.IX Item "op/exists_sub"
Verify \f(CW\*(C`exists &sub\*(C'\fR operations.
.SH "Incompatible Chizzles"
.IX Header "Incompatible Chizzles"
.SS "Perl Source Incompatibilities"
.IX Subsection "Perl Source Incompatibilities"
Beware dat any freshly smoked up warnings dat done been added or oldschool ones
that done been enhanced is \fBnot\fR considered incompatible chizzles.
.PP
Since all freshly smoked up warnings must be explicitly axed via tha \f(CW\*(C`\-w\*(C'\fR
switch or tha \f(CW\*(C`warnings\*(C'\fR pragma, it is ultimately tha programmer's
responsibilitizzle ta ensure dat warnings is enabled judiciously.
.IP "\s-1CHECK\s0 be a freshly smoked up keyword" 4
.IX Item "CHECK be a freshly smoked up keyword"
All subroutine definitions named \s-1CHECK\s0 is now special. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See
\&\f(CW\*(C`/"Support fo' CHECK blocks"\*(C'\fR fo' mo' shiznit.
.IP "Treatment of list slicez of undef has chizzled" 4
.IX Item "Treatment of list slicez of undef has chizzled"
There be a potential incompatibilitizzle up in tha behavior of list slices
that is comprised entirely of undefined joints.
See \*(L"Behavior of list slices is mo' consistent\*(R".
.ie n .IP "Format of $English::PERL_VERSION is different" 4
.el .IP "Format of \f(CW$English::PERL_VERSION\fR is different" 4
.IX Item "Format of $English::PERL_VERSION is different"
Da Gangsta module now sets \f(CW$PERL_VERSION\fR ta $^V (a strang value) rather
than \f(CW$]\fR (a numeric value).  This be a potential incompatibility.
Send our asses a report via perlbug if yo ass be affected by all dis bullshit.
.Sp
See \*(L"Improved Perl version numberin system\*(R" fo' tha reasons for
this chizzle.
.ie n .IP "Literalz of tha form 1.2.3 parse differently" 4
.el .IP "Literalz of tha form \f(CW1.2.3\fR parse differently" 4
.IX Item "Literalz of tha form 1.2.3 parse differently"
Previously, numeric literals wit mo' than one dot up in dem were
interpreted as a gangbangin' floatin point number concatenated wit one or more
numbers.  Such \*(L"numbers\*(R" is now parsed as strings composed of the
specified ordinals.
.Sp
For example, \f(CW\*(C`print 97.98.99\*(C'\fR used ta output \f(CW97.9899\fR up in earlier
versions yo, but now prints \f(CW\*(C`abc\*(C'\fR.
.Sp
See \*(L"Support fo' strings represented as a vector of ordinals\*(R".
.IP "Possibly chizzled pseudo-random number generator" 4
.IX Item "Possibly chizzled pseudo-random number generator"
Perl programs dat depend on reproducin a specific set of pseudo-random
numbers may now produce different output cuz of improvements made ta the
\&\fIrand()\fR builtin. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use \f(CW\*(C`sh Configure \-Drandfunc=rand\*(C'\fR ta obtain
the oldschool behavior.
.Sp
See \*(L"Betta pseudo-random number generator\*(R".
.IP "Hashin function fo' hash keys has chizzled" 4
.IX Item "Hashin function fo' hash keys has chizzled"
Even though Perl hashes is not order preserving, tha apparently
random order encountered when iteratin on tha contentz of a hash
is straight-up determined by tha hashin algorithm used. Y'all KNOW dat shit, muthafucka!  Improvements
in tha algorithm may yield a random order dat is \fBdifferent\fR from
that of previous versions, especially when iteratin on hashes.
.Sp
See \*(L"Betta worst-case behavior of hashes\*(R" fo' additional
information.
.ie n .IP """undef"" fails on read only joints" 4
.el .IP "\f(CWundef\fR fails on read only joints" 4
.IX Item "undef fails on read only joints"
Usin tha \f(CW\*(C`undef\*(C'\fR operator on a readonly value (like fuckin \f(CW$1\fR) has
the same effect as assignin \f(CW\*(C`undef\*(C'\fR ta tha readonly value\*(--it
throws a exception.
.IP "Close-on-exec bit may be set on pipe n' socket handles" 4
.IX Item "Close-on-exec bit may be set on pipe n' socket handles"
Pipe n' socket handlez is also now subject ta tha close-on-exec
behavior determined by tha special variable $^F.
.Sp
See \*(L"Mo' consistent close-on-exec behavior\*(R".
.ie n .IP "Freestylin ""$$1"" ta mean ""${$}1"" is unsupported" 4
.el .IP "Freestylin \f(CW``$$1''\fR ta mean \f(CW``${$}1''\fR is unsupported" 4
.IX Item "Freestylin ""$$1"" ta mean ""${$}1"" is unsupported"
Perl 5.004 deprecated tha interpretation of \f(CW$$1\fR and
similar within interpolated strings ta mean \f(CW\*(C`$$ . "1"\*(C'\fR,
but still allowed dat shit.
.Sp
In Perl 5.6.0 n' later, \f(CW"$$1"\fR always means \f(CW"${$1}"\fR.
.ie n .IP "\fIdelete()\fR, \fIeach()\fR, \fIvalues()\fR n' ""\e(%h)""" 4
.el .IP "\fIdelete()\fR, \fIeach()\fR, \fIvalues()\fR n' \f(CW\e(%h)\fR" 4
.IX Item "delete(), each(), joints() n' )"
operate on aliases ta joints, not copies
.Sp
\&\fIdelete()\fR, \fIeach()\fR, \fIvalues()\fR n' hashes (e.g. \f(CW\*(C`\e(%h)\*(C'\fR)
in a list context return tha actual
values up in tha hash, instead of copies (as they used ta up in earlier
versions).  Typical idioms fo' rockin these constructs copy the
returned joints yo, but dis can cook up a thugged-out dope difference when
bustin references ta tha returned joints, n' you can put dat on yo' toast.  Keys up in tha hash is still
returned as copies when iteratin on a hash.
.Sp
See also \*(L"\fIdelete()\fR, \fIeach()\fR, \fIvalues()\fR n' hash iteration is faster\*(R".
.IP "vec(\s-1EXPR,OFFSET,BITS\s0) enforces powers-of-two \s-1BITS\s0" 4
.IX Item "vec(EXPR,OFFSET,BITS) enforces powers-of-two BITS"
\&\fIvec()\fR generates a run-time error if tha \s-1BITS\s0 argument is not
a valid power-of-two integer.
.IP "Text of some diagnostic output has chizzled" 4
.IX Item "Text of some diagnostic output has chizzled"
Most references ta internal Perl operations up in diagnostics
have been chizzled ta be mo' descriptive.  This may be an
issue fo' programs dat may incorrectly rely on tha exact
text of diagnostics fo' proper functioning.
.ie n .IP """%@"" has been removed" 4
.el .IP "\f(CW%@\fR has been removed" 4
.IX Item "%@ has been removed"
Da undocumented special variable \f(CW\*(C`%@\*(C'\fR dat used ta accumulate
\&\*(L"background\*(R" errors (like fuckin dem dat happen up in \s-1\fIDESTROY\s0()\fR)
has been removed, cuz it could potentially result up in memory
leaks.
.IP "Parenthesized \fInot()\fR behaves like a list operator" 4
.IX Item "Parenthesized not() behaves like a list operator"
Da \f(CW\*(C`not\*(C'\fR operator now falls under tha \*(L"if it be lookin like a gangbangin' function,
it behaves like a gangbangin' function\*(R" rule.
.Sp
As a result, tha parenthesized form can be used wit \f(CW\*(C`grep\*(C'\fR n' \f(CW\*(C`map\*(C'\fR.
Da followin construct used ta be a syntax error before yo, but it works
as expected now:
.Sp
.Vb 1
\&    grep not($_), @things;
.Ve
.Sp
On tha other hand, rockin \f(CW\*(C`not\*(C'\fR wit a literal list slice may not
work.  Da followin previously allowed construct:
.Sp
.Vb 1
\&    print not (1,2,3)[0];
.Ve
.Sp
needz ta be freestyled wit additionizzle parentheses now:
.Sp
.Vb 1
\&    print not((1,2,3)[0]);
.Ve
.Sp
Da behavior remains unaffected when \f(CW\*(C`not\*(C'\fR aint followed by parentheses.
.ie n .IP "Semantics of bareword prototype ""(*)"" have chizzled" 4
.el .IP "Semantics of bareword prototype \f(CW(*)\fR have chizzled" 4
.IX Item "Semantics of bareword prototype (*) have chizzled"
Da semantics of tha bareword prototype \f(CW\*(C`*\*(C'\fR have chizzled. Y'all KNOW dat shit, muthafucka!  Perl 5.005
always coerced simple scalar arguments ta a typeglob, which wasn't useful
in thangs where tha subroutine must distinguish between a simple
scalar n' a typeglob.  Da freshly smoked up behavior is ta not coerce bareword
arguments ta a typeglob.  Da value will always be visible as either
a simple scalar or as a reference ta a typeglob.
.Sp
See \*(L"Mo' functionizzle bareword prototype (*)\*(R".
.IP "Semantics of bit operators may have chizzled on 64\-bit platforms" 4
.IX Item "Semantics of bit operators may have chizzled on 64-bit platforms"
If yo' platform is either natively 64\-bit or if Perl has been
configured ta used 64\-bit integers, i.e., \f(CW$Config\fR{ivsize} is 8, 
there may be a potential incompatibilitizzle up in tha behavior of bitwise
numeric operators (& | ^ ~ << >>).  These operators used ta strictly
operate on tha lower 32 bitz of integers up in previous versions yo, but now
operate over tha entire natizzle integral width.  In particular, note
that unary \f(CW\*(C`~\*(C'\fR will produce different thangs up in dis biatch on platforms dat have
different \f(CW$Config\fR{ivsize}.  For portability, be shizzle ta mask off
the excess bits up in tha result of unary \f(CW\*(C`~\*(C'\fR, e.g., \f(CW\*(C`~$x & 0xffffffff\*(C'\fR.
.Sp
See \*(L"Bit operators support full natizzle integer width\*(R".
.IP "Mo' builtins taint they thangs up in dis biatch" 4
.IX Item "Mo' builtins taint they thangs up in dis biatch"
As busted lyrics bout up in \*(L"Improved securitizzle features\*(R", there may be more
sourcez of taint up in a Perl program.
.Sp
To avoid these freshly smoked up taintin behaviors, you can build Perl wit the
Configure option \f(CW\*(C`\-Accflags=\-DINCOMPLETE_TAINTS\*(C'\fR.  Beware dat the
ensuin perl binary may be insecure.
.SS "C Source Incompatibilities"
.IX Subsection "C Source Incompatibilities"
.ie n .IP """PERL_POLLUTE""" 4
.el .IP "\f(CWPERL_POLLUTE\fR" 4
.IX Item "PERL_POLLUTE"
Release 5.005 grandfathered oldschool global symbol names by providin preprocessor
macros fo' extension source compatibility.  Az of release 5.6.0, these
preprocessor definitions is not available by default.  Yo ass need ta explicitly
compile perl wit \f(CW\*(C`\-DPERL_POLLUTE\*(C'\fR ta git these definitions.  For
extensions still rockin tha oldschool symbols, dis option can be
specified via MakeMaker:
.Sp
.Vb 1
\&    perl Makefile.PL POLLUTE=1
.Ve
.ie n .IP """PERL_IMPLICIT_CONTEXT""" 4
.el .IP "\f(CWPERL_IMPLICIT_CONTEXT\fR" 4
.IX Item "PERL_IMPLICIT_CONTEXT"
This freshly smoked up build option serves up a set of macros fo' all \s-1API\s0 functions
such dat a implicit interpreter/thread context argument is passed to
every \s-1API\s0 function. I aint talkin' bout chicken n' gravy biatch.  As a result of this, suttin' like \f(CW\*(C`sv_setsv(foo,bar)\*(C'\fR
amounts ta a macro invocation dat straight-up translates ta suttin' like
\&\f(CW\*(C`Perl_sv_setsv(my_perl,foo,bar)\*(C'\fR.  While dis is generally expected
to not have any dope source compatibilitizzle issues, tha difference
between a macro n' a real function call will need ta be considered.
.Sp
This means dat there \fBis\fR a source compatibilitizzle issue as a result of
this if yo' extensions attempt ta use pointas ta any of tha Perl \s-1API\s0
functions.
.Sp
Note dat tha above issue aint relevant ta tha default build of
Perl, whose intercourses continue ta match dem of prior versions
(but subject ta tha other options busted lyrics bout here).
.Sp
See \*(L"Background n' \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 up in perlguts fo' detailed shiznit on the
ramificationz of buildin Perl wit dis option.
.Sp
.Vb 3
\&    NOTE: PERL_IMPLICIT_CONTEXT be automatically enabled whenever Perl is built
\&    wit one of \-Dusethreads, \-Dusemultiplicity, or both.  It be not
\&    intended ta be enabled by playas at dis time.
.Ve
.ie n .IP """PERL_POLLUTE_MALLOC""" 4
.el .IP "\f(CWPERL_POLLUTE_MALLOC\fR" 4
.IX Item "PERL_POLLUTE_MALLOC"
Enablin Perlz malloc up in release 5.005 n' earlier caused tha namespace of
the systemz malloc crew of functions ta be usurped by tha Perl versions,
since by default they used tha same names.  Besides causin problems on
platforms dat do not allow these functions ta be cleanly replaced, this
also meant dat tha system versions could not be called up in programs that
used Perlz malloc.  Previous versionz of Perl have allowed dis behaviour
to be suppressed wit tha \s-1HIDEMYMALLOC\s0 n' \s-1EMBEDMYMALLOC\s0 preprocessor
definitions.
.Sp
Az of release 5.6.0, Perlz malloc crew of functions have default names
distinct from tha system versions.  Yo ass need ta explicitly compile perl with
\&\f(CW\*(C`\-DPERL_POLLUTE_MALLOC\*(C'\fR ta git tha olda behaviour. Shiiit, dis aint no joke.  \s-1HIDEMYMALLOC\s0
and \s-1EMBEDMYMALLOC\s0 have no effect, since tha behaviour they enabled is now
the default.
.Sp
Note dat these functions do \fBnot\fR constitute Perlz memory allocation \s-1API.\s0
See \*(L"Memory Allocation\*(R" up in perlguts fo' further shiznit bout dis shit.
.SS "Compatible C Source \s-1API\s0 Chizzles"
.IX Subsection "Compatible C Source API Chizzles"
.ie n .IP """PATCHLEVEL"" is now ""PERL_VERSION""" 4
.el .IP "\f(CWPATCHLEVEL\fR is now \f(CWPERL_VERSION\fR" 4
.IX Item "PATCHLEVEL is now PERL_VERSION"
Da cpp macros \f(CW\*(C`PERL_REVISION\*(C'\fR, \f(CW\*(C`PERL_VERSION\*(C'\fR, n' \f(CW\*(C`PERL_SUBVERSION\*(C'\fR
are now available by default from perl.h, n' reflect tha base revision,
patchlevel, n' subversion respectively.  \f(CW\*(C`PERL_REVISION\*(C'\fR had no
prior equivalent, while \f(CW\*(C`PERL_VERSION\*(C'\fR n' \f(CW\*(C`PERL_SUBVERSION\*(C'\fR were
previously available as \f(CW\*(C`PATCHLEVEL\*(C'\fR n' \f(CW\*(C`SUBVERSION\*(C'\fR.
.Sp
Da freshly smoked up names cause less bullshit of tha \fBcpp\fR namespace n' reflect what
the numbers have come ta stand fo' up in common practice.  For compatibility,
the oldschool names is still supported when \fIpatchlevel.h\fR is explicitly
included (as required before), so there is no source incompatibility
from tha chizzle.
.SS "Binary Incompatibilities"
.IX Subsection "Binary Incompatibilities"
In general, tha default build of dis release is sposed ta fuckin be binary
compatible fo' extensions built wit tha 5.005 release or its maintenance
versions.  But fuck dat shiznit yo, tha word on tha street is dat specific platforms may have fucked up binary compatibility
due ta chizzlez up in tha defaults used up in hints files.  Therefore, please be
sure ta always check tha platform-specific \s-1README\s0 filez fo' any notes to
the contrary.
.PP
Da usethreadz or usemultiplicitizzle buildz is \fBnot\fR binary compatible
with tha correspondin buildz up in 5.005.
.PP
On platforms dat require a explicit list of exports (\s-1AIX, OS/2\s0 n' Windows,
among others), purely internal symbols like fuckin parser functions n' the
run time opcodes is not exported by default.  Perl 5.005 used ta export
all functions irrespectizzle of whether they was considered part of the
hood \s-1API\s0 or not.
.PP
For tha full list of hood \s-1API\s0 functions, peep perlapi.
.SH "Known Problems"
.IX Header "Known Problems"
.SS "Thread test failures"
.IX Subsection "Thread test failures"
Da subtests 19 n' 20 of lib/thr5005.t test is known ta fail due to
fundamenstrual problems up in tha 5.005 threadin implementation. I aint talkin' bout chicken n' gravy biatch.  These are
not freshly smoked up failures\*(--Perl 5.005_0x has tha same ol' dirty bugs yo, but didn't have these
tests.
.SS "\s-1EBCDIC\s0 platforms not supported"
.IX Subsection "EBCDIC platforms not supported"
In earlier releasez of Perl, \s-1EBCDIC\s0 environments like \s-1OS390 \s0(also
known as Open Edizzle \s-1MVS\s0) n' VM-ESA was supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Cuz of chizzles
required by tha \s-1UTF\-8 \s0(Unicode) support, tha \s-1EBCDIC\s0 platforms is not
supported up in Perl 5.6.0.
.SS "In 64\-bit HP-UX tha lib/io_multihomed test may hang"
.IX Subsection "In 64-bit HP-UX tha lib/io_multihomed test may hang"
Da lib/io_multihomed test may hang up in HP-UX if Perl has been
configured ta be 64\-bit.  Because other 64\-bit platforms do not
hang up in dis test, HP-UX is suspect.  All other tests pass
in 64\-bit HP-UX.  Da test attempts ta create n' connect to
\&\*(L"multihomed\*(R" sockets (sockets which have multiple \s-1IP\s0 addresses).
.SS "\s-1NEXTSTEP 3.3 POSIX\s0 test failure"
.IX Subsection "NEXTSTEP 3.3 POSIX test failure"
In \s-1NEXTSTEP 3\s0.3p2 tha implementation of tha \fIstrftime\fR\|(3) up in the
operatin system libraries is buggy: tha \f(CW%j\fR format numbers tha minutes of
a month startin from zero, which, while bein logical ta programmers,
will cause tha subtests 19 ta 27 of tha lib/posix test may fail.
.SS "Tru64 (aka Digital \s-1UNIX,\s0 aka \s-1DEC OSF/1\s0) lib/sdbm test failure wit gcc"
.IX Subsection "Tru64 (aka Digital UNIX, aka DEC OSF/1) lib/sdbm test failure wit gcc"
If compiled wit gcc 2.95 tha lib/sdbm test will fail (dump core).
Da cure is ta use tha vendor cc, it comes wit tha operatin system
and produces phat code.
.SS "UNICOS/mk \s-1CC\s0 failures durin Configure run"
.IX Subsection "UNICOS/mk CC failures durin Configure run"
In UNICOS/mk tha followin errors may step tha fuck up durin tha Configure run:
.PP
.Vb 6
\&        Guessin which symbols yo' C compila n' preprocessor define...
\&        CC\-20 cc: ERROR File = try.c, Line = 3
\&        ...
\&          wack switch yylook 79bad switch yylook 79bad switch yylook 79bad switch yylook 79#ifdef A29K
\&        ...
\&        4 errors detected up in tha compilation of "try.c".
.Ve
.PP
Da culprit is tha fucked up awk of UNICOS/mk.  Da effect is fortunately
rather mild: Perl itself aint adversely affected by tha error, only
the h2ph utilitizzle comin wit Perl, n' dat is rather rarely needed
these days.
.SS "Arrow operator n' arrays"
.IX Subsection "Arrow operator n' arrays"
When tha left argument ta tha arrow operator \f(CW\*(C`\->\*(C'\fR be a array, or
the \f(CW\*(C`scalar\*(C'\fR operator operatin on a array, tha result of the
operation must be considered erroneous. For example:
.PP
.Vb 2
\&    @x\->[2]
\&    scalar(@x)\->[2]
.Ve
.PP
These expressions will git run-time errors up in some future release of
Perl.
.SS "Experimenstrual features"
.IX Subsection "Experimenstrual features"
As discussed above, nuff features is still experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Interfaces and
implementation of these features is subject ta chizzle, n' up in off tha hook cases,
even subject ta removal up in some future release of Perl.  These features
include tha following:
.IP "Threads" 4
.IX Item "Threads"
.PD 0
.IP "Unicode" 4
.IX Item "Unicode"
.IP "64\-bit support" 4
.IX Item "64-bit support"
.IP "Lvalue subroutines" 4
.IX Item "Lvalue subroutines"
.IP "Weak references" 4
.IX Item "Weak references"
.IP "Da pseudo-hash data type" 4
.IX Item "Da pseudo-hash data type"
.IP "Da Compila suite" 4
.IX Item "Da Compila suite"
.IP "Internal implementation of file globbing" 4
.IX Item "Internal implementation of file globbing"
.IP "Da \s-1DB\s0 module" 4
.IX Item "Da DB module"
.IP "Da regular expression code constructs:" 4
.IX Item "Da regular expression code constructs:"
.PD
\&\f(CW\*(C`(?{ code })\*(C'\fR n' \f(CW\*(C`(??{ code })\*(C'\fR
.SH "Obsolete Diagnostics"
.IX Header "Obsolete Diagnostics"
.IP "Characta class syntax [: :] is reserved fo' future extensions" 4
.IX Item "Characta class syntax [: :] is reserved fo' future extensions"
(W) Within regular expression characta classes ([]) tha syntax beginning
with \*(L"[:\*(R" n' endin wit \*(L":]\*(R" is reserved fo' future extensions.
If you need ta represent dem characta sequences inside a regular
expression characta class, just quote tha square brackets wit the
backslash: \*(L"\e[:\*(R" n' \*(L":\e]\*(R".
.IP "Ill-formed logical name |%s| up in prime_env_iter" 4
.IX Item "Ill-formed logical name |%s| up in prime_env_iter"
(W) A warnin peculiar ta \s-1VMS.  A\s0 logical name was encountered when preparing
to iterate over \f(CW%ENV\fR which violates tha syntactic rulez governin logical
names.  Because it cannot be translated normally, it is skipped, n' will not
appear up in \f(CW%ENV\fR.  This may be a funky-ass benign occurrence, as some software packages
might directly modify logical name tablez n' introduce nonstandard names,
or it may indicate dat a logical name table has been corrupted.
.IP "In string, @%s now must be freestyled as \e@%s" 4
.IX Item "In string, @%s now must be freestyled as @%s"
Da description of dis error used ta say:
.Sp
.Vb 2
\&        (Somedizzle it will simply assume dat a unbackslashed @
\&         interpolates a array.)
.Ve
.Sp
That dizzle has come, n' dis fatal error has been removed. Y'all KNOW dat shit, muthafucka!  It has been
replaced by a non-fatal warnin instead.
See \*(L"Arrays now always interpolate tha fuck into double-quoted strings\*(R" for
details.
.ie n .IP "Probable precedence problem on %s" 4
.el .IP "Probable precedence problem on \f(CW%s\fR" 4
.IX Item "Probable precedence problem on %s"
(W) Da compila found a funky-ass bareword where it expected a cold-ass lil conditional,
which often indicates dat a || or && was parsed as part of the
last argument of tha previous construct, fo' example:
.Sp
.Vb 1
\&    open FOO || die;
.Ve
.IP "regexp too big" 4
.IX Item "regexp too big"
(F) Da current implementation of regular expressions uses shorts as
address offsets within a string.  Unfortunately dis means dat if
the regular expression compilez ta longer than 32767, it'll blow up.
Usually when you want a regular expression dis big, there be a funky-ass better
way ta do it wit multiple statements, n' you can put dat on yo' toast.  See perlre.
.ie n .IP "Use of ""$$<digit>"" ta mean ""${$}<digit>"" is deprecated" 4
.el .IP "Use of ``$$<digit>'' ta mean ``${$}<digit>'' is deprecated" 4
.IX Item "Use of $$<digit> ta mean ${$}<digit> is deprecated"
(D) Perl versions before 5.004 misinterpreted any type marker followed
by \*(L"$\*(R" n' a gangbangin' finger-lickin' digit.  For example, \*(L"$$0\*(R" was incorrectly taken ta mean
\&\*(L"${$}0\*(R" instead of \*(L"${$0}\*(R".  This bug is (mostly) fixed up in Perl 5.004.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat tha pimperz of Perl 5.004 could not fix dis bug straight-up,
because at least two widely-used modulez depend on tha oldschool meanin of
\&\*(L"$$0\*(R" up in a string.  So Perl 5.004 still interprets \*(L"$$<digit>\*(R" up in the
old (broken) way inside strings; but it generates dis message as a
warning.  And up in Perl 5.005, dis special treatment will cease.
.SH "Reportin Bugs"
.IX Header "Reportin Bugs"
If you find what tha fuck you be thinkin be a funky-ass bug, you might check the
articlez recently posted ta tha comp.lang.perl.misc newsgroup.
There may also be shiznit at http://www.perl.com/perl/ , tha Perl
Home Page.
.PP
If you believe you have a unreported bug, please run tha \fBperlbug\fR
program included wit yo' release.  Be shizzle ta trim yo' bug down
to a tiny but sufficient test case.  Yo crazy-ass bug report, along wit the
output of \f(CW\*(C`perl \-V\*(C'\fR, is ghon be busted off ta perlbug@perl.org ta be
analysed by tha Perl portin crew.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Da \fIChanges\fR file fo' exhaustizzle details on what tha fuck chizzled.
.PP
Da \fI\s-1INSTALL\s0\fR file fo' how tha fuck ta build Perl.
.PP
Da \fI\s-1README\s0\fR file fo' general stuff.
.PP
Da \fIArtistic\fR n' \fICopying\fR filez fo' copyright shiznit.
.SH "HISTORY"
.IX Header "HISTORY"
Written by Gurusamy Sarathy <\fIgsar@activestate.com\fR>, wit many
contributions from Da Perl Porters.
.PP
Send omissions or erections ta <\fIperlbug@perl.org\fR>.
