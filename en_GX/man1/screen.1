.\" vi:set wm=5
.TH SCREEN 1 "Aug 2003"
.if n .ds Q \&"
.if n .ds U \&"
.if t .ds Q ``
.if t .ds U ''
.UC 4
.SH NAME
screen \- screen manager wit VT100/ANSI terminal emulation


.SH SYNOPSIS
.B screen
[
.B \-\fIoptions\fP
] [
.B \fIcmd\fP
[
.B \fIargs\fP
] ]
.br
.B screen \-r
[[\fIpid\fP\fB.\fP]\fItty\fP[\fB.\fP\fIhost\fP]]
.br
.B screen \-r
\fIsessionballer\fP\fB/\fP[[\fIpid\fP\fB.\fP]\fItty\fP[\fB.\fP\fIhost\fP]]
.ta .5i 1.8i


.SH DESCRIPTION
.I Screen
is a gangbangin' full-screen window manager that
multiplexes a physical terminal between nuff muthafuckin processes (typically
interactizzle shells).
Each virtual terminal serves up tha functions
of a DEC VT100 terminal and, up in addition, nuff muthafuckin control functions
from tha ISO 6429 (ECMA 48, ANSI X3.64) n' ISO 2022 standards
(e.\|g. insert/delete line n' support fo' multiple characta sets).
There be a scrollback history buffer fo' each virtual terminal n' a
copy-and-paste mechanizzle dat allows movin text regions between
windows.
.PP
When
.I screen
is called, it creates a single window wit a gangbangin' finger-lickin' dirty-ass shell up in it (or tha specified
command) n' then gets outta yo' way so dat you can use tha program as you
normally would.
Then, at any time, you can create freshly smoked up (full-screen) windows wit other programs
in dem (includin mo' shells), bust a cap up in existin windows, view a list of
windows, turn output loggin on n' off, copy-and-paste text between
windows, view tha scrollback history, switch between windows
in whatever manner you wish, etc fo' realz. All windows run they programs straight-up
independent of each other n' shit. Programs continue ta run when they window
is currently not visible n' even when tha whole 
.I screen 
session is detached from tha userz terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  When a program terminates,
.I screen
(per default) kills tha window dat contained dat shit.
If dis window was up in tha foreground, tha display switches ta tha previous
window; if none is left,
.I screen
exits.
.PP
Everythang you type is busted ta tha program hustlin up in tha current window.
Da only exception ta dis is tha one keystroke dat is used ta initiate
a command ta tha window manager.
By default, each command begins wit a cold-ass lil control-a (abbreviated C-a from
now on), n' is followed by one other keystroke.
Da command characta n' all tha key bindings can be straight-up customized
to be anythang you like, though they is always two charactas up in length.
.PP
.I Screen
does not KNOW tha prefix \*QC-\*U ta mean control. 
Please use tha caret notation (\*Q^A\*U instead of \*QC-a\*U) as arguments
to e.g. tha 
.I escape
command or tha \fI-e\fP option.
.I Screen
will also print up control charactas up in caret notation.
.PP
Da standard way ta create a freshly smoked up window is ta type \*QC-a c\*U.
This creates a freshly smoked up window hustlin a gangbangin' finger-lickin' dirty-ass shell n' switches ta that
window immediately, regardless of tha state of tha process hustlin
in tha current window.
Similarly, you can create a freshly smoked up window wit a cold-ass lil custom command up in it by
first bindin tha command ta a keystroke (in yo' .screenrc file or at the
\*QC-a :\*U command line) and
then rockin it just like tha \*QC-a c\*U command.
In addition, freshly smoked up windows can be pimped by hustlin a cold-ass lil command like:
.IP
screen emacs prog.c
.PP
from a gangbangin' finger-lickin' dirty-ass shell prompt within a previously pimped window.
This aint gonna run another copy of
.IR screen ,
but will instead supply tha command name n' its arguments ta tha window
manager (specified up in tha $STY environment variable) whoz ass will use it to
create tha freshly smoked up window.
Da above example would start tha emacs editor (editin prog.c) n' switch
to its window. - Note dat you cannot transhiznit environment variablez from
the invokin shell ta tha application (emacs up in dis case), cuz it is
forked from tha parent screen process, not from tha invokin shell.
.PP
If \*Q/etc/utmp\*U is writable by
.IR screen ,
an appropriate record is ghon be freestyled ta dis file fo' each window, and
removed when tha window is terminated.
This is useful fo' hustlin wit \*Qtalk\*U, \*Qscript\*U, \*Qshutdown\*U,
\*Qrsend\*U, \*Qsccs\*U n' other similar programs dat use tha utmp
file ta determine whoz ass yo ass is fo' realz. As long as
.I screen
is actizzle on yo' terminal,
the terminalz own record is removed from tha utmp file. Right back up in yo muthafuckin ass. See also \*QC-a L\*U.


.SH GETTING STARTED
Before you begin ta use
.I screen
yo dirty ass is gonna need ta make shizzle you have erectly selected yo' terminal type,
just as you would fo' any other termcap/terminfo program.
(Yo ass can do dis by using
.IR tset
for example.)
.PP
If you impatient n' wanna git started without bustin a shitload mo' reading,
you should remember dis one command:  \*QC-a ?\*U.
Typin these two charactas will display a list of tha available
.I screen
commandz n' they bindings. Each keystroke is discussed in
the section \*QDEFAULT KEY BINDINGS\*U. Da manual section \*QCUSTOMIZATION\*U
deals wit tha contentz of yo' .screenrc.
.PP
If yo' terminal be a \*Qtrue\*U auto-margin terminal (it don't allow
the last posizzle on tha screen ta be updated without scrollin the
screen) consider rockin a version of yo' terminalz termcap dat has
automatic margins turned \fIoff\fP. This will ensure a accurate and
optimal update of tha screen up in all circumstances. Most terminals
nowadays have \*Qmagic\*U margins (automatic margins plus usable last
column). This is tha VT100 steez type n' perfectly suited for
.IR screen .
If all you've gots be a \*Qtrue\*U auto-margin terminal 
.I screen
will be content ta use it yo, but uppimpin a cold-ass lil characta put tha fuck into tha last
posizzle on tha screen may not be possible until tha screen scrolls or
the characta is moved tha fuck into a safe posizzle up in some other way. This
delay can be shortened by rockin a terminal wit insert-character
capability.


.SH "COMMAND-LINE OPTIONS"
Screen has tha followin command-line options:
.TP 5
.B \-a
include \fIall\fP capabilitizzles (with some minor exceptions) up in each
windowz termcap, even if
.I screen
must redraw partz of tha display up in order ta implement a gangbangin' function.
.TP 5
.B \-A
Adapt tha sizez of all windows ta tha size of tha current terminal.
By default,
.I screen
tries ta restore its oldschool window sizes when attachin ta resizable terminals
(those wit \*QWS\*U up in its description, e.g. suncmd or some xterm).
.TP 5
.BI "\-c " file
override tha default configuration file from \*Q$HOME/.screenrc\*U
to \fIfile\fP.
.TP 5
.BR \-d | \-D " [" \fIpid.tty.host ]
does not start
.IR screen ,
but detaches tha elsewhere hustlin
.I screen
session. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it has tha same ol' dirty effect as typin \*QC-a d\*U from
.IR screen 's
controllin terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. \fB\-D\fP is tha equivalent ta tha juice detach key.
If no session can be detached, dis option is ignored. Y'all KNOW dat shit, muthafucka! In combination wit the
\fB\-r\fP/\fB\-R\fP option mo' bangin effects can be  bigged up :
.TP 8
.B \-d \-r
Reattach a session n' if necessary detach it first.
.TP 8
.B \-d \-R
Reattach a session n' if necessary detach or even create it first.
.TP 8
.B \-d \-RR
Reattach a session n' if necessary detach or create dat shit. Use tha first
session if mo' than one session be available.
.TP 8
.B \-D \-r
Reattach a session. I aint talkin' bout chicken n' gravy biatch. If necessary detach n' logout remotely first.
.TP 8
.B \-D \-R
Attach here n' now, nahmeean? In detail dis means: If a session is hustlin, then
reattach. If necessary detach n' logout remotely first.
If dat shiznit was not hustlin create it n' notify tha user n' shit. This is the
authorz favorite.
.TP 8
.B \-D \-RR
Attach here n' now, nahmeean? Whatever dat means, just do dat shit.
.IP "" 5
Note: It be always a phat scam ta check tha statuz of yo' sessions by means of
\*Qscreen \-list\*U.
.TP 5
.BI "\-e " xy
specifies tha command characta ta be \fIx\fP n' tha characta generatin a
literal command characta ta \fIy\fP (when typed afta tha command character).
Da default is \*QC-a\*U n' `a', which can be specified as \*Q-e^Aa\*U.
When bustin a
.I screen
session, dis option sets tha default command character n' shit. In a multiuser
session all playas added will start off wit dis command character n' shit. But
when attachin ta a already hustlin session, dis option chizzlez only
the command characta of tha attachin user.
This option is equivalent ta either tha commandz \*Qdefescape\*U or
\*Qescape\*U respectively.
.TP 5
.BR \-f\fP ", " \-fn ", n' " \-fa
turns flow-control on, off, or \*Qautomatic switchin mode\*U.
This can also be defined all up in tha \*Qdefflow\*U .screenrc command.
.TP 5
.BI "\-h " num
Specifies tha history scrollback buffer ta be \fInum\fP lines high.
.TP 5
.B \-i
will cause tha interrupt key (usually C-c) ta interrupt tha display
immediately when flow-control is on.
See tha \*Qdefflow\*U .screenrc command fo' details.
Da use of dis option is discouraged.
.TP 5
.BR \-l " n' " \-ln
turns login mode on or off (for /etc/utmp updating).
This can also be defined all up in tha \*Qdeflogin\*U .screenrc command.
.TP 5
.BR \-ls " [" \fImatch ]
.PD 0
.TP 5
.BR \-list " [" \fImatch ] 
.PD
does not start
.IR screen ,
but prints a list of
.I pid.tty.host
strings identifyin your
.I screen
sessions.
Sessions marked `detached' can be resumed wit \*Qscreen -r\*U. Those marked
`attached' is hustlin n' gotz a cold-ass lil controllin terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If tha session runs up in 
multiuser mode, it is marked `multi'. Right back up in yo muthafuckin ass. Sessions marked as `unreachable' either
live on a gangbangin' finger-lickin' different host or is `dead'.
An unreachable session is considered dead, when its name
matches either tha name of tha local host, or tha specified parameter, if any.
See tha \fB-r\fP flag fo' a thugged-out description how tha fuck ta construct matches.
Sessions marked as `dead' should be thoroughly checked n' removed. Y'all KNOW dat shit, muthafucka! 
Ask yo' system administrator if yo ass is not sure. Remove sessions wit tha 
\fB-wipe\fP option. I aint talkin' bout chicken n' gravy biatch. 
.TP 5
.B \-L
tells
.I screen
to turn on automatic output loggin fo' tha windows.
.TP 5
.B \-m
causes
.I screen
to ignore tha $STY environment variable. With \*Qscreen -m\*U creation of
a freshly smoked up session is enforced, regardless whether
.I screen
is called from within another
.I screen
session or not. This flag has a special meanin up in connection
with tha `-d' option:
.TP 8
.B \-d \-m
Start
.I screen
in \*Qdetached\*U mode. This creates a freshly smoked up session but don't
attach ta dat shit. This is useful fo' system startup scripts.
.TP 8
.B \-D \-m
This also starts screen up in \*Qdetached\*U mode yo, but don't fork
a freshly smoked up process. Da command exits if tha session terminates.
.TP 5
.B \-O
selects a mo' optimal output mode fo' yo' terminal rather than legit VT100
emulation (only affects auto-margin terminals without `LP').
This can also be set up in yo' .screenrc by specifyin `OP' up in a \*Qtermcap\*U
command.
.TP 5
.BI "\-p " number_or_name|-|=|+
Preselect a window. This is useful when you wanna reattach ta a
specific window or you wanna bust a cold-ass lil command via tha \*Q-X\*U
option ta a specific window fo' realz. As wit screenz select command, \*Q-\*U
selects tha blank window fo' realz. As a special case fo' reattach, \*Q=\*U
brings up tha windowlist on tha blank window, while a \*Q+\*U
will create a freshly smoked up window. Da command aint gonna be
executed if tha specified window could not be found.
.TP 5
.B \-q
Suppress printin of error lyrics. In combination wit \*Q-ls\*U tha exit 
value be as bigs up: 9 indicates a gangbangin' finger-lickin' directory without sessions. 10 
indicates a gangbangin' finger-lickin' directory wit hustlin but not attachable sessions. 11 (or more) 
indicates 1 (or more) usable sessions.
In combination wit \*Q-r\*U tha exit value be as bigs up: 10 indicates dat 
there is no session ta resume. 12 (or more) indicates dat there be 2 (or 
more) sessions ta resume n' you should specify which one ta chizzle. 
In all other cases \*Q-q\*U has no effect.
.TP 5
.B \-Q
Some commandz now can be queried from a remote session rockin this
flag, e.g. 'screen -Q windows'. Da commandz will bust the
response ta tha stdout of tha queryin process. If there was an
error up in tha command, then tha queryin process will exit with
a non-zero status.

Da commandz dat can be queried now are:
 \fBecho\fP
 \fBinfo\fP
 \fBlastmsg\fP
 \fBnumber\fP
 \fBselect\fP
 \fBtime\fP
 \fBtitle\fP
 \fBwindows\fP
.TP 5
.BR \-r " [" \fIpid.tty.host ]
.PD 0
.TP 5
.BR \-r " \fIsessionballer/[" \fIpid.tty.host ]
.PD
resumes a thugged-out detached
.I screen
session. I aint talkin' bout chicken n' gravy biatch.  No other options (except combinations wit \fB\-d\fP/\fB\-D\fP) may
be specified, though a optionizzle prefix of [\fIpid.\fP]\fItty.host\fP
may be needed ta distinguish between multiple detached
.I screen
sessions.  Da second form is used ta connect ta another userz screen session
which runs up in multiuser mode. This indicates dat screen should look for
sessions up in another userz directory. This requires setuid-root.
.TP 5
.B \-R
attempts ta resume tha straight-up original gangsta detached
.I screen
session it finds.  If successful, all other command-line options is ignored.
If no detached session exists, starts a freshly smoked up session rockin tha specified
options, just as if
.B \-R
had not been specified. Y'all KNOW dat shit, muthafucka! Da option is set by default if
.I screen
is run as a login-shell (actually screen uses \*Q-xRR\*U up in dat case).
For combinations wit tha \fB\-d\fP/\fB\-D\fP option peep there.
.TP 5
.BI "\-s " program 
sets tha default shell ta tha program specified, instead of tha value
in tha environment variable $SHELL (or \*Q/bin/sh\*U if not defined).
This can also be defined all up in tha \*Qshell\*U .screenrc command.
.TP 5
.BI "\-S " sessionname
When bustin a freshly smoked up session, dis option can be used ta specify a
meaningful name fo' tha session. I aint talkin' bout chicken n' gravy biatch. This name identifies tha session for
\*Qscreen -list\*U n' \*Qscreen -r\*U actions. Well shiiiit, it substitutes the
default [\fItty.host\fP] suffix.
.TP 5
.BI "\-t " name
sets tha title (a.\|k.\|a.) fo' tha default shell or specified program.
See also tha \*Qshelltitle\*U .screenrc command.
.TP 5
.BI "\-T " term
Set tha $TERM enviroment varible rockin tha spcified term as
opposed ta tha defualt settin of \fBscreen\fP.
.TP 5
.B \-U
Run screen up in UTF-8 mode. This option  drops some lyrics ta screen dat yo' terminal
sendz n' understandz UTF-8 encoded characters. Well shiiiit, it also sets tha default
encodin fo' freshly smoked up windows ta `utf8'.
.TP 5
.B \-v
Print version number.
.TP 5
.BR \-wipe " [" \fImatch ]
does tha same ol' dirty as \*Qscreen -ls\*U yo, but removes destroyed sessions instead of
markin dem as `dead'.
An unreachable session is considered dead, when its name matches either 
the name of tha local host, or tha explicitly given parameter, if any.
See tha \fB-r\fP flag fo' a thugged-out description how tha fuck ta construct matches.
.TP 5
.B \-x
Attach ta a not detached
.I screen
session. I aint talkin' bout chicken n' gravy biatch. (Multi display mode).
.I Screen
refuses ta attach from within itself. 
But when cascadin multiple screens, loops is not detected; take care.
.TP 5
.B \-X
Send tha specified command ta a hustlin screen session. I aint talkin' bout chicken n' gravy biatch. Yo ass can use
the \fB-d\fP or \fB-r\fP option ta tell screen ta look only for
attached or detached screen sessions. Note dat dis command don't
work if tha session is password protected.
.TP 5
.B \-4
Resolve hostnames only ta IPv4 addresses.
.TP 5
.B \-6
Resolve hostnames only ta IPv6 addresses.

.SH "DEFAULT KEY BINDINGS"
.ta 12n 26n
As mentioned, each
.I screen
command consistz of a
\*QC-a\*U followed by one other character.
For yo' convenience, all commandz dat is bound ta lower-case lettas are
also bound ta they control characta counterparts (with tha exception
of \*QC-a a\*U; peep below), thus, \*QC-a c\*U as well as \*QC-a C-c\*U can
be used ta create a window. Right back up in yo muthafuckin ass. See section \*QCUSTOMIZATION\*U fo' a thugged-out description
of tha command.
.PP
.TP 26n
Da followin table shows tha default key bindings:
.IP "\fBC-a '\fP	(select)"
Prompt fo' a window name or number ta switch to.
.IP "\fBC-a ""\fP	(windowlist -b)"
Present a list of all windows fo' selection.
.IP "\fBC-a 0\fP	(select 0)"
.PD 0
.IP "\fB ... \fP	   ..."
.IP "\fBC-a 9\fP	(select 9)"
.IP "\fBC-a -\fP	(select -)"
.PD
Switch ta window number 0 \- 9, or ta tha blank window.
.IP "\fBC-a tab\fP	(focus)"
.PD
Switch tha input focus ta tha next region.
See also \fIsplit, remove, only\fP.
.IP "\fBC-a C-a\fP	(other)"
Toggle ta tha window displayed previously.
Note dat dis bindin defaults ta tha command characta typed twice,
unless overridden. I aint talkin' bout chicken n' gravy biatch.  For instance, if you use tha option \*Q\fB\-e]x\fP\*U,
this command becomes \*Q]]\*U.
.IP "\fBC-a a\fP	(meta)"
Send tha command characta (C-a) ta window. Right back up in yo muthafuckin ass. See \fIescape\fP command.
.IP "\fBC-a A\fP	(title)"
Allow tha user ta enta a name fo' tha current window.
.IP "\fBC-a b\fP"
.PD 0
.IP "\fBC-a C-b\fP	(break)"
.PD
Send a funky-ass break ta window.
.IP "\fBC-a B\fP	(pow_break)"
Reopen tha terminal line n' bust a funky-ass break.
.IP "\fBC-a c\fP"
.PD 0
.IP "\fBC-a C-c\fP	(screen)"
.PD
Smoke a freshly smoked up window wit a gangbangin' finger-lickin' dirty-ass shell n' switch ta dat window.
.IP "\fBC-a C\fP	(clear)"
Clear tha screen.
.IP "\fBC-a d\fP"
.PD 0
.IP "\fBC-a C-d\fP	(detach)"
.PD
Detach
.I screen
from dis terminal.
.IP "\fBC-a D D\fP	(pow_detach)"
Detach n' logout.
.IP "\fBC-a f\fP"
.PD 0
.IP "\fBC-a C-f\fP	(flow)"
.PD
Toggle flow \fIon\fP, \fIoff\fP or \fIauto\fP.
.IP "\fBC-a F\fP	(fit)"
Resize tha window ta tha current region size.
.IP "\fBC-a C-g\fP	(vbell)"
Toggles
.I screen's
visual bell mode.
.IP "\fBC-a h\fP	(hardcopy)"
.PD
Write a hardcopy of tha current window ta tha file \*Qhardcopy.\fIn\fP\*U.
.IP "\fBC-a H\fP	(log)"
Begins/endz loggin of tha current window ta tha file \*Qscreenlog.\fIn\fP\*U.
.IP "\fBC-a i\fP"
.PD 0
.IP "\fBC-a C-i\fP	(info)"
.PD
Show info bout dis window.
.IP "\fBC-a k\fP"
.PD 0
.IP "\fBC-a C-k\fP	(kill)"
.PD
Destroy current window.
.IP "\fBC-a l\fP"
.PD 0
.IP "\fBC-a C-l\fP	(redisplay)"
.PD
Fully refresh current window.
.IP "\fBC-a L\fP	(login)"
Toggle dis windows login slot fo' realz. Available only if
.I screen
is configured ta update tha utmp database.
.IP "\fBC-a m\fP"
.PD 0
.IP "\fBC-a C-m\fP	(lastmsg)"
.PD
Repeat tha last message displayed up in tha message line.
.IP "\fBC-a M\fP	(monitor)"
Togglez monitorin of tha current window.
.IP "\fBC-a space\fP"
.PD 0
.IP "\fBC-a n\fP"
.IP "\fBC-a C-n\fP	(next)"
.PD
Switch ta tha next window.
.IP "\fBC-a N\fP	(number)"
Show tha number (and title) of tha current window.
.IP "\fBC-a backspace\fP"
.PD 0
.IP "\fBC-a h\fP"
.IP "\fBC-a p\fP"
.IP "\fBC-a C-p\fP	(prev)"
.PD
Switch ta tha previous window (opposite of \fBC-a n\fP).
.IP "\fBC-a q\fP"
.PD 0
.IP "\fBC-a C-q\fP	(xon)"
.PD
Send a cold-ass lil control-q ta tha current window.
.IP "\fBC-a Q\fP	(only)"
Delete all regions but tha current one.
See also \fIsplit, remove, focus\fP.
.IP "\fBC-a r\fP"
.PD 0
.IP "\fBC-a C-r\fP	(wrap)"
.PD
Toggle tha current windowz line-wrap settin (turn tha current window's
automatic margins on n' off).
.IP "\fBC-a s\fP"
.PD 0
.IP "\fBC-a C-s\fP	(xoff)"
.PD
Send a cold-ass lil control-s ta tha current window.
.IP "\fBC-a S\fP	(split)"
Split tha current region horizontally tha fuck into two freshly smoked up ones.
See also \fIonly, remove, focus\fP.
.IP "\fBC-a t\fP"
.PD 0
.IP "\fBC-a C-t\fP	(time)"
.PD
Show system shiznit.
.IP "\fBC-a v\fP	(version)"
.PD
Display tha version n' compilation date.
.IP "\fBC-a C-v\fP	(digraph)"
.PD
Enta digraph.
.IP "\fBC-a w\fP"
.PD 0
.IP "\fBC-a C-w\fP	(windows)"
.PD
Show a list of window.
.IP "\fBC-a W\fP	(width)"
Toggle 80/132 columns.
.IP "\fBC-a x\fP"
.PD 0
.IP "\fBC-a C-x\fP	(lockscreen)"
.PD
Lock dis terminal.
.IP "\fBC-a X\fP 	(remove)"
Bust a cap up in tha current region.
See also \fIsplit, only, focus\fP.
.IP "\fBC-a z\fP"
.PD 0
.IP "\fBC-a C-z\fP	(suspend)"
.PD
Suspend
.IR screen .
Yo crazy-ass system must support BSD-style thang-control.
.IP "\fBC-a Z\fP	(reset)"
Reset tha virtual terminal ta its \*Qpower-on\*U joints.
.IP "\fBC-a .\fP	(dumptermcap)"
Write up a \*Q.termcap\*U file.
.IP "\fBC-a ?\fP	(help)"
Show key bindings.
.IP "\fBC-a C-\e\fP	(quit)"
Bust a cap up in all windows n' terminate
.IR screen .
.IP "\fBC-a :\fP	(colon)"
Enta command line mode.
.IP "\fBC-a [\fP"
.PD 0
.IP "\fBC-a C-[\fP"
.IP "\fBC-a esc\fP	(copy)"
.PD
Enta copy/scrollback mode.
.IP "\fBC-a C-]\fP"
.PD 0
.IP "\fBC-a ]\fP	(paste .)"
.PD
Write tha contentz of tha paste buffer ta tha stdin queue of the
current window. 
.IP "\fBC-a {\fP
.PD 0
.IP "\fBC-a }\fP	(history)"
.PD
Copy n' paste a previous (command) line.
.IP "\fBC-a >\fP	(writebuf)"
Write paste buffer ta a gangbangin' file.
.IP "\fBC-a <\fP	(readbuf)"
Readz tha screen-exchange file tha fuck into tha paste buffer.
.IP "\fBC-a =\fP	(removebuf)"
Removes tha file used by \fBC-a <\fP n' \fPC-a >\fP.
.IP "\fBC-a ,\fP	(license)"
Shows where
.I screen
be reppin, where it went ta n' why you can use dat shit.
.IP "\fBC-a _\fP	(silence)"
Start/stop monitorin tha current window fo' inactivity.
.IP "\fBC-a |\fP	(split -v)"
Split tha current region vertically tha fuck into two freshly smoked up ones.
.IP "\fBC-a *\fP	(displays)"
Show a listin of all currently attached displays.


.SH CUSTOMIZATION
Da \*Qsocket directory\*U defaults either ta $HOME/.screen or simply to
/tmp/screens or preferably ta /usr/local/screens chosen at compile-time. If
.I screen
is installed setuid-root, then tha administrator
should compile
.I screen
with a adequate (not NFS mounted) socket directory. If
.I screen
is not hustlin setuid-root, tha user can specify any mode 700 directory
in tha environment variable $SCREENDIR.
.PP
When
.I screen
is invoked, it executes initialization commandz from tha files
\*Q/etc/screenrc\*U and
\*Q.screenrc\*U up in tha userz home directory. These is tha \*Qprogrammer's
defaults\*U dat can be overridden up in tha followin ways: fo' the
global screenrc file 
.I screen
searches fo' tha environment variable $SYSSCREENRC (this override feature
may be disabled at compile-time). Da user specific
screenrc file is searched up in $SCREENRC, then $HOME/.screenrc.
Da command line option \fB-c\fP takes
precedence over tha above user screenrc files.
.PP
Commandz up in these filez is used ta set options, bind functions to
keys, n' ta automatically establish one or mo' windows at the
beginnin of your
.I screen
session.
Commandz is listed one per line, wit empty lines bein ignored.
A commandz arguments is separated by tabs or spaces, n' may be
surrounded by single or double quotes.
A `#' turns tha rest of tha line tha fuck into a cold-ass lil comment, except up in quotes.
Unintelligible lines is warned bout n' ignored.
Commandz may contain references ta environment variables. Da 
syntax is tha shell-like "$VAR " or "${VAR}". Note dat dis causes 
incompatibilitizzle wit previous 
.I screen
versions, as now tha '$'-characta has ta be protected wit '\e' if no
variable substitution shall be performed. Y'all KNOW dat shit, muthafucka! A strang up in single-quotes be also
protected from variable substitution.
.PP
Two configuration filez is shipped as examplez wit yo' screen distribution:
\*Qetc/screenrc\*U n' \*Qetc/etcscreenrc\*U. They contain a number of
useful examplez fo' various commands.
.PP
Customization can also be done 'on-line'. To enta tha command mode type
`C-a :'. Note dat commandz startin wit \*Qdef\*U chizzle default joints,
while others chizzle current settings.
.PP
Da followin commandz is available:
.sp 
.ne 3
.BI acladd " usernames"
.RI [ crypted-pw ]
.br
.BI addacl " usernames"
.PP
Enable playas ta straight-up access dis screen session. I aint talkin' bout chicken n' gravy biatch. \fIUsernames\fP can be one
user or a cold-ass lil comma separated list of users. This command enablez ta attach ta the
.I screen
session n' performs tha equivalent of `aclchg \fIusernames\fP +rwx \&"#?\&"'.
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. To add a user wit restricted access, use tha `aclchg' command below.
If a optionizzle second parameta is supplied, it should be a cold-ass lil crypted password
for tha named user(s). `Addacl' be a synonym ta `acladd'.
Multi user mode only.
.sp 
.ne 3
.BI aclchg " usernames permbits list"
.br
.BI chacl " usernames permbits list"
.PP
Change permissions fo' a cold-ass lil comma separated list of users. Permission bits are
represented as `r', `w' n' `x'. Prefixin `+' grants tha permission, `-' 
removes dat shit. Da third parameta be a cold-ass lil comma separated list of commandz and/or
windows (specified either by number or title). Da special list `#' refers ta 
all windows, `?' ta all commands. if \fIusernames\fP consistz of a single `*',
all known playas is affected.
A command can be executed when tha user has tha `x' bit fo' dat shit.
Da user can type input ta a window when dat schmoooove muthafucka has its `w' bit set n' no other
user obtains a writelock fo' dis window. 
Other bits is currently ignored. Y'all KNOW dat shit, muthafucka!  
To withdraw tha writelock from another user up in window 2:
`aclchg \fIusername\fP -w+w 2'.
To allow read-only access ta tha session: `aclchg \fIusername\fP
-w \&"#\&"' fo' realz. As soon as a userz name is known ta 
.I screen 
he can attach ta tha session n' (per default) has full permissions fo' all 
command n' windows. Execution permission fo' tha acl commands, `at' n' others
should also be removed or tha user may be able ta regain write permission.
Rightz of tha special username
.B no muthafucka
cannot be chizzled (see tha \*Qsu\*U command).
`Chacl' be a synonym ta `aclchg'.
Multi user mode only.
.sp
.ne 3
.BI acldel " username"
.PP
Remove a user from
.IR screen 's
access control list. If currently attached, all the
userz displays is detached from tha session. I aint talkin' bout chicken n' gravy biatch yo. Dude cannot attach again.
Multi user mode only.
.sp
.ne 3
.BI aclgrp " username"
.RI [ groupname ]
.PP
Creates crewz of playas dat share common access rights, n' you can put dat on yo' toast. Da name of tha 
group is tha username of tha crew leader n' shit. Each gangmember of tha crew inherits
the permissions dat is granted ta tha crew leader n' shit. That means, if a user
fails a access check, another check is made fo' tha crew leader.
A user is removed from all crews tha special value \*Qnone\*U is used for
.IR groupname .
If tha second parameta is omitted all crews tha user is up in is listed.
.sp
.ne 3
.B aclumask
.RI [[ playas ] +bits 
.RI |[ playas ] -bits " .... ]"
.br
.B umask
.RI [[ playas ] +bits 
.RI |[ playas ] -bits " .... ]"
.PP
This specifies tha access other playas gotta windows dat is ghon be pimped by
the calla of tha command.
.I Users
may be no, one or a cold-ass lil comma separated list of known usernames. If no playas are
specified, a list of all currently known playas be assumed. Y'all KNOW dat shit, muthafucka! 
.I Bits
is any combination of access control bits allowed defined wit tha 
\*Qaclchg\*U command. Y'all KNOW dat shit, muthafucka! Da special username \*Q?\*U predefines tha access
that not yet known playas is ghon be granted ta any window initially.
Da special username \*Q??\*U predefines tha access dat not yet known 
users is granted ta any command. Y'all KNOW dat shit, muthafucka! 
Rightz of tha special username
.B no muthafucka
cannot be chizzled (see tha \*Qsu\*U command).
`Umask' be a synonym ta `aclumask'.
.sp
.ne 3
.BI activitizzle " message"
.PP
When any activitizzle occurs up in a funky-ass background window dat is bein monitored,
.I screen
displays a notification up in tha message line.
Da notification message can be re-defined by meanz of tha \*Qactivity\*U
command.
Each occurrence of `%' up in \fImessage\fP is replaced by
the number of tha window up in which activitizzle has occurred,
and each occurrence of `^G' is replaced by tha definizzle fo' bell
in yo' termcap (usually a audible bell).
Da default message is
.sp
	'Activitizzle up in window %n'
.sp
Note dat monitorin is off fo' all windows by default yo, but can be altered
by use of tha \*Qmonitor\*U command (C-a M).
.sp
.ne 3
.BR "allpartial on" | off
.PP
If set ta on, only tha current cursor line is refreshed on window chizzle.
This affects all windows n' is useful fo' slow terminal lines. Da 
previous settin of full/partial refresh fo' each window is restored
with \*Qallpartial off\*U.  This be a global flag dat immediately takes effect
on all windows overridin tha \*Qpartial\*U settings. Well shiiiit, it do not chizzle the
default redraw behavior of newly pimped windows.
.sp
.ne 3
.BR "altscreen on" | off
.PP
If set ta on, "alternate screen" support is enabled up in virtual terminals,
just like up in xterm.  Initial settin is `off'.
.sp
.ne 3
.BR "at " "[\fIidentifier\fP][" "#\fP|\fP*\fP|\fP%\fP] "
.IR "command " [ args " ... ]"
.PP
Execute a cold-ass lil command at other displays or windows as if it had been entered there.
\*QAt\*U chizzlez tha context (the `current window' or `current display'
setting) of tha command. Y'all KNOW dat shit, muthafucka! If tha straight-up original gangsta parameta raps on some 
non-unique context, tha command is ghon be executed multiple times. If tha straight-up original gangsta 
parameta iz of tha form `\fIidentifier\fP*' then identifier is matched against
user names.  Da command is executed once fo' each display of tha selected 
user(s). If tha straight-up original gangsta parameta iz of tha form `\fIidentifier\fP%' identifier 
is matched against displays. Displays is named afta tha ttys they 
attach. Da prefix `/dev/' or `/dev/tty' may be omitted from tha identifier.
If \fIidentifier\fP has a `#' or not a god damn thang appended it is matched against 
window numbers n' titles. Omittin a identifier up in front of tha `#', `*' or 
`%'-characta selects all users, displays or windows cuz a prefix-match is
performed. Y'all KNOW dat shit, muthafucka! Note dat on tha affected display(s) a gangbangin' finger-lickin' dirty-ass short message will describe
what happened. Y'all KNOW dat shit, muthafucka! Permission is checked fo' initiator of tha \*Qat\*U command,
not fo' tha ballaz of tha affected display(s).
Note dat tha '#' characta works as a cold-ass lil comment introducer when it is preceded by
whitespace. This can be escaped by prefixin a '\e'. 
Permission is checked fo' tha initiator of tha \*Qat\*U command, not fo' the
ballaz of tha affected display(s).
.br
Caveat: 
When matchin against windows, tha command is executed at least 
once per window. Commandz dat chizzle tha internal arrangement of windows
(like \*Qother\*U) may be called again. I aint talkin' bout chicken n' gravy biatch. In shared windows tha command will
be repeated fo' each attached display. Beware, when issuin toggle commands
like \*Qlogin\*U!
Some commandz (e.g. \*Qprocess\*U) require dat 
a display be associated wit tha target windows.  These commandz may not work
correctly under \*Qat\*U loopin over windows.
.sp
.ne 3
.BI "attrcolor " attrib
.RI [ "attribute/color-modifier" ]
.PP
This command can be used ta highlight attributes by changin tha color of
the text. If tha attribute
.I attrib
is up in use, tha specified attribute/color modifier be also applied. Y'all KNOW dat shit, muthafucka! If no
modifier is given, tha current one is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. See tha \*QSTRING ESCAPES\*U
chapta fo' tha syntax of tha modifier n' shit. Right back up in yo muthafuckin ass. Screen understandz two
pseudo-attributes, \*Qi\*U standz fo' high-intensitizzle foreground
color n' \*QI\*U fo' high-intensitizzle background color.
.sp
Examples:
.IP
attrcolor b "R"
.PP
Change tha color ta bright red if bold text is ta be printed.
.IP
attrcolor u "-u b"
.PP
Use blue text instead of underline.
.IP
attrcolor b ".I"
.PP
Use bright flavas fo' bold text. Most terminal emulators do this
already.
.IP
attrcolor i "+b"
.PP
Make bright colored text also bold.
.sp
.ne 3
.BR "autodetach on" | off
.PP
Sets whether 
.I screen
will automatically detach upon hangup, which
saves all yo' hustlin programs until they is resumed wit a
.B "screen -r"
command.
When turned off, a hangup signal will terminizzle 
.I screen
and all tha processes it gotz nuff fo' realz. Autodetach is on by default.
.sp
.ne 3
.BR "autonuke on" | off
.PP
Sets whether a cold-ass lil clear screen sequence should nuke all tha output
that has not been freestyled ta tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. See also
\*Qobuflimit\*U.
.sp
.ne 3
.BI "backtick " id
.I gamespan
.I autorefresh
.I cmd
.I args...
.br
.BI "backtick " id
.PP
Program tha backtick command wit tha numerical id \fIid\fP.
Da output of such a cold-ass lil command is used fo' substitution of the
\*Q%`\*U strang escape. Da specified \fIlifespan\fP is tha number
of secondz tha output is considered valid. Y'all KNOW dat shit, muthafucka! Afta dis time, the
command is run again n' again n' again if a cold-ass lil correspondin strang escape is encountered.
Da \fIautorefresh\fP parameta triggers an
automatic refresh fo' caption n' hardstatus strings afta the
specified number of seconds. Only tha last line of output is used
for substitution.
.br
If both tha \fIlifespan\fP n' tha \fIautorefresh\fP parameters
are zero, tha backtick program is sposed ta fuckin stay up in the
background n' generate output once up in a while.
In dis case, tha command is executed right away n' screen stores
the last line of output. If a freshly smoked up line gets printed screen will
automatically refresh tha hardstatus or tha captions.
.br
Da second form of tha command deletes tha backtick command
with tha numerical id \fIid\fP.
.sp
.ne 3
.BR "bce " [ on | off ]
.PP
Change background-color-erase setting. If \*Qbce\*U is set ta on, all
charactas cleared by a erase/insert/scroll/clear operation
will be displayed up in tha current background color. Shiiit, dis aint no joke. Otherwise
the default background color is used.
.sp
.ne 3
.B bell_msg
.RI [ message ]
.PP
When a funky-ass bell characta is busted ta a funky-ass background window,
.I screen
displays a notification up in tha message line.
Da notification message can be re-defined by dis command.
Each occurrence of `%' up in \fImessage\fP is replaced by
the number of tha window ta which a funky-ass bell has been sent,
and each occurrence of `^G' is replaced by tha definizzle fo' bell
in yo' termcap (usually a audible bell).
Da default message is
.sp
	'Bell up in window %n'
.sp
An empty message can be supplied ta tha \*Qbell_msg\*U command ta suppress
output of a message line (bell_msg "").
Without parameter, tha current message is shown.
.sp
.ne 3
.BI "bind "
.RB [ -c
.IR class ]
.I key 
.RI [ command " [" args ]]
.PP
Bind a cold-ass lil command ta a key.
By default, most of tha commandz provided by
.I screen
are bound ta one or mo' keys as indicated up in tha \*QDEFAULT KEY BINDINGS\*U
section, e.\|g. the
command ta create a freshly smoked up window is bound ta \*QC-c\*U n' \*Qc\*U.
Da \*Qbind\*U command can be used ta redefine tha key bindings n' to
define freshly smoked up bindings.
Da \fIkey\fP argument is either a single character, a two-characta sequence
of tha form \*Q^x\*U (meanin \*QC-x\*U), a funky-ass backslash followed by a octal
number (specifyin tha ASCII code of tha character), or a funky-ass backslash followed
by a second character, like fuckin \*Q\e^\*U or \*Q\e\e\*U.
Da argument can also be quoted, if you like.
If no further argument is given, any previously established binding
for dis key is removed.
Da \fIcommand\fP argument can be any command listed up in dis section.

If a cold-ass lil command class is specified via tha \*Q-c\*U option, tha key
is bound fo' tha specified class. Use tha \*Qcommand\*U command
to activate a cold-ass lil class. Command classes can be used ta create multiple
command keys or multi-characta bindings.
.PP
Some examples:
.PP
.nf
	bind ' ' windows
	bind ^k
	bind k
	bind K kill
	bind ^f screen telnet foobar
	bind \e033 screen -ln -t root -h 1000 9 su
.fi
.PP
would bind tha space key ta tha command dat displays a list
of windows (so dat tha command probably invoked by \*QC-a C-w\*U
would also be available as \*QC-a space\*U). Da next three lines
remove tha default bust a cap up in bindin from \*QC-a C-k\*U n' \*QC-a k\*U. 
\*QC-a K\*U is then bound ta tha bust a cap up in command. Y'all KNOW dat shit, muthafucka! Then it
bindz \*QC-f\*U ta tha command \*Qcreate a window wit a TELNET
connection ta foobar\*U, n' bind \*Qescape\*U ta tha command
that creates a non-login window wit a.\|k.\|a. \*Qroot\*U up in slot #9, with
a superuser shell n' a scrollback buffer of 1000 lines.
.PP
.nf
	bind -c demo1 0 select 10
	bind -c demo1 1 select 11
	bind -c demo1 2 select 12
	bindkey "^B" command -c demo1
.fi
.PP
makes \*QC-b 0\*U select window 10, \*QC-b 1\*U window 11, etc.
.PP
.nf
	bind -c demo2 0 select 10
	bind -c demo2 1 select 11
	bind -c demo2 2 select 12
	bind - command -c demo2
.fi
.PP
makes \*QC-a - 0\*U select window 10, \*QC-a - 1\*U window 11, etc.
.sp
.ne 3
.B bindkey
.RB [ -d ]
.RB [ -m ]
.RB [ -a ]
.RB [[ -k | -t ]
.I string
.RI [ "cmd args" ]]
.PP
This command manages screenz input translation tables. Every
entry up in one of tha tablez  drops some lyrics ta screen how tha fuck ta react if a cold-ass lil certain
sequence of charactas is encountered. Y'all KNOW dat shit, muthafucka! There is three tables:
one dat should contain actions programmed by tha user, one for
the default actions used fo' terminal emulation n' one for
screenz copy mode ta do cursor movement. Right back up in yo muthafuckin ass. See section
\*QINPUT TRANSLATION\*U fo' a list of default key bindings.
.br
If the
.B -d
option is given, bindkey modifies tha default table,
.B -m
changes tha copy mode table
and wit neither option tha user table is selected.
Da argument
.I string
is tha sequence of charactas ta which a action is bound. Y'all KNOW dat shit, muthafucka! This
can either be a gangbangin' fixed strang or a termcap keyboard capability
name (selectable wit the
.B -k
option).
.br
Some keys on a VT100 terminal can bust a gangbangin' finger-lickin' different
strin if application mode is turned on (e.g tha cursor keys).
Such keys have two entries up in tha translation table. Yo ass can
select tha application mode entry by specifyin the
.B -a
option.
.br
The
.B -t
option  drops some lyrics ta screen not ta do inter-characta timing. One cannot
turn off tha timin if a termcap capabilitizzle is used.
.br
.I Cmd
can be any of screenz commandz wit a arbitrary number of
.IR args .
If
.I cmd
is omitted tha key-bindin is removed from tha table.
.br
Here is some examplez of keyboard bindings:
.sp
.nf
        bindkey -d
.fi
Show all of tha default key bindings. Da application mode entries
are marked wit [A].
.sp
.nf
        bindkey -k k1 select 1
.fi
Make tha "F1" key switch ta window one.
.sp
.nf
        bindkey -t foo shiznit barfoo
.fi
Make "foo" a abbreviation of tha word "barfoo". Timeout is disabled
so dat playas can type slowly.
.sp
.nf
        bindkey "\e024" mapdefault
.fi
This key-bindin make \*Q^T\*U a escape characta fo' key-bindings. If
you did tha above \*Qshiznit barfoo\*U binding, you can enta tha word
\*Qfoo\*U by typin \*Q^Tfoo\*U. If you wanna bang a \*Q^T\*U
you gotta press tha key twice (i.e., escape tha escape binding).
.sp
.nf
        bindkey -k F1 command
.fi
Make tha F11 (not F1!) key a alternatizzle screen
escape (besides ^A).
.sp
.ne 3
.B break
.RI [ duration ]
.PP
Send a funky-ass break signal fo' \fIduration\fP*0.25 secondz ta dis window.
For non-Posix systems tha time interval may be rounded up ta full seconds.
Most useful if a cold-ass lil characta thang be attached ta tha window rather than 
a shell process (See also chapta \*QWINDOW TYPES\*U). Da maximum duration of
a break signal is limited ta 15 seconds.
.sp
.ne 3
.B blanker
.PP
Activate tha screen blanker n' shit. First tha screen is cleared. Y'all KNOW dat shit, muthafucka! If no blanker
program is defined, tha cursor is turned off, otherwise, tha 
program is started n' itz output is freestyled ta tha screen.
Da screen blanker is capped wit tha straight-up original gangsta keypress, tha read key
is discarded.
.br
This command is normally used together wit tha \*Qidle\*U command.
.sp
.ne 3
.B blankerprg
.RI [ "program args" ]
.PP
Defines a funky-ass blanker program. Disablez tha blanker program if an
empty argument is given. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Shows tha currently set blanker program if no
arguments is given.
.sp
.ne 3
.B breaktype
.RI [ tcsendbreak | TIOCSBRK
.RI | TCSBRK ]
.PP
Choose one of tha available methodz of generatin a funky-ass break signal for
terminal devices. This command should affect tha current window only.
But it still behaves identical ta \*Qdefbreaktype\*U. This is ghon be chizzled in
the future.
Callin \*Qbreaktype\*U wit no parameta displays tha break method fo' the
current window.
.sp
.ne 3
.B bufferfile
.RI [ exchange-file ]
.PP
Change tha filename used fo' readin n' freestylin wit tha paste buffer.
If tha optionizzle argument ta tha \*Qbufferfile\*U command is omitted, 
the default settin (\*Q/tmp/screen-exchange\*U) is reactivated.
Da followin example will paste tha systemz password file tha fuck into 
the
.I screen
window (usin tha paste buffer, where a cold-ass lil copy remains):
.PP
.nf
	C-a : bufferfile /etc/passwd
	C-a < C-a ]
	C-a : bufferfile
.fi
.sp
.ne 3
.BR "c1 " [ on | off ]
.PP
Change c1 code processing. \*QC1 on\*U  drops some lyrics ta screen ta treat
the input charactas between 128 n' 159 as control functions.
Such a 8-bit code is normally tha same as ESC followed by the
correspondin 7-bit code. Da default settin is ta process c1
codes n' can be chizzled wit tha \*Qdefc1\*U command. Y'all KNOW dat shit, muthafucka! 
Users wit fonts dat have usable charactas up in the
c1 positions may wanna turn dis off.
.sp
.ne 3
.BR "caption always" | splitonly
.RI [ strang ]
.br
.B "caption string"
.RI [ strang ]
.PP
This command controls tha display of tha window captions. Normally
a caption is only used if mo' than one window is shown on the
display (split screen mode). But if tha type is set to
.B always
screen shows a cold-ass lil caption even if only one window is displayed. Y'all KNOW dat shit, muthafucka! Da default
is
.BR splitonly .
.P
Da second form chizzlez tha text used fo' tha caption. I aint talkin' bout chicken n' gravy biatch. Yo ass can use
all escapes from tha \*QSTRING ESCAPES\*U chapter n' shit. Right back up in yo muthafuckin ass. Screen uses
a default of `%3n %t'.
.P
Yo ass can mix both forms by providin a strang as a additionizzle argument.
.sp
.ne 3
.BI "charset " set
.PP
Change tha current characta set slot designation n' charset
mapping.  Da first four characta of
.I set
are treated as charset designators while tha fifth n' sixth
characta must be up in range '0' ta '3' n' set tha GL/GR charset
mapping. On every last muthafuckin posizzle a '.' may be used ta indicate that
the correspondin charset/mappin should not be chizzled
(\fIset\fP is padded ta six charactas internally by appendin '.'
chars). New windows have "BBBB02" as default charset, unless a
\*Qencoding\*U command be active.
.br
Da current settin can be viewed wit tha \*Qinfo\*U command.
.sp
.ne 3
.B chdir
.RI [ directory ]
.PP
Change tha \fIcurrent directory\fP of
.I screen
to tha specified directory or, if called without a argument,
to yo' home directory (the value of tha environment variable $HOME).
All windows dat is pimped by meanz of tha \*Qscreen\*U command
from within \*Q.screenrc\*U or by meanz of \*QC-a : screen ...\*U
or \*QC-a c\*U use dis as they default directory.
Without a cold-ass lil chdir command, dis would be tha directory from which
.I screen
was invoked.
Hardcopy n' log filez is always freestyled ta tha \fIwindow's\fP default
directory, \fInot\fP tha current directory of tha process hustlin up in the
window.
Yo ass can use dis command multiple times up in yo' .screenrc ta start various
windows up in different default directories yo, but tha last chdir value will
affect all tha windows you create interactively.
.sp
.ne 3
.B clear
.PP
Clears tha current window n' saves its image ta tha scrollback buffer.
.sp
.ne 3
.B colon
.RI [ prefix ]
.PP
Allows you ta enta \*Q.screenrc\*U command lines. Useful 
for on-the-fly modification of key bindings, 
specific window creation n' changin settings. Note dat tha \*Qset\*U
keyword no longer exists muthafucka! Usually commandz affect tha current window rather 
than default settings fo' future windows. Chizzle defaults wit commands
startin wit 'def...'. 

If you consider dis as tha `Ex command mode' of 
.IR screen ,
you may regard \*QC-a esc\*U (copy mode) as its `Vi command mode'.
.sp 
.ne 3
.B command
.RB [ -c
.IR class ]
.PP
This command has tha same ol' dirty effect as typin tha screen escape
characta (^A). Well shiiiit, it is probably only useful fo' key bindings.
If tha \*Q-c\*U option is given, select tha specified command
class.  See also \*Qbind\*U n' \*Qbindkey\*U.
.sp 
.ne 3
.BR "compacthist " [ on | off ]
.PP
This  drops some lyrics ta screen whether ta suppress trailin blank lines when
scrollin up text tha fuck into tha history buffer.
.sp 
.ne 3
.BR "console " [ on | off ]
.PP
Grabs or un-grabs tha machines console output ta a window.
.IR Note :
Only tha balla of /dev/console can grab tha console output.
This command is only available if tha machine supports tha ioctl TIOCCONS.
.sp
.ne 3
.B copy
.PP
Enta copy/scrollback mode. This allows you ta copy text from tha current
window n' its history tha fuck into tha paste buffer n' shit. In dis mode a vi-like
`full screen editor' be active:
.br
.IR "Movement keys" :
.br
.in +4n
.ti -2n
\fBh\fP, \fBC-h\fP, or \fBleft arrow\fP move tha cursor left.
.br
.ti -2n
\fBj\fP, \fBC-n\fP, or \fBdown arrow\fP move tha cursor down.
.br
.ti -2n
\fBk\fP, \fBC-p\fP, or \fBup arrow\fP move tha cursor up.
.br
.ti -2n
\fBl\fP ('el') or \fBright arrow\fP move tha cursor right.
.br
.ti -2n
\fB0\fP (zero) or \fBC-a\fP move ta tha leftmost column.
.br
.ti -2n
\fB+\fP n' \fB\-\fP positions one line up n' down.
.br
.ti -2n
\fBH\fP, \fBM\fP n' \fBL\fP move tha cursor ta tha leftmost column
of tha top, centa or bottom line of tha window. 
.br
.ti -2n
\fB|\fP moves ta tha specified absolute column.
.br
.ti -2n
\fBg\fP or \fBhome\fP moves ta tha beginnin of tha buffer.
.br
.ti -2n
\fBG\fP or \fBend\fP moves ta tha specified absolute line (default: end of buffer).
.br 
.ti -2n
\fB%\fP jumps ta tha specified cementage of tha buffer.
.br
.ti -2n
\fB^\fP or \fB$\fP move ta tha leftmost column, ta tha straight-up original gangsta or last
non-whitespace characta on tha line.
.br
.ti -2n
\fBw\fP, \fBb\fP, n' \fBe\fP move tha cursor word by word.
.br 
.ti -2n
\fBB\fP, \fBE\fP move tha cursor WORD by WORD (as up in vi).
.br 
.ti -2n
.\"\fBf\fP,\fBt\fP, \fBF\fP, \fBT\fP move tha cursor forward/backward ta tha next occurence of tha target.
\fBf/F\fP, \fBt/T\fP move tha cursor forward/backward ta tha next occurence of tha target. (eg, '3fy' will 
move tha cursor ta tha 3rd 'y' ta tha right.)
.br
.ti -2n
\fB;\fP n' \fB,\fP Repeat tha last f/F/t/T command up in tha same/opposite direction.
.br
.ti -2n
\fBC-e\fP n' \fBC-y\fP scroll tha display up/down by one line
while preservin tha cursor position.
.br
.ti -2n
\fBC-u\fP n' \fBC-d\fP scroll tha display up/down by tha specified amount of 
lines while preservin tha cursor position. I aint talkin' bout chicken n' gravy biatch. (Default: half screen-full). 
.br
.ti -2n
\fBC-b\fP n' \fBC-f\fP scroll tha display up/down a gangbangin' full screen.
.br
.ti -4n

.IR Note :
.br
Emacs steez movement keys can be customized by a .screenrc command.
(E.\|g. markkeys "h=^B:l=^F:$=^E") There is no simple method fo' a gangbangin' full 
emacs-style keymap, as dis involves multi-characta codes.

.br
.ti -4n
.IR Markin :
.br
Da copy range is specified by settin two marks. Da text between these marks 
will be highlighted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Press:
.br
.ti -2n
\fBspace\fP or \fBenter\fP ta set tha straight-up original gangsta or second mark
respectively. If \fBmousetrack\fP is set ta `on', marks can also be set using
\fPleft mouse click\fP.
.br
.ti -2n
\fBY\fP n' \fBy\fP used ta mark one whole line or ta mark from 
start of line.
.br
.ti -2n
\fBW\fP marks exactly one word. Y'all KNOW dat shit, muthafucka! 
.br 
.ti -4n
.IR "Repeat count" :
.br
Any of these commandz can be prefixed wit a repeat count number by pressin 
digits 
.br
.ti -2n
\fB0\fP..\fB9\fP which
is taken as a repeat count. 
.br
Example: \*QC-a C-[ H 10 j 5 Y\*U will copy lines
11 ta 15 tha fuck into tha paste buffer.
.br
.ti -4n
.IR Searchin :
.ti -2n
\fB/\fP \fIVi\fP-like search forward.
.ti -2n
\fB?\fP \fIVi\fP-like search backward.
.ti -2n 
\fBC-a s\fP \fIEmacs\fP steez incremenstrual search forward.
.ti -2n
\fBC-r\fP \fIEmacs\fP steez reverse i-search.
.ti -2n
\fBn\fP Find next search pattern.
.ti -2n
\fBN\fP Find previous search pattern.
.ti -4n
.IR Specials :
.br
There is however some keys dat act differently than in
.IR vi .
.I Vi
does not allow one ta yank rectangular blockz of text yo, but
.I screen
does. Press: 
.br
.ti -2n
\fBc\fP or \fBC\fP ta set tha left or right margin respectively. If no repeat count is
given, both default ta tha current cursor position. I aint talkin' bout chicken n' gravy biatch. 
.br
Example: Try dis on a rather full text screen: 
\*QC-a [ M 20 l SPACE c 10 l 5 j C SPACE\*U.

This moves one ta tha middle line of tha screen, moves up in 20 columns left,
marks tha beginnin of tha paste buffer, sets tha left column, moves 5 columns
down, sets tha right column, n' then marks tha end of
the paste buffer n' shit. Now try:
.br
\*QC-a [ M 20 l SPACE 10 l 5 j SPACE\*U

and notice tha difference up in tha amount of text copied.
.br
.ti -2n
\fBJ\fP joins lines. Well shiiiit, it togglez between 4 modes: lines separated by a
newline characta (012), lines glued seamless, lines separated by a single
whitespace n' comma separated lines. Note dat you can prepend tha newline
characta wit a cold-ass lil carriage return character, by issuin a \*Qcrlf on\*U.
.br
.ti -2n
\fBv\fP or \fBV\fP is fo' all the
.I vi 
users wit \*Q:set numbers\*U \- it togglez tha left margin between column 9
and 1. Press 
.br
.ti -2n
\fBa\fP before tha final space key ta toggle up in append mode. Thus
the contentz of tha paste buffer aint gonna be overwritten yo, but be appended to.
.br
.ti -2n
\fBA\fP togglez up in append mode n' sets a (second) mark.
.br
.ti -2n
\fB>\fP sets tha (second) mark n' writes tha contentz of tha paste buffer to
the screen-exchange file (/tmp/screen-exchange per default) once copy-mode is 
finished. Y'all KNOW dat shit, muthafucka! 
.br
This example demonstrates how tha fuck ta dump tha whole scrollback buffer 
to dat file: \*QC-A [ g SPACE G $ >\*U.
.br
.ti -2n
\fBC-g\fP gives shiznit bout tha current line n' column.
.br
.ti -2n
\fBx\fP or \fBo\fP exchanges tha straight-up original gangsta mark n' tha current cursor position. I aint talkin' bout chicken n' gravy biatch. You
can use dis ta adjust a already placed mark.
.br
.ti -2n
\fBC-l\fP ('el') will redraw tha screen.
.br 
.ti -2n
\fB@\fP do nothing. Do not even exit copy mode.
.br
.ti -2n
All keys not busted lyrics bout here exit copy mode.
.in -4n
.sp
.ne 3
.B copy_reg
.RI [ key ]
.PP
No longer exists, use \*Qreadreg\*U instead.
.sp
.ne 3
.BR "crlf " [ on | off ]
.PP
This affects tha copyin of text regions wit tha `C-a [' command. Y'all KNOW dat shit, muthafucka! If it is set
to `on', lines is ghon be separated by tha two characta sequence `CR' - `LF'. 
Otherwise (default) only `LF' is used.
When no parameta is given, tha state is toggled.
.sp
.ne 3
.BR "debug on" | off
.PP
Turns runtime debuggin on or off. If 
.I screen
has been compiled wit option -DDEBUG debuggin available n' is turned on per 
default. Note dat dis command only affects debuggin output from tha main 
\*QSCREEN\*U process erectly. Debug output from attacher processes can only
be turned off once n' alllll muthafuckin day.
.sp
.ne 3
.BR "defc1 on" | off
.PP
Same as tha \fBc1\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `on'.
.sp
.ne 3
.BR "defautonuke on" | off
.PP
Same as tha \fBautonuke\fP command except dat tha default settin fo' freshly smoked up displays is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
Note dat you can use tha special `AN' terminal capabilitizzle if you
want ta git a thugged-out dependency on tha terminal type.
.sp
.ne 3
.BR "defbce on" | off
.PP
Same as tha \fBbce\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.B defbreaktype
.RI [ tcsendbreak | TIOCSBRK
.RI | TCSBRK ]
.PP
Choose one of tha available methodz of generatin a funky-ass break signal for
terminal devices. Da preferred methodz is 
.IR tcsendbreak " n' " TIOCSBRK .
Da third, 
.IR TCSBRK , 
blocks tha complete 
.I screen
session fo' tha duration
of tha break yo, but it may be tha only way ta generate long breaks. 
.IR Tcsendbreak " n' " TIOCSBRK
may or may not produce long breaks wit spikes (e.g. 4 per
second). This aint only system-dependent, dis also differs between
serial board drivers.
Callin \*Qdefbreaktype\*U wit no parameta displays tha current setting.
.sp
.ne 3
.BR "defcharset " [ \fIset ]
.PP
Like tha \fBcharset\fP command except dat tha default settin for
new windows is chizzled. Y'all KNOW dat shit, muthafucka! Shows current default if called without
argument.
.sp
.ne 3
.BI "defescape " xy
.PP
Set tha default command characters. This is equivalent ta tha 
\*Qescape\*U except dat it is useful multiuser sessions only. In a
multiuser session \*Qescape\*U chizzlez tha command characta of the
callin user, where \*Qdefescape\*U chizzlez tha default command
charactas fo' playas dat is ghon be added later.
.sp
.ne 3
.BR "defflow on" | off | auto 
.RB [ interrupt ]
.PP
Same as tha \fBflow\fP command except dat tha default settin fo' freshly smoked up windows 
is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `auto'.
Specifyin \*Qdefflow auto interrupt\*U is tha same ol' dirty as tha command-line options
.B \-fa
and
.BR \-i . 
.sp
.ne 3
.BR "defgr on" | off
.PP
Same as tha \fBgr\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.BR "defhstatus " [ \fIstatus ]
.PP
Da hardstatus line dat all freshly smoked up windows will git is set to
.I status\fR.
This command is useful ta make tha hardstatuz of every last muthafuckin window
display tha window number or title or tha like.
.I Status
may contain tha same directives as up in tha window lyrics yo, but
the directizzle escape characta is '^E' (octal 005) instead of '%'.
This was done ta cook up a misinterpretation of program generated
hardstatus lines impossible.
If tha parameter
.I status
is omitted, tha current default strang is displayed.
Per default tha hardstatus line of freshly smoked up windows is empty.
.sp
.ne 3
.BI "defencodin " enc
.PP
Same as tha \fBencoding\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is tha encodin taken from the
terminal.
.sp
.ne 3
.BR "deflog on" | off
.PP
Same as tha \fBlog\fP command except dat tha default settin fo' freshly smoked up windows 
is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.BR "deflogin on" | off
.PP
Same as tha \fBlogin\fP command except dat tha default settin fo' freshly smoked up windows 
is chizzled. Y'all KNOW dat shit, muthafucka! This is initialized wit `on' as distributed (see config.h.in).
.sp
.ne 3
.BI "defmode " mode
.PP
Da mode of each newly allocated pseudo-tty is set ta \fImode\fP.
\fIMode\fP be a octal number.
When no \*Qdefmode\*U command is given, mode 0622 is used.
.sp
.ne 3
.BR "defmonitor on" | off
.PP
Same as tha \fBmonitor\fP command except dat tha default settin fo' freshly smoked up 
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.BR "defmousetrack on" | off
.PP
Same as tha \fBmousetrack\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.B defnonblock 
.BR on | off | \fInumsecs
.PP
Same as tha \fBnonblock\fP command except dat tha default settin for
displays is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.BI "defobuflimit " limit
.PP
Same as tha \fBobuflimit\fP command except dat tha default settin fo' freshly smoked up displays is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is 256 bytes.
Note dat you can use tha special 'OL' terminal capabilitizzle if you
want ta git a thugged-out dependency on tha terminal type.
.sp
.ne 3
.BI "defscrollback " num
.PP
Same as tha \fBscrollback\fP command except dat tha default settin fo' freshly smoked up 
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is 100.
.sp
.ne 3
.BI "defshell " command
.PP
Synonym ta tha \fBshell\fP command. Y'all KNOW dat shit, muthafucka! See there.
.sp
.ne 3
.BR "defsilence on" | off
.PP
Same as tha \fBsilence\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `off'.
.sp
.ne 3
.BI "defslowpaste " msec"
.PP
Same as tha \fBslowpaste\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is 0 milliseconds, meanin `off'.
.sp
.ne 3
.BR "defutf8 on" | off
.PP
Same as tha \fButf8\fP command except dat tha default settin fo' new
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initial settin is `on' if screen was started with
\*Q-U\*U, otherwise `off'.
.sp
.ne 3
.BR "defwrap on" | off
.PP
Same as tha \fBwrap\fP command except dat tha default settin fo' freshly smoked up 
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initially line-wrap is on n' can be toggled wit tha 
\*Qwrap\*U command (\*QC-a r\*U) or by meanz of "C-a : wrap on|off".
.sp
.ne 3
.BR "defwritelock on" | off | auto
.PP
Same as tha \fBwritelock\fP command except dat tha default settin fo' freshly smoked up 
windows is chizzled. Y'all KNOW dat shit, muthafucka! Initially writelocks will off.
.sp
.ne 3
.BR "defzombie " [\fIkeys\fP]
.PP
Synonym ta tha \fBzombie\fP command. Y'all KNOW dat shit, muthafucka! Both currently chizzle tha default.
See there.
.sp
.ne 3
.B detach
.RB [ -h ]
.PP
Detach tha 
.I screen
session (disconnect it from tha terminal n' put it tha fuck into tha background).
This returns you ta tha shell where you invoked
.IR screen .
A detached
.I screen
can be resumed by invoking
.I screen
with the
.B \-r
option (see also section \*QCOMMAND-LINE OPTIONS\*U). The
.B \-h
option  drops some lyrics ta screen ta immediately close tha connection ta the
terminal (\*Qhangup\*U).
.sp
.ne 3
.B dinfo
.PP
Show what tha fuck screen be thinkin bout yo' terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Useful if you wanna know
why features like color or tha alternate charset don't work.
.sp
.ne 3
.B displays
.PP
Shows a tabular listin of all currently connected user front-endz (displays).
This is most useful fo' multiuser sessions.
Da followin keys can be used up in displays list:
.br
.in +4n
.ti -2n
\fBk\fP, \fBC-p\fP, or \fBup\fP Move up one line.
.br
.ti -2n
\fBj\fP, \fBC-n\fP, or \fBdown\fP Move down one line.
.br
.ti -2n
\fBC-a\fP or \fBhome\fP Move ta tha straight-up original gangsta line.
.br
.ti -2n
\fBC-e\fP or \fBend\fP Move ta tha last line.
.br
.ti -2n
\fBC-u\fP or \fBC-d\fP Move one half page up or down.
.br
.ti -2n
\fBC-b\fP or \fBC-f\fP Move one full page up or down.
.br
.ti -2n
\fBmouseclick\fP Move ta tha selected line fo' realz. Available
when \*Qmousetrack\*U is set ta on.
.br
.ti -2n
\fBspace\fP Refresh tha list
.br
.ti -2n
\fBd\fP Detach dat display
.br
.ti -2n
\fBD\fP Juice detach dat display
.br
.ti -2n
\fBC-g\fP, \fBenter\fP, or \fBescape\fP Exit tha list
.br
.ti -4n
.PP
Da followin be a example of what tha fuck \*Qdisplays\*U could look like:
.IP
xterm 80x42 jnweiger@/dev/ttyp4     0(m11)   &rWx
.br
facit 80x24 mlschroe@/dev/ttyhf nb 11(tcsh)   rwx
.br
xterm 80x42 jnhollma@/dev/ttyp5     0(m11)   &R.x
.br
 (A)   (B)     (C)     (D)     (E) (F)(G)   (H)(I)
.PP
Da legend be as bigs up:
.br
(A) Da terminal type known by screen fo' dis display.
.br
(B) Displays geometry as width x height.
.br
(C) Username whoz ass is logged up in all up in tha display.
.br
(D) Device name of tha display or tha attached device
.br
(E) Display is up in blockin or nonblockin mode. Da available modes is "nb", "NB",
"Z<", "Z>", n' "BL".
.br
(F) Number of tha window
.br
(G) Name/title of window
.br
(H) Whether tha window is shared
.br
(I) Window permissions. Made up of three characters:
      (1st character)
         - : no read
         r : read
         R : read only cuz of foreign wlock
      (2nd character)
         - : no write
         . : write suppressed by foreign wlock
         w : write
         W : own wlock
      (3rd character)
         - : no execute
         x : execute

\*QDisplays\*U needz a region size of at least 10 charactas wide n' 5 charactas high in
order ta display.
.sp
.ne 3
.BR "digraph " [ \fIpreset [ \fI unicode-value ] ]
.PP
This command prompts tha user fo' a gangbangin' finger-lickin' digraph sequence. Da next
two charactas typed is looked up in a funky-ass builtin table n' the
resultin characta is banged up in tha input stream. For example,
if tha user entas 'a"', a a-umlaut is ghon be inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If the
first characta entered be a 0 (zero),
.I screen
will treat tha followin charactas (up ta three) as a octal
number instead. Y'all KNOW dat shit, muthafucka!  Da optionizzle argument
.I preset
is treated as user input, thus one can create a \*Qumlaut\*U key.
For example tha command "bindkey ^K digraph '"'" enablez tha user
to generate a a-umlaut by typin CTRL-K a.
When a non-zero
.I unicode-value
is specified, a freshly smoked up digraph is pimped wit tha specified preset. Da digraph is unset
if a zero value is provided fo' the
.I unicode-value.
.sp
.ne 3
.B dumptermcap
.PP
Write tha termcap entry fo' tha virtual terminal optimized fo' tha currently
actizzle window ta tha file \*Q.termcap\*U up in tha userz 
\*Q$HOME/.screen\*U directory (or wherever 
.I screen
stores its sockets, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See tha \*QFILES\*U section below).
This termcap entry is identical ta tha value of tha environment variable
$TERMCAP dat is set up by
.I screen
for each window. For terminfo based systems yo big-ass booty is ghon need ta run a cold-ass lil converter
like 
.IR captoinfo
and then compile tha entry wit 
.IR tic .
.sp
.ne 3
.BR "echo " [ -n ]
.I message
.PP
Da echo command may be used ta annoy 
.I screen
users wit a 'message of the
day'. Typically installed up in a global /etc/screenrc. 
Da option \*Q-n\*U may be used ta suppress tha line feed.
See also \*Qsleep\*U.
Echo be also useful fo' online checkin of environment variables.
.sp
.ne 3
.BI "encodin " enc
.RI [ enc ]
.PP
Tell 
.I screen 
how ta interpret tha input/output. Da first argument
sets tha encodin of tha current window. Each window can emulate
a different encoding. Da optionizzle second parameta overwrites
the encodin of tha connected terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it should never be
needed as screen uses tha locale settin ta detect tha encoding.
There be also a way ta select a terminal encodin dependin on
the terminal type by rockin tha \*QKJ\*U termcap entry.

Supported encodings is eucJP, SJIS, eucKR, eucCN, Big5, GBK, KOI8-R,
CP1251, UTF-8, ISO8859-2, ISO8859-3, ISO8859-4, ISO8859-5, ISO8859-6,
ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis.

See also \*Qdefencoding\*U, which chizzlez tha default settin of a new
window.
.sp
.ne 3
.BI "escape " xy
.PP
Set tha command characta ta \fIx\fP n' tha characta generatin a literal
command characta (by triggerin tha \*Qmeta\*U command) ta \fIy\fP (similar
to tha \-e option).
Each argument is either a single character, a two-characta sequence
of tha form \*Q^x\*U (meanin \*QC-x\*U), a funky-ass backslash followed by a octal
number (specifyin tha ASCII code of tha character), or a funky-ass backslash followed
by a second character, like fuckin \*Q\e^\*U or \*Q\e\e\*U.
Da default is \*Q^Aa\*U.
.sp
.ne 3
.B eval
.I command1
.RI [ command2
.IR ... ]
.PP
Parses n' executes each argument as separate command.
.sp
.ne 3
.B exec
.RI [[ fdpat ]
.IR "newcommand " [ "args ..." ]]
.PP
Run a unix subprocess (specified by a executable path \fInewcommand\fP n' its 
optionizzle arguments) up in tha current window. Da flow of data between 
newcommandz stdin/stdout/stderr, tha process originally started up in tha window 
(let our asses call it "application-process") n' screen itself (window) is 
controlled by tha file descriptor pattern fdpat.
This pattern is basically a three characta sequence representin stdin, stdout
and stderr of newcommand. Y'all KNOW dat shit, muthafucka! A dot (.) connects tha file descriptor
to
.IR screen .
An exclamation mark (!) causes tha file
descriptor ta be connected ta tha application-process fo' realz. A colon (:) combines
both.
User input will git all up in newcommand unless newcommand receives tha 
application-process' 
output (fdpats first characta is `!' or `:') or a pipe symbol (|) be added 
(as a gangbangin' fourth character) ta tha end of fdpat.
.br
Invokin `exec' without arguments shows name n' argumentz of tha currently
runnin subprocess up in dis window. Only one subprocess a time can be hustlin
in each window.
.br
When a subprocess is hustlin tha `kill' command will affect it instead of the
windows process.
.br
Refer ta tha postscript file `doc/fdpat.ps' fo' a cold-ass lil confusin illustration
of all 21 possible combinations. Each drawin shows tha digits 2,1,0
representin tha three file descriptorz of newcommand. Y'all KNOW dat shit, muthafucka! Da box marked
`W' is tha usual pty dat has tha application-process on its slave side.
Da box marked `P' is tha secondary pty dat now has
.I screen
at its masta side.
.sp
Abbreviations: 
.br
Whitespace between tha word `exec' n' fdpat n' tha command 
can be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Trailin dots n' a gangbangin' fdpat consistin only of dots can be 
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A simple `|' is synonymous fo' tha pattern `!..|'; tha word exec can
be omitted here n' can always be replaced by `!'.
.sp
Examples:
.IP
exec ... /bin/sh
.br
exec /bin/sh
.br
!/bin/sh
.PP
Creates another shell up in tha same window, while tha original gangsta shell is still 
running. Output of both shells is displayed n' user input is busted ta tha new
/bin/sh.
.IP
exec !.. stty 19200
.br
exec ! stty 19200
.br
!!stty 19200
.PP
Set tha speed of tha windowz tty. If yo' stty command operates on stdout, 
then add another `!'.
.IP
exec !..| less
.br
|less
.PP
This addz a pager ta tha window output. Da special characta `|' is needed to
give tha user control over tha pager although it gets its input from tha 
windowz process. This works, cuz
.I less
listens on stderr (a behavior that
.I screen
would not expect without tha `|') 
when its stdin aint a tty. 
.I Less 
versions newer than 177 fail miserably here; phat old
.I pg
still works.
.IP
!:sed -n s/.*Error.*/\e007/p
.PP
Sendz window output ta both, tha user n' tha sed command. Y'all KNOW dat shit, muthafucka! Da sed bangs an
additionizzle bell characta (oct. 007) ta tha window output peeped by
.IR screen .
This will cause "Bell up in window x" lyrics, whenever tha strang "Error"
appears up in tha window.
.sp
.ne 3
.B fit
.PP
Change tha window size ta tha size of tha current region. I aint talkin' bout chicken n' gravy biatch. This
command is needed cuz screen don't adapt tha window size
automatically if tha window is displayed mo' than once.
.sp
.ne 3
.B flow
.RB [ on | off | "auto\fR]\fP"
.PP
Sets tha flow-control mode fo' dis window.
Without parametas it cyclez tha current windowz flow-control settin from 
"automatic" ta "on" ta "off".
See tha rap on \*QFLOW-CONTROL\*U lata on up in dis document fo' full 
details n' note, dat dis is subject ta chizzle up in future releases.
Default is set by `defflow'.
.sp
.ne 3
.BR "focus " [ up | down | top | bottom ]
.PP
Move tha input focus ta tha next region. I aint talkin' bout chicken n' gravy biatch. This is done up in a cold-ass lil cyclic
way so dat tha top region is selected afta tha bottom one. If
no subcommand is given it defaults ta `down'. `up' cyclez up in the
opposite order, `top' n' `bottom' git all up in tha top n' bottom
region respectively. Useful bindings is (j n' k as up in vi)
.nf
    bind j focus down
    bind k focus up
    bind t focus top
    bind b focus bottom
.fi
Note dat \fBk\fP is traditionally bound ta tha \fIkill\fP command.
.sp
.ne 3
.BI "focusminsize [ ( " width "|max|_ ) ( " height "|max|_ ) ]"
.PP
This forces any currently selected region ta be automatically
resized at least a cold-ass lil certain \fIwidth\fP n' \fIheight\fP fo' realz. All
other surroundin regions is ghon be resized up in order ta accommodate.
This constraint bigs up everytime tha \*Qfocus\*U command is
used. Y'all KNOW dat shit, muthafucka! Da \*Qresize\*U command can be used ta increase either
dimension of a region yo, but never below what tha fuck is set with
\*Qfocusminsize\*U. Da underscore `_' be a synonym for
\fBmax\fP. Right back up in yo muthafuckin ass. Settin a \fIwidth\fP n' \fIheight\fP of `0 0'
(zero zero) will undo any constraints n' allow fo' manual resizing.
Without any parameters, tha minimum width n' height is shown.
.sp
.ne 3
.BR "gr " [ on | off ]
.PP
Turn GR charset switchin on/off. Whenever screen sees a input
characta wit tha 8th bit set, it will use tha charset stored up in the
GR slot n' print tha characta wit tha 8th bit stripped. Y'all KNOW dat shit, muthafucka! The
default (see also \*Qdefgr\*U) aint ta process GR switchin cuz
otherwise tha ISO88591 charset would not work.
.sp
.ne 3
.BI group
.RI [ grouptitle ]
.PP
Change or show tha crew tha current window belongs to. Windows can
be moved round between different crews by specifyin tha name of
the destination group. Without specifyin a group, tha title of the
current crew is displayed.
.sp
.ne 3
.B hardcopy
.RB [ -h ]
.RI [ file ]
.PP
Writes up tha currently displayed image ta tha file \fIfile\fP,
or, if no filename is specified, ta \fIhardcopy.n\fP up in the
default directory, where \fIn\fP is tha number of tha current window. 
This either appendz or overwrites tha file if it exists, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See below.
If tha option \fB-h\fP is specified, dump also tha contentz of the
scrollback buffer.
.sp
.ne 3
.BR "hardcopy_append on" | off
.PP
If set ta "on", 
.I screen
will append ta tha "hardcopy.n" filez pimped by tha command \*QC-a h\*U, 
otherwise these filez is overwritten each time.
Default is `off'.
.sp
.ne 3
.BI "hardcopydir "directory
.PP
Defines a gangbangin' finger-lickin' directory where hardcopy filez is ghon be placed. Y'all KNOW dat shit, muthafucka! If unset, hardcopys
are dumped in
.IR screen 's
current hustlin directory.
.sp
.ne 3
.BR "hardstatus " [ on | off ]
.br
.BR "hardstatus \fR[\fBalways\fR]\fBlastline" | message | ignore
.RI [ strang ]
.br
.B "hardstatus string"
.RI [ strang ]
.PP
This command configures tha use n' emulation of tha terminal's
hardstatus line. Da first form
togglez whether
.I screen
will use tha hardware status line ta display lyrics. If the
flag is set ta `off', these lyrics
are overlaid up in reverse vizzle mode all up in tha display line. Da default
settin is `on'.
.P
Da second form  drops some lyrics ta 
.I screen 
what ta do if tha terminal don't
have a hardstatus line (i.e. tha termcap/terminfo capabilities
"hs", "ts", "fs" n' "ds" is not set). If tha type
\*Qlastline\*U is used, 
.I screen 
will reserve tha last line of the
display for
the hardstatus. \*Qmessage\*U uses 
.I screen's
message mechanizzle and
\*Qignore\*U  drops some lyrics ta 
.I screen 
never ta display tha hardstatus.
If you prepend tha word \*Qalways\*U ta tha type (e.g., \*Qalwayslastline\*U), 
.I screen 
will use tha type even if tha terminal supports a hardstatus.
.P
Da third form specifies tha contentz of tha hardstatus line.  '%h' is
used as default string, i.e., tha stored hardstatuz of tha current
window (settable via \*QESC]0;<string>^G\*U or \*QESC_<string>ESC\e\*U)
is displayed. Y'all KNOW dat shit, muthafucka!  Yo ass can customize dis ta any strang you like including
the escapes from tha \*QSTRING ESCAPES\*U chapter n' shit. If you leave out
the argument
.IR strang ,
the current strang is displayed.
.P
Yo ass can mix tha second n' third form by providin tha strang as
additionizzle argument.
.sp
.ne 3
.B height
.RB [ -w | -d ]
.RI [ lines " [" cols ]]
.PP
Set tha display height ta a specified number of lines. When no argument
is given it togglez between 24 n' 42 lines display. Yo ass can also
specify a width if you wanna chizzle both joints.
The
.B -w
option  drops some lyrics ta screen ta leave tha display size unchanged n' just set
the window size,
.B -d
vice versa.
.sp
.ne 3
.B help
.RB [ -c
.IR class ]
.PP
Not straight-up a online help yo, but 
displays a help 
.I screen 
showin you all tha key bindings.
Da first pages list all tha internal commandz followed by they current
bindings.
Subsequent pages will display tha custom commands, one command per key.
Press space when you done readin each page, or return ta exit early.
All other charactas is ignored. Y'all KNOW dat shit, muthafucka! If tha \*Q-c\*U option is given,
display all bound commandz fo' tha specified command class.
See also \*QDEFAULT KEY BINDINGS\*U section.
.sp
.ne 3
.B history
.PP
Usually playas work wit a gangbangin' finger-lickin' dirty-ass shell dat allows easy as fuck  access ta previous commands.
For example csh has tha command \*Q!!\*U ta repeat tha last command executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.I Screen
allows you ta git a primitizzle way of re-callin \*Qthe command that
started ...\*U: Yo ass just type tha straight-up original gangsta letta of dat command, then hit
`C-a {' and
.I screen
tries ta find a previous line dat matches wit tha `prompt character' 
to tha left of tha cursor. Shiiit, dis aint no joke. This line is pasted tha fuck into dis windowz input queue.
Thus you gotz a cold-ass lil crude command history (made up by tha visible window n' its
scrollback buffer). 
.sp
.ne 3
.BI "hstatus " status
.PP
Change tha windowz hardstatus line ta tha strang \fIstatus\fP.
.sp
.ne 3
.B idle
.RI [ timeout
.RI [ "cmd args" ]]
.PP
Sets a cold-ass lil command dat is run afta tha specified number of seconds
inactivitizzle is reached. Y'all KNOW dat shit, muthafucka! This command will normally be tha \*Qblanker\*U
command ta create a screen blanker yo, but it can be any screen command.
If no command is specified, only tha timeout is set fo' realz. A timeout of
zero (or tha special timeout \fBoff\fP) disablez tha timer.
If no arguments is given, tha current settings is displayed.
.sp
.ne 3
.BR "ignorecase " [ on | off ]
.PP
Tell screen ta ignore tha case of charactas up in searches. Default is
`off'. Without any options, tha state of ignorecase is toggled.
.sp
.ne 3
.B info
.PP
Uses tha message line ta display some shiznit bout tha current window:
the cursor posizzle up in tha form \*Q(column,row)\*U startin wit \*Q(1,1)\*U,
the terminal width n' height plus tha size of tha scrollback buffer up in lines, 
like up in \*Q(80,24)+50\*U, tha current state of window XON/XOFF flow control
is shown like dis (See also section FLOW CONTROL):

.nf
  +flow     automatic flow control, currently on.
  -flow     automatic flow control, currently off.
  +(+)flow  flow control enabled. Y'all KNOW dat shit, muthafucka! Agrees wit automatic control.
  -(+)flow  flow control disabled. Y'all KNOW dat shit, muthafucka! Disagrees wit automatic control.
  +(-)flow  flow control enabled. Y'all KNOW dat shit, muthafucka! Disagrees wit automatic control.
  -(-)flow  flow control disabled. Y'all KNOW dat shit, muthafucka! Agrees wit automatic control.
.fi

Da current line wrap settin (`+wrap' indicates enabled, `\-wrap' not) is
also shown. I aint talkin' bout chicken n' gravy biatch. Da flags `ins', `org', `app', `log', `mon' or `nored' is 
displayed when tha window is up in bang mode, origin mode, 
application-keypad mode, has output logging,
activitizzle monitorin or partial redraw enabled.

Da currently actizzle characta set (\fIG0\fP, \fIG1\fP, \fIG2\fP,
or \fIG3\fP) n' up in square brackets tha terminal characta sets dat are
currently designated as \fIG0\fP all up in \fIG3\fP is shown. I aint talkin' bout chicken n' gravy biatch. If tha window
is up in UTF-8 mode, tha strang \*QUTF-8\*U is shown instead.

Additionizzle modes dependin on tha type of tha window is displayed all up in tha end of tha status line (See also chapta \*QWINDOW TYPES\*U).
.br
If tha state machine of tha terminal emulator is up in a non-default state,
the info line is started wit a strang identifyin tha current state.
.br
For system shiznit use tha \*Qtime\*U command.
.sp
.ne 3
.BR ins_reg " [" \fIkey ]
.PP
No longer exists, use \*Qpaste\*U instead.
.sp
.ne 3
.B kill
.PP
Bust a cap up in current window.
.br 
If there be a `exec' command hustlin then it is capped. Y'all KNOW dat shit, muthafucka! Otherwise tha process
(shell) hustlin up in tha window receives a HANGUP condition, 
the window structure is removed n' 
.I screen 
(your display) switches ta another
window.  When tha last window is destroyed, 
.I screen
exits.
Afta a bust a cap up in 
.I screen 
switches ta tha previously displayed window.
.br
Note:
.I Emacs
users should keep dis command up in mind, when cappin' a line.
It be recommended not ta use \*QC-a\*U as the
.I screen
escape key or ta rebind bust a cap up in ta \*QC-a K\*U.
.sp
.ne 3
.B lastmsg
.PP
Redisplay tha last contentz of tha message/status line.
Useful if you typin when a message appears, cuz  tha message goes 
away when you press a key (unless yo' terminal has a hardware status line).
Refer ta tha commandz \*Qmsgwait\*U n' \*Qmsgminwait\*U fo' fine tuning.
.sp
.ne 3
.BR "layout freshly smoked up " [\fItitle\fP]
.PP
Smoke a freshly smoked up layout. Da screen will chizzle ta one whole region
and be switched ta tha blank window. From here, you build the
regions n' tha windows they show as you desire. Da freshly smoked up layout
will be numbered wit tha smallest available integer, starting
with zero. Yo ass can optionally give a title ta yo' freshly smoked up layout.
Otherwise, it gonna git a thugged-out default title of \*Qlayout\*U. You
can always chizzle tha title lata by rockin tha command
\fBlayout title\fP.
.sp
.ne 3
.BR "layout remove " [\fIn|title\fP]
.PP
Remove, or up in other lyrics, delete tha specified layout. Either
the number or tha title can be specified. Y'all KNOW dat shit, muthafucka! Without either
specification, \fIscreen\fP will remove tha current layout.

Removin a layout do not affect yo' set windows or regions.
.sp
.ne 3
.B layout next
.PP
Switch ta tha next layout available
.sp
.ne 3
.B layout prev
.PP
Switch ta tha previous layout available
.sp
.ne 3
.BR "layout select " [\fIn|title\fP]
.PP
Select tha desired layout. Either tha number or tha title can
be specified. Y'all KNOW dat shit, muthafucka! Without either justification, \fIscreen\fP will
prompt n' ask which screen is desired. Y'all KNOW dat shit, muthafucka! To peep which layouts are
available, use tha \fBlayout show\fP command.
.sp
.ne 3
.B layout show
.PP
List on tha message line tha number(s) n' title(s) of tha available
layout(s). Da current layout is flagged.
.sp
.ne 3
.BR "layout title " [\fItitle\fP]
.PP
Change or display tha title of tha current layout fo' realz. A strang given
will be used ta name tha layout. Without any options, tha current
title n' number is displayed on tha message line.
.sp
.ne 3
.BR "layout number " [\fIn\fP]
.PP
Change or display tha number of tha current layout fo' realz. An integer given
will be used ta number tha layout. Without any options, tha current
number n' title is displayed on tha message line.
.sp
.ne 3
.BR "layout attach " [\fItitle\fP|\fB:last\fP]
.PP
Change or display which layout ta reattach back to. Da default is
\fB:last\fP, which  drops some lyrics ta \fIscreen\fP ta reattach back ta tha last
used layout just before detachment. By supplyin a title, Yo ass can
instruct \fIscreen\fP ta reattach ta a particular layout regardless
which one was used all up in tha time of detachment. Without any options,
the layout ta reattach ta is ghon be shown up in tha message line.
.sp
.ne 3
.BR "layout save " [\fIn|title\fP]
.PP
Remember tha current arrangement of regions. When used, \fIscreen\fP
will remember tha arrangement of vertically n' horizontally split
regions. This arrangement is restored when a \fIscreen\fP session
is reattached or switched back from a gangbangin' finger-lickin' different layout. If the
session endz or tha \fIscreen\fP process dies, tha layout
arrangements is lost. Da \fBlayout dump\fP command should help
in dis siutation. I aint talkin' bout chicken n' gravy biatch. If a number
or title is supplied, \fIscreen\fP will remember tha arrangement of
that particular layout. Without any options, \fIscreen\fP will
remember tha current layout.

Savin yo' regions can be done automatically by rockin the
\fBlayout autosave\fP command.
.sp
.ne 3
.BR "layout autosave " [\fBon|off\fP]
.PP
Change or display tha statuz of automatcally savin layouts, n' you can put dat on yo' toast. The
default is \fBon\fP, meanin when \fIscreen\fP is detached or
changed ta a gangbangin' finger-lickin' different layout, tha arrangement of regions n' windows
will be remembered all up in tha time of chizzle n' restored upon return.
If autosave is set ta \fBoff\fP, dat arrangement will only be
restored ta either ta tha last manual save, rockin \fBlayout save\fP,
or ta when tha layout was first pimped, ta a single region with
a single window. Without either a \fBon\fP or \fBoff\fP, the
current status is displayed on tha message line.
.sp
.ne 3
.BR "layout dump " [\fIfilename\fP]
.PP
Write ta a gangbangin' file tha order of splits made up in tha current layout. This 
is useful ta recreate tha order of yo' regions used up in yo' current
layout. Only tha current layout is recorded. Y'all KNOW dat shit, muthafucka! While tha order of the
regions is recorded, tha sizez of dem regions n' which windows
correspond ta which regions is not. If no filename is specified,
the default is \fIlayout-dump\fP, saved up in tha directory dat the
\fIscreen\fP process was started in. I aint talkin' bout chicken n' gravy biatch. If tha file already exists,
\fBlayout dump\fP will append ta dat file fo' realz. As a example:
.PP
.nf
	C-a : layout dump /home/user/.screenrc
.fi
.PP
will save or append tha layout ta tha userz \fI.screenrc\fP file.
.sp
.ne 3
.B license
.PP
Display tha disclaimer page. This is done whenever
.I screen
is started without options, which should be often enough cause I gots dem finger-lickin' chickens wit tha siz-auce. Right back up in yo muthafuckin ass. See also 
the \*Qstartup_message\*U command.
.sp
.ne 3
.B lockscreen
.PP
Lock dis display.
Call a screenlock program (/local/bin/lck or /usr/bin/lock or a funky-ass builtin if no
other be available). Right back up in yo muthafuckin ass. Screen do not accept any command keys until dis program
terminates. Meanwhile processes up in tha windows may continue, as tha windows 
are up in tha `detached' state. Da screenlock program may be chizzled all up in the
environment variable $LOCKPRG (which must be set up in tha shell from which 
.I screen
is started) n' is executed wit tha userz uid n' gid.
.br
Warning: 
When you leave other shells unlocked n' you have no password set on           
.IR screen ,
the lock is void: One could easily re-attach from a unlocked
shell. This feature should rather be called `lockterminal'.
.sp
.ne 3
.BR "log " [ on | off ]
.PP
Start/stop freestylin output of tha current window ta a gangbangin' file 
\*Qscreenlog.\fIn\fP\*U up in tha windowz default directory, where \fIn\fP 
is tha number of tha current window. This filename can be chizzled with
the `logfile' command. Y'all KNOW dat shit, muthafucka! If no parameta is given, tha state
of loggin is toggled. Y'all KNOW dat shit, muthafucka! Da session log be appended ta tha previous contents 
of tha file if it already exists, n' you can put dat on yo' toast. Da current contents n' tha contents 
of tha scrollback history is not included up in tha session log.
Default is `off'.
.sp
.ne 3
.BI "logfile " filename
.br
.BI "logfile flush " secs
.PP
Defines tha name tha log filez will get. Da default is
\*Qscreenlog.%n\*U. Da second form chizzlez tha number of seconds
.I screen
will wait before flushin tha logfile buffer ta tha file-system. The
default value is 10 seconds.
.sp
.ne 3
.BR "login " [ on | off ]
.PP
Addz or removes tha entry up in tha utmp database file fo' tha current window.
This controls if tha window is `logged in'.
When no parameta is given, tha login state of tha window is toggled.
Additionally ta dat toggle, it is convenient havin a `log in' n' a `log out'
key. E.\|g. `bind I login on' n' `bind O login off' will map these
keys ta be C-a I n' C-a O.
Da default settin (in config.h.in) should be \*Qon\*U fo' a 
.I screen
that runs under suid-root.
Use tha \*Qdeflogin\*U command ta chizzle tha default login state fo' freshly smoked up 
windows. Both commandz is only present when 
.I screen
has been compiled wit utmp support.
.sp
.ne 3
.BR "logtstamp " [ on | off ]
.br
.B "logtstamp after"
.RI [ secs ]
.br
.B "logtstamp string"
.RI [ strang ]
.PP
This command controls logfile time-stamp mechanizzle of 
.I screen.
If
time-stamps is turned \*Qon\*U, 
.I screen 
addz a strang containing
the current time ta tha logfile afta two minutez of inactivity.
When output continues n' mo' than another two minutes have passed,
a second time-stamp be added ta document tha restart of the
output. Yo ass can chizzle dis timeout wit tha second form
of tha command. Y'all KNOW dat shit, muthafucka! Da third form is used fo' customizin tha time-stamp
strin (`-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\\n' by
default).
.sp
.ne 3
.B mapdefault
.PP
Tell 
.I screen 
that tha next input characta should only be looked up
in tha default bindkey table. Right back up in yo muthafuckin ass. See also \*Qbindkey\*U.
.sp
.ne 3
.B mapnotnext
.PP
Like mapdefault yo, but don't even look up in tha default bindkey table.
.sp
.ne 3
.B maptimeout
.RI [ timeout ]
.PP
Set tha inter-characta timer fo' input sequence detection ta a timeout
of
.I timeout
ms. Da default timeout is 300ms. Maptimeout wit no arguments shows
the current setting.
See also \*Qbindkey\*U.
.sp
.ne 3
.BI "markkeys " string
.PP
This be a method of changin tha keymap used fo' copy/history mode.
Da strang is made up of \fIoldchar\fP=\fInewchar\fP pairs which are
separated by `:'. Example: Da strang \*QB=^B:F=^F\*U will chizzle tha 
keys `C-b' n' `C-f' ta tha vi steez bindin (scroll up/down fill page).
This happens ta be tha default bindin fo' `B' n' `F'.
Da command \*Qmarkkeys h=^B:l=^F:$=^E\*U would set tha mode fo' a emacs-style
binding.
If yo' terminal sendz characters, dat cause you ta abort copy mode,
then dis command may help by bindin these charactas ta do nothing.
Da no-op characta is `@' n' is used like this: \*Qmarkkeys
@=L=H\*U if you do not wanna use tha `H' or `L' commandz any longer.
As shown up in dis example, multiple keys can be assigned ta one function up in a 
single statement.
.sp
.ne 3
.BI "maxwin " num
.PP
Set tha maximum window number screen will create. Don't affect
already existin windows. Da number can be increased only when there be no
existin windows.
.sp
.ne 3
.B meta
.PP
Insert tha command characta (C-a) up in tha current windowz input stream.
.sp
.ne 3
.BR "monitor " [ on | off ]
.PP
Togglez activitizzle monitorin of windows.
When monitorin is turned on n' a affected window is switched tha fuck into the
background, yo big-ass booty is ghon receive tha activitizzle notification message up in the
status line all up in tha straight-up original gangsta sign of output n' tha window will also be marked
with a `@' up in tha window-status display.
Monitorin is initially off fo' all windows.
.sp
.ne 3
.BR "mousetrack " [ on | off ]
.PP
This command determines whether
.I screen
will peep for
mouse clicks. When dis command is enabled, regions dat have
been split up in various ways can be selected by pointin ta them
with a mouse n' left-clickin em. Without specifyin \fBon\fP
or \fBoff\fP, tha current state is displayed. Y'all KNOW dat shit, muthafucka! Da default state
is determined by tha \*Qdefmousetrack\*U command.
.sp
.ne 3
.BI "msgminwait " sec
.PP
Defines tha time 
.I screen 
delays a freshly smoked up message when one message is currently displayed. Y'all KNOW dat shit, muthafucka! 
Da default is 1 second.
.sp
.ne 3
.BI "msgwait " sec
.PP
Defines tha time a message is displayed if 
.I screen
is not disturbed by other activity. Da default is 5 seconds.
.sp
.ne 3
.BR "multiuser on" | off
.PP
Switch between singleuser n' multiuser mode. Right back up in yo muthafuckin ass. Standard
.I screen
operation is singleuser n' shit. In multiuser mode tha commandz `acladd',
`aclchg', `aclgrp' n' `acldel'
can be used ta enable (and disable) other playas accessin dis 
.I screen
session. I aint talkin' bout chicken n' gravy biatch. 
.sp
.ne 3
.BR "nethack on" | off
.PP
Changes tha kind of error lyrics used by
.IR screen .
When yo ass is familiar wit tha game \*Qnethack\*U, you may trip off the
nethack-style lyrics which will often blur tha facts a lil yo, but are
much funnier ta read. Y'all KNOW dat shit, muthafucka! Anyway, standard lyrics often tend ta be unclear as
well.
.br
This option is only 
available if
.I screen
was compiled wit tha NETHACK flag defined. Y'all KNOW dat shit, muthafucka! The
default settin is then determined by tha presence of tha environment 
variable $NETHACKOPTIONS n' tha file ~/.nethackrc - if either one is present,
the default is \fBon\fP.
.sp
.ne 3
.B next
.PP
Switch ta tha next window.
This command can be used repeatedly ta cycle all up in tha list of windows.
.sp
.ne 3
.B nonblock 
.RB [ on | off | \fInumsecs ]
.PP
Tell screen how tha fuck ta deal wit user intercourses (displays) dat cease to
accept output. This can happen if a user presses ^S or a TCP/modem
connection gets cut but no hangup is received. Y'all KNOW dat shit, muthafucka! If nonblock is
\fBoff\fP (this is tha default) screen waits until tha display
restarts ta accept tha output. If nonblock is \fBon\fP, screen
waits until tha timeout is reached (\fBon\fP is treated as 1s). If the
display still don't receive characters, screen will consider
it \*Qblocked\*U n' stop bustin  charactas ta dat shit. If at
some time it restarts ta accept characters, screen will unblock
the display n' redisplay tha updated window contents.
.sp
.ne 3
.BR "number " [[+|-] \fIn ]
.PP
Change tha current windowz number n' shit. If tha given number \fIn\fP be already 
used by another window, both windows exchange they numbers. If no argument is
specified, tha current window number (and title) is shown. I aint talkin' bout chicken n' gravy biatch. Usin `+' or `-'
will chizzle tha windowz number by tha relatizzle amount specified.
.sp
.ne 3
.BR "obuflimit " [ \fIlimit ]
.PP
If tha output buffer gotz nuff mo' bytes than tha specified limit, no
more data will be
read from tha windows. Da default value is 256. If you gotz a gangbangin' fast
display (like xterm), you can set it ta some higher value. If no
argument is specified, tha current settin is displayed.
.sp
.ne 3
.B only
.PP
Bust a cap up in all regions but tha current one.
.sp
.ne 3
.B other
.PP
Switch ta tha window displayed previously. If dis window do no longer exist,
\fIother\fP has tha same ol' dirty effect as \fInext\fP.
.sp
.ne 3
.BR "partial on" | off
.PP
Defines whether tha display should be refreshed (as wit \fIredisplay\fP) after
switchin ta tha current window. This command only affects tha current window.
To immediately affect all windows use tha \fIallpartial\fP command.
Default is `off', of course.  This default is fixed, as there is currently no 
\fIdefpartial\fP command.
.sp
.ne 3
.BR "password " [ \fIcrypted_pw ]
.PP
Present a cold-ass lil crypted password up in yo' \*Q.screenrc\*U file and
.I screen
will ask
for it, whenever one of mah thugs attempts ta resume a thugged-out detached. Y'all KNOW dat shit, muthafucka! This is useful
if you have privileged programs hustlin under
.I screen
and you wanna protect yo' session from reattach attempts by another user
masqueradin as yo' uid (i.e. any superuser.)
If no crypted password is specified,
.I screen
prompts twice fo' typin a
password n' places its encryption up in tha paste buffer.
Default is `none', dis disablez password checking.
.sp
.ne 3
.BR paste
.RI [ registas " [" dest_reg ]]
.PP
Write tha (concatenated) contentz of tha specified registas ta tha stdin queue
of tha current window. Da regista '.' is treated as the
paste buffer n' shit. If no parameta is given tha user is prompted fo' a single 
regista ta paste.
Da paste buffer can be filled wit tha \fIcopy\fP, \fIhistory\fP n' 
\fIreadbuf\fP commands. 
Other registas can be filled wit tha \fIregister\fP, \fIreadreg\fP n' 
\fIpaste\fP commands.
If \fIpaste\fP is called wit a second argument, tha contentz of tha specified
registas is pasted tha fuck into tha named destination regista rather than 
the window. If '.' is used as tha second argument, tha displays paste buffer is
the destination.
Note, dat \*Qpaste\*U uses a wide variety of resources: Whenever a second 
argument is specified no current window is needed. Y'all KNOW dat shit, muthafucka! When tha source justification
only gotz nuff registas (not tha paste buffer) then there need not be a cold-ass lil current 
display (terminal attached), as tha registas is a global resource. Da 
paste buffer exists once fo' every last muthafuckin user.
.sp
.ne 3
.BR "pastefont " [ on | off ]
.PP
Tell 
.I screen 
to include font shiznit up in tha paste buffer n' shit. The
default aint ta do so. This command is especially useful for
multi characta fonts like kanji.
.sp
.ne 3
.B pow_break
.PP
Reopen tha windowz terminal line n' bust a funky-ass break condition. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See `break'.
.sp
.ne 3
.B pow_detach
.PP
Juice detach. 
Mainly tha same as \fIdetach\fP yo, but also sendz a HANGUP signal to
the parent process of
.IR screen .
CAUTION: This will result up in a logout, when 
.I screen
was started from yo' login shell.
.sp
.ne 3
.B pow_detach_msg
.RI [ message ]
.PP
Da \fImessage\fP specified here is output whenever a `Juice detach' was
performed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it may be used as a replacement fo' a logout message or ta reset 
baud rate, etc. 
Without parameter, tha current message is shown.
.sp
.ne 3
.B prev
.PP
Switch ta tha window wit tha next lower number.
This command can be used repeatedly ta cycle all up in tha list of windows.
.sp
.ne 3
.B printcmd
.RI [ cmd ]
.PP
If
.I cmd
is not a empty string, 
.I screen 
will not use tha terminal capabilities
\*Qpo/pf\*U if it detects a ansi print sequence
.BR "ESC [ 5 i" ,
but pipe tha output into
.IR cmd .
This should normally be a cold-ass lil command like \*Qlpr\*U or
\*Q'cat > /tmp/scrprint'\*U.
.B printcmd
without a cold-ass lil command displays tha current setting.
Da ansi sequence
.B "ESC \e"
endz printin n' closes tha pipe.
.br
Warning: Be careful wit dis command hommie! If other user have write
access ta yo' terminal, they is ghon be able ta fire off print commands.
.sp
.ne 3
.BR process " [" \fIkey ]
.PP
Stuff tha contentz of tha specified regista tha fuck into 
.IR screen 's
input queue. If no argument is given yo ass is prompted fo' a
regista name. Da text is parsed as if it had been typed up in from tha user's
keyboard. Y'all KNOW dat shit, muthafucka! This command can be used ta bind multiple actions ta a single key.
.sp
.ne 3
.B quit
.PP
Bust a cap up in all windows n' terminate
.IR screen .
Note dat on VT100-style terminals tha keys C-4 n' C-\e is identical.
This make tha default bindings dangerous:
Be careful not ta type C-a C-4 when selectin window no. 4.
Use tha empty bind command (as up in \*Qbind '^\e'\*U) ta remove a key binding.
.sp
.ne 3
.B readbuf
.RB [ -e
.IR encodin ]
.RI [ filename ]
.PP
Readz tha contentz of tha specified file tha fuck into tha paste buffer.
Yo ass can tell screen tha encodin of tha file via tha \fB-e\fP option.
If no file is specified, tha screen-exchange filename is used.
See also \*Qbufferfile\*U command.
.sp
.ne 3
.B readreg 
.RB [ -e
.IR encodin ]
.RI [ regista " [" filename ]]
.PP
Do one of two thangs, dependent on number of arguments: wit zero or one
arguments it it duplicates tha paste buffer contents tha fuck into tha regista specified
or entered all up in tha prompt. With two arguments it readz tha contentz of tha named 
file tha fuck into tha register, just as \fIreadbuf\fP readz tha screen-exchange file
into tha paste buffer.
Yo ass can tell screen tha encodin of tha file via tha \fB-e\fP option.
Da followin example will paste tha systemz password file tha fuck into 
the 
.I screen 
window (usin regista p, where a cold-ass lil copy remains):
.PP
.nf
	C-a : readreg p /etc/passwd
	C-a : paste p
.fi
.sp
.ne 3
.B redisplay
.PP
Redisplay tha current window. Needed ta git a gangbangin' full redisplay when in
partial redraw mode.
.sp
.ne 3
.B register
.RB [ -e
.IR encodin ]
.I "key string"
.PP
Save tha specified \fIstring\fP ta tha regista \fIkey\fP.
Da encodin of tha strang can be specified via tha \fB-e\fP option.
See also tha \*Qpaste\*U command.
.sp
.ne 3
.B "remove"
.PP
Bust a cap up in tha current region. I aint talkin' bout chicken n' gravy biatch. This be a no-op if there is only one region.
.sp
.ne 3
.B "removebuf"
.PP
Unlinks tha screen-exchange file used by tha commandz \*Qwritebuf\*U n' 
\*Qreadbuf\*U. 
.sp
.ne 3
.B "rendizzle bell" | monitor | silence | so
.RB "\fIattr\fR " [ \fIcolor ]
.PP
Change tha way
.I screen
rendaz tha titlez of windows dat have monitor or bell flags set up in caption or hardstatus or windowlist. Right back up in yo muthafuckin ass. See tha \*QSTRING ESCAPES\*U chapta fo' tha syntax of tha modifiers.
Da default fo' monitor is currently \*Q=b \*U (bold, actizzle colors), fo' bell \*Q=ub \*U (underline, bold n' actizzle colors), n' \*Q=u \*U fo' silence.
.sp
.ne 3
.B "reset"
.PP 
Reset tha virtual terminal ta its \*Qpower-on\*U joints, n' you can put dat on yo' toast. Useful when strange
settings (like scroll regions or graphics characta set) is left over from
an application.
.sp
.ne 3
.B "resize"
.PP 
Resize tha current region. I aint talkin' bout chicken n' gravy biatch. Da space is ghon be removed from or added to
the region below or if there be a not enough space from tha region above.
.IP
resize +N	increase current region height by N
.IP
resize -N	decrease current region height by N
.IP
resize  N	set current region height ta N
.IP
resize  =	make all windows equally high
.IP
resize  max	maximize current region height
.IP
resize  min	minimize current region height
.PP
.sp
.ne 3
.B "screen \fP[\fI-opts\fP] [\fIn\fP] [\fIcmd\fP [\fIargs\fP]|\fB//group\fP]"
.PP
Establish a freshly smoked up window.
Da flow-control options (\fB\-f\fP, \fB\-fn\fP n' \fB\-fa\fP),
title (a.\|k.\|a.) option (\fB\-t\fP), login options (\fB-l\fP n' \fB-ln\fP)
, terminal type option (\fB-T\fP <term>), tha all-capability-flag (\fB-a\fP)
and scrollback option (\fB-h\fP <num>) may be specified wit each command. Y'all KNOW dat shit, muthafucka! 
Da option (\fB-M\fP) turns monitorin on fo' dis window.
Da option (\fB-L\fP) turns output loggin on fo' dis window.
If a optionizzle number \fIn\fP up in tha range 0..MAXWIN-1 is given,
the window number \fIn\fP be assigned ta tha newly pimped window
(or, if dis number be already in-use, tha next available number).
If a cold-ass lil command is specified afta \*Qscreen\*U, dis command (with tha given
arguments) is started up in tha window; otherwise, a gangbangin' finger-lickin' dirty-ass shell is pimped.
If \fB//group\fP is supplied, a cold-ass lil container-type window is pimped in
which other windows may be pimped inside dat shit. 

Thus, if yo' \*Q.screenrc\*U gotz nuff tha lines
.sp
.nf
	# example fo' .screenrc:
	screen 1
	screen -fn -t foobar -L 2 telnet foobar
.fi
.sp
.I screen
creates a gangbangin' finger-lickin' dirty-ass shell window (in window #1) n' a window wit a TELNET connection
to tha machine foobar (with no flow-control rockin tha title \*Qfoobar\*U
in window #2) n' will write a logfile (\*Qscreenlog.2\*U) of tha telnet 
session.
Note, dat unlike previous versions of
.I screen
no additionizzle default window is pimped when \*Qscreen\*U commandz is 
included up in yo' \*Q.screenrc\*U file. When tha initialization is completed,
.I screen
switches ta tha last window specified up in yo' .screenrc file or, if none,
opens a thugged-out default window #0.
.br
Screen has built up in some functionalitizzle of \*Qcu\*U n' \*Qtelnet\*U.
See also chapta \*QWINDOW TYPES\*U.
.sp
.ne 3
.B "scrollback \fP\fInum\fP"
.PP
Set tha size of tha scrollback buffer fo' tha current windows ta \fInum\fP 
lines. Da default scrollback is 100 lines.
See also tha \*Qdefscrollback\*U command n' use \*Qinfo\*U ta view the
current setting. To access n' use tha contents up in tha scrollback buffer,
use tha \*Qcopy\*U command.
.sp
.ne 3
.BR "select " [ \fIWindowID ]
.PP
Switch ta tha window identified by \fIWindowID\fP.
This can be a prefix of a window title (alphanumeric window name) or a
window number.
Da parameta is optionizzle n' if omitted, you git prompted fo' a identifier n' shit. 
When a freshly smoked up window is established, tha straight-up original gangsta available number
is assigned ta dis window.
Thus, tha straight-up original gangsta window can be activated by \*Qselect 0\*U.
Da number of windows is limited at compile-time by tha MAXWIN
configuration parameta (which defaults ta 40).
There is two special WindowIDs, \*Q-\*U selects the
internal blank window n' \*Q.\*U selects tha current window. The
latta is useful if used wit screenz \*Q-X\*U option.
.sp
.ne
.BR "sessionname " [ \fIname ]
.PP
Rename tha current session. I aint talkin' bout chicken n' gravy biatch. Note, dat fo' \*Qscreen -list\*U the
name shows up wit tha process-id prepended. Y'all KNOW dat shit, muthafucka! If tha argument \*Qname\*U
is omitted, tha name of dis session is displayed. Y'all KNOW dat shit, muthafucka! Caution: Da $STY 
environment variablez will still reflect tha oldschool name up in pre-existing
shells. This may result up in mad drama. Use of dis command is generally
discouraged. Y'all KNOW dat shit, muthafucka! Use tha \*Q-S\*U command-line option if you want to
name a freshly smoked up session.
Da default is constructed from tha tty n' host names.
.sp
.ne 3
.B "setenv " 
.RI [ var " [" strang ]]
.PP
Set tha environment variable \fIvar\fP ta value \fIstring\fP.
If only \fIvar\fP is specified, tha user is ghon be prompted ta enta a value.
If no parametas is specified, tha user is ghon be prompted fo' both variable
and value. Da environment is inherited by all subsequently forked shells.
.sp
.ne 3
.BR "setsid " [ on | off ]
.PP
Normally screen uses different sessions n' process crews for
the windows. If setsid is turned \fIoff\fP, dis aint done
anymore n' all windows is ghon be up in tha same process crew as the
screen backend process. This also breaks thang-control, so be careful.
Da default is \fIon\fP, of course. This command is probably useful
only up in rare circumstances.
.sp
.ne 3
.B "shell \fIcommand\fP"
.PP
Set tha command ta be used ta create a freshly smoked up shell.
This overrides tha value of tha environment variable $SHELL.
This is useful if you'd like ta run a tty-enhancer which is expectin to
execute tha program specified up in $SHELL. If tha command begins with
a '-' character, tha shell is ghon be started as a login-shell.
.sp
.ne 3
.B "shelltitle \fItitle\fP"
.PP
Set tha title fo' all shells pimped durin startup or by
the C-A C-c command.
For details bout what tha fuck a title is, peep tha rap
entitled \*QTITLES (namin windows)\*U.
.sp
.ne 3
.BR "silence " [ on | off "|\fIsec\fP]"
.PP
Togglez silence monitorin of windows.
When silence is turned on n' a affected window is switched tha fuck into the
background, yo big-ass booty is ghon receive tha silence notification message up in the
status line afta a specified period of inactivitizzle (silence). Da default
timeout can be chizzled wit tha `silencewait' command or by specifyin a 
number of secondz instead of `on' or `off'.
Silence is initially off fo' all windows.
.sp
.ne 3
.BI "silencewait " sec
.PP
Define tha time dat all windows monitored fo' silence should wait before
displayin a message. Default 30 seconds.
.sp
.ne
.B "sleep \fP\fInum\fP"
.PP
This command will pause tha execution of a .screenrc file fo' \fInum\fP seconds.
Keyboard activitizzle will end tha chill.
It may be used ta give playas a cold-ass lil chizzle ta read tha lyrics output by \*Qecho\*U.
.sp
.ne 3
.B "slowpaste \fImsec\fP"
.PP
Define tha speed at which text is banged tha fuck into tha current window by tha 
paste ("C-a ]") command. Y'all KNOW dat shit, muthafucka! 
If tha slowpaste value is nonzero text is freestyled characta by character.
.I screen
will cook up a pause of \fImsec\fP millisecondz afta each single characta write 
to allow tha application ta process its input. Only use slowpaste if yo' 
underlyin system exposes flow control problems while pastin big-ass amountz of 
text. 
.sp
.ne 3
.BI "source " file
.PP
Read n' execute commandz from file \fIfile\fP. Right back up in yo muthafuckin ass. Source commandz may
be nested ta a maximum recursion level of ten. I aint talkin' bout chicken n' gravy biatch. If file aint an
absolute path n' screen be already processin a source command, the
parent directory of tha hustlin source command file is used ta search
for tha freshly smoked up command file before screenz current directory.

Note dat termcap/terminfo/termcapinfo commandz only work at
startup n' reattach time, so they must be reached via the
default screenrc filez ta have a effect.
.sp
.ne 3
.B sorendition
.RB [ "\fIattr\fR " [ \fIcolor ]]
.PP
This command is deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Right back up in yo muthafuckin ass. See "rendizzle so" instead.
.sp
.ne 3
.B split
.RB [ -v ]
.PP
Split tha current region tha fuck into two freshly smoked up ones fo' realz. All regions on the
display is resized ta make room fo' tha freshly smoked up region. I aint talkin' bout chicken n' gravy biatch. Da blank
window is displayed on tha freshly smoked up region. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Splits is made horizontally
unless -v is used. Y'all KNOW dat shit, muthafucka! Use tha \*Qremove\*U or tha \*Qonly\*U command
to delete regions. Use \*Qfocus\*U ta toggle between regions.
.sp
.ne 3
.B "startup_message on\fP|\fBoff"
.PP
Select whether you wanna peep tha copyright notice durin startup.
Default is `on', as you probably noticed.
.sp
.ne 3
.B shiznit 
.RB  [ "\fIstring\fR" ]
.PP
Stuff tha string
.I string
in tha input buffer of tha current window.
This is like tha \*Qpaste\*U command but wit much less overhead.
Without a parameter, screen will prompt fo' a strang ta stuff.
Yo ass cannot paste
pimpin' buffers wit tha \*Qstuff\*U command. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is most useful fo' key
bindings. Right back up in yo muthafuckin ass. See also \*Qbindkey\*U.
.sp
.ne 3
.B su
.RI [ username " [" password
.RI [ password2 ]]]
.PP
Substitute tha user of a gangbangin' finger-lickin' display. Da command prompts fo' all parametas that
are omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If passwordz is specified as parameters, they gotta be
specified un-crypted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da first password is matched against tha systems
passwd database, tha second password is matched against tha 
.I screen
password as set wit tha commandz \*Qacladd\*U or \*Qpassword\*U.
\*QSu\*U may be useful fo' tha 
.I screen
administrator ta test multiuser setups.
.\"						XXX removed up in 3.8.0 XXX
.\" but it is mainly used implicitly
.\" by tha \*Qconnect\*U command ta identify playas dat access a remote session.
When tha identification fails, tha user has access ta tha commandz available
for user
.BR no muthafucka .
These is \*Qdetach\*U, \*Qlicense\*U, \*Qversion\*U, \*Qhelp\*U and
\*Qdisplays\*U.
.sp
.ne 3
.B "suspend"
.PP
Suspend
.IR screen .
Da windows is up in tha `detached' state, while 
.I screen
is suspended. Y'all KNOW dat shit, muthafucka! This feature relies on tha shell bein able ta do thang control.
.sp
.ne 3
.B "term \fIterm\fP"
.PP
In each windowz environment
.I screen
opens, tha $TERM variable is set ta \*Qscreen\*U by default. 
But when no description fo' \*Qscreen\*U is installed up in tha local termcap
or terminfo data base, you set $TERM ta \- say \-
\*Qvt100\*U. This won't do much harm, as 
.I screen
is VT100/ANSI compatible.
Da use of tha \*Qterm\*U command is discouraged fo' non-default purpose.
That is, one may wanna specify special $TERM settings (e.g. vt100) fo' the
next \*Qscreen rlogin othermachine\*U command. Y'all KNOW dat shit, muthafucka! Use tha command \*Qscreen -T vt100
rlogin othermachine\*U rather than settin n' resettin tha default.
.sp
.ne 3
.BI termcap " term terminal-tweaks"
.RI [ window-tweaks ]
.br
.BI terminfo " term terminal-tweaks"
.RI [ window-tweaks ]
.br
.BI termcapinfo " term terminal-tweaks"
.RI [ window-tweaks ]
.PP
Use dis command ta modify yo' terminalz termcap entry without going
all up in all tha hasslez involved up in bustin a cold-ass lil custom termcap entry.
Plus, you can optionally customize tha termcap generated fo' tha windows.
Yo ass gotta place these commandz up in one of tha screenrc startup files, as
they is meaningless once tha terminal emulator is booted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  
.br
If yo' system works uses tha terminfo database rather than termcap, 
.I screen 
will KNOW tha `terminfo' command, which has tha same ol' dirty effects as the
`termcap' command. Y'all KNOW dat shit, muthafucka!  Two separate commandz is provided, as there be subtle
syntactic differences, e.g. when parameta interpolation (usin `%') is
required. Y'all KNOW dat shit, muthafucka! Note dat termcap namez of tha capabilitizzles gotta be used
with tha `terminfo' command. Y'all KNOW dat shit, muthafucka! 
.br
In nuff cases, where tha arguments is valid up in both terminfo n' termcap
syntax, you can use tha command `termcapinfo', which is just a gangbangin' finger-lickin' dirty-ass shorthand
for a pair of `termcap' n' `terminfo' commandz wit identical arguments.
.PP
Da first argument specifies which terminal(s) should be affected by this
definition.
Yo ass can specify multiple terminal names by separatin dem wit `|'s.
Use `*' ta match all terminals n' `vt*' ta match all terminals dat begin
with \*Qvt\*U.
.PP
Each \fItweak\fP argument gotz nuff one or mo' termcap defines (separated
by `:'s) ta be banged all up in tha start of tha appropriate termcap entry,
enhancin it or overridin existin joints.
Da first tweak modifies yo' terminalz termcap, n' gotz nuff definitions
that yo' terminal uses ta big-ass up certain functions.
Specify a null strang ta leave dis unchanged (e.\|g. '').
Da second (optional) tweak modifies all tha window termcaps, n' should
contain definitions that
.I screen
understandz (see tha \*QVIRTUAL TERMINAL\*U
section).
.PP
Some examples:
.IP
termcap xterm*  LP:hs@
.PP
Informs
.I screen
that all terminals dat begin wit `xterm' have firm auto-margins that
allow tha last posizzle on tha screen ta be updated (LP) yo, but they don't
really gotz a status line (no 'hs' \- append `@' ta turn entries off).
Note dat we assume `LP' fo' all terminal names dat start wit \*Qvt\*U,
but only if you don't specify a termcap command fo' dat terminal.
.IP
termcap vt*  LP
.br
termcap vt102|vt220  Z0=\eE[?3h:Z1=\eE[?3l
.PP
Specifies tha firm-margined `LP' capabilitizzle fo' all terminals dat begin with
`vt', n' tha second line will also add tha escape-sequences ta switch
into (Z0) n' back outta (Z1) 132-character-per-line mode if dis is
a VT102 or VT220.
(Yo ass must specify Z0 n' Z1 up in yo' termcap ta use tha width-changing
commands.)
.IP
termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
.PP
This leaves yo' vt100 termcap ridin' solo n' addz tha function key labels to
each windowz termcap entry.
.IP
termcap h19|z19  am@:im=\eE@:ei=\eEO  dc=\eE[P
.PP
Takes a h19 or z19 termcap n' turns off auto-margins (am@) n' enablez the
insert mode (im) n' end-insert (ei) capabilitizzles (the `@' up in tha `im'
strin be afta tha `=', so it is part of tha string).
Havin tha `im' n' `ei' definitions put tha fuck into yo' terminalz termcap will
cause
.I screen
to automatically advertise tha character-insert capabilitizzle in
each windowz termcap.
Each window will also git tha delete-characta capabilitizzle (dc) added ta its
termcap, which
.I screen
will translate tha fuck into a line-update fo' tha terminal
(we're pretendin it don't support characta deletion).
.PP
If you wanna straight-up specify each windowz termcap entry, you should
instead set tha $SCREENCAP variable prior ta hustlin
.IR screen .
See tha rap on tha \*QVIRTUAL TERMINAL\*U up in dis manual, n' tha termcap(5)
man page fo' mo' shiznit on termcap definitions.
.sp
.ne 3
.B time
.RI [ strang ]
.PP
Uses tha message line ta display tha time of day, tha host name, n' tha load
averages over 1, 5, n' 15 minutes (if dis be available on yo' system).
For window specific shiznit, use \*Qinfo\*U.

If a strang is specified, it chizzlez tha format of tha time report like it is
busted lyrics bout up in tha \*QSTRING ESCAPES\*U chapter n' shit. Right back up in yo muthafuckin ass. Screen uses a thugged-out default of
"%c:%s %M %d %H%? %l%?".
.sp
.ne 3
.BR "title " [ \fIwindowtitle ]
.PP
Set tha name of tha current window ta \fIwindowtitle\fP. If no name is 
specified,
.I screen
prompts fo' one. This command was known as `aka' up in previous
releases.
.sp
.ne 3
.BI "unbindall "
.PP
Unbind all tha bindings. This can be useful when
screen is used solely fo' its detachin abilities, like fuckin when
lettin a cold-ass lil console application run as a thugged-out daemon. I aint talkin' bout chicken n' gravy biatch. If, fo' some reason,
it is necessary ta bind commandz afta this, use 'screen -X'.
.sp
.ne 3
.BI "unsetenv " var
.PP
Unset a environment variable.
.sp
.ne 3
.B utf8
.RB [ on | off
.RB [ on | off ]]
.PP
Change tha encodin used up in tha current window. If utf8 is enabled, the
strings busted ta tha window is ghon be UTF-8 encoded n' vice versa. Omittin the
parameta togglez tha setting. If a second parameta is given, tha display's
encodin be also chizzled (this should rather be done wit screenz \*Q-U\*U
option).
See also \*Qdefutf8\*U, which chizzlez tha default settin of a new
window.
.sp
.ne 3
.B vbell 
.RB [ on | off ]
.PP
Sets tha visual bell settin fo' dis window. Omittin tha parameter
togglez tha setting. If vbell is switched on yo, but yo' terminal do not 
support a visual bell, a `vbell-message' is displayed up in tha status line when
the bell characta (^G) is received.
Visual bell support of a terminal is defined by tha termcap variable `vb' 
(terminfo: 'flash'). 
.br
Per default, vbell is off, thus tha audible bell is used. Y'all KNOW dat shit, muthafucka! 
See also `bell_msg'.
.sp
.ne 3
.B vbell_msg
.RI [ message ]
.PP
Sets tha visual bell message. \fImessage\fP is printed ta tha status line if
the window receives a funky-ass bell characta (^G), vbell is set ta \*Qon\*U yo, but tha 
terminal do not support a visual bell.
Da default message is \*QWuff, Wuff!!\*U.
Without a parameter, tha current message is shown.
.sp
.ne 3
.BI "vbellwait " sec
.PP
Define a thugged-out delay up in secondz afta each display of 
.IR screen 's
visual bell message. Da default is 1 second.
.sp
.ne 3
.B verbose
.RB [ on | off ]
.PP
If verbose is switched on, tha command name is echoed, whenever a window
is pimped (or resurrected from zombie state). Default is off.
Without a parameter, tha current settin is shown.
.sp
.ne 3
.B version
.PP
Print tha current version n' tha compile date up in tha status line.
.sp
.ne 3
.BI "wall " "message"
.PP
Write a message ta all displays. Da message will step tha fuck up in tha terminal's
status line.
.sp
.ne 3
.B width
.RB [ -w | -d ]
.RI [ cols " [" lines ]]
.PP
Toggle tha window width between 80 n' 132 columns or set it ta \fIcols\fP 
columns if a argument is specified. Y'all KNOW dat shit, muthafucka! 
This requires a cold-ass lil capable terminal n' tha termcap entries \*QZ0\*U n' \*QZ1\*U.
See tha \*Qtermcap\*U command fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. Yo ass can also specify
a freshly smoked up height if you wanna chizzle both joints.
The
.B -w
option  drops some lyrics ta screen ta leave tha display size unchanged n' just set
the window size,
.B -d
vice versa.
.sp
.ne 3
.B windowlist
.RB [ -b ]
.RB [ -m ]
.RB [ -g ]
.br
.B windowlist
.B string
.RI [ strang ]
.br
.B windowlist
.B title
.RI [ title ]
.PP
Display all windows up in a table fo' visual window selection.
If screen was up in a window group, screen will
back outta tha crew n' then display tha windows up in dat group.
If tha 
.B -b
option is given, screen will switch ta tha blank window before
presentin tha list, so dat tha current window be also selectable.
The
.B -m
option chizzlez tha order of tha windows, instead of sortin by
window numbers screen uses its internal most-recently-used list.
The
.B -g
option will show tha windows inside any crews up in dat level
and downwards.

Da followin keys is used ta navigate up in \*Qwindowlist\*U:
.br
.in +4n
.ti -2n
\fBk\fP, \fBC-p\fP, or \fBup\fP Move up one line.
.br
.ti -2n
\fBj\fP, \fBC-n\fP, or \fBdown\fP Move down one line.
.br
.ti -2n
\fBC-g\fP or \fBescape\fP Exit windowlist.
.br
.ti -2n
\fBC-a\fP or \fBhome\fP Move ta tha straight-up original gangsta line.
.br
.ti -2n
\fBC-e\fP or \fBend\fP Move ta tha last line.
.br
.ti -2n
\fBC-u\fP or \fBC-d\fP Move one half page up or down.
.br
.ti -2n
\fBC-b\fP or \fBC-f\fP Move one full page up or down.
.br
.ti -2n
\fB0..9\fP Usin tha number keys, move ta tha selected line.
.br
.ti -2n
\fBmouseclick\fP Move ta tha selected line fo' realz. Available when
\*Qmousetrack\*U is set ta \*Qon\*U
.br
.ti -2n
\fB/\fP Search.
.br
.ti -2n
\fBn\fP Repeat search up in tha forward direction.
.br
.ti -2n
\fBN\fP Repeat search up in tha backward direction.
.br
.ti -2n
\fBm\fP Toggle MRU.
.br
.ti -2n
\fBg\fP Toggle crew nesting.
.br
.ti -2n
\fBa\fP All window view.
.br
.ti -2n
\fBC-h\fP or backspace Back up tha group.
.br
.ti -2n
\fB,\fP Switch numbers wit tha previous window.
.br
.ti -2n
\fB.\fP Switch numbers wit tha next window.
.br
.ti -2n
\fBK\fP Bust a cap up in dat window.
.br
.ti -2n
\fBspace\fP or \fBenter\fP Select dat window.
.br
.in -4n

Da table format can be chizzled wit tha \fBstring\fP and
\fBtitle\fP option, tha title is displayed as table heading, while
the lines is made by rockin tha strang setting. Da default
settin is \*QNum Name%=Flags\*U fo' tha title n' \*Q%3n %t%=%f\*U
for tha lines.
See tha \*QSTRING ESCAPES\*U chapta fo' mo' codes (e.g. color
settings).

\*QWindowlist\*U needz a region size of at least 10 charactas wide
and 6 charactas high up in order ta display.
.sp
.ne 3
.B windows
.PP
Uses tha message line ta display a list of all tha windows.
Each window is listed by number wit tha name of process dat has been
started up in tha window (or its title);
the current window is marked wit a `*';
the previous window is marked wit a `-';
all tha windows dat is \*Qlogged in\*U is marked wit a `$';
a background window dat has received a funky-ass bell is marked wit a `!';
a background window dat is bein monitored n' has had activitizzle occur
is marked wit a `@';
a window which has output loggin turned on is marked wit `(L)'; 
windows occupied by other playas is marked wit `&';
windows up in tha zombie state is marked wit `Z'.
If dis list is too long ta fit on tha terminalz status line only the
portion round tha current window is displayed.
.sp
.ne 3
.BR "wrap " [ on | off ]
.PP
Sets tha line-wrap settin fo' tha current window.
When line-wrap is on, tha second consecutizzle printable characta output at
the last column of a line will wrap ta tha start of tha followin line.
As a added feature, backspace (^H) will also wrap all up in tha left margin
to tha previous line.
Default is `on'. Without any options, tha state of wrap is toggled.
.sp
.ne 3
.B writebuf
.RB [ -e
.IR encodin ]
.RI [ filename ]
.PP
Writes tha contentz of tha paste buffer ta tha specified file, or tha hood accessible screen-exchange
file if no filename is given. I aint talkin' bout chicken n' gravy biatch. This is thought of as a primitizzle meanz of communication between
.I screen
users on tha same host. If a encodin is specified tha paste buffer
is recoded on tha fly ta match tha encoding.
Da filename can be set wit tha \fIbufferfile\fP
command n' defaults ta \*Q/tmp/screen-exchange\*U.
.sp
.ne 3
.BR "writelock " [ on | "off\fR|\fBauto\fR]"
.PP
In addizzle ta access control lists, not all playas may be able ta write to
the same window at once. Per default, writelock is up in `auto' mode and
grants exclusive input permission ta tha user whoz ass is tha straight-up original gangsta ta switch
to tha particular window. When he leaves tha window, other playas may obtain
the writelock (automatically). Da writelock of tha current window is disabled
by tha command \*Qwritelock off\*U. If tha user thangs tha command 
\*Qwritelock on\*U he keeps tha exclusive write permission while switching
to other windows.
.sp
.ne 3
.B xoff
.br
.B xon
.PP
Insert a CTRL-s / CTRL-q characta ta tha stdin queue of the
current window.
.sp
.ne 3
.B zmodem
.RB [ off\fR|\fPauto\fR|\fPcatch\fR|\fPpass ]
.br
.B "zmodem sendcmd"
.RI [ strang ]
.br
.B "zmodem recvcmd"
.RI [ strang ]
.PP
Define zmodem support fo' screen. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Screen understandz two different
modes when it detects a zmodem request: \*Qpass\*U n' \*Qcatch\*U.
If tha mode is set ta \*Qpass\*U, screen will relay all data
to tha attacher until tha end of tha transmission is reached.
In \*Qcatch\*U mode screen acts as a zmodem endpoint n' starts
the correspondin rz/ss commands. If tha mode is set ta \*Qauto\*U,
screen will use \*Qcatch\*U if tha window be a tty (e.g. a serial line),
otherwise it will use \*Qpass\*U.
.br
Yo ass can define tha templates screen uses up in \*Qcatch\*U mode
via tha second n' tha third form.
.br
Note also dat dis be a experimenstrual feature.
.sp
.ne 3
.BR "zombie " [\fIkeys\fP [ onerror ] ]
.br
.BR "defzombie " [\fIkeys\fP]
.PP
Per default
.I screen 
windows is removed from tha window list as soon as
the windows process (e.g. shell) exits, n' you can put dat on yo' toast. When a strang of two keys is 
specified ta tha zombie command, `dead' windows will remain up in tha list.
Da \fBkill\fP command may be used ta remove such a window. Pressin tha 
first key up in tha dead window has tha same ol' dirty effect. When pressin tha second 
key, 
.I screen 
will attempt ta resurrect tha window. Da process dat was 
initially hustlin up in tha window is ghon be launched again. I aint talkin' bout chicken n' gravy biatch. Callin \fBzombie\fP
without parametas will clear tha zombie setting, thus makin windows disappear 
when they process exits.

As tha zombie-settin is manipulated globally fo' all windows, dis command 
should only be called \fBdefzombie\fP. Until we need dis as a per window 
setting, tha commandz \fBzombie\fP n' \fBdefzombie\fP is synonymous.

Optionally you can put tha word \*Qonerror\*U afta tha keys. This will cause screen
to monitor exit statuz of tha process hustlin up in tha window. If it exits normally ('0'), 
the window disappears fo' realz. Any other exit value causes tha window ta become a zombie.

.SH "THE MESSAGE LINE"
.I Screen
displays shiznital lyrics n' other diagnostics up in a \fImessage line\fP.
While dis line is distributed ta step tha fuck up all up in tha bottom of tha screen,
it can be defined ta step tha fuck up all up in tha top of tha screen durin compilation.
If yo' terminal has a status line defined up in its termcap,
.I screen
will use dis fo' displayin its lyrics, otherwise a line of the
current screen will
be temporarily overwritten n' output is ghon be momentarily interrupted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. The
message line be automatically removed afta all dem secondz delay yo, but it
can also be removed early (on terminals without a status line) by beginning
to type.
.PP
Da message line facilitizzle can be used by a application hustlin in
the current window by meanz of tha ANSI \fIPrivacy message\fP
control sequence.
For instance, from within tha shell, try suttin' like:
.IP
echo '<esc>^Wuz crackalackin' ghetto from window '$WINDOW'<esc>\e\e'
.PP
where '<esc>' be a \fIescape\fP, '^' be a literal up-arrow,
and '\e\e' turns tha fuck into a single backslash.

.SH "WINDOW TYPES"
Screen serves up three different window types. New windows is pimped wit 
.IR screen 's
.B screen
command (see also tha entry up in chapta \*QCUSTOMIZATION\*U). Da first
parameta ta tha 
.B screen
command defines which type of window is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da different window types are
all special casez of tha aiiight type. They done been added up in order
to allow 
.I screen 
to be used efficiently as a cold-ass lil console multiplexer wit 100 or mo' windows.

.IP \(bu 3
Da aiiight window gotz nuff a gangbangin' finger-lickin' dirty-ass shell (default, if no parameta is given) or any
other system command dat could be executed from a gangbangin' finger-lickin' dirty-ass shell (e.g.  
.BR slogin ,
etc...) 

.IP \(bu
If a tty (characta special device) name (e.g. \*Q/dev/ttya\*U)
is specified as tha straight-up original gangsta parameter, then tha window is directly connected to
this device. 
This window type is similar ta \*Qscreen cu -l /dev/ttya\*U.
Read n' write access is required on tha thang node, a exclusive open is
attempted on tha node ta mark tha connection line as busy.
An optionizzle parameta be allowed consistin of a cold-ass lil comma separated list of flags
in tha notation used by stty(1):
.RS
.IP <baud_rate>		
Usually 300, 1200, 9600 or 19200. This affects transmission as well as receive speed.
.IP "cs8 or cs7"
Specify tha transmission of eight (or seven) bits per byte.
.IP "ixon or -ixon"
Enablez (or disables) software flow-control (CTRL-S/CTRL-Q) fo' bustin  data.
.IP "ixoff or -ixoff"
Enablez (or disables) software flow-control fo' receivin data.
.IP "istrip or -istrip"
Clear (or keep) tha eight bit up in each received byte.
.PP
Yo ass may wanna specify as nuff of these options as applicable. Unspecified
options cause tha terminal driver ta make up tha parameta jointz of the
connection. I aint talkin' bout chicken n' gravy biatch.  These joints is system dependent n' may be up in defaults or joints
saved from a previous connection.
.PP
For tty windows, tha 
.B info
command shows a shitload of tha modem control lines
in tha status line. These may include `RTS', `CTS', 'DTR', `DSR', `CD' n' more.
This dependz on tha available ioctl()z n' system header filez as well as the
on tha physical capabilitizzlez of tha serial board. Y'all KNOW dat shit, muthafucka! 
Signals dat is logical low (inactive) have they name preceded by
an exclamation mark (!), otherwise tha signal is logical high (active).
Signals not supported by tha hardware but available ta tha ioctl() intercourse
are probably shown low. 
.PP
When tha CLOCAL status bit is true, tha whole set of modem signals is placed 
inside curly braces ({ n' }).
When tha CRTSCTS or TIOCSOFTCAR bit is set, tha signals `CTS' or `CD' 
are shown up in parenthesis, respectively. 
.PP
For tty windows, tha command
.B break
causes tha Data transmission line (TxD) ta go low fo' a specified period of
time. This is sposed ta fuckin be interpreted as break signal on tha other side.
No data is busted n' no modem control line is chizzled when a 
.B break
is issued.
.RE

.IP \(bu
If tha straight-up original gangsta parameta is \*Q//telnet\*U, tha second parameta is sposed ta fuckin
be a host name, n' a optionizzle third parameta may specify a TCP port number
(default decimal 23).  Screen will connect ta a server listenin on tha remote
host n' use tha telnet protocol ta rap wit dat server.
.br
.br
For telnet windows, tha command
.B info
shows details bout tha connection up in square brackets ([ n' ]) all up in tha end of
the status line. 
.RS
.IP b
BINARY. Da connection is up in binary mode.
.IP e
ECHO. Local echo is disabled.
.IP c
SGA. Da connection is up in `characta mode' (default: `line mode').
.IP t
TTYPE. Da terminal type has been axed by tha remote host.
Screen sendz tha name \*Qscreen\*U unless instructed otherwise (see also
the command `term').
.IP w
NAWS. Da remote joint is notified bout window size chizzles.
.IP f
LFLOW. Da remote host will bust flow control shiznit.
(Ignored all up in tha moment.)
.PP
Additionizzle flags fo' debuggin is x, t n' n (XDISPLOC, TSPEED and
NEWENV).
.PP
For telnet windows, tha command
.B break
sendz tha telnet code IAC BREAK (decimal 243) ta tha remote host.


This window type is only available if
.I screen
was compiled wit tha BUILTIN_TELNET option defined.
.RE


.SH "STRING ESCAPES"
Screen serves up a escape mechanizzle ta bang shiznit like the
current time tha fuck into lyrics or file names. Da escape character
is '%' wit one exception: inside of a windowz hardstatus '^%' ('^E')
is used instead.

Here is tha full list of supported escapes:
.IP %
the escape characta itself
.IP a
either 'am' or 'pm'
.IP A
either 'AM' or 'PM'
.IP c
current time HH:MM up in 24h format
.IP C
current time HH:MM up in 12h format
.IP d
dizzle number
.IP D
weekdizzle name
.IP f
flagz of tha window, peep \*Qwindows\*U fo' meaningz of tha various flags
.IP F
sets %? ta legit if tha window has tha focus
.IP h
hardstatuz of tha window
.IP H
hostname of tha system
.IP l
current load of tha system
.IP m
month number
.IP M
month name
.IP n
window number
.IP P
sets %? ta legit if tha current region is up in copy/paste mode
.IP S
session name
.IP s
seconds
.IP t
window title
.IP u
all other playas on dis window
.IP w
all window numbers n' names. With '-' qualifier: up ta tha current
window; wit '+' qualifier: startin wit tha window afta tha current
one.
.IP W
all window numbers n' names except tha current one
.IP y
last two digitz of tha year number
.IP Y
full year number
.IP ?
the part ta tha next '%?' is displayed only if a '%' escape
inside tha part expandz ta a non-empty string
.IP :
else part of '%?'
.IP =
pad tha strang ta tha displayz width (like TeXz hfill). If a
number is specified, pad ta tha cementage of tha windowz width.
A '0' qualifier  drops some lyrics ta screen ta treat tha number as absolute position.
Yo ass can specify ta pad relatizzle ta tha last absolute pad position
by addin a '+' qualifier or ta pad relatizzle ta tha right margin
by rockin '-'. Da paddin truncates tha strang if tha specified
posizzle lies before tha current position. I aint talkin' bout chicken n' gravy biatch fo' realz. Add tha 'L' qualifier
to chizzle all dis bullshit.
.IP <
same as '%=' but just do truncation, do not fill wit spaces
.IP >
mark tha current text posizzle fo' tha next truncation. I aint talkin' bout chicken n' gravy biatch. When
screen need ta do truncation, it tries ta do it up in a way that
the marked posizzle gets moved ta tha specified cementage of
the output area. (Da area starts from tha last absolute pad
posizzle n' endz wit tha posizzle specified by tha truncation
operator.) Da 'L' qualifier  drops some lyrics ta screen ta mark tha truncated
parts wit '...'.
.IP {
attribute/color modifier strang terminated by tha next \*Q}\*U
.IP `
Substitute wit tha output of a 'backtick' command. Y'all KNOW dat shit, muthafucka! Da length
qualifier is misused ta identify one of tha commands.
.P
Da 'c' n' 'C' escape may be qualified wit a '0' ta make 
.I screen 
use zero instead of space as fill character n' shit. Da '0' qualifier
also make tha '=' escape use absolute positions. Da 'n' n' '='
escapes understand
a length qualifier (e.g. '%3n'), 'D' n' 'M' can be prefixed wit 'L'
to generate long names, 'w' n' 'W' also show tha window flags
if 'L' is given.
.PP
An attribute/color modifier is is used ta chizzle tha attributes or the
color settings. Its format
is \*Q[attribute modifier] [color description]\*U. Da attribute modifier
must be prefixed by a cold-ass lil chizzle type indicator if it can be trippin with
a color description. I aint talkin' bout chicken n' gravy biatch. Da followin chizzle types is known:
.IP +
add tha specified set ta tha current attributes
.IP -
remove tha set from tha current attributes
.IP !
invert tha set up in tha current attributes
.IP =
change tha current attributes ta tha specified set
.PP
Da attribute set can either be specified as a hexadecimal number or
a combination of tha followin letters:
.IP d
dim
.PD 0
.IP u
underline
.IP b
bold
.IP r
reverse
.IP s
standout
.IP B
blinking
.PD
.PP
Colors is coded either as a hexadecimal number or two lettas specifying
the desired background n' foreground color (in dat order). Da following
colors is known:
.IP k
black
.PD 0
.IP r
red
.IP g
green
.IP y
yellow
.IP b
blue
.IP m
magenta
.IP c
cyan
.IP w
white
.IP d
default color
.IP .
leave color unchanged
.PD
.PP
Da capitalized versionz of tha letta specify bright colors. Yo ass can also
use tha pseudo-color 'i' ta set just tha brightnizz n' leave tha color
unchanged.
.br
A one digit/letta color description is treated as foreground or
background color dependent on tha current attributes: if reverse mode is
set, tha background color is chizzled instead of tha foreground color.
If you don't like this, prefix tha color wit a \*Q.\*U. If you want
the same behavior fo' two-letta color descriptions, also prefix them
with a \*Q.\*U.
.br
As a special case, \*Q%{-}\*U restores tha attributes n' flavas that
were set before tha last chizzle was made (i.e., pops one level of the
color-change stack).
.PP
Examples:
.IP "\*QG\*U"
set color ta bright green
.IP "\*Q+b r\*U"
use bold red
.IP "\*Q= yd\*U"
clear all attributes, write up in default color on yellow background.
.IP "%-Lw%{= BW}%50>%n%f* %t%{-}%+Lw%<"
Da available windows centered all up in tha current window n' truncated to
the available width. Da current window is displayed white on blue.
This can be used wit \*Qhardstatus alwayslastline\*U.
.IP "%?%F%{.R.}%?%3n %t%? [%h]%?"
Da window number n' title n' tha windowz hardstatus, if one is set.
Also bust a red background if dis is tha actizzle focus. Useful for
\*Qcaption string\*U.
.SH "FLOW-CONTROL"
Each window has a gangbangin' flow-control settin dat determines how
.I screen
deals with
the XON n' XOFF charactas (and like tha interrupt character).
When flow-control is turned off,
.I screen
ignores tha XON n' XOFF characters,
which allows tha user ta bust dem ta tha current program by simply typing
them (useful fo' tha \fIemacs\fP editor, fo' instance).
Da trade-off is dat it will take longer fo' output from a \*Qnormal\*U
program ta pause up in response ta a XOFF.
With flow-control turned on, XON n' XOFF charactas is used ta immediately
pause tha output of tha current window.
Yo ass can still bust these charactas ta tha current program yo, but you must use
the appropriate two-character
.I screen
commandz (typically \*QC-a q\*U (xon)
and \*QC-a s\*U (xoff)).
Da xon/xoff commandz is also useful fo' typin C-s n' C-q past a terminal
that intercepts these characters.
.PP
Each window has a initial flow-control value set wit either the
.B \-f
option or tha \*Qdefflow\*U .screenrc command. Y'all KNOW dat shit, muthafucka! Per default tha windows
are set ta automatic flow-switching.
It can then be toggled between tha three states 'fixed on', 'fixed off'
and 'automatic' interactively wit tha \*Qflow\*U command bound ta "C-a f".
.PP
Da automatic flow-switchin mode deals with
flow control rockin tha TIOCPKT mode (like \*Qrlogin\*U do). If
the tty driver do not support TIOCPKT,
.I screen
tries ta smoke up
the right mode based on tha current settin of tha application
keypad \- when it is enabled, flow-control is turned off n' visa versa.
Of course, you can still manipulate flow-control manually when needed.
.PP
If you hustlin wit flow-control enabled n' find dat pressin the
interrupt key (usually C-c) do not interrupt tha display until another
6-8 lines have scrolled by, try hustlin
.I screen
with tha \*Qinterrupt\*U
option (add tha \*Qinterrupt\*U flag ta tha \*Qflow\*U command in
your .screenrc, or use the
.B \-i
command-line option).
This causes tha output that
.I screen
has accumulated from tha interrupted program ta be flushed.
One disadvantage is dat tha virtual terminalz memory gotz nuff the
non-flushed version of tha output, which up in rare cases can cause
minor inaccuracies up in tha output.
For example, if you switch screens n' return, or update tha screen
with \*QC-a l\*U you would peep tha version of tha output you would
have gotten without \*Qinterrupt\*U bein on.
Also, you might need ta turn off flow-control (or use auto-flow mode ta turn
it off automatically) when hustlin a program dat expects you ta type the
interrupt characta as input, as it is possible ta interrupt
the output of tha virtual terminal ta yo' physical terminal when flow-control
is enabled.
If dis happens, a simple refresh of tha screen wit \*QC-a l\*U will
restore dat shit.
Give each mode a try, n' use whichever mode you find mo' comfortable.


.SH "TITLES (namin windows)"
Yo ass can customize each windowz name up in tha window display (viewed wit the
\*Qwindows\*U command (C-a w)) by settin it wit one of
the title commands.
Normally tha name displayed is tha actual command name of tha program
created up in tha window.
But fuck dat shiznit yo, tha word on tha street is dat it is sometimes useful ta distinguish various programz of tha same
name or ta chizzle tha name on-the-fly ta reflect tha current state of
the window.
.PP
Da default name fo' all shell windows can be set wit tha \*Qshelltitle\*U
command up in tha .screenrc file, while all other windows is pimped with
a \*Qscreen\*U command n' thus can have they name set wit the
.B \-t
option.
Interactively, there is tha title-strin escape-sequence
(<esc>k\fIname\fP<esc>\e) n' tha \*Qtitle\*U command (C-a A).
Da forma can be output from a application ta control tha windowz name
under software control, n' tha latta will prompt fo' a name when typed.
Yo ass can also bind pre-defined names ta keys wit tha \*Qtitle\*U command
to set thangs quickly without prompting.
.PP
Finally,
.I screen
has a gangbangin' finger-lickin' dirty-ass shell-specific heuristic dat is enabled by settin tha windowz name
to \*Q\fIsearch|name\fP\*U n' arrangin ta git a null title escape-sequence
output as a part of yo' prompt.
Da \fIsearch\fP portion specifies a end-of-prompt search string, while
the \fIname\fP portion specifies tha default shell name fo' tha window.
If tha \fIname\fP endz up in a `:'
.I screen
will add what tha fuck it believes ta be tha current command hustlin up in tha window
to tha end of tha windowz shell name (e.\|g. \*Q\fIname:cmd\fP\*U).
Otherwise tha current command name supersedes tha shell name while it is
running.
.PP
Herez how tha fuck it works:  you must modify yo' shell prompt ta output a null
title-escape-sequence (<esc>k<esc>\e) as a part of yo' prompt.
Da last part of yo' prompt must be tha same as tha strang you specified
for tha \fIsearch\fP portion of tha title.
Once dis is set up,
.I screen
will use tha title-escape-sequence ta clear tha previous command name and
get locked n loaded fo' tha next command.
Then, when a newline is received from tha shell, a search is made fo' the
end of tha prompt.
If found, it will grab tha straight-up original gangsta word afta tha matched strang n' use it
as tha command name.
If tha command name begins wit either '!', '%', or '^'
.I screen
will use tha straight-up original gangsta word on tha followin line (if found) up in preference to
the just-found name.
This helps csh playas git betta command names when rockin thang control or
history recall commands.
.PP
Herez some .screenrc examples:
.IP
screen -t top 2 sick top
.PP
Addin dis line ta yo' .screenrc would start a sick-d version of the
\*Qtop\*U command up in window 2 named \*Qtop\*U rather than \*Qnice\*U.
.sp
.nf
	shelltitle '> |csh'
	screen 1
.fi
.sp
These commandz would start a gangbangin' finger-lickin' dirty-ass shell wit tha given shelltitle.
Da title specified be a auto-title dat would expect tha prompt and
the typed command ta look suttin' like tha following:
.IP
/usr/joe/src/dir> trn
.PP
(it looks afta tha '> ' fo' tha command name).
Da window status would show tha name \*Qtrn\*U while tha command was
running, n' revert ta \*Qcsh\*U upon completion.
.IP
bind R screen -t '% |root:' su
.PP
Havin dis command up in yo' .screenrc would bind tha key
sequence \*QC-a R\*U ta tha \*Qsu\*U command n' give it an
auto-title name of \*Qroot:\*U.
For dis auto-title ta work, tha screen could look something
like this:
.sp
.nf
	% !em
	emacs file.c
.fi
.sp
Here tha user typed tha csh history command \*Q!em\*U which ran the
previously entered \*Qemacs\*U command.
Da window status would show \*Qroot:emacs\*U durin tha execution
of tha command, n' revert ta simply \*Qroot:\*U at its completion.
.PP
.nf
	bind o title
	bind E title ""
	bind u title (unknown)
.fi
.sp
Da first bindin aint gots any arguments, so it would prompt you
for a title. when you type \*QC-a o\*U.
Da second bindin would clear a auto-titlez current settin (C-a E).
Da third bindin would set tha current windowz title ta \*Q(unknown)\*U
(C-a u).
.PP
One thang ta keep up in mind when addin a null title-escape-sequence to
your prompt is dat some shells (like tha csh) count all tha non-control
charactas as part of tha promptz length.
If these invisible charactas aren't a multiple of 8 then backspacin over
a tab will result up in a incorrect display.
One way ta git round dis is ta bust a prompt like this:
.IP
set prompt='^[[0000m^[k^[\e% '
.PP
Da escape-sequence \*Q<esc>[0000m\*U not only normalizes tha character
attributes yo, but all tha zeros round tha length of tha invisible characters
up ta 8.
Bash playas will probably wanna echo tha escape sequence up in the
PROMPT_COMMAND:
.IP
PROMPT_COMMAND='printf "\e033k\e033\e134"'
.PP
(I used \*Q\134\*U ta output a `\e' cuz of a funky-ass bug up in bash v1.04).


.SH "THE VIRTUAL TERMINAL"
Each window up in a 
.I screen
session emulates a VT100 terminal, wit some extra functions added. Y'all KNOW dat shit, muthafucka! The
VT100 emulator is hard-coded, no other terminal types can be emulated.
.br
Usually
.I screen
tries ta emulate as much of tha VT100/ANSI standard
as possible. But if yo' terminal lacks certain capabilities,
the emulation may not be complete. In these cases
.I screen
has ta tell tha applications dat a shitload of tha features
are missing. This is no problem on machines rockin termcap,
because
.I screen
can use tha $TERMCAP variable to
customize tha standard
.I screen
termcap.
.PP
But if you do a
rlogin on another machine or yo' machine supports only
terminfo dis method fails. Because of this,
.I screen
offers a way ta deal wit these cases. 
Here is how tha fuck it works:
.PP
When 
.I screen
tries ta figure up a terminal name fo' itself,
it first looks
for a entry named \*Qscreen.<term>\*U, where <term> is
the contentz of yo' $TERM variable.
If no such entry exists,
.I screen
tries \*Qscreen\*U (or \*Qscreen-w\*U if tha terminal is wide
(132 cols or more)).
If even dis entry cannot be found, \*Qvt100\*U is used as a
substitute.
.PP
Da scam is dat if you gotz a terminal which don't
support a blingin feature (e.g. delete char or clear ta EOS)
you can build a freshly smoked up termcap/terminfo entry for
.I screen
(named \*Qscreen.<dumbterm>\*U) up in which dis capability
has been disabled. Y'all KNOW dat shit, muthafucka! If dis entry is installed on your
machines yo ass be able ta do
a rlogin n' still keep tha erect termcap/terminfo entry.
Da terminal name is put up in tha $TERM variable
of all freshly smoked up windows.
.I Screen
also sets tha $TERMCAP variable reflectin tha capabilities
of tha virtual terminal emulated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Notice that, however, on machines
usin tha terminfo database dis variable has no effect.
Furthermore, tha variable $WINDOW is set ta tha window number
of each window.
.PP
Da actual set of capabilitizzles supported by tha virtual terminal
dependz on tha capabilitizzles supported by tha physical terminal.
If, fo' instance, tha physical terminal do not support underscore mode,
.I screen
does not put tha `us' n' `ue' capabilitizzles tha fuck into tha windowz $TERMCAP
variable, accordingly.
But fuck dat shiznit yo, tha word on tha street is dat a minimum number of capabilitizzles must be supported by a
terminal up in order ta run
.IR screen ;
namely scrolling, clear screen, n' direct cursor addressing
(in addition,
.I screen
does not run on hardcopy terminals or on terminals dat over-strike).
.PP
Also, you can customize tha $TERMCAP value used by
.I screen
by rockin tha \*Qtermcap\*U .screenrc command, or
by definin tha variable $SCREENCAP prior ta startup.
When tha is latta defined, its value is ghon be copied verbatim tha fuck into each
windowz $TERMCAP variable.
This can either be tha full terminal definition, or a gangbangin' filename where the
terminal \*Qscreen\*U (and/or \*Qscreen-w\*U) is defined.
.PP
Note dat 
.I screen
honors tha \*Qterminfo\*U .screenrc command if tha system uses the
terminfo database rather than termcap.
.PP
When tha boolean `G0' capabilitizzle is present up in tha termcap entry
for tha terminal on which
.I screen
has been called, tha terminal emulation of
.I screen
supports multiple characta sets.
This allows a application ta make use of, fo' instance,
the VT100 graphics characta set or nationistic characta sets.
Da followin control functions from ISO 2022 is supported:
\fIlock shift G0\fP (\fISI\fP), \fIlock shift G1\fP (\fISO\fP),
\fIlock shift G2\fP, \fIlock shift G3\fP, \fIsingle shift G2\fP,
and \fIsingle shift G3\fP.
When a virtual terminal is pimped or reset, tha ASCII character
set is designated as \fIG0\fP all up in \fIG3\fP.
When tha `G0' capabilitizzle is present,
.I screen
evaluates tha capabilities
`S0', `E0', n' `C0' if present. `S0' is tha sequence tha terminal uses
to enable n' start tha graphics characta set rather than \fISI\fP. 
`E0' is tha correspondin replacement fo' \fISO\fP. `C0' gives a cold-ass lil character
by characta translation strang dat is used durin semi-graphics mode. This 
strin is built like tha `acsc' terminfo capability.
.PP
When tha `po' n' `pf' capabilitizzles is present up in tha terminal's
termcap entry, applications hustlin up in a
.I screen
window can bust output ta tha printa port of tha terminal.
This allows a user ta have a application up in one window
sendin output ta a printa connected ta tha terminal, while all
other windows is still actizzle (the printa port is enabled
and disabled again n' again n' again fo' each chunk of output).
As a side-effect, programs hustlin up in different windows can
send output ta tha printa simultaneously.
Data busted ta tha printa aint displayed up in tha window.  Da 
.I info
command displays a line startin `PRIN' while tha printa be active.
.PP
.I Screen
maintains a hardstatus line fo' every last muthafuckin window. If a window
gets selected, tha displayz hardstatus is ghon be updated ta match
the windowz hardstatus line. If tha display has no hardstatus
the line is ghon be displayed as a standard 
.I screen 
message.
Da hardstatus line can be chizzled wit tha ANSI Application
Program Command (APC): \*QESC_<string>ESC\e\*U fo' realz. As a cold-ass lil convenience
for xterm playas tha sequence \*QESC]0..2;<string>^G\*U is
also accepted.
.PP
Some capabilitizzles is only put tha fuck into tha $TERMCAP
variable of tha virtual terminal if they can be efficiently
implemented by tha physical terminal.
For instance, `dl' (delete line) is only put tha fuck into tha $TERMCAP
variable if tha terminal supports either delete line itself or
scrollin regions. Note dat dis may provoke mad drama, when 
the session is reattached on a gangbangin' finger-lickin' different terminal, as tha value
of $TERMCAP cannot be modified by parent processes.
.PP
Da "alternate screen" capabilitizzle aint enabled by default.
Set tha \fBaltscreen\fP .screenrc command ta enable dat shit.
.PP
Da followin be a list of control sequences recognized by
.IR screen .
\*Q(V)\*U n' \*Q(A)\*U indicate VT100-specific n' ANSI- or
ISO-specific functions, respectively.
.PP
.ta 22n
.TP 27
.B "ESC E"
Next Line
.TP 27
.B "ESC D"
Index
.TP 27
.B "ESC M"
Reverse Index
.TP 27
.B "ESC H"
Horizontal Tab Set
.TP 27
.B "ESC Z"
Send VT100 Identification String
.TP 27
.BR "ESC 7" "	(V)"
Save Cursor n' Attributes
.TP 27
.BR "ESC 8" "	(V)"
Restore Cursor n' Attributes
.TP 27
.BR "ESC [s" "	(A)"
Save Cursor n' Attributes
.TP 27
.BR "ESC [u" "	(A)"
Restore Cursor n' Attributes
.TP 27
.B "ESC c"
Reset ta Initial State
.TP 27
.B "ESC g"
Visual Bell
.TP 27
.B "ESC \fPPn\fB p"
Cursor Visibilitizzle (97801)
.TP 27
\h'\w'ESC 'u'Pn = \fB6\fP
Invisible
.TP 27
\h'\w'ESC Pn = 'u'\fB7\fP
Visible
.TP 27
.BR "ESC =" "	(V)"
Application Keypad Mode
.TP 27
.BR "ESC >" "	(V)"
Numeric Keypad Mode
.TP 27
.BR "ESC # 8" "	(V)"
Fill Screen wit E's
.TP 27
.BR "ESC \e" "	(A)"
Strin Terminator
.TP 27
.BR "ESC ^" "	(A)"
Privacy Message Strin (Message Line)
.TP 27
.B "ESC !"
Global Message Strin (Message Line)
.TP 27
.B "ESC k"
A.\|k.\|a. Definizzle String
.TP 27
.BR "ESC P" "	(A)"
Device Control String.
Outputs a strang directly ta tha host
terminal without interpretation.
.TP 27
.BR "ESC _" "	(A)"
Application Program Command (Hardstatus)
.TP 27
.BR "ESC ] 0 ; strang ^G" "	(A)"
Operatin System Command (Hardstatus, xterm title hack)
.TP 27
.BR "ESC ] 83 ; cmd ^G" "	(A)"
Execute screen command. Y'all KNOW dat shit, muthafucka! This only works if multi-user support is
compiled tha fuck into screen. I aint talkin' bout chicken n' gravy biatch. Da pseudo-user \*Q:window:\*U is used to
check tha access control list. Use \*Qaddacl :window: -rwx #?\*U to
create a user wit no muthafuckin rights n' allow only tha needed commands.
.TP 27
.BR "Control-N" "	(A)"
Lock Shift G1 (SO)
.TP 27
.BR "Control-O" "	(A)"
Lock Shift G0 (SI)
.TP 27
.BR "ESC n" "	(A)"
Lock Shift G2
.TP 27
.BR "ESC o" "	(A)"
Lock Shift G3
.TP 27
.BR "ESC N" "	(A)"
Single Shift G2
.TP 27
.BR "ESC O" "	(A)"
Single Shift G3
.TP 27
.BR "ESC ( \fPPcs" "	(A)"
Designate characta set as G0
.TP 27
.BR "ESC ) \fPPcs" "	(A)"
Designate characta set as G1
.TP 27
.BR "ESC * \fPPcs" "	(A)"
Designate characta set as G2
.TP 27
.BR "ESC + \fPPcs" "	(A)"
Designate characta set as G3
.TP 27
.B "ESC [ \fPPn\fB ; \fPPn\fB H"
Direct Cursor Addressing
.TP 27
.B "ESC [ \fPPn\fB ; \fPPn\fB f"
same as above
.TP 27
.B "ESC [ \fPPn\fB J"
Erase up in Display
.TP 27
\h'\w'ESC [ 'u'Pn = None or \fB0\fP
From Cursor ta End of Screen
.TP 27
\h'\w'ESC [ Pn = 'u'\fB1\fP
From Beginnin of Screen ta Cursor
.TP 27
\h'\w'ESC [ Pn = 'u'\fB2\fP
Entire Screen
.TP 27
.B "ESC [ \fPPn\fB K"
Erase up in Line
.TP 27
\h'\w'ESC [ 'u'Pn = None or \fB0\fP
From Cursor ta End of Line
.TP 27
\h'\w'ESC [ Pn = 'u'\fB1\fP
From Beginnin of Line ta Cursor
.TP 27
\h'\w'ESC [ Pn = 'u'\fB2\fP
Entire Line
.TP 27
.B "ESC [ \fPPn\fB X"
Erase character
.TP 27
.B "ESC [ \fPPn\fB A"
Cursor Up
.TP 27
.B "ESC [ \fPPn\fB B"
Cursor Down
.TP 27
.B "ESC [ \fPPn\fB C"
Cursor Right
.TP 27
.B "ESC [ \fPPn\fB D"
Cursor Left
.TP 27
.B "ESC [ \fPPn\fB E"
Cursor next line
.TP 27
.B "ESC [ \fPPn\fB F"
Cursor previous line
.TP 27
.B "ESC [ \fPPn\fB G"
Cursor horizontal position
.TP 27
.B "ESC [ \fPPn\fB `"
same as above
.TP 27
.B "ESC [ \fPPn\fB d"
Cursor vertical position
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB m"
Select Graphic Rendition
.TP 27
\h'\w'ESC [ 'u'Ps = None or \fB0\fP
Default Rendition
.TP 27
\h'\w'ESC [ Ps = 'u'\fB1\fP
Bold
.TP 27
\h'\w'ESC [ Ps = 'u'\fB2\fP	(A)
Faint
.TP 27
\h'\w'ESC [ Ps = 'u'\fB3\fP	(A)
\fIStandout\fP Mode (ANSI: Italicized)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB4\fP
Underlined
.TP 27
\h'\w'ESC [ Ps = 'u'\fB5\fP
Blinking
.TP 27
\h'\w'ESC [ Ps = 'u'\fB7\fP
Negatizzle Image
.TP 27
\h'\w'ESC [ Ps = 'u'\fB22\fP	(A)
Normal Intensity
.TP 27
\h'\w'ESC [ Ps = 'u'\fB23\fP	(A)
\fIStandout\fP Mode off (ANSI: Italicized off)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB24\fP	(A)
Not Underlined
.TP 27
\h'\w'ESC [ Ps = 'u'\fB25\fP	(A)
Not Blinking
.TP 27
\h'\w'ESC [ Ps = 'u'\fB27\fP	(A)
Positizzle Image
.TP 27
\h'\w'ESC [ Ps = 'u'\fB30\fP	(A)
Foreground Black
.TP 27
\h'\w'ESC [ Ps = 'u'\fB31\fP	(A)
Foreground Red
.TP 27
\h'\w'ESC [ Ps = 'u'\fB32\fP	(A)
Foreground Green
.TP 27
\h'\w'ESC [ Ps = 'u'\fB33\fP	(A)
Foreground Yellow
.TP 27
\h'\w'ESC [ Ps = 'u'\fB34\fP	(A)
Foreground Blue
.TP 27
\h'\w'ESC [ Ps = 'u'\fB35\fP	(A)
Foreground Magenta
.TP 27
\h'\w'ESC [ Ps = 'u'\fB36\fP	(A)
Foreground Cyan
.TP 27
\h'\w'ESC [ Ps = 'u'\fB37\fP	(A)
Foreground White
.TP 27
\h'\w'ESC [ Ps = 'u'\fB39\fP	(A)
Foreground Default
.TP 27
\h'\w'ESC [ Ps = 'u'\fB40\fP	(A)
Background Black
.TP 27
\h'\w'ESC [ Ps = 'u'\fB...\fP
...
.TP 27
\h'\w'ESC [ Ps = 'u'\fB49\fP	(A)
Background Default
.TP 27
.B "ESC [ \fPPn\fB g"
Tab Clear
.TP 27
\h'\w'ESC [ 'u'Pn = None or \fB0\fP
Clear Tab at Current Position
.TP 27
\h'\w'ESC [ Ps = 'u'\fB3\fP
Clear All Tabs
.TP 27
.BR "ESC [ \fPPn\fB ; \fPPn\fB r" "	(V)"
Set Scrollin Region
.TP 27
.BR "ESC [ \fPPn\fB I" "	(A)"
Horizontal Tab
.TP 27
.BR "ESC [ \fPPn\fB Z" "	(A)"
Backward Tab
.TP 27
.BR "ESC [ \fPPn\fB L" "	(A)"
Insert Line
.TP 27
.BR "ESC [ \fPPn\fB M" "	(A)"
Delete Line
.TP 27
.BR "ESC [ \fPPn\fB @" "	(A)"
Insert Character
.TP 27
.BR "ESC [ \fPPn\fB P" "	(A)"
Delete Character
.TP 27
.B "ESC [ \fPPn\fB S"
Scroll Scrollin Region Up
.TP 27
.B "ESC [ \fPPn\fB T"
Scroll Scrollin Region Down
.TP 27
.B "ESC [ \fPPn\fB ^"
same as above
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB h"
Set Mode
.TP 27
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB l"
Reset Mode
.TP 27
\h'\w'ESC [ 'u'Ps = \fB4\fP	(A)
Insert Mode
.TP 27
\h'\w'ESC [ Ps = 'u'\fB20\fP	(A)
\fIAutomatic Linefeed\fP Mode
.TP 27
\h'\w'ESC [ Ps = 'u'\fB34\fP
Normal Cursor Visibility
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1\fP	(V)
Application Cursor Keys
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?3\fP	(V)
Change Terminal Width ta 132 columns
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?5\fP	(V)
Reverse Video
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?6\fP	(V)
\fIOrigin\fP Mode
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?7\fP	(V)
\fIWrap\fP Mode
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?9\fP
X10 mouse tracking
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?25\fP	(V)
Visible Cursor
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?47\fP
Alternate Screen (old xterm code)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1000\fP	(V)
VT200 mouse tracking
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1047\fP
Alternate Screen (new xterm code)
.TP 27
\h'\w'ESC [ Ps = 'u'\fB?1049\fP
Alternate Screen (new xterm code)
.TP 27
.BR "ESC [ 5 i" "	(A)"
Start relay ta printa (ANSI Media Copy)
.TP 27
.BR "ESC [ 4 i" "	(A)"
Quit relay ta printa (ANSI Media Copy)
.TP 27
.B "ESC [ 8 ; \fPPh\fB ; \fPPw\fB t"
Resize tha window ta `Ph' lines n' `Pw' columns (SunView special)
.TP 27
.B "ESC [ c"
Send VT100 Identification String
.TP 27
.B "ESC [ x"
Send Terminal Parameta Report
.TP 27
.B "ESC [ > c"
Send VT220 Secondary Device Attributes String
.TP 27
.B "ESC [ 6 n"
Send Cursor Posizzle Report


.SH "INPUT TRANSLATION"
In order ta do a gangbangin' full VT100 emulation 
.I screen
has ta detect
that a sequence of charactas up in tha input stream was generated
by a keypress on tha userz keyboard n' bang tha VT100
style escape sequence. \fIScreen\fP has a straight-up flexible way of bustin
this by makin it possible ta map arbitrary commandz on arbitrary
sequencez of characters. For standard VT100 emulation tha command
will always bang a strang up in tha input buffer of tha window
(see also command \fBstuff\fP up in tha command table).
Because tha sequences generated by a keypress can
change afta a reattach from a gangbangin' finger-lickin' different terminal type, it is
possible ta bind commandz ta tha termcap name of tha keys.
\fIScreen\fP will bang tha erect bindin afta each
reattach. Right back up in yo muthafuckin ass. See tha \fBbindkey\fP command fo' further details on the
syntax n' examples.
.PP
Here is tha table of tha default key bindings. (A) means dat the
command is executed if tha keyboard is switched tha fuck into application
mode.
.PP
.ta 18n 34n 50n
.nf
Key name	Termcap name	Command
\l'54n'
.ta 22n 34n 50n
Cursor up	ku	shiznit \e033[A
		shiznit \e033OA	(A)
Cursor down	kd	shiznit \e033[B
		shiznit \e033OB	(A)
Cursor right	kr	shiznit \e033[C
		shiznit \e033OC	(A)
Cursor left	kl	shiznit \e033[D
		shiznit \e033OD	(A)
Function key 0	k0	shiznit \e033[10~
Function key 1	k1	shiznit \e033OP
Function key 2	k2	shiznit \e033OQ
Function key 3	k3	shiznit \e033OR
Function key 4	k4	shiznit \e033OS
Function key 5	k5	shiznit \e033[15~
Function key 6	k6	shiznit \e033[17~
Function key 7	k7	shiznit \e033[18~
Function key 8	k8	shiznit \e033[19~
Function key 9	k9	shiznit \e033[20~
Function key 10	k;	shiznit \e033[21~
Function key 11	F1	shiznit \e033[23~
Function key 12	F2	shiznit \e033[24~
Home	kh	shiznit \e033[1~
End	kH	shiznit \e033[4~
Insert	kI	shiznit \e033[2~
Delete	kD	shiznit \e033[3~
Page up	kP	shiznit \e033[5~
Page down	kN	shiznit \e033[6~
Keypad 0	f0	shiznit 0
		shiznit \e033Op	(A)
Keypad 1	f1	shiznit 1
		shiznit \e033Oq	(A)
Keypad 2	f2	shiznit 2
		shiznit \e033Or	(A)
Keypad 3	f3	shiznit 3
		shiznit \e033Os	(A)
Keypad 4	f4	shiznit 4
		shiznit \e033Ot	(A)
Keypad 5	f5	shiznit 5
		shiznit \e033Ou	(A)
Keypad 6	f6	shiznit 6
		shiznit \e033Ov	(A)
Keypad 7	f7	shiznit 7
		shiznit \e033Ow	(A)
Keypad 8	f8	shiznit 8
		shiznit \e033Ox	(A)
Keypad 9	f9	shiznit 9
		shiznit \e033Oy	(A)
Keypad +	f+	shiznit +
		shiznit \e033Ok	(A)
Keypad -	f-	shiznit -
		shiznit \e033Om	(A)
Keypad *	f*	shiznit *
		shiznit \e033Oj	(A)
Keypad /	f/	shiznit /
		shiznit \e033Oo	(A)
Keypad =	fq	shiznit =
		shiznit \e033OX	(A)
Keypad .	f.	shiznit .
		shiznit \e033On	(A)
Keypad ,	f,	shiznit ,
		shiznit \e033Ol	(A)
Keypad enter	fe	shiznit \e015
		shiznit \e033OM	(A)
.fi


.SH SPECIAL TERMINAL CAPABILITIES
Da followin table raps bout all terminal capabilities
that is recognized by 
.I screen
and is not up in tha termcap(5) manual.
Yo ass can place these capabilitizzles up in yo' termcap entries (in
`/etc/termcap') or use dem wit tha commandz `termcap', `terminfo' and
`termcapinfo' up in yo' screenrc files. Well shiiiit, it is often not possible ta place
these capabilitizzles up in tha terminfo database.
.PP
.ta 5n
.TP 13
.BI LP "	(bool)"
Terminal has VT100 steez margins (`magic margins'). Note that
this capabilitizzle is obsolete cuz 
.I screen
uses tha standard 'xn' instead.
.TP 13
.BI Z0 "	(str)"
Change width ta 132 columns.
.TP 13
.BI Z1 "	(str)"
Change width ta 80 columns.
.TP 13
.BI WS "	(str)"
Resize display. This capabilitizzle has tha desired width n' height as
arguments, n' you can put dat on yo' toast. \fISunView(tm)\fP example: '\eE[8;%d;%dt'.
.TP 13
.BI NF "	(bool)"
Terminal don't need flow control. Right back up in yo muthafuckin ass. Send ^S n' ^Q direct to
the application. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Same as 'flow off'. Da opposite of this
capabilitizzle is 'nx'.
.TP 13
.BI G0 "	(bool)"
Terminal can deal wit ISO 2022 font selection sequences.
.TP 13
.BI S0 "	(str)"
Switch charset 'G0' ta tha specified charset. Default
is '\eE(%.'.
.TP 13
.BI E0 "	(str)"
Switch charset 'G0' back ta standard charset. Default
is '\eE(B'.
.TP 13
.BI C0 "	(str)"
Use tha strang as a cold-ass lil conversion table fo' font '0'. Right back up in yo muthafuckin ass. See
the 'ac' capabilitizzle fo' mo' details.
.TP 13
.BI CS "	(str)"
Switch cursor-keys ta application mode.
.TP 13
.BI CE "	(str)"
Switch cursor-keys back ta aiiight mode.
.TP 13
.BI AN "	(bool)"
Turn on autonuke. Right back up in yo muthafuckin ass. See tha 'autonuke' command fo' mo' details.
.TP 13
.BI OL "	(num)"
Set tha output buffer limit. Right back up in yo muthafuckin ass. See tha 'obuflimit' command fo' mo' details.
.TP 13
.BI KJ "	(str)"
Set tha encodin of tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. See tha 'encoding' command for
valid encodings.
.TP 13
.BI AF "	(str)"
Change characta foreground color up in a ANSI conform way. This
capabilitizzle will almost always be set ta '\eE[3%dm' ('\eE[3%p1%dm'
on terminfo machines).
.TP 13
.BI AB "	(str)"
Same as 'AF' yo, but chizzle background color.
.TP 13
.BI AX "	(bool)"
Do KNOW ANSI set default fg/bg color (\eE[39m / \eE[49m).
.TP 13
.BI XC "	(str)"
Describe a translation of charactas ta strings dependin on the
current font. Mo' details follow up in tha next section.
.TP 13
.BI XT "	(bool)"
Terminal understandz special xterm sequences (OSC, mouse tracking).
.TP 13
.BI C8 "	(bool)"
Terminal needz bold ta display high-intensitizzle flavas (e.g. Eterm).
.TP 13
.BI TF "	(bool)"
Add missin capabilitizzles ta tha termcap/info entry. (Set by default).

.SH CHARACTER TRANSLATION
\fIScreen\fP has a bangin mechanizzle ta translate charactas ta arbitrary
strings dependin on tha current font n' terminal type.
Use dis feature if you wanna work wit a cold-ass lil common standard character
set (say ISO8851-latin1) even on terminals dat scatta tha more
unusual charactas over nuff muthafuckin nationistic language font pages.

Syntax:
.nf
    \fBXC=\fP\fI<charset-mapping>\fP{\fB,,\fP\fI<charset-mapping>\fP}
    \fI<charset-mapping>\fP := \fI<designator><template>\fP{\fB,\fP\fI<mapping>\fP}
    \fI<mapping>\fP := \fI<char-to-be-mapped><template-arg>\fP
.fi

Da thangs up in braces may be repeated any number of times.

A \fI<charset-mapping>\fP  drops some lyrics ta 
.I screen
how ta map characters
in font \fI<designator>\fP ('B': Ascii, 'A': UK, 'K': German, etc.)
to strings. Every \fI<mapping>\fP raps bout ta what tha fuck strang a single
characta is ghon be translated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. A template mechanizzle is used, as 
most of tha time tha codes gotz a shitload up in common (for example
strings ta switch ta n' from another charset). Each occurrence
of '%' up in \fI<template>\fP gets substituted wit tha \fI<template-arg>\fP
specified together wit tha character n' shit. If yo' strings is not
similar at all, then use '%' as a template n' place tha full
strin up in \fI<template-arg>\fP fo' realz. A quotin mechanizzle was added ta make
it possible ta bust a real '%'. Da '\e' characta quotes the
special charactas '\e', '%', n' ','.

Here be a example:

    termcap hp700 'XC=B\eE(K%\eE(B,\e304[,\e326\e\e\e\e,\e334]'

This tells
.I screen
how ta translate ISOlatin1 (charset 'B')
upper case umlaut charactas on a hp700 terminal dat has a
German charset. '\e304' gets translated ta '\eE(K[\eE(B' n' so on.
Note dat dis line gets parsed *three* times before tha internal
lookup table is built, therefore a shitload of quotin is needed to
create a single '\e'.

Another extension was added ta allow mo' emulation: If a mapping
translates tha unquoted '%' char, it is ghon be busted ta tha terminal
whenever 
.I screen
switches ta tha correspondin \fI<designator>\fP. In this
special case tha template be assumed ta be just '%' cuz
the charset switch sequence n' tha characta mappings normally
haven't much up in common.

This example shows one use of tha extension:

    termcap xterm 'XC=K%,%\eE(B,[\e304,\e\e\e\e\e326,]\e334'

Here, a part of tha German ('K') charset is emulated on a xterm.
If 
.I screen
has ta chizzle ta tha 'K' charset, '\eE(B' is ghon be sent
to tha terminal, i.e. tha ASCII charset is used instead. Y'all KNOW dat shit, muthafucka! The
template is just '%', so tha mappin is straightforward: '['
to '\e304', '\e' ta '\e326', n' ']' ta '\e334'.

.SH ENVIRONMENT
.PD 0
.IP COLUMNS 15
Number of columns on tha terminal (overrides termcap entry).
.IP HOME
Directory up in which ta look fo' .screenrc.
.IP LINES 
Number of lines on tha terminal (overrides termcap entry).
.IP LOCKPRG
Screen lock program.
.IP NETHACKOPTIONS
Turns on nethack option.
.IP PATH
Used fo' locatin programs ta run.
.IP SCREENCAP
For customizin a terminalz TERMCAP value.
.IP SCREENDIR
Alternate socket directory.
.IP SCREENRC
Alternate user screenrc file.
.IP SHELL
Default shell program fo' openin windows (default \*Q/bin/sh\*U).
.IP STY
Alternate socket name.
.IP SYSSCREENRC
Alternate system screenrc file.
.IP TERM
Terminal name.
.IP TERMCAP
Terminal description.
.IP WINDOW
Window number of a window (at creation time).

.SH FILES
.PD 0
.IP .../screen-4.?.??/etc/screenrc 34
.IP .../screen-4.?.??/etc/etcscreenrc
Examplez up in tha 
.I screen
distribution package fo' private n' global initialization files.
.IP $SYSSCREENRC 
.IP /etc/screenrc
.I screen
initialization commands
.IP $SCREENRC
.IP $HOME/.screenrc
Read up in afta /etc/screenrc
.IP $SCREENDIR/S-<login>
.IP /local/screens/S-<login>
Socket directories (default)
.IP /usr/tmp/screens/S-<login>
Alternate socket directories.
.IP "<socket directory>/.termcap"
Written by tha "termcap" output function
.IP /usr/tmp/screens/screen-exchange
or
.IP /tmp/screen-exchange
.I screen
`interprocess communication buffer'
.IP hardcopy.[0-9]
Screen images pimped by tha hardcopy function
.IP screenlog.[0-9]
Output log filez pimped by tha log function
.IP /usr/lib/terminfo/?/*
or
.IP /etc/termcap
Terminal capabilitizzle databases
.IP /etc/utmp
Login records
.IP $LOCKPRG
Program dat locks a terminal.


.SH "SEE ALSO"
termcap(5), utmp(5), vi(1), captoinfo(1), tic(1)


.SH AUTHORS
Originally pimped by Oliver Laumann, dis sickest fuckin version was
produced by Juergen Weigert, Mike Schroeder, Micah Cowan and
Sadrul Habib Chowdhury.

.SH COPYLEFT
.nf
Copyright (c) 2010
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Sadrul Habib Chowdhury (sadrul@users.sourceforge.net)
Copyright (c) 2008, 2009
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Mike Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
	Micah Cowan (micah@cowan.name)
	Sadrul Habib Chowdhury (sadrul@users.sourceforge.net)
Copyright (C) 1993-2003
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Mike Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
Copyright (C) 1987 Oliver Laumann
.fi
.PP
This program is free software; you can redistribute it and/or modify
it under tha termz of tha GNU General Public License as published by
the Jacked Software Foundation; either version 3, or (at yo' option)
any lata version.
.PP
This program is distributed up in tha hope dat it is ghon be useful,
but WITHOUT ANY WARRANTY; without even tha implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License fo' mo' details.
.PP
Yo ass should have received a cold-ass lil copy of tha GNU General Public License
along wit dis program (see tha file COPYING); if not, write ta the
Jacked Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

.SH CONTRIBUTORS
.nf
Ken Beal (kbeal@amber.ssd.csd.harris.com),
Rudolf Koenig (rfkoenig@immd4.informatik.uni-erlangen.de),
Toerless Eckert (eckert@immd4.informatik.uni-erlangen.de), 
Weezy Davison (davison@borland.com),
Patrick Wolfe (pat@kai.com, kailand!pat),
Bart Schaefer (schaefer@cse.ogi.edu),
Nathan Glasser (nathan@brokaw.lcs.mit.edu),
Larry W. Virden (lvirden@cas.org),
Howard Chu (hyc@hanauma.jpl.nasa.gov),
Slim Tim MacKenzie (tym@dibbler.cs.monash.edu.au),
Markku Jarvinen (mta@{cc,cs,ee}.tut.fi),
Marc Boucher (marc@CAM.ORG),
Doug Siebert (dsiebert@isca.uiowa.edu),
Ken Stillson (stillson@tsfsrv.mitre.org),
Ian Frechett (frechett@spot.Colorado.EDU),
Brian Koehmstedt (bpk@gnu.ai.mit.edu),
Don Smizzle (djs6015@ultb.isc.rit.edu),
Frank van der Linden (vdlinden@fwi.uva.nl),
Martin Schweikert (schweik@cpp.ob.open.de),
Dizzy Vrona (dave@sashimi.lcu.com),
E. Tye McQueen (tye%spillman.UUCP@uunet.uu.net),
Matthew Chronic (mrg@eterna.com.au),
Christopher Williams (cgw@pobox.com),
Mack Mosley (mattm@access.digex.net),
Gregory Neil Shapiro (gshapiro@wpi.WPI.EDU),
Johannes Zellner (johannes@zellner.org),
Pablo Averbuj (pablo@averbuj.com).
.fi


.SH VERSION
This is version 4.1.0. Its roots is a merge of a cold-ass lil custom version
2.3PR7 by Weezy Davison
and nuff muthafuckin enhancements ta Oliver Laumannz version 2.0. Note dat all versions
numbered 2.x is copyright by Oliver Laumann. I aint talkin' bout chicken n' gravy biatch. 

.SH AVAILABILITY
Da sickest fuckin straight-up legit release of 
.I screen
available via anonymous ftp from gnudist.gnu.org, nic.funet.fi or any other 
.I GNU 
distribution crib. Da home joint of
.I screen
is ftp.uni-erlangen.de, up in tha directory
pub/utilities/screen. I aint talkin' bout chicken n' gravy biatch. Da subdirectory `private' gotz nuff tha sickest fuckin beta
testin release. If you wanna help, bust a note to
screen@uni-erlangen.de.

.SH BUGS
.PD
.IP \(bu 3
`dm' (delete mode) n' `xs' is not handled
correctly (they is ignored). `xn' is treated as a magic-margin
indicator.
.IP \(bu
.I Screen
has no clue bout double-high or double-wide characters.         
But dis is tha only area where 
.I vttest
is allowed ta fail.
.IP \(bu
It aint possible ta chizzle tha environment variable $TERMCAP when 
reattachin under a gangbangin' finger-lickin' different terminal type.
.IP \(bu
Da support of terminfo based systems is straight-up limited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Addin extra
capabilitizzles ta $TERMCAP may not have any effects.
.IP \(bu
.I Screen
does not make use of hardware tabs.
.IP \(bu
.I Screen
must be installed as set-uid wit balla root on most systems up in order
to be able ta erectly chizzle tha balla of tha tty thang file for
each window.
Special permission may also be required ta write tha file \*Q/etc/utmp\*U.
.IP \(bu
Entries up in \*Q/etc/utmp\*U is not removed when
.I screen
is capped wit SIGKILL.
This will cause some programs (like "w" or "rwho")
to advertise dat a user is logged on whoz ass straight-up aint.
.IP \(bu
.I Screen
may give a strange warnin when yo' tty has no utmp entry.
.IP \(bu
When tha modem line was hung up, 
.I screen
may not automatically detach (or quit)
unless tha thang driver is configured ta bust a HANGUP signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. 
To detach a 
.I screen
session use tha -D or -d command line option.
.IP \(bu
If a password is set, tha command line options -d n' -D still detach a 
session without asking.
.IP \(bu
Both \*Qbreaktype\*U n' \*Qdefbreaktype\*U chizzle tha break generating
method used by all terminal devices. Da first should chizzle a window
specific setting, where tha latta should chizzle only tha default fo' freshly smoked up 
windows.
.IP \(bu
When attachin ta a multiuser session, tha userz .screenrc file is not
sourced. Y'all KNOW dat shit, muthafucka! Each userz underground settings gotta be included up in tha .screenrc
file from which tha session is booted, or gotta be chizzled manually.
.IP \(bu
A weird imagination is most useful ta bust full advantage of all tha features.
.IP \(bu
Send bug-reports, fixes, enhancements, t-shirts, scrilla, brew & pizzy to
.BR screen@uni-erlangen.de .

