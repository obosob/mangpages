.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEMBED 1"
.TH PERLEMBED 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlembed \- how tha fuck ta embed perl up in yo' C program
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1PREAMBLE\s0"
.IX Subsection "PREAMBLE"
Do you want to:
.IP "\fBUse C from Perl?\fR" 5
.IX Item "Use C from Perl?"
Read perlxstut, perlxs, h2xs, perlguts, n' perlapi.
.IP "\fBUse a Unix program from Perl?\fR" 5
.IX Item "Use a Unix program from Perl?"
Read bout back-quotes n' bout \f(CW\*(C`system\*(C'\fR n' \f(CW\*(C`exec\*(C'\fR up in perlfunc.
.IP "\fBUse Perl from Perl?\fR" 5
.IX Item "Use Perl from Perl?"
Read bout \*(L"do\*(R" up in perlfunc n' \*(L"eval\*(R" up in perlfunc n' \*(L"require\*(R" up in perlfunc 
and \*(L"use\*(R" up in perlfunc.
.IP "\fBUse C from C?\fR" 5
.IX Item "Use C from C?"
Rethink yo' design.
.IP "\fBUse Perl from C?\fR" 5
.IX Item "Use Perl from C?"
Read on...
.SS "\s-1ROADMAP\s0"
.IX Subsection "ROADMAP"
.IP "\(bu" 5
Compilin yo' C program
.IP "\(bu" 5
Addin a Perl interpreta ta yo' C program
.IP "\(bu" 5
Callin a Perl subroutine from yo' C program
.IP "\(bu" 5
Evaluatin a Perl statement from yo' C program
.IP "\(bu" 5
Performin Perl pattern matches n' substitutions from yo' C program
.IP "\(bu" 5
Fiddlin wit tha Perl stack from yo' C program
.IP "\(bu" 5
Maintainin a persistent interpreter
.IP "\(bu" 5
Maintainin multiple interpreta instances
.IP "\(bu" 5
Usin Perl modules, which theyselves use C libraries, from yo' C program
.IP "\(bu" 5
Embeddin Perl under Win32
.SS "Compilin yo' C program"
.IX Subsection "Compilin yo' C program"
If you have shiznit compilin tha scripts up in dis documentation,
yo ass is not ridin' solo.  Da cardinal rule: \s-1COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  \s0(Sorry fo' yelling.)
.PP
Also, every last muthafuckin C program dat uses Perl must link up in tha \fIperl library\fR.
Whatz that, you ask, biatch?  Perl is itself freestyled up in C; tha perl library
is tha collection of compiled C programs dat was used ta create your
perl executable (\fI/usr/bin/perl\fR or equivalent).  (Corollary: you
can't use Perl from yo' C program unless Perl has been compiled on
your machine, or installed properly\*(--thatz why you shouldn't blithely
copy Perl executablez from machine ta machine without also copyin the
\&\fIlib\fR directory.)
.PP
When you use Perl from C, yo' C program will\*(--usually\-\-allocate,
\&\*(L"run\*(R", n' deallocate a \fIPerlInterpreter\fR object, which is defined by
the perl library.
.PP
If yo' copy of Perl is recent enough ta contain dis documentation
(version 5.002 or later), then tha perl library (and \fI\s-1EXTERN\s0.h\fR and
\&\fIperl.h\fR, which you gonna also need) will reside up in a gangbangin' finger-lickin' directory
that be lookin like this:
.PP
.Vb 1
\&    /usr/local/lib/perl5/your_architecture_here/CORE
.Ve
.PP
or like just
.PP
.Vb 1
\&    /usr/local/lib/perl5/CORE
.Ve
.PP
or maybe suttin' like
.PP
.Vb 1
\&    /usr/opt/perl5/CORE
.Ve
.PP
Execute dis statement fo' a hint bout where ta find \s-1CORE:\s0
.PP
.Vb 1
\&    perl \-MConfig \-e \*(Aqprint $Config{archlib}\*(Aq
.Ve
.PP
Herez how tha fuck you'd compile tha example up in tha next section,
\&\*(L"Addin a Perl interpreta ta yo' C program\*(R", on mah Linux box:
.PP
.Vb 4
\&    % gcc \-O2 \-Dbool=char \-DHAS_BOOL \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-L/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-o interp interp.c \-lperl \-lm
.Ve
.PP
(Thatz all one line.)  On mah \s-1DEC\s0 Alpha hustlin oldschool 5.003_05, tha 
incantation be a lil' bit different:
.PP
.Vb 4
\&    % cc \-O2 \-Olimit 2900 \-DSTANDARD_C \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE
\&    \-L/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE \-L/usr/local/lib
\&    \-D_\|_LANGUAGE_C_\|_ \-D_NO_PROTO \-o interp interp.c \-lperl \-lm
.Ve
.PP
How tha fuck can you figure up what tha fuck ta add, biatch?  Assumin yo' Perl is post\-5.001,
execute a \f(CW\*(C`perl \-V\*(C'\fR command n' pay special attention ta tha \*(L"cc\*(R" and
\&\*(L"ccflags\*(R" shiznit.
.PP
You'll gotta chizzle tha appropriate compila (\fIcc\fR, \fIgcc\fR, et al.) for
your machine: \f(CW\*(C`perl \-MConfig \-e \*(Aqprint $Config{cc}\*(Aq\*(C'\fR will rap  what
to use.
.PP
You'll also gotta chizzle tha appropriate library directory
(\fI/usr/local/lib/...\fR) fo' yo' machine.  If yo' compila bitches
that certain functions is undefined, or dat it can't locate
\&\fI\-lperl\fR, then you need ta chizzle tha path followin tha \f(CW\*(C`\-L\*(C'\fR.  If it
complains dat it can't find \fI\s-1EXTERN\s0.h\fR n' \fIperl.h\fR, you need to
change tha path followin tha \f(CW\*(C`\-I\*(C'\fR.
.PP
Yo ass may gotta add extra libraries as well.  Which ones?
Perhaps dem printed by
.PP
.Vb 1
\&   perl \-MConfig \-e \*(Aqprint $Config{libs}\*(Aq
.Ve
.PP
Provided yo' perl binary was properly configured n' installed the
\&\fBExtUtils::Embed\fR module will determine all of dis shiznit for
you:
.PP
.Vb 1
\&   % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
If tha \fBExtUtils::Embed\fR module aint part of yo' Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by\-module/ExtUtils/
(If dis documentation came from yo' Perl distribution, then you is
runnin 5.004 or betta n' you already have dat shit.)
.PP
Da \fBExtUtils::Embed\fR kit on \s-1CPAN\s0 also gotz nuff all source code for
the examplez up in dis document, tests, additionizzle examplez n' other
information you may find useful.
.SS "Addin a Perl interpreta ta yo' C program"
.IX Subsection "Addin a Perl interpreta ta yo' C program"
In a sense, perl (the C program) be a phat example of embeddin Perl
(the language), so I be bout ta demonstrate embeddin wit \fIminiperlmain.c\fR,
included up in tha source distribution. I aint talkin' bout chicken n' gravy biatch.  Herez a funky-ass bastardized, non-portable
version of \fIminiperlmain.c\fR containin tha essentialz of embedding:
.PP
.Vb 2
\&    #include <EXTERN.h>               /* from tha Perl distribution     */
\&    #include <perl.h>                 /* from tha Perl distribution     */
\&
\&    static PerlInterpreta *my_perl;  /***    Da Perl interpreta    ***/
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
\&        perl_run(my_perl);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
Notice dat our phat asses don't use tha \f(CW\*(C`env\*(C'\fR pointer n' shit.  Normally handed to
\&\f(CW\*(C`perl_parse\*(C'\fR as its final argument, \f(CW\*(C`env\*(C'\fR here is replaced by
\&\f(CW\*(C`NULL\*(C'\fR, which means dat tha current environment is ghon be used.
.PP
Da macros \s-1\fIPERL_SYS_INIT3\s0()\fR n' \s-1\fIPERL_SYS_TERM\s0()\fR provide system-specific
tune up of tha C runtime environment necessary ta run Perl interpreters;
they should only be called once regardless of how tha fuck nuff interpretas you
create or destroy. Call \s-1\fIPERL_SYS_INIT3\s0()\fR before you create yo' first
interpreter, n' \s-1\fIPERL_SYS_TERM\s0()\fR afta you free yo' last interpreter.
.PP
Since \s-1\fIPERL_SYS_INIT3\s0()\fR may chizzle \f(CW\*(C`env\*(C'\fR, it may be mo' appropriate to
provide \f(CW\*(C`env\*(C'\fR as a argument ta \fIperl_parse()\fR.
.PP
Also notice dat no matta what tha fuck arguments you pass ta \fIperl_parse()\fR,
\&\s-1\fIPERL_SYS_INIT3\s0()\fR must be invoked on tha C \fImain()\fR argc, argv n' env and
only once.
.PP
Now compile dis program (I be bout ta call it \fIinterp.c\fR) tha fuck into a executable:
.PP
.Vb 1
\&    % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Afta a successful compilation, you gonna be able ta use \fIinterp\fR just
like perl itself:
.PP
.Vb 6
\&    % interp
\&    print "Pretty Dope Perl \en";
\&    print "10890 \- 9801 is ", 10890 \- 9801;
\&    <CTRL\-D>
\&    Pretty Dope Perl
\&    10890 \- 9801 is 1089
.Ve
.PP
or
.PP
.Vb 2
\&    % interp \-e \*(Aqprintf("%x", 3735928559)\*(Aq
\&    deadbeef
.Ve
.PP
Yo ass can also read n' execute Perl statements from a gangbangin' file while up in the
midst of yo' C program, by placin tha filename up in \fIargv[1]\fR before
callin \fIperl_run\fR.
.SS "Callin a Perl subroutine from yo' C program"
.IX Subsection "Callin a Perl subroutine from yo' C program"
To call individual Perl subroutines, you can use any of tha \fBcall_*\fR
functions documented up in perlcall.
In dis example we'll use \f(CW\*(C`call_argv\*(C'\fR.
.PP
Thatz shown below, up in a program I be bout ta call \fIshowtime.c\fR.
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreta *my_perl;
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        char *args[] = { NULL };
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&
\&        perl_parse(my_perl, NULL, argc, argv, NULL);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&        /*** skippin perl_run() ***/
\&
\&        call_argv("showtime", G_DISCARD | G_NOARGS, args);
\&
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
where \fIshowtime\fR be a Perl subroutine dat takes no arguments (thatz the
\&\fIG_NOARGS\fR) n' fo' which I be bout ta ignore tha return value (thatz the
\&\fIG_DISCARD\fR).  Those flags, n' others, is discussed up in perlcall.
.PP
I be bout ta define tha \fIshowtime\fR subroutine up in a gangbangin' file called \fIshowtime.pl\fR:
.PP
.Vb 1
\&    print "I shan\*(Aqt be printed.";
\&
\&    sub showtime {
\&        print time;
\&    }
.Ve
.PP
Simple enough cause I gots dem finger-lickin' chickens wit tha siz-auce.  Now compile n' run:
.PP
.Vb 1
\&    % cc \-o showtime showtime.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % showtime showtime.pl
\&    818284590
.Ve
.PP
yieldin tha number of secondz dat elapsed between January 1, 1970
(the beginnin of tha Unix epoch), n' tha moment I fuckin started freestylin this
sentence.
.PP
In dis particular case our phat asses don't gotta call \fIperl_run\fR, as we set 
the PL_exit_flag \s-1PERL_EXIT_DESTRUCT_END\s0 which executes \s-1END\s0 blocks in
perl_destruct.
.PP
If you wanna pass arguments ta tha Perl subroutine, you can add
strings ta tha \f(CW\*(C`NULL\*(C'\fR\-terminated \f(CW\*(C`args\*(C'\fR list passed to
\&\fIcall_argv\fR.  For other data types, or ta examine return joints,
yo dirty ass is gonna need ta manipulate tha Perl stack.  Thatz demonstrated in
\&\*(L"Fiddlin wit tha Perl stack from yo' C program\*(R".
.SS "Evaluatin a Perl statement from yo' C program"
.IX Subsection "Evaluatin a Perl statement from yo' C program"
Perl serves up two \s-1API\s0 functions ta evaluate piecez of Perl code.
These is \*(L"eval_sv\*(R" up in perlapi n' \*(L"eval_pv\*(R" up in perlapi.
.PP
Arguably, these is tha only routines you gonna eva need ta execute
snippetz of Perl code from within yo' C program.  Yo crazy-ass code can be as
long as you wish; it can contain multiple statements; it can employ
\&\*(L"use\*(R" up in perlfunc, \*(L"require\*(R" up in perlfunc, n' \*(L"do\*(R" up in perlfunc to
include external Perl files.
.PP
\&\fIeval_pv\fR lets our asses evaluate individual Perl strings, n' then
extract variablez fo' coercion tha fuck into C types.  Da followin program,
\&\fIstring.c\fR, executes three Perl strings, extractin a \f(CW\*(C`int\*(C'\fR from
the first, a \f(CW\*(C`float\*(C'\fR from tha second, n' a \f(CW\*(C`char *\*(C'\fR from tha third.
.PP
.Vb 2
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&
\&   static PerlInterpreta *my_perl;
\&
\&   main (int argc, char **argv, char **env)
\&   {
\&       char *embedding[] = { "", "\-e", "0" };
\&
\&       PERL_SYS_INIT3(&argc,&argv,&env);
\&       my_perl = perl_alloc();
\&       perl_construct( my_perl );
\&
\&       perl_parse(my_perl, NULL, 3, embedding, NULL);
\&       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&       perl_run(my_perl);
\&
\&       /** Treat $a as a integer **/
\&       eval_pv("$a = 3; $a **= 2", TRUE);
\&       printf("a = %d\en", SvIV(get_sv("a", 0)));
\&
\&       /** Treat $a as a gangbangin' float **/
\&       eval_pv("$a = 3.14; $a **= 2", TRUE);
\&       printf("a = %f\en", SvNV(get_sv("a", 0)));
\&
\&       /** Treat $a as a strang **/
\&       eval_pv("$a = \*(AqrekcaH lreP rehtonA tsuJ\*(Aq; $a = reverse($a);", TRUE);
\&       printf("a = %s\en", SvPV_nolen(get_sv("a", 0)));
\&
\&       perl_destruct(my_perl);
\&       perl_free(my_perl);
\&       PERL_SYS_TERM();
\&   }
.Ve
.PP
All of dem strange functions wit \fIsv\fR up in they names help convert Perl scalars ta C types.  They're busted lyrics bout up in perlguts n' perlapi.
.PP
If you compile n' run \fIstring.c\fR, you gonna peep tha thangs up in dis biatch of using
\&\fI\fISvIV()\fI\fR ta create a \f(CW\*(C`int\*(C'\fR, \fI\fISvNV()\fI\fR ta create a \f(CW\*(C`float\*(C'\fR, and
\&\fI\fISvPV()\fI\fR ta create a string:
.PP
.Vb 3
\&   a = 9
\&   a = 9.859600
\&   a = Just Another Perl Hacker
.Ve
.PP
In tha example above, we've pimped a global variable ta temporarily
store tha computed value of our eval'ed expression. I aint talkin' bout chicken n' gravy biatch.  It be also
possible n' up in most cases a funky-ass betta game ta fetch tha return value
from \fI\fIeval_pv()\fI\fR instead. Y'all KNOW dat shit, muthafucka!  Example:
.PP
.Vb 4
\&   ...
\&   SV *val = eval_pv("reverse \*(AqrekcaH lreP rehtonA tsuJ\*(Aq", TRUE);
\&   printf("%s\en", SvPV_nolen(val));
\&   ...
.Ve
.PP
This way, we avoid namespace bullshit by not bustin global
variablez n' we've simplified our code as well.
.SS "Performin Perl pattern matches n' substitutions from yo' C program"
.IX Subsection "Performin Perl pattern matches n' substitutions from yo' C program"
Da \fI\fIeval_sv()\fI\fR function lets our asses evaluate stringz of Perl code, so we can
define some functions dat use it ta \*(L"specialize\*(R" up in matches and
substitutions: \fI\fImatch()\fI\fR, \fI\fIsubstitute()\fI\fR, n' \fI\fImatches()\fI\fR.
.PP
.Vb 1
\&   I32 match(SV *string, char *pattern);
.Ve
.PP
Given a strang n' a pattern (e.g., \f(CW\*(C`m/clasp/\*(C'\fR or \f(CW\*(C`/\eb\ew*\eb/\*(C'\fR, which
in yo' C program might step tha fuck up as \*(L"/\e\eb\e\ew*\e\eb/\*(R"), \fImatch()\fR
returns 1 if tha strang matches tha pattern n' 0 otherwise.
.PP
.Vb 1
\&   int substitute(SV **string, char *pattern);
.Ve
.PP
Given a pointa ta a \f(CW\*(C`SV\*(C'\fR n' a \f(CW\*(C`=~\*(C'\fR operation (e.g.,
\&\f(CW\*(C`s/bob/robert/g\*(C'\fR or \f(CW\*(C`tr[A\-Z][a\-z]\*(C'\fR), \fIsubstitute()\fR modifies tha string
within tha \f(CW\*(C`SV\*(C'\fR as accordin ta tha operation, returnin tha number of substitutions
made.
.PP
.Vb 1
\&   int matches(SV *string, char *pattern, AV **matches);
.Ve
.PP
Given a \f(CW\*(C`SV\*(C'\fR, a pattern, n' a pointa ta a empty \f(CW\*(C`AV\*(C'\fR,
\&\fImatches()\fR evaluates \f(CW\*(C`$strin =~ $pattern\*(C'\fR up in a list context, and
fills up in \fImatches\fR wit tha array elements, returnin tha number of matches found.
.PP
Herez a sample program, \fImatch.c\fR, dat uses all three (long lines have
been wrapped here):
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& static PerlInterpreta *my_perl;
\&
\& /** my_eval_sv(code, error_check)
\& ** kinda like eval_sv(), 
\& ** but we pop tha return value off tha stack 
\& **/
\& SV* my_eval_sv(SV *sv, I32 croak_on_error)
\& {
\&     dSP;
\&     SV* retval;
\&
\&
\&     PUSHMARK(SP);
\&     eval_sv(sv, G_SCALAR);
\&
\&     SPAGAIN;
\&     retval = POPs;
\&     PUTBACK;
\&
\&     if (croak_on_error && SvTRUE(ERRSV))
\&        croak(SvPVx_nolen(ERRSV));
\&
\&     return retval;
\& }
\&
\& /** match(string, pattern)
\& **
\& ** Used fo' matches up in a scalar context.
\& **
\& ** Returns 1 if tha match was successful; 0 otherwise.
\& **/
\&
\& I32 match(SV *string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "my $strin = \*(Aq%s\*(Aq; $strin =~ %s",
\&              SvPV_nolen(string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     return SvIV(retval);
\& }
\&
\& /** substitute(string, pattern)
\& **
\& ** Used fo' =~ operations dat modify they left\-hand side (s/// n' tr///)
\& **
\& ** Returns tha number of successful matches, and
\& ** modifies tha input strang if there was any.
\& **/
\&
\& I32 substitute(SV **string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "$strin = \*(Aq%s\*(Aq; ($strin =~ %s)",
\&              SvPV_nolen(*string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *strin = get_sv("string", 0);
\&     return SvIV(retval);
\& }
\&
\& /** matches(string, pattern, matches)
\& **
\& ** Used fo' matches up in a list context.
\& **
\& ** Returns tha number of matches,
\& ** n' fills up in **matches wit tha matchin substrings
\& **/
\&
\& I32 matches(SV *string, char *pattern, AV **match_list)
\& {
\&     SV *command = newSV(0);
\&     I32 num_matches;
\&
\&     sv_setpvf(command, "my $strin = \*(Aq%s\*(Aq; @array = ($strin =~ %s)",
\&              SvPV_nolen(string), pattern);
\&
\&     my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *match_list = get_av("array", 0);
\&     num_matches = av_top_index(*match_list) + 1;
\&
\&     return num_matches;
\& }
\&
\& main (int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "\-e", "0" };
\&     AV *match_list;
\&     I32 num_matches, i;
\&     SV *text;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     my_perl = perl_alloc();
\&     perl_construct(my_perl);
\&     perl_parse(my_perl, NULL, 3, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&     text = newSV(0);
\&     sv_setpv(text, "When he be at a cold-ass lil convenience store n' tha "
\&        "bill comes ta some amount like 76 cents, Maynard is "
\&        "aware dat there is suttin' he *should* do, suttin' "
\&        "that will enable his ass ta git back a quarter yo, but dat schmoooove muthafucka has "
\&        "no scam *what*.  Dude fumblez all up in his bangin red squeezey "
\&        "changepurse n' gives tha pimp three extra pennies wit "
\&        "his dollar, hopin dat he might luck tha fuck into tha erect "
\&        "amount.  Da pimp gives his ass back two of his own pennies "
\&        "and then tha big-ass shiny quarta dat is his thugged-out lil' prize. "
\&        "\-RICHH");
\&
\&     if (match(text, "m/quarter/")) /** Do text contain \*(Aqquarter\*(Aq, biatch? **/
\&        printf("match: Text gotz nuff tha word \*(Aqquarter\*(Aq.\en\en");
\&     else
\&        printf("match: Text don\*(Aqt contain tha word \*(Aqquarter\*(Aq.\en\en");
\&
\&     if (match(text, "m/eighth/")) /** Do text contain \*(Aqeighth\*(Aq, biatch? **/
\&        printf("match: Text gotz nuff tha word \*(Aqeighth\*(Aq.\en\en");
\&     else
\&        printf("match: Text don\*(Aqt contain tha word \*(Aqeighth\*(Aq.\en\en");
\&
\&     /** Match all occurrencez of /wi../ **/
\&     num_matches = matches(text, "m/(wi..)/g", &match_list);
\&     printf("matches: m/(wi..)/g found %d matches...\en", num_matches);
\&
\&     fo' (i = 0; i < num_matches; i++)
\&        printf("match: %s\en", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
\&     printf("\en");
\&
\&     /** Remove all vowels from text **/
\&     num_matches = substitute(&text, "s/[aeiou]//gi");
\&     if (num_matches) {
\&        printf("substitute: s/[aeiou]//gi...%d substitutions made.\en",
\&               num_matches);
\&        printf("Now text is: %s\en\en", SvPV_nolen(text));
\&     }
\&
\&     /** Attempt a substitution **/
\&     if (!substitute(&text, "s/Perl/C/")) {
\&        printf("substitute: s/Perl/C...No substitution made.\en\en");
\&     }
\&
\&     SvREFCNT_dec(text);
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
which produces tha output (again, long lines done been wrapped here)
.PP
.Vb 1
\&   match: Text gotz nuff tha word \*(Aqquarter\*(Aq.
\&
\&   match: Text don\*(Aqt contain tha word \*(Aqeighth\*(Aq.
\&
\&   matches: m/(wi..)/g found 2 matches...
\&   match: will
\&   match: with
\&
\&   substitute: s/[aeiou]//gi...139 substitutions made.
\&   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
\&   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
\&   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
\&   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
\&   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. \-RCHH
\&
\&   substitute: s/Perl/C...No substitution made.
.Ve
.SS "Fiddlin wit tha Perl stack from yo' C program"
.IX Subsection "Fiddlin wit tha Perl stack from yo' C program"
When tryin ta explain stacks, most computa science textbooks mumble
suttin' bout spring-loaded columnz of cafeteria plates: tha last
thang you pushed on tha stack is tha straight-up original gangsta thang you pop off.  That'll
do fo' our purposes: yo' C program will push some arguments onto \*(L"the Perl
stack\*(R", shut its eyes while some magic happens, n' then pop the
results\*(--the return value of yo' Perl subroutine\*(--off tha stack.
.PP
First you gonna need ta know how tha fuck ta convert between C types n' Perl
types, wit \fInewSViv()\fR n' \fIsv_setnv()\fR n' \fInewAV()\fR n' all their
friends.  They're busted lyrics bout up in perlguts n' perlapi.
.PP
Then you gonna need ta know how tha fuck ta manipulate tha Perl stack.  That's
busted lyrics bout up in perlcall.
.PP
Once you've understood them, embeddin Perl up in C is easy as fuck .
.PP
Because C has no builtin function fo' integer exponentiation, let's
make Perlz ** operator available ta it (this is less useful than it
sounds, cuz Perl implements ** wit Cz \fI\fIpow()\fI\fR function).  First
I be bout ta create a stub exponentiation function up in \fIpower.pl\fR:
.PP
.Vb 4
\&    sub expo {
\&        mah ($a, $b) = @_;
\&        return $a ** $b;
\&    }
.Ve
.PP
Now I be bout ta create a C program, \fIpower.c\fR, wit a gangbangin' function
\&\fI\fIPerlPower()\fI\fR dat gotz nuff all tha perlguts necessary ta push the
two arguments tha fuck into \fI\fIexpo()\fI\fR n' ta pop tha return value out.  Take a
deep breath...
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreta *my_perl;
\&
\&    static void
\&    PerlPower(int a, int b)
\&    {
\&      dSP;                            /* initialize stack pointa      */
\&      ENTER;                          /* every last muthafuckin thang pimped afta here */
\&      SAVETMPS;                       /* ...is a temporary variable.   */
\&      PUSHMARK(SP);                   /* remember tha stack pointa    */
\&      XPUSHs(sv_2mortal(newSViv(a))); /* push tha base onto tha stack  */
\&      XPUSHs(sv_2mortal(newSViv(b))); /* push tha exponent onto stack  */
\&      PUTBACK;                      /* make local stack pointa global */
\&      call_pv("expo", G_SCALAR);      /* call tha function             */
\&      SPAGAIN;                        /* refresh stack pointa         */
\&                                    /* pop tha return value from stack */
\&      printf ("%d ta tha %dth juice is %d.\en", a, b, POPi);
\&      PUTBACK;
\&      FREETMPS;                       /* free dat return value        */
\&      LEAVE;                       /* ...and tha XPUSHed "mortal" args.*/
\&    }
\&
\&    int main (int argc, char **argv, char **env)
\&    {
\&      char *my_argv[] = { "", "power.pl" };
\&
\&      PERL_SYS_INIT3(&argc,&argv,&env);
\&      my_perl = perl_alloc();
\&      perl_construct( my_perl );
\&
\&      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
\&      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&      perl_run(my_perl);
\&
\&      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
\&
\&      perl_destruct(my_perl);
\&      perl_free(my_perl);
\&      PERL_SYS_TERM();
\&    }
.Ve
.PP
Compile n' run:
.PP
.Vb 1
\&    % cc \-o juice power.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % power
\&    3 ta tha 4th juice is 81.
.Ve
.SS "Maintainin a persistent interpreter"
.IX Subsection "Maintainin a persistent interpreter"
When pimpin interactizzle and/or potentially long-running
applications, itz a phat scam ta maintain a persistent interpreter
rather than allocatin n' constructin a freshly smoked up interpreta multiple
times.  Da major reason is speed: since Perl will only be loaded into
memory once.
.PP
But fuck dat shiznit yo, tha word on tha street is dat you gotta be mo' cautious wit namespace n' variable
scopin when rockin a persistent interpreter n' shit.  In previous examples
we've been rockin global variablez up in tha default package \f(CW\*(C`main\*(C'\fR.  We
knew exactly what tha fuck code would be run, n' assumed we could avoid
variable collisions n' outrageous symbol table growth.
.PP
Letz say yo' application be a server dat will occasionally run Perl
code from some arbitrary file.  Yo crazy-ass server has no way of knowin what
code itz goin ta run. I aint talkin' bout chicken n' gravy biatch.  Straight-up dangerous.
.PP
If tha file is pulled up in by \f(CW\*(C`perl_parse()\*(C'\fR, compiled tha fuck into a newly
constructed interpreter, n' subsequently cleaned up with
\&\f(CW\*(C`perl_destruct()\*(C'\fR afterwards, you shielded from most namespace
shits.
.PP
One way ta avoid namespace collisions up in dis scenario is ta translate
the filename tha fuck into a guaranteed-unique package name, n' then compile
the code tha fuck into dat package rockin \*(L"eval\*(R" up in perlfunc.  In tha example
below, each file will only be compiled once.  Or, tha application
might chizzle ta clean up tha symbol table associated wit tha file
afta itz no longer needed. Y'all KNOW dat shit, muthafucka!  Usin \*(L"call_argv\*(R" up in perlapi, We bout ta
call tha subroutine \f(CW\*(C`Embed::Persistent::eval_file\*(C'\fR which lives up in the
file \f(CW\*(C`persistent.pl\*(C'\fR n' pass tha filename n' boolean cleanup/cache
flag as arguments.
.PP
Note dat tha process will continue ta grow fo' each file dat it
uses.  In addition, there might be \f(CW\*(C`AUTOLOAD\*(C'\fRed subroutines n' other
conditions dat cause Perlz symbol table ta grow.  Yo ass might want to
add some logic dat keeps track of tha process size, or restarts
itself afta a cold-ass lil certain number of requests, ta ensure dat memory
consumption is minimized. Y'all KNOW dat shit, muthafucka!  You'll also wanna scope yo' variables
with \*(L"my\*(R" up in perlfunc whenever possible.
.PP
.Vb 2
\& package Embed::Persistent;
\& #persistent.pl
\&
\& use strict;
\& our %Cache;
\& use Symbol qw(delete_package);
\&
\& sub valid_package_name {
\&     my($string) = @_;
\&     $strin =~ s/([^A\-Za\-z0\-9\e/])/sprintf("_%2x",unpack("C",$1))/eg;
\&     # second pass only fo' lyrics startin wit a gangbangin' finger-lickin' digit
\&     $strin =~ s|/(\ed)|sprintf("/_%2x",unpack("C",$1))|eg;
\&
\&     # Dress it up as a real package name
\&     $strin =~ s|/|::|g;
\&     return "Embed" . $string;
\& }
\&
\& sub eval_file {
\&     my($filename, $delete) = @_;
\&     mah $package = valid_package_name($filename);
\&     mah $mtime = \-M $filename;
\&     if(defined $Cache{$package}{mtime}
\&        &&
\&        $Cache{$package}{mtime} <= $mtime)
\&     {
\&        # our crazy asses have compiled dis subroutine already,
\&        # it has not been updated on disk, not a god damn thang left ta do
\&        print STDERR "already compiled $package\->handlez\en";
\&     }
\&     else {
\&        local *FH;
\&        open FH, $filename or take a thugged-out dirtnap "open \*(Aq$filename\*(Aq $!";
\&        local($/) = undef;
\&        mah $sub = <FH>;
\&        close FH;
\&
\&        #wrap tha code tha fuck into a subroutine inside our unique package
\&        mah $eval = qq{package $package; sub handlez { $sub; }};
\&        {
\&            # hide our variablez within dis block
\&            my($filename,$mtime,$package,$sub);
\&            eval $eval;
\&        }
\&        take a thugged-out dirtnap $@ if $@;
\&
\&        #cache it unless we\*(Aqre cleanin up each time
\&        $Cache{$package}{mtime} = $mtime unless $delete;
\&     }
\&
\&     eval {$package\->handlez;};
\&     take a thugged-out dirtnap $@ if $@;
\&
\&     delete_package($package) if $delete;
\&
\&     #take a look if you want
\&     #print Devel::Symdump\->rnew($package)\->as_string, $/;
\& }
\&
\& 1;
\&
\& _\|_END_\|_
\&
\& /* persistent.c */
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* 1 = clean up filename\*(Aqs symbol table afta each request, 0 = don\*(Aqt */
\& #ifndef DO_CLEAN
\& #define DO_CLEAN 0
\& #endif
\&
\& #define BUFFER_SIZE 1024
\&
\& static PerlInterpreta *my_perl = NULL;
\&
\& int
\& main(int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "persistent.pl" };
\&     char *args[] = { "", DO_CLEAN, NULL };
\&     char filename[BUFFER_SIZE];
\&     int exitstatus = 0;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     if((my_perl = perl_alloc()) == NULL) {
\&        fprintf(stderr, "no memory!");
\&        exit(1);
\&     }
\&     perl_construct(my_perl);
\&
\&     PL_origalen = 1; /* don\*(Aqt let $0 assignment update tha proctitle or embedding[0] */
\&     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&     if(!exitstatus) {
\&        exitstatus = perl_run(my_perl);
\&
\&        while(printf("Enta file name: ") &&
\&              fgets(filename, BUFFER_SIZE, stdin)) {
\&
\&            filename[strlen(filename)\-1] = \*(Aq\e0\*(Aq; /* strip \en */
\&            /* call tha subroutine, passin it tha filename as a argument */
\&            args[0] = filename;
\&            call_argv("Embed::Persistent::eval_file",
\&                           G_DISCARD | G_EVAL, args);
\&
\&            /* check $@ */
\&            if(SvTRUE(ERRSV))
\&                fprintf(stderr, "eval error: %s\en", SvPV_nolen(ERRSV));
\&        }
\&     }
\&
\&     PL_perl_destruct_level = 0;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\&     exit(exitstatus);
\& }
.Ve
.PP
Now compile:
.PP
.Vb 1
\& % cc \-o persistent persistent.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Herez a example script file:
.PP
.Vb 3
\& #test.pl
\& mah $strin = "hello";
\& foo($string);
\&
\& sub foo {
\&     print "foo says: @_\en";
\& }
.Ve
.PP
Now run:
.PP
.Vb 7
\& % persistent
\& Enta file name: test.pl
\& foo says: hello
\& Enta file name: test.pl
\& already compiled Embed::test_2epl\->handlez
\& foo says: hello
\& Enta file name: ^C
.Ve
.SS "Execution of \s-1END\s0 blocks"
.IX Subsection "Execution of END blocks"
Traditionally \s-1END\s0 blocks done been executed all up in tha end of tha perl_run.
This causes problems fo' applications dat never call perl_run. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since
perl 5.7.2 you can specify \f(CW\*(C`PL_exit_flags |= PERL_EXIT_DESTRUCT_END\*(C'\fR
to git tha freshly smoked up behaviour. Shiiit, dis aint no joke. This also enablez tha hustlin of \s-1END\s0 blocks if
the perl_parse fails n' \f(CW\*(C`perl_destruct\*(C'\fR will return tha exit value.
.ie n .SS "$0 assignments"
.el .SS "\f(CW$0\fP assignments"
.IX Subsection "$0 assignments"
When a perl script assigns a value ta \f(CW$0\fR then tha perl runtime will
try ta make dis value show up as tha program name reported by \*(L"ps\*(R" by
uppimpin tha memory pointed ta by tha argv passed ta \fIperl_parse()\fR and
also callin \s-1API\s0 functions like \fIsetproctitle()\fR where available.  This
behaviour might not be appropriate when embeddin perl n' can be
disabled by assignin tha value \f(CW1\fR ta tha variable \f(CW\*(C`PL_origalen\*(C'\fR
before \fIperl_parse()\fR is called.
.PP
Da \fIpersistent.c\fR example above is fo' instizzle likely ta segfault
when \f(CW$0\fR be assigned ta if tha \f(CW\*(C`PL_origalen = 1;\*(C'\fR assignment is
removed. Y'all KNOW dat shit, muthafucka!  This cuz perl will try ta write ta tha read only memory
of tha \f(CW\*(C`embedding[]\*(C'\fR strings.
.SS "Maintainin multiple interpreta instances"
.IX Subsection "Maintainin multiple interpreta instances"
Some rare applications will need ta create mo' than one interpreter
durin a session. I aint talkin' bout chicken n' gravy biatch.  Such a application might sporadically decizzle to
release any resources associated wit tha interpreter.
.PP
Da program must take care ta ensure dat dis takes place \fIbefore\fR
the next interpreta is constructed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  By default, when perl is not
built wit any special options, tha global variable
\&\f(CW\*(C`PL_perl_destruct_level\*(C'\fR is set ta \f(CW0\fR, since extra cleanin aint
usually needed when a program only eva creates a single interpreter
in its entire gametime.
.PP
Settin \f(CW\*(C`PL_perl_destruct_level\*(C'\fR ta \f(CW1\fR make every last muthafuckin thang squeaky clean:
.PP
.Vb 10
\& while(1) {
\&     ...
\&     /* reset global variablez here wit PL_perl_destruct_level = 1 */
\&     PL_perl_destruct_level = 1;
\&     perl_construct(my_perl);
\&     ...
\&     /* clean n' reset _everything_ durin perl_destruct */
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     ...
\&     /* let\*(Aqs go do it again! */
\& }
.Ve
.PP
When \fI\fIperl_destruct()\fI\fR is called, tha interpreterz syntax parse tree
and symbol tablez is cleaned up, n' global variablez is reset.  The
second assignment ta \f(CW\*(C`PL_perl_destruct_level\*(C'\fR is needed cuz
perl_construct resets it ta \f(CW0\fR.
.PP
Now suppose our crazy asses have mo' than one interpreta instizzle hustlin at the
same time.  This is feasible yo, but only if you used tha Configure option
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR or tha options \f(CW\*(C`\-Dusethreadz \-Duseithreads\*(C'\fR when
buildin perl.  By default, enablin one of these Configure options
sets tha per-interpreta global variable \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to
\&\f(CW1\fR, so dat thorough cleanin be automatic n' interpreta variables
are initialized erectly.  Even if you don't intend ta run two or
more interpretas all up in tha same time yo, but ta run dem sequentially, like
in tha above example, it is recommended ta build perl wit the
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR option otherwise some interpreta variablez may
not be initialized erectly between consecutizzle runs n' your
application may crash.
.PP
See also \*(L"Thread-aware system intercourses\*(R" up in perlxs.
.PP
Usin \f(CW\*(C`\-Dusethreadz \-Duseithreads\*(C'\fR rather than \f(CW\*(C`\-Dusemultiplicity\*(C'\fR
is mo' appropriate if you intend ta run multiple interpreters
concurrently up in different threads, cuz it enablez support for
linkin up in tha thread librariez of yo' system wit tha interpreter.
.PP
Letz give it a try:
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* we\*(Aqre goin ta embed two interpretas */
\&
\& #define SAY_HELLO "\-e", "print qq(Yea muthafucka, I\*(Aqm $^X\en)"
\&
\& int main(int argc, char **argv, char **env)
\& {
\&     PerlInterpreta *one_perl, *two_perl;
\&     char *one_args[] = { "one_perl", SAY_HELLO };
\&     char *two_args[] = { "two_perl", SAY_HELLO };
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     one_perl = perl_alloc();
\&     two_perl = perl_alloc();
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_construct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_construct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_run(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_run(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_destruct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_destruct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_free(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_free(two_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
Note tha calls ta \s-1\fIPERL_SET_CONTEXT\s0()\fR.  These is necessary ta initialize
the global state dat tracks which interpreta is tha \*(L"current\*(R" one on
the particular process or thread dat may be hustlin dat shit.  It should
always be used if you have mo' than one interpreta n' is making
perl \s-1API\s0 calls on both interpretas up in a interleaved fashion.
.PP
\&\s-1PERL_SET_CONTEXT\s0(interp) should also be called whenever \f(CW\*(C`interp\*(C'\fR is
used by a thread dat did not create it (usin either \fIperl_alloc()\fR, or
the mo' esoteric \fIperl_clone()\fR).
.PP
Compile as usual:
.PP
.Vb 1
\& % cc \-o multiplicitizzle multiplicity.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Run it, Run it:
.PP
.Vb 3
\& % multiplicity
\& Yea muthafucka, I\*(Aqm one_perl
\& Yea muthafucka, I\*(Aqm two_perl
.Ve
.SS "Usin Perl modules, which theyselves use C libraries, from yo' C program"
.IX Subsection "Usin Perl modules, which theyselves use C libraries, from yo' C program"
If you've played wit tha examplez above n' tried ta embed a script
that \fI\fIuse()\fI\fRs a Perl module (like fuckin \fISocket\fR) which itself uses a C or \*(C+ library,
this probably happened:
.PP
.Vb 3
\& Can\*(Aqt load module Socket, dynamic loadin not available up in dis perl.
\&  (Yo ass may need ta build a freshly smoked up perl executable which either supports
\&  dynamic loadin or has tha Socket module statically linked tha fuck into dat shit.)
.Ve
.PP
Whatz wrong?
.PP
Yo crazy-ass interpreta don't give a fuck how tha fuck ta rap wit these extensions
on its own. I aint talkin' bout chicken n' gravy biatch.  A lil glue will help.  Up until now you've been
callin \fI\fIperl_parse()\fI\fR, handin it \s-1NULL\s0 fo' tha second argument:
.PP
.Vb 1
\& perl_parse(my_perl, NULL, argc, my_argv, NULL);
.Ve
.PP
Thatz where tha glue code can be banged ta create tha initial contact between
Perl n' linked C/\*(C+ routines.  Letz take a look some piecez of \fIperlmain.c\fR
to peep how tha fuck Perl do this:
.PP
.Vb 1
\& static void xs_init (pTHX);
\&
\& EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
\& EXTERN_C void boot_Socket (pTHX_ CV* cv);
\&
\&
\& EXTERN_C void
\& xs_init(pTHX)
\& {
\&        char *file = _\|_FILE_\|_;
\&        /* DynaLoader be a special case */
\&        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
\&        newXS("Socket::bootstrap", boot_Socket, file);
\& }
.Ve
.PP
Simply put: fo' each extension linked wit yo' Perl executable
(determined durin its initial configuration on your
computa or when addin a freshly smoked up extension),
a Perl subroutine is pimped ta incorporate tha extension's
routines.  Normally, dat subroutine is named
\&\fI\fIModule::bootstrap()\fI\fR n' is invoked when you say \fIuse Module\fR.  In
turn, dis hooks tha fuck into a \s-1XSUB, \s0\fIboot_Module\fR, which creates a Perl
counterpart fo' each of tha extensionz XSUBs.  Don't worry bout this
part; leave dat ta tha \fIxsubpp\fR n' extension authors.  If your
extension is dynamically loaded, DynaLoader creates \fI\fIModule::bootstrap()\fI\fR
for you on tha fly.  In fact, if you gotz a hustlin DynaLoader then there
is rarely any need ta link up in any other extensions statically.
.PP
Once you have dis code, slap it tha fuck into tha second argument of \fI\fIperl_parse()\fI\fR:
.PP
.Vb 1
\& perl_parse(my_perl, xs_init, argc, my_argv, NULL);
.Ve
.PP
Then compile:
.PP
.Vb 1
\& % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\& % interp
\&   use Socket;
\&   use SomeDynamicallyLoadedModule;
\&
\&   print "Now I can use extensions!\en"\*(Aq
.Ve
.PP
\&\fBExtUtils::Embed\fR can also automate freestylin tha \fIxs_init\fR glue code.
.PP
.Vb 4
\& % perl \-MExtUtils::Embed \-e xsinit \-\- \-o perlxsi.c
\& % cc \-c perlxsi.c \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-c interp.c  \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-o interp perlxsi.o interp.o \`perl \-MExtUtils::Embed \-e ldopts\`
.Ve
.PP
Consult perlxs, perlguts, n' perlapi fo' mo' details.
.SH "Hidin Perl_"
.IX Header "Hidin Perl_"
If you straight-up hide tha short formz of tha Perl hood \s-1API,\s0
add \-DPERL_NO_SHORT_NAMES ta tha compilation flags.  This means that
for example instead of writing
.PP
.Vb 1
\&    warn("%d bottlez of brew on tha wall", bottlecount);
.Ve
.PP
you will gotta write tha explicit full form
.PP
.Vb 1
\&    Perl_warn(aTHX_ "%d bottlez of brew on tha wall", bottlecount);
.Ve
.PP
(See \*(L"Background n' \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 up in perlguts fo' tha explanation
of tha \f(CW\*(C`aTHX_\*(C'\fR. )  Hidin tha short forms is straight-up useful fo' avoiding
all sortz of nasty (C preprocessor or otherwise) conflicts wit other
software packages (Perl defines bout 2400 APIs wit these short names,
take or leave few hundred, so there certainly is room fo' conflict.)
.SH "MORAL"
.IX Header "MORAL"
Yo ass can sometimes \fIwrite fasta code\fR up in C yo, but
you can always \fIwrite code faster\fR up in Perl.  Because you can use
each from tha other, combine dem as you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jizzle Orwant <\fIorwant@media.mit.edu\fR> n' Doug MacEachern
<\fIdougm@covalent.net\fR>, wit lil' small-ass contributions from Slim Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, n' Ilya
Zakharevich.
.PP
Doug MacEachern has a article on embeddin up in Volume 1, Issue 4 of
Da Perl Journal ( http://www.tpj.com/ ).  Doug be also tha pimper of the
most widely-used Perl embedding: tha mod_perl system
(perl.apache.org), which embedz Perl up in tha Apache wizzy server.
Oracle, Binary Evolution, ActiveState, n' Lil' Bow Wow Sugarss nsapi_perl
have used dis model fo' Oracle, Netscape n' Internizzle Information
Server Perl plugins.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern n' Jizzle Orwant.  All
Rights Reserved.
.PP
This document may be distributed under tha same terms as Perl itself.
