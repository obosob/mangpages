.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERN 1"
.TH PERLINTERN 1 "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintern \- autogenerated documentation of purely internal
		 Perl functions
.SH "DESCRIPTION"
.IX Xref "internal Perl functions interpreta functions"
.IX Header "DESCRIPTION"
This file is tha autogenerated documentation of functions up in the
Perl interpreta dat is documented rockin Perlz internal documentation
format but is not marked as part of tha Perl \s-1API.\s0 In other lyrics,
\&\fBthey is not fo' use up in extensions\fR!
.SH "Compile-time scope hooks"
.IX Header "Compile-time scope hooks"
.IP "BhkENTRY" 8
.IX Xref "BhkENTRY"
.IX Item "BhkENTRY"
Return a entry from tha \s-1BHK\s0 structure. \fIwhich\fR be a preprocessor token
indicatin which entry ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If tha appropriate flag aint set
this will return \s-1NULL.\s0 Da type of tha return value dependz on which
entry you ask for.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void *  BhkENTRY(BHK *hk, which)
.Ve
.IP "BhkFLAGS" 8
.IX Xref "BhkFLAGS"
.IX Item "BhkFLAGS"
Return tha \s-1BHK\s0z flags.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        U32     BhkFLAGS(BHK *hk)
.Ve
.IP "\s-1CALL_BLOCK_HOOKS \s0" 8
.IX Xref "CALL_BLOCK_HOOKS"
.IX Item "CALL_BLOCK_HOOKS "
Call all tha registered block hooks fo' type \fIwhich\fR. \fIwhich\fR be a
preprocessin token; tha type of \fIarg\fR dependz on \fIwhich\fR.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    CALL_BLOCK_HOOKS(which, arg)
.Ve
.SH "CV reference counts n' CvOUTSIDE"
.IX Header "CV reference counts n' CvOUTSIDE"
.IP "CvWEAKOUTSIDE" 8
.IX Xref "CvWEAKOUTSIDE"
.IX Item "CvWEAKOUTSIDE"
Each \s-1CV\s0 has a pointer, \f(CW\*(C`CvOUTSIDE()\*(C'\fR, ta its lexically enclosing
\&\s-1CV \s0(if any). Because pointas ta anonymous sub prototypes are
stored up in \f(CW\*(C`&\*(C'\fR pad slots, it aint nuthin but a possible ta git a cold-ass lil circular reference,
with tha parent pointin ta tha lil pimp n' vice-versa. To avoid the
ensuin memory leak, our phat asses do not increment tha reference count of tha \s-1CV\s0
pointed ta by \f(CW\*(C`CvOUTSIDE\*(C'\fR up in tha \fIone specific instance\fR dat tha parent
has a \f(CW\*(C`&\*(C'\fR pad slot pointin back ta us. In dis case, we set the
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR flag up in tha child. Y'all KNOW dat shit, muthafucka! This allows our asses ta determine under what
circumstances we should decrement tha refcount of tha parent when freeing
the child.
.Sp
There be a gangbangin' further complication wit non-closure anonymous subs (i.e. them
that do not refer ta any lexicals outside dat sub). In dis case, the
anonymous prototype is shared rather than bein cloned. Y'all KNOW dat shit, muthafucka! This has the
consequence dat tha parent may be freed while there be still active
children, eg
.Sp
.Vb 1
\&    BEGIN { $a = sub { eval \*(Aq$x\*(Aq } }
.Ve
.Sp
In dis case, tha \s-1BEGIN\s0 is freed immediately afta execution since there
are no actizzle references ta it: tha anon sub prototype has
\&\f(CW\*(C`CvWEAKOUTSIDE\*(C'\fR set since it aint a cold-ass lil closure, n' \f(CW$a\fR points ta tha same
\&\s-1CV,\s0 so it don't contribute ta \s-1BEGIN\s0z refcount either n' shit.  When \f(CW$a\fR is
executed, tha \f(CW\*(C`eval \*(Aq$x\*(Aq\*(C'\fR causes tha chain of \f(CW\*(C`CvOUTSIDE\*(C'\fRs ta be followed,
and tha freed \s-1BEGIN\s0 be accessed.
.Sp
To avoid this, whenever a \s-1CV\s0 n' its associated pad is freed, any
\&\f(CW\*(C`&\*(C'\fR entries up in tha pad is explicitly removed from tha pad, n' if the
refcount of tha pointed-to anon sub is still positive, then that
childz \f(CW\*(C`CvOUTSIDE\*(C'\fR is set ta point ta its grandparent. This will only
occur up in tha single specific case of a non-closure anon prototype
havin one or mo' actizzle references (like fuckin \f(CW$a\fR above).
.Sp
One other thang ta consider is dat a \s-1CV\s0 may be merely undefined
rather than freed, eg \f(CW\*(C`undef &foo\*(C'\fR. In dis case, its refcount may
not have reached zero yo, but we still delete its pad n' its \f(CW\*(C`CvROOT\*(C'\fR etc.
Since various lil pimps may still have they \f(CW\*(C`CvOUTSIDE\*(C'\fR pointin at this
undefined \s-1CV,\s0 we keep its own \f(CW\*(C`CvOUTSIDE\*(C'\fR fo' tha time being, so that
the chain of lexical scopes is unbroken. I aint talkin' bout chicken n' gravy biatch. For example, tha following
should print 123:
.Sp
.Vb 5
\&    mah $x = 123;
\&    sub tmp { sub { eval \*(Aq$x\*(Aq } }
\&    mah $a = tmp();
\&    undef &tmp;
\&    print  $a\->();
\&
\&        bool    CvWEAKOUTSIDE(CV *cv)
.Ve
.SH "Embeddin Functions"
.IX Header "Embeddin Functions"
.IP "cv_dump" 8
.IX Xref "cv_dump"
.IX Item "cv_dump"
dump tha contentz of a \s-1CV\s0
.Sp
.Vb 1
\&        void    cv_dump(CV *cv, const char *title)
.Ve
.IP "cv_forget_slab" 8
.IX Xref "cv_forget_slab"
.IX Item "cv_forget_slab"
When a \s-1CV\s0 has a reference count on its slab (CvSLABBED), it is responsible
for makin shizzle it is freed. Y'all KNOW dat shit, muthafucka!  (Hence, no two CVs should eva have a
reference count on tha same slab.)  Da \s-1CV\s0 only need ta reference tha slab
durin compilation. I aint talkin' bout chicken n' gravy biatch.  Once it is compiled n' CvROOT attached, it has
finished its thang, so it can forget tha slab.
.Sp
.Vb 1
\&        void    cv_forget_slab(CV *cv)
.Ve
.IP "do_dump_pad" 8
.IX Xref "do_dump_pad"
.IX Item "do_dump_pad"
Dump tha contentz of a padlist
.Sp
.Vb 2
\&        void    do_dump_pad(I32 level, PerlIO *file,
\&                            PADLIST *padlist, int full)
.Ve
.IP "intro_my" 8
.IX Xref "intro_my"
.IX Item "intro_my"
\&\*(L"Introduce\*(R" mah variablez ta visible status.  This is called durin parsing
at tha end of each statement ta make lexical variablez visible to
subsequent statements.
.Sp
.Vb 1
\&        U32     intro_my()
.Ve
.IP "padlist_dup" 8
.IX Xref "padlist_dup"
.IX Item "padlist_dup"
Duplicates a pad.
.Sp
.Vb 2
\&        PADLIST * padlist_dup(PADLIST *srcpad,
\&                              CLONE_PARAMS *param)
.Ve
.IP "pad_alloc_name" 8
.IX Xref "pad_alloc_name"
.IX Item "pad_alloc_name"
Allocates a place up in tha currently-compiling
pad (via \*(L"pad_alloc\*(R" up in perlapi) and
then stores a name fo' dat entry.  \fInamesv\fR be adopted n' becomes the
name entry; it must already contain tha name strang n' be sufficiently
upgraded. Y'all KNOW dat shit, muthafucka!  \fItypestash\fR n' \fIourstash\fR n' tha \f(CW\*(C`padadd_STATE\*(C'\fR flag get
added ta \fInamesv\fR.  None of tha other
processin of \*(L"pad_add_name_pvn\*(R" up in perlapi
is done.  Returns tha offset of tha allocated pad slot.
.Sp
.Vb 2
\&        PADOFFSET pad_alloc_name(SV *namesv, U32 flags,
\&                                 HV *typestash, HV *ourstash)
.Ve
.IP "pad_block_start" 8
.IX Xref "pad_block_start"
.IX Item "pad_block_start"
Update tha pad compilation state variablez on entry ta a freshly smoked up block.
.Sp
.Vb 1
\&        void    pad_block_start(int full)
.Ve
.IP "pad_check_dup" 8
.IX Xref "pad_check_dup"
.IX Item "pad_check_dup"
Peep fo' duplicate declarations: report any of:
.Sp
.Vb 3
\&     * a mah up in tha current scope wit tha same name;
\&     * a our (anywhere up in tha pad) wit tha same name n' the
\&       same stash as C<ourstash>
.Ve
.Sp
\&\f(CW\*(C`is_our\*(C'\fR indicates dat tha name ta check be a 'our' declaration.
.Sp
.Vb 2
\&        void    pad_check_dup(SV *name, U32 flags,
\&                              const HV *ourstash)
.Ve
.IP "pad_findlex" 8
.IX Xref "pad_findlex"
.IX Item "pad_findlex"
Find a named lexical anywhere up in a cold-ass lil chain of nested padz fo' realz. Add fake entries
in tha inner padz if itz found up in a outa one.
.Sp
Returns tha offset up in tha bottom pad of tha lex or tha fake lex.
cv is tha \s-1CV\s0 up in which ta start tha search, n' seq is tha current cop_seq
to match against. If warn is true, print appropriate warnings.  Da out_*
vars return joints, n' so is pointas ta where tha returned joints
should be stored. Y'all KNOW dat shit, muthafucka! out_capture, if non-null, requests dat tha innermost
instizzle of tha lexical is captured; out_name_sv is set ta tha innermost
matched namesv or fake namesv; out_flags returns tha flags normally
associated wit tha \s-1IVX\s0 field of a gangbangin' fake namesv.
.Sp
Note dat \fIpad_findlex()\fR is recursive; it recurses up tha chain of CVs,
then comes back down, addin fake entries as it goes. Well shiiiit, it has ta be dis way
because fake namesvs up in anon protoypes gotta store up in xlow tha index into
the parent pad.
.Sp
.Vb 5
\&        PADOFFSET pad_findlex(const char *namepv,
\&                              STRLEN namelen, U32 flags,
\&                              const CV* cv, U32 seq, int warn,
\&                              SV** out_capture,
\&                              SV** out_name_sv, int *out_flags)
.Ve
.IP "pad_fixup_inner_anons" 8
.IX Xref "pad_fixup_inner_anons"
.IX Item "pad_fixup_inner_anons"
For any anon CVs up in tha pad, chizzle CvOUTSIDE of dat \s-1CV\s0 from
old_cv ta new_cv if necessary. Needed when a newly-compiled \s-1CV\s0 has ta be
moved ta a pre-existin \s-1CV\s0 struct.
.Sp
.Vb 2
\&        void    pad_fixup_inner_anons(PADLIST *padlist,
\&                                      CV *old_cv, CV *new_cv)
.Ve
.IP "pad_free" 8
.IX Xref "pad_free"
.IX Item "pad_free"
Jacked tha \s-1SV\s0 at offset po up in tha current pad.
.Sp
.Vb 1
\&        void    pad_free(PADOFFSET po)
.Ve
.IP "pad_leavemy" 8
.IX Xref "pad_leavemy"
.IX Item "pad_leavemy"
Cleanup at end of scope durin compilation: set tha max seq number for
lexicals up in dis scope n' warn of any lexicals dat never gots introduced.
.Sp
.Vb 1
\&        void    pad_leavemy()
.Ve
.IP "pad_push" 8
.IX Xref "pad_push"
.IX Item "pad_push"
Push a freshly smoked up pad frame onto tha padlist, unless there be a already a pad at
this depth, up in which case don't bother bustin a freshly smoked up one.  Then give
the freshly smoked up pad a \f(CW@_\fR up in slot zero.
.Sp
.Vb 1
\&        void    pad_push(PADLIST *padlist, int depth)
.Ve
.IP "pad_reset" 8
.IX Xref "pad_reset"
.IX Item "pad_reset"
Mark all tha current temporaries fo' reuse
.Sp
.Vb 1
\&        void    pad_reset()
.Ve
.IP "pad_swipe" 8
.IX Xref "pad_swipe"
.IX Item "pad_swipe"
Abandon tha tmp up in tha current pad at offset po n' replace wit a
new one.
.Sp
.Vb 1
\&        void    pad_swipe(PADOFFSET po, bool refadjust)
.Ve
.SH "Functions up in file op.c"
.IX Header "Functions up in file op.c"
.IP "core_prototype" 8
.IX Xref "core_prototype"
.IX Item "core_prototype"
This function assigns tha prototype of tha named core function ta \f(CW\*(C`sv\*(C'\fR, or
to a freshly smoked up mortal \s-1SV\s0 if \f(CW\*(C`sv\*(C'\fR is \s-1NULL. \s0 It returns tha modified \f(CW\*(C`sv\*(C'\fR, or
\&\s-1NULL\s0 if tha core function has no prototype.  \f(CW\*(C`code\*(C'\fR be a cold-ass lil code as returned
by \f(CW\*(C`keyword()\*(C'\fR.  It must not be equal ta 0 or \-KEY_CORE.
.Sp
.Vb 3
\&        SV *    core_prototype(SV *sv, const char *name,
\&                               const int code,
\&                               int * const opnum)
.Ve
.SH "Functions up in file pp_ctl.c"
.IX Header "Functions up in file pp_ctl.c"
.IP "docatch" 8
.IX Xref "docatch"
.IX Item "docatch"
Peep fo' tha cases 0 or 3 of cur_env.je_ret, only used inside a eval context.
.Sp
0 is used as continue inside eval,
.Sp
3 is used fo' a gangbangin' finger-lickin' take a thugged-out dirtnap caught by a inner eval \- continue inner loop
.Sp
See cop.h: je_mustcatch, when set at any runlevel ta \s-1TRUE,\s0 means eval ops must
establish a local jmpenv ta handle exception traps.
.Sp
.Vb 1
\&        OP*     docatch(OP *o)
.Ve
.SH "GV Functions"
.IX Header "GV Functions"
.IP "gv_try_downgrade" 8
.IX Xref "gv_try_downgrade"
.IX Item "gv_try_downgrade"
If tha typeglob \f(CW\*(C`gv\*(C'\fR can be expressed mo' succinctly, by having
suttin' other than a real \s-1GV\s0 up in its place up in tha stash, replace it
with tha optimised form.  Basic requirements fo' dis is dat \f(CW\*(C`gv\*(C'\fR
is a real typeglob, is sufficiently ordinary, n' is only referenced
from its package.  This function is meant ta be used when a \s-1GV\s0 has been
looked up in part ta peep what tha fuck was there, causin upgradin yo, but based
on what tha fuck was found it turns up dat tha real \s-1GV\s0 aint required afta all.
.Sp
If \f(CW\*(C`gv\*(C'\fR be a cold-ass lil straight-up empty typeglob, it is deleted from tha stash.
.Sp
If \f(CW\*(C`gv\*(C'\fR be a typeglob containin only a sufficiently-ordinary constant
sub, tha typeglob is replaced wit a scalar-reference placeholda that
more compactly represents tha same ol' dirty thang.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    gv_try_downgrade(GV* gv)
.Ve
.SH "Hash Manipulation Functions"
.IX Header "Hash Manipulation Functions"
.IP "hv_ename_add" 8
.IX Xref "hv_ename_add"
.IX Item "hv_ename_add"
Addz a name ta a stashz internal list of effectizzle names.  See
\&\f(CW\*(C`hv_ename_delete\*(C'\fR.
.Sp
This is called when a stash be assigned ta a freshly smoked up location up in tha symbol
table.
.Sp
.Vb 2
\&        void    hv_ename_add(HV *hv, const char *name, U32 len,
\&                             U32 flags)
.Ve
.IP "hv_ename_delete" 8
.IX Xref "hv_ename_delete"
.IX Item "hv_ename_delete"
Removes a name from a stashz internal list of effectizzle names.  If dis is
the name returned by \f(CW\*(C`HvENAME\*(C'\fR, then another name up in tha list will take
its place (\f(CW\*(C`HvENAME\*(C'\fR will use it).
.Sp
This is called when a stash is deleted from tha symbol table.
.Sp
.Vb 2
\&        void    hv_ename_delete(HV *hv, const char *name,
\&                                U32 len, U32 flags)
.Ve
.IP "refcounted_he_chain_2hv" 8
.IX Xref "refcounted_he_chain_2hv"
.IX Item "refcounted_he_chain_2hv"
Generates n' returns a \f(CW\*(C`HV *\*(C'\fR representin tha content of a
\&\f(CW\*(C`refcounted_he\*(C'\fR chain.
\&\fIflags\fR is currently unused n' must be zero.
.Sp
.Vb 3
\&        HV *    refcounted_he_chain_2hv(
\&                    const struct refcounted_he *c, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pv" 8
.IX Xref "refcounted_he_fetch_pv"
.IX Item "refcounted_he_fetch_pv"
Like \*(L"refcounted_he_fetch_pvn\*(R" yo, but takes a nul-terminated string
instead of a string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pv(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvn" 8
.IX Xref "refcounted_he_fetch_pvn"
.IX Item "refcounted_he_fetch_pvn"
Search along a \f(CW\*(C`refcounted_he\*(C'\fR chain fo' a entry wit tha key specified
by \fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has tha \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR
bit set, tha key octets is interpreted as \s-1UTF\-8,\s0 otherwise they
are interpreted as Latin\-1.  \fIhash\fR be a precomputed hash of tha key
string, or zero if it has not been precomputed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Returns a mortal scalar
representin tha value associated wit tha key, or \f(CW&PL_sv_placeholder\fR
if there is no value associated wit tha key.
.Sp
.Vb 5
\&        SV *    refcounted_he_fetch_pvn(
\&                    const struct refcounted_he *chain,
\&                    const char *keypv, STRLEN keylen, U32 hash,
\&                    U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_pvs" 8
.IX Xref "refcounted_he_fetch_pvs"
.IX Item "refcounted_he_fetch_pvs"
Like \*(L"refcounted_he_fetch_pvn\*(R" yo, but takes a literal strang instead of
a string/length pair, n' no precomputed hash.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_pvs(
\&                    const struct refcounted_he *chain,
\&                    const char *key, U32 flags
\&                )
.Ve
.IP "refcounted_he_fetch_sv" 8
.IX Xref "refcounted_he_fetch_sv"
.IX Item "refcounted_he_fetch_sv"
Like \*(L"refcounted_he_fetch_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 4
\&        SV *    refcounted_he_fetch_sv(
\&                    const struct refcounted_he *chain, SV *key,
\&                    U32 hash, U32 flags
\&                )
.Ve
.IP "refcounted_he_free" 8
.IX Xref "refcounted_he_free"
.IX Item "refcounted_he_free"
Decrements tha reference count of a \f(CW\*(C`refcounted_he\*(C'\fR by one.  If the
reference count reaches zero tha structurez memory is freed, which
(recursively) causes a reduction of its parent \f(CW\*(C`refcounted_he\*(C'\fR's
reference count.  It be safe ta pass a null pointa ta dis function:
no action occurs up in dis case.
.Sp
.Vb 1
\&        void    refcounted_he_free(struct refcounted_he *he)
.Ve
.IP "refcounted_he_inc" 8
.IX Xref "refcounted_he_inc"
.IX Item "refcounted_he_inc"
Increment tha reference count of a \f(CW\*(C`refcounted_he\*(C'\fR.  Da pointa ta the
\&\f(CW\*(C`refcounted_he\*(C'\fR be also returned. Y'all KNOW dat shit, muthafucka!  It be safe ta pass a null pointer
to dis function: no action occurs n' a null pointa is returned.
.Sp
.Vb 3
\&        struct refcounted_he * refcounted_he_inc(
\&                                   struct refcounted_he *he
\&                               )
.Ve
.IP "refcounted_he_new_pv" 8
.IX Xref "refcounted_he_new_pv"
.IX Item "refcounted_he_new_pv"
Like \*(L"refcounted_he_new_pvn\*(R" yo, but takes a nul-terminated strang instead
of a string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pv(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvn" 8
.IX Xref "refcounted_he_new_pvn"
.IX Item "refcounted_he_new_pvn"
Creates a freshly smoked up \f(CW\*(C`refcounted_he\*(C'\fR.  This consistz of a single key/value
pair n' a reference ta a existin \f(CW\*(C`refcounted_he\*(C'\fR chain (which may
be empty), n' thus forms a longer chain. I aint talkin' bout chicken n' gravy biatch.  When rockin tha longer chain,
the freshly smoked up key/value pair takes precedence over any entry fo' tha same key
further along tha chain.
.Sp
Da freshly smoked up key is specified by \fIkeypv\fR n' \fIkeylen\fR.  If \fIflags\fR has
the \f(CW\*(C`REFCOUNTED_HE_KEY_UTF8\*(C'\fR bit set, tha key octets is interpreted
as \s-1UTF\-8,\s0 otherwise they is interpreted as Latin\-1.  \fIhash\fR is
a precomputed hash of tha key string, or zero if it has not been
precomputed.
.Sp
\&\fIvalue\fR is tha scalar value ta store fo' dis key.  \fIvalue\fR is copied
by dis function, which thus do not take ballershizzle of any reference
to it, n' lata chizzlez ta tha scalar aint gonna be reflected up in the
value visible up in tha \f(CW\*(C`refcounted_he\*(C'\fR.  Complex typez of scalar will not
be stored wit referential integritizzle yo, but is ghon be coerced ta strings.
\&\fIvalue\fR may be either null or \f(CW&PL_sv_placeholder\fR ta indicate dat no
value is ta be associated wit tha key; this, as wit any non-null value,
takes precedence over tha existence of a value fo' tha key further along
the chain.
.Sp
\&\fIparent\fR points ta tha rest of tha \f(CW\*(C`refcounted_he\*(C'\fR chain ta be
attached ta tha freshly smoked up \f(CW\*(C`refcounted_he\*(C'\fR.  This function takes ballership
of one reference ta \fIparent\fR, n' returns one reference ta tha new
\&\f(CW\*(C`refcounted_he\*(C'\fR.
.Sp
.Vb 6
\&        struct refcounted_he * refcounted_he_new_pvn(
\&                                   struct refcounted_he *parent,
\&                                   const char *keypv,
\&                                   STRLEN keylen, U32 hash,
\&                                   SV *value, U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_pvs" 8
.IX Xref "refcounted_he_new_pvs"
.IX Item "refcounted_he_new_pvs"
Like \*(L"refcounted_he_new_pvn\*(R" yo, but takes a literal strang instead of
a string/length pair, n' no precomputed hash.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_pvs(
\&                                   struct refcounted_he *parent,
\&                                   const char *key, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.IP "refcounted_he_new_sv" 8
.IX Xref "refcounted_he_new_sv"
.IX Item "refcounted_he_new_sv"
Like \*(L"refcounted_he_new_pvn\*(R" yo, but takes a Perl scalar instead of a
string/length pair.
.Sp
.Vb 5
\&        struct refcounted_he * refcounted_he_new_sv(
\&                                   struct refcounted_he *parent,
\&                                   SV *key, U32 hash, SV *value,
\&                                   U32 flags
\&                               )
.Ve
.SH "IO Functions"
.IX Header "IO Functions"
.IP "start_glob" 8
.IX Xref "start_glob"
.IX Item "start_glob"
Function called by \f(CW\*(C`do_readline\*(C'\fR ta spawn a glob (or do tha glob inside
perl on \s-1VMS\s0). This code used ta be inline yo, but now perl uses \f(CW\*(C`File::Glob\*(C'\fR
this glob starta is only used by miniperl durin tha build process.
Movin it away shrinks pp_hot.c; shrinkin pp_hot.c helps speed perl up.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        PerlIO* start_glob(SV *tmpglob, IO *io)
.Ve
.SH "Magical Functions"
.IX Header "Magical Functions"
.IP "magic_clearhint" 8
.IX Xref "magic_clearhint"
.IX Item "magic_clearhint"
Triggered by a thugged-out delete from %^H, recordz tha key to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhint(SV* sv, MAGIC* mg)
.Ve
.IP "magic_clearhints" 8
.IX Xref "magic_clearhints"
.IX Item "magic_clearhints"
Triggered by clearin %^H, resets \f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.
.Sp
.Vb 1
\&        int     magic_clearhints(SV* sv, MAGIC* mg)
.Ve
.IP "magic_methcall" 8
.IX Xref "magic_methcall"
.IX Item "magic_methcall"
Invoke a magic method (like \s-1FETCH\s0).
.Sp
\&\f(CW\*(C`sv\*(C'\fR n' \f(CW\*(C`mg\*(C'\fR is tha tied thangy n' tha tie magic.
.Sp
\&\f(CW\*(C`meth\*(C'\fR is tha name of tha method ta call.
.Sp
\&\f(CW\*(C`argc\*(C'\fR is tha number of args (in addizzle ta \f(CW$self\fR) ta pass ta tha method.
.Sp
Da \f(CW\*(C`flags\*(C'\fR can be:
.Sp
.Vb 4
\&    G_DISCARD     invoke method wit G_DISCARD flag n' don\*(Aqt
\&                  return a value
\&    G_UNDEF_FILL  fill tha stack wit argc pointas to
\&                  PL_sv_undef
.Ve
.Sp
Da arguments theyselves is any joints followin tha \f(CW\*(C`flags\*(C'\fR argument.
.Sp
Returns tha \s-1SV \s0(if any) returned by tha method, or \s-1NULL\s0 on failure.
.Sp
.Vb 3
\&        SV*     magic_methcall(SV *sv, const MAGIC *mg,
\&                               const char *meth, U32 flags,
\&                               U32 argc, ...)
.Ve
.IP "magic_sethint" 8
.IX Xref "magic_sethint"
.IX Item "magic_sethint"
Triggered by a store ta %^H, recordz tha key/value pair to
\&\f(CW\*(C`PL_compiling.cop_hints_hash\*(C'\fR.  It be assumed dat hints aren't storing
anythang dat would need a thugged-out deep copy.  Maybe we should warn if we find a
reference.
.Sp
.Vb 1
\&        int     magic_sethint(SV* sv, MAGIC* mg)
.Ve
.IP "mg_localize" 8
.IX Xref "mg_localize"
.IX Item "mg_localize"
Copy a shitload of tha magic from a existin \s-1SV\s0 ta freshly smoked up localized version of that
\&\s-1SV.\s0 Container magic (eg \f(CW%ENV\fR, \f(CW$1\fR, tie) gets copied, value magic don't (eg
taint, pos).
.Sp
If setmagic is false then no set magic is ghon be called on tha freshly smoked up (empty) \s-1SV.\s0
This typically means dat assignment will soon follow (e.g. 'local \f(CW$x\fR = \f(CW$y\fR'),
and dat will handle tha magic.
.Sp
.Vb 1
\&        void    mg_localize(SV* sv, SV* nsv, bool setmagic)
.Ve
.SH "MRO Functions"
.IX Header "MRO Functions"
.IP "mro_get_linear_isa_dfs" 8
.IX Xref "mro_get_linear_isa_dfs"
.IX Item "mro_get_linear_isa_dfs"
Returns tha Depth-First Search linearization of \f(CW@ISA\fR
the given stash.  Da return value be a read-only AV*.
\&\f(CW\*(C`level\*(C'\fR should be 0 (it is used internally up in this
functionz recursion).
.Sp
Yo ass is responsible fo' \f(CW\*(C`SvREFCNT_inc()\*(C'\fR on the
return value if you plan ta store it anywhere
semi-permanently (otherwise it might be deleted
out from under you tha next time tha cache is
invalidated).
.Sp
.Vb 1
\&        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)
.Ve
.IP "mro_isa_changed_in" 8
.IX Xref "mro_isa_changed_in"
.IX Item "mro_isa_changed_in"
Takes tha necessary steps (cache invalidations, mostly)
when tha \f(CW@ISA\fR of tha given package has chizzled. Y'all KNOW dat shit, muthafucka!  Invoked
by tha \f(CW\*(C`setisa\*(C'\fR magic, should not need ta invoke directly.
.Sp
.Vb 1
\&        void    mro_isa_changed_in(HV* stash)
.Ve
.IP "mro_package_moved" 8
.IX Xref "mro_package_moved"
.IX Item "mro_package_moved"
Call dis function ta signal ta a stash dat it has been assigned to
another spot up in tha stash hierarchy.  \f(CW\*(C`stash\*(C'\fR is tha stash dat has been
assigned. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`oldstash\*(C'\fR is tha stash it replaces, if any.  \f(CW\*(C`gv\*(C'\fR is tha glob
that is straight-up bein assigned to.
.Sp
This can also be called wit a null first argument to
indicate dat \f(CW\*(C`oldstash\*(C'\fR has been deleted.
.Sp
This function invalidates isa caches on tha oldschool stash, on all subpackages
nested inside it, n' on tha subclassez of all them, including
non-existent packages dat have correspondin entries up in \f(CW\*(C`stash\*(C'\fR.
.Sp
It also sets tha effectizzle names (\f(CW\*(C`HvENAME\*(C'\fR) on all tha stashes as
appropriate.
.Sp
If tha \f(CW\*(C`gv\*(C'\fR is present n' aint up in tha symbol table, then dis function
simply returns.  This checked is ghon be skipped if \f(CW\*(C`flags & 1\*(C'\fR.
.Sp
.Vb 4
\&        void    mro_package_moved(HV * const stash,
\&                                  HV * const oldstash,
\&                                  const GV * const gv,
\&                                  U32 flags)
.Ve
.SH "Optree Manipulation Functions"
.IX Header "Optree Manipulation Functions"
.IP "finalize_optree" 8
.IX Xref "finalize_optree"
.IX Item "finalize_optree"
This function finalizes tha optree. Right back up in yo muthafuckin ass. Should be called directly after
the complete optree is built. Well shiiiit, it do some additional
checkin which can't be done up in tha aiiight ck_xxx functions n' makes
the tree thread-safe.
.Sp
.Vb 1
\&        void    finalize_optree(OP* o)
.Ve
.SH "Pad Data Structures"
.IX Header "Pad Data Structures"
.IP "\s-1CX_CURPAD_SAVE \s0" 8
.IX Xref "CX_CURPAD_SAVE"
.IX Item "CX_CURPAD_SAVE "
Save tha current pad up in tha given context block structure.
.Sp
.Vb 1
\&        void    CX_CURPAD_SAVE(struct context)
.Ve
.IP "\s-1CX_CURPAD_SV \s0" 8
.IX Xref "CX_CURPAD_SV"
.IX Item "CX_CURPAD_SV "
Access tha \s-1SV\s0 at offset po up in tha saved current pad up in tha given
context block structure (can be used as a lvalue).
.Sp
.Vb 1
\&        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)
.Ve
.IP "PadnameIsOUR" 8
.IX Xref "PadnameIsOUR"
.IX Item "PadnameIsOUR"
Whether dis be a \*(L"our\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsOUR(PADNAME pn)
.Ve
.IP "PadnameIsSTATE" 8
.IX Xref "PadnameIsSTATE"
.IX Item "PadnameIsSTATE"
Whether dis be a \*(L"state\*(R" variable.
.Sp
.Vb 1
\&        bool    PadnameIsSTATE(PADNAME pn)
.Ve
.IP "PadnameOURSTASH" 8
.IX Xref "PadnameOURSTASH"
.IX Item "PadnameOURSTASH"
Da stash up in which dis \*(L"our\*(R" variable was declared.
.Sp
.Vb 1
\&        HV *    PadnameOURSTASH()
.Ve
.IP "PadnameOUTER" 8
.IX Xref "PadnameOUTER"
.IX Item "PadnameOUTER"
Whether dis entry belongs ta a outa pad.
.Sp
.Vb 1
\&        bool    PadnameOUTER(PADNAME pn)
.Ve
.IP "PadnameTYPE" 8
.IX Xref "PadnameTYPE"
.IX Item "PadnameTYPE"
Da stash associated wit a typed lexical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This returns tha \f(CW%Foo::\fR hash
for \f(CW\*(C`my Foo $bar\*(C'\fR.
.Sp
.Vb 1
\&        HV *    PadnameTYPE(PADNAME pn)
.Ve
.IP "\s-1PAD_BASE_SV \s0" 8
.IX Xref "PAD_BASE_SV"
.IX Item "PAD_BASE_SV "
Git tha value from slot \f(CW\*(C`po\*(C'\fR up in tha base (DEPTH=1) pad of a padlist
.Sp
.Vb 1
\&        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
.Ve
.IP "\s-1PAD_CLONE_VARS \s0" 8
.IX Xref "PAD_CLONE_VARS"
.IX Item "PAD_CLONE_VARS "
Clone tha state variablez associated wit hustlin n' compilin pads.
.Sp
.Vb 2
\&        void    PAD_CLONE_VARS(PerlInterpreta *proto_perl,
\&                               CLONE_PARAMS* param)
.Ve
.IP "\s-1PAD_COMPNAME_FLAGS \s0" 8
.IX Xref "PAD_COMPNAME_FLAGS"
.IX Item "PAD_COMPNAME_FLAGS "
Return tha flags fo' tha current compilin pad name
at offset \f(CW\*(C`po\*(C'\fR fo' realz. Assumes a valid slot entry.
.Sp
.Vb 1
\&        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_GEN \s0" 8
.IX Xref "PAD_COMPNAME_GEN"
.IX Item "PAD_COMPNAME_GEN "
Da generation number of tha name at offset \f(CW\*(C`po\*(C'\fR up in tha current
compilin pad (lvalue). Note dat \f(CW\*(C`SvUVX\*(C'\fR is hijacked fo' dis purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
.Ve
.IP "PAD_COMPNAME_GEN_set" 8
.IX Xref "PAD_COMPNAME_GEN_set"
.IX Item "PAD_COMPNAME_GEN_set"
Sets tha generation number of tha name at offset \f(CW\*(C`po\*(C'\fR up in tha current
lin pad (lvalue) ta \f(CW\*(C`gen\*(C'\fR.  Note dat \f(CW\*(C`SvUV_set\*(C'\fR is hijacked fo' dis purpose.
.Sp
.Vb 1
\&        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
.Ve
.IP "\s-1PAD_COMPNAME_OURSTASH \s0" 8
.IX Xref "PAD_COMPNAME_OURSTASH"
.IX Item "PAD_COMPNAME_OURSTASH "
Return tha stash associated wit a \f(CW\*(C`our\*(C'\fR variable.
Assumes tha slot entry be a valid \f(CW\*(C`our\*(C'\fR lexical.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_PV \s0" 8
.IX Xref "PAD_COMPNAME_PV"
.IX Item "PAD_COMPNAME_PV "
Return tha name of tha current compilin pad name
at offset \f(CW\*(C`po\*(C'\fR fo' realz. Assumes a valid slot entry.
.Sp
.Vb 1
\&        char *  PAD_COMPNAME_PV(PADOFFSET po)
.Ve
.IP "\s-1PAD_COMPNAME_TYPE \s0" 8
.IX Xref "PAD_COMPNAME_TYPE"
.IX Item "PAD_COMPNAME_TYPE "
Return tha type (stash) of tha current compilin pad name at offset
\&\f(CW\*(C`po\*(C'\fR. Must be a valid name. Returns null if not typed.
.Sp
.Vb 1
\&        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)
.Ve
.IP "pad_peg" 8
.IX Xref "pad_peg"
.IX Item "pad_peg"
When \s-1PERL_MAD\s0 is enabled, dis be a lil' small-ass no-op function dat gets called
at tha start of each pad-related function. I aint talkin' bout chicken n' gravy biatch.  It can be breakpointed to
track all pad operations.  Da parameta be a strang indicatin tha type
of pad operation bein performed.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        void    pad_peg(const char *s)
.Ve
.IP "\s-1PAD_RESTORE_LOCAL \s0" 8
.IX Xref "PAD_RESTORE_LOCAL"
.IX Item "PAD_RESTORE_LOCAL "
Restore tha oldschool pad saved tha fuck into tha local variable opad by \s-1\fIPAD_SAVE_LOCAL\s0()\fR
.Sp
.Vb 1
\&        void    PAD_RESTORE_LOCAL(PAD *opad)
.Ve
.IP "\s-1PAD_SAVE_LOCAL \s0" 8
.IX Xref "PAD_SAVE_LOCAL"
.IX Item "PAD_SAVE_LOCAL "
Save tha current pad ta tha local variable opad, then make the
current pad equal ta npad
.Sp
.Vb 1
\&        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
.Ve
.IP "\s-1PAD_SAVE_SETNULLPAD \s0" 8
.IX Xref "PAD_SAVE_SETNULLPAD"
.IX Item "PAD_SAVE_SETNULLPAD "
Save tha current pad then set it ta null.
.Sp
.Vb 1
\&        void    PAD_SAVE_SETNULLPAD()
.Ve
.IP "\s-1PAD_SETSV \s0" 8
.IX Xref "PAD_SETSV"
.IX Item "PAD_SETSV "
Set tha slot at offset \f(CW\*(C`po\*(C'\fR up in tha current pad ta \f(CW\*(C`sv\*(C'\fR
.Sp
.Vb 1
\&        SV *    PAD_SETSV(PADOFFSET po, SV* sv)
.Ve
.IP "\s-1PAD_SET_CUR \s0" 8
.IX Xref "PAD_SET_CUR"
.IX Item "PAD_SET_CUR "
Set tha current pad ta be pad \f(CW\*(C`n\*(C'\fR up in tha padlist, saving
the previous current pad. Y'all KNOW dat shit, muthafucka! \s-1NB\s0 currently dis macro expandz ta a strang too
long fo' some compilers, so itz dopest ta replace it with
.Sp
.Vb 2
\&    SAVECOMPPAD();
\&    PAD_SET_CUR_NOSAVE(padlist,n);
\&
\&
\&        void    PAD_SET_CUR(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SET_CUR_NOSAVE \s0" 8
.IX Xref "PAD_SET_CUR_NOSAVE"
.IX Item "PAD_SET_CUR_NOSAVE "
like \s-1PAD_SET_CUR,\s0 but without tha save
.Sp
.Vb 1
\&        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
.Ve
.IP "\s-1PAD_SV \s0" 8
.IX Xref "PAD_SV"
.IX Item "PAD_SV "
Git tha value at offset \f(CW\*(C`po\*(C'\fR up in tha current pad
.Sp
.Vb 1
\&        void    PAD_SV(PADOFFSET po)
.Ve
.IP "PAD_SVl" 8
.IX Xref "PAD_SVl"
.IX Item "PAD_SVl"
Lightweight n' lvalue version of \f(CW\*(C`PAD_SV\*(C'\fR.
Git or set tha value at offset \f(CW\*(C`po\*(C'\fR up in tha current pad.
Unlike \f(CW\*(C`PAD_SV\*(C'\fR, do not print diagnostics wit \-DX.
For internal use only.
.Sp
.Vb 1
\&        SV *    PAD_SVl(PADOFFSET po)
.Ve
.IP "\s-1SAVECLEARSV \s0" 8
.IX Xref "SAVECLEARSV"
.IX Item "SAVECLEARSV "
Clear tha pointed ta pad value on scope exit. (i.e. tha runtime action of 'my')
.Sp
.Vb 1
\&        void    SAVECLEARSV(SV **svp)
.Ve
.IP "\s-1SAVECOMPPAD \s0" 8
.IX Xref "SAVECOMPPAD"
.IX Item "SAVECOMPPAD "
save PL_comppad n' PL_curpad
.Sp
.Vb 1
\&        void    SAVECOMPPAD()
.Ve
.IP "\s-1SAVEPADSV \s0" 8
.IX Xref "SAVEPADSV"
.IX Item "SAVEPADSV "
Save a pad slot (used ta restore afta a iteration)
.Sp
\&\s-1XXX DAPM\s0 it would make mo' sense ta make tha arg a \s-1PADOFFSET
\&\s0	void	\s-1SAVEPADSV\s0(\s-1PADOFFSET\s0 po)
.SH "Per-Interpreta Variables"
.IX Header "Per-Interpreta Variables"
.IP "PL_DBsingle" 8
.IX Xref "PL_DBsingle"
.IX Item "PL_DBsingle"
When Perl is run up in debuggin mode, wit tha \fB\-d\fR switch, dis \s-1SV\s0 be a
boolean which indicates whether subs is bein single-stepped.
Single-steppin be automatically turned on afta every last muthafuckin step.  This is tha C
variable which correspondz ta Perlz \f(CW$DB::single\fR variable.  See
\&\f(CW\*(C`PL_DBsub\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBsingle
.Ve
.IP "PL_DBsub" 8
.IX Xref "PL_DBsub"
.IX Item "PL_DBsub"
When Perl is run up in debuggin mode, wit tha \fB\-d\fR switch, dis \s-1GV\s0 gotz nuff
the \s-1SV\s0 which holdz tha name of tha sub bein debugged. Y'all KNOW dat shit, muthafucka!  This is tha C
variable which correspondz ta Perlz \f(CW$DB::sub\fR variable.  See
\&\f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        GV *    PL_DBsub
.Ve
.IP "PL_DBtrace" 8
.IX Xref "PL_DBtrace"
.IX Item "PL_DBtrace"
Trace variable used when Perl is run up in debuggin mode, wit tha \fB\-d\fR
switch.  This is tha C variable which correspondz ta Perlz \f(CW$DB::trace\fR
variable.  See \f(CW\*(C`PL_DBsingle\*(C'\fR.
.Sp
.Vb 1
\&        SV *    PL_DBtrace
.Ve
.IP "PL_dowarn" 8
.IX Xref "PL_dowarn"
.IX Item "PL_dowarn"
Da C variable which correspondz ta Perlz $^W warnin variable.
.Sp
.Vb 1
\&        bool    PL_dowarn
.Ve
.IP "PL_last_in_gv" 8
.IX Xref "PL_last_in_gv"
.IX Item "PL_last_in_gv"
Da \s-1GV\s0 which was last used fo' a gangbangin' filehandle input operation. I aint talkin' bout chicken n' gravy biatch. (\f(CW\*(C`<FH>\*(C'\fR)
.Sp
.Vb 1
\&        GV*     PL_last_in_gv
.Ve
.IP "PL_ofsgv" 8
.IX Xref "PL_ofsgv"
.IX Item "PL_ofsgv"
Da glob containin tha output field separator \- \f(CW\*(C`*,\*(C'\fR up in Perl space.
.Sp
.Vb 1
\&        GV*     PL_ofsgv
.Ve
.IP "PL_rs" 8
.IX Xref "PL_rs"
.IX Item "PL_rs"
Da input record separator \- \f(CW$/\fR up in Perl space.
.Sp
.Vb 1
\&        SV*     PL_rs
.Ve
.SH "Stack Manipulation Macros"
.IX Header "Stack Manipulation Macros"
.IP "djSP" 8
.IX Xref "djSP"
.IX Item "djSP"
Declare Just \f(CW\*(C`SP\*(C'\fR. This is straight-up identical ta \f(CW\*(C`dSP\*(C'\fR, n' declares
a local copy of perlz stack pointer, available via tha \f(CW\*(C`SP\*(C'\fR macro.
See \f(CW\*(C`SP\*(C'\fR.  (Available fo' backward source code compatibilitizzle wit the
old (Perl 5.005) thread model.)
.Sp
.Vb 1
\&                djSP;
.Ve
.IP "\s-1LVRET \s0" 8
.IX Xref "LVRET"
.IX Item "LVRET "
True if dis op is ghon be tha return value of a lvalue subroutine
.SH "SV Manipulation Functions"
.IX Header "SV Manipulation Functions"
.IP "SvTHINKFIRST" 8
.IX Xref "SvTHINKFIRST"
.IX Item "SvTHINKFIRST"
A quick flag check ta peep whether a sv should be passed ta sv_force_normal
to be \*(L"downgraded\*(R" before SvIVX or SvPVX can be modified directly.
.Sp
For example, if yo' scalar be a reference n' you wanna modify tha SvIVX
slot, you can't just do SvROK_off, as dat will leak tha referent.
.Sp
This is used internally by various sv-modifyin functions, such as
sv_setsv, sv_setiv n' sv_pvn_force.
.Sp
One case dat dis do not handle be a gv without SvFAKE set.  After
.Sp
.Vb 1
\&    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
.Ve
.Sp
it will still be a gv.
.Sp
SvTHINKFIRST sometimes produces false positives.  In dem cases
sv_force_normal do nothing.
.Sp
.Vb 1
\&        U32     SvTHINKFIRST(SV *sv)
.Ve
.IP "sv_add_arena" 8
.IX Xref "sv_add_arena"
.IX Item "sv_add_arena"
Given a cold-ass lil chunk of memory, link it ta tha head of tha list of arenas,
and split it tha fuck into a list of free SVs.
.Sp
.Vb 2
\&        void    sv_add_arena(char *const ptr, const U32 size,
\&                             const U32 flags)
.Ve
.IP "sv_clean_all" 8
.IX Xref "sv_clean_all"
.IX Item "sv_clean_all"
Decrement tha refcnt of each remainin \s-1SV,\s0 possibly triggerin a
cleanup.  This function may gotta be called multiple times ta free
SVs which is up in complex self-referential hierarchies.
.Sp
.Vb 1
\&        I32     sv_clean_all()
.Ve
.IP "sv_clean_objs" 8
.IX Xref "sv_clean_objs"
.IX Item "sv_clean_objs"
Attempt ta destroy all objects not yet freed.
.Sp
.Vb 1
\&        void    sv_clean_objs()
.Ve
.IP "sv_free_arenas" 8
.IX Xref "sv_free_arenas"
.IX Item "sv_free_arenas"
Deallocate tha memory used by all arenas.  Note dat all tha individual \s-1SV\s0
headz n' bodies within tha arenas must already done been freed.
.Sp
.Vb 1
\&        void    sv_free_arenas()
.Ve
.SH "SV-Body Allocation"
.IX Header "SV-Body Allocation"
.IP "sv_2num" 8
.IX Xref "sv_2num"
.IX Item "sv_2num"
Return a \s-1SV\s0 wit tha numeric value of tha source \s-1SV,\s0 bustin any necessary
reference or overload conversion. I aint talkin' bout chicken n' gravy biatch.  Yo ass must use tha \f(CW\*(C`SvNUM(sv)\*(C'\fR macro to
access dis function.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 1
\&        SV*     sv_2num(SV *const sv)
.Ve
.IP "sv_copypv" 8
.IX Xref "sv_copypv"
.IX Item "sv_copypv"
Copies a stringified representation of tha source \s-1SV\s0 tha fuck into the
destination \s-1SV. \s0 Automatically performs any necessary mg_get and
coercion of numeric joints tha fuck into strings.  Guaranteed ta preserve
\&\s-1UTF8\s0 flag even from overloaded objects, n' you can put dat on yo' toast.  Similar up in nature to
sv_2pv[_flags] but operates directly on a \s-1SV\s0 instead of just the
string.  Mostly uses sv_2pv_flags ta do its work, except when that
would lose tha \s-1UTF\-8\s0'nizz of tha \s-1PV.\s0
.Sp
.Vb 1
\&        void    sv_copypv(SV *const dsv, SV *const ssv)
.Ve
.IP "sv_ref" 8
.IX Xref "sv_ref"
.IX Item "sv_ref"
Returns a \s-1SV\s0 describin what tha fuck tha \s-1SV\s0 passed up in be a reference to.
.Sp
.Vb 2
\&        SV*     sv_ref(SV *dst, const SV *const sv,
\&                       const int ob)
.Ve
.SH "Unicode Support"
.IX Header "Unicode Support"
.IP "find_uninit_var" 8
.IX Xref "find_uninit_var"
.IX Item "find_uninit_var"
Find tha name of tha undefined variable (if any) dat caused tha operator
to issue a \*(L"Use of uninitialized value\*(R" warning.
If match is true, only return a name if its value matches uninit_sv.
So roughly bustin lyrics, if a unary operator (like fuckin \s-1OP_COS\s0) generates a
warning, then followin tha direct lil pimp of tha op may yield an
\&\s-1OP_PADSV\s0 or \s-1OP_GV\s0 dat gives tha name of tha undefined variable.  On the
other hand, wit \s-1OP_ADD\s0 there be two branches ta follow, so we only print
the variable name if we git a exact match.
.Sp
Da name is returned as a mortal \s-1SV.\s0
.Sp
Assumes dat PL_op is tha op dat originally triggered tha error, n' that
PL_comppad/PL_curpad points ta tha currently executin pad.
.Sp
\&\s-1NOTE:\s0 dis function is experimenstrual n' may chizzle or be
removed without notice.
.Sp
.Vb 3
\&        SV*     find_uninit_var(const OP *const obase,
\&                                const SV *const uninit_sv,
\&                                bool top)
.Ve
.IP "report_uninit" 8
.IX Xref "report_uninit"
.IX Item "report_uninit"
Print appropriate \*(L"Use of uninitialized variable\*(R" warning.
.Sp
.Vb 1
\&        void    report_uninit(const SV *uninit_sv)
.Ve
.SH "Undocumented functions"
.IX Header "Undocumented functions"
Da followin functions is currently undocumented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you use one of
them, you may wish ta consider bustin n' submittin documentation for
it.
.IP "Perl_croak_memory_wrap" 4
.IX Xref "Perl_croak_memory_wrap"
.IX Item "Perl_croak_memory_wrap"
.PD 0
.IP "Slab_Alloc" 4
.IX Xref "Slab_Alloc"
.IX Item "Slab_Alloc"
.IP "Slab_Free" 4
.IX Xref "Slab_Free"
.IX Item "Slab_Free"
.IP "Slab_to_ro" 4
.IX Xref "Slab_to_ro"
.IX Item "Slab_to_ro"
.IP "Slab_to_rw" 4
.IX Xref "Slab_to_rw"
.IX Item "Slab_to_rw"
.IP "_add_range_to_invlist" 4
.IX Xref "_add_range_to_invlist"
.IX Item "_add_range_to_invlist"
.IP "_core_swash_init" 4
.IX Xref "_core_swash_init"
.IX Item "_core_swash_init"
.IP "_get_invlist_len_addr" 4
.IX Xref "_get_invlist_len_addr"
.IX Item "_get_invlist_len_addr"
.IP "_get_swash_invlist" 4
.IX Xref "_get_swash_invlist"
.IX Item "_get_swash_invlist"
.IP "_invlist_array_init" 4
.IX Xref "_invlist_array_init"
.IX Item "_invlist_array_init"
.IP "_invlist_gotz nuff_cp" 4
.IX Xref "_invlist_gotz nuff_cp"
.IX Item "_invlist_gotz nuff_cp"
.IP "_invlist_contents" 4
.IX Xref "_invlist_contents"
.IX Item "_invlist_contents"
.IP "_invlist_intersection" 4
.IX Xref "_invlist_intersection"
.IX Item "_invlist_intersection"
.IP "_invlist_intersection_maybe_complement_2nd" 4
.IX Xref "_invlist_intersection_maybe_complement_2nd"
.IX Item "_invlist_intersection_maybe_complement_2nd"
.IP "_invlist_invert" 4
.IX Xref "_invlist_invert"
.IX Item "_invlist_invert"
.IP "_invlist_invert_prop" 4
.IX Xref "_invlist_invert_prop"
.IX Item "_invlist_invert_prop"
.IP "_invlist_len" 4
.IX Xref "_invlist_len"
.IX Item "_invlist_len"
.IP "_invlist_populate_swatch" 4
.IX Xref "_invlist_populate_swatch"
.IX Item "_invlist_populate_swatch"
.IP "_invlist_search" 4
.IX Xref "_invlist_search"
.IX Item "_invlist_search"
.IP "_invlist_subtract" 4
.IX Xref "_invlist_subtract"
.IX Item "_invlist_subtract"
.IP "_invlist_union" 4
.IX Xref "_invlist_union"
.IX Item "_invlist_union"
.IP "_invlist_union_maybe_complement_2nd" 4
.IX Xref "_invlist_union_maybe_complement_2nd"
.IX Item "_invlist_union_maybe_complement_2nd"
.IP "_new_invlist" 4
.IX Xref "_new_invlist"
.IX Item "_new_invlist"
.IP "_swash_inversion_hash" 4
.IX Xref "_swash_inversion_hash"
.IX Item "_swash_inversion_hash"
.IP "_swash_to_invlist" 4
.IX Xref "_swash_to_invlist"
.IX Item "_swash_to_invlist"
.IP "_to_fold_latin1" 4
.IX Xref "_to_fold_latin1"
.IX Item "_to_fold_latin1"
.IP "_to_upper_title_latin1" 4
.IX Xref "_to_upper_title_latin1"
.IX Item "_to_upper_title_latin1"
.IP "aassign_common_vars" 4
.IX Xref "aassign_common_vars"
.IX Item "aassign_common_vars"
.IP "add_cp_to_invlist" 4
.IX Xref "add_cp_to_invlist"
.IX Item "add_cp_to_invlist"
.IP "addmad" 4
.IX Xref "addmad"
.IX Item "addmad"
.IP "alloc_maybe_populate_EXACT" 4
.IX Xref "alloc_maybe_populate_EXACT"
.IX Item "alloc_maybe_populate_EXACT"
.IP "allocmy" 4
.IX Xref "allocmy"
.IX Item "allocmy"
.IP "amagic_is_enabled" 4
.IX Xref "amagic_is_enabled"
.IX Item "amagic_is_enabled"
.IP "append_madprops" 4
.IX Xref "append_madprops"
.IX Item "append_madprops"
.IP "apply" 4
.IX Xref "apply"
.IX Item "apply"
.IP "av_extend_guts" 4
.IX Xref "av_extend_guts"
.IX Item "av_extend_guts"
.IP "av_reify" 4
.IX Xref "av_reify"
.IX Item "av_reify"
.IP "bind_match" 4
.IX Xref "bind_match"
.IX Item "bind_match"
.IP "block_end" 4
.IX Xref "block_end"
.IX Item "block_end"
.IP "block_start" 4
.IX Xref "block_start"
.IX Item "block_start"
.IP "boot_core_PerlIO" 4
.IX Xref "boot_core_PerlIO"
.IX Item "boot_core_PerlIO"
.IP "boot_core_UNIVERSAL" 4
.IX Xref "boot_core_UNIVERSAL"
.IX Item "boot_core_UNIVERSAL"
.IP "boot_core_mro" 4
.IX Xref "boot_core_mro"
.IX Item "boot_core_mro"
.IP "cando" 4
.IX Xref "cando"
.IX Item "cando"
.IP "check_utf8_print" 4
.IX Xref "check_utf8_print"
.IX Item "check_utf8_print"
.IP "ck_entersub_args_core" 4
.IX Xref "ck_entersub_args_core"
.IX Item "ck_entersub_args_core"
.IP "compute_EXACTish" 4
.IX Xref "compute_EXACTish"
.IX Item "compute_EXACTish"
.IP "convert" 4
.IX Xref "convert"
.IX Item "convert"
.IP "coresub_op" 4
.IX Xref "coresub_op"
.IX Item "coresub_op"
.IP "create_eval_scope" 4
.IX Xref "create_eval_scope"
.IX Item "create_eval_scope"
.IP "croak_no_mem" 4
.IX Xref "croak_no_mem"
.IX Item "croak_no_mem"
.IP "croak_popstack" 4
.IX Xref "croak_popstack"
.IX Item "croak_popstack"
.IP "current_re_engine" 4
.IX Xref "current_re_engine"
.IX Item "current_re_engine"
.IP "cv_ckproto_len_flags" 4
.IX Xref "cv_ckproto_len_flags"
.IX Item "cv_ckproto_len_flags"
.IP "cv_clone_into" 4
.IX Xref "cv_clone_into"
.IX Item "cv_clone_into"
.IP "cvgv_set" 4
.IX Xref "cvgv_set"
.IX Item "cvgv_set"
.IP "cvstash_set" 4
.IX Xref "cvstash_set"
.IX Item "cvstash_set"
.IP "deb_stack_all" 4
.IX Xref "deb_stack_all"
.IX Item "deb_stack_all"
.IP "delete_eval_scope" 4
.IX Xref "delete_eval_scope"
.IX Item "delete_eval_scope"
.IP "die_unwind" 4
.IX Xref "die_unwind"
.IX Item "die_unwind"
.IP "do_aexec" 4
.IX Xref "do_aexec"
.IX Item "do_aexec"
.IP "do_aexec5" 4
.IX Xref "do_aexec5"
.IX Item "do_aexec5"
.IP "do_eof" 4
.IX Xref "do_eof"
.IX Item "do_eof"
.IP "do_exec" 4
.IX Xref "do_exec"
.IX Item "do_exec"
.IP "do_exec3" 4
.IX Xref "do_exec3"
.IX Item "do_exec3"
.IP "do_execfree" 4
.IX Xref "do_execfree"
.IX Item "do_execfree"
.IP "do_ipcctl" 4
.IX Xref "do_ipcctl"
.IX Item "do_ipcctl"
.IP "do_ipcget" 4
.IX Xref "do_ipcget"
.IX Item "do_ipcget"
.IP "do_msgrcv" 4
.IX Xref "do_msgrcv"
.IX Item "do_msgrcv"
.IP "do_msgsnd" 4
.IX Xref "do_msgsnd"
.IX Item "do_msgsnd"
.IP "do_ncmp" 4
.IX Xref "do_ncmp"
.IX Item "do_ncmp"
.IP "do_op_xmldump" 4
.IX Xref "do_op_xmldump"
.IX Item "do_op_xmldump"
.IP "do_pmop_xmldump" 4
.IX Xref "do_pmop_xmldump"
.IX Item "do_pmop_xmldump"
.IP "do_print" 4
.IX Xref "do_print"
.IX Item "do_print"
.IP "do_readline" 4
.IX Xref "do_readline"
.IX Item "do_readline"
.IP "do_seek" 4
.IX Xref "do_seek"
.IX Item "do_seek"
.IP "do_semop" 4
.IX Xref "do_semop"
.IX Item "do_semop"
.IP "do_shmio" 4
.IX Xref "do_shmio"
.IX Item "do_shmio"
.IP "do_sysseek" 4
.IX Xref "do_sysseek"
.IX Item "do_sysseek"
.IP "do_tell" 4
.IX Xref "do_tell"
.IX Item "do_tell"
.IP "do_trans" 4
.IX Xref "do_trans"
.IX Item "do_trans"
.IP "do_vecget" 4
.IX Xref "do_vecget"
.IX Item "do_vecget"
.IP "do_vecset" 4
.IX Xref "do_vecset"
.IX Item "do_vecset"
.IP "do_vop" 4
.IX Xref "do_vop"
.IX Item "do_vop"
.IP "dofile" 4
.IX Xref "dofile"
.IX Item "dofile"
.IP "dump_all_perl" 4
.IX Xref "dump_all_perl"
.IX Item "dump_all_perl"
.IP "dump_packsubs_perl" 4
.IX Xref "dump_packsubs_perl"
.IX Item "dump_packsubs_perl"
.IP "dump_sub_perl" 4
.IX Xref "dump_sub_perl"
.IX Item "dump_sub_perl"
.IP "dump_sv_child" 4
.IX Xref "dump_sv_child"
.IX Item "dump_sv_child"
.IP "emulate_cop_io" 4
.IX Xref "emulate_cop_io"
.IX Item "emulate_cop_io"
.IP "feature_is_enabled" 4
.IX Xref "feature_is_enabled"
.IX Item "feature_is_enabled"
.IP "find_lexical_cv" 4
.IX Xref "find_lexical_cv"
.IX Item "find_lexical_cv"
.IP "find_runcv_where" 4
.IX Xref "find_runcv_where"
.IX Item "find_runcv_where"
.IP "find_rundefsv2" 4
.IX Xref "find_rundefsv2"
.IX Item "find_rundefsv2"
.IP "find_script" 4
.IX Xref "find_script"
.IX Item "find_script"
.IP "free_tied_hv_pool" 4
.IX Xref "free_tied_hv_pool"
.IX Item "free_tied_hv_pool"
.IP "get_and_check_backslash_N_name" 4
.IX Xref "get_and_check_backslash_N_name"
.IX Item "get_and_check_backslash_N_name"
.IP "get_db_sub" 4
.IX Xref "get_db_sub"
.IX Item "get_db_sub"
.IP "get_debug_opts" 4
.IX Xref "get_debug_opts"
.IX Item "get_debug_opts"
.IP "get_hash_seed" 4
.IX Xref "get_hash_seed"
.IX Item "get_hash_seed"
.IP "get_invlist_iter_addr" 4
.IX Xref "get_invlist_iter_addr"
.IX Item "get_invlist_iter_addr"
.IP "get_invlist_previous_index_addr" 4
.IX Xref "get_invlist_previous_index_addr"
.IX Item "get_invlist_previous_index_addr"
.IP "get_invlist_version_id_addr" 4
.IX Xref "get_invlist_version_id_addr"
.IX Item "get_invlist_version_id_addr"
.IP "get_invlist_zero_addr" 4
.IX Xref "get_invlist_zero_addr"
.IX Item "get_invlist_zero_addr"
.IP "get_no_modify" 4
.IX Xref "get_no_modify"
.IX Item "get_no_modify"
.IP "get_opargs" 4
.IX Xref "get_opargs"
.IX Item "get_opargs"
.IP "get_re_arg" 4
.IX Xref "get_re_arg"
.IX Item "get_re_arg"
.IP "getenv_len" 4
.IX Xref "getenv_len"
.IX Item "getenv_len"
.IP "grok_bslash_x" 4
.IX Xref "grok_bslash_x"
.IX Item "grok_bslash_x"
.IP "hfree_next_entry" 4
.IX Xref "hfree_next_entry"
.IX Item "hfree_next_entry"
.IP "hv_backreferences_p" 4
.IX Xref "hv_backreferences_p"
.IX Item "hv_backreferences_p"
.IP "hv_kill_backrefs" 4
.IX Xref "hv_kill_backrefs"
.IX Item "hv_kill_backrefs"
.IP "hv_undef_flags" 4
.IX Xref "hv_undef_flags"
.IX Item "hv_undef_flags"
.IP "init_argv_symbols" 4
.IX Xref "init_argv_symbols"
.IX Item "init_argv_symbols"
.IP "init_constants" 4
.IX Xref "init_constants"
.IX Item "init_constants"
.IP "init_dbargs" 4
.IX Xref "init_dbargs"
.IX Item "init_dbargs"
.IP "init_debugger" 4
.IX Xref "init_debugger"
.IX Item "init_debugger"
.IP "invert" 4
.IX Xref "invert"
.IX Item "invert"
.IP "invlist_array" 4
.IX Xref "invlist_array"
.IX Item "invlist_array"
.IP "invlist_clone" 4
.IX Xref "invlist_clone"
.IX Item "invlist_clone"
.IP "invlist_highest" 4
.IX Xref "invlist_highest"
.IX Item "invlist_highest"
.IP "invlist_is_iterating" 4
.IX Xref "invlist_is_iterating"
.IX Item "invlist_is_iterating"
.IP "invlist_iterfinish" 4
.IX Xref "invlist_iterfinish"
.IX Item "invlist_iterfinish"
.IP "invlist_iterinit" 4
.IX Xref "invlist_iterinit"
.IX Item "invlist_iterinit"
.IP "invlist_max" 4
.IX Xref "invlist_max"
.IX Item "invlist_max"
.IP "invlist_previous_index" 4
.IX Xref "invlist_previous_index"
.IX Item "invlist_previous_index"
.IP "invlist_set_len" 4
.IX Xref "invlist_set_len"
.IX Item "invlist_set_len"
.IP "invlist_set_previous_index" 4
.IX Xref "invlist_set_previous_index"
.IX Item "invlist_set_previous_index"
.IP "invlist_trim" 4
.IX Xref "invlist_trim"
.IX Item "invlist_trim"
.IP "io_close" 4
.IX Xref "io_close"
.IX Item "io_close"
.IP "isALNUM_lazy" 4
.IX Xref "isALNUM_lazy"
.IX Item "isALNUM_lazy"
.IP "isIDFIRST_lazy" 4
.IX Xref "isIDFIRST_lazy"
.IX Item "isIDFIRST_lazy"
.IP "is_utf8_char_slow" 4
.IX Xref "is_utf8_char_slow"
.IX Item "is_utf8_char_slow"
.IP "is_utf8_common" 4
.IX Xref "is_utf8_common"
.IX Item "is_utf8_common"
.IP "jmaybe" 4
.IX Xref "jmaybe"
.IX Item "jmaybe"
.IP "keyword" 4
.IX Xref "keyword"
.IX Item "keyword"
.IP "keyword_plugin_standard" 4
.IX Xref "keyword_plugin_standard"
.IX Item "keyword_plugin_standard"
.IP "list" 4
.IX Xref "list"
.IX Item "list"
.IP "localize" 4
.IX Xref "localize"
.IX Item "localize"
.IP "mad_free" 4
.IX Xref "mad_free"
.IX Item "mad_free"
.IP "madlex" 4
.IX Xref "madlex"
.IX Item "madlex"
.IP "madparse" 4
.IX Xref "madparse"
.IX Item "madparse"
.IP "magic_clear_all_env" 4
.IX Xref "magic_clear_all_env"
.IX Item "magic_clear_all_env"
.IP "magic_cleararylen_p" 4
.IX Xref "magic_cleararylen_p"
.IX Item "magic_cleararylen_p"
.IP "magic_clearenv" 4
.IX Xref "magic_clearenv"
.IX Item "magic_clearenv"
.IP "magic_clearisa" 4
.IX Xref "magic_clearisa"
.IX Item "magic_clearisa"
.IP "magic_clearpack" 4
.IX Xref "magic_clearpack"
.IX Item "magic_clearpack"
.IP "magic_clearsig" 4
.IX Xref "magic_clearsig"
.IX Item "magic_clearsig"
.IP "magic_copycallchecker" 4
.IX Xref "magic_copycallchecker"
.IX Item "magic_copycallchecker"
.IP "magic_existspack" 4
.IX Xref "magic_existspack"
.IX Item "magic_existspack"
.IP "magic_freearylen_p" 4
.IX Xref "magic_freearylen_p"
.IX Item "magic_freearylen_p"
.IP "magic_freeovrld" 4
.IX Xref "magic_freeovrld"
.IX Item "magic_freeovrld"
.IP "magic_get" 4
.IX Xref "magic_get"
.IX Item "magic_get"
.IP "magic_getarylen" 4
.IX Xref "magic_getarylen"
.IX Item "magic_getarylen"
.IP "magic_getdefelem" 4
.IX Xref "magic_getdefelem"
.IX Item "magic_getdefelem"
.IP "magic_getnkeys" 4
.IX Xref "magic_getnkeys"
.IX Item "magic_getnkeys"
.IP "magic_getpack" 4
.IX Xref "magic_getpack"
.IX Item "magic_getpack"
.IP "magic_getpos" 4
.IX Xref "magic_getpos"
.IX Item "magic_getpos"
.IP "magic_getsig" 4
.IX Xref "magic_getsig"
.IX Item "magic_getsig"
.IP "magic_getsubstr" 4
.IX Xref "magic_getsubstr"
.IX Item "magic_getsubstr"
.IP "magic_gettaint" 4
.IX Xref "magic_gettaint"
.IX Item "magic_gettaint"
.IP "magic_getuvar" 4
.IX Xref "magic_getuvar"
.IX Item "magic_getuvar"
.IP "magic_getvec" 4
.IX Xref "magic_getvec"
.IX Item "magic_getvec"
.IP "magic_killbackrefs" 4
.IX Xref "magic_killbackrefs"
.IX Item "magic_killbackrefs"
.IP "magic_nextpack" 4
.IX Xref "magic_nextpack"
.IX Item "magic_nextpack"
.IP "magic_regdata_cnt" 4
.IX Xref "magic_regdata_cnt"
.IX Item "magic_regdata_cnt"
.IP "magic_regdatum_get" 4
.IX Xref "magic_regdatum_get"
.IX Item "magic_regdatum_get"
.IP "magic_regdatum_set" 4
.IX Xref "magic_regdatum_set"
.IX Item "magic_regdatum_set"
.IP "magic_scalarpack" 4
.IX Xref "magic_scalarpack"
.IX Item "magic_scalarpack"
.IP "magic_set" 4
.IX Xref "magic_set"
.IX Item "magic_set"
.IP "magic_set_all_env" 4
.IX Xref "magic_set_all_env"
.IX Item "magic_set_all_env"
.IP "magic_setarylen" 4
.IX Xref "magic_setarylen"
.IX Item "magic_setarylen"
.IP "magic_setcollxfrm" 4
.IX Xref "magic_setcollxfrm"
.IX Item "magic_setcollxfrm"
.IP "magic_setdbline" 4
.IX Xref "magic_setdbline"
.IX Item "magic_setdbline"
.IP "magic_setdefelem" 4
.IX Xref "magic_setdefelem"
.IX Item "magic_setdefelem"
.IP "magic_setenv" 4
.IX Xref "magic_setenv"
.IX Item "magic_setenv"
.IP "magic_setisa" 4
.IX Xref "magic_setisa"
.IX Item "magic_setisa"
.IP "magic_setmglob" 4
.IX Xref "magic_setmglob"
.IX Item "magic_setmglob"
.IP "magic_setnkeys" 4
.IX Xref "magic_setnkeys"
.IX Item "magic_setnkeys"
.IP "magic_setpack" 4
.IX Xref "magic_setpack"
.IX Item "magic_setpack"
.IP "magic_setpos" 4
.IX Xref "magic_setpos"
.IX Item "magic_setpos"
.IP "magic_setregexp" 4
.IX Xref "magic_setregexp"
.IX Item "magic_setregexp"
.IP "magic_setsig" 4
.IX Xref "magic_setsig"
.IX Item "magic_setsig"
.IP "magic_setsubstr" 4
.IX Xref "magic_setsubstr"
.IX Item "magic_setsubstr"
.IP "magic_settaint" 4
.IX Xref "magic_settaint"
.IX Item "magic_settaint"
.IP "magic_setutf8" 4
.IX Xref "magic_setutf8"
.IX Item "magic_setutf8"
.IP "magic_setuvar" 4
.IX Xref "magic_setuvar"
.IX Item "magic_setuvar"
.IP "magic_setvec" 4
.IX Xref "magic_setvec"
.IX Item "magic_setvec"
.IP "magic_sizepack" 4
.IX Xref "magic_sizepack"
.IX Item "magic_sizepack"
.IP "magic_wipepack" 4
.IX Xref "magic_wipepack"
.IX Item "magic_wipepack"
.IP "malloc_good_size" 4
.IX Xref "malloc_good_size"
.IX Item "malloc_good_size"
.IP "malloced_size" 4
.IX Xref "malloced_size"
.IX Item "malloced_size"
.IP "mem_collxfrm" 4
.IX Xref "mem_collxfrm"
.IX Item "mem_collxfrm"
.IP "mode_from_discipline" 4
.IX Xref "mode_from_discipline"
.IX Item "mode_from_discipline"
.IP "more_bodies" 4
.IX Xref "more_bodies"
.IX Item "more_bodies"
.IP "mro_meta_dup" 4
.IX Xref "mro_meta_dup"
.IX Item "mro_meta_dup"
.IP "mro_meta_init" 4
.IX Xref "mro_meta_init"
.IX Item "mro_meta_init"
.IP "my_attrs" 4
.IX Xref "my_attrs"
.IX Item "my_attrs"
.IP "my_betoh16" 4
.IX Xref "my_betoh16"
.IX Item "my_betoh16"
.IP "my_betoh32" 4
.IX Xref "my_betoh32"
.IX Item "my_betoh32"
.IP "my_betoh64" 4
.IX Xref "my_betoh64"
.IX Item "my_betoh64"
.IP "my_betohi" 4
.IX Xref "my_betohi"
.IX Item "my_betohi"
.IP "my_betohl" 4
.IX Xref "my_betohl"
.IX Item "my_betohl"
.IP "my_betohs" 4
.IX Xref "my_betohs"
.IX Item "my_betohs"
.IP "my_clearenv" 4
.IX Xref "my_clearenv"
.IX Item "my_clearenv"
.IP "my_htobe16" 4
.IX Xref "my_htobe16"
.IX Item "my_htobe16"
.IP "my_htobe32" 4
.IX Xref "my_htobe32"
.IX Item "my_htobe32"
.IP "my_htobe64" 4
.IX Xref "my_htobe64"
.IX Item "my_htobe64"
.IP "my_htobei" 4
.IX Xref "my_htobei"
.IX Item "my_htobei"
.IP "my_htobel" 4
.IX Xref "my_htobel"
.IX Item "my_htobel"
.IP "my_htobes" 4
.IX Xref "my_htobes"
.IX Item "my_htobes"
.IP "my_htole16" 4
.IX Xref "my_htole16"
.IX Item "my_htole16"
.IP "my_htole32" 4
.IX Xref "my_htole32"
.IX Item "my_htole32"
.IP "my_htole64" 4
.IX Xref "my_htole64"
.IX Item "my_htole64"
.IP "my_htolei" 4
.IX Xref "my_htolei"
.IX Item "my_htolei"
.IP "my_htolel" 4
.IX Xref "my_htolel"
.IX Item "my_htolel"
.IP "my_htoles" 4
.IX Xref "my_htoles"
.IX Item "my_htoles"
.IP "my_letoh16" 4
.IX Xref "my_letoh16"
.IX Item "my_letoh16"
.IP "my_letoh32" 4
.IX Xref "my_letoh32"
.IX Item "my_letoh32"
.IP "my_letoh64" 4
.IX Xref "my_letoh64"
.IX Item "my_letoh64"
.IP "my_letohi" 4
.IX Xref "my_letohi"
.IX Item "my_letohi"
.IP "my_letohl" 4
.IX Xref "my_letohl"
.IX Item "my_letohl"
.IP "my_letohs" 4
.IX Xref "my_letohs"
.IX Item "my_letohs"
.IP "my_lstat_flags" 4
.IX Xref "my_lstat_flags"
.IX Item "my_lstat_flags"
.IP "my_stat_flags" 4
.IX Xref "my_stat_flags"
.IX Item "my_stat_flags"
.IP "my_swabn" 4
.IX Xref "my_swabn"
.IX Item "my_swabn"
.IP "my_unexec" 4
.IX Xref "my_unexec"
.IX Item "my_unexec"
.IP "newATTRSUB_flags" 4
.IX Xref "newATTRSUB_flags"
.IX Item "newATTRSUB_flags"
.IP "newGP" 4
.IX Xref "newGP"
.IX Item "newGP"
.IP "newMADPROP" 4
.IX Xref "newMADPROP"
.IX Item "newMADPROP"
.IP "newMADsv" 4
.IX Xref "newMADsv"
.IX Item "newMADsv"
.IP "newSTUB" 4
.IX Xref "newSTUB"
.IX Item "newSTUB"
.IP "newTOKEN" 4
.IX Xref "newTOKEN"
.IX Item "newTOKEN"
.IP "newXS_len_flags" 4
.IX Xref "newXS_len_flags"
.IX Item "newXS_len_flags"
.IP "new_warnings_bitfield" 4
.IX Xref "new_warnings_bitfield"
.IX Item "new_warnings_bitfield"
.IP "nextargv" 4
.IX Xref "nextargv"
.IX Item "nextargv"
.IP "oopsAV" 4
.IX Xref "oopsAV"
.IX Item "oopsAV"
.IP "oopsHV" 4
.IX Xref "oopsHV"
.IX Item "oopsHV"
.IP "op_clear" 4
.IX Xref "op_clear"
.IX Item "op_clear"
.IP "op_const_sv" 4
.IX Xref "op_const_sv"
.IX Item "op_const_sv"
.IP "op_getmad" 4
.IX Xref "op_getmad"
.IX Item "op_getmad"
.IP "op_getmad_weak" 4
.IX Xref "op_getmad_weak"
.IX Item "op_getmad_weak"
.IP "op_integerize" 4
.IX Xref "op_integerize"
.IX Item "op_integerize"
.IP "op_lvalue_flags" 4
.IX Xref "op_lvalue_flags"
.IX Item "op_lvalue_flags"
.IP "op_refcnt_dec" 4
.IX Xref "op_refcnt_dec"
.IX Item "op_refcnt_dec"
.IP "op_refcnt_inc" 4
.IX Xref "op_refcnt_inc"
.IX Item "op_refcnt_inc"
.IP "op_std_init" 4
.IX Xref "op_std_init"
.IX Item "op_std_init"
.IP "op_unscope" 4
.IX Xref "op_unscope"
.IX Item "op_unscope"
.IP "op_xmldump" 4
.IX Xref "op_xmldump"
.IX Item "op_xmldump"
.IP "opslab_force_free" 4
.IX Xref "opslab_force_free"
.IX Item "opslab_force_free"
.IP "opslab_free" 4
.IX Xref "opslab_free"
.IX Item "opslab_free"
.IP "opslab_free_nopad" 4
.IX Xref "opslab_free_nopad"
.IX Item "opslab_free_nopad"
.IP "package" 4
.IX Xref "package"
.IX Item "package"
.IP "package_version" 4
.IX Xref "package_version"
.IX Item "package_version"
.IP "padlist_store" 4
.IX Xref "padlist_store"
.IX Item "padlist_store"
.IP "parse_unicode_opts" 4
.IX Xref "parse_unicode_opts"
.IX Item "parse_unicode_opts"
.IP "parser_free" 4
.IX Xref "parser_free"
.IX Item "parser_free"
.IP "parser_free_nexttoke_ops" 4
.IX Xref "parser_free_nexttoke_ops"
.IX Item "parser_free_nexttoke_ops"
.IP "peep" 4
.IX Xref "peep"
.IX Item "peep"
.IP "pmop_xmldump" 4
.IX Xref "pmop_xmldump"
.IX Item "pmop_xmldump"
.IP "pmruntime" 4
.IX Xref "pmruntime"
.IX Item "pmruntime"
.IP "populate_isa" 4
.IX Xref "populate_isa"
.IX Item "populate_isa"
.IP "prepend_madprops" 4
.IX Xref "prepend_madprops"
.IX Item "prepend_madprops"
.IP "qerror" 4
.IX Xref "qerror"
.IX Item "qerror"
.IP "re_op_compile" 4
.IX Xref "re_op_compile"
.IX Item "re_op_compile"
.IP "reg_named_buff" 4
.IX Xref "reg_named_buff"
.IX Item "reg_named_buff"
.IP "reg_named_buff_iter" 4
.IX Xref "reg_named_buff_iter"
.IX Item "reg_named_buff_iter"
.IP "reg_numbered_buff_fetch" 4
.IX Xref "reg_numbered_buff_fetch"
.IX Item "reg_numbered_buff_fetch"
.IP "reg_numbered_buff_length" 4
.IX Xref "reg_numbered_buff_length"
.IX Item "reg_numbered_buff_length"
.IP "reg_numbered_buff_store" 4
.IX Xref "reg_numbered_buff_store"
.IX Item "reg_numbered_buff_store"
.IP "reg_qr_package" 4
.IX Xref "reg_qr_package"
.IX Item "reg_qr_package"
.IP "reg_temp_copy" 4
.IX Xref "reg_temp_copy"
.IX Item "reg_temp_copy"
.IP "regcurly" 4
.IX Xref "regcurly"
.IX Item "regcurly"
.IP "regpposixcc" 4
.IX Xref "regpposixcc"
.IX Item "regpposixcc"
.IP "regprop" 4
.IX Xref "regprop"
.IX Item "regprop"
.IP "report_evil_fh" 4
.IX Xref "report_evil_fh"
.IX Item "report_evil_fh"
.IP "report_redefined_cv" 4
.IX Xref "report_redefined_cv"
.IX Item "report_redefined_cv"
.IP "report_wrongway_fh" 4
.IX Xref "report_wrongway_fh"
.IX Item "report_wrongway_fh"
.IP "rpeep" 4
.IX Xref "rpeep"
.IX Item "rpeep"
.IP "rsignal_restore" 4
.IX Xref "rsignal_restore"
.IX Item "rsignal_restore"
.IP "rsignal_save" 4
.IX Xref "rsignal_save"
.IX Item "rsignal_save"
.IP "rxres_save" 4
.IX Xref "rxres_save"
.IX Item "rxres_save"
.IP "same_dirent" 4
.IX Xref "same_dirent"
.IX Item "same_dirent"
.IP "sawparens" 4
.IX Xref "sawparens"
.IX Item "sawparens"
.IP "scalar" 4
.IX Xref "scalar"
.IX Item "scalar"
.IP "scalarvoid" 4
.IX Xref "scalarvoid"
.IX Item "scalarvoid"
.IP "sighandlez" 4
.IX Xref "sighandlez"
.IX Item "sighandlez"
.IP "softref2xv" 4
.IX Xref "softref2xv"
.IX Item "softref2xv"
.IP "sub_crush_depth" 4
.IX Xref "sub_crush_depth"
.IX Item "sub_crush_depth"
.IP "sv_add_backref" 4
.IX Xref "sv_add_backref"
.IX Item "sv_add_backref"
.IP "sv_catxmlpv" 4
.IX Xref "sv_catxmlpv"
.IX Item "sv_catxmlpv"
.IP "sv_catxmlpvn" 4
.IX Xref "sv_catxmlpvn"
.IX Item "sv_catxmlpvn"
.IP "sv_catxmlsv" 4
.IX Xref "sv_catxmlsv"
.IX Item "sv_catxmlsv"
.IP "sv_del_backref" 4
.IX Xref "sv_del_backref"
.IX Item "sv_del_backref"
.IP "sv_free2" 4
.IX Xref "sv_free2"
.IX Item "sv_free2"
.IP "sv_kill_backrefs" 4
.IX Xref "sv_kill_backrefs"
.IX Item "sv_kill_backrefs"
.IP "sv_len_utf8_nomg" 4
.IX Xref "sv_len_utf8_nomg"
.IX Item "sv_len_utf8_nomg"
.IP "sv_mortalcopy_flags" 4
.IX Xref "sv_mortalcopy_flags"
.IX Item "sv_mortalcopy_flags"
.IP "sv_resetpvn" 4
.IX Xref "sv_resetpvn"
.IX Item "sv_resetpvn"
.IP "sv_sethek" 4
.IX Xref "sv_sethek"
.IX Item "sv_sethek"
.IP "sv_setsv_cow" 4
.IX Xref "sv_setsv_cow"
.IX Item "sv_setsv_cow"
.IP "sv_unglob" 4
.IX Xref "sv_unglob"
.IX Item "sv_unglob"
.IP "sv_xmlpeek" 4
.IX Xref "sv_xmlpeek"
.IX Item "sv_xmlpeek"
.IP "tied_method" 4
.IX Xref "tied_method"
.IX Item "tied_method"
.IP "token_free" 4
.IX Xref "token_free"
.IX Item "token_free"
.IP "token_getmad" 4
.IX Xref "token_getmad"
.IX Item "token_getmad"
.IP "translate_substr_offsets" 4
.IX Xref "translate_substr_offsets"
.IX Item "translate_substr_offsets"
.IP "try_amagic_bin" 4
.IX Xref "try_amagic_bin"
.IX Item "try_amagic_bin"
.IP "try_amagic_un" 4
.IX Xref "try_amagic_un"
.IX Item "try_amagic_un"
.IP "unshare_hek" 4
.IX Xref "unshare_hek"
.IX Item "unshare_hek"
.IP "utilize" 4
.IX Xref "utilize"
.IX Item "utilize"
.IP "varname" 4
.IX Xref "varname"
.IX Item "varname"
.IP "vivify_defelem" 4
.IX Xref "vivify_defelem"
.IX Item "vivify_defelem"
.IP "vivify_ref" 4
.IX Xref "vivify_ref"
.IX Item "vivify_ref"
.IP "wait4pid" 4
.IX Xref "wait4pid"
.IX Item "wait4pid"
.IP "was_lvalue_sub" 4
.IX Xref "was_lvalue_sub"
.IX Item "was_lvalue_sub"
.IP "watch" 4
.IX Xref "watch"
.IX Item "watch"
.IP "win32_croak_not_implemented" 4
.IX Xref "win32_croak_not_implemented"
.IX Item "win32_croak_not_implemented"
.IP "write_to_stderr" 4
.IX Xref "write_to_stderr"
.IX Item "write_to_stderr"
.IP "xmldump_all" 4
.IX Xref "xmldump_all"
.IX Item "xmldump_all"
.IP "xmldump_all_perl" 4
.IX Xref "xmldump_all_perl"
.IX Item "xmldump_all_perl"
.IP "xmldump_eval" 4
.IX Xref "xmldump_eval"
.IX Item "xmldump_eval"
.IP "xmldump_form" 4
.IX Xref "xmldump_form"
.IX Item "xmldump_form"
.IP "xmldump_indent" 4
.IX Xref "xmldump_indent"
.IX Item "xmldump_indent"
.IP "xmldump_packsubs" 4
.IX Xref "xmldump_packsubs"
.IX Item "xmldump_packsubs"
.IP "xmldump_packsubs_perl" 4
.IX Xref "xmldump_packsubs_perl"
.IX Item "xmldump_packsubs_perl"
.IP "xmldump_sub" 4
.IX Xref "xmldump_sub"
.IX Item "xmldump_sub"
.IP "xmldump_sub_perl" 4
.IX Xref "xmldump_sub_perl"
.IX Item "xmldump_sub_perl"
.IP "xmldump_vindent" 4
.IX Xref "xmldump_vindent"
.IX Item "xmldump_vindent"
.IP "xs_apiversion_bootcheck" 4
.IX Xref "xs_apiversion_bootcheck"
.IX Item "xs_apiversion_bootcheck"
.IP "xs_version_bootcheck" 4
.IX Xref "xs_version_bootcheck"
.IX Item "xs_version_bootcheck"
.IP "yyerror" 4
.IX Xref "yyerror"
.IX Item "yyerror"
.IP "yyerror_pv" 4
.IX Xref "yyerror_pv"
.IX Item "yyerror_pv"
.IP "yyerror_pvn" 4
.IX Xref "yyerror_pvn"
.IX Item "yyerror_pvn"
.IP "yylex" 4
.IX Xref "yylex"
.IX Item "yylex"
.IP "yyparse" 4
.IX Xref "yyparse"
.IX Item "yyparse"
.IP "yyunlex" 4
.IX Xref "yyunlex"
.IX Item "yyunlex"
.PD
.SH "AUTHORS"
.IX Header "AUTHORS"
Da autodocumentation system was originally added ta tha Perl core by
Benjamin Stuhl. Documentation is by whoever was kind enough to
document they functions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlguts, perlapi
