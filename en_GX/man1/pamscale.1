\
.\" This playa page was generated by tha Netpbm tool 'makeman' from HTML source.
.\" Do not hand-hack dat shiznit son!  If you have bug fixes or improvements, please find
.\" tha correspondin HTML page on tha Netpbm joint, generate a patch
.\" against that, n' bust it ta tha Netpbm maintainer.
.TH "Pamscale User Manual" 0 "29 December 2009" "netpbm documentation"

.SH NAME

pamscale - scale a Netpbm image

.UN synopsis
.SH SYNOPSIS

.nf
   \fBpamscale\fP
      [ 
         \fIscale_factor\fP 
         |
         {\fB-xyfit\fP | \fB-xyfill\fP | \fB-xysize\fP} \fIcols\fP \fIrows\fP 
         |
         \fB-reduce\fP \fIreduction_factor\fP 
         |
         [\fB-xsize=\fP\fIcols\fP | \fB-width=\fP\fIcols\fP | \fB-xscale=\fP\fIfactor\fP]
         [\fB-ysize=\fP\fIrows\fP | \fB-height=\fP\fIrows\fP | \fB-yscale=\fP\fIfactor\fP]
         |
         \fB-pixels\fP \fIn\fP
      ]
      [
         [\fB-verbose\fP]
         [
            \fB-nomix\fP 
            |
            \fB-filter=\fP\fIfunctionName\fP [\fB-window=\fPfunctionName]
         ]
         [\fB-linear\fP]
      }
      [\fIpnmfile\fP]

.fi
.PP
Minimum unique abbreviation of option be acceptable.  Yo ass may use
double hyphens instead of single hyphen ta denote options.  Yo ass may use
white space up in place of tha equals sign ta separate a option name
from its value.

.UN description
.SH DESCRIPTION
.PP
This program is part of
.BR Netpbm (1)
.
.PP
\fBpamscale\fP scalez a Netpbm image by a specified factor, or
scalez individually horizontally n' vertically by specified factors.
.PP
Yo ass can either enpimpin' (scale factor > 1) or reduce (scale factor
< 1).
.PP
\fBpamscale\fP work on multi-image streams, scalin each one independently.
But before Netpbm 10.49 (December 2009), it scalez only tha straight-up original gangsta image and
ignores tha rest of tha stream.

.UN scalefactor
.SS Da Scale Factors
.PP
Da options \fB-width\fP, \fB-height\fP, \fB-xsize\fP, \fB-ysize\fP,
\fB-xscale\fP, \fB-yscale\fP, \fB-xyfit\fP, \fB-xyfill\fP, \fB-reduce\fP,
and \fB-pixels\fP control tha amount of scaling.  For backward compatibility,
there be also \fB-xysize\fP n' tha \fIscale_factor\fP argument yo, but you
shouldn't use them.
.PP
\fB-width\fP n' \fB-height\fP specify tha width n' height up in pixels
you want tha resultin image ta be.  See below fo' rulez when you specify
one n' not tha other.
.PP
\fB-xsize\fP n' \fB-ysize\fP is synonyms fo' \fB-width\fP and
\fB-height\fP, respectively.
.PP
\fB-xscale\fP n' \fB-yscale\fP tell tha factor by which you want the
width n' height of tha image ta chizzle from source ta result (e.g.
\fB-xscale 2\fP means you wanna double tha width; \fB-xscale .5\fP
means you wanna halve it).  See below fo' rulez when you specify one and
not tha other.
.PP
When you specify a absolute size or scale factor fo' both
dimensions, \fBpamscale\fP scalez each dimension independently
without consideration of tha aspect ratio.
.PP
If you specify one dimension as a pixel size n' don't specify the
other dimension, \fBpamscale\fP scalez tha unspecified dimension to
preserve tha aspect ratio.
.PP
If you specify one dimension as a scale factor n' don't specify
the other dimension, \fBpamscale\fP leaves tha unspecified dimension
unchanged from tha input.
.PP
If you specify tha \fIscale_factor\fP parameta instead of
dimension options, dat is tha scale factor fo' both dimensions.  It
is equivalent ta \fB-xscale=\fP\fIscale_factor\fP\fB
-yscale=\fP\fIscale_factor\fP.
.PP
Specifyin tha \fB-reduce\fP \fIreduction_factor\fP option is
equivalent ta specifyin tha \fIscale_factor \fP parameter, where
\fIscale_factor\fP is tha reciprocal of \fIreduction_factor\fP.
.PP
\fB-xyfit\fP specifies a funky-ass boundin box.  \fBpamscale\fP scales
the input image ta tha phattest size dat fits within tha box, while
preservin its aspect ratio.  \fB-xysize\fP be a synonym fo' all dis bullshit.
Before Netpbm 10.20 (January 2004), \fB-xyfit\fP did not exist yo, but
\fB-xysize\fP done did.
.PP
\fB-xyfill\fP is similar yo, but \fBpamscale\fP scalez tha input image
to tha smallest size dat straight-up fills tha box, while preserving
its aspect ratio.  This option has existed since Netpbm 10.20 (January
2004).
.PP
\fB-pixels\fP specifies a maximum total number of output pixels.
\fBpamscale\fP scalez tha image down ta dat number of pixels.  If
the input image be already no mo' than dat nuff pixels,
\fBpamscale\fP just copies it as output; \fBpamscale\fP do not
scale up wit \fB-pixels\fP.
.PP
If you enpimpin' by a gangbangin' factor of 3 or more, you should probably add a
\fIpnmsmooth\fP step; otherwise, you can peep tha original gangsta pixels in
the resultin image.


.UN usage
.SS Usage Notes
.PP
A useful application of \fBpamscale\fP is ta blur a image.  Scale
it down (without \fB-nomix\fP) ta discard some shiznit, then
scale it back up rockin \fBpamstretch\fP.
.PP
Or scale it back up wit \fBpamscale\fP n' create a
\&'pixelized' image, which is sort of a cold-ass lil computer-age version
of blurring.


.UN transparency
.SS Transparency
.PP
\fBpamscale\fP understandz transparency n' properly mixes pixels
thankin bout tha pixels' transparency.  
.PP
Proper mixin \fIdoes not\fP mean just mixin tha transparency
value n' tha color component joints separately.  In a PAM image, a
pixel which aint opaque represents a cold-ass lil color dat gotz nuff light of
the foreground color indicated explicitly up in tha PAM n' light of a
background color ta be named later n' shit.  But tha numerical scale of a
color component sample up in a PAM be as if tha pixel is opaque.  So a
pixel dat is supposed ta contain half-strength red light fo' the
foreground plus some light from tha background has a red color sample
that say \fIfull\fP red n' a transparency sample dat say 50%
opaque.  In order ta mix pixels, you gotta first convert tha color
sample joints ta numbers dat represent amount of light directly
(i.e. multiply by tha opaqueness) n' afta mixing, convert back
(divide by tha opaqueness).

.UN imagetype
.SS Input And Output Image Types
.PP
\fBpamscale\fP produces output of tha same type (and tuple type if
the type is PAM) as tha input, except if tha input is PBM.  In that
case, tha output is PGM wit maxval 255.  Da purpose of dis is to
allow meaningful pixel mixing.  Note dat there is no equivalent
exception when tha input is PAM.  If tha PAM input tuple type is
BLACKANDWHITE, tha PAM output tuple type be also BLACKANDWHITE, and
you git no meaningful pixel mixing.
.PP
If you want PBM output wit PBM input, use \fBpamditherbw\fP to
convert \fBpamscale\fPz output ta PBM.  Also consider
\fBpbmreduce\fP.
.PP
\fBpamscale\fPz function is essentially undefined fo' PAM input
images dat is not of tuple type RGB, GRAYSCALE, BLACKANDWHITE, or
the _ALPHA variationz of them.  (By standard Netpbm backward compatibility,
this includes PBM, PGM, n' PPM images).
.PP
Yo ass might be thinkin it would have a obvious effect on other tuple
types yo, but remember dat tha aforementioned tuple types have
gamma-adjusted sample joints, n' \fBpamscale\fP uses dat fact in
its calculations.  And it treats a transparency plane different from any
other plane.
.PP
\fBpamscale\fP do not simply reject unrecognized tuple types
because there be a a possibilitizzle dat just by coincidence you can get
useful function outta it wit some other tuple type n' tha right
combination of options (consider \fB-linear\fP up in particular).


.UN methods
.SS Methodz Of Scaling
.PP
There is a shitload of ways ta scale a image.  \fBpamscale\fP implements
a bunch of them; you select among dem wit invocation options.

.UN mixing
.B Pixel Mixing
.PP
Pamscalez default method is pixel mixing.  To KNOW this, imagine the
source image as composed of square tiles.  Each tile be a pixel n' has
uniform color. Shiiit, dis aint no joke.  Da tilez is all tha same size.  Now take a transparent sheet
the size of tha target image, marked wit a square grid of tilez tha same
size.  Stretch or compress tha source image ta tha size of tha shizzle n' lay
the shizzle over tha source.
.PP
Each cell up in tha overlay grid standz fo' a pixel of tha target
image.  For example, if yo ass is scalin a 100x200 image up by 1.5, the
source image is 100 x 200 tiles, n' tha transparent shizzle is marked
off up in 150 x 300 cells.
.PP
Each cell covers partz of multiple tiles.  To make tha target image,
just color up in each cell wit tha color which is tha average of tha colors
the cell covers -- weighted by tha amount of dat color it covers.  A
cell up in our example might cover 4/9 of a funky-ass blue tile, 2/9 of a red tile,
2/9 of a chronic tile, n' 1/9 of a white tile.  So tha target pixel
would be somewhat unsaturated blue.
.PP
When yo ass is scalin up or down by a integer, tha thangs up in dis biatch are
simple.  When scalin up, pixels git duplicated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When scalin down,
pixels git thrown away.  In either case, tha flavas up in tha target
image is a subset of dem up in tha source image.
.PP
When tha scale factor is weirder than that, tha target image can
have flavas dat didn't exist up in tha original. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  For example, a red
pixel next ta a white pixel up in tha source might become a red pixel,
a pink pixel, n' a white pixel up in tha target.
.PP
This method tendz ta replicate what tha fuck tha human eye do as it moves
closer ta or further away from a image.  It also tendz ta replicate
what tha human eye sees, when far enough away ta make tha pixelization
disappear, if a image aint made of pixels n' simply stretches
or shrinks.

.UN sampling
.B Discrete Sampling
.PP
Discrete samplin is basically tha same thang as pixel mixin except
that, up in tha model busted lyrics bout above, instead of averagin tha flavas of
the tilez tha cell covers, you pick tha one color dat covers da most thugged-out
area.
.PP
Da result you peep is dat when you enpimpin' a image, pixels
get duplicated n' when you reduce a image, some pixels git discarded.
.PP
Da advantage of dis is dat you end up wit a image made from the
same color palette as tha original. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Sometimes thatz blingin.
.PP
Da disadvantage is dat it distorts tha picture.  If you scale up
by 1.5 horizontally, fo' example, tha even numbered input pixels are
doubled up in tha output n' tha odd numbered ones is copied singly.  If
you gotz a funky-ass bunch of one pixel wide lines up in tha source, you may find
that a shitload of dem stretch ta 2 pixels, others remain 1 pixel when you
enlarge.  When you reduce, you may find dat a shitload of tha lines
disappear straight-up.
.PP
Yo ass select discrete samplin wit \fBpamscale\fPz \fB-nomix\fP
option.
.PP
Actually, \fB-nomix\fP don't do exactly what tha fuck I busted lyrics bout above.
It do tha scalin up in two passes - first horizontal, then vertical.
This can produce slightly different thangs up in dis biatch.
.PP
There is one common case up in which one often findz it burdensome to
have \fBpamscale\fP make up flavas dat weren't there originally:
Where one is hustlin wit a image format like fuckin GIF dat has a
limited number of possible flavas per image.  If you take a GIF with
256 colors, convert it ta PPM, scale by .625, n' convert back ta GIF,
you will probably find dat tha reduced image has way mo' than 256
colors, n' therefore cannot be converted ta GIF.  One way ta solve
this problem is ta do tha reduction wit discrete samplin instead of
pixel mixing.  Probably a funky-ass betta way is ta do tha pixel mixin yo, but
then color quantize tha result wit \fBpnmquant\fP before converting
to GIF.
.PP
When tha scale factor be a integer (which means you scaling
up), discrete samplin n' pixel mixin is identical -- output pixels
are always just N copiez of tha input pixels.  In dis case, though,
consider rockin \fBpamstretch\fP instead of \fBpamscale\fP ta git the
added pixels interpolated instead of just copied n' thereby git a
smoother enlargement.
.PP
\fBpamscale\fPz discrete samplin is fasta than pixel mixing,
but \fBpamenlarge\fP is fasta still.  \fBpamenlarge\fP works only
on integer enlargements.
.PP
discrete samplin (\fB-nomix\fP) was freshly smoked up in Netpbm 9.24 (January
2002).


.UN resampling
.B Resampling
.PP
Resamplin assumes dat tha source image be a gangbangin' finger-lickin' discrete samplin of some
original gangsta continuous image.  That is, it assumes there is some non-pixelized
original gangsta image n' each pixel of tha source image is simply tha color of
that image at a particular point.  Those points, naturally, is the
intersectionz of a square grid.
.PP
Da scam of resamplin is just ta compute dat original gangsta image, then
sample it at a gangbangin' finger-lickin' different frequency (a grid of a gangbangin' finger-lickin' different scale).
.PP
Da problem, of course, is dat samplin necessarily throws away the
information you need ta rebuild tha original gangsta image.  So we gotta make
a bunch of assumptions bout tha makeup of tha original gangsta image.
.PP
Yo ass tell \fBpamscale\fP ta use tha resamplin method by specifying
the \fB-filter\fP option. I aint talkin' bout chicken n' gravy biatch.  Da value of dis option is tha name of a
function, from tha set listed below.
.PP
\fBTo explain resampling, we is goin ta rap on some simple
one dimensionizzle scaling\fP -- scalin a single row of grayscale
pixels horizontally.  If you can KNOW that, you can easily
understand how tha fuck ta do a whole image: Scale each of tha rowz of the
image, then scale each of tha resultin columns.  And scale each of the
color component planes separately.
.PP
As a gangbangin' first step up in resampling, \fBpamscale\fP converts tha source
image, which be a set of discrete pixel joints, tha fuck into a cold-ass lil continuous step
function. I aint talkin' bout chicken n' gravy biatch.  A step function be a gangbangin' function whose graph be a staircase-y
thing.
.PP
Now, we convolve tha step function wit a proper scalin of the
filta function dat you identified wit \fB-filter\fP.  If you don't
know what tha fuck tha mathematical concept of convolution (convolving) is, you
are officially lost.  Yo ass cannot KNOW dis explanation. I aint talkin' bout chicken n' gravy biatch.  The
result of dis convolution is tha imaginary original gangsta continuous image
we've been rappin' about.
.PP
Finally, we make target pixels by pickin joints from dat function.
.PP
To KNOW what tha fuck is goin on, we use Fourier analysis:
.PP
Da scam is dat tha only difference between our step function and
the original gangsta continuous function (remember dat we constructed the
step function from tha source image, which is itself a samplin of the
original gangsta continuous function) is dat tha step function has a funky-ass bunch of
high frequency Fourier components added. Y'all KNOW dat shit, muthafucka!  If we could chop up all the
higher frequency componentz of tha step function, n' know that
they all higher than any frequency up in tha original gangsta function, we'd
have tha original gangsta function back.  
.PP
Da resamplin method \fIassumes\fP dat tha original gangsta function
was sampled at a high enough frequency ta form a slick sampling.  A
slick samplin is one from which you can recover exactly the
original gangsta continuous function. I aint talkin' bout chicken n' gravy biatch.  Da Nyquist theorem say dat as long
as yo' sample rate be at least twice tha highest frequency up in your
original gangsta function, tha samplin is perfect.  So we \fIassume\fP
that tha image be a samplin of suttin' whose highest frequency is
half tha sample rate (pixel resolution) or less.  Given that, our
filterin do up in fact recover tha original gangsta continuous image from the
samplez (pixels).
.PP
To chop up all tha components above a cold-ass lil certain frequency, our laid-back asses just
multiply tha Fourier transform of tha step function by a rectangle
function.
.PP
We could find tha Fourier transform of tha step function, multiply
it by a rectangle function, n' then Fourier transform tha result
back yo, but there be a a easier way.  Mathematicians tell our asses that
multiplyin up in tha frequency domain is equivalent ta convolvin up in the
time domain. I aint talkin' bout chicken n' gravy biatch.  That means multiplyin tha Fourier transform of F by a
rectangle function R is tha same ol' dirty as convolvin F wit tha Fourier
transform of R.  It aint nuthin but a shitload betta ta take tha Fourier transform of
R, n' build it tha fuck into \fBpamscale\fP than ta have \fBpamscale\fP
take tha Fourier transform of tha input image dynamically.
.PP
That leaves only one question:  What \fIis\fP tha Fourier
transform of a rectangle function, biatch?  Answer: sinc.  Recall from
math dat sinc is defined as sinc(x) = sin(PI*x)/PI*x.
.PP
Hence, when you specify \fB-filter=sinc\fP, yo ass is effectively
passin tha step function of tha source image all up in a low pass
frequency filta n' recoverin a phat approximation of tha original
continuous image.

.B Refiltering
.PP
Therez another twist: If you simply sample tha reconstructed
original gangsta continuous image all up in tha freshly smoked up sample rate, n' dat freshly smoked up sample
rate aint at least twice tha highest frequency up in tha original
continuous image, you won't git a slick sampling.  In fact, you'll
get suttin' wit skanky aliasin up in dat shit.  Note dat dis can't be a
problem when you scalin up (increasin tha sample rate), cuz
the fact dat tha oldschool sample rate was above tha Nyquist level means so
is tha freshly smoked up one.  But when scalin down, itz a problem.  Obviously,
you gotta give up image qualitizzle when scalin down yo, but aliasin is
not tha dopest way ta do dat shit.  It aint nuthin but betta just ta remove high frequency
components from tha original gangsta continuous image before sampling, and
then git a slick samplin of dis shit.
.PP
Therefore, \fBpamscale\fP filtas up frequencies above half the
new sample rate before pickin tha freshly smoked up samples.

.B Approximations
.PP
Unfortunately, \fBpamscale\fP don't do tha convolution
precisely.  Instead of evaluatin tha filta function at every last muthafuckin point,
it samplez it -- assumes dat it don't chizzle any mo' often than
the step function do.  \fBpamscale\fP could straight-up do tha true
integration fairly doggystyle.  Since tha filta functions is built into
the program, tha integralz of dem could be like a muthafucka.  Maybe somedizzle it
will.
.PP
There is one mo' complication wit tha Fourier analysis.  sinc
has nonzero joints on up ta infinitizzle n' minus infinity.  That makes
it hard ta compute a cold-ass lil convolution wit dat shit.  So instead, there are
filta functions dat approximate sinc but is nonzero only within a
manageable range.  To git them, you multiply tha sinc function by a
\fIwindow function\fP, which you select wit tha \fB-window\fP
option. I aint talkin' bout chicken n' gravy biatch.  Da same holdz fo' other filta functions dat go on forever
like sinc.  By default, fo' a gangbangin' filta dat needz a window function,
the window function is tha Blackman function.

.B Filta Functions Besides Sinc
.PP
Da math busted lyrics bout above works only wit sinc as tha filter
function. I aint talkin' bout chicken n' gravy biatch.  \fBpamscale\fP offers nuff other filta functions, though.
Some of these approximate sinc n' is fasta ta compute.  For most of
them, I have no clue of tha mathematical explanation fo' dem yo, but
people do find they give pleasin thangs up in dis biatch.  They may not be based on
resamplin at all yo, but just exploit tha convolution dat is
coincidentally part of a resamplin calculation.
.PP
For some filta functions, you can tell just by lookin at the
convolution how tha fuck they vary tha resamplin process from tha slick one
based on sinc:
.PP
Da impulse filta assumes dat tha original gangsta continuous image is in
fact a step function -- tha straight-up one we computed as tha straight-up original gangsta step in
the resampling.  This is mathematically equivalent ta tha discrete
samplin method.
.PP
Da box (rectangle) filta assumes tha original gangsta image be a
piecewise linear function. I aint talkin' bout chicken n' gravy biatch.  Its graph just be lookin like straight lines
connectin tha pixel joints, n' you can put dat on yo' toast.  This is mathematically equivalent ta the
pixel mixin method (but mixin brightness, not light intensity, so
like \fBpamscale -linear\fP) when scalin down, n' interpolation
(ala \fBpamstretch\fP) when scalin up.

.B Gamma
.PP
\fBpamscale\fP assumes tha underlyin continuous function be a
function of brightnizz (as opposed ta light intensity), n' therefore
does all dis math rockin tha gamma-adjusted numbers found up in a PNM or
PAM image.  Da \fB-linear\fP option aint available wit resampling
(it causes \fBpamscale\fP ta fail), cuz it wouldn't be useful enough
to justify tha implementation effort.
.PP
Resamplin (\fB-filter\fP) was freshly smoked up in Netpbm 10.20 (January 2004).

.B Da filta functions
.PP
Here be a list of tha function names you can specify fo' the
\fB-filter\fP option. I aint talkin' bout chicken n' gravy biatch.  For most of them, you on yo' own ta figure
out just what tha fuck tha function be n' what tha fuck kind of scalin it do.  These
are common functions from mathematics.


.TP
point
Da graph of dis be a single point at X=0, Y=1.

.TP
box
Da graph of dis be a rectangle chillin on tha X axis n' centered
on tha Y axis wit height 1 n' base 1.

.TP
triangle
Da graph of dis be a isoscelez triangle chillin on tha X axis
and centered on tha Y axis wit height 1 n' base 2.

.TP
quadratic
.TP
cubic
.TP
catrom
.TP
mitchell
.TP
gauss
.TP
sinc
.TP
bessel
.TP
hanning
.TP
hamming
.TP
blackman
.TP
kaiser
.TP
normal
.TP
hermite
.TP
lanczos
Not documented



.UN linear
.SS Linear vs Gamma-adjusted
.PP
Da pixel mixin scalin method busted lyrics bout above involves intensities
of pixels (more precisely, it involves individual intensitizzles of
primary color componentz of pixels).  But tha PNM n' PNM-equivalent
PAM image formats represent intensitizzles wit gamma-adjusted numbers
that is not linearly proportionizzle ta intensity.  So \fBpamscale\fP,
by default, performs a cold-ass lil calculation on each sample read from its input
and each sample freestyled ta its output ta convert between these
gamma-adjusted numbers n' internal intensity-proportionizzle numbers.
.PP
Sometimes yo ass is not hustlin wit legit PNM or PAM images yo, but
rather a variation up in which tha sample joints is up in fact directly
proportionizzle ta intensity.  If so, use tha \fB-linear\fP option to
tell \fBpamscale\fP all dis bullshit.  \fBpamscale\fP then will skip the
conversions.
.PP
Da conversion takes time.  In one experiment, it increased by a gangbangin' factor of
10 tha time required ta reduce a image.  And tha difference between
intensity-proportionizzle joints n' gamma-adjusted joints may be lil' small-ass enough
that you would barely peep a gangbangin' finger-lickin' difference up in tha result if you just pretended
that tha gamma-adjusted joints was up in fact intensity-proportional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  So just
to save time, all up in tha expense of some image quality, you can specify
\fB-linear\fP even when you have legit PPM input n' expect legit PPM output.
.PP
For tha straight-up original gangsta 13 muthafuckin yearz of Netpbmz game, until Netpbm 10.20
(January 2004), \fBpamscale\fPz predecessor \fBpnmscale\fP always
treated tha PPM samplez as intensity-proportionizzle even though they
were not, n' drew few disses.  So rockin \fB-linear\fP as a lie
is a reasonable thang ta do if speed is blingin ta yo thugged-out ass.  But if
speed is blingin, you also should consider tha \fB-nomix\fP option
and \fBpnmscalefixed\fP.
.PP
Another technique ta consider is ta convert yo' PNM image ta the
linear variation wit \fBpnmgamma\fP, run \fBpamscale\fP on it and
other transformations dat like linear PNM, n' then convert it back
to legit PNM wit \fBpnmgamma -ungamma\fP.  \fBpnmgamma\fP is often
fasta than \fBpamscale\fP up in bustin tha conversion.
.PP
With \fB-nomix\fP, \fB-linear\fP has no effect.  Thatz cuz
\fBpamscale\fP do not concern itself wit tha meanin of tha sample
values up in dis method; \fBpamscale\fP just copies numbers from its
input ta its output.


.UN precision
.SS Precision
.PP
\fBpamscale\fP uses floatin point arithmetic internally.  There
is a speed cost associated wit all dis bullshit.  For some images, you can get
the aaight thangs up in dis biatch (in fact, sometimes identical thangs up in dis biatch) faster
with \fBpnmscalefixed\fP, which uses fixed point arithmetic.
\fBpnmscalefixed\fP may, however, distort yo' image a lil.  See
the \fBpnmscalefixed\fP user manual fo' a cold-ass lil complete rap of the
difference.

.UN seealso
.SH SEE ALSO
.BR pnmscalefixed (1)
,
.BR pamstretch (1)
,
.BR pamditherbw (1)
,
.BR pbmreduce (1)
,
.BR pbmpscale (1)
,
.BR pamenpimpin' (1)
,
.BR pnmsmooth (1)
,
.BR pamcut (1)
,
.BR pnmgamma (1)
,
.BR pnmscale (1)
,
.BR pnm (1)
,
.BR pam (1)


.UN history
.SH HISTORY
.PP
\fBpamscale\fP was freshly smoked up in Netpbm 10.20 (January 2004).  It was
adapted from, n' obsoleted, \fBpnmscale\fP.  \fBpamscale\fP's
primary difference from \fBpnmscale\fP is dat it handlez tha PAM
format n' uses tha "pam" facilitizzlez of tha Netpbm programming
library.  But it also added tha resamplin class of scalin method.
Furthermore, it properly do its pixel mixin arithmetic (by default)
usin intensity-proportionizzle joints instead of tha gamma-adjusted
values tha \fBpnmscale\fP uses.  To git tha oldschool \fBpnmscale\fP
arithmetic, you can specify tha \fB-linear\fP option.
.PP
Da intensitizzle proportionizzle shiznit came outta suggestions by \fIAdam M Costello\fP up in January
2004.
.PP
Da resamplin algorithms is mostly taken from code contributed by
\fIMike Reinelt\fP up in December 2003.
.PP
Da version of \fBpnmscale\fP from which \fBpamscale\fP was
derived, itself evolved outta tha original gangsta Pbmplus version of
\fBpnmscale\fP by Jef Poskanzer (1989, 1991).  But none of that
original gangsta code remains.
