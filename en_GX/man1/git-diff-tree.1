'\" t
.\"     Title: git-diff-tree
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-DIFF\-TREE" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-diff-tree \- Compares tha content n' mode of blobs found via two tree objects
.SH "SYNOPSIS"
.sp
.nf
\fIgit diff\-tree\fR [\-\-stdin] [\-m] [\-s] [\-v] [\-\-no\-commit\-id] [\-\-pretty]
              [\-t] [\-r] [\-c | \-\-cc] [\-\-root] [<common diff options>]
              <tree\-ish> [<tree\-ish>] [<path>\&...]
.fi
.sp
.SH "DESCRIPTION"
.sp
Compares tha content n' mode of tha blobs found via two tree objects\&.
.sp
If there is only one <tree\-ish> given, tha commit is compared wit its muthafathas (see \-\-stdin below)\&.
.sp
Note dat \fIgit diff\-tree\fR can use tha tree encapsulated up in a cold-ass lil commit object\&.
.SH "OPTIONS"
.PP
\-p, \-u, \-\-patch
.RS 4
Generate patch (see section on generatin patches)\&.
.RE
.PP
\-s, \-\-no\-patch
.RS 4
Suppress diff output\&. Useful fo' commandz like
git show
that show tha patch by default, or ta quit tha effect of
\-\-patch\&.
.RE
.PP
\-U<n>, \-\-unified=<n>
.RS 4
Generate diffs wit <n> linez of context instead of tha usual three\&. Implies
\-p\&.
.RE
.PP
\-\-raw
.RS 4
Generate tha raw format\&. This is tha default\&.
.RE
.PP
\-\-patch\-with\-raw
.RS 4
Synonym for
\-p \-\-raw\&.
.RE
.PP
\-\-minimal
.RS 4
Spend extra time ta make shizzle tha smallest possible diff is produced\&.
.RE
.PP
\-\-patience
.RS 4
Generate a gangbangin' finger-lickin' diff rockin tha "patience diff" algorithm\&.
.RE
.PP
\-\-histogram
.RS 4
Generate a gangbangin' finger-lickin' diff rockin tha "histogram diff" algorithm\&.
.RE
.PP
\-\-diff\-algorithm={patience|minimal|histogram|myers}
.RS 4
Choose a gangbangin' finger-lickin' diff algorithm\&. Da variants is as bigs up:
.PP
default, myers
.RS 4
Da basic greedy diff algorithm\&. Currently, dis is tha default\&.
.RE
.PP
minimal
.RS 4
Spend extra time ta make shizzle tha smallest possible diff is produced\&.
.RE
.PP
patience
.RS 4
Use "patience diff" algorithm when generatin patches\&.
.RE
.PP
histogram
.RS 4
This algorithm extendz tha patience algorithm ta "support low\-occurrence common elements"\&.
.RE
.sp
For instance, if you configured diff\&.algorithm variable ta a non\-default value n' wanna use tha default one, then you gotta use
\-\-diff\-algorithm=default
option\&.
.RE
.PP
\-\-stat[=<width>[,<name\-width>[,<count>]]]
.RS 4
Generate a gangbangin' finger-lickin' diffstat\&. By default, as much space as necessary is ghon be used fo' tha filename part, n' tha rest fo' tha graph part\&. Maximum width defaults ta terminal width, or 80 columns if not connected ta a terminal, n' can be overridden by
<width>\&. Da width of tha filename part can be limited by givin another width
<name\-width>
afta a cold-ass lil comma\&. Da width of tha graph part can be limited by using
\-\-stat\-graph\-width=<width>
(affects all commandz generatin a stat graph) or by setting
diff\&.statGraphWidth=<width>
(does not affect
git format\-patch)\&. By givin a third parameter
<count>, you can limit tha output ta tha first
<count>
lines, followed by
\&.\&.\&.
if there be more\&.
.sp
These parametas can also be set individually with
\-\-stat\-width=<width>,
\-\-stat\-name\-width=<name\-width>
and
\-\-stat\-count=<count>\&.
.RE
.PP
\-\-numstat
.RS 4
Similar to
\-\-stat yo, but shows number of added n' deleted lines up in decimal notation n' pathname without abbreviation, ta make it mo' machine bumpin'\&. For binary files, outputs two
\-
instead of saying
0 0\&.
.RE
.PP
\-\-shortstat
.RS 4
Output only tha last line of the
\-\-stat
format containin total number of modified files, as well as number of added n' deleted lines\&.
.RE
.PP
\-\-dirstat[=<param1,param2,\&...>]
.RS 4
Output tha distribution of relatizzle amount of chizzlez fo' each sub\-directory\&. Da behavior of
\-\-dirstat
can be customized by passin it a cold-ass lil comma separated list of parameters\&. Da defaults is controlled by the
diff\&.dirstat
configuration variable (see
\fBgit-config\fR(1))\&. Da followin parametas is available:
.PP
changes
.RS 4
Compute tha dirstat numbers by countin tha lines dat done been removed from tha source, or added ta tha destination\&. This ignores tha amount of pure code movements within a gangbangin' file\&. In other lyrics, rearrangin lines up in a gangbangin' file aint counted as much as other chizzles\&. This is tha default behavior when no parameta is given\&.
.RE
.PP
lines
.RS 4
Compute tha dirstat numbers by bustin tha regular line\-based diff analysis, n' summin tha removed/added line counts\&. (For binary files, count 64\-byte chunks instead, since binary filez have no natural concept of lines)\&. This be a mo' expensive
\-\-dirstat
behavior than the
changes
behavior yo, but it do count rearranged lines within a gangbangin' file as much as other chizzles\&. Da resultin output is consistent wit what tha fuck you git from tha other
\-\-*stat
options\&.
.RE
.PP
files
.RS 4
Compute tha dirstat numbers by countin tha number of filez chizzled\&. Each chizzled file counts equally up in tha dirstat analysis\&. This is tha computationally skankyest
\-\-dirstat
behavior, since it do not gotta peep tha file contents at all\&.
.RE
.PP
cumulative
.RS 4
Count chizzlez up in a cold-ass lil lil pimp directory fo' tha parent directory as well\&. Note dat when using
cumulative, tha sum of tha cementages reported may exceed 100%\&. Da default (non\-cumulative) behavior can be specified wit the
noncumulative
parameter\&.
.RE
.PP
<limit>
.RS 4
An integer parameta specifies a cold-ass lil cut\-off cement (3% by default)\&. Directories contributin less than dis cementage of tha chizzlez is not shown up in tha output\&.
.RE
.sp
Example: Da followin will count chizzled files, while ignorin directories wit less than 10% of tha total amount of chizzled files, n' accumulatin lil pimp directory counts up in tha parent directories:
\-\-dirstat=files,10,cumulative\&.
.RE
.PP
\-\-summary
.RS 4
Output a cold-ass lil condensed summary of extended header shiznit like fuckin creations, renames n' mode chizzles\&.
.RE
.PP
\-\-patch\-with\-stat
.RS 4
Synonym for
\-p \-\-stat\&.
.RE
.PP
\-z
.RS 4
When
\-\-raw,
\-\-numstat,
\-\-name\-only
or
\-\-name\-status
has been given, do not munge pathnames n' use NULs as output field terminators\&.
.sp
Without dis option, each pathname output gonna git TAB, LF, double quotes, n' backslash charactas replaced with
\et,
\en,
\e", and
\e\e, respectively, n' tha pathname is ghon be enclosed up in double quotes if any of dem replacements occurred\&.
.RE
.PP
\-\-name\-only
.RS 4
Show only namez of chizzled files\&.
.RE
.PP
\-\-name\-status
.RS 4
Show only names n' statuz of chizzled files\&. Right back up in yo muthafuckin ass. See tha description of the
\-\-diff\-filter
option on what tha fuck tha status lettas mean\&.
.RE
.PP
\-\-submodule[=<format>]
.RS 4
Specify how tha fuck differences up in submodulez is shown\&. When
\-\-submodule
or
\-\-submodule=log
is given, the
\fIlog\fR
format is used\&. This format lists tha commits up in tha range like
\fBgit-submodule\fR(1)summary
does\&. Omittin the
\-\-submodule
option or specifying
\-\-submodule=short, uses the
\fIshort\fR
format\&. This format just shows tha namez of tha commits all up in tha beginnin n' end of tha range\&. Can be tweaked via the
diff\&.submodule
configuration variable\&.
.RE
.PP
\-\-color[=<when>]
.RS 4
Show colored diff\&.
\-\-color
(i\&.e\&. without
\fI=<when>\fR) is tha same ol' dirty as
\-\-color=always\&.
\fI<when>\fR
can be one of
always,
never, or
auto\&.
.RE
.PP
\-\-no\-color
.RS 4
Turn off colored diff\&. Well shiiiit, it is tha same ol' dirty as
\-\-color=never\&.
.RE
.PP
\-\-word\-diff[=<mode>]
.RS 4
Show a word diff, rockin tha <mode> ta delimit chizzled lyrics\&. By default, lyrics is delimited by whitespace; see
\-\-word\-diff\-regex
below\&. Da <mode> defaults to
\fIplain\fR, n' must be one of:
.PP
color
.RS 4
Highlight chizzled lyrics rockin only colors\&. Implies
\-\-color\&.
.RE
.PP
plain
.RS 4
Show lyrics as
[\-removed\-]
and
{+added+}\&. Makes no attempts ta escape tha delimitas if they step tha fuck up in tha input, so tha output may be ambiguous\&.
.RE
.PP
porcelain
.RS 4
Use a special line\-based format intended fo' script consumption\& fo' realz. Added/removed/unchanged runs is printed up in tha usual unified diff format, startin wit a
+/\-/` ` characta all up in tha beginnin of tha line n' extendin ta tha end of tha line\&. Newlines up in tha input is represented by a tilde
~
on a line of its own\&.
.RE
.PP
none
.RS 4
Disable word diff again\&.
.RE
.sp
Note dat despite tha name of tha straight-up original gangsta mode, color is used ta highlight tha chizzled parts up in all modes if enabled\&.
.RE
.PP
\-\-word\-diff\-regex=<regex>
.RS 4
Use <regex> ta decizzle what tha fuck a word is, instead of thankin bout runz of non\-whitespace ta be a word\& fo' realz. Also implies
\-\-word\-diff
unless dat shiznit was already enabled\&.
.sp
Every non\-overlappin match of tha <regex> is considered a word\& fo' realz. Anythang between these matches is considered whitespace n' ignored(!) fo' tha purposez of findin differences\&. Yo ass may wanna append
|[^[:space:]]
to yo' regular expression ta make shizzle dat it matches all non\-whitespace characters\& fo' realz. A match dat gotz nuff a newline is silently truncated(!) all up in tha newline\&.
.sp
Da regex can also be set via a gangbangin' finger-lickin' diff driver or configuration option, see
\fBgitattributes\fR(1)
or
\fBgit-config\fR(1)\&. Givin it explicitly overrides any diff driver or configuration setting\&. Diff drivers override configuration settings\&.
.RE
.PP
\-\-color\-words[=<regex>]
.RS 4
Equivalent to
\-\-word\-diff=color
plus (if a regex was specified)
\-\-word\-diff\-regex=<regex>\&.
.RE
.PP
\-\-no\-renames
.RS 4
Turn off rename detection, even when tha configuration file gives tha default ta do so\&.
.RE
.PP
\-\-check
.RS 4
Warn if chizzlez introduce whitespace errors\&. What is considered whitespace errors is controlled by
core\&.whitespace
configuration\&. By default, trailin whitespaces (includin lines dat solely consist of whitespaces) n' a space characta dat is immediately followed by a tab characta inside tha initial indent of tha line is considered whitespace errors\&. Exits wit non\-zero status if problems is found\&. Not compatible wit \-\-exit\-code\&.
.RE
.PP
\-\-full\-index
.RS 4
Instead of tha straight-up original gangsta handful of characters, show tha full pre\- n' post\-image blob object names on tha "index" line when generatin patch format output\&.
.RE
.PP
\-\-binary
.RS 4
In addizzle to
\-\-full\-index, output a funky-ass binary diff dat can be applied with
git\-apply\&.
.RE
.PP
\-\-abbrev[=<n>]
.RS 4
Instead of showin tha full 40\-byte hexadecimal object name up in diff\-raw format output n' diff\-tree header lines, show only a partial prefix\&. This is independent of the
\-\-full\-index
option above, which controls tha diff\-patch output format\&. Non default number of digits can be specified with
\-\-abbrev=<n>\&.
.RE
.PP
\-B[<n>][/<m>], \-\-break\-rewrites[=[<n>][/<m>]]
.RS 4
Break complete rewrite chizzlez tha fuck into pairz of delete n' create\&. This serves two purposes:
.sp
It affects tha way a cold-ass lil chizzle dat amounts ta a total rewrite of a gangbangin' file not as a seriez of deletion n' insertion mixed together wit a straight-up few lines dat happen ta match textually as tha context yo, but as a single deletion of every last muthafuckin thang oldschool followed by a single insertion of every last muthafuckin thang new, n' tha number
m
controls dis aspect of tha \-B option (defaults ta 60%)\&.
\-B/70%
specifies dat less than 30% of tha original gangsta should remain up in tha result fo' Git ta consider it a total rewrite (i\&.e\&. otherwise tha resultin patch is ghon be a seriez of deletion n' insertion mixed together wit context lines)\&.
.sp
When used wit \-M, a straight-up\-rewritten file be also considered as tha source of a rename (usually \-M only considaz a gangbangin' file dat disappeared as tha source of a rename), n' tha number
n
controls dis aspect of tha \-B option (defaults ta 50%)\&.
\-B20%
specifies dat a cold-ass lil chizzle wit addizzle n' deletion compared ta 20% or mo' of tha file\(cqs size is eligible fo' bein picked up as a possible source of a rename ta another file\&.
.RE
.PP
\-M[<n>], \-\-find\-renames[=<n>]
.RS 4
Detect renames\&. If
n
is specified, it aint nuthin but a threshold on tha similaritizzle index (i\&.e\&. amount of addition/deletions compared ta tha file\(cqs size)\&. For example,
\-M90%
means Git should consider a thugged-out delete/add pair ta be a rename if mo' than 90% of tha file hasn\(cqt chizzled\&. Without a
%
sign, tha number is ta be read as a gangbangin' fraction, wit a thugged-out decimal point before it\&. I\&.e\&.,
\-M5
becomes 0\&.5, n' is thus tha same ol' dirty as
\-M50%\&. Right back up in yo muthafuckin ass. Similarly,
\-M05
is tha same ol' dirty as
\-M5%\&. To limit detection ta exact renames, use
\-M100%\&. Da default similaritizzle index is 50%\&.
.RE
.PP
\-C[<n>], \-\-find\-copies[=<n>]
.RS 4
Detect copies as well as renames\&. Right back up in yo muthafuckin ass. See also
\-\-find\-copies\-harder\&. If
n
is specified, it has tha same ol' dirty meanin as for
\-M<n>\&.
.RE
.PP
\-\-find\-copies\-harder
.RS 4
For performizzle reasons, by default,
\-C
option findz copies only if tha original gangsta file of tha copy was modified up in tha same chizzleset\&. This flag make tha command inspect unmodified filez as muthafuckas fo' tha source of copy\&. This be a straight-up high-rollin' operation fo' big-ass projects, so use it wit caution\&. Givin mo' than one
\-C
option has tha same ol' dirty effect\&.
.RE
.PP
\-D, \-\-irreversible\-delete
.RS 4
Omit tha preimage fo' deletes, i\&.e\&. print only tha header but not tha diff between tha preimage and
/dev/null\&. Da resultin patch aint meant ta be applied with
patch
or
git apply; dis is solely fo' playas whoz ass wanna just concentrate on reviewin tha text afta tha chizzle\&. In addition, tha output obviously lack enough shiznit ta apply such a patch up in reverse, even manually, hence tha name of tha option\&.
.sp
When used together with
\-B, omit also tha preimage up in tha deletion part of a thugged-out delete/create pair\&.
.RE
.PP
\-l<num>
.RS 4
The
\-M
and
\-C
options require O(n^2) processin time where n is tha number of potential rename/copy targets\&. This option prevents rename/copy detection from hustlin if tha number of rename/copy targets exceedz tha specified number\&.
.RE
.PP
\-\-diff\-filter=[(A|C|D|M|R|T|U|X|B)\&...[*]]
.RS 4
Select only filez dat is Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have they type (i\&.e\&. regular file, symlink, submodule, \&...) chizzled (T), is Unmerged (U), is Unknown (X), or have had they pairin Broken (B)\& fo' realz. Any combination of tha filta charactas (includin none) can be used\&. When
*
(All\-or\-none) be added ta tha combination, all paths is selected if there be any file dat matches other criteria up in tha comparison; if there is no file dat matches other criteria, not a god damn thang is selected\&.
.RE
.PP
\-S<string>
.RS 4
Look fo' differences dat chizzle tha number of occurrencez of tha specified strang (i\&.e\&. addition/deletion) up in a gangbangin' file\&. Intended fo' tha scripter\(cqs use\&.
.sp
It be useful when you\(cqre lookin fo' a exact block of code (like a struct), n' wanna know tha history of dat block since it first came tha fuck into being: use tha feature iteratively ta feed tha bangin-ass block up in tha preimage back into
\-S, n' keep goin until you git tha straight-up first version of tha block\&.
.RE
.PP
\-G<regex>
.RS 4
Look fo' differences whose patch text gotz nuff added/removed lines dat match <regex>\&.
.sp
To illustrate tha difference between
\-S<regex> \-\-pickaxe\-regex
and
\-G<regex>, consider a cold-ass lil commit wit tha followin diff up in tha same file:
.sp
.if n \{\
.RS 4
.\}
.nf
+    return !regexec(regexp, two\->ptr, 1, &regmatch, 0);
\&.\&.\&.
\-    hit = !regexec(regexp, mf2\&.ptr, 1, &regmatch, 0);
.fi
.if n \{\
.RE
.\}
.sp
While
git log \-G"regexec\e(regexp"
will show dis commit,
git log \-S"regexec\e(regexp" \-\-pickaxe\-regex
will not (because tha number of occurrencez of dat strang did not chizzle)\&.
.sp
See the
\fIpickaxe\fR
entry in
\fBgitdiffcore\fR(7)
for mo' shiznit\&.
.RE
.PP
\-\-pickaxe\-all
.RS 4
When
\-S
or
\-G
findz a cold-ass lil chizzle, show all tha chizzlez up in dat chizzleset, not just tha filez dat contain tha chizzle up in <string>\&.
.RE
.PP
\-\-pickaxe\-regex
.RS 4
Treat tha <string> given to
\-S
as a extended POSIX regular expression ta match\&.
.RE
.PP
\-O<orderfile>
.RS 4
Output tha patch up in tha order specified up in tha <orderfile>, which has one shell glob pattern per line\&. This overrides the
diff\&.orderfile
configuration variable (see
\fBgit-config\fR(1))\&. To cancel
diff\&.orderfile, use
\-O/dev/null\&.
.RE
.PP
\-R
.RS 4
Swap two inputs; dat is, show differences from index or on\-disk file ta tree contents\&.
.RE
.PP
\-\-relative[=<path>]
.RS 4
When run from a subdirectory of tha project, it can be holla'd at ta exclude chizzlez outside tha directory n' show pathnames relatizzle ta it wit dis option\&. When yo ass is not up in a subdirectory (e\&.g\&. up in a funky-ass bare repository), you can name which subdirectory ta make tha output relatizzle ta by givin a <path> as a argument\&.
.RE
.PP
\-a, \-\-text
.RS 4
Treat all filez as text\&.
.RE
.PP
\-\-ignore\-space\-at\-eol
.RS 4
Ignore chizzlez up in whitespace at EOL\&.
.RE
.PP
\-b, \-\-ignore\-space\-change
.RS 4
Ignore chizzlez up in amount of whitespace\&. This ignores whitespace at line end, n' considaz all other sequencez of one or mo' whitespace charactas ta be equivalent\&.
.RE
.PP
\-w, \-\-ignore\-all\-space
.RS 4
Ignore whitespace when comparin lines\&. This ignores differences even if one line has whitespace where tha other line has none\&.
.RE
.PP
\-\-ignore\-blank\-lines
.RS 4
Ignore chizzlez whose lines is all blank\&.
.RE
.PP
\-\-inter\-hunk\-context=<lines>
.RS 4
Show tha context between diff hunks, up ta tha specified number of lines, thereby fusin hunks dat is close ta each other\&.
.RE
.PP
\-W, \-\-function\-context
.RS 4
Show whole surroundin functionz of chizzles\&.
.RE
.PP
\-\-exit\-code
.RS 4
Make tha program exit wit codes similar ta diff(1)\&. That is, it exits wit 1 if there was differences n' 0 means no differences\&.
.RE
.PP
\-\-quiet
.RS 4
Disable all output of tha program\&. Implies
\-\-exit\-code\&.
.RE
.PP
\-\-ext\-diff
.RS 4
Allow a external diff helper ta be executed\&. If you set a external diff driver with
\fBgitattributes\fR(5), you need ta use dis option with
\fBgit-log\fR(1)
and playas\&.
.RE
.PP
\-\-no\-ext\-diff
.RS 4
Disallow external diff drivers\&.
.RE
.PP
\-\-textconv, \-\-no\-textconv
.RS 4
Allow (or disallow) external text conversion filtas ta be run when comparin binary files\&. Right back up in yo muthafuckin ass. See
\fBgitattributes\fR(5)
for details\&. Because textconv filtas is typically a one\-way conversion, tha resultin diff is suitable fo' human consumption yo, but cannot be applied\&. For dis reason, textconv filtas is enabled by default only for
\fBgit-diff\fR(1)
and
\fBgit-log\fR(1) yo, but not for
\fBgit-format-patch\fR(1)
or diff plumbin commands\&.
.RE
.PP
\-\-ignore\-submodules[=<when>]
.RS 4
Ignore chizzlez ta submodulez up in tha diff generation\&. <when> can be either "none", "untracked", "dirty" or "all", which is tha default\&. Usin "none" will consider tha submodule modified when it either gotz nuff untracked or modified filez or its HEAD differs from tha commit recorded up in tha superproject n' can be used ta override any settingz of the
\fIignore\fR
option in
\fBgit-config\fR(1)
or
\fBgitmodules\fR(5)\&. When "untracked" is used submodulez is not considered dirty when they only contain untracked content (but they is still scanned fo' modified content)\&. Usin "dirty" ignores all chizzlez ta tha work tree of submodules, only chizzlez ta tha commits stored up in tha superproject is shown (this was tha behavior until 1\&.7\&.0)\&. Usin "all" hides all chizzlez ta submodules\&.
.RE
.PP
\-\-src\-prefix=<prefix>
.RS 4
Show tha given source prefix instead of "a/"\&.
.RE
.PP
\-\-dst\-prefix=<prefix>
.RS 4
Show tha given destination prefix instead of "b/"\&.
.RE
.PP
\-\-no\-prefix
.RS 4
Do not show any source or destination prefix\&.
.RE
.sp
For mo' detailed explanation on these common options, peep also \fBgitdiffcore\fR(7)\&.
.PP
<tree\-ish>
.RS 4
Da id of a tree object\&.
.RE
.PP
<path>\&...
.RS 4
If provided, tha thangs up in dis biatch is limited ta a subset of filez matchin one of these prefix strings\&. i\&.e\&., file matches
/^<pattern1>|<pattern2>|\&.\&.\&./
Note dat dis parameta do not provide any wildcard or regexp features\&.
.RE
.PP
\-r
.RS 4
recurse tha fuck into sub\-trees
.RE
.PP
\-t
.RS 4
show tree entry itself as well as subtrees\&. Implies \-r\&.
.RE
.PP
\-\-root
.RS 4
When
\fI\-\-root\fR
is specified tha initial commit is ghon be shown as a funky-ass big-ass creation event\&. This is equivalent ta a gangbangin' finger-lickin' diff against tha NULL tree\&.
.RE
.PP
\-\-stdin
.RS 4
When
\fI\-\-stdin\fR
is specified, tha command do not take <tree\-ish> arguments from tha command line\&. Instead, it readz lines containin either two <tree>, one <commit>, or a list of <commit> from its standard input\&. (Use a single space as separator\&.)
.sp
When two trees is given, it compares tha straight-up original gangsta tree wit tha second\&. When a single commit is given, it compares tha commit wit its muthafathas\&. Da remainin commits, when given, is used as if they is muthafathaz of tha straight-up original gangsta commit\&.
.sp
When comparin two trees, tha ID of both trees (separated by a space n' terminated by a newline) is printed before tha difference\&. When comparin commits, tha ID of tha straight-up original gangsta (or only) commit, followed by a newline, is printed\&.
.sp
Da followin flags further affect tha behavior when comparin commits (but not trees)\&.
.RE
.PP
\-m
.RS 4
By default,
\fIgit diff\-tree \-\-stdin\fR
does not show differences fo' merge commits\&. With dis flag, it shows differences ta dat commit from all of its muthafathas\&. Right back up in yo muthafuckin ass. See also
\fI\-c\fR\&.
.RE
.PP
\-s
.RS 4
By default,
\fIgit diff\-tree \-\-stdin\fR
shows differences, either up in machine\-readable form (without
\fI\-p\fR) or up in patch form (with
\fI\-p\fR)\&. This output can be suppressed\&. Well shiiiit, it is only useful with
\fI\-v\fR
flag\&.
.RE
.PP
\-v
.RS 4
This flag causes
\fIgit diff\-tree \-\-stdin\fR
to also show tha commit message before tha differences\&.
.RE
.PP
\-\-pretty[=<format>], \-\-format=<format>
.RS 4
Pretty\-print tha contentz of tha commit logs up in a given format, where
\fI<format>\fR
can be one of
\fIoneline\fR,
\fIshort\fR,
\fImedium\fR,
\fIfull\fR,
\fIfuller\fR,
\fIemail\fR,
\fIraw\fR
and
\fIformat:<string>\fR\&. Right back up in yo muthafuckin ass. See tha "PRETTY FORMATS" section fo' some additionizzle details fo' each format\&. When omitted, tha format defaults to
\fImedium\fR\&.
.sp
Note: you can specify tha default pretty format up in tha repository configuration (see
\fBgit-config\fR(1))\&.
.RE
.PP
\-\-abbrev\-commit
.RS 4
Instead of showin tha full 40\-byte hexadecimal commit object name, show only a partial prefix\&. Non default number of digits can be specified wit "\-\-abbrev=<n>" (which also modifies diff output, if it is displayed)\&.
.sp
This should make "\-\-pretty=oneline" a whole lot mo' readable fo' playas rockin 80\-column terminals\&.
.RE
.PP
\-\-no\-abbrev\-commit
.RS 4
Show tha full 40\-byte hexadecimal commit object name\&. This negates
\-\-abbrev\-commit
and dem options which imply it like fuckin "\-\-oneline"\&. Well shiiiit, it also overrides the
\fIlog\&.abbrevCommit\fR
variable\&.
.RE
.PP
\-\-oneline
.RS 4
This be a gangbangin' finger-lickin' dirty-ass shorthand fo' "\-\-pretty=oneline \-\-abbrev\-commit" used together\&.
.RE
.PP
\-\-encoding=<encoding>
.RS 4
Da commit objects record tha encodin used fo' tha log message up in they encodin header; dis option can be used ta tell tha command ta re\-code tha commit log message up in tha encodin preferred by tha user\&. For non plumbin commandz dis defaults ta UTF\-8\&.
.RE
.PP
\-\-notes[=<ref>]
.RS 4
Show tha notes (see
\fBgit-notes\fR(1)) dat annotate tha commit, when showin tha commit log message\&. This is tha default for
git log,
git show
and
git whatchanged
commandz when there is no
\-\-pretty,
\-\-format, or
\-\-oneline
option given on tha command line\&.
.sp
By default, tha notes shown is from tha notes refs listed up in the
\fIcore\&.notesRef\fR
and
\fInotes\&.displayRef\fR
variablez (or correspondin environment overrides)\&. Right back up in yo muthafuckin ass. See
\fBgit-config\fR(1)
for mo' details\&.
.sp
With a optional
\fI<ref>\fR
argument, show dis notes ref instead of tha default notes ref(s)\&. Da ref is taken ta be in
refs/notes/
if it aint qualified\&.
.sp
Multiple \-\-notes options can be combined ta control which notes is bein displayed\&. Examples: "\-\-notes=foo" will show only notes from "refs/notes/foo"; "\-\-notes=foo \-\-notes" will show both notes from "refs/notes/foo" n' from tha default notes ref(s)\&.
.RE
.PP
\-\-no\-notes
.RS 4
Do not show notes\&. This negates tha above
\-\-notes
option, by resettin tha list of notes refs from which notes is shown\&. Options is parsed up in tha order given on tha command line, so e\&.g\&. "\-\-notes \-\-notes=foo \-\-no\-notes \-\-notes=bar" will only show notes from "refs/notes/bar"\&.
.RE
.PP
\-\-show\-notes[=<ref>], \-\-[no\-]standard\-notes
.RS 4
These options is deprecated\&. Use tha above \-\-notes/\-\-no\-notes options instead\&.
.RE
.PP
\-\-show\-signature
.RS 4
Peep tha validitizzle of a signed commit object by passin tha signature to
gpg \-\-verify
and show tha output\&.
.RE
.PP
\-\-no\-commit\-id
.RS 4
\fIgit diff\-tree\fR
outputs a line wit tha commit ID when applicable\&. This flag suppressed tha commit ID output\&.
.RE
.PP
\-c
.RS 4
This flag chizzlez tha way a merge commit is displayed (which means it is useful only when tha command is given one <tree\-ish>, or
\fI\-\-stdin\fR)\&. Well shiiiit, it shows tha differences from each of tha muthafathas ta tha merge result simultaneously instead of showin pairwise diff between a parent n' tha result one at a time (which is what tha fuck the
\fI\-m\fR
option do)\&. Furthermore, it lists only filez which was modified from all muthafathas\&.
.RE
.PP
\-\-cc
.RS 4
This flag chizzlez tha way a merge commit patch is displayed, up in a similar way ta the
\fI\-c\fR
option\&. Well shiiiit, it implies the
\fI\-c\fR
and
\fI\-p\fR
options n' further compresses tha patch output by omittin uninterestin hunks whose tha contents up in tha muthafathas have only two variants n' tha merge result picks one of dem without modification\&. When all hunks is uninteresting, tha commit itself n' tha commit log message aint shown, just like up in any other "empty diff" case\&.
.RE
.PP
\-\-always
.RS 4
Show tha commit itself n' tha commit log message even if tha diff itself is empty\&.
.RE
.SH "PRETTY FORMATS"
.sp
If tha commit be a merge, n' if tha pretty\-format aint \fIoneline\fR, \fIemail\fR or \fIraw\fR, a additionizzle line is banged before tha \fIAuthor:\fR line\&. This line begins wit "Merge: " n' tha sha1z of ancestral commits is printed, separated by spaces\&. Note dat tha listed commits may not necessarily be tha list of tha \fBdirect\fR parent commits if you have limited yo' view of history: fo' example, if yo ass is only horny bout chizzlez related ta a cold-ass lil certain directory or file\&.
.sp
There is nuff muthafuckin built\-in formats, n' you can define additionizzle formats by settin a pretty\&.<name> config option ta either another format name, or a \fIformat:\fR string, as busted lyrics bout below (see \fBgit-config\fR(1))\& yo. Here is tha detailz of tha built\-in formats:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIoneline\fR
.sp
.if n \{\
.RS 4
.\}
.nf
<sha1> <title line>
.fi
.if n \{\
.RE
.\}
.sp
This is designed ta be as compact as possible\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIshort\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fImedium\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
Date:   <lyricist date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIfull\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
Commit: <committer>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIfuller\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author:     <author>
AuthorDate: <lyricist date>
Commit:     <committer>
CommitDate: <committa date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIemail\fR
.sp
.if n \{\
.RS 4
.\}
.nf
From <sha1> <date>
From: <author>
Date: <lyricist date>
Subject: [PATCH] <title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIraw\fR
.sp
The
\fIraw\fR
format shows tha entire commit exactly as stored up in tha commit object\&. Notably, tha SHA\-1s is displayed up in full, regardless of whether \-\-abbrev or \-\-no\-abbrev is used, and
\fIparents\fR
information show tha legit parent commits, without takin grafts or history simplification tha fuck into account\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIformat:<string>\fR
.sp
The
\fIformat:<string>\fR
format allows you ta specify which shiznit you wanna show\&. Well shiiiit, it works a lil bit like printf format, wit tha notable exception dat you git a newline with
\fI%n\fR
instead of
\fI\en\fR\&.
.sp
E\&.g,
\fIformat:"Da lyricist of %h was %an, %ar%nDa title was >>%s<<%n"\fR
would show suttin' like this:
.sp
.if n \{\
.RS 4
.\}
.nf
Da lyricist of fe6e0ee was Junio C Hamano, 23 minutes ago
Da title was >>t4119: test autocomputin \-p<n> fo' traditionizzle diff input\&.<<
.fi
.if n \{\
.RE
.\}
.sp
Da placeholdaz are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%H\fR: commit hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%h\fR: abbreviated commit hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%T\fR: tree hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%t\fR: abbreviated tree hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%P\fR: parent hashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%p\fR: abbreviated parent hashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%an\fR: lyricist name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aN\fR: lyricist name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ae\fR: lyricist email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aE\fR: lyricist email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ad\fR: lyricist date (format respects \-\-date= option)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aD\fR: lyricist date, RFC2822 style
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ar\fR: lyricist date, relative
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%at\fR: lyricist date, UNIX timestamp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ai\fR: lyricist date, ISO 8601 format
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cn\fR: committa name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cN\fR: committa name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ce\fR: committa email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cE\fR: committa email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cd\fR: committa date
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cD\fR: committa date, RFC2822 style
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cr\fR: committa date, relative
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ct\fR: committa date, UNIX timestamp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ci\fR: committa date, ISO 8601 format
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%d\fR: ref names, like tha \-\-decorate option of
\fBgit-log\fR(1)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%e\fR: encoding
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%s\fR: subject
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%f\fR: sanitized subject line, suitable fo' a gangbangin' filename
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%b\fR: body
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%B\fR: raw body (unwrapped subject n' body)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%N\fR: commit notes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GG\fR: raw verification message from GPG fo' a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%G?\fR: show "G" fo' a Dope signature, "B" fo' a Wack signature, "U" fo' a good, untrusted signature n' "N" fo' no signature
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GS\fR: show tha name of tha signer fo' a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GK\fR: show tha key used ta sign a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gD\fR: reflog selector, e\&.g\&.,
refs/stash@{1}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gd\fR: shortened reflog selector, e\&.g\&.,
stash@{1}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gn\fR: reflog identitizzle name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gN\fR: reflog identitizzle name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ge\fR: reflog identitizzle email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gE\fR: reflog identitizzle email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gs\fR: reflog subject
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cred\fR: switch color ta red
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cgreen\fR: switch color ta green
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cblue\fR: switch color ta blue
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Creset\fR: reset color
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%C(\&...)\fR: color justification, as busted lyrics bout up in color\&.branch\&.* config option; adding
auto,
at tha beginnin will emit color only when flavas is enabled fo' log output (by
color\&.diff,
color\&.ui, or
\-\-color, n' respectin the
auto
settingz of tha forma if we is goin ta a terminal)\&.
auto
alone (i\&.e\&.
%C(auto)) will turn on auto colorin on tha next placeholdaz until tha color is switched again\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%m\fR: left, right or boundary mark
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%n\fR: newline
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%%\fR: a raw
\fI%\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%x00\fR: print a funky-ass byte from a hex code
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%w([<w>[,<i1>[,<i2>]]])\fR: switch line wrapping, like tha \-w option of
\fBgit-shortlog\fR(1)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%<(<N>[,trunc|ltrunc|mtrunc])\fR: make tha next placeholda take at least N columns, paddin spaces on tha right if necessary\&. Optionally truncate all up in tha beginnin (ltrunc), tha middle (mtrunc) or tha end (trunc) if tha output is longer than N columns\&. Note dat truncatin only works erectly wit N >= 2\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%<|(<N>)\fR: make tha next placeholda take at least until Nth columns, paddin spaces on tha right if necessary
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%>(<N>)\fR,
\fI%>|(<N>)\fR: similar to
\fI%<(<N>)\fR,
\fI%<|(<N>)\fR
respectively yo, but paddin spaces on tha left
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%>>(<N>)\fR,
\fI%>>|(<N>)\fR: similar to
\fI%>(<N>)\fR,
\fI%>|(<N>)\fR
respectively, except dat if tha next placeholda takes mo' spaces than given n' there be spaces on its left, use dem spaces
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%><(<N>)\fR,
\fI%><|(<N>)\fR: similar to
\fI% <(<N>)\fR,
\fI%<|(<N>)\fR
respectively yo, but paddin both sides (i\&.e\&. tha text is centered)
.RE
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Some placeholdaz may depend on other options given ta tha revision traversal engine\&. For example, tha %g* reflog options will bang a empty strang unless we is traversin reflog entries (e\&.g\&., by git log \-g)\&. Da %d placeholda will use tha "short" decoration format if \-\-decorate was not already provided on tha command line\&.
.sp .5v
.RE
.sp
If you add a + (plus sign) afta \fI%\fR of a placeholder, a line\-feed is banged immediately before tha expansion if n' only if tha placeholda expandz ta a non\-empty string\&.
.sp
If you add a \- (minus sign) afta \fI%\fR of a placeholder, line\-feedz dat immediately precede tha expansion is deleted if n' only if tha placeholda expandz ta a empty string\&.
.sp
If you add a ` ` (space) afta \fI%\fR of a placeholder, a space is banged immediately before tha expansion if n' only if tha placeholda expandz ta a non\-empty string\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fItformat:\fR
.sp
The
\fItformat:\fR
format works exactly like
\fIformat:\fR, except dat it serves up "terminator" semantics instead of "separator" semantics\&. In other lyrics, each commit has tha message terminator characta (usually a newline) appended, rather than a separator placed between entries\&. This means dat tha final entry of a single\-line format is ghon be properly terminated wit a freshly smoked up line, just as tha "oneline" format do\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=format:%h 4da45bef \e
  | perl \-pe \(aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\(aq
4da45be
7134973 \-\- NO NEWLINE

$ git log \-2 \-\-pretty=tformat:%h 4da45bef \e
  | perl \-pe \(aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\(aq
4da45be
7134973
.fi
.if n \{\
.RE
.\}
.sp
In addition, any unrecognized strang dat has a
%
in it is interpreted as if it has
tformat:
in front of it\&. For example, these two is equivalent:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=tformat:%h 4da45bef
$ git log \-2 \-\-pretty=%h 4da45bef
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "LIMITING OUTPUT"
.sp
If you\(cqre only horny bout differences up in a subset of files, fo' example some architecture\-specific files, you might do:
.sp
.if n \{\
.RS 4
.\}
.nf
git diff\-tree \-r <tree\-ish> <tree\-ish> arch/ia64 include/asm\-ia64
.fi
.if n \{\
.RE
.\}
.sp
and it will only show you what tha fuck chizzled up in dem two directories\&.
.sp
Or if yo ass is searchin fo' what tha fuck chizzled up in just kernel/sched\&.c, just do
.sp
.if n \{\
.RS 4
.\}
.nf
git diff\-tree \-r <tree\-ish> <tree\-ish> kernel/sched\&.c
.fi
.if n \{\
.RE
.\}
.sp
and it will ignore all differences ta other files\&.
.sp
Da pattern be always tha prefix, n' is matched exactly\&. There is no wildcards\&. Even stricter, it has ta match a cold-ass lil complete path component\&. I\&.e\&. "foo" do not pick up foobar\&.h\&. "foo" do match foo/bar\&.h so it can be used ta name subdirectories\&.
.sp
An example of aiiight usage is:
.sp
.if n \{\
.RS 4
.\}
.nf
torvalds@ppc970:~/git> git diff\-tree \-\-abbrev 5319e4
:100664 100664 ac348b\&.\&.\&. a01513\&.\&.\&.    git\-fsck\-objects\&.c
.fi
.if n \{\
.RE
.\}
.sp
which  drops some lyrics ta you dat tha last commit chizzled just one file (it\(cqs from dis one:
.sp
.if n \{\
.RS 4
.\}
.nf
commit 3c6f7ca19ad4043e9e72fa94106f352897e651a8
tree 5319e4d609cdd282069cc4dce33c1db559539b03
parent b4e628ea30d5ab3606119d2ea5caeab141d38df7
lyricist Linus Torvaldz <torvalds@ppc970\&.osdl\&.org> Sat Apr 9 12:02:30 2005
committa Linus Torvaldz <torvalds@ppc970\&.osdl\&.org> Sat Apr 9 12:02:30 2005

Make "git\-fsck\-objects" print up all tha root commits it finds\&.

Once I do tha reference tracking, I\(aqll also make it print up all the
HEAD commits it finds, which is even mo' interesting\&.
.fi
.if n \{\
.RE
.\}
.sp
.sp
in case you care)\&.
.SH "RAW OUTPUT FORMAT"
.sp
Da raw output format from "git\-diff\-index", "git\-diff\-tree", "git\-diff\-files" n' "git diff \-\-raw" is straight-up similar\&.
.sp
These commandz all compare two setz of thangs; what tha fuck is compared differs:
.PP
git\-diff\-index <tree\-ish>
.RS 4
compares tha <tree\-ish> n' tha filez on tha filesystem\&.
.RE
.PP
git\-diff\-index \-\-cached <tree\-ish>
.RS 4
compares tha <tree\-ish> n' tha index\&.
.RE
.PP
git\-diff\-tree [\-r] <tree\-ish\-1> <tree\-ish\-2> [<pattern>\&...]
.RS 4
compares tha trees named by tha two arguments\&.
.RE
.PP
git\-diff\-filez [<pattern>\&...]
.RS 4
compares tha index n' tha filez on tha filesystem\&.
.RE
.sp
Da "git\-diff\-tree" command begins its output by printin tha hash of what tha fuck is bein compared\& fo' realz. Afta that, all tha commandz print one output line per chizzled file\&.
.sp
An output line is formatted dis way:
.sp
.if n \{\
.RS 4
.\}
.nf
in\-place edit  :100644 100644 bcd1234\&.\&.\&. 0123456\&.\&.\&. M file0
copy\-edit      :100644 100644 abcd123\&.\&.\&. 1234567\&.\&.\&. C68 file1 file2
rename\-edit    :100644 100644 abcd123\&.\&.\&. 1234567\&.\&.\&. R86 file1 file3
create         :000000 100644 0000000\&.\&.\&. 1234567\&.\&.\& fo' realz. A file4
delete         :100644 000000 1234567\&.\&.\&. 0000000\&.\&.\&. D file5
unmerged       :000000 000000 0000000\&.\&.\&. 0000000\&.\&.\&. U file6
.fi
.if n \{\
.RE
.\}
.sp
.sp
That is, from tha left ta tha right:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
a colon\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
mode fo' "src"; 000000 if creation or unmerged\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
a space\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
mode fo' "dst"; 000000 if deletion or unmerged\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
a space\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
sha1 fo' "src"; 0{40} if creation or unmerged\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
a space\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
sha1 fo' "dst"; 0{40} if creation, unmerged or "peep work tree"\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
a space\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
status, followed by optionizzle "score" number\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
a tab or a NUL when
\fI\-z\fR
option is used\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
path fo' "src"
.RE
.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
a tab or a NUL when
\fI\-z\fR
option is used; only exists fo' C or R\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
path fo' "dst"; only exists fo' C or R\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
an LF or a NUL when
\fI\-z\fR
option is used, ta terminizzle tha record\&.
.RE
.sp
Possible status lettas are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A: addizzle of a gangbangin' file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C: copy of a gangbangin' file tha fuck into a freshly smoked up one
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D: deletion of a gangbangin' file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
M: modification of tha contents or mode of a gangbangin' file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
R: renamin of a gangbangin' file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T: chizzle up in tha type of tha file
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
U: file is unmerged (you must complete tha merge before it can be committed)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
X: "unknown" chizzle type (most probably a funky-ass bug, please report it)
.RE
.sp
Status lettas C n' R is always followed by a score (denotin tha cementage of similaritizzle between tha source n' target of tha move or copy), n' is tha only ones ta be so\&.
.sp
<sha1> is shown as all 0\(cqs if a gangbangin' file is freshly smoked up on tha filesystem n' it is outta sync wit tha index\&.
.sp
Example:
.sp
.if n \{\
.RS 4
.\}
.nf
:100644 100644 5be4a4\&.\&.\&.\&.\&.\&. 000000\&.\&.\&.\&.\&.\&. M file\&.c
.fi
.if n \{\
.RE
.\}
.sp
.sp
When \-z option aint used, TAB, LF, n' backslash charactas up in pathnames is represented as \et, \en, n' \e\e, respectively\&.
.SH "DIFF FORMAT FOR MERGES"
.sp
"git\-diff\-tree", "git\-diff\-files" n' "git\-diff \-\-raw" can take \fI\-c\fR or \fI\-\-cc\fR option ta generate diff output also fo' merge commits\&. Da output differs from tha format busted lyrics bout above up in tha followin way:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
there be a cold-ass lil colon fo' each parent
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
there is mo' "src" modes n' "src" sha1
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
status is concatenated status charactas fo' each parent
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
no optionizzle "score" number
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
single path, only fo' "dst"
.RE
.sp
Example:
.sp
.if n \{\
.RS 4
.\}
.nf
::100644 100644 100644 fabadb8\&.\&.\&. cc95eb0\&.\&.\&. 4866510\&.\&.\&. MM      describe\&.c
.fi
.if n \{\
.RE
.\}
.sp
.sp
Note dat \fIcombined diff\fR lists only filez which was modified from all muthafathas\&.
.SH "GENERATING PATCHES WITH -P"
.sp
When "git\-diff\-index", "git\-diff\-tree", or "git\-diff\-files" is run wit a \fI\-p\fR option, "git diff" without tha \fI\-\-raw\fR option, or "git log" wit tha "\-p" option, they do not produce tha output busted lyrics bout above; instead they produce a patch file\&. Yo ass can customize tha creation of such patches via tha GIT_EXTERNAL_DIFF n' tha GIT_DIFF_OPTS environment variables\&.
.sp
What tha \-p option produces is slightly different from tha traditionizzle diff format:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
It be preceded wit a "git diff" header dat be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-git a/file1 b/file2
.fi
.if n \{\
.RE
.\}
.sp
The
a/
and
b/
filenames is tha same unless rename/copy is involved\&. Especially, even fo' a cold-ass lil creation or a thugged-out deletion,
/dev/null
is
\fInot\fR
used up in place of the
a/
or
b/
filenames\&.
.sp
When rename/copy is involved,
file1
and
file2
show tha name of tha source file of tha rename/copy n' tha name of tha file dat rename/copy produces, respectively\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
It be followed by one or mo' extended header lines:
.sp
.if n \{\
.RS 4
.\}
.nf
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy ta <path>
rename from <path>
rename ta <path>
similaritizzle index <number>
dissimilaritizzle index <number>
index <hash>\&.\&.<hash> <mode>
.fi
.if n \{\
.RE
.\}
.sp
File modes is printed as 6\-digit octal numbers includin tha file type n' file permission bits\&.
.sp
Path names up in extended headaz do not include the
a/
and
b/
prefixes\&.
.sp
Da similaritizzle index is tha cementage of unchanged lines, n' tha dissimilaritizzle index is tha cementage of chizzled lines\&. Well shiiiit, it aint nuthin but a rounded down integer, followed by a cement sign\&. Da similaritizzle index value of 100% is thus reserved fo' two equal files, while 100% dissimilaritizzle means dat no line from tha oldschool file juiced it up tha fuck into tha freshly smoked up one\&.
.sp
Da index line includes tha SHA\-1 checksum before n' afta tha chizzle\&. Da <mode> is included if tha file mode do not chizzle; otherwise, separate lines indicate tha oldschool n' tha freshly smoked up mode\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
TAB, LF, double quote n' backslash charactas up in pathnames is represented as
\et,
\en,
\e"
and
\e\e, respectively\&. If there is need fo' such substitution then tha whole pathname is put up in double quotes\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
All the
file1
filez up in tha output refer ta filez before tha commit, n' all the
file2
filez refer ta filez afta tha commit\&. Well shiiiit, it is incorrect ta apply each chizzle ta each file sequentially\&. For example, dis patch will swap a n' b:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-git a/a b/b
rename from a
rename ta b
diff \-\-git a/b b/a
rename from b
rename ta a
.fi
.if n \{\
.RE
.\}
.RE
.SH "COMBINED DIFF FORMAT"
.sp
Any diff\-generatin command can take tha \(oq\-c` or \-\-cc option ta produce a \fIcombined diff\fR when showin a merge\&. This is tha default format when showin merges wit \fBgit-diff\fR(1) or \fBgit-show\fR(1)\&. Note also dat you can give tha `\-m\(cq option ta any of these commandz ta force generation of diffs wit individual muthafathaz of a merge\&.
.sp
A \fIcombined diff\fR format be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-combined describe\&.c
index fabadb8,cc95eb0\&.\&.4866510
\-\-\- a/describe\&.c
+++ b/describe\&.c
@@@ \-98,20 \-98,12 +98,20 @@@
        return (a_date > b_date) ? \-1 : (a_date == b_date) ? 0 : 1;
  }

\- static void describe(char *arg)
 \-static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) {
                initialized = 1;
                for_each_ref(get_name);
.fi
.if n \{\
.RE
.\}
.sp

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
It be preceded wit a "git diff" header, dat be lookin like dis (when
\fI\-c\fR
option is used):
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-combined file
.fi
.if n \{\
.RE
.\}
.sp
or like dis (when
\fI\-\-cc\fR
option is used):
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-cc file
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
It be followed by one or mo' extended header lines (this example shows a merge wit two muthafathas):
.sp
.if n \{\
.RS 4
.\}
.nf
index <hash>,<hash>\&.\&.<hash>
mode <mode>,<mode>\&.\&.<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
.fi
.if n \{\
.RE
.\}
.sp
The
mode <mode>,<mode>\&.\&.<mode>
line appears only if at least one of tha <mode> is different from tha rest\&. Extended headaz wit shiznit bout detected contents movement (renames n' copyin detection) is designed ta work wit diff of two <tree\-ish> n' is not used by combined diff format\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
It be followed by two\-line from\-file/to\-file header
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-\- a/file
+++ b/file
.fi
.if n \{\
.RE
.\}
.sp
Similar ta two\-line header fo' traditional
\fIunified\fR
diff format,
/dev/null
is used ta signal pimped or deleted files\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Chunk header format is modified ta prevent playas from accidentally feedin it to
patch \-p1\&. Combined diff format was pimped fo' review of merge commit chizzles, n' was not meant fo' apply\&. Da chizzle is similar ta tha chizzle up in tha extended
\fIindex\fR
header:
.sp
.if n \{\
.RS 4
.\}
.nf
@@@ <from\-file\-range> <from\-file\-range> <to\-file\-range> @@@
.fi
.if n \{\
.RE
.\}
.sp
There is (number of muthafathas + 1)
@
charactas up in tha chunk header fo' combined diff format\&.
.RE
.sp
Unlike tha traditionizzle \fIunified\fR diff format, which shows two filez A n' B wit a single column dat has \- (minus \(em appears up in A but removed up in B), + (plus \(em missin up in A but added ta B), or " " (space \(em unchanged) prefix, dis format compares two or mo' filez file1, file2,\&... wit one file X, n' shows how tha fuck X differs from each of fileN\&. One column fo' each of fileN is prepended ta tha output line ta note how tha fuck X\(cqs line is different from it\&.
.sp
A \- characta up in tha column N means dat tha line appears up in fileN but it do not step tha fuck up in tha result\& fo' realz. A + characta up in tha column N means dat tha line appears up in tha result, n' fileN aint gots dat line (in other lyrics, tha line was added, from tha deal wit view of dat parent)\&.
.sp
In tha above example output, tha function signature was chizzled from both filez (hence two \- removals from both file1 n' file2, plus ++ ta mean one line dat was added do not step tha fuck up in either file1 or file2)\& fo' realz. Also eight other lines is tha same from file1 but do not step tha fuck up in file2 (hence prefixed wit +)\&.
.sp
When shown by git diff\-tree \-c, it compares tha muthafathaz of a merge commit wit tha merge result (i\&.e\&. file1\&.\&.fileN is tha muthafathas)\&. When shown by git diff\-filez \-c, it compares tha two unresolved merge muthafathas wit tha hustlin tree file (i\&.e\&. file1 is stage 2 aka "our version", file2 is stage 3 aka "their version")\&.
.SH "OTHER DIFF FORMATS"
.sp
Da \-\-summary option raps bout newly added, deleted, renamed n' copied files\&. Da \-\-stat option addz diffstat(1) graph ta tha output\&. These options can be combined wit other options, like fuckin \-p, n' is meant fo' human consumption\&.
.sp
When showin a cold-ass lil chizzle dat involves a rename or a cold-ass lil copy, \-\-stat output formats tha pathnames compactly by combinin common prefix n' suffix of tha pathnames\&. For example, a cold-ass lil chizzle dat moves arch/i386/Makefile ta arch/x86/Makefile while modifyin 4 lines is ghon be shown like this:
.sp
.if n \{\
.RS 4
.\}
.nf
arch/{i386 => x86}/Makefile    |   4 +\-\-
.fi
.if n \{\
.RE
.\}
.sp
.sp
Da \-\-numstat option gives tha diffstat(1) shiznit but is designed fo' easier machine consumption\& fo' realz. An entry up in \-\-numstat output be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
1       2       README
3       1       arch/{i386 => x86}/Makefile
.fi
.if n \{\
.RE
.\}
.sp
.sp
That is, from left ta right:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
the number of added lines;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
a tab;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
the number of deleted lines;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
a tab;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
pathname (possibly wit rename/copy shiznit);
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
a newline\&.
.RE
.sp
When \-z output option is up in effect, tha output is formatted dis way:
.sp
.if n \{\
.RS 4
.\}
.nf
1       2       README NUL
3       1       NUL arch/i386/Makefile NUL arch/x86/Makefile NUL
.fi
.if n \{\
.RE
.\}
.sp
.sp
That is:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
the number of added lines;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
a tab;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
the number of deleted lines;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
a tab;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
a NUL (only exists if renamed/copied);
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
pathname up in preimage;
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
a NUL (only exists if renamed/copied);
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
pathname up in postimage (only exists if renamed/copied);
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
a NUL\&.
.RE
.sp
Da extra NUL before tha preimage path up in renamed case is ta allow scripts dat read tha output ta tell if tha current record bein read be a single\-path record or a rename/copy record without readin ahead\& fo' realz. Afta readin added n' deleted lines, readin up ta NUL would yield tha pathname yo, but if dat is NUL, tha record will show two paths\&.
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
