.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RSAUTL 1"
.TH RSAUTL 1 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
rsautl \- RSA utility
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBopenssl\fR \fBrsautl\fR
[\fB\-in file\fR]
[\fB\-out file\fR]
[\fB\-inkey file\fR]
[\fB\-pubin\fR]
[\fB\-certin\fR]
[\fB\-sign\fR]
[\fB\-verify\fR]
[\fB\-encrypt\fR]
[\fB\-decrypt\fR]
[\fB\-pkcs\fR]
[\fB\-ssl\fR]
[\fB\-raw\fR]
[\fB\-hexdump\fR]
[\fB\-asn1parse\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fBrsautl\fR command can be used ta sign, verify, encrypt n' decrypt
data rockin tha \s-1RSA\s0 algorithm.
.SH "COMMAND OPTIONS"
.IX Header "COMMAND OPTIONS"
.IP "\fB\-in filename\fR" 4
.IX Item "-in filename"
This specifies tha input filename ta read data from or standard input
if dis option aint specified.
.IP "\fB\-out filename\fR" 4
.IX Item "-out filename"
specifies tha output filename ta write ta or standard output by
default.
.IP "\fB\-inkey file\fR" 4
.IX Item "-inkey file"
the input key file, by default it should be a \s-1RSA\s0 private key.
.IP "\fB\-pubin\fR" 4
.IX Item "-pubin"
the input file be a \s-1RSA\s0 hood key.
.IP "\fB\-certin\fR" 4
.IX Item "-certin"
the input be a cold-ass lil certificate containin a \s-1RSA\s0 hood key.
.IP "\fB\-sign\fR" 4
.IX Item "-sign"
sign tha input data n' output tha signed result. This requires
and \s-1RSA\s0 private key.
.IP "\fB\-verify\fR" 4
.IX Item "-verify"
verify tha input data n' output tha recovered data.
.IP "\fB\-encrypt\fR" 4
.IX Item "-encrypt"
encrypt tha input data rockin a \s-1RSA\s0 hood key.
.IP "\fB\-decrypt\fR" 4
.IX Item "-decrypt"
decrypt tha input data rockin a \s-1RSA\s0 private key.
.IP "\fB\-pkcs, \-oaep, \-ssl, \-raw\fR" 4
.IX Item "-pkcs, -oaep, -ssl, -raw"
the paddin ta use: PKCS#1 v1.5 (the default), PKCS#1 \s-1OAEP,\s0
special paddin used up in \s-1SSL\s0 v2 backwardz compatible handshakes,
or no padding, respectively.
For signatures, only \fB\-pkcs\fR n' \fB\-raw\fR can be used.
.IP "\fB\-hexdump\fR" 4
.IX Item "-hexdump"
hex dump tha output data.
.IP "\fB\-asn1parse\fR" 4
.IX Item "-asn1parse"
asn1parse tha output data, dis is useful when combined wit the
\&\fB\-verify\fR option.
.SH "NOTES"
.IX Header "NOTES"
\&\fBrsautl\fR cuz it uses tha \s-1RSA\s0 algorithm directly can only be
used ta sign or verify lil' small-ass piecez of data.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Sign some data rockin a private key:
.PP
.Vb 1
\& openssl rsautl \-sign \-in file \-inkey key.pem \-out sig
.Ve
.PP
Recover tha signed data
.PP
.Vb 1
\& openssl rsautl \-verify \-in sig \-inkey key.pem
.Ve
.PP
Examine tha raw signed data:
.PP
.Vb 1
\& openssl rsautl \-verify \-in file \-inkey key.pem \-raw \-hexdump
\&
\& 0000 \- 00 01 ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0010 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0020 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0030 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0040 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0050 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0060 \- ff ff ff ff ff ff ff ff\-ff ff ff ff ff ff ff ff   ................
\& 0070 \- ff ff ff ff 00 68 65 6c\-6c 6f 20 77 6f 72 6c 64   .....wassup ghetto
.Ve
.PP
Da PKCS#1 block formattin is evident from all dis bullshit. If dis was done using
encrypt n' decrypt tha block would done been of type 2 (the second byte)
and random paddin data visible instead of tha 0xff bytes.
.PP
It be possible ta analyse tha signature of certificates rockin this
utilitizzle up in conjunction wit \fBasn1parse\fR. Consider tha self signed
example up in certs/pca\-cert.pem . Hustlin \fBasn1parse\fR as bigs up yields:
.PP
.Vb 1
\& openssl asn1parse \-in pca\-cert.pem
\&
\&    0:d=0  hl=4 l= 742 cons: SEQUENCE          
\&    4:d=1  hl=4 l= 591 cons:  SEQUENCE          
\&    8:d=2  hl=2 l=   3 cons:   cont [ 0 ]        
\&   10:d=3  hl=2 l=   1 prim:    INTEGER           :02
\&   13:d=2  hl=2 l=   1 prim:   INTEGER           :00
\&   16:d=2  hl=2 l=  13 cons:   SEQUENCE          
\&   18:d=3  hl=2 l=   9 prim:    OBJECT            :md5WithRSAEncryption
\&   29:d=3  hl=2 l=   0 prim:    NULL              
\&   31:d=2  hl=2 l=  92 cons:   SEQUENCE          
\&   33:d=3  hl=2 l=  11 cons:    SET               
\&   35:d=4  hl=2 l=   9 cons:     SEQUENCE          
\&   37:d=5  hl=2 l=   3 prim:      OBJECT            :countryName
\&   42:d=5  hl=2 l=   2 prim:      PRINTABLESTRING   :AU
\&  ....
\&  599:d=1  hl=2 l=  13 cons:  SEQUENCE          
\&  601:d=2  hl=2 l=   9 prim:   OBJECT            :md5WithRSAEncryption
\&  612:d=2  hl=2 l=   0 prim:   NULL              
\&  614:d=1  hl=3 l= 129 prim:  BIT STRING
.Ve
.PP
Da final \s-1BIT STRING\s0 gotz nuff tha actual signature. Well shiiiit, it can be extracted with:
.PP
.Vb 1
\& openssl asn1parse \-in pca\-cert.pem \-out sig \-noout \-strparse 614
.Ve
.PP
Da certificate hood key can be extracted with:
.PP
.Vb 1
\& openssl x509 \-in test/testx509.pem \-pubkey \-noout >pubkey.pem
.Ve
.PP
Da signature can be analysed with:
.PP
.Vb 1
\& openssl rsautl \-in sig \-verify \-asn1parse \-inkey pubkey.pem \-pubin
\&
\&    0:d=0  hl=2 l=  32 cons: SEQUENCE          
\&    2:d=1  hl=2 l=  12 cons:  SEQUENCE          
\&    4:d=2  hl=2 l=   8 prim:   OBJECT            :md5
\&   14:d=2  hl=2 l=   0 prim:   NULL              
\&   16:d=1  hl=2 l=  16 prim:  OCTET STRING      
\&      0000 \- f3 46 9e aa 1a 4a 73 c9\-37 ea 93 00 48 25 08 b5   .F...Js.7...H%..
.Ve
.PP
This is tha parsed version of a \s-1ASN1\s0 DigestInfo structure. Well shiiiit, it can be peeped that
the digest used was md5. Da actual part of tha certificate dat was signed can
be extracted with:
.PP
.Vb 1
\& openssl asn1parse \-in pca\-cert.pem \-out tbs \-noout \-strparse 4
.Ve
.PP
and its digest computed with:
.PP
.Vb 2
\& openssl md5 \-c tbs
\& MD5(tbs)= f3:46:9e:aa:1a:4a:73:c9:37:ea:93:00:48:25:08:b5
.Ve
.PP
which it can be peeped agrees wit tha recovered value above.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdgst\fR\|(1), \fIrsa\fR\|(1), \fIgenrsa\fR\|(1)
