.TH "ZSHMISC" "1" "October 7, 2014" "zsh 5\&.0\&.7"
.SH "NAME"
zshmisc \- every last muthafuckin thang n' then some
.\" Yodl file: Zsh/grammar.yo
.SH "SIMPLE COMMANDS & PIPELINES"
A \fIsimple command\fP be a sequence of optionizzle parameter
assignments followed by blank\-separated lyrics,
with optionizzle redirections interspersed\&.  For a thugged-out description
of assignment, peep tha beginnin of
\fIzshparam\fP(1)\&.
.PP
Da first word is tha command ta be executed, n' tha remaining
words, if any, is arguments ta tha command\&.
If a cold-ass lil command name is given, tha parameta assignments modify
the environment of tha command when it is executed\&.
Da value of a simple command is its exit status,
or 128 plus tha signal number if terminated by a signal\&.
For example,
.PP
.RS
.nf
\fBecho foo\fP
.fi
.RE
.PP
is a simple command wit arguments\&.
.PP
A \fIpipeline\fP is either a simple command, or a sequence of two or more
simple commandz where each command is separated from tha next by `\fB|\fP\&'
or `\fB|&\fP\&'\&.  Where commandz is separated by `\fB|\fP', tha standard
output of tha straight-up original gangsta command is connected ta the
standard input of tha next\&.  `\fB|&\fP\&' is shorthand fo' `\fB2>&1 |\fP', which
connects both tha standard output n' tha standard error of the
command ta tha standard input of tha next\&.  Da value of a pipeline
is tha value of tha last command, unless tha pipeline is preceded by
`\fB!\fP\&' up in which case tha value is tha logical inverse of tha value of the
last command\&.
For example,
.PP
.RS
.nf
\fBecho foo | sed \&'s/foo/bar/'\fP
.fi
.RE
.PP
is a pipeline, where tha output (`\fBfoo\fP\&' plus a newline) of tha first
command is ghon be passed ta tha input of tha second\&.
.PP
If a pipeline is preceded by `\fBcoproc\fP\&', it is executed as a cold-ass lil coprocess;
a two\-way pipe is established between it n' tha parent shell\&.  The
shell can read from or write ta tha coprocess by meanz of tha `\fB>&p\fP\&'
and `\fB<&p\fP\&' redirection operators or wit `\fBprint \-p\fP' n' `\fBread \-p\fP'\&.
A pipeline cannot be preceded by both `\fBcoproc\fP\&' n' `\fB!\fP'\&.
If thang control be active, tha coprocess can be treated up in other than input
and output as a ordinary background thang\&.
.PP
A \fIsublist\fP is either a single pipeline, or a sequence of two or more
pipelines separated by `\fB&&\fP\&' or `\fB||\fP'\&.  If two pipelines is separated
by `\fB&&\fP\&', tha second pipeline is executed only if tha straight-up original gangsta succeeds
(returns a zero status)\&.  If two pipelines is separated by `\fB||\fP\&', the
second is executed only if tha straight-up original gangsta fails (returns a nonzero status)\&.
Both operators have equal precedence n' is left associative\&.
Da value of tha sublist is tha value of tha last pipeline executed\&.
For example,
.PP
.RS
.nf
\fBdmesg | grep panic && print yes\fP
.fi
.RE
.PP
is a sublist consistin of two pipelines, tha second just a simple command
which is ghon be executed if n' only if tha \fBgrep\fP command returns a zero
status\&.  If it do not, tha value of tha sublist is dat return status, else
it is tha status returned by tha \fBprint\fP (almost certainly zero)\&.
.PP
A \fIlist\fP be a sequence of zero or mo' sublists, up in which each sublist
is terminated by `\fB;\fP\&', `\fB&\fP', `\fB&|\fP', `\fB&!\fP', or a newline\&.
This terminator
may optionally be omitted from tha last sublist up in tha list when the
list appears as a cold-ass lil complex command inside `\fB(\fP\&.\&.\&.\fB)\fP\&'
or `\fB{\fP\&.\&.\&.\fB}\fP\&'\&.  When a
sublist is terminated by `\fB;\fP\&' or newline, tha shell waits fo' it to
finish before executin tha next sublist\&.  If a sublist is terminated
by a `\fB&\fP\&', `\fB&|\fP', or `\fB&!\fP',
the shell executes tha last pipeline up in it up in tha background, and
does not wait fo' it ta finish (note tha difference from other shells
which execute tha whole sublist up in tha background)\&.
A backgrounded pipeline returns a statuz of zero\&.
.PP
Mo' generally, a list can be peeped as a set of any shell commands
whatsoever, includin tha complex commandz below; dis is implied wherever
the word `list\&' appears up in lata descriptions\&.  For example, tha commands
in a gangbangin' finger-lickin' dirty-ass shell function form a special sort of list\&.
.SH "PRECOMMAND MODIFIERS"
A simple command may be preceded by a \fIprecommand modifier\fP,
which will alta how tha fuck tha command is interpreted\&.  These modifiers are
shell builtin commandz wit tha exception of \fBnocorrect\fP which is
a reserved word\&.
.PP
.PD 0
.TP
.PD
\fB\-\fP
Da command is executed wit a `\fB\-\fP\&' prepended ta its
\fBargv[0]\fP string\&.
.TP
\fBbuiltin\fP
Da command word is taken ta be tha name of a funky-ass builtin command,
rather than a gangbangin' finger-lickin' dirty-ass shell function or external command\&.
.TP
\fBcommand\fP [ \fB\-pvV\fP ]
Da command word is taken ta be tha name of a external command,
rather than a gangbangin' finger-lickin' dirty-ass shell function or builtin\&.   If tha \fBPOSIX_BUILTINS\fP option
is set, builtins will also be executed but certain special properties
of dem is suppressed\&. Da \fB\-p\fP flag causes a thugged-out default path ta be
searched instead of dat up in \fB$path\fP\&. With tha \fB\-v\fP flag, \fBcommand\fP
is similar ta \fBwhence\fP n' wit \fB\-V\fP, it is equivalent ta \fBwhence
\-v\fP\&.
.TP
\fBexec\fP [ \fB\-cl\fP ] [ \fB\-a\fP \fIargv0\fP ]
Da followin command together wit any arguments is run up in place
of tha current process, rather than as a sub\-process\&.  Da shell do not
fork n' is replaced\&.  Da shell do not invoke \fBTRAPEXIT\fP, nor do it
source \fBzlogout\fP files\&.
Da options is provided fo' compatibilitizzle wit other shells\&.
.RS
.PP
Da \fB\-c\fP option clears tha environment\&.
.PP
Da \fB\-l\fP option is equivalent ta tha \fB\-\fP precommand modifier, to
treat tha replacement command as a login shell; tha command is executed
with a \fB\-\fP prepended ta its \fBargv[0]\fP string\&.  This flag has no effect
if used together wit tha \fB\-a\fP option\&.
.PP
Da \fB\-a\fP option is used ta specify explicitly tha \fBargv[0]\fP string
(the name of tha command as peeped by tha process itself) ta be used by the
replacement command n' is directly equivalent ta settin a value
for tha \fBARGV0\fP environment variable\&.
.RE
.TP
\fBnocorrect\fP
Spellin erection aint done on any of tha lyrics\&.  This must appear
before any other precommand modifier, as it is interpreted immediately,
before any parsin is done\&.  It has no effect up in non\-interactizzle shells\&.
.TP
\fBnoglob\fP
Filename generation (globbing) aint performed on any of
the lyrics\&.
.SH "COMPLEX COMMANDS"
A \fIcomplex command\fP up in zsh is one of tha following:
.PP
.PD 0
.TP
.PD
\fBif\fP \fIlist\fP \fBthen\fP \fIlist\fP [ \fBelif\fP \fIlist\fP \fBthen\fP \fIlist\fP ] \&.\&.\&. [ \fBelse\fP \fIlist\fP ] \fBfi\fP
Da \fBif\fP \fIlist\fP is executed, n' if it returns a zero exit status,
the \fBthen\fP \fIlist\fP is executed\&.
Otherwise, tha \fBelif\fP \fIlist\fP is executed n' if its status is zero,
the \fBthen\fP \fIlist\fP is executed\&.
If each \fBelif\fP \fIlist\fP returns nonzero status, tha \fBelse\fP \fIlist\fP
is executed\&.
.TP
\fBfor\fP \fIname\fP \&.\&.\&. [ \fBin\fP \fIword\fP \&.\&.\&. ] \fIterm\fP \fBdo\fP \fIlist\fP \fBdone\fP
where \fIterm\fP be at least one newline or \fB;\fP\&.
Expand tha list of \fIword\fPs, n' set tha parameter
\fIname\fP ta each of dem up in turn, executing
\fIlist\fP each time\&.  If tha \fBin\fP \fIword\fP is omitted,
use tha positionizzle parametas instead of tha \fIword\fPs\&.
.RS
.PP
Mo' than one parameta \fIname\fP can step tha fuck up before tha list of
\fIword\fPs\&.  If \fIN\fP \fIname\fPs is given, then on each execution of the
loop tha next \fBN\fP \fIword\fPs is assigned ta tha corresponding
parameters\&.  If there be mo' \fIname\fPs than remainin \fIword\fPs, the
remainin parametas is each set ta tha empty string\&.  Execution of the
loop endz when there is no remainin \fIword\fP ta assign ta tha first
\fIname\fP\&.  It be only possible fo' \fBin\fP ta step tha fuck up as tha straight-up original gangsta \fIname\fP
in tha list, else it is ghon be treated as markin tha end of tha list\&.
.RE
.TP
\fBfor ((\fP [\fIexpr1\fP] \fB;\fP [\fIexpr2\fP] \fB;\fP [\fIexpr3\fP] \fB)) do\fP \fIlist\fP \fBdone\fP
Da arithmetic expression \fIexpr1\fP is evaluated first (see
the section `Arithmetic Evaluation\&')\&.  Da arithmetic expression
\fIexpr2\fP is repeatedly evaluated until it evaluates ta zero and
when non\-zero, \fIlist\fP is executed n' tha arithmetic expression
\fIexpr3\fP evaluated\&.  If any expression is omitted, then it behaves
as if it evaluated ta 1\&.
.TP
\fBwhile\fP \fIlist\fP \fBdo\fP \fIlist\fP \fBdone\fP
Execute tha \fBdo\fP \fIlist\fP as long as tha \fBwhile\fP \fIlist\fP
returns a zero exit status\&.
.TP
\fBuntil\fP \fIlist\fP \fBdo\fP \fIlist\fP \fBdone\fP
Execute tha \fBdo\fP \fIlist\fP as long as \fBuntil\fP \fIlist\fP
returns a nonzero exit status\&.
.TP
\fBrepeat\fP \fIword\fP \fBdo\fP \fIlist\fP \fBdone\fP
\fIword\fP is expanded n' treated as a arithmetic expression,
which must evaluate ta a number \fIn\fP\&.
\fIlist\fP is then executed \fIn\fP times\&.
.RS
.PP
Da \fBrepeat\fP syntax is disabled by default when the
shell starts up in a mode emulatin another shell\&.  It can be enabled
with tha command `\fBenable \-r repeat\fP\&'
.RE
.TP
\fBcase\fP \fIword\fP \fBin\fP [ [\fB(\fP] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \&.\&.\&. \fB)\fP \fIlist\fP (\fB;;\fP|\fB;&\fP|\fB;|\fP) ] \&.\&.\&. \fBesac\fP
Execute tha \fIlist\fP associated wit tha straight-up original gangsta \fIpattern\fP
that matches \fIword\fP, if any\&.  Da form of tha patterns
is tha same ol' dirty as dat used fo' filename generation\&.  See
the section `Filename Generation\&'\&.
.RS
.PP
If tha \fIlist\fP dat is executed is terminated wit \fB;&\fP rather than
\fB;;\fP, tha followin list be also executed\&.  Da rule for
the terminator of tha followin list \fB;;\fP, \fB;&\fP or \fB;|\fP is
applied unless tha \fBesac\fP is reached\&.
.PP
If tha \fIlist\fP dat is executed is terminated wit \fB;|\fP the
shell continues ta scan tha \fIpattern\fPs lookin fo' tha next match,
executin tha correspondin \fIlist\fP, n' applyin tha rule for
the correspondin terminator \fB;;\fP, \fB;&\fP or \fB;|\fP\&.
Note dat \fIword\fP aint re\-expanded; all applicable \fIpattern\fPs
are tested wit tha same \fIword\fP\&.
.RE
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP \&.\&.\&. \fIterm\fP ] \fBdo\fP \fIlist\fP \fBdone\fP
where \fIterm\fP is one or mo' newline or \fB;\fP ta terminizzle tha \fIword\fPs\&.
Print tha set of \fIword\fPs, each preceded by a number\&.
If tha \fBin\fP \fIword\fP is omitted, use tha positionizzle parameters\&.
Da \fBPROMPT3\fP prompt is printed n' a line is read from tha line editor
if tha shell is interactizzle n' dat be active, or else standard input\&.
If dis line consistz of the
number of one of tha listed \fIword\fPs, then tha parameta \fIname\fP
is set ta tha \fIword\fP correspondin ta dis number\&.
If dis line is empty, tha selection list is printed again\&.
Otherwise, tha value of tha parameta \fIname\fP is set ta null\&.
Da contentz of tha line read from standard input is saved
in tha parameta \fBREPLY\fP\&.  \fIlist\fP is executed
for each selection until a funky-ass break or end\-of\-file is encountered\&.
.TP
\fB(\fP \fIlist\fP \fB)\fP
Execute \fIlist\fP up in a subshell\&.  Traps set by tha \fBtrap\fP builtin
are reset ta they default joints while executin \fIlist\fP\&.
.TP
\fB{\fP \fIlist\fP \fB}\fP
Execute \fIlist\fP\&.
.TP
\fB{\fP \fItry\-list\fP \fB} always {\fP \fIalways\-list\fP \fB}\fP
First execute \fItry\-list\fP\&.  Regardless of errors, or \fBbreak\fP,
\fBcontinue\fP, or \fBreturn\fP commandz encountered within \fItry\-list\fP,
execute \fIalways\-list\fP\&.  Execution then continues from the
result of tha execution of \fItry\-list\fP; up in other lyrics, any error,
or \fBbreak\fP, \fBcontinue\fP, or \fBreturn\fP command is treated up in the
normal way, as if \fIalways\-list\fP was not present\&.  Da two
chunkz of code is referred ta as tha `try block\&' n' tha `always block'\&.
.RS
.PP
Optionizzle newlines or semicolons may step tha fuck up afta tha \fBalways\fP;
note, however, dat they may \fInot\fP step tha fuck up between tha preceding
closin brace n' tha \fBalways\fP\&.
.PP
An `error\&' up in dis context be a cold-ass lil condizzle like fuckin a syntax error which
causes tha shell ta abort execution of tha current function, script, or
list\&.  Syntax errors encountered while tha shell is parsin the
code do not cause tha \fIalways\-list\fP ta be executed\&.  For example,
an erroneously constructed \fBif\fP block up in \fBtry\-list\fP would cause the
shell ta abort durin parsing, so dat \fBalways\-list\fP would not be
executed, while a erroneous substitution like fuckin \fB${*foo*}\fP would
cause a run\-time error, afta which \fBalways\-list\fP would be executed\&.
.PP
An error condizzle can be tested n' reset wit tha special integer
variable \fBTRY_BLOCK_ERROR\fP\&.  Outside a \fBalways\-list\fP tha value is
irrelevant yo, but it is initialised ta \fB\-1\fP\&.  Inside \fBalways\-list\fP, the
value is 1 if a error occurred up in tha \fBtry\-list\fP, else 0\&.  If
\fBTRY_BLOCK_ERROR\fP is set ta 0 durin tha \fBalways\-list\fP, tha error
condizzle caused by tha \fBtry\-list\fP is reset, n' shell execution
continues normally afta tha end of \fBalways\-list\fP\&.  Alterin tha value
durin tha \fBtry\-list\fP aint useful (unless dis forms part of an
enclosin \fBalways\fP block)\&.
.PP
Regardless of \fBTRY_BLOCK_ERROR\fP, afta tha end of \fBalways\-list\fP the
normal shell status \fB$?\fP is tha value returned from \fBtry\-list\fP\&.
This is ghon be non\-zero if there was a error, even if \fBTRY_BLOCK_ERROR\fP
was set ta zero\&.
.PP
Da followin executes tha given code, ignorin any errors it causes\&.
This be a alternatizzle ta tha usual convention of protectin code by
executin it up in a subshell\&.
.PP
.RS
.nf
\fB{
    # code which may cause a error
  } always {
    # This code is executed regardless of tha error\&.
    (( TRY_BLOCK_ERROR = 0 ))
}
# Da error condizzle has been reset\&.\fP
.fi
.RE
.PP
An \fBexit\fP command (or a \fBreturn\fP command executed all up in tha outermost
function level of a script) encountered up in \fBtry\-list\fP do \fInot\fP cause
the execution of \fIalways\-list\fP\&.  Instead, tha shell exits immediately
afta any \fBEXIT\fP trap has been executed\&.
.RE
.TP
.PD 0
\fBfunction\fP \fIword\fP \&.\&.\&. [ \fB()\fP ] [ \fIterm\fP ] \fB{\fP \fIlist\fP \fB}\fP
.TP
.PD 0
\fIword\fP \&.\&.\&. \fB()\fP [ \fIterm\fP ] \fB{\fP \fIlist\fP \fB}\fP
.TP
.PD
\fIword\fP \&.\&.\&. \fB()\fP [ \fIterm\fP ] \fIcommand\fP
where \fIterm\fP is one or mo' newline or \fB;\fP\&.
Define a gangbangin' function which is referenced by any one of \fIword\fP\&.
Normally, only one \fIword\fP is provided; multiple \fIword\fPs
are probably only useful fo' settin traps\&.
Da body of tha function is tha \fIlist\fP between
the \fB{\fP n' \fB}\fP\&.  See tha section `Functions\&'\&.
.RS
.PP
If tha option \fBSH_GLOB\fP is set fo' compatibilitizzle wit other shells, then
whitespace may step tha fuck up between between tha left n' right parentheses when
there be a single \fIword\fP;  otherwise, tha parentheses is ghon be treated as
formin a globbin pattern up in dat case\&.
.PP
In any of tha forms above, a redirection may step tha fuck up outside the
function body, fo' example
.PP
.RS
.nf
\fBfunc() { \&.\&.\&. } 2>&1\fP
.fi
.RE
.PP
Da redirection is stored wit tha function n' applied whenever the
function is executed\&.  Any variablez up in tha redirection is expanded
at tha point tha function is executed yo, but outside tha function scope\&.
.RE
.TP
\fBtime\fP [ \fIpipeline\fP ]
Da \fIpipeline\fP is executed, n' timin statistics are
reported on tha standard error up in tha form specified
by tha \fBTIMEFMT\fP parameter\&.
If \fIpipeline\fP is omitted, print statistics bout the
shell process n' its children\&.
.TP
\fB[[\fP \fIexp\fP \fB]]\fP
Evaluates tha conditionizzle expression \fIexp\fP
and return a zero exit status if it is true\&.
See tha section `Conditionizzle Expressions\&'
for a thugged-out description of \fIexp\fP\&.
.SH "ALTERNATE FORMS FOR COMPLEX COMMANDS"
Many of zsh\&z complex commandz have alternate forms\&.  These are
non\-standard n' is likely not ta be obvious even ta seasoned shell
programmers; they should not be used anywhere dat portabilitizzle of shell
code be a cold-ass lil concern\&.
.PP
Da short versions below only work if \fIsublist\fP iz of tha form `\fB{\fP
\fIlist\fP \fB}\fP\&' or if tha \fBSHORT_LOOPS\fP option is set\&.  For tha \fBif\fP,
\fBwhile\fP n' \fBuntil\fP commands, up in both these cases tha test part of the
loop must also be suitably delimited, like fuckin by `\fB[[ \&.\&.\&. ]]\fP\&' or `\fB((
\&.\&.\&. ))\fP\&', else tha end of tha test aint gonna be recognized\&.  For the
\fBfor\fP, \fBrepeat\fP, \fBcase\fP n' \fBselect\fP commandz no such special form
for tha arguments is necessary yo, but tha other condizzle (the special form
of \fIsublist\fP or use of tha \fBSHORT_LOOPS\fP option) still applies\&.
.PP
.PD 0
.TP
.PD
\fBif\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP [ \fBelif\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP ] \&.\&.\&. [ \fBelse {\fP \fIlist\fP \fB}\fP ]
An alternate form of \fBif\fP\&.  Da rulez mean that
.RS
.PP
.RS
.nf
\fBif [[ \-o ignorebraces ]] {
  print yes
}\fP
.fi
.RE
.PP
works yo, but
.PP
.RS
.nf
\fBif legit {  # Do not work!
  print yes
}
\fP
.fi
.RE
.PP
does \fInot\fP, since tha test aint suitably delimited\&.
.RE
.TP
\fBif\fP \fIlist\fP \fIsublist\fP
A short form of tha alternate `if\&'\&.  Da same limitations on tha form of
\fIlist\fP apply as fo' tha previous form\&.
.TP
\fBfor\fP \fIname\fP \&.\&.\&. \fB(\fP \fIword\fP \&.\&.\&. \fB)\fP \fIsublist\fP
A short form of \fBfor\fP\&.
.TP
\fBfor\fP \fIname\fP \&.\&.\&. [ \fBin\fP \fIword\fP \&.\&.\&. ] \fIterm\fP \fIsublist\fP
where \fIterm\fP be at least one newline or \fB;\fP\&.
Another short form of \fBfor\fP\&.
.TP
\fBfor ((\fP [\fIexpr1\fP] \fB;\fP [\fIexpr2\fP] \fB;\fP [\fIexpr3\fP] \fB))\fP \fIsublist\fP
A short form of tha arithmetic \fBfor\fP command\&.
.TP
\fBforeach\fP \fIname\fP \&.\&.\&. \fB(\fP \fIword\fP \&.\&.\&. \fB)\fP \fIlist\fP \fBend\fP
Another form of \fBfor\fP\&.
.TP
\fBwhile\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP
An alternatizzle form of \fBwhile\fP\&.  Note tha limitations on tha form of
\fIlist\fP mentioned above\&.
.TP
\fBuntil\fP \fIlist\fP \fB{\fP \fIlist\fP \fB}\fP
An alternatizzle form of \fBuntil\fP\&.  Note tha limitations on tha form of
\fIlist\fP mentioned above\&.
.TP
\fBrepeat\fP \fIword\fP \fIsublist\fP
This be a gangbangin' finger-lickin' dirty-ass short form of \fBrepeat\fP\&.
.TP
\fBcase\fP \fIword\fP \fB{\fP [ [\fB(\fP] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] \&.\&.\&. \fB)\fP \fIlist\fP (\fB;;\fP|\fB;&\fP|\fB;|\fP) ] \&.\&.\&. \fB}\fP
An alternatizzle form of \fBcase\fP\&.
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP \fIterm\fP ] \fIsublist\fP
where \fIterm\fP be at least one newline or \fB;\fP\&.
A short form of \fBselect\fP\&.
.SH "RESERVED WORDS"
Da followin lyrics is recognized as reserved lyrics when used as tha first
word of a cold-ass lil command unless quoted or disabled rockin \fBdisable \-r\fP:
.PP
\fBdo done esac then elif else fi fo' case
if while function repeat time until
select coproc nocorrect foreach end ! [[ { }\fP
.PP
Additionally, `\fB}\fP\&' is recognized up in any posizzle if neither the
\fBIGNORE_BRACES\fP option nor tha \fBIGNORE_CLOSE_BRACES\fP option is set\&.
.SH "ERRORS"
Certain errors is treated as fatal by tha shell: up in a interactive
shell, they cause control ta return ta tha command line, n' up in a
non\-interactizzle shell they cause tha shell ta be aborted\&.  In older
versionz of zsh, a non\-interactizzle shell hustlin a script would not
abort straight-up yo, but would resume execution all up in tha next command ta be
read from tha script, skippin tha remainder of any functions or
shell constructs like fuckin loops or conditions; dis somewhat illogical
behaviour can be recovered by settin tha option \fBCONTINUE_ON_ERROR\fP\&.
.PP
Fatal errors found up in non\-interactizzle shells include:
.PP
.PD 0
.TP
.PD
\(bu
Failure ta parse shell options passed when invokin tha shell
.TP
\(bu
Failure ta chizzle options wit tha \fBset\fP builtin
.TP
\(bu
Parse errorz of all sorts, includin failures ta parse
mathematical expressions
.TP
\(bu
Failures ta set or modify variable behaviour wit \fBtypeset\fP,
\fBlocal\fP, \fBdeclare\fP, \fBexport\fP, \fBinteger\fP, \fBfloat\fP
.TP
\(bu
Execution of incorrectly positioned loop control structures
(\fBcontinue\fP, \fBbreak\fP)
.TP
\(bu
Attempts ta use regular expression wit no regular expression
module available
.TP
\(bu
Disallowed operations when tha \fBRESTRICTED\fP options is set
.TP
\(bu
Failure ta create a pipe needed fo' a pipeline
.TP
\(bu
Failure ta create a multio
.TP
\(bu
Failure ta autoload a module needed fo' a thugged-out declared shell feature
.TP
\(bu
Errors bustin command or process substitutions
.TP
\(bu
Syntax errors up in glob qualifiers
.TP
\(bu
File generation errors where not caught by tha option \fBBAD_PATTERN\fP
.TP
\(bu
All wack patterns used fo' matchin within case statements
.TP
\(bu
File generation failures where not caused by \fBNO_MATCH\fP or
similar options
.TP
\(bu
All file generation errors where tha pattern was used ta create a
multio
.TP
\(bu
Memory errors where detected by tha shell
.TP
\(bu
Invalid subscripts ta shell variables
.TP
\(bu
Attempts ta assign read\-only variables
.TP
\(bu
Logical errors wit variablez like fuckin assignment ta tha wack type
.TP
\(bu
Use of invalid variable names
.TP
\(bu
Errors up in variable substitution syntax
.TP
\(bu
Failure ta convert charactas up in \fB$\&'\fP\&.\&.\&.\fB'\fP expressions
.PP
If tha \fBPOSIX_BUILTINS\fP option is set, mo' errors associated with
shell builtin commandz is treated as fatal, as specified by tha POSIX
standard\&.
.PP
.SH "COMMENTS"
In non\-interactizzle shells, or up in interactizzle shells wit the
\fBINTERACTIVE_COMMENTS\fP option set, a word beginning
with tha third characta of tha \fBhistchars\fP parameter
(`\fB#\fP\&' by default) causes dat word n' all tha following
charactas up ta a newline ta be ignored\&.
.SH "ALIASING"
Every token up in tha shell input is checked ta peep if there
is a alias defined fo' it\&.
If so, it is replaced by tha text of tha alias if it is up in command
posizzle (if it could be tha straight-up original gangsta word of a simple command),
or if tha alias is global\&.
If tha text endz wit a space, tha next word up in tha shell input
is treated as though it was up in command posizzle fo' purposez of alias
expansion\&.
An alias is defined rockin tha \fBalias\fP builtin; global aliases
may be defined rockin tha \fB\-g\fP option ta dat builtin\&.
.PP
Alias expansion is done on tha shell input before any other expansion
except history expansion\&.  Therefore, if a alias is defined fo' the
word \fBfoo\fP, alias expansion may be avoided by quotin part of the
word, e\&.g\&. \fB\efoo\fP\&.  Any form of quotin works, although there is
nothang ta prevent a alias bein defined fo' tha quoted form such as
\fB\efoo\fP as well\&.  For use wit completion, which would remove an
initial backslash followed by a cold-ass lil characta dat isn\&'t special, it may be
more convenient ta quote tha word by startin wit a single quote,
i\&.e\&. \fB\&'foo\fP; completion will automatically add tha trailin single
quote\&.
.PP
There be a cold-ass lil commonly encountered problem wit aliases
illustrated by tha followin code:
.PP
.RS
.nf
\fBalias echobar=\&'echo bar'; echobar\fP
.fi
.RE
.PP
This prints a message dat tha command \fBechobar\fP could not be found\&.
This happens cuz aliases is expanded when tha code is read in;
the entire line is read up in one go, so dat when \fBechobar\fP is executed it
is too late ta expand tha newly defined alias\&.  This is often
a problem up in shell scripts, functions, n' code executed wit `\fBsource\fP\&'
or `\fB\&.\fP\&'\&.  Consequently, use of functions rather than aliases is
recommended up in non\-interactizzle code\&.
.PP
Note also tha unhelpful interaction of aliases n' function definitions:
.PP
.RS
.nf
\fBalias func=\&'noglob func'
func() {
    echo Do suttin' wit $*
}\fP
.fi
.RE
.PP
Because aliases is expanded up in function definitions, dis causes the
followin command ta be executed:
.PP
.RS
.nf
\fBnoglob func() {
    echo Do suttin' wit $*
}\fP
.fi
.RE
.PP
which defines \fBnoglob\fP as well as \fBfunc\fP as functions wit the
body given\&.  To avoid this, either quote tha name \fBfunc\fP or use the
alternatizzle function definizzle form `\fBfunction func\fP\&'\&.  Ensurin the
alias is defined afta tha function works but is problematic if the
code fragment might be re\-executed\&.
.PP
.SH "QUOTING"
A characta may be \fIquoted\fP (that is, made
to stand fo' itself) by precedin it wit a `\fB\e\fP\&'\&.
`\fB\e\fP\&' followed by a newline is ignored\&.
.PP
A strang enclosed between `\fB$\&'\fP' n' `\fB'\fP' is
processed tha same way as tha strang argumentz of the
\fBprint\fP builtin, n' tha resultin strang is considered ta be
entirely quoted\&.  A literal `\fB\&'\fP' characta can be included up in the
strin by rockin tha `\fB\e\&'\fP' escape\&.
.PP
All charactas enclosed between a pair of single quotes (\fB\&''\fP) that
is not preceded by a `\fB$\fP\&' is quoted\&.  A single quote cannot appear
within single quotes unless tha option \fBRC_QUOTES\fP is set, up in which case
a pair of single quotes is turned tha fuck into a single quote\&.  For example,
.PP
.RS
.nf
\fBprint \&''''\fP
.fi
.RE
.PP
outputs not a god damn thang apart from a newline if \fBRC_QUOTES\fP aint set yo, but one
single quote if it is set\&.
.PP
Inside double quotes (\fB""\fP), parameta and
command substitution occur, n' `\fB\e\fP\&' quotes tha characters
`\fB\e\fP\&', `\fB`\fP', `\fB"\fP', n' `\fB$\fP'\&.
.\" Yodl file: Zsh/redirect.yo
.SH "REDIRECTION"
If a cold-ass lil command is followed by \fB&\fP
and thang control aint active,
then tha default standard input
for tha command is tha empty file \fB/dev/null\fP\&.
Otherwise, tha environment fo' tha execution of a cold-ass lil command gotz nuff the
file descriptorz of tha invokin shell as modified by
input/output justifications\&.
.PP
Da followin may step tha fuck up anywhere up in a simple command
or may precede or follow a cold-ass lil complex command\&.
Expansion occurs before \fIword\fP or \fIdigit\fP
is used except as noted below\&.
If tha result of substitution on \fIword\fP
produces mo' than one filename,
redirection occurs fo' each
separate filename up in turn\&.
.PP
.PD 0
.TP
.PD
\fB<\fP \fIword\fP
Open file \fIword\fP fo' readin as standard input\&.
.TP
\fB<>\fP \fIword\fP
Open file \fIword\fP fo' readin n' freestylin as standard input\&.
If tha file do not exist then it is pimped\&.
.TP
\fB>\fP \fIword\fP
Open file \fIword\fP fo' freestylin as standard output\&.
If tha file do not exist then it is pimped\&.
If tha file exists, n' tha \fBCLOBBER\fP option is unset,
this causes a error;
otherwise, it is truncated ta zero length\&.
.TP
.PD 0
\fB>|\fP \fIword\fP
.TP
.PD
\fB>!\fP \fIword\fP
Same as \fB>\fP, except dat tha file is truncated ta zero length
if it exists, even if \fBCLOBBER\fP is unset\&.
.TP
\fB>>\fP \fIword\fP
Open file \fIword\fP fo' freestylin up in append mode as standard output\&.
If tha file do not exist, n' tha \fBCLOBBER\fP
option is unset, dis causes a error;
otherwise, tha file is pimped\&.
.TP
.PD 0
\fB>>|\fP \fIword\fP
.TP
.PD
\fB>>!\fP \fIword\fP
Same as \fB>>\fP, except dat tha file is pimped if it do not
exist, even if \fBCLOBBER\fP is unset\&.
.TP
\fB<<\fP[\fB\-\fP] \fIword\fP
Da shell input is read up ta a line dat is tha same ol' dirty as
\fIword\fP, or ta a end\-of\-file\&.
No parameta expansion, command substitution or
filename generation is performed on \fIword\fP\&.
Da resultin document, called a
\fIhere\-document\fP, becomes tha standard input\&.
.RS
.PP
If any characta of \fIword\fP is quoted with
single or double quotes or a `\fB\e\fP\&',
no interpretation is placed upon tha charactaz of tha document\&.
Otherwise, parameta n' command substitution
occurs, `\fB\e\fP\&' followed by a newline is removed,
and `\fB\e\fP\&' must be used ta quote tha characters
`\fB\e\fP\&', `\fB$\fP', `\fB`\fP' n' tha straight-up original gangsta characta of \fIword\fP\&.
.PP
Note dat \fIword\fP itself do not undergo shell expansion\&.  Backquotes
in \fIword\fP aint gots they usual effect; instead they behave
similarly ta double quotes, except dat tha backquotes theyselves are
passed all up in unchanged\&.  (This shiznit is given fo' completeness
and it aint recommended dat backquotes be used\&.)  Quotes up in tha form
\fB$\&'\fP\fI\&.\&.\&.\fP\fB'\fP have they standard effect of expandin backslashed
references ta special characters\&.
.PP
If \fB<<\-\fP is used, then all leading
tabs is stripped from \fIword\fP n' from tha document\&.
.RE
.TP
\fB<<<\fP \fIword\fP
Perform shell expansion on \fIword\fP n' pass tha result
to standard input\&.  This is known as a \fIhere\-string\fP\&.
Compare tha use of \fIword\fP up in here\-documents above, where \fIword\fP
does not undergo shell expansion\&.
.TP
.PD 0
\fB<&\fP \fInumber\fP
.TP
.PD
\fB>&\fP \fInumber\fP
Da standard input/output is duplicated from file descriptor
\fInumber\fP (see \fIdup2\fP(2))\&.
.TP
.PD 0
\fB<& \-\fP
.TP
.PD
\fB>& \-\fP
Close tha standard input/output\&.
.TP
.PD 0
\fB<& p\fP
.TP
.PD
\fB>& p\fP
Da input/output from/to tha coprocess is moved ta tha standard input/output\&.
.TP
.PD 0
\fB>&\fP \fIword\fP
.TP
.PD
\fB&>\fP \fIword\fP
(Except where `\fB>&\fP \fIword\fP\&' matches one of tha above syntaxes;
`\fB&>\fP\&' can always be used ta avoid dis ambiguity\&.)
Redirects both standard output n' standard error (file descriptor 2)
in tha manner of `\fB>\fP \fIword\fP\&'\&.
Note dat dis do \fInot\fP have tha same effect as `\fB>\fP \fIword\fP \fB2>&1\fP\&'
in tha presence of multios (see tha section below)\&.
.TP
.PD 0
\fB>&|\fP \fIword\fP
.TP
.PD 0
\fB>&!\fP \fIword\fP
.TP
.PD 0
\fB&>|\fP \fIword\fP
.TP
.PD
\fB&>!\fP \fIword\fP
Redirects both standard output n' standard error (file descriptor 2)
in tha manner of `\fB>|\fP \fIword\fP\&'\&.
.TP
.PD 0
\fB>>&\fP \fIword\fP
.TP
.PD
\fB&>>\fP \fIword\fP
Redirects both standard output n' standard error (file descriptor 2)
in tha manner of `\fB>>\fP \fIword\fP\&'\&.
.TP
.PD 0
\fB>>&|\fP \fIword\fP
.TP
.PD 0
\fB>>&!\fP \fIword\fP
.TP
.PD 0
\fB&>>|\fP \fIword\fP
.TP
.PD
\fB&>>!\fP \fIword\fP
Redirects both standard output n' standard error (file descriptor 2)
in tha manner of `\fB>>|\fP \fIword\fP\&'\&.
.PP
If one of tha above is preceded by a gangbangin' finger-lickin' digit, then tha file
descriptor referred ta is dat specified by tha digit
instead of tha default 0 or 1\&.
Da order up in which redirections is specified is significant\&.
Da shell evaluates each redirection up in termz of the
(\fIfile descriptor\fP, \fIfile\fP)
association all up in tha time of evaluation\&.
For example:
.PP
.RS
.nf
\&.\&.\&. \fB1>\fP\fIfname\fP \fB2>&1\fP
.fi
.RE
.PP
first associates file descriptor 1 wit file \fIfname\fP\&.
It then associates file descriptor 2 wit tha file associated wit file
descriptor 1 (that is, \fIfname\fP)\&.
If tha order of redirections was reversed,
file descriptor 2 would be associated
with tha terminal (assumin file descriptor 1 had been)
and then file descriptor 1 would be associated wit file \fIfname\fP\&.
.PP
Da `\fB|&\fP\&' command separator busted lyrics bout in
\fISimple Commandz & Pipelines\fP up in \fIzshmisc\fP(1)
is a gangbangin' finger-lickin' dirty-ass shorthand fo' `\fB2>&1 |\fP\&'\&.
.PP
Da various formz of process substitution, `\fB<(\fP\fIlist\fP\fB)\fP\&',
and `\fB=(\fP\fIlist\fP())\&' fo' input and
`\fB>(\fP\fIlist\fP\fB)\fP\&' fo' output, is often used together with
redirection\&.  For example, if \fIword\fP up in a output redirection iz of the
form `\fB>(\fP\fIlist\fP\fB)\fP\&' then tha output is piped ta the
command represented by \fIlist\fP\&.  See
\fIProcess Substitution\fP up in \fIzshexpn\fP(1)\&.
.SH "OPENING FILE DESCRIPTORS USING PARAMETERS"
.PP
When tha shell is parsin arguments ta a cold-ass lil command, n' tha shell option
\fBIGNORE_BRACES\fP aint set, a gangbangin' finger-lickin' different form of redirection be allowed:
instead of a gangbangin' finger-lickin' digit before tha operator there be a valid shell identifier
enclosed up in braces\&.  Da shell will open a freshly smoked up file descriptor that
is guaranteed ta be at least 10 n' set tha parameta named by the
identifier ta tha file descriptor opened\&.  No whitespace be allowed
between tha closin brace n' tha redirection character\&.  For example:
.PP
.RS
.nf
\&.\&.\&. {myfd}>&1
.fi
.RE
.PP
This opens a freshly smoked up file descriptor dat be a thugged-out duplicate of file descriptor
1 n' sets tha parameta \fBmyfd\fP ta tha number of tha file descriptor,
which is ghon be at least 10\&.  Da freshly smoked up file descriptor can be freestyled ta using
the syntax \fB>&$myfd\fP\&.
.PP
Da syntax \fB{\fP\fIvarid\fP\fB}>&\-\fP, fo' example \fB{myfd}>&\-\fP, may be used
to close a gangbangin' file descriptor opened up in dis fashion\&.  Note dat the
parameta given by \fIvarid\fP must previously be set ta a gangbangin' file descriptor
in dis case\&.
.PP
It be a error ta open or close a gangbangin' file descriptor up in dis fashizzle when the
parameta is readonly\&.  But fuck dat shiznit yo, tha word on tha street is dat it aint a error ta read or write a gangbangin' file
descriptor rockin \fB<&$\fP\fIparam\fP or \fB>&$\fP\fIparam\fP if \fIparam\fP is
readonly\&.
.PP
If tha option \fBCLOBBER\fP is unset, it be a error ta open a gangbangin' file
descriptor rockin a parameta dat be already set ta a open file descriptor
previously allocated by dis mechanism\&.  Unsettin tha parameta before
usin it fo' allocatin a gangbangin' file descriptor avoidz tha error\&.
.PP
Note dat dis mechanizzle merely allocates or closes a gangbangin' file descriptor; it
does not big-ass up any redirections from or ta it\&.  It be probably convenient
to allocate a gangbangin' file descriptor prior ta use as a argument ta \fBexec\fP\&.
Da syntax do not up in any case work when used round complex commands
like fuckin parenthesised subshells or loops, where tha openin brace is
interpreted as part of a cold-ass lil command list ta be executed up in tha current shell\&.
.PP
Da followin shows a typical sequence of allocation, use, n' closin of a
file descriptor:
.PP
.RS
.nf
\fBinteger myfd
exec {myfd}>~/logs/mylogfile\&.txt
print This be a log message\&. >&$myfd
exec {myfd}>&\-\fP
.fi
.RE
.PP
Note dat tha expansion of tha variable up in tha expression \fB>&$myfd\fP
occurs all up in tha point tha redirection is opened\&.  This be afta tha expansion
of command arguments n' afta any redirections ta tha left on tha command
line done been processed\&.
.SH "MULTIOS"
If tha user tries ta open a gangbangin' file descriptor fo' freestylin mo' than once,
the shell opens tha file descriptor as a pipe ta a process dat copies
its input ta all tha specified outputs, similar ta \fBtee\fP,
provided tha \fBMULTIOS\fP option is set, as it is by default\&.  Thus:
.PP
.RS
.nf
\fBdate >foo >bar\fP
.fi
.RE
.PP
writes tha date ta two files, named `\fBfoo\fP\&' n' `\fBbar\fP'\&.
Note dat a pipe be a implicit redirection; thus
.PP
.RS
.nf
\fBdate >foo | cat\fP
.fi
.RE
.PP
writes tha date ta tha file `\fBfoo\fP\&', n' also pipes it ta cat\&.
.PP
If tha \fBMULTIOS\fP
option is set, tha word afta a redirection operator be also subjected
to filename generation (globbing)\&.  Thus
.PP
.RS
.nf
\fB: > *\fP
.fi
.RE
.PP
will truncate all filez up in tha current directory,
assumin there\&z at least one\&.  (Without tha \fBMULTIOS\fP
option, it would create a empty file called `\fB*\fP\&'\&.)
Similarly, you can do
.PP
.RS
.nf
\fBecho exit 0 >> *\&.sh\fP
.fi
.RE
.PP
If tha user tries ta open a gangbangin' file descriptor fo' readin mo' than once,
the shell opens tha file descriptor as a pipe ta a process dat copies
all tha specified inputs ta its output up in tha order
specified, similar ta \fBcat\fP,
provided tha \fBMULTIOS\fP option is set\&.  Thus
.PP
.RS
.nf
\fBsort <foo <fubar\fP
.fi
.RE
.PP
or even
.PP
.RS
.nf
\fBsort <f{oo,ubar}\fP
.fi
.RE
.PP
is equivalent ta `\fBcat foo fubar | sort\fP\&'\&.
.PP
Expansion of tha redirection argument occurs all up in tha point tha redirection
is opened, all up in tha point busted lyrics bout above fo' tha expansion of tha variable
in \fB>&$myfd\fP\&.
.PP
Note dat a pipe be a implicit redirection; thus
.PP
.RS
.nf
\fBcat bar | sort <foo\fP
.fi
.RE
.PP
is equivalent ta `\fBcat bar foo | sort\fP\&' (note tha order of tha inputs)\&.
.PP
If tha \fBMULTIOS\fP option is \fIun\fPset,
each redirection replaces tha previous redirection fo' dat file descriptor\&.
But fuck dat shiznit yo, tha word on tha street is dat all filez repimped up ta is straight-up opened, so
.PP
.RS
.nf
\fBecho foo > bar > baz\fP
.fi
.RE
.PP
when \fBMULTIOS\fP is unset will truncate bar, n' write `\fBfoo\fP\&' tha fuck into baz\&.
.PP
There be a problem when a output multio be attached ta a external
program\&.  A simple example shows this:
.PP
.RS
.nf
\fBcat file >file1 >file2
cat file1 file2\fP
.fi
.RE
.PP
Here, it is possible dat tha second `\fBcat\fP\&' aint gonna display tha full
contentz of \fBfile1\fP n' \fBfile2\fP (i\&.e\&. tha original gangsta contents of
\fBfile\fP repeated twice)\&.
.PP
Da reason fo' dis is dat tha multios is spawned afta tha \fBcat\fP
process is forked from tha parent shell, so tha parent shell do not
wait fo' tha multios ta finish freestylin data\&.  This means tha command as
shown can exit before \fBfile1\fP n' \fBfile2\fP is straight-up written\&.
As a workaround, it is possible ta run tha \fBcat\fP process as part of a
job up in tha current shell:
.PP
.RS
.nf
\fB{ pussaaaaay file } >file >file2\fP
.fi
.RE
.PP
Here, tha \fB{\fP\fI\&.\&.\&.\fP\fB}\fP thang will pause ta wait fo' both filez ta be
written\&.
.PP
.SH "REDIRECTIONS WITH NO COMMAND"
When a simple command consistz of one or mo' redirection operators
and zero or mo' parameta assignments yo, but no command name, zsh can
behave up in nuff muthafuckin ways\&.
.PP
If tha parameta \fBNULLCMD\fP aint set or tha option \fBCSH_NULLCMD\fP is
set, a error is caused\&.  This is tha \fBcsh\fP behavior n' \fBCSH_NULLCMD\fP
is set by default when emulatin \fBcsh\fP\&.
.PP
If tha option \fBSH_NULLCMD\fP is set, tha builtin `\fB:\fP\&' is banged as a
command wit tha given redirections\&.  This is tha default when emulating
\fBsh\fP or \fBksh\fP\&.
.PP
Otherwise, if tha parameta \fBNULLCMD\fP is set, its value is ghon be used as a
command wit tha given redirections\&.  If both \fBNULLCMD\fP and
\fBREADNULLCMD\fP is set, then tha value of tha latta is ghon be used instead
of dat of tha forma when tha redirection be a input\&.  Da default for
\fBNULLCMD\fP is `\fBcat\fP\&' n' fo' \fBREADNULLCMD\fP is `\fBmore\fP'\&. Thus
.PP
.RS
.nf
\fB< file\fP
.fi
.RE
.PP
shows tha contentz of \fBfile\fP on standard output, wit pagin if dat be a
terminal\&.  \fBNULLCMD\fP n' \fBREADNULLCMD\fP may refer ta shell functions\&.
.PP
.\" Yodl file: Zsh/exec.yo
.SH "COMMAND EXECUTION"
If a cold-ass lil command name gotz nuff no slashes, tha shell attempts ta locate
it\&.  If there exists a gangbangin' finger-lickin' dirty-ass shell function by dat name, tha function
is invoked as busted lyrics bout up in tha section `Functions\&'\&.  If there exists
a shell builtin by dat name, tha builtin is invoked\&.
.PP
Otherwise, tha shell searches each element of \fB$path\fP fo' a
directory containin a executable file by dat name\&.  If the
search is unsuccessful, tha shell prints a error message n' returns
a nonzero exit status\&.
.PP
If execution fails cuz tha file aint up in executable format,
and tha file aint a gangbangin' finger-lickin' directory, it be assumed ta be a gangbangin' finger-lickin' dirty-ass shell
script\&.  \fB/bin/sh\fP is spawned ta execute it\&.  If tha program
is a gangbangin' file beginnin wit `\fB#!\fP\&', tha remainder of tha straight-up original gangsta line
specifies a interpreta fo' tha program\&.  Da shell will
execute tha specified interpreta on operatin systems dat do
not handle dis executable format up in tha kernel\&.
.PP
If no external command is found but a gangbangin' function \fBcommand_not_found_handlez\fP
exists tha shell executes dis function wit all
command line arguments\&.  Da function should return status zero if it
successfully handled tha command, or non\-zero status if it failed\&.
In tha latta case tha standard handlin be applied: `command not
found\&' is printed ta standard error n' tha shell exits wit status 127\&.
Note dat tha handlez is executed up in a subshell forked ta execute
an external command, hence chizzlez ta directories, shell parameters,
etc\&. have no effect on tha main shell\&.
.\" Yodl file: Zsh/func.yo
.SH "FUNCTIONS"
Shell functions is defined wit tha \fBfunction\fP reserved word or the
special syntax `\fIfuncname\fP \fB()\fP\&'\&.
Shell functions is read up in n' stored internally\&.
Alias names is resolved when tha function is read\&.
Functions is executed like commandz wit tha arguments
passed as positionizzle parameters\&.
(See tha section `Command Execution\&'\&.)
.PP
Functions execute up in tha same process as tha calla and
share all files
and present hustlin directory wit the
caller\&.  A trap on \fBEXIT\fP set inside a gangbangin' function
is executed afta tha function completes up in tha environment
of tha caller\&.
.PP
Da \fBreturn\fP builtin is used ta return from function calls\&.
.PP
Function identifiers can be listed wit tha \fBfunctions\fP builtin\&.
Functions can be undefined wit tha \fBunfunction\fP builtin\&.
.SH "AUTOLOADING FUNCTIONS"
.PP
A function can be marked as \fIundefined\fP rockin tha \fBautoload\fP builtin
(or `\fBfunctions \-u\fP\&' or `\fBtypeset \-fu\fP')\&.  Such a gangbangin' function has no
body\&.  When tha function is first executed, tha shell searches fo' its
definizzle rockin tha elementz of tha \fBfpath\fP variable\&.  Thus ta define
functions fo' autoloading, a typical sequence is:
.PP
.RS
.nf
\fBfpath=(~/myfuncs $fpath)
autoload myfunc1 myfunc2 \&.\&.\&.\fP
.fi
.RE
.PP
Da usual alias expansion durin readin is ghon be suppressed if the
\fBautoload\fP builtin or its equivalent is given tha option \fB\-U\fP\&. This is
recommended fo' tha use of functions supplied wit tha zsh distribution\&.
Note dat fo' functions precompiled wit tha \fBzcompile\fP builtin command
the flag \fB\-U\fP must be provided when tha \fB\&.zwc\fP file is pimped, as the
correspondin shiznit is compiled tha fuck into tha latter\&.
.PP
For each \fIelement\fP up in \fBfpath\fP, tha shell looks fo' three possible
files, tha newest of which is used ta load tha definizzle fo' tha function:
.PP
.PD 0
.TP
.PD
\fIelement\fP\fB\&.zwc\fP
A file pimped wit tha \fBzcompile\fP builtin command, which is sposed ta fuckin
contain tha definitions fo' all functions up in tha directory named
\fIelement\fP\&.  Da file is treated up in tha same manner as a gangbangin' finger-lickin' directory
containin filez fo' functions n' is searched fo' tha definizzle of the
function\&.   If tha definizzle aint found, tha search fo' a thugged-out definition
proceedz wit tha other two possibilitizzles busted lyrics bout below\&.
.RS
.PP
If \fIelement\fP already includes a \fB\&.zwc\fP extension (i\&.e\&. tha extension
was explicitly given by tha user), \fIelement\fP is searched fo' the
definizzle of tha function without comparin its age ta dat of other
files; up in fact, there do not need ta be any directory named \fIelement\fP
without tha suffix\&.  Thus includin a element such as
`\fB/usr/local/funcs\&.zwc\fP\&' up in \fBfpath\fP will speed up tha search for
functions, wit tha disadvantage dat functions included must be explicitly
recompiled by hand before tha shell notices any chizzles\&.
.RE
.TP
\fIelement\fP\fB/\fP\fIfunction\fP\fB\&.zwc\fP
A file pimped wit \fBzcompile\fP, which is sposed ta fuckin contain the
definizzle fo' \fIfunction\fP\&.  It may include other function definitions
as well yo, but dem is neither loaded nor executed; a gangbangin' file found up in this
way is searched \fIonly\fP fo' tha definizzle of \fIfunction\fP\&.
.TP
\fIelement\fP\fB/\fP\fIfunction\fP
A file of zsh command text, taken ta be tha definizzle fo' \fIfunction\fP\&.
.PP
In summary, tha order of searchin is, first, up in tha \fIparents of\fP
directories up in \fBfpath\fP fo' tha newer of either a cold-ass lil compiled directory or
a directory up in \fBfpath\fP; second, if mo' than one of these gotz nuff a
definizzle fo' tha function dat is sought, tha leftmost up in tha \fBfpath\fP
is chosen; n' third, within a gangbangin' finger-lickin' directory, tha newer of either a cold-ass lil compiled
function or a ordinary function definizzle is used\&.
.PP
If tha \fBKSH_AUTOLOAD\fP option is set, or tha file gotz nuff only a
simple definizzle of tha function, tha file\&z contents is ghon be executed\&.
This will normally define tha function up in question yo, but may also perform
initialization, which is executed up in tha context of tha function execution,
and may therefore define local parameters\&.  It be a error if tha function
is not defined by loadin tha file\&.
.PP
Otherwise, tha function body (with no surroundin `\fIfuncname\fP\fB()
{\fP\fI\&.\&.\&.\fP\fB}\fP\&') is taken ta be tha complete contentz of tha file\&.  This
form allows tha file ta be used directly as a executable shell script\&.  If
processin of tha file thangs up in dis biatch up in tha function bein re\-defined, the
function itself aint re\-executed\&.  To force tha shell ta perform
initialization n' then call tha function defined, tha file should contain
initialization code (which is ghon be executed then discarded) up in addizzle to
a complete function definizzle (which is ghon be retained fo' subsequent calls
to tha function), n' a cold-ass lil call ta tha shell function, includin any
arguments, all up in tha end\&.
.PP
For example, suppose tha autoload file \fBfunc\fP gotz nuff
.PP
.RS
.nf
\fBfunc() { print This is func; }
print func is initialized
\fP
.fi
.RE
.PP
then `\fBfunc; func\fP\&' wit \fBKSH_AUTOLOAD\fP set will produce both lyrics
on tha straight-up original gangsta call yo, but only tha message `\fBThis is func\fP\&' on tha second
and subsequent calls\&.  Without \fBKSH_AUTOLOAD\fP set, it will produce
the initialization message on tha straight-up original gangsta call, n' tha other message on the
second n' subsequent calls\&.
.PP
It be also possible ta create a gangbangin' function dat aint marked as autoloaded,
but which loadz its own definizzle by searchin \fBfpath\fP, by using
`\fBautoload \-X\fP\&' within a gangbangin' finger-lickin' dirty-ass shell function\&.  For example, tha followin are
equivalent:
.PP
.RS
.nf
\fBmyfunc() {
  autoload \-X
}
myfunc args\&.\&.\&.\fP
.fi
.RE
.PP
and
.PP
.RS
.nf
\fBunfunction myfunc   # if myfunc was defined
autoload myfunc
myfunc args\&.\&.\&.\fP
.fi
.RE
.PP
In fact, tha \fBfunctions\fP command outputs `\fBbuiltin autoload \-X\fP\&' as
the body of a autoloaded function\&.  This is done so that
.PP
.RS
.nf
\fBeval "$(functions)"\fP
.fi
.RE
.PP
produces a reasonable result\&.  A legit autoloaded function can be
identified by tha presence of tha comment `\fB# undefined\fP\&' up in tha body,
because all comments is discarded from defined functions\&.
.PP
To load tha definizzle of a autoloaded function \fBmyfunc\fP without
executin \fBmyfunc\fP, use:
.PP
.RS
.nf
\fBautoload +X myfunc\fP
.fi
.RE
.PP
.SH "ANONYMOUS FUNCTIONS"
.PP
If no name is given fo' a gangbangin' function, it is `anonymous\&' n' is handled
specially\&.  Either form of function definizzle may be used: a `\fB()\fP\&' with
no precedin name, or a `\fBfunction\fP\&' wit a immediately followin open
brace\&.  Da function is executed immediately all up in tha deal wit definizzle and
is not stored fo' future use\&.  Da function name is set ta `\fB(anon)\fP\&'\&.
.PP
Arguments ta tha function may be specified as lyrics followin the
closin brace definin tha function, hence if there be none no
arguments (other than \fB$0\fP) is set\&.  This be a gangbangin' finger-lickin' difference from the
way other functions is parsed: aiiight function definitions may be
followed by certain keywordz like fuckin `\fBelse\fP\&' or `\fBfi\fP', which will
be treated as arguments ta anonymous functions, so dat a newline or
semicolon is needed ta force keyword interpretation\&.
.PP
Note also dat tha argument list of any enclosin script or function is
hidden (as would be tha case fo' any other function called at this
point)\&.
.PP
Redirections may be applied ta tha anonymous function up in tha same manner as
to a cold-ass lil current\-shell structure enclosed up in braces\&.  Da main use of anonymous
functions is ta provide a scope fo' local variables\&.  This is particularly
convenient up in start\-up filez as these do not provide they own local
variable scope\&.
.PP
For example,
.PP
.RS
.nf
\fBvariable=outside
function {
  local variable=inside
  print "I be $variable wit arguments $*"
} dis n' that
print "I be $variable"\fP
.fi
.RE
.PP
outputs tha following:
.PP
.RS
.nf
\fBI be inside wit arguments dis n' that
I be outside\fP
.fi
.RE
.PP
Note dat function definitions wit arguments dat expand ta nothing,
for example `\fBname=; function $name { \fP\fI\&.\&.\&.\fP\fB }\fP\&', is not
treated as anonymous functions\&.  Instead, they is treated as normal
function definitions where tha definizzle is silently discarded\&.
.PP
.SH "SPECIAL FUNCTIONS"
Certain functions, if defined, have special meanin ta tha shell\&.
.PP
.SS "Hook Functions"
.PP
For tha functions below, it is possible ta define a array dat has the
same name as tha function wit `\fB_functions\fP\&' appended\&.  Any element in
such a array is taken as tha name of a gangbangin' function ta execute; it is executed
in tha same context n' wit tha same arguments as tha basic function\&.  For
example, if \fB$chpwd_functions\fP be a array containin tha joints
`\fBmychpwd\fP\&', `\fBchpwd_save_dirstack\fP', then tha shell attempts to
execute tha functions `\fBchpwd\fP\&', `\fBmychpwd\fP' and
`\fBchpwd_save_dirstack\fP\&', up in dat order\&.  Any function dat do not exist
is silently ignored\&.  A function found by dis mechanizzle is referred to
elsewhere as a `hook function\&'\&.  An error up in any function causes subsequent
functions not ta be run\&.  Note further dat a error up in a \fBprecmd\fP hook
causes a immediately followin \fBperiodic\fP function not ta run (though
it may run all up in tha next opportunity)\&.
.PP
.PD 0
.TP
.PD
\fBchpwd\fP
Executed whenever tha current hustlin directory is chizzled\&.
.TP
\fBperiodic\fP
If tha parameta \fBPERIOD\fP
is set, dis function is executed every last muthafuckin \fB$PERIOD\fP
seconds, just before a prompt\&.  Note dat if multiple functions
are defined rockin tha array \fBperiodic_functions\fP only one
period be applied ta tha complete set of functions, n' the
scheduled time aint reset if tha list of functions be altered\&.
Hence tha set of functions be always called together\&.
.TP
\fBprecmd\fP
Executed before each prompt\&.  Note dat precommand functions is not
re\-executed simply cuz tha command line is redrawn, as happens, for
example, when a notification bout a exitin thang is displayed\&.
.TP
\fBpreexec\fP
Executed just afta a cold-ass lil command has been read n' be bout ta be
executed\&.  If tha history mechanizzle be actizzle (and tha line was not
discarded from tha history buffer), tha strang dat tha user typed is
passed as tha straight-up original gangsta argument, otherwise it be a empty string\&.  The
actual command dat is ghon be executed (includin expanded aliases) is
passed up in two different forms: tha second argument be a single\-line,
size\-limited version of tha command (with thangs like function bodies
elided); tha third argument gotz nuff tha full text dat is being
executed\&.
.TP
\fBzshaddhistory\fP
Executed when a history line has been read interactively yo, but
before it is executed\&.  Da sole argument is tha complete history
line (so dat any terminatin newline will still be present)\&.
.RS
.PP
If any of tha hook functions returns status 1 (or any non\-zero value
other than 2, though dis aint guaranteed fo' future versionz of the
shell) tha history line aint gonna be saved, although it lingers up in the
history until tha next line is executed, allowin you ta reuse or edit
it immediately\&.
.PP
If any of tha hook functions returns status 2 tha history line
will be saved on tha internal history list yo, but not freestyled to
the history file\&.  In case of a cold-ass lil conflict, tha straight-up original gangsta non\-zero status
value is taken\&.
.PP
A hook function may call `\fBfc \-p\fP \fI\&.\&.\&.\fP\&' ta switch tha history
context so dat tha history is saved up in a gangbangin' finger-lickin' different file from the
that up in tha global \fBHISTFILE\fP parameter\&.  This is handled specially:
the history context be automatically restored afta tha processing
of tha history line is finished\&.
.PP
Da followin example function works wit one of tha options
\fBINC_APPEND_HISTORY\fP or \fBSHARE_HISTORY\fP set, up in order dat tha line
is freestyled up immediately afta tha history entry be added\&.  It first
addz tha history line ta tha aiiight history wit tha newline stripped,
which is probably tha erect behaviour\&.  Then it switches tha history
context so dat tha line is ghon be freestyled ta a history file up in the
current directory\&.
.PP
.RS
.nf
\fBzshaddhistory() {
  print \-sr \-\- ${1%%$\&'\en'}
  fc \-p \&.zsh_local_history
}\fP
.fi
.RE
.RE
.TP
\fBzshexit\fP
Executed all up in tha point where tha main shell be bout ta exit normally\&.
This aint called by exitin subshells, nor when tha \fBexec\fP
precommand modifier is used before a external command\&.  Also, unlike
\fBTRAPEXIT\fP, it aint called when functions exit\&.
.PP
.SS "Trap Functions"
.PP
Da functions below is treated specially but aint gots corresponding
hook arrays\&.
.PP
.PD 0
.TP
.PD
\fBTRAP\fP\fINAL\fP
If defined n' non\-null,
this function is ghon be executed whenever tha shell
catches a signal \fBSIG\fP\fINAL\fP, where \fINAL\fP be a signal
name as specified fo' tha \fBkill\fP builtin\&.
Da signal number is ghon be passed as tha straight-up original gangsta parameta ta tha function\&.
.RS
.PP
If a gangbangin' function of dis form is defined n' null,
the shell n' processes spawned by it will ignore \fBSIG\fP\fINAL\fP\&.
.PP
Da return status from tha function is handled specially\&.  If it is
zero, tha signal be assumed ta done been handled, n' execution continues
normally\&.  Otherwise, tha shell will behave as interrupted except that
the return statuz of tha trap is retained\&.
.PP
Programs terminated by uncaught signals typically return tha status 128
plus tha signal number\&.  Hence tha followin causes tha handlez for
\fBSIGINT\fP ta print a message, then mimic tha usual effect of tha signal\&.
.PP
.RS
.nf
\fBTRAPINT() {
  print "Caught SIGINT, aborting\&."
  return $(( 128 + $1 ))
}\fP
.fi
.RE
.PP
Da functions \fBTRAPZERR\fP, \fBTRAPDEBUG\fP n' \fBTRAPEXIT\fP is never
executed inside other traps\&.
.RE
.TP
\fBTRAPDEBUG\fP
If tha option \fBDEBUG_BEFORE_CMD\fP is set (as it is by default), executed
before each command; otherwise executed afta each command\&.  See
the description of tha \fBtrap\fP builtin in
\fIzshbuiltins\fP(1) fo' detailz of additionizzle features provided
in debug traps\&.
.TP
\fBTRAPEXIT\fP
Executed when tha shell exits,
or when tha current function exits if defined inside a gangbangin' function\&.
Da value of \fB$?\fP all up in tha start of execution is tha exit statuz of the
shell or tha return statuz of tha function exiting\&.
.TP
\fBTRAPZERR\fP
Executed whenever a cold-ass lil command has a non\-zero exit status\&.  But fuck dat shiznit yo, tha word on tha street is dat the
function aint executed if tha command occurred up in a sublist followed by
`\fB&&\fP\&' or `\fB||\fP'; only tha final command up in a sublist of dis type
causes tha trap ta be executed\&.  Da function \fBTRAPERR\fP acts tha same ol' dirty as
\fBTRAPZERR\fP on systems where there is no \fBSIGERR\fP (this is tha usual
case)\&.
.PP
Da functions beginnin `\fBTRAP\fP\&' may alternatively be defined wit the
\fBtrap\fP builtin:  dis may be preferable fo' some uses\&.  Settin a trap
with one form removes any trap of tha other form fo' tha same signal;
removin a trap up in either form removes all traps fo' tha same signal\&.
Da forms
.PP
.RS
.nf
\fBTRAPNAL() { 
 # code
}\fP
.fi
.RE
.PP
(\&'function traps') and
.PP
.RS
.nf
\fBtrap \&'
 # code
\&' NAL\fP
.fi
.RE
.PP
(\&'list traps') is equivalent up in most ways, tha exceptions bein the
following:
.PP
.PD 0
.TP
.PD
\(bu
Function traps have all tha propertizzlez of aiiight functions,
appearin up in tha list of functions n' bein called wit they own
function context rather than tha context where tha trap was triggered\&.
.TP
\(bu
Da return status from function traps is special, whereas a return
from a list trap causes tha surroundin context ta return wit tha given
status\&.
.TP
\(bu
Function traps is not reset within subshells, up in accordizzle with
zsh behaviour; list traps is reset, up in accordizzle wit POSIX
behaviour\&.
.\" Yodl file: Zsh/jobs.yo
.SH "JOBS"
If tha \fBMONITOR\fP option is set,
an interactizzle shell associates a \fIjob\fP wit each pipeline\&.
It keeps a table of current thangs, printed by tha \fBjobs\fP
command, n' assigns dem lil' small-ass integer numbers\&.
When a thang is started asynchronously wit `\fB&\fP\&',
the shell prints a line ta standard error which looks like:
.PP
.RS
.nf
\fB[1] 1234\fP
.fi
.RE
.PP
indicatin dat tha thang which was started asynchronously was thang number
1 n' had one (top\-level) process, whose process ID was 1234\&.
.PP
If a thang is started wit `\fB&|\fP\&' or `\fB&!\fP',
then dat thang is immediately disowned\&.  Afta startup, it
does not gotz a place up in tha thang table, n' aint subject
to tha thang control features busted lyrics bout here\&.
.PP
If yo ass is hustlin a thang n' wish ta do suttin' else you may hit tha key
^Z (control\-Z) which sendz a \fBTSTP\fP signal ta tha current thang:  dis key
may be redefined by tha \fBsusp\fP option of tha external \fBstty\fP command\&.
Da shell will then normally indicate dat tha thang has been `suspended\&',
and print another prompt\&.  Yo ass can then manipulate tha state of dis thang,
puttin it up in tha background wit tha \fBbg\fP command, or run some other
commandz n' then eventually brang tha thang back tha fuck into tha foreground with
the foreground command \fBfg\fP\&.  A ^Z takes effect immediately and
is like a interrupt up in dat pendin output n' unread input is discarded
when it is typed\&.
.PP
A thang bein run up in tha background will suspend if it tries ta read
from tha terminal\&.
.PP
Note dat if tha thang hustlin up in tha foreground be a gangbangin' finger-lickin' dirty-ass shell function,
then suspendin it gonna git tha effect of causin tha shell ta fork\&.
This is necessary ta separate tha function\&z state from dat of the
parent shell struttin tha thang control, so dat tha latta can return
to tha command line prompt\&.  As a result, even if \fBfg\fP is
used ta continue tha thang tha function will no longer be part of the
parent shell, n' any variablez set by tha function aint gonna be visible
in tha parent shell\&.  Thus tha behaviour is different from tha case
where tha function was never suspended\&.  Zsh is different from many
other shells up in dis regard\&.
.PP
Da same behaviour is found when tha shell is executin code as the
right hand side of a pipeline or any complex shell construct such as
\fBif\fP, \fBfor\fP, etc\&., up in order dat tha entire block of code
can be managed as a single thang\&.
Background thangs is normally allowed ta produce output,
but dis can be disabled by givin tha command `\fBstty tostop\fP\&'\&.
If you set this
tty option, then background thangs will suspend when they try ta produce
output like they do when they try ta read input\&.
.PP
When a cold-ass lil command is suspended n' continued lata wit tha \fBfg\fP or
\fBwait\fP builtins, zsh restores tty modes dat was up in effect when it was
suspended\&.  This (intentionally) do not apply if tha command is
continued via `\fBkill \-CONT\fP\&', nor when it is continued wit \fBbg\fP\&.
.PP
There is nuff muthafuckin ways ta refer ta thangs up in tha shell\&.
A thang can be referred ta by tha process ID of any process of tha thang
or by one of tha following:
.PP
.PD 0
.TP
\fB%\fP\fInumber\fP
Da thang wit tha given number\&.
.TP
\fB%\fP\fIstring\fP
Any thang whose command line begins wit \fIstring\fP\&.
.TP
\fB%?\fP\fIstring\fP
Any thang whose command line gotz nuff \fIstring\fP\&.
.TP
\fB%%\fP
Current thang\&.
.TP
\fB%+\fP
Equivalent ta `\fB%%\fP\&'\&.
.TP
\fB%\-\fP
Previous thang\&.
.PD
.PP
Da shell learns immediately whenever a process chizzlez state\&.
It normally informs you whenever a thang becomes blocked so that
no further progress is possible\&.  If tha \fBNOTIFY\fP option aint set,
it waits until just before it prints a prompt before it informs you\&.
All such notifications is busted directly ta tha terminal, not to
the standard output or standard error\&.
.PP
When tha monitor mode is on, each background thang dat completes
triggers any trap set fo' \fBCHLD\fP\&.
.PP
When you try ta leave tha shell while thangs is hustlin or suspended, you will
be warned dat `Yo ass have suspended (running) thangs\&'\&.
Yo ass may use tha \fBjobs\fP command ta peep what tha fuck they are\&.
If you do dis or immediately try to
exit again, tha shell aint gonna warn you a second time; tha suspended
jobs is ghon be terminated, n' tha hustlin thangs is ghon be sent
a \fBSIGHUP\fP signal, if tha \fBHUP\fP option is set\&.
.PP
To avoid havin tha shell terminizzle tha hustlin thangs, either
use tha \fBnohup\fP command (see \fInohup\fP(1))
or tha \fBdisown\fP builtin\&.
.SH "SIGNALS"
Da \fBINT\fP n' \fBQUIT\fP signals fo' a invoked
command is ignored if tha command is followed by
`\fB&\fP\&' n' tha \fBMONITOR\fP option aint active\&.
Da shell itself always ignores tha \fBQUIT\fP signal\&.
Otherwise, signals have tha joints
inherited by tha shell from its parent
(but peep tha \fBTRAP\fP\fINAL\fP special functions up in tha section `Functions\&')\&.
.PP
Certain thangs is run asynchronously by tha shell other than them
explicitly put tha fuck into tha background; even up in cases where tha shell
would probably wait fo' such thangs, a explicit \fBexit\fP command
or exit cuz of tha option \fBERR_EXIT\fP will cause tha shell to
exit without waiting\&.  Examplez of such asynchronous thangs are
process substitution, see
the section PROCESS SUBSTITUTION up in tha \fIzshexpn\fP(1) manual page, n' tha handlez processes for
multios, see
the section MULTIOS up in tha \fIzshmisc\fP(1) manual page\&.
.\" Yodl file: Zsh/arith.yo
.SH "ARITHMETIC EVALUATION"
Da shell can big-ass up integer n' floatin point arithmetic, either using
the builtin \fBlet\fP, or via a substitution of tha form \fB$((\&.\&.\&.))\fP\&.  For
integers, tha shell is probably compiled ta use 8\-byte precision where this
is available, otherwise precision is 4 bytes\&.  This can be tested, for
example, by givin tha command `\fBprint \- $(( 12345678901 ))\fP\&'; if the
number appears unchanged, tha precision be at least 8 bytes\&.  Floating
point arithmetic always uses tha `double\&' type wit whatever corresponding
precision is provided by tha compila n' tha library\&.
.PP
Da \fBlet\fP builtin command takes arithmetic expressions as arguments; each
is evaluated separately\&.  Since nuff of tha arithmetic operators, as well
as spaces, require quoting, a alternatizzle form is provided: fo' any
command which begins wit a `\fB((\fP\&', all tha charactas until a
matchin `\fB))\fP\&' is treated as a quoted expression and
arithmetic expansion performed as fo' a argument of \fBlet\fP\&.  Mo'
precisely, `\fB((\fP\fI\&.\&.\&.\fP\fB))\fP\&' is equivalent to
`\fBlet "\fP\fI\&.\&.\&.\fP\fB"\fP\&'\&.  Da return status is 0 if tha arithmetic value
of tha expression is non\-zero, 1 if it is zero, n' 2 if a error occurred\&.
.PP
For example, tha followin statement
.PP
.RS
.nf
\fB(( val = 2 + 1 ))\fP
.fi
.RE
.PP
is equivalent to
.PP
.RS
.nf
\fBlet "val = 2 + 1"\fP
.fi
.RE
.PP
both assignin tha value 3 ta tha shell variable \fBval\fP n' returnin a
zero status\&.
.PP
Integers can be up in bases other than 10\&.
A leadin `\fB0x\fP\&' or `\fB0X\fP' denotes hexadecimal\&.
Integers may also be of tha form `\fIbase\fP\fB#\fP\fIn\fP\&',
where \fIbase\fP be a thugged-out decimal number between two n' thirty\-six
representin tha arithmetic base n' \fIn\fP
is a number up in dat base (for example, `\fB16#ff\fP\&' is 255 up in hexadecimal)\&.
Da \fIbase\fP\fB#\fP may also be omitted, up in which case
base 10 is used\&.  For backwardz compatibilitizzle tha form
`\fB[\fP\fIbase\fP\fB]\fP\fIn\fP\&' be also accepted\&.
.PP
An integer expression or a funky-ass base given up in tha form
`\fIbase\fP\fB#\fP\fIn\fP\&' may contain underscores (`\fB_\fP') afta the
leadin digit fo' visual guidance; these is ignored up in computation\&.
Examplez is \fB1_000_000\fP or \fB0xffff_ffff\fP which is equivalent to
\fB1000000\fP n' \fB0xffffffff\fP respectively\&.
.PP
It be also possible ta specify a funky-ass base ta be used fo' output up in tha form
`\fB[#\fP\fIbase\fP\fB]\fP\&', fo' example `\fB[#16]\fP'\&.  This is used when
outputtin arithmetical substitutions or when assignin ta scalar
parametas yo, but a explicitly defined integer or floatin point parameter
will not be affected\&.  If a integer variable is implicitly defined by an
arithmetic expression, any base specified up in dis way is ghon be set as the
variable\&z output arithmetic base as if tha option `\fB\-i\fP \fIbase\fP' to
the \fBtypeset\fP builtin had been used\&.  Da expression has no precedence
and if it occurs mo' than once up in a mathematical expression, tha last
encountered is used\&.  For claritizzle it is recommended dat it step tha fuck up at the
beginnin of a expression\&.  As a example:
.PP
.RS
.nf
\fBtypeset \-i 16 y
print $(( [#8] x = 32, y = 32 ))
print $x $y\fP
.fi
.RE
.PP
outputs first `\fB8#40\fP\&', tha rightmost value up in tha given output base, and
then `\fB8#40 16#20\fP\&', cuz \fBy\fP has been explicitly declared to
have output base 16, while \fBx\fP (assumin it do not already exist) is
implicitly typed by tha arithmetic evaluation, where it acquires tha output
base 8\&.
.PP
Da \fIbase\fP may be replaced or followed by a underscore, which may
itself be followed by a positizzle integer (if it is missin tha value 3
is used)\&.  This indicates dat underscores should be banged tha fuck into the
output string, groupin tha number fo' visual clarity\&.  Da following
integer specifies tha number of digits ta crew together\&.  For example:
.PP
.RS
.nf
\fBsetopt cbases
print $(( [#16_4] 65536 ** 2 ))\fP
.fi
.RE
.PP
outputs `\fB0x1_0000_0000\fP\&'\&.
.PP
Da feature can be used wit floating
point numbers, up in which case tha base must be omitted; grouping
is away from tha decimal point\&.  For example,
.PP
.RS
.nf
\fBzmodload zsh/mathfunc
print $(( [#_] sqrt(1e7) ))\fP
.fi
.RE
.PP
outputs `\fB3_162\&.277_660_168_379_5\fP\&' (the number of decimal places
shown may vary)\&.
.PP
If tha \fBC_BASES\fP option is set, hexadecimal numbers up in tha standard C
format, fo' example \fB0xFF\fP instead of tha usual `\fB16#FF\fP\&'\&.  If the
option \fBOCTAL_ZEROES\fP be also set (it aint by default), octal numbers
will be treated similarly n' hence step tha fuck up as `\fB077\fP\&' instead of
`\fB8#77\fP\&'\&.  This option has no effect on tha output of bases other than
hexadecimal n' octal, n' these formats is always understood on input\&.
.PP
When a output base is specified rockin tha `\fB[#\fP\fIbase\fP\fB]\fP\&' syntax,
an appropriate base prefix is ghon be output if necessary, so dat tha value
output is valid syntax fo' input\&.  If tha \fB#\fP is doubled, fo' example
`\fB[##16]\fP\&', then no base prefix is output\&.
.PP
Floatin point constants is recognized by tha presence of a thugged-out decimal point
or a exponent\&.  Da decimal point may be tha straight-up original gangsta characta of the
constant yo, but tha exponent characta \fBe\fP or \fBE\fP may not, as it will be
taken fo' a parameta name\&.  All numeric parts (before n' afta the
decimal point n' up in tha exponent) may contain underscores afta the
leadin digit fo' visual guidance; these is ignored up in computation\&.
.PP
An arithmetic expression uses nearly tha same syntax and
associativitizzle of expressions as up in C\&.
.PP
In tha natizzle mode of operation, tha followin operators is supported
(listed up in decreasin order of precedence):
.PP
.PD 0
.TP
\fB+ \- ! ~ ++ \-\-\fP
unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
.TP
\fB<< >>\fP
bitwise shift left, right
.TP
\fB&\fP
bitwise AND
.TP
\fB^\fP
bitwise XOR
.TP
\fB|\fP
bitwise OR
.TP
\fB**\fP
exponentiation
.TP
\fB* / %\fP
multiplication, division, modulus (remainder)
.TP
\fB+ \-\fP
addition, subtraction
.TP
\fB< > <= >=\fP
comparison
.TP
\fB== !=\fP
equalitizzle n' inequality
.TP
\fB&&\fP
logical AND
.TP
\fB|| ^^\fP
logical OR, XOR
.TP
\fB, biatch? :\fP
ternary operator
.TP
\fB= += \-= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=\fP
assignment
.TP
\fB,\fP
comma operator
.PD
.PP
Da operators `\fB&&\fP\&', `\fB||\fP', `\fB&&=\fP', n' `\fB||=\fP' are
short\-circuiting, n' only one of tha latta two expressions up in a ternary
operator is evaluated\&.  Note tha precedence of tha bitwise AND, OR,
and XOR operators\&.
.PP
With tha option \fBC_PRECEDENCES\fP tha precedences (but no other
properties) of tha operators is altered ta be tha same as dem in
most other languages dat support tha relevant operators:
.PP
.PD 0
.TP
\fB+ \- ! ~ ++ \-\-\fP
unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
.TP
\fB**\fP
exponentiation
.TP
\fB* / %\fP
multiplication, division, modulus (remainder)
.TP
\fB+ \-\fP
addition, subtraction
.TP
\fB<< >>\fP
bitwise shift left, right
.TP
\fB< > <= >=\fP
comparison
.TP
\fB== !=\fP
equalitizzle n' inequality
.TP
\fB&\fP
bitwise AND
.TP
\fB^\fP
bitwise XOR
.TP
\fB|\fP
bitwise OR
.TP
\fB&&\fP
logical AND
.TP
\fB^^\fP
logical XOR
.TP
\fB||\fP
logical OR
.TP
\fB, biatch? :\fP
ternary operator
.TP
\fB= += \-= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=\fP
assignment
.TP
\fB,\fP
comma operator
.PD
.PP
Note tha precedence of exponentiation up in both cases is below
that of unary operators, hence `\fB\-3**2\fP\&' evaluates as `\fB9\fP', not
\fB\-9\fP\&.  Use parentheses where necessary: `\fB\-(3**2)\fP\&'\&.  This is
for compatibilitizzle wit other shells\&.
.PP
Mathematical functions can be called wit tha syntax
`\fIfunc\fP\fB(\fP\fIargs\fP\fB)\fP\&', where tha function decides
if tha \fIargs\fP is used as a strang or a cold-ass lil comma\-separated list of
arithmetic expressions\&. Da shell currently defines no mathematical
functions by default yo, but tha module \fBzsh/mathfunc\fP may be loaded with
the \fBzmodload\fP builtin ta provide standard floatin point mathematical
functions\&.
.PP
An expression of tha form `\fB##\fP\fIx\fP\&' where \fIx\fP be any character
sequence like fuckin `\fBa\fP\&', `\fB^A\fP', or `\fB\eM\-\eC\-x\fP' gives tha value of
this characta n' a expression of tha form `\fB#\fP\fIfoo\fP\&' gives the
value of tha straight-up original gangsta characta of tha contentz of tha parameta \fIfoo\fP\&.
Characta joints is accordin ta tha characta set used up in tha current
locale; fo' multibyte characta handlin tha option \fBMULTIBYTE\fP must be
set\&.  Note dat dis form is different from `\fB$#\fP\fIfoo\fP\&', a standard
parameta substitution which gives tha length of tha parameta \fIfoo\fP\&.
`\fB#\e\fP\&' be accepted instead of `\fB##\fP' yo, but its use is deprecated\&.
.PP
Named parametas n' subscripted arrays can be referenced by name within an
arithmetic expression without rockin tha parameta expansion syntax\&.  For
example,
.PP
.RS
.nf
\fB((val2 = val1 * 2))\fP
.fi
.RE
.PP
assigns twice tha value of \fB$val1\fP ta tha parameta named \fBval2\fP\&.
.PP
An internal integer representation of a named parameter
can be specified wit tha \fBinteger\fP builtin\&.
Arithmetic evaluation is performed on tha value of each
assignment ta a named parameta declared integer
in dis manner\&.  Assignin a gangbangin' floatin point number ta a integer thangs up in dis biatch in
roundin down ta tha next integer\&.
.PP
Likewise, floatin point numbers can be declared wit tha \fBfloat\fP
builtin; there be two types, differin only up in they output format, as
busted lyrics bout fo' tha \fBtypeset\fP builtin\&.  Da output format can be bypassed
by rockin arithmetic substitution instead of tha parameta substitution,
i\&.e\&. `\fB${\fP\fIfloat\fP\fB}\fP\&' uses tha defined format yo, but
`\fB$((\fP\fIfloat\fP\fB))\fP\&' uses a generic floatin point
format\&.
.PP
Promotion of integer ta floatin point joints is performed where
necessary\&.  In addition, if any operator which requires a integer
(`\fB~\fP\&', `\fB&\fP', `\fB|\fP', `\fB^\fP', `\fB%\fP', `\fB<<\fP', `\fB>>\fP' n' their
equivalents wit assignment) is given a gangbangin' floatin point argument, it will be
silently rounded down ta tha next integer\&.
.PP
Scalar variablez can hold integer or floatin point joints at different
times; there is no memory of tha numeric type up in dis case\&.
.PP
If a variable is first assigned up in a numeric context without previously
bein declared, it is ghon be implicitly typed as \fBinteger\fP or \fBfloat\fP and
retain dat type either until tha type is explicitly chizzled or until the
end of tha scope\&.  This can have unforeseen consequences\&.  For example, in
the loop
.PP
.RS
.nf
\fBfor (( f = 0; f < 1; f += 0\&.1 )); do
# use $f
done\fP
.fi
.RE
.PP
if \fBf\fP has not already been declared, tha straight-up original gangsta assignment will cause it
to be pimped as a integer, n' consequently tha operation `\fBf += 0\&.1\fP\&'
will always cause tha result ta be truncated ta zero, so dat tha loop will
fail\&.  A simple fix would be ta turn tha initialization tha fuck into `\fBf = 0\&.0\fP\&'\&.
It be therefore dopest ta declare numeric variablez wit explicit types\&.
.\" Yodl file: Zsh/cond.yo
.SH "CONDITIONAL EXPRESSIONS"
A \fIconditionizzle expression\fP is used wit tha \fB[[\fP
compound command ta test attributez of filez n' ta compare strings\&.
Each expression can be constructed from one or more
of tha followin unary or binary expressions:
.PP
.PD 0
.TP
.PD
\fB\-a\fP \fIfile\fP
true if \fIfile\fP exists\&.
.TP
\fB\-b\fP \fIfile\fP
true if \fIfile\fP exists n' be a funky-ass block special file\&.
.TP
\fB\-c\fP \fIfile\fP
true if \fIfile\fP exists n' be a cold-ass lil characta special file\&.
.TP
\fB\-d\fP \fIfile\fP
true if \fIfile\fP exists n' be a gangbangin' finger-lickin' directory\&.
.TP
\fB\-e\fP \fIfile\fP
true if \fIfile\fP exists\&.
.TP
\fB\-f\fP \fIfile\fP
true if \fIfile\fP exists n' be a regular file\&.
.TP
\fB\-g\fP \fIfile\fP
true if \fIfile\fP exists n' has its setgid bit set\&.
.TP
\fB\-h\fP \fIfile\fP
true if \fIfile\fP exists n' be a symbolic link\&.
.TP
\fB\-k\fP \fIfile\fP
true if \fIfile\fP exists n' has its sticky bit set\&.
.TP
\fB\-n\fP \fIstring\fP
true if length of \fIstring\fP is non\-zero\&.
.TP
\fB\-o\fP \fIoption\fP
true if option named \fIoption\fP is on\&.  \fIoption\fP
may be a single character, up in which case it aint nuthin but a single letta option name\&.
(See tha section `Specifyin Options\&'\&.)
.TP
\fB\-p\fP \fIfile\fP
true if \fIfile\fP exists n' be a FIFO special file (named pipe)\&.
.TP
\fB\-r\fP \fIfile\fP
true if \fIfile\fP exists n' is readable by current process\&.
.TP
\fB\-s\fP \fIfile\fP
true if \fIfile\fP exists n' has size pimped outa than zero\&.
.TP
\fB\-t\fP \fIfd\fP
true if file descriptor number \fIfd\fP
is open n' associated wit a terminal device\&.
(note: \fIfd\fP aint optional)
.TP
\fB\-u\fP \fIfile\fP
true if \fIfile\fP exists n' has its setuid bit set\&.
.TP
\fB\-w\fP \fIfile\fP
true if \fIfile\fP exists n' is writable by current process\&.
.TP
\fB\-x\fP \fIfile\fP
true if \fIfile\fP exists n' is executable by current process\&.
If \fIfile\fP exists n' be a gangbangin' finger-lickin' directory, then tha current process
has permission ta search up in tha directory\&.
.TP
\fB\-z\fP \fIstring\fP
true if length of \fIstring\fP is zero\&.
.TP
\fB\-L\fP \fIfile\fP
true if \fIfile\fP exists n' be a symbolic link\&.
.TP
\fB\-O\fP \fIfile\fP
true if \fIfile\fP exists n' is owned by tha effectizzle user ID of dis process\&.
.TP
\fB\-G\fP \fIfile\fP
true if \fIfile\fP exists n' its crew matches
the effectizzle crew ID of dis process\&.
.TP
\fB\-S\fP \fIfile\fP
true if \fIfile\fP exists n' be a socket\&.
.TP
\fB\-N\fP \fIfile\fP
true if \fIfile\fP exists n' its access time is
not newer than its modification time\&.
.TP
\fIfile1\fP \fB\-nt\fP \fIfile2\fP
true if \fIfile1\fP exists n' is newer than \fIfile2\fP\&.
.TP
\fIfile1\fP \fB\-ot\fP \fIfile2\fP
true if \fIfile1\fP exists n' is olda than \fIfile2\fP\&.
.TP
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
true if \fIfile1\fP n' \fIfile2\fP exist n' refer ta tha same file\&.
.TP
.PD 0
\fIstring\fP \fB=\fP \fIpattern\fP
.TP
.PD
\fIstring\fP \fB==\fP \fIpattern\fP
true if \fIstring\fP matches \fIpattern\fP\&.
Da `\fB==\fP\&' form is tha preferred one\&.  Da `\fB=\fP' form is for
backward compatibilitizzle n' should be considered obsolete\&.
.TP
\fIstring\fP \fB!=\fP \fIpattern\fP
true if \fIstring\fP do not match \fIpattern\fP\&.
.TP
\fIstring\fP \fB=~\fP \fIregexp\fP
true if \fIstring\fP matches tha regular expression
\fIregexp\fP\&.  If tha option \fBRE_MATCH_PCRE\fP is set
\fIregexp\fP is tested as a PCRE regular expression using
the \fBzsh/pcre\fP module, else it is tested as a POSIX
extended regular expression rockin tha \fBzsh/regex\fP module\&.
Upon successful match, some variablez is ghon be updated; no variables
are chizzled if tha matchin fails\&.
.RS
.PP
If tha option \fBBASH_REMATCH\fP aint set tha scalar parameter
\fBMATCH\fP is set ta tha substrin dat matched tha pattern and
the integer parametas \fBMBEGIN\fP n' \fBMEND\fP ta tha index of tha start
and end, respectively, of tha match up in \fIstring\fP, such dat if
\fIstring\fP is contained up in variable \fBvar\fP tha expression
`${var[$MBEGIN,$MEND]}\&' is identical ta `$MATCH'\&.  Da setting
of tha option \fBKSH_ARRAYS\fP is bigged up\&.  Likewise, tha array
\fBmatch\fP is set ta tha substrings dat matched parenthesised
subexpressions n' tha arrays \fBmbegin\fP n' \fBmend\fP ta tha indices of
the start n' end positions, respectively, of tha substrings within
\fIstring\fP\&.  Da arrays is not set if there was no parenthesised
subexpresssions\&.  For example, if tha strang `\fBa short string\fP\&' is matched
against tha regular expression `\fBs(\&.\&.\&.)t\fP\&', then (assumin the
option \fBKSH_ARRAYS\fP aint set) \fBMATCH\fP, \fBMBEGIN\fP
and \fBMEND\fP is `\fBshort\fP\&', 3 n' 7, respectively, while \fBmatch\fP,
\fBmbegin\fP n' \fBmend\fP is single entry arrays containing
the strings `\fBhor\fP\&', `\fB4\fP' n' `\fB6\fP, respectively\&.
.PP
If tha option \fBBASH_REMATCH\fP is set tha array
\fBBASH_REMATCH\fP is set ta tha substrin dat matched tha pattern
followed by tha substrings dat matched parenthesised
subexpressions within tha pattern\&.
.RE
.TP
\fIstring1\fP \fB<\fP \fIstring2\fP
true if \fIstring1\fP comes before \fIstring2\fP
based on ASCII value of they characters\&.
.TP
\fIstring1\fP \fB>\fP \fIstring2\fP
true if \fIstring1\fP comes afta \fIstring2\fP
based on ASCII value of they characters\&.
.TP
\fIexp1\fP \fB\-eq\fP \fIexp2\fP
true if \fIexp1\fP is numerically equal ta \fIexp2\fP\&.
Note dat fo' purely numeric comparisons use of the
\fB((\fP\fI\&.\&.\&.\fP\fB))\fP builtin busted lyrics bout in
the section `ARITHMETIC EVALUATION\&' is mo' convenient than
conditionizzle expressions\&.
.TP
\fIexp1\fP \fB\-ne\fP \fIexp2\fP
true if \fIexp1\fP is numerically not equal ta \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-lt\fP \fIexp2\fP
true if \fIexp1\fP is numerically less than \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-gt\fP \fIexp2\fP
true if \fIexp1\fP is numerically pimped outa than \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-le\fP \fIexp2\fP
true if \fIexp1\fP is numerically less than or equal ta \fIexp2\fP\&.
.TP
\fIexp1\fP \fB\-ge\fP \fIexp2\fP
true if \fIexp1\fP is numerically pimped outa than or equal ta \fIexp2\fP\&.
.TP
\fB(\fP \fIexp\fP \fB)\fP
true if \fIexp\fP is true\&.
.TP
\fB!\fP \fIexp\fP
true if \fIexp\fP is false\&.
.TP
\fIexp1\fP \fB&&\fP \fIexp2\fP
true if \fIexp1\fP n' \fIexp2\fP is both true\&.
.TP
\fIexp1\fP \fB||\fP \fIexp2\fP
true if either \fIexp1\fP or \fIexp2\fP is true\&.
.PP
For compatibility, if there be a single argument dat is not
syntactically significant, typically a variable, tha condizzle is
treated as a test fo' whether tha expression expandz as a strang of
non\-zero length\&.  In other lyrics, \fB[[ $var ]]\fP is tha same ol' dirty as \fB[[ \-n
$var ]]\fP\&.  It be recommended dat tha second, explicit, form be used
where possible\&.
.PP
Normal shell expansion is performed on tha \fIfile\fP, \fIstring\fP and
\fIpattern\fP arguments yo, but tha result of each expansion is constrained to
be a single word, similar ta tha effect of double quotes\&.
.PP
Filename generation aint performed on any form of argument to
conditions\&.  But fuck dat shiznit yo, tha word on tha street is dat it can be forced up in any case where aiiight shell
expansion is valid n' when tha option \fBEXTENDED_GLOB\fP is up in effect by
usin a explicit glob qualifier of tha form \fB(#q)\fP at the
end of tha string\&.  A aiiight glob qualifier expression may appear
between tha `\fBq\fP\&' n' tha closin parenthesis; if none appears the
expression has no effect beyond causin filename generation\&.  The
resultz of filename generation is joined together ta form a single
word, as wit tha thangs up in dis biatch of other formz of expansion\&.
.PP
This special use of filename generation is only available wit the
\fB[[\fP syntax\&.  If tha condizzle occurs within tha \fB[\fP or \fBtest\fP
builtin commandz then globbin occurs instead as part of aiiight command
line expansion before tha condizzle is evaluated\&.  In dis case it may
generate multiple lyrics which is likely ta confuse tha syntax of the
test command\&.
.PP
For example,
.PP
\fB[[ \-n file*(#qN) ]]\fP
.PP
produces status zero if n' only if there be at least one file up in the
current directory beginnin wit tha strang `\fBfile\fP\&'\&.  Da globbing
qualifier \fBN\fP ensures dat tha expression is empty if there is
no matchin file\&.
.PP
Pattern metacharactas is actizzle fo' tha \fIpattern\fP arguments;
the patterns is tha same as dem used fo' filename generation, see
\fIzshexpn\fP(1) yo, but there is no special behaviour
of `\fB/\fP\&' nor initial dots, n' no glob qualifiers is allowed\&.
.PP
In each of tha above expressions, if
\fIfile\fP iz of tha form `\fB/dev/fd/\fP\fIn\fP\&',
where \fIn\fP be a integer,
then tha test applied ta tha open file whose
descriptor number is \fIn\fP,
even if tha underlyin system do not support
the \fB/dev/fd\fP directory\&.
.PP
In tha forms which do numeric comparison, tha expressions \fIexp\fP
undergo arithmetic expansion as if they was enclosed up in \fB$((\&.\&.\&.))\fP\&.
.PP
For example, tha following:
.PP
.RS
.nf
\fB[[ ( \-f foo || \-f bar ) && $report = y* ]] && print File exists\&.\fP
.fi
.RE
.PP
tests if either file \fBfoo\fP or file \fBbar\fP exists, n' if so, if the
value of tha parameta \fBreport\fP begins wit `\fBy\fP\&'; if tha complete
condizzle is true, tha message `\fBFile exists\&.\fP\&' is printed\&.
.\" Yodl file: Zsh/prompt.yo
.SH "EXPANSION OF PROMPT SEQUENCES"
Prompt sequences undergo a special form of expansion\&.  This type of expansion
is also available rockin tha \fB\-P\fP option ta tha \fBprint\fP builtin\&.
.PP
If tha \fBPROMPT_SUBST\fP option is set, tha prompt strang is first subjected to
\fIparameta expansion\fP,
\fIcommand substitution\fP and
\fIarithmetic expansion\fP\&.
See
\fIzshexpn\fP(1)\&.

Certain escape sequences may be recognised up in tha prompt string\&.
.PP
If tha \fBPROMPT_BANG\fP option is set, a `\fB!\fP\&' up in tha prompt is replaced
by tha current history event number\&.  A literal `\fB!\fP\&' may then be
represented as `\fB!!\fP\&'\&.
.PP
If tha \fBPROMPT_PERCENT\fP option is set, certain escape sequences that
start wit `\fB%\fP\&' is expanded\&.
Many escapes is followed by a single character, although a shitload of these
take a optionizzle integer argument that
should step tha fuck up between tha `\fB%\fP\&' n' tha next characta of the
sequence\&.  Mo' fucked up escape sequences is available ta provide
conditionizzle expansion\&.
.PP
.SH "SIMPLE PROMPT ESCAPES"
.PP
.SS "Special characters"
.PD 0
.TP
.PD
\fB%%\fP
A `\fB%\fP\&'\&.
.TP
\fB%)\fP
A `\fB)\fP\&'\&.
.PP
.SS "Login shiznit"
.PD 0
.TP
.PD
\fB%l\fP
Da line (tty) tha user is logged up in on, without `\fB/dev/\fP\&' prefix\&.
If tha name starts wit `\fB/dev/tty\fP\&', dat prefix is stripped\&.
.TP
\fB%M\fP
Da full machine hostname\&.
.TP
\fB%m\fP
Da hostname up ta tha straight-up original gangsta `\fB\&.\fP\&'\&.
An integer may follow tha `\fB%\fP\&' ta specify
how nuff componentz of tha hostname is desired\&.  With a wack integer,
trailin componentz of tha hostname is shown\&.
.TP
\fB%n\fP
\fB$USERNAME\fP\&.
.TP
\fB%y\fP
Da line (tty) tha user is logged up in on, without `\fB/dev/\fP\&' prefix\&.
This do not treat `\fB/dev/tty\fP\&' names specially\&.
.PP
.SS "Shell state"
.PD 0
.TP
.PD
\fB%#\fP
A `\fB#\fP\&' if tha shell is hustlin wit privileges, a `\fB%\fP' if not\&.
Equivalent ta `\fB%(!\&.#\&.%%)\fP\&'\&.
Da definizzle of `privileged\&', fo' these purposes, is dat either the
effectizzle user ID is zero, or, if POSIX\&.1e capabilitizzles is supported, that
at least one capabilitizzle is raised up in either tha Effectizzle or Inheritable
capabilitizzle vectors\&.
.TP
\fB%?\fP
Da return statuz of tha last command executed just before tha prompt\&.
.TP
\fB%_\fP
Da statuz of tha parser, i\&.e\&. tha shell constructs (like `\fBif\fP\&' and
`\fBfor\fP\&') dat done been started on tha command line\&. If given a integer
number dat nuff strings is ghon be printed; zero or wack or no integer means
print as nuff as there are\&.  This is most useful up in prompts \fBPS2\fP for
continuation lines n' \fBPS4\fP fo' debuggin wit tha \fBXTRACE\fP option; in
the latta case it will also work non\-interactively\&.
.TP
.PD 0
\fB%d\fP
.TP
.PD
\fB/\fP
Current hustlin directory\&.  If a integer bigs up tha `\fB%\fP\&',
it specifies a fuckin shitload of trailin componentz of tha current working
directory ta show; zero means tha whole path\&.  A wack integer
specifies leadin components, i\&.e\&. \fB%\-1d\fP specifies tha straight-up original gangsta component\&.
.TP
\fB%~\fP
As \fB%d\fP n' \fB%/\fP yo, but if tha current hustlin directory starts with
\fB$HOME\fP, dat part is replaced by a `\fB~\fP\&'\&. Furthermore, if it has a named
directory as its prefix, dat part is replaced by a `\fB~\fP\&' followed by
the name of tha directory yo, but only if tha result is shorta than
the full path; 
see \fIDynamic\fP n' \fIStatic named directories\fP up in \fIzshexpn\fP(1)\&.
.TP
\fB%e\fP
Evaluation depth of tha current sourced file, shell function, or \fBeval\fP\&.
This is incremented or decremented every last muthafuckin time tha value of \fB%N\fP is
set or reverted ta a previous value, respectively\&.  This is most useful
for debuggin as part of \fB$PS4\fP\&.
.TP
.PD 0
\fB%h\fP
.TP
.PD
\fB%!\fP
Current history event number\&.
.TP
\fB%i\fP
Da line number currently bein executed up in tha script, sourced file, or
shell function given by \fB%N\fP\&.  This is most useful fo' debuggin as part
of \fB$PS4\fP\&.
.TP
\fB%I\fP
Da line number currently bein executed up in tha file \fB%x\fP\&.  This is
similar ta \fB%i\fP yo, but tha line number be always a line number up in the
file where tha code was defined, even if tha code be a gangbangin' finger-lickin' dirty-ass shell function\&.
.TP
\fB%j\fP
Da number of thangs\&.
.TP
\fB%L\fP
Da current value of \fB$SHLVL\fP\&.
.TP
\fB%N\fP
Da name of tha script, sourced file, or shell function dat zsh is
currently executing, whichever was started most recently\&.  If there is
none, dis is equivalent ta tha parameta \fB$0\fP\&.  An integer may follow
the `\fB%\fP\&' ta specify a fuckin shitload of trailin path components ta show; zero
means tha full path\&.  A wack integer specifies leadin components\&.
.TP
\fB%x\fP
Da name of tha file containin tha source code currently being
executed\&.  This behaves as \fB%N\fP except dat function n' eval command
names is not shown, instead tha file where they was defined\&.
.TP
.PD 0
\fB%c\fP
.TP
.PD 0
\fB%\&.\fP
.TP
.PD
\fB%C\fP
Trailin component of tha current hustlin directory\&.
An integer may follow tha `\fB%\fP\&' ta git mo' than one component\&.
Unless `\fB%C\fP\&' is used, tilde contraction is performed first\&.  These are
deprecated as \fB%c\fP n' \fB%C\fP is equivalent ta \fB%1~\fP n' \fB%1/\fP,
respectively, while explicit positizzle integers have tha same effect as for
the latta two sequences\&.
.PP
.SS "Date n' time"
.PD 0
.TP
.PD
\fB%D\fP
Da date up in \fIyy\fP\fB\-\fP\fImm\fP\fB\-\fP\fIdd\fP format\&.
.TP
\fB%T\fP
Current time of day, up in 24\-hour format\&.
.TP
.PD 0
\fB%t\fP
.TP
.PD
\fB%@\fP
Current time of day, up in 12\-hour, am/pm format\&.
.TP
\fB%*\fP
Current time of dizzle up in 24\-hour format, wit seconds\&.
.TP
\fB%w\fP
Da date up in \fIday\fP\fB\-\fP\fIdd\fP format\&.
.TP
\fB%W\fP
Da date up in \fImm\fP\fB/\fP\fIdd\fP\fB/\fP\fIyy\fP format\&.
.TP
\fB%D{\fP\fIstring\fP\fB}\fP
\fIstring\fP is formatted rockin tha \fBstrftime\fP function\&.
See \fIstrftime\fP(3) fo' mo' details\&.  Various zsh
extensions provide numbers wit no leadin zero or space
if tha number be a single digit:
.RS
.PP
.PD 0
.TP
\fB%f\fP
a dizzle of tha month
.TP
\fB%K\fP
the minute of tha dizzle on tha 24\-hour clock
.TP
\fB%L\fP
the minute of tha dizzle on tha 12\-hour clock
.PD
.PP
In addition, if tha system supports tha POSIX \fBgettimeofday\fP system
call, \fB%\&.\fP serves up decimal fractionz of a second since tha epoch with
leadin zeroes\&.  By default three decimal places is provided yo, but a
number of digits up ta 6 may be given followin tha \fB%\fP; hence \fB%6\&.\fP
outputs microseconds\&.  A typical example of dis is tha format
`\fB%D{%H:%M:%S\&.%\&.}\fP\&'\&.
.PP
Da GNU extension dat a `\fB\-\fP\&' between tha \fB%\fP n' the
format characta causes a leadin zero or space ta be stripped
is handled directly by tha shell fo' tha format charactas \fBd\fP, \fBf\fP,
\fBH\fP, \fBk\fP, \fBl\fP, \fBm\fP, \fBM\fP, \fBS\fP n' \fBy\fP; any other format
charactas is provided ta \fBstrftime()\fP wit any leadin `\fB\-\fP\&',
present, so tha handlin is system dependent\&.  Further GNU
extensions is not supported at present\&.
.RE
.PP
.SS "Visual effects"
.PD 0
.TP
.PD
\fB%B\fP (\fB%b\fP)
Start (stop) boldface mode\&.
.TP
\fB%E\fP
Clear ta end of line\&.
.TP
\fB%U\fP (\fB%u\fP)
Start (stop) underline mode\&.
.TP
\fB%S\fP (\fB%s\fP)
Start (stop) standout mode\&.
.TP
\fB%F\fP (\fB%f\fP)
Start (stop) rockin a gangbangin' finger-lickin' different foreground colour, if supported
by tha terminal\&.  Da colour may be specified two ways: either
as a numeric argument, as normal, or by a sequence up in braces
followin tha \fB%F\fP, fo' example \fB%F{red}\fP\&.  In tha latta case
the joints allowed is as busted lyrics bout fo' tha \fBfg\fP \fBzle_highlight\fP
attribute;
see \fICharacta Highlighting\fP up in \fIzshzle\fP(1)\&.  This means dat numeric
colours is allowed up in tha second format also\&.
.TP
\fB%K\fP (\fB%k\fP)
Start (stop) rockin a gangbangin' finger-lickin' different bacKground colour\&.  Da syntax is
identical ta dat fo' \fB%F\fP n' \fB%f\fP\&.
.TP
\fB%{\fP\&.\&.\&.\fB%}\fP
Include a strang as a literal escape sequence\&.
Da strang within tha braces should not chizzle tha cursor
position\&.  Brace pairs can nest\&.
.RS
.PP
A positizzle numeric argument between tha \fB%\fP n' tha \fB{\fP is treated as
busted lyrics bout fo' \fB%G\fP below\&.
.RE
.TP
\fB%G\fP
Within a \fB%{\fP\&.\&.\&.\fB%}\fP sequence, include a `glitch\&': dat is, assume
that a single characta width is ghon be output\&.  This is useful when
outputtin charactas dat otherwise cannot be erectly handled by the
shell, like fuckin tha alternate characta set on some terminals\&.
Da charactas up in question can be included within a \fB%{\fP\&.\&.\&.\fB%}\fP
sequence together wit tha appropriate number of \fB%G\fP sequences to
indicate tha erect width\&.  An integer between tha `\fB%\fP\&' n' `\fBG\fP'
indicates a cold-ass lil characta width other than one\&.  Hence \fB%{\fP\fIseq\fP\fB%2G%}\fP
outputs \fIseq\fP n' assumes it takes up tha width of two standard
characters\&.
.RS
.PP
Multiple usez of \fB%G\fP accumulate up in tha obvious fashion; tha position
of tha \fB%G\fP is unimportant\&.  Negatizzle integers is not handled\&.
.PP
Note dat when prompt truncation is up in use it be advisable ta divide up
output tha fuck into single charactas within each \fB%{\fP\&.\&.\&.\fB%}\fP crew so that
the erect truncation point can be found\&.
.RE
.PP
.SH "CONDITIONAL SUBSTRINGS IN PROMPTS"
.PD 0
.TP
.PD
\fB%v\fP
Da value of tha straight-up original gangsta element of tha \fBpsvar\fP array parameter\&.  Peepin
the `\fB%\fP\&' wit a integer gives dat element of tha array\&.  Negative
integers count from tha end of tha array\&.
.TP
\fB%(\fP\fIx\&.true\-text\&.false\-text\fP\fB)\fP
Specifies a ternary expression\&.  Da characta followin tha \fIx\fP is
arbitrary; tha same characta is used ta separate tha text fo' the
`true\&' result from dat fo' tha `false' result\&.
This separator may not step tha fuck up in tha \fItrue\-text\fP, except as part of a
%\-escape
sequence\&.  A `\fB)\fP\&' may step tha fuck up in tha \fIfalse\-text\fP as `\fB%)\fP'\&.
\fItrue\-text\fP
and \fIfalse\-text\fP may both contain arbitrarily\-nested escape
sequences, includin further ternary expressions\&.
.RS
.PP
Da left parenthesis may be preceded or followed by a positizzle integer \fIn\fP,
which defaults ta zero\&.  A wack integer is ghon be multiplied by \-1, except
as noted below fo' `\fBl\fP\&'\&.
Da test characta \fIx\fP may be any of tha following:
.PP
.PD 0
.TP
\fB!\fP
True if tha shell is hustlin wit privileges\&.
.TP
\fB#\fP
True if tha effectizzle uid of tha current process is \fIn\fP\&.
.TP
\fB?\fP
True if tha exit statuz of tha last command was \fIn\fP\&.
.TP
\fB_\fP
True if at least \fIn\fP shell constructs was started\&.
.TP
\fBC\fP
.TP
\fB/\fP
True if tha current absolute path has at least \fIn\fP elements
relatizzle ta tha root directory, hence \fB/\fP is counted as 0 elements\&.
.TP
\fBc\fP
.TP
\fB\&.\fP
.TP
\fB~\fP
True if tha current path, wit prefix replacement, has at
least \fIn\fP elements relatizzle ta tha root directory, hence \fB/\fP is
counted as 0 elements\&.
.TP
\fBD\fP
True if tha month is equal ta \fIn\fP (January = 0)\&.
.TP
\fBd\fP
True if tha dizzle of tha month is equal ta \fIn\fP\&.
.TP
\fBe\fP
True if tha evaluation depth be at least \fIn\fP\&.
.TP
\fBg\fP
True if tha effectizzle gid of tha current process is \fIn\fP\&.
.TP
\fBj\fP
True if tha number of thangs be at least \fIn\fP\&.
.TP
\fBL\fP
True if tha \fBSHLVL\fP parameta be at least \fIn\fP\&.
.TP
\fBl\fP
True if at least \fIn\fP charactas have already been
printed on tha current line\&.  When \fIn\fP is negative, legit if at least
\fBabs\fP\fB(\fP\fIn\fP\fB)\fP charactas remain before tha opposite
margin (thus tha left margin fo' \fBRPROMPT\fP)\&.
.TP
\fBS\fP
True if tha \fBSECONDS\fP parameta be at least \fIn\fP\&.
.TP
\fBT\fP
True if tha time up in minutes is equal ta \fIn\fP\&.
.TP
\fBt\fP
True if tha time up in minutes is equal ta \fIn\fP\&.
.TP
\fBv\fP
True if tha array \fBpsvar\fP has at least \fIn\fP elements\&.
.TP
\fBV\fP
True if element \fIn\fP of tha array \fBpsvar\fP is set and
non\-empty\&.
.TP
\fBw\fP
True if tha dizzle of tha week is equal ta \fIn\fP (Sundizzle = 0)\&.
.PD
.RE
.TP
.PD 0
\fB%<\fP\fIstring\fP\fB<\fP
.TP
.PD 0
\fB%>\fP\fIstring\fP\fB>\fP
.TP
.PD
\fB%[\fP\fIxstring\fP\fB]\fP
Specifies truncation behaviour fo' tha remainder of tha prompt string\&.
Da third, deprecated, form is equivalent ta `\fB%\fP\fIxstringx\fP\&',
i\&.e\&. \fIx\fP may be `\fB<\fP\&' or `\fB>\fP'\&.
Da \fIstring\fP is ghon be displayed in
place of tha truncated portion of any string; note dis do not
undergo prompt expansion\&.
.RS
.PP
Da numeric argument, which up in tha third form may step tha fuck up immediately
afta tha `\fB[\fP\&', specifies tha maximum permitted length of
the various strings dat can be displayed up in tha prompt\&.
In tha straight-up original gangsta two forms, dis numeric argument may be negative, up in which
case tha truncation length is determined by subtractin tha absolute
value of tha numeric argument from tha number of characta positions
remainin on tha current prompt line\&.  If dis thangs up in dis biatch up in a zero or
negatizzle length, a length of 1 is used\&.  In other lyrics, a negative
argument arranges dat afta truncation at least \fIn\fP characters
remain before tha right margin (left margin fo' \fBRPROMPT\fP)\&.
.PP
Da forms wit `\fB<\fP\&' truncate all up in tha left of tha string,
and tha forms wit `\fB>\fP\&' truncate all up in tha right of tha string\&.
For example, if tha current directory is `\fB/home/pike\fP\&',
the prompt `\fB%8<\&.\&.<%/\fP\&' will expand ta `\fB\&.\&.e/pike\fP'\&.
In dis string, tha terminatin characta (`\fB<\fP\&', `\fB>\fP' or `\fB]\fP'),
or up in fact any character, may be quoted by a precedin `\fB\e\fP\&'; note
when rockin \fBprint \-P\fP, however, dat dis must be doubled as the
strin be also subject ta standard \fBprint\fP processing, up in addition
to any backslashes removed by a thugged-out double quoted string:  da most thugged-out shitty case
is therefore `\fBprint \-P "%<\e\e\e\e<<\&.\&.\&."\fP\&'\&.
.PP
If tha \fIstring\fP is longer than tha specified truncation length,
it will step tha fuck up in full, straight-up replacin tha truncated string\&.
.PP
Da part of tha prompt strang ta be truncated runs ta tha end of the
string, or ta tha end of tha next enclosin crew of tha `\fB%(\fP\&'
construct, or ta tha next truncation encountered all up in tha same grouping
level (i\&.e\&. truncations inside a `\fB%(\fP\&' is separate), which
ever comes first\&.  In particular, a truncation wit argument zero
(e\&.g\&., `\fB%<<\fP\&') marks tha end of tha range of tha strang ta be
truncated while turnin off truncation from there on\&. For example, the
prompt \&'%10<\&.\&.\&.<%~%<<%# ' will print a truncated representation of the
current directory, followed by a `\fB%\fP\&' or `\fB#\fP', followed by a
space\&.  Without tha `\fB%<<\fP\&', dem two charactas would be included
in tha strang ta be truncated\&.  Note dat `\fB%\-0<<\fP\&' be a gangbangin' finger-lickin' distinct
.PP
Truncation applies only within each individual line of tha prompt, as
delimited by embedded newlines (if any)\&.  If tha total length of any line
of tha prompt afta truncation is pimped outa than tha terminal width, or if
the part ta be truncated gotz nuff embedded newlines, truncation behavior
is undefined n' may chizzle up in a gangbangin' future version of tha shell\&.  Use
`\fB%\-\fIn\fP(l\&.\fItrue\-text\fP\&.\fIfalse\-text\fP)\fP\&' ta remove parts
of tha prompt when tha available space is less than \fIn\fP\&.
.RE
