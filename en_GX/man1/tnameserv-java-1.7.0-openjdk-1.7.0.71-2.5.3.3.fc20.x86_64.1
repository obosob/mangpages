." Copyright (c) 1999, 2011, Oracle and/or its affiliates fo' realz. All muthafuckin rights reserved.
." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
."
." This code is free software; you can redistribute it and/or modify it
." under tha termz of tha GNU General Public License version 2 only, as
." published by tha Jacked Software Foundation.
."
." This code is distributed up in tha hope dat it is ghon be useful yo, but WITHOUT
." ANY WARRANTY; without even tha implied warranty of MERCHANTABILITY or
." FITNESS FOR A PARTICULAR PURPOSE.  See tha GNU General Public License
." version 2 fo' mo' details (a copy is included up in tha LICENSE file that
." accompanied dis code).
."
." Yo ass should have received a cold-ass lil copy of tha GNU General Public License version
." 2 along wit dis work; if not, write ta tha Jacked Software Foundation,
." Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
."
." Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
." or visit www.oracle.com if you need additionizzle shiznit or have any
." thangs.
."
.TH tnameserv 1 "16 Mar 2012"

.LP
.SH "Name"
Java IDL: Transient Namin Service \- \f2tnameserv\fP
.LP
.LP
This document discusses rockin tha Java IDL Transient Namin Service, \f2tnameserv\fP. Java IDL also includes tha Object Request Broker Daemon (ORBD). ORBD be a thugged-out daemon process containin a Bootstrap Service, a Transient Namin Service, a \f3Persistent\fP Namin Service, n' a Server Manager n' shit. Da Java IDL tutorials all use ORBD, however, you can substitute \f2tnameserv\fP fo' \f2orbd\fP up in any of tha examplez dat bust a Transient Namin Service. For documentation on tha \f2orbd\fP tool, link ta its orbd(1) or tha 
.na
\f2Java IDL Namin Service Included wit ORBD\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/idl/jidlNaming.html topic.
.LP
.LP
Topics up in dis section include:
.LP
.RS 3
.TP 2
o
Java\ IDL Transient Namin Service 
.TP 2
o
Startin tha Java\ IDL Transient Namin Service 
.TP 2
o
Stoppin tha Java\ IDL Transient Namin Service 
.TP 2
o
Sample Client: Addin Objects ta tha Namespace 
.TP 2
o
Sample Client: Browsin tha Namespace 
.RE

.LP
.SH "Java\ IDL Transient Namin Service"
.LP
.LP
Da CORBA COS (Common Object Skillz) Namin Service serves up a tree\-like directory fo' object references much like a gangbangin' filesystem serves up a gangbangin' finger-lickin' directory structure fo' files. Da Transient Namin Service provided wit Java IDL, \f2tnameserv\fP, be a simple implementation of tha COS Namin Service justification.
.LP
.LP
Object references is stored up in tha namespace by name n' each object reference\-name pair is called a name \f2binding\fP. Name bindings may be organized under \f2namin contexts\fP. Namin contexts is theyselves name bindings n' serve tha same organizationizzle function as a gangbangin' file system subdirectory fo' realz. All bindings is stored under tha \f2initial namin context\fP. Da initial namin context is tha only persistent bindin up in tha namespace; tha rest of tha namespace is lost if tha Java IDL namin steez process halts n' restarts.
.LP
.LP
For a applet or application ta use COS naming, its ORB must know tha port of a host hustlin a namin steez or have access ta a stringified initial namin context fo' dat namin service. Da namin steez can either be tha Java\ IDL namin steez or another COS\-compliant namin service.
.LP
.SH "Startin tha Java\ IDL Transient Namin Service"
.LP
.LP
Yo ass must start tha Java\ IDL namin steez before a application or applet dat uses its namin service. Installation of tha Java\ IDL thang creates a script (Solaris: \f2tnameserv\fP) or executable file (Windows NT: \f2tnameserv.exe\fP) dat starts tha Java\ IDL namin service. Right back up in yo muthafuckin ass. Start tha namin steez so it runs up in tha background.
.LP
.LP
If you do not specify otherwise, tha Java\ IDL namin steez listens on port 900 fo' tha bootstrap protocol used ta implement tha ORB \f2resolve_initial_references()\fP n' \f2list_initial_references()\fP methods, as bigs up:
.LP
.nf
\f3
.fl
        tnameserv \-ORBInitialPort \fP\f4nameserverport\fP\f3&
.fl
\fP
.fi

.LP
.LP
If you do not specify tha name server port, port 900 is used by default. When hustlin Solaris software, you must become root ta start a process on a port under 1024. For dis reason, we recommend dat you bust a port number pimped outa than or equal ta 1024. To specify a gangbangin' finger-lickin' different port, fo' example, 1050, n' ta run tha namin steez up in tha background, from a UNIX command shell, enter:
.LP
.nf
\f3
.fl
        tnameserv \-ORBInitialPort 1050&
.fl
\fP
.fi

.LP
.LP
From a MS\-DOS system prompt (Windows), enter:
.LP
.nf
\f3
.fl
        start tnameserv \-ORBInitialPort 1050
.fl
\fP
.fi

.LP
.LP
Clientz of tha name server must be made aware of tha freshly smoked up port number n' shit. Do dis by settin tha \f2org.omg.CORBA.ORBInitialPort\fP property ta tha freshly smoked up port number when bustin tha ORB object.
.LP
.SS 
Hustlin tha server n' client on different hosts
.LP
.LP
In most of tha Java IDL n' RMI\-IIOP tutorials, tha Namin Service, Server, n' Client is all hustlin on tha pimpment machine. In real ghetto deployment, it is likely dat tha client n' server will run on different host machines than tha Namin Service.
.LP
.LP
For tha client n' server ta find tha Namin Service, they must be made aware of tha port number n' host on which tha namin steez is hustlin. Do dis by settin tha \f2org.omg.CORBA.ORBInitialPort\fP n' \f2org.omg.CORBA.ORBInitialHost\fP propertizzles up in tha client n' server filez ta tha machine name n' port number on which tha Namin Service is hustlin fo' realz. An example of dis is shown up in 
.na
\f2Da Wuz crackalackin' Ghetto Example Usin RMI\-IIOP\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/rmi\-iiop/rmiiiopexample.html. Yo ass could also use tha command line options \f2\-ORBInitialPort\fP \f2nameserverport#\fP n' \f2\-ORBInitialHost\fP \f2nameserverhostname\fP ta tell tha client n' server where ta find tha Namin Service. 
.na
\f2Java IDL: Hustlin tha Wuz crackalackin' Ghetto Example on TWO Machines\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/idl/tutorial/jidl2machines.html shows one way of bustin dis rockin tha command line option.
.LP
.LP
For example, suppose tha Transient Namin Service, \f2tnameserv\fP is hustlin on port 1050 on host \f2nameserverhost\fP. Da client is hustlin on host \f2clienthost\fP n' tha server is hustlin on host \f2serverhost\fP.
.LP
.RS 3
.TP 2
o
Start \f2tnameserv\fP on tha host \f2nameserverhost\fP, as bigs up: 
.nf
\f3
.fl
     tnameserv \-ORBInitialPort 1050
.fl

.fl
\fP
.fi
.TP 2
o
Start tha server on tha \f2serverhost\fP, as bigs up: 
.nf
\f3
.fl
     java Server \-ORBInitialPort 1050 \-ORBInitialHost nameserverhost
.fl
\fP
.fi
.TP 2
o
Start tha client on tha \f2clienthost\fP, as bigs up: 
.nf
\f3
.fl
     java Client \-ORBInitialPort 1050 \-ORBInitialHost nameserverhost
.fl
\fP
.fi
.RE

.LP
.SS 
Da \-J option
.LP
This command\-line option be available fo' use wit \f2tnameserve\fP: 
.RS 3
.TP 3
\-Joption 
Pass \f2option\fP ta tha Java virtual machine, where \f2option\fP is one of tha options busted lyrics bout on tha reference page fo' java(1). For example, \f3\-J\-Xms48m\fP sets tha startup memory ta 48 megabytes. Well shiiiit, it aint nuthin but a cold-ass lil common convention fo' \f3\-J\fP ta pass options ta tha underlyin virtual machine. 
.RE

.LP
.SH "Stoppin tha Java\ IDL Transient Namin Service"
.LP
.LP
To stop tha Java\ IDL namin service, use tha relevant operatin system command, like fuckin \f2kill\fP fo' a Unix process, or \f2Ctrl\-C\fP fo' a Windows process. Da namin steez will continue ta wait fo' invocations until it is explicitly shutdown. I aint talkin' bout chicken n' gravy biatch. Note dat names registered wit tha Java\ IDL namin steez disappear when tha steez is terminated.
.LP
.SH "Sample Client: Addin Objects ta tha Namespace"
.LP
.LP
Da followin sample program illustrates how tha fuck ta add names ta tha namespace. Well shiiiit, it aint nuthin but a self\-contained Transient Namin Service client dat creates tha followin simple tree.
.LP
.RS 3
.TP 2
o
\f4Initial Namin Context\fP 
.RS 3
.TP 2
*
\f3plans\fP 
.TP 2
*
\f4Personal\fP 
.RS 3
.TP 2
-
\f3calendar\fP 
.TP 2
-
\f3schedule\fP 
.RE
.RE
.RE

.LP
.LP
In dis example, \f3plans\fP be a object reference n' \f3Personal\fP be a namin context dat gotz nuff two object references: \f3calendar\fP n' \f3schedule\fP.
.LP
.nf
\f3
.fl
import java.util.Properties;
.fl
import org.omg.CORBA.*;
.fl
import org.omg.CosNaming.*;
.fl

.fl
hood class NameClient
.fl
{
.fl
   hood static void main(Strin args[])
.fl
   {
.fl
      try {
.fl
\fP
.fi

.LP
In tha above section, Startin tha Java IDL Transient Namin Service, tha nameserver was started on port 1050. Da followin code ensures dat tha client program be aware of dis port number n' shit. 
.nf
\f3
.fl
        Propertizzles props = freshly smoked up Properties();
.fl
        props.put("org.omg.CORBA.ORBInitialPort", "1050");
.fl
        ORB orb = ORB.init(args, props);
.fl

.fl
\fP
.fi

.LP
This code obtains tha initial namin context n' assigns it ta \f3ctx\fP. Da second line copies \f3ctx\fP tha fuck into a thugged-out dummy object reference \f3objref\fP dat we'll attach ta various names n' add tha fuck into tha namespace. 
.nf
\f3
.fl
        NamingContext ctx =
.fl
NamingContextHelper.narrow(orb.resolve_initial_references("NameService"));
.fl
        NamingContext objref = ctx;
.fl

.fl
\fP
.fi

.LP
This code creates a name "plans" of type "text" n' bindz it ta our dummy object reference. "plans" is then added under tha initial namin context rockin \f2rebind\fP. Da \f2rebind\fP method allows our asses ta run dis program over n' over again n' again n' again without gettin tha exceptions we'd git from rockin \f2bind\fP. 
.nf
\f3
.fl
        NameComponent nc1 = freshly smoked up NameComponent("plans", "text");
.fl
        NameComponent[] name1 = {nc1};
.fl
        ctx.rebind(name1, objref);
.fl
        System.out.println("plans rebind successful!");
.fl

.fl
\fP
.fi

.LP
This code creates a namin context called "Personal" of type "directory". Da resultin object reference, \f3ctx2\fP, is bound ta tha name n' added under tha initial namin context. 
.nf
\f3
.fl
        NameComponent nc2 = freshly smoked up NameComponent("Personal", "directory");
.fl
        NameComponent[] name2 = {nc2};
.fl
        NamingContext ctx2 = ctx.bind_new_context(name2);
.fl
        System.out.println("new namin context added..");
.fl

.fl
\fP
.fi

.LP
Da remainder of tha code bindz tha dummy object reference rockin tha names "schedule" n' "calendar" under tha "Personal" namin context (\f3ctx2\fP). 
.nf
\f3
.fl
        NameComponent nc3 = freshly smoked up NameComponent("schedule", "text");
.fl
        NameComponent[] name3 = {nc3};
.fl
        ctx2.rebind(name3, objref);
.fl
        System.out.println("schedule rebind successful!");
.fl

.fl
        NameComponent nc4 = freshly smoked up NameComponent("calender", "text");
.fl
        NameComponent[] name4 = {nc4};
.fl
        ctx2.rebind(name4, objref);
.fl
        System.out.println("calender rebind successful!");
.fl

.fl

.fl
    } catch (Exception e) {
.fl
        e.printStackTrace(System.err);
.fl
    }
.fl
  }
.fl
}
.fl
\fP
.fi

.LP
.SH "Sample Client: Browsin tha Namespace"
.LP
.LP
Da followin sample program illustrates how tha fuck ta browse tha namespace.
.LP
.nf
\f3
.fl
import java.util.Properties;
.fl
import org.omg.CORBA.*;
.fl
import org.omg.CosNaming.*;
.fl

.fl
hood class NameClientList
.fl
{
.fl
   hood static void main(Strin args[])
.fl
   {
.fl
      try {
.fl
\fP
.fi

.LP
In tha above section, Startin tha Java IDL Transient Namin Service, tha nameserver was started on port 1050. Da followin code ensures dat tha client program be aware of dis port number n' shit. 
.nf
\f3
.fl

.fl
        Propertizzles props = freshly smoked up Properties();
.fl
        props.put("org.omg.CORBA.ORBInitialPort", "1050");
.fl
        ORB orb = ORB.init(args, props);
.fl

.fl

.fl
\fP
.fi

.LP
Da followin code obtains tha initial namin context. 
.nf
\f3
.fl
        NamingContext nc =
.fl
NamingContextHelper.narrow(orb.resolve_initial_references("NameService"));
.fl

.fl
\fP
.fi

.LP
Da \f2list\fP method lists tha bindings up in tha namin context. In dis case, up ta 1000 bindings from tha initial namin context is ghon be returned up in tha BindingListHolder; any remainin bindings is returned up in tha BindingIteratorHolda n' shit. 
.nf
\f3
.fl
        BindingListHolda bl = freshly smoked up BindingListHolder();
.fl
        BindingIteratorHolda blIt= freshly smoked up BindingIteratorHolder();
.fl
        nc.list(1000, bl, blIt);
.fl

.fl
\fP
.fi

.LP
This code gets tha array of bindings outta tha returned BindingListHolda n' shit. If there be no bindings, tha program ends. 
.nf
\f3
.fl
        Bindin bindings[] = bl.value;
.fl
        if (bindings.length == 0) return;
.fl

.fl
\fP
.fi

.LP
Da remainder of tha code loops all up in tha bindings n' prints tha names out. 
.nf
\f3
.fl
        fo' (int i=0; i < bindings.length; i++) {
.fl

.fl
            // git tha object reference fo' each binding
.fl
            org.omg.CORBA.Object obj = nc.resolve(bindings[i].binding_name);
.fl
            Strin objStr = orb.object_to_string(obj);
.fl
            int lastIx = bindings[i].binding_name.length\-1;
.fl

.fl
            // check ta peep if dis be a namin context
.fl
            if (bindings[i].binding_type == BindingType.ncontext) {
.fl
              System.out.println( "Context: " +
.fl
bindings[i].binding_name[lastIx].id);
.fl
            } else {
.fl
                System.out.println("Object: " +
.fl
bindings[i].binding_name[lastIx].id);
.fl
            }
.fl
        }
.fl

.fl
       } catch (Exception e) {
.fl
        e.printStackTrace(System.err);
.fl
       }
.fl
   }
.fl
}
.fl
\fP
.fi

.LP
 
