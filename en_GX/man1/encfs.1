.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  | will give a
.\" real vertical bar. Shiiit, dis aint no joke.  \*(C+ will give a sickr C++.  Capital omega is used to
.\" do unbreakable dashes n' therefore won't be available.  \*(C` n' \*(C'
.\" expand ta `' up in nroff, not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
'br\}
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.Sh), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ENCFS 1"
.TH ENCFS 1 "2009-11-29" "1.7.3" "Encrypted Filesystem"
.SH "NAME"
encfs \- mounts or creates a encrypted virtual filesystem
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBencfs\fR [\fB\-\-version\fR] [\fB\-s\fR] [\fB\-f\fR] [\fB\-v\fR|\fB\-\-verbose\fR] 
[\fB\-i \s-1MINUTES\s0\fR|\fB\-\-idle=MINUTES\fR] [\fB\-\-extpass=program\fR] 
[\fB\-S\fR|\fB\-\-stdinpass\fR] [\fB\-\-anykey\fR] [\fB\-\-forcedecode\fR] 
[\fB\-d\fR|\fB\-\-fuse\-debug\fR] [\fB\-\-public\fR] [\fB\-\-no\-default\-flags\fR]
[\fB\-\-ondemand\fR] [\fB\-\-reverse\fR] [\fB\-\-standard\fR] 
[\fB\-o \s-1FUSE_OPTION\s0\fR]
\&\fIrootdir\fR \fImountPoint\fR 
[\fB\-\-\fR [\fIFuse Mount Options\fR]]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBEncFS\fR creates a virtual encrypted filesystem which stores encrypted data in
the \fIrootdir\fR directory n' make tha unencrypted data visible at the
\&\fImountPoint\fR directory.  Da user must supply a password which is used to
(indirectly) encrypt both filenames n' file contents.
.PP
If \fBEncFS\fR is unable ta find a supported filesystem all up in tha specified
\&\fIrootdir\fR, then tha user is ghon be axed if they wish ta create a freshly smoked up encrypted
filesystem all up in tha specified location. I aint talkin' bout chicken n' gravy biatch.  Options is ghon be presented ta tha user
allowin some control over tha algorithms ta use.  As \fBEncFS\fR matures, there
may be a increasin number of chizzles.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-i\fR, \fB\-\-idle=MINUTES\fR" 4
.IX Item "-i, --idle=MINUTES"
Enable automatic unmount of tha filesystem afta a period of inactivity.  The
period is specified up in minutes, so tha shortest timeout period dat can be
axed is one minute.  \fBEncFS\fR aint gonna automatically unmount if there are
filez open within tha filesystem, even if they is open up in read-only mode.
However simply havin filez open do not count as activity.
.IP "\fB\-f\fR" 4
.IX Item "-f"
Da \fB\-f\fR (\fIforeground\fR) option causes \fBEncFS\fR ta run up in tha foreground.
Normally \fBEncFS\fR spawns off as a thugged-out daemon n' runs up in tha background, returning
control ta tha spawnin shell.  With tha \fB\-f\fR option, it will run up in the
foreground n' any warning/debug log lyrics is ghon be displayed on standard
error. Shiiit, dis aint no joke.  In tha default (background) mode, all log lyrics is logged via
syslog.
.IP "\fB\-v\fR, \fB\-\-verbose\fR" 4
.IX Item "-v, --verbose"
Causes \fBEncFS\fR ta enable loggin of various debug channels within \fBEncFS\fR.
Normally these loggin lyrics is disabled n' have no effect.  It is
recommended dat you run up in foreground (\fB\-f\fR) mode when hustlin wit verbose
enabled.
.IP "\fB\-s\fR" 4
.IX Item "-s"
Da \fB\-s\fR (\fIsingle threaded\fR) option causes \fBEncFS\fR ta run up in single threaded
mode.  By default, \fBEncFS\fR runs up in multi-threaded mode.  This option is used
durin \fBEncFS\fR pimpment up in order ta simplify debuggin n' allow it ta run
under memory checkin tools..
.IP "\fB\-d\fR, \fB\-\-fuse\-debug\fR" 4
.IX Item "-d, --fuse-debug"
Enablez debuggin within tha \fB\s-1FUSE\s0\fR library.  This should only be used if you
suspect a problem within \fB\s-1FUSE\s0\fR itself (not \fBEncFS\fR), as it generates a lot
of low-level data n' aint likely ta be straight-up helpful up in general problem
tracking.  Try \fIverbose\fR mode (\fB\-v\fR) first, which gives a higher level view
of what tha fuck is goin down within \fBEncFS\fR.
.IP "\fB\-\-forcedecode\fR" 4
.IX Item "--forcedecode"
This option only has a effect on filesystems which use \s-1MAC\s0 block headers.  By
default, if a funky-ass block is decoded n' tha stored \s-1MAC\s0 don't match what tha fuck is
calculated, then a \s-1IO\s0 error is moonwalked back ta tha application n' tha block is
not returned. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat by specifyin \fB\-\-forcedecode\fR, only a error will be
logged n' tha data will still be moonwalked back ta tha application. I aint talkin' bout chicken n' gravy biatch.  This may be
useful fo' attemptin ta read corrupted files.
.IP "\fB\-\-public\fR" 4
.IX Item "--public"
Attempt ta make encfs behave as a typical multi-user filesystem.  By default,
all \s-1FUSE\s0 based filesystems is visible only ta tha user whoz ass mounted em.  No
other playas (includin root) can view tha filesystem contents, n' you can put dat on yo' toast.  Da \fB\-\-public\fR
option do two thangs.  It addz tha \s-1FUSE\s0 flags \*(L"allow_other\*(R" and
\&\*(L"default_permission\*(R" when mountin tha filesystem, which  drops some lyrics ta \s-1FUSE\s0 ta allow
other playas ta access tha filesystem, n' ta use tha ballershizzle permissions
provided by tha filesystem.  Secondly, tha \fB\-\-public\fR flag chizzlez how tha fuck encfs's
node creation functions work \- as they will try n' set ballershizzle of freshly smoked up nodes
based on tha calla identification.
.Sp
\&\fBWarning\fR: In order fo' dis ta work, encfs must be run as root \*(-- otherwise
it aint gonna have tha mobilitizzle ta chizzle ballershizzle of files.  I recommend that
you instead rewind if tha fuse allow_other option can be used ta do what
you want before thankin bout tha use of \fB\-\-public\fR.
.IP "\fB\-\-ondemand\fR" 4
.IX Item "--ondemand"
Mount tha filesystem on\-demand. Y'all KNOW dat shit, muthafucka!  This currently only make sense up in combination
with \fB\-\-idle\fR n' \fB\-\-extpass\fR options.  When tha filesystem becomes idle,
instead of exiting, \fBEncFS\fR stops allowin access ta tha filesystem by
internally droppin itz reference ta dat shit.  If one of mah thugs attempts ta access the
filesystem again, tha extpass program is used ta prompt tha user fo' the
password. Y'all KNOW dat shit, muthafucka!  If dis succeeds, then tha filesystem becomes available again.
.IP "\fB\-\-reverse\fR" 4
.IX Item "--reverse"
Normally \fBEncFS\fR serves up a plaintext view of data on demand. Y'all KNOW dat shit, muthafucka!  Normally it
stores enciphered data n' displays plaintext data.  With \fB\-\-reverse\fR it takes
as source plaintext data n' produces enciphered data on\-demand. Y'all KNOW dat shit, muthafucka!  This can be
useful fo' bustin remote encrypted backups, where you do not wish ta keep the
local filez unencrypted.
.Sp
For example, tha followin would create a encrypted view up in /tmp/crypt\-view.
.Sp
.Vb 1
\&    encfs --reverse /home/me /tmp/crypt-view
.Ve
.Sp
Yo ass could then copy tha /tmp/crypt\-view directory up in order ta git a cold-ass lil copy of
the encrypted data.  Yo ass must also keep a cold-ass lil copy of tha file /home/me/.encfs5
which gotz nuff tha filesystem shiznit. I aint talkin' bout chicken n' gravy biatch.  Together, tha two can be used to
reproduce tha unencrypted data:
.Sp
.Vb 1
\&    ENCFS5_CONFIG=/home/me/.encfs5 encfs /tmp/crypt-view /tmp/plain-view
.Ve
.Sp
Now /tmp/plain\-view gotz nuff tha same ol' dirty data as /home/me
.Sp
Note dat \fB\-\-reverse\fR mode only works wit limited configuration options, so
many settings may be disabled when used.
.IP "\fB\-\-standard\fR" 4
.IX Item "--standard"
If bustin a freshly smoked up filesystem, dis automatically selects standard configuration
options, ta help wit automatic filesystem creation. I aint talkin' bout chicken n' gravy biatch.  This is tha set of
options dat should be used unless you know what tha fuck you bustin n' have read the
documentation.
.Sp
When not bustin a gangbangin' filesystem, dis flag do nothing.
.IP "\fB\-o \s-1FUSE_ARG\s0\fR" 4
.IX Item "-o FUSE_ARG"
Pass all up in \fB\s-1FUSE\s0\fR args ta tha underlyin library.  This make it easy as fuck  to
pass \s-1FUSE\s0 options when mountin \fBEncFS\fR via mount (and /etc/fstab).  Eg:
.Sp
.Vb 1
\&    mount encfs#/home/me-crypt /home/me -t fuse -o kernel_cache
.Ve
.Sp
Note dat encfs arguments cannot be set dis way.  If you need ta set encfs
arguments, create a wrapper, like fuckin  encfs\-reverse;
.Sp
.Vb 2
\&    #!/bin/sh
\&    encfs --reverse $*
.Ve
.Sp
Then mount rockin tha script path
.Sp
.Vb 1
\&    mount encfs-reverse#/home/me /home/me-crypt -t fuse
.Ve
.IP "\fB\-\-\fR" 4
.IX Item "--"
Da \fB\-\-\fR option  drops some lyrics ta \fBEncFS\fR ta bust any remainin arguments directly to
\&\fB\s-1FUSE\s0\fR.  In turn, \fB\s-1FUSE\s0\fR passes tha arguments ta \fBfusermount\fR.  See
the \fBfusermount\fR help page fo' shiznit on available commands.
.IP "\fB\-\-no\-default\-flags\fR" 4
.IX Item "--no-default-flags"
\&\fBEncfs\fR addz tha \s-1FUSE\s0 flags \*(L"use_ino\*(R" n' \*(L"default_permissions\*(R" by default, as
of version 1.2.2, cuz dat improves compatibilitizzle wit some programs..  If
for some reason you need ta disable one or both of these flags, use tha option
\&\fB\-\-no\-default\-flags\fR.
.Sp
Da followin command lines produce tha same result:
.Sp
.Vb 2
\&    encfs raw crypt
\&    encfs --no-default-flags raw crypt -- -o use_ino,default_permissions
.Ve
.IP "\fB\-\-extpass=program\fR" 4
.IX Item "--extpass=program"
Specify a external program ta use fo' gettin tha user password. Y'all KNOW dat shit, muthafucka!  When the
external program is spawned, tha environment variable \*(L"RootDir\*(R" is ghon be set to
contain tha path ta tha root directory.  Da program should print tha password
to standard output.
.Sp
\&\fBEncFS\fR takes every last muthafuckin thang returned from tha program ta be tha password, except
for a trailin newline (\en) which is ghon be removed.
.Sp
For example, specifyin \fB\-\-extpass\fR=\fI/usr/lib/ssh/ssh\-askpass\fR will cause
\&\fBEncFS\fR ta use sshz password prompt program.  
.Sp
\&\fBNote\fR: \fBEncFS\fR readz at most 2k of data from tha password program, n' it
removes any trailin newline.  Versions before 1.4.x accepted only 64 bytes of
text.
.IP "\fB\-S\fR, \fB\-\-stdinpass\fR" 4
.IX Item "-S, --stdinpass"
Read password from standard input, without prompting.  This may be useful for
scriptin encfs mounts.
.Sp
Note dat you should make shizzle tha filesystem n' mount points exist first.
Otherwise encfs will prompt fo' tha filesystem creation options, which may
interfere wit yo' script.
.IP "\fB\-\-anykey\fR" 4
.IX Item "--anykey"
Turn off key validation checking.  This allows \fBEncFS\fR ta be used with
secondary passwords.  This could be used ta store a separate set of filez up in an
encrypted filesystem.  \fBEncFS\fR ignores filez which do not decode properly, so
filez pimped wit separate passwordz will only be visible when tha filesystem
is mounted wit they associated password.
.Sp
Note dat if tha primary password is chizzled (usin \fBencfsctl\fR), tha other
passwordz aint gonna be usable unless tha primary password is set back ta what tha fuck it
was, as tha other passwordz rely on a invalid decodin of tha volume key,
which aint gonna remain tha same if tha primary password is chizzled.
.Sp
\&\fBWarning\fR: Use dis option at yo' own risk.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Smoke a freshly smoked up encrypted filesystem.  Store tha raw (encrypted) data in
\&\*(L"~/.crypt\*(R" , n' make tha unencrypted data visible up in \*(L"~/crypt\*(R".  Both
directories is up in tha home directory up in dis example.  This example shows the
full output of encfs as it asks tha user if they wish ta create tha filesystem:
.PP
.Vb 9
\&    % encfs ~/.crypt ~/crypt
\&    Directory "/home/me/.crypt" do not exist, create (y,n)?y
\&    Directory "/home/me/crypt" do not exist, create (y,n)?y
\&    Creatin freshly smoked up encrypted volume.
\&    Please chizzle from one of tha followin options:
\&     enta "x" fo' expert configuration mode,
\&     enta "p" fo' pre-configured paranoia mode,
\&     anythang else, or a empty line will select standard mode.
\&    ?>
.Ve
.PP
.Vb 4
\&    Standard configuration selected.
\&    Usin cipher Blowfish, key size 160, block size 512
\&    New Password: <password entered here>
\&    Verify: <password entered here>
.Ve
.PP
Da filesystem is now mounted n' visible up in \fI~/crypt\fR.  If filez is pimped
there, they can be peeped up in encrypted form up in \fI~/.crypt\fR.  To unmount the
filesystem, use \fIfusermount\fR wit tha \fB\-u\fR (unmount) option:
.PP
.Vb 1
\&    % fusermount -u ~/crypt
.Ve
.PP
Another example.  To mount tha same filesystem yo, but have fusermount name the
mount point '/dev/foo' (as shown up in \fIdf\fR n' other tools which read
/etc/mtab), n' also request kernel-level cachin of file data (which is both
special arguments ta fusermount):
.PP
.Vb 1
\&    % encfs ~/.crypt ~/crypt -- -n /dev/foo -c
.Ve
.PP
Or, if you find strange behavior under some particular program when hustlin in
an encrypted filesystem, it may be helpful ta run up in verbose mode while
reproducin tha problem n' bust along tha output wit tha problem report:
.PP
.Vb 1
\&    % encfs -v -f ~/.crypt ~/crypt 2> encfs-report.txt
.Ve
.PP
In order ta avoid leakin sensitizzle shiznit all up in tha debuggin channels,
all warnings n' debug lyrics (as output up in verbose mode) contain only
encrypted filenames.  Yo ass can use tha \fIencfsctl\fR programz \fIdecode\fR function
to decode filenames if desired.
.SH "CAVEATS"
.IX Header "CAVEATS"
\&\fBEncFS\fR aint a legit filesystem.  It do not deal wit any of tha actual
storage or maintenizzle of files.  It simply translates requests (encryptin or
decryptin as necessary) n' passes tha requests all up in ta tha underlying
host filesystem.  Therefor any limitationz of tha host filesystem will likely
be inherited by \fBEncFS\fR (or possibly be further limited).
.PP
One such limitation is filename length.  If yo' underlyin filesystem limits
you ta N charactas up in a gangbangin' filename, then \fBEncFS\fR will limit you ta approximately
3*(N\-2)/4.  For example if tha host filesystem limits ta 256 characters, then
\&\fBEncFS\fR is ghon be limited ta 190 characta filenames.  This is cuz encrypted
filenames is always longer then plaintext filenames.
.SH "FILESYSTEM OPTIONS"
.IX Header "FILESYSTEM OPTIONS"
When \fBEncFS\fR is given a root directory which do not contain a existing
\&\fBEncFS\fR filesystem, it will give tha option ta create one.  Note dat options
can only be set at filesystem creation time.  There is no support fo' modifying
a filesystemz options in\-place.  
.PP
If you wanna upgrade a gangbangin' filesystem ta use newer features, then you need to
create a freshly smoked up filesystem n' mount both tha oldschool filesystem n' freshly smoked up filesystem at
the same time n' copy tha oldschool ta tha new.
.PP
Multiple instancez of encfs can be run all up in tha same time, includin different
versionz of encfs, as long as they is compatible wit tha current \s-1FUSE\s0 module
on yo' system.
.PP
A chizzle is provided fo' two pre-configured settings ('standard' and
\&'paranoia'), along wit a expert configuration mode.
.PP
\&\fIStandard\fR mode uses tha followin settings:
    Cipher: \s-1AES\s0
    Key Size: 192 bits
    \s-1PBKDF2\s0 wit 1/2 second runtime, 160 bit salt
    Filesystem Block Size: 1024 bytes
    Filename Encoding: Block encodin wit \s-1IV\s0 chaining
    Unique initialization vector file headers
.PP
\&\fIParanoia\fR mode uses tha followin settings:
    Cipher: \s-1AES\s0
    Key Size: 256 bits
    \s-1PBKDF2\s0 wit 3 second runtime, 160 bit salt
    Filesystem Block Size: 1024 bytes
    Filename Encoding: Block encodin wit \s-1IV\s0 chaining
    Unique initialization vector file headers
    Message Authentication Code block headers
    External \s-1IV\s0 Chaining
.PP
In tha expert / manual configuration mode, each of tha above options is
configurable.  Here be a list of current options wit some notes bout what
they mean:
.SH "Key Derivation Function"
.IX Header "Key Derivation Function"
Az of version 1.5, \fBEncFS\fR now uses \s-1PBKDF2\s0 as tha default key derivation
function. I aint talkin' bout chicken n' gravy biatch.  Da number of iterations up in tha keyin function is selected based on
wall clock time ta generate tha key.  In standard mode, a target time of 0.5
secondz is used, n' up in paranoia mode a target of 3.0 secondz is used.
.PP
On a 1.6Ghz \s-1AMD\s0 64 system, it rougly 64k iterationz of tha key derivation
function can be handled up in half a second. Y'all KNOW dat shit, muthafucka!  Da exact number of iterations to
use is stored up in tha configuration file, as it is needed ta remount the
filesystem.
.PP
If a \fBEncFS\fR filesystem configuration from 1.4.x is modified wit version 1.5
(like fuckin when rockin encfsctl ta chizzle tha password), then tha freshly smoked up \s-1PBKDF2\s0
function is ghon be used n' tha filesystem will no longer be readable by older
versions.
.IP "\fICipher\fR" 4
.IX Item "Cipher"
Which encryption algorithm ta use.  Da list is generated automatically based
on what tha fuck supported algorithms \fBEncFS\fR found up in tha encryption libraries.
When rockin a recent version of \fBOpenSSL\fR, Blowfish n' \s-1AES\s0 is tha typical
options.
.Sp
Blowfish be a 8 byte cipher \- encodin 8 bytes at a time.  \s-1AES\s0 be a 16 byte
cipher.
.IP "\fICipher Key Size\fR" 4
.IX Item "Cipher Key Size"
Many, if not all, of tha supported ciphers support multiple key lengths.  There
is not straight-up much need ta have enormous key lengths.  Even 160 bits (the
default) is probably overkill.
.IP "\fIFilesystem Block Size\fR" 4
.IX Item "Filesystem Block Size"
This is tha size (in bytes) dat \fBEncFS\fR deals wit at one time.  Each block
gets its own initialization vector n' is encoded up in tha cipher's
cipher-block-chainin mode.  A partial block all up in tha end of a gangbangin' file is encoded
usin a stream mode ta avoid havin ta store tha filesize somewhere.
.Sp
Havin larger block sizes reduces tha overhead of \fBEncFS\fR a lil yo, but it can
also add overhead if yo' programs read lil' small-ass partz of files.  In order ta read
a single byte from a gangbangin' file, tha entire block dat gotz nuff dat byte must be
read n' decoded, so a big-ass block size addz overhead ta lil' small-ass requests, n' you can put dat on yo' toast.  With
write calls it is even worse, as a funky-ass block must be read n' decoded, tha chizzle
applied n' tha block encoded n' freestyled back out.
.Sp
Da default is 512 bytes az of version 1.0.  Dat shiznit was hard coded ta 64 bytes in
version 0.x, which was not as efficient as tha current settin fo' general
usage.
.IP "\fIFilename Encoding\fR" 4
.IX Item "Filename Encoding"
\&\fBNew up in 1.1\fR fo' realz. A chizzle is given between stream encodin of filename n' block
encoding.  Da advantage of stream encodin is dat tha encoded filenames will
be as short as possible.  If you gotz a gangbangin' filename wit a single letter, it will
be straight-up short up in tha encoded form, where as block encoded filenames is always
rounded up ta tha block size of tha encryption cipher (8 bytes fo' Blowfish and
16 bytes fo' \s-1AES\s0).
.Sp
Da advantage of block encodin mode is dat filename lenths all come up as a
multiple of tha cipher block size.  This means dat one of mah thugs lookin at your
encrypted data can't tell as much bout tha length of yo' filenames.  It is
on by default, as it takes a similar amount of time ta rockin tha stream cipher.
However stream cipher mode may be useful if you want shorta encrypted
filenames fo' some reason.
.Sp
Prior ta version 1.1, only stream encodin was supported.
.IP "\fIFilename Initialization Vector Chaining\fR" 4
.IX Item "Filename Initialization Vector Chaining"
\&\fBNew up in 1.1\fR.  In previous versionz of \fBEncFS\fR, each filename element in
a path was encoded separately.  So if \*(L"foo\*(R" encoded ta \*(L"\s-1XXX\s0\*(R", then it would
always encode dat way (given tha same encryption key), no matta if tha path
was \*(L"a/b/foo\*(R", or \*(L"aa/foo/cc\*(R", etc.  That meant dat shiznit was possible fo' one of mah thugs
lookin all up in tha encrypted data ta peep if two filez up in different directories had
the same name, even though they wouldn't know what tha fuck dat name decoded to.
.Sp
With initialization vector chaining, each directory gets its own initialization
vector. Shiiit, dis aint no joke.  So \*(L"a/foo\*(R" n' \*(L"b/foo\*(R" gonna git straight-up different encoded names
for \*(L"foo\*(R".  This features has almost no performizzle impact (for most
operations), n' so is tha default up in all modes.
.Sp
\&\fBNote:\fR One dope performizzle exception is directory renames.  Since the
initialization vector fo' filename encodin dependz on tha directory path, any
rename requires re-encodin every last muthafuckin filename up in tha tree of tha directory being
changed. Y'all KNOW dat shit, muthafucka!  If there be thousandz of files, then EncFS will gotta do thousands
of renames.  It may also be possible dat EncFS will come across a gangbangin' file dat it
can't decode or aint gots permission ta move durin tha rename operation, in
which case it will attempt ta undo any chizzlez it made up ta dat point n' the
rename will fail.
.IP "\fIPer-File Initialization Vectors\fR" 4
.IX Item "Per-File Initialization Vectors"
\&\fBNew up in 1.1\fR.  In previous versionz of \fBEncFS\fR, each file was encoded up in the
same way.  Each block up in a gangbangin' file has always had its own initialization vector,
but up in a thugged-out deterministic way so dat block N up in one file is encoded up in tha same
was as block N up in another file.  That juiced it up possible fo' one of mah thugs ta tell if
two filez was identical (or partz of tha file was identical) by comparin the
encoded data.
.Sp
With per-file initialization vectors, each file gets its own 64bit random
initialization vector, so dat each file is encrypted up in a gangbangin' finger-lickin' different way.
.Sp
This option is enabled by default.
.IP "\fIExternal \s-1IV\s0 Chaining\fR" 4
.IX Item "External IV Chaining"
\&\fBNew up in 1.1.3\fR.  This option is closely related ta Per-File Initialization
Vectors n' Filename Initialization Vector Chaining.  Basically it extendz the
initialization vector chainin from filenames ta tha per-file initialization
vector.
.Sp
When dis option is enabled, tha per-file initialization vector is encoded
usin tha initialization vector derived from tha filename initialization vector
chainin code.  This means dat tha data up in a gangbangin' file becomes tied ta the
filename.  If a encrypted file is renamed outside of encfs, it will no longer
be decodable within encfs.  Note dat unless Block \s-1MAC\s0 headaz is enabled, the
decodin error aint gonna be detected n' will result up in readin random looking
data.
.Sp
There be a cold-ass lil cost associated wit all dis bullshit.  When External \s-1IV\s0 Chainin is enabled,
hard links aint gonna be allowed within tha filesystem, as there would be no way
to properly decode two different filenames pointin ta tha same data.
.Sp
Also, renamin a gangbangin' file requires modifyin tha file header n' shit.  So renames will only
be allowed when tha user has write access ta tha file.
.Sp
Because of these limits, dis option is disabled by default fo' standard mode
(and enabled by default fo' paranoia mode).
.IP "\fIBlock \s-1MAC\s0 headers\fR" 4
.IX Item "Block MAC headers"
\&\fBNew ta 1.1\fR.  If dis is enabled, every last muthafuckin block up in every last muthafuckin file is stored along
with a cold-ass lil cryptographic checksum (Message Authentication Code).  This make it
virtually impossible ta modify a gangbangin' file without tha chizzle bein detected by
\&\fBEncFS\fR.  \fBEncFS\fR will refuse ta read data which do not pass tha checksum,
and will log tha error n' return a \s-1IO\s0 error ta tha application.
.Sp
This addz substantial overhead (default bein 8 bytes per filesystem block),
plus computationizzle overhead, n' aint enabled by default except up in paranoia
mode.
.Sp
When dis aint enabled n' if \fBEncFS\fR be axed ta read modified or corrupted
data, it gonna git no way ta verify dat tha decoded data is what tha fuck was
originally encoded.
.SH "Attacks"
.IX Header "Attacks"
Da primary goal of \fBEncFS\fR is ta protect data off\-line.  That is, provide a
convenient way of storin filez up in a way dat will frustrate any attempt to
read dem if tha filez is lata intercepted.
.PP
Some algorithms up in \fBEncFS\fR is also meant ta frustrate on-line attacks where
an attacker be assumed ta be able ta modify tha files.
.PP
Da most intrusive attacks, where a attacker has complete control of the
userz machine (and can therefor modify \fBEncFS\fR, or \fB\s-1FUSE\s0\fR, or tha kernel
itself) is not guarded against.  Do not assume dat encrypted filez will
protect yo' sensitizzle data if you enta yo' password tha fuck into a cold-ass lil compromised
computer n' shit.  How tha fuck you determine dat tha computa is safe ta use is beyond the
scope of dis documentation.
.PP
That holla'd, here is some example attacks n' data gatherin steez on the
filesystem contents along wit tha algorithms \fBEncFS\fR supports ta thwart them:
.IP "\fBAttack\fR: modifyin all dem bytez of a encrypted file (without knowin what tha fuck they will decode to)." 4
.IX Item "Attack: modifyin all dem bytez of a encrypted file (without knowin what tha fuck they will decode to)."
\&\fBEncFS\fR do not use any form of \s-1XOR\s0 encryption which would allow
single bytes ta be modified without affectin others.  Most modifications
would affect dozens or mo' bytes.  Additionally, \s-1MAC\s0 Block headaz can be
used ta identify any chizzlez ta files.
.IP "\fBAttack\fR: copyin a random block of one file ta a random block of another file." 4
.IX Item "Attack: copyin a random block of one file ta a random block of another file."
Each block has its own [deterministic] initialization vector.
.IP "\fBAttack\fR: copyin block N ta block N of another file." 4
.IX Item "Attack: copyin block N ta block N of another file."
When tha Per-File Initialization Vector support is enabled (default
in 1.1.x filesystems), a cold-ass lil copied block aint gonna decode properly when copied to
another file.
.IP "\fBAttack\fR: copyin a entire file ta another file." 4
.IX Item "Attack: copyin a entire file ta another file."
Can be prevented by enablin External \s-1IV\s0 Chainin mode.
.IP "\fBAttack\fR: determine if two filenames is tha same by lookin at encrypted names." 4
.IX Item "Attack: determine if two filenames is tha same by lookin at encrypted names."
Filename Initialization Vector chainin prevents dis by givin each file a
64\-bit initialization vector derived from its full path name.
.IP "\fBAttack\fR: compare if two filez contain tha same data." 4
.IX Item "Attack: compare if two filez contain tha same data."
Per-File Initialization Vector support prevents all dis bullshit.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This library is distributed up in tha hope dat it is ghon be useful yo, but \s-1WITHOUT\s0 \s-1ANY\s0
\&\s-1WARRANTY\s0; without even tha implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A
\&\s-1PARTICULAR\s0 \s-1PURPOSE\s0.  Please refer ta tha \*(L"\s-1COPYING\s0\*(R" file distributed with
\&\fBEncFS\fR fo' complete details.
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\fBEncFS\fR was freestyled by \fBValient Gough <vgough@pobox.com>\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIencfsctl\fR\|(1)
