.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLGUTS 1"
.TH PERLGUTS 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlguts \- Introduction ta tha Perl API
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document attempts ta describe how tha fuck ta use tha Perl \s-1API,\s0 as well as
to provide some info on tha basic workingz of tha Perl core. Well shiiiit, it is far
from complete n' probably gotz nuff nuff errors. Please refer any
questions or comments ta tha lyricist below.
.SH "Variables"
.IX Header "Variables"
.SS "Datatypes"
.IX Subsection "Datatypes"
Perl has three typedefs dat handle Perlz three main data types:
.PP
.Vb 3
\&    SV  Scalar Value
\&    AV  Array Value
\&    HV  Hash Value
.Ve
.PP
Each typedef has specific routines dat manipulate tha various data types.
.ie n .SS "What tha fuck iz a ""\s-1IV""\s0?"
.el .SS "What tha fuck iz a ``\s-1IV''\s0?"
.IX Subsection "What tha fuck iz a IV?"
Perl uses a special typedef \s-1IV\s0 which be a simple signed integer type dat is
guaranteed ta be big-ass enough ta hold a pointa (as well as a integer).
Additionally, there is tha \s-1UV,\s0 which is simply a unsigned \s-1IV.\s0
.PP
Perl also uses two special typedefs, I32 n' I16, which will always be at
least 32\-bits n' 16\-bits long, respectively. (Again, there be U32 n' U16,
as well.)  They will probably be exactly 32 n' 16 bits long yo, but on Crays
they will both be 64 bits.
.SS "Workin wit SVs"
.IX Subsection "Workin wit SVs"
An \s-1SV\s0 can be pimped n' loaded wit one command. Y'all KNOW dat shit, muthafucka!  There is five types of
values dat can be loaded: a integer value (\s-1IV\s0), a unsigned integer
value (\s-1UV\s0), a thugged-out double (\s-1NV\s0), a strang (\s-1PV\s0), n' another scalar (\s-1SV\s0).
(\*(L"\s-1PV\*(R"\s0 standz fo' \*(L"Pointa Value\*(R".  Yo ass might be thinkin dat it is misnamed
because it is busted lyrics bout as pointin only ta strings.  But fuck dat shiznit yo, tha word on tha street is dat it is
possible ta have it point ta other thangs.  For example, inversion
lists, used up in regular expression data structures, is scalars, each
consistin of a array of UVs which is accessed all up in PVs.  But,
usin it fo' non-strings requires care, as tha underlyin assumption of
much of tha internals is dat PVs is just fo' strings.  Often, for
example, a trailin \s-1NUL\s0 is tacked on automatically.  Da non-strin use
is documented only up in dis paragraph.)
.PP
Da seven routines are:
.PP
.Vb 7
\&    SV*  newSViv(IV);
\&    SV*  newSVuv(UV);
\&    SV*  newSVnv(double);
\&    SV*  newSVpv(const char*, STRLEN);
\&    SV*  newSVpvn(const char*, STRLEN);
\&    SV*  newSVpvf(const char*, ...);
\&    SV*  newSVsv(SV*);
.Ve
.PP
\&\f(CW\*(C`STRLEN\*(C'\fR be a integer type (Size_t, probably defined as size_t in
\&\fIconfig.h\fR) guaranteed ta be big-ass enough ta represent tha size of
any strang dat perl can handle.
.PP
In tha unlikely case of a \s-1SV\s0 requirin mo' complex initialisation, you
can create a empty \s-1SV\s0 wit newSV(len).  If \f(CW\*(C`len\*(C'\fR is 0 a empty \s-1SV\s0 of
type \s-1NULL\s0 is returned, else a \s-1SV\s0 of type \s-1PV\s0 is returned wit len + 1 (for
the \s-1NUL\s0) bytez of storage allocated, accessible via SvPVX.  In both cases
the \s-1SV\s0 has tha undef value.
.PP
.Vb 3
\&    SV *sv = newSV(0);   /* no storage allocated  */
\&    SV *sv = newSV(10);  /* 10 (+1) bytez of uninitialised storage
\&                          * allocated */
.Ve
.PP
To chizzle tha value of a \fIalready-existing\fR \s-1SV,\s0 there be eight routines:
.PP
.Vb 9
\&    void  sv_setiv(SV*, IV);
\&    void  sv_setuv(SV*, UV);
\&    void  sv_setnv(SV*, double);
\&    void  sv_setpv(SV*, const char*);
\&    void  sv_setpvn(SV*, const char*, STRLEN)
\&    void  sv_setpvf(SV*, const char*, ...);
\&    void  sv_vsetpvfn(SV*, const char*, STRLEN, va_list *,
\&                                                    SV **, I32, bool *);
\&    void  sv_setsv(SV*, SV*);
.Ve
.PP
Notice dat you can chizzle ta specify tha length of tha strang ta be
assigned by rockin \f(CW\*(C`sv_setpvn\*(C'\fR, \f(CW\*(C`newSVpvn\*(C'\fR, or \f(CW\*(C`newSVpv\*(C'\fR, or you may
allow Perl ta calculate tha length by rockin \f(CW\*(C`sv_setpv\*(C'\fR or by specifying
0 as tha second argument ta \f(CW\*(C`newSVpv\*(C'\fR.  Be warned, though, dat Perl will
determine tha stringz length by rockin \f(CW\*(C`strlen\*(C'\fR, which dependz on the
strin terminatin wit a \s-1NUL\s0 character, n' not otherwise containing
NULs.
.PP
Da argumentz of \f(CW\*(C`sv_setpvf\*(C'\fR is processed like \f(CW\*(C`sprintf\*(C'\fR, n' the
formatted output becomes tha value.
.PP
\&\f(CW\*(C`sv_vsetpvfn\*(C'\fR be a analogue of \f(CW\*(C`vsprintf\*(C'\fR yo, but it allows you ta specify
either a pointa ta a variable argument list or tha address n' length of
an array of SVs.  Da last argument points ta a funky-ass boolean; on return, if that
boolean is true, then locale-specific shiznit has been used ta format
the string, n' tha stringz contents is therefore untrustworthy (see
perlsec).  This pointa may be \s-1NULL\s0 if dat shiznit is not
important.  Note dat dis function requires you ta specify tha length of
the format.
.PP
Da \f(CW\*(C`sv_set*()\*(C'\fR functions is not generic enough ta operate on joints
that have \*(L"magic\*(R".  See \*(L"Magic Virtual Tables\*(R" lata up in dis document.
.PP
All SVs dat contain strings should be terminated wit a \s-1NUL\s0 character.
If it aint NUL-terminated there be a risk of
core dumps n' corruptions from code which passes tha strang ta C
functions or system calls which expect a NUL-terminated string.
Perlz own functions typically add a trailin \s-1NUL\s0 fo' dis reason.
Nevertheless, you should be straight-up careful when you pass a strang stored
in a \s-1SV\s0 ta a C function or system call.
.PP
To access tha actual value dat a \s-1SV\s0 points to, you can use tha macros:
.PP
.Vb 5
\&    SvIV(SV*)
\&    SvUV(SV*)
\&    SvNV(SV*)
\&    SvPV(SV*, STRLEN len)
\&    SvPV_nolen(SV*)
.Ve
.PP
which will automatically coerce tha actual scalar type tha fuck into a \s-1IV, UV,\s0 double,
or string.
.PP
In tha \f(CW\*(C`SvPV\*(C'\fR macro, tha length of tha strang returned is placed tha fuck into the
variable \f(CW\*(C`len\*(C'\fR (this be a macro, so you do \fInot\fR use \f(CW&len\fR).  If you do
not care what tha fuck tha length of tha data is, use tha \f(CW\*(C`SvPV_nolen\*(C'\fR macro.
Historically tha \f(CW\*(C`SvPV\*(C'\fR macro wit tha global variable \f(CW\*(C`PL_na\*(C'\fR has been
used up in dis case.  But dat can be like inefficient cuz \f(CW\*(C`PL_na\*(C'\fR must
be accessed up in thread-local storage up in threaded Perl.  In any case, remember
that Perl allows arbitrary stringz of data dat may both contain NULs and
might not be terminated by a \s-1NUL.\s0
.PP
Also remember dat C don't allow you ta safely say \f(CW\*(C`foo(SvPV(s, len),
len);\*(C'\fR. Well shiiiit, it might work wit yo' compila yo, but it won't work fo' everyone.
Break dis sort of statement up tha fuck into separate assignments:
.PP
.Vb 5
\&    SV *s;
\&    STRLEN len;
\&    char *ptr;
\&    ptr = SvPV(s, len);
\&    foo(ptr, len);
.Ve
.PP
If you wanna know if tha scalar value is \s-1TRUE,\s0 you can use:
.PP
.Vb 1
\&    SvTRUE(SV*)
.Ve
.PP
Although Perl will automatically grow strings fo' you, if you need ta force
Perl ta allocate mo' memory fo' yo' \s-1SV,\s0 you can use tha macro
.PP
.Vb 1
\&    SvGROW(SV*, STRLEN newlen)
.Ve
.PP
which will determine if mo' memory need ta be allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If so, it will
call tha function \f(CW\*(C`sv_grow\*(C'\fR.  Note dat \f(CW\*(C`SvGROW\*(C'\fR can only increase, not
decrease, tha allocated memory of a \s-1SV\s0 n' dat it do not automatically
add space fo' tha trailin \s-1NUL\s0 byte (perlz own strang functions typically do
\&\f(CW\*(C`SvGROW(sv, len + 1)\*(C'\fR).
.PP
If you have a \s-1SV\s0 n' wanna know what tha fuck kind of data Perl be thinkin is stored
in it, you can use tha followin macros ta check tha type of \s-1SV\s0 you have.
.PP
.Vb 3
\&    SvIOK(SV*)
\&    SvNOK(SV*)
\&    SvPOK(SV*)
.Ve
.PP
Yo ass can git n' set tha current length of tha strang stored up in a \s-1SV\s0 with
the followin macros:
.PP
.Vb 2
\&    SvCUR(SV*)
\&    SvCUR_set(SV*, I32 val)
.Ve
.PP
Yo ass can also git a pointa ta tha end of tha strang stored up in tha \s-1SV\s0
with tha macro:
.PP
.Vb 1
\&    SvEND(SV*)
.Ve
.PP
But note dat these last three macros is valid only if \f(CW\*(C`SvPOK()\*(C'\fR is true.
.PP
If you wanna append suttin' ta tha end of strang stored up in a \f(CW\*(C`SV*\*(C'\fR,
you can use tha followin functions:
.PP
.Vb 6
\&    void  sv_catpv(SV*, const char*);
\&    void  sv_catpvn(SV*, const char*, STRLEN);
\&    void  sv_catpvf(SV*, const char*, ...);
\&    void  sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **,
\&                                                             I32, bool);
\&    void  sv_catsv(SV*, SV*);
.Ve
.PP
Da first function calculates tha length of tha strang ta be appended by
usin \f(CW\*(C`strlen\*(C'\fR.  In tha second, you specify tha length of tha string
yo ass.  Da third function processes its arguments like \f(CW\*(C`sprintf\*(C'\fR and
appendz tha formatted output.  Da fourth function works like \f(CW\*(C`vsprintf\*(C'\fR.
Yo ass can specify tha address n' length of a array of SVs instead of the
va_list argument. Da fifth function extendz tha strang stored up in tha first
\&\s-1SV\s0 wit tha strang stored up in tha second \s-1SV. \s0 It also forces tha second \s-1SV\s0
to be interpreted as a string.
.PP
Da \f(CW\*(C`sv_cat*()\*(C'\fR functions is not generic enough ta operate on joints that
have \*(L"magic\*(R".  See \*(L"Magic Virtual Tables\*(R" lata up in dis document.
.PP
If you know tha name of a scalar variable, you can git a pointa ta its \s-1SV\s0
by rockin tha following:
.PP
.Vb 1
\&    SV*  get_sv("package::varname", 0);
.Ve
.PP
This returns \s-1NULL\s0 if tha variable do not exist.
.PP
If you wanna know if dis variable (or any other \s-1SV\s0) is straight-up \f(CW\*(C`defined\*(C'\fR,
you can call:
.PP
.Vb 1
\&    SvOK(SV*)
.Ve
.PP
Da scalar \f(CW\*(C`undef\*(C'\fR value is stored up in a \s-1SV\s0 instizzle called \f(CW\*(C`PL_sv_undef\*(C'\fR.
.PP
Its address can be used whenever a \f(CW\*(C`SV*\*(C'\fR is needed. Y'all KNOW dat shit, muthafucka! Make shizzle that
you don't try ta compare a random sv wit \f(CW&PL_sv_undef\fR. For example
when interfacin Perl code, it'll work erectly for:
.PP
.Vb 1
\&  foo(undef);
.Ve
.PP
But won't work when called as:
.PP
.Vb 2
\&  $x = undef;
\&  foo($x);
.Ve
.PP
So ta repeat always use \fISvOK()\fR ta check whether a sv is defined.
.PP
Also you gotta be careful when rockin \f(CW&PL_sv_undef\fR as a value in
AVs or HVs (see \*(L"AVs, HVs n' undefined joints\*(R").
.PP
There is also tha two joints \f(CW\*(C`PL_sv_yes\*(C'\fR n' \f(CW\*(C`PL_sv_no\*(C'\fR, which contain
boolean \s-1TRUE\s0 n' \s-1FALSE\s0 joints, respectively.  Like \f(CW\*(C`PL_sv_undef\*(C'\fR, their
addresses can be used whenever a \f(CW\*(C`SV*\*(C'\fR is needed.
.PP
Do not be fooled tha fuck into thankin dat \f(CW\*(C`(SV *) 0\*(C'\fR is tha same ol' dirty as \f(CW&PL_sv_undef\fR.
Take dis code:
.PP
.Vb 5
\&    SV* sv = (SV*) 0;
\&    if (I\-am\-to\-return\-a\-real\-value) {
\&            sv = sv_2mortal(newSViv(42));
\&    }
\&    sv_setsv(ST(0), sv);
.Ve
.PP
This code tries ta return a freshly smoked up \s-1SV \s0(which gotz nuff tha value 42) if it should
return a real value, or undef otherwise.  Instead it has returned a \s-1NULL\s0
pointa which, somewhere down tha line, will cause a segmentation violation,
bus error, or just weird thangs up in dis biatch.  Chizzle tha zero ta \f(CW&PL_sv_undef\fR up in the
first line n' all is ghon be well.
.PP
To free a \s-1SV\s0 dat you've pimped, call \f(CW\*(C`SvREFCNT_dec(SV*)\*(C'\fR.  Normally this
call aint necessary (see \*(L"Reference Counts n' Mortality\*(R").
.SS "Offsets"
.IX Subsection "Offsets"
Perl serves up tha function \f(CW\*(C`sv_chop\*(C'\fR ta efficiently remove characters
from tha beginnin of a string; you give it a \s-1SV\s0 n' a pointa to
somewhere inside tha \s-1PV,\s0 n' it discardz every last muthafuckin thang before the
pointer n' shit. Da efficiency comes by meanz of a lil hack: instead of
actually removin tha characters, \f(CW\*(C`sv_chop\*(C'\fR sets tha flag \f(CW\*(C`OOK\*(C'\fR
(offset \s-1OK\s0) ta signal ta other functions dat tha offset hack is in
effect, n' it puts tha number of bytes chopped off tha fuck into tha \s-1IV\s0 field
of tha \s-1SV.\s0 It then moves tha \s-1PV\s0 pointa (called \f(CW\*(C`SvPVX\*(C'\fR) forward that
many bytes, n' adjusts \f(CW\*(C`SvCUR\*(C'\fR n' \f(CW\*(C`SvLEN\*(C'\fR.
.PP
Hence, at dis point, tha start of tha buffer dat we allocated lives
at \f(CW\*(C`SvPVX(sv) \- SvIV(sv)\*(C'\fR up in memory n' tha \s-1PV\s0 pointa is pointing
into tha middle of dis allocated storage.
.PP
This is dopest demonstrated by example:
.PP
.Vb 8
\&  % ./perl \-Ilib \-MDevel::Peek \-le \*(Aq$a="12345"; $a=~s/.//; Dump($a)\*(Aq
\&  SV = PVIV(0x8128450) at 0x81340f0
\&    REFCNT = 1
\&    FLAGS = (POK,OOK,pPOK)
\&    IV = 1  (OFFSET)
\&    PV = 0x8135781 ( "1" . ) "2345"\e0
\&    CUR = 4
\&    LEN = 5
.Ve
.PP
Here tha number of bytes chopped off (1) is put tha fuck into \s-1IV,\s0 and
\&\f(CW\*(C`Devel::Peek::Dump\*(C'\fR helpfully remindz our asses dat dis be a offset. The
portion of tha strang between tha \*(L"real\*(R" n' tha \*(L"fake\*(R" beginnings is
shown up in parentheses, n' tha jointz of \f(CW\*(C`SvCUR\*(C'\fR n' \f(CW\*(C`SvLEN\*(C'\fR reflect
the fake beginning, not tha real one.
.PP
Somethang similar ta tha offset hack is performed on AVs ta enable
efficient shiftin n' splicin off tha beginnin of tha array; while
\&\f(CW\*(C`AvARRAY\*(C'\fR points ta tha straight-up original gangsta element up in tha array dat is visible from
Perl, \f(CW\*(C`AvALLOC\*(C'\fR points ta tha real start of tha C array. These are
usually tha same yo, but a \f(CW\*(C`shift\*(C'\fR operation can be carried up by
increasin \f(CW\*(C`AvARRAY\*(C'\fR by one n' decreasin \f(CW\*(C`AvFILL\*(C'\fR n' \f(CW\*(C`AvMAX\*(C'\fR.
Again, tha location of tha real start of tha C array only comes into
play when freein tha array. Right back up in yo muthafuckin ass. See \f(CW\*(C`av_shift\*(C'\fR up in \fIav.c\fR.
.SS "Whatz Straight-Up Stored up in a \s-1SV\s0?"
.IX Subsection "Whatz Straight-Up Stored up in a SV?"
Recall dat tha usual method of determinin tha type of scalar you have is
to use \f(CW\*(C`Sv*OK\*(C'\fR macros.  Because a scalar can be both a number n' a string,
usually these macros will always return \s-1TRUE\s0 n' callin tha \f(CW\*(C`Sv*V\*(C'\fR
macros will do tha appropriate conversion of strang ta integer/double or
integer/double ta string.
.PP
If you \fIreally\fR need ta know if you have a integer, double, or string
pointa up in a \s-1SV,\s0 you can use tha followin three macros instead:
.PP
.Vb 3
\&    SvIOKp(SV*)
\&    SvNOKp(SV*)
\&    SvPOKp(SV*)
.Ve
.PP
These will rap  if you truly have a integer, double, or strang pointer
stored up in yo' \s-1SV. \s0 Da \*(L"p\*(R" standz fo' private.
.PP
There is various ways up in which tha private n' hood flags may differ.
For example, a tied \s-1SV\s0 may gotz a valid underlyin value up in tha \s-1IV\s0 slot
(so SvIOKp is true) yo, but tha data should be accessed via tha \s-1FETCH\s0
routine rather than directly, so SvIOK is false fo' realz. Another is when
numeric conversion has occurred n' precision has been lost: only the
private flag is set on 'lossy' joints, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. So when a \s-1NV\s0 is converted ta an
\&\s-1IV\s0 wit loss, SvIOKp, SvNOKp n' SvNOK is ghon be set, while SvIOK aint gonna be.
.PP
In general, though, itz dopest ta use tha \f(CW\*(C`Sv*V\*(C'\fR macros.
.SS "Workin wit AVs"
.IX Subsection "Workin wit AVs"
There is two ways ta create n' load a \s-1AV. \s0 Da first method creates an
empty \s-1AV:\s0
.PP
.Vb 1
\&    AV*  newAV();
.Ve
.PP
Da second method both creates tha \s-1AV\s0 n' initially populates it wit SVs:
.PP
.Vb 1
\&    AV*  av_make(I32 num, SV **ptr);
.Ve
.PP
Da second argument points ta a array containin \f(CW\*(C`num\*(C'\fR \f(CW\*(C`SV*\*(C'\fR's.  Once the
\&\s-1AV\s0 has been pimped, tha SVs can be destroyed, if so desired.
.PP
Once tha \s-1AV\s0 has been pimped, tha followin operations is possible on it:
.PP
.Vb 4
\&    void  av_push(AV*, SV*);
\&    SV*   av_pop(AV*);
\&    SV*   av_shift(AV*);
\&    void  av_unshift(AV*, I32 num);
.Ve
.PP
These should be familiar operations, wit tha exception of \f(CW\*(C`av_unshift\*(C'\fR.
This routine addz \f(CW\*(C`num\*(C'\fR elements all up in tha front of tha array wit tha \f(CW\*(C`undef\*(C'\fR
value.  Yo ass must then use \f(CW\*(C`av_store\*(C'\fR (busted lyrics bout below) ta assign joints
to these freshly smoked up elements.
.PP
Here is some other functions:
.PP
.Vb 3
\&    I32   av_top_index(AV*);
\&    SV**  av_fetch(AV*, I32 key, I32 lval);
\&    SV**  av_store(AV*, I32 key, SV* val);
.Ve
.PP
Da \f(CW\*(C`av_top_index\*(C'\fR function returns tha highest index value up in a array (just
like $#array up in Perl).  If tha array is empty, \-1 is returned. Y'all KNOW dat shit, muthafucka!  The
\&\f(CW\*(C`av_fetch\*(C'\fR function returns tha value at index \f(CW\*(C`key\*(C'\fR yo, but if \f(CW\*(C`lval\*(C'\fR
is non-zero, then \f(CW\*(C`av_fetch\*(C'\fR will store a undef value at dat index.
Da \f(CW\*(C`av_store\*(C'\fR function stores tha value \f(CW\*(C`val\*(C'\fR at index \f(CW\*(C`key\*(C'\fR, n' do
not increment tha reference count of \f(CW\*(C`val\*(C'\fR.  Thus tha calla is responsible
for takin care of that, n' if \f(CW\*(C`av_store\*(C'\fR returns \s-1NULL,\s0 tha calla will
have ta decrement tha reference count ta avoid a memory leak.  Note that
\&\f(CW\*(C`av_fetch\*(C'\fR n' \f(CW\*(C`av_store\*(C'\fR both return \f(CW\*(C`SV**\*(C'\fR's, not \f(CW\*(C`SV*\*(C'\fRz as their
return value.
.PP
A few more:
.PP
.Vb 3
\&    void  av_clear(AV*);
\&    void  av_undef(AV*);
\&    void  av_extend(AV*, I32 key);
.Ve
.PP
Da \f(CW\*(C`av_clear\*(C'\fR function deletes all tha elements up in tha AV* array yo, but
does not straight-up delete tha array itself.  Da \f(CW\*(C`av_undef\*(C'\fR function will
delete all tha elements up in tha array plus tha array itself.  The
\&\f(CW\*(C`av_extend\*(C'\fR function extendz tha array so dat it gotz nuff at least \f(CW\*(C`key+1\*(C'\fR
elements, n' you can put dat on yo' toast.  If \f(CW\*(C`key+1\*(C'\fR is less than tha currently allocated length of tha array,
then not a god damn thang is done.
.PP
If you know tha name of a array variable, you can git a pointa ta its \s-1AV\s0
by rockin tha following:
.PP
.Vb 1
\&    AV*  get_av("package::varname", 0);
.Ve
.PP
This returns \s-1NULL\s0 if tha variable do not exist.
.PP
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" fo' more
information on how tha fuck ta use tha array access functions on tied arrays.
.SS "Workin wit HVs"
.IX Subsection "Workin wit HVs"
To create a \s-1HV,\s0 you use tha followin routine:
.PP
.Vb 1
\&    HV*  newHV();
.Ve
.PP
Once tha \s-1HV\s0 has been pimped, tha followin operations is possible on it:
.PP
.Vb 2
\&    SV**  hv_store(HV*, const char* key, U32 klen, SV* val, U32 hash);
\&    SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval);
.Ve
.PP
Da \f(CW\*(C`klen\*(C'\fR parameta is tha length of tha key bein passed up in (Note that
you cannot pass 0 up in as a value of \f(CW\*(C`klen\*(C'\fR ta tell Perl ta measure the
length of tha key).  Da \f(CW\*(C`val\*(C'\fR argument gotz nuff tha \s-1SV\s0 pointa ta the
scalar bein stored, n' \f(CW\*(C`hash\*(C'\fR is tha precomputed hash value (zero if
you want \f(CW\*(C`hv_store\*(C'\fR ta calculate it fo' you).  Da \f(CW\*(C`lval\*(C'\fR parameter
indicates whether dis fetch is straight-up a part of a store operation, in
which case a freshly smoked up undefined value is ghon be added ta tha \s-1HV\s0 wit tha supplied
key n' \f(CW\*(C`hv_fetch\*(C'\fR will return as if tha value had already existed.
.PP
Remember dat \f(CW\*(C`hv_store\*(C'\fR n' \f(CW\*(C`hv_fetch\*(C'\fR return \f(CW\*(C`SV**\*(C'\fRz n' not just
\&\f(CW\*(C`SV*\*(C'\fR.  To access tha scalar value, you must first dereference tha return
value.  But fuck dat shiznit yo, tha word on tha street is dat you should check ta make shizzle dat tha return value is
not \s-1NULL\s0 before dereferencin dat shit.
.PP
Da first of these two functions checks if a hash table entry exists, n' tha 
second deletes dat shit.
.PP
.Vb 2
\&    bool  hv_exists(HV*, const char* key, U32 klen);
\&    SV*   hv_delete(HV*, const char* key, U32 klen, I32 flags);
.Ve
.PP
If \f(CW\*(C`flags\*(C'\fR do not include tha \f(CW\*(C`G_DISCARD\*(C'\fR flag then \f(CW\*(C`hv_delete\*(C'\fR will
create n' return a mortal copy of tha deleted value.
.PP
And mo' miscellaneous functions:
.PP
.Vb 2
\&    void   hv_clear(HV*);
\&    void   hv_undef(HV*);
.Ve
.PP
Like they \s-1AV\s0 counterparts, \f(CW\*(C`hv_clear\*(C'\fR deletes all tha entries up in tha hash
table but do not straight-up delete tha hash table.  Da \f(CW\*(C`hv_undef\*(C'\fR deletes
both tha entries n' tha hash table itself.
.PP
Perl keeps tha actual data up in a linked list of structures wit a typedef of \s-1HE.\s0
These contain tha actual key n' value pointas (plus extra administrative
overhead).  Da key be a strang pointer; tha value be a \f(CW\*(C`SV*\*(C'\fR.  However,
once you have a \f(CW\*(C`HE*\*(C'\fR, ta git tha actual key n' value, use tha routines
specified below.
.PP
.Vb 10
\&    I32    hv_iterinit(HV*);
\&            /* Prepares startin point ta traverse hash table */
\&    HE*    hv_iternext(HV*);
\&            /* Git tha next entry, n' return a pointa ta a
\&               structure dat has both tha key n' value */
\&    char*  hv_iterkey(HE* entry, I32* retlen);
\&            /* Git tha key from a HE structure n' also return
\&               tha length of tha key strang */
\&    SV*    hv_iterval(HV*, HE* entry);
\&            /* Return a SV pointa ta tha value of tha HE
\&               structure */
\&    SV*    hv_iternextsv(HV*, char** key, I32* retlen);
\&            /* This convenience routine combines hv_iternext,
\&               hv_iterkey, n' hv_iterval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da key n' retlen
\&               arguments is return joints fo' tha key n' its
\&               length.  Da value is returned up in tha SV* argument */
.Ve
.PP
If you know tha name of a hash variable, you can git a pointa ta its \s-1HV\s0
by rockin tha following:
.PP
.Vb 1
\&    HV*  get_hv("package::varname", 0);
.Ve
.PP
This returns \s-1NULL\s0 if tha variable do not exist.
.PP
Da hash algorithm is defined up in tha \f(CW\*(C`PERL_HASH\*(C'\fR macro:
.PP
.Vb 1
\&    PERL_HASH(hash, key, klen)
.Ve
.PP
Da exact implementation of dis macro varies by architecture n' version
of perl, n' tha return value may chizzle per invocation, so tha value
is only valid fo' tha duration of a single perl process.
.PP
See \*(L"Understandin tha Magic of Tied Hashes n' Arrays\*(R" fo' more
information on how tha fuck ta use tha hash access functions on tied hashes.
.SS "Hash \s-1API\s0 Extensions"
.IX Subsection "Hash API Extensions"
Beginnin wit version 5.004, tha followin functions is also supported:
.PP
.Vb 2
\&    HE*     hv_fetch_ent  (HV* tb, SV* key, I32 lval, U32 hash);
\&    HE*     hv_store_ent  (HV* tb, SV* key, SV* val, U32 hash);
\&
\&    bool    hv_exists_ent (HV* tb, SV* key, U32 hash);
\&    SV*     hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);
\&
\&    SV*     hv_iterkeysv  (HE* entry);
.Ve
.PP
Note dat these functions take \f(CW\*(C`SV*\*(C'\fR keys, which simplifies writing
of extension code dat deals wit hash structures.  These functions
also allow passin of \f(CW\*(C`SV*\*(C'\fR keys ta \f(CW\*(C`tie\*(C'\fR functions without forcing
you ta stringify tha keys (unlike tha previous set of functions).
.PP
They also return n' accept whole hash entries (\f(CW\*(C`HE*\*(C'\fR), makin their
use mo' efficient (since tha hash number fo' a particular string
doesn't gotta be recomputed every last muthafuckin time).  See perlapi fo' detailed
descriptions.
.PP
Da followin macros must always be used ta access tha contentz of hash
entries. Put ya muthafuckin choppers up if ya feel dis!  Note dat tha arguments ta these macros must be simple
variables, since they may git evaluated mo' than once.  See
perlapi fo' detailed descriptionz of these macros.
.PP
.Vb 6
\&    HePV(HE* he, STRLEN len)
\&    HeVAL(HE* he)
\&    HeHASH(HE* he)
\&    HeSVKEY(HE* he)
\&    HeSVKEY_force(HE* he)
\&    HeSVKEY_set(HE* he, SV* sv)
.Ve
.PP
These two lower level macros is defined yo, but must only be used when
dealin wit keys dat is not \f(CW\*(C`SV*\*(C'\fRs:
.PP
.Vb 2
\&    HeKEY(HE* he)
\&    HeKLEN(HE* he)
.Ve
.PP
Note dat both \f(CW\*(C`hv_store\*(C'\fR n' \f(CW\*(C`hv_store_ent\*(C'\fR do not increment the
reference count of tha stored \f(CW\*(C`val\*(C'\fR, which is tha callerz responsibility.
If these functions return a \s-1NULL\s0 value, tha calla will probably have to
decrement tha reference count of \f(CW\*(C`val\*(C'\fR ta avoid a memory leak.
.SS "AVs, HVs n' undefined joints"
.IX Subsection "AVs, HVs n' undefined joints"
Sometimes you gotta store undefined joints up in AVs or HVs fo' realz. Although
this may be a rare case, it can be tricky. Thatz cuz you is
used ta rockin \f(CW&PL_sv_undef\fR if you need a undefined \s-1SV.\s0
.PP
For example, intuizzle  drops some lyrics ta you dat dis \s-1XS\s0 code:
.PP
.Vb 2
\&    AV *av = newAV();
\&    av_store( av, 0, &PL_sv_undef );
.Ve
.PP
is equivalent ta dis Perl code:
.PP
.Vb 2
\&    mah @av;
\&    $av[0] = undef;
.Ve
.PP
Unfortunately, dis aint true fo' realz. AVs use \f(CW&PL_sv_undef\fR as a marker
for indicatin dat a array element has not yet been initialized.
Thus, \f(CW\*(C`exists $av[0]\*(C'\fR would be legit fo' tha above Perl code yo, but
false fo' tha array generated by tha \s-1XS\s0 code.
.PP
Other problems can occur when storin \f(CW&PL_sv_undef\fR up in HVs:
.PP
.Vb 1
\&    hv_store( hv, "key", 3, &PL_sv_undef, 0 );
.Ve
.PP
This will indeed make tha value \f(CW\*(C`undef\*(C'\fR yo, but if you try ta modify
the value of \f(CW\*(C`key\*(C'\fR, you gonna git tha followin error:
.PP
.Vb 1
\&    Modification of non\-creatable hash value attempted
.Ve
.PP
In perl 5.8.0, \f(CW&PL_sv_undef\fR was also used ta mark placeholders
in restricted hashes. This caused such hash entries not ta appear
when iteratin over tha hash or when checkin fo' tha keys
with tha \f(CW\*(C`hv_exists\*(C'\fR function.
.PP
Yo ass can run tha fuck into similar problems when you store \f(CW&PL_sv_yes\fR or
\&\f(CW&PL_sv_no\fR tha fuck into AVs or HVs. Tryin ta modify such elements
will hit you wit tha followin error:
.PP
.Vb 1
\&    Modification of a read\-only value attempted
.Ve
.PP
To cook up a long-ass rap short, you can use tha special variables
\&\f(CW&PL_sv_undef\fR, \f(CW&PL_sv_yes\fR n' \f(CW&PL_sv_no\fR wit AVs and
HVs yo, but you gotta make shizzle you know what tha fuck you bustin.
.PP
Generally, if you wanna store a undefined value up in a \s-1AV\s0
or \s-1HV,\s0 you should not use \f(CW&PL_sv_undef\fR yo, but rather create a
new undefined value rockin tha \f(CW\*(C`newSV\*(C'\fR function, fo' example:
.PP
.Vb 2
\&    av_store( av, 42, newSV(0) );
\&    hv_store( hv, "foo", 3, newSV(0), 0 );
.Ve
.SS "References"
.IX Subsection "References"
References is a special type of scalar dat point ta other data types
(includin other references).
.PP
To create a reference, use either of tha followin functions:
.PP
.Vb 2
\&    SV* newRV_inc((SV*) thang);
\&    SV* newRV_noinc((SV*) thang);
.Ve
.PP
Da \f(CW\*(C`thing\*(C'\fR argument can be any of a \f(CW\*(C`SV*\*(C'\fR, \f(CW\*(C`AV*\*(C'\fR, or \f(CW\*(C`HV*\*(C'\fR.  The
functions is identical except dat \f(CW\*(C`newRV_inc\*(C'\fR increments tha reference
count of tha \f(CW\*(C`thing\*(C'\fR, while \f(CW\*(C`newRV_noinc\*(C'\fR do not.  For historical
reasons, \f(CW\*(C`newRV\*(C'\fR be a synonym fo' \f(CW\*(C`newRV_inc\*(C'\fR.
.PP
Once you gotz a reference, you can use tha followin macro ta dereference
the reference:
.PP
.Vb 1
\&    SvRV(SV*)
.Ve
.PP
then call tha appropriate routines, castin tha returned \f(CW\*(C`SV*\*(C'\fR ta either an
\&\f(CW\*(C`AV*\*(C'\fR or \f(CW\*(C`HV*\*(C'\fR, if required.
.PP
To determine if a \s-1SV\s0 be a reference, you can use tha followin macro:
.PP
.Vb 1
\&    SvROK(SV*)
.Ve
.PP
To discover what tha fuck type of value tha reference refers to, use tha following
macro n' then check tha return value.
.PP
.Vb 1
\&    SvTYPE(SvRV(SV*))
.Ve
.PP
Da most useful types dat is ghon be returned are:
.PP
.Vb 5
\&    < SVt_PVAV  Scalar
\&    SVt_PVAV    Array
\&    SVt_PVHV    Hash
\&    SVt_PVCV    Code
\&    SVt_PVGV    Glob (possibly a gangbangin' file handle)
.Ve
.PP
See \*(L"svtype\*(R" up in perlapi fo' mo' details.
.SS "Blessed References n' Class Objects"
.IX Subsection "Blessed References n' Class Objects"
References is also used ta support object-oriented programming.  In perl's
\&\s-1OO\s0 lexicon, a object is simply a reference dat has been pimped tha fuck into a
package (or class).  Once pimped, tha programmer may now use tha reference
to access tha various methodz up in tha class.
.PP
A reference can be pimped tha fuck into a package wit tha followin function:
.PP
.Vb 1
\&    SV* sv_bless(SV* sv, HV* stash);
.Ve
.PP
Da \f(CW\*(C`sv\*(C'\fR argument must be a reference value.  Da \f(CW\*(C`stash\*(C'\fR argument
specifies which class tha reference will belong to.  See
\&\*(L"Stashes n' Globs\*(R" fo' shiznit on convertin class names tha fuck into stashes.
.PP
/* Still under construction */
.PP
Da followin function upgrades rv ta reference if not already one.
Creates a freshly smoked up \s-1SV\s0 fo' rv ta point to.  If \f(CW\*(C`classname\*(C'\fR is non-null, tha \s-1SV\s0
is pimped tha fuck into tha specified class.  \s-1SV\s0 is returned.
.PP
.Vb 1
\&        SV* newSVrv(SV* rv, const char* classname);
.Ve
.PP
Da followin three functions copy integer, unsigned integer or double
into a \s-1SV\s0 whose reference is \f(CW\*(C`rv\*(C'\fR.  \s-1SV\s0 is pimped if \f(CW\*(C`classname\*(C'\fR is
non-null.
.PP
.Vb 3
\&        SV* sv_setref_iv(SV* rv, const char* classname, IV iv);
\&        SV* sv_setref_uv(SV* rv, const char* classname, UV uv);
\&        SV* sv_setref_nv(SV* rv, const char* classname, NV iv);
.Ve
.PP
Da followin function copies tha pointa value (\fIthe address, not the
string!\fR) tha fuck into a \s-1SV\s0 whose reference is rv.  \s-1SV\s0 is pimped if \f(CW\*(C`classname\*(C'\fR
is non-null.
.PP
.Vb 1
\&        SV* sv_setref_pv(SV* rv, const char* classname, void* pv);
.Ve
.PP
Da followin function copies a strang tha fuck into a \s-1SV\s0 whose reference is \f(CW\*(C`rv\*(C'\fR.
Set length ta 0 ta let Perl calculate tha strang length.  \s-1SV\s0 is pimped if
\&\f(CW\*(C`classname\*(C'\fR is non-null.
.PP
.Vb 2
\&    SV* sv_setref_pvn(SV* rv, const char* classname, char* pv,
\&                                                         STRLEN length);
.Ve
.PP
Da followin function tests whether tha \s-1SV\s0 is pimped tha fuck into tha specified
class.  It do not check inheritizzle relationshizzles.
.PP
.Vb 1
\&        int  sv_isa(SV* sv, const char* name);
.Ve
.PP
Da followin function tests whether tha \s-1SV\s0 be a reference ta a pimped object.
.PP
.Vb 1
\&        int  sv_isobject(SV* sv);
.Ve
.PP
Da followin function tests whether tha \s-1SV\s0 is derived from tha specified
class. \s-1SV\s0 can be either a reference ta a pimped object or a string
containin a cold-ass lil class name. This is tha function implementin the
\&\f(CW\*(C`UNIVERSAL::isa\*(C'\fR functionality.
.PP
.Vb 1
\&        bool sv_derived_from(SV* sv, const char* name);
.Ve
.PP
To check if you've gots a object derived from a specific class you have
to write:
.PP
.Vb 1
\&        if (sv_isobject(sv) && sv_derived_from(sv, class)) { ... }
.Ve
.SS "Creatin New Variables"
.IX Subsection "Creatin New Variables"
To create a freshly smoked up Perl variable wit a undef value which can be accessed from
your Perl script, use tha followin routines, dependin on tha variable type.
.PP
.Vb 3
\&    SV*  get_sv("package::varname", GV_ADD);
\&    AV*  get_av("package::varname", GV_ADD);
\&    HV*  get_hv("package::varname", GV_ADD);
.Ve
.PP
Notice tha use of \s-1GV_ADD\s0 as tha second parameter n' shit.  Da freshly smoked up variable can now
be set, rockin tha routines appropriate ta tha data type.
.PP
There is additionizzle macros whose joints may be bitwise \s-1OR\s0'ed wit the
\&\f(CW\*(C`GV_ADD\*(C'\fR argument ta enable certain extra features.  Those bits are:
.IP "\s-1GV_ADDMULTI\s0" 4
.IX Item "GV_ADDMULTI"
Marks tha variable as multiply defined, thus preventin the:
.Sp
.Vb 1
\&  Name <varname> used only once: possible typo
.Ve
.Sp
warning.
.IP "\s-1GV_ADDWARN\s0" 4
.IX Item "GV_ADDWARN"
Issues tha warning:
.Sp
.Vb 1
\&  Had ta create <varname> unexpectedly
.Ve
.Sp
if tha variable did not exist before tha function was called.
.PP
If you do not specify a package name, tha variable is pimped up in tha current
package.
.SS "Reference Counts n' Mortality"
.IX Subsection "Reference Counts n' Mortality"
Perl uses a reference count-driven garbage collection mechanism. Right back up in yo muthafuckin ass. SVs,
AVs, or HVs (xV fo' short up in tha following) start they game wit a
reference count of 1.  If tha reference count of a xV eva drops ta 0,
then it is ghon be destroyed n' its memory made available fo' reuse.
.PP
This normally don't happen all up in tha Perl level unless a variable is
undef'ed or tha last variable holdin a reference ta it is chizzled or
overwritten. I aint talkin' bout chicken n' gravy biatch.  At tha internal level, however, reference counts can be
manipulated wit tha followin macros:
.PP
.Vb 3
\&    int SvREFCNT(SV* sv);
\&    SV* SvREFCNT_inc(SV* sv);
\&    void SvREFCNT_dec(SV* sv);
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat there is one other function which manipulates tha reference
count of its argument.  Da \f(CW\*(C`newRV_inc\*(C'\fR function, yo big-ass booty is ghon recall,
creates a reference ta tha specified argument.  As a side effect,
it increments tha argumentz reference count.  If dis aint what
you want, use \f(CW\*(C`newRV_noinc\*(C'\fR instead.
.PP
For example, imagine you wanna return a reference from a \s-1XSUB\s0 function.
Inside tha \s-1XSUB\s0 routine, you create a \s-1SV\s0 which initially has a reference
count of one.  Then you call \f(CW\*(C`newRV_inc\*(C'\fR, passin it tha just-created \s-1SV.\s0
This returns tha reference as a freshly smoked up \s-1SV,\s0 but tha reference count of the
\&\s-1SV\s0 you passed ta \f(CW\*(C`newRV_inc\*(C'\fR has been incremented ta two.  Now you
return tha reference from tha \s-1XSUB\s0 routine n' forget bout tha \s-1SV.\s0
But Perl aint son!  Whenever tha returned reference is destroyed, the
reference count of tha original gangsta \s-1SV\s0 is decreased ta one n' not a god damn thang happens.
Da \s-1SV\s0 will hang round without any way ta access it until Perl itself
terminates.  This be a memory leak.
.PP
Da erect procedure, then, is ta use \f(CW\*(C`newRV_noinc\*(C'\fR instead of
\&\f(CW\*(C`newRV_inc\*(C'\fR.  Then, if n' when tha last reference is destroyed,
the reference count of tha \s-1SV\s0 will git all up in zero n' it is ghon be destroyed,
stoppin any memory leak.
.PP
There is some convenience functions available dat can help wit the
destruction of xVs.  These functions introduce tha concept of \*(L"mortality\*(R".
An xV dat is mortal has had its reference count marked ta be decremented,
but not straight-up decremented, until \*(L"a short time later\*(R".  Generally the
term \*(L"short time later\*(R" means a single Perl statement, like fuckin a cold-ass lil call to
an \s-1XSUB\s0 function. I aint talkin' bout chicken n' gravy biatch.  Da actual determinant fo' when mortal xVs have their
reference count decremented dependz on two macros, \s-1SAVETMPS\s0 n' \s-1FREETMPS.\s0
See perlcall n' perlxs fo' mo' details on these macros.
.PP
\&\*(L"Mortalization\*(R" then be at its simplest a thugged-out deferred \f(CW\*(C`SvREFCNT_dec\*(C'\fR.
But fuck dat shiznit yo, tha word on tha street is dat if you mortalize a variable twice, tha reference count will
lata be decremented twice.
.PP
\&\*(L"Mortal\*(R" SVs is mainly used fo' SVs dat is placed on perlz stack.
For example a \s-1SV\s0 which is pimped just ta pass a number ta a cold-ass lil called sub
is made mortal ta have it cleaned up automatically when itz popped off
the stack. Right back up in yo muthafuckin ass. Similarly, thangs up in dis biatch returned by XSUBs (which is pushed on the
stack) is often made mortal.
.PP
To create a mortal variable, use tha functions:
.PP
.Vb 3
\&    SV*  sv_newmortal()
\&    SV*  sv_2mortal(SV*)
\&    SV*  sv_mortalcopy(SV*)
.Ve
.PP
Da first call creates a mortal \s-1SV \s0(with no value), tha second converts a existing
\&\s-1SV\s0 ta a mortal \s-1SV \s0(and thus defers a cold-ass lil call ta \f(CW\*(C`SvREFCNT_dec\*(C'\fR), n' the
third creates a mortal copy of a existin \s-1SV.\s0
Because \f(CW\*(C`sv_newmortal\*(C'\fR gives tha freshly smoked up \s-1SV\s0 no value, it must normally be given one
via \f(CW\*(C`sv_setpv\*(C'\fR, \f(CW\*(C`sv_setiv\*(C'\fR, etc. :
.PP
.Vb 2
\&    SV *tmp = sv_newmortal();
\&    sv_setiv(tmp, an_integer);
.Ve
.PP
As dat is multiple C statements it is like common so peep dis idiom instead:
.PP
.Vb 1
\&    SV *tmp = sv_2mortal(newSViv(an_integer));
.Ve
.PP
Yo ass should be careful bout bustin mortal variables.  Strange thangs
can happen if you make tha same value mortal within multiple contexts,
or if you cook up a variable mortal multiple times. Thinkin of \*(L"Mortalization\*(R"
as deferred \f(CW\*(C`SvREFCNT_dec\*(C'\fR should help ta minimize such problems.
For example if yo ass is passin a \s-1SV\s0 which you \fIknow\fR has a high enough \s-1REFCNT\s0
to survive its use on tha stack you need not do any mortalization.
If yo ass is not shizzle then bustin a \f(CW\*(C`SvREFCNT_inc\*(C'\fR n' \f(CW\*(C`sv_2mortal\*(C'\fR, or
makin a \f(CW\*(C`sv_mortalcopy\*(C'\fR is safer.
.PP
Da mortal routines is not just fo' SVs; AVs n' HVs can be
made mortal by passin they address (type-casted ta \f(CW\*(C`SV*\*(C'\fR) ta the
\&\f(CW\*(C`sv_2mortal\*(C'\fR or \f(CW\*(C`sv_mortalcopy\*(C'\fR routines.
.SS "Stashes n' Globs"
.IX Subsection "Stashes n' Globs"
A \fBstash\fR be a hash dat gotz nuff all variablez dat is defined
within a package.  Each key of tha stash be a symbol
name (shared by all tha different typez of objects dat have tha same
name), n' each value up in tha hash table be a \s-1GV \s0(Glob Value).  This \s-1GV\s0
in turn gotz nuff references ta tha various objectz of dat name,
includin (but not limited to) tha following:
.PP
.Vb 6
\&    Scalar Value
\&    Array Value
\&    Hash Value
\&    I/O Handle
\&    Format
\&    Subroutine
.Ve
.PP
There be a single stash called \f(CW\*(C`PL_defstash\*(C'\fR dat holdz tha shit dat exist
in tha \f(CW\*(C`main\*(C'\fR package.  To git all up in tha shit up in other packages, append the
strin \*(L"::\*(R" ta tha package name.  Da shit up in tha \f(CW\*(C`Foo\*(C'\fR package is in
the stash \f(CW\*(C`Foo::\*(C'\fR up in PL_defstash.  Da shit up in tha \f(CW\*(C`Bar::Baz\*(C'\fR package are
in tha stash \f(CW\*(C`Baz::\*(C'\fR up in \f(CW\*(C`Bar::\*(C'\fRz stash.
.PP
To git tha stash pointa fo' a particular package, use tha function:
.PP
.Vb 2
\&    HV*  gv_stashpv(const char* name, I32 flags)
\&    HV*  gv_stashsv(SV*, I32 flags)
.Ve
.PP
Da first function takes a literal string, tha second uses tha strang stored
in tha \s-1SV. \s0 Remember dat a stash is just a hash table, so you git back an
\&\f(CW\*(C`HV*\*(C'\fR.  Da \f(CW\*(C`flags\*(C'\fR flag will create a freshly smoked up package if it is set ta \s-1GV_ADD.\s0
.PP
Da name dat \f(CW\*(C`gv_stash*v\*(C'\fR wants is tha name of tha package whose symbol table
you want.  Da default package is called \f(CW\*(C`main\*(C'\fR.  If you have multiply nested
packages, pass they names ta \f(CW\*(C`gv_stash*v\*(C'\fR, separated by \f(CW\*(C`::\*(C'\fR as up in tha Perl
language itself.
.PP
Alternately, if you have a \s-1SV\s0 dat be a pimped reference, you can find
out tha stash pointa by using:
.PP
.Vb 1
\&    HV*  SvSTASH(SvRV(SV*));
.Ve
.PP
then use tha followin ta git tha package name itself:
.PP
.Vb 1
\&    char*  HvNAME(HV* stash);
.Ve
.PP
If you need ta bless or re-bless a object you can use tha following
function:
.PP
.Vb 1
\&    SV*  sv_bless(SV*, HV* stash)
.Ve
.PP
where tha straight-up original gangsta argument, a \f(CW\*(C`SV*\*(C'\fR, must be a reference, n' tha second
argument be a stash.  Da returned \f(CW\*(C`SV*\*(C'\fR can now be used up in tha same way
as any other \s-1SV.\s0
.PP
For mo' shiznit on references n' blessings, consult perlref.
.SS "Double-Typed SVs"
.IX Subsection "Double-Typed SVs"
Scalar variablez normally contain only one type of value, a integer,
double, pointer, or reference.  Perl will automatically convert the
actual scalar data from tha stored type tha fuck into tha axed type.
.PP
Some scalar variablez contain mo' than one type of scalar data.  For
example, tha variable \f(CW$!\fR gotz nuff either tha numeric value of \f(CW\*(C`errno\*(C'\fR
or its strang equivalent from either \f(CW\*(C`strerror\*(C'\fR or \f(CW\*(C`sys_errlist[]\*(C'\fR.
.PP
To force multiple data joints tha fuck into a \s-1SV,\s0 you must do two thangs: use the
\&\f(CW\*(C`sv_set*v\*(C'\fR routines ta add tha additionizzle scalar type, then set a gangbangin' flag
so dat Perl will believe it gotz nuff mo' than one type of data.  The
four macros ta set tha flags are:
.PP
.Vb 4
\&        SvIOK_on
\&        SvNOK_on
\&        SvPOK_on
\&        SvROK_on
.Ve
.PP
Da particular macro you must use dependz on which \f(CW\*(C`sv_set*v\*(C'\fR routine
you called first.  This is cuz every last muthafuckin \f(CW\*(C`sv_set*v\*(C'\fR routine turns on
only tha bit fo' tha particular type of data bein set, n' turns off
all tha rest.
.PP
For example, ta create a freshly smoked up Perl variable called \*(L"dberror\*(R" dat gotz nuff
both tha numeric n' descriptizzle strang error joints, you could use the
followin code:
.PP
.Vb 2
\&    extern int  dberror;
\&    extern char *dberror_list;
\&
\&    SV* sv = get_sv("dberror", GV_ADD);
\&    sv_setiv(sv, (IV) dberror);
\&    sv_setpv(sv, dberror_list[dberror]);
\&    SvIOK_on(sv);
.Ve
.PP
If tha order of \f(CW\*(C`sv_setiv\*(C'\fR n' \f(CW\*(C`sv_setpv\*(C'\fR had been reversed, then the
macro \f(CW\*(C`SvPOK_on\*(C'\fR would need ta be called instead of \f(CW\*(C`SvIOK_on\*(C'\fR.
.SS "Magic Variables"
.IX Subsection "Magic Variables"
[This section still under construction. I aint talkin' bout chicken n' gravy biatch.  Ignore every last muthafuckin thang here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Post no
bills.  Everythang not permitted is forbidden.]
.PP
Any \s-1SV\s0 may be magical, dat is, it has special features dat a normal
\&\s-1SV\s0 do not have.  These features is stored up in tha \s-1SV\s0 structure up in a
linked list of \f(CW\*(C`struct magic\*(C'\fR's, typedef'ed ta \f(CW\*(C`MAGIC\*(C'\fR.
.PP
.Vb 10
\&    struct magic {
\&        MAGIC*      mg_moremagic;
\&        MGVTBL*     mg_virtual;
\&        U16         mg_private;
\&        char        mg_type;
\&        U8          mg_flags;
\&        I32         mg_len;
\&        SV*         mg_obj;
\&        char*       mg_ptr;
\&    };
.Ve
.PP
Note dis is current az of patchlevel 0, n' could chizzle at any time.
.SS "Assignin Magic"
.IX Subsection "Assignin Magic"
Perl addz magic ta a \s-1SV\s0 rockin tha sv_magic function:
.PP
.Vb 1
\&  void sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen);
.Ve
.PP
Da \f(CW\*(C`sv\*(C'\fR argument be a pointa ta tha \s-1SV\s0 dat is ta acquire a freshly smoked up magical
feature.
.PP
If \f(CW\*(C`sv\*(C'\fR aint already magical, Perl uses tha \f(CW\*(C`SvUPGRADE\*(C'\fR macro to
convert \f(CW\*(C`sv\*(C'\fR ta type \f(CW\*(C`SVt_PVMG\*(C'\fR. Perl then continues by addin freshly smoked up magic
to tha beginnin of tha linked list of magical features.  Any prior entry
of tha same type of magic is deleted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Note dat dis can be overridden,
and multiple instancez of tha same type of magic can be associated wit an
\&\s-1SV.\s0
.PP
Da \f(CW\*(C`name\*(C'\fR n' \f(CW\*(C`namlen\*(C'\fR arguments is used ta associate a strang with
the magic, typically tha name of a variable. \f(CW\*(C`namlen\*(C'\fR is stored up in the
\&\f(CW\*(C`mg_len\*(C'\fR field n' if \f(CW\*(C`name\*(C'\fR is non-null then either a \f(CW\*(C`savepvn\*(C'\fR copy of
\&\f(CW\*(C`name\*(C'\fR or \f(CW\*(C`name\*(C'\fR itself is stored up in tha \f(CW\*(C`mg_ptr\*(C'\fR field, dependin on
whether \f(CW\*(C`namlen\*(C'\fR is pimped outa than zero or equal ta zero respectively.  As a
special case, if \f(CW\*(C`(name && namlen == HEf_SVKEY)\*(C'\fR then \f(CW\*(C`name\*(C'\fR be assumed
to contain a \f(CW\*(C`SV*\*(C'\fR n' is stored as-is wit its \s-1REFCNT\s0 incremented.
.PP
Da sv_magic function uses \f(CW\*(C`how\*(C'\fR ta determine which, if any, predefined
\&\*(L"Magic Virtual Table\*(R" should be assigned ta tha \f(CW\*(C`mg_virtual\*(C'\fR field.
See tha \*(L"Magic Virtual Tables\*(R" section below.  Da \f(CW\*(C`how\*(C'\fR argument be also
stored up in tha \f(CW\*(C`mg_type\*(C'\fR field. Y'all KNOW dat shit, muthafucka! Da value of \f(CW\*(C`how\*(C'\fR should be chosen
from tha set of macros \f(CW\*(C`PERL_MAGIC_foo\*(C'\fR found up in \fIperl.h\fR. Note dat before
these macros was added, Perl internals used ta directly use character
literals, so you may occasionally come across oldschool code or documentation
referrin ta 'U' magic rather than \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR fo' example.
.PP
Da \f(CW\*(C`obj\*(C'\fR argument is stored up in tha \f(CW\*(C`mg_obj\*(C'\fR field of tha \f(CW\*(C`MAGIC\*(C'\fR
structure.  If it aint tha same as tha \f(CW\*(C`sv\*(C'\fR argument, tha reference
count of tha \f(CW\*(C`obj\*(C'\fR object is incremented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If it is tha same, or if
the \f(CW\*(C`how\*(C'\fR argument is \f(CW\*(C`PERL_MAGIC_arylen\*(C'\fR, or if it aint nuthin but a \s-1NULL\s0 pointer,
then \f(CW\*(C`obj\*(C'\fR is merely stored, without tha reference count bein incremented.
.PP
See also \f(CW\*(C`sv_magicext\*(C'\fR up in perlapi fo' a mo' flexible way ta add magic
to a \s-1SV.\s0
.PP
There be also a gangbangin' function ta add magic ta a \f(CW\*(C`HV\*(C'\fR:
.PP
.Vb 1
\&    void hv_magic(HV *hv, GV *gv, int how);
.Ve
.PP
This simply calls \f(CW\*(C`sv_magic\*(C'\fR n' coerces tha \f(CW\*(C`gv\*(C'\fR argument tha fuck into a \f(CW\*(C`SV\*(C'\fR.
.PP
To remove tha magic from a \s-1SV,\s0 call tha function sv_unmagic:
.PP
.Vb 1
\&    int sv_unmagic(SV *sv, int type);
.Ve
.PP
Da \f(CW\*(C`type\*(C'\fR argument should be equal ta tha \f(CW\*(C`how\*(C'\fR value when tha \f(CW\*(C`SV\*(C'\fR
was initially made magical.
.PP
But fuck dat shiznit yo, tha word on tha street is dat note dat \f(CW\*(C`sv_unmagic\*(C'\fR removes all magic of a cold-ass lil certain \f(CW\*(C`type\*(C'\fR from the
\&\f(CW\*(C`SV\*(C'\fR. If you wanna remove only certain magic of a \f(CW\*(C`type\*(C'\fR based on tha magic
virtual table, use \f(CW\*(C`sv_unmagicext\*(C'\fR instead:
.PP
.Vb 1
\&    int sv_unmagicext(SV *sv, int type, MGVTBL *vtbl);
.Ve
.SS "Magic Virtual Tables"
.IX Subsection "Magic Virtual Tables"
Da \f(CW\*(C`mg_virtual\*(C'\fR field up in tha \f(CW\*(C`MAGIC\*(C'\fR structure be a pointa ta an
\&\f(CW\*(C`MGVTBL\*(C'\fR, which be a structure of function pointas n' standz for
\&\*(L"Magic Virtual Table\*(R" ta handle tha various operations dat might be
applied ta dat variable.
.PP
Da \f(CW\*(C`MGVTBL\*(C'\fR has five (or sometimes eight) pointas ta tha following
routine types:
.PP
.Vb 5
\&    int  (*svt_get)(SV* sv, MAGIC* mg);
\&    int  (*svt_set)(SV* sv, MAGIC* mg);
\&    U32  (*svt_len)(SV* sv, MAGIC* mg);
\&    int  (*svt_clear)(SV* sv, MAGIC* mg);
\&    int  (*svt_free)(SV* sv, MAGIC* mg);
\&
\&    int  (*svt_copy)(SV *sv, MAGIC* mg, SV *nsv,
\&                                          const char *name, I32 namlen);
\&    int  (*svt_dup)(MAGIC *mg, CLONE_PARAMS *param);
\&    int  (*svt_local)(SV *nsv, MAGIC *mg);
.Ve
.PP
This \s-1MGVTBL\s0 structure is set at compile-time up in \fIperl.h\fR n' there are
currently 32 types.  These different structures contain pointas ta various
routines dat big-ass up additionizzle actions dependin on which function is
bein called.
.PP
.Vb 8
\&   Function pointa    Action taken
\&   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-
\&   svt_get             Do suttin' before tha value of tha SV is
\&                       retrieved.
\&   svt_set             Do suttin' afta tha SV be assigned a value.
\&   svt_len             Report on tha SV\*(Aqs length.
\&   svt_clear           Clear suttin' tha SV represents.
\&   svt_free            Jacked any extra storage associated wit tha SV.
\&
\&   svt_copy            copy tied variable magic ta a tied element
\&   svt_dup             duplicate a magic structure durin thread cloning
\&   svt_local           copy magic ta local value durin \*(Aqlocal\*(Aq
.Ve
.PP
For instance, tha \s-1MGVTBL\s0 structure called \f(CW\*(C`vtbl_sv\*(C'\fR (which corresponds
to a \f(CW\*(C`mg_type\*(C'\fR of \f(CW\*(C`PERL_MAGIC_sv\*(C'\fR) gotz nuff:
.PP
.Vb 1
\&    { magic_get, magic_set, magic_len, 0, 0 }
.Ve
.PP
Thus, when a \s-1SV\s0 is determined ta be magical n' of type \f(CW\*(C`PERL_MAGIC_sv\*(C'\fR,
if a git operation is bein performed, tha routine \f(CW\*(C`magic_get\*(C'\fR is
called. Y'all KNOW dat shit, muthafucka!  All tha various routines fo' tha various magical types begin
with \f(CW\*(C`magic_\*(C'\fR.  \s-1NOTE:\s0 tha magic routines is not considered part of
the Perl \s-1API,\s0 n' may not be exported by tha Perl library.
.PP
Da last three slots is a recent addition, n' fo' source code
compatibilitizzle they is only checked fo' if one of tha three flags
MGf_COPY, MGf_DUP or MGf_LOCAL is set up in mg_flags. This means dat most
code can continue declarin a vtable as a 5\-element value. These three are
currently used exclusively by tha threadin code, n' is highly subject
to chizzle.
.PP
Da current kindz of Magic Virtual Tablez are:
.PP
.Vb 10
\& mg_type
\& (old\-style char n' macro)   MGVTBL         Type of magic
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-         \-\-\-\-\-\-\-\-\-\-\-\-\-
\& \e0 PERL_MAGIC_sv             vtbl_sv        Special scalar variable
\& #  PERL_MAGIC_arylen         vtbl_arylen    Array length ($#ary)
\& %  PERL_MAGIC_rhash          (none)         extra data fo' restricted
\&                                             hashes
\& &  PERL_MAGIC_proto          (none)         mah sub prototype CV
\& .  PERL_MAGIC_pos            vtbl_pos       pos() lvalue
\& :  PERL_MAGIC_symtab         (none)         extra data fo' symbol
\&                                             tables
\& <  PERL_MAGIC_backref        vtbl_backref   fo' weak ref data
\& @  PERL_MAGIC_arylen_p       (none)         ta move arylen outta XPVAV
\& B  PERL_MAGIC_bm             vtbl_regexp    Boyer\-Moore 
\&                                             (fast strang search)
\& c  PERL_MAGIC_overload_table vtbl_ovrld     Holdz overload table 
\&                                             (AMT) on stash
\& D  PERL_MAGIC_regdata        vtbl_regdata   Regex match posizzle data 
\&                                             (@+ n' @\- vars)
\& d  PERL_MAGIC_regdatum       vtbl_regdatum  Regex match posizzle data
\&                                             element
\& E  PERL_MAGIC_env            vtbl_env       %ENV hash
\& e  PERL_MAGIC_envelem        vtbl_envelem   %ENV hash element
\& f  PERL_MAGIC_fm             vtbl_regexp    Formline 
\&                                             (\*(Aqcompiled\*(Aq format)
\& g  PERL_MAGIC_regex_global   vtbl_mglob     m//g target
\& H  PERL_MAGIC_hints          vtbl_hints     %^H hash
\& h  PERL_MAGIC_hintselem      vtbl_hintselem %^H hash element
\& I  PERL_MAGIC_isa            vtbl_isa       @ISA array
\& i  PERL_MAGIC_isaelem        vtbl_isaelem   @ISA array element
\& k  PERL_MAGIC_nkeys          vtbl_nkeys     scalar(keys()) lvalue
\& L  PERL_MAGIC_dbfile         (none)         Debugger %_<filename
\& l  PERL_MAGIC_dbline         vtbl_dbline    Debugger %_<filename
\&                                             element
\& N  PERL_MAGIC_shared         (none)         Shared between threads
\& n  PERL_MAGIC_shared_scalar  (none)         Shared between threads
\& o  PERL_MAGIC_collxfrm       vtbl_collxfrm  Locale transformation
\& P  PERL_MAGIC_tied           vtbl_pack      Tied array or hash
\& p  PERL_MAGIC_tiedelem       vtbl_packelem  Tied array or hash element
\& q  PERL_MAGIC_tiedscalar     vtbl_packelem  Tied scalar or handle
\& r  PERL_MAGIC_qr             vtbl_regexp    precompiled qr// regex
\& S  PERL_MAGIC_sig            (none)         %SIG hash
\& s  PERL_MAGIC_sigelem        vtbl_sigelem   %SIG hash element
\& t  PERL_MAGIC_taint          vtbl_taint     Taintedness
\& U  PERL_MAGIC_uvar           vtbl_uvar      Available fo' use by
\&                                             extensions
\& u  PERL_MAGIC_uvar_elem      (none)         Reserved fo' use by
\&                                             extensions
\& V  PERL_MAGIC_vstrin        (none)         SV was vstrin literal
\& v  PERL_MAGIC_vec            vtbl_vec       vec() lvalue
\& w  PERL_MAGIC_utf8           vtbl_utf8      Cached UTF\-8 shiznit
\& x  PERL_MAGIC_substr         vtbl_substr    substr() lvalue
\& y  PERL_MAGIC_defelem        vtbl_defelem   Shadow "foreach" iterator
\&                                             variable / smart-ass parameter
\&                                             vivification
\& ]  PERL_MAGIC_checkcall      vtbl_checkcall inlining/mutation of call
\&                                             ta dis CV
\& ~  PERL_MAGIC_ext            (none)         Available fo' use by
\&                                             extensions
.Ve
.PP
When a uppercase n' lowercase letta both exist up in tha table, then the
uppercase letta is typically used ta represent some kind of composite type
(a list or a hash), n' tha lowercase letta is used ta represent a element
of dat composite type. Right back up in yo muthafuckin ass. Some internals code make use of dis case
relationship.  But fuck dat shiznit yo, tha word on tha street is dat 'v' n' 'V' (vec n' v\-string) is up in no way related.
.PP
Da \f(CW\*(C`PERL_MAGIC_ext\*(C'\fR n' \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR magic types is defined
specifically fo' use by extensions n' aint gonna be used by perl itself.
Extensions can use \f(CW\*(C`PERL_MAGIC_ext\*(C'\fR magic ta 'attach' private shiznit
to variablez (typically objects).  This is especially useful cuz
there is no way fo' aiiight perl code ta corrupt dis private shiznit
(unlike rockin extra elementz of a hash object).
.PP
Similarly, \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR magic can be used much like \fItie()\fR ta booty-call a
C function any time a scalarz value is used or chizzled. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`MAGIC\*(C'\fR's
\&\f(CW\*(C`mg_ptr\*(C'\fR field points ta a \f(CW\*(C`ufuncs\*(C'\fR structure:
.PP
.Vb 5
\&    struct ufuncs {
\&        I32 (*uf_val)(pTHX_ IV, SV*);
\&        I32 (*uf_set)(pTHX_ IV, SV*);
\&        IV uf_index;
\&    };
.Ve
.PP
When tha \s-1SV\s0 is read from or freestyled to, tha \f(CW\*(C`uf_val\*(C'\fR or \f(CW\*(C`uf_set\*(C'\fR
function is ghon be called wit \f(CW\*(C`uf_index\*(C'\fR as tha straight-up original gangsta arg n' a pointa to
the \s-1SV\s0 as tha second. Y'all KNOW dat shit, muthafucka!  A simple example of how tha fuck ta add \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR
magic is shown below.  Note dat tha ufuncs structure is copied by
sv_magic, so you can safely allocate it on tha stack.
.PP
.Vb 10
\&    void
\&    Umagic(sv)
\&        SV *sv;
\&    PREINIT:
\&        struct ufuncs uf;
\&    CODE:
\&        uf.uf_val   = &my_get_fn;
\&        uf.uf_set   = &my_set_fn;
\&        uf.uf_index = 0;
\&        sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));
.Ve
.PP
Attachin \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR ta arrays is permissible but has no effect.
.PP
For hashes there be a specialized hook dat gives control over hash
keys (but not joints).  This hook calls \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR 'get' magic
if tha \*(L"set\*(R" function up in tha \f(CW\*(C`ufuncs\*(C'\fR structure is \s-1NULL. \s0 Da hook
is activated whenever tha hash be accessed wit a key specified as
an \f(CW\*(C`SV\*(C'\fR all up in tha functions \f(CW\*(C`hv_store_ent\*(C'\fR, \f(CW\*(C`hv_fetch_ent\*(C'\fR,
\&\f(CW\*(C`hv_delete_ent\*(C'\fR, n' \f(CW\*(C`hv_exists_ent\*(C'\fR.  Accessin tha key as a string
all up in tha functions without tha \f(CW\*(C`..._ent\*(C'\fR suffix circumvents the
hook.  See \*(L"\s-1GUTS\*(R"\s0 up in Hash::Util::FieldHash fo' a thugged-out detailed description.
.PP
Note dat cuz multiple extensions may be rockin \f(CW\*(C`PERL_MAGIC_ext\*(C'\fR
or \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR magic, it is blingin fo' extensions ta take
extra care ta avoid conflict.  Typically only rockin tha magic on
objects pimped tha fuck into tha same class as tha extension is sufficient.
For \f(CW\*(C`PERL_MAGIC_ext\*(C'\fR magic, it is probably a phat scam ta define an
\&\f(CW\*(C`MGVTBL\*(C'\fR, even if all its fieldz is ghon be \f(CW0\fR, so dat individual
\&\f(CW\*(C`MAGIC\*(C'\fR pointas can be identified as a particular kind of magic
usin they magic virtual table. \f(CW\*(C`mg_findext\*(C'\fR serves up a easy as fuck  way
to do that:
.PP
.Vb 1
\&    STATIC MGVTBL my_vtbl = { 0, 0, 0, 0, 0, 0, 0, 0 };
\&
\&    MAGIC *mg;
\&    if ((mg = mg_findext(sv, PERL_MAGIC_ext, &my_vtbl))) {
\&        /* dis is straight-up ours, not another module\*(Aqs PERL_MAGIC_ext */
\&        my_priv_data_t *priv = (my_priv_data_t *)mg\->mg_ptr;
\&        ...
\&    }
.Ve
.PP
Also note dat tha \f(CW\*(C`sv_set*()\*(C'\fR n' \f(CW\*(C`sv_cat*()\*(C'\fR functions busted lyrics about
earlier do \fBnot\fR invoke 'set' magic on they targets, n' you can put dat on yo' toast.  This must
be done by tha user either by callin tha \f(CW\*(C`SvSETMAGIC()\*(C'\fR macro after
callin these functions, or by rockin one of tha \f(CW\*(C`sv_set*_mg()\*(C'\fR or
\&\f(CW\*(C`sv_cat*_mg()\*(C'\fR functions.  Similarly, generic C code must call the
\&\f(CW\*(C`SvGETMAGIC()\*(C'\fR macro ta invoke any 'get' magic if they use a \s-1SV\s0
obtained from external sources up in functions dat don't handle magic.
See perlapi fo' a thugged-out description of these functions.
For example, calls ta tha \f(CW\*(C`sv_cat*()\*(C'\fR functions typically need ta be
followed by \f(CW\*(C`SvSETMAGIC()\*(C'\fR yo, but they don't need a prior \f(CW\*(C`SvGETMAGIC()\*(C'\fR
since they implementation handlez 'get' magic.
.SS "Findin Magic"
.IX Subsection "Findin Magic"
.Vb 2
\&    MAGIC *mg_find(SV *sv, int type); /* Findz tha magic pointa of that
\&                                       * type */
.Ve
.PP
This routine returns a pointa ta a \f(CW\*(C`MAGIC\*(C'\fR structure stored up in tha \s-1SV.\s0
If tha \s-1SV\s0 aint gots dat magical feature, \f(CW\*(C`NULL\*(C'\fR is returned. Y'all KNOW dat shit, muthafucka! If the
\&\s-1SV\s0 has multiple instancez of dat magical feature, tha straight-up original gangsta one will be
returned. Y'all KNOW dat shit, muthafucka! \f(CW\*(C`mg_findext\*(C'\fR can be used ta find a \f(CW\*(C`MAGIC\*(C'\fR structure of a \s-1SV\s0
based on both its magic type n' its magic virtual table:
.PP
.Vb 1
\&    MAGIC *mg_findext(SV *sv, int type, MGVTBL *vtbl);
.Ve
.PP
Also, if tha \s-1SV\s0 passed ta \f(CW\*(C`mg_find\*(C'\fR or \f(CW\*(C`mg_findext\*(C'\fR aint of type
SVt_PVMG, Perl may core dump.
.PP
.Vb 1
\&    int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN klen);
.Ve
.PP
This routine checks ta peep what tha fuck typez of magic \f(CW\*(C`sv\*(C'\fR has.  If tha mg_type
field be a uppercase letter, then tha mg_obj is copied ta \f(CW\*(C`nsv\*(C'\fR yo, but
the mg_type field is chizzled ta be tha lowercase letter.
.SS "Understandin tha Magic of Tied Hashes n' Arrays"
.IX Subsection "Understandin tha Magic of Tied Hashes n' Arrays"
Tied hashes n' arrays is magical beastz of tha \f(CW\*(C`PERL_MAGIC_tied\*(C'\fR
magic type.
.PP
\&\s-1WARNING:\s0 Az of tha 5.004 release, proper usage of tha array n' hash
access functions requires understandin all dem caveats, n' you can put dat on yo' toast.  Some
of these caveats is straight-up considered bugs up in tha \s-1API,\s0 ta be fixed
in lata releases, n' is bracketed wit [\s-1MAYCHANGE\s0] below. If
you find yo ass straight-up applyin such shiznit up in dis section, be
aware dat tha behavior may chizzle up in tha future, umm, without warning.
.PP
Da perl tie function associates a variable wit a object dat implements
the various \s-1GET, SET,\s0 etc methods.  To big-ass up tha equivalent of tha perl
tie function from a \s-1XSUB,\s0 you must mimic dis behaviour. Shiiit, dis aint no joke.  Da code below
carries up tha necessary steps \- firstly it creates a freshly smoked up hash, n' then
creates a second hash which it blesses tha fuck into tha class which will implement
the tie methods. Lastly it tizzles tha two hashes together, n' returns a
reference ta tha freshly smoked up tied hash.  Note dat tha code below do \s-1NOT\s0 call the
\&\s-1TIEHASH\s0 method up in tha MyTie class \-
see \*(L"Callin Perl Routines from within C Programs\*(R" fo' details on how
to do all dis bullshit.
.PP
.Vb 10
\&    SV*
\&    mytie()
\&    PREINIT:
\&        HV *hash;
\&        HV *stash;
\&        SV *tie;
\&    CODE:
\&        hash = newHV();
\&        tie = newRV_noinc((SV*)newHV());
\&        stash = gv_stashpv("MyTie", GV_ADD);
\&        sv_bless(tie, stash);
\&        hv_magic(hash, (GV*)tie, PERL_MAGIC_tied);
\&        RETVAL = newRV_noinc(hash);
\&    OUTPUT:
\&        RETVAL
.Ve
.PP
Da \f(CW\*(C`av_store\*(C'\fR function, when given a tied array argument, merely
copies tha magic of tha array onto tha value ta be \*(L"stored\*(R", using
\&\f(CW\*(C`mg_copy\*(C'\fR.  It may also return \s-1NULL,\s0 indicatin dat tha value did not
actually need ta be stored up in tha array.  [\s-1MAYCHANGE\s0] Afta a cold-ass lil call to
\&\f(CW\*(C`av_store\*(C'\fR on a tied array, tha calla will probably need ta call
\&\f(CW\*(C`mg_set(val)\*(C'\fR ta straight-up invoke tha perl level \*(L"\s-1STORE\*(R"\s0 method on the
\&\s-1TIEARRAY\s0 object.  If \f(CW\*(C`av_store\*(C'\fR did return \s-1NULL,\s0 a cold-ass lil call to
\&\f(CW\*(C`SvREFCNT_dec(val)\*(C'\fR will also be probably necessary ta avoid a memory
leak. [/MAYCHANGE]
.PP
Da previous paragraph be applicable verbatim ta tied hash access rockin the
\&\f(CW\*(C`hv_store\*(C'\fR n' \f(CW\*(C`hv_store_ent\*(C'\fR functions as well.
.PP
\&\f(CW\*(C`av_fetch\*(C'\fR n' tha correspondin hash functions \f(CW\*(C`hv_fetch\*(C'\fR and
\&\f(CW\*(C`hv_fetch_ent\*(C'\fR straight-up return a undefined mortal value whose magic
has been initialized rockin \f(CW\*(C`mg_copy\*(C'\fR.  Note tha value so returned do not
need ta be deallocated, as it be already mortal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  [\s-1MAYCHANGE\s0] But you will
need ta booty-call \f(CW\*(C`mg_get()\*(C'\fR on tha returned value up in order ta straight-up invoke
the perl level \*(L"\s-1FETCH\*(R"\s0 method on tha underlyin \s-1TIE\s0 object.  Similarly,
you may also call \f(CW\*(C`mg_set()\*(C'\fR on tha return value afta possibly assigning
a suitable value ta it rockin \f(CW\*(C`sv_setsv\*(C'\fR,  which will invoke tha \*(L"\s-1STORE\*(R"\s0
method on tha \s-1TIE\s0 object. [/MAYCHANGE]
.PP
[\s-1MAYCHANGE\s0]
In other lyrics, tha array or hash fetch/store functions don't straight-up
fetch n' store actual joints up in tha case of tied arrays n' hashes.  They
merely call \f(CW\*(C`mg_copy\*(C'\fR ta attach magic ta tha joints dat was meant ta be
\&\*(L"stored\*(R" or \*(L"fetched\*(R".  Lata calls ta \f(CW\*(C`mg_get\*(C'\fR n' \f(CW\*(C`mg_set\*(C'\fR actually
do tha thang of invokin tha \s-1TIE\s0 methodz on tha underlyin objects, n' you can put dat on yo' toast.  Thus
the magic mechanizzle currently implements a kind of lazy access ta arrays
and hashes.
.PP
Currently (az of perl version 5.004), use of tha hash n' array access
functions requires tha user ta be aware of whether they is operatin on
\&\*(L"normal\*(R" hashes n' arrays, or on they tied variants, n' you can put dat on yo' toast.  Da \s-1API\s0 may be
changed ta provide mo' transparent access ta both tied n' aiiight data
types up in future versions.
[/MAYCHANGE]
.PP
Yo ass would do well ta KNOW dat tha \s-1TIEARRAY\s0 n' \s-1TIEHASH\s0 intercourses
are mere sugar ta invoke some perl method calls while rockin tha uniform hash
and array syntax.  Da use of dis sugar imposes some overhead (typically
about two ta four extra opcodes per \s-1FETCH/STORE\s0 operation, up in addizzle to
the creation of all tha mortal variablez required ta invoke tha methods).
This overhead is ghon be comparatively lil' small-ass if tha \s-1TIE\s0 methodz is theyselves
substantial yo, but if they is only all dem statements long, tha overhead
will not be insignificant.
.SS "Localizin chizzles"
.IX Subsection "Localizin chizzles"
Perl has a straight-up handy construction
.PP
.Vb 4
\&  {
\&    local $var = 2;
\&    ...
\&  }
.Ve
.PP
This construction is \fIapproximately\fR equivalent to
.PP
.Vb 6
\&  {
\&    mah $oldvar = $var;
\&    $var = 2;
\&    ...
\&    $var = $oldvar;
\&  }
.Ve
.PP
Da freshest difference is dat tha straight-up original gangsta construction would
reinstate tha initial value of \f(CW$var\fR, irrespectizzle of how tha fuck control exits
the block: \f(CW\*(C`goto\*(C'\fR, \f(CW\*(C`return\*(C'\fR, \f(CW\*(C`die\*(C'\fR/\f(CW\*(C`eval\*(C'\fR, etc. Well shiiiit, it aint nuthin but a lil bit
more efficient as well.
.PP
There be a way ta big up a similar task from C via Perl \s-1API:\s0 create a
\&\fIpseudo-block\fR, n' arrange fo' some chizzlez ta be automatically
undone all up in tha end of it, either explicit, or via a non-local exit (via
\&\fIdie()\fR) fo' realz. A \fIblock\fR\-like construct is pimped by a pair of
\&\f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR macros (see \*(L"Returnin a Scalar\*(R" up in perlcall).
Such a cold-ass lil construct may be pimped specially fo' some blingin localized
task, or a existin one (like boundariez of enclosin Perl
subroutine/block, or a existin pair fo' freein TMPs) may be
used. Y'all KNOW dat shit, muthafucka! (In tha second case tha overhead of additionizzle localization must
be almost negligible.) Note dat any \s-1XSUB\s0 be automatically enclosed in
an \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR pair.
.PP
Inside such a \fIpseudo-block\fR tha followin steez be available:
.ie n .IP """SAVEINT(int i)""" 4
.el .IP "\f(CWSAVEINT(int i)\fR" 4
.IX Item "SAVEINT(int i)"
.PD 0
.ie n .IP """SAVEIV(IV i)""" 4
.el .IP "\f(CWSAVEIV(IV i)\fR" 4
.IX Item "SAVEIV(IV i)"
.ie n .IP """SAVEI32(I32 i)""" 4
.el .IP "\f(CWSAVEI32(I32 i)\fR" 4
.IX Item "SAVEI32(I32 i)"
.ie n .IP """SAVELONG(long i)""" 4
.el .IP "\f(CWSAVELONG(long i)\fR" 4
.IX Item "SAVELONG(long i)"
.PD
These macros arrange thangs ta restore tha value of integer variable
\&\f(CW\*(C`i\*(C'\fR all up in tha end of enclosin \fIpseudo-block\fR.
.ie n .IP "SAVESPTR(s)" 4
.el .IP "\f(CWSAVESPTR(s)\fR" 4
.IX Item "SAVESPTR(s)"
.PD 0
.ie n .IP "SAVEPPTR(p)" 4
.el .IP "\f(CWSAVEPPTR(p)\fR" 4
.IX Item "SAVEPPTR(p)"
.PD
These macros arrange thangs ta restore tha value of pointas \f(CW\*(C`s\*(C'\fR and
\&\f(CW\*(C`p\*(C'\fR. \f(CW\*(C`s\*(C'\fR must be a pointa of a type which survives conversion to
\&\f(CW\*(C`SV*\*(C'\fR n' back, \f(CW\*(C`p\*(C'\fR should be able ta survive conversion ta \f(CW\*(C`char*\*(C'\fR
and back.
.ie n .IP """SAVEFREESV(SV *sv)""" 4
.el .IP "\f(CWSAVEFREESV(SV *sv)\fR" 4
.IX Item "SAVEFREESV(SV *sv)"
Da refcount of \f(CW\*(C`sv\*(C'\fR would be decremented all up in tha end of
\&\fIpseudo-block\fR.  This is similar ta \f(CW\*(C`sv_2mortal\*(C'\fR up in dat it be also a
mechanizzle fo' bustin a thugged-out delayed \f(CW\*(C`SvREFCNT_dec\*(C'\fR.  But fuck dat shiznit yo, tha word on tha street is dat while \f(CW\*(C`sv_2mortal\*(C'\fR
extendz tha gametime of \f(CW\*(C`sv\*(C'\fR until tha beginnin of tha next statement,
\&\f(CW\*(C`SAVEFREESV\*(C'\fR extendz it until tha end of tha enclosin scope.  These
lifetimes can be wildly different.
.Sp
Also compare \f(CW\*(C`SAVEMORTALIZESV\*(C'\fR.
.ie n .IP """SAVEMORTALIZESV(SV *sv)""" 4
.el .IP "\f(CWSAVEMORTALIZESV(SV *sv)\fR" 4
.IX Item "SAVEMORTALIZESV(SV *sv)"
Just like \f(CW\*(C`SAVEFREESV\*(C'\fR yo, but mortalizes \f(CW\*(C`sv\*(C'\fR all up in tha end of tha current
scope instead of decrementin its reference count.  This probably has the
effect of keepin \f(CW\*(C`sv\*(C'\fR kickin it until tha statement dat called tha currently
live scope has finished executing.
.ie n .IP """SAVEFREEOP(OP *op)""" 4
.el .IP "\f(CWSAVEFREEOP(OP *op)\fR" 4
.IX Item "SAVEFREEOP(OP *op)"
Da \f(CW\*(C`OP *\*(C'\fR is \fIop_free()\fRed all up in tha end of \fIpseudo-block\fR.
.ie n .IP "SAVEFREEPV(p)" 4
.el .IP "\f(CWSAVEFREEPV(p)\fR" 4
.IX Item "SAVEFREEPV(p)"
Da chunk of memory which is pointed ta by \f(CW\*(C`p\*(C'\fR is \fISafefree()\fRed at the
end of \fIpseudo-block\fR.
.ie n .IP """SAVECLEARSV(SV *sv)""" 4
.el .IP "\f(CWSAVECLEARSV(SV *sv)\fR" 4
.IX Item "SAVECLEARSV(SV *sv)"
Clears a slot up in tha current scratchpad which correspondz ta \f(CW\*(C`sv\*(C'\fR at
the end of \fIpseudo-block\fR.
.ie n .IP """SAVEDELETE(HV *hv, char *key, I32 length)""" 4
.el .IP "\f(CWSAVEDELETE(HV *hv, char *key, I32 length)\fR" 4
.IX Item "SAVEDELETE(HV *hv, char *key, I32 length)"
Da key \f(CW\*(C`key\*(C'\fR of \f(CW\*(C`hv\*(C'\fR is deleted all up in tha end of \fIpseudo-block\fR. The
strin pointed ta by \f(CW\*(C`key\*(C'\fR is \fISafefree()\fRed. Y'all KNOW dat shit, muthafucka!  If one has a \fIkey\fR in
short-lived storage, tha correspondin strang may be reallocated like
this:
.Sp
.Vb 1
\&  SAVEDELETE(PL_defstash, savepv(tmpbuf), strlen(tmpbuf));
.Ve
.ie n .IP """SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)""" 4
.el .IP "\f(CWSAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)\fR" 4
.IX Item "SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)"
At tha end of \fIpseudo-block\fR tha function \f(CW\*(C`f\*(C'\fR is called wit the
only argument \f(CW\*(C`p\*(C'\fR.
.ie n .IP """SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)""" 4
.el .IP "\f(CWSAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)\fR" 4
.IX Item "SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)"
At tha end of \fIpseudo-block\fR tha function \f(CW\*(C`f\*(C'\fR is called wit the
implicit context argument (if any), n' \f(CW\*(C`p\*(C'\fR.
.ie n .IP """SAVESTACK_POS()""" 4
.el .IP "\f(CWSAVESTACK_POS()\fR" 4
.IX Item "SAVESTACK_POS()"
Da current offset on tha Perl internal stack (cf. \f(CW\*(C`SP\*(C'\fR) is restored
at tha end of \fIpseudo-block\fR.
.PP
Da followin \s-1API\s0 list gotz nuff functions, thus one needz to
provide pointas ta tha modifiable data explicitly (either C pointers,
or Perlish \f(CW\*(C`GV *\*(C'\fRs).  Where tha above macros take \f(CW\*(C`int\*(C'\fR, a similar
function takes \f(CW\*(C`int *\*(C'\fR.
.ie n .IP """SV* save_scalar(GV *gv)""" 4
.el .IP "\f(CWSV* save_scalar(GV *gv)\fR" 4
.IX Item "SV* save_scalar(GV *gv)"
Equivalent ta Perl code \f(CW\*(C`local $gv\*(C'\fR.
.ie n .IP """AV* save_ary(GV *gv)""" 4
.el .IP "\f(CWAV* save_ary(GV *gv)\fR" 4
.IX Item "AV* save_ary(GV *gv)"
.PD 0
.ie n .IP """HV* save_hash(GV *gv)""" 4
.el .IP "\f(CWHV* save_hash(GV *gv)\fR" 4
.IX Item "HV* save_hash(GV *gv)"
.PD
Similar ta \f(CW\*(C`save_scalar\*(C'\fR yo, but localize \f(CW@gv\fR n' \f(CW%gv\fR.
.ie n .IP """void save_item(SV *item)""" 4
.el .IP "\f(CWvoid save_item(SV *item)\fR" 4
.IX Item "void save_item(SV *item)"
Duplicates tha current value of \f(CW\*(C`SV\*(C'\fR, on tha exit from tha current
\&\f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR \fIpseudo-block\fR will restore tha value of \f(CW\*(C`SV\*(C'\fR
usin tha stored value. Well shiiiit, it don't handle magic. Use \f(CW\*(C`save_scalar\*(C'\fR if
magic be affected.
.ie n .IP """void save_list(SV **sarg, I32 maxsarg)""" 4
.el .IP "\f(CWvoid save_list(SV **sarg, I32 maxsarg)\fR" 4
.IX Item "void save_list(SV **sarg, I32 maxsarg)"
A variant of \f(CW\*(C`save_item\*(C'\fR which takes multiple arguments via a array
\&\f(CW\*(C`sarg\*(C'\fR of \f(CW\*(C`SV*\*(C'\fR of length \f(CW\*(C`maxsarg\*(C'\fR.
.ie n .IP """SV* save_svref(SV **sptr)""" 4
.el .IP "\f(CWSV* save_svref(SV **sptr)\fR" 4
.IX Item "SV* save_svref(SV **sptr)"
Similar ta \f(CW\*(C`save_scalar\*(C'\fR yo, but will reinstate a \f(CW\*(C`SV *\*(C'\fR.
.ie n .IP """void save_aptr(AV **aptr)""" 4
.el .IP "\f(CWvoid save_aptr(AV **aptr)\fR" 4
.IX Item "void save_aptr(AV **aptr)"
.PD 0
.ie n .IP """void save_hptr(HV **hptr)""" 4
.el .IP "\f(CWvoid save_hptr(HV **hptr)\fR" 4
.IX Item "void save_hptr(HV **hptr)"
.PD
Similar ta \f(CW\*(C`save_svref\*(C'\fR yo, but localize \f(CW\*(C`AV *\*(C'\fR n' \f(CW\*(C`HV *\*(C'\fR.
.PP
Da \f(CW\*(C`Alias\*(C'\fR module implements localization of tha basic types within the
\&\fIcallerz scope\fR.  Muthafuckas whoz ass is horny bout how tha fuck ta localize thangs in
the containin scope should take a look there like a muthafucka.
.SH "Subroutines"
.IX Header "Subroutines"
.SS "XSUBs n' tha Argument Stack"
.IX Subsection "XSUBs n' tha Argument Stack"
Da \s-1XSUB\s0 mechanizzle be a simple way fo' Perl programs ta access C subroutines.
An \s-1XSUB\s0 routine gonna git a stack dat gotz nuff tha arguments from tha Perl
program, n' a way ta map from tha Perl data structures ta a C equivalent.
.PP
Da stack arguments is accessible all up in tha \f(CWST(n)\fR macro, which returns
the \f(CW\*(C`n\*(C'\fR'th stack argument.  Argument 0 is tha straight-up original gangsta argument passed up in the
Perl subroutine call.  These arguments is \f(CW\*(C`SV*\*(C'\fR, n' can be used anywhere
an \f(CW\*(C`SV*\*(C'\fR is used.
.PP
Most of tha time, output from tha C routine can be handled all up in use of
the \s-1RETVAL\s0 n' \s-1OUTPUT\s0 directives.  But fuck dat shiznit yo, tha word on tha street is dat there be some cases where the
argument stack aint already long enough ta handle all tha return joints.
An example is tha \s-1POSIX\s0 \fItzname()\fR call, which takes no arguments yo, but returns
two, tha local time unitz standard n' summer time abbreviations.
.PP
To handle dis thang, tha \s-1PPCODE\s0 directizzle is used n' tha stack is
extended rockin tha macro:
.PP
.Vb 1
\&    EXTEND(SP, num);
.Ve
.PP
where \f(CW\*(C`SP\*(C'\fR is tha macro dat represents tha local copy of tha stack pointer,
and \f(CW\*(C`num\*(C'\fR is tha number of elements tha stack should be extended by.
.PP
Now dat there is room on tha stack, joints can be pushed on it rockin \f(CW\*(C`PUSHs\*(C'\fR
macro. Da pushed joints will often need ta be \*(L"mortal\*(R" (See
\&\*(L"Reference Counts n' Mortality\*(R"):
.PP
.Vb 7
\&    PUSHs(sv_2mortal(newSViv(an_integer)))
\&    PUSHs(sv_2mortal(newSVuv(an_unsigned_integer)))
\&    PUSHs(sv_2mortal(newSVnv(a_double)))
\&    PUSHs(sv_2mortal(newSVpv("Some String",0)))
\&    /* Although tha last example is betta freestyled as tha more
\&     * efficient: */
\&    PUSHs(newSVpvs_flags("Some String", SVs_TEMP))
.Ve
.PP
And now tha Perl program callin \f(CW\*(C`tzname\*(C'\fR, tha two joints is ghon be assigned
as in:
.PP
.Vb 1
\&    ($standard_abbrev, $summer_abbrev) = POSIX::tzname;
.Ve
.PP
An alternate (and possibly simpler) method ta pushin joints on tha stack is
to use tha macro:
.PP
.Vb 1
\&    XPUSHs(SV*)
.Ve
.PP
This macro automatically adjusts tha stack fo' you, if needed. Y'all KNOW dat shit, muthafucka!  Thus, you
do not need ta booty-call \f(CW\*(C`EXTEND\*(C'\fR ta extend tha stack.
.PP
Despite they suggestions up in earlier versionz of dis document tha macros
\&\f(CW\*(C`(X)PUSH[iunp]\*(C'\fR is \fInot\fR suited ta XSUBs which return multiple thangs up in dis biatch.
For that, either stick ta tha \f(CW\*(C`(X)PUSHs\*(C'\fR macros shown above, or use tha new
\&\f(CW\*(C`m(X)PUSH[iunp]\*(C'\fR macros instead; peep \*(L"Puttin a C value on Perl stack\*(R".
.PP
For mo' shiznit, consult perlxs n' perlxstut.
.SS "Autoloadin wit XSUBs"
.IX Subsection "Autoloadin wit XSUBs"
If a \s-1AUTOLOAD\s0 routine be a \s-1XSUB,\s0 as wit Perl subroutines, Perl puts the
fully-qualified name of tha autoloaded subroutine up in tha \f(CW$AUTOLOAD\fR variable
of tha \s-1XSUB\s0z package.
.PP
But it also puts tha same ol' dirty shiznit up in certain fieldz of tha \s-1XSUB\s0 itself:
.PP
.Vb 4
\&    HV *stash           = CvSTASH(cv);
\&    const char *subname = SvPVX(cv);
\&    STRLEN name_length  = SvCUR(cv); /* up in bytes */
\&    U32 is_utf8         = SvUTF8(cv);
.Ve
.PP
\&\f(CW\*(C`SvPVX(cv)\*(C'\fR gotz nuff just tha sub name itself, not includin tha package.
For a \s-1AUTOLOAD\s0 routine up in \s-1UNIVERSAL\s0 or one of its superclasses,
\&\f(CW\*(C`CvSTASH(cv)\*(C'\fR returns \s-1NULL\s0 durin a method call on a nonexistent package.
.PP
\&\fBNote\fR: Settin \f(CW$AUTOLOAD\fR stopped hustlin up in 5.6.1, which did not support
\&\s-1XS AUTOLOAD\s0 subs at all.  Perl 5.8.0 introduced tha use of fieldz up in the
\&\s-1XSUB\s0 itself.  Perl 5.16.0 restored tha settin of \f(CW$AUTOLOAD\fR.  If you need
to support 5.8\-5.14, use tha \s-1XSUB\s0z fields.
.SS "Callin Perl Routines from within C Programs"
.IX Subsection "Callin Perl Routines from within C Programs"
There is four routines dat can be used ta booty-call a Perl subroutine from
within a C program.  These four are:
.PP
.Vb 4
\&    I32  call_sv(SV*, I32);
\&    I32  call_pv(const char*, I32);
\&    I32  call_method(const char*, I32);
\&    I32  call_argv(const char*, I32, char**);
.Ve
.PP
Da routine most often used is \f(CW\*(C`call_sv\*(C'\fR.  Da \f(CW\*(C`SV*\*(C'\fR argument
gotz nuff either tha name of tha Perl subroutine ta be called, or a
reference ta tha subroutine.  Da second argument consistz of flags
that control tha context up in which tha subroutine is called, whether
or not tha subroutine is bein passed arguments, how tha fuck errors should be
trapped, n' how tha fuck ta treat return joints.
.PP
All four routines return tha number of arguments dat tha subroutine returned
on tha Perl stack.
.PP
These routines used ta be called \f(CW\*(C`perl_call_sv\*(C'\fR, etc., before Perl v5.6.0,
but dem names is now deprecated; macroz of tha same name is provided for
compatibility.
.PP
When rockin any of these routines (except \f(CW\*(C`call_argv\*(C'\fR), tha programmer
must manipulate tha Perl stack.  These include tha followin macros and
functions:
.PP
.Vb 11
\&    dSP
\&    SP
\&    PUSHMARK()
\&    PUTBACK
\&    SPAGAIN
\&    ENTER
\&    SAVETMPS
\&    FREETMPS
\&    LEAVE
\&    XPUSH*()
\&    POP*()
.Ve
.PP
For a thugged-out detailed description of callin conventions from C ta Perl,
consult perlcall.
.SS "Memory Allocation"
.IX Subsection "Memory Allocation"
\fIAllocation\fR
.IX Subsection "Allocation"
.PP
All memory meant ta be used wit tha Perl \s-1API\s0 functions should be manipulated
usin tha macros busted lyrics bout up in dis section. I aint talkin' bout chicken n' gravy biatch.  Da macros provide tha necessary
transparency between differences up in tha actual malloc implementation dat is
used within perl.
.PP
It be suggested dat you enable tha version of malloc dat is distributed
with Perl.  It keeps poolz of various sizez of unallocated memory in
order ta satisfy allocation requests mo' doggystyle.  But fuck dat shiznit yo, tha word on tha street is dat on some
platforms, it may cause spurious malloc or free errors.
.PP
Da followin three macros is used ta initially allocate memory :
.PP
.Vb 3
\&    Newx(pointer, number, type);
\&    Newxc(pointer, number, type, cast);
\&    Newxz(pointer, number, type);
.Ve
.PP
Da first argument \f(CW\*(C`pointer\*(C'\fR should be tha name of a variable dat will
point ta tha newly allocated memory.
.PP
Da second n' third arguments \f(CW\*(C`number\*(C'\fR n' \f(CW\*(C`type\*(C'\fR specify how tha fuck nuff of
the specified type of data structure should be allocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da argument
\&\f(CW\*(C`type\*(C'\fR is passed ta \f(CW\*(C`sizeof\*(C'\fR.  Da final argument ta \f(CW\*(C`Newxc\*(C'\fR, \f(CW\*(C`cast\*(C'\fR,
should be used if tha \f(CW\*(C`pointer\*(C'\fR argument is different from tha \f(CW\*(C`type\*(C'\fR
argument.
.PP
Unlike tha \f(CW\*(C`Newx\*(C'\fR n' \f(CW\*(C`Newxc\*(C'\fR macros, tha \f(CW\*(C`Newxz\*(C'\fR macro calls \f(CW\*(C`memzero\*(C'\fR
to zero up all tha newly allocated memory.
.PP
\fIReallocation\fR
.IX Subsection "Reallocation"
.PP
.Vb 3
\&    Renew(pointer, number, type);
\&    Renewc(pointer, number, type, cast);
\&    Safefree(pointer)
.Ve
.PP
These three macros is used ta chizzle a memory buffer size or ta free a
piece of memory no longer needed. Y'all KNOW dat shit, muthafucka!  Da arguments ta \f(CW\*(C`Renew\*(C'\fR n' \f(CW\*(C`Renewc\*(C'\fR
match dem of \f(CW\*(C`New\*(C'\fR n' \f(CW\*(C`Newc\*(C'\fR wit tha exception of not needin the
\&\*(L"magic cookie\*(R" argument.
.PP
\fIMoving\fR
.IX Subsection "Moving"
.PP
.Vb 3
\&    Move(source, dest, number, type);
\&    Copy(source, dest, number, type);
\&    Zero(dest, number, type);
.Ve
.PP
These three macros is used ta move, copy, or zero up previously allocated
memory.  Da \f(CW\*(C`source\*(C'\fR n' \f(CW\*(C`dest\*(C'\fR arguments point ta tha source and
destination startin points, n' you can put dat on yo' toast.  Perl will move, copy, or zero up \f(CW\*(C`number\*(C'\fR
instancez of tha size of tha \f(CW\*(C`type\*(C'\fR data structure (usin tha \f(CW\*(C`sizeof\*(C'\fR
function).
.SS "PerlIO"
.IX Subsection "PerlIO"
Da most recent pimpment releasez of Perl done been fuckin wit with
removin Perlz dependency on tha \*(L"normal\*(R" standard I/O suite n' allowing
other stdio implementations ta be used. Y'all KNOW dat shit, muthafucka!  This involves bustin a new
abstraction layer dat then calls whichever implementation of stdio Perl
was compiled with.  All XSUBs should now use tha functions up in tha PerlIO
abstraction layer n' not make any assumptions bout what tha fuck kind of stdio
is bein used.
.PP
For a cold-ass lil complete description of tha PerlIO abstraction, consult perlapio.
.SS "Puttin a C value on Perl stack"
.IX Subsection "Puttin a C value on Perl stack"
All dem opcodes (this be a elementary operation up in tha internal perl
stack machine) put a SV* on tha stack. But fuck dat shiznit yo, tha word on tha street is dat as a optimization
the correspondin \s-1SV\s0 is (usually) not recreated each time. Da opcodes
reuse specially assigned SVs (\fItarget\fRs) which is (as a cold-ass lil corollary)
not constantly freed/created.
.PP
Each of tha targets is pimped only once (but see
\&\*(L"Scratchpadz n' recursion\*(R" below), n' when a opcode need ta put
an integer, a thugged-out double, or a strang on stack, it just sets the
correspondin partz of its \fItarget\fR n' puts tha \fItarget\fR on stack.
.PP
Da macro ta put dis target on stack is \f(CW\*(C`PUSHTARG\*(C'\fR, n' it is
directly used up in some opcodes, as well as indirectly up in zillions of
others, which use it via \f(CW\*(C`(X)PUSH[iunp]\*(C'\fR.
.PP
Because tha target is reused, you must be careful when pushin multiple
values on tha stack. Da followin code aint gonna do what tha fuck you think:
.PP
.Vb 2
\&    XPUSHi(10);
\&    XPUSHi(20);
.Ve
.PP
This translates as "set \f(CW\*(C`TARG\*(C'\fR ta 10, push a pointa ta \f(CW\*(C`TARG\*(C'\fR onto
the stack; set \f(CW\*(C`TARG\*(C'\fR ta 20, push a pointa ta \f(CW\*(C`TARG\*(C'\fR onto tha stack".
At tha end of tha operation, tha stack do not contain tha joints 10
and 20 yo, but straight-up gotz nuff two pointas ta \f(CW\*(C`TARG\*(C'\fR, which our crazy asses have set
to 20.
.PP
If you need ta push multiple different joints then you should either use
the \f(CW\*(C`(X)PUSHs\*(C'\fR macros, or else use tha freshly smoked up \f(CW\*(C`m(X)PUSH[iunp]\*(C'\fR macros,
none of which make use of \f(CW\*(C`TARG\*(C'\fR.  Da \f(CW\*(C`(X)PUSHs\*(C'\fR macros simply push an
SV* on tha stack, which, as noted under \*(L"XSUBs n' tha Argument Stack\*(R",
will often need ta be \*(L"mortal\*(R".  Da freshly smoked up \f(CW\*(C`m(X)PUSH[iunp]\*(C'\fR macros make
this a lil easier ta big up by bustin a freshly smoked up mortal fo' you (via
\&\f(CW\*(C`(X)PUSHmortal\*(C'\fR), pushin dat onto tha stack (extendin it if necessary
in tha case of tha \f(CW\*(C`mXPUSH[iunp]\*(C'\fR macros), n' then settin its value.
Thus, instead of freestylin dis ta \*(L"fix\*(R" tha example above:
.PP
.Vb 2
\&    XPUSHs(sv_2mortal(newSViv(10)))
\&    XPUSHs(sv_2mortal(newSViv(20)))
.Ve
.PP
you can simply write:
.PP
.Vb 2
\&    mXPUSHi(10)
\&    mXPUSHi(20)
.Ve
.PP
On a related note, if you do use \f(CW\*(C`(X)PUSH[iunp]\*(C'\fR, then you goin to
need a \f(CW\*(C`dTARG\*(C'\fR up in yo' variable declarations so dat tha \f(CW\*(C`*PUSH*\*(C'\fR
macros can make use of tha local variable \f(CW\*(C`TARG\*(C'\fR.  See also \f(CW\*(C`dTARGET\*(C'\fR
and \f(CW\*(C`dXSTARG\*(C'\fR.
.SS "Scratchpads"
.IX Subsection "Scratchpads"
Da question remains on when tha SVs which is \fItarget\fRs fo' opcodes
are pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da answer is dat they is pimped when tha current
unit\*(--a subroutine or a gangbangin' file (for opcodes fo' statements outside of
subroutines)\-\-is compiled. Y'all KNOW dat shit, muthafucka! Durin dis time a special anonymous Perl
array is pimped, which is called a scratchpad fo' tha current unit.
.PP
A scratchpad keeps SVs which is lexicals fo' tha current unit n' are
targets fo' opcodes. One can deduce dat a \s-1SV\s0 lives on a scratchpad
by lookin on its flags: lexicals have \f(CW\*(C`SVs_PADMY\*(C'\fR set, and
\&\fItarget\fRs have \f(CW\*(C`SVs_PADTMP\*(C'\fR set.
.PP
Da correspondence between OPs n' \fItarget\fRs aint 1\-to\-1. Different
OPs up in tha compile tree of tha unit can use tha same target, if this
would not conflict wit tha expected game of tha temporary.
.SS "Scratchpadz n' recursion"
.IX Subsection "Scratchpadz n' recursion"
In fact it aint 100% legit dat a cold-ass lil compiled unit gotz nuff a pointa to
the scratchpad \s-1AV.\s0 In fact it gotz nuff a pointa ta a \s-1AV\s0 of
(initially) one element, n' dis element is tha scratchpad \s-1AV.\s0 Why do
we need a extra level of indirection?
.PP
Da answer is \fBrecursion\fR, n' maybe \fBthreads\fR. Both
these can create nuff muthafuckin execution pointas goin tha fuck into tha same
subroutine. For tha subroutine-child not write over tha temporaries
for tha subroutine-parent (lifespan of which covers tha call ta the
child), tha parent n' tha lil pimp should have different
scratchpads. (\fIAnd\fR tha lexicals should be separate anyway!)
.PP
So each subroutine is born wit a array of scratchpadz (of length 1).
On each entry ta tha subroutine it is checked dat tha current
depth of tha recursion aint mo' than tha length of dis array, and
if it is, freshly smoked up scratchpad is pimped n' pushed tha fuck into tha array.
.PP
Da \fItarget\fRs on dis scratchpad is \f(CW\*(C`undef\*(C'\fRs yo, but they is already
marked wit erect flags.
.SH "Compiled code"
.IX Header "Compiled code"
.SS "Code tree"
.IX Subsection "Code tree"
Here our phat asses describe tha internal form yo' code is converted ta by
Perl. Right back up in yo muthafuckin ass. Start wit a simple example:
.PP
.Vb 1
\&  $a = $b + $c;
.Ve
.PP
This is converted ta a tree similar ta dis one:
.PP
.Vb 5
\&             assign\-to
\&           /           \e
\&          +             $a
\&        /   \e
\&      $b     $c
.Ve
.PP
(but slightly mo' fucked up).  This tree reflects tha way Perl
parsed yo' code yo, but has not a god damn thang ta do wit tha execution order.
There be a additionizzle \*(L"thread\*(R" goin all up in tha nodez of tha tree
which shows tha order of execution of tha nodes.  In our simplified
example above it looks like:
.PP
.Vb 1
\&     $b \-\-\-> $c \-\-\-> + \-\-\-> $a \-\-\-> assign\-to
.Ve
.PP
But wit tha actual compile tree fo' \f(CW\*(C`$a = $b + $c\*(C'\fR it is different:
some nodes \fIoptimized away\fR.  As a cold-ass lil corollary, though tha actual tree
gotz nuff mo' nodes than our simplified example, tha execution order
is tha same ol' dirty as up in our example.
.SS "Examinin tha tree"
.IX Subsection "Examinin tha tree"
If you have yo' perl compiled fo' debuggin (usually done with
\&\f(CW\*(C`\-DDEBUGGING\*(C'\fR on tha \f(CW\*(C`Configure\*(C'\fR command line), you may examine the
compiled tree by specifyin \f(CW\*(C`\-Dx\*(C'\fR on tha Perl command line.  The
output takes nuff muthafuckin lines per node, n' fo' \f(CW\*(C`$b+$c\*(C'\fR it looks like
this:
.PP
.Vb 10
\&    5           TYPE = add  ===> 6
\&                TARG = 1
\&                FLAGS = (SCALAR,KIDS)
\&                {
\&                    TYPE = null  ===> (4)
\&                      (was rv2sv)
\&                    FLAGS = (SCALAR,KIDS)
\&                    {
\&    3                   TYPE = gvsv  ===> 4
\&                        FLAGS = (SCALAR)
\&                        GV = main::b
\&                    }
\&                }
\&                {
\&                    TYPE = null  ===> (5)
\&                      (was rv2sv)
\&                    FLAGS = (SCALAR,KIDS)
\&                    {
\&    4                   TYPE = gvsv  ===> 5
\&                        FLAGS = (SCALAR)
\&                        GV = main::c
\&                    }
\&                }
.Ve
.PP
This tree has 5 nodes (one per \f(CW\*(C`TYPE\*(C'\fR specifier), only 3 of dem are
not optimized away (one per number up in tha left column).  Da immediate
lil pimpz of tha given node correspond ta \f(CW\*(C`{}\*(C'\fR pairs on tha same level
of indentation, thus dis listin correspondz ta tha tree:
.PP
.Vb 5
\&                   add
\&                 /     \e
\&               null    null
\&                |       |
\&               gvsv    gvsv
.Ve
.PP
Da execution order is indicated by \f(CW\*(C`===>\*(C'\fR marks, thus it is \f(CW\*(C`3
4 5 6\*(C'\fR (node \f(CW6\fR aint included tha fuck into above listing), i.e.,
\&\f(CW\*(C`gvsv gvsv add whatever\*(C'\fR.
.PP
Each of these nodes represents a op, a gangbangin' fundamenstrual operation inside the
Perl core. Da code which implements each operation can be found up in the
\&\fIpp*.c\fR files; tha function which implements tha op wit type \f(CW\*(C`gvsv\*(C'\fR
is \f(CW\*(C`pp_gvsv\*(C'\fR, n' so on. I aint talkin' bout chicken n' gravy biatch fo' realz. As tha tree above shows, different ops have
different numberz of children: \f(CW\*(C`add\*(C'\fR be a funky-ass binary operator, as one would
expect, n' so has two lil' thugs. To accommodate tha various different
numberz of children, there be various typez of op data structure, and
they link together up in different ways.
.PP
Da simplest type of op structure is \f(CW\*(C`OP\*(C'\fR: dis has no lil' thugs. Unary
operators, \f(CW\*(C`UNOP\*(C'\fRs, have one child, n' dis is pointed ta by the
\&\f(CW\*(C`op_first\*(C'\fR field. Y'all KNOW dat shit, muthafucka! Binary operators (\f(CW\*(C`BINOP\*(C'\fRs) aint only an
\&\f(CW\*(C`op_first\*(C'\fR field but also a \f(CW\*(C`op_last\*(C'\fR field. Y'all KNOW dat shit, muthafucka! Da most complex type of
op be a \f(CW\*(C`LISTOP\*(C'\fR, which has any number of lil' thugs. In dis case, the
first lil pimp is pointed ta by \f(CW\*(C`op_first\*(C'\fR n' tha last lil pimp by
\&\f(CW\*(C`op_last\*(C'\fR. Da lil pimps up in between can be found by iteratively
followin tha \f(CW\*(C`op_sibling\*(C'\fR pointa from tha straight-up original gangsta lil pimp ta tha last.
.PP
There is also two other op types: a \f(CW\*(C`PMOP\*(C'\fR holdz a regular expression,
and has no children, n' a \f(CW\*(C`LOOP\*(C'\fR may or may not have lil' thugs. If the
\&\f(CW\*(C`op_children\*(C'\fR field is non-zero, it behaves like a \f(CW\*(C`LISTOP\*(C'\fR. To
complicate matters, if a \f(CW\*(C`UNOP\*(C'\fR is straight-up a \f(CW\*(C`null\*(C'\fR op after
optimization (see \*(L"Compile pass 2: context propagation\*(R") it will still
have lil pimps up in accordizzle wit its forma type.
.PP
Another way ta examine tha tree is ta bust a cold-ass lil compila back-end module, such
as B::Concise.
.SS "Compile pass 1: check routines"
.IX Subsection "Compile pass 1: check routines"
Da tree is pimped by tha compila while \fIyacc\fR code feedz it
the constructions it recognizes. Right back up in yo muthafuckin ass. Since \fIyacc\fR works bottom-up, so do
the first pass of perl compilation.
.PP
What make dis pass bangin-ass fo' perl pimpers is dat some
optimization may be performed on dis pass.  This is optimization by
so-called \*(L"check routines\*(R".  Da correspondence between node names
and correspondin check routines is busted lyrics bout up in \fIopcode.pl\fR (do not
forget ta run \f(CW\*(C`make regen_headers\*(C'\fR if you modify dis file).
.PP
A check routine is called when tha node is straight-up constructed except
for tha execution-order thread. Y'all KNOW dat shit, muthafucka!  Since at dis time there be no
back-links ta tha currently constructed node, one can do most any
operation ta tha top-level node, includin freein it and/or bustin
new nodes above/below dat shit.
.PP
Da check routine returns tha node which should be banged tha fuck into the
tree (if tha top-level node was not modified, check routine returns
its argument).
.PP
By convention, check routines have names \f(CW\*(C`ck_*\*(C'\fR. They is usually
called from \f(CW\*(C`new*OP\*(C'\fR subroutines (or \f(CW\*(C`convert\*(C'\fR) (which up in turn are
called from \fIperly.y\fR).
.SS "Compile pass 1a: constant folding"
.IX Subsection "Compile pass 1a: constant folding"
Immediately afta tha check routine is called tha returned node is
checked fo' bein compile-time executable.  If it is (the value is
judged ta be constant) it is immediately executed, n' a \fIconstant\fR
node wit tha \*(L"return value\*(R" of tha correspondin subtree is
substituted instead. Y'all KNOW dat shit, muthafucka!  Da subtree is deleted.
.PP
If constant foldin was not performed, tha execution-order thread is
created.
.SS "Compile pass 2: context propagation"
.IX Subsection "Compile pass 2: context propagation"
When a cold-ass lil context fo' a part of compile tree is known, it is propagated
down all up in tha tree.  At dis time tha context can have 5 joints
(instead of 2 fo' runtime context): void, boolean, scalar, list, and
lvalue.  In contrast wit tha pass 1 dis pass is processed from top
to bottom: a nodez context determines tha context fo' its lil' thugs.
.PP
Additionizzle context-dependent optimizations is performed at dis time.
Since at dis moment tha compile tree gotz nuff back-references (via
\&\*(L"thread\*(R" pointers), nodes cannot be \fIfree()\fRd now, nahmeean, biatch?  To allow
optimized-away nodes at dis stage, such nodes is \fInull()\fRified instead
of \fIfree()\fRin (i.e. they type is chizzled ta \s-1OP_NULL\s0).
.SS "Compile pass 3: peephole optimization"
.IX Subsection "Compile pass 3: peephole optimization"
Afta tha compile tree fo' a subroutine (or fo' a \f(CW\*(C`eval\*(C'\fR or a gangbangin' file)
is pimped, a additionizzle pass over tha code is performed. Y'all KNOW dat shit, muthafucka! This pass
is neither top-down or bottom-up yo, but up in tha execution order (with
additionizzle complications fo' conditionals).  Optimizations performed
at dis stage is subject ta tha same restrictions as up in tha pass 2.
.PP
Peephole optimizations is done by callin tha function pointed to
by tha global variable \f(CW\*(C`PL_peepp\*(C'\fR.  By default, \f(CW\*(C`PL_peepp\*(C'\fR just
calls tha function pointed ta by tha global variable \f(CW\*(C`PL_rpeepp\*(C'\fR.
By default, dat performs some basic op fixups n' optimisations along
the execution-order op chain, n' recursively calls \f(CW\*(C`PL_rpeepp\*(C'\fR for
each side chain of ops (resultin from conditionals).  Extensions may
provide additionizzle optimisations or fixups, hookin tha fuck into either the
per-subroutine or recursive stage, like this:
.PP
.Vb 10
\&    static peep_t prev_peepp;
\&    static void my_peep(pTHX_ OP *o)
\&    {
\&        /* custom per\-subroutine optimisation goes here */
\&        prev_peepp(aTHX_ o);
\&        /* custom per\-subroutine optimisation may also go here */
\&    }
\&    BOOT:
\&        prev_peepp = PL_peepp;
\&        PL_peepp = my_peep;
\&
\&    static peep_t prev_rpeepp;
\&    static void my_rpeep(pTHX_ OP *o)
\&    {
\&        OP *orig_o = o;
\&        for(; o; o = o\->op_next) {
\&            /* custom per\-op optimisation goes here */
\&        }
\&        prev_rpeepp(aTHX_ orig_o);
\&    }
\&    BOOT:
\&        prev_rpeepp = PL_rpeepp;
\&        PL_rpeepp = my_rpeep;
.Ve
.SS "Pluggable runops"
.IX Subsection "Pluggable runops"
Da compile tree is executed up in a runops function. I aint talkin' bout chicken n' gravy biatch.  There is two runops
functions, up in \fIrun.c\fR n' up in \fIdump.c\fR.  \f(CW\*(C`Perl_runops_debug\*(C'\fR is used
with \s-1DEBUGGING\s0 n' \f(CW\*(C`Perl_runops_standard\*(C'\fR is used otherwise.  For fine
control over tha execution of tha compile tree it is possible ta provide
your own runops function.
.PP
It aint nuthin but probably dopest ta copy one of tha existin runops functions and
change it ta suit yo' needs.  Then, up in tha \s-1BOOT\s0 section of yo' \s-1XS\s0
file, add tha line:
.PP
.Vb 1
\&  PL_runops = my_runops;
.Ve
.PP
This function should be as efficient as possible ta keep yo' programs
runnin as fast as possible.
.SS "Compile-time scope hooks"
.IX Subsection "Compile-time scope hooks"
Az of perl 5.14 it is possible ta hook tha fuck into tha compile-time lexical
scope mechanizzle rockin \f(CW\*(C`Perl_blockhook_register\*(C'\fR. This is used like
this:
.PP
.Vb 2
\&    STATIC void my_start_hook(pTHX_ int full);
\&    STATIC BHK my_hooks;
\&
\&    BOOT:
\&        BhkENTRY_set(&my_hooks, bhk_start, my_start_hook);
\&        Perl_blockhook_register(aTHX_ &my_hooks);
.Ve
.PP
This will arrange ta have \f(CW\*(C`my_start_hook\*(C'\fR called all up in tha start of
compilin every last muthafuckin lexical scope. Da available hooks are:
.ie n .IP """void bhk_start(pTHX_ int full)""" 4
.el .IP "\f(CWvoid bhk_start(pTHX_ int full)\fR" 4
.IX Item "void bhk_start(pTHX_ int full)"
This is called just afta startin a freshly smoked up lexical scope. Note dat Perl
code like
.Sp
.Vb 1
\&    if ($x) { ... }
.Ve
.Sp
creates two scopes: tha straight-up original gangsta starts all up in tha \f(CW\*(C`(\*(C'\fR n' has \f(CW\*(C`full == 1\*(C'\fR,
the second starts all up in tha \f(CW\*(C`{\*(C'\fR n' has \f(CW\*(C`full == 0\*(C'\fR. Both end at the
\&\f(CW\*(C`}\*(C'\fR, so calls ta \f(CW\*(C`start\*(C'\fR n' \f(CW\*(C`pre/post_end\*(C'\fR will match fo' realz. Anything
pushed onto tha save stack by dis hook is ghon be popped just before the
scope endz (between tha \f(CW\*(C`pre_\*(C'\fR n' \f(CW\*(C`post_end\*(C'\fR hooks, up in fact).
.ie n .IP """void bhk_pre_end(pTHX_ OP **o)""" 4
.el .IP "\f(CWvoid bhk_pre_end(pTHX_ OP **o)\fR" 4
.IX Item "void bhk_pre_end(pTHX_ OP **o)"
This is called all up in tha end of a lexical scope, just before unwindin the
stack. \fIo\fR is tha root of tha optree representin tha scope; it be a
double pointa so you can replace tha \s-1OP\s0 if you need to.
.ie n .IP """void bhk_post_end(pTHX_ OP **o)""" 4
.el .IP "\f(CWvoid bhk_post_end(pTHX_ OP **o)\fR" 4
.IX Item "void bhk_post_end(pTHX_ OP **o)"
This is called all up in tha end of a lexical scope, just afta unwindin the
stack. \fIo\fR be as above. Note dat it is possible fo' calls ta \f(CW\*(C`pre_\*(C'\fR
and \f(CW\*(C`post_end\*(C'\fR ta nest, if there is suttin' on tha save stack that
calls strang eval.
.ie n .IP """void bhk_eval(pTHX_ OP *const o)""" 4
.el .IP "\f(CWvoid bhk_eval(pTHX_ OP *const o)\fR" 4
.IX Item "void bhk_eval(pTHX_ OP *const o)"
This is called just before startin ta compile a \f(CW\*(C`eval STRING\*(C'\fR, \f(CW\*(C`do
FILE\*(C'\fR, \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR, afta tha eval has been set up. \fIo\fR is the
\&\s-1OP\s0 dat axed tha eval, n' will normally be a \f(CW\*(C`OP_ENTEREVAL\*(C'\fR,
\&\f(CW\*(C`OP_DOFILE\*(C'\fR or \f(CW\*(C`OP_REQUIRE\*(C'\fR.
.PP
Once you have yo' hook functions, you need a \f(CW\*(C`BHK\*(C'\fR structure ta put
them in. I aint talkin' bout chicken n' gravy biatch. It aint nuthin but dopest ta allocate it statically, since there is no way to
free it once itz registered. Y'all KNOW dat shit, muthafucka! Da function pointas should be inserted
into dis structure rockin tha \f(CW\*(C`BhkENTRY_set\*(C'\fR macro, which will also set
flags indicatin which entries is valid. Y'all KNOW dat shit, muthafucka! If you do need ta allocate
your \f(CW\*(C`BHK\*(C'\fR dynamically fo' some reason, be shizzle ta zero it before you
start.
.PP
Once registered, there is no mechanizzle ta switch these hooks off, so if
that is necessary yo big-ass booty is ghon need ta do dis yo ass fo' realz. An entry up in \f(CW\*(C`%^H\*(C'\fR
is probably tha dopest way, so tha effect is lexically scoped; however it
is also possible ta use tha \f(CW\*(C`BhkDISABLE\*(C'\fR n' \f(CW\*(C`BhkENABLE\*(C'\fR macros to
temporarily switch entries on n' off. Yo ass should also be aware that
generally bustin lyrics at least one scope gonna git opened before your
extension is loaded, so yo big-ass booty is ghon peep some \f(CW\*(C`pre/post_end\*(C'\fR pairs that
didn't gotz a matchin \f(CW\*(C`start\*(C'\fR.
.ie n .SH "Examinin internal data structures wit tha ""dump"" functions"
.el .SH "Examinin internal data structures wit tha \f(CWdump\fP functions"
.IX Header "Examinin internal data structures wit tha dump functions"
To aid debugging, tha source file \fIdump.c\fR gotz nuff a number of
functions which produce formatted output of internal data structures.
.PP
Da most commonly used of these functions is \f(CW\*(C`Perl_sv_dump\*(C'\fR; itz used
for dumpin SVs, AVs, HVs, n' CVs. Da \f(CW\*(C`Devel::Peek\*(C'\fR module calls
\&\f(CW\*(C`sv_dump\*(C'\fR ta produce debuggin output from Perl-space, so playaz of that
module should already be familiar wit its format.
.PP
\&\f(CW\*(C`Perl_op_dump\*(C'\fR can be used ta dump a \f(CW\*(C`OP\*(C'\fR structure or any of its
derivatives, n' produces output similar ta \f(CW\*(C`perl \-Dx\*(C'\fR; up in fact,
\&\f(CW\*(C`Perl_dump_eval\*(C'\fR will dump tha main root of tha code bein evaluated,
exactly like \f(CW\*(C`\-Dx\*(C'\fR.
.PP
Other useful functions is \f(CW\*(C`Perl_dump_sub\*(C'\fR, which turns a \f(CW\*(C`GV\*(C'\fR tha fuck into an
op tree, \f(CW\*(C`Perl_dump_packsubs\*(C'\fR which calls \f(CW\*(C`Perl_dump_sub\*(C'\fR on all the
subroutines up in a package like so: (Thankfully, these is all xsubs, so
there is no op tree)
.PP
.Vb 1
\&    (gdb) print Perl_dump_packsubs(PL_defstash)
\&
\&    SUB attributes::bootstrap = (xsub 0x811fedc 0)
\&
\&    SUB UNIVERSAL::can = (xsub 0x811f50c 0)
\&
\&    SUB UNIVERSAL::isa = (xsub 0x811f304 0)
\&
\&    SUB UNIVERSAL::VERSION = (xsub 0x811f7ac 0)
\&
\&    SUB DynaLoader::boot_DynaLoader = (xsub 0x805b188 0)
.Ve
.PP
and \f(CW\*(C`Perl_dump_all\*(C'\fR, which dumps all tha subroutines up in tha stash and
the op tree of tha main root.
.SH "How tha fuck multiple interpretas n' concurrency is supported"
.IX Header "How tha fuck multiple interpretas n' concurrency is supported"
.SS "Background n' \s-1PERL_IMPLICIT_CONTEXT\s0"
.IX Subsection "Background n' PERL_IMPLICIT_CONTEXT"
Da Perl interpreta can be regarded as a cold-ass lil closed box: it has a \s-1API\s0
for feedin it code or otherwise makin it do thangs yo, but it also has
functions fo' its own use.  This smells a shitload like a object, and
there is ways fo' you ta build Perl so dat you can have multiple
interpreters, wit one interpreta represented either as a C structure,
or inside a thread-specific structure.  These structures contain all
the context, tha state of dat interpreter.
.PP
One macro controls tha major Perl build flavor: \s-1MULTIPLICITY.\s0 The
\&\s-1MULTIPLICITY\s0 build has a C structure dat packages all tha interpreter
state. With multiplicity-enabled perls, \s-1PERL_IMPLICIT_CONTEXT\s0 be also
normally defined, n' enablez tha support fo' passin up in a \*(L"hidden\*(R" first
argument dat represents all three data structures. \s-1MULTIPLICITY\s0 makes
multi-threaded perls possible (with tha ithreadz threadin model, related
to tha macro \s-1USE_ITHREADS.\s0)
.PP
Two other \*(L"encapsulation\*(R" macros is tha \s-1PERL_GLOBAL_STRUCT\s0 and
\&\s-1PERL_GLOBAL_STRUCT_PRIVATE \s0(the latta turns on tha former, n' the
forma turns on \s-1MULTIPLICITY.\s0)  Da \s-1PERL_GLOBAL_STRUCT\s0 causes all the
internal variablez of Perl ta be wrapped inside a single global struct,
struct perl_vars, accessible as (globals) &PL_Vars or PL_VarsPtr or
the function  \fIPerl_GetVars()\fR.  Da \s-1PERL_GLOBAL_STRUCT_PRIVATE\s0 goes
one step further, there is still a single struct (allocated up in \fImain()\fR
either from heap or from stack) but there be no global data symbols
pointin ta dat shit.  In either case tha global struct should be initialised
as tha straight-up first thang up in \fImain()\fR rockin \fIPerl_init_global_struct()\fR and
correspondingly tear it down afta \fIperl_free()\fR rockin \fIPerl_free_global_struct()\fR,
please peep \fIminiperlmain.c\fR fo' usage details.  Yo ass may also need
to use \f(CW\*(C`dVAR\*(C'\fR up in yo' codin ta \*(L"declare tha global variables\*(R"
when yo ass is rockin em.  dTHX do dis fo' you automatically.
.PP
To peep whether you have non-const data you can bust a BSD-compatible \f(CW\*(C`nm\*(C'\fR:
.PP
.Vb 1
\&  nm libperl.a | grep \-v \*(Aq [TURtr] \*(Aq
.Ve
.PP
If dis displays any \f(CW\*(C`D\*(C'\fR or \f(CW\*(C`d\*(C'\fR symbols, you have non-const data.
.PP
For backward compatibilitizzle reasons definin just \s-1PERL_GLOBAL_STRUCT\s0
doesn't straight-up hide all symbols inside a funky-ass big-ass global struct: some
PerlIO_xxx vtablez is left visible.  Da \s-1PERL_GLOBAL_STRUCT_PRIVATE\s0
then hides every last muthafuckin thang (see how tha fuck tha \s-1PERLIO_FUNCS_DECL\s0 is used).
.PP
All dis obviously requires a way fo' tha Perl internal functions ta be
either subroutines takin some kind of structure as tha first
argument, or subroutines takin not a god damn thang as tha straight-up original gangsta argument.  To
enable these two straight-up different wayz of buildin tha interpreter,
the Perl source (as it do up in all kindsa muthafuckin other thangs) make heavy
use of macros n' subroutine namin conventions.
.PP
First problem: decidin which functions is ghon be hood \s-1API\s0 functions and
which is ghon be private.  All functions whose names begin \f(CW\*(C`S_\*(C'\fR is private
(think \*(L"S\*(R" fo' \*(L"secret\*(R" or \*(L"static\*(R").  All other functions begin with
\&\*(L"Perl_\*(R" yo, but just cuz a gangbangin' function begins wit \*(L"Perl_\*(R" do not mean it is
part of tha \s-1API. \s0(See \*(L"Internal Functions\*(R".) Da easiest way ta be \fBsure\fR a
function is part of tha \s-1API\s0 is ta find its entry up in perlapi.
If it exists up in perlapi, itz part of tha \s-1API. \s0 If it don't, n' you
think it should be (i.e., you need it fo' yo' extension), bust mail via
perlbug explainin why you be thinkin it should be.
.PP
Second problem: there must be a syntax so dat tha same subroutine
declarations n' calls can pass a structure as they first argument,
or pass nothing.  To solve this, tha subroutines is named and
declared up in a particular way.  Herez a typical start of a static
function used within tha Perl guts:
.PP
.Vb 2
\&  STATIC void
\&  S_incline(pTHX_ char *s)
.Ve
.PP
\&\s-1STATIC\s0 becomes \*(L"static\*(R" up in C, n' may be #define'd ta not a god damn thang up in some
configurations up in tha future.
.PP
A hood function (i.e. part of tha internal \s-1API,\s0 but not necessarily
sanctioned fo' use up in extensions) begins like this:
.PP
.Vb 2
\&  void
\&  Perl_sv_setiv(pTHX_ SV* dsv, IV num)
.Ve
.PP
\&\f(CW\*(C`pTHX_\*(C'\fR is one of a fuckin shitload of macros (in \fIperl.h\fR) dat hide the
detailz of tha interpreterz context.  \s-1THX\s0 standz fo' \*(L"thread\*(R", \*(L"this\*(R",
or \*(L"thingy\*(R", as tha case may be.  (And no, George Lucas aint involved. Y'all KNOW dat shit, muthafucka! :\-)
Da first characta could be 'p' fo' a \fBp\fRrototype, 'a' fo' \fBa\fRrgument,
or 'd' fo' \fBd\fReclaration, so our crazy asses have \f(CW\*(C`pTHX\*(C'\fR, \f(CW\*(C`aTHX\*(C'\fR n' \f(CW\*(C`dTHX\*(C'\fR, and
their variants.
.PP
When Perl is built without options dat set \s-1PERL_IMPLICIT_CONTEXT,\s0 there is no
first argument containin tha interpreterz context.  Da trailin underscore
in tha pTHX_ macro indicates dat tha macro expansion needz a cold-ass lil comma
afta tha context argument cuz other arguments follow dat shit.  If
\&\s-1PERL_IMPLICIT_CONTEXT\s0 aint defined, pTHX_ is ghon be ignored, n' the
subroutine aint prototyped ta take tha extra argument.  Da form of the
macro without tha trailin underscore is used when there be no additional
explicit arguments.
.PP
When a cold-ass lil core function calls another, it must pass tha context.  This
is normally hidden via macros.  Consider \f(CW\*(C`sv_setiv\*(C'\fR.  It expandz into
suttin' like this:
.PP
.Vb 6
\&    #ifdef PERL_IMPLICIT_CONTEXT
\&      #define sv_setiv(a,b)      Perl_sv_setiv(aTHX_ a, b)
\&      /* can\*(Aqt do dis fo' vararg functions, peep below */
\&    #else
\&      #define sv_setiv           Perl_sv_setiv
\&    #endif
.Ve
.PP
This works well, n' means dat \s-1XS\s0 authors can gleefully write:
.PP
.Vb 1
\&    sv_setiv(foo, bar);
.Ve
.PP
and still have it work under all tha modes Perl could have been
compiled with.
.PP
This don't work so cleanly fo' varargs functions, though, as macros
imply dat tha number of arguments is known up in advance.  Instead we
either need ta spell dem up fully, passin \f(CW\*(C`aTHX_\*(C'\fR as tha first
argument (the Perl core tendz ta do dis wit functions like
Perl_warner), or bust a cold-ass lil context-free version.
.PP
Da context-free version of Perl_warner is called
Perl_warner_nocontext, n' do not take tha extra argument.  Instead
it do dTHX; ta git tha context from thread-local storage.  We
\&\f(CW\*(C`#define warner Perl_warner_nocontext\*(C'\fR so dat extensions git source
compatibilitizzle all up in tha expense of performance.  (Passin a arg is
cheaper than grabbin it from thread-local storage.)
.PP
Yo ass can ignore [pad]THXx when browsin tha Perl headers/sources.
Those is strictly fo' use within tha core.  Extensions n' embedders
need only be aware of [pad]THX.
.SS "So what tha fuck happened ta dTHR?"
.IX Subsection "So what tha fuck happened ta dTHR?"
\&\f(CW\*(C`dTHR\*(C'\fR was introduced up in perl 5.005 ta support tha olda thread model.
Da olda thread model now uses tha \f(CW\*(C`THX\*(C'\fR mechanizzle ta pass context
pointas around, so \f(CW\*(C`dTHR\*(C'\fR aint useful any mo' n' mo' n' mo'.  Perl 5.6.0 and
lata still have it fo' backward source compatibilitizzle yo, but it is defined
to be a no-op.
.SS "How tha fuck do I use all dis up in extensions?"
.IX Subsection "How tha fuck do I use all dis up in extensions?"
When Perl is built wit \s-1PERL_IMPLICIT_CONTEXT,\s0 extensions dat call
any functions up in tha Perl \s-1API\s0 will need ta pass tha initial context
argument somehow.  Da kicker is dat yo big-ass booty is ghon need ta write it in
such a way dat tha extension still compilez when Perl aint been
built wit \s-1PERL_IMPLICIT_CONTEXT\s0 enabled.
.PP
There is three ways ta do all dis bullshit.  First, tha easy as fuck  but inefficient way,
which be also tha default, up in order ta maintain source compatibility
with extensions: whenever \fI\s-1XSUB\s0.h\fR is #included, it redefines tha aTHX
and aTHX_ macros ta booty-call a gangbangin' function dat will return tha context.
Thus, suttin' like:
.PP
.Vb 1
\&        sv_setiv(sv, num);
.Ve
.PP
in yo' extension will translate ta dis when \s-1PERL_IMPLICIT_CONTEXT\s0 is
in effect:
.PP
.Vb 1
\&        Perl_sv_setiv(Perl_get_context(), sv, num);
.Ve
.PP
or ta dis otherwise:
.PP
.Vb 1
\&        Perl_sv_setiv(sv, num);
.Ve
.PP
Yo ass don't gotta do anythang freshly smoked up in yo' extension ta git this; since
the Perl library serves up \fIPerl_get_context()\fR, it will all just
work.
.PP
Da second, mo' efficient way is ta use tha followin template for
your Foo.xs:
.PP
.Vb 4
\&        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
\&        #include "EXTERN.h"
\&        #include "perl.h"
\&        #include "XSUB.h"
\&
\&        STATIC void my_private_function(int arg1, int arg2);
\&
\&        STATIC void
\&        my_private_function(int arg1, int arg2)
\&        {
\&            dTHX;       /* fetch context */
\&            ... call nuff Perl API functions ...
\&        }
\&
\&        [... etc ...]
\&
\&        MODULE = Foo            PACKAGE = Foo
\&
\&        /* typical XSUB */
\&
\&        void
\&        my_xsub(arg)
\&                int arg
\&            CODE:
\&                my_private_function(arg, 10);
.Ve
.PP
Note dat tha only two chizzlez from tha aiiight way of freestylin an
extension is tha addizzle of a \f(CW\*(C`#define PERL_NO_GET_CONTEXT\*(C'\fR before
includin tha Perl headers, followed by a \f(CW\*(C`dTHX;\*(C'\fR declaration at
the start of every last muthafuckin function dat will call tha Perl \s-1API.  \s0(You'll
know which functions need this, cuz tha C compila will complain
that there be a a undeclared identifier up in dem functions.)  No chizzles
are needed fo' tha XSUBs theyselves, cuz tha \s-1\fIXS\s0()\fR macro is
correctly defined ta pass up in tha implicit context if needed.
.PP
Da third, even mo' efficient way is ta ape how tha fuck it is done within
the Perl guts:
.PP
.Vb 4
\&        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
\&        #include "EXTERN.h"
\&        #include "perl.h"
\&        #include "XSUB.h"
\&
\&        /* pTHX_ only needed fo' functions dat call Perl API */
\&        STATIC void my_private_function(pTHX_ int arg1, int arg2);
\&
\&        STATIC void
\&        my_private_function(pTHX_ int arg1, int arg2)
\&        {
\&            /* dTHX; not needed here, cuz THX be a argument */
\&            ... call Perl API functions ...
\&        }
\&
\&        [... etc ...]
\&
\&        MODULE = Foo            PACKAGE = Foo
\&
\&        /* typical XSUB */
\&
\&        void
\&        my_xsub(arg)
\&                int arg
\&            CODE:
\&                my_private_function(aTHX_ arg, 10);
.Ve
.PP
This implementation never has ta fetch tha context rockin a gangbangin' function
call, since it be always passed as a extra argument.  Dependin on
your needz fo' simplicitizzle or efficiency, you may mix tha previous
two approaches freely.
.PP
Never add a cold-ass lil comma afta \f(CW\*(C`pTHX\*(C'\fR yo ass\*(--always use tha form of the
macro wit tha underscore fo' functions dat take explicit arguments,
or tha form without tha argument fo' functions wit no explicit arguments.
.PP
If one is compilin Perl wit tha \f(CW\*(C`\-DPERL_GLOBAL_STRUCT\*(C'\fR tha \f(CW\*(C`dVAR\*(C'\fR
definizzle is needed if tha Perl global variablez (see \fIperlvars.h\fR
or \fIglobvar.sym\fR) is accessed up in tha function n' \f(CW\*(C`dTHX\*(C'\fR is not
used (the \f(CW\*(C`dTHX\*(C'\fR includes tha \f(CW\*(C`dVAR\*(C'\fR if necessary).  One notices
the need fo' \f(CW\*(C`dVAR\*(C'\fR only wit tha holla'd compile-time define, cuz
otherwise tha Perl global variablez is visible as-is.
.SS "Should I do anythang special if I call perl from multiple threads?"
.IX Subsection "Should I do anythang special if I call perl from multiple threads?"
If you create interpretas up in one thread n' then proceed ta booty-call dem in
another, you need ta make shizzle perlz own Thread Local Storage (\s-1TLS\s0) slot is
initialized erectly up in each of dem threads.
.PP
Da \f(CW\*(C`perl_alloc\*(C'\fR n' \f(CW\*(C`perl_clone\*(C'\fR \s-1API\s0 functions will automatically set
the \s-1TLS\s0 slot ta tha interpreta they pimped, so dat there is no need ta do
anythang special if tha interpreta be always accessed up in tha same thread that
created it, n' dat thread did not create or call any other interpreters
afterwards.  If dat aint tha case, you gotta set tha \s-1TLS\s0 slot of the
thread before callin any functions up in tha Perl \s-1API\s0 on dat particular
interpreter n' shit.  This is done by callin tha \f(CW\*(C`PERL_SET_CONTEXT\*(C'\fR macro up in that
thread as tha straight-up original gangsta thang you do:
.PP
.Vb 2
\&        /* do dis before bustin anythang else wit some_perl */
\&        PERL_SET_CONTEXT(some_perl);
\&
\&        ... other Perl API calls on some_perl go here ...
.Ve
.SS "Future Plans n' \s-1PERL_IMPLICIT_SYS\s0"
.IX Subsection "Future Plans n' PERL_IMPLICIT_SYS"
Just as \s-1PERL_IMPLICIT_CONTEXT\s0 serves up a way ta bundle up every last muthafuckin thang
that tha interpreta knows bout itself n' pass it around, so too are
there plans ta allow tha interpreta ta bundle up every last muthafuckin thang it knows
about tha environment itz hustlin on. I aint talkin' bout chicken n' gravy biatch.  This is enabled wit the
\&\s-1PERL_IMPLICIT_SYS\s0 macro.  Currently it only works wit \s-1USE_ITHREADS\s0 on
Windows.
.PP
This allows tha mobilitizzle ta provide a extra pointa (called tha \*(L"host\*(R"
environment) fo' all tha system calls.  This make it possible for
all tha system shiznit ta maintain they own state, fucked up down into
seven C structures.  These is thin wrappers round tha usual system
calls (see \fIwin32/perllib.c\fR) fo' tha default perl executable yo, but fo' a
more ambitious host (like tha one dat would do \fIfork()\fR emulation) all
the extra work needed ta pretend dat different interpretas are
actually different \*(L"processes\*(R", would be done here.
.PP
Da Perl engine/interpreta n' tha host is orthogonal entities.
There could be one or mo' interpretas up in a process, n' one or
more \*(L"hosts\*(R", wit free association between em.
.SH "Internal Functions"
.IX Header "Internal Functions"
All of Perlz internal functions which is ghon be exposed ta tha outside
world is prefixed by \f(CW\*(C`Perl_\*(C'\fR so dat they aint gonna conflict wit \s-1XS\s0
functions or functions used up in a program up in which Perl is embedded.
Similarly, all global variablez begin wit \f(CW\*(C`PL_\*(C'\fR. (By convention,
static functions start wit \f(CW\*(C`S_\*(C'\fR.)
.PP
Inside tha Perl core (\f(CW\*(C`PERL_CORE\*(C'\fR defined), you can git all up in tha functions
either wit or without tha \f(CW\*(C`Perl_\*(C'\fR prefix, props ta a funky-ass bunch of defines
that live up in \fIembed.h\fR. Note dat extension code should \fInot\fR set
\&\f(CW\*(C`PERL_CORE\*(C'\fR; dis exposes tha full perl internals, n' is likely ta cause
breakage of tha \s-1XS\s0 up in each freshly smoked up perl release.
.PP
Da file \fIembed.h\fR is generated automatically from
\&\fIembed.pl\fR n' \fIembed.fnc\fR. \fIembed.pl\fR also creates tha prototyping
header filez fo' tha internal functions, generates tha documentation
and a shitload of other bits n' pieces. It aint nuthin but blingin dat when you add
a freshly smoked up function ta tha core or chizzle a existin one, you chizzle the
data up in tha table up in \fIembed.fnc\fR as well yo. Herez a sample entry from
that table:
.PP
.Vb 1
\&    Apd |SV**   |av_fetch   |AV* ar|I32 key|I32 lval
.Ve
.PP
Da second column is tha return type, tha third column tha name. Columns
afta dat is tha arguments, n' you can put dat on yo' toast. Da first column be a set of flags:
.IP "A" 3
.IX Item "A"
This function be a part of tha hood \s-1API.\s0 All such functions should also
have 'd', straight-up few do not.
.IP "p" 3
.IX Item "p"
This function has a \f(CW\*(C`Perl_\*(C'\fR prefix; i.e. it is defined as
\&\f(CW\*(C`Perl_av_fetch\*(C'\fR.
.IP "d" 3
.IX Item "d"
This function has documentation rockin tha \f(CW\*(C`apidoc\*(C'\fR feature which we'll
peep up in a second. Y'all KNOW dat shit, muthafucka!  Some functions have 'd' but not 'A'; docs is good.
.PP
Other available flags are:
.IP "s" 3
.IX Item "s"
This be a static function n' is defined as \f(CW\*(C`STATIC S_whatever\*(C'\fR, and
usually called within tha sources as \f(CW\*(C`whatever(...)\*(C'\fR.
.IP "n" 3
.IX Item "n"
This do not need a interpreta context, so tha definizzle has no
\&\f(CW\*(C`pTHX\*(C'\fR, n' it bigs up dat callaz don't use \f(CW\*(C`aTHX\*(C'\fR.  (See
\&\*(L"Background n' \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0.)
.IP "r" 3
.IX Item "r"
This function never returns; \f(CW\*(C`croak\*(C'\fR, \f(CW\*(C`exit\*(C'\fR n' playas.
.IP "f" 3
.IX Item "f"
This function takes a variable number of arguments, \f(CW\*(C`printf\*(C'\fR style.
Da argument list should end wit \f(CW\*(C`...\*(C'\fR, like this:
.Sp
.Vb 1
\&    Afprd   |void   |croak          |const char* pat|...
.Ve
.IP "M" 3
.IX Item "M"
This function is part of tha experimenstrual pimpment \s-1API,\s0 n' may chizzle
or disappear without notice.
.IP "o" 3
.IX Item "o"
This function should not gotz a cold-ass lil compatibilitizzle macro ta define, say,
\&\f(CW\*(C`Perl_parse\*(C'\fR ta \f(CW\*(C`parse\*(C'\fR. Well shiiiit, it must be called as \f(CW\*(C`Perl_parse\*(C'\fR.
.IP "x" 3
.IX Item "x"
This function aint exported outta tha Perl core.
.IP "m" 3
.IX Item "m"
This is implemented as a macro.
.IP "X" 3
.IX Item "X"
This function is explicitly exported.
.IP "E" 3
.IX Item "E"
This function is visible ta extensions included up in tha Perl core.
.IP "b" 3
.IX Item "b"
Binary backward compatibility; dis function be a macro but also has
a \f(CW\*(C`Perl_\*(C'\fR implementation (which is exported).
.IP "others" 3
.IX Item "others"
See tha comments all up in tha top of \f(CW\*(C`embed.fnc\*(C'\fR fo' others.
.PP
If you edit \fIembed.pl\fR or \fIembed.fnc\fR, yo big-ass booty is ghon need ta run
\&\f(CW\*(C`make regen_headers\*(C'\fR ta force a rebuild of \fIembed.h\fR n' other
auto-generated files.
.SS "Formatted Printin of IVs, UVs, n' NVs"
.IX Subsection "Formatted Printin of IVs, UVs, n' NVs"
If yo ass is printin IVs, UVs, or \s-1NVS\s0 instead of tha \fIstdio\fR\|(3) style
formattin codes like \f(CW%d\fR, \f(CW%ld\fR, \f(CW%f\fR, you should use the
followin macros fo' portability
.PP
.Vb 7
\&        IVdf            IV up in decimal
\&        UVuf            UV up in decimal
\&        UVof            UV up in octal
\&        UVxf            UV up in hexadecimal
\&        NVef            NV %e\-like
\&        NVff            NV %f\-like
\&        NVgf            NV %g\-like
.Ve
.PP
These will take care of 64\-bit integers n' long doubles.
For example:
.PP
.Vb 1
\&        printf("IV is %"IVdf"\en", iv);
.Ve
.PP
Da IVdf will expand ta whatever is tha erect format fo' tha IVs.
.PP
If yo ass is printin addressez of pointers, use UVxf combined
with \s-1\fIPTR2UV\s0()\fR, do not use \f(CW%lx\fR or \f(CW%p\fR.
.SS "Pointer-To-Integer n' Integer-To-Pointer"
.IX Subsection "Pointer-To-Integer n' Integer-To-Pointer"
Because pointa size do not necessarily equal integer size,
use tha follow macros ta do it right.
.PP
.Vb 4
\&        PTR2UV(pointer)
\&        PTR2IV(pointer)
\&        PTR2NV(pointer)
\&        INT2PTR(pointertotype, integer)
.Ve
.PP
For example:
.PP
.Vb 2
\&        IV  iv = ...;
\&        SV *sv = INT2PTR(SV*, iv);
.Ve
.PP
and
.PP
.Vb 2
\&        AV *av = ...;
\&        UV  uv = PTR2UV(av);
.Ve
.SS "Exception Handling"
.IX Subsection "Exception Handling"
There is a cold-ass lil couple macros ta do straight-up basic exception handlin up in \s-1XS\s0
modules. Yo ass gotta define \f(CW\*(C`NO_XSLOCKS\*(C'\fR before includin \fI\s-1XSUB\s0.h\fR to
be able ta use these macros:
.PP
.Vb 2
\&        #define NO_XSLOCKS
\&        #include "XSUB.h"
.Ve
.PP
Yo ass can use these macros if you call code dat may croak yo, but you need
to do some cleanup before givin control back ta Perl. For example:
.PP
.Vb 1
\&        dXCPT;    /* set up necessary variablez */
\&
\&        XCPT_TRY_START {
\&          code_that_may_croak();
\&        } XCPT_TRY_END
\&
\&        XCPT_CATCH
\&        {
\&          /* do cleanup here */
\&          XCPT_RETHROW;
\&        }
.Ve
.PP
Note dat you always gotta rethrow a exception dat has been
caught. Usin these macros, it aint possible ta just catch the
exception n' ignore dat shit. If you gotta ignore tha exception, you
have ta use tha \f(CW\*(C`call_*\*(C'\fR function.
.PP
Da advantage of rockin tha above macros is dat you don't have
to setup a extra function fo' \f(CW\*(C`call_*\*(C'\fR, n' dat rockin these
macros is fasta than rockin \f(CW\*(C`call_*\*(C'\fR.
.SS "Source Documentation"
.IX Subsection "Source Documentation"
Therez a effort goin on ta document tha internal functions and
automatically produce reference manuals from dem \- perlapi is one
such manual which details all tha functions which is available ta \s-1XS\s0
writers. perlintern is tha autogenerated manual fo' tha functions
which is not part of tha \s-1API\s0 n' is supposedly fo' internal use only.
.PP
Source documentation is pimped by puttin \s-1POD\s0 comments tha fuck into tha C
source, like this:
.PP
.Vb 2
\& /*
\& =for apidoc sv_setiv
\&
\& Copies a integer tha fuck into tha given SV.  Do not handle \*(Aqset\*(Aq magic.  See
\& C<sv_setiv_mg>.
\&
\& =cut
\& */
.Ve
.PP
Please try n' supply some documentation if you add functions ta the
Perl core.
.SS "Backwardz compatibility"
.IX Subsection "Backwardz compatibility"
Da Perl \s-1API\s0 chizzlez over time. New functions is added or tha intercourses
of existin functions is chizzled. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`Devel::PPPort\*(C'\fR module tries to
provide compatibilitizzle code fo' a shitload of these chizzles, so \s-1XS\s0 writas don't
have ta code it theyselves when supportin multiple versionz of Perl.
.PP
\&\f(CW\*(C`Devel::PPPort\*(C'\fR generates a C header file \fIppport.h\fR dat can also
be run as a Perl script. To generate \fIppport.h\fR, run:
.PP
.Vb 1
\&    perl \-MDevel::PPPort \-eDevel::PPPort::WriteFile
.Ve
.PP
Besides checkin existin \s-1XS\s0 code, tha script can also be used ta retrieve
compatibilitizzle shiznit fo' various \s-1API\s0 calls rockin tha \f(CW\*(C`\-\-api\-info\*(C'\fR
command line switch. For example:
.PP
.Vb 1
\&  % perl ppport.h \-\-api\-info=sv_magicext
.Ve
.PP
For details, peep \f(CW\*(C`perldoc ppport.h\*(C'\fR.
.SH "Unicode Support"
.IX Header "Unicode Support"
Perl 5.6.0 introduced Unicode support. It aint nuthin but blingin fo' portas n' \s-1XS\s0
writas ta KNOW dis support n' make shizzle dat tha code they
write do not corrupt Unicode data.
.SS "What \fBis\fP Unicode, anyway?"
.IX Subsection "What tha fuck iz Unicode, anyway?"
In tha olden, less enlightened times, we all used ta use \s-1ASCII.\s0 Most of
us did, anyway. Da big-ass problem wit \s-1ASCII\s0 is dat itz Gangsta. Well,
no, thatz not straight-up tha problem; tha problem is dat itz not
particularly useful fo' playas whoz ass don't use tha Roman alphabet. What
used ta happen was dat particular languages would stick they own
alphabet up in tha upper range of tha sequence, between 128 n' 255. Of
course, we then ended up wit nuff variants dat weren't quite
\&\s-1ASCII,\s0 n' tha whole point of it bein a standard was lost.
.PP
Worse still, if you've gots a language like Chinese or
Japanese dat has hundredz or thousandz of characters, then you straight-up
can't fit dem tha fuck into a mere 256, so they had ta forget bout \s-1ASCII\s0
altogether, n' build they own systems rockin pairz of numbers ta refer
to one character.
.PP
To fix this, some playas formed Unicode, Inc. and
produced a freshly smoked up characta set containin all tha charactas you can
possibly be thinkin of n' mo' n' mo' n' mo'. There is nuff muthafuckin wayz of representin these
characters, n' tha one Perl uses is called \s-1UTF\-8. UTF\-8\s0 uses
a variable number of bytes ta represent a cold-ass lil character n' shit. Yo ass can learn more
about Unicode n' Perlz Unicode model up in perlunicode.
.SS "How tha fuck can I recognise a \s-1UTF\-8\s0 string?"
.IX Subsection "How tha fuck can I recognise a UTF-8 string?"
Yo ass can't. This is cuz \s-1UTF\-8\s0 data is stored up in bytes just like
non\-UTF\-8 data. Da Unicode characta 200, (\f(CW0xC8\fR fo' you hex types)
capital E wit a grave accent, is represented by tha two bytes
\&\f(CW\*(C`v196.172\*(C'\fR. Unfortunately, tha non-Unicode strang \f(CW\*(C`chr(196).chr(172)\*(C'\fR
has dat byte sequence as well. Right back up in yo muthafuckin ass. So you can't tell just by lookin \- this
is what tha fuck make Unicode input a bangin-ass problem.
.PP
In general, you either gotta know what tha fuck you dealin with, or you
have ta guess.  Da \s-1API\s0 function \f(CW\*(C`is_utf8_string\*(C'\fR can help; it'll tell
you if a strang gotz nuff only valid \s-1UTF\-8\s0 characters. But fuck dat shiznit yo, tha word on tha street is dat it can't
do tha work fo' yo thugged-out ass. On a cold-ass lil character-by-characta basis,
\&\f(CW\*(C`is_utf8_char_buf\*(C'\fR
will rap  whether tha current characta up in a strang is valid \s-1UTF\-8. \s0
.SS "How tha fuck do \s-1UTF\-8\s0 represent Unicode characters?"
.IX Subsection "How tha fuck do UTF-8 represent Unicode characters?"
As mentioned above, \s-1UTF\-8\s0 uses a variable number of bytes ta store a
character n' shit. Charactas wit joints 0...127 is stored up in one byte, just
like phat ol' \s-1ASCII.\s0 Characta 128 is stored as \f(CW\*(C`v194.128\*(C'\fR; this
continues up ta characta 191, which is \f(CW\*(C`v194.191\*(C'\fR. Now we've run up of
bits (191 is binary \f(CW10111111\fR) so we move on; 192 is \f(CW\*(C`v195.128\*(C'\fR fo' realz. And
so it goes on, movin ta three bytes at characta 2048.
.PP
Assumin you know you dealin wit a \s-1UTF\-8\s0 string, you can smoke up
how long tha straight-up original gangsta characta up in it is wit tha \f(CW\*(C`UTF8SKIP\*(C'\fR macro:
.PP
.Vb 2
\&    char *utf = "\e305\e233\e340\e240\e201";
\&    I32 len;
\&
\&    len = UTF8SKIP(utf); /* len is 2 here */
\&    utf += len;
\&    len = UTF8SKIP(utf); /* len is 3 here */
.Ve
.PP
Another way ta skip over charactas up in a \s-1UTF\-8\s0 strang is ta use
\&\f(CW\*(C`utf8_hop\*(C'\fR, which takes a strang n' a fuckin shitload of charactas ta skip
over n' shit. Yo ass is on yo' own bout boundz checking, though, so don't use it
lightly.
.PP
All bytes up in a multi-byte \s-1UTF\-8\s0 characta gonna git tha high bit set,
so you can test if you need ta do suttin' special wit this
characta like dis (the \s-1\fIUTF8_IS_INVARIANT\s0()\fR be a macro dat tests
whether tha byte can be encoded as a single byte even up in \s-1UTF\-8\s0):
.PP
.Vb 4
\&    U8 *utf;
\&    U8 *utf_end; /* 1 beyond buffer pointed ta by utf */
\&    UV uv;      /* Note: a UV, not a U8, not a cold-ass lil char */
\&    STRLEN len; /* length of characta up in bytes */
\&
\&    if (!UTF8_IS_INVARIANT(*utf))
\&        /* Must treat dis as UTF\-8 */
\&        uv = utf8_to_uvchr_buf(utf, utf_end, &len);
\&    else
\&        /* OK ta treat dis characta as a funky-ass byte */
\&        uv = *utf;
.Ve
.PP
Yo ass can also peep up in dat example dat we use \f(CW\*(C`utf8_to_uvchr_buf\*(C'\fR ta git the
value of tha character; tha inverse function \f(CW\*(C`uvchr_to_utf8\*(C'\fR be available
for puttin a \s-1UV\s0 tha fuck into \s-1UTF\-8:\s0
.PP
.Vb 6
\&    if (!UTF8_IS_INVARIANT(uv))
\&        /* Must treat dis as UTF8 */
\&        utf8 = uvchr_to_utf8(utf8, uv);
\&    else
\&        /* OK ta treat dis characta as a funky-ass byte */
\&        *utf8++ = uv;
.Ve
.PP
Yo ass \fBmust\fR convert charactas ta UVs rockin tha above functions if
yo ass is eva up in a thang where you gotta match \s-1UTF\-8\s0 n' non\-UTF\-8
characters. Yo ass may not skip over \s-1UTF\-8\s0 charactas up in dis case. If you
do this, you gonna lose tha mobilitizzle ta match hi-bit non\-UTF\-8 characters;
for instance, if yo' \s-1UTF\-8\s0 strang gotz nuff \f(CW\*(C`v196.172\*(C'\fR, n' you skip
that character, you can never match a \f(CW\*(C`chr(200)\*(C'\fR up in a non\-UTF\-8 string.
So don't do that!
.SS "How tha fuck do Perl store \s-1UTF\-8\s0 strings?"
.IX Subsection "How tha fuck do Perl store UTF-8 strings?"
Currently, Perl deals wit Unicode strings n' non-Unicode strings
slightly differently fo' realz. A flag up in tha \s-1SV, \s0\f(CW\*(C`SVf_UTF8\*(C'\fR, indicates dat the
strin is internally encoded as \s-1UTF\-8.\s0 Without it, tha byte value is the
codepoint number n' vice versa (in other lyrics, tha strang is encoded
as iso\-8859\-1 yo, but \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR is needed ta git iso\-8859\-1
semantics). Yo ass can check n' manipulate dis flag wit the
followin macros:
.PP
.Vb 3
\&    SvUTF8(sv)
\&    SvUTF8_on(sv)
\&    SvUTF8_off(sv)
.Ve
.PP
This flag has a blingin effect on Perlz treatment of tha string: if
Unicode data aint properly distinguished, regular expressions,
\&\f(CW\*(C`length\*(C'\fR, \f(CW\*(C`substr\*(C'\fR n' other strang handlin operations will have
undesirable thangs up in dis biatch.
.PP
Da problem comes when you have, fo' instance, a strang dat aint
flagged as \s-1UTF\-8,\s0 n' gotz nuff a funky-ass byte sequence dat could be \s-1UTF\-8 \-\s0
especially when combinin non\-UTF\-8 n' \s-1UTF\-8\s0 strings.
.PP
Never forget dat tha \f(CW\*(C`SVf_UTF8\*(C'\fR flag is separate ta tha \s-1PV\s0 value; you
need be shizzle you don't accidentally knock it off while you is
manipulatin SVs. Mo' specifically, you cannot expect ta do this:
.PP
.Vb 4
\&    SV *sv;
\&    SV *nsv;
\&    STRLEN len;
\&    char *p;
\&
\&    p = SvPV(sv, len);
\&    frobnicate(p);
\&    nsv = newSVpvn(p, len);
.Ve
.PP
Da \f(CW\*(C`char*\*(C'\fR strang do not rap  tha whole story, n' you can't
copy or reconstruct a \s-1SV\s0 just by copyin tha strang value. Peep if the
old \s-1SV\s0 has tha \s-1UTF8\s0 flag set, n' act accordingly:
.PP
.Vb 5
\&    p = SvPV(sv, len);
\&    frobnicate(p);
\&    nsv = newSVpvn(p, len);
\&    if (SvUTF8(sv))
\&        SvUTF8_on(nsv);
.Ve
.PP
In fact, yo' \f(CW\*(C`frobnicate\*(C'\fR function should be made aware of whether or
not itz dealin wit \s-1UTF\-8\s0 data, so dat it can handle tha string
appropriately.
.PP
Since just passin a \s-1SV\s0 ta a \s-1XS\s0 function n' copyin tha data of
the \s-1SV\s0 aint enough ta copy tha \s-1UTF8\s0 flags, even less right is just
passin a \f(CW\*(C`char *\*(C'\fR ta a \s-1XS\s0 function.
.SS "How tha fuck do I convert a strang ta \s-1UTF\-8\s0?"
.IX Subsection "How tha fuck do I convert a strang ta UTF-8?"
If you mixin \s-1UTF\-8\s0 n' non\-UTF\-8 strings, it is necessary ta upgrade
one of tha strings ta \s-1UTF\-8.\s0 If you've gots a \s-1SV,\s0 tha easiest way ta do
this is:
.PP
.Vb 1
\&    sv_utf8_upgrade(sv);
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat you must not do this, fo' example:
.PP
.Vb 2
\&    if (!SvUTF8(left))
\&        sv_utf8_upgrade(left);
.Ve
.PP
If you do dis up in a funky-ass binary operator, yo big-ass booty is ghon straight-up chizzle one of the
strings dat came tha fuck into tha operator, and, while it shouldn't be noticeable
by tha end user, it can cause problems up in deficient code.
.PP
Instead, \f(CW\*(C`bytes_to_utf8\*(C'\fR will hit you wit a UTF\-8\-encoded \fBcopy\fR of its
strin argument. This is useful fo' havin tha data available for
comparisons n' so on, without harmin tha original gangsta \s-1SV.\s0 Therez also
\&\f(CW\*(C`utf8_to_bytes\*(C'\fR ta go tha other way yo, but naturally, dis will fail if
the strang gotz nuff any charactas above 255 dat can't be represented
in a single byte.
.SS "Is there anythang else I need ta know?"
.IX Subsection "Is there anythang else I need ta know?"
Not straight-up. Just remember these thangs:
.IP "\(bu" 3
Therez no way ta tell if a strang is \s-1UTF\-8\s0 or not. Yo ass can tell if a \s-1SV\s0
is \s-1UTF\-8\s0 by lookin at its \f(CW\*(C`SvUTF8\*(C'\fR flag. Don't forget ta set tha flag if
suttin' should be \s-1UTF\-8.\s0 Treat tha flag as part of tha \s-1PV,\s0 even though
itz not \- if you pass on tha \s-1PV\s0 ta somewhere, pass on tha flag like a muthafucka.
.IP "\(bu" 3
If a strang is \s-1UTF\-8, \s0\fBalways\fR use \f(CW\*(C`utf8_to_uvchr_buf\*(C'\fR ta git all up in tha value,
unless \f(CW\*(C`UTF8_IS_INVARIANT(*s)\*(C'\fR up in which case you can use \f(CW*s\fR.
.IP "\(bu" 3
When freestylin a cold-ass lil characta \f(CW\*(C`uv\*(C'\fR ta a \s-1UTF\-8\s0 string, \fBalways\fR use
\&\f(CW\*(C`uvchr_to_utf8\*(C'\fR, unless \f(CW\*(C`UTF8_IS_INVARIANT(uv))\*(C'\fR up in which case
you can use \f(CW\*(C`*s = uv\*(C'\fR.
.IP "\(bu" 3
Mixin \s-1UTF\-8\s0 n' non\-UTF\-8 strings is tricky. Use \f(CW\*(C`bytes_to_utf8\*(C'\fR ta get
a freshly smoked up strang which is \s-1UTF\-8\s0 encoded, n' then combine em.
.SH "Custom Operators"
.IX Header "Custom Operators"
Custom operator support be a experimenstrual feature dat allows you to
define yo' own ops. This is primarily ta allow tha buildin of
interpretas fo' other languages up in tha Perl core yo, but it also allows
optimizations all up in tha creation of \*(L"macro-ops\*(R" (ops which big-ass up the
functionz of multiple ops which is probably executed together, such as
\&\f(CW\*(C`gvsv, gvsv, add\*(C'\fR.)
.PP
This feature is implemented as a freshly smoked up op type, \f(CW\*(C`OP_CUSTOM\*(C'\fR. Da Perl
core do not \*(L"know\*(R" anythang special bout dis op type, n' so it will
not be involved up in any optimizations. This also means dat you can
define yo' custom ops ta be any op structure \- unary, binary, list and
so on \- you like.
.PP
It aint nuthin but blingin ta know what tha fuck custom operators won't do fo' yo thugged-out ass. They
won't let you add freshly smoked up syntax ta Perl, directly. They won't even let you
add freshly smoked up keywords, directly. In fact, they won't chizzle tha way Perl
compilez a program at all. Yo ass gotta do dem chizzlez yo ass, after
Perl has compiled tha program. Yo ass do dis either by manipulatin tha op
tree rockin a \f(CW\*(C`CHECK\*(C'\fR block n' tha \f(CW\*(C`B::Generate\*(C'\fR module, or by adding
a custom peephole optimizer wit tha \f(CW\*(C`optimize\*(C'\fR module.
.PP
When you do this, you replace ordinary Perl ops wit custom ops by
bustin ops wit tha type \f(CW\*(C`OP_CUSTOM\*(C'\fR n' tha \f(CW\*(C`op_ppaddr\*(C'\fR of yo' own
\&\s-1PP\s0 function. I aint talkin' bout chicken n' gravy biatch. This should be defined up in \s-1XS\s0 code, n' should look like
the \s-1PP\s0 ops up in \f(CW\*(C`pp_*.c\*(C'\fR. Yo ass is responsible fo' ensurin dat yo' op
takes tha appropriate number of joints from tha stack, n' yo ass is
responsible fo' addin stack marks if necessary.
.PP
Yo ass should also \*(L"register\*(R" yo' op wit tha Perl interpreta so dat it
can produce sensible error n' warnin lyrics. Right back up in yo muthafuckin ass. Since it is possible to
have multiple custom ops within tha one \*(L"logical\*(R" op type \f(CW\*(C`OP_CUSTOM\*(C'\fR,
Perl uses tha value of \f(CW\*(C`o\->op_ppaddr\*(C'\fR ta determine which custom op
it is dealin with. Yo ass should create a \f(CW\*(C`XOP\*(C'\fR structure fo' each
ppaddr you use, set tha propertizzlez of tha custom op with
\&\f(CW\*(C`XopENTRY_set\*(C'\fR, n' regista tha structure against tha ppaddr using
\&\f(CW\*(C`Perl_custom_op_register\*(C'\fR fo' realz. A trivial example might look like:
.PP
.Vb 2
\&    static XOP my_xop;
\&    static OP *my_pp(pTHX);
\&
\&    BOOT:
\&        XopENTRY_set(&my_xop, xop_name, "myxop");
\&        XopENTRY_set(&my_xop, xop_desc, "Useless custom op");
\&        Perl_custom_op_register(aTHX_ my_pp, &my_xop);
.Ve
.PP
Da available fieldz up in tha structure are:
.IP "xop_name" 4
.IX Item "xop_name"
A short name fo' yo' op. This is ghon be included up in some error lyrics,
and will also be returned as \f(CW\*(C`$op\->name\*(C'\fR by tha B module, so
it will step tha fuck up in tha output of module like B::Concise.
.IP "xop_desc" 4
.IX Item "xop_desc"
A short description of tha function of tha op.
.IP "xop_class" 4
.IX Item "xop_class"
Which of tha various \f(CW*OP\fR structures dis op uses. This should be one of
the \f(CW\*(C`OA_*\*(C'\fR constants from \fIop.h\fR, namely
.RS 4
.IP "\s-1OA_BASEOP\s0" 4
.IX Item "OA_BASEOP"
.PD 0
.IP "\s-1OA_UNOP\s0" 4
.IX Item "OA_UNOP"
.IP "\s-1OA_BINOP\s0" 4
.IX Item "OA_BINOP"
.IP "\s-1OA_LOGOP\s0" 4
.IX Item "OA_LOGOP"
.IP "\s-1OA_LISTOP\s0" 4
.IX Item "OA_LISTOP"
.IP "\s-1OA_PMOP\s0" 4
.IX Item "OA_PMOP"
.IP "\s-1OA_SVOP\s0" 4
.IX Item "OA_SVOP"
.IP "\s-1OA_PADOP\s0" 4
.IX Item "OA_PADOP"
.IP "\s-1OA_PVOP_OR_SVOP\s0" 4
.IX Item "OA_PVOP_OR_SVOP"
.PD
This should be interpreted as '\f(CW\*(C`PVOP\*(C'\fR' only. Da \f(CW\*(C`_OR_SVOP\*(C'\fR is cuz
the only core \f(CW\*(C`PVOP\*(C'\fR, \f(CW\*(C`OP_TRANS\*(C'\fR, can sometimes be a \f(CW\*(C`SVOP\*(C'\fR instead.
.IP "\s-1OA_LOOP\s0" 4
.IX Item "OA_LOOP"
.PD 0
.IP "\s-1OA_COP\s0" 4
.IX Item "OA_COP"
.RE
.RS 4
.PD
.Sp
Da other \f(CW\*(C`OA_*\*(C'\fR constants should not be used.
.RE
.IP "xop_peep" 4
.IX Item "xop_peep"
This member iz of type \f(CW\*(C`Perl_cpeep_t\*(C'\fR, which expandz ta \f(CW\*(C`void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)\*(C'\fR. If it is set, dis function
will be called from \f(CW\*(C`Perl_rpeep\*(C'\fR when opz of dis type is encountered
by tha peephole optimizer n' shit. \fIo\fR is tha \s-1OP\s0 dat needz optimizing;
\&\fIoldop\fR is tha previous \s-1OP\s0 optimized, whose \f(CW\*(C`op_next\*(C'\fR points ta \fIo\fR.
.PP
\&\f(CW\*(C`B::Generate\*(C'\fR directly supports tha creation of custom ops by name.
.SH "AUTHORS"
.IX Header "AUTHORS"
Until May 1997, dis document was maintained by Jeff Okamoto
<okamoto@corp.hp.com>.  It be now maintained as part of Perl
itself by tha Perl 5 Portas <perl5\-porters@perl.org>.
.PP
With fuckin shitloadz of help n' suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Pizzle Hudson, Ilya Zakharevich, Pizzle Marquess, Neil
Bowers, Matthew Green, Slim Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, n' Gurusamy Sarathy.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlapi, perlintern, perlxs, perlembed
