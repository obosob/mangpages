'\" t
.\"     Title: glib-genmarshal
.\"    Author: Slim Tim Janik
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 11/11/2013
.\"    Manual: User Commands
.\"    Source: GObject
.\"  Language: Gangsta
.\"
.TH "GLIB\-GENMARSHAL" "1" "" "GObject" "User Commands"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
glib-genmarshal \- C code marshalla generation utilitizzle fo' GLib closures
.SH "SYNOPSIS"
.HP \w'\fBglib\-genmarshal\fR\ 'u
\fBglib\-genmarshal\fR [OPTION...] [FILE...]
.SH "DESCRIPTION"
.PP
\fBglib\-genmarshal\fR
is a lil' small-ass utilitizzle dat generates C code marshallaz fo' callback functionz of tha GClosure mechanizzle up in tha GObject sublibrary of GLib\&. Da marshalla functions gotz a standard signature, they git passed up in tha invokin closure, a array of value structures holdin tha callback function parametas n' a value structure fo' tha return value of tha callback\&. Da marshalla is then responsible ta booty-call tha respectizzle C code function of tha closure wit all tha parametas on tha stack n' ta collect its return value\&.
.PP
\fBglib\-genmarshal\fR
takes a list of marshallaz ta generate as input\&. Da marshalla list is either read from standard input or from filez passed as additionizzle arguments on tha command line\&.
.SS "Marshalla list format"
.PP
Da marshalla lists is processed line by line, a line can contain a cold-ass lil comment up in tha form of
.sp
.if n \{\
.RS 4
.\}
.nf
# dis be a cold-ass lil comment
.fi
.if n \{\
.RE
.\}
.sp
or a marshalla justification of tha form
.sp
.if n \{\
.RS 4
.\}
.nf
\fIRTYPE\fR:\fIPTYPE\fR
\fIRTYPE\fR:\fIPTYPE\fR,\fIPTYPE\fR
\fIRTYPE\fR:\fIPTYPE\fR,\fIPTYPE\fR,\fIPTYPE\fR
.fi
.if n \{\
.RE
.\}
.sp
(up ta 16
\fIPTYPE\fRs may be present)\&.
.PP
The
\fIRTYPE\fR
part specifies tha callback\*(Aqs return type n' the
\fIPTYPE\fRs right ta tha colon specify tha callback\*(Aqs parameta list, except fo' tha straight-up original gangsta n' tha last arguments which is always pointers\&.
.SS "Parameta types"
.PP
Currently, tha followin types is supported:
.PP
\fIVOID\fR
.RS 4
indicates no return type, or no extra parameters\&. If
\fIVOID\fR
is used as tha parameta list, no additionizzle parametas may be present\&.
.RE
.PP
\fIBOOLEAN\fR
.RS 4
for boolean types (gboolean)
.RE
.PP
\fICHAR\fR
.RS 4
for signed char types (gchar)
.RE
.PP
\fIUCHAR\fR
.RS 4
for unsigned char types (guchar)
.RE
.PP
\fIINT\fR
.RS 4
for signed integer types (gint)
.RE
.PP
\fIUINT\fR
.RS 4
for unsigned integer types (guint)
.RE
.PP
\fILONG\fR
.RS 4
for signed long integer types (glong)
.RE
.PP
\fIULONG\fR
.RS 4
for unsigned long integer types (gulong)
.RE
.PP
\fIINT64\fR
.RS 4
for signed 64bit integer types (gint64)
.RE
.PP
\fIUINT64\fR
.RS 4
for unsigned 64bit integer types (guint64)
.RE
.PP
\fIENUM\fR
.RS 4
for enumeration types (gint)
.RE
.PP
\fIFLAGS\fR
.RS 4
for flag enumeration types (guint)
.RE
.PP
\fIFLOAT\fR
.RS 4
for single\-precision float types (gfloat)
.RE
.PP
\fIDOUBLE\fR
.RS 4
for double\-precision float types (gdouble)
.RE
.PP
\fISTRING\fR
.RS 4
for strang types (gchar*)
.RE
.PP
\fIBOXED\fR
.RS 4
for boxed (anonymous but reference counted) types (GBoxed*)
.RE
.PP
\fIPARAM\fR
.RS 4
for GParamSpec or derived types (GParamSpec*)
.RE
.PP
\fIPOINTER\fR
.RS 4
for anonymous pointa types (gpointer)
.RE
.PP
\fIOBJECT\fR
.RS 4
for GObject or derived types (GObject*)
.RE
.PP
\fIVARIANT\fR
.RS 4
for GVariant types (GVariant*)
.RE
.PP
\fINONE\fR
.RS 4
deprecated alias for
\fIVOID\fR
.RE
.PP
\fIBOOL\fR
.RS 4
deprecated alias for
\fIBOOLEAN\fR
.RE
.SH "OPTIONS"
.PP
\fB\-\-header\fR
.RS 4
Generate header file contentz of tha marshallers\&.
.RE
.PP
\fB\-\-body\fR
.RS 4
Generate C code file contentz of tha marshallers\&.
.RE
.PP
\fB\-\-prefix=\fR\fB\fIPREFIX\fR\fR
.RS 4
Specify marshalla prefix\&. Da default prefix is
`g_cclosure_marshal\*(Aq\&.
.RE
.PP
\fB\-\-skip\-source\fR
.RS 4
Skip source location remarks up in generated comments\&.
.RE
.PP
\fB\-\-stdinc\fR
.RS 4
Use tha standard marshallaz of tha GObject library, n' include
gmarshal\&.h
in generated header files\&.
.RE
.PP
\fB\-\-nostdinc\fR
.RS 4
Do not use tha standard marshallaz of tha GObject library, n' skip
gmarshal\&.h
include directizzle up in generated header files\&.
.RE
.PP
\fB\-\-internal\fR
.RS 4
Mark generated functions as internal, rockin G_GNUC_INTERNAL\&.
.RE
.PP
\fB\-\-valist\-marshallers\fR
.RS 4
Generate valist marshallers, fo' use wit g_signal_set_va_marshaller()\&.
.RE
.PP
\fB\-v\fR, \fB\-\-version\fR
.RS 4
Print version shiznit\&.
.RE
.PP
\fB\-\-g\-fatal\-warnings\fR
.RS 4
Make warnings fatal, dat is, exit immediately once a warnin occurs\&.
.RE
.PP
\fB\-h\fR, \fB\-\-help\fR
.RS 4
Print brief help n' exit\&.
.RE
.PP
\fB\-v\fR, \fB\-\-version\fR
.RS 4
Print version n' exit\&.
.RE
.SH "EXAMPLE"
.PP
To generate marshallaz fo' tha followin callback functions:
.sp
.if n \{\
.RS 4
.\}
.nf
void   foo (gpointa data1,
            gpointa data2);
void   bar (gpointa data1,
            gint     param1,
            gpointa data2);
gfloat baz (gpointa data1,
            gboolean param1,
            guchar   param2,
            gpointa data2);
.fi
.if n \{\
.RE
.\}
.PP
The
marshaller\&.list
file has ta be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
VOID:VOID
VOID:INT
FLOAT:BOOLEAN,UCHAR
.fi
.if n \{\
.RE
.\}
.PP
and you call glib\-genmarshal like this:
.sp
.if n \{\
.RS 4
.\}
.nf
glib\-genmarshal \-\-header marshaller\&.list > marshaller\&.h
glib\-genmarshal \-\-body marshaller\&.list > marshaller\&.c
.fi
.if n \{\
.RE
.\}
.PP
Da generated marshallaz have tha arguments encoded up in they function name\&. For dis particular list, they are
.sp
.if n \{\
.RS 4
.\}
.nf
g_cclosure_user_marshal_VOID__VOID(),
g_cclosure_user_marshal_VOID__INT(),
g_cclosure_user_marshal_FLOAT__BOOLEAN_UCHAR()\&.
.fi
.if n \{\
.RE
.\}
.PP
They can be used directly fo' GClosures or be passed up in as tha GSignalCMarshalla c_marshaller; argument upon creation of signals:
.sp
.if n \{\
.RS 4
.\}
.nf
GClosure *cc_foo, *cc_bar, *cc_baz;

cc_foo = g_cclosure_new (NULL, foo, NULL);
g_closure_set_marshal (cc_foo, g_cclosure_user_marshal_VOID__VOID);
cc_bar = g_cclosure_new (NULL, bar, NULL);
g_closure_set_marshal (cc_bar, g_cclosure_user_marshal_VOID__INT);
cc_baz = g_cclosure_new (NULL, baz, NULL);
g_closure_set_marshal (cc_baz, g_cclosure_user_marshal_FLOAT__BOOLEAN_UCHAR);
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.PP
\fBglib-mkenums\fR(1)
