.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLLOL 1"
.TH PERLLOL 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perllol \- Manipulatin Arrayz of Arrays up in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Declaration n' Access of Arrayz of Arrays"
.IX Subsection "Declaration n' Access of Arrayz of Arrays"
Da simplest two-level data structure ta build up in Perl be a array of
arrays, sometimes casually called a list of lists, n' you can put dat on yo' toast.  It aint nuthin but reasonably easy as fuck  to
understand, n' almost every last muthafuckin thang dat applies here will also be applicable
lata on wit tha fancier data structures.
.PP
An array of a array is just a regular oldschool array \f(CW@AoA\fR dat you can
get at wit two subscripts, like \f(CW$AoA[3][2]\fR.  Herez a thugged-out declaration
of tha array:
.PP
.Vb 1
\&    use 5.010;  # so we can use say()
\&
\&    # assign ta our array, a array of array references
\&    @AoA = (
\&           [ "fred", "barney", "pebbles", "bambam", "dino", ],
\&           [ "george", "jane", "elroy", "judy", ],
\&           [ "homer", "bart", "marge", "maggie", ],
\&    );
\&    say $AoA[2][1];
\&  bart
.Ve
.PP
Now you should be straight-up careful dat tha outa bracket type
is a round one, dat is, a parenthesis.  Thatz cuz you assignin to
an \f(CW@array\fR, so you need parentheses.  If you wanted there \fInot\fR ta be a \f(CW@AoA\fR,
but rather just a reference ta it, you could do suttin' mo' like this:
.PP
.Vb 8
\&    # assign a reference ta array of array references
\&    $ref_to_AoA = [
\&        [ "fred", "barney", "pebbles", "bambam", "dino", ],
\&        [ "george", "jane", "elroy", "judy", ],
\&        [ "homer", "bart", "marge", "maggie", ],
\&    ];
\&    say $ref_to_AoA\->[2][1];
\&  bart
.Ve
.PP
Notice dat tha outa bracket type has chizzled, n' so our access syntax
has also chizzled. Y'all KNOW dat shit, muthafucka!  Thatz cuz unlike C, up in perl you can't freely
interchange arrays n' references thereto.  \f(CW$ref_to_AoA\fR be a reference ta an
array, whereas \f(CW@AoA\fR be a array proper n' shit.  Likewise, \f(CW$AoA[2]\fR aint an
array yo, but a array ref.  So how tha fuck come you can write these:
.PP
.Vb 2
\&    $AoA[2][2]
\&    $ref_to_AoA\->[2][2]
.Ve
.PP
instead of havin ta write these:
.PP
.Vb 2
\&    $AoA[2]\->[2]
\&    $ref_to_AoA\->[2]\->[2]
.Ve
.PP
Well, thatz cuz tha rule is dat on adjacent brackets only (whether
square or curly), yo ass is free ta omit tha pointa dereferencin arrow.
But you cannot do so fo' tha straight-up first one if itz a scalar containing
a reference, which means dat \f(CW$ref_to_AoA\fR always needz dat shit.
.SS "Growin Yo crazy-ass Own"
.IX Subsection "Growin Yo crazy-ass Own"
Thatz all well n' phat fo' declaration of a gangbangin' fixed data structure,
but what tha fuck if you wanted ta add freshly smoked up elements on tha fly, or build
it up entirely from scratch?
.PP
First, letz peep readin it up in from a gangbangin' file.  This is suttin' like
addin a row at a time.  We bout ta assume dat there be a a gangbangin' flat file up in which
each line be a row n' each word a element.  If you tryin ta pimp an
\&\f(CW@AoA\fR array containin all these, herez tha right way ta do that:
.PP
.Vb 4
\&    while (<>) {
\&        @tmp = split;
\&        push @AoA, [ @tmp ];
\&    }
.Ve
.PP
Yo ass might also have loaded dat from a gangbangin' function:
.PP
.Vb 3
\&    fo' $i ( 1 .. 10 ) {
\&        $AoA[$i] = [ somefunc($i) ];
\&    }
.Ve
.PP
Or you might have had a temporary variable chillin round wit the
array up in dat shit.
.PP
.Vb 4
\&    fo' $i ( 1 .. 10 ) {
\&        @tmp = somefunc($i);
\&        $AoA[$i] = [ @tmp ];
\&    }
.Ve
.PP
It aint nuthin but blingin you make shizzle ta use tha \f(CW\*(C`[ ]\*(C'\fR array reference
constructor. Shiiit, dis aint no joke.  Thatz cuz dis wouldn't work:
.PP
.Vb 1
\&    $AoA[$i] = @tmp;   # WRONG!
.Ve
.PP
Da reason dat don't do what tha fuck you want is cuz assignin a
named array like dat ta a scalar is takin a array up in scalar
context, which means just counts tha number of elements up in \f(CW@tmp\fR.
.PP
If yo ass is hustlin under \f(CW\*(C`use strict\*(C'\fR (and if yo ass aint, why in
the ghetto aren't yo slick ass?), you gonna gotta add some declarations to
make it happy:
.PP
.Vb 6
\&    use strict;
\&    my(@AoA, @tmp);
\&    while (<>) {
\&        @tmp = split;
\&        push @AoA, [ @tmp ];
\&    }
.Ve
.PP
Of course, you don't need tha temporary array ta git a name at all:
.PP
.Vb 3
\&    while (<>) {
\&        push @AoA, [ split ];
\&    }
.Ve
.PP
Yo ass also don't gotta use \fIpush()\fR.  Yo ass could just cook up a gangbangin' finger-lickin' direct assignment
if you knew where you wanted ta put it:
.PP
.Vb 5
\&    mah (@AoA, $i, $line);
\&    fo' $i ( 0 .. 10 ) {
\&        $line = <>;
\&        $AoA[$i] = [ split " ", $line ];
\&    }
.Ve
.PP
or even just
.PP
.Vb 4
\&    mah (@AoA, $i);
\&    fo' $i ( 0 .. 10 ) {
\&        $AoA[$i] = [ split " ", <> ];
\&    }
.Ve
.PP
Yo ass should up in general be leery of rockin functions dat could
potentially return lists up in scalar context without explicitly stating
such.  This would be clearer ta tha casual reader:
.PP
.Vb 4
\&    mah (@AoA, $i);
\&    fo' $i ( 0 .. 10 ) {
\&        $AoA[$i] = [ split " ", scalar(<>) ];
\&    }
.Ve
.PP
If you wanted ta git a \f(CW$ref_to_AoA\fR variable as a reference ta a array,
you'd gotta do suttin' like this:
.PP
.Vb 3
\&    while (<>) {
\&        push @$ref_to_AoA, [ split ];
\&    }
.Ve
.PP
Now you can add freshly smoked up rows.  What bout addin freshly smoked up columns?  If you is
dealin wit just matrices, itz often easiest ta use simple assignment:
.PP
.Vb 5
\&    fo' $x (1 .. 10) {
\&        fo' $y (1 .. 10) {
\&            $AoA[$x][$y] = func($x, $y);
\&        }
\&    }
\&
\&    fo' $x ( 3, 7, 9 ) {
\&        $AoA[$x][20] += func2($x);
\&    }
.Ve
.PP
It don't matta whether dem elements is already
there or not: it'll gladly create dem fo' you, setting
intervenin elements ta \f(CW\*(C`undef\*(C'\fR as need be.
.PP
If you wanted just ta append ta a row, you'd have
to do suttin' a lil' bit funnier looking:
.PP
.Vb 2
\&    # add freshly smoked up columns ta a existin row
\&    push @{ $AoA[0] }, "wilma", "betty";   # explicit deref
.Ve
.PP
Prior ta Perl 5.14, dis wouldn't even compile:
.PP
.Vb 1
\&    push $AoA[0], "wilma", "betty";        # implicit deref
.Ve
.PP
How tha fuck come?  Because back up in tha day, tha argument ta \fIpush()\fR had ta be a
real array, not just a reference ta one. Thatz no longer true.  In fact,
the line marked \*(L"implicit deref\*(R" above works just fine\*(--in this
instance\*(--to do what tha fuck tha one dat say explicit deref done did.
.PP
Da reason I holla'd \*(L"in dis instance\*(R" is cuz dat \fIonly\fR works
because \f(CW$AoA[0]\fR already held a array reference.  If you try dat on an
undefined variable, you gonna take a exception. I aint talkin' bout chicken n' gravy biatch.  Thatz cuz tha implicit
derefererence aint NEVER gonna autovivify a undefined variable tha way \f(CW\*(C`@{ }\*(C'\fR
always will:
.PP
.Vb 3
\&    mah $aref = undef;
\&    push $aref,  qw(some mo' joints);  # WRONG!
\&    push @$aref, qw(a few more);        # ok
.Ve
.PP
If you wanna take advantage of dis freshly smoked up implicit dereferencin behavior,
go right ahead: it make code easier on tha eye n' wrist.  Just understand
that olda releases will choke on it durin compilation. I aint talkin' bout chicken n' gravy biatch.  Whenever you make
use of suttin' dat works only up in some given release of Perl n' later,
but not earlier, you should place a prominent
.PP
.Vb 1
\&    use v5.14;   # needed fo' implicit deref of array refs by array ops
.Ve
.PP
directizzle all up in tha top of tha file dat needz dat shit.  That way when some muthafucka
tries ta run tha freshly smoked up code under a oldschool perl, rather than gettin a error like
.PP
.Vb 2
\&    Type of arg 1 ta push must be array (not array element) at /tmp/a line 8, near ""betty";"
\&    Execution of /tmp/a aborted cuz of compilation errors.
.Ve
.PP
they'll be politely informed that
.PP
.Vb 2
\&    Perl v5.14.0 required\-\-this is only v5.12.3, stopped at /tmp/a line 1.
\&    BEGIN failed\-\-compilation aborted at /tmp/a line 1.
.Ve
.SS "Access n' Printing"
.IX Subsection "Access n' Printing"
Now itz time ta print yo' data structure out.  How
are you goin ta do that?  Well, if you want only one
of tha elements, itz trivial:
.PP
.Vb 1
\&    print $AoA[0][0];
.Ve
.PP
If you wanna print tha whole thang, though, you can't
say
.PP
.Vb 1
\&    print @AoA;         # WRONG
.Ve
.PP
because you gonna git just references listed, n' perl will never
automatically dereference thangs fo' yo thugged-out ass.  Instead, you have to
roll yo ass a loop or two.  This prints tha whole structure,
usin tha shell-style \fIfor()\fR construct ta loop across tha outer
set of subscripts.
.PP
.Vb 3
\&    fo' $aref ( @AoA ) {
\&        say "\et [ @$aref ],";
\&    }
.Ve
.PP
If you wanted ta keep track of subscripts, you might do this:
.PP
.Vb 3
\&    fo' $i ( 0 .. $#AoA ) {
\&        say "\et elt $i is [ @{$AoA[$i]} ],";
\&    }
.Ve
.PP
or maybe even all dis bullshit.  Notice tha inner loop.
.PP
.Vb 5
\&    fo' $i ( 0 .. $#AoA ) {
\&        fo' $j ( 0 .. $#{$AoA[$i]} ) {
\&            say "elt $i $j is $AoA[$i][$j]";
\&        }
\&    }
.Ve
.PP
As you can see, itz gettin a lil' bit fucked up. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Thatz why
sometimes is easier ta take a temporary on yo' way through:
.PP
.Vb 6
\&    fo' $i ( 0 .. $#AoA ) {
\&        $aref = $AoA[$i];
\&        fo' $j ( 0 .. $#{$aref} ) {
\&            say "elt $i $j is $AoA[$i][$j]";
\&        }
\&    }
.Ve
.PP
Hmm... thatz still a lil' bit skanky.  How tha fuck bout this:
.PP
.Vb 7
\&    fo' $i ( 0 .. $#AoA ) {
\&        $aref = $AoA[$i];
\&        $n = @$aref \- 1;
\&        fo' $j ( 0 .. $n ) {
\&            say "elt $i $j is $AoA[$i][$j]";
\&        }
\&    }
.Ve
.PP
When you git pissed wit freestylin a cold-ass lil custom print fo' yo' data structures,
you might peep tha standard Dumpvalue or Data::Dumper modules.
Da forma is what tha fuck tha Perl debugger uses, while tha latta generates
parsable Perl code.  For example:
.PP
.Vb 1
\&    use v5.14;     # rockin tha + prototype, freshly smoked up ta v5.14
\&
\&    sub show(+) {
\&        require Dumpvalue;
\&        state $prettily = freshly smoked up Dumpvalue::
\&                            tick        => q("),
\&                            compactDump => 1,  # comment these two lines out
\&                            hellaCompact => 1,  # if you want a funky-ass bigger dump
\&                        ;
\&        dumpValue $prettily @_;
\&    }
\&
\&    # Assign a list of array references ta a array.
\&    mah @AoA = (
\&           [ "fred", "barney" ],
\&           [ "george", "jane", "elroy" ],
\&           [ "homer", "marge", "bart" ],
\&    );
\&    push $AoA[0], "wilma", "betty";
\&    show @AoA;
.Ve
.PP
will print out:
.PP
.Vb 3
\&    0  0..3  "fred" "barney" "wilma" "betty"
\&    1  0..2  "george" "jane" "elroy"
\&    2  0..2  "homer" "marge" "bart"
.Ve
.PP
Whereas if you comment up tha two lines I holla'd you might wish to,
then it shows it ta you dis way instead:
.PP
.Vb 10
\&    0  ARRAY(0x8031d0)
\&       0  "fred"
\&       1  "barney"
\&       2  "wilma"
\&       3  "betty"
\&    1  ARRAY(0x803d40)
\&       0  "george"
\&       1  "jane"
\&       2  "elroy"
\&    2  ARRAY(0x803e10)
\&       0  "homer"
\&       1  "marge"
\&       2  "bart"
.Ve
.SS "Slices"
.IX Subsection "Slices"
If you wanna git at a slice (part of a row) up in a multidimensional
array, you goin ta gotta do some fancy subscripting.  That's
because while our crazy asses gotz a sick synonym fo' single elements via the
pointa arrow fo' dereferencing, no such convenience exists fo' slices.
.PP
Herez how tha fuck ta do one operation rockin a loop.  We bout ta assume a \f(CW@AoA\fR
variable as before.
.PP
.Vb 5
\&    @part = ();
\&    $x = 4;
\&    fo' ($y = 7; $y < 13; $y++) {
\&        push @part, $AoA[$x][$y];
\&    }
.Ve
.PP
That same loop could be replaced wit a slice operation:
.PP
.Vb 1
\&    @part = @{$AoA[4]}[7..12];
.Ve
.PP
or spaced up a funky-ass bit:
.PP
.Vb 1
\&    @part = @{ $AoA[4] } [ 7..12 ];
.Ve
.PP
But as you might well imagine, dis can git pretty rough on tha reader.
.PP
Ah yo, but what tha fuck if you wanted a \fItwo-dimensionizzle slice\fR, like fuckin having
\&\f(CW$x\fR run from 4..8 n' \f(CW$y\fR run from 7 ta 12?  Hmm... herez tha simple way:
.PP
.Vb 6
\&    @newAoA = ();
\&    fo' ($startx = $x = 4; $x <= 8; $x++) {
\&        fo' ($starty = $y = 7; $y <= 12; $y++) {
\&            $newAoA[$x \- $startx][$y \- $starty] = $AoA[$x][$y];
\&        }
\&    }
.Ve
.PP
We can reduce a shitload of tha loopin all up in slices
.PP
.Vb 3
\&    fo' ($x = 4; $x <= 8; $x++) {
\&        push @newAoA, [ @{ $AoA[$x] } [ 7..12 ] ];
\&    }
.Ve
.PP
If you was tha fuck into Schwartzian Transforms, you would probably
have selected map fo' that
.PP
.Vb 1
\&    @newAoA = map { [ @{ $AoA[$_] } [ 7..12 ] ] } 4 .. 8;
.Ve
.PP
Although if yo' manager accused you of seekin thang securitizzle (or rapid
insecurity) all up in inscrutable code, it would be hard ta argue. :\-)
If I was you, I'd put dat up in a gangbangin' function:
.PP
.Vb 5
\&    @newAoA = splice_2D( \e@AoA, 4 => 8, 7 => 12 );
\&    sub splice_2D {
\&        mah $lrr = shift;        # ref ta array of array refs!
\&        mah ($x_lo, $x_hi,
\&            $y_lo, $y_hi) = @_;
\&
\&        return map {
\&            [ @{ $lrr\->[$_] } [ $y_lo .. $y_hi ] ]
\&        } $x_lo .. $x_hi;
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perldata, perlref, perldsc
.SH "AUTHOR"
.IX Header "AUTHOR"
Tomothy Christiansen <\fItchrist@perl.com\fR>
.PP
Last update: Tue Apr 26 18:30:55 \s-1MDT 2011\s0
