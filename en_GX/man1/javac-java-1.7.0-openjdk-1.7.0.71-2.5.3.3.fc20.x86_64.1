." Copyright (c) 1994, 2011, Oracle and/or its affiliates fo' realz. All muthafuckin rights reserved.
." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
."
." This code is free software; you can redistribute it and/or modify it
." under tha termz of tha GNU General Public License version 2 only, as
." published by tha Jacked Software Foundation.
."
." This code is distributed up in tha hope dat it is ghon be useful yo, but WITHOUT
." ANY WARRANTY; without even tha implied warranty of MERCHANTABILITY or
." FITNESS FOR A PARTICULAR PURPOSE.  See tha GNU General Public License
." version 2 fo' mo' details (a copy is included up in tha LICENSE file that
." accompanied dis code).
."
." Yo ass should have received a cold-ass lil copy of tha GNU General Public License version
." 2 along wit dis work; if not, write ta tha Jacked Software Foundation,
." Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
."
." Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
." or visit www.oracle.com if you need additionizzle shiznit or have any
." thangs.
."
.TH javac 1 "16 Mar 2012"

.LP
.SH "Name"
javac \- Java programmin language compiler
.LP
.SH "SYNOPSIS"
.LP
.nf
\f3
.fl
        \fP\f3javac\fP [ options ] [ sourcefilez ] [ classes ] [ @argfilez ]
.fl

.fl
.fi

.LP
.LP
Arguments may be up in any order.
.LP
.RS 3
.TP 3
options 
Command\-line options. 
.TP 3
sourcefilez 
One or mo' source filez ta be compiled (like fuckin MyClass.java). 
.TP 3
classes 
One or mo' classes ta be processed fo' annotations (like fuckin MyPackage.MyClass). 
.TP 3
@argfilez 
One or mo' filez dat lists options n' source files. Da \f2\-J\fP options is not allowed up in these files. 
.RE

.LP
.SH "DESCRIPTION"
.LP
.LP
Da \f3javac\fP tool readz class n' intercourse definitions, freestyled up in tha Java programmin language, n' compilez dem tha fuck into bytecode class files. Well shiiiit, it can also process annotations up in Java source filez n' classes.
.LP
.LP
There is two ways ta pass source code file names ta \f3javac\fP:
.LP
.RS 3
.TP 2
o
For a lil' small-ass number of source files, simply list tha file names on tha command line. 
.TP 2
o
For a big-ass number of source files, list tha file names up in a gangbangin' file, separated by blanks or line breaks. Then use tha list file name on tha \f3javac\fP command line, preceded by a \f3@\fP character n' shit. 
.RE

.LP
.LP
Source code file names must have \f2.java\fP suffixes, class file names must have \f2.class\fP suffixes, n' both source n' class filez must have root names dat identify tha class. For example, a cold-ass lil class called \f2MyClass\fP would be freestyled up in a source file called \f2MyClass.java\fP n' compiled tha fuck into a funky-ass bytecode class file called \f2MyClass.class\fP.
.LP
.LP
Inner class definitions produce additionizzle class files. These class filez have names combinin tha inner n' outa class names, like fuckin \f2MyClass$MyInnerClass.class\fP.
.LP
.LP
Yo ass should arrange source filez up in a gangbangin' finger-lickin' directory tree dat reflects they package tree. For example, if you keep all yo' source filez up in \f3/workspace\fP, tha source code fo' \f2com.mysoft.mypack.MyClass\fP should be up in \f3/workspace/com/mysoft/mypack/MyClass.java\fP.
.LP
.LP
By default, tha compila puts each class file up in tha same directory as its source file. Yo ass can specify a separate destination directory wit \f3\-d\fP (see Options, below).
.LP
.SH "OPTIONS"
.LP
.LP
Da compila has a set of standard options dat is supported on tha current pimpment environment n' is ghon be supported up in future releases fo' realz. An additionizzle set of non\-standard options is specific ta tha current virtual machine n' compila implementations n' is subject ta chizzle up in tha future. Non\-standard options begin wit \f3\-X\fP.
.LP
.SS 
Standard Options
.LP
.RS 3
.TP 3
\-Akey[=value] 
Options ta pass ta annotation processors. These is not interpreted by javac directly yo, but is made available fo' use by individual processors. \f2key\fP should be one or mo' identifiers separated by ".". 
.TP 3
\-cp path or \-classpath path 
Specify where ta find user class files, n' (optionally) annotation processors n' source files. This class path overrides tha user class path up in tha \f3CLASSPATH\fP environment variable. If neither \f3CLASSPATH\fP, \f3\-cp\fP nor \f3\-classpath\fP is specified, tha user class path consistz of tha current directory. Right back up in yo muthafuckin ass. See Settin tha Class Path fo' mo' details.
.br
.br
>If tha \f3\-sourcepath\fP option aint specified, tha user class path be also searched fo' source files.
.br
.br
If tha \f3\-processorpath\fP option aint specified, tha class path be also searched fo' annotation processors. 
.TP 3
\-Djava.ext.dirs=directories 
Override tha location of installed extensions. 
.TP 3
\-Djava.endorsed.dirs=directories 
Override tha location of endorsed standardz path. 
.TP 3
\-d directory 
Set tha destination directory fo' class files. Da directory must already exist; \f3javac\fP aint gonna create dat shit. If a cold-ass lil class is part of a package, \f3javac\fP puts tha class file up in a subdirectory reflectin tha package name, bustin directories as needed. Y'all KNOW dat shit, muthafucka! For example, if you specify \f3\-d /home/myclasses\fP n' tha class is called \f2com.mypackage.MyClass\fP, then tha class file is called \f2/home/myclasses/com/mypackage/MyClass.class\fP.
.br
.br
If \f3\-d\fP aint specified, \f3javac\fP puts each class filez up in tha same directory as tha source file from which dat shiznit was generated.
.br
.br
\f3Note:\fP Da directory specified by \f3\-d\fP aint automatically added ta yo' user class path. 
.TP 3
\-deprecation 
Show a thugged-out description of each use or override of a thugged-out deprecated member or class. Without \f3\-deprecation\fP, \f3javac\fP shows a summary of tha source filez dat use or override deprecated thugz or classes. \f3\-deprecation\fP is shorthand fo' \f3\-Xlint:deprecation\fP. 
.TP 3
\-encodin encodin 
Set tha source file encodin name, like fuckin \f2EUC\-JP n' UTF\-8\fP. If \f3\-encoding\fP aint specified, tha platform default converta is used. Y'all KNOW dat shit, muthafucka!  
.TP 3
\-endorseddirs directories 
Override tha location of endorsed standardz path. 
.TP 3
\-extdirs directories 
Overrides tha location of tha \f2ext\fP directory. Da \f2directories\fP variable be a cold-ass lil colon\-separated list of directories. Put ya muthafuckin choppers up if ya feel dis! Each JAR archive up in tha specified directories is searched fo' class filez fo' realz. All JAR archives found is automatically part of tha class path.
.br
.br
If yo ass is cross\-compilin (compilin classes against bootstrap n' extension classez of a gangbangin' finger-lickin' different Java platform implementation), dis option specifies tha directories dat contain tha extension classes. Right back up in yo muthafuckin ass. See Cross\-Compilation Options fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
\-g 
Generate all debuggin shiznit, includin local variables. By default, only line number n' source file shiznit is generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.TP 3
\-g:none 
Do not generate any debuggin shiznit. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
\-g:{keyword list} 
Generate only some kindz of debuggin shiznit, specified by a cold-ass lil comma separated list of keywords. Valid keywordz are: 
.RS 3
.TP 3
source 
Source file debuggin shiznit 
.TP 3
lines 
Line number debuggin shiznit 
.TP 3
vars 
Local variable debuggin shiznit 
.RE
.TP 3
\-help 
Print a synopsiz of standard options. 
.TP 3
\-implicit:{class,none} 
Controls tha generation of class filez fo' implicitly loaded source files. To automatically generate class files, use \f3\-implicit:class\fP. To suppress class file generation, use \f3\-implicit:none\fP. If dis option aint specified, tha default is ta automatically generate class files. In dis case, tha compila will issue a warnin if any such class filez is generated when also bustin annotation processing. Da warnin aint gonna be issued if dis option is set explicitly. Right back up in yo muthafuckin ass. See Searchin For Types.  
.TP 3
\-Joption 
Pass \f2option\fP ta tha \f3java\fP launcher called by \f3javac\fP. For example, \f3\-J\-Xms48m\fP sets tha startup memory ta 48 megabytes. Well shiiiit, it aint nuthin but a cold-ass lil common convention fo' \f3\-J\fP ta pass options ta tha underlyin VM executin applications freestyled up in Java.
.br
.br
\f3Note:\fP \f3CLASSPATH\fP, \f3\-classpath\fP, \f3\-bootclasspath\fP, n' \f3\-extdirs\fP do \f2not\fP specify tha classes used ta run \f3javac\fP. Fiddlin wit tha implementation of tha compila up in dis way is probably pointless n' always risky. If you do need ta do this, use tha \f3\-J\fP option ta pass all up in options ta tha underlyin \f3java\fP launcher n' shit. 
.TP 3
\-nowarn 
Disable warnin lyrics. This has tha same ol' dirty meanin as \f3\-Xlint:none\fP. 
.TP 3
\-proc: {none,only} 
Controls whether annotation processin and/or compilation is done. \f3\-proc:none\fP means dat compilation takes place without annotation processing. \f3\-proc:only\fP means dat only annotation processin is done, without any subsequent compilation. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
\-processor class1[,class2,class3...] 
Namez of tha annotation processors ta run. I aint talkin' bout chicken n' gravy biatch. This bypasses tha default discovery process. 
.TP 3
\-processorpath path 
Specify where ta find annotation processors; if dis option aint used, tha class path is ghon be searched fo' processors. 
.TP 3
\-s dir 
Specify tha directory where ta place generated source files. Da directory must already exist; \f3javac\fP aint gonna create dat shit. If a cold-ass lil class is part of a package, tha compila puts tha source file up in a subdirectory reflectin tha package name, bustin directories as needed. Y'all KNOW dat shit, muthafucka! For example, if you specify \f3\-s /home/mysrc\fP n' tha class is called \f2com.mypackage.MyClass\fP, then tha source file is ghon be placed up in \f2/home/mysrc/com/mypackage/MyClass.java\fP. 
.TP 3
\-source release 
Specifies tha version of source code accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da followin joints fo' \f2release\fP is allowed: 
.RS 3
.TP 3
1.3 
Da compila do \f2not\fP support assertions, generics, or other language features introduced afta Java SE 1.3. 
.TP 3
1.4 
Da compila accepts code containin assertions, which was introduced up in Java SE 1.4. 
.TP 3
1.5 
Da compila accepts code containin generics n' other language features introduced up in Java SE 5. 
.TP 3
5 
Synonym fo' 1.5. 
.TP 3
1.6 
No language chizzlez was introduced up in Java SE 6. But fuck dat shiznit yo, tha word on tha street is dat encodin errors up in source filez is now reported as errors instead of warnings as up in previous releasez of Java SE. 
.TP 3
6 
Synonym fo' 1.6. 
.TP 3
1.7 
This is tha default value. Da compila accepts code wit features introduced up in Java SE 7. 
.TP 3
7 
Synonym fo' 1.7. 
.RE
.TP 3
\-sourcepath sourcepath 
Specify tha source code path ta search fo' class or intercourse definitions fo' realz. As wit tha user class path, source path entries is separated by colons (\f3:\fP) n' can be directories, JAR archives, or ZIP archives. If packages is used, tha local path name within tha directory or archive must reflect tha package name.
.br
.br
\f3Note:\fP Classes found all up in tha class path may be subject ta automatic recompilation if they sources is also found. Y'all KNOW dat shit, muthafucka! See Searchin For Types. 
.TP 3
\-verbose 
Verbose output. This includes shiznit bout each class loaded n' each source file compiled. Y'all KNOW dat shit, muthafucka! 
.TP 3
\-version 
Print version shiznit. I aint talkin' bout chicken n' gravy biatch.  
.TP 3
\-Werror 
Terminizzle compilation if warnings occur. Shiiit, dis aint no joke. 
.TP 3
\-X 
Display shiznit bout non\-standard options n' exit. 
.RE

.LP
.SS 
Cross\-Compilation Options
.LP
.LP
By default, classes is compiled against tha bootstrap n' extension classez of tha platform dat \f3javac\fP shipped with. But \f3javac\fP also supports \f2cross\-compiling\fP, where classes is compiled against a funky-ass bootstrap n' extension classez of a gangbangin' finger-lickin' different Java platform implementation. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is blingin ta use \f3\-bootclasspath\fP n' \f3\-extdirs\fP when cross\-compiling; peep Cross\-Compilation Example below.
.LP
.RS 3
.TP 3
\-target version 
Generate class filez dat target a specified version of tha VM. Class filez will run on tha specified target n' on lata versions yo, but not on earlier versionz of tha VM. Valid targets is \f31.1\fP, \f31.2\fP, \f31.3\fP, \f31.4\fP, \f31.5\fP (also \f35\fP), \f31.6\fP (also \f36\fP), n' \f31.7\fP (also \f37\fP). 
.LP
Da default fo' \f3\-target\fP dependz on tha value of \f3\-source\fP: 
.RS 3
.TP 2
o
If \-source is \f3not specified\fP, tha value of \-target is \f31.7\fP 
.TP 2
o
If \-source is \f31.2\fP, tha value of \-target is \f31.4\fP 
.TP 2
o
If \-source is \f31.3\fP, tha value of \-target is \f31.4\fP 
.TP 2
o
If \-source is \f31.5\fP, tha value of \-target is \f31.7\fP 
.TP 2
o
If \-source is \f31.6\fP, tha value of \-target is \f31.7\fP 
.TP 2
o
For \f3all other joints\fP of \-source, tha value of \f3\-target\fP is tha value of \f3\-source\fP. 
.RE
.TP 3
\-bootclasspath bootclasspath 
Cross\-compile against tha specified set of boot classes fo' realz. As wit tha user class path, boot class path entries is separated by colons (\f3:\fP) n' can be directories, JAR archives, or ZIP archives. 
.RE

.LP
.SS 
Non\-Standard Options
.LP
.RS 3
.TP 3
\-Xbootclasspath/p:path 
Prepend ta tha bootstrap class path. 
.TP 3
\-Xbootclasspath/a:path 
Append ta tha bootstrap class path. 
.TP 3
\-Xbootclasspath/:path 
Override location of bootstrap class files. 
.TP 3
\-Xlint 
Enable all recommended warnings. In dis release, enablin all available warnings is recommended. Y'all KNOW dat shit, muthafucka! 
.TP 3
\-Xlint:all 
Enable all recommended warnings. In dis release, enablin all available warnings is recommended. Y'all KNOW dat shit, muthafucka! 
.TP 3
\-Xlint:none 
Disable all warnings. 
.TP 3
\-Xlint:name 
Enable warnin \f2name\fP. Right back up in yo muthafuckin ass. See tha section Warnings That Can Be Enabled or Disabled wit \-Xlint Option fo' a list of warnings you can enable wit dis option. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
\-Xlint:\-name 
Disable warnin \f2name\fP. Right back up in yo muthafuckin ass. See tha section Warnings That Can Be Enabled or Disabled wit \-Xlint Option fo' a list of warnings you can disable wit dis option. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
\-Xmaxerrs number 
Set tha maximum number of errors ta print. 
.TP 3
\-Xmaxwarns number 
Set tha maximum number of warnings ta print. 
.TP 3
\-Xstdout filename 
Send compila lyrics ta tha named file. By default, compila lyrics git all up in \f2System.err\fP. 
.TP 3
\-Xprefer:{newer,source} 
Specify which file ta read when both a source file n' class file is found fo' a type. (See Searchin For Types). If \f2\-Xprefer:newer\fP is used, it readz tha newer of tha source or class file fo' a type (default). If tha \f2\-Xprefer:source\fP option is used, it readz source file. Use \f2\-Xprefer:source\fP when you wanna be shizzle dat any annotation processors can access annotations declared wit a retention policy of \f2SOURCE\fP.  
.TP 3
\-Xpkginfo:{always,legacy,nonempty} 
Specify handlin of package\-info filez 
.TP 3
\-Xprint 
Print up textual representation of specified types fo' debuggin purposes; big-ass up neither annotation processin nor compilation. I aint talkin' bout chicken n' gravy biatch. Da format of tha output may chizzle. 
.TP 3
\-XprintProcessorInfo 
Print shiznit bout which annotations a processor be axed ta process. 
.TP 3
\-XprintRoundz 
Print shiznit bout initial n' subsequent annotation processin rounds. 
.RE

.LP
.SS 
Warnings That Can Be Enabled or Disabled wit \-Xlint Option
.LP
.LP
Enable warnin \f2name\fP wit tha option \f3\-Xlint:\fP\f2name\fP, where \f2name\fP is one of tha followin warnin names. Right back up in yo muthafuckin ass. Similarly, you can disable warnin \f2name\fP wit tha option \f3\-Xlint:\-\fP\f2name\fP:
.LP
.RS 3
.TP 3
cast 
Warn bout unnecessary n' redundant casts, n' you can put dat on yo' toast. For example: 
.nf
\f3
.fl
Strin s = (String)"Hello!"
.fl
\fP
.fi
.TP 3
classfile 
Warn bout thangs related ta classfile contents, n' you can put dat on yo' toast. 
.TP 3
deprecation 
Warn bout use of deprecated items. For example: 
.nf
\f3
.fl
    java.util.Date myDate = freshly smoked up java.util.Date();
.fl
    int currentDizzle = myDate.getDay();
.fl
\fP
.fi
Da method \f2java.util.Date.getDay\fP has been deprecated since JDK 1.1. 
.TP 3
dep\-ann 
Warn bout shit dat is documented wit a \f2@deprecated\fP Javadoc comment yo, but aint gots a \f2@Deprecated\fP annotation. I aint talkin' bout chicken n' gravy biatch. For example: 
.nf
\f3
.fl
  /**
.fl
   * @deprecated Az of Java SE 7, replaced by {@link #newMethod()}
.fl
   */
.fl

.fl
  hood static void deprecatedMethood() { }
.fl

.fl
  hood static void newMethod() { }
.fl
\fP
.fi
.TP 3
divzero 
Warn bout division by constant integer 0. For example: 
.nf
\f3
.fl
    int divideByZero = 42 / 0;
.fl
\fP
.fi
.TP 3
empty 
Warn bout empty statements afta \f2if\fP statements, n' you can put dat on yo' toast. For example: 
.nf
\f3
.fl
class E {
.fl
    void m() {
.fl
        if (true) ;
.fl
    }
.fl
}
.fl
\fP
.fi
.TP 3
fallall up in 
Peep \f2switch\fP blocks fo' fall\-all up in cases n' provide a warnin message fo' any dat is found. Y'all KNOW dat shit, muthafucka! Fall\-all up in cases is cases up in a \f2switch\fP block, other than tha last case up in tha block, whose code do not include a \f2break\fP statement, allowin code execution ta "fall through" from dat case ta tha next case. For example, tha code followin tha \f2case 1\fP label up in dis \f2switch\fP block do not end wit a \f2break\fP statement: 
.nf
\f3
.fl
switch (x) {
.fl
case 1:
.fl
       System.out.println("1");
.fl
       //  No break statement here.
.fl
case 2:
.fl
       System.out.println("2");
.fl
}
.fl
\fP
.fi
If tha \f2\-Xlint:fallthrough\fP flag was used when compilin dis code, tha compila would emit a warnin bout "possible fall\-all up in tha fuck into case," along wit tha line number of tha case up in question. I aint talkin' bout chicken n' gravy biatch. 
.TP 3
finally 
Warn bout \f2finally\fP clauses dat cannot complete normally. For example: 
.nf
\f3
.fl
  hood static int m() {
.fl
    try {
.fl
      throw freshly smoked up NullPointerException();
.fl
    } catch (NullPointerException e) {
.fl
      System.err.println("Caught NullPointerException.");
.fl
      return 1;
.fl
    } finally {
.fl
      return 0;
.fl
    }
.fl
  }
.fl
\fP
.fi
Da compila generates a warnin fo' \f2finally\fP block up in dis example. When dis method is called, it returns a value of \f20\fP, not \f21\fP fo' realz. A \f2finally\fP block always executes when tha \f2try\fP block exits, n' you can put dat on yo' toast. In dis example, if control is transferred ta tha \f2catch\fP, then tha method exits, n' you can put dat on yo' toast. But fuck dat shiznit yo, tha word on tha street is dat tha \f2finally\fP block must be executed, so it is executed, even though control has already been transferred outside tha method. Y'all KNOW dat shit, muthafucka! 
.TP 3
options 
Warn bout thangs relatin ta tha use of command line options. Right back up in yo muthafuckin ass. See Cross\-Compilation Example fo' a example of dis kind of warning. 
.TP 3
overrides 
Warn bout thangs regardin method overrides. For example, consider tha followin two classes: 
.nf
\f3
.fl
hood class ClassWithVarargsMethod {
.fl
  void varargsMethod(String... s) { }
.fl
}
.fl
\fP
.fi
.nf
\f3
.fl
hood class ClassWithOverridingMethod extendz ClassWithVarargsMethod {
.fl
  @Override
.fl
  void varargsMethod(String[] s) { }
.fl
}
.fl
\fP
.fi
Da compila generates a warnin similar ta tha following:
.br
.br
\f2warning: [override] varargsMethod(String[]) up in ClassWithOverridingMethod overrides varargsMethod(String...) up in ClassWithVarargsMethod; overridin method is missin '...'\fP
.br
.br
When tha compila encountas a varargs method, it translates tha varargs formal parameta tha fuck into a array. In tha method \f2ClassWithVarargsMethod.varargsMethod\fP, tha compila translates tha varargs formal parameta \f2String... s\fP ta tha formal parameta \f2String[] s\fP, a array, which matches tha formal parameta of tha method \f2ClassWithOverridingMethod.varargsMethod\fP. Consequently, dis example compiles. 
.TP 3
path 
Warn bout invalid path elements n' nonexistent path directories on tha command line (with regardz ta tha class path, tha source path, n' other paths). Right back up in yo muthafuckin ass. Such warnings cannot be suppressed wit tha \f2@SuppressWarnings\fP annotation. I aint talkin' bout chicken n' gravy biatch. For example: 
.nf
\f3
.fl
javac \-Xlint:path \-classpath /nonexistentpath Example.java
.fl
\fP
.fi
.TP 3
processin 
Warn bout thangs regardin annotation processing. Da compila generates dis warnin if you gotz a cold-ass lil class dat has a annotation, n' you use a annotation processor dat cannot handle dat type of exception. I aint talkin' bout chicken n' gravy biatch. For example, tha followin be a simple annotation processor:
.br
.br
\f3Source file \fP\f4AnnoProc.java\fP: 
.nf
\f3
.fl
import java.util.*;
.fl
import javax.annotation.processing.*;
.fl
import javax.lang.model.*;
.fl
import javax.lang.model.element.*;
.fl

.fl
@SupportedAnnotationTypes("NotAnno")
.fl
hood class AnnoProc extendz AbstractProcessor {
.fl
    hood boolean process(Set<? extendz TypeElement> elems, RoundEnvironment renv) {
.fl
        return true;
.fl
    }
.fl

.fl
    hood SourceVersion getSupportedSourceVersion() {
.fl
        return SourceVersion.latest();
.fl
    }
.fl
}
.fl
\fP
.fi
\f3Source file \fP\f4AnnosWithoutProcessors.java\fP\f3:\fP 
.nf
\f3
.fl
@interface Anno { }
.fl

.fl
@Anno
.fl
class AnnosWithoutProcessors { }
.fl
\fP
.fi
Da followin commandz compile tha annotation processor \f2AnnoProc\fP, then run dis annotation processor against tha source file \f2AnnosWithoutProcessors.java\fP: 
.nf
\f3
.fl
% \fP\f3javac AnnoProc.java\fP
.fl
% \f3javac \-cp . \-Xlint:processin \-processor AnnoProc \-proc:only AnnosWithoutProcessors.java\fP
.fl
.fi
When tha compila runs tha annotation processor against tha source file \f2AnnosWithoutProcessors.java\fP, it generates tha followin warning:
.br
.br
\f2warning: [processing] No processor fronted any of these annotations: Anno\fP
.br
.br
To resolve dis issue, you can rename tha annotation defined n' used up in tha class \f2AnnosWithoutProcessors\fP from \f2Anno\fP ta \f2NotAnno\fP. 
.TP 3
rawtypes 
Warn bout unchecked operations on raw types. Da followin statement generates a \f2rawtypes\fP warning: 
.nf
\f3
.fl
void countElements(List l) { ... }
.fl
\fP
.fi
Da followin do not generate a \f2rawtypes\fP warning: 
.nf
\f3
.fl
void countElements(List<?> l) { ... }
.fl
\fP
.fi
\f2List\fP be a raw type. But fuck dat shiznit yo, tha word on tha street is dat \f2List<?>\fP be a unbounded wildcard parameterized type. Because \f2List\fP be a parameterized intercourse, you should always specify its type argument. In dis example, tha \f2List\fP formal argument is specified wit a unbounded wildcard (\f2?\fP) as its formal type parameter, which means dat tha \f2countElements\fP method can accept any instantiation of tha \f2List\fP intercourse. 
.TP 3
serial 
Warn bout missin \f2serialVersionUID\fP definitions on serializable classes. For example: 
.nf
\f3
.fl
hood class PersistentTime implements Serializable
.fl
{
.fl
  private Date time;
.fl

.fl
   hood PersistentTime() {
.fl
     time = Calendar.getInstance().getTime();
.fl
   }
.fl

.fl
   hood Date getTime() {
.fl
     return time;
.fl
   }
.fl
}
.fl
\fP
.fi
Da compila generates tha followin warning:
.br
.br
\f2warning: [serial] serializable class PersistentTime has no definizzle of serialVersionUID\fP
.br
.br
If a serializable class do not explicitly declare a gangbangin' field named \f2serialVersionUID\fP, then tha serialization runtime will calculate a thugged-out default \f2serialVersionUID\fP value fo' dat class based on various aspectz of tha class, as busted lyrics bout up in tha Java Object Serialization Justification. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat it is straight fuckin recommended dat all serializable classes explicitly declare \f2serialVersionUID\fP joints cuz tha default process of computin \f2serialVersionUID\fP valez is highly sensitizzle ta class details dat may vary dependin on compila implementations, n' can thus result up in unexpected \f2InvalidClassExceptions\fP durin deserialization. I aint talkin' bout chicken n' gravy biatch. Therefore, ta guarantee a cold-ass lil consistent \f2serialVersionUID\fP value across different Java compila implementations, a serializable class must declare a explicit \f2serialVersionUID\fP value. 
.TP 3
static 
Warn bout thangs relatin ta use of statics. For example: 
.nf
\f3
.fl
class XLintStatic {
.fl
    static void m1() { }
.fl
    void m2() { all dis bullshit.m1(); }
.fl
}
.fl
\fP
.fi
Da compila generates tha followin warning: 
.nf
\f3
.fl
warning: [static] static method should be qualified by type name, XLintStatic, instead of by a expression
.fl
\fP
.fi
To resolve dis issue, you can call tha static method \f2m1\fP as bigs up: 
.nf
\f3
.fl
XLintStatic.m1();
.fl
\fP
.fi
Alternatively, you can remove tha \f2static\fP keyword from tha declaration of tha method \f2m1\fP. 
.TP 3
try 
Warn bout thangs relatin ta use of \f2try\fP blocks, includin try\-with\-resources statements, n' you can put dat on yo' toast. For example, a warnin is generated fo' tha followin statement cuz tha resource \f2ac\fP declared up in tha \f2try\fP statement aint used: 
.nf
\f3
.fl
try ( AutoCloseable ac = getResource() ) {
.fl
    // do nothing
.fl
}
.fl
\fP
.fi
.TP 3
unchecked 
Give mo' detail fo' unchecked conversion warnings dat is mandated by tha Java Language Justification. I aint talkin' bout chicken n' gravy biatch. For example: 
.nf
\f3
.fl
    List l = freshly smoked up ArrayList<Number>();
.fl
    List<String> ls = l;       // unchecked warning
.fl
\fP
.fi
Durin type erasure, tha types \f2ArrayList<Number>\fP n' \f2List<String>\fP become \f2ArrayList\fP n' \f2List\fP, respectively.
.br
.br
Da variable \f2ls\fP has tha parameterized type \f2List<String>\fP. When tha \f2List\fP referenced by \f2l\fP be assigned ta \f2ls\fP, tha compila generates a unchecked warning; tha compila is unable ta determine at compile time, n' moreover knows dat tha JVM aint gonna be able ta determine at runtime, if \f2l\fP refers ta a \f2List<String>\fP type; it do not. Consequently, heap bullshit occurs.
.br
.br
In detail, a heap bullshit thang occurs when tha \f2List\fP object \f2l\fP, whose static type is \f2List<Number>\fP, be assigned ta another \f2List\fP object, \f2ls\fP, dat has a gangbangin' finger-lickin' different static type, \f2List<String>\fP. But fuck dat shiznit yo, tha word on tha street is dat tha compila still allows dis assignment. Well shiiiit, it must allow dis assignment ta preserve backwardz compatibilitizzle wit versionz of Java SE dat do not support generics. Because of type erasure, \f2List<Number>\fP n' \f2List<String>\fP both become \f2List\fP. Consequently, tha compila allows tha assignment of tha object \f2l\fP, which has a raw type of \f2List\fP, ta tha object \f2ls\fP. 
.TP 3
varargs 
Warn bout unsafe usagez of variable arguments (varargs) methods, up in particular, dem dat contain non\-reifiable arguments, n' you can put dat on yo' toast. For example: 
.nf
\f3
.fl
hood class ArrayBuilder {
.fl
  hood static <T> void addToList (List<T> listArg, T... elements) {
.fl
    fo' (T x : elements) {
.fl
      listArg.add(x);
.fl
    }
.fl
  }
.fl
}
.fl
\fP
.fi
Da compila generates tha followin warnin fo' tha definizzle of tha method \f2ArrayBuilder.addToList\fP: 
.nf
\f3
.fl
warning: [varargs] Possible heap bullshit from parameterized vararg type T
.fl
\fP
.fi
When tha compila encountas a varargs method, it translates tha varargs formal parameta tha fuck into a array. But fuck dat shiznit yo, tha word on tha street is dat tha Java programmin language do not permit tha creation of arrayz of parameterized types. In tha method \f2ArrayBuilder.addToList\fP, tha compila translates tha varargs formal parameta \f2T... elements\fP ta tha formal parameta \f2T[] elements\fP, a array. But fuck dat shiznit yo, tha word on tha street is dat cuz of type erasure, tha compila converts tha varargs formal parameta ta \f2Object[] elements\fP. Consequently, there be a possibilitizzle of heap bullshit. 
.RE

.LP
.SH "COMMAND LINE ARGUMENT FILES"
.LP
.LP
To shorten or simplify tha javac command line, you can specify one or mo' filez dat theyselves contain arguments ta tha \f2javac\fP command (except \f2\-J\fP options). This enablez you ta create javac commandz of any length on any operatin system.
.LP
.LP
An argument file can include javac options n' source filenames up in any combination. I aint talkin' bout chicken n' gravy biatch. Da arguments within a gangbangin' file can be space\-separated or newline\-separated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If a gangbangin' filename gotz nuff embedded spaces, put tha whole filename up in double quotes.
.LP
.LP
Filenames within a argument file is relatizzle ta tha current directory, not tha location of tha argument file. Wildcardz (*) is not allowed up in these lists (like fuckin fo' specifyin \f2*.java\fP). Use of tha '\f2@\fP' characta ta recursively interpret filez aint supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \f2\-J\fP options is not supported cuz they is passed ta tha launcher, which do not support argument files.
.LP
.LP
When executin javac, pass up in tha path n' name of each argument file wit tha '\f2@\fP' leadin character n' shit. When javac encountas a argument beginnin wit tha characta `\f2@\fP', it expandz tha contentz of dat file tha fuck into tha argument list.
.LP
.SS 
Example \- Single Arg File
.LP
.LP
Yo ass could bust a single argument file named "\f2argfile\fP" ta hold all javac arguments:
.LP
.nf
\f3
.fl
% \fP\f3javac @argfile\fP
.fl
.fi

.LP
.LP
This argument file could contain tha contentz of both filez shown up in tha next example.
.LP
.SS 
Example \- Two Arg Files
.LP
.LP
Yo ass can create two argument filez \-\- one fo' tha javac options n' tha other fo' tha source filenames: (Notice tha followin lists have no line\-continuation characters.)
.LP
.LP
Smoke a gangbangin' file named "\f2options\fP" containing:
.LP
.nf
\f3
.fl
     \-d classes
.fl
     \-g
.fl
     \-sourcepath /java/pubs/ws/1.3/src/share/classes
.fl

.fl
\fP
.fi

.LP
.LP
Smoke a gangbangin' file named "\f2classes\fP" containing:
.LP
.nf
\f3
.fl
     MyClass1.java
.fl
     MyClass2.java
.fl
     MyClass3.java
.fl

.fl
\fP
.fi

.LP
.LP
Yo ass would then run \f3javac\fP with:
.LP
.nf
\f3
.fl
  % \fP\f3javac @options @classes\fP
.fl

.fl
.fi

.LP
.SS 
Example \- Arg Filez wit Paths
.LP
.LP
Da argument filez can have paths yo, but any filenames inside tha filez is relatizzle ta tha current hustlin directory (not \f2path1\fP or \f2path2\fP):
.LP
.nf
\f3
.fl
% \fP\f3javac @path1/options @path2/classes\fP
.fl
.fi

.LP
.SH "ANNOTATION PROCESSING"
.LP
.LP
\f3javac\fP serves up direct support fo' annotation processing, supersedin tha need fo' tha separate annotation processin tool, \f3apt\fP.
.LP
.LP
Da API fo' annotation processors is defined up in tha \f2javax.annotation.processing\fP n' \f2javax.lang.model\fP packages n' subpackages.
.LP
.SS 
Overview of annotation processing
.LP
.LP
Unless annotation processin is disabled wit tha \f3\-proc:none\fP option, tha compila searches fo' any annotation processors dat is available. Da search path can be specified wit tha \f3\-processorpath\fP option; if it aint given, tha user class path is used. Y'all KNOW dat shit, muthafucka! Processors is located by meanz of steez provider\-configuration filez named \f2META\-INF/skillz/javax.annotation.processing.Processor\fP on tha search path. Right back up in yo muthafuckin ass. Such filez should contain tha namez of any annotation processors ta be used, listed one per line fo' realz. Alternatively, processors can be specified explicitly, rockin tha \f3\-processor\fP option.
.LP
.LP
Afta scannin tha source filez n' classes on tha command line ta determine what tha fuck annotations is present, tha compila queries tha processors ta determine what tha fuck annotations they process. When a match is found, tha processor is ghon be invoked. Y'all KNOW dat shit, muthafucka! A processor may "claim" tha annotations it processes, up in which case no further attempt is made ta find any processors fo' dem annotations. Once all annotations done been fronted, tha compila do not look fo' additionizzle processors.
.LP
.LP
If any processors generate any freshly smoked up source files, another round of annotation processin will occur: any newly generated source filez is ghon be scanned, n' tha annotations processed as before fo' realz. Any processors invoked on previous roundz will also be invoked on all subsequent rounds. This continues until no freshly smoked up source filez is generated.
.LP
.LP
Afta a round occurs where no freshly smoked up source filez is generated, tha annotation processors is ghon be invoked one last time, ta give dem a cold-ass lil chizzle ta complete any work they may need ta do. Finally, unless tha \f3\-proc:only\fP option is used, tha compila will compile tha original gangsta n' all tha generated source files.
.LP
.SS 
Implicitly loaded source files
.LP
.LP
To compile a set of source files, tha compila may need ta implicitly load additionizzle source files. (See Searchin For Types). Right back up in yo muthafuckin ass. Such filez is currently not subject ta annotation processing. By default, tha compila will give a warnin if annotation processin has occurred n' any implicitly loaded source filez is compiled. Y'all KNOW dat shit, muthafucka! See tha \-implicit option fo' ways ta suppress tha warning.
.LP
.SH "SEARCHING FOR TYPES"
.LP
.LP
When compilin a source file, tha compila often needz shiznit on some type whose definizzle did not step tha fuck up in tha source filez given on tha command line. Da compila needz type shiznit fo' every last muthafuckin class or intercourse used, extended, or implemented up in tha source file. This includes classes n' intercourses not explicitly mentioned up in tha source file but which provide shiznit all up in inheritance.
.LP
.LP
For example, when you subclass \f3java.applet.Applet\fP, yo ass be also rockin \f3Applet's\fP ancestor classes: \f3java.awt.Panel\fP, \f3java.awt.Container\fP, \f3java.awt.Component\fP, n' \f3java.lang.Object\fP.
.LP
.LP
When tha compila needz type shiznit, it looks fo' a source file or class file which defines tha type. Da compila searches fo' class filez first up in tha bootstrap n' extension classes, then up in tha user class path (which by default is tha current directory). Da user class path is defined by settin tha \f3CLASSPATH\fP environment variable or by rockin tha \f3\-classpath\fP command line option. I aint talkin' bout chicken n' gravy biatch. (For details, peep Settin tha Class Path).
.LP
.LP
If you set tha \-sourcepath option, tha compila searches tha indicated path fo' source files; otherwise tha compila searches tha user class path fo' both class filez n' source files.
.LP
.LP
Yo ass can specify different bootstrap or extension classes wit tha \f3\-bootclasspath\fP n' \f3\-extdirs\fP options; peep Cross\-Compilation Options below.
.LP
.LP
A successful type search may produce a cold-ass lil class file, a source file, or both. If both is found, you can use tha \-Xprefer option ta instruct tha compila which ta use. If \f3newer\fP is given, tha compila will use tha newer of tha two files. If \f3source\fP is given, it will use tha source file. Da default is \f3newer\fP.
.LP
.LP
If a type search findz a source file fo' a required type, either by itself, or as a result of tha settin fo' \f3\-Xprefer\fP, tha compila will read tha source file ta git tha shiznit it needs. In addition, it will by default compile tha source file as well. Yo ass can use tha \-implicit option ta specify tha behavior. Shiiit, dis aint no joke. If \f3none\fP is given, no class filez is ghon be generated fo' tha source file. If \f3class\fP is given, class filez is ghon be generated fo' tha source file.
.LP
.LP
Da compila may not discover tha need fo' some type shiznit until afta annotation processin is complete. If tha type shiznit is found up in a source file n' no \f3\-implicit\fP option is given, tha compila will give a warnin dat tha file is bein compiled without bein subject ta annotation processing. To disable tha warning, either specify tha file on tha command line (so dat it is ghon be subject ta annotation processing) or use tha \f3\-implicit\fP option ta specify whether or not class filez should be generated fo' such source files.
.LP
.SH "PROGRAMMATIC INTERFACE"
.LP
.LP
\f3javac\fP supports tha freshly smoked up Java Compila API defined by tha classes n' intercourses up in tha \f2javax.tools\fP package.
.LP
.SS 
Example
.LP
.LP
To big-ass up a cold-ass lil compilation rockin arguments as you would give on tha command line, you can use tha following:
.LP
.nf
\f3
.fl
JavaCompila javac = ToolProvider.getSystemJavaCompiler();
.fl
int rc = javac.run(null, null, null, args);
.fl
\fP
.fi

.LP
.LP
This will write any diagnostics ta tha standard output stream, n' return tha exit code dat \f3javac\fP would give when invoked from tha command line.
.LP
.LP
Yo ass can use other methodz on tha \f2javax.tools.JavaCompiler\fP intercourse ta handle diagnostics, control where filez is read from n' freestyled to, n' so on.
.LP
.SS 
Oldskool Interface
.LP
.LP
\f3Note:\fP This API is retained fo' backwardz compatibilitizzle only; all freshly smoked up code should use tha Java Compila API, busted lyrics bout above.
.LP
.LP
Da \f2com.sun.tools.javac.Main\fP class serves up two static methodz ta invoke tha compila from a program:
.LP
.nf
\f3
.fl
hood static int compile(String[] args);
.fl
hood static int compile(String[] args, PrintWrita out);
.fl
\fP
.fi

.LP
.LP
Da \f2args\fP parameta represents any of tha command line arguments dat would normally be passed ta tha javac program n' is outlined up in tha above Synopsis section.
.LP
.LP
Da \f2out\fP parameta indicates where tha compilerz diagnostic output is directed.
.LP
.LP
Da return value is equivalent ta tha exit value from \f3javac\fP.
.LP
.LP
Note dat all \f3other\fP classes n' methodz found up in a package whose name starts wit \f2com.sun.tools.javac\fP (informally known as sub\-packagez of \f2com.sun.tools.javac\fP) is strictly internal n' subject ta chizzle at any time.
.LP
.SH "EXAMPLES"
.LP
.SS 
Compilin a Simple Program
.LP
.LP
One source file, \f2Hello.java\fP, defines a cold-ass lil class called \f3greetings.Hello\fP. Da \f2greetings\fP directory is tha package directory both fo' tha source file n' tha class file n' is off tha current directory. This allows our asses ta use tha default user class path. Well shiiiit, it also make it unnecessary ta specify a separate destination directory wit \f3\-d\fP.
.LP
.nf
\f3
.fl
% \fP\f3ls\fP
.fl
greetings/
.fl
% \f3ls greetings\fP
.fl
Hello.java
.fl
% \f3cat greetings/Hello.java\fP
.fl
package greetings;
.fl

.fl
hood class Wuz crackalackin' {
.fl
    hood static void main(String[] args) {
.fl
        fo' (int i=0; i < args.length; i++) {
.fl
            System.out.println("Wuz crackalackin' " + args[i]);
.fl
        }
.fl
    }
.fl
}
.fl
% \f3javac greetings/Hello.java\fP
.fl
% \f3ls greetings\fP
.fl
Hello.class   Hello.java
.fl
% \f3java greetings.Wuz crackalackin' Ghetto Universe Everyone\fP
.fl
Wuz crackalackin' World
.fl
Wuz crackalackin' Universe
.fl
Wuz crackalackin' Everyone
.fl
.fi

.LP
.SS 
Compilin Multiple Source Files
.LP
.LP
This example compilez all tha source filez up in tha package \f2greetings\fP.
.LP
.nf
\f3
.fl
% \fP\f3ls\fP
.fl
greetings/
.fl
% \f3ls greetings\fP
.fl
Aloha.java         GutenTag.java      Hello.java         Hi.java
.fl
% \f3javac greetings/*.java\fP
.fl
% \f3ls greetings\fP
.fl
Aloha.class         GutenTag.class      Hello.class         Hi.class
.fl
Aloha.java          GutenTag.java       Hello.java          Hi.java
.fl
.fi

.LP
.SS 
Specifyin a User Class Path
.LP
.LP
Havin chizzled one of tha source filez up in tha previous example, we recompile it:
.LP
.nf
\f3
.fl
% \fP\f3pwd\fP
.fl
/examples
.fl
% \f3javac greetings/Hi.java\fP
.fl
.fi

.LP
.LP
Since \f2greetings.Hi\fP refers ta other classes up in tha \f2greetings\fP package, tha compila need ta find these other classes. Da example above works, cuz our default user class path happens ta be tha directory containin tha package directory. But suppose we wanna recompile dis file n' not worry bout which directory we in? Then we need ta add \f2/examples\fP ta tha user class path. We can do dis by settin \f3CLASSPATH\fP yo, but here we'll use tha \f3\-classpath\fP option.
.LP
.nf
\f3
.fl
% \fP\f3javac \-classpath /examplez /examples/greetings/Hi.java\fP
.fl
.fi

.LP
.LP
If we chizzle \f2greetings.Hi\fP again, ta bust a funky-ass banner utility, dat utilitizzle also need ta be accessible all up in tha user class path.
.LP
.nf
\f3
.fl
% \fP\f3javac \-classpath /examples:/lib/Banners.jar \\ 
.fl
            /examples/greetings/Hi.java\fP
.fl
.fi

.LP
.LP
To execute a cold-ass lil class up in \f2greetings\fP, we need access both ta \f2greetings\fP n' ta tha classes it uses.
.LP
.nf
\f3
.fl
% \fP\f3java \-classpath /examples:/lib/Banners.jar greetings.Hi\fP
.fl
.fi

.LP
.SS 
Separatin Source Filez n' Class Files
.LP
.LP
It often make sense ta keep source filez n' class filez up in separate directories, especially on big-ass projects, n' you can put dat on yo' toast. We use \f3\-d\fP ta indicate tha separate class file destination. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since tha source filez is not up in tha user class path, we use \f3\-sourcepath\fP ta help tha compila find em.
.LP
.nf
\f3
.fl
% \fP\f3ls\fP
.fl
classes/  lib/      src/
.fl
% \f3ls src\fP
.fl
farewells/
.fl
% \f3ls src/farewells\fP
.fl
Base.java      GoodBye.java
.fl
% \f3ls lib\fP
.fl
Banners.jar
.fl
% \f3ls classes\fP
.fl
% \f3javac \-sourcepath src \-classpath classes:lib/Banners.jar \\ 
.fl
            src/farewells/GoodBye.java \-d classes\fP
.fl
% \f3ls classes\fP
.fl
farewells/
.fl
% \f3ls classes/farewells\fP
.fl
Base.class      GoodBye.class
.fl
.fi

.LP
.LP
\f3Note:\fP Da compila compiled \f2src/farewells/Base.java\fP, even though our phat asses didn't specify it on tha command line. To trace automatic compiles, use tha \f3\-verbose\fP option.
.LP
.SS 
Cross\-Compilation Example
.LP
.LP
Da followin example uses \f3javac\fP ta compile code dat will run on a 1.6 VM.
.LP
.nf
\f3
.fl
% \fP\f3javac \-source 1.6 \-target 1.6 \-bootclasspath jdk1.6.0/lib/rt.jar \\ 
.fl
            \-extdirs "" OldCode.java\fP
.fl
.fi

.LP
.LP
Da \f2\-source 1.6\fP option specifies dat version 1.6 (or 6) of tha Java programmin language be used ta compile \f2OldCode.java\fP. Da option \f3\-target 1.6\fP option ensures dat tha generated class filez is ghon be compatible wit 1.6 VMs. Note dat up in most cases, tha value of tha \f3\-target\fP option is tha value of tha \f3\-source\fP option; up in dis example, you can omit tha \f3\-target\fP option.
.LP
.LP
Yo ass must specify tha \f3\-bootclasspath\fP option ta specify tha erect version of tha bootstrap classes (the \f2rt.jar\fP library). If not, tha compila generates a warning:
.LP
.nf
\f3
.fl
% \fP\f3javac \-source 1.6 OldCode.java\fP
.fl
warning: [options] bootstrap class path not set up in conjunction wit \-source 1.6
.fl
.fi

.LP
.LP
If you do not specify tha erect version of bootstrap classes, tha compila will use tha oldschool language rulez (in dis example, it will use version 1.6 of tha Java programmin language) combined wit tha freshly smoked up bootstrap classes, which can result up in class filez dat do not work on tha olda platform (in dis case, Java SE 6) cuz reference ta non\-existent methodz can git included.
.LP
.SH "SEE ALSO"
.LP
.RS 3
.TP 2
o
.na
\f2Da javac Guide\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/javac/index.html 
.TP 2
o
java(1) \- tha Java Application Launcher 
.TP 2
o
jdb(1) \- Java Application Debugger 
.TP 2
o
javah(1) \- C Header n' Stub File Generator 
.TP 2
o
javap(1) \- Class File Disassembla 
.TP 2
o
javadoc(1) \- API Documentation Generator 
.TP 2
o
jar(1) \- JAR Archive Tool 
.TP 2
o
.na
\f2Da Java Extensions Framework\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/extensions/index.html 
.RE

.LP
 
