.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPACKTUT 1"
.TH PERLPACKTUT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpacktut \- tutorial on "pack" n' "unpack"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR is two functions fo' transformin data according
to a user-defined template, between tha guarded way Perl stores joints
and some well-defined representation as might be required up in tha 
environment of a Perl program. Unfortunately, they also two of 
da most thugged-out misunderstood n' most often overlooked functions dat Perl
provides. This tutorial will demystify dem fo' yo thugged-out ass.
.SH "Da Basic Principle"
.IX Header "Da Basic Principle"
Most programmin languages don't shelta tha memory where variablez are
stored. Y'all KNOW dat shit, muthafucka! In C, fo' instance, you can take tha address of some variable,
and tha \f(CW\*(C`sizeof\*(C'\fR operator  drops some lyrics ta you how tha fuck nuff bytes is allocated to
the variable. Usin tha address n' tha size, you may access tha storage
to yo' heartz content.
.PP
In Perl, you just can't access memory at random yo, but tha structural and
representationizzle conversion provided by \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR be an
pimpin alternative. Da \f(CW\*(C`pack\*(C'\fR function converts joints ta a funky-ass byte
sequence containin representations accordin ta a given justification,
the so-called \*(L"template\*(R" argument. \f(CW\*(C`unpack\*(C'\fR is tha reverse process,
derivin some joints from tha contentz of a strang of bytes. (Be cautioned,
however, dat not all dat has been packed together can be neatly unpacked \- 
a straight-up common experience as seasoned travellaz is likely ta confirm.)
.PP
Why, you may ask, would you need a cold-ass lil chunk of memory containin some joints
in binary representation? One phat reason is input n' output accessing
some file, a thugged-out device, or a network connection, whereby dis binary
representation is either forced on you or will hit you wit some benefit
in processin fo' realz. Another cause is passin data ta some system call that
is not available as a Perl function: \f(CW\*(C`syscall\*(C'\fR requires you ta provide
parametas stored up in tha way it happens up in a C program. Even text processin 
(as shown up in tha next section) may be simplified wit judicious usage 
of these two functions.
.PP
To peep how tha fuck (un)packin works, we'll start wit a simple template
code where tha conversion is up in low gear: between tha contentz of a funky-ass byte
sequence n' a strang of hexadecimal digits, n' you can put dat on yo' toast. Letz use \f(CW\*(C`unpack\*(C'\fR, since
this is likely ta remind you of a thugged-out dump program, or some desperate last
message fucked up programs is aint gonna ta throw at you before they expire
into tha wild blue yonder n' shiznit fo' realz. Assumin dat tha variable \f(CW$mem\fR holdz a 
sequence of bytes dat we'd like ta inspect without assumin anythang 
about its meaning, we can write
.PP
.Vb 2
\&   my( $hex ) = unpack( \*(AqH*\*(Aq, $mem );
\&   print "$hex\en";
.Ve
.PP
whereupon we might peep suttin' like this, wit each pair of hex digits
correspondin ta a funky-ass byte:
.PP
.Vb 1
\&   41204d414e204120504c414e20412043414e414c2050414e414d41
.Ve
.PP
What was up in dis chunk of memory? Numbers, characters, or a mixture of
both? Assumin dat we on a cold-ass lil computa where \s-1ASCII \s0(or some similar)
encodin is used: hexadecimal joints up in tha range \f(CW0x40\fR \- \f(CW0x5A\fR
indicate a uppercase letter, n' \f(CW0x20\fR encodes a space. Right back up in yo muthafuckin ass. So we might
assume it aint nuthin but a piece of text, which some is able ta read like a tabloid;
but others will gotta git hold of a \s-1ASCII\s0 table n' relive that
firstgrader feeling. Not carin too much bout which way ta read this,
we note dat \f(CW\*(C`unpack\*(C'\fR wit tha template code \f(CW\*(C`H\*(C'\fR converts tha contents
of a sequence of bytes tha fuck into tha customary hexadecimal notation. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Since
\&\*(L"a sequence of\*(R" be a pimpin' vague indication of quantity, \f(CW\*(C`H\*(C'\fR has been
defined ta convert just a single hexadecimal digit unless it is followed
by a repeat count fo' realz. An asterisk fo' tha repeat count means ta use whatever
remains.
.PP
Da inverse operation \- packin byte contents from a strang of hexadecimal
digits \- is just as easily written. I aint talkin' bout chicken n' gravy biatch. For instance:
.PP
.Vb 2
\&   mah $s = pack( \*(AqH2\*(Aq x 10, 30..39 );
\&   print "$s\en";
.Ve
.PP
Since we feed a list of ten 2\-digit hexadecimal strings ta \f(CW\*(C`pack\*(C'\fR, the
pack template should contain ten pack codes. If dis is run on a cold-ass lil computer
with \s-1ASCII\s0 characta coding, it will print \f(CW0123456789\fR.
.SH "Packin Text"
.IX Header "Packin Text"
Letz suppose you've gots ta read up in a thugged-out data file like this:
.PP
.Vb 4
\&    Date      |Description                | Income|Expenditure
\&    01/24/2001 Zed\*(Aqs Camel Emporium                    1147.99
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides ta tourists      235.00
.Ve
.PP
How tha fuck do our phat asses do it? Yo ass might be thinkin first ta use \f(CW\*(C`split\*(C'\fR; however, since
\&\f(CW\*(C`split\*(C'\fR collapses blank fields, you gonna never know whether a record was
income or expenditure. Oops. Well, you could always use \f(CW\*(C`substr\*(C'\fR:
.PP
.Vb 7
\&    while (<>) { 
\&        mah $date   = substr($_,  0, 11);
\&        mah $desc   = substr($_, 12, 27);
\&        mah $income = substr($_, 40,  7);
\&        mah $expend = substr($_, 52,  7);
\&        ...
\&    }
.Ve
.PP
It aint nuthin but not straight-up a funky-ass barrel of laughs, is it? In fact, itz worse than it
may seem; tha eagle-eyed may notice dat tha straight-up original gangsta field should only be
10 charactas wide, n' tha error has propagated right all up in tha other
numbers \- which we've had ta count by hand. Y'all KNOW dat shit, muthafucka! So itz error-prone as well
as horribly unfriendly.
.PP
Or maybe we could use regular expressions:
.PP
.Vb 5
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = 
\&            m|(\ed\ed/\ed\ed/\ed{4}) (.{27}) (.{7})(.*)|;
\&        ...
\&    }
.Ve
.PP
Urgh. Well, itz a lil' bit mo' betta yo, but \- well, would you wanna maintain
that?
.PP
Yo, aint Perl supposed ta make dis sort of thang easy as fuck ? Well, it do,
if you use tha right tools. \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR is designed ta help
you up when dealin wit fixed-width data like tha above. Letz have a
peep a solution wit \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 4
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7A*", $_);
\&        ...
\&    }
.Ve
.PP
That looks a lil' bit sickr; but we've gots ta take apart dat weird template.
Where did I pull dat up of?
.PP
\&\s-1OK,\s0 letz gotz a peep a shitload of our data again; up in fact, we'll include
the headers, n' a handy rula so we can keep track of where we are.
.PP
.Vb 5
\&             1         2         3         4         5        
\&    1234567890123456789012345678901234567890123456789012345678
\&    Date      |Description                | Income|Expenditure
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides ta tourists      235.00
.Ve
.PP
From this, we can peep dat tha date column stretches from column 1 to
column 10 \- ten charactas wide. Da \f(CW\*(C`pack\*(C'\fR\-ese fo' \*(L"character\*(R" is
\&\f(CW\*(C`A\*(C'\fR, n' ten of dem is \f(CW\*(C`A10\*(C'\fR. Right back up in yo muthafuckin ass. So if our laid-back asses just wanted ta extract the
dates, we could say this:
.PP
.Vb 1
\&    my($date) = unpack("A10", $_);
.Ve
.PP
\&\s-1OK,\s0 whatz next? Between tha date n' tha description be a funky-ass blank column;
we wanna skip over dis shit. Da \f(CW\*(C`x\*(C'\fR template means \*(L"skip forward\*(R", so we
want one of them. Next, our crazy asses have another batch of characters, from 12 to
38. Thatz 27 mo' characters, hence \f(CW\*(C`A27\*(C'\fR. (Don't make tha fencepost
error \- there be 27 charactas between 12 n' 38, not 26. Count 'em!)
.PP
Now we skip another characta n' pick up tha next 7 characters:
.PP
.Vb 1
\&    my($date,$description,$income) = unpack("A10xA27xA7", $_);
.Ve
.PP
Now comes tha smart-ass bit. Lines up in our ledger which is just income and
not expenditure might end at column 46 yo. Hence, our phat asses don't wanna tell our
\&\f(CW\*(C`unpack\*(C'\fR pattern dat we \fBneed\fR ta find another 12 characters; we'll
just say \*(L"if there be a anythang left, take it\*(R" fo' realz. As you might guess from
regular expressions, thatz what tha fuck tha \f(CW\*(C`*\*(C'\fR means: \*(L"use every last muthafuckin thang
remaining\*(R".
.IP "\(bu" 3
Be warned, though, dat unlike regular expressions, if tha \f(CW\*(C`unpack\*(C'\fR
template don't match tha incomin data, Perl will scream n' take a thugged-out dirt nap.
.PP
Hence, puttin all dat shiznit together:
.PP
.Vb 1
\&    my($date,$description,$income,$expend) = unpack("A10xA27xA7xA*", $_);
.Ve
.PP
Now, thatz our data parsed. Y'all KNOW dat shit, muthafucka! I suppose what tha fuck we might wanna do now is
total up our income n' expenditure, n' add another line ta tha end of
our ledger \- up in tha same format \- sayin how tha fuck much we've brought up in and
how much we've spent:
.PP
.Vb 5
\&    while (<>) {
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7xA*", $_);
\&        $tot_income += $income;
\&        $tot_expend += $expend;
\&    }
\&
\&    $tot_income = sprintf("%.2f", $tot_income); # Git dem tha fuck into 
\&    $tot_expend = sprintf("%.2f", $tot_expend); # "financial" format
\&
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&
\&    # OK, let\*(Aqs go:
\&
\&    print pack("A10xA27xA7xA*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
Oh, hmm. That didn't like work. Letz peep what tha fuck happened:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides ta tourists     1235.00
\&    03/23/2001Totals                     1235.001172.98
.Ve
.PP
\&\s-1OK,\s0 itz a start yo, but what tha fuck happened ta tha spaces? We put \f(CW\*(C`x\*(C'\fR, didn't
we? Shouldn't it skip forward? Letz peep what tha fuck \*(L"pack\*(R" up in perlfunc says:
.PP
.Vb 1
\&    x   A null byte.
.Ve
.PP
Urgh. No wonder n' shit. Therez a funky-ass big-ass difference between \*(L"a null byte\*(R",
characta zero, n' \*(L"a space\*(R", characta 32. Perlz put something
between tha date n' tha description \- but unfortunately, we can't see
it!
.PP
What we straight-up need ta do is expand tha width of tha fields. Da \f(CW\*(C`A\*(C'\fR
format padz any non-existent charactas wit spaces, so we can use the
additionizzle spaces ta line up our fields, like this:
.PP
.Vb 1
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
(Note dat you can put spaces up in tha template ta make it mo' readable,
but they don't translate ta spaces up in tha output.) Herez what tha fuck we got
this time:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides ta tourists     1235.00
\&    03/23/2001 Totals                      1235.00 1172.98
.Ve
.PP
Thatz a lil' bit mo' betta yo, but we still have dat last column which needz to
be moved further over n' shit. Therez a easy as fuck  way ta fix dis up:
unfortunately, we can't git \f(CW\*(C`pack\*(C'\fR ta right-justify our fieldz yo, but we
can git \f(CW\*(C`sprintf\*(C'\fR ta do it:
.PP
.Vb 4
\&    $tot_income = sprintf("%.2f", $tot_income); 
\&    $tot_expend = sprintf("%12.2f", $tot_expend);
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
This time we git tha right answer:
.PP
.Vb 3
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides ta tourists     1235.00
\&    03/23/2001 Totals                      1235.00      1172.98
.Ve
.PP
So thatz how tha fuck we consume n' produce fixed-width data. Letz recap what
we've peeped of \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR so far:
.IP "\(bu" 3
Use \f(CW\*(C`pack\*(C'\fR ta go from nuff muthafuckin piecez of data ta one fixed-width
version; use \f(CW\*(C`unpack\*(C'\fR ta turn a gangbangin' fixed-width-format strang tha fuck into several
piecez of data.
.IP "\(bu" 3
Da pack format \f(CW\*(C`A\*(C'\fR means \*(L"any character\*(R"; if you \f(CW\*(C`pack\*(C'\fRin and
you've run outta thangs ta pack, \f(CW\*(C`pack\*(C'\fR will fill tha rest up with
spaces.
.IP "\(bu" 3
\&\f(CW\*(C`x\*(C'\fR means \*(L"skip a funky-ass byte\*(R" when \f(CW\*(C`unpack\*(C'\fRing; when \f(CW\*(C`pack\*(C'\fRing, it means
\&\*(L"introduce a null byte\*(R" \- thatz probably not what tha fuck you mean if you is
dealin wit plain text.
.IP "\(bu" 3
Yo ass can follow tha formats wit numbers ta say how tha fuck nuff characters
should be affected by dat format: \f(CW\*(C`A12\*(C'\fR means \*(L"take 12 characters\*(R";
\&\f(CW\*(C`x6\*(C'\fR means \*(L"skip 6 bytes\*(R" or \*(L"characta 0, 6 times\*(R".
.IP "\(bu" 3
Instead of a number, you can use \f(CW\*(C`*\*(C'\fR ta mean \*(L"consume every last muthafuckin thang else
left\*(R".
.Sp
\&\fBWarning\fR: when packin multiple piecez of data, \f(CW\*(C`*\*(C'\fR only means
\&\*(L"consume all of tha current piece of data\*(R". Thatz ta say
.Sp
.Vb 1
\&    pack("A*A*", $one, $two)
.Ve
.Sp
packs all of \f(CW$one\fR tha fuck into tha straight-up original gangsta \f(CW\*(C`A*\*(C'\fR n' then all of \f(CW$two\fR into
the second. Y'all KNOW dat shit, muthafucka! This be a general principle: each format character
correspondz ta one piece of data ta be \f(CW\*(C`pack\*(C'\fRed.
.SH "Packin Numbers"
.IX Header "Packin Numbers"
So much fo' textual data. Letz git onto tha meaty shiznit dat \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR is dopest at: handlin binary formats fo' numbers. There is,
of course, not just one binary format  \- game would be too simple \- but
Perl will do all tha finicky labor fo' yo thugged-out ass.
.SS "Integers"
.IX Subsection "Integers"
Packin n' unpackin numbers implies conversion ta n' from some
\&\fIspecific\fR binary representation. I aint talkin' bout chicken n' gravy biatch. Leavin floatin point numbers
aside fo' tha moment, tha salient propertizzlez of any such representation
are:
.IP "\(bu" 4
the number of bytes used fo' storin tha integer,
.IP "\(bu" 4
whether tha contents is interpreted as a signed or unsigned number,
.IP "\(bu" 4
the byte ordering: whether tha straight-up original gangsta byte is tha least or most
significant byte (or: lil-endian or big-endian, respectively).
.PP
So, fo' instance, ta pack 20302 ta a signed 16 bit integer up in your
computerz representation you write
.PP
.Vb 1
\&   mah $ps = pack( \*(Aqs\*(Aq, 20302 );
.Ve
.PP
Again, tha result be a string, now containin 2 bytes. If you print 
this strang (which is, generally, not recommended) you might see
\&\f(CW\*(C`ON\*(C'\fR or \f(CW\*(C`NO\*(C'\fR (dependin on yo' systemz byte ordering) \- or something
entirely different if yo' computa don't use \s-1ASCII\s0 characta encoding.
Unpackin \f(CW$ps\fR wit tha same template returns tha original gangsta integer value:
.PP
.Vb 1
\&   my( $s ) = unpack( \*(Aqs\*(Aq, $ps );
.Ve
.PP
This is legit fo' all numeric template codes. But don't expect miracles:
if tha packed value exceedz tha allotted byte capacity, high order bits
are silently discarded, n' unpack certainly won't be able ta pull them
back outta some magic hat fo' realz. And, when you pack rockin a signed template
code like fuckin \f(CW\*(C`s\*(C'\fR, a excess value may result up in tha sign bit
gettin set, n' unpackin dis will smartly return a wack value.
.PP
16 bits won't git you too far wit integers yo, but there is \f(CW\*(C`l\*(C'\fR n' \f(CW\*(C`L\*(C'\fR
for signed n' unsigned 32\-bit integers fo' realz. And if dis aint enough and
your system supports 64 bit integers you can push tha limits much closer
to infinitizzle wit pack codes \f(CW\*(C`q\*(C'\fR n' \f(CW\*(C`Q\*(C'\fR fo' realz. A notable exception is provided
by pack codes \f(CW\*(C`i\*(C'\fR n' \f(CW\*(C`I\*(C'\fR fo' signed n' unsigned integerz of tha 
\&\*(L"local custom\*(R" variety: Such a integer will take up as nuff bytes as
a local C compila returns fo' \f(CW\*(C`sizeof(int)\*(C'\fR yo, but it'll use \fIat least\fR
32 bits.
.PP
Each of tha integer pack codes \f(CW\*(C`sSlLqQ\*(C'\fR thangs up in dis biatch up in a gangbangin' fixed number of bytes,
no matta where you execute yo' program. This may be useful fo' some 
applications yo, but it do not provide fo' a portable way ta pass data 
structures between Perl n' C programs (bound ta happen when you call 
\&\s-1XS\s0 extensions or tha Perl function \f(CW\*(C`syscall\*(C'\fR), or when you read or
write binary files. What you gonna need up in dis case is template codes that
depend on what tha fuck yo' local C compila compilez when you code \f(CW\*(C`short\*(C'\fR or
\&\f(CW\*(C`unsigned long\*(C'\fR, fo' instance. These codes n' they corresponding
byte lengths is shown up in tha table below.  Since tha C standard leaves
much leeway wit respect ta tha relatizzle sizez of these data types, actual
values may vary, n' thatz why tha joints is given as expressions in
C n' Perl. (If you'd like ta use joints from \f(CW%Config\fR up in yo' program
you gotta import it wit \f(CW\*(C`use Config\*(C'\fR.)
.PP
.Vb 5
\&   signed unsigned  byte length up in C   byte length up in Perl       
\&     s muthafucka!     S!      sizeof(short)      $Config{shortsize}
\&     i!     I!      sizeof(int)        $Config{intsize}
\&     l!     L!      sizeof(long)       $Config{longsize}
\&     q!     Q!      sizeof(long long)  $Config{longlongsize}
.Ve
.PP
Da \f(CW\*(C`i!\*(C'\fR n' \f(CW\*(C`I!\*(C'\fR codes aren't different from \f(CW\*(C`i\*(C'\fR n' \f(CW\*(C`I\*(C'\fR; they are
tolerated fo' completeness' sake.
.SS "Unpackin a Stack Frame"
.IX Subsection "Unpackin a Stack Frame"
Requestin a particular byte orderin may be necessary when you work with
binary data comin from some specific architecture whereas yo' program could
run on a straight-up different system fo' realz. As a example, assume you have 24 bytes
containin a stack frame as it happens on a Intel 8086:
.PP
.Vb 11
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\& TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&      |   CS    |        | AL | AH | AX            |   DI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | BL | BH | BX            |   BP    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | CL | CH | CX            |   DS    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | DL | DH | DX            |   ES    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
.Ve
.PP
First, we note dat dis time-honored 16\-bit \s-1CPU\s0 uses lil-endian order,
and thatz why tha low order byte is stored all up in tha lower address. To
unpack such a (unsigned) short we'll gotta use code \f(CW\*(C`v\*(C'\fR fo' realz. A repeat
count unpacks all 12 shorts:
.PP
.Vb 2
\&   my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
\&     unpack( \*(Aqv12\*(Aq, $frame );
.Ve
.PP
Alternatively, we could have used \f(CW\*(C`C\*(C'\fR ta unpack tha individually
accessible byte registas \s-1FL, FH, AL, AH,\s0 etc.:
.PP
.Vb 2
\&   my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
\&     unpack( \*(AqC10\*(Aq, substr( $frame, 4, 10 ) );
.Ve
.PP
It would be sick if we could do dis up in one fell tha fuck swoop: unpack a gangbangin' finger-lickin' dirty-ass short,
back up a lil, n' then unpack 2 bytes. Right back up in yo muthafuckin ass. Since Perl \fIis\fR sick, it
proffers tha template code \f(CW\*(C`X\*(C'\fR ta back up one byte. Puttin dis all
together, we may now write:
.PP
.Vb 5
\&   my( $ip, $cs,
\&       $flags,$fl,$fh,
\&       $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
\&       $si, $di, $bp, $ds, $es ) =
\&   unpack( \*(Aqv2\*(Aq . (\*(AqvXXCC\*(Aq x 5) . \*(Aqv5\*(Aq, $frame );
.Ve
.PP
(Da clumsy construction of tha template can be avoided \- just read on!)
.PP
We've taken some pains ta construct tha template so dat it matches
the contentz of our frame buffer n' shit. Otherwise we'd either git undefined joints,
or \f(CW\*(C`unpack\*(C'\fR could not unpack all. If \f(CW\*(C`pack\*(C'\fR runs outta items, it will
supply null strings (which is coerced tha fuck into zeroes whenever tha pack code
says so).
.SS "How tha fuck ta Eat a Egg on a Net"
.IX Subsection "How tha fuck ta Eat a Egg on a Net"
Da pack code fo' big-endian (high order byte all up in tha lowest address) is
\&\f(CW\*(C`n\*(C'\fR fo' 16 bit n' \f(CW\*(C`N\*(C'\fR fo' 32 bit integers. Yo ass use these codes
if you know dat yo' data be reppin a cold-ass lil compliant architecture yo, but,
surprisingly enough, you should also use these pack codes if you
exchange binary data, across tha network, wit some system dat you
know next ta not a god damn thang about. Da simple reason is dat this
order has been chosen as tha \fInetwork order\fR, n' all standard-fearing
programs ought ta follow dis convention. I aint talkin' bout chicken n' gravy biatch. (This is, of course, a stern
backin fo' one of tha Lilliputian partizzles n' may well influence the
political pimpment there.) So, if tha protocol expects you ta send
a message by bustin  tha length first, followed by just all kindsa muthafuckin bytes,
you could write:
.PP
.Vb 1
\&   mah $buf = pack( \*(AqN\*(Aq, length( $msg ) ) . $msg;
.Ve
.PP
or even:
.PP
.Vb 1
\&   mah $buf = pack( \*(AqNA*\*(Aq, length( $msg ), $msg );
.Ve
.PP
and pass \f(CW$buf\fR ta yo' bust routine. Right back up in yo muthafuckin ass. Some protocols demand dat the
count should include tha length of tha count itself: then just add 4
to tha data length. (But make shizzle ta read \*(L"Lengths n' Widths\*(R" before
you straight-up code this!)
.SS "Byte-order modifiers"
.IX Subsection "Byte-order modifiers"
In tha previous sections we've hustled how tha fuck ta use \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR and
\&\f(CW\*(C`V\*(C'\fR ta pack n' unpack integers wit big\- or lil-endian byte-order.
While dis is sick, itz still rather limited cuz it leaves up all
kindz of signed integers as well as 64\-bit integers. For example, if you
wanted ta unpack a sequence of signed big-endian 16\-bit integers up in a
platform-independent way, you would gotta write:
.PP
.Vb 1
\&   mah @data = unpack \*(Aqs*\*(Aq, pack \*(AqS*\*(Aq, unpack \*(Aqn*\*(Aq, $buf;
.Ve
.PP
This is skanky fo' realz. Az of Perl 5.9.2, there be a a much sickr way ta express your
desire fo' a cold-ass lil certain byte-order: tha \f(CW\*(C`>\*(C'\fR n' \f(CW\*(C`<\*(C'\fR modifiers.
\&\f(CW\*(C`>\*(C'\fR is tha big-endian modifier, while \f(CW\*(C`<\*(C'\fR is tha lil-endian
modifier n' shit. Usin them, we could rewrite tha above code as:
.PP
.Vb 1
\&   mah @data = unpack \*(Aqs>*\*(Aq, $buf;
.Ve
.PP
As you can see, tha \*(L"bangin' end\*(R" of tha arrow touches tha \f(CW\*(C`s\*(C'\fR, which be a
nice way ta remember dat \f(CW\*(C`>\*(C'\fR is tha big-endian modifier n' shit. Da same
obviously works fo' \f(CW\*(C`<\*(C'\fR, where tha \*(L"lil end\*(R" touches tha code.
.PP
Yo ass will probably find these modifiers even mo' useful if you have
to deal wit big\- or lil-endian C structures. Be shizzle ta read
\&\*(L"Packin n' Unpackin C Structures\*(R" fo' mo' on dis shit.
.SS "Floatin point Numbers"
.IX Subsection "Floatin point Numbers"
For packin floatin point numbers you have tha chizzle between the
pack codes \f(CW\*(C`f\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`F\*(C'\fR n' \f(CW\*(C`D\*(C'\fR. \f(CW\*(C`f\*(C'\fR n' \f(CW\*(C`d\*(C'\fR pack tha fuck into (or unpack
from) single-precision or double-precision representation as it is provided
by yo' system. If yo' systems supports it, \f(CW\*(C`D\*(C'\fR can be used ta pack and
unpack extended-precision floatin point joints (\f(CW\*(C`long double\*(C'\fR), which
can offer even mo' resolution than \f(CW\*(C`f\*(C'\fR or \f(CW\*(C`d\*(C'\fR. \f(CW\*(C`F\*(C'\fR packs a \f(CW\*(C`NV\*(C'\fR,
which is tha floatin point type used by Perl internally. (There
is no such thang as a network representation fo' reals, so if you want
to bust yo' real numbers across computa boundaries, you'd betta stick
to \s-1ASCII\s0 representation, unless you straight-up shizzle whatz on tha other
end of tha line. For tha even mo' adventuresome, you can use tha byte-order
modifiers from tha previous section also on floatin point codes.)
.SH "Horny-Ass Templates"
.IX Header "Horny-Ass Templates"
.SS "Bit Strings"
.IX Subsection "Bit Strings"
Bits is tha atoms up in tha memory ghetto. Right back up in yo muthafuckin ass. Y'all KNOW dat shit, muthafucka! Access ta individual bits may
have ta be used either as a last resort or cuz it is da most thugged-out
convenient way ta handle yo' data. Bit strang (un)packin converts
between strings containin a seriez of \f(CW0\fR n' \f(CW1\fR charactas and
a sequence of bytes each containin a crew of 8 bits, n' you can put dat on yo' toast. This be almost
as simple as it sounds, except dat there be two ways tha contents of
a byte may be freestyled as a lil' bit string. Letz gotz a peep a annotated
byte:
.PP
.Vb 5
\&     7 6 5 4 3 2 1 0
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | 1 0 0 0 1 1 0 0 |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB
.Ve
.PP
It aint nuthin but egg-eatin all over again: Some be thinkin dat as a lil' bit strang dis should
be freestyled \*(L"10001100\*(R" i.e. beginnin wit da most thugged-out dope bit, others
insist on \*(L"00110001\*(R". Well, Perl aint biased, so thatz why our crazy asses have two bit
strin codes:
.PP
.Vb 2
\&   $byte = pack( \*(AqB8\*(Aq, \*(Aq10001100\*(Aq ); # start wit MSB
\&   $byte = pack( \*(Aqb8\*(Aq, \*(Aq00110001\*(Aq ); # start wit LSB
.Ve
.PP
It aint possible ta pack or unpack bit fieldz \- just integral bytes.
\&\f(CW\*(C`pack\*(C'\fR always starts all up in tha next byte boundary n' \*(L"roundz up\*(R" ta the
next multiple of 8 by addin zero bits as required. Y'all KNOW dat shit, muthafucka! (If you do want bit
fields, there is \*(L"vec\*(R" up in perlfunc. Or you could implement bit field 
handlin all up in tha characta strang level, rockin split, substr, and
concatenation on unpacked bit strings.)
.PP
To illustrate unpackin fo' bit strings, we'll decompose a simple
status regista (a \*(L"\-\*(R" standz fo' a \*(L"reserved\*(R" bit):
.PP
.Vb 4
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | S Z \- A \- P \- C | \- \- \- \- O D I T |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB MSB           LSB
.Ve
.PP
Convertin these two bytes ta a strang can be done wit tha unpack 
template \f(CW\*(Aqb16\*(Aq\fR. To obtain tha individual bit joints from tha bit
strin we use \f(CW\*(C`split\*(C'\fR wit tha \*(L"empty\*(R" separator pattern which dissects
into individual characters. Bit joints from tha \*(L"reserved\*(R" positions are
simply assigned ta \f(CW\*(C`undef\*(C'\fR, a cold-ass lil convenient notation fo' \*(L"I couldn't give a fuckin shiznit where
this goes\*(R".
.PP
.Vb 3
\&   ($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
\&    $trace, $interrupt, $direction, $overflow) =
\&      split( //, unpack( \*(Aqb16\*(Aq, $status ) );
.Ve
.PP
We could have used a unpack template \f(CW\*(Aqb12\*(Aq\fR just as well, since the
last 4 bits can be ignored anyway.
.SS "Uuencoding"
.IX Subsection "Uuencoding"
Another odd-man-out up in tha template alphabet is \f(CW\*(C`u\*(C'\fR, which packs an
\&\*(L"uuencoded string\*(R". (\*(L"uu\*(R" is short fo' Unix-to-Unix.) Chances is that
you won't eva need dis encodin technique which was invented ta overcome
the shortcomingz of old-fashioned transmission mediums dat do not support
other than simple \s-1ASCII\s0 data. Da essential recipe is simple: Take three 
bytes, or 24 bits, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Split dem tha fuck into 4 six-packs, addin a space (0x20) ta 
each. Repeat until all of tha data is blended. Y'all KNOW dat shit, muthafucka! Fold crewz of 4 bytes tha fuck into 
lines no longer than 60 n' garnish dem up in front wit tha original gangsta byte count 
(incremented by 0x20) n' a \f(CW"\en"\fR all up in tha end yo, but it ain't no stoppin cause I be still poppin'. \- Da \f(CW\*(C`pack\*(C'\fR chef will
prepare dis fo' you, a la minute, when you select pack code \f(CW\*(C`u\*(C'\fR on tha menu:
.PP
.Vb 1
\&   mah $uubuf = pack( \*(Aqu\*(Aq, $bindat );
.Ve
.PP
A repeat count afta \f(CW\*(C`u\*(C'\fR sets tha number of bytes ta put tha fuck into an
uuencoded line, which is tha maximum of 45 by default yo, but could be
set ta some (smaller) integer multiple of three. \f(CW\*(C`unpack\*(C'\fR simply ignores
the repeat count.
.SS "Bustin Sums"
.IX Subsection "Bustin Sums"
An even stranger template code is \f(CW\*(C`%\*(C'\fR<\fInumber\fR>. First, cuz 
itz used as a prefix ta some other template code. Right back up in yo muthafuckin ass. Second, cuz it
cannot be used up in \f(CW\*(C`pack\*(C'\fR at all, n' third, up in \f(CW\*(C`unpack\*(C'\fR, don't return the
data as defined by tha template code it precedes. Instead it'll hit you wit an
integer of \fInumber\fR bits dat is computed from tha data value by 
fuckin wit sums. For numeric unpack codes, no big-ass feat be  bigged up :
.PP
.Vb 2
\&    mah $buf = pack( \*(Aqiii\*(Aq, 100, 20, 3 );
\&    print unpack( \*(Aq%32i3\*(Aq, $buf ), "\en";  # prints 123
.Ve
.PP
For strang joints, \f(CW\*(C`%\*(C'\fR returns tha sum of tha byte joints saving
you tha shiznit of a sum loop wit \f(CW\*(C`substr\*(C'\fR n' \f(CW\*(C`ord\*(C'\fR:
.PP
.Vb 1
\&    print unpack( \*(Aq%32A*\*(Aq, "\ex01\ex10" ), "\en";  # prints 17
.Ve
.PP
Although tha \f(CW\*(C`%\*(C'\fR code is documented as returnin a \*(L"checksum\*(R":
don't put yo' trust up in such joints muthafucka! Even when applied ta a lil' small-ass number
of bytes, they won't guarantee a noticeable Hammin distance.
.PP
In connection wit \f(CW\*(C`b\*(C'\fR or \f(CW\*(C`B\*(C'\fR, \f(CW\*(C`%\*(C'\fR simply addz bits, n' dis can be put
to phat use ta count set bits efficiently:
.PP
.Vb 1
\&    mah $bitcount = unpack( \*(Aq%32b*\*(Aq, $mask );
.Ve
.PP
And a even paritizzle bit can be determined like this:
.PP
.Vb 1
\&    mah $evenparitizzle = unpack( \*(Aq%1b*\*(Aq, $mask );
.Ve
.SS "Unicode"
.IX Subsection "Unicode"
Unicode be a cold-ass lil characta set dat can represent most charactas up in most of
the ghettoz languages, providin room fo' over one mazillion different
characters. Unicode 3.1 specifies 94,140 characters: Da Basic Latin
charactas is assigned ta tha numbers 0 \- 127. Da Latin\-1 Supplement with
charactas dat is used up in nuff muthafuckin European languages is up in tha next
range, up ta 255 fo' realz. Afta some mo' Latin extensions we find tha character
sets from languages rockin non-Roman alphabets, interspersed wit a
variety of symbol sets like fuckin currency symbols, Zapf Dingbats or Braille.
(Yo ass might wanna visit <http://www.unicode.org/> fo' a peep some of
them \- mah underground favourites is Telugu n' Kannada.)
.PP
Da Unicode characta sets associates charactas wit integers. Encoding
these numbers up in a equal number of bytes would mo' than double the
requirements fo' storin texts freestyled up in Latin alphabets.
Da \s-1UTF\-8\s0 encodin avoidz dis by storin da most thugged-out common (from a westsideern
point of view) charactas up in a single byte while encodin tha rarer
ones up in three or mo' bytes.
.PP
Perl uses \s-1UTF\-8,\s0 internally, fo' most Unicode strings.
.PP
So what tha fuck has dis gots ta do wit \f(CW\*(C`pack\*(C'\fR? Well, if you wanna compose a
Unicode strang (that is internally encoded as \s-1UTF\-8\s0), you can do so by
usin template code \f(CW\*(C`U\*(C'\fR fo' realz. As a example, letz produce tha Euro currency
symbol (code number 0x20AC):
.PP
.Vb 2
\&   $UTF8{Euro} = pack( \*(AqU\*(Aq, 0x20AC );
\&   # Equivalent to: $UTF8{Euro} = "\ex{20ac}";
.Ve
.PP
Inspectin \f(CW$UTF8{Euro}\fR shows dat it gotz nuff 3 bytes:
\&\*(L"\exe2\ex82\exac\*(R". But fuck dat shiznit yo, tha word on tha street is dat it gotz nuff only 1 character, number 0x20AC.
Da round trip can be completed wit \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 1
\&   $Unicode{Euro} = unpack( \*(AqU\*(Aq, $UTF8{Euro} );
.Ve
.PP
Unpackin rockin tha \f(CW\*(C`U\*(C'\fR template code also works on \s-1UTF\-8\s0 encoded byte
strings.
.PP
Usually you gonna wanna pack or unpack \s-1UTF\-8\s0 strings:
.PP
.Vb 3
\&   # pack n' unpack tha Hebrew alphabet
\&   mah $alefbet = pack( \*(AqU*\*(Aq, 0x05d0..0x05ea );
\&   mah @hebrew = unpack( \*(AqU*\*(Aq, $utf );
.Ve
.PP
Please note: up in tha general case, you betta off using
Encode::decode_utf8 ta decode a \s-1UTF\-8\s0 encoded byte strang ta a Perl
Unicode string, n' Encode::encode_utf8 ta encode a Perl Unicode string
to \s-1UTF\-8\s0 bytes. These functions provide meanz of handlin invalid byte
sequences n' generally gotz a gangbangin' playalier intercourse.
.SS "Another Portable Binary Encoding"
.IX Subsection "Another Portable Binary Encoding"
Da pack code \f(CW\*(C`w\*(C'\fR has been added ta support a portable binary data
encodin scheme dat goes way beyond simple integers. (Details can
be found at <http://Casbah.org/>, tha Scarab project.)  A \s-1BER \s0(Binary Encoded
Representation) compressed unsigned integer stores base 128
digits, most dope digit first, wit as few digits as possible.
Bit eight (the high bit) is set on each byte except tha last. There
is no size limit ta \s-1BER\s0 encodin yo, but Perl won't git all up in extremes.
.PP
.Vb 1
\&   mah $berbuf = pack( \*(Aqw*\*(Aq, 1, 128, 128+1, 128*128+127 );
.Ve
.PP
A hex dump of \f(CW$berbuf\fR, wit spaces banged all up in tha right places,
shows 01 8100 8101 81807F. Right back up in yo muthafuckin ass. Since tha last byte be always less than
128, \f(CW\*(C`unpack\*(C'\fR knows where ta stop.
.SH "Template Grouping"
.IX Header "Template Grouping"
Prior ta Perl 5.8, repetitionz of templates had ta be made by
\&\f(CW\*(C`x\*(C'\fR\-multiplication of template strings. Now there be a funky-ass betta way as
we may use tha pack codes \f(CW\*(C`(\*(C'\fR n' \f(CW\*(C`)\*(C'\fR combined wit a repeat count.
Da \f(CW\*(C`unpack\*(C'\fR template from tha Stack Frame example can simply
be freestyled like this:
.PP
.Vb 1
\&   unpack( \*(Aqv2 (vXXCC)5 v5\*(Aq, $frame )
.Ve
.PP
Letz explore dis feature a lil mo' n' mo' n' mo'. We bout ta begin wit tha equivalent of
.PP
.Vb 1
\&   join( \*(Aq\*(Aq, map( substr( $_, 0, 1 ), @str ) )
.Ve
.PP
which returns a strang consistin of tha straight-up original gangsta characta from each string.
Usin pack, we can write
.PP
.Vb 1
\&   pack( \*(Aq(A)\*(Aq.@str, @str )
.Ve
.PP
or, cuz a repeat count \f(CW\*(C`*\*(C'\fR means \*(L"repeat as often as required\*(R",
simply
.PP
.Vb 1
\&   pack( \*(Aq(A)*\*(Aq, @str )
.Ve
.PP
(Note dat tha template \f(CW\*(C`A*\*(C'\fR would only have packed \f(CW$str[0]\fR up in full
length.)
.PP
To pack dates stored as triplets ( day, month, year ) up in a array \f(CW@dates\fR
into a sequence of byte, byte, short integer we can write
.PP
.Vb 1
\&   $pd = pack( \*(Aq(CCS)*\*(Aq, map( @$_, @dates ) );
.Ve
.PP
To swap pairz of charactas up in a strang (with even length) one could use
several steez. First, letz use \f(CW\*(C`x\*(C'\fR n' \f(CW\*(C`X\*(C'\fR ta skip forward n' back:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(xAXXAx)*\*(Aq, $s ) );
.Ve
.PP
We can also use \f(CW\*(C`@\*(C'\fR ta jump ta a offset, wit 0 bein tha posizzle where
we was when tha last \f(CW\*(C`(\*(C'\fR was encountered:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(@1A @0A @2)*\*(Aq, $s ) );
.Ve
.PP
Finally, there be also a entirely different approach by unpackin big
endian shorts n' packin dem up in tha reverse byte order:
.PP
.Vb 1
\&   $s = pack( \*(Aq(v)*\*(Aq, unpack( \*(Aq(n)*\*(Aq, $s );
.Ve
.SH "Lengths n' Widths"
.IX Header "Lengths n' Widths"
.SS "Strin Lengths"
.IX Subsection "Strin Lengths"
In tha previous section we've peeped a network message dat was constructed
by prefixin tha binary message length ta tha actual message. You'll find
that packin a length followed by all kindsa muthafuckin bytez of data be a 
frequently used recipe since appendin a null byte won't work
if a null byte may be part of tha data yo. Here be a example where both
steez is used: afta two null terminated strings wit source and
destination address, a Short Message (to a mobile phone) is busted after
a length byte:
.PP
.Vb 1
\&   mah $msg = pack( \*(AqZ*Z*CA*\*(Aq, $src, $dst, length( $sm ), $sm );
.Ve
.PP
Unpackin dis message can be done wit tha same template:
.PP
.Vb 1
\&   ( $src, $dst, $len, $sm ) = unpack( \*(AqZ*Z*CA*\*(Aq, $msg );
.Ve
.PP
Therez a subtle trap lurkin up in tha offing: Addin another field after
the Short Message (in variable \f(CW$sm\fR) be all right when packin yo, but this
cannot be unpacked naively:
.PP
.Vb 2
\&   # pack a message
\&   mah $msg = pack( \*(AqZ*Z*CA*C\*(Aq, $src, $dst, length( $sm ), $sm, $prio );
\&
\&   # unpack fails \- $prio remains undefined!
\&   ( $src, $dst, $len, $sm, $prio ) = unpack( \*(AqZ*Z*CA*C\*(Aq, $msg );
.Ve
.PP
Da pack code \f(CW\*(C`A*\*(C'\fR gobblez up all remainin bytes, n' \f(CW$prio\fR remains
undefined hommie! Before our slick asses let disappointment dampen tha morale: Perlz got
the trump card ta make dis trick too, just a lil further up tha sleeve.
Watch this:
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length/string, byte
\&   mah $msg = pack( \*(AqZ* Z* C/A* C\*(Aq, $src, $dst, $sm, $prio );
\&
\&   # unpack
\&   ( $src, $dst, $sm, $prio ) = unpack( \*(AqZ* Z* C/A* C\*(Aq, $msg );
.Ve
.PP
Combinin two pack codes wit a slash (\f(CW\*(C`/\*(C'\fR) associates dem wit a single
value from tha argument list. In \f(CW\*(C`pack\*(C'\fR, tha length of tha argument is
taken n' packed accordin ta tha straight-up original gangsta code while tha argument itself
is added afta bein converted wit tha template code afta tha slash.
This saves our asses tha shiznit of insertin tha \f(CW\*(C`length\*(C'\fR call yo, but it is 
in \f(CW\*(C`unpack\*(C'\fR where we straight-up score: Da value of tha length byte marks the
end of tha strang ta be taken from tha buffer n' shit. Right back up in yo muthafuckin ass. Since dis combination
doesn't make sense except when tha second pack code aint \f(CW\*(C`a*\*(C'\fR, \f(CW\*(C`A*\*(C'\fR
or \f(CW\*(C`Z*\*(C'\fR, Perl won't let yo thugged-out ass.
.PP
Da pack code precedin \f(CW\*(C`/\*(C'\fR may be anythang thatz fit ta represent a
number: All tha numeric binary pack codes, n' even text codes such as
\&\f(CW\*(C`A4\*(C'\fR or \f(CW\*(C`Z*\*(C'\fR:
.PP
.Vb 4
\&   # pack/unpack a strang preceded by its length up in ASCII
\&   mah $buf = pack( \*(AqA4/A*\*(Aq, "Humpty\-Dumpty" );
\&   # unpack $buf: \*(Aq13  Humpty\-Dumpty\*(Aq
\&   mah $txt = unpack( \*(AqA4/A*\*(Aq, $buf );
.Ve
.PP
\&\f(CW\*(C`/\*(C'\fR aint implemented up in Perls before 5.6, so if yo' code is required to
work on olda Perls you gonna need ta \f(CW\*(C`unpack( \*(AqZ* Z* C\*(Aq)\*(C'\fR ta git tha length,
then use it ta cook up a freshly smoked up unpack string. For example
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length, string, byte (5.005 compatible)
\&   mah $msg = pack( \*(AqZ* Z* C A* C\*(Aq, $src, $dst, length $sm, $sm, $prio );
\&
\&   # unpack
\&   ( undef, undef, $len) = unpack( \*(AqZ* Z* C\*(Aq, $msg );
\&   ($src, $dst, $sm, $prio) = unpack ( "Z* Z* x A$len C", $msg );
.Ve
.PP
But dat second \f(CW\*(C`unpack\*(C'\fR is rushin ahead. Y'all KNOW dat shit, muthafucka! Well shiiiit, it aint rockin a simple literal
strin fo' tha template. Right back up in yo muthafuckin ass. So maybe we should introduce...
.SS "Dynamic Templates"
.IX Subsection "Dynamic Templates"
So far, we've peeped literals used as templates. If tha list of pack
items aint gots fixed length, a expression constructin the
template is required (whenever, fo' some reason, \f(CW\*(C`()*\*(C'\fR cannot be used).
Herez a example: To store named strang joints up in a way dat can be
conveniently parsed by a C program, we create a sequence of names and
null terminated \s-1ASCII\s0 strings, wit \f(CW\*(C`=\*(C'\fR between tha name n' tha value,
followed by a additionizzle delimitin null byte yo. Herez how:
.PP
.Vb 2
\&   mah $env = pack( \*(Aq(A*A*Z*)\*(Aq . keys( %Env ) . \*(AqC\*(Aq,
\&                   map( { ( $_, \*(Aq=\*(Aq, $Env{$_} ) } keys( %Env ) ), 0 );
.Ve
.PP
Letz examine tha cogz of dis byte mill, one by one. Therez tha \f(CW\*(C`map\*(C'\fR
call, bustin tha shit we intend ta shiznit tha fuck into tha \f(CW$env\fR buffer:
to each key (in \f(CW$_\fR) it addz tha \f(CW\*(C`=\*(C'\fR separator n' tha hash entry value.
Each triplet is packed wit tha template code sequence \f(CW\*(C`A*A*Z*\*(C'\fR that
is repeated accordin ta tha number of keys. (Yes, thatz what tha fuck tha \f(CW\*(C`keys\*(C'\fR
function returns up in scalar context.) To git tha straight-up last null byte,
we add a \f(CW0\fR all up in tha end of tha \f(CW\*(C`pack\*(C'\fR list, ta be packed wit \f(CW\*(C`C\*(C'\fR.
(Attentizzle readaz may have noticed dat we could have omitted tha 0.)
.PP
For tha reverse operation, we'll gotta determine tha number of items
in tha buffer before we can let \f(CW\*(C`unpack\*(C'\fR rip it apart:
.PP
.Vb 2
\&   mah $n = $env =~ tr/\e0// \- 1;
\&   mah %env = map( split( /=/, $_ ), unpack( "(Z*)$n", $env ) );
.Ve
.PP
Da \f(CW\*(C`tr\*(C'\fR counts tha null bytes. Da \f(CW\*(C`unpack\*(C'\fR call returns a list of
name-value pairs each of which is taken apart up in tha \f(CW\*(C`map\*(C'\fR block.
.SS "Countin Repetitions"
.IX Subsection "Countin Repetitions"
Rather than storin a sentinel all up in tha end of a thugged-out data item (or a list of items),
we could precede tha data wit a cold-ass lil count fo' realz. Again, we pack keys n' joints of
a hash, precedin each wit a unsigned short length count, n' up front
we store tha number of pairs:
.PP
.Vb 1
\&   mah $env = pack( \*(AqS(S/A* S/A*)*\*(Aq, scalar keys( %Env ), %Env );
.Ve
.PP
This simplifies tha reverse operation as tha number of repetitions can be
unpacked wit tha \f(CW\*(C`/\*(C'\fR code:
.PP
.Vb 1
\&   mah %env = unpack( \*(AqS/(S/A* S/A*)\*(Aq, $env );
.Ve
.PP
Note dat dis is one of tha rare cases where you cannot use tha same
template fo' \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR cuz \f(CW\*(C`pack\*(C'\fR can't determine
a repeat count fo' a \f(CW\*(C`()\*(C'\fR\-group.
.SS "Intel \s-1HEX\s0"
.IX Subsection "Intel HEX"
Intel \s-1HEX\s0 be a gangbangin' file format fo' representin binary data, mostly for
programmin various chips, as a text file. (See
<http://en.wikipedia.org/wiki/.hex> fo' a thugged-out detailed description, and
<http://en.wikipedia.org/wiki/SREC_(file_format)> fo' tha Motorola
S\-record format, which can be unravelled rockin tha same technique.)
Each line begins wit a cold-ass lil colon (':') n' is followed by a sequence of
hexadecimal characters, specifyin a funky-ass byte count \fIn\fR (8 bit),
an address (16 bit, big-ass endian), a record type (8 bit), \fIn\fR data bytes
and a cold-ass lil checksum (8 bit) computed as tha least dope byte of tha two's
complement sum of tha precedin bytes. Example: \f(CW\*(C`:0300300002337A1E\*(C'\fR.
.PP
Da first step of processin such a line is tha conversion, ta binary,
of tha hexadecimal data, ta obtain tha four fields, while checkin the
checksum. No surprise here: we'll start wit a simple \f(CW\*(C`pack\*(C'\fR call ta 
convert every last muthafuckin thang ta binary:
.PP
.Vb 1
\&   mah $binrec = pack( \*(AqH*\*(Aq, substr( $hexrec, 1 ) );
.Ve
.PP
Da resultin byte sequence is most convenient fo' checkin tha checksum.
Don't slow yo' program down wit a gangbangin' fo' loop addin tha \f(CW\*(C`ord\*(C'\fR joints
of dis stringz bytes \- tha \f(CW\*(C`unpack\*(C'\fR code \f(CW\*(C`%\*(C'\fR is tha thang ta use
for computin tha 8\-bit sum of all bytes, which must be equal ta zero:
.PP
.Vb 1
\&   take a thugged-out dirtnap unless unpack( "%8C*", $binrec ) == 0;
.Ve
.PP
Finally, letz git dem four fields. By now, you shouldn't have any
problems wit tha straight-up original gangsta three fieldz \- but how tha fuck can we use tha byte count
of tha data up in tha straight-up original gangsta field as a length fo' tha data field? Here
the codes \f(CW\*(C`x\*(C'\fR n' \f(CW\*(C`X\*(C'\fR come ta tha rescue, as they permit jumping
back n' forth up in tha strang ta unpack.
.PP
.Vb 1
\&   my( $addr, $type, $data ) = unpack( "x n C X4 C x3 /a", $bin );
.Ve
.PP
Code \f(CW\*(C`x\*(C'\fR skips a funky-ass byte, since our phat asses don't need tha count yet. Code \f(CW\*(C`n\*(C'\fR takes
care of tha 16\-bit big-endian integer address, n' \f(CW\*(C`C\*(C'\fR unpacks the
record type. Bein at offset 4, where tha data begins, we need tha count.
\&\f(CW\*(C`X4\*(C'\fR brangs our asses back ta square one, which is tha byte at offset 0.
Now we pick up tha count, n' zoom forth ta offset 4, where we are
now straight-up furnished ta extract tha exact number of data bytes, leaving
the trailin checksum byte ridin' solo.
.SH "Packin n' Unpackin C Structures"
.IX Header "Packin n' Unpackin C Structures"
In previous sections our crazy asses have peeped how tha fuck ta pack numbers n' character
strings. If it was not fo' a cold-ass lil couple snags we could conclude this
section right away wit tha terse remark dat C structures don't
contain anythang else, n' therefore you already know all there is ta dat shit.
Sorry, no: read on, please.
.PP
If you gotta deal wit a shitload of C structures, n' don't want to
hack all yo' template strings manually, you gonna probably wanna have
a peep tha \s-1CPAN\s0 module \f(CW\*(C`Convert::Binary::C\*(C'\fR. Not only can it parse
your C source directly yo, but it also has built-in support fo' all the
oddz n' endz busted lyrics bout further on up in dis section.
.SS "Da Alignment Pit"
.IX Subsection "Da Alignment Pit"
In tha consideration of speed against memory requirements tha balance
has been tilted up in favor of fasta execution. I aint talkin' bout chicken n' gravy biatch. This has hyped up the
way C compilaz allocate memory fo' structures: On architectures
where a 16\-bit or 32\-bit operand can be moved fasta between places in
memory, or ta or from a \s-1CPU\s0 register, if it be aligned at a even or 
multiple-of-four or even at a multiple-of eight address, a C compiler
will hit you wit dis speed benefit by stuffin extra bytes tha fuck into structures.
If you don't cross tha C shoreline dis aint likely ta cause you any
grief (although you should care when you design big-ass data structures,
or you want yo' code ta be portable between architectures (you do want
that, don't yo slick ass?)).
.PP
To peep how tha fuck dis affects \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR, we'll compare these two
C structures:
.PP
.Vb 6
\&   typedef struct {
\&     char     c1;
\&     short    s;
\&     char     c2;
\&     long     l;
\&   } gappy_t;
\&
\&   typedef struct {
\&     long     l;
\&     short    s;
\&     char     c1;
\&     char     c2;
\&   } dense_t;
.Ve
.PP
Typically, a C compila allocates 12 bytes ta a \f(CW\*(C`gappy_t\*(C'\fR variable yo, but
requires only 8 bytes fo' a \f(CW\*(C`dense_t\*(C'\fR fo' realz. Afta investigatin dis further,
we can draw memory maps, showin where tha extra 4 bytes is hidden:
.PP
.Vb 5
\&   0           +4          +8          +12
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   gappy_t
\&
\&   0           +4          +8
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |     l     |  h  |c1|c2|
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   dense_t
.Ve
.PP
And thatz where tha straight-up original gangsta quirk strikes: \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR
templates gotta be stuffed wit \f(CW\*(C`x\*(C'\fR codes ta git dem extra fill bytes.
.PP
Da natural question: \*(L"Why can't Perl compensate fo' tha gaps?\*(R" warrants
an answer n' shit. One phat reason is dat C compilaz might provide (non-ANSI)
extensions permittin all sortz of fancy control over tha way structures
are aligned, even all up in tha level of a individual structure field. Y'all KNOW dat shit, muthafucka! And, if
this was not enough, there be a insidious thang called \f(CW\*(C`union\*(C'\fR where
the amount of fill bytes cannot be derived from tha alignment of tha next
item ridin' solo.
.PP
\&\s-1OK,\s0 so letz bite tha cap yo. Herez one way ta git tha alignment right
by insertin template codes \f(CW\*(C`x\*(C'\fR, which don't take a cold-ass lil correspondin item 
from tha list:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aqcxs cxxx l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Note tha \f(CW\*(C`!\*(C'\fR afta \f(CW\*(C`l\*(C'\fR: Us thugs wanna make shizzle dat we pack a long
integer as it is compiled by our C compila n' shiznit fo' realz. And even now, it will only
work fo' tha platforms where tha compila aligns thangs as above.
And some muthafucka somewhere has a platform where it don't.
[Probably a Cray, where \f(CW\*(C`short\*(C'\fRs, \f(CW\*(C`int\*(C'\fRs n' \f(CW\*(C`long\*(C'\fRs is all 8 bytes. :\-)]
.PP
Countin bytes n' watchin alignments up in lengthy structures is bound ta 
be a thugged-out drag. Isn't there a way we can create tha template wit a simple
program? Herez a C program dat do tha trick:
.PP
.Vb 2
\&   #include <stdio.h>
\&   #include <stddef.h>
\&
\&   typedef struct {
\&     char     fc1;
\&     short    fs;
\&     char     fc2;
\&     long     fl;
\&   } gappy_t;
\&
\&   #define Pt(struct,field,tchar) \e
\&     printf( "@%d%s ", offsetof(struct,field), # tchar );
\&
\&   int main() {
\&     Pt( gappy_t, fc1, c  );
\&     Pt( gappy_t, fs,  s muthafucka! );
\&     Pt( gappy_t, fc2, c  );
\&     Pt( gappy_t, fl,  l! );
\&     printf( "\en" );
\&   }
.Ve
.PP
Da output line can be used as a template up in a \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR call:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aq@0c @2s muthafucka! @4c @8l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Gee, yet another template code \- as if our crazy asses hadn't plenty. But 
\&\f(CW\*(C`@\*(C'\fR saves our dizzle by enablin our asses ta specify tha offset from tha beginning
of tha pack buffer ta tha next item: This is just tha value
the \f(CW\*(C`offsetof\*(C'\fR macro (defined up in \f(CW\*(C`<stddef.h>\*(C'\fR) returns when
given a \f(CW\*(C`struct\*(C'\fR type n' one of its field names (\*(L"member-designator\*(R" up in 
C standardese).
.PP
Neither rockin offsets nor addin \f(CW\*(C`x\*(C'\fRz ta bridge tha gaps is satisfactory.
(Just imagine what tha fuck happens if tha structure chizzles.) What we straight-up need
is a way of sayin \*(L"skip as nuff bytes as required ta tha next multiple of N\*(R".
In fluent Templatese, you say dis wit \f(CW\*(C`x!N\*(C'\fR where N is replaced by the
appropriate value yo. Herez tha next version of our struct packaging:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aqc x!2 s c x!4 l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Thatz certainly mo' betta yo, but we still gotta know how tha fuck long all the
integers are, n' portabilitizzle is far away. Rather than \f(CW2\fR,
for instance, we wanna say \*(L"however long a gangbangin' finger-lickin' dirty-ass short is\*(R". But dis can be
done by enclosin tha appropriate pack code up in brackets: \f(CW\*(C`[s]\*(C'\fR. Right back up in yo muthafuckin ass. So, here's
the straight-up dopest we can do:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aqc x![s] s c x![l!] l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.SS "Dealin wit Endian-ness"
.IX Subsection "Dealin wit Endian-ness"
Now, imagine dat we wanna pack tha data fo' a machine wit a
different byte-order n' shit. First, we'll gotta figure up how tha fuck big-ass tha data
types on tha target machine straight-up are. Letz assume dat tha longs are
32 bits wide n' tha shorts is 16 bits wide. Yo ass can then rewrite the
template as:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aqc x![s] s c x![l] l\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
If tha target machine is lil-endian, we could write:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aqc x![s] s< c x![l] l<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This forces tha short n' tha long thugz ta be lil-endian, n' is
just fine if you aint gots too nuff struct members. But we could also
use tha byte-order modifier on a crew n' write tha following:
.PP
.Vb 1
\&  mah $gappy = pack( \*(Aq( c x![s] s c x![l] l )<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This aint as short as before yo, but it make it mo' obvious dat we
intend ta have lil-endian byte-order fo' a whole group, not only
for individual template codes. Well shiiiit, it can also be mo' readable n' easier
to maintain.
.SS "Alignment, Take 2"
.IX Subsection "Alignment, Take 2"
I be afraid dat our asses aint like all up in wit tha alignment catch yet. The
hydra raises another skanky head when you pack arrayz of structures:
.PP
.Vb 4
\&   typedef struct {
\&     short    count;
\&     char     glyph;
\&   } cell_t;
\&
\&   typedef cell_t buffer_t[BUFLEN];
.Ve
.PP
Wherez tha catch? Paddin is neither required before tha straight-up original gangsta field \f(CW\*(C`count\*(C'\fR,
nor between dis n' tha next field \f(CW\*(C`glyph\*(C'\fR, so why can't we simply pack
like this:
.PP
.Vb 3
\&   # suttin' goes wack here:
\&   pack( \*(Aqs!a\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.PP
This packs \f(CW\*(C`3*@buffer\*(C'\fR bytes yo, but it turns up dat tha size of 
\&\f(CW\*(C`buffer_t\*(C'\fR is four times \f(CW\*(C`BUFLEN\*(C'\fR! Da moral of tha rap is that
the required alignment of a structure or array is propagated ta the
next higher level where we gotta consider paddin \fIat tha end\fR
of each component as well. Thus tha erect template is:
.PP
.Vb 2
\&   pack( \*(Aqs!ax\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.SS "Alignment, Take 3"
.IX Subsection "Alignment, Take 3"
And even if you take all tha above tha fuck into account, \s-1ANSI\s0 still lets this:
.PP
.Vb 3
\&   typedef struct {
\&     char     foo[2];
\&   } foo_t;
.Ve
.PP
vary up in size. Da alignment constraint of tha structure can be pimped outa than
any of its elements, n' you can put dat on yo' toast. [And if you be thinkin dat dis don't affect anything
common, dismember tha next cellphone dat you see. Many have \s-1ARM\s0 cores, and
the \s-1ARM\s0 structure rulez make \f(CW\*(C`sizeof (foo_t)\*(C'\fR == 4]
.SS "Pointas fo' How tha fuck ta Use Them"
.IX Subsection "Pointas fo' How tha fuck ta Use Them"
Da title of dis section indicates tha second problem you may run into
sooner or lata when you pack C structures. If tha function you intend
to call expects a, say, \f(CW\*(C`void *\*(C'\fR value, you \fIcannot\fR simply take
a reference ta a Perl variable. (Although dat value certainly be a
memory address, it aint tha address where tha variablez contents are
stored.)
.PP
Template code \f(CW\*(C`P\*(C'\fR promises ta pack a \*(L"pointa ta a gangbangin' fixed length string\*(R".
Isn't dis what tha fuck we want? Letz try:
.PP
.Vb 3
\&    # allocate some storage n' pack a pointa ta it
\&    mah $memory = "\ex00" x $size;
\&    mah $memptr = pack( \*(AqP\*(Aq, $memory );
.Ve
.PP
But wait: don't \f(CW\*(C`pack\*(C'\fR just return a sequence of bytes? How tha fuck can we pass this
strin of bytes ta some C code expectin a pointa which is, afta all,
nothang but a number? Da answer is simple: We gotta obtain tha numeric
address from tha bytes returned by \f(CW\*(C`pack\*(C'\fR.
.PP
.Vb 1
\&    mah $ptr = unpack( \*(AqL!\*(Aq, $memptr );
.Ve
.PP
Obviously dis assumes dat it is possible ta typecast a pointer
to a unsigned long n' vice versa, which frequently works but should not
be taken as a universal law. \- Now dat our crazy asses have dis pointa tha next question
is: How tha fuck can we put it ta phat use? We need a cold-ass lil call ta some C function
where a pointa is expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da \fIread\fR\|(2) system call comes ta mind:
.PP
.Vb 1
\&    ssize_t read(int fd, void *buf, size_t count);
.Ve
.PP
Afta readin perlfunc explainin how tha fuck ta use \f(CW\*(C`syscall\*(C'\fR we can write
this Perl function copyin a gangbangin' file ta standard output:
.PP
.Vb 12
\&    require \*(Aqsyscall.ph\*(Aq;
\&    sub cat($){
\&        mah $path = shift();
\&        mah $size = \-s $path;
\&        mah $memory = "\ex00" x $size;  # allocate some memory
\&        mah $ptr = unpack( \*(AqL\*(Aq, pack( \*(AqP\*(Aq, $memory ) );
\&        open( F, $path ) || die( "$path: cannot open ($!)\en" );
\&        mah $fd = fileno(F);
\&        mah $res = syscall( &SYS_read, fileno(F), $ptr, $size );
\&        print $memory;
\&        close( F );
\&    }
.Ve
.PP
This is neither a specimen of simplicitizzle nor a paragon of portabilitizzle but
it illustrates tha point: We is able ta sneak behind tha scenes and
access Perlz otherwise well-guarded memory dawwwwg! (Important note: Perl's
\&\f(CW\*(C`syscall\*(C'\fR do \fInot\fR require you ta construct pointas up in dis roundabout
way. Yo ass simply pass a strang variable, n' Perl forwardz tha address.)
.PP
How tha fuck do \f(CW\*(C`unpack\*(C'\fR wit \f(CW\*(C`P\*(C'\fR work? Imagine some pointa up in tha buffer
about ta be unpacked: If it aint tha null pointa (which will smartly
produce tha \f(CW\*(C`undef\*(C'\fR value) our crazy asses gotz a start address \- but then what?
Perl has no way of knowin how tha fuck long dis \*(L"fixed length string\*(R" is, so
itz up ta you ta specify tha actual size as a explicit length afta \f(CW\*(C`P\*(C'\fR.
.PP
.Vb 2
\&   mah $mem = "abcdefghijklmn";
\&   print unpack( \*(AqP5\*(Aq, pack( \*(AqP\*(Aq, $mem ) ); # prints "abcde"
.Ve
.PP
As a cold-ass lil consequence, \f(CW\*(C`pack\*(C'\fR ignores any number or \f(CW\*(C`*\*(C'\fR afta \f(CW\*(C`P\*(C'\fR.
.PP
Now dat our crazy asses have peeped \f(CW\*(C`P\*(C'\fR at work, we might as well give \f(CW\*(C`p\*(C'\fR a whirl.
Why do we need a second template code fo' packin pointas at all? Da 
answer lies behind tha simple fact dat a \f(CW\*(C`unpack\*(C'\fR wit \f(CW\*(C`p\*(C'\fR promises
a null-terminated strang startin all up in tha address taken from tha buffer,
and dat implies a length fo' tha data item ta be returned:
.PP
.Vb 2
\&   mah $buf = pack( \*(Aqp\*(Aq, "abc\ex00efhijklmn" );
\&   print unpack( \*(Aqp\*(Aq, $buf );    # prints "abc"
.Ve
.PP
Albeit dis be apt ta be confusing: As a cold-ass lil consequence of tha length being
implied by tha stringz length, a number afta pack code \f(CW\*(C`p\*(C'\fR be a repeat
count, not a length as afta \f(CW\*(C`P\*(C'\fR.
.PP
Usin \f(CW\*(C`pack(..., $x)\*(C'\fR wit \f(CW\*(C`P\*(C'\fR or \f(CW\*(C`p\*(C'\fR ta git tha address where \f(CW$x\fR is
actually stored must be used wit circumspection. I aint talkin' bout chicken n' gravy biatch. Perlz internal machinery
considaz tha relation between a variable n' dat address as its straight-up own 
private matta n' don't straight-up care dat our crazy asses have obtained a cold-ass lil copy. Therefore:
.IP "\(bu" 4
Do not use \f(CW\*(C`pack\*(C'\fR wit \f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR ta obtain tha address of variable
thatz bound ta go outta scope (and thereby freein its memory) before you
are done wit rockin tha memory at dat address.
.IP "\(bu" 4
Be straight-up careful wit Perl operations dat chizzle tha value of the
variable fo' realz. Appendin suttin' ta tha variable, fo' instance, might require
reallocation of its storage, leavin you wit a pointa tha fuck into no-manz land.
.IP "\(bu" 4
Don't be thinkin dat you can git tha address of a Perl variable
when it is stored as a integer or double number playa! \f(CW\*(C`pack(\*(AqP\*(Aq, $x)\*(C'\fR will
force tha variablez internal representation ta string, just as if you
had freestyled suttin' like \f(CW\*(C`$x .= \*(Aq\*(Aq\*(C'\fR.
.PP
It aint nuthin but safe, however, ta P\- or p\-pack a strang literal, cuz Perl simply
allocates a anonymous variable.
.SH "Pack Recipes"
.IX Header "Pack Recipes"
Here is a cold-ass lil collection of (possibly) useful canned recipes fo' \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 2
\&    # Convert IP address fo' socket functions
\&    pack( "C4", split /\e./, "123.4.5.6" ); 
\&
\&    # Count tha bits up in a cold-ass lil chunk of memory (e.g. a select vector)
\&    unpack( \*(Aq%32b*\*(Aq, $mask );
\&
\&    # Determine tha endiannizz of yo' system
\&    $is_lil_endian = unpack( \*(Aqc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&    $is_big_endian = unpack( \*(Aqxc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&
\&    # Determine tha number of bits up in a natizzle integer
\&    $bits = unpack( \*(Aq%32I!\*(Aq, ~0 );
\&
\&    # Prepare argument fo' tha nanosleep system call
\&    mah $timespec = pack( \*(AqL!L!\*(Aq, $secs, $nanosecs );
.Ve
.PP
For a simple memory dump we unpack some bytes tha fuck into just as 
many pairz of hex digits, n' use \f(CW\*(C`map\*(C'\fR ta handle tha traditional
spacin \- 16 bytes ta a line:
.PP
.Vb 4
\&    mah $i;
\&    print map( ++$i % 16 ? "$_ " : "$_\en",
\&               unpack( \*(AqH2\*(Aq x length( $mem ), $mem ) ),
\&          length( $mem ) % 16 ? "\en" : \*(Aq\*(Aq;
.Ve
.SH "Funnies Section"
.IX Header "Funnies Section"
.Vb 5
\&    # Pullin digits outta nowhere...
\&    print unpack( \*(AqC\*(Aq, pack( \*(Aqx\*(Aq ) ),
\&          unpack( \*(Aq%B*\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqH\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqA\*(Aq, unpack( \*(AqC\*(Aq, pack( \*(AqA\*(Aq ) ) ), "\en";
\&
\&    # One fo' tha road ;\-)
\&    mah $advice = pack( \*(Aqall u can up in a van\*(Aq );
.Ve
.SH "Authors"
.IX Header "Authors"
Semen Cozens n' Wolfgang Laun.
