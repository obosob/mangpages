.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREFTUT 1"
.TH PERLREFTUT 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreftut \- Markz straight-up short tutorial bout references
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One of da most thugged-out blingin freshly smoked up features up in Perl 5 was tha capabilitizzle to
manage fucked up data structures like multidimensionizzle arrays and
nested hashes.  To enable these, Perl 5 introduced a gangbangin' feature called
\&'references', n' rockin references is tha key ta managin fucked up,
structured data up in Perl.  Unfortunately, there be a a shitload of funky syntax
to learn, n' tha main manual page can be hard ta follow.  Da manual
is like complete, n' sometimes playas find dat a problem, cuz
it can be hard ta tell what tha fuck is blingin n' what tha fuck aint.
.PP
Fortunately, you only need ta know 10% of whatz up in tha main page ta get
90% of tha benefit.  This page will show you dat 10%.
.SH "Dum diddy-dum, here I come biaaatch! Who tha fuck Needz Complicated Data Structures?"
.IX Header "Dum diddy-dum, here I come biaaatch! Who tha fuck Needz Complicated Data Structures?"
One problem dat comes up all tha time is needin a hash whose joints are
lists, n' you can put dat on yo' toast.  Perl has hashes, of course yo, but tha joints gotta be scalars;
they can't be lists.
.PP
Why would you want a hash of lists?  Letz take a simple example: You
have a gangbangin' file of hood n' ghetto names, like this:
.PP
.Vb 6
\&        Chicago, USA
\&        Frankfurt, Germany
\&        Berlin, Germany
\&        Washington, USA
\&        Helsinki, Finland
\&        New York, USA
.Ve
.PP
and you wanna produce a output like this, wit each ghetto mentioned
once, n' then a alphabetical list of tha ghettos up in dat ghetto:
.PP
.Vb 3
\&        Finland: Helsinki.
\&        Germany: Berlin, Frankfurt.
\&        USA:  Chicago, New York, Washington.
.Ve
.PP
Da natural way ta do dis is ta git a hash whose keys is ghetto
names.  Associated wit each ghetto name key be a list of tha ghettos in
that ghetto.  Each time you read a line of input, split it tha fuck into a cold-ass lil ghetto
and a cold-ass lil hood, look up tha list of ghettos already known ta be up in that
country, n' append tha freshly smoked up hood ta tha list.  When you done reading
the input, iterate over tha hash as usual, sortin each list of ghettos
before you print it out.
.PP
If hash joints couldn't be lists, you lose.  You'd probably have to
combine all tha ghettos tha fuck into a single strang somehow, n' then when
time came ta write tha output, you'd gotta break tha strang tha fuck into a
list, sort tha list, n' turn it back tha fuck into a string.  This is messy
and error-prone.  And itz frustrating, cuz Perl already has
perfectly phat lists dat would solve tha problem if only you could
use em.
.SH "Da Solution"
.IX Header "Da Solution"
By tha time Perl 5 rolled around, we was already stuck wit this
design: Hash joints must be scalars.  Da solution ta dis is
references.
.PP
A reference be a scalar value dat \fIrefers to\fR a entire array or an
entire hash (or ta just bout anythang else).  Names is one kind of
reference dat you already familiar with.  Think of tha President
of tha United Hoods: a messy, inconvenient ounce ta tha bounce of blood n' bones.
But ta rap bout him, or ta represent his ass up in a cold-ass lil computa program, all
you need is tha easy as fuck , convenient scalar strang \*(L"Barack Obizzay\*(R".
.PP
References up in Perl is like names fo' arrays n' hashes.  They're
Perlz private, internal names, so you can be shizzle they're
unambiguous.  Unlike \*(L"Barack Obizzay\*(R", a reference only refers ta one
thing, n' you always know what tha fuck it refers to.  If you gotz a reference
to a array, you can recover tha entire array from dat shit.  If you have a
reference ta a hash, you can recover tha entire hash.  But the
reference is still a easy as fuck , compact scalar value.
.PP
Yo ass can't gotz a hash whose joints is arrays; hash joints can only be
scalars.  We stuck wit dis shit.  But a single reference can refer to
an entire array, n' references is scalars, so you can gotz a hash of
references ta arrays, n' it'll act a shitload like a hash of arrays, and
it'll be just as useful as a hash of arrays.
.PP
We bout ta come back ta dis hood-country problem later, afta we've seen
some syntax fo' managin references.
.SH "Syntax"
.IX Header "Syntax"
There is just two ways ta cook up a reference, n' just two ways ta use
it once you have dat shit.
.SS "Makin References"
.IX Subsection "Makin References"
\fI\f(BIMake Rule 1\fI\fR
.IX Subsection "Make Rule 1"
.PP
If you put a \f(CW\*(C`\e\*(C'\fR up in front of a variable, you git a
reference ta dat variable.
.PP
.Vb 3
\&    $aref = \e@array;         # $aref now holdz a reference ta @array
\&    $href = \e%hash;          # $href now holdz a reference ta %hash
\&    $sref = \e$scalar;        # $sref now holdz a reference ta $scalar
.Ve
.PP
Once tha reference is stored up in a variable like \f(CW$aref\fR or \f(CW$href\fR, you
can copy it or store it just tha same as any other scalar value:
.PP
.Vb 3
\&    $xy = $aref;             # $xy now holdz a reference ta @array
\&    $p[3] = $href;           # $p[3] now holdz a reference ta %hash
\&    $z = $p[3];              # $z now holdz a reference ta %hash
.Ve
.PP
These examplez show how tha fuck ta make references ta variablez wit names.
Sometimes you wanna cook up a array or a hash dat aint gots a
name.  This be analogous ta tha way you like ta be able ta use the
strin \f(CW"\en"\fR or tha number 80 without havin ta store it up in a named
variable first.
.PP
\&\fBMake Rule 2\fR
.PP
\&\f(CW\*(C`[ ITEMS ]\*(C'\fR cook up a new, anonymous array, n' returns a reference to
that array.  \f(CW\*(C`{ ITEMS }\*(C'\fR cook up a new, anonymous hash, n' returns a
reference ta dat hash.
.PP
.Vb 2
\&    $aref = [ 1, "foo", undef, 13 ];
\&    # $aref now holdz a reference ta a array
\&
\&    $href = { APR => 4, AUG => 8 };
\&    # $href now holdz a reference ta a hash
.Ve
.PP
Da references you git from rule 2 is tha same kind of
references dat you git from rule 1:
.PP
.Vb 2
\&        # This:
\&        $aref = [ 1, 2, 3 ];
\&
\&        # Do tha same as this:
\&        @array = (1, 2, 3);
\&        $aref = \e@array;
.Ve
.PP
Da first line be a abbreviation fo' tha followin two lines, except
that it don't create tha superfluous array variable \f(CW@array\fR.
.PP
If you write just \f(CW\*(C`[]\*(C'\fR, you git a new, empty anonymous array.
If you write just \f(CW\*(C`{}\*(C'\fR, you git a new, empty anonymous hash.
.SS "Usin References"
.IX Subsection "Usin References"
What can you do wit a reference once you have it?  It aint nuthin but a scalar
value, n' we've peeped dat you can store it as a scalar n' git it back
again just like any scalar. Shiiit, dis aint no joke.  There is just two mo' ways ta use it:
.PP
\fI\f(BIUse Rule 1\fI\fR
.IX Subsection "Use Rule 1"
.PP
Yo ass can always use a array reference, up in curly braces, up in place of
the name of a array.  For example, \f(CW\*(C`@{$aref}\*(C'\fR instead of \f(CW@array\fR.
.PP
Here is some examplez of that:
.PP
Arrays:
.PP
.Vb 4
\&        @a              @{$aref}                An array
\&        reverse @a      reverse @{$aref}        Reverse tha array
\&        $a[3]           ${$aref}[3]             An element of tha array
\&        $a[3] = 17;     ${$aref}[3] = 17        Assignin a element
.Ve
.PP
On each line is two expressions dat do tha same thang.  The
left-hand versions operate on tha array \f(CW@a\fR.  Da right-hand
versions operate on tha array dat is referred ta by \f(CW$aref\fR.  Once
they find tha array they operatin on, both versions do tha same
things ta tha arrays.
.PP
Usin a hash reference is \fIexactly\fR tha same:
.PP
.Vb 4
\&        %h              %{$href}              A hash
\&        keys %h         keys %{$href}         Git tha keys from tha hash
\&        $h{\*(Aqred\*(Aq}       ${$href}{\*(Aqred\*(Aq}       An element of tha hash
\&        $h{\*(Aqred\*(Aq} = 17  ${$href}{\*(Aqred\*(Aq} = 17  Assignin a element
.Ve
.PP
Whatever you wanna do wit a reference, \fBUse Rule 1\fR  drops some lyrics ta you how
to do dat shit.  Yo ass just write tha Perl code dat you would have written
for bustin tha same thang ta a regular array or hash, n' then replace
the array or hash name wit \f(CW\*(C`{$reference}\*(C'\fR.  \*(L"How tha fuck do I loop over an
array when all I have be a reference?\*(R"  Well, ta loop over a array, you
would write
.PP
.Vb 3
\&        fo' mah $element (@array) {
\&           ...
\&        }
.Ve
.PP
so replace tha array name, \f(CW@array\fR, wit tha reference:
.PP
.Vb 3
\&        fo' mah $element (@{$aref}) {
\&           ...
\&        }
.Ve
.PP
\&\*(L"How tha fuck do I print up tha contentz of a hash when all I have be a
reference?\*(R"  First write tha code fo' printin up a hash:
.PP
.Vb 3
\&        fo' mah $key (keys %hash) {
\&          print "$key => $hash{$key}\en";
\&        }
.Ve
.PP
And then replace tha hash name wit tha reference:
.PP
.Vb 3
\&        fo' mah $key (keys %{$href}) {
\&          print "$key => ${$href}{$key}\en";
\&        }
.Ve
.PP
\fI\f(BIUse Rule 2\fI\fR
.IX Subsection "Use Rule 2"
.PP
\&\fBUse Rule 1\fR be all you straight-up need, cuz it  drops some lyrics ta you how tha fuck ta do
straight-up every last muthafuckin thang you eva need ta do wit references.  But the
most common thang ta do wit a array or a hash is ta extract a single
element, n' tha \fBUse Rule 1\fR notation is cumbersome.  So there be an
abbreviation.
.PP
\&\f(CW\*(C`${$aref}[3]\*(C'\fR is too hard ta read, so you can write \f(CW\*(C`$aref\->[3]\*(C'\fR
instead.
.PP
\&\f(CW\*(C`${$href}{red}\*(C'\fR is too hard ta read, so you can write
\&\f(CW\*(C`$href\->{red}\*(C'\fR instead.
.PP
If \f(CW$aref\fR holdz a reference ta a array, then \f(CW\*(C`$aref\->[3]\*(C'\fR is
the fourth element of tha array.  Don't confuse dis wit \f(CW$aref[3]\fR,
which is tha fourth element of a straight-up different array, one
deceptively named \f(CW@aref\fR.  \f(CW$aref\fR n' \f(CW@aref\fR is unrelated the
same way dat \f(CW$item\fR n' \f(CW@item\fR are.
.PP
Similarly, \f(CW\*(C`$href\->{\*(Aqred\*(Aq}\*(C'\fR is part of tha hash referred ta by
the scalar variable \f(CW$href\fR, like even one wit no name.
\&\f(CW$href{\*(Aqred\*(Aq}\fR is part of tha deceptively named \f(CW%href\fR hash.  It's
easy ta forget ta leave up tha \f(CW\*(C`\->\*(C'\fR, n' if you do, you gonna get
bizarre thangs up in dis biatch when yo' program gets array n' hash elements up of
totally unexpected hashes n' arrays dat weren't tha ones you wanted
to use.
.SS "An Example"
.IX Subsection "An Example"
Letz peep a quick example of how tha fuck all dis is useful.
.PP
First, remember dat \f(CW\*(C`[1, 2, 3]\*(C'\fR make a anonymous array containing
\&\f(CW\*(C`(1, 2, 3)\*(C'\fR, n' gives you a reference ta dat array.
.PP
Now be thinkin about
.PP
.Vb 4
\&        @a = ( [1, 2, 3],
\&               [4, 5, 6],
\&               [7, 8, 9]
\&             );
.Ve
.PP
\&\f(CW@a\fR be a array wit three elements, n' each one be a reference to
another array.
.PP
\&\f(CW$a[1]\fR is one of these references.  It refers ta a array, tha array
containin \f(CW\*(C`(4, 5, 6)\*(C'\fR, n' cuz it aint nuthin but a reference ta a array,
\&\fBUse Rule 2\fR say dat we can write \f(CW$a[1]\->[2]\fR ta git the
third element from dat array.  \f(CW$a[1]\->[2]\fR is tha 6.
Similarly, \f(CW$a[0]\->[1]\fR is tha 2.  What our crazy asses have here is like a
two-dimensionizzle array; you can write \f(CW$a[ROW]\->[COLUMN]\fR ta get
or set tha element up in any row n' any column of tha array.
.PP
Da notation still looks a lil cumbersome, so there be a one more
abbreviation:
.SS "Arrow Rule"
.IX Subsection "Arrow Rule"
In between two \fBsubscripts\fR, tha arrow is optional.
.PP
Instead of \f(CW$a[1]\->[2]\fR, we can write \f(CW$a[1][2]\fR; it means the
same thang.  Instead of \f(CW\*(C`$a[0]\->[1] = 23\*(C'\fR, we can write
\&\f(CW\*(C`$a[0][1] = 23\*(C'\fR; it means tha same ol' dirty thang.
.PP
Now it straight-up be lookin like two-dimensionizzle arrays!
.PP
Yo ass can peep why tha arrows is blingin.  Without them, we would have
had ta write \f(CW\*(C`${$a[1]}[2]\*(C'\fR instead of \f(CW$a[1][2]\fR.  For
three-dimensionizzle arrays, they let our asses write \f(CW$x[2][3][5]\fR instead of
the unreadable \f(CW\*(C`${${$x[2]}[3]}[5]\*(C'\fR.
.SH "Solution"
.IX Header "Solution"
Herez tha answer ta tha problem I posed earlier, of reformattin a
file of hood n' ghetto names.
.PP
.Vb 1
\&    1   mah %table;
\&
\&    2   while (<>) {
\&    3    chomp;
\&    4     mah ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
\&
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     mah @citizzles = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
Da program has two pieces: Lines 2\-\-7 read tha input n' build a thugged-out data
structure, n' lines 8\-13 analyze tha data n' print up tha report.
We goin ta git a hash, \f(CW%table\fR, whose keys is ghetto names,
and whose joints is references ta arrayz of hood names.  Da data
structure is ghon be lookin like this:
.PP
.Vb 10
\&           %table
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        |Germany| *\-\-\-\->| Frankfurt | Berlin |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        |Finland| *\-\-\-\->| Helsinki |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        |  USA  | *\-\-\-\->| Chicago | Washington | New York |
\&        |       |   |   +\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+
\&        +\-\-\-\-\-\-\-+\-\-\-+
.Ve
.PP
We bout ta peep output first.  Supposin we already have dis structure,
how do we print it out?
.PP
.Vb 6
\&    8   foreach $country (sort keys %table) {
\&    9     print "$country: ";
\&   10     mah @citizzles = @{$table{$country}};
\&   11     print join \*(Aq, \*(Aq, sort @cities;
\&   12     print ".\en";
\&   13   }
.Ve
.PP
\&\f(CW%table\fR be an
ordinary hash, n' we git a list of keys from it, sort tha keys, and
loop over tha keys as usual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da only use of references is up in line 10.
\&\f(CW$table{$country}\fR looks up tha key \f(CW$country\fR up in tha hash
and gets tha value, which be a reference ta a array of ghettos up in dat ghetto.
\&\fBUse Rule 1\fR say that
we can recover tha array by saying
\&\f(CW\*(C`@{$table{$country}}\*(C'\fR.  Line 10 is just like
.PP
.Vb 1
\&        @citizzles = @array;
.Ve
.PP
except dat tha name \f(CW\*(C`array\*(C'\fR has been replaced by tha reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  Da \f(CW\*(C`@\*(C'\fR  drops some lyrics ta Perl ta git tha entire array.
Havin gotten tha list of ghettos, we sort it, join it, n' print it
out as usual.
.PP
Lines 2\-7 is responsible fo' buildin tha structure up in tha first
place.  Here they is again:
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     mah ($city, $country) = split /, /;
\&    5     $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
Lines 2\-4 acquire a cold-ass lil hood n' ghetto name.  Line 5 looks ta peep if the
country be already present as a key up in tha hash.  If itz not, the
program uses tha \f(CW\*(C`[]\*(C'\fR notation (\fBMake Rule 2\fR) ta manufacture a new,
empty anonymous array of ghettos, n' installs a reference ta it into
the hash under tha appropriate key.
.PP
Line 6 installs tha hood name tha fuck into tha appropriate array.
\&\f(CW$table{$country}\fR now holdz a reference ta tha array of ghettos seen
in dat ghetto so far. Shiiit, dis aint no joke.  Line 6 is exactly like
.PP
.Vb 1
\&        push @array, $city;
.Ve
.PP
except dat tha name \f(CW\*(C`array\*(C'\fR has been replaced by tha reference
\&\f(CW\*(C`{$table{$country}}\*(C'\fR.  Da \f(CW\*(C`push\*(C'\fR addz a cold-ass lil hood name ta tha end of the
referred-to array.
.PP
Therez one fine point I skipped. Y'all KNOW dat shit, muthafucka!  Line 5 is unnecessary, n' we can
get rid of dat shit.
.PP
.Vb 6
\&    2   while (<>) {
\&    3    chomp;
\&    4     mah ($city, $country) = split /, /;
\&    5   ####  $table{$country} = [] unless exists $table{$country};
\&    6     push @{$table{$country}}, $city;
\&    7   }
.Ve
.PP
If there be a already a entry up in \f(CW%table\fR fo' tha current \f(CW$country\fR,
then not a god damn thang is different.  Line 6 will locate tha value in
\&\f(CW$table{$country}\fR, which be a reference ta a array, n' push
\&\f(CW$city\fR tha fuck into tha array.  But
what do it do when
\&\f(CW$country\fR holdz a key, say \f(CW\*(C`Greece\*(C'\fR, dat aint yet up in \f(CW%table\fR?
.PP
This is Perl, so it do tha exact right thang.  It sees dat you want
to push \f(CW\*(C`Athens\*(C'\fR onto a array dat don't exist, so it helpfully
makes a new, empty, anonymous array fo' you, installs it into
\&\f(CW%table\fR, n' then pushes \f(CW\*(C`Athens\*(C'\fR onto dat shit.  This is called
\&'autovivification'\-\-bringin thangs ta game automatically.  Perl saw
that tha key wasn't up in tha hash, so it pimped a freshly smoked up hash entry
automatically. Perl saw dat you wanted ta use tha hash value as an
array, so it pimped a freshly smoked up empty array n' installed a reference ta it
in tha hash automatically.  And as usual, Perl made tha array one
element longer ta hold tha freshly smoked up hood name.
.SH "Da Rest"
.IX Header "Da Rest"
I promised ta hit you wit 90% of tha benefit wit 10% of tha details, and
that means I left up 90% of tha details.  Now dat you have an
overview of tha blingin parts, it should be easier ta read the
perlref manual page, which discusses 100% of tha details.
.PP
Some of tha highlightz of perlref:
.IP "\(bu" 4
Yo ass can make references ta anything, includin scalars, functions, and
other references.
.IP "\(bu" 4
In \fBUse Rule 1\fR, you can omit tha curly brackets whenever tha thang
inside dem be a atomic scalar variable like \f(CW$aref\fR.  For example,
\&\f(CW@$aref\fR is tha same ol' dirty as \f(CW\*(C`@{$aref}\*(C'\fR, n' \f(CW$$aref[1]\fR is tha same ol' dirty as
\&\f(CW\*(C`${$aref}[1]\*(C'\fR.  If you just startin out, you may wanna adopt
the g-thang of always includin tha curly brackets.
.IP "\(bu" 4
This don't copy tha underlyin array:
.Sp
.Vb 1
\&        $aref2 = $aref1;
.Ve
.Sp
Yo ass git two references ta tha same array.  If you modify
\&\f(CW\*(C`$aref1\->[23]\*(C'\fR n' then peep
\&\f(CW\*(C`$aref2\->[23]\*(C'\fR you gonna peep tha chizzle.
.Sp
To copy tha array, use
.Sp
.Vb 1
\&        $aref2 = [@{$aref1}];
.Ve
.Sp
This uses \f(CW\*(C`[...]\*(C'\fR notation ta create a freshly smoked up anonymous array, and
\&\f(CW$aref2\fR be assigned a reference ta tha freshly smoked up array.  Da freshly smoked up array is
initialized wit tha contentz of tha array referred ta by \f(CW$aref1\fR.
.Sp
Similarly, ta copy a anonymous hash, you can use
.Sp
.Vb 1
\&        $href2 = {%{$href1}};
.Ve
.IP "\(bu" 4
To peep if a variable gotz nuff a reference, use tha \f(CW\*(C`ref\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  It
returns legit if its argument be a reference.  Actually itz a lil
betta than that: It returns \f(CW\*(C`HASH\*(C'\fR fo' hash references n' \f(CW\*(C`ARRAY\*(C'\fR
for array references.
.IP "\(bu" 4
If you try ta bust a reference like a string, you git strings like
.Sp
.Vb 1
\&        ARRAY(0x80f5dec)   or    HASH(0x826afc0)
.Ve
.Sp
If you eva peep a strang dat be lookin like this, you gonna know you
printed up a reference by mistake.
.Sp
A side effect of dis representation is dat you can use \f(CW\*(C`eq\*(C'\fR ta see
if two references refer ta tha same thang.  (But you should probably use
\&\f(CW\*(C`==\*(C'\fR instead cuz itz much faster.)
.IP "\(bu" 4
Yo ass can bust a strang as if it was a reference.  If you use tha string
\&\f(CW"foo"\fR as a array reference, itz taken ta be a reference ta the
array \f(CW@foo\fR.  This is called a \fIsoft reference\fR or \fIsymbolic
reference\fR.  Da declaration \f(CW\*(C`use strict \*(Aqrefs\*(Aq\*(C'\fR disablez this
feature, which can cause all sortz of shiznit if you use it by accident.
.PP
Yo ass might prefer ta go on ta perllol instead of perlref; it
discusses listz of lists n' multidimensionizzle arrays up in detail.  After
that, you should move on ta perldsc; itz a Data Structure Cookbook
that shows recipes fo' rockin n' printin up arrayz of hashes, hashes
of arrays, n' other kindz of data.
.SH "Summary"
.IX Header "Summary"
Everyone needz compound data structures, n' up in Perl tha way you get
them is wit references.  There is four blingin rulez fo' managing
references: Two fo' makin references n' two fo' rockin em.  Once
you know these rulez you can do most of tha blingin thangs you need
to do wit references.
.SH "Credits"
.IX Header "Credits"
Author: Mark Jizzo Dominus, Plover Systems (\f(CW\*(C`mjd\-perl\-ref+@plover.com\*(C'\fR)
.PP
This article originally rocked up in \fIDa Perl Journal\fR
( http://www.tpj.com/ ) volume 3, #2.  Reprinted wit permission.
.PP
Da original gangsta title was \fIUnderstand References Today\fR.
.SS "Distribution Conditions"
.IX Subsection "Distribution Conditions"
Copyright 1998 Da Perl Journal.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in these filez are
hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch.  Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' funk or fo' profit
as you peep fit.  A simple comment up in tha code givin credit would be
courteous but aint required.
