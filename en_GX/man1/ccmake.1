.TH ccmake 1 "February 11, 2014" "ccmake 2.8.12.2"
.SH NAME
.PP
.nf
  ccmake \- Curses Interface fo' CMake.
.fi

.SH USAGE
.PP
.nf
  ccmake <path\-to\-source>
  ccmake <path\-to\-existing\-build>
.fi

.SH DESCRIPTION
.PP
Da "ccmake" executable is tha CMake curses intercourse.  Project configuration settings may be specified interactively all up in dis GUI.  Brief instructions is provided all up in tha bottom of tha terminal when tha program is hustlin.

.PP
CMake be a cold-ass lil cross\-platform build system generator. Shiiit, dis aint no joke.  Projects specify they build process wit platform\-independent CMake listfilez included up in each directory of a source tree wit tha name CMakeLists.txt. Users build a project by rockin CMake ta generate a funky-ass build system fo' a natizzle tool on they platform.

.SH OPTIONS
.TP
.B -C <initial-cache>
Pre\-load a script ta populate tha cache.

When cmake is first run up in a empty build tree, it creates a CMakeCache.txt file n' populates it wit customizable settings fo' tha project.  This option may be used ta specify a gangbangin' file from which ta load cache entries before tha straight-up original gangsta pass all up in tha projectz cmake listfiles.  Da loaded entries take prioritizzle over tha projectz default joints, n' you can put dat on yo' toast.  Da given file should be a CMake script containin SET commandz dat use tha CACHE option, not a cold-ass lil cache\-format file.

.TP
.B -D <var>:<type>=<value>
Smoke a cold-ass lil cmake cache entry.

When cmake is first run up in a empty build tree, it creates a CMakeCache.txt file n' populates it wit customizable settings fo' tha project.  This option may be used ta specify a settin dat takes prioritizzle over tha projectz default value.  Da option may be repeated fo' as nuff cache entries as desired.

.TP
.B -U <globbing_expr>
Remove matchin entries from CMake cache.

This option may be used ta remove one or mo' variablez from tha CMakeCache.txt file, globbin expressions rockin * n' ? is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da option may be repeated fo' as nuff cache entries as desired.


Use wit care, you can make yo' CMakeCache.txt non\-working.

.TP
.B -G <generator-name>
Specify a funky-ass build system generator.

CMake may support multiple natizzle build systems on certain platforms.  A generator is responsible fo' generatin a particular build system.  Possible generator names is specified up in tha Generators section.

.TP
.B -T <toolset-name>
Specify toolset name if supported by generator.

Some CMake generators support a toolset name ta be given ta tha natizzle build system ta chizzle a cold-ass lil compila n' shit.  This is supported only on specific generators:


.nf
  Visual Studio >= 10
  Xcode >= 3.0
.fi

See natizzle build system documentation fo' allowed toolset names.

.TP
.B -Wno-dev
Suppress pimper warnings.

Suppress warnings dat is meant fo' tha lyricist of tha CMakeLists.txt files.

.TP
.B -Wdev
Enable pimper warnings.

Enable warnings dat is meant fo' tha lyricist of tha CMakeLists.txt files.

.TP
.B --copyright [file]
Print tha CMake copyright n' exit.

If a gangbangin' file is specified, tha copyright is freestyled tha fuck into dat shit.

.TP
.B --help,-help,-usage,-h,-H,/?
Print usage shiznit n' exit.

Usage raps bout tha basic command line intercourse n' its options.

.TP
.B --help-full [file]
Print full help n' exit.

Full help displays most of tha documentation provided by tha UNIX playa page.  It be provided fo' use on non\-UNIX platforms yo, but be also convenient if tha playa page aint installed. Y'all KNOW dat shit, muthafucka!  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-html [file]
Print full help up in HTML format.

This option is used by CMake authors ta help produce wizzy pages.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-man [file]
Print full help as a UNIX playa page n' exit.

This option is used by tha cmake build ta generate tha UNIX playa page.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --version,-version,/V [file]
Show program name/version banner n' exit.

If a gangbangin' file is specified, tha version is freestyled tha fuck into dat shit.

.SH GENERATORS
.TP
.B Unix Makefiles
Generates standard UNIX makefiles.

A hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Ninja
Generates build.ninja filez (experimental).

A build.ninja file is generated tha fuck into tha build tree. Recent versionz of tha ninja program can build tha project all up in tha "all" target.  An "install" target be also provided.

.TP
.B CodeBlocks - Ninja
Generates CodeBlocks project files.

Project filez fo' CodeBlocks is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B CodeBlocks - Unix Makefiles
Generates CodeBlocks project files.

Project filez fo' CodeBlocks is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Eclipse CDT4 - Ninja
Generates Eclipse CDT 4.0 project files.

Project filez fo' Eclipse is ghon be pimped up in tha top directory. In outta source builds, a linked resource ta tha top level source directory is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree. Da appropriate make program can build tha project all up in tha default make target fo' realz. A "make install" target be also provided.

.TP
.B Eclipse CDT4 - Unix Makefiles
Generates Eclipse CDT 4.0 project files.

Project filez fo' Eclipse is ghon be pimped up in tha top directory. In outta source builds, a linked resource ta tha top level source directory is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. Additionally a hierarchy of makefilez is generated tha fuck into tha build tree. Da appropriate make program can build tha project all up in tha default make target fo' realz. A "make install" target be also provided.

.TP
.B KDevelop3
Generates KDevelop 3 project files.

Project filez fo' KDevelop 3 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call. If you chizzle tha settings rockin KDevelop cmake will try its dopest ta keep yo' chizzlez when regeneratin tha project filez fo' realz. Additionally a hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B KDevelop3 - Unix Makefiles
Generates KDevelop 3 project files.

Project filez fo' KDevelop 3 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call. If you chizzle tha settings rockin KDevelop cmake will try its dopest ta keep yo' chizzlez when regeneratin tha project filez fo' realz. Additionally a hierarchy of UNIX makefilez is generated tha fuck into tha build tree.  Any standard UNIX\-style make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Sublime Text 2 - Ninja
Generates Sublime Text 2 project files.

Project filez fo' Sublime Text 2 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally Makefilez (or build.ninja files) is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.TP
.B Sublime Text 2 - Unix Makefiles
Generates Sublime Text 2 project files.

Project filez fo' Sublime Text 2 is ghon be pimped up in tha top directory n' up in every last muthafuckin subdirectory which features a CMakeLists.txt file containin a PROJECT() call fo' realz. Additionally Makefilez (or build.ninja files) is generated tha fuck into tha build tree.  Da appropriate make program can build tha project all up in tha default make target.  A "make install" target be also provided.

.SH PROPERTIES
.PP
.nf
  CMake Propertizzles \- Propertizzles supported by CMake, tha Cross\-Platform Makefile Generator.
.fi

.PP
This is tha documentation fo' tha propertizzles supported by CMake. Propertizzles can have different scopes. They can either be assigned ta a source file, a gangbangin' finger-lickin' directory, a target or globally ta CMake. By modifyin tha jointz of propertizzles tha behaviour of tha build system can be customized.

.SH COMMAND
.TP
.B add_compile_options
Addz options ta tha compilation of source files.

.nf
  add_compile_options(<option> ...)
.fi

Addz options ta tha compila command line fo' sources up in tha current directory n' below.  This command can be used ta add any options yo, but alternatizzle commandz exist ta add preprocessor definitions or include directories. Put ya muthafuckin choppers up if ya feel dis!  See documentation of tha directory n' target COMPILE_OPTIONS propertizzles fo' details.  Arguments ta add_compile_options may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B add_custom_command
Add a cold-ass lil custom build rule ta tha generated build system.

There is two main signatures fo' add_custom_command Da first signature is fo' addin a cold-ass lil custom command ta produce a output.


.nf
  add_custom_command(OUTPUT output1 [output2 ...]
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [MAIN_DEPENDENCY depend]
                     [DEPENDS [depends...]]
                     [IMPLICIT_DEPENDS <lang1> depend1
                                      [<lang2> depend2] ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM] [APPEND])
.fi

This defines a cold-ass lil command ta generate specified OUTPUT file(s).  A target pimped up in tha same directory (CMakeLists.txt file) dat specifies any output of tha custom command as a source file is given a rule ta generate tha file rockin tha command at build time.  Do not list tha output up in mo' than one independent target dat may build up in parallel or tha two instancez of tha rule may conflict (instead use add_custom_target ta drive tha command n' make tha other targets depend on dat one).  If a output name be a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. Note dat MAIN_DEPENDENCY is straight-up optionizzle n' is used as a suggestion ta visual basement bout where ta hang tha custom command. Y'all KNOW dat shit, muthafucka! In makefile terms dis creates a freshly smoked up target up in tha followin form:


.nf
  OUTPUT: MAIN_DEPENDENCY DEPENDS
          COMMAND
.fi

If mo' than one command is specified they is ghon be executed up in order n' shit. Da optionizzle ARGS argument is fo' backward compatibilitizzle n' is ghon be ignored.


Da second signature addz a cold-ass lil custom command ta a target like fuckin a library or executable. This is useful fo' struttin a operation before or afta buildin tha target. Da command becomes part of tha target n' will only execute when tha target itself is built.  If tha target be already built, tha command aint gonna execute.


.nf
  add_custom_command(TARGET target
                     PRE_BUILD | PRE_LINK | POST_BUILD
                     COMMAND command1 [ARGS] [args1...]
                     [COMMAND command2 [ARGS] [args2...] ...]
                     [WORKING_DIRECTORY dir]
                     [COMMENT comment] [VERBATIM])
.fi

This defines a freshly smoked up command dat is ghon be associated wit buildin tha specified target. When tha command will happen is determined by which of tha followin is specified:


.nf
  PRE_BUILD \- run before all other dependencies
  PRE_LINK \- run afta other dependencies
  POST_BUILD \- run afta tha target has been built
.fi

Note dat tha PRE_BUILD option is only supported on Visual Studio 7 or later n' shit. For all other generators PRE_BUILD is ghon be treated as PRE_LINK.


If WORKING_DIRECTORY is specified tha command is ghon be executed up in tha directory given. I aint talkin' bout chicken n' gravy biatch. If it aint nuthin but a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. If COMMENT is set, tha value is ghon be displayed as a message before tha commandz is executed at build time. If APPEND is specified tha COMMAND n' DEPENDS option joints is appended ta tha custom command fo' tha straight-up original gangsta output specified. Y'all KNOW dat shit, muthafucka! There must have already been a previous call ta dis command wit tha same output. Da COMMENT, WORKING_DIRECTORY, n' MAIN_DEPENDENCY options is currently ignored when APPEND is given yo, but may be used up in tha future.


If VERBATIM is given then all arguments ta tha commandz is ghon be escaped properly fo' tha build tool so dat tha invoked command receives each argument unchanged. Y'all KNOW dat shit, muthafucka!  Note dat one level of escapes is still used by tha CMake language processor before add_custom_command even sees tha arguments, n' you can put dat on yo' toast. Use of VERBATIM is recommended as it enablez erect behavior. Shiiit, dis aint no joke. When VERBATIM aint given tha behavior is platform specific cuz there is no protection of tool\-specific special characters.


If tha output of tha custom command aint straight-up pimped as a gangbangin' file on disk it should be marked as SYMBOLIC wit SET_SOURCE_FILES_PROPERTIES.


Da IMPLICIT_DEPENDS option requests scannin of implicit dependenciez of a input file.  Da language given specifies tha programmin language whose correspondin dependency scanner should be used. Y'all KNOW dat shit, muthafucka!  Currently only C n' CXX language scanners is supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da language has ta be specified fo' every last muthafuckin file up in tha IMPLICIT_DEPENDS list. Dependencies discovered from tha scannin is added ta dem of tha custom command at build time.  Note dat tha IMPLICIT_DEPENDS option is currently supported only fo' Makefile generators n' is ghon be ignored by other generators.


If COMMAND specifies a executable target (created by ADD_EXECUTABLE) it will automatically be replaced by tha location of tha executable pimped at build time.  Additionally a target\-level dependency is ghon be added so dat tha executable target is ghon be built before any target rockin dis custom command. Y'all KNOW dat shit, muthafucka!  However dis do NOT add a gangbangin' file\-level dependency dat would cause tha custom command ta re\-run whenever tha executable is recompiled.


Arguments ta COMMAND may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

References ta target names up in generator expressions imply target\-level dependencies yo, but NOT file\-level dependencies. Put ya muthafuckin choppers up if ya feel dis!  List target names wit tha DEPENDS option ta add file dependencies.


Da DEPENDS option specifies filez on which tha command depends.  If any dependency be a OUTPUT of another custom command up in tha same directory (CMakeLists.txt file) CMake automatically brangs tha other custom command tha fuck into tha target up in which dis command is built.  If DEPENDS aint specified tha command will run whenever tha OUTPUT is missing; if tha command do not straight-up create tha OUTPUT then tha rule will always run. I aint talkin' bout chicken n' gravy biatch.  If DEPENDS specifies any target (created by a ADD_* command) a target\-level dependency is pimped ta make shizzle tha target is built before any target rockin dis custom command. Y'all KNOW dat shit, muthafucka!  Additionally, if tha target be a executable or library a gangbangin' file\-level dependency is pimped ta cause tha custom command ta re\-run whenever tha target is recompiled.


.TP
.B add_custom_target
Add a target wit no output so it will always be built.

.nf
  add_custom_target(Name [ALL] [command1 [args1...]]
                    [COMMAND command2 [args2...] ...]
                    [DEPENDS depend depend depend ... ]
                    [WORKING_DIRECTORY dir]
                    [COMMENT comment] [VERBATIM]
                    [SOURCES src1 [src2...]])
.fi

Addz a target wit tha given name dat executes tha given commands. Da target has no output file n' is ALWAYS CONSIDERED OUT OF DATE even if tha commandz try ta create a gangbangin' file wit tha name of tha target. Use ADD_CUSTOM_COMMAND ta generate a gangbangin' file wit dependencies. Put ya muthafuckin choppers up if ya feel dis! By default not a god damn thang dependz on tha custom target. Use ADD_DEPENDENCIES ta add dependencies ta or from other targets, n' you can put dat on yo' toast. If tha ALL option is specified it indicates dat dis target should be added ta tha default build target so dat it is ghon be run every last muthafuckin time (the command cannot be called ALL). Da command n' arguments is optionizzle n' if not specified a empty target is ghon be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If WORKING_DIRECTORY is set, then tha command is ghon be run up in dat directory. If it aint nuthin but a relatizzle path it is ghon be interpreted relatizzle ta tha build tree directory correspondin ta tha current source directory. If COMMENT is set, tha value is ghon be displayed as a message before tha commandz is executed at build time. Dependencies listed wit tha DEPENDS argument may reference filez n' outputz of custom commandz pimped wit add_custom_command() up in tha same directory (CMakeLists.txt file).


If VERBATIM is given then all arguments ta tha commandz is ghon be escaped properly fo' tha build tool so dat tha invoked command receives each argument unchanged. Y'all KNOW dat shit, muthafucka!  Note dat one level of escapes is still used by tha CMake language processor before add_custom_target even sees tha arguments, n' you can put dat on yo' toast. Use of VERBATIM is recommended as it enablez erect behavior. Shiiit, dis aint no joke. When VERBATIM aint given tha behavior is platform specific cuz there is no protection of tool\-specific special characters.


Da SOURCES option specifies additionizzle source filez ta be included up in tha custom target.  Specified source filez is ghon be added ta IDE project filez fo' convenience up in editin even if they aint build rules.

.TP
.B add_definitions
Addz \-D define flags ta tha compilation of source files.

.nf
  add_definitions(\-DFOO \-DBAR ...)
.fi

Addz flags ta tha compila command line fo' sources up in tha current directory n' below.  This command can be used ta add any flags yo, but dat shiznit was originally intended ta add preprocessor definitions.  Flags beginnin up in \-D or /D dat be lookin like preprocessor definitions is automatically added ta tha COMPILE_DEFINITIONS property fo' tha current directory.  Definitions wit non\-trivial joints may be left up in tha set of flags instead of bein converted fo' reasonz of backwardz compatibility.  See documentation of tha directory, target, n' source file COMPILE_DEFINITIONS propertizzles fo' details on addin preprocessor definitions ta specific scopes n' configurations.

.TP
.B add_dependencies
Add a thugged-out dependency between top\-level targets.

.nf
  add_dependencies(target\-name depend\-target1
                   depend\-target2 ...)
.fi

Make a top\-level target depend on other top\-level targets, n' you can put dat on yo' toast.  A top\-level target is one pimped by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET.  Addin dependencies wit dis command can be used ta make shizzle one target is built before another target.  Dependencies added ta a IMPORTED target is followed transitively up in its place since tha target itself do not build. Y'all KNOW dat shit, muthafucka!  See tha DEPENDS option of ADD_CUSTOM_TARGET n' ADD_CUSTOM_COMMAND fo' addin file\-level dependencies up in custom rules.  See tha OBJECT_DEPENDS option up in SET_SOURCE_FILES_PROPERTIES ta add file\-level dependencies ta object files.

.TP
.B add_executable
Add a executable ta tha project rockin tha specified source files.

.nf
  add_executable(<name> [WIN32] [MACOSX_BUNDLE]
                 [EXCLUDE_FROM_ALL]
                 source1 source2 ... sourceN)
.fi

Addz a executable target called <name> ta be built from tha source filez listed up in tha command invocation. I aint talkin' bout chicken n' gravy biatch.  Da <name> correspondz ta tha logical target name n' must be globally unique within a project.  Da actual file name of tha executable built is constructed based on conventionz of tha natizzle platform (like fuckin <name>.exe or just <name>).  


By default tha executable file is ghon be pimped up in tha build tree directory correspondin ta tha source tree directory up in which tha command was invoked. Y'all KNOW dat shit, muthafucka!  See documentation of tha RUNTIME_OUTPUT_DIRECTORY target property ta chizzle dis location. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha OUTPUT_NAME target property ta chizzle tha <name> part of tha final file name.  


If WIN32 is given tha property WIN32_EXECUTABLE is ghon be set on tha target pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See documentation of dat target property fo' details.


If MACOSX_BUNDLE is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha MACOSX_BUNDLE target property fo' details.


If EXCLUDE_FROM_ALL is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha EXCLUDE_FROM_ALL target property fo' details.


Da add_executable command can also create IMPORTED executable targets rockin dis signature:


.nf
  add_executable(<name> IMPORTED [GLOBAL])
.fi

An IMPORTED executable target references a executable file located outside tha project.  No rulez is generated ta build dat shit.  Da target name has scope up in tha directory up in which it is pimped n' below yo, but tha GLOBAL option extendz visibility.  It may be referenced like any target built within tha project.  IMPORTED executablez is useful fo' convenient reference from commandz like add_custom_command. Y'all KNOW dat shit, muthafucka!  Details bout tha imported executable is specified by settin propertizzles whose names begin up in "IMPORTED_".  Da most blingin such property is IMPORTED_LOCATION (and its per\-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies tha location of tha main executable file on disk.  See documentation of tha IMPORTED_* propertizzles fo' mo' shiznit.


Da signature


.nf
  add_executable(<name> ALIAS <target>)
.fi

creates a alias, such dat <name> can be used ta refer ta <target> up in subsequent commands.  Da <name> do not step tha fuck up in tha generated buildsystem as a make target.  Da <target> may not be a IMPORTED target or a ALIAS.  Alias targets can be used as linkable targets, targets ta read propertizzles from, executablez fo' custom commandz n' custom targets, n' you can put dat on yo' toast.  They can also be tested fo' existizzle wit tha regular if(TARGET) subcommand. Y'all KNOW dat shit, muthafucka!  Da <name> may not be used ta modify propertizzlez of <target>, dat is, it may not be used as tha operand of set_property, set_target_properties, target_link_libraries etc.  An ALIAS target may not be installed of exported.

.TP
.B add_library
Add a library ta tha project rockin tha specified source files.

.nf
  add_library(<name> [STATIC | SHARED | MODULE]
              [EXCLUDE_FROM_ALL]
              source1 source2 ... sourceN)
.fi

Addz a library target called <name> ta be built from tha source filez listed up in tha command invocation. I aint talkin' bout chicken n' gravy biatch.  Da <name> correspondz ta tha logical target name n' must be globally unique within a project.  Da actual file name of tha library built is constructed based on conventionz of tha natizzle platform (like fuckin lib<name>.a or <name>.lib).


STATIC, SHARED, or MODULE may be given ta specify tha type of library ta be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  STATIC libraries is archivez of object filez fo' use when linkin other targets, n' you can put dat on yo' toast.  SHARED libraries is linked dynamically n' loaded at runtime.  MODULE libraries is plugins dat is not linked tha fuck into other targets but may be loaded dynamically at runtime rockin dlopen\-like functionality.  If no type is given explicitly tha type is STATIC or SHARED based on whether tha current value of tha variable BUILD_SHARED_LIBS is true.  For SHARED n' MODULE libraries tha POSITION_INDEPENDENT_CODE target property is set ta TRUE automatically.


By default tha library file is ghon be pimped up in tha build tree directory correspondin ta tha source tree directory up in which tha command was invoked. Y'all KNOW dat shit, muthafucka!  See documentation of tha ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY, n' RUNTIME_OUTPUT_DIRECTORY target propertizzles ta chizzle dis location. I aint talkin' bout chicken n' gravy biatch.  See documentation of tha OUTPUT_NAME target property ta chizzle tha <name> part of tha final file name.  


If EXCLUDE_FROM_ALL is given tha correspondin property is ghon be set on tha pimped target.  See documentation of tha EXCLUDE_FROM_ALL target property fo' details.


Da add_library command can also create IMPORTED library targets rockin dis signature:


.nf
  add_library(<name> <SHARED|STATIC|MODULE|UNKNOWN> IMPORTED
              [GLOBAL])
.fi

An IMPORTED library target references a library file located outside tha project.  No rulez is generated ta build dat shit.  Da target name has scope up in tha directory up in which it is pimped n' below yo, but tha GLOBAL option extendz visibility.  It may be referenced like any target built within tha project.  IMPORTED libraries is useful fo' convenient reference from commandz like target_link_libraries. Put ya muthafuckin choppers up if ya feel dis!  Details bout tha imported library is specified by settin propertizzles whose names begin up in "IMPORTED_".  Da most blingin such property is IMPORTED_LOCATION (and its per\-configuration version IMPORTED_LOCATION_<CONFIG>) which specifies tha location of tha main library file on disk.  See documentation of tha IMPORTED_* propertizzles fo' mo' shiznit.


Da signature


.nf
  add_library(<name> OBJECT <src>...)
.fi

creates a special "object library" target.  An object library compilez source filez but do not archive or link they object filez tha fuck into a library.  Instead other targets pimped by add_library or add_executable may reference tha objects rockin a expression of tha form $<TARGET_OBJECTS:objlib> as a source, where "objlib" is tha object library name.  For example:


.nf
  add_library(... $<TARGET_OBJECTS:objlib> ...)
  add_executable(... $<TARGET_OBJECTS:objlib> ...)
.fi

will include objlibz object filez up in a library n' a executable along wit dem compiled from they own sources.  Object libraries may contain only sources (and headers) dat compile ta object files.  They may contain custom commandz generatin such sources yo, but not PRE_BUILD, PRE_LINK, or POST_BUILD commands.  Object libraries cannot be imported, exported, installed, or linked. Y'all KNOW dat shit, muthafucka!  Some natizzle build systems may not like targets dat have only object files, so consider addin at least one real source file ta any target dat references $<TARGET_OBJECTS:objlib>.


Da signature


.nf
  add_library(<name> ALIAS <target>)
.fi

creates a alias, such dat <name> can be used ta refer ta <target> up in subsequent commands.  Da <name> do not step tha fuck up in tha generated buildsystem as a make target.  Da <target> may not be a IMPORTED target or a ALIAS.  Alias targets can be used as linkable targets, targets ta read propertizzles from.  They can also be tested fo' existizzle wit tha regular if(TARGET) subcommand. Y'all KNOW dat shit, muthafucka!  Da <name> may not be used ta modify propertizzlez of <target>, dat is, it may not be used as tha operand of set_property, set_target_properties, target_link_libraries etc.  An ALIAS target may not be installed of exported.

.TP
.B add_subdirectory
Add a subdirectory ta tha build.

.nf
  add_subdirectory(source_dir [binary_dir] 
                   [EXCLUDE_FROM_ALL])
.fi

Add a subdirectory ta tha build. Y'all KNOW dat shit, muthafucka! Da source_dir specifies tha directory up in which tha source CMakeLists.txt n' code filez is located. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If it aint nuthin but a relatizzle path it is ghon be evaluated wit respect ta tha current directory (the typical usage) yo, but it may also be a absolute path. Da binary_dir specifies tha directory up in which ta place tha output files. If it aint nuthin but a relatizzle path it is ghon be evaluated wit respect ta tha current output directory yo, but it may also be a absolute path. If binary_dir aint specified, tha value of source_dir, before expandin any relatizzle path, is ghon be used (the typical usage). Da CMakeLists.txt file up in tha specified source directory is ghon be processed immediately by CMake before processin up in tha current input file continues beyond dis command.


If tha EXCLUDE_FROM_ALL argument is provided then targets up in tha subdirectory aint gonna be included up in tha ALL target of tha parent directory by default, n' is ghon be excluded from IDE project files.  Users must explicitly build targets up in tha subdirectory.  This is meant fo' use when tha subdirectory gotz nuff a separate part of tha project dat is useful but not necessary, like fuckin a set of examples.  Typically tha subdirectory should contain its own project() command invocation so dat a gangbangin' full build system is ghon be generated up in tha subdirectory (like fuckin a VS IDE solution file).  Note dat inter\-target dependencies supercede dis exclusion. I aint talkin' bout chicken n' gravy biatch.  If a target built by tha parent project dependz on a target up in tha subdirectory, tha dependee target is ghon be included up in tha parent project build system ta satisfy tha dependency.

.TP
.B add_test
Add a test ta tha project wit tha specified arguments.

.nf
  add_test(testname Exename arg1 arg2 ... )
.fi

If tha ENABLE_TESTING command has been run, dis command addz a test target ta tha current directory. If ENABLE_TESTING has not been run, dis command do nothing.  Da tests is run by tha testin subsystem by executin Exename wit tha specified arguments, n' you can put dat on yo' toast.  Exename can be either a executable built by dis project or a arbitrary executable on tha system (like tclsh).  Da test is ghon be run wit tha current hustlin directory set ta tha CMakeList.txt filez correspondin directory up in tha binary tree.





.nf
  add_test(NAME <name> [CONFIGURATIONS [Debug|Release|...]]
           [WORKING_DIRECTORY dir]
           COMMAND <command> [arg1 [arg2 ...]])
.fi

Add a test called <name>.  Da test name may not contain spaces, quotes, or other charactas special up in CMake syntax.  If COMMAND specifies a executable target (created by add_executable) it will automatically be replaced by tha location of tha executable pimped at build time.  If a CONFIGURATIONS option is given then tha test is ghon be executed only when testin under one of tha named configurations.  If a WORKING_DIRECTORY option is given then tha test is ghon be executed up in tha given directory.


Arguments afta COMMAND may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Example usage:


.nf
  add_test(NAME mytest
           COMMAND testDriver \-\-config $<CONFIGURATION>
                              \-\-exe $<TARGET_FILE:myexe>)
.fi

This creates a test "mytest" whose command runs a testDriver tool passin tha configuration name n' tha full path ta tha executable file produced by target "myexe".

.TP
.B aux_source_directory
Find all source filez up in a gangbangin' finger-lickin' directory.

.nf
  aux_source_directory(<dir> <variable>)
.fi

Collects tha namez of all tha source filez up in tha specified directory n' stores tha list up in tha <variable> provided. Y'all KNOW dat shit, muthafucka!  This command is intended ta be used by projects dat use explicit template instantiation. I aint talkin' bout chicken n' gravy biatch.  Template instantiation filez can be stored up in a "Templates" subdirectory n' collected automatically rockin dis command ta avoid manually listin all instantiations.


It be temptin ta use dis command ta avoid freestylin tha list of source filez fo' a library or executable target.  While dis seems ta work, there is no way fo' CMake ta generate a funky-ass build system dat knows when a freshly smoked up source file has been added. Y'all KNOW dat shit, muthafucka!  Normally tha generated build system knows when it need ta rerun CMake cuz tha CMakeLists.txt file is modified ta add a freshly smoked up source.  When tha source is just added ta tha directory without modifyin dis file, one would gotta manually rerun CMake ta generate a funky-ass build system incorporatin tha freshly smoked up file.

.TP
.B break
Break from a enclosin foreach or while loop.

.nf
  break()
.fi

Breaks from a enclosin foreach loop or while loop

.TP
.B build_command
Git tha command line ta build dis project.

.nf
  build_command(<variable>
                [CONFIGURATION <config>]
                [PROJECT_NAME <projname>]
                [TARGET <target>])
.fi

Sets tha given <variable> ta a strang containin tha command line fo' buildin one configuration of a target up in a project rockin tha build tool appropriate fo' tha current CMAKE_GENERATOR.


If CONFIGURATION is omitted, CMake chizzlez a reasonable default value  fo' multi\-configuration generators.  CONFIGURATION is ignored fo' single\-configuration generators.


If PROJECT_NAME is omitted, tha resultin command line will build tha top level PROJECT up in tha current build tree.


If TARGET is omitted, tha resultin command line will build every last muthafuckin thang, effectively rockin build target 'all' or 'ALL_BUILD'.


.nf
  build_command(<cachevariable> <makecommand>)
.fi

This second signature is deprecated yo, but still available fo' backwardz compatibility. Use tha straight-up original gangsta signature instead.


Sets tha given <cachevariable> ta a strang containin tha command ta build dis project from tha root of tha build tree rockin tha build tool given by <makecommand>.  <makecommand> should be tha full path ta msdev, devenv, nmake, make or one of tha end user build tools.

.TP
.B cmake_host_system_information
Query host system specific shiznit.

.nf
  cmake_host_system_information(RESULT <variable> QUERY <key> ...)
.fi

Queries system shiznit of tha host system on which cmake runs. One or mo' <key> can be provided ta select tha shiznit ta be queried. Y'all KNOW dat shit, muthafucka! Da list of queried joints is stored up in <variable>.


<key> can be one of tha followin joints:


.nf
  NUMBER_OF_LOGICAL_CORES   = Number of logical cores.
  NUMBER_OF_PHYSICAL_CORES  = Number of physical cores.
  HOSTNAME                  = Hostname.
  FQDN                      = Fully qualified domain name.
  TOTAL_VIRTUAL_MEMORY      = Total virtual memory up in megabytes.
  AVAILABLE_VIRTUAL_MEMORY  = Available virtual memory up in megabytes.
  TOTAL_PHYSICAL_MEMORY     = Total physical memory up in megabytes.
  AVAILABLE_PHYSICAL_MEMORY = Available physical memory up in megabytes.
.fi

.TP
.B cmake_minimum_required
Set tha minimum required version of cmake fo' a project.

.nf
  cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]]
                         [FATAL_ERROR])
.fi

If tha current version of CMake is lower than dat required it will stop processin tha project n' report a error. Shiiit, dis aint no joke.  When a version higher than 2.4 is specified tha command implicitly invokes


.nf
  cmake_policy(VERSION major[.minor[.patch[.tweak]]])
.fi

which sets tha cmake policy version level ta tha version specified. Y'all KNOW dat shit, muthafucka!  When version 2.4 or lower is given tha command implicitly invokes


.nf
  cmake_policy(VERSION 2.4)
.fi

which enablez compatibilitizzle features fo' CMake 2.4 n' lower.


Da FATAL_ERROR option be accepted but ignored by CMake 2.6 n' higher n' shit.  It should be specified so CMake versions 2.4 n' lower fail wit a error instead of just a warning.

.TP
.B cmake_policy
Manage CMake Policy settings.

As CMake evolves it is sometimes necessary ta chizzle existin behavior up in order ta fix bugs or improve implementationz of existin features.  Da CMake Policy mechanizzle is designed ta help keep existin projects buildin as freshly smoked up versionz of CMake introduce chizzlez up in behavior. Shiiit, dis aint no joke.  Each freshly smoked up policy (behavioral chizzle) is given a identifier of tha form "CMP<NNNN>" where "<NNNN>" be a integer index.  Documentation associated wit each policy raps bout tha OLD n' NEW behavior n' tha reason tha policy was introduced. Y'all KNOW dat shit, muthafucka!  Projects may set each policy ta select tha desired behavior. Shiiit, dis aint no joke.  When CMake need ta know which behavior ta use it checks fo' a settin specified by tha project.  If no settin be available tha OLD behavior be assumed n' a warnin is produced requestin dat tha policy be set.


Da cmake_policy command is used ta set policies ta OLD or NEW behavior. Shiiit, dis aint no joke.  While settin policies individually is supported, we encourage projects ta set policies based on CMake versions.


.nf
  cmake_policy(VERSION major.minor[.patch[.tweak]])
.fi

Specify dat tha current CMake list file is freestyled fo' tha given version of CMake.  All policies introduced up in tha specified version or earlier is ghon be set ta use NEW behavior. Shiiit, dis aint no joke.  All policies introduced afta tha specified version is ghon be unset (unless variable CMAKE_POLICY_DEFAULT_CMP<NNNN> sets a thugged-out default).  This effectively requests behavior preferred az of a given CMake version n'  drops some lyrics ta newer CMake versions ta warn bout they freshly smoked up policies. Put ya muthafuckin choppers up if ya feel dis!  Da policy version specified must be at least 2.4 or tha command will report a error. Shiiit, dis aint no joke.  In order ta git compatibilitizzle features supportin versions earlier than 2.4 peep documentation of policy CMP0001.


.nf
  cmake_policy(SET CMP<NNNN> NEW)
  cmake_policy(SET CMP<NNNN> OLD)
.fi

Tell CMake ta use tha OLD or NEW behavior fo' a given policy.  Projects dependin on tha oldschool behavior of a given policy may silence a policy warnin by settin tha policy state ta OLD.  Alternatively one may fix tha project ta work wit tha freshly smoked up behavior n' set tha policy state ta NEW.


.nf
  cmake_policy(GET CMP<NNNN> <variable>)
.fi

Peep whether a given policy is set ta OLD or NEW behavior. Shiiit, dis aint no joke.  Da output variable value is ghon be "OLD" or "NEW" if tha policy is set, n' empty otherwise.


CMake keeps policy settings on a stack, so chizzlez made by tha cmake_policy command affect only tha top of tha stack.  A freshly smoked up entry on tha policy stack is managed automatically fo' each subdirectory ta protect its muthafathas n' siblings.  CMake also manages a freshly smoked up entry fo' scripts loaded by include() n' find_package() commandz except when invoked wit tha NO_POLICY_SCOPE option (see also policy CMP0011).  Da cmake_policy command serves up a intercourse ta manage custom entries on tha policy stack:


.nf
  cmake_policy(PUSH)
  cmake_policy(POP)
.fi

Each PUSH must gotz a matchin POP ta erase any chizzles.  This is useful ta make temporary chizzlez ta policy settings.


Functions n' macros record policy settings when they is pimped n' use tha pre\-record policies when they is invoked. Y'all KNOW dat shit, muthafucka!  If tha function or macro implementation sets policies, tha chizzlez automatically propagate up all up in callaz until they reach tha closest nested policy stack entry.

.TP
.B configure_file
Copy a gangbangin' file ta another location n' modify its contents.

.nf
  configure_file(<input> <output>
                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY] 
                 [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])
.fi

Copies a gangbangin' file <input> ta file <output> n' substitutes variable joints referenced up in tha file content.  If <input> be a relatizzle path it is evaluated wit respect ta tha current source directory.  Da <input> must be a gangbangin' file, not a gangbangin' finger-lickin' directory.  If <output> be a relatizzle path it is evaluated wit respect ta tha current binary directory.  If <output> names a existin directory tha input file is placed up in dat directory wit its original gangsta name.  


If tha <input> file is modified tha build system will re\-run CMake ta re\-configure tha file n' generate tha build system again.


This command replaces any variablez up in tha input file referenced as ${VAR} or @VAR@ wit they joints as determined by CMake.  If a variable aint defined, it is ghon be replaced wit nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes is ghon be C\-style escaped. Y'all KNOW dat shit, muthafucka!  Da file is ghon be configured wit tha current jointz of CMake variables. If @ONLY is specified, only variablez of tha form @VAR@ is ghon be replaced n' ${VAR} is ghon be ignored. Y'all KNOW dat shit, muthafucka!  This is useful fo' configurin scripts dat use ${VAR}.


Input file linez of tha form "#cmakedefine VAR ..." is ghon be replaced wit either "#define VAR ..." or "/* #undef VAR */" dependin on whether VAR is set up in CMake ta any value not considered a gangbangin' false constant by tha if() command. Y'all KNOW dat shit, muthafucka! (Content of "...", if any, is processed as above.) Input file linez of tha form "#cmakedefine01 VAR" is ghon be replaced wit either "#define VAR 1" or "#define VAR 0" similarly.


With NEWLINE_STYLE tha line endin could be adjusted: 


.nf
    'UNIX' or 'LF' fo' \\n, 'DOS', 'WIN32' or 'CRLF' fo' \\r\\n.
.fi

COPYONLY must not be used wit NEWLINE_STYLE.


.TP
.B create_test_sourcelist
Smoke a test driver n' source list fo' buildin test programs.

.nf
  create_test_sourcelist(sourceListName driverName
                         test1 test2 test3
                         EXTRA_INCLUDE include.h
                         FUNCTION function)
.fi

A test driver be a program dat links together nuff lil' small-ass tests tha fuck into a single executable.  This is useful when buildin static executablez wit big-ass libraries ta shrink tha total required size.  Da list of source filez needed ta build tha test driver is ghon be up in sourceListName.  DriverName is tha name of tha test driver program.  Da rest of tha arguments consist of a list of test source files, can be semicolon separated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Each test source file should gotz a gangbangin' function up in it dat is tha same ol' dirty name as tha file wit no extension (foo.cxx should have int foo(int, char*[]);) DriverName is ghon be able ta booty-call each of tha tests by name on tha command line. If EXTRA_INCLUDE is specified, then tha next argument is included tha fuck into tha generated file. If FUNCTION is specified, then tha next argument is taken as a gangbangin' function name dat is passed a pointa ta ac n' av.  This can be used ta add extra command line processin ta each test. Da cmake variable CMAKE_TESTDRIVER_BEFORE_TESTMAIN can be set ta have code dat is ghon be placed directly before callin tha test main function. I aint talkin' bout chicken n' gravy biatch.   CMAKE_TESTDRIVER_AFTER_TESTMAIN can be set ta have code dat is ghon be placed directly afta tha call ta tha test main function.

.TP
.B define_property
Define n' document custom properties.

.nf
  define_property(<GLOBAL | DIRECTORY | TARGET | SOURCE |
                   TEST | VARIABLE | CACHED_VARIABLE>
                   PROPERTY <name> [INHERITED]
                   BRIEF_DOCS <brief\-doc> [docs...]
                   FULL_DOCS <full\-doc> [docs...])
.fi

Define one property up in a scope fo' use wit tha set_property n' get_property commands.  This is primarily useful ta associate documentation wit property names dat may be retrieved wit tha get_property command. Y'all KNOW dat shit, muthafucka!  Da first argument determines tha kind of scope up in which tha property should be used. Y'all KNOW dat shit, muthafucka!  It must be one of tha following:


.nf
  GLOBAL    = associated wit tha global namespace
  DIRECTORY = associated wit one directory
  TARGET    = associated wit one target
  SOURCE    = associated wit one source file
  TEST      = associated wit a test named wit add_test
  VARIABLE  = documents a CMake language variable
  CACHED_VARIABLE = documents a CMake cache variable
.fi

Note dat unlike set_property n' get_property no actual scope need ta be given; only tha kind of scope is blingin.


Da required PROPERTY option is immediately followed by tha name of tha property bein defined.


If tha INHERITED option then tha get_property command will chain up ta tha next higher scope when tha axed property aint set up in tha scope given ta tha command. Y'all KNOW dat shit, muthafucka!  DIRECTORY scope chains ta GLOBAL.  TARGET, SOURCE, n' TEST chain ta DIRECTORY.


Da BRIEF_DOCS n' FULL_DOCS options is followed by strings ta be associated wit tha property as its brief n' full documentation. I aint talkin' bout chicken n' gravy biatch.  Correspondin options ta tha get_property command will retrieve tha documentation.

.TP
.B else
Starts tha else portion of a if block.

.nf
  else(expression)
.fi

See tha if command.

.TP
.B elseif
Starts tha elseif portion of a if block.

.nf
  elseif(expression)
.fi

See tha if command.

.TP
.B enable_language
Enable a language (CXX/C/Fortran/etc)

.nf
  enable_language(<lang> [OPTIONAL] )
.fi

This command enablez support fo' tha named language up in CMake. This is tha same ol' dirty as tha project command but do not create any of tha extra variablez dat is pimped by tha project command. Y'all KNOW dat shit, muthafucka! Example languages is CXX, C, Fortran. I aint talkin' bout chicken n' gravy biatch. 


This command must be called up in file scope, not up in a gangbangin' function call.  Furthermore, it must be called up in tha highest directory common ta all targets rockin tha named language directly fo' compilin sources or indirectly all up in link dependencies. Put ya muthafuckin choppers up if ya feel dis!  It be simplest ta enable all needed languages up in tha top\-level directory of a project.


Da OPTIONAL keyword be a placeholda fo' future implementation n' do not currently work.

.TP
.B enable_testing
Enable testin fo' current directory n' below.

.nf
  enable_testing()
.fi

Enablez testin fo' dis directory n' below.  See also tha add_test command. Y'all KNOW dat shit, muthafucka!  Note dat ctest expects ta find a test file up in tha build directory root.  Therefore, dis command should be up in tha source directory root.

.TP
.B endforeach
Endz a list of commandz up in a FOREACH block.

.nf
  endforeach(expression)
.fi

See tha FOREACH command.

.TP
.B endfunction
Endz a list of commandz up in a gangbangin' function block.

.nf
  endfunction(expression)
.fi

See tha function command.

.TP
.B endif
Endz a list of commandz up in a if block.

.nf
  endif(expression)
.fi

See tha if command.

.TP
.B endmacro
Endz a list of commandz up in a macro block.

.nf
  endmacro(expression)
.fi

See tha macro command.

.TP
.B endwhile
Endz a list of commandz up in a while block.

.nf
  endwhile(expression)
.fi

See tha while command.

.TP
.B execute_process
Execute one or mo' lil pimp processes.

.nf
  execute_process(COMMAND <cmd1> [args1...]]
                  [COMMAND <cmd2> [args2...] [...]]
                  [WORKING_DIRECTORY <directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE <variable>]
                  [OUTPUT_VARIABLE <variable>]
                  [ERROR_VARIABLE <variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                  [OUTPUT_STRIP_TRAILING_WHITESPACE]
                  [ERROR_STRIP_TRAILING_WHITESPACE])
.fi

Runs tha given sequence of one or mo' commandz wit tha standard output of each process piped ta tha standard input of tha next.  A single standard error pipe is used fo' all processes.  If WORKING_DIRECTORY is given tha named directory is ghon be set as tha current hustlin directory of tha lil pimp processes.  If TIMEOUT is given tha lil pimp processes is ghon be terminated if they do not finish up in tha specified number of secondz (fractions is allowed).  If RESULT_VARIABLE is given tha variable is ghon be set ta contain tha result of hustlin tha processes.  This is ghon be a integer return code from tha last lil pimp or a strang describin a error condition. I aint talkin' bout chicken n' gravy biatch.  If OUTPUT_VARIABLE or ERROR_VARIABLE is given tha variable named is ghon be set wit tha contentz of tha standard output n' standard error pipes respectively.  If tha same variable is named fo' both pipes they output is ghon be merged up in tha order produced. Y'all KNOW dat shit, muthafucka!  If INPUT_FILE, OUTPUT_FILE, or ERROR_FILE is given tha file named is ghon be attached ta tha standard input of tha straight-up original gangsta process, standard output of tha last process, or standard error of all processes respectively.  If OUTPUT_QUIET or ERROR_QUIET is given then tha standard output or standard error thangs up in dis biatch is ghon be on tha fuckin' down-lowly ignored. Y'all KNOW dat shit, muthafucka!  If mo' than one OUTPUT_* or ERROR_* option is given fo' tha same pipe tha precedence aint specified. Y'all KNOW dat shit, muthafucka!  If no OUTPUT_* or ERROR_* options is given tha output is ghon be shared wit tha correspondin pipez of tha CMake process itself.


Da execute_process command be a newer mo' bangin version of exec_program yo, but tha oldschool command has been kept fo' compatibility.

.TP
.B export
Export targets from tha build tree fo' use by outside projects.

.nf
  export(TARGETS [target1 [target2 [...]]] [NAMESPACE <namespace>]
         [APPEND] FILE <filename> [EXPORT_LINK_INTERFACE_LIBRARIES])
.fi

Smoke a gangbangin' file <filename> dat may be included by outside projects ta import targets from tha current projectz build tree.  This is useful durin cross\-compilin ta build utilitizzle executablez dat can run on tha host platform up in one project n' then import dem tha fuck into another project bein compiled fo' tha target platform.  If tha NAMESPACE option is given tha <namespace> strang is ghon be prepended ta all target names freestyled ta tha file.  If tha APPEND option is given tha generated code is ghon be appended ta tha file instead of overwritin dat shit.  Da EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes tha contentz of tha propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)? ta be exported, when policy CMP0022 is NEW.  If a library target is included up in tha export but a target ta which it links aint included tha behavior is unspecified.


Da file pimped by dis command is specific ta tha build tree n' should never be installed. Y'all KNOW dat shit, muthafucka!  See tha install(EXPORT) command ta export targets from a installation tree.


Do not set propertizzles dat affect tha location of a target afta passin it ta dis command. Y'all KNOW dat shit, muthafucka!  These include propertizzles whose names match "(RUNTIME|LIBRARY|ARCHIVE)_OUTPUT_(NAME|DIRECTORY)(_<CONFIG>)?", "(IMPLIB_)?(PREFIX|SUFFIX)", or "LINKER_LANGUAGE".  Failure ta follow dis rule aint diagnosed n' leaves tha location of tha target undefined.


.nf
  export(PACKAGE <name>)
.fi

Store tha current build directory up in tha CMake user package registry fo' package <name>.  Da find_package command may consider tha directory while searchin fo' package <name>.  This helps dependent projects find n' bust a package from tha current projectz build tree without help from tha user n' shit.  Note dat tha entry up in tha package registry dat dis command creates works only up in conjunction wit a package configuration file (<name>Config.cmake) dat works wit tha build tree.

.TP
.B file
File manipulation command.

.nf
  file(WRITE filename "message ta write"... )
  file(APPEND filename "message ta write"... )
  file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])
  file(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512> filename variable)
  file(STRINGS filename variable [LIMIT_COUNT num]
       [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]
       [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]
       [NEWLINE_CONSUME] [REGEX regex]
       [NO_HEX_CONVERSION])
  file(GLOB variable [RELATIVE path] [globbin expressions]...)
  file(GLOB_RECURSE variable [RELATIVE path] 
       [FOLLOW_SYMLINKS] [globbin expressions]...)
  file(RENAME <oldname> <newname>)
  file(REMOVE [file1 ...])
  file(REMOVE_RECURSE [file1 ...])
  file(MAKE_DIRECTORY [directory1 directory2 ...])
  file(RELATIVE_PATH variable directory file)
  file(TO_CMAKE_PATH path result)
  file(TO_NATIVE_PATH path result)
  file(DOWNLOAD url file [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS]
       [EXPECTED_HASH ALGO=value] [EXPECTED_MD5 sum]
       [TLS_VERIFY on|off] [TLS_CAINFO file])
  file(UPLOAD filename url [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS])
  file(TIMESTAMP filename variable [<format string>] [UTC])
  file(GENERATE OUTPUT output_file
       <INPUT input_file|CONTENT input_content>
       [CONDITION expression])
.fi

WRITE will write a message tha fuck into a gangbangin' file called 'filename'. Well shiiiit, it overwrites tha file if it already exists, n' creates tha file if it do not exist. (If tha file be a funky-ass build input, use configure_file ta update tha file only when its content chizzles.)


APPEND will write a message tha fuck into a gangbangin' file same as WRITE, except it will append it ta tha end of tha file


READ will read tha content of a gangbangin' file n' store it tha fuck into tha variable. Well shiiiit, it will start all up in tha given offset n' read up ta numBytes. If tha argument HEX is given, tha binary data is ghon be converted ta hexadecimal representation n' dis is ghon be stored up in tha variable.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha content of a gangbangin' file.


STRINGS will parse a list of ASCII strings from a gangbangin' file n' store it up in a variable. Binary data up in tha file is ignored. Y'all KNOW dat shit, muthafucka! Carriage return (CR) charactas is ignored. Y'all KNOW dat shit, muthafucka! Well shiiiit, it works also fo' Intel Hex n' Motorola S\-record files, which is automatically converted ta binary format when readin em. Disable dis rockin NO_HEX_CONVERSION.


LIMIT_COUNT sets tha maximum number of strings ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. LIMIT_INPUT sets tha maximum number of bytes ta read from tha input file. LIMIT_OUTPUT sets tha maximum number of bytes ta store up in tha output variable. LENGTH_MINIMUM sets tha minimum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Shorta strings is ignored. Y'all KNOW dat shit, muthafucka! LENGTH_MAXIMUM sets tha maximum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Longer strings is split tha fuck into strings no longer than tha maximum length. NEWLINE_CONSUME allows newlines ta be included up in strings instead of terminatin em.


REGEX specifies a regular expression dat a strang must match ta be returned. Y'all KNOW dat shit, muthafucka! Typical usage 


.nf
  file(STRINGS myfile.txt myfile)
.fi

stores a list up in tha variable "myfile" up in which each item be a line from tha input file.


GLOB will generate a list of all filez dat match tha globbin expressions n' store it tha fuck into tha variable. Globbin expressions is similar ta regular expressions yo, but much simpla n' shit. If RELATIVE flag is specified fo' a expression, tha thangs up in dis biatch is ghon be returned as a relatizzle path ta tha given path.  (Us dudes do not recommend rockin GLOB ta collect a list of source filez from yo' source tree.  If no CMakeLists.txt file chizzlez when a source be added or removed then tha generated build system cannot know when ta ask CMake ta regenerate.)


Examplez of globbin expressions include:


.nf
   *.cxx      \- match all filez wit extension cxx
   *.vt?      \- match all filez wit extension vta,...,vtz
   f[3\-5].txt \- match filez f3.txt, f4.txt, f5.txt
.fi

GLOB_RECURSE will generate a list similar ta tha regular GLOB, except it will traverse all tha subdirectoriez of tha matched directory n' match tha files. Right back up in yo muthafuckin ass. Subdirectories dat is symlinks is only traversed if FOLLOW_SYMLINKS is given or cmake policy CMP0009 aint set ta NEW. Right back up in yo muthafuckin ass. See cmake \-\-help\-policy CMP0009 fo' mo' shiznit.


Examplez of recursive globbin include:


.nf
   /dir/*.py  \- match all python filez up in /dir n' subdirectories
.fi

MAKE_DIRECTORY will create tha given directories, also if they parent directories don't exist yet


RENAME moves a gangbangin' file or directory within a gangbangin' filesystem, replacin tha destination atomically.


REMOVE will remove tha given files, also up in subdirectories


REMOVE_RECURSE will remove tha given filez n' directories, also non\-empty directories


RELATIVE_PATH will determine relatizzle path from directory ta tha given file.


TO_CMAKE_PATH will convert path tha fuck into a cold-ass lil cmake steez path wit unix /.  Da input can be a single path or a system path like "$ENV{PATH}".  Note tha double quotes round tha ENV call TO_CMAKE_PATH only takes  one argument. This command will also convert tha natizzle list delimitas fo' a list of paths like tha PATH environment variable.


TO_NATIVE_PATH works just like TO_CMAKE_PATH yo, but will convert from  a cold-ass lil cmake steez path tha fuck into tha natizzle path steez \\ fo' windows n' / fo' UNIX.


DOWNLOAD will downlizzle tha given URL ta tha given file. If LOG var is specified a log of tha downlizzle is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If EXPECTED_HASH ALGO=value is specified, tha operation will verify dat tha downloaded filez actual hash matches tha expected value, where ALGO is one of MD5, SHA1, SHA224, SHA256, SHA384, or SHA512.  If it do not match, tha operation fails wit a error. Shiiit, dis aint no joke. ("EXPECTED_MD5 sum" is short\-hand fo' "EXPECTED_HASH MD5=sum".) If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete. For https URLs CMake must be built wit OpenSSL.  TLS/SSL certificates is not checked by default.  Set TLS_VERIFY ta ON ta check certificates and/or use EXPECTED_HASH ta verify downloaded content.  Set TLS_CAINFO ta specify a cold-ass lil custom Certificate Authoritizzle file.  If either TLS option aint given CMake will check variablez CMAKE_TLS_VERIFY n' CMAKE_TLS_CAINFO, respectively.


UPLOAD will upload tha given file ta tha given URL. If LOG var is specified a log of tha upload is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete.


TIMESTAMP will write a strang representation of tha modification time of filename ta variable.


Should tha command be unable ta obtain a timestamp variable is ghon be set ta tha empty strang "".


See documentation of tha strang TIMESTAMP sub\-command fo' mo' details.


Da file() command also serves up COPY n' INSTALL signatures:


.nf
  file(<COPY|INSTALL> files... DESTINATION <dir>
       [FILE_PERMISSIONS permissions...]
       [DIRECTORY_PERMISSIONS permissions...]
       [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]
       [FILES_MATCHING]
       [[PATTERN <pattern> | REGEX <regex>]
        [EXCLUDE] [PERMISSIONS permissions...]] [...])
.fi

Da COPY signature copies files, directories, n' symlinks ta a thugged-out destination folda n' shit.  Relatizzle input paths is evaluated wit respect ta tha current source directory, n' a relatizzle destination is evaluated wit respect ta tha current build directory.  Copyin preserves input file timestamps, n' optimizes up a gangbangin' file if it exists all up in tha destination wit tha same timestamp.  Copyin preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS is given (default is USE_SOURCE_PERMISSIONS).  See tha install(DIRECTORY) command fo' documentation of permissions, PATTERN, REGEX, n' EXCLUDE options.  


Da INSTALL signature differs slightly from COPY: it prints status lyrics, n' NO_SOURCE_PERMISSIONS is default.  Installation scripts generated by tha install() command use dis signature (with some undocumented options fo' internal use).


GENERATE will write a <output_file> wit content from a <input_file>, or from <input_content>.  Da output is generated conditionally based on tha content of tha <condition>.  Da file is freestyled at CMake generate\-time n' tha input may contain generator expressions.  Da <condition>, <output_file> n' <input_file> may also contain generator expressions.  Da <condition> must evaluate ta either '0' or '1'.  Da <output_file> must evaluate ta a unique name among all configurations n' among all invocationz of file(GENERATE).

.TP
.B find_file
Find tha full path ta a gangbangin' file.

.nf
   find_file(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_file(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_file(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' full path ta named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha full path ta a gangbangin' file is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_file is invoked wit tha same variable.  Da name of tha full path ta a gangbangin' file dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_file(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_file(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B find_library
Find a library.

.nf
   find_library(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_library(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_library(
             <VAR>
             name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a library fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha library is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_library is invoked wit tha same variable.  Da name of tha library dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   LIB
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_LIBRARY_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_library(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_library(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When mo' than one value is given ta tha NAMES option dis command by default will consider one name at a time n' search every last muthafuckin directory fo' dat shit.  Da NAMES_PER_DIR option  drops some lyrics ta dis command ta consider one directory at a time n' search fo' all names up in dat shit.


If tha library found be a gangbangin' framework, then VAR is ghon be set ta tha full path ta tha framework <fullPath>/A.framework. When a gangbangin' full path ta a gangbangin' framework is used as a library, CMake will bust a \-framework A, n' a \-F<fullPath> ta link tha framework ta tha target.


If tha global property FIND_LIBRARY_USE_LIB64_PATHS is set all search paths is ghon be tested as normal, wit "64/" appended, n' wit all matchez of "lib/" replaced wit "lib64/". This property be automatically set fo' tha platforms dat is known ta need it if at least one of tha languages supported by tha PROJECT command is enabled.

.TP
.B find_package
Load settings fo' a external project.

.nf
  find_package(<package> [version] [EXACT] [QUIET] [MODULE]
               [REQUIRED] [[COMPONENTS] [components...]]
               [OPTIONAL_COMPONENTS components...]
               [NO_POLICY_SCOPE])
.fi

Findz n' loadz settings from a external project.  <package>_FOUND is ghon be set ta indicate whether tha package was found. Y'all KNOW dat shit, muthafucka!  When tha package is found package\-specific shiznit is provided all up in variablez n' imported targets documented by tha package itself.  Da QUIET option disablez lyrics if tha package cannot be found. Y'all KNOW dat shit, muthafucka!  Da MODULE option disablez tha second signature documented below.  Da REQUIRED option stops processin wit a error message if tha package cannot be found.


A package\-specific list of required components may be listed afta tha COMPONENTS option (or afta tha REQUIRED option if present).  Additionizzle optionizzle components may be listed afta OPTIONAL_COMPONENTS.  Available components n' they influence on whether a package is considered ta be found is defined by tha target package.


Da [version] argument requests a version wit which tha package found should be compatible (format is major[.minor[.patch[.tweak]]]).  Da EXACT option requests dat tha version be matched exactly.  If no [version] and/or component list is given ta a recursive invocation inside a gangbangin' find\-module, tha correspondin arguments is forwarded automatically from tha outa call (includin tha EXACT flag fo' [version]).  Version support is currently provided only on a package\-by\-package basis (details below).


User code should generally look fo' packages rockin tha above simple signature.  Da remainder of dis command documentation specifies tha full command signature n' detailz of tha search process.  Project maintainers wishin ta provide a package ta be found by dis command is encouraged ta read on.


Da command has two modes by which it searches fo' packages: "Module" mode n' "Config" mode.  Module mode be available when tha command is invoked wit tha above reduced signature.  CMake searches fo' a gangbangin' file called "Find<package>.cmake" up in tha CMAKE_MODULE_PATH followed by tha CMake installation. I aint talkin' bout chicken n' gravy biatch.  If tha file is found, it is read n' processed by CMake.  It be responsible fo' findin tha package, checkin tha version, n' producin any needed lyrics.  Many find\-modulez provide limited or no support fo' versioning; check tha module documentation. I aint talkin' bout chicken n' gravy biatch.  If no module is found n' tha MODULE option aint given tha command proceedz ta Config mode.


Da complete Config mode command signature is:


.nf
  find_package(<package> [version] [EXACT] [QUIET]
               [REQUIRED] [[COMPONENTS] [components...]]
               [CONFIG|NO_MODULE]
               [NO_POLICY_SCOPE]
               [NAMES name1 [name2 ...]]
               [CONFIGS config1 [config2 ...]]
               [HINTS path1 [path2 ... ]]
               [PATHS path1 [path2 ... ]]
               [PATH_SUFFIXES suffix1 [suffix2 ...]]
               [NO_DEFAULT_PATH]
               [NO_CMAKE_ENVIRONMENT_PATH]
               [NO_CMAKE_PATH]
               [NO_SYSTEM_ENVIRONMENT_PATH]
               [NO_CMAKE_PACKAGE_REGISTRY]
               [NO_CMAKE_BUILDS_PATH]
               [NO_CMAKE_SYSTEM_PATH]
               [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
               [CMAKE_FIND_ROOT_PATH_BOTH |
                ONLY_CMAKE_FIND_ROOT_PATH |
                NO_CMAKE_FIND_ROOT_PATH])
.fi

Da CONFIG option may be used ta skip Module mode explicitly n' switch ta Config mode.  It be synonymous ta rockin NO_MODULE.  Config mode be also implied by use of options not specified up in tha reduced signature.  


Config mode attempts ta locate a cold-ass lil configuration file provided by tha package ta be found. Y'all KNOW dat shit, muthafucka!  A cache entry called <package>_DIR is pimped ta hold tha directory containin tha file.  By default tha command searches fo' a package wit tha name <package>.  If tha NAMES option is given tha names followin it is used instead of <package>.  Da command searches fo' a gangbangin' file called "<name>Config.cmake" or "<lower\-case\-name>\-config.cmake" fo' each name specified. Y'all KNOW dat shit, muthafucka!  A replacement set of possible configuration file names may be given rockin tha CONFIGS option. I aint talkin' bout chicken n' gravy biatch.  Da search procedure is specified below.  Once found, tha configuration file is read n' processed by CMake.  Since tha file is provided by tha package it already knows tha location of package contents, n' you can put dat on yo' toast.  Da full path ta tha configuration file is stored up in tha cmake variable <package>_CONFIG.


All configuration filez which done been considered by CMake while searchin fo' a installation of tha package wit a appropriate version is stored up in tha cmake variable <package>_CONSIDERED_CONFIGS, tha associated versions up in <package>_CONSIDERED_VERSIONS. 


If tha package configuration file cannot be found CMake will generate a error describin tha problem unless tha QUIET argument is specified. Y'all KNOW dat shit, muthafucka!  If REQUIRED is specified n' tha package aint found a gangbangin' fatal error is generated n' tha configure step stops executing.  If <package>_DIR has been set ta a gangbangin' finger-lickin' directory not containin a cold-ass lil configuration file CMake will ignore it n' search from scratch.


When tha [version] argument is given Config mode will only find a version of tha package dat fronts compatibilitizzle wit tha axed version (format is major[.minor[.patch[.tweak]]]).  If tha EXACT option is given only a version of tha package frontin a exact match of tha axed version may be found. Y'all KNOW dat shit, muthafucka!  CMake do not establish any convention fo' tha meanin of version numbers.  Package version numbers is checked by "version" filez provided by tha packages theyselves.  For a cold-ass lil muthafucka package configuration file "<config\-file>.cmake" tha correspondin version file is located next ta it n' named either "<config\-file>\-version.cmake" or "<config\-file>Version.cmake".  If no such version file be available then tha configuration file be assumed ta not be compatible wit any axed version. I aint talkin' bout chicken n' gravy biatch.  A basic version file containin generic version matchin code can be pimped rockin tha macro write_basic_package_version_file(), peep its documentation fo' mo' details.  When a version file is found it is loaded ta check tha axed version number n' shit.  Da version file is loaded up in a nested scope up in which tha followin variablez done been defined:


.nf
  PACKAGE_FIND_NAME          = tha <package> name
  PACKAGE_FIND_VERSION       = full axed version string
  PACKAGE_FIND_VERSION_MAJOR = major version if requested, else 0
  PACKAGE_FIND_VERSION_MINOR = minor version if requested, else 0
  PACKAGE_FIND_VERSION_PATCH = patch version if requested, else 0
  PACKAGE_FIND_VERSION_TWEAK = tweak version if requested, else 0
  PACKAGE_FIND_VERSION_COUNT = number of version components, 0 ta 4
.fi

Da version file checks whether it satisfies tha axed version n' sets these variables:


.nf
  PACKAGE_VERSION            = full provided version string
  PACKAGE_VERSION_EXACT      = legit if version is exact match
  PACKAGE_VERSION_COMPATIBLE = legit if version is compatible
  PACKAGE_VERSION_UNSUITABLE = legit if unsuitable as any version
.fi

These variablez is checked by tha find_package command ta determine whether tha configuration file serves up a aaight version. I aint talkin' bout chicken n' gravy biatch.  They is not available afta tha find_package call returns.  If tha version be aaight tha followin variablez is set:


.nf
  <package>_VERSION       = full provided version string
  <package>_VERSION_MAJOR = major version if provided, else 0
  <package>_VERSION_MINOR = minor version if provided, else 0
  <package>_VERSION_PATCH = patch version if provided, else 0
  <package>_VERSION_TWEAK = tweak version if provided, else 0
  <package>_VERSION_COUNT = number of version components, 0 ta 4
.fi

and tha correspondin package configuration file is loaded. Y'all KNOW dat shit, muthafucka!  When multiple package configuration filez is available whose version filez claim compatibilitizzle wit tha version axed it is unspecified which one is chosen. I aint talkin' bout chicken n' gravy biatch.  No attempt is made ta chizzle a highest or closest version number.


Config mode serves up a elaborate intercourse n' search procedure.  Much of tha intercourse is provided fo' completenizz n' fo' use internally by find\-modulez loaded by Module mode.  Most user code should simply call


.nf
  find_package(<package> [major[.minor]] [EXACT] [REQUIRED|QUIET])
.fi

in order ta find a package.  Package maintainers providin CMake package configuration filez is encouraged ta name n' install dem such dat tha procedure outlined below will find dem without requirin use of additionizzle options.


CMake constructs a set of possible installation prefixes fo' tha package.  Under each prefix nuff muthafuckin directories is searched fo' a cold-ass lil configuration file.  Da tablez below show tha directories searched. Y'all KNOW dat shit, muthafucka!  Each entry is meant fo' installation trees followin Windows (W), UNIX (U), or Applez (A) conventions.


.nf
  <prefix>/                                               (W)
  <prefix>/(cmake|CMake)/                                 (W)
  <prefix>/<name>*/                                       (W)
  <prefix>/<name>*/(cmake|CMake)/                         (W)
  <prefix>/(lib/<arch>|lib|share)/cmake/<name>*/          (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/                (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/(cmake|CMake)/  (U)
.fi

On systems supportin OS X Frameworks n' Application Bundlez tha followin directories is searched fo' frameworks or bundlez containin a cold-ass lil configuration file:


.nf
  <prefix>/<name>.framework/Resources/                    (A)
  <prefix>/<name>.framework/Resources/CMake/              (A)
  <prefix>/<name>.framework/Versions/*/Resources/         (A)
  <prefix>/<name>.framework/Versions/*/Resources/CMake/   (A)
  <prefix>/<name>.app/Contents/Resources/                 (A)
  <prefix>/<name>.app/Contents/Resources/CMake/           (A)
.fi

In all cases tha <name> is treated as case\-insensitizzle n' correspondz ta any of tha names specified (<package> or names given by NAMES).  Paths wit lib/<arch> is enabled if CMAKE_LIBRARY_ARCHITECTURE is set.  If PATH_SUFFIXES is specified tha suffixes is appended ta each (W) or (U) directory entry one\-by\-one.


This set of directories is intended ta work up in cooperation wit projects dat provide configuration filez up in they installation trees.  Directories above marked wit (W) is intended fo' installations on Windows where tha prefix may point all up in tha top of a applicationz installation directory.  Those marked wit (U) is intended fo' installations on UNIX platforms where tha prefix is shared by multiple packages.  This is merely a cold-ass lil convention, so all (W) n' (U) directories is still searched on all platforms.  Directories marked wit (A) is intended fo' installations on Applez platforms.  Da cmake variablez CMAKE_FIND_FRAMEWORK n' CMAKE_FIND_APPBUNDLE determine tha order of preference as specified below.


Da set of installation prefixes is constructed rockin tha followin steps.  If NO_DEFAULT_PATH is specified all NO_* options is enabled.


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <package>_DIR
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed. Y'all KNOW dat shit, muthafucka!  Path entries endin up in "/bin" or "/sbin" is automatically converted ta they parent directories.


.nf
   PATH
.fi

5. Right back up in yo muthafuckin ass. Search project build trees recently configured up in a CMake GUI.  This can be skipped if NO_CMAKE_BUILDS_PATH is passed. Y'all KNOW dat shit, muthafucka!  It be intended fo' tha case when a user is buildin multiple dependent projects one afta another.


6. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake user package registry.  This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  On UNIX platforms a <package> may step tha fuck up under tha directory


.nf
  ~/.cmake/packages/<package>
.fi

as a gangbangin' file, wit arbitrary name, whose content specifies tha directory containin tha package configuration file.  See tha export(PACKAGE) command ta create user package registry entries fo' project build trees.


7. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

8. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake system package registry.  This can be skipped if NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_LOCAL_MACHINE\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  There is no system package registry on non\-Windows platforms.


9. Right back up in yo muthafuckin ass. Search paths specified by tha PATHS option. I aint talkin' bout chicken n' gravy biatch.  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_package(<package> PATHS paths... NO_DEFAULT_PATH)
   find_package(<package>)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


Every non\-REQUIRED find_package() call can be disabled by settin tha variable CMAKE_DISABLE_FIND_PACKAGE_<package> ta TRUE. Right back up in yo muthafuckin ass. See tha documentation fo' tha CMAKE_DISABLE_FIND_PACKAGE_<package> variable fo' mo' shiznit.


When loadin a gangbangin' find module or package configuration file find_package defines variablez ta provide shiznit bout tha call arguments (and restores they original gangsta state before returning):


.nf
 <package>_FIND_REQUIRED      = legit if REQUIRED option was given
 <package>_FIND_QUIETLY       = legit if QUIET option was given
 <package>_FIND_VERSION       = full axed version string
 <package>_FIND_VERSION_MAJOR = major version if requested, else 0
 <package>_FIND_VERSION_MINOR = minor version if requested, else 0
 <package>_FIND_VERSION_PATCH = patch version if requested, else 0
 <package>_FIND_VERSION_TWEAK = tweak version if requested, else 0
 <package>_FIND_VERSION_COUNT = number of version components, 0 ta 4
 <package>_FIND_VERSION_EXACT = legit if EXACT option was given
 <package>_FIND_COMPONENTS    = list of axed components
 <package>_FIND_REQUIRED_<c>  = legit if component <c> is required
                                false if component <c> is optional
.fi

In Module mode tha loaded find module is responsible ta honor tha request detailed by these variables; peep tha find module fo' details.  In Config mode find_package handlez REQUIRED, QUIET, n' version options automatically but leaves it ta tha package configuration file ta handle components up in a way dat make sense fo' tha package.  Da package configuration file may set <package>_FOUND ta false ta tell find_package dat component requirements is not satisfied.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B find_path
Find tha directory containin a gangbangin' file.

.nf
   find_path(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_path(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_path(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' finger-lickin' directory containin tha named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha file up in a gangbangin' finger-lickin' directory is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_path is invoked wit tha same variable.  Da name of tha file up in a gangbangin' finger-lickin' directory dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_path(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_path(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When searchin fo' frameworks, if tha file is specified as A/b.h, then tha framework search will look fo' A.framework/Headers/b.h. If dat is found tha path is ghon be set ta tha path ta tha framework. CMake will convert dis ta tha erect \-F option ta include tha file. 

.TP
.B find_program
Find a executable program.

.nf
   find_program(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_program(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_program(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a program fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha program is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_program is invoked wit tha same variable.  Da name of tha program dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_PROGRAM_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_program(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_program(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B fltk_wrap_ui
Smoke FLTK user intercourses Wrappers.

.nf
  fltk_wrap_ui(resultingLibraryName source1
               source2 ... sourceN )
.fi

Produce .h n' .cxx filez fo' all tha .fl n' .fld filez listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da resultin .h n' .cxx filez is ghon be added ta a variable named resultingLibraryName_FLTK_UI_SRCS which should be added ta yo' library.

.TP
.B foreach
Evaluate a crew of commandz fo' each value up in a list.

.nf
  foreach(loop_var arg1 arg2 ...)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endforeach(loop_var)
.fi

All commandz between foreach n' tha matchin endforeach is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endforeach is evaluated, tha recorded list of commandz is invoked once fo' each argument listed up in tha original gangsta foreach command. Y'all KNOW dat shit, muthafucka!  Before each iteration of tha loop "${loop_var}" is ghon be set as a variable wit tha current value up in tha list.


.nf
  foreach(loop_var RANGE total)
  foreach(loop_var RANGE start stop [step])
.fi

Foreach can also iterate over a generated range of numbers. There is three typez of dis iteration:


* When specifyin single number, tha range gonna git elements 0 ta "total".


* When specifyin two numbers, tha range gonna git elements from tha straight-up original gangsta number ta tha second number.


* Da third optionizzle number is tha increment used ta iterate from tha straight-up original gangsta number ta tha second number.


.nf
  foreach(loop_var IN [LISTS [list1 [...]]]
                      [ITEMS [item1 [...]]])
.fi

Iterates over a precise list of items.  Da LISTS option names list\-valued variablez ta be traversed, includin empty elements (an empty strang be a zero\-length list).  Da ITEMS option endz argument parsin n' includes all arguments followin it up in tha iteration.

.TP
.B function
Start recordin a gangbangin' function fo' lata invocation as a cold-ass lil command.

.nf
  function(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endfunction(<name>)
.fi

Define a gangbangin' function named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta function yo, but before tha matchin endfunction, is not invoked until tha function is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha function is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha variable ARGC which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ARGV0 ARGV1 ARGV2 ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin functions wit optionizzle arguments fo' realz. Additionally ARGV holdz tha list of all arguments given ta tha function n' ARGN holdz tha list of arguments past tha last expected argument.


A function opens a freshly smoked up scope: peep set(var PARENT_SCOPE) fo' details.


See tha cmake_policy() command documentation fo' tha behavior of policies inside functions.

.TP
.B get_cmake_property
Git a property of tha CMake instance.

.nf
  get_cmake_property(VAR property)
.fi

Git a property from tha CMake instance.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND".  Some supported propertizzles include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, n' COMPONENTS.


See also tha mo' general get_property() command.

.TP
.B get_directory_property
Git a property of DIRECTORY scope.

.nf
  get_directory_property(<variable> [DIRECTORY <dir>] <prop\-name>)
.fi

Store a property of directory scope up in tha named variable.  If tha property aint defined tha empty\-strin is returned. Y'all KNOW dat shit, muthafucka!  Da DIRECTORY argument specifies another directory from which ta retrieve tha property value.  Da specified directory must have already been traversed by CMake.


.nf
  get_directory_property(<variable> [DIRECTORY <dir>]
                         DEFINITION <var\-name>)
.fi

Git a variable definizzle from a gangbangin' finger-lickin' directory.  This form is useful ta git a variable definizzle from another directory.


See also tha mo' general get_property() command.

.TP
.B get_filename_component
Git a specific component of a gangbangin' full filename.

.nf
  get_filename_component(<VAR> <FileName> <COMP> [CACHE])
.fi

Set <VAR> ta a cold-ass lil component of <FileName>, where <COMP> is one of:


.nf
 DIRECTORY = Directory without file name
 NAME      = File name without directory
 EXT       = File name longest extension (.b.c from d/a.b.c)
 NAME_WE   = File name without directory or longest extension
 ABSOLUTE  = Full path ta file
 REALPATH  = Full path ta existin file wit symlinks resolved
 PATH      = Legacy alias fo' DIRECTORY (use fo' CMake <= 2.8.11)
.fi

Paths is returned wit forward slashes n' have no trailin slahes. Da longest file extension be always considered. Y'all KNOW dat shit, muthafucka! If tha optionizzle CACHE argument is specified, tha result variable be added ta tha cache.


.nf
  get_filename_component(<VAR> FileName
                         PROGRAM [PROGRAM_ARGS <ARG_VAR>]
                         [CACHE])
.fi

Da program up in FileName is ghon be found up in tha system search path or left as a gangbangin' full path.  If PROGRAM_ARGS is present wit PROGRAM, then any command\-line arguments present up in tha FileName strang is split from tha program name n' stored up in <ARG_VAR>.  This is used ta separate a program name from its arguments up in a cold-ass lil command line string.

.TP
.B get_property
Git a property.

.nf
  get_property(<variable>
               <GLOBAL             |
                DIRECTORY [dir]    |
                TARGET    <target> |
                SOURCE    <source> |
                TEST      <test>   |
                CACHE     <entry>  |
                VARIABLE>
               PROPERTY <name>
               [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])
.fi

Git one property from one object up in a scope.  Da first argument specifies tha variable up in which ta store tha result.  Da second argument determines tha scope from which ta git tha property.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope must name one existin target.


SOURCE scope must name one source file.


TEST scope must name one existin test.


CACHE scope must name one cache entry.


VARIABLE scope is unique n' do not accept a name.


Da required PROPERTY option is immediately followed by tha name of tha property ta get.  If tha property aint set a empty value is returned. Y'all KNOW dat shit, muthafucka!  If tha SET option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been set.  If tha DEFINED option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been defined like fuckin wit define_property. If BRIEF_DOCS or FULL_DOCS is given then tha variable is set ta a strang containin documentation fo' tha axed property.  If documentation be axed fo' a property dat has not been defined NOTFOUND is returned.

.TP
.B get_source_file_property
Git a property fo' a source file.

.nf
  get_source_file_property(VAR file property)
.fi

Git a property from a source file.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND". Use set_source_files_propertizzles ta set property joints, n' you can put dat on yo' toast.  Source file propertizzles probably control how tha fuck tha file is built. One property dat be always there is LOCATION


See also tha mo' general get_property() command.

.TP
.B get_target_property
Git a property from a target.

.nf
  get_target_property(VAR target property)
.fi

Git a property from a target.   Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND".  Use set_target_propertizzles ta set property joints, n' you can put dat on yo' toast.  Propertizzles is probably used ta control how tha fuck a target is built yo, but some query tha target instead. Y'all KNOW dat shit, muthafucka!  This command can git propertizzles fo' any target so far pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da targets do not need ta be up in tha current CMakeLists.txt file.


See also tha mo' general get_property() command.

.TP
.B get_test_property
Git a property of tha test.

.nf
  get_test_property(test property VAR)
.fi

Git a property from tha Test.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND". For a list of standard propertizzles you can type cmake \-\-help\-property\-list


See also tha mo' general get_property() command.

.TP
.B if
Conditionally execute a crew of commands.

.nf
  if(expression)
    # then section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  elseif(expression2)
    # elseif section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  else(expression)
    # else section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endif(expression)
.fi

Evaluates tha given expression. I aint talkin' bout chicken n' gravy biatch.  If tha result is true, tha commandz up in tha THEN section is invoked. Y'all KNOW dat shit, muthafucka!  Otherwise, tha commandz up in tha else section is invoked. Y'all KNOW dat shit, muthafucka!  Da elseif n' else sections is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass may have multiple elseif clauses. Note dat tha expression up in tha else n' endif clause is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Long expressions can be used n' there be a traditionizzle order of precedence. Parenthetical expressions is evaluated first followed by unary operators like fuckin EXISTS, COMMAND, n' DEFINED. Then any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Then NOT operators n' finally AND, OR operators is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Possible expressions are:


.nf
  if(<constant>)
.fi

True if tha constant is 1, ON, YES, TRUE, Y, or a non\-zero number n' shit.  False if tha constant is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, '', or endz up in tha suffix '\-NOTFOUND'.  Named boolean constants is case\-insensitive.  If tha argument aint one of these constants, it is treated as a variable:


.nf
  if(<variable>)
.fi

True if tha variable is defined ta a value dat aint a gangbangin' false constant.  False otherwise.  (Note macro arguments is not variables.)


.nf
  if(NOT <expression>)
.fi

True if tha expression aint true.


.nf
  if(<expr1> AND <expr2>)
.fi

True if both expressions would be considered legit individually.


.nf
  if(<expr1> OR <expr2>)
.fi

True if either expression would be considered legit individually.


.nf
  if(COMMAND command\-name)
.fi

True if tha given name be a cold-ass lil command, macro or function dat can be invoked.


.nf
  if(POLICY policy\-id)
.fi

True if tha given name be a existin policy (of tha form CMP<NNNN>).


.nf
  if(TARGET target\-name)
.fi

True if tha given name be a existin target, built or imported.


.nf
  if(EXISTS file\-name)
  if(EXISTS directory\-name)
.fi

True if tha named file or directory exists, n' you can put dat on yo' toast.  Behavior is well\-defined only fo' full paths.


.nf
  if(file1 IS_NEWER_THAN file2)
.fi

True if file1 is newer than file2 or if one of tha two filez don't exist. Behavior is well\-defined only fo' full paths. If tha file time stamps is exactly tha same, a IS_NEWER_THAN comparison returns true, so dat any dependent build operations will occur up in tha event of a tie. This includes tha case of passin tha same file name fo' both file1 n' file2.


.nf
  if(IS_DIRECTORY directory\-name)
.fi

True if tha given name be a gangbangin' finger-lickin' directory.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_SYMLINK file\-name)
.fi

True if tha given name be a symbolic link.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_ABSOLUTE path)
.fi

True if tha given path be a absolute path.


.nf
  if(<variable|string> MATCHES regex)
.fi

True if tha given strang or variablez value matches tha given regular expression.


.nf
  if(<variable|string> LESS <variable|string>)
  if(<variable|string> GREATER <variable|string>)
  if(<variable|string> EQUAL <variable|string>)
.fi

True if tha given strang or variablez value be a valid number n' tha inequalitizzle or equalitizzle is true.


.nf
  if(<variable|string> STRLESS <variable|string>)
  if(<variable|string> STRGREATER <variable|string>)
  if(<variable|string> STREQUAL <variable|string>)
.fi

True if tha given strang or variablez value is lexicographically less (or pimped outer, or equal) than tha strang or variable on tha right.


.nf
  if(<variable|string> VERSION_LESS <variable|string>)
  if(<variable|string> VERSION_EQUAL <variable|string>)
  if(<variable|string> VERSION_GREATER <variable|string>)
.fi

Component\-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]]).


.nf
  if(DEFINED <variable>)
.fi

True if tha given variable is defined. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do not matta if tha variable is legit or false just if it has been set.


.nf
  if((expression) AND (expression OR (expression)))
.fi

Da expressions inside tha parenthesis is evaluated first n' then tha remainin expression is evaluated as up in tha previous examples. Where there be nested parenthesis tha innermost is evaluated as part of evaluatin tha expression dat gotz nuff em.


Da if command was freestyled straight-up early up in CMakez history, prepimpin tha ${} variable evaluation syntax, n' fo' convenience evaluates variablez named by its arguments as shown up in tha above signatures.  Note dat aiiight variable evaluation wit ${} applies before tha if command even receives tha arguments, n' you can put dat on yo' toast.  Therefore code like


.nf
  set(var1 OFF)
  set(var2 "var1")
  if(${var2})
.fi

appears ta tha if command as


.nf
  if(var1)
.fi

and is evaluated accordin ta tha if(<variable>) case documented above.  Da result is OFF which is false.  But fuck dat shiznit yo, tha word on tha street is dat if we remove tha ${} from tha example then tha command sees


.nf
  if(var2)
.fi

which is legit cuz var2 is defined ta "var1" which aint a gangbangin' false constant.


Automatic evaluation applies up in tha other cases whenever tha above\-documented signature accepts <variable|string>:


1) Da left hand argument ta MATCHES is first checked ta peep if it aint nuthin but a thugged-out defined variable, if so tha variablez value is used, otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


2) If tha left hand argument ta MATCHES is missin it returns false without error 


3) Both left n' right hand arguments ta LESS GREATER EQUAL is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


4) Both left n' right hand arguments ta STRLESS STREQUAL STRGREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


5) Both left n' right hand argumemnts ta VERSION_LESS VERSION_EQUAL VERSION_GREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


6) Da right hand argument ta NOT is tested ta peep if it aint nuthin but a funky-ass boolean constant, if so tha value is used, otherwise it be assumed ta be a variable n' it is dereferenced. Y'all KNOW dat shit, muthafucka! 


7) Da left n' right hand arguments ta AND OR is independently tested ta peep if they is boolean constants, if so they is used as such, otherwise they is assumed ta be variablez n' is dereferenced. Y'all KNOW dat shit, muthafucka! 


.TP
.B include
Load n' run CMake code from a gangbangin' file or module.

.nf
  include(<file|module> [OPTIONAL] [RESULT_VARIABLE <VAR>]
                        [NO_POLICY_SCOPE])
.fi

Load n' run CMake code from tha file given. I aint talkin' bout chicken n' gravy biatch.  Variable readz n' writes access tha scope of tha calla (dynamic scoping).  If OPTIONAL is present, then no error is raised if tha file do not exist.  If RESULT_VARIABLE is given tha variable is ghon be set ta tha full filename which has been included or NOTFOUND if it failed.


If a module is specified instead of a gangbangin' file, tha file wit name <modulename>.cmake is searched first up in CMAKE_MODULE_PATH, then up in tha CMake module directory. There is one exception ta this: if tha file which calls include() is located itself up in tha CMake module directory, then first tha CMake module directory is searched n' CMAKE_MODULE_PATH afterwards. Right back up in yo muthafuckin ass. See also policy CMP0017.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B include_directories
Add include directories ta tha build.

.nf
  include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)
.fi

Add tha given directories ta dem tha compila uses ta search fo' include files.  Relatizzle paths is interpreted as relatizzle ta tha current source directory. 


Da include directories is added ta tha directory property INCLUDE_DIRECTORIES fo' tha current CMakeLists file. They is also added ta tha target property INCLUDE_DIRECTORIES fo' each target up in tha current CMakeLists file. Da target property joints is tha ones used by tha generators.


By default tha directories is appended onto tha current list of directories. Put ya muthafuckin choppers up if ya feel dis! This default behavior can be chizzled by settin CMAKE_INCLUDE_DIRECTORIES_BEFORE ta ON. By rockin AFTER or BEFORE explicitly, you can select between appendin n' prepending, independent of tha default. 


If tha SYSTEM option is given, tha compila is ghon be holla'd all up in tha directories is meant as system include directories on some platforms (signallin dis settin might big up effects like fuckin tha compila skippin warnings, or these fixed\-install system filez not bein considered up in dependency calculations \- peep compila docs).

.TP
.B include_external_msproject
Include a external Microsizzlez project file up in a workspace.

.nf
  include_external_msproject(projectname location
                             [TYPE projectTypeGUID]
                             [GUID projectGUID]
                             [PLATFORM platformName]
                             dep1 dep2 ...)
.fi

Includes a external Microsizzlez project up in tha generated workspace file.  Currently do not a god damn thang on UNIX. This will create a target named [projectname].  This can be used up in tha add_dependencies command ta make thangs depend on tha external project.


TYPE, GUID n' PLATFORM is optionizzle parametas dat allow one ta specify tha type of project, id (GUID) of tha project n' tha name of tha target platform.  This is useful fo' projects requirin joints other than tha default (e.g. WIX projects). These options is not supported by tha Visual Studio 6 generator.

.TP
.B include_regular_expression
Set tha regular expression used fo' dependency checking.

.nf
  include_regular_expression(regex_match [regex_complain])
.fi

Set tha regular expressions used up in dependency checking.  Only filez matchin regex_match is ghon be traced as dependencies. Put ya muthafuckin choppers up if ya feel dis!  Only filez matchin regex_diss will generate warnings if they cannot be found (standard header paths is not searched).  Da defaults are:


.nf
  regex_match    = "^.*$" (match every last muthafuckin thang)
  regex_diss = "^$" (match empty strang only)
.fi

.TP
.B install
Specify rulez ta run at install time.

This command generates installation rulez fo' a project.  Rulez specified by calls ta dis command within a source directory is executed up in order durin installation. I aint talkin' bout chicken n' gravy biatch.  Da order across directories aint defined.


There is multiple signatures fo' dis command. Y'all KNOW dat shit, muthafucka!  Some of dem define installation propertizzles fo' filez n' targets, n' you can put dat on yo' toast.  Propertizzles common ta multiple signatures is covered here but they is valid only fo' signatures dat specify em.


DESTINATION arguments specify tha directory on disk ta which a gangbangin' file is ghon be installed. Y'all KNOW dat shit, muthafucka!  If a gangbangin' full path (with a leadin slash or drive letter) is given it is used directly.  If a relatizzle path is given it is interpreted relatizzle ta tha value of CMAKE_INSTALL_PREFIX. Da prefix can be relocated at install time rockin DESTDIR mechanizzle explained up in tha CMAKE_INSTALL_PREFIX variable documentation.


PERMISSIONS arguments specify permissions fo' installed files.  Valid permissions is OWNER_READ, OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, n' SETGID.  Permissions dat do not make sense on certain platforms is ignored on dem platforms.


Da CONFIGURATIONS argument specifies a list of build configurations fo' which tha install rule applies (Debug, Release, etc.).


Da COMPONENT argument specifies a installation component name wit which tha install rule be associated, like fuckin "runtime" or "development".  Durin component\-specific installation only install rulez associated wit tha given component name is ghon be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Durin a gangbangin' full installation all components is installed. Y'all KNOW dat shit, muthafucka! If COMPONENT aint provided a thugged-out default component "Unspecified" is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da default component name may be controlled wit tha CMAKE_INSTALL_DEFAULT_COMPONENT_NAME variable.


Da RENAME argument specifies a name fo' a installed file dat may be different from tha original gangsta file.  Renamin be allowed only when a single file is installed by tha command.


Da OPTIONAL argument specifies dat it aint a error if tha file ta be installed do not exist.  


Da TARGETS signature:


.nf
  install(TARGETS targets... [EXPORT <export\-name>]
          [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
            PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
           [DESTINATION <dir>]
           [INCLUDES DESTINATION [<dir> ...]]
           [PERMISSIONS permissions...]
           [CONFIGURATIONS [Debug|Release|...]]
           [COMPONENT <component>]
           [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
          ] [...])
.fi

Da TARGETS form specifies rulez fo' installin targets from a project.  There is five kindz of target filez dat may be installed: ARCHIVE, LIBRARY, RUNTIME, FRAMEWORK, n' BUNDLE.  Executablez is treated as RUNTIME targets, except dat dem marked wit tha MACOSX_BUNDLE property is treated as BUNDLE targets on OS X. Right back up in yo muthafuckin ass. Static libraries is always treated as ARCHIVE targets, n' you can put dat on yo' toast. Module libraries is always treated as LIBRARY targets, n' you can put dat on yo' toast. For non\-DLL platforms shared libraries is treated as LIBRARY targets, except dat dem marked wit tha FRAMEWORK property is treated as FRAMEWORK targets on OS X.  For DLL platforms tha DLL part of a gangbangin' finger-lickin' dirty-ass shared library is treated as a RUNTIME target n' tha correspondin import library is treated as a ARCHIVE target fo' realz. All Windows\-based systems includin Cygwin is DLL platforms. Da ARCHIVE, LIBRARY, RUNTIME, n' FRAMEWORK arguments chizzle tha type of target ta which tha subsequent propertizzles apply.  If none is given tha installation propertizzles apply ta all target types.  If only one is given then only targetz of dat type is ghon be installed (which can be used ta install just a DLL or just a import library).Da INCLUDES DESTINATION specifies a list of directories which is ghon be added ta tha INTERFACE_INCLUDE_DIRECTORIES of tha <targets> when exported by install(EXPORT).  If a relatizzle path is specified, it is treated as relatizzle ta tha $<INSTALL_PREFIX>.


Da PRIVATE_HEADER, PUBLIC_HEADER, n' RESOURCE arguments cause subsequent propertizzles ta be applied ta installin a FRAMEWORK shared library targetz associated filez on non\-Applez platforms.  Rulez defined by these arguments is ignored on Applez platforms cuz tha associated filez is installed tha fuck into tha appropriate locations inside tha framework folda n' shit.  See documentation of tha PRIVATE_HEADER, PUBLIC_HEADER, n' RESOURCE target propertizzles fo' details.


Either NAMELINK_ONLY or NAMELINK_SKIP may be specified as a LIBRARY option. I aint talkin' bout chicken n' gravy biatch.  On some platforms a versioned shared library has a symbolic link such as


.nf
  lib<name>.so \-> lib<name>.so.1
.fi

where "lib<name>.so.1" is tha soname of tha library n' "lib<name>.so" be a "namelink" allowin linkers ta find tha library when given "\-l<name>".  Da NAMELINK_ONLY option causes installation of only tha namelink when a library target is installed. Y'all KNOW dat shit, muthafucka!  Da NAMELINK_SKIP option causes installation of library filez other than tha namelink when a library target is installed. Y'all KNOW dat shit, muthafucka!  When neither option is given both portions is installed. Y'all KNOW dat shit, muthafucka!  On platforms where versioned shared libraries aint gots namelinks or when a library aint versioned tha NAMELINK_SKIP option installs tha library n' tha NAMELINK_ONLY option installs nothing.  See tha VERSION n' SOVERSION target propertizzles fo' details on bustin versioned shared libraries.


One or mo' crewz of propertizzles may be specified up in a single call ta tha TARGETS form of dis command. Y'all KNOW dat shit, muthafucka!  A target may be installed mo' than once ta different locations.  Consider hypothetical targets "myExe", "mySharedLib", n' "myStaticLib".  Da code


.nf
    install(TARGETS myExe mySharedLib myStaticLib
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib/static)
    install(TARGETS mySharedLib DESTINATION /some/full/path)
.fi

will install myExe ta <prefix>/bin n' myStaticLib ta <prefix>/lib/static.  On non\-DLL platforms mySharedLib is ghon be installed ta <prefix>/lib n' /some/full/path.  On DLL platforms tha mySharedLib DLL is ghon be installed ta <prefix>/bin n' /some/full/path n' its import library is ghon be installed ta <prefix>/lib/static n' /some/full/path.


Da EXPORT option associates tha installed target filez wit a export called <export\-name>.  It must step tha fuck up before any RUNTIME, LIBRARY, or ARCHIVE options.  To straight-up install tha export file itself, call install(EXPORT).  See documentation of tha install(EXPORT ...) signature below fo' details.


Installin a target wit EXCLUDE_FROM_ALL set ta legit has undefined behavior.


Da FILES signature:


.nf
  install(FILES files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])
.fi

Da FILES form specifies rulez fo' installin filez fo' a project.  File names given as relatizzle paths is interpreted wit respect ta tha current source directory.  Filez installed by dis form is by default given permissions OWNER_WRITE, OWNER_READ, GROUP_READ, n' WORLD_READ if no PERMISSIONS argument is given.


Da PROGRAMS signature:


.nf
  install(PROGRAMS files... DESTINATION <dir>
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>]
          [RENAME <name>] [OPTIONAL])
.fi

Da PROGRAMS form is identical ta tha FILES form except dat tha default permissions fo' tha installed file also include OWNER_EXECUTE, GROUP_EXECUTE, n' WORLD_EXECUTE.  This form is intended ta install programs dat is not targets, like fuckin shell scripts, n' you can put dat on yo' toast.  Use tha TARGETS form ta install targets built within tha project.


Da DIRECTORY signature:


.nf
  install(DIRECTORY dirs... DESTINATION <dir>
          [FILE_PERMISSIONS permissions...]
          [DIRECTORY_PERMISSIONS permissions...]
          [USE_SOURCE_PERMISSIONS] [OPTIONAL]
          [CONFIGURATIONS [Debug|Release|...]]
          [COMPONENT <component>] [FILES_MATCHING]
          [[PATTERN <pattern> | REGEX <regex>]
           [EXCLUDE] [PERMISSIONS permissions...]] [...])
.fi

Da DIRECTORY form installs contentz of one or mo' directories ta a given destination. I aint talkin' bout chicken n' gravy biatch.  Da directory structure is copied verbatim ta tha destination. I aint talkin' bout chicken n' gravy biatch.  Da last component of each directory name be appended ta tha destination directory but a trailin slash may be used ta avoid dis cuz it leaves tha last component empty.  Directory names given as relatizzle paths is interpreted wit respect ta tha current source directory.  If no input directory names is given tha destination directory is ghon be pimped but not a god damn thang is ghon be installed tha fuck into dat shit.  Da FILE_PERMISSIONS n' DIRECTORY_PERMISSIONS options specify permissions given ta filez n' directories up in tha destination. I aint talkin' bout chicken n' gravy biatch.  If USE_SOURCE_PERMISSIONS is specified n' FILE_PERMISSIONS is not, file permissions is ghon be copied from tha source directory structure.  If no permissions is specified filez is ghon be given tha default permissions specified up in tha FILES form of tha command, n' tha directories is ghon be given tha default permissions specified up in tha PROGRAMS form of tha command.


Installation of directories may be controlled wit fine granularitizzle rockin tha PATTERN or REGEX options.  These "match" options specify a globbin pattern or regular expression ta match directories or filez encountered within input directories. Put ya muthafuckin choppers up if ya feel dis!  They may be used ta apply certain options (see below) ta a subset of tha filez n' directories encountered. Y'all KNOW dat shit, muthafucka!  Da full path ta each input file or directory (with forward slashes) is matched against tha expression. I aint talkin' bout chicken n' gravy biatch.  A PATTERN will match only complete file names: tha portion of tha full path matchin tha pattern must occur all up in tha end of tha file name n' be preceded by a slash.  A REGEX will match any portion of tha full path but it may use '/' n' '$' ta simulate tha PATTERN behavior. Shiiit, dis aint no joke.  By default all filez n' directories is installed whether or not they is matched. Y'all KNOW dat shit, muthafucka!  Da FILES_MATCHING option may be given before tha straight-up original gangsta match option ta disable installation of filez (but not directories) not matched by any expression. I aint talkin' bout chicken n' gravy biatch.  For example, tha code


.nf
  install(DIRECTORY src/ DESTINATION include/myproj
          FILES_MATCHING PATTERN "*.h")
.fi

will extract n' install header filez from a source tree.


Some options may follow a PATTERN or REGEX expression n' is applied only ta filez or directories matchin em.  Da EXCLUDE option will skip tha matched file or directory.  Da PERMISSIONS option overrides tha permissions settin fo' tha matched file or directory.  For example tha code


.nf
  install(DIRECTORY icons scripts/ DESTINATION share/myproj
          PATTERN "CVS" EXCLUDE
          PATTERN "scripts/*"
          PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                      GROUP_EXECUTE GROUP_READ)
.fi

will install tha icons directory ta share/myproj/icons n' tha scripts directory ta share/myproj.  Da icons will git default file permissions, tha scripts is ghon be given specific permissions, n' any CVS directories is ghon be excluded.


Da SCRIPT n' CODE signature:


.nf
  install([[SCRIPT <file>] [CODE <code>]] [...])
.fi

Da SCRIPT form will invoke tha given CMake script filez durin installation. I aint talkin' bout chicken n' gravy biatch.  If tha script file name be a relatizzle path it is ghon be interpreted wit respect ta tha current source directory.  Da CODE form will invoke tha given CMake code durin installation. I aint talkin' bout chicken n' gravy biatch.  Code is specified as a single argument inside a thugged-out double\-quoted string. For example, tha code


.nf
  install(CODE "MESSAGE(\\"Sample install message.\\")")
.fi

will print a message durin installation.


Da EXPORT signature:


.nf
  install(EXPORT <export\-name> DESTINATION <dir>
          [NAMESPACE <namespace>] [FILE <name>.cmake]
          [PERMISSIONS permissions...]
          [CONFIGURATIONS [Debug|Release|...]]
          [EXPORT_LINK_INTERFACE_LIBRARIES]
          [COMPONENT <component>])
.fi

Da EXPORT form generates n' installs a CMake file containin code ta import targets from tha installation tree tha fuck into another project.  Target installations is associated wit tha export <export\-name> rockin tha EXPORT option of tha install(TARGETS ...) signature documented above.  Da NAMESPACE option will prepend <namespace> ta tha target names as they is freestyled ta tha import file.  By default tha generated file is ghon be called <export\-name>.cmake but tha FILE option may be used ta specify a gangbangin' finger-lickin' different name.  Da value given ta tha FILE option must be a gangbangin' file name wit tha ".cmake" extension. I aint talkin' bout chicken n' gravy biatch.  If a CONFIGURATIONS option is given then tha file will only be installed when one of tha named configurations is installed. Y'all KNOW dat shit, muthafucka!  Additionally, tha generated import file will reference only tha matchin target configurations.  Da EXPORT_LINK_INTERFACE_LIBRARIES keyword, if present, causes tha contentz of tha propertizzles matchin (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_<CONFIG>)? ta be exported, when policy CMP0022 is NEW.  If a COMPONENT option is specified dat do not match dat given ta tha targets associated wit <export\-name> tha behavior is undefined. Y'all KNOW dat shit, muthafucka!  If a library target is included up in tha export but a target ta which it links aint included tha behavior is unspecified.


Da EXPORT form is useful ta help outside projects use targets built n' installed by tha current project.  For example, tha code


.nf
  install(TARGETS myexe EXPORT myproj DESTINATION bin)
  install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
.fi

will install tha executable myexe ta <prefix>/bin n' code ta import it up in tha file "<prefix>/lib/myproj/myproj.cmake".  An outside project may load dis file wit tha include command n' reference tha myexe executable from tha installation tree rockin tha imported target name mp_myexe as if tha target was built up in its own tree.


NOTE: This command supercedes tha INSTALL_TARGETS command n' tha target propertizzles PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT.  It also replaces tha FILES formz of tha INSTALL_FILES n' INSTALL_PROGRAMS commands.  Da processin order of these install rulez relatizzle ta dem generated by INSTALL_TARGETS, INSTALL_FILES, n' INSTALL_PROGRAMS commandz aint defined.


.TP
.B link_directories
Specify directories up in which tha linker will look fo' libraries.

.nf
  link_directories(directory1 directory2 ...)
.fi

Specify tha paths up in which tha linker should search fo' libraries. Put ya muthafuckin choppers up if ya feel dis! Da command will apply only ta targets pimped afta it is called. Y'all KNOW dat shit, muthafucka! Relatizzle paths given ta dis command is interpreted as relatizzle ta tha current source directory, peep CMP0015. 


Note dat dis command is rarely necessary.  Library locations returned by find_package() n' find_library() is absolute paths.  Pass these absolute library file paths directly ta tha target_link_libraries() command. Y'all KNOW dat shit, muthafucka!  CMake will ensure tha linker findz em.

.TP
.B list
List operations.

.nf
  list(LENGTH <list> <output variable>)
  list(GET <list> <element index> [<element index> ...]
       <output variable>)
  list(APPEND <list> <element> [<element> ...])
  list(FIND <list> <value> <output variable>)
  list(INSERT <list> <element_index> <element> [<element> ...])
  list(REMOVE_ITEM <list> <value> [<value> ...])
  list(REMOVE_AT <list> <index> [<index> ...])
  list(REMOVE_DUPLICATES <list>)
  list(REVERSE <list>)
  list(SORT <list>)
.fi

LENGTH will return a given listz length.


GET will return list of elements specified by indices from tha list.


APPEND will append elements ta tha list.


FIND will return tha index of tha element specified up in tha list or \-1 if it wasn't found.


INSERT will bang elements ta tha list ta tha specified location.


REMOVE_AT n' REMOVE_ITEM will remove shit from tha list. Da difference is dat REMOVE_ITEM will remove tha given items, while REMOVE_AT will remove tha shit all up in tha given indices.


REMOVE_DUPLICATES will remove duplicated shit up in tha list.


REVERSE reverses tha contentz of tha list in\-place.


SORT sorts tha list in\-place alphabetically.


Da list subcommandz APPEND, INSERT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE n' SORT may create freshly smoked up joints fo' tha list within tha current CMake variable scope. Right back up in yo muthafuckin ass. Similar ta tha SET command, tha LIST command creates freshly smoked up variable joints up in tha current scope, even if tha list itself is straight-up defined up in a parent scope. To propagate tha thangs up in dis biatch of these operations upwards, use SET wit PARENT_SCOPE, SET wit CACHE INTERNAL, or some other meanz of value propagation.


NOTES: A list up in cmake be a ; separated crew of strings. To create a list tha set command can be used. Y'all KNOW dat shit, muthafucka! For example, set(var a funky-ass b c d e)  creates a list wit a;b;c;d;e, n' set(var "a b c d e") creates a strang or a list wit one item up in dat shit.


When specifyin index joints, if <element index> is 0 or pimped outer, it is indexed from tha beginnin of tha list, wit 0 representin tha straight-up original gangsta list element. If <element index> is \-1 or lesser, it is indexed from tha end of tha list, wit \-1 representin tha last list element. Be careful when countin wit wack indices: they do not start from 0. \-0 is equivalent ta 0, tha straight-up original gangsta list element.


.TP
.B load_cache
Load up in tha joints from another projectz CMake cache.

.nf
  load_cache(pathToCacheFile READ_WITH_PREFIX
             prefix entry1...)
.fi

Read tha cache n' store tha axed entries up in variablez wit they name prefixed wit tha given prefix.  This only readz tha joints, n' do not create entries up in tha local projectz cache.


.nf
  load_cache(pathToCacheFile [EXCLUDE entry1...]
             [INCLUDE_INTERNALS entry1...])
.fi

Load up in tha joints from another cache n' store dem up in tha local projectz cache as internal entries. Put ya muthafuckin choppers up if ya feel dis!  This is useful fo' a project dat dependz on another project built up in a gangbangin' finger-lickin' different tree.  EXCLUDE option can be used ta provide a list of entries ta be excluded. Y'all KNOW dat shit, muthafucka!  INCLUDE_INTERNALS can be used ta provide a list of internal entries ta be included. Y'all KNOW dat shit, muthafucka!  Normally, no internal entries is brought in. I aint talkin' bout chicken n' gravy biatch.  Use of dis form of tha command is straight fuckin discouraged yo, but it is provided fo' backward compatibility.

.TP
.B load_command
Load a cold-ass lil command tha fuck into a hustlin CMake.

.nf
  load_command(COMMAND_NAME <loc1> [loc2 ...])
.fi

Da given locations is searched fo' a library whose name is cmCOMMAND_NAME.  If found, it is loaded as a module n' tha command be added ta tha set of available CMake commands.  Usually, TRY_COMPILE is used before dis command ta compile tha module. If tha command is successfully loaded a variable named


.nf
  CMAKE_LOADED_COMMAND_<COMMAND_NAME>
.fi

will be set ta tha full path of tha module dat was loaded. Y'all KNOW dat shit, muthafucka!  Otherwise tha variable aint gonna be set.

.TP
.B macro
Start recordin a macro fo' lata invocation as a cold-ass lil command.

.nf
  macro(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endmacro(<name>)
.fi

Define a macro named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta macro yo, but before tha matchin endmacro, is not invoked until tha macro is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha macro is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha joints ${ARGC} which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ${ARGV0} ${ARGV1} ${ARGV2} ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin macros wit optionizzle arguments fo' realz. Additionally ${ARGV} holdz tha list of all arguments given ta tha macro n' ${ARGN} holdz tha list of arguments past tha last expected argument. Note dat tha parametas ta a macro n' joints like fuckin ARGN is not variablez up in tha usual CMake sense. They is strang replacements much like tha C preprocessor would do wit a macro. If you want legit CMake variablez and/or betta CMake scope control you should peep tha function command.


See tha cmake_policy() command documentation fo' tha behavior of policies inside macros.

.TP
.B mark_as_advanced
Mark cmake cached variablez as advanced.

.nf
  mark_as_advanced([CLEAR|FORCE] VAR VAR2 VAR...)
.fi

Mark tha named cached variablez as advanced. Y'all KNOW dat shit, muthafucka!  An advanced variable aint gonna be displayed up in any of tha cmake GUIs unless tha show advanced option is on. I aint talkin' bout chicken n' gravy biatch.  If CLEAR is tha straight-up original gangsta argument advanced variablez is chizzled back ta unadvanced. Y'all KNOW dat shit, muthafucka!  If FORCE is tha straight-up original gangsta argument, then tha variable is made advanced. Y'all KNOW dat shit, muthafucka!  If neither FORCE nor CLEAR is specified, freshly smoked up joints is ghon be marked as advanced yo, but if tha variable already has a advanced/non\-advanced state, it aint gonna be chizzled.


It do not a god damn thang up in script mode.

.TP
.B math
Mathematical expressions.

.nf
  math(EXPR <output variable> <math expression>)
.fi

EXPR evaluates mathematical expression n' returns result up in tha output variable. Example mathematical expression is '5 * ( 10 + 13 )'.  Supported operators is + \- * / % | & ^ ~ << >> * / %.  They have tha same meanin  as they do up in C code.

.TP
.B message
Display a message ta tha user.

.nf
  message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
          "message ta display" ...)
.fi

Da optionizzle keyword determines tha type of message:


.nf
  (none)         = Important shiznit
  STATUS         = Incidental shiznit
  WARNING        = CMake Warning, continue processing
  AUTHOR_WARNING = CMake Warnin (dev), continue processing
  SEND_ERROR     = CMake Error, continue processing,
                                but skip generation
  FATAL_ERROR    = CMake Error, stop processin n' generation
.fi

Da CMake command\-line tool displays STATUS lyrics on stdout n' all other message types on stderr. Shiiit, dis aint no joke.  Da CMake GUI displays all lyrics up in its log area.  Da interactizzle dialogs (ccmake n' CMakeSetup) show STATUS lyrics one at a time on a status line n' other lyrics up in interactizzle pop\-up boxes.


CMake Warnin n' Error message text displays rockin a simple markup language.  Non\-indented text is formatted up in line\-wrapped paragraphs delimited by newlines.  Indented text is considered pre\-formatted.

.TP
.B option
Provides a option dat tha user can optionally select.

.nf
  option(<option_variable> "help strang describin option"
         [initial value])
.fi

Provide a option fo' tha user ta select as ON or OFF.  If no initial value is provided, OFF is used.


If you have options dat depend on tha jointz of other options, peep tha module help fo' CMakeDependentOption.

.TP
.B project
Set a name fo' tha entire project.

.nf
  project(<projectname> [languageName1 languageName2 ... ] )
.fi

Sets tha name of tha project.  Additionally dis sets tha variablez <projectName>_BINARY_DIR n' <projectName>_SOURCE_DIR ta tha respectizzle joints.


Optionally you can specify which languages yo' project supports, n' you can put dat on yo' toast.  Example languages is CXX (i.e. C++), C, Fortran, etc. By default C n' CXX is enabled. Y'all KNOW dat shit, muthafucka!  E.g. if you aint gots a C++ compiler, you can disable tha check fo' it by explicitly listin tha languages you wanna support, e.g. C.  By rockin tha special language "NONE" all checks fo' any language can be disabled. Y'all KNOW dat shit, muthafucka! If a variable exists called CMAKE_PROJECT_<projectName>_INCLUDE, tha file pointed ta by dat variable is ghon be included as tha last step of tha project command.


Da top\-level CMakeLists.txt file fo' a project must contain a literal, direct call ta tha project() command; loadin one all up in tha include() command aint sufficient.  If no such call exists CMake will implicitly add one ta tha top dat enablez tha default languages (C n' CXX).

.TP
.B qt_wrap_cpp
Smoke Qt Wrappers.

.nf
  qt_wrap_cpp(resultingLibraryName DestName
              SourceLists ...)
.fi

Produce moc filez fo' all tha .h filez listed up in tha SourceLists, n' you can put dat on yo' toast.  Da moc filez is ghon be added ta tha library rockin tha DestName source list.

.TP
.B qt_wrap_ui
Smoke Qt user intercourses Wrappers.

.nf
  qt_wrap_ui(resultingLibraryName HeadersDestName
             SourcesDestName SourceLists ...)
.fi

Produce .h n' .cxx filez fo' all tha .ui filez listed up in tha SourceLists, n' you can put dat on yo' toast.  Da .h filez is ghon be added ta tha library rockin tha HeadersDestNamesource list.  Da .cxx filez is ghon be added ta tha library rockin tha SourcesDestNamesource list.

.TP
.B remove_definitions
Removes \-D define flags added by add_definitions.

.nf
  remove_definitions(\-DFOO \-DBAR ...)
.fi

Removes flags (added by add_definitions) from tha compila command line fo' sources up in tha current directory n' below.

.TP
.B return
Return from a gangbangin' file, directory or function.

.nf
  return()
.fi

Returns from a gangbangin' file, directory or function. I aint talkin' bout chicken n' gravy biatch. When dis command is encountered up in a included file (via include() or find_package()), it causes processin of tha current file ta stop n' control is moonwalked back ta tha includin file. If it is encountered up in a gangbangin' file which aint included by another file, e.g. a CMakeLists.txt, control is moonwalked back ta tha parent directory if there is one. If return is called up in a gangbangin' function, control is moonwalked back ta tha calla of tha function. I aint talkin' bout chicken n' gravy biatch. Note dat a macro aint a gangbangin' function n' do not handle return like a gangbangin' function do.

.TP
.B separate_arguments
Parse space\-separated arguments tha fuck into a semicolon\-separated list.

.nf
  separate_arguments(<var> <UNIX|WINDOWS>_COMMAND "<args>")
.fi

Parses a unix\- or windows\-style command\-line strang "<args>" n' stores a semicolon\-separated list of tha arguments up in <var>.  Da entire command line must be given up in one "<args>" argument.


Da UNIX_COMMAND mode separates arguments by unquoted whitespace.  It recognizes both single\-quote n' double\-quote pairs.  A backslash escapes tha next literal characta (\\" is "); there be no special escapes (\\n is just n).


Da WINDOWS_COMMAND mode parses a windows command\-line rockin tha same syntax tha runtime library uses ta construct argv at startup.  It separates arguments by whitespace dat aint double\-quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Backslashes is literal unless they precede double\-quotes.  See tha MSDN article "Parsin C Command\-Line Arguments" fo' details.


.nf
  separate_arguments(VARIABLE)
.fi

Convert tha value of VARIABLE ta a semi\-colon separated list.  All spaces is replaced wit ';'.  This helps wit generatin command lines.

.TP
.B set
Set a CMake, cache or environment variable ta a given value.

.nf
  set(<variable> <value>
      [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
.fi

Within CMake sets <variable> ta tha value <value>.  <value> is expanded before <variable> is set ta dat shit.  Normally, set will set a regular CMake variable. If CACHE is present, then tha <variable> is put up in tha cache instead, unless it be already up in tha cache. Right back up in yo muthafuckin ass. See section 'Variable types up in CMake' below fo' detailz of regular n' cache variablez n' they interactions. If CACHE is used, <type> n' <docstring> is required. Y'all KNOW dat shit, muthafucka! <type> is used by tha CMake GUI ta chizzle a widget wit which tha user sets a value. Da value fo' <type> may be one of


.nf
  FILEPATH = File chizzla dialog.
  PATH     = Directory chizzla dialog.
  STRING   = Arbitrary string.
  BOOL     = Boolean ON/OFF checkbox.
  INTERNAL = No GUI entry (used fo' persistent variables).
.fi

If <type> is INTERNAL, tha cache variable is marked as internal, n' aint gonna be shown ta tha user up in tools like cmake\-gui. This is intended fo' joints dat should be persisted up in tha cache yo, but which playas should not normally chizzle. INTERNAL implies FORCE.


Normally, set(...CACHE...) creates cache variablez yo, but do not modify em. If FORCE is specified, tha value of tha cache variable is set, even if tha variable be already up in tha cache. This should normally be avoided, as it will remove any chizzlez ta tha cache variablez value by tha user.


If PARENT_SCOPE is present, tha variable is ghon be set up in tha scope above tha current scope. Each freshly smoked up directory or function creates a freshly smoked up scope. This command will set tha value of a variable tha fuck into tha parent directory or callin function (whichever be applicable ta tha case at hand). PARENT_SCOPE cannot be combined wit CACHE.


If <value> aint specified then tha variable is removed instead of set.  See also: tha unset() command.


.nf
  set(<variable> <value1> ... <valueN>)
.fi

In dis case <variable> is set ta a semicolon separated list of joints.


<variable> can be a environment variable such as:


.nf
  set( ENV{PATH} /home/martink )
.fi

in which case tha environment variable is ghon be set.


*** Variable types up in CMake ***


In CMake there be two typez of variables: aiiight variablez n' cache variables. Normal variablez is meant fo' tha internal use of tha script (just like variablez up in most programmin languages); they is not persisted across CMake runs. Cache variablez (unless set wit INTERNAL) is mostly intended fo' configuration settings where tha straight-up original gangsta CMake run determines a suitable default value, which tha user can then override, by editin tha cache wit tools like fuckin ccmake or cmake\-gui. Cache variablez is stored up in tha CMake cache file, n' is persisted across CMake runs. 


Both types can exist all up in tha same time wit tha same name but different joints, n' you can put dat on yo' toast. When ${FOO} is evaluated, CMake first looks fo' a aiiight variable 'FOO' up in scope n' uses it if set. If n' only if no aiiight variable exists then it falls back ta tha cache variable 'FOO'.


Some examples:


Da code 'set(FOO "x")' sets tha aiiight variable 'FOO'. Well shiiiit, it do not bust a nut on tha cache yo, but it will hide any existin cache value 'FOO'.


Da code 'set(FOO "x" CACHE ...)' checks fo' 'FOO' up in tha cache, ignorin any aiiight variable of tha same name. If 'FOO' is up in tha cache then not a god damn thang happens ta either tha aiiight variable or tha cache variable. If 'FOO' aint up in tha cache, then it be added ta tha cache.


Finally, whenever a cold-ass lil cache variable be added or modified by a cold-ass lil command, CMake also *removes* tha aiiight variable of tha same name from tha current scope so dat a immediately followin evaluation of it will expose tha newly cached value.


Normally projects should avoid rockin aiiight n' cache variablez of tha same name, as dis interaction can be hard ta follow. But fuck dat shiznit yo, tha word on tha street is dat up in some thangs it can be useful naaahhmean? One example (used by some projects):


A project has a subproject up in its source tree. Da lil pimp project has its own CMakeLists.txt, which is included from tha parent CMakeLists.txt rockin add_subdirectory(). Now, if tha parent n' tha lil pimp project provide tha same option (for example a cold-ass lil compila option), tha parent gets tha straight-up original gangsta chizzle ta add a user\-editable option ta tha cache. Normally, tha lil pimp would then use tha same value dat tha parent uses. But fuck dat shiznit yo, tha word on tha street is dat it may be necessary ta hard\-code tha value fo' tha lil pimp projectz option while still allowin tha user ta edit tha value used by tha parent project. Da parent project can bust dis simply by settin a aiiight variable wit tha same name as tha option up in a scope sufficient ta hide tha optionz cache variable from tha lil pimp straight-up. Da parent has already set tha cache variable,  so tha childz set(...CACHE...) will do nothing, n' evaluatin tha option variable will use tha value from tha aiiight variable, which hides tha cache variable.

.TP
.B set_directory_properties
Set a property of tha directory.

.nf
  set_directory_properties(PROPERTIES prop1 value1 prop2 value2)
.fi

Set a property fo' tha current directory n' subdirectories. Put ya muthafuckin choppers up if ya feel dis! If tha property aint found, CMake will report a error. Shiiit, dis aint no joke. Da propertizzles include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, n' ADDITIONAL_MAKE_CLEAN_FILES fo' realz. ADDITIONAL_MAKE_CLEAN_FILES be a list of filez dat is ghon be cleaned as a part of "make clean" stage.

.TP
.B set_property
Set a named property up in a given scope.

.nf
  set_property(<GLOBAL                            |
                DIRECTORY [dir]                   |
                TARGET    [target1 [target2 ...]] |
                SOURCE    [src1 [src2 ...]]       |
                TEST      [test1 [test2 ...]]     |
                CACHE     [entry1 [entry2 ...]]>
               [APPEND] [APPEND_STRING]
               PROPERTY <name> [value1 [value2 ...]])
.fi

Set one property on zero or mo' objectz of a scope.  Da first argument determines tha scope up in which tha property is set.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope may name zero or mo' existin targets.


SOURCE scope may name zero or mo' source files.  Note dat source file propertizzles is visible only ta targets added up in tha same directory (CMakeLists.txt).


TEST scope may name zero or mo' existin tests.


CACHE scope must name zero or mo' cache existin entries.


Da required PROPERTY option is immediately followed by tha name of tha property ta set.  Remainin arguments is used ta compose tha property value up in tha form of a semicolon\-separated list.  If tha APPEND option is given tha list be appended ta any existin property value.If tha APPEND_STRING option is given tha strang be append ta any existin property value as string, i.e. it thangs up in dis biatch up in a longer strang n' not a list of strings.

.TP
.B set_source_files_properties
Source filez can have propertizzles dat affect how tha fuck they is built.

.nf
  set_source_files_properties([file1 [file2 [...]]]
                              PROPERTIES prop1 value1
                              [prop2 value2 [...]])
.fi

Set propertizzles associated wit source filez rockin a key/value paired list.  See propertizzles documentation fo' dem known ta CMake.  Unrecognized propertizzles is ignored. Y'all KNOW dat shit, muthafucka!  Source file propertizzles is visible only ta targets added up in tha same directory (CMakeLists.txt).

.TP
.B set_target_properties
Targets can have propertizzles dat affect how tha fuck they is built.

.nf
  set_target_properties(target1 target2 ...
                        PROPERTIES prop1 value1
                        prop2 value2 ...)
.fi

Set propertizzles on a target. Da syntax fo' tha command is ta list all tha filez you wanna chizzle, n' then provide tha joints you wanna set next.  Yo ass can use any prop value pair you want n' extract it lata wit tha GET_TARGET_PROPERTY command.


Propertizzles dat affect tha name of a targetz output file is as bigs up.  Da PREFIX n' SUFFIX propertizzles override tha default target name prefix (like fuckin "lib") n' suffix (like fuckin ".so"). IMPORT_PREFIX n' IMPORT_SUFFIX is tha equivalent propertizzles fo' tha import library correspondin ta a DLL (for SHARED library targets).  OUTPUT_NAME sets tha real name of a target when it is built n' can be used ta help create two targetz of tha same name even though CMake requires unique logical target names.  There be also a <CONFIG>_OUTPUT_NAME dat can set tha output name on a per\-configuration basis.  <CONFIG>_POSTFIX sets a postfix fo' tha real name of tha target when it is built under tha configuration named by <CONFIG> (in upper\-case, like fuckin "DEBUG_POSTFIX").  Da value of dis property is initialized when tha target is pimped ta tha value of tha variable CMAKE_<CONFIG>_POSTFIX (except fo' executable targets cuz earlier CMake versions which did not use dis variable fo' executables).


Da LINK_FLAGS property can be used ta add extra flags ta tha link step of a target. LINK_FLAGS_<CONFIG> will add ta tha configuration <CONFIG>, fo' example, DEBUG, RELEASE, MINSIZEREL, RELWITHDEBINFO. DEFINE_SYMBOL sets tha name of tha preprocessor symbol defined when compilin sources up in a gangbangin' finger-lickin' dirty-ass shared library. If not set here then it is set ta target_EXPORTS by default (with some substitutions if tha target aint a valid C identifier). This is useful fo' headaz ta know whether they is bein included from inside they library or outside ta properly setup dllexport/dllimport decorations. Da COMPILE_FLAGS property sets additionizzle compila flags used ta build sources within tha target.  It may also be used ta pass additionizzle preprocessor definitions.


Da LINKER_LANGUAGE property is used ta chizzle tha tool used ta link a executable or shared library. Da default is set tha language ta match tha filez up in tha library. CXX n' C is common joints fo' dis property.


For shared libraries VERSION n' SOVERSION can be used ta specify tha build version n' API version respectively. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks n' tha linker supports so\-names. If only one of both is specified tha missin be assumed ta have tha same version number n' shit. For executablez VERSION can be used ta specify tha build version. I aint talkin' bout chicken n' gravy biatch. When buildin or installin appropriate symlinks is pimped if tha platform supports symlinks. For shared libraries n' executablez on Windows tha VERSION attribute is parsed ta extract a "major.minor" version number n' shit. These numbers is used as tha image version of tha binary. 


There is all dem propertizzles used ta specify RPATH rules. INSTALL_RPATH be a semicolon\-separated list specifyin tha rpath ta use up in installed targets (for platforms dat support it). INSTALL_RPATH_USE_LINK_PATH be a funky-ass boolean dat if set ta legit will append directories up in tha linker search path n' outside tha project ta tha INSTALL_RPATH. Right back up in yo muthafuckin ass. SKIP_BUILD_RPATH be a funky-ass boolean specifyin whether ta skip automatic generation of a rpath allowin tha target ta run from tha build tree. BUILD_WITH_INSTALL_RPATH be a funky-ass boolean specifyin whether ta link tha target up in tha build tree wit tha INSTALL_RPATH.  This takes precedence over SKIP_BUILD_RPATH n' avoidz tha need fo' relinkin before installation. I aint talkin' bout chicken n' gravy biatch.  INSTALL_NAME_DIR be a strang specifyin tha directory portion of tha "install_name" field of shared libraries on Mac OSX ta use up in tha installed targets, n' you can put dat on yo' toast. When tha target is pimped tha jointz of tha variablez CMAKE_INSTALL_RPATH, CMAKE_INSTALL_RPATH_USE_LINK_PATH, CMAKE_SKIP_BUILD_RPATH, CMAKE_BUILD_WITH_INSTALL_RPATH, n' CMAKE_INSTALL_NAME_DIR is used ta initialize these properties.


PROJECT_LABEL can be used ta chizzle tha name of tha target up in a IDE like visual studio.  VS_KEYWORD can be set ta chizzle tha visual basement keyword, fo' example Qt integration works betta if dis is set ta Qt4VSv1.0.


VS_SCC_PROJECTNAME, VS_SCC_LOCALPATH, VS_SCC_PROVIDER n' VS_SCC_AUXPATH can be set ta add support fo' source control bindings up in a  Visual Studio project file.


VS_GLOBAL_<variable> can be set ta add a Visual Studio project\-specific global variable. Qt integration works betta if VS_GLOBAL_QtVersion is set ta tha Qt version FindQt4.cmake found. Y'all KNOW dat shit, muthafucka! For example, "4.7.3"


Da PRE_INSTALL_SCRIPT n' POST_INSTALL_SCRIPT propertizzles is tha oldschool way ta specify CMake scripts ta run before n' afta installin a target.  They is used only when tha oldschool INSTALL_TARGETS command is used ta install tha target.  Use tha INSTALL command instead.


Da EXCLUDE_FROM_DEFAULT_BUILD property is used by tha visual basement generators.  If it is set ta 1 tha target aint gonna be part of tha default build when you select "Build Solution". This can also be set on a per\-configuration basis rockin EXCLUDE_FROM_DEFAULT_BUILD_<CONFIG>.

.TP
.B set_tests_properties
Set a property of tha tests.

.nf
  set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)
.fi

Set a property fo' tha tests, n' you can put dat on yo' toast. If tha property aint found, CMake will report a error. Shiiit, dis aint no joke. Da propertizzles include:


WILL_FAIL: If set ta true, dis will invert tha pass/fail flag of tha test.


PASS_REGULAR_EXPRESSION: If set, tha test output is ghon be checked against tha specified regular expressions n' at least one of tha regular expressions has ta match, otherwise tha test will fail.


.nf
  Example: PASS_REGULAR_EXPRESSION "TestPassed;All ok"
.fi

FAIL_REGULAR_EXPRESSION: If set, if tha output will match ta one of specified regular expressions, tha test will fail.


.nf
  Example: PASS_REGULAR_EXPRESSION "[^a\-z]Error;ERROR;Failed"
.fi

Both PASS_REGULAR_EXPRESSION n' FAIL_REGULAR_EXPRESSION expect a list of regular expressions.


TIMEOUT: Settin dis will limit tha test runtime ta tha number of secondz specified.


.TP
.B crib_name
Set tha given variable ta tha name of tha computer.

.nf
  crib_name(variable)
.fi

.TP
.B source_group
Define a groupin fo' sources up in tha makefile.

.nf
  source_group(name [REGULAR_EXPRESSION regex] [FILES src1 src2 ...])
.fi

Defines a crew tha fuck into which sources is ghon be placed up in project files.  This is mainly used ta setup file tabs up in Visual Studio.  Any file whose name is listed or matches tha regular expression is ghon be placed up in dis group.  If a gangbangin' file matches multiple groups, tha LAST crew dat explicitly lists tha file is ghon be favored, if any.  If no crew explicitly lists tha file, tha LAST crew whose regular expression matches tha file is ghon be favored.


Da name of tha crew may contain backslashes ta specify subgroups:


.nf
  source_group(outer\\\\inner ...)
.fi

For backwardz compatibility, dis command also supports tha format:


.nf
  source_group(name regex)
.fi

.TP
.B string
Strin operations.

.nf
  string(REGEX MATCH <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX MATCHALL <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX REPLACE <regular_expression>
         <replace_expression> <output variable>
         <input> [<input>...])
  string(REPLACE <match_string>
         <replace_string> <output variable>
         <input> [<input>...])
  string(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512>
         <output variable> <input>)
  string(COMPARE EQUAL <string1> <string2> <output variable>)
  string(COMPARE NOTEQUAL <string1> <string2> <output variable>)
  string(COMPARE LESS <string1> <string2> <output variable>)
  string(COMPARE GREATER <string1> <string2> <output variable>)
  string(ASCII <number> [<number> ...] <output variable>)
  string(CONFIGURE <string1> <output variable>
         [@ONLY] [ESCAPE_QUOTES])
  string(TOUPPER <string1> <output variable>)
  string(TOLOWER <string1> <output variable>)
  string(LENGTH <string> <output variable>)
  string(SUBSTRING <string> <begin> <length> <output variable>)
  string(STRIP <string> <output variable>)
  string(RANDOM [LENGTH <length>] [ALPHABET <alphabet>]
         [RANDOM_SEED <seed>] <output variable>)
  string(FIND <string> <substring> <output variable> [REVERSE])
  string(TIMESTAMP <output variable> [<format string>] [UTC])
  string(MAKE_C_IDENTIFIER <input string> <output variable>)
.fi

REGEX MATCH will match tha regular expression once n' store tha match up in tha output variable.


REGEX MATCHALL will match tha regular expression as nuff times as possible n' store tha matches up in tha output variable as a list.


REGEX REPLACE will match tha regular expression as nuff times as possible n' substitute tha replacement expression fo' tha match up in tha output.  Da replace expression may refer ta paren\-delimited subexpressionz of tha match rockin \\1, \\2, ..., \\9.  Note dat two backslashes (\\\\1) is required up in CMake code ta git a funky-ass backslash all up in argument parsing.


REPLACE will replace all occurrencez of match_strin up in tha input wit replace_strin n' store tha result up in tha output.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha input string.


COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare tha strings n' store legit or false up in tha output variable.


ASCII'ma convert all numbers tha fuck into correspondin ASCII characters.


CONFIGURE will transform a strang like CONFIGURE_FILE transforms a gangbangin' file.


TOUPPER/TOLOWER will convert strang ta upper/lower characters.


LENGTH will return a given stringz length.


SUBSTRING will return a substrin of a given string. If length is \-1 tha remainder of tha strang startin at begin is ghon be returned.


STRIP will return a substrin of a given strang wit leadin n' trailin spaces removed.


RANDOM will return a random strang of given length consistin of charactas from tha given alphabet. Default length is 5 charactas n' default alphabet be all numbers n' upper n' lower case letters.  If a integer RANDOM_SEED is given, its value is ghon be used ta seed tha random number generator.


FIND will return tha posizzle where tha given substrin was found up in tha supplied string. If tha REVERSE flag was used, tha command will search fo' tha posizzle of tha last occurrence of tha specified substring.


Da followin charactas have special meanin up in regular expressions:


.nf
   ^         Matches at beginnin of input
   $         Matches at end of input
   .         Matches any single character
   [ ]       Matches any character(s) inside tha brackets
   [^ ]      Matches any character(s) not inside tha brackets
    \-        Inside brackets, specifies a inclusive range between
             charactas on either side e.g. [a\-f] is [abcdef]
             To match a literal \- rockin brackets, make it tha first
             or tha last characta e.g. [+*/\-] matches basic
             mathematical operators.
   *         Matches precedin pattern zero or mo' times
   +         Matches precedin pattern one or mo' times
   ?         Matches precedin pattern zero or once only
   |         Matches a pattern on either side of tha |
   ()        Saves a matched subexpression, which can be referenced 
             up in tha REGEX REPLACE operation. I aint talkin' bout chicken n' gravy biatch fo' realz. Additionally it is saved
             by all regular expression\-related commands, includin 
             e.g. if( MATCHES ), up in tha variablez CMAKE_MATCH_(0..9).
.fi

*, + n' ? have higher precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. | has lower precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. This means dat tha regular expression "^ab+d$" matches "abbd" but not "ababd", n' tha regular expression "^(ab|cd)$" matches "ab" but not "abd".


TIMESTAMP will write a strang representation of tha current date and/or time ta tha output variable.


Should tha command be unable ta obtain a timestamp tha output variable is ghon be set ta tha empty strang "".


Da optionizzle UTC flag requests tha current date/time representation ta be up in Coordinated Universal Time (UTC) rather than local time.


Da optionizzle <format string> may contain tha followin format specifiers: 


.nf
   %d        Da dizzle of tha current month (01\-31).
   %H        Da minute on a 24\-hour clock (00\-23).
   %I        Da minute on a 12\-hour clock (01\-12).
   %j        Da dizzle of tha current year (001\-366).
   %m        Da month of tha current year (01\-12).
   %M        Da minute of tha current minute (00\-59).
   %S        Da second of tha current minute.
             60 represents a leap second. Y'all KNOW dat shit, muthafucka! (00\-60)
   %U        Da week number of tha current year (00\-53).
   %w        Da dizzle of tha current week. 0 is Sunday. It make me wanna hollar playa! (0\-6)
   %y        Da last two digitz of tha current year (00\-99)
   %Y        Da current year. Shiiit, dis aint no joke. 
.fi

Unknown format specifiers is ghon be ignored n' copied ta tha output as\-is.


If no explicit <format string> is given it will default to:


.nf
   %Y\-%m\-%dT%H:%M:%S    fo' local time.
   %Y\-%m\-%dT%H:%M:%SZ   fo' UTC.
.fi

MAKE_C_IDENTIFIER will write a strang which can be used as a identifier up in C.

.TP
.B target_compile_definitions
Add compile definitions ta a target.

.nf
  target_compile_definitions(<target> <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify compile definitions ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.  Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha COMPILE_DEFINITIONS property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_COMPILE_DEFINITIONS property of <target>.   Da followin arguments specify compile definitions.  Repeated calls fo' tha same <target> append shit up in tha order called.


Arguments ta target_compile_definitions may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_compile_options
Add compile options ta a target.

.nf
  target_compile_options(<target> [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify compile options ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.  If BEFORE is specified, tha content is ghon be prepended ta tha property instead of bein appended.


Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha COMPILE_OPTIONS property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_COMPILE_OPTIONS property of <target>.   Da followin arguments specify compile opitions.  Repeated calls fo' tha same <target> append shit up in tha order called.


Arguments ta target_compile_options may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_include_directories
Add include directories ta a target.

.nf
  target_include_directories(<target> [SYSTEM] [BEFORE] <INTERFACE|PUBLIC|PRIVATE> [items1...]
    [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
.fi

Specify include directories or targets ta use when compilin a given target.  Da named <target> must done been pimped by a cold-ass lil command like fuckin add_executable or add_library n' must not be a IMPORTED target.


If BEFORE is specified, tha content is ghon be prepended ta tha property instead of bein appended.


Da INTERFACE, PUBLIC n' PRIVATE keywordz is required ta specify tha scope of tha followin arguments, n' you can put dat on yo' toast.  PRIVATE n' PUBLIC shit will populate tha INCLUDE_DIRECTORIES property of <target>.  PUBLIC n' INTERFACE shit will populate tha INTERFACE_INCLUDE_DIRECTORIES property of <target>.   Da followin arguments specify include directories. Put ya muthafuckin choppers up if ya feel dis!  Specified include directories may be absolute paths or relatizzle paths.  Repeated calls fo' tha same <target> append shit up in tha order called.If SYSTEM is specified, tha compila is ghon be holla'd all up in tha directories is meant as system include directories on some platforms (signallin dis settin might big up effects like fuckin tha compila skippin warnings, or these fixed\-install system filez not bein considered up in dependency calculations \- peep compila docs).  If SYSTEM is used together wit PUBLIC or INTERFACE, tha INTERFACE_SYSTEM_INCLUDE_DIRECTORIES target property is ghon be populated wit tha specified directories.


Arguments ta target_include_directories may use "generator expressions" wit tha syntax "$<...>".  Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B target_link_libraries
Link a target ta given libraries.

.nf
  target_link_libraries(<target> [item1 [item2 [...]]]
                        [[debug|optimized|general] <item>] ...)
.fi

Specify libraries or flags ta use when linkin a given target.  Da named <target> must done been pimped up in tha current directory by a cold-ass lil command like fuckin add_executable or add_library.  Da remainin arguments specify library names or flags.  Repeated calls fo' tha same <target> append shit up in tha order called.


If a library name matches dat of another target up in tha project a thugged-out dependency will automatically be added up in tha build system ta make shizzle tha library bein linked is up\-to\-date before tha target links.  Item names startin wit '\-' yo, but not '\-l' or '\-framework', is treated as linker flags.


A "debug", "optimized", or "general" keyword indicates dat tha library immediately followin it is ta be used only fo' tha correspondin build configuration. I aint talkin' bout chicken n' gravy biatch.  Da "debug" keyword correspondz ta tha Debug configuration (or ta configurations named up in tha DEBUG_CONFIGURATIONS global property if it is set).  Da "optimized" keyword correspondz ta all other configurations.  Da "general" keyword correspondz ta all configurations, n' is purely optionizzle (assumed if omitted).  Higher granularitizzle may be  bigged up  fo' per\-configuration rulez by bustin n' linkin ta IMPORTED library targets, n' you can put dat on yo' toast.  See tha IMPORTED mode of tha add_library command fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch.  


Library dependencies is transitizzle by default wit dis signature.  When dis target is linked tha fuck into another target then tha libraries linked ta dis target will step tha fuck up on tha link line fo' tha other target like a muthafucka.  This transitizzle "link intercourse" is stored up in tha INTERFACE_LINK_LIBRARIES target property when policy CMP0022 is set ta NEW n' may be overridden by settin tha property directly. (When CMP0022 aint set ta NEW, transitizzle linkin is builtin but may be overridden by tha LINK_INTERFACE_LIBRARIES property.  Calls ta other signaturez of dis command may set tha property makin any libraries linked exclusively by dis signature private.)


CMake will also propagate "usage requirements" from linked library targets, n' you can put dat on yo' toast.  Usage requirements affect compilation of sources up in tha <target>.  They is specified by propertizzles defined on linked targets, n' you can put dat on yo' toast.  Durin generation of tha build system, CMake integrates usage requirement property joints wit tha correspondin build propertizzles fo' <target>:


.nf
 INTERFACE_COMPILE_DEFINITONS: Appendz ta COMPILE_DEFINITONS
 INTERFACE_INCLUDE_DIRECTORIES: Appendz ta INCLUDE_DIRECTORIES
 INTERFACE_POSITION_INDEPENDENT_CODE: Sets POSITION_INDEPENDENT_CODE
   or checked fo' consistency wit existin value
.fi




If a <item> be a library up in a Mac OX framework, tha Headaz directory of tha framework will also be processed as a "usage requirement".  This has tha same ol' dirty effect as passin tha framework directory as a include directory.  target_link_libraries(<target>


.nf
                      <PRIVATE|PUBLIC|INTERFACE> <lib> ...
                      [<PRIVATE|PUBLIC|INTERFACE> <lib> ... ] ...])
.fi

Da PUBLIC, PRIVATE n' INTERFACE keywordz can be used ta specify both tha link dependencies n' tha link intercourse up in one command. Y'all KNOW dat shit, muthafucka!  Libraries n' targets followin PUBLIC is linked to, n' is made part of tha link intercourse.  Libraries n' targets followin PRIVATE is linked ta yo, but is not made part of tha link intercourse.  Libraries followin INTERFACE is appended ta tha link intercourse n' is not used fo' linkin <target>.


.nf
  target_link_libraries(<target> LINK_INTERFACE_LIBRARIES
                        [[debug|optimized|general] <lib>] ...)
.fi

Da LINK_INTERFACE_LIBRARIES mode appendz tha libraries ta tha INTERFACE_LINK_LIBRARIES target property instead of rockin dem fo' linking.  If policy CMP0022 aint NEW, then dis mode also appendz libraries ta tha LINK_INTERFACE_LIBRARIES n' its per\-configuration equivalent.  This signature is fo' compatibilitizzle only. Prefer tha INTERFACE mode instead. Y'all KNOW dat shit, muthafucka!  Libraries specified as "debug" is wrapped up in a generator expression ta correspond ta debug builds.  If policy CMP0022 aint NEW, tha libraries is also appended ta tha LINK_INTERFACE_LIBRARIES_DEBUG property (or ta tha propertizzles correspondin ta configurations listed up in tha DEBUG_CONFIGURATIONS global property if it is set).  Libraries specified as "optimized" is appended ta tha INTERFACE_LINK_LIBRARIES property.  If policy CMP0022 aint NEW, they is also appended ta tha LINK_INTERFACE_LIBRARIES property.  Libraries specified as "general" (or without any keyword) is treated as if specified fo' both "debug" n' "optimized".


.nf
  target_link_libraries(<target>
                        <LINK_PRIVATE|LINK_PUBLIC>
                          [[debug|optimized|general] <lib>] ...
                        [<LINK_PRIVATE|LINK_PUBLIC>
                          [[debug|optimized|general] <lib>] ...])
.fi

Da LINK_PUBLIC n' LINK_PRIVATE modes can be used ta specify both tha link dependencies n' tha link intercourse up in one command. Y'all KNOW dat shit, muthafucka!  This signature is fo' compatibilitizzle only. Prefer tha PUBLIC or PRIVATE keywordz instead. Y'all KNOW dat shit, muthafucka!  Libraries n' targets followin LINK_PUBLIC is linked to, n' is made part of tha INTERFACE_LINK_LIBRARIES.  If policy CMP0022 aint NEW, they is also made part of tha LINK_INTERFACE_LIBRARIES.  Libraries n' targets followin LINK_PRIVATE is linked ta yo, but is not made part of tha INTERFACE_LINK_LIBRARIES (or LINK_INTERFACE_LIBRARIES).


Da library dependency graph is normally acyclic (a DAG) yo, but up in tha case of mutually\-dependent STATIC libraries CMake allows tha graph ta contain cyclez (strongly connected components).  When another target links ta one of tha libraries CMake repeats tha entire connected component.  For example, tha code


.nf
  add_library(A STATIC a.c)
  add_library(B STATIC b.c)
  target_link_libraries(A B)
  target_link_libraries(B A)
  add_executable(main main.c)
  target_link_libraries(main A)
.fi

links 'main' ta 'A B A B'.  (While one repetizzle is probably sufficient, pathological object file n' symbol arrangements can require mo' n' mo' n' mo'.  One may handle such cases by manually repeatin tha component up in tha last target_link_libraries call.  But fuck dat shiznit yo, tha word on tha street is dat if two archives is straight-up so interdependent they should probably be combined tha fuck into a single archive.)


Arguments ta target_link_libraries may use "generator expressions" wit tha syntax "$<...>".  Note however, dat generator expressions aint gonna be used up in OLD handlin of CMP0003 or CMP0004.


Generator expressions is evaluated durin build system generation ta produce shiznit specific ta each build configuration. I aint talkin' bout chicken n' gravy biatch.  Valid expressions are:


.nf
  $<0:...>                  = empty strang (ignores "...")
  $<1:...>                  = content of "..."
  $<CONFIG:cfg>             = '1' if config is "cfg", else '0'
  $<CONFIGURATION>          = configuration name
  $<BOOL:...>               = '1' if tha '...' is true, else '0'
  $<STREQUAL:a,b>           = '1' if a is STREQUAL b, else '0'
  $<ANGLE\-R>                = A literal '>'. Used ta compare strings which contain a '>' fo' example.
  $<COMMA>                  = A literal ','. Used ta compare strings which contain a ',' fo' example.
  $<SEMICOLON>              = A literal ';'. Used ta prevent list expansion on a argument wit ';'.
  $<JOIN:list,...>          = joins tha list wit tha content of "..."
  $<TARGET_NAME:...>        = Marks ... as bein tha name of a target.  This is required if exportin targets ta multiple dependent export sets, n' you can put dat on yo' toast.  Da '...' must be a literal name of a target\- it may not contain generator expressions.
  $<INSTALL_INTERFACE:...>  = content of "..." when tha property is exported rockin install(EXPORT), n' empty otherwise.
  $<BUILD_INTERFACE:...>    = content of "..." when tha property is exported rockin export(), or when tha target is used by another target up in tha same buildsystem. Expandz ta tha empty strang otherwise.
  $<C_COMPILER_ID>          = Da CMake\-id of tha C compila used.
  $<C_COMPILER_ID:comp>     = '1' if tha CMake\-id of tha C compila matches comp, otherwise '0'.
  $<CXX_COMPILER_ID>        = Da CMake\-id of tha CXX compila used.
  $<CXX_COMPILER_ID:comp>   = '1' if tha CMake\-id of tha CXX compila matches comp, otherwise '0'.
  $<VERSION_GREATER:v1,v2>  = '1' if v1 be a version pimped outa than v2, else '0'.
  $<VERSION_LESS:v1,v2>     = '1' if v1 be a version less than v2, else '0'.
  $<VERSION_EQUAL:v1,v2>    = '1' if v1 is tha same ol' dirty version as v2, else '0'.
  $<C_COMPILER_VERSION>     = Da version of tha C compila used.
  $<C_COMPILER_VERSION:ver> = '1' if tha version of tha C compila matches ver, otherwise '0'.
  $<CXX_COMPILER_VERSION>   = Da version of tha CXX compila used.
  $<CXX_COMPILER_VERSION:ver> = '1' if tha version of tha CXX compila matches ver, otherwise '0'.
  $<TARGET_FILE:tgt>        = main file (.exe, .so.1.2, .a)
  $<TARGET_LINKER_FILE:tgt> = file used ta link (.a, .lib, .so)
  $<TARGET_SONAME_FILE:tgt> = file wit soname (.so.3)
.fi

where "tgt" is tha name of a target.  Target file expressions produce a gangbangin' full path yo, but _DIR n' _NAME versions can produce tha directory n' file name components:


.nf
  $<TARGET_FILE_DIR:tgt>/$<TARGET_FILE_NAME:tgt>
  $<TARGET_LINKER_FILE_DIR:tgt>/$<TARGET_LINKER_FILE_NAME:tgt>
  $<TARGET_SONAME_FILE_DIR:tgt>/$<TARGET_SONAME_FILE_NAME:tgt>
.fi




.nf
  $<TARGET_PROPERTY:tgt,prop>   = Da value of tha property prop on tha target tgt.
.fi

Note dat tgt aint added as a thugged-out dependency of tha target dis expression is evaluated on.


.nf
  $<TARGET_POLICY:pol>          = '1' if tha policy was NEW when tha 'head' target was pimped, else '0'.  If tha policy was not set, tha warnin message fo' tha policy is ghon be emitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This generator expression only works fo' a subset of policies.
  $<INSTALL_PREFIX>         = Content of tha install prefix when tha target is exported via INSTALL(EXPORT) n' empty otherwise.
.fi

Boolean expressions:


.nf
  $<AND:?[,?]...>           = '1' if all '?' is '1', else '0'
  $<OR:?[,?]...>            = '0' if all '?' is '0', else '1'
  $<NOT:?>                  = '0' if '?' is '1', else '1'
.fi

where '?' be always either '0' or '1'.


Expressions wit a implicit 'this' target:


.nf
  $<TARGET_PROPERTY:prop>   = Da value of tha property prop on tha target on which tha generator expression is evaluated.
.fi

.TP
.B try_compile
Try buildin some code.

.nf
  try_compile(RESULT_VAR <bindir> <srcdir>
              <projectName> [targetName] [CMAKE_FLAGS flags...]
              [OUTPUT_VARIABLE <var>])
.fi

Try buildin a project.  In dis form, srcdir should contain a cold-ass lil complete CMake project wit a CMakeLists.txt file n' all sources. Da bindir n' srcdir aint gonna be deleted afta dis command is run. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Specify targetName ta build a specific target instead of tha 'all' or 'ALL_BUILD' target.


.nf
  try_compile(RESULT_VAR <bindir> <srcfile|SOURCES srcfile...>
              [CMAKE_FLAGS flags...]
              [COMPILE_DEFINITIONS flags...]
              [LINK_LIBRARIES libs...]
              [OUTPUT_VARIABLE <var>]
              [COPY_FILE <fileName> [COPY_FILE_ERROR <var>]])
.fi

Try buildin a executable from one or mo' source files.  In dis form tha user need only supply one or mo' source filez dat include a thugged-out definizzle fo' 'main'.  CMake will create a CMakeLists.txt file ta build tha source(s) as a executable.  Specify COPY_FILE ta git a cold-ass lil copy of tha linked executable all up in tha given fileName n' optionally COPY_FILE_ERROR ta capture any error.


In dis version all filez up in bindir/CMakeFiles/CMakeTmp is ghon be cleaned automatically. For debugging, \-\-debug\-trycompile can be passed ta cmake ta avoid dis clean. I aint talkin' bout chicken n' gravy biatch. But fuck dat shiznit yo, tha word on tha street is dat multiple sequential try_compile operations reuse dis single output directory. If you use \-\-debug\-trycompile, you can only debug one try_compile call at a time. Da recommended procedure is ta configure wit cmake all tha way all up in once, then delete tha cache entry associated wit tha try_compile call of interest, n' then re\-run cmake again n' again n' again wit \-\-debug\-trycompile.


Some extra flags dat can be included are,  INCLUDE_DIRECTORIES, LINK_DIRECTORIES, n' LINK_LIBRARIES.  COMPILE_DEFINITIONS is \-Ddefinizzle dat is ghon be passed ta tha compile line.


Da srcfile signature also accepts a LINK_LIBRARIES argument which may contain a list of libraries or IMPORTED targets which is ghon be linked ta up in tha generated project.  If LINK_LIBRARIES is specified as a parameta ta try_compile, then any LINK_LIBRARIES passed as CMAKE_FLAGS is ghon be ignored.


try_compile creates a CMakeList.txt file on tha fly dat be lookin like this:


.nf
  add_definitions( <expanded COMPILE_DEFINITIONS from callin cmake>)
  include_directories(${INCLUDE_DIRECTORIES})
  link_directories(${LINK_DIRECTORIES})
  add_executable(cmTryCompileExec sources)
  target_link_libraries(cmTryCompileExec ${LINK_LIBRARIES})
.fi

In both versionz of tha command, if OUTPUT_VARIABLE is specified, then tha output from tha build process is stored up in tha given variable. Da success or failure of tha try_compile, i.e. TRUE or FALSE respectively, is returned up in RESULT_VAR. CMAKE_FLAGS can be used ta pass \-DVAR:TYPE=VALUE flags ta tha cmake dat is run durin tha build. Y'all KNOW dat shit, muthafucka! Set variable CMAKE_TRY_COMPILE_CONFIGURATION ta chizzle a funky-ass build configuration.

.TP
.B try_run
Try compilin n' then hustlin some code.

.nf
  try_run(RUN_RESULT_VAR COMPILE_RESULT_VAR
          bindir srcfile [CMAKE_FLAGS <Flags>]
          [COMPILE_DEFINITIONS <flags>]
          [COMPILE_OUTPUT_VARIABLE comp]
          [RUN_OUTPUT_VARIABLE run]
          [OUTPUT_VARIABLE var]
          [ARGS <arg1> <arg2>...])
.fi

Try compilin a srcfile.  Return TRUE or FALSE fo' success or failure up in COMPILE_RESULT_VAR.  Then if tha compile succeeded, run tha executable n' return its exit code up in RUN_RESULT_VAR. If tha executable was built yo, but failed ta run, then RUN_RESULT_VAR is ghon be set ta FAILED_TO_RUN. COMPILE_OUTPUT_VARIABLE specifies tha variable where tha output from tha compile step goes. RUN_OUTPUT_VARIABLE specifies tha variable where tha output from tha hustlin executable goes.


For compatibilitizzle reasons OUTPUT_VARIABLE is still supported, which gives you tha output from tha compile n' run step combined.


Cross compilin issues


When cross compiling, tha executable compiled up in tha straight-up original gangsta step probably cannot be run on tha build host. try_run() checks tha CMAKE_CROSSCOMPILING variable ta detect whether CMake is up in crosscompilin mode. If thatz tha case, it will still try ta compile tha executable yo, but it aint gonna try ta run tha executable. Instead it will create cache variablez which must be filled by tha user or by presettin dem up in some CMake script file ta tha joints tha executable would have produced if it had been run on its actual target platform. These variablez is RUN_RESULT_VAR (explanation peep above) n' if RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) was used, a additionizzle cache variable RUN_RESULT_VAR__COMPILE_RESULT_VAR__TRYRUN_OUTPUT.This is intended ta hold stdout n' stderr from tha executable.


In order ta make cross compilin yo' project easier, use try_run only if straight-up required. Y'all KNOW dat shit, muthafucka! If you use try_run, use RUN_OUTPUT_VARIABLE (or OUTPUT_VARIABLE) only if straight-up required. Y'all KNOW dat shit, muthafucka! Usin dem will require dat when crosscompiling, tha cache variablez will gotta be set manually ta tha output of tha executable. Yo ass can also "guard" tha calls ta try_run wit if(CMAKE_CROSSCOMPILING) n' provide a easy as fuck \-to\-preset alternatizzle fo' dis case.


Set variable CMAKE_TRY_COMPILE_CONFIGURATION ta chizzle a funky-ass build configuration.

.TP
.B unset
Unset a variable, cache variable, or environment variable.

.nf
  unset(<variable> [CACHE])
.fi

Removes tha specified variable causin it ta become undefined. Y'all KNOW dat shit, muthafucka!  If CACHE is present then tha variable is removed from tha cache instead of tha current scope.


<variable> can be a environment variable such as:


.nf
  unset(ENV{LD_LIBRARY_PATH})
.fi

in which case tha variable is ghon be removed from tha current environment.

.TP
.B variable_watch
Watch tha CMake variable fo' chizzle.

.nf
  variable_watch(<variable name> [<command ta execute>])
.fi

If tha specified variable chizzles, tha message is ghon be printed bout tha variable bein chizzled. Y'all KNOW dat shit, muthafucka! If tha command is specified, tha command is ghon be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da command will receive tha followin arguments: COMMAND(<variable> <access> <value> <current list file> <stack>)

.TP
.B while
Evaluate a crew of commandz while a cold-ass lil condizzle is true

.nf
  while(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endwhile(condition)
.fi

All commandz between while n' tha matchin endwhile is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endwhile is evaluated, tha recorded list of commandz is invoked as long as tha condizzle is true. Da condizzle is evaluated rockin tha same logic as tha if command.

.SH COMPATIBILITY COMMANDS
.TP
.B build_name
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use ${CMAKE_SYSTEM} n' ${CMAKE_CXX_COMPILER} instead.

.nf
  build_name(variable)
.fi

Sets tha specified variable ta a strang representin tha platform n' compila settings.  These joints is now available all up in tha CMAKE_SYSTEM n' CMAKE_CXX_COMPILER variables.

.TP
.B exec_program
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha execute_process() command instead.

Run a executable program durin tha processin of tha CMakeList.txt file.


.nf
  exec_program(Executable [directory up in which ta run]
               [ARGS <arguments ta executable>]
               [OUTPUT_VARIABLE <var>]
               [RETURN_VALUE <var>])
.fi

Da executable is run up in tha optionally specified directory.  Da executable can include arguments if it is double quoted yo, but it is betta ta use tha optionizzle ARGS argument ta specify arguments ta tha program.   This is cuz cmake will then be able ta escape spaces up in tha executable path.  An optionizzle argument OUTPUT_VARIABLE specifies a variable up in which ta store tha output. To capture tha return value of tha execution, provide a RETURN_VALUE. If OUTPUT_VARIABLE is specified, then no output will git all up in tha stdout/stderr of tha console hustlin cmake.


.TP
.B export_library_dependencies
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use INSTALL(EXPORT) or EXPORT command.

This command generates a old\-style library dependencies file.  Projects requirin CMake 2.6 or lata should not use tha command. Y'all KNOW dat shit, muthafucka!  Use instead tha install(EXPORT) command ta help export targets from a installation tree n' tha export() command ta export targets from a funky-ass build tree.


Da old\-style library dependencies file do not take tha fuck into account per\-configuration namez of libraries or tha LINK_INTERFACE_LIBRARIES target property.


.nf
  export_library_dependencies(<file> [APPEND])
.fi

Smoke a gangbangin' file named <file> dat can be included tha fuck into a CMake listfile wit tha INCLUDE command. Y'all KNOW dat shit, muthafucka!  Da file will contain a fuckin shitload of SET commandz dat will set all tha variablez needed fo' library dependency shiznit. I aint talkin' bout chicken n' gravy biatch.  This should be tha last command up in tha top level CMakeLists.txt file of tha project.  If tha APPEND option is specified, tha SET commandz is ghon be appended ta tha given file instead of replacin dat shit.

.TP
.B install_files
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha install(FILES ) command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.  Da FILES form is directly replaced by tha FILES form of tha install command. Y'all KNOW dat shit, muthafucka!  Da regexp form can be expressed mo' clearly rockin tha GLOB form of tha file command.


.nf
  install_files(<dir> extension file file ...)
.fi

Smoke rulez ta install tha listed filez wit tha given extension tha fuck into tha given directory.  Only filez existin up in tha current source tree or its correspondin location up in tha binary tree may be listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If a gangbangin' file specified already has a extension, dat extension is ghon be removed first.  This is useful fo' providin listz of source filez like fuckin foo.cxx when you want tha correspondin foo.h ta be installed. Y'all KNOW dat shit, muthafucka! A typical extension is '.h'.


.nf
  install_files(<dir> regexp)
.fi

Any filez up in tha current source directory dat match tha regular expression is ghon be installed.


.nf
  install_files(<dir> FILES file file ...)
.fi

Any filez listed afta tha FILES keyword is ghon be installed explicitly from tha names given. I aint talkin' bout chicken n' gravy biatch.  Full paths is allowed up in dis form.


Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX.

.TP
.B install_programs
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha install(PROGRAMS ) command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.  Da FILES form is directly replaced by tha PROGRAMS form of tha INSTALL command. Y'all KNOW dat shit, muthafucka!  Da regexp form can be expressed mo' clearly rockin tha GLOB form of tha FILE command.


.nf
  install_programs(<dir> file1 file2 [file3 ...])
  install_programs(<dir> FILES file1 [file2 ...])
.fi

Smoke rulez ta install tha listed programs tha fuck into tha given directory. Use tha FILES argument ta guarantee dat tha file list version of tha command is ghon be used even when there is only one argument.


.nf
  install_programs(<dir> regexp)
.fi

In tha second form any program up in tha current source directory dat matches tha regular expression is ghon be installed.


This command is intended ta install programs dat is not built by cmake, like fuckin shell scripts, n' you can put dat on yo' toast.  See tha TARGETS form of tha INSTALL command ta create installation rulez fo' targets built by cmake.


Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX.

.TP
.B install_targets
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha install(TARGETS )  command instead.

This command has been superceded by tha install command. Y'all KNOW dat shit, muthafucka!  It be provided fo' compatibilitizzle wit olda CMake code.


.nf
  install_targets(<dir> [RUNTIME_DIRECTORY dir] target target)
.fi

Smoke rulez ta install tha listed targets tha fuck into tha given directory.  Da directory <dir> is relatizzle ta tha installation prefix, which is stored up in tha variable CMAKE_INSTALL_PREFIX. If RUNTIME_DIRECTORY is specified, then on systems wit special runtime filez (Windows DLL), tha filez is ghon be copied ta dat directory.

.TP
.B link_libraries
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha target_link_libraries() command instead.

Link libraries ta all targets added later.


.nf
  link_libraries(library1 <debug | optimized> library2 ...)
.fi

Specify a list of libraries ta be linked tha fuck into any followin targets (typically added wit tha add_executable or add_library calls).  This command is passed down ta all subdirectories. Put ya muthafuckin choppers up if ya feel dis!  Da debug n' optimized strings may be used ta indicate dat tha next library listed is ta be used only fo' dat specific type of build.

.TP
.B make_directory
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(MAKE_DIRECTORY ) command instead.

.nf
  make_directory(directory)
.fi

Creates tha specified directory.  Full paths should be given. I aint talkin' bout chicken n' gravy biatch.  Any parent directories dat do not exist will also be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use wit care.

.TP
.B output_required_files
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Approximate C preprocessor dependency scanning.

This command exists only cuz ancient CMake versions provided dat shit.  CMake handlez preprocessor dependency scannin automatically rockin a mo' advanced scanner.


.nf
  output_required_files(srcfile outputfile)
.fi

Outputs a list of all tha source filez dat is required by tha specified srcfile. This list is freestyled tha fuck into outputfile. This is similar ta freestylin up tha dependencies fo' srcfile except dat it jumps from .h filez tha fuck into .cxx, .c n' .cpp filez if possible.

.TP
.B remove
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha list(REMOVE_ITEM ) command instead.

.nf
  remove(VAR VALUE VALUE ...)
.fi

Removes VALUE from tha variable VAR.  This is typically used ta remove entries from a vector (e.g. semicolon separated list).  VALUE is expanded.

.TP
.B subdir_depends
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Do nothing.

.nf
  subdir_depends(subdir dep1 dep2 ...)
.fi

Do not do anything.  This command used ta help projects order parallel buildz erectly.  This functionalitizzle is now automatic.

.TP
.B subdirs
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha add_subdirectory() command instead.

Add a list of subdirectories ta tha build.


.nf
  subdirs(dir1 dir2 ...[EXCLUDE_FROM_ALL exclude_dir1 exclude_dir2 ...]
          [PREORDER] )
.fi

Add a list of subdirectories ta tha build. Y'all KNOW dat shit, muthafucka! Da add_subdirectory command should be used instead of subdirs although subdirs will still work. This will cause any CMakeLists.txt filez up in tha sub directories ta be processed by CMake.  Any directories afta tha PREORDER flag is traversed first by makefile builds, tha PREORDER flag has no effect on IDE projects, n' you can put dat on yo' toast.  Any directories afta tha EXCLUDE_FROM_ALL marker aint gonna be included up in tha top level makefile or project file. This is useful fo' havin CMake create makefilez or projects fo' a set of examplez up in a project. Yo ass would want CMake ta generate makefilez or project filez fo' all tha examplez all up in tha same time yo, but you would not want dem ta show up in tha top level project or be built each time make is run from tha top.

.TP
.B use_mangled_mesa
Copy mesa headaz fo' use up in combination wit system GL.

.nf
  use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)
.fi

Da path ta mesa includes, should contain gl_mangle.h.  Da mesa headaz is copied ta tha specified output directory.  This allows mangled mesa headaz ta override other GL headaz by bein added ta tha include directory path earlier.

.TP
.B utility_source
Specify tha source tree of a third\-party utility.

.nf
  utility_source(cache_entry executable_name
                 path_to_source [file1 file2 ...])
.fi

When a third\-party utilityz source is included up in tha distribution, dis command specifies its location n' name.  Da cache entry aint gonna be set unless tha path_to_source n' all listed filez exist.  It be assumed dat tha source tree of tha utilitizzle gonna git been built before it is needed.


When cross compilin CMake will print a warnin if a utility_source() command is executed, cuz up in nuff cases it is used ta build a executable which is executed lata on. I aint talkin' bout chicken n' gravy biatch. This don't work when cross compiling, since tha executable can run only on they target platform. Right back up in yo muthafuckin ass. So up in dis case tha cache entry has ta be adjusted manually so it points ta a executable which is runnable on tha build host.

.TP
.B variable_requires
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha if() command instead.

Assert satisfaction of a optionz required variables.


.nf
  variable_requires(TEST_VARIABLE RESULT_VARIABLE
                    REQUIRED_VARIABLE1
                    REQUIRED_VARIABLE2 ...)
.fi

Da first argument (TEST_VARIABLE) is tha name of tha variable ta be tested, if dat variable is false not a god damn thang else is done. If TEST_VARIABLE is true, then tha next argument (RESULT_VARIABLE) be a variable dat is set ta legit if all tha required variablez is set. Da rest of tha arguments is variablez dat must be legit or not set ta NOTFOUND ta avoid a error. Shiiit, dis aint no joke.  If any is not true, a error is reported.

.TP
.B write_file
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(WRITE ) command instead.

.nf
  write_file(filename "message ta write"... [APPEND])
.fi

Da first argument is tha file name, tha rest of tha arguments is lyrics ta write. If tha argument APPEND is specified, then tha message is ghon be appended.


NOTE 1: file(WRITE ... n' file(APPEND ... do exactly tha same as dis one but add some mo' functionality.


NOTE 2: When rockin write_file tha produced file cannot be used as a input ta CMake (CONFIGURE_FILE, source file ...) cuz it will lead ta a infinite loop. Use configure_file if you wanna generate input filez ta CMake.

.SH MODULES
.SH COPYRIGHT
.PP
Copyright 2000\-2012 Kitware, Inc., Insight Software Consortium.  All muthafuckin rights reserved.

.PP
Redistribution n' use up in source n' binary forms, wit or without modification, is permitted provided dat tha followin conditions is met:

.PP
Redistributionz of source code must retain tha above copyright notice, dis list of conditions n' tha followin disclaimer.

.PP
Redistributions up in binary form must reproduce tha above copyright notice, dis list of conditions n' tha followin disclaimer up in tha documentation and/or other shiznit provided wit tha distribution.

.PP
Neither tha namez of Kitware, Inc., tha Insight Software Consortium, nor tha namez of they contributors may be used ta endorse or promote shizzle derived from dis software without specific prior freestyled permission.

.PP
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.SH SEE ALSO
.PP
.B cmake(1), ctest(1)

.PP
Da followin resources is available ta git help rockin CMake:

.TP
.B Home Page
http://www.cmake.org

Da primary startin point fo' peepin' bout CMake.

.TP
.B Frequently Axed Questions
http://www.cmake.org/Wiki/CMake_FAQ

A Wiki is provided containin lyrics ta frequently axed thangs. 

.TP
.B Online Documentation
http://www.cmake.org/HTML/Documentation.html

Links ta available documentation may be found on dis wizzy page.

.TP
.B Mailin List
http://www.cmake.org/HTML/MailingLists.html

For help n' rap bout rockin cmake, a mailin list is provided at cmake@cmake.org. Da list is member\-post\-only but one may sign up on tha CMake wizzy page. Please first read tha full documentation at http://www.cmake.org before postin thangs ta tha list.

.SH AUTHOR
.PP
This manual page was generated by tha "\-\-help\-man" option.

