.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTRO 1"
.TH PERLINTRO 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlintro \-\- a funky-ass brief introduction n' overview of Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is intended ta hit you wit a quick overview of tha Perl
programmin language, along wit pointas ta further documentation. I aint talkin' bout chicken n' gravy biatch.  It
is intended as a \*(L"bootstrap\*(R" guide fo' dem playas whoz ass is freshly smoked up ta the
language, n' serves up just enough shiznit fo' you ta be able to
read other peoples' Perl n' KNOW roughly what tha fuck itz bustin, or
write yo' own simple scripts.
.PP
This introductory document do not aim ta be complete.  It do not
even aim ta be entirely accurate.  In some cases perfection has been
sacrificed up in tha goal of gettin tha general scam across.  Yo ass are
\&\fIstrongly\fR advised ta follow dis introduction wit mo' shiznit
from tha full Perl manual, tha table of contents ta which can be found
in perltoc.
.PP
Throughout dis document you gonna peep references ta other partz of the
Perl documentation. I aint talkin' bout chicken n' gravy biatch.  Yo ass can read dat documentation rockin tha \f(CW\*(C`perldoc\*(C'\fR
command or whatever method you rockin ta read dis document.
.PP
Throughout Perlz documentation, you gonna find a shitload of examplez intended
to help explain tha discussed features.  Please keep up in mind dat many
of dem is code fragments rather than complete programs.
.PP
These examplez often reflect tha steez n' preference of tha lyricist of
that piece of tha documentation, n' may be briefer than a cold-ass lil corresponding
line of code up in a real program.  Except where otherwise noted, you
should assume dat \f(CW\*(C`use strict\*(C'\fR n' \f(CW\*(C`use warnings\*(C'\fR statements
appear earlier up in tha \*(L"program\*(R", n' dat any variablez used have
already been declared, even if dem declarations done been omitted
to make tha example easier ta read.
.PP
Do note dat tha examplez done been freestyled by nuff different authors over
a period of nuff muthafuckin decades.  Stylez n' steez will therefore differ,
although some effort has been made ta not vary stylez too widely up in the
same sections.  Do not consider one steez ta be betta than others \- \*(L"There's
Mo' Than One Way To Do It\*(R" is one of Perlz mottos.  Afta all, up in your
journey as a programmer, yo ass is likely ta encounta different styles.
.SS "What tha fuck iz Perl?"
.IX Subsection "What tha fuck iz Perl?"
Perl be a general-purpose programmin language originally pimped for
text manipulation n' now used fo' a wide range of tasks including
system administration, wizzy pimpment, network programming, \s-1GUI\s0
development, n' more.
.PP
Da language is intended ta be practical (easy ta use, efficient,
complete) rather than dope (tiny, elegant, minimal).  Its major
features is dat itz easy as fuck  ta use, supports both procedural and
object-oriented (\s-1OO\s0) programming, has bangin built-in support fo' text
processing, n' has one of tha ghettoz most impressive collections of
third-party modules.
.PP
Different definitionz of Perl is given up in perl, perlfaq1 and
no diggity other places.  From dis we can determine dat Perl is different
things ta different playas yo, but dat fuckin shitloadz of playas be thinkin itz at least
worth freestylin about.
.SS "Hustlin Perl programs"
.IX Subsection "Hustlin Perl programs"
To run a Perl program from tha Unix command line:
.PP
.Vb 1
\& perl progname.pl
.Ve
.PP
Alternatively, put dis as tha straight-up original gangsta line of yo' script:
.PP
.Vb 1
\& #!/usr/bin/env perl
.Ve
.PP
\&... n' run tha script as \fI/path/to/script.pl\fR.  Of course, it'll need
to be executable first, so \f(CW\*(C`chmod 755 script.pl\*(C'\fR (under Unix).
.PP
(This start line assumes you have tha \fBenv\fR program.  Yo ass can also put
directly tha path ta yo' perl executable, like up in \f(CW\*(C`#!/usr/bin/perl\*(C'\fR).
.PP
For mo' shiznit, includin instructions fo' other platforms such as
Windows n' Mac \s-1OS,\s0 read perlrun.
.SS "Safety net"
.IX Subsection "Safety net"
Perl by default is straight-up forgiving.  In order ta make it mo' robust
it is recommended ta start every last muthafuckin program wit tha followin lines:
.PP
.Vb 3
\& #!/usr/bin/perl
\& use strict;
\& use warnings;
.Ve
.PP
Da two additionizzle lines request from perl ta catch various common
problems up in yo' code.  They check different thangs so you need both.  A
potential problem caught by \f(CW\*(C`use strict;\*(C'\fR will cause yo' code ta stop
immediately when it is encountered, while \f(CW\*(C`use warnings;\*(C'\fR will merely
give a warnin (like tha command-line switch \fB\-w\fR) n' let yo' code run.
To read mo' bout dem check they respectizzle manual pages at strict
and warnings.
.SS "Basic syntax overview"
.IX Subsection "Basic syntax overview"
A Perl script or program consistz of one or mo' statements, n' you can put dat on yo' toast.  These
statements is simply freestyled up in tha script up in a straightforward
fashion. I aint talkin' bout chicken n' gravy biatch.  There is no need ta git a \f(CW\*(C`main()\*(C'\fR function or anythang of
that kind.
.PP
Perl statements end up in a semi-colon:
.PP
.Vb 1
\& print "Yo muthafucka, ghetto";
.Ve
.PP
Comments start wit a hash symbol n' run ta tha end of tha line
.PP
.Vb 1
\& # This be a cold-ass lil comment
.Ve
.PP
Whitespace is irrelevant:
.PP
.Vb 3
\& print
\&     "Yo muthafucka, ghetto"
\&     ;
.Ve
.PP
\&... except inside quoted strings:
.PP
.Vb 3
\& # dis would print wit a linebreak up in tha middle
\& print "Hello
\& ghetto";
.Ve
.PP
Double quotes or single quotes may be used round literal strings:
.PP
.Vb 2
\& print "Yo muthafucka, ghetto";
\& print \*(AqYo muthafucka, ghetto\*(Aq;
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat only double quotes \*(L"interpolate\*(R" variablez n' special
charactas like fuckin newlines (\f(CW\*(C`\en\*(C'\fR):
.PP
.Vb 2
\& print "Yo muthafucka, $name\en";     # works fine
\& print \*(AqYo muthafucka, $name\en\*(Aq;     # prints $name\en literally
.Ve
.PP
Numbers don't need quotes round them:
.PP
.Vb 1
\& print 42;
.Ve
.PP
Yo ass can use parentheses fo' functions' arguments or omit them
accordin ta yo' underground taste.  They is only required
occasionally ta clarify thangz of precedence.
.PP
.Vb 2
\& print("Yo muthafucka, ghetto\en");
\& print "Yo muthafucka, ghetto\en";
.Ve
.PP
Mo' detailed shiznit bout Perl syntax can be found up in perlsyn.
.SS "Perl variable types"
.IX Subsection "Perl variable types"
Perl has three main variable types: scalars, arrays, n' hashes.
.IP "Scalars" 4
.IX Item "Scalars"
A scalar represents a single value:
.Sp
.Vb 2
\& mah $animal = "camel";
\& mah $answer = 42;
.Ve
.Sp
Scalar joints can be strings, integers or floatin point numbers, n' Perl
will automatically convert between dem as required. Y'all KNOW dat shit, muthafucka!  There is no need
to pre-declare yo' variable types yo, but you gotta declare dem using
the \f(CW\*(C`my\*(C'\fR keyword tha last time you use em.  (This is one of the
requirementz of \f(CW\*(C`use strict;\*(C'\fR.)
.Sp
Scalar joints can be used up in various ways:
.Sp
.Vb 3
\& print $animal;
\& print "Da animal is $animal\en";
\& print "Da square of $answer is ", $answer * $answer, "\en";
.Ve
.Sp
There is a fuckin shitload of \*(L"magic\*(R" scalars wit names dat look like
punctuation or line noise.  These special variablez is used fo' all
kindz of purposes, n' is documented up in perlvar. Shiiit, dis aint no joke.  Da only one you
need ta know bout fo' now is \f(CW$_\fR which is tha \*(L"default variable\*(R".
It aint nuthin but used as tha default argument ta a fuckin shitload of functions up in Perl, and
itz set implicitly by certain loopin constructs.
.Sp
.Vb 1
\& print;          # prints contentz of $_ by default
.Ve
.IP "Arrays" 4
.IX Item "Arrays"
An array represents a list of joints:
.Sp
.Vb 3
\& mah @animals = ("camel", "llama", "owl");
\& mah @numbers = (23, 42, 69);
\& mah @mixed   = ("camel", 42, 1.23);
.Ve
.Sp
Arrays is zero-indexed. Y'all KNOW dat shit, muthafucka!  Herez how tha fuck you git at elements up in a array:
.Sp
.Vb 2
\& print $animals[0];              # prints "camel"
\& print $animals[1];              # prints "llama"
.Ve
.Sp
Da special variable \f(CW$#array\fR  drops some lyrics ta you tha index of tha last element
of a array:
.Sp
.Vb 1
\& print $mixed[$#mixed];       # last element, prints 1.23
.Ve
.Sp
Yo ass might be tempted ta use \f(CW\*(C`$#array + 1\*(C'\fR ta rap  how tha fuck nuff shit there
are up in a array.  Don't bother n' shit.  As it happens, rockin \f(CW@array\fR where Perl
expects ta find a scalar value (\*(L"in scalar context\*(R") will hit you wit tha number
of elements up in tha array:
.Sp
.Vb 1
\& if (@animals < 5) { ... }
.Ve
.Sp
Da elements we gettin from tha array start wit a \f(CW\*(C`$\*(C'\fR cuz
we're gettin just a single value outta tha array; you ask fo' a scalar,
you git a scalar.
.Sp
To git multiple joints from a array:
.Sp
.Vb 3
\& @animals[0,1];                 # gives ("camel", "llama");
\& @animals[0..2];                # gives ("camel", "llama", "owl");
\& @animals[1..$#animals];        # gives all except tha straight-up original gangsta element
.Ve
.Sp
This is called a \*(L"array slice\*(R".
.Sp
Yo ass can do various useful thangs ta lists:
.Sp
.Vb 2
\& mah @sorted    = sort @animals;
\& mah @backwardz = reverse @numbers;
.Ve
.Sp
There is a cold-ass lil couple special arrays too, like fuckin \f(CW@ARGV\fR (the command
line arguments ta yo' script) n' \f(CW@_\fR (the arguments passed ta a
subroutine).  These is documented up in perlvar.
.IP "Hashes" 4
.IX Item "Hashes"
A hash represents a set of key/value pairs:
.Sp
.Vb 1
\& mah %fruit_color = ("apple", "red", "banana", "yellow");
.Ve
.Sp
Yo ass can use whitespace n' tha \f(CW\*(C`=>\*(C'\fR operator ta lay dem up more
nicely:
.Sp
.Vb 4
\& mah %fruit_color = (
\&     apple  => "red",
\&     banana => "yellow",
\& );
.Ve
.Sp
To git at hash elements:
.Sp
.Vb 1
\& $fruit_color{"apple"};           # gives "red"
.Ve
.Sp
Yo ass can git at listz of keys n' joints wit \f(CW\*(C`keys()\*(C'\fR and
\&\f(CW\*(C`values()\*(C'\fR.
.Sp
.Vb 2
\& mah @fruits = keys %fruit_colors;
\& mah @colors = joints %fruit_colors;
.Ve
.Sp
Hashes have no particular internal order, though you can sort tha keys
and loop all up in em.
.Sp
Just like special scalars n' arrays, there be also special hashes.
Da most well known of these is \f(CW%ENV\fR which gotz nuff environment
variables.  Read all bout it (and other special variables) in
perlvar.
.PP
Scalars, arrays n' hashes is documented mo' straight-up up in perldata.
.PP
Mo' complex data types can be constructed rockin references, which allow
you ta build lists n' hashes within lists n' hashes.
.PP
A reference be a scalar value n' can refer ta any other Perl data
type.  So by storin a reference as tha value of a array or hash
element, you can easily create lists n' hashes within lists and
hashes.  Da followin example shows a 2 level hash of hash
structure rockin anonymous hash references.
.PP
.Vb 10
\& mah $variablez = {
\&     scalar  =>  {
\&                  description => "single item",
\&                  sigil => \*(Aq$\*(Aq,
\&                 },
\&     array   =>  {
\&                  description => "ordered list of items",
\&                  sigil => \*(Aq@\*(Aq,
\&                 },
\&     hash    =>  {
\&                  description => "key/value pairs",
\&                  sigil => \*(Aq%\*(Aq,
\&                 },
\& };
\&
\& print "Scalars begin wit a $variables\->{\*(Aqscalar\*(Aq}\->{\*(Aqsigil\*(Aq}\en";
.Ve
.PP
Exhaustizzle shiznit on tha topic of references can be found in
perlreftut, perllol, perlref n' perldsc.
.SS "Variable scoping"
.IX Subsection "Variable scoping"
Throughout tha previous section all tha examplez have used tha syntax:
.PP
.Vb 1
\& mah $var = "value";
.Ve
.PP
Da \f(CW\*(C`my\*(C'\fR is straight-up not required; you could just use:
.PP
.Vb 1
\& $var = "value";
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat tha above usage will create global variablez all up in your
program, which is wack programmin practice.  \f(CW\*(C`my\*(C'\fR creates lexically
scoped variablez instead. Y'all KNOW dat shit, muthafucka!  Da variablez is scoped ta tha block
(i.e. a funky-ass bunch of statements surrounded by curly-braces) up in which they
are defined.
.PP
.Vb 9
\& mah $x = "foo";
\& mah $some_condizzle = 1;
\& if ($some_condition) {
\&     mah $y = "bar";
\&     print $x;           # prints "foo"
\&     print $y;           # prints "bar"
\& }
\& print $x;               # prints "foo"
\& print $y;               # prints nothing; $y has fallen outta scope
.Ve
.PP
Usin \f(CW\*(C`my\*(C'\fR up in combination wit a \f(CW\*(C`use strict;\*(C'\fR all up in tha top of
your Perl scripts means dat tha interpreta will pick up certain common
programmin errors.  For instance, up in tha example above, tha final
\&\f(CW\*(C`print $y\*(C'\fR would cause a cold-ass lil compile-time error n' prevent you from
runnin tha program.  Usin \f(CW\*(C`strict\*(C'\fR is highly recommended.
.SS "Conditionizzle n' loopin constructs"
.IX Subsection "Conditionizzle n' loopin constructs"
Perl has most of tha usual conditionizzle n' loopin constructs, n' you can put dat on yo' toast.  Az of Perl
5.10, it even has a cold-ass lil case/switch statement (spelled \f(CW\*(C`given\*(C'\fR/\f(CW\*(C`when\*(C'\fR).  See
\&\*(L"Switch Statements\*(R" up in perlsyn fo' mo' details.
.PP
Da conditions can be any Perl expression. I aint talkin' bout chicken n' gravy biatch.  See tha list of operators in
the next section fo' shiznit on comparison n' boolean logic operators,
which is commonly used up in conditionizzle statements.
.IP "if" 4
.IX Item "if"
.Vb 7
\& if ( condizzle ) {
\&     ...
\& } elsif ( other condizzle ) {
\&     ...
\& } else {
\&     ...
\& }
.Ve
.Sp
Therez also a negated version of it:
.Sp
.Vb 3
\& unless ( condizzle ) {
\&     ...
\& }
.Ve
.Sp
This is provided as a mo' readable version of \f(CW\*(C`if (!\f(CIcondition\f(CW)\*(C'\fR.
.Sp
Note dat tha braces is required up in Perl, even if you've only gots one
line up in tha block.  But fuck dat shiznit yo, tha word on tha street is dat there be a cold-ass lil smart-ass way of makin yo' one-line
conditionizzle blocks mo' Gangsta like:
.Sp
.Vb 4
\& # tha traditionizzle way
\& if ($zippy) {
\&     print "Yow!";
\& }
\&
\& # tha Perlish post\-condizzle way
\& print "Yow!" if $zippy;
\& print "Our thugged-out asses have no bananas" unless $bananas;
.Ve
.IP "while" 4
.IX Item "while"
.Vb 3
\& while ( condizzle ) {
\&     ...
\& }
.Ve
.Sp
Therez also a negated version, fo' tha same reason our crazy asses have \f(CW\*(C`unless\*(C'\fR:
.Sp
.Vb 3
\& until ( condizzle ) {
\&     ...
\& }
.Ve
.Sp
Yo ass can also use \f(CW\*(C`while\*(C'\fR up in a post-condition:
.Sp
.Vb 1
\& print "LA LA LA\en" while 1;          # loops forever
.Ve
.IP "for" 4
.IX Item "for"
Exactly like C:
.Sp
.Vb 3
\& fo' ($i = 0; $i <= $max; $i++) {
\&     ...
\& }
.Ve
.Sp
Da C steez fo' loop is rarely needed up in Perl since Perl provides
the mo' thugged-out list scannin \f(CW\*(C`foreach\*(C'\fR loop.
.IP "foreach" 4
.IX Item "foreach"
.Vb 3
\& foreach (@array) {
\&     print "This element is $_\en";
\& }
\&
\& print $list[$_] foreach 0 .. $max;
\&
\& # you don\*(Aqt gotta use tha default $_ either...
\& foreach mah $key (keys %hash) {
\&     print "Da value of $key is $hash{$key}\en";
\& }
.Ve
.Sp
Da \f(CW\*(C`foreach\*(C'\fR keyword is straight-up a synonym fo' tha \f(CW\*(C`for\*(C'\fR
keyword. Y'all KNOW dat shit, muthafucka!  See \f(CW\*(C`"Foreach Loops" up in perlsyn\*(C'\fR.
.PP
For mo' detail on loopin constructs (and some dat weren't mentioned in
this overview) peep perlsyn.
.SS "Builtin operators n' functions"
.IX Subsection "Builtin operators n' functions"
Perl comes wit a wide selection of builtin functions.  Some of tha ones
we've already peeped include \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`sort\*(C'\fR n' \f(CW\*(C`reverse\*(C'\fR.  A list of
them is given all up in tha start of perlfunc n' you can easily read
about any given function by rockin \f(CW\*(C`perldoc \-f \f(CIfunctionname\f(CW\*(C'\fR.
.PP
Perl operators is documented up in full up in perlop yo, but here is a gangbangin' few
of da most thugged-out common ones:
.IP "Arithmetic" 4
.IX Item "Arithmetic"
.Vb 4
\& +   addition
\& \-   subtraction
\& *   multiplication
\& /   division
.Ve
.IP "Numeric comparison" 4
.IX Item "Numeric comparison"
.Vb 6
\& ==  equality
\& !=  inequality
\& <   less than
\& >   pimped outa than
\& <=  less than or equal
\& >=  pimped outa than or equal
.Ve
.IP "Strin comparison" 4
.IX Item "Strin comparison"
.Vb 6
\& eq  equality
\& ne  inequality
\& lt  less than
\& gt  pimped outa than
\& le  less than or equal
\& ge  pimped outa than or equal
.Ve
.Sp
(Why do our crazy asses have separate numeric n' strang comparisons?  Because our phat asses don't
have special variable types, n' Perl need ta know whether ta sort
numerically (where 99 is less than 100) or alphabetically (where 100 comes
before 99).
.IP "Boolean logic" 4
.IX Item "Boolean logic"
.Vb 3
\& &&  and
\& ||  or
\& !   not
.Ve
.Sp
(\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR n' \f(CW\*(C`not\*(C'\fR aren't just up in tha above table as descriptions
of tha operators.  They're also supported as operators up in they own
right.  They're mo' readable than tha C\-style operators yo, but have
different precedence ta \f(CW\*(C`&&\*(C'\fR n' playas.  Peep perlop fo' more
detail.)
.IP "Miscellaneous" 4
.IX Item "Miscellaneous"
.Vb 4
\& =   assignment
\& .   strang concatenation
\& x   strang multiplication
\& ..  range operator (creates a list of numbers)
.Ve
.PP
Many operators can be combined wit a \f(CW\*(C`=\*(C'\fR as bigs up:
.PP
.Vb 3
\& $a += 1;        # same as $a = $a + 1
\& $a \-= 1;        # same as $a = $a \- 1
\& $a .= "\en";     # same as $a = $a . "\en";
.Ve
.SS "Filez n' I/O"
.IX Subsection "Filez n' I/O"
Yo ass can open a gangbangin' file fo' input or output rockin tha \f(CW\*(C`open()\*(C'\fR function.
It aint nuthin but documented up in extravagant detail up in perlfunc n' perlopentut,
but up in short:
.PP
.Vb 3
\& open(my $in,  "<",  "input.txt")  or take a thugged-out dirtnap "Can\*(Aqt open input.txt: $!";
\& open(my $out, ">",  "output.txt") or take a thugged-out dirtnap "Can\*(Aqt open output.txt: $!";
\& open(my $log, ">>", "my.log")     or take a thugged-out dirtnap "Can\*(Aqt open my.log: $!";
.Ve
.PP
Yo ass can read from a open filehandle rockin tha \f(CW\*(C`<>\*(C'\fR operator. Shiiit, dis aint no joke.  In
scalar context it readz a single line from tha filehandle, n' up in list
context it readz tha whole file in, assignin each line ta a element of
the list:
.PP
.Vb 2
\& mah $line  = <$in>;
\& mah @lines = <$in>;
.Ve
.PP
Readin up in tha whole file at one time is called slurping.  It can
be useful but it may be a memory hog.  Most text file processing
can be done a line at a time wit Perlz loopin constructs.
.PP
Da \f(CW\*(C`<>\*(C'\fR operator is most often peeped up in a \f(CW\*(C`while\*(C'\fR loop:
.PP
.Vb 3
\& while (<$in>) {     # assigns each line up in turn ta $_
\&     print "Just read up in dis line: $_";
\& }
.Ve
.PP
We've already peeped how tha fuck ta print ta standard output rockin \f(CW\*(C`print()\*(C'\fR.
But fuck dat shiznit yo, tha word on tha street is dat \f(CW\*(C`print()\*(C'\fR can also take a optionizzle first argument specifying
which filehandle ta print to:
.PP
.Vb 3
\& print STDERR "This is yo' final warning.\en";
\& print $out $record;
\& print $log $logmessage;
.Ve
.PP
When you done wit yo' filehandles, you should \f(CW\*(C`close()\*(C'\fR them
(though ta be honest, Perl will clean up afta you if you forget):
.PP
.Vb 1
\& close $in or take a thugged-out dirtnap "$in: $!";
.Ve
.SS "Regular expressions"
.IX Subsection "Regular expressions"
Perlz regular expression support is both broad n' deep, n' is the
subject of lengthy documentation up in perlrequick, perlretut, and
elsewhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  But fuck dat shiznit yo, tha word on tha street is dat up in short:
.IP "Simple matching" 4
.IX Item "Simple matching"
.Vb 2
\& if (/foo/)       { ... }  # legit if $_ gotz nuff "foo"
\& if ($a =~ /foo/) { ... }  # legit if $a gotz nuff "foo"
.Ve
.Sp
Da \f(CW\*(C`//\*(C'\fR matchin operator is documented up in perlop.  It operates on
\&\f(CW$_\fR by default, or can be bound ta another variable rockin tha \f(CW\*(C`=~\*(C'\fR
bindin operator (also documented up in perlop).
.IP "Simple substitution" 4
.IX Item "Simple substitution"
.Vb 4
\& s/foo/bar/;               # replaces foo wit bar up in $_
\& $a =~ s/foo/bar/;         # replaces foo wit bar up in $a
\& $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo wit bar
\&                           # up in $a
.Ve
.Sp
Da \f(CW\*(C`s///\*(C'\fR substitution operator is documented up in perlop.
.IP "Mo' complex regular expressions" 4
.IX Item "Mo' complex regular expressions"
Yo ass don't just gotta match on fixed strings.  In fact, you can match
on just bout anythang you could trip of by rockin mo' complex regular
expressions.  These is documented at pimped out length up in perlre yo, but for
the meantime, herez a quick cheat sheet:
.Sp
.Vb 12
\& .                   a single character
\& \es                  a whitespace characta (space, tab, newline,
\&                     ...)
\& \eS                  non\-whitespace character
\& \ed                  a gangbangin' finger-lickin' digit (0\-9)
\& \eD                  a non\-digit
\& \ew                  a word characta (a\-z, A\-Z, 0\-9, _)
\& \eW                  a non\-word character
\& [aeiou]             matches a single characta up in tha given set
\& [^aeiou]            matches a single characta outside tha given
\&                     set
\& (foo|bar|baz)       matches any of tha alternatives specified
\&
\& ^                   start of string
\& $                   end of string
.Ve
.Sp
Quantifiers can be used ta specify how tha fuck nuff of tha previous thang you
wanna match on, where \*(L"thing\*(R" means either a literal character, one
of tha metacharactas listed above, or a crew of charactas or
metacharactas up in parentheses.
.Sp
.Vb 6
\& *                   zero or mo' of tha previous thang
\& +                   one or mo' of tha previous thang
\& ?                   zero or one of tha previous thang
\& {3}                 matches exactly 3 of tha previous thang
\& {3,6}               matches between 3 n' 6 of tha previous thang
\& {3,}                matches 3 or mo' of tha previous thang
.Ve
.Sp
Some brief examples:
.Sp
.Vb 7
\& /^\ed+/              strang starts wit one or mo' digits
\& /^$/                not a god damn thang up in tha strang (start n' end are
\&                     adjacent)
\& /(\ed\es){3}/         three digits, each followed by a whitespace
\&                     characta (eg "3 4 5 ")
\& /(a.)+/             matches a strang up in which every last muthafuckin odd\-numbered
\&                     letta be a (eg "abacadaf")
\&
\& # This loop readz from STDIN, n' prints non\-blank lines:
\& while (<>) {
\&     next if /^$/;
\&     print;
\& }
.Ve
.IP "Parentheses fo' capturing" 4
.IX Item "Parentheses fo' capturing"
As well as grouping, parentheses serve a second purpose.  They can be
used ta capture tha thangs up in dis biatch of partz of tha regexp match fo' lata use.
Da thangs up in dis biatch end up in \f(CW$1\fR, \f(CW$2\fR n' so on.
.Sp
.Vb 1
\& # a cold-ass lil skanky n' nasty way ta break a email address up tha fuck into parts
\&
\& if ($email =~ /([^@]+)@(.+)/) {
\&     print "Username is $1\en";
\&     print "Hostname is $2\en";
\& }
.Ve
.IP "Other regexp features" 4
.IX Item "Other regexp features"
Perl regexps also support backreferences, lookaheads, n' all kindz of
other complex details.  Read all bout dem up in perlrequick,
perlretut, n' perlre.
.SS "Freestylin subroutines"
.IX Subsection "Freestylin subroutines"
Freestylin subroutines is easy as fuck :
.PP
.Vb 5
\& sub logger {
\&    mah $logmessage = shift;
\&    open mah $logfile, ">>", "my.log" or take a thugged-out dirtnap "Could not open my.log: $!";
\&    print $logfile $logmessage;
\& }
.Ve
.PP
Now we can use tha subroutine just as any other built-in function:
.PP
.Vb 1
\& logger("Our thugged-out asses gotz a logger subroutine!");
.Ve
.PP
Whatz dat \f(CW\*(C`shift\*(C'\fR?  Well, tha arguments ta a subroutine is available
to our asses as a special array called \f(CW@_\fR (see perlvar fo' mo' on that).
Da default argument ta tha \f(CW\*(C`shift\*(C'\fR function just happens ta be \f(CW@_\fR.
So \f(CW\*(C`my $logmessage = shift;\*(C'\fR shifts tha straight-up original gangsta item off tha list of
arguments n' assigns it ta \f(CW$logmessage\fR.
.PP
We can manipulate \f(CW@_\fR up in other ways too:
.PP
.Vb 2
\& mah ($logmessage, $priority) = @_;       # common
\& mah $logmessage = $_[0];                 # uncommon, n' skanky
.Ve
.PP
Subroutines can also return joints:
.PP
.Vb 5
\& sub square {
\&     mah $num = shift;
\&     mah $result = $num * $num;
\&     return $result;
\& }
.Ve
.PP
Then use it like:
.PP
.Vb 1
\& $sq = square(8);
.Ve
.PP
For mo' shiznit on freestylin subroutines, peep perlsub.
.SS "\s-1OO\s0 Perl"
.IX Subsection "OO Perl"
\&\s-1OO\s0 Perl is relatively simple n' is implemented rockin references which
know what tha fuck sort of object they is based on Perlz concept of packages.
But fuck dat shiznit yo, tha word on tha street is dat \s-1OO\s0 Perl is largely beyond tha scope of dis document.
Read perlootut n' perlobj.
.PP
As a funky-ass beginnin Perl programmer, yo' most common use of \s-1OO\s0 Perl will be
in rockin third-party modules, which is documented below.
.SS "Usin Perl modules"
.IX Subsection "Usin Perl modules"
Perl modulez provide a range of features ta help you avoid reinventing
the wheel, n' can be downloaded from \s-1CPAN \s0( http://www.cpan.org/ ).  A
number of ghettofab modulez is included wit tha Perl distribution
itself.
.PP
Categoriez of modulez range from text manipulation ta network protocols
to database integration ta graphics.  A categorized list of modulez is
also available from \s-1CPAN.\s0
.PP
To learn how tha fuck ta install modulez you downlizzle from \s-1CPAN,\s0 read
perlmodinstall.
.PP
To learn how tha fuck ta bust a particular module, use \f(CW\*(C`perldoc \f(CIModule::Name\f(CW\*(C'\fR.
Typically yo big-ass booty is ghon wanna \f(CW\*(C`use \f(CIModule::Name\f(CW\*(C'\fR, which will then give
you access ta exported functions or a \s-1OO\s0 intercourse ta tha module.
.PP
perlfaq gotz nuff thangs n' lyrics related ta nuff common
tasks, n' often serves up suggestions fo' phat \s-1CPAN\s0 modulez ta use.
.PP
perlmod raps bout Perl modulez up in general. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  perlmodlib lists the
modulez which came wit yo' Perl installation.
.PP
If you feel tha urge ta write Perl modules, perlnewmod will give you
phat lyrics.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirrily \*(L"Skud\*(R" Robert <skud@cpan.org>
