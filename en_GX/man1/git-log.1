'\" t
.\"     Title: git-log
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-LOG" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-log \- Show commit logs
.SH "SYNOPSIS"
.sp
.nf
\fIgit log\fR [<options>] [<revision range>] [[\-\-] <path>\&...]
.fi
.sp
.SH "DESCRIPTION"
.sp
Shows tha commit logs\&.
.sp
Da command takes options applicable ta tha git rev\-list command ta control what tha fuck is shown n' how, n' options applicable ta tha git diff\-* commandz ta control how tha fuck tha chizzlez each commit introduces is shown\&.
.SH "OPTIONS"
.PP
\-\-follow
.RS 4
Continue listin tha history of a gangbangin' file beyond renames (works only fo' a single file)\&.
.RE
.PP
\-\-no\-decorate, \-\-decorate[=short|full|no]
.RS 4
Print up tha ref namez of any commits dat is shown\&. If
\fIshort\fR
is specified, tha ref name prefixes
\fIrefs/heads/\fR,
\fIrefs/tags/\fR
and
\fIrefs/remotes/\fR
will not be printed\&. If
\fIfull\fR
is specified, tha full ref name (includin prefix) is ghon be printed\&. Da default option is
\fIshort\fR\&.
.RE
.PP
\-\-source
.RS 4
Print up tha ref name given on tha command line by which each commit was reached\&.
.RE
.PP
\-\-use\-mailmap
.RS 4
Use mailmap file ta map lyricist n' committa names n' email addresses ta canonical real names n' email addresses\&. Right back up in yo muthafuckin ass. See
\fBgit-shortlog\fR(1)\&.
.RE
.PP
\-\-full\-diff
.RS 4
Without dis flag,
git log \-p <path>\&.\&.\&.
shows commits dat bust a nut on tha specified paths, n' diffs bout tha same specified paths\&. With this, tha full diff is shown fo' commits dat bust a nut on tha specified paths; dis means dat "<path>\&..." limits only commits, n' don\(cqt limit diff fo' dem commits\&.
.sp
Note dat dis affects all diff\-based output types, e\&.g\&. dem produced by
\-\-stat, etc\&.
.RE
.PP
\-\-log\-size
.RS 4
Include a line \(lqlog size <number>\(rq up in tha output fo' each commit, where <number> is tha length of dat commit\(cqs message up in bytes\&. Intended ta speed up tools dat read log lyrics from
git log
output by allowin dem ta allocate space up in advance\&.
.RE
.PP
\-L <start>,<end>:<file>, \-L :<regex>:<file>
.RS 4
Trace tha evolution of tha line range given by "<start>,<end>" (or tha funcname regex <regex>) within tha <file>\&. Yo ass may not give any pathspec limiters\&. This is currently limited ta a strutt startin from a single revision, i\&.e\&., you may only give zero or one positizzle revision arguments\&. Yo ass can specify dis option mo' than once\&.
.sp
<start> n' <end> can take one of these forms:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
number
.sp
If <start> or <end> be a number, it specifies a absolute line number (lines count from 1)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
/regex/
.sp
This form will use tha straight-up original gangsta line matchin tha given POSIX regex\&. If <start> be a regex, it will search from tha end of tha previous
\-L
range, if any, otherwise from tha start of file\&. If <start> is \(lq^/regex/\(rq, it will search from tha start of file\&. If <end> be a regex, it will search startin all up in tha line given by <start>\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
+offset or \-offset
.sp
This is only valid fo' <end> n' will specify a fuckin shitload of lines before or afta tha line given by <start>\&.
.RE
.sp
If \(lq:<regex>\(rq is given up in place of <start> n' <end>, it denotes tha range from tha straight-up original gangsta funcname line dat matches <regex>, up ta tha next funcname line\&. \(lq:<regex>\(rq searches from tha end of tha previous
\-L
range, if any, otherwise from tha start of file\&. \(lq^:<regex>\(rq searches from tha start of file\&.
.RE
.PP
<revision range>
.RS 4
Show only commits up in tha specified revision range\&. When no <revision range> is specified, it defaults to
HEAD
(i\&.e\&. tha whole history leadin ta tha current commit)\&.
origin\&.\&.HEAD
specifies all tha commits reachable from tha current commit (i\&.e\&.
HEAD) yo, but not from
origin\&. For a cold-ass lil complete list of ways ta spell <revision range>, peep the
\fISpecifyin Ranges\fR
section of
\fBgitrevisions\fR(7)\&.
.RE
.PP
[\-\-] <path>\&...
.RS 4
Show only commits dat is enough ta explain how tha fuck tha filez dat match tha specified paths came ta be\&. Right back up in yo muthafuckin ass. See
\fIHistory Simplification\fR
below fo' details n' other simplification modes\&.
.sp
Paths may need ta be prefixed wit \(oq`\-\- \(aq\(cq ta separate dem from options or tha revision range, when mad drama arises\&.
.RE
.SS "Commit Limiting"
.sp
Besides specifyin a range of commits dat should be listed rockin tha special notations explained up in tha description, additionizzle commit limitin may be applied\&.
.sp
Usin mo' options generally further limits tha output (e\&.g\&. \-\-since=<date1> limits ta commits newer than <date1>, n' rockin it wit \-\-grep=<pattern> further limits ta commits whose log message has a line dat matches <pattern>), unless otherwise noted\&.
.sp
Note dat these is applied before commit orderin n' formattin options, like fuckin \-\-reverse\&.
.PP
\-<number>, \-n <number>, \-\-max\-count=<number>
.RS 4
Limit tha number of commits ta output\&.
.RE
.PP
\-\-skip=<number>
.RS 4
Skip
\fInumber\fR
commits before startin ta show tha commit output\&.
.RE
.PP
\-\-since=<date>, \-\-after=<date>
.RS 4
Show commits mo' recent than a specific date\&.
.RE
.PP
\-\-until=<date>, \-\-before=<date>
.RS 4
Show commits olda than a specific date\&.
.RE
.PP
\-\-author=<pattern>, \-\-committer=<pattern>
.RS 4
Limit tha commits output ta ones wit author/committa header lines dat match tha specified pattern (regular expression)\&. With mo' than one
\-\-author=<pattern>, commits whose lyricist matches any of tha given patterns is chosen (similarly fo' multiple
\-\-committer=<pattern>)\&.
.RE
.PP
\-\-grep\-reflog=<pattern>
.RS 4
Limit tha commits output ta ones wit reflog entries dat match tha specified pattern (regular expression)\&. With mo' than one
\-\-grep\-reflog, commits whose reflog message matches any of tha given patterns is chosen\&. Well shiiiit, it be a error ta use dis option unless
\-\-walk\-reflogs
is up in use\&.
.RE
.PP
\-\-grep=<pattern>
.RS 4
Limit tha commits output ta ones wit log message dat matches tha specified pattern (regular expression)\&. With mo' than one
\-\-grep=<pattern>, commits whose message matches any of tha given patterns is chosen (but see
\-\-all\-match)\&.
.sp
When
\-\-show\-notes
is up in effect, tha message from tha notes as if it is part of tha log message\&.
.RE
.PP
\-\-all\-match
.RS 4
Limit tha commits output ta ones dat match all given
\-\-grep, instead of ones dat match at least one\&.
.RE
.PP
\-i, \-\-regexp\-ignore\-case
.RS 4
Match tha regular expression limitin patterns without regard ta letta case\&.
.RE
.PP
\-\-basic\-regexp
.RS 4
Consider tha limitin patterns ta be basic regular expressions; dis is tha default\&.
.RE
.PP
\-E, \-\-extended\-regexp
.RS 4
Consider tha limitin patterns ta be extended regular expressions instead of tha default basic regular expressions\&.
.RE
.PP
\-F, \-\-fixed\-strings
.RS 4
Consider tha limitin patterns ta be fixed strings (don\(cqt interpret pattern as a regular expression)\&.
.RE
.PP
\-\-perl\-regexp
.RS 4
Consider tha limitin patterns ta be Perl\-compatible regular expressions\&. Requires libpcre ta be compiled in\&.
.RE
.PP
\-\-remove\-empty
.RS 4
Quit when a given path disappears from tha tree\&.
.RE
.PP
\-\-merges
.RS 4
Print only merge commits\&. This is exactly tha same as
\-\-min\-parents=2\&.
.RE
.PP
\-\-no\-merges
.RS 4
Do not print commits wit mo' than one parent\&. This is exactly tha same as
\-\-max\-parents=1\&.
.RE
.PP
\-\-min\-parents=<number>, \-\-max\-parents=<number>, \-\-no\-min\-parents, \-\-no\-max\-parents
.RS 4
Show only commits which have at least (or at most) dat nuff parent commits\&. In particular,
\-\-max\-parents=1
is tha same ol' dirty as
\-\-no\-merges,
\-\-min\-parents=2
is tha same ol' dirty as
\-\-merges\&.
\-\-max\-parents=0
gives all root commits and
\-\-min\-parents=3
all octopus merges\&.
.sp
\-\-no\-min\-parents
and
\-\-no\-max\-parents
reset these limits (to no limit) again\&. Equivalent forms are
\-\-min\-parents=0
(any commit has 0 or mo' muthafathas) and
\-\-max\-parents=\-1
(negatizzle numbers denote no upper limit)\&.
.RE
.PP
\-\-first\-parent
.RS 4
Big up only tha straight-up original gangsta parent commit upon seein a merge commit\&. This option can give a funky-ass betta overview when viewin tha evolution of a particular topic branch, cuz merges tha fuck into a topic branch tend ta be only bout adjustin ta updated upstream from time ta time, n' dis option allows you ta ignore tha individual commits brought up in ta yo' history by such a merge\&.
.RE
.PP
\-\-not
.RS 4
Reverses tha meanin of the
\fI^\fR
prefix (or lack thereof) fo' all followin revision specifiers, up ta tha next
\-\-not\&.
.RE
.PP
\-\-all
.RS 4
Pretend as if all tha refs in
refs/
are listed on tha command line as
\fI<commit>\fR\&.
.RE
.PP
\-\-branches[=<pattern>]
.RS 4
Pretend as if all tha refs in
refs/heads
are listed on tha command line as
\fI<commit>\fR\&. If
\fI<pattern>\fR
is given, limit branches ta ones matchin given shell glob\&. If pattern lacks
\fI?\fR,
\fI*\fR, or
\fI[\fR,
\fI/*\fR
at tha end is implied\&.
.RE
.PP
\-\-tags[=<pattern>]
.RS 4
Pretend as if all tha refs in
refs/tags
are listed on tha command line as
\fI<commit>\fR\&. If
\fI<pattern>\fR
is given, limit tags ta ones matchin given shell glob\&. If pattern lacks
\fI?\fR,
\fI*\fR, or
\fI[\fR,
\fI/*\fR
at tha end is implied\&.
.RE
.PP
\-\-remotes[=<pattern>]
.RS 4
Pretend as if all tha refs in
refs/remotes
are listed on tha command line as
\fI<commit>\fR\&. If
\fI<pattern>\fR
is given, limit remote\-trackin branches ta ones matchin given shell glob\&. If pattern lacks
\fI?\fR,
\fI*\fR, or
\fI[\fR,
\fI/*\fR
at tha end is implied\&.
.RE
.PP
\-\-glob=<glob\-pattern>
.RS 4
Pretend as if all tha refs matchin shell glob
\fI<glob\-pattern>\fR
are listed on tha command line as
\fI<commit>\fR\&. Leading
\fIrefs/\fR, be automatically prepended if missing\&. If pattern lacks
\fI?\fR,
\fI*\fR, or
\fI[\fR,
\fI/*\fR
at tha end is implied\&.
.RE
.PP
\-\-exclude=<glob\-pattern>
.RS 4
Do not include refs matching
\fI<glob\-pattern>\fR
that tha next
\-\-all,
\-\-branches,
\-\-tags,
\-\-remotes, or
\-\-glob
would otherwise consider\&. Repetitionz of dis option accumulate exclusion patterns up ta tha next
\-\-all,
\-\-branches,
\-\-tags,
\-\-remotes, or
\-\-glob
option (other options or arguments do not clear accumlated patterns)\&.
.sp
Da patterns given should not begin with
refs/heads,
refs/tags, or
refs/remotes
when applied to
\-\-branches,
\-\-tags, or
\-\-remotes, respectively, n' they must begin with
refs/
when applied to
\-\-glob
or
\-\-all\&. If a trailing
\fI/*\fR
is intended, it must be given explicitly\&.
.RE
.PP
\-\-ignore\-missing
.RS 4
Upon seein a invalid object name up in tha input, pretend as if tha wack input was not given\&.
.RE
.PP
\-\-bisect
.RS 4
Pretend as if tha wack bisection ref
refs/bisect/bad
was listed n' as if dat shiznit was followed by
\-\-not
and tha phat bisection refs
refs/bisect/good\-*
on tha command line\&.
.RE
.PP
\-\-stdin
.RS 4
In addizzle ta the
\fI<commit>\fR
listed on tha command line, read dem from tha standard input\&. If a
\fI\-\-\fR
separator is seen, stop readin commits n' start readin paths ta limit tha result\&.
.RE
.PP
\-\-cherry\-mark
.RS 4
Like
\-\-cherry\-pick
(see below) but mark equivalent commits with
=
rather than omittin them, n' inequivalent ones with
+\&.
.RE
.PP
\-\-cherry\-pick
.RS 4
Omit any commit dat introduces tha same ol' dirty chizzle as another commit on tha \(lqother side\(rq when tha set of commits is limited wit symmetric difference\&.
.sp
For example, if you have two branches,
A
and
B, a usual way ta list all commits on only one side of dem is with
\-\-left\-right
(see tha example below up in tha description of the
\-\-left\-right
option)\&. But fuck dat shiznit yo, tha word on tha street is dat it shows tha commits dat was cherry\-picked from tha other branch (for example, \(lq3rd on b\(rq may be cherry\-picked from branch A)\&. With dis option, such pairz of commits is excluded from tha output\&.
.RE
.PP
\-\-left\-only, \-\-right\-only
.RS 4
List only commits on tha respectizzle side of a symmetric range, i\&.e\&. only dem which would be marked
<
resp\&.
>
by
\-\-left\-right\&.
.sp
For example,
\-\-cherry\-pick \-\-right\-only A\&.\&.\&.B
omits dem commits from
B
which is in
A
or is patch\-equivalent ta a cold-ass lil commit in
A\&. In other lyrics, dis lists the
+
commits from
git cherry A B\&. Mo' precisely,
\-\-cherry\-pick \-\-right\-only \-\-no\-merges
gives tha exact list\&.
.RE
.PP
\-\-cherry
.RS 4
A synonym for
\-\-right\-only \-\-cherry\-mark \-\-no\-merges; useful ta limit tha output ta tha commits on our side n' mark dem dat done been applied ta tha other side of a gangbangin' forked history with
git log \-\-cherry upstream\&.\&.\&.mybranch, similar to
git cherry upstream mybranch\&.
.RE
.PP
\-g, \-\-walk\-reflogs
.RS 4
Instead of struttin tha commit ancestry chain, strutt reflog entries from da most thugged-out recent one ta olda ones\&. When dis option is used you cannot specify commits ta exclude (that is,
\fI^commit\fR,
\fIcommit1\&.\&.commit2\fR, and
\fIcommit1\&.\&.\&.commit2\fR
notations cannot be used)\&.
.sp
With
\-\-pretty
format other than
oneline
(for obvious reasons), dis causes tha output ta have two extra linez of shiznit taken from tha reflog\&. By default,
\fIcommit@{Nth}\fR
notation is used up in tha output\&. When tha startin commit is specified as
\fIcommit@{now}\fR, output also uses
\fIcommit@{timestamp}\fR
notation instead\&. Under
\-\-pretty=oneline, tha commit message is prefixed wit dis shiznit on tha same line\&. This option cannot be combined with
\-\-reverse\&. Right back up in yo muthafuckin ass. See also
\fBgit-reflog\fR(1)\&.
.RE
.PP
\-\-merge
.RS 4
Afta a gangbangin' failed merge, show refs dat bust a nut on filez havin a cold-ass lil conflict n' don\(cqt exist on all headz ta merge\&.
.RE
.PP
\-\-boundary
.RS 4
Output excluded boundary commits\&. Boundary commits is prefixed with
\-\&.
.RE
.SS "History Simplification"
.sp
Sometimes yo ass is only horny bout partz of tha history, fo' example tha commits modifyin a particular <path>\&. But there be two partz of \fIHistory Simplification\fR, one part is selectin tha commits n' tha other is how tha fuck ta do it, as there be various strategies ta simplify tha history\&.
.sp
Da followin options select tha commits ta be shown:
.PP
<paths>
.RS 4
Commits modifyin tha given <paths> is selected\&.
.RE
.PP
\-\-simplify\-by\-decoration
.RS 4
Commits dat is referred by some branch or tag is selected\&.
.RE
.sp
Note dat extra commits can be shown ta give a meaningful history\&.
.sp
Da followin options affect tha way tha simplification is performed:
.PP
Default mode
.RS 4
Simplifies tha history ta tha simplest history explainin tha final state of tha tree\&. Right back up in yo muthafuckin ass. Simplest cuz it prunes some side branches if tha end result is tha same ol' dirty (i\&.e\&. mergin branches wit tha same content)
.RE
.PP
\-\-full\-history
.RS 4
Same as tha default mode yo, but do not prune some history\&.
.RE
.PP
\-\-dense
.RS 4
Only tha selected commits is shown, plus some ta git a meaningful history\&.
.RE
.PP
\-\-sparse
.RS 4
All commits up in tha simplified history is shown\&.
.RE
.PP
\-\-simplify\-merges
.RS 4
Additionizzle option to
\-\-full\-history
to remove some needless merges from tha resultin history, as there be no selected commits contributin ta dis merge\&.
.RE
.PP
\-\-ancestry\-path
.RS 4
When given a range of commits ta display (e\&.g\&.
\fIcommit1\&.\&.commit2\fR
or
\fIcommit2 ^commit1\fR), only display commits dat exist directly on tha ancestry chain between the
\fIcommit1\fR
and
\fIcommit2\fR, i\&.e\&. commits dat is both descendants of
\fIcommit1\fR, n' ancestors of
\fIcommit2\fR\&.
.RE
.sp
A mo' detailed explanation bigs up\&.
.sp
Suppose you specified foo as tha <paths>\&. We shall call commits dat modify foo !TREESAME, n' tha rest TREESAME\&. (In a gangbangin' finger-lickin' diff filtered fo' foo, they look different n' equal, respectively\&.)
.sp
In tha following, we will always refer ta tha same example history ta illustrate tha differences between simplification settings\&. We assume dat yo ass is filterin fo' a gangbangin' file foo up in dis commit graph:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /   /
        I     B   C   D   E   Y
         \e   /   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\(aq   X
.fi
.if n \{\
.RE
.\}
.sp
.sp
Da horizontal line of history A\-\-\-Q is taken ta be tha straight-up original gangsta parent of each merge\&. Da commits are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
I
is tha initial commit, up in which
foo
exists wit contents \(lqasdf\(rq, n' a gangbangin' file
quux
exists wit contents \(lqquux\(rq\&. Initial commits is compared ta a empty tree, so
I
is !TREESAME\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
In
A,
foo
gotz nuff just \(lqfoo\(rq\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
B
gotz nuff tha same ol' dirty chizzle as
A\&. Its merge
M
is trivial n' hence TREESAME ta all muthafathas\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C
does not chizzle
foo yo, but its merge
N
changes it ta \(lqfoobar\(rq, so it aint TREESAME ta any parent\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D
sets
foo
to \(lqbaz\(rq\&. Its merge
O
combines tha strings from
N
and
D
to \(lqfoobarbaz\(rq; i\&.e\&., it aint TREESAME ta any parent\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
E
changes
quux
to \(lqxyzzy\(rq, n' its merge
P
combines tha strings ta \(lqquux xyzzy\(rq\&.
P
is TREESAME to
O yo, but not to
E\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
X
is a independent root commit dat added a freshly smoked up file
side, and
Y
modified it\&.
Y
is TREESAME to
X\&. Its merge
Q
added
side
to
P, and
Q
is TREESAME to
P yo, but not to
Y\&.
.RE
.sp
rev\-list strutts backwardz all up in history, includin or excludin commits based on whether \-\-full\-history and/or parent rewritin (via \-\-parents or \-\-children) is used\&. Da followin settings is available\&.
.PP
Default mode
.RS 4
Commits is included if they is not TREESAME ta any parent (though dis can be chizzled, see
\-\-sparse
below)\&. If tha commit was a merge, n' dat shiznit was TREESAME ta one parent, follow only dat parent\&. (Even if there be nuff muthafuckin TREESAME muthafathas, follow only one of them\&.) Otherwise, follow all muthafathas\&.
.sp
This thangs up in dis biatch in:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-N\-\-\-O
         /     /   /
        I\-\-\-\-\-\-\-\-\-D
.fi
.if n \{\
.RE
.\}
.sp
Note how tha fuck tha rule ta only follow tha TREESAME parent, if one be available, removed
B
from consideration entirely\&.
C
was considered via
N yo, but is TREESAME\&. Root commits is compared ta a empty tree, so
I
is !TREESAME\&.
.sp
Parent/child relations is only visible with
\-\-parents yo, but dat do not affect tha commits selected up in default mode, so our crazy asses have shown tha parent lines\&.
.RE
.PP
\-\-full\-history without parent rewriting
.RS 4
This mode differs from tha default up in one point: always follow all muthafathaz of a merge, even if it is TREESAME ta one of them\&. Even if mo' than one side of tha merge has commits dat is included, dis do not imply dat tha merge itself is muthafucka! In tha example, we get
.sp
.if n \{\
.RS 4
.\}
.nf
        I  A  B  N  D  O  P  Q
.fi
.if n \{\
.RE
.\}
.sp
M
was excluded cuz it is TREESAME ta both muthafathas\&.
E,
C
and
B
were all strutted yo, but only
B
was !TREESAME, so tha others do not appear\&.
.sp
Note dat without parent rewriting, it aint straight-up possible ta rap bout tha parent/child relationshizzlez between tha commits, so we show dem disconnected\&.
.RE
.PP
\-\-full\-history wit parent rewriting
.RS 4
Ordinary commits is only included if they is !TREESAME (though dis can be chizzled, see
\-\-sparse
below)\&.
.sp
Merges is always included\&. But fuck dat shiznit yo, tha word on tha street is dat they parent list is rewritten: Along each parent, prune away commits dat is not included theyselves\&. This thangs up in dis biatch in
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O\-\-\-P\-\-\-Q
         /     /   /   /   /
        I     B   /   D   /
         \e   /   /   /   /
          `\-\-\-\-\-\-\-\-\-\-\-\-\-\(aq
.fi
.if n \{\
.RE
.\}
.sp
Compare to
\-\-full\-history
without rewritin above\&. Note that
E
was pruned away cuz it is TREESAME yo, but tha parent list of P was rewritten ta contain
E\(aqs parent
I\&. Da same happened for
C
and
N, and
X,
Y
and
Q\&.
.RE
.sp
In addizzle ta tha above settings, you can chizzle whether TREESAME affects inclusion:
.PP
\-\-dense
.RS 4
Commits dat is strutted is included if they is not TREESAME ta any parent\&.
.RE
.PP
\-\-sparse
.RS 4
All commits dat is strutted is included\&.
.sp
Note dat without
\-\-full\-history, dis still simplifies merges: if one of tha muthafathas is TREESAME, we follow only dat one, so tha other sidez of tha merge is never strutted\&.
.RE
.PP
\-\-simplify\-merges
.RS 4
First, build a history graph up in tha same way that
\-\-full\-history
with parent rewritin do (see above)\&.
.sp
Then simplify each commit
C
to its replacement
C\(aq
in tha final history accordin ta tha followin rules:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Set
C\(aq
to
C\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Replace each parent
P
of
C\(aq
with its simplification
P\(aq\&. In tha process, drop muthafathas dat is ancestorz of other muthafathas or dat is root commits TREESAME ta a empty tree, n' remove duplicates yo, but take care ta never drop all muthafathas dat we is TREESAME to\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If afta dis parent rewriting,
C\(aq
is a root or merge commit (has zero or >1 muthafathas), a funky-ass boundary commit, or !TREESAME, it remains\&. Otherwise, it is replaced wit its only parent\&.
.RE
.sp
Da effect of dis is dopest shown by way of comparin to
\-\-full\-history
with parent rewriting\&. Da example turns into:
.sp
.if n \{\
.RS 4
.\}
.nf
          \&.\-A\-\-\-M\-\-\-N\-\-\-O
         /     /       /
        I     B       D
         \e   /       /
          `\-\-\-\-\-\-\-\-\-\(aq
.fi
.if n \{\
.RE
.\}
.sp
Note tha major differences in
N,
P, and
Q
over
\-\-full\-history:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
N\(aqs parent list had
I
removed, cuz it be a ancestor of tha other parent
M\&. Right back up in yo muthafuckin ass. Still,
N
remained cuz it is !TREESAME\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
P\(aqs parent list similarly had
I
removed\&.
P
was then removed straight-up, cuz it had one parent n' is TREESAME\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Q\(aqs parent list had
Y
simplified to
X\&.
X
was then removed, cuz dat shiznit was a TREESAME root\&.
Q
was then removed straight-up, cuz it had one parent n' is TREESAME\&.
.RE
.RE
.sp
Finally, there be a gangbangin' fifth simplification mode available:
.PP
\-\-ancestry\-path
.RS 4
Limit tha displayed commits ta dem directly on tha ancestry chain between tha \(lqfrom\(rq n' \(lqto\(rq commits up in tha given commit range\&. I\&.e\&. only display commits dat is ancestor of tha \(lqto\(rq commit n' descendantz of tha \(lqfrom\(rq commit\&.
.sp
As a example use case, consider tha followin commit history:
.sp
.if n \{\
.RS 4
.\}
.nf
            D\-\-\-E\-\-\-\-\-\-\-F
           /     \e       \e
          B\-\-\-C\-\-\-G\-\-\-H\-\-\-I\-\-\-J
         /                     \e
        A\-\-\-\-\-\-\-K\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
A regular
\fID\&.\&.M\fR
computes tha set of commits dat is ancestors of
M yo, but excludes tha ones dat is ancestors of
D\&. This is useful ta peep what tha fuck happened ta tha history leadin to
M
since
D, up in tha sense dat \(lqwhat do
M
have dat did not exist in
D\(rq\&. Da result up in dis example would be all tha commits, except
A
and
B
(and
D
itself, of course)\&.
.sp
When we wanna smoke up what tha fuck commits in
M
are contaminated wit tha bug introduced by
D
and need fixing, however, we might wanna view only tha subset of
\fID\&.\&.M\fR
that is straight-up descendants of
D, i\&.e\&. excluding
C
and
K\&. This is exactly what tha fuck the
\-\-ancestry\-path
option do\& fo' realz. Applied ta the
\fID\&.\&.M\fR
range, it thangs up in dis biatch in:
.sp
.if n \{\
.RS 4
.\}
.nf
                E\-\-\-\-\-\-\-F
                 \e       \e
                  G\-\-\-H\-\-\-I\-\-\-J
                               \e
                                L\-\-M
.fi
.if n \{\
.RE
.\}
.sp
.RE
.sp
Da \-\-simplify\-by\-decoration option allows you ta view only tha big-ass picture of tha topologizzle of tha history, by omittin commits dat is not referenced by tags\&. Commits is marked as !TREESAME (in other lyrics, kept afta history simplification rulez busted lyrics bout above) if (1) they is referenced by tags, or (2) they chizzle tha contentz of tha paths given on tha command line\& fo' realz. All other commits is marked as TREESAME (subject ta be simplified away)\&.
.SS "Commit Ordering"
.sp
By default, tha commits is shown up in reverse chronological order\&.
.PP
\-\-date\-order
.RS 4
Show no muthafathas before all of its lil pimps is shown yo, but otherwise show commits up in tha commit timestamp order\&.
.RE
.PP
\-\-author\-date\-order
.RS 4
Show no muthafathas before all of its lil pimps is shown yo, but otherwise show commits up in tha lyricist timestamp order\&.
.RE
.PP
\-\-topo\-order
.RS 4
Show no muthafathas before all of its lil pimps is shown, n' avoid showin commits on multiple linez of history intermixed\&.
.sp
For example, up in a cold-ass lil commit history like this:
.sp
.if n \{\
.RS 4
.\}
.nf
    \-\-\-1\-\-\-\-2\-\-\-\-4\-\-\-\-7
        \e              \e
         3\-\-\-\-5\-\-\-\-6\-\-\-\-8\-\-\-
.fi
.if n \{\
.RE
.\}
.sp
where tha numbers denote tha order of commit timestamps,
git rev\-list
and playaz with
\-\-date\-order
show tha commits up in tha timestamp order: 8 7 6 5 4 3 2 1\&.
.sp
With
\-\-topo\-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some olda commits is shown before newer ones up in order ta avoid showin tha commits from two parallel pimpment track mixed together\&.
.RE
.PP
\-\-reverse
.RS 4
Output tha commits up in reverse order\&. Cannot be combined with
\-\-walk\-reflogs\&.
.RE
.SS "Object Traversal"
.sp
These options is mostly targeted fo' packin of Git repositories\&.
.PP
\-\-objects
.RS 4
Print tha object IDz of any object referenced by tha listed commits\&.
\-\-objects foo ^bar
thus means \(lqsend mah crazy ass all object IDs which I need ta downlizzle if I have tha commit object
\fIbar\fR
but not
\fIfoo\fR\(rq\&.
.RE
.PP
\-\-objects\-edge
.RS 4
Similar to
\-\-objects yo, but also print tha IDz of excluded commits prefixed wit a \(lq\-\(rq character\&. This is used by
\fBgit-pack-objects\fR(1)
to build \(lqthin\(rq pack, which recordz objects up in deltified form based on objects contained up in these excluded commits ta reduce network traffic\&.
.RE
.PP
\-\-unpacked
.RS 4
Only useful with
\-\-objects; print tha object IDs dat is not up in packs\&.
.RE
.PP
\-\-no\-walk[=(sorted|unsorted)]
.RS 4
Only show tha given commits yo, but do not traverse they ancestors\&. This has no effect if a range is specified\&. If tha argument
unsorted
is given, tha commits is shown up in tha order they was given on tha command line\&. Otherwise (if
sorted
or no argument was given), tha commits is shown up in reverse chronological order by commit time\&.
.RE
.PP
\-\-do\-walk
.RS 4
Overrides a previous
\-\-no\-walk\&.
.RE
.SS "Commit Formatting"
.PP
\-\-pretty[=<format>], \-\-format=<format>
.RS 4
Pretty\-print tha contentz of tha commit logs up in a given format, where
\fI<format>\fR
can be one of
\fIoneline\fR,
\fIshort\fR,
\fImedium\fR,
\fIfull\fR,
\fIfuller\fR,
\fIemail\fR,
\fIraw\fR
and
\fIformat:<string>\fR\&. Right back up in yo muthafuckin ass. See tha "PRETTY FORMATS" section fo' some additionizzle details fo' each format\&. When omitted, tha format defaults to
\fImedium\fR\&.
.sp
Note: you can specify tha default pretty format up in tha repository configuration (see
\fBgit-config\fR(1))\&.
.RE
.PP
\-\-abbrev\-commit
.RS 4
Instead of showin tha full 40\-byte hexadecimal commit object name, show only a partial prefix\&. Non default number of digits can be specified wit "\-\-abbrev=<n>" (which also modifies diff output, if it is displayed)\&.
.sp
This should make "\-\-pretty=oneline" a whole lot mo' readable fo' playas rockin 80\-column terminals\&.
.RE
.PP
\-\-no\-abbrev\-commit
.RS 4
Show tha full 40\-byte hexadecimal commit object name\&. This negates
\-\-abbrev\-commit
and dem options which imply it like fuckin "\-\-oneline"\&. Well shiiiit, it also overrides the
\fIlog\&.abbrevCommit\fR
variable\&.
.RE
.PP
\-\-oneline
.RS 4
This be a gangbangin' finger-lickin' dirty-ass shorthand fo' "\-\-pretty=oneline \-\-abbrev\-commit" used together\&.
.RE
.PP
\-\-encoding=<encoding>
.RS 4
Da commit objects record tha encodin used fo' tha log message up in they encodin header; dis option can be used ta tell tha command ta re\-code tha commit log message up in tha encodin preferred by tha user\&. For non plumbin commandz dis defaults ta UTF\-8\&.
.RE
.PP
\-\-notes[=<ref>]
.RS 4
Show tha notes (see
\fBgit-notes\fR(1)) dat annotate tha commit, when showin tha commit log message\&. This is tha default for
git log,
git show
and
git whatchanged
commandz when there is no
\-\-pretty,
\-\-format, or
\-\-oneline
option given on tha command line\&.
.sp
By default, tha notes shown is from tha notes refs listed up in the
\fIcore\&.notesRef\fR
and
\fInotes\&.displayRef\fR
variablez (or correspondin environment overrides)\&. Right back up in yo muthafuckin ass. See
\fBgit-config\fR(1)
for mo' details\&.
.sp
With a optional
\fI<ref>\fR
argument, show dis notes ref instead of tha default notes ref(s)\&. Da ref is taken ta be in
refs/notes/
if it aint qualified\&.
.sp
Multiple \-\-notes options can be combined ta control which notes is bein displayed\&. Examples: "\-\-notes=foo" will show only notes from "refs/notes/foo"; "\-\-notes=foo \-\-notes" will show both notes from "refs/notes/foo" n' from tha default notes ref(s)\&.
.RE
.PP
\-\-no\-notes
.RS 4
Do not show notes\&. This negates tha above
\-\-notes
option, by resettin tha list of notes refs from which notes is shown\&. Options is parsed up in tha order given on tha command line, so e\&.g\&. "\-\-notes \-\-notes=foo \-\-no\-notes \-\-notes=bar" will only show notes from "refs/notes/bar"\&.
.RE
.PP
\-\-show\-notes[=<ref>], \-\-[no\-]standard\-notes
.RS 4
These options is deprecated\&. Use tha above \-\-notes/\-\-no\-notes options instead\&.
.RE
.PP
\-\-show\-signature
.RS 4
Peep tha validitizzle of a signed commit object by passin tha signature to
gpg \-\-verify
and show tha output\&.
.RE
.PP
\-\-relative\-date
.RS 4
Synonym for
\-\-date=relative\&.
.RE
.PP
\-\-date=(relative|local|default|iso|rfc|short|raw)
.RS 4
Only takes effect fo' dates shown up in human\-readable format, like fuckin when using
\-\-pretty\&.
log\&.date
config variable sets a thugged-out default value fo' tha log command\(cqs
\-\-date
option\&.
.sp
\-\-date=relative
shows dates relatizzle ta tha current time, e\&.g\&. \(lq2 minutes ago\(rq\&.
.sp
\-\-date=local
shows timestamps up in user\(cqs local time unit\&.
.sp
\-\-date=iso
(or
\-\-date=iso8601) shows timestamps up in ISO 8601 format\&.
.sp
\-\-date=rfc
(or
\-\-date=rfc2822) shows timestamps up in RFC 2822 format, often found up in email lyrics\&.
.sp
\-\-date=short
shows only tha date yo, but not tha time, in
YYYY\-MM\-DD
format\&.
.sp
\-\-date=raw
shows tha date up in tha internal raw Git format
%s %z
format\&.
.sp
\-\-date=default
shows timestamps up in tha original gangsta time unit (either committer\(cqs or author\(cqs)\&.
.RE
.PP
\-\-parents
.RS 4
Print also tha muthafathaz of tha commit (in tha form "commit parent\&...")\& fo' realz. Also enablez parent rewriting, see
\fIHistory Simplification\fR
below\&.
.RE
.PP
\-\-children
.RS 4
Print also tha lil pimpz of tha commit (in tha form "commit child\&...")\& fo' realz. Also enablez parent rewriting, see
\fIHistory Simplification\fR
below\&.
.RE
.PP
\-\-left\-right
.RS 4
Mark which side of a symmetric diff a cold-ass lil commit is reachable from\&. Commits from tha left side is prefixed with
<
and dem from tha right with
>\&. If combined with
\-\-boundary, dem commits is prefixed with
\-\&.
.sp
For example, if you have dis topology:
.sp
.if n \{\
.RS 4
.\}
.nf
             y\-\-\-b\-\-\-b  branch B
            / \e /
           /   \&.
          /   / \e
         o\-\-\-x\-\-\-a\-\-\-a  branch A
.fi
.if n \{\
.RE
.\}
.sp
you would git a output like this:
.sp
.if n \{\
.RS 4
.\}
.nf
        $ git rev\-list \-\-left\-right \-\-boundary \-\-pretty=oneline A\&.\&.\&.B

        >bbbbbbb\&.\&.\&. 3rd on b
        >bbbbbbb\&.\&.\&. 2nd on b
        <aaaaaaa\&.\&.\&. 3rd on a
        <aaaaaaa\&.\&.\&. 2nd on a
        \-yyyyyyy\&.\&.\&. 1st on b
        \-xxxxxxx\&.\&.\&. 1st on a
.fi
.if n \{\
.RE
.\}
.sp
.RE
.PP
\-\-graph
.RS 4
Draw a text\-based graphical representation of tha commit history on tha left hand side of tha output\&. This may cause extra lines ta be printed up in between commits, up in order fo' tha graph history ta be drawn properly\&.
.sp
This enablez parent rewriting, see
\fIHistory Simplification\fR
below\&.
.sp
This implies the
\-\-topo\-order
option by default yo, but the
\-\-date\-order
option may also be specified\&.
.RE
.SS "Diff Formatting"
.sp
Listed below is options dat control tha formattin of diff output\&. Right back up in yo muthafuckin ass. Some of dem is specific ta \fBgit-rev-list\fR(1), however other diff options may be given\&. Right back up in yo muthafuckin ass. See \fBgit-diff-files\fR(1) fo' mo' options\&.
.PP
\-c
.RS 4
With dis option, diff output fo' a merge commit shows tha differences from each of tha muthafathas ta tha merge result simultaneously instead of showin pairwise diff between a parent n' tha result one at a time\&. Furthermore, it lists only filez which was modified from all muthafathas\&.
.RE
.PP
\-\-cc
.RS 4
This flag implies the
\-c
option n' further compresses tha patch output by omittin uninterestin hunks whose contents up in tha muthafathas have only two variants n' tha merge result picks one of dem without modification\&.
.RE
.PP
\-m
.RS 4
This flag make tha merge commits show tha full diff like regular commits; fo' each merge parent, a separate log entry n' diff is generated\& fo' realz. An exception is dat only diff against tha straight-up original gangsta parent is shown when
\-\-first\-parent
option is given; up in dat case, tha output represents tha chizzlez tha merge brought
\fIinto\fR
the then\-current branch\&.
.RE
.PP
\-r
.RS 4
Show recursive diffs\&.
.RE
.PP
\-t
.RS 4
Show tha tree objects up in tha diff output\&. This implies
\-r\&.
.RE
.SH "PRETTY FORMATS"
.sp
If tha commit be a merge, n' if tha pretty\-format aint \fIoneline\fR, \fIemail\fR or \fIraw\fR, a additionizzle line is banged before tha \fIAuthor:\fR line\&. This line begins wit "Merge: " n' tha sha1z of ancestral commits is printed, separated by spaces\&. Note dat tha listed commits may not necessarily be tha list of tha \fBdirect\fR parent commits if you have limited yo' view of history: fo' example, if yo ass is only horny bout chizzlez related ta a cold-ass lil certain directory or file\&.
.sp
There is nuff muthafuckin built\-in formats, n' you can define additionizzle formats by settin a pretty\&.<name> config option ta either another format name, or a \fIformat:\fR string, as busted lyrics bout below (see \fBgit-config\fR(1))\& yo. Here is tha detailz of tha built\-in formats:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIoneline\fR
.sp
.if n \{\
.RS 4
.\}
.nf
<sha1> <title line>
.fi
.if n \{\
.RE
.\}
.sp
This is designed ta be as compact as possible\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIshort\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fImedium\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
Date:   <lyricist date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIfull\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author: <author>
Commit: <committer>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIfuller\fR
.sp
.if n \{\
.RS 4
.\}
.nf
commit <sha1>
Author:     <author>
AuthorDate: <lyricist date>
Commit:     <committer>
CommitDate: <committa date>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIemail\fR
.sp
.if n \{\
.RS 4
.\}
.nf
From <sha1> <date>
From: <author>
Date: <lyricist date>
Subject: [PATCH] <title line>
.fi
.if n \{\
.RE
.\}
.sp
.if n \{\
.RS 4
.\}
.nf
<full commit message>
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIraw\fR
.sp
The
\fIraw\fR
format shows tha entire commit exactly as stored up in tha commit object\&. Notably, tha SHA\-1s is displayed up in full, regardless of whether \-\-abbrev or \-\-no\-abbrev is used, and
\fIparents\fR
information show tha legit parent commits, without takin grafts or history simplification tha fuck into account\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fIformat:<string>\fR
.sp
The
\fIformat:<string>\fR
format allows you ta specify which shiznit you wanna show\&. Well shiiiit, it works a lil bit like printf format, wit tha notable exception dat you git a newline with
\fI%n\fR
instead of
\fI\en\fR\&.
.sp
E\&.g,
\fIformat:"Da lyricist of %h was %an, %ar%nDa title was >>%s<<%n"\fR
would show suttin' like this:
.sp
.if n \{\
.RS 4
.\}
.nf
Da lyricist of fe6e0ee was Junio C Hamano, 23 minutes ago
Da title was >>t4119: test autocomputin \-p<n> fo' traditionizzle diff input\&.<<
.fi
.if n \{\
.RE
.\}
.sp
Da placeholdaz are:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%H\fR: commit hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%h\fR: abbreviated commit hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%T\fR: tree hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%t\fR: abbreviated tree hash
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%P\fR: parent hashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%p\fR: abbreviated parent hashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%an\fR: lyricist name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aN\fR: lyricist name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ae\fR: lyricist email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aE\fR: lyricist email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ad\fR: lyricist date (format respects \-\-date= option)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%aD\fR: lyricist date, RFC2822 style
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ar\fR: lyricist date, relative
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%at\fR: lyricist date, UNIX timestamp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ai\fR: lyricist date, ISO 8601 format
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cn\fR: committa name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cN\fR: committa name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ce\fR: committa email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cE\fR: committa email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cd\fR: committa date
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cD\fR: committa date, RFC2822 style
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%cr\fR: committa date, relative
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ct\fR: committa date, UNIX timestamp
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ci\fR: committa date, ISO 8601 format
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%d\fR: ref names, like tha \-\-decorate option of
\fBgit-log\fR(1)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%e\fR: encoding
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%s\fR: subject
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%f\fR: sanitized subject line, suitable fo' a gangbangin' filename
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%b\fR: body
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%B\fR: raw body (unwrapped subject n' body)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%N\fR: commit notes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GG\fR: raw verification message from GPG fo' a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%G?\fR: show "G" fo' a Dope signature, "B" fo' a Wack signature, "U" fo' a good, untrusted signature n' "N" fo' no signature
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GS\fR: show tha name of tha signer fo' a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%GK\fR: show tha key used ta sign a signed commit
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gD\fR: reflog selector, e\&.g\&.,
refs/stash@{1}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gd\fR: shortened reflog selector, e\&.g\&.,
stash@{1}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gn\fR: reflog identitizzle name
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gN\fR: reflog identitizzle name (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%ge\fR: reflog identitizzle email
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gE\fR: reflog identitizzle email (respectin \&.mailmap, see
\fBgit-shortlog\fR(1)
or
\fBgit-blame\fR(1))
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%gs\fR: reflog subject
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cred\fR: switch color ta red
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cgreen\fR: switch color ta green
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Cblue\fR: switch color ta blue
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%Creset\fR: reset color
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%C(\&...)\fR: color justification, as busted lyrics bout up in color\&.branch\&.* config option; adding
auto,
at tha beginnin will emit color only when flavas is enabled fo' log output (by
color\&.diff,
color\&.ui, or
\-\-color, n' respectin the
auto
settingz of tha forma if we is goin ta a terminal)\&.
auto
alone (i\&.e\&.
%C(auto)) will turn on auto colorin on tha next placeholdaz until tha color is switched again\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%m\fR: left, right or boundary mark
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%n\fR: newline
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%%\fR: a raw
\fI%\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%x00\fR: print a funky-ass byte from a hex code
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%w([<w>[,<i1>[,<i2>]]])\fR: switch line wrapping, like tha \-w option of
\fBgit-shortlog\fR(1)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%<(<N>[,trunc|ltrunc|mtrunc])\fR: make tha next placeholda take at least N columns, paddin spaces on tha right if necessary\&. Optionally truncate all up in tha beginnin (ltrunc), tha middle (mtrunc) or tha end (trunc) if tha output is longer than N columns\&. Note dat truncatin only works erectly wit N >= 2\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%<|(<N>)\fR: make tha next placeholda take at least until Nth columns, paddin spaces on tha right if necessary
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%>(<N>)\fR,
\fI%>|(<N>)\fR: similar to
\fI%<(<N>)\fR,
\fI%<|(<N>)\fR
respectively yo, but paddin spaces on tha left
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%>>(<N>)\fR,
\fI%>>|(<N>)\fR: similar to
\fI%>(<N>)\fR,
\fI%>|(<N>)\fR
respectively, except dat if tha next placeholda takes mo' spaces than given n' there be spaces on its left, use dem spaces
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fI%><(<N>)\fR,
\fI%><|(<N>)\fR: similar to
\fI% <(<N>)\fR,
\fI%<|(<N>)\fR
respectively yo, but paddin both sides (i\&.e\&. tha text is centered)
.RE
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Some placeholdaz may depend on other options given ta tha revision traversal engine\&. For example, tha %g* reflog options will bang a empty strang unless we is traversin reflog entries (e\&.g\&., by git log \-g)\&. Da %d placeholda will use tha "short" decoration format if \-\-decorate was not already provided on tha command line\&.
.sp .5v
.RE
.sp
If you add a + (plus sign) afta \fI%\fR of a placeholder, a line\-feed is banged immediately before tha expansion if n' only if tha placeholda expandz ta a non\-empty string\&.
.sp
If you add a \- (minus sign) afta \fI%\fR of a placeholder, line\-feedz dat immediately precede tha expansion is deleted if n' only if tha placeholda expandz ta a empty string\&.
.sp
If you add a ` ` (space) afta \fI%\fR of a placeholder, a space is banged immediately before tha expansion if n' only if tha placeholda expandz ta a non\-empty string\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fItformat:\fR
.sp
The
\fItformat:\fR
format works exactly like
\fIformat:\fR, except dat it serves up "terminator" semantics instead of "separator" semantics\&. In other lyrics, each commit has tha message terminator characta (usually a newline) appended, rather than a separator placed between entries\&. This means dat tha final entry of a single\-line format is ghon be properly terminated wit a freshly smoked up line, just as tha "oneline" format do\&. For example:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=format:%h 4da45bef \e
  | perl \-pe \(aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\(aq
4da45be
7134973 \-\- NO NEWLINE

$ git log \-2 \-\-pretty=tformat:%h 4da45bef \e
  | perl \-pe \(aq$_ \&.= " \-\- NO NEWLINE\en" unless /\en/\(aq
4da45be
7134973
.fi
.if n \{\
.RE
.\}
.sp
In addition, any unrecognized strang dat has a
%
in it is interpreted as if it has
tformat:
in front of it\&. For example, these two is equivalent:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git log \-2 \-\-pretty=tformat:%h 4da45bef
$ git log \-2 \-\-pretty=%h 4da45bef
.fi
.if n \{\
.RE
.\}
.sp
.RE
.SH "COMMON DIFF OPTIONS"
.PP
\-p, \-u, \-\-patch
.RS 4
Generate patch (see section on generatin patches)\&.
.RE
.PP
\-s, \-\-no\-patch
.RS 4
Suppress diff output\&. Useful fo' commandz like
git show
that show tha patch by default, or ta quit tha effect of
\-\-patch\&.
.RE
.PP
\-U<n>, \-\-unified=<n>
.RS 4
Generate diffs wit <n> linez of context instead of tha usual three\&. Implies
\-p\&.
.RE
.PP
\-\-raw
.RS 4
Generate tha raw format\&.
.RE
.PP
\-\-patch\-with\-raw
.RS 4
Synonym for
\-p \-\-raw\&.
.RE
.PP
\-\-minimal
.RS 4
Spend extra time ta make shizzle tha smallest possible diff is produced\&.
.RE
.PP
\-\-patience
.RS 4
Generate a gangbangin' finger-lickin' diff rockin tha "patience diff" algorithm\&.
.RE
.PP
\-\-histogram
.RS 4
Generate a gangbangin' finger-lickin' diff rockin tha "histogram diff" algorithm\&.
.RE
.PP
\-\-diff\-algorithm={patience|minimal|histogram|myers}
.RS 4
Choose a gangbangin' finger-lickin' diff algorithm\&. Da variants is as bigs up:
.PP
default, myers
.RS 4
Da basic greedy diff algorithm\&. Currently, dis is tha default\&.
.RE
.PP
minimal
.RS 4
Spend extra time ta make shizzle tha smallest possible diff is produced\&.
.RE
.PP
patience
.RS 4
Use "patience diff" algorithm when generatin patches\&.
.RE
.PP
histogram
.RS 4
This algorithm extendz tha patience algorithm ta "support low\-occurrence common elements"\&.
.RE
.sp
For instance, if you configured diff\&.algorithm variable ta a non\-default value n' wanna use tha default one, then you gotta use
\-\-diff\-algorithm=default
option\&.
.RE
.PP
\-\-stat[=<width>[,<name\-width>[,<count>]]]
.RS 4
Generate a gangbangin' finger-lickin' diffstat\&. By default, as much space as necessary is ghon be used fo' tha filename part, n' tha rest fo' tha graph part\&. Maximum width defaults ta terminal width, or 80 columns if not connected ta a terminal, n' can be overridden by
<width>\&. Da width of tha filename part can be limited by givin another width
<name\-width>
afta a cold-ass lil comma\&. Da width of tha graph part can be limited by using
\-\-stat\-graph\-width=<width>
(affects all commandz generatin a stat graph) or by setting
diff\&.statGraphWidth=<width>
(does not affect
git format\-patch)\&. By givin a third parameter
<count>, you can limit tha output ta tha first
<count>
lines, followed by
\&.\&.\&.
if there be more\&.
.sp
These parametas can also be set individually with
\-\-stat\-width=<width>,
\-\-stat\-name\-width=<name\-width>
and
\-\-stat\-count=<count>\&.
.RE
.PP
\-\-numstat
.RS 4
Similar to
\-\-stat yo, but shows number of added n' deleted lines up in decimal notation n' pathname without abbreviation, ta make it mo' machine bumpin'\&. For binary files, outputs two
\-
instead of saying
0 0\&.
.RE
.PP
\-\-shortstat
.RS 4
Output only tha last line of the
\-\-stat
format containin total number of modified files, as well as number of added n' deleted lines\&.
.RE
.PP
\-\-dirstat[=<param1,param2,\&...>]
.RS 4
Output tha distribution of relatizzle amount of chizzlez fo' each sub\-directory\&. Da behavior of
\-\-dirstat
can be customized by passin it a cold-ass lil comma separated list of parameters\&. Da defaults is controlled by the
diff\&.dirstat
configuration variable (see
\fBgit-config\fR(1))\&. Da followin parametas is available:
.PP
changes
.RS 4
Compute tha dirstat numbers by countin tha lines dat done been removed from tha source, or added ta tha destination\&. This ignores tha amount of pure code movements within a gangbangin' file\&. In other lyrics, rearrangin lines up in a gangbangin' file aint counted as much as other chizzles\&. This is tha default behavior when no parameta is given\&.
.RE
.PP
lines
.RS 4
Compute tha dirstat numbers by bustin tha regular line\-based diff analysis, n' summin tha removed/added line counts\&. (For binary files, count 64\-byte chunks instead, since binary filez have no natural concept of lines)\&. This be a mo' expensive
\-\-dirstat
behavior than the
changes
behavior yo, but it do count rearranged lines within a gangbangin' file as much as other chizzles\&. Da resultin output is consistent wit what tha fuck you git from tha other
\-\-*stat
options\&.
.RE
.PP
files
.RS 4
Compute tha dirstat numbers by countin tha number of filez chizzled\&. Each chizzled file counts equally up in tha dirstat analysis\&. This is tha computationally skankyest
\-\-dirstat
behavior, since it do not gotta peep tha file contents at all\&.
.RE
.PP
cumulative
.RS 4
Count chizzlez up in a cold-ass lil lil pimp directory fo' tha parent directory as well\&. Note dat when using
cumulative, tha sum of tha cementages reported may exceed 100%\&. Da default (non\-cumulative) behavior can be specified wit the
noncumulative
parameter\&.
.RE
.PP
<limit>
.RS 4
An integer parameta specifies a cold-ass lil cut\-off cement (3% by default)\&. Directories contributin less than dis cementage of tha chizzlez is not shown up in tha output\&.
.RE
.sp
Example: Da followin will count chizzled files, while ignorin directories wit less than 10% of tha total amount of chizzled files, n' accumulatin lil pimp directory counts up in tha parent directories:
\-\-dirstat=files,10,cumulative\&.
.RE
.PP
\-\-summary
.RS 4
Output a cold-ass lil condensed summary of extended header shiznit like fuckin creations, renames n' mode chizzles\&.
.RE
.PP
\-\-patch\-with\-stat
.RS 4
Synonym for
\-p \-\-stat\&.
.RE
.PP
\-z
.RS 4
Separate tha commits wit NULs instead of wit freshly smoked up newlines\&.
.sp
Also, when
\-\-raw
or
\-\-numstat
has been given, do not munge pathnames n' use NULs as output field terminators\&.
.sp
Without dis option, each pathname output gonna git TAB, LF, double quotes, n' backslash charactas replaced with
\et,
\en,
\e", and
\e\e, respectively, n' tha pathname is ghon be enclosed up in double quotes if any of dem replacements occurred\&.
.RE
.PP
\-\-name\-only
.RS 4
Show only namez of chizzled files\&.
.RE
.PP
\-\-name\-status
.RS 4
Show only names n' statuz of chizzled files\&. Right back up in yo muthafuckin ass. See tha description of the
\-\-diff\-filter
option on what tha fuck tha status lettas mean\&.
.RE
.PP
\-\-submodule[=<format>]
.RS 4
Specify how tha fuck differences up in submodulez is shown\&. When
\-\-submodule
or
\-\-submodule=log
is given, the
\fIlog\fR
format is used\&. This format lists tha commits up in tha range like
\fBgit-submodule\fR(1)summary
does\&. Omittin the
\-\-submodule
option or specifying
\-\-submodule=short, uses the
\fIshort\fR
format\&. This format just shows tha namez of tha commits all up in tha beginnin n' end of tha range\&. Can be tweaked via the
diff\&.submodule
configuration variable\&.
.RE
.PP
\-\-color[=<when>]
.RS 4
Show colored diff\&.
\-\-color
(i\&.e\&. without
\fI=<when>\fR) is tha same ol' dirty as
\-\-color=always\&.
\fI<when>\fR
can be one of
always,
never, or
auto\&.
.RE
.PP
\-\-no\-color
.RS 4
Turn off colored diff\&. Well shiiiit, it is tha same ol' dirty as
\-\-color=never\&.
.RE
.PP
\-\-word\-diff[=<mode>]
.RS 4
Show a word diff, rockin tha <mode> ta delimit chizzled lyrics\&. By default, lyrics is delimited by whitespace; see
\-\-word\-diff\-regex
below\&. Da <mode> defaults to
\fIplain\fR, n' must be one of:
.PP
color
.RS 4
Highlight chizzled lyrics rockin only colors\&. Implies
\-\-color\&.
.RE
.PP
plain
.RS 4
Show lyrics as
[\-removed\-]
and
{+added+}\&. Makes no attempts ta escape tha delimitas if they step tha fuck up in tha input, so tha output may be ambiguous\&.
.RE
.PP
porcelain
.RS 4
Use a special line\-based format intended fo' script consumption\& fo' realz. Added/removed/unchanged runs is printed up in tha usual unified diff format, startin wit a
+/\-/` ` characta all up in tha beginnin of tha line n' extendin ta tha end of tha line\&. Newlines up in tha input is represented by a tilde
~
on a line of its own\&.
.RE
.PP
none
.RS 4
Disable word diff again\&.
.RE
.sp
Note dat despite tha name of tha straight-up original gangsta mode, color is used ta highlight tha chizzled parts up in all modes if enabled\&.
.RE
.PP
\-\-word\-diff\-regex=<regex>
.RS 4
Use <regex> ta decizzle what tha fuck a word is, instead of thankin bout runz of non\-whitespace ta be a word\& fo' realz. Also implies
\-\-word\-diff
unless dat shiznit was already enabled\&.
.sp
Every non\-overlappin match of tha <regex> is considered a word\& fo' realz. Anythang between these matches is considered whitespace n' ignored(!) fo' tha purposez of findin differences\&. Yo ass may wanna append
|[^[:space:]]
to yo' regular expression ta make shizzle dat it matches all non\-whitespace characters\& fo' realz. A match dat gotz nuff a newline is silently truncated(!) all up in tha newline\&.
.sp
Da regex can also be set via a gangbangin' finger-lickin' diff driver or configuration option, see
\fBgitattributes\fR(1)
or
\fBgit-config\fR(1)\&. Givin it explicitly overrides any diff driver or configuration setting\&. Diff drivers override configuration settings\&.
.RE
.PP
\-\-color\-words[=<regex>]
.RS 4
Equivalent to
\-\-word\-diff=color
plus (if a regex was specified)
\-\-word\-diff\-regex=<regex>\&.
.RE
.PP
\-\-no\-renames
.RS 4
Turn off rename detection, even when tha configuration file gives tha default ta do so\&.
.RE
.PP
\-\-check
.RS 4
Warn if chizzlez introduce whitespace errors\&. What is considered whitespace errors is controlled by
core\&.whitespace
configuration\&. By default, trailin whitespaces (includin lines dat solely consist of whitespaces) n' a space characta dat is immediately followed by a tab characta inside tha initial indent of tha line is considered whitespace errors\&. Exits wit non\-zero status if problems is found\&. Not compatible wit \-\-exit\-code\&.
.RE
.PP
\-\-full\-index
.RS 4
Instead of tha straight-up original gangsta handful of characters, show tha full pre\- n' post\-image blob object names on tha "index" line when generatin patch format output\&.
.RE
.PP
\-\-binary
.RS 4
In addizzle to
\-\-full\-index, output a funky-ass binary diff dat can be applied with
git\-apply\&.
.RE
.PP
\-\-abbrev[=<n>]
.RS 4
Instead of showin tha full 40\-byte hexadecimal object name up in diff\-raw format output n' diff\-tree header lines, show only a partial prefix\&. This is independent of the
\-\-full\-index
option above, which controls tha diff\-patch output format\&. Non default number of digits can be specified with
\-\-abbrev=<n>\&.
.RE
.PP
\-B[<n>][/<m>], \-\-break\-rewrites[=[<n>][/<m>]]
.RS 4
Break complete rewrite chizzlez tha fuck into pairz of delete n' create\&. This serves two purposes:
.sp
It affects tha way a cold-ass lil chizzle dat amounts ta a total rewrite of a gangbangin' file not as a seriez of deletion n' insertion mixed together wit a straight-up few lines dat happen ta match textually as tha context yo, but as a single deletion of every last muthafuckin thang oldschool followed by a single insertion of every last muthafuckin thang new, n' tha number
m
controls dis aspect of tha \-B option (defaults ta 60%)\&.
\-B/70%
specifies dat less than 30% of tha original gangsta should remain up in tha result fo' Git ta consider it a total rewrite (i\&.e\&. otherwise tha resultin patch is ghon be a seriez of deletion n' insertion mixed together wit context lines)\&.
.sp
When used wit \-M, a straight-up\-rewritten file be also considered as tha source of a rename (usually \-M only considaz a gangbangin' file dat disappeared as tha source of a rename), n' tha number
n
controls dis aspect of tha \-B option (defaults ta 50%)\&.
\-B20%
specifies dat a cold-ass lil chizzle wit addizzle n' deletion compared ta 20% or mo' of tha file\(cqs size is eligible fo' bein picked up as a possible source of a rename ta another file\&.
.RE
.PP
\-M[<n>], \-\-find\-renames[=<n>]
.RS 4
If generatin diffs, detect n' report renames fo' each commit\&. For followin filez across renames while traversin history, see
\-\-follow\&. If
n
is specified, it aint nuthin but a threshold on tha similaritizzle index (i\&.e\&. amount of addition/deletions compared ta tha file\(cqs size)\&. For example,
\-M90%
means Git should consider a thugged-out delete/add pair ta be a rename if mo' than 90% of tha file hasn\(cqt chizzled\&. Without a
%
sign, tha number is ta be read as a gangbangin' fraction, wit a thugged-out decimal point before it\&. I\&.e\&.,
\-M5
becomes 0\&.5, n' is thus tha same ol' dirty as
\-M50%\&. Right back up in yo muthafuckin ass. Similarly,
\-M05
is tha same ol' dirty as
\-M5%\&. To limit detection ta exact renames, use
\-M100%\&. Da default similaritizzle index is 50%\&.
.RE
.PP
\-C[<n>], \-\-find\-copies[=<n>]
.RS 4
Detect copies as well as renames\&. Right back up in yo muthafuckin ass. See also
\-\-find\-copies\-harder\&. If
n
is specified, it has tha same ol' dirty meanin as for
\-M<n>\&.
.RE
.PP
\-\-find\-copies\-harder
.RS 4
For performizzle reasons, by default,
\-C
option findz copies only if tha original gangsta file of tha copy was modified up in tha same chizzleset\&. This flag make tha command inspect unmodified filez as muthafuckas fo' tha source of copy\&. This be a straight-up high-rollin' operation fo' big-ass projects, so use it wit caution\&. Givin mo' than one
\-C
option has tha same ol' dirty effect\&.
.RE
.PP
\-D, \-\-irreversible\-delete
.RS 4
Omit tha preimage fo' deletes, i\&.e\&. print only tha header but not tha diff between tha preimage and
/dev/null\&. Da resultin patch aint meant ta be applied with
patch
or
git apply; dis is solely fo' playas whoz ass wanna just concentrate on reviewin tha text afta tha chizzle\&. In addition, tha output obviously lack enough shiznit ta apply such a patch up in reverse, even manually, hence tha name of tha option\&.
.sp
When used together with
\-B, omit also tha preimage up in tha deletion part of a thugged-out delete/create pair\&.
.RE
.PP
\-l<num>
.RS 4
The
\-M
and
\-C
options require O(n^2) processin time where n is tha number of potential rename/copy targets\&. This option prevents rename/copy detection from hustlin if tha number of rename/copy targets exceedz tha specified number\&.
.RE
.PP
\-\-diff\-filter=[(A|C|D|M|R|T|U|X|B)\&...[*]]
.RS 4
Select only filez dat is Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have they type (i\&.e\&. regular file, symlink, submodule, \&...) chizzled (T), is Unmerged (U), is Unknown (X), or have had they pairin Broken (B)\& fo' realz. Any combination of tha filta charactas (includin none) can be used\&. When
*
(All\-or\-none) be added ta tha combination, all paths is selected if there be any file dat matches other criteria up in tha comparison; if there is no file dat matches other criteria, not a god damn thang is selected\&.
.RE
.PP
\-S<string>
.RS 4
Look fo' differences dat chizzle tha number of occurrencez of tha specified strang (i\&.e\&. addition/deletion) up in a gangbangin' file\&. Intended fo' tha scripter\(cqs use\&.
.sp
It be useful when you\(cqre lookin fo' a exact block of code (like a struct), n' wanna know tha history of dat block since it first came tha fuck into being: use tha feature iteratively ta feed tha bangin-ass block up in tha preimage back into
\-S, n' keep goin until you git tha straight-up first version of tha block\&.
.RE
.PP
\-G<regex>
.RS 4
Look fo' differences whose patch text gotz nuff added/removed lines dat match <regex>\&.
.sp
To illustrate tha difference between
\-S<regex> \-\-pickaxe\-regex
and
\-G<regex>, consider a cold-ass lil commit wit tha followin diff up in tha same file:
.sp
.if n \{\
.RS 4
.\}
.nf
+    return !regexec(regexp, two\->ptr, 1, &regmatch, 0);
\&.\&.\&.
\-    hit = !regexec(regexp, mf2\&.ptr, 1, &regmatch, 0);
.fi
.if n \{\
.RE
.\}
.sp
While
git log \-G"regexec\e(regexp"
will show dis commit,
git log \-S"regexec\e(regexp" \-\-pickaxe\-regex
will not (because tha number of occurrencez of dat strang did not chizzle)\&.
.sp
See the
\fIpickaxe\fR
entry in
\fBgitdiffcore\fR(7)
for mo' shiznit\&.
.RE
.PP
\-\-pickaxe\-all
.RS 4
When
\-S
or
\-G
findz a cold-ass lil chizzle, show all tha chizzlez up in dat chizzleset, not just tha filez dat contain tha chizzle up in <string>\&.
.RE
.PP
\-\-pickaxe\-regex
.RS 4
Treat tha <string> given to
\-S
as a extended POSIX regular expression ta match\&.
.RE
.PP
\-O<orderfile>
.RS 4
Output tha patch up in tha order specified up in tha <orderfile>, which has one shell glob pattern per line\&. This overrides the
diff\&.orderfile
configuration variable (see
\fBgit-config\fR(1))\&. To cancel
diff\&.orderfile, use
\-O/dev/null\&.
.RE
.PP
\-R
.RS 4
Swap two inputs; dat is, show differences from index or on\-disk file ta tree contents\&.
.RE
.PP
\-\-relative[=<path>]
.RS 4
When run from a subdirectory of tha project, it can be holla'd at ta exclude chizzlez outside tha directory n' show pathnames relatizzle ta it wit dis option\&. When yo ass is not up in a subdirectory (e\&.g\&. up in a funky-ass bare repository), you can name which subdirectory ta make tha output relatizzle ta by givin a <path> as a argument\&.
.RE
.PP
\-a, \-\-text
.RS 4
Treat all filez as text\&.
.RE
.PP
\-\-ignore\-space\-at\-eol
.RS 4
Ignore chizzlez up in whitespace at EOL\&.
.RE
.PP
\-b, \-\-ignore\-space\-change
.RS 4
Ignore chizzlez up in amount of whitespace\&. This ignores whitespace at line end, n' considaz all other sequencez of one or mo' whitespace charactas ta be equivalent\&.
.RE
.PP
\-w, \-\-ignore\-all\-space
.RS 4
Ignore whitespace when comparin lines\&. This ignores differences even if one line has whitespace where tha other line has none\&.
.RE
.PP
\-\-ignore\-blank\-lines
.RS 4
Ignore chizzlez whose lines is all blank\&.
.RE
.PP
\-\-inter\-hunk\-context=<lines>
.RS 4
Show tha context between diff hunks, up ta tha specified number of lines, thereby fusin hunks dat is close ta each other\&.
.RE
.PP
\-W, \-\-function\-context
.RS 4
Show whole surroundin functionz of chizzles\&.
.RE
.PP
\-\-ext\-diff
.RS 4
Allow a external diff helper ta be executed\&. If you set a external diff driver with
\fBgitattributes\fR(5), you need ta use dis option with
\fBgit-log\fR(1)
and playas\&.
.RE
.PP
\-\-no\-ext\-diff
.RS 4
Disallow external diff drivers\&.
.RE
.PP
\-\-textconv, \-\-no\-textconv
.RS 4
Allow (or disallow) external text conversion filtas ta be run when comparin binary files\&. Right back up in yo muthafuckin ass. See
\fBgitattributes\fR(5)
for details\&. Because textconv filtas is typically a one\-way conversion, tha resultin diff is suitable fo' human consumption yo, but cannot be applied\&. For dis reason, textconv filtas is enabled by default only for
\fBgit-diff\fR(1)
and
\fBgit-log\fR(1) yo, but not for
\fBgit-format-patch\fR(1)
or diff plumbin commands\&.
.RE
.PP
\-\-ignore\-submodules[=<when>]
.RS 4
Ignore chizzlez ta submodulez up in tha diff generation\&. <when> can be either "none", "untracked", "dirty" or "all", which is tha default\&. Usin "none" will consider tha submodule modified when it either gotz nuff untracked or modified filez or its HEAD differs from tha commit recorded up in tha superproject n' can be used ta override any settingz of the
\fIignore\fR
option in
\fBgit-config\fR(1)
or
\fBgitmodules\fR(5)\&. When "untracked" is used submodulez is not considered dirty when they only contain untracked content (but they is still scanned fo' modified content)\&. Usin "dirty" ignores all chizzlez ta tha work tree of submodules, only chizzlez ta tha commits stored up in tha superproject is shown (this was tha behavior until 1\&.7\&.0)\&. Usin "all" hides all chizzlez ta submodules\&.
.RE
.PP
\-\-src\-prefix=<prefix>
.RS 4
Show tha given source prefix instead of "a/"\&.
.RE
.PP
\-\-dst\-prefix=<prefix>
.RS 4
Show tha given destination prefix instead of "b/"\&.
.RE
.PP
\-\-no\-prefix
.RS 4
Do not show any source or destination prefix\&.
.RE
.sp
For mo' detailed explanation on these common options, peep also \fBgitdiffcore\fR(7)\&.
.SH "GENERATING PATCHES WITH -P"
.sp
When "git\-diff\-index", "git\-diff\-tree", or "git\-diff\-files" is run wit a \fI\-p\fR option, "git diff" without tha \fI\-\-raw\fR option, or "git log" wit tha "\-p" option, they do not produce tha output busted lyrics bout above; instead they produce a patch file\&. Yo ass can customize tha creation of such patches via tha GIT_EXTERNAL_DIFF n' tha GIT_DIFF_OPTS environment variables\&.
.sp
What tha \-p option produces is slightly different from tha traditionizzle diff format:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
It be preceded wit a "git diff" header dat be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-git a/file1 b/file2
.fi
.if n \{\
.RE
.\}
.sp
The
a/
and
b/
filenames is tha same unless rename/copy is involved\&. Especially, even fo' a cold-ass lil creation or a thugged-out deletion,
/dev/null
is
\fInot\fR
used up in place of the
a/
or
b/
filenames\&.
.sp
When rename/copy is involved,
file1
and
file2
show tha name of tha source file of tha rename/copy n' tha name of tha file dat rename/copy produces, respectively\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
It be followed by one or mo' extended header lines:
.sp
.if n \{\
.RS 4
.\}
.nf
old mode <mode>
new mode <mode>
deleted file mode <mode>
new file mode <mode>
copy from <path>
copy ta <path>
rename from <path>
rename ta <path>
similaritizzle index <number>
dissimilaritizzle index <number>
index <hash>\&.\&.<hash> <mode>
.fi
.if n \{\
.RE
.\}
.sp
File modes is printed as 6\-digit octal numbers includin tha file type n' file permission bits\&.
.sp
Path names up in extended headaz do not include the
a/
and
b/
prefixes\&.
.sp
Da similaritizzle index is tha cementage of unchanged lines, n' tha dissimilaritizzle index is tha cementage of chizzled lines\&. Well shiiiit, it aint nuthin but a rounded down integer, followed by a cement sign\&. Da similaritizzle index value of 100% is thus reserved fo' two equal files, while 100% dissimilaritizzle means dat no line from tha oldschool file juiced it up tha fuck into tha freshly smoked up one\&.
.sp
Da index line includes tha SHA\-1 checksum before n' afta tha chizzle\&. Da <mode> is included if tha file mode do not chizzle; otherwise, separate lines indicate tha oldschool n' tha freshly smoked up mode\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
TAB, LF, double quote n' backslash charactas up in pathnames is represented as
\et,
\en,
\e"
and
\e\e, respectively\&. If there is need fo' such substitution then tha whole pathname is put up in double quotes\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
All the
file1
filez up in tha output refer ta filez before tha commit, n' all the
file2
filez refer ta filez afta tha commit\&. Well shiiiit, it is incorrect ta apply each chizzle ta each file sequentially\&. For example, dis patch will swap a n' b:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-git a/a b/b
rename from a
rename ta b
diff \-\-git a/b b/a
rename from b
rename ta a
.fi
.if n \{\
.RE
.\}
.RE
.SH "COMBINED DIFF FORMAT"
.sp
Any diff\-generatin command can take tha \(oq\-c` or \-\-cc option ta produce a \fIcombined diff\fR when showin a merge\&. This is tha default format when showin merges wit \fBgit-diff\fR(1) or \fBgit-show\fR(1)\&. Note also dat you can give tha `\-m\(cq option ta any of these commandz ta force generation of diffs wit individual muthafathaz of a merge\&.
.sp
A \fIcombined diff\fR format be lookin like this:
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-combined describe\&.c
index fabadb8,cc95eb0\&.\&.4866510
\-\-\- a/describe\&.c
+++ b/describe\&.c
@@@ \-98,20 \-98,12 +98,20 @@@
        return (a_date > b_date) , biatch? \-1 : (a_date == b_date) , biatch? 0 : 1;
  }

\- static void describe(char *arg)
 \-static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +      unsigned char sha1[20];
 +      struct commit *cmit;
        struct commit_list *list;
        static int initialized = 0;
        struct commit_name *n;

 +      if (get_sha1(arg, sha1) < 0)
 +              usage(describe_usage);
 +      cmit = lookup_commit_reference(sha1);
 +      if (!cmit)
 +              usage(describe_usage);
 +
        if (!initialized) {
                initialized = 1;
                for_each_ref(get_name);
.fi
.if n \{\
.RE
.\}
.sp

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
It be preceded wit a "git diff" header, dat be lookin like dis (when
\fI\-c\fR
option is used):
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-combined file
.fi
.if n \{\
.RE
.\}
.sp
or like dis (when
\fI\-\-cc\fR
option is used):
.sp
.if n \{\
.RS 4
.\}
.nf
diff \-\-cc file
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
It be followed by one or mo' extended header lines (this example shows a merge wit two muthafathas):
.sp
.if n \{\
.RS 4
.\}
.nf
index <hash>,<hash>\&.\&.<hash>
mode <mode>,<mode>\&.\&.<mode>
new file mode <mode>
deleted file mode <mode>,<mode>
.fi
.if n \{\
.RE
.\}
.sp
The
mode <mode>,<mode>\&.\&.<mode>
line appears only if at least one of tha <mode> is different from tha rest\&. Extended headaz wit shiznit bout detected contents movement (renames n' copyin detection) is designed ta work wit diff of two <tree\-ish> n' is not used by combined diff format\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
It be followed by two\-line from\-file/to\-file header
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-\- a/file
+++ b/file
.fi
.if n \{\
.RE
.\}
.sp
Similar ta two\-line header fo' traditional
\fIunified\fR
diff format,
/dev/null
is used ta signal pimped or deleted files\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Chunk header format is modified ta prevent playas from accidentally feedin it to
patch \-p1\&. Combined diff format was pimped fo' review of merge commit chizzles, n' was not meant fo' apply\&. Da chizzle is similar ta tha chizzle up in tha extended
\fIindex\fR
header:
.sp
.if n \{\
.RS 4
.\}
.nf
@@@ <from\-file\-range> <from\-file\-range> <to\-file\-range> @@@
.fi
.if n \{\
.RE
.\}
.sp
There is (number of muthafathas + 1)
@
charactas up in tha chunk header fo' combined diff format\&.
.RE
.sp
Unlike tha traditionizzle \fIunified\fR diff format, which shows two filez A n' B wit a single column dat has \- (minus \(em appears up in A but removed up in B), + (plus \(em missin up in A but added ta B), or " " (space \(em unchanged) prefix, dis format compares two or mo' filez file1, file2,\&... wit one file X, n' shows how tha fuck X differs from each of fileN\&. One column fo' each of fileN is prepended ta tha output line ta note how tha fuck X\(cqs line is different from it\&.
.sp
A \- characta up in tha column N means dat tha line appears up in fileN but it do not step tha fuck up in tha result\& fo' realz. A + characta up in tha column N means dat tha line appears up in tha result, n' fileN aint gots dat line (in other lyrics, tha line was added, from tha deal wit view of dat parent)\&.
.sp
In tha above example output, tha function signature was chizzled from both filez (hence two \- removals from both file1 n' file2, plus ++ ta mean one line dat was added do not step tha fuck up in either file1 or file2)\& fo' realz. Also eight other lines is tha same from file1 but do not step tha fuck up in file2 (hence prefixed wit +)\&.
.sp
When shown by git diff\-tree \-c, it compares tha muthafathaz of a merge commit wit tha merge result (i\&.e\&. file1\&.\&.fileN is tha muthafathas)\&. When shown by git diff\-filez \-c, it compares tha two unresolved merge muthafathas wit tha hustlin tree file (i\&.e\&. file1 is stage 2 aka "our version", file2 is stage 3 aka "their version")\&.
.SH "EXAMPLES"
.PP
git log \-\-no\-merges
.RS 4
Show tha whole commit history yo, but skip any merges
.RE
.PP
git log v2\&.6\&.12\&.\&. include/scsi drivers/scsi
.RS 4
Show all commits since version
\fIv2\&.6\&.12\fR
that chizzled any file up in the
include/scsi
or
drivers/scsi
subdirectories
.RE
.PP
git log \-\-since="2 weeks ago" \-\- gitk
.RS 4
Show tha chizzlez durin tha last two weeks ta tha file
\fIgitk\fR\&. Da \(lq\-\-\(rq is necessary ta avoid mad drama wit the
\fBbranch\fR
named
\fIgitk\fR
.RE
.PP
git log \-\-name\-status release\&.\&.test
.RS 4
Show tha commits dat is up in tha "test" branch but not yet up in tha "release" branch, along wit tha list of paths each commit modifies\&.
.RE
.PP
git log \-\-follow builtin/rev\-list\&.c
.RS 4
Shows tha commits dat chizzled
builtin/rev\-list\&.c, includin dem commits dat occurred before tha file was given its present name\&.
.RE
.PP
git log \-\-branches \-\-not \-\-remotes=origin
.RS 4
Shows all commits dat is up in any of local branches but not up in any of remote\-trackin branches for
\fIorigin\fR
(what you have dat origin don\(cqt)\&.
.RE
.PP
git log masta \-\-not \-\-remotes=*/master
.RS 4
Shows all commits dat is up in local masta but not up in any remote repository masta branches\&.
.RE
.PP
git log \-p \-m \-\-first\-parent
.RS 4
Shows tha history includin chizzle diffs yo, but only from tha \(lqmain branch\(rq perspective, skippin commits dat come from merged branches, n' showin full diffz of chizzlez introduced by tha merges\&. This make sense only when followin a strict policy of mergin all topic branches when stayin on a single integration branch\&.
.RE
.PP
git log \-L \(aq/int main/\(aq,/^}/:main\&.c
.RS 4
Shows how tha fuck tha function
main()
in tha file
main\&.c
evolved over time\&.
.RE
.PP
git log \-3
.RS 4
Limits tha number of commits ta show ta 3\&.
.RE
.SH "DISCUSSION"
.sp
At tha core level, Git is characta encodin agnostic\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da pathnames recorded up in tha index n' up in tha tree objects is treated as uninterpreted sequencez of non\-NUL bytes\&. What readdir(2) returns is what tha fuck is recorded n' compared wit tha data Git keeps track of, which up in turn is sposed ta fuckin be what tha fuck lstat(2) n' creat(2) accepts\&. There is no such thang as pathname encodin translation\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da contentz of tha blob objects is uninterpreted sequencez of bytes\&. There is no encodin translation all up in tha core level\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Da commit log lyrics is uninterpreted sequencez of non\-NUL bytes\&.
.RE
.sp
Although we encourage dat tha commit log lyrics is encoded up in UTF\-8, both tha core n' Git Porcelain is designed not ta force UTF\-8 on projects\&. If all participantz of a particular project find it mo' convenient ta use legacy encodings, Git do not forbid it\&. But fuck dat shiznit yo, tha word on tha street is dat there be all dem thangs ta keep up in mind\&.
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
\fIgit commit\fR
and
\fIgit commit\-tree\fR
issues a warnin if tha commit log message given ta it do not be lookin like a valid UTF\-8 string, unless you explicitly say yo' project uses a legacy encoding\&. Da way ta say dis is ta have i18n\&.commitencodin in
\&.git/config
file, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[i18n]
        commitencodin = ISO\-8859\-1
.fi
.if n \{\
.RE
.\}
.sp
Commit objects pimped wit tha above settin record tha value of
i18n\&.commitencoding
in its
encoding
header\&. This is ta help other playas whoz ass peep dem later\&. Lack of dis header implies dat tha commit log message is encoded up in UTF\-8\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
\fIgit log\fR,
\fIgit show\fR,
\fIgit blame\fR
and playaz peep the
encoding
header of a cold-ass lil commit object, n' try ta re\-code tha log message tha fuck into UTF\-8 unless otherwise specified\&. Yo ass can specify tha desired output encodin with
i18n\&.logoutputencoding
in
\&.git/config
file, like this:
.sp
.if n \{\
.RS 4
.\}
.nf
[i18n]
        logoutputencodin = ISO\-8859\-1
.fi
.if n \{\
.RE
.\}
.sp
If you aint gots dis configuration variable, tha value of
i18n\&.commitencoding
is used instead\&.
.RE
.sp
Note dat our phat asses deliberately chose not ta re\-code tha commit log message when a cold-ass lil commit is made ta force UTF\-8 all up in tha commit object level, cuz re\-codin ta UTF\-8 aint necessarily a reversible operation\&.
.SH "CONFIGURATION"
.sp
See \fBgit-config\fR(1) fo' core variablez n' \fBgit-diff\fR(1) fo' settings related ta diff generation\&.
.PP
format\&.pretty
.RS 4
Default fo' the
\-\-format
option\&. (See
\fIPretty Formats\fR
above\&.) Defaults to
medium\&.
.RE
.PP
i18n\&.logOutputEncoding
.RS 4
Encodin ta use when displayin logs\&. (See
\fIRap\fR
above\&.) Defaults ta tha value of
i18n\&.commitEncoding
if set, n' UTF\-8 otherwise\&.
.RE
.PP
log\&.date
.RS 4
Default format fo' human\-readable dates\&. (Compare the
\-\-date
option\&.) Defaults ta "default", which means ta write dates like
Sat May 8 19:35:34 2010 \-0500\&.
.RE
.PP
log\&.showroot
.RS 4
If
false,
git log
and related commandz aint gonna treat tha initial commit as a funky-ass big-ass creation event\& fo' realz. Any root commits in
git log \-p
output would be shown without a gangbangin' finger-lickin' diff attached\&. Da default is
true\&.
.RE
.PP
mailmap\&.*
.RS 4
See
\fBgit-shortlog\fR(1)\&.
.RE
.PP
notes\&.displayRef
.RS 4
Which refs, up in addizzle ta tha default set by
core\&.notesRef
or
\fIGIT_NOTES_REF\fR, ta read notes from when showin commit lyrics wit the
log
family of commands\&. Right back up in yo muthafuckin ass. See
\fBgit-notes\fR(1)\&.
.sp
May be a unabbreviated ref name or a glob n' may be specified multiple times\& fo' realz. A warnin is ghon be issued fo' refs dat do not exist yo, but a glob dat do not match any refs is silently ignored\&.
.sp
This settin can be disabled by the
\-\-no\-notes
option, overridden by the
\fIGIT_NOTES_DISPLAY_REF\fR
environment variable, n' overridden by the
\-\-notes=<ref>
option\&.
.RE
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
