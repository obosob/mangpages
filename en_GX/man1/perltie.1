.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTIE 1"
.TH PERLTIE 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perltie \- how tha fuck ta hide a object class up in a simple variable
.IX Xref "tie"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& tie VARIABLE, CLASSNAME, LIST
\&
\& $object = tied VARIABLE
\&
\& untie VARIABLE
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Prior ta release 5.0 of Perl, a programmer could use \fIdbmopen()\fR
to connect a on-disk database up in tha standard Unix \fIdbm\fR\|(3x)
format magically ta a \f(CW%HASH\fR up in they program.  But fuck dat shiznit yo, tha word on tha street is dat they Perl was either
built wit one particular dbm library or another yo, but not both, and
you couldn't extend dis mechanizzle ta other packages or typez of variables.
.PP
Now you can.
.PP
Da \fItie()\fR function bindz a variable ta a cold-ass lil class (package) dat will provide
the implementation fo' access methodz fo' dat variable.  Once dis magic
has been performed, accessin a tied variable automatically triggers
method calls up in tha proper class.  Da complexitizzle of tha class is
hidden behind magic methodz calls.  Da method names is up in \s-1ALL CAPS,\s0
which be a cold-ass lil convention dat Perl uses ta indicate dat they called
implicitly rather than explicitly\*(--just like tha \s-1\fIBEGIN\s0()\fR n' \s-1\fIEND\s0()\fR
functions.
.PP
In tha \fItie()\fR call, \f(CW\*(C`VARIABLE\*(C'\fR is tha name of tha variable ta be
enchanted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \f(CW\*(C`CLASSNAME\*(C'\fR is tha name of a cold-ass lil class implementin objects of
the erect type.  Any additionizzle arguments up in tha \f(CW\*(C`LIST\*(C'\fR is passed to
the appropriate constructor method fo' dat class\*(--meanin \s-1\fITIESCALAR\s0()\fR,
\&\s-1\fITIEARRAY\s0()\fR, \s-1\fITIEHASH\s0()\fR, or \s-1\fITIEHANDLE\s0()\fR.  (Typically these is arguments
like fuckin might be passed ta tha \fIdbminit()\fR function of C.) Da object
returned by tha \*(L"new\*(R" method be also returned by tha \fItie()\fR function,
which would be useful if you wanted ta access other methodz in
\&\f(CW\*(C`CLASSNAME\*(C'\fR. (Yo ass don't straight-up gotta return a reference ta a right
\&\*(L"type\*(R" (e.g., \s-1HASH\s0 or \f(CW\*(C`CLASSNAME\*(C'\fR) so long as itz a properly pimped
object.)  Yo ass can also retrieve a reference ta tha underlyin object
usin tha \fItied()\fR function.
.PP
Unlike \fIdbmopen()\fR, tha \fItie()\fR function aint gonna \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR a module
for you\*(--you need ta do dat explicitly yo ass.
.SS "Tyin Scalars"
.IX Xref "scalar, tying"
.IX Subsection "Tyin Scalars"
A class implementin a tied scalar should define tha followin methods:
\&\s-1TIESCALAR, FETCH, STORE,\s0 n' possibly \s-1UNTIE\s0 and/or \s-1DESTROY.\s0
.PP
Letz peep each up in turn, rockin as a example a tie class for
scalars dat allows tha user ta do suttin' like:
.PP
.Vb 2
\&    tie $his_speed, \*(AqNice\*(Aq, getppid();
\&    tie $my_speed,  \*(AqNice\*(Aq, $$;
.Ve
.PP
And now whenever either of dem variablez be accessed, its current
system prioritizzle is retrieved n' returned. Y'all KNOW dat shit, muthafucka!  If dem variablez is set,
then tha processs prioritizzle is chizzled!
.PP
We bout ta use Jarkko Hietaniemi <\fIjhi@iki.fi\fR>z BSD::Resource class (not
included) ta access tha \s-1PRIO_PROCESS, PRIO_MIN,\s0 n' \s-1PRIO_MAX\s0 constants
from yo' system, as well as tha \fIgetpriority()\fR n' \fIsetpriority()\fR system
calls.  Herez tha preamble of tha class.
.PP
.Vb 5
\&    package Nice;
\&    use Carp;
\&    use BSD::Resource;
\&    use strict;
\&    $Nice::DEBUG = 0 unless defined $Nice::DEBUG;
.Ve
.IP "\s-1TIESCALAR\s0 classname, \s-1LIST \s0" 4
.IX Xref "TIESCALAR"
.IX Item "TIESCALAR classname, LIST "
This is tha constructor fo' tha class.  That means it is
sposed ta fuckin return a pimped reference ta a freshly smoked up scalar
(probably anonymous) dat itz bustin.  For example:
.Sp
.Vb 3
\&    sub TIESCALAR {
\&        mah $class = shift;
\&        mah $pid = shift || $$; # 0 means me
\&
\&        if ($pid !~ /^\ed+$/) {
\&            carp "Nice::Tie::Scalar gots non\-numeric pid $pid" if $^W;
\&            return undef;
\&        }
\&
\&        unless (kill 0, $pid) { # EPERM or ERSCH, no diggity
\&            carp "Nice::Tie::Scalar gots wack pid $pid: $!" if $^W;
\&            return undef;
\&        }
\&
\&        return bless \e$pid, $class;
\&    }
.Ve
.Sp
This tie class has chosen ta return a error rather than raisin an
exception if its constructor should fail.  While dis is how tha fuck \fIdbmopen()\fR works,
other classes may well not wish ta be all kindsa forgiving.  It checks tha global
variable \f(CW$^W\fR ta peep whether ta emit a lil' bit of noise anyway.
.IP "\s-1FETCH\s0 this" 4
.IX Xref "FETCH"
.IX Item "FETCH this"
This method is ghon be triggered every last muthafuckin time tha tied variable be accessed
(read).  It takes no arguments beyond its self reference, which is the
object representin tha scalar our phat asses dealin with.  Because up in dis case
we're rockin just a \s-1SCALAR\s0 ref fo' tha tied scalar object, a simple $$self
allows tha method ta git all up in tha real value stored there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  In our example
below, dat real value is tha process \s-1ID\s0 ta which we've tied our variable.
.Sp
.Vb 10
\&    sub FETCH {
\&        mah $self = shift;
\&        confess "wrong type" unless ref $self;
\&        croak "usage error" if @_;
\&        mah $nicety;
\&        local($!) = 0;
\&        $nicety = getpriority(PRIO_PROCESS, $$self);
\&        if ($!) { croak "getprioritizzle failed: $!" }
\&        return $nicety;
\&    }
.Ve
.Sp
This time we've decided ta blow up (raise a exception) if tha renice
fails\*(--therez no place fo' our asses ta return a error otherwise, n' it's
probably tha right thang ta do.
.IP "\s-1STORE\s0 this, value" 4
.IX Xref "STORE"
.IX Item "STORE this, value"
This method is ghon be triggered every last muthafuckin time tha tied variable is set
(assigned).  Beyond its self reference, it also expects one (and only one)
argument: tha freshly smoked up value tha user is tryin ta assign. I aint talkin' bout chicken n' gravy biatch. Don't worry about
returnin a value from \s-1STORE\s0; tha semantic of assignment returnin the
assigned value is implemented wit \s-1FETCH.\s0
.Sp
.Vb 5
\&    sub STORE {
\&        mah $self = shift;
\&        confess "wrong type" unless ref $self;
\&        mah $new_nicety = shift;
\&        croak "usage error" if @_;
\&
\&        if ($new_nicety < PRIO_MIN) {
\&            carp sprintf
\&              "WARNING: prioritizzle %d less than minimum system prioritizzle %d",
\&                  $new_nicety, PRIO_MIN if $^W;
\&            $new_nicety = PRIO_MIN;
\&        }
\&
\&        if ($new_nicety > PRIO_MAX) {
\&            carp sprintf
\&              "WARNING: prioritizzle %d pimped outa than maximum system prioritizzle %d",
\&                  $new_nicety, PRIO_MAX if $^W;
\&            $new_nicety = PRIO_MAX;
\&        }
\&
\&        unless (defined setpriority(PRIO_PROCESS, $$self, $new_nicety)) {
\&            confess "setprioritizzle failed: $!";
\&        }
\&    }
.Ve
.IP "\s-1UNTIE\s0 this" 4
.IX Xref "UNTIE"
.IX Item "UNTIE this"
This method is ghon be triggered when tha \f(CW\*(C`untie\*(C'\fR occurs. This can be useful
if tha class need ta know when no further calls is ghon be made. (Except \s-1DESTROY\s0
of course.) See "Da \f(CW\*(C`untie\*(C'\fR Gotcha" below fo' mo' details.
.IP "\s-1DESTROY\s0 this" 4
.IX Xref "DESTROY"
.IX Item "DESTROY this"
This method is ghon be triggered when tha tied variable need ta be destructed.
As wit other object classes, such a method is seldom necessary, cuz Perl
deallocates its moribund objectz memory fo' you automatically\*(--this aint
\&\*(C+, you know.  We bout ta bust a \s-1DESTROY\s0 method here fo' debuggin purposes only.
.Sp
.Vb 5
\&    sub DESTROY {
\&        mah $self = shift;
\&        confess "wrong type" unless ref $self;
\&        carp "[ Nice::DESTROY pid $$self ]" if $Nice::DEBUG;
\&    }
.Ve
.PP
Thatz bout all there is ta dat shit.  Actually, itz mo' than all there
is ta it, cuz we've done all dem sick thangs here fo' tha sake
of completeness, robustness, n' general aesthetics.  Simpler
\&\s-1TIESCALAR\s0 classes is certainly possible.
.SS "Tyin Arrays"
.IX Xref "array, tying"
.IX Subsection "Tyin Arrays"
A class implementin a tied ordinary array should define tha following
methods: \s-1TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE\s0 n' like \s-1UNTIE\s0 and/or \s-1DESTROY.\s0
.PP
\&\s-1FETCHSIZE\s0 n' \s-1STORESIZE\s0 is used ta provide \f(CW$#array\fR and
equivalent \f(CW\*(C`scalar(@array)\*(C'\fR access.
.PP
Da methodz \s-1POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE,\s0 n' \s-1EXISTS\s0 are
required if tha perl operator wit tha correspondin (but lowercase) name
is ta operate on tha tied array. Da \fBTie::Array\fR class can be used as a
base class ta implement tha straight-up original gangsta five of these up in termz of tha basic
methodz above.  Da default implementationz of \s-1DELETE\s0 n' \s-1EXISTS\s0 in
\&\fBTie::Array\fR simply \f(CW\*(C`croak\*(C'\fR.
.PP
In addizzle \s-1EXTEND\s0 is ghon be called when perl would have pre-extended
allocation up in a real array.
.PP
For dis rap, we'll implement a array whose elements is a gangbangin' fixed
size at creation. I aint talkin' bout chicken n' gravy biatch.  If you try ta create a element larger than tha fixed
size, you gonna take a exception. I aint talkin' bout chicken n' gravy biatch.  For example:
.PP
.Vb 4
\&    use FixedElem_Array;
\&    tie @array, \*(AqFixedElem_Array\*(Aq, 3;
\&    $array[0] = \*(Aqcat\*(Aq;  # ok.
\&    $array[1] = \*(Aqdawgs\*(Aq; # exception, length(\*(Aqdawgs\*(Aq) > 3.
.Ve
.PP
Da preamble code fo' tha class be as bigs up:
.PP
.Vb 3
\&    package FixedElem_Array;
\&    use Carp;
\&    use strict;
.Ve
.IP "\s-1TIEARRAY\s0 classname, \s-1LIST \s0" 4
.IX Xref "TIEARRAY"
.IX Item "TIEARRAY classname, LIST "
This is tha constructor fo' tha class.  That means it is sposed ta fuckin
return a pimped reference all up in which tha freshly smoked up array (probably an
anonymous \s-1ARRAY\s0 ref) is ghon be accessed.
.Sp
In our example, just ta show you dat you don't \fIreally\fR gotta return an
\&\s-1ARRAY\s0 reference, we'll chizzle a \s-1HASH\s0 reference ta represent our object.
A \s-1HASH\s0 works up well as a generic record type: tha \f(CW\*(C`{ELEMSIZE}\*(C'\fR field will
store tha maximum element size allowed, n' tha \f(CW\*(C`{ARRAY}\*(C'\fR field will hold the
true \s-1ARRAY\s0 ref.  If one of mah thugs outside tha class tries ta dereference the
object returned (doubtless thankin it a \s-1ARRAY\s0 ref), they'll blow up.
This just goes ta show you dat you should respect a objectz privacy.
.Sp
.Vb 11
\&    sub TIEARRAY {
\&      mah $class    = shift;
\&      mah $elemsize = shift;
\&      if ( @_ || $elemsize =~ /\eD/ ) {
\&        croak "usage: tie ARRAY, \*(Aq" . _\|_PACKAGE_\|_ . "\*(Aq, elem_size";
\&      }
\&      return bless {
\&        ELEMSIZE => $elemsize,
\&        ARRAY    => [],
\&      }, $class;
\&    }
.Ve
.IP "\s-1FETCH\s0 this, index" 4
.IX Xref "FETCH"
.IX Item "FETCH this, index"
This method is ghon be triggered every last muthafuckin time a individual element tha tied array
is accessed (read).  It takes one argument beyond its self reference: the
index whose value we tryin ta fetch.
.Sp
.Vb 5
\&    sub FETCH {
\&      mah $self  = shift;
\&      mah $index = shift;
\&      return $self\->{ARRAY}\->[$index];
\&    }
.Ve
.Sp
If a wack array index is used ta read from a array, tha index
will be translated ta a positizzle one internally by callin \s-1FETCHSIZE\s0
before bein passed ta \s-1FETCH. \s0 Yo ass may disable dis feature by
assignin a legit value ta tha variable \f(CW$NEGATIVE_INDICES\fR up in the
tied array class.
.Sp
As you may have noticed, tha name of tha \s-1FETCH\s0 method (et al.) is tha same
for all accesses, even though tha constructors differ up in names (\s-1TIESCALAR\s0
vs \s-1TIEARRAY\s0).  While up in theory you could have tha same class servicing
several tied types, up in practice dis becomes cumbersome, n' itz easiest
to keep dem at simply one tie type per class.
.IP "\s-1STORE\s0 this, index, value" 4
.IX Xref "STORE"
.IX Item "STORE this, index, value"
This method is ghon be triggered every last muthafuckin time a element up in tha tied array is set
(written).  It takes two arguments beyond its self reference: tha index at
which we tryin ta store suttin' n' tha value we tryin ta put
there.
.Sp
In our example, \f(CW\*(C`undef\*(C'\fR is straight-up \f(CW\*(C`$self\->{ELEMSIZE}\*(C'\fR number of
spaces so our crazy asses gotz a lil mo' work ta do here:
.Sp
.Vb 11
\&    sub STORE {
\&      mah $self = shift;
\&      my( $index, $value ) = @_;
\&      if ( length $value > $self\->{ELEMSIZE} ) {
\&        croak "length of $value is pimped outa than $self\->{ELEMSIZE}";
\&      }
\&      # fill up in tha blanks
\&      $self\->EXTEND( $index ) if $index > $self\->FETCHSIZE();
\&      # right justify ta keep element size fo' smalla elements
\&      $self\->{ARRAY}\->[$index] = sprintf "%$self\->{ELEMSIZE}s", $value;
\&    }
.Ve
.Sp
Negatizzle indexes is treated tha same as wit \s-1FETCH.\s0
.IP "\s-1FETCHSIZE\s0 this" 4
.IX Xref "FETCHSIZE"
.IX Item "FETCHSIZE this"
Returns tha total number of shit up in tha tied array associated with
object \fIthis\fR. (Equivalent ta \f(CW\*(C`scalar(@array)\*(C'\fR).  For example:
.Sp
.Vb 4
\&    sub FETCHSIZE {
\&      mah $self = shift;
\&      return scalar @{$self\->{ARRAY}};
\&    }
.Ve
.IP "\s-1STORESIZE\s0 this, count" 4
.IX Xref "STORESIZE"
.IX Item "STORESIZE this, count"
Sets tha total number of shit up in tha tied array associated with
object \fIthis\fR ta be \fIcount\fR. If dis make tha array larger then
classs mappin of \f(CW\*(C`undef\*(C'\fR should be returned fo' freshly smoked up positions.
If tha array becomes smalla then entries beyond count should be
deleted.
.Sp
In our example, 'undef' is straight-up a element containing
\&\f(CW\*(C`$self\->{ELEMSIZE}\*(C'\fR number of spaces.  Observe:
.Sp
.Vb 10
\&    sub STORESIZE {
\&      mah $self  = shift;
\&      mah $count = shift;
\&      if ( $count > $self\->FETCHSIZE() ) {
\&        foreach ( $count \- $self\->FETCHSIZE() .. $count ) {
\&          $self\->STORE( $_, \*(Aq\*(Aq );
\&        }
\&      } elsif ( $count < $self\->FETCHSIZE() ) {
\&        foreach ( 0 .. $self\->FETCHSIZE() \- $count \- 2 ) {
\&          $self\->POP();
\&        }
\&      }
\&    }
.Ve
.IP "\s-1EXTEND\s0 this, count" 4
.IX Xref "EXTEND"
.IX Item "EXTEND this, count"
Informatizzle call dat array is likely ta grow ta have \fIcount\fR entries.
Can be used ta optimize allocation. I aint talkin' bout chicken n' gravy biatch. This method need do nothing.
.Sp
In our example, we wanna make shizzle there be no blank (\f(CW\*(C`undef\*(C'\fR)
entries, so \f(CW\*(C`EXTEND\*(C'\fR will make use of \f(CW\*(C`STORESIZE\*(C'\fR ta fill elements
as needed:
.Sp
.Vb 5
\&    sub EXTEND {   
\&      mah $self  = shift;
\&      mah $count = shift;
\&      $self\->STORESIZE( $count );
\&    }
.Ve
.IP "\s-1EXISTS\s0 this, key" 4
.IX Xref "EXISTS"
.IX Item "EXISTS this, key"
Verify dat tha element at index \fIkey\fR exists up in tha tied array \fIthis\fR.
.Sp
In our example, we will determine dat if a element consists of
\&\f(CW\*(C`$self\->{ELEMSIZE}\*(C'\fR spaces only, it do not exist:
.Sp
.Vb 7
\&    sub EXISTS {
\&      mah $self  = shift;
\&      mah $index = shift;
\&      return 0 if ! defined $self\->{ARRAY}\->[$index] ||
\&                  $self\->{ARRAY}\->[$index] eq \*(Aq \*(Aq x $self\->{ELEMSIZE};
\&      return 1;
\&    }
.Ve
.IP "\s-1DELETE\s0 this, key" 4
.IX Xref "DELETE"
.IX Item "DELETE this, key"
Delete tha element at index \fIkey\fR from tha tied array \fIthis\fR.
.Sp
In our example, a thugged-out deleted item is \f(CW\*(C`$self\->{ELEMSIZE}\*(C'\fR spaces:
.Sp
.Vb 5
\&    sub DELETE {
\&      mah $self  = shift;
\&      mah $index = shift;
\&      return $self\->STORE( $index, \*(Aq\*(Aq );
\&    }
.Ve
.IP "\s-1CLEAR\s0 this" 4
.IX Xref "CLEAR"
.IX Item "CLEAR this"
Clear (remove, delete, ...) all joints from tha tied array associated with
object \fIthis\fR.  For example:
.Sp
.Vb 4
\&    sub CLEAR {
\&      mah $self = shift;
\&      return $self\->{ARRAY} = [];
\&    }
.Ve
.IP "\s-1PUSH\s0 this, \s-1LIST \s0" 4
.IX Xref "PUSH"
.IX Item "PUSH this, LIST "
Append elementz of \fI\s-1LIST\s0\fR ta tha array.  For example:
.Sp
.Vb 7
\&    sub PUSH {  
\&      mah $self = shift;
\&      mah @list = @_;
\&      mah $last = $self\->FETCHSIZE();
\&      $self\->STORE( $last + $_, $list[$_] ) foreach 0 .. $#list;
\&      return $self\->FETCHSIZE();
\&    }
.Ve
.IP "\s-1POP\s0 this" 4
.IX Xref "POP"
.IX Item "POP this"
Remove last element of tha array n' return dat shit.  For example:
.Sp
.Vb 4
\&    sub POP {
\&      mah $self = shift;
\&      return pop @{$self\->{ARRAY}};
\&    }
.Ve
.IP "\s-1SHIFT\s0 this" 4
.IX Xref "SHIFT"
.IX Item "SHIFT this"
Remove tha straight-up original gangsta element of tha array (shiftin other elements down)
and return dat shit.  For example:
.Sp
.Vb 4
\&    sub SHIFT {
\&      mah $self = shift;
\&      return shift @{$self\->{ARRAY}};
\&    }
.Ve
.IP "\s-1UNSHIFT\s0 this, \s-1LIST \s0" 4
.IX Xref "UNSHIFT"
.IX Item "UNSHIFT this, LIST "
Insert \s-1LIST\s0 elements all up in tha beginnin of tha array, movin existin elements
up ta make room.  For example:
.Sp
.Vb 9
\&    sub UNSHIFT {
\&      mah $self = shift;
\&      mah @list = @_;
\&      mah $size = scalar( @list );
\&      # make room fo' our list
\&      @{$self\->{ARRAY}}[ $size .. $#{$self\->{ARRAY}} + $size ]
\&       = @{$self\->{ARRAY}};
\&      $self\->STORE( $_, $list[$_] ) foreach 0 .. $#list;
\&    }
.Ve
.IP "\s-1SPLICE\s0 this, offset, length, \s-1LIST \s0" 4
.IX Xref "SPLICE"
.IX Item "SPLICE this, offset, length, LIST "
Perform tha equivalent of \f(CW\*(C`splice\*(C'\fR on tha array.
.Sp
\&\fIoffset\fR is optionizzle n' defaults ta zero, wack joints count back 
from tha end of tha array.
.Sp
\&\fIlength\fR is optionizzle n' defaults ta rest of tha array.
.Sp
\&\fI\s-1LIST\s0\fR may be empty.
.Sp
Returns a list of tha original gangsta \fIlength\fR elements at \fIoffset\fR.
.Sp
In our example, we'll bust a lil shortcut if there be a \fI\s-1LIST\s0\fR:
.Sp
.Vb 11
\&    sub SPLICE {
\&      mah $self   = shift;
\&      mah $offset = shift || 0;
\&      mah $length = shift || $self\->FETCHSIZE() \- $offset;
\&      mah @list   = (); 
\&      if ( @_ ) {
\&        tie @list, _\|_PACKAGE_\|_, $self\->{ELEMSIZE};
\&        @list   = @_;
\&      }
\&      return splice @{$self\->{ARRAY}}, $offset, $length, @list;
\&    }
.Ve
.IP "\s-1UNTIE\s0 this" 4
.IX Xref "UNTIE"
.IX Item "UNTIE this"
Will be called when \f(CW\*(C`untie\*(C'\fR happens. (See "Da \f(CW\*(C`untie\*(C'\fR Gotcha" below.)
.IP "\s-1DESTROY\s0 this" 4
.IX Xref "DESTROY"
.IX Item "DESTROY this"
This method is ghon be triggered when tha tied variable need ta be destructed.
As wit tha scalar tie class, dis be almost never needed up in a
language dat do its own garbage collection, so dis time we'll
just leave it out.
.SS "Tyin Hashes"
.IX Xref "hash, tying"
.IX Subsection "Tyin Hashes"
Hashes was tha straight-up original gangsta Perl data type ta be tied (see \fIdbmopen()\fR).  A class
implementin a tied hash should define tha followin methods: \s-1TIEHASH\s0 is
the constructor. Shiiit, dis aint no joke.  \s-1FETCH\s0 n' \s-1STORE\s0 access tha key n' value pairs.  \s-1EXISTS\s0
reports whether a key is present up in tha hash, n' \s-1DELETE\s0 deletes one.
\&\s-1CLEAR\s0 emptizzles tha hash by deletin all tha key n' value pairs.  \s-1FIRSTKEY\s0
and \s-1NEXTKEY\s0 implement tha \fIkeys()\fR n' \fIeach()\fR functions ta iterate over all
the keys. \s-1SCALAR\s0 is triggered when tha tied hash is evaluated up in scalar 
context. \s-1UNTIE\s0 is called when \f(CW\*(C`untie\*(C'\fR happens, n' \s-1DESTROY\s0 is called when
the tied variable is garbage collected.
.PP
If dis seems like a lot, then feel free ta inherit from merely the
standard Tie::StdHash module fo' most of yo' methods, redefinin only the
interestin ones.  See Tie::Hash fo' details.
.PP
Remember dat Perl distinguishes between a key not existin up in tha hash,
and tha key existin up in tha hash but havin a cold-ass lil correspondin value of
\&\f(CW\*(C`undef\*(C'\fR.  Da two possibilitizzles can be tested wit tha \f(CW\*(C`exists()\*(C'\fR and
\&\f(CW\*(C`defined()\*(C'\fR functions.
.PP
Herez a example of a somewhat bangin-ass tied hash class:  it gives you
a hash representin a particular userz dot files.  Yo ass index tha fuck into tha hash
with tha name of tha file (minus tha dot) n' you git back dat dot file's
contents, n' you can put dat on yo' toast.  For example:
.PP
.Vb 8
\&    use DotFiles;
\&    tie %dot, \*(AqDotFiles\*(Aq;
\&    if ( $dot{profile} =~ /MANPATH/ ||
\&         $dot{login}   =~ /MANPATH/ ||
\&         $dot{cshrc}   =~ /MANPATH/    )
\&    {
\&        print "you seem ta set yo' MANPATH\en";
\&    }
.Ve
.PP
Or herez another sample of rockin our tied class:
.PP
.Vb 5
\&    tie %him, \*(AqDotFiles\*(Aq, \*(Aqdaemon\*(Aq;
\&    foreach $f ( keys %him ) {
\&        printf "daemon dot file %s is size %d\en",
\&            $f, length $him{$f};
\&    }
.Ve
.PP
In our tied hash DotFilez example, we bust a regular
hash fo' tha object containin nuff muthafuckin blingin
fields, of which only tha \f(CW\*(C`{LIST}\*(C'\fR field is ghon be what tha fuck the
user be thinkin of as tha real hash.
.IP "\s-1USER\s0" 5
.IX Item "USER"
whose dot filez dis object represents
.IP "\s-1HOME\s0" 5
.IX Item "HOME"
where dem dot filez live
.IP "\s-1CLOBBER\s0" 5
.IX Item "CLOBBER"
whether we should try ta chizzle or remove dem dot files
.IP "\s-1LIST\s0" 5
.IX Item "LIST"
the hash of dot file names n' content mappings
.PP
Herez tha start of \fIDotfiles.pm\fR:
.PP
.Vb 5
\&    package DotFiles;
\&    use Carp;
\&    sub whowasi { (caller(1))[3] . \*(Aq()\*(Aq }
\&    mah $DEBUG = 0;
\&    sub debug { $DEBUG = @_ ? shift : 1 }
.Ve
.PP
For our example, we wanna be able ta emit debuggin info ta help up in tracing
durin pimpment.  We keep also one convenience function around
internally ta help print up warnings; \fIwhowasi()\fR returns tha function name
that calls dat shit.
.PP
Here is tha methodz fo' tha DotFilez tied hash.
.IP "\s-1TIEHASH\s0 classname, \s-1LIST \s0" 4
.IX Xref "TIEHASH"
.IX Item "TIEHASH classname, LIST "
This is tha constructor fo' tha class.  That means it is sposed ta fuckin
return a pimped reference all up in which tha freshly smoked up object (probably but not
necessarily a anonymous hash) is ghon be accessed.
.Sp
Herez tha constructor:
.Sp
.Vb 9
\&    sub TIEHASH {
\&        mah $self = shift;
\&        mah $user = shift || $>;
\&        mah $dotdir = shift || \*(Aq\*(Aq;
\&        croak "usage: @{[&whowasi]} [USER [DOTDIR]]" if @_;
\&        $user = getpwuid($user) if $user =~ /^\ed+$/;
\&        mah $dir = (getpwnam($user))[7]
\&                || croak "@{[&whowasi]}: no user $user";
\&        $dir .= "/$dotdir" if $dotdir;
\&
\&        mah $node = {
\&            USER    => $user,
\&            HOME    => $dir,
\&            LIST    => {},
\&            CLOBBER => 0,
\&        };
\&
\&        opendir(DIR, $dir)
\&                || croak "@{[&whowasi]}: can\*(Aqt opendir $dir: $!";
\&        foreach $dot ( grep /^\e./ && \-f "$dir/$_", readdir(DIR)) {
\&            $dot =~ s/^\e.//;
\&            $node\->{LIST}{$dot} = undef;
\&        }
\&        closedir DIR;
\&        return bless $node, $self;
\&    }
.Ve
.Sp
It aint nuthin but probably worth mentionin dat if you goin ta filetest the
return joints outta a readdir, you'd betta prepend tha directory
in question. I aint talkin' bout chicken n' gravy biatch.  Otherwise, cuz our phat asses didn't \fIchdir()\fR there, it would
have been testin tha wack file.
.IP "\s-1FETCH\s0 this, key" 4
.IX Xref "FETCH"
.IX Item "FETCH this, key"
This method is ghon be triggered every last muthafuckin time a element up in tha tied hash is
accessed (read).  It takes one argument beyond its self reference: tha key
whose value we tryin ta fetch.
.Sp
Herez tha fetch fo' our DotFilez example.
.Sp
.Vb 6
\&    sub FETCH {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        mah $dot = shift;
\&        mah $dir = $self\->{HOME};
\&        mah $file = "$dir/.$dot";
\&
\&        unless (exists $self\->{LIST}\->{$dot} || \-f $file) {
\&            carp "@{[&whowasi]}: no $dot file" if $DEBUG;
\&            return undef;
\&        }
\&
\&        if (defined $self\->{LIST}\->{$dot}) {
\&            return $self\->{LIST}\->{$dot};
\&        } else {
\&            return $self\->{LIST}\->{$dot} = \`cat $dir/.$dot\`;
\&        }
\&    }
.Ve
.Sp
Dat shiznit was easy as fuck  ta write by havin it call tha Unix \fIcat\fR\|(1) command yo, but it
would probably be mo' portable ta open tha file manually (and somewhat
more efficient).  Of course, cuz dot filez is a Unixy concept, we're
not dat concerned.
.IP "\s-1STORE\s0 this, key, value" 4
.IX Xref "STORE"
.IX Item "STORE this, key, value"
This method is ghon be triggered every last muthafuckin time a element up in tha tied hash is set
(written).  It takes two arguments beyond its self reference: tha index at
which we tryin ta store something, n' tha value we tryin ta put
there.
.Sp
Here up in our DotFilez example, we'll be careful not ta let
them try ta overwrite tha file unless they've called tha \fIclobber()\fR
method on tha original gangsta object reference returned by \fItie()\fR.
.Sp
.Vb 7
\&    sub STORE {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        mah $dot = shift;
\&        mah $value = shift;
\&        mah $file = $self\->{HOME} . "/.$dot";
\&        mah $user = $self\->{USER};
\&
\&        croak "@{[&whowasi]}: $file not clobberable"
\&            unless $self\->{CLOBBER};
\&
\&        open(my $f, \*(Aq>\*(Aq, $file) || croak "can\*(Aqt open $file: $!";
\&        print $f $value;
\&        close($f);
\&    }
.Ve
.Sp
If they wanted ta clobber something, they might say:
.Sp
.Vb 3
\&    $ob = tie %daemon_dots, \*(Aqdaemon\*(Aq;
\&    $ob\->clobber(1);
\&    $daemon_dots{signature} = "A legit daemon\en";
.Ve
.Sp
Another way ta lay handz on a reference ta tha underlyin object is to
use tha \fItied()\fR function, so they might alternately have set clobber
using:
.Sp
.Vb 2
\&    tie %daemon_dots, \*(Aqdaemon\*(Aq;
\&    tied(%daemon_dots)\->clobber(1);
.Ve
.Sp
Da clobber method is simply:
.Sp
.Vb 4
\&    sub clobber {
\&        mah $self = shift;
\&        $self\->{CLOBBER} = @_ ? shift : 1;
\&    }
.Ve
.IP "\s-1DELETE\s0 this, key" 4
.IX Xref "DELETE"
.IX Item "DELETE this, key"
This method is triggered when we remove a element from tha hash,
typically by rockin tha \fIdelete()\fR function. I aint talkin' bout chicken n' gravy biatch.  Again, we'll
be careful ta check whether they straight-up wanna clobber files.
.Sp
.Vb 2
\&    sub DELETE   {
\&        carp &whowasi if $DEBUG;
\&
\&        mah $self = shift;
\&        mah $dot = shift;
\&        mah $file = $self\->{HOME} . "/.$dot";
\&        croak "@{[&whowasi]}: won\*(Aqt remove file $file"
\&            unless $self\->{CLOBBER};
\&        delete $self\->{LIST}\->{$dot};
\&        mah $success = unlink($file);
\&        carp "@{[&whowasi]}: can\*(Aqt unlink $file: $!" unless $success;
\&        $success;
\&    }
.Ve
.Sp
Da value returned by \s-1DELETE\s0 becomes tha return value of tha call
to \fIdelete()\fR.  If you wanna emulate tha aiiight behavior of \fIdelete()\fR,
you should return whatever \s-1FETCH\s0 would have returned fo' dis key.
In dis example, our crazy asses have chosen instead ta return a value which tells
the calla whether tha file was successfully deleted.
.IP "\s-1CLEAR\s0 this" 4
.IX Xref "CLEAR"
.IX Item "CLEAR this"
This method is triggered when tha whole hash is ta be cleared, probably by
assignin tha empty list ta dat shit.
.Sp
In our example, dat would remove all tha userz dot files muthafucka!  It aint nuthin but such a
dangerous thang dat they'll gotta set \s-1CLOBBER\s0 ta suttin' higher than
1 ta make it happen.
.Sp
.Vb 10
\&    sub CLEAR    {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        croak "@{[&whowasi]}: won\*(Aqt remove all dot filez fo' $self\->{USER}"
\&            unless $self\->{CLOBBER} > 1;
\&        mah $dot;
\&        foreach $dot ( keys %{$self\->{LIST}}) {
\&            $self\->DELETE($dot);
\&        }
\&    }
.Ve
.IP "\s-1EXISTS\s0 this, key" 4
.IX Xref "EXISTS"
.IX Item "EXISTS this, key"
This method is triggered when tha user uses tha \fIexists()\fR function
on a particular hash.  In our example, we'll peep tha \f(CW\*(C`{LIST}\*(C'\fR
hash element fo' this:
.Sp
.Vb 6
\&    sub EXISTS   {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        mah $dot = shift;
\&        return exists $self\->{LIST}\->{$dot};
\&    }
.Ve
.IP "\s-1FIRSTKEY\s0 this" 4
.IX Xref "FIRSTKEY"
.IX Item "FIRSTKEY this"
This method is ghon be triggered when tha user is going
to iterate all up in tha hash, like fuckin via a \fIkeys()\fR or \fIeach()\fR
call.
.Sp
.Vb 6
\&    sub FIRSTKEY {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        mah $a = keys %{$self\->{LIST}};          # reset each() iterator
\&        each %{$self\->{LIST}}
\&    }
.Ve
.IP "\s-1NEXTKEY\s0 this, lastkey" 4
.IX Xref "NEXTKEY"
.IX Item "NEXTKEY this, lastkey"
This method gets triggered durin a \fIkeys()\fR or \fIeach()\fR iteration. I aint talkin' bout chicken n' gravy biatch.  It has a
second argument which is tha last key dat had been accessed. Y'all KNOW dat shit, muthafucka!  This is
useful if you carryin bout orderin or callin tha iterator from more
than one sequence, or not straight-up storin thangs up in a hash anywhere.
.Sp
For our example, we rockin a real hash so we'll do just tha simple
thang yo, but we'll gotta go all up in tha \s-1LIST\s0 field indirectly.
.Sp
.Vb 5
\&    sub NEXTKEY  {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        return each %{ $self\->{LIST} }
\&    }
.Ve
.IP "\s-1SCALAR\s0 this" 4
.IX Xref "SCALAR"
.IX Item "SCALAR this"
This is called when tha hash is evaluated up in scalar context. In order
to mimic tha behaviour of untied hashes, dis method should return a
false value when tha tied hash is considered empty. If dis method do
not exist, perl will cook up some fuckin constipated guesses n' return legit when
the hash is inside a iteration. I aint talkin' bout chicken n' gravy biatch. If dis aint tha case, \s-1FIRSTKEY\s0 is
called, n' tha result is ghon be a gangbangin' false value if \s-1FIRSTKEY\s0 returns tha empty
list, legit otherwise.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat you should \fBnot\fR blindly rely on perl always bustin tha right 
thing. Particularly, perl will mistakenly return legit when you clear tha 
hash by repeatedly callin \s-1DELETE\s0 until it is empty. Yo ass is therefore 
advised ta supply yo' own \s-1SCALAR\s0 method when you wanna be straight-up 
sure dat yo' hash behaves sickly up in scalar context.
.Sp
In our example we can just call \f(CW\*(C`scalar\*(C'\fR on tha underlyin hash
referenced by \f(CW\*(C`$self\->{LIST}\*(C'\fR:
.Sp
.Vb 5
\&    sub SCALAR {
\&        carp &whowasi if $DEBUG;
\&        mah $self = shift;
\&        return scalar %{ $self\->{LIST} }
\&    }
.Ve
.IP "\s-1UNTIE\s0 this" 4
.IX Xref "UNTIE"
.IX Item "UNTIE this"
This is called when \f(CW\*(C`untie\*(C'\fR occurs.  See "Da \f(CW\*(C`untie\*(C'\fR Gotcha" below.
.IP "\s-1DESTROY\s0 this" 4
.IX Xref "DESTROY"
.IX Item "DESTROY this"
This method is triggered when a tied hash be bout ta go up of
scope.  Yo ass don't straight-up need it unless you tryin ta add debugging
or have auxiliary state ta clean up.  Herez a straight-up simple function:
.Sp
.Vb 3
\&    sub DESTROY  {
\&        carp &whowasi if $DEBUG;
\&    }
.Ve
.PP
Note dat functions like fuckin \fIkeys()\fR n' \fIvalues()\fR may return big-ass lists
when used on big-ass objects, like \s-1DBM\s0 files.  Yo ass may prefer ta use the
\&\fIeach()\fR function ta iterate over such.  Example:
.PP
.Vb 7
\&    # print up history file offsets
\&    use NDBM_File;
\&    tie(%HIST, \*(AqNDBM_File\*(Aq, \*(Aq/usr/lib/news/history\*(Aq, 1, 0);
\&    while (($key,$val) = each %HIST) {
\&        print $key, \*(Aq = \*(Aq, unpack(\*(AqL\*(Aq,$val), "\en";
\&    }
\&    untie(%HIST);
.Ve
.SS "Tyin FileHandles"
.IX Xref "filehandle, tying"
.IX Subsection "Tyin FileHandles"
This is partially implemented now, nahmeean?
.PP
A class implementin a tied filehandle should define tha following
methods: \s-1TIEHANDLE,\s0 at least one of \s-1PRINT, PRINTF, WRITE, READLINE, GETC,
READ,\s0 n' possibly \s-1CLOSE, UNTIE\s0 n' \s-1DESTROY. \s0 Da class can also provide: \s-1BINMODE,
OPEN, EOF, FILENO, SEEK, TELL \-\s0 if tha correspondin perl operators are
used on tha handle.
.PP
When \s-1STDERR\s0 is tied, its \s-1PRINT\s0 method is ghon be called ta issue warnings
and error lyrics.  This feature is temporarily disabled durin tha call, 
which means you can use \f(CW\*(C`warn()\*(C'\fR inside \s-1PRINT\s0 without startin a recursive
loop.  And just like \f(CW\*(C`_\|_WARN_\|_\*(C'\fR n' \f(CW\*(C`_\|_DIE_\|_\*(C'\fR handlezs, \s-1STDERR\s0z \s-1PRINT\s0
method may be called ta report parser errors, so tha caveats mentioned under 
\&\*(L"%SIG\*(R" up in perlvar apply.
.PP
All of dis is especially useful when perl is embedded up in some other 
program, where output ta \s-1STDOUT\s0 n' \s-1STDERR\s0 may gotta be repimped up 
in some special way.  See nvi n' tha Apache module fo' examples.
.PP
When tyin a handle, tha straight-up original gangsta argument ta \f(CW\*(C`tie\*(C'\fR should begin wit an
asterisk.  So, if yo ass is tyin \s-1STDOUT,\s0 use \f(CW*STDOUT\fR.  If you have
assigned it ta a scalar variable, say \f(CW$handle\fR, use \f(CW*$handle\fR.
\&\f(CW\*(C`tie $handle\*(C'\fR tizzles tha scalar variable \f(CW$handle\fR, not tha handle inside
it.
.PP
In our example we goin ta create a gangbangin' finger-lickin' dirty-ass shoutin handle.
.PP
.Vb 1
\&    package Shout;
.Ve
.IP "\s-1TIEHANDLE\s0 classname, \s-1LIST \s0" 4
.IX Xref "TIEHANDLE"
.IX Item "TIEHANDLE classname, LIST "
This is tha constructor fo' tha class.  That means it is sposed ta fuckin
return a pimped reference of some sort. Da reference can be used to
hold some internal shiznit.
.Sp
.Vb 1
\&    sub TIEHANDLE { print "<shout>\en"; mah $i; bless \e$i, shift }
.Ve
.IP "\s-1WRITE\s0 this, \s-1LIST \s0" 4
.IX Xref "WRITE"
.IX Item "WRITE this, LIST "
This method is ghon be called when tha handle is freestyled ta via the
\&\f(CW\*(C`syswrite\*(C'\fR function.
.Sp
.Vb 5
\&    sub WRITE {
\&        $r = shift;
\&        my($buf,$len,$offset) = @_;
\&        print "WRITE called, \e$buf=$buf, \e$len=$len, \e$offset=$offset";
\&    }
.Ve
.IP "\s-1PRINT\s0 this, \s-1LIST \s0" 4
.IX Xref "PRINT"
.IX Item "PRINT this, LIST "
This method is ghon be triggered every last muthafuckin time tha tied handle is printed to
with tha \f(CW\*(C`print()\*(C'\fR or \f(CW\*(C`say()\*(C'\fR functions.  Beyond its self reference
it also expects tha list dat was passed ta tha print function.
.Sp
.Vb 1
\&    sub PRINT { $r = shift; $$r++; print join($,,map(uc($_),@_)),$\e }
.Ve
.Sp
\&\f(CW\*(C`say()\*(C'\fR acts just like \f(CW\*(C`print()\*(C'\fR except $\e is ghon be localized ta \f(CW\*(C`\en\*(C'\fR so
you need do not a god damn thang special ta handle \f(CW\*(C`say()\*(C'\fR up in \f(CW\*(C`PRINT()\*(C'\fR.
.IP "\s-1PRINTF\s0 this, \s-1LIST \s0" 4
.IX Xref "PRINTF"
.IX Item "PRINTF this, LIST "
This method is ghon be triggered every last muthafuckin time tha tied handle is printed to
with tha \f(CW\*(C`printf()\*(C'\fR function.
Beyond its self reference it also expects tha format n' list dat was
passed ta tha printf function.
.Sp
.Vb 5
\&    sub PRINTF {
\&        shift;
\&        mah $fmt = shift;
\&        print sprintf($fmt, @_);
\&    }
.Ve
.IP "\s-1READ\s0 this, \s-1LIST \s0" 4
.IX Xref "READ"
.IX Item "READ this, LIST "
This method is ghon be called when tha handle is read from via tha \f(CW\*(C`read\*(C'\fR
or \f(CW\*(C`sysread\*(C'\fR functions.
.Sp
.Vb 8
\&    sub READ {
\&        mah $self = shift;
\&        mah $bufref = \e$_[0];
\&        my(undef,$len,$offset) = @_;
\&        print "READ called, \e$buf=$bufref, \e$len=$len, \e$offset=$offset";
\&        # add ta $$bufref, set $len ta number of charactas read
\&        $len;
\&    }
.Ve
.IP "\s-1READLINE\s0 this" 4
.IX Xref "READLINE"
.IX Item "READLINE this"
This method is called when tha handle is read via \f(CW\*(C`<HANDLE>\*(C'\fR
or \f(CW\*(C`readline HANDLE\*(C'\fR.
.Sp
As per \f(CW\*(C`readline\*(C'\fR, up in scalar context it should return
the next line, or \f(CW\*(C`undef\*(C'\fR fo' no mo' data.  In list context it should
return all remainin lines, or a empty list fo' no mo' data.  Da strings
returned should include tha input record separator \f(CW$/\fR (see perlvar),
unless it is \f(CW\*(C`undef\*(C'\fR (which means \*(L"slurp\*(R" mode).
.Sp
.Vb 10
\&    sub READLINE {
\&      mah $r = shift;
\&      if (wantarray) {
\&        return ("all remaining\en",
\&                "lines up\en",
\&                "to eof\en");
\&      } else {
\&        return "READLINE called " . ++$$r . " times\en";
\&      }
\&    }
.Ve
.IP "\s-1GETC\s0 this" 4
.IX Xref "GETC"
.IX Item "GETC this"
This method is ghon be called when tha \f(CW\*(C`getc\*(C'\fR function is called.
.Sp
.Vb 1
\&    sub GETC { print "Don\*(Aqt GETC, Git Perl"; return "a"; }
.Ve
.IP "\s-1EOF\s0 this" 4
.IX Xref "EOF"
.IX Item "EOF this"
This method is ghon be called when tha \f(CW\*(C`eof\*(C'\fR function is called.
.Sp
Startin wit Perl 5.12, a additionizzle integer parameta is ghon be passed. Y'all KNOW dat shit, muthafucka!  It
will be zero if \f(CW\*(C`eof\*(C'\fR is called without parameter; \f(CW1\fR if \f(CW\*(C`eof\*(C'\fR is given
a filehandle as a parameter, e.g. \f(CW\*(C`eof(FH)\*(C'\fR; n' \f(CW2\fR up in tha straight-up special
case dat tha tied filehandle is \f(CW\*(C`ARGV\*(C'\fR n' \f(CW\*(C`eof\*(C'\fR is called wit a empty
parameta list, e.g. \f(CW\*(C`eof()\*(C'\fR.
.Sp
.Vb 1
\&    sub EOF { not length $stringbuf }
.Ve
.IP "\s-1CLOSE\s0 this" 4
.IX Xref "CLOSE"
.IX Item "CLOSE this"
This method is ghon be called when tha handle is closed via tha \f(CW\*(C`close\*(C'\fR
function.
.Sp
.Vb 1
\&    sub CLOSE { print "CLOSE called.\en" }
.Ve
.IP "\s-1UNTIE\s0 this" 4
.IX Xref "UNTIE"
.IX Item "UNTIE this"
As wit tha other typez of ties, dis method is ghon be called when \f(CW\*(C`untie\*(C'\fR happens.
It may be appropriate ta \*(L"auto \s-1CLOSE\*(R"\s0 when dis occurs.  See
"Da \f(CW\*(C`untie\*(C'\fR Gotcha" below.
.IP "\s-1DESTROY\s0 this" 4
.IX Xref "DESTROY"
.IX Item "DESTROY this"
As wit tha other typez of ties, dis method is ghon be called when the
tied handle be bout ta be destroyed. Y'all KNOW dat shit, muthafucka! This is useful fo' debuggin and
possibly cleanin up.
.Sp
.Vb 1
\&    sub DESTROY { print "</shout>\en" }
.Ve
.PP
Herez how tha fuck ta use our lil example:
.PP
.Vb 5
\&    tie(*FOO,\*(AqShout\*(Aq);
\&    print FOO "hello\en";
\&    $a = 4; $b = 6;
\&    print FOO $a, " plus ", $b, " equals ", $a + $b, "\en";
\&    print <FOO>;
.Ve
.SS "\s-1UNTIE\s0 this"
.IX Xref "UNTIE"
.IX Subsection "UNTIE this"
Yo ass can define fo' all tie types a \s-1UNTIE\s0 method dat is ghon be called
at \fIuntie()\fR.  See "Da \f(CW\*(C`untie\*(C'\fR Gotcha" below.
.ie n .SS "Da ""untie"" Gotcha"
.el .SS "Da \f(CWuntie\fP Gotcha"
.IX Xref "untie"
.IX Subsection "Da untie Gotcha"
If you intend makin use of tha object returned from either \fItie()\fR or
\&\fItied()\fR, n' if tha tiez target class defines a thugged-out destructor, there be a
subtle gotcha you \fImust\fR guard against.
.PP
As setup, consider dis (admittedly rather contrived) example of a
tie; all it do is bust a gangbangin' file ta keep a log of tha joints assigned to
a scalar.
.PP
.Vb 1
\&    package Remember;
\&
\&    use strict;
\&    use warnings;
\&    use IO::File;
\&
\&    sub TIESCALAR {
\&        mah $class = shift;
\&        mah $filename = shift;
\&        mah $handle = IO::File\->new( "> $filename" )
\&                         or take a thugged-out dirtnap "Cannot open $filename: $!\en";
\&
\&        print $handle "Da Start\en";
\&        bless {FH => $handle, Value => 0}, $class;
\&    }
\&
\&    sub FETCH {
\&        mah $self = shift;
\&        return $self\->{Value};
\&    }
\&
\&    sub STORE {
\&        mah $self = shift;
\&        mah $value = shift;
\&        mah $handle = $self\->{FH};
\&        print $handle "$value\en";
\&        $self\->{Value} = $value;
\&    }
\&
\&    sub DESTROY {
\&        mah $self = shift;
\&        mah $handle = $self\->{FH};
\&        print $handle "Da End\en";
\&        close $handle;
\&    }
\&
\&    1;
.Ve
.PP
Here be a example dat make use of dis tie:
.PP
.Vb 2
\&    use strict;
\&    use Remember;
\&
\&    mah $fred;
\&    tie $fred, \*(AqRemember\*(Aq, \*(Aqmyfile.txt\*(Aq;
\&    $fred = 1;
\&    $fred = 4;
\&    $fred = 5;
\&    untie $fred;
\&    system "cat myfile.txt";
.Ve
.PP
This is tha output when it is executed:
.PP
.Vb 5
\&    Da Start
\&    1
\&    4
\&    5
\&    Da End
.Ve
.PP
So far so good. Y'all KNOW dat shit, muthafucka! I be fly as a gangbangin' falcon, soarin all up in tha sky dawwwwg!  Those of y'all whoz ass done been payin attention will have
spotted dat tha tied object aint been used so far. Shiiit, dis aint no joke.  So lets add an
extra method ta tha Remember class ta allow comments ta be included in
the file; say, suttin' like this:
.PP
.Vb 6
\&    sub comment {
\&        mah $self = shift;
\&        mah $text = shift;
\&        mah $handle = $self\->{FH};
\&        print $handle $text, "\en";
\&    }
.Ve
.PP
And here is tha previous example modified ta use tha \f(CW\*(C`comment\*(C'\fR method
(which requires tha tied object):
.PP
.Vb 2
\&    use strict;
\&    use Remember;
\&
\&    mah ($fred, $x);
\&    $x = tie $fred, \*(AqRemember\*(Aq, \*(Aqmyfile.txt\*(Aq;
\&    $fred = 1;
\&    $fred = 4;
\&    comment $x "changing...";
\&    $fred = 5;
\&    untie $fred;
\&    system "cat myfile.txt";
.Ve
.PP
When dis code is executed there is no output.  Herez why:
.PP
When a variable is tied, it be associated wit tha object which is the
return value of tha \s-1TIESCALAR, TIEARRAY,\s0 or \s-1TIEHASH\s0 function. I aint talkin' bout chicken n' gravy biatch.  This
object normally has only one reference, namely, tha implicit reference
from tha tied variable.  When \fIuntie()\fR is called, dat reference is
destroyed. Y'all KNOW dat shit, muthafucka!  Then, as up in tha straight-up original gangsta example above, tha object's
destructor (\s-1DESTROY\s0) is called, which be aiiight fo' objects dat have
no mo' valid references; n' thus tha file is closed.
.PP
In tha second example, however, our crazy asses have stored another reference to
the tied object up in \f(CW$x\fR.  That means dat when \fIuntie()\fR gets called
there will still be a valid reference ta tha object up in existence, so
the destructor aint called at dat time, n' thus tha file is not
closed. Y'all KNOW dat shit, muthafucka!  Da reason there is no output is cuz tha file buffers
have not been flushed ta disk.
.PP
Now dat you know what tha fuck tha problem is, what tha fuck can you do ta avoid it?
Prior ta tha introduction of tha optionizzle \s-1UNTIE\s0 method tha only way
was tha phat oldschool \f(CW\*(C`\-w\*(C'\fR flag. Which will spot any instances where you call
\&\fIuntie()\fR n' there be still valid references ta tha tied object.  If
the second script above dis near tha top \f(CW\*(C`use warnings \*(Aquntie\*(Aq\*(C'\fR
or was run wit tha \f(CW\*(C`\-w\*(C'\fR flag, Perl prints this
warnin message:
.PP
.Vb 1
\&    untie attempted while 1 inner references still exist
.Ve
.PP
To git tha script ta work properly n' silence tha warnin make sure
there is no valid references ta tha tied object \fIbefore\fR \fIuntie()\fR is
called:
.PP
.Vb 2
\&    undef $x;
\&    untie $fred;
.Ve
.PP
Now dat \s-1UNTIE\s0 exists tha class designer can decizzle which partz of the
class functionalitizzle is straight-up associated wit \f(CW\*(C`untie\*(C'\fR n' which with
the object bein destroyed. Y'all KNOW dat shit, muthafucka! What make sense fo' a given class depends
on whether tha inner references is bein kept so dat non-tie-related
methodz can be called on tha object. But up in most cases it probably makes
sense ta move tha functionalitizzle dat would done been up in \s-1DESTROY\s0 ta tha \s-1UNTIE\s0
method.
.PP
If tha \s-1UNTIE\s0 method exists then tha warnin above do not occur. Shiiit, dis aint no joke. Instead the
\&\s-1UNTIE\s0 method is passed tha count of \*(L"extra\*(R" references n' can issue its own
warnin if appropriate. e.g. ta replicate tha no \s-1UNTIE\s0 case dis method can
be used:
.PP
.Vb 5
\&    sub UNTIE
\&    {
\&     mah ($obj,$count) = @_;
\&     carp "untie attempted while $count inner references still exist" if $count;
\&    }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See DB_File or Config fo' some bangin-ass \fItie()\fR implementations.
A phat startin point fo' nuff \fItie()\fR implementations is wit one of the
modulez Tie::Scalar, Tie::Array, Tie::Hash, or Tie::Handle.
.SH "BUGS"
.IX Header "BUGS"
Da bucket usage shiznit provided by \f(CW\*(C`scalar(%hash)\*(C'\fR is not
available.  What dis means is dat rockin \f(CW%tied_hash\fR up in boolean
context don't work right (currently dis always tests false,
regardless of whether tha hash is empty or hash elements).
.PP
Localizin tied arrays or hashes do not work.  Afta exitin the
scope tha arrays or tha hashes is not restored.
.PP
Countin tha number of entries up in a hash via \f(CW\*(C`scalar(keys(%hash))\*(C'\fR
or \f(CW\*(C`scalar(values(%hash)\*(C'\fR) is inefficient since it need ta iterate
all up in all tha entries wit \s-1FIRSTKEY/NEXTKEY.\s0
.PP
Tied hash/array slices cause multiple \s-1FETCH/STORE\s0 pairs, there be no
tie methodz fo' slice operations.
.PP
Yo ass cannot easily tie a multilevel data structure (like fuckin a hash of
hashes) ta a thugged-out dbm file.  Da first problem is dat all but \s-1GDBM\s0 and
Berkeley \s-1DB\s0 have size limitations yo, but beyond that, you also have problems
with how tha fuck references is ta be represented on disk.  One
module dat do attempt ta address dis need is DBM::Deep.  Peep your
nearest \s-1CPAN\s0 joint as busted lyrics bout up in perlmodlib fo' source code.  Note
that despite its name, DBM::Deep do not use dbm.  Another earlier attempt
at solvin tha problem is \s-1MLDBM,\s0 which be also available on tha \s-1CPAN,\s0 but
which has some fairly straight-up limitations.
.PP
Tied filehandlez is still incomplete.  \fIsysopen()\fR, \fItruncate()\fR,
\&\fIflock()\fR, \fIfcntl()\fR, \fIstat()\fR n' \-X can't currently be trapped.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tomothy Christiansen
.PP
\&\s-1TIEHANDLE\s0 by Sven Verdoolaege <\fIskimo@dns.ufsia.ac.be\fR> n' Doug MacEachern <\fIdougm@osf.org\fR>
.PP
\&\s-1UNTIE\s0 by Nick Ing-Simmons <\fInick@ing\-simmons.net\fR>
.PP
\&\s-1SCALAR\s0 by Tassilo von Parseval <\fItassilo.von.parseval@rwth\-aachen.de\fR>
.PP
Tyin Arrays by Casey Westside <\fIcasey@geeknest.com\fR>
