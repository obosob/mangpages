.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREREF 1"
.TH PERLREREF 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreref \- Perl Regular Expressions Reference
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a quick reference ta Perlz regular expressions.
For full shiznit peep perlre n' perlop, as well
as tha \*(L"\s-1SEE ALSO\*(R"\s0 section up in dis document.
.SS "\s-1OPERATORS\s0"
.IX Subsection "OPERATORS"
\&\f(CW\*(C`=~\*(C'\fR determines ta which variable tha regex be applied.
In its absence, \f(CW$_\fR is used.
.PP
.Vb 1
\&    $var =~ /foo/;
.Ve
.PP
\&\f(CW\*(C`!~\*(C'\fR determines ta which variable tha regex be applied,
and negates tha result of tha match; it returns
false if tha match succeeds, n' legit if it fails.
.PP
.Vb 1
\&    $var !~ /foo/;
.Ve
.PP
\&\f(CW\*(C`m/pattern/msixpogcdual\*(C'\fR searches a strang fo' a pattern match,
applyin tha given options.
.PP
.Vb 10
\&    m  Multiline mode \- ^ n' $ match internal lines
\&    s  match as a Single line \- . matches \en
\&    i  case\-Insensitive
\&    x  eXtended legibilitizzle \- free whitespace n' comments
\&    p  Preserve a cold-ass lil copy of tha matched strang \-
\&       ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} is ghon be defined.
\&    o  compile pattern Once
\&    g  Global \- all occurrences
\&    c  don\*(Aqt reset pos on failed matches when rockin /g
\&    a  restrict \ed, \es, \ew n' [:posix:] ta match ASCII only
\&    aa (two a\*(Aqs) also /i matches exclude ASCII/non\-ASCII
\&    l  match accordin ta current locale
\&    u  match accordin ta Unicode rules
\&    d  match accordin ta natizzle rulez unless suttin' indicates
\&       Unicode
.Ve
.PP
If 'pattern' be a empty string, tha last \fIsuccessfully\fR matched
regex is used. Y'all KNOW dat shit, muthafucka! Delimitas other than '/' may be used fo' both this
operator n' tha followin ones. Da leadin \f(CW\*(C`m\*(C'\fR can be omitted
if tha delimita is '/'.
.PP
\&\f(CW\*(C`qr/pattern/msixpodual\*(C'\fR lets you store a regex up in a variable,
or pass one around. Y'all KNOW dat shit, muthafucka! Modifiers as fo' \f(CW\*(C`m//\*(C'\fR, n' is stored
within tha regex.
.PP
\&\f(CW\*(C`s/pattern/replacement/msixpogcedual\*(C'\fR substitutes matches of
\&'pattern' wit 'replacement'. Modifiers as fo' \f(CW\*(C`m//\*(C'\fR,
with two additions:
.PP
.Vb 2
\&    e  Evaluate \*(Aqreplacement\*(Aq as a expression
\&    r  Return substitution n' leave tha original gangsta strang untouched.
.Ve
.PP
\&'e' may be specified multiple times. 'replacement' is interpreted
as a thugged-out double quoted strang unless a single-quote (\f(CW\*(C`\*(Aq\*(C'\fR) is tha delimiter.
.PP
\&\f(CW\*(C`?pattern?\*(C'\fR is like \f(CW\*(C`m/pattern/\*(C'\fR but matches only once. No alternate
delimitas can be used. Y'all KNOW dat shit, muthafucka!  Must be reset wit \fIreset()\fR.
.SS "\s-1SYNTAX\s0"
.IX Subsection "SYNTAX"
.Vb 10
\& \e       Escapes tha characta immediately followin it
\& .       Matches any single characta except a newline (unless /s is
\&           used)
\& ^       Matches all up in tha beginnin of tha strang (or line, if /m is used)
\& $       Matches all up in tha end of tha strang (or line, if /m is used)
\& *       Matches tha precedin element 0 or mo' times
\& +       Matches tha precedin element 1 or mo' times
\& ?       Matches tha precedin element 0 or 1 times
\& {...}   Specifies a range of occurrences fo' tha element precedin it
\& [...]   Matches any one of tha charactas contained within tha brackets
\& (...)   Groups subexpressions fo' capturin ta $1, $2...
\& (?:...) Groups subexpressions without capturin (cluster)
\& |       Matches either tha subexpression precedin or followin it
\& \eg1 or \eg{1}, \eg2 ...    Matches tha text from tha Nth group
\& \e1, \e2, \e3 ...           Matches tha text from tha Nth group
\& \eg\-1 or \eg{\-1}, \eg\-2 ... Matches tha text from tha Nth previous group
\& \eg{name}     Named backreference
\& \ek<name>     Named backreference
\& \ek\*(Aqname\*(Aq     Named backreference
\& (?P=name)    Named backreference (python syntax)
.Ve
.SS "\s-1ESCAPE SEQUENCES\s0"
.IX Subsection "ESCAPE SEQUENCES"
These work as up in aiiight strings.
.PP
.Vb 10
\&   \ea       Alarm (beep)
\&   \ee       Escape
\&   \ef       Formfeed
\&   \en       Newline
\&   \er       Carriage return
\&   \et       Tab
\&   \e037     Char whose ordinal is tha 3 octal digits, max \e777
\&   \eo{2307} Char whose ordinal is tha octal number, unrestricted
\&   \ex7f     Char whose ordinal is tha 2 hex digits, max \exFF
\&   \ex{263a} Char whose ordinal is tha hex number, unrestricted
\&   \ecx      Control\-x
\&   \eN{name} A named Unicode characta or characta sequence
\&   \eN{U+263D} A Unicode characta by hex ordinal
\&
\&   \el  Lowercase next character
\&   \eu  Titlecase next character
\&   \eL  Lowercase until \eE
\&   \eU  Uppercase until \eE
\&   \eF  Foldcase until \eE
\&   \eQ  Disable pattern metacharactas until \eE
\&   \eE  End modification
.Ve
.PP
For Titlecase, peep \*(L"Titlecase\*(R".
.PP
This one works differently from aiiight strings:
.PP
.Vb 1
\&   \eb  An assertion, not backspace, except up in a cold-ass lil characta class
.Ve
.SS "\s-1CHARACTER CLASSES\s0"
.IX Subsection "CHARACTER CLASSES"
.Vb 4
\&   [amy]    Match \*(Aqa\*(Aq, \*(Aqm\*(Aq or \*(Aqy\*(Aq
\&   [f\-j]    Dash specifies "range"
\&   [f\-j\-]   Dash escaped or at start or end means \*(Aqdash\*(Aq
\&   [^f\-j]   Caret indicates "match any characta _except_ these"
.Ve
.PP
Da followin sequences (except \f(CW\*(C`\eN\*(C'\fR) work within or without a cold-ass lil characta class.
Da first six is locale aware, all is Unicode aware. Right back up in yo muthafuckin ass. See perllocale
and perlunicode fo' details.
.PP
.Vb 10
\&   \ed      A digit
\&   \eD      A nondigit
\&   \ew      A word character
\&   \eW      A non\-word character
\&   \es      A whitespace character
\&   \eS      A non\-whitespace character
\&   \eh      An horizontal whitespace
\&   \eH      A non horizontal whitespace
\&   \eN      A non newline (when not followed by \*(Aq{NAME}\*(Aq;;
\&           not valid up in a cold-ass lil characta class; equivalent ta [^\en]; it\*(Aqs
\&           like \*(Aq.\*(Aq without /s modifier)
\&   \ev      A vertical whitespace
\&   \eV      A non vertical whitespace
\&   \eR      A generic newline           (?>\ev|\ex0D\ex0A)
\&
\&   \eC      Match a funky-ass byte (with Unicode, \*(Aq.\*(Aq matches a cold-ass lil character)
\&   \epP     Match P\-named (Unicode) property
\&   \ep{...} Match Unicode property wit name longer than 1 character
\&   \ePP     Match non\-P
\&   \eP{...} Match lack of Unicode property wit name longer than 1 char
\&   \eX      Match Unicode extended grapheme cluster
.Ve
.PP
\&\s-1POSIX\s0 characta classes n' they Unicode n' Perl equivalents:
.PP
.Vb 3
\&            ASCII\-         Full\-
\&   POSIX    range          range    backslash
\& [[:...:]]  \ep{...}        \ep{...}   sequence    Description
\&
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& alnum   PosixAlnum       XPosixAlnum            Alpha plus Digit
\& alpha   PosixAlpha       XPosixAlpha            Alphabetic characters
\& ascii   ASCII                                   Any ASCII character
\& blank   PosixBlank       XPosixBlank   \eh       Horizontal whitespace;
\&                                                   full\-range also
\&                                                   freestyled as
\&                                                   \ep{HorizSpace} (GNU
\&                                                   extension)
\& cntrl   PosixCntrl       XPosixCntrl            Control characters
\& digit   PosixDigit       XPosixDigit   \ed       Decimal digits
\& graph   PosixGraph       XPosixGraph            Alnum plus Punct
\& lower   PosixLower       XPosixLower            Lowercase characters
\& print   PosixPrint       XPosixPrint            Graph plus Print yo, but
\&                                                   not any Cntrls
\& punct   PosixPunct       XPosixPunct            Punctuation n' Symbols
\&                                                   up in ASCII\-range; just
\&                                                   punct outside it
\& space   PosixSpace       XPosixSpace            [\es\ecK]
\&         PerlSpace        XPerlSpace    \es       Perl\*(Aqs whitespace def\*(Aqn
\& upper   PosixUpper       XPosixUpper            Uppercase characters
\& word    PosixWord        XPosixWord    \ew       Alnum + Unicode marks +
\&                                                   connectors, like \*(Aq_\*(Aq
\&                                                   (Perl extension)
\& xdigit  ASCII_Hex_Digit  XPosixDigit            Hexadecimal digit,
\&                                                    ASCII\-range is
\&                                                    [0\-9A\-Fa\-f]
.Ve
.PP
Also, various synonyms like \f(CW\*(C`\ep{Alpha}\*(C'\fR fo' \f(CW\*(C`\ep{XPosixAlpha}\*(C'\fR; all listed
in \*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops
.PP
Within a cold-ass lil characta class:
.PP
.Vb 3
\&    POSIX      traditionizzle   Unicode
\&  [:digit:]       \ed        \ep{Digit}
\&  [:^digit:]      \eD        \eP{Digit}
.Ve
.SS "\s-1ANCHORS\s0"
.IX Subsection "ANCHORS"
All is zero-width assertions.
.PP
.Vb 9
\&   ^  Match strang start (or line, if /m is used)
\&   $  Match strang end (or line, if /m is used) or before newline
\&   \eb Match word boundary (between \ew n' \eW)
\&   \eB Match except at word boundary (between \ew n' \ew or \eW n' \eW)
\&   \eA Match strang start (regardless of /m)
\&   \eZ Match strang end (before optionizzle newline)
\&   \ez Match absolute strang end
\&   \eG Match where previous m//g left off
\&   \eK Keep tha shiznit left of tha \eK, don\*(Aqt include it up in $&
.Ve
.SS "\s-1QUANTIFIERS\s0"
.IX Subsection "QUANTIFIERS"
Quantifiers is greedy by default n' match tha \fBlongest\fR leftmost.
.PP
.Vb 9
\&   Maximal Minimal Possessive Allowed range
\&   \-\-\-\-\-\-\- \-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-
\&   {n,m}   {n,m}?  {n,m}+     Must occur at least n times
\&                              but no mo' than m times
\&   {n,}    {n,}?   {n,}+      Must occur at least n times
\&   {n}     {n}?    {n}+       Must occur exactly n times
\&   *       *?      *+         0 or mo' times (same as {0,})
\&   +       +?      ++         1 or mo' times (same as {1,})
\&   ?       ??      ?+         0 or 1 time (same as {0,1})
.Ve
.PP
Da possessive forms (new up in Perl 5.10) prevent backtracking: what tha fuck gets
matched by a pattern wit a possessive quantifier aint gonna be backtracked
into, even if dat causes tha whole match ta fail.
.PP
There is no quantifier \f(CW\*(C`{,n}\*(C'\fR. Thatz interpreted as a literal string.
.SS "\s-1EXTENDED CONSTRUCTS\s0"
.IX Subsection "EXTENDED CONSTRUCTS"
.Vb 10
\&   (?#text)          A comment
\&   (?:...)           Groups subexpressions without capturin (cluster)
\&   (?pimsx\-imsx:...) Enable/disable option (as per m// modifiers)
\&   (?=...)           Zero\-width positizzle lookahead assertion
\&   (?!...)           Zero\-width wack lookahead assertion
\&   (?<=...)          Zero\-width positizzle lookbehind assertion
\&   (?<!...)          Zero\-width wack lookbehind assertion
\&   (?>...)           Grab what tha fuck we can, prohibit backtracking
\&   (?|...)           Branch reset
\&   (?<name>...)      Named capture
\&   (?\*(Aqname\*(Aq...)      Named capture
\&   (?P<name>...)     Named capture (python syntax)
\&   (?{ code })       Embedded code, return value becomes $^R
\&   (??{ code })      Dynamic regex, return value used as regex
\&   (?N)              Recurse tha fuck into subpattern number N
\&   (?\-N), (?+N)      Recurse tha fuck into Nth previous/next subpattern
\&   (?R), (?0)        Recurse all up in tha beginnin of tha whole pattern
\&   (?&name)          Recurse tha fuck into a named subpattern
\&   (?P>name)         Recurse tha fuck into a named subpattern (python syntax)
\&   (?(cond)yes|no)
\&   (?(cond)yes)      Conditionizzle expression, where "cond" can be:
\&                     (?=pat)   look\-ahead
\&                     (?!pat)   wack look\-ahead
\&                     (?<=pat)  look\-behind
\&                     (?<!pat)  wack look\-behind
\&                     (N)       subpattern N has matched something
\&                     (<name>)  named subpattern has matched something
\&                     (\*(Aqname\*(Aq)  named subpattern has matched something
\&                     (?{code}) code condition
\&                     (R)       legit if recursing
\&                     (RN)      legit if recursin tha fuck into Nth subpattern
\&                     (R&name)  legit if recursin tha fuck into named subpattern
\&                     (DEFINE)  always false, no no\-pattern allowed
.Ve
.SS "\s-1VARIABLES\s0"
.IX Subsection "VARIABLES"
.Vb 1
\&   $_    Default variable fo' operators ta use
\&
\&   $\`    Everythang prior ta matched string
\&   $&    Entire matched string
\&   $\*(Aq    Everythang afta ta matched string
\&
\&   ${^PREMATCH}   Everythang prior ta matched string
\&   ${^MATCH}      Entire matched string
\&   ${^POSTMATCH}  Everythang afta ta matched string
.Ve
.PP
Da use of \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR or \f(CW\*(C`$\*(Aq\*(C'\fR will slow down \fBall\fR regex use
within yo' program. Consult perlvar fo' \f(CW\*(C`@\-\*(C'\fR
to peep equivalent expressions dat won't cause slow down.
See also Devel::SawAmpersand. Y'all KNOW dat shit, muthafucka! Startin wit Perl 5.10, you
can also use tha equivalent variablez \f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR
and \f(CW\*(C`${^POSTMATCH}\*(C'\fR yo, but fo' dem ta be defined, you have to
specify tha \f(CW\*(C`/p\*(C'\fR (preserve) modifier on yo' regular expression.
.PP
.Vb 8
\&   $1, $2 ...  hold tha Xth captured expr
\&   $+    Last parenthesized pattern match
\&   $^N   Holdz da most thugged-out recently closed capture
\&   $^R   Holdz tha result of tha last (?{...}) expr
\&   @\-    Offsetz of startz of groups. $\-[0] holdz start of whole match
\&   @+    Offsetz of endz of groups. $+[0] holdz end of whole match
\&   %+    Named capture groups
\&   %\-    Named capture groups, as array refs
.Ve
.PP
Captured crews is numbered accordin ta they \fIopening\fR paren.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
.Vb 5
\&   lc          Lowercase a string
\&   lcfirst     Lowercase first char of a string
\&   uc          Uppercase a string
\&   ucfirst     Titlecase first char of a string
\&   fc          Foldcase a string
\&
\&   pos         Return or set current match position
\&   quotemeta   Quote metacharacters
\&   reset       Reset ?pattern? status
\&   study       Analyze strang fo' optimizin matching
\&
\&   split       Use a regex ta split a strang tha fuck into parts
.Ve
.PP
Da first five of these is like tha escape sequences \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\el\*(C'\fR,
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR, n' \f(CW\*(C`\eF\*(C'\fR.  For Titlecase, peep \*(L"Titlecase\*(R"; For
Foldcase, peep \*(L"Foldcase\*(R".
.SS "\s-1TERMINOLOGY\s0"
.IX Subsection "TERMINOLOGY"
\fITitlecase\fR
.IX Subsection "Titlecase"
.PP
Unicode concept which most often is equal ta uppercase yo, but for
certain charactas like tha German \*(L"sharp s\*(R" there be a gangbangin' finger-lickin' difference.
.PP
\fIFoldcase\fR
.IX Subsection "Foldcase"
.PP
Unicode form dat is useful when comparin strings regardless of case,
as certain charactas have compex one-to-many case mappings. Primarily a
variant of lowercase.
.SH "AUTHOR"
.IX Header "AUTHOR"
Iain Truskett. Updated by tha Perl 5 Porters.
.PP
This document may be distributed under tha same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
perlretut fo' a tutorial on regular expressions.
.IP "\(bu" 4
perlrequick fo' a rapid tutorial.
.IP "\(bu" 4
perlre fo' mo' details.
.IP "\(bu" 4
perlvar fo' details on tha variables.
.IP "\(bu" 4
perlop fo' details on tha operators.
.IP "\(bu" 4
perlfunc fo' details on tha functions.
.IP "\(bu" 4
perlfaq6 fo' FAQUIZZYs on regular expressions.
.IP "\(bu" 4
perlrebackslash fo' a reference on backslash sequences.
.IP "\(bu" 4
perlrecharclass fo' a reference on characta classes.
.IP "\(bu" 4
Da re module ta alta behaviour n' aid
debugging.
.IP "\(bu" 4
\&\*(L"Debuggin Regular Expressions\*(R" up in perldebug
.IP "\(bu" 4
perluniintro, perlunicode, charnames n' perllocale
for details on regexes n' internationalisation.
.IP "\(bu" 4
\&\fIMasterin Regular Expressions\fR by Jeffrey Friedl
(\fIhttp://oreilly.com/catalog/9780596528126/\fR) fo' a thorough groundin and
reference on tha topic.
.SH "THANKS"
.IX Header "THANKS"
Dizzy P.C. Wollmann,
Slick Rick Soderberg,
Shizzle M. Burke,
Tomothy Christiansen,
Jim Cromie,
and
Jeffrey Goff
for useful lyrics.
