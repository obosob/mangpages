.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLREAPI 1"
.TH PERLREAPI 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlreapi \- Perl regular expression plugin intercourse
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Az of Perl 5.9.5 there be a freshly smoked up intercourse fo' pluggin n' using
regular expression engines other than tha default one.
.PP
Each engine is supposed ta provide access ta a cold-ass lil constant structure of the
followin format:
.PP
.Vb 10
\&    typedef struct regexp_engine {
\&        REGEXP* (*comp) (pTHX_
\&                         const SV * const pattern, const U32 flags);
\&        I32     (*exec) (pTHX_
\&                         REGEXP * const rx,
\&                         char* stringarg,
\&                         char* strend, char* strbeg,
\&                         I32 minend, SV* screamer,
\&                         void* data, U32 flags);
\&        char*   (*intuit) (pTHX_
\&                           REGEXP * const rx, SV *sv,
\&                           char *strpos, char *strend, U32 flags,
\&                           struct re_scream_pos_data_s *data);
\&        SV*     (*checkstr) (pTHX_ REGEXP * const rx);
\&        void    (*free) (pTHX_ REGEXP * const rx);
\&        void    (*numbered_buff_FETCH) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV * const sv);
\&        void    (*numbered_buff_STORE) (pTHX_
\&                                        REGEXP * const rx,
\&                                        const I32 paren,
\&                                        SV const * const value);
\&        I32     (*numbered_buff_LENGTH) (pTHX_
\&                                         REGEXP * const rx,
\&                                         const SV * const sv,
\&                                         const I32 paren);
\&        SV*     (*named_buff) (pTHX_
\&                               REGEXP * const rx,
\&                               SV * const key,
\&                               SV * const value,
\&                               U32 flags);
\&        SV*     (*named_buff_iter) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const SV * const lastkey,
\&                                    const U32 flags);
\&        SV*     (*qr_package)(pTHX_ REGEXP * const rx);
\&    #ifdef USE_ITHREADS
\&        void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
\&    #endif
\&        REGEXP* (*op_comp) (...);
.Ve
.PP
When a regexp is compiled, its \f(CW\*(C`engine\*(C'\fR field is then set ta point at
the appropriate structure, so dat when it need ta be used Perl can find
the right routines ta do so.
.PP
In order ta install a freshly smoked up regexp handlez, \f(CW$^H{regcomp}\fR is set
to a integer which (when casted appropriately) resolves ta one of these
structures.  When compiling, tha \f(CW\*(C`comp\*(C'\fR method is executed, n' the
resultin \f(CW\*(C`regexp\*(C'\fR structurez engine field is sposed ta fuckin point back at
the same structure.
.PP
Da pTHX_ symbol up in tha definizzle be a macro used by Perl under threading
to provide a extra argument ta tha routine holdin a pointa back to
the interpreta dat is executin tha regexp. Right back up in yo muthafuckin ass. So under threadin all
routines git a extra argument.
.SH "Callbacks"
.IX Header "Callbacks"
.SS "comp"
.IX Subsection "comp"
.Vb 1
\&    REGEXP* comp(pTHX_ const SV * const pattern, const U32 flags);
.Ve
.PP
Compile tha pattern stored up in \f(CW\*(C`pattern\*(C'\fR rockin tha given \f(CW\*(C`flags\*(C'\fR and
return a pointa ta a prepared \f(CW\*(C`REGEXP\*(C'\fR structure dat can perform
the match.  See \*(L"Da \s-1REGEXP\s0 structure\*(R" below fo' a explanation of
the individual fieldz up in tha \s-1REGEXP\s0 struct.
.PP
Da \f(CW\*(C`pattern\*(C'\fR parameta is tha scalar dat was used as the
pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Previous versionz of Perl would pass two \f(CW\*(C`char*\*(C'\fR indicating
the start n' end of tha stringified pattern; tha followin snippet can
be used ta git tha oldschool parameters:
.PP
.Vb 3
\&    STRLEN plen;
\&    char*  exp = SvPV(pattern, plen);
\&    char* xend = exp + plen;
.Ve
.PP
Since any scalar can be passed as a pattern, itz possible ta implement
an engine dat do suttin' wit a array (\f(CW\*(C`"ook" =~ [ qw/ eek
hlagh / ]\*(C'\fR) or wit tha non-stringified form of a cold-ass lil compiled regular
expression (\f(CW\*(C`"ook" =~ qr/eek/\*(C'\fR).  Perlz own engine will always
stringify every last muthafuckin thang rockin tha snippet above yo, but dat don't mean
other engines have to.
.PP
Da \f(CW\*(C`flags\*(C'\fR parameta be a funky-ass bitfield which indicates which of the
\&\f(CW\*(C`msixp\*(C'\fR flags tha regex was compiled with.  It also gotz nuff
additionizzle info, like fuckin if \f(CW\*(C`use locale\*(C'\fR is up in effect.
.PP
Da \f(CW\*(C`eogc\*(C'\fR flags is stripped up before bein passed ta tha comp
routine.  Da regex engine do not need ta know if any of these
are set, as dem flags should only affect what tha fuck Perl do wit the
pattern n' its match variables, not how tha fuck it gets compiled and
executed.
.PP
By tha time tha comp callback is called, a shitload of these flags have
already had effect (noted below where applicable).  However most of
their effect occurs afta tha comp callback has run, up in routines that
read tha \f(CW\*(C`rx\->extflags\*(C'\fR field which it populates.
.PP
In general tha flags should be preserved up in \f(CW\*(C`rx\->extflags\*(C'\fR after
compilation, although tha regex engine might wanna add or delete
some of dem ta invoke or disable some special behavior up in Perl.  The
flags along wit any special behavior they cause is documented below:
.PP
Da pattern modifiers:
.ie n .IP """/m"" \- RXf_PMf_MULTILINE" 4
.el .IP "\f(CW/m\fR \- RXf_PMf_MULTILINE" 4
.IX Item "/m - RXf_PMf_MULTILINE"
If dis is up in \f(CW\*(C`rx\->extflags\*(C'\fR it is ghon be passed to
\&\f(CW\*(C`Perl_fbm_instr\*(C'\fR by \f(CW\*(C`pp_split\*(C'\fR which will treat tha subject string
as a multi-line string.
.ie n .IP """/s"" \- RXf_PMf_SINGLELINE" 4
.el .IP "\f(CW/s\fR \- RXf_PMf_SINGLELINE" 4
.IX Item "/s - RXf_PMf_SINGLELINE"
.PD 0
.ie n .IP """/i"" \- RXf_PMf_FOLD" 4
.el .IP "\f(CW/i\fR \- RXf_PMf_FOLD" 4
.IX Item "/i - RXf_PMf_FOLD"
.ie n .IP """/x"" \- RXf_PMf_EXTENDED" 4
.el .IP "\f(CW/x\fR \- RXf_PMf_EXTENDED" 4
.IX Item "/x - RXf_PMf_EXTENDED"
.PD
If present on a regex, \f(CW"#"\fR comments is ghon be handled differently by the
tokenizer up in some cases.
.Sp
\&\s-1TODO:\s0 Document dem cases.
.ie n .IP """/p"" \- RXf_PMf_KEEPCOPY" 4
.el .IP "\f(CW/p\fR \- RXf_PMf_KEEPCOPY" 4
.IX Item "/p - RXf_PMf_KEEPCOPY"
\&\s-1TODO:\s0 Document this
.IP "Characta set" 4
.IX Item "Characta set"
Da characta set semantics is determined by a enum dat is contained
in dis field. Y'all KNOW dat shit, muthafucka!  This is still experimenstrual n' subject ta chizzle yo, but
the current intercourse returns tha rulez by use of tha in-line function
\&\f(CW\*(C`get_regex_charset(const U32 flags)\*(C'\fR.  Da only currently documented
value returned from it is \s-1REGEX_LOCALE_CHARSET,\s0 which is set if
\&\f(CW\*(C`use locale\*(C'\fR is up in effect. If present up in \f(CW\*(C`rx\->extflags\*(C'\fR,
\&\f(CW\*(C`split\*(C'\fR will use tha locale dependent definizzle of whitespace
when RXf_SKIPWHITE or RXf_WHITE is up in effect.  \s-1ASCII\s0 whitespace
is defined as per isSPACE, n' by tha internal
macros \f(CW\*(C`is_utf8_space\*(C'\fR under \s-1UTF\-8,\s0 n' \f(CW\*(C`isSPACE_LC\*(C'\fR under \f(CW\*(C`use
locale\*(C'\fR.
.PP
Additionizzle flags:
.IP "RXf_SPLIT" 4
.IX Item "RXf_SPLIT"
This flag was removed up in perl 5.18.0.  \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR is now special-cased
solely up in tha parser n' shit.  RXf_SPLIT is still #defined, so you can test fo' dat shit.
This is how tha fuck it used ta work:
.Sp
If \f(CW\*(C`split\*(C'\fR is invoked as \f(CW\*(C`split \*(Aq \*(Aq\*(C'\fR or wit no arguments (which
really means \f(CW\*(C`split(\*(Aq \*(Aq, $_)\*(C'\fR, peep split), Perl will
set dis flag.  Da regex engine can then check fo' it n' set the
\&\s-1SKIPWHITE\s0 n' \s-1WHITE\s0 extflags.  To do this, tha Perl engine do:
.Sp
.Vb 2
\&    if (flags & RXf_SPLIT && r\->prelen == 1 && r\->precomp[0] == \*(Aq \*(Aq)
\&        r\->extflags |= (RXf_SKIPWHITE|RXf_WHITE);
.Ve
.PP
These flags can be set durin compilation ta enable optimizations in
the \f(CW\*(C`split\*(C'\fR operator.
.IP "RXf_SKIPWHITE" 4
.IX Item "RXf_SKIPWHITE"
This flag was removed up in perl 5.18.0.  It be still #defined, so you can
set it yo, but bustin so gonna git no effect.  This is how tha fuck it used ta work:
.Sp
If tha flag is present up in \f(CW\*(C`rx\->extflags\*(C'\fR \f(CW\*(C`split\*(C'\fR will delete
whitespace from tha start of tha subject strang before itz operated
on. I aint talkin' bout chicken n' gravy biatch.  What tha fuck iz considered whitespace dependz on if tha subject be a
\&\s-1UTF\-8\s0 strang n' if tha \f(CW\*(C`RXf_PMf_LOCALE\*(C'\fR flag is set.
.Sp
If RXf_WHITE is set up in addizzle ta dis flag, \f(CW\*(C`split\*(C'\fR will behave like
\&\f(CW\*(C`split " "\*(C'\fR under tha Perl engine.
.IP "RXf_START_ONLY" 4
.IX Item "RXf_START_ONLY"
Tells tha split operator ta split tha target strang on newlines
(\f(CW\*(C`\en\*(C'\fR) without invokin tha regex engine.
.Sp
Perlz engine sets dis if tha pattern is \f(CW\*(C`/^/\*(C'\fR (\f(CW\*(C`plen == 1 && *exp
== \*(Aq^\*(Aq\*(C'\fR), even under \f(CW\*(C`/^/s\*(C'\fR; peep split.  Of course a
different regex engine might wanna use tha same optimizations
with a gangbangin' finger-lickin' different syntax.
.IP "RXf_WHITE" 4
.IX Item "RXf_WHITE"
Tells tha split operator ta split tha target strang on whitespace
without invokin tha regex engine.  Da definizzle of whitespace varies
dependin on if tha target strang be a \s-1UTF\-8\s0 strang n' on
if RXf_PMf_LOCALE is set.
.Sp
Perlz engine sets dis flag if tha pattern is \f(CW\*(C`\es+\*(C'\fR.
.IP "RXf_NULL" 4
.IX Item "RXf_NULL"
Tells tha split operator ta split tha target strang on
characters.  Da definizzle of characta varies dependin on if
the target strang be a \s-1UTF\-8\s0 string.
.Sp
Perlz engine sets dis flag on empty patterns, dis optimization
makes \f(CW\*(C`split //\*(C'\fR much fasta than it would otherwise be.  It aint nuthin but even
fasta than \f(CW\*(C`unpack\*(C'\fR.
.IP "RXf_NO_INPLACE_SUBST" 4
.IX Item "RXf_NO_INPLACE_SUBST"
Added up in perl 5.18.0, dis flag indicates dat a regular expression might
perform a operation dat would interfere wit inplace substituion. I aint talkin' bout chicken n' gravy biatch. For
instizzle it might contain lookbehind, or assign ta non-magical variables
(like fuckin \f(CW$REGMARK\fR n' \f(CW$REGERROR\fR) durin matching.  \f(CW\*(C`s///\*(C'\fR will skip
certain optimisations when dis is set.
.SS "exec"
.IX Subsection "exec"
.Vb 4
\&    I32 exec(pTHX_ REGEXP * const rx,
\&             char *stringarg, char* strend, char* strbeg,
\&             I32 minend, SV* screamer,
\&             void* data, U32 flags);
.Ve
.PP
Execute a regexp. Da arguments are
.IP "rx" 4
.IX Item "rx"
Da regular expression ta execute.
.IP "screamer" 4
.IX Item "screamer"
This strangely-named arg is tha \s-1SV\s0 ta be matched against.  Note dat the
actual char array ta be matched against is supplied by tha arguments
busted lyrics bout below; tha \s-1SV\s0 is just used ta determine UTF8ness, \f(CW\*(C`pos()\*(C'\fR etc.
.IP "strbeg" 4
.IX Item "strbeg"
Pointa ta tha physical start of tha string.
.IP "strend" 4
.IX Item "strend"
Pointa ta tha characta followin tha physical end of tha strang (i.e.
the \f(CW\*(C`\e0\*(C'\fR).
.IP "stringarg" 4
.IX Item "stringarg"
Pointa ta tha posizzle up in tha strang where matchin should start; it might
not be equal ta \f(CW\*(C`strbeg\*(C'\fR (for example up in a lata iteration of \f(CW\*(C`/.../g\*(C'\fR).
.IP "minend" 4
.IX Item "minend"
Minimum length of strang (measured up in bytes from \f(CW\*(C`stringarg\*(C'\fR) dat must
match; if tha engine reaches tha end of tha match but aint reached this
posizzle up in tha string, it should fail.
.IP "data" 4
.IX Item "data"
Optimisation data; subject ta chizzle.
.IP "flags" 4
.IX Item "flags"
Optimisation flags; subject ta chizzle.
.SS "intuit"
.IX Subsection "intuit"
.Vb 3
\&    char* intuit(pTHX_ REGEXP * const rx,
\&                  SV *sv, char *strpos, char *strend,
\&                  const U32 flags, struct re_scream_pos_data_s *data);
.Ve
.PP
Find tha start posizzle where a regex match should be attempted,
or possibly if tha regex engine should not be run cuz the
pattern can't match.  This is called, as appropriate, by tha core,
dependin on tha jointz of tha \f(CW\*(C`extflags\*(C'\fR gangmember of tha \f(CW\*(C`regexp\*(C'\fR
structure.
.SS "checkstr"
.IX Subsection "checkstr"
.Vb 1
\&    SV* checkstr(pTHX_ REGEXP * const rx);
.Ve
.PP
Return a \s-1SV\s0 containin a strang dat must step tha fuck up in tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Used
by \f(CW\*(C`split\*(C'\fR fo' optimisin matches.
.SS "free"
.IX Subsection "free"
.Vb 1
\&    void free(pTHX_ REGEXP * const rx);
.Ve
.PP
Called by Perl when it is freein a regexp pattern so dat tha engine
can release any resources pointed ta by tha \f(CW\*(C`pprivate\*(C'\fR gangmember of the
\&\f(CW\*(C`regexp\*(C'\fR structure.  This is only responsible fo' freein private data;
Perl will handle releasin anythang else contained up in tha \f(CW\*(C`regexp\*(C'\fR structure.
.SS "Numbered capture callbacks"
.IX Subsection "Numbered capture callbacks"
Called ta get/set tha value of \f(CW\*(C`$\`\*(C'\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, \f(CW$&\fR n' they named
equivalents, ${^PREMATCH}, ${^POSTMATCH} n' $^{\s-1MATCH\s0}, as well as the
numbered capture crews (\f(CW$1\fR, \f(CW$2\fR, ...).
.PP
Da \f(CW\*(C`paren\*(C'\fR parameta is ghon be \f(CW1\fR fo' \f(CW$1\fR, \f(CW2\fR fo' \f(CW$2\fR n' so
forth, n' have these symbolic joints fo' tha special variables:
.PP
.Vb 6
\&    ${^PREMATCH}  RX_BUFF_IDX_CARET_PREMATCH
\&    ${^POSTMATCH} RX_BUFF_IDX_CARET_POSTMATCH
\&    ${^MATCH}     RX_BUFF_IDX_CARET_FULLMATCH
\&    $\`            RX_BUFF_IDX_PREMATCH
\&    $\*(Aq            RX_BUFF_IDX_POSTMATCH
\&    $&            RX_BUFF_IDX_FULLMATCH
.Ve
.PP
Note dat up in Perl 5.17.3 n' earlier, tha last three constants was also
used fo' tha caret variantz of tha variables.
.PP
Da names done been chosen by analogy wit Tie::Scalar methods
names wit a additionizzle \fB\s-1LENGTH\s0\fR callback fo' efficiency.  However
named capture variablez is currently not tied internally but
implemented via magic.
.PP
\fInumbered_buff_FETCH\fR
.IX Subsection "numbered_buff_FETCH"
.PP
.Vb 2
\&    void numbered_buff_FETCH(pTHX_ REGEXP * const rx, const I32 paren,
\&                             SV * const sv);
.Ve
.PP
Fetch a specified numbered capture.  \f(CW\*(C`sv\*(C'\fR should be set ta tha scalar
to return, tha scalar is passed as a argument rather than being
returned from tha function cuz when itz called Perl already has a
scalar ta store tha value, bustin another one would be
redundant.  Da scalar can be set wit \f(CW\*(C`sv_setsv\*(C'\fR, \f(CW\*(C`sv_setpvn\*(C'\fR and
friends, peep perlapi.
.PP
This callback is where Perl untaints its own capture variablez under
taint mode (see perlsec).  See tha \f(CW\*(C`Perl_reg_numbered_buff_fetch\*(C'\fR
function up in \fIregcomp.c\fR fo' how tha fuck ta untaint capture variablez if
thatz suttin' you'd like yo' engine ta do as well.
.PP
\fInumbered_buff_STORE\fR
.IX Subsection "numbered_buff_STORE"
.PP
.Vb 4
\&    void    (*numbered_buff_STORE) (pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value);
.Ve
.PP
Set tha value of a numbered capture variable.  \f(CW\*(C`value\*(C'\fR is tha scalar
that is ta be used as tha freshly smoked up value.  It aint nuthin but up ta tha engine ta make
sure dis is used as tha freshly smoked up value (or reject it).
.PP
Example:
.PP
.Vb 4
\&    if ("ook" =~ /(o*)/) {
\&        # \*(Aqparen\*(Aq is ghon be \*(Aq1\*(Aq n' \*(Aqvalue\*(Aq is ghon be \*(Aqee\*(Aq
\&        $1 =~ tr/o/e/;
\&    }
.Ve
.PP
Perlz own engine will croak on any attempt ta modify tha capture
variables, ta do dis up in another engine use tha followin callback
(copied from \f(CW\*(C`Perl_reg_numbered_buff_store\*(C'\fR):
.PP
.Vb 9
\&    void
\&    Example_reg_numbered_buff_store(pTHX_
\&                                    REGEXP * const rx,
\&                                    const I32 paren,
\&                                    SV const * const value)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        PERL_UNUSED_ARG(paren);
\&        PERL_UNUSED_ARG(value);
\&
\&        if (!PL_localizing)
\&            Perl_croak(aTHX_ PL_no_modify);
\&    }
.Ve
.PP
Actually Perl aint gonna \fIalways\fR croak up in a statement dat looks
like it would modify a numbered capture variable.  This is cuz the
\&\s-1STORE\s0 callback aint gonna be called if Perl can determine dat it
doesn't gotta modify tha value.  This is exactly how tha fuck tied variables
behave up in tha same thang:
.PP
.Vb 2
\&    package CaptureVar;
\&    use base \*(AqTie::Scalar\*(Aq;
\&
\&    sub TIESCALAR { bless [] }
\&    sub FETCH { undef }
\&    sub STORE { take a thugged-out dirtnap "This don\*(Aqt git called" }
\&
\&    package main;
\&
\&    tie mah $sv => "CaptureVar";
\&    $sv =~ y/a/b/;
.Ve
.PP
Because \f(CW$sv\fR is \f(CW\*(C`undef\*(C'\fR when tha \f(CW\*(C`y///\*(C'\fR operator be applied ta it,
the transliteration won't straight-up execute n' tha program won't
\&\f(CW\*(C`die\*(C'\fR.  This is different ta how tha fuck 5.8 n' earlier versions behaved
since tha capture variablez was \s-1READONLY\s0 variablez then; now they'll
just take a thugged-out dirtnap when assigned ta up in tha default engine.
.PP
\fInumbered_buff_LENGTH\fR
.IX Subsection "numbered_buff_LENGTH"
.PP
.Vb 4
\&    I32 numbered_buff_LENGTH (pTHX_
\&                              REGEXP * const rx,
\&                              const SV * const sv,
\&                              const I32 paren);
.Ve
.PP
Git tha \f(CW\*(C`length\*(C'\fR of a cold-ass lil capture variable.  Therez a special callback
for dis so dat Perl don't gotta do a \s-1FETCH\s0 n' run \f(CW\*(C`length\*(C'\fR on
the result, since tha length is (in Perlz case) known from a offset
stored up in \f(CW\*(C`rx\->offs\*(C'\fR, dis is much mo' efficient:
.PP
.Vb 3
\&    I32 s1  = rx\->offs[paren].start;
\&    I32 s2  = rx\->offs[paren].end;
\&    I32 len = t1 \- s1;
.Ve
.PP
This be a lil bit mo' complex up in tha case of \s-1UTF\-8,\s0 peep what
\&\f(CW\*(C`Perl_reg_numbered_buff_length\*(C'\fR do with
is_utf8_string_loclen.
.SS "Named capture callbacks"
.IX Subsection "Named capture callbacks"
Called ta get/set tha value of \f(CW\*(C`%+\*(C'\fR n' \f(CW\*(C`%\-\*(C'\fR, as well as by some
utilitizzle functions up in re.
.PP
There is two callbacks, \f(CW\*(C`named_buff\*(C'\fR is called up in all tha cases the
\&\s-1FETCH, STORE, DELETE, CLEAR, EXISTS\s0 n' \s-1SCALAR \s0Tie::Hash callbacks
would be on chizzlez ta \f(CW\*(C`%+\*(C'\fR n' \f(CW\*(C`%\-\*(C'\fR n' \f(CW\*(C`named_buff_iter\*(C'\fR up in the
same cases as \s-1FIRSTKEY\s0 n' \s-1NEXTKEY.\s0
.PP
Da \f(CW\*(C`flags\*(C'\fR parameta can be used ta determine which of these
operations tha callbacks should respond to.  Da followin flags are
currently defined:
.PP
Which Tie::Hash operation is bein performed from tha Perl level on
\&\f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%+\*(C'\fR, if any:
.PP
.Vb 8
\&    RXapif_FETCH
\&    RXapif_STORE
\&    RXapif_DELETE
\&    RXapif_CLEAR
\&    RXapif_EXISTS
\&    RXapif_SCALAR
\&    RXapif_FIRSTKEY
\&    RXapif_NEXTKEY
.Ve
.PP
If \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR is bein operated on, if any.
.PP
.Vb 2
\&    RXapif_ONE /* %+ */
\&    RXapif_ALL /* %\- */
.Ve
.PP
If dis is bein called as \f(CW\*(C`re::regname\*(C'\fR, \f(CW\*(C`re::regnames\*(C'\fR or
\&\f(CW\*(C`re::regnames_count\*(C'\fR, if any.  Da first two is ghon be combined with
\&\f(CW\*(C`RXapif_ONE\*(C'\fR or \f(CW\*(C`RXapif_ALL\*(C'\fR.
.PP
.Vb 3
\&    RXapif_REGNAME
\&    RXapif_REGNAMES
\&    RXapif_REGNAMES_COUNT
.Ve
.PP
Internally \f(CW\*(C`%+\*(C'\fR n' \f(CW\*(C`%\-\*(C'\fR is implemented wit a real tied intercourse
via Tie::Hash::NamedCapture.  Da methodz up in dat package will call
back tha fuck into these functions.  However tha usage of
Tie::Hash::NamedCapture fo' dis purpose might chizzle up in future
releases.  For instizzle dis might be implemented by magic instead
(would need a extension ta mgvtbl).
.PP
\fInamed_buff\fR
.IX Subsection "named_buff"
.PP
.Vb 2
\&    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
\&                           SV * const value, U32 flags);
.Ve
.PP
\fInamed_buff_iter\fR
.IX Subsection "named_buff_iter"
.PP
.Vb 4
\&    SV*     (*named_buff_iter) (pTHX_
\&                                REGEXP * const rx,
\&                                const SV * const lastkey,
\&                                const U32 flags);
.Ve
.SS "qr_package"
.IX Subsection "qr_package"
.Vb 1
\&    SV* qr_package(pTHX_ REGEXP * const rx);
.Ve
.PP
Da package tha qr// magic object is pimped tha fuck into (as peeped by \f(CW\*(C`ref
qr//\*(C'\fR).  It be recommended dat engines chizzle dis ta they package
name fo' identification regardless of if they implement methods
on tha object.
.PP
Da package dis method returns should also have tha internal
\&\f(CW\*(C`Regexp\*(C'\fR package up in its \f(CW@ISA\fR.  \f(CW\*(C`qr//\->isa("Regexp")\*(C'\fR should always
be legit regardless of what tha fuck engine is bein used.
.PP
Example implementation might be:
.PP
.Vb 6
\&    SV*
\&    Example_qr_package(pTHX_ REGEXP * const rx)
\&    {
\&        PERL_UNUSED_ARG(rx);
\&        return newSVpvs("re::engine::Example");
\&    }
.Ve
.PP
Any method calls on a object pimped wit \f(CW\*(C`qr//\*(C'\fR is ghon be dispatched ta the
package as a aiiight object.
.PP
.Vb 3
\&    use re::engine::Example;
\&    mah $re = qr//;
\&    $re\->meth; # dispatched ta re::engine::Example::meth()
.Ve
.PP
To retrieve tha \f(CW\*(C`REGEXP\*(C'\fR object from tha scalar up in a \s-1XS\s0 function use
the \f(CW\*(C`SvRX\*(C'\fR macro, peep \*(L"\s-1REGEXP\s0 Functions\*(R" up in perlapi.
.PP
.Vb 3
\&    void meth(SV * rv)
\&    PPCODE:
\&        REGEXP * re = SvRX(sv);
.Ve
.SS "dupe"
.IX Subsection "dupe"
.Vb 1
\&    void* dupe(pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
.Ve
.PP
On threaded buildz a regexp may need ta be duplicated so dat tha pattern
can be used by multiple threads.  This routine is sposed ta fuckin handle the
duplication of any private data pointed ta by tha \f(CW\*(C`pprivate\*(C'\fR gangmember of
the \f(CW\*(C`regexp\*(C'\fR structure.  It is ghon be called wit tha preconstructed new
\&\f(CW\*(C`regexp\*(C'\fR structure as a argument, tha \f(CW\*(C`pprivate\*(C'\fR member will point at
the \fBold\fR private structure, n' it is dis routinez responsibilitizzle to
construct a cold-ass lil copy n' return a pointa ta it (which Perl will then use to
overwrite tha field as passed ta dis routine.)
.PP
This allows tha engine ta dupe its private data but also if necessary
modify tha final structure if it straight-up must.
.PP
On unthreaded buildz dis field don't exist.
.SS "op_comp"
.IX Subsection "op_comp"
This is private ta tha Perl core n' subject ta chizzle. Right back up in yo muthafuckin ass. Should be left
null.
.SH "Da REGEXP structure"
.IX Header "Da REGEXP structure"
Da \s-1REGEXP\s0 struct is defined up in \fIregexp.h\fR.
All regex engines must be able to
correctly build such a structure up in they \*(L"comp\*(R" routine.
.PP
Da \s-1REGEXP\s0 structure gotz nuff all tha data dat Perl need ta be aware of
to properly work wit tha regular expression. I aint talkin' bout chicken n' gravy biatch.  It includes data about
optimisations dat Perl can use ta determine if tha regex engine should
really be used, n' various other control info dat is needed ta properly
execute patterns up in various contexts, like fuckin if tha pattern anchored in
some way, or what tha fuck flags was used durin tha compile, or if the
program gotz nuff special constructs dat Perl need ta be aware of.
.PP
In addizzle it gotz nuff two fieldz dat is intended fo' tha private
use of tha regex engine dat compiled tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  These is the
\&\f(CW\*(C`intflags\*(C'\fR n' \f(CW\*(C`pprivate\*(C'\fR members.  \f(CW\*(C`pprivate\*(C'\fR be a void pointa to
an arbitrary structure, whose use n' pimpment is tha responsibility
of tha compilin engine.  Perl aint NEVER gonna modify either of these
values.
.PP
.Vb 3
\&    typedef struct regexp {
\&        /* what tha fuck engine pimped dis regexp, biatch? */
\&        const struct regexp_engine* engine;
\&
\&        /* what tha fuck re is dis a lightweight copy of, biatch? */
\&        struct regexp* mother_re;
\&
\&        /* Hype bout tha match dat tha Perl core uses ta manage
\&         * thangs */
\&        U32 extflags;   /* Flags used both externally n' internally */
\&        I32 minlen;     /* mininum possible number of chars up in */
\&                           strang ta match */
\&        I32 minlenret;  /* mininum possible number of chars up in $& */
\&        U32 gofs;       /* chars left of pos dat we search from */
\&
\&        /* substrin data bout strings dat must appear
\&           up in tha final match, used fo' optimisations */
\&        struct reg_substr_data *substrs;
\&
\&        U32 nparens;  /* number of capture crews */
\&
\&        /* private engine specific data */
\&        U32 intflags;   /* Engine Specific Internal flags */
\&        void *pprivate; /* Data private ta tha regex engine which 
\&                           pimped dis object. */
\&
\&        /* Data bout tha last/current match. These is modified during
\&         * matching*/
\&        U32 lastparen;            /* highest close paren matched ($+) */
\&        U32 lastcloseparen;       /* last close paren matched ($^N) */
\&        regexp_paren_pair *swap;  /* Swap copy of *offs */
\&        regexp_paren_pair *offs;  /* Array of offsets fo' (@\-) and
\&                                     (@+) */
\&
\&        char *subbeg;  /* saved or original gangsta strang so \edigit works
\&                          forever n' shit. */
\&        SV_SAVED_COPY  /* If non\-NULL, SV which is COW from original gangsta */
\&        I32 sublen;    /* Length of strang pointed by subbeg */
\&        I32 suboffset;  /* byte offset of subbeg from logical start of
\&                           str */
\&        I32 subcoffset; /* suboffset equiv yo, but up in chars (for @\-/@+) */
\&
\&        /* Hype bout tha match dat isn\*(Aqt often used */
\&        I32 prelen;           /* length of precomp */
\&        const char *precomp;  /* pre\-compilation regular expression */
\&
\&        char *wrapped;  /* wrapped version of tha pattern */
\&        I32 wraplen;    /* length of wrapped */
\&
\&        I32 seen_evals;   /* number of eval crews up in tha pattern \- for
\&                             securitizzle checks */
\&        HV *paren_names;  /* Optionizzle hash of paren names */
\&
\&        /* Refcount of dis regexp */
\&        I32 refcnt;             /* Refcount of dis regexp */
\&    } regexp;
.Ve
.PP
Da fieldz is discussed up in mo' detail below:
.ie n .SS """engine"""
.el .SS "\f(CWengine\fP"
.IX Subsection "engine"
This field points at a \f(CW\*(C`regexp_engine\*(C'\fR structure which gotz nuff pointers
to tha subroutines dat is ta be used fo' struttin a match.  It
is tha compilin routinez responsibilitizzle ta populate dis field before
returnin tha regexp object.
.PP
Internally dis is set ta \f(CW\*(C`NULL\*(C'\fR unless a cold-ass lil custom engine is specified in
\&\f(CW$^H{regcomp}\fR, Perlz own set of callbacks can be accessed up in tha struct
pointed ta by \f(CW\*(C`RE_ENGINE_PTR\*(C'\fR.
.ie n .SS """mother_re"""
.el .SS "\f(CWmother_re\fP"
.IX Subsection "mother_re"
\&\s-1TODO,\s0 peep <http://www.mail\-archive.com/perl5\-changes@perl.org/msg17328.html>
.ie n .SS """extflags"""
.el .SS "\f(CWextflags\fP"
.IX Subsection "extflags"
This is ghon be used by Perl ta peep what tha fuck flags tha regexp was compiled
with, dis will normally be set ta tha value of tha flags parameta by
the comp callback.  See tha comp documentation for
valid flags.
.ie n .SS """minlen"" ""minlenret"""
.el .SS "\f(CWminlen\fP \f(CWminlenret\fP"
.IX Subsection "minlen minlenret"
Da minimum strang length (in characters) required fo' tha pattern ta match.
This is used to
prune tha search space by not botherin ta match any closer ta tha end of a
strin than would allow a match.  For instizzle there is no point up in even
startin tha regex engine if tha minlen is 10 but tha strang is only 5
charactas long.  There is no way dat tha pattern can match.
.PP
\&\f(CW\*(C`minlenret\*(C'\fR is tha minimum length (in characters) of tha strang dat would
be found up in $& afta a match.
.PP
Da difference between \f(CW\*(C`minlen\*(C'\fR n' \f(CW\*(C`minlenret\*(C'\fR can be peeped up in the
followin pattern:
.PP
.Vb 1
\&    /ns(?=\ed)/
.Ve
.PP
where tha \f(CW\*(C`minlen\*(C'\fR would be 3 but \f(CW\*(C`minlenret\*(C'\fR would only be 2 as tha \ed is
required ta match but aint actually
included up in tha matched content.  This
distinction is particularly blingin as tha substitution logic uses the
\&\f(CW\*(C`minlenret\*(C'\fR ta tell if it can do in-place substitutions (these can
result up in considerable speed-up).
.ie n .SS """gofs"""
.el .SS "\f(CWgofs\fP"
.IX Subsection "gofs"
Left offset from \fIpos()\fR ta start match at.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Substrin data bout strings dat must step tha fuck up in tha final match.  This
is currently only used internally by Perlz engine yo, but might be
used up in tha future fo' all engines fo' optimisations.
.ie n .SS """nparens"", ""lastparen"", n' ""lastcloseparen"""
.el .SS "\f(CWnparens\fP, \f(CWlastparen\fP, n' \f(CWlastcloseparen\fP"
.IX Subsection "nparens, lastparen, n' lastcloseparen"
These fieldz is used ta keep track of how tha fuck nuff paren crews could be matched
in tha pattern, which was tha last open paren ta be entered, n' which was
the last close paren ta be entered.
.ie n .SS """intflags"""
.el .SS "\f(CWintflags\fP"
.IX Subsection "intflags"
Da enginez private copy of tha flags tha pattern was compiled with. Usually
this is tha same ol' dirty as \f(CW\*(C`extflags\*(C'\fR unless tha engine chose ta modify one of em.
.ie n .SS """pprivate"""
.el .SS "\f(CWpprivate\fP"
.IX Subsection "pprivate"
A void* pointin ta a engine-defined
data structure.  Da Perl engine uses the
\&\f(CW\*(C`regexp_internal\*(C'\fR structure (see \*(L"Base Structures\*(R" up in perlreguts) but a cold-ass lil custom
engine should use suttin' else.
.ie n .SS """swap"""
.el .SS "\f(CWswap\fP"
.IX Subsection "swap"
Unused. Y'all KNOW dat shit, muthafucka!  Left up in fo' compatibilitizzle wit Perl 5.10.0.
.ie n .SS """offs"""
.el .SS "\f(CWoffs\fP"
.IX Subsection "offs"
A \f(CW\*(C`regexp_paren_pair\*(C'\fR structure which defines offsets tha fuck into tha strang being
matched which correspond ta tha \f(CW$&\fR n' \f(CW$1\fR, \f(CW$2\fR etc. captures, the
\&\f(CW\*(C`regexp_paren_pair\*(C'\fR struct is defined as bigs up:
.PP
.Vb 4
\&    typedef struct regexp_paren_pair {
\&        I32 start;
\&        I32 end;
\&    } regexp_paren_pair;
.Ve
.PP
If \f(CW\*(C`\->offs[num].start\*(C'\fR or \f(CW\*(C`\->offs[num].end\*(C'\fR is \f(CW\*(C`\-1\*(C'\fR then that
capture crew did not match.
\&\f(CW\*(C`\->offs[0].start/end\*(C'\fR represents \f(CW$&\fR (or
\&\f(CW\*(C`${^MATCH}\*(C'\fR under \f(CW\*(C`//p\*(C'\fR) n' \f(CW\*(C`\->offs[paren].end\*(C'\fR matches \f(CW$$paren\fR where
\&\f(CW$paren \fR= 1>.
.ie n .SS """precomp"" ""prelen"""
.el .SS "\f(CWprecomp\fP \f(CWprelen\fP"
.IX Subsection "precomp prelen"
Used fo' optimisations.  \f(CW\*(C`precomp\*(C'\fR holdz a cold-ass lil copy of tha pattern that
was compiled n' \f(CW\*(C`prelen\*(C'\fR its length.  When a freshly smoked up pattern is ta be
compiled (like fuckin inside a loop) tha internal \f(CW\*(C`regcomp\*(C'\fR operator
checks if tha last compiled \f(CW\*(C`REGEXP\*(C'\fRz \f(CW\*(C`precomp\*(C'\fR n' \f(CW\*(C`prelen\*(C'\fR
are equivalent ta tha freshly smoked up one, n' if so uses tha oldschool pattern instead
of compilin a freshly smoked up one.
.PP
Da relevant snippet from \f(CW\*(C`Perl_pp_regcomp\*(C'\fR:
.PP
.Vb 3
\&        if (!re || !re\->precomp || re\->prelen != (I32)len ||
\&            memNE(re\->precomp, t, len))
\&        /* Compile a freshly smoked up pattern */
.Ve
.ie n .SS """paren_names"""
.el .SS "\f(CWparen_names\fP"
.IX Subsection "paren_names"
This be a hash used internally ta track named capture crews n' their
offsets, n' you can put dat on yo' toast.  Da keys is tha namez of tha buffers tha joints is dualvars,
with tha \s-1IV\s0 slot holdin tha number of buffers wit tha given name n' the
pv bein a embedded array of I32.  Da joints may also be contained
independently up in tha data array up in cases where named backreferences are
used.
.ie n .SS """substrs"""
.el .SS "\f(CWsubstrs\fP"
.IX Subsection "substrs"
Holdz shiznit on tha longest strang dat must occur at a gangbangin' fixed
offset from tha start of tha pattern, n' tha longest strang dat must
occur at a gangbangin' floatin offset from tha start of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Used ta do
Fast-Boyer-Moore searches on tha strang ta smoke up if its worth using
the regex engine at all, n' if so where up in tha strang ta search.
.ie n .SS """subbeg"" ""sublen"" ""saved_copy"" ""suboffset"" ""subcoffset"""
.el .SS "\f(CWsubbeg\fP \f(CWsublen\fP \f(CWsaved_copy\fP \f(CWsuboffset\fP \f(CWsubcoffset\fP"
.IX Subsection "subbeg sublen saved_copy suboffset subcoffset"
Used durin tha execution phase fo' managin search n' replace patterns,
and fo' providin tha text fo' \f(CW$&\fR, \f(CW$1\fR etc. \f(CW\*(C`subbeg\*(C'\fR points ta a
buffer (either tha original gangsta string, or a cold-ass lil copy up in tha case of
\&\f(CW\*(C`RX_MATCH_COPIED(rx)\*(C'\fR), n' \f(CW\*(C`sublen\*(C'\fR is tha length of tha buffer n' shit.  The
\&\f(CW\*(C`RX_OFFS\*(C'\fR start n' end indices index tha fuck into dis buffer.
.PP
In tha presence of tha \f(CW\*(C`REXEC_COPY_STR\*(C'\fR flag yo, but wit tha addizzle of
the \f(CW\*(C`REXEC_COPY_SKIP_PRE\*(C'\fR or \f(CW\*(C`REXEC_COPY_SKIP_POST\*(C'\fR flags, a engine
can chizzle not ta copy tha full buffer (although it must still do so in
the presence of \f(CW\*(C`RXf_PMf_KEEPCOPY\*(C'\fR or tha relevant bits bein set in
\&\f(CW\*(C`PL_sawampersand\*(C'\fR).  In dis case, it may set \f(CW\*(C`suboffset\*(C'\fR ta indicate the
number of bytes from tha logical start of tha buffer ta tha physical start
(i.e. \f(CW\*(C`subbeg\*(C'\fR).  It should also set \f(CW\*(C`subcoffset\*(C'\fR, tha number of
charactas up in tha offset. Da latta is needed ta support \f(CW\*(C`@\-\*(C'\fR n' \f(CW\*(C`@+\*(C'\fR
which work up in characters, not bytes.
.ie n .SS """wrapped"" ""wraplen"""
.el .SS "\f(CWwrapped\fP \f(CWwraplen\fP"
.IX Subsection "wrapped wraplen"
Stores tha strang \f(CW\*(C`qr//\*(C'\fR stringifies to. Da Perl engine fo' example
stores \f(CW\*(C`(?^:eek)\*(C'\fR up in tha case of \f(CW\*(C`qr/eek/\*(C'\fR.
.PP
When rockin a cold-ass lil custom engine dat don't support tha \f(CW\*(C`(?:)\*(C'\fR construct
for inline modifiers, itz probably dopest ta have \f(CW\*(C`qr//\*(C'\fR stringify to
the supplied pattern, note dat dis will create undesired patterns in
cases such as:
.PP
.Vb 3
\&    mah $x = qr/a|b/;  # "a|b"
\&    mah $y = qr/c/i;   # "c"
\&    mah $z = qr/$x$y/; # "a|bc"
.Ve
.PP
Therez no solution fo' dis problem other than makin tha custom
engine KNOW a cold-ass lil construct like \f(CW\*(C`(?:)\*(C'\fR.
.ie n .SS """seen_evals"""
.el .SS "\f(CWseen_evals\fP"
.IX Subsection "seen_evals"
This stores tha number of eval crews in
the pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  This is used fo' security
purposes when embeddin compiled regexes tha fuck into larger patterns wit \f(CW\*(C`qr//\*(C'\fR.
.ie n .SS """refcnt"""
.el .SS "\f(CWrefcnt\fP"
.IX Subsection "refcnt"
Da number of times tha structure is referenced. Y'all KNOW dat shit, muthafucka!  When
this falls ta 0, tha regexp be automatically freed
by a cold-ass lil call ta pregfree.  This should be set ta 1 in
each enginez \*(L"comp\*(R" routine.
.SH "HISTORY"
.IX Header "HISTORY"
Originally part of perlreguts.
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally freestyled by Yves Orton, expanded by \*(Aevar Arnfjo\*:r\*(d-
Bjarmason.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright 2006 Yves Orton n' 2007 \*(Aevar Arnfjo\*:r\*(d- Bjarmason.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
