.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ6 1"
.TH PERLFAQ6 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq6 \- Regular Expressions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section is surprisingly lil' small-ass cuz tha rest of tha \s-1FAQ\s0 is
littered wit lyrics involvin regular expressions. For example,
decodin a \s-1URL\s0 n' checkin whether suttin' be a number can be handled
with regular expressions yo, but dem lyrics is found elsewhere in
this document (in perlfaq9: \*(L"How tha fuck do I decode or create dem %\-encodings
on tha web\*(R" n' perlfaq4: \*(L"How tha fuck do I determine whether a scalar is
a number/whole/integer/float\*(R", ta be precise).
.SS "How tha fuck can I hope ta use regular expressions without bustin illegible n' unmaintainable code?"
.IX Xref "regex, legibilitizzle regexp, legibilitizzle regular expression, legibilitizzle x"
.IX Subsection "How tha fuck can I hope ta use regular expressions without bustin illegible n' unmaintainable code?"
Three steez can make regular expressions maintainable and
understandable.
.IP "Comments Outside tha Regex" 4
.IX Item "Comments Outside tha Regex"
Describe what tha fuck you bustin n' how tha fuck you bustin it, rockin aiiight Perl
comments.
.Sp
.Vb 3
\&    # turn tha line tha fuck into tha straight-up original gangsta word, a cold-ass lil colon, n' the
\&    # number of charactas on tha rest of tha line
\&    s/^(\ew+)(.*)/ lc($1) . ":" . length($2) /meg;
.Ve
.IP "Comments Inside tha Regex" 4
.IX Item "Comments Inside tha Regex"
Da \f(CW\*(C`/x\*(C'\fR modifier causes whitespace ta be ignored up in a regex pattern
(except up in a cold-ass lil characta class n' all dem other places), n' also allows you to
use aiiight comments there, like a muthafucka fo' realz. As you can imagine, whitespace n' comments
help all muthafuckin day.
.Sp
\&\f(CW\*(C`/x\*(C'\fR lets you turn this:
.Sp
.Vb 1
\&    s{<(?:[^>\*(Aq"]*|".*?"|\*(Aq.*?\*(Aq)+>}{}gs;
.Ve
.Sp
into this:
.Sp
.Vb 10
\&    s{ <                    # openin angle bracket
\&        (?:                 # Non\-backreffin groupin paren
\&            [^>\*(Aq"] *        # 0 or mo' thangs dat is neither > nor \*(Aq nor "
\&                |           #    or else
\&            ".*?"           # a section between double quotes (stingy match)
\&                |           #    or else
\&            \*(Aq.*?\*(Aq           # a section between single quotes (stingy match)
\&        ) +                 #   all occurrin one or mo' times
\&        >                   # closin angle bracket
\&    }{}gsx;                 # replace wit nothing, i.e. delete
.Ve
.Sp
It aint nuthin but still not like so clear as prose yo, but it is straight-up useful for
describin tha meanin of each part of tha pattern.
.IP "Different Delimiters" 4
.IX Item "Different Delimiters"
While we normally be thinkin of patterns as bein delimited wit \f(CW\*(C`/\*(C'\fR
characters, they can be delimited by almost any character n' shit. perlre
raps bout all dis bullshit. For example, tha \f(CW\*(C`s///\*(C'\fR above uses braces as
delimiters. Right back up in yo muthafuckin ass. Selectin another delimita can avoid quotin the
delimita within tha pattern:
.Sp
.Vb 2
\&    s/\e/usr\e/local/\e/usr\e/share/g;    # wack delimita chizzle
\&    s#/usr/local#/usr/share#g;        # better
.Ve
.Sp
Usin logically paired delimitas can be even mo' readable:
.Sp
.Vb 1
\&    s{/usr/local/}{/usr/share}g;      # betta still
.Ve
.SS "I be havin shiznit matchin over mo' than one line. Whatz wrong?"
.IX Xref "regex, multiline regexp, multiline regular expression, multiline"
.IX Subsection "I be havin shiznit matchin over mo' than one line. Whatz wrong?"
Either you aint gots mo' than one line up in tha strang you looking
at (probably), or else yo ass aint rockin tha erect modifier(s) on
your pattern (possibly).
.PP
There is nuff ways ta git multiline data tha fuck into a string. If you want
it ta happen automatically while readin input, you gonna wanna set $/
(probably ta '' fo' paragraphs or \f(CW\*(C`undef\*(C'\fR fo' tha whole file) to
allow you ta read mo' than one line at a time.
.PP
Read perlre ta help you decizzle which of \f(CW\*(C`/s\*(C'\fR n' \f(CW\*(C`/m\*(C'\fR (or both)
you might wanna use: \f(CW\*(C`/s\*(C'\fR allows dot ta include newline, n' \f(CW\*(C`/m\*(C'\fR
allows caret n' dollar ta match next ta a newline, not just at the
end of tha string. Yo ass do need ta make shizzle dat you've actually
got a multiline strang up in there.
.PP
For example, dis program detects duplicate lyrics, even when they span
line breaks (but not paragraph ones). For dis example, our phat asses don't need
\&\f(CW\*(C`/s\*(C'\fR cuz we aren't rockin dot up in a regular expression dat we want
to cross line boundaries. Put ya muthafuckin choppers up if ya feel dis! Neither do we need \f(CW\*(C`/m\*(C'\fR cuz our phat asses don't
want caret or dollar ta match at any point inside tha record next
to newlines. But itz imperatizzle dat $/ be set ta suttin' other
than tha default, or else we won't straight-up eva gotz a multiline
record read in.
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read up in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /\eb([\ew\*(Aq\-]+)(\es+\eg1)+\eb/gi ) {     # word starts alpha
\&            print "Duplicate $1 at paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Herez some code dat findz sentences dat begin wit \*(L"From \*(R" (which would
be mangled by nuff mailers):
.PP
.Vb 6
\&    $/ = \*(Aq\*(Aq;          # read up in whole paragraph, not just one line
\&    while ( <> ) {
\&        while ( /^From /gm ) { # /m make ^ match next ta \en
\&        print "leadin from up in paragraph $.\en";
\&        }
\&    }
.Ve
.PP
Herez code dat findz every last muthafuckin thang between \s-1START\s0 n' \s-1END\s0 up in a paragraph:
.PP
.Vb 6
\&    undef $/;          # read up in whole file, not just one line or paragraph
\&    while ( <> ) {
\&        while ( /START(.*?)END/sgm ) { # /s make . cross line boundaries
\&            print "$1\en";
\&        }
\&    }
.Ve
.SS "How tha fuck can I pull up lines between two patterns dat is theyselves on different lines?"
.IX Xref ".."
.IX Subsection "How tha fuck can I pull up lines between two patterns dat is theyselves on different lines?"
Yo ass can use Perlz somewhat horny-ass \f(CW\*(C`..\*(C'\fR operator (documented in
perlop):
.PP
.Vb 1
\&    perl \-ne \*(Aqprint if /START/ .. /END/\*(Aq file1 file2 ...
.Ve
.PP
If you wanted text n' not lines, you would use
.PP
.Vb 1
\&    perl \-0777 \-ne \*(Aqprint "$1\en" while /START(.*?)END/gs\*(Aq file1 file2 ...
.Ve
.PP
But if you want nested occurrencez of \f(CW\*(C`START\*(C'\fR all up in \f(CW\*(C`END\*(C'\fR, you'll
run up against tha problem busted lyrics bout up in tha question up in dis section
on matchin balanced text.
.PP
Herez another example of rockin \f(CW\*(C`..\*(C'\fR:
.PP
.Vb 7
\&    while (<>) {
\&        mah $in_header =   1  .. /^$/;
\&        mah $in_body   = /^$/ .. eof;
\&    # now chizzle between them
\&    } continue {
\&        $. = 0 if eof;    # fix $.
\&    }
.Ve
.SS "How tha fuck do I match \s-1XML, HTML,\s0 or other nasty, skanky thangs wit a regex?"
.IX Xref "regex, XML regex, HTML XML HTML pain frustration suckin out, will ta live"
.IX Subsection "How tha fuck do I match XML, HTML, or other nasty, skanky thangs wit a regex?"
Do not use regexes. Use a module n' forget bout the
regular expressions. Da XML::LibXML, HTML::TokeParser and
HTML::TreeBuilder modulez is phat starts, although each namespace
has other parsin modulez specialized fo' certain tasks n' different
wayz of bustin dat shit. Right back up in yo muthafuckin ass. Start at \s-1CPAN\s0 Search ( <http://metacpan.org/> )
and wonder at all tha work playas have done fo' you already dawwwwg! :)
.SS "I put a regular expression tha fuck into $/ but it didn't work. Whatz wrong?"
.IX Xref "$ , regexes up in $INPUT_RECORD_SEPARATOR, regexes up in $RS, regexes in"
.IX Subsection "I put a regular expression tha fuck into $/ but it didn't work. Whatz wrong?"
$/ has ta be a string. Yo ass can use these examplez if you straight-up need to
do all dis bullshit.
.PP
If you have File::Stream, dis is easy as fuck .
.PP
.Vb 1
\&    use File::Stream;
\&
\&    mah $stream = File::Stream\->new(
\&        $filehandle,
\&        separator => qr/\es*,\es*/,
\&        );
\&
\&    print "$_\en" while <$stream>;
.Ve
.PP
If you aint gots File::Stream, you gotta do a lil mo' work.
.PP
Yo ass can use tha four-argument form of sysread ta continually add to
a buffer n' shiznit fo' realz. Afta you add ta tha buffer, you check if you have a
complete line (usin yo' regular expression).
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        while( s/^((?s).*?)your_pattern// ) {
\&            mah $record = $1;
\&            # do shiznit here.
\&        }
\&    }
.Ve
.PP
Yo ass can do tha same thang wit foreach n' a match rockin the
c flag n' tha \eG anchor, if you do not mind yo' entire file
bein up in memory all up in tha end.
.PP
.Vb 7
\&    local $_ = "";
\&    while( sysread FH, $_, 8192, length ) {
\&        foreach mah $record ( m/\eG((?s).*?)your_pattern/gc ) {
\&            # do shiznit here.
\&        }
\&        substr( $_, 0, pos ) = "" if pos;
\&    }
.Ve
.SS "How tha fuck do I substitute case-insensitively on tha \s-1LHS\s0 while preservin case on tha \s-1RHS\s0?"
.IX Xref "replace, case preservin substitute, case preservin substitution, case preservin s, case preserving"
.IX Subsection "How tha fuck do I substitute case-insensitively on tha LHS while preservin case on tha RHS?"
Herez a ghettofab Perlish solution by Larry Rosla n' shit. Well shiiiit, it exploits
propertizzlez of bitwise xor on \s-1ASCII\s0 strings.
.PP
.Vb 1
\&    $_= "this be a TEsT case";
\&
\&    $old = \*(Aqtest\*(Aq;
\&    $new = \*(Aqsuccess\*(Aq;
\&
\&    s{(\eQ$old\eE)}
\&    { uc $new | (uc $1 ^ $1) .
\&        (uc(substr $1, \-1) ^ substr $1, \-1) x
\&        (length($new) \- length $1)
\&    }egi;
\&
\&    print;
.Ve
.PP
And here it be as a subroutine, modeled afta tha above:
.PP
.Vb 3
\&    sub preserve_case {
\&        mah ($old, $new) = @_;
\&        mah $mask = uc $old ^ $old;
\&
\&        uc $new | $mask .
\&            substr($mask, \-1) x (length($new) \- length($old))
\&    }
\&
\&    $strin = "this be a TEsT case";
\&    $strin =~ s/(test)/preserve_case($1, "success")/egi;
\&    print "$string\en";
.Ve
.PP
This prints:
.PP
.Vb 1
\&    dis be a SUcCESS case
.Ve
.PP
As a alternative, ta keep tha case of tha replacement word if it is
longer than tha original, you can use dis code, by Jeff Pinyan:
.PP
.Vb 3
\&    sub preserve_case {
\&        mah ($from, $to) = @_;
\&        mah ($lf, $lt) = map length, @_;
\&
\&        if ($lt < $lf) { $from = substr $from, 0, $lt }
\&        else { $from .= substr $to, $lf }
\&
\&        return uc $to | ($from ^ uc $from);
\&    }
.Ve
.PP
This chizzlez tha sentence ta \*(L"this be a SUcCess case.\*(R"
.PP
Just ta show dat C programmers can write C up in any programmin language,
if you prefer a mo' C\-like solution, tha followin script make the
substitution have tha same case, letta by letter, as tha original.
(It also happens ta run bout 240% slower than tha Perlish solution runs.)
If tha substitution has mo' charactas than tha strang bein substituted,
the case of tha last characta is used fo' tha rest of tha substitution.
.PP
.Vb 8
\&    # Original Gangsta by Nathan Torkington, massaged by Jeffrey Friedl
\&    #
\&    sub preserve_case
\&    {
\&        mah ($old, $new) = @_;
\&        mah $state = 0; # 0 = no chizzle; 1 = lc; 2 = uc
\&        mah ($i, $oldlen, $newlen, $c) = (0, length($old), length($new));
\&        mah $len = $oldlen < $newlen ? $oldlen : $newlen;
\&
\&        fo' ($i = 0; $i < $len; $i++) {
\&            if ($c = substr($old, $i, 1), $c =~ /[\eW\ed_]/) {
\&                $state = 0;
\&            } elsif (lc $c eq $c) {
\&                substr($new, $i, 1) = lc(substr($new, $i, 1));
\&                $state = 1;
\&            } else {
\&                substr($new, $i, 1) = uc(substr($new, $i, 1));
\&                $state = 2;
\&            }
\&        }
\&        # finish up wit any remainin freshly smoked up (for when freshly smoked up is longer than old)
\&        if ($newlen > $oldlen) {
\&            if ($state == 1) {
\&                substr($new, $oldlen) = lc(substr($new, $oldlen));
\&            } elsif ($state == 2) {
\&                substr($new, $oldlen) = uc(substr($new, $oldlen));
\&            }
\&        }
\&        return $new;
\&    }
.Ve
.ie n .SS "How tha fuck can I make ""\ew"" match nationistic characta sets?"
.el .SS "How tha fuck can I make \f(CW\ew\fP match nationistic characta sets?"
.IX Xref "\\w"
.IX Subsection "How tha fuck can I make w match nationistic characta sets?"
Put \f(CW\*(C`use locale;\*(C'\fR up in yo' script. Da \ew characta class is taken
from tha current locale.
.PP
See perllocale fo' details.
.ie n .SS "How tha fuck can I match a locale-smart version of ""/[a\-zA\-Z]/""?"
.el .SS "How tha fuck can I match a locale-smart version of \f(CW/[a\-zA\-Z]/\fP?"
.IX Xref "alpha"
.IX Subsection "How tha fuck can I match a locale-smart version of /[a-zA-Z]/?"
Yo ass can use tha \s-1POSIX\s0 characta class syntax \f(CW\*(C`/[[:alpha:]]/\*(C'\fR
documented up in perlre.
.PP
No matta which locale yo ass is in, tha alphabetic charactas are
the charactas up in \ew without tha digits n' tha underscore.
As a regex, dat be lookin like \f(CW\*(C`/[^\eW\ed_]/\*(C'\fR. Its complement,
the non-alphabetics, is then every last muthafuckin thang up in \eW along with
the digits n' tha underscore, or \f(CW\*(C`/[\eW\ed_]/\*(C'\fR.
.SS "How tha fuck can I quote a variable ta use up in a regex?"
.IX Xref "regex, escapin regexp, escapin regular expression, escaping"
.IX Subsection "How tha fuck can I quote a variable ta use up in a regex?"
Da Perl parser will expand \f(CW$variable\fR n' \f(CW@variable\fR references in
regular expressions unless tha delimita be a single quote. Remember,
too, dat tha right-hand side of a \f(CW\*(C`s///\*(C'\fR substitution is considered
a double-quoted strang (see perlop fo' mo' details). Remember
also dat any regex special charactas is ghon be acted on unless you
precede tha substitution wit \eQ yo. Herez a example:
.PP
.Vb 2
\&    $strin = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $strin =~ s/$regex/Polyp/;
\&    # $strin is now "Polypacido P. Octopus"
.Ve
.PP
Because \f(CW\*(C`.\*(C'\fR is special up in regular expressions, n' can match any
single character, tha regex \f(CW\*(C`P.\*(C'\fR here has matched tha <Pl> up in the
original gangsta string.
.PP
To escape tha special meanin of \f(CW\*(C`.\*(C'\fR, we use \f(CW\*(C`\eQ\*(C'\fR:
.PP
.Vb 2
\&    $strin = "Placido P. Octopus";
\&    $regex  = "P.";
\&
\&    $strin =~ s/\eQ$regex/Polyp/;
\&    # $strin is now "Placido Polyp Octopus"
.Ve
.PP
Da use of \f(CW\*(C`\eQ\*(C'\fR causes tha <.> up in tha regex ta be treated as a
regular character, so dat \f(CW\*(C`P.\*(C'\fR matches a \f(CW\*(C`P\*(C'\fR followed by a thugged-out dot.
.ie n .SS "What tha fuck iz ""/o"" straight-up for?"
.el .SS "What tha fuck iz \f(CW/o\fP straight-up for?"
.IX Xref " o, regular expressions compile, regular expressions"
.IX Subsection "What tha fuck iz /o straight-up for?"
(contributed by brian d foy)
.PP
Da \f(CW\*(C`/o\*(C'\fR option fo' regular expressions (documented up in perlop and
perlreref)  drops some lyrics ta Perl ta compile tha regular expression only once.
This is only useful when tha pattern gotz nuff a variable. Perls 5.6
and lata handle dis automatically if tha pattern do not chizzle.
.PP
Since tha match operator \f(CW\*(C`m//\*(C'\fR, tha substitution operator \f(CW\*(C`s///\*(C'\fR,
and tha regular expression quotin operator \f(CW\*(C`qr//\*(C'\fR is double-quotish
constructs, you can interpolate variablez tha fuck into tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. See the
answer ta \*(L"How tha fuck can I quote a variable ta use up in a regex?\*(R" fo' more
details.
.PP
This example takes a regular expression from tha argument list and
prints tha linez of input dat match it:
.PP
.Vb 1
\&    mah $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/;
\&    }
.Ve
.PP
Versionz of Perl prior ta 5.6 would recompile tha regular expression
for each iteration, even if \f(CW$pattern\fR had not chizzled. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`/o\*(C'\fR
would prevent dis by spittin some lyrics ta Perl ta compile tha pattern tha first
time, then reuse dat fo' subsequent iterations:
.PP
.Vb 1
\&    mah $pattern = shift @ARGV;
\&
\&    while( <> ) {
\&        print if m/$pattern/o; # useful fo' Perl < 5.6
\&    }
.Ve
.PP
In versions 5.6 n' later, Perl won't recompile tha regular expression
if tha variable aint chizzled, so you probably don't need tha \f(CW\*(C`/o\*(C'\fR
option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it don't hurt yo, but it don't help either n' shit. If you want any
version of Perl ta compile tha regular expression only once even if
the variable chizzlez (thus, only rockin its initial value), you still
need tha \f(CW\*(C`/o\*(C'\fR.
.PP
Yo ass can peep Perlz regular expression engine at work ta verify for
yo ass if Perl is recompilin a regular expression. I aint talkin' bout chicken n' gravy biatch. Da \f(CW\*(C`use re
\&\*(Aqdebug\*(Aq\*(C'\fR pragma (comes wit Perl 5.005 n' later) shows tha details.
With Perls before 5.6, you should peep \f(CW\*(C`re\*(C'\fR reportin dat its
compilin tha regular expression on each iteration. I aint talkin' bout chicken n' gravy biatch. With Perl 5.6 or
later, you should only peep \f(CW\*(C`re\*(C'\fR report dat fo' tha straight-up original gangsta iteration.
.PP
.Vb 1
\&    use re \*(Aqdebug\*(Aq;
\&
\&    mah $regex = \*(AqPerl\*(Aq;
\&    foreach ( qw(Perl Java Ruby Python) ) {
\&        print STDERR "\-" x 73, "\en";
\&        print STDERR "Tryin $_...\en";
\&        print STDERR "\et$_ is good!\en" if m/$regex/;
\&    }
.Ve
.SS "How tha fuck do I bust a regular expression ta strip C\-style comments from a gangbangin' file?"
.IX Subsection "How tha fuck do I bust a regular expression ta strip C-style comments from a gangbangin' file?"
While dis straight-up can be done, itz much harder than you'd think.
For example, dis one-liner
.PP
.Vb 1
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
.Ve
.PP
will work up in nuff but not all cases. Yo ass see, itz too simple-minded for
certain kindz of C programs, up in particular, dem wit what tha fuck step tha fuck up ta be
comments up in quoted strings. For that, you'd need suttin' like this,
created by Jeffrey Friedl n' lata modified by Fred Curtis.
.PP
.Vb 4
\&    $/ = undef;
\&    $_ = <>;
\&    s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $2 ? $2 : ""#gse;
\&    print;
.Ve
.PP
This could, of course, be mo' legibly freestyled wit tha \f(CW\*(C`/x\*(C'\fR modifier, adding
whitespace n' comments yo. Here it is expanded, courtesy of Fred Curtis.
.PP
.Vb 8
\&    s{
\&       /\e*         ##  Start of /* ... */ comment
\&       [^*]*\e*+    ##  Non\-* followed by 1\-or\-more *\*(Aqs
\&       (
\&         [^/*][^*]*\e*+
\&       )*          ##  0\-or\-more thangs which don\*(Aqt start wit /
\&                   ##    but do end wit \*(Aq*\*(Aq
\&       /           ##  End of /* ... */ comment
\&
\&     |         ##     OR  various thangs which aren\*(Aqt comments:
\&
\&       (
\&         "           ##  Start of " ... " string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^"\e\e]        ##  Non "\e
\&         )*
\&         "           ##  End of " ... " string
\&
\&       |         ##     OR
\&
\&         \*(Aq           ##  Start of \*(Aq ... \*(Aq string
\&         (
\&           \e\e.           ##  Escaped char
\&         |               ##    OR
\&           [^\*(Aq\e\e]        ##  Non \*(Aq\e
\&         )*
\&         \*(Aq           ##  End of \*(Aq ... \*(Aq string
\&
\&       |         ##     OR
\&
\&         .           ##  Anythang other char
\&         [^/"\*(Aq\e\e]*   ##  Chars which don\*(Aqt start a cold-ass lil comment, strang or escape
\&       )
\&     }{defined $2 ? $2 : ""}gxse;
.Ve
.PP
A slight modification also removes \*(C+ comments, possibly spannin multiple lines
usin a cold-ass lil continuation character:
.PP
.Vb 1
\& s#/\e*[^*]*\e*+([^/*][^*]*\e*+)*/|//([^\e\e]|[^\en][\en]?)*?\en|("(\e\e.|[^"\e\e])*"|\*(Aq(\e\e.|[^\*(Aq\e\e])*\*(Aq|.[^/"\*(Aq\e\e]*)#defined $3 ? $3 : ""#gse;
.Ve
.SS "Can I use Perl regular expressions ta match balanced text?"
.IX Xref "regex, matchin balanced test regexp, matchin balanced test regular expression, matchin balanced test possessive PARNO Text::Balanced Regexp::Common backtrackin recursion"
.IX Subsection "Can I use Perl regular expressions ta match balanced text?"
(contributed by brian d foy)
.PP
Yo crazy-ass first try should probably be tha Text::Balanced module, which
is up in tha Perl standard library since Perl 5.8. Well shiiiit, it has a variety of
functions ta deal wit tricky text. Da Regexp::Common module can
also help by providin canned patterns you can use.
.PP
Az of Perl 5.10, you can match balanced text wit regular expressions
usin recursive patterns. Before Perl 5.10, you had ta resort to
various tricks like fuckin rockin Perl code up in \f(CW\*(C`(??{})\*(C'\fR sequences.
.PP
Herez a example rockin a recursive regular expression. I aint talkin' bout chicken n' gravy biatch. Da goal is to
capture all of tha text within angle brackets, includin tha text in
nested angle brackets, n' you can put dat on yo' toast. This sample text has two \*(L"major\*(R" groups: a
group wit one level of nestin n' a crew wit two levels of
nesting. There is five total crews up in angle brackets:
.PP
.Vb 3
\&    I have some <brackets up in <nested brackets> > and
\&    <another crew <nested once <nested twice> > >
\&    n' that\*(Aqs dat shit.
.Ve
.PP
Da regular expression ta match tha balanced text uses two freshly smoked up (to
Perl 5.10) regular expression features. These is covered up in perlre
and dis example be a modified version of one up in dat documentation.
.PP
First, addin tha freshly smoked up possessive \f(CW\*(C`+\*(C'\fR ta any quantifier findz the
longest match n' do not backtrack. Thatz blingin since you want
to handle any angle brackets all up in tha recursion, not backtracking.
Da crew \f(CW\*(C`[^<>]++\*(C'\fR findz one or mo' non-angle brackets without
backtracking.
.PP
Second, tha freshly smoked up \f(CW\*(C`(?PARNO)\*(C'\fR refers ta tha sub-pattern up in the
particular capture crew given by \f(CW\*(C`PARNO\*(C'\fR. In tha followin regex,
the first capture crew findz (and remembers) tha balanced text, and
you need dat same pattern within tha straight-up original gangsta buffer ta git past the
nested text. Thatz tha recursive part. Da \f(CW\*(C`(?1)\*(C'\fR uses tha pattern
in tha outa capture crew as a independent part of tha regex.
.PP
Puttin all dat shiznit together, you have:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    mah $strin =<<"HERE";
\&    I have some <brackets up in <nested brackets> > and
\&    <another crew <nested once <nested twice> > >
\&    n' that\*(Aqs dat shit.
\&    HERE
\&
\&    mah @groups = $strin =~ m/
\&            (                   # start of capture crew 1
\&            <                   # match a openin angle bracket
\&                (?:
\&                    [^<>]++     # one or mo' non angle brackets, non backtracking
\&                      |
\&                    (?1)        # found < or >, so recurse ta capture crew 1
\&                )*
\&            >                   # match a cold-ass lil closin angle bracket
\&            )                   # end of capture crew 1
\&            /xg;
\&
\&    $" = "\en\et";
\&    print "Found:\en\et@groups\en";
.Ve
.PP
Da output shows dat Perl found tha two major groups:
.PP
.Vb 3
\&    Found:
\&        <brackets up in <nested brackets> >
\&        <another crew <nested once <nested twice> > >
.Ve
.PP
With a lil extra work, you can git tha all of tha crews up in angle
brackets even if they is up in other angle brackets like a muthafucka. Each time you
get a funky-ass balanced match, remove its outa delimita (thatz tha one you
just matched so don't match it again) n' add it ta a queue of strings
to process. Keep bustin dat until you git no matches:
.PP
.Vb 1
\&    #!/usr/local/bin/perl5.10.0
\&
\&    mah @queue =<<"HERE";
\&    I have some <brackets up in <nested brackets> > and
\&    <another crew <nested once <nested twice> > >
\&    n' that\*(Aqs dat shit.
\&    HERE
\&
\&    mah $regex = qr/
\&            (                   # start of bracket 1
\&            <                   # match a openin angle bracket
\&                (?:
\&                    [^<>]++     # one or mo' non angle brackets, non backtracking
\&                      |
\&                    (?1)        # recurse ta bracket 1
\&                )*
\&            >                   # match a cold-ass lil closin angle bracket
\&            )                   # end of bracket 1
\&            /x;
\&
\&    $" = "\en\et";
\&
\&    while( @queue ) {
\&        mah $strin = shift @queue;
\&
\&        mah @groups = $strin =~ m/$regex/g;
\&        print "Found:\en\et@groups\en\en" if @groups;
\&
\&        unshift @queue, map { s/^<//; s/>$//; $_ } @groups;
\&    }
.Ve
.PP
Da output shows all of tha groups. Da outermost matches show up
first n' tha nested matches so up later:
.PP
.Vb 3
\&    Found:
\&        <brackets up in <nested brackets> >
\&        <another crew <nested once <nested twice> > >
\&
\&    Found:
\&        <nested brackets>
\&
\&    Found:
\&        <nested once <nested twice> >
\&
\&    Found:
\&        <nested twice>
.Ve
.SS "What do it mean dat regexes is greedy? How tha fuck can I git round it?"
.IX Xref "greedy greediness"
.IX Subsection "What do it mean dat regexes is greedy? How tha fuck can I git round it?"
Most playas mean dat greedy regexes match as much as they can.
Technically bustin lyrics, itz straight-up tha quantifiers (\f(CW\*(C`?\*(C'\fR, \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`{}\*(C'\fR) dat is greedy rather than tha whole pattern; Perl prefers local
greed n' immediate gratification ta overall greed. Y'all KNOW dat shit, muthafucka! To git non-greedy
versionz of tha same quantifiers, use (\f(CW\*(C`??\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{}?\*(C'\fR).
.PP
An example:
.PP
.Vb 3
\&    mah $s1 = mah $s2 = "I be straight-up hella cold";
\&    $s1 =~ s/ve.*y //;      # I be cold
\&    $s2 =~ s/ve.*?y //;     # I be straight-up cold
.Ve
.PP
Notice how tha fuck tha second substitution stopped matchin as soon as it
encountered \*(L"y \*(R". Da \f(CW\*(C`*?\*(C'\fR quantifier effectively  drops some lyrics ta tha regular
expression engine ta find a match as quickly as possible n' pass
control on ta whatever is next up in line, as you would if you were
playin bangin' potato.
.SS "How tha fuck do I process each word on each line?"
.IX Xref "word"
.IX Subsection "How tha fuck do I process each word on each line?"
Use tha split function:
.PP
.Vb 5
\&    while (<>) {
\&        foreach mah $word ( split ) {
\&            # do suttin' wit $word here
\&        }
\&    }
.Ve
.PP
Note dat dis aint straight-up a word up in tha Gangsta sense; itz just
chunkz of consecutizzle non-whitespace characters.
.PP
To work wit only alphanumeric sequences (includin underscores), you
might consider
.PP
.Vb 5
\&    while (<>) {
\&        foreach $word (m/(\ew+)/g) {
\&            # do suttin' wit $word here
\&        }
\&    }
.Ve
.SS "How tha fuck can I print up a word-frequency or line-frequency summary?"
.IX Subsection "How tha fuck can I print up a word-frequency or line-frequency summary?"
To do this, you gotta parse up each word up in tha input stream. We bout ta
pretend dat by word you mean chunk of alphabetics, hyphens, or
apostrophes, rather than tha non-whitespace chunk scam of a word given
in tha previous question:
.PP
.Vb 6
\&    mah (%seen);
\&    while (<>) {
\&        while ( /(\eb[^\eW_\ed][\ew\*(Aq\-]+\eb)/g ) {   # misses "\`sheep\*(Aq"
\&            $seen{$1}++;
\&        }
\&    }
\&
\&    while ( mah ($word, $count) = each %seen ) {
\&        print "$count $word\en";
\&    }
.Ve
.PP
If you wanted ta do tha same thang fo' lines, you wouldn't need a
regular expression:
.PP
.Vb 1
\&    mah (%seen);
\&
\&    while (<>) {
\&        $seen{$_}++;
\&    }
\&
\&    while ( mah ($line, $count) = each %seen ) {
\&        print "$count $line";
\&    }
.Ve
.PP
If you want these output up in a sorted order, peep perlfaq4: \*(L"How tha fuck do I
sort a hash (optionally by value instead of key)?\*(R".
.SS "How tha fuck can I do approximate matching?"
.IX Xref "match, approximate matching, approximate"
.IX Subsection "How tha fuck can I do approximate matching?"
See tha module String::Approx available from \s-1CPAN.\s0
.SS "How tha fuck do I efficiently match nuff regular expressions at once?"
.IX Xref "regex, efficiency regexp, efficiency regular expression, efficiency"
.IX Subsection "How tha fuck do I efficiently match nuff regular expressions at once?"
(contributed by brian d foy)
.PP
If you have Perl 5.10 or later, dis be almost trivial. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass just smart
match against a array of regular expression objects:
.PP
.Vb 1
\&    mah @patterns = ( qr/Fr.d/, qr/B.rn.y/, qr/W.lm./ );
\&
\&    if( $strin ~~ @patterns ) {
\&        ...
\&    };
.Ve
.PP
Da smart-ass match stops when it findz a match, so it don't gotta try
every expression.
.PP
Earlier than Perl 5.10, you gotz a lil' bit of work ta do. Yo ass want to
avoid compilin a regular expression every last muthafuckin time you wanna match dat shit.
In dis example, perl must recompile tha regular expression fo' every
iteration of tha \f(CW\*(C`foreach\*(C'\fR loop since it has no way ta know what
\&\f(CW$pattern\fR will be:
.PP
.Vb 1
\&    mah @patterns = qw( foo bar baz );
\&
\&    LINE: while( <DATA> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /\eb$pattern\eb/i ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
Da \f(CW\*(C`qr//\*(C'\fR operator flossed up in perl 5.005. Well shiiiit, it compilez a regular
expression yo, but don't apply dat shit. When you use tha pre-compiled
version of tha regex, perl do less work. In dis example, I inserted
a \f(CW\*(C`map\*(C'\fR ta turn each pattern tha fuck into its pre-compiled form. Da rest of
the script is tha same yo, but faster:
.PP
.Vb 1
\&    mah @patterns = map { qr/\eb$_\eb/i } qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        foreach $pattern ( @patterns ) {
\&            if( /$pattern/ ) {
\&                print;
\&                next LINE;
\&            }
\&        }
\&    }
.Ve
.PP
In some cases, you may be able ta make nuff muthafuckin patterns tha fuck into a single
regular expression. I aint talkin' bout chicken n' gravy biatch. Beware of thangs dat require backtracking
though.
.PP
.Vb 1
\&    mah $regex = join \*(Aq|\*(Aq, qw( foo bar baz );
\&
\&    LINE: while( <> ) {
\&        print if /\eb(?:$regex)\eb/i;
\&    }
.Ve
.PP
For mo' details on regular expression efficiency, peep \fIMastering
Regular Expressions\fR by Jeffrey Friedl yo. Dude explains how tha fuck tha regular
expressions engine works n' why some patterns is surprisingly
inefficient. Once you KNOW how tha fuck perl applies regular expressions,
you can tune dem fo' individual thangs.
.ie n .SS "Why don't word-boundary searches wit ""\eb"" work fo' me son?"
.el .SS "Why don't word-boundary searches wit \f(CW\eb\fP work fo' me son?"
.IX Xref "\\b"
.IX Subsection "Why don't word-boundary searches wit b work fo' me son?"
(contributed by brian d foy)
.PP
Ensure dat you know what tha fuck \eb straight-up do: itz tha boundary between a
word character, \ew, n' suttin' dat aint a word character n' shit. That
thang dat aint a word characta might be \eW yo, but it can also be the
start or end of tha string.
.PP
It aint nuthin but not (not!) tha boundary between whitespace n' non-whitespace,
and it aint tha shiznit between lyrics we use ta create sentences.
.PP
In regex speak, a word boundary (\eb) be a \*(L"zero width assertion\*(R",
meanin dat it don't represent a cold-ass lil characta up in tha strin yo, but a
condizzle at a cold-ass lil certain position.
.PP
For tha regular expression, /\ebPerl\eb/, there has ta be a word
boundary before tha \*(L"P\*(R" n' afta tha \*(L"l\*(R" fo' realz. As long as suttin' other
than a word characta precedes tha \*(L"P\*(R" n' succeedz tha \*(L"l\*(R", the
pattern will match. These strings match /\ebPerl\eb/.
.PP
.Vb 4
\&    "Perl"    # no word char before P or afta l
\&    "Perl "   # same as previous (space aint a word char)
\&    "\*(AqPerl\*(Aq"  # tha \*(Aq char aint a word char
\&    "Perl\*(Aqs"  # no word char before P, non\-word char afta "l"
.Ve
.PP
These strings do not match /\ebPerl\eb/.
.PP
.Vb 2
\&    "Perl_"   # _ be a word char!
\&    "Perler"  # no word char before P yo, but one afta l
.Ve
.PP
Yo ass don't gotta use \eb ta match lyrics though cause I gots dem finger-lickin' chickens wit tha siz-auce. Yo ass can look for
non-word charactas surrounded by word characters. These strings
match tha pattern /\eb'\eb/.
.PP
.Vb 2
\&    "don\*(Aqt"   # tha \*(Aq char is surrounded by "n" n' "t"
\&    "qep\*(Aqa\*(Aq"  # tha \*(Aq char is surrounded by "p" n' "a"
.Ve
.PP
These strings do not match /\eb'\eb/.
.PP
.Vb 1
\&    "foo\*(Aq"    # there is no word char afta non\-word \*(Aq
.Ve
.PP
Yo ass can also use tha complement of \eb, \eB, ta specify dat there
should not be a word boundary.
.PP
In tha pattern /\eBam\eB/, there must be a word characta before tha \*(L"a\*(R"
and afta tha \*(L"m\*(R". These patterns match /\eBam\eB/:
.PP
.Vb 2
\&    "llama"   # "am" surrounded by word chars
\&    "Samuel"  # same
.Ve
.PP
These strings do not match /\eBam\eB/
.PP
.Vb 2
\&    "Sam"      # no word boundary before "a" yo, but one afta "m"
\&    "I be Sam" # "am" surrounded by non\-word chars
.Ve
.SS "Why do rockin $&, $`, or $' slow mah program down?"
.IX Xref "$MATCH $& $POSTMATCH $' $PREMATCH $`"
.IX Subsection "Why do rockin $&, $`, or $' slow mah program down?"
(contributed by Anno Siegel)
.PP
Once Perl sees dat you need one of these variablez anywhere up in the
program, it serves up dem on each n' every last muthafuckin pattern match. That means
that on every last muthafuckin pattern match tha entire strang is ghon be copied, part of it
to $`, part ta $&, n' part ta $'. Thus tha penalty is most severe with
long strings n' patterns dat match often. I aint talkin' bout chicken n' gravy biatch fo' realz. Avoid $&, $', n' $` if you
can yo, but if you can't, once you've used dem at all, use dem at will
because you've already paid tha price. Remember dat some algorithms
really appreciate em fo' realz. Az of tha 5.005 release, tha $& variable is no
longer \*(L"expensive\*(R" tha way tha other two are.
.PP
Since Perl 5.6.1 tha special variablez @\- n' @+ can functionally replace
$`, $& n' $'. These arrays contain pointas ta tha beginnin n' end
of each match (see perlvar fo' tha full story), so they give you
essentially tha same shiznit yo, but without tha risk of excessive
strin copying.
.PP
Perl 5.10 added three specials, \f(CW\*(C`${^MATCH}\*(C'\fR, \f(CW\*(C`${^PREMATCH}\*(C'\fR, and
\&\f(CW\*(C`${^POSTMATCH}\*(C'\fR ta do tha same thang but without tha global performance
penalty. Perl 5.10 only sets these variablez if you compile or execute the
regular expression wit tha \f(CW\*(C`/p\*(C'\fR modifier.
.ie n .SS "What phat is ""\eG"" up in a regular expression?"
.el .SS "What phat is \f(CW\eG\fP up in a regular expression?"
.IX Xref "\\G"
.IX Subsection "What phat is G up in a regular expression?"
Yo ass use tha \f(CW\*(C`\eG\*(C'\fR anchor ta start tha next match on tha same
strin where tha last match left off. Da regular
expression engine cannot skip over any charactas ta find
the next match wit dis anchor, so \f(CW\*(C`\eG\*(C'\fR is similar ta the
beginnin of strang anchor, \f(CW\*(C`^\*(C'\fR. Da \f(CW\*(C`\eG\*(C'\fR anchor is typically
used wit tha \f(CW\*(C`g\*(C'\fR flag. Well shiiiit, it uses tha value of \f(CW\*(C`pos()\*(C'\fR
as tha posizzle ta start tha next match fo' realz. As tha match
operator make successive matches, it thugged-out shiznit \f(CW\*(C`pos()\*(C'\fR wit the
posizzle of tha next characta past tha last match (or the
first characta of tha next match, dependin on how tha fuck you like
to peep it). Each strang has its own \f(CW\*(C`pos()\*(C'\fR value.
.PP
Suppose you wanna match all of consecutizzle pairz of digits
in a strang like \*(L"1122a44\*(R" n' stop matchin when you
encounta non-digits, n' you can put dat on yo' toast. Yo ass wanna match \f(CW11\fR n' \f(CW22\fR but
the letta <a> shows up between \f(CW22\fR n' \f(CW44\fR n' you want
to stop at \f(CW\*(C`a\*(C'\fR. Right back up in yo muthafuckin ass. Simply matchin pairz of digits skips over
the \f(CW\*(C`a\*(C'\fR n' still matches \f(CW44\fR.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    mah @pairs = m/(\ed\ed)/g;   # qw( 11 22 44 )
.Ve
.PP
If you use tha \f(CW\*(C`\eG\*(C'\fR anchor, you force tha match afta \f(CW22\fR to
start wit tha \f(CW\*(C`a\*(C'\fR. Da regular expression cannot match
there since it do not find a gangbangin' finger-lickin' digit, so tha next match
fails n' tha match operator returns tha pairs it already
found.
.PP
.Vb 2
\&    $_ = "1122a44";
\&    mah @pairs = m/\eG(\ed\ed)/g; # qw( 11 22 )
.Ve
.PP
Yo ass can also use tha \f(CW\*(C`\eG\*(C'\fR anchor up in scalar context. You
still need tha \f(CW\*(C`g\*(C'\fR flag.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
.Ve
.PP
Afta tha match fails all up in tha letta \f(CW\*(C`a\*(C'\fR, perl resets \f(CW\*(C`pos()\*(C'\fR
and tha next match on tha same strang starts all up in tha beginning.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/g ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 afta while" if m/(\ed\ed)/g; # findz "11"
.Ve
.PP
Yo ass can disable \f(CW\*(C`pos()\*(C'\fR resets on fail wit tha \f(CW\*(C`c\*(C'\fR flag, documented
in perlop n' perlreref. Right back up in yo muthafuckin ass. Subsequent matches start where tha last
successful match ended (the value of \f(CW\*(C`pos()\*(C'\fR) even if a match on the
same strang has failed up in tha meantime. In dis case, tha match after
the \f(CW\*(C`while()\*(C'\fR loop starts all up in tha \f(CW\*(C`a\*(C'\fR (where tha last match stopped),
and since it do not use any anchor it can skip over tha \f(CW\*(C`a\*(C'\fR ta find
\&\f(CW44\fR.
.PP
.Vb 4
\&    $_ = "1122a44";
\&    while( m/\eG(\ed\ed)/gc ) {
\&        print "Found $1\en";
\&    }
\&
\&    print "Found $1 afta while" if m/(\ed\ed)/g; # findz "44"
.Ve
.PP
Typically you use tha \f(CW\*(C`\eG\*(C'\fR anchor wit tha \f(CW\*(C`c\*(C'\fR flag
when you wanna try a gangbangin' finger-lickin' different match if one fails,
like fuckin up in a tokenizer n' shit. Jeffrey Friedl offers dis example
which works up in 5.004 or later.
.PP
.Vb 9
\&    while (<>) {
\&        chomp;
\&        PARSER: {
\&            m/ \eG( \ed+\eb    )/gcx   && do { print "number: $1\en";  redo; };
\&            m/ \eG( \ew+      )/gcx   && do { print "word:   $1\en";  redo; };
\&            m/ \eG( \es+      )/gcx   && do { print "space:  $1\en";  redo; };
\&            m/ \eG( [^\ew\ed]+ )/gcx   && do { print "other:  $1\en";  redo; };
\&        }
\&    }
.Ve
.PP
For each line, tha \f(CW\*(C`PARSER\*(C'\fR loop first tries ta match a series
of digits followed by a word boundary. This match has to
start all up in tha place tha last match left off (or tha beginning
of tha strang on tha straight-up original gangsta match). Right back up in yo muthafuckin ass. Since \f(CW\*(C`m/ \eG( \ed+\eb
)/gcx\*(C'\fR uses tha \f(CW\*(C`c\*(C'\fR flag, if tha strang do not match that
regular expression, perl do not reset \fIpos()\fR n' tha next
match starts all up in tha same posizzle ta try a gangbangin' finger-lickin' different
pattern.
.SS "Is Perl regexes DFAs or NFAs? Is they \s-1POSIX\s0 compliant?"
.IX Xref "DFA NFA POSIX"
.IX Subsection "Is Perl regexes DFAs or NFAs? Is they POSIX compliant?"
While itz legit dat Perlz regular expressions resemble tha DFAs
(deterministic finite automata) of tha \fIegrep\fR\|(1) program, they is in
fact implemented as NFAs (non-deterministic finite automata) ta allow
backtrackin n' backreferencin fo' realz. And they aren't POSIX-style either,
because dem guarantee worst-case behavior fo' all cases. (It seems
that some playas prefer guaranteez of consistency, even when what's
guaranteed is slowness.) See tha book \*(L"Masterin Regular Expressions\*(R"
(from O'Reilly) by Jeffrey Friedl fo' all tha details you could ever
hope ta know on these mattas (a full citation appears in
perlfaq2).
.SS "Whatz wack wit rockin grep up in a void context?"
.IX Xref "grep"
.IX Subsection "Whatz wack wit rockin grep up in a void context?"
Da problem is dat grep buildz a return list, regardless of tha context.
This means you makin Perl git all up in tha shiznit of buildin a list that
you then just throw away. If tha list is large, you waste both time n' space.
If yo' intent is ta iterate over tha list, then bust a gangbangin' fo' loop fo' this
purpose.
.PP
In perls olda than 5.8.1, map suffers from dis problem as well.
But since 5.8.1, dis has been fixed, n' map is context aware \- up in void
context, no lists is constructed.
.SS "How tha fuck can I match strings wit multibyte characters?"
.IX Xref "regex, n' multibyte charactas regexp, n' multibyte charactas regular expression, n' multibyte charactas martian encoding, Martian"
.IX Subsection "How tha fuck can I match strings wit multibyte characters?"
Startin from Perl 5.6 Perl has had some level of multibyte character
support. Perl 5.8 or lata is recommended. Y'all KNOW dat shit, muthafucka! Supported multibyte
characta repertoires include Unicode, n' legacy encodings
all up in tha Encode module. Right back up in yo muthafuckin ass. See perluniintro, perlunicode,
and Encode.
.PP
If yo ass is stuck wit olda Perls, you can do Unicode wit the
Unicode::Strin module, n' characta conversions rockin the
Unicode::Map8 n' Unicode::Map modules. If yo ass is using
Japanese encodings, you might try rockin tha jperl 5.005_03.
.PP
Finally, tha followin set of approaches was offered by Jeffrey
Friedl, whose article up in issue #5 of Da Perl Journal talks about
this straight-up matter.
.PP
Letz suppose you have some weird Martian encodin where pairs of
\&\s-1ASCII\s0 uppercase lettas encode single Martian lettas (i.e. tha two
bytes \*(L"\s-1CV\*(R"\s0 cook up a single Martian letter, as do tha two bytes \*(L"\s-1SG\*(R",
\&\*(L"VS\*(R", \*(L"XX\*(R",\s0 etc.). Other bytes represent single characters, just like
\&\s-1ASCII.\s0
.PP
So, tha strang of Martian \*(L"I be \s-1CVSGXX\s0!\*(R" uses 12 bytes ta encode the
nine charactas 'I', ' ', 'a', 'm', ' ', '\s-1CV\s0', '\s-1SG\s0', '\s-1XX\s0', '!'.
.PP
Now, say you wanna search fo' tha single characta \f(CW\*(C`/GX/\*(C'\fR. Perl
doesn't know bout Martian, so it'll find tha two bytes \*(L"\s-1GX\*(R"\s0 up in tha \*(L"I
am \s-1CVSGXX\s0!\*(R" string, even though dat characta aint there: it just
looks like it is cuz \*(L"\s-1SG\*(R"\s0 is next ta \*(L"\s-1XX\*(R",\s0 but there be a no real
\&\*(L"\s-1GX\*(R".\s0 This be a funky-ass big-ass problem.
.PP
Here is all dem ways, all painful, ta deal wit it:
.PP
.Vb 2
\&    # Make shizzle adjacent "martian" bytes is no longer adjacent.
\&    $martian =~ s/([A\-Z][A\-Z])/ $1 /g;
\&
\&    print "found GX!\en" if $martian =~ /GX/;
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    mah @chars = $martian =~ m/([A\-Z][A\-Z]|[^A\-Z])/g;
\&    # above is conceptually similar to:     mah @chars = $text =~ m/(.)/g;
\&    #
\&    foreach mah $char (@chars) {
\&        print "found GX!\en", last if $char eq \*(AqGX\*(Aq;
\&    }
.Ve
.PP
Or like this:
.PP
.Vb 6
\&    while ($martian =~ m/\eG([A\-Z][A\-Z]|.)/gs) {  # \eG probably unneeded
\&        if ($1 eq \*(AqGX\*(Aq) {
\&            print "found GX!\en";
\&            last;
\&        }
\&    }
.Ve
.PP
Herez another, slightly less painful, way ta do it from Benjamin
Goldberg, whoz ass uses a zero-width wack look-behind assertion.
.PP
.Vb 5
\&    print "found GX!\en" if    $martian =~ m/
\&        (?<![A\-Z])
\&        (?:[A\-Z][A\-Z])*?
\&        GX
\&        /x;
.Ve
.PP
This succeedz if tha \*(L"martian\*(R" characta \s-1GX\s0 is up in tha string, n' fails
otherwise. If you don't like rockin (?<!), a zero-width negative
look-behind assertion, you can replace (?<![A\-Z]) wit (?:^|[^A\-Z]).
.PP
It do have tha drawback of puttin tha wack thang up in $\-[0] n' $+[0],
but dis probably can be hit dat shiznit around.
.SS "How tha fuck do I match a regular expression thatz up in a variable?"
.IX Xref "regex, up in variable eval regex quotemeta \\Q, regex \\E, regex qr"
.IX Subsection "How tha fuck do I match a regular expression thatz up in a variable?"
(contributed by brian d foy)
.PP
Us dudes don't gotta hard-code patterns tha fuck into tha match operator (or
anythang else dat works wit regular expressions). We can put the
pattern up in a variable fo' lata use.
.PP
Da match operator be a thugged-out double quote context, so you can interpolate
your variable just like a thugged-out double quoted string. In dis case, you
read tha regular expression as user input n' store it up in \f(CW$regex\fR.
Once you have tha pattern up in \f(CW$regex\fR, you use dat variable up in the
match operator.
.PP
.Vb 1
\&    chomp( mah $regex = <STDIN> );
\&
\&    if( $strin =~ m/$regex/ ) { ... }
.Ve
.PP
Any regular expression special charactas up in \f(CW$regex\fR is still
special, n' tha pattern still has ta be valid or Perl will complain.
For instance, up in dis pattern there be a unpaired parenthesis.
.PP
.Vb 1
\&    mah $regex = "Unmatched ( paren";
\&
\&    "Two parens ta bind dem all" =~ m/$regex/;
.Ve
.PP
When Perl compilez tha regular expression, it treats tha parenthesis
as tha start of a memory match. When it don't find tha closing
parenthesis, it bitches:
.PP
.Vb 1
\&    Unmatched ( up in regex; marked by <\-\- HERE up in m/Unmatched ( <\-\- HERE  paren/ at script line 3.
.Ve
.PP
Yo ass can git round dis up in nuff muthafuckin ways dependin on our thang.
First, if you don't want any of tha charactas up in tha strang ta be
special, you can escape dem wit \f(CW\*(C`quotemeta\*(C'\fR before you use tha string.
.PP
.Vb 2
\&    chomp( mah $regex = <STDIN> );
\&    $regex = quotemeta( $regex );
\&
\&    if( $strin =~ m/$regex/ ) { ... }
.Ve
.PP
Yo ass can also do dis directly up in tha match operator rockin tha \f(CW\*(C`\eQ\*(C'\fR
and \f(CW\*(C`\eE\*(C'\fR sequences. Da \f(CW\*(C`\eQ\*(C'\fR  drops some lyrics ta Perl where ta start escaping
special characters, n' tha \f(CW\*(C`\eE\*(C'\fR  drops some lyrics ta it where ta stop (see perlop
for mo' details).
.PP
.Vb 1
\&    chomp( mah $regex = <STDIN> );
\&
\&    if( $strin =~ m/\eQ$regex\eE/ ) { ... }
.Ve
.PP
Alternately, you can use \f(CW\*(C`qr//\*(C'\fR, tha regular expression quote operator (see
perlop fo' mo' details). Well shiiiit, it quotes n' like compilez tha pattern,
and you can apply regular expression flags ta tha pattern.
.PP
.Vb 1
\&    chomp( mah $input = <STDIN> );
\&
\&    mah $regex = qr/$input/is;
\&
\&    $strin =~ m/$regex/  # same as m/$input/is;
.Ve
.PP
Yo ass might also wanna trap any errors by wrappin a \f(CW\*(C`eval\*(C'\fR block
around tha whole thang.
.PP
.Vb 1
\&    chomp( mah $input = <STDIN> );
\&
\&    eval {
\&        if( $strin =~ m/\eQ$input\eE/ ) { ... }
\&    };
\&    warn $@ if $@;
.Ve
.PP
Or...
.PP
.Vb 7
\&    mah $regex = eval { qr/$input/is };
\&    if( defined $regex ) {
\&        $strin =~ m/$regex/;
\&    }
\&    else {
\&        warn $@;
\&    }
.Ve
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in dis file
are hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' fun
or fo' profit as you peep fit fo' realz. A simple comment up in tha code giving
credit would be courteous but aint required.
