.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPORT 1"
.TH PERLPORT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlport \- Freestylin portable Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl runs on a shitload of operatin systems.  While most of dem share
much up in common, they also have they own unique features.
.PP
This document is meant ta help you ta smoke up what tha fuck constitutes portable
Perl code.  That way once you cook up a thugged-out decision ta write portably,
you know where tha lines is drawn, n' you can stay within em.
.PP
There be a tradeoff between takin full advantage of one particular
type of computa n' takin advantage of a gangbangin' full range of em.
Naturally, as you broaden yo' range n' become mo' diverse, the
common factors drop, n' yo ass is left wit a mo' n' mo' n' mo' smaller
area of common ground up in which you can operate ta accomplish a
particular task.  Thus, when you begin comin' at a problem, it is
important ta consider under which part of tha tradeoff curve you
wanna operate.  Specifically, you must decizzle whether it is
important dat tha task dat yo ass is codin have tha full generality
of bein portable, or whether ta just git tha thang done n' aint a thugged-out damn thang dat yo' ass can do.
This is tha hardest chizzle ta be made.  Da rest is easy as fuck , cuz
Perl serves up nuff chizzles, whichever way you wanna approach your
problem.
.PP
Lookin at it another way, freestylin portable code is probably about
willfully limitin yo' available chizzles.  Naturally, it takes
discipline n' sacrifice ta do dis shit.  Da thang of portability
and convenience may be a cold-ass lil constant.  Yo ass done been warned.
.PP
Be aware of two blingin points:
.IP "Not all Perl programs gotta be portable" 4
.IX Item "Not all Perl programs gotta be portable"
There is no reason you should not use Perl as a language ta glue Unix
tools together, or ta prototype a Macintosh application, or ta manage the
Windows registry.  If it make no sense ta aim fo' portabilitizzle fo' one
reason or another up in a given program, then don't bother.
.IP "Nearly all of Perl already \fIis\fR portable" 4
.IX Item "Nearly all of Perl already is portable"
Don't be fooled tha fuck into thankin dat it is hard ta create portable Perl
code.  It aint.  Perl tries its level-best ta bridge tha gaps between
whatz available on different platforms, n' all tha means available to
use dem features.  Thus almost all Perl code runs on any machine
without modification. I aint talkin' bout chicken n' gravy biatch.  But there be some dope thangs in
writin portable code, n' dis document is entirely bout dem issues.
.PP
Herez tha general rule: When you approach a task commonly done
usin a whole range of platforms, be thinkin bout freestylin portable
code.  That way, you don't sacrifice much by way of tha implementation
choices you can avail yo ass of, n' all up in tha same time you can give
your playas fuckin shitloadz of platform chizzles.  On tha other hand, when you have to
take advantage of some unique feature of a particular platform, as is
often tha case wit systems programmin (whether fo' Unix, Windows,
\&\s-1VMS,\s0 etc.), consider freestylin platform-specific code.
.PP
When tha code will run on only two or three operatin systems, you
may need ta consider only tha differencez of dem particular systems.
Da blingin thang is ta decizzle where tha code will run n' ta be
deliberate up in yo' decision.
.PP
Da material below is separated tha fuck into three main sections: main thangs of
portabilitizzle (\*(L"\s-1ISSUES\*(R"\s0), platform-specific thangs (\*(L"\s-1PLATFORMS\*(R"\s0), and
built-in perl functions dat behave differently on various ports
(\*(L"\s-1FUNCTION IMPLEMENTATIONS\*(R"\s0).
.PP
This shiznit should not be considered complete; it includes possibly
transient shiznit bout idiosyncrasiez of a shitload of tha ports, almost
all of which is up in a state of constant evolution. I aint talkin' bout chicken n' gravy biatch.  Thus, dis material
should be considered a perpetual work up in progress
(\f(CW\*(C`<IMG SRC="yellow_sign.gif" ALT="Under Construction">\*(C'\fR).
.SH "ISSUES"
.IX Header "ISSUES"
.SS "Newlines"
.IX Subsection "Newlines"
In most operatin systems, lines up in filez is terminated by newlines.
Just what tha fuck is used as a newline may vary from \s-1OS\s0 ta \s-1OS. \s0 Unix
traditionally uses \f(CW\*(C`\e012\*(C'\fR, one type of DOSish I/O uses \f(CW\*(C`\e015\e012\*(C'\fR,
and Mac\ \s-1OS\s0 uses \f(CW\*(C`\e015\*(C'\fR.
.PP
Perl uses \f(CW\*(C`\en\*(C'\fR ta represent tha \*(L"logical\*(R" newline, where what tha fuck is
logical may depend on tha platform up in use.  In MacPerl, \f(CW\*(C`\en\*(C'\fR always
means \f(CW\*(C`\e015\*(C'\fR.  In DOSish perls, \f(CW\*(C`\en\*(C'\fR probably means \f(CW\*(C`\e012\*(C'\fR yo, but when
accessin a gangbangin' file up in \*(L"text\*(R" mode, perl uses tha \f(CW\*(C`:crlf\*(C'\fR layer that
translates it ta (or from) \f(CW\*(C`\e015\e012\*(C'\fR, dependin on whether you is
readin or writing. Unix do tha same thang on ttys up in canonical
mode.  \f(CW\*(C`\e015\e012\*(C'\fR is commonly referred ta as \s-1CRLF.\s0
.PP
To trim trailin newlines from text lines use \fIchomp()\fR.  With default 
settings dat function looks fo' a trailin \f(CW\*(C`\en\*(C'\fR characta n' thus 
trims up in a portable way.
.PP
When dealin wit binary filez (or text filez up in binary mode) be sure
to explicitly set $/ ta tha appropriate value fo' yo' file format
before rockin \fIchomp()\fR.
.PP
Because of tha \*(L"text\*(R" mode translation, DOSish perls have limitations
in rockin \f(CW\*(C`seek\*(C'\fR n' \f(CW\*(C`tell\*(C'\fR on a gangbangin' file accessed up in \*(L"text\*(R" mode.
Stick ta \f(CW\*(C`seek\*(C'\fR\-in ta locations you gots from \f(CW\*(C`tell\*(C'\fR (and no
others), n' yo ass is probably free ta use \f(CW\*(C`seek\*(C'\fR n' \f(CW\*(C`tell\*(C'\fR even
in \*(L"text\*(R" mode.  Usin \f(CW\*(C`seek\*(C'\fR or \f(CW\*(C`tell\*(C'\fR or other file operations
may be non-portable.  If you use \f(CW\*(C`binmode\*(C'\fR on a gangbangin' file, however, you
can probably \f(CW\*(C`seek\*(C'\fR n' \f(CW\*(C`tell\*(C'\fR wit arbitrary joints up in safety.
.PP
A common misconception up in socket programmin is dat \f(CW\*(C`\en\*(C'\fR eq \f(CW\*(C`\e012\*(C'\fR
everywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  When rockin protocols like fuckin common Internizzle protocols,
\&\f(CW\*(C`\e012\*(C'\fR n' \f(CW\*(C`\e015\*(C'\fR is called fo' specifically, n' tha joints of
the logical \f(CW\*(C`\en\*(C'\fR n' \f(CW\*(C`\er\*(C'\fR (carriage return) is not reliable.
.PP
.Vb 2
\&    print SOCKET "Yo there, client!\er\en";      # WRONG
\&    print SOCKET "Yo there, client!\e015\e012";  # RIGHT
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat rockin \f(CW\*(C`\e015\e012\*(C'\fR (or \f(CW\*(C`\ecM\ecJ\*(C'\fR, or \f(CW\*(C`\ex0D\ex0A\*(C'\fR) can be tedious
and unsightly, as well as confusin ta dem maintainin tha code.  As
such, tha Socket module supplies tha Right Thin fo' dem playas whoz ass want dat shit.
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    print SOCKET "Yo there, client!$CRLF"      # RIGHT
.Ve
.PP
When readin from a socket, remember dat tha default input record
separator \f(CW$/\fR is \f(CW\*(C`\en\*(C'\fR yo, but robust socket code will recognize as
either \f(CW\*(C`\e012\*(C'\fR or \f(CW\*(C`\e015\e012\*(C'\fR as end of line:
.PP
.Vb 3
\&    while (<SOCKET>) {
\&        # ...
\&    }
.Ve
.PP
Because both \s-1CRLF\s0 n' \s-1LF\s0 end up in \s-1LF,\s0 tha input record separator can
be set ta \s-1LF\s0 n' any \s-1CR\s0 stripped later n' shit.  Betta ta write:
.PP
.Vb 2
\&    use Socket qw(:DEFAULT :crlf);
\&    local($/) = LF;      # not needed if $/ be already \e012
\&
\&    while (<SOCKET>) {
\&        s/$CR?$LF/\en/;   # not shizzle if socket uses LF or CRLF, OK
\&    #   s/\e015?\e012/\en/; # same thang
\&    }
.Ve
.PP
This example is preferred over tha previous one\*(--even fo' Unix
platforms\*(--because now any \f(CW\*(C`\e015\*(C'\fRz (\f(CW\*(C`\ecM\*(C'\fR's) is stripped out
(and there was much rejoicing).
.PP
Similarly, functions dat return text data\*(--like fuckin a gangbangin' function that
fetches a wizzy page\*(--should sometimes translate newlines before
returnin tha data, if they've not yet been translated ta tha local
newline representation. I aint talkin' bout chicken n' gravy biatch.  A single line of code will often suffice:
.PP
.Vb 2
\&    $data =~ s/\e015?\e012/\en/g;
\&    return $data;
.Ve
.PP
Some of dis may be confusing.  Herez a handy reference ta tha \s-1ASCII CR\s0
and \s-1LF\s0 characters.  Yo ass can print it up n' stick it up in yo' wallet.
.PP
.Vb 2
\&    LF  eq  \e012  eq  \ex0A  eq  \ecJ  eq  chr(10)  eq  ASCII 10
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  ASCII 13
\&
\&             | Unix | DOS  | Mac  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF  |  CR  |
\&        \er   |  CR  |  CR  |  LF  |
\&        \en * |  LF  | CRLF |  CR  |
\&        \er * |  CR  |  CR  |  LF  |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.PP
Da Unix column assumes dat yo ass is not accessin a serial line
(like a tty) up in canonical mode.  If yo ass is, then \s-1CR\s0 on input becomes
\&\*(L"\en\*(R", n' \*(L"\en\*(R" on output becomes \s-1CRLF.\s0
.PP
These is just da most thugged-out common definitionz of \f(CW\*(C`\en\*(C'\fR n' \f(CW\*(C`\er\*(C'\fR up in Perl.
There may well be others.  For example, on a \s-1EBCDIC\s0 implementation
like fuckin z/OS (\s-1OS/390\s0) or \s-1OS/400 \s0(usin tha \s-1ILE,\s0 tha \s-1PASE\s0 is ASCII-based)
the above material is similar ta \*(L"Unix\*(R" but tha code numbers chizzle:
.PP
.Vb 4
\&    LF  eq  \e025  eq  \ex15  eq  \ecU  eq  chr(21)  eq  CP\-1047 21
\&    LF  eq  \e045  eq  \ex25  eq           chr(37)  eq  CP\-0037 37
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-1047 13
\&    CR  eq  \e015  eq  \ex0D  eq  \ecM  eq  chr(13)  eq  CP\-0037 13
\&
\&             | z/OS | OS/400 |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        \en   |  LF  |  LF    |
\&        \er   |  CR  |  CR    |
\&        \en * |  LF  |  LF    |
\&        \er * |  CR  |  CR    |
\&        \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        * text\-mode STDIO
.Ve
.SS "Numbers endiannizz n' Width"
.IX Subsection "Numbers endiannizz n' Width"
Different CPUs store integers n' floatin point numbers up in different
ordaz (called \fIendianness\fR) n' widths (32\-bit n' 64\-bit bein the
most common todizzle).  This affects yo' programs when they attempt ta transfer
numbers up in binary format from one \s-1CPU\s0 architecture ta another,
usually either \*(L"live\*(R" via network connection, or by storin the
numbers ta secondary storage like fuckin a gangbangin' finger-lickin' disk file or tape.
.PP
Conflictin storage ordaz make utta mess outta tha numbers.  If a
lil-endian host (Intel, \s-1VAX\s0) stores 0x12345678 (305419896 in
decimal), a funky-ass big-endian host (Motorola, Sparc, \s-1PA\s0) readz it as
0x78563412 (2018915346 up in decimal).  Alpha n' \s-1MIPS\s0 can be either:
Digital/Compaq used/uses dem up in lil-endian mode; SGI/Cray uses
them up in big-endian mode.  To avoid dis problem up in network (socket)
connections use tha \f(CW\*(C`pack\*(C'\fR n' \f(CW\*(C`unpack\*(C'\fR formats \f(CW\*(C`n\*(C'\fR n' \f(CW\*(C`N\*(C'\fR, the
\&\*(L"network\*(R" orders.  These is guaranteed ta be portable.
.PP
Az of perl 5.10.0, you can also use tha \f(CW\*(C`>\*(C'\fR n' \f(CW\*(C`<\*(C'\fR modifiers
to force big\- or lil-endian byte-order n' shit.  This is useful if you want
to store signed integers or 64\-bit integers, fo' example.
.PP
Yo ass can explore tha endiannizz of yo' platform by unpackin a
data structure packed up in natizzle format such as:
.PP
.Vb 3
\&    print unpack("h*", pack("s2", 1, 2)), "\en";
\&    # \*(Aq10002000\*(Aq on e.g. Intel x86 or Alpha 21064 up in lil\-endian mode
\&    # \*(Aq00100020\*(Aq on e.g. Motorola 68040
.Ve
.PP
If you need ta distinguish between endian architectures you could use
either of tha variablez set like so:
.PP
.Vb 2
\&    $is_big_endian   = unpack("h*", pack("s", 1)) =~ /01/;
\&    $is_lil_endian = unpack("h*", pack("s", 1)) =~ /^1/;
.Ve
.PP
Differin widths can cause truncation even between platformz of equal
endianness.  Da platform of shorta width loses tha upper partz of the
number n' shit.  There is no phat solution fo' dis problem except ta avoid
transferrin or storin raw binary numbers.
.PP
One can circumnavigate both these problems up in two ways.  Either
transfer n' store numbers always up in text format, instead of raw
binary, or else consider rockin modulez like Data::Dumper n' Storable
(included az of perl 5.8).  Keepin all data as text significantly
simplifies matters.
.PP
Da v\-strings is portable only up ta v2147483647 (0x7FFFFFFF), that's
how far \s-1EBCDIC,\s0 or mo' precisely UTF-EBCDIC will go.
.SS "Filez n' Filesystems"
.IX Subsection "Filez n' Filesystems"
Most platforms these minutes structure filez up in a hierarchical fashion.
So, it is reasonably safe ta assume dat all platforms support the
notion of a \*(L"path\*(R" ta uniquely identify a gangbangin' file on tha system.  How
that path is straight-up written, though, differs considerably.
.PP
Although similar, file path justifications differ between Unix,
Windows, Mac\ \s-1OS, OS/2, VMS, VOS, RISC\s0\ \s-1OS,\s0 n' probably others.
Unix, fo' example, is one of tha few OSes dat has tha elegant idea
of a single root directory.
.PP
\&\s-1DOS, OS/2, VMS, VOS,\s0 n' Windows can work similarly ta Unix wit \f(CW\*(C`/\*(C'\fR
as path separator, or up in they own idiosyncratic ways (like fuckin having
several root directories n' various \*(L"unrooted\*(R" thang filez such \s-1NIL:\s0
and \s-1LPT:\s0).
.PP
Mac\ \s-1OS 9\s0 n' earlier used \f(CW\*(C`:\*(C'\fR as a path separator instead of \f(CW\*(C`/\*(C'\fR.
.PP
Da filesystem may support neither hard links (\f(CW\*(C`link\*(C'\fR) nor
symbolic links (\f(CW\*(C`symlink\*(C'\fR, \f(CW\*(C`readlink\*(C'\fR, \f(CW\*(C`lstat\*(C'\fR).
.PP
Da filesystem may support neither access timestamp nor chizzle
timestamp (meanin dat bout tha only portable timestamp is the
modification timestamp), or one second granularitizzle of any timestamps
(e.g. tha \s-1FAT\s0 filesystem limits tha time granularitizzle ta two seconds).
.PP
Da \*(L"inode chizzle timestamp\*(R" (the \f(CW\*(C`\-C\*(C'\fR filetest) may straight-up be the
\&\*(L"creation timestamp\*(R" (which it aint up in Unix).
.PP
\&\s-1VOS\s0 perl can emulate Unix filenames wit \f(CW\*(C`/\*(C'\fR as path separator. Shiiit, dis aint no joke.  The
natizzle pathname charactas pimped outer-than, less-than, number-sign, and
percent-sign is always accepted.
.PP
\&\s-1RISC\s0\ \s-1OS\s0 perl can emulate Unix filenames wit \f(CW\*(C`/\*(C'\fR as path
separator, or go natizzle n' use \f(CW\*(C`.\*(C'\fR fo' path separator n' \f(CW\*(C`:\*(C'\fR to
signal filesystems n' disk names.
.PP
Don't assume Unix filesystem access semantics: dat read, write,
and execute is all tha permissions there are, n' even if they exist,
that they semantics (for example what tha fuck do r, w, n' x mean on
a directory) is tha Unix ones.  Da various Unix/POSIX compatibility
layers probably try ta make intercourses like \fIchmod()\fR work yo, but sometimes
there simply is no phat mapping.
.PP
If all dis is intimidating, have no (well, maybe only a lil)
fear. Shiiit, dis aint no joke.  There is modulez dat can help.  Da File::Spec modules
provide methodz ta do tha Right Thin on whatever platform happens
to be hustlin tha program.
.PP
.Vb 6
\&    use File::Spec::Functions;
\&    chdir(updir());        # go up one directory
\&    mah $file = catfile(curdir(), \*(Aqtemp\*(Aq, \*(Aqfile.txt\*(Aq);
\&    # on Unix n' Win32, \*(Aq./temp/file.txt\*(Aq
\&    # on Mac OS Classic, \*(Aq:temp:file.txt\*(Aq
\&    # on VMS, \*(Aq[.temp]file.txt\*(Aq
.Ve
.PP
File::Spec be available up in tha standard distribution az of version
5.004_05.  File::Spec::Functions is only up in File::Spec 0.7 n' later,
and some versionz of perl come wit version 0.6.  If File::Spec
is not updated ta 0.7 or later, you must use tha object-oriented
interface from File::Spec (or upgrade File::Spec).
.PP
In general, thang code should not have file paths hardcoded.
Makin dem user-supplied or read from a cold-ass lil configuration file is
better, keepin up in mind dat file path syntax varies on different
machines.
.PP
This is especially noticeable up in scripts like Makefilez n' test suites,
which often assume \f(CW\*(C`/\*(C'\fR as a path separator fo' subdirectories.
.PP
Also of use is File::Basename from tha standard distribution, which
splits a pathname tha fuck into pieces (base filename, full path ta directory,
and file suffix).
.PP
Even when on a single platform (if you can call Unix a single platform),
remember not ta count on tha existence or tha contentz of particular
system-specific filez or directories, like \fI/etc/passwd\fR,
\&\fI/etc/sendmail.conf\fR, \fI/etc/resolv.conf\fR, or even \fI/tmp/\fR.  For
example, \fI/etc/passwd\fR may exist but not contain tha encrypted
passwords, cuz tha system is rockin some form of enhanced security.
Or it may not contain all tha accounts, cuz tha system is rockin \s-1NIS. \s0
If code do need ta rely on such a gangbangin' file, include a thugged-out description of the
file n' its format up in tha codez documentation, then make it easy as fuck  for
the user ta override tha default location of tha file.
.PP
Don't assume a text file will end wit a newline.  They should,
but playas forget.
.PP
Do not have two filez or directoriez of tha same name wit different
case, like \fItest.pl\fR n' \fITest.pl\fR, as nuff platforms have
case-insensitizzle (or at least case-forgiving) filenames.  Also, try
not ta have non-word charactas (except fo' \f(CW\*(C`.\*(C'\fR) up in tha names, and
keep dem ta tha 8.3 convention, fo' maximum portability, onerous a
burden though dis may appear.
.PP
Likewise, when rockin tha AutoSplit module, try ta keep yo' functions to
8.3 namin n' case-insensitizzle conventions; or, all up in tha least,
make it so tha resultin filez gotz a unique (case-insensitively)
first 8 characters.
.PP
Whitespace up in filenames is tolerated on most systems yo, but not all,
and even on systems where it might be tolerated, some utilities
might become trippin by such whitespace.
.PP
Many systems (\s-1DOS, VMS ODS\-2\s0) cannot have mo' than one \f(CW\*(C`.\*(C'\fR up in their
filenames.
.PP
Don't assume \f(CW\*(C`>\*(C'\fR won't be tha straight-up original gangsta characta of a gangbangin' filename.
Always use \f(CW\*(C`<\*(C'\fR explicitly ta open a gangbangin' file fo' reading, or even
better, use tha three-arg version of open, unless you want tha user to
be able ta specify a pipe open.
.PP
.Vb 1
\&    open mah $fh, \*(Aq<\*(Aq, $existing_file) or take a thugged-out dirtnap $!;
.Ve
.PP
If filenames might use strange characters, it is safest ta open it
with \f(CW\*(C`sysopen\*(C'\fR instead of \f(CW\*(C`open\*(C'\fR.  \f(CW\*(C`open\*(C'\fR is magic n' can
translate charactas like \f(CW\*(C`>\*(C'\fR, \f(CW\*(C`<\*(C'\fR, n' \f(CW\*(C`|\*(C'\fR, which may
be tha wack thang ta do.  (Sometimes, though, itz tha right thang.)
Three-arg open can also help protect against dis translation up in cases
where it is undesirable.
.PP
Don't use \f(CW\*(C`:\*(C'\fR as a part of a gangbangin' filename since nuff systems use dat for
their own semantics (Mac \s-1OS\s0 Funky-Ass fo' separatin pathname components,
many networkin schemes n' utilitizzles fo' separatin tha nodename and
the pathname, n' so on).  For tha same reasons, avoid \f(CW\*(C`@\*(C'\fR, \f(CW\*(C`;\*(C'\fR and
\&\f(CW\*(C`|\*(C'\fR.
.PP
Don't assume dat up in pathnames you can collapse two leadin slashes
\&\f(CW\*(C`//\*(C'\fR tha fuck into one: some networkin n' clusterin filesystems have special
semantics fo' dis shit.  Let tha operatin system ta sort it out.
.PP
Da \fIportable filename characters\fR as defined by \s-1ANSI C\s0 are
.PP
.Vb 4
\& a funky-ass b c d e f g h i j k l m n o p q r t u v w x y z
\& A B C D E F G H I J K L M N O P Q R T U V W X Y Z
\& 0 1 2 3 4 5 6 7 8 9
\& . _ \-
.Ve
.PP
and tha \*(L"\-\*(R" shouldn't be tha straight-up original gangsta character n' shit.  If you wanna be
hypercorrect, stay case-insensitizzle n' within tha 8.3 naming
convention (all tha filez n' directories gotta be unique within one
directory if they names is lowercased n' truncated ta eight
charactas before tha \f(CW\*(C`.\*(C'\fR, if any, n' ta three charactas afta the
\&\f(CW\*(C`.\*(C'\fR, if any).  (And do not use \f(CW\*(C`.\*(C'\fRs up in directory names.)
.SS "System Interaction"
.IX Subsection "System Interaction"
Not all platforms provide a cold-ass lil command line.  These is probably platforms
that rely primarily on a Graphical User Interface (\s-1GUI\s0) fo' user
interaction. I aint talkin' bout chicken n' gravy biatch.  A program requirin a cold-ass lil command line intercourse might
not work everywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  This is probably fo' tha user of tha program
to deal with, so don't stay up late worryin bout dat shit.
.PP
Some platforms can't delete or rename filez held open by tha system,
this limitation may also apply ta changin filesystem metainformation
like file permissions or ballers.  Remember ta \f(CW\*(C`close\*(C'\fR filez when you
are done wit em.  Don't \f(CW\*(C`unlink\*(C'\fR or \f(CW\*(C`rename\*(C'\fR a open file.  Don't
\&\f(CW\*(C`tie\*(C'\fR or \f(CW\*(C`open\*(C'\fR a gangbangin' file already tied or opened; \f(CW\*(C`untie\*(C'\fR or \f(CW\*(C`close\*(C'\fR
it first.
.PP
Don't open tha same file mo' than once at a time fo' writing, as some
operatin systems put mandatory locks on such files.
.PP
Don't assume dat write/modify permission on a gangbangin' finger-lickin' directory gives the
right ta add or delete files/directories up in dat directory.  That is
filesystem specific: up in some filesystems you need write/modify
permission also (or even just) up in tha file/directory itself.  In some
filesystems (\s-1AFS, DFS\s0) tha permission ta add/delete directory entries
is a cold-ass lil straight-up separate permission.
.PP
Don't assume dat a single \f(CW\*(C`unlink\*(C'\fR straight-up gets rid of tha file:
some filesystems (most notably tha ones up in \s-1VMS\s0) have versioned
filesystems, n' \fIunlink()\fR removes only da most thugged-out recent one (it don't
remove all tha versions cuz by default tha natizzle tools on them
platforms remove just da most thugged-out recent version, too).  Da portable
idiom ta remove all tha versionz of a gangbangin' file is
.PP
.Vb 1
\&    1 while unlink "file";
.Ve
.PP
This will terminizzle if tha file is undeleteable fo' some reason
(protected, not there, n' so on).
.PP
Don't count on a specific environment variable existin up in \f(CW%ENV\fR.
Don't count on \f(CW%ENV\fR entries bein case-sensitive, or even
case-preserving.  Don't try ta clear \f(CW%ENV\fR by sayin \f(CW\*(C`%ENV = ();\*(C'\fR, or,
if you straight-up have to, make it conditionizzle on \f(CW\*(C`$^O ne \*(AqVMS\*(Aq\*(C'\fR since in
\&\s-1VMS\s0 tha \f(CW%ENV\fR table is much mo' than a per-process key-value string
table.
.PP
On \s-1VMS,\s0 some entries up in tha \f(CW%ENV\fR hash is dynamically pimped when
their key is used on a read if they did not previously exist.  The
values fo' \f(CW$ENV{HOME}\fR, \f(CW$ENV{TERM}\fR, \f(CW$ENV{HOME}\fR, n' \f(CW$ENV{USER}\fR,
are known ta be dynamically generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da specific names dat are
dynamically generated may vary wit tha version of tha C library on \s-1VMS,\s0
and mo' may exist than is documented.
.PP
On \s-1VMS\s0 by default, chizzlez ta tha \f(CW%ENV\fR hash is persistent afta tha process
exits, n' you can put dat on yo' toast.  This can cause unintended issues.
.PP
Don't count on signals or \f(CW%SIG\fR fo' anything.
.PP
Don't count on filename globbing.  Use \f(CW\*(C`opendir\*(C'\fR, \f(CW\*(C`readdir\*(C'\fR, and
\&\f(CW\*(C`closedir\*(C'\fR instead.
.PP
Don't count on per-program environment variables, or per-program current
directories.
.PP
Don't count on specific jointz of \f(CW$!\fR, neither numeric nor
especially tha strings joints, n' you can put dat on yo' toast. Users may switch they localez causing
error lyrics ta be translated tha fuck into they languages.  If you can
trust a POSIXish environment, you can portably use tha symbols defined
by tha Errno module, like \s-1ENOENT. \s0 And don't trust on tha jointz of \f(CW$!\fR
at all except immediately afta a gangbangin' failed system call.
.SS "Command names versus file pathnames"
.IX Subsection "Command names versus file pathnames"
Don't assume dat tha name used ta invoke a cold-ass lil command or program with
\&\f(CW\*(C`system\*(C'\fR or \f(CW\*(C`exec\*(C'\fR can also be used ta test fo' tha existence of the
file dat holdz tha executable code fo' dat command or program.
First, nuff systems have \*(L"internal\*(R" commandz dat is built-in ta the
shell or \s-1OS\s0 n' while these commandz can be invoked, there is no
correspondin file.  Second, some operatin systems (e.g., Cygwin,
\&\s-1DJGPP, OS/2,\s0 n' \s-1VOS\s0) have required suffixes fo' executable files;
these suffixes is generally permitted on tha command name but is not
required. Y'all KNOW dat shit, muthafucka!  Thus, a cold-ass lil command like \*(L"perl\*(R" might exist up in a gangbangin' file named
\&\*(L"perl\*(R", \*(L"perl.exe\*(R", or \*(L"perl.pm\*(R", dependin on tha operatin system.
Da variable \*(L"_exe\*(R" up in tha Config module holdz tha executable suffix,
if any.  Third, tha \s-1VMS\s0 port carefully sets up $^X and
\&\f(CW$Config\fR{perlpath} so dat no further processin is required. Y'all KNOW dat shit, muthafucka!  This is
just as well, cuz tha matchin regular expression used below would
then gotta deal wit a possible trailin version number up in tha \s-1VMS\s0
file name.
.PP
To convert $^X ta a gangbangin' file pathname, takin account of tha requirements
of tha various operatin system possibilities, say:
.PP
.Vb 4
\& use Config;
\& mah $thisperl = $^X;
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.PP
To convert \f(CW$Config\fR{perlpath} ta a gangbangin' file pathname, say:
.PP
.Vb 4
\& use Config;
\& mah $thisperl = $Config{perlpath};
\& if ($^O ne \*(AqVMS\*(Aq)
\&    {$thisperl .= $Config{_exe} unless $thisperl =~ m/$Config{_exe}$/i;}
.Ve
.SS "Networking"
.IX Subsection "Networking"
Don't assume dat you can reach tha hood Internet.
.PP
Don't assume dat there is only one way ta git all up in firewalls
to tha hood Internet.
.PP
Don't assume dat you can reach outside ghetto all up in any other port
than 80, or some wizzy proxy.  ftp is blocked by nuff firewalls.
.PP
Don't assume dat you can bust email by connectin ta tha local \s-1SMTP\s0 port.
.PP
Don't assume dat you can reach yo ass or any node by tha name
\&'localhost'.  Da same goes fo' '127.0.0.1'.  Yo ass will gotta try both.
.PP
Don't assume dat tha host has only one network card, or dat it
can't bind ta nuff virtual \s-1IP\s0 addresses.
.PP
Don't assume a particular network thang name.
.PP
Don't assume a particular set of \fIioctl()\fRs will work.
.PP
Don't assume dat you can pin hosts n' git replies.
.PP
Don't assume dat any particular port (service) will respond.
.PP
Don't assume dat Sys::Hostname (or any other \s-1API\s0 or command) returns
either a gangbangin' straight-up qualified hostname or a non-qualified hostname: it all
dependz on how tha fuck tha system had been configured. Y'all KNOW dat shit, muthafucka!  Also remember dat for
things like fuckin \s-1DHCP\s0 n' \s-1NAT,\s0 tha hostname you git back might not be
very useful.
.PP
All tha above \*(L"don't\*(R":s may look daunting, n' they is yo, but tha key
is ta degrade gracefully if one cannot reach tha particular network
service one wants, n' you can put dat on yo' toast.  Croakin or hangin do not look straight-up professional.
.SS "Interprocess Communication (\s-1IPC\s0)"
.IX Subsection "Interprocess Communication (IPC)"
In general, don't directly access tha system up in code meant ta be
portable.  That means, no \f(CW\*(C`system\*(C'\fR, \f(CW\*(C`exec\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`pipe\*(C'\fR,
\&\f(CW\*(C`\`\`\*(C'\fR, \f(CW\*(C`qx//\*(C'\fR, \f(CW\*(C`open\*(C'\fR wit a \f(CW\*(C`|\*(C'\fR, nor any of tha other thangs
that make bein a perl hacker worth being.
.PP
Commandz dat launch external processes is generally supported on
most platforms (though nuff of dem do not support any type of
forking).  Da problem wit rockin dem arises from what tha fuck you invoke
them on. I aint talkin' bout chicken n' gravy biatch.  External tools is often named differently on different
platforms, may not be available up in tha same location, might accept
different arguments, can behave differently, n' often present their
results up in a platform-dependent way.  Thus, you should seldom depend
on dem ta produce consistent thangs up in dis biatch. (Then again, if you callin 
\&\fInetstat \-a\fR, you probably don't expect it ta run on both Unix n' \s-1CP/M.\s0)
.PP
One especially common bit of Perl code is openin a pipe ta \fBsendmail\fR:
.PP
.Vb 2
\&    open(MAIL, \*(Aq|/usr/lib/sendmail \-t\*(Aq) 
\&        or take a thugged-out dirtnap "cannot fork sendmail: $!";
.Ve
.PP
This is fine fo' systems programmin when sendmail is known ta be
available.  But it aint fine fo' nuff non-Unix systems, n' even
some Unix systems dat may not have sendmail installed. Y'all KNOW dat shit, muthafucka!  If a portable
solution is needed, peep tha various distributions on \s-1CPAN\s0 dat deal
with dat shit.  Mail::Maila n' Mail::Send up in tha MailTools distribution are
commonly used, n' provide nuff muthafuckin mailin methods, includin mail,
sendmail, n' direct \s-1SMTP \s0(via Net::SMTP) if a mail transfer agent is
not available.  Mail::Sendmail be a standalone module dat provides
simple, platform-independent mailing.
.PP
Da Unix System V \s-1IPC \s0(\f(CW\*(C`msg*(), sem*(), shm*()\*(C'\fR) aint available
even on all Unix platforms.
.PP
Do not use either tha bare result of \f(CW\*(C`pack("N", 10, 20, 30, 40)\*(C'\fR or
bare v\-strings (like fuckin \f(CW\*(C`v10.20.30.40\*(C'\fR) ta represent IPv4 addresses:
both forms just pack tha four bytes tha fuck into network order n' shit.  That this
would be equal ta tha C language \f(CW\*(C`in_addr\*(C'\fR struct (which is what tha fuck the
socket code internally uses) aint guaranteed. Y'all KNOW dat shit, muthafucka!  To be portable use
the routinez of tha Socket extension, like fuckin \f(CW\*(C`inet_aton()\*(C'\fR,
\&\f(CW\*(C`inet_ntoa()\*(C'\fR, n' \f(CW\*(C`sockaddr_in()\*(C'\fR.
.PP
Da rule of thumb fo' portable code is: Do all dat shiznit up in portable Perl, or
use a module (that may internally implement it wit platform-specific
code yo, but expose a cold-ass lil common intercourse).
.SS "External Subroutines (\s-1XS\s0)"
.IX Subsection "External Subroutines (XS)"
\&\s-1XS\s0 code can probably be made ta work wit any platform yo, but dependent
libraries, header files, etc., might not be readily available or
portable, or tha \s-1XS\s0 code itself might be platform-specific, just as Perl
code might be.  If tha libraries n' headaz is portable, then it is
normally reasonable ta make shizzle tha \s-1XS\s0 code is portable, like a muthafucka.
.PP
A different type of portabilitizzle issue arises when freestylin \s-1XS\s0 code:
availabilitizzle of a C compila on tha end-userz system.  C brangs
with it its own portabilitizzle issues, n' freestylin \s-1XS\s0 code will expose
you ta a shitload of them.  Freestylin purely up in Perl be a easier way to
achieve portability.
.SS "Standard Modules"
.IX Subsection "Standard Modules"
In general, tha standard modulez work across platforms.  Notable
exceptions is tha \s-1CPAN\s0 module (which currently make connections ta external
programs dat may not be available), platform-specific modulez (like
ExtUtils::MM_VMS), n' \s-1DBM\s0 modules.
.PP
There is no one \s-1DBM\s0 module available on all platforms.
SDBM_File n' tha others is generally available on all Unix n' DOSish
ports yo, but not up in MacPerl, where only NBDM_File n' DB_File are
available.
.PP
Da phat shizzle is dat at least some \s-1DBM\s0 module should be available, and
AnyDBM_File will use whichever module it can find. Y'all KNOW dat shit, muthafucka!  Of course, then
the code need ta be fairly strict, droppin ta tha top billin common
factor (e.g., not exceedin 1K fo' each record), so dat it will
work wit any \s-1DBM\s0 module.  See AnyDBM_File fo' mo' details.
.SS "Time n' Date"
.IX Subsection "Time n' Date"
Da systemz notion of time of dizzle n' calendar date is controlled in
widely different ways.  Don't assume tha timezone is stored up in \f(CW$ENV{TZ}\fR,
and even if it is, don't assume dat you can control tha timezone through
that variable.  Don't assume anythang bout tha three-letta timezone
abbreviations (for example dat \s-1MST\s0 would be tha Mountain Standard Time,
itz been known ta stand fo' Moscow Standard Time).  If you need to
use timezones, express dem up in some unambiguous format like the
exact number of minutes offset from \s-1UTC,\s0 or tha \s-1POSIX\s0 timezone
format.
.PP
Don't assume dat tha epoch starts at 00:00:00, January 1, 1970,
because dat is \s-1OS\-\s0 n' implementation-specific.  It be betta to
store a thugged-out date up in a unambiguous representation. I aint talkin' bout chicken n' gravy biatch.  Da \s-1ISO 8601\s0 standard
defines YYYY-MM-DD as tha date format, or \s-1YYYY\-MM\-DDTHH:MM:SS
\&\s0(thatz a literal \*(L"T\*(R" separatin tha date from tha time).
Please do use tha \s-1ISO 8601\s0 instead of makin our asses guess what
date 02/03/04 might be.  \s-1ISO 8601\s0 even sorts sickly as-is.
A text representation (like \*(L"1987\-12\-18\*(R") can be easily converted
into a OS-specific value rockin a module like Date::Parse.
An array of joints, like fuckin dem returned by \f(CW\*(C`localtime\*(C'\fR, can be
converted ta a OS-specific representation rockin Time::Local.
.PP
When calculatin specific times, like fuckin fo' tests up in time or date modules,
it may be appropriate ta calculate a offset fo' tha epoch.
.PP
.Vb 2
\&    require Time::Local;
\&    mah $offset = Time::Local::timegm(0, 0, 0, 1, 0, 70);
.Ve
.PP
Da value fo' \f(CW$offset\fR up in Unix is ghon be \f(CW0\fR yo, but up in Mac \s-1OS\s0 Classic
will be some big-ass number n' shit.  \f(CW$offset\fR can then be added ta a Unix time
value ta git what tha fuck should be tha proper value on any system.
.SS "Characta sets n' characta encoding"
.IX Subsection "Characta sets n' characta encoding"
Assume straight-up lil bout characta sets.
.PP
Assume not a god damn thang bout numerical joints (\f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`chr\*(C'\fR) of characters.
Do not use explicit code point ranges (like \exHH\-\exHH); use for
example symbolic characta classes like \f(CW\*(C`[:print:]\*(C'\fR.
.PP
Do not assume dat tha alphabetic charactas is encoded contiguously
(in tha numeric sense).  There may be gaps.
.PP
Do not assume anythang bout tha orderin of tha characters.
Da lowercase lettas may come before or afta tha uppercase letters;
the lowercase n' uppercase may be interlaced so dat both \*(L"a\*(R" n' \*(L"A\*(R"
come before \*(L"b\*(R"; tha accented n' other internationistic charactas may
be interlaced so dat a\*: comes before \*(L"b\*(R".
.SS "Internationalisation"
.IX Subsection "Internationalisation"
If you may assume \s-1POSIX \s0(a rather big-ass assumption), you may read
more bout tha \s-1POSIX\s0 locale system from perllocale.  Da locale
system at least attempts ta make thangs a lil bit mo' portable,
or at least mo' convenient n' native-friendly fo' non-English
users.  Da system affects characta sets n' encoding, n' date
and time formatting\*(--amongst other thangs.
.PP
If you straight-up wanna be international, you should consider Unicode.
See perluniintro n' perlunicode fo' mo' shiznit.
.PP
If you wanna use non-ASCII bytes (outside tha bytes 0x00..0x7f) in
the \*(L"source code\*(R" of yo' code, ta be portable you gotta be explicit
about what tha fuck bytes they are.  Someone might fo' example be rockin your
code under a \s-1UTF\-8\s0 locale, up in which case random natizzle bytes might be
illegal (\*(L"Malformed \s-1UTF\-8 ...\*(R"\s0)  This means dat fo' example embedding
\&\s-1ISO 8859\-1\s0 bytes beyond 0x7f tha fuck into yo' strings might cause shit
later n' shit.  If tha bytes is natizzle 8\-bit bytes, you can use tha \f(CW\*(C`bytes\*(C'\fR
pragma.  If tha bytes is up in a strang (regular expression bein a
curious string), you can often also use tha \f(CW\*(C`\exHH\*(C'\fR notation instead
of embeddin tha bytes as-is.  If you wanna write yo' code up in \s-1UTF\-8,\s0
you can use tha \f(CW\*(C`utf8\*(C'\fR.
.SS "System Resources"
.IX Subsection "System Resources"
If yo' code is destined fo' systems wit severely constrained (or
missing!) virtual memory systems then you wanna be \fIespecially\fR mindful
of avoidin wasteful constructs such as:
.PP
.Vb 1
\&    mah @lines = <$very_large_file>;            # bad
\&
\&    while (<$fh>) {$file .= $_}                # sometimes bad
\&    mah $file = join(\*(Aq\*(Aq, <$fh>);                # better
.Ve
.PP
Da last two constructs may step tha fuck up unintuitizzle ta most people.  The
first repeatedly grows a string, whereas tha second allocates a
pimpin' chunk of memory up in one go.  On some systems, tha second is
more efficient dat tha first.
.SS "Security"
.IX Subsection "Security"
Most multi-user platforms provide basic levelz of security, usually
implemented all up in tha filesystem level.  Some, however, unfortunately do
not.  Thus tha notion of user id, or \*(L"home\*(R" directory,
or even tha state of bein logged-in, may be unrecognizable on many
platforms.  If you write programs dat is security-conscious, it
is probably dopest ta know what tha fuck type of system yo big-ass booty is ghon be hustlin
under so dat you can write code explicitly fo' dat platform (or
class of platforms).
.PP
Don't assume tha Unix filesystem access semantics: tha operating
system or tha filesystem may be rockin some \s-1ACL\s0 systems, which are
richer languages than tha usual rwx.  Even if tha rwx exist,
their semantics might be different.
.PP
(From securitizzle viewpoint testin fo' permissions before attemptin to
do suttin' is wack-ass anyway: if one tries this, there is potential
for race conditions. Right back up in yo muthafuckin ass. Someone or suttin' might chizzle the
permissions between tha permissions check n' tha actual operation.
Just try tha operation.)
.PP
Don't assume tha Unix user n' crew semantics: especially, don't
expect tha \f(CW$<\fR n' \f(CW$>\fR (or tha \f(CW$(\fR n' \f(CW$)\fR) ta work
for switchin identitizzles (or memberships).
.PP
Don't assume set-uid n' set-gid semantics. (And even if you do,
think twice: set-uid n' set-gid is a known can of securitizzle worms.)
.SS "Style"
.IX Subsection "Style"
For dem times when it is necessary ta have platform-specific code,
consider keepin tha platform-specific code up in one place, makin porting
to other platforms easier n' shit.  Use tha Config module n' tha special
variable \f(CW$^O\fR ta differentiate platforms, as busted lyrics bout in
\&\*(L"\s-1PLATFORMS\*(R"\s0.
.PP
Be careful up in tha tests you supply wit yo' module or programs.
Module code may be straight-up portable yo, but its tests might not be.  This
often happens when tests spawn off other processes or call external
programs ta aid up in tha testing, or when (as noted above) tha tests
assume certain thangs bout tha filesystem n' paths.  Be careful not
to depend on a specific output steez fo' errors, like fuckin when checking
\&\f(CW$!\fR afta a gangbangin' failed system call.  Usin \f(CW$!\fR fo' anythang else than
displayin it as output is doubtful (though peep tha Errno module for
testin reasonably portably fo' error value). Right back up in yo muthafuckin ass. Some platforms expect
a certain output format, n' Perl on dem platforms may have been
adjusted accordingly.  Most specifically, don't anchor a regex when
testin a error value.
.SH "CPAN Testers"
.IX Header "CPAN Testers"
Modulez uploaded ta \s-1CPAN\s0 is tested by a variety of volunteers on
different platforms.  These \s-1CPAN\s0 testas is notified by mail of each
new upload, n' reply ta tha list wit \s-1PASS, FAIL, NA \s0(not applicable to
this platform), or \s-1UNKNOWN \s0(unknown), along wit any relevant notations.
.PP
Da purpose of tha testin is twofold: one, ta help pimpers fix any
problems up in they code dat crop up cuz of lack of testin on other
platforms; two, ta provide playas wit shiznit bout whether
a given module works on a given platform.
.PP
Also see:
.IP "\(bu" 4
Mailin list: cpan\-testers\-discuss@perl.org
.IP "\(bu" 4
Testin thangs up in dis biatch: <http://www.cpantesters.org/>
.SH "PLATFORMS"
.IX Header "PLATFORMS"
Perl is built wit a \f(CW$^O\fR variable dat indicates tha operating
system dat shiznit was built on. I aint talkin' bout chicken n' gravy biatch.  This was implemented
to help speed up code dat would otherwise gotta \f(CW\*(C`use Config\*(C'\fR
and use tha value of \f(CW$Config{osname}\fR.  Of course, ta git more
detailed shiznit bout tha system, lookin tha fuck into \f(CW%Config\fR is
certainly recommended.
.PP
\&\f(CW%Config\fR cannot always be trusted, however, cuz dat shiznit was built
at compile time.  If perl was built up in one place, then transferred
elsewhere, some joints may be wrong.  Da joints may even have been
edited afta tha fact.
.SS "Unix"
.IX Subsection "Unix"
Perl works on a funky-ass bewilderin variety of Unix n' Unix-like platforms (see
e.g. most of tha filez up in tha \fIhints/\fR directory up in tha source code kit).
On most of these systems, tha value of \f(CW$^O\fR (hence \f(CW$Config{\*(Aqosname\*(Aq}\fR,
too) is determined either by lowercasin n' strippin punctuation from the
first field of tha strang returned by typin \f(CW\*(C`uname \-a\*(C'\fR (or a similar command)
at tha shell prompt or by testin tha file system fo' tha presence of
uniquely named filez like fuckin a kernel or header file.  Here, fo' example,
are all dem of tha mo' ghettofab Unix flavors:
.PP
.Vb 10
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    AIX           aix        aix
\&    BSD/OS        bsdos      i386\-bsdos
\&    Darwin        darwin     darwin
\&    dgux          dgux       AViiON\-dgux
\&    DYNIX/ptx     dynixptx   i386\-dynixptx
\&    FreeBSD       freebsd    freebsd\-i386    
\&    Haiku         haiku      BePC\-haiku
\&    Linux         linux      arm\-linux
\&    Linux         linux      i386\-linux
\&    Linux         linux      i586\-linux
\&    Linux         linux      ppc\-linux
\&    HP\-UX         hpux       PA\-RISC1.1
\&    IRIX          irix       irix
\&    Mac OS X      darwin     darwin
\&    NeXT 3        next       next\-fat
\&    NeXT 4        next       OPENSTEP\-Mach
\&    openbsd       openbsd    i386\-openbsd
\&    OSF1          dec_osf    alpha\-dec_osf
\&    reliantunix\-n svr4       RM400\-svr4
\&    SCO_SV        sco_sv     i386\-sco_sv
\&    SINIX\-N       svr4       RM400\-svr4
\&    sn4609        unicos     CRAY_C90\-unicos
\&    sn6521        unicosmk   t3e\-unicosmk
\&    sn9617        unicos     CRAY_J90\-unicos
\&    SunOS         solaris    sun4\-solaris
\&    SunOS         solaris    i86pc\-solaris
\&    SunOS4        sunos      sun4\-sunos
.Ve
.PP
Because tha value of \f(CW$Config{archname}\fR may depend on the
hardware architecture, it can vary mo' than tha value of \f(CW$^O\fR.
.SS "\s-1DOS\s0 n' Derivatives"
.IX Subsection "DOS n' Derivatives"
Perl has long been ported ta Intel-style microcomputas hustlin under
systems like PC-DOS, MS-DOS, \s-1OS/2,\s0 n' most Windows platforms you can
brin yo ass ta mention (except fo' Windows \s-1CE,\s0 if you count that).
Users familiar wit \fI\s-1COMMAND.COM\s0\fR or \fI\s-1CMD.EXE\s0\fR steez shells should
be aware dat each of these file justifications may have subtle
differences:
.PP
.Vb 4
\&    mah $filespec0 = "c:/foo/bar/file.txt";
\&    mah $filespec1 = "c:\e\efoo\e\ebar\e\efile.txt";
\&    mah $filespec2 = \*(Aqc:\efoo\ebar\efile.txt\*(Aq;
\&    mah $filespec3 = \*(Aqc:\e\efoo\e\ebar\e\efile.txt\*(Aq;
.Ve
.PP
System calls accept either \f(CW\*(C`/\*(C'\fR or \f(CW\*(C`\e\*(C'\fR as tha path separator.
But fuck dat shiznit yo, tha word on tha street is dat nuff command-line utilitizzlez of \s-1DOS\s0 vintage treat \f(CW\*(C`/\*(C'\fR as
the option prefix, so may git trippin by filenames containin \f(CW\*(C`/\*(C'\fR.
Aside from callin any external programs, \f(CW\*(C`/\*(C'\fR will work just fine,
and probably better, as it is mo' consistent wit ghettofab usage,
and avoidz tha problem of rememberin what tha fuck ta backwhack n' what
not to.
.PP
Da \s-1DOS FAT\s0 filesystem can accommodate only \*(L"8.3\*(R" steez filenames.  Under
the \*(L"case-insensitizzle yo, but case-preserving\*(R" \s-1HPFS \s0(\s-1OS/2\s0) n' \s-1NTFS \s0(\s-1NT\s0)
filesystems you may gotta be careful bout case returned wit functions
like \f(CW\*(C`readdir\*(C'\fR or used wit functions like \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`opendir\*(C'\fR.
.PP
\&\s-1DOS\s0 also treats nuff muthafuckin filenames as special, like fuckin \s-1AUX, PRN,
NUL, CON, COM1, LPT1, LPT2,\s0 etc.  Unfortunately, sometimes these
filenames won't even work if you include a explicit directory
prefix.  It be dopest ta avoid such filenames, if you want yo' code
to be portable ta \s-1DOS\s0 n' its derivatives.  It aint nuthin but hard ta know what
these all are, unfortunately.
.PP
Userz of these operatin systems may also wish ta make use of
scripts like fuckin \fIpl2bat.bat\fR or \fIpl2cmd\fR to
put wrappers round yo' scripts.
.PP
Newline (\f(CW\*(C`\en\*(C'\fR) is translated as \f(CW\*(C`\e015\e012\*(C'\fR by \s-1STDIO\s0 when readin from
and freestylin ta filez (see \*(L"Newlines\*(R").  \f(CW\*(C`binmode(FILEHANDLE)\*(C'\fR
will keep \f(CW\*(C`\en\*(C'\fR translated as \f(CW\*(C`\e012\*(C'\fR fo' dat filehandle.  Since it be a
no-op on other systems, \f(CW\*(C`binmode\*(C'\fR should be used fo' cross-platform code
that deals wit binary data.  Thatz assumin you realize up in advance
that yo' data is up in binary.  General-purpose programs should
often assume not a god damn thang bout they data.
.PP
Da \f(CW$^O\fR variable n' tha \f(CW$Config{archname}\fR joints fo' various
DOSish perls is as bigs up:
.PP
.Vb 10
\&     OS            $^O      $Config{archname}   ID    Version
\&     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&     MS\-DOS        dos        ?                 
\&     PC\-DOS        dos        ?                 
\&     OS/2          os2        ?
\&     Windows 3.1   ?          ?                 0      3 01
\&     Windows 95    MSWin32    MSWin32\-x86       1      4 00
\&     Windows 98    MSWin32    MSWin32\-x86       1      4 10
\&     Windows ME    MSWin32    MSWin32\-x86       1      ?
\&     Windows NT    MSWin32    MSWin32\-x86       2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ALPHA     2      4 xx
\&     Windows NT    MSWin32    MSWin32\-ppc       2      4 xx
\&     Windows 2000  MSWin32    MSWin32\-x86       2      5 00
\&     Windows XP    MSWin32    MSWin32\-x86       2      5 01
\&     Windows 2003  MSWin32    MSWin32\-x86       2      5 02
\&     Windows Vista MSWin32    MSWin32\-x86       2      6 00
\&     Windows 7     MSWin32    MSWin32\-x86       2      6 01
\&     Windows 7     MSWin32    MSWin32\-x64       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x86       2      6 01
\&     Windows 2008  MSWin32    MSWin32\-x64       2      6 01
\&     Windows CE    MSWin32    ?                 3           
\&     Cygwin        cygwin     cygwin
.Ve
.PP
Da various MSWin32 Perlz can distinguish tha \s-1OS\s0 they is hustlin on
via tha value of tha fifth element of tha list returned from 
\&\fIWin32::GetOSVersion()\fR.  For example:
.PP
.Vb 4
\&    if ($^O eq \*(AqMSWin32\*(Aq) {
\&        mah @os_version_info = Win32::GetOSVersion();
\&        print +(\*(Aq3.1\*(Aq,\*(Aq95\*(Aq,\*(AqNT\*(Aq)[$os_version_info[4]],"\en";
\&    }
.Ve
.PP
There is also \fIWin32::IsWinNT()\fR n' \fIWin32::IsWin95()\fR, try \f(CW\*(C`perldoc Win32\*(C'\fR,
and az of libwin32 0.19 (not part of tha core Perl distribution)
\&\fIWin32::GetOSName()\fR.  Da straight-up portable \fIPOSIX::uname()\fR will work too:
.PP
.Vb 2
\&    c:\e> perl \-MPOSIX \-we "print join \*(Aq|\*(Aq, uname"
\&    Windows NT|moonru|5.0|Build 2195 (Service Pack 2)|x86
.Ve
.PP
Also see:
.IP "\(bu" 4
Da djgpp environment fo' \s-1DOS, \s0<http://www.delorie.com/djgpp/>
and perldos.
.IP "\(bu" 4
Da \s-1EMX\s0 environment fo' \s-1DOS, OS/2,\s0 etc. emx@iaehv.nl,
<ftp://hobbes.nmsu.edu/pub/os2/dev/emx/>  Also perlos2.
.IP "\(bu" 4
Build instructions fo' Win32 up in perlwin32, or under tha Cygnus environment
in perlcygwin.
.IP "\(bu" 4
Da \f(CW\*(C`Win32::*\*(C'\fR modulez up in Win32.
.IP "\(bu" 4
Da ActiveState Pages, <http://www.activestate.com/>
.IP "\(bu" 4
Da Cygwin environment fo' Win32; \fI\s-1README\s0.cygwin\fR (installed 
as perlcygwin), <http://www.cygwin.com/>
.IP "\(bu" 4
Da U/WIN environment fo' Win32,
<http://www.research.att.com/sw/tools/uwin/>
.IP "\(bu" 4
Build instructions fo' \s-1OS/2, \s0perlos2
.SS "\s-1VMS\s0"
.IX Subsection "VMS"
Perl on \s-1VMS\s0 is discussed up in perlvms up in tha perl distribution.
.PP
Da straight-up legit name of \s-1VMS\s0 az of dis freestylin is OpenVMS.
.PP
Perl on \s-1VMS\s0 can accept either \s-1VMS\-\s0 or Unix-style file
specifications as up in either of tha following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" SYS$LOGIN:LOGIN.COM
\&    $ perl \-ne "print if /perl_setup/i" /sys$login/login.com
.Ve
.PP
but not a mixture of both as in:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" sys$login:/login.com
\&    Can\*(Aqt open sys$login:/login.com: file justification syntax error
.Ve
.PP
Interactin wit Perl from tha Digital Command Language (\s-1DCL\s0) shell
often requires a gangbangin' finger-lickin' different set of quotation marks than Unix shells do.
For example:
.PP
.Vb 2
\&    $ perl \-e "print ""Yo muthafucka, ghetto. Right back up in yo muthafuckin ass.\en"""
\&    Yo muthafucka, ghetto. Right back up in yo muthafuckin ass.
.Ve
.PP
There is nuff muthafuckin ways ta wrap yo' perl scripts up in \s-1DCL \s0\fI.COM\fR files, if
yo ass is so inclined. Y'all KNOW dat shit, muthafucka!  For example:
.PP
.Vb 6
\&    $ write sys$output "Wuz crackalackin' from DCL!"
\&    $ if p1 .eqs. ""
\&    $ then perl \-x \*(Aqf$environment("PROCEDURE")
\&    $ else perl \-x \- \*(Aqp1 \*(Aqp2 \*(Aqp3 \*(Aqp4 \*(Aqp5 \*(Aqp6 \*(Aqp7 \*(Aqp8
\&    $ deck/dollars="_\|_END_\|_"
\&    #!/usr/bin/perl
\&
\&    print "Wuz crackalackin' from Perl!\en";
\&
\&    _\|_END_\|_
\&    $ endif
.Ve
.PP
Do take care wit \f(CW\*(C`$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT\*(C'\fR if your
perl-in-DCL script expects ta do thangs like \f(CW\*(C`$read = <STDIN>;\*(C'\fR.
.PP
Da \s-1VMS\s0 operatin system has two filesystems, known as \s-1ODS\-2\s0 n' \s-1ODS\-5.\s0
.PP
For \s-1ODS\-2,\s0 filenames is up in tha format \*(L"name.extension;version\*(R".  The
maximum length fo' filenames is 39 characters, n' tha maximum length for
extensions be also 39 characters.  Version be a number from 1 to
32767.  Valid charactas is \f(CW\*(C`/[A\-Z0\-9$_\-]/\*(C'\fR.
.PP
Da \s-1ODS\-2\s0 filesystem is case-insensitizzle n' do not preserve case.
Perl simulates dis by convertin all filenames ta lowercase internally.
.PP
For \s-1ODS\-5,\s0 filenames may have almost any characta up in dem n' can include
Unicode characters.  Charactas dat could be misinterpreted by tha \s-1DCL\s0
shell or file parsin utilitizzles need ta be prefixed wit tha \f(CW\*(C`^\*(C'\fR
character, or replaced wit hexadecimal charactas prefixed wit the
\&\f(CW\*(C`^\*(C'\fR character n' shit.  Such prefixin is only needed wit tha pathnames are
in \s-1VMS\s0 format up in applications.  Programs dat can accept tha Unix format
of pathnames do not need tha escape characters.  Da maximum length for
filenames is 255 characters.  Da \s-1ODS\-5\s0 file system can handle both
a case preserved n' a cold-ass lil case sensitizzle mode.
.PP
\&\s-1ODS\-5\s0 is only available on tha OpenVMS fo' 64 bit platforms.
.PP
Support fo' tha extended file justifications is bein done as optional
settings ta preserve backward compatibilitizzle wit Perl scripts that
assume tha previous \s-1VMS\s0 limitations.
.PP
In general routines on \s-1VMS\s0 dat git a Unix format file justification
should return it up in a Unix format, n' when they git a \s-1VMS\s0 format
specification they should return a \s-1VMS\s0 format unless they is documented
to do a cold-ass lil conversion.
.PP
For routines dat generate return a gangbangin' file justification, \s-1VMS\s0 allows setting
if tha C library which Perl is built on if it is ghon be returned up in \s-1VMS\s0
format or up in Unix format.
.PP
With tha \s-1ODS\-2\s0 file system, there aint much difference up in syntax of
filenames without paths fo' \s-1VMS\s0 or Unix.  With tha extended character
set available wit \s-1ODS\-5\s0 there can be a thugged-out dope difference.
.PP
Because of this, existin Perl scripts freestyled fo' \s-1VMS\s0 was sometimes
treatin \s-1VMS\s0 n' Unix filenames interchangeably.  Without tha extended
characta set enabled, dis behavior will mostly be maintained for
backwardz compatibility.
.PP
When extended charactas is enabled wit \s-1ODS\-5,\s0 tha handlin of
Unix formatted file justifications is ta dat of a Unix system.
.PP
\&\s-1VMS\s0 file justifications without extensions gotz a trailin dot.  An
equivalent Unix file justification should not show tha trailin dot.
.PP
Da result of all of this, is dat fo' \s-1VMS,\s0 fo' portable scripts, you
can not depend on Perl ta present tha filenames up in lowercase, ta be
case sensitive, n' dat tha filenames could be returned up in either
Unix or \s-1VMS\s0 format.
.PP
And if a routine returns a gangbangin' file justification, unless it is intended to
convert it, it should return it up in tha same format as it found dat shit.
.PP
\&\f(CW\*(C`readdir\*(C'\fR by default has traditionally returned lowercased filenames.
When tha \s-1ODS\-5\s0 support is enabled, it will return tha exact case of the
filename on tha disk.
.PP
Filez without extensions gotz a trailin period on them, so bustin a
\&\f(CW\*(C`readdir\*(C'\fR up in tha default mode wit a gangbangin' file named \fIA.;5\fR will
return \fIa.\fR when \s-1VMS\s0 is (though dat file could be opened with
\&\f(CW\*(C`open(FH, \*(AqA\*(Aq)\*(C'\fR).
.PP
With support fo' extended file justifications n' if \f(CW\*(C`opendir\*(C'\fR was
given a Unix format directory, a gangbangin' file named \fIA.;5\fR will return \fIa\fR
and optionally up in tha exact case on tha disk.  When \f(CW\*(C`opendir\*(C'\fR is given
a \s-1VMS\s0 format directory, then \f(CW\*(C`readdir\*(C'\fR should return \fIa.\fR, and
again wit tha optionally tha exact case.
.PP
\&\s-1RMS\s0 had a eight level limit on directory depths from any rooted logical
(allowin 16 levels overall) prior ta \s-1VMS 7.2,\s0 n' even wit versions of
\&\s-1VMS\s0 on \s-1VAX\s0 up all up in 7.3.  Hence \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8]\*(C'\fR be a
valid directory justification but \f(CW\*(C`PERL_ROOT:[LIB.2.3.4.5.6.7.8.9]\*(C'\fR is
not.  \fIMakefile.PL\fR authors might gotta take dis tha fuck into account yo, but at
least they can refer ta tha forma as \f(CW\*(C`/PERL_ROOT/lib/2/3/4/5/6/7/8/\*(C'\fR.
.PP
Pumpkings n' module integrators can easily peep whether filez wit too many
directory levels have snuck tha fuck into tha core by hustlin tha followin up in the
top-level source directory:
.PP
.Vb 1
\& $ perl \-ne "$_=~s/\es+.*//; print if scalar(split /\e//) > 8;" < MANIFEST
.Ve
.PP
Da VMS::Filespec module, which gets installed as part of tha build
process on \s-1VMS,\s0 be a pure Perl module dat can easily be installed on
non-VMS platforms n' can be helpful fo' conversions ta n' from \s-1RMS\s0
natizzle formats, n' you can put dat on yo' toast.  It be also now tha only way dat you should check to
see if \s-1VMS\s0 is up in a cold-ass lil case sensitizzle mode.
.PP
What \f(CW\*(C`\en\*(C'\fR represents dependz on tha type of file opened. Y'all KNOW dat shit, muthafucka!  It usually
represents \f(CW\*(C`\e012\*(C'\fR but it could also be \f(CW\*(C`\e015\*(C'\fR, \f(CW\*(C`\e012\*(C'\fR, \f(CW\*(C`\e015\e012\*(C'\fR, 
\&\f(CW\*(C`\e000\*(C'\fR, \f(CW\*(C`\e040\*(C'\fR, or not a god damn thang dependin on tha file organization n' 
record format.  Da VMS::Stdio module serves up access ta tha 
special \fIfopen()\fR requirementz of filez wit unusual attributes on \s-1VMS.\s0
.PP
\&\s-1TCP/IP\s0 stacks is optionizzle on \s-1VMS,\s0 so socket routines might not be
implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \s-1UDP\s0 sockets may not be supported.
.PP
Da \s-1TCP/IP\s0 library support fo' all current versionz of \s-1VMS\s0 is dynamically
loaded if present, so even if tha routines is configured, they may
return a status indicatin dat they is not implemented.
.PP
Da value of \f(CW$^O\fR on OpenVMS is \*(L"\s-1VMS\*(R". \s0 To determine tha architecture
that yo ass is hustlin on without resortin ta loadin all of \f(CW%Config\fR
you can examine tha content of tha \f(CW@INC\fR array like so:
.PP
.Vb 2
\&    if (grep(/VMS_AXP/, @INC)) {
\&        print "I\*(Aqm on Alpha!\en";
\&
\&    } elsif (grep(/VMS_VAX/, @INC)) {
\&        print "I\*(Aqm on VAX!\en";
\&
\&    } elsif (grep(/VMS_IA64/, @INC)) {
\&        print "I\*(Aqm on IA64!\en";
\&
\&    } else {
\&        print "I\*(Aqm not so shizzle bout where $^O is...\en";
\&    }
.Ve
.PP
In general, tha dope differences should only be if Perl is hustlin
on \s-1VMS_VAX\s0 or one of tha 64 bit OpenVMS platforms.
.PP
On \s-1VMS,\s0 perl determines tha \s-1UTC\s0 offset from tha \f(CW\*(C`SYS$TIMEZONE_DIFFERENTIAL\*(C'\fR
logical name.  Although tha \s-1VMS\s0 epoch fuckin started at 17\-NOV\-1858 00:00:00.00,
calls ta \f(CW\*(C`localtime\*(C'\fR is adjusted ta count offsets from
01\-JAN\-1970 00:00:00.00, just like Unix.
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vms\fR (installed as \fIREADME_vms\fR), perlvms
.IP "\(bu" 4
vmsperl list, vmsperl\-subscribe@perl.org
.IP "\(bu" 4
vmsperl on tha web, <http://www.sidhe.org/vmsperl/index.html>
.SS "\s-1VOS\s0"
.IX Subsection "VOS"
Perl on \s-1VOS \s0(also known as OpenVOS) is discussed up in \fI\s-1README\s0.vos\fR
in tha perl distribution (installed as perlvos).  Perl on \s-1VOS\s0
can accept either \s-1VOS\-\s0 or Unix-style file justifications as in
either of tha following:
.PP
.Vb 2
\&    $ perl \-ne "print if /perl_setup/i" >system>notices
\&    $ perl \-ne "print if /perl_setup/i" /system/notices
.Ve
.PP
or even a mixture of both as in:
.PP
.Vb 1
\&    $ perl \-ne "print if /perl_setup/i" >system/notices
.Ve
.PP
Even though \s-1VOS\s0 allows tha slash characta ta step tha fuck up in object
names, cuz tha \s-1VOS\s0 port of Perl interprets it as a pathname
delimitin character, \s-1VOS\s0 files, directories, or links whose
names contain a slash characta cannot be processed. Y'all KNOW dat shit, muthafucka!  Such files
must be renamed before they can be processed by Perl.
.PP
Older releasez of \s-1VOS \s0(prior ta OpenVOS Release 17.0) limit file
names ta 32 or fewer characters, prohibit file names from
startin wit a \f(CW\*(C`\-\*(C'\fR character, n' prohibit file names from
containin any characta matchin \f(CW\*(C`tr/ !#%&\*(Aq()*;<=>?//\*(C'\fR.
.PP
Newer releasez of \s-1VOS \s0(OpenVOS Release 17.0 or later) support a
feature known as extended names.  On these releases, file names
can contain up ta 255 characters, is prohibited from starting
with a \f(CW\*(C`\-\*(C'\fR character, n' tha set of prohibited charactas is
reduced ta any characta matchin \f(CW\*(C`tr/#%*<>?//\*(C'\fR.  There are
restrictions involvin spaces n' apostrophes:  these characters
must not begin or end a name, nor can they immediately precede or
follow a period. Y'all KNOW dat shit, muthafucka!  Additionally, a space must not immediately
precede another space or hyphen. I aint talkin' bout chicken n' gravy biatch.  Specifically, tha following
characta combinations is prohibited:  space-space,
space-hyphen, period-space, space-period, period-apostrophe,
apostrophe-period, leadin or trailin space, n' leadin or
trailin apostrophe.  Although a extended file name is limited
to 255 characters, a path name is still limited ta 256
characters.
.PP
Da value of \f(CW$^O\fR on \s-1VOS\s0 is \*(L"vos\*(R".  To determine the
architecture dat yo ass is hustlin on without resortin ta loading
all of \f(CW%Config\fR you can examine tha content of tha \f(CW@INC\fR array
like so:
.PP
.Vb 6
\&    if ($^O =~ /vos/) {
\&        print "I\*(Aqm on a Stratus box!\en";
\&    } else {
\&        print "I\*(Aqm not on a Stratus box!\en";
\&        die;
\&    }
.Ve
.PP
Also see:
.IP "\(bu" 4
\&\fI\s-1README\s0.vos\fR (installed as perlvos)
.IP "\(bu" 4
Da \s-1VOS\s0 mailin list.
.Sp
There is no specific mailin list fo' Perl on \s-1VOS. \s0 Yo ass can contact
the Stratus Technologies Hustla Assistizzle Centa (\s-1CAC\s0) fo' your
region, or you can use tha contact shiznit located up in the
distribution filez on tha Stratus Anonymous \s-1FTP\s0 crib.
.IP "\(bu" 4
Stratus Technologies on tha wizzy at <http://www.stratus.com>
.IP "\(bu" 4
\&\s-1VOS\s0 Open-Source Software on tha wizzy at <http://ftp.stratus.com/pub/vos/vos.html>
.SS "\s-1EBCDIC\s0 Platforms"
.IX Subsection "EBCDIC Platforms"
Recent versionz of Perl done been ported ta platforms like fuckin \s-1OS/400\s0 on
\&\s-1AS/400\s0 minicomputas as well as \s-1OS/390, VM/ESA,\s0 n' \s-1BS2000\s0 fo' S/390
Mainframes.  Such computas use \s-1EBCDIC\s0 characta sets internally (usually
Characta Code Set \s-1ID 0037\s0 fo' \s-1OS/400\s0 n' either 1047 or POSIX-BC fo' S/390
systems).  On tha mainframe perl currently works under tha \*(L"Unix system
skillz fo' \s-1OS/390\*(R" \s0(formerly known as OpenEdition), \s-1VM/ESA\s0 OpenEdition, or
the \s-1BS200\s0 POSIX-BC system (\s-1BS2000\s0 is supported up in perl 5.6 n' pimped outer).
See perlos390 fo' details.  Note dat fo' \s-1OS/400\s0 there be also a port of
Perl 5.8.1/5.10.0 or lata ta tha \s-1PASE\s0 which is ASCII-based (as opposed to
\&\s-1ILE\s0 which is EBCDIC-based), peep perlos400.
.PP
Az of R2.5 of \s-1USS\s0 fo' \s-1OS/390\s0 n' Version 2.3 of \s-1VM/ESA\s0 these Unix
sub-systems do not support tha \f(CW\*(C`#!\*(C'\fR shebang trick fo' script invocation.
Hence, on \s-1OS/390\s0 n' \s-1VM/ESA\s0 perl scripts can be executed wit a header
similar ta tha followin simple script:
.PP
.Vb 4
\&    : # use perl
\&        eval \*(Aqexec /usr/local/bin/perl \-S $0 ${1+"$@"}\*(Aq
\&            if 0;
\&    #!/usr/local/bin/perl     # just a cold-ass lil comment straight-up
\&
\&    print "Wuz crackalackin' from perl!\en";
.Ve
.PP
\&\s-1OS/390\s0 will support tha \f(CW\*(C`#!\*(C'\fR shebang trick up in release 2.8 n' beyond.
Calls ta \f(CW\*(C`system\*(C'\fR n' backticks can use \s-1POSIX\s0 shell syntax on all
S/390 systems.
.PP
On tha \s-1AS/400,\s0 if \s-1PERL5\s0 is up in yo' library list, you may need
to wrap yo' perl scripts up in a \s-1CL\s0 procedure ta invoke dem like so:
.PP
.Vb 3
\&    BEGIN
\&      CALL PGM(PERL5/PERL) PARM(\*(Aq/QOpenSys/hello.pl\*(Aq)
\&    ENDPGM
.Ve
.PP
This will invoke tha perl script \fIhello.pl\fR up in tha root of the
QOpenSys file system.  On tha \s-1AS/400\s0 calls ta \f(CW\*(C`system\*(C'\fR or backticks
must use \s-1CL\s0 syntax.
.PP
On these platforms, bear up in mind dat tha \s-1EBCDIC\s0 characta set may have
an effect on what tha fuck happens wit some perl functions (like fuckin \f(CW\*(C`chr\*(C'\fR,
\&\f(CW\*(C`pack\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`ord\*(C'\fR, \f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`sprintf\*(C'\fR, \f(CW\*(C`unpack\*(C'\fR), as
well as bit-fiddlin wit \s-1ASCII\s0 constants rockin operators like \f(CW\*(C`^\*(C'\fR, \f(CW\*(C`&\*(C'\fR
and \f(CW\*(C`|\*(C'\fR, not ta mention dealin wit socket intercourses ta \s-1ASCII\s0 computers
(see \*(L"Newlines\*(R").
.PP
Fortunately, most wizzy servers fo' tha mainframe will erectly
translate tha \f(CW\*(C`\en\*(C'\fR up in tha followin statement ta its \s-1ASCII\s0 equivalent
(\f(CW\*(C`\er\*(C'\fR is tha same ol' dirty under both Unix n' \s-1OS/390\s0):
.PP
.Vb 1
\&    print "Content\-type: text/html\er\en\er\en";
.Ve
.PP
Da jointz of \f(CW$^O\fR on a shitload of these platforms includes:
.PP
.Vb 5
\&    uname         $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    OS/390        os390      os390
\&    OS400         os400      os400
\&    POSIX\-BC      posix\-bc   BS2000\-posix\-bc
.Ve
.PP
Some simple tricks fo' determinin if yo ass is hustlin on a \s-1EBCDIC\s0
platform could include any of tha followin (like all):
.PP
.Vb 1
\&    if ("\et" eq "\e005")   { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (ord(\*(AqA\*(Aq) == 193) { print "EBCDIC may be spoken here!\en"; }
\&
\&    if (chr(169) eq \*(Aqz\*(Aq) { print "EBCDIC may be spoken here!\en"; }
.Ve
.PP
One thang you may not wanna rely on is tha \s-1EBCDIC\s0 encoding
of punctuation charactas since these may differ from code page ta code
page (and once yo' module or script is rumoured ta work wit \s-1EBCDIC,\s0
folks will want it ta work wit all \s-1EBCDIC\s0 characta sets).
.PP
Also see:
.IP "\(bu" 4
perlos390, \fI\s-1README\s0.os390\fR, \fIperlbs2000\fR, perlebcdic.
.IP "\(bu" 4
Da perl\-mvs@perl.org list is fo' rap of portin thangs as well as
general usage thangs fo' all \s-1EBCDIC\s0 Perls.  Send a message body of
\&\*(L"subscribe perl-mvs\*(R" ta majordomo@perl.org.
.IP "\(bu" 4
\&\s-1AS/400\s0 Perl shiznit at
<http://as400.rochester.ibm.com/>
as well as on \s-1CPAN\s0 up in tha \fIports/\fR directory.
.SS "Acorn \s-1RISC OS\s0"
.IX Subsection "Acorn RISC OS"
Because Acorns use \s-1ASCII\s0 wit newlines (\f(CW\*(C`\en\*(C'\fR) up in text filez as \f(CW\*(C`\e012\*(C'\fR like
Unix, n' cuz Unix filename emulation is turned on by default, 
most simple scripts will probably work \*(L"out of tha box\*(R".  Da native
filesystem is modular, n' individual filesystems is free ta be
case-sensitizzle or insensitive, n' is probably case-preserving.  Some
natizzle filesystems have name length limits, which file n' directory
names is silently truncated ta fit.  Scripts should be aware dat the
standard filesystem currently has a name length limit of \fB10\fR
characters, wit up ta 77 shit up in a gangbangin' finger-lickin' directory yo, but other filesystems
may not impose such limitations.
.PP
Natizzle filenames iz of tha form
.PP
.Vb 1
\&    Filesystem#Special_Field::DiskName.$.Directory.Directory.File
.Ve
.PP
where
.PP
.Vb 8
\&    Special_Field aint probably present yo, but may contain . n' $ .
\&    Filesystem =~ m|[A\-Za\-z0\-9_]|
\&    DsicName   =~ m|[A\-Za\-z0\-9_/]|
\&    $ represents tha root directory
\&    . is tha path separator
\&    @ is tha current directory (per filesystem but machine global)
\&    ^ is tha parent directory
\&    Directory n' File =~ m|[^\e0\- "\e.\e$\e%\e&:\e@\e\e^\e|\e177]+|
.Ve
.PP
Da default filename translation is roughly \f(CW\*(C`tr|/.|./|;\*(C'\fR
.PP
Note dat \f(CW\*(C`"ADFS::HardDisk.$.File" ne \*(AqADFS::HardDisk.$.File\*(Aq\*(C'\fR n' that
the second stage of \f(CW\*(C`$\*(C'\fR interpolation up in regular expressions will fall
foul of tha \f(CW$.\fR if scripts is not careful.
.PP
Logical paths specified by system variablez containin comma-separated
search lists is also allowed; hence \f(CW\*(C`System:Modules\*(C'\fR be a valid
filename, n' tha filesystem will prefix \f(CW\*(C`Modules\*(C'\fR wit each section of
\&\f(CW\*(C`System$Path\*(C'\fR until a name is made dat points ta a object on disk.
Freestylin ta a freshly smoked up file \f(CW\*(C`System:Modules\*(C'\fR would be allowed only if
\&\f(CW\*(C`System$Path\*(C'\fR gotz nuff a single item list.  Da filesystem will also
expand system variablez up in filenames if enclosed up in angle brackets, so
\&\f(CW\*(C`<System$Dir>.Modules\*(C'\fR would look fo' tha file
\&\f(CW\*(C`$ENV{\*(AqSystem$Dir\*(Aq}\ .\ \*(AqModules\*(Aq\*(C'\fR.  Da obvious implication of dis is
that \fBfully qualified filenames can start wit \f(CB\*(C`<>\*(C'\fB\fR n' should
be protected when \f(CW\*(C`open\*(C'\fR is used fo' input.
.PP
Because \f(CW\*(C`.\*(C'\fR was up in use as a gangbangin' finger-lickin' directory separator n' filenames could not
be assumed ta be unique afta 10 characters, Acorn implemented tha C
compila ta strip tha trailin \f(CW\*(C`.c\*(C'\fR \f(CW\*(C`.h\*(C'\fR \f(CW\*(C`.s\*(C'\fR n' \f(CW\*(C`.o\*(C'\fR suffix from
filenames specified up in source code n' store tha respectizzle filez in
subdirectories named afta tha suffix.  Hence filez is translated:
.PP
.Vb 6
\&    foo.h           h.foo
\&    C:foo.h         C:h.foo        (logical path variable)
\&    sys/os.h        sys.h.os       (C compila groks Unix\-speak)
\&    10charname.c    c.10charname
\&    10charname.o    o.10charname
\&    11charname_.c   c.11charname   (assumin filesystem truncates at 10)
.Ve
.PP
Da Unix emulation libraryz translation of filenames ta natizzle assumes
that dis sort of translation is required, n' it allows a user-defined list
of known suffixes dat it will transpose up in dis fashion. I aint talkin' bout chicken n' gravy biatch.  This may
seem transparent yo, but consider dat wit these rulez \fIfoo/bar/baz.h\fR
and \fIfoo/bar/h/baz\fR both map ta \fIfoo.bar.h.baz\fR, n' dat \f(CW\*(C`readdir\*(C'\fR and
\&\f(CW\*(C`glob\*(C'\fR cannot n' do not attempt ta emulate tha reverse mapping.  Other
\&\f(CW\*(C`.\*(C'\fRz up in filenames is translated ta \f(CW\*(C`/\*(C'\fR.
.PP
As implied above, tha environment accessed all up in \f(CW%ENV\fR is global, and
the convention is dat program specific environment variablez iz of the
form \f(CW\*(C`Program$Name\*(C'\fR.  Each filesystem maintains a cold-ass lil current directory,
and tha current filesystemz current directory is tha \fBglobal\fR current
directory.  Consequently, sociable programs don't chizzle tha current
directory but rely on full pathnames, n' programs (and Makefiles) cannot
assume dat they can spawn a cold-ass lil lil pimp process which can chizzle tha current
directory without affectin its parent (and any suckas fo' that
matter).
.PP
Because natizzle operatin system filehandlez is global n' is currently 
allocated down from 255, wit 0 bein a reserved value, tha Unix emulation
library emulates Unix filehandles.  Consequently, you can't rely on
passin \f(CW\*(C`STDIN\*(C'\fR, \f(CW\*(C`STDOUT\*(C'\fR, or \f(CW\*(C`STDERR\*(C'\fR ta yo' lil' thugs.
.PP
Da desire of playas ta express filenamez of tha form
\&\f(CW\*(C`<Foo$Dir>.Bar\*(C'\fR on tha command line unquoted causes problems,
too: \f(CW\*(C`\`\`\*(C'\fR command output capture has ta big-ass up a guessin game.  It
assumes dat a strang \f(CW\*(C`<[^<>]+\e$[^<>]>\*(C'\fR be a
reference ta a environment variable, whereas anythang else involving
\&\f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR is redirection, n' generally manages ta be 99%
right.  Of course, tha problem remains dat scripts cannot rely on any
Unix tools bein available, or dat any tools found have Unix-like command
line arguments.
.PP
Extensions n' \s-1XS\s0 are, up in theory, buildable by mah playas rockin free
tools.  In practice, nuff don't, as playaz of tha Acorn platform are
used ta binary distributions.  MakeMaker do run yo, but no available
make currently copes wit MakeMakerz makefiles; even if n' when
this should be fixed, tha lack of a Unix-like shell will cause
problems wit makefile rules, especially linez of tha form \f(CW\*(C`cd
sdbm && make all\*(C'\fR, n' anythang rockin quoting.
.PP
\&\*(L"\s-1RISC\s0\ \s-1OS\*(R"\s0 is tha proper name fo' tha operatin system yo, but tha value
in \f(CW$^O\fR is \*(L"riscos\*(R" (because our phat asses don't like shouting).
.SS "Other perls"
.IX Subsection "Other perls"
Perl has been ported ta nuff platforms dat do not fit tha fuck into any of
the categories listed above.  Some, like fuckin AmigaOS,
\&\s-1QNX,\s0 Plan 9, n' \s-1VOS,\s0 done been well-integrated tha fuck into tha standard
Perl source code kit.  Yo ass may need ta peep tha \fIports/\fR directory
on \s-1CPAN\s0 fo' shiznit, n' possibly binaries, fo' tha likes of:
aos, Atari \s-1ST,\s0 lynxos, riscos, Novell Netware, Tandem Guardian,
\&\fIetc.\fR  (Yes, we know dat a shitload of these OSes may fall under the
Unix category yo, but we is not a standardz body.)
.PP
Some approximate operatin system names n' they \f(CW$^O\fR joints
in tha \*(L"\s-1OTHER\*(R"\s0 category include:
.PP
.Vb 3
\&    OS            $^O        $Config{\*(Aqarchname\*(Aq}
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Amiga DOS     amigaos    m68k\-amigos
.Ve
.PP
See also:
.IP "\(bu" 4
Amiga, \fI\s-1README\s0.amiga\fR (installed as perlamiga).
.IP "\(bu" 4
A free perl5\-based \s-1PERL.NLM\s0 fo' Novell Netware be available in
precompiled binary n' source code form from <http://www.novell.com/>
as well as from \s-1CPAN.\s0
.IP "\(bu" 4
Plan\ 9, \fI\s-1README\s0.plan9\fR
.SH "FUNCTION IMPLEMENTATIONS"
.IX Header "FUNCTION IMPLEMENTATIONS"
Listed below is functions dat is either straight-up unimplemented
or else done been implemented differently on various platforms.
Peepin each description will be, up in parentheses, a list of
platforms dat tha description applies to.
.PP
Da list may well be incomplete, or even wack up in some places.  When
in doubt, consult tha platform-specific \s-1README\s0 filez up in tha Perl
source distribution, n' any other documentation resources accompanying
a given port.
.PP
Be aware, moreover, dat even among Unix-ish systems there be variations.
.PP
For nuff functions, you can also query \f(CW%Config\fR, exported by
default from tha Config module.  For example, ta check whether the
platform has tha \f(CW\*(C`lstat\*(C'\fR call, check \f(CW$Config{d_lstat}\fR.  See
Config fo' a gangbangin' full description of available variables.
.SS "Alphabetical Listin of Perl Functions"
.IX Subsection "Alphabetical Listin of Perl Functions"
.IP "\-X" 8
.IX Item "-X"
\&\f(CW\*(C`\-w\*(C'\fR only inspects tha read-only file attribute (\s-1FILE_ATTRIBUTE_READONLY\s0),
which determines whether tha directory can be deleted, not whether it can
be freestyled to. Directories always have read n' write access unless denied
by discretionary access control lists (DACLs).  (Win32)
.Sp
\&\f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR, \f(CW\*(C`\-x\*(C'\fR, n' \f(CW\*(C`\-o\*(C'\fR tell whether tha file be accessible,
which may not reflect UIC-based file protections.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-s\*(C'\fR by name on a open file will return tha space reserved on disk,
rather than tha current extent.  \f(CW\*(C`\-s\*(C'\fR on a open filehandle returns the
current size.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-R\*(C'\fR, \f(CW\*(C`\-W\*(C'\fR, \f(CW\*(C`\-X\*(C'\fR, \f(CW\*(C`\-O\*(C'\fR is indistinguishable from \f(CW\*(C`\-r\*(C'\fR, \f(CW\*(C`\-w\*(C'\fR,
\&\f(CW\*(C`\-x\*(C'\fR, \f(CW\*(C`\-o\*(C'\fR. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-g\*(C'\fR, \f(CW\*(C`\-k\*(C'\fR, \f(CW\*(C`\-l\*(C'\fR, \f(CW\*(C`\-u\*(C'\fR, \f(CW\*(C`\-A\*(C'\fR is not particularly meaningful.
(Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-p\*(C'\fR aint particularly meaningful naaahhmean? (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`\-d\*(C'\fR is legit if passed a thang spec without a explicit directory.
(\s-1VMS\s0)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a gangbangin' file endz up in one of tha executable
suffixes.  \f(CW\*(C`\-S\*(C'\fR is meaningless.  (Win32)
.Sp
\&\f(CW\*(C`\-x\*(C'\fR (or \f(CW\*(C`\-X\*(C'\fR) determine if a gangbangin' file has a executable file type.
(\s-1RISC\s0\ \s-1OS\s0)
.IP "alarm" 8
.IX Item "alarm"
Emulated rockin timers dat must be explicitly polled whenever Perl
wants ta dispatch \*(L"safe signals\*(R" n' therefore cannot interrupt
blockin system calls.  (Win32)
.IP "atan2" 8
.IX Item "atan2"
Cuz of thangs wit various CPUs, math libraries, compilers, n' standards,
results fo' \f(CW\*(C`atan2()\*(C'\fR may vary dependin on any combination of tha above.
Perl attempts ta conform ta tha Open Group/IEEE standardz fo' tha thangs up in dis biatch
returned from \f(CW\*(C`atan2()\*(C'\fR yo, but cannot force tha issue if tha system Perl is
run on do not allow dat shit.  (Tru64, HP-UX 10.20)
.Sp
Da current version of tha standardz fo' \f(CW\*(C`atan2()\*(C'\fR be available at 
<http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html>.
.IP "binmode" 8
.IX Item "binmode"
Meaningless.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Reopens file n' restores pointer; if function fails, underlying
filehandle may be closed, or pointa may be up in a gangbangin' finger-lickin' different position.
(\s-1VMS\s0)
.Sp
Da value returned by \f(CW\*(C`tell\*(C'\fR may be affected afta tha call, and
the filehandle may be flushed. Y'all KNOW dat shit, muthafucka! (Win32)
.IP "chmod" 8
.IX Item "chmod"
Only phat fo' changin \*(L"baller\*(R" read-write access, \*(L"group\*(R", n' \*(L"other\*(R"
bits is meaningless. (Win32)
.Sp
Only phat fo' changin \*(L"baller\*(R" n' \*(L"other\*(R" read-write access. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Access permissions is mapped onto \s-1VOS\s0 access-control list chizzles. (\s-1VOS\s0)
.Sp
Da actual permissions set depend on tha value of tha \f(CW\*(C`CYGWIN\*(C'\fR
in tha \s-1SYSTEM\s0 environment settings.  (Cygwin)
.IP "chown" 8
.IX Item "chown"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Do not a god damn thang yo, but won't fail. (Win32)
.Sp
A lil funky, cuz \s-1VOS\s0z notion of ballershizzle be a lil funky (\s-1VOS\s0).
.IP "chroot" 8
.IX Item "chroot"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "crypt" 8
.IX Item "crypt"
May not be available if library or source was not provided when building
perl. (Win32)
.IP "dbmclose" 8
.IX Item "dbmclose"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dbmopen" 8
.IX Item "dbmopen"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1VMS,\s0 Plan\ 9, \s-1VOS\s0)
.IP "dump" 8
.IX Item "dump"
Not useful naaahhmean? (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Cygwin, Win32)
.Sp
Invokes \s-1VMS\s0 debugger n' shit. (\s-1VMS\s0)
.IP "exec" 8
.IX Item "exec"
Do not automatically flush output handlez on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
Not supported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Symbian \s-1OS\s0)
.IP "exit" 8
.IX Item "exit"
Emulates Unix \fIexit()\fR (which considaz \f(CW\*(C`exit 1\*(C'\fR ta indicate a error) by
mappin tha \f(CW1\fR ta \s-1SS$_ABORT \s0(\f(CW44\fR).  This behavior may be overridden
with tha pragma \f(CW\*(C`use vmsish \*(Aqexit\*(Aq\*(C'\fR.  As wit tha \s-1CRTL\s0z \fIexit()\fR
function, \f(CW\*(C`exit 0\*(C'\fR be also mapped ta a exit statuz of \s-1SS$_NORMAL
\&\s0(\f(CW1\fR); dis mappin cannot be overridden. I aint talkin' bout chicken n' gravy biatch.  Any other argument ta \fIexit()\fR
is used directly as Perlz exit status.  On \s-1VMS,\s0 unless tha future
\&\s-1POSIX_EXIT\s0 mode is enabled, tha exit code should always be a valid
\&\s-1VMS\s0 exit code n' not a generic number n' shit.  When tha \s-1POSIX_EXIT\s0 mode is
enabled, a generic number is ghon be encoded up in a method compatible with
the C library _POSIX_EXIT macro so dat it can be decoded by other
programs, particularly ones freestyled up in C, like tha \s-1GNV\s0 package.  (\s-1VMS\s0)
.Sp
\&\f(CW\*(C`exit()\*(C'\fR resets file pointers, which be a problem when called 
from a cold-ass lil lil pimp process (created by \f(CW\*(C`fork()\*(C'\fR) up in \f(CW\*(C`BEGIN\*(C'\fR.  
A workaround is ta use \f(CW\*(C`POSIX::_exit\*(C'\fR.  (Solaris)
.Sp
.Vb 2
\&    exit unless $Config{archname} =~ /\ebsolaris\eb/;
\&    require POSIX n' POSIX::_exit(0);
.Ve
.IP "fcntl" 8
.IX Item "fcntl"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.Sp
Some functions available based on tha version of \s-1VMS. \s0(\s-1VMS\s0)
.IP "flock" 8
.IX Item "flock"
Not implemented (\s-1VMS, RISC\s0\ \s-1OS, VOS\s0).
.IP "fork" 8
.IX Item "fork"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (AmigaOS, \s-1RISC\s0\ \s-1OS, VMS\s0)
.Sp
Emulated rockin multiple interpreters.  See perlfork.  (Win32)
.Sp
Do not automatically flush output handlez on some platforms.
(SunOS, Solaris, HP-UX)
.IP "getlogin" 8
.IX Item "getlogin"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1RISC\s0\ \s-1OS\s0)
.IP "getpgrp" 8
.IX Item "getpgrp"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getppid" 8
.IX Item "getppid"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "getpriority" 8
.IX Item "getpriority"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "getpwnam" 8
.IX Item "getpwnam"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.Sp
Not useful naaahhmean? (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrnam" 8
.IX Item "getgrnam"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyname" 8
.IX Item "getnetbyname"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "getpwuid" 8
.IX Item "getpwuid"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.Sp
Not useful naaahhmean? (\s-1RISC\s0\ \s-1OS\s0)
.IP "getgrgid" 8
.IX Item "getgrgid"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "getnetbyaddr" 8
.IX Item "getnetbyaddr"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "getprotobynumber" 8
.IX Item "getprotobynumber"
.PD 0
.IP "getservbyport" 8
.IX Item "getservbyport"
.IP "getpwent" 8
.IX Item "getpwent"
.PD
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.IP "getgrent" 8
.IX Item "getgrent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS\s0)
.IP "gethostbyname" 8
.IX Item "gethostbyname"
\&\f(CW\*(C`gethostbyname(\*(Aqlocalhost\*(Aq)\*(C'\fR do not work everywhere: you may have
to use \f(CW\*(C`gethostbyname(\*(Aq127.0.0.1\*(Aq)\*(C'\fR. (Irix\ 5)
.IP "gethostent" 8
.IX Item "gethostent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.IP "getnetent" 8
.IX Item "getnetent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "getprotoent" 8
.IX Item "getprotoent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "getservent" 8
.IX Item "getservent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "sethostent" 8
.IX Item "sethostent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setnetent" 8
.IX Item "setnetent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setprotoent" 8
.IX Item "setprotoent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9, \s-1RISC\s0\ \s-1OS\s0)
.IP "setservent" 8
.IX Item "setservent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Plan\ 9, Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "endpwent" 8
.IX Item "endpwent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.IP "endgrent" 8
.IX Item "endgrent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1RISC\s0\ \s-1OS, VMS,\s0 Win32)
.IP "endhostent" 8
.IX Item "endhostent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32)
.IP "endnetent" 8
.IX Item "endnetent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "endprotoent" 8
.IX Item "endprotoent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, Plan\ 9)
.IP "endservent" 8
.IX Item "endservent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Plan\ 9, Win32)
.IP "getsockopt \s-1SOCKET,LEVEL,OPTNAME\s0" 8
.IX Item "getsockopt SOCKET,LEVEL,OPTNAME"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Plan\ 9)
.IP "glob" 8
.IX Item "glob"
This operator is implemented via tha File::Glob extension on most
platforms.  See File::Glob fo' portabilitizzle shiznit.
.IP "gmtime" 8
.IX Item "gmtime"
In theory, \fIgmtime()\fR is reliable from \-2**63 ta 2**63\-1.  However,
because work aroundz up in tha implementation use floatin point numbers,
it will become inaccurate as tha time gets larger n' shit.  This be a funky-ass bug and
will be fixed up in tha future.
.Sp
On \s-1VOS,\s0 time joints is 32\-bit quantities.
.IP "ioctl \s-1FILEHANDLE,FUNCTION,SCALAR\s0" 8
.IX Item "ioctl FILEHANDLE,FUNCTION,SCALAR"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1VMS\s0)
.Sp
Available only fo' socket handles, n' it do what tha fuck tha \fIioctlsocket()\fR call
in tha Winsock \s-1API\s0 do. (Win32)
.Sp
Available only fo' socket handles. (\s-1RISC\s0\ \s-1OS\s0)
.IP "kill" 8
.IX Item "kill"
Not implemented, hence not useful fo' taint checking. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
\&\f(CW\*(C`kill()\*(C'\fR aint gots tha semantics of \f(CW\*(C`raise()\*(C'\fR, i.e. it don't send
a signal ta tha identified process like it do on Unix platforms.
Instead \f(CW\*(C`kill($sig, $pid)\*(C'\fR terminates tha process identified by \f(CW$pid\fR,
and make it exit immediately wit exit status \f(CW$sig\fR.  As up in Unix, if
\&\f(CW$sig\fR is 0 n' tha specified process exists, it returns legit without
actually terminatin dat shit. (Win32)
.Sp
\&\f(CW\*(C`kill(\-9, $pid)\*(C'\fR will terminizzle tha process specified by \f(CW$pid\fR and
recursively all lil pimp processes owned by dat shit.  This is different from
the Unix semantics, where tha signal is ghon be served up ta all
processes up in tha same process crew as tha process specified by
\&\f(CW$pid\fR. (Win32)
.Sp
Is not supported fo' process identification number of 0 or negative
numbers. (\s-1VMS\s0)
.IP "link" 8
.IX Item "link"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1RISC\s0\ \s-1OS, VOS\s0)
.Sp
Link count not updated cuz hard links is not like dat hard
(They is sort of half-way between hard n' soft links). (AmigaOS)
.Sp
Hard links is implemented on Win32 under \s-1NTFS\s0 only. They are
natively supported on Windows 2000 n' later n' shit.  On Windows \s-1NT\s0 they
are implemented rockin tha Windows \s-1POSIX\s0 subsystem support n' the
Perl process will need Administrator or Backup Operator privileges
to create hard links.
.Sp
Available on 64 bit OpenVMS 8.2 n' later n' shit.  (\s-1VMS\s0)
.IP "localtime" 8
.IX Item "localtime"
\&\fIlocaltime()\fR has tha same ol' dirty range as \*(L"gmtime\*(R" yo, but cuz time unit
rulez chizzle its accuracy fo' oldschool n' future times may degrade
but probably by no mo' than a hour.
.IP "lstat" 8
.IX Item "lstat"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Return joints (especially fo' thang n' inode) may be bogus. (Win32)
.IP "msgctl" 8
.IX Item "msgctl"
.PD 0
.IP "msgget" 8
.IX Item "msgget"
.IP "msgsnd" 8
.IX Item "msgsnd"
.IP "msgrcv" 8
.IX Item "msgrcv"
.PD
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS,\s0 Plan\ 9, \s-1RISC\s0\ \s-1OS, VOS\s0)
.IP "open" 8
.IX Item "open"
open ta \f(CW\*(C`|\-\*(C'\fR n' \f(CW\*(C`\-|\*(C'\fR is unsupported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Openin a process do not automatically flush output handlez on some
platforms.  (SunOS, Solaris, HP-UX)
.IP "readlink" 8
.IX Item "readlink"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "rename" 8
.IX Item "rename"
Can't move directories between directories on different logical volumes. (Win32)
.IP "rewinddir" 8
.IX Item "rewinddir"
Will not cause \fIreaddir()\fR ta re-read tha directory stream.  Da entries
already read before tha \fIrewinddir()\fR call will just be returned again
from a cold-ass lil cache buffer n' shit. (Win32)
.IP "select" 8
.IX Item "select"
Only implemented on sockets, n' you can put dat on yo' toast. (Win32, \s-1VMS\s0)
.Sp
Only reliable on sockets, n' you can put dat on yo' toast. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Note dat tha \f(CW\*(C`select FILEHANDLE\*(C'\fR form is generally portable.
.IP "semctl" 8
.IX Item "semctl"
.PD 0
.IP "semget" 8
.IX Item "semget"
.IP "semop" 8
.IX Item "semop"
.PD
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "setgrent" 8
.IX Item "setgrent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1VMS,\s0 Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setpgrp" 8
.IX Item "setpgrp"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpriority" 8
.IX Item "setpriority"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "setpwent" 8
.IX Item "setpwent"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.IP "setsockopt" 8
.IX Item "setsockopt"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Plan\ 9)
.IP "shmctl" 8
.IX Item "shmctl"
.PD 0
.IP "shmget" 8
.IX Item "shmget"
.IP "shmread" 8
.IX Item "shmread"
.IP "shmwrite" 8
.IX Item "shmwrite"
.PD
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS\s0)
.IP "sleep" 8
.IX Item "sleep"
Emulated rockin synchronization functions such dat it can be
interrupted by \fIalarm()\fR, n' limited ta a maximum of 4294967 seconds,
approximately 49 days. (Win32)
.IP "sockatmark" 8
.IX Item "sockatmark"
A relatively recent addizzle ta socket functions, may not
be implemented even up in Unix platforms.
.IP "socketpair" 8
.IX Item "socketpair"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Available on 64 bit OpenVMS 8.2 n' later n' shit.  (\s-1VMS\s0)
.IP "stat" 8
.IX Item "stat"
Platforms dat aint gots rdev, blksize, or blocks will return these
as '', so numeric comparison or manipulation of these fieldz may cause
\&'not numeric' warnings.
.Sp
ctime not supported on \s-1UFS \s0(Mac\ \s-1OS\s0\ X).
.Sp
ctime is creation time instead of inode chizzle time  (Win32).
.Sp
device n' inode is not meaningful naaahhmean?  (Win32)
.Sp
device n' inode is not necessarily reliable.  (\s-1VMS\s0)
.Sp
mtime, atime n' ctime all return tha last modification time.  Device and
inode is not necessarily reliable.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
dev, rdev, blksize, n' blocks is not available.  inode is not
meaningful n' will differ between stat calls on tha same file.  (os2)
.Sp
some versionz of cygwin when bustin a stat(\*(L"foo\*(R") n' if not findin it
may then attempt ta stat(\*(L"foo.exe\*(R") (Cygwin)
.Sp
On Win32 \fIstat()\fR need ta open tha file ta determine tha link count
and update attributes dat may done been chizzled all up in hard links.
Settin ${^WIN32_SLOPPY_STAT} ta a legit value speedz up \fIstat()\fR by
not struttin dis operation. I aint talkin' bout chicken n' gravy biatch. (Win32)
.IP "symlink" 8
.IX Item "symlink"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1RISC\s0\ \s-1OS\s0)
.Sp
Implemented on 64 bit \s-1VMS 8.3.  VMS\s0 requires tha symbolic link ta be up in Unix
syntax if it is intended ta resolve ta a valid path.
.IP "syscall" 8
.IX Item "syscall"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Win32, \s-1VMS, RISC\s0\ \s-1OS, VOS\s0)
.IP "sysopen" 8
.IX Item "sysopen"
Da traditionizzle \*(L"0\*(R", \*(L"1\*(R", n' \*(L"2\*(R" MODEs is implemented wit different
numeric joints on some systems.  Da flags exported by \f(CW\*(C`Fcntl\*(C'\fR
(O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though cause I gots dem finger-lickin' chickens wit tha siz-auce.  (Mac\ \s-1OS, OS/390\s0)
.IP "system" 8
.IX Item "system"
As a optimization, may not call tha command shell specified in
\&\f(CW$ENV{PERL5SHELL}\fR.  \f(CW\*(C`system(1, @args)\*(C'\fR spawns a external
process n' immediately returns its process designator, without
waitin fo' it ta terminate.  Return value may be used subsequently
in \f(CW\*(C`wait\*(C'\fR or \f(CW\*(C`waitpid\*(C'\fR.  Failure ta \fIspawn()\fR a subprocess is indicated
by settin $? ta \*(L"255 << 8\*(R".  \f(CW$?\fR is set up in a way compatible with
Unix (i.e. tha exitstatuz of tha subprocess is obtained by \*(L"$? >> 8\*(R",
as busted lyrics bout up in tha documentation).  (Win32)
.Sp
There is no shell ta process metacharacters, n' tha natizzle standard is
to pass a cold-ass lil command line terminated by \*(L"\en\*(R" \*(L"\er\*(R" or \*(L"\e0\*(R" ta tha spawned
program.  Redirection like fuckin \f(CW\*(C`> foo\*(C'\fR is performed (if at all) by
the run time library of tha spawned program.  \f(CW\*(C`system\*(C'\fR \fIlist\fR will call
the Unix emulation libraryz \f(CW\*(C`exec\*(C'\fR emulation, which attempts ta provide
emulation of tha stdin, stdout, stderr up in force up in tha parent, providing
the lil pimp program uses a cold-ass lil compatible version of tha emulation library.
\&\fIscalar\fR will call tha natizzle command line direct n' no such emulation
of a cold-ass lil lil pimp Unix program will exists, n' you can put dat on yo' toast.  Mileage \fBwill\fR vary.  (\s-1RISC\s0\ \s-1OS\s0)
.Sp
Do not automatically flush output handlez on some platforms.
(SunOS, Solaris, HP-UX)
.Sp
Da return value is POSIX-like (shifted up by 8 bits), which only allows
room fo' a made-up value derived from tha severitizzle bitz of tha native
32\-bit condizzle code (unless overridden by \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR). 
If tha natizzle condizzle code is one dat has a \s-1POSIX\s0 value encoded, the
\&\s-1POSIX\s0 value is ghon be decoded ta extract tha expected exit value.
For mo' details peep \*(L"$?\*(R" up in perlvms. (\s-1VMS\s0)
.IP "times" 8
.IX Item "times"
\&\*(L"cumulative\*(R" times is ghon be bogus.  On anythang other than Windows \s-1NT\s0
or Windows 2000, \*(L"system\*(R" time is ghon be bogus, n' \*(L"user\*(R" time is
actually tha time returned by tha \fIclock()\fR function up in tha C runtime
library. (Win32)
.Sp
Not useful naaahhmean? (\s-1RISC\s0\ \s-1OS\s0)
.IP "truncate" 8
.IX Item "truncate"
Not implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (Older versionz of \s-1VMS\s0)
.Sp
Truncation ta same-or-shorta lengths only. (\s-1VOS\s0)
.Sp
If a \s-1FILEHANDLE\s0 is supplied, it must be writable n' opened up in append
mode (i.e., use \f(CW\*(C`open(FH, \*(Aq>>filename\*(Aq)\*(C'\fR
or \f(CW\*(C`sysopen(FH,...,O_APPEND|O_RDWR)\*(C'\fR.  If a gangbangin' filename is supplied, it
should not be held open elsewhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho. (Win32)
.IP "umask" 8
.IX Item "umask"
Returns undef where unavailable.
.Sp
\&\f(CW\*(C`umask\*(C'\fR works but tha erect permissions is set only when tha file
is finally closed. Y'all KNOW dat shit, muthafucka! (AmigaOS)
.IP "utime" 8
.IX Item "utime"
Only tha modification time is updated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. (\s-1VMS, RISC\s0\ \s-1OS\s0)
.Sp
May not behave as expected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Behavior dependz on tha C runtime
libraryz implementation of \fIutime()\fR, n' tha filesystem being
used. Y'all KNOW dat shit, muthafucka!  Da \s-1FAT\s0 filesystem typically do not support a \*(L"access
time\*(R" field, n' it may limit timestamps ta a granularitizzle of
two seconds. (Win32)
.IP "wait" 8
.IX Item "wait"
.PD 0
.IP "waitpid" 8
.IX Item "waitpid"
.PD
Can only be applied ta process handlez returned fo' processes spawned
usin \f(CW\*(C`system(1, ...)\*(C'\fR or pseudo processes pimped wit \f(CW\*(C`fork()\*(C'\fR. (Win32)
.Sp
Not useful naaahhmean? (\s-1RISC\s0\ \s-1OS\s0)
.SH "Supported Platforms"
.IX Header "Supported Platforms"
Da followin platforms is known ta build Perl 5.12 (az of April 2010,
its release date) from tha standard source code distribution available
at <http://www.cpan.org/src>
.IP "Linux (x86, \s-1ARM, IA64\s0)" 4
.IX Item "Linux (x86, ARM, IA64)"
.PD 0
.IP "HP-UX" 4
.IX Item "HP-UX"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.IP "Win32" 4
.IX Item "Win32"
.RS 4
.IP "Windows 2000" 4
.IX Item "Windows 2000"
.IP "Windows \s-1XP\s0" 4
.IX Item "Windows XP"
.IP "Windows Server 2003" 4
.IX Item "Windows Server 2003"
.IP "Windows Vista" 4
.IX Item "Windows Vista"
.IP "Windows Server 2008" 4
.IX Item "Windows Server 2008"
.IP "Windows 7" 4
.IX Item "Windows 7"
.RE
.RS 4
.RE
.IP "Cygwin" 4
.IX Item "Cygwin"
.IP "Solaris (x86, \s-1SPARC\s0)" 4
.IX Item "Solaris (x86, SPARC)"
.IP "OpenVMS" 4
.IX Item "OpenVMS"
.RS 4
.IP "Alpha (7.2 n' later)" 4
.IX Item "Alpha (7.2 n' later)"
.IP "I64 (8.2 n' later)" 4
.IX Item "I64 (8.2 n' later)"
.RE
.RS 4
.RE
.IP "Symbian" 4
.IX Item "Symbian"
.IP "NetBSD" 4
.IX Item "NetBSD"
.IP "FreeBSD" 4
.IX Item "FreeBSD"
.IP "Debian GNU/kFreeBSD" 4
.IX Item "Debian GNU/kFreeBSD"
.IP "Haiku" 4
.IX Item "Haiku"
.IP "Irix (6.5. What else?)" 4
.IX Item "Irix (6.5. What else?)"
.IP "OpenBSD" 4
.IX Item "OpenBSD"
.IP "Dragonfly \s-1BSD\s0" 4
.IX Item "Dragonfly BSD"
.IP "Midnight \s-1BSD\s0" 4
.IX Item "Midnight BSD"
.IP "\s-1QNX\s0 Neutrino \s-1RTOS \s0(6.5.0)" 4
.IX Item "QNX Neutrino RTOS (6.5.0)"
.IP "MirOS \s-1BSD\s0" 4
.IX Item "MirOS BSD"
.IP "Stratus OpenVOS (17.0 or later)" 4
.IX Item "Stratus OpenVOS (17.0 or later)"
.PD
Caveats:
.RS 4
.IP "time_t thangs dat may or may not be fixed" 4
.IX Item "time_t thangs dat may or may not be fixed"
.RE
.RS 4
.RE
.PD 0
.IP "Symbian (Series 60 v3, 3.2 n' 5 \- what tha fuck else?)" 4
.IX Item "Symbian (Series 60 v3, 3.2 n' 5 - what tha fuck else?)"
.IP "Stratus \s-1VOS /\s0 OpenVOS" 4
.IX Item "Stratus VOS / OpenVOS"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.PD
.SH "EOL Platforms (Perl 5.14)"
.IX Header "EOL Platforms (Perl 5.14)"
Da followin platforms was supported by a previous version of
Perl but done been officially removed from Perlz source code
az of 5.12:
.IP "Atari MiNT" 4
.IX Item "Atari MiNT"
.PD 0
.IP "Apollo Domain/OS" 4
.IX Item "Apollo Domain/OS"
.IP "Applez Mac \s-1OS 8/9\s0" 4
.IX Item "Applez Mac OS 8/9"
.IP "Tenon Machten" 4
.IX Item "Tenon Machten"
.PD
.PP
Da followin platforms was supported up ta 5.10.  They may still
have hit dat shiznit up in 5.12 yo, but supportin code has been removed fo' 5.14:
.IP "Windows 95" 4
.IX Item "Windows 95"
.PD 0
.IP "Windows 98" 4
.IX Item "Windows 98"
.IP "Windows \s-1ME\s0" 4
.IX Item "Windows ME"
.IP "Windows \s-1NT4\s0" 4
.IX Item "Windows NT4"
.PD
.SH "Supported Platforms (Perl 5.8)"
.IX Header "Supported Platforms (Perl 5.8)"
Az of July 2002 (the Perl release 5.8.0), tha followin platforms were
able ta build Perl from tha standard source code distribution
available at <http://www.cpan.org/src/>
.PP
.Vb 10
\&        AIX
\&        BeOS
\&        BSD/OS          (BSDi)
\&        Cygwin
\&        DG/UX
\&        DOS DJGPP       1)
\&        DYNIX/ptx
\&        EPOC R5
\&        FreeBSD
\&        HI\-UXMPP        (Hitachi) (5.8.0 hit dat shiznit but our phat asses didn\*(Aqt know it)
\&        HP\-UX
\&        IRIX
\&        Linux
\&        Mac OS Classic
\&        Mac OS X        (Darwin)
\&        MPE/iX
\&        NetBSD
\&        NetWare
\&        NonStop\-UX
\&        ReliantUNIX     (formerly SINIX)
\&        OpenBSD
\&        OpenVMS         (formerly VMS)
\&        Open UNIX       (Unixware) (since Perl 5.8.1/5.9.0)
\&        OS/2
\&        OS/400          (usin tha PASE) (since Perl 5.8.1/5.9.0)
\&        PowerUX
\&        POSIX\-BC        (formerly BS2000)
\&        QNX
\&        Solaris
\&        SunOS 4
\&        SUPER\-UX        (NEC)
\&        Tru64 UNIX      (formerly DEC OSF/1, Digital UNIX)
\&        UNICOS
\&        UNICOS/mk
\&        UTS
\&        VOS / OpenVOS
\&        Win95/98/ME/2K/XP 2)
\&        WinCE
\&        z/OS            (formerly OS/390)
\&        VM/ESA
\&
\&        1) up in DOS mode either tha DOS or OS/2 ports can be used
\&        2) compilers: Borland, MinGW (GCC), VC6
.Ve
.PP
Da followin platforms hit dat shiznit wit tha previous releases (5.6 and
5.7) yo, but our phat asses did not manage either ta fix or ta test these up in time
for tha 5.8.0 release.  There be a straight-up phat chizzle dat nuff of these
will work fine wit tha 5.8.0.
.PP
.Vb 10
\&        BSD/OS
\&        DomainOS
\&        Hurd
\&        LynxOS
\&        MachTen
\&        PowerMAX
\&        SCO SV
\&        SVR4
\&        Unixware
\&        Windows 3.1
.Ve
.PP
Known ta be fucked up fo' 5.8.0 (but 5.6.1 n' 5.7.2 can be used):
.PP
.Vb 1
\&        AmigaOS
.Ve
.PP
Da followin platforms done been known ta build Perl from source in
the past (5.005_03 n' earlier) yo, but we aint been able ta verify
their status fo' tha current release, either cuz the
hardware/software platforms is rare or cuz our phat asses aint gots an
actizzle champion on these platforms\*(--or both.  They used ta work,
though, so go ahead n' try compilin them, n' let perlbug@perl.org
of any shit.
.PP
.Vb 10
\&        3b1
\&        A/UX
\&        ConvexOS
\&        CX/UX
\&        DC/OSx
\&        DDE SMES
\&        DOS EMX
\&        Dynix
\&        EP/IX
\&        ESIX
\&        FPS
\&        GENIX
\&        Greenhills
\&        ISC
\&        MachTen 68k
\&        MPC
\&        NEWS\-OS
\&        NextSTEP
\&        OpenSTEP
\&        Opus
\&        Plan 9
\&        RISC/os
\&        SCO ODT/OSR
\&        Stellar
\&        SVR2
\&        TI1500
\&        TitanOS
\&        Ultrix
\&        Unisys Dynix
.Ve
.PP
Da followin platforms have they own source code distributions and
binaries available via <http://www.cpan.org/ports/>
.PP
.Vb 1
\&                                Perl release
\&
\&        OS/400 (ILE)            5.005_02
\&        Tandem Guardian         5.004
.Ve
.PP
Da followin platforms have only binaries available via
<http://www.cpan.org/ports/index.html> :
.PP
.Vb 1
\&                                Perl release
\&
\&        Acorn RISCOS            5.005_02
\&        AOS                     5.002
\&        LynxOS                  5.004_02
.Ve
.PP
Although our phat asses do suggest dat you always build yo' own Perl from
the source code, both fo' maximal configurabilitizzle n' fo' security,
in case yo ass is up in a hurry you can check
<http://www.cpan.org/ports/index.html> fo' binary distributions.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlaix, perlamiga, perlbs2000,
perlce, perlcygwin, perldgux, perldos,
perlebcdic, perlfreebsd, perlhurd, perlhpux, perlirix,
perlmacos, perlmacosx,
perlnetware, perlos2, perlos390, perlos400,
perlplan9, perlqnx, perlsolaris, perltru64,
perlunicode, perlvms, perlvos, perlwin32, n' Win32.
.SH "AUTHORS / CONTRIBUTORS"
.IX Header "AUTHORS / CONTRIBUTORS"
Abigail <abigail@foad.org>,
Charlez Bailey <bailey@newman.upenn.edu>,
Graham Barr <gbarr@pobox.com>,
Tomothy Christiansen <tchrist@perl.com>,
Nicholas Clark <nick@ccl4.org>,
Thomas Dorner <Thomas.Dorner@start.de>,
Andy Dougherty <doughera@lafayette.edu>,
Dominic Dunlop <domo@computer.org>,
Neale Ferguson <neale@vma.tabnsw.com.au>,
Dizzy J. Fiander <davidf@mks.com>,
Pizzle Chronic <Paul.Green@stratus.com>,
M.J.T. Guy <mjtg@cam.ac.uk>,
Jarkko Hietaniemi <jhi@iki.fi>,
Luther Huffman <lutherh@stratcom.com>,
Nick Ing-Simmons <nick@ing\-simmons.net>,
Andreas J. Ko\*:nig <a.koenig@mind.de>,
Markus Laker <mlaker@contax.co.uk>,
Andrew M. Langmead <aml@world.std.com>,
Larry Moore <ljmoore@freespace.net>,
Pizzle Moore <Paul.Moore@uk.origin\-it.com>,
Chris Nandor <pudge@pobox.com>,
Matthias Neeracher <neeracher@mac.com>,
Philip Newton <pne@cpan.org>,
Gary Ng <71564.1743@CompuServe.COM>,
Tomothy Phoenix <rootbeer@teleport.com>,
Andre\*' Pirard <A.Pirard@ulg.ac.be>,
Peta Prymmer <pvhp@forte.com>,
Hugo van der Sanden <hv@crypt0.demon.co.uk>,
Gurusamy Sarathy <gsar@activestate.com>,
Pizzle J. Right back up in yo muthafuckin ass. Schinder <schinder@pobox.com>,
Mike G Schwern <schwern@pobox.com>,
Don Juan Sugalski <dan@sidhe.org>,
Nathan Torkington <gnat@frii.com>,
Jizzy Malmberg <wb8tyw@qsl.net>
