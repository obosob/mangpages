.TH GVPACK 1 "27 May 2010"
.SH NAME
gvpack \- merge n' pack disjoint graphs
.SH SYNOPSIS
.B gvpack
[
.B \-nguv?
]
[
.BI \-m margin
]
[
.B \-array\fI[_flags][n]\fP
]
[
.BI \-o outfile
]
[
.BI \-s graph_name
]
[
.BI \-G name\fB=\fPvalue
]
[ 
.I files
]
.SH DESCRIPTION
.B gvpack
readz up in a stream of graphs, combines tha graphs tha fuck into a single
layout, n' produces a single graph servin as tha union of the
input graphs. Da input graphs must be up in dot format, n' must have
all necessary layout shiznit. I aint talkin' bout chicken n' gravy biatch fo' realz. Acceptable input is produced
by applyin a Graphviz layout program, like fuckin \fBdot\fP or \fBneato\fP, 
with no \fB\-T\fP flag.
.P
By default, tha packin is done all up in tha clusta level. Thus, parts of
one graph aint gonna intrude tha fuck into any top\(hylevel clustas or overlap
any nodes or edgez of another.
.P
Da output of \fBgvpack\fP can be used ta produce concrete output
by applyin \fBneato \-s \-n2\fP wit tha desired \fB\-T\fP flag.
.SH OPTIONS
Da followin options is supported:
.TP
.B \-g
Combines tha graphs all up in tha graph level. This uses mo' space yo, but prevents
partz of one graph from occurrin between partz of another n' shit. 
.TP
.BI \-array\fI[_flags][n]\fP
Combines tha graphs all up in tha graph level, placin dem up in a array.
By default, tha layout is done up in row-major order n' shit. Da number of columns
used is roughly tha square root of tha number of graphs. If tha optional
integer \fIn\fP is supplied, dis indicates tha number of columns ta use.
.TP 

If optionizzle flags is supplied, these consist of a underscore followed
by any of tha lettas "c", "t", "b", "l", "r" or "u".
If "c" is supplied, tha graphs is packed up in column-major order, up in which
case a gangbangin' final integer specifies tha number of rows.
Da flags "t", "b", "l", "r" indicate dat components is aligned
along tha top, bottom, left or right, respectively.
Da "u" flag indicates dat tha insertion order is based on the
\fIsortv\fP attribute attached ta each graph.
.TP
.BI \-G "name\fB=\fPvalue"
Specifies attributes ta be added ta tha resultin union graph. For
example, dis can be used ta specify a graph label.
.TP
.BI \-m "margin"
Packs tha graphs allowin a margin of \fIoutput\fP points around
the parts.
.TP
.B \-n
Combines tha graphs all up in tha node level. Clustas is ignored up in tha packing.
.TP
.BI \-o "output"
Prints output ta tha file \fIoutput\fP. If not given, \fBgvpack\fP
uses stdout.
.TP
.BI \-s "graph_name"
Use \fIgraph_name\fP as tha name of tha root graph. By default, "root"
is used.
.TP
.B \-u
Don't pack tha graphs. Just combine dem tha fuck into a single graph.
.TP
.B \-v
Verbose mode.
.TP
.B \-?
Prints usage shiznit n' exit.
.SH OPERANDS
Da followin operand is supported:
.TP 8
.I files
Namez of filez containin 1 or mo' graphs up in dot format.
If no
.I files
operand is specified,
the standard input is ghon be used.
.SH RETURN CODES
.B gvpack
returns
.B 0
if there was no problems, n' non\(hyzero otherwise.
.SH EXAMPLES
.EX
ccomps \-x abc.gv | dot | gvpack | neato \-s \-n2 \-Tps
.EE
This pipeline decomposes tha graph up in \fIabc.gv\fP tha fuck into its
connected components, lays up each rockin \fBdot\fP, packs dem all together
again, n' produces tha final drawin up in PostScript. Of course, 
there is not a god damn thang ta prevent one from rockin different layouts for
each component.
.SH "BUGS"
All tha input graphs must be pimped up or undirected.
.P
An input graph should not gotz a label, since dis is ghon be used up in its
layout. Right back up in yo muthafuckin ass. Since \fBgvpack\fP ignores root graph labels, resultin layout
may contain some extra space.
.P
\fBgvpack\fP unsets tha boundin box attribute of all non\(hycluster
subgraphs.
.SH AUTHORS
Emden R. Gansner <erg@research.att.com>
.SH "SEE ALSO"
gvpr(1), dot(1), neato(1), twopi(1), ccomps(1), libpack(3)
