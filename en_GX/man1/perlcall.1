.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLCALL 1"
.TH PERLCALL 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlcall \- Perl callin conventions from C
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da purpose of dis document is ta show you how tha fuck ta booty-call Perl subroutines
directly from C, i.e., how tha fuck ta write \fIcallbacks\fR.
.PP
Apart from discussin tha C intercourse provided by Perl fo' writing
callbacks tha document uses a seriez of examplez ta show how tha fuck the
interface straight-up works up in practice.  In addizzle some steez for
codin callbacks is covered.
.PP
Examplez where callbacks is necessary include
.IP "\(bu" 5
An Error Handlez
.Sp
Yo ass have pimped a \s-1XSUB\s0 intercourse ta a applicationz C \s-1API.\s0
.Sp
A fairly common feature up in applications is ta allow you ta define a C
function dat is ghon be called whenever suttin' nasty occurs. What we
wanna is ta be able ta specify a Perl subroutine dat will be
called instead.
.IP "\(bu" 5
An Event-Driven Program
.Sp
Da funky-ass example of where callbacks is used is when freestylin an
event driven program, like fuckin fo' a X11 application. I aint talkin' bout chicken n' gravy biatch.  In dis case
you regista functions ta be called whenever specific events occur,
e.g., a mouse button is pressed, tha cursor moves tha fuck into a window or a
menu item is selected.
.PP
Although tha steez busted lyrics bout here is applicable when embedding
Perl up in a C program, dis aint tha primary goal of dis document.
There is other details dat must be considered n' is specific to
embeddin Perl. For details on embeddin Perl up in C refer to
perlembed.
.PP
Before you launch yo ass head first tha fuck into tha rest of dis document,
it would be a phat scam ta have read tha followin two documents\*(--perlxs
and perlguts.
.SH "THE CALL_ FUNCTIONS"
.IX Header "THE CALL_ FUNCTIONS"
Although dis shiznit is easier ta explain rockin examples, you first need
be aware of all dem blingin definitions.
.PP
Perl has a fuckin shitload of C functions dat allow you ta booty-call Perl
subroutines.  They are
.PP
.Vb 4
\&    I32 call_sv(SV* sv, I32 flags);
\&    I32 call_pv(char *subname, I32 flags);
\&    I32 call_method(char *methname, I32 flags);
\&    I32 call_argv(char *subname, I32 flags, char **argv);
.Ve
.PP
Da key function is \fIcall_sv\fR.  All tha other functions are
fairly simple wrappers which make it easier ta booty-call Perl subroutines in
special cases fo' realz. At tha end of tha dizzle they will all call \fIcall_sv\fR
to invoke tha Perl subroutine.
.PP
All tha \fIcall_*\fR functions gotz a \f(CW\*(C`flags\*(C'\fR parameta which is
used ta pass a lil' bit mask of options ta Perl.  This bit mask operates
identically fo' each of tha functions.  Da settings available up in the
bit mask is discussed up in \*(L"\s-1FLAG VALUES\*(R"\s0.
.PP
Each of tha functions will now be discussed up in turn.
.IP "call_sv" 5
.IX Item "call_sv"
\&\fIcall_sv\fR takes two parameters. Da first, \f(CW\*(C`sv\*(C'\fR, be a SV*.
This allows you ta specify tha Perl subroutine ta be called either as a
C strang (which has first been converted ta a \s-1SV\s0) or a reference ta a
subroutine. Da section, \fIUsin call_sv\fR, shows how tha fuck you can make
use of \fIcall_sv\fR.
.IP "call_pv" 5
.IX Item "call_pv"
Da function, \fIcall_pv\fR, is similar ta \fIcall_sv\fR except it
expects its first parameta ta be a C char* which identifies tha Perl
subroutine you wanna call, e.g., \f(CW\*(C`call_pv("fred", 0)\*(C'\fR.  If the
subroutine you wanna call is up in another package, just include the
package name up in tha string, e.g., \f(CW"pkg::fred"\fR.
.IP "call_method" 5
.IX Item "call_method"
Da function \fIcall_method\fR is used ta booty-call a method from a Perl
class.  Da parameta \f(CW\*(C`methname\*(C'\fR correspondz ta tha name of tha method
to be called. Y'all KNOW dat shit, muthafucka!  Note dat tha class dat tha method belongs ta is passed
on tha Perl stack rather than up in tha parameta list. This class can be
either tha name of tha class (for a static method) or a reference ta an
object (for a virtual method).  See perlobj fo' mo' shiznit on
static n' virtual methodz n' \*(L"Usin call_method\*(R" fo' a example
of rockin \fIcall_method\fR.
.IP "call_argv" 5
.IX Item "call_argv"
\&\fIcall_argv\fR calls tha Perl subroutine specified by tha C string
stored up in tha \f(CW\*(C`subname\*(C'\fR parameter n' shit. Well shiiiit, it also takes tha usual \f(CW\*(C`flags\*(C'\fR
parameter n' shit.  Da final parameter, \f(CW\*(C`argv\*(C'\fR, consistz of a NULL-terminated
list of C strings ta be passed as parametas ta tha Perl subroutine.
See \fIUsin call_argv\fR.
.PP
All tha functions return a integer n' shit. This be a cold-ass lil count of tha number of
items returned by tha Perl subroutine. Da actual shit returned by the
subroutine is stored on tha Perl stack.
.PP
As a general rule you should \fIalways\fR check tha return value from
these functions.  Even if yo ass is expectin only a particular number of
values ta be returned from tha Perl subroutine, there is not a god damn thang to
stop one of mah thugs from bustin suttin' unexpected\*(--don't say you haven't
been warned.
.SH "FLAG VALUES"
.IX Header "FLAG VALUES"
Da \f(CW\*(C`flags\*(C'\fR parameta up in all tha \fIcall_*\fR functions is one of G_VOID,
G_SCALAR, or G_ARRAY, which indicate tha call context, \s-1OR\s0'ed together
with a lil' bit mask of any combination of tha other G_* symbols defined below.
.SS "G_VOID"
.IX Subsection "G_VOID"
Calls tha Perl subroutine up in a void context.
.PP
This flag has 2 effects:
.IP "1." 5
It indicates ta tha subroutine bein called dat it is executin in
a void context (if it executes \fIwantarray\fR tha result is ghon be the
undefined value).
.IP "2." 5
It ensures dat not a god damn thang is straight-up returned from tha subroutine.
.PP
Da value returned by tha \fIcall_*\fR function indicates how tha fuck many
items done been returned by tha Perl subroutine\*(--in dis case it will
be 0.
.SS "G_SCALAR"
.IX Subsection "G_SCALAR"
Calls tha Perl subroutine up in a scalar context.  This is tha default
context flag settin fo' all tha \fIcall_*\fR functions.
.PP
This flag has 2 effects:
.IP "1." 5
It indicates ta tha subroutine bein called dat it is executin up in a
scalar context (if it executes \fIwantarray\fR tha result is ghon be false).
.IP "2." 5
It ensures dat only a scalar is straight-up returned from tha subroutine.
Da subroutine can, of course,  ignore tha \fIwantarray\fR n' return a
list anyway. If so, then only tha last element of tha list will be
returned.
.PP
Da value returned by tha \fIcall_*\fR function indicates how tha fuck many
items done been returned by tha Perl subroutine \- up in dis case it will
be either 0 or 1.
.PP
If 0, then you have specified tha G_DISCARD flag.
.PP
If 1, then tha item straight-up returned by tha Perl subroutine will be
stored on tha Perl stack \- tha section \fIReturnin a Scalar\fR shows how
to access dis value on tha stack.  Remember dat regardless of how
many shit tha Perl subroutine returns, only tha last one will be
accessible from tha stack \- be thinkin of tha case where only one value is
returned as bein a list wit only one element.  Any other shit that
were returned aint gonna exist by tha time control returns from the
\&\fIcall_*\fR function. I aint talkin' bout chicken n' gravy biatch.  Da section \fIReturnin a list up in a scalar
context\fR shows a example of dis behavior.
.SS "G_ARRAY"
.IX Subsection "G_ARRAY"
Calls tha Perl subroutine up in a list context.
.PP
As wit G_SCALAR, dis flag has 2 effects:
.IP "1." 5
It indicates ta tha subroutine bein called dat it is executin up in a
list context (if it executes \fIwantarray\fR tha result is ghon be true).
.IP "2." 5
It ensures dat all shit returned from tha subroutine will be
accessible when control returns from tha \fIcall_*\fR function.
.PP
Da value returned by tha \fIcall_*\fR function indicates how tha fuck many
items done been returned by tha Perl subroutine.
.PP
If 0, then you have specified tha G_DISCARD flag.
.PP
If not 0, then it is ghon be a cold-ass lil count of tha number of shit returned by
the subroutine. These shit is ghon be stored on tha Perl stack.  The
section \fIReturnin a list of joints\fR gives a example of rockin the
G_ARRAY flag n' tha mechanics of accessin tha returned shit from the
Perl stack.
.SS "G_DISCARD"
.IX Subsection "G_DISCARD"
By default, tha \fIcall_*\fR functions place tha shit returned from
by tha Perl subroutine on tha stack.  If yo ass is not interested in
these items, then settin dis flag will make Perl git rid of them
automatically fo' yo thugged-out ass.  Note dat it is still possible ta indicate a
context ta tha Perl subroutine by rockin either G_SCALAR or G_ARRAY.
.PP
If you do not set dis flag then it is \fIvery\fR blingin dat you make
sure dat any temporaries (i.e., parametas passed ta tha Perl
subroutine n' joints returned from tha subroutine) is disposed of
yo ass.  Da section \fIReturnin a Scalar\fR gives detailz of how tha fuck to
dispose of these temporaries explicitly n' tha section \fIUsin Perl to
dispose of temporaries\fR discusses tha specific circumstances where you
can ignore tha problem n' let Perl deal wit it fo' yo thugged-out ass.
.SS "G_NOARGS"
.IX Subsection "G_NOARGS"
Whenever a Perl subroutine is called rockin one of tha \fIcall_*\fR
functions, it be assumed by default dat parametas is ta be passed to
the subroutine.  If yo ass is not passin any parametas ta tha Perl
subroutine, you can save a lil' bit of time by settin dis flag.  It has
the effect of not bustin tha \f(CW@_\fR array fo' tha Perl subroutine.
.PP
Although tha functionalitizzle provided by dis flag may seem
straightforward, it should be used only if there be a phat reason ta do
so.  Da reason fo' bein cautious is that, even if you have specified
the G_NOARGS flag, it is still possible fo' tha Perl subroutine that
has been called ta be thinkin dat you have passed it parameters.
.PP
In fact, what tha fuck can happen is dat tha Perl subroutine you have called
can access tha \f(CW@_\fR array from a previous Perl subroutine.  This will
occur when tha code dat is executin tha \fIcall_*\fR function has
itself been called from another Perl subroutine. Da code below
illustrates this
.PP
.Vb 2
\&    sub fred
\&      { print "@_\en"  }
\&
\&    sub joe
\&      { &fred }
\&
\&    &joe(1,2,3);
.Ve
.PP
This will print
.PP
.Vb 1
\&    1 2 3
.Ve
.PP
What has happened is dat \f(CW\*(C`fred\*(C'\fR accesses tha \f(CW@_\fR array which
belongs ta \f(CW\*(C`joe\*(C'\fR.
.SS "G_EVAL"
.IX Subsection "G_EVAL"
It be possible fo' tha Perl subroutine yo ass is callin ta terminate
abnormally, e.g., by callin \fIdie\fR explicitly or by not actually
existing.  By default, when either of these events occurs, the
process will terminizzle immediately.  If you wanna trap this
type of event, specify tha G_EVAL flag.  It will put a \fIeval { }\fR
around tha subroutine call.
.PP
Whenever control returns from tha \fIcall_*\fR function you need to
check tha \f(CW$@\fR variable as you would up in a aiiight Perl script.
.PP
Da value returned from tha \fIcall_*\fR function is dependent on
what other flags done been specified n' whether a error has
occurred. Y'all KNOW dat shit, muthafucka!  Here is all tha different cases dat can occur:
.IP "\(bu" 5
If tha \fIcall_*\fR function returns normally, then tha value
returned be as specified up in tha previous sections.
.IP "\(bu" 5
If G_DISCARD is specified, tha return value will always be 0.
.IP "\(bu" 5
If G_ARRAY is specified \fIand\fR a error has occurred, tha return value
will always be 0.
.IP "\(bu" 5
If G_SCALAR is specified \fIand\fR a error has occurred, tha return value
will be 1 n' tha value on tha top of tha stack is ghon be \fIundef\fR. This
means dat if you have already detected tha error by checkin \f(CW$@\fR and
you want tha program ta continue, you must remember ta pop tha \fIundef\fR
from tha stack.
.PP
See \fIUsin G_EVAL\fR fo' details on rockin G_EVAL.
.SS "G_KEEPERR"
.IX Subsection "G_KEEPERR"
Usin tha G_EVAL flag busted lyrics bout above will always set \f(CW$@\fR: clearing
it if there was no error, n' settin it ta describe tha error if there
was a error up in tha called code.  This is what tha fuck you want if yo' intention
is ta handle possible errors yo, but sometimes you just wanna trap errors
and stop dem interferin wit tha rest of tha program.
.PP
This scenario will mostly be applicable ta code dat is meant ta be called
from within destructors, asynchronous callbacks, n' signal handlezs.
In such thangs, where tha code bein called has lil relation ta the
surroundin dynamic context, tha main program need ta be insulated from
errors up in tha called code, even if they can't be handled intelligently.
It may also be useful ta do dis wit code fo' \f(CW\*(C`_\|_DIE_\|_\*(C'\fR or \f(CW\*(C`_\|_WARN_\|_\*(C'\fR
hooks, n' \f(CW\*(C`tie\*(C'\fR functions.
.PP
Da G_KEEPERR flag is meant ta be used up in conjunction wit G_EVAL in
\&\fIcall_*\fR functions dat is used ta implement such code, or with
\&\f(CW\*(C`eval_sv\*(C'\fR.  This flag has no effect on tha \f(CW\*(C`call_*\*(C'\fR functions when
G_EVAL aint used.
.PP
When G_KEEPERR is used, any error up in tha called code will terminizzle the
call as usual, n' tha error aint gonna propagate beyond tha call (as usual
for G_EVAL) yo, but it aint gonna go tha fuck into \f(CW$@\fR.  Instead tha error will be
converted tha fuck into a warning, prefixed wit tha strang \*(L"\et(in cleanup)\*(R".
This can be disabled rockin \f(CW\*(C`no warnings \*(Aqmisc\*(Aq\*(C'\fR.  If there is no error,
\&\f(CW$@\fR aint gonna be cleared.
.PP
Note dat tha G_KEEPERR flag do not propagate tha fuck into inner evals; these
may still set \f(CW$@\fR.
.PP
Da G_KEEPERR flag was introduced up in Perl version 5.002.
.PP
See \fIUsin G_KEEPERR\fR fo' a example of a thang dat warrants the
use of dis flag.
.SS "Determinin tha Context"
.IX Subsection "Determinin tha Context"
As mentioned above, you can determine tha context of tha currently
executin subroutine up in Perl wit \fIwantarray\fR.  Da equivalent test
can be made up in C by rockin tha \f(CW\*(C`GIMME_V\*(C'\fR macro, which returns
\&\f(CW\*(C`G_ARRAY\*(C'\fR if you done been called up in a list context, \f(CW\*(C`G_SCALAR\*(C'\fR if
in a scalar context, or \f(CW\*(C`G_VOID\*(C'\fR if up in a void context (i.e., the
return value aint gonna be used).  An olda version of dis macro is
called \f(CW\*(C`GIMME\*(C'\fR; up in a void context it returns \f(CW\*(C`G_SCALAR\*(C'\fR instead of
\&\f(CW\*(C`G_VOID\*(C'\fR.  An example of rockin tha \f(CW\*(C`GIMME_V\*(C'\fR macro is shown in
section \fIUsin \s-1GIMME_V\s0\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Enough of tha definizzle talk! Letz have all dem examples.
.PP
Perl serves up nuff macros ta assist up in accessin tha Perl stack.
Wherever possible, these macros should always be used when interfacing
to Perl internals.  Our thugged-out asses hope dis should make tha code less vulnerable
to any chizzlez made ta Perl up in tha future.
.PP
Another point worth notin is dat up in tha straight-up original gangsta seriez of examplez I
have made use of only tha \fIcall_pv\fR function. I aint talkin' bout chicken n' gravy biatch.  This has been done
to keep tha code simpla n' ease you tha fuck into tha topic.  Wherever
possible, if tha chizzle is between rockin \fIcall_pv\fR and
\&\fIcall_sv\fR, you should always try ta use \fIcall_sv\fR.  See
\&\fIUsin call_sv\fR fo' details.
.SS "No Parameters, Nothang Returned"
.IX Subsection "No Parameters, Nothang Returned"
This first trivial example will call a Perl subroutine, \fIPrintUID\fR, to
print up tha \s-1UID\s0 of tha process.
.PP
.Vb 4
\&    sub PrintUID
\&    {
\&        print "UID is $<\en";
\&    }
.Ve
.PP
and here be a C function ta booty-call it
.PP
.Vb 4
\&    static void
\&    call_PrintUID()
\&    {
\&        dSP;
\&
\&        PUSHMARK(SP);
\&        call_pv("PrintUID", G_DISCARD|G_NOARGS);
\&    }
.Ve
.PP
Simple, eh?
.PP
A few points ta note bout dis example:
.IP "1." 5
Ignore \f(CW\*(C`dSP\*(C'\fR n' \f(CW\*(C`PUSHMARK(SP)\*(C'\fR fo' now, nahmeean, biatch? They is ghon be discussed in
the next example.
.IP "2." 5
We aren't passin any parametas ta \fIPrintUID\fR so G_NOARGS can be
specified.
.IP "3." 5
We aren't horny bout anythang returned from \fIPrintUID\fR, so
G_DISCARD is specified. Y'all KNOW dat shit, muthafucka! Even if \fIPrintUID\fR was chizzled to
return some value(s), havin specified G_DISCARD will mean dat they
will be wiped by tha time control returns from \fIcall_pv\fR.
.IP "4." 5
As \fIcall_pv\fR is bein used, tha Perl subroutine is specified as a
C string. In dis case tha subroutine name has been 'hard\-wired' tha fuck into the
code.
.IP "5." 5
Because we specified G_DISCARD, it aint necessary ta check tha value
returned from \fIcall_pv\fR. Well shiiiit, it will always be 0.
.SS "Passin Parameters"
.IX Subsection "Passin Parameters"
Now letz cook up a slightly mo' complex example. This time we want to
call a Perl subroutine, \f(CW\*(C`LeftString\*(C'\fR, which will take 2 parameters\*(--a
strin ($s) n' a integer ($n).  Da subroutine will simply
print tha straight-up original gangsta \f(CW$n\fR charactaz of tha string.
.PP
So tha Perl subroutine would be lookin like this:
.PP
.Vb 5
\&    sub LeftString
\&    {
\&        my($s, $n) = @_;
\&        print substr($s, 0, $n), "\en";
\&    }
.Ve
.PP
Da C function required ta booty-call \fILeftString\fR would be lookin like this:
.PP
.Vb 6
\&    static void
\&    call_LeftString(a, b)
\&    char * a;
\&    int b;
\&    {
\&        dSP;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSVpv(a, 0)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        call_pv("LeftString", G_DISCARD);
\&
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
Here is all dem notes on tha C function \fIcall_LeftString\fR.
.IP "1." 5
Parametas is passed ta tha Perl subroutine rockin tha Perl stack.
This is tha purpose of tha code beginnin wit tha line \f(CW\*(C`dSP\*(C'\fR and
endin wit tha line \f(CW\*(C`PUTBACK\*(C'\fR.  Da \f(CW\*(C`dSP\*(C'\fR declares a local copy
of tha stack pointer n' shit.  This local copy should \fBalways\fR be accessed
as \f(CW\*(C`SP\*(C'\fR.
.IP "2." 5
If yo ass is goin ta put suttin' onto tha Perl stack, you need ta know
where ta put dat shit. This is tha purpose of tha macro \f(CW\*(C`dSP\*(C'\fR\-\-it declares
and initializes a \fIlocal\fR copy of tha Perl stack pointer.
.Sp
All tha other macros which is ghon be used up in dis example require you to
have used dis macro.
.Sp
Da exception ta dis rule is if yo ass is callin a Perl subroutine
directly from a \s-1XSUB\s0 function. I aint talkin' bout chicken n' gravy biatch. In dis case it aint necessary to
use tha \f(CW\*(C`dSP\*(C'\fR macro explicitly\*(--it is ghon be declared fo' you
automatically.
.IP "3." 5
Any parametas ta be pushed onto tha stack should be bracketed by the
\&\f(CW\*(C`PUSHMARK\*(C'\fR n' \f(CW\*(C`PUTBACK\*(C'\fR macros.  Da purpose of these two macros, in
this context, is ta count tha number of parametas yo ass is
pushin automatically.  Then whenever Perl is bustin tha \f(CW@_\fR array fo' the
subroutine, it knows how tha fuck big-ass ta make dat shit.
.Sp
Da \f(CW\*(C`PUSHMARK\*(C'\fR macro  drops some lyrics ta Perl ta cook up a menstrual note of tha current
stack pointer n' shit. Even if yo ass aint passin any parametas (like the
example shown up in tha section \fINo Parameters, Nothang Returned\fR) you
must still call tha \f(CW\*(C`PUSHMARK\*(C'\fR macro before you can call any of the
\&\fIcall_*\fR functions\*(--Perl still need ta know dat there be no
parameters.
.Sp
Da \f(CW\*(C`PUTBACK\*(C'\fR macro sets tha global copy of tha stack pointa ta be
the same as our local copy. If our phat asses didn't do this, \fIcall_pv\fR
wouldn't know where tha two parametas we pushed were\*(--remember that
up ta now all tha stack pointa manipulation our crazy asses have done is wit our
local copy, \fInot\fR tha global copy.
.IP "4." 5
Next, we come ta XPUSHs. This is where tha parametas straight-up get
pushed onto tha stack. In dis case we is pushin a strang n' an
integer.
.Sp
See \*(L"XSUBs n' tha Argument Stack\*(R" up in perlguts fo' details
on how tha fuck tha \s-1XPUSH\s0 macros work.
.IP "5." 5
Because we pimped temporary joints (by meanz of \fIsv_2mortal()\fR calls)
we will gotta tidy up tha Perl stack n' dispose of mortal SVs.
.Sp
This is tha purpose of
.Sp
.Vb 2
\&    ENTER;
\&    SAVETMPS;
.Ve
.Sp
at tha start of tha function, and
.Sp
.Vb 2
\&    FREETMPS;
\&    LEAVE;
.Ve
.Sp
at tha end yo, but it ain't no stoppin cause I be still poppin'. Da \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`SAVETMPS\*(C'\fR pair creates a funky-ass boundary fo' any
temporaries we create.  This means dat tha temporaries we git rid of
will be limited ta dem which was pimped afta these calls.
.Sp
Da \f(CW\*(C`FREETMPS\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR pair will git rid of any joints returned by
the Perl subroutine (see next example), plus it will also dump the
mortal SVs our crazy asses have pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Havin \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`SAVETMPS\*(C'\fR at the
beginnin of tha code make shizzle dat no other mortals is destroyed.
.Sp
Think of these macros as hustlin a lil' bit like \f(CW\*(C`{\*(C'\fR n' \f(CW\*(C`}\*(C'\fR up in Perl
to limit tha scope of local variables.
.Sp
See tha section \fIUsin Perl ta Dispose of Temporaries\fR fo' details of
an alternatizzle ta rockin these macros.
.IP "6." 5
Finally, \fILeftString\fR can now be called via tha \fIcall_pv\fR function.
Da only flag specified dis time is G_DISCARD. Because we is passing
2 parametas ta tha Perl subroutine dis time, we aint specified
G_NOARGS.
.SS "Returnin a Scalar"
.IX Subsection "Returnin a Scalar"
Now fo' a example of dealin wit tha shit returned from a Perl
subroutine.
.PP
Here be a Perl subroutine, \fIAdder\fR, dat takes 2 integer parameters
and simply returns they sum.
.PP
.Vb 5
\&    sub Adder
\&    {
\&        my($a, $b) = @_;
\&        $a + $b;
\&    }
.Ve
.PP
Because we is now concerned wit tha return value from \fIAdder\fR, tha C
function required ta booty-call it is now a lil' bit mo' complex.
.PP
.Vb 7
\&    static void
\&    call_Adder(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        int count;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(a)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        count = call_pv("Adder", G_SCALAR);
\&
\&        SPAGAIN;
\&
\&        if (count != 1)
\&            croak("Big shit\en");
\&
\&        printf ("Da sum of %d n' %d is %d\en", a, b, POPi);
\&
\&        PUTBACK;
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
Points ta note dis time are
.IP "1." 5
Da only flag specified dis time was G_SCALAR. That means dat tha \f(CW@_\fR
array is ghon be pimped n' dat tha value returned by \fIAdder\fR will
still exist afta tha call ta \fIcall_pv\fR.
.IP "2." 5
Da purpose of tha macro \f(CW\*(C`SPAGAIN\*(C'\fR is ta refresh tha local copy of the
stack pointer n' shit. This is necessary cuz it is possible dat tha memory
allocated ta tha Perl stack has been reallocated durin the
\&\fIcall_pv\fR call.
.Sp
If yo ass is makin use of tha Perl stack pointa up in yo' code you must
always refresh tha local copy rockin \s-1SPAGAIN\s0 whenever you make use
of tha \fIcall_*\fR functions or any other Perl internal function.
.IP "3." 5
Although only a single value was sposed ta fuckin be returned from \fIAdder\fR,
it is still phat practice ta check tha return code from \fIcall_pv\fR
anyway.
.Sp
Expectin a single value aint like tha same as knowin dat there
will be one. If one of mah thugs modified \fIAdder\fR ta return a list n' we
didn't check fo' dat possibilitizzle n' take appropriate action tha Perl
stack would end up in a inconsistent state. That is suttin' you
\&\fIreally\fR don't wanna happen eva.
.IP "4." 5
Da \f(CW\*(C`POPi\*(C'\fR macro is used here ta pop tha return value from tha stack.
In dis case we wanted a integer, so \f(CW\*(C`POPi\*(C'\fR was used.
.Sp
Here is tha complete list of \s-1POP\s0 macros available, along wit tha types
they return.
.Sp
.Vb 5
\&    POPs        SV
\&    POPp        pointer
\&    POPn        double
\&    POPi        integer
\&    POPl        long
.Ve
.IP "5." 5
Da final \f(CW\*(C`PUTBACK\*(C'\fR is used ta leave tha Perl stack up in a cold-ass lil consistent
state before exitin tha function. I aint talkin' bout chicken n' gravy biatch.  This is necessary cuz when we
popped tha return value from tha stack wit \f(CW\*(C`POPi\*(C'\fR it updated only our
local copy of tha stack pointer n' shit.  Remember, \f(CW\*(C`PUTBACK\*(C'\fR sets tha global
stack pointa ta be tha same as our local copy.
.SS "Returnin a List of Values"
.IX Subsection "Returnin a List of Values"
Now, letz extend tha previous example ta return both tha sum of the
parametas n' tha difference.
.PP
Here is tha Perl subroutine
.PP
.Vb 5
\&    sub AddSubtract
\&    {
\&       my($a, $b) = @_;
\&       ($a+$b, $a\-$b);
\&    }
.Ve
.PP
and dis is tha C function
.PP
.Vb 7
\&    static void
\&    call_AddSubtract(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        int count;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(a)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        count = call_pv("AddSubtract", G_ARRAY);
\&
\&        SPAGAIN;
\&
\&        if (count != 2)
\&            croak("Big shit\en");
\&
\&        printf ("%d \- %d = %d\en", a, b, POPi);
\&        printf ("%d + %d = %d\en", a, b, POPi);
\&
\&        PUTBACK;
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
If \fIcall_AddSubtract\fR is called like this
.PP
.Vb 1
\&    call_AddSubtract(7, 4);
.Ve
.PP
then here is tha output
.PP
.Vb 2
\&    7 \- 4 = 3
\&    7 + 4 = 11
.Ve
.PP
Notes
.IP "1." 5
Us thugs wanted list context, so G_ARRAY was used.
.IP "2." 5
Not surprisingly \f(CW\*(C`POPi\*(C'\fR is used twice dis time cuz we were
retrievin 2 joints from tha stack. Da blingin thang ta note is that
when rockin tha \f(CW\*(C`POP*\*(C'\fR macros they come off tha stack up in \fIreverse\fR
order.
.SS "Returnin a List up in a Scalar Context"
.IX Subsection "Returnin a List up in a Scalar Context"
Say tha Perl subroutine up in tha previous section was called up in a scalar
context, like this
.PP
.Vb 8
\&    static void
\&    call_AddSubScalar(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        int count;
\&        int i;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(a)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        count = call_pv("AddSubtract", G_SCALAR);
\&
\&        SPAGAIN;
\&
\&        printf ("Items Returned = %d\en", count);
\&
\&        fo' (i = 1; i <= count; ++i)
\&            printf ("Value %d = %d\en", i, POPi);
\&
\&        PUTBACK;
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
Da other modification made is dat \fIcall_AddSubScalar\fR will print the
number of shit returned from tha Perl subroutine n' they value (for
simplicitizzle it assumes dat they is integer).  So if
\&\fIcall_AddSubScalar\fR is called
.PP
.Vb 1
\&    call_AddSubScalar(7, 4);
.Ve
.PP
then tha output will be
.PP
.Vb 2
\&    Items Returned = 1
\&    Value 1 = 3
.Ve
.PP
In dis case tha main point ta note is dat only tha last item up in the
list is returned from tha subroutine. \fIAddSubtract\fR straight-up juiced it up back to
\&\fIcall_AddSubScalar\fR.
.SS "Returnin Data from Perl via tha Parameta List"
.IX Subsection "Returnin Data from Perl via tha Parameta List"
It be also possible ta return joints directly via tha parameter
list\*(--whether it is straight-up desirable ta do it be another matta entirely.
.PP
Da Perl subroutine, \fIInc\fR, below takes 2 parametas n' increments
each directly.
.PP
.Vb 5
\&    sub Inc
\&    {
\&        ++ $_[0];
\&        ++ $_[1];
\&    }
.Ve
.PP
and here be a C function ta booty-call dat shit.
.PP
.Vb 9
\&    static void
\&    call_Inc(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        int count;
\&        SV * sva;
\&        SV * svb;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        sva = sv_2mortal(newSViv(a));
\&        svb = sv_2mortal(newSViv(b));
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sva);
\&        XPUSHs(svb);
\&        PUTBACK;
\&
\&        count = call_pv("Inc", G_DISCARD);
\&
\&        if (count != 0)
\&            croak ("call_Inc: expected 0 joints from \*(AqInc\*(Aq, gots %d\en",
\&                   count);
\&
\&        printf ("%d + 1 = %d\en", a, SvIV(sva));
\&        printf ("%d + 1 = %d\en", b, SvIV(svb));
\&
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
To be able ta access tha two parametas dat was pushed onto tha stack
afta they return from \fIcall_pv\fR it is necessary ta cook up a note
of they addresses\*(--thus tha two variablez \f(CW\*(C`sva\*(C'\fR n' \f(CW\*(C`svb\*(C'\fR.
.PP
Da reason dis is necessary is dat tha area of tha Perl stack which
held dem will straight-up likely done been overwritten by suttin' else by
the time control returns from \fIcall_pv\fR.
.SS "Usin G_EVAL"
.IX Subsection "Usin G_EVAL"
Now a example rockin G_EVAL. Below be a Perl subroutine which computes
the difference of its 2 parameters. If dis would result up in a negative
result, tha subroutine calls \fIdie\fR.
.PP
.Vb 3
\&    sub Subtract
\&    {
\&        mah ($a, $b) = @_;
\&
\&        take a thugged-out dirtnap "death can be fatal\en" if $a < $b;
\&
\&        $a \- $b;
\&    }
.Ve
.PP
and some C ta booty-call it
.PP
.Vb 7
\&    static void
\&    call_Subtract(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        int count;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(a)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        count = call_pv("Subtract", G_EVAL|G_SCALAR);
\&
\&        SPAGAIN;
\&
\&        /* Peep tha eval first */
\&        if (SvTRUE(ERRSV))
\&        {
\&            printf ("Uh oh \- %s\en", SvPV_nolen(ERRSV));
\&            POPs;
\&        }
\&        else
\&        {
\&            if (count != 1)
\&               croak("call_Subtract: wanted 1 value from \*(AqSubtract\*(Aq, gots %d\en",
\&                        count);
\&
\&            printf ("%d \- %d = %d\en", a, b, POPi);
\&        }
\&
\&        PUTBACK;
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
If \fIcall_Subtract\fR is called thus
.PP
.Vb 1
\&    call_Subtract(4, 5)
.Ve
.PP
the followin is ghon be printed
.PP
.Vb 1
\&    Uh oh \- dirtnap can be fatal
.Ve
.PP
Notes
.IP "1." 5
Us thugs wanna be able ta catch tha \fIdie\fR so our crazy asses have used tha G_EVAL
flag.  Not specifyin dis flag would mean dat tha program would
terminizzle immediately all up in tha \fIdie\fR statement up in tha subroutine
\&\fISubtract\fR.
.IP "2." 5
Da code
.Sp
.Vb 5
\&    if (SvTRUE(ERRSV))
\&    {
\&        printf ("Uh oh \- %s\en", SvPV_nolen(ERRSV));
\&        POPs;
\&    }
.Ve
.Sp
is tha direct equivalent of dis bit of Perl
.Sp
.Vb 1
\&    print "Uh oh \- $@\en" if $@;
.Ve
.Sp
\&\f(CW\*(C`PL_errgv\*(C'\fR be a perl global of type \f(CW\*(C`GV *\*(C'\fR dat points ta the
symbol table entry containin tha error. Shiiit, dis aint no joke.  \f(CW\*(C`ERRSV\*(C'\fR therefore
refers ta tha C equivalent of \f(CW$@\fR.
.IP "3." 5
Note dat tha stack is popped rockin \f(CW\*(C`POPs\*(C'\fR up in tha block where
\&\f(CW\*(C`SvTRUE(ERRSV)\*(C'\fR is true.  This is necessary cuz whenever a
\&\fIcall_*\fR function invoked wit G_EVAL|G_SCALAR returns a error,
the top of tha stack holdz tha value \fIundef\fR. Because we want the
program ta continue afta detectin dis error, it is essential that
the stack be tidied up by removin tha \fIundef\fR.
.SS "Usin G_KEEPERR"
.IX Subsection "Usin G_KEEPERR"
Consider dis rather facetious example, where our crazy asses have used a \s-1XS\s0
version of tha call_Subtract example above inside a thugged-out destructor:
.PP
.Vb 9
\&    package Foo;
\&    sub freshly smoked up { bless {}, $_[0] }
\&    sub Subtract {
\&        my($a,$b) = @_;
\&        take a thugged-out dirtnap "death can be fatal" if $a < $b;
\&        $a \- $b;
\&    }
\&    sub DESTROY { call_Subtract(5, 4); }
\&    sub foo { take a thugged-out dirtnap "foo dies"; }
\&
\&    package main;
\&    {
\&        mah $foo = Foo\->new;
\&        eval { $foo\->foo };
\&    }
\&    print "Saw: $@" if $@;             # should be yo, but isn\*(Aqt
.Ve
.PP
This example will fail ta recognize dat a error occurred inside the
\&\f(CW\*(C`eval {}\*(C'\fR.  Herez why: tha call_Subtract code gots executed while perl
was cleanin up temporaries when exitin tha outa braced block, n' cuz
call_Subtract is implemented wit \fIcall_pv\fR rockin tha G_EVAL
flag, it promptly reset \f(CW$@\fR.  This thangs up in dis biatch up in tha failure of the
outermost test fo' \f(CW$@\fR, n' thereby tha failure of tha error trap.
.PP
Appendin tha G_KEEPERR flag, so dat tha \fIcall_pv\fR call in
call_Subtract reads:
.PP
.Vb 1
\&        count = call_pv("Subtract", G_EVAL|G_SCALAR|G_KEEPERR);
.Ve
.PP
will preserve tha error n' restore reliable error handling.
.SS "Usin call_sv"
.IX Subsection "Usin call_sv"
In all tha previous examplez I have 'hard\-wired' tha name of tha Perl
subroutine ta be called from C.  Most of tha time though, it is more
convenient ta be able ta specify tha name of tha Perl subroutine from
within tha Perl script.
.PP
Consider tha Perl code below
.PP
.Vb 4
\&    sub fred
\&    {
\&        print "Wuz crackalackin' there\en";
\&    }
\&
\&    CallSubPV("fred");
.Ve
.PP
Here be a snippet of \s-1XSUB\s0 which defines \fICallSubPV\fR.
.PP
.Vb 6
\&    void
\&    CallSubPV(name)
\&        char *  name
\&        CODE:
\&        PUSHMARK(SP);
\&        call_pv(name, G_DISCARD|G_NOARGS);
.Ve
.PP
That is fine as far as it goes. Da thang is, tha Perl subroutine
can be specified as only a string, however, Perl allows references
to subroutines n' anonymous subroutines.
This is where \fIcall_sv\fR is useful.
.PP
Da code below fo' \fICallSubSV\fR is identical ta \fICallSubPV\fR except
that tha \f(CW\*(C`name\*(C'\fR parameta is now defined as a SV* n' we use
\&\fIcall_sv\fR instead of \fIcall_pv\fR.
.PP
.Vb 6
\&    void
\&    CallSubSV(name)
\&        SV *    name
\&        CODE:
\&        PUSHMARK(SP);
\&        call_sv(name, G_DISCARD|G_NOARGS);
.Ve
.PP
Because we is rockin a \s-1SV\s0 ta booty-call \fIfred\fR tha followin can all be used:
.PP
.Vb 5
\&    CallSubSV("fred");
\&    CallSubSV(\e&fred);
\&    $ref = \e&fred;
\&    CallSubSV($ref);
\&    CallSubSV( sub { print "Wuz crackalackin' there\en" } );
.Ve
.PP
As you can see, \fIcall_sv\fR gives you much pimped outa flexibilitizzle in
how you can specify tha Perl subroutine.
.PP
Yo ass should note that, if it is necessary ta store tha \s-1SV \s0(\f(CW\*(C`name\*(C'\fR up in the
example above) which correspondz ta tha Perl subroutine so dat it can
be used lata up in tha program, it not enough just ta store a cold-ass lil copy of the
pointa ta tha \s-1SV.\s0 Say tha code above had been like this:
.PP
.Vb 1
\&    static SV * rememberSub;
\&
\&    void
\&    SaveSub1(name)
\&        SV *    name
\&        CODE:
\&        rememberSub = name;
\&
\&    void
\&    CallSavedSub1()
\&        CODE:
\&        PUSHMARK(SP);
\&        call_sv(rememberSub, G_DISCARD|G_NOARGS);
.Ve
.PP
Da reason dis is wack is that, by tha time you come ta use the
pointa \f(CW\*(C`rememberSub\*(C'\fR up in \f(CW\*(C`CallSavedSub1\*(C'\fR, it may or may not still refer
to tha Perl subroutine dat was recorded up in \f(CW\*(C`SaveSub1\*(C'\fR.  This is
particularly legit fo' these cases:
.PP
.Vb 2
\&    SaveSub1(\e&fred);
\&    CallSavedSub1();
\&
\&    SaveSub1( sub { print "Wuz crackalackin' there\en" } );
\&    CallSavedSub1();
.Ve
.PP
By tha time each of tha \f(CW\*(C`SaveSub1\*(C'\fR statements above has been executed,
the SV*s which corresponded ta tha parametas will no longer exist.
Expect a error message from Perl of tha form
.PP
.Vb 1
\&    Can\*(Aqt use a undefined value as a subroutine reference at ...
.Ve
.PP
for each of tha \f(CW\*(C`CallSavedSub1\*(C'\fR lines.
.PP
Similarly, wit dis code
.PP
.Vb 4
\&    $ref = \e&fred;
\&    SaveSub1($ref);
\&    $ref = 47;
\&    CallSavedSub1();
.Ve
.PP
you can expect one of these lyrics (which you straight-up git is dependent on
the version of Perl yo ass is using)
.PP
.Vb 2
\&    Not a CODE reference at ...
\&    Undefined subroutine &main::47 called ...
.Ve
.PP
Da variable \f(CW$ref\fR may have referred ta tha subroutine \f(CW\*(C`fred\*(C'\fR
whenever tha call ta \f(CW\*(C`SaveSub1\*(C'\fR was made but by tha time
\&\f(CW\*(C`CallSavedSub1\*(C'\fR gets called it now holdz tha number \f(CW47\fR. Because we
saved only a pointa ta tha original gangsta \s-1SV\s0 up in \f(CW\*(C`SaveSub1\*(C'\fR, any chizzlez to
\&\f(CW$ref\fR is ghon be tracked by tha pointa \f(CW\*(C`rememberSub\*(C'\fR. This means that
whenever \f(CW\*(C`CallSavedSub1\*(C'\fR gets called, it will attempt ta execute the
code which is referenced by tha SV* \f(CW\*(C`rememberSub\*(C'\fR.  In dis case
though, it now refers ta tha integer \f(CW47\fR, so expect Perl ta complain
loudly.
.PP
A similar but mo' subtle problem is illustrated wit dis code:
.PP
.Vb 4
\&    $ref = \e&fred;
\&    SaveSub1($ref);
\&    $ref = \e&joe;
\&    CallSavedSub1();
.Ve
.PP
This time whenever \f(CW\*(C`CallSavedSub1\*(C'\fR gets called it will execute tha Perl
subroutine \f(CW\*(C`joe\*(C'\fR (assumin it exists) rather than \f(CW\*(C`fred\*(C'\fR as was
originally axed up in tha call ta \f(CW\*(C`SaveSub1\*(C'\fR.
.PP
To git round these problems it is necessary ta take a gangbangin' full copy of the
\&\s-1SV. \s0 Da code below shows \f(CW\*(C`SaveSub2\*(C'\fR modified ta do dis shit.
.PP
.Vb 1
\&    static SV * keepSub = (SV*)NULL;
\&
\&    void
\&    SaveSub2(name)
\&        SV *    name
\&        CODE:
\&        /* Take a cold-ass lil copy of tha callback */
\&        if (keepSub == (SV*)NULL)
\&            /* First time, so create a freshly smoked up SV */
\&            keepSub = newSVsv(name);
\&        else
\&            /* Been here before, so overwrite */
\&            SvSetSV(keepSub, name);
\&
\&    void
\&    CallSavedSub2()
\&        CODE:
\&        PUSHMARK(SP);
\&        call_sv(keepSub, G_DISCARD|G_NOARGS);
.Ve
.PP
To avoid bustin a freshly smoked up \s-1SV\s0 every last muthafuckin time \f(CW\*(C`SaveSub2\*(C'\fR is called,
the function first checks ta peep if it has been called before.  If not,
then space fo' a freshly smoked up \s-1SV\s0 be allocated n' tha reference ta tha Perl
subroutine \f(CW\*(C`name\*(C'\fR is copied ta tha variable \f(CW\*(C`keepSub\*(C'\fR up in one
operation rockin \f(CW\*(C`newSVsv\*(C'\fR.  Thereafter, whenever \f(CW\*(C`SaveSub2\*(C'\fR is called,
the existin \s-1SV, \s0\f(CW\*(C`keepSub\*(C'\fR, is overwritten wit tha freshly smoked up value using
\&\f(CW\*(C`SvSetSV\*(C'\fR.
.SS "Usin call_argv"
.IX Subsection "Usin call_argv"
Here be a Perl subroutine which prints whatever parametas is passed
to dat shit.
.PP
.Vb 3
\&    sub PrintList
\&    {
\&        my(@list) = @_;
\&
\&        foreach (@list) { print "$_\en" }
\&    }
.Ve
.PP
And here be a example of \fIcall_argv\fR which will call
\&\fIPrintList\fR.
.PP
.Vb 1
\&    static char * lyrics[] = {"alpha", "beta", "gamma", "delta", NULL};
\&
\&    static void
\&    call_PrintList()
\&    {
\&        dSP;
\&
\&        call_argv("PrintList", G_DISCARD, lyrics);
\&    }
.Ve
.PP
Note dat it aint necessary ta booty-call \f(CW\*(C`PUSHMARK\*(C'\fR up in dis instance.
This is cuz \fIcall_argv\fR will do it fo' yo thugged-out ass.
.SS "Usin call_method"
.IX Subsection "Usin call_method"
Consider tha followin Perl code:
.PP
.Vb 2
\&    {
\&        package Mine;
\&
\&        sub new
\&        {
\&            my($type) = shift;
\&            bless [@_]
\&        }
\&
\&        sub Display
\&        {
\&            mah ($self, $index) = @_;
\&            print "$index: $$self[$index]\en";
\&        }
\&
\&        sub PrintID
\&        {
\&            my($class) = @_;
\&            print "This is Class $class version 1.0\en";
\&        }
\&    }
.Ve
.PP
It implements just a straight-up simple class ta manage a array.  Apart from
the constructor, \f(CW\*(C`new\*(C'\fR, it declares methods, one static n' one
virtual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da static method, \f(CW\*(C`PrintID\*(C'\fR, prints up simply tha class
name n' a version number n' shit. Da virtual method, \f(CW\*(C`Display\*(C'\fR, prints up a
single element of tha array.  Here be a all-Perl example of rockin dat shit.
.PP
.Vb 3
\&    $a = Mine\->new(\*(Aqred\*(Aq, \*(Aqgreen\*(Aq, \*(Aqblue\*(Aq);
\&    $a\->Display(1);
\&    Mine\->PrintID;
.Ve
.PP
will print
.PP
.Vb 2
\&    1: green
\&    This is Class Mine version 1.0
.Ve
.PP
Callin a Perl method from C is fairly straightforward. Y'all KNOW dat shit, muthafucka! Da following
things is required:
.IP "\(bu" 5
A reference ta tha object fo' a virtual method or tha name of tha class
for a static method
.IP "\(bu" 5
Da name of tha method
.IP "\(bu" 5
Any other parametas specific ta tha method
.PP
Here be a simple \s-1XSUB\s0 which illustrates tha mechanics of callin both
the \f(CW\*(C`PrintID\*(C'\fR n' \f(CW\*(C`Display\*(C'\fR methodz from C.
.PP
.Vb 10
\&    void
\&    call_Method(ref, method, index)
\&        SV *    ref
\&        char *  method
\&        int             index
\&        CODE:
\&        PUSHMARK(SP);
\&        XPUSHs(ref);
\&        XPUSHs(sv_2mortal(newSViv(index)));
\&        PUTBACK;
\&
\&        call_method(method, G_DISCARD);
\&
\&    void
\&    call_PrintID(class, method)
\&        char *  class
\&        char *  method
\&        CODE:
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSVpv(class, 0)));
\&        PUTBACK;
\&
\&        call_method(method, G_DISCARD);
.Ve
.PP
So tha methodz \f(CW\*(C`PrintID\*(C'\fR n' \f(CW\*(C`Display\*(C'\fR can be invoked like this:
.PP
.Vb 3
\&    $a = Mine\->new(\*(Aqred\*(Aq, \*(Aqgreen\*(Aq, \*(Aqblue\*(Aq);
\&    call_Method($a, \*(AqDisplay\*(Aq, 1);
\&    call_PrintID(\*(AqMine\*(Aq, \*(AqPrintID\*(Aq);
.Ve
.PP
Da only thang ta note is that, up in both tha static n' virtual methods,
the method name aint passed via tha stack\*(--it is used as tha first
parameta ta \fIcall_method\fR.
.SS "Usin \s-1GIMME_V\s0"
.IX Subsection "Usin GIMME_V"
Here be a trivial \s-1XSUB\s0 which prints tha context up in which it is
currently executing.
.PP
.Vb 10
\&    void
\&    PrintContext()
\&        CODE:
\&        I32 gimme = GIMME_V;
\&        if (gimme == G_VOID)
\&            printf ("Context is Void\en");
\&        else if (gimme == G_SCALAR)
\&            printf ("Context is Scalar\en");
\&        else
\&            printf ("Context is Array\en");
.Ve
.PP
And here is some Perl ta test dat shit.
.PP
.Vb 3
\&    PrintContext;
\&    $a = PrintContext;
\&    @a = PrintContext;
.Ve
.PP
Da output from dat will be
.PP
.Vb 3
\&    Context is Void
\&    Context is Scalar
\&    Context is Array
.Ve
.SS "Usin Perl ta Dispose of Temporaries"
.IX Subsection "Usin Perl ta Dispose of Temporaries"
In tha examplez given ta date, any temporaries pimped up in tha callback
(i.e., parametas passed on tha stack ta tha \fIcall_*\fR function or
values returned via tha stack) done been freed by one of these methods:
.IP "\(bu" 5
Specifyin tha G_DISCARD flag wit \fIcall_*\fR
.IP "\(bu" 5
Explicitly rockin tha \f(CW\*(C`ENTER\*(C'\fR/\f(CW\*(C`SAVETMPS\*(C'\fR\-\-\f(CW\*(C`FREETMPS\*(C'\fR/\f(CW\*(C`LEAVE\*(C'\fR pairing
.PP
There be another method which can be used, namely lettin Perl do it
for you automatically whenever it regains control afta tha callback
has terminated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is done by simply not rockin the
.PP
.Vb 5
\&    ENTER;
\&    SAVETMPS;
\&    ...
\&    FREETMPS;
\&    LEAVE;
.Ve
.PP
sequence up in tha callback (and not, of course, specifyin tha G_DISCARD
flag).
.PP
If yo ass is goin ta use dis method you gotta be aware of a possible
memory leak which can arise under straight-up specific circumstances.  To
explain these circumstances you need ta know a lil' bit bout tha flow of
control between Perl n' tha callback routine.
.PP
Da examplez given all up in tha start of tha document (an error handlez and
an event driven program) is typical of tha two main sortz of flow
control dat yo ass is likely ta encounta wit callbacks.  There be a
very blingin distinction between them, so pay attention.
.PP
In tha straight-up original gangsta example, a error handlez, tha flow of control could be as
bigs up.  Yo ass have pimped a intercourse ta a external library.
Control can reach tha external library like this
.PP
.Vb 1
\&    perl \-\-> XSUB \-\-> external library
.Ve
.PP
Whilst control is up in tha library, a error condizzle occurs. Yo ass have
previously set up a Perl callback ta handle dis thang, so it will
get executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Once tha callback has finished, control will drop back to
Perl again. I aint talkin' bout chicken n' gravy biatch.  Here is what tha fuck tha flow of control is ghon be like up in that
situation
.PP
.Vb 7
\&    perl \-\-> XSUB \-\-> external library
\&                      ...
\&                      error occurs
\&                      ...
\&                      external library \-\-> call_* \-\-> perl
\&                                                          |
\&    perl <\-\- XSUB <\-\- external library <\-\- call_* <\-\-\-\-+
.Ve
.PP
Afta processin of tha error rockin \fIcall_*\fR is completed,
control reverts back ta Perl mo' or less immediately.
.PP
In tha diagram, tha further right you go tha mo' deeply nested the
scope is.  It be only when control is back wit perl on tha extreme
left of tha diagram dat you gonna git dropped back ta tha enclosing
scope n' any temporaries you have left hangin round is ghon be freed.
.PP
In tha second example, a event driven program, tha flow of control
will be mo' like this
.PP
.Vb 10
\&    perl \-\-> XSUB \-\-> event handlez
\&                      ...
\&                      event handlez \-\-> call_* \-\-> perl
\&                                                       |
\&                      event handlez <\-\- call_* <\-\-\-\-+
\&                      ...
\&                      event handlez \-\-> call_* \-\-> perl
\&                                                       |
\&                      event handlez <\-\- call_* <\-\-\-\-+
\&                      ...
\&                      event handlez \-\-> call_* \-\-> perl
\&                                                       |
\&                      event handlez <\-\- call_* <\-\-\-\-+
.Ve
.PP
In dis case tha flow of control can consist of only tha repeated
sequence
.PP
.Vb 1
\&    event handlez \-\-> call_* \-\-> perl
.Ve
.PP
for practically tha complete duration of tha program.  This means that
control may \fInever\fR drop back ta tha surroundin scope up in Perl at the
off tha hook left.
.PP
So what tha fuck is tha big-ass problem, biatch? Well, if yo ass is expectin Perl ta tidy up
those temporaries fo' you, you might be up in fo' a long-ass wait.  For Perl
to dispose of yo' temporaries, control must drop back ta the
enclosin scope at some stage.  In tha event driven scenario dat may
never happen. I aint talkin' bout chicken n' gravy biatch.  This means that, as time goes on, yo' program will
create mo' n' mo' temporaries, none of which will eva be freed. Y'all KNOW dat shit, muthafucka! As
each of these temporaries consumes some memory yo' program will
eventually consume all tha available memory up in yo' system\*(--kapow!
.PP
So here is tha bottom line\*(--if yo ass is shizzle dat control will revert
back ta tha enclosin Perl scope fairly quickly afta tha end of your
callback, then it aint straight-up necessary ta dispose explicitly of
any temporaries you may have pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Mind you, if yo ass be at all
uncertain bout what tha fuck ta do, it don't do any harm ta tidy up anyway.
.SS "Strategies fo' Storin Callback Context Information"
.IX Subsection "Strategies fo' Storin Callback Context Information"
Potentially one of tha trickiest problems ta overcome when designin a
callback intercourse can be figurin up how tha fuck ta store tha mappin between
the C callback function n' tha Perl equivalent.
.PP
To help KNOW why dis can be a real problem first consider how tha fuck a
callback is set up in a all C environment.  Typically a C \s-1API\s0 will
provide a gangbangin' function ta regista a cold-ass lil callback.  This will expect a pointer
to a gangbangin' function as one of its parameters.  Below be a cold-ass lil call ta a
hypothetical function \f(CW\*(C`register_fatal\*(C'\fR which registas tha C function
to git called when a gangbangin' fatal error occurs.
.PP
.Vb 1
\&    register_fatal(cb1);
.Ve
.PP
Da single parameta \f(CW\*(C`cb1\*(C'\fR be a pointa ta a gangbangin' function, so you must
have defined \f(CW\*(C`cb1\*(C'\fR up in yo' code, say suttin' like this
.PP
.Vb 6
\&    static void
\&    cb1()
\&    {
\&        printf ("Fatal Error\en");
\&        exit(1);
\&    }
.Ve
.PP
Now chizzle dat ta booty-call a Perl subroutine instead
.PP
.Vb 1
\&    static SV * callback = (SV*)NULL;
\&
\&    static void
\&    cb1()
\&    {
\&        dSP;
\&
\&        PUSHMARK(SP);
\&
\&        /* Call tha Perl sub ta process tha callback */
\&        call_sv(callback, G_DISCARD);
\&    }
\&
\&
\&    void
\&    register_fatal(fn)
\&        SV *    fn
\&        CODE:
\&        /* Remember tha Perl sub */
\&        if (callback == (SV*)NULL)
\&            callback = newSVsv(fn);
\&        else
\&            SvSetSV(callback, fn);
\&
\&        /* regista tha callback wit tha external library */
\&        register_fatal(cb1);
.Ve
.PP
where tha Perl equivalent of \f(CW\*(C`register_fatal\*(C'\fR n' tha callback it
registers, \f(CW\*(C`pcb1\*(C'\fR, might be lookin like this
.PP
.Vb 2
\&    # Regista tha sub pcb1
\&    register_fatal(\e&pcb1);
\&
\&    sub pcb1
\&    {
\&        take a thugged-out dirtnap "I\*(Aqm dying...\en";
\&    }
.Ve
.PP
Da mappin between tha C callback n' tha Perl equivalent is stored in
the global variable \f(CW\*(C`callback\*(C'\fR.
.PP
This is ghon be adequate if you eva need ta have only one callback
registered at any time fo' realz. An example could be a error handlez like the
code sketched up above. Remember though, repeated calls to
\&\f(CW\*(C`register_fatal\*(C'\fR will replace tha previously registered callback
function wit tha freshly smoked up one.
.PP
Say fo' example you wanna intercourse ta a library which allows asynchronous
file i/o.  In dis case you may be able ta regista a cold-ass lil callback whenever
a read operation has completed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. To be of any use we wanna be able to
call separate Perl subroutines fo' each file dat is opened. Y'all KNOW dat shit, muthafucka!  As it
stands, tha error handlez example above would not be adequate as it
allows only a single callback ta be defined at any time. What we
require be a meanz of storin tha mappin between tha opened file and
the Perl subroutine we wanna be called fo' dat file.
.PP
Say tha i/o library has a gangbangin' function \f(CW\*(C`asynch_read\*(C'\fR which associates a C
function \f(CW\*(C`ProcessRead\*(C'\fR wit a gangbangin' file handle \f(CW\*(C`fh\*(C'\fR\-\-this assumes dat it
has also provided some routine ta open tha file n' so obtain tha file
handle.
.PP
.Vb 1
\&    asynch_read(fh, ProcessRead)
.Ve
.PP
This may expect tha C \fIProcessRead\fR function of dis form
.PP
.Vb 7
\&    void
\&    ProcessRead(fh, buffer)
\&    int fh;
\&    char *      buffer;
\&    {
\&         ...
\&    }
.Ve
.PP
To provide a Perl intercourse ta dis library we need ta be able ta map
between tha \f(CW\*(C`fh\*(C'\fR parameta n' tha Perl subroutine we want called. Y'all KNOW dat shit, muthafucka!  A
hash be a cold-ass lil convenient mechanizzle fo' storin dis mapping.  Da code
below shows a possible implementation
.PP
.Vb 1
\&    static HV * Mappin = (HV*)NULL;
\&
\&    void
\&    asynch_read(fh, callback)
\&        int     fh
\&        SV *    callback
\&        CODE:
\&        /* If tha hash don\*(Aqt already exist, create it */
\&        if (Mappin == (HV*)NULL)
\&            Mappin = newHV();
\&
\&        /* Save tha fh \-> callback mappin */
\&        hv_store(Mapping, (char*)&fh, sizeof(fh), newSVsv(callback), 0);
\&
\&        /* Regista wit tha C Library */
\&        asynch_read(fh, asynch_read_if);
.Ve
.PP
and \f(CW\*(C`asynch_read_if\*(C'\fR could be lookin like this
.PP
.Vb 7
\&    static void
\&    asynch_read_if(fh, buffer)
\&    int fh;
\&    char *      buffer;
\&    {
\&        dSP;
\&        SV ** sv;
\&
\&        /* Git tha callback associated wit fh */
\&        sv =  hv_fetch(Mapping, (char*)&fh , sizeof(fh), FALSE);
\&        if (sv == (SV**)NULL)
\&            croak("Internal error...\en");
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(fh)));
\&        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
\&        PUTBACK;
\&
\&        /* Call tha Perl sub */
\&        call_sv(*sv, G_DISCARD);
\&    }
.Ve
.PP
For completeness, here is \f(CW\*(C`asynch_close\*(C'\fR.  This shows how tha fuck ta remove
the entry from tha hash \f(CW\*(C`Mapping\*(C'\fR.
.PP
.Vb 6
\&    void
\&    asynch_close(fh)
\&        int     fh
\&        CODE:
\&        /* Remove tha entry from tha hash */
\&        (void) hv_delete(Mapping, (char*)&fh, sizeof(fh), G_DISCARD);
\&
\&        /* Now call tha real asynch_close */
\&        asynch_close(fh);
.Ve
.PP
So tha Perl intercourse would be lookin like this
.PP
.Vb 4
\&    sub callback1
\&    {
\&        my($handle, $buffer) = @_;
\&    }
\&
\&    # Regista tha Perl callback
\&    asynch_read($fh, \e&callback1);
\&
\&    asynch_close($fh);
.Ve
.PP
Da mappin between tha C callback n' Perl is stored up in tha global
hash \f(CW\*(C`Mapping\*(C'\fR dis time. Usin a hash has tha distinct advantage that
it allows a unlimited number of callbacks ta be registered.
.PP
What if tha intercourse provided by tha C callback don't contain a
parameta which allows tha file handle ta Perl subroutine mapping, biatch?  Say
in tha asynchronous i/o package, tha callback function gets passed only
the \f(CW\*(C`buffer\*(C'\fR parameta like this
.PP
.Vb 6
\&    void
\&    ProcessRead(buffer)
\&    char *      buffer;
\&    {
\&        ...
\&    }
.Ve
.PP
Without tha file handle there is no straightforward way ta map from the
C callback ta tha Perl subroutine.
.PP
In dis case a possible way round dis problem is ta predefine a
seriez of C functions ta act as tha intercourse ta Perl, thus
.PP
.Vb 3
\&    #define MAX_CB              3
\&    #define NULL_HANDLE \-1
\&    typedef void (*FnMap)();
\&
\&    struct MapStruct {
\&        FnMap    Function;
\&        SV *     PerlSub;
\&        int      Handle;
\&      };
\&
\&    static void  fn1();
\&    static void  fn2();
\&    static void  fn3();
\&
\&    static struct MapStruct Map [MAX_CB] =
\&        {
\&            { fn1, NULL, NULL_HANDLE },
\&            { fn2, NULL, NULL_HANDLE },
\&            { fn3, NULL, NULL_HANDLE }
\&        };
\&
\&    static void
\&    Pcb(index, buffer)
\&    int index;
\&    char * buffer;
\&    {
\&        dSP;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSVpv(buffer, 0)));
\&        PUTBACK;
\&
\&        /* Call tha Perl sub */
\&        call_sv(Map[index].PerlSub, G_DISCARD);
\&    }
\&
\&    static void
\&    fn1(buffer)
\&    char * buffer;
\&    {
\&        Pcb(0, buffer);
\&    }
\&
\&    static void
\&    fn2(buffer)
\&    char * buffer;
\&    {
\&        Pcb(1, buffer);
\&    }
\&
\&    static void
\&    fn3(buffer)
\&    char * buffer;
\&    {
\&        Pcb(2, buffer);
\&    }
\&
\&    void
\&    array_asynch_read(fh, callback)
\&        int             fh
\&        SV *    callback
\&        CODE:
\&        int index;
\&        int null_index = MAX_CB;
\&
\&        /* Find tha same handle or a empty entry */
\&        fo' (index = 0; index < MAX_CB; ++index)
\&        {
\&            if (Map[index].Handle == fh)
\&                break;
\&
\&            if (Map[index].Handle == NULL_HANDLE)
\&                null_index = index;
\&        }
\&
\&        if (index == MAX_CB && null_index == MAX_CB)
\&            croak ("Too nuff callback functions registered\en");
\&
\&        if (index == MAX_CB)
\&            index = null_index;
\&
\&        /* Save tha file handle */
\&        Map[index].Handle = fh;
\&
\&        /* Remember tha Perl sub */
\&        if (Map[index].PerlSub == (SV*)NULL)
\&            Map[index].PerlSub = newSVsv(callback);
\&        else
\&            SvSetSV(Map[index].PerlSub, callback);
\&
\&        asynch_read(fh, Map[index].Function);
\&
\&    void
\&    array_asynch_close(fh)
\&        int     fh
\&        CODE:
\&        int index;
\&
\&        /* Find tha file handle */
\&        fo' (index = 0; index < MAX_CB; ++ index)
\&            if (Map[index].Handle == fh)
\&                break;
\&
\&        if (index == MAX_CB)
\&            croak ("could not close fh %d\en", fh);
\&
\&        Map[index].Handle = NULL_HANDLE;
\&        SvREFCNT_dec(Map[index].PerlSub);
\&        Map[index].PerlSub = (SV*)NULL;
\&
\&        asynch_close(fh);
.Ve
.PP
In dis case tha functions \f(CW\*(C`fn1\*(C'\fR, \f(CW\*(C`fn2\*(C'\fR, n' \f(CW\*(C`fn3\*(C'\fR is used to
remember tha Perl subroutine ta be called. Y'all KNOW dat shit, muthafucka! Each of tha functions holds
a separate hard-wired index which is used up in tha function \f(CW\*(C`Pcb\*(C'\fR to
access tha \f(CW\*(C`Map\*(C'\fR array n' straight-up call tha Perl subroutine.
.PP
There is some obvious disadvantages wit dis technique.
.PP
Firstly, tha code is considerably mo' complex than wit tha previous
example.
.PP
Secondly, there be a hard-wired limit (in dis case 3) ta tha number of
callbacks dat can exist simultaneously. Da only way ta increase the
limit is by modifyin tha code ta add mo' functions n' then
recompiling.  None tha less, as long as tha number of functions is
chosen wit some care, it is still a workable solution n' up in some
cases is tha only one available.
.PP
To summarize, here is a fuckin shitload of possible methodz fo' you ta consider
for storin tha mappin between C n' tha Perl callback
.IP "1. Ignore tha problem \- Allow only 1 callback" 5
.IX Item "1. Ignore tha problem - Allow only 1 callback"
For a shitload of thangs, like interfacin ta a error handlez, dis may
be a perfectly adequate solution.
.IP "2. Right back up in yo muthafuckin ass. Smoke a sequence of callbacks \- hard wired limit" 5
.IX Item "2. Right back up in yo muthafuckin ass. Smoke a sequence of callbacks - hard wired limit"
If it is impossible ta tell from tha parametas passed back from tha C
callback what tha fuck tha context is, then you may need ta create a sequence of C
callback intercourse functions, n' store pointas ta each up in a array.
.IP "3. Use a parameta ta map ta tha Perl callback" 5
.IX Item "3. Use a parameta ta map ta tha Perl callback"
A hash be a ideal mechanizzle ta store tha mappin between C n' Perl.
.SS "Alternate Stack Manipulation"
.IX Subsection "Alternate Stack Manipulation"
Although I have made use of only tha \f(CW\*(C`POP*\*(C'\fR macros ta access joints
returned from Perl subroutines, it be also possible ta bypass these
macros n' read tha stack rockin tha \f(CW\*(C`ST\*(C'\fR macro (See perlxs fo' a
full description of tha \f(CW\*(C`ST\*(C'\fR macro).
.PP
Most of tha time tha \f(CW\*(C`POP*\*(C'\fR macros should be adequate; tha main
problem wit dem is dat they force you ta process tha returned joints
in sequence. This may not be da most thugged-out suitable way ta process the
values up in some cases. What we want is ta be able ta access tha stack in
a random order n' shit. Da \f(CW\*(C`ST\*(C'\fR macro as used when codin a \s-1XSUB\s0 is ideal
for dis purpose.
.PP
Da code below is tha example given up in tha section \fIReturnin a List
of Values\fR recoded ta use \f(CW\*(C`ST\*(C'\fR instead of \f(CW\*(C`POP*\*(C'\fR.
.PP
.Vb 8
\&    static void
\&    call_AddSubtract2(a, b)
\&    int a;
\&    int b;
\&    {
\&        dSP;
\&        I32 ax;
\&        int count;
\&
\&        ENTER;
\&        SAVETMPS;
\&
\&        PUSHMARK(SP);
\&        XPUSHs(sv_2mortal(newSViv(a)));
\&        XPUSHs(sv_2mortal(newSViv(b)));
\&        PUTBACK;
\&
\&        count = call_pv("AddSubtract", G_ARRAY);
\&
\&        SPAGAIN;
\&        SP \-= count;
\&        ax = (SP \- PL_stack_base) + 1;
\&
\&        if (count != 2)
\&            croak("Big shit\en");
\&
\&        printf ("%d + %d = %d\en", a, b, SvIV(ST(0)));
\&        printf ("%d \- %d = %d\en", a, b, SvIV(ST(1)));
\&
\&        PUTBACK;
\&        FREETMPS;
\&        LEAVE;
\&    }
.Ve
.PP
Notes
.IP "1." 5
Notice dat dat shiznit was necessary ta define tha variable \f(CW\*(C`ax\*(C'\fR.  This is
because tha \f(CW\*(C`ST\*(C'\fR macro expects it ta exist.  If we was up in a \s-1XSUB\s0 it
would not be necessary ta define \f(CW\*(C`ax\*(C'\fR as it be already defined for
us.
.IP "2." 5
Da code
.Sp
.Vb 3
\&        SPAGAIN;
\&        SP \-= count;
\&        ax = (SP \- PL_stack_base) + 1;
.Ve
.Sp
sets tha stack up so dat we can use tha \f(CW\*(C`ST\*(C'\fR macro.
.IP "3." 5
Unlike tha original gangsta codin of dis example, tha returned
values is not accessed up in reverse order n' shit.  So \f(CWST(0)\fR refers ta the
first value returned by tha Perl subroutine n' \f(CW\*(C`ST(count\-1)\*(C'\fR
refers ta tha last.
.SS "Creatin n' Callin a Anonymous Subroutine up in C"
.IX Subsection "Creatin n' Callin a Anonymous Subroutine up in C"
As we've already shown, \f(CW\*(C`call_sv\*(C'\fR can be used ta invoke an
anonymous subroutine.  But fuck dat shiznit yo, tha word on tha street is dat our example flossed a Perl script
invokin a \s-1XSUB\s0 ta big-ass up dis operation. I aint talkin' bout chicken n' gravy biatch.  Letz peep how tha fuck it can be
done inside our C code:
.PP
.Vb 1
\& ...
\&
\& SV *cvrv = eval_pv("sub { print \*(AqYo ass aint gonna find mah crazy ass clutterin any namespace!\*(Aq }", TRUE);
\&
\& ...
\&
\& call_sv(cvrv, G_VOID|G_NOARGS);
.Ve
.PP
\&\f(CW\*(C`eval_pv\*(C'\fR is used ta compile tha anonymous subroutine, which
will be tha return value as well (read mo' bout \f(CW\*(C`eval_pv\*(C'\fR in
\&\*(L"eval_pv\*(R" up in perlapi).  Once dis code reference is up in hand, it
can be mixed up in wit all tha previous examplez we've shown.
.SH "LIGHTWEIGHT CALLBACKS"
.IX Header "LIGHTWEIGHT CALLBACKS"
Sometimes you need ta invoke tha same subroutine repeatedly.
This probably happens wit a gangbangin' function dat acts on a list of
values, like fuckin Perlz built-in \fIsort()\fR. Yo ass can pass a
comparison function ta \fIsort()\fR, which will then be invoked
for every last muthafuckin pair of joints dat need ta be compared. Y'all KNOW dat shit, muthafucka! Da \fIfirst()\fR
and \fIreduce()\fR functions from List::Util follow a similar
pattern.
.PP
In dis case it is possible ta speed up tha routine (often
quite substantially) by rockin tha lightweight callback \s-1API.\s0
Da scam is dat tha callin context only need ta be
created n' destroyed once, n' tha sub can be called
arbitrarily nuff times up in between.
.PP
It be usual ta pass parametas rockin global variablez (typically
\&\f(CW$_\fR fo' one parameter, or \f(CW$a\fR n' \f(CW$b\fR fo' two parameters) rather
than via \f(CW@_\fR. (It be possible ta use tha \f(CW@_\fR mechanizzle if you know
what you bustin, though there be as yet no supported \s-1API\s0 for
it. It aint nuthin but also inherently slower.)
.PP
Da pattern of macro calls is like this:
.PP
.Vb 3
\&    dMULTICALL;                 /* Declare local variablez */
\&    I32 gimme = G_SCALAR;       /* context of tha call: G_SCALAR,
\&                                 * G_ARRAY, or G_VOID */
\&
\&    PUSH_MULTICALL(cv);         /* Set up tha context fo' callin cv,
\&                                   n' set local vars appropriately */
\&
\&    /* loop */ {
\&        /* set tha value(s) af yo' parameta variablez */
\&        MULTICALL;              /* Make tha actual call */
\&    } /* end of loop */
\&
\&    POP_MULTICALL;              /* Tear down tha callin context */
.Ve
.PP
For some concrete examples, peep tha implementation of the
\&\fIfirst()\fR n' \fIreduce()\fR functionz of List::Util 1.18. There you
will also find a header file dat emulates tha multicall \s-1API\s0
on olda versionz of perl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlxs, perlguts, perlembed
.SH "AUTHOR"
.IX Header "AUTHOR"
Pizzle Marquess
.PP
Special props ta tha followin playas whoz ass assisted up in tha creation of
the document.
.PP
Jeff Okamoto, Slim Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy
and Larry Wall.
.SH "DATE"
.IX Header "DATE"
Version 1.3, 14th Apr 1997
