.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "A2P 1"
.TH A2P 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
a2p \- Awk ta Perl translator
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBa2p\fR [\fIoptions\fR] [\fIfilename\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIA2p\fR takes a awk script specified on tha command line (or from
standard input) n' produces a cold-ass lil comparable \fIperl\fR script on the
standard output.
.SS "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
Options include:
.IP "\fB\-D<number>\fR" 5
.IX Item "-D<number>"
sets debuggin flags.
.IP "\fB\-F<character>\fR" 5
.IX Item "-F<character>"
 drops some lyrics ta a2p dat dis awk script be always invoked wit dis \fB\-F\fR
switch.
.IP "\fB\-n<fieldlist>\fR" 5
.IX Item "-n<fieldlist>"
specifies tha namez of tha input fieldz if input do not gotta be
split tha fuck into a array.  If you was translatin a awk script that
processes tha password file, you might say:
.Sp
.Vb 1
\&        a2p \-7 \-nlogin.password.uid.gid.gcos.shell.home
.Ve
.Sp
Any delimita can be used ta separate tha field names.
.IP "\fB\-<number>\fR" 5
.IX Item "-<number>"
causes a2p ta assume dat input will always have dat nuff fields.
.IP "\fB\-o\fR" 5
.IX Item "-o"
 drops some lyrics ta a2p ta use oldschool awk behavior. Shiiit, dis aint no joke.  Da only current differences are:
.RS 5
.IP "\(bu" 5
Oldskool awk always has a line loop, even if there be no line
actions, whereas freshly smoked up awk do not.
.IP "\(bu" 5
In oldschool awk, sprintf is mad greedy bout its arguments.
For example, given tha statement
.Sp
.Vb 1
\&        print sprintf(some_args), extra_args;
.Ve
.Sp
old awk considaz \fIextra_args\fR ta be arguments ta \f(CW\*(C`sprintf\*(C'\fR; freshly smoked up awk
considaz dem arguments ta \f(CW\*(C`print\*(C'\fR.
.RE
.RS 5
.RE
.ie n .SS """Considerations"""
.el .SS "``Considerations''"
.IX Subsection "Considerations"
A2p cannot do as phat a thang translatin as a human would yo, but it
usually do pretty well.  There is some areas where you may want to
examine tha perl script produced n' tweak it some.  Here is some of
them, up in no particular order.
.PP
There be a awk idiom of puttin \fIint()\fR round a strang expression to
force numeric interpretation, even though tha argument be always
integer anyway.  This is generally unneeded up in perl yo, but a2p can't
tell if tha argument be always goin ta be integer, so it leaves it
in. I aint talkin' bout chicken n' gravy biatch.  Yo ass may wish ta remove dat shit.
.PP
Perl differentiates numeric comparison from strang comparison. I aint talkin' bout chicken n' gravy biatch.  Awk
has one operator fo' both dat decides at run time which comparison to
do.  A2p do not try ta do a cold-ass lil complete thang of awk emulation at this
point.  Instead it guesses which one you want.  It aint nuthin but almost always
right yo, but it can be spoofed. Y'all KNOW dat shit, muthafucka!  All such guesses is marked wit the
comment "\f(CW\*(C`#???\*(C'\fR".  Yo ass should go all up in n' check em.  Yo ass might
wanna run at least once wit tha \fB\-w\fR switch ta perl, which will
warn you if you use == where you should have used eq.
.PP
Perl do not attempt ta emulate tha behavior of awk up in which
nonexistent array elements sprang tha fuck into existence simply by being
referenced. Y'all KNOW dat shit, muthafucka!  If somehow yo ass is relyin on dis mechanizzle ta create
null entries fo' a subsequent for...in, they won't be there up in perl.
.PP
If a2p cook up a split line dat assigns ta a list of variablez that
looks like (Fld1, Fld2, Fld3...) you may wanna rerun a2p rockin the
\&\fB\-n\fR option mentioned above.  This will let you name tha fields
all up in tha script.  If it splits ta a array instead, tha script
is probably referrin ta tha number of fieldz somewhere.
.PP
Da exit statement up in awk don't necessarily exit; it goes ta tha \s-1END\s0
block if there is one.  Awk scripts dat do contortions within tha \s-1END\s0
block ta bypass tha block under such circumstances can be simplified
by removin tha conditionizzle up in tha \s-1END\s0 block n' just exitin directly
from tha perl script.
.PP
Perl has two kindz of array, numerically-indexed n' associative.
Perl associatizzle arrays is called \*(L"hashes\*(R".  Awk arrays is usually
translated ta hashes yo, but if you happen ta know dat tha index is
always goin ta be numeric you could chizzle tha {...} ta [...].
Iteration over a hash is done rockin tha \fIkeys()\fR function yo, but iteration
over a array is \s-1NOT. \s0 Yo ass might need ta modify any loop dat iterates
over such a array.
.PP
Awk starts by assumin \s-1OFMT\s0 has tha value %.6g.  Perl starts by
assumin its equivalent, $#, ta have tha value %.20g.  You'll want to
set $# explicitly if you use tha default value of \s-1OFMT.\s0
.PP
Near tha top of tha line loop is ghon be tha split operation dat is
implicit up in tha awk script.  There is times when you can move this
down past some conditionals dat test tha entire record so dat the
split aint done as often.
.PP
For aesthetic reasons you may wish ta chizzle index variablez from being
1\-based (awk style) ta 0\-based (Perl style).  Be shizzle ta chizzle all
operations tha variable is involved up in ta match.
.PP
Cute comments dat say \*(L"# Here be a workaround cuz awk is dumb\*(R"
are passed all up in unmodified.
.PP
Awk scripts is often embedded up in a gangbangin' finger-lickin' dirty-ass shell script dat pipes shiznit into
and outta awk.  Often tha shell script wrapper can be incorporated
into tha perl script, since perl can start up pipes tha fuck into n' up of
itself, n' can do other thangs dat awk can't do by itself.
.PP
Scripts dat refer ta tha special variablez \s-1RSTART\s0 n' \s-1RLENGTH\s0 can
often be simplified by referrin ta tha variablez $`, $& n' $', as
long as they is within tha scope of tha pattern match dat sets em.
.PP
Da produced perl script may have subroutines defined ta deal with
awkz semantics regardin getline n' print.  Since a2p probably picks
correctnizz over efficiency.  it be almost always possible ta rewrite
such code ta be mo' efficient by discardin tha semantic sugar.
.PP
For efficiency, you may wish ta remove tha keyword from any return
statement dat is tha last statement executed up in a subroutine.  A2p
catches da most thugged-out common case yo, but don't analyze embedded blocks for
subtla cases.
.PP
ARGV[0] translates ta \f(CW$ARGV0\fR yo, but ARGV[n] translates ta \f(CW$ARGV\fR[$n\-1].  A
loop dat tries ta iterate over ARGV[0] won't find dat shit.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
A2p uses no environment variables.
.SH "AUTHOR"
.IX Header "AUTHOR"
Larry Wall <\fIlarry@wall.org\fR>
.SH "FILES"
.IX Header "FILES"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\& perl   Da perl compiler/interpreter
\&
\& s2p    sed ta perl translator
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.SH "BUGS"
.IX Header "BUGS"
It would be possible ta emulate awkz behavior up in selectin string
versus numeric operations at run time by inspection of tha operands,
but it would be gross n' inefficient.  Besides, a2p almost always
guesses right.
.PP
Storage fo' tha awk syntax tree is currently static, n' can run out.
