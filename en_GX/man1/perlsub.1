.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLSUB 1"
.TH PERLSUB 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlsub \- Perl subroutines
.IX Xref "subroutine function"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
To declare subroutines:
.IX Xref "subroutine, declaration sub"
.PP
.Vb 4
\&    sub NAME;                     # A "forward" declaration.
\&    sub NAME(PROTO);              #  ditto yo, but wit prototypes
\&    sub NAME : ATTRS;             #  wit attributes
\&    sub NAME(PROTO) : ATTRS;      #  wit attributes n' prototypes
\&
\&    sub NAME BLOCK                # A declaration n' a thugged-out definition.
\&    sub NAME(PROTO) BLOCK         #  ditto yo, but wit prototypes
\&    sub NAME : ATTRS BLOCK        #  wit attributes
\&    sub NAME(PROTO) : ATTRS BLOCK #  wit prototypes n' attributes
.Ve
.PP
To define a anonymous subroutine at runtime:
.IX Xref "subroutine, anonymous"
.PP
.Vb 4
\&    $subref = sub BLOCK;                 # no proto
\&    $subref = sub (PROTO) BLOCK;         # wit proto
\&    $subref = sub : ATTRS BLOCK;         # wit attributes
\&    $subref = sub (PROTO) : ATTRS BLOCK; # wit proto n' attributes
.Ve
.PP
To import subroutines:
.IX Xref "import"
.PP
.Vb 1
\&    use MODULE qw(NAME1 NAME2 NAME3);
.Ve
.PP
To call subroutines:
.IX Xref "subroutine, call call"
.PP
.Vb 4
\&    NAME(LIST);    # & is optionizzle wit parentheses.
\&    NAME LIST;     # Parentheses optionizzle if predeclared/imported.
\&    &NAME(LIST);   # Circumvent prototypes.
\&    &NAME;         # Makes current @_ visible ta called subroutine.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Like nuff languages, Perl serves up fo' user-defined subroutines.
These may be located anywhere up in tha main program, loaded up in from
other filez via tha \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR keywords, or
generated on tha fly rockin \f(CW\*(C`eval\*(C'\fR or anonymous subroutines.
Yo ass can even call a gangbangin' function indirectly rockin a variable containing
its name or a \s-1CODE\s0 reference.
.PP
Da Perl model fo' function call n' return joints is simple: all
functions is passed as parametas one single flat list of scalars, and
all functions likewise return ta they calla one single flat list of
scalars.  Any arrays or hashes up in these call n' return lists will
collapse, losin they identities\*(--but you may always use
pass-by-reference instead ta avoid all dis bullshit.  Both call n' return lists may
contain as nuff or as few scalar elements as you'd like.  (Often a
function without a explicit return statement is called a subroutine yo, but
therez straight-up no difference from Perlz perspective.)
.IX Xref "subroutine, parameta parameter"
.PP
Any arguments passed up in show up in tha array \f(CW@_\fR.  Therefore, if
you called a gangbangin' function wit two arguments, dem would be stored in
\&\f(CW$_[0]\fR n' \f(CW$_[1]\fR.  Da array \f(CW@_\fR be a local array yo, but its
elements is aliases fo' tha actual scalar parameters.  In particular,
if a element \f(CW$_[0]\fR is updated, tha correspondin argument is
updated (or a error occurs if it aint updatable).  If a argument
is a array or hash element which did not exist when tha function
was called, dat element is pimped only when (and if) it is modified
or a reference ta it is taken. I aint talkin' bout chicken n' gravy biatch.  (Some earlier versionz of Perl
created tha element whether or not tha element was assigned to.)
Assignin ta tha whole array \f(CW@_\fR removes dat aliasing, n' do
not update any arguments.
.IX Xref "subroutine, argument argument @_"
.PP
A \f(CW\*(C`return\*(C'\fR statement may be used ta exit a subroutine, optionally
specifyin tha returned value, which is ghon be evaluated up in the
appropriate context (list, scalar, or void) dependin on tha context of
the subroutine call.  If you specify no return value, tha subroutine
returns a empty list up in list context, tha undefined value up in scalar
context, or not a god damn thang up in void context.  If you return one or more
aggregates (arrays n' hashes), these is ghon be flattened together into
one big-ass indistinguishable list.
.PP
If no \f(CW\*(C`return\*(C'\fR is found n' if tha last statement be a expression, its
value is returned. Y'all KNOW dat shit, muthafucka! If tha last statement be a loop control structure
like a \f(CW\*(C`foreach\*(C'\fR or a \f(CW\*(C`while\*(C'\fR, tha returned value is unspecified. Y'all KNOW dat shit, muthafucka! The
empty sub returns tha empty list.
.IX Xref "subroutine, return value return value return"
.PP
Perl aint gots named formal parameters.  In practice all you
do be assign ta a \f(CW\*(C`my()\*(C'\fR list of these n' you can put dat on yo' toast.  Variablez dat aren't
declared ta be private is global variables.  For gory details
on bustin private variables, peep \*(L"Private Variablez via \fImy()\fR\*(R"
and \*(L"Temporary Values via \fIlocal()\fR\*(R".  To create protected
environments fo' a set of functions up in a separate package (and
probably a separate file), peep \*(L"Packages\*(R" up in perlmod.
.IX Xref "formal parameta parameter, formal"
.PP
Example:
.PP
.Vb 8
\&    sub max {
\&        mah $max = shift(@_);
\&        foreach $foo (@_) {
\&            $max = $foo if $max < $foo;
\&        }
\&        return $max;
\&    }
\&    $bestdizzle = max($mon,$tue,$wed,$thu,$fri);
.Ve
.PP
Example:
.PP
.Vb 2
\&    # git a line, combinin continuation lines
\&    #  dat start wit whitespace
\&
\&    sub get_line {
\&        $thisline = $lookahead;  # global variables!
\&        LINE: while (defined($lookahead = <STDIN>)) {
\&            if ($lookahead =~ /^[ \et]/) {
\&                $thisline .= $lookahead;
\&            }
\&            else {
\&                last LINE;
\&            }
\&        }
\&        return $thisline;
\&    }
\&
\&    $lookahead = <STDIN>;       # git first line
\&    while (defined($line = get_line())) {
\&        ...
\&    }
.Ve
.PP
Assignin ta a list of private variablez ta name yo' arguments:
.PP
.Vb 4
\&    sub maybeset {
\&        my($key, $value) = @_;
\&        $Foo{$key} = $value unless $Foo{$key};
\&    }
.Ve
.PP
Because tha assignment copies tha joints, dis also has tha effect
of turnin call-by-reference tha fuck into call-by-value.  Otherwise a
function is free ta do in-place modificationz of \f(CW@_\fR n' chizzle
its callerz joints.
.IX Xref "call-by-reference call-by-value"
.PP
.Vb 4
\&    upcase_in($v1, $v2);  # dis chizzlez $v1 n' $v2
\&    sub upcase_in {
\&        fo' (@_) { tr/a\-z/A\-Z/ }
\&    }
.Ve
.PP
Yo ass aren't allowed ta modify constants up in dis way, of course.  If an
argument was straight-up literal n' you tried ta chizzle it, you'd take a
(presumably fatal) exception. I aint talkin' bout chicken n' gravy biatch.   For example, dis won't work:
.IX Xref "call-by-reference call-by-value"
.PP
.Vb 1
\&    upcase_in("frederick");
.Ve
.PP
It would be much less thuggy if tha \f(CW\*(C`upcase_in()\*(C'\fR function
were freestyled ta return a cold-ass lil copy of its parametas instead
of changin dem up in place:
.PP
.Vb 7
\&    ($v3, $v4) = upcase($v1, $v2);  # dis don\*(Aqt chizzle $v1 n' $v2
\&    sub upcase {
\&        return unless defined wantarray;  # void context, do nothing
\&        mah @parms = @_;
\&        fo' (@parms) { tr/a\-z/A\-Z/ }
\&        return wantarray , biatch? @parms : $parms[0];
\&    }
.Ve
.PP
Notice how tha fuck dis (unprototyped) function don't care whether it was
passed real scalars or arrays.  Perl sees all arguments as one big,
long, flat parameta list up in \f(CW@_\fR.  This is one area where
Perlz simple argument-passin steez shines.  Da \f(CW\*(C`upcase()\*(C'\fR
function would work perfectly well without changin tha \f(CW\*(C`upcase()\*(C'\fR
definizzle even if we fed it thangs like this:
.PP
.Vb 2
\&    @newlist   = upcase(@list1, @list2);
\&    @newlist   = upcase( split /:/, $var );
.Ve
.PP
Do not, however, be tempted ta do this:
.PP
.Vb 1
\&    (@a, @b)   = upcase(@list1, @list2);
.Ve
.PP
Like tha flattened incomin parameta list, tha return list be also
flattened on return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  So all you have managed ta do here is stored
everythang up in \f(CW@a\fR n' made \f(CW@b\fR empty.  See 
\&\*(L"Pass by Reference\*(R" fo' alternatives.
.PP
A subroutine may be called rockin a explicit \f(CW\*(C`&\*(C'\fR prefix.  The
\&\f(CW\*(C`&\*(C'\fR is optionizzle up in modern Perl, as is parentheses if the
subroutine has been predeclared. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`&\*(C'\fR is \fInot\fR optional
when just namin tha subroutine, like fuckin when itz used as
an argument ta \fIdefined()\fR or \fIundef()\fR.  Nor is it optionizzle when you
wanna do a indirect subroutine call wit a subroutine name or
reference rockin tha \f(CW\*(C`&$subref()\*(C'\fR or \f(CW\*(C`&{$subref}()\*(C'\fR constructs,
although tha \f(CW\*(C`$subref\->()\*(C'\fR notation solves dat problem.
See perlref fo' mo' bout all dis shit.
.IX Xref "&"
.PP
Subroutines may be called recursively.  If a subroutine is called
usin tha \f(CW\*(C`&\*(C'\fR form, tha argument list is optional, n' if omitted,
no \f(CW@_\fR array is set up fo' tha subroutine: tha \f(CW@_\fR array at the
time of tha call is visible ta subroutine instead. Y'all KNOW dat shit, muthafucka!  This be an
efficiency mechanizzle dat freshly smoked up playas may wish ta avoid.
.IX Xref "recursion"
.PP
.Vb 2
\&    &foo(1,2,3);        # pass three arguments
\&    foo(1,2,3);         # tha same
\&
\&    foo();              # pass a null list
\&    &foo();             # tha same
\&
\&    &foo;               # foo() git current args, like foo(@_) !!
\&    foo;                # like foo() IFF sub foo predeclared, else "foo"
.Ve
.PP
Not only do tha \f(CW\*(C`&\*(C'\fR form make tha argument list optional, it also
disablez any prototype checkin on arguments you do provide.  This
is kinda fo' oldschool reasons, n' kinda fo' havin a cold-ass lil convenient way
to cheat if you know what tha fuck you bustin.  See \*(L"Prototypes\*(R" below.
.IX Xref "&"
.PP
Since Perl 5.16.0, tha \f(CW\*(C`_\|_SUB_\|_\*(C'\fR token be available under \f(CW\*(C`use feature
\&\*(Aqcurrent_sub\*(Aq\*(C'\fR n' \f(CW\*(C`use 5.16.0\*(C'\fR.  It will evaluate ta a reference ta the
currently-runnin sub, which allows fo' recursive calls without knowing
your subroutinez name.
.PP
.Vb 6
\&    use 5.16.0;
\&    mah $factorial = sub {
\&      mah ($x) = @_;
\&      return 1 if $x == 1;
\&      return($x * _\|_SUB_\|_\->( $x \- 1 ) );
\&    };
.Ve
.PP
Da behaviour of \f(CW\*(C`_\|_SUB_\|_\*(C'\fR within a regex code block (like fuckin \f(CW\*(C`/(?{...})/\*(C'\fR)
is subject ta chizzle.
.PP
Subroutines whose names is up in all upper case is reserved ta tha Perl
core, as is modulez whose names is up in all lower case.  A subroutine in
all capitals be a loosely-held convention meanin it is ghon be called
indirectly by tha run-time system itself, probably cuz of a triggered event.
Subroutines dat do special, pre-defined thangs include \f(CW\*(C`AUTOLOAD\*(C'\fR, \f(CW\*(C`CLONE\*(C'\fR,
\&\f(CW\*(C`DESTROY\*(C'\fR plus all functions mentioned up in perltie n' PerlIO::via.
.PP
Da \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR, \f(CW\*(C`INIT\*(C'\fR n' \f(CW\*(C`END\*(C'\fR subroutines
are not so much subroutines as named special code blocks, of which you
can have mo' than one up in a package, n' which you can \fBnot\fR call
explicitly.  See \*(L"\s-1BEGIN, UNITCHECK, CHECK, INIT\s0 n' \s-1END\*(R"\s0 up in perlmod
.SS "Private Variablez via \fImy()\fP"
.IX Xref "my variable, lexical lexical lexical variable scope, lexical lexical scope attributes, my"
.IX Subsection "Private Variablez via my()"
Synopsis:
.PP
.Vb 5
\&    mah $foo;            # declare $foo lexically local
\&    mah (@wid, %get);    # declare list of variablez local
\&    mah $foo = "flurp";  # declare $foo lexical, n' init it
\&    mah @oof = @bar;     # declare @oof lexical, n' init it
\&    mah $x : Foo = $y;   # similar, wit a attribute applied
.Ve
.PP
\&\fB\s-1WARNING\s0\fR: Da use of attribute lists on \f(CW\*(C`my\*(C'\fR declarations is still
evolving.  Da current semantics n' intercourse is subject ta chizzle.
See attributes n' Attribute::Handlezs.
.PP
Da \f(CW\*(C`my\*(C'\fR operator declares tha listed variablez ta be lexically
confined ta tha enclosin block, conditionizzle (\f(CW\*(C`if/unless/elsif/else\*(C'\fR),
loop (\f(CW\*(C`for/foreach/while/until/continue\*(C'\fR), subroutine, \f(CW\*(C`eval\*(C'\fR,
or \f(CW\*(C`do/require/use\*(C'\fR'd file.  If mo' than one value is listed, the
list must be placed up in parentheses.  All listed elements must be
legal lvalues.  Only alphanumeric identifiers may be lexically
scoped\*(--magical built-ins like \f(CW$/\fR must currently be \f(CW\*(C`local\*(C'\fRized
with \f(CW\*(C`local\*(C'\fR instead.
.PP
Unlike dynamic variablez pimped by tha \f(CW\*(C`local\*(C'\fR operator, lexical
variablez declared wit \f(CW\*(C`my\*(C'\fR is straight-up hidden from tha outside
world, includin any called subroutines.  This is legit if itz the
same subroutine called from itself or elsewhere\*(--every call gets
its own copy.
.IX Xref "local"
.PP
This don't mean dat a \f(CW\*(C`my\*(C'\fR variable declared up in a statically
enclosin lexical scope would be invisible.  Only dynamic scopes
are cut off.   For example, tha \f(CW\*(C`bumpx()\*(C'\fR function below has access
to tha lexical \f(CW$x\fR variable cuz both tha \f(CW\*(C`my\*(C'\fR n' tha \f(CW\*(C`sub\*(C'\fR
occurred all up in tha same scope, presumably file scope.
.PP
.Vb 2
\&    mah $x = 10;
\&    sub bumpx { $x++ }
.Ve
.PP
An \f(CW\*(C`eval()\*(C'\fR, however, can peep lexical variablez of tha scope it is
bein evaluated in, so long as tha names aren't hidden by declarations within
the \f(CW\*(C`eval()\*(C'\fR itself.  See perlref.
.IX Xref "eval, scope of"
.PP
Da parameta list ta \fImy()\fR may be assigned ta if desired, which allows you
to initialize yo' variables.  (If no initializer is given fo' a
particular variable, it is pimped wit tha undefined value.)  Commonly
this is used ta name input parametas ta a subroutine.  Examples:
.PP
.Vb 4
\&    $arg = "fred";        # "global" variable
\&    $n = cube_root(27);
\&    print "$arg be thinkin tha root is $n\en";
\& fred be thinkin tha root is 3
\&
\&    sub cube_root {
\&        mah $arg = shift;  # name don\*(Aqt matter
\&        $arg **= 1/3;
\&        return $arg;
\&    }
.Ve
.PP
Da \f(CW\*(C`my\*(C'\fR is simply a modifier on suttin' you might assign to.  So when
you do assign ta variablez up in its argument list, \f(CW\*(C`my\*(C'\fR don't
change whether dem variablez is viewed as a scalar or a array.  So
.PP
.Vb 2
\&    mah ($foo) = <STDIN>;                # WRONG?
\&    mah @FOO = <STDIN>;
.Ve
.PP
both supply a list context ta tha right-hand side, while
.PP
.Vb 1
\&    mah $foo = <STDIN>;
.Ve
.PP
supplies a scalar context.  But tha followin declares only one variable:
.PP
.Vb 1
\&    mah $foo, $bar = 1;                  # WRONG
.Ve
.PP
That has tha same ol' dirty effect as
.PP
.Vb 2
\&    mah $foo;
\&    $bar = 1;
.Ve
.PP
Da declared variable aint introduced (is not visible) until after
the current statement.  Thus,
.PP
.Vb 1
\&    mah $x = $x;
.Ve
.PP
can be used ta initialize a freshly smoked up \f(CW$x\fR wit tha value of tha oldschool \f(CW$x\fR, and
the expression
.PP
.Vb 1
\&    mah $x = 123 n' $x == 123
.Ve
.PP
is false unless tha oldschool \f(CW$x\fR happened ta have tha value \f(CW123\fR.
.PP
Lexical scopez of control structures is not bounded precisely by the
braces dat delimit they controlled blocks; control expressions are
part of dat scope, like a muthafucka.  Thus up in tha loop
.PP
.Vb 5
\&    while (my $line = <>) {
\&        $line = lc $line;
\&    } continue {
\&        print $line;
\&    }
.Ve
.PP
the scope of \f(CW$line\fR extendz from its declaration all up in tha rest of
the loop construct (includin tha \f(CW\*(C`continue\*(C'\fR clause) yo, but not beyond
it.  Similarly, up in tha conditional
.PP
.Vb 8
\&    if ((my $answer = <STDIN>) =~ /^yes$/i) {
\&        user_agrees();
\&    } elsif ($answer =~ /^no$/i) {
\&        user_disagrees();
\&    } else {
\&        chomp $answer;
\&        take a thugged-out dirtnap "\*(Aq$answer\*(Aq is neither \*(Aqyes\*(Aq nor \*(Aqno\*(Aq";
\&    }
.Ve
.PP
the scope of \f(CW$answer\fR extendz from its declaration all up in tha rest
of dat conditional, includin any \f(CW\*(C`elsif\*(C'\fR n' \f(CW\*(C`else\*(C'\fR clauses, 
but not beyond dat shit.  See \*(L"Simple Statements\*(R" up in perlsyn fo' shiznit
on tha scope of variablez up in statements wit modifiers.
.PP
Da \f(CW\*(C`foreach\*(C'\fR loop defaults ta scopin its index variable dynamically
in tha manner of \f(CW\*(C`local\*(C'\fR.  But fuck dat shiznit yo, tha word on tha street is dat if tha index variable is
prefixed wit tha keyword \f(CW\*(C`my\*(C'\fR, or if there be already a lexical
by dat name up in scope, then a freshly smoked up lexical is pimped instead. Y'all KNOW dat shit, muthafucka!  Thus
in tha loop
.IX Xref "foreach for"
.PP
.Vb 3
\&    fo' mah $i (1, 2, 3) {
\&        some_function();
\&    }
.Ve
.PP
the scope of \f(CW$i\fR extendz ta tha end of tha loop yo, but not beyond it,
renderin tha value of \f(CW$i\fR inaccessible within \f(CW\*(C`some_function()\*(C'\fR.
.IX Xref "foreach for"
.PP
Some playas may wish ta encourage tha use of lexically scoped variables.
As a aid ta catchin implicit uses ta package variables,
which is always global, if you say
.PP
.Vb 1
\&    use strict \*(Aqvars\*(Aq;
.Ve
.PP
then any variable mentioned from there ta tha end of tha enclosing
block must either refer ta a lexical variable, be predeclared via
\&\f(CW\*(C`our\*(C'\fR or \f(CW\*(C`use vars\*(C'\fR, or else must be straight-up qualified wit tha package name.
A compilation error thangs up in dis biatch otherwise.  An inner block may countermand
this wit \f(CW\*(C`no strict \*(Aqvars\*(Aq\*(C'\fR.
.PP
A \f(CW\*(C`my\*(C'\fR has both a cold-ass lil compile-time n' a run-time effect.  At compile
time, tha compila takes notice of dat shit.  Da principal usefulness
of dis is ta on tha down-low \f(CW\*(C`use strict \*(Aqvars\*(Aq\*(C'\fR yo, but it be also essential
for generation of closures as detailed up in perlref.  Actual
initialization is delayed until run time, though, so it gets executed
at tha appropriate time, like fuckin each time all up in a loop, for
example.
.PP
Variablez declared wit \f(CW\*(C`my\*(C'\fR is not part of any package n' is therefore
never straight-up qualified wit tha package name.  In particular, you not
allowed ta try ta cook up a package variable (or other global) lexical:
.PP
.Vb 1
\&    mah $pack::var;      # ERROR!  Illegal syntax
.Ve
.PP
In fact, a thugged-out dynamic variable (also known as package or global variables)
are still accessible rockin tha straight-up qualified \f(CW\*(C`::\*(C'\fR notation even while a
lexical of tha same name be also visible:
.PP
.Vb 4
\&    package main;
\&    local $x = 10;
\&    mah    $x = 20;
\&    print "$x n' $::x\en";
.Ve
.PP
That will print up \f(CW20\fR n' \f(CW10\fR.
.PP
Yo ass may declare \f(CW\*(C`my\*(C'\fR variablez all up in tha outermost scope of a gangbangin' file
to hide any such identifiers from tha ghetto outside dat file.  This
is similar up in spirit ta Cz static variablez when they is used at
the file level.  To do dis wit a subroutine requires tha use of
a closure (an anonymous function dat accesses enclosin lexicals).
If you wanna create a private subroutine dat cannot be called
from outside dat block, it can declare a lexical variable containing
an anonymous sub reference:
.PP
.Vb 3
\&    mah $secret_version = \*(Aq1.001\-beta\*(Aq;
\&    mah $secret_sub = sub { print $secret_version };
\&    &$secret_sub();
.Ve
.PP
As long as tha reference is never returned by any function within the
module, no outside module can peep tha subroutine, cuz its name aint in
any packagez symbol table.  Remember dat it aint \fI\s-1REALLY\s0\fR called
\&\f(CW$some_pack::secret_version\fR or anything; itz just \f(CW$secret_version\fR,
unqualified n' unqualifiable.
.PP
This do not work wit object methods, however; all object methods
have ta be up in tha symbol table of some package ta be found. Y'all KNOW dat shit, muthafucka!  See
\&\*(L"Function Templates\*(R" up in perlref fo' suttin' of a work-around to
this.
.SS "Persistent Private Variables"
.IX Xref "state state variable static variable, persistent variable, static closure"
.IX Subsection "Persistent Private Variables"
There is two ways ta build persistent private variablez up in Perl 5.10.
First, you can simply use tha \f(CW\*(C`state\*(C'\fR feature. Or, you can use closures,
if you wanna stay compatible wit releases olda than 5.10.
.PP
\fIPersistent variablez via \fIstate()\fI\fR
.IX Subsection "Persistent variablez via state()"
.PP
Beginnin wit Perl 5.10.0, you can declare variablez wit tha \f(CW\*(C`state\*(C'\fR
keyword up in place of \f(CW\*(C`my\*(C'\fR.  For dat ta work, though, you must have
enabled dat feature beforehand, either by rockin tha \f(CW\*(C`feature\*(C'\fR pragma, or
by rockin \f(CW\*(C`\-E\*(C'\fR on one-liners (see feature).  Beginnin wit Perl 5.16,
the \f(CW\*(C`CORE::state\*(C'\fR form do not require the
\&\f(CW\*(C`feature\*(C'\fR pragma.
.PP
Da \f(CW\*(C`state\*(C'\fR keyword creates a lexical variable (followin tha same scoping
rulez as \f(CW\*(C`my\*(C'\fR) dat persists from one subroutine call ta tha next.  If a
state variable resides inside a anonymous subroutine, then each copy of
the subroutine has its own copy of tha state variable.  But fuck dat shiznit yo, tha word on tha street is dat tha value
of tha state variable will still persist between calls ta tha same copy of
the anonymous subroutine.  (Don't forget dat \f(CW\*(C`sub { ... }\*(C'\fR creates a new
subroutine each time it is executed.)
.PP
For example, tha followin code maintains a private counter, incremented
each time tha \fIgimme_another()\fR function is called:
.PP
.Vb 2
\&    use feature \*(Aqstate\*(Aq;
\&    sub gimme_another { state $x; return ++$x }
.Ve
.PP
And dis example uses anonymous subroutines ta create separate counters:
.PP
.Vb 4
\&    use feature \*(Aqstate\*(Aq;
\&    sub create_counta {
\&        return sub { state $x; return ++$x }
\&    }
.Ve
.PP
Also, since \f(CW$x\fR is lexical, it can't be reached or modified by any Perl
code outside.
.PP
When combined wit variable declaration, simple scalar assignment ta \f(CW\*(C`state\*(C'\fR
variablez (as up in \f(CW\*(C`state $x = 42\*(C'\fR) is executed only tha last time.  When such
statements is evaluated subsequent times, tha assignment is ignored. Y'all KNOW dat shit, muthafucka!  The
behavior of dis sort of assignment ta non-scalar variablez is undefined.
.PP
\fIPersistent variablez wit closures\fR
.IX Subsection "Persistent variablez wit closures"
.PP
Just cuz a lexical variable is lexically (also called statically)
scoped ta its enclosin block, \f(CW\*(C`eval\*(C'\fR, or \f(CW\*(C`do\*(C'\fR \s-1FILE,\s0 dis don't mean that
within a gangbangin' function it works like a C static.  It normally works more
like a C auto yo, but wit implicit garbage collection.
.PP
Unlike local variablez up in C or \*(C+, Perlz lexical variablez don't
necessarily git recycled just cuz they scope has exited.
If suttin' mo' permanent is still aware of tha lexical, it will
stick around. Y'all KNOW dat shit, muthafucka!  So long as suttin' else references a lexical, that
lexical won't be freed\*(--which be as it should be.  Yo ass wouldn't want
memory bein free until you was done rockin it, or kept round once you
were done.  Automatic garbage collection takes care of dis fo' yo thugged-out ass.
.PP
This means dat you can pass back or save away references ta lexical
variables, whereas ta return a pointa ta a C auto be a grave error.
It also gives our asses a way ta simulate Cz function statics.  Herez a
mechanizzle fo' givin a gangbangin' function private variablez wit both lexical
scopin n' a static gametime.  If you do wanna create suttin' like
Cz static variables, just enclose tha whole function up in a extra block,
and put tha static variable outside tha function but up in tha block.
.PP
.Vb 8
\&    {
\&        mah $secret_val = 0;
\&        sub gimme_another {
\&            return ++$secret_val;
\&        }
\&    }
\&    # $secret_val now becomes unreachable by tha outside
\&    # ghetto yo, but retains its value between calls ta gimme_another
.Ve
.PP
If dis function is bein sourced up in from a separate file
via \f(CW\*(C`require\*(C'\fR or \f(CW\*(C`use\*(C'\fR, then dis is probably just fine.  If it's
all up in tha main program, you gonna need ta arrange fo' tha \f(CW\*(C`my\*(C'\fR
to be executed early, either by puttin tha whole block above
your main program, or mo' likely, placin merely a \f(CW\*(C`BEGIN\*(C'\fR
code block round it ta make shizzle it gets executed before yo' program
starts ta run:
.PP
.Vb 6
\&    BEGIN {
\&        mah $secret_val = 0;
\&        sub gimme_another {
\&            return ++$secret_val;
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1BEGIN, UNITCHECK, CHECK, INIT\s0 n' \s-1END\*(R"\s0 up in perlmod bout the
special triggered code blocks, \f(CW\*(C`BEGIN\*(C'\fR, \f(CW\*(C`UNITCHECK\*(C'\fR, \f(CW\*(C`CHECK\*(C'\fR,
\&\f(CW\*(C`INIT\*(C'\fR n' \f(CW\*(C`END\*(C'\fR.
.PP
If declared all up in tha outermost scope (the file scope), then lexicals
work somewhat like Cz file statics.  They is available ta all
functions up in dat same file declared below dem yo, but is inaccessible
from outside dat file.  This game is sometimes used up in modules
to create private variablez dat tha whole module can see.
.SS "Temporary Values via \fIlocal()\fP"
.IX Xref "local scope, dynamic dynamic scope variable, local variable, temporary"
.IX Subsection "Temporary Values via local()"
\&\fB\s-1WARNING\s0\fR: In general, you should be rockin \f(CW\*(C`my\*(C'\fR instead of \f(CW\*(C`local\*(C'\fR, cuz
itz fasta n' less thuggy n' shit.  Exceptions ta dis include tha global punctuation
variables, global filehandlez n' formats, n' direct manipulation of the
Perl symbol table itself.  \f(CW\*(C`local\*(C'\fR is mostly used when tha current value
of a variable must be visible ta called subroutines.
.PP
Synopsis:
.PP
.Vb 1
\&    # localization of joints
\&
\&    local $foo;                 # make $foo dynamically local
\&    local (@wid, %get);         # make list of variablez local
\&    local $foo = "flurp";       # make $foo dynamic, n' init it
\&    local @oof = @bar;          # make @oof dynamic, n' init it
\&
\&    local $hash{key} = "val";   # sets a local value fo' dis hash entry
\&    delete local $hash{key};    # delete dis entry fo' tha current block
\&    local ($cond , biatch? $v1 : $v2);  # nuff muthafuckin typez of lvalues support
\&                                # localization
\&
\&    # localization of symbols
\&
\&    local *FH;                  # localize $FH, @FH, %FH, &FH  ...
\&    local *merlyn = *randal;    # now $merlyn is straight-up $randal, plus
\&                                #     @merlyn is straight-up @randal, etc
\&    local *merlyn = \*(Aqrandal\*(Aq;   # SAME THING: promote \*(Aqrandal\*(Aq ta *randal
\&    local *merlyn = \e$randal;   # just alias $merlyn, not @merlyn etc
.Ve
.PP
A \f(CW\*(C`local\*(C'\fR modifies its listed variablez ta be \*(L"local\*(R" ta the
enclosin block, \f(CW\*(C`eval\*(C'\fR, or \f(CW\*(C`do FILE\*(C'\fR\-\-and ta \fIany subroutine
called from within dat block\fR.  A \f(CW\*(C`local\*(C'\fR just gives temporary
values ta global (meanin package) variables.  It do \fInot\fR create
a local variable.  This is known as dynamic scoping.  Lexical scoping
is done wit \f(CW\*(C`my\*(C'\fR, which works mo' like Cz auto declarations.
.PP
Some typez of lvalues can be localized as well: hash n' array elements
and slices, conditionals (provided dat they result be always
localizable), n' symbolic references.  As fo' simple variables, this
creates new, dynamically scoped joints.
.PP
If mo' than one variable or expression is given ta \f(CW\*(C`local\*(C'\fR, they must be
placed up in parentheses.  This operator works
by savin tha current jointz of dem variablez up in its argument list on a
hidden stack n' restorin dem upon exitin tha block, subroutine, or
eval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This means dat called subroutines can also reference tha local
variable yo, but not tha global one.  Da argument list may be assigned ta if
desired, which allows you ta initialize yo' local variables.  (If no
initializer is given fo' a particular variable, it is pimped wit an
undefined value.)
.PP
Because \f(CW\*(C`local\*(C'\fR be a run-time operator, it gets executed each time
all up in a loop.  Consequently, itz mo' efficient ta localize your
variablez outside tha loop.
.PP
\fIGrammatical note on \fIlocal()\fI\fR
.IX Xref "local, context"
.IX Subsection "Grammatical note on local()"
.PP
A \f(CW\*(C`local\*(C'\fR is simply a modifier on a lvalue expression. I aint talkin' bout chicken n' gravy biatch.  When you assign to
a \f(CW\*(C`local\*(C'\fRized variable, tha \f(CW\*(C`local\*(C'\fR don't chizzle whether its list is viewed
as a scalar or a array.  So
.PP
.Vb 2
\&    local($foo) = <STDIN>;
\&    local @FOO = <STDIN>;
.Ve
.PP
both supply a list context ta tha right-hand side, while
.PP
.Vb 1
\&    local $foo = <STDIN>;
.Ve
.PP
supplies a scalar context.
.PP
\fILocalization of special variables\fR
.IX Xref "local, special variable"
.IX Subsection "Localization of special variables"
.PP
If you localize a special variable, you gonna be givin a freshly smoked up value ta it,
but its magic won't go away.  That means dat all side-effects related
to dis magic still work wit tha localized value.
.PP
This feature allows code like dis ta work :
.PP
.Vb 2
\&    # Read tha whole contentz of FILE up in $slurp
\&    { local $/ = undef; $slurp = <FILE>; }
.Ve
.PP
Note, however, dat dis restricts localization of some joints ; for
example, tha followin statement dies, az of perl 5.10.0, wit a error
\&\fIModification of a read-only value attempted\fR, cuz tha \f(CW$1\fR variable is
magical n' read-only :
.PP
.Vb 1
\&    local $1 = 2;
.Ve
.PP
One exception is tha default scalar variable: startin wit perl 5.14
\&\f(CW\*(C`local($_)\*(C'\fR will always strip all magic from \f(CW$_\fR, ta make it possible
to safely reuse \f(CW$_\fR up in a subroutine.
.PP
\&\fB\s-1WARNING\s0\fR: Localization of tied arrays n' hashes do not currently
work as busted lyrics about.
This is ghon be fixed up in a gangbangin' future release of Perl; up in tha meantime, avoid
code dat relies on any particular behaviour of localisin tied arrays
or hashes (localisin individual elements is still aiiight).
See \*(L"Localisin Tied Arrays n' Hashes Is Broken\*(R" up in perl58delta fo' more
details.
.IX Xref "local, tie"
.PP
\fILocalization of globs\fR
.IX Xref "local, glob glob"
.IX Subsection "Localization of globs"
.PP
Da construct
.PP
.Vb 1
\&    local *name;
.Ve
.PP
creates a whole freshly smoked up symbol table entry fo' tha glob \f(CW\*(C`name\*(C'\fR up in the
current package.  That means dat all variablez up in its glob slot ($name,
\&\f(CW@name\fR, \f(CW%name\fR, &name, n' tha \f(CW\*(C`name\*(C'\fR filehandle) is dynamically reset.
.PP
This implies, among other thangs, dat any magic eventually carried by
those variablez is locally lost.  In other lyrics, sayin \f(CW\*(C`local */\*(C'\fR
will not have any effect on tha internal value of tha input record
separator.
.PP
\fILocalization of elementz of composite types\fR
.IX Xref "local, composite type element local, array element local, hash element"
.IX Subsection "Localization of elementz of composite types"
.PP
It aint nuthin but also worth takin a moment ta explain what tha fuck happens when you
\&\f(CW\*(C`local\*(C'\fRize a gangmember of a cold-ass lil composite type (i.e. a array or hash element).
In dis case, tha element is \f(CW\*(C`local\*(C'\fRized \fIby name\fR. This means that
when tha scope of tha \f(CW\*(C`local()\*(C'\fR ends, tha saved value will be
restored ta tha hash element whose key was named up in tha \f(CW\*(C`local()\*(C'\fR, or
the array element whose index was named up in tha \f(CW\*(C`local()\*(C'\fR.  If that
element was deleted while tha \f(CW\*(C`local()\*(C'\fR was up in effect (e.g. by a
\&\f(CW\*(C`delete()\*(C'\fR from a hash or a \f(CW\*(C`shift()\*(C'\fR of a array), it will spring
back tha fuck into existence, possibly extendin a array n' fillin up in the
skipped elements wit \f(CW\*(C`undef\*(C'\fR.  For instance, if you say
.PP
.Vb 10
\&    %hash = ( \*(AqThis\*(Aq => \*(Aqis\*(Aq, \*(Aqa\*(Aq => \*(Aqtest\*(Aq );
\&    @ary  = ( 0..5 );
\&    {
\&         local($ary[5]) = 6;
\&         local($hash{\*(Aqa\*(Aq}) = \*(Aqdrill\*(Aq;
\&         while (my $e = pop(@ary)) {
\&             print "$e . . .\en";
\&             last unless $e > 3;
\&         }
\&         if (@ary) {
\&             $hash{\*(Aqonly a\*(Aq} = \*(Aqtest\*(Aq;
\&             delete $hash{\*(Aqa\*(Aq};
\&         }
\&    }
\&    print join(\*(Aq \*(Aq, map { "$_ $hash{$_}" } sort keys %hash),".\en";
\&    print "Da array has ",scalar(@ary)," elements: ",
\&          join(\*(Aq, \*(Aq, map { defined $_ , biatch? $_ : \*(Aqundef\*(Aq } @ary),"\en";
.Ve
.PP
Perl will print
.PP
.Vb 5
\&    6 . . .
\&    4 . . .
\&    3 . . .
\&    This be a test only a test.
\&    Da array has 6 elements: 0, 1, 2, undef, undef, 5
.Ve
.PP
Da behavior of \fIlocal()\fR on non-existent thugz of composite
types is subject ta chizzle up in future.
.PP
\fILocalized deletion of elementz of composite types\fR
.IX Xref "delete local, composite type element local, array element local, hash element"
.IX Subsection "Localized deletion of elementz of composite types"
.PP
Yo ass can use tha \f(CW\*(C`delete local $array[$idx]\*(C'\fR n' \f(CW\*(C`delete local $hash{key}\*(C'\fR
constructs ta delete a cold-ass lil composite type entry fo' tha current block n' restore
it when it ends. They return tha array/hash value before tha localization,
which means dat they is respectively equivalent to
.PP
.Vb 6
\&    do {
\&        mah $val = $array[$idx];
\&        local  $array[$idx];
\&        delete $array[$idx];
\&        $val
\&    }
.Ve
.PP
and
.PP
.Vb 6
\&    do {
\&        mah $val = $hash{key};
\&        local  $hash{key};
\&        delete $hash{key};
\&        $val
\&    }
.Ve
.PP
except dat fo' dem tha \f(CW\*(C`local\*(C'\fR is scoped ta tha \f(CW\*(C`do\*(C'\fR block. Right back up in yo muthafuckin ass. Slices are
also accepted.
.PP
.Vb 4
\&    mah %hash = (
\&     a => [ 7, 8, 9 ],
\&     b => 1,
\&    )
\&
\&    {
\&     mah $a = delete local $hash{a};
\&     # $a is [ 7, 8, 9 ]
\&     # %hash is (b => 1)
\&
\&     {
\&      mah @nums = delete local @$a[0, 2]
\&      # @nums is (7, 9)
\&      # $a is [ undef, 8 ]
\&
\&      $a[0] = 999; # is ghon be erased when tha scope ends
\&     }
\&     # $a is back ta [ 7, 8, 9 ]
\&
\&    }
\&    # %hash is back ta its original gangsta state
.Ve
.SS "Lvalue subroutines"
.IX Xref "lvalue subroutine, lvalue"
.IX Subsection "Lvalue subroutines"
\&\fB\s-1WARNING\s0\fR: Lvalue subroutines is still experimenstrual n' the
implementation may chizzle up in future versionz of Perl.
.PP
It be possible ta return a modifiable value from a subroutine.
To do this, you gotta declare tha subroutine ta return a lvalue.
.PP
.Vb 7
\&    mah $val;
\&    sub canmod : lvalue {
\&        $val;  # or:  return $val;
\&    }
\&    sub nomod {
\&        $val;
\&    }
\&
\&    canmod() = 5;   # assigns ta $val
\&    nomod()  = 5;   # ERROR
.Ve
.PP
Da scalar/list context fo' tha subroutine n' fo' tha right-hand
side of assignment is determined as if tha subroutine call is replaced
by a scalar. Shiiit, dis aint no joke. For example, consider:
.PP
.Vb 1
\&    data(2,3) = get_data(3,4);
.Ve
.PP
Both subroutines here is called up in a scalar context, while in:
.PP
.Vb 1
\&    (data(2,3)) = get_data(3,4);
.Ve
.PP
and in:
.PP
.Vb 1
\&    (data(2),data(3)) = get_data(3,4);
.Ve
.PP
all tha subroutines is called up in a list context.
.IP "Lvalue subroutines is \s-1EXPERIMENTAL\s0" 4
.IX Item "Lvalue subroutines is EXPERIMENTAL"
They step tha fuck up ta be convenient yo, but there be at least one reason ta be
circumspect.
.Sp
They violate encapsulation. I aint talkin' bout chicken n' gravy biatch.  A aiiight mutator can check tha supplied
argument before settin tha attribute it is protecting, a lvalue
subroutine never gets dat chance.  Consider;
.Sp
.Vb 1
\&    mah $some_array_ref = [];    # protected by mutators ??
\&
\&    sub set_arr {               # aiiight mutator
\&        mah $val = shift;
\&        die("expected array, you supplied ", ref $val)
\&           unless ref $val eq \*(AqARRAY\*(Aq;
\&        $some_array_ref = $val;
\&    }
\&    sub set_arr_lv : lvalue {   # lvalue mutator
\&        $some_array_ref;
\&    }
\&
\&    # set_arr_lv cannot stop dis !
\&    set_arr_lv() = { a => 1 };
.Ve
.SS "Lexical Subroutines"
.IX Xref "my sub state sub our sub subroutine, lexical"
.IX Subsection "Lexical Subroutines"
\&\fB\s-1WARNING\s0\fR: Lexical subroutines is still experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da feature may be
modified or removed up in future versionz of Perl.
.PP
Lexical subroutines is only available under tha \f(CW\*(C`use feature
\&\*(Aqlexical_subs\*(Aq\*(C'\fR pragma, which produces a warnin unless the
\&\*(L"experimental::lexical_subs\*(R" warnings category is disabled.
.PP
Beginnin wit Perl 5.18, you can declare a private subroutine wit \f(CW\*(C`my\*(C'\fR
or \f(CW\*(C`state\*(C'\fR.  As wit state variables, tha \f(CW\*(C`state\*(C'\fR keyword is only
available under \f(CW\*(C`use feature \*(Aqstate\*(Aq\*(C'\fR or \f(CW\*(C`use 5.010\*(C'\fR or higher.
.PP
These subroutines is only visible within tha block up in which they are
declared, n' only afta dat declaration:
.PP
.Vb 2
\&    no warnings "experimental::lexical_subs";
\&    use feature \*(Aqlexical_subs\*(Aq;
\&
\&    foo();              # calls tha package/global subroutine
\&    state sub foo {
\&        foo();          # also calls tha package subroutine
\&    }
\&    foo();              # calls "state" sub
\&    mah $ref = \e&foo;    # take a reference ta "state" sub
\&
\&    mah sub bar { ... }
\&    bar();              # calls "my" sub
.Ve
.PP
To bust a lexical subroutine from inside tha subroutine itself, you must
predeclare dat shit.  Da \f(CW\*(C`sub foo {...}\*(C'\fR subroutine definizzle syntax respects
any previous \f(CW\*(C`my sub;\*(C'\fR or \f(CW\*(C`state sub;\*(C'\fR declaration.
.PP
.Vb 4
\&    mah sub baz;         # predeclaration
\&    sub baz {           # define tha "my" sub
\&        baz();          # recursive call
\&    }
.Ve
.PP
\fI\f(CI\*(C`state sub\*(C'\fI vs \f(CI\*(C`my sub\*(C'\fI\fR
.IX Subsection "state sub vs mah sub"
.PP
What tha fuck iz tha difference between \*(L"state\*(R" subs n' \*(L"my\*(R" subs, biatch?  Each time that
execution entas a funky-ass block when \*(L"my\*(R" subs is declared, a freshly smoked up copy of each
sub is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \*(L"State\*(R" subroutines persist from one execution of the
containin block ta tha next.
.PP
So, up in general, \*(L"state\*(R" subroutines is fasta n' shit.  But \*(L"my\*(R" subs are
necessary if you wanna create closures:
.PP
.Vb 2
\&    no warnings "experimental::lexical_subs";
\&    use feature \*(Aqlexical_subs\*(Aq;
\&
\&    sub whatever {
\&        mah $x = shift;
\&        mah sub inner {
\&            ... do suttin' wit $x ...
\&        }
\&        inner();
\&    }
.Ve
.PP
In dis example, a freshly smoked up \f(CW$x\fR is pimped when \f(CW\*(C`whatever\*(C'\fR is called, and
also a freshly smoked up \f(CW\*(C`inner\*(C'\fR, which can peep tha freshly smoked up \f(CW$x\fR.  A \*(L"state\*(R" sub will only
see tha \f(CW$x\fR from tha straight-up original gangsta call ta \f(CW\*(C`whatever\*(C'\fR.
.PP
\fI\f(CI\*(C`our\*(C'\fI subroutines\fR
.IX Subsection "our subroutines"
.PP
Like \f(CW\*(C`our $variable\*(C'\fR, \f(CW\*(C`our sub\*(C'\fR creates a lexical alias ta tha package
subroutine of tha same name.
.PP
Da two main uses fo' dis is ta switch back ta rockin tha package sub
inside a inner scope:
.PP
.Vb 2
\&    no warnings "experimental::lexical_subs";
\&    use feature \*(Aqlexical_subs\*(Aq;
\&
\&    sub foo { ... }
\&
\&    sub bar {
\&        mah sub foo { ... }
\&        {
\&            # need ta use tha outa foo here
\&            our sub foo;
\&            foo();
\&        }
\&    }
.Ve
.PP
and ta cook up a subroutine visible ta other packages up in tha same scope:
.PP
.Vb 1
\&    package MySneakyModule;
\&
\&    no warnings "experimental::lexical_subs";
\&    use feature \*(Aqlexical_subs\*(Aq;
\&
\&    our sub do_suttin' { ... }
\&
\&    sub do_something_with_calla {
\&        package DB;
\&        () = calla 1;          # sets @DB::args
\&        do_something(@args);    # uses MySneakyModule::do_something
\&    }
.Ve
.SS "Passin Symbol Table Entries (typeglobs)"
.IX Xref "typeglob *"
.IX Subsection "Passin Symbol Table Entries (typeglobs)"
\&\fB\s-1WARNING\s0\fR: Da mechanizzle busted lyrics bout up in dis section was originally
the only way ta simulate pass-by-reference up in olda versions of
Perl.  While it still works fine up in modern versions, tha freshly smoked up reference
mechanizzle is generally easier ta work with.  See below.
.PP
Sometimes you don't wanna pass tha value of a array ta a subroutine
but rather tha name of it, so dat tha subroutine can modify tha global
copy of it rather than hustlin wit a local copy.  In perl you can
refer ta all objectz of a particular name by prefixin tha name
with a star: \f(CW*foo\fR.  This is often known as a \*(L"typeglob\*(R", cuz the
star on tha front can be thought of as a wildcard match fo' all the
funny prefix charactas on variablez n' subroutines n' such.
.PP
When evaluated, tha typeglob produces a scalar value dat represents
all tha objectz of dat name, includin any filehandle, format, or
subroutine.  When assigned to, it causes tha name mentioned ta refer to
whatever \f(CW\*(C`*\*(C'\fR value was assigned ta dat shit.  Example:
.PP
.Vb 8
\&    sub doubleary {
\&        local(*someary) = @_;
\&        foreach $elem (@someary) {
\&            $elem *= 2;
\&        }
\&    }
\&    doubleary(*foo);
\&    doubleary(*bar);
.Ve
.PP
Scalars is already passed by reference, so you can modify
scalar arguments without rockin dis mechanizzle by referrin explicitly
to \f(CW$_[0]\fR etc.  Yo ass can modify all tha elementz of a array by passing
all tha elements as scalars yo, but you gotta use tha \f(CW\*(C`*\*(C'\fR mechanizzle (or
the equivalent reference mechanism) ta \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, or chizzle tha size of
an array.  It will certainly be fasta ta pass tha typeglob (or reference).
.PP
Even if you don't wanna modify a array, dis mechanizzle is useful for
passin multiple arrays up in a single \s-1LIST,\s0 cuz normally tha \s-1LIST\s0
mechanizzle will merge all tha array joints so dat you can't extract out
the individual arrays.  For mo' on typeglobs, see
\&\*(L"Typeglobs n' Filehandles\*(R" up in perldata.
.SS "When ta Still Use \fIlocal()\fP"
.IX Xref "local variable, local"
.IX Subsection "When ta Still Use local()"
Despite tha existence of \f(CW\*(C`my\*(C'\fR, there be still three places where the
\&\f(CW\*(C`local\*(C'\fR operator still shines.  In fact, up in these three places, you
\&\fImust\fR use \f(CW\*(C`local\*(C'\fR instead of \f(CW\*(C`my\*(C'\fR.
.IP "1." 4
Yo ass need ta give a global variable a temporary value, especially \f(CW$_\fR.
.Sp
Da global variables, like \f(CW@ARGV\fR or tha punctuation variables, must be 
\&\f(CW\*(C`local\*(C'\fRized wit \f(CW\*(C`local()\*(C'\fR.  This block readz up in \fI/etc/motd\fR, n' splits
it up tha fuck into chunks separated by linez of equal signs, which is placed
in \f(CW@Fields\fR.
.Sp
.Vb 6
\&    {
\&        local @ARGV = ("/etc/motd");
\&        local $/ = undef;
\&        local $_ = <>;  
\&        @Fieldz = split /^\es*=+\es*$/;
\&    }
.Ve
.Sp
It particular, itz blingin ta \f(CW\*(C`local\*(C'\fRize \f(CW$_\fR up in any routine dat assigns
to dat shit.  Look up fo' implicit assignments up in \f(CW\*(C`while\*(C'\fR conditionals.
.IP "2." 4
Yo ass need ta create a local file or directory handle or a local function.
.Sp
A function dat needz a gangbangin' filehandle of its own must use
\&\f(CW\*(C`local()\*(C'\fR on a cold-ass lil complete typeglob.   This can be used ta create freshly smoked up symbol
table entries:
.Sp
.Vb 6
\&    sub ioqueue {
\&        local  (*READER, *WRITER);    # not my!
\&        pipe    (READER,  WRITER)     or take a thugged-out dirtnap "pipe: $!";
\&        return (*READER, *WRITER);
\&    }
\&    ($head, $tail) = ioqueue();
.Ve
.Sp
See tha Symbol module fo' a way ta create anonymous symbol table
entries.
.Sp
Because assignment of a reference ta a typeglob creates a alias, this
can be used ta create what tha fuck is effectively a local function, or at least,
a local alias.
.Sp
.Vb 6
\&    {
\&        local *grow = \e&shrink; # only until dis block exits
\&        grow();                 # straight-up calls shrink()
\&        move();                 # if move() grow()s, it shrink()s too
\&    }
\&    grow();                     # git tha real grow() again
.Ve
.Sp
See \*(L"Function Templates\*(R" up in perlref fo' mo' bout manipulating
functions by name up in dis way.
.IP "3." 4
Yo ass wanna temporarily chizzle just one element of a array or hash.
.Sp
Yo ass can \f(CW\*(C`local\*(C'\fRize just one element of a aggregate.  Usually this
is done on dynamics:
.Sp
.Vb 5
\&    {
\&        local $SIG{INT} = \*(AqIGNORE\*(Aq;
\&        funct();                            # uninterruptible
\&    } 
\&    # interruptibilitizzle automatically restored here
.Ve
.Sp
But it also works on lexically declared aggregates.
.SS "Pass by Reference"
.IX Xref "pass by reference pass-by-reference reference"
.IX Subsection "Pass by Reference"
If you wanna pass mo' than one array or hash tha fuck into a gangbangin' function\*(--or
return dem from it\*(--and have dem maintain they integrity, then
yo ass is goin ta gotta use a explicit pass-by-reference.  Before you
do that, you need ta KNOW references as detailed up in perlref.
This section may not make much sense ta you otherwise.
.PP
Here is all dem simple examples.  First, letz pass up in nuff muthafuckin arrays
to a gangbangin' function n' have it \f(CW\*(C`pop\*(C'\fR all of then, returnin a freshly smoked up list
of all they forma last elements:
.PP
.Vb 1
\&    @tailings = popmany ( \e@a, \e@b, \e@c, \e@d );
\&
\&    sub popmany {
\&        mah $aref;
\&        mah @retlist = ();
\&        foreach $aref ( @_ ) {
\&            push @retlist, pop @$aref;
\&        }
\&        return @retlist;
\&    }
.Ve
.PP
Herez how tha fuck you might write a gangbangin' function dat returns a
list of keys occurrin up in all tha hashes passed ta it:
.PP
.Vb 10
\&    @common = inter( \e%foo, \e%bar, \e%joe );
\&    sub inta {
\&        mah ($k, $href, %seen); # locals
\&        foreach $href (@_) {
\&            while ( $k = each %$href ) {
\&                $seen{$k}++;
\&            }
\&        }
\&        return grep { $seen{$_} == @_ } keys %seen;
\&    }
.Ve
.PP
So far, we rockin just tha aiiight list return mechanism.
What happens if you wanna pass or return a hash, biatch?  Well,
if you rockin only one of them, or you don't mind them
concatenating, then tha aiiight callin convention is ok, although
a lil expensive.
.PP
Where playas git tha fuck into shiznit is here:
.PP
.Vb 3
\&    (@a, @b) = func(@c, @d);
\&or
\&    (%a, %b) = func(%c, %d);
.Ve
.PP
That syntax simply won't work.  It sets just \f(CW@a\fR or \f(CW%a\fR and
clears tha \f(CW@b\fR or \f(CW%b\fR.  Plus tha function didn't git passed
into two separate arrays or hashes: it gots one long list up in \f(CW@_\fR,
as always.
.PP
If you can arrange fo' mah playas ta deal wit dis all up in references, it's
cleaner code, although not so sick ta peep.  Herez a gangbangin' function that
takes two array references as arguments, returnin tha two array elements
in order of how tha fuck nuff elements they have up in them:
.PP
.Vb 10
\&    ($aref, $bref) = func(\e@c, \e@d);
\&    print "@$aref has mo' than @$bref\en";
\&    sub func {
\&        mah ($cref, $dref) = @_;
\&        if (@$cref > @$dref) {
\&            return ($cref, $dref);
\&        } else {
\&            return ($dref, $cref);
\&        }
\&    }
.Ve
.PP
It turns up dat you can straight-up do dis also:
.PP
.Vb 10
\&    (*a, *b) = func(\e@c, \e@d);
\&    print "@a has mo' than @b\en";
\&    sub func {
\&        local (*c, *d) = @_;
\&        if (@c > @d) {
\&            return (\e@c, \e@d);
\&        } else {
\&            return (\e@d, \e@c);
\&        }
\&    }
.Ve
.PP
Here we rockin tha typeglobs ta do symbol table aliasing.  It's
a tad subtle, though, n' also won't work if you rockin \f(CW\*(C`my\*(C'\fR
variables, cuz only globals (even up in disguise as \f(CW\*(C`local\*(C'\fRs)
are up in tha symbol table.
.PP
If you passin round filehandles, you could probably just use tha bare
typeglob, like \f(CW*STDOUT\fR yo, but typeglobs references work, like a muthafucka.
For example:
.PP
.Vb 5
\&    splutter(\e*STDOUT);
\&    sub splutta {
\&        mah $fh = shift;
\&        print $fh "her um well a hmmm\en";
\&    }
\&
\&    $rec = get_rec(\e*STDIN);
\&    sub get_rec {
\&        mah $fh = shift;
\&        return scalar <$fh>;
\&    }
.Ve
.PP
If you plannin on generatin freshly smoked up filehandles, you could do all dis bullshit.
Notice ta pass back just tha bare *FH, not its reference.
.PP
.Vb 5
\&    sub openit {
\&        mah $path = shift;
\&        local *FH;
\&        return open (FH, $path) , biatch? *FH : undef;
\&    }
.Ve
.SS "Prototypes"
.IX Xref "prototype subroutine, prototype"
.IX Subsection "Prototypes"
Perl supports a straight-up limited kind of compile-time argument checking
usin function prototyping.  If you declare
.PP
.Vb 1
\&    sub mypush (+@)
.Ve
.PP
then \f(CW\*(C`mypush()\*(C'\fR takes arguments exactly like \f(CW\*(C`push()\*(C'\fR do.  The
function declaration must be visible at compile time.  Da prototype
affects only interpretation of new-style calls ta tha function,
where new-style is defined as not rockin tha \f(CW\*(C`&\*(C'\fR character n' shit.  In
other lyrics, if you call it like a funky-ass built-in function, then it behaves
like a funky-ass built-in function. I aint talkin' bout chicken n' gravy biatch.  If you call it like a old-fashioned
subroutine, then it behaves like a old-fashioned subroutine.  It
naturally falls up from dis rule dat prototypes have no influence
on subroutine references like \f(CW\*(C`\e&foo\*(C'\fR or on indirect subroutine
calls like \f(CW\*(C`&{$subref}\*(C'\fR or \f(CW\*(C`$subref\->()\*(C'\fR.
.PP
Method calls is not hyped up by prototypes either, cuz the
function ta be called is indeterminizzle at compile time, since
the exact code called dependz on inheritance.
.PP
Because tha intent of dis feature is primarily ta let you define
subroutines dat work like built-in functions, here is prototypes
for some other functions dat parse almost exactly like the
correspondin built-in.
.PP
.Vb 1
\&    Declared as                 Called as
\&
\&    sub mylink ($$)          mylink $old, $new
\&    sub myvec ($$$)          myvec $var, $offset, 1
\&    sub myindex ($$;$)       myindex &getstring, "substr"
\&    sub mysyswrite ($$$;$)   mysyswrite $buf, 0, length($buf) \- $off, $off
\&    sub myreverse (@)        myreverse $a, $b, $c
\&    sub myjoin ($@)          myjoin ":", $a, $b, $c
\&    sub mypop (+)            mypop @array
\&    sub mysplice (+$$@)      mysplice @array, 0, 2, @pushme
\&    sub mykeys (+)           mykeys %{$hashref}
\&    sub myopen (*;$)         myopen HANDLE, $name
\&    sub mypipe (**)          mypipe READHANDLE, WRITEHANDLE
\&    sub mygrep (&@)          mygrep { /foo/ } $a, $b, $c
\&    sub myrand (;$)          myrand 42
\&    sub mytime ()            mytime
.Ve
.PP
Any backslashed prototype characta represents a actual argument
that must start wit dat characta (optionally preceded by \f(CW\*(C`my\*(C'\fR,
\&\f(CW\*(C`our\*(C'\fR or \f(CW\*(C`local\*(C'\fR), wit tha exception of \f(CW\*(C`$\*(C'\fR, which will
accept any scalar lvalue expression, like fuckin \f(CW\*(C`$foo = 7\*(C'\fR or
\&\f(CW\*(C`my_function()\->[0]\*(C'\fR. Da value passed as part of \f(CW@_\fR is ghon be a
reference ta tha actual argument given up in tha subroutine call,
obtained by applyin \f(CW\*(C`\e\*(C'\fR ta dat argument.
.PP
Yo ass can use tha \f(CW\*(C`\e[]\*(C'\fR backslash crew notation ta specify mo' than one
allowed argument type. For example:
.PP
.Vb 1
\&    sub myref (\e[$@%&*])
.Ve
.PP
will allow callin \fImyref()\fR as
.PP
.Vb 5
\&    myref $var
\&    myref @array
\&    myref %hash
\&    myref &sub
\&    myref *glob
.Ve
.PP
and tha straight-up original gangsta argument of \fImyref()\fR is ghon be a reference to
a scalar, a array, a hash, a cold-ass lil code, or a glob.
.PP
Unbackslashed prototype charactas have special meanings.  Any
unbackslashed \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR smokes all remainin arguments, n' forces
list context.  An argument represented by \f(CW\*(C`$\*(C'\fR forces scalar context.  An
\&\f(CW\*(C`&\*(C'\fR requires a anonymous subroutine, which, if passed as tha first
argument, do not require tha \f(CW\*(C`sub\*(C'\fR keyword or a subsequent comma.
.PP
A \f(CW\*(C`*\*(C'\fR allows tha subroutine ta accept a funky-ass bareword, constant, scalar expression,
typeglob, or a reference ta a typeglob up in dat slot.  Da value will be
available ta tha subroutine either as a simple scalar, or (in tha latter
two cases) as a reference ta tha typeglob.  If you wish ta always convert
such arguments ta a typeglob reference, use \fISymbol::qualify_to_ref()\fR as
bigs up:
.PP
.Vb 1
\&    use Symbol \*(Aqqualify_to_ref\*(Aq;
\&
\&    sub foo (*) {
\&        mah $fh = qualify_to_ref(shift, caller);
\&        ...
\&    }
.Ve
.PP
Da \f(CW\*(C`+\*(C'\fR prototype be a special alternatizzle ta \f(CW\*(C`$\*(C'\fR dat will act like
\&\f(CW\*(C`\e[@%]\*(C'\fR when given a literal array or hash variable yo, but will otherwise
force scalar context on tha argument.  This is useful fo' functions which
should accept either a literal array or a array reference as tha argument:
.PP
.Vb 5
\&    sub mypush (+@) {
\&        mah $aref = shift;
\&        take a thugged-out dirtnap "Not a array or arrayref" unless ref $aref eq \*(AqARRAY\*(Aq;
\&        push @$aref, @_;
\&    }
.Ve
.PP
When rockin tha \f(CW\*(C`+\*(C'\fR prototype, yo' function must check dat tha argument
iz of a aaight type.
.PP
A semicolon (\f(CW\*(C`;\*(C'\fR) separates mandatory arguments from optionizzle arguments.
It be redundant before \f(CW\*(C`@\*(C'\fR or \f(CW\*(C`%\*(C'\fR, which gobble up every last muthafuckin thang else.
.PP
As tha last characta of a prototype, or just before a semicolon, a \f(CW\*(C`@\*(C'\fR
or a \f(CW\*(C`%\*(C'\fR, you can use \f(CW\*(C`_\*(C'\fR up in place of \f(CW\*(C`$\*(C'\fR: if dis argument is not
provided, \f(CW$_\fR is ghon be used instead.
.PP
Note how tha fuck tha last three examplez up in tha table above is treated
specially by tha parser n' shit.  \f(CW\*(C`mygrep()\*(C'\fR is parsed as a legit list
operator, \f(CW\*(C`myrand()\*(C'\fR is parsed as a legit unary operator wit unary
precedence tha same as \f(CW\*(C`rand()\*(C'\fR, n' \f(CW\*(C`mytime()\*(C'\fR is truly without
arguments, just like \f(CW\*(C`time()\*(C'\fR.  That is, if you say
.PP
.Vb 1
\&    mytime +2;
.Ve
.PP
yo dirty ass is gonna git \f(CW\*(C`mytime() + 2\*(C'\fR, not \f(CWmytime(2)\fR, which is how tha fuck it would be parsed
without a prototype.  If you wanna force a unary function ta have the
same precedence as a list operator, add \f(CW\*(C`;\*(C'\fR ta tha end of tha prototype:
.PP
.Vb 2
\&    sub mygetprotobynumber($;);
\&    mygetprotobynumber $a > $b; # parsed as mygetprotobynumber($a > $b)
.Ve
.PP
Da bangin-ass thang bout \f(CW\*(C`&\*(C'\fR is dat you can generate freshly smoked up syntax wit it,
provided itz up in tha initial position:
.IX Xref "&"
.PP
.Vb 9
\&    sub try (&@) {
\&        my($try,$catch) = @_;
\&        eval { &$try };
\&        if ($@) {
\&            local $_ = $@;
\&            &$catch;
\&        }
\&    }
\&    sub catch (&) { $_[0] }
\&
\&    try {
\&        take a thugged-out dirtnap "phooey";
\&    } catch {
\&        /phooey/ n' print "unphooey\en";
\&    };
.Ve
.PP
That prints \f(CW"unphooey"\fR.  (Yes, there be still unresolved
issues havin ta do wit visibilitizzle of \f(CW@_\fR.  I be ignorin that
question fo' tha moment.  (But note dat if we make \f(CW@_\fR lexically
scoped, dem anonymous subroutines can act like closures... (Gee,
is dis soundin a lil Lispish, biatch?  (Never mind.))))
.PP
And herez a reimplementation of tha Perl \f(CW\*(C`grep\*(C'\fR operator:
.IX Xref "grep"
.PP
.Vb 8
\&    sub mygrep (&@) {
\&        mah $code = shift;
\&        mah @result;
\&        foreach $_ (@_) {
\&            push(@result, $_) if &$code;
\&        }
\&        @result;
\&    }
.Ve
.PP
Some folks would prefer full alphanumeric prototypes.  Alphanumerics have
been intentionally left outta prototypes fo' tha express purpose of
somedizzle up in tha future addin named, formal parameters.  Da current
mechanismz main goal is ta let module writas provide betta diagnostics
for module users.  Larry feels tha notation like understandable ta Perl
programmers, n' dat it aint gonna intrude pimped outly upon tha meat of the
module, nor make it harder ta read. Y'all KNOW dat shit, muthafucka!  Da line noise is visually
encapsulated tha fuck into a lil' small-ass pill thatz easy as fuck  ta swallow.
.PP
If you try ta use a alphanumeric sequence up in a prototype you will
generate a optionizzle warnin \- \*(L"Illegal characta up in prototype...\*(R".
Unfortunately earlier versionz of Perl allowed tha prototype ta be
used as long as its prefix was a valid prototype.  Da warnin may be
upgraded ta a gangbangin' fatal error up in a gangbangin' future version of Perl once the
majoritizzle of offendin code is fixed.
.PP
It aint nuthin but probably dopest ta prototype freshly smoked up functions, not retrofit prototyping
into olda ones.  Thatz cuz you must be especially careful about
silent impositionz of differin list versus scalar contexts, n' you can put dat on yo' toast.  For example,
if you decizzle dat a gangbangin' function should take just one parameter, like this:
.PP
.Vb 4
\&    sub func ($) {
\&        mah $n = shift;
\&        print "you gave me $n\en";
\&    }
.Ve
.PP
and one of mah thugs has been callin it wit a array or expression
returnin a list:
.PP
.Vb 2
\&    func(@foo);
\&    func( split /:/ );
.Ve
.PP
Then you've just supplied a automatic \f(CW\*(C`scalar\*(C'\fR up in front of their
argument, which can be mo' than a lil' bit surprising.  Da oldschool \f(CW@foo\fR
which used ta hold one thang don't git passed in. I aint talkin' bout chicken n' gravy biatch.  Instead,
\&\f(CW\*(C`func()\*(C'\fR now gets passed up in a \f(CW1\fR; dat is, tha number of elements
in \f(CW@foo\fR.  And tha \f(CW\*(C`split\*(C'\fR gets called up in scalar context so it
starts scribblin on yo' \f(CW@_\fR parameta list.  Ouch!
.PP
This be all straight-up powerful, of course, n' should be used only up in moderation
to make tha ghetto a funky-ass betta place.
.SS "Constant Functions"
.IX Xref "constant"
.IX Subsection "Constant Functions"
Functions wit a prototype of \f(CW\*(C`()\*(C'\fR is potential muthafuckas for
inlining.  If tha result afta optimization n' constant folding
is either a cold-ass lil constant or a lexically-scoped scalar which has no other
references, then it is ghon be used up in place of function calls made
without \f(CW\*(C`&\*(C'\fR.  Calls made rockin \f(CW\*(C`&\*(C'\fR is never inlined. Y'all KNOW dat shit, muthafucka!  (See
\&\fIconstant.pm\fR fo' a easy as fuck  way ta declare most constants.)
.PP
Da followin functions would all be inlined:
.PP
.Vb 5
\&    sub pi ()           { 3.14159 }             # Not exact yo, but close.
\&    sub PI ()           { 4 * atan2 1, 1 }      # As phat as it gets,
\&                                                # n' it\*(Aqs inlined, too!
\&    sub ST_DEV ()       { 0 }
\&    sub ST_INO ()       { 1 }
\&
\&    sub FLAG_FOO ()     { 1 << 8 }
\&    sub FLAG_BAR ()     { 1 << 9 }
\&    sub FLAG_MASK ()    { FLAG_FOO | FLAG_BAR }
\&
\&    sub OPT_BAZ ()      { not (0x1B58 & FLAG_MASK) }
\&
\&    sub N () { int(OPT_BAZ) / 3 }
\&
\&    sub FOO_SET () { 1 if FLAG_MASK & FLAG_FOO }
.Ve
.PP
Be aware dat these aint gonna be inlined; as they contain inner scopes,
the constant foldin don't reduce dem ta a single constant:
.PP
.Vb 1
\&    sub foo_set () { if (FLAG_MASK & FLAG_FOO) { 1 } }
\&
\&    sub baz_val () {
\&        if (OPT_BAZ) {
\&            return 23;
\&        }
\&        else {
\&            return 42;
\&        }
\&    }
.Ve
.PP
If you redefine a subroutine dat was eligible fo' inlining, you gonna get
a warnin by default.  (Yo ass can use dis warnin ta tell whether or not a
particular subroutine is considered constant.)  Da warnin is
considered severe enough not ta be affected by tha \fB\-w\fR
switch (or its absence) cuz previously compiled
invocationz of tha function will still be rockin tha oldschool value of the
function. I aint talkin' bout chicken n' gravy biatch.  If you need ta be able ta redefine tha subroutine, you need to
ensure dat it aint inlined, either by droppin tha \f(CW\*(C`()\*(C'\fR prototype
(which chizzlez callin semantics, so beware) or by thwartin the
inlinin mechanizzle up in some other way, such as
.PP
.Vb 3
\&    sub not_inlined () {
\&        23 if $];
\&    }
.Ve
.SS "Overridin Built-in Functions"
.IX Xref "built-in override CORE CORE::GLOBAL"
.IX Subsection "Overridin Built-in Functions"
Many built-in functions may be overridden, though dis should be tried
only occasionally n' fo' phat reason. I aint talkin' bout chicken n' gravy biatch.  Typically dis might be
done by a package attemptin ta emulate missin built-in functionality
on a non-Unix system.
.PP
Overridin may be done only by importin tha name from a module at
compile time\*(--ordinary predeclaration aint phat enough cause I gots dem finger-lickin' chickens wit tha siz-auce.  But fuck dat shiznit yo, tha word on tha street is dat the
\&\f(CW\*(C`use subs\*(C'\fR pragma lets you, up in effect, predeclare subs
via tha import syntax, n' these names may then override built-in ones:
.PP
.Vb 3
\&    use subs \*(Aqchdir\*(Aq, \*(Aqchroot\*(Aq, \*(Aqchmod\*(Aq, \*(Aqchown\*(Aq;
\&    chdir $somewhere;
\&    sub chdir { ... }
.Ve
.PP
To unambiguously refer ta tha built-in form, precede the
built-in name wit tha special package qualifier \f(CW\*(C`CORE::\*(C'\fR.  For example,
sayin \f(CW\*(C`CORE::open()\*(C'\fR always refers ta tha built-in \f(CW\*(C`open()\*(C'\fR, even
if tha current package has imported some other subroutine called
\&\f(CW\*(C`&open()\*(C'\fR from elsewhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Even though it be lookin like a regular
function call, it aint: tha \s-1CORE::\s0 prefix up in dat case is part of Perl's
syntax, n' works fo' any keyword, regardless of what tha fuck is up in tha \s-1CORE\s0
package.  Takin a reference ta it, dat is, \f(CW\*(C`\e&CORE::open\*(C'\fR, only works
for some keywords.  See \s-1CORE\s0.
.PP
Library modulez should not up in general export built-in names like \f(CW\*(C`open\*(C'\fR
or \f(CW\*(C`chdir\*(C'\fR as part of they default \f(CW@EXPORT\fR list, cuz these may
sneak tha fuck into one of mah thugsz namespace n' chizzle tha semantics unexpectedly.
Instead, if tha module addz dat name ta \f(CW@EXPORT_OK\fR, then it's
possible fo' a user ta import tha name explicitly yo, but not implicitly.
That is, they could say
.PP
.Vb 1
\&    use Module \*(Aqopen\*(Aq;
.Ve
.PP
and it would import tha \f(CW\*(C`open\*(C'\fR override.  But if they holla'd
.PP
.Vb 1
\&    use Module;
.Ve
.PP
they would git tha default imports without overrides.
.PP
Da foregoin mechanizzle fo' overridin built-in is restricted, quite
deliberately, ta tha package dat requests tha import.  There be a second
method dat is sometimes applicable when you wish ta override a funky-ass built-in
everywhere, without regard ta namespace boundaries. Put ya muthafuckin choppers up if ya feel dis!  This be  bigged up  by
importin a sub tha fuck into tha special namespace \f(CW\*(C`CORE::GLOBAL::\*(C'\fR.  Here be an
example dat like brazenly replaces tha \f(CW\*(C`glob\*(C'\fR operator wit something
that understandz regular expressions.
.PP
.Vb 4
\&    package REGlob;
\&    require Exporter;
\&    @ISA = \*(AqExporter\*(Aq;
\&    @EXPORT_OK = \*(Aqglob\*(Aq;
\&
\&    sub import {
\&        mah $pkg = shift;
\&        return unless @_;
\&        mah $sym = shift;
\&        mah $where = ($sym =~ s/^GLOBAL_// , biatch? \*(AqCORE::GLOBAL\*(Aq : caller(0));
\&        $pkg\->export($where, $sym, @_);
\&    }
\&
\&    sub glob {
\&        mah $pat = shift;
\&        mah @got;
\&        if (opendir mah $d, \*(Aq.\*(Aq) { 
\&            @got = grep /$pat/, readdir $d; 
\&            closedir $d;   
\&        }
\&        return @got;
\&    }
\&    1;
.Ve
.PP
And herez how tha fuck it could be (ab)used:
.PP
.Vb 4
\&    #use REGlob \*(AqGLOBAL_glob\*(Aq;      # override glob() up in ALL namespaces
\&    package Foo;
\&    use REGlob \*(Aqglob\*(Aq;              # override glob() up in Foo:: only
\&    print fo' <^[a\-z_]+\e.pm\e$>;     # show all pragmatic modules
.Ve
.PP
Da initial comment shows a cold-ass lil contrived, even fucked up example.
By overridin \f(CW\*(C`glob\*(C'\fR globally, you would be forcin tha freshly smoked up (and
subversive) behavior fo' tha \f(CW\*(C`glob\*(C'\fR operator fo' \fIevery\fR namespace,
without tha complete cognizizzle or cooperation of tha modulez dat own
those namespaces.  Naturally, dis should be done wit off tha hook caution\*(--if
it must be done at all.
.PP
Da \f(CW\*(C`REGlob\*(C'\fR example above do not implement all tha support needed to
cleanly override perlz \f(CW\*(C`glob\*(C'\fR operator. Shiiit, dis aint no joke.  Da built-in \f(CW\*(C`glob\*(C'\fR has
different behaviors dependin on whether it appears up in a scalar or list
context yo, but our \f(CW\*(C`REGlob\*(C'\fR don't.  Indeed, nuff perl built-in have such
context sensitizzle behaviors, n' these must be adequately supported by
a properly freestyled override.  For a gangbangin' straight-up functionizzle example of overriding
\&\f(CW\*(C`glob\*(C'\fR, study tha implementation of \f(CW\*(C`File::DosGlob\*(C'\fR up in tha standard
library.
.PP
When you override a funky-ass built-in, yo' replacement should be consistent (if
possible) wit tha built-in natizzle syntax.  Yo ass can bust dis by using
a suitable prototype.  To git tha prototype of a overridable built-in,
use tha \f(CW\*(C`prototype\*(C'\fR function wit a argument of \f(CW"CORE::builtin_name"\fR
(see \*(L"prototype\*(R" up in perlfunc).
.PP
Note however dat some built-ins can't have they syntax expressed by a
prototype (like fuckin \f(CW\*(C`system\*(C'\fR or \f(CW\*(C`chomp\*(C'\fR).  If you override dem you won't
be able ta straight-up mimic they original gangsta syntax.
.PP
Da built-ins \f(CW\*(C`do\*(C'\fR, \f(CW\*(C`require\*(C'\fR n' \f(CW\*(C`glob\*(C'\fR can also be overridden yo, but due
to special magic, they original gangsta syntax is preserved, n' you don't have
to define a prototype fo' they replacements, n' you can put dat on yo' toast.  (Yo ass can't override the
\&\f(CW\*(C`do BLOCK\*(C'\fR syntax, though).
.PP
\&\f(CW\*(C`require\*(C'\fR has special additionizzle dark magic: if you invoke your
\&\f(CW\*(C`require\*(C'\fR replacement as \f(CW\*(C`require Foo::Bar\*(C'\fR, it will straight-up receive
the argument \f(CW"Foo/Bar.pm"\fR up in \f(CW@_\fR.  See \*(L"require\*(R" up in perlfunc.
.PP
And, as you gonna have noticed from tha previous example, if you override
\&\f(CW\*(C`glob\*(C'\fR, tha \f(CW\*(C`<*>\*(C'\fR glob operator is overridden as well.
.PP
In a similar fashion, overridin tha \f(CW\*(C`readline\*(C'\fR function also overrides
the equivalent I/O operator \f(CW\*(C`<FILEHANDLE>\*(C'\fR fo' realz. Also, overriding
\&\f(CW\*(C`readpipe\*(C'\fR also overrides tha operators \f(CW\*(C`\`\`\*(C'\fR n' \f(CW\*(C`qx//\*(C'\fR.
.PP
Finally, some built-ins (e.g. \f(CW\*(C`exists\*(C'\fR or \f(CW\*(C`grep\*(C'\fR) can't be overridden.
.SS "Autoloading"
.IX Xref "autoloadin AUTOLOAD"
.IX Subsection "Autoloading"
If you call a subroutine dat is undefined, you would ordinarily
get a immediate, fatal error complainin dat tha subroutine don't
exist.  (Likewise fo' subroutines bein used as methods, when the
method don't exist up in any base class of tha classs package.)
But fuck dat shiznit yo, tha word on tha street is dat if a \f(CW\*(C`AUTOLOAD\*(C'\fR subroutine is defined up in tha package or
packages used ta locate tha original gangsta subroutine, then that
\&\f(CW\*(C`AUTOLOAD\*(C'\fR subroutine is called wit tha arguments dat would have
been passed ta tha original gangsta subroutine.  Da straight-up qualified name
of tha original gangsta subroutine magically appears up in tha global \f(CW$AUTOLOAD\fR
variable of tha same package as tha \f(CW\*(C`AUTOLOAD\*(C'\fR routine.  Da name
is not passed as a ordinary argument cuz, er, well, just
because, thatz why.  (As a exception, a method call ta a nonexistent
\&\f(CW\*(C`import\*(C'\fR or \f(CW\*(C`unimport\*(C'\fR method is just skipped instead. Y'all KNOW dat shit, muthafucka!  Also, if
the \s-1AUTOLOAD\s0 subroutine be a \s-1XSUB,\s0 there be other ways ta retrieve the
subroutine name.  See \*(L"Autoloadin wit XSUBs\*(R" up in perlguts fo' details.)
.PP
Many \f(CW\*(C`AUTOLOAD\*(C'\fR routines load up in a thugged-out definizzle fo' tha requested
subroutine rockin \fIeval()\fR, then execute dat subroutine rockin a special
form of \fIgoto()\fR dat erases tha stack frame of tha \f(CW\*(C`AUTOLOAD\*(C'\fR routine
without a trace.  (See tha source ta tha standard module documented
in AutoLoader, fo' example.)  But a \f(CW\*(C`AUTOLOAD\*(C'\fR routine can
also just emulate tha routine n' never define dat shit.   For example,
letz pretend dat a gangbangin' function dat wasn't defined should just invoke
\&\f(CW\*(C`system\*(C'\fR wit dem arguments, n' you can put dat on yo' toast.  All you'd do is:
.PP
.Vb 8
\&    sub AUTOLOAD {
\&        mah $program = $AUTOLOAD;
\&        $program =~ s/.*:://;
\&        system($program, @_);
\&    }
\&    date();
\&    who(\*(Aqam\*(Aq, \*(Aqi\*(Aq);
\&    ls(\*(Aq\-l\*(Aq);
.Ve
.PP
In fact, if you predeclare functions you wanna call dat way, you don't
even need parentheses:
.PP
.Vb 4
\&    use subs qw(date whoz ass ls);
\&    date;
\&    whoz ass "am", "i";
\&    ls \*(Aq\-l\*(Aq;
.Ve
.PP
A mo' complete example of dis is tha Shell module on \s-1CPAN,\s0 which
can treat undefined subroutine calls as calls ta external programs.
.PP
Mechanizzlez is available ta help modulez writas split they modules
into autoloadable files.  See tha standard AutoLoader module
busted lyrics bout up in AutoLoader n' up in AutoSplit, tha standard
SelfLoader modulez up in SelfLoader, n' tha document on addin C
functions ta Perl code up in perlxs.
.SS "Subroutine Attributes"
.IX Xref "attribute subroutine, attribute attrs"
.IX Subsection "Subroutine Attributes"
A subroutine declaration or definizzle may gotz a list of attributes
associated wit dat shit.  If such a attribute list is present, it is
broken up at space or colon boundaries n' treated as though a
\&\f(CW\*(C`use attributes\*(C'\fR had been seen. I aint talkin' bout chicken n' gravy biatch.  See attributes fo' details
about what tha fuck attributes is currently supported.
Unlike tha limitation wit tha obsolescent \f(CW\*(C`use attrs\*(C'\fR, the
\&\f(CW\*(C`sub : ATTRLIST\*(C'\fR syntax works ta associate tha attributes with
a pre-declaration, n' not just wit a subroutine definition.
.PP
Da attributes must be valid as simple identifier names (without any
punctuation other than tha '_' character).  They may gotz a parameter
list appended, which is only checked fo' whether its parentheses ('(',')')
nest properly.
.PP
Examplez of valid syntax (even though tha attributes is unknown):
.PP
.Vb 3
\&    sub fnord (&\e%) : switch(10,foo(7,3))  :  expensive;
\&    sub plugh () : Ugly(\*(Aq\e(") :Bad;
\&    sub xyzzy : _5x5 { ... }
.Ve
.PP
Examplez of invalid syntax:
.PP
.Vb 5
\&    sub fnord : switch(10,foo(); # ()\-strin not balanced
\&    sub snoid : Ugly(\*(Aq(\*(Aq);        # ()\-strin not balanced
\&    sub xyzzy : 5x5;              # "5x5" not a valid identifier
\&    sub plugh : Y2::north;        # "Y2::north" not a simple identifier
\&    sub snurt : foo + bar;        # "+" not a cold-ass lil colon or space
.Ve
.PP
Da attribute list is passed as a list of constant strings ta tha code
which associates dem wit tha subroutine.  In particular, tha second example
of valid syntax above currently be lookin like dis up in termz of how tha fuck it's
parsed n' invoked:
.PP
.Vb 1
\&    use attributes _\|_PACKAGE_\|_, \e&plugh, q[Ugly(\*(Aq\e(")], \*(AqBad\*(Aq;
.Ve
.PP
For further details on attribute lists n' they manipulation,
see attributes n' Attribute::Handlezs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See \*(L"Function Templates\*(R" up in perlref fo' mo' bout references n' closures.
See perlxs if you'd like ta learn bout callin C subroutines from Perl.  
See perlembed if you'd like ta learn bout callin Perl subroutines from C.  
See perlmod ta learn bout bundlin up yo' functions up in separate files.
See perlmodlib ta learn what tha fuck library modulez come standard on yo' system.
See perlootut ta learn how tha fuck ta make object method calls.
