.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PROVE 1"
.TH PROVE 1 "2013-05-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
prove \- Run tests all up in a TAP harness.
.SH "USAGE"
.IX Header "USAGE"
.Vb 1
\& prove [options] [filez or directories]
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Boolean options:
.PP
.Vb 10
\& \-v,  \-\-verbose         Print all test lines.
\& \-l,  \-\-lib             Add \*(Aqlib\*(Aq ta tha path fo' yo' tests (\-Ilib).
\& \-b,  \-\-blib            Add \*(Aqblib/lib\*(Aq n' \*(Aqblib/arch\*(Aq ta tha path for
\&                        yo' tests
\& \-s,  \-\-shuffle         Run tha tests up in random order.
\& \-c,  \-\-color           Colored test output (default).
\&      \-\-nocolor         Do not color test output.
\&      \-\-count           Show tha X/Y test count when not verbose
\&                        (default)
\&      \-\-nocount         Disable tha X/Y test count.
\& \-D   \-\-dry             Dry run. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Show test dat would have run.
\& \-f,  \-\-failures        Show failed tests.
\& \-o,  \-\-comments        Show comments.
\&      \-\-ignore\-exit     Ignore exit status from test scripts.
\& \-m,  \-\-merge           Merge test scripts\*(Aq STDERR wit they STDOUT.
\& \-r,  \-\-recurse         Recursively descend tha fuck into directories.
\&      \-\-reverse         Run tha tests up in reverse order.
\& \-q,  \-\-quiet           Suppress some test output while hustlin tests.
\& \-Q,  \-\-QUIET           Only print summary thangs up in dis biatch.
\& \-p,  \-\-parse           Show full list of TAP parse errors, if any.
\&      \-\-directives      Only show thangs up in dis biatch wit TODO or SKIP directives.
\&      \-\-timer           Print elapsed time afta each test.
\&      \-\-trap            Trap Ctrl\-C n' print summary on interrupt.
\&      \-\-normalize       Normalize TAP output up in verbose output
\& \-T                     Enable taintin checks.
\& \-t                     Enable taintin warnings.
\& \-W                     Enable fatal warnings.
\& \-w                     Enable warnings.
\& \-h,  \-\-help            Display dis help
\& \-?,                    Display dis help
\& \-H,  \-\-man             Longer manpage fo' prove
\&      \-\-norc            Don\*(Aqt process default .proverc
.Ve
.PP
Options dat take arguments:
.PP
.Vb 10
\& \-I                     Library paths ta include.
\& \-P                     Load plugin (searches App::Prove::Plugin::*.)
\& \-M                     Load a module.
\& \-e,  \-\-exec            Interpreta ta run tha tests (\*(Aq\*(Aq fo' compiled
\&                        tests.)
\&      \-\-ext             Set tha extension fo' tests (default \*(Aq.t\*(Aq)
\&      \-\-harnizz         Define test harnizz ta use.  See TAP::Harness.
\&      \-\-formatta       Result formatta ta use. Right back up in yo muthafuckin ass. See FORMATTERS.
\&      \-\-source          Load and/or configure a SourceHandlez n' shit. Right back up in yo muthafuckin ass. See
\&                        SOURCE HANDLERS.
\& \-a,  \-\-archive out.tgz Store tha resultin TAP up in a archive file.
\& \-j,  \-\-jobs N          Run N test thangs up in parallel (try 9.)
\&      \-\-state=opts      Control prove\*(Aqs persistent state.
\&      \-\-rc=rcfile       Process options from rcfile
\&      \-\-rulez           Rulez fo' parallel vs sequential processing.
.Ve
.SH "NOTES"
.IX Header "NOTES"
.SS ".proverc"
.IX Subsection ".proverc"
If \fI~/.proverc\fR or \fI./.proverc\fR exist they is ghon be read n' any
options they contain processed before tha command line options. Options
in \fI.proverc\fR is specified up in tha same way as command line options:
.PP
.Vb 3
\&    # .proverc
\&    \-\-state=hot,fast,save
\&    \-j9
.Ve
.PP
Additionizzle option filez may be specified wit tha \f(CW\*(C`\-\-rc\*(C'\fR option.
Default option file processin is disabled by tha \f(CW\*(C`\-\-norc\*(C'\fR option.
.PP
Under Windows n' \s-1VMS\s0 tha option file is named \fI_proverc\fR rather than
\&\fI.proverc\fR n' is sought only up in tha current directory.
.ie n .SS "Readin from ""STDIN"""
.el .SS "Readin from \f(CWSTDIN\fP"
.IX Subsection "Readin from STDIN"
If you gotz a list of tests (or URLs, or anythang else you wanna test) up in a
file, you can add dem ta yo' tests by rockin a '\-':
.PP
.Vb 1
\& prove \- < my_list_of_things_to_test.txt
.Ve
.PP
See tha \f(CW\*(C`README\*(C'\fR up in tha \f(CW\*(C`examples\*(C'\fR directory of dis distribution.
.SS "Default Test Directory"
.IX Subsection "Default Test Directory"
If no filez or directories is supplied, \f(CW\*(C`prove\*(C'\fR looks fo' all files
matchin tha pattern \f(CW\*(C`t/*.t\*(C'\fR.
.SS "Colored Test Output"
.IX Subsection "Colored Test Output"
Colored test output is tha default yo, but if output aint ta a
terminal, color is disabled. Y'all KNOW dat shit, muthafucka! Yo ass can override dis by addin the
\&\f(CW\*(C`\-\-color\*(C'\fR switch.
.PP
Color support requires Term::ANSIColor on Unix-like platforms and
Win32::Console windows. If tha necessary module aint installed
colored output aint gonna be available.
.SS "Exit Code"
.IX Subsection "Exit Code"
If tha tests fail \f(CW\*(C`prove\*(C'\fR will exit wit non-zero status.
.SS "Arguments ta Tests"
.IX Subsection "Arguments ta Tests"
It be possible ta supply arguments ta tests, n' you can put dat on yo' toast. To do so separate dem from
provez own arguments wit tha arisdottle, '::'. For example
.PP
.Vb 1
\& prove \-v t/mytest.t :: \-\-url http://example.com
.Ve
.PP
would run \fIt/mytest.t\fR wit tha options '\-\-url http://example.com'.
When hustlin multiple tests they will each receive tha same arguments.
.ie n .SS """\-\-exec"""
.el .SS "\f(CW\-\-exec\fP"
.IX Subsection "--exec"
Normally you can just pass a list of Perl tests n' tha harnizz will know how
to execute em.  But fuck dat shiznit yo, tha word on tha street is dat if yo' tests is not freestyled up in Perl or if you
want all tests invoked exactly tha same way, use tha \f(CW\*(C`\-e\*(C'\fR, or \f(CW\*(C`\-\-exec\*(C'\fR
switch:
.PP
.Vb 3
\& prove \-\-exec \*(Aq/usr/bin/ruby \-w\*(Aq t/
\& prove \-\-exec \*(Aq/usr/bin/perl \-Tw \-mstrict \-Ilib\*(Aq t/
\& prove \-\-exec \*(Aq/path/to/my/customer/exec\*(Aq
.Ve
.ie n .SS """\-\-merge"""
.el .SS "\f(CW\-\-merge\fP"
.IX Subsection "--merge"
If you need ta make shizzle yo' diagnostics is displayed up in tha erect
order relatizzle ta test thangs up in dis biatch you can use tha \f(CW\*(C`\-\-merge\*(C'\fR option to
merge tha test scripts' \s-1STDERR\s0 tha fuck into they \s-1STDOUT.\s0
.PP
This guarantees dat \s-1STDOUT \s0(where tha test thangs up in dis biatch appear) n' \s-1STDERR
\&\s0(where tha diagnostics appear) will stay up in sync. Da harnizz will
display any diagnostics yo' tests emit on \s-1STDERR.\s0
.PP
Caveat: dis be a lil' bit of a kludge. In particular note dat if anything
that appears on \s-1STDERR\s0 be lookin like a test result tha test harnizz will
get confused. Y'all KNOW dat shit, muthafucka! Use dis option only if you KNOW tha consequences
and can live wit tha risk.
.ie n .SS """\-\-trap"""
.el .SS "\f(CW\-\-trap\fP"
.IX Subsection "--trap"
Da \f(CW\*(C`\-\-trap\*(C'\fR option will attempt ta trap \s-1SIGINT \s0(Ctrl-C) durin a test
run n' display tha test summary even if tha run is interrupted
.ie n .SS """\-\-state"""
.el .SS "\f(CW\-\-state\fP"
.IX Subsection "--state"
Yo ass can ask \f(CW\*(C`prove\*(C'\fR ta remember tha state of previous test runs and
select and/or order tha tests ta be run based on dat saved state.
.PP
Da \f(CW\*(C`\-\-state\*(C'\fR switch requires a argument which must be a cold-ass lil comma
separated list of one or mo' of tha followin options.
.ie n .IP """last""" 4
.el .IP "\f(CWlast\fR" 4
.IX Item "last"
Run tha same tests as tha last time tha state was saved. Y'all KNOW dat shit, muthafucka! This make it
possible, fo' example, ta recreate tha orderin of a gangbangin' finger-lickin' dirty-ass shuffled test.
.Sp
.Vb 2
\&    # Run all tests up in random order
\&    $ prove \-b \-\-state=save \-\-shuffle
\&
\&    # Run dem again n' again n' again up in tha same order
\&    $ prove \-b \-\-state=last
.Ve
.ie n .IP """failed""" 4
.el .IP "\f(CWfailed\fR" 4
.IX Item "failed"
Run only tha tests dat failed on tha last run.
.Sp
.Vb 2
\&    # Run all tests
\&    $ prove \-b \-\-state=save
\&
\&    # Run failures
\&    $ prove \-b \-\-state=failed
.Ve
.Sp
If you also specify tha \f(CW\*(C`save\*(C'\fR option newly passin tests will be
excluded from subsequent runs.
.Sp
.Vb 2
\&    # Repeat until no mo' failures
\&    $ prove \-b \-\-state=failed,save
.Ve
.ie n .IP """passed""" 4
.el .IP "\f(CWpassed\fR" 4
.IX Item "passed"
Run only tha passed tests from last time. Useful ta make shizzle dat no
new problems done been introduced.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Run all tests up in aiiight order n' shit. Multple options may be specified, so to
run all tests wit tha failures from last time first:
.Sp
.Vb 1
\&    $ prove \-b \-\-state=failed,all,save
.Ve
.ie n .IP """hot""" 4
.el .IP "\f(CWhot\fR" 4
.IX Item "hot"
Run tha tests dat most recently failed first. Da last failure time of
each test is stored. Y'all KNOW dat shit, muthafucka! Da \f(CW\*(C`hot\*(C'\fR option causes tests ta be run up in most\-recent\-
failure order.
.Sp
.Vb 1
\&    $ prove \-b \-\-state=hot,save
.Ve
.Sp
Tests dat have never failed aint gonna be selected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. To run all tests with
da most thugged-out recently failed first use
.Sp
.Vb 1
\&    $ prove \-b \-\-state=hot,all,save
.Ve
.Sp
This combination of options may also be specified thus
.Sp
.Vb 1
\&    $ prove \-b \-\-state=adrian
.Ve
.ie n .IP """todo""" 4
.el .IP "\f(CWtodo\fR" 4
.IX Item "todo"
Run any tests wit todos.
.ie n .IP """slow""" 4
.el .IP "\f(CWslow\fR" 4
.IX Item "slow"
Run tha tests up in slowest ta fastest order n' shit. This is useful up in conjunction
with tha \f(CW\*(C`\-j\*(C'\fR parallel testin switch ta ensure dat yo' slowest tests
start hustlin first.
.Sp
.Vb 1
\&    $ prove \-b \-\-state=slow \-j9
.Ve
.ie n .IP """fast""" 4
.el .IP "\f(CWfast\fR" 4
.IX Item "fast"
Run test tests up in fastest ta slowest order.
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
Run tha tests up in newest ta crazy oldschool order based on tha modification times
of tha test scripts.
.ie n .IP """old""" 4
.el .IP "\f(CWold\fR" 4
.IX Item "old"
Run tha tests up in crazy oldschool ta newest order.
.ie n .IP """fresh""" 4
.el .IP "\f(CWfresh\fR" 4
.IX Item "fresh"
Run dem test scripts dat done been modified since tha last test run.
.ie n .IP """save""" 4
.el .IP "\f(CWsave\fR" 4
.IX Item "save"
Save tha state on exit. Da state is stored up in a gangbangin' file called \fI.prove\fR
(\fI_prove\fR on Windows n' \s-1VMS\s0) up in tha current directory.
.PP
Da \f(CW\*(C`\-\-state\*(C'\fR switch may be used mo' than once.
.PP
.Vb 1
\&    $ prove \-b \-\-state=hot \-\-state=all,save
.Ve
.SS "\-\-rules"
.IX Subsection "--rules"
Da \f(CW\*(C`\-\-rules\*(C'\fR option is used ta control which tests is run sequentially and
which is run up in parallel, if tha \f(CW\*(C`\-\-jobs\*(C'\fR option is specified. Y'all KNOW dat shit, muthafucka! Da option may
be specified multiple times, n' tha order matters.
.PP
Da most practical use is likely ta specify dat some tests is not
\&\*(L"parallel-ready\*(R".  Since mentionin a gangbangin' file wit \-\-rulez doens't cause it to
selected ta run as a test, you can \*(L"set n' forget\*(R" some rulez preferences in
your .proverc file. Then you gonna be able ta take maximum advantage of the
performizzle benefitz of parallel testing, while some exceptions is still run
in parallel.
.PP
\fI\-\-rulez examples\fR
.IX Subsection "--rulez examples"
.PP
.Vb 2
\&    # All tests is allowed ta run up in parallel, except dem startin wit "p"
\&    \-\-rules=\*(Aqseq=t/p*.t\*(Aq \-\-rules=\*(Aqpar=**\*(Aq
\&
\&    # All tests must run up in sequence except dem startin wit "p", which should be run parallel
\&    \-\-rules=\*(Aqpar=t/p*.t\*(Aq
.Ve
.PP
\fI\-\-rulez resolution\fR
.IX Subsection "--rulez resolution"
.IP "\(bu" 4
By default, all tests is eligible ta be run up in parallel. Right back up in yo muthafuckin ass. Specifyin any of yo' own rulez removes dis one.
.IP "\(bu" 4
\&\*(L"First match wins\*(R". Da first rule dat matches a test is ghon be tha one dat applies.
.IP "\(bu" 4
Any test which do not match a rule is ghon be run up in sequence all up in tha end of tha run.
.IP "\(bu" 4
Da existence of a rule do not imply selectin a test. Yo ass must still specify tha tests ta run.
.IP "\(bu" 4
Specifyin a rule ta allow tests ta run up in parallel do not make tha run up in parallel. Yo ass still need specify tha number of parallel \f(CW\*(C`jobs\*(C'\fR up in yo' Harnizz object.
.PP
\fI\-\-rulez Glob-style pattern matching\fR
.IX Subsection "--rulez Glob-style pattern matching"
.PP
We implement our own glob-style pattern matchin fo' \-\-rulez yo. Here is the
supported patterns:
.PP
.Vb 5
\&    ** be any number of characters, includin /, within a pathname
\&    * is zero or mo' charactas within a gangbangin' filename/directory name
\&    ? is exactly one characta within a gangbangin' filename/directory name
\&    {foo,bar,baz} be any of foo, bar or baz.
\&    \e be a escape character
.Ve
.PP
\fIMo' advizzle justifications fo' parallel vs sequence run rules\fR
.IX Subsection "Mo' advizzle justifications fo' parallel vs sequence run rules"
.PP
If you need mo' advanced pimpment of what tha fuck runs up in parallel vs up in sequence, see
the associated 'rules' documentation up in TAP::Harnizz n' TAP::Parser::Scheduler.
If whatz possible directly all up in \f(CW\*(C`prove\*(C'\fR aint sufficient, you can write yo' own
harnizz ta access these features directly.
.ie n .SS "@INC"
.el .SS "\f(CW@INC\fP"
.IX Subsection "@INC"
prove introduces a separation between \*(L"options passed ta tha perl which
runs prove\*(R" n' \*(L"options passed ta tha perl which runs tests\*(R"; this
distinction is by design. I aint talkin' bout chicken n' gravy biatch. Thus tha perl which is hustlin a test starts
with tha default \f(CW@INC\fR fo' realz. Additionizzle library directories can be added
via tha \f(CW\*(C`PERL5LIB\*(C'\fR environment variable, via \-Ifoo up in \f(CW\*(C`PERL5OPT\*(C'\fR or
via tha \f(CW\*(C`\-Ilib\*(C'\fR option ta \fIprove\fR.
.SS "Taint Mode"
.IX Subsection "Taint Mode"
Normally when a Perl program is run up in taint mode tha contentz of the
\&\f(CW\*(C`PERL5LIB\*(C'\fR environment variable do not step tha fuck up in \f(CW@INC\fR.
.PP
Because \f(CW\*(C`PERL5LIB\*(C'\fR is often used durin testin ta add build
directories ta \f(CW@INC\fR prove passes tha namez of any directories found
in \f(CW\*(C`PERL5LIB\*(C'\fR as \-I switches. Da net effect of dis is that
\&\f(CW\*(C`PERL5LIB\*(C'\fR is honoured even when prove is run up in taint mode.
.SH "FORMATTERS"
.IX Header "FORMATTERS"
Yo ass can load a cold-ass lil custom TAP::Parser::Formatter:
.PP
.Vb 1
\&  prove \-\-formatta MyFormatter
.Ve
.SH "SOURCE HANDLERS"
.IX Header "SOURCE HANDLERS"
Yo ass can load custom TAP::Parser::SourceHandlezs, ta chizzle tha way the
parser interprets particular \fIsources\fR of \s-1TAP.\s0
.PP
.Vb 1
\&  prove \-\-source MyHandlez \-\-source YetAnother t
.Ve
.PP
If you wanna provide config ta tha source you can use:
.PP
.Vb 4
\&  prove \-\-source MyCustom \e
\&        \-\-source Perl \-\-perl\-option \*(Aqfoo=bar baz\*(Aq \-\-perl\-option avg=0.278 \e
\&        \-\-source File \-\-file\-option extensions=.txt \-\-file\-option extensions=.tmp t
\&        \-\-source pgTAP \-\-pgtap\-option pset=format=html \-\-pgtap\-option pset=border=2
.Ve
.PP
Each \f(CW\*(C`\-\-$source\-option\*(C'\fR option must specify a key/value pair separated by an
\&\f(CW\*(C`=\*(C'\fR. If a option can take multiple joints, just specify it multiple times,
as wit tha \f(CW\*(C`extensions=\*(C'\fR examplez above. If tha option should be a hash
reference, specify tha value as a second pair separated by a \f(CW\*(C`=\*(C'\fR, as up in the
\&\f(CW\*(C`pset=\*(C'\fR examplez above (escape \f(CW\*(C`=\*(C'\fR wit a funky-ass backslash).
.PP
All \f(CW\*(C`\-\-sources\*(C'\fR is combined tha fuck into a hash, n' passed ta \*(L"new\*(R" up in TAP::Harness's
\&\f(CW\*(C`sources\*(C'\fR parameter.
.PP
See TAP::Parser::IteratorFactory fo' mo' details on how tha fuck configuration is
passed ta \fISourceHandlezs\fR.
.SH "PLUGINS"
.IX Header "PLUGINS"
Plugins can be loaded rockin tha \f(CW\*(C`\-P\f(CIplugin\f(CW\*(C'\fR syntax, eg:
.PP
.Vb 1
\&  prove \-PMyPlugin
.Ve
.PP
This will search fo' a module named \f(CW\*(C`App::Prove::Plugin::MyPlugin\*(C'\fR, or failing
that, \f(CW\*(C`MyPlugin\*(C'\fR.  If tha plugin can't be found, \f(CW\*(C`prove\*(C'\fR will diss & exit.
.PP
Yo ass can pass arguments ta yo' plugin by appendin \f(CW\*(C`=arg1,arg2,etc\*(C'\fR ta the
plugin name:
.PP
.Vb 1
\&  prove \-PMyPlugin=fou,du,fafa
.Ve
.PP
Please check individual plugin documentation fo' mo' details.
.SS "Available Plugins"
.IX Subsection "Available Plugins"
For a up-to-date list of plugins available, please check \s-1CPAN:\s0
.PP
<http://search.cpan.org/search?query=App%3A%3AProve+Plugin>
.SS "Freestylin Plugins"
.IX Subsection "Freestylin Plugins"
Please peep \*(L"\s-1PLUGINS\*(R"\s0 up in App::Prove.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Yo dawwwwg! \fBDa above document had some codin errors, which is explained below:\fR
.IP "Around line 291:" 4
.IX Item "Around line 291:"
Unknown directive: =over4
.IP "Around line 293:" 4
.IX Item "Around line 293:"
\&'=item' outside of any '=over'
