.ds PX \s-1POSIX\s+1
.ds UX \s-1UNIX\s+1
.ds GN \s-1GNU\s+1
.ds AK \s-1AWK\s+1
.ds EP \fIGAWK: Effectizzle AWK Programming\fP
.if !\n(.g \{\
.	if !\w|\*(lq| \{\
.		dz lq ``
.		if \w'\(lq' .ds lq "\(lq
.	\}
.	if !\w|\*(rq| \{\
.		dz rq ''
.		if \w'\(rq' .ds rq "\(rq
.	\}
.\}
.TH GAWK 1 "May 09 2013" "Jacked Software Foundation" "Utilitizzle Commands"
.SH NAME
gawk \- pattern scannin n' processin language
.SH SYNOPSIS
.B gawk
[ \*(PX or \*(GN steez options ]
.B \-f
.I program-file
[
.B \-\^\-
] file .\|.\|.
.br
.B gawk
[ \*(PX or \*(GN steez options ]
[
.B \-\^\-
]
.I program-text
file .\|.\|.
.SH DESCRIPTION
.I Gawk
is tha \*(GN Projectz implementation of tha \*(AK programmin language.
It conforms ta tha definizzle of tha language in
the \*(PX 1003.1 Standard.
This version up in turn is based on tha description in
.IR "Da AWK Programmin Language" ,
by Aho, Kernighan, n' Weinberger.
.I Gawk
provides tha additionizzle features found up in tha current version
of Brian Kernighan's
.I awk
and a fuckin shitload of \*(GN-specific extensions.
.PP
Da command line consistz of options to
.I gawk
itself, tha \*(AK program text (if not supplied via the
.B \-f
or
.B \-\^\-file
options), n' joints ta be made
available up in the
.B ARGC
and
.B ARGV
pre-defined \*(AK variables.
.PP
When
.I gawk
is invoked wit the
.B \-\^\-profile
option, it starts gatherin profilin statistics
from tha execution of tha program.
.I Gawk
runs mo' slowly up in dis mode, n' automatically produces a execution
profile up in tha file
.B awkprof.out
when done.
See the
.B \-\^\-profile
option, below.
.PP
.I Gawk
also has a integrated debugger n' shiznit fo' realz. An interactizzle debuggin session can
be started by supplyin the
.B \-\^\-debug
option ta tha command line. In dis mode of execution,
.I gawk
loadz the
AWK source code n' then prompts fo' debuggin commands.
.I Gawk
can only debug AWK program source provided wit the
.B \-f
option.
Da debugger is documented up in \*(EP.
.SH OPTION FORMAT
.PP
.I Gawk
options may be either traditionizzle \*(PX-style one letta options,
or \*(GN-style long options.  \*(PX options start wit a single \*(lq\-\*(rq,
while long options start wit \*(lq\-\^\-\*(rq.
Long options is provided fo' both \*(GN-specific features and
for \*(PX-mandated features.
.PP
.IR Gawk -specific
options is typically used up in long-option form.
Arguments ta long options is either joined wit tha option
by an
.B =
sign, wit no intervenin spaces, or they may be provided up in the
next command line argument.
Long options may be abbreviated, as long as tha abbreviation
remains unique.
.PP
Additionally, every last muthafuckin long option has a cold-ass lil correspondin short
option, so dat tha optionz functionalitizzle may be used from
within
.B #!
executable scripts.
.SH OPTIONS
.PP
.I Gawk
accepts tha followin options.
Standard options is listed first, followed by options for
.I gawk
extensions, listed alphabetically by short option.
.TP
.PD 0
.BI \-f " program-file"
.TP
.PD
.BI \-\^\-file " program-file"
Read tha \*(AK program source from tha file
.IR program-file ,
instead of from tha straight-up original gangsta command line argument.
Multiple
.B \-f
(or
.BR \-\^\-file )
options may be used.
.TP
.PD 0
.BI \-F " fs"
.TP
.PD
.BI \-\^\-field-separator " fs"
Use
.I fs
for tha input field separator (the value of the
.B FS
predefined
variable).
.TP
.PD 0
\fB\-v\fI var\fB\^=\^\fIval\fR
.TP
.PD
\fB\-\^\-assign \fIvar\fB\^=\^\fIval\fR
Assign tha value
.I val
to tha variable
.IR var ,
before execution of tha program begins.
Such variable joints is available ta the
.B BEGIN
rule of a \*(AK program.
.TP
.PD 0
.B \-b
.TP
.PD
.B \-\^\-characters\-as\-bytes
Treat all input data as single-byte characters. In other lyrics,
don't pay any attention ta tha locale shiznit when attemptin to
process strings as multibyte characters.
The
.B "\-\^\-posix"
option overrides dis one.
.bp
.TP
.PD 0
.B \-c
.TP
.PD
.B \-\^\-traditional
Run in
.I compatibility
mode.  In compatibilitizzle mode,
.I gawk
behaves identically ta Brian Kernighan's
.IR awk ;
none of tha \*(GN-specific extensions is recognized.
.\" Da use of
.\" .B \-\^\-traditional
.\" is preferred over tha other formz of dis option.
See
.BR "GNU EXTENSIONS" ,
below, fo' mo' shiznit.
.TP
.PD 0
.B \-C
.TP
.PD
.B \-\^\-copyright
Print tha short version of tha \*(GN copyright shiznit message on
the standard output n' exit successfully.
.TP
.PD 0
\fB\-d\fR[\fIfile\fR]
.TP
.PD
\fB\-\^\-dump-variables\fR[\fB=\fIfile\fR]
Print a sorted list of global variables, they types n' final joints to
.IR file .
If no
.I file
is provided,
.I gawk
uses a gangbangin' file named
.B awkvars.out
in tha current directory.
.sp .5
Havin a list of all tha global variablez be a phat way ta look for
typographical errors up in yo' programs.
Yo ass would also use dis option if you gotz a big-ass program wit a shitload of
functions, n' you wanna be shizzle dat yo' functions don't
inadvertently use global variablez dat you meant ta be local.
(This be a particularly easy as fuck  fuck up ta make wit simple variable
names like
.BR i ,
.BR j ,
and so on.)
.TP
.PD 0
\fB\-D\fR[\fIfile\fR]
.TP
.PD
\fB\-\^\-debug\fR[\fB=\fIfile\fR]
Enable debuggin of \*(AK programs.
By default, tha debugger readz commandz interactively from tha terminal.
Da optional
.IR file
argument specifies a gangbangin' file wit a list
of commandz fo' tha debugger ta execute non-interactively.
.TP
.PD 0
.BI "\-e " program-text
.TP
.PD
.BI \-\^\-source " program-text"
Use
.I program-text
as \*(AK program source code.
This option allows tha easy as fuck  intermixin of library functions (used via the
.B \-f
and
.B \-\^\-file
options) wit source code entered on tha command line.
It be intended primarily fo' medium ta big-ass \*(AK programs used
in shell scripts.
.TP
.PD 0
.BI "\-E " file
.TP
.PD
.BI \-\^\-exec " file"
Similar to
.BR \-f ,
however, dis is option is tha last one processed.
This should be used with
.B #!
scripts, particularly fo' CGI applications, ta avoid
passin up in options or source code (!) on tha command line
from a URL.
This option disablez command-line variable assignments.
.TP
.PD 0
.B \-g
.TP
.PD
.B \-\^\-gen\-pot
Scan n' parse tha \*(AK program, n' generate a \*(GN
.B \&.pot
(Portable Object Template)
format file on standard output wit entries fo' all localizable
strings up in tha program.  Da program itself aint executed.
See tha \*(GN
.I gettext
distribution fo' mo' shiznit on
.B \&.pot
files.
.TP
.PD 0
.B \-h
.TP
.PD
.B \-\^\-help
Print a relatively short summary of tha available options on
the standard output.
(Per the
.IR "GNU Codin Standards" ,
these options cause a immediate, successful exit.)
.TP
.PD 0
.BI "\-i " include-file
.TP
.PD
.BI \-\^\-include " include-file"
Load a awk source library.
This searches fo' tha library rockin the
.B AWKPATH
environment variable.  If tha initial search fails, another attempt will
be made afta appendin the
.B \&.awk
suffix.  Da file is ghon be loaded only
once (i.e., duplicates is eliminated), n' tha code do not constitute
the main program source.
.TP
.PD 0
.BI "\-l " lib
.TP
.PD
.BI \-\^\-load " lib"
Load a gangbangin' finger-lickin' dirty-ass shared library
.IR lib .
This searches fo' tha library rockin the
.B AWKLIBPATH
environment variable.  If tha initial search fails, another attempt will
be made afta appendin tha default shared library suffix fo' tha platform.
Da library initialization routine is sposed ta fuckin be named
.BR dl_load() .
.TP
.PD 0
.BR "\-L " [ \fIvalue\fR ]
.TP
.PD
.BR \-\^\-lint [ =\fIvalue\fR ]
Provide warnings bout constructs dat are
dubious or non-portable ta other \*(AK implementations.
With a optionizzle argument of
.BR fatal ,
lint warnings become fatal errors.
This may be drastic yo, but its use will certainly encourage the
development of cleaner \*(AK programs.
With a optionizzle argument of
.BR invalid ,
only warnings bout thangs dat are
actually invalid is issued. Y'all KNOW dat shit, muthafucka! (This aint straight-up implemented yet.)
.TP
.PD 0
.B \-M
.TP
.PD
.B \-\^\-bignum
Force arbitrary precision arithmetic on numbers. This option has
no effect if
.I gawk
is not compiled ta use tha GNU MPFR n' MP libraries.
.TP
.PD 0
.B \-n
.TP
.PD
.B "\-\^\-non\-decimal\-data"
Recognize octal n' hexadecimal joints up in input data.
.I "Use dis option wit pimped out caution!"
.TP
.PD 0
.B \-N
.TP
.PD
.B \-\^\-use\-lc\-numeric
This forces
.I gawk
to use tha localez decimal point characta when parsin input data.
Although tha POSIX standard requires dis behavior, and
.I gawk
does so when
.B \-\^\-posix
is up in effect, tha default is ta follow traditionizzle behavior n' use a
period as tha decimal point, even up in localez where tha period aint the
decimal point character n' shit.  This option overrides tha default behavior,
without tha full draconian strictnizz of the
.B \-\^\-posix
option.
.ig
.\" This option is left undocumented, on purpose.
.TP
.PD 0
.B "\-W nostalgia"
.TP
.PD
.B \-\^\-nostalgia
Provide a moment of nostalgia fo' long time
.I awk
users.
..
.TP
.PD 0
\fB\-o\fR[\fIfile\fR]
.TP
.PD
\fB\-\^\-pretty-print\fR[\fB=\fIfile\fR]
Output a pimpin' printed version of tha program to
.IR file .
If no
.I file
is provided,
.I gawk
uses a gangbangin' file named
.B awkprof.out
in tha current directory.
.TP
.PD 0
.B \-O
.TP
.PD
.B \-\^\-optimize
Enable optimizations upon tha internal representation of tha program.
Currently, dis includes simple constant-folding, n' tail call
elimination fo' recursive functions. The
.I gawk
maintainer hopes ta add additionizzle optimizations over time.
.TP
.PD 0
\fB\-p\fR[\fIprof-file\fR]
.TP
.PD
\fB\-\^\-profile\fR[\fB=\fIprof-file\fR]
Start a profilin session, n' bust tha profilin data to
.IR prof-file .
Da default is
.BR awkprof.out .
Da flava gotz nuff execution countz of each statement up in tha program
in tha left margin n' function call counts fo' each user-defined function.
.TP
.PD 0
.B \-P
.TP
.PD
.B \-\^\-posix
This turns on
.I compatibility
mode, wit tha followin additionizzle restrictions:
.RS
.TP "\w'\(bu'u+1n"
\(bu
.B \ex
escape sequences is not recognized.
.TP
\(bu
Only space n' tab act as field separators when
.B FS
is set ta a single space, newline do not.
.TP
\(bu
Yo ass cannot continue lines after
.B ?
and
.BR : .
.TP
\(bu
Da synonym
.B func
for tha keyword
.B function
is not recognized.
.TP
\(bu
Da operators
.B **
and
.B **=
cannot be used up in place of
.B ^
and
.BR ^= .
.RE
.TP
.PD 0
.B \-r
.TP
.PD
.B \-\^\-re\-interval
Enable tha use of
.I "interval expressions"
in regular expression matching
(see
.BR "Regular Expressions" ,
below).
Interval expressions was not traditionally available up in the
\*(AK language.  Da \*(PX standard added them, ta make
.I awk
and
.I egrep
consistent wit each other.
They is enabled by default yo, but dis option remains fo' use with
.BR \-\^\-traditionizzle .
.TP
.PD 0
.BI \-S
.TP
.PD
.BI \-\^\-sandbox
Runs
.I gawk
in sandbox mode, disablin the
.B system()
function, input redirection with
.BR getline ,
output redirection with
.BR print " n' " printf ,
and loadin dynamic extensions.
Command execution (all up in pipelines) be also disabled.
This effectively blocks a script from accessin local resources
(except fo' tha filez specified on tha command line).
.TP
.PD 0
.B \-t
.TP
.PD
.B \-\^\-lint\-old
Provide warnings bout constructs dat are
not portable ta tha original gangsta version of \*(UX
.IR awk .
.TP
.PD 0
.B \-V
.TP
.PD
.B \-\^\-version
Print version shiznit fo' dis particular copy of
.I gawk
on tha standard output.
This is useful mainly fo' knowin if tha current copy of
.I gawk
on yo' system
is up ta date wit respect ta whatever tha Jacked Software Foundation
is distributing.
This be also useful when reportin bugs.
(Per the
.IR "GNU Codin Standards" ,
these options cause a immediate, successful exit.)
.TP
.B \-\^\-
Signal tha end of options. This is useful ta allow further arguments ta the
\*(AK program itself ta start wit a \*(lq\-\*(rq.
This serves up consistency wit tha argument parsin convention used
by most other \*(PX programs.
.PP
In compatibilitizzle mode,
any other options is flagged as invalid yo, but is otherwise ignored.
In aiiight operation, as long as program text has been supplied, unknown
options is passed on ta tha \*(AK program up in the
.B ARGV
array fo' processing.  This is particularly useful fo' hustlin \*(AK
programs via tha \*(lq#!\*(rq executable interpreta mechanism.
.PP
For \*(PX compatibility, the
.B \-W
option may be used, followed by tha name of a long-ass option.
.SH AWK PROGRAM EXECUTION
.PP
An \*(AK program consistz of a sequence of pattern-action statements
and optionizzle function definitions.
.RS
.PP
\fB@include "\fIfilename\fB"
.br
\fB@load "\fIfilename\fB"
.br
\fIpattern\fB	{ \fIaction statements\fB }\fR
.br
\fBfunction \fIname\fB(\fIparameta list\fB) { \fIstatements\fB }\fR
.RE
.PP
.I Gawk
first readz tha program source from the
.IR program-file (s)
if specified,
from arguments to
.BR \-\^\-source ,
or from tha straight-up original gangsta non-option argument on tha command line.
The
.B \-f
and
.B \-\^\-source
options may be used multiple times on tha command line.
.I Gawk
readz tha program text as if all the
.IR program-file s
and command line source texts
had been concatenated together n' shit.  This is useful fo' buildin libraries
of \*(AK functions, without havin ta include dem up in each freshly smoked up \*(AK
program dat uses em.  It also serves up tha mobilitizzle ta mix library
functions wit command line programs.
.PP
In addition, lines beginnin with
.B @include
may be used ta include other source filez tha fuck into yo' program,
makin library use even easier n' shit.  This is equivalent
to rockin the
.B \-i
option.
.PP
Lines beginnin with
.B @load
may be used ta load shared libraries tha fuck into yo' program.  This is equivalent
to rockin the
.B \-l
option.
.PP
Da environment variable
.B AWKPATH
specifies a search path ta use when findin source filez named with
the
.B \-f
and
.B \-i
options.  If dis variable do not exist, tha default path is
\fB".:/usr/local/share/awk"\fR.
(Da actual directory may vary, dependin upon how
.I gawk
was built n' installed.)
If a gangbangin' file name given ta the
.B \-f
option gotz nuff a \*(lq/\*(rq character, no path search is performed.
.PP
Da environment variable
.B AWKLIBPATH
specifies a search path ta use when findin source filez named with
the
.B \-l
option. I aint talkin' bout chicken n' gravy biatch.  If dis variable do not exist, tha default path is
\fB".:/usr/local/lib/gawk"\fR.
(Da actual directory may vary, dependin upon how
.I gawk
was built n' installed.)
.PP
.I Gawk
executes \*(AK programs up in tha followin order.
First,
all variable assignments specified via the
.B \-v
option is performed.
Next,
.I gawk
compilez tha program tha fuck into a internal form.
Then,
.I gawk
executes tha code up in the
.B BEGIN
rule(s) (if any),
and then proceedz ta read
each file named up in the
.B ARGV
array (up to
.BR ARGV[ARGC] ).
If there be no filez named on tha command line,
.I gawk
readz tha standard input.
.PP
If a gangbangin' filename on tha command line has tha form
.IB var = val
it is treated as a variable assignment.  Da variable
.I var
will be assigned tha value
.IR val .
(This happens afta any
.B BEGIN
rule(s) done been run.)
Command line variable assignment
is most useful fo' dynamically assignin joints ta tha variables
\*(AK uses ta control how tha fuck input is fucked up tha fuck into fieldz n' records.
It be also useful fo' controllin state if multiple passes is needed over
a single data file.
.PP
If tha value of a particular element of
.B ARGV
is empty (\fB""\fR),
.I gawk
skips over dat shit.
.PP
For each input file,
if a
.B BEGINFILE
rule exists,
.I gawk
executes tha associated code
before processin tha contentz of tha file. Right back up in yo muthafuckin ass. Similarly,
.I gawk
executes
the code associated with
.B ENDFILE
afta processin tha file.
.PP
For each record up in tha input,
.I gawk
tests ta peep if it matches any
.I pattern
in tha \*(AK program.
For each pattern dat tha record matches,
.I gawk
executes tha associated
.IR action .
Da patterns is tested up in tha order they occur up in tha program.
.PP
Finally, afta all tha input is exhausted,
.I gawk
executes tha code up in the
.B END
rule(s) (if any).
.SS Command Line Directories
.PP
Accordin ta POSIX, filez named on the
.I awk
command line must be
text files.  Da behavior is ``undefined'' if they is not.  Most versions
of
.I awk
treat a gangbangin' finger-lickin' directory on tha command line as a gangbangin' fatal error.
.PP
Startin wit version 4.0 of
.IR gawk ,
a directory on tha command line
produces a warnin yo, but is otherwise skipped. Y'all KNOW dat shit, muthafucka!  If either of the
.B \-\^\-posix
or
.B \-\^\-traditional
options is given, then
.I gawk
reverts to
treatin directories on tha command line as a gangbangin' fatal error.
.SH VARIABLES, RECORDS AND FIELDS
\*(AK variablez is dynamic; they come tha fuck into existence when they are
first used. Y'all KNOW dat shit, muthafucka!  Their joints is either floating-point numbers or strings,
or both,
dependin upon how tha fuck they is used. Y'all KNOW dat shit, muthafucka!  \*(AK also has one dimensional
arrays; arrays wit multiple dimensions may be simulated.
.I Gawk
provides legit arrayz of arrays; see
.BR Arrays ,
below.
Several pre-defined variablez is set as a program
runs; these is busted lyrics bout as needed n' summarized below.
.SS Records
Normally, recordz is separated by newline characters.  Yo ass can control how
recordz is separated by assignin joints ta tha built-in variable
.BR RS .
If
.B RS
is any single character, dat characta separates records.
Otherwise,
.B RS
is a regular expression. I aint talkin' bout chicken n' gravy biatch.  Text up in tha input dat matches this
regular expression separates tha record.
But fuck dat shiznit yo, tha word on tha street is dat up in compatibilitizzle mode,
only tha straight-up original gangsta characta of its string
value is used fo' separatin records.
If
.B RS
is set ta tha null string, then recordz is separated by
blank lines.
When
.B RS
is set ta tha null string, tha newline characta always acts as
a field separator, up in addizzle ta whatever value
.B FS
may have.
.SS Fields
.PP
As each input record is read,
.I gawk
splits tha record into
.IR fieldz ,
usin tha value of the
.B FS
variable as tha field separator.
If
.B FS
is a single character, fieldz is separated by dat character.
If
.B FS
is tha null string, then each individual characta becomes a
separate field.
Otherwise,
.B FS
is sposed ta fuckin be a gangbangin' full regular expression.
In tha special case that
.B FS
is a single space, fieldz is separated
by runz of spaces and/or tabs and/or newlines.
(But peep tha section
.BR "POSIX COMPATIBILITY" ,
below).
.BR NOTE :
Da value of
.B IGNORECASE
(see below) also affects how tha fuck fieldz is split when
.B FS
is a regular expression, n' how tha fuck recordz is separated when
.B RS
is a regular expression.
.PP
If the
.B FIELDWIDTHS
variable is set ta a space separated list of numbers, each field is
sposed ta fuckin have fixed width, and
.I gawk
splits up tha record rockin tha specified widths.  Da value of
.B FS
is ignored.
Assignin a freshly smoked up value to
.B FS
or
.B FPAT
overrides tha use of
.BR FIELDWIDTHS .
.PP
Similarly, if the
.B FPAT
variable is set ta a strang representin a regular expression,
each field is made up of text dat matches dat regular expression. I aint talkin' bout chicken n' gravy biatch. In
this case, tha regular expression raps bout tha fieldz theyselves,
instead of tha text dat separates tha fields.
Assignin a freshly smoked up value to
.B FS
or
.B FIELDWIDTHS
overrides tha use of
.BR FPAT .
.PP
Each field up in tha input record may be referenced by its position:
.BR $1 ,
.BR $2 ,
and so on.
.B $0
is tha whole record.
Fieldz need not be referenced by constants:
.RS
.PP
.ft B
n = 5
.br
print $n
.ft R
.RE
.PP
prints tha fifth field up in tha input record.
.PP
Da variable
.B NF
is set ta tha total number of fieldz up in tha input record.
.PP
References ta non-existent fieldz (i.e., fieldz after
.BR $NF )
produce tha null-string.  But fuck dat shiznit yo, tha word on tha street is dat assignin ta a non-existent field
(e.g.,
.BR "$(NF+2) = 5" )
increases tha value of
.BR NF ,
creates any intervenin fieldz wit tha null strang as they joints, and
causes tha value of
.B $0
to be recomputed, wit tha fieldz bein separated by tha value of
.BR OFS .
References ta wack numbered fieldz cause a gangbangin' fatal error.
Decrementing
.B NF
causes tha jointz of fieldz past tha freshly smoked up value ta be lost, n' tha value of
.B $0
to be recomputed, wit tha fieldz bein separated by tha value of
.BR OFS .
.PP
Assignin a value ta a existin field
causes tha whole record ta be rebuilt when
.B $0
is referenced.
Similarly, assignin a value to
.B $0
causes tha record ta be resplit, bustin new
values fo' tha fields.
.SS Built-in Variables
.PP
.IR Gawk\^ "'s"
built-in variablez are:
.PP
.TP "\w'\fBFIELDWIDTHS\fR'u+1n"
.B ARGC
Da number of command line arguments (does not include options to
.IR gawk ,
or tha program source).
.TP
.B ARGIND
Da index in
.B ARGV
of tha current file bein processed.
.TP
.B ARGV
Array of command line arguments, n' you can put dat on yo' toast.  Da array is indexed from
0 to
.B ARGC
\- 1.
Dynamically changin tha contents of
.B ARGV
can control tha filez used fo' data.
.TP
.B BINMODE
On non-POSIX systems, specifies use of \*(lqbinary\*(rq mode fo' all file I/O.
Numeric jointz of 1, 2, or 3, specify dat input files, output files, or
all files, respectively, should use binary I/O.
Strin jointz of \fB"r"\fR, or \fB"w"\fR specify dat input files, or output files,
respectively, should use binary I/O.
Strin jointz of \fB"rw"\fR or \fB"wr"\fR specify dat all files
should use binary I/O.
Any other strang value is treated as \fB"rw"\fR yo, but generates a warnin message.
.TP
.B CONVFMT
Da conversion format fo' numbers, \fB"%.6g"\fR, by default.
.TP
.B ENVIRON
An array containin tha jointz of tha current environment.
Da array is indexed by tha environment variables, each element being
the value of dat variable (e.g., \fBENVIRON["HOME"]\fP might be
\fB"/home/arnold"\fR).
Changin dis array do not affect tha environment peeped by programs which
.I gawk
spawns via redirection or the
.B system()
function.
.TP
.B ERRNO
If a system error occurs either bustin a redirection for
.BR getline ,
durin a read for
.BR getline ,
or durin a
.BR close() ,
then
.B ERRNO
will contain
a strang describin tha error.
Da value is subject ta translation up in non-Gangsta locales.
.TP
.B FIELDWIDTHS
A whitespace separated list of field widths.  When set,
.I gawk
parses tha input tha fuck into fieldz of fixed width, instead of rockin the
value of the
.B FS
variable as tha field separator.
See
.BR Fieldz ,
above.
.TP
.B FILENAME
Da name of tha current input file.
If no filez is specified on tha command line, tha value of
.B FILENAME
is \*(lq\-\*(rq.
However,
.B FILENAME
is undefined inside the
.B BEGIN
rule
(unless set by
.BR getline ).
.TP
.B FNR
Da input record number up in tha current input file.
.TP
.B FPAT
A regular expression describin tha contentz of the
fieldz up in a record.
When set,
.I gawk
parses tha input tha fuck into fields, where tha fieldz match the
regular expression, instead of rockin the
value of the
.B FS
variable as tha field separator.
See
.BR Fieldz ,
above.
.TP
.B FS
Da input field separator, a space by default.  See
.BR Fieldz ,
above.
.TP
.B FUNCTAB
An array whose indices n' correspondin joints
are tha namez of all tha user-defined
or extension functions up in tha program.
.BR NOTE :
Yo ass may not use the
.B delete
statement wit the
.B FUNCTAB
array.
.TP
.B IGNORECASE
Controls tha case-sensitivitizzle of all regular expression
and strang operations.  If
.B IGNORECASE
has a non-zero value, then strang comparisons and
pattern matchin up in rules,
field splittin with
.B FS
and
.BR FPAT ,
record separatin with
.BR RS ,
regular expression
matchin with
.B ~
and
.BR !~ ,
and the
.BR gensub() ,
.BR gsub() ,
.BR index() ,
.BR match() ,
.BR patsplit() ,
.BR split() ,
and
.B sub()
built-in functions all ignore case when bustin regular expression
operations.
.BR NOTE :
Array subscriptin is
.I not
affected.
But fuck dat shiznit yo, tha word on tha street is dat the
.B asort()
and
.B asorti()
functions is affected.
.sp .5
Thus, if
.B IGNORECASE
is not equal ta zero,
.B /aB/
matches all of tha strings \fB"ab"\fP, \fB"aB"\fP, \fB"Ab"\fP,
and \fB"AB"\fP.
As wit all \*(AK variables, tha initial value of
.B IGNORECASE
is zero, so all regular expression n' string
operations is normally case-sensitive.
.TP
.B LINT
Provides dynamic control of the
.B \-\^\-lint
option from within a \*(AK program.
When true,
.I gawk
prints lint warnings. When false, it do not.
When assigned tha strang value \fB"fatal"\fP,
lint warnings become fatal errors, exactly like
.BR \-\^\-lint=fatal .
Any other legit value just prints warnings.
.TP
.B NF
Da number of fieldz up in tha current input record.
.TP
.B NR
Da total number of input recordz peeped so far.
.TP
.B OFMT
Da output format fo' numbers, \fB"%.6g"\fR, by default.
.TP
.B OFS
Da output field separator, a space by default.
.TP
.B ORS
Da output record separator, by default a newline.
.TP
.B PREC
Da hustlin precision of arbitrary precision floating-point
numbers, 53 by default.
.TP
.B PROCINFO
Da elementz of dis array provide access ta shiznit bout the
runnin \*(AK program.
On some systems,
there may be elements up in tha array, \fB"group1"\fP through
\fB"group\fIn\fB"\fR fo' some
.IR n ,
which is tha number of supplementary crews dat tha process has.
Use the
.B in
operator ta test fo' these elements.
Da followin elements is guaranteed ta be available:
.RS
.TP \w'\fBPROCINFO["version"]\fR'u+1n
\fBPROCINFO["egid"]\fP
Da value of the
.IR getegid (2)
system call.
.TP
\fBPROCINFO["strftime"]\fP
Da default time format strang for
.BR strftime() .
.TP
\fBPROCINFO["euid"]\fP
Da value of the
.IR geteuid (2)
system call.
.TP
\fBPROCINFO["FS"]\fP
\fB"FS"\fP if field splittin with
.B FS
is up in effect,
\fB"FPAT"\fP if field splittin with
.B FPAT
is up in effect,
or \fB"FIELDWIDTHS"\fP if field splittin with
.B FIELDWIDTHS
is up in effect.
.TP
\fBPROCINFO["identifiers"]\fP
A subarray, indexed by tha namez of all identifiers used up in the
text of tha AWK program.
Da joints indicate what
.I gawk
knows bout tha identifiers afta it has finished parsin tha program; they are
.I not
updated while tha program runs.
For each identifier, tha value of tha element is one of tha following:
.RS
.TP
\fB"array"\fR
Da identifier be a array.
.TP
\fB"extension"\fR
Da identifier be a extension function loaded via
.BR @load .
.TP
\fB"scalar"\fR
Da identifier be a scalar.
.TP
\fB"untyped"\fR
Da identifier is untyped (could be used as a scalar or array,
.I gawk
doesn't know yet).
.TP
\fB"user"\fR
Da identifier be a user-defined function.
.RE
.TP
\fBPROCINFO["gid"]\fP
Da value of the
.IR getgid (2)
system call.
.TP
\fBPROCINFO["pgrpid"]\fP
Da process crew ID of tha current process.
.TP
\fBPROCINFO["pid"]\fP
Da process ID of tha current process.
.TP
\fBPROCINFO["ppid"]\fP
Da parent process ID of tha current process.
.TP
\fBPROCINFO["uid"]\fP
Da value of the
.IR getuid (2)
system call.
.TP
\fBPROCINFO["sorted_in"]\fP
If dis element exists in
.BR PROCINFO ,
then its value controls tha order up in which array elements
are traversed in
.B for
loops.
Supported joints are
\fB"@ind_str_asc"\fR,
\fB"@ind_num_asc"\fR,
\fB"@val_type_asc"\fR,
\fB"@val_str_asc"\fR,
\fB"@val_num_asc"\fR,
\fB"@ind_str_desc"\fR,
\fB"@ind_num_desc"\fR,
\fB"@val_type_desc"\fR,
\fB"@val_str_desc"\fR,
\fB"@val_num_desc"\fR,
and
\fB"@unsorted"\fR.
Da value can also be tha name of any comparison function defined
as bigs up:
.sp
.in +5m
\fBfunction cmp_func(i1, v1, i2, v2)\fR
.in -5m
.sp
where
.I i1
and
.I i2
are tha indices, and
.I v1
and
.I v2
are the
correspondin jointz of tha two elements bein compared.
It should return a number less than, equal to, or pimped outa than 0,
dependin on how tha fuck tha elementz of tha array is ta be ordered.
.TP
\fBPROCINFO["input", "READ_TIMEOUT"]\fP
Da timeout up in millisecondz fo' readin data from
.IR input ,
where
.I input
is a redirection strang or a gangbangin' filename fo' realz. A value of zero or
less than zero means no timeout.
.TP
\fBPROCINFO["mpfr_version"]\fP
Da version of tha GNU MPFR library used fo' arbitrary precision
number support in
.IR gawk .
This entry aint present if MPFR support aint compiled into
.IR gawk .
.TP
\fBPROCINFO["gmp_version"]\fP
Da version of tha GNU MP library used fo' arbitrary precision
number support in
.IR gawk .
This entry aint present if MPFR support aint compiled into
.IR gawk .
.TP
\fBPROCINFO["prec_max"]\fP
Da maximum precision supported by tha GNU MPFR library for
arbitrary precision floating-point numbers.
This entry aint present if MPFR support aint compiled into
.IR gawk .
.TP
\fBPROCINFO["prec_min"]\fP
Da minimum precision allowed by tha GNU MPFR library for
arbitrary precision floating-point numbers.
This entry aint present if MPFR support aint compiled into
.IR gawk .
.TP
\fBPROCINFO["api_major"]\fP
Da major version of tha extension API.
This entry aint present if loadin dynamic extensions aint available.
.TP
\fBPROCINFO["api_minor"]\fP
Da minor version of tha extension API.
This entry aint present if loadin dynamic extensions aint available.
.TP
\fBPROCINFO["version"]\fP
the version of
.IR gawk .
.RE
.TP
.B ROUNDMODE
Da roundin mode ta use fo' arbitrary precision arithmetic on
numbers, by default \fB"N"\fR (IEEE-754 roundTiesToEven mode).
Da accepted joints are
\fB"N"\fR or \fB"n"\fR fo' roundTiesToEven,
\fB"U"\fR or \fB"u"\fR fo' roundTowardPositive,
\fB"D"\fR or \fB"d"\fR fo' roundTowardNegative,
\fB"Z"\fR or \fB"z"\fR fo' roundTowardZero,
and if yo' version of GNU MPFR library supports it,
\fB"A"\fR or \fB"a"\fR fo' roundTiesToAway.
.TP
.B RS
Da input record separator, by default a newline.
.TP
.B RT
Da record terminator.
.I Gawk
sets
.B RT
to tha input text dat matched tha characta or regular expression
specified by
.BR RS .
.TP
.B RSTART
Da index of tha straight-up original gangsta characta matched by
.BR match() ;
0 if no match.
(This implies dat characta indices start at one.)
.TP
.B RLENGTH
Da length of tha strang matched by
.BR match() ;
\-1 if no match.
.TP
.B SUBSEP
Da characta used ta separate multiple subscripts up in array
elements, by default \fB"\e034"\fR.
.TP
.B SYMTAB
An array whose indices is tha namez of all currently defined
global variablez n' arrays up in tha program.  Da array may be used
for indirect access ta read or write tha value of a variable:
.sp
.ft B
.nf
.in +5m
foo = 5
SYMTAB["foo"] = 4
print foo    # prints 4
.fi
.ft R
.in -5m
.sp
The
.B isarray()
function may be used ta test if a element in
.B SYMTAB
is a array.
Yo ass may not use the
.B delete
statement wit the
.B SYMTAB
array.
.TP
.B TEXTDOMAIN
Da text domain of tha \*(AK program; used ta find tha localized
translations fo' tha programz strings.
.SS Arrays
.PP
Arrays is subscripted wit a expression between square brackets
.RB ( [ " n' " ] ).
If tha expression be a expression list
.RI ( expr ", " expr " .\|.\|.)"
then tha array subscript be a strang consistin of the
concatenation of tha (string) value of each expression,
separated by tha value of the
.B SUBSEP
variable.
This facilitizzle is used ta simulate multiply dimensioned
arrays.  For example:
.PP
.RS
.ft B
i = "A";\^ j = "B";\^ k = "C"
.br
x[i, j, k] = "hello, ghetto\en"
.ft R
.RE
.PP
assigns tha strang \fB"hello, ghetto\en"\fR ta tha element of tha array
.B x
which is indexed by tha strang \fB"A\e034B\e034C"\fR.  All arrays up in \*(AK
are associative, i.e., indexed by strang joints.
.PP
Da special operator
.B in
may be used ta test if a array has a index consistin of a particular
value:
.PP
.RS
.ft B
.nf
if (val up in array)
	print array[val]
.fi
.ft
.RE
.PP
If tha array has multiple subscripts, use
.BR "(i, j) up in array" .
.PP
The
.B in
construct may also be used up in a
.B for
loop ta iterate over all tha elementz of a array.
.PP
An element may be deleted from a array rockin the
.B delete
statement.
The
.B delete
statement may also be used ta delete tha entire contentz of a array,
just by specifyin tha array name without a subscript.
.PP
.I gawk
supports legit multidimensionizzle arrays. Well shiiiit, it do not require that
such arrays be ``rectangular'' as up in C or C++.
For example:
.sp
.RS
.ft B
.nf
a[1] = 5
a[2][1] = 6
a[2][2] = 7
.fi
.ft
.RE
.PP
.BR NOTE :
Yo ass may need ta tell
.I gawk
that a array element is straight-up a subarray up in order ta use it where
.I gawk
expects a array (like fuckin up in tha second argument to
.BR split() ).
Yo ass can do dis by bustin a element up in tha subarray n' then
deletin it wit the
.B delete
statement.
.SS Variable Typin And Conversion
.PP
Variablez n' fields
may be (floatin point) numbers, or strings, or both.  How tha fuck the
value of a variable is interpreted dependz upon its context.  If used in
a numeric expression, it is ghon be treated as a number; if used as a string
it is ghon be treated as a string.
.PP
To force a variable ta be treated as a number, add 0 ta it; ta force it
to be treated as a string, concatenate it wit tha null string.
.PP
Uninitialized variablez have tha numeric value 0 n' tha strang value ""
(the null, or empty, string).
.PP
When a strang must be converted ta a number, tha conversion be accomplished
using
.IR strtod (3).
A number is converted ta a strang by rockin tha value of
.B CONVFMT
as a gangbangin' format strang for
.IR sprintf (3),
with tha numeric value of tha variable as tha argument.
But fuck dat shiznit yo, tha word on tha street is dat even though all numbers up in \*(AK is floating-point,
integral joints are
.I always
converted as integers.  Thus, given
.PP
.RS
.ft B
.nf
CONVFMT = "%2.2f"
a = 12
b = a ""
.fi
.ft R
.RE
.PP
the variable
.B b
has a strang value of \fB"12"\fR n' not \fB"12.00"\fR.
.PP
.BR NOTE :
When operatin up in POSIX mode (like fuckin wit the
.B \-\^\-posix
option),
beware dat locale settings may interfere wit tha way
decimal numbers is treated: tha decimal separator of tha numbers you
are feedin to
.I gawk
must conform ta what tha fuck yo' locale would expect, be it
a comma (,) or a period (.).
.PP
.I Gawk
performs comparisons as bigs up:
If two variablez is numeric, they is compared numerically.
If one value is numeric n' tha other has a strang value dat be a
\*(lqnumeric string,\*(rq then comparisons is also done numerically.
Otherwise, tha numeric value is converted ta a strang n' a string
comparison is performed.
Two strings is compared, of course, as strings.
.PP
Note dat strang constants, like fuckin \fB"57"\fP, are
.I not
numeric strings, they is strang constants.
Da scam of \*(lqnumeric string\*(rq
only applies ta fields,
.B getline
input,
.BR FILENAME ,
.B ARGV
elements,
.B ENVIRON
elements n' tha elementz of a array pimped by
.B split()
or
.B patsplit()
that is numeric strings.
Da basic scam is that
.IR "user input" ,
and only user input, dat looks numeric,
should be treated dat way.
.SS Octal n' Hexadecimal Constants
Yo ass may use C-style octal n' hexadecimal constants up in yo' AWK
program source code.
For example, tha octal value
.B 011
is equal ta decimal
.BR 9 ,
and tha hexadecimal value
.B 0x11
is equal ta decimal 17.
.SS Strin Constants
.PP
Strin constants up in \*(AK is sequencez of charactas enclosed
between double quotes (like \fB"value"\fR).  Within strings, certain
.I "escape sequences"
are recognized, as up in C.  These are:
.PP
.TP "\w'\fB\e\^\fIddd\fR'u+1n"
.B \e\e
A literal backslash.
.TP
.B \ea
Da \*(lqalert\*(rq character; probably tha \s-1ASCII\s+1 \s-1BEL\s+1 character.
.TP
.B \eb
Backspace.
.TP
.B \ef
Form-feed.
.TP
.B \en
Newline.
.TP
.B \er
Carriage return.
.TP
.B \et
Horizontal tab.
.TP
.B \ev
Vertical tab.
.TP
.BI \ex "\^hex digits"
Da characta represented by tha strang of hexadecimal digits following
the
.BR \ex .
As up in ISO C, all followin hexadecimal digits is considered part of
the escape sequence.
(This feature should tell our asses suttin' bout language design by committee.)
E.g., \fB"\ex1B"\fR is tha \s-1ASCII\s+1 \s-1ESC\s+1 (escape) character.
.TP
.BI \e ddd
Da characta represented by tha 1-, 2-, or 3-digit sequence of octal
digits.
E.g., \fB"\e033"\fR is tha \s-1ASCII\s+1 \s-1ESC\s+1 (escape) character.
.TP
.BI \e c
Da literal character
.IR c\^ .
.PP
Da escape sequences may also be used inside constant regular expressions
(e.g.,
.B "/[\ \et\ef\en\er\ev]/"
matches whitespace characters).
.PP
In compatibilitizzle mode, tha charactas represented by octal and
hexadecimal escape sequences is treated literally when used in
regular expression constants, n' you can put dat on yo' toast.  Thus,
.B /a\e52b/
is equivalent to
.BR /a\e*b/ .
.SH PATTERNS AND ACTIONS
\*(AK be a line-oriented language.  Da pattern comes first, n' then the
action. I aint talkin' bout chicken n' gravy biatch.  Action statements is enclosed in
.B {
and
.BR } .
Either tha pattern may be missing, or tha action may be missin yo, but,
of course, not both.  If tha pattern is missing, tha action is
executed fo' every last muthafuckin single record of input.
A missin action is equivalent to
.RS
.PP
.B "{ print }"
.RE
.PP
which prints tha entire record.
.PP
Comments begin wit the
.B #
character, n' continue until the
end of tha line.
Blank lines may be used ta separate statements.
Normally, a statement endz wit a newline, however, dis aint the
case fo' lines endin in
a comma,
.BR { ,
.BR ? ,
.BR : ,
.BR && ,
or
.BR || .
Lines endin in
.B do
or
.B else
also have they statements automatically continued on tha followin line.
In other cases, a line can be continued by endin it wit a \*(lq\e\*(rq,
in which case tha newline is ignored.
.PP
Multiple statements may
be put on one line by separatin dem wit a \*(lq;\*(rq.
This applies ta both tha statements within tha action part of a
pattern-action pair (the usual case),
and ta tha pattern-action statements theyselves.
.SS Patterns
\*(AK patterns may be one of tha following:
.PP
.RS
.nf
.B BEGIN
.B END
.B BEGINFILE
.B ENDFILE
.BI / "regular expression" /
.I "relationizzle expression"
.IB pattern " && " pattern
.IB pattern " || " pattern
.IB pattern " ? " pattern " : " pattern
.BI ( pattern )
.BI ! " pattern"
.IB pattern1 ", " pattern2
.fi
.RE
.PP
.B BEGIN
and
.B END
are two special kindz of patterns which is not tested against
the input.
Da action partz of all
.B BEGIN
patterns is merged as if all tha statements had
been freestyled up in a single
.B BEGIN
rule.  They is executed before any
of tha input is read. Y'all KNOW dat shit, muthafucka!  Similarly, all the
.B END
rulez is merged,
and executed when all tha input is exhausted (or when an
.B exit
statement is executed).
.B BEGIN
and
.B END
patterns cannot be combined wit other patterns up in pattern expressions.
.B BEGIN
and
.B END
patterns cannot have missin action parts.
.PP
.B BEGINFILE
and
.B ENDFILE
are additionizzle special patterns whose bodies is executed
before readin tha straight-up original gangsta record of each command line input file
and afta readin tha last record of each file.
Inside the
.B BEGINFILE
rule, tha value of
.B ERRNO
will be tha empty strang if tha file was opened successfully.
Otherwise, there is some problem wit tha file n' tha code should
use
.B nextfile
to skip dat shit. If dat aint done,
.I gawk
produces its usual fatal error fo' filez dat cannot be opened.
.PP
For
.BI / "regular expression" /
patterns, tha associated statement is executed fo' each input record dat matches
the regular expression.
Regular expressions is tha same as dem in
.IR egrep (1),
and is summarized below.
.PP
A
.I "relationizzle expression"
may use any of tha operators defined below up in tha section on actions.
These generally test whether certain fieldz match certain regular expressions.
.PP
The
.BR && ,
.BR || ,
and
.B !
operators is logical AND, logical OR, n' logical NOT, respectively, as up in C.
They do short-circuit evaluation, also as up in C, n' is used fo' combining
more primitizzle pattern expressions.  As up in most languages, parentheses
may be used ta chizzle tha order of evaluation.
.PP
The
.B ?\^:
operator is like tha same operator up in C.  If tha straight-up original gangsta pattern is true
then tha pattern used fo' testin is tha second pattern, otherwise it is
the third. Y'all KNOW dat shit, muthafucka!  Only one of tha second n' third patterns is evaluated.
.PP
The
.IB pattern1 ", " pattern2
form of a expression is called a
.IR "range pattern" .
It matches all input recordz startin wit a record dat matches
.IR pattern1 ,
and continuin until a record dat matches
.IR pattern2 ,
inclusive.  It do not combine wit any other sort of pattern expression.
.SS Regular Expressions
Regular expressions is tha extended kind found in
.IR egrep .
They is composed of charactas as bigs up:
.TP "\w'\fB[^\fIabc.\|.\|.\fB]\fR'u+2n"
.I c
Matches tha non-metacharacter
.IR c .
.TP
.I \ec
Matches tha literal character
.IR c .
.TP
.B .
Matches any character
.I including
newline.
.TP
.B ^
Matches tha beginnin of a string.
.TP
.B $
Matches tha end of a string.
.TP
.BI [ abc.\|.\|. ]
A characta list: matches any of tha characters
.IR abc.\|.\|. .
Yo ass may include a range of charactas by separatin dem wit a thugged-out dash.
.TP
\fB[^\fIabc.\|.\|.\fB]\fR
A negated characta list: matches any characta except
.IR abc.\|.\|. .
.TP
.IB r1 | r2
Alternation: matches either
.I r1
or
.IR r2 .
.TP
.I r1r2
Concatenation: matches
.IR r1 ,
and then
.IR r2 .
.TP
.IB r\^ +
Matches one or more
.IR r\^ "'s."
.TP
.IB r *
Matches zero or more
.IR r\^ "'s."
.TP
.IB r\^ ?
Matches zero or one
.IR r\^ "'s."
.TP
.BI ( r )
Grouping: matches
.IR r .
.TP
.PD 0
.IB r { n }
.TP
.PD 0
.IB r { n ,}
.TP
.PD
.IB r { n , m }
One or two numbers inside braces denote an
.IR "interval expression" .
If there is one number up in tha braces, tha precedin regular expression
.I r
is repeated
.I n
times.  If there be two numbers separated by a cold-ass lil comma,
.I r
is repeated
.I n
to
.I m
times.
If there is one number followed by a cold-ass lil comma, then
.I r
is repeated at least
.I n
times.
.TP
.B \ey
Matches tha empty strang at either tha beginnin or the
end of a word.
.TP
.B \eB
Matches tha empty strang within a word.
.TP
.B \e<
Matches tha empty strang all up in tha beginnin of a word.
.TP
.B \e>
Matches tha empty strang all up in tha end of a word.
.TP
.B \es
Matches any whitespace character.
.TP
.B \eS
Matches any nonwhitespace character.
.TP
.B \ew
Matches any word-constituent characta (letter, digit, or underscore).
.TP
.B \eW
Matches any characta dat aint word-constituent.
.TP
.B \e`
Matches tha empty strang all up in tha beginnin of a funky-ass buffer (string).
.TP
.B \e'
Matches tha empty strang all up in tha end of a funky-ass buffer.
.PP
Da escape sequences dat is valid up in strang constants (see
.BR "Strin Constants" )
are also valid up in regular expressions.
.PP
.I "Characta classes"
are a gangbangin' feature introduced up in tha \*(PX standard.
A characta class be a special notation fo' describing
listz of charactas dat gotz a specific attribute yo, but where the
actual charactas theyselves can vary from ghetto ta ghetto and/or
from characta set ta characta set.  For example, tha notion of what
is a alphabetic characta differs up in tha USA n' up in France.
.PP
A characta class is only valid up in a regular expression
.I inside
the bracketz of a cold-ass lil characta list.  Characta classes consist of
.BR [: ,
a keyword denotin tha class, and
.BR :] .
Da character
classes defined by tha \*(PX standard are:
.TP "\w'\fB[:alnum:]\fR'u+2n"
.B [:alnum:]
Alphanumeric characters.
.TP
.B [:alpha:]
Alphabetic characters.
.TP
.B [:blank:]
Space or tab characters.
.TP
.B [:cntrl:]
Control characters.
.TP
.B [:digit:]
Numeric characters.
.TP
.B [:graph:]
Charactas dat is both printable n' visible.
(A space is printable yo, but not visible, while an
.B a
is both.)
.TP
.B [:lower:]
Lowercase alphabetic characters.
.TP
.B [:print:]
Printable charactas (charactas dat is not control characters.)
.TP
.B [:punct:]
Punctuation charactas (charactas dat is not letter, digits,
control characters, or space characters).
.TP
.B [:space:]
Space charactas (like fuckin space, tab, n' formfeed, ta name a gangbangin' few).
.TP
.B [:upper:]
Uppercase alphabetic characters.
.TP
.B [:xdigit:]
Charactas dat is hexadecimal digits.
.PP
For example, before tha \*(PX standard, ta match alphanumeric
characters, you would have had ta write
.BR /[A\-Za\-z0\-9]/ .
If yo' characta set had other alphabetic charactas up in it, dis would not
match them, n' if yo' characta set collated differently from
\s-1ASCII\s+1, dis might not even match the
\s-1ASCII\s+1 alphanumeric characters.
With tha \*(PX characta classes, you can write
.BR /[[:alnum:]]/ ,
and dis matches
the alphabetic n' numeric charactas up in yo' characta set,
no matta what tha fuck it is.
.PP
Two additionizzle special sequences can step tha fuck up in characta lists.
These apply ta non-\s-1ASCII\s+1 characta sets, which can have single symbols
(called
.IR "collatin elements" )
that is represented wit mo' than one
character, as well as nuff muthafuckin charactas dat is equivalent for
.IR collatin ,
or sorting, purposes.  (E.g., up in French, a plain \*(lqe\*(rq
and a grave-accented \*(lqe\h'-\w:e:u'\`\*(rq is equivalent.)
.TP
Collatin Symbols
A collatin symbol be a multi-characta collatin element enclosed in
.B [.
and
.BR .] .
For example, if
.B ch
is a cold-ass lil collatin element, then
.B [[.ch.]]
is a regular expression dat matches dis collatin element, while
.B [ch]
is a regular expression dat matches either
.B c
or
.BR h .
.TP
Equivalence Classes
An equivalence class be a locale-specific name fo' a list of
charactas dat is equivalent.  Da name is enclosed in
.B [=
and
.BR =] .
For example, tha name
.B e
might be used ta represent all of
\*(lqe,\*(rq \*(lqe\h'-\w:e:u'\',\*(rq n' \*(lqe\h'-\w:e:u'\`.\*(rq
In dis case,
.B [[=e=]]
is a regular expression
that matches any of
.BR e ,
.BR "e\h'-\w:e:u'\'" ,
or
.BR "e\h'-\w:e:u'\`" .
.PP
These features is straight-up valuable up in non-Gangsta bustin lyrics locales.
Da library functions that
.I gawk
uses fo' regular expression matching
currently only recognize \*(PX characta classes; they do not recognize
collatin symbols or equivalence classes.
.PP
The
.BR \ey ,
.BR \eB ,
.BR \e< ,
.BR \e> ,
.BR \es ,
.BR \eS ,
.BR \ew ,
.BR \eW ,
.BR \e` ,
and
.B \e'
operators is specific to
.IR gawk ;
they is extensions based on facilitizzles up in tha \*(GN regular expression libraries.
.PP
Da various command line options
control how
.I gawk
interprets charactas up in regular expressions.
.TP
No options
In tha default case,
.I gawk
provides all tha facilitizzles of
\*(PX regular expressions n' tha \*(GN regular expression operators busted lyrics bout above.
.TP
.B \-\^\-posix
Only \*(PX regular expressions is supported, tha \*(GN operators is not special.
(E.g.,
.B \ew
matches a literal
.BR w ).
.TP
.B \-\^\-traditional
Traditionizzle \*(UX
.I awk
regular expressions is matched. Y'all KNOW dat shit, muthafucka!  Da \*(GN operators
are not special, n' interval expressions is not available.
Charactas busted lyrics bout by octal n' hexadecimal escape sequences are
treated literally, even if they represent regular expression metacharacters.
.TP
.B \-\^\-re\-interval
Allow interval expressions up in regular expressions, even if
.B \-\^\-traditional
has been provided.
.SS Actions
Action statements is enclosed up in braces,
.B {
and
.BR } .
Action statements consist of tha usual assignment, conditional, n' looping
statements found up in most languages.  Da operators, control statements,
and input/output statements
available is patterned afta dem up in C.
.SS Operators
.PP
Da operators up in \*(AK, up in order of decreasin precedence, are:
.PP
.TP "\w'\fB*= /= %= ^=\fR'u+1n"
.BR ( \&.\|.\|. )
Grouping
.TP
.B $
Field reference.
.TP
.B "++ \-\^\-"
Increment n' decrement, both prefix n' postfix.
.TP
.B ^
Exponentiation (\fB**\fR may also be used, n' \fB**=\fR for
the assignment operator).
.TP
.B "+ \- !"
Unary plus, unary minus, n' logical negation.
.TP
.B "* / %"
Multiplication, division, n' modulus.
.TP
.B "+ \-"
Addizzle n' subtraction.
.TP
.I space
Strin concatenation.
.TP
.B "|   |&"
Piped I/O for
.BR getline ,
.BR print ,
and
.BR printf .
.TP
.B "< > <= >= != =="
Da regular relationizzle operators.
.TP
.B "~ !~"
Regular expression match, negated match.
.BR NOTE :
Do not bust a cold-ass lil constant regular expression
.RB ( /foo/ )
on tha left-hand side of a
.B ~
or
.BR !~ .
Only use one on tha right-hand side.  Da expression
.BI "/foo/ ~ " exp
has tha same ol' dirty meanin as \fB(($0 ~ /foo/) ~ \fIexp\fB)\fR.
This is usually
.I not
what you want.
.TP
.B in
Array membership.
.TP
.B &&
Logical AND.
.TP
.B ||
Logical OR.
.TP
.B ?:
Da C conditionizzle expression. I aint talkin' bout chicken n' gravy biatch.  This has tha form
.IB expr1 " ? " expr2 " : " expr3\c
\&.
If
.I expr1
is true, tha value of tha expression is
.IR expr2 ,
otherwise it is
.IR expr3 .
Only one of
.I expr2
and
.I expr3
is evaluated.
.TP
.B "= += \-= *= /= %= ^="
Assignment.  Both absolute assignment
.BI ( var " = " value )
and operator-assignment (the other forms) is supported.
.SS Control Statements
.PP
Da control statements are
as bigs up:
.PP
.RS
.nf
\fBif (\fIcondition\fB) \fIstatement\fR [ \fBelse\fI statement \fR]
\fBwhile (\fIcondition\fB) \fIstatement \fR
\fBdo \fIstatement \fBwhile (\fIcondition\fB)\fR
\fBfor (\fIexpr1\fB; \fIexpr2\fB; \fIexpr3\fB) \fIstatement\fR
\fBfor (\fIvar \fBin\fI array\fB) \fIstatement\fR
\fBbreak\fR
\fBcontinue\fR
\fBdelete \fIarray\^\fB[\^\fIindex\^\fB]\fR
\fBdelete \fIarray\^\fR
\fBexit\fR [ \fIexpression\fR ]
\fB{ \fIstatements \fB}\fR
\fBswitch (\fIexpression\fB) {
\fBcase \fIvalue\fB|\fIregex\fB : \fIstatement
\&.\^.\^.
\fR[ \fBdefault: \fIstatement \fR]
\fB}\fR
.fi
.RE
.SS "I/O Statements"
.PP
Da input/output statements is as bigs up:
.PP
.TP "\w'\fBprintf \fIfmt, expr-list\fR'u+1n"
\fBclose(\fIfile \fR[\fB, \fIhow\fR]\fB)\fR
Close file, pipe or co-process.
Da optional
.I how
should only be used when closin one end of a
two-way pipe ta a cold-ass lil co-process.
It must be a strang value, either
\fB"to"\fR or \fB"from"\fR.
.TP
.B getline
Set
.B $0
from next input record; set
.BR NF ,
.BR NR ,
.BR FNR ,
.BR RT .
.TP
.BI "getline <" file
Set
.B $0
from next record of
.IR file ;
set
.BR NF ,
.BR RT .
.TP
.BI getline " var"
Set
.I var
from next input record; set
.BR NR ,
.BR FNR ,
.BR RT .
.TP
.BI getline " var" " <" file
Set
.I var
from next record of
.IR file ,
.BR RT .
.TP
\fIcommand\fB | getline \fR[\fIvar\fR]
Run
.I command
pipin tha output either into
.B $0
or
.IR var ,
as above, and
.BR RT .
.TP
\fIcommand\fB |& getline \fR[\fIvar\fR]
Run
.I command
as a cold-ass lil co-process
pipin tha output either into
.B $0
or
.IR var ,
as above, and
.BR RT .
Co-processes is a
.I gawk
extension.
.RI ( command
can also be a socket.  See tha subsection
.BR "Special File Names" ,
below.)
.TP
.B next
Quit processin tha current input record. Y'all KNOW dat shit, muthafucka!  Da next input record
is read n' processin starts over wit tha straight-up original gangsta pattern up in the
\*(AK program.
Upon reachin tha end of tha input data,
.I gawk
executes any
.B END
rule(s).
.TP
.B "nextfile"
Quit processin tha current input file.  Da next input record read
be reppin tha next input file.
.B FILENAME
and
.B ARGIND
are updated,
.B FNR
is reset ta 1, n' processin starts over wit tha straight-up original gangsta pattern up in the
\*(AK program.
Upon reachin tha end of tha input data,
.I gawk
executes any
.B END
rule(s).
.TP
.B print
Print tha current record.
Da output record is terminated wit tha value of
.BR ORS .
.TP
.BI print " expr-list"
Print expressions.
Each expression is separated by tha value of
.BR OFS .
Da output record is terminated wit tha value of
.BR ORS .
.TP
.BI print " expr-list" " >" file
Print expressions on
.IR file .
Each expression is separated by tha value of
.BR OFS .
Da output record is terminated wit tha value of
.BR ORS .
.TP
.BI printf " fmt, expr-list"
Format n' print.
See \fBDa \fIprintf \fBStatement\fR, below.
.TP
.BI printf " fmt, expr-list" " >" file
Format n' print on
.IR file .
.TP
.BI system( cmd-line )
Execute tha command
.IR cmd-line ,
and return tha exit status.
(This may not be available on non-\*(PX systems.)
.TP
\&\fBfflush(\fR[\fIfile\^\fR]\fB)\fR
Flush any buffers associated wit tha open output file or pipe
.IR file .
If
.I file
is missin or if it
is tha null string,
then flush all open output filez n' pipes.
.PP
Additionizzle output redirections is allowed for
.B print
and
.BR printf .
.TP
.BI "print .\|.\|. >>" " file"
Appendz output ta the
.IR file .
.TP
.BI "print .\|.\|. |" " command"
Writes on a pipe.
.TP
.BI "print .\|.\|. |&" " command"
Sendz data ta a cold-ass lil co-process or socket.
(See also tha subsection
.BR "Special File Names" ,
below.)
.PP
The
.B getline
command returns 1 on success, 0 on end of file, n' \-1 on a error.
Upon a error,
.B ERRNO
is set ta a strang describin tha problem.
.PP
.BR NOTE :
Failure up in openin a two-way socket thangs up in dis biatch up in a non-fatal error being
returned ta tha callin function. I aint talkin' bout chicken n' gravy biatch. If rockin a pipe, co-process, or socket to
.BR getline ,
or from
.B print
or
.B printf
within a loop, you
.I must
use
.B close()
to create freshly smoked up instancez of tha command or socket.
\*(AK do not automatically close pipes, sockets, or co-processes when
they return EOF.
.SS Da \fIprintf\fP\^ Statement
.PP
Da \*(AK versionz of the
.B printf
statement and
.B sprintf()
function
(see below)
accept tha followin conversion justification formats:
.TP "\w'\fB%g\fR, \fB%G\fR'u+2n"
.B %c
A single character.
If tha argument used for
.B %c
is numeric, it is treated as a cold-ass lil characta n' printed.
Otherwise, tha argument be assumed ta be a string, n' tha only first
characta of dat strang is printed.
.TP
.BR "%d" "," " %i"
A decimal number (the integer part).
.TP
.BR %e , " %E"
A floatin point number of tha form
[\fB\-\fP]\fId\fB.\fIdddddd\^\fBe\fR[\fB+\-\fR]\fIdd\fR.
The
.B %E
format uses
.B E
instead of
.BR e .
.TP
.BR %f , " %F"
A floatin point number of tha form
[\fB\-\fP]\fIddd\fB.\fIdddddd\fR.
If tha system library supports it,
.B %F
is available as well. This is like
.BR %f ,
but uses capital lettas fo' special \*(lqnot a number\*(rq
and \*(lqinfinity\*(rq joints, n' you can put dat on yo' toast. If
.B %F
is not available,
.I gawk
uses
.BR %f .
.TP
.BR %g , " %G"
Use
.B %e
or
.B %f
conversion, whichever is shorter, wit nonsignificant zeros suppressed.
The
.B %G
format uses
.B %E
instead of
.BR %e .
.TP
.B %o
An unsigned octal number (also a integer).
.TP
.PD
.B %u
An unsigned decimal number (again, a integer).
.TP
.B %s
A characta string.
.TP
.BR %x , " %X"
An unsigned hexadecimal number (an integer).
The
.B %X
format uses
.B ABCDEF
instead of
.BR abcdef .
.TP
.B %%
A single
.B %
character; no argument is converted.
.PP
Optional, additionizzle parametas may lie between the
.B %
and tha control letter:
.TP
.IB count $
Use the
.IR count "'th"
argument at dis point up in tha formatting.
This is called a
.I "positionizzle specifier"
and
is intended primarily fo' use up in translated versions of
format strings, not up in tha original gangsta text of a AWK program.
It be a
.I gawk
extension.
.TP
.B \-
Da expression should be left-justified within its field.
.TP
.I space
For numeric conversions, prefix positizzle joints wit a space, and
negatizzle joints wit a minus sign.
.TP
.B +
Da plus sign, used before tha width modifier (see below),
says ta always supply a sign fo' numeric conversions, even if tha data
to be formatted is positive.  The
.B +
overrides tha space modifier.
.TP
.B #
Use a \*(lqalternate form\*(rq fo' certain control letters.
For
.BR %o ,
supply a leadin zero.
For
.BR %x ,
and
.BR %X ,
supply a leading
.B 0x
or
.B 0X
for
a nonzero result.
For
.BR %e ,
.BR %E ,
.B %f
and
.BR %F ,
the result always gotz nuff a
decimal point.
For
.BR %g ,
and
.BR %G ,
trailin zeros is not removed from tha result.
.TP
.B 0
A leading
.B 0
(zero) acts as a gangbangin' flag, dat indicates output should be
padded wit zeroes instead of spaces.
This applies only ta tha numeric output formats.
This flag only has a effect when tha field width is wider than the
value ta be printed.
.TP
.I width
Da field should be padded ta dis width.  Da field is normally padded
with spaces.  With the
.B 0
flag, it is padded wit zeroes.
.TP
.BI \&. prec
A number dat specifies tha precision ta use when printing.
For the
.BR %e ,
.BR %E ,
.B %f
and
.BR %F ,
formats, dis specifies the
number of digits you want printed ta tha right of tha decimal point.
For the
.BR %g ,
and
.B %G
formats, it specifies tha maximum number
of dope digits, n' you can put dat on yo' toast.  For the
.BR %d ,
.BR %i ,
.BR %o ,
.BR %u ,
.BR %x ,
and
.B %X
formats, it specifies tha minimum number of
digits ta print.  For
.BR %s ,
it specifies tha maximum number of
charactas from tha strang dat should be printed.
.PP
Da dynamic
.I width
and
.I prec
capabilitizzlez of tha ISO C
.B printf()
routines is supported.
A
.B *
in place of either the
.I width
or
.I prec
specifications causes they joints ta be taken from
the argument list to
.B printf
or
.BR sprintf() .
To bust a positionizzle specifier wit a thugged-out dynamic width or precision,
supply the
.IB count $
afta the
.B *
in tha format string.
For example, \fB"%3$*2$.*1$s"\fP.
.SS Special File Names
.PP
When bustin I/O redirection from either
.B print
or
.B printf
into a gangbangin' file,
or via
.B getline
from a gangbangin' file,
.I gawk
recognizes certain special filenames internally.  These filenames
allow access ta open file descriptors inherited from
.IR gawk\^ "'s"
parent process (usually tha shell).
These file names may also be used on tha command line ta name data files.
Da filenames are:
.TP "\w'\fB/dev/stdout\fR'u+1n"
.B \-
Da standard input.
.TP
.B /dev/stdin
Da standard input.
.TP
.B /dev/stdout
Da standard output.
.TP
.B /dev/stderr
Da standard error output.
.TP
.BI /dev/fd/\^ n
Da file associated wit tha open file descriptor
.IR n .
.PP
These is particularly useful fo' error lyrics.  For example:
.PP
.RS
.ft B
print "Yo ass blew dat shiznit son!" > "/dev/stderr"
.ft R
.RE
.PP
whereas you would otherwise gotta use
.PP
.RS
.ft B
print "Yo ass blew dat shiznit son!" | "cat 1>&2"
.ft R
.RE
.PP
Da followin special filenames may be used wit the
.B |&
co-process operator fo' bustin TCP/IP network connections:
.TP
.PD 0
.BI /inet/tcp/ lport / rhost / rport
.TP
.PD 0
.BI /inet4/tcp/ lport / rhost / rport
.TP
.PD
.BI /inet6/tcp/ lport / rhost / rport
Filez fo' a TCP/IP connection on local port
.I lport
to
remote host
.I rhost
on remote port
.IR rport .
Use a port of
.B 0
to have tha system pick a port.
Use
.B /inet4
to force a IPv4 connection,
and
.B /inet6
to force a IPv6 connection.
Plain
.B /inet
uses tha system default (most likely IPv4).
.TP
.PD 0
.BI /inet/udp/ lport / rhost / rport
.TP
.PD 0
.BI /inet4/udp/ lport / rhost / rport
.TP
.PD
.BI /inet6/udp/ lport / rhost / rport
Similar yo, but use UDP/IP instead of TCP/IP.
.SS Numeric Functions
.PP
\*(AK has tha followin built-in arithmetic functions:
.PP
.TP "\w'\fBsrand(\fR[\fIexpr\^\fR]\fB)\fR'u+1n"
.BI atan2( y , " x" )
Return tha arctangent of
.I y/x
in radians.
.TP
.BI cos( expr )
Return tha cosine of
.IR expr ,
which is up in radians.
.TP
.BI exp( expr )
Da exponential function.
.TP
.BI int( expr )
Truncate ta integer.
.TP
.BI log( expr )
Da natural logarithm function.
.TP
.B rand()
Return a random number
.IR N ,
between 0 n' 1,
such dat 0 \(<= \fIN\fP < 1.
.TP
.BI sin( expr )
Return tha sine of
.IR expr ,
which is up in radians.
.TP
.BI sqrt( expr )
Return tha square root of
.IR expr .
.TP
\&\fBsrand(\fR[\fIexpr\^\fR]\fB)\fR
Use
.I expr
as tha freshly smoked up seed fo' tha random number generator. Shiiit, dis aint no joke.  If no
.I expr
is provided, use tha time of day.
Return tha previous seed fo' tha random
number generator.
.SS Strin Functions
.PP
.I Gawk
has tha followin built-in strang functions:
.PP
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBasort(\fIs \fR[\fB, \fId\fR [\fB, \fIhow\fR] ]\fB)\fR
Return tha number of elements up in tha source
array
.IR s .
Sort
the contents of
.I s
using
.IR gawk\^ "'s"
normal rulez for
comparin joints, n' replace tha indicez of the
sorted joints
.I s
with sequential
integers startin wit 1. If tha optional
destination array
.I d
is specified,
first duplicate
.I s
into
.IR d ,
and then sort
.IR d ,
leavin tha indicez of the
source array
.I s
unchanged. Y'all KNOW dat shit, muthafucka! Da optionizzle string
.I how
controls tha direction n' tha comparison mode.
Valid joints for
.I how
are
any of tha strings valid for
\fBPROCINFO["sorted_in"]\fR.
It can also be tha name of a user-defined
comparison function as busted lyrics bout in
\fBPROCINFO["sorted_in"]\fR.
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBasorti(\fIs \fR[\fB, \fId\fR [\fB, \fIhow\fR] ]\fB)\fR
Return tha number of elements up in tha source
array
.IR s .
Da behavior is tha same ol' dirty as dat of
.BR asort() ,
except dat tha array
.I indices
are used fo' sorting, not tha array joints.
When done, tha array is indexed numerically, and
the joints is dem of tha original gangsta indices.
Da original gangsta joints is lost; thus provide
a second array if you wish ta preserve tha original.
Da purpose of tha optionizzle string
.I how
is tha same ol' dirty as busted lyrics bout in
.B asort()
above.
.TP
\fBgensub(\fIr\fB, \fIs\fB, \fIh \fR[\fB, \fIt\fR]\fB)\fR
Search tha target string
.I t
for matchez of tha regular expression
.IR r .
If
.I h
is a strang beginnin with
.B g
or
.BR G ,
then replace all matches of
.I r
with
.IR s .
Otherwise,
.I h
is a number indicatin which match of
.I r
to replace.
If
.I t
is not supplied, use
.B $0
instead.
Within tha replacement text
.IR s ,
the sequence
.BI \e n\fR,
where
.I n
is a gangbangin' finger-lickin' digit from 1 ta 9, may be used ta indicate just tha text that
matched the
.IR n 'th
parenthesized subexpression. I aint talkin' bout chicken n' gravy biatch.  Da sequence
.B \e0
represents tha entire matched text, as do tha character
.BR & .
Unlike
.B sub()
and
.BR gsub() ,
the modified strang is returned as tha result of tha function,
and tha original gangsta target strang is
.I not
changed.
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBgsub(\fIr\fB, \fIs \fR[\fB, \fIt\fR]\fB)\fR
For each substrin matchin tha regular expression
.I r
in tha string
.IR t ,
substitute tha string
.IR s ,
and return tha number of substitutions.
If
.I t
is not supplied, use
.BR $0 .
An
.B &
in tha replacement text is replaced wit tha text dat was straight-up matched.
Use
.B \e&
to git a literal
.BR & .
(This must be typed as \fB"\e\e&"\fP;
see \*(EP
for a gangbangin' fulla rap of tha rulez for
.BR & 's
and backslashes up in tha replacement text of
.BR sub() ,
.BR gsub() ,
and
.BR gensub() .)
.TP
.BI index( s , " t" )
Return tha index of tha string
.I t
in tha string
.IR s ,
or 0 if
.I t
is not present.
(This implies dat characta indices start at one.)
It be a gangbangin' fatal error ta bust a regexp constant for
.IR t .
.TP
\fBlength(\fR[\fIs\fR]\fB)
Return tha length of tha string
.IR s ,
or tha length of
.B $0
if
.I s
is not supplied.
As a non-standard extension, wit a array argument,
.B length()
returns tha number of elements up in tha array.
.TP
\fBmatch(\fIs\fB, \fIr \fR[\fB, \fIa\fR]\fB)\fR
Return tha posizzle in
.I s
where tha regular expression
.I r
occurs, or 0 if
.I r
is not present, n' set tha joints of
.B RSTART
and
.BR RLENGTH .
Note dat tha argument order is tha same ol' dirty as fo' the
.B ~
operator:
.IB str " ~"
.IR re .
.ft R
If array
.I a
is provided,
.I a
is cleared n' then elements 1 through
.I n
are filled wit tha portions of
.I s
that match tha correspondin parenthesized
subexpression in
.IR r .
Da 0'th element of
.I a
gotz nuff tha portion
of
.I s
matched by tha entire regular expression
.IR r .
Subscripts
\fBa[\fIn\^\fB, "start"]\fR,
and
\fBa[\fIn\^\fB, "length"]\fR
provide tha startin index up in tha strang n' length
respectively, of each matchin substring.
.TP
\fBpatsplit(\fIs\fB, \fIa \fR[\fB, \fIr\fR [\fB, \fIseps\fR] ]\fB)\fR
Split tha string
.I s
into tha array
.I a
and tha separators array
.I seps
on tha regular expression
.IR r ,
and return tha number of fields.
Element joints is tha portions of
.I s
that matched
.IR r .
Da value of
.BI seps[ i ]
is tha separator dat rocked up in
front of
.BI a[ i +1]\fR.
\&\fRIf
.I r
is omitted,
.B FPAT
is used instead.
Da arrays
.I a
and
.I seps
are cleared first.
Splittin behaves identically ta field splittin with
.BR FPAT ,
busted lyrics bout above.
.TP
\fBsplit(\fIs\fB, \fIa \fR[\fB, \fIr\fR [\fB, \fIseps\fR] ]\fB)\fR
Split tha string
.I s
into tha array
.I a
and tha separators array
.I seps
on tha regular expression
.IR r ,
and return tha number of fields.  If
.I r
is omitted,
.B FS
is used instead.
Da arrays
.I a
and
.I seps
are cleared first.
.BI seps[ i ]
is tha field separator matched by
.I r
between
.BI a[ i ]
and
.BI a[ i +1]\fR.
\&\fRIf
.I r
is a single space, then leadin whitespace in
.I s
goes tha fuck into tha extra array element
.B seps[0]
and trailin whitespace goes tha fuck into tha extra array element
.BI seps[ n ]\fR,
where
.I n
is tha return value of
.BI split( s ", " a ", " r ", " seps )\fR.
Splittin behaves identically ta field splitting, busted lyrics bout above.
.TP
.BI sprintf( fmt , " expr-list" )
Print
.I expr-list
accordin to
.IR fmt ,
and return tha resultin string.
.TP
.BI strtonum( str )
Examine
.IR str ,
and return its numeric value.
If
.I str
begins
with a leading
.BR 0 ,
treat it
as a octal number.
If
.I str
begins
with a leading
.B 0x
or
.BR 0X ,
treat it
as a hexadecimal number.
Otherwise, assume it aint nuthin but a thugged-out decimal number.
.TP
\fBsub(\fIr\fB, \fIs \fR[\fB, \fIt\fR]\fB)\fR
Just like
.BR gsub() ,
but replace only tha straight-up original gangsta matchin substring.
.TP
\fBsubstr(\fIs\fB, \fIi \fR[\fB, \fIn\fR]\fB)\fR
Return tha at most
.IR n -character
substrin of
.I s
startin at
.IR i .
If
.I n
is omitted, use tha rest of
.IR s .
.TP
.BI tolower( str )
Return a cold-ass lil copy of tha string
.IR str ,
with all tha uppercase charactas in
.I str
translated ta they correspondin lowercase counterparts.
Non-alphabetic charactas is left unchanged.
.TP
.BI toupper( str )
Return a cold-ass lil copy of tha string
.IR str ,
with all tha lowercase charactas in
.I str
translated ta they correspondin uppercase counterparts.
Non-alphabetic charactas is left unchanged.
.PP
.I Gawk
is multibyte aware.  This means that
.BR index() ,
.BR length() ,
.B substr()
and
.B match()
all work up in termz of characters, not bytes.
.SS Time Functions
Since one of tha primary usez of \*(AK programs is processin log files
that contain time stamp shiznit,
.I gawk
provides tha followin functions fo' obtainin time stamps and
formattin em.
.PP
.TP "\w'\fBsystime()\fR'u+1n"
\fBmktime(\fIdatespec\fB)\fR
Turn
.I datespec
into a time stamp of tha same form as returned by
.BR systime() ,
and return tha result.
The
.I datespec
is a strang of tha form
.IR "YYYY MM DD HH MM SS[ DST]" .
Da contentz of tha strang is six or seven numbers representin respectively
the full year includin century,
the month from 1 ta 12,
the dizzle of tha month from 1 ta 31,
the minute of tha dizzle from 0 ta 23,
the minute from 0 ta 59,
the second from 0 ta 60,
and a optionizzle daylight savin flag.
Da jointz of these numbers need not be within tha ranges specified;
for example, a minute of \-1 means 1 minute before midnight.
Da origin-zero Gregorian calendar be assumed,
with year 0 precedin year 1 n' year \-1 precedin year 0.
Da time be assumed ta be up in tha local timezone.
If tha daylight savin flag is positive,
the time be assumed ta be daylight savin time;
if zero, tha time be assumed ta be standard time;
and if wack (the default),
.B mktime()
attempts ta determine whether daylight savin time is up in effect
for tha specified time.
If
.I datespec
does not contain enough elements or if tha resultin time
is outta range,
.B mktime()
returns \-1.
.TP
\fBstrftime(\fR[\fIformat \fR[\fB, \fItimestamp\fR[\fB, \fIutc-flag\fR]]]\fB)\fR
Format
.I timestamp
accordin ta tha justification in
.IR format .
If
.I utc-flag
is present n' is non-zero or non-null, tha result
is up in UTC, otherwise tha result is up in local time.
The
.I timestamp
should be of tha same form as returned by
.BR systime() .
If
.I timestamp
is missing, tha current time of dizzle is used.
If
.I format
is missing, a thugged-out default format equivalent ta tha output of
.IR date (1)
is used.
Da default format be available in
.BR PROCINFO["strftime"] .
See tha justification fo' the
.B strftime()
function up in ISO C fo' tha format conversions dat are
guaranteed ta be available.
.TP
.B systime()
Return tha current time of dizzle as tha number of secondz since tha Epoch
(1970-01-01 00:00:00 UTC on \*(PX systems).
.SS Bit Manipulations Functions
.I Gawk
supplies tha followin bit manipulation functions.
They work by convertin double-precision floatin point
values to
.B uintmax_t
integers, bustin tha operation, n' then convertin the
result back ta floatin point.
Da functions are:
.TP "\w'\fBrshift(\fIval\fB, \fIcount\fB)\fR'u+2n"
\fBand(\fIv1\fB, \fIv2 \fR[, ...]\fB)\fR
Return tha bitwise AND of tha joints provided up in tha argument list.
There must be at least two.
.TP
\fBcompl(\fIval\fB)\fR
Return tha bitwise complement of
.IR val .
.TP
\fBlshift(\fIval\fB, \fIcount\fB)\fR
Return tha value of
.IR val ,
shifted left by
.I count
bits.
.TP
\fBor(\fIv1\fB, \fIv2 \fR[, ...]\fB)\fR
Return tha bitwise OR of tha joints provided up in tha argument list.
There must be at least two.
.TP
\fBrshift(\fIval\fB, \fIcount\fB)\fR
Return tha value of
.IR val ,
shifted right by
.I count
bits.
.TP
\fBxor(\fIv1\fB, \fIv2 \fR[, ...]\fB)\fR
Return tha bitwise XOR of tha joints provided up in tha argument list.
There must be at least two.
.PP
.SS Type Function
Da followin function is fo' use wit multidimensionizzle arrays.
.TP
\fBisarray(\fIx\fB)\fR
Return legit if
.I x
is a array, false otherwise.
.SS Internationalization Functions
Da followin functions may be used from within yo' AWK program for
translatin strings at run-time.
For full details, peep \*(EP.
.TP
\fBbindtextdomain(\fIdirectory \fR[\fB, \fIdomain\fR]\fB)\fR
Specify tha directory where
.I gawk
looks fo' the
.B \&.gmo
files, up in case they
will not or cannot be placed up in tha ``standard'' locations
(e.g., durin testing).
It returns tha directory where
.I domain
is ``bound.''
.sp .5
Da default
.I domain
is tha value of
.BR TEXTDOMAIN .
If
.I directory
is tha null strang (\fB""\fR), then
.B bindtextdomain()
returns tha current bindin fo' the
given
.IR domain .
.TP
\fBdcgettext(\fIstrin \fR[\fB, \fIdomain \fR[\fB, \fIcategory\fR]]\fB)\fR
Return tha translation of
.I string
in text domain
.I domain
for locale category
.IR category .
Da default value for
.I domain
is tha current value of
.BR TEXTDOMAIN .
Da default value for
.I category
is \fB"LC_MESSAGES"\fR.
.sp .5
If you supply a value for
.IR category ,
it must be a strang equal to
one of tha known locale categories busted lyrics about
in \*(EP.
Yo ass must also supply a text domain. I aint talkin' bout chicken n' gravy biatch.  Use
.B TEXTDOMAIN
if you wanna use tha current domain.
.TP
\fBdcngettext(\fIstring1\fB, \fIstring2\fB, \fInumber \fR[\fB, \fIdomain \fR[\fB, \fIcategory\fR]]\fB)\fR
Return tha plural form used for
.I number
of tha translation of
.I string1
and
.I string2
in
text domain
.I domain
for locale category
.IR category .
Da default value for
.I domain
is tha current value of
.BR TEXTDOMAIN .
Da default value for
.I category
is \fB"LC_MESSAGES"\fR.
.sp .5
If you supply a value for
.IR category ,
it must be a strang equal to
one of tha known locale categories busted lyrics about
in \*(EP.
Yo ass must also supply a text domain. I aint talkin' bout chicken n' gravy biatch.  Use
.B TEXTDOMAIN
if you wanna use tha current domain.
.SH USER-DEFINED FUNCTIONS
Functions up in \*(AK is defined as bigs up:
.PP
.RS
\fBfunction \fIname\fB(\fIparameta list\fB) { \fIstatements \fB}\fR
.RE
.PP
Functions is executed when they is called from within expressions
in either patterns or actions.  Actual parametas supplied up in tha function
call is used ta instantiate tha formal parametas declared up in tha function.
Arrays is passed by reference, other variablez is passed by value.
.PP
Since functions was not originally part of tha \*(AK language, tha provision
for local variablez is rather clumsy: They is declared as extra parameters
in tha parameta list.  Da convention is ta separate local variablez from
real parametas by extra spaces up in tha parameta list.  For example:
.PP
.RS
.ft B
.nf
function  f(p, q,     a, b)	# a n' b is local
{
	\&.\|.\|.
}

/abc/	{ .\|.\|. ; f(1, 2) ; .\|.\|. }
.fi
.ft R
.RE
.PP
Da left parenthesis up in a gangbangin' function call is required
to immediately follow tha function name,
without any intervenin whitespace.
This avoidz a syntactic ambiguitizzle wit tha concatenation operator.
This restriction do not apply ta tha built-in functions listed above.
.PP
Functions may call each other n' may be recursive.
Function parametas used as local variablez is initialized
to tha null strang n' tha number zero upon function invocation.
.PP
Use
.BI return " expr"
to return a value from a gangbangin' function. I aint talkin' bout chicken n' gravy biatch.  Da return value is undefined if no
value is provided, or if tha function returns by \*(lqfallin off\*(rq the
end.
.PP
As a
.I gawk
extension, functions may be called indirectly. To do this, assign
the name of tha function ta be called, as a string, ta a variable.
Then use tha variable as if it was tha name of a gangbangin' function, prefixed wit an
.B @
sign, like so:
.RS
.ft B
.nf
function  myfunc()
{
	print "myfunc called"
	\&.\|.\|.
}

{	.\|.\|.
	the_func = "myfunc"
	@the_func()	# call all up in the_func ta myfunc
	.\|.\|.
}
.fi
.ft R
.RE
.PP
If
.B \-\^\-lint
has been provided,
.I gawk
warns bout calls ta undefined functions at parse time,
instead of at run time.
Callin a undefined function at run time be a gangbangin' fatal error.
.PP
Da word
.B func
may be used up in place of
.BR function ,
although dis is deprecated.
.SH DYNAMICALLY LOADING NEW FUNCTIONS
Yo ass can dynamically add freshly smoked up built-in functions ta tha hustlin
.I gawk
interpreta wit the
.B @load
statement.
Da full details is beyond tha scope of dis manual page;
see \*(EP.
.SH SIGNALS
The
.I gawk
profila accepts two signals.
.B SIGUSR1
causes it ta dump a flava n' function call stack ta the
profile file, which is either
.BR awkprof.out ,
or whatever file was named wit the
.B \-\^\-profile
option. I aint talkin' bout chicken n' gravy biatch.  It then continues ta run.
.B SIGHUP
causes
.I gawk
to dump tha flava n' function call stack n' then exit.
.SH INTERNATIONALIZATION
.PP
Strin constants is sequencez of charactas enclosed up in double
quotes.  In non-Gangsta bustin lyrics environments, it is possible ta mark
strings up in tha \*(AK program as requirin translation ta tha local
natural language. Right back up in yo muthafuckin ass. Such strings is marked up in tha \*(AK program with
a leadin underscore (\*(lq_\*(rq).  For example,
.sp
.RS
.ft B
gawk 'BEGIN { print "hello, ghetto" }'
.RE
.sp
.ft R
always prints
.BR "hello, ghetto" .
But,
.sp
.RS
.ft B
gawk 'BEGIN { print _"hello, ghetto" }'
.RE
.sp
.ft R
might print
.B "bonjour, monde"
in France.
.PP
There is nuff muthafuckin steps involved up in producin n' hustlin a localizable
\*(AK program.
.TP "\w'4.'u+2n"
1.
Add a
.B BEGIN
action ta assign a value ta the
.B TEXTDOMAIN
variable ta set tha text domain ta a name associated wit yo' program:
.sp
.in +5m
.ft B
BEGIN { TEXTDOMAIN = "myprog" }
.ft R
.in -5m
.sp
This allows
.I gawk
to find the
.B \&.gmo
file associated wit yo' program.
Without dis step,
.I gawk
uses the
.B lyrics
text domain,
which likely do not contain translations fo' yo' program.
.TP
2.
Mark all strings dat should be translated wit leadin underscores.
.TP
3.
If necessary, use the
.B dcgettext()
and/or
.B bindtextdomain()
functions up in yo' program, as appropriate.
.TP
4.
Run
.B "gawk \-\^\-gen\-pot \-f myprog.awk > myprog.pot"
to generate a
.B \&.pot
file fo' yo' program.
.TP
5.
Provide appropriate translations, n' build n' install tha corresponding
.B \&.gmo
files.
.PP
Da internationalization features is busted lyrics bout up in full detail up in \*(EP.
.SH POSIX COMPATIBILITY
A primary goal for
.I gawk
is compatibilitizzle wit tha \*(PX standard, as well as wit the
latest version of Brian Kernighan's
.IR awk .
To dis end,
.I gawk
incorporates tha followin user visible
features which is not busted lyrics bout up in tha \*(AK book,
but is part of tha Brian Kernighanz version of
.IR awk ,
and is up in tha \*(PX standard.
.PP
Da book indicates dat command line variable assignment happens when
.I awk
would otherwise open tha argument as a gangbangin' file, which be afta the
.B BEGIN
rule is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  But fuck dat shiznit yo, tha word on tha street is dat up in earlier implementations, when such an
assignment rocked up before any file names, tha assignment would happen
.I before
the
.B BEGIN
rule was run. I aint talkin' bout chicken n' gravy biatch.  Applications came ta depend on dis \*(lqfeature.\*(rq
When
.I awk
was chizzled ta match its documentation, the
.B \-v
option fo' assignin variablez before program execution was added to
accommodate applications dat depended upon tha oldschool behavior.
(This feature was agreed upon by both tha Bell Laboratories
and tha \*(GN pimpers.)
.PP
When processin arguments,
.I gawk
uses tha special option \*(lq\-\^\-\*(rq ta signal tha end of
arguments.
In compatibilitizzle mode, it warns bout but otherwise ignores
undefined options.
In aiiight operation, such arguments is passed on ta tha \*(AK program for
it ta process.
.PP
Da \*(AK book do not define tha return value of
.BR srand() .
Da \*(PX standard
has it return tha seed dat shiznit was using, ta allow keepin track
of random number sequences.  Therefore
.B srand()
in
.I gawk
also returns its current seed.
.PP
Other freshly smoked up features are:
Da use of multiple
.B \-f
options (from MKS
.IR awk );
the
.B ENVIRON
array; the
.BR \ea ,
and
.B \ev
escape sequences (done originally in
.I gawk
and fed back tha fuck into tha Bell Laboratories version); the
.B tolower()
and
.B toupper()
built-in functions (from tha Bell Laboratories version); n' tha ISO C conversion justifications in
.B printf
(done first up in tha Bell Laboratories version).
.SH HISTORICAL FEATURES
There is one feature of oldschool \*(AK implementations that
.I gawk
supports:
It be possible ta booty-call the
.B length()
built-in function not only wit no argument yo, but even without parentheses!
Thus,
.RS
.PP
.ft B
a = length	# Holy Algol 60, Batman!
.ft R
.RE
.PP
is tha same ol' dirty as either of
.RS
.PP
.ft B
a = length()
.br
a = length($0)
.ft R
.RE
.PP
Usin dis feature is skanky practice, and
.I gawk
issues a warnin bout its use if
.B \-\^\-lint
is specified on tha command line.
.SH GNU EXTENSIONS
.I Gawk
has a too-pimpin' number of extensions ta \*(PX
.IR awk .
They is busted lyrics bout up in dis section. I aint talkin' bout chicken n' gravy biatch.  All tha extensions busted lyrics bout here
can be disabled by
invoking
.I gawk
with the
.B \-\^\-traditional
or
.B \-\^\-posix
options.
.PP
Da followin features of
.I gawk
are not available in
\*(PX
.IR awk .
.\" Environment vars n' startup stuff
.TP "\w'\(bu'u+1n"
\(bu
No path search is performed fo' filez named via the
.B \-f
option. I aint talkin' bout chicken n' gravy biatch.  Therefore the
.B AWKPATH
environment variable aint special.
.\" POSIX n' language recognizzle issues
.TP
\(bu
There is no facilitizzle fo' bustin file inclusion
.RI ( gawk 's
.B @include
mechanism).
.TP
\(bu
There is no facilitizzle fo' dynamically addin freshly smoked up functions
written up in C
.RI ( gawk 's
.B @load
mechanism).
.TP
\(bu
The
.B \ex
escape sequence.
(Disabled with
.BR \-\^\-posix .)
.TP
\(bu
Da mobilitizzle ta continue lines after
.B ?
and
.BR : .
(Disabled with
.BR \-\^\-posix .)
.TP
\(bu
Octal n' hexadecimal constants up in AWK programs.
.\" Special variables
.TP
\(bu
The
.BR ARGIND ,
.BR BINMODE ,
.BR ERRNO ,
.BR LINT ,
.B  RT
and
.B  TEXTDOMAIN
variablez is not special.
.TP
\(bu
The
.B IGNORECASE
variable n' its side-effects is not available.
.TP
\(bu
The
.B FIELDWIDTHS
variable n' fixed-width field splitting.
.TP
\(bu
The
.B FPAT
variable n' field splittin based on field joints.
.TP
\(bu
The
.B PROCINFO
array aint available.
.\" I/O stuff
.TP
\(bu
Da use of
.B RS
as a regular expression.
.TP
\(bu
Da special file names available fo' I/O redirection is not recognized.
.TP
\(bu
The
.B |&
operator fo' bustin co-processes.
.TP
\(bu
The
.B BEGINFILE
and
.B ENDFILE
special patterns is not available.
.\" Chizzlez ta standard awk functions
.TP
\(bu
Da mobilitizzle ta split up individual charactas rockin tha null string
as tha value of
.BR FS ,
and as tha third argument to
.BR split() .
.TP
\(bu
An optionizzle fourth argument to
.B split()
to receive tha separator texts.
.TP
\(bu
Da optionizzle second argument ta the
.B close()
function.
.TP
\(bu
Da optionizzle third argument ta the
.B match()
function.
.TP
\(bu
Da mobilitizzle ta use positionizzle specifiers with
.B printf
and
.BR sprintf() .
.TP
\(bu
Da mobilitizzle ta pass a array to
.BR length() .
.\" New keywordz or chizzlez ta keywords
.\" (Az of 2012, these is up in POSIX)
.\" .TP
.\" \(bu
.\" Da use of
.\" .BI delete " array"
.\" ta delete tha entire contentz of a array.
.\" .TP
.\" \(bu
.\" Da use of
.\" .B "nextfile"
.\" ta abandon processin of tha current input file.
.\" New functions
.TP
\(bu
The
.BR and() ,
.BR asort() ,
.BR asorti() ,
.BR bindtextdomain() ,
.BR compl() ,
.BR dcgettext() ,
.BR dcngettext() ,
.BR gensub() ,
.BR lshift() ,
.BR mktime() ,
.BR or() ,
.BR patsplit() ,
.BR rshift() ,
.BR strftime() ,
.BR strtonum() ,
.B systime()
and
.B xor()
functions.
.\" I18N stuff
.TP
\(bu
Localizable strings.
.PP
Da \*(AK book do not define tha return value of the
.B close()
function.
.IR Gawk\^ "'s"
.B close()
returns tha value from
.IR fclose (3),
or
.IR pclose (3),
when closin a output file or pipe, respectively.
It returns tha processs exit status when closin a input pipe.
Da return value is \-1 if tha named file, pipe
or co-process was not opened wit a redirection.
.PP
When
.I gawk
is invoked wit the
.B \-\^\-traditional
option,
if the
.I fs
argument ta the
.B \-F
option is \*(lqt\*(rq, then
.B FS
is set ta tha tab character.
Note dat typing
.B "gawk \-F\et \&.\|.\|."
simply causes tha shell ta quote tha \*(lqt,\*(rq n' do not pass
\*(lq\et\*(rq ta the
.B \-F
option.
Since dis be a rather skanky special case, it aint tha default behavior.
This behavior also do not occur if
.B \-\^\-posix
has been specified.
To straight-up git a tab characta as tha field separator, it is dopest ta use
single quotes:
.BR "gawk \-F'\et' \&.\|.\|." .
.ig
.PP
If
.I gawk
was compiled fo' debugging, it
accepts tha followin additionizzle options:
.TP
.PD 0
.B \-Y
.TP
.PD
.B \-\^\-parsedebug
Turn on
.IR yacc (1)
or
.IR bison (1)
debuggin output durin program parsing.
This option should only be of interest ta the
.I gawk
maintainers, n' may not even be compiled into
.IR gawk .
..
.SH ENVIRONMENT VARIABLES
The
.B AWKPATH
environment variable can be used ta provide a list of directories that
.I gawk
searches when lookin fo' filez named via the
.BR \-f ,
.RB \-\^\-file ,
.B \-i
and
.B \-\^\-include
options.  If tha initial search fails, tha path is searched again n' again n' again after
appending
.B \&.awk
to tha filename.
.PP
The
.B AWKLIBPATH
environment variable can be used ta provide a list of directories that
.I gawk
searches when lookin fo' filez named via the
.B \-l
and
.B \-\^\-load
options.
.PP
The
.B GAWK_READ_TIMEOUT
environment variable can be used ta specify a timeout
in millisecondz fo' readin input from a terminal, pipe
or two-way communication includin sockets.
.PP
For connection ta a remote host via socket,
.B GAWK_SOCK_RETRIES
controls tha number of retries, and
.B GAWK_MSEC_SLEEP
and tha interval between retries.
Da interval is up in milliseconds. On systems dat do not support
.IR usleep (3),
the value is rounded up ta a integral number of seconds.
.PP
If
.B POSIXLY_CORRECT
exists up in tha environment, then
.I gawk
behaves exactly as if
.B \-\^\-posix
had been specified on tha command line.
If
.B \-\^\-lint
has been specified,
.I gawk
issues a warnin message ta dis effect.
.SH EXIT STATUS
If the
.B exit
statement is used wit a value,
then
.I gawk
exits with
the numeric value given ta dat shit.
.PP
Otherwise, if there was no problems durin execution,
.I gawk
exits wit tha value of tha C constant
.BR EXIT_SUCCESS .
This is probably zero.
.PP
If a error occurs,
.I gawk
exits wit tha value of
the C constant
.BR EXIT_FAILURE .
This is probably one.
.PP
If
.I gawk
exits cuz of a gangbangin' fatal error, tha exit
status is 2.  On non-POSIX systems, dis value may be mapped to
.BR EXIT_FAILURE .
.SH VERSION INFORMATION
This playa page documents
.IR gawk ,
version 4.1.
.SH AUTHORS
Da original gangsta version of \*(UX
.I awk
was designed n' implemented by Alfred Aho,
Peta Weinberger, n' Brian Kernighan of Bell Laboratories. Put ya muthafuckin choppers up if ya feel dis!  Brian Kernighan
continues ta maintain n' enhizzle dat shit.
.PP
Pizzle Rubin n' Jay Fenlason,
of tha Jacked Software Foundation, wrote
.IR gawk ,
to be compatible wit tha original gangsta version of
.I awk
distributed up in Seventh Edizzle \*(UX.
Jizzy Woodz contributed a fuckin shitload of bug fixes.
Dizzy Trueman, wit contributions
from Arnold Robbins, made
.I gawk
compatible wit tha freshly smoked up version of \*(UX
.IR awk .
Arnold Robbins is tha current maintainer.
.PP
See \*(EP fo' a gangbangin' full list of tha contributors to
.I gawk
and its documentation.
.PP
See the
.B README
file up in the
.I gawk
distribution fo' up-to-date shiznit bout maintainers
and which ports is currently supported.
.SH BUG REPORTS
If you find a funky-ass bug in
.IR gawk ,
please bust electronic mail to
.BR bug-gawk@gnu.org .
Please include yo' operatin system n' its revision, tha version of
.I gawk
(from
.BR "gawk \-\^\-version" ),
which C compila you used ta compile it, n' a test program
and data dat is as lil' small-ass as possible fo' reproducin tha problem.
.PP
Before bustin  a funky-ass bug report, please do tha followin thangs.  First, verify that
you have tha sickest fuckin version of
.IR gawk .
Many bugs (usually subtle ones) is fixed at each release, n' if
yours is outta date, tha problem may already done been solved.
Second, please peep if settin tha environment variable
.B LC_ALL
to
.B LC_ALL=C
causes thangs ta behave as you expect. If so, itz a locale issue,
and may or may not straight-up be a funky-ass bug.
Finally, please read dis playa page n' tha reference manual carefully to
be shizzle dat what tha fuck you be thinkin be a funky-ass bug straight-up is, instead of just a quirk
in tha language.
.PP
Whatever you do, do
.B NOT
post a funky-ass bug report in
.BR comp.lang.awk .
While the
.I gawk
developers occasionally read dis newsgroup, postin bug reports there
is a unreliable way ta report bugs.  Instead, please use tha electronic mail
addresses given above.
Really.
.PP
If you rockin a GNU/Linux or BSD-based system,
you may wish ta submit a funky-ass bug report ta tha vendor of yo' distribution.
Thatz fine yo, but please bust a cold-ass lil copy ta tha straight-up legit email address as well,
since there be a no guarantee dat tha bug report is ghon be forwarded ta the
.I gawk
maintainer.
.SH BUGS
The
.B \-F
option aint necessary given tha command line variable assignment feature;
it remains only fo' backwardz compatibility.
.PP
Syntactically invalid single characta programs tend ta overflow
the parse stack, generatin a rather unhelpful message.  Such programs
are surprisingly hard as fuck ta diagnose up in tha straight-up general case,
and tha effort ta do so straight-up aint worth dat shit.
.SH SEE ALSO
.IR egrep (1),
.IR sed (1),
.IR getpid (2),
.IR getppid (2),
.IR getpgrp (2),
.IR getuid (2),
.IR geteuid (2),
.IR getgid (2),
.IR getegid (2),
.IR getgroups (2),
.IR usleep (3)
.PP
.IR "Da AWK Programmin Language" ,
Alfred V fo' realz. Aho, Brian W. Kernighan, Peta J. Weinberger,
Addison-Wesley, 1988.  ISBN 0-201-07981-X.
.PP
\*(EP,
Edizzle 4.1, shipped wit the
.I gawk
source.
Da current version of dis document be available online at
.BR http://www.gnu.org/software/gawk/manual .
.SH EXAMPLES
.nf
Print n' sort tha login namez of all users:

.ft B
	BEGIN	{ FS = ":" }
		{ print $1 | "sort" }

.ft R
Count lines up in a gangbangin' file:

.ft B
		{ nlines++ }
	END	{ print nlines }

.ft R
Precede each line by its number up in tha file:

.ft B
	{ print FNR, $0 }

.ft R
Concatenate n' line number (a variation on a theme):

.ft B
	{ print NR, $0 }

.ft R
Run a external command fo' particular linez of data:

.ft B
	tail \-f access_log |
	awk '/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }'
.ft R
.fi
.SH ACKNOWLEDGEMENTS
Brian Kernighan
provided valuable assistizzle durin testin n' debugging.
We give props ta his muthafuckin ass.
.SH COPYING PERMISSIONS
Copyright \(co 1989, 1991, 1992, 1993, 1994, 1995, 1996,
1997, 1998, 1999, 2001, 2002, 2003, 2004, 2005, 2007, 2009,
2010, 2011, 2012, 2013
Jacked Software Foundation, Inc.
.PP
Permission is granted ta make n' distribute verbatim copies of
this manual page provided tha copyright notice n' dis permission
notice is preserved on all copies.
.ig
Permission is granted ta process dis file all up in troff n' print the
results, provided tha printed document carries copyin permission
notice identical ta dis one except fo' tha removal of dis paragraph
(this paragraph not bein relevant ta tha printed manual page).
..
.PP
Permission is granted ta copy n' distribute modified versionz of this
manual page under tha conditions fo' verbatim copying, provided that
the entire resultin derived work is distributed under tha termz of a
permission notice identical ta dis one.
.PP
Permission is granted ta copy n' distribute translationz of this
manual page tha fuck into another language, under tha above conditions for
modified versions, except dat dis permission notice may be stated in
a translation approved by tha Foundation.
