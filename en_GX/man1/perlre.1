.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLRE 1"
.TH PERLRE 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlre \- Perl regular expressions
.IX Xref "regular expression regex regexp"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page raps bout tha syntax of regular expressions up in Perl.
.PP
If you aint used regular expressions before, a quick-start
introduction be available up in perlrequick, n' a longer tutorial
introduction be available up in perlretut.
.PP
For reference on how tha fuck regular expressions is used up in matching
operations, plus various examplez of tha same, peep raps of
\&\f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR, \f(CW\*(C`qr//\*(C'\fR n' \f(CW\*(C`??\*(C'\fR up in \*(L"Regexp Quote-Like
Operators\*(R" up in perlop.
.SS "Modifiers"
.IX Subsection "Modifiers"
Matchin operations can have various modifiers.  Modifiers
that relate ta tha interpretation of tha regular expression inside
are listed below.  Modifiers dat alta tha way a regular expression
is used by Perl is detailed up in \*(L"Regexp Quote-Like Operators\*(R" up in perlop and
\&\*(L"Gory detailz of parsin quoted constructs\*(R" up in perlop.
.IP "m" 4
.IX Xref " m regex, multiline regexp, multiline regular expression, multiline"
.IX Item "m"
Treat strang as multiple lines.  That is, chizzle \*(L"^\*(R" n' \*(L"$\*(R" from matching
the start or end of line only all up in tha left n' right endz of tha strang to
matchin dem anywhere within tha string.
.IP "s" 4
.IX Xref " s regex, single-line regexp, single-line regular expression, single-line"
.IX Item "s"
Treat strang as single line.  That is, chizzle \*(L".\*(R" ta match any character
whatsoever, even a newline, which normally it would not match.
.Sp
Used together, as \f(CW\*(C`/ms\*(C'\fR, they let tha \*(L".\*(R" match any characta whatsoever,
while still allowin \*(L"^\*(R" n' \*(L"$\*(R" ta match, respectively, just after
and just before newlines within tha string.
.IP "i" 4
.IX Xref " i regex, case-insensitizzle regexp, case-insensitizzle regular expression, case-insensitive"
.IX Item "i"
Do case-insensitizzle pattern matching.
.Sp
If locale matchin rulez is up in effect, tha case map is taken from the
current
locale fo' code points less than 255, n' from Unicode rulez fo' larger
code points, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat matches dat would cross tha Unicode
rules/non\-Unicode rulez boundary (ordz 255/256) aint gonna succeed. Y'all KNOW dat shit, muthafucka!  See
perllocale.
.Sp
There is a fuckin shitload of Unicode charactas dat match multiple characters
under \f(CW\*(C`/i\*(C'\fR.  For example, \f(CW\*(C`LATIN SMALL LIGATURE FI\*(C'\fR
should match tha sequence \f(CW\*(C`fi\*(C'\fR.  Perl is not
currently able ta do dis when tha multiple charactas is up in tha pattern and
are split between groupings, or when one or mo' is quantified. Y'all KNOW dat shit, muthafucka!  Thus
.Sp
.Vb 3
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # Matches
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Don\*(Aqt match!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Don\*(Aqt match!
\&
\& # Da below don\*(Aqt match, n' it isn\*(Aqt clear what tha fuck $1 n' $2 would
\& # be even if it did!!
\& "\eN{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Don\*(Aqt match!
.Ve
.Sp
Perl don't match multiple charactas up in a funky-ass bracketed
characta class unless tha characta dat maps ta dem is explicitly
mentioned, n' it don't match dem at all if tha characta class is
inverted, which otherwise could be highly confusing.  See
\&\*(L"Bracketed Characta Classes\*(R" up in perlrecharclass, and
\&\*(L"Negation\*(R" up in perlrecharclass.
.IP "x" 4
.IX Xref " x"
.IX Item "x"
Extend yo' patternz legibilitizzle by permittin whitespace n' comments.
Details up in \*(L"/x\*(R"
.IP "p" 4
.IX Xref " p regex, preserve regexp, preserve"
.IX Item "p"
Preserve tha strang matched such dat ${^PREMATCH}, ${^MATCH}, and
${^POSTMATCH} is available fo' use afta matching.
.IP "g n' c" 4
.IX Xref " g c"
.IX Item "g n' c"
Global matching, n' keep tha Current posizzle afta failed matching.
Unlike i, m, s n' x, these two flags affect tha way tha regex is used
rather than tha regex itself. Right back up in yo muthafuckin ass. See
\&\*(L"Usin regular expressions up in Perl\*(R" up in perlretut fo' further explanation
of tha g n' c modifiers.
.IP "a, d, l n' u" 4
.IX Xref " a thugged-out d l u"
.IX Item "a, d, l n' u"
These modifiers, all freshly smoked up in 5.14, affect which character-set semantics
(Unicode, etc.) is used, as busted lyrics bout below in
\&\*(L"Characta set modifiers\*(R".
.PP
Regular expression modifiers is probably freestyled up in documentation
as e.g., "the \f(CW\*(C`/x\*(C'\fR modifier", even though tha delimiter
in question might not straight-up be a slash.  Da modifiers \f(CW\*(C`/imsxadlup\*(C'\fR
may also be embedded within tha regular expression itself using
the \f(CW\*(C`(?...)\*(C'\fR construct, peep \*(L"Extended Patterns\*(R" below.
.PP
\fI/x\fR
.IX Subsection "/x"
.PP
\&\f(CW\*(C`/x\*(C'\fR tells
the regular expression parser ta ignore most whitespace dat is neither
backslashed nor within a cold-ass lil characta class.  Yo ass can use dis ta break up
your regular expression tha fuck into (slightly) mo' readable parts, n' you can put dat on yo' toast.  Da \f(CW\*(C`#\*(C'\fR
characta be also treated as a metacharacta introducin a cold-ass lil comment,
just as up in ordinary Perl code.  This also means dat if you want real
whitespace or \f(CW\*(C`#\*(C'\fR charactas up in tha pattern (outside a cold-ass lil character
class, where they is unaffected by \f(CW\*(C`/x\*(C'\fR), then you gonna either have to
escape dem (usin backslashes or \f(CW\*(C`\eQ...\eE\*(C'\fR) or encode dem rockin octal,
hex, or \f(CW\*(C`\eN{}\*(C'\fR escapes.  Taken together, these features go a long-ass way towards
makin Perlz regular expressions mo' readable.  Note dat you have to
be careful not ta include tha pattern delimita up in tha comment\*(--perl has
no way of knowin you did not intend ta close tha pattern early.  See
the C\-comment deletion code up in perlop.  Also note dat anythang inside
a \f(CW\*(C`\eQ...\eE\*(C'\fR stays unaffected by \f(CW\*(C`/x\*(C'\fR.  And note dat \f(CW\*(C`/x\*(C'\fR don't affect
space interpretation within a single multi-characta construct.  For
example up in \f(CW\*(C`\ex{...}\*(C'\fR, regardless of tha \f(CW\*(C`/x\*(C'\fR modifier, there can be no
spaces.  Same fo' a quantifier like fuckin \f(CW\*(C`{3}\*(C'\fR or
\&\f(CW\*(C`{5,}\*(C'\fR.  Similarly, \f(CW\*(C`(?:...)\*(C'\fR can't gotz a space between tha \f(CW\*(C`(\*(C'\fR,
\&\f(CW\*(C`?\*(C'\fR, n' \f(CW\*(C`:\*(C'\fR.  Within any delimitas fo' such a
construct, allowed spaces is not affected by \f(CW\*(C`/x\*(C'\fR, n' depend on the
construct.  For example, \f(CW\*(C`\ex{...}\*(C'\fR can't have spaces cuz hexadecimal
numbers aint gots spaces up in em.  But, Unicode propertizzles can have spaces, so
in \f(CW\*(C`\ep{...}\*(C'\fR there can be spaces dat follow tha Unicode rules, fo' which see
\&\*(L"Propertizzles accessible all up in \ep{} n' \eP{}\*(R" up in perluniprops.
.IX Xref " x"
.PP
\fICharacta set modifiers\fR
.IX Subsection "Characta set modifiers"
.PP
\&\f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, \f(CW\*(C`/a\*(C'\fR, n' \f(CW\*(C`/l\*(C'\fR, available startin up in 5.14, is called
the characta set modifiers; they affect tha characta set semantics
used fo' tha regular expression.
.PP
Da \f(CW\*(C`/d\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, n' \f(CW\*(C`/l\*(C'\fR modifiers is not likely ta be of much use
to you, n' so you need not worry bout dem straight-up much.  They exist for
Perlz internal use, so dat complex regular expression data structures
can be automatically serialized n' lata exactly reconstituted,
includin all they nuances.  But, since Perl can't keep a secret, and
there may be rare instances where they is useful, they is documented
here.
.PP
Da \f(CW\*(C`/a\*(C'\fR modifier, on tha other hand, may be useful naaahhmean?  Its purpose is to
allow code dat is ta work mostly on \s-1ASCII\s0 data ta not gotta concern
itself wit Unicode.
.PP
Briefly, \f(CW\*(C`/l\*(C'\fR sets tha characta set ta dat of whatever \fBL\fRocale is in
effect all up in tha time of tha execution of tha pattern match.
.PP
\&\f(CW\*(C`/u\*(C'\fR sets tha characta set ta \fBU\fRnicode.
.PP
\&\f(CW\*(C`/a\*(C'\fR also sets tha characta set ta Unicode, \s-1BUT\s0 addz several
restrictions fo' \fBA\fRSCII-safe matching.
.PP
\&\f(CW\*(C`/d\*(C'\fR is tha old, problematic, pre\-5.14 \fBD\fRefault characta set
behavior. Shiiit, dis aint no joke.  Its only use is ta force dat oldschool behavior.
.PP
At any given time, exactly one of these modifiers is up in effect.  Their
existence allows Perl ta keep tha originally compiled behavior of a
regular expression, regardless of what tha fuck rulez is up in effect when it is
actually executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  And if it is interpolated tha fuck into a larger regex, the
originalz rulez continue ta apply ta it, n' only dat shit.
.PP
Da \f(CW\*(C`/l\*(C'\fR n' \f(CW\*(C`/u\*(C'\fR modifiers is automatically selected for
regular expressions compiled within tha scope of various pragmas,
and we recommend dat up in general, you use dem pragmas instead of
specifyin these modifiers explicitly.  For one thang, tha modifiers
affect only pattern matching, n' do not extend ta even any replacement
done, whereas rockin tha pragmas give consistent thangs up in dis biatch fo' all
appropriate operations within they scopes.  For example,
.PP
.Vb 1
\& s/foo/\eUbar/il
.Ve
.PP
will match \*(L"foo\*(R" rockin tha localez rulez fo' case-insensitizzle matching,
but tha \f(CW\*(C`/l\*(C'\fR do not affect how tha fuck tha \f(CW\*(C`\eU\*(C'\fR operates.  Most likely you
want both of dem ta use locale rules.  To do this, instead compile the
regular expression within tha scope of \f(CW\*(C`use locale\*(C'\fR.  This both
implicitly addz tha \f(CW\*(C`/l\*(C'\fR n' applies locale rulez ta tha \f(CW\*(C`\eU\*(C'\fR.   The
lesson is ta \f(CW\*(C`use locale\*(C'\fR n' not \f(CW\*(C`/l\*(C'\fR explicitly.
.PP
Similarly, it would be betta ta use \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR
instead of,
.PP
.Vb 1
\& s/foo/\eLbar/iu
.Ve
.PP
to git Unicode rules, as tha \f(CW\*(C`\eL\*(C'\fR up in tha forma (but not necessarily
the latter) would also use Unicode rules.
.PP
Mo' detail on each of tha modifiers bigs up.  Most likely you don't
need ta know dis detail fo' \f(CW\*(C`/l\*(C'\fR, \f(CW\*(C`/u\*(C'\fR, n' \f(CW\*(C`/d\*(C'\fR, n' can skip ahead
to /a.
.PP
/l
.IX Subsection "/l"
.PP
means ta use tha current localez rulez (see perllocale) when pattern
matching.  For example, \f(CW\*(C`\ew\*(C'\fR will match tha \*(L"word\*(R" charactaz of that
locale, n' \f(CW"/i"\fR case-insensitizzle matchin will match accordin to
the localez case foldin rules.  Da locale used is ghon be tha one in
effect all up in tha time of execution of tha pattern match.  This may not be
the same as tha compilation-time locale, n' can differ from one match
to another if there be a intervenin call of the
\&\fIsetlocale()\fR function.
.PP
Perl only supports single-byte locales.  This means dat code points
above 255 is treated as Unicode no matta what tha fuck locale is up in effect.
Under Unicode rules, there be all dem case-insensitizzle matches dat cross
the 255/256 boundary.  These is disallowed under \f(CW\*(C`/l\*(C'\fR.  For example,
0xFF (on \s-1ASCII\s0 platforms) do not caselessly match tha characta at
0x178, \f(CW\*(C`LATIN CAPITAL LETTER Y WITH DIAERESIS\*(C'\fR, cuz 0xFF may not be
\&\f(CW\*(C`LATIN SMALL LETTER Y WITH DIAERESIS\*(C'\fR up in tha current locale, n' Perl
has no way of knowin if dat characta even exists up in tha locale, much
less what tha fuck code point it is.
.PP
This modifier may be specified ta be tha default by \f(CW\*(C`use locale\*(C'\fR yo, but
see \*(L"Which characta set modifier is up in effect?\*(R".
.IX Xref " l"
.PP
/u
.IX Subsection "/u"
.PP
means ta use Unicode rulez when pattern matching.  On \s-1ASCII\s0 platforms,
this means dat tha code points between 128 n' 255 take on their
Latin\-1 (\s-1ISO\-8859\-1\s0) meanings (which is tha same as Unicode's).
(Otherwise Perl considaz they meanings ta be undefined.)  Thus,
under dis modifier, tha \s-1ASCII\s0 platform effectively becomes a Unicode
platform; n' hence, fo' example, \f(CW\*(C`\ew\*(C'\fR will match any of tha mo' than
100_000 word charactas up in Unicode.
.PP
Unlike most locales, which is specific ta a language n' ghetto pair,
Unicode classifies all tha charactas dat is lettas \fIsomewhere\fR in
the ghetto as
\&\f(CW\*(C`\ew\*(C'\fR.  For example, yo' locale might not be thinkin dat \f(CW\*(C`LATIN SMALL
LETTER ETH\*(C'\fR be a letta (unless you happen ta drop a rhyme Icelandic) yo, but
Unicode do.  Similarly, all tha charactas dat is decimal digits
somewhere up in tha ghetto will match \f(CW\*(C`\ed\*(C'\fR; dis is hundreds, not 10,
possible matches.  And a shitload of dem digits be lookin like a shitload of tha 10
\&\s-1ASCII\s0 digits yo, but mean a gangbangin' finger-lickin' different number, so a human could easily think
a number be a gangbangin' finger-lickin' different quantitizzle than it straight-up is.  For example,
\&\f(CW\*(C`BENGALI DIGIT FOUR\*(C'\fR (U+09EA) looks straight-up much like an
\&\f(CW\*(C`ASCII DIGIT EIGHT\*(C'\fR (U+0038).  And, \f(CW\*(C`\ed+\*(C'\fR, may match stringz of digits
that is a mixture from different freestylin systems, bustin a security
issue.  \*(L"\fInum()\fR\*(R" up in Unicode::UCD can be used ta sort
this out.  Or tha \f(CW\*(C`/a\*(C'\fR modifier can be used ta force \f(CW\*(C`\ed\*(C'\fR ta match
just tha \s-1ASCII 0\s0 all up in 9.
.PP
Also, under dis modifier, case-insensitizzle matchin works on tha full
set of Unicode
characters.  Da \f(CW\*(C`KELVIN SIGN\*(C'\fR, fo' example matches tha lettas \*(L"k\*(R" and
\&\*(L"K\*(R"; n' \f(CW\*(C`LATIN SMALL LIGATURE FF\*(C'\fR matches tha sequence \*(L"ff\*(R", which,
if you not prepared, might make it be lookin like a hexadecimal constant,
presentin another potential securitizzle issue.  See
<http://unicode.org/reports/tr36> fo' a thugged-out detailed rap of Unicode
securitizzle issues.
.PP
This modifier may be specified ta be tha default by \f(CW\*(C`use feature
\&\*(Aqunicode_strings\*(C'\fR, \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher),
but peep \*(L"Which characta set modifier is up in effect?\*(R".
.IX Xref " u"
.PP
/d
.IX Subsection "/d"
.PP
This modifier means ta use tha \*(L"Default\*(R" natizzle rulez of tha platform
except when there is cause ta use Unicode rulez instead, as bigs up:
.IP "1." 4
the target strang is encoded up in \s-1UTF\-8\s0; or
.IP "2." 4
the pattern is encoded up in \s-1UTF\-8\s0; or
.IP "3." 4
the pattern explicitly mentions a cold-ass lil code point dat be above 255 (say by
\&\f(CW\*(C`\ex{100}\*(C'\fR); or
.IP "4." 4
the pattern uses a Unicode name (\f(CW\*(C`\eN{...}\*(C'\fR);  or
.IP "5." 4
the pattern uses a Unicode property (\f(CW\*(C`\ep{...}\*(C'\fR); or
.IP "6." 4
the pattern uses "\f(CW\*(C`(?[ ])\*(C'\fR"
.PP
Another mnemonic fo' dis modifier is \*(L"Depends\*(R", as tha rulez actually
used depend on various thangs, n' as a result you can git unexpected
results, n' you can put dat on yo' toast.  See \*(L"Da \*(R"Unicode Bug"" up in perlunicode.  Da Unicode Bug has
become rather infamous, leadin ta yet another (printable) name fo' this
modifier, \*(L"Dodgy\*(R".
.PP
Unless tha pattern or strang is encoded up in \s-1UTF\-8,\s0 only \s-1ASCII\s0 characters
can match positively.
.PP
Here is some examplez of how tha fuck dat works on a \s-1ASCII\s0 platform:
.PP
.Vb 6
\& $str =  "\exDF";      # $str aint up in UTF\-8 format.
\& $str =~ /^\ew/;       # No match, as $str isn\*(Aqt up in UTF\-8 format.
\& $str .= "\ex{0e0b}";  # Now $str is up in UTF\-8 format.
\& $str =~ /^\ew/;       # Match! $str is now up in UTF\-8 format.
\& chop $str;
\& $str =~ /^\ew/;       # Still a match! $str remains up in UTF\-8 format.
.Ve
.PP
This modifier be automatically selected by default when none of the
others are, so yet another name fo' it is \*(L"Default\*(R".
.PP
Because of tha unexpected behaviors associated wit dis modifier, you
probably should only use it ta maintain weird backward compatibilities.
.PP
/a (and /aa)
.IX Subsection "/a (and /aa)"
.PP
This modifier standz fo' ASCII-restrict (or ASCII-safe).  This modifier,
unlike tha others, may be doubled-up ta increase its effect.
.PP
When it appears singly, it causes tha sequences \f(CW\*(C`\ed\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, and
the Posix characta classes ta match only up in tha \s-1ASCII\s0 range.  They thus
revert ta they pre\-5.6, pre-Unicode meanings.  Under \f(CW\*(C`/a\*(C'\fR,  \f(CW\*(C`\ed\*(C'\fR
always means precisely tha digits \f(CW"0"\fR ta \f(CW"9"\fR; \f(CW\*(C`\es\*(C'\fR means tha five
charactas \f(CW\*(C`[ \ef\en\er\et]\*(C'\fR, n' startin up in Perl v5.18, experimentally,
the vertical tab; \f(CW\*(C`\ew\*(C'\fR means tha 63 characters
\&\f(CW\*(C`[A\-Za\-z0\-9_]\*(C'\fR; n' likewise, all tha Posix classes such as
\&\f(CW\*(C`[[:print:]]\*(C'\fR match only tha appropriate ASCII-range characters.
.PP
This modifier is useful fo' playas whoz ass only incidentally use Unicode,
and whoz ass do not wish ta be burdened wit its complexitizzles n' security
concerns.
.PP
With \f(CW\*(C`/a\*(C'\fR, one can write \f(CW\*(C`\ed\*(C'\fR wit confidence dat it will only match
\&\s-1ASCII\s0 characters, n' should tha need arise ta match beyond \s-1ASCII,\s0 you
can instead use \f(CW\*(C`\ep{Digit}\*(C'\fR (or \f(CW\*(C`\ep{Word}\*(C'\fR fo' \f(CW\*(C`\ew\*(C'\fR).  There are
similar \f(CW\*(C`\ep{...}\*(C'\fR constructs dat can match beyond \s-1ASCII\s0 both white
space (see \*(L"Whitespace\*(R" up in perlrecharclass), n' Posix classes (see
\&\*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass).  Thus, dis modifier
doesn't mean you can't use Unicode, it means dat ta git Unicode
matchin you must explicitly bust a cold-ass lil construct (\f(CW\*(C`\ep{}\*(C'\fR, \f(CW\*(C`\eP{}\*(C'\fR) that
signals Unicode.
.PP
As you would expect, dis modifier causes, fo' example, \f(CW\*(C`\eD\*(C'\fR ta mean
the same thang as \f(CW\*(C`[^0\-9]\*(C'\fR; up in fact, all non-ASCII charactas match
\&\f(CW\*(C`\eD\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, n' \f(CW\*(C`\eW\*(C'\fR.  \f(CW\*(C`\eb\*(C'\fR still means ta match all up in tha boundary
between \f(CW\*(C`\ew\*(C'\fR n' \f(CW\*(C`\eW\*(C'\fR, rockin tha \f(CW\*(C`/a\*(C'\fR definitionz of dem (similarly
for \f(CW\*(C`\eB\*(C'\fR).
.PP
Otherwise, \f(CW\*(C`/a\*(C'\fR behaves like tha \f(CW\*(C`/u\*(C'\fR modifier, up in that
case-insensitizzle matchin uses Unicode semantics; fo' example, \*(L"k\*(R" will
match tha Unicode \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching, n' code
points up in tha Latin1 range, above \s-1ASCII\s0 gonna git Unicode rulez when it
comes ta case-insensitizzle matching.
.PP
To forbid ASCII/non\-ASCII matches (like \*(L"k\*(R" wit \f(CW\*(C`\eN{KELVIN SIGN}\*(C'\fR),
specify tha \*(L"a\*(R" twice, fo' example \f(CW\*(C`/aai\*(C'\fR or \f(CW\*(C`/aia\*(C'\fR.  (Da first
occurrence of \*(L"a\*(R" restricts tha \f(CW\*(C`\ed\*(C'\fR, etc., n' tha second occurrence
addz tha \f(CW\*(C`/i\*(C'\fR restrictions.)  But, note dat code points outside the
\&\s-1ASCII\s0 range will use Unicode rulez fo' \f(CW\*(C`/i\*(C'\fR matching, so tha modifier
doesn't straight-up restrict thangs ta just \s-1ASCII\s0; it just forbidz the
intermixin of \s-1ASCII\s0 n' non-ASCII.
.PP
To summarize, dis modifier serves up protection fo' applications that
don't wish ta be exposed ta all of Unicode.  Specifyin it twice
gives added protection.
.PP
This modifier may be specified ta be tha default by \f(CW\*(C`use re \*(Aq/a\*(Aq\*(C'\fR
or \f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR.  If you do so, you may straight-up have occasion ta use
the \f(CW\*(C`/u\*(C'\fR modifier explictly if there be all dem regular expressions
where you do want full Unicode rulez (but even here, itz dopest if
everythang was under feature \f(CW"unicode_strings"\fR, along wit the
\&\f(CW\*(C`use re \*(Aq/aa\*(Aq\*(C'\fR).  Also peep \*(L"Which characta set modifier is in
effect?\*(R".
.IX Xref " a aa"
.PP
Which characta set modifier is up in effect?
.IX Subsection "Which characta set modifier is up in effect?"
.PP
Which of these modifiers is up in effect at any given point up in a regular
expression dependz on a gangbangin' fairly complex set of interactions.  These have
been designed so dat up in general you don't gotta worry bout it yo, but
this section gives tha gory details.  As
explained below up in \*(L"Extended Patterns\*(R" it is possible ta explicitly
specify modifiers dat apply only ta portionz of a regular expression.
Da innermost always has prioritizzle over any outa ones, n' one applying
to tha whole expression has prioritizzle over any of tha default settings dat are
busted lyrics bout up in tha remainder of dis section.
.PP
Da \f(CW\*(C`use re \*(Aq/foo\*(Aq\*(C'\fR pragma can be used ta set
default modifiers (includin these) fo' regular expressions compiled
within its scope.  This pragma has precedence over tha other pragmas
listed below dat also chizzle tha defaults.
.PP
Otherwise, \f(CW\*(C`use locale\*(C'\fR sets tha default modifier ta \f(CW\*(C`/l\*(C'\fR;
and \f(CW\*(C`use feature \*(Aqunicode_strings\*(C'\fR, or
\&\f(CW\*(C`use 5.012\*(C'\fR (or higher) set tha default to
\&\f(CW\*(C`/u\*(C'\fR when not up in tha same scope as either \f(CW\*(C`use locale\*(C'\fR
or \f(CW\*(C`use bytes\*(C'\fR.
(\f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR also
sets tha default ta \f(CW\*(C`/u\*(C'\fR, overridin any plain \f(CW\*(C`use locale\*(C'\fR.)
Unlike tha mechanizzlez mentioned above, these
affect operations besides regular expressions pattern matching, n' so
give mo' consistent thangs up in dis biatch wit other operators, includin using
\&\f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\el\*(C'\fR, etc. up in substitution replacements.
.PP
If none of tha above apply, fo' backwardz compatibilitizzle reasons, the
\&\f(CW\*(C`/d\*(C'\fR modifier is tha one up in effect by default.  As dis can lead to
unexpected thangs up in dis biatch, it is dopest ta specify which other rule set should be
used.
.PP
Characta set modifier behavior prior ta Perl 5.14
.IX Subsection "Characta set modifier behavior prior ta Perl 5.14"
.PP
Prior ta 5.14, there was no explicit modifiers yo, but \f(CW\*(C`/l\*(C'\fR was implied
for regexes compiled within tha scope of \f(CW\*(C`use locale\*(C'\fR, n' \f(CW\*(C`/d\*(C'\fR was
implied otherwise.  But fuck dat shiznit yo, tha word on tha street is dat interpolatin a regex tha fuck into a larger regex
would ignore tha original gangsta compilation up in favor of whatever was up in effect
at tha time of tha second compilation. I aint talkin' bout chicken n' gravy biatch.  There was a number of
inconsistencies (bugs) wit tha \f(CW\*(C`/d\*(C'\fR modifier, where Unicode rules
would be used when inappropriate, n' vice versa.  \f(CW\*(C`\ep{}\*(C'\fR did not imply
Unicode rules, n' neither did all occurrencez of \f(CW\*(C`\eN{}\*(C'\fR, until 5.12.
.SS "Regular Expressions"
.IX Subsection "Regular Expressions"
\fIMetacharacters\fR
.IX Subsection "Metacharacters"
.PP
Da patterns used up in Perl pattern matchin evolved from dem supplied in
the Version 8 regex routines.  (Da routines is derived
(distantly) from Henry Spencerz freely redistributable reimplementation
of tha V8 routines.)  See \*(L"Version 8 Regular Expressions\*(R" for
details.
.PP
In particular tha followin metacharactas have they standard \fIegrep\fR\-ish
meanings:
.IX Xref "metacharacta \\ ^ . $ | ( () [ []"
.PP
.Vb 7
\&    \e        Quote tha next metacharacter
\&    ^        Match tha beginnin of tha line
\&    .        Match any characta (except newline)
\&    $        Match tha end of tha line (or before newline all up in tha end)
\&    |        Alternation
\&    ()       Grouping
\&    []       Bracketed Characta class
.Ve
.PP
By default, tha \*(L"^\*(R" characta is guaranteed ta match only the
beginnin of tha string, tha \*(L"$\*(R" characta only tha end (or before the
newline all up in tha end), n' Perl do certain optimizations wit the
assumption dat tha strang gotz nuff only one line.  Embedded newlines
will not be matched by \*(L"^\*(R" or \*(L"$\*(R".  Yo ass may, however, wish ta treat a
strin as a multi-line buffer, such dat tha \*(L"^\*(R" will match afta any
newline within tha strang (except if tha newline is tha last characta in
the string), n' \*(L"$\*(R" will match before any newline.  At the
cost of a lil mo' overhead, you can do dis by rockin tha /m modifier
on tha pattern match operator. Shiiit, dis aint no joke.  (Older programs did dis by settin \f(CW$*\fR,
but dis option was removed up in perl 5.10.)
.IX Xref "^ $ m"
.PP
To simplify multi-line substitutions, tha \*(L".\*(R" characta never matches a
newline unless you use tha \f(CW\*(C`/s\*(C'\fR modifier, which up in effect  drops some lyrics ta Perl ta pretend
the strang be a single line\*(--even if it aint.
.IX Xref ". s"
.PP
\fIQuantifiers\fR
.IX Subsection "Quantifiers"
.PP
Da followin standard quantifiers is recognized:
.IX Xref "metacharacta quantifier * + ? {n} {n,} {n,m}"
.PP
.Vb 6
\&    *           Match 0 or mo' times
\&    +           Match 1 or mo' times
\&    ?           Match 1 or 0 times
\&    {n}         Match exactly n times
\&    {n,}        Match at least n times
\&    {n,m}       Match at least n but not mo' than m times
.Ve
.PP
(If a cold-ass lil curly bracket occurs up in any other context n' do not form part of
a backslashed sequence like \f(CW\*(C`\ex{...}\*(C'\fR, it is treated as a regular
character n' shit.  In particular, tha lower quantifier bound aint optional,
and a typo up in a quantifier silently causes it ta be treated as the
literal characters.  For example,
.PP
.Vb 1
\&    /o{4,3}/
.Ve
.PP
looks like a quantifier dat matches 0 times, since 4 is pimped outa than 3,
but it straight-up means ta match tha sequence of six characters
\&\f(CW"o\ {\ 4\ ,\ 3\ }"\fR.  It be planned ta eventually require literal uses
of curly brackets ta be escaped, say by precedin dem wit a funky-ass backslash
or enclosin dem within square brackets, (\f(CW"\e{"\fR or \f(CW"[{]"\fR).  This
change will allow fo' future syntax extensions (like makin tha lower
bound of a quantifier optional), n' betta error checking.  In the
meantime, you should git up in tha g-thang of escapin all instances where
you mean a literal \*(L"{\*(R".)
.PP
Da \*(L"*\*(R" quantifier is equivalent ta \f(CW\*(C`{0,}\*(C'\fR, tha \*(L"+\*(R"
quantifier ta \f(CW\*(C`{1,}\*(C'\fR, n' tha \*(L"?\*(R" quantifier ta \f(CW\*(C`{0,1}\*(C'\fR.  n n' m is limited
to non-negatizzle integral joints less than a preset limit defined when perl is built.
This is probably 32766 on da most thugged-out common platforms.  Da actual limit can
be peeped up in tha error message generated by code like fuckin this:
.PP
.Vb 1
\&    $_ **= $_ , / {$_} / fo' 2 .. 42;
.Ve
.PP
By default, a quantified subpattern is \*(L"greedy\*(R", dat is, it will match as
many times as possible (given a particular startin location) while still
allowin tha rest of tha pattern ta match.  If you want it ta match the
minimum number of times possible, follow tha quantifier wit a \*(L"?\*(R".  Note
that tha meanings don't chizzle, just tha \*(L"greediness\*(R":
.IX Xref "metacharacta greedy greedinizz ? *? +? ?? {n}? {n,}? {n,m}?"
.PP
.Vb 6
\&    *?        Match 0 or mo' times, not greedily
\&    +?        Match 1 or mo' times, not greedily
\&    ??        Match 0 or 1 time, not greedily
\&    {n}?      Match exactly n times, not greedily (redundant)
\&    {n,}?     Match at least n times, not greedily
\&    {n,m}?    Match at least n but not mo' than m times, not greedily
.Ve
.PP
By default, when a quantified subpattern do not allow tha rest of the
overall pattern ta match, Perl will backtrack. But fuck dat shiznit yo, tha word on tha street is dat dis behaviour is
sometimes undesirable. Thus Perl serves up tha \*(L"possessive\*(R" quantifier form
as well.
.PP
.Vb 6
\& *+     Match 0 or mo' times n' give not a god damn thang back
\& ++     Match 1 or mo' times n' give not a god damn thang back
\& ?+     Match 0 or 1 time n' give not a god damn thang back
\& {n}+   Match exactly n times n' give not a god damn thang back (redundant)
\& {n,}+  Match at least n times n' give not a god damn thang back
\& {n,m}+ Match at least n but not mo' than m times n' give not a god damn thang back
.Ve
.PP
For instance,
.PP
.Vb 1
\&   \*(Aqaaaa\*(Aq =~ /a++a/
.Ve
.PP
will never match, as tha \f(CW\*(C`a++\*(C'\fR will gobble up all tha \f(CW\*(C`a\*(C'\fRz up in the
strin n' won't leave any fo' tha remainin part of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This
feature can be mad useful ta give perl hints bout where it
shouldn't backtrack. For instance, tha typical \*(L"match a thugged-out double-quoted
string\*(R" problem can be most efficiently performed when freestyled as:
.PP
.Vb 1
\&   /"(?:[^"\e\e]++|\e\e.)*+"/
.Ve
.PP
as we know dat if tha final quote do not match, backtrackin will not
help. Right back up in yo muthafuckin ass. See tha independent subexpression
"\f(CW\*(C`(?>pattern)\*(C'\fR" fo' mo' details;
possessive quantifiers is just syntactic sugar fo' dat construct. For
instizzle tha above example could also be freestyled as bigs up:
.PP
.Vb 1
\&   /"(?>(?:(?>[^"\e\e]+)|\e\e.)*)"/
.Ve
.PP
\fIEscape sequences\fR
.IX Subsection "Escape sequences"
.PP
Because patterns is processed as double-quoted strings, tha following
also work:
.PP
.Vb 10
\& \et          tab                   (HT, TAB)
\& \en          newline               (LF, NL)
\& \er          return                (CR)
\& \ef          form feed             (FF)
\& \ea          alarm (bell)          (BEL)
\& \ee          escape (think troff)  (ESC)
\& \ecK         control char          (example: VT)
\& \ex{}, \ex00  characta whose ordinal is tha given hexadecimal number
\& \eN{name}    named Unicode characta or characta sequence
\& \eN{U+263D}  Unicode characta     (example: FIRST QUARTER MOON)
\& \eo{}, \e000  characta whose ordinal is tha given octal number
\& \el          lowercase next char (think vi)
\& \eu          uppercase next char (think vi)
\& \eL          lowercase till \eE (think vi)
\& \eU          uppercase till \eE (think vi)
\& \eQ          quote (disable) pattern metacharactas till \eE
\& \eE          end either case modification or quoted section, be thinkin vi
.Ve
.PP
Details is up in \*(L"Quote n' Quote-like Operators\*(R" up in perlop.
.PP
\fICharacta Classes n' other Special Escapes\fR
.IX Subsection "Characta Classes n' other Special Escapes"
.PP
In addition, Perl defines tha following:
.IX Xref "\\g \\k \\K backreference"
.PP
.Vb 10
\& Sequence   Note    Description
\&  [...]     [1]  Match a cold-ass lil characta accordin ta tha rulez of the
\&                   bracketed characta class defined by tha "...".
\&                   Example: [a\-z] matches "a" or "b" or "c" ... or "z"
\&  [[:...:]] [2]  Match a cold-ass lil characta accordin ta tha rulez of tha POSIX
\&                   characta class "..." within tha outa bracketed
\&                   characta class.  Example: [[:upper:]] matches any
\&                   uppercase character.
\&  (?[...])  [8]  Extended bracketed characta class
\&  \ew        [3]  Match a "word" characta (alphanumeric plus "_", plus
\&                   other connector punctuation chars plus Unicode
\&                   marks)
\&  \eW        [3]  Match a non\-"word" character
\&  \es        [3]  Match a whitespace character
\&  \eS        [3]  Match a non\-whitespace character
\&  \ed        [3]  Match a thugged-out decimal digit character
\&  \eD        [3]  Match a non\-digit character
\&  \epP       [3]  Match P, named property.  Use \ep{Prop} fo' longer names
\&  \ePP       [3]  Match non\-P
\&  \eX        [4]  Match Unicode "eXtended grapheme cluster"
\&  \eC             Match a single C\-language char (octet) even if dat is
\&                   part of a larger UTF\-8 character n' shit.  Thus it breaks up
\&                   charactas tha fuck into they UTF\-8 bytes, so you may end up
\&                   wit malformed piecez of UTF\-8.  Unsupported in
\&                   lookbehind.
\&  \e1        [5]  Backreference ta a specific capture crew or buffer.
\&                   \*(Aq1\*(Aq may straight-up be any positizzle integer.
\&  \eg1       [5]  Backreference ta a specific or previous group,
\&  \eg{\-1}    [5]  Da number may be wack indicatin a relative
\&                   previous crew n' may optionally be wrapped in
\&                   curly brackets fo' less thuggy parsing.
\&  \eg{name}  [5]  Named backreference
\&  \ek<name>  [5]  Named backreference
\&  \eK        [6]  Keep tha shiznit left of tha \eK, don\*(Aqt include it up in $&
\&  \eN        [7]  Any characta but \en. I aint talkin' bout chicken n' gravy biatch.  Not affected by /s modifier
\&  \ev        [3]  Vertical whitespace
\&  \eV        [3]  Not vertical whitespace
\&  \eh        [3]  Horizontal whitespace
\&  \eH        [3]  Not horizontal whitespace
\&  \eR        [4]  Linebreak
.Ve
.IP "[1]" 4
.IX Item "[1]"
See \*(L"Bracketed Characta Classes\*(R" up in perlrecharclass fo' details.
.IP "[2]" 4
.IX Item "[2]"
See \*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass fo' details.
.IP "[3]" 4
.IX Item "[3]"
See \*(L"Backslash sequences\*(R" up in perlrecharclass fo' details.
.IP "[4]" 4
.IX Item "[4]"
See \*(L"Misc\*(R" up in perlrebackslash fo' details.
.IP "[5]" 4
.IX Item "[5]"
See \*(L"Capture groups\*(R" below fo' details.
.IP "[6]" 4
.IX Item "[6]"
See \*(L"Extended Patterns\*(R" below fo' details.
.IP "[7]" 4
.IX Item "[7]"
Note dat \f(CW\*(C`\eN\*(C'\fR has two meanings.  When of tha form \f(CW\*(C`\eN{NAME}\*(C'\fR, it matches the
characta or characta sequence whose name is \f(CW\*(C`NAME\*(C'\fR; n' similarly
when of tha form \f(CW\*(C`\eN{U+\f(CIhex\f(CW}\*(C'\fR, it matches tha characta whose Unicode
code point is \fIhex\fR.  Otherwise it matches any characta but \f(CW\*(C`\en\*(C'\fR.
.IP "[8]" 4
.IX Item "[8]"
See \*(L"Extended Bracketed Characta Classes\*(R" up in perlrecharclass fo' details.
.PP
\fIAssertions\fR
.IX Subsection "Assertions"
.PP
Perl defines tha followin zero-width assertions:
.IX Xref "zero-width assertion assertion regex, zero-width assertion regexp, zero-width assertion regular expression, zero-width assertion \\b \\B \\A \\Z \\z \\G"
.PP
.Vb 7
\&    \eb  Match a word boundary
\&    \eB  Match except at a word boundary
\&    \eA  Match only at beginnin of string
\&    \eZ  Match only at end of string, or before newline all up in tha end
\&    \ez  Match only at end of string
\&    \eG  Match only at pos() (e.g. all up in tha end\-of\-match position
\&        of prior m//g)
.Ve
.PP
A word boundary (\f(CW\*(C`\eb\*(C'\fR) be a spot between two characters
that has a \f(CW\*(C`\ew\*(C'\fR on one side of it n' a \f(CW\*(C`\eW\*(C'\fR on tha other side
of it (in either order), countin tha imaginary charactas off the
beginnin n' end of tha strang as matchin a \f(CW\*(C`\eW\*(C'\fR.  (Within
characta classes \f(CW\*(C`\eb\*(C'\fR represents backspace rather than a word
boundary, just as it normally do up in any double-quoted string.)
Da \f(CW\*(C`\eA\*(C'\fR n' \f(CW\*(C`\eZ\*(C'\fR is just like \*(L"^\*(R" n' \*(L"$\*(R", except dat they
won't match multiple times when tha \f(CW\*(C`/m\*(C'\fR modifier is used, while
\&\*(L"^\*(R" n' \*(L"$\*(R" will match at every last muthafuckin internal line boundary.  To match
the actual end of tha strang n' not ignore a optionizzle trailing
newline, use \f(CW\*(C`\ez\*(C'\fR.
.IX Xref "\\b \\A \\Z \\z m"
.PP
Da \f(CW\*(C`\eG\*(C'\fR assertion can be used ta chain global matches (using
\&\f(CW\*(C`m//g\*(C'\fR), as busted lyrics bout up in \*(L"Regexp Quote-Like Operators\*(R" up in perlop.
It be also useful when freestylin \f(CW\*(C`lex\*(C'\fR\-like scanners, when you have
several patterns dat you wanna match against consequent substrings
of yo' string; peep tha previous reference.  Da actual location
where \f(CW\*(C`\eG\*(C'\fR will match can also be hyped up by rockin \f(CW\*(C`pos()\*(C'\fR as
an lvalue: peep \*(L"pos\*(R" up in perlfunc. Note dat tha rule fo' zero-length
matches (see \*(L"Repeated Patterns Matchin a Zero-length Substring\*(R")
is modified somewhat, up in dat contents ta tha left of \f(CW\*(C`\eG\*(C'\fR are
not counted when determinin tha length of tha match. Thus tha following
will not match forever:
.IX Xref "\\G"
.PP
.Vb 5
\&     mah $strin = \*(AqABC\*(Aq;
\&     pos($string) = 1;
\&     while ($strin =~ /(.\eG)/g) {
\&         print $1;
\&     }
.Ve
.PP
It will print 'A' n' then terminate, as it considaz tha match to
be zero-width, n' thus aint gonna match all up in tha same posizzle twice up in a
row.
.PP
It be worth notin dat \f(CW\*(C`\eG\*(C'\fR improperly used can result up in a infinite
loop. Take care when rockin patterns dat include \f(CW\*(C`\eG\*(C'\fR up in a alternation.
.PP
\fICapture groups\fR
.IX Subsection "Capture groups"
.PP
Da bracketin construct \f(CW\*(C`( ... )\*(C'\fR creates capture crews (also referred ta as
capture buffers). To refer ta tha current contentz of a crew lata on, within
the same pattern, use \f(CW\*(C`\eg1\*(C'\fR (or \f(CW\*(C`\eg{1}\*(C'\fR) fo' tha first, \f(CW\*(C`\eg2\*(C'\fR (or \f(CW\*(C`\eg{2}\*(C'\fR)
for tha second, n' so on.
This is called a \fIbackreference\fR.
 
 
 
 
    
 
 
  
There is no limit ta tha number of captured substrings dat you may use.
Groups is numbered wit tha leftmost open parenthesis bein number 1, etc.  If
a crew did not match, tha associated backreference won't match either n' shit. (This
can happen if tha crew is optional, or up in a gangbangin' finger-lickin' different branch of an
alternation.)
Yo ass can omit tha \f(CW"g"\fR, n' write \f(CW"\e1"\fR, etc yo, but there be some thangs with
this form, busted lyrics bout below.
.IX Xref "regex, capture buffer regexp, capture buffer regex, capture crew regexp, capture crew regular expression, capture buffer backreference regular expression, capture crew backreference \\g{1} \\g{-1} \\g{name} relatizzle backreference named backreference named capture buffer regular expression, named capture buffer named capture crew regular expression, named capture crew %+ $+{name} \\k<name>"
.PP
Yo ass can also refer ta capture crews relatively, by rockin a wack number, so
that \f(CW\*(C`\eg\-1\*(C'\fR n' \f(CW\*(C`\eg{\-1}\*(C'\fR both refer ta tha immediately precedin capture
group, n' \f(CW\*(C`\eg\-2\*(C'\fR n' \f(CW\*(C`\eg{\-2}\*(C'\fR both refer ta tha crew before dat shit.  For
example:
.PP
.Vb 8
\&        /
\&         (Y)            # crew 1
\&         (              # crew 2
\&            (X)         # crew 3
\&            \eg{\-1}      # backref ta crew 3
\&            \eg{\-3}      # backref ta crew 1
\&         )
\&        /x
.Ve
.PP
would match tha same as \f(CW\*(C`/(Y) ( (X) \eg3 \eg1 )/x\*(C'\fR.  This allows you to
interpolate regexes tha fuck into larger regexes n' not gotta worry bout the
capture crews bein renumbered.
.PP
Yo ass can dispense wit numbers altogether n' create named capture groups.
Da notation is \f(CW\*(C`(?<\f(CIname\f(CW>...)\*(C'\fR ta declare n' \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR to
reference.  (To be compatible wit .Net regular expressions, \f(CW\*(C`\eg{\f(CIname\f(CW}\*(C'\fR may
also be freestyled as \f(CW\*(C`\ek{\f(CIname\f(CW}\*(C'\fR, \f(CW\*(C`\ek<\f(CIname\f(CW>\*(C'\fR or \f(CW\*(C`\ek\*(Aq\f(CIname\f(CW\*(Aq\*(C'\fR.)
\&\fIname\fR must not begin wit a number, nor contain hyphens.
When different crews within tha same pattern have tha same name, any reference
to dat name assumes tha leftmost defined group.  Named crews count in
absolute n' relatizzle numbering, n' so can also be referred ta by them
numbers.
(It aint nuthin but possible ta do thangs wit named capture crews dat would otherwise
require \f(CW\*(C`(??{})\*(C'\fR.)
.PP
Capture crew contents is dynamically scoped n' available ta you outside the
pattern until tha end of tha enclosin block or until tha next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" up in perlsyn.)
Yo ass can refer ta dem by absolute number (usin \f(CW"$1"\fR instead of \f(CW"\eg1"\fR,
etc); or by name via tha \f(CW\*(C`%+\*(C'\fR hash, rockin \f(CW"$+{\f(CIname\f(CW}"\fR.
.PP
Braces is required up in referrin ta named capture groups yo, but is optionizzle for
absolute or relatizzle numbered ones.  Braces is less thuggy when bustin a regex by
concatenatin smalla strings.  For example if you have \f(CW\*(C`qr/$a$b/\*(C'\fR, n' \f(CW$a\fR
contained \f(CW"\eg1"\fR, n' \f(CW$b\fR contained \f(CW"37"\fR, you would git \f(CW\*(C`/\eg137/\*(C'\fR which
is probably not what tha fuck you intended.
.PP
Da \f(CW\*(C`\eg\*(C'\fR n' \f(CW\*(C`\ek\*(C'\fR notations was introduced up in Perl 5.10.0.  Prior ta that
there was no named nor relatizzle numbered capture groups.  Absolute numbered
groups was referred ta rockin \f(CW\*(C`\e1\*(C'\fR,
\&\f(CW\*(C`\e2\*(C'\fR, etc., n' dis notation is still
accepted (and likely always will be).  But it leadz ta some ambiguitizzles if
there is mo' than 9 capture groups, as \f(CW\*(C`\e10\*(C'\fR could mean either tha tenth
capture group, or tha characta whose ordinal up in octal is 010 (a backspace in
\&\s-1ASCII\s0).  Perl resolves dis ambiguitizzle by interpretin \f(CW\*(C`\e10\*(C'\fR as a funky-ass backreference
only if at least 10 left parentheses have opened before dat shit.  Likewise \f(CW\*(C`\e11\*(C'\fR is
a backreference only if at least 11 left parentheses have opened before dat shit.
And so on. I aint talkin' bout chicken n' gravy biatch.  \f(CW\*(C`\e1\*(C'\fR all up in \f(CW\*(C`\e9\*(C'\fR is always interpreted as backreferences.
There is nuff muthafuckin examplez below dat illustrate these perils.  Yo ass can avoid
the ambiguitizzle by always rockin \f(CW\*(C`\eg{}\*(C'\fR or \f(CW\*(C`\eg\*(C'\fR if you mean capturin groups;
and fo' octal constants always rockin \f(CW\*(C`\eo{}\*(C'\fR, or fo' \f(CW\*(C`\e077\*(C'\fR n' below, rockin 3
digits padded wit leadin zeros, since a leadin zero implies a octal
constant.
.PP
Da \f(CW\*(C`\e\f(CIdigit\f(CW\*(C'\fR notation also works up in certain circumstances outside
the pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  See \*(L"Warnin on \e1 Instead of \f(CW$1\fR\*(R" below fo' details.
.PP
Examples:
.PP
.Vb 1
\&    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two lyrics
\&
\&    /(.)\eg1/                        # find first doubled char
\&         n' print "\*(Aq$1\*(Aq is tha straight-up original gangsta doubled character\en";
\&
\&    /(?<char>.)\ek<char>/            # ... a gangbangin' finger-lickin' different way
\&         n' print "\*(Aq$+{char}\*(Aq is tha straight-up original gangsta doubled character\en";
\&
\&    /(?\*(Aqchar\*(Aq.)\eg1/                 # ... mix n' match
\&         n' print "\*(Aq$1\*(Aq is tha straight-up original gangsta doubled character\en";
\&
\&    if (/Time: (..):(..):(..)/) {   # parse up joints
\&        $hours = $1;
\&        $minutes = $2;
\&        $secondz = $3;
\&    }
\&
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\eg10/   # \eg10 be a funky-ass backreference
\&    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\e10/    # \e10 is octal
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e10/  # \e10 be a funky-ass backreference
\&    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\e010/ # \e010 is octal
\&
\&    $a = \*(Aq(.)\e1\*(Aq;        # Creates problems when concatenated.
\&    $b = \*(Aq(.)\eg{1}\*(Aq;     # Avoidz tha problems.
\&    "aa" =~ /${a}/;      # True
\&    "aa" =~ /${b}/;      # True
\&    "aa0" =~ /${a}0/;    # False!
\&    "aa0" =~ /${b}0/;    # True
\&    "aa\ex08" =~ /${a}0/;  # True!
\&    "aa\ex08" =~ /${b}0/;  # False
.Ve
.PP
Several special variablez also refer back ta portionz of tha previous
match.  \f(CW$+\fR returns whatever tha last bracket match matched.
\&\f(CW$&\fR returns tha entire matched string.  (At one point \f(CW$0\fR did
also yo, but now it returns tha name of tha program.)  \f(CW\*(C`$\`\*(C'\fR returns
everythang before tha matched string.  \f(CW\*(C`$\*(Aq\*(C'\fR returns every last muthafuckin thang
afta tha matched strin fo' realz. And \f(CW$^N\fR gotz nuff whatever was matched by
da most thugged-out-recently closed crew (submatch). \f(CW$^N\fR can be used in
extended patterns (see below), fo' example ta assign a submatch ta a
variable.
.IX Xref "$+ $^N $& $` $'"
.PP
These special variables, like tha \f(CW\*(C`%+\*(C'\fR hash n' tha numbered match variables
(\f(CW$1\fR, \f(CW$2\fR, \f(CW$3\fR, etc.) is dynamically scoped
until tha end of tha enclosin block or until tha next successful
match, whichever comes first.  (See \*(L"Compound Statements\*(R" up in perlsyn.)
.IX Xref "$+ $^N $& $` $' $1 $2 $3 $4 $5 $6 $7 $8 $9"
.PP
\&\fB\s-1NOTE\s0\fR: Failed matches up in Perl do not reset tha match variables,
which make it easier ta write code dat tests fo' a seriez of more
specific cases n' rethugz tha dopest match.
.PP
\&\fB\s-1WARNING\s0\fR: Once Perl sees dat you need one of \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR, or
\&\f(CW\*(C`$\*(Aq\*(C'\fR anywhere up in tha program, it has ta provide dem fo' every
pattern match.  This may substantially slow yo' program.  Perl
uses tha same ol' dirty mechanizzle ta produce \f(CW$1\fR, \f(CW$2\fR, etc, so you also pay a
price fo' each pattern dat gotz nuff capturin parentheses.  (To
avoid dis cost while retainin tha groupin behaviour, use the
extended regular expression \f(CW\*(C`(?: ... )\*(C'\fR instead.)  But if you never
use \f(CW$&\fR, \f(CW\*(C`$\`\*(C'\fR or \f(CW\*(C`$\*(Aq\*(C'\fR, then patterns \fIwithout\fR capturing
parentheses aint gonna be penalized. Y'all KNOW dat shit, muthafucka!  So avoid \f(CW$&\fR, \f(CW\*(C`$\*(Aq\*(C'\fR, n' \f(CW\*(C`$\`\*(C'\fR
if you can yo, but if you can't (and some algorithms straight-up appreciate
them), once you've used dem once, use dem at will, cuz you've
already paid tha price.  Az of 5.17.4, tha presence of each of tha three
variablez up in a program is recorded separately, n' dependin on
circumstances, perl may be able be mo' efficient knowin dat only \f(CW$&\fR
rather than all three done been seen, fo' example.
.IX Xref "$& $` $'"
.PP
As a workaround fo' dis problem, Perl 5.10.0 introduces \f(CW\*(C`${^PREMATCH}\*(C'\fR,
\&\f(CW\*(C`${^MATCH}\*(C'\fR n' \f(CW\*(C`${^POSTMATCH}\*(C'\fR, which is equivalent ta \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR
and \f(CW\*(C`$\*(Aq\*(C'\fR, \fBexcept\fR dat they is only guaranteed ta be defined afta a
successful match dat was executed wit tha \f(CW\*(C`/p\*(C'\fR (preserve) modifier.
Da use of these variablez incurs no global performizzle penalty, unlike
their punctuation char equivalents, however all up in tha trade-off dat you
have ta tell perl when you wanna use em.
.IX Xref " p p modifier"
.SS "Quotin metacharacters"
.IX Subsection "Quotin metacharacters"
Backslashed metacharactas up in Perl is alphanumeric, like fuckin \f(CW\*(C`\eb\*(C'\fR,
\&\f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\en\*(C'\fR.  Unlike some other regular expression languages, there
are no backslashed symbols dat aren't alphanumeric.  So anything
that be lookin like \e\e, \e(, \e), \e[, \e], \e{, or \e} be always
interpreted as a literal character, not a metacharacter n' shit.  This was
once used up in a cold-ass lil common idiom ta disable or quote tha special meanings
of regular expression metacharactas up in a strang dat you want to
use fo' a pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Simply quote all non\-\*(L"word\*(R" characters:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e$1/g;
.Ve
.PP
(If \f(CW\*(C`use locale\*(C'\fR is set, then dis dependz on tha current locale.)
Todizzle it is mo' common ta use tha \fIquotemeta()\fR function or tha \f(CW\*(C`\eQ\*(C'\fR
metaquotin escape sequence ta disable all metacharacters' special
meanings like this:
.PP
.Vb 1
\&    /$unquoted\eQ$quoted\eE$unquoted/
.Ve
.PP
Beware dat if you put literal backslashes (those not inside
interpolated variables) between \f(CW\*(C`\eQ\*(C'\fR n' \f(CW\*(C`\eE\*(C'\fR, double-quotish
backslash interpolation may lead ta confusin thangs up in dis biatch.  If you
\&\fIneed\fR ta use literal backslashes within \f(CW\*(C`\eQ...\eE\*(C'\fR,
consult \*(L"Gory detailz of parsin quoted constructs\*(R" up in perlop.
.PP
\&\f(CW\*(C`quotemeta()\*(C'\fR n' \f(CW\*(C`\eQ\*(C'\fR is straight-up busted lyrics bout up in \*(L"quotemeta\*(R" up in perlfunc.
.SS "Extended Patterns"
.IX Subsection "Extended Patterns"
Perl also defines a cold-ass lil consistent extension syntax fo' features not
found up in standard tools like \fBawk\fR and
\&\fBlex\fR.  Da syntax fo' most of these be a
pair of parentheses wit a question mark as tha straight-up original gangsta thang within
the parentheses.  Da characta afta tha question mark indicates
the extension.
.PP
Da stabilitizzle of these extensions varies widely.  Some have been
part of tha core language fo' nuff years.  Others is experimental
and may chizzle without warnin or be straight-up removed. Y'all KNOW dat shit, muthafucka!  Check
the documentation on a individual feature ta verify its current
status.
.PP
A question mark was chosen fo' dis n' fo' tha minimal-matching
construct cuz 1) question marks is rare up in olda regular
expressions, n' 2) whenever you peep one, you should stop and
\&\*(L"question\*(R" exactly what tha fuck is goin on. I aint talkin' bout chicken n' gravy biatch.  Thatz psychology....
.ie n .IP """(?#text)""" 4
.el .IP "\f(CW(?#text)\fR" 4
.IX Xref "(?#)"
.IX Item "(?#text)"
A comment.  Da text is ignored. Y'all KNOW dat shit, muthafucka!  If tha \f(CW\*(C`/x\*(C'\fR modifier enables
whitespace formatting, a simple \f(CW\*(C`#\*(C'\fR will suffice.  Note dat Perl closes
the comment as soon as it sees a \f(CW\*(C`)\*(C'\fR, so there is no way ta put a literal
\&\f(CW\*(C`)\*(C'\fR up in tha comment.
.ie n .IP """(?adlupimsx\-imsx)""" 4
.el .IP "\f(CW(?adlupimsx\-imsx)\fR" 4
.IX Item "(?adlupimsx-imsx)"
.PD 0
.ie n .IP """(?^alupimsx)""" 4
.el .IP "\f(CW(?^alupimsx)\fR" 4
.IX Xref "(?) (?^)"
.IX Item "(?^alupimsx)"
.PD
One or mo' embedded pattern-match modifiers, ta be turned on (or
turned off, if preceded by \f(CW\*(C`\-\*(C'\fR) fo' tha remainder of tha pattern or
the remainder of tha enclosin pattern crew (if any).
.Sp
This is particularly useful fo' dynamic patterns, like fuckin dem read up in from a
configuration file, taken from a argument, or specified up in a table
somewhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Consider tha case where some patterns wanna be
case-sensitizzle n' some do not:  Da case-insensitizzle ones merely need to
include \f(CW\*(C`(?i)\*(C'\fR all up in tha front of tha pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  For example:
.Sp
.Vb 2
\&    $pattern = "foobar";
\&    if ( /$pattern/i ) { }
\&
\&    # mo' flexible:
\&
\&    $pattern = "(?i)foobar";
\&    if ( /$pattern/ ) { }
.Ve
.Sp
These modifiers is restored all up in tha end of tha enclosin group. For example,
.Sp
.Vb 1
\&    ( (?i) blah ) \es+ \eg1
.Ve
.Sp
will match \f(CW\*(C`blah\*(C'\fR up in any case, some spaces, n' a exact (\fIincludin tha case\fR!)
repetizzle of tha previous word, assumin tha \f(CW\*(C`/x\*(C'\fR modifier, n' no \f(CW\*(C`/i\*(C'\fR
modifier outside dis group.
.Sp
These modifiers do not carry over tha fuck into named subpatterns called up in the
enclosin group. In other lyrics, a pattern like fuckin \f(CW\*(C`((?i)(?&NAME))\*(C'\fR do not
change tha case-sensitivitizzle of tha \*(L"\s-1NAME\*(R"\s0 pattern.
.Sp
Any of these modifiers can be set ta apply globally ta all regular
expressions compiled within tha scope of a \f(CW\*(C`use re\*(C'\fR.  See
\&\*(L"'/flags' mode\*(R" up in re.
.Sp
Startin up in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
afta tha \f(CW"?"\fR be a gangbangin' finger-lickin' dirty-ass shorthand equivalent ta \f(CW\*(C`d\-imsx\*(C'\fR.  Flags (except
\&\f(CW"d"\fR) may follow tha caret ta override dat shit.
But a minus sign aint legal wit dat shit.
.Sp
Note dat tha \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, \f(CW\*(C`p\*(C'\fR, n' \f(CW\*(C`u\*(C'\fR modifiers is special in
that they can only be enabled, not disabled, n' tha \f(CW\*(C`a\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`l\*(C'\fR, and
\&\f(CW\*(C`u\*(C'\fR modifiers is mutually exclusive: specifyin one de-specifies the
others, n' a maximum of one (or two \f(CW\*(C`a\*(C'\fR's) may step tha fuck up in the
construct.  Thus, for
example, \f(CW\*(C`(?\-p)\*(C'\fR will warn when compiled under \f(CW\*(C`use warnings\*(C'\fR;
\&\f(CW\*(C`(?\-d:...)\*(C'\fR n' \f(CW\*(C`(?dl:...)\*(C'\fR is fatal errors.
.Sp
Note also dat tha \f(CW\*(C`p\*(C'\fR modifier is special up in dat its presence
anywhere up in a pattern has a global effect.
.ie n .IP """(?:pattern)""" 4
.el .IP "\f(CW(?:pattern)\fR" 4
.IX Xref "(?:)"
.IX Item "(?:pattern)"
.PD 0
.ie n .IP """(?adluimsx\-imsx:pattern)""" 4
.el .IP "\f(CW(?adluimsx\-imsx:pattern)\fR" 4
.IX Item "(?adluimsx-imsx:pattern)"
.ie n .IP """(?^aluimsx:pattern)""" 4
.el .IP "\f(CW(?^aluimsx:pattern)\fR" 4
.IX Xref "(?^:)"
.IX Item "(?^aluimsx:pattern)"
.PD
This is fo' clustering, not capturing; it crews subexpressions like
\&\*(L"()\*(R" yo, but don't make backreferences as \*(L"()\*(R" do.  So
.Sp
.Vb 1
\&    @fieldz = split(/\eb(?:a|b|c)\eb/)
.Ve
.Sp
is like
.Sp
.Vb 1
\&    @fieldz = split(/\eb(a|b|c)\eb/)
.Ve
.Sp
but don't spit up extra fields.  It aint nuthin but also skankyer not ta capture
charactas if you don't need to.
.Sp
Any lettas between \f(CW\*(C`?\*(C'\fR n' \f(CW\*(C`:\*(C'\fR act as flags modifiers as with
\&\f(CW\*(C`(?adluimsx\-imsx)\*(C'\fR.  For example,
.Sp
.Vb 1
\&    /(?s\-i:more.*than).*million/i
.Ve
.Sp
is equivalent ta tha mo' verbose
.Sp
.Vb 1
\&    /(?:(?s\-i)more.*than).*million/i
.Ve
.Sp
Startin up in Perl 5.14, a \f(CW"^"\fR (caret or circumflex accent) immediately
afta tha \f(CW"?"\fR be a gangbangin' finger-lickin' dirty-ass shorthand equivalent ta \f(CW\*(C`d\-imsx\*(C'\fR.  Any positive
flags (except \f(CW"d"\fR) may follow tha caret, so
.Sp
.Vb 1
\&    (?^x:foo)
.Ve
.Sp
is equivalent to
.Sp
.Vb 1
\&    (?x\-ims:foo)
.Ve
.Sp
Da caret  drops some lyrics ta Perl dat dis clusta don't inherit tha flagz of any
surroundin pattern yo, but uses tha system defaults (\f(CW\*(C`d\-imsx\*(C'\fR),
modified by any flags specified.
.Sp
Da caret allows fo' simpla stringification of compiled regular
expressions.  These look like
.Sp
.Vb 1
\&    (?^:pattern)
.Ve
.Sp
with any non-default flags appearin between tha caret n' tha colon.
A test dat looks at such stringification thus don't need ta have the
system default flags hard-coded up in it, just tha caret.  If freshly smoked up flags are
added ta Perl, tha meanin of tha caretz expansion will chizzle ta include
the default fo' dem flags, so tha test will still work, unchanged.
.Sp
Specifyin a wack flag afta tha caret be a error, as tha flag is
redundant.
.Sp
Mnemonic fo' \f(CW\*(C`(?^...)\*(C'\fR:  A fresh beginnin since tha usual use of a cold-ass lil caret is
to match all up in tha beginning.
.ie n .IP """(?|pattern)""" 4
.el .IP "\f(CW(?|pattern)\fR" 4
.IX Xref "(?|) Branch reset"
.IX Item "(?|pattern)"
This is tha \*(L"branch reset\*(R" pattern, which has tha special property
that tha capture crews is numbered from tha same startin point
in each alternation branch. Well shiiiit, it be available startin from perl 5.10.0.
.Sp
Capture crews is numbered from left ta right yo, but inside this
construct tha numberin is restarted fo' each branch.
.Sp
Da numberin within each branch is ghon be as normal, n' any groups
followin dis construct is ghon be numbered as though tha construct
contained only one branch, dat bein tha one wit da most thugged-out capture
groups up in dat shit.
.Sp
This construct is useful when you wanna capture one of a
number of alternatizzle matches.
.Sp
Consider tha followin pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da numbers underneath show in
which crew tha captured content is ghon be stored.
.Sp
.Vb 3
\&    # before  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-branch\-reset\-\-\-\-\-\-\-\-\-\-\- afta        
\&    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
\&    # 1            2         2  3        2     3     4
.Ve
.Sp
Be careful when rockin tha branch reset pattern up in combination wit 
named captures. Named captures is implemented as bein aliases ta 
numbered crews holdin tha captures, n' dat interferes wit the
implementation of tha branch reset pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If yo ass is rockin named
captures up in a funky-ass branch reset pattern, itz dopest ta use tha same names,
in tha same order, up in each of tha alternations:
.Sp
.Vb 2
\&   /(?|  (?<a> x ) (?<b> y )
\&      |  (?<a> z ) (?<b> w )) /x
.Ve
.Sp
Not bustin so may lead ta surprises:
.Sp
.Vb 3
\&  "12" =~ /(?| (?<a> \ed+ ) | (?<b> \eD+))/x;
\&  say $+ {a};   # Prints \*(Aq12\*(Aq
\&  say $+ {b};   # *Also* prints \*(Aq12\*(Aq.
.Ve
.Sp
Da problem here is dat both tha crew named \f(CW\*(C`a\*(C'\fR n' tha group
named \f(CW\*(C`b\*(C'\fR is aliases fo' tha crew belongin ta \f(CW$1\fR.
.IP "Look-Around Assertions" 4
.IX Xref "look-around assertion lookaround assertion look-around lookaround"
.IX Item "Look-Around Assertions"
Look-around assertions is zero-width patterns which match a specific
pattern without includin it up in \f(CW$&\fR. Positizzle assertions match when
their subpattern matches, wack assertions match when they subpattern
fails. Look-behind matches text up ta tha current match position,
look-ahead matches text followin tha current match position.
.RS 4
.ie n .IP """(?=pattern)""" 4
.el .IP "\f(CW(?=pattern)\fR" 4
.IX Xref "(?=) look-ahead, positizzle lookahead, positive"
.IX Item "(?=pattern)"
A zero-width positizzle look-ahead assertion. I aint talkin' bout chicken n' gravy biatch.  For example, \f(CW\*(C`/\ew+(?=\et)/\*(C'\fR
matches a word followed by a tab, without includin tha tab up in \f(CW$&\fR.
.ie n .IP """(?!pattern)""" 4
.el .IP "\f(CW(?!pattern)\fR" 4
.IX Xref "(?!) look-ahead, wack lookahead, negative"
.IX Item "(?!pattern)"
A zero-width wack look-ahead assertion. I aint talkin' bout chicken n' gravy biatch.  For example \f(CW\*(C`/foo(?!bar)/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" dat aint followed by \*(L"bar\*(R".  Note
however dat look-ahead n' look-behind is \s-1NOT\s0 tha same thang.  Yo ass cannot
use dis fo' look-behind.
.Sp
If yo ass is lookin fo' a \*(L"bar\*(R" dat aint preceded by a \*(L"foo\*(R", \f(CW\*(C`/(?!foo)bar/\*(C'\fR
will not do what tha fuck you want.  Thatz cuz tha \f(CW\*(C`(?!foo)\*(C'\fR is just sayin that
the next thang cannot be \*(L"foo\*(R"\-\-and itz not, itz a \*(L"bar\*(R", so \*(L"foobar\*(R" will
match.  Use look-behind instead (see below).
.ie n .IP """(?<=pattern)"" ""\eK""" 4
.el .IP "\f(CW(?<=pattern)\fR \f(CW\eK\fR" 4
.IX Xref "(?<=) look-behind, positizzle lookbehind, positizzle \\K"
.IX Item "(?<=pattern) K"
A zero-width positizzle look-behind assertion. I aint talkin' bout chicken n' gravy biatch.  For example, \f(CW\*(C`/(?<=\et)\ew+/\*(C'\fR
matches a word dat bigs up a tab, without includin tha tab up in \f(CW$&\fR.
Works only fo' fixed-width look-behind.
.Sp
There be a special form of dis construct, called \f(CW\*(C`\eK\*(C'\fR, which causes the
regex engine ta \*(L"keep\*(R" every last muthafuckin thang it had matched prior ta tha \f(CW\*(C`\eK\*(C'\fR and
not include it up in \f(CW$&\fR. This effectively serves up variable-length
look-behind. Y'all KNOW dat shit, muthafucka! Da use of \f(CW\*(C`\eK\*(C'\fR inside of another look-around assertion
is allowed yo, but tha behaviour is currently not well defined.
.Sp
For various reasons \f(CW\*(C`\eK\*(C'\fR may be hella mo' efficient than the
equivalent \f(CW\*(C`(?<=...)\*(C'\fR construct, n' it is especially useful in
situations where you wanna efficiently remove suttin' following
suttin' else up in a string. For instance
.Sp
.Vb 1
\&  s/(foo)bar/$1/g;
.Ve
.Sp
can be rewritten as tha much mo' efficient
.Sp
.Vb 1
\&  s/foo\eKbar//g;
.Ve
.ie n .IP """(?<!pattern)""" 4
.el .IP "\f(CW(?<!pattern)\fR" 4
.IX Xref "(?<!) look-behind, wack lookbehind, negative"
.IX Item "(?<!pattern)"
A zero-width wack look-behind assertion. I aint talkin' bout chicken n' gravy biatch.  For example \f(CW\*(C`/(?<!bar)foo/\*(C'\fR
matches any occurrence of \*(L"foo\*(R" dat do not follow \*(L"bar\*(R".  Works
only fo' fixed-width look-behind.
.RE
.RS 4
.RE
.ie n .IP """(?\*(AqNAME\*(Aqpattern)""" 4
.el .IP "\f(CW(?\*(AqNAME\*(Aqpattern)\fR" 4
.IX Item "(?NAMEpattern)"
.PD 0
.ie n .IP """(?<NAME>pattern)""" 4
.el .IP "\f(CW(?<NAME>pattern)\fR" 4
.IX Xref "(?<NAME>) (?'NAME') named capture capture"
.IX Item "(?<NAME>pattern)"
.PD
A named capture group. Identical up in every last muthafuckin respect ta aiiight capturing
parentheses \f(CW\*(C`()\*(C'\fR but fo' tha additionizzle fact dat tha group
can be referred ta by name up in various regular expression
constructs (like \f(CW\*(C`\eg{NAME}\*(C'\fR) n' can be accessed by name
afta a successful match via \f(CW\*(C`%+\*(C'\fR or \f(CW\*(C`%\-\*(C'\fR. Right back up in yo muthafuckin ass. See perlvar
for mo' details on tha \f(CW\*(C`%+\*(C'\fR n' \f(CW\*(C`%\-\*(C'\fR hashes.
.Sp
If multiple distinct capture crews have tha same name then the
$+{\s-1NAME\s0} will refer ta tha leftmost defined crew up in tha match.
.Sp
Da forms \f(CW\*(C`(?\*(AqNAME\*(Aqpattern)\*(C'\fR n' \f(CW\*(C`(?<NAME>pattern)\*(C'\fR is equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR While tha notation of dis construct is tha same ol' dirty as tha similar
function up in .NET regexes, tha behavior is not. In Perl tha crews are
numbered sequentially regardless of bein named or not. Thus up in the
pattern
.Sp
.Vb 1
\&  /(x)(?<foo>y)(z)/
.Ve
.Sp
$+{foo} is ghon be tha same as \f(CW$2\fR, n' \f(CW$3\fR will contain 'z' instead of
the opposite which is what tha fuck a .NET regex hacker might expect.
.Sp
Currently \s-1NAME\s0 is restricted ta simple identifiers only.
In other lyrics, it must match \f(CW\*(C`/^[_A\-Za\-z][_A\-Za\-z0\-9]*\ez/\*(C'\fR or
its Unicode extension (see utf8),
though it aint extended by tha locale (see perllocale).
.Sp
\&\fB\s-1NOTE:\s0\fR In order ta make thangs easier fo' programmers wit experience
with tha Python or \s-1PCRE\s0 regex engines, tha pattern \f(CW\*(C`(?P<NAME>pattern)\*(C'\fR
may be used instead of \f(CW\*(C`(?<NAME>pattern)\*(C'\fR; however dis form do not
support tha use of single quotes as a thugged-out delimita fo' tha name.
.ie n .IP """\ek<NAME>""" 4
.el .IP "\f(CW\ek<NAME>\fR" 4
.IX Item "k<NAME>"
.PD 0
.ie n .IP """\ek\*(AqNAME\*(Aq""" 4
.el .IP "\f(CW\ek\*(AqNAME\*(Aq\fR" 4
.IX Item "kNAME"
.PD
Named backreference. Right back up in yo muthafuckin ass. Similar ta numeric backreferences, except that
the crew is designated by name n' not number n' shit. If multiple groups
have tha same name then it refers ta tha leftmost defined crew in
the current match.
.Sp
It be a error ta refer ta a name not defined by a \f(CW\*(C`(?<NAME>)\*(C'\fR
earlier up in tha pattern.
.Sp
Both forms is equivalent.
.Sp
\&\fB\s-1NOTE:\s0\fR In order ta make thangs easier fo' programmers wit experience
with tha Python or \s-1PCRE\s0 regex engines, tha pattern \f(CW\*(C`(?P=NAME)\*(C'\fR
may be used instead of \f(CW\*(C`\ek<NAME>\*(C'\fR.
.ie n .IP """(?{ code })""" 4
.el .IP "\f(CW(?{ code })\fR" 4
.IX Xref "(?{}) regex, code up in regexp, code up in regular expression, code in"
.IX Item "(?{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, n' may be chizzled without notice. Code executed that
has side effects may not big-ass up identically from version ta version
due ta tha effect of future optimisations up in tha regex engine. The
implementation of dis feature was radically overhauled fo' tha 5.18.0
release, n' its behaviour up in earlier versionz of perl was much buggier,
especially up in relation ta parsing, lexical vars, scoping, recursion and
reentrancy.
.Sp
This zero-width assertion executes any embedded Perl code.  It always
succeeds, n' its return value is set as \f(CW$^R\fR.
.Sp
In literal patterns, tha code is parsed all up in tha same time as the
surroundin code. While within tha pattern, control is passed temporarily
back ta tha perl parser, until tha logically-balancin closin brace is
encountered. Y'all KNOW dat shit, muthafucka! This is similar ta tha way dat a array index expression in
a literal strang is handled, fo' example
.Sp
.Vb 1
\&    "abc$array[ 1 + f(\*(Aq[\*(Aq) + g()]def"
.Ve
.Sp
In particular, braces do not need ta be balanced:
.Sp
.Vb 1
\&    s/abc(?{ f(\*(Aq{\*(Aq); })/def/
.Ve
.Sp
Even up in a pattern dat is interpolated n' compiled at run-time, literal
code blocks is ghon be compiled once, at perl compile time; tha following
prints \*(L"\s-1ABCD\*(R":\s0
.Sp
.Vb 5
\&    print "D";
\&    mah $qr = qr/(?{ BEGIN { print "A" } })/;
\&    mah $foo = "foo";
\&    /$foo$qr(?{ BEGIN { print "B" } })/;
\&    BEGIN { print "C" }
.Ve
.Sp
In patterns where tha text of tha code is derived from run-time
information rather than appearin literally up in a source code /pattern/,
the code is compiled all up in tha same time dat tha pattern is compiled, and
for reasonz of security, \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR must be up in scope. This is to
stop user-supplied patterns containin code snippets from being
executable.
.Sp
In thangs where you need ta enable dis wit \f(CW\*(C`use re \*(Aqeval\*(Aq\*(C'\fR, you should
also have taint checkin enabled. Y'all KNOW dat shit, muthafucka!  Betta yet, use tha carefully
constrained evaluation within a Safe compartment.  See perlsec for
details bout both these mechanisms.
.Sp
From tha viewpoint of parsing, lexical variable scope n' closures,
.Sp
.Vb 1
\&    /AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    /AAA/ && do { BBB } && /CCC/
.Ve
.Sp
Similarly,
.Sp
.Vb 1
\&    qr/AAA(?{ BBB })CCC/
.Ve
.Sp
behaves approximately like
.Sp
.Vb 1
\&    sub { /AAA/ && do { BBB } && /CCC/ }
.Ve
.Sp
In particular:
.Sp
.Vb 3
\&    { mah $i = 1; $r = qr/(?{ print $i })/ }
\&    mah $i = 2;
\&    /$r/; # prints "1"
.Ve
.Sp
Inside a \f(CW\*(C`(?{...})\*(C'\fR block, \f(CW$_\fR refers ta tha strang tha regular
expression is matchin against. Yo ass can also use \f(CW\*(C`pos()\*(C'\fR ta know what tha fuck is
the current posizzle of matchin within dis string.
.Sp
Da code block introduces a freshly smoked up scope from tha perspectizzle of lexical
variable declarations yo, but \fBnot\fR from tha perspectizzle of \f(CW\*(C`local\*(C'\fR and
similar localizin behaviours. Right back up in yo muthafuckin ass. So lata code blocks within tha same
pattern will still peep tha joints which was localized up in earlier blocks.
These accumulated localizations is undone either all up in tha end of a
successful match, or if tha assertion is backtracked (compare
\&\*(L"Backtracking\*(R"). For example,
.Sp
.Vb 10
\&  $_ = \*(Aqa\*(Aq x 8;
\&  m<
\&     (?{ $cnt = 0 })               # Initialize $cnt.
\&     (
\&       a
\&       (?{
\&           local $cnt = $cnt + 1;  # Update $cnt,
\&                                   # backtracking\-safe.
\&       })
\&     )*
\&     aaaa
\&     (?{ $res = $cnt })            # On success copy to
\&                                   # non\-localized location.
\&   >x;
.Ve
.Sp
will initially increment \f(CW$cnt\fR up ta 8; then durin backtracking, its
value is ghon be unwound back ta 4, which is tha value assigned ta \f(CW$res\fR.
At tha end of tha regex execution, \f(CW$cnt\fR is ghon be wound back ta its initial
value of 0.
.Sp
This assertion may be used as tha condizzle up in a
.Sp
.Vb 1
\&    (?(condition)yes\-pattern|no\-pattern)
.Ve
.Sp
switch.  If \fInot\fR used up in dis way, tha result of evaluation of \f(CW\*(C`code\*(C'\fR
is put tha fuck into tha special variable \f(CW$^R\fR.  This happens immediately, so
\&\f(CW$^R\fR can be used from other \f(CW\*(C`(?{ code })\*(C'\fR assertions inside tha same
regular expression.
.Sp
Da assignment ta \f(CW$^R\fR above is properly localized, so tha old
value of \f(CW$^R\fR is restored if tha assertion is backtracked; compare
\&\*(L"Backtracking\*(R".
.Sp
Note dat tha special variable \f(CW$^N\fR  is particularly useful wit code
blocks ta capture tha thangs up in dis biatch of submatches up in variablez without havin to
keep track of tha number of nested parentheses. For example:
.Sp
.Vb 3
\&  $_ = "Da brown fox jumps over tha lazy dog";
\&  /the (\eS+)(?{ $color = $^N }) (\eS+)(?{ $animal = $^N })/i;
\&  print "color = $color, animal = $animal\en";
.Ve
.ie n .IP """(??{ code })""" 4
.el .IP "\f(CW(??{ code })\fR" 4
.IX Xref "(??{}) regex, postponed regexp, postponed regular expression, postponed"
.IX Item "(??{ code })"
\&\fB\s-1WARNING\s0\fR: This extended regular expression feature is considered
experimental, n' may be chizzled without notice. Code executed that
has side effects may not big-ass up identically from version ta version
due ta tha effect of future optimisations up in tha regex engine.
.Sp
This be a \*(L"postponed\*(R" regular subexpression. I aint talkin' bout chicken n' gravy biatch.  It behaves up in \fIexactly\fR the
same way as a \f(CW\*(C`(?{ code })\*(C'\fR code block as busted lyrics bout above, except that
its return value, rather than bein assigned ta \f(CW$^R\fR, is treated as a
pattern, compiled if itz a strang (or used as-is if its a qr// object),
then matched as if it was banged instead of dis construct.
.Sp
Durin tha matchin of dis sub-pattern, it has its own set of
captures which is valid durin tha sub-match yo, but is discarded once
control returns ta tha main pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. For example, tha followin matches,
with tha inner pattern capturin \*(L"B\*(R" n' matchin \*(L"\s-1BB\*(R",\s0 while tha outer
pattern captures \*(L"A\*(R";
.Sp
.Vb 3
\&    mah $inner = \*(Aq(.)\e1\*(Aq;
\&    "ABBA" =~ /^(.)(??{ $inner })\e1/;
\&    print $1; # prints "A";
.Ve
.Sp
Note dat dis means dat  there is no way fo' tha inner pattern ta refer
to a cold-ass lil capture crew defined outside.  (Da code block itself can use \f(CW$1\fR,
etc., ta refer ta tha enclosin patternz capture groups.)  Thus, although
.Sp
.Vb 1
\&    (\*(Aqa\*(Aq x 100)=~/(??{\*(Aq(.)\*(Aq x 100})/
.Ve
.Sp
\&\fIwill\fR match, it will \fInot\fR set \f(CW$1\fR on exit.
.Sp
Da followin pattern matches a parenthesized group:
.Sp
.Vb 9
\& $re = qr{
\&            \e(
\&            (?:
\&               (?> [^()]+ )  # Non\-parens without backtracking
\&             |
\&               (??{ $re })   # Group wit matchin parens
\&            )*
\&            \e)
\&         }x;
.Ve
.Sp
See also
\&\f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR
for a gangbangin' finger-lickin' different, mo' efficient way ta accomplish
the same task.
.Sp
Executin a postponed regular expression 50 times without consumin any
input strang will result up in a gangbangin' fatal error. Shiiit, dis aint no joke.  Da maximum depth is compiled
into perl, so changin it requires a cold-ass lil custom build.
.ie n .IP """(?\f(CIPARNO\f(CW)"" ""(?\-\f(CIPARNO\f(CW)"" ""(?+\f(CIPARNO\f(CW)"" ""(?R)"" ""(?0)""" 4
.el .IP "\f(CW(?\f(CIPARNO\f(CW)\fR \f(CW(?\-\f(CIPARNO\f(CW)\fR \f(CW(?+\f(CIPARNO\f(CW)\fR \f(CW(?R)\fR \f(CW(?0)\fR" 4
.IX Xref "(?PARNO) (?1) (?R) (?0) (?-1) (?+1) (?-PARNO) (?+PARNO) regex, recursive regexp, recursive regular expression, recursive regex, relatizzle recursion"
.IX Item "(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)"
Similar ta \f(CW\*(C`(??{ code })\*(C'\fR except dat it do not involve executin any
code or potentially compilin a returned pattern string; instead it treats
the part of tha current pattern contained within a specified capture group
as a independent pattern dat must match all up in tha current position.
Capture crews contained by tha pattern gonna git tha value as determined
by tha outermost recursion.
.Sp
\&\fI\s-1PARNO\s0\fR be a sequence of digits (not startin wit 0) whose value reflects
the paren-number of tha capture crew ta recurse to. \f(CW\*(C`(?R)\*(C'\fR recurses to
the beginnin of tha whole pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. \f(CW\*(C`(?0)\*(C'\fR be a alternate syntax for
\&\f(CW\*(C`(?R)\*(C'\fR. If \fI\s-1PARNO\s0\fR is preceded by a plus or minus sign then it be assumed
to be relative, wit wack numbers indicatin precedin capture groups
and positizzle ones following. Thus \f(CW\*(C`(?\-1)\*(C'\fR refers ta da most thugged-out recently
declared group, n' \f(CW\*(C`(?+1)\*(C'\fR indicates tha next crew ta be declared.
Note dat tha countin fo' relatizzle recursion differs from dat of
relatizzle backreferences, up in dat wit recursion unclosed crews \fBare\fR
included.
.Sp
Da followin pattern matches a gangbangin' function \fIfoo()\fR which may contain
balanced parentheses as tha argument.
.Sp
.Vb 10
\&  $re = qr{ (                   # paren crew 1 (full function)
\&              foo
\&              (                 # paren crew 2 (parens)
\&                \e(
\&                  (             # paren crew 3 (contentz of parens)
\&                  (?:
\&                   (?> [^()]+ ) # Non\-parens without backtracking
\&                  |
\&                   (?2)         # Recurse ta start of paren crew 2
\&                  )*
\&                  )
\&                \e)
\&              )
\&            )
\&          }x;
.Ve
.Sp
If tha pattern was used as bigs up
.Sp
.Vb 4
\&    \*(Aqfoo(bar(baz)+baz(bop))\*(Aq=~/$re/
\&        n' print "\e$1 = $1\en",
\&                  "\e$2 = $2\en",
\&                  "\e$3 = $3\en";
.Ve
.Sp
the output produced should be tha following:
.Sp
.Vb 3
\&    $1 = foo(bar(baz)+baz(bop))
\&    $2 = (bar(baz)+baz(bop))
\&    $3 = bar(baz)+baz(bop)
.Ve
.Sp
If there is no correspondin capture crew defined, then it be a
fatal error. Shiiit, dis aint no joke.  Recursin deeper than 50 times without consumin any input
strin will also result up in a gangbangin' fatal error. Shiiit, dis aint no joke.  Da maximum depth is compiled
into perl, so changin it requires a cold-ass lil custom build.
.Sp
Da followin shows how tha fuck rockin wack indexin can make it
easier ta embed recursive patterns inside of a \f(CW\*(C`qr//\*(C'\fR construct
for lata use:
.Sp
.Vb 4
\&    mah $parens = qr/(\e((?:[^()]++|(?\-1))*+\e))/;
\&    if (/foo $parens \es+ \e+ \es+ bar $parens/x) {
\&       # do suttin' here...
\&    }
.Ve
.Sp
\&\fBNote\fR dat dis pattern do not behave tha same way as tha equivalent
\&\s-1PCRE\s0 or Python construct of tha same form. In Perl you can backtrack into
a recursed group, up in \s-1PCRE\s0 n' Python tha recursed tha fuck into crew is treated
as atomic fo' realz. Also, modifiers is resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how tha fuck tha sub-pattern will
be processed.
.ie n .IP """(?&NAME)""" 4
.el .IP "\f(CW(?&NAME)\fR" 4
.IX Xref "(?&NAME)"
.IX Item "(?&NAME)"
Recurse ta a named subpattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Identical ta \f(CW\*(C`(?\f(CIPARNO\f(CW)\*(C'\fR except dat the
parenthesis ta recurse ta is determined by name. If multiple parentheses have
the same name, then it recurses ta tha leftmost.
.Sp
It be a error ta refer ta a name dat aint declared somewhere up in the
pattern.
.Sp
\&\fB\s-1NOTE:\s0\fR In order ta make thangs easier fo' programmers wit experience
with tha Python or \s-1PCRE\s0 regex engines tha pattern \f(CW\*(C`(?P>NAME)\*(C'\fR
may be used instead of \f(CW\*(C`(?&NAME)\*(C'\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Xref "(?()"
.IX Item "(?(condition)yes-pattern|no-pattern)"
.PD 0
.ie n .IP """(?(condition)yes\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern)"
.PD
Conditionizzle expression. I aint talkin' bout chicken n' gravy biatch. Matches \f(CW\*(C`yes\-pattern\*(C'\fR if \f(CW\*(C`condition\*(C'\fR yields
a legit value, matches \f(CW\*(C`no\-pattern\*(C'\fR otherwise fo' realz. A missin pattern always
matches.
.Sp
\&\f(CW\*(C`(condition)\*(C'\fR should be one of: 1) a integer in
parentheses (which is valid if tha correspondin pair of parentheses
matched); 2) a look\-ahead/look\-behind/evaluate zero-width assertion; 3) a
name up in angle brackets or single quotes (which is valid if a group
with tha given name matched); or 4) tha special symbol (R) (true when
evaluated inside of recursion or eval) fo' realz. Additionally tha R may be
followed by a number, (which is ghon be legit when evaluated when recursing
inside of tha appropriate group), or by \f(CW&NAME\fR, up in which case it will
be legit only when evaluated durin recursion up in tha named group.
.Sp
Herez a summary of tha possible predicates:
.RS 4
.IP "(1) (2) ..." 4
.IX Item "(1) (2) ..."
Checks if tha numbered capturin crew has matched something.
.IP "(<\s-1NAME\s0>) ('\s-1NAME\s0')" 4
.IX Item "(<NAME>) ('NAME')"
Checks if a crew wit tha given name has matched something.
.IP "(?=...) (?!...) (?<=...) (?<!...)" 4
Checks whether tha pattern matches (or do not match, fo' tha '!'
variants).
.IP "(?{ \s-1CODE \s0})" 4
.IX Item "(?{ CODE })"
Treats tha return value of tha code block as tha condition.
.IP "(R)" 4
.IX Item "(R)"
Checks if tha expression has been evaluated inside of recursion.
.IP "(R1) (R2) ..." 4
.IX Item "(R1) (R2) ..."
Checks if tha expression has been evaluated while executin directly
inside of tha n\-th capture group. This check is tha regex equivalent of
.Sp
.Vb 1
\&  if ((caller(0))[3] eq \*(Aqsubname\*(Aq) { ... }
.Ve
.Sp
In other lyrics, it do not check tha full recursion stack.
.IP "(R&NAME)" 4
.IX Item "(R&NAME)"
Similar ta \f(CW\*(C`(R1)\*(C'\fR, dis predicate checks ta peep if we executing
directly inside of tha leftmost crew wit a given name (this is tha same
logic used by \f(CW\*(C`(?&NAME)\*(C'\fR ta disambiguate). Well shiiiit, it do not check tha full
stack yo, but only tha name of tha innermost actizzle recursion.
.IP "(\s-1DEFINE\s0)" 4
.IX Item "(DEFINE)"
In dis case, tha yes-pattern is never directly executed, n' no
no-pattern be allowed. Y'all KNOW dat shit, muthafucka! Similar up in spirit ta \f(CW\*(C`(?{0})\*(C'\fR but mo' efficient.
See below fo' details.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 4
\&    m{ ( \e( )?
\&       [^()]+
\&       (?(1) \e) )
\&     }x
.Ve
.Sp
matches a cold-ass lil chunk of non-parentheses, possibly included up in parentheses
themselves.
.Sp
A special form is tha \f(CW\*(C`(DEFINE)\*(C'\fR predicate, which never executes its
yes-pattern directly, n' do not allow a no-pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This allows one to
define subpatterns which is ghon be executed only by tha recursion mechanism.
This way, you can define a set of regular expression rulez dat can be
bundled tha fuck into any pattern you chizzle.
.Sp
It be recommended dat fo' dis usage you put tha \s-1DEFINE\s0 block at the
end of tha pattern, n' dat you name any subpatterns defined within dat shit.
.Sp
Also, itz worth notin dat patterns defined dis way probably will
not be as efficient, as tha optimiser aint straight-up smart-ass about
handlin em.
.Sp
An example of how tha fuck dis might be used be as bigs up:
.Sp
.Vb 5
\&  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
\&   (?(DEFINE)
\&     (?<NAME_PAT>....)
\&     (?<ADRESS_PAT>....)
\&   )/x
.Ve
.Sp
Note dat capture crews matched inside of recursion is not accessible
afta tha recursion returns, so tha extra layer of capturin crews is
necessary. Thus \f(CW$+{NAME_PAT}\fR would not be defined even though
\&\f(CW$+{NAME}\fR would be.
.Sp
Finally, keep up in mind dat subpatterns pimped inside a \s-1DEFINE\s0 block
count towardz tha absolute n' relatizzle number of captures, so this:
.Sp
.Vb 5
\&    mah @captures = "a" =~ /(.)                  # First capture
\&                           (?(DEFINE)
\&                               (?<EXAMPLE> 1 )  # Second capture
\&                           )/x;
\&    say scalar @captures;
.Ve
.Sp
Will output 2, not 1. This is particularly blingin if you intend to
compile tha definitions wit tha \f(CW\*(C`qr//\*(C'\fR operator, n' later
interpolate dem up in another pattern.
.RE
.ie n .IP """(?>pattern)""" 4
.el .IP "\f(CW(?>pattern)\fR" 4
.IX Xref "backtrack backtrackin atomic possessive"
.IX Item "(?>pattern)"
An \*(L"independent\*(R" subexpression, one which matches tha substring
that a \fIstandalone\fR \f(CW\*(C`pattern\*(C'\fR would match if anchored all up in tha given
position, n' it matches \fInothang other than dis substring\fR.  This
construct is useful fo' optimizationz of what tha fuck would otherwise be
\&\*(L"eternal\*(R" matches, cuz it aint gonna backtrack (see \*(L"Backtracking\*(R").
It may also be useful up in places where tha \*(L"grab all you can, n' do not
give anythang back\*(R" semantic is desirable.
.Sp
For example: \f(CW\*(C`^(?>a*)ab\*(C'\fR aint NEVER gonna match, since \f(CW\*(C`(?>a*)\*(C'\fR
(anchored all up in tha beginnin of string, as above) will match \fIall\fR
charactas \f(CW\*(C`a\*(C'\fR all up in tha beginnin of string, leavin no \f(CW\*(C`a\*(C'\fR for
\&\f(CW\*(C`ab\*(C'\fR ta match.  In contrast, \f(CW\*(C`a*ab\*(C'\fR will match tha same as \f(CW\*(C`a+b\*(C'\fR,
since tha match of tha subgroup \f(CW\*(C`a*\*(C'\fR is hyped up by tha following
group \f(CW\*(C`ab\*(C'\fR (see \*(L"Backtracking\*(R").  In particular, \f(CW\*(C`a*\*(C'\fR inside
\&\f(CW\*(C`a*ab\*(C'\fR will match fewer charactas than a standalone \f(CW\*(C`a*\*(C'\fR, since
this make tha tail match.
.Sp
\&\f(CW\*(C`(?>pattern)\*(C'\fR do not disable backtrackin altogether once it has
matched. Y'all KNOW dat shit, muthafucka! Well shiiiit, it is still possible ta backtrack past tha construct yo, but not
into dat shit. Right back up in yo muthafuckin ass. So \f(CW\*(C`((?>a*)|(?>b*))ar\*(C'\fR will still match \*(L"bar\*(R".
.Sp
An effect similar ta \f(CW\*(C`(?>pattern)\*(C'\fR may be  bigged up  by writing
\&\f(CW\*(C`(?=(pattern))\eg{\-1}\*(C'\fR.  This matches tha same ol' dirty substrin as a standalone
\&\f(CW\*(C`a+\*(C'\fR, n' tha followin \f(CW\*(C`\eg{\-1}\*(C'\fR smokes tha matched string; it therefore
makes a zero-length assertion tha fuck into a analogue of \f(CW\*(C`(?>...)\*(C'\fR.
(Da difference between these two constructs is dat tha second one
uses a cold-ass lil capturin group, thus shiftin ordinalz of backreferences
in tha rest of a regular expression.)
.Sp
Consider dis pattern:
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            [^()]+           # x+
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
That will efficiently match a nonempty crew wit matchin parentheses
two levels deep or less.  But fuck dat shiznit yo, tha word on tha street is dat if there is no such group, it
will take virtually forever on a long-ass string.  Thatz cuz there
are all kindsa muthafuckin different ways ta split a long-ass strang tha fuck into several
substrings.  This is what tha fuck \f(CW\*(C`(.+)+\*(C'\fR is bustin, n' \f(CW\*(C`(.+)+\*(C'\fR is similar
to a subpattern of tha above pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Consider how tha fuck tha pattern
above detects no-match on \f(CW\*(C`((()aaaaaaaaaaaaaaaaaa\*(C'\fR up in several
secondz yo, but dat each extra letta doublez dis time.  This
exponential performizzle will make it step tha fuck up dat yo' program has
hung.  But fuck dat shiznit yo, tha word on tha street is dat a tiny chizzle ta dis pattern
.Sp
.Vb 8
\&    m{ \e(
\&          (
\&            (?> [^()]+ )        # chizzle x+ above ta (?> x+ )
\&          |
\&            \e( [^()]* \e)
\&          )+
\&       \e)
\&     }x
.Ve
.Sp
which uses \f(CW\*(C`(?>...)\*(C'\fR matches exactly when tha one above do (verifying
this yo ass would be a productizzle exercise) yo, but finishes up in a gangbangin' fourth
the time when used on a similar strang wit 1000000 \f(CW\*(C`a\*(C'\fRs.  Be aware,
however, that, when dis construct is followed by a
quantifier, it currently triggers a warnin message under
the \f(CW\*(C`use warnings\*(C'\fR pragma or \fB\-w\fR switch sayin it
\&\f(CW"matches null strang nuff times up in regex"\fR.
.Sp
On simple groups, like fuckin tha pattern \f(CW\*(C`(?> [^()]+ )\*(C'\fR, a cold-ass lil comparable
effect may be  bigged up  by wack look-ahead, as up in \f(CW\*(C`[^()]+ (?! [^()] )\*(C'\fR.
This was only 4 times slower on a strang wit 1000000 \f(CW\*(C`a\*(C'\fRs.
.Sp
Da \*(L"grab all you can, n' do not give anythang back\*(R" semantic is desirable
in nuff thangs where on tha straight-up original gangsta sight a simple \f(CW\*(C`()*\*(C'\fR looks like
the erect solution. I aint talkin' bout chicken n' gravy biatch.  Suppose we parse text wit comments bein delimited
by \f(CW\*(C`#\*(C'\fR followed by some optionizzle (horizontal) whitespace.  Contrary to
its appearance, \f(CW\*(C`#[ \et]*\*(C'\fR \fIis not\fR tha erect subexpression ta match
the comment delimiter, cuz it may \*(L"give up\*(R" some whitespace if
the remainder of tha pattern can be made ta match dat way.  Da erect
answer is either one of these:
.Sp
.Vb 2
\&    (?>#[ \et]*)
\&    #[ \et]*(?![ \et])
.Ve
.Sp
For example, ta grab non-empty comments tha fuck into \f(CW$1\fR, one should use either
one of these:
.Sp
.Vb 2
\&    / (?> \e# [ \et]* ) (        .+ ) /x;
\&    /     \e# [ \et]*   ( [^ \et] .* ) /x;
.Ve
.Sp
Which one you pick dependz on which of these expressions betta reflects
the above justification of comments.
.Sp
In some literature dis construct is called \*(L"atomic matching\*(R" or
\&\*(L"possessive matching\*(R".
.Sp
Possessive quantifiers is equivalent ta puttin tha item they is applied
to inside of one of these constructs, n' you can put dat on yo' toast. Da followin equivalences apply:
.Sp
.Vb 6
\&    Quantifier Form     Bracketin Form
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    PAT*+               (?>PAT*)
\&    PAT++               (?>PAT+)
\&    PAT?+               (?>PAT?)
\&    PAT{min,max}+       (?>PAT{min,max})
.Ve
.ie n .IP """(?[ ])""" 4
.el .IP "\f(CW(?[ ])\fR" 4
.IX Item "(?[ ])"
See \*(L"Extended Bracketed Characta Classes\*(R" up in perlrecharclass.
.SS "Special Backtrackin Control Verbs"
.IX Subsection "Special Backtrackin Control Verbs"
\&\fB\s-1WARNING:\s0\fR These patterns is experimenstrual n' subject ta chizzle or
removal up in a gangbangin' future version of Perl. Their usage up in thang code should
be noted ta avoid problems durin upgrades.
.PP
These special patterns is generally of tha form \f(CW\*(C`(*VERB:ARG)\*(C'\fR. Unless
otherwise stated tha \s-1ARG\s0 argument is optional; up in some cases, it is
forbidden.
.PP
Any pattern containin a special backtrackin verb dat allows a argument
has tha special behaviour dat when executed it sets tha current package's
\&\f(CW$REGERROR\fR n' \f(CW$REGMARK\fR variables. When bustin so tha following
rulez apply:
.PP
On failure, tha \f(CW$REGERROR\fR variable is ghon be set ta tha \s-1ARG\s0 value of the
verb pattern, if tha verb was involved up in tha failure of tha match. If the
\&\s-1ARG\s0 part of tha pattern was omitted, then \f(CW$REGERROR\fR is ghon be set ta the
name of tha last \f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed, or ta \s-1TRUE\s0 if there was
none fo' realz. Also, tha \f(CW$REGMARK\fR variable is ghon be set ta \s-1FALSE.\s0
.PP
On a successful match, tha \f(CW$REGERROR\fR variable is ghon be set ta \s-1FALSE,\s0 and
the \f(CW$REGMARK\fR variable is ghon be set ta tha name of tha last
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR pattern executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  See tha explanation fo' the
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR verb below fo' mo' details.
.PP
\&\fB\s-1NOTE:\s0\fR \f(CW$REGERROR\fR n' \f(CW$REGMARK\fR is not magic variablez like \f(CW$1\fR
and most other regex-related variables. They is not local ta a scope, nor
readonly yo, but instead is volatile package variablez similar ta \f(CW$AUTOLOAD\fR.
Use \f(CW\*(C`local\*(C'\fR ta localize chizzlez ta dem ta a specific scope if necessary.
.PP
If a pattern do not contain a special backtrackin verb dat allows an
argument, then \f(CW$REGERROR\fR n' \f(CW$REGMARK\fR is not touched at all.
.IP "Verbs dat take a argument" 3
.IX Item "Verbs dat take a argument"
.RS 3
.PD 0
.ie n .IP """(*PRUNE)"" ""(*PRUNE:NAME)""" 4
.el .IP "\f(CW(*PRUNE)\fR \f(CW(*PRUNE:NAME)\fR" 4
.IX Xref "(*PRUNE) (*PRUNE:NAME)"
.IX Item "(*PRUNE) (*PRUNE:NAME)"
.PD
This zero-width pattern prunes tha backtrackin tree all up in tha current point
when backtracked tha fuck into on failure. Consider tha pattern \f(CW\*(C`A (*PRUNE) B\*(C'\fR,
where A n' B is complex patterns. Until tha \f(CW\*(C`(*PRUNE)\*(C'\fR verb is reached,
A may backtrack as necessary ta match. Once it is reached, matching
continues up in B, which may also backtrack as necessary; however, should B
not match, then no further backtrackin will take place, n' tha pattern
will fail outright all up in tha current startin position.
.Sp
Da followin example counts all tha possible matchin strings up in a
pattern (without straight-up matchin any of them).
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
which produces:
.Sp
.Vb 10
\&    aaab
\&    aaa
\&    aa
\&    a
\&    aab
\&    aa
\&    a
\&    ab
\&    a
\&    Count=9
.Ve
.Sp
If we add a \f(CW\*(C`(*PRUNE)\*(C'\fR before tha count like tha following
.Sp
.Vb 2
\&    \*(Aqaaab\*(Aq =~ /a+b?(*PRUNE)(?{print "$&\en"; $count++})(*FAIL)/;
\&    print "Count=$count\en";
.Ve
.Sp
we prevent backtrackin n' find tha count of tha longest matchin string
at each matchin startin point like so:
.Sp
.Vb 4
\&    aaab
\&    aab
\&    ab
\&    Count=3
.Ve
.Sp
Any number of \f(CW\*(C`(*PRUNE)\*(C'\fR assertions may be used up in a pattern.
.Sp
See also \f(CW\*(C`(?>pattern)\*(C'\fR n' possessive quantifiers fo' other ways to
control backtracking. In some cases, tha use of \f(CW\*(C`(*PRUNE)\*(C'\fR can be
replaced wit a \f(CW\*(C`(?>pattern)\*(C'\fR wit no functionizzle difference; however,
\&\f(CW\*(C`(*PRUNE)\*(C'\fR can be used ta handle cases dat cannot be expressed rockin a
\&\f(CW\*(C`(?>pattern)\*(C'\fR ridin' solo.
.ie n .IP """(*SKIP)"" ""(*SKIP:NAME)""" 4
.el .IP "\f(CW(*SKIP)\fR \f(CW(*SKIP:NAME)\fR" 4
.IX Xref "(*SKIP)"
.IX Item "(*SKIP) (*SKIP:NAME)"
This zero-width pattern is similar ta \f(CW\*(C`(*PRUNE)\*(C'\fR, except dat on
failure it also signifies dat whatever text dat was matched leadin up
to tha \f(CW\*(C`(*SKIP)\*(C'\fR pattern bein executed cannot be part of \fIany\fR match
of dis pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. This effectively means dat tha regex engine \*(L"skips\*(R" forward
to dis posizzle on failure n' tries ta match again, (assumin that
there is sufficient room ta match).
.Sp
Da name of tha \f(CW\*(C`(*SKIP:NAME)\*(C'\fR pattern has special significance. If a
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR was encountered while matching, then it is dat position
which is used as tha \*(L"skip point\*(R". If no \f(CW\*(C`(*MARK)\*(C'\fR of dat name was
encountered, then tha \f(CW\*(C`(*SKIP)\*(C'\fR operator has no effect. When used
without a name tha \*(L"skip point\*(R" is where tha match point was when
executin tha (*SKIP) pattern.
.Sp
Compare tha followin ta tha examplez up in \f(CW\*(C`(*PRUNE)\*(C'\fR; note tha string
is twice as long:
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*SKIP)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 3
\&    aaab
\&    aaab
\&    Count=2
.Ve
.Sp
Once tha 'aaab' all up in tha start of tha strang has matched, n' tha \f(CW\*(C`(*SKIP)\*(C'\fR
executed, tha next startin point is ghon be where tha cursor was when the
\&\f(CW\*(C`(*SKIP)\*(C'\fR was executed.
.ie n .IP """(*MARK:NAME)"" ""(*:NAME)""" 4
.el .IP "\f(CW(*MARK:NAME)\fR \f(CW(*:NAME)\fR" 4
.IX Xref "(*MARK) (*MARK:NAME) (*:NAME)"
.IX Item "(*MARK:NAME) (*:NAME)"
This zero-width pattern can be used ta mark tha point reached up in a string
when a cold-ass lil certain part of tha pattern has been successfully matched. Y'all KNOW dat shit, muthafucka! This
mark may be given a name fo' realz. A lata \f(CW\*(C`(*SKIP)\*(C'\fR pattern will then skip
forward ta dat point if backtracked tha fuck into on failure fo' realz. Any number of
\&\f(CW\*(C`(*MARK)\*(C'\fR patterns is allowed, n' tha \s-1NAME\s0 portion may be duplicated.
.Sp
In addizzle ta interactin wit tha \f(CW\*(C`(*SKIP)\*(C'\fR pattern, \f(CW\*(C`(*MARK:NAME)\*(C'\fR
can be used ta \*(L"label\*(R" a pattern branch, so dat afta matching, the
program can determine which branchez of tha pattern was involved up in the
match.
.Sp
When a match is successful, tha \f(CW$REGMARK\fR variable is ghon be set ta the
name of da most thugged-out recently executed \f(CW\*(C`(*MARK:NAME)\*(C'\fR dat was involved
in tha match.
.Sp
This can be used ta determine which branch of a pattern was matched
without rockin a separate capture crew fo' each branch, which up in turn
can result up in a performizzle improvement, as perl cannot optimize
\&\f(CW\*(C`/(?:(x)|(y)|(z))/\*(C'\fR as efficiently as suttin' like
\&\f(CW\*(C`/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/\*(C'\fR.
.Sp
When a match has failed, n' unless another verb has been involved in
failin tha match n' has provided its own name ta use, tha \f(CW$REGERROR\fR
variable is ghon be set ta tha name of da most thugged-out recently executed
\&\f(CW\*(C`(*MARK:NAME)\*(C'\fR.
.Sp
See \*(L"(*SKIP)\*(R" fo' mo' details.
.Sp
As a gangbangin' finger-lickin' dirty-ass shortcut \f(CW\*(C`(*MARK:NAME)\*(C'\fR can be freestyled \f(CW\*(C`(*:NAME)\*(C'\fR.
.ie n .IP """(*THEN)"" ""(*THEN:NAME)""" 4
.el .IP "\f(CW(*THEN)\fR \f(CW(*THEN:NAME)\fR" 4
.IX Item "(*THEN) (*THEN:NAME)"
This is similar ta tha \*(L"cut group\*(R" operator \f(CW\*(C`::\*(C'\fR from Perl 6.  Like
\&\f(CW\*(C`(*PRUNE)\*(C'\fR, dis verb always matches, n' when backtracked tha fuck into on
failure, it causes tha regex engine ta try tha next alternation up in the
innermost enclosin crew (capturin or otherwise) dat has alternations.
Da two branchez of a \f(CW\*(C`(?(condition)yes\-pattern|no\-pattern)\*(C'\fR do not
count as a alternation, as far as \f(CW\*(C`(*THEN)\*(C'\fR is concerned.
.Sp
Its name be reppin tha observation dat dis operation combined wit the
alternation operator (\f(CW\*(C`|\*(C'\fR) can be used ta create what tha fuck is essentially a
pattern-based if/then/else block:
.Sp
.Vb 1
\&  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )
.Ve
.Sp
Note dat if dis operator is used n' \s-1NOT\s0 inside of a alternation then
it acts exactly like tha \f(CW\*(C`(*PRUNE)\*(C'\fR operator.
.Sp
.Vb 1
\&  / A (*PRUNE) B /
.Ve
.Sp
is tha same ol' dirty as
.Sp
.Vb 1
\&  / A (*THEN) B /
.Ve
.Sp
but
.Sp
.Vb 1
\&  / ( A (*THEN) B | C ) /
.Ve
.Sp
is not tha same as
.Sp
.Vb 1
\&  / ( A (*PRUNE) B | C ) /
.Ve
.Sp
as afta matchin tha A but failin on tha B tha \f(CW\*(C`(*THEN)\*(C'\fR verb will
backtrack n' try C; but tha \f(CW\*(C`(*PRUNE)\*(C'\fR verb will simply fail.
.RE
.RS 3
.RE
.IP "Verbs without a argument" 3
.IX Item "Verbs without a argument"
.RS 3
.PD 0
.ie n .IP """(*COMMIT)""" 4
.el .IP "\f(CW(*COMMIT)\fR" 4
.IX Xref "(*COMMIT)"
.IX Item "(*COMMIT)"
.PD
This is tha Perl 6 \*(L"commit pattern\*(R" \f(CW\*(C`<commit>\*(C'\fR or \f(CW\*(C`:::\*(C'\fR. It aint nuthin but a
zero-width pattern similar ta \f(CW\*(C`(*SKIP)\*(C'\fR, except dat when backtracked
into on failure it causes tha match ta fail outright. No further attempts
to find a valid match by advancin tha start pointa will occur again.
For example,
.Sp
.Vb 2
\& \*(Aqaaabaaab\*(Aq =~ /a+b?(*COMMIT)(?{print "$&\en"; $count++})(*FAIL)/;
\& print "Count=$count\en";
.Ve
.Sp
outputs
.Sp
.Vb 2
\&    aaab
\&    Count=1
.Ve
.Sp
In other lyrics, once tha \f(CW\*(C`(*COMMIT)\*(C'\fR has been entered, n' if tha pattern
does not match, tha regex engine aint gonna try any further matchin on the
rest of tha string.
.ie n .IP """(*FAIL)"" ""(*F)""" 4
.el .IP "\f(CW(*FAIL)\fR \f(CW(*F)\fR" 4
.IX Xref "(*FAIL) (*F)"
.IX Item "(*FAIL) (*F)"
This pattern matches not a god damn thang n' always fails. Well shiiiit, it can be used ta force the
engine ta backtrack. Well shiiiit, it is equivalent ta \f(CW\*(C`(?!)\*(C'\fR yo, but easier ta read. Y'all KNOW dat shit, muthafucka! In
fact, \f(CW\*(C`(?!)\*(C'\fR gets optimised tha fuck into \f(CW\*(C`(*FAIL)\*(C'\fR internally.
.Sp
It be probably useful only when combined wit \f(CW\*(C`(?{})\*(C'\fR or \f(CW\*(C`(??{})\*(C'\fR.
.ie n .IP """(*ACCEPT)""" 4
.el .IP "\f(CW(*ACCEPT)\fR" 4
.IX Xref "(*ACCEPT)"
.IX Item "(*ACCEPT)"
\&\fB\s-1WARNING:\s0\fR This feature is highly experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it aint recommended
for thang code.
.Sp
This pattern matches not a god damn thang n' causes tha end of successful matchin at
the point at which tha \f(CW\*(C`(*ACCEPT)\*(C'\fR pattern was encountered, regardless of
whether there is straight-up mo' ta match up in tha string. When inside of a
nested pattern, like fuckin recursion, or up in a subpattern dynamically generated
via \f(CW\*(C`(??{})\*(C'\fR, only tha innermost pattern is ended immediately.
.Sp
If tha \f(CW\*(C`(*ACCEPT)\*(C'\fR is inside of capturin crews then tha crews are
marked as ended all up in tha point at which tha \f(CW\*(C`(*ACCEPT)\*(C'\fR was encountered.
For instance:
.Sp
.Vb 1
\&  \*(AqAB\*(Aq =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;
.Ve
.Sp
will match, n' \f(CW$1\fR is ghon be \f(CW\*(C`AB\*(C'\fR n' \f(CW$2\fR is ghon be \f(CW\*(C`B\*(C'\fR, \f(CW$3\fR will not
be set. If another branch up in tha inner parentheses was matched, like fuckin up in the
strin '\s-1ACDE\s0', then tha \f(CW\*(C`D\*(C'\fR n' \f(CW\*(C`E\*(C'\fR would gotta be matched as well.
.RE
.RS 3
.RE
.SS "Backtracking"
.IX Xref "backtrack backtracking"
.IX Subsection "Backtracking"
\&\s-1NOTE:\s0 This section presents a abstract approximation of regular
expression behavior. Shiiit, dis aint no joke.  For a mo' rigorous (and fucked up) view of
the rulez involved up in selectin a match among possible alternatives,
see \*(L"Combinin \s-1RE\s0 Pieces\*(R".
.PP
A fundamenstrual feature of regular expression matchin involves the
notion called \fIbacktracking\fR, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`*?\*(C'\fR, \f(CW\*(C`+\*(C'\fR,
\&\f(CW\*(C`+?\*(C'\fR, \f(CW\*(C`{n,m}\*(C'\fR, n' \f(CW\*(C`{n,m}?\*(C'\fR.  Backtrackin is often optimized
internally yo, but tha general principle outlined here is valid.
.PP
For a regular expression ta match, tha \fIentire\fR regular expression must
match, not just part of dat shit.  So if tha beginnin of a pattern containin a
quantifier succeedz up in a way dat causes lata parts up in tha pattern to
fail, tha matchin engine backs up n' recalculates tha beginning
part\*(--thatz why itz called backtracking.
.PP
Here be a example of backtracking:  Letz say you wanna find the
word followin \*(L"foo\*(R" up in tha strang \*(L"Chicken is on tha foo table.\*(R":
.PP
.Vb 4
\&    $_ = "Chicken is on tha foo table.";
\&    if ( /\eb(foo)\es+(\ew+)/i ) {
\&        print "$2 bigs up $1.\en";
\&    }
.Ve
.PP
When tha match runs, tha straight-up original gangsta part of tha regular expression (\f(CW\*(C`\eb(foo)\*(C'\fR)
findz a possible match right all up in tha beginnin of tha string, n' loadz up
\&\f(CW$1\fR wit \*(L"Foo\*(R".  But fuck dat shiznit yo, tha word on tha street is dat as soon as tha matchin engine sees dat there's
no whitespace followin tha \*(L"Foo\*(R" dat it had saved up in \f(CW$1\fR, it realizes its
mistake n' starts over again n' again n' again one characta afta where it had the
tentatizzle match.  This time it goes all tha way until tha next occurrence
of \*(L"foo\*(R". Da complete regular expression matches dis time, n' you get
the expected output of \*(L"table bigs up foo.\*(R"
.PP
Sometimes minimal matchin can help all muthafuckin day. It make me wanna hollar playa!  Imagine you'd like ta match
everythang between \*(L"foo\*(R" n' \*(L"bar\*(R".  Initially, you write something
like this:
.PP
.Vb 4
\&    $_ =  "Da chicken is under tha bar up in tha barn.";
\&    if ( /foo(.*)bar/ ) {
\&        print "got <$1>\en";
\&    }
.Ve
.PP
Which like unexpectedly yields:
.PP
.Vb 1
\&  gots <d is under tha bar up in tha >
.Ve
.PP
Thatz cuz \f(CW\*(C`.*\*(C'\fR was greedy, so you git every last muthafuckin thang between the
\&\fIfirst\fR \*(L"foo\*(R" n' tha \fIlast\fR \*(L"bar\*(R".  Here itz mo' effective
to use minimal matchin ta make shizzle you git tha text between a \*(L"foo\*(R"
and tha straight-up original gangsta \*(L"bar\*(R" thereafter.
.PP
.Vb 2
\&    if ( /foo(.*?)bar/ ) { print "got <$1>\en" }
\&  gots <d is under tha >
.Ve
.PP
Herez another example. Letz say you'd like ta match a number all up in tha end
of a string, n' you also wanna keep tha precedin part of tha match.
So you write this:
.PP
.Vb 4
\&    $_ = "I have 2 numbers: 53147";
\&    if ( /(.*)(\ed*)/ ) {                                # Wrong!
\&        print "Beginnin is <$1>, number is <$2>.\en";
\&    }
.Ve
.PP
That won't work at all, cuz \f(CW\*(C`.*\*(C'\fR was greedy n' gobbled up the
whole strin fo' realz. As \f(CW\*(C`\ed*\*(C'\fR can match on a empty strang tha complete
regular expression matched successfully.
.PP
.Vb 1
\&    Beginnin is <I have 2 numbers: 53147>, number is <>.
.Ve
.PP
Here is some variants, most of which don't work:
.PP
.Vb 11
\&    $_ = "I have 2 numbers: 53147";
\&    @pats = qw{
\&        (.*)(\ed*)
\&        (.*)(\ed+)
\&        (.*?)(\ed*)
\&        (.*?)(\ed+)
\&        (.*)(\ed+)$
\&        (.*?)(\ed+)$
\&        (.*)\eb(\ed+)$
\&        (.*\eD)(\ed+)$
\&    };
\&
\&    fo' $pat (@pats) {
\&        printf "%\-12s ", $pat;
\&        if ( /$pat/ ) {
\&            print "<$1> <$2>\en";
\&        } else {
\&            print "FAIL\en";
\&        }
\&    }
.Ve
.PP
That will print out:
.PP
.Vb 8
\&    (.*)(\ed*)    <I have 2 numbers: 53147> <>
\&    (.*)(\ed+)    <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed*)   <> <>
\&    (.*?)(\ed+)   <I have > <2>
\&    (.*)(\ed+)$   <I have 2 numbers: 5314> <7>
\&    (.*?)(\ed+)$  <I have 2 numbers: > <53147>
\&    (.*)\eb(\ed+)$ <I have 2 numbers: > <53147>
\&    (.*\eD)(\ed+)$ <I have 2 numbers: > <53147>
.Ve
.PP
As you see, dis can be a lil' bit tricky.  It aint nuthin but blingin ta realize dat a
regular expression is merely a set of assertions dat gives a thugged-out definition
of success.  There may be 0, 1, or nuff muthafuckin different ways dat the
definizzle might succeed against a particular string.  And if there are
multiple ways it might succeed, you need ta KNOW backtrackin to
know which variety of success yo big-ass booty is ghon achieve.
.PP
When rockin look-ahead assertions n' negations, dis can all git even
trickier n' shit.  Imagine you'd like ta find a sequence of non-digits not
followed by \*(L"123\*(R".  Yo ass might try ta write dat as
.PP
.Vb 4
\&    $_ = "ABC123";
\&    if ( /^\eD*(?!123)/ ) {                # Wrong!
\&        print "Yup, no 123 up in $_\en";
\&    }
.Ve
.PP
But dat aint goin ta match; at least, not tha way you hoping.  It
claims dat there is no 123 up in tha string.  Herez a cold-ass lil clearer picture of
why dat pattern matches, contrary ta ghettofab expectations:
.PP
.Vb 2
\&    $x = \*(AqABC123\*(Aq;
\&    $y = \*(AqABC445\*(Aq;
\&
\&    print "1: gots $1\en" if $x =~ /^(ABC)(?!123)/;
\&    print "2: gots $1\en" if $y =~ /^(ABC)(?!123)/;
\&
\&    print "3: gots $1\en" if $x =~ /^(\eD*)(?!123)/;
\&    print "4: gots $1\en" if $y =~ /^(\eD*)(?!123)/;
.Ve
.PP
This prints
.PP
.Vb 3
\&    2: gots ABC
\&    3: gots AB
\&    4: gots ABC
.Ve
.PP
Yo ass might have expected test 3 ta fail cuz it seems ta a more
general purpose version of test 1.  Da blingin difference between
them is dat test 3 gotz nuff a quantifier (\f(CW\*(C`\eD*\*(C'\fR) n' so can use
backtracking, whereas test 1 will not.  Whatz goin down is
that you've axed \*(L"Is it legit dat all up in tha start of \f(CW$x\fR, followin 0 or more
non-digits, you have suttin' thatz not 123?\*(R"  If tha pattern matcher had
let \f(CW\*(C`\eD*\*(C'\fR expand ta \*(L"\s-1ABC\*(R",\s0 dis would have caused tha whole pattern to
fail.
.PP
Da search engine will initially match \f(CW\*(C`\eD*\*(C'\fR wit \*(L"\s-1ABC\*(R". \s0 Then it will
try ta match \f(CW\*(C`(?!123)\*(C'\fR wit \*(L"123\*(R", which fails.  But cuz
a quantifier (\f(CW\*(C`\eD*\*(C'\fR) has been used up in tha regular expression, the
search engine can backtrack n' retry tha match differently
in tha hope of matchin tha complete regular expression.
.PP
Da pattern straight-up, \fIreally\fR wants ta succeed, so it uses the
standard pattern back-off-and-retry n' lets \f(CW\*(C`\eD*\*(C'\fR expand ta just \*(L"\s-1AB\*(R"\s0 this
time.  Now there be a indeed suttin' followin \*(L"\s-1AB\*(R"\s0 dat is not
\&\*(L"123\*(R".  It aint nuthin but \*(L"C123\*(R", which suffices.
.PP
We can deal wit dis by rockin both a assertion n' a negation.
We bout ta say dat tha straight-up original gangsta part up in \f(CW$1\fR must be followed both by a gangbangin' finger-lickin' digit
and by suttin' thatz not \*(L"123\*(R".  Remember dat tha look-aheads
are zero-width expressions\*(--they only look yo, but don't consume any
of tha strang up in they match.  So rewritin dis way produces what
you'd expect; dat is, case 5 will fail yo, but case 6 succeeds:
.PP
.Vb 2
\&    print "5: gots $1\en" if $x =~ /^(\eD*)(?=\ed)(?!123)/;
\&    print "6: gots $1\en" if $y =~ /^(\eD*)(?=\ed)(?!123)/;
\&
\&    6: gots ABC
.Ve
.PP
In other lyrics, tha two zero-width assertions next ta each other work as though
they ANDed together, just as you'd use any built-in assertions:  \f(CW\*(C`/^$/\*(C'\fR
matches only if you all up in tha beginnin of tha line \s-1AND\s0 tha end of the
line simultaneously.  Da deeper underlyin truth is dat juxtaposizzle in
regular expressions always means \s-1AND,\s0 except when you write a explicit \s-1OR\s0
usin tha vertical bar. Shiiit, dis aint no joke.  \f(CW\*(C`/ab/\*(C'\fR means match \*(L"a\*(R" \s-1AND \s0(then) match \*(L"b\*(R",
although tha attempted matches is made at different positions cuz \*(L"a\*(R"
is not a zero-width assertion yo, but a one-width assertion.
.PP
\&\fB\s-1WARNING\s0\fR: Particularly fucked up regular expressions can take
exponential time ta solve cuz of tha immense number of possible
ways they can use backtrackin ta try fo' a match.  For example, without
internal optimizations done by tha regular expression engine, dis will
take a painfully long time ta run:
.PP
.Vb 1
\&    \*(Aqaaaaaaaaaaaa\*(Aq =~ /((a{0,5}){0,5})*[c]/
.Ve
.PP
And if you used \f(CW\*(C`*\*(C'\fRz up in tha internal crews instead of limitin them
to 0 all up in 5 matches, then it would take forever\*(--or until you ran
out of stack space.  Mo'over, these internal optimizations is not
always applicable.  For example, if you put \f(CW\*(C`{0,5}\*(C'\fR instead of \f(CW\*(C`*\*(C'\fR
on tha external group, no current optimization be applicable, n' the
match takes a long-ass time ta finish.
.PP
A bangin tool fo' optimizin such beasts is what tha fuck is known as an
\&\*(L"independent group\*(R",
which do not backtrack (see "\f(CW\*(C`(?>pattern)\*(C'\fR").  Note also that
zero-length look\-ahead/look\-behind assertions aint gonna backtrack ta make
the tail match, since they is up in \*(L"logical\*(R" context: only
whether they match is considered relevant.  For a example
where side-effectz of look-ahead \fImight\fR have hyped up the
followin match, peep "\f(CW\*(C`(?>pattern)\*(C'\fR".
.SS "Version 8 Regular Expressions"
.IX Xref "regular expression, version 8 regex, version 8 regexp, version 8"
.IX Subsection "Version 8 Regular Expressions"
In case you not familiar wit tha \*(L"regular\*(R" Version 8 regex
routines, here is tha pattern-matchin rulez not busted lyrics bout above.
.PP
Any single characta matches itself, unless it aint nuthin but a \fImetacharacter\fR
with a special meanin busted lyrics bout here or above.  Yo ass can cause
charactas dat normally function as metacharactas ta be interpreted
literally by prefixin dem wit a \*(L"\e\*(R" (e.g., \*(L"\e.\*(R" matches a \*(L".\*(R", not any
character; \*(L"\e\e\*(R" matches a \*(L"\e\*(R"). This escape mechanizzle be also required
for tha characta used as tha pattern delimiter.
.PP
A seriez of charactas matches dat seriez of charactas up in tha target
string, so tha pattern \f(CW\*(C`blurfl\*(C'\fR would match \*(L"blurfl\*(R" up in tha target
string.
.PP
Yo ass can specify a cold-ass lil characta class, by enclosin a list of characters
in \f(CW\*(C`[]\*(C'\fR, which will match any characta from tha list.  If the
first characta afta tha \*(L"[\*(R" is \*(L"^\*(R", tha class matches any characta not
in tha list.  Within a list, tha \*(L"\-\*(R" characta specifies a
range, so dat \f(CW\*(C`a\-z\*(C'\fR represents all charactas between \*(L"a\*(R" n' \*(L"z\*(R",
inclusive.  If you want either \*(L"\-\*(R" or \*(L"]\*(R" itself ta be a gangmember of a
class, put it all up in tha start of tha list (possibly afta a \*(L"^\*(R"), or
escape it wit a funky-ass backslash.  \*(L"\-\*(R" be also taken literally when it is
at tha end of tha list, just before tha closin \*(L"]\*(R".  (The
followin all specify tha same class of three characters: \f(CW\*(C`[\-az]\*(C'\fR,
\&\f(CW\*(C`[az\-]\*(C'\fR, n' \f(CW\*(C`[a\e\-z]\*(C'\fR.  All is different from \f(CW\*(C`[a\-z]\*(C'\fR, which
specifies a cold-ass lil class containin twenty-six characters, even on EBCDIC-based
characta sets.)  Also, if you try ta use tha character
classes \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\ed\*(C'\fR, or \f(CW\*(C`\eD\*(C'\fR as endpoints of
a range, tha \*(L"\-\*(R" is understood literally.
.PP
Note also dat tha whole range scam is rather unportable between
characta sets\*(--and even within characta sets they may cause thangs up in dis biatch
you probably didn't expect.  A sound principle is ta use only ranges
that begin from n' end at either alphabetics of equal case ([a\-e],
[A\-E]), or digits ([0\-9]).  Anythang else is unsafe.  If up in doubt,
spell up tha characta sets up in full.
.PP
Charactas may be specified rockin a metacharacta syntax much like that
used up in C: \*(L"\en\*(R" matches a newline, \*(L"\et\*(R" a tab, \*(L"\er\*(R" a cold-ass lil carriage return,
\&\*(L"\ef\*(R" a gangbangin' form feed, etc.  Mo' generally, \e\fInnn\fR, where \fInnn\fR be a string
of three octal digits, matches tha characta whose coded characta set value
is \fInnn\fR.  Similarly, \ex\fInn\fR, where \fInn\fR is hexadecimal digits,
matches tha characta whose ordinal is \fInn\fR. Da expression \ec\fIx\fR
matches tha characta control\-\fIx\fR.  Finally, tha \*(L".\*(R" metacharacter
matches any characta except \*(L"\en\*(R" (unless you use \f(CW\*(C`/s\*(C'\fR).
.PP
Yo ass can specify a seriez of alternatives fo' a pattern rockin \*(L"|\*(R" to
separate them, so dat \f(CW\*(C`fee|fie|foe\*(C'\fR will match any of \*(L"fee\*(R", \*(L"fie\*(R",
or \*(L"foe\*(R" up in tha target strang (as would \f(CW\*(C`f(e|i|o)e\*(C'\fR).  The
first alternatizzle includes every last muthafuckin thang from tha last pattern delimiter
(\*(L"(\*(R", \*(L"(?:\*(R", etc. or tha beginnin of tha pattern) up ta tha straight-up original gangsta \*(L"|\*(R", and
the last alternatizzle gotz nuff every last muthafuckin thang from tha last \*(L"|\*(R" ta tha next
closin pattern delimiter n' shit.  Thatz why itz common practice ta include
alternatives up in parentheses: ta minimize mad drama bout where they
start n' end.
.PP
Alternatives is tried from left ta right, so tha first
alternatizzle found fo' which tha entire expression matches, is tha one that
is chosen. I aint talkin' bout chicken n' gravy biatch. This means dat alternatives is not necessarily greedy. For
example: when matchin \f(CW\*(C`foo|foot\*(C'\fR against \*(L"barefoot\*(R", only tha \*(L"foo\*(R"
part will match, as dat is tha straight-up original gangsta alternatizzle tried, n' it successfully
matches tha target string. (This might not seem blingin yo, but it is
important when yo ass is capturin matched text rockin parentheses.)
.PP
Also remember dat \*(L"|\*(R" is interpreted as a literal within square brackets,
so if you write \f(CW\*(C`[fee|fie|foe]\*(C'\fR you straight-up only matchin \f(CW\*(C`[feio|]\*(C'\fR.
.PP
Within a pattern, you may designate subpatterns fo' lata reference
by enclosin dem up in parentheses, n' you may refer back ta the
\&\fIn\fRth subpattern lata up in tha pattern rockin tha metacharacter
\&\e\fIn\fR or \eg\fIn\fR.  Subpatterns is numbered based on tha left ta right order
of they openin parenthesis.  A backreference matches whatever
actually matched tha subpattern up in tha strang bein examined, not
the rulez fo' dat subpattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Therefore, \f(CW\*(C`(0|0x)\ed*\es\eg1\ed*\*(C'\fR will
match \*(L"0x1234 0x4321\*(R" yo, but not \*(L"0x1234 01234\*(R", cuz subpattern
1 matched \*(L"0x\*(R", even though tha rule \f(CW\*(C`0|0x\*(C'\fR could potentially match
the leadin 0 up in tha second number.
.ie n .SS "Warnin on \e1 Instead of $1"
.el .SS "Warnin on \e1 Instead of \f(CW$1\fP"
.IX Subsection "Warnin on 1 Instead of $1"
Some playas git too used ta freestylin thangs like:
.PP
.Vb 1
\&    $pattern =~ s/(\eW)/\e\e\e1/g;
.Ve
.PP
This is grandfathered (for \e1 ta \e9) fo' tha \s-1RHS\s0 of a substitute ta avoid
shockin the
\&\fBsed\fR crackas yo, but itz a gangbangin' finger-lickin' dirty g-thang ta git into.  Thatz cuz in
PerlThink, tha righthand side of a \f(CW\*(C`s///\*(C'\fR be a thugged-out double-quoted string.  \f(CW\*(C`\e1\*(C'\fR in
the usual double-quoted strang means a cold-ass lil control-A.  Da customary Unix
meanin of \f(CW\*(C`\e1\*(C'\fR is kludged up in fo' \f(CW\*(C`s///\*(C'\fR.  But fuck dat shiznit yo, tha word on tha street is dat if you git tha fuck into tha habit
of bustin that, you git yo ass tha fuck into shiznit if you then add a \f(CW\*(C`/e\*(C'\fR
modifier.
.PP
.Vb 1
\&    s/(\ed+)/ \e1 + 1 /eg;            # causes warnin under \-w
.Ve
.PP
Or if you try ta do
.PP
.Vb 1
\&    s/(\ed+)/\e1000/;
.Ve
.PP
Yo ass can't disambiguate dat by sayin \f(CW\*(C`\e{1}000\*(C'\fR, whereas you can fix it with
\&\f(CW\*(C`${1}000\*(C'\fR.  Da operation of interpolation should not be confused
with tha operation of matchin a funky-ass backreference.  Certainly they mean two
different thangs on tha \fIleft\fR side of tha \f(CW\*(C`s///\*(C'\fR.
.SS "Repeated Patterns Matchin a Zero-length Substring"
.IX Subsection "Repeated Patterns Matchin a Zero-length Substring"
\&\fB\s-1WARNING\s0\fR: Difficult material (and prose) ahead. Y'all KNOW dat shit, muthafucka!  This section needz a rewrite.
.PP
Regular expressions provide a terse n' bangin programmin language.  As
with most other juice tools, juice comes together wit tha ability
to wreak havoc.
.PP
A common abuse of dis juice stems from tha mobilitizzle ta make infinite
loops rockin regular expressions, wit suttin' as innocuous as:
.PP
.Vb 1
\&    \*(Aqfoo\*(Aq =~ m{ ( o? )* }x;
.Ve
.PP
Da \f(CW\*(C`o?\*(C'\fR matches all up in tha beginnin of \f(CW\*(Aqfoo\*(Aq\fR, n' since tha position
in tha strang aint moved by tha match, \f(CW\*(C`o?\*(C'\fR would match again n' again n' again n' again
because of tha \f(CW\*(C`*\*(C'\fR quantifier n' shit.  Another common way ta create a similar cycle
is wit tha loopin modifier \f(CW\*(C`//g\*(C'\fR:
.PP
.Vb 1
\&    @matches = ( \*(Aqfoo\*(Aq =~ m{ o? }xg );
.Ve
.PP
or
.PP
.Vb 1
\&    print "match: <$&>\en" while \*(Aqfoo\*(Aq =~ m{ o? }xg;
.Ve
.PP
or tha loop implied by \fIsplit()\fR.
.PP
But fuck dat shiznit yo, tha word on tha street is dat long experience has shown dat nuff programmin tasks may
be hella simplified by rockin repeated subexpressions that
may match zero-length substrings.  Herez a simple example being:
.PP
.Vb 2
\&    @chars = split //, $string;           # // aint magic up in split
\&    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /
.Ve
.PP
Thus Perl allows such constructs, by \fIforcefully breaking
the infinite loop\fR.  Da rulez fo' dis is different fo' lower-level
loops given by tha greedy quantifiers \f(CW\*(C`*+{}\*(C'\fR, n' fo' higher-level
ones like tha \f(CW\*(C`/g\*(C'\fR modifier or \fIsplit()\fR operator.
.PP
Da lower-level loops is \fIinterrupted\fR (that is, tha loop is
broken) when Perl detects dat a repeated expression matched a
zero-length substring.   Thus
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;
.Ve
.PP
is made equivalent to
.PP
.Vb 1
\&   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;
.Ve
.PP
For example, dis program
.PP
.Vb 12
\&   #!perl \-l
\&   "aaaaab" =~ /
\&     (?:
\&        a                 # non\-zero
\&        |                 # or
\&       (?{print "hello"}) # print wassup whenever this
\&                          #    branch is tried
\&       (?=(b))            # zero\-width assertion
\&     )*  # any number of times
\&    /x;
\&   print $&;
\&   print $1;
.Ve
.PP
prints
.PP
.Vb 3
\&   hello
\&   aaaaa
\&   b
.Ve
.PP
Notice dat \*(L"hello\*(R" is only printed once, as when Perl sees dat tha sixth
iteration of tha outermost \f(CW\*(C`(?:)*\*(C'\fR matches a zero-length string, it stops
the \f(CW\*(C`*\*(C'\fR.
.PP
Da higher-level loops preserve a additionizzle state between iterations:
whether tha last match was zero-length.  To break tha loop, tha following
match afta a zero-length match is prohibited ta git a length of zero.
This prohibizzle interacts wit backtrackin (see \*(L"Backtracking\*(R"),
and so tha \fIsecond best\fR match is chosen if tha \fIbest\fR match is of
zero length.
.PP
For example:
.PP
.Vb 2
\&    $_ = \*(Aqbar\*(Aq;
\&    s/\ew??/<$&>/g;
.Ve
.PP
results up in \f(CW\*(C`<><b><><a><><r><>\*(C'\fR.  At each posizzle of tha strang tha best
match given by non-greedy \f(CW\*(C`??\*(C'\fR is tha zero-length match, n' tha \fIsecond
best\fR match is what tha fuck is matched by \f(CW\*(C`\ew\*(C'\fR.  Thus zero-length matches
alternate wit one-character-long matches.
.PP
Similarly, fo' repeated \f(CW\*(C`m/()/g\*(C'\fR tha second-best match is tha match at the
posizzle one notch further up in tha string.
.PP
Da additionizzle state of bein \fImatched wit zero-length\fR be associated with
the matched string, n' is reset by each assignment ta \fIpos()\fR.
Zero-length matches all up in tha end of tha previous match is ignored
durin \f(CW\*(C`split\*(C'\fR.
.SS "Combinin \s-1RE\s0 Pieces"
.IX Subsection "Combinin RE Pieces"
Each of tha elementary piecez of regular expressions which was busted lyrics about
before (like fuckin \f(CW\*(C`ab\*(C'\fR or \f(CW\*(C`\eZ\*(C'\fR) could match at most one substring
at tha given posizzle of tha input string.  But fuck dat shiznit yo, tha word on tha street is dat up in a typical regular
expression these elementary pieces is combined tha fuck into mo' fucked up
patterns rockin combinin operators \f(CW\*(C`ST\*(C'\fR, \f(CW\*(C`S|T\*(C'\fR, \f(CW\*(C`S*\*(C'\fR etc.
(in these examplez \f(CW\*(C`S\*(C'\fR n' \f(CW\*(C`T\*(C'\fR is regular subexpressions).
.PP
Such combinations can include alternatives, leadin ta a problem of chizzle:
if we match a regular expression \f(CW\*(C`a|ab\*(C'\fR against \f(CW"abc"\fR, will it match
substrin \f(CW"a"\fR or \f(CW"ab"\fR?  One way ta describe which substrin is
actually matched is tha concept of backtrackin (see \*(L"Backtracking\*(R").
But fuck dat shiznit yo, tha word on tha street is dat dis description is too low-level n' make you think
in termz of a particular implementation.
.PP
Another description starts wit notionz of \*(L"better\*(R"/\*(L"worse\*(R".  All the
substrings which may be matched by tha given regular expression can be
sorted from tha \*(L"best\*(R" match ta tha \*(L"worst\*(R" match, n' it is tha \*(L"best\*(R"
match which is chosen. I aint talkin' bout chicken n' gravy biatch.  This substitutes tha question of \*(L"what is chosen?\*(R"
by tha question of \*(L"which matches is better, n' which is worse?\*(R".
.PP
Again, fo' elementary pieces there is no such question, since at most
one match at a given posizzle is possible.  This section raps bout the
notion of better/worse fo' combinin operators.  In tha description
below \f(CW\*(C`S\*(C'\fR n' \f(CW\*(C`T\*(C'\fR is regular subexpressions.
.ie n .IP """ST""" 4
.el .IP "\f(CWST\fR" 4
.IX Item "ST"
Consider two possible matches, \f(CW\*(C`AB\*(C'\fR n' \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR, \f(CW\*(C`A\*(C'\fR n' \f(CW\*(C`A\*(Aq\*(C'\fR are
substrings which can be matched by \f(CW\*(C`S\*(C'\fR, \f(CW\*(C`B\*(C'\fR n' \f(CW\*(C`B\*(Aq\*(C'\fR is substrings
which can be matched by \f(CW\*(C`T\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR be a funky-ass betta match fo' \f(CW\*(C`S\*(C'\fR than \f(CW\*(C`A\*(Aq\*(C'\fR, \f(CW\*(C`AB\*(C'\fR be a funky-ass better
match than \f(CW\*(C`A\*(AqB\*(Aq\*(C'\fR.
.Sp
If \f(CW\*(C`A\*(C'\fR n' \f(CW\*(C`A\*(Aq\*(C'\fR coincide: \f(CW\*(C`AB\*(C'\fR be a funky-ass betta match than \f(CW\*(C`AB\*(Aq\*(C'\fR if
\&\f(CW\*(C`B\*(C'\fR be a funky-ass betta match fo' \f(CW\*(C`T\*(C'\fR than \f(CW\*(C`B\*(Aq\*(C'\fR.
.ie n .IP """S|T""" 4
.el .IP "\f(CWS|T\fR" 4
.IX Item "S|T"
When \f(CW\*(C`S\*(C'\fR can match, it aint nuthin but a funky-ass betta match than when only \f(CW\*(C`T\*(C'\fR can match.
.Sp
Orderin of two matches fo' \f(CW\*(C`S\*(C'\fR is tha same ol' dirty as fo' \f(CW\*(C`S\*(C'\fR.  Similar for
two matches fo' \f(CW\*(C`T\*(C'\fR.
.ie n .IP """S{REPEAT_COUNT}""" 4
.el .IP "\f(CWS{REPEAT_COUNT}\fR" 4
.IX Item "S{REPEAT_COUNT}"
Matches as \f(CW\*(C`SSS...S\*(C'\fR (repeated as nuff times as necessary).
.ie n .IP """S{min,max}""" 4
.el .IP "\f(CWS{min,max}\fR" 4
.IX Item "S{min,max}"
Matches as \f(CW\*(C`S{max}|S{max\-1}|...|S{min+1}|S{min}\*(C'\fR.
.ie n .IP """S{min,max}?""" 4
.el .IP "\f(CWS{min,max}?\fR" 4
.IX Item "S{min,max}?"
Matches as \f(CW\*(C`S{min}|S{min+1}|...|S{max\-1}|S{max}\*(C'\fR.
.ie n .IP """S?"", ""S*"", ""S+""" 4
.el .IP "\f(CWS?\fR, \f(CWS*\fR, \f(CWS+\fR" 4
.IX Item "S?, S*, S+"
Same as \f(CW\*(C`S{0,1}\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}\*(C'\fR respectively.
.ie n .IP """S??"", ""S*?"", ""S+?""" 4
.el .IP "\f(CWS??\fR, \f(CWS*?\fR, \f(CWS+?\fR" 4
.IX Item "S??, S*?, S+?"
Same as \f(CW\*(C`S{0,1}?\*(C'\fR, \f(CW\*(C`S{0,BIG_NUMBER}?\*(C'\fR, \f(CW\*(C`S{1,BIG_NUMBER}?\*(C'\fR respectively.
.ie n .IP """(?>S)""" 4
.el .IP "\f(CW(?>S)\fR" 4
.IX Item "(?>S)"
Matches tha dopest match fo' \f(CW\*(C`S\*(C'\fR n' only dis shit.
.ie n .IP """(?=S)"", ""(?<=S)""" 4
.el .IP "\f(CW(?=S)\fR, \f(CW(?<=S)\fR" 4
.IX Item "(?=S), (?<=S)"
Only tha dopest match fo' \f(CW\*(C`S\*(C'\fR is considered. Y'all KNOW dat shit, muthafucka!  (This is blingin only if
\&\f(CW\*(C`S\*(C'\fR has capturin parentheses, n' backreferences is used somewhere
else up in tha whole regular expression.)
.ie n .IP """(?!S)"", ""(?<!S)""" 4
.el .IP "\f(CW(?!S)\fR, \f(CW(?<!S)\fR" 4
.IX Item "(?!S), (?<!S)"
For dis groupin operator there is no need ta describe tha ordering, since
only whether or not \f(CW\*(C`S\*(C'\fR can match is blingin.
.ie n .IP """(??{ EXPR })"", ""(?\f(CIPARNO\f(CW)""" 4
.el .IP "\f(CW(??{ EXPR })\fR, \f(CW(?\f(CIPARNO\f(CW)\fR" 4
.IX Item "(??{ EXPR }), (?PARNO)"
Da orderin is tha same ol' dirty as fo' tha regular expression which is
the result of \s-1EXPR,\s0 or tha pattern contained by capture crew \fI\s-1PARNO\s0\fR.
.ie n .IP """(?(condition)yes\-pattern|no\-pattern)""" 4
.el .IP "\f(CW(?(condition)yes\-pattern|no\-pattern)\fR" 4
.IX Item "(?(condition)yes-pattern|no-pattern)"
Recall dat which of \f(CW\*(C`yes\-pattern\*(C'\fR or \f(CW\*(C`no\-pattern\*(C'\fR straight-up matches is
already determined. Y'all KNOW dat shit, muthafucka!  Da orderin of tha matches is tha same ol' dirty as fo' the
chosen subexpression.
.PP
Da above recipes describe tha orderin of matches \fIat a given position\fR.
One mo' rule is needed ta KNOW how tha fuck a match is determined fo' the
whole regular expression: a match at a earlier posizzle be always better
than a match at a lata position.
.SS "Creatin Custom \s-1RE\s0 Engines"
.IX Subsection "Creatin Custom RE Engines"
Az of Perl 5.10.0, one can create custom regular expression engines.  This
is not fo' tha faint of ass, as they gotta plug up in all up in tha C level.  See
perlreapi fo' mo' details.
.PP
As a alternative, overloaded constants (see overload) provide a simple
way ta extend tha functionalitizzle of tha \s-1RE\s0 engine, by substitutin one
pattern fo' another.
.PP
Suppose dat we wanna enable a freshly smoked up \s-1RE\s0 escape-sequence \f(CW\*(C`\eY|\*(C'\fR which
matches at a funky-ass boundary between whitespace charactas n' non-whitespace
characters.  Note dat \f(CW\*(C`(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)\*(C'\fR matches exactly
at these positions, so we wanna have each \f(CW\*(C`\eY|\*(C'\fR up in tha place of the
more fucked up version. I aint talkin' bout chicken n' gravy biatch.  We can create a module \f(CW\*(C`customre\*(C'\fR ta do
this:
.PP
.Vb 2
\&    package customre;
\&    use overload;
\&
\&    sub import {
\&      shift;
\&      take a thugged-out dirtnap "No argument ta customre::import allowed" if @_;
\&      overload::constant \*(Aqqr\*(Aq => \e&convert;
\&    }
\&
\&    sub invalid { take a thugged-out dirtnap "/$_[0]/: invalid escape \*(Aq\e\e$_[1]\*(Aq"}
\&
\&    # We must also take care of not escapin tha legitimate \e\eY|
\&    # sequence, hence tha presence of \*(Aq\e\e\*(Aq up in tha conversion rules.
\&    mah %rulez = ( \*(Aq\e\e\*(Aq => \*(Aq\e\e\e\e\*(Aq,
\&                  \*(AqY|\*(Aq => qr/(?=\eS)(?<!\eS)|(?!\eS)(?<=\eS)/ );
\&    sub convert {
\&      mah $re = shift;
\&      $re =~ s{
\&                \e\e ( \e\e | Y . )
\&              }
\&              { $rules{$1} or invalid($re,$1) }sgex;
\&      return $re;
\&    }
.Ve
.PP
Now \f(CW\*(C`use customre\*(C'\fR enablez tha freshly smoked up escape up in constant regular
expressions, i.e., dem without any runtime variable interpolations.
As documented up in overload, dis conversion will work only over
literal partz of regular expressions.  For \f(CW\*(C`\eY|$re\eY|\*(C'\fR tha variable
part of dis regular expression need ta be converted explicitly
(but only if tha special meanin of \f(CW\*(C`\eY|\*(C'\fR should be enabled inside \f(CW$re\fR):
.PP
.Vb 5
\&    use customre;
\&    $re = <>;
\&    chomp $re;
\&    $re = customre::convert $re;
\&    /\eY|$re\eY|/;
.Ve
.SS "PCRE/Python Support"
.IX Subsection "PCRE/Python Support"
Az of Perl 5.10.0, Perl supports nuff muthafuckin Python/PCRE\-specific extensions
to tha regex syntax. While Perl programmers is encouraged ta use the
Perl-specific syntax, tha followin is also accepted:
.ie n .IP """(?P<NAME>pattern)""" 4
.el .IP "\f(CW(?P<NAME>pattern)\fR" 4
.IX Item "(?P<NAME>pattern)"
Define a named capture group. Equivalent ta \f(CW\*(C`(?<NAME>pattern)\*(C'\fR.
.ie n .IP """(?P=NAME)""" 4
.el .IP "\f(CW(?P=NAME)\fR" 4
.IX Item "(?P=NAME)"
Backreference ta a named capture group. Equivalent ta \f(CW\*(C`\eg{NAME}\*(C'\fR.
.ie n .IP """(?P>NAME)""" 4
.el .IP "\f(CW(?P>NAME)\fR" 4
.IX Item "(?P>NAME)"
Subroutine call ta a named capture group. Equivalent ta \f(CW\*(C`(?&NAME)\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
Many regular expression constructs don't work on \s-1EBCDIC\s0 platforms.
.PP
There is a fuckin shitload of thangs wit regard ta case-insensitizzle matching
in Unicode rules.  See \f(CW\*(C`i\*(C'\fR under \*(L"Modifiers\*(R" above.
.PP
This document varies from hard as fuck ta KNOW ta straight-up
and utterly opaque.  Da wanderin prose riddled wit jargon is
hard ta fathom up in nuff muthafuckin places.
.PP
This document needz a rewrite dat separates tha tutorial content
from tha reference content.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlrequick.
.PP
perlretut.
.PP
\&\*(L"Regexp Quote-Like Operators\*(R" up in perlop.
.PP
\&\*(L"Gory detailz of parsin quoted constructs\*(R" up in perlop.
.PP
perlfaq6.
.PP
\&\*(L"pos\*(R" up in perlfunc.
.PP
perllocale.
.PP
perlebcdic.
.PP
\&\fIMasterin Regular Expressions\fR by Jeffrey Friedl, published
by O'Reilly n' Associates.
