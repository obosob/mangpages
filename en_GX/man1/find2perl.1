.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FIND2PERL 1"
.TH FIND2PERL 1 "2014-10-30" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
find2perl \- translate find command lines ta Perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        find2perl [paths] [predicates] | perl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
find2perl be a lil translator ta convert find command lines to
equivalent Perl code.  Da resultin code is typically fasta than
runnin find itself.
.PP
\&\*(L"paths\*(R" is a set of paths where find2perl will start its searches and
\&\*(L"predicates\*(R" is taken from tha followin list.
.ie n .IP """! PREDICATE""" 4
.el .IP "\f(CW! PREDICATE\fR" 4
.IX Item "! PREDICATE"
Negate tha sense of tha followin predicate.  Da \f(CW\*(C`!\*(C'\fR must be passed as
a distinct argument, so it may need ta be surrounded by whitespace and/or
quoted from interpretation by tha shell rockin a funky-ass backslash (just as with
usin \f(CWfind(1)\fR).
.ie n .IP """( PREDICATES )""" 4
.el .IP "\f(CW( PREDICATES )\fR" 4
.IX Item "( PREDICATES )"
Group tha given \s-1PREDICATES. \s0 Da parentheses must be passed as distinct
arguments, so they may need ta be surrounded by whitespace and/or
quoted from interpretation by tha shell rockin a funky-ass backslash (just as with
usin \f(CWfind(1)\fR).
.ie n .IP """PREDICATE1 PREDICATE2""" 4
.el .IP "\f(CWPREDICATE1 PREDICATE2\fR" 4
.IX Item "PREDICATE1 PREDICATE2"
True if _both_ \s-1PREDICATE1\s0 n' \s-1PREDICATE2\s0 is true; \s-1PREDICATE2\s0 is not
evaluated if \s-1PREDICATE1\s0 is false.
.ie n .IP """PREDICATE1 \-o PREDICATE2""" 4
.el .IP "\f(CWPREDICATE1 \-o PREDICATE2\fR" 4
.IX Item "PREDICATE1 -o PREDICATE2"
True if either one of \s-1PREDICATE1\s0 or \s-1PREDICATE2\s0 is true; \s-1PREDICATE2\s0 is
not evaluated if \s-1PREDICATE1\s0 is true.
.ie n .IP """\-follow""" 4
.el .IP "\f(CW\-follow\fR" 4
.IX Item "-follow"
Big up (dereference) symlinks.  Da checkin of file attributes depends
on tha posizzle of tha \f(CW\*(C`\-follow\*(C'\fR option. I aint talkin' bout chicken n' gravy biatch. If it precedes tha file
check option, a \f(CW\*(C`stat\*(C'\fR is done which means tha file check applies ta the
file tha symbolic link is pointin to. If \f(CW\*(C`\-follow\*(C'\fR option bigs up the
file check option, dis now applies ta tha symbolic link itself, i.e.
an \f(CW\*(C`lstat\*(C'\fR is done.
.ie n .IP """\-depth""" 4
.el .IP "\f(CW\-depth\fR" 4
.IX Item "-depth"
Change directory traversal algorithm from breadth-first ta depth-first.
.ie n .IP """\-prune""" 4
.el .IP "\f(CW\-prune\fR" 4
.IX Item "-prune"
Do not descend tha fuck into tha directory currently matched.
.ie n .IP """\-xdev""" 4
.el .IP "\f(CW\-xdev\fR" 4
.IX Item "-xdev"
Do not traverse mount points (prunes search at mount-point directories).
.ie n .IP """\-name GLOB""" 4
.el .IP "\f(CW\-name GLOB\fR" 4
.IX Item "-name GLOB"
File name matches specified \s-1GLOB\s0 wildcard pattern, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  \s-1GLOB\s0 may need ta be
quoted ta avoid interpretation by tha shell (just as wit using
\&\f(CWfind(1)\fR).
.ie n .IP """\-iname GLOB""" 4
.el .IP "\f(CW\-iname GLOB\fR" 4
.IX Item "-iname GLOB"
Like \f(CW\*(C`\-name\*(C'\fR yo, but tha match is case insensitive.
.ie n .IP """\-path GLOB""" 4
.el .IP "\f(CW\-path GLOB\fR" 4
.IX Item "-path GLOB"
Path name matches specified \s-1GLOB\s0 wildcard pattern.
.ie n .IP """\-ipath GLOB""" 4
.el .IP "\f(CW\-ipath GLOB\fR" 4
.IX Item "-ipath GLOB"
Like \f(CW\*(C`\-path\*(C'\fR yo, but tha match is case insensitive.
.ie n .IP """\-perm PERM""" 4
.el .IP "\f(CW\-perm PERM\fR" 4
.IX Item "-perm PERM"
Low-order 9 bitz of permission match octal value \s-1PERM.\s0
.ie n .IP """\-perm \-PERM""" 4
.el .IP "\f(CW\-perm \-PERM\fR" 4
.IX Item "-perm -PERM"
Da bits specified up in \s-1PERM\s0 is all set up in filez permissions.
.ie n .IP """\-type X""" 4
.el .IP "\f(CW\-type X\fR" 4
.IX Item "-type X"
Da filez type matches perlz \f(CW\*(C`\-X\*(C'\fR operator.
.ie n .IP """\-fstype TYPE""" 4
.el .IP "\f(CW\-fstype TYPE\fR" 4
.IX Item "-fstype TYPE"
Filesystem of current path iz of type \s-1TYPE \s0(only NFS/non\-NFS distinction
is implemented).
.ie n .IP """\-user USER""" 4
.el .IP "\f(CW\-user USER\fR" 4
.IX Item "-user USER"
True if \s-1USER\s0 is balla of file.
.ie n .IP """\-group GROUP""" 4
.el .IP "\f(CW\-group GROUP\fR" 4
.IX Item "-group GROUP"
True if filez crew is \s-1GROUP.\s0
.ie n .IP """\-nouser""" 4
.el .IP "\f(CW\-nouser\fR" 4
.IX Item "-nouser"
True if filez balla aint up in password database.
.ie n .IP """\-nogroup""" 4
.el .IP "\f(CW\-nogroup\fR" 4
.IX Item "-nogroup"
True if filez crew aint up in crew database.
.ie n .IP """\-inum INUM""" 4
.el .IP "\f(CW\-inum INUM\fR" 4
.IX Item "-inum INUM"
True filez inode number is \s-1INUM.\s0
.ie n .IP """\-links N""" 4
.el .IP "\f(CW\-links N\fR" 4
.IX Item "-links N"
True if (hard) link count of file matches N (see below).
.ie n .IP """\-size N""" 4
.el .IP "\f(CW\-size N\fR" 4
.IX Item "-size N"
True if filez size matches N (see below) N is normally counted in
512\-byte blocks yo, but a suffix of \*(L"c\*(R" specifies dat size should be
counted up in charactas (bytes) n' a suffix of \*(L"k\*(R" specifies that
size should be counted up in 1024\-byte blocks.
.ie n .IP """\-atime N""" 4
.el .IP "\f(CW\-atime N\fR" 4
.IX Item "-atime N"
True if last-access time of file matches N (measured up in days) (see
below).
.ie n .IP """\-ctime N""" 4
.el .IP "\f(CW\-ctime N\fR" 4
.IX Item "-ctime N"
True if last-changed time of filez inode matches N (measured up in days,
see below).
.ie n .IP """\-mtime N""" 4
.el .IP "\f(CW\-mtime N\fR" 4
.IX Item "-mtime N"
True if last-modified time of file matches N (measured up in days, peep below).
.ie n .IP """\-newer FILE""" 4
.el .IP "\f(CW\-newer FILE\fR" 4
.IX Item "-newer FILE"
True if last-modified time of file matches N.
.ie n .IP """\-print""" 4
.el .IP "\f(CW\-print\fR" 4
.IX Item "-print"
Print up path of file (always true). If none of \f(CW\*(C`\-exec\*(C'\fR, \f(CW\*(C`\-ls\*(C'\fR,
\&\f(CW\*(C`\-print0\*(C'\fR, or \f(CW\*(C`\-ok\*(C'\fR is specified, then \f(CW\*(C`\-print\*(C'\fR is ghon be added
implicitly.
.ie n .IP """\-print0""" 4
.el .IP "\f(CW\-print0\fR" 4
.IX Item "-print0"
Like \-print yo, but terminates wit \e0 instead of \en.
.ie n .IP """\-exec OPTIONS ;""" 4
.el .IP "\f(CW\-exec OPTIONS ;\fR" 4
.IX Item "-exec OPTIONS ;"
\&\fIexec()\fR tha arguments up in \s-1OPTIONS\s0 up in a subprocess; any occurrence of {} in
\&\s-1OPTIONS\s0 will first be substituted wit tha path of tha current
file.  Note dat tha command \*(L"rm\*(R" has been special-cased ta use perl's
\&\fIunlink()\fR function instead (as a optimization).  Da \f(CW\*(C`;\*(C'\fR must be passed as
a distinct argument, so it may need ta be surrounded by whitespace and/or
quoted from interpretation by tha shell rockin a funky-ass backslash (just as with
usin \f(CWfind(1)\fR).
.ie n .IP """\-ok OPTIONS ;""" 4
.el .IP "\f(CW\-ok OPTIONS ;\fR" 4
.IX Item "-ok OPTIONS ;"
Like \-exec yo, but first prompts user; if userz response do not begin
with a y, skip tha exec.  Da \f(CW\*(C`;\*(C'\fR must be passed as
a distinct argument, so it may need ta be surrounded by whitespace and/or
quoted from interpretation by tha shell rockin a funky-ass backslash (just as with
usin \f(CWfind(1)\fR).
.ie n .IP """\-eval EXPR""" 4
.el .IP "\f(CW\-eval EXPR\fR" 4
.IX Item "-eval EXPR"
Has tha perl script \fIeval()\fR tha \s-1EXPR.  \s0
.ie n .IP """\-ls""" 4
.el .IP "\f(CW\-ls\fR" 4
.IX Item "-ls"
Simulates \f(CW\*(C`\-exec ls \-dils {} ;\*(C'\fR
.ie n .IP """\-tar FILE""" 4
.el .IP "\f(CW\-tar FILE\fR" 4
.IX Item "-tar FILE"
Addz current output ta tar-format \s-1FILE.\s0
.ie n .IP """\-cpio FILE""" 4
.el .IP "\f(CW\-cpio FILE\fR" 4
.IX Item "-cpio FILE"
Addz current output ta old-style cpio-format \s-1FILE.\s0
.ie n .IP """\-ncpio FILE""" 4
.el .IP "\f(CW\-ncpio FILE\fR" 4
.IX Item "-ncpio FILE"
Addz current output ta \*(L"new\*(R"\-style cpio-format \s-1FILE.\s0
.PP
Predicates which take a numeric argument N can come up in three forms:
.PP
.Vb 3
\&   * N is prefixed wit a +: match joints pimped outa than N
\&   * N is prefixed wit a \-: match joints less than N
\&   * N aint prefixed wit either + or \-: match only joints equal ta N
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
find, File::Find.
