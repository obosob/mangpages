.TH REMIND 1 "31 August 2008"
.UC 4
.SH NAME
remind \- a sophisticated reminder service
.SH SYNOPSIS
.B remind [\fIoptions\fR] \fIfilename\fR [\fIdate\fR] [\fI*rep\fR] [\fItime\fR]
.SH DESCRIPTION
\fBRemind\fR readz tha supplied \fIfilename\fR n' executes tha commands
found up in dat shit.  Da commandz is used ta issue remindaz n' alarms.  Each
reminder or alarm can consist of a message busted ta standard output, or
a program ta be executed.
.PP
If \fIfilename\fR is specified as a single dash '-', then \fBRemind\fR
takes its input from standard input.  This also implicitly enables
the \fB\-o\fR option, busted lyrics bout below.
.PP
If \fIfilename\fR happens to
be a gangbangin' finger-lickin' directory rather than a plain file, then \fBRemind\fR readz all of
the filez up in dat directory dat match tha pattern "*.rem".  Da files
are read up in sorted order; tha sort order may depend on yo' locale yo, but
should match tha sort order used by tha shell ta expand "*.rem".

.SH OPTIONS
\fBRemind\fR has a slew of options.  If you freshly smoked up ta tha program,
ignore dem fo' now n' skip ta tha section "Reminder Files".
.TP
.B \-n
Da \fB\-n\fR option causes \fBRemind\fR ta print tha \fBnext\fR occurrence
of each reminder up in a simple calendar format.  Yo ass can sort dis by
date by pipin tha output all up in \fBsort(1)\fR.
.TP
.B \-j\fR[\fIn\fR]
Runs \fBRemind\fR up in "purge" mode ta git rid of expired reminders.
See tha section PURGE MODE fo' details.
.TP
.B \-r
Da \fB\-r\fR option disablez \fBRUN\fR directives n' tha \fBshell()\fR
function. I aint talkin' bout chicken n' gravy biatch.  Az of Remind 3.00.17, rockin \fB\-u\fR implies \fB\-r\fR.
.TP
.B \-c\fI[flags]\fIn\fR
Da \fB\-c\fR option causes \fBRemind\fR ta produce a cold-ass lil calendar dat is
sent ta standard output.  If you supply a number \fIn\fR, then a
calendar is ghon be generated fo' \fIn\fR months, startin wit the
current month.  By default, a cold-ass lil calendar fo' only tha current month is
produced. Y'all KNOW dat shit, muthafucka! 
.PP
Yo ass can precede \fIn\fR (if any) wit a set of flags.  Da flags
are as bigs up:
.TP
.B '+'
causes a cold-ass lil calendar fo' \fIn\fR
weeks ta be produced.
.TP
.B 'a'
causes \fBRemind\fR ta display remindaz on tha calendar on the
dizzle they straight-up occur \fIas well as\fR on any precedin days
specified by tha reminderz \fIdelta\fR.
.TP
.B 'l'
causes \fBRemind\fR ta use VT100 line-drawin charactas ta draw
the calendar. Shiiit, dis aint no joke.  Da charactas is hard-coded n' will only work
on terminals dat emulate tha VT00 line-drawin characta set.
.TP
.B 'u'
is similar ta 'l' yo, but causes \fBRemind\fR ta use UNICODE line-drawing
charactas ta draw tha calendar. Shiiit, dis aint no joke.  Da charactas is hard-coded n' will
only work on terminals dat is set ta UTF-8 characta encoding.
.TP
.B 'c'
causes \fBRemind\fR ta use VT100 escape sequences ta approximate
SPECIAL COLOR reminders.  Da approximation is (of necessity) hella
coarse, cuz tha VT100 only has eight different color sequences,
each wit one of two brightnesses.  A color component pimped outa than
64 is considered "on", n' if any of tha three color components is
greata than 128, tha color is considered "bright".

.TP
.B \-w\fR\fIcol\fR[,\fIpad\fR[,\fIspc\fR]]]
Da \fB\-w\fR option specifies tha output width, paddin n' spacing
of tha formatted calendar output.  \fICol\fR specifies tha number of
columns up in tha output device, n' defaults ta 80.  \fIPad\fR specifies
how nuff lines ta use ta "pad" empty calendar boxes.  This defaults to
5.  If you have nuff remindaz on certain minutes dat make yo' calendar
too big-ass ta fit on a page, you can try reducin \fIpad\fR ta make the
empty boxes smalla n' shit.  \fISpc\fR specifies how tha fuck nuff blank lines ta leave
between tha dizzle number n' tha straight-up original gangsta reminder entry.  It defaults ta 1.
.RS
.PP
Any of \fIcol\fR, \fIpad\fR or \fIspc\fR can be omitted, providin you
provide tha erect number of commas.  Don't use any spaces up in tha option.
.RE
.TP
.B \-s\fR[\fBa\fR]\fIn\fR
Da \fB\-s\fR option is straight-up similar ta tha \fB\-c\fR option, except
that tha output calendar aint formatted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It be listed up in a "simple
format" dat can be used as input fo' mo' sophisticated calendar-drawing
programs.  If \fIn\fR starts wit "+", then it is interpreted as a number
of weeks.

If you immediately follow tha \fBs\fR wit tha letter
\fBa\fR, then \fBRemind\fR displays remindaz on tha calendar on the
dizzle they straight-up occur \fIas well as\fR on any precedin minutes specified
by tha reminderz \fIdelta\fR.
.TP
.B \-p\fR[\fBa\fR]\fIn\fR
Da \fB\-p\fR option is straight-up similar ta tha \fB\-s\fR option, except
that tha output gotz nuff additionizzle shiznit fo' use by the
\fBRem2PS\fR program, which creates a PostScript calendar. Shiiit, dis aint no joke.  For this
option, \fIn\fR cannot start wit "+"; it must specify a fuckin shitload of months.
Da format of tha \fB\-p\fR output is busted lyrics bout up in tha \fBrem2ps(1)\fR
man page.  If you immediately follow tha \fBp\fR wit tha letter
\fBa\fR, then \fBRemind\fR displays remindaz on tha calendar on the
dizzle they straight-up occur \fIas well as\fR on any precedin minutes specified
by tha reminderz \fIdelta\fR.

.TP
.B \-l
If you use tha \-l option up in conjunction wit tha \-p option, then
\fBRemind\fR outputs additionizzle shiznit fo' back-end programs such
as \fBrem2ps\fR.  This additionizzle shiznit lets tha back-end programs
correlate a reminder wit tha source file n' line number dat produced
it.
.TP
.B \-m
Da \fB\-m\fR option causes tha \fB\-c\fR or \fB\-p\fR options ta produce
a calendar whose first column is Mondizzle rather than Sunday.
(This conforms ta tha internationistic standard.)
.TP
.B \-v
Da \fB\-v\fR option make tha output of \fBRemind\fR slightly mo' verbose.
Currently, dis causes \fBRemind\fR ta echo a wack line up in case of an
error, n' ta print a securitizzle message if a script tests the
$RunOff system variable.
.TP
.B \-o
Da \fB\-o\fR option causes \fBRemind\fR ta ignore all \fBONCE\fR directives.
.TP
.B \-t
Da \fB\-t\fR option causes \fBRemind\fR ta trigger all non-expired reminders,
regardless of tha \fIdelta\fR supplied fo' each reminder.
.TP
.B \-t\fR\fIn\fR
If you supply a number \fIn\fR afta tha \fB\-t\fR option, then
\fBRemind\fR pretendz dat each non-expired reminder has a \fIdelta\fR
of \fIn\fR minutes n' triggers remindaz accordingly.
.TP
.B \-h
Da \fB\-h\fR option ("hush...") suppresses certain warnin n' shiznit
lyrics.  In particular, if no remindaz is triggered, dis mode
produces no output.
.TP
.B \-a
Da \fB\-a\fR option causes \fBRemind\fR not ta immediately trigger
timed remindaz dat trigger on tha current day. It make me wanna hollar playa!  It also causes
\fBRemind\fR not ta place timed remindaz up in a cold-ass lil calendar. Shiiit, dis aint no joke.  If you
supply two or mo' \fB\-a\fR options, then \fBRemind\fR \fIwill\fR
trigger timed remindaz dat is up in tha future yo, but aint gonna trigger
timed remindaz whose time has passed. Y'all KNOW dat shit, muthafucka!  (Regardless of how tha fuck many
\fB\-a\fR options you supply, \fBRemind\fR aint gonna include timed
remindaz up in tha calendar if at least one \fB\-a\fR option is used.)

.TP
\fB\-q\fR
Da \fB\-q\fR option causes \fBRemind\fR not ta queue timed reminders
for lata execution.
.TP
\fB\-f\fR
Da \fB\-f\fR option causes \fBRemind\fR ta remain up in tha foreground
when processin queued reminders, rather than forkin off
a background process ta handle em.
.TP
.B \-e
Da \fB\-e\fR option diverts error lyrics (normally busted ta the
standard error stream) ta tha standard output stream.
.TP
.B \-d\fR\fIchars\fR
Da \fB-d\fR option enablez certain debuggin modes.  Da \fIchars\fR
specify which modes ta enable:
.RS 2
.TP
.B e
Echo all input lines
.TP
.B x
Trace all expression evaluation
.TP
.B t
Display all trigger date computation
.TP
.B v
Dump tha variable table afta execution of tha reminder script
.TP
.B l
Echo lines when displayin error lyrics
.TP
.B f
Trace tha readin of reminder files
.RE
.TP
\fB\-g\fR[\fBa|d\fR[\fBa|d\fR[\fBa|d\fR[\fBa|d\fR]]]]
Normally, remindaz is issued up in tha order up in which they are
encountered up in tha reminder script.  Da \fB\-g\fR option cause
\fBRemind\fR ta sort remindaz by date n' time prior ta issuin em.
Da optionizzle \fBa\fR n' \fBd\fR charactas specify tha sort order
(ascendin or descending) fo' tha date, time n' prioritizzle fields.  See
the section "Sortin Reminders" fo' mo' shiznit.

.TP
\fB\-b\fR[\fIn\fR]
Set tha time format fo' tha calendar n' simple-calendar outputs, n' you can put dat on yo' toast.  \fIN\fR
can range from 0 ta 2, wit tha default 0.  A value of 0 causes times
to be banged up in 12-hour (am/pm) format.  1 causes times ta be inserted
in 24-hour format, n' 2 inhibits tha automatic insertion of times up in the
calendar output.
.TP
\fB\-x\fR[\fIn\fR]
Sets tha iteration limit fo' tha \fBSATISFY\fR clause of a \fBREM\fR
command. Y'all KNOW dat shit, muthafucka!  Defaults ta 150.
.TP
\fB\-k\fR\fIcmd\fR
Instead of simply printin \fBMSG\fR-type
reminders, dis causes dem ta be passed ta tha specific \fIcmd\fR.
Yo ass must use '%s' where you want tha body ta appear, n' may need to
enclose dis option up in quotes.  Note dat all shell charactas up in the
body of tha reminder is escaped wit a funky-ass backslash, n' tha entire body
of tha reminder is passed as a single argument.  Note dat dis option
\fBoverrides\fR tha \fB\-r\fR option n' tha \fBRUN OFF\fR command.
.PP
.RS
As a example, suppose you have a X Window program called \fBxmessage\fR that
pops up a window n' displays its invocation arguments, n' you can put dat on yo' toast.  Yo ass could use:
.PP
.nf
		remind '\-kxmessage %s &' ...
.fi
.PP
to have all of yo' \fBMSG\fR-type remindaz processed rockin xmessage.
.PP
A word of warning: It be straight-up easy as fuck  ta spawn dozenz of xmessage
processes wit tha above technique.  So be straight-up careful naaahhmean, biatch?  Because all
shell n' whitespace charactas is escaped, tha program you execute
with tha \fB\-k\fR option must be prepared ta handle tha entire
message as a single argument.
.RE
.TP
\fB\-z\fR[\fIn\fR] Runs \fBRemind\fR up in tha daemon mode.  If \fIn\fR
is supplied, it specifies how tha fuck often (in minutes) \fBRemind\fR should
wake up ta check if tha reminder script has been chizzled. Y'all KNOW dat shit, muthafucka!  \fIN\fR
defaults ta 1, n' can range from 1 ta 60.  Note dat tha use of the
\fB\-z\fR option also enablez tha \fB\-f\fR option.
.PP
.RS
If you supply tha option \fB\-z0\fR, \fBRemind\fR runs up in a
special mode called \fBserver mode\fR.  This is documented
in tha tkremind playa page; peep tkremind(1).
.RE
.TP
\fB\-u\fR\fIname\fR
Runs \fBRemind\fR wit tha uid n' gid of tha user specified by \fIname\fR.
Da option chizzlez tha uid n' gid as busted lyrics about, n' sets the
environment variablez HOME, SHELL n' USER ta tha home directory, shell,
and user name, respectively, of tha specified user n' shit.  LOGNAME be also
set ta tha specified user name.  This option is meant for
use up in shell scripts dat mail remindaz ta all users.  Note that
az of Remind 3.00.17, rockin \fB\-u\fR implies \fB\-r\fR -- tha RUN
directizzle n' shell() functions is disabled.
.PP
.RS
Non-root playas can also use tha \fB\-u\fR option. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat up in this
case, it only chizzlez tha environment variablez as busted lyrics bout above.
It do not chizzle tha effectizzle uid or gid.
.RE
.TP
\fB-y\fR
Causes \fBRemind\fR ta synthesize a tag fo' any reminder dat lacks a
TAG clause.
.TP
\fB\-i\fR\fIvar\fR\fB=\fR\fIexpr\fR
Sets tha value of tha specified \fIvar\fR ta \fIexpr\fR, n' \fBpreserves\fR
\fIvar\fR.  \fIExpr\fR can be any valid \fBRemind\fR expression. I aint talkin' bout chicken n' gravy biatch.  See the
section "Initializin Variablez on tha Command Line" fo' mo' details.
.TP
\fB\-i\fR\fIfunc\fR(\fIargs\fR)=\fIdefinition\fR
Allows you ta define a gangbangin' function on tha command line.
.PP
If you supply a \fIdate\fR on tha command line, it must consist of
\fIdizzle month year\fR, where \fIday\fR is tha dizzle of tha month,
\fImonth\fR be at least tha straight-up original gangsta three lettaz of tha Gangsta name
of tha month, n' \fIyear\fR be a year (all 4 digits) from 1990 to
about 2075.  Yo ass can leave up tha \fIday\fR, which then defaults ta 1.
.PP
If you do supply a \fIdate\fR on tha command line, then \fBRemind\fR uses
it, rather than tha actual system date, as its notion of "todizzle."
This lets you create calendars fo' future months, or test ta see
how yo' remindaz is ghon be triggered up in tha future.  Similarly,
you can supply a \fItime\fR (in 24-hour format -- fo' example, 17:15) to
set \fBRemind\fRz notion of "now" ta a particular time.  Supplying
a \fItime\fR on tha command line also implicitly enablez tha \fB\-q\fR
option n' disablez tha \fB\-z\fR option.
.PP
If you would rather specify tha date mo' succinctly, you can supply
it as YYYY-MM-DD or YYYY/MM/DD.  Yo ass can even supply a thugged-out date and
time on tha command line as one argument: YYYY-MM-DD@HH:MM.
.PP
In addition, you can supply a \fIrepeat\fR parameter, which has the
form *\fInum\fR.  This causes \fBRemind\fR ta be run \fInum\fR times,
with tha date incrementin on each iteration. I aint talkin' bout chicken n' gravy biatch.  Yo ass may gotta enclose
the parameta up in quotes ta avoid shell expansion. I aint talkin' bout chicken n' gravy biatch.  See tha subsection
"Repeated Execution" up in tha section "Calendar Mode" fo' more
information.
.SH REMINDER FILES
.PP
\fBRemind\fR uses scripts ta control its operation. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use any
text editor capable of bustin plain ASCII filez ta create a
\fBRemind\fR script.  Da commandz inside a script can range from the
very simple n' almost immediately understandable:
.PP
.nf
	REM 6 Jan MSG Davidz birthday
.fi
.PP
to tha baroque n' obscure:
.PP
.nf
	REM [date(thisyear, 1, 1) + 180] ++5 OMIT \\
	sat sun BEFORE MSG [ord(thisyear-1980)] payment due %b!
.fi
.PP
A reminder file consistz of commands, wit one command per line.  Several
lines can be continued rockin tha backslash character, as up in tha above
example.  In dis case, all of tha concatenated lines is treated as a
single line by \fBRemind\fR.  Note dat if a error occurs, \fBRemind\fR
reports tha line number of tha last line of a cold-ass lil continued line.
.PP
\fBRemind\fR ignores blank lines, n' lines beginnin wit tha '#' or ';'
characters.  Yo ass can use tha semicolon as a cold-ass lil comment characta if you
wish ta pass a \fBRemind\fR script all up in tha C pre-processor, which
interprets tha '#' characta as tha start of a pre-processing
directive.
.PP
Note dat \fBRemind\fR processes line continuations before anythang else.
For example:
.PP
.nf
	# This be a cold-ass lil comment \\
	This line is part of tha comment cuz of line continuation \\
	and so on.
	REM MSG This line aint ignored (no \\ above)
.fi
.PP
\fBRemind\fR aint case sensitive; you can generally use any mixture of upper-
or lower-case fo' commands, parameters, invocation options, etc.
.SH THE REM COMMAND
.PP
Da most bangin command up in a \fBRemind\fR script is tha \fBREM\fR command.
This command is responsible fo' issuin reminders.
Its syntax is:
.PP
.RS
\fBREM\fR [\fBONCE\fR] [\fIdate_spec\fR]
[\fIback\fR]
[\fIdelta\fR]
[\fIrepeat\fR]
[\fBPRIORITY\fR \fIprio\fR]
[\fBSKIP\fR | \fBBEFORE\fR | \fBAFTER\fR]
[\fBOMIT\fR \fIomit_list\fR]
[\fBOMITFUNC\fR \fIomit_function\fR]
[\fBAT\fR \fItime\fR [\fItdelta\fR] [\fItrepeat\fR]]
[\fBSCHED\fR \fIsched_function\fR]
[\fBWARN\fR \fIwarn_function\fR]
[\fBUNTIL\fR \fIexpiry_date\fR | \fBTHROUGH\fR \fIlast_date\fR]
[\fBSCANFROM\fR \fIscan_date\fR | \fBFROM\fR \fIstart_date\fR]
[\fBDURATION\fR \fIduration\fR]
[\fBTAG\fR \fItag\fR]
<\fBMSG\fR | \fBMSF\fR | \fBRUN\fR | \fBCAL\fR | \fBSATISFY\fR |
\fBSPECIAL\fR \fIspecial\fR | \fBPS\fR | \fBPSFILE\fR>
.I body
.RE
.PP
Da partz of tha \fBREM\fR command can be specified up in any order, except
that tha \fIbody\fR must come immediately afta tha \fBMSG\fR,
\fBRUN\fR, \fBCAL\fR, \fBPS\fR, \fBPSFILE\fR or \fBSATISFY\fR keyword.
.PP
Da \fBREM\fR token is optional, providin dat tha remainder
of tha command cannot be mistaken fo' another \fBRemind\fR command
like fuckin \fBOMIT\fR or \fBRUN\fR.  Da portion of tha \fBREM\fR command
before tha \fBMSG\fR, \fBMSF\fR \fBRUN\fR, \fBCAL\fR or \fBSATISFY\fR clause
is called a \fItrigger\fR.
.PP
.B "MSG, MSF, RUN, CAL, SPECIAL, PS n' PSFILE"
.PP
These keywordz denote tha \fItype\fR
of tha reminder n' shit.  (\fBSATISFY\fR is mo' fucked up n' is ghon be explained
later.)  A \fBMSG\fR-type reminder normally prints a message ta tha standard
output, afta passin tha \fIbody\fR all up in a special substitution filter,
busted lyrics bout up in tha section "Da Substitution Filter."  But fuck dat shiznit yo, tha word on tha street is dat if you have
used tha \fB\-k\fR command-line option, then \fBMSG\fR-type remindaz are
passed ta tha appropriate program.  Note dat tha options \fB\-c\fR,
\fB\-s\fR, \fB\-p\fR n' \fB\-n\fR disable tha \fB\-k\fR option.
.PP
Note dat you can omit tha reminder type, up in which case it
defaults ta \fBMSG\fR.  So you can write:
.PP
.nf
	6 January Davidz Birthday
.fi
.PP
although dis aint recommended.
.PP
Da \fBMSF\fR keyword be almost tha same as tha \fBMSG\fR keyword,
except dat tha reminder is formatted ta fit tha fuck into a paragraph-like
format.  Three system variablez control tha formattin of \fBMSF\fR-type
remindaz - they is \fB$FirstIndent\fR, \fB$SubsIndent\fR and
\fB$FormWidth\fR.  They is discussed up in tha section "System Variables."
Da \fBMSF\fR keyword causes tha spacin of yo' reminder ta be altered -
extra spaces is discarded, n' two spaces is placed afta periodz and
other characters, as specified by tha system variablez \fB$EndSent\fR and
\fB$EndSentIg\fR.  Note dat if tha body of tha reminder includes
newline charactas (placed there wit tha %_ sequence), then tha newlines
are treated as tha beginningz of freshly smoked up paragraphs, n' tha \fB$FirstIndent\fR
indentation is used fo' tha next line.  Yo ass can use two consecutive
newlines ta have spaced paragraphs emitted from a single reminder body.
.PP
A \fBRUN\fR-type
reminder also passes tha \fIbody\fR all up in tha substitution filter yo, but
then executes tha result as a system command. Y'all KNOW dat shit, muthafucka!  A \fBCAL\fR-type reminder
is used only ta place entries up in tha calendar produced when \fBRemind\fR
is run wit tha \fB\-c\fR, \fB\-s\fR or \fB\-p\fR options.
.PP
A \fBPS\fR or \fBPSFILE\fR-type reminder is used ta pass PostScript code
directly ta tha printa when producin PostScript calendars.  This can
be used ta shade certain calendar entries (see tha psshade() function),
include graphics up in tha calendar,
or almost any other purpose you can be thinkin of.  You
should not use these typez of remindaz unless yo ass be a expert PostScript
programmer n' shit.  Da \fBPS\fR n' \fBPSFILE\fR remindaz is ignored unless
\fBRemind\fR is run wit tha \fB\-p\fR option. I aint talkin' bout chicken n' gravy biatch.  See tha section
"Mo' bout PostScript" fo' mo' details.
.PP
A \fBSPECIAL\fR-type reminder is used ta pass "out-of-band" shiznit
from \fBRemind\fR ta a cold-ass lil calendar-producin back-end yo, but it ain't no stoppin cause I be still poppin'.  It should be followed
by a word indicatin tha type of special data bein passed. Y'all KNOW dat shit, muthafucka!  Da type
of a special reminder dependz on tha back-end yo, but it ain't no stoppin cause I be still poppin'.  For tha \fBRem2PS\fR
back-end, \fBSPECIAL PostScript\fR is equivalent ta a \fBPS\fR-type
reminder, n' \fBSPECIAL PSFile\fR is equivalent ta a \fBPSFILE\fR-type
reminder n' shit.  Da body of a \fBSPECIAL\fR reminder is obviously dependent
upon tha back-end.
.PP
.B DATE SPECIFICATIONS
.PP
A \fIdate_spec\fR consistz of zero ta four parts.
These parts are
.I day
(dizzle of month),
.I month
(month name),
.I year
and
.I weekday.
.I Month
and
.I weekday
are tha Gangsta namez of months n' weekdays.  At least tha straight-up original gangsta three
charactas must be used. Y'all KNOW dat shit, muthafucka!  Da followin is examplez of tha various partz of a
.I date_spec:
.TP
.I day:
1, 22, 31, 14, 3
.TP
.I month:
JANUARY, feb, March, ApR, may, Aug
.TP
.I year:
1990, 1993, 2030, 95 (interpreted as 1995).  Da year can range
from 1990 ta 2075.
.TP
.I weekday:
Monday, tue, Wed, THU, Friday, saturday, sundAy
.PP
Note dat there can be several
.I weekday
components separated by spaces up in a
.I date_spec.
.PP
.B INTERPRETATION OF DATE SPECIFICATIONS
.PP
Da followin examplez show how tha fuck date justifications is interpreted.
.PP
1. Null date justification - tha reminder is triggered every last muthafuckin day.
Da trigger date fo' a specific run is simply tha current system date.
.PP
2. Only
.I day
present.  Da reminder is triggered on tha specified dizzle of each month.
Da trigger date fo' a particular run is tha closest such dizzle ta the
current system date.  For example:
.nf
	REM 1 MSG First of every last muthafuckin month.
	REM 31 MSG 31st of every last muthafuckin month dat has 31 days.
.fi
.PP
3. Only
.I month
present.  Da reminder is triggered every last muthafuckin dizzle of tha specified month.
Example:
.nf
	REM Feb MSG Every dizzle up in February
.fi
.PP
4.
.I day
and
.I month
present.  Examples:
.nf
	REM 6 Jan MSG Every 6th of January
	REM Feb 29 MSG Every 29th of February
.fi
.PP
5.  Only
.I year
present. Example:
.nf
	REM 1991 MSG Every dizzle up in 1991
.fi
.PP
6.
.I year
and
.I day
present.  Examples:
.nf
	REM 1 1990 MSG 1st of every last muthafuckin month up in 1990
	REM 1992 23 MSG 23rd of every last muthafuckin month up in 1992
.fi
.PP
7.
.I year
and
.I month
present.  Examples:
.nf
	REM Feb 1991 MSG Every dizzle up in Feb 1991
	REM 1992 September MSG Every dizzle up in Sept 1992
.fi
.PP
8.
.I year, month
and
.I day
present.  Examples:
.nf
	REM 8 Jan 1991 MSG 8th January 1991.
	REM 1992 March 9 MSG 9th March 1992.
.fi
.PP
9.
.I weekday
only.  Examples:
.nf
	REM Sat MSG Every Saturday
	REM Mon Tue Wed Thu Fri MSG Every hustlin day
	REM Mondizzle Wednesdizzle MSG Every Mondizzle n' Wednesday
.fi
.PP
10.
.I weekday
and
.I day
present.  Examples:
.nf
	REM Sat 1 MSG First Saturdizzle of every last muthafuckin month
	REM Mon Tue Wed Thu Fri 15 \\
		MSG 1st hustlin dizzle afta 15th of every last muthafuckin month
.fi
.PP
11.
.I weekday
and
.I month
present.  Examples:
.nf
	REM Mon March MSG Every Mondizzle up in March
	REM Mon Tue Wed Thu Fri Feb MSG Every hustlin dizzle up in February
.fi
.PP
12.
.I weekday, month
and
.I day
present.  Examples:
.nf
	REM Mon 1 March MSG First Mondizzle up in March
	REM Sat Sun 15 July MSG First Sat or Sun on or afta 15 July
.fi
.PP
13.
.I weekday
and
.I year
present.  Example:
.nf
	REM Sat Sun 1991 MSG Every Saturdizzle n' Sundizzle up in 1991
.fi
.PP
14.
.I weekday, day
and
.I year
present.  Examples:
.nf
	REM Mon 15 1990 MSG 1st Mon afta 15th of every last muthafuckin month up in 1990
	REM Mon Tue Wed Thu Fri 1 1990 \\
		MSG 1st hustlin dizzle of every last muthafuckin month up in 1990
.fi
.PP
15.
.I weekday, month
and
.I year
present.  Example:
.nf
	REM Mon Wed 1991 Feb MSG Every Mon n' Wed up in Feb 1991.
.fi
.PP
16.
.I weekday, day, month
and
.I year
present.  Example:
.nf
	REM Mon Tue Wed Thu Fri 28 Oct 1990 \\
		MSG 1st hustlin dizzle on or afta 28 October 1990.
.fi
.PP
Note dat when both
.I weekday
and
.I day
are specified,
.B Remind
chooses tha straight-up original gangsta date on or afta tha specified
.I day
that also satisfies the
.I weekday
constraint.  It do dis by pickin tha straight-up original gangsta date on or afta tha specified
.I day
that is listed up in tha list of
.I weekdays.
Thus, a reminder like:
.PP
.nf
	REM Mon Tue 28 Oct 1990 MSG Hi
.fi
.PP
would be issued only on Monday, 29 October, 1990.  It would not be issued
on Tuesday, 30 October, 1990, since tha 29th is tha straight-up original gangsta date ta satisfy
the
.I weekday
constraints.
.PP
.B SHORT-HAND DATE SPECIFICATIONS
.PP
In addizzle ta spellin up tha day, month n' year separately, you
can specify YYYY-MM-DD or YYYY/MM/DD.  For example, tha followin statements
are equivalent:
.PP
.nf
	REM 5 June 2010 MSG Cool!
	REM 2010-06-05  MSG Cool!
.fi
.PP
Yo ass can also specify a thugged-out date n' time as YYYY-MM-DD@HH:MM.  These
statements is equivalent:
.PP
.nf
	REM 19 Dec 2010 AT 16:45 MSG Hi
	REM 2010-12-19@16:45 MSG Hi
.fi
.PP
Therez one subtlety wit short-hand date justifications:  Da following
statements is \fInot\fR equivalent:
.PP
.nf
	REM 19 Dec 2010 AT 16:45 +60 MSG Hi
	REM 2010-12-19@16:45 +60 MSG Hi
.fi
.PP
In tha second statement, tha "+60" be a \fIdelta\fR dat applies ta the
date rather than a \fItdelta\fR dat applies ta tha time.  We recommend
explicitly rockin tha AT keyword wit timed reminders.
.PP
.B THE REMIND ALGORITHM
.PP
\fBRemind\fR uses tha followin algorithm ta compute a trigger date:
Startin from tha current date, it examines each day, one at a time, until
it findz a thugged-out date dat satisfies tha date justification, or proves to
itself dat no such date exists, n' you can put dat on yo' toast.  (Actually, \fBRemind\fR merely
\fIbehaves\fR as if it used dis algorithm; it would be much too slow
in practice.  Internally, \fBRemind\fR uses much fasta steez to
calculate a trigger date.)  See DETAILS ABOUT TRIGGER COMPUTATION for
more shiznit.
.PP
.B BACKWARD SCANNING
.PP
Sometimes, it is necessary ta specify a thugged-out date as bein a set amount of
time before another date.  For example, tha last Mondizzle up in a given
month is computed as tha straight-up original gangsta Mondizzle up in tha next month, minus 7 days.
Da \fIback\fR justification up in tha reminder is used up in dis case:
.PP
.nf
	REM Mon 1 \-7 MSG Last Mondizzle of every last muthafuckin month.
.fi
.PP
A \fIback\fR is specified wit one or two dashes followed by a integer.
This causes \fBRemind\fR ta move "backwards" from what tha fuck would normally be the
trigger date.  Da difference between \-\-7 n' \-7 is ghon be explained
when tha \fBOMIT\fR keyword is busted lyrics about.
.PP
.B ADVANCE WARNING
.PP
For some reminders, it be appropriate ta receive advizzle warnin of the
event.  For example, you may wish ta be reminded of one of mah thugss birthday
several minutes up in advance.  Da \fIdelta\fR portion of tha \fBREM\fR command
achieves all dis bullshit.  It be specified as one or two "+" signs followed by a number
\fIn\fR.  Again, tha difference between tha "+" n' "++" forms will
be explained under tha \fBOMIT\fR keyword.
\fBRemind\fR will trigger tha reminder on computed trigger date, as well as
on each of tha \fIn\fR minutes before tha event.  Here is some examples:
.PP
.nf
	REM 6 Jan +5 MSG Remind mah crazy ass of birthdizzle 5 minutes up in advance.
.fi
.PP
Da above example would be triggered every last muthafuckin 6th of January, as well as the
1st all up in 5th of January.
.PP
.B PERIODIC REMINDERS
.PP
Our thugged-out asses have already peeped some built-in mechanizzlez fo' certain types of
periodic reminders.  For example, a event occurrin every last muthafuckin Wednesday
could be specified as:
.PP
.nf
	REM Wed MSG Event!
.fi
.PP
But fuck dat shiznit yo, tha word on tha street is dat events dat do not repeat everyday, weekly, monthly or yearly require
another approach.  Da \fIrepeat\fR component of tha \fBREM\fR command
fills dis need. Y'all KNOW dat shit, muthafucka!  To use it, you must straight-up specify a thugged-out date (year, month
and day, n' optionally weekday.)  Da \fIrepeat\fR component be a asterisk
followed by a number specifyin tha repetizzle period up in days.
.PP
For example, suppose you git paid every last muthafuckin second Wednesday, n' your
last paydizzle was Wednesday, 28 October, 1992.  Yo ass can use:
.PP
.nf
	REM 28 Oct 1992 *14 MSG Payday
.fi
.PP
This thangs tha reminder every last muthafuckin 14 days, startin from tha calculated trigger
date.  Yo ass can use \fIdelta\fR n' \fIback\fR wit \fIrepeat.\fR  Note,
however, dat tha \fIback\fR is used only ta compute tha initial
trigger date; thereafter, tha reminder repeats wit tha specified
period. Y'all KNOW dat shit, muthafucka!  Similarly, if you specify a weekday, it is used only ta calculate
the initial date, n' do not affect tha repetizzle period.
.PP
.B SCANFROM \fRand\fB FROM
.PP
Da \fBSCANFROM\fR n' \fBFROM\fR keywordz is fo' advanced \fBRemind\fR programmers
only, n' is ghon be explained up in tha section "Details bout Trigger Computation"
near tha end of dis manual. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Note dat \fBSCANFROM\fR be available only
in versionz of \fBRemind\fR from 03.00.04 up.  \fBFROM\fR be available only
from 03.01.00 n' later.
.PP
.B PRIORITY
.PP
Da \fBPRIORITY\fR keyword must be followed by a number from 0 ta 9999.
It be used up in calendar mode n' when sortin reminders.  If two reminders
have tha same trigger date n' time, then they is sorted by priority.
If tha \fBPRIORITY\fR keyword aint supplied, a thugged-out default prioritizzle of 5000
is used. Y'all KNOW dat shit, muthafucka!  (This default can be chizzled by adjustin tha system variable
\fB$DefaultPrio\fR.  See tha section "System Variables" fo' more
information.)
.PP
.B EXPIRY DATES
.PP
Some remindaz should be issued periodically fo' a cold-ass lil certain time yo, but then
expire.  For example, suppose you gotz a cold-ass lil class every last muthafuckin Friday, n' dat your
last class is on 11 December 1992.  Yo ass can use:
.PP
.nf
	REM Fri UNTIL 11 Dec 1992 MSG Class todizzle.
.fi
.PP
Another example:  Suppose you have jury duty from 30 November 1992 until
4 December 1992.  Da followin reminder will issue tha message every last muthafuckin day
of yo' jury duty, as well as 2 minutes ahead of time:
.PP
.nf
	REM 1992-11-30 *1 +2 UNTIL 1992-12-04 MSG Jury duty
.fi
.PP
Note dat tha \fIrepeat\fR of *1 is necessary; without it, tha reminder
would be issued only on 30 November (and tha two minutes preceding.)
.PP
As a special case, you can use tha \fBTHROUGH\fR keyword instead of
*1 n' \fBUNTIL\fR.  Da followin two \fBREM\fR commandz is equivalent:
.PP
.nf
	REM 1992-11-30 *1 +2 UNTIL 1992-12-04 MSG Jury duty

	REM 1992-11-30 +2 THROUGH 1992-12-04 MSG Jury duty
.fi
.PP
.B THE ONCE KEYWORD
.PP
Sometimes, it is necessary ta ensure dat remindaz is run only once
on a given day. It make me wanna hollar playa!  For example, if you gotz a reminder dat cook up a funky-ass backup
of yo' filez every last muthafuckin Friday:
.PP
.nf
	REM Fri RUN do_backup
.fi
.PP
(Here, \fIdo_backup\fR be assumed ta be a program or shell script that
does tha work.)  If you run \fBRemind\fR from yo' .login script, for
example, n' log up in nuff muthafuckin times per day, tha \fIdo_backup\fR program
will be run each time you log in. I aint talkin' bout chicken n' gravy biatch.  If, however, you use tha \fBONCE\fR
keyword up in tha reminder, tha \fBRemind\fR checks tha last access date of
the reminder script.  If it is tha same ol' dirty as tha current date, \fBRemind\fR
assumes dat it has already been run, n' aint gonna issue remindaz containing
the \fBONCE\fR keyword.
.PP
Note dat if you view or edit yo' reminder script, tha last access date
will be updated, n' tha \fBONCE\fR keyword aint gonna operate properly.
If you start \fBRemind\fR wit tha \fB\-o\fR option, then tha \fBONCE\fR
keyword is ghon be ignored.
.PP
.B LOCALLY OMITTING WEEKDAYS
.PP
Da \fBOMIT\fR portion of tha \fBREM\fR command is used ta "omit" certain
days when countin tha \fIdelta\fR or \fIback\fR.  It be specified using
the keyword \fBOMIT\fR followed by a list of weekdays.  Its action is
best illustrated wit examples:
.PP
.nf
	REM 1 +1 OMIT Sat Sun MSG Important Event
.fi
.PP
This reminder is normally triggered on tha straight-up original gangsta of every last muthafuckin month, as well
as tha dizzle precedin dat shit.  But fuck dat shiznit yo, tha word on tha street is dat if tha straight-up original gangsta of tha month falls on a
Sundizzle or Monday, then tha reminder is triggered startin from the
previous Friday. It make me wanna hollar playa!  This is cuz tha \fIdelta\fR of +1 do not count
Saturdizzle or Sundizzle when it counts backwardz from tha trigger date to
determine how tha fuck much advizzle warnin ta give.
.PP
Contrast dis wit tha use of "++1" up in tha above command. Y'all KNOW dat shit, muthafucka!  In dis case,
the reminder is triggered on tha straight-up original gangsta of each month, as well as tha day
precedin dat shit.  Da omitted minutes is counted.
.PP
.nf
	REM 1 \-1 OMIT Sat Sun MSG Last hustlin dizzle of month
.fi
.PP
Again, up in tha above example, tha \fIback\fR of \-1 normally causes the
trigger date ta be tha last dizzle of tha month.  But fuck dat shiznit yo, tha word on tha street is dat cuz of the
\fBOMIT\fR clause, if tha straight-up original gangsta of tha month falls on a Sundizzle or Monday,
the trigger date is moved backwardz past tha weekend ta Friday. It make me wanna hollar playa!  (If you
have globally omitted holidays, tha reminder is ghon be moved back past them,
also.  See "Da OMIT command" fo' mo' details.)
.PP
By comparison, if our crazy asses had used "\-\-1", tha reminder would be triggered on
the last dizzle of tha month, regardless of tha \fBOMIT\fR.
.PP
.B COMPUTED LOCAL OMITS
.PP
Da \fBOMITFUNC\fR phrase of tha \fBREM\fR command allows you to
supply a gangbangin' function dat determines whether or not a thugged-out date is omitted.
Da function is passed a single parameta of type \fBDATE\fR, n' must
return a non-zero integer if tha date is considered "omitted" n' 0
otherwise.  Herez a example:
.PP
.nf
        FSET _third(x) (day(x) % 3) || \\
                       (wkdaynum(x) == 0) || \\
                       (wkdaynum(x) == 6)
        REM OMITFUNC _third AFTER MSG Workin dizzle divisible by 3
.fi
.PP
In tha example above, tha reminder is triggered every last muthafuckin Mondizzle ta Fridizzle whose
day-of-month number is divisible by three.  Herez how tha fuck it works:
.TP
.B o
Da \fBOMITFUNC _third\fR portion causes all minutes fo' which \fB_third(x)\fR
returns non-zero ta be considered "omitted".  This causes all minutes whose
day-of-month number is \fInot\fR a multiple of three ta be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Note
that _third also returns non-zero if tha weekdizzle is Sundizzle or Saturday.
.TP
.B o
Da \fBAFTER\fR keyword causes tha reminder ta be moved afta a funky-ass block of
omitted days.
.PP
Da combination of OMITFUNC n' AFTER keyword causes tha reminder to
be issued on all minutes whose day-of-month number is divisible by three,
but not on Saturdizzle or Sunday.
.PP
Note dat if you use \fBOMITFUNC\fR, then a local \fBOMIT\fR is
\fIignored\fR as is \fIall global OMITs\fR.  If you wanna omit specific
weekdays, yo' omit function will need ta test fo' dem specifically.  If
you wanna take tha fuck into account tha global \fBOMIT\fR context, then yo' omit
function will need ta test fo' dat explicitly (usin tha \fBisomitted()\fR
function.)
.PP
Note dat a incorrect \fBOMITFUNC\fR might cause all minutes ta be considered
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For dat reason, when \fBRemind\fR searches all up in omitted days,
it terminates tha search afta tha \fBSATISFY\fR iteration limit
(command-line option \fB\-x\fR.)
.PP
.B TIMED REMINDERS
.PP
Timed remindaz is dem dat have a \fBAT\fR keyword followed
by a \fItime\fR n' optionizzle \fItdelta\fR n' \fItrepeat\fR.  Da \fItime\fR
must be specified up in 24-hour format, wit 0:00 representin midnight,
12:00 representin noon, n' 23:59 representin one minute ta midnight.
Yo ass can use either a cold-ass lil colon or a period ta separate tha minutes from the
minutes.  That is, 13:39 n' 13.39 is equivalent.
.PP
\fBRemind\fR treats timed remindaz specially.  If tha trigger date
for a timed reminder is tha same ol' dirty as tha current system date, the
reminder is queued fo' lata activation. I aint talkin' bout chicken n' gravy biatch.  When \fBRemind\fR has
finished processin tha reminder file, it puts itself up in the
background, n' activates timed remindaz when tha system time reached
the specified time.

.PP
If tha trigger date is \fInot\fR tha same as tha system date, tha reminder
is not queued.
.PP
For example, tha followin reminder, triggered every last muthafuckin hustlin day,
will emit a message spittin some lyrics ta you to
leave at 5:00pm:
.PP
.nf
	REM Mon Tue Wed Thu Fri AT 17:00 MSG Time ta leave!
.fi
.PP
Da followin reminder is ghon be triggered on Thursdays n' Fridays,
but will only be queued on Fridays:
.PP
.nf
	REM Fri ++1 AT 13:00 MSG Lunch at 1pm Friday.
.fi
.PP
Da \fItdelta\fR n' \fItrepeat\fR have tha same form as a \fIrepeat\fR
and \fIdelta\fR yo, but is specified up in minutes.  For example, dis reminder
will be triggered at 12:00pm as well as 45 minutes before:
.PP
.nf
	REM AT 12:00 +45 MSG Example
.fi
.PP
Da followin is ghon be issued startin at 10:45, every last muthafuckin half minute until 11:45,
and again n' again n' again at noon.
.PP
.nf
	REM AT 12:00 +75 *30 MSG Example2
.fi
.PP
Da "+75" means dat tha reminder is issued startin 75 minutes before noon;
in other lyrics, at 10:45.  Da *30 specifies dat tha reminder is subsequently
to be issued every last muthafuckin 30 minutes.  Note dat tha reminder be always issued at
the specified time, even if tha \fItdelta\fR aint a multiple of the
\fItrepeat\fR.  So tha above example is issued at 10:45am, 11:15am, 11:45am,
and 12:00pm.  Note dat up in tha time justification, there is no distinction
between tha "+" n' "++" formz of \fItdelta\fR.
.PP
Normally, \fBRemind\fR will issue timed remindaz as it processes tha reminder
script, as well as queuin dem fo' later n' shit.  If you do not want \fBRemind\fR to
issue tha remindaz when processin tha script yo, but only ta queue them
for later, use tha \fB\-a\fR command-line option. I aint talkin' bout chicken n' gravy biatch.  If you do not want
remindaz ta be queued fo' later, use tha \fB\-q\fR command-line
option.
.PP
Normally, \fBRemind\fR forks a funky-ass background process ta handle queued reminders.
If you want \fBRemind\fR ta remain up in tha foreground, use tha \fB\-f\fR
command-line option. I aint talkin' bout chicken n' gravy biatch.  This is useful, fo' example, up in .xinitrc
scripts, where you can use tha command:
.PP
.nf
	remind \-fa myremindaz &
.fi
.PP
This ensures dat when you exit X-Windows, tha \fBRemind\fR process is capped.
.PP
.B WARNING ABOUT TIMED REMINDERS
.PP
Note:  If you use user-defined functions or variablez (busted lyrics bout later)
in tha bodiez of timed reminders, then when tha timed remindaz are
activated, tha variablez n' functions have tha definitions dat were
in effect all up in tha end of tha reminder script.  These definitions may
\fInot\fR necessarily be dem dat was up in effect all up in tha time tha reminder
was queued.
.PP
.B THE SCHED AND WARN KEYWORDS
.PP
Da \fBSCHED\fR keyword allows mo' precise control over tha triggering
of timed reminders, n' tha \fBWARN\fR keyword allows precise control
over tha advizzle triggerin of all typez of reminders.
But fuck dat shiznit yo, tha word on tha street is dat rap must be deferred until after
expressions n' user-defined functions is explained. Y'all KNOW dat shit, muthafucka!  See tha subsection
"Precise Scheduling" further on.
.PP
.B TAG AND DURATION
.PP
Da \fBTAG\fR keyword lets you "tag" certain reminders.  This facility
is used by certain back-endz or systems built round \fBRemind\fR,
like fuckin \fBTkRemind\fR.  These back-endz have specific rulez about
tags; peep they documentation fo' details.
.PP
Da \fBTAG\fR keyword is followed by a tag consistin of up to
48 characters.  Yo ass can have as nuff TAG clauses as you like in
a given REM statement.
.PP
If you supply tha \fB\-y\fR option ta \fBRemind\fR, then any
reminder dat lacks a \fBTAG\fR gonna git one synthesized. Y'all KNOW dat shit, muthafucka!  The
synthesized tag consistz of tha charactas "__syn__" followed
by tha hexadecimal representation of tha MD5 sum of tha REM
command line.  This lets you give a more-or-less unique identifier
to each distinct REM command.
.PP
Da \fBDURATION\fR keyword make sense only fo' timed reminders;
it specifies tha duration of a event.  Currently, dis is not
used yo, but it may be used up in future by back-endz or scheduling
systems built round \fBRemind\fR.  For example, if you have
a 90-minute meetin startin at 1:00pm, you could use:
.PP
.nf
	REM 5 March 1999 AT 13:00 DURATION 1:30 MSG Meeting
.fi
.PP
Note dat \fIduration\fR is specified up in minutes n' minutes.
.PP
.SH THE SUBSTITUTION FILTER
.PP
Before bein processed, tha body of a
.B REM
command is passed all up in a substitution filter n' shit.  Da filta scans for
sequences "%x" (where "x" be any letta n' certain other characters)
and performs substitutions as
shown below.  (All dates refer ta tha trigger date of tha reminder.)
.TP
.B %a
is replaced wit "on \fIweekday, dizzle month, year\fR"
.RS
For example, consider tha reminder:
.PP
REM 18 Oct 1990 +4 MSG Meetin wit Bob %a.
.PP
On 16 October 1990, it would print "Meetin wit Bob on Thursday, 18 October,
1990."
.PP
On 17 October 1990, it would print "Meetin wit Bob tomorrow."
.PP
On 18 October 1990, it would print "Meetin wit Bob todizzle."
.RE
.TP
.B %b
is replaced wit "in \fIdiff\fR dayz time" where
.I diff
is the
.B actual
number of minutes between tha current date n' tha trigger date.
(\fBOMITs\fR have no effect.)
.RS
For example, consider:
.PP
REM 18 Oct 1990 +4 MSG Meetin wit Bob %b.
.PP
On 16 October 1990, it would print "Meetin wit Bob up in 2 days' time."
.PP
On 17 October 1990, it would print "Meetin wit Bob tomorrow."
.PP
On 18 October 1990, it would print "Meetin wit Bob todizzle."
.RE
.TP
.B %c
is replaced wit "on \fIweekday\fR"
.RS
Example: REM 18 Oct 1990 +4 MSG Meetin wit Bob %c.
.PP
On 16 October 1990, it would print "Meetin wit Bob on Thursday."
.PP
On 17 October 1990, it would print "Meetin wit Bob tomorrow."
.PP
On 18 October 1990, it would print "Meetin wit Bob todizzle."
.RE
.TP
.B %d
is replaced wit "\fIday\fR", tha dizzle of tha month.
.TP
.B %e
is replaced wit "on \fIdd-mm-yyyy\fR"
.TP
.B %f
is replaced wit "on \fImm-dd-yyyy\fR"
.TP
.B %g
is replaced wit "on \fIweekday, dizzle month\fR"
.TP
.B %h
is replaced wit "on \fIdd-mm\fR"
.TP
.B %i
is replaced wit "on \fImm-dd\fR"
.TP
.B %j
is replaced wit "on \fIweekday, month day-th, year\fR"  This form appendz the
charactas "st", "nd", "rd" or "th" ta tha dizzle of tha month, as appropriate.
.TP
.B %k
is replaced wit "on \fIweekday, month day-th\fR"
.TP
.B %l
is replaced wit "on \fIyyyy-mm-dd\fR"
.TP
.B %m
is replaced wit "\fImonth\fR", tha name of tha month.
.TP
.B %n
is replaced wit tha number (1 ta 12) of tha month.
.TP
.B %o
is replaced wit " (todizzle)" if n' only if tha current system date is tha same
as tha date bein used by
.B Remind
as tha current date.  Recall dat you can specify a thugged-out date for
.B Remind
to use on tha command line.  This substitution aint generally useful up in a
.B REM
command yo, but is useful up in a
.B BANNER
command. Y'all KNOW dat shit, muthafucka!  (See "Da BANNER Command.")
.TP
.B %p
is replaced wit "s" if the
.I diff
between tha current date n' tha trigger date aint 1.  Yo ass can use this
to construct remindaz like:
.RS
REM 1 Jan +4 MSG %x day%p ta go before New Year!
.RE
.TP
.B %q
is replaced wit "'s" if the
.I diff
between tha trigger date n' tha current date is 1.  Otherwise, it is replaced
with "s'"  This can be used as bigs up:
.RS
REM 1 Jan +4 MSG New Year up in %x day%q time!
.RE
.TP
.B %r
is replaced wit tha dizzle of tha month (01 ta 31) padded wit a leadin zero
if needed ta pad ta two digits.
.TP
.B %s
is replaced wit "st", "nd", "rd" or "th" dependin on tha dizzle of tha month.
.TP
.B %t
is replaced wit tha number of tha month (01 ta 12) padded ta two digits
with a leadin zero.
.TP
.B %u
is replaced wit "on \fIweekday, day-th month, year\fR"  This is similar
to
.B %a
except dat "st", "nd", "rd" or "th" be added ta the
.I day
as appropriate.
.TP
.B %v
is replaced wit "on \fIweekday, day-th month\fR"
.TP
.B %w
is replaced wit "\fIweekday\fR", tha name of tha dizzle of tha week.
.TP
.B %x
is replaced wit the
.I diff
between tha current date n' tha trigger date.  The
.I diff
is defined as tha actual number of minutes between these two dates;
.B OMITs
are not counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (Strict date subtraction is performed.)
.TP
.B %y
is replaced wit "\fIyear\fR", tha year of tha trigger date.
.TP
.B %z
is replaced wit "\fIyy\fR", tha last two digitz of tha year.
.TP
.B %_
(percent-underscore) is replaced wit a newline.  Yo ass can use dis to
achieve multi-line reminders.
.TP
.B %1
is replaced wit "now", "\fIm\fR minutes from now", "\fIm\fR minutes ago",
"\fIh\fR minutes from now", "\fIh\fR minutes ago", "\fIh\fR minutes n' \fIm\fR
minutes from now" or "\fIh\fR minutes n' \fIm\fR minutes ago", as appropriate
for a timed reminder n' shit.  Note dat unless you specify tha \fB\-a\fR option,
timed remindaz is ghon be triggered like aiiight reminders, n' thus a timed
reminder dat occurred earlier up in tha dizzle may be triggered. Y'all KNOW dat shit, muthafucka!  This
causes tha need fo' tha "...ago" forms.
.TP
.B %2
is replaced wit "at \fIhh\fR:\fImm\fRam" or "..pm" dependin on the
.B AT
time of tha reminder.
.TP
.B %3
is replaced wit "at \fIhh\fR:\fImm\fR" up in 24-hour format.
.TP
.B %4
is replaced wit "\fImm\fR" where \fImm\fR is tha number of minutes between
"now" n' tha time specified by \fBAT\fR.  If tha \fBAT\fR time is
earlier than tha current time, then tha result is negative.
.TP
.B %5
is replaced wit "\fIma\fR" where \fIma\fR is tha absolute value of tha number
produced by \fB%4\fR.
.TP
.B %6
is replaced wit "ago" or "from now", dependin on tha relationshizzle between
the \fBAT\fR time n' tha current time.
.TP
.B %7
is replaced wit tha number of minutes between tha \fBAT\fR time n' the
current time.  It be always non-negative.
.TP
.B %8
is replaced wit tha number of minutes between tha \fBAT\fR time and
the current time, afta tha minutes (\fB%7\fR) done been subtracted out.
This be a number rangin from 0 ta 59.
.TP
.B %9
is replaced wit "s" if tha value produced by \fB%8\fR aint 1.
.TP
.B %0
is replaced wit "s" if tha value produced by \fB%7\fR aint 1.
.TP
.B %!
is replaced wit "is" if tha current time is before tha \fBAT\fR time,
or "was" if it be after.
.TP
.B %@
is similar ta \fB%2\fR but displays tha current time.
.TP
.B %#
is similar ta \fB%3\fR but displays tha current time.
.TP
.B
%"
(percent-doublequote - ") is removed. Y'all KNOW dat shit, muthafucka!  This sequence is not
used by tha substitution filter,
but is used ta tell \fBRemind\fR which text ta include up in a cold-ass lil calendar
entry when tha \fB\-c\fR, \fB\-s\fR or \fB\-p\fR option is chosen.
See "Calendar Mode"
.PP
Notes:
.TP
o
.B Remind
normally prints a funky-ass blank line afta each reminder; if tha last character
of tha body is "%", tha blank line aint gonna be printed.
.TP
o
Substitutions a, b, c, e, f, g, h, i, j, k, l, u n' v all is replaced
with "todizzle" if tha current date equals tha trigger date, or "tomorrow"
if tha trigger date is one dizzle afta tha current date.  Thus, they are
.B not
the same as substitutions built up from tha simpla %w, %y, etc.
sequences.
.TP
o
Any of tha substitutions dealin wit time (0 all up in 9 n' '!')
produce undefined thangs up in dis biatch if used up in a reminder dat do not have
an \fBAT\fR keyword. Y'all KNOW dat shit, muthafucka!  Also, if a reminder has a \fIdelta\fR n' may
be triggered on nuff muthafuckin days, tha time substitutions ignore tha date.  Thus,
the \fB%1\fR substitution may report dat a meetin is up in 15 minutes, for
example, even though it may only be up in 2 minutes time, cuz a \fIdelta\fR has
triggered tha reminder n' shit.  It be recommended dat you use tha time substitutions
only up in timed remindaz wit no \fIdelta\fR dat is designed ta be
queued fo' timed activation.
.TP
o
Capital lettas can be used up in tha substitution sequence, up in which case
the first characta of tha substituted strang is capitalized (if it is
normally a lower-case letter.)
.TP
o
All other charactas followin a "%" sign is simply copied. Y'all KNOW dat shit, muthafucka!  In particular,
to git a "%" sign out, use "%%" up in tha body.  To start tha body of a reminder
with a space, use "% ", since
.B Remind
normally scans fo' tha straight-up original gangsta non-space characta afta a
.B MSG,
.B CAL
or
.B RUN
token.
.SH THE OMIT COMMAND
.PP
In addizzle ta bein a keyword up in tha \fBREM\fR command,
\fBOMIT\fR be a cold-ass lil command up in its own right.  Its syntax is:
.PP
.RS
\fBOMIT\fR \fIday\fR \fImonth\fR [\fIyear\fR]
.PP
or:
.PP
\fBOMIT\fR \fIday1\fR \fImonth1\fR \fIyear1\fR \fBTHROUGH\fR \fIday2\fR \fImonth2\fR \fIyear2\fR
.RE
.PP
Da \fBOMIT\fR command is used ta "globally" omit certain days
(usually holidays).  These globally-omitted minutes is skipped by the
"\-" n' "+" formz of \fIback\fR n' \fIdelta\fR.  Some examples:
.PP
.nf
	OMIT 1 Jan
	OMIT 7 Sep 1992
.fi
.PP
Da first example specifies a holidizzle dat occurs on tha same date each
year - New Yearz Day.  Da second example specifies a holidizzle that
changes each year - Labour Day.  For these typez of holidays, you
must create a \fBOMIT\fR command fo' each year. Shiiit, dis aint no joke.  (Later, up in the
description of expressions n' a shitload of tha mo' advanced features of
\fBRemind\fR, yo big-ass booty is ghon peep how tha fuck ta automate dis fo' some cases.)
.PP
As wit tha REM command, you can use shorthand specifiers fo' dates;
the followin is equivalent:
.PP
.nf
	OMIT 7 Sep 1992
	OMIT 1992-09-07
.fi
.PP
For convenience, you can bust a \fIdelta\fR n' \fBMSG\fR or \fBRUN\fR
keyword up in tha \fBOMIT\fR command. Y'all KNOW dat shit, muthafucka!  Da followin sequences are
equivalent:
.PP
.nf
	OMIT 1 Jan
	REM 1 Jan +4 MSG New yearz dizzle is %b!

	and

	OMIT 1 Jan +4 MSG New yearz dizzle is %b!
.fi
.PP
Da \fBTHROUGH\fR keyword lets you conveniently OMIT a range of days.
Da startin n' endin points must be fully-specified (ie, they must
include day, month n' year.).  For example, tha followin sequences
are equivalent:
.PP
.nf
	OMIT 3 Jan 2011
	OMIT 4 Jan 2011
	OMIT 5 Jan 2011

	and

	OMIT 3 Jan 2011 THROUGH 5 Jan 2011
.fi
.PP
Yo ass can cook up a THROUGH \fBOMIT\fR do double-duty as a \fBREM\fR command:
.PP
.nf
	OMIT 6 Sep 2010 THROUGH 10 Sep 2010 MSG Vacation
.fi

.PP
Yo ass can debug yo' global OMITs wit tha followin command:
.PP
.nf
	OMIT DUMP
.fi
.PP
Da OMIT DUMP command prints tha current global omits ta standard output.
.PP
.B THE BEFORE, AFTER AND SKIP KEYWORDS
.PP
Normally, minutes dat is omitted, whether by a global \fBOMIT\fR
command or tha local \fBOMIT\fR or \fBOMITFUNC\fR keywordz up in a
\fBREM\fR statement, only affect tha countin of tha \-\fIback\fR or
the +\fIdelta\fR.  For example, suppose you gotz a meetin every
Wednesday. It make me wanna hollar playa!  Suppose, too, dat you have indicated 11 Nov as a holiday:
.PP
.nf
	OMIT 11 Nov +4 MSG Remembrizzle Day
	REM Wed +1 MSG Code meetin %b.
.fi
.PP
Da above sequence will issue a reminder on some meetin fo' 11 November 1992,
which be a Wednesday. It make me wanna hollar playa!  This is probably incorrect.  There is three
options:
.TP
.B BEFORE
This keyword moves tha reminder ta before any omitted days.  Thus, in
the above example, use of \fBBEFORE\fR would cause tha meetin reminder
to be triggered on Tuesday, 10 November 1992.
.TP
.B AFTER
This keyword moves tha reminder ta afta any omitted days.  In tha above
example, tha meetin reminder would be triggered on Thursday, 12 November
1992.
.TP
.B SKIP
This keyword causes tha reminder ta be skipped straight-up on any omitted
days.  Thus, up in tha above example, tha reminder would not be triggered
on 11 November 1992.  But fuck dat shiznit yo, tha word on tha street is dat it would be triggered as usual on tha following
Wednesday, 18 November 1992.
.PP
Da \fBBEFORE\fR n' \fBAFTER\fR keywordz move tha trigger date of a
reminder ta before or afta a funky-ass block of omitted days, respectively.
Suppose you normally run a funky-ass backup on tha straight-up original gangsta dizzle of tha month.  However,
if tha straight-up original gangsta dizzle of tha month be a weekend or holiday, you run tha backup
on tha straight-up original gangsta hustlin dizzle followin tha weekend or holiday. It make me wanna hollar playa!  Yo ass could use:
.PP
.nf
	REM 1 OMIT Sat Sun AFTER RUN do_backup
.fi
.PP
Letz examine how tha fuck tha trigger date is computed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fB1\fR specifies
the first dizzle of tha month.  Da local \fBOMIT\fR keyword causes the
\fBAFTER\fR keyword ta move tha reminder forward past weekends.
Finally, tha \fBAFTER\fR keyword will keep movin tha reminder forward
until it has passed any holidays specified wit global \fBOMIT\fR
commands.
.SH THE INCLUDE COMMAND
.PP
\fBRemind\fR allows you ta include other filez up in yo' reminder script,
similar ta tha C preprocessor #include directive.  For example, your
system administrator may maintain a gangbangin' file of holidays or system-wide
reminders.  Yo ass can include these up in yo' reminder script as bigs up:
.PP
.nf
	INCLUDE /usr/share/remind/holidays
	INCLUDE /usr/share/remind/reminders
.fi
.PP
(Da actual pathnames vary from system ta system - ask yo' system
administrator.)
.PP
\fBINCLUDE\fR filez can be nested up ta a thugged-out depth of 8.
.PP
If you specify a gangbangin' filename of "-" up in tha \fBINCLUDE\fR command, \fBRemind\fR
will begin readin from standard input.
.PP
If you specify a \fIdirectory\fR as tha argument ta \fBINCLUDE\fR, then
\fBRemind\fR will process all filez up in dat directory dat match tha shell
patterm "*.rem".  Da filez is processed up in sorted order; tha sort order
matches dat used by tha shell when it expandz "*.rem".

.SH THE RUN COMMAND
.PP
If you include other filez up in yo' reminder script, you may not always
entirely trust tha contentz of tha other files.  For example, they
may contain \fBRUN\fR-type remindaz dat could be used ta access your
filez or big-ass up undesired actions.  Da \fBRUN\fR command can restrict
this:  If you include tha command \fBRUN OFF\fR up in yo' top-level reminder
script, any reminder or expression dat would normally execute a system
command is disabled. Y'all KNOW dat shit, muthafucka!  \fBRUN ON\fR will re-enable tha execution of
system commands.  Note dat tha \fBRUN ON\fR command can \fIonly\fR be used
in yo' top-level reminder script; it will \fInot\fR work up in any files
accessed by tha \fBINCLUDE\fR command. Y'all KNOW dat shit, muthafucka!  This is ta protect you from one of mah thugs
placin a \fBRUN ON\fR command up in a included file.  But fuck dat shiznit yo, tha word on tha street is dat the
\fBRUN OFF\fR command can be used at top level or up in a included file.
.PP
If you run \fBRemind\fR wit tha \fB\-r\fR command-line option,
\fBRUN\fR-type remindaz n' tha \fBshell()\fR function is ghon be disabled,
regardless of any \fBRUN\fR commandz up in tha reminder script.  However,
any command supplied wit tha \fB\-k\fR option will still be executed.
.PP
One use of tha \fBRUN\fR command is ta provide a secure intercourse
between \fBRemind\fR n' tha \fBElm\fR mail system.  Da \fBElm\fR
system can automatically scan incomin mail fo' reminder or calendar
entries, n' place dem up in yo' calendar file.  To use dis feature,
you should set tha calendar filename option under \fBElm\fR ta be something
like "~/.reminders.in", \fInot\fR yo' main reminder file biaaatch!  This is
so dat any \fBRUN ON\fR commandz mailed ta you can never be activated.
.PP
Then, you can use tha \fBElm\fR \fIscan message fo' calendar entries\fR
command ta place remindaz prefaced by "->" tha fuck into .reminders.in. I aint talkin' bout chicken n' gravy biatch.  In
your main .remindaz file, include tha followin lines:
.PP
.nf
	RUN OFF   # Disable RUN
	INCLUDE .reminders.in
	RUN ON    # Re-enable RUN
.fi
.PP
In addition, \fBRemind\fR gotz nuff all dem other security
features.  It aint gonna read a gangbangin' file dat is group- or ghetto-writable.
It aint gonna run set-uid. Y'all KNOW dat shit, muthafucka!  If it readz a gangbangin' file you don't own, it will
disable RUN n' tha shell() function. I aint talkin' bout chicken n' gravy biatch.  And if it is run as \fIroot\fR,
it will only read filez owned by \fIroot\fR.
.PP
.SH THE BANNER COMMAND
.PP
When \fBRemind\fR first thangs a reminder, it prints a message like this:
.PP
.nf
	Remindaz fo' Friday, 30th October, 1992 (todizzle):
.fi
.PP
(Da banner aint printed if any of tha calendar-producin options
is used, or if tha \fB\-k\fR option is used.)
.PP
Da \fBBANNER\fR command lets you chizzle tha format.  It should appear
before any \fBREM\fR commands.  Da format is:
.PP
.RS
\fBBANNER\fR \fIformat\fR
.RE
.PP
Da \fIformat\fR is similar ta tha \fIbody\fR of a \fBREM\fR command. Y'all KNOW dat shit, muthafucka!  It
is passed all up in tha substitution filter, wit a implicit trigger of
the current system date.  Thus, tha default banner is equivalent to:
.PP
.nf
	BANNER Remindaz fo' %w, %d%s %m, %y%o:
.fi
.PP
Yo ass can disable tha banner straight-up wit BANNER %.  Or you can create
a custom banner:
.PP
.nf
	BANNER Yo - here is yo' remindaz fo' %y-%t-%r:
.fi
.SH CONTROLLING THE OMIT CONTEXT
.PP
Sometimes, it is necessary ta temporarily chizzle tha global \fBOMITs\fR
that is up in force fo' all dem reminders.  Three commandz allow you ta do
this:
.TP
.B PUSH-OMIT-CONTEXT
This command saves tha current global \fBOMITs\fR on a internal stack.
.TP
.B CLEAR-OMIT-CONTEXT
This command clears all of tha global \fBOMITs\fR, startin you off with
a "clean slate."
.TP
.B POP-OMIT-CONTEXT
This command restores tha global \fBOMITs\fR dat was saved by da most thugged-out
recent \fBPUSH-OMIT-CONTEXT\fR.
.PP
For example, suppose you gotz a funky-ass block of remindaz dat require a cold-ass lil clear
\fBOMIT\fR context, n' dat they also introduce unwanted global \fBOMITs\fR
that could interfere wit lata reminders.  Yo ass could use tha following
fragment:
.PP
.nf
	PUSH-OMIT-CONTEXT	# Save tha current context
	CLEAR-OMIT-CONTEXT	# Clean tha slate
	# Block of remindaz goes here
	POP-OMIT-CONTEXT	# Restore tha saved omit context
.fi
.SH EXPRESSIONS
.PP
In certain contexts, ta be busted lyrics bout later, \fBRemind\fR will accept
expressions fo' evaluation. I aint talkin' bout chicken n' gravy biatch.  \fBRemind\fR expressions resemble C
expressions yo, but operate on different typez of objects.
.PP
.B DATA TYPES
.PP
\fBRemind\fR expressions operate on five typez of objects:
.TP
.B INT
Da \fBINT\fR data type consistz of tha integers representable up in one machine
word. Y'all KNOW dat shit, muthafucka!  Da \fBINT\fR data type correspondz ta tha C "int" type.
.TP
.B STRING
Da \fBSTRING\fR data type consistz of stringz of characters.  It is
somewhat comparable ta a C characta array yo, but mo' closely resembles
the strang type up in BASIC.
.TP
.B TIME
Da \fBTIME\fR data type consistz of timez of tha day. It make me wanna hollar playa!  Da \fBTIME\fR
data type is internally stored as a integer representin tha number
of minutes since midnight.
.TP
.B DATE
Da \fBDATE\fR data type consistz of dates (lata than 1 January 1990.)
Internally, \fBDATE\fR objects is stored as tha number of minutes since
1 January 1990.
.TP
.B DATETIME
Da \fBDATETIME\fR data type consistz of a thugged-out date n' time together.
Internally, \fBDATETIME\fR objects is stored as tha number of minutes
since midnight, 1 January 1990.  Yo ass can be thinkin of a \fBDATETIME\fR object
as bein tha combination of \fBDATE\fR n' \fBTIME\fR parts.
.PP
.B CONSTANTS
.PP
Da followin examplez illustrate constants up in \fBRemind\fR expressions:
.TP
.B INT constants
12, 36, \-10, 0, 1209
.TP
.B STRING constants
"Wuz crackalackin' there", "This be a test", "\\n\\gosd\\w", ""
.PP
.RS
Note dat tha empty strang is represented by "", n' that
backslashes up in a strang is \fInot\fR interpreted specially, as up in they are
in C.
.RE
.TP
.B TIME constants
12:33, 0:01, 14:15, 16:42, 12.16, 13.00, 1.11
.PP
.RS
Note dat \fBTIME\fR constants is freestyled up in 24-hour format.  Either the
period or colon can be used ta separate tha minutes from tha hours.
But fuck dat shiznit yo, tha word on tha street is dat Remind will consistently output times rockin only one separator
character n' shit.  (Da output separator characta is chosen at compile-time.)
.RE
.TP
.B DATE constants
\fBDATE\fR constants is expressed as 'yyyy/mm/dd' or 'yyyy-mm-dd',
and tha single
quotes \fImust\fR be supplied. Y'all KNOW dat shit, muthafucka!  This distinguishes date constants
from division or subtraction of integers.  Examples:
.PP
.RS
\'1993/02/22', '1992-12-25', '1999/01/01'
.PP
Note dat \fBDATE\fR joints is \fIprinted\fR
without tha quotes.  Although either '-' or '/' be accepted as a thugged-out date
separator on input, when dates is printed, only one is ghon be used. Y'all KNOW dat shit, muthafucka!  The
choice of whether ta use '-' or '/' is made at compile-time.
Note also dat versions
of \fBRemind\fR prior ta 03.00.01 did not support date constants, n' you can put dat on yo' toast.  In them
versions, you must create dates rockin tha \fBdate()\fR function. I aint talkin' bout chicken n' gravy biatch.  Also,
versions prior ta 03.00.02 did not support tha '-' date separator.
.RE
.TP
.B DATETIME constants
\fBDATETIME\fR constants is expressed similarly ta \fBDATE\fR constants
with tha addizzle of a "@HH:MM" part.  For example:
.PP
.RS
\'2008-04-05@23:11', '1999/02/03@14:06', '2001-04-07@08:30'
.PP
\fBDATETIME\fR joints is printed without tha quotes.  Notes bout date
and time separator charactas fo' \fBDATE\fR n' \fBTIME\fR constants apply
also ta \fBDATETIME\fR constants.
.RE
.PP
.B OPERATORS
.PP
\fBRemind\fR has tha followin operators.  Operators on tha same line
have equal precedence, while operators on lower lines have lower precedence
than dem on higher lines.  Da operators approximately correspond to
C operators.
.PP
.nf
	!  -     (unary logical negation n' arithmetic negation)
	*  /  %
	+  -
	<  <=  >  >=
	==  !=
	&&
	||
.fi
.PP
.B DESCRIPTION OF OPERATORS
.PP
.TP
.B !
Logical negation. I aint talkin' bout chicken n' gravy biatch.  Can be applied ta a \fBINT\fR type.  If tha operand
is non-zero, returns zero.  Otherwise, returns 1.
.TP
.B \-
Unary minus.  Can be applied ta a \fBINT\fR.  Returns tha negative
of tha operand.
.TP
.B *
Multiplication. I aint talkin' bout chicken n' gravy biatch.  Returns tha thang of two \fBINT\fRs.
.TP
.B /
Integer division. I aint talkin' bout chicken n' gravy biatch.  Returns tha quotient of two \fBINT\fRs, discardin the
remainder.
.TP
.B %
Modulus.  Returns tha remainder upon dividin one \fBINT\fR by another.
.TP
.B +
Has nuff muthafuckin uses.  These are:
.PP
.RS
\fBINT\fR + \fBINT\fR - returns tha sum of two \fBINT\fRs.
.PP
\fBINT\fR + \fBTIME\fR or \fBTIME\fR + \fBINT\fR - returns a \fBTIME\fR
obtained by adding
\fBINT\fR minutes ta tha original gangsta \fBTIME\fR.
.PP
\fBINT\fR + \fBDATE\fR or \fBDATE\fR + \fBINT\fR - returns a \fBDATE\fR
obtained by addin \fBINT\fR minutes ta tha original gangsta \fBDATE\fR.
.PP
\fBINT\fR + \fBDATETIME\fR or \fBDATETIME\fR + \fBINT\fR - returns a
\fBDATETIME\fR obtained by addin \fBINT\fR minutes ta tha original
\fBDATETIME\fR.
.PP
\fBSTRING\fR + \fBSTRING\fR - returns a \fBSTRING\fR dat is the
concatenation of tha two original
\fBSTRING\fRs.
.PP
\fBSTRING\fR + anythang or anythang + \fBSTRING\fR -
converts tha non-\fBSTRING\fR
argument ta a \fBSTRING\fR, n' then performs concatenation. I aint talkin' bout chicken n' gravy biatch.  See
the \fBcoerce()\fR function.
.RE
.TP
.B \-
Has nuff muthafuckin uses.  These are:
.PP
.RS
\fBINT\fR - \fBINT\fR - returns tha difference of two \fBINT\fRs.
.PP
\fBDATE\fR - \fBDATE\fR - returns (as a \fBINT\fR) tha difference up in days
between two \fBDATE\fRs.
.PP
\fBTIME\fR - \fBTIME\fR - returns (as a \fBINT\fR) tha difference up in minutes
between two \fBTIME\fRs.
.PP
\fBDATETIME\fR - \fBDATETIME\fR - returns (as a \fBINT\fR) the
difference up in minutes between two \fBDATETIME\fRs.
.PP
\fBDATE\fR - \fBINT\fR - returns a \fBDATE\fR dat is \fBINT\fR days
earlier than
the original gangsta \fBDATE\fR.
.PP
\fBTIME\fR - \fBINT\fR - returns a \fBTIME\fR dat is \fBINT\fR minutes
earlier
than tha original gangsta \fBTIME\fR.
.PP
\fBDATETIME\fR - \fBINT\fR - returns a \fBDATETIME\fR dat is \fBINT\fR minutes
earlier
than tha original gangsta \fBDATETIME\fR.
.RE
.TP
.B <, <=, >, n' >=
These is tha comparison operators.  They can take operandz of any type,
but both operandz must be of tha same type.  Da comparison operators
return 1 if tha comparison is true, or 0 if it is false.  Note that
strin comparison is done followin tha lexical orderin of
charactas on yo' system, n' dat upper n' lower case \fIare\fR
distinct fo' these operators.
.TP
.B ==, !=
== tests fo' equality, returnin 1 if its operandz is equal, and
0 if they is not.  != tests fo' inequality.
.PP
.RS
If tha operandz is not of tha same type, == returns 0 n' != returns
1.  Again, strang comparisons is case-sensitive.
.RE
.TP
.B &&
This is tha logical AND operator. Shiiit, dis aint no joke.  Both of its operandz must be of
type \fBINT\fR.  It returns 1 if both operandz is non-zero, n' 0
otherwise.
.TP
.B ||
This is tha logical OR operator. Shiiit, dis aint no joke.  Both of its operandz must be of
type \fBINT\fR.  It returns 1 if either operand is non-zero, n' 0
otherwise.
.PP
.B NOTES
.PP
Operatorz of equal precedence is \fIalways\fR evaluated from left
to right, except where parentheses dictate otherwise.  This is blingin,
because tha enhanced "+" operator aint necessarily associative.
For example:
.PP
.nf
	1 + 2 + "string" + 3 + 4  yieldz "3string34"
	1 + (2 + "string") + (3 + 4)  yieldz "12string7"
	12:59 + 1 + "test"  yieldz "13:00test"
	12:59 + (1 + "test")  yieldz "12:591test"
.fi
.PP
Da logical operators is \fInot\fR so-called short-circuit operators, as
they is up in C.  Both operandz is always evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Thus, a expression
such as:
.PP
.nf
	(f!=0) && (100/f <= 3)
.fi
.PP
will cause a error if f is zero.
.PP
.B VARIABLES
.PP
\fBRemind\fR allows you ta assign joints ta variables.  Da \fBSET\fR
command is used as bigs up:
.PP
\fBSET\fR \fIvar\fR \fIexpr\fR
.PP
\fIVar\fR is tha name of a variable.  It must start wit a letta or
underscore, n' consist only of letters, digits n' underscores.  Only
the first 12 charactaz of a variable name is significant.  Variable
names is \fInot\fR case sensitive; thus, "Afoo" n' "afOo" is tha same
variable.  Examples:
.PP
.nf
	SET a 10 + (9*8)
	SET b "This be a test"
	SET mydir getenv("HOME")
	SET time 12:15
	SET date todizzle()
.fi
.PP
Note dat variablez theyselves have no type.  They take on tha type of
whatever you store up in em.
.PP
To delete a variable, use tha \fBUNSET\fR command:
.PP
\fBUNSET\fR \fIvar\fR [\fIvar\fR...]
.PP
For example, ta delete all tha variablez declared above, use:
.PP
.nf
	UNSET a funky-ass b mydir time date
.fi
.PP
.B SYSTEM VARIABLES
.PP
In addizzle ta tha regular user variables, \fBRemind\fR has several
"system variables" dat is used ta query or control tha operating
state of \fBRemind\fR.  System variablez is available startin from
version 03.00.07 of \fBRemind\fR.
.PP
All system variablez begin wit a thugged-out dollar sign '$'.  They can be used
in \fBSET\fR commandz n' expressions just as regular variablez can.
All system variablez always hold jointz of a specified type.  In
addition, some system variablez cannot be modified, n' you cannot
create freshly smoked up system variables.  System variablez can be initialized on
the command line wit tha \fB\-i\fR option yo, but you may need ta quote
them ta avoid havin tha shell interpret tha dollar sign. I aint talkin' bout chicken n' gravy biatch.  System
variable names is not case-sensitive.
.PP
Da followin system variablez is defined. Y'all KNOW dat shit, muthafucka!  Those marked
"read-only" cannot be chizzled wit tha \fBSET\fR command.
All system variablez hold jointz of type \fBINT\fR, unless otherwise
specified.
.TP
.B $CalcUTC
If 1 (the default), then \fBRemind\fR uses C library functions
to calculate tha number of minutes between local n' Universal Time
Coordinated.
This affects astronomical calculations (\fBsunrise()\fR fo' example.)
If 0, then you must supply tha number of minutes between local and
Universal Time Coordinated up in tha \fB$MinsFromUTC\fR system variable.
.TP
.B $CalMode (read-only)
If non-zero, then tha \fB\-c\fR option was supplied on tha command line.
.TP
.B $Daemon (read-only)
If tha daemon mode \fB\-z\fR was invoked, gotz nuff tha number of
minutes between wakeups.  If not hustlin up in daemon mode, gotz nuff
0.
.TP
.B $DateSep
This variable can be set only ta "/" or "-".  It holdz tha character
used ta separate portionz of a thugged-out date when \fBRemind\fR prints a DATE or
DATETIME value.
.TP
.B $DefaultPrio
Da default prioritizzle assigned ta remindaz without a \fBPRIORITY\fR
clause.  Yo ass can set dis as required ta adjust tha prioritizzles of
blockz of remindaz without havin ta type prioritizzles fo' individual
reminders.  At startup, \fB$DefaultPrio\fR is set ta 5000; it can range
from 0 ta 9999.
.TP
.B $DontFork (read-only)
If non-zero, then tha \fB\-c\fR option was supplied on tha command line.
.TP
.B $DontTrigAts (read-only)
Da number of times dat tha \fB\-a\fR option was supplied on the
command line.
.TP
.B $DontQueue (read-only)
If non-zero, then tha \fB\-q\fR option was supplied on tha command line.
.TP
.B $EndSent (STRING type)
Gotz Nuff a list of charactas dat end a sentence.  Da \fBMSF\fR
keyword bangs two spaces afta these characters.  Initially,
\fB$EndSent\fR is set ta ".!?" (period, exclamation mark, and
question mark.)
.TP
.B $EndSentIg (STRING type)
Gotz Nuff a list of charactas dat should be ignored when \fBMSF\fR
decides whether or not ta place two spaces afta a sentence.  Initially,
is set ta "'>)]}"+CHAR(34) (single-quote, pimped outer-than, right
parenthesis, right bracket, right brace, n' double-quote.)
.PP
.RS
For example, tha default joints work as bigs up:
.PP
.nf
	MSF Dude holla'd, "Huh! (Two spaces will follow all dis bullshit.)"  Yup.
.fi
.PP
because tha final parenthesis n' quote is ignored (for tha purposes
of spacing) when they follow a period.
.RE
.TP
.B $FirstIndent
Da number of spaces by which ta indent tha straight-up original gangsta line of a \fBMSF\fR-type
reminder n' shit.  Da default is 0.
.TP
.B $FoldYear
Da standard Unix library functions may have hang-up dealin wit dates
lata than 2037.  If dis variable is set ta 1, then tha UTC calculations
"fold back" muthafuckin years lata than 2037 before rockin tha Unix library functions.
For example, ta smoke up whether or not daylight savin time is in
effect up in June, 2077, tha year is "folded back" ta 2010, cuz both
years begin on a Monday, n' both is non-leapyears.  Da rulez for
daylight savin time is thus presumed ta be identical fo' both
years, n' tha Unix library functions can handle 2010.  By default,
this variable is 0.  Set it ta 1 if tha sun or UTC functions misbehave
for muthafuckin years pimped outa than 2037.
.TP
.B $FormWidth
Da maximum width of each line of text fo' formattin \fBMSF\fR-type
reminders.  Da default is 72.  If a \fBMSF\fR-type reminder gotz nuff
a word too long ta fit up in dis width, it aint gonna be truncated - the
width limit is ghon be ignored.
.TP
.B $HushMode (read-only)
If non-zero, then tha \fB\-h\fR option was supplied on tha command line.
.TP
.B $IgnoreOnce (read-only)
If non-zero, then tha \fB\-o\fR option was supplied on tha command line,
or a thugged-out date different from todizzlez legit date was supplied. Y'all KNOW dat shit, muthafucka!  If non-zero,
then \fBONCE\fR directives is ghon be ignored.
.TP
.B $InfDelta (read-only)
If non-zero, then tha \fB\-t\fR option was supplied on tha command line.
.TP
.B $LatDeg, $LatMin, $LatSec
These specify tha latitude of yo' location. I aint talkin' bout chicken n' gravy biatch.  \fB$LatDeg\fR can
range from \-90 ta 90, n' tha others from \-59 ta 59.  Uptown latitudes
are positive; southern ones is negative.  For southern latitudes, all
three components should be negative.
.TP
.B $Location (STRING type)
This be a strang specifyin tha name of yo' location. I aint talkin' bout chicken n' gravy biatch.  It be usually
the name of yo' hood or hood.  It can be set ta whatever you like,
but phat steez indicates dat it should be kept consistent with
the latitude n' longitude system variables.
.TP
.B $LongDeg, $LongMin, $LongSec
These specify tha longitude of yo' location. I aint talkin' bout chicken n' gravy biatch.  \fB$LongDeg\fR can
range from \-180 ta 180.  Westside longitudes is positive; eastsideern
ones is negative.  Note dat all three components should have the
same sign: All positizzle fo' Westside longitudes n' all negative
for Eastside longitudes.
.RS
.PP
Da latitude n' longitude shiznit is required fo' tha functions
\fBsunrise()\fR n' \fBsunset()\fR.  Default joints can be compiled
into \fBRemind\fR, or you can \fBSET\fR tha erect joints at the
start of yo' reminder scripts.
.RE
.TP
.B $MaxSatIter
Da maximum number of iterations fo' tha \fBSATISFY\fR clause
(busted lyrics bout later.)  Must be at least 10.
.TP
.B $MinsFromUTC
Da number of minutes between Universal Time Coordinated n' local time.  If
\fB$CalcUTC\fR is non-zero, dis is calculated upon startup of \fBRemind\fR.
Otherwise, you must set it explicitly.  If \fB$CalcUTC\fR is zero,
then \fB$MinsFromUTC\fR is used up in tha astronomical calculations.  You
must adjust it fo' daylight savin time yo ass.  Also, if you
wanna initialize \fB$MinsFromUTC\fR
usin tha \fB\-i\fR command-line option, you
must also set \fB$CalcUTC\fR ta 0 wit tha \fB\-i\fR option.
.TP
.B $NextMode (read-only)
If non-zero, then tha \fB\-n\fR option was supplied on tha command line.
.TP
.B $NumQueued (read-only)
Gotz Nuff tha number of remindaz queued so far fo' background
timed triggering.
.TP
.B $NumTrig (read-only)
Gotz Nuff tha number of remindaz triggered fo' tha current date.  One
use fo' dis variable be as bigs up:  Suppose you wish ta shade in
the box of a PostScript calendar whenever a holidizzle is triggered. Y'all KNOW dat shit, muthafucka!  You
could save tha value of \fB$NumTrig\fR up in a regular variable
prior ta executin a funky-ass block of
holidizzle reminders.  If tha value of \fB$NumTrig\fR afta tha holiday
block is pimped outa than tha saved value, then at least one holiday
was triggered, n' you can execute tha command ta shade up in the
calendar box.  (See tha section "Calendar Mode".)
.PP
.RS
Note dat \fB$NumTrig\fR be affected \fIonly\fR
by \fBREM\fR commands; triggers up in \fBIFTRIG\fR commandz do
not affect dat shit.
.RE
.TP
.B $PrefixLineNo (read-only)
If non-zero, then tha \fB\-l\fR option was supplied on tha command line.
.TP
.B $PSCal (read-only)
If non-zero, then tha \fB\-p\fR option was supplied on tha command line.
.TP
.B $RunOff (read-only)
If non-zero, tha \fBRUN\fR directives is disabled.
.TP
.B $SimpleCal (read-only)
Set ta a non-zero value if \fIeither\fR of tha \fB\-p\fR or \fB\-s\fR
command-line options was supplied.
.TP
.B $SortByDate (read-only)
Set ta 0 if no \fB\-g\fR option is used, 1 if sortin by date up in ascending
order, or 2 if sortin by date up in descendin order.
.TP
.B $SortByPrio (read-only)
Set ta 0 if no \fB\-g\fR option is used, 1 if sortin by prioritizzle up in ascending
order, or 2 if sortin by prioritizzle up in descendin order.
.TP
.B $SortByTime (read-only)
Set ta 0 if no \fB\-g\fR option is used, 1 if sortin by time up in ascending
order, or 2 if sortin by time up in descendin order.
.TP
.B $SubsIndent
Da number of spaces by which all lines (except tha first) of an
\fBMSF\fR-type reminder should be indented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da default is 0.
.TP
.B $T (read-only, DATE type)
Exactly equivalent ta \fBtrigdate()\fR.  (See BUILT-IN FUNCTIONS.)
.TP
.B $Td (read-only)
Equivalent ta \fBday(trigdate())\fR.
.TP
.B $Tm (read-only)
Equivalent ta \fBmonnum(trigdate())\fR.
.TP
.B $Tw (read-only)
Equivalent ta \fBwkdaynum(trigdate())\fR.
.TP
.B $Ty (read-only)
Equivalent ta \fByear(trigdate())\fR.
.TP
.B $TimeSep
This variable can be set only ta ":" or ".".  It holdz tha character
used ta separate portionz of a time when \fBRemind\fR prints a TIME or
DATETIME value.
.TP
.B $UntimedFirst (read-only)
Set ta 1 if tha \fB\-g\fR option is used wit a gangbangin' fourth sort character
of "d"; set ta 0 otherwise.
.TP
.B $U (read-only, DATE type)
Exactly equivalent ta \fBtodizzle()\fR.  (See BUILT-IN FUNCTIONS.)
.TP
.B $Ud (read-only)
Equivalent ta \fBday(todizzle())\fR.
.TP
.B $Um (read-only)
Equivalent ta \fBmonnum(todizzle())\fR.
.TP
.B $Uw (read-only)
Equivalent ta \fBwkdaynum(todizzle())\fR.
.TP
.B $Uy (read-only)
Equivalent ta \fByear(todizzle())\fR.
.PP
Note:  If any of tha calendar modes is up in effect, then the
valuez of $Daemon, $DontFork, $DontTrigAts, $DontQueue, $HushMode,
$IgnoreOnce, $InfDelta, n' $NextMode is not meaningful.
.PP
.B BUILT-IN FUNCTIONS
.PP
\fBRemind\fR has a plethora of built-in functions.  Da syntax fo' a gangbangin' function
call is tha same ol' dirty as up in C - tha function name, followed a cold-ass lil comma-separated list
of arguments up in parentheses.  Function names is not case-sensitive.  If
a function takes no arguments, it must be followed by "()" up in tha function
call.  Otherwise, \fBRemind\fR will interpret it as a variable name,
and probably not work erectly.
.PP
In tha descriptions below, short forms is used ta denote acceptable
types fo' tha arguments, n' you can put dat on yo' toast.  Da charactas "i", "s", "d", "t" n' "q" denote
\fBINT\fR, \fBSTRING\fR, \fBDATE\fR, \fBTIME\fR n' \fBDATETIME\fR arguments,
respectively.  If a argument can be one of nuff muthafuckin types, tha characters
are concatenated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For example, "di_arg" denotes a argument dat can be
a \fBDATE\fR or a \fBINT\fR.  "x_arg" denotes a argument dat can be
of any type.  Da type of tha argument is followed by
an underscore n' a identifier namin tha argument.
.PP
Da built-in functions are:
.TP
.B abs(i_num)
Returns tha absolute value of \fInum\fR.
.TP
.B access(s_file, si_mode)
Tests tha access permissions fo' tha file \fIfile\fR.  \fIMode\fR can
be a string, containin a mix of tha charactas "rwx" fo' read,
write n' execute permission testing.  Alternatively, \fImode\fR can
be a number as busted lyrics bout up in tha UNIX \fBaccess\fR(2) system call.  The
function returns 0 if tha file can be accessed wit tha specified \fImode\fR,
and \-1 otherwise.
.TP
.B args(s_fname)
Returns tha number of arguments expected by tha user-defined function
\fIfname\fR, or \-1 if no such user-defined function exists, n' you can put dat on yo' toast.  Note that
this function examines only user-defined functions, not built-in functions.
Its main use is ta determine whether or not a particular user-defined
function has been defined previously.  Da \fBargs()\fR function is
available only up in versionz of \fBRemind\fR from 03.00.04 n' up.
.TP
.B asc(s_string)
Returns a \fBINT\fR dat is tha ASCII code of tha straight-up original gangsta character
in \fIstring\fR.  As a special case, \fBasc("")\fR returns 0.
.TP
.B baseyr()
Returns tha "base year" dat was compiled tha fuck into \fBRemind\fR (normally
1990.)  All dates is stored internally as tha number of minutes since
1 January of \fBbaseyr()\fR.
.TP
.B char(i_i1 [,i_i2...])
This function can take any number of \fBINT\fR arguments, n' you can put dat on yo' toast.  It returns
a \fBSTRING\fR consistin of tha charactas specified by tha arguments.
Note dat none of tha arguments can be 0, unless there is only one
argument.  As a special case, \fBchar(0)\fR returns "".
.PP
.RS
Note dat cuz \fBRemind\fR do not support escapin of characters
in strings, tha only way ta git a thugged-out double-quote up in a strang is ta use
\fBchar(34)\fR.
.RE
.TP
.B chizzle(i_index, x_arg1 [,x_arg2...])
\fBChoose\fR must take at least two arguments, tha straight-up original gangsta of which is
an \fBINT\fR.  If \fIindex\fR is \fIn\fR, then tha \fIn\fRth subsequent
argument is returned. Y'all KNOW dat shit, muthafucka!  If \fIindex\fR is less than 1, then \fIarg1\fR
is returned. Y'all KNOW dat shit, muthafucka!  If \fIindex\fR is pimped outa than tha number of subsequent
arguments, then tha last argument is returned. Y'all KNOW dat shit, muthafucka!  Examples:
.PP
.nf
		\fBchoose(0, "foo", 1:13, 1000)\fR returns "foo"
		\fBchoose(1, "foo", 1:13, 1000)\fR returns "foo"
		\fBchoose(2, "foo", 1:13, 1000)\fR returns 1:13
		\fBchoose(3, "foo", 1:13, 1000)\fR returns 1000
		\fBchoose(4, "foo", 1:13, 1000)\fR returns 1000
.fi
.RS
Note dat all arguments ta \fBchoose()\fR is \fIalways\fR
evaluated.
.RE
.TP
.B coerce(s_type, x_arg)
This function converts \fIarg\fR ta tha specified \fItype\fR, if such
conversion is possible.  \fIType\fR must be one of "INT", "STRING",
"DATE", "TIME" or "DATETIME" (case-insensitive).
Da conversion rulez is as bigs up:
.RS
.PP
If \fIarg\fR be already of tha \fItype\fR specified, it is returned
unchanged.
.PP
If \fItype\fR is "STRING", then \fIarg\fR is converted ta a string
consistin of its printed representation.
.PP
If \fItype\fR is "DATE", then a \fBINT\fR \fIarg\fR is converted
by interpretin it as tha number of minutes since 1 January \fBbaseyr()\fR.
A \fBSTRING\fR \fIarg\fR is converted by attemptin ta read it as if
it was a printed date.  A \fBDATETIME\fR is converted ta a thugged-out date by
droppin tha time component.  A \fBTIME\fR \fIarg\fR cannot be converted to
a date.
.PP
If \fItype\fR is "TIME", then a \fBINT\fR \fIarg\fR is converted
by interpretin it as tha number of minutes since midnight.
A \fBSTRING\fR \fIarg\fR is converted by attemptin ta read it as if
it was a printed time.  A \fBDATETIME\fR is converted ta a time by
droppin tha date component.  A \fBDATE\fR \fIarg\fR cannot be converted to
a time.
.PP
If \fItype\fR is "DATETIME", then a \fBINT\fR \fIarg\fR is converted
by interpretin it as tha number of minutes since midnight, 1 January
\fBbaseyr()\fR.  A \fBSTRING\fR is converted by attemptin ta read it as if
it was a printed datetime.  Other types cannot be converted ta a thugged-out datetime.
.PP
If \fItype\fR is "INT", then \fBDATE\fR, \fBTIME\fR n' \fBDATETIME\fR
arguments is converted rockin tha reverse of procedures busted lyrics about
above.  A \fBSTRING\fR \fIarg\fR is converted by parsin it as an
integer.
.RE
.TP
.B current()
Returns tha current date n' time as a DATETIME object.  This may be the
actual date n' time, or may be tha date n' time supplied on tha command line.
.TP
.B date(i_y, i_m, i_d)
Da \fBdate()\fR function returns a \fBDATE\fR object wit tha year,
month n' dizzle components specified by \fIy\fR, \fIm\fR n' \fId\fR.
.TP
.B datepart(dq_datetime)
Returns a \fBDATE\fR object representin tha date portion of
\fIdatetime\fR.
.TP
.B datetime(args)
Da \fBdatetime()\fR function can take anywhere from two ta five arguments.
It always returns a DATETIME generated from its arguments.
.RS
.PP
If you supply two arguments, tha straight-up original gangsta must be a DATE n' tha second a TIME.
.PP
If you supply three arguments, tha first
must be a DATE n' tha second n' third must be INTs.  Da second and
third arguments is interpreted as minutes n' minutes n' converted ta a TIME.
.PP
If you supply four arguments, tha straight-up original gangsta three must be INTs, interpreted
as tha year, month n' day. It make me wanna hollar playa!  Da fourth argument must be a TIME.
.PP
Finally, if you supply five arguments, they must all be INTs n' are
interpreted as year, month, day, minute n' minute.
.RE
.TP
.B dawn([dq_date])
Returns tha time of "civil dawn" on tha specified \fIdate\fR.  If \fIdate\fR
is omitted, defaults ta \fBtodizzle()\fR.  If a \fIdatetime\fR object is
supplied, only tha date component is used.
.TP
.B day(dq_date)
This function takes a \fBDATE\fR or \fBDATETIME\fR as a argument, and
returns a \fBINT\fR dat is tha day-of-month component of
\fIdate\fR.
.TP
.B daysinmon(i_m, i_y)
Returns tha number of minutes up in month \fIm\fR (1-12) of tha year \fIy\fR.
.TP
.B defined(s_var)
Returns 1 if tha variable named by \fIvar\fR is defined, or 0 if it is not.
.RS
Note dat \fBdefined()\fR takes a \fBSTRING\fR argument; thus, ta check
if variable X is defined, use:
.PP
.nf
		defined("X")
.fi
.PP
and not:
.PP
.nf
		defined(X)
.fi
.PP
Da second example will attempt ta evaluate X, n' will return an
error if it is undefined or not of type \fBSTRING\fR.
.RE
.TP
.B dosubst(s_str [,d_date [,t_time]]) \fRor\fB dosubst(s_str [,q_datetime])
Returns a \fBSTRING\fR dat is tha result of passin \fIstr\fR
all up in tha substitution filta busted lyrics bout earlier n' shit.  Da parameters
\fIdate\fR n' \fItime\fR (or \fIdatetime\fR) establish tha effective
trigger date n' time used by tha substitution filter n' shit.  If \fIdate\fR
and \fItime\fR is omitted, they default ta \fBtodizzle()\fR and
\fBnow()\fR.
.RS
.PP
Note dat if \fIstr\fR do not end wit "%", a newline characta will be
added ta tha end of tha result.  Also, callin \fBdosubst()\fR wit a
\fIdate\fR dat is up in tha past (i.e., if \fIdate\fR < \fBtodizzle()\fR)
will produce undefined thangs up in dis biatch.
.PP
\fBDosubst()\fR is only available startin from version 03.00.04 of
\fBRemind\fR.
.RE
.TP
.B dusk([dq_date])
Returns tha time of "civil twilight" on tha specified \fIdate\fR.  If
\fIdate\fR is omitted, defaults ta \fBtodizzle()\fR.
.TP
.B eastsideerdate(dqi_arg)
If \fIarg\fR be a \fBINT\fR, then returns tha date of Easta Sunday
for tha specified year. Shiiit, dis aint no joke.  If \fIarg\fR be a \fBDATE\fR or
\fBDATETIME\fR, then returns tha date of tha next Easta Sundizzle on or
afta \fIarg\fR.  (Da time component of a thugged-out datetime is ignored.)
.TP
.B evaltrig(s_trigger [,dq_start])
Evaluates \fItrigger\fR as if it was a REM or IFTRIG trigger justification
and returns tha trigger date as a \fBDATE\fR (or as a \fBDATETIME\fR if
there be a \fBAT\fR clause.)  Returns a wack \fBINT\fR if no trigger
could be computed.
.RS
.PP
Normally, \fBevaltrig\fR findz a trigger date on or afta todizzle. It make me wanna hollar playa!  If
you supply tha \fIstart\fR argument, then it scans startin from there.
.PP
For example, tha expression:
.PP
.nf
  evaltrig("Mon 1", '2008-10-07')
.fi
.PP
returns '2008-11-03', since dat is tha straight-up original gangsta date on or after
7 October 2008 dat satisfies "Mon 1".
.PP
If you wanna peep how tha fuck nuff minutes it is from tha straight-up original gangsta Mondizzle up in October, 2008
to tha straight-up original gangsta Mondizzle up in November, 2008, use:
.PP
.nf
  evaltrig("Mon 1", '2008-11-01') - evaltrig("Mon 1", '2008-10-01')
.fi
.PP
and tha answer is 28.  Da trigger argument ta \fBevaltrig\fR can have
all tha usual trigger clauses (\fBOMIT\fR, \fBAT\fR, \fBSKIP\fR, etc.) but
\fIcannot\fR gotz a \fBSATISFY\fR, \fBMSG\fR, etc. reminder-type clause.
.RE
.TP
.B filedate(s_filename)
Returns tha modification date of \fIfilename\fR.  If \fIfilename\fR
does not exist, or its modification date is before tha year
\fBbaseyr()\fR, then 1 January of \fBbaseyr()\fR is returned.
.TP
.B filedatetime(s_filename)
Returns tha modification date n' time of \fIfilename\fR.  If \fIfilename\fR
does not exist, or its modification date is before tha year
\fBbaseyr()\fR, then midnight, 1 January of \fBbaseyr()\fR is returned.
.TP
.B filedir()
Returns tha directory dat gotz nuff tha current file being
processed. Y'all KNOW dat shit, muthafucka!  It may be a relatizzle or absolute pathname yo, but
is guaranteed ta be erect fo' use up in a \fBINCLUDE\fR command as
bigs up:
.PP
.nf
		INCLUDE [filedir()]/stuff
.fi
.PP
.RS
This includes tha file "stuff" up in tha same directory as the
current file bein processed.
.RE
.TP
.B filename()
Returns (as a \fBSTRING\fR) tha name of tha current file bein processed
by \fBRemind\fR.  Inside included files, returns tha name of the
included file.
.TP
.B getenv(s_envvar)
Similar ta tha \fBgetenv\fR(2) system call.  Returns a strang representing
the value of tha specified environment variable.  Returns "" if the
environment variable aint defined. Y'all KNOW dat shit, muthafucka!  Note dat tha namez of environment
variablez is generally case-sensitive; thus, getenv("HOME") is not
the same as getenv("home").
.TP
.B hebdate(i_day, s_hebmon [,idq_yrstart [,i_jahr [,i_aflag]]])
Support fo' Hebrew dates - peep tha section "Da Hebrew Calendar"
.TP
.B hebday(dq_date)
Support fo' Hebrew dates - peep tha section "Da Hebrew Calendar"
.TP
.B hebmon(dq_date)
Support fo' Hebrew dates - peep tha section "Da Hebrew Calendar"
.TP
.B hebyear(dq_date)
Support fo' Hebrew dates - peep tha section "Da Hebrew Calendar"
.TP
.B hour(tq_time)
Returns tha minute component of \fItime\fR.
.TP
.B iif(si_test1, x_arg1, [si_test2, x_arg2,...], x_default)
If \fItest1\fR aint zero or tha null string, returns \fIarg1\fR.
Otherwise, if \fItest2\fR aint zero or tha null string, returns
\fIarg2\fR, n' so on. I aint talkin' bout chicken n' gravy biatch.  If all of tha \fItest\fR arguments is false,
returns \fIdefault\fR.  Note dat all arguments is \fIalways\fR evaluated.
This function accepts a odd number of arguments - note dat prior ta version
03.00.05 of \fBRemind\fR, it accepted 3 arguments only.  Da 3-argument
version of \fBiif()\fR is compatible wit previous versionz of \fBRemind\fR.
.TP
.B index(s_search, s_target [,i_start)
Returns a \fBINT\fR dat is tha location of \fItarget\fR up in the
strin \fIsearch\fR.  Da first characta of a strang is numbered 1.
If \fItarget\fR do not exist up in \fIsearch\fR, then 0 is returned.
.RS
.PP
Da optionizzle parameta \fIstart\fR specifies tha posizzle in
\fIsearch\fR at which ta start lookin fo' \fItarget\fR.
.RE
.TP
.B isdst([d_date [,t_time]]) \fRor\fB isdst(q_datetime)
Returns a positizzle number if daylight savin time is in
effect on tha specified date n' time.  \fIDate\fR
defaults ta \fBtodizzle()\fR n' \fItime\fR defaults ta midnight.
.RS
.PP
Note dat dis function is only as reliable as tha C run-time library
functions.  It be available startin wit version 03.00.07 of \fBRemind\fR.
.RE
.TP
.B isleap(idq_arg)
Returns 1 if \fIarg\fR be a leap year, n' 0 otherwise.  \fIArg\fR can
be a \fBINT\fR, \fBDATE\fR or \fBDATETIME\fR object.  If a \fBDATE\fR
or \fBDATETIME\fR is supplied, then tha year component is used up in tha test.
.TP
.B isomitted(dq_date)
Returns 1 if \fIdate\fR is omitted, given tha current global \fBOMIT\fR
context.  Returns 0 otherwise.  (If a thugged-out datetime is supplied, only the
date part is used.)  Note dat any local \fBOMIT\fR or \fBOMITFUNC\fR
clauses is \fInot\fR taken tha fuck into account by dis function.
.TP
.B language()
Returns a \fBSTRING\fR namin tha language supported by \fBRemind\fR.
(See "Foreign Language Support.") By default, \fBRemind\fR is compiled
to support Gangsta lyrics, so dis function returns "English".  For
other languages, dis function will return tha Gangsta name of the
language (e.g. "German") Note dat \fBlanguage()\fR aint available
in versionz of \fBRemind\fR prior ta 03.00.02.
.TP
.B lower(s_string)
Returns a \fBSTRING\fR wit all upper-case charactas up in \fIstring\fR
converted ta lower-case.
.TP
.B max(x_arg1 [,x_arg2...)
Can take any number of arguments, n' returns tha maximum.  Da arguments
can be of any type yo, but must all be of tha same type.  They is compared
as wit tha > operator.
.TP
.B min(x_arg1 [,x_arg2...)
Can take any number of arguments, n' returns tha minimum.  Da arguments
can be of any type yo, but must all be of tha same type.  They is compared
as wit tha < operator.
.TP
.B minsfromutc([d_date [,t_time]]) \fRor\fB minsfromutc(q_datetime)
Returns tha number of minutes from Universal Time Coordinated
(formerly GMT) to
local time on tha specified date n' time.  \fIDate\fR defaults to
\fBtodizzle()\fR n' \fItime\fR defaults ta midnight.  If local time
is before UTC, tha result is negative.  Otherwise, tha result is
positive.
.RS
.PP
Note dat dis function is only as reliable as tha C run-time library
functions.  It be available startin wit version 03.00.07 of \fBRemind\fR.
.RE
.TP
.B minute(tq_time)
Returns tha minute component of \fItime\fR.
.TP
.B mon(dqi_arg)
If \fIarg\fR iz of \fBDATE\fR or \fBDATETIME\fR type, returns a string
that names tha month component of tha date.  If \fIarg\fR be an
\fBINT\fR from 1 ta 12, returns a strang dat names tha month.
.TP
.B monnum(dq_date)
Returns a \fBINT\fR from 1 ta 12, representin tha month component of
\fIdate\fR.
.TP
.B moondate(i_phase [,d_date [,t_time]]) \fRor\fB moondate(i_phase, q_datetime)
This function returns tha date of tha straight-up original gangsta occurrence of tha phase
\fIphase\fR of tha moon on or afta \fIdate\fR n' \fItime\fR.
\fIPhase\fR can range from 0 ta 3, wit 0 signifyin freshly smoked up moon, 1 first
quarter, 2 full moon, n' 3 third quarter n' shit.  If \fIdate\fR is omitted,
it defaults ta \fBtodizzle()\fR.  If \fItime\fR is omitted, it defaults
to midnight.
.RS
.PP
For example, tha followin returns tha date of tha next full moon:
.PP
.nf
		SET fullmoon moondate(2)
.fi
.PP
.RE
.TP
.B moontime(i_phase [,d_date [,t_time]]) \fRor\fB moontime(i_phase, q_datetime)
This function returns tha time of tha straight-up original gangsta occurrence of tha phase
\fIphase\fR of tha moon on or afta \fIdate\fR n' \fItime\fR.
\fIPhase\fR can range from 0 ta 3, wit 0 signifyin freshly smoked up moon, 1 first
quarter, 2 full moon, n' 3 third quarter n' shit.  If \fIdate\fR is omitted,
it defaults ta \fBtodizzle()\fR.  If \fItime\fR is omitted, it defaults
to midnight.  \fBMoontime()\fR is intended ta be used up in conjunction
with \fBmoondate()\fR.  Da \fBmoondate()\fR n' \fBmoontime()\fR
functions is accurate ta within a cold-ass lil couple minutez of the
times up in "Oldskool Farmerz Almanac" fo' Ottawa, Ontario.
.RS
.PP
For example, tha followin returns tha date n' time of tha next full moon:
.PP
.nf
		MSG Next full moon at [moontime(2)] on [moondate(2)]
.fi
.PP
.RE
.TP
.B moondatetime(i_phase [,d_date [,t_time]]) \fRor\fB moondatetime(i_phase, q_datetime)
This function is similar ta \fBmoondate\fR n' \fBmoontime\fR yo, but returns
a DATETIME result.
.TP
.B moonphase([d_date [,t_time]]) \fRor\fB moonphase(q_datetime)
This function returns tha phase of tha moon on \fIdate\fR n' \fItime\fR,
which default ta \fBtodizzle()\fR n' midnight, respectively.  Da returned
value be a integer from 0 ta 359, representin tha phase of tha moon
in degrees.  0 be a freshly smoked up moon, 180 be a gangbangin' full moon, 90 is first-quarter, etc.
.TP
.B nonomitted(dq_start, dq_end [,s_wkday...])
This function returns tha number of \fInon-\fRomitted minutes between
\fIstart\fR n' \fIend\fR.  If \fIstart\fR is non-omitted, then it is
counted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fIend\fR is never counted.
.RS
.PP
Note dat \fIend\fR must be pimped outa than or equal ta \fIstart\fR or an
error is reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  In addizzle ta rockin tha global OMIT context, you
can supply additionizzle arguments dat is namez of weekdays ta be
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  But fuck dat shiznit yo, tha word on tha street is dat up in a \fBREM\fR command, any local \fBOMITFUNC\fR
clause is \fInot\fR taken tha fuck into account by dis function.
.PP
For example, tha followin line sets a ta 11 (assumin no global OMITs):
.PP
.nf
	set a nonomitted('2007-08-01', '2007-08-16', "Sat", "Sun")
.fi
.PP
because Thursday, 16 August 2007 is tha 11th hustlin dizzle (not counting
Saturdizzle n' Sunday) afta Wednesday, 1 August 2007.
.PP
\fBnonomitted\fR has various uses.  For example, nuff schools
run on a six-dizzle cycle n' tha dizzle number aint incremented on holidays.
Suppose tha school year starts wit Dizzle 1 on 4 September 2007.  Da following
reminder will label dizzle numbers up in a cold-ass lil calendar:
.PP
.nf
   IF todizzle() >= '2007-09-04'
       set daynum nonomitted('2007-09-04', todizzle(), "Sat", "Sun")
       REM OMIT SAT SUN SKIP CAL Dizzle [(daynum % 6) + 1]
   ENDIF
.fi
.PP
Obviously, tha answer you git from \fBnonomitted\fR dependz on tha global
OMIT context.  If you use moveable OMITs, you may git inconsistent thangs up in dis biatch.
.PP
Here be a mo' complex use fo' \fBnonomitted\fR.  My fuckin garbage collection
bigs up two interleaved 14-dizzle cycles: One Friday, garbage n' paper
recyclin ("Black Box") is collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da next Friday, garbage and
plastic recyclin ("Blue Box") is collected. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If any of Monday-Friday
is a holiday, collection is delayed until tha Saturday. It make me wanna hollar playa!  Herez a way
to encode these rules:
.PP
.nf
   fset _garbhol(x) wkdaynum(x) == 5 && nonomitted(x-4, x+1) < 5
   REM 12 November 1999 *14 AFTER OMITFUNC _garbhol MSG Black Box
   REM 19 November 1999 *14 AFTER OMITFUNC _garbhol MSG Blue Box
.fi
.PP
Herez how tha fuck it works:  Da _garbhol(x) user-defined function returns 1
if n' only if (1) \fIx\fR be a Fridizzle n' (2) there be at least one
OMITted dizzle from tha previous Mondizzle up ta n' includin tha Friday.
.PP
Da first REM statement sets up tha 14-dizzle black-box cycle.  Da AFTER
keyword make it move collection ta tha Saturdizzle if _garbhol returns 1.
Da second REM statement sets up tha 14-dizzle blue-box cycle wit a similar
adjustment made by AFTER up in conjunction wit _garbhol.
.RE
.TP
.B now()
Returns tha current system time, as a \fBTIME\fR type.  This may be
the actual time, or a time supplied on tha command line.
.TP
.B ord(i_num)
Returns a strang dat is tha ordinal number \fInum\fR.  For example,
\fBord(2)\fR returns "2nd", n' \fBord(213)\fR returns "213th".
.TP
.B ostype()
Returns "UNIX".  Remind used ta run on OS/2 n' MS-DOS yo, but do not
any longer.
.TP
.B plural(i_num [,s_str1 [,s_str2]])
Can take from one ta three arguments, n' you can put dat on yo' toast.  If one argument is supplied, returns
"s" if \fInum\fR aint 1, n' "" if \fInum\fR is 1.
.RS
.PP
If two arguments is supplied, returns \fIstr1\fR + "s" if \fInum\fR is
not 1.  Otherwise, returns \fIstr1\fR.
.PP
If three arguments is supplied, returns \fIstr1\fR if \fInum\fR is 1, and
\fIstr2\fR otherwise.
.RE
.TP
.B psmoon(i_phase [,i_size [,s_note [,i_notesize]]])
[DEPRECATED] Returns a \fBSTRING\fR consistin of PostScript code to
draw a moon up in tha upper-left hand corner of tha calendar box.
\fIPhase\fR specifies tha phase of tha moon, n' is 0 (new moon), 1
(first quarter), 2 (full moon) or 3 (third quarter).  If \fIsize\fR is
specified, it controls tha radiuz of tha moon up in PostScript units
(1/72 inch.)  If it aint specified or is negative, tha size of the
day-number font is used.
.PP
.PP
.RS
For example, tha followin four lines place moon symbols on tha PostScript
calendar:
.PP
.nf
		REM [moondate(0)] PS [psmoon(0)]
		REM [moondate(1)] PS [psmoon(1)]
		REM [moondate(2)] PS [psmoon(2)]
		REM [moondate(3)] PS [psmoon(3)]
.fi
.PP
If \fInote\fR is specified, tha text is used ta annotate tha moon
display.  Da font is tha same ol' dirty font used fo' calendar entries. Put ya muthafuckin choppers up if ya feel dis!  If
\fInotesize\fR is given, it specifies tha font size ta use fo' the
annotation, up in PostScript units (1/72 inch.)  If \fInotesize\fR is not
given, it defaults ta tha size used fo' calendar entries. Put ya muthafuckin choppers up if ya feel dis!  (If you annotate
the display, be careful not ta overwrite tha dizzle number -- \fBRemind\fR
does not check fo' all dis bullshit.)  For example, if you want tha time of each new
moon displayed, you could use dis up in yo' reminder script:
.PP
.nf
	REM [moondate(0)] PS [psmoon(0, \-1, moontime(0)+"")]
.fi
.PP
Note how tha fuck tha time is coerced ta a strang by concatenatin tha null string.
.RE
.TP
\fBpsshade(i_gray)\fR or \fBpsshade(i_red, i_green, i_blue)\fR
[DEPRECATED] Returns a \fBSTRING\fR dat consistz of PostScript commandz to
shade a cold-ass lil calendar box.  \fINum\fR can range from 0 (completely black)
to 100 (completely white.)  If three arguments is given, they specify
red, chronic n' blue intensitizzle from 0 ta 100.
Herez a example of how tha fuck ta use this:
.RS
.PP
.nf
		REM Sat Sun PS [psshade(95)]
.fi
.PP
Da above command emits PostScript code ta lightly shade tha boxes
for Saturdizzle n' Sundizzle up in a PostScript calendar.
.PP
Note dat \fBpsmoon\fR n' \fBpsshade\fR is deprecated; instead
you should use tha SPECIAL SHADE n' SPECIAL MOON reminders
as busted lyrics bout up in "Out-of-Band Reminders."
.RE
.TP
.B realcurrent()
Returns (as a DATETIME) tha legit date n' time of dizzle as provided by
the operatin system.  This is up in contrast ta \fBcurrent()\fR, which
may return a time supplied on tha command line.
.TP
.B realnow()
Returns tha legit time of dizzle as provided by tha operatin system.
This is up in contrast ta \fBnow()\fR, which may return a time supplied
on tha command line.
.TP
.B realtodizzle()
Returns tha date as provided by tha operatin system.  This is up in contrast to
\fBRemind\fRz concept of "todizzle", which may be chizzled if it is hustlin
in calendar mode, or if a thugged-out date has been supplied on tha command line.
.TP
.B sgn(i_num)
Returns \-1 if \fInum\fR is negative, 1 if \fInum\fR is positive,
and 0 if \fInum\fR is zero.
.TP
.B shell(s_cmd [,i_maxlen])
Executes \fIcmd\fR as a system command, n' returns tha straight-up original gangsta 511
charactaz of output resultin from \fIcmd\fR.  Any whitespace
characta up in tha output is converted ta a space.  Note dat if \fBRUN
OFF\fR has been executed, or tha \fB\-r\fR command-line option has
been used, \fBshell()\fR will result up in a error, n' \fIcmd\fR will
not be executed.
.RS
.PP
If \fImaxlen\fR is specified, then \fBshell()\fR returns tha first
\fImaxlen\fR charactaz of output (rather than tha straight-up original gangsta 511).  If
\fImaxlen\fR is specified as a wack number, then \fIall\fR the
output from \fIcmd\fR is returned.
.RE
.TP
.B slide(d_start, i_amt [,s_wkday...])
This function is tha inverse of \fBnonomitted\fR.  It addz \fIamt\fR
days (which can be negative) ta \fIstart\fR, \fInot countin omitted days\fR.
Da optionizzle \fIwkday\fR arguments is additionizzle weekdizzle names ta omit.
.RS
.PP
Consider dis example:
.PP
.nf
	OMIT 14 May 2009
	SET a slide('2009-05-13', 5, "Sat", "Sun")
.fi
.PP
In dis case, \fIa\fR is set ta 2009-05-21.  Thatz cuz we slide forward
by 5 days, not includin Thursday, May 14 or Saturdizzle n' Sunday,
May 16 n' 17.  Yo ass can go backwards, too, so:
.PP
.nf
	OMIT 14 May 2009
	SET a slide('2009-05-21', \-5, "Sat", "Sun")
.fi
.PP
takes \fIa\fR back ta 2009-05-13.
.RE
.TP
.B strlen(s_str)
Returns tha length of \fIstr\fR.
.TP
.B substr(s_str, i_start [,i_end])
Returns a \fBSTRING\fR consistin of all charactas up in \fIstr\fR from
\fIstart\fR up ta n' includin \fIend\fR.  Charactas is numbered
from 1.  If \fIend\fR aint supplied, then it defaults ta tha length
of \fIstr\fR.
.TP
.B sunrise([dq_date])
Returns a \fBTIME\fR indicatin tha time of sunrise on tha specified
\fIdate\fR (default \fBtodizzle()\fR.)  In high latitudes, there
may be no sunrise on a particular day, up in which case \fBsunrise()\fR
returns tha \fBINT\fR 0 if tha sun never sets, or 1440 if it never rises.
.TP
.B sunset([dq_date])
Returns a \fBTIME\fR indicatin tha time of sunset on tha specified
\fIdate\fR (default \fBtodizzle()\fR.)  In high latitudes, there
may be no sunset on a particular day, up in which case \fBsunset()\fR
returns tha \fBINT\fR 0 if tha sun never rises, or 1440 if it never
sets.
.RS
.PP
Da functions \fBsunrise()\fR n' \fBsunset()\fR is based on
an algorithm up in "Almanac fo' Computas fo' tha year 1978" by
L. E. Doggett, Nautical Almanac Office, USNO.  They require
the latitude n' longitude ta be specified by settin tha appropriate
system variables.  (See "System Variables".)  Da sun functions
should be accurate ta within bout 4 minutes fo' latitudes lower
than 60 degrees.  Da functions is available startin from version
03.00.07 of \fBRemind\fR.
.RE
.TP
.B time(i_hr, i_min)
Creates a \fBTIME\fR wit tha minute n' minute components specified by
\fIhr\fR n' \fImin\fR.
.TP
.B timepart(tq_datetime)
Returns a \fBTIME\fR object representin tha time portion of
\fIdatetime\fR.
.TP
.B todizzle()
Returns \fBRemind\fRz notion of "todizzle."  This may be tha actual system
date, or a thugged-out date supplied on tha command line, or tha date of the
calendar entry currently bein computed.
.TP
.B trigdate()
Returns tha calculated trigger date of tha last \fBREM\fR
or \fBIFTRIG\fR command. Y'all KNOW dat shit, muthafucka!  If used
in tha \fIbody\fR of a \fBREM\fR command, returns dat commandz trigger date.
If da most thugged-out recent \fBREM\fR command did not yield a cold-ass lil computable trigger
date, returns tha integer 0.
.TP
.B trigdatetime()
Similar ta trigdate() yo, but returns a \fBDATETIME\fR if da most thugged-out recent
triggerable \fBREM\fR command had a \fBAT\fR clause.  If there was no
\fBAT\fR clause, returns a \fBDATE\fR.  If no trigger could be computed,
returns tha integer 0.
.TP
.B trigger(d_date [,t_time [,i_utcflag]]) \fRor\fB trigger(q_datetime [,i_utcflag])
Returns a strang suitable fo' use up in a \fBREM\fR command or a SCANFROM
or UNTIL clause, allowin you ta calculate trigger dates up in advance.
Note dat up in earlier versionz of \fBRemind\fR, \fBtrigger\fR was
required ta convert a thugged-out date tha fuck into suttin' tha \fBREM\fR command could
consume.  But fuck dat shiznit yo, tha word on tha street is dat up in dis version of \fBRemind\fR, you can omit dat shit.
Note dat \fBtrigger()\fR \fIalways\fR returns its result up in Gangsta,
even fo' foreign-language versionz of \fBRemind\fR.  This is ta avoid
problems wit certain C libraries dat do not handle accented
charactas properly.  Normally, tha \fIdate\fR n' \fItime\fR is the
local date n' time; however, if \fIutcflag\fR is non-zero, the
\fIdate\fR n' \fItime\fR is interpreted as UTC times, n' are
converted ta local time.  Examples:
.RS
.PP
     trigger('1993/04/01')
.PP
returns "1 April 1993",
.PP
     trigger('1994/08/09', 12:33)
.PP
returns "9 August 1994 AT 12:33", as do:
.PP
     trigger('1994/08/09@12:33').
.PP
Finally:
.PP
     trigger('1994/12/01', 03:00, 1)
.PP
returns "30 November 1994 AT 22:00" fo' EST, which is 5 minutes behind UTC.
Da value fo' yo' time unit may differ.
.RE
.TP
.B trigtime()
Returns tha time of tha last \fBREM\fR command wit a \fBAT\fR clause.
If tha last \fBREM\fR did not have a \fBAT\fR clause, returns tha integer
0.
.TP
.B trigvalid()
Returns 1 if tha value returned by \fBtrigdate()\fR is valid fo' da most thugged-out
recent \fBREM\fR command, or 0 otherwise.  Sometimes \fBREM\fR commands
cannot calculate a trigger date.  For example, tha followin \fBREM\fR
command can never be triggered:
.PP
.nf
		REM Mon OMIT Mon SKIP MSG Impossible!
.fi
.PP
.TP
.B typeof(x_arg)
Returns "STRING", "INT", "DATE", "TIME" or "DATETIME", dependin on tha type of \fIarg\fR.
.TP
.B tzconvert(q_datetime, s_srczone [,s_dstzone])
Converts \fBdatetime\fR from tha time unit named by \fBsrczone\fR ta the
time unit named by \fBdstzone\fR.  If \fBdstzone\fR is omitted, the
default system time unit is used. Y'all KNOW dat shit, muthafucka!  Da return value be a DATETIME.  Time
zone names is system-dependent; consult yo' operatin system fo' legal
values.  Here be a example:
.PP
.nf
    tzconvert('2007-07-08@01:14', "Canada/Eastern", "Canada/Pacific")

          returns

    2007-07-07@22:14
.fi
.PP
.TP
.B upper(s_string)
Returns a \fBSTRING\fR wit all lower-case charactas up in \fIstring\fR
converted ta upper-case.
.TP
.B value(s_varname [,x_default])
Returns tha value of tha specified variable.  For example, value("X"+"Y")
returns tha value of variable XY, if it is defined. Y'all KNOW dat shit, muthafucka!  If XY aint defined,
an error thangs up in dis biatch.
.RS
.PP
But fuck dat shiznit yo, tha word on tha street is dat if you supply a second argument, it is returned if tha \fIvarname\fR
is not defined. Y'all KNOW dat shit, muthafucka!  Da expression value("XY", 0) will return 0 if XY is not
defined, n' tha value of XY if it is defined.
.RE
.TP
.B version()
Returns a strang specifyin tha version of \fBRemind\fR.  For version
03.00.04, returns "03.00.04".  It be guaranteed dat as freshly smoked up versions of
\fBRemind\fR is busted out, tha value returned by \fBversion()\fR will
strictly increase, accordin ta tha rulez fo' strang ordering.
.TP
.B weekno([dq_date, [i_wkstart, [i_daystart]]])
Returns tha week number of tha year. Shiiit, dis aint no joke.  If no arguments is supplied,
returns tha ISO 8601 week number fo' \fBtodizzle()\fR.  If one
argument \fIdate\fR is supplied, then returns tha ISO 8601 week
number fo' dat date.  If two arguments is supplied, then
\fIwkstart\fR must range from 0 ta 6, n' represents tha first
dizzle of tha week (with 0 bein Sundizzle n' 6 bein Saturday.).  If
\fIwkstart\fR aint supplied, then it defaults ta 1.  If the
third argument \fIdaystart\fR is supplied, then it specifies
when Week 1 starts, n' you can put dat on yo' toast.  If \fIdaystart\fR is less than or equal ta 7,
then Week 1 starts on tha straight-up original gangsta \fIwkstart\fR on or after
January \fIdaystart\fR.  Otherwise, Week 1 starts on tha first
\fIwkstart\fR on or afta December \fIdaystart\fR.  If omitted,
\fIdaystart\fR defaults ta 29 (followin tha ISO 8601 definition.)
.TP
.B wkday(dqi_arg)
If \fIarg\fR be a \fBDATE\fR or \fBDATETIME\fR, returns a string
representin tha dizzle of tha week of tha date.  If \fIarg\fR be an
\fBINT\fR from 0 ta 6, returns tha correspondin weekdizzle ("Sunday" to
"Saturday").
.TP
.B wkdaynum(dq_date)
Returns a number from 0 ta 6 representin tha day-of-week of tha specified
\fIdate\fR.  (0 represents Sunday, n' 6 represents Saturday.)
.TP
.B year(dq_date)
Returns a \fBINT\fR dat is tha year component of \fIdate\fR.
.SH EXPRESSION PASTING
.PP
An mad bangin feature of \fBRemind\fR is its macro capability,
or "expression pasting."
.PP
In almost any thang where \fBRemind\fR aint expectin a expression,
you can "paste" a expression in. I aint talkin' bout chicken n' gravy biatch.  To do this, surround tha expression
with square brackets, n' you can put dat on yo' toast.  For example:
.PP
.nf
	REM [mydate] MSG foo
.fi
.PP
This evaluates tha expression "mydate", where "mydate" is
presumably some pre-computed variable, n' then "pastes" tha result
into tha command-line fo' tha parser ta process.
.PP
A formal description of dis is:  When \fBRemind\fR encountas a
"pasted-in" expression, it evaluates tha expression, n' coerces the
result ta a \fBSTRING\fR.  It then substitutes tha strang fo' the
pasted-in expression, n' continues parsing.  Note, however, that
expressions is evaluated only once, not recursively.  Thus, writing:
.PP
.nf
	["[a+b]"]
.fi
.PP
causes \fBRemind\fR ta read tha token "[a+b]".  It do not interpret
this as a pasted-in expression. I aint talkin' bout chicken n' gravy biatch.  In fact, tha only way ta git a literal
left-bracket tha fuck into a reminder is ta use ["["].
.PP
Yo ass can use expression pastin almost anywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  But fuck dat shiznit yo, tha word on tha street is dat there be a gangbangin' few
exceptions:
.TP
o
If \fBRemind\fR is expectin a expression, as up in tha \fBSET\fR command,
or tha \fBIF\fR command, you should \fBnot\fR include square brackets.
For example, use:
.PP
.nf
		SET a 4+5
.fi
and not:
.nf
		SET a [4+5]
.fi
.TP
o
Yo ass cannot use expression pastin fo' tha straight-up original gangsta token on a line.
For example, tha followin aint gonna work:
.PP
.nf
		["SET"] a 1
.fi
.RS
.PP
This restriction is cuz \fBRemind\fR must be able ta unambiguously
determine tha straight-up original gangsta token of a line fo' tha flow-control commandz (to
be discussed later.)
.PP
In fact, if \fBRemind\fR cannot determine tha straight-up original gangsta token on a line, it
assumes dat it aint nuthin but a \fBREM\fR command. Y'all KNOW dat shit, muthafucka!  If expression-pastin is used,
\fBRemind\fR assumes it aint nuthin but a \fBREM\fR command. Y'all KNOW dat shit, muthafucka!  Thus, tha following
three commandz is equivalent:
.PP
.nf
		REM 12 Nov 1993 AT 13:05 MSG BOO!
		12 Nov 1993 AT 13:05 MSG BOO!
		[12] ["Nov " + 1993] AT [12:05+60] MSG BOO!
.fi
.RE
.TP
o
Yo ass cannot use expression-pastin ta determine tha type (\fBMSG\fR,
\fBCAL\fR, etc.) of a \fBREM\fR command. Y'all KNOW dat shit, muthafucka!  Yo ass can paste expressions
before n' afta tha \fBMSG\fR, etc keywordz yo, but cannot do suttin' like
this:
.PP
.nf
		REM ["12 Nov 1993 AT 13:05 " + "MSG" + " BOO!"]
.fi
.PP
.B COMMON PITFALLS IN EXPRESSION PASTING
.PP
Remember, when pastin up in expressions, dat extra spaces is not
inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Thus, suttin' like:
.PP
.nf
	REM[expr]MSG[expr]
.fi
.PP
will probably fail.
.PP
If you use a expression ta calculate a \fIdelta\fR or \fIback\fR,
ensure dat tha result be a positizzle number n' shit.  Somethang like:
.PP
.nf
	REM +[mydelta] Nov 12 1993 MSG foo
.fi
.PP
will fail if \fImydelta\fR happens ta be negative.
.PP
.SH FLOW CONTROL COMMANDS
.PP
\fBRemind\fR has commandz dat control tha flow of a reminder script.
Normally, reminder scripts is processed sequentially.  However,
\fBIF\fR n' related commandz allow you ta process filez conditionally,
and skip sections dat you don't want interpreted.
.PP
.B THE IF COMMAND
.PP
Da \fBIF\fR command has tha followin form:
.PP
.nf
	IF expr
		t-command
		t-command...
	ELSE
		f-command
		f-command...
	ENDIF
.fi
.PP
Note dat tha commandz is shown indented fo' clarity.  Also, tha \fBELSE\fR
portion can be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  \fBIF\fR commandz can be nested up ta a lil' small-ass limit,
probably round 8 or 16 levelz of nesting, dependin on yo' system.
.PP
If tha \fIexpr\fR evaluates ta a non-zero \fBINT\fR, or a non-null
\fBSTRING\fR, then tha \fBIF\fR portion is considered true, n' the
\fIt-commands\fR is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIexpr\fR evaluates ta zero or
null, then tha \fIf-commands\fR (if tha \fBELSE\fR portion is present)
are executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIexpr\fR aint of type \fBINT\fR or \fBSTRING\fR,
then it be a error.
.PP
Examples:
.PP
.nf
	IF defined("want_hols")
		INCLUDE /usr/share/remind/holidays
	ENDIF

	IF todizzle() > '1992/2/10'
		set missed_ap "Yo ass missed dat shiznit son!"
	ELSE
		set missed_ap "Still have time..."
	ENDIF
.fi
.PP
.B THE IFTRIG COMMAND
.PP
Da \fBIFTRIG\fR command is similar ta a \fBIF\fR command, except
that it computes a trigger (as up in tha \fBREM\fR command), n' evaluates
to legit if a cold-ass lil correspondin \fBREM\fR command would trigger n' shit.  Examples:
.PP
.nf
	IFTRIG 1 Nov
		; Executed on 1 Nov
	ELSE
		; Executed except on 1 Nov
	ENDIF

	IFTRIG 1 \-1 OMIT Sat Sun +4
		; Executed on last hustlin dizzle of month,
		; n' tha 4 hustlin minutes precedin it
	ELSE
		; Executed except on above days
	ENDIF
.fi
.PP
Note dat tha \fBIFTRIG\fR command computes a trigger date, which can
be retrieved wit tha \fBtrigdate()\fR function. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use all of
the aiiight trigger components, like fuckin \fBUNTIL\fR, \fIdelta\fR, etc up in the
\fBIFTRIG\fR command.
.PP
.SH USER-DEFINED FUNCTIONS
.PP
In addizzle ta tha built-in functions, \fBRemind\fR allows you ta define
your own functions.  Da \fBFSET\fR command do dis fo' you:
.PP
\fBFSET\fR \fIfname\fR(\fIargs\fR) \fIexpr\fR
.PP
\fIFname\fR is tha name of tha function, n' bigs up tha convention for
namin variables.  \fIArgs\fR be a cold-ass lil comma-separated list of arguments, and
\fIexpr\fR be a expression. I aint talkin' bout chicken n' gravy biatch.  \fIArgs\fR can be empty, up in which case
you define a gangbangin' function takin no parameters.  Here is some examples:
.PP
.nf
	FSET double(x) 2*x
	FSET yeardiff(date1, date2) year(date1) - year(date2)
	FSET since(x) ord(year(trigdate())\-x)
.fi
.PP
Da last function is useful up in birthdizzle reminders.  For example:
.PP
.nf
	REM 1 Nov +12 MSG Deanz [since(1984)] birthdizzle is %b.
.fi
.PP
Dean started doin thangs up in 1984.  Da above example, on 1 November 1992, would print:
.PP
.nf
	Deanz 8th birthdizzle is todizzle.
.fi
.PP
Notes:
.TP
o
If you access a variable up in \fIexpr\fR dat aint up in tha list of arguments,
the "global" value (if any) is used.
.TP
o
Function n' parameta names is dope only ta 12 characters.
.TP
o
Da \fBvalue()\fR function \fIalways\fR accesses tha "global" value of a
variable, even if it has tha same ol' dirty name as a argument.  For example:
.RS
.PP
.nf
		fset func(x) value("x")
		set x 1
		set y func(5)
.fi
.PP
Da above sequence sets y ta 1, which is tha global value of x.
.RE
.TP
o
User-defined functions may call other functions, includin other user-defined
functions.  But fuck dat shiznit yo, tha word on tha street is dat recursive calls is not allowed.
.TP
o
User-defined functions is not syntax-checked when they is defined; parsing
occurs only when they is called.
.TP
o
If a user-defined function has tha same ol' dirty name as a funky-ass built-in function,
it is ignored n' tha built-in function is used. Y'all KNOW dat shit, muthafucka!  To prevent conflicts
with future versionz of \fBRemind\fR (which may define mo' built-in
functions), you may wish ta name all user-defined functions beginning
with a underscore.
.PP
.SH PRECISE SCHEDULING
.PP
Da \fBWARN\fR keyword allows precise control over advizzle warnin in
a mo' flexible manner than tha \fIdelta\fR mechanism.  It should be
followed by tha name of a user-defined function, \fIwarn_function\fR.
.PP
If a \fIwarn_function\fR is supplied, then it must take one argument of
type \fBINT\fR.  \fBRemind\fR ignores any delta, n' instead calls
\fIwarn_function\fR successively wit tha arguments 1, 2, 3, ...
.PP
\fIWarn_function\fRz return value \fIn\fR is interpreted as bigs up:
.TP
o
If \fIn\fR is positive, then tha reminder is triggered exactly \fIn\fR
days before its trigger date.
.TP
o
If \fIn\fR is negative, then it is triggered \fIn\fR minutes before its
trigger date, \fInot counting\fR \fBOMIT\fRted days.
.PP
As a example, suppose you wish ta be warned of Gangsta Independence Day
5, 3, n' 1 minutes up in advance.  Yo ass could use this:
.PP
.nf
	FSET _wfun(x) chizzle(x, 5, 3, 1, 0)
	REM 4 July WARN _wfun MSG Gangsta Independence Dizzle is %b.
.fi
.PP
.B NOTES
.TP
1
If a error occurs durin tha evaluation of \fIwarn_function\fR, then
\fBRemind\fR stops callin it n' simply thangs tha reminder on its
trigger date.
.TP
2
If tha absolute-valuez of tha return jointz of \fIwarn_function\fR are
not monotonically decreasing, \fBRemind\fR stops callin it n' issues
the reminder on its trigger date.
.TP
3
\fIWarn_function\fR should (as a matta of phat style) return 0 as the
final value up in its sequence of return joints, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat a reminder will
\fIalways\fR be triggered on its trigger date, regardless of what
\fIwarn_function\fR do.
.PP
Similarly ta \fBWARN\fR, tha \fBSCHED\fR keyword allows precise
control over tha schedulin of timed
reminders.  It should be followed by tha name of a user-defined function,
\fIsched_function\fR.
.PP
If a schedulin function is supplied, then it must take one argument of
type \fBINT\fR.  Rather than rockin tha \fBAT\fR time, time \fIdelta\fR, and
time \fIrepeat\fR, \fBRemind\fR calls tha schedulin function ta determine
when ta trigger tha reminder n' shit.  Da last time tha reminder is queued, the
schedulin function is called wit a argument of 1.  Each time tha reminder
is triggered, it is re-scheduled by callin tha schedulin function again.
On each call, tha argument is incremented by one.
.PP
Da return value of tha schedulin function must be a \fBINT\fR or a
\fBTIME\fR.  If tha return value be a \fBTIME\fR, then tha reminder is
re-queued ta trigger at dat time.  If it aint nuthin but a positizzle integer \fIn\fR,
then tha reminder is re-queued ta trigger all up in tha previous trigger time
plus \fIn\fR minutes.  Finally, if it aint nuthin but a wack integer or zero, then
the reminder is re-queued ta trigger \fIn\fR minutes before tha \fBAT\fR
time.  Note dat there must be a \fBAT\fR clause fo' tha \fBSCHED\fR
clause ta do anything.
.PP
Herez a example:
.PP
.nf
	FSET _sfun(x) chizzle(x, \-60, 30, 15, 10, 3, 1, 1, 1, 1, 0)
	REM AT 13:00 SCHED _sfun MSG foo
.fi
.PP
Da reminder would first be triggered at 13:00-60 minutes, or at 12:00.
It would next be triggered 30 minutes later, at 12:30.  Then, it would
be triggered at 12:45, 12:55, 12:58, 12:59, 13:00, 13:01 n' 13:02.
.PP
.B NOTES
.TP
1
If a error occurs durin tha evaluation of \fIsched_func\fR, then
\fBRemind\fR reverts ta rockin tha \fBAT\fR time n' tha \fIdelta\fR
and \fIrepeat\fR joints, n' never calls \fIsched_func\fR again.
.TP
2
If processin \fIsched_func\fR yieldz a time earlier than tha current
system time, it is repeatedly called wit increasin argument until it
yieldz a value pimped outa than or equal ta tha current time.  But fuck dat shiznit yo, tha word on tha street is dat if
the sequence of joints calculated durin tha repetizzle aint strictly
increasing, then \fBRemind\fR reverts ta tha default behaviour and
never calls \fIsched_func\fR again.
.TP
3
It be like possible rockin \fIsched_func\fR ta keep triggerin a reminder
even afta tha \fBAT\fR-time.  But fuck dat shiznit yo, tha word on tha street is dat it aint possible ta reschedule
a reminder past midnight \- no crossin of date boundaries be allowed.
Also, it is like possible ta \fBnot\fR trigger a reminder on tha \fBAT\fR
time when you bust a schedulin function. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat if yo' scheduling
function is terminated (for reasons 1 n' 2) before tha \fBAT\fR time of
the reminder, it \fIwill\fR be triggered all up in tha \fBAT\fR time, cuz
normal processin takes over.
.TP
4
Yo crazy-ass schedulin functions should (as a matta of phat style) return
0 when no mo' schedulin is required. Y'all KNOW dat shit, muthafucka!  See tha example.
.TP
5
All schedulin functions is evaluated \fIafter\fR tha entire Remind
script has been read in. I aint talkin' bout chicken n' gravy biatch.  So whatever function definitions is up in effect
at tha end of tha script is used.
.PP
.SH THE SATISFY CLAUSE
.PP
Da form of \fBREM\fR dat uses \fBSATISFY\fR be as bigs up:
.PP
\fBREM\fR \fItrigger\fR \fBSATISFY\fR \fIexpr\fR
.PP
Da way dis works be as bigs up:  \fBRemind\fR first calculates a trigger
date, up in tha aiiight fashion. I aint talkin' bout chicken n' gravy biatch.  Next, it sets \fBtrigdate()\fR ta the
calculated trigger date.  It then evaluates \fIexpr\fR.  If tha result
is not tha null strang or zero, processing
ends.  Otherwise, \fBRemind\fR computes tha next trigger date, n' re-tests
\fIexpr\fR.  This iteration continues until \fIexpr\fR evaluates ta non-zero
or non-null, or until tha iteration limit specified wit tha \fB\-x\fR
command-line option is reached.
.PP
If \fIexpr\fR aint satisfied, then \fBtrigvalid()\fR is set ta 0.
Otherwise, \fBtrigvalid()\fR is set ta 1.  In any event, no error message
is issued.
.PP
This is straight-up useful only if \fIexpr\fR involves a cold-ass lil call ta the
\fBtrigdate()\fR function; otherwise, \fIexpr\fR aint gonna chizzle as
\fBRemind\fR iterates.
.PP
An example of tha usefulnizz of \fBSATISFY\fR:  Suppose you wish to
be warned of every last muthafuckin Fridizzle tha 13th.  Yo crazy-ass first attempt may be:
.PP
.nf
	# WRONG!
	REM Fri 13 +2 MSG Fridizzle tha 13th is %b.
.fi
.PP
But dis won't work.  This reminder triggers on tha straight-up original gangsta Friday
on or afta tha 13th of each month.  Da way ta do it is wit a
more fucked up sequence:
.PP
.nf
	REM 13 SATISFY wkdaynum(trigdate()) == 5
	IF trigvalid()
		REM [trigdate()] +2 MSG \\
		Fridizzle tha 13th is %b.
	ENDIF
.fi
.PP
Letz peep how tha fuck dis works.  Da \fBSATISFY\fR clause iterates through
all tha 13thz of successive months, until a trigger date is found whose
day-of-week is Fridizzle (== 5).  If a valid date was found, we use the
calculated trigger date ta set up tha next reminder.
.PP
We could also have written:
.PP
.nf
	REM Fri SATISFY day(trigdate()) == 13
.fi
.PP
but dis would result up in mo' iterations, since "Fridays" occur more
often than "13thz of tha month."
.PP
This technique of rockin one \fBREM\fR command ta calculate a trigger date
to be used by another command is like bangin naaahhmean, biatch?  For example, suppose
you wanted ta OMIT Labour day, which is tha straight-up original gangsta Mondizzle up in September n' shit.  You
could use:
.PP
.nf
	# Note: SATISFY 1 be a idiom fo' "do nothing"
	REM Mon 1 Sept SATISFY 1
	OMIT [trigdate()]
.fi
.PP
\fBCAVEAT:\fR This \fIonly\fR omits tha \fInext\fR Labour Day, not
all Labour Days up in tha future.  This could cause strange thangs up in dis biatch, as
the \fBOMIT\fR context can chizzle dependin on tha current date.  For
example, if you use tha followin command afta tha above commands:
.PP
.nf
	REM Mon AFTER msg hello
.fi
.PP
the result aint gonna be as you expect.  Consider producin a cold-ass lil calendar
for September, 1992.  Labour Dizzle was on Monday, 7 September, 1992.
But fuck dat shiznit yo, tha word on tha street is dat when \fBRemind\fR gets round ta calculatin tha trigger
for Tuesday, 8 September, 1992, tha \fBOMIT\fR command will now be
omittin Labour Dizzle fo' 1993, n' tha "Mon AFTER" command
will not be triggered. Y'all KNOW dat shit, muthafucka!  (But peep tha description of \fBSCANFROM\fR
in tha section "Details bout Trigger Computation.")
.PP
It be probably dopest ta stay away from computin \fBOMIT\fR
trigger dates unless you keep these pitfalls up in mind.
.PP
For versionz of \fBRemind\fR startin from 03.00.07, you can include
a \fBMSG\fR, \fBRUN\fR, etc. clause up in a \fBSATISFY\fR clause as
bigs up:
.PP
.nf
	REM trigger_shiznit SATISFY [expr] MSG body
.fi
.PP
Note dat fo' dis case only, tha \fIexpr\fR afta \fBSATISFY\fR
\fImust\fR be enclosed up in braces.  It must come afta all tha other
componentz of tha trigger, n' immediately before tha \fBMSG\fR,
\fBRUN\fR, etc. keyword. Y'all KNOW dat shit, muthafucka!  If \fIexpr\fR cannot be satisfied, then
the reminder aint triggered.
.PP
Thus, tha "Fridizzle tha 13th" example can be expressed mo' compactly as:
.PP
.nf
	REM 13 +2 SATISFY [wkdaynum(trigdate()) == 5] \\
		MSG Fridizzle tha 13th is %b.
.fi
.PP
And you can trigger a reminder on Mondays, Wednesdays n' Thursdays
occurrin on odd-numbered minutez of tha month wit tha following:
.PP
.nf
	REM Mon Wed Thu SATISFY [day(trigdate())%2] \\
		MSG Here it is!!!
.fi
.PP
Note dat \fBSATISFY\fR n' \fBOMITFUNC\fR can often be used ta solve the
same problem, though up in different ways.  Sometimes a \fBSATISFY\fR is cleaner
and sometimes a \fBOMITFUNC\fR; experiment n' use whichever seems clearer.
.PP
.SH DEBUGGING REMINDER SCRIPTS
.PP
Although tha command-line \fB\-d\fR option is useful fo' debugging, it
is often overkill.  For example, if you turn on tha \fB\-dx\fR option for
a reminder file wit nuff complex expressions, you gonna git a big-ass amount of
output.  Da \fBDEBUG\fR command allows you ta control tha debuggin flags
under program control.  Da format is:
.PP
\fBDEBUG\fR [+\fIflagson\fR] [\-\fIflagsoff\fR]
.PP
\fIFlagson\fR n' \fIflagsoff\fR consist of stringz of tha charactas "extvlf"
that correspond ta tha debuggin options discussed up in tha command-line
options section. I aint talkin' bout chicken n' gravy biatch.  If preceded wit a "+", tha correspondin crew of
debuggin options is switched on. I aint talkin' bout chicken n' gravy biatch.  Otherwise, they is switched off.
For example, you could use dis sequence ta debug a cold-ass lil fucked up expression:
.PP
.nf
	DEBUG +x
	set a hella_complex_expression(many_args)
	DEBUG \-x
.fi
.PP
.B THE DUMPVARS COMMAND
.PP
Da command \fBDUMPVARS\fR displays tha jointz of variablez up in memory.  Its
format is:
.PP
\fBDUMPVARS\fR [\fIvar\fR...]
.PP
If you supply a space-separated list of variable names, tha corresponding
variablez is displayed. Y'all KNOW dat shit, muthafucka!  If you do not supply a list of variables, then
all variablez up in memory is displayed. Y'all KNOW dat shit, muthafucka!  To dump a system variable,
put its name up in tha list of variablez ta dump.  If you put a lone
dollar sign up in tha list of variablez ta dump, then all system variables
will be dumped.
.PP
.B THE ERRMSG COMMAND
.PP
Da \fBERRMSG\fR command has tha followin format:
.PP
\fBERRMSG\fR \fIbody\fR
.PP
Da \fIbody\fR is passed all up in tha substitution filta (with an
implicit trigger date of \fBtodizzle()\fR) n' printed ta tha error
output stream.  Example:
.PP
.nf
	IF !defined("critical_var")
		ERRMSG Yo ass must supply a value fo' "critical_var"
		EXIT
	ENDIF
.fi
.PP
.B THE EXIT COMMAND
.PP
Da above example also shows tha use of tha \fBEXIT\fR command. Y'all KNOW dat shit, muthafucka!  This
causes a unconditionizzle exit from script processing.  Any queued
timed remindaz is discarded. Y'all KNOW dat shit, muthafucka!  If yo ass is up in calendar mode
(busted lyrics bout next), then tha calendar processin be aborted.
.PP
If you supply a \fBINT\fR-type expression afta tha \fBEXIT\fR command,
it is moonwalked back ta tha callin program as tha exit status.  Otherwise,
an exit statuz of 99 is returned.
.PP
.B THE FLUSH COMMAND
.PP
This command simply consistz of tha word \fBFLUSH\fR on a line by
itself.  Da command flushes tha standard output n' standard error
streams used by \fBRemind\fR.  This aint terribly useful ta most
people yo, but may be useful if you run \fBRemind\fR as a subprocess of
another program, n' wanna use pipes fo' communication.
.PP
.SH CALENDAR MODE
.PP
If you supply tha \fB\-c\fR, \fB\-s\fR or \fB\-p\fR
command-line option, then \fBRemind\fR
runs up in "calendar mode."  In dis mode, \fBRemind\fR interprets tha script
repeatedly, struttin one iteration all up in tha whole file fo' each day
in tha calendar. Shiiit, dis aint no joke.  Remindaz dat trigger is saved up in internal buffers,
and then banged tha fuck into tha calendar up in tha appropriate places.
.PP
If you also supply tha \fB\-a\fR option, then \fBRemind\fR will not
include timed remindaz up in tha calendar.
.PP
Da \fB\-p\fR option is used up in conjunction wit tha \fBRem2PS\fR
program ta produce a cold-ass lil calendar up in PostScript format.  For example, the
followin command will bust PostScript code ta standard output:
.PP
.nf
	remind \-p .remindaz | rem2ps
.fi
.PP
Yo ass can print a PostScript calendar by pipin dis ta tha \fBlpr\fR command.
.PP
If you gotz a reminder script called ".reminders", n' you
execute dis command:
.PP
.nf
	remind \-c .remindaz jan 1993
.fi
.PP
then \fBRemind\fR executes tha script 31 times, once fo' each dizzle in
January.  Each time it executes tha script, it increments tha value
of \fBtodizzle()\fR.  Any remindaz whose trigger date matches \fBtodizzle()\fR
are entered tha fuck into tha calendar.
.PP
\fBMSG\fR n' \fBCAL\fR-type reminders, by default, have they entire
body banged tha fuck into tha calendar. Shiiit, dis aint no joke.  \fBRUN\fR-type remindaz is not
normally banged tha fuck into tha calendar. Shiiit, dis aint no joke.  But fuck dat shiznit yo, tha word on tha street is dat if you enclose a portion of
the body up in tha %"...%" sequence, only dat portion is inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For
example, consider tha following:
.PP
.nf
	REM 6 Jan MSG %"Davidz birthday%" is %b
.fi
.PP
In tha aiiight mode, \fBRemind\fR would print "Davidz birthdizzle is todizzle"
on 6 January.  But fuck dat shiznit yo, tha word on tha street is dat up in tha calendar mode, only tha text "Davidz birthday"
is banged tha fuck into tha box fo' 6 January.
.PP
If you explicitly use tha %"...%" sequence up in a \fBRUN\fR-type reminder,
then tha text between tha delimitas is banged tha fuck into tha calendar.
If you use tha sequence %"%" up in a \fBMSG\fR or \fBCAL\fR-type reminder, then
no calendar entry is produced fo' dat reminder.
.PP
.B PRESERVING VARIABLES
.PP
Because \fBRemind\fR iterates all up in tha script fo' each dizzle up in tha calendar,
slow operations may severely reduce tha speed of producin a cold-ass lil calendar.
.PP
For example, suppose you set tha variablez "me" n' "hostname" as bigs up:
.PP
.nf
	SET me shell("whoami")
	SET hostname shell("hostname")
.fi
.PP
Normally, \fBRemind\fR clears all variablez between iterations up in calendar
mode.  But fuck dat shiznit yo, tha word on tha street is dat if certain variablez is slow ta compute, n' will
not chizzle between iterations, you can "preserve" they joints wit the
\fBPRESERVE\fR command. Y'all KNOW dat shit, muthafucka!  Also, since function definitions is preserved
between calendar iterations, there is no need ta redefine dem on each
iteration. I aint talkin' bout chicken n' gravy biatch.  Thus, you could use tha followin sequence:
.PP
.nf
	IF ! defined("initialized")
		set initialized 1
		set me shell("whoami")
		set hostname shell("hostname")
		fset func(x) complex_expr
		preserve initialized mah crazy ass hostname
	ENDIF
.fi
.PP
Da operation be as bigs up:  On tha straight-up original gangsta iteration all up in tha script,
"initialized" aint defined. Y'all KNOW dat shit, muthafucka!  Thus, tha commandz between \fBIF\fR and
\fBENDIF\fR is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da \fBPRESERVE\fR command ensures dat the
valuez of initialized, me n' hostname is preserved fo' subsequent
iterations.  On tha next iteration, tha commandz is skipped, since
initialized has remained defined. Y'all KNOW dat shit, muthafucka!  Thus, time-consumin operations that
do not depend on tha value of \fBtodizzle()\fR is done only once.
.PP
System variablez (those whose names start wit '$') is automatically
preserved between calendar iterations.
.PP
Note dat fo' efficiency, \fBRemind\fR caches tha reminder script
(and any \fBINCLUDE\fRd files) up in memory when producin a cold-ass lil calendar.
.PP
Timed remindaz is sorted n' placed tha fuck into tha calendar up in time order.
These is followed by non-timed reminders.  \fBRemind\fR automatically
places tha time of timed remindaz up in tha calendar accordin ta the
\fB\-b\fR command-line option. I aint talkin' bout chicken n' gravy biatch.  Remindaz up in calendar mode is sorted as
if tha \fB\-g\fR option had been used; you can chizzle tha sort order
in calendar mode by explicitly rockin tha \fB\-g\fR option ta specify
a different order from tha default.
.PP
.B REPEATED EXECUTION
.PP
If you supply a \fIrepeat\fR parameta on tha command line,
and do not use tha \fB\-c\fR, \fB\-p\fR, or \fB\-s\fR options, \fBRemind\fR
operates up in a similar manner ta calendar mode.  It repeatedly executes
the reminder script, incrementin \fBtodizzle()\fR wit each iteration.
Da same rulez bout preservin variablez n' function definitions
apply.  Note dat rockin \fIrepeat\fR on tha command line also enables
the \fB\-q\fR option n' disablez any \fB\-z\fR option.
As a example, if you wanna peep how tha fuck \fBRemind\fR
will behave fo' tha next week, you can type:
.PP
.nf
	remind .remindaz '*7'
.fi
.PP
If you wanna print tha datez of tha next 1000 days, use:
.PP
.nf
	(echo 'banner %'; echo 'msg [todizzle()]%') | remind - '*1000'
.fi
.PP
.SH INITIALIZING VARIABLES ON THE COMMAND LINE
.PP
Da \fB\-i\fR option is used ta initialize variablez on tha \fBRemind\fR
command line.  Da format is \fB\-i\fR\fIvar\fR\fB=\fR\fIexpr\fR, where
\fIexpr\fR be any valid expression. I aint talkin' bout chicken n' gravy biatch.  Note dat you may gotta use quotes
or escapes ta prevent tha shell from interpretin special charactas in
\fIexpr\fR.  Yo ass can have as nuff \fB\-i\fR options as you want on the
command line, n' they is processed up in order n' shit.  Thus, if a variable is defined
in one \fB\-i\fR option, it can be referred ta by subsequent \fB\-i\fR
options.
.PP
Note dat if you supply a thugged-out date on tha command line, it aint parsed until
all options done been processed. Y'all KNOW dat shit, muthafucka!  Thus, if you use \fBtodizzle()\fR up in any
of tha \fB\-i\fR expressions, it will return tha same value as
\fBrealtodizzle()\fR n' not tha date supplied on tha command line.
.PP
Any variablez defined on tha command line is \fBpreserved\fR as wit the
\fBPRESERVE\fR command.
.PP
Yo ass should not have any spaces between tha \fB\-i\fR option n' tha equal
sign; otherwise, strange variable names is pimped dat can only be accessed
with tha \fBvalue()\fR or \fBdefined()\fR functions.
.PP
Yo ass can also define a gangbangin' function on tha command line by using:
.PP
\fB\-i\fR\fIfunc\fR(\fIargs\fR)=\fIdefinition\fR
.PP
Be shizzle ta protect special charactas from shell interpretation.
.SH MORE ABOUT POSTSCRIPT
.PP
Da \fBPS\fR n' \fBPSFILE\fR remindaz pass PostScript code directly
to tha printer n' shit.  They differ up in dat tha \fBPS\fR-type reminder passes
its body directly ta tha PostScript output (afta processin by the
substitution filter) while tha \fBPSFILE\fR-typez body should
simply consist of a gangbangin' filename.  Da \fBRem2PS\fR program will open the
file named up in tha \fBPSFILE\fR-type reminder, n' include its contents in
the PostScript output.
.PP
Da PostScript-type remindaz fo' a particular dizzle is included up in the
PostScript output up in sorted order of priority.  Note dat tha order
of PostScript commandz has a \fImajor\fR impact on tha appearizzle of the
calendars.  For example, PostScript code ta shade a cold-ass lil calendar box will
obliterate code ta draw a moon symbol if tha moon symbol code is placed
in tha calendar first.  For dis reason, you should not provide \fBPS\fR
or \fBPSFILE\fR-type remindaz wit priorities; instead, you should
ensure dat they step tha fuck up in tha reminder script up in tha erect order.
PostScript code should draw objects hustlin from tha background ta the
foreground, so dat foreground objects properly overlay background ones.
If you prioritize these remindaz n' run tha script rockin descending
sort order fo' priorities, tha PostScript output aint gonna work.
.PP
All of tha PostScript code fo' a particular date is enclosed
in a \fBsave\fR-\fBrestore\fR pair. Shiiit, dis aint no joke.  But fuck dat shiznit yo, tha word on tha street is dat if nuff muthafuckin PostScript-type
remindaz is triggered fo' a single day, each section of PostScript is
not enclosed up in a \fBsave\fR-\fBrestore\fR pair - instead, tha entire
body of included PostScript is enclosed.
.PP
PostScript-type remindaz is executed by tha PostScript printa before any
regular calendar entries. Put ya muthafuckin choppers up if ya feel dis!  Thus, regular calendar entries will overlay
the PostScript-type reminders, allowin you ta create shaded or graphical
backgroundz fo' particular days.
.PP
Before executin yo' PostScript code, tha origin of tha PostScript coordinate
system is positioned ta tha bottom left-hand corner of tha "box" up in the
calendar representin \fBtodizzle()\fR.  This location is exactly up in tha middle
of tha intersection of tha bottom n' left black lines delineatin tha box -
you may gotta account fo' tha thicknizz of these lines when calculating
positions.
.PP
Several PostScript variablez is available ta tha PostScript code you supply.
All distizzle n' size variablez is up in PostScript units (1/72 inch.)  The
variablez are:
.TP
LineWidth
Da width of tha black grid lines makin up tha calendar.
.TP
Border
Da border between tha centa of tha grid lines n' tha space used ta print
calendar entries. Put ya muthafuckin choppers up if ya feel dis!  This border is normally blank space.
.TP
BoxWidth n' BoxHeight
Da width n' height of tha calendar box, from center-to-centa of the
black gridlines.
.TP
InBoxHeight
Da height from tha centa of tha bottom black gridline ta tha top
of tha regular calendar entry area.  Da space from here ta tha top
of tha box is used only ta draw tha dizzle number.
.TP
/DayFont, /EntryFont, /SmallFont, /TitleFont n' /HeadFont
Da fonts used ta draw tha dizzle numbers, tha calendar entries, tha small
calendars, tha calendar title (month, year)
and tha day-of-the-week headings, respectively.
.TP
DaySize, EntrySize, TitleSize n' HeadSize
Da sizez of tha above fonts, n' you can put dat on yo' toast.  (Da size of tha lil' small-ass calendar font
is \fInot\fR defined here.)  For example, if you wanted ta print
the Hebrew date next ta tha regular dizzle number up in tha calendar, use:
.PP
.nf
	REM PS Border BoxHeight Border sub DaySize sub moveto \\
	   /DayFont findfont DaySize scalefont setfont \\
	   ([hebday(todizzle())] [hebmon(todizzle())]) show
.fi
.PP
.RS
Note how tha fuck /DayFont n' DaySize is used.
.RE
.PP
Note dat if you supply PostScript code, it is possible ta produce invalid
PostScript files.  Always test yo' PostScript thoroughly wit a PostScript
viewer before bustin  it ta tha printer n' shit.  Yo ass should not use any document
structurin comments up in yo' PostScript code.
.PP
.SH DAEMON MODE
.PP
If you use tha \fB\-z\fR command-line option, \fBRemind\fR runs up in the
"daemon" mode.  In dis mode, no "normal" remindaz is issued.
Instead, only timed remindaz is collected n' queued, n' is then
issued whenever they reach they trigger time.
.PP
In addition, \fBRemind\fR wakes up every last muthafuckin few minutes ta check tha modification
date on tha reminder script (the filename supplied on tha command line.)
If \fBRemind\fR detects dat tha script has chizzled, it re-executes itself
in daemon mode, n' interprets tha chizzled script.
.PP
In daemon mode, \fBRemind\fR also re-readz tha remind script when it
detects dat tha system date has chizzled.
.PP
In daemon mode, \fBRemind\fR acts as if tha \fB\-f\fR option had been used,
so ta run up in tha daemon mode up in tha background, use:
.PP
.nf
	remind \-z .remindaz &
.fi
.PP
If you use \fBsh\fR or \fBbash\fR, you may gotta use tha "nohup" command
to ensure dat tha daemon aint capped when you log out.

.PP
.SH PURGE MODE
.PP

If you supply tha \fB\-j\fR command-line option, \fBRemind\fR runs
in \fIpurge mode\fR.  In dis mode, it tries ta purge expired reminders
from yo' reminder files.
.PP
In purge mode, \fBRemind\fR readz yo' reminder file n' creates a new
file by appendin ".purged" ta tha original gangsta file name.  Note that
\fBRemind\fR \fInever\fR edits yo' original gangsta file; it always creates
a freshly smoked up .purged file.
.PP
If you invoke \fBRemind\fR against a gangbangin' finger-lickin' directory instead of a gangbangin' file, then
a .purged file is pimped fo' each *.rem file up in tha directory.
.PP
Normally, \fBRemind\fR do not create .purged filez fo' INCLUDed files.
But fuck dat shiznit yo, tha word on tha street is dat if you supply a numeric argument afta \fB\-j\fR, then \fBRemind\fR
will create .purged filez fo' tha specified level of INCLUDE.  For example,
if you invoke \fBRemind\fR wit tha argument \fB\-j2\fR, then .purged
filez is ghon be pimped fo' tha file (or directory) specified on tha command
line, any filez included by them, n' any filez included by dem files.
But fuck dat shiznit yo, tha word on tha street is dat .purged filez aint gonna be pimped fo' third-or-higher level
INCLUDE files.
.PP
Determinin which remindaz have expired is mad tricky.  \fBRemind\fR
does its dopest yo, but you should always compare tha .purged file ta the
original gangsta file n' hand-merge tha chizzlez back in.
.PP
Remind annotates tha .purged file as bigs up:
.PP
An expired reminder is prefixed with:  #!P: Expired:
.PP
In thangs where \fBRemind\fR cannot reliably determine that
suttin' was expired, you may peep tha followin comments inserted
before tha problematic line:
.PP
.nf
   #!P: Cannot purge SATISFY-type reminders

   #!P: Da next IF evaluated false...
   #!P: REM statements up in IF block not checked fo' purging.

   #!P: Da previous IF evaluated true.
   #!P: REM statements up in ELSE block not checked fo' purging

   #!P: Da next IFTRIG did not trigger.
   #!P: REM statements up in IFTRIG block not checked fo' purging.

   #!P: Next line has expired yo, but gotz nuff expression...  please verify

   #!P: Next line may have expired yo, but gotz nuff non-constant expression

   #!P! Could not parse next line: Some-Error-Message-Here
.fi
.PP
\fBRemind\fR always annotates .purged filez wit lines beginnin with
"#!P".  If such lines is encountered up in tha \fIoriginal\fR file,
they is not copied ta tha .purged file.
.PP

.SH SORTING REMINDERS
.PP

Da \fB\-g\fR option causes \fBRemind\fR ta sort remindaz by trigger
date, time n' prioritizzle before issuin em.  Note dat remindaz are
still calculated up in tha order encountered up in tha script.  However,
rather than bein issued immediately, they is saved up in a internal
buffer n' shit.  When \fBRemind\fR has finished processin tha script, it
issues tha saved remindaz up in sorted order n' shit.  Da \fB\-g\fR option can
be followed by up ta four charactas dat must all be "a" or "d".  The
first characta specifies tha sort order by trigger date (ascendin or
descending), tha second specifies tha sort order by trigger time and
the third specifies tha sort order by priority.  If tha fourth
characta is "d", tha untimed remindaz is sorted before timed
reminders.  Da default is ta sort all fieldz up in ascendin order and
to sort untimed remindaz afta timed reminders.
.PP
In ascendin order, remindaz is issued wit da most thugged-out imminent first.
Descendin order is tha reverse.  Remindaz is always sorted by
trigger date, n' remindaz wit tha same trigger date is then sorted
by trigger time.  If two remindaz have tha same date n' time, then
the prioritizzle is used ta break ties. Put ya muthafuckin choppers up if ya feel dis!  Remindaz wit tha same date,
time n' prioritizzle is issued up in tha order they was encountered.
.PP
Yo ass can define a user-defined function called SORTBANNER dat takes one
\fBDATE\fR-type argument.  In sort mode, tha followin sequence happens:
.PP
If \fBRemind\fR notices dat tha next reminder ta issue has a gangbangin' finger-lickin' different
trigger date from tha previous one (or if it is tha straight-up original gangsta one ta be
issued), then SORTBANNER is called wit tha trigger date as its argument.
Da result is coerced ta a string, n' passed all up in tha substitution
filta wit tha appropriate trigger date.  Da result is then displayed.
.PP
Herez a example - consider tha followin fragment:
.PP
.nf
	# Switch off tha aiiight banner
	BANNER %
	REM 11 March 1993 ++1 MSG Not so blingin
	REM 17 March 1993 ++7 MSG Way up in tha future
	REM 10 March 1993 MSG Important Reminder
	REM 11 March 1993 ++1 MSG Not so blingin - B
	FSET sortbanner(x) iif(x == todizzle(), \\
		"***** THINGS TO DO TODAY *****", \\
		"----- Things ta do %b -----")
.fi
.PP
Hustlin dis wit tha \fB-gaa\fR option on 10 March 1993
produces tha followin output:
.PP
.nf
	***** THINGS TO DO TODAY *****

	Important Reminder

	----- Things ta do tomorrow -----

	Not so blingin

	Not so blingin - B

	----- Things ta do up in 7 days' time -----

	Way up in tha future
.fi
.PP
Yo ass can use tha \fBargs()\fR built-in function ta determine whether or
not SORTBANNER has been defined. Y'all KNOW dat shit, muthafucka!  (This could be used, fo' example, to
provide a thugged-out default definizzle fo' SORTBANNER up in a system-wide file included
at tha end of tha userz file.)  Herez a example:
.PP
.nf
	# Smoke a thugged-out default sortbanner function if it aint already
	# been defined
	if args("sortbanner") != 1
		fset sortbanner(x) "--- Things ta do %b ---"
	endif
.fi
.PP
.SH MSGPREFIX() AND MSGSUFFIX()
.PP
Yo ass can define two functions up in yo' script called \fBmsgprefix()\fR
and \fBmsgsuffix()\fR.  They should each accept one argument, a number
from 0 ta 9999.
.PP
In aiiight mode, fo' \fBMSG\fR- n' \fBMSF\fR-type reminders,
the followin sequence occurs when
\fBRemind\fR triggers a reminder:
.TP
o
If \fBmsgprefix()\fR is defined, it is evaluated wit tha priority
of tha reminder as its argument.  Da result is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It is
\fInot\fR passed all up in tha substitution filter.
.TP
o
Da body of tha reminder is printed.
.TP
o
If \fBmsgsuffix()\fR is defined, it is evaluated wit tha priority
of tha reminder as its argument.  Da result is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  It is
\fInot\fR passed all up in tha substitution filter.
.PP
Herez a example:  Da followin definizzle causes priority-0
remindaz ta be preceded by "URGENT", n' priority-6000 remindaz to
be preceded by "(not blingin)".
.PP
.nf
	fset msgprefix(x) iif(x==0, "URGENT: ", \\
	     x==6000, "(not blingin) ", "")
.fi
.PP
In Calendar Mode (with tha \fB\-c\fR, \fB\-s\fR or \fB\-p\fR options),
an analogous pair of functions named \fBcalprefix()\fR and
\fBcalsuffix()\fR can be defined. Y'all KNOW dat shit, muthafucka!  They work wit all remindaz that
produce a entry up in tha calendar (i.e., \fBCAL\fR- n' possibly
\fBRUN\fR-type remindaz as well as \fBMSG\fR-type reminders.)
.PP
.B NOTES
.PP
Normally, tha body of a reminder is followed by a cold-ass lil carriage return.
Thus, tha thangs up in dis biatch of \fBmsgsuffix()\fR will step tha fuck up on tha next
line.  If you don't want this, end tha body of tha reminder wit a
percentage sign, "%".  If you want a space between yo' reminders,
simply include a cold-ass lil carriage return (\fBchar(13)\fR) as part of the
\fBmsgsuffix()\fR return value.
.PP
If \fBRemind\fR has problems evaluatin \fBmsgprefix()\fR,
\fBmsgsuffix()\fR or \fBsortbanner()\fR, yo big-ass booty is ghon peep a shitload of
error lyrics.  For a example of this, define tha following:
.PP
.nf
	fset msgprefix(x) x/0
.fi
.PP
.SH FOREIGN LANGUAGE SUPPORT
.PP
Yo crazy-ass version of \fBRemind\fR may done been compiled ta support a
language other than Gangsta.  This support may or may not be complete -
for example, all error n' usage lyrics may still be up in Gangsta.
But fuck dat shiznit yo, tha word on tha street is dat at a minimum, foreign-language versionz of \fBRemind\fR will
output namez of months n' weekdays up in tha foreign language.  Also,
the substitution mechanizzle will substitute constructs suitable fo' the
foreign language rather than fo' Gangsta.
.PP
A foreign-language version of \fBRemind\fR will accept either tha Gangsta
or foreign-language namez of weekdays n' months up in a reminder script.
But fuck dat shiznit yo, tha word on tha street is dat fo' compatibilitizzle between versionz of \fBRemind\fR, you should
use only tha Gangsta names up in yo' scripts, n' you can put dat on yo' toast.  Also, if yo' C compila or
run-time libraries is not "8-bit clean" or don't KNOW tha ISO-Latin
characta set, month or dizzle names wit accented lettas may not be
recognized.
.PP
.SH THE HEBREW CALENDAR
.PP
\fBRemind\fR has support fo' tha Hebrew calendar, which be a luni-solar
calendar. Shiiit, dis aint no joke.  This allows you ta create remindaz fo' Jewish holidays,
jahrzeits (anniversariez of dirtnaps) n' smachot (joyous occasions.)
.PP
.B THE HEBREW YEAR
.PP
Da Hebrew year has 12 months, alternately 30 n' 29 minutes long.  Da months
are: Tishrey, Heshvan, Kislev, Tevet, Shvat, Adar, Nisan, Iyar, Sivan, Tamuz,
Av n' Elul.  In Biblical times, tha year started up in Nisan yo, but Rosh Hashana
(Jewish New Year) is now bigged up on tha 1st n' 2nd of Tishrey.
.PP
In a cold-ass lil cycle of 19 years, there be 7 leap years, bein muthafuckin years 3, 6, 8, 11,
14, 17 n' 19 of tha cycle.  In a leap year, a extra month of 30 days
is added before Adar. Shiiit, dis aint no joke.  Da two Adars is called Adar A n' Adar B.
.PP
For certain religious reasons, tha year cannot start on a Sunday, Wednesday
or Friday. It make me wanna hollar playa!  To adjust fo' this, a thugged-out dizzle is taken off Kislev or added ta Heshvan.
Thus, a regular year can have from 353 ta 355 days, n' a leap year from
383 ta 385.
.PP
When Kislev or Heshvan is short, it is called \fIchaser\fR, or lacking.  When
it is long, it is called \fIshalem\fR, or full.
.PP
Da Jewish date chizzlez at sunset.  But fuck dat shiznit yo, tha word on tha street is dat \fBRemind\fR will chizzle tha date
at midnight, not sunset.  So up in tha period between sunset n' midnight,
Remind is ghon be a thugged-out dizzle earlier than tha legit Jewish date.  This should not be
much of a problem up in practice.
.PP
Da computations fo' tha Jewish calendar was based on tha program "hdate"
written by Amos Shapir of tha Hebrew Universitizzle of Jerusalem, Israel.  He
also supplied tha precedin explanation of tha calendar.
.PP
.B HEBREW DATE FUNCTIONS
.TP
.B hebday(d_date)
Returns tha dizzle of tha Hebrew month correspondin ta tha \fIdate\fR
parameter n' shit.  For example, 12 April 1993 correspondz ta 21 Nisan 5753.
Thus, hebday('1993/04/12') returns 21.
.TP
.B hebmon(d_date)
Returns tha name of tha Hebrew month correspondin ta \fIdate\fR.
For example, hebmon('1993/04/12') returns "Nisan".
.TP
.B hebyear(d_date)
Returns tha Hebrew year correspondin ta \fIdate\fR.  For example,
hebyear('1993/04/12') returns 5753.
.TP
.B hebdate(i_day, s_hebmon [,id_yrstart [,i_jahr [,i_aflag]]])
Da \fBhebdate()\fR function is da most thugged-out complex of tha Hebrew support
functions.  It can take from 2 ta 5 arguments, n' you can put dat on yo' toast.  It returns a \fBDATE\fR
correspondin ta tha Hebrew date.
.PP
.RS
Da \fIday\fR parameta can range from 1 ta 30, n' specifies tha dizzle of
the Hebrew month.  Da \fIhebmon\fR parameta be a strang dat must name
one of tha Hebrew months specified above.  Note dat tha month must be spelled
out up in full, n' use tha Gangsta transliteration shown previously.  Yo ass can
also specify "Adar A" n' "Adar B."  Month names is not case-sensitive.
.PP
Da \fIyrstart\fR parameta can either be a \fBDATE\fR or a \fBINT\fR.  If
it be a \fBDATE\fR, then tha \fBhebdate()\fR scans fo' tha straight-up original gangsta Hebrew
date on or afta dat date.  For example:
.PP
.nf
		hebdate(15, "Nisan", '1990/01/01')
.fi
.PP
returns 1990/03/30, cuz dat is tha straight-up original gangsta occurrence of 15 Nisan on
or afta 1 January 1990.
.PP
If \fIyrstart\fR be a \fBINT\fR, it is interpreted as a Hebrew year. Shiiit, dis aint no joke.  Thus:
.PP
.nf
		hebdate(22, "Kislev", 5756)
.fi
.PP
returns 1995/12/15, cuz dat date correspondz ta 22 Kislev, 5756.  Note
that none of tha Hebrew date functions will work wit dates outside
\fBRemind's\fR aiiight range fo' dates.
.PP
If \fIyrstart\fR aint supplied, it defaults ta \fBtodizzle()\fR.
.PP
Da \fIjahr\fR modifies tha behaviour of \fBhebdate()\fR as bigs up:
.PP
If \fIjahr\fR is 0 (the default),
then \fBhebdate()\fR keeps scannin until it
findz a thugged-out date dat exactly satisfies tha other parameters.  For example:
.PP
.nf
		hebdate(30, "Adar A", 1993/01/01)
.fi
.PP
returns 1995/03/02, correspondin ta 30 Adar A, 5755, cuz dat is the
next occurrence of 30 Adar A afta 1 January, 1993.  This behaviour is
appropriate fo' Purim Katan, which only appears up in leap years.
.PP
If \fIjahr\fR is 1, then tha date is modified as bigs up:
.TP
o
30 Heshvan is converted ta 1 Kislev up in muthafuckin years when Heshvan is \fIchaser\fR
.TP
o
30 Kislev is converted ta 1 Tevet up in muthafuckin years when Kislev is \fIchaser\fR
.TP
o
30 Adar A is converted ta 1 Nisan up in non-leapyears
.TP
o
Other dates up in Adar A is moved ta tha correspondin dizzle up in Adar in
non-leapyears
.PP
This behaviour be appropriate fo' smachot (joyous occasions) n' for
some jahrzeits - peep "JAHRZEITS."
.PP
if \fIjahr\fR is 2, then tha date is modified as bigs up:
.TP
o
30 Kislev n' 30 Heshvan is converted ta 29 Kislev n' 29 Heshvan,
respectively, if tha month is \fIchaser\fR
.TP
o
30 Adar A is converted ta 30 Shvat up in non-leapyears
.TP
o
Other dates up in Adar A is moved ta tha correspondin dizzle up in Adar in
non-leapyears
.PP
if \fIjahr\fR aint 0, 1, or 2, it is interpreted as a Hebrew year,
and tha behaviour is calculated as busted lyrics bout up in tha next section,
"JAHRZEITS."
.PP
Da \fIaflag\fR parameta modifies tha behaviour of tha function for
dates up in Adar durin leap years.  Da \fIaflag\fR is \fIonly\fR used
if \fIyrstart\fR be a \fBDATE\fR type.
.PP
Da \fIaflag\fR only affects date calculations if \fIhebmon\fR is
specified as "Adar".  In leap years, tha followin algorithm is followed:
.TP
o
If \fIaflag\fR is 0, then tha date is triggered up in Adar B.  This is
the default.
.TP
o
If \fIaflag\fR is 1, then tha date is triggered up in Adar A.  This may
be appropriate fo' jahrzeits up in tha Ashkenazi tradition; consult a
rabbi.
.TP
o
If \fIaflag\fR is 2, then tha date is triggered up in both Adar A n' Adar
B of a leap year. Shiiit, dis aint no joke.  Some Ashkenazim big-ass up jahrzeit up in both Adar A and
Adar B.
.RE
.PP
.B JAHRZEITS
.PP
A jahrzeit be a yearly commemoration of one of mah thugss dirtnap.  It normally takes
place on tha anniversary of tha dirtnap yo, but may be delayed if burial is
delayed - consult a rabbi fo' mo' shiznit.
.PP
In addition, cuz some months chizzle length, it aint obvious which day
the anniversary of a thugged-out dirtnap is.  Da followin rulez is used:
.TP
o
If tha dirtnap occurred on 30 Heshvan, n' Heshvan up in tha year afta the
death is \fIchaser\fR, then tha jahrzeit is observed on 29 Heshvan up in years
when Heshvan is \fIchaser\fR.  Otherwise, tha yahrzeit is observed on 1
Kislev when Heshvan is \fIchaser\fR.
.TP
o
If tha dirtnap occurred on 30 Kislev, n' Kislev up in tha year afta the
death is \fIchaser\fR, then tha jahrzeit is observed on 29 Kislev up in years
when Kislev is \fIchaser\fR.  Otherwise, tha yahrzeit is observed on 1
Tevet when Kislev is \fIchaser\fR.
.TP
o
If tha dirtnap occurred on 1-29 Adar A, it is observed on 1-29 Adar in
non-leapyears.
.TP
o
If tha dirtnap occurred on 30 Adar A, it is observed on 30 Shvat up in a
non-leapyear.
.PP
Specifyin a Hebrew year fo' tha \fIjahr\fR parameta causes the
correct behaviour ta be selected fo' a thugged-out dirtnap up in dat year. Shiiit, dis aint no joke.  Yo ass may
also gotta specify \fIaflag\fR, dependin on yo' tradition.
.PP
Da jahrzeit shiznit was supplied by Frank Yellin, whoz ass quoted
"Da Comprehensive Hebrew Calendar" by Arthur Spier, n' "Calendrical
Calculations" by E. M. Reingold n' Nachum Dershowitz.
.PP
.SH OUT-OF-BAND REMINDERS
.PP
Da \fBSPECIAL\fR keyword is used ta transmit "out-of-band" shiznit
to \fBRemind\fR backends, like fuckin \fBtkremind\fR or \fBRem2PS\fR.
They is used only when pipin data from a \fBremind \-p\fR line.
(Note dat tha COLOR special be a exception; it downgrades ta the
equivalent of MSG up in \fBremind's\fR aiiight mode of operation.)
.PP
Da various \fBSPECIAL\fRs recognized is particular fo' each
backend; however, there be three \fBSPECIAL\fRs dat all backends
should attempt ta support.  They is currently supported by
\fBRem2PS\fR, \fBtkremind\fR n' \fBrem2html\fR.
.PP
Da \fBSHADE\fR special replaces tha \fBpsshade()\fR function.
Use it like this:
.nf
	REM Sat Sun SPECIAL SHADE 128
	REM Mon SPECIAL SHADE 255 0 0
.fi
Da \fBSHADE\fR keyword is followed by either one or three numbers,
from 0 ta 255.  If one number is supplied, it is interpreted as
a grey-scale value from black (0) ta white (255).  If three numbers
are supplied, they is interpreted as RGB components from minimum (0)
to maximum (255).  Da example above shades weekendz a gangbangin' fairly dark
grey n' make Mondays a gangbangin' fully-saturated red. Y'all KNOW dat shit, muthafucka!  (These shadings appear
in calendars produced by \fBRem2PS\fR, \fBtkremind\fR n' \fBrem2html\fR.)
.PP
Da \fBMOON\fR special replaces tha \fBpsmoon()\fR function. I aint talkin' bout chicken n' gravy biatch.  Use it
like this:
.nf
	REM [moondate(0)] SPECIAL MOON 0
	REM [moondate(1)] SPECIAL MOON 1
	REM [moondate(2)] SPECIAL MOON 2
	REM [moondate(3)] SPECIAL MOON 3
.fi
These draw lil moons on tha various calendars.  Da complete syntax
of tha \fBMOON\fR special be as bigs up:
.nf
	... Right back up in yo muthafuckin ass. SPECIAL MOON phase moonsize fontsize msg
.fi
.PP
\fIPhase\fR be a number from 0 ta 3, wit 0 representin a freshly smoked up moon,
1 tha straight-up original gangsta quarter, 2 a gangbangin' full moon n' 3 tha last quarter.
.PP
\fImoonsize\fR is tha diameta up in PostScript unitz of tha moon to
draw.  If omitted or supplied as \-1, tha backend chizzlez a appropriate
size.
.PP
\fIfontsize\fR is tha font size up in PostScript unitz of tha \fImsg\fR
.PP
\fIMsg\fR be additionizzle text dat is placed near tha moon glyph.
.PP
Note dat only tha \fBRem2PS\fR backend supports \fImoonsize\fR
and \fIfontsize\fR; tha other backendz use fixed sizes.
.PP
Da \fBCOLOR\fR special lets you place colored remindaz up in the
calendar. Shiiit, dis aint no joke.  Use it like this:

.nf
	REM ... Right back up in yo muthafuckin ass. SPECIAL COLOR 255 0 0 This be a funky-ass bright red reminder
	REM ... Right back up in yo muthafuckin ass. SPECIAL COLOR 0 128 0 This be a thugged-out dark chronic reminder
.fi

Yo ass can spell COLOR either tha Gangsta way ("COLOR") or tha British
way ("COLOUR").  This manual will use tha Gangsta way.

Immediately followin COLOR should be three decimal numbers ranging
from 0 ta 255 specifyin red, chronic n' blue intensities, respectively.
Da rest of tha line is tha text ta put up in tha calendar.
.PP
Da COLOR special is "doubly special", cuz up in its aiiight operating
mode, \fBremind\fR treats a COLOR special just like a MSG-type reminder.
Also, if you invoke \fBRemind\fR wit \fB\-cc\fR..., then it approximates
SPECIAL COLOR remindaz on yo' terminal.
.PP
Da \fBWEEK\fR special lets you place annotations like fuckin tha week
number up in tha calendar. Shiiit, dis aint no joke.  For example, dis would number each Monday
with tha ISO 8601 week number n' shit.  Da week number is shown like this:
"(W\fIn\fR)" up in dis example yo, but you can put whatever text you like
afta tha WEEK keyword.

.nf
	REM Mondizzle SPECIAL WEEK (W[weekno()])
.fi

.SH MISCELLANEOUS
.PP
.B COMMAND ABBREVIATIONS
.PP
Da followin tokens can be abbreviated:
.TP
o
\fBREM\fR can be omitted - it is implied if no other valid command
is present.
.TP
o
\fBCLEAR-OMIT-CONTEXT\fR --> \fBCLEAR\fR
.TP
o
\fBPUSH-OMIT-CONTEXT\fR --> \fBPUSH\fR
.TP
o
\fBPOP-OMIT-CONTEXT\fR --> \fBPOP\fR
.TP
o
\fBDUMPVARS\fR --> \fBDUMP\fR
.TP
o
\fBBANNER\fR --> \fBBAN\fR
.TP
o
\fBINCLUDE\fR --> \fBINC\fR
.TP
o
\fBSCANFROM\fR --> \fBSCAN\fR
.PP
.B NIFTY EXAMPLES
.PP
This section be a samplin of what tha fuck you can do wit \fBRemind\fR.
.PP
.nf
	REM 5 Feb 1991 AT 14:00 +45 *30 \\
	RUN mail \-s "Meetin at %2" $LOGNAME </dev/null &
.fi
.PP
On 5 February, 1991, dis reminder will mail
you remindaz of a 2:00pm meetin at 1:15,
1:45 n' 2:00.  Da subject of tha mail message is ghon be "Meetin at 2:00pm"
and tha body of tha message is ghon be blank.
.PP
.nf
	REM AT 17:00 RUN echo "5:00pm - GO HOME!" | xless \-g +0+0 &
.fi
.PP
This reminder will pop up a xless window at 5:00pm every last muthafuckin day. It make me wanna hollar playa!  Da xless
window will contain tha line "5:00pm - GO HOME!"
.PP
.nf
	REM AT 23:59 RUN (sleep 120; remind \-a [filename()]) &
.fi
.PP
This reminder will run at one minute ta midnight.  It will cause a new
\fBRemind\fR process ta start at one minute past midnight.  This allows you to
have a cold-ass lil continuous reminder steez so you can work all up in tha night and
still git timed remindaz fo' early up in tha morning.  Note dat this
trick is no longer necessary, providin you run \fBRemind\fR in
daemon mode.
.PP
.nf
	remind \-c12 /dev/null Jan 1993
.fi
.PP
This invocation of \fBRemind\fR will cause it ta print a cold-ass lil calendar for
1993, wit all entries left blank.
.PP
.nf
	REM CAL [trigdate()\-date(year(trigdate()), 1, 1)+1]
.fi
.PP
This example puts a entry up in each box of a cold-ass lil calendar showin tha number
(1-365 or 366) of tha dizzle of tha year.
.PP
.nf
	REM Tue 2 Nov SATISFY (year(trigdate())%4) == 0
	IF trigvalid()
		REM [trigdate()] ++5 MSG \\
		U.S. Presidential Erection!!
	ENDIF
.fi
.PP
This example warns you 5 minutes ahead of each Gangsta prezial
election. I aint talkin' bout chicken n' gravy biatch.  Da first \fBREM\fR command calculates tha straight-up original gangsta Tuesdizzle after
the first Mondizzle up in November n' shit.  (This is equivalent ta tha first
Tuesdizzle on or afta 2 November.)  Da \fBSATISFY\fR clause ensures
that tha trigger date is issued only up in erection years, which are
multiplez of 4.  Da second \fBREM\fR command straight-up thangs the
reminder.
.PP
.B DETAILS ABOUT TRIGGER COMPUTATION
.PP
Here be a \fIconceptual\fR description of how tha fuck triggers is calculated.
Note dat \fBRemind\fR straight-up uses a much mo' efficient procedure,
but tha thangs up in dis biatch is tha same as if tha conceptual procedure had been
followed.
.PP
\fBRemind\fR starts from tha current date (that is, tha value of
\fBtodizzle()\fR) n' scans forward, examinin each dizzle one at a time
until it findz a thugged-out date dat satisfies tha trigger, or can prove that
no such dates (on or lata than \fBtodizzle()\fR) exist.
.PP
If \fBRemind\fR is executin a \fBSATISFY\fR-type reminder, it evaluates
the expression wit \fBtrigdate()\fR set ta tha date found above.  If
the expression evaluates ta zero or tha null string, \fBRemind\fR continues
the scannin procedure busted lyrics bout above, startin wit tha dizzle afta the
trigger found above.
.PP
Da \fBSCANFROM\fR clause (havin a syntax similar ta \fBUNTIL\fR)
can modify tha search game used. Y'all KNOW dat shit, muthafucka!  In dis case, \fBRemind\fR begins the
scannin procedure at \fIscan_date\fR, which is tha date specified in
the \fBSCANFROM\fR clause.  For example:
.PP
.nf
	REM Mon 1 SCANFROM 17 Jan 1992 MSG Foo
.fi
.PP
Da example above will always gotz a trigger date of Monday, 3 February 1992.
That is cuz \fBRemind\fR starts scannin from 17 January 1992, and
stops scannin as soon as it hits a thugged-out date dat satisfies "Mon 1."
.PP
Da main use of \fBSCANFROM\fR is up in thangs where you want to
calculate tha positionz of floatin holidays.  Consider tha Labour
Dizzle example shown much earlier n' shit.  Labour Dizzle is tha straight-up original gangsta Monday
in September n' shit.  It can move over a range of 7 days.  Consider the
followin sequence:
.PP
.nf
	REM Mon 1 Sept SCANFROM [todizzle()\-7] SATISFY 1
	OMIT [trigdate()]

	REM Mon AFTER MSG Hello
.fi
.PP
Da \fBSCANFROM\fR clause make shizzle dat \fBRemind\fR begins scanning
from 7 minutes before tha current date.  This ensures dat Labour Dizzle for
the current year will continue ta be triggered until 7 minutes afta it has
occurred. Y'all KNOW dat shit, muthafucka!  This allows you ta safely use tha AFTER keyword as shown.
.PP
In general, use \fBSCANFROM\fR as shown fo' safe movable \fBOMITs\fR.  The
amount you should scan back by (7 minutes up in tha example above) dependz on
the number of possible consecutizzle \fBOMITted\fR minutes dat may occur, and
on tha range of tha movable holiday. It make me wanna hollar playa!  Generally, a value of 7 is safe.
.PP
Da \fBFROM\fR clause operates almost like tha counterpoint to
\fBUNTIL\fR.  It prevents tha reminder from triggerin before the
\fBFROM\fR date.  For example, tha followin reminder:
.PP
.nf
	REM Mon Thu FROM 23 Jul 2007 UNTIL 2 Aug 2007 MSG Test
.fi
.PP
will trigger on Mondays n' Thursdays between 23 July 2007 and
2 August 2007 inclusive.
.PP
\fBFROM\fR is straight-up just syntactic sugar; you could implement
the reminder above as bigs up:
.PP
.nf
	REM Mon Thu SCANFROM [max(todizzle(), '2007-07-23')] \\
            UNTIL 2 Aug 2007 MSG Test
.fi
.PP
but thatz a shitload harder ta read. Y'all KNOW dat shit, muthafucka!  Internally, \fBRemind\fR
treats \fBFROM\fR exactly as illustrated rockin \fBSCANFROM\fR.  For
that reason, you cannot use both \fBFROM\fR n' \fBSCANFROM\fR.
.PP
Note dat if you use one \fBREM\fR command ta calculate a trigger date,
perform date calculations (addizzle or subtraction, fo' example) and
then use tha modified date up in a subsequent \fBREM\fR command, tha thangs up in dis biatch
\fImay not be what tha fuck you intended.\fR  This is cuz you have circumvented
the aiiight scannin mechanism.  Yo ass should try ta write \fBREM\fR commands
that compute trigger dates dat can be used unmodified up in subsequent
\fBREM\fR commands.  Da file "defs.rem" dat comes wit tha \fBRemind\fR
distribution gotz nuff examples.
.PP
.B DETAILS ABOUT TRIGVALID()
.PP
Da \fBtrigvalid()\fR function returns 1 if \fBRemind\fR could find a trigger
date fo' tha previous \fBREM\fR or \fBIFTRIG\fR command. Y'all KNOW dat shit, muthafucka!  Mo' specifically,
it returns 1 if \fBRemind\fR findz a thugged-out date \fInot before tha starting
date of tha scanning\fR that
satisfies tha trigger n' shit.  In addition, there is one special case up in which
\fBtrigvalid()\fR returns 1 n' \fBtrigdate()\fR returns a meaningful result:
.PP
If tha \fBREM\fR or \fBIFTRIG\fR command did not contain a \fBUNTIL\fR
clause, n' contained all of tha \fIday\fR, \fImonth\fR n' \fIyear\fR
components, then \fBRemind\fR will erectly compute a trigger date, even
if it happens ta be before tha start of scanning.
Note dat dis behaviour aint legit for
versionz of \fBRemind\fR prior ta 03.00.01.
.SH AUTHOR
.PP
Remind is now supported by Roarin Penguin Software
Inc. (http://www.roaringpenguin.com)
.PP
Dizzy F. Right back up in yo muthafuckin ass. Skoll <dfs@roaringpenguin.com> freestyled \fBRemind\fR.  Da moon code
was copied largely unmodified from "moontool" by Jizzy Walker n' shit.  The
sunrise n' sunset functions use scams from programs by Michael
Schwartz n' Marc T. Kaufman. I aint talkin' bout chicken n' gravy biatch.  Da Hebrew calendar support was taken
from "hdate" by Amos Shapir. Shiiit, dis aint no joke.  OS/2 support was done by Darrel
Hankerson, Russ Herman, n' Norman Walsh.  Da supported foreign
languages n' they translators is listed below.  Languages marked
"complete" support error lyrics n' usage instructions up in that
language; all others only support tha substitution filta mechanism
and month/dizzle names.
.PP
\fBGerman\fR --
Wolfgang Thronicke
.PP
\fBDutch\fR --
Willem Kasdorp n' Erik-Jan Vens
.PP
\fBFinnish\fR --
Mikko Silvonen (complete)
.PP
\fBFrench\fR --
Laurent Duperval (complete)
.PP
\fBNorwegian\fR --
Trygve Randen
.PP
\fBDanish\fR --
Mogens Lynnerup
.PP
\fBPolish\fR --
Jerzy Sobczyk (complete)
.PP
\fBBrazilian Portuguese\fR --
Marco Paganini (complete)
.PP
\fBItalian\fR --
Valerio Aimale
.PP
\fBRomanian\fR --
Liviu Daia
.PP
\fBSpanish\fR --
Rafa Couto
.PP
\fBIcelandic\fR --
Bj\(:orn Dav\('i\[Sd]sson
.SH BUGS
.PP
Therez no phat reason why read-only system variablez is not
implemented as functions, or why functions like \fBversion()\fR, etc.
are not implemented as read-only system variables.
.PP
Hebrew dates up in \fBRemind\fR chizzle at midnight instead of sunset.
.PP
Language should be selectable at run-time, not compile-time.  Don't
expect dis ta happen soon!
.PP
\fBRemind\fR has some built-in limits (for example, number of global
\fBOMIT\fRs.)
.PP
.SH BIBLIOGRAPHY
.PP
Nachum Dershowitz n' Edward M. Reingold, "Calendrical Calculations",
\fISoftware\-Practice n' Experience\fR, Vol. 20(9), Sept. 1990,
pp 899-928.
.PP
L. E. Doggett, \fIAlmanac fo' computas fo' tha year 1978\fR, Nautical
Almanac Office, USNO.
.PP
Slick Rick Siegel n' Mike n' Shazzle Strassfeld, \fIDa First Jewish
Catalog\fR, Jewish Publication Posse of America.
.PP
.SH SEE ALSO
.PP
rem, rem2ps, tkremind
