.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFMPEG 1"
.TH FFMPEG 1 "2015-01-03" " " " "
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffmpeg \- ffmpeg vizzle converter
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
ffmpeg [\fIglobal_options\fR] {[\fIinput_file_options\fR] \-i \fIinput_file\fR} ... {[\fIoutput_file_options\fR] \fIoutput_file\fR} ...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBffmpeg\fR be a straight-up fast vizzle n' audio converta dat can also grab from
a live audio/video source. Well shiiiit, it can also convert between arbitrary sample
rates n' resize vizzle on tha fly wit a high qualitizzle polyphase filter.
.PP
\&\fBffmpeg\fR readz from a arbitrary number of input \*(L"files\*(R" (which can be regular
files, pipes, network streams, grabbin devices, etc.), specified by the
\&\f(CW\*(C`\-i\*(C'\fR option, n' writes ta a arbitrary number of output \*(L"files\*(R", which are
specified by a plain output filename fo' realz. Anythang found on tha command line which
cannot be interpreted as a option is considered ta be a output filename.
.PP
Each input or output file can, up in principle, contain any number of streams of
different types (video/audio/subtitle/attachment/data). Da allowed number and/or
typez of streams may be limited by tha container format. Right back up in yo muthafuckin ass. Selectin which
streams from which inputs will go tha fuck into which output is either done automatically
or wit tha \f(CW\*(C`\-map\*(C'\fR option (see tha Stream selection chapter).
.PP
To refer ta input filez up in options, you must use they indices (0\-based). E.g.
the first input file is \f(CW0\fR, tha second is \f(CW1\fR, etc. Right back up in yo muthafuckin ass. Similarly, streams
within a gangbangin' file is referred ta by they indices. E.g. \f(CW\*(C`2:3\*(C'\fR refers ta the
fourth stream up in tha third input file fo' realz. Also peep tha Stream specifiers chapter.
.PP
As a general rule, options is applied ta tha next specified
file. Therefore, order is blingin, n' you can have tha same
option on tha command line multiple times. Each occurrence is
then applied ta tha next input or output file.
Exceptions from dis rule is tha global options (e.g. verbositizzle level),
which should be specified first.
.PP
Do not mix input n' output filez \*(-- first specify all input files, then all
output filez fo' realz. Also do not mix options which belong ta different filez fo' realz. All
options apply \s-1ONLY\s0 ta tha next input or output file n' is reset between files.
.IP "\(bu" 4
To set tha vizzle bitrate of tha output file ta 64 kbit/s:
.Sp
.Vb 1
\&        ffmpeg \-i input.avi \-b:v 64k \-bufsize 64k output.avi
.Ve
.IP "\(bu" 4
To force tha frame rate of tha output file ta 24 fps:
.Sp
.Vb 1
\&        ffmpeg \-i input.avi \-r 24 output.avi
.Ve
.IP "\(bu" 4
To force tha frame rate of tha input file (valid fo' raw formats only)
to 1 fps n' tha frame rate of tha output file ta 24 fps:
.Sp
.Vb 1
\&        ffmpeg \-r 1 \-i input.m2v \-r 24 output.avi
.Ve
.PP
Da format option may be needed fo' raw input files.
.SH "DETAILED DESCRIPTION"
.IX Header "DETAILED DESCRIPTION"
Da transcodin process up in \fBffmpeg\fR fo' each output can be busted lyrics bout by
the followin diagram:
.PP
.Vb 5
\&         _\|_\|_\|_\|_\|_\|_              _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_               _\|_\|_\|_\|_\|_\|_\|_\|_              _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_            _\|_\|_\|_\|_\|_\|_\|_
\&        |       |            |              |             |         |            |              |          |        |
\&        | input |  demuxer   | encoded data |   decoder   | decoded |  encoder   | encoded data |  muxer   | output |
\&        | file  | \-\-\-\-\-\-\-\-\-> | packets      |  \-\-\-\-\-\-\-\-\-> | frames  | \-\-\-\-\-\-\-\-\-> | packets      | \-\-\-\-\-\-\-> | file   |
\&        |_\|_\|_\|_\|_\|_\|_|            |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|             |_\|_\|_\|_\|_\|_\|_\|_\|_|            |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|          |_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.PP
\&\fBffmpeg\fR calls tha libavformat library (containin demuxers) ta read
input filez n' git packets containin encoded data from em. When there are
multiple input files, \fBffmpeg\fR tries ta keep dem synchronized by
trackin lowest timestamp on any actizzle input stream.
.PP
Encoded packets is then passed ta tha decoder (unless streamcopy is selected
for tha stream, peep further fo' a thugged-out description). Da decoder produces
uncompressed frames (raw vizzle/PCM audio/...) which can be processed further by
filterin (see next section) fo' realz. Afta filtering, tha frames is passed ta the
encoder, which encodes dem n' outputs encoded packets, n' you can put dat on yo' toast. Finally dem are
passed ta tha muxer, which writes tha encoded packets ta tha output file.
.SS "Filtering"
.IX Subsection "Filtering"
Before encoding, \fBffmpeg\fR can process raw audio n' vizzle frames using
filtas from tha libavfilta library. Right back up in yo muthafuckin ass. Several chained filtas form a gangbangin' filter
graph. \fBffmpeg\fR distinguishes between two typez of filtergraphs:
simple n' complex.
.PP
\fISimple filtergraphs\fR
.IX Subsection "Simple filtergraphs"
.PP
Simple filtergraphs is dem dat have exactly one input n' output, both of
the same type. In tha above diagram they can be represented by simply inserting
an additionizzle step between decodin n' encoding:
.PP
.Vb 5
\&         _\|_\|_\|_\|_\|_\|_\|_\|_                        _\|_\|_\|_\|_\|_\|_\|_\|_\|_              _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&        |         |                      |          |            |              |
\&        | decoded |  simple filtergraph  | filtered |  encoder   | encoded data |
\&        | frames  | \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-> | frames   | \-\-\-\-\-\-\-\-\-> | packets      |
\&        |_\|_\|_\|_\|_\|_\|_\|_\|_|                      |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|            |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.PP
Simple filtergraphs is configured wit tha per-stream \fB\-filter\fR option
(with \fB\-vf\fR n' \fB\-af\fR aliases fo' vizzle n' audio respectively).
A simple filtergraph fo' vizzle can look fo' example like this:
.PP
.Vb 4
\&         _\|_\|_\|_\|_\|_\|_        _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_        _\|_\|_\|_\|_\|_\|_        _\|_\|_\|_\|_        _\|_\|_\|_\|_\|_\|_\|_
\&        |       |      |             |      |       |      |     |      |        |
\&        | input | \-\-\-> | deinterlace | \-\-\-> | scale | \-\-\-> | fps | \-\-\-> | output |
\&        |_\|_\|_\|_\|_\|_\|_|      |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|      |_\|_\|_\|_\|_\|_\|_|      |_\|_\|_\|_\|_|      |_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.PP
Note dat some filtas chizzle frame propertizzles but not frame contents, n' you can put dat on yo' toast. E.g. the
\&\f(CW\*(C`fps\*(C'\fR filta up in tha example above chizzlez number of frames yo, but do not
touch tha frame contents fo' realz. Another example is tha \f(CW\*(C`setpts\*(C'\fR filter, which
only sets timestamps n' otherwise passes tha frames unchanged.
.PP
\fIComplex filtergraphs\fR
.IX Subsection "Complex filtergraphs"
.PP
Complex filtergraphs is dem which cannot be busted lyrics bout as simply a linear
processin chain applied ta one stream. This is tha case, fo' example, when tha graph has
more than one input and/or output, or when output stream type is different from
input. They can be represented wit tha followin diagram:
.PP
.Vb 10
\&         _\|_\|_\|_\|_\|_\|_\|_\|_
\&        |         |
\&        | input 0 |\e                    _\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&        |_\|_\|_\|_\|_\|_\|_\|_\|_| \e                  |          |
\&                     \e   _\|_\|_\|_\|_\|_\|_\|_\|_    /| output 0 |
\&                      \e |         |  / |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
\&         _\|_\|_\|_\|_\|_\|_\|_\|_     \e| complex | /
\&        |         |     |         |/
\&        | input 1 |\-\-\-\->| filta  |\e
\&        |_\|_\|_\|_\|_\|_\|_\|_\|_|     |         | \e   _\|_\|_\|_\|_\|_\|_\|_\|_\|_
\&                       /| graph   |  \e |          |
\&                      / |         |   \e| output 1 |
\&         _\|_\|_\|_\|_\|_\|_\|_\|_   /  |_\|_\|_\|_\|_\|_\|_\|_\|_|    |_\|_\|_\|_\|_\|_\|_\|_\|_\|_|
\&        |         | /
\&        | input 2 |/
\&        |_\|_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.PP
Complex filtergraphs is configured wit tha \fB\-filter_complex\fR option.
Note dat dis option is global, since a cold-ass lil complex filtergraph, by its nature,
cannot be unambiguously associated wit a single stream or file.
.PP
Da \fB\-lavfi\fR option is equivalent ta \fB\-filter_complex\fR.
.PP
A trivial example of a cold-ass lil complex filtergraph is tha \f(CW\*(C`overlay\*(C'\fR filter, which
has two vizzle inputs n' one vizzle output, containin one vizzle overlaid on top
of tha other n' shit. Its audio counterpart is tha \f(CW\*(C`amix\*(C'\fR filter.
.SS "Stream copy"
.IX Subsection "Stream copy"
Stream copy be a mode selected by supplyin tha \f(CW\*(C`copy\*(C'\fR parameta ta the
\&\fB\-codec\fR option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it make \fBffmpeg\fR omit tha decodin n' encoding
step fo' tha specified stream, so it do only demuxin n' muxing. Well shiiiit, it is useful
for changin tha container format or modifyin container-level metadata. The
diagram above will, up in dis case, simplify ta this:
.PP
.Vb 5
\&         _\|_\|_\|_\|_\|_\|_              _\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_            _\|_\|_\|_\|_\|_\|_\|_
\&        |       |            |              |          |        |
\&        | input |  demuxer   | encoded data |  muxer   | output |
\&        | file  | \-\-\-\-\-\-\-\-\-> | packets      | \-\-\-\-\-\-\-> | file   |
\&        |_\|_\|_\|_\|_\|_\|_|            |_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_\|_|          |_\|_\|_\|_\|_\|_\|_\|_|
.Ve
.PP
Since there is no decodin or encoding, it is straight-up fast n' there is no quality
loss. But fuck dat shiznit yo, tha word on tha street is dat it might not work up in some cases cuz of nuff factors fo' realz. Applying
filtas is obviously also impossible, since filtas work on uncompressed data.
.SH "STREAM SELECTION"
.IX Header "STREAM SELECTION"
By default, \fBffmpeg\fR includes only one stream of each type (video, audio, subtitle)
present up in tha input filez n' addz dem ta each output file.  It picks the
\&\*(L"best\*(R" of each based upon tha followin criteria: fo' vizzle, it is tha stream
with tha highest resolution, fo' audio, it is tha stream wit da most thugged-out channels, for
subtitles, it is tha straight-up original gangsta subtitle stream. In tha case where nuff muthafuckin streams of
the same type rate equally, tha stream wit tha lowest index is chosen.
.PP
Yo ass can disable a shitload of dem defaults by rockin tha \f(CW\*(C`\-vn/\-an/\-sn\*(C'\fR options. For
full manual control, use tha \f(CW\*(C`\-map\*(C'\fR option, which disablez tha defaults just
busted lyrics about.
.SH "OPTIONS"
.IX Header "OPTIONS"
All tha numerical options, if not specified otherwise, accept a string
representin a number as input, which may be followed by one of tha \s-1SI\s0
unit prefixes, fo' example: 'K', 'M', or 'G'.
.PP
If 'i' be appended ta tha \s-1SI\s0 unit prefix, tha complete prefix will be
interpreted as a unit prefix fo' binary multiplies, which is based on
powerz of 1024 instead of powerz of 1000 fo' realz. Appendin 'B' ta tha \s-1SI\s0 unit
prefix multiplies tha value by 8. This allows using, fo' example:
\&'\s-1KB\s0', 'MiB', 'G' n' 'B' as number suffixes.
.PP
Options which do not take arguments is boolean options, n' set the
correspondin value ta true. They can be set ta false by prefixing
the option name wit \*(L"no\*(R". For example rockin \*(L"\-nofoo\*(R"
will set tha boolean option wit name \*(L"foo\*(R" ta false.
.SS "Stream specifiers"
.IX Subsection "Stream specifiers"
Some options is applied per-stream, e.g. bitrate or codec. Right back up in yo muthafuckin ass. Stream specifiers
are used ta precisely specify which stream(s) a given option belongs to.
.PP
A stream specifier be a strang generally appended ta tha option name and
separated from it by a cold-ass lil colon. I aint talkin' bout chicken n' gravy biatch. E.g. \f(CW\*(C`\-codec:a:1 ac3\*(C'\fR gotz nuff the
\&\f(CW\*(C`a:1\*(C'\fR stream specifier, which matches tha second audio stream. Therefore, it
would select tha ac3 codec fo' tha second audio stream.
.PP
A stream specifier can match nuff muthafuckin streams, so dat tha option be applied ta all
of em. E.g. tha stream specifier up in \f(CW\*(C`\-b:a 128k\*(C'\fR matches all audio
streams.
.PP
An empty stream specifier matches all streams. For example, \f(CW\*(C`\-codec copy\*(C'\fR
or \f(CW\*(C`\-codec: copy\*(C'\fR would copy all tha streams without reencoding.
.PP
Possible formz of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches tha stream wit dis index. E.g. \f(CW\*(C`\-threads:1 4\*(C'\fR would set the
thread count fo' tha second stream ta 4.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of following: 'v' fo' vizzle, 'a' fo' audio, 's' fo' subtitle,
\&'d' fo' data, n' 't' fo' attachments, n' you can put dat on yo' toast. If \fIstream_index\fR is given, then it matches
stream number \fIstream_index\fR of dis type. Otherwise, it matches all
streamz of dis type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then it matches tha stream wit number \fIstream_index\fR
in tha program wit tha id \fIprogram_id\fR. Otherwise, it matches all streams up in the
program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches tha stream by a gangbangin' format-specific \s-1ID.\s0
.SS "Generic options"
.IX Subsection "Generic options"
These options is shared amongst tha ff* tools.
.IP "\fB\-L\fR" 4
.IX Item "-L"
Show license.
.IP "\fB\-h, \-?, \-help, \-\-help [\fR\fIarg\fR\fB]\fR" 4
.IX Item "-h, -?, -help, --help [arg]"
Show help fo' realz. An optionizzle parameta may be specified ta print help on some specific
item. If no argument is specified, only basic (non advanced) tool
options is shown.
.Sp
Possible jointz of \fIarg\fR are:
.RS 4
.IP "\fBlong\fR" 4
.IX Item "long"
Print advanced tool options up in addizzle ta tha basic tool options.
.IP "\fBfull\fR" 4
.IX Item "full"
Print complete list of options, includin shared n' private options
for encoders, decoders, demuxers, muxers, filters, etc.
.IP "\fBdecoder=\fR\fIdecoder_name\fR" 4
.IX Item "decoder=decoder_name"
Print detailed shiznit bout tha decoder named \fIdecoder_name\fR. Use the
\&\fB\-decoders\fR option ta git a list of all decoders.
.IP "\fBencoder=\fR\fIencoder_name\fR" 4
.IX Item "encoder=encoder_name"
Print detailed shiznit bout tha encoder named \fIencoder_name\fR. Use the
\&\fB\-encoders\fR option ta git a list of all encoders.
.IP "\fBdemuxer=\fR\fIdemuxer_name\fR" 4
.IX Item "demuxer=demuxer_name"
Print detailed shiznit bout tha demuxer named \fIdemuxer_name\fR. Use the
\&\fB\-formats\fR option ta git a list of all demuxers n' muxers.
.IP "\fBmuxer=\fR\fImuxer_name\fR" 4
.IX Item "muxer=muxer_name"
Print detailed shiznit bout tha muxer named \fImuxer_name\fR. Use the
\&\fB\-formats\fR option ta git a list of all muxers n' demuxers.
.IP "\fBfilter=\fR\fIfilter_name\fR" 4
.IX Item "filter=filter_name"
Print detailed shiznit bout tha filta name \fIfilter_name\fR. Use the
\&\fB\-filters\fR option ta git a list of all filters.
.RE
.RS 4
.RE
.IP "\fB\-version\fR" 4
.IX Item "-version"
Show version.
.IP "\fB\-formats\fR" 4
.IX Item "-formats"
Show available formats.
.IP "\fB\-codecs\fR" 4
.IX Item "-codecs"
Show all codecs known ta libavcodec.
.Sp
Note dat tha term 'codec' is used all up in dis documentation as a gangbangin' finger-lickin' dirty-ass shortcut
for what tha fuck is mo' erectly called a media bitstream format.
.IP "\fB\-decoders\fR" 4
.IX Item "-decoders"
Show available decoders.
.IP "\fB\-encoders\fR" 4
.IX Item "-encoders"
Show all available encoders.
.IP "\fB\-bsfs\fR" 4
.IX Item "-bsfs"
Show available bitstream filters.
.IP "\fB\-protocols\fR" 4
.IX Item "-protocols"
Show available protocols.
.IP "\fB\-filters\fR" 4
.IX Item "-filters"
Show available libavfilta filters.
.IP "\fB\-pix_fmts\fR" 4
.IX Item "-pix_fmts"
Show available pixel formats.
.IP "\fB\-sample_fmts\fR" 4
.IX Item "-sample_fmts"
Show available sample formats.
.IP "\fB\-layouts\fR" 4
.IX Item "-layouts"
Show channel names n' standard channel layouts.
.IP "\fB\-colors\fR" 4
.IX Item "-colors"
Show recognized color names.
.IP "\fB\-loglevel [repeat+]\fR\fIloglevel\fR \fB| \-v [repeat+]\fR\fIloglevel\fR" 4
.IX Item "-loglevel [repeat+]loglevel | -v [repeat+]loglevel"
Set tha loggin level used by tha library.
Addin \*(L"repeat+\*(R" indicates dat repeated log output should not be compressed
to tha straight-up original gangsta line n' tha \*(L"Last message repeated n times\*(R" line will be
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \*(L"repeat\*(R" can also be used ridin' solo.
If \*(L"repeat\*(R" is used alone, n' wit no prior loglevel set, tha default
loglevel is ghon be used. Y'all KNOW dat shit, muthafucka! If multiple loglevel parametas is given, using
\&'repeat' aint gonna chizzle tha loglevel.
\&\fIloglevel\fR be a number or a strang containin one of tha followin joints:
.RS 4
.IP "\fBquiet\fR" 4
.IX Item "quiet"
Show not a god damn thang at all; be silent.
.IP "\fBpanic\fR" 4
.IX Item "panic"
Only show fatal errors which could lead tha process ta crash, such as
and assert failure. This aint currently used fo' anything.
.IP "\fBfatal\fR" 4
.IX Item "fatal"
Only show fatal errors. These is errors afta which tha process straight-up
cannot continue after.
.IP "\fBerror\fR" 4
.IX Item "error"
Show all errors, includin ones which can be recovered from.
.IP "\fBwarning\fR" 4
.IX Item "warning"
Show all warnings n' errors fo' realz. Any message related ta possibly
incorrect or unexpected events is ghon be shown.
.IP "\fBinfo\fR" 4
.IX Item "info"
Show informatizzle lyrics durin processing. This is up in addizzle to
warnings n' errors. This is tha default value.
.IP "\fBverbose\fR" 4
.IX Item "verbose"
Same as \f(CW\*(C`info\*(C'\fR, except mo' verbose.
.IP "\fBdebug\fR" 4
.IX Item "debug"
Show every last muthafuckin thang, includin debuggin shiznit.
.RE
.RS 4
.Sp
By default tha program logs ta stderr, if colorin is supported by the
terminal, flavas is used ta mark errors n' warnings. Log coloring
can be disabled settin tha environment variable
\&\fB\s-1AV_LOG_FORCE_NOCOLOR\s0\fR or \fB\s-1NO_COLOR\s0\fR, or can be forced setting
the environment variable \fB\s-1AV_LOG_FORCE_COLOR\s0\fR.
Da use of tha environment variable \fB\s-1NO_COLOR\s0\fR is deprecated and
will be dropped up in a gangbangin' followin FFmpeg version.
.RE
.IP "\fB\-report\fR" 4
.IX Item "-report"
Dump full command line n' console output ta a gangbangin' file named
\&\f(CW\*(C`\f(CIprogram\f(CW\-\f(CIYYYYMMDD\f(CW\-\f(CIHHMMSS\f(CW.log\*(C'\fR up in tha current
directory.
This file can be useful fo' bug reports.
It also implies \f(CW\*(C`\-loglevel verbose\*(C'\fR.
.Sp
Settin tha environment variable \f(CW\*(C`FFREPORT\*(C'\fR ta any value has the
same effect. If tha value be a ':'\-separated key=value sequence, these
options will affect tha report; options joints must be escaped if they
contain special charactas or tha options delimita ':' (see the
``Quotin n' escaping'' section up in tha ffmpeg-utils manual). The
followin option is recognized:
.RS 4
.IP "\fBfile\fR" 4
.IX Item "file"
set tha file name ta use fo' tha report; \f(CW%p\fR is expanded ta tha name
of tha program, \f(CW%t\fR is expanded ta a timestamp, \f(CW\*(C`%%\*(C'\fR is expanded
to a plain \f(CW\*(C`%\*(C'\fR
.RE
.RS 4
.Sp
Errors up in parsin tha environment variable is not fatal, n' will not
appear up in tha report.
.RE
.IP "\fB\-cpuflags flags (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-cpuflags flags (global)"
Allows settin n' clearin cpu flags. This option is intended
for testing. Do not use it unless you know what tha fuck you bustin.
.Sp
.Vb 3
\&        ffmpeg \-cpuflags \-sse+mmx ...
\&        ffmpeg \-cpuflags mmx ...
\&        ffmpeg \-cpuflags 0 ...
.Ve
.Sp
Possible flags fo' dis option are:
.RS 4
.IP "\fBx86\fR" 4
.IX Item "x86"
.RS 4
.PD 0
.IP "\fBmmx\fR" 4
.IX Item "mmx"
.IP "\fBmmxext\fR" 4
.IX Item "mmxext"
.IP "\fBsse\fR" 4
.IX Item "sse"
.IP "\fBsse2\fR" 4
.IX Item "sse2"
.IP "\fBsse2slow\fR" 4
.IX Item "sse2slow"
.IP "\fBsse3\fR" 4
.IX Item "sse3"
.IP "\fBsse3slow\fR" 4
.IX Item "sse3slow"
.IP "\fBssse3\fR" 4
.IX Item "ssse3"
.IP "\fBatom\fR" 4
.IX Item "atom"
.IP "\fBsse4.1\fR" 4
.IX Item "sse4.1"
.IP "\fBsse4.2\fR" 4
.IX Item "sse4.2"
.IP "\fBavx\fR" 4
.IX Item "avx"
.IP "\fBxop\fR" 4
.IX Item "xop"
.IP "\fBfma4\fR" 4
.IX Item "fma4"
.IP "\fB3dnow\fR" 4
.IX Item "3dnow"
.IP "\fB3dnowext\fR" 4
.IX Item "3dnowext"
.IP "\fBcmov\fR" 4
.IX Item "cmov"
.RE
.RS 4
.RE
.IP "\fB\s-1ARM\s0\fR" 4
.IX Item "ARM"
.RS 4
.IP "\fBarmv5te\fR" 4
.IX Item "armv5te"
.IP "\fBarmv6\fR" 4
.IX Item "armv6"
.IP "\fBarmv6t2\fR" 4
.IX Item "armv6t2"
.IP "\fBvfp\fR" 4
.IX Item "vfp"
.IP "\fBvfpv3\fR" 4
.IX Item "vfpv3"
.IP "\fBneon\fR" 4
.IX Item "neon"
.RE
.RS 4
.RE
.IP "\fBPowerPC\fR" 4
.IX Item "PowerPC"
.RS 4
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.RE
.RS 4
.RE
.IP "\fBSpecific Processors\fR" 4
.IX Item "Specific Processors"
.RS 4
.IP "\fBpentium2\fR" 4
.IX Item "pentium2"
.IP "\fBpentium3\fR" 4
.IX Item "pentium3"
.IP "\fBpentium4\fR" 4
.IX Item "pentium4"
.IP "\fBk6\fR" 4
.IX Item "k6"
.IP "\fBk62\fR" 4
.IX Item "k62"
.IP "\fBathlon\fR" 4
.IX Item "athlon"
.IP "\fBathlonxp\fR" 4
.IX Item "athlonxp"
.IP "\fBk8\fR" 4
.IX Item "k8"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\fB\-opencl_options options (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-opencl_options options (global)"
.PD
Set OpenCL environment options. This option is only available when
FFmpeg has been compiled wit \f(CW\*(C`\-\-enable\-opencl\*(C'\fR.
.Sp
\&\fIoptions\fR must be a list of \fIkey\fR=\fIvalue\fR option pairs
separated by ':'. Right back up in yo muthafuckin ass. See tha ``OpenCL Options'' section up in the
ffmpeg-utils manual fo' tha list of supported options.
.SS "AVOptions"
.IX Subsection "AVOptions"
These options is provided directly by tha libavformat, libavdevice and
libavcodec libraries. Put ya muthafuckin choppers up if ya feel dis! To peep tha list of available AVOptions, use the
\&\fB\-help\fR option. I aint talkin' bout chicken n' gravy biatch. They is separated tha fuck into two categories:
.IP "\fBgeneric\fR" 4
.IX Item "generic"
These options can be set fo' any container, codec or device. Generic options
are listed under AVFormatContext options fo' containers/devices n' under
AVCodecContext options fo' codecs.
.IP "\fBprivate\fR" 4
.IX Item "private"
These options is specific ta tha given container, thang or codec. Private
options is listed under they correspondin containers/devices/codecs.
.PP
For example ta write a ID3v2.3 header instead of a thugged-out default ID3v2.4 to
an \s-1MP3\s0 file, use tha \fBid3v2_version\fR private option of tha \s-1MP3\s0
muxer:
.PP
.Vb 1
\&        ffmpeg \-i input.flac \-id3v2_version 3 out.mp3
.Ve
.PP
All codec AVOptions is per-stream, n' thus a stream specifier
should be attached ta em.
.PP
Note: tha \fB\-nooption\fR syntax cannot be used fo' boolean
AVOptions, use \fB\-option 0\fR/\fB\-option 1\fR.
.PP
Note: tha oldschool undocumented way of specifyin per-stream AVOptions by
prependin v/a/s ta tha options name is now obsolete n' will be
removed soon.
.SS "Main options"
.IX Subsection "Main options"
.IP "\fB\-f\fR \fIfmt\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-f fmt (input/output)"
Force input or output file format. Da format is normally auto detected fo' input
filez n' guessed from tha file extension fo' output files, so dis option is not
needed up in most cases.
.IP "\fB\-i\fR \fIfilename\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-i filename (input)"
input file name
.IP "\fB\-y (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-y (global)"
Overwrite output filez without asking.
.IP "\fB\-n (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-n (global)"
Do not overwrite output files, n' exit immediately if a specified
output file already exists.
.IP "\fB\-c[:\fR\fIstream_specifier\fR\fB]\fR \fIcodec\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-c[:stream_specifier] codec (input/output,per-stream)"
.PD 0
.IP "\fB\-codec[:\fR\fIstream_specifier\fR\fB]\fR \fIcodec\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-codec[:stream_specifier] codec (input/output,per-stream)"
.PD
Select a encoder (when used before a output file) or a thugged-out decoder (when used
before a input file) fo' one or mo' streams. \fIcodec\fR is tha name of a
decoder/encoder or a special value \f(CW\*(C`copy\*(C'\fR (output only) ta indicate that
the stream aint ta be re-encoded.
.Sp
For example
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0 \-c:v libx264 \-c:a copy OUTPUT
.Ve
.Sp
encodes all vizzle streams wit libx264 n' copies all audio streams.
.Sp
For each stream, tha last matchin \f(CW\*(C`c\*(C'\fR option be applied, so
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0 \-c copy \-c:v:1 libx264 \-c:a:137 libvorbis OUTPUT
.Ve
.Sp
will copy all tha streams except tha second vizzle, which is ghon be encoded with
libx264, n' tha 138th audio, which is ghon be encoded wit libvorbis.
.IP "\fB\-t\fR \fIduration\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-t duration (output)"
Quit freestylin tha output afta its duration reaches \fIduration\fR.
\&\fIduration\fR may be a number up in seconds, or up in \f(CW\*(C`hh:mm:ss[.xxx]\*(C'\fR form.
.Sp
\&\-to n' \-t is mutually exclusive n' \-t has priority.
.IP "\fB\-to\fR \fIposition\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-to posizzle (output)"
Quit freestylin tha output at \fIposition\fR.
\&\fIposition\fR may be a number up in seconds, or up in \f(CW\*(C`hh:mm:ss[.xxx]\*(C'\fR form.
.Sp
\&\-to n' \-t is mutually exclusive n' \-t has priority.
.IP "\fB\-fs\fR \fIlimit_size\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-fs limit_size (output)"
Set tha file size limit, expressed up in bytes.
.IP "\fB\-ss\fR \fIposition\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-ss posizzle (input/output)"
When used as a input option (before \f(CW\*(C`\-i\*(C'\fR), seeks up in dis input file to
\&\fIposition\fR. Note tha up in most formats it aint possible ta seek exactly, so
\&\fBffmpeg\fR will seek ta tha closest seek point before \fIposition\fR.
When transcodin n' \fB\-accurate_seek\fR is enabled (the default), this
extra segment between tha seek point n' \fIposition\fR is ghon be decoded and
discarded. Y'all KNOW dat shit, muthafucka! When bustin stream copy or when \fB\-noaccurate_seek\fR is used, it
will be preserved.
.Sp
When used as a output option (before a output filename), decodes but discards
input until tha timestamps reach \fIposition\fR.
.Sp
\&\fIposition\fR may be either up in secondz or up in \f(CW\*(C`hh:mm:ss[.xxx]\*(C'\fR form.
.IP "\fB\-itsoffset\fR \fIoffset\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-itsoffset offset (input)"
Set tha input time offset up in seconds.
\&\f(CW\*(C`[\-]hh:mm:ss[.xxx]\*(C'\fR syntax be also supported.
Da offset be added ta tha timestampz of tha input files.
Specifyin a positizzle offset means dat tha corresponding
streams is delayed by \fIoffset\fR seconds.
.IP "\fB\-timestamp\fR \fItime\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-timestamp time (output)"
Set tha recordin timestamp up in tha container.
Da syntax fo' \fItime\fR is:
.Sp
.Vb 1
\&        now|([(YYYY\-MM\-DD|YYYYMMDD)[T|t| ]]((HH:MM:SS[.m...])|(HHMMSS[.m...]))[Z|z])
.Ve
.Sp
If tha value is \*(L"now\*(R" it takes tha current time.
Time is local time unless 'Z' or 'z' be appended, up in which case it is
interpreted as \s-1UTC.\s0
If tha year-month-dizzle part aint specified it takes tha current
year-month-day.
.IP "\fB\-metadata[:metadata_specifier]\fR \fIkey\fR\fB=\fR\fIvalue\fR \fB(\fR\fIoutput,per\-metadata\fR\fB)\fR" 4
.IX Item "-metadata[:metadata_specifier] key=value (output,per-metadata)"
Set a metadata key/value pair.
.Sp
An optionizzle \fImetadata_specifier\fR may be given ta set metadata
on streams or chapters. Right back up in yo muthafuckin ass. See \f(CW\*(C`\-map_metadata\*(C'\fR documentation for
details.
.Sp
This option overrides metadata set wit \f(CW\*(C`\-map_metadata\*(C'\fR. Well shiiiit, it is
also possible ta delete metadata by rockin a empty value.
.Sp
For example, fo' settin tha title up in tha output file:
.Sp
.Vb 1
\&        ffmpeg \-i in.avi \-metadata title="my title" out.flv
.Ve
.Sp
To set tha language of tha straight-up original gangsta audio stream:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-metadata:s:a:1 language=eng OUTPUT
.Ve
.IP "\fB\-target\fR \fItype\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-target type (output)"
Specify target file type (\f(CW\*(C`vcd\*(C'\fR, \f(CW\*(C`svcd\*(C'\fR, \f(CW\*(C`dvd\*(C'\fR, \f(CW\*(C`dv\*(C'\fR,
\&\f(CW\*(C`dv50\*(C'\fR). \fItype\fR may be prefixed wit \f(CW\*(C`pal\-\*(C'\fR, \f(CW\*(C`ntsc\-\*(C'\fR or
\&\f(CW\*(C`film\-\*(C'\fR ta use tha correspondin standard. Y'all KNOW dat shit, muthafucka! All tha format options
(bitrate, codecs, buffer sizes) is then set automatically. Yo ass can just type:
.Sp
.Vb 1
\&        ffmpeg \-i myfile.avi \-target vcd /tmp/vcd.mpg
.Ve
.Sp
Nevertheless you can specify additionizzle options as long as you know
they do not conflict wit tha standard, as in:
.Sp
.Vb 1
\&        ffmpeg \-i myfile.avi \-target vcd \-bf 2 /tmp/vcd.mpg
.Ve
.IP "\fB\-dframes\fR \fInumber\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-dframes number (output)"
Set tha number of data frames ta record. Y'all KNOW dat shit, muthafucka! This be a alias fo' \f(CW\*(C`\-frames:d\*(C'\fR.
.IP "\fB\-frames[:\fR\fIstream_specifier\fR\fB]\fR \fIframecount\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-frames[:stream_specifier] framecount (output,per-stream)"
Quit freestylin ta tha stream afta \fIframecount\fR frames.
.IP "\fB\-q[:\fR\fIstream_specifier\fR\fB]\fR \fIq\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-q[:stream_specifier] q (output,per-stream)"
.PD 0
.IP "\fB\-qscale[:\fR\fIstream_specifier\fR\fB]\fR \fIq\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-qscale[:stream_specifier] q (output,per-stream)"
.PD
Use fixed qualitizzle scale (\s-1VBR\s0). Da meanin of \fIq\fR is
codec-dependent.
.IP "\fB\-filter[:\fR\fIstream_specifier\fR\fB]\fR \fIfiltergraph\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-filter[:stream_specifier] filtergraph (output,per-stream)"
Smoke tha filtergraph specified by \fIfiltergraph\fR n' use it to
filta tha stream.
.Sp
\&\fIfiltergraph\fR be a thugged-out description of tha filtergraph ta apply to
the stream, n' must gotz a single input n' a single output of the
same type of tha stream. In tha filtergraph, tha input be associated
to tha label \f(CW\*(C`in\*(C'\fR, n' tha output ta tha label \f(CW\*(C`out\*(C'\fR. Right back up in yo muthafuckin ass. See
the ffmpeg-filtas manual fo' mo' shiznit bout tha filtergraph
syntax.
.Sp
See tha \-filter_complex option if you
wanna create filtergraphs wit multiple inputs and/or outputs.
.IP "\fB\-filter_script[:\fR\fIstream_specifier\fR\fB]\fR \fIfilename\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-filter_script[:stream_specifier] filename (output,per-stream)"
This option is similar ta \fB\-filter\fR, tha only difference is dat its
argument is tha name of tha file from which a gangbangin' filtergraph description is ta be
read.
.IP "\fB\-pre[:\fR\fIstream_specifier\fR\fB]\fR \fIpreset_name\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-pre[:stream_specifier] preset_name (output,per-stream)"
Specify tha preset fo' matchin stream(s).
.IP "\fB\-stats (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-stats (global)"
Print encodin progress/statistics. Well shiiiit, it is on by default, ta explicitly
disable it you need ta specify \f(CW\*(C`\-nostats\*(C'\fR.
.IP "\fB\-progress\fR \fIurl\fR \fB(\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-progress url (global)"
Send program-friendly progress shiznit ta \fIurl\fR.
.Sp
Progress shiznit is freestyled approximately every last muthafuckin second n' all up in tha end of
the encodin process. Well shiiiit, it is made of "\fIkey\fR=\fIvalue\fR" lines. \fIkey\fR
consistz of only alphanumeric characters. Da last key of a sequence of
progress shiznit be always \*(L"progress\*(R".
.IP "\fB\-stdin\fR" 4
.IX Item "-stdin"
Enable interaction on standard input. On by default unless standard input is
used as a input. To explicitly disable interaction you need ta specify
\&\f(CW\*(C`\-nostdin\*(C'\fR.
.Sp
Disablin interaction on standard input is useful, fo' example, if
ffmpeg is up in tha background process group. Roughly tha same result can
be  bigged up  wit \f(CW\*(C`ffmpeg ... < /dev/null\*(C'\fR but it requires a
shell.
.IP "\fB\-debug_ts (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-debug_ts (global)"
Print timestamp shiznit. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is off by default. This option is
mostly useful fo' testin n' debuggin purposes, n' tha output
format may chizzle from one version ta another, so it should not be
employed by portable scripts.
.Sp
See also tha option \f(CW\*(C`\-fdebug ts\*(C'\fR.
.IP "\fB\-attach\fR \fIfilename\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-attach filename (output)"
Add a attachment ta tha output file. This is supported by all dem formats
like Matroska fo' e.g. fonts used up in renderin subtitlez fo' realz. Attachments
are implemented as a specific type of stream, so dis option will add
a freshly smoked up stream ta tha file. Well shiiiit, it is then possible ta use per-stream options
on dis stream up in tha usual way fo' realz. Attachment streams pimped wit this
option is ghon be pimped afta all tha other streams (i.e. dem pimped
with \f(CW\*(C`\-map\*(C'\fR or automatic mappings).
.Sp
Note dat fo' Matroska you also gotta set tha mimetype metadata tag:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-attach DejaVuSans.ttf \-metadata:s:2 mimetype=application/x\-truetype\-font out.mkv
.Ve
.Sp
(assumin dat tha attachment stream is ghon be third up in tha output file).
.IP "\fB\-dump_attachment[:\fR\fIstream_specifier\fR\fB]\fR \fIfilename\fR \fB(\fR\fIinput,per\-stream\fR\fB)\fR" 4
.IX Item "-dump_attachment[:stream_specifier] filename (input,per-stream)"
Extract tha matchin attachment stream tha fuck into a gangbangin' file named \fIfilename\fR. If
\&\fIfilename\fR is empty, then tha value of tha \f(CW\*(C`filename\*(C'\fR metadata tag
will be used.
.Sp
E.g. ta extract tha straight-up original gangsta attachment ta a gangbangin' file named 'out.ttf':
.Sp
.Vb 1
\&        ffmpeg \-dump_attachment:t:0 out.ttf \-i INPUT
.Ve
.Sp
To extract all attachments ta filez determined by tha \f(CW\*(C`filename\*(C'\fR tag:
.Sp
.Vb 1
\&        ffmpeg \-dump_attachment:t "" \-i INPUT
.Ve
.Sp
Technical note \*(-- attachments is implemented as codec extradata, so this
option can straight-up be used ta extract extradata from any stream, not just
attachments.
.SS "Video Options"
.IX Subsection "Video Options"
.IP "\fB\-vframes\fR \fInumber\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-vframes number (output)"
Set tha number of vizzle frames ta record. Y'all KNOW dat shit, muthafucka! This be a alias fo' \f(CW\*(C`\-frames:v\*(C'\fR.
.IP "\fB\-r[:\fR\fIstream_specifier\fR\fB]\fR \fIfps\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-r[:stream_specifier] fps (input/output,per-stream)"
Set frame rate (Hz value, fraction or abbreviation).
.Sp
As a input option, ignore any timestamps stored up in tha file n' instead
generate timestamps assumin constant frame rate \fIfps\fR.
.Sp
As a output option, duplicate or drop input frames ta big up constant output
frame rate \fIfps\fR.
.IP "\fB\-s[:\fR\fIstream_specifier\fR\fB]\fR \fIsize\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-s[:stream_specifier] size (input/output,per-stream)"
Set frame size.
.Sp
As a input option, dis be a gangbangin' finger-lickin' dirty-ass shortcut fo' tha \fBvideo_size\fR private
option, recognized by some demuxers fo' which tha frame size is either not
stored up in tha file or is configurable \*(-- e.g. raw vizzle or vizzle grabbers.
.Sp
As a output option, dis bangs tha \f(CW\*(C`scale\*(C'\fR vizzle filta ta the
\&\fIend\fR of tha correspondin filtergraph. Please use tha \f(CW\*(C`scale\*(C'\fR filter
directly ta bang it all up in tha beginnin or some other place.
.Sp
Da format is \fBwxh\fR (default \- same as source).
.IP "\fB\-aspect[:\fR\fIstream_specifier\fR\fB]\fR \fIaspect\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-aspect[:stream_specifier] aspect (output,per-stream)"
Set tha vizzle display aspect ratio specified by \fIaspect\fR.
.Sp
\&\fIaspect\fR can be a gangbangin' floatin point number string, or a strang of the
form \fInum\fR:\fIden\fR, where \fInum\fR n' \fIden\fR is the
numerator n' denominator of tha aspect ratio. For example \*(L"4:3\*(R",
\&\*(L"16:9\*(R", \*(L"1.3333\*(R", n' \*(L"1.7777\*(R" is valid argument joints.
.Sp
If used together wit \fB\-vcodec copy\fR, it will affect tha aspect ratio
stored at container level yo, but not tha aspect ratio stored up in encoded
frames, if it exists.
.IP "\fB\-vn (\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-vn (output)"
Disable vizzle recording.
.IP "\fB\-vcodec\fR \fIcodec\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-vcodec codec (output)"
Set tha vizzle codec. This be a alias fo' \f(CW\*(C`\-codec:v\*(C'\fR.
.IP "\fB\-pass[:\fR\fIstream_specifier\fR\fB]\fR \fIn\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-pass[:stream_specifier] n (output,per-stream)"
Select tha pass number (1 or 2). Well shiiiit, it is used ta do two-pass
video encoding. Da statistics of tha vizzle is recorded up in tha first
pass tha fuck into a log file (see also tha option \-passlogfile),
and up in tha second pass dat log file is used ta generate tha vizzle
at tha exact axed bitrate.
On pass 1, you may just deactivate audio n' set output ta null,
examplez fo' Windows n' Unix:
.Sp
.Vb 2
\&        ffmpeg \-i foo.mov \-c:v libxvid \-pass 1 \-an \-f rawvideo \-y NUL
\&        ffmpeg \-i foo.mov \-c:v libxvid \-pass 1 \-an \-f rawvideo \-y /dev/null
.Ve
.IP "\fB\-passlogfile[:\fR\fIstream_specifier\fR\fB]\fR \fIprefix\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-passlogfile[:stream_specifier] prefix (output,per-stream)"
Set two-pass log file name prefix ta \fIprefix\fR, tha default file name
prefix is ``ffmpeg2pass''. Da complete file name will be
\&\fI\s-1PREFIX\-N\s0.log\fR, where N be a number specific ta tha output
stream
.IP "\fB\-vlang\fR \fIcode\fR" 4
.IX Item "-vlang code"
Set tha \s-1ISO 639\s0 language code (3 letters) of tha current vizzle stream.
.IP "\fB\-vf\fR \fIfiltergraph\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-vf filtergraph (output)"
Smoke tha filtergraph specified by \fIfiltergraph\fR n' use it to
filta tha stream.
.Sp
This be a alias fo' \f(CW\*(C`\-filter:v\*(C'\fR, peep tha \-filta option.
.SS "Advanced Video Options"
.IX Subsection "Advanced Video Options"
.IP "\fB\-pix_fmt[:\fR\fIstream_specifier\fR\fB]\fR \fIformat\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-pix_fmt[:stream_specifier] format (input/output,per-stream)"
Set pixel format. Use \f(CW\*(C`\-pix_fmts\*(C'\fR ta show all tha supported
pixel formats.
If tha selected pixel format can not be selected, ffmpeg will print a
warnin n' select tha dopest pixel format supported by tha encoder.
If \fIpix_fmt\fR is prefixed by a \f(CW\*(C`+\*(C'\fR, ffmpeg will exit wit a error
if tha axed pixel format can not be selected, n' automatic conversions
inside filtergraphs is disabled.
If \fIpix_fmt\fR be a single \f(CW\*(C`+\*(C'\fR, ffmpeg selects tha same ol' dirty pixel format
as tha input (or graph output) n' automatic conversions is disabled.
.IP "\fB\-sws_flags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-sws_flags flags (input/output)"
Set SwScala flags.
.IP "\fB\-vdt\fR \fIn\fR" 4
.IX Item "-vdt n"
Discard threshold.
.IP "\fB\-rc_override[:\fR\fIstream_specifier\fR\fB]\fR \fIoverride\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-rc_override[:stream_specifier] override (output,per-stream)"
Rate control override fo' specific intervals, formatted as \*(L"int,int,int\*(R"
list separated wit slashes. Two first joints is tha beginnin and
end frame numbers, last one is quantizer ta use if positive, or quality
factor if negative.
.IP "\fB\-ilme\fR" 4
.IX Item "-ilme"
Force interlacin support up in encoder (\s-1MPEG\-2\s0 n' \s-1MPEG\-4\s0 only).
Use dis option if yo' input file is interlaced n' you want
to keep tha interlaced format fo' minimum losses.
Da alternatizzle is ta deinterlace tha input stream with
\&\fB\-deinterlace\fR yo, but deinterlacin introduces losses.
.IP "\fB\-psnr\fR" 4
.IX Item "-psnr"
Calculate \s-1PSNR\s0 of compressed frames.
.IP "\fB\-vstats\fR" 4
.IX Item "-vstats"
Dump vizzle codin statistics ta \fIvstats_HHMMSS.log\fR.
.IP "\fB\-vstats_file\fR \fIfile\fR" 4
.IX Item "-vstats_file file"
Dump vizzle codin statistics ta \fIfile\fR.
.IP "\fB\-top[:\fR\fIstream_specifier\fR\fB]\fR \fIn\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-top[:stream_specifier] n (output,per-stream)"
top=1/bottom=0/auto=\-1 field first
.IP "\fB\-dc\fR \fIprecision\fR" 4
.IX Item "-dc precision"
Intra_dc_precision.
.IP "\fB\-vtag\fR \fIfourcc/tag\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-vtag fourcc/tag (output)"
Force vizzle tag/fourcc. This be a alias fo' \f(CW\*(C`\-tag:v\*(C'\fR.
.IP "\fB\-qphist (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-qphist (global)"
Show \s-1QP\s0 histogram
.IP "\fB\-vbsf\fR \fIbitstream_filter\fR" 4
.IX Item "-vbsf bitstream_filter"
Deprecated peep \-bsf
.IP "\fB\-force_key_frames[:\fR\fIstream_specifier\fR\fB]\fR \fItime\fR\fB[,\fR\fItime\fR\fB...] (\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-force_key_frames[:stream_specifier] time[,time...] (output,per-stream)"
.PD 0
.IP "\fB\-force_key_frames[:\fR\fIstream_specifier\fR\fB] expr:\fR\fIexpr\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-force_key_frames[:stream_specifier] expr:expr (output,per-stream)"
.PD
Force key frames all up in tha specified timestamps, mo' precisely all up in tha first
frames afta each specified time.
.Sp
If tha argument is prefixed wit \f(CW\*(C`expr:\*(C'\fR, tha strang \fIexpr\fR
is interpreted like a expression n' is evaluated fo' each frame fo' realz. A
key frame is forced up in case tha evaluation is non-zero.
.Sp
If one of tha times is "\f(CW\*(C`chapters\*(C'\fR[\fIdelta\fR]", it is expanded into
the time of tha beginnin of all chaptas up in tha file, shifted by
\&\fIdelta\fR, expressed as a time up in seconds.
This option can be useful ta ensure dat a seek point is present at a
chapta mark or any other designated place up in tha output file.
.Sp
For example, ta bang a key frame at 5 minutes, plus key frames 0.1 second
before tha beginnin of every last muthafuckin chapter:
.Sp
.Vb 1
\&        \-force_key_frames 0:05:00,chapters\-0.1
.Ve
.Sp
Da expression up in \fIexpr\fR can contain tha followin constants:
.RS 4
.IP "\fBn\fR" 4
.IX Item "n"
the number of current processed frame, startin from 0
.IP "\fBn_forced\fR" 4
.IX Item "n_forced"
the number of forced frames
.IP "\fBprev_forced_n\fR" 4
.IX Item "prev_forced_n"
the number of tha previous forced frame, it is \f(CW\*(C`NAN\*(C'\fR when no
keyframe was forced yet
.IP "\fBprev_forced_t\fR" 4
.IX Item "prev_forced_t"
the time of tha previous forced frame, it is \f(CW\*(C`NAN\*(C'\fR when no
keyframe was forced yet
.IP "\fBt\fR" 4
.IX Item "t"
the time of tha current processed frame
.RE
.RS 4
.Sp
For example ta force a key frame every last muthafuckin 5 seconds, you can specify:
.Sp
.Vb 1
\&        \-force_key_frames expr:gte(t,n_forced*5)
.Ve
.Sp
To force a key frame 5 secondz afta tha time of tha last forced one,
startin from second 13:
.Sp
.Vb 1
\&        \-force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))
.Ve
.Sp
Note dat forcin too nuff keyframes is straight-up harmful fo' tha lookahead
algorithmz of certain encoders: rockin fixed-GOP options or similar
would be mo' efficient.
.RE
.IP "\fB\-copyinkf[:\fR\fIstream_specifier\fR\fB] (\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-copyinkf[:stream_specifier] (output,per-stream)"
When bustin stream copy, copy also non-key frames found at the
beginning.
.SS "Audio Options"
.IX Subsection "Audio Options"
.IP "\fB\-aframes\fR \fInumber\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-aframes number (output)"
Set tha number of audio frames ta record. Y'all KNOW dat shit, muthafucka! This be a alias fo' \f(CW\*(C`\-frames:a\*(C'\fR.
.IP "\fB\-ar[:\fR\fIstream_specifier\fR\fB]\fR \fIfreq\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-ar[:stream_specifier] freq (input/output,per-stream)"
Set tha audio samplin frequency. For output streams it is set by
default ta tha frequency of tha correspondin input stream. For input
streams dis option only make sense fo' audio grabbin devices n' raw
demuxers n' is mapped ta tha correspondin demuxer options.
.IP "\fB\-aq\fR \fIq\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-aq q (output)"
Set tha audio qualitizzle (codec-specific, \s-1VBR\s0). This be a alias fo' \-q:a.
.IP "\fB\-ac[:\fR\fIstream_specifier\fR\fB]\fR \fIchannels\fR \fB(\fR\fIinput/output,per\-stream\fR\fB)\fR" 4
.IX Item "-ac[:stream_specifier] channels (input/output,per-stream)"
Set tha number of audio channels. For output streams it is set by
default ta tha number of input audio channels. For input streams
this option only make sense fo' audio grabbin devices n' raw demuxers
and is mapped ta tha correspondin demuxer options.
.IP "\fB\-an (\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-an (output)"
Disable audio recording.
.IP "\fB\-acodec\fR \fIcodec\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-acodec codec (input/output)"
Set tha audio codec. This be a alias fo' \f(CW\*(C`\-codec:a\*(C'\fR.
.IP "\fB\-sample_fmt[:\fR\fIstream_specifier\fR\fB]\fR \fIsample_fmt\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-sample_fmt[:stream_specifier] sample_fmt (output,per-stream)"
Set tha audio sample format. Use \f(CW\*(C`\-sample_fmts\*(C'\fR ta git a list
of supported sample formats.
.IP "\fB\-af\fR \fIfiltergraph\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-af filtergraph (output)"
Smoke tha filtergraph specified by \fIfiltergraph\fR n' use it to
filta tha stream.
.Sp
This be a alias fo' \f(CW\*(C`\-filter:a\*(C'\fR, peep tha \-filta option.
.SS "Advanced Audio options:"
.IX Subsection "Advanced Audio options:"
.IP "\fB\-atag\fR \fIfourcc/tag\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-atag fourcc/tag (output)"
Force audio tag/fourcc. This be a alias fo' \f(CW\*(C`\-tag:a\*(C'\fR.
.IP "\fB\-absf\fR \fIbitstream_filter\fR" 4
.IX Item "-absf bitstream_filter"
Deprecated, peep \-bsf
.IP "\fB\-guess_layout_max\fR \fIchannels\fR \fB(\fR\fIinput,per\-stream\fR\fB)\fR" 4
.IX Item "-guess_layout_max channels (input,per-stream)"
If some input channel layout aint known, try ta guess only if it
correspondz ta at most tha specified number of channels. For example, 2
 drops some lyrics ta ta \fBffmpeg\fR ta recognize 1 channel as mono n' 2 channels as
stereo but not 6 channels as 5.1. Da default is ta always try ta guess. Use
0 ta disable all guessing.
.SS "Subtitle options:"
.IX Subsection "Subtitle options:"
.IP "\fB\-slang\fR \fIcode\fR" 4
.IX Item "-slang code"
Set tha \s-1ISO 639\s0 language code (3 letters) of tha current subtitle stream.
.IP "\fB\-scodec\fR \fIcodec\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-scodec codec (input/output)"
Set tha subtitle codec. This be a alias fo' \f(CW\*(C`\-codec:s\*(C'\fR.
.IP "\fB\-sn (\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-sn (output)"
Disable subtitle recording.
.IP "\fB\-sbsf\fR \fIbitstream_filter\fR" 4
.IX Item "-sbsf bitstream_filter"
Deprecated, peep \-bsf
.SS "Advanced Subtitle options:"
.IX Subsection "Advanced Subtitle options:"
.IP "\fB\-fix_sub_duration\fR" 4
.IX Item "-fix_sub_duration"
Fix subtitlez durations. For each subtitle, wait fo' tha next packet up in the
same stream n' adjust tha duration of tha straight-up original gangsta ta avoid overlap. This is
necessary wit some subtitlez codecs, especially \s-1DVB\s0 subtitles, cuz the
duration up in tha original gangsta packet is only a rough estimate n' tha end is
actually marked by a empty subtitle frame. Failin ta use dis option when
necessary can result up in exaggerated durations or muxin failures due to
non-monotonic timestamps.
.Sp
Note dat dis option will delay tha output of all data until tha next
subtitle packet is decoded: it may increase memory consumption n' latency a
lot.
.IP "\fB\-canvas_size\fR \fIsize\fR" 4
.IX Item "-canvas_size size"
Set tha size of tha canvas used ta render subtitles.
.SS "Advanced options"
.IX Subsection "Advanced options"
.IP "\fB\-map [\-]\fR\fIinput_file_id\fR\fB[:\fR\fIstream_specifier\fR\fB][,\fR\fIsync_file_id\fR\fB[:\fR\fIstream_specifier\fR\fB]] |\fR \fI[linklabel]\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-map [-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]] | [linklabel] (output)"
Designate one or mo' input streams as a source fo' tha output file. Each input
stream is identified by tha input file index \fIinput_file_id\fR and
the input stream index \fIinput_stream_id\fR within tha input
file. Both indices start at 0. If specified,
\&\fIsync_file_id\fR:\fIstream_specifier\fR sets which input stream
is used as a presentation sync reference.
.Sp
Da first \f(CW\*(C`\-map\*(C'\fR option on tha command line specifies the
source fo' output stream 0, tha second \f(CW\*(C`\-map\*(C'\fR option specifies
the source fo' output stream 1, etc.
.Sp
A \f(CW\*(C`\-\*(C'\fR characta before tha stream identifier creates a \*(L"negative\*(R" mapping.
It disablez matchin streams from already pimped mappings.
.Sp
An alternatizzle \fI[linklabel]\fR form will map outputs from complex filter
graphs (see tha \fB\-filter_complex\fR option) ta tha output file.
\&\fIlinklabel\fR must correspond ta a thugged-out defined output link label up in tha graph.
.Sp
For example, ta map \s-1ALL\s0 streams from tha straight-up original gangsta input file ta output
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0 output
.Ve
.Sp
For example, if you have two audio streams up in tha straight-up original gangsta input file,
these streams is identified by \*(L"0:0\*(R" n' \*(L"0:1\*(R". Yo ass can use
\&\f(CW\*(C`\-map\*(C'\fR ta select which streams ta place up in a output file. For
example:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0:1 out.wav
.Ve
.Sp
will map tha input stream up in \fI\s-1INPUT\s0\fR identified by \*(L"0:1\*(R" to
the (single) output stream up in \fIout.wav\fR.
.Sp
For example, ta select tha stream wit index 2 from input file
\&\fIa.mov\fR (specified by tha identifier \*(L"0:2\*(R"), n' stream with
index 6 from input \fIb.mov\fR (specified by tha identifier \*(L"1:6\*(R"),
and copy dem ta tha output file \fIout.mov\fR:
.Sp
.Vb 1
\&        ffmpeg \-i a.mov \-i b.mov \-c copy \-map 0:2 \-map 1:6 out.mov
.Ve
.Sp
To select all vizzle n' tha third audio stream from a input file:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0:v \-map 0:a:2 OUTPUT
.Ve
.Sp
To map all tha streams except tha second audio, use wack mappings
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map 0 \-map \-0:a:1 OUTPUT
.Ve
.Sp
Note dat rockin dis option disablez tha default mappings fo' dis output file.
.IP "\fB\-map_channel [\fR\fIinput_file_id\fR\fB.\fR\fIstream_specifier\fR\fB.\fR\fIchannel_id\fR\fB|\-1][:\fR\fIoutput_file_id\fR\fB.\fR\fIstream_specifier\fR\fB]\fR" 4
.IX Item "-map_channel [input_file_id.stream_specifier.channel_id|-1][:output_file_id.stream_specifier]"
Map a audio channel from a given input ta a output. If
\&\fIoutput_file_id\fR.\fIstream_specifier\fR aint set, tha audio channel will
be mapped on all tha audio streams.
.Sp
Usin \*(L"\-1\*(R" instead of
\&\fIinput_file_id\fR.\fIstream_specifier\fR.\fIchannel_id\fR will map a muted
channel.
.Sp
For example, assumin \fI\s-1INPUT\s0\fR be a stereo audio file, you can switch the
two audio channels wit tha followin command:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map_channel 0.0.1 \-map_channel 0.0.0 OUTPUT
.Ve
.Sp
If you wanna mute tha straight-up original gangsta channel n' keep tha second:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map_channel \-1 \-map_channel 0.0.1 OUTPUT
.Ve
.Sp
Da order of tha \*(L"\-map_channel\*(R" option specifies tha order of tha channels in
the output stream. Da output channel layout is guessed from tha number of
channels mapped (mono if one \*(L"\-map_channel\*(R", stereo if two, etc.). Usin \*(L"\-ac\*(R"
in combination of \*(L"\-map_channel\*(R" make tha channel bust levels ta be updated if
input n' output channel layouts don't match (for instizzle two \*(L"\-map_channel\*(R"
options n' \*(L"\-ac 6\*(R").
.Sp
Yo ass can also extract each channel of a input ta specific outputs; tha following
command extracts two channelz of tha \fI\s-1INPUT\s0\fR audio stream (file 0, stream 0)
to tha respectizzle \fI\s-1OUTPUT_CH0\s0\fR n' \fI\s-1OUTPUT_CH1\s0\fR outputs:
.Sp
.Vb 1
\&        ffmpeg \-i INPUT \-map_channel 0.0.0 OUTPUT_CH0 \-map_channel 0.0.1 OUTPUT_CH1
.Ve
.Sp
Da followin example splits tha channelz of a stereo input tha fuck into two separate
streams, which is put tha fuck into tha same output file:
.Sp
.Vb 1
\&        ffmpeg \-i stereo.wav \-map 0:0 \-map 0:0 \-map_channel 0.0.0:0.0 \-map_channel 0.0.1:0.1 \-y out.ogg
.Ve
.Sp
Note dat currently each output stream can only contain channels from a single
input stream; you can't fo' example use \*(L"\-map_channel\*(R" ta pick multiple input
audio channels contained up in different streams (from tha same or different files)
and merge dem tha fuck into a single output stream. Well shiiiit, it is therefore not currently
possible, fo' example, ta turn two separate mono streams tha fuck into a single stereo
stream yo. However splittin a stereo stream tha fuck into two single channel mono streams
is possible.
.Sp
If you need dis feature, a possible workaround is ta use tha \fIamerge\fR
filter n' shit. For example, if you need ta merge a media (here \fIinput.mkv\fR) wit 2
mono audio streams tha fuck into one single stereo channel audio stream (and keep the
video stream), you can use tha followin command:
.Sp
.Vb 1
\&        ffmpeg \-i input.mkv \-filter_complex "[0:1] [0:2] amerge" \-c:a pcm_s16le \-c:v copy output.mkv
.Ve
.IP "\fB\-map_metadata[:\fR\fImetadata_spec_out\fR\fB]\fR \fIinfile\fR\fB[:\fR\fImetadata_spec_in\fR\fB] (\fR\fIoutput,per\-metadata\fR\fB)\fR" 4
.IX Item "-map_metadata[:metadata_spec_out] infile[:metadata_spec_in] (output,per-metadata)"
Set metadata shiznit of tha next output file from \fIinfile\fR. Note that
those is file indices (zero-based), not filenames.
Optionizzle \fImetadata_spec_in/out\fR parametas specify, which metadata ta copy.
A metadata specifier can have tha followin forms:
.RS 4
.IP "\fIg\fR" 4
.IX Item "g"
global metadata, i.e. metadata dat applies ta tha whole file
.IP "\fIs\fR\fB[:\fR\fIstream_spec\fR\fB]\fR" 4
.IX Item "s[:stream_spec]"
per-stream metadata. \fIstream_spec\fR be a stream specifier as busted lyrics about
in tha Stream specifiers chapter n' shit. In a input metadata specifier, tha first
matchin stream is copied from. In a output metadata specifier, all matching
streams is copied to.
.IP "\fIc\fR\fB:\fR\fIchapter_index\fR" 4
.IX Item "c:chapter_index"
per-chapta metadata. \fIchapter_index\fR is tha zero-based chapta index.
.IP "\fIp\fR\fB:\fR\fIprogram_index\fR" 4
.IX Item "p:program_index"
per-program metadata. \fIprogram_index\fR is tha zero-based program index.
.RE
.RS 4
.Sp
If metadata specifier is omitted, it defaults ta global.
.Sp
By default, global metadata is copied from tha straight-up original gangsta input file,
per-stream n' per-chapta metadata is copied along wit streams/chapters. These
default mappings is disabled by bustin any mappin of tha relevant type fo' realz. A negative
file index can be used ta create a thugged-out dummy mappin dat just disablez automatic copying.
.Sp
For example ta copy metadata from tha straight-up original gangsta stream of tha input file ta global metadata
of tha output file:
.Sp
.Vb 1
\&        ffmpeg \-i in.ogg \-map_metadata 0:s:0 out.mp3
.Ve
.Sp
To do tha reverse, i.e. copy global metadata ta all audio streams:
.Sp
.Vb 1
\&        ffmpeg \-i in.mkv \-map_metadata:s:a 0:g out.mkv
.Ve
.Sp
Note dat simple \f(CW0\fR would work as well up in dis example, since global
metadata be assumed by default.
.RE
.IP "\fB\-map_chapters\fR \fIinput_file_index\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-map_chaptas input_file_index (output)"
Copy chaptas from input file wit index \fIinput_file_index\fR ta tha next
output file. If no chapta mappin is specified, then chaptas is copied from
the first input file wit at least one chapter n' shit. Use a wack file index to
disable any chapta copying.
.IP "\fB\-benchmark (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-benchmark (global)"
Show benchmarkin shiznit all up in tha end of a encode.
Shows \s-1CPU\s0 time used n' maximum memory consumption.
Maximum memory consumption aint supported on all systems,
it will probably display as 0 if not supported.
.IP "\fB\-benchmark_all (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-benchmark_all (global)"
Show benchmarkin shiznit durin tha encode.
Shows \s-1CPU\s0 time used up in various steps (audio/video encode/decode).
.IP "\fB\-timelimit\fR \fIduration\fR \fB(\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-timelimit duration (global)"
Exit afta ffmpeg has been hustlin fo' \fIduration\fR seconds.
.IP "\fB\-dump (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-dump (global)"
Dump each input packet ta stderr.
.IP "\fB\-hex (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-hex (global)"
When dumpin packets, also dump tha payload.
.IP "\fB\-re (\fR\fIinput\fR\fB)\fR" 4
.IX Item "-re (input)"
Read input at natizzle frame rate. Mainly used ta simulate a grab device.
or live input stream (e.g. when readin from a gangbangin' file). Right back up in yo muthafuckin ass. Should not be used
with actual grab devices or live input streams (where it can cause packet
loss).
By default \fBffmpeg\fR attempts ta read tha input(s) as fast as possible.
This option will slow down tha readin of tha input(s) ta tha natizzle frame rate
of tha input(s). Well shiiiit, it is useful fo' real-time output (e.g. live streaming).
.IP "\fB\-loop_input\fR" 4
.IX Item "-loop_input"
Loop over tha input stream. Currently it works only fo' image
streams. This option is used fo' automatic FFserver testing.
This option is deprecated, use \-loop 1.
.IP "\fB\-loop_output\fR \fInumber_of_times\fR" 4
.IX Item "-loop_output number_of_times"
Repeatedly loop output fo' formats dat support loopin like fuckin animated \s-1GIF
\&\s0(0 will loop tha output infinitely).
This option is deprecated, use \-loop.
.IP "\fB\-vsync\fR \fIparameter\fR" 4
.IX Item "-vsync parameter"
Video sync method.
For compatibilitizzle reasons oldschool joints can be specified as numbers.
Newly added joints will gotta be specified as strings always.
.RS 4
.IP "\fB0, passthrough\fR" 4
.IX Item "0, passthrough"
Each frame is passed wit its timestamp from tha demuxer ta tha muxer.
.IP "\fB1, cfr\fR" 4
.IX Item "1, cfr"
Frames is ghon be duplicated n' dropped ta big up exactly tha requested
constant frame rate.
.IP "\fB2, vfr\fR" 4
.IX Item "2, vfr"
Frames is passed all up in wit they timestamp or dropped so as to
prevent 2 frames from havin tha same timestamp.
.IP "\fBdrop\fR" 4
.IX Item "drop"
As passall up in but destroys all timestamps, makin tha muxer generate
fresh timestamps based on frame-rate.
.IP "\fB\-1, auto\fR" 4
.IX Item "-1, auto"
Chooses between 1 n' 2 dependin on muxer capabilities. Put ya muthafuckin choppers up if ya feel dis! This is the
default method.
.RE
.RS 4
.Sp
Note dat tha timestamps may be further modified by tha muxer, afta all dis bullshit.
For example, up in tha case dat tha format option \fBavoid_negative_ts\fR
is enabled.
.Sp
With \-map you can select from which stream tha timestamps should be
taken. I aint talkin' bout chicken n' gravy biatch. Yo ass can leave either vizzle or audio unchanged n' sync the
remainin stream(s) ta tha unchanged one.
.RE
.IP "\fB\-async\fR \fIsamples_per_second\fR" 4
.IX Item "-async samples_per_second"
Audio sync method. Y'all KNOW dat shit, muthafucka! \*(L"Stretches/squeezes\*(R" tha audio stream ta match tha timestamps,
the parameta is tha maximum samplez per second by which tha audio is chizzled.
\&\-async 1 be a special case where only tha start of tha audio stream is erected
without any lata erection.
.Sp
Note dat tha timestamps may be further modified by tha muxer, afta all dis bullshit.
For example, up in tha case dat tha format option \fBavoid_negative_ts\fR
is enabled.
.Sp
This option has been deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha \f(CW\*(C`aresample\*(C'\fR audio filta instead.
.IP "\fB\-copyts\fR" 4
.IX Item "-copyts"
Do not process input timestamps yo, but keep they joints without trying
to sanitize em. In particular, do not remove tha initial start time
offset value.
.Sp
Note that, dependin on tha \fBvsync\fR option or on specific muxer
processin (e.g. up in case tha format option \fBavoid_negative_ts\fR
is enabled) tha output timestamps may mismatch wit tha input
timestamps even when dis option is selected.
.IP "\fB\-copytb\fR \fImode\fR" 4
.IX Item "-copytb mode"
Specify how tha fuck ta set tha encoder timebase when stream copying.  \fImode\fR be an
integer numeric value, n' can assume one of tha followin joints:
.RS 4
.IP "\fB1\fR" 4
.IX Item "1"
Use tha demuxer timebase.
.Sp
Da time base is copied ta tha output encoder from tha correspondin input
demuxer n' shit. This is sometimes required ta avoid non monotonically increasing
timestamps when copyin vizzle streams wit variable frame rate.
.IP "\fB0\fR" 4
.IX Item "0"
Use tha decoder timebase.
.Sp
Da time base is copied ta tha output encoder from tha correspondin input
decoder.
.IP "\fB\-1\fR" 4
.IX Item "-1"
Try ta make tha chizzle automatically, up in order ta generate a sane output.
.RE
.RS 4
.Sp
Default value is \-1.
.RE
.IP "\fB\-shortest (\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-shortest (output)"
Finish encodin when tha shortest input stream ends.
.IP "\fB\-dts_delta_threshold\fR" 4
.IX Item "-dts_delta_threshold"
Timestamp discontinuitizzle delta threshold.
.IP "\fB\-muxdelay\fR \fIseconds\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-muxdelay secondz (input)"
Set tha maximum demux-decode delay.
.IP "\fB\-muxpreload\fR \fIseconds\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-muxpreload secondz (input)"
Set tha initial demux-decode delay.
.IP "\fB\-streamid\fR \fIoutput-stream-index\fR\fB:\fR\fInew-value\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-streamid output-stream-index:new-value (output)"
Assign a freshly smoked up stream-id value ta a output stream. This option should be
specified prior ta tha output filename ta which it applies.
For tha thang where multiple output filez exist, a streamid
may be reassigned ta a gangbangin' finger-lickin' different value.
.Sp
For example, ta set tha stream 0 \s-1PID\s0 ta 33 n' tha stream 1 \s-1PID\s0 ta 36 for
an output mpegts file:
.Sp
.Vb 1
\&        ffmpeg \-i infile \-streamid 0:33 \-streamid 1:36 out.ts
.Ve
.IP "\fB\-bsf[:\fR\fIstream_specifier\fR\fB]\fR \fIbitstream_filters\fR \fB(\fR\fIoutput,per\-stream\fR\fB)\fR" 4
.IX Item "-bsf[:stream_specifier] bitstream_filtas (output,per-stream)"
Set bitstream filtas fo' matchin streams. \fIbitstream_filters\fR is
a comma-separated list of bitstream filters. Use tha \f(CW\*(C`\-bsfs\*(C'\fR option
to git tha list of bitstream filters.
.Sp
.Vb 1
\&        ffmpeg \-i h264.mp4 \-c:v copy \-bsf:v h264_mp4toannexb \-an out.h264
\&
\&        
\&        ffmpeg \-i file.mov \-an \-vn \-bsf:s mov2textsub \-c:s copy \-f rawvideo sub.txt
.Ve
.IP "\fB\-tag[:\fR\fIstream_specifier\fR\fB]\fR \fIcodec_tag\fR \fB(\fR\fIper-stream\fR\fB)\fR" 4
.IX Item "-tag[:stream_specifier] codec_tag (per-stream)"
Force a tag/fourcc fo' matchin streams.
.IP "\fB\-timecode\fR \fIhh\fR\fB:\fR\fImm\fR\fB:\fR\fIss\fR\fB\s-1SEP\s0\fR\fIff\fR" 4
.IX Item "-timecode hh:mm:ssSEPff"
Specify Timecode fo' writing. \fI\s-1SEP\s0\fR is ':' fo' non drop timecode n' ';'
(or '.') fo' drop.
.Sp
.Vb 1
\&        ffmpeg \-i input.mpg \-timecode 01:02:03.04 \-r 30000/1001 \-s ntsc output.mpg
.Ve
.IP "\fB\-filter_complex\fR \fIfiltergraph\fR \fB(\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-filter_complex filtergraph (global)"
Define a cold-ass lil complex filtergraph, i.e. one wit arbitrary number of inputs and/or
outputs, n' you can put dat on yo' toast. For simple graphs \*(-- dem wit one input n' one output of tha same
type \*(-- peep tha \fB\-filter\fR options. \fIfiltergraph\fR be a thugged-out description of
the filtergraph, as busted lyrics bout up in tha ``Filtergraph syntax'' section of the
ffmpeg-filtas manual.
.Sp
Input link labels must refer ta input streams rockin the
\&\f(CW\*(C`[file_index:stream_specifier]\*(C'\fR syntax (i.e. tha same as \fB\-map\fR
uses). If \fIstream_specifier\fR matches multiple streams, tha straight-up original gangsta one will be
used. Y'all KNOW dat shit, muthafucka! An unlabeled input is ghon be connected ta tha straight-up original gangsta unused input stream of
the matchin type.
.Sp
Output link labels is referred ta wit \fB\-map\fR. Unlabeled outputs are
added ta tha straight-up original gangsta output file.
.Sp
Note dat wit dis option it is possible ta use only lavfi sources without
normal input files.
.Sp
For example, ta overlay a image over vizzle
.Sp
.Vb 2
\&        ffmpeg \-i vizzle.mkv \-i image.png \-filter_complex \*(Aq[0:v][1:v]overlay[out]\*(Aq \-map
\&        \*(Aq[out]\*(Aq out.mkv
.Ve
.Sp
Here \f(CW\*(C`[0:v]\*(C'\fR refers ta tha straight-up original gangsta vizzle stream up in tha straight-up original gangsta input file,
which is linked ta tha straight-up original gangsta (main) input of tha overlay filter n' shit. Right back up in yo muthafuckin ass. Similarly the
first vizzle stream up in tha second input is linked ta tha second (overlay) input
of overlay.
.Sp
Assumin there is only one vizzle stream up in each input file, we can omit input
labels, so tha above is equivalent to
.Sp
.Vb 2
\&        ffmpeg \-i vizzle.mkv \-i image.png \-filter_complex \*(Aqoverlay[out]\*(Aq \-map
\&        \*(Aq[out]\*(Aq out.mkv
.Ve
.Sp
Furthermore we can omit tha output label n' tha single output from tha filter
graph is ghon be added ta tha output file automatically, so we can simply write
.Sp
.Vb 1
\&        ffmpeg \-i vizzle.mkv \-i image.png \-filter_complex \*(Aqoverlay\*(Aq out.mkv
.Ve
.Sp
To generate 5 secondz of pure red vizzle rockin lavfi \f(CW\*(C`color\*(C'\fR source:
.Sp
.Vb 1
\&        ffmpeg \-filter_complex \*(Aqcolor=c=red\*(Aq \-t 5 out.mkv
.Ve
.IP "\fB\-lavfi\fR \fIfiltergraph\fR \fB(\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-lavfi filtergraph (global)"
Define a cold-ass lil complex filtergraph, i.e. one wit arbitrary number of inputs and/or
outputs, n' you can put dat on yo' toast. Equivalent ta \fB\-filter_complex\fR.
.IP "\fB\-filter_complex_script\fR \fIfilename\fR \fB(\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-filter_complex_script filename (global)"
This option is similar ta \fB\-filter_complex\fR, tha only difference is that
its argument is tha name of tha file from which a cold-ass lil complex filtergraph
description is ta be read.
.IP "\fB\-accurate_seek (\fR\fIinput\fR\fB)\fR" 4
.IX Item "-accurate_seek (input)"
This option enablez or disablez accurate seekin up in input filez wit the
\&\fB\-ss\fR option. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is enabled by default, so seekin be accurate when
transcoding. Use \fB\-noaccurate_seek\fR ta disable it, which may be useful
e.g. when copyin some streams n' transcodin tha others.
.IP "\fB\-override_ffserver (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-override_ffserver (global)"
Overrides tha input justifications from ffserver n' shit. Usin dis option you can
map any input stream ta ffserver n' control nuff aspectz of tha encodin from
ffmpeg. Without dis option ffmpeg will transmit ta ffserver what tha fuck be axed by
ffserver.
Da option is intended fo' cases where features is needed dat cannot be
specified ta ffserver but can be ta ffmpeg.
.PP
As a special exception, you can bust a funky-ass bitmap subtitle stream as input: it
will be converted tha fuck into a vizzle wit tha same size as tha phattest vizzle in
the file, or 720x576 if no vizzle is present. Note dat dis be an
experimenstrual n' temporary solution. I aint talkin' bout chicken n' gravy biatch. Well shiiiit, it is ghon be removed once libavfilta has
proper support fo' subtitles.
.PP
For example, ta hardcode subtitlez on top of a DVB-T recordin stored in
MPEG-TS format, delayin tha subtitlez by 1 second:
.PP
.Vb 3
\&        ffmpeg \-i input.ts \-filter_complex \e
\&          \*(Aq[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay\*(Aq \e
\&          \-sn \-map \*(Aq#0x2dc\*(Aq output.mkv
.Ve
.PP
(0x2d0, 0x2dc n' 0x2ef is tha MPEG-TS PIDz of respectively tha vizzle,
audio n' subtitlez streams; 0:0, 0:3 n' 0:7 would have hit dat shiznit too)
.SS "Preset files"
.IX Subsection "Preset files"
A preset file gotz nuff a sequence of \fIoption\fR=\fIvalue\fR pairs,
one fo' each line, specifyin a sequence of options which would be
awkward ta specify on tha command line. Lines startin wit tha hash
('#') characta is ignored n' is used ta provide comments, n' you can put dat on yo' toast. Check
the \fIpresets\fR directory up in tha FFmpeg source tree fo' examples.
.PP
Preset filez is specified wit tha \f(CW\*(C`vpre\*(C'\fR, \f(CW\*(C`apre\*(C'\fR,
\&\f(CW\*(C`spre\*(C'\fR, n' \f(CW\*(C`fpre\*(C'\fR options. Da \f(CW\*(C`fpre\*(C'\fR option takes the
filename of tha preset instead of a preset name as input n' can be
used fo' any kind of codec. For tha \f(CW\*(C`vpre\*(C'\fR, \f(CW\*(C`apre\*(C'\fR, and
\&\f(CW\*(C`spre\*(C'\fR options, tha options specified up in a preset file are
applied ta tha currently selected codec of tha same type as tha preset
option.
.PP
Da argument passed ta tha \f(CW\*(C`vpre\*(C'\fR, \f(CW\*(C`apre\*(C'\fR, n' \f(CW\*(C`spre\*(C'\fR
preset options identifies tha preset file ta use accordin ta the
followin rules:
.PP
First ffmpeg searches fo' a gangbangin' file named \fIarg\fR.ffpreset up in the
directories \fI\f(CI$FFMPEG_DATADIR\fI\fR (if set), n' \fI\f(CI$HOME\fI/.ffmpeg\fR, n' in
the datadir defined at configuration time (usually \fIPREFIX/share/ffmpeg\fR)
or up in a \fIffpresets\fR folda along tha executable on win32,
in dat order n' shit. For example, if tha argument is \f(CW\*(C`libvpx\-1080p\*(C'\fR, it will
search fo' tha file \fIlibvpx\-1080p.ffpreset\fR.
.PP
If no such file is found, then ffmpeg will search fo' a gangbangin' file named
\&\fIcodec_name\fR\-\fIarg\fR.ffpreset up in tha above-mentioned
directories, where \fIcodec_name\fR is tha name of tha codec ta which
the preset file options is ghon be applied. Y'all KNOW dat shit, muthafucka! For example, if you select
the vizzle codec wit \f(CW\*(C`\-vcodec libvpx\*(C'\fR n' use \f(CW\*(C`\-vpre 1080p\*(C'\fR,
then it will search fo' tha file \fIlibvpx\-1080p.ffpreset\fR.
.SH "TIPS"
.IX Header "TIPS"
.IP "\(bu" 4
For streamin at straight-up low bitrates, bust a low frame rate
and a lil' small-ass \s-1GOP\s0 size. This is especially legit fo' RealVideo where
the Linux playa do not seem ta be straight-up fast, so it can miss
frames fo' realz. An example is:
.Sp
.Vb 1
\&        ffmpeg \-g 3 \-r 3 \-t 10 \-b:v 50k \-s qcif \-f rv10 /tmp/b.rm
.Ve
.IP "\(bu" 4
Da parameta 'q' which is displayed while encodin is tha current
quantizer n' shit. Da value 1 indicates dat a straight-up phat qualitizzle could
be  bigged up . Y'all KNOW dat shit, muthafucka! Da value 31 indicates da most thugged-out shitty quality. If q=31 appears
too often, it means dat tha encoder cannot compress enough ta meet
your bitrate. Yo ass must either increase tha bitrate, decrease the
frame rate or decrease tha frame size.
.IP "\(bu" 4
If yo' computa aint fast enough, you can speed up the
compression all up in tha expense of tha compression ratio. Yo ass can use
\&'\-me zero' ta speed up motion estimation, n' '\-g 0' ta disable
motion estimation straight-up (you have only I\-frames, which means it
is bout as phat as \s-1JPEG\s0 compression).
.IP "\(bu" 4
To have straight-up low audio bitrates, reduce tha samplin frequency
(down ta 22050 Hz fo' \s-1MPEG\s0 audio, 22050 or 11025 fo' \s-1AC\-3\s0).
.IP "\(bu" 4
To gotz a cold-ass lil constant qualitizzle (but a variable bitrate), use tha option
\&'\-qscale n' when 'n' is between 1 (pimpin quality) n' 31 (worst
quality).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Preset files"
.IX Subsection "Preset files"
A preset file gotz nuff a sequence of \fIoption=value\fR pairs, one for
each line, specifyin a sequence of options which can be specified also on
the command line. Lines startin wit tha hash ('#') characta is ignored and
are used ta provide comments, n' you can put dat on yo' toast. Empty lines is also ignored. Y'all KNOW dat shit, muthafucka! Peep the
\&\fIpresets\fR directory up in tha FFmpeg source tree fo' examples.
.PP
Preset filez is specified wit tha \f(CW\*(C`pre\*(C'\fR option, dis option takes a
preset name as input.  FFmpeg searches fo' a gangbangin' file named \fIpreset_name\fR.avpreset in
the directories \fI\f(CI$AVCONV_DATADIR\fI\fR (if set), n' \fI\f(CI$HOME\fI/.ffmpeg\fR, n' in
the data directory defined at configuration time (usually \fI\f(CI$PREFIX\fI/share/ffmpeg\fR)
in dat order n' shit.  For example, if tha argument is \f(CW\*(C`libx264\-max\*(C'\fR, it will
search fo' tha file \fIlibx264\-max.avpreset\fR.
.SS "Video n' Audio grabbing"
.IX Subsection "Video n' Audio grabbing"
If you specify tha input format n' thang then ffmpeg can grab vizzle
and audio directly.
.PP
.Vb 1
\&        ffmpeg \-f oss \-i /dev/dsp \-f vizzle4linux2 \-i /dev/video0 /tmp/out.mpg
.Ve
.PP
Or wit a \s-1ALSA\s0 audio source (mono input, card id 1) instead of \s-1OSS:\s0
.PP
.Vb 1
\&        ffmpeg \-f alsa \-ac 1 \-i hw:1 \-f vizzle4linux2 \-i /dev/video0 /tmp/out.mpg
.Ve
.PP
Note dat you must activate tha right vizzle source n' channel before
launchin ffmpeg wit any \s-1TV\s0 viewer such as
<\fBhttp://linux.bytesex.org/xawtv/\fR> by Gerd Knorr. Shiiit, dis aint no joke. Yo ass also
have ta set tha audio recordin levels erectly wit a
standard mixer.
.SS "X11 grabbing"
.IX Subsection "X11 grabbing"
Grab tha X11 display wit ffmpeg via
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-video_size cif \-framerate 25 \-i :0.0 /tmp/out.mpg
.Ve
.PP
0.0 is display.screen number of yo' X11 server, same as
the \s-1DISPLAY\s0 environment variable.
.PP
.Vb 1
\&        ffmpeg \-f x11grab \-video_size cif \-framerate 25 \-i :0.0+10,20 /tmp/out.mpg
.Ve
.PP
0.0 is display.screen number of yo' X11 server, same as tha \s-1DISPLAY\s0 environment
variable. 10 is tha x\-offset n' 20 tha y\-offset fo' tha grabbing.
.SS "Video n' Audio file format conversion"
.IX Subsection "Video n' Audio file format conversion"
Any supported file format n' protocol can serve as input ta ffmpeg:
.PP
Examples:
.IP "\(bu" 4
Yo ass can use \s-1YUV\s0 filez as input:
.Sp
.Vb 1
\&        ffmpeg \-i /tmp/test%d.Y /tmp/out.mpg
.Ve
.Sp
It will use tha files:
.Sp
.Vb 2
\&        /tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,
\&        /tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...
.Ve
.Sp
Da Y filez use twice tha resolution of tha U n' V files. They are
raw files, without header n' shit. They can be generated by all decent vizzle
decoders. Yo ass must specify tha size of tha image wit tha \fB\-s\fR option
if ffmpeg cannot guess dat shit.
.IP "\(bu" 4
Yo ass can input from a raw \s-1YUV420P\s0 file:
.Sp
.Vb 1
\&        ffmpeg \-i /tmp/test.yuv /tmp/out.avi
.Ve
.Sp
test.yuv be a gangbangin' file containin raw \s-1YUV\s0 planar data. Each frame is composed
of tha Y plane followed by tha U n' V planes at half vertical and
horizontal resolution.
.IP "\(bu" 4
Yo ass can output ta a raw \s-1YUV420P\s0 file:
.Sp
.Vb 1
\&        ffmpeg \-i mydivx.avi hugefile.yuv
.Ve
.IP "\(bu" 4
Yo ass can set nuff muthafuckin input filez n' output files:
.Sp
.Vb 1
\&        ffmpeg \-i /tmp/a.wav \-s 640x480 \-i /tmp/a.yuv /tmp/a.mpg
.Ve
.Sp
Converts tha audio file a.wav n' tha raw \s-1YUV\s0 vizzle file a.yuv
to \s-1MPEG\s0 file a.mpg.
.IP "\(bu" 4
Yo ass can also do audio n' vizzle conversions all up in tha same time:
.Sp
.Vb 1
\&        ffmpeg \-i /tmp/a.wav \-ar 22050 /tmp/a.mp2
.Ve
.Sp
Converts a.wav ta \s-1MPEG\s0 audio at 22050 Hz sample rate.
.IP "\(bu" 4
Yo ass can encode ta nuff muthafuckin formats all up in tha same time n' define a
mappin from input stream ta output streams:
.Sp
.Vb 1
\&        ffmpeg \-i /tmp/a.wav \-map 0:a \-b:a 64k /tmp/a.mp2 \-map 0:a \-b:a 128k /tmp/b.mp2
.Ve
.Sp
Converts a.wav ta a.mp2 at 64 kbits n' ta b.mp2 at 128 kbits, n' you can put dat on yo' toast. '\-map
file:index' specifies which input stream is used fo' each output
stream, up in tha order of tha definizzle of output streams.
.IP "\(bu" 4
Yo ass can transcode decrypted VOBs:
.Sp
.Vb 1
\&        ffmpeg \-i snatch_1.vob \-f avi \-c:v mpeg4 \-b:v 800k \-g 300 \-bf 2 \-c:a libmp3lame \-b:a 128k snatch.avi
.Ve
.Sp
This be a typical \s-1DVD\s0 rippin example; tha input be a \s-1VOB\s0 file, the
output a \s-1AVI\s0 file wit \s-1MPEG\-4\s0 vizzle n' \s-1MP3\s0 audio. Note dat up in this
command we use B\-frames so tha \s-1MPEG\-4\s0 stream is DivX5 compatible, and
\&\s-1GOP\s0 size is 300 which means one intra frame every last muthafuckin 10 secondz fo' 29.97fps
input vizzle. Furthermore, tha audio stream is MP3\-encoded so you need
to enable \s-1LAME\s0 support by passin \f(CW\*(C`\-\-enable\-libmp3lame\*(C'\fR ta configure.
Da mappin is particularly useful fo' \s-1DVD\s0 transcoding
to git tha desired audio language.
.Sp
\&\s-1NOTE:\s0 To peep tha supported input formats, use \f(CW\*(C`ffmpeg \-formats\*(C'\fR.
.IP "\(bu" 4
Yo ass can extract images from a vizzle, or create a vizzle from nuff images:
.Sp
For extractin images from a vizzle:
.Sp
.Vb 1
\&        ffmpeg \-i foo.avi \-r 1 \-s WxH \-f image2 foo\-%03d.jpeg
.Ve
.Sp
This will extract one vizzle frame per second from tha vizzle n' will
output dem up in filez named \fIfoo\-001.jpeg\fR, \fIfoo\-002.jpeg\fR,
etc. Images is ghon be rescaled ta fit tha freshly smoked up WxH joints.
.Sp
If you wanna extract just a limited number of frames, you can use the
above command up in combination wit tha \-vframes or \-t option, or in
combination wit \-ss ta start extractin from a cold-ass lil certain point up in time.
.Sp
For bustin a vizzle from nuff images:
.Sp
.Vb 1
\&        ffmpeg \-f image2 \-i foo\-%03d.jpeg \-r 12 \-s WxH foo.avi
.Ve
.Sp
Da syntax \f(CW\*(C`foo\-%03d.jpeg\*(C'\fR specifies ta bust a thugged-out decimal number
composed of three digits padded wit zeroes ta express tha sequence
number n' shit. Well shiiiit, it is tha same ol' dirty syntax supported by tha C printf function yo, but
only formats acceptin a aiiight integer is suitable.
.Sp
When importin a image sequence, \-i also supports expanding
shell-like wildcard patterns (globbing) internally, by selectin the
image2\-specific \f(CW\*(C`\-pattern_type glob\*(C'\fR option.
.Sp
For example, fo' bustin a vizzle from filenames matchin tha glob pattern
\&\f(CW\*(C`foo\-*.jpeg\*(C'\fR:
.Sp
.Vb 1
\&        ffmpeg \-f image2 \-pattern_type glob \-i \*(Aqfoo\-*.jpeg\*(Aq \-r 12 \-s WxH foo.avi
.Ve
.IP "\(bu" 4
Yo ass can put nuff streamz of tha same type up in tha output:
.Sp
.Vb 1
\&        ffmpeg \-i test1.avi \-i test2.avi \-map 0:3 \-map 0:2 \-map 0:1 \-map 0:0 \-c copy test12.nut
.Ve
.Sp
Da resultin output file \fItest12.avi\fR will contain first four streams from
the input file up in reverse order.
.IP "\(bu" 4
To force \s-1CBR\s0 vizzle output:
.Sp
.Vb 1
\&        ffmpeg \-i myfile.avi \-b 4000k \-minrate 4000k \-maxrate 4000k \-bufsize 1835k out.m2v
.Ve
.IP "\(bu" 4
Da four options lmin, lmax, mblmin n' mblmax use 'lambda' units,
but you may use tha \s-1QP2LAMBDA\s0 constant ta easily convert from 'q' units:
.Sp
.Vb 1
\&        ffmpeg \-i src.ext \-lmax 21*QP2LAMBDA dst.ext
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\-all\fR\|(1),
\&\fIffplay\fR\|(1), \fIffprobe\fR\|(1), \fIffserver\fR\|(1),
\&\fIffmpeg\-utils\fR\|(1), \fIffmpeg\-scaler\fR\|(1), \fIffmpeg\-resampler\fR\|(1),
\&\fIffmpeg\-codecs\fR\|(1), \fIffmpeg\-bitstream\-filters\fR\|(1), \fIffmpeg\-formats\fR\|(1),
\&\fIffmpeg\-devices\fR\|(1), \fIffmpeg\-protocols\fR\|(1), \fIffmpeg\-filters\fR\|(1)
.SH "AUTHORS"
.IX Header "AUTHORS"
Da FFmpeg pimpers.
.PP
For details bout tha authorship, peep tha Git history of tha project
(git://source.ffmpeg.org/ffmpeg), e.g. by typin tha command
\&\fBgit log\fR up in tha FFmpeg source directory, or browsin the
online repository at <\fBhttp://source.ffmpeg.org\fR>.
.PP
Maintainers fo' tha specific components is listed up in tha file
\&\fI\s-1MAINTAINERS\s0\fR up in tha source code tree.
