.TH "ZSHCOMPCTL" "1" "October 7, 2014" "zsh 5\&.0\&.7"
.SH "NAME"
zshcompctl \- zsh programmable completion
.\" Yodl file: Zsh/compctl.yo
.SH "DESCRIPTION"
This version of zsh has two wayz of struttin completion of lyrics on the
command line\&.  New playaz of tha shell may prefer ta use tha newer
and mo' bangin system based on shell functions; dis is busted lyrics bout in
\fIzshcompsys\fP(1), n' tha basic shell mechanizzlez which support it are
busted lyrics bout up in \fIzshcompwid\fP(1)\&.  This manual entry raps bout tha older
\fBcompctl\fP command\&.
.PD 0
.TP
\fBcompctl\fP [ \fB\-CDT\fP ] \fIoptions\fP [ \fIcommand\fP \&.\&.\&. ]
.TP
\fBcompctl\fP [ \fB\-CDT\fP ] \fIoptions\fP [ \fB\-x\fP \fIpattern\fP \fIoptions\fP \fB\-\fP \&.\&.\&. \fB\-\fP\fB\-\fP ] [ \fB+\fP \fIoptions\fP [ \fB\-x\fP \&.\&.\&. \fB\-\fP\fB\-\fP ] \&.\&.\&. [\fB+\fP] ] [ \fIcommand\fP \&.\&.\&. ]
.TP
\fBcompctl\fP \fB\-M\fP \fImatch\-specs\fP \&.\&.\&.
.TP
\fBcompctl\fP \fB\-L\fP [ \fB\-CDTM\fP ] [ \fIcommand\fP \&.\&.\&. ]
.TP
\fBcompctl\fP \fB+\fP \fIcommand\fP \&.\&.\&.
.PD
.PP
Control tha editor\&z completion behavior accordin ta tha supplied set
of \fIoptions\fP\&.  Various editin commands, notably
\fBexpand\-or\-complete\-word\fP, probably bound ta tab, will
attempt ta complete a word typed by tha user, while others, notably
\fBdelete\-char\-or\-list\fP, probably bound ta ^D up in EMACS editing
mode, list tha possibilities; \fBcompctl\fP controls what tha fuck them
possibilitizzles are\&.  They may fo' example be filenames (da most thugged-out common
case, n' hence tha default), shell variables, or lyrics from a
user\-specified list\&.
.PP
.SH "COMMAND FLAGS"
Completion of tha argumentz of a cold-ass lil command may be different fo' each
command or may use tha default\&.  Da behavior when completin the
command word itself may also be separately specified\&.  These
correspond ta tha followin flags n' arguments, all of which (except
for \fB\-L\fP) may be combined wit any combination of the
\fIoptions\fP busted lyrics bout subsequently up in tha section `Option Flags\&':
.PP
.PD 0
.TP
.PD
\fIcommand\fP \&.\&.\&.
controls completion fo' tha named commands, which must be listed last
on tha command line\&.  If completion be attempted fo' a cold-ass lil command wit a
pathname containin slashes n' no completion definizzle is found, the
search is retried wit tha last pathname component\&. If tha command starts
with a \fB=\fP, completion is tried wit tha pathname of tha command\&.
.RS
.PP
Any of tha \fIcommand\fP strings may be patternz of tha form normally
used fo' filename generation\&.  These should be quoted ta protect them
from immediate expansion; fo' example tha command strang \fB\&'foo*'\fP
arranges fo' completion of tha lyrics of any command beginnin with
\fBfoo\fP\&.  When completion be attempted, all pattern completions are
tried up in tha reverse order of they definizzle until one matches\&.  By
default, completion then proceedz as normal, i\&.e\&. tha shell will try to
generate mo' matches fo' tha specific command on tha command line; this
can be overridden by includin \fB\-tn\fP up in tha flags fo' tha pattern
completion\&.
.PP
Note dat aliases
are expanded before tha command name is determined unless the
\fBCOMPLETE_ALIASES\fP option is set\&.  Commandz may not be combined
with tha \fB\-C\fP, \fB\-D\fP or \fB\-T\fP flags\&.
.RE
.TP
\fB\-C\fP
controls completion when tha command word itself is bein completed\&.
If no \fBcompctl \-C\fP command has been issued,  tha namez of any
executable command (whether up in tha path or specific ta tha shell, such
as aliases or functions) is completed\&.
.TP
\fB\-D\fP
controls default completion behavior fo' tha argumentz of commandz not
assigned any special behavior\&.  If no \fBcompctl \-D\fP command has
been issued, filenames is completed\&.
.TP
\fB\-T\fP
supplies completion flags ta be used before any other processin is
done, even before processin fo' \fBcompctl\fPs defined fo' specific
commands\&.  This is especially useful when combined wit extended
completion (the \fB\-x\fP flag, peep tha section `Extended Completion\&' below)\&.
Usin dis flag you can define default behavior
which will apply ta all commandz without exception, or you can alter
the standard behavior fo' all commands\&.  For example, if yo' access
to tha user database is too slow and/or it gotz nuff too nuff playas (so
that completion afta `\fB~\fP\&' is too slow ta be usable), you can use
.RS
.PP
.RS
.nf
\fBcompctl \-T \-x \&'s[~] C[0,[^/]#]' \-k playaz \-S/ \-tn\fP
.fi
.RE
.PP
to complete tha strings up in tha array \fBfriends\fP afta a `\fB~\fP\&'\&.
Da \fBC[\&.\&.\&.]\fP argument is necessary so dat dis form of ~\-completion is
not tried afta tha directory name is finished\&.
.RE
.TP
\fB\-L\fP
lists tha existin completion behavior up in a manner suitable for
puttin tha fuck into a start\-up script; tha existin behavior aint chizzled\&.
Any combination of tha above forms, or tha \fB\-M\fP flag (which must
follow tha \fB\-L\fP flag), may be specified, otherwise all defined
completions is listed\&.  Any other flags supplied is ignored\&.
.TP
\fIno argument\fP
If no argument is given, \fBcompctl\fP lists all defined completions
in a abbreviated form;  wit a list of \fIoptions\fP, all completions
with dem flags set (not countin extended completion) is listed\&.
.PP
If tha \fB+\fP flag is ridin' solo n' followed immediately by tha \fIcommand\fP
list, tha completion behavior fo' all tha commandz up in tha list is reset to
the default\&.  In other lyrics, completion will subsequently use the
options specified by tha \fB\-D\fP flag\&.
.PP
Da form wit \fB\-M\fP as tha straight-up original gangsta n' only option defines global
matchin justifications (see
zshcompwid)\&. Da match justifications given is ghon be used fo' every last muthafuckin completion
attempt (only when rockin \fBcompctl\fP, not wit tha freshly smoked up completion
system) n' is tried up in tha order up in which they is defined until one 
generates at least one match\&. E\&.g\&.:
.PP
.RS
.nf
\fBcompctl \-M \&'' 'm:{a\-zA\-Z}={A\-Za\-z}'\fP
.fi
.RE
.PP
This will first try completion without any global match justifications 
(the empty string) and, if dat generates no matches, will try case
insensitizzle completion\&.
.PP
.SH "OPTION FLAGS"
.PD 0
.TP
[ \fB\-fcFBdeaRGovNAIOPZEnbjrzu/12\fP ]
.TP
[ \fB\-k\fP \fIarray\fP ] [ \fB\-g\fP \fIglobstring\fP ] [ \fB\-s\fP \fIsubststring\fP ]
.TP
[ \fB\-K\fP \fIfunction\fP ]
.TP
[ \fB\-Q\fP ] [ \fB\-P\fP \fIprefix\fP ] [ \fB\-S\fP \fIsuffix\fP ]
.TP
[ \fB\-W\fP \fIfile\-prefix\fP ] [ \fB\-H\fP \fInum pattern\fP ]
.TP
[ \fB\-q\fP ] [ \fB\-X\fP \fIexplanation\fP ] [ \fB\-Y\fP \fIexplanation\fP ]
.TP
[ \fB\-y\fP \fIfunc\-or\-var\fP ] [ \fB\-l\fP \fIcmd\fP ] [ \fB\-h\fP \fIcmd\fP ] [ \fB\-U\fP ]
.TP
[ \fB\-t\fP \fIcontinue\fP ] [ \fB\-J\fP \fIname\fP ] [ \fB\-V\fP \fIname\fP ]
.TP
[ \fB\-M\fP \fImatch\-spec\fP ]
.PD
.PP
Da remainin \fIoptions\fP specify tha type of command arguments
to look fo' durin completion\&.  Any combination of these flags may be
specified; tha result be a sorted list of all tha possibilities\&.  The
options is as bigs up\&.
.PP
.SS "Simple Flags"
These produce completion lists made up by tha shell itself:
.PP
.PD 0
.TP
.PD
\fB\-f\fP
Filenames n' file system paths\&.
.TP
\fB\-/\fP
Just file system paths\&.
.TP
\fB\-c\fP
Command names, includin aliases, shell functions, builtins
and reserved lyrics\&.
.TP
\fB\-F\fP
Function names\&.
.TP
\fB\-B\fP
Namez of builtin commands\&.
.TP
\fB\-m\fP
Namez of external commands\&.
.TP
\fB\-w\fP
Reserved lyrics\&.
.TP
\fB\-a\fP
Alias names\&.
.TP
\fB\-R\fP
Namez of regular (non\-global) aliases\&.
.TP
\fB\-G\fP
Namez of global aliases\&.
.TP
\fB\-d\fP
This can be combined wit \fB\-F\fP, \fB\-B\fP, \fB\-w\fP,
\fB\-a\fP, \fB\-R\fP n' \fB\-G\fP ta git namez of disabled
functions, builtins, reserved lyrics or aliases\&.
.TP
\fB\-e\fP
This option (to show enabled commands) is up in effect by default yo, but
may be combined wit \fB\-d\fP; \fB\-de\fP up in combination with
\fB\-F\fP, \fB\-B\fP, \fB\-w\fP, \fB\-a\fP, \fB\-R\fP n' \fB\-G\fP
will complete namez of functions, builtins, reserved lyrics or aliases
whether or not they is disabled\&.
.TP
\fB\-o\fP
Namez of shell options (see
\fIzshoptions\fP(1))\&.
.TP
\fB\-v\fP
Namez of any variable defined up in tha shell\&.
.TP
\fB\-N\fP
Namez of scalar (non\-array) parameters\&.
.TP
\fB\-A\fP
Array names\&.
.TP
\fB\-I\fP
Namez of integer variables\&.
.TP
\fB\-O\fP
Namez of read\-only variables\&.
.TP
\fB\-p\fP
Namez of parametas used by tha shell (includin special parameters)\&.
.TP
\fB\-Z\fP
Namez of shell special parameters\&.
.TP
\fB\-E\fP
Namez of environment variables\&.
.TP
\fB\-n\fP
Named directories\&.
.TP
\fB\-b\fP
Key bindin names\&.
.TP
\fB\-j\fP
Thang names:  tha straight-up original gangsta word of tha thang leader\&z command line\&.  This is useful
with tha \fBkill\fP builtin\&.
.TP
\fB\-r\fP
Namez of hustlin thangs\&.
.TP
\fB\-z\fP
Namez of suspended thangs\&.
.TP
\fB\-u\fP
User names\&.
.PP
.SS "Flags wit Arguments"
These have user supplied arguments ta determine how tha fuck tha list of
completions is ta be made up:
.PP
.PD 0
.TP
.PD
\fB\-k\fP \fIarray\fP
Names taken from tha elementz of \fB$\fP\fIarray\fP (note dat tha `\fB$\fP\&'
does not step tha fuck up on tha command line)\&.
Alternatively, tha argument \fIarray\fP itself may be a set
of space\- or comma\-separated joints up in parentheses, up in which any
delimita may be escaped wit a funky-ass backslash; up in dis case tha argument
should be quoted\&.  For example,
.RS
.PP
.RS
.nf
\fBcompctl \-k "(cputime filesize datasize stacksize
	       coredumpsize resident descriptors)" limit\fP
.fi
.RE
.RE
.TP
\fB\-g\fP \fIglobstring\fP
Da \fIglobstring\fP is expanded rockin filename globbing; it should be
quoted ta protect it from immediate expansion\&. Da resulting
filenames is taken as tha possible completions\&.  Use `\fB*(/)\fP\&' instead of
`\fB*/\fP\&' fo' directories\&.  Da \fBfignore\fP special parameta is not
applied ta tha resultin files\&.  Mo' than one pattern may be given
separated by blanks\&. (Note dat brace expansion is \fInot\fP part of
globbing\&.  Use tha syntax `\fB(either|or)\fP\&' ta match alternatives\&.)
.TP
\fB\-s\fP \fIsubststring\fP
Da \fIsubststring\fP is split tha fuck into lyrics n' these lyrics is than
expanded rockin all shell expansion mechanizzlez (see
\fIzshexpn\fP(1))\&.  Da resultin lyrics is taken as possible
completions\&.  Da \fBfignore\fP special parameta aint applied ta the
resultin files\&.  Note dat \fB\-g\fP is fasta fo' filenames\&.
.TP
\fB\-K\fP \fIfunction\fP
Call tha given function ta git tha completions\&.  Unless tha name
starts wit a underscore, tha function is
passed two arguments: tha prefix n' tha suffix of tha word on which
completion is ta be attempted, up in other lyrics dem charactas before
the cursor position, n' dem from tha cursor posizzle onwards\&.  The
whole command line can be accessed wit tha \fB\-c\fP n' \fB\-l\fP flags
of tha \fBread\fP builtin\&. The
function should set tha variable \fBreply\fP ta a array containing
the completions (one completion per element); note dat \fBreply\fP
should not be made local ta tha function\&.  From such a gangbangin' function the
command line can be accessed wit tha \fB\-c\fP n' \fB\-l\fP flags to
the \fBread\fP builtin\&.  For example,
.RS
.PP
.RS
.nf
\fBfunction whoson { reply=(`users`); }
compctl \-K whoson talk\fP
.fi
.RE
.PP
completes only logged\-on playas afta `\fBtalk\fP\&'\&.  Note dat `\fBwhoson\fP' must
return a array, so `\fBreply=`users`\fP\&' would be incorrect\&.
.RE
.TP
\fB\-H\fP \fInum pattern\fP
Da possible completions is taken from tha last \fInum\fP history
lines\&.  Only lyrics matchin \fIpattern\fP is taken\&.  If \fInum\fP is
zero or wack tha whole history is searched n' if \fIpattern\fP is
the empty strang all lyrics is taken (as wit `\fB*\fP\&')\&.  A typical
use is
.RS
.PP
.RS
.nf
\fBcompctl \-D \-f + \-H 0 \&''\fP
.fi
.RE
.PP
which forces completion ta look back up in tha history list fo' a word if
no filename matches\&.
.RE
.PP
.SS "Control Flags"
These do not directly specify typez of name ta be completed yo, but
manipulate tha options dat do:
.PP
.PD 0
.TP
.PD
\fB\-Q\fP
This instructs tha shell not ta quote any metacharactas up in tha possible
completions\&.  Normally tha thangs up in dis biatch of a cold-ass lil completion is banged into
the command line wit any metacharactas quoted so dat they are
interpreted as aiiight characters\&.  This be appropriate fo' filenames
and ordinary strings\&.  But fuck dat shiznit yo, tha word on tha street is dat fo' special effects, like fuckin inserting
a backquoted expression from a cold-ass lil completion array (\fB\-k\fP) so that
the expression aint gonna be evaluated until tha complete line is
executed, dis option must be used\&.
.TP
\fB\-P\fP \fIprefix\fP
Da \fIprefix\fP is banged just before tha completed string; any
initial part already typed is ghon be completed n' tha whole \fIprefix\fP
ignored fo' completion purposes\&.  For example,
.RS
.PP
.RS
.nf
\fBcompctl \-j \-P "%" kill\fP
.fi
.RE
.PP
inserts a `%\&' afta tha bust a cap up in command n' then completes thang names\&.
.RE
.TP
\fB\-S\fP \fIsuffix\fP
When a cold-ass lil completion is found tha \fIsuffix\fP is banged after
the completed string\&.  In tha case of menu completion tha suffix is
inserted immediately yo, but it is still possible ta cycle all up in the
list of completions by repeatedly hittin tha same key\&.
.TP
\fB\-W\fP \fIfile\-prefix\fP
With directory \fIfile\-prefix\fP:  fo' command, file, directory and
globbin completion (options \fB\-c\fP, \fB\-f\fP, \fB\-/\fP, \fB\-g\fP), tha file
prefix is implicitly added up in front of tha completion\&.  For example,
.RS
.PP
.RS
.nf
\fBcompctl \-/ \-W ~/Mail maildirs\fP
.fi
.RE
.PP
completes any subdirectories ta any depth beneath tha directory
\fB~/Mail\fP, although dat prefix do not step tha fuck up on tha command line\&.
Da \fIfile\-prefix\fP may also be of tha form accepted by tha \fB\-k\fP
flag, i\&.e\&. tha name of a array or a literal list up in parenthesis\&. In
this case all tha directories up in tha list is ghon be searched for
possible completions\&.
.RE
.TP
\fB\-q\fP
If used wit a suffix as specified by tha \fB\-S\fP option, this
causes tha suffix ta be removed if tha next characta typed be a funky-ass blank
or do not bang anythang or if tha suffix consistz of only one character
and tha next characta typed is tha same ol' dirty character; dis tha same ol' dirty rule used
for tha \fBAUTO_REMOVE_SLASH\fP option\&.  Da option is most useful fo' list
separators (comma, colon, etc\&.)\&.
.TP
\fB\-l\fP \fIcmd\fP
This option restricts tha range
of command line lyrics dat is considered ta be arguments\&.  If
combined wit one of tha extended completion patterns `\fBp[\fP\&.\&.\&.\fB]\fP\&',
`\fBr[\fP\&.\&.\&.\fB]\fP\&', or `\fBR[\fP\&.\&.\&.\fB]\fP'  (see tha section `Extended Completion'
below) tha range is restricted ta tha range of arguments
specified up in tha brackets\&.  Completion is then performed as if these
had been given as arguments ta tha \fIcmd\fP supplied wit the
option\&. If tha \fIcmd\fP strang is empty tha straight-up original gangsta word up in tha range
is instead taken as tha command name, n' command name completion
performed on tha straight-up original gangsta word up in tha range\&.  For example,
.RS
.PP
.RS
.nf
\fBcompctl \-x \&'r[\-exec,;]' \-l '' \-\- find\fP
.fi
.RE
.PP
completes arguments between `\fB\-exec\fP\&' n' tha followin `\fB;\fP' (or tha end
of tha command line if there is no such string) as if they were
a separate command line\&.
.RE
.TP
\fB\-h\fP \fIcmd\fP
Normally zsh completes quoted strings as a whole\&. With dis option,
completion can be done separately on different partz of such
strings\&. Well shiiiit, it works like tha \fB\-l\fP option but make tha completion code 
work on tha partz of tha current word dat is separated by
spaces\&. These parts is completed as if they was arguments ta the
given \fIcmd\fP\&. If \fIcmd\fP is tha empty string, tha straight-up original gangsta part is
completed as a cold-ass lil command name, as wit \fB\-l\fP\&.
.TP
\fB\-U\fP
Use tha whole list of possible completions, whether or not they
actually match tha word on tha command line\&.  Da word typed so far
will be deleted\&.  This is most useful wit a gangbangin' function (given by the
\fB\-K\fP option) which can examine tha word components passed ta it
(or via tha \fBread\fP builtin\&z \fB\-c\fP n' \fB\-l\fP flags) and
use its own criteria ta decizzle what tha fuck matches\&.  If there is no
completion, tha original gangsta word is retained\&.  Since tha produced 
possible completions seldom have bangin-ass common prefixes
and suffixes, menu completion is started immediately if \fBAUTO_MENU\fP is
set n' dis flag is used\&.
.TP
\fB\-y\fP \fIfunc\-or\-var\fP
Da list provided by \fIfunc\-or\-var\fP is displayed instead of tha list
of completions whenever a listin is required; tha actual completions
to be banged is not affected\&.  It can be provided up in two
ways\&. Firstly, if \fIfunc\-or\-var\fP begins wit a \fB$\fP it defines a
variable, or if it begins wit a left parenthesis a literal
array, which gotz nuff tha list\&.  A variable may done been set by a
call ta a gangbangin' function rockin tha \fB\-K\fP option\&.  Otherwise it gotz nuff the
name of a gangbangin' function which is ghon be executed ta create tha list\&.  The
function is ghon be passed as a argument list all matchin completions,
includin prefixes n' suffixes expanded up in full, n' should set the
array \fBreply\fP ta tha result\&.  In both cases, tha display list will
only be retrieved afta a cold-ass lil complete list of matches has been pimped\&.
.RS
.PP
Note dat tha returned list do not gotta correspond, even in
length, ta tha original gangsta set of matches, n' may be passed as a scalar
instead of a array\&.  No special formattin of charactas is
performed on tha output up in dis case; up in particular, newlines are
printed literally n' if they step tha fuck up output up in columns is suppressed\&.
.RE
.TP
\fB\-X\fP \fIexplanation\fP
Print \fIexplanation\fP when tryin completion on tha current set of
options\& fo' realz. A `\fB%n\fP\&' up in dis strang is replaced by tha number of
matches dat was added fo' dis explanation string\&.
Da explanation only appears if completion was tried n' there was
no unique match, or when listin completions\&. Explanation strings 
will be listed together wit tha matchez of tha crew specified
together wit tha \fB\-X\fP option (usin tha \fB\-J\fP or \fB\-V\fP
option)\&. If tha same explanation strang is given ta multiple \fB\-X\fP
options, tha strang appears only once (for each group) n' tha number
of matches shown fo' tha `\fB%n\fP\&' is tha total number of all matches
for each of these uses\&. In any case, tha explanation strang will only
be shown if there was at least one match added fo' tha explanation
string\&.
.RS
.PP
Da sequences \fB%B\fP, \fB%b\fP, \fB%S\fP, \fB%s\fP, \fB%U\fP, n' \fB%u\fP specify
output attributes (bold, standout, n' underline), \fB%F\fP, \fB%f\fP, \fB%K\fP,
\fB%k\fP specify foreground n' background colours, n' \fB%{\&.\&.\&.%}\fP can
be used ta include literal escape sequences as up in prompts\&.
.RE
.TP
\fB\-Y\fP \fIexplanation\fP
Identical ta \fB\-X\fP, except dat tha \fIexplanation\fP first undergoes
expansion followin tha usual rulez fo' strings up in double quotes\&.
Da expansion is ghon be carried up afta any functions is called for
the \fB\-K\fP or \fB\-y\fP options, allowin dem ta set variables\&.
.TP
\fB\-t\fP \fIcontinue\fP
Da \fIcontinue\fP\-strin gotz nuff a cold-ass lil characta dat specifies which set
of completion flags should be used next\&.  It be useful:
.RS
.PP
(i) With \fB\-T\fP, or when tryin a list of pattern completions, when
\fBcompctl\fP would probably continue wit ordinary processin after
findin matches; dis can be suppressed wit `\fB\-tn\fP\&'\&.
.PP
(ii) With a list of alternatives separated by \fB+\fP, when \fBcompctl\fP
would normally stop when one of tha alternatives generates matches\&.  It
can be forced ta consider tha next set of completions by addin `\fB\-t+\fP\&'
to tha flagz of tha alternatizzle before tha `\fB+\fP\&'\&.
.PP
(iii) In a extended completion list (see below), when \fBcompctl\fP would
normally continue until a set of conditions succeeded, then use only
the immediately followin flags\&.  With `\fB\-t\-\fP\&', \fBcompctl\fP will
continue tryin extended completions afta tha next `\fB\-\fP\&'; with
`\fB\-tx\fP\&' it will attempt completion wit tha default flags, up in other
wordz dem before tha `\fB\-x\fP\&'\&.
.RE
.TP
\fB\-J\fP \fIname\fP
This gives tha name of tha crew tha matches should be placed in\&. Groups
are listed n' sorted separately; likewise, menu completion will offer
the matches up in tha crews up in tha order up in which tha crews were
defined\&. If no crew name is explicitly given, tha matches is stored in
a crew named \fIdefault\fP\&. Da last time a crew name is encountered,
a crew wit dat name is pimped\& fo' realz. Afta dat all matches wit tha same
group name is stored up in dat group\&.
.RS
.PP
This can be useful wit non\-exclusive alternatizzle completions\&.  For
example, in
.PP
.RS
.nf
\fBcompctl \-f \-J filez \-t+ + \-v \-J variablez foo\fP
.fi
.RE
.PP
both filez n' variablez is possible completions, as tha \fB\-t+\fP forces
both setz of alternatives before n' afta tha \fB+\fP ta be considered at
once\&.  Because of tha \fB\-J\fP options, however, all filez is listed
before all variables\&.
.RE
.TP
\fB\-V\fP \fIname\fP
Like \fB\-J\fP yo, but matches within tha crew aint gonna be sorted up in listings
nor up in menu completion\&. These unsorted crews is up in a gangbangin' finger-lickin' different name
space from tha sorted ones, so crews defined as \fB\-J files\fP n' \fB\-V
files\fP is distinct\&.
.TP
\fB\-1\fP
If given together wit tha \fB\-V\fP option, makes
only consecutizzle duplicates up in tha crew be removed\&. Note dat groups
with n' without dis flag is up in different name spaces\&.
.TP
\fB\-2\fP
If given together wit tha \fB\-J\fP or \fB\-V\fP option, make all
duplicates be kept\& fo' realz. Again, crews wit n' without dis flag is in
different name spaces\&.
.TP
\fB\-M\fP \fImatch\-spec\fP
This defines additionizzle matchin control justifications dat should be used
only when testin lyrics fo' tha list of flags dis flag appears in\&. Da format
of tha \fImatch\-spec\fP strang is busted lyrics bout up in 
zshcompwid\&.
.PP
.SH "ALTERNATIVE COMPLETION"
.PD 0
.TP
\fBcompctl\fP [ \fB\-CDT\fP ] \fIoptions\fP \fB+\fP \fIoptions\fP [ \fB+\fP \&.\&.\&. ] [ \fB+\fP ] \fIcommand\fP \&.\&.\&.
.PD
.PP
Da form wit `\fB+\fP\&' specifies alternatizzle options\&. Completion is
tried wit tha options before tha straight-up original gangsta `\fB+\fP\&'\&. If dis produces no
matches completion is tried wit tha flags afta tha `\fB+\fP\&' n' so on\&. If
there is no flags afta tha last `\fB+\fP\&' n' a match has not been found
up ta dat point, default completion is tried\&.
If tha list of flags gotz nuff a \fB\-t\fP wit a \fB+\fP character, tha next
list of flags is used even if tha current list produced matches\&.
.PP
.PP
Additionizzle options is available dat restrict completion ta some part
of tha command line; dis is referred ta as `extended completion\&'\&.
.PP
.SH "EXTENDED COMPLETION"
.PD 0
.TP
\fBcompctl\fP [ \fB\-CDT\fP ] \fIoptions\fP \fB\-x\fP \fIpattern\fP \fIoptions\fP \fB\-\fP \&.\&.\&. \fB\-\fP\fB\-\fP
.TP
         [ \fIcommand\fP \&.\&.\&. ]
.TP
\fBcompctl\fP [ \fB\-CDT\fP ] \fIoptions\fP [ \fB\-x\fP \fIpattern\fP \fIoptions\fP \fB\-\fP \&.\&.\&. \fB\-\fP\fB\-\fP ]
.TP
         [ \fB+\fP \fIoptions\fP [ \fB\-x\fP \&.\&.\&. \fB\-\fP\fB\-\fP ] \&.\&.\&. [\fB+\fP] ] [ \fIcommand\fP \&.\&.\&. ]
.PD
.PP
Da form wit `\fB\-x\fP\&' specifies extended completion fo' the
commandz given; as shown, it may be combined wit alternative
completion rockin `\fB+\fP\&'\&.  Each \fIpattern\fP is examined up in turn; when a
match is found, tha correspondin \fIoptions\fP, as busted lyrics bout in
the section `Option Flags\&' above, is used ta generate possible
completions\&.  If no \fIpattern\fP matches, tha \fIoptions\fP given
before tha \fB\-x\fP is used\&.
.PP
Note dat each pattern should be supplied as a single argument and
should be quoted ta prevent expansion of metacharactas by the
shell\&.
.PP
A \fIpattern\fP is built of sub\-patterns separated by commas; it
matches if at least one of these sub\-patterns matches (they are
`or\&'ed)\&. These sub\-patterns is up in turn composed of other
sub\-patterns separated by white spaces which match if all of the
sub\-patterns match (they is `and\&'ed)\&.  An element of the
sub\-patterns iz of tha form `\fIc\fP\fB[\fP\&.\&.\&.\fB][\fP\&.\&.\&.\fB]\fP\&', where tha pairs of
brackets may be repeated as often as necessary, n' matches if any of
the setz of brackets match (an `or\&')\&.  Da example below make this
clearer\&.
.PP
Da elements may be any of tha following:
.PP
.PD 0
.TP
.PD
\fBs[\fP\fIstring\fP\fB]\fP\&.\&.\&.
Matches if tha current word on tha command line starts with
one of tha strings given up in brackets\&.  Da \fIstring\fP aint removed
and aint part of tha completion\&.
.TP
\fBS[\fP\fIstring\fP\fB]\fP\&.\&.\&.
Like \fBs[\fP\fIstring\fP\fB]\fP except dat tha \fIstring\fP is part of the
completion\&.
.TP
\fBp[\fP\fIfrom\fP\fB,\fP\fIto\fP\fB]\fP\&.\&.\&.
Matches if tha number of tha current word is between one of
the \fIfrom\fP n' \fIto\fP pairs inclusive\&. Da comma n' \fIto\fP
are optional; \fIto\fP defaults ta tha same value as \fIfrom\fP\&.  The
numbers may be negative: \fB\-\fP\fIn\fP refers ta tha \fIn\fP\&'th last word
on tha line\&.
.TP
\fBc[\fP\fIoffset\fP\fB,\fP\fIstring\fP\fB]\fP\&.\&.\&.
Matches if tha \fIstring\fP matches tha word offset by
\fIoffset\fP from tha current word position\&.  Usually \fIoffset\fP
will be negative\&.
.TP
\fBC[\fP\fIoffset\fP\fB,\fP\fIpattern\fP\fB]\fP\&.\&.\&.
Like \fBc\fP but rockin pattern matchin instead\&.
.TP
\fBw[\fP\fIindex\fP\fB,\fP\fIstring\fP\fB]\fP\&.\&.\&.
Matches if tha word up in posizzle \fIindex\fP is equal
to tha correspondin \fIstring\fP\&.  Note dat tha word count is made
afta any alias expansion\&.
.TP
\fBW[\fP\fIindex\fP\fB,\fP\fIpattern\fP\fB]\fP\&.\&.\&.
Like \fBw\fP but rockin pattern matchin instead\&.
.TP
\fBn[\fP\fIindex\fP\fB,\fP\fIstring\fP\fB]\fP\&.\&.\&.
Matches if tha current word gotz nuff \fIstring\fP\&.  Anythang up ta and
includin tha \fIindex\fPth occurrence of dis strang aint gonna be
considered part of tha completion yo, but tha rest will\&.  \fIindex\fP may
be wack ta count from tha end: up in most cases, \fIindex\fP will be
1 or \-1\&.  For example,
.RS
.PP
.RS
.nf
\fBcompctl \-s \&'`users`' \-x 'n[1,@]' \-k hosts \-\- talk\fP
.fi
.RE
.PP
will probably complete usernames yo, but if you bang a \fB@\fP afta the
name, names from tha array \fIhosts\fP (assumed ta contain hostnames,
though you must make tha array yo ass) is ghon be completed\&.  Other
commandz like fuckin \fBrcp\fP can be handled similarly\&.
.RE
.TP
\fBN[\fP\fIindex\fP\fB,\fP\fIstring\fP\fB]\fP\&.\&.\&.
Like \fBn\fP except dat tha strang will be
taken as a cold-ass lil characta class\&.  Anythang up ta n' includin the
\fIindex\fPth occurrence of any of tha charactas up in \fIstring\fP
will not be considered part of tha completion\&.
.TP
\fBm[\fP\fImin\fP\fB,\fP\fImax\fP\fB]\fP\&.\&.\&.
Matches if tha total number of lyrics lies between \fImin\fP and
\fImax\fP inclusive\&.
.TP
\fBr[\fP\fIstr1\fP\fB,\fP\fIstr2\fP\fB]\fP\&.\&.\&.
Matches if tha cursor be afta a word wit prefix \fIstr1\fP\&.  If there
is also a word wit prefix \fIstr2\fP on tha command line afta tha one 
matched by \fIstr1\fP it matches
only if tha cursor is before dis word\&. If tha comma n' \fIstr2\fP are
omitted, it matches if tha cursor be afta a word wit prefix \fIstr1\fP\&.
.TP
\fBR[\fP\fIstr1\fP\fB,\fP\fIstr2\fP\fB]\fP\&.\&.\&.
Like \fBr\fP but rockin pattern matchin instead\&.
.TP
\fBq[\fP\fIstr\fP\fB]\fP\&.\&.\&.
Matches tha word currently bein completed is up in single quotes n' tha 
\fIstr\fP begins wit tha letta `s\&', or if completion is done in
double quotes n' \fIstr\fP starts wit tha letta `d\&', or if
completion is done up in backticks n' \fIstr\fP starts wit a `b\&'\&.
.PP
.SH "EXAMPLE"
.PP
.RS
.nf
\fBcompctl \-u \-x \&'s[\fB+\fP] c[\-1,\-f],s[\-f+]' \e 
  \-g \&'~/Mail/*(:t)' \- 's[\-f],c[\-1,\-f]' \-f \-\- mail\fP
.fi
.RE
.PP
This is ta be interpreted as bigs up:
.PP
If tha current command is \fBmail\fP, then
.PP
.RS
.nf

if ((the current word begins wit \fB+\fP n' tha previous word is \fB\-f\fP)
or (the current word begins wit \fB\-f+\fP)), then complete the
non\-directory part (the `\fB:t\fP\&' glob modifier) of filez up in tha directory
\fB~/Mail\fP; else
.PP
if tha current word begins wit \fB\-f\fP or tha previous word was \fB\-f\fP, then
complete any file; else
.PP
complete user names\&.

.fi
.RE
