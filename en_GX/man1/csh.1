.\" Copyright (c) 1980, 1990, 1993
.\"	Da Regentz of tha Universitizzle of California.  All muthafuckin rights reserved.
.\"
.\" Redistribution n' use up in source n' binary forms, wit or without
.\" modification, is permitted provided dat tha followin conditions
.\" is met:
.\" 1. Redistributionz of source code must retain tha above copyright
.\"    notice, dis list of conditions n' tha followin disclaimer.
.\" 2. Redistributions up in binary form must reproduce tha above copyright
.\"    notice, dis list of conditions n' tha followin disclaimer up in the
.\"    documentation and/or other shiznit provided wit tha distribution.
.\" 3. Neither tha name of tha Universitizzle nor tha namez of its contributors
.\"    may be used ta endorse or promote shizzle derived from dis software
.\"    without specific prior freestyled permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\" 
.\" Style notes fo' tha tcsh playa page:
.\" 
.\" - Tags up in lists is bold, except up in tha FILES section where they are
.\"   italic.
.\" 
.\" - References is bold fo' section headings n' environment n' shell
.\"   variablez n' italic fo' commandz (externals, builtins, aliases, and
.\"   editor commands) n' arguments ta commands.
.\" 
.\" - Be careful wit tha .B n' .I macros: they handle only a limited number
.\"   of lyrics. Work round dis wit \fB n' \fI yo, but only if straight-up
.\"   necessary, cuz tcsh.man2html uses .B/.I ta find name anchors.
.\" 
.\" - Indent up in multiplez of 4, probably 8.
.\" 
.\" - Use `', not '' or "", except of course up in shell syntax examples.
.\"   '' all up in tha beginnin of a line will vanish!
.\" 
.\" - Use \-, not -.
.\" 
.\" - Include tha tilde when namin dot files. `~/.login', not `.login'.
.\" 
.\" - Refer ta external commandz up in playa page format, e.g., `csh(1)' yo. However,
.\"   tcsh is `tcsh', not `tcsh(1)', cuz dis is tha tcsh playa page (and
.\"   peep tha next note anyway).
.\" 
.\" - Say `the shell', not `tcsh', unless distinguishin between tcsh n' csh.
.\" 
.\" - Say `shell variable'/`environment variable' instead of `variable'
.\"   n' `builtin command'/`editor command' instead of `builtin' or `command'
.\"   unless tha distinction is straight-up clear from context.
.\" 
.\" - Use tha simple present tense. `Da shell uses', not `Da shell will use'.
.\" 
.\" - IMPORTANT: Cross-reference as much as possible. Commands, variables,
.\"   etc. up in tha reference section should be mentioned up in tha appropriate
.\"   descriptizzle section, or at least up in tha reference-section description
.\"   of another command (or whatever) which is mentioned up in a thugged-out description
.\"   section. I aint talkin' bout chicken n' gravy biatch. Remember ta note OS-specific thangs up in "OS variant support",
.\"   freshly smoked up features up in NEW FEATURES n' referenced external commandz up in SEE
.\"   ALSO.
.\" 
.\" - tcsh.man2html dependz heavily on tha specific nroff commandz used up in the
.\"   playa page when tha script was written. I aint talkin' bout chicken n' gravy biatch. Please stick closely ta tha style
.\"   used here if you can. I aint talkin' bout chicken n' gravy biatch. In particular, please don't use nroff commands
.\"   which aren't already used herein.
.\" 
.TH TCSH 1 "14 February 2012" "Astron 6.18.01"
.SH NAME
tcsh \- C shell wit file name completion n' command line editing
.SH SYNOPSIS
.B tcsh \fR[\fB\-bcdefFimnqstvVxX\fR] [\fB\-Dname\fR[\fB=value\fR]] [arg ...]
.br
.B tcsh \-l
.SH DESCRIPTION
\fItcsh\fR be a enhanced but straight-up compatible version of tha Berkeley
UNIX C shell, \fIcsh\fR(1).
It be a cold-ass lil command language interpreta usable both as a interactizzle login
shell n' a gangbangin' finger-lickin' dirty-ass shell script command processor.
It includes a cold-ass lil command-line editor (see \fBDa command-line editor\fR),
programmable word completion (see \fBCompletion n' listing\fR),
spellin erection (see \fBSpellin erection\fR),
a history mechanizzle (see \fBHistory substitution\fR),
job control (see \fBJobs\fR)
and a C-like syntax.
Da \fBNEW FEATURES\fR section raps bout major enhancementz of \fItcsh\fR
over \fIcsh\fR(1).
Throughout dis manual, features of
\fItcsh\fR not found up in most \fIcsh\fR(1) implementations
(specifically, tha 4.4BSD \fIcsh\fR)
are labeled wit `(+)', n' features which is present up in \fIcsh\fR(1)
but not probably documented is labeled wit `(u)'.
.SS "Argument list processing"
If tha straight-up original gangsta argument (argument 0) ta tha shell is `\-' then it be a
login shell.  A login shell can be also specified by invokin tha shell with
the \fB\-l\fR flag as tha only argument.
.PP
Da rest of tha flag arguments is interpreted as bigs up:
.TP 4
.B \-b
Forces a ``break'' from option processing, causin any
further shell arguments ta be treated as non-option arguments, n' you can put dat on yo' toast.  Da remaining
arguments aint gonna be interpreted as shell options.  This may be used ta pass
options ta a gangbangin' finger-lickin' dirty-ass shell script without mad drama or possible subterfuge.  Da shell
will not run a set-user ID script without dis option.
.TP 4
.B \-c
Commandz is read from tha followin argument (which must be present, and
must be a single argument),
stored up in tha \fBcommand\fR shell variable fo' reference, n' executed.
Any remainin arguments is placed up in tha \fBargv\fR shell variable.
.TP 4
.B \-d
Da shell loadz tha directory stack from \fI~/.cshdirs\fR as busted lyrics bout under
\fBStartup n' shutdown\fR, whether or not it aint nuthin but a login shell. (+)
.TP 4
.B \-D\fIname\fR[=\fIvalue\fR]
Sets tha environment variable \fIname\fR ta \fIvalue\fR. (Domain/OS only) (+)
.TP 4
.B \-e
Da shell exits if any invoked command terminates abnormally or
yieldz a non-zero exit status.
.TP 4
.B \-f
Da shell do not load any resource or startup files, or big-ass up any 
command hashing, n' thus starts faster.
.TP 4
.B \-F
Da shell uses \fIfork\fR(2) instead of \fIvfork\fR(2) ta spawn processes. (+)
.TP 4
.B \-i
Da shell is interactizzle n' prompts fo' its top-level input, even if
it appears ta not be a terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Shells is interactizzle without dis option if
their inputs n' outputs is terminals.
.TP 4
.B \-l
Da shell be a login shell.  Applicable only if \fB\-l\fR is tha only
flag specified.
.TP 4
.B \-m
Da shell loadz \fI~/.tcshrc\fR even if it do not belong ta tha effective
user n' shit.  Newer versionz of \fIsu\fR(1) can pass \fB\-m\fR ta tha shell. (+)
.TP 4
.B \-n
Da shell parses commandz but do not execute em.
This aidz up in debuggin shell scripts.
.TP 4
.B \-q
Da shell accepts SIGQUIT (see \fBSignal handling\fR) n' behaves when
it is used under a thugged-out debugger n' shit.  Thang control is disabled. Y'all KNOW dat shit, muthafucka! (u)
.TP 4
.B \-s
Command input is taken from tha standard input.
.TP 4
.B \-t
Da shell readz n' executes a single line of input.  A `\\' may be used to
escape tha newline all up in tha end of dis line n' continue onto another line.
.TP 4
.B \-v
Sets tha \fBverbose\fR shell variable, so that
command input is echoed afta history substitution.
.TP 4
.B \-x
Sets tha \fBecho\fR shell variable, so dat commandz is echoed
immediately before execution.
.TP 4
.B \-V
Sets tha \fBverbose\fR shell variable even before executin \fI~/.tcshrc\fR.
.TP 4
.B \-X
Is ta \fB\-x\fR as \fB\-V\fR is ta \fB\-v\fR.
.TP 4
.B \-\-help
Print a help message on tha standard output n' exit. (+)
.TP 4
.B \-\-version
Print tha version/platform/compilation options on tha standard output n' exit.
This shiznit be also contained up in tha \fBversion\fR shell variable. (+)
.PP
Afta processin of flag arguments, if arguments remain but none of the
\fB\-c\fR, \fB\-i\fR, \fB\-s\fR, or \fB\-t\fR options was given, tha first
argument is taken as tha name of a gangbangin' file of commands, or ``script'', to
be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da shell opens dis file n' saves its name fo' possible
resubstitution by `$0'.  Because nuff systems use either tha standard
version 6 or version 7 shells whose shell scripts is not compatible
with dis shell, tha shell uses such a `standard' shell ta execute a script
whose first characta aint a `#', i.e., dat do not start wit a
comment.
.PP
Remainin arguments is placed up in tha \fBargv\fR shell variable.
.SS "Startup n' shutdown"
A login shell begins by executin commandz from tha system files
\fI/etc/csh.cshrc\fR n' \fI/etc/csh.login\fR.
It then executes commandz from filez up in tha userz \fBhome\fR directory:
first \fI~/.tcshrc\fR (+)
or, if \fI~/.tcshrc\fR aint found, \fI~/.cshrc\fR,
then \fI~/.history\fR (or tha value of tha \fBhistfile\fR shell variable),
then \fI~/.login\fR,
and finally \fI~/.cshdirs\fR (or tha value of tha \fBdirsfile\fR shell variable) (+).
Da shell may read \fI/etc/csh.login\fR before instead of after
\fI/etc/csh.cshrc\fR, n' \fI~/.login\fR before instead of after
\fI~/.tcshrc\fR or \fI~/.cshrc\fR n' \fI~/.history\fR, if so compiled;
see tha \fBversion\fR shell variable. (+)
.PP
Non-login shells read only \fI/etc/csh.cshrc\fR n' \fI~/.tcshrc\fR
or \fI~/.cshrc\fR on startup.
.PP
For examplez of startup files, please consult
\fIhttp://tcshrc.sourceforge.net\fR.
.PP
Commandz like \fIstty\fR(1) n' \fItset\fR(1),
which need be run only once per login, probably go up in onez \fI~/.login\fR file.
Users whoz ass need ta use tha same set of filez wit both \fIcsh\fR(1) and
\fItcsh\fR can have only a \fI~/.cshrc\fR which checks fo' tha existence of the
\fBtcsh\fR shell variable (q.v.) before rockin \fItcsh\fR-specific commands,
or can have both a \fI~/.cshrc\fR n' a \fI~/.tcshrc\fR which \fIsource\fRs
(see tha builtin command) \fI~/.cshrc\fR.
Da rest of dis manual uses `\fI~/.tcshrc\fR' ta mean `\fI~/.tcshrc\fR or,
if \fI~/.tcshrc\fR aint found, \fI~/.cshrc\fR'.
.PP
In tha aiiight case, tha shell begins readin commandz from tha terminal,
promptin wit `> '.  (Processin of arguments n' tha use of tha shell to
process filez containin command scripts is busted lyrics bout later.)
Da shell repeatedly readz a line of command input, breaks it tha fuck into lyrics,
places it on tha command history list, parses it n' executes each command
in tha line.
.PP
One can log up by typin `^D' on a empty line, `logout' or `login' or
via tha shellz autologout mechanizzle (see tha \fBautologout\fR shell variable).
When a login shell terminates it sets tha \fBlogout\fR shell variable to
`normal' or `automatic' as appropriate, then
executes commandz from tha files
\fI/etc/csh.logout\fR n' \fI~/.logout\fR.  Da shell may drop DTR on logout
if so compiled; peep tha \fBversion\fR shell variable.
.PP
Da namez of tha system login n' logout filez vary from system ta system for
compatibilitizzle wit different \fIcsh\fR(1) variants; peep \fBFILES\fR.
.SS Editing
We first describe \fBDa command-line editor\fR.
Da \fBCompletion n' listing\fR n' \fBSpellin erection\fR sections
describe two setz of functionalitizzle dat is implemented as editor commands
but which deserve they own treatment.
Finally, \fBEditor commands\fR lists n' raps about
the editor commandz specific ta tha shell n' they default bindings.
.SS "Da command-line editor (+)"
Command-line input can be edited rockin key sequences much like dem used in
GNU Emacs or \fIvi\fR(1).
Da editor be actizzle only when tha \fBedit\fR shell variable is set, which
it is by default up in interactizzle shells.
Da \fIbindkey\fR builtin can display n' chizzle key bindings.
Emacs-style key bindings is used by default
(unless tha shell was compiled otherwise; peep tha \fBversion\fR shell variable),
but \fIbindkey\fR can chizzle tha key bindings ta \fIvi\fR-style bindings en masse.
.PP
Da shell always bindz tha arrow keys (as defined up in tha \fBTERMCAP\fR
environment variable) to
.PP
.PD 0
.RS +4
.TP 8
down
\fIdown-history\fR
.TP 8
up
\fIup-history\fR
.TP 8
left
\fIbackward-char\fR
.TP 8
right
\fIforward-char\fR
.PD
.RE
.PP
unless bustin so would alta another single-characta binding.
One can set tha arrow key escape sequences ta tha empty strang wit \fIsettc\fR
to prevent these bindings.
Da ANSI/VT100 sequences fo' arrow keys is always bound.
.PP
Other key bindings are, fo' da most thugged-out part, what tha fuck Emacs n' \fIvi\fR(1)
users would expect n' can easily be displayed by \fIbindkey\fR, so there
is no need ta list dem here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  Likewise, \fIbindkey\fR can list tha editor
commandz wit a gangbangin' finger-lickin' dirty-ass short description of each.
.PP
Note dat editor commandz aint gots tha same notion of a ``word'' as do the
shell.  Da editor delimits lyrics wit any non-alphanumeric charactas not in
the shell variable \fBwordchars\fR, while tha shell recognizes only whitespace
and a shitload of tha charactas wit special meanings ta it, listed under
\fBLexical structure\fR.
.SS "Completion n' listin (+)"
Da shell is often able ta complete lyrics when given a unique abbreviation.
Type part of a word (for example `ls /usr/lost') n' hit tha tab key to
run tha \fIcomplete-word\fR editor command.
Da shell completes tha filename `/usr/lost' ta `/usr/lost+found/',
replacin tha incomplete word wit tha complete word up in tha input buffer.
(Note tha terminal `/'; completion addz a `/' ta the
end of completed directories n' a space ta tha end of other completed lyrics,
to speed typin n' provide a visual indicator of successful completion.
Da \fBaddsuffix\fR shell variable can be unset ta prevent all dis bullshit.)
If no match is found (like `/usr/lost+found' don't exist),
the terminal bell rings.
If tha word be already complete (like there be a `/usr/lost' on your
system, or like you was thankin too far ahead n' typed tha whole thang)
a `/' or space be added ta tha end if it aint already there.
.PP
Completion works anywhere up in tha line, not at just tha end; completed
text pushes tha rest of tha line ta tha right.  Completion up in tha middle of a word
often thangs up in dis biatch up in leftover charactas ta tha right of tha cursor dat need
to be deleted.
.PP
Commandz n' variablez can be completed up in much tha same way.
For example, typin `em[tab]' would complete `em' to
`emacs' if \fIemacs\fR was tha only command on yo' system beginnin wit `em'.
Completion can find a cold-ass lil command up in any directory up in \fBpath\fR or if
given a gangbangin' full pathname.
Typin `echo $ar[tab]' would complete `$ar' ta `$argv'
if no other variable fuckin started wit `ar'.
.PP
Da shell parses tha input buffer ta determine whether tha word you want to
complete should be completed as a gangbangin' filename, command or variable.
Da first word up in tha buffer n' tha straight-up original gangsta word following
`;', `|', `|&', `&&' or `||' is considered ta be a cold-ass lil command.
A word beginnin wit `$' is considered ta be a variable.
Anythang else be a gangbangin' filename.  An empty line is `completed' as a gangbangin' filename.
.PP
Yo ass can list tha possible completionz of a word at any time by typin `^D'
to run tha \fIdelete-char-or-list-or-eof\fR editor command.
Da shell lists tha possible completions rockin tha \fIls\-F\fR builtin (q.v.)
and reprints tha prompt n' unfinished command line, fo' example:
.IP "" 4
> ls /usr/l[^D]
.br
lbin/       lib/        local/      lost+found/
.br
> ls /usr/l
.PP
If tha \fBautolist\fR shell variable is set, tha shell lists tha remaining
choices (if any) whenever completion fails:
.IP "" 4
> set autolist
.br
> nm /usr/lib/libt[tab]
.br
libtermcap.a@ libtermlib.a@
.br
> nm /usr/lib/libterm
.PP
If \fBautolist\fR is set ta `ambiguous', chizzlez is listed only when
completion fails n' addz no freshly smoked up charactas ta tha word bein completed.
.PP
A filename ta be completed can contain variables, yo' own or others' home
directories abbreviated wit `~' (see \fBFilename substitution\fR) and
directory stack entries abbreviated wit `='
(see \fBDirectory stack substitution\fR).  For example,
.IP "" 4
> ls ~k[^D]
.br
kahn    kas     kellogg
.br
> ls ~ke[tab]
.br
> ls ~kellogg/
.PP
or
.IP "" 4
> set local = /usr/local
.br
> ls $lo[tab]
.br
> ls $local/[^D]
.br
bin/ etc/ lib/ man/ src/
.br
> ls $local/
.PP
Note dat variablez can also be expanded explicitly wit the
\fIexpand-variables\fR editor command.
.PP
\fIdelete-char-or-list-or-eof\fR lists at only tha end of tha line;
in tha middle of a line it deletes tha characta under tha cursor and
on a empty line it logs one up or, if \fBignoreeof\fR is set, do nothing.
`M-^D', bound ta tha editor command \fIlist-choices\fR, lists completion
possibilitizzles anywhere on a line, n' \fIlist-choices\fR (or any one of the
related editor commandz dat do or don't delete, list and/or log out,
listed under \fIdelete-char-or-list-or-eof\fR) can be bound ta `^D' with
the \fIbindkey\fR builtin command if so desired.
.PP
Da \fIcomplete-word-fwd\fR n' \fIcomplete-word-back\fR editor commands
(not bound ta any keys by default) can be used ta cycle up n' down through
the list of possible completions, replacin tha current word wit tha next or
previous word up in tha list.
.PP
Da shell variable \fBfignore\fR can be set ta a list of suffixes ta be
ignored by completion. I aint talkin' bout chicken n' gravy biatch.  Consider tha following:
.IP "" 4
> ls
.br
Makefile        condiments.h~   main.o          side.c
.br
README          main.c          meal            side.o
.br
condiments.h    main.c~
.br
> set fignore = (.o \\~)
.br
> emacs ma[^D]
.br
main.c   main.c~  main.o
.br
> emacs ma[tab]
.br
> emacs main.c
.PP
`main.c~' n' `main.o' is ignored by completion (but not listing),
because they end up in suffixes up in \fBfignore\fR.
Note dat a `\\' was needed up in front of `~' ta prevent it from being
expanded ta \fBhome\fR as busted lyrics bout under \fBFilename substitution\fR.
\fBfignore\fR is ignored if only one completion is possible.
.PP
If tha \fBcomplete\fR shell variable is set ta `enhance', completion
1) ignores case n' 2) considaz periods, hyphens n' underscores
(`.', `\-' n' `_') ta be word separators n' hyphens n' underscores to
be equivalent.  If you had tha followin files
.IP "" 4
comp.lang.c      comp.lang.perl   comp.std.c++
.br
comp.lang.c++    comp.std.c
.PP
and typed `mail \-f c.l.c[tab]', it would be completed to
`mail \-f comp.lang.c', n' ^D would list `comp.lang.c' n' `comp.lang.c++'.
`mail \-f c..c++[^D]' would list `comp.lang.c++' n' `comp.std.c++'.  Typing
`rm a\-\-file[^D]' up in tha followin directory
.IP "" 4
A_silly_file    a-hyphenated-file    another_silly_file
.PP
would list all three files, cuz case is ignored n' hyphens and
underscores is equivalent.  Periods, however, is not equivalent to
hyphens or underscores.
.PP
If tha \fBcomplete\fR shell variable is set ta `Enhance', completion
ignores case n' differences between a hyphen n' a underscore word
separator only when tha user types a lowercase characta or a hyphen.
Enterin a uppercase characta or a underscore aint gonna match tha 
correspondin lowercase characta or hyphen word separator. Shiiit, dis aint no joke.  
Typin `rm a\-\-file[^D]' up in tha directory of tha previous example would 
still list all three filez yo, but typin `rm A\-\-file' would match only 
`A_silly_file' n' typin `rm a__file[^D]' would match just `A_silly_file' 
and `another_silly_file' cuz tha user explicitly used a uppercase 
or a underscore character n' shit.  
.PP
Completion n' listin is affected by nuff muthafuckin other shell variables:
\fBrecexact\fR can be set ta complete on tha shortest possible unique
match, even if mo' typin might result up in a longer match:
.IP "" 4
> ls
.br
fodder   foo      chicken     foonly
.br
> set recexact
.br
> rm fo[tab]
.PP
just beeps, cuz `fo' could expand ta `fod' or `foo' yo, but if we type
another `o',
.IP "" 4
> rm foo[tab]
.br
> rm foo
.PP
the completion completes on `foo', even though `food' n' `foonly'
also match.
\fBautoexpand\fR can be set ta run tha \fIexpand-history\fR editor command
before each completion attempt, \fBautocorrect\fR can be set to
spelling-correct tha word ta be completed (see \fBSpellin erection\fR)
before each completion attempt n' \fBcorrect\fR can be set ta complete
commandz automatically afta one hits `return'.
\fBmatchbeep\fR can be set ta make completion beep or not beep up in a variety
of thangs, n' \fBnobeep\fR can be set ta never beep at all.
\fBnostat\fR can be set ta a list of directories and/or patterns that
match directories ta prevent tha completion mechanizzle from \fIstat\fR(2)ing
those directories.
\fBlistmax\fR n' \fBlistmaxrows\fR can be set ta limit tha number of items
and rows (respectively) dat is listed without askin first.
\fBrecognize_only_executables\fR can be set ta make tha shell list only
executablez when listin commandz yo, but it is like slow.
.PP
Finally, tha \fIcomplete\fR builtin command can be used ta tell tha shell how
to complete lyrics other than filenames, commandz n' variables.
Completion n' listin do not work on glob-patterns (see \fBFilename substitution\fR),
but tha \fIlist-glob\fR n' \fIexpand-glob\fR editor commandz perform
equivalent functions fo' glob-patterns.
.SS "Spellin erection (+)"
Da shell can sometimes erect tha spellin of filenames, commandz n' variable names
as well as completin n' listin em.
.PP
Individual lyrics can be spelling-corrected wit tha \fIspell-word\fR
editor command (usually bound ta M-s n' M-S)
and tha entire input buffer wit \fIspell-line\fR (usually bound ta M-$).
Da \fBcorrect\fR shell variable can be set ta `cmd' ta erect the
command name or `all' ta erect tha entire line each time return is typed,
and \fBautocorrect\fR can be set ta erect tha word ta be completed
before each completion attempt.
.PP
When spellin erection is invoked up in any of these ways and
the shell be thinkin dat any part of tha command line is misspelled,
it prompts wit tha erected line:
.IP "" 4
> set erect = cmd
.br
> lz /usr/bin
.br
CORRECT>ls /usr/bin (y|n|e|a)?
.PP
One can answer `y' or space ta execute tha erected line,
`e' ta leave tha uncorrected command up in tha input buffer,
`a' ta abort tha command as if `^C' had been hit, and
anythang else ta execute tha original gangsta line unchanged.
.PP
Spellin erection recognizes user-defined completions (see the
\fIcomplete\fR builtin command).  If a input word up in a posizzle for
which a cold-ass lil completion is defined resemblez a word up in tha completion list,
spellin erection registas a misspellin n' suggests tha latter
word as a cold-ass lil erection. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat if tha input word do not match any of
the possible completions fo' dat position, spellin erection do
not regista a misspelling.
.PP
Like completion, spellin erection works anywhere up in tha line,
pushin tha rest of tha line ta tha right n' possibly leaving
extra charactas ta tha right of tha cursor.
.PP
Beware: spellin erection aint guaranteed ta work tha way one intends,
and is provided mostly as a experimenstrual feature.
Suggestions n' improvements is welcome.
.SS "Editor commandz (+)"
`bindkey' lists key bindings n' `bindkey \-l' lists n' briefly raps about
editor commands.
Only freshly smoked up or especially bangin-ass editor commandz is busted lyrics bout here.
See \fIemacs\fR(1) n' \fIvi\fR(1) fo' descriptionz of each editor's
key bindings.
.PP
Da characta or charactas ta which each command is bound by default is
given up in parentheses.  `^\fIcharacter\fR' means a cold-ass lil control characta and
`M-\fIcharacter\fR' a meta character, typed as escape-\fIcharacter\fR
on terminals without a meta key.  Case counts yo, but commandz dat is bound
to lettas by default is bound ta both lower- n' uppercase lettas for
convenience.
.TP 8
.B complete-word \fR(tab)
Completes a word as busted lyrics bout under \fBCompletion n' listing\fR.
.TP 8
.B complete-word-back \fR(not bound)
Like \fIcomplete-word-fwd\fR yo, but steps up from tha end of tha list.
.TP 8
.B complete-word-fwd \fR(not bound)
Replaces tha current word wit tha straight-up original gangsta word up in tha list of possible
completions.  May be repeated ta step down all up in tha list.
At tha end of tha list, beeps n' reverts ta tha incomplete word.
.TP 8
.B complete-word-raw \fR(^X-tab)
Like \fIcomplete-word\fR yo, but ignores user-defined completions.
.TP 8
.B copy-prev-word \fR(M-^_)
Copies tha previous word up in tha current line tha fuck into tha input buffer.
See also \fIinsert-last-word\fR.
.TP 8
.B dabbrev-expand \fR(M-/)
Expandz tha current word ta da most thugged-out recent precedin one fo' which
the current be a leadin substring, wrappin round tha history list
(once) if necessary.
Repeatin \fIdabbrev-expand\fR without any intervenin typing
changes ta tha next previous word etc., skippin identical matches
much like \fIhistory-search-backward\fR do.
.TP 8
.B delete-char \fR(not bound)
Deletes tha characta under tha cursor.
See also \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B delete-char-or-eof \fR(not bound)
Do \fIdelete-char\fR if there be a cold-ass lil characta under tha cursor
or \fIend-of-file\fR on a empty line.
See also \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B delete-char-or-list \fR(not bound)
Do \fIdelete-char\fR if there be a cold-ass lil characta under tha cursor
or \fIlist-choices\fR all up in tha end of tha line.
See also \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B delete-char-or-list-or-eof \fR(^D)
Do \fIdelete-char\fR if there be a cold-ass lil characta under tha cursor,
\fIlist-choices\fR all up in tha end of tha line
or \fIend-of-file\fR on a empty line.
See also dem three commands, each of which do only a single action, and
\fIdelete-char-or-eof\fR, \fIdelete-char-or-list\fR n' \fIlist-or-eof\fR,
each of which do a gangbangin' finger-lickin' different two outta tha three.
.TP 8
.B down-history \fR(down-arrow, ^N)
Like \fIup-history\fR yo, but steps down, stoppin all up in tha original gangsta input line.
.TP 8
.B end-of-file \fR(not bound)
Signals a end of file, causin tha shell ta exit unless tha \fBignoreeof\fR
shell variable (q.v.) is set ta prevent all dis bullshit.
See also \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B expand-history \fR(M-space)
Expandz history substitutions up in tha current word.
See \fBHistory substitution\fR.
See also \fImagic-space\fR, \fItoggle-literal-history\fR and
the \fBautoexpand\fR shell variable.
.TP 8
.B expand-glob \fR(^X-*)
Expandz tha glob-pattern ta tha left of tha cursor.
See \fBFilename substitution\fR.
.TP 8
.B expand-line \fR(not bound)
Like \fIexpand-history\fR yo, but
expandz history substitutions up in each word up in tha input buffer.
.TP 8
.B expand-variablez \fR(^X-$)
Expandz tha variable ta tha left of tha cursor.
See \fBVariable substitution\fR.
.TP 8
.B history-search-backward \fR(M-p, M-P)
Searches backwardz all up in tha history list fo' a cold-ass lil command beginnin with
the current contentz of tha input buffer up ta tha cursor n' copies it
into tha input buffer.
Da search strang may be a glob-pattern (see \fBFilename substitution\fR)
containin `*', `?', `[]' or `{}'.
\fIup-history\fR n' \fIdown-history\fR will proceed from the
appropriate point up in tha history list.
Emacs mode only.
See also \fIhistory-search-forward\fR n' \fIi-search-back\fR.
.TP 8
.B history-search-forward \fR(M-n, M-N)
Like \fIhistory-search-backward\fR yo, but searches forward.
.TP 8
.B i-search-back \fR(not bound)
Searches backward like \fIhistory-search-backward\fR, copies tha straight-up original gangsta match
into tha input buffer wit tha cursor positioned all up in tha end of tha pattern,
and prompts wit `bck: ' n' tha straight-up original gangsta match.  Additionizzle charactas may be
typed ta extend tha search, \fIi-search-back\fR may be typed ta continue
searchin wit tha same pattern, wrappin round tha history list if
necessary, (\fIi-search-back\fR must be bound ta a
single characta fo' dis ta work) or one of tha followin special characters
may be typed:
.PP
.RS +8
.RS +4
.PD 0
.TP 8
^W
Appendz tha rest of tha word under tha cursor ta tha search pattern.
.TP 8
delete (or any characta bound ta \fIbackward-delete-char\fR)
Undoes tha effect of tha last characta typed n' deletes a cold-ass lil character
from tha search pattern if appropriate.
.TP 8
^G
If tha previous search was successful, aborts tha entire search.
If not, goes back ta tha last successful search.
.TP 8
escape
Endz tha search, leavin tha current line up in tha input buffer.
.RE
.PD
.PP
Any other characta not bound ta \fIself-insert-command\fR terminates the
search, leavin tha current line up in tha input buffer, and
is then interpreted as aiiight input.  In particular, a cold-ass lil carriage return
causes tha current line ta be executed.
Emacs mode only.
See also \fIi-search-fwd\fR n' \fIhistory-search-backward\fR.
.RE
.TP 8
.B i-search-fwd \fR(not bound)
Like \fIi-search-back\fR yo, but searches forward.
.TP 8
.B insert-last-word \fR(M-_)
Inserts tha last word of tha previous input line (`!$') tha fuck into tha input buffer.
See also \fIcopy-prev-word\fR.
.TP 8
.B list-choices \fR(M-^D)
Lists completion possibilitizzles as busted lyrics bout under \fBCompletion n' listing\fR.
See also \fIdelete-char-or-list-or-eof\fR n' \fIlist-choices-raw\fR.
.TP 8
.B list-choices-raw \fR(^X-^D)
Like \fIlist-choices\fR yo, but ignores user-defined completions.
.TP 8
.B list-glob \fR(^X-g, ^X-G)
Lists (via tha \fIls\-F\fR builtin) matches ta tha glob-pattern
(see \fBFilename substitution\fR) ta tha left of tha cursor.
.TP 8
.B list-or-eof \fR(not bound)
Do \fIlist-choices\fR
or \fIend-of-file\fR on a empty line.
See also \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B magic-space \fR(not bound)
Expandz history substitutions up in tha current line,
like \fIexpand-history\fR, n' bangs a space.
\fImagic-space\fR is designed ta be bound ta tha space bar,
but aint bound by default.
.TP 8
.B normalize-command \fR(^X-?)
Searches fo' tha current word up in PATH and, if it is found, replaces it with
the full path ta tha executable.  Special charactas is quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Aliases are
expanded n' quoted but commandz within aliases is not.  This command is
useful wit commandz dat take commandz as arguments, e.g., `dbx' n' `sh \-x'.
.TP 8
.B normalize-path \fR(^X-n, ^X-N)
Expandz tha current word as busted lyrics bout under tha `expand' setting
of tha \fBsymlinks\fR shell variable.
.TP 8
.B overwrite-mode \fR(unbound)
Togglez between input n' overwrite modes.
.TP 8
.B run-fg-editor \fR(M-^Z)
Saves tha current input line and
looks fo' a stopped thang wit a name equal ta tha last component of the
file name part of tha \fBEDITOR\fR or \fBVISUAL\fR environment variables,
or, if neither is set, `ed' or `vi'.
If such a thang is found, it is restarted as if `fg %\fIjob\fR' had been
typed. Y'all KNOW dat shit, muthafucka!  This is used ta toggle back n' forth between a editor and
the shell doggystyle.  Some playas bind dis command ta `^Z' so they
can do dis even mo' doggystyle.
.TP
.B run-help \fR(M-h, M-H)
Searches fo' documentation on tha current command, rockin tha same notion of
`current command' as tha completion routines, n' prints dat shit.  There is no way
to bust a pager; \fIrun-help\fR is designed fo' short help files.
If tha special alias \fBhelpcommand\fR is defined, it is run wit the
command name as a sole argument.  Else,
documentation should be up in a gangbangin' file named \fIcommand\fR.help, \fIcommand\fR.1,
\fIcommand\fR.6, \fIcommand\fR.8 or \fIcommand\fR, which should be up in one
of tha directories listed up in tha \fBHPATH\fR environment variable.
If there is mo' than one help file only tha straight-up original gangsta is printed.
.TP 8
.B self-insert-command \fR(text characters)
In bang mode (the default), bangs tha typed characta tha fuck into tha input line afta tha characta under tha cursor.
In overwrite mode, replaces tha characta under tha cursor wit tha typed character.
Da input mode is normally preserved between lines yo, but the
\fBinputmode\fR shell variable can be set ta `insert' or `overwrite' ta put the
editor up in dat mode all up in tha beginnin of each line.
See also \fIoverwrite-mode\fR.
.TP 8
.B sequence-lead-in \fR(arrow prefix, meta prefix, ^X)
Indicates dat tha followin charactas is part of a
multi-key sequence.  Bindin a cold-ass lil command ta a multi-key sequence straight-up creates
two bindings: tha straight-up original gangsta characta ta \fIsequence-lead-in\fR n' the
whole sequence ta tha command. Y'all KNOW dat shit, muthafucka!  All sequences beginnin wit a cold-ass lil character
bound ta \fIsequence-lead-in\fR is effectively bound ta \fIundefined-key\fR
unless bound ta another command.
.TP 8
.B spell-line \fR(M-$)
Attempts ta erect tha spellin of each word up in tha input buffer, like
\fIspell-word\fR yo, but ignores lyrics whose first characta is one of
`\-', `!', `^' or `%', or which contain `\\', `*' or `?', ta avoid problems
with switches, substitutions n' tha like.
See \fBSpellin erection\fR.
.TP 8
.B spell-word \fR(M-s, M-S)
Attempts ta erect tha spellin of tha current word as busted lyrics about
under \fBSpellin erection\fR.
Checks each component of a word which appears ta be a pathname.
.TP 8
.B toggle-literal-history \fR(M-r, M-R)
Expandz or `unexpands' history substitutions up in tha input buffer.
See also \fIexpand-history\fR n' tha \fBautoexpand\fR shell variable.
.TP 8
.B undefined-key \fR(any unbound key)
Beeps.
.TP 8
.B up-history \fR(up-arrow, ^P)
Copies tha previous entry up in tha history list tha fuck into tha input buffer.
If \fBhistlit\fR is set, uses tha literal form of tha entry.
May be repeated ta step up all up in tha history list, stoppin all up in tha top.
.TP 8
.B vi-search-back \fR(?)
Prompts wit `?' fo' a search strang (which may be a glob-pattern, as with
\fIhistory-search-backward\fR), searches fo' it n' copies it tha fuck into the
input buffer n' shit.  Da bell rings if no match is found.
Hittin return endz tha search n' leaves tha last match up in tha input
buffer.
Hittin escape endz tha search n' executes tha match.
\fIvi\fR mode only.
.TP 8
.B vi-search-fwd \fR(/)
Like \fIvi-search-back\fR yo, but searches forward.
.TP 8
.B which-command \fR(M-?)
Do a \fIwhich\fR (see tha description of tha builtin command) on the
first word of tha input buffer.
.TP 8
.B yank-pop \fR(M-y)
When executed immediately afta a \fIyank\fR or another \fIyank-pop\fR,
replaces tha yanked strang wit tha next previous strang from the
killring. This also has tha effect of rotatin tha killring, such that
this strang is ghon be considered da most thugged-out recently capped by a later
\fIyank\fR command. Y'all KNOW dat shit, muthafucka! Repeatin \fIyank-pop\fR will cycle all up in the
killrin any number of times.
.SS "Lexical structure"
Da shell splits input lines tha fuck into lyrics at blanks n' tabs.  Da special
charactas `&', `|', `;', `<', `>', `(', n' `)' n' tha doubled characters
`&&', `||', `<<' n' `>>' is always separate lyrics, whether or not they are
surrounded by whitespace.
.PP
When tha shellz input aint a terminal, tha characta `#' is taken ta begin a
comment.  Each `#' n' tha rest of tha input line on which it appears is
discarded before further parsing.
.PP
A special characta (includin a funky-ass blank or tab) may be prevented from having
its special meaning, n' possibly made part of another word, by precedin it
with a funky-ass backslash (`\\') or enclosin it up in single (`''), double (`"') or
backward (``') quotes.  When not otherwise quoted a newline preceded by a `\\'
is equivalent ta a funky-ass blank yo, but inside quotes dis sequence thangs up in dis biatch up in a
newline.
.PP
Furthermore, all \fBSubstitutions\fR (see below) except \fBHistory substitution\fR
can be prevented by enclosin tha strings (or partz of strings)
in which they step tha fuck up wit single quotes or by quotin tha crucial character(s)
(e.g., `$' or ``' fo' \fBVariable substitution\fR or \fBCommand substitution\fR respectively)
with `\\'.  (\fBAlias substitution\fR is no exception: quotin up in any way any
characta of a word fo' which a \fIalias\fR has been defined prevents
substitution of tha alias.  Da usual way of quotin a alias is ta precede it
with a funky-ass backslash.) \fBHistory substitution\fR is prevented by
backslashes but not by single quotes.  Strings quoted wit double or backward
quotes undergo \fBVariable substitution\fR n' \fBCommand substitution\fR yo, but other
substitutions is prevented.
.PP
Text inside single or double quotes becomes a single word (or part of one).
Metacharactas up in these strings, includin blanks n' tabs, do not form
separate lyrics.  Only up in one special case (see \fBCommand substitution\fR
below) can a thugged-out double-quoted strang yield partz of mo' than one word;
single-quoted strings never do.  Backward quotes is special: they signal
\fBCommand substitution\fR (q.v.), which may result up in mo' than one word.
.PP
Quotin complex strings, particularly strings which theyselves contain quoting
characters, can be confusing.  Remember dat quotes need not be used as they are
in human writing!  It may be easier ta quote not a entire strin yo, but only
those partz of tha strang which need quoting, rockin different typez of quoting
to do so if appropriate.
.PP
Da \fBbackslash_quote\fR shell variable (q.v.) can be set ta make backslashes
always quote `\\', `'', n' `"'.  (+) This may make complex quotin tasks
easier yo, but it can cause syntax errors up in \fIcsh\fR(1) scripts.
.SS Substitutions
We now describe tha various transformations tha shell performs on tha input in
the order up in which they occur. Shiiit, dis aint no joke.  We note up in passin tha data structures involved
and tha commandz n' variablez which affect em.  Remember dat substitutions
can be prevented by quotin as busted lyrics bout under \fBLexical structure\fR.
.SS "History substitution"
Each command, or ``event'', input from tha terminal is saved up in tha history
list.  Da previous command be always saved, n' tha \fBhistory\fR shell
variable can be set ta a number ta save dat nuff commands.  Da \fBhistdup\fR
shell variable can be set ta not save duplicate events or consecutizzle duplicate
events.
.PP
Saved commandz is numbered sequentially from 1 n' stamped wit tha time.
It aint probably necessary ta use event numbers yo, but tha current event number
can be made part of tha prompt by placin a `!' up in tha \fBprompt\fR shell variable.
.PP
Da shell straight-up saves history up in expanded n' literal (unexpanded) forms.
If tha \fBhistlit\fR shell variable is set, commandz dat display n' store
history use tha literal form.
.PP
Da \fIhistory\fR builtin command can print, store up in a gangbangin' file, restore
and clear tha history list at any time,
and tha \fBsavehist\fR n' \fBhistfile\fR shell variablez can be set to
store tha history list automatically on logout n' restore it on login.
.PP
History substitutions introduce lyrics from tha history list tha fuck into tha input
stream, makin it easy as fuck  ta repeat commands, repeat argumentz of a previous
command up in tha current command, or fix spellin mistakes up in tha previous
command wit lil typin n' a high degree of confidence.
.PP
History substitutions begin wit tha characta `!'.  They may begin anywhere in
the input stream yo, but they do not nest.  Da `!' may be preceded by a `\\' to
prevent its special meaning; fo' convenience, a `!' is passed unchanged when it
is followed by a funky-ass blank, tab, newline, `=' or `('.  History substitutions also
occur when a input line begins wit `^'.  This special abbreviation will be
busted lyrics bout later n' shit.  Da charactas used ta signal history substitution (`!' and
`^') can be chizzled by settin tha \fBhistchars\fR shell variable.  Any input
line which gotz nuff a history substitution is printed before it is executed.
.PP
A history substitution may have a ``event justification'', which indicates
the event from which lyrics is ta be taken, a ``word designator'',
which selects particular lyrics from tha chosen event, and/or a ``modifier'',
which manipulates tha selected lyrics.
.PP
An event justification can be
.PP
.PD 0
.RS +4
.TP 8
.I n
A number, referrin ta a particular event
.TP 8
\-\fIn\fR
An offset, referrin ta tha event \fIn\fR before tha current event
.TP 8
#
Da current event.
This should be used carefully up in \fIcsh\fR(1), where there is no check for
recursion. I aint talkin' bout chicken n' gravy biatch.  \fItcsh\fR allows 10 levelz of recursion. I aint talkin' bout chicken n' gravy biatch.  (+)
.TP 8
!
Da previous event (equivalent ta `\-1')
.TP 8
.I s
Da most recent event whose first word begins wit tha strang \fIs\fR
.TP 8
?\fIs\fR?
Da most recent event which gotz nuff tha strang \fIs\fR.
Da second `?' can be omitted if it is immediately followed by a newline.
.RE
.PD
.PP
For example, consider dis bit of one of mah thugss history list:
.IP "" 4
\ 9  8:30    nroff \-man wumpus.man
.br
10  8:31    cp wumpus.man wumpus.man.old
.br
11  8:36    vi wumpus.man
.br
12  8:37    diff wumpus.man.old wumpus.man
.PP
Da commandz is shown wit they event numbers n' time stamps.
Da current event, which we aint typed up in yet, is event 13.
`!11' n' `!\-2' refer ta event 11.
`!!' refers ta tha previous event, 12.  `!!' can be abbreviated `!' if it is
followed by `:' (`:' is busted lyrics bout below).
`!n' refers ta event 9, which begins wit `n'.
`!?old?' also refers ta event 12, which gotz nuff `old'.
Without word designators or modifiers history references simply expand ta the
entire event, so we might type `!cp' ta redo tha copy command or `!!|more'
if tha `diff' output scrolled off tha top of tha screen.
.PP
History references may be insulated from tha surroundin text wit braces if
necessary.  For example, `!vdoc' would look fo' a cold-ass lil command beginnin with
`vdoc', and, up in dis example, not find one yo, but `!{v}doc' would expand
unambiguously ta `vi wumpus.mandoc'.
Even up in braces, history substitutions do not nest.
.PP
(+) While \fIcsh\fR(1) expands, fo' example, `!3d' ta event 3 wit the
letta `d' appended ta it, \fItcsh\fR expandz it ta tha last event beginning
with `3d'; only straight-up numeric arguments is treated as event numbers.
This make it possible ta recall events beginnin wit numbers.
To expand `!3d' as up in \fIcsh\fR(1) say `!{3}d'.
.PP
To select lyrics from a event we can follow tha event justification by a `:'
and a thugged-out designator fo' tha desired lyrics.  Da lyrics of a input line are
numbered from 0, tha straight-up original gangsta (usually command) word bein 0, tha second word
(first argument) bein 1, etc.  Da basic word designators are:
.PP
.PD 0
.RS +4
.TP 8
0
Da first (command) word
.TP 8
.I n
Da \fIn\fRth argument
.TP 8
^
Da first argument, equivalent ta `1'
.TP 8
$
Da last argument
.TP 8
%
Da word matched by a ?\fIs\fR? search
.TP 8
.I x\-y
A range of lyrics
.TP 8
.I \-y
Equivalent ta \fI`0\-y'\fR
.TP 8
*
Equivalent ta `^\-$' yo, but returns not a god damn thang if tha event gotz nuff only 1 word
.TP 8
.I x*
Equivalent ta \fI`x\-$'\fR
.TP 8
.I x\-
Equivalent ta \fI`x*'\fR yo, but omittin tha last word (`$')
.PD
.RE
.PP
Selected lyrics is banged tha fuck into tha command line separated by single blanks.
For example, tha `diff' command up in tha previous example might have been
typed as `diff !!:1.old !!:1' (usin `:1' ta select tha straight-up original gangsta argument
from tha previous event) or `diff !\-2:2 !\-2:1' ta select n' swap the
arguments from tha `cp' command. Y'all KNOW dat shit, muthafucka!  If our phat asses didn't care bout tha order of the
`diff' we might have holla'd `diff !\-2:1\-2' or simply `diff !\-2:*'.
Da `cp' command might done been freestyled `cp wumpus.man !#:1.old', rockin `#'
to refer ta tha current event.
`!n:\- hurkle.man' would reuse tha straight-up original gangsta two lyrics from tha `nroff' command
to say `nroff \-man hurkle.man'.
.PP
Da `:' separatin tha event justification from tha word designator can be
omitted if tha argument selector begins wit a `^', `$', `*', `%' or `\-'.
For example, our `diff' command might done been `diff !!^.old !!^' or,
equivalently, `diff !!$.old !!$'.  But fuck dat shiznit yo, tha word on tha street is dat if `!!' be abbreviated `!',
an argument selector beginnin wit `\-' is ghon be interpreted as a event
specification.
.PP
A history reference may gotz a word designator but no event justification.
It then references tha previous command.
Continuin our `diff' example, we could have holla'd simply `diff
!^.old !^' or, ta git tha arguments up in tha opposite order, just `diff !*'.
.PP
Da word or lyrics up in a history reference can be edited, or ``modified'',
by followin it wit one or mo' modifiers, each preceded by a `:':
.PP
.PD 0
.RS +4
.TP 8
h
Remove a trailin pathname component, leavin tha head.
.TP 8
t
Remove all leadin pathname components, leavin tha tail.
.TP 8
r
Remove a gangbangin' filename extension `.xxx', leavin tha root name.
.TP 8
e
Remove all but tha extension.
.TP 8
u
Uppercase tha straight-up original gangsta lowercase letter.
.TP 8
l
Lowercase tha straight-up original gangsta uppercase letter.
.TP 8
s\fI/l/r/\fR
Substitute \fIl\fR fo' \fIr\fR.
\fIl\fR is simply a strang like \fIr\fR, not a regular expression as in
the eponymous \fIed\fR(1) command.
Any characta may be used as tha delimita up in place of `/';
a `\\' can be used ta quote tha delimita expect `(', `)', `|' n' `>' inside \fIl\fR n' \fIr\fR.
Da characta `&' up in tha \fIr\fR is replaced by \fIl\fR; `\\' also quotes `&'.
If \fIl\fR is empty (``''), tha \fIl\fR from a previous substitution or the
\fIs\fR from a previous search or event number up in event justification is used.
Da trailin delimita may be omitted if it is immediately followed by a newline.
.TP 8
&
Repeat tha previous substitution.
.TP 8
g
Apply tha followin modifier once ta each word.
.TP 8
a (+)
Apply tha followin modifier as nuff times as possible ta a single word.
`a' n' `g' can be used together ta apply a modifier globally.
With tha `s' modifier, only tha patterns contained up in tha original gangsta word are
substituted, not patterns dat contain any substitution result.
.TP 8
p
Print tha freshly smoked up command line but do not execute dat shit.
.TP 8
q
Quote tha substituted lyrics, preventin further substitutions.
.TP 8
x
Like q yo, but break tha fuck into lyrics at blanks, tabs n' newlines.
.PD
.RE
.PP
Modifiers is applied ta only tha straight-up original gangsta modifiable word (unless `g' is used).
It be a error fo' no word ta be modifiable.
.PP
For example, tha `diff' command might done been freestyled as `diff wumpus.man.old
!#^:r', rockin `:r' ta remove `.old' from tha straight-up original gangsta argument on tha same line
(`!#^').  We could say `echo wassup up there', then `echo !*:u' ta capitalize
`hello', `echo !*:au' ta say it up loud, or `echo !*:agu' ta straight-up shout.
We might follow `mail \-s "I forgot mah password" rot' wit `!:s/rot/root' to
correct tha spellin of `root' (but peep \fBSpellin erection\fR fo' a
different approach).
.PP
There be a special abbreviation fo' substitutions.
`^', when it is tha straight-up original gangsta characta on a input line, is equivalent ta `!:s^'.
Thus we might have holla'd `^rot^root' ta make tha spellin erection up in the
previous example.
This is tha only history substitution which do not explicitly begin wit `!'.
.PP
(+) In \fIcsh\fR as such, only one modifier may be applied ta each history
or variable expansion. I aint talkin' bout chicken n' gravy biatch.  In \fItcsh\fR, mo' than one may be used, fo' example
.IP "" 4
% mv wumpus.man /usr/man/man1/wumpus.1
.br
% playa !$:t:r
.br
man wumpus
.PP
In \fIcsh\fR, tha result would be `wumpus.1:r'.  A substitution followed by a
colon may need ta be insulated from it wit braces:
.IP "" 4
> mv a.out /usr/games/wumpus
.br
> setenv PATH !$:h:$PATH
.br
Wack ! modifier: $.
.br
> setenv PATH !{\-2$:h}:$PATH
.br
setenv PATH /usr/games:/bin:/usr/bin:.
.PP
Da first attempt would succeed up in \fIcsh\fR but fails up in \fItcsh\fR,
because \fItcsh\fR expects another modifier afta tha second colon
rather than `$'.
.PP
Finally, history can be accessed all up in tha editor as well as through
the substitutions just busted lyrics about.
Da \fIup-\fR n' \fIdown-history\fR, \fIhistory-search-backward\fR and
\fI-forward\fR, \fIi-search-back\fR n' \fI-fwd\fR,
\fIvi-search-back\fR n' \fI-fwd\fR, \fIcopy-prev-word\fR
and \fIinsert-last-word\fR editor commandz search for
events up in tha history list n' copy dem tha fuck into tha input buffer.
Da \fItoggle-literal-history\fR editor command switches between the
expanded n' literal formz of history lines up in tha input buffer.
\fIexpand-history\fR n' \fIexpand-line\fR expand history substitutions
in tha current word n' up in tha entire input buffer respectively.
.SS "Alias substitution"
Da shell maintains a list of aliases which can be set, unset n' printed by
the \fIalias\fR n' \fIunalias\fR commands.  Afta a cold-ass lil command line is parsed
into simple commandz (see \fBCommands\fR) tha straight-up original gangsta word of each command,
left-to-right, is checked ta peep if it has a alias.  If so, tha straight-up original gangsta word is
replaced by tha alias.  If tha alias gotz nuff a history reference, it undergoes
\fBHistory substitution\fR (q.v.) as though tha original gangsta command was the
previous input line.  If tha alias do not contain a history reference, the
argument list is left untouched.
.PP
Thus if tha alias fo' `ls' was `ls \-l' tha command `ls /usr' would become `ls
\-l /usr', tha argument list here bein undisturbed. Y'all KNOW dat shit, muthafucka!  If tha alias fo' `lookup'
were `grep !^ /etc/passwd' then `lookup bill' would become `grep bill
/etc/passwd'.  Aliases can be used ta introduce parser metasyntax.  For
example, `alias print 'pr \e!* | lpr'' defines a ``command'' (`print') which
\fIpr\fR(1)s its arguments ta tha line printer.
.PP
Alias substitution is repeated until tha straight-up original gangsta word of tha command has no
alias.  If a alias substitution do not chizzle tha straight-up original gangsta word (as up in the
previous example) it is flagged ta prevent a loop.  Other loops is detected and
cause a error.
.PP
Some aliases is referred ta by tha shell; peep \fBSpecial aliases\fR.
.SS "Variable substitution"
Da shell maintains a list of variables, each of which has as value a list of
zero or mo' lyrics.
Da jointz of shell variablez can be displayed n' chizzled wit the
\fIset\fR n' \fIunset\fR commands.
Da system maintains its own list of ``environment'' variables.
These can be displayed n' chizzled wit \fIprintenv\fR, \fIsetenv\fR and
\fIunsetenv\fR.
.PP
(+) Variablez may be made read-only wit `set \-r' (q.v.).
Read-only variablez may not be modified or unset;
attemptin ta do so will cause a error.
Once made read-only, a variable cannot be made writable,
so `set \-r' should be used wit caution.
Environment variablez cannot be made read-only.
.PP
Some variablez is set by tha shell or referred ta by dat shit.
For instance, tha \fBargv\fR variable be a image of tha shellz argument
list, n' lyrics of dis variablez value is referred ta up in special ways.
Some of tha variablez referred ta by tha shell is toggles;
the shell do not care what tha fuck they value is, only whether they is set or not.
For instance, tha \fBverbose\fR variable be a toggle which causes command
input ta be echoed. Y'all KNOW dat shit, muthafucka!  Da \fB\-v\fR command line option sets dis variable.
\fBSpecial shell variables\fR lists all variablez which is referred ta by tha shell.
.PP
Other operations treat variablez numerically.  Da `@' command permits numeric
calculations ta be performed n' tha result assigned ta a variable.  Variable
values are, however, always represented as (zero or more) strings.  For the
purposez of numeric operations, tha null strang is considered ta be zero, and
the second n' subsequent lyrics of multi-word joints is ignored.
.PP
Afta tha input line be aliased n' parsed, n' before each command is
executed, variable substitution is performed keyed by `$' characters.  This
expansion can be prevented by precedin tha `$' wit a `\e' except within `"'s
where it \fIalways\fR occurs, n' within `'z where it \fInever\fR occurs.
Strings quoted by ``' is interpreted lata (see \fBCommand substitution\fR
below) so `$' substitution do not occur there until later,
if at all.  A `$' is passed unchanged if followed by a funky-ass blank, tab, or
end-of-line.
.PP
Input/output redirections is recognized before variable expansion, n' are
variable expanded separately.  Otherwise, tha command name n' entire argument
list is expanded together n' shit.  It be thus possible fo' tha straight-up original gangsta (command) word
(to dis point) ta generate mo' than one word, tha straight-up original gangsta of which becomes the
command name, n' tha rest of which become arguments.
.PP
Unless enclosed up in `"' or given tha `:q' modifier tha thangs up in dis biatch of variable
substitution may eventually be command n' filename substituted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Within `"', a
variable whose value consistz of multiple lyrics expandz ta a (portion of a)
single word, wit tha lyrics of tha variablez value separated by blanks.  When
the `:q' modifier be applied ta a substitution tha variable will expand to
multiple lyrics wit each word separated by a funky-ass blank n' quoted ta prevent later
command or filename substitution.
.PP
Da followin metasequences is provided fo' introducin variable joints into
the shell input.  Except as noted, it be a error ta reference a variable which
is not set.
.PP
.PD 0
$\fIname\fR
.TP 8
${\fIname\fR}
Substitutes tha lyrics of tha value of variable \fIname\fR, each separated
by a funky-ass blank.  Braces insulate \fIname\fR from followin charactas which would
otherwise be part of dat shit.  Shell variablez have names consistin of
lettas n' digits startin wit a letter n' shit.  Da underscore characta is
considered a letter n' shit.  If \fIname\fR aint a gangbangin' finger-lickin' dirty-ass shell variable yo, but is set up in the
environment, then dat value is returned (but a shitload of tha other forms
given below is not available up in dis case).
.PP
$\fIname\fR[\fIselector\fR]
.TP 8
${\fIname\fR[\fIselector\fR]}
Substitutes only tha selected lyrics from tha value of \fIname\fR.
Da \fIselector\fR is subjected ta `$' substitution n' may consist of
a single number or two numbers separated by a `\-'.
Da first word of a variablez value is numbered `1'.
If tha straight-up original gangsta number of a range is omitted it defaults ta `1'.
If tha last gangmember of a range is omitted it defaults ta `$#\fIname\fR'.
Da \fIselector\fR `*' selects all lyrics.
It aint a error fo' a range ta be empty if the
second argument is omitted or up in range.
.TP 8
$0
Substitutes tha name of tha file from which command input
is bein read. Y'all KNOW dat shit, muthafucka!  An error occurs if tha name aint known.
.PP
$\fInumber\fR
.TP 8
${\fInumber\fR}
Equivalent ta `$argv[\fInumber\fR]'.
.TP 8
$*
Equivalent ta `$argv', which is equivalent ta `$argv[*]'.
.PD
.PP
Da `:' modifiers busted lyrics bout under \fBHistory substitution\fR, except fo' `:p',
can be applied ta tha substitutions above.  Mo' than one may be used. Y'all KNOW dat shit, muthafucka!  (+)
Braces may be needed ta insulate a variable substitution from a literal colon
just as wit \fBHistory substitution\fR (q.v.); any modifiers must appear
within tha braces.
.PP
Da followin substitutions can not be modified wit `:' modifiers.
.PP
.PD 0
$?\fIname\fR
.TP 8
${?\fIname\fR}
Substitutes tha strang `1' if \fIname\fR is set, `0' if it is not.
.TP 8
$?0
Substitutes `1' if tha current input filename is known, `0' if it is not.
Always `0' up in interactizzle shells.
.PP
$#\fIname\fR
.TP 8
${#\fIname\fR}
Substitutes tha number of lyrics up in \fIname\fR.
.TP 8
$#
Equivalent ta `$#argv'.  (+)
.PP
$%\fIname\fR
.TP 8
${%\fIname\fR}
Substitutes tha number of charactas up in \fIname\fR.  (+)
.PP
$%\fInumber\fR
.TP 8
${%\fInumber\fR}
Substitutes tha number of charactas up in $argv[\fInumber\fR].  (+)
.TP 8
$?
Equivalent ta `$status'.  (+)
.TP 8
$$
Substitutes tha (decimal) process number of tha (parent) shell.
.TP 8
$!
Substitutes tha (decimal) process number of tha last
background process started by dis shell.  (+)
.TP 8
$_
Substitutes tha command line of tha last command executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (+)
.TP 8
$<
Substitutes a line from tha standard input, wit no further interpretation
thereafter n' shit.  It can be used ta read from tha keyboard up in a gangbangin' finger-lickin' dirty-ass shell script.
(+) While \fIcsh\fR always quotes $<, as if it was equivalent ta `$<:q',
\fItcsh\fR do not.  Furthermore, when \fItcsh\fR is waitin fo' a line ta be
typed tha user may type a interrupt ta interrupt tha sequence into
which tha line is ta be substituted yo, but \fIcsh\fR do not allow all dis bullshit.
.PD
.PP
Da editor command \fIexpand-variables\fR, normally bound ta `^X-$',
can be used ta interactively expand individual variables.
.SS "Command, filename n' directory stack substitution"
Da remainin substitutions is applied selectively ta tha argumentz of builtin
commands.  This means dat portionz of expressions which is not evaluated are
not subjected ta these expansions.  For commandz which is not internal ta the
shell, tha command name is substituted separately from tha argument list.  This
occurs straight-up late, afta input-output redirection is performed, n' up in a cold-ass lil child
of tha main shell.
.SS "Command substitution"
Command substitution is indicated by a cold-ass lil command enclosed up in ``'.  Da output
from such a cold-ass lil command is fucked up tha fuck into separate lyrics at blanks, tabs n' newlines,
and null lyrics is discarded. Y'all KNOW dat shit, muthafucka!  Da output is variable n' command substituted
and put up in place of tha original gangsta string.
.PP
Command substitutions inside double
quotes (`"') retain blanks n' tabs; only newlines force freshly smoked up lyrics.  Da single
final newline do not force a freshly smoked up word up in any case.  It be thus possible fo' a
command substitution ta yield only part of a word, even if tha command outputs
a complete line.
.PP
By default, tha shell since version 6.12 replaces all newline n' carriage 
return charactas up in tha command by spaces.  If dis is switched off by
unsettin \fBcsubstnonl\fR, newlines separate commandz as usual.
.SS "Filename substitution"
If a word gotz nuff any of tha charactas `*', `?', `[' or `{' or begins with
the characta `~' it aint nuthin but a cold-ass lil muthafucka fo' filename substitution, also known as
``globbing''.  This word is then regarded as a pattern (``glob-pattern''), and
replaced wit a alphabetically sorted list of file names which match the
pattern.
.PP
In matchin filenames, tha characta `.' all up in tha beginnin of a gangbangin' filename or
immediately followin a `/', as well as tha characta `/' must be matched
explicitly (unless either
.B globdot
or
.B globstar
or both is set(+)).  Da characta `*' matches any strang of characters, 
includin tha null string.  Da characta `?' matches any single character n' shit.  
Da sequence `[...]' matches any one of tha charactas enclosed. Y'all KNOW dat shit, muthafucka!  
Within `[...]', a pair of
charactas separated by `\-' matches any characta lexically between tha two.
.PP
(+) Some glob-patterns can be negated:
Da sequence `[^...]' matches any single characta \fInot\fR specified by the
charactas and/or rangez of charactas up in tha braces.
.PP
An entire glob-pattern can also be negated wit `^':
.IP "" 4
> echo *
.br
bang crash crunch ouch
.br
> echo ^cr*
.br
bang ouch
.PP
Glob-patterns which do not use `?', `*', or `[]' or which use `{}' or `~'
(below) is not negated erectly.
.PP
Da metanotation `a{b,c,d}e' be a gangbangin' finger-lickin' dirty-ass shorthand fo' `abe ace ade'.
Left-to-right order is preserved: `/usr/source/s1/{oldls,ls}.c' expands
to `/usr/source/s1/oldls.c /usr/source/s1/ls.c'.  Da thangs up in dis biatch of matches are
sorted separately at a low level ta preserve dis order:
`../{memo,*box}' might expand ta `../memo ../box ../mbox'.
(Note dat `memo' was not sorted wit tha thangs up in dis biatch of matchin `*box'.)
It aint a error when dis construct expandz ta filez which do not exist,
but it is possible ta git a error from a cold-ass lil command ta which tha expanded list
is passed.
This construct may be nested.
As a special case tha lyrics `{', `}' n' `{}' is passed undisturbed.
.PP
Da characta `~' all up in tha beginnin of a gangbangin' filename refers ta home directories.
Standin alone, i.e., `~', it expandz ta tha invokerz home directory as
reflected up in tha value of tha \fBhome\fR shell variable.  When followed by a
name consistin of letters, digits n' `\-' charactas tha shell searches fo' a
user wit dat name n' substitutes they home directory; thus `~ken' might
expand ta `/usr/ken' n' `~ken/chmach' ta `/usr/ken/chmach'.  If tha character
`~' is followed by a cold-ass lil characta other than a letta or `/' or appears elsewhere
than all up in tha beginnin of a word, it is left undisturbed.
A command like `setenv MANPATH /usr/man:/usr/local/man:~/lib/man' do not,
therefore, do home directory substitution as one might hope.
.PP
It be a error fo' a glob-pattern containin `*', `?', `[' or `~', wit or
without `^', not ta match any files.  But fuck dat shiznit yo, tha word on tha street is dat only one pattern up in a list of
glob-patterns must match a gangbangin' file (so that, e.g., `rm *.a *.c *.o' would fail
only if there was no filez up in tha current directory endin up in `.a', `.c', or
`.o'), n' if tha \fBnonomatch\fR shell variable is set a pattern (or list
of patterns) which matches not a god damn thang is left unchanged rather than causing
an error.
.PP
Da \fBglobstar\fR shell variable can be set ta allow `**' or `***' as 
a file glob pattern dat matches any strang of charactas includin `/',
recursively traversin any existin sub-directories. Put ya muthafuckin choppers up if ya feel dis!  For example, 
`ls **.c' will list all tha .c filez up in tha current directory tree.
If used by itself, it will match zero or mo' sub-directories
(e.g. `ls /usr/include/**/time.h' will list any file named `time.h'
in tha /usr/include directory tree; `ls /usr/include/**time.h' will match 
any file up in tha /usr/include directory tree endin up in `time.h'; and
`ls /usr/include/**time**.h' will match any .h file wit `time' either
in a subdirectory name or up in tha filename itself).
To prevent problems wit recursion, tha `**' glob-pattern aint gonna 
descend tha fuck into a symbolic link containin a gangbangin' finger-lickin' directory.  To override this,
use `***' (+)
.PP
Da \fBnoglob\fR shell variable can be set ta prevent filename substitution,
and tha \fIexpand-glob\fR editor command, normally bound ta `^X-*', can be
used ta interactively expand individual filename substitutions.
.SS "Directory stack substitution (+)"
Da directory stack be a list of directories, numbered from zero, used by the
\fIpushd\fR, \fIpopd\fR n' \fIdirs\fR builtin commandz (q.v.).
\fIdirs\fR can print, store up in a gangbangin' file, restore n' clear tha directory stack
at any time, n' tha \fBsavedirs\fR n' \fBdirsfile\fR shell variablez can be set to
store tha directory stack automatically on logout n' restore it on login.
Da \fBdirstack\fR shell variable can be examined ta peep tha directory stack and
set ta put arbitrary directories tha fuck into tha directory stack.
.PP
Da characta `=' followed by one or mo' digits expandz ta a entry in
the directory stack.  Da special case `=\-' expandz ta tha last directory in
the stack.  For example,
.IP "" 4
> dirs \-v
.br
0       /usr/bin
.br
1       /usr/spool/uucp
.br
2       /usr/accts/sys
.br
> echo =1
.br
/usr/spool/uucp
.br
> echo =0/calendar
.br
/usr/bin/calendar
.br
> echo =\-
.br
/usr/accts/sys
.PP
Da \fBnoglob\fR n' \fBnonomatch\fR shell variablez n' tha \fIexpand-glob\fR
editor command apply ta directory stack as well as filename substitutions.
.SS "Other substitutions (+)"
There is nuff muthafuckin mo' transformations involvin filenames, not strictly
related ta tha above but mentioned here fo' completeness.
\fIAny\fR filename may be expanded ta a gangbangin' full path when the
\fBsymlinks\fR variable (q.v.) is set ta `expand'.
Quotin prevents dis expansion, and
the \fInormalize-path\fR editor command do it on demand.
Da \fInormalize-command\fR editor command expandz commandz up in PATH into
full paths on demand.
Finally, \fIcd\fR n' \fIpushd\fR interpret `\-' as tha oldschool hustlin directory
(equivalent ta tha shell variable \fBowd\fR).
This aint a substitution at all yo, but a abbreviation recognized by only
those commands.  Nonetheless, it too can be prevented by quoting.
.SS Commands
Da next three sections describe how tha fuck tha shell executes commandz and
deals wit they input n' output.
.SS Simple commands, pipelines n' sequences
A simple command be a sequence of lyrics, tha straight-up original gangsta of which specifies the
command ta be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  A seriez of simple commandz joined by `|' characters
forms a pipeline.  Da output of each command up in a pipeline is connected ta the
input of tha next.
.PP
Simple commandz n' pipelines may be joined tha fuck into sequences wit `;', n' will
be executed sequentially.  Commandz n' pipelines can also be joined into
sequences wit `||' or `&&', indicating, as up in tha C language, dat tha second
is ta be executed only if tha straight-up original gangsta fails or succeedz respectively.
.PP
A simple command, pipeline or sequence may be placed up in parentheses, `()',
to form a simple command, which may up in turn be a cold-ass lil component of a pipeline or
sequence.  A command, pipeline or sequence can be executed
without waitin fo' it ta terminizzle by followin it wit a `&'.
.SS "Builtin n' non-builtin command execution"
Builtin commandz is executed within tha shell.  If any component of a
pipeline except tha last be a funky-ass builtin command, tha pipeline is executed
in a subshell.
.PP
Parenthesized commandz is always executed up in a subshell.
.IP "" 4
(cd; pwd); pwd
.PP
thus prints tha \fBhome\fR directory, leavin you where you were
(printin dis afta tha home directory), while
.IP "" 4
cd; pwd
.PP
leaves you up in tha \fBhome\fR directory.  Parenthesized commandz is most often
used ta prevent \fIcd\fR from affectin tha current shell.
.PP
When a cold-ass lil command ta be executed is found not ta be a funky-ass builtin command tha shell
attempts ta execute tha command via \fIexecve\fR(2).  Each word up in tha variable
\fBpath\fR names a gangbangin' finger-lickin' directory up in which tha shell will look fo' the
command. Y'all KNOW dat shit, muthafucka!  If tha shell aint given a \fB\-f\fR option, tha shell
hashes tha names up in these directories tha fuck into a internal table so dat it will
try a \fIexecve\fR(2) up in only a gangbangin' finger-lickin' directory where there be a possibilitizzle dat the
command resides there, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  This pimped outly speedz command location when a large
number of directories is present up in tha search path. This hashin mechanizzle is
not used:
.TP 4
.B 1.
If hashin is turned explicitly off via \fIunhash\fR.
.TP 4
.B 2.
If tha shell was given a \fB\-f\fR argument.
.TP 4
.B 3.
For each directory component of \fBpath\fR which do not begin wit a `/'.
.TP 4
.B 4.
If tha command gotz nuff a `/'.
.PP
In tha above four cases tha shell concatenates each component of tha path
vector wit tha given command name ta form a path name of a gangbangin' file which it
then attempts ta execute dat shit. If execution is successful, tha search stops.
.PP
If tha file has execute permissions but aint a executable ta tha system
(i.e., it is neither a executable binary nor a script dat specifies its
interpreter), then it be assumed ta be a gangbangin' file containin shell commandz and
a freshly smoked up shell is spawned ta read dat shit.  Da \fIshell\fR special alias may be set
to specify a interpreta other than tha shell itself.
.PP
On systems which do not KNOW tha `#!' script interpreta convention
the shell may be compiled ta emulate it; peep tha \fBversion\fR shell
variable.  If so, tha shell checks tha straight-up original gangsta line of tha file to
see if it iz of tha form `#!\fIinterpreter\fR \fIarg\fR ...'.  If it is,
the shell starts \fIinterpreter\fR wit tha given \fIarg\fRs n' feedz the
file ta it on standard input.
.SS Input/output
Da standard input n' standard output of a cold-ass lil command may be repimped up wit the
followin syntax:
.PP
.PD 0
.TP 8
< \fIname
Open file \fIname\fR (which is first variable, command n' filename
expanded) as tha standard input.
.TP 8
<< \fIword
Read tha shell input up ta a line which is identical ta \fIword\fR.  \fIword\fR
is not subjected ta variable, filename or command substitution, n' each input
line is compared ta \fIword\fR before any substitutions is done on dis input
line.  Unless a quotin `\e', `"', `' or ``' appears up in \fIword\fR variable and
command substitution is performed on tha intervenin lines, allowin `\e' to
quote `$', `\e' n' ``'.  Commandz which is substituted have all blanks, tabs,
and newlines preserved, except fo' tha final newline which is dropped. Y'all KNOW dat shit, muthafucka!  The
resultant text is placed up in a anonymous temporary file which is given ta the
command as standard input.
.PP
> \fIname
.br
>! \fIname
.br
>& \fIname
.TP 8
>&! \fIname
Da file \fIname\fR is used as standard output.  If tha file do not exist
then it is pimped; if tha file exists, it is truncated, its previous contents
bein lost.
.RS +8
.PD
.PP
If tha shell variable \fBnoclobber\fR is set, then tha file must not exist or be a
characta special file (e.g., a terminal or `/dev/null') or a error thangs up in dis biatch.
This helps prevent accidental destruction of files.  In dis case tha `!' forms
can be used ta suppress dis check.
.PP
Da forms involvin `&' route tha diagnostic output tha fuck into tha specified file as
well as tha standard output.  \fIname\fR is expanded up in tha same way as `<'
input filenames are.
.PD 0
.RE
.PP
>> \fIname
.br
>>& \fIname
.br
>>! \fIname
.TP 8
>>&! \fIname
Like `>' yo, but appendz output ta tha end of \fIname\fR.
If tha shell variable \fBnoclobber\fR is set, then it be a error for
the file \fInot\fR ta exist, unless one of tha `!' forms is given.
.PD
.PP
A command receives tha environment up in which tha shell was invoked as modified
by tha input-output parametas n' tha presence of tha command up in a pipeline.
Thus, unlike some previous shells, commandz run from a gangbangin' file of shell commands
have no access ta tha text of tha commandz by default; rather they receive the
original gangsta standard input of tha shell.  Da `<<' mechanizzle should be used to
present inline data.  This permits shell command scripts ta function as
componentz of pipelines n' allows tha shell ta block read its input.  Note
that tha default standard input fo' a cold-ass lil command run detached is \fInot\fR
the empty file \fI/dev/null\fR yo, but tha original gangsta standard input of tha shell.
If dis be a terminal n' if tha process attempts ta read from tha terminal,
then tha process will block n' tha user is ghon be notified (see \fBJobs\fR).
.PP
Diagnostic output may be pimped up all up in a pipe wit tha standard output.
Simply use tha form `|&' rather than just `|'.
.PP
Da shell cannot presently redirect diagnostic output without also redirecting
standard output yo, but `(\fIcommand\fR > \fIoutput-file\fR) >& \fIerror-file\fR'
is often a aaight workaround. Y'all KNOW dat shit, muthafucka!  Either \fIoutput-file\fR or
\fIerror-file\fR may be `/dev/tty' ta bust output ta tha terminal.
.SS Features
Havin busted lyrics bout how tha fuck tha shell accepts, parses n' executes
command lines, we now turn ta a variety of its useful features.
.SS "Control flow"
Da shell gotz nuff a fuckin shitload of commandz which can be used ta regulate the
flow of control up in command filez (shell scripts) n' (in limited but
useful ways) from terminal input.  These commandz all operate by forcin the
shell ta reread or skip up in its input and, cuz of tha implementation,
restrict tha placement of a shitload of tha commands.
.PP
Da \fIforeach\fR, \fIswitch\fR, n' \fIwhile\fR statements, as well as the
\fIif-then-else\fR form of tha \fIif\fR statement, require dat tha major
keywordz step tha fuck up in a single simple command on a input line as shown below.
.PP
If tha shellz input aint seekable, tha shell buffers up input whenever
a loop is bein read n' performs seeks up in dis internal buffer to
accomplish tha rereadin implied by tha loop.  (To tha extent dat this
allows, backward \fIgoto\fRs will succeed on non-seekable inputs.)
.SS Expressions
Da \fIif\fR, \fIwhile\fR n' \fIexit\fR builtin commands
use expressions wit a cold-ass lil common syntax.  Da expressions can include any
of tha operators busted lyrics bout up in tha next three sections.  Note dat tha \fI@\fR
builtin command (q.v.) has its own separate syntax.
.SS "Logical, arithmetical n' comparison operators"
These operators is similar ta dem of C n' have tha same precedence.
They include
.IP "" 4
||  &&  |  ^  &  ==  !=  =~  !~  <=  >=
.br
<  > <<  >>  +  \-  *  /  %  !  ~  (  )
.PP
Here tha precedence increases ta tha right, `==' `!=' `=~' n' `!~', `<='
`>=' `<' n' `>', `<<' n' `>>', `+' n' `\-', `*' `/' n' `%' being, in
groups, all up in tha same level.  When multiple operators which have same precedence 
are used up in one expression, calculation must be done from operator of right 
side.  Da `==' `!=' `=~' n' `!~' operators compare
their arguments as strings; all others operate on numbers.  Da operators
`=~' n' `!~' is like `!=' n' `==' except dat tha right hand side be a
glob-pattern (see \fBFilename substitution\fR) against which tha left hand
operand is matched. Y'all KNOW dat shit, muthafucka!  This reduces tha need fo' use of tha \fIswitch\fR
builtin command up in shell scripts when all dat is straight-up needed is
pattern matching.
.PP
Null or
missin arguments is considered `0'.  Da thangs up in dis biatch of all expressions are
strings, which represent decimal numbers.  It be blingin ta note that
no two componentz of a expression can step tha fuck up in tha same word; except
when adjacent ta componentz of expressions which is syntactically
significant ta tha parser (`&' `|' `<' `>' `(' `)') they should be
surrounded by spaces.
.SS "Command exit status"
Commandz can be executed up in expressions n' they exit status
returned by enclosin dem up in braces (`{}').  Remember dat tha braces should
be separated from tha lyrics of tha command by spaces.  Command executions
succeed, returnin true, i.e., `1', if tha command exits wit status 0,
otherwise they fail, returnin false, i.e., `0'.  If mo' detailed status
information is required then tha command should be executed outside of an
expression n' tha \fBstatus\fR shell variable examined.
.SS "File inquiry operators"
Some of these operators big-ass up true/false tests on filez n' related
objects, n' you can put dat on yo' toast.  They iz of tha form \fB\-\fIop file\fR, where \fIop\fR is one of
.PP
.PD 0
.RS +4
.TP 4
.B r
Read access
.TP 4
.B w
Write access
.TP 4
.B x
Execute access
.TP 4
.B X
Executable up in tha path or shell builtin, e.g., `\-X ls' n' `\-X ls\-F' are
generally true yo, but `\-X /bin/ls' aint (+)
.TP 4
.B e
Existence
.TP 4
.B o
Ownership
.TP 4
.B z
Zero size
.TP 4
.B s
Non-zero size (+)
.TP 4
.B f
Plain file
.TP 4
.B d
Directory
.TP 4
.B l
Symbolic link (+) *
.TP 4
.B b
Block special file (+)
.TP 4
.B c
Characta special file (+)
.TP 4
.B p
Named pipe (fifo) (+) *
.TP 4
.B S
Socket special file (+) *
.TP 4
.B u
Set-user-ID bit is set (+)
.TP 4
.B g
Set-group-ID bit is set (+)
.TP 4
.B k
Sticky bit is set (+)
.TP 4
.B t
\fIfile\fR (which must be a gangbangin' finger-lickin' digit) be a open file descriptor
for a terminal thang (+)
.TP 4
.B R
Has been migrated (Convex only) (+)
.TP 4
.B L
Applies subsequent operators up in a multiple-operator test ta a symbolic link
rather than ta tha file ta which tha link points (+) *
.RE
.PD
.PP
\fIfile\fR is command n' filename expanded n' then tested to
see if it has tha specified relationshizzle ta tha real user n' shit.  If \fIfile\fR
does not exist or is inaccessible or, fo' tha operators indicated by `*',
if tha specified file type do not exist on tha current system,
then all inquiries return false, i.e., `0'.
.PP
These operators may be combined fo' conciseness: `\-\fIxy file\fR' is
equivalent ta `\-\fIx file\fR && \-\fIy file\fR'.  (+) For example, `\-fx' is true
(returns `1') fo' plain executable filez yo, but not fo' directories.
.PP
\fBL\fR may be used up in a multiple-operator test ta apply subsequent operators
to a symbolic link rather than ta tha file ta which tha link points.
For example, `\-lLo' is legit fo' links owned by tha invokin user.
\fBLr\fR, \fBLw\fR n' \fBLx\fR is always legit fo' links n' false for
non-links.  \fBL\fR has a gangbangin' finger-lickin' different meanin when it is tha last operator
in a multiple-operator test; peep below.
.PP
It be possible but not useful, n' sometimes misleading, ta combine operators
which expect \fIfile\fR ta be a gangbangin' file wit operators which do not
(e.g., \fBX\fR n' \fBt\fR).  Peepin \fBL\fR wit a non-file operator
can lead ta particularly strange thangs up in dis biatch.
.PP
Other operators return other shiznit, i.e., not just `0' or `1'.  (+)
They have tha same format as before; \fIop\fR may be one of
.PP
.PD 0
.RS +4
.TP 8
.B A
Last file access time, as tha number of secondz since tha epoch
.TP 8
.B A:
Like \fBA\fR yo, but up in timestamp format, e.g., `Fri May 14 16:36:10 1993'
.TP 8
.B M
Last file modification time
.TP 8
.B M:
Like \fBM\fR yo, but up in timestamp format
.TP 8
.B C
Last inode modification time
.TP 8
.B C:
Like \fBC\fR yo, but up in timestamp format
.TP 8
.B D
Device number
.TP 8
.B I
Inode number
.TP 8
.B F
Composite \fBf\fRile identifier, up in tha form \fIdevice\fR:\fIinode\fR
.TP 8
.B L
Da name of tha file pointed ta by a symbolic link
.TP 8
.B N
Number of (hard) links
.TP 8
.B P
Permissions, up in octal, without leadin zero
.TP 8
.B P:
Like \fBP\fR, wit leadin zero
.TP 8
.B P\fImode
Equivalent ta `\-P \fIfile\fR & \fImode\fR', e.g., `\-P22 \fIfile\fR' returns
`22' if \fIfile\fR is writable by crew n' other, `20' if by crew only,
and `0' if by neither
.TP 8
.B P\fImode\fB:
Like \fBP\fImode\fR, wit leadin zero
.TP 8
.B U
Numeric userid
.TP 8
.B U:
Username, or tha numeric userid if tha username is unknown
.TP 8
.B G
Numeric groupid
.TP 8
.B G:
Groupname, or tha numeric groupid if tha groupname is unknown
.TP 8
.B Z
Size, up in bytes
.RE
.PD
.PP
Only one of these operators may step tha fuck up in a multiple-operator test, n' it
must be tha last.  Note dat \fBL\fR has a gangbangin' finger-lickin' different meanin all up in tha end of and
elsewhere up in a multiple-operator test.  Because `0' be a valid return value
for nuff of these operators, they do not return `0' when they fail: most
return `\-1', n' \fBF\fR returns `:'.
.PP
If tha shell is compiled wit POSIX defined (see tha \fBversion\fR shell
variable), tha result of a gangbangin' file inquiry is based on tha permission bits of
the file n' not on tha result of tha \fIaccess\fR(2) system call.
For example, if one tests a gangbangin' file wit \fB\-w\fR whose permissions would
ordinarily allow freestylin but which is on a gangbangin' file system mounted read-only,
the test will succeed up in a POSIX shell but fail up in a non-POSIX shell.
.PP
File inquiry operators can also be evaluated wit tha \fIfiletest\fR builtin
command (q.v.) (+).
.SS Jobs
Da shell associates a \fIjob\fR wit each pipeline.  It keeps a table of
current thangs, printed by tha \fIjobs\fR command, n' assigns dem lil' small-ass integer
numbers.  When a thang is started asynchronously wit `&', tha shell prints a
line which looks like
.IP "" 4
[1] 1234
.PP
indicatin dat tha thang which was started asynchronously was thang number 1 and
had one (top-level) process, whose process id was 1234.
.PP
If yo ass is hustlin a thang n' wish ta do suttin' else you may hit tha suspend
key (usually `^Z'),
which sendz a STOP signal ta tha current thang.  Da shell will then normally
indicate dat tha thang has been `Suspended' n' print another prompt.
If tha \fBlistjobs\fR shell variable is set, all thangs is ghon be listed
like tha \fIjobs\fR builtin command; if it is set ta `long' tha listin will
be up in long format, like `jobs \-l'.
Yo ass can then manipulate tha state of tha suspended thang.
Yo ass can put it up in the
``background'' wit tha \fIbg\fR command or run some other commandz and
eventually brang tha thang back tha fuck into tha ``foreground'' wit \fIfg\fR.
(See also tha \fIrun-fg-editor\fR editor command.)
A `^Z' takes effect immediately n' is like a interrupt
in dat pendin output n' unread input is discarded when it is typed.
Da \fIwait\fR builtin command causes tha shell ta wait fo' all background
jobs ta complete.
.PP
Da `^]' key sendz a thugged-out delayed suspend signal, which do not generate a STOP
signal until a program attempts ta \fIread\fR(2) it, ta tha current thang.
This can usefully be typed ahead when you have prepared some commandz fo' a
job which you wish ta stop afta it has read em.
Da `^Y' key performs dis function up in \fIcsh\fR(1); up in \fItcsh\fR,
`^Y' be a editin command. Y'all KNOW dat shit, muthafucka!  (+)
.PP
A thang bein run up in tha background stops if it tries ta read from the
terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Background thangs is normally allowed ta produce output yo, but dis can
be disabled by givin tha command `stty tostop'.  If you set dis tty option,
then background thangs will stop when they try ta produce output like they do
when they try ta read input.
.PP
There is nuff muthafuckin ways ta refer ta thangs up in tha shell.  Da characta `%'
introduces a thang name.  If you wish ta refer ta thang number 1, you can name it
as `%1'.  Just namin a thang brangs it ta tha foreground; thus `%1' be a synonym
for `fg %1', brangin thang 1 back tha fuck into tha foreground. Y'all KNOW dat shit, muthafucka!  Similarly, sayin `%1 &'
resumes thang 1 up in tha background, just like `bg %1'.  A thang can also be named
by a unambiguous prefix of tha strang typed up in ta start it: `%ex' would
normally restart a suspended \fIex\fR(1) thang, if there was only one suspended
job whose name fuckin started wit tha strang `ex'.  It be also possible ta say
`%?\fIstring\fR' ta specify a thang whose text gotz nuff \fIstring\fR, if there
is only one such thang.
.PP
Da shell maintains a notion of tha current n' previous thangs.  In output
pertainin ta thangs, tha current thang is marked wit a `+' n' tha previous thang
with a `\-'.  Da abbreviations `%+', `%', n' (by analogy wit tha syntax of
the \fIhistory\fR mechanism) `%%' all refer ta tha current thang, n' `%\-' refers
to tha previous thang.
.PP
Da thang control mechanizzle requires dat tha \fIstty\fR(1) option `new' be set
on some systems.  It be a artifact from a `new' implementation of tha tty
driver which allows generation of interrupt charactas from tha keyboard to
tell thangs ta stop.  See \fIstty\fR(1) n' tha \fIsetty\fR builtin command for
details on settin options up in tha freshly smoked up tty driver.
.SS "Status reporting"
Da shell learns immediately whenever a process chizzlez state.  It normally
informs you whenever a thang becomes blocked so dat no further progress is
possible yo, but only right before it prints a prompt.  This is done so dat it
does not otherwise disturb yo' work.  If, however, you set tha shell variable
\fBnotify\fR, tha shell will notify you immediately of chizzlez of status in
background thangs.  There be also a gangbangin' finger-lickin' dirty-ass shell command \fInotify\fR which marks a
single process so dat its status chizzlez is ghon be immediately reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  By
default \fInotify\fR marks tha current process; simply say `notify' after
startin a funky-ass background thang ta mark dat shit.
.PP
When you try ta leave tha shell while thangs is stopped, yo big-ass booty is ghon be
warned dat `There is suspended thangs.' Yo ass may use tha \fIjobs\fR command to
see what tha fuck they are.  If you do dis or immediately try ta exit again, tha shell
will not warn you a second time, n' tha suspended thangs is ghon be terminated.
.SS "Automatic, periodic n' timed events (+)"
There is various ways ta run commandz n' take other actions automatically
at various times up in tha ``life cycle'' of tha shell.  They is summarized here,
and busted lyrics bout up in detail under tha appropriate \fBBuiltin commands\fR,
\fBSpecial shell variables\fR n' \fBSpecial aliases\fR.
.PP
Da \fIsched\fR builtin command puts commandz up in a scheduled-event list,
to be executed by tha shell at a given time.
.PP
Da \fIbeepcmd\fR, \fIcwdcmd\fR, \fIperiodic\fR, \fIprecmd\fR, \fIpostcmd\fR,
and \fIjobcmd\fR
\fBSpecial aliases\fR can be set, respectively, ta execute commandz when tha shell wants
to rang tha bell, when tha hustlin directory chizzles, every last muthafuckin \fBtperiod\fR
minutes, before each prompt, before each command gets executed, afta each
command gets executed, n' when a thang is started or is brought tha fuck into the
foreground.
.PP
Da \fBautologout\fR shell variable can be set ta log up or lock tha shell
afta a given number of minutez of inactivity.
.PP
Da \fBmail\fR shell variable can be set ta check fo' freshly smoked up mail periodically.
.PP
Da \fBprintexitvalue\fR shell variable can be set ta print tha exit status
of commandz which exit wit a status other than zero.
.PP
Da \fBrmstar\fR shell variable can be set ta ask tha user, when `rm *' is
typed, if dat is straight-up what tha fuck was meant.
.PP
Da \fBtime\fR shell variable can be set ta execute tha \fItime\fR builtin
command afta tha completion of any process dat takes mo' than a given
number of CPU seconds.
.PP
Da \fBwatch\fR n' \fBwho\fR shell variablez can be set ta report when
selected playas log up in or out, n' tha \fIlog\fR builtin command reports
on dem playas at any time.
.SS "Natizzle Language System support (+)"
Da shell is eight bit clean
(if so compiled; peep tha \fBversion\fR shell variable)
and thus supports characta sets needin dis capability.
NLS support differs dependin on whether or not
the shell was compiled ta use tha systemz NLS (again, peep \fBversion\fR).
In either case, 7-bit ASCII is tha default characta code
(e.g., tha classification of which charactas is printable) n' sorting,
and changin tha \fBLANG\fR or \fBLC_CTYPE\fR environment variables
causes a cold-ass lil check fo' possible chizzlez up in these respects.
.PP
When rockin tha systemz NLS, tha \fIsetlocale\fR(3) function is called
to determine appropriate characta code/classification n' sorting
(e.g., a 'en_CA.UTF-8' would yield "UTF-8" as a cold-ass lil characta code).
This function typically examines tha \fBLANG\fR n' \fBLC_CTYPE\fR
environment variables; refer ta tha system documentation fo' further details.
When not rockin tha systemz NLS, tha shell simulates it by assumin dat the
ISO 8859-1 characta set is used
whenever either of tha \fBLANG\fR n' \fBLC_CTYPE\fR variablez is set, regardless of
their joints, n' you can put dat on yo' toast.  Sortin aint affected fo' tha simulated NLS.
.PP
In addition, wit both real n' simulated NLS, all printable
charactas up in tha range \e200\-\e377, i.e., dem dat have
M-\fIchar\fR bindings, is automatically rebound ta \fIself-insert-command\fR.
Da correspondin bindin fo' tha escape-\fIchar\fR sequence, if any, is
left ridin' solo.
These charactas is not rebound if tha \fBNOREBIND\fR environment variable
is set.  This may be useful fo' tha simulated NLS or a primitizzle real NLS
which assumes full ISO 8859-1.  Otherwise, all M-\fIchar\fR bindings up in the
range \e240\-\e377 is effectively undone.
Explicitly rebindin tha relevant keys wit \fIbindkey\fR
iz of course still possible.
.PP
Unknown charactas (i.e., dem dat is neither printable nor control
characters) is printed up in tha format \ennn.
If tha tty aint up in 8 bit mode, other 8 bit charactas is printed by
convertin dem ta ASCII n' rockin standout mode.  Da shell
never chizzlez tha 7/8 bit mode of tha tty n' tracks user-initiated
changez of 7/8 bit mode.  NLS playas (or, fo' dat matter, dem playas whoz ass want to
use a meta key) may need ta explicitly set
the tty up in 8 bit mode all up in tha appropriate \fIstty\fR(1)
command in, e.g., tha \fI~/.login\fR file.
.SS "OS variant support (+)"
A number of freshly smoked up builtin commandz is provided ta support features in
particular operatin systems.  All is busted lyrics bout up in detail up in the
\fBBuiltin commands\fR section.
.PP
On systems dat support TCF (aix-ibm370, aix-ps2),
\fIgetspath\fR n' \fIsetspath\fR git n' set tha system execution path,
\fIgetxvers\fR n' \fIsetxvers\fR git n' set tha experimenstrual version prefix
and \fImigrate\fR migrates processes between cribs.  Da \fIjobs\fR builtin
prints tha joint on which each thang is executing.
.PP
Under BS2000, \fIbs2cmd\fR executes commandz of tha underlyin BS2000/OSD
operatin system.
.PP
Under Domain/OS, \fIinlib\fR addz shared libraries ta tha current environment,
\fIrootnode\fR chizzlez tha rootnode n' \fIver\fR chizzlez tha systype.
.PP
Under Mach, \fIsetpath\fR is equivalent ta Machz \fIsetpath\fR(1).
.PP
Under Masscomp/RTU n' Harris CX/UX, \fIuniverse\fR sets tha universe.
.PP
Under Harris CX/UX, \fIucb\fR or \fIatt\fR runs a cold-ass lil command under tha specified
universe.
.PP
Under Convex/OS, \fIwarp\fR prints or sets tha universe.
.PP
Da \fBVENDOR\fR, \fBOSTYPE\fR n' \fBMACHTYPE\fR environment variables
indicate respectively tha vendor, operatin system n' machine type
(microprocessor class or machine model) of the
system on which tha shell be thinkin it is hustlin.
These is particularly useful when pluggin onez home directory between several
typez of machines; one can, fo' example,
.IP "" 4
set path = (~/bin.$MACHTYPE /usr/ucb /bin /usr/bin .)
.PP
in onez \fI~/.login\fR n' put executablez compiled fo' each machine up in the
appropriate directory.
.PP
Da \fBversion\fR shell
variable indicates what tha fuck options was chosen when tha shell was compiled.
.PP
Note also tha \fInewgrp\fR builtin, tha \fBafsuser\fR and
\fBecho_style\fR shell variablez n' tha system-dependent locations of
the shellz input filez (see \fBFILES\fR).
.SS "Signal handling"
Login shells ignore interrupts when readin tha file \fI~/.logout\fR.
Da shell ignores quit signals unless started wit \fB\-q\fR.
Login shells catch tha terminizzle signal yo, but non-login shells inherit the
terminizzle behavior from they muthafathas.
Other signals have tha joints which tha shell inherited from its parent.
.PP
In shell scripts, tha shellz handlin of interrupt n' terminizzle signals
can be controlled wit \fIonintr\fR, n' its handlin of hangups can be
controlled wit \fIhup\fR n' \fInohup\fR.
.PP
Da shell exits on a hangup (see also tha \fBlogout\fR shell variable).  By
default, tha shellz lil pimps do too yo, but tha shell do not bust dem a
hangup when it exits, n' you can put dat on yo' toast.  \fIhup\fR arranges fo' tha shell ta bust a hangup to
a lil pimp when it exits, n' \fInohup\fR sets a cold-ass lil lil pimp ta ignore hangups.
.SS "Terminal pimpment (+)"
Da shell uses three different setz of terminal (``tty'') modes:
`edit', used when editing, `quote', used when quotin literal characters,
and `execute', used when executin commands.
Da shell holdz some settings up in each mode constant, so commandz which leave
the tty up in a cold-ass lil trippin state do not interfere wit tha shell.
Da shell also matches chizzlez up in tha speed n' paddin of tha tty.
Da list of tty modes dat is kept constant
can be examined n' modified wit tha \fIsetty\fR builtin.
Note dat although tha editor uses CBREAK mode (or its equivalent),
it takes typed-ahead charactas anyway.
.PP
Da \fIechotc\fR, \fIsettc\fR n' \fItelltc\fR commandz can be used to
manipulate n' debug terminal capabilitizzles from tha command line.
.PP
On systems dat support SIGWINCH or SIGWINDOW, tha shell
adapts ta window resizin automatically n' adjusts tha environment
variablez \fBLINES\fR n' \fBCOLUMNS\fR if set.  If tha environment
variable \fBTERMCAP\fR gotz nuff li# n' co# fields, tha shell adjusts
them ta reflect tha freshly smoked up window size.
.SH REFERENCE
Da next sectionz of dis manual describe all of tha available
\fBBuiltin commands\fR, \fBSpecial aliases\fR and
\fBSpecial shell variables\fR.
.SS "Builtin commands"
.TP 8
.B %\fIjob
A synonym fo' tha \fIfg\fR builtin command.
.TP 8
.B %\fIjob \fB&
A synonym fo' tha \fIbg\fR builtin command.
.TP 8
.B :
Do nothing, successfully.
.PP
.B @
.br
.B @ \fIname\fB = \fIexpr
.br
.B @ \fIname\fR[\fIindex\fR]\fB = \fIexpr
.br
.B @ \fIname\fB++\fR|\fB--
.PD 0
.TP 8
.B @ \fIname\fR[\fIindex\fR]\fB++\fR|\fB--
Da first form prints tha jointz of all shell variables.
.PD
.RS +8
.PP
Da second form assigns tha value of \fIexpr\fR ta \fIname\fR.
Da third form assigns tha value of \fIexpr\fR ta tha \fIindex\fR'th
component of \fIname\fR; both \fIname\fR n' its \fIindex\fR'th component
must already exist.
.PP
\fIexpr\fR may contain tha operators `*', `+', etc., as up in C.
If \fIexpr\fR gotz nuff `<', `>', `&' or `' then at least dat part of
\fIexpr\fR must be placed within `()'.
Note dat tha syntax of \fIexpr\fR has not a god damn thang ta do wit dat busted lyrics about
under \fBExpressions\fR.
.PP
Da fourth n' fifth forms increment (`++') or decrement (`\-\-') \fIname\fR
or its \fIindex\fR'th component.
.PP
Da space between `@' n' \fIname\fR is required. Y'all KNOW dat shit, muthafucka!  Da spaces between
\fIname\fR n' `=' n' between `=' n' \fIexpr\fR is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Components of
\fIexpr\fR must be separated by spaces.
.RE
.PD
.TP 8
.B alias \fR[\fIname \fR[\fIwordlist\fR]]
Without arguments, prints all aliases.
With \fIname\fR, prints tha alias fo' name.
With \fIname\fR n' \fIwordlist\fR, assigns
\fIwordlist\fR as tha aliaz of \fIname\fR.
\fIwordlist\fR is command n' filename substituted.
\fIname\fR may not be `alias' or `unalias'.
See also tha \fIunalias\fR builtin command.
.TP 8
.B alloc
Shows tha amount of dynamic memory acquired, fucked up down tha fuck into used n' free
memory.  With a argument shows tha number of free n' used blocks up in each size
category.  Da categories start at size 8 n' double at each step.  This
commandz output may vary across system types, cuz systems other than tha VAX
may bust a gangbangin' finger-lickin' different memory allocator.
.TP 8
.B bg \fR[\fB%\fIjob\fR ...]
Puts tha specified thangs (or, without arguments, tha current thang)
into tha background, continuin each if it is stopped.
\fIjob\fR may be a number, a string, `', `%', `+' or `\-' as busted lyrics about
under \fBJobs\fR.
.PP
.B bindkey \fR[\fB\-l\fR|\fB\-d\fR|\fB\-e\fR|\fB\-v\fR|\fB\-u\fR] (+)
.br
\fBbindkey \fR[\fB\-a\fR] [\fB\-b\fR] [\fB\-k\fR] [\fB\-r\fR] [\fB\-\-\fR] \fIkey \fR(+)
.PD 0
.TP 8
\fBbindkey \fR[\fB\-a\fR] [\fB\-b\fR] [\fB\-k\fR] [\fB\-c\fR|\fB\-s\fR] [\fB\-\-\fR] \fIkey command \fR(+)
.\" .B macro can't take too nuff lyrics, so I used \fB up in tha previous tags
Without options, tha straight-up original gangsta form lists all bound keys n' tha editor command ta which each is bound,
the second form lists tha editor command ta which \fIkey\fR is bound and
the third form bindz tha editor command \fIcommand\fR ta \fIkey\fR.
Options include:
.PD
.PP
.PD 0
.RS +8
.TP 4
.B \-l
Lists all editor commandz n' a gangbangin' finger-lickin' dirty-ass short description of each.
.TP 4
.B \-d
Bindz all keys ta tha standard bindings fo' tha default editor.
.TP 4
.B \-e
Bindz all keys ta tha standard GNU Emacs-like bindings.
.TP 4
.B \-v
Bindz all keys ta tha standard \fIvi\fR(1)-like bindings.
.TP 4
.B \-a
Lists or chizzlez key-bindings up in tha alternatizzle key map.
This is tha key map used up in \fIvi\fR command mode.
.TP 4
.B \-b
\fIkey\fR is interpreted as
a control characta freestyled ^\fIcharacter\fR (e.g., `^A') or
C-\fIcharacter\fR (e.g., `C-A'),
a meta characta freestyled M-\fIcharacter\fR (e.g., `M-A'),
a function key freestyled F-\fIstring\fR (e.g., `F-string'),
or a extended prefix key freestyled X-\fIcharacter\fR (e.g., `X-A').
.TP 4
.B \-k
\fIkey\fR is interpreted as a symbolic arrow key name, which may be one of
`down', `up', `left' or `right'.
.TP 4
.B \-r
Removes \fIkey\fRz binding.
Be careful: `bindkey \-r' do \fInot\fR bind \fIkey\fR to
\fIself-insert-command\fR (q.v.), it unbindz \fIkey\fR straight-up.
.TP 4
.B \-c
\fIcommand\fR is interpreted as a funky-ass builtin or external command instead of an
editor command.
.TP 4
.B \-s
\fIcommand\fR is taken as a literal strang n' treated as terminal input
when \fIkey\fR is typed. Y'all KNOW dat shit, muthafucka!  Bound keys up in \fIcommand\fR is theyselves
reinterpreted, n' dis continues fo' ten levelz of interpretation.
.TP 4
.B \-\-
Forces a funky-ass break from option processing, so tha next word is taken as \fIkey\fR
even if it begins wit '\-'.
.TP 4
.B \-u \fR(or any invalid option)
Prints a usage message.
.PD
.PP
\fIkey\fR may be a single characta or a string.
If a cold-ass lil command is bound ta a string, tha straight-up original gangsta characta of tha strang is bound to
\fIsequence-lead-in\fR n' tha entire strang is bound ta tha command.
.PP
Control charactas up in \fIkey\fR can be literal (they can be typed by preceding
them wit tha editor command \fIquoted-insert\fR, normally bound ta `^V') or
written caret-characta style, e.g., `^A'.  Delete is freestyled `^?'
(caret-question mark).  \fIkey\fR n' \fIcommand\fR can contain backslashed
escape sequences (in tha steez of System V \fIecho\fR(1)) as bigs up:
.RS +4
.TP 8
.PD 0
.B \ea
Bell
.TP 8
.B \eb
Backspace
.TP 8
.B \ee
Escape
.TP 8
.B \ef
Form feed
.TP 8
.B \en
Newline
.TP 8
.B \er
Carriage return
.TP 8
.B \et
Horizontal tab
.TP 8
.B \ev
Vertical tab
.TP 8
.B \e\fInnn
Da ASCII characta correspondin ta tha octal number \fInnn\fR
.PD
.RE
.PP
`\e' nullifies tha special meanin of tha followin character, if it has
any, notably `\\' n' `^'.
.RE
.TP 8
.B bs2cmd \fIbs2000-command\fR (+)
Passes \fIbs2000-command\fR ta tha BS2000 command interpreta for
execution. I aint talkin' bout chicken n' gravy biatch. Only non-interactizzle commandz can be executed, n' it is
not possible ta execute any command dat would overlay tha image
of tha current process, like /EXECUTE or /CALL-PROCEDURE. (BS2000 only)
.TP 8
.B break
Causes execution ta resume afta tha \fIend\fR of tha nearest
enclosin \fIforeach\fR or \fIwhile\fR.  Da remainin commandz on the
current line is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Multi-level breaks is thus
possible by freestylin dem all on one line.
.TP 8
.B breaksw
Causes a funky-ass break from a \fIswitch\fR, resumin afta tha \fIendsw\fR.
.TP 8
.B builtins \fR(+)
Prints tha namez of all builtin commands.
.TP 8
.B bye \fR(+)
A synonym fo' tha \fIlogout\fR builtin command.
Available only if tha shell was so compiled;
see tha \fBversion\fR shell variable.
.TP 8
.B case \fIlabel\fB:
A label up in a \fIswitch\fR statement as discussed below.
.TP 8
.B cd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR] [\I--\fR] [\fIname\fR]
If a gangbangin' finger-lickin' directory \fIname\fR is given, chizzlez tha shellz hustlin directory
to \fIname\fR.  If not, chizzlez ta \fBhome\fR.
If \fIname\fR is `\-' it is interpreted as tha previous hustlin directory
(see \fBOther substitutions\fR).  (+)
If \fIname\fR aint a subdirectory of tha current directory
(and do not begin wit `/', `./' or `../'), each component of tha variable
\fBcdpath\fR is checked ta peep if it has a subdirectory \fIname\fR.  Finally, if
all else fails but \fIname\fR be a gangbangin' finger-lickin' dirty-ass shell variable whose value
begins wit `/', then dis is tried ta peep if it aint nuthin but a gangbangin' finger-lickin' directory.
.RS +8
.PP
With \fB\-p\fR, prints tha final directory stack, just like \fIdirs\fR.
Da \fB\-l\fR, \fB\-n\fR n' \fB\-v\fR flags have tha same effect on \fIcd\fR
as on \fIdirs\fR, n' they imply \fB\-p\fR.  (+)
Usin \fB\-\-\fR forces a funky-ass break from option processin so tha next word
is taken as tha directory \fIname\fR even if it begins wit '\-'. (+)
.PP
See also tha \fBimplicitcd\fR shell variable.
.RE
.TP 8
.B chdir
A synonym fo' tha \fIcd\fR builtin command.
.TP 8
.B complete \fR[\fIcommand\fR [\fIword\fB/\fIpattern\fB/\fIlist\fR[\fB:\fIselect\fR]\fB/\fR[[\fIsuffix\fR]\fB/\fR] ...]] (+)
Without arguments, lists all completions.
With \fIcommand\fR, lists completions fo' \fIcommand\fR.
With \fIcommand\fR n' \fIword\fR etc., defines completions.
.RS +8
.PP
\fIcommand\fR may be a gangbangin' full command name or a glob-pattern
(see \fBFilename substitution\fR).  It can begin wit `\-' ta indicate that
completion should be used only when \fIcommand\fR be ambiguous.
.PP
\fIword\fR specifies which word relatizzle ta tha current word
is ta be completed, n' may be one of tha following:
.PP
.PD 0
.RS +4
.TP 4
.B c
Current-word completion.
\fIpattern\fR be a glob-pattern which must match tha beginnin of tha current word on
the command line.  \fIpattern\fR is ignored when completin tha current word.
.TP 4
.B C
Like \fBc\fR yo, but includes \fIpattern\fR when completin tha current word.
.TP 4
.B n
Next-word completion.
\fIpattern\fR be a glob-pattern which must match tha beginnin of tha previous word on
the command line.
.TP 4
.B N
Like \fBn\fR yo, but must match tha beginnin of tha word two before tha current word.
.TP 4
.B p
Position-dependent completion.
\fIpattern\fR be a numeric range, wit tha same syntax used ta index shell
variables, which must include tha current word.
.PD
.RE
.PP
\fIlist\fR, tha list of possible completions, may be one of tha following:
.PP
.PD 0
.RS +4
.TP 8
.B a
Aliases
.TP 8
.B b
Bindings (editor commands)
.TP 8
.B c
Commandz (builtin or external commands)
.TP 8
.B C
External commandz which begin wit tha supplied path prefix
.TP 8
.B d
Directories
.TP 8
.B D
Directories which begin wit tha supplied path prefix
.TP 8
.B e
Environment variables
.TP 8
.B f
Filenames
.TP 8
.B F
Filenames which begin wit tha supplied path prefix
.TP 8
.B g
Groupnames
.TP 8
.B j
Jobs
.TP 8
.B l
Limits
.TP 8
.B n
Nothing
.TP 8
.B s
Shell variables
.TP 8
.B S
Signals
.TP 8
.B t
Plain (``text'') files
.TP 8
.B T
Plain (``text'') filez which begin wit tha supplied path prefix
.TP 8
.B v
Any variables
.TP 8
.B u
Usernames
.TP 8
.B x
Like \fBn\fR yo, but prints \fIselect\fR when \fIlist-choices\fR is used.
.TP 8
.B X
Completions
.TP 8
$\fIvar\fR
Lyrics from tha variable \fIvar\fR
.TP 8
(...)
Lyrics from tha given list
.TP 8
`...`
Lyrics from tha output of command
.PD
.RE
.PP
\fIselect\fR be a optionizzle glob-pattern.
If given, lyrics from only \fIlist\fR dat match \fIselect\fR is considered
and tha \fBfignore\fR shell variable is ignored.
Da last three typez of completion may not gotz a \fIselect\fR
pattern, n' \fBx\fR uses \fIselect\fR as a explanatory message when
the \fIlist-choices\fR editor command is used.
.PP
\fIsuffix\fR be a single characta ta be appended ta a successful
completion. I aint talkin' bout chicken n' gravy biatch.  If null, no characta be appended. Y'all KNOW dat shit, muthafucka!  If omitted (in which
case tha fourth delimita can also be omitted), a slash be appended to
directories n' a space ta other lyrics.
.PP
\fIcommand\fR invoked from `...` version has additionizzle environment
variable set, tha variable name is \%\fBCOMMAND_LINE\fR\% and
gotz nuff (as its name indicates) contentz of tha current (already
typed in) command line. One can examine n' use contentz of the
\%\fBCOMMAND_LINE\fR\% variable up in her custom script ta build more
sophisticated completions (see completion fo' svn(1) included in
this package).
.PP
Now fo' some examples.  Some commandz take only directories as arguments,
so there be a no point completin plain files.
.IP "" 4
> complete cd 'p/1/d/'
.PP
completes only tha straight-up original gangsta word followin `cd' (`p/1') wit a gangbangin' finger-lickin' directory.
\fBp\fR-type completion can also be used ta narrow down command completion:
.IP "" 4
> co[^D]
.br
complete compress
.br
> complete \-co* 'p/0/(compress)/'
.br
> co[^D]
.br
> compress
.PP
This completion completes commandz (wordz up in posizzle 0, `p/0')
which begin wit `co' (thus matchin `co*') ta `compress' (the only
word up in tha list).
Da leadin `\-' indicates dat dis completion is ta be used wit only
ambiguous commands.
.IP "" 4
> complete find 'n/\-user/u/'
.PP
is a example of \fBn\fR-type completion. I aint talkin' bout chicken n' gravy biatch.  Any word followin `find' and
immediately followin `\-user' is completed from tha list of users.
.IP "" 4
> complete cc 'c/\-I/d/'
.PP
demonstrates \fBc\fR-type completion. I aint talkin' bout chicken n' gravy biatch.  Any word followin `cc' n' beginning
with `\-I' is completed as a gangbangin' finger-lickin' directory.  `\-I' aint taken as part of the
directory cuz we used lowercase \fBc\fR.
.PP
Different \fIlist\fRs is useful wit different commands.
.IP "" 4
> complete alias 'p/1/a/'
.br
> complete playa 'p/*/c/'
.br
> complete set 'p/1/s/'
.br
> complete legit 'p/1/x:Truth has no options./'
.PP
These complete lyrics followin `alias' wit aliases, `man' wit commands,
and `set' wit shell variables.
`true' aint gots any options, so \fBx\fR do not a god damn thang when completion
is attempted n' prints `Truth has no options.' when completion chizzlez is listed.
.PP
Note dat tha \fIman\fR example, n' nuff muthafuckin other examplez below, could
just as well have used 'c/*' or 'n/*' as 'p/*'.
.PP
Lyrics can be completed from a variable evaluated at completion time,
.IP "" 4
> complete ftp 'p/1/$hostnames/'
.br
> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)
.br
> ftp [^D]
.br
rtfm.mit.edu tesla.ee.cornell.edu
.br
> ftp [^C]
.br
> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)
.br
> ftp [^D]
.br
rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net
.PP
or from a cold-ass lil command run at completion time:
.IP "" 4
> complete bust a cap up in 'p/*/`ps | awk \\{print\\ \\$1\\}`/'
.br
> bust a cap up in \-9 [^D]
.br
23113 23377 23380 23406 23429 23529 23530 PID
.PP
Note dat tha \fIcomplete\fR command do not itself quote its arguments,
so tha braces, space n' `$' up in `{print $1}' must be quoted explicitly.
.PP
One command can have multiple completions:
.IP "" 4
> complete dbx 'p/2/(core)/' 'p/*/c/'
.PP
completes tha second argument ta `dbx' wit tha word `core' n' all other
arguments wit commands.  Note dat tha positionizzle completion is specified
before tha next-word completion.
Because completions is evaluated from left ta right, if
the next-word completion was specified first it would always match
and tha positionizzle completion would never be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This be a
common fuck up when definin a cold-ass lil completion.
.PP
Da \fIselect\fR pattern is useful when a cold-ass lil command takes filez wit only
particular forms as arguments, n' you can put dat on yo' toast.  For example,
.IP "" 4
> complete cc 'p/*/f:*.[cao]/'
.PP
completes `cc' arguments ta filez endin up in only `.c', `.a', or `.o'.
\fIselect\fR can also exclude files, rockin negation of a glob-pattern as
busted lyrics bout under \fBFilename substitution\fR.  One might use
.IP "" 4
> complete rm 'p/*/f:^*.{c,h,cc,C,tex,1,man,l,y}/'
.PP
to exclude precious source code from `rm' completion. I aint talkin' bout chicken n' gravy biatch.  Of course, one
could still type excluded names manually or override tha completion
mechanizzle rockin tha \fIcomplete-word-raw\fR or \fIlist-choices-raw\fR
editor commandz (q.v.).
.PP
Da `C', `D', `F' n' `T' \fIlist\fRs is like `c', `d', `f' n' `t'
respectively yo, but they use tha \fIselect\fR argument up in a gangbangin' finger-lickin' different way: to
restrict completion ta filez beginnin wit a particular path prefix.  For
example, tha Elm mail program uses `=' as a abbreviation fo' onez mail
directory.  One might use
.IP "" 4
> complete elm c@=@F:$HOME/Mail/@
.PP
to complete `elm \-f =' as if it was `elm \-f ~/Mail/'.  Note dat we used `@'
instead of `/' ta avoid mad drama wit tha \fIselect\fR argument, n' we used
`$HOME' instead of `~' cuz home directory substitution works at only the
beginnin of a word.
.PP
\fIsuffix\fR is used ta add a nonstandard suffix
(not space or `/' fo' directories) ta completed lyrics.
.IP "" 4
> complete finger 'c/*@/$hostnames/' 'p/1/u/@'
.PP
completes arguments ta `finger' from tha list of users, appendz a `@',
and then completes afta tha `@' from tha `hostnames' variable.  Note
again tha order up in which tha completions is specified.
.PP
Finally, herez a cold-ass lil complex example fo' inspiration:
.IP "" 4
> complete find \\
.br
\&'n/\-name/f/' 'n/\-newer/f/' 'n/\-{,n}cpio/f/' \e
.br
\&\'n/\-exec/c/' 'n/\-ok/c/' 'n/\-user/u/' \e
.br
\&'n/\-group/g/' 'n/\-fstype/(nfs 4.2)/' \e
.br
\&'n/\-type/(b c d f l p s)/' \e
.br
\'c/\-/(name newer cpio ncpio exec aiiight user \e
.br
group fstype type atime ctime depth inum \e
.br
ls mtime nogroup nouser perm print prune \e
.br
size xdev)/' \e
.br
\&'p/*/d/'
.PP
This completes lyrics followin `\-name', `\-newer', `\-cpio' or `ncpio'
(note tha pattern which matches both) ta files,
wordz followin `\-exec' or `\-ok' ta commands, lyrics followin `user'
and `group' ta playas n' crews respectively
and lyrics followin `\-fstype' or `\-type' ta thugz of the
given lists, n' you can put dat on yo' toast.  It also completes tha switches theyselves from tha given list
(note tha use of \fBc\fR-type completion)
and completes anythang not otherwise completed ta a gangbangin' finger-lickin' directory.  Whew.
.PP
Remember dat programmed completions is ignored if tha word bein completed
is a tilde substitution (beginnin wit `~') or a variable (beginnin wit `$').
\fIcomplete\fR be a experimenstrual feature, n' tha syntax may chizzle
in future versionz of tha shell.
See also tha \fIuncomplete\fR builtin command.
.RE
.TP 8
.B continue
Continues execution of tha nearest enclosin \fIwhile\fR or \fIforeach\fR.
Da rest of tha commandz on tha current line is executed.
.TP 8
.B default:
Labels tha default case up in a \fIswitch\fR statement.
It should come afta all \fIcase\fR labels.
.PP
.B dirs \fR[\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR]
.br
.B dirs \-S\fR|\fB\-L \fR[\fIfilename\fR] (+)
.PD 0
.TP 8
.B dirs \-c \fR(+)
Da first form prints tha directory stack.  Da top of tha stack be at the
left n' tha straight-up original gangsta directory up in tha stack is tha current directory.
With \fB\-l\fR, `~' or `~\fIname\fP' up in tha output is expanded explicitly
to \fBhome\fR or tha pathname of tha home directory fo' user \fIname\fP.  (+)
With \fB\-n\fR, entries is wrapped before they reach tha edge of tha screen. I aint talkin' bout chicken n' gravy biatch.  (+)
With \fB\-v\fR, entries is printed one per line, preceded by they stack positions.  (+)
If mo' than one of \fB\-n\fR or \fB\-v\fR is given, \fB\-v\fR takes precedence.
\fB\-p\fR be accepted but do nothing.
.PD
.RS +8
.PP
With \fB\-S\fR, tha second form saves tha directory stack ta \fIfilename\fR
as a seriez of \fIcd\fR n' \fIpushd\fR commands.
With \fB\-L\fR, tha shell sources \fIfilename\fR, which is presumably
a directory stack file saved by tha \fB\-S\fR option or tha \fBsavedirs\fR
mechanism.
In either case, \fBdirsfile\fR is used if \fIfilename\fR aint given and
\fI~/.cshdirs\fR is used if \fBdirsfile\fR is unset.
.PP
Note dat login shells do tha equivalent of `dirs \-L' on startup
and, if \fBsavedirs\fR is set, `dirs \-S' before exiting.
Because only \fI~/.tcshrc\fR is normally sourced before \fI~/.cshdirs\fR,
\fBdirsfile\fR should be set up in \fI~/.tcshrc\fR rather than \fI~/.login\fR.
.PP
Da last form clears tha directory stack.
.RE
.TP 8
.B echo \fR[\fB\-n\fR] \fIword\fR ...
Writes each \fIword\fR ta tha shellz standard
output, separated by spaces n' terminated wit a newline.
Da \fBecho_style\fR shell variable may be set ta emulate (or not) tha flags n' escape
sequencez of tha BSD and/or System V versionz of \fIecho\fR; peep \fIecho\fR(1).
.TP 8
.B echotc \fR[\fB\-sv\fR] \fIarg\fR ... (+)
Exercises tha terminal capabilitizzles (see \fItermcap\fR(5)) up in \fIargs\fR.
For example, 'echotc home' sendz tha cursor ta tha home position,
\&'echotc cm 3 10' sendz it ta column 3 n' row 10, and
\&'echotc ts 0; echo "This be a test."; echotc fs' prints "This be a test."
in tha status line.
.RS +8
.PP
If \fIarg\fR is 'baud', 'cols', 'lines', 'meta' or 'tabs', prints the
value of dat capabilitizzle ("yes" or "no" indicatin dat tha terminal do
or aint gots dat capability).  One might use dis ta make tha output
from a gangbangin' finger-lickin' dirty-ass shell script less verbose on slow terminals, or limit command
output ta tha number of lines on tha screen:
.IP "" 4
> set history=`echotc lines`
.br
> @ history\-\-
.PP
Termcap strings may contain wildcardz which aint gonna echo erectly.
One should use double quotes when settin a gangbangin' finger-lickin' dirty-ass shell variable ta a terminal
capabilitizzle string, as up in tha followin example dat places tha date in
the status line:
.IP "" 4
> set tosl="`echotc ts 0`"
.br
> set frsl="`echotc fs`"
.br
> echo \-n "$tosl";date; echo \-n "$frsl"
.PP
With \fB\-s\fR, nonexistent capabilitizzles return tha empty strang rather
than causin a error.
With \fB\-v\fR, lyrics is verbose.
.RE
.PP
.B else
.br
.B end
.br
.B endif
.PD 0
.TP 8
.B endsw
See tha description of tha \fIforeach\fR, \fIif\fR, \fIswitch\fR, and
\fIwhile\fR statements below.
.PD
.TP 8
.B eval \fIarg\fR ...
Treats tha arguments as input ta the
shell n' executes tha resultin command(s) up in tha context
of tha current shell.  This is probably used ta execute commands
generated as tha result of command or variable substitution,
because parsin occurs before these substitutions.
See \fItset\fR(1) fo' a sample use of \fIeval\fR.
.TP 8
.B exec \fIcommand\fR
Executes tha specified command up in place of tha current shell.
.TP 8
.B exit \fR[\fIexpr\fR]
Da shell exits either wit tha value of tha specified \fIexpr\fR
(an expression, as busted lyrics bout under \fBExpressions\fR)
or, without \fIexpr\fR, wit tha value 0.
.TP 8
.B fg \fR[\fB%\fIjob\fR ...]
Brings tha specified thangs (or, without arguments, tha current thang)
into tha foreground, continuin each if it is stopped.
\fIjob\fR may be a number, a string, `', `%', `+' or `\-' as busted lyrics about
under \fBJobs\fR.
See also tha \fIrun-fg-editor\fR editor command.
.TP 8
.B filetest \-\fIop file\fR ... (+)
Applies \fIop\fR (which be a gangbangin' file inquiry operator as busted lyrics bout under
\fBFile inquiry operators\fR) ta each \fIfile\fR n' returns tha thangs up in dis biatch as a
space-separated list.
.PP
.B foreach \fIname \fB(\fIwordlist\fB)
.br
\&...
.PD 0
.TP 8
.B end
Successively sets tha variable \fIname\fR ta each gangmember of
\fIwordlist\fR n' executes tha sequence of commandz between dis command
and tha matchin \fIend\fR.  (Both \fIforeach\fR n' \fIend\fR
must step tha fuck up ridin' solo on separate lines.)  Da builtin command
\fIcontinue\fR may be used ta continue tha loop prematurely and
the builtin command \fIbreak\fR ta terminizzle it prematurely.
When dis command is read from tha terminal, tha loop is read once
promptin wit `foreach? ' (or \fBprompt2\fR) before any statements in
the loop is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you cook up a gangbangin' fuck up typin up in a
loop all up in tha terminal you can rub it out.
.PD
.TP 8
.B getspath \fR(+)
Prints tha system execution path.  (TCF only)
.TP 8
.B getxvers \fR(+)
Prints tha experimenstrual version prefix.  (TCF only)
.TP 8
.B glob \fIwordlist
Like \fIecho\fR yo, but tha `-n' parameta aint recognized n' lyrics are
delimited by null charactas up in tha output.  Useful for
programs which wish ta use tha shell ta filename expand a list of lyrics.
.TP 8
.B goto \fIword
\fIword\fR is filename n' command-substituted to
yield a strang of tha form `label'.  Da shell rewindz its
input as much as possible, searches fo' a line of the
form `label:', possibly preceded by blanks or tabs, and
continues execution afta dat line.
.TP 8
.B hashstat
Prints a statistics line indicatin how tha fuck effectizzle the
internal hash table has been at locatin commandz (and avoiding
\fIexec\fR's).  An \fIexec\fR be attempted fo' each component of the
\fBpath\fR where tha hash function indicates a possible hit, and
in each component which do not begin wit a `/'.
.IP
On machines without \fIvfork\fR(2), prints only tha number n' size of
hash buckets.
.PP
.B history \fR[\fB\-hTr\fR] [\fIn\fR]
.br
.B history \-S\fR|\fB\-L|\fB\-M \fR[\fIfilename\fR] (+)
.PD 0
.TP 8
.B history \-c \fR(+)
Da first form prints tha history event list.
If \fIn\fR is given only tha \fIn\fR most recent events is printed or saved.
With \fB\-h\fR, tha history list is printed without leadin numbers.  If
\fB-T\fR is specified, timestamps is printed also up in comment form.
(This can be used to
produce filez suitable fo' loadin wit 'history \-L' or 'source \-h'.)
With \fB\-r\fR, tha order of printin is most recent
first rather than crazy oldschool first.
.PD
.RS +8
.PP
With \fB\-S\fR, tha second form saves tha history list ta \fIfilename\fR.
If tha straight-up original gangsta word of tha \fBsavehist\fR shell variable is set ta a
number, at most dat nuff lines is saved. Y'all KNOW dat shit, muthafucka!  If tha second word of
\fBsavehist\fR is set ta `merge', tha history list is merged wit the
existin history file instead of replacin it (if there is one) and
sorted by time stamp.  (+) Mergin is intended fo' a environment like
the X Window System
with nuff muthafuckin shells up in simultaneous use.  Currently it succeeds
only when tha shells quit sickly one afta another.
.PP
With \fB\-L\fR, tha shell appendz \fIfilename\fR, which is presumably a
history list saved by tha \fB\-S\fR option or tha \fBsavehist\fR mechanism,
to tha history list.
\fB\-M\fR is like \fB\-L\fR yo, but tha contentz of \fIfilename\fR is merged
into tha history list n' sorted by timestamp.
In either case, \fBhistfile\fR is used if \fIfilename\fR aint given and
\fI~/.history\fR is used if \fBhistfile\fR is unset.
`history \-L' is exactly like 'source \-h' except dat it do not require a
filename.
.PP
Note dat login shells do tha equivalent of `history \-L' on startup
and, if \fBsavehist\fR is set, `history \-S' before exiting.
Because only \fI~/.tcshrc\fR is normally sourced before \fI~/.history\fR,
\fBhistfile\fR should be set up in \fI~/.tcshrc\fR rather than \fI~/.login\fR.
.PP
If \fBhistlit\fR is set, tha straight-up original gangsta n' second forms print n' save tha literal
(unexpanded) form of tha history list.
.PP
Da last form clears tha history list.
.RE
.TP 8
.B hup \fR[\fIcommand\fR] \fR(+)
With \fIcommand\fR, runs \fIcommand\fR such dat it will exit on a hangup
signal n' arranges fo' tha shell ta bust it a hangup signal when tha shell
exits.
Note dat commandz may set they own response ta hangups, overridin \fIhup\fR.
Without a argument, causes tha non-interactizzle shell only to
exit on a hangup fo' tha remainder of tha script.
See also \fBSignal handling\fR n' tha \fInohup\fR builtin command.
.TP 8
.B if (\fIexpr\fB) \fIcommand
If \fIexpr\fR (an expression, as busted lyrics bout under \fBExpressions\fR)
evaluates true, then \fIcommand\fR is executed.
Variable substitution on \fIcommand\fR happens early, all up in tha same time it
does fo' tha rest of tha \fIif\fR command.
\fIcommand\fR must be a simple command, not a alias, a pipeline, a cold-ass lil command list
or a parenthesized command list yo, but it may have arguments.
Input/output redirection occurs even if \fIexpr\fR is
false n' \fIcommand\fR is thus \fInot\fR executed; dis be a funky-ass bug.
.PP
.B if (\fIexpr\fB) then
.br
\&...
.br
.B else if (\fIexpr2\fB) then
.br
\&...
.br
.B else
.br
\&...
.PD 0
.TP 8
.B endif
If tha specified \fIexpr\fR is legit then tha commandz ta the
first \fIelse\fR is executed; otherwise if \fIexpr2\fR is legit then
the commandz ta tha second \fIelse\fR is executed, etc.  Any
number of \fIelse-if\fR pairs is possible; only one \fIendif\fR is
needed. Y'all KNOW dat shit, muthafucka!  Da \fIelse\fR part is likewise optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  (Da lyrics
\fIelse\fR n' \fIendif\fR must step tha fuck up all up in tha beginnin of input lines;
the \fIif\fR must step tha fuck up ridin' solo on its input line or afta an
\fIelse\fR.)
.PD
.TP 8
.B inlib \fIshared-library\fR ... (+)
Addz each \fIshared-library\fR ta tha current environment.  There is no way
to remove a gangbangin' finger-lickin' dirty-ass shared library.  (Domain/OS only)
.TP 8
.B thangs \fR[\fB\-l\fR]
Lists tha actizzle thangs.  With \fB\-l\fR, lists process
IDs up in addizzle ta tha aiiight shiznit. I aint talkin' bout chicken n' gravy biatch.  On TCF systems, prints
the joint on which each thang is executing.
.PP
.PD 0
.TP 8
.B bust a cap up in \fR[\fB\-s \fIsignal\fR] \fB%\fIjob\fR|\fIpid\fR ...
.PD 0
.TP 8
.B bust a cap up in \-l
Da first n' second forms sendz tha specified \fIsignal\fR (or, if none
is given, tha TERM (terminate) signal) ta tha specified thangs or processes.
\fIjob\fR may be a number, a string, `', `%', `+' or `\-' as busted lyrics about
under \fBJobs\fR.
Signals is either given by number or by name (as given in
\fI/usr/include/signal.h\fR, stripped of tha prefix `SIG').
There is no default \fIjob\fR; sayin just `kill' do not bust a signal
to tha current thang.  If tha signal bein busted is TERM (terminate)
or HUP (hangup), then tha thang or process is busted a
CONT (continue) signal as well.
Da third form lists tha signal names.
.PD
.TP 8
.B limit \fR[\fB\-h\fR] [\fIresource\fR [\fImaximum-use\fR]]
Limits tha consumption by tha current process n' each
process it creates ta not individually exceed \fImaximum-use\fR on
the specified \fIresource\fR.  If no \fImaximum-use\fR is given, then
the current limit is printed; if no \fIresource\fR is given, then
all limitations is given. I aint talkin' bout chicken n' gravy biatch.  If tha \fB\-h\fR flag is given, the
hard limits is used instead of tha current limits, n' you can put dat on yo' toast.  The
hard limits impose a cold-ass lil ceilin on tha jointz of tha current
limits, n' you can put dat on yo' toast.  Only tha super-user may raise tha hard limits yo, but
a user may lower or raise tha current limits within tha legal range.
.RS +8
.PP
Controllable resources currently include (if supported by tha OS):
.TP
\fIcputime\fR
the maximum number of cpu-secondz ta be used by each process
.TP
\fIfilesize\fR
the phattest single file which can be pimped
.TP
\fIdatasize\fR
the maximum growth of tha data+stack region via sbrk(2) beyond
the end of tha program text
.TP
\fIstacksize\fR
the maximum size of tha automatically-extended stack region
.TP
\fIcoredumpsize\fR
the size of tha phattest core dump dat is ghon be pimped
.TP
\fImemoryuse\fR
the maximum amount of physical memory a process
may have allocated ta it at a given time (this aint implemented up in tha 2.6+ kernel,
so there is no effect introduced by changin dis value)
.TP
\fIvmemoryuse\fR
the maximum amount of virtual memory a process
may have allocated ta it at a given time (address space)
.TP
\fIvmemoryuse\fR
the maximum amount of virtual memory a process
may have allocated ta it at a given time
.TP
\fIheapsize\fR
the maximum amount of memory a process
may allocate per \fIbrk()\fR system call
.TP
\fIdescriptors\fR or \fIopenfiles\fR
the maximum number of open filez fo' dis process
.TP
\fIconcurrency\fR
the maximum number of threadz fo' dis process
.TP
\fImemorylocked\fR
the maximum size which a process may lock tha fuck into memory rockin mlock(2)
.TP
\fImaxproc\fR
the maximum number of simultaneous processes fo' dis user id
.TP
\fIsbsize\fR
the maximum size of socket buffer usage fo' dis user
.TP
\fIswapsize\fR
the maximum amount of swap space reserved or used fo' dis user
.TP
\fImaxlocks\fR
the maximum number of locks fo' dis user
.TP
\fImaxsignal\fR
the maximum number of pendin signals fo' dis user
.TP
\fImaxmessage\fR
the maximum number of bytes up in POSIX mqueues fo' dis user
.TP
\fImaxnice\fR
the maximum sick prioritizzle tha user be allowed ta raise mapped from [19...-20]
to [0...39] fo' dis user
.TP
\fImaxrtprio\fR
the maximum realtime prioritizzle fo' dis user
\fImaxrttime\fR
the timeout fo' RT tasks up in microsecondz fo' dis user.
.PP
\fImaximum-use\fR may be given as a (floatin point or
integer) number followed by a scale factor. Shiiit, dis aint no joke.  For all limits
other than \fIcputime\fR tha default scale is `k' or `kilobytes'
(1024 bytes); a scale factor of `m' or `megabytes' or `g' or `gigabytes'
may also be used. Y'all KNOW dat shit, muthafucka!  For \fIcputime\fR tha default scalin is `seconds',
while `m' fo' minutes or `h' fo' hours, or a time of the
form `mm:ss' givin minutes n' secondz may be used.
.PP
If \fImaximum-use\fR  is `unlimited',
then tha limitation on tha specified \fIresource\fR
is removed (this is equivalent ta tha \fIunlimit\fR builtin command).
.PP
For both \fIresource\fR names n' scale factors, unambiguous
prefixez of tha names suffice.
.RE
.TP 8
.B log \fR(+)
Prints tha \fBwatch\fR shell variable n' reports on each user indicated
in \fBwatch\fR whoz ass is logged in, regardless of when they last logged in.
See also \fIwatchlog\fR.
.TP 8
.B login
Terminates a login shell, replacin it wit a instizzle of
\fI/bin/login\fR. This is one way ta log off, included for
compatibilitizzle wit \fIsh\fR(1).
.TP 8
.B logout
Terminates a login shell.  Especially useful if \fBignoreeof\fR is set.
.TP 8
.B ls\-F \fR[\-\fIswitch\fR ...] [\fIfile\fR ...] (+)
Lists filez like `ls \-F' yo, but much fasta n' shit.  It identifies each type of
special file up in tha listin wit a special character:
.PP
.RS +8
.PD 0
.TP 4
/
Directory
.TP 4
*
Executable
.TP 4
#
Block device
.TP 4
%
Characta device
.TP 4
|
Named pipe (systems wit named pipes only)
.TP 4
=
Socket (systems wit sockets only)
.TP 4
@
Symbolic link (systems wit symbolic links only)
.TP 4
+
Hidden directory (AIX only) or context dependent (HP/UX only)
.TP 4
:
Network special (HP/UX only)
.PD
.PP
If tha \fBlistlinks\fR shell variable is set, symbolic links is identified
in mo' detail (on only systems dat have them, of course):
.PP
.PD 0
.TP 4
@
Symbolic link ta a non-directory
.TP 4
>
Symbolic link ta a gangbangin' finger-lickin' directory
.TP 4
&
Symbolic link ta nowhere
.PD
.PP
\fBlistlinks\fR also slows down \fIls\-F\fR n' causes partitions holding
filez pointed ta by symbolic links ta be mounted.
.PP
If tha \fBlistflags\fR shell variable is set ta `x', `a' or `A', or any
combination thereof (e.g., `xA'), they is used as flags ta \fIls\-F\fR,
makin it act like `ls \-xF', `ls \-Fa', `ls \-FA' or a cold-ass lil combination
(e.g., `ls \-FxA').
On machines where `ls \-C' aint tha default, \fIls\-F\fR acts like `ls \-CF',
unless \fBlistflags\fR gotz nuff a `x', up in which case it acts like `ls \-xF'.
\fIls\-F\fR passes its arguments ta \fIls\fR(1) if it is given any switches,
so `alias ls ls\-F' generally do tha right thang.
.PP
Da \fBls\-F\fR builtin can list filez rockin different flavas dependin on the
filetype or extension. I aint talkin' bout chicken n' gravy biatch.  See tha \fBcolor\fR shell variable n' the
\fBLS_COLORS\fR environment variable.
.RE
.PP
.B migrate \fR[\fB\-\fIsite\fR] \fIpid\fR|\fB%\fIjobid\fR ... (+)
.PD 0
.TP 8
.B migrate \-\fIsite\fR (+)
Da first form migrates tha process or thang ta tha joint specified or the
default joint determined by tha system path.
Da second form is equivalent ta `migrate \-\fIsite\fR $$': it migrates the
current process ta tha specified crib.  Migratin tha shell
itself can cause unexpected behavior, cuz tha shell
does not like ta lose its tty.  (TCF only)
.PD
.TP 8
.B newgrp \fR[\fB\-\fR] \fI[group]\fR (+)
Equivalent ta `exec newgrp'; peep \fInewgrp\fR(1).
Available only if tha shell was so compiled;
see tha \fBversion\fR shell variable.
.TP 8
.B sick \fR[\fB+\fInumber\fR] [\fIcommand\fR]
Sets tha schedulin prioritizzle fo' tha shell ta \fInumber\fR, or, without
\fInumber\fR, ta 4.  With \fIcommand\fR, runs \fIcommand\fR all up in tha appropriate
priority.
Da pimped outa tha \fInumber\fR, tha less cpu
the process gets, n' you can put dat on yo' toast.  Da super-user may specify negative
prioritizzle by rockin `nice \-number ...'.  Command be always
executed up in a sub-shell, n' tha restrictions placed on
commandz up in simple \fIif\fR statements apply.
.TP 8
.B nohup \fR[\fIcommand\fR]
With \fIcommand\fR, runs \fIcommand\fR such dat it will ignore hangup signals.
Note dat commandz may set they own response ta hangups, overridin \fInohup\fR.
Without a argument, causes tha non-interactizzle shell only to
ignore hangups fo' tha remainder of tha script.
See also \fBSignal handling\fR n' tha \fIhup\fR builtin command.
.TP 8
.B notify \fR[\fB%\fIjob\fR ...]
Causes tha shell ta notify tha user asynchronously when tha statuz of any
of tha specified thangs (or, without %\fIjob\fR, tha current thang) chizzles,
instead of waitin until tha next prompt as is usual.
\fIjob\fR may be a number, a string, `', `%', `+' or `\-' as busted lyrics about
under \fBJobs\fR.
See also tha \fBnotify\fR shell variable.
.TP 8
.B onintr \fR[\fB\-\fR|\fIlabel\fR]
Controls tha action of tha shell on interrupts, n' you can put dat on yo' toast.  Without arguments,
restores tha default action of tha shell on interrupts,
which is ta terminizzle shell scripts or ta return ta the
terminal command input level.
With `\-', causes all interrupts ta be ignored.
With \fIlabel\fR, causes tha shell ta execute a `goto \fIlabel\fR'
when a interrupt is received or a cold-ass lil lil pimp process terminates cuz it was
interrupted.
.IP "" 8
\fIonintr\fR is ignored if tha shell is hustlin detached n' up in system
startup filez (see \fBFILES\fR), where interrupts is disabled anyway.
.TP 8
.B popd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR] \fR[\fB+\fIn\fR]
Without arguments, pops tha directory stack n' returns ta tha freshly smoked up top directory.
With a number `+\fIn\fR', discardz tha \fIn\fR'th entry up in tha stack.
.IP "" 8
Finally, all formz of \fIpopd\fR print tha final directory stack,
just like \fIdirs\fR.  Da \fBpushdsilent\fR shell variable can be set to
prevent dis n' tha \fB\-p\fR flag can be given ta override \fBpushdsilent\fR.
Da \fB\-l\fR, \fB\-n\fR n' \fB\-v\fR flags have tha same effect on \fIpopd\fR
as on \fIdirs\fR.  (+)
.TP 8
.B printenv \fR[\fIname\fR] (+)
Prints tha names n' jointz of all environment variablez or,
with \fIname\fR, tha value of tha environment variable \fIname\fR.
.TP 8
.B pushd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR] [\fIname\fR|\fB+\fIn\fR]
Without arguments, exchanges tha top two elementz of tha directory stack.
If \fBpushdtohome\fR is set, \fIpushd\fR without arguments do `pushd ~',
like \fIcd\fR.  (+)
With \fIname\fR, pushes tha current hustlin directory onto tha directory
stack n' chizzlez ta \fIname\fR.
If \fIname\fR is `\-' it is interpreted as tha previous hustlin directory
(see \fBFilename substitution\fR).  (+)
If \fBdunique\fR is set, \fIpushd\fR removes any instancez of \fIname\fR
from tha stack before pushin it onto tha stack.  (+)
With a number `+\fIn\fR', rotates tha \fIn\fRth element of the
directory stack round ta be tha top element n' chizzlez ta dat shit.
If \fBdextract\fR is set, however, `pushd +\fIn\fR' extracts tha \fIn\fRth
directory, pushes it onto tha top of tha stack n' chizzlez ta dat shit.  (+)
.IP "" 8
Finally, all formz of \fIpushd\fR print tha final directory stack,
just like \fIdirs\fR.  Da \fBpushdsilent\fR shell variable can be set to
prevent dis n' tha \fB\-p\fR flag can be given ta override \fBpushdsilent\fR.
Da \fB\-l\fR, \fB\-n\fR n' \fB\-v\fR flags have tha same effect on \fIpushd\fR
as on \fIdirs\fR.  (+)
.TP 8
.B rehash
Causes tha internal hash table of tha contentz of the
directories up in tha \fBpath\fR variable ta be recomputed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is
needed if tha \fBautorehash\fR shell variable aint set n' new
commandz is added ta directories up in \fBpath\fR while yo ass is logged
in. I aint talkin' bout chicken n' gravy biatch.  With \fBautorehash\fR, a freshly smoked up command is ghon be found
automatically, except up in tha special case where another command of
the same name which is located up in a gangbangin' finger-lickin' different directory already
exists up in tha hash table.  Also flushes tha cache of home directories
built by tilde expansion.
.TP 8
.B repeat \fIcount command
Da specified \fIcommand\fR,
which is subject ta tha same restrictions as tha \fIcommand\fR
in tha one line \fIif\fR statement above, is executed \fIcount\fR times.
I/O redirections occur exactly once, even if \fIcount\fR is 0.
.TP 8
.B rootnode //\fInodename \fR(+)
Changes tha rootnode ta //\fInodename\fR, so dat `/' is ghon be interpreted
as `//\fInodename\fR'.  (Domain/OS only)
.PP
.B sched \fR(+)
.br
.B sched \fR[\fB+\fR]\fIhh:mm command\fR \fR(+)
.PD 0
.TP 8
.B sched \-\fIn\fR (+)
Da first form prints tha scheduled-event list.
Da \fBsched\fR shell variable may be set ta define tha format up in which
the scheduled-event list is printed.
Da second form addz \fIcommand\fR ta tha scheduled-event list.
For example,
.PD
.RS +8
.IP "" 4
> sched 11:00 echo It\\z eleven o\\'clock.
.PP
causes tha shell ta echo `It aint nuthin but eleven o'clock.' at 11 AM.
Da time may be up in 12-hour AM/PM format
.IP "" 4
> sched 5pm set prompt='[%h] It\\z afta 5; bounce back ta tha doggy den: >'
.PP
or may be relatizzle ta tha current time:
.IP "" 4
> sched +2:15 /usr/lib/uucp/uucico \-r1 \-sother
.PP
A relatizzle time justification may not use AM/PM format.
Da third form removes item \fIn\fR from tha event list:
.IP "" 4
> sched
.br
     1  Wed Apr  4 15:42  /usr/lib/uucp/uucico \-r1 \-sother
.br
     2  Wed Apr  4 17:00  set prompt=[%h] It aint nuthin but afta 5; bounce back ta tha doggy den: >
.br
> sched \-2
.br
> sched
.br
     1  Wed Apr  4 15:42  /usr/lib/uucp/uucico \-r1 \-sother
.PP
A command up in tha scheduled-event list is executed just before tha first
prompt is printed afta tha time when tha command is scheduled.
It be possible ta miss tha exact time when tha command is ta be run yo, but
an overdue command will execute all up in tha next prompt.
A command which comes due while tha shell
is waitin fo' user input is executed immediately.
But fuck dat shiznit yo, tha word on tha street is dat aiiight operation of a already-runnin command will not
be interrupted so dat a scheduled-event list element may be run.
.PP
This mechanizzle is similar ta yo, but not tha same as, tha \fIat\fR(1)
command on some Unix systems.
Its major disadvantage is dat it may not run a cold-ass lil command at exactly the
specified time.
Its major advantage is dat cuz \fIsched\fR runs directly from
the shell, it has access ta shell variablez n' other structures.
This serves up a mechanizzle fo' changin onez hustlin environment
based on tha time of day.
.RE
.PP
.B set
.br
.B set \fIname\fR ...
.br
.B set \fIname\fR\fB=\fIword\fR ...
.br
.B set [\-r] [\-f|\-l] \fIname\fR\fB=(\fIwordlist\fB)\fR ... (+)
.br
.B set \fIname[index]\fR\fB=\fIword\fR ...
.br
.B set \-r \fR(+)
.br
.B set \-r \fIname\fR ... (+)
.PD 0
.TP 8
.B set \-r \fIname\fR\fB=\fIword\fR ... (+)
Da first form of tha command prints tha value of all shell variables.
Variablez which contain mo' than a single word print as a
parenthesized word list.
Da second form sets \fIname\fR ta tha null string.
Da third form sets \fIname\fR ta tha single \fIword\fR.
Da fourth form sets \fIname\fR ta tha list of lyrics in
\fIwordlist\fR.  In all cases tha value is command n' filename expanded.
If \fB\-r\fR is specified, tha value is set read-only.  If \fB\-f\fR or
\fB\-l\fR is specified, set only unique lyrics keepin they order.
\fB\-f\fR prefers tha straight-up original gangsta occurrence of a word, n' \fB\-l\fR tha last.
Da fifth form sets tha \fIindex\fR'th component of \fIname\fR ta \fIword\fR;
this component must already exist.
Da sixth form lists only tha namez of all shell variablez dat is read-only.
Da seventh form make \fIname\fR read-only, whether or not it has a value.
Da eighth form is tha same ol' dirty as tha third form yo, but
make \fIname\fR read-only all up in tha same time.
.PD
.IP "" 8
These arguments can be repeated ta set and/or make read-only multiple variables
in a single set command. Y'all KNOW dat shit, muthafucka!  Note, however, dat variable expansion
happens fo' all arguments before any settin occurs.  Note also dat `=' can
be adjacent ta both \fIname\fR n' \fIword\fR or separated from both by
whitespace yo, but cannot be adjacent ta only one or tha other.
See also tha \fIunset\fR builtin command.
.TP 8
.B setenv \fR[\fIname \fR[\fIvalue\fR]]
Without arguments, prints tha names n' jointz of all environment variables.
Given \fIname\fR, sets tha environment variable \fIname\fR ta \fIvalue\fR
or, without \fIvalue\fR, ta tha null string.
.TP 8
.B setpath \fIpath \fR(+)
Equivalent ta \fIsetpath\fR(1).  (Mach only)
.TP 8
.B setspath\fR LOCAL|\fIsite\fR|\fIcpu\fR ...  (+)
Sets tha system execution path.  (TCF only)
.TP 8
.B settc \fIcap value \fR(+)
Tells tha shell ta believe dat tha terminal capabilitizzle \fIcap\fR
(as defined up in \fItermcap\fR(5)) has tha value \fIvalue\fR.
No sanitizzle checkin is done.
Concept terminal playas may gotta `settc xn no' ta git proper
wrappin all up in tha rightmost column.
.TP 8
.B setty \fR[\fB\-d\fR|\fB\-q\fR|\fB\-x\fR] [\fB\-a\fR] [[\fB+\fR|\fB\-\fR]\fImode\fR] (+)
Controls which tty modes (see \fBTerminal pimpment\fR)
the shell do not allow ta chizzle.
\fB\-d\fR, \fB\-q\fR or \fB\-x\fR  drops some lyrics ta \fIsetty\fR ta act
on tha `edit', `quote' or `execute' set of tty modes respectively; without
\fB\-d\fR, \fB\-q\fR or \fB\-x\fR, `execute' is used.
.IP "" 8
Without other arguments, \fIsetty\fR lists tha modes up in tha chosen set
which is fixed on (`+mode') or off (`\-mode').
Da available modes, n' thus tha display, vary from system ta system.
With \fB\-a\fR, lists all tty modes up in tha chosen set
whether or not they is fixed.
With \fB+\fImode\fR, \fB\-\fImode\fR or \fImode\fR, fixes \fImode\fR on or off
or removes control from \fImode\fR up in tha chosen set.
For example, `setty +echok echoe' fixes `echok' mode on n' allows commands
to turn `echoe' mode on or off, both when tha shell is executin commands.
.TP 8
.B setxvers\fR [\fIstring\fR] (+)
Set tha experimenstrual version prefix ta \fIstring\fR, or removes it
if \fIstring\fR is omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  (TCF only)
.TP 8
.B shift \fR[\fIvariable\fR]
Without arguments, discardz \fBargv\fR[1] n' shifts tha thugz of
\fBargv\fR ta tha left.  It be a error fo' \fBargv\fR not ta be set or ta have
less than one word as value.  With \fIvariable\fR, performs the
same function on \fIvariable\fR.
.TP 8
.B source \fR[\fB\-h\fR] \fIname\fR [\fIargs\fR ...]
Da shell readz n' executes commandz from \fIname\fR.
Da commandz is not placed on tha history list.
If any \fIargs\fR is given, they is placed up in \fBargv\fR.  (+)
\fIsource\fR commandz may be nested;
if they is nested too deeply tha shell may run outta file descriptors.
An error up in a \fIsource\fR at any level terminates all nested
\fIsource\fR commands.
With \fB\-h\fR, commandz is placed on tha history list instead of being
executed, much like `history \-L'.
.TP 8
.B stop \fB%\fIjob\fR|\fIpid\fR ...
Stops tha specified thangs or processes which is executin up in tha background.
\fIjob\fR may be a number, a string, `', `%', `+' or `\-' as busted lyrics about
under \fBJobs\fR.
There is no default \fIjob\fR; sayin just `stop' do not stop
the current thang.
.TP 8
.B suspend
Causes tha shell ta stop up in its tracks, much as if it had
been busted a stop signal wit \fB^Z\fR.  This is most often used to
stop shells started by \fIsu\fR(1).
.PP
.B switch (\fIstring\fB)
.br
.B case \fIstr1\fB:
.PD 0
.IP "" 4
\&...
.br
.B breaksw
.PP
\&...
.PP
.B default:
.IP "" 4
\&...
.br
.B breaksw
.TP 8
.B endsw
Each case label is successively matched, against the
specified \fIstring\fR which is first command n' filename expanded.
Da file metacharactas `*', `?' n' `[...]'  may be used
in tha case labels, which is variable expanded. Y'all KNOW dat shit, muthafucka!  If none
of tha labels match before a `default' label is found, then
the execution begins afta tha default label.  Each case
label n' tha default label must step tha fuck up all up in tha beginnin of
a line.  Da command \fIbreaksw\fR causes execution ta continue
afta tha \fIendsw\fR.  Otherwise control may fall all up in case
labels n' default labels as up in C.  If no label matches and
there is no default, execution continues afta tha \fIendsw\fR.
.PD
.TP 8
.B telltc \fR(+)
Lists tha jointz of all terminal capabilitizzles (see \fItermcap\fR(5)).
.TP 8
.B termname \fR[\fIterminal type\fR] \fR(+)
Tests if \fIterminal type\fR (or tha current value of \fBTERM\fR if no
\fIterminal type\fR is given) has a entry up in tha hosts termcap(5) or
terminfo(5) database. Prints tha terminal type ta stdout n' returns 0
if a entry is present otherwise returns 1.
.TP 8
.B time \fR[\fIcommand\fR]
Executes \fIcommand\fR (which must be a simple command, not a alias,
a pipeline, a cold-ass lil command list or a parenthesized command list)
and prints a time summary as busted lyrics bout under tha \fBtime\fR variable.
If necessary, a extra shell is pimped ta print tha time statistic when
the command completes.
Without \fIcommand\fR, prints a time summary fo' tha current shell n' its
children.
.TP 8
.B umask \fR[\fIvalue\fR]
Sets tha file creation mask ta \fIvalue\fR, which is given up in octal.
Common joints fo' tha mask are
002, givin all access ta tha crew n' read n' execute access ta others, and
022, givin read n' execute access ta tha crew n' others.
Without \fIvalue\fR, prints tha current file creation mask.
.TP 8
.B unalias \fIpattern\fR
.br
Removes all aliases whose names match \fIpattern\fR.
`unalias *' thus removes all aliases.
It aint a error fo' not a god damn thang ta be \fIunalias\fRed.
.TP 8
.B uncomplete \fIpattern\fR (+)
Removes all completions whose names match \fIpattern\fR.
`uncomplete *' thus removes all completions.
It aint a error fo' not a god damn thang ta be \fIuncomplete\fRd.
.TP 8
.B unhash
Disablez use of tha internal hash table ta speed location of
executed programs.
.TP 8
.B universe \fIuniverse\fR (+)
Sets tha universe ta \fIuniverse\fR.  (Masscomp/RTU only)
.TP 8
.B unlimit \fR[\fB\-hf\fR] [\fIresource\fR]
Removes tha limitation on \fIresource\fR or, if no \fIresource\fR is
specified, all \fIresource\fR limitations.
With \fB\-h\fR, tha correspondin hard limits is removed.
Only tha super-user may do all dis bullshit.
Note dat \fBunlimit\fR may not exit successful, since most systems
do not allow \fIdescriptors\fR ta be unlimited.
With \fB\-f\fR errors is ignored.
.TP 8
.B unset \fIpattern
Removes all variablez whose names match \fIpattern\fR, unless they is read-only.
`unset *' thus removes all variablez unless they is read-only;
this be a wack idea.
It aint a error fo' not a god damn thang ta be \fIunset\fR.
.TP 8
.B unsetenv \fIpattern
Removes all environment variablez whose names match \fIpattern\fR.
`unsetenv *' thus removes all environment variables;
this be a wack idea.
It aint a error fo' not a god damn thang ta be \fIunsetenv\fRed.
.TP 8
.B ver \fR[\fIsystype\fR [\fIcommand\fR]] (+)
Without arguments, prints \fBSYSTYPE\fR.  With \fIsystype\fR, sets \fBSYSTYPE\fR
to \fIsystype\fR.  With \fIsystype\fR n' \fIcommand\fR, executes \fIcommand\fR
under \fIsystype\fR.  \fIsystype\fR may be `bsd4.3' or `sys5.3'.
(Domain/OS only)
.TP 8
.B wait
Da shell waits fo' all background thangs.  If tha shell is interactive, an
interrupt will disrupt tha wait n' cause tha shell ta print tha names n' thang
numberz of all outstandin thangs.
.TP 8
.B warp \fIuniverse\fR (+)
Sets tha universe ta \fIuniverse\fR.  (Convex/OS only)
.TP 8
.B watchlog \fR(+)
An alternate name fo' tha \fIlog\fR builtin command (q.v.).
Available only if tha shell was so compiled;
see tha \fBversion\fR shell variable.
.TP 8
.B where \fIcommand\fR (+)
Reports all known instancez of \fIcommand\fR, includin aliases, builtins and
executablez up in \fBpath\fR.
.TP 8
.B which\fR \fIcommand\fR (+)
Displays tha command dat is ghon be executed by tha shell afta substitutions,
\fBpath\fR searching, etc.
Da builtin command is just like \fIwhich\fR(1) yo, but it erectly reports
\fItcsh\fR aliases n' builtins n' is 10 ta 100 times faster.
See also tha \fIwhich-command\fR editor command.
.PP
.B while (\fIexpr\fB)\fR
.br
\&...
.PD 0
.TP 8
.B end
Executes tha commandz between tha \fIwhile\fR n' tha matchin \fIend\fR
while \fIexpr\fR (an expression, as busted lyrics bout under \fBExpressions\fR)
evaluates non-zero.
\fIwhile\fR n' \fIend\fR must step tha fuck up ridin' solo on they input lines.
\fIbreak\fR n' \fIcontinue\fR may be used ta terminizzle or continue the
loop prematurely.
If tha input be a terminal, tha user is prompted tha last time
all up in tha loop as wit \fIforeach\fR.
.PD
.SS "Special aliases (+)"
If set, each of these aliases executes automatically all up in tha indicated time.
They is all initially undefined.
.TP 8
.B beepcmd
Runs when tha shell wants ta rang tha terminal bell.
.TP 8
.B cwdcmd
Runs afta every last muthafuckin chizzle of hustlin directory.  For example, if tha user is
workin on a X window system rockin \fIxterm\fR(1) n' a re-parentin window
manager dat supports title bars like fuckin \fItwm\fR(1) n' do
.RS +8
.IP "" 4
> alias cwdcmd  'echo \-n "^[]2;${HOST}:$cwd ^G"'
.PP
then tha shell will chizzle tha title of tha hustlin \fIxterm\fR(1)
to be tha name of tha host, a cold-ass lil colon, n' tha full current hustlin directory.
A fancier way ta do dat is
.IP "" 4
> alias cwdcmd 'echo \-n "^[]2;${HOST}:$cwd^G^[]1;${HOST}^G"'
.PP
This will put tha hostname n' hustlin directory on tha title bar but
only tha hostname up in tha icon manager menu.
.PP
Note dat puttin a \fIcd\fR, \fIpushd\fR or \fIpopd\fR up in \fIcwdcmd\fR
may cause a infinite loop.  It be tha authorz opinion dat mah playas bustin
so will git what tha fuck they deserve.
.RE
.TP 8
.B thangcmd
Runs before each command gets executed, or when tha command chizzlez state.
This is similar ta \fIpostcmd\fR yo, but it do not print builtins.
.RS +8
.IP "" 4
> alias thangcmd  'echo \-n "^[]2\e;\e!#:q^G"'
.PP
then executin \fIvi foo.c\fR will put tha command strang up in tha xterm title bar.
.RE
.TP 8
.B helpcommand
Invoked by tha \fBrun-help\fR editor command. Y'all KNOW dat shit, muthafucka!  Da command name fo' which help
is sought is passed as sole argument.
For example, if one do
.RS +8
.IP "" 4
> alias helpcommand '\e!:1 --help'
.PP
then tha help display of tha command itself is ghon be invoked, rockin tha GNU
help callin convention.
Currently there is no easy as fuck  way ta account fo' various callin conventions (e.g.,
the customary Unix `-h'), except by rockin a table of nuff commands.
.RE
.TP 8
.B periodic
Runs every last muthafuckin \fBtperiod\fR minutes.  This serves up a cold-ass lil convenient means for
checkin on common but infrequent chizzlez like fuckin freshly smoked up mail.  For example,
if one do
.RS +8
.IP "" 4
> set tperiod = 30
.br
> alias periodic checknews
.PP
then tha \fIchecknews\fR(1) program runs every last muthafuckin 30 minutes.
If \fIperiodic\fR is set but \fBtperiod\fR is unset or set ta 0,
\fIperiodic\fR behaves like \fIprecmd\fR.
.RE
.TP 8
.B precmd
Runs just before each prompt is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For example, if one do
.RS +8
.IP "" 4
> alias precmd date
.PP
then \fIdate\fR(1) runs just before tha shell prompts fo' each command.
There is no limits on what tha fuck \fIprecmd\fR can be set ta do yo, but discretion
should be used.
.RE
.TP 8
.B postcmd
Runs before each command gets executed.
.RS +8
.IP "" 4
> alias postcmd  'echo \-n "^[]2\e;\e!#:q^G"'
.PP
then executin \fIvi foo.c\fR will put tha command strang up in tha xterm title bar.
.RE
.TP 8
.B shell
Specifies tha interpreta fo' executable scripts which do not theyselves
specify a interpreter n' shit.  Da first word should be a gangbangin' full path name ta the
desired interpreta (e.g., `/bin/csh' or `/usr/local/bin/tcsh').
.SS "Special shell variables"
Da variablez busted lyrics bout up in dis section have special meanin ta tha shell.
.PP
Da shell sets \fBaddsuffix\fR, \fBargv\fR, \fBautologout\fR, \fBcsubstnonl\fR, \fBcommand\fR, \fBecho_style\fR,
\fBedit\fR, \fBgid\fR, \fBgroup\fR, \fBhome\fR, \fBloginsh\fR, \fBoid\fR, \fBpath\fR,
\fBprompt\fR, \fBprompt2\fR, \fBprompt3\fR, \fBshell\fR, \fBshlvl\fR,
\fBtcsh\fR, \fBterm\fR, \fBtty\fR, \fBuid\fR, \fBuser\fR n' \fBversion\fR at
startup; they do not chizzle thereafta unless chizzled by tha user n' shit.  Da shell
updates \fBcwd\fR, \fBdirstack\fR, \fBowd\fR n' \fBstatus\fR when necessary,
and sets \fBlogout\fR on logout.
.PP
Da shell synchronizes \fBgroup\fR, \fBhome\fR, \fBpath\fR, \fBshlvl\fR,
\fBterm\fR n' \fBuser\fR wit tha environment variablez of tha same names:
whenever tha environment variable chizzlez tha shell chizzlez tha corresponding
shell variable ta match (unless tha shell variable is read-only) n' vice
versa.  Note dat although \fBcwd\fR n' \fBPWD\fR have identical meanings, they
are not synchronized up in dis manner, n' dat tha shell automatically
converts between tha different formatz of \fBpath\fR n' \fBPATH\fR.
.TP 8
.B addsuffix \fR(+)
If set, filename completion addz `/' ta tha end of directories n' a space
to tha end of aiiight filez when they is matched exactly.
Set by default.
.TP 8
.B afsuser \fR(+)
If set, \fBautologout\fRz autolock feature uses its value instead of
the local username fo' kerberos authentication.
.TP 8
.B ampm \fR(+)
If set, all times is shown up in 12-hour AM/PM format.
.TP 8
.B argv
Da arguments ta tha shell.  Positionizzle parametas is taken from \fBargv\fR,
i.e., `$1' is replaced by `$argv[1]', etc.
Set by default yo, but probably empty up in interactizzle shells.
.TP 8
.B autocorrect \fR(+)
If set, tha \fIspell-word\fR editor command is invoked automatically before
each completion attempt.
.TP 8
.B autoexpand \fR(+)
If set, tha \fIexpand-history\fR editor command is invoked automatically
before each completion attempt. If dis is set ta \fIonlyhistory\fR, then
only history is ghon be expanded n' a second completion will expand filenames.
.TP 8
.B autolist \fR(+)
If set, possibilitizzles is listed afta a ambiguous completion.
If set ta `ambiguous', possibilitizzles is listed only when no new
charactas is added by completion.
.TP 8
.B autologout \fR(+)
Da first word is tha number of minutez of inactivitizzle before automatic
logout.  Da optionizzle second word is tha number of minutez of inactivity
before automatic locking.
When tha shell automatically logs out, it prints `auto-logout', sets the
variable \fBlogout\fR ta `automatic' n' exits.
When tha shell automatically locks, tha user is required ta enta his thugged-out lil' password
to continue working.  Five incorrect attempts result up in automatic logout.
Set ta `60' (automatic logout afta 60 minutes, n' no locking) by default
in login n' superuser shells yo, but not if tha shell be thinkin it is hustlin
under a window system (i.e., tha \fBDISPLAY\fR environment variable is set),
the tty be a pseudo-tty (pty) or tha shell was not so compiled (see the
\fBversion\fR shell variable).
See also tha \fBafsuser\fR n' \fBlogout\fR shell variables.
.TP 8
.B autorehash \fR(+)
If set, tha internal hash table of tha contentz of tha directories up in the
\fBpath\fR variable is ghon be recomputed if a cold-ass lil command aint found up in tha hash
table.  In addition, tha list of available commandz is ghon be rebuilt fo' each
command completion or spellin erection attempt if set ta `complete' or
`correct' respectively; if set ta `always', dis is ghon be done fo' both
cases.
.TP 8
.B backslash_quote \fR(+)
If set, backslashes (`\\') always quote `\\', `'', n' `"'.  This may make
complex quotin tasks easier yo, but it can cause syntax errors up in \fIcsh\fR(1)
scripts.
.TP 8
.B catalog
Da file name of tha message catalog.
If set, tcsh use `tcsh.${catalog}' as a message catalog instead of
default `tcsh'.
.TP 8
.B cdpath
A list of directories up in which \fIcd\fR should search for
subdirectories if they aren't found up in tha current directory.
.TP 8
.B color
If set, it enablez color display fo' tha builtin \fBls\-F\fR n' it passes
\fB\-\-color=auto\fR ta \fBls\fR.  Alternatively, it can be set ta only
\fBls\-F\fR or only \fBls\fR ta enable color ta only one command. Y'all KNOW dat shit, muthafucka!  Setting
it ta not a god damn thang is equivalent ta settin it ta \fB(ls\-F ls)\fR.
.TP 8
.B colorcat
If set, it enablez color escape sequence fo' NLS message files.
And display colorful NLS lyrics.
.TP 8
.B command \fR(+)
If set, tha command which was passed ta tha shell wit tha \fB-c\fR flag (q.v.).
.TP 8
.B compat_expr \fR(+)
If set, tha shell will evaluate expressions right ta left, like tha original
\fIcsh\fR.
.TP 8
.B complete \fR(+)
If set ta `igncase', tha completion becomes case insensitive.
If set ta `enhance', completion ignores case n' considers
hyphens n' underscores ta be equivalent; it will also treat
periods, hyphens n' underscores (`.', `\-' n' `_') as word
separators.
If set ta `Enhance', completion matches uppercase n' underscore
charactas explicitly n' matches lowercase n' hyphens up in a
case-insensivite manner; it will treat periods, hypens n' underscores
as word separators.
.TP 8
.B continue \fR(+)
If set ta a list of commands, tha shell will continue tha listed
commands, instead of startin a freshly smoked up one.
.TP 8
.B continue_args \fR(+)
Same as continue yo, but tha shell will execute:
.RS +8
.IP "" 4
echo `pwd` $argv > ~/.<cmd>_pause; %<cmd>
.RE
.TP 8
.B erect \fR(+)
If set ta `cmd', commandz is automatically spelling-corrected.
If set ta `complete', commandz is automatically completed.
If set ta `all', tha entire command line is erected.
.TP 8
.B csubstnonl \fR(+)
If set, newlines n' carriage returns up in command substitution are
replaced by spaces.  Set by default.
.TP 8
.B cwd
Da full pathname of tha current directory.
See also tha \fBdirstack\fR n' \fBowd\fR shell variables.
.TP 8
.B dextract \fR(+)
If set, `pushd +\fIn\fR' extracts tha \fIn\fRth directory from tha directory
stack rather than rotatin it ta tha top.
.TP 8
.B dirsfile \fR(+)
Da default location up in which `dirs \-S' n' `dirs \-L' look for
a history file.  If unset, \fI~/.cshdirs\fR is used.
Because only \fI~/.tcshrc\fR is normally sourced before \fI~/.cshdirs\fR,
\fBdirsfile\fR should be set up in \fI~/.tcshrc\fR rather than \fI~/.login\fR.
.TP 8
.B dirstack \fR(+)
An array of all tha directories on tha directory stack.
`$dirstack[1]' is tha current hustlin directory, `$dirstack[2]'
the first directory on tha stack, etc.
Note dat tha current hustlin directory is `$dirstack[1]' but `=0' in
directory stack substitutions, etc.
One can chizzle tha stack arbitrarily by settin \fBdirstack\fR,
but tha straight-up original gangsta element (the current hustlin directory) be always erect.
See also tha \fBcwd\fR n' \fBowd\fR shell variables.
.TP 8
.B dspmbyte \fR(+)
Has a effect iff 'dspm' is listed as part of tha \fBversion\fR shell variable.
If set ta `euc', it enablez display n' editin EUC-kanji(Japanese) code.
If set ta `sjis', it enablez display n' editin Shift-JIS(Japanese) code.
If set ta `big5', it enablez display n' editin Big5(Chinese) code.
If set ta `utf8', it enablez display n' editin Utf8(Unicode) code.
If set ta tha followin format, it enablez display n' editin of original
multi-byte code format:
.RS +8
.IP "" 4
> set dspmbyte = 0000....(256 bytes)....0000
.PP
Da table requires \fBjust\fR 256 bytes.  Each characta of 256 characters
correspondz (from left ta right) ta tha ASCII codes 0x00, 0x01, ... 0xff.  Each
character
.\" (posizzle up in dis table?)
is set ta number 0,1,2 n' 3.  Each number has tha followin meaning:
.br
  0 ... not used fo' multi-byte characters.
.br
  1 ... used fo' tha straight-up original gangsta byte of a multi-byte character.
.br
  2 ... used fo' tha second byte of a multi-byte character.
.br
  3 ... used fo' both tha straight-up original gangsta byte n' second byte of a multi-byte character.
.\" SHK: I tried mah dopest ta git tha followin ta be grammatically erect.
.\" But fuck dat shiznit yo, tha word on tha street is dat I still don't KNOW what tha fuck be happenin here, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  In the
.\" followin example, there be three bytes yo, but tha text seems ta refer to
.\" each nybble as a cold-ass lil character n' shit.  Whatz goin on here?  It dis 3-byte code
.\" up in tha table?  Da text above seems ta imply dat there be 256
.\" characters/bytes up in tha table.  If I git some mo' info on dis (like
.\" a cold-ass lil complete example), I could fix tha text ta be grammatically erect.
.\" (steve.kelem@xilinx.com 1999/09/13)
.PP
  Example:
.br
If set ta `001322', tha straight-up original gangsta characta (means 0x00 of tha ASCII code) and
second characta (means 0x01 of ASCII code) is set ta `0'.  Then, it is not
used fo' multi-byte characters.  Da 3rd characta (0x02) is set ta '1',
indicatin dat it is used fo' tha straight-up original gangsta byte of a multi-byte character.
Da 4th character(0x03) is set '3'.  It be used fo' both tha straight-up original gangsta byte and
the second byte of a multi-byte character n' shit.  Da 5th n' 6th characters
(0x04,0x05) is set ta '2', indicatin dat they is used fo' tha second
byte of a multi-byte character.
.PP
Da GNU fileutils version of ls cannot display multi-byte
filenames without tha -N ( --literal ) option. I aint talkin' bout chicken n' gravy biatch.   If yo ass is using
this version, set tha second word of dspmbyte ta "ls".  If not, for
example, "ls-F -l" cannot display multi-byte filenames.
.PP
  Note:
.br
This variable can only be used if KANJI n' DSPMBYTE has been defined at
compile time.
.RE
.TP 8
.B dunique \fR(+)
If set, \fIpushd\fR removes any instancez of \fIname\fR
from tha stack before pushin it onto tha stack.
.TP 8
.B echo
If set, each command wit its arguments is echoed just before it is
executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For non-builtin commandz all expansions occur before
echoing.  Builtin commandz is echoed before command n' filename
substitution, cuz these substitutions is then done selectively.
Set by tha \fB\-x\fR command line option.
.TP 8
.B echo_style \fR(+)
Da steez of tha \fIecho\fR builtin. I aint talkin' bout chicken n' gravy biatch.  May be set to
.PP
.RS +8
.PD 0
.TP 8
bsd
Don't echo a newline if tha straight-up original gangsta argument is `\-n'.
.TP 8
sysv
Recognize backslashed escape sequences up in echo strings.
.TP 8
both
Recognize both tha `\-n' flag n' backslashed escape sequences; tha default.
.TP 8
none
Recognize neither.
.PD
.PP
Set by default ta tha local system default.  Da BSD n' System V
options is busted lyrics bout up in tha \fIecho\fR(1) playa pages on tha appropriate
systems.
.RE
.TP 8
.B edit \fR(+)
If set, tha command-line editor is used. Y'all KNOW dat shit, muthafucka!  Set by default up in interactive
shells.
.TP 8
.B ellipsis \fR(+)
If set, tha `%c'/`%.' n' `%C' prompt sequences (see tha \fBprompt\fR
shell variable) indicate skipped directories wit a ellipsis (`...')
instead of `/<skipped>'.
.TP 8
.B euid \fR(+)
Da userz effectizzle user ID.
.TP 8
.B euser \fR(+)
Da first matchin passwd entry name correspondin ta tha effectizzle user ID.
.TP 8
.B fignore \fR(+)
Lists file name suffixes ta be ignored by completion.
.TP 8
.B filec
In \fItcsh\fR, completion be always used n' dis variable is ignored
by default. If 
.B edit
is unset, then tha traditionizzle \fIcsh\fR completion is used.
If set up in \fIcsh\fR, filename completion is used.
.TP 8
.B gid \fR(+)
Da userz real crew ID.
.TP 8
.B globdot \fR(+)
If set, wild-card glob patterns will match filez n' directories beginning
with `.' except fo' `.' n' `..'
.TP 8
.B globstar \fR(+)
If set, tha `**' n' `***' file glob patterns will match any strang of 
charactas includin `/' traversin any existin sub-directories. Put ya muthafuckin choppers up if ya feel dis!  (e.g. 
`ls **.c' will list all tha .c filez up in tha current directory tree).
If used by itself, it will match zero or mo' sub-directories
(e.g. `ls /usr/include/**/time.h' will list any file named `time.h'
in tha /usr/include directory tree; whereas `ls /usr/include/**time.h'
will match any file up in tha /usr/include directory tree endin up in `time.h').
To prevent problems wit recursion, tha `**' glob-pattern aint gonna 
descend tha fuck into a symbolic link containin a gangbangin' finger-lickin' directory.  To override this,
use `***'
.TP 8
.B crew \fR(+)
Da userz crew name.
.TP 8
.B highlight
If set, tha incremenstrual search match (in \fIi-search-back\fR and
\fIi-search-fwd\fR) n' tha region between tha mark n' tha cursor are
highlighted up in reverse vizzle.
.IP "" 8
Highlightin requires mo' frequent terminal writes, which introduces extra
overhead. Y'all KNOW dat shit, muthafucka! If you care bout terminal performance, you may wanna leave this
unset.
.TP 8
.B histchars
A strang value determinin tha charactas used up in \fBHistory
substitution\fR (q.v.).  Da first characta of its value is used as
the history substitution character, replacin tha default character
`!'.  Da second characta of its value replaces tha characta `^' in
quick substitutions.
.TP 8
.B histdup \fR(+)
Controls handlin of duplicate entries up in tha history list.  If set to
`all' only unique history events is entered up in tha history list.  If
set ta `prev' n' tha last history event is tha same ol' dirty as tha current
command, then tha current command aint entered up in tha history.  If
set ta `erase' n' tha same event is found up in tha history list, that
old event gets erased n' tha current one gets inserted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Note dat the
`prev' n' `all' options renumber history events so there be no gaps.
.TP 8
.B histfile \fR(+)
Da default location up in which `history \-S' n' `history \-L' look for
a history file.  If unset, \fI~/.history\fR is used. Y'all KNOW dat shit, muthafucka!  \fBhistfile\fR is
useful when pluggin tha same home directory between different machines,
or when savin separate histories on different terminals.  Because only
\fI~/.tcshrc\fR is normally sourced before \fI~/.history\fR,
\fBhistfile\fR should be set up in \fI~/.tcshrc\fR rather than
\fI~/.login\fR.
.TP 8
.B histlit \fR(+)
If set, builtin n' editor commandz n' tha \fBsavehist\fR mechanism
use tha literal (unexpanded) form of lines up in tha history list.  See
also tha \fItoggle-literal-history\fR editor command.
.TP 8
.B history
Da first word indicates tha number of history events ta save.  The
optionizzle second word (+) indicates tha format up in which history is
printed; if not given, `%h\\t%T\\t%R\\n' is used. Y'all KNOW dat shit, muthafucka!  Da format sequences
are busted lyrics bout below under \fBprompt\fR; note tha variable meanin of
`%R'.  Set ta `100' by default.
.TP 8
.B home
Initialized ta tha home directory of tha invoker n' shit.  Da filename
expansion of `\fI~\fR' refers ta dis variable.
.TP 8
.B ignoreeof
If set ta tha empty strang or `0' n' tha input thang be a terminal,
the \fIend-of-file\fR command (usually generated by tha user by typing
`^D' on a empty line) causes tha shell ta print `Use "exit" ta leave
tcsh.' instead of exiting.  This prevents tha shell from accidentally
bein capped. Y'all KNOW dat shit, muthafucka!  Historically dis settin exited afta 26 successive
EOFz ta avoid infinite loops.  If set ta a number \fIn\fR, tha shell
ignores \fIn - 1\fR consecutizzle \fIend-of-file\fRs n' exits on the
\fIn\fRth.  (+) If unset, `1' is used, i.e., tha shell exits on a
single `^D'.
.TP 8
.B implicitcd \fR(+)
If set, tha shell treats a gangbangin' finger-lickin' directory name typed as a cold-ass lil command as though
it was a request ta chizzle ta dat directory.  If set ta \fIverbose\fR,
the chizzle of directory is echoed ta tha standard output.  This behavior
is inhibited up in non-interactizzle shell scripts, or fo' command strings
with mo' than one word. Y'all KNOW dat shit, muthafucka!  Changin directory takes precedence over
executin a like-named command yo, but it is done afta alias
substitutions.  Tilde n' variable expansions work as expected.
.TP 8
.B inputmode \fR(+)
If set ta `insert' or `overwrite', puts tha editor tha fuck into dat input mode
at tha beginnin of each line.
.TP 8
.B killdup \fR(+)
Controls handlin of duplicate entries up in tha bust a cap up in ring.  If set to
`all' only unique strings is entered up in tha bust a cap up in ring.  If set to
`prev' n' tha last capped strang is tha same ol' dirty as tha current capped
string, then tha current strang aint entered up in tha ring.  If set
to `erase' n' tha same strang is found up in tha bust a cap up in ring, tha old
strin is erased n' tha current one is inserted.
.TP 8
.B killrin \fR(+)
Indicates tha number of capped strings ta keep up in memory.  Set ta `30'
by default.  If unset or set ta less than `2', tha shell will only
keep da most thugged-out recently capped string.
Strings is put up in tha killrin by tha editor commandz dat delete
(kill) stringz of text, e.g. \fIbackward-delete-word\fR,
\fIkill-line\fR, etc, as well as tha \fIcopy-region-as-kill\fR command.
Da \fIyank\fR editor command will yank da most thugged-out recently capped string
into tha command-line, while \fIyank-pop\fR (see \fBEditor commands\fR)
can be used ta yank earlier capped strings.
.TP 8
.B listflags \fR(+)
If set ta `x', `a' or `A', or any combination thereof (e.g., `xA'), they
are used as flags ta \fIls\-F\fR, makin it act like `ls \-xF', `ls
\-Fa', `ls \-FA' or a cold-ass lil combination (e.g., `ls \-FxA'): `a' shows all
filez (even if they start wit a `.'), `A' shows all filez but `.' and
`..', n' `x' sorts across instead of down. I aint talkin' bout chicken n' gravy biatch.  If tha second word of
\fBlistflags\fR is set, it is used as tha path ta `ls(1)'.
.TP 8
.B listjobs \fR(+)
If set, all thangs is listed when a thang is suspended. Y'all KNOW dat shit, muthafucka!  If set ta `long',
the listin is up in long format.
.TP 8
.B listlinks \fR(+)
If set, tha \fIls\-F\fR builtin command shows tha type of file ta which
each symbolic link points.
.TP 8
.B listmax \fR(+)
Da maximum number of shit which tha \fIlist-choices\fR editor command
will list without askin first.
.TP 8
.B listmaxrows \fR(+)
Da maximum number of rowz of shit which tha \fIlist-choices\fR editor
command will list without askin first.
.TP 8
.B loginsh \fR(+)
Set by tha shell if it aint nuthin but a login shell.  Settin or unsettin it
within a gangbangin' finger-lickin' dirty-ass shell has no effect.  See also \fBshlvl\fR.
.TP 8
.B logout \fR(+)
Set by tha shell ta `normal' before a aiiight logout, `automatic' before
an automatic logout, n' `hangup' if tha shell was capped by a hangup
signal (see \fBSignal handling\fR).  See also tha \fBautologout\fR
shell variable.
.TP 8
.B mail
A list of filez n' directories ta check fo' incomin mail, optionally
preceded by a numeric word. Y'all KNOW dat shit, muthafucka!  Before each prompt, if 10 minutes have
passed since tha last check, tha shell checks each file n' say `You
have freshly smoked up mail.' (or, if \fBmail\fR gotz nuff multiple files, `Yo ass have
new mail up in \fIname\fR.') if tha filesize is pimped outa than zero up in size
and has a modification time pimped outa than its access time.
.PP
.RS +8
.PD
.PP
If yo ass is up in a login shell, then no mail file is reported unless it has
been modified afta tha time tha shell has started up, ta prevent
redundant notifications.  Most login programs will rap  whether or not
you have mail when you log in.
.PP
If a gangbangin' file specified up in \fBmail\fR be a gangbangin' finger-lickin' directory, tha shell will count each
file within dat directory as a separate message, n' will report `Yo ass have
\fIn\fR mails.' or `Yo ass have \fIn\fR mails up in \fIname\fR.' as appropriate.
This functionalitizzle is provided primarily fo' dem systems which store mail
in dis manner, like fuckin tha Andrew Mail System.
.PP
If tha straight-up original gangsta word of \fBmail\fR is numeric it is taken as a gangbangin' finger-lickin' different mail
checkin interval, up in seconds.
.PP
Under straight-up rare circumstances, tha shell may report `Yo ass have mail.' instead
of `Yo ass have freshly smoked up mail.'
.RE
.TP 8
.B matchbeep \fR(+)
If set ta `never', completion never beeps.
If set ta `nomatch', it beeps only when there is no match.
If set ta `ambiguous', it beeps when there be multiple matches.
If set ta `notunique', it beeps when there is one exact n' other longer matches.
If unset, `ambiguous' is used.
.TP 8
.B nobeep \fR(+)
If set, beepin is straight-up disabled.
See also \fBvisiblebell\fR.
.TP 8
.B noclobber
If set, restrictions is placed on output redirection ta insure dat files
are not accidentally destroyed n' dat `>>' redirections refer ta existing
files, as busted lyrics bout up in tha \fBInput/output\fR section.
.TP 8
.B noding
If set, disable tha printin of `DING!' up in tha \fBprompt\fR time
specifiers all up in tha chizzle of hour.
.TP 8
.B noglob
If set, \fBFilename substitution\fR n' \fBDirectory stack substitution\fR
(q.v.) is inhibited. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  This is most useful up in shell scripts which do not deal
with filenames, or afta a list of filenames has been obtained n' further
expansions is not desirable.
.TP 8
.B nokanji \fR(+)
If set n' tha shell supports Kanji (see tha \fBversion\fR shell variable),
it is disabled so dat tha meta key can be used.
.TP 8
.B nonomatch
If set, a \fBFilename substitution\fR or \fBDirectory stack substitution\fR
(q.v.) which do not match any
existin filez is left untouched rather than causin a error.
It be still a error fo' tha substitution ta be
malformed, e.g., `echo [' still gives a error.
.TP 8
.B nostat \fR(+)
A list of directories (or glob-patterns which match directories; see
\fBFilename substitution\fR) dat should not be \fIstat\fR(2)ed durin a
completion operation. I aint talkin' bout chicken n' gravy biatch.  This is probably used ta exclude directories which
take too much time ta \fIstat\fR(2), fo' example \fI/afs\fR.
.TP 8
.B notify
If set, tha shell announces thang completions asynchronously.
Da default is ta present thang completions just before printin a prompt.
.TP 8
.B oid \fR(+)
Da userz real organization ID.  (Domain/OS only)
.TP 8
.B owd \fR(+)
Da oldschool hustlin directory, equivalent ta tha `\-' used by \fIcd\fR n' \fIpushd\fR.
See also tha \fBcwd\fR n' \fBdirstack\fR shell variables.
.TP 8
.B padhour
If set, enable tha printin of paddin '0' fo' hours, up in 24 n' 12 hour
formats, n' you can put dat on yo' toast.  E.G.: 07:45:42 vs. 7:45:42.
.TP 8
.B parseoctal
To retain compatibily wit olda versions numeric variablez startin with
0 is not interpreted as octal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Settin dis variable enablez proper octal
parsing.
.TP 8
.B path
A list of directories up in which ta look fo' executable commands.
A null word specifies tha current directory.
If there is no \fBpath\fR variable then only full path names will execute.
\fBpath\fR is set by tha shell at startup from tha \fBPATH\fR environment
variable or, if \fBPATH\fR do not exist, ta a system-dependent default
suttin' like `(/usr/local/bin /usr/bsd /bin /usr/bin .)'.
Da shell may put `.' first or last up in \fBpath\fR or omit it entirely
dependin on how tha fuck dat shiznit was compiled; peep tha \fBversion\fR shell variable.
A shell which is given neither tha \fB\-c\fR nor tha \fB\-t\fR option
hashes tha contentz of tha directories up in \fBpath\fR after
readin \fI~/.tcshrc\fR n' each time \fBpath\fR is reset.
If one addz a freshly smoked up command ta a gangbangin' finger-lickin' directory up in \fBpath\fR while tha shell
is active, one may need ta do a \fIrehash\fR fo' tha shell ta find dat shit.
.TP 8
.B printexitvalue \fR(+)
If set n' a interactizzle program exits wit a non-zero status, tha shell
prints `Exit \fBstatus\fR'.
.TP 8
.B prompt
Da strang which is printed before readin each command from tha terminal.
\fBprompt\fR may include any of tha followin formattin sequences (+), which
are replaced by tha given shiznit:
.PP
.RS +8
.PD 0
.TP 4
%/
Da current hustlin directory.
.TP 4
%~
Da current hustlin directory yo, but wit onez home directory
represented by `~' n' other users' home directories represented by
`~user' as per \fBFilename substitution\fR.  `~user' substitution
happens only if tha shell has already used `~\fIuser\fR' up in a pathname
in tha current session.
.TP 4
%c[[0]\fIn\fR], %.[[0]\fIn\fR]
Da trailin component of tha current hustlin directory, or \fIn\fR
trailin components if a gangbangin' finger-lickin' digit \fIn\fR is given.
If \fIn\fR begins wit `0', tha number of skipped components precede
the trailin component(s) up in tha format `/<\fIskipped\fR>trailing'.
If tha \fBellipsis\fR shell variable is set, skipped components
are represented by a ellipsis so tha whole becomes `...trailing'.
`~' substitution is done as up in `%~' above yo, but tha `~' component
is ignored when countin trailin components.
.TP 4
%C
Like %c yo, but without `~' substitution.
.TP 4
%h, %!, !
Da current history event number.
.TP 4
%M
Da full hostname.
.TP 4
%m
Da hostname up ta tha straight-up original gangsta `.'.
.TP 4
%S (%s)
Start (stop) standout mode.
.TP 4
%B (%b)
Start (stop) boldfacin mode.
.TP 4
%U (%u)
Start (stop) underline mode.
.TP 4
%t, %@
Da time of dizzle up in 12-hour AM/PM format.
.TP 4
%T
Like `%t' yo, but up in 24-hour format (but peep tha \fBampm\fR shell variable).
.TP 4
%p
Da `precise' time of dizzle up in 12-hour AM/PM format, wit seconds.
.TP 4
%P
Like `%p' yo, but up in 24-hour format (but peep tha \fBampm\fR shell variable).
.TP 4
\e\fIc\fR
\fIc\fR is parsed as up in \fIbindkey\fR.
.TP 4
^\fIc\fR
\fIc\fR is parsed as up in \fIbindkey\fR.
.TP 4
%%
A single `%'.
.TP 4
%n
Da user name.
.TP 4
%N
Da effectizzle user name.
.TP 4
%j
Da number of thangs.
.TP 4
%d
Da weekdizzle up in `Day' format.
.TP 4
%D
Da dizzle up in `dd' format.
.TP 4
%w
Da month up in `Mon' format.
.TP 4
%W
Da month up in `mm' format.
.TP 4
%y
Da year up in `yy' format.
.TP 4
%Y
Da year up in `yyyy' format.
.TP 4
%l
Da shellz tty.
.TP 4
%L
Clears from tha end of tha prompt ta end of tha display or tha end of tha line.
.TP 4
%$
Expandz tha shell or environment variable name immediately afta tha `$'.
.TP 4
%#
`>' (or tha straight-up original gangsta characta of tha \fBpromptchars\fR shell variable)
for aiiight users, `#' (or tha second characta of \fBpromptchars\fR)
for tha superuser.
.TP 4
%{\fIstring\fR%}
Includes \fIstring\fR as a literal escape sequence.
It should be used only ta chizzle terminal attributes and
should not move tha cursor location. I aint talkin' bout chicken n' gravy biatch.  This
cannot be tha last sequence up in \fBprompt\fR.
.TP 4
%?
Da return code of tha command executed just before tha prompt.
.TP 4
%R
In \fBprompt2\fR, tha statuz of tha parser.
In \fBprompt3\fR, tha erected string.
In \fBhistory\fR, tha history string.
.PD
.PP
`%B', `%S', `%U' n' `%{\fIstring\fR%}' is available up in only
eight-bit-clean shells; peep tha \fBversion\fR shell variable.
.PP
Da bold, standout n' underline sequences is often used ta distinguish a
superuser shell.  For example,
.IP "" 4
> set prompt = "%m [%h] %B[%@]%b [%/] you rang? "
.br
tut [37] \fB[2:54pm]\fR [/usr/accts/sys] you rang? _
.PP
If `%t', `%@', `%T', `%p', or `%P' is used, n' \fBnoding\fR aint set,
then print `DING!' on tha chizzle of minute (i.e, `:00' minutes) instead of
the actual time.
.PP
Set by default ta `%# ' up in interactizzle shells.
.RE
.TP 8
.B prompt2 \fR(+)
Da strang wit which ta prompt up in \fIwhile\fR n' \fIforeach\fR loops and
afta lines endin up in `\\'.
Da same format sequences may be used as up in \fBprompt\fR (q.v.);
note tha variable meanin of `%R'.
Set by default ta `%R? ' up in interactizzle shells.
.TP 8
.B prompt3 \fR(+)
Da strang wit which ta prompt when confirmin automatic spellin erection.
Da same format sequences may be used as up in \fBprompt\fR (q.v.);
note tha variable meanin of `%R'.
Set by default ta `CORRECT>%R (y|n|e|a)? ' up in interactizzle shells.
.TP 8
.B promptchars \fR(+)
If set (to a two-characta string), tha `%#' formattin sequence up in the
\fBprompt\fR shell variable is replaced wit tha straight-up original gangsta characta for
normal playas n' tha second characta fo' tha superuser.
.TP 8
.B pushdtohome \fR(+)
If set, \fIpushd\fR without arguments do `pushd ~', like \fIcd\fR.
.TP 8
.B pushdsilent \fR(+)
If set, \fIpushd\fR n' \fIpopd\fR do not print tha directory stack.
.TP 8
.B recexact \fR(+)
If set, completion completes on a exact match even if a longer match is
possible.
.TP 8
.B recognize_only_executablez \fR(+)
If set, command listin displays only filez up in tha path dat are
executable.  Slow.
.TP 8
.B rmstar \fR(+)
If set, tha user is prompted before `rm *' is executed.
.TP 8
.B rprompt \fR(+)
Da strang ta print on tha right-hand side of tha screen (after
the command input) when tha prompt is bein displayed on tha left.
It recognizes tha same ol' dirty formattin charactas as \fBprompt\fR.
It will automatically disappear n' reappear as necessary, ta ensure that
command input aint obscured, n' will step tha fuck up only if tha prompt,
command input, n' itself will fit together on tha straight-up original gangsta line.
If \fBedit\fR aint set, then \fBrprompt\fR is ghon be printed after
the prompt n' before tha command input.
.TP 8
.B savedirs \fR(+)
If set, tha shell do `dirs \-S' before exiting.
If tha straight-up original gangsta word is set ta a number, at most dat nuff directory stack
entries is saved.
.TP 8
.B savehist
If set, tha shell do `history \-S' before exiting.
If tha straight-up original gangsta word is set ta a number, at most dat nuff lines is saved.
(Da number must be less than or equal ta \fBhistory\fR.)
If tha second word is set ta `merge', tha history list is merged with
the existin history file instead of replacin it (if there is one) and
sorted by time stamp n' da most thugged-out recent events is retained. Y'all KNOW dat shit, muthafucka!  (+)
.TP 8
.B sched \fR(+)
Da format up in which tha \fIsched\fR builtin command prints scheduled events;
if not given, `%h\\t%T\\t%R\\n' is used.
Da format sequences is busted lyrics bout above under \fBprompt\fR;
note tha variable meanin of `%R'.
.TP 8
.B shell
Da file up in which tha shell resides.  This is used up in forking
shells ta interpret filez which have execute bits set yo, but
which is not executable by tha system.  (See tha description
of \fBBuiltin n' non-builtin command execution\fR.)  Initialized ta the
(system-dependent) home of tha shell.
.TP 8
.B shlvl \fR(+)
Da number of nested shells.
Reset ta 1 up in login shells.
See also \fBloginsh\fR.
.TP 8
.B status
Da status returned by tha last command, unless tha variable
.B anyerror
is set, n' any error up in a pipeline or a funky-ass backquote expansion will be
propagated (this is tha default
.B csh
behavior, n' tha current
.B tcsh
default). If it terminated
abnormally, then 0200 be added ta tha status.  Builtin commands
which fail return exit status `1', all other builtin commands
return status `0'.
.TP 8
.B symlinks \fR(+)
Can be set ta nuff muthafuckin different joints ta control symbolic link (`symlink')
resolution:
.RS +8
.PP
If set ta `chase', whenever tha current directory chizzlez ta a gangbangin' finger-lickin' directory
containin a symbolic link, it is expanded ta tha real name of tha directory
to which tha link points, n' you can put dat on yo' toast.  This do not work fo' tha userz home directory;
this be a funky-ass bug.
.PP
If set ta `ignore', tha shell tries ta construct a cold-ass lil current directory
relatizzle ta tha current directory before tha link was crossed.
This means dat \fIcd\fRin all up in a symbolic link n' then `cd ..'ing
returns one ta tha original gangsta directory.  This affects only builtin commands
and filename completion.
.PP
If set ta `expand', tha shell tries ta fix symbolic links by straight-up expanding
arguments which be lookin like path names.  This affects any command, not just
builtins.  Unfortunately, dis do not work fo' hard-to-recognize filenames,
like fuckin dem embedded up in command options.  Expansion may be prevented by
quoting.  While dis settin is probably da most thugged-out convenient, it is sometimes
misleadin n' sometimes confusin when it fails ta recognize a argument
which should be expanded. Y'all KNOW dat shit, muthafucka!  A compromise is ta use `ignore' n' use the
editor command \fInormalize-path\fR (bound by default ta ^X-n) when necessary.
.PP
Some examplez is up in order n' shit.  First, letz set up some play directories:
.IP "" 4
> cd /tmp
.br
> mkdir from from/src to
.br
> ln \-s from/src to/dst
.PP
Herez tha behavior wit \fBsymlinks\fR unset,
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/from
.PP
herez tha behavior wit \fBsymlinks\fR set ta `chase',
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/from/src
.br
> cd ..; echo $cwd
.br
/tmp/from
.PP
herez tha behavior wit \fBsymlinks\fR set ta `ignore',
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/to
.PP
and herez tha behavior wit \fBsymlinks\fR set ta `expand'.
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/to
.br
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ".."; echo $cwd
.br
/tmp/from
.br
> /bin/echo ..
.br
/tmp/to
.br
> /bin/echo ".."
.br
\&..
.PP
Note dat `expand' expansion 1) works just like `ignore' fo' builtins
like \fIcd\fR, 2) is prevented by quoting, n' 3) happens before
filenames is passed ta non-builtin commands.
.RE
.TP 8
.B tcsh \fR(+)
Da version number of tha shell up in tha format `R.VV.PP',
where `R' is tha major release number, `VV' tha current version
and `PP' tha patchlevel.
.TP 8
.B term
Da terminal type.  Usually set up in \fI~/.login\fR as busted lyrics bout under
\fBStartup n' shutdown\fR.
.TP 8
.B time
If set ta a number, then tha \fItime\fR builtin (q.v.) executes automatically
afta each command which takes mo' than dat nuff CPU seconds.
If there be a second word, it is used as a gangbangin' format strang fo' tha output
of tha \fItime\fR builtin. I aint talkin' bout chicken n' gravy biatch.  (u) Da followin sequences may be used up in the
format string:
.PP
.RS +8
.PD 0
.TP 4
%U
Da time tha process dropped up in user mode up in cpu seconds.
.TP 4
%S
Da time tha process dropped up in kernel mode up in cpu seconds.
.TP 4
%E
Da elapsed (wall clock) time up in seconds.
.TP 4
%P
Da CPU cementage computed as (%U + %S) / %E.
.TP 4
%W
Number of times tha process was swapped.
.TP 4
%X
Da average amount up in (shared) text space used up in Kbytes.
.TP 4
%D
Da average amount up in (unshared) data/stack space used up in Kbytes.
.TP 4
%K
Da total space used (%X + %D) up in Kbytes.
.TP 4
%M
Da maximum memory tha process had up in use at any time up in Kbytes.
.TP 4
%F
Da number of major page faults (page needed ta be brought from disk).
.TP 4
%R
Da number of minor page faults.
.TP 4
%I
Da number of input operations.
.TP 4
%O
Da number of output operations.
.TP 4
%r
Da number of socket lyrics received.
.TP 4
%s
Da number of socket lyrics sent.
.TP 4
%k
Da number of signals received.
.TP 4
%w
Da number of voluntary context switches (waits).
.TP 4
%c
Da number of involuntary context switches.
.PD
.PP
Only tha straight-up original gangsta four sequences is supported on systems without BSD resource
limit functions.
Da default time format is `%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww' for
systems dat support resource usage reportin n' `%Uu %Ss %E %P' for
systems dat do not.
.PP
Under Sequentz DYNIX/ptx, %X, %D, %K, %r n' %s is not
available yo, but tha followin additionizzle sequences are:
.PP
.PD 0
.TP 4
%Y
Da number of system calls performed.
.TP 4
%Z
Da number of pages which is zero-filled on demand.
.TP 4
%i
Da number of times a processs resident set size was increased by tha kernel.
.TP 4
%d
Da number of times a processs resident set size was decreased by tha kernel.
.TP 4
%l
Da number of read system calls performed.
.TP 4
%m
Da number of write system calls performed.
.TP 4
%p
Da number of readz from raw disk devices.
.TP 4
%q
Da number of writes ta raw disk devices.
.PD
.PP
and tha default time format is `%Uu %Ss %E %P %I+%Oio %Fpf+%Ww'.
Note dat tha CPU cementage can be higher than 100% on multi-processors.
.RE
.TP 8
.B tperiod \fR(+)
Da period, up in minutes, between executionz of tha \fIperiodic\fR special alias.
.TP 8
.B tty \fR(+)
Da name of tha tty, or empty if not attached ta one.
.TP 8
.B uid \fR(+)
Da userz real user ID.
.TP 8
.B user
Da userz login name.
.TP 8
.B verbose
If set, causes tha lyrics of each
command ta be printed, afta history substitution (if any).
Set by tha \fB\-v\fR command line option.
.TP 8
.B version \fR(+)
Da version ID stamp.  It gotz nuff tha shellz version number (see \fBtcsh\fR),
origin, release date, vendor, operatin system n' machine (see \fBVENDOR\fR,
\fBOSTYPE\fR n' \fBMACHTYPE\fR) n' a cold-ass lil comma-separated
list of options which was set at compile time.
Options which is set by default up in tha distribution is noted.
.PP
.RS +8
.PD 0
.TP 6
8b
Da shell is eight bit clean; default
.TP 6
7b
Da shell aint eight bit clean
.TP 6
wide
Da shell is multibyte encodin clean (like UTF-8)
.TP 6
nls
Da systemz NLS is used; default fo' systems wit NLS
.TP 6
lf
Login shells execute \fI/etc/csh.login\fR before instead of after
\fI/etc/csh.cshrc\fR n' \fI~/.login\fR before instead of after
\fI~/.tcshrc\fR n' \fI~/.history\fR.
.TP 6
dl
`.' is put last up in \fBpath\fR fo' security; default
.TP 6
nd
`.' is omitted from \fBpath\fR fo' security
.TP 6
vi
\fIvi\fR-style editin is tha default rather than \fIemacs\fR
.TP 6
dtr
Login shells drop DTR when exiting
.TP 6
bye
\fIbye\fR be a synonym fo' \fIlogout\fR n' \fIlog\fR
is a alternate name fo' \fIwatchlog\fR
.TP 6
al
\fBautologout\fR is enabled; default
.TP 6
kan
Kanji is used if appropriate accordin ta locale settings,
unless tha \fBnokanji\fR shell variable is set
.TP 6
sm
Da systemz \fImalloc\fR(3) is used
.TP 6
hb
Da `#!<program> <args>' convention is emulated when executin shell scripts
.TP 6
ng
Da \fInewgrp\fR builtin be available
.TP 6
rh
Da shell attempts ta set tha \fBREMOTEHOST\fR environment variable
.TP 6
afs
Da shell verifies yo' password wit tha kerberos server if local
authentication fails.  Da \fBafsuser\fR shell variable or the
\fBAFSUSER\fR environment variable override yo' local username if set.
.PD
.PP
An administrator may enta additionizzle strings ta indicate differences
in tha local version.
.RE
.TP 8
.B visiblebell \fR(+)
If set, a screen flash is used rather than tha audible bell.
See also \fBnobeep\fR.
.TP 8
.B peep \fR(+)
A list of user/terminal pairs ta peep fo' logins n' logouts.
If either tha user is `any' all terminals is peeped fo' tha given user
and vice versa.
Settin \fBwatch\fR ta `(any any)' watches all playas n' terminals.
For example,
.RS +8
.IP "" 4
set peep = (george ttyd1 any console $user any)
.PP
reports activitizzle of tha user `george' on ttyd1, any user on tha console, and
oneself (or a trespasser) on any terminal.
.PP
Logins n' logouts is checked every last muthafuckin 10 minutes by default yo, but tha first
word of \fBwatch\fR can be set ta a number ta check every last muthafuckin all kindsa muthafuckin minutes.
For example,
.IP "" 4
set peep = (1 any any)
.PP
reports any login/logout once every last muthafuckin minute.  For tha impatient, tha \fIlog\fR
builtin command triggers a \fBwatch\fR report at any time.  All current logins
are reported (as wit tha \fIlog\fR builtin) when \fBwatch\fR is first set.
.PP
Da \fBwho\fR shell variable controls tha format of \fBwatch\fR reports.
.RE
.TP 8
.B whoz ass \fR(+)
Da format strang fo' \fBwatch\fR lyrics.  Da followin sequences
are replaced by tha given shiznit:
.PP
.RS +8
.PD 0
.TP 4
%n
Da name of tha user whoz ass logged in/out.
.TP 4
%a
Da observed action, i.e., `logged on', `logged off' or `replaced \fIolduser\fR on'.
.TP 4
%l
Da terminal (tty) on which tha user logged in/out.
.TP 4
%M
Da full hostname of tha remote host, or `local' if tha login/logout was
from tha local host.
.TP 4
%m
Da hostname of tha remote host up ta tha straight-up original gangsta `.'.
Da full name is printed if it be a IP address or a X Window System display.
.PD
.PP
%M n' %m is available on only systems dat store tha remote hostname in
\fI/etc/utmp\fR.
If unset, `%n has %a %l from %m.' is used, or `%n has %a %l.' on systems
which don't store tha remote hostname.
.RE
.TP 8
.B wordchars \fR(+)
A list of non-alphanumeric charactas ta be considered part of a word by the
\fIforward-word\fR, \fIbackward-word\fR etc., editor commands.
If unset, `*?_\-.[]~=' is used.
.SH ENVIRONMENT
.TP 8
.B AFSUSER \fR(+)
Equivalent ta tha \fBafsuser\fR shell variable.
.TP 8
.B COLUMNS
Da number of columns up in tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \fBTerminal pimpment\fR.
.TP 8
.B DISPLAY
Used by X Window System (see \fIX\fR(1)).
If set, tha shell do not set \fBautologout\fR (q.v.).
.TP 8
.B EDITOR
Da pathname ta a thugged-out default editor.
See also tha \fBVISUAL\fR environment variable
and tha \fIrun-fg-editor\fR editor command.
.TP 8
.B GROUP \fR(+)
Equivalent ta tha \fBgroup\fR shell variable.
.TP 8
.B HOME
Equivalent ta tha \fBhome\fR shell variable.
.TP 8
.B HOST \fR(+)
Initialized ta tha name of tha machine on which tha shell
is hustlin, as determined by tha \fIgethostname\fR(2) system call.
.TP 8
.B HOSTTYPE \fR(+)
Initialized ta tha type of machine on which tha shell
is hustlin, as determined at compile time.  This variable is obsolete and
will be removed up in a gangbangin' future version.
.TP 8
.B HPATH \fR(+)
A colon-separated list of directories up in which tha \fIrun-help\fR editor
command looks fo' command documentation.
.TP 8
.B LANG
Gives tha preferred characta environment.
See \fBNatizzle Language System support\fR.
.TP 8
.B LC_CTYPE
If set, only ctype characta handlin is chizzled.
See \fBNatizzle Language System support\fR.
.TP 8
.B LINES
Da number of lines up in tha terminal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See \fBTerminal pimpment\fR.
.TP 8
.B LS_COLORS
Da format of dis variable is reminiscent of tha \fBtermcap(5)\fR
file format; a cold-ass lil colon-separated list of expressionz of tha form
"\fIxx=string\fR", where "\fIxx\fR" be a two-characta variable name.  The
variablez wit they associated defaults are:
.PP
.RS +8
.RS +4
.PD 0
.TP 12
no	0
Normal (non-filename) text
.TP 12
fi	0
Regular file
.TP 12
di	01;34
Directory
.TP 12
ln	01;36
Symbolic link
.TP 12
pi	33
Named pipe (FIFO)
.TP 12
so	01;35
Socket
.TP 12
do	01;35
Door
.TP 12
bd	01;33
Block device
.TP 12
cd	01;32
Characta device
.TP 12
ex	01;32
Executable file
.TP 12
mi	(none)
Missin file (defaults ta fi)
.TP 12
or	(none)
Orphaned symbolic link (defaults ta ln)
.TP 12
lc	^[[
Left code
.TP 12
rc	m
Right code
.TP 12
ec	(none)
End code (replaces lc+no+rc)
.PD
.RE
.PP
Yo ass need ta include only tha variablez you wanna chizzle from
the default.
.PP
File names can also be colorized based on filename extension.
This is specified up in tha \fBLS_COLORS\fR variable rockin tha syntax
\fB"*ext=string"\fR.  For example, rockin ISO 6429 codes, ta color
all C\-language source filez blue you would specify \fB"*.c=34"\fR.
This would color all filez endin up in \fB.c\fR up in blue (34) color.
.PP
Control charactas can be freestyled either up in C\-style\-escaped
notation, or up in stty\-like ^\-notation. I aint talkin' bout chicken n' gravy biatch.  Da C\-style notation
addz \fB^[\fR fo' Escape, \fB\_\fR fo' a aiiight space character,
and \fB?\fR fo' Delete.  In addition, tha \fB^[\fR escape character
can be used ta override tha default interpretation of \fB^[\fR,
\fB^\fR, \fB:\fR n' \fB=\fR.
.PP
Each file is ghon be freestyled as \fB<lc>\fR \fB<color-code>\fR
\fB<rc>\fR \fB<filename>\fR \fB<ec>\fR.  If tha \fB<ec>\fR
code is undefined, tha sequence \fB<lc>\fR \fB<no>
\fB<rc>\fR is ghon be used instead. Y'all KNOW dat shit, muthafucka!  This is generally mo' convenient
to use yo, but less general. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da left, right n' end codes are
provided so you don't gotta type common parts over n' over
again n' ta support weird terminals; yo big-ass booty is ghon generally not
need ta chizzle dem at all unless yo' terminal do not use
ISO 6429 color sequences but a gangbangin' finger-lickin' different system.
.PP
If yo' terminal do use ISO 6429 color codes, you can
compose tha type codes (i.e., all except tha \fBlc\fR, \fBrc\fR,
and \fBec\fR codes) from numerical commandz separated by semicolons.  The
most common commandz are:
.PP
.RS +8
.PD 0
.TP 4
0
to restore default color
.TP 4
1
for brighta colors
.TP 4
4
for underlined text
.TP 4
5
for flashin text
.TP 4
30
for black foreground
.TP 4
31
for red foreground
.TP 4
32
for chronic foreground
.TP 4
33
for yellow (or brown) foreground
.TP 4
34
for blue foreground
.TP 4
35
for purple foreground
.TP 4
36
for cyan foreground
.TP 4
37
for white (or gray) foreground
.TP 4
40
for black background
.TP 4
41
for red background
.TP 4
42
for chronic background
.TP 4
43
for yellow (or brown) background
.TP 4
44
for blue background
.TP 4
45
for purple background
.TP 4
46
for cyan background
.TP 4
47
for white (or gray) background
.PD
.RE
.PP
Not all commandz will work on all systems or display devices.
.PP
A few terminal programs do not recognize tha default end code
properly.  If all text gets colorized afta you do a gangbangin' finger-lickin' directory
listing, try changin tha \fBno\fR n' \fBfi\fR codes from 0 ta the
numerical codes fo' yo' standard fore- n' background colors.
.RE
.TP 8
.B MACHTYPE \fR(+)
Da machine type (microprocessor class or machine model), as determined at compile time.
.TP 8
.B NOREBIND \fR(+)
If set, printable charactas is not rebound ta \fIself-insert-command\fR.
See \fBNatizzle Language System support\fR.
.TP 8
.B OSTYPE \fR(+)
Da operatin system, as determined at compile time.
.TP 8
.B PATH
A colon-separated list of directories up in which ta look fo' executables.
Equivalent ta tha \fBpath\fR shell variable yo, but up in a gangbangin' finger-lickin' different format.
.TP 8
.B PWD \fR(+)
Equivalent ta tha \fBcwd\fR shell variable yo, but not synchronized ta it;
updated only afta a actual directory chizzle.
.TP 8
.B REMOTEHOST \fR(+)
Da host from which tha user has logged up in remotely, if dis is tha case and
the shell be able ta determine dat shit.  Set only if tha shell was so compiled;
see tha \fBversion\fR shell variable.
.TP 8
.B SHLVL \fR(+)
Equivalent ta tha \fBshlvl\fR shell variable.
.TP 8
.B SYSTYPE \fR(+)
Da current system type.  (Domain/OS only)
.TP 8
.B TERM
Equivalent ta tha \fBterm\fR shell variable.
.TP 8
.B TERMCAP
Da terminal capabilitizzle string.  See \fBTerminal pimpment\fR.
.TP 8
.B USER
Equivalent ta tha \fBuser\fR shell variable.
.TP 8
.B VENDOR \fR(+)
Da vendor, as determined at compile time.
.TP 8
.B VISUAL
Da pathname ta a thugged-out default full-screen editor.
See also tha \fBEDITOR\fR environment variable
and tha \fIrun-fg-editor\fR editor command.
.SH FILES
.PD 0
.TP 16
.I /etc/csh.cshrc
Read first by every last muthafuckin shell.
ConvexOS, Stellix n' Intel use \fI/etc/cshrc\fR and
NeXTs use \fI/etc/cshrc.std\fR.
A/UX, AMIX, Cray n' IRIX have no equivalent up in \fIcsh\fR(1),
but read dis file up in \fItcsh\fR anyway.
Solaris 2.x aint gots it either yo, but \fItcsh\fR readz \fI/etc/.cshrc\fR.  (+)
.TP 16
.I /etc/csh.login
Read by login shells afta \fI/etc/csh.cshrc\fR.
ConvexOS, Stellix n' Intel use \fI/etc/login\fR,
NeXTs use \fI/etc/login.std\fR, Solaris 2.x uses \fI/etc/.login\fR and
A/UX, AMIX, Cray n' IRIX use \fI/etc/cshrc\fR.
.TP 16
.I ~/.tcshrc \fR(+)
Read by every last muthafuckin shell afta \fI/etc/csh.cshrc\fR or its equivalent.
.TP 16
.I ~/.cshrc
Read by every last muthafuckin shell, if \fI~/.tcshrc\fR don't exist,
afta \fI/etc/csh.cshrc\fR or its equivalent.
This manual uses `\fI~/.tcshrc\fR' ta mean `\fI~/.tcshrc\fR or,
if \fI~/.tcshrc\fR aint found, \fI~/.cshrc\fR'.
.TP 16
.I ~/.history
Read by login shells afta \fI~/.tcshrc\fR
if \fBsavehist\fR is set yo, but peep also \fBhistfile\fR.
.TP 16
.I ~/.login
Read by login shells afta \fI~/.tcshrc\fR or \fI~/.history\fR.
Da shell may be compiled ta read \fI~/.login\fR before instead of after
\fI~/.tcshrc\fR n' \fI~/.history\fR; peep tha \fBversion\fR shell variable.
.TP 16
.I ~/.cshdirs \fR(+)
Read by login shells afta \fI~/.login\fR
if \fBsavedirs\fR is set yo, but peep also \fBdirsfile\fR.
.TP 16
.I /etc/csh.logout
Read by login shells at logout.
ConvexOS, Stellix n' Intel use \fI/etc/logout\fR and
NeXTs use \fI/etc/logout.std\fR.
A/UX, AMIX, Cray n' IRIX have no equivalent up in \fIcsh\fR(1),
but read dis file up in \fItcsh\fR anyway.
Solaris 2.x aint gots it either yo, but \fItcsh\fR readz \fI/etc/.logout\fR.  (+)
.TP 16
.I ~/.logout
Read by login shells at logout afta \fI/etc/csh.logout\fR or its equivalent.
.TP 16
.I /bin/sh
Used ta interpret shell scripts not startin wit a `#'.
.TP 16
.I /tmp/sh*
Temporary file fo' `<<'.
.TP 16
.I /etc/passwd
Source of home directories fo' `~name' substitutions.
.PD
.PP
Da order up in which startup filez is read may differ if tha shell was so
compiled; peep \fBStartup n' shutdown\fR n' tha \fBversion\fR shell variable.
.SH "NEW FEATURES (+)"
This manual raps bout \fItcsh\fR as a single entity,
but experienced \fIcsh\fR(1) playas will wanna pay special attention to
\fItcsh\fRz freshly smoked up features.
.PP
A command-line editor, which supports GNU Emacs or \fIvi\fR(1)-style
key bindings.  See \fBDa command-line editor\fR n' \fBEditor commands\fR.
.PP
Programmable, interactizzle word completion n' listing.
See \fBCompletion n' listing\fR n' tha \fIcomplete\fR n' \fIuncomplete\fR
builtin commands.
.PP
\fBSpellin erection\fR (q.v.) of filenames, commandz n' variables.
.PP
\fBEditor commands\fR (q.v.) which big-ass up other useful functions up in tha middle of
typed commands, includin documentation lookup (\fIrun-help\fR),
quick editor restartin (\fIrun-fg-editor\fR) and
command resolution (\fIwhich-command\fR).
.PP
An enhanced history mechanism.  Events up in tha history list is time-stamped.
See also tha \fIhistory\fR command n' its associated shell variables,
the previously undocumented `#' event specifier n' freshly smoked up modifiers
under \fBHistory substitution\fR,
the \fI*-history\fR, \fIhistory-search-*\fR, \fIi-search-*\fR, \fIvi-search-*\fR and
\fItoggle-literal-history\fR editor commands
and tha \fBhistlit\fR shell variable.
.PP
Enhanced directory parsin n' directory stack handling.
See tha \fIcd\fR, \fIpushd\fR, \fIpopd\fR n' \fIdirs\fR commandz n' they associated
shell variables, tha description of \fBDirectory stack substitution\fR,
the \fBdirstack\fR, \fBowd\fR n' \fBsymlinks\fR shell variablez and
the \fInormalize-command\fR n' \fInormalize-path\fR editor commands.
.PP
Negation up in glob-patterns.  See \fBFilename substitution\fR.
.PP
New \fBFile inquiry operators\fR (q.v.) n' a \fIfiletest\fR
builtin which uses em.
.PP
A variety of \fBAutomatic, periodic n' timed events\fR (q.v.) including
scheduled events, special aliases, automatic logout n' terminal locking,
command timin n' watchin fo' logins n' logouts.
.PP
Support fo' tha Natizzle Language System
(see \fBNatizzle Language System support\fR),
OS variant features
(see \fBOS variant support\fR n' tha \fBecho_style\fR shell variable)
and system-dependent file locations (see \fBFILES\fR).
.PP
Extensive terminal-management capabilities. Put ya muthafuckin choppers up if ya feel dis!  See \fBTerminal pimpment\fR.
.PP
New builtin commandz includin \fIbuiltins\fR, \fIhup\fR, \fIls\-F\fR,
\fInewgrp\fR, \fIprintenv\fR, \fIwhich\fR n' \fIwhere\fR (q.v.).
.PP
New variablez dat make useful shiznit easily available ta tha shell.
See tha \fBgid\fR, \fBloginsh\fR, \fBoid\fR, \fBshlvl\fR, \fBtcsh\fR,
\fBtty\fR, \fBuid\fR n' \fBversion\fR shell variablez n' tha \fBHOST\fR,
\fBREMOTEHOST\fR, \fBVENDOR\fR, \fBOSTYPE\fR n' \fBMACHTYPE\fR environment
variables.
.PP
A freshly smoked up syntax fo' includin useful shiznit up in tha prompt string
(see \fBprompt\fR),
and special prompts fo' loops n' spellin erection
(see \fBprompt2\fR n' \fBprompt3\fR).
.PP
Read-only variables.  See \fBVariable substitution\fR.
.SH BUGS
When a suspended command is restarted, tha shell prints tha directory
it started up in if dis is different from tha current directory.  This can
be misleadin (i.e., wrong) as tha thang may have chizzled directories internally.
.PP
Shell builtin functions is not stoppable/restartable.  Command sequences
of tha form `a ; b ; c' is also not handled gracefully when stoppin is
attempted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If you suspend `b', tha shell will then immediately execute
`c'.  This is especially noticeable if dis expansion thangs up in dis biatch from an
\fIalias\fR.  It suffices ta place tha sequence of commandz up in ()z ta force it
to a subshell, i.e., `( a ; b ; c )'.
.PP
Control over tty output afta processes is started is primitive; like
this will inspire one of mah thugs ta work on a phat virtual terminal intercourse.
In a virtual terminal intercourse much mo' bangin-ass thangs could be
done wit output control.
.PP
Alias substitution is most often used ta clumsily simulate shell procedures;
shell procedures should be provided rather than aliases.
.PP
Control structures should be parsed rather than bein recognized as
built-in commands.  This would allow control commandz ta be placed anywhere,
to be combined wit `|', n' ta be used wit `&' n' `;' metasyntax.
.PP
\fIforeach\fR don't ignore here documents when lookin fo' its \fIend\fR.
.PP
It should be possible ta use tha `:' modifiers on tha output of command
substitutions.
.PP
Da screen update fo' lines longer than tha screen width is straight-up skanky
if tha terminal cannot move tha cursor up (i.e., terminal type `dumb').
.PP
\fBHPATH\fR n' \fBNOREBIND\fR don't need ta be environment variables.
.PP
Glob-patterns which do not use `?', `*' or `[]' or which use `{}' or `~'
are not negated erectly.
.PP
Da single-command form of \fIif\fR do output redirection even if
the expression is false n' tha command aint executed.
.PP
\fIls\-F\fR includes file identification charactas when sortin filenames
and do not handle control charactas up in filenames well.  It cannot be
interrupted.
.PP
Command substitution supports multiple commandz n' conditions yo, but not
cyclez or backward \fIgoto\fRs.
.PP
Report bugs at http://bugs.gw.com/, preferably wit fixes.  If you want to
help maintain n' test tcsh, bust mail ta tcsh-request@mx.gw.com wit the
text `subscribe tcsh' on a line by itself up in tha body.
.SH THE T IN TCSH
In 1964, DEC produced tha PDP-6.  Da PDP-10 was a lata re-implementation. I aint talkin' bout chicken n' gravy biatch.  It
was re-christened tha DECsystem-10 up in 1970 or so when DEC brought up the
second model, tha KI10.
.PP
TENEX was pimped at Bolt, Beranek & Newman (a Cambridge, Massachusetts
think tank) in
1972 as a experiment up in demand-paged virtual memory operatin systems.  They
built a freshly smoked up pager fo' tha DEC PDP-10 n' pimped tha OS ta go wit dat shit.  It was
extremely successful up in academia.
.PP
In 1975, DEC brought up a freshly smoked up model of tha PDP-10, tha KL10; they intended to
have only a version of TENEX, which they had licensed from BBN, fo' tha new
box.  They called they version TOPS-20 (their capitalization is trademarked).
All dem TOPS-10 playas (`Da OPeratin System fo' PDP-10') objected; thus DEC
found theyselves supportin two incompatible systems on tha same hardware--but
then there was 6 on tha PDP-11!
.PP
TENEX, n' TOPS-20 ta version 3, had command completion
via a user-code-level subroutine library called ULTCMD.  With version 3, DEC
moved all dat capabilitizzle n' mo' tha fuck into tha monitor (`kernel' fo' you Unix
types), accessed by tha COMND% JSYS (`Jump ta SYStem' instruction, the
supervisor call mechanizzle [are mah IBM roots also showing?]).
.PP
Da creator of tcsh was impressed by dis feature n' nuff muthafuckin otherz of TENEX
and TOPS-20, n' pimped a version of csh which mimicked em.
.SH LIMITATIONS
Da system limits argument lists ta ARG_MAX characters.
.PP
Da number of arguments ta a cold-ass lil command which involves filename expansion is
limited ta 1/6th tha number of charactas allowed up in a argument list.
.PP
Command substitutions may substitute no mo' charactas than is allowed in
an argument list.
.PP
To detect looping, tha shell restricts tha number of \fIalias\fR
substitutions on a single line ta 20.
.SH "SEE ALSO"
csh(1), emacs(1), ls(1), newgrp(1), sh(1), setpath(1), stty(1), su(1),
tset(1), vi(1), x(1), access(2), execve(2), fork(2), killpg(2),
pipe(2), setrlimit(2), sigvec(2), stat(2), umask(2), vfork(2), wait(2),
malloc(3), setlocale(3), tty(4), a.out(5), termcap(5), environ(7),
termio(7), Introduction ta tha C Shell
.SH VERSION
This manual documents tcsh 6.18.01 (Astron) 2012-02-14.
.SH AUTHORS
.PD 0
.TP 2
Lil' Willy Joy
Original Gangsta lyricist of \fIcsh\fR(1)
.TP 2
J.E. Kulp, Pt IIASA, Laxenburg, Austria
Thang control n' directory stack features
.TP 2
Ken Greer, HP Labs, 1981
File name completion
.TP 2
Mike Ellis, Fairchild, 1983
Command name recognition/completion
.TP 2
Pizzle Placeway, Ohio State CIS Dept., 1983-1993
Command line editor, prompt routines, freshly smoked up glob syntax n' a shitload of fixes
and speedups
.TP 2
Karl Kleinpaste, CCI 1983-4
Special aliases, directory stack extraction stuff, login/logout watch,
scheduled events, n' tha scam of tha freshly smoked up prompt format
.TP 2
Rayan Zachariassen, Universitizzle of Toronto, 1984
\fIls\-F\fR n' \fIwhich\fR builtins n' a shitload of bug fixes, modifications
and speedups
.TP 2
Chris Mackdaddysley, Caltech
Fast storage allocator routines
.TP 2
Chris Grevstad, TRW, 1987
Incorporated 4.3BSD \fIcsh\fR tha fuck into \fItcsh\fR
.TP 2
Christos S. Zoulas, Cornell U. EE Dept., 1987-94
Ports ta HPUX, SVR2 n' SVR3, a SysV version of getwd.c, SHORT_STRINGS support
and a freshly smoked up version of sh.glob.c
.TP 2
Jizzy J Dempsey, BBN, n' Pizzle Placeway, OSU, 1988
A/UX port
.TP 2
Daniel Long, NNSC, 1988
\fBwordchars\fR
.TP 2
Patrick Wolfe, Kuck n' Associates, Inc., 1988
\fIvi\fR mode cleanup
.TP 2
Dizzy C Lawrence, Rensselaer Polytechnic Institute, 1989
\fBautolist\fR n' ambiguous completion listing
.TP 2
Alec Wolman, DEC, 1989
Newlines up in tha prompt
.TP 2
Mack Landau, BBN, 1989
\fI~/.tcshrc\fR
.TP 2
Ray Vibey, Purdue Physics, 1989
Magic space bar history expansion
.TP 2
Mordechai ????, Intel, 1989
printprompt() fixes n' additions
.TP 2
Kazuhiro Honda, Dept. of Computa Science, Keio University, 1989
Automatic spellin erection n' \fBprompt3\fR
.TP 2
Per Hedeland, Ellemtel, Sweden, 1990-
Various bugfixes, improvements n' manual thugged-out shit
.TP 2
Hans J fo' realz. Albertsson (Sun Sweden)
\fBampm\fR, \fIsettc\fR n' \fItelltc\fR
.TP 2
Mike Bloom
Interrupt handlin fixes
.TP 2
Mike Fine, Digital Weapons Corp
Extended key support
.TP 2
Eric Schnoebelen, Convex, 1990
Convex support, fuckin shitloadz of \fIcsh\fR bug fixes,
save n' restore of directory stack
.TP 2
Ron Flax, Apple, 1990
A/UX 2.0 (re)port
.TP 2
Don Juan Oscarsson, LTH Sweden, 1990
NLS support n' simulated NLS support fo' non NLS cribs, fixes
.TP 2
Johan Widen, SICS Sweden, 1990
\fBshlvl\fR, Mach support, \fIcorrect-line\fR, 8-bit printing
.TP 2
Mack Day, Sanyo Icon, 1990
POSIX termio support, SysV limit fixes
.TP 2
Jaap Vermeulen, Sequent, 1990-91
Vi mode fixes, expand-line, window chizzle fixes, Symmetry port
.TP 2
Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991
\fBautolist\fR beepin options, modified tha history search ta search for
the whole strang from tha beginnin of tha line ta tha cursor.
.TP 2
Scott Krotz, Motorola, 1991
Minix port
.TP 2
Dizzy Dawes, Sydney U fo' realz. Australia, Physics Dept., 1991
SVR4 thang control fixes
.TP 2
Jose Sousa, Interactizzle Systems Corp., 1991
Extended \fIvi\fR fixes n' \fIvi\fR delete command
.TP 2
Marc Horowitz, MIT, 1991
ANSIfication fixes, freshly smoked up exec hashin code, imake fixes, \fIwhere\fR
.TP 2
Bruce Sterlin Woodcock, sterling@netcom.com, 1991-1995
ETA n' Pyramid port, Makefile n' lint fixes, \fBignoreeof\fR=n addition, and
various other portabilitizzle chizzlez n' bug fixes
.TP 2
Jeff Fink, 1992
\fIcomplete-word-fwd\fR n' \fIcomplete-word-back\fR
.TP 2
Harry C. Pulley, 1992
Coherent port
.TP 2
Andy Phillips, Mullard Space Science Lab U.K., 1992
VMS-POSIX port
.TP 2
Beto Appleton, IBM Corp., 1992
Walkin process crew fixes, \fIcsh\fR bug fixes,
POSIX file tests, POSIX SIGHUP
.TP 2
Scott Bolte, Cray Computa Corp., 1992
CSOS port
.TP 2
Kaveh R. Ghazi, Rutgers University, 1992
Tek, m88k, Titan n' Masscomp ports n' fixes.  Added autoconf support.
.TP 2
Mark Linderman, Cornell University, 1992
OS/2 port
.TP 2
Mika Liljeberg, liljeber@kruuna.Helsinki.FI, 1992
Linux port
.TP 2
Slim Tim P. Right back up in yo muthafuckin ass. Starrin, NASA Langley Research Centa Operations, 1993
Read-only variables
.TP 2
Dizzle Schweisguth, Yale University, 1993-4
New playa page n' tcsh.man2html
.TP 2
Larry Schwimmer, Stanford University, 1993
AFS n' HESIOD patches
.TP 2
Luke Mewburn, RMIT University, 1994-6
Enhanced directory printin up in prompt,
added \fBellipsis\fR n' \fBrprompt\fR.
.TP 2
Edward Hutchins, Silicon Graphics Inc., 1996
Added implicit cd.
.TP 2
Martin Kraemer, 1997
Ported ta Siemens Nixdorf EBCDIC machine
.TP 2
Amol Deshpande, Microsoft, 1997
Ported ta WIN32 (Windows/95 n' Windows/NT); freestyled all tha missin library
and message catalog code ta intercourse ta Windows.
.TP 2
Taga Nayuta, 1998
Color ls additions.
.PD
.PP
.SH "THANKS TO"
Bryan Dunlap, Clayton Elwell, Karl Kleinpaste, Bob Manson, Steve Romig,
Diana Smetters, Bob Sutterfield, Mark Verber, Elizabeth Zwicky n' all
the other playas at Ohio State fo' suggestions n' encouragement
.PP
All tha playas on tha net, fo' puttin up with,
reportin bugs in, n' suggestin freshly smoked up additions ta each n' every last muthafuckin version
.PP
Slick Rick M fo' realz. Alderson Pt III, fo' freestylin tha `T up in tcsh' section
