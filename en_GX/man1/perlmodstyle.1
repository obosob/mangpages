.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLMODSTYLE 1"
.TH PERLMODSTYLE 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlmodstyle \- Perl module steez guide
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This document attempts ta describe tha Perl Communityz \*(L"best practice\*(R"
for freestylin Perl modules.  It extendz tha recommendations found up in 
perlstyle , which should be considered required reading
before readin dis document.
.PP
While dis document is intended ta be useful ta all module authors, it is
particularly aimed at authors whoz ass wish ta publish they modulez on \s-1CPAN.\s0
.PP
Da focus is on elementz of steez which is visible ta tha playaz of a 
module, rather than dem parts which is only peeped by tha modulez 
developers.  But fuck dat shiznit yo, tha word on tha street is dat nuff of tha guidelines presented up in dis document
can be extrapolated n' applied successfully ta a modulez internals.
.PP
This document differs from perlnewmod up in dat it aint nuthin but a steez guide
rather than a tutorial on bustin \s-1CPAN\s0 modules.  It serves up a
checklist against which modulez can be compared ta determine whether
they conform ta dopest practice, without necessarily describin up in detail
how ta big up all dis bullshit.
.PP
All tha lyrics contained up in dis document has been gleaned from
extensive rap battlez wit experienced \s-1CPAN\s0 authors n' users.  Every
piece of lyrics given here is tha result of previous mistakes.  This
information is here ta help you avoid tha same mistakes n' tha extra
work dat would inevitably be required ta fix em.
.PP
Da first section of dis document serves up a itemized checklist; 
subsequent sections provide a mo' detailed rap of tha shit on 
the list.  Da final section, \*(L"Common Pitfalls\*(R", raps on some shitload of tha 
most ghettofab mistakes made by \s-1CPAN\s0 authors.
.SH "QUICK CHECKLIST"
.IX Header "QUICK CHECKLIST"
For mo' detail on each item up in dis checklist, peep below.
.SS "Before you start"
.IX Subsection "Before you start"
.IP "\(bu" 4
Don't re-invent tha wheel
.IP "\(bu" 4
Patch, extend or subclass a existin module where possible
.IP "\(bu" 4
Do one thang n' do it well
.IP "\(bu" 4
Choose a appropriate name
.SS "Da \s-1API\s0"
.IX Subsection "Da API"
.IP "\(bu" 4
\&\s-1API\s0 should be understandable by tha average programmer
.IP "\(bu" 4
Simple methodz fo' simple tasks
.IP "\(bu" 4
Separate functionalitizzle from output
.IP "\(bu" 4
Consistent namin of subroutines or methods
.IP "\(bu" 4
Use named parametas (a hash or hashref) when there be mo' than two
parameters
.SS "Stability"
.IX Subsection "Stability"
.IP "\(bu" 4
Ensure yo' module works under \f(CW\*(C`use strict\*(C'\fR n' \f(CW\*(C`\-w\*(C'\fR
.IP "\(bu" 4
Stable modulez should maintain backwardz compatibility
.SS "Documentation"
.IX Subsection "Documentation"
.IP "\(bu" 4
Write documentation up in \s-1POD\s0
.IP "\(bu" 4
Document purpose, scope n' target applications
.IP "\(bu" 4
Document each publically accessible method or subroutine, includin params n' return joints
.IP "\(bu" 4
Give examplez of use up in yo' documentation
.IP "\(bu" 4
Provide a \s-1README\s0 file n' like also release notes, chizzlelog, etc
.IP "\(bu" 4
Provide links ta further shiznit (\s-1URL,\s0 email)
.SS "Release considerations"
.IX Subsection "Release considerations"
.IP "\(bu" 4
Specify pre-requisites up in Makefile.PL or Build.PL
.IP "\(bu" 4
Specify Perl version requirements wit \f(CW\*(C`use\*(C'\fR
.IP "\(bu" 4
Include tests wit yo' module
.IP "\(bu" 4
Choose a sensible n' consistent version numberin scheme (X.YY is tha common Perl module numberin scheme)
.IP "\(bu" 4
Increment tha version number fo' every last muthafuckin chizzle, no matta how tha fuck small
.IP "\(bu" 4
Package tha module rockin \*(L"make dist\*(R"
.IP "\(bu" 4
Choose a appropriate license (GPL/Artistic be a phat default)
.SH "BEFORE YOU START WRITING A MODULE"
.IX Header "BEFORE YOU START WRITING A MODULE"
Try not ta launch headlong tha fuck into pimpin yo' module without spending
some time thankin first.  A lil forethought may save you a vast
amount of effort lata on.
.SS "Has it been done before?"
.IX Subsection "Has it been done before?"
Yo ass may not even need ta write tha module.  Peep whether itz already 
been done up in Perl, n' avoid re-inventin tha wheel unless you gotz a 
phat reason.
.PP
Dope places ta look fo' pre-existin modulez include
http://search.cpan.org/ n' askin on modules@perl.org
.PP
If a existin module \fBalmost\fR do what tha fuck you want, consider freestylin a
patch, freestylin a subclass, or otherwise extendin tha existin module
rather than rewritin dat shit.
.SS "Do one thang n' do it well"
.IX Subsection "Do one thang n' do it well"
At tha risk of statin tha obvious, modulez is intended ta be modular.
A Perl pimper should be able ta use modulez ta put together the
buildin blockz of they application. I aint talkin' bout chicken n' gravy biatch.  But fuck dat shiznit yo, tha word on tha street is dat itz blingin dat the
blocks is tha right shape, n' dat tha pimper shouldn't gotta use
a big-ass block when all they need be a lil' small-ass one.
.PP
Yo crazy-ass module should gotz a cold-ass lil clearly defined scope which is no longer than
a single sentence.  Can yo' module be fucked up down tha fuck into a cold-ass lil crew of
related modules?
.PP
Wack example:
.PP
\&\*(L"FooBar.pm serves up a implementation of tha \s-1FOO\s0 protocol n' the
related \s-1BAR\s0 standard.\*(R"
.PP
Dope example:
.PP
\&\*(L"Foo.pm serves up a implementation of tha \s-1FOO\s0 protocol.  Bar.pm
implements tha related \s-1BAR\s0 protocol.\*(R"
.PP
This means dat if a thugged-out pimper only needz a module fo' tha \s-1BAR\s0 standard,
they should not be forced ta install libraries fo' \s-1FOO\s0 as well.
.SS "Whatz up in a name?"
.IX Subsection "Whatz up in a name?"
Make shizzle you chizzle a appropriate name fo' yo' module early on. I aint talkin' bout chicken n' gravy biatch.  This
will help playas find n' remember yo' module, n' make programming
with yo' module mo' intuitive.
.PP
When namin yo' module, consider tha following:
.IP "\(bu" 4
Be descriptizzle (i.e. accurately raps bout tha purpose of tha module).
.IP "\(bu" 4
Be consistent wit existin modules.
.IP "\(bu" 4
Reflect tha functionalitizzle of tha module, not tha implementation.
.IP "\(bu" 4
Avoid startin a freshly smoked up top-level hierarchy, especially if a suitable
hierarchy already exists under which you could place yo' module.
.PP
Yo ass should contact modules@perl.org ta ask dem bout yo' module name
before publishin yo' module.  Yo ass should also try ta ask playas whoz ass 
are already familiar wit tha modulez application domain n' tha \s-1CPAN\s0
namin system.  Authorz of similar modules, or modulez wit similar
names, may be a phat place ta start.
.SH "DESIGNING AND WRITING YOUR MODULE"
.IX Header "DESIGNING AND WRITING YOUR MODULE"
Considerations fo' module design n' coding:
.SS "To \s-1OO\s0 or not ta \s-1OO\s0?"
.IX Subsection "To OO or not ta OO?"
Yo crazy-ass module may be object oriented (\s-1OO\s0) or not, or it may have both kindz 
of intercourses available.  There is pros n' conz of each technique, which 
should be considered when you design yo' \s-1API.\s0
.PP
In \fIPerl Best Practices\fR (copyright 2004, Published by O'Reilly Media, Inc.),
Damian Conway serves up a list of criteria ta use when decidin if \s-1OO\s0 is the
right fit fo' yo' problem:
.IP "\(bu" 4
Da system bein designed is large, or is likely ta become large.
.IP "\(bu" 4
Da data can be aggregated tha fuck into obvious structures, especially if
therez a big-ass amount of data up in each aggregate.
.IP "\(bu" 4
Da various typez of data aggregate form a natural hierarchy that
facilitates tha use of inheritizzle n' polymorphism.
.IP "\(bu" 4
Yo ass gotz a piece of data on which nuff different operations are
applied.
.IP "\(bu" 4
Yo ass need ta big-ass up tha same general operations on related types of
data yo, but wit slight variations dependin on tha specific type of data
the operations is applied to.
.IP "\(bu" 4
It aint nuthin but likely you gonna gotta add freshly smoked up data types later.
.IP "\(bu" 4
Da typical interactions between piecez of data is dopest represented by
operators.
.IP "\(bu" 4
Da implementation of individual componentz of tha system is likely to
change over time.
.IP "\(bu" 4
Da system design be already object-oriented.
.IP "\(bu" 4
Big-Ass numberz of other programmers is ghon be rockin yo' code modules.
.PP
Think carefully bout whether \s-1OO\s0 be appropriate fo' yo' module.
Gratuitous object orientation thangs up in dis biatch up in complex APIs which are
hard as fuck fo' tha average module user ta KNOW or use.
.SS "Designin yo' \s-1API\s0"
.IX Subsection "Designin yo' API"
Yo crazy-ass intercourses should be understandable by a average Perl programmer n' shit.  
Da followin guidelines may help you judge whether yo' \s-1API\s0 is
sufficiently straightforward:
.IP "Write simple routines ta do simple thangs." 4
.IX Item "Write simple routines ta do simple thangs."
It aint nuthin but betta ta gotz a shitload of simple routines than all dem monolithic ones.
If yo' routine chizzlez its behaviour hella based on its
arguments, itz a sign dat you should have two (or more) separate
routines.
.IP "Separate functionalitizzle from output." 4
.IX Item "Separate functionalitizzle from output."
Return yo' thangs up in dis biatch up in da most thugged-out generic form possible n' allow tha user 
to chizzle how tha fuck ta use em.  Da most generic form possible is probably a
Perl data structure which can then be used ta generate a text report,
\&\s-1HTML, XML,\s0 a thugged-out database query, or whatever else yo' playas require.
.Sp
If yo' routine iterates all up in some kind of list (like fuckin a list of
files, or recordz up in a thugged-out database) you may consider providin a cold-ass lil callback
so dat playas can manipulate each element of tha list up in turn.
File::Find serves up a example of dis wit its 
\&\f(CW\*(C`find(\e&wanted, $dir)\*(C'\fR syntax.
.IP "Provide sensible shortcuts n' defaults." 4
.IX Item "Provide sensible shortcuts n' defaults."
Don't require every last muthafuckin module user ta jump all up in tha same hoops ta big up a
simple result.  Yo ass can always include optionizzle parametas or routines fo' 
more complex or non-standard behaviour. Shiiit, dis aint no joke.  If most of yo' playas have to
type all dem almost identical linez of code when they start rockin your
module, itz a sign dat you should have made dat behaviour a thugged-out default.
Another phat indicator dat you should use defaults is if most of yo' 
users call yo' routines wit tha same arguments.
.IP "Namin conventions" 4
.IX Item "Namin conventions"
Yo crazy-ass namin should be consistent.  For instance, itz betta ta have:
.Sp
.Vb 3
\&        display_day();
\&        display_week();
\&        display_year();
.Ve
.Sp
than
.Sp
.Vb 3
\&        display_day();
\&        week_display();
\&        show_year();
.Ve
.Sp
This applies equally ta method names, parameta names, n' anythang else
which is visible ta tha user (and most thangs dat aren't!)
.IP "Parameta passing" 4
.IX Item "Parameta passing"
Use named parameters. It aint nuthin but easier ta bust a hash like this:
.Sp
.Vb 5
\&    $obj\->do_something(
\&            name => "wibble",
\&            type => "text",
\&            size => 1024,
\&    );
.Ve
.Sp
\&... than ta git a long-ass list of unnamed parametas like this:
.Sp
.Vb 1
\&    $obj\->do_something("wibble", "text", 1024);
.Ve
.Sp
While tha list of arguments might work fine fo' one, two or even three
arguments, any mo' arguments become hard fo' tha module user to
remember, n' hard fo' tha module lyricist ta manage.  If you wanna add
a freshly smoked up parameta yo big-ass booty is ghon gotta add it ta tha end of tha list for
backward compatibility, n' dis will probably make yo' list order
unintuitive.  Also, if nuff elements may be undefined you may peep the
followin unattractizzle method calls:
.Sp
.Vb 1
\&    $obj\->do_something(undef, undef, undef, undef, undef, undef, 1024);
.Ve
.Sp
Provide sensible defaults fo' parametas which have em.  Don't make
your playas specify parametas which will almost always be tha same.
.Sp
Da issue of whether ta pass tha arguments up in a hash or a hashref is
largely a matta of underground style.
.Sp
Da use of hash keys startin wit a hyphen (\f(CW\*(C`\-name\*(C'\fR) or entirely up in 
upper case (\f(CW\*(C`NAME\*(C'\fR) be a relic of olda versionz of Perl up in which
ordinary lower case strings was not handled erectly by tha \f(CW\*(C`=>\*(C'\fR
operator. Shiiit, dis aint no joke.  While some modulez retain uppercase or hyphenated argument
keys fo' oldschool reasons or as a matta of underground style, most new
modulez should use simple lower case keys.  Whatever you chizzle, be
consistent!
.SS "Strictnizz n' warnings"
.IX Subsection "Strictnizz n' warnings"
Yo crazy-ass module should run successfully under tha strict pragma n' should
run without generatin any warnings.  Yo crazy-ass module should also handle 
taint-checkin where appropriate, though dis can cause bullshit in
many cases.
.SS "Backwardz compatibility"
.IX Subsection "Backwardz compatibility"
Modulez which is \*(L"stable\*(R" should not break backwardz compatibility
without at least a long-ass transizzle phase n' a major chizzle up in version
number.
.SS "Error handlin n' lyrics"
.IX Subsection "Error handlin n' lyrics"
When yo' module encountas a error it should do one or mo' of:
.IP "\(bu" 4
Return a undefined value.
.IP "\(bu" 4
set \f(CW$Module::errstr\fR or similar (\f(CW\*(C`errstr\*(C'\fR be a cold-ass lil common name used by
\&\s-1DBI\s0 n' other ghettofab modules; if you chizzle suttin' else, be shizzle to
document it clearly).
.IP "\(bu" 4
\&\f(CW\*(C`warn()\*(C'\fR or \f(CW\*(C`carp()\*(C'\fR a message ta \s-1STDERR.  \s0
.IP "\(bu" 4
\&\f(CW\*(C`croak()\*(C'\fR only when yo' module straight-up cannot figure up what tha fuck to
do.  (\f(CW\*(C`croak()\*(C'\fR be a funky-ass betta version of \f(CW\*(C`die()\*(C'\fR fo' use within 
modules, which reports its errors from tha perspectizzle of tha calla n' shit.  
See Carp fo' detailz of \f(CW\*(C`croak()\*(C'\fR, \f(CW\*(C`carp()\*(C'\fR n' other useful
routines.)
.IP "\(bu" 4
As a alternatizzle ta tha above, you may prefer ta throw exceptions rockin 
the Error module.
.PP
Configurable error handlin can be straight-up useful ta yo' users.  Consider
offerin a cold-ass lil chizzle of levels fo' warnin n' debug lyrics, a option to
send lyrics ta a separate file, a way ta specify a error-handling
routine, or other such features.  Be shizzle ta default all these options
to tha commonest use.
.SH "DOCUMENTING YOUR MODULE"
.IX Header "DOCUMENTING YOUR MODULE"
.SS "\s-1POD\s0"
.IX Subsection "POD"
Yo crazy-ass module should include documentation aimed at Perl pimpers.
Yo ass should use Perlz \*(L"plain oldschool documentation\*(R" (\s-1POD\s0) fo' yo' general 
technical documentation, though you may wish ta write additional
documentation (white papers, tutorials, etc) up in some other format.  
Yo ass need ta cover tha followin subjects:
.IP "\(bu" 4
A synopsiz of tha common usez of tha module
.IP "\(bu" 4
Da purpose, scope n' target applicationz of yo' module
.IP "\(bu" 4
Use of each publically accessible method or subroutine, including
parametas n' return joints
.IP "\(bu" 4
Examplez of use
.IP "\(bu" 4
Sourcez of further shiznit
.IP "\(bu" 4
A contact email address fo' tha author/maintainer
.PP
Da level of detail up in Perl module documentation generally goes from
less detailed ta mo' detailed. Y'all KNOW dat shit, muthafucka!  Yo crazy-ass \s-1SYNOPSIS\s0 section should contain a
minimal example of use (like as lil as one line of code; skip the
unusual use cases or anythang not needed by most users); the
\&\s-1DESCRIPTION\s0 should describe yo' module up in broad terms, generally in
just all dem paragraphs; mo' detail of tha modulez routines or methods,
lengthy code examples, or other in-depth material should be given up in 
subsequent sections.
.PP
Ideally, one of mah thugs whoz slightly familiar wit yo' module should be able
to refresh they memory without hittin \*(L"page down\*(R".  As yo' reader
continues all up in tha document, they should receive a progressively
greata amount of knowledge.
.PP
Da recommended order of sections up in Perl module documentation is:
.IP "\(bu" 4
\&\s-1NAME\s0
.IP "\(bu" 4
\&\s-1SYNOPSIS\s0
.IP "\(bu" 4
\&\s-1DESCRIPTION\s0
.IP "\(bu" 4
One or mo' sections or subsections givin pimped outa detail of available 
methodz n' routines n' any other relevant shiznit.
.IP "\(bu" 4
BUGS/CAVEATS/etc
.IP "\(bu" 4
\&\s-1AUTHOR\s0
.IP "\(bu" 4
\&\s-1SEE ALSO\s0
.IP "\(bu" 4
\&\s-1COPYRIGHT\s0 n' \s-1LICENSE\s0
.PP
Keep yo' documentation near tha code it documents (\*(L"inline\*(R"
documentation).  Include \s-1POD\s0 fo' a given method right above dat 
methodz subroutine.  This make it easier ta keep tha documentation up
to date, n' avoidz havin ta document each piece of code twice (once in
\&\s-1POD\s0 n' once up in comments).
.SS "\s-1README, INSTALL,\s0 release notes, chizzlelogs"
.IX Subsection "README, INSTALL, release notes, chizzlelogs"
Yo crazy-ass module should also include a \s-1README\s0 file describin tha module and
givin pointas ta further shiznit (website, lyricist email).
.PP
An \s-1INSTALL\s0 file should be included, n' should contain simple installation 
instructions. When rockin ExtUtils::MakeMaker dis will probably be:
.IP "perl Makefile.PL" 4
.IX Item "perl Makefile.PL"
.PD 0
.IP "make" 4
.IX Item "make"
.IP "make test" 4
.IX Item "make test"
.IP "make install" 4
.IX Item "make install"
.PD
.PP
When rockin Module::Build, dis will probably be:
.IP "perl Build.PL" 4
.IX Item "perl Build.PL"
.PD 0
.IP "perl Build" 4
.IX Item "perl Build"
.IP "perl Build test" 4
.IX Item "perl Build test"
.IP "perl Build install" 4
.IX Item "perl Build install"
.PD
.PP
Release notes or chizzlelogs should be produced fo' each release of your
software describin user-visible chizzlez ta yo' module, up in terms
relevant ta tha user.
.SH "RELEASE CONSIDERATIONS"
.IX Header "RELEASE CONSIDERATIONS"
.SS "Version numbering"
.IX Subsection "Version numbering"
Version numbers should indicate at least major n' minor releases, and
possibly sub-minor releases.  A major release is one up in which most of
the functionalitizzle has chizzled, or up in which major freshly smoked up functionalitizzle is
added. Y'all KNOW dat shit, muthafucka!  A minor release is one up in which a lil' small-ass amount of functionality
has been added or chizzled. Y'all KNOW dat shit, muthafucka!  Sub-minor version numbers is probably used
for chizzlez which do not affect functionality, like fuckin documentation
patches.
.PP
Da most common \s-1CPAN\s0 version numberin scheme be lookin like this:
.PP
.Vb 1
\&    1.00, 1.10, 1.11, 1.20, 1.30, 1.31, 1.32
.Ve
.PP
A erect \s-1CPAN\s0 version number be a gangbangin' floatin point number wit at least 
2 digits afta tha decimal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass can test whether it conforms ta \s-1CPAN\s0 by 
using
.PP
.Vb 1
\&    perl \-MExtUtils::MakeMaker \-le \*(Aqprint MM\->parse_version(shift)\*(Aq \*(AqFoo.pm\*(Aq
.Ve
.PP
If you wanna release a 'beta' or 'alpha' version of a module but
don't want \s-1CPAN\s0.pm ta list it as most recent use a '_' afta the
regular version number followed by at least 2 digits, eg. 1.20_01. If
you do this, tha followin idiom is recommended:
.PP
.Vb 3
\&  $VERSION = "1.12_01";
\&  $XS_VERSION = $VERSION; # only needed if you have XS code
\&  $VERSION = eval $VERSION;
.Ve
.PP
With dat trick MakeMaker will only read tha straight-up original gangsta line n' thus read
the underscore, while tha perl interpreta will evaluate tha \f(CW$VERSION\fR
and convert tha strang tha fuck into a number n' shit. Lata operations dat treat
\&\f(CW$VERSION\fR as a number will then be able ta do so without provokin a
warnin bout \f(CW$VERSION\fR not bein a number.
.PP
Never release anythang (even a one-word documentation patch) without
incrementin tha number n' shit.  Even a one-word documentation patch should
result up in a cold-ass lil chizzle up in version all up in tha sub-minor level.
.SS "Pre-requisites"
.IX Subsection "Pre-requisites"
Module authors should carefully consider whether ta rely on other
modules, n' which modulez ta rely on.
.PP
Most blinginly, chizzle modulez which is as stable as possible.  In
order of preference:
.IP "\(bu" 4
Core Perl modules
.IP "\(bu" 4
Stable \s-1CPAN\s0 modules
.IP "\(bu" 4
Unstable \s-1CPAN\s0 modules
.IP "\(bu" 4
Modulez not available from \s-1CPAN\s0
.PP
Specify version requirements fo' other Perl modulez up in the
pre-requisites up in yo' Makefile.PL or Build.PL.
.PP
Be shizzle ta specify Perl version requirements both up in Makefile.PL or
Build.PL n' wit \f(CW\*(C`require 5.6.1\*(C'\fR or similar. Shiiit, dis aint no joke. Right back up in yo muthafuckin ass. See tha section on
\&\f(CW\*(C`use VERSION\*(C'\fR of \*(L"require\*(R" up in perlfunc fo' details.
.SS "Testing"
.IX Subsection "Testing"
All modulez should be tested before distribution (usin \*(L"make disttest\*(R"),
and tha tests should also be available ta playas installin tha modulez 
(usin \*(L"make test\*(R").  
For Module::Build you would use tha \f(CW\*(C`make test\*(C'\fR equivalent \f(CW\*(C`perl Build test\*(C'\fR.
.PP
Da importizzle of these tests is proportionizzle ta tha alleged stabilitizzle of a 
module fo' realz. A module which purports ta be stable or which hopes ta big up wide 
use should adhere ta as strict a testin regime as possible.
.PP
Useful modulez ta help you write tests (with minimum impact on yo' 
development process or yo' time) include Test::Simple, Carp::Assert 
and Test::Inline.
For mo' sophisticated test suites there be Test::Mo' n' Test::MockObject.
.SS "Packaging"
.IX Subsection "Packaging"
Modulez should be packaged rockin one of tha standard packagin tools.
Currently you have tha chizzle between ExtUtils::MakeMaker n' the
more platform independent Module::Build, allowin modulez ta be installed up in a
consistent manner.
When rockin ExtUtils::MakeMaker, you can use \*(L"make dist\*(R" ta create your
package. Tools exist ta help you ta build yo' module up in a MakeMaker-friendly
style. These include ExtUtils::ModuleMaker n' h2xs.  See also perlnewmod.
.SS "Licensing"
.IX Subsection "Licensing"
Make shizzle dat yo' module has a license, n' dat tha full text of it
is included up in tha distribution (unless itz a cold-ass lil common one n' tha terms
of tha license don't require you ta include it).
.PP
If you don't give a fuck what tha fuck license ta use, dual licensin under tha \s-1GPL\s0
and Artistic licenses (the same as Perl itself) be a phat idea.
See perlgpl n' perlartistic.
.SH "COMMON PITFALLS"
.IX Header "COMMON PITFALLS"
.SS "Reinventin tha wheel"
.IX Subsection "Reinventin tha wheel"
There is certain application spaces which is already hella, straight-up well
served by \s-1CPAN. \s0 One example is templatin systems, another is date and
time modules, n' there be nuff mo' n' mo' n' mo'.  While it aint nuthin but a rite of passage to
write yo' own version of these thangs, please consider carefully
whether tha Perl ghetto straight-up needz you ta publish dat shit.
.SS "Tryin ta do too much"
.IX Subsection "Tryin ta do too much"
Yo crazy-ass module is ghon be part of a thugged-out pimperz toolkit.  It will not, in
itself, form tha \fBentire\fR toolkit.  It aint nuthin but temptin ta add extra features
until yo' code be a monolithic system rather than a set of modular
buildin blocks.
.SS "Inappropriate documentation"
.IX Subsection "Inappropriate documentation"
Don't fall tha fuck into tha trap of freestylin fo' tha wack crew.  Your
primary crew be a reasonably experienced pimper wit at least 
a moderate understandin of yo' modulez application domain, whoz just 
downloaded yo' module n' wants ta start rockin it as quickly as possible.
.PP
Tutorials, end-user documentation, research papers, FAQUIZZYs etc is not 
appropriate up in a modulez main documentation. I aint talkin' bout chicken n' gravy biatch.  If you straight-up wanna 
write these, include dem as sub-documents like fuckin \f(CW\*(C`My::Module::Tutorial\*(C'\fR or
\&\f(CW\*(C`My::Module::FAQ\*(C'\fR n' provide a link up in tha \s-1SEE ALSO\s0 section of the
main documentation.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "perlstyle" 4
.IX Item "perlstyle"
General Perl steez guide
.IP "perlnewmod" 4
.IX Item "perlnewmod"
How tha fuck ta create a freshly smoked up module
.IP "perlpod" 4
.IX Item "perlpod"
\&\s-1POD\s0 documentation
.IP "podchecker" 4
.IX Item "podchecker"
Verifies yo' \s-1POD\s0z erectness
.IP "Packagin Tools" 4
.IX Item "Packagin Tools"
ExtUtils::MakeMaker, Module::Build
.IP "Testin tools" 4
.IX Item "Testin tools"
Test::Simple, Test::Inline, Carp::Assert, Test::Mo', Test::MockObject
.IP "http://pause.perl.org/" 4
.IX Item "http://pause.perl.org/"
Perl Authors Upload Server n' shit.  Gotz Nuff links ta shiznit fo' module
authors.
.IP "Any phat book on software engineering" 4
.IX Item "Any phat book on software engineering"
.SH "AUTHOR"
.IX Header "AUTHOR"
Kirrily \*(L"Skud\*(R" Robert <skud@cpan.org>
