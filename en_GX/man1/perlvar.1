.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLVAR 1"
.TH PERLVAR 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlvar \- Perl predefined variables
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Da Syntax of Variable Names"
.IX Subsection "Da Syntax of Variable Names"
Variable names up in Perl can have nuff muthafuckin formats, n' you can put dat on yo' toast.  Usually, they
must begin wit a letta or underscore, up in which case they can be
arbitrarily long (up ta a internal limit of 251 characters) and
may contain letters, digits, underscores, or tha special sequence
\&\f(CW\*(C`::\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR.  In dis case, tha part before tha last \f(CW\*(C`::\*(C'\fR or
\&\f(CW\*(C`\*(Aq\*(C'\fR is taken ta be a \fIpackage qualifier\fR; peep perlmod.
.PP
Perl variable names may also be a sequence of digits or a single
punctuation or control character n' shit.  These names is all reserved for
special uses by Perl; fo' example, tha all-digits names is used
to hold data captured by backreferences afta a regular expression
match.  Perl has a special syntax fo' tha single-control-character
names: It understandz \f(CW\*(C`^X\*(C'\fR (caret \f(CW\*(C`X\*(C'\fR) ta mean tha control\-\f(CW\*(C`X\*(C'\fR
character n' shit.  For example, tha notation \f(CW$^W\fR (dollar-sign caret
\&\f(CW\*(C`W\*(C'\fR) is tha scalar variable whose name is tha single character
control\-\f(CW\*(C`W\*(C'\fR.  This is betta than typin a literal control\-\f(CW\*(C`W\*(C'\fR
into yo' program.
.PP
Since Perl v5.6.0, Perl variable names may be alphanumeric
strings dat begin wit control charactas (or betta yet, a cold-ass lil caret).
These variablez must be freestyled up in tha form \f(CW\*(C`${^Foo}\*(C'\fR; tha braces
are not optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  \f(CW\*(C`${^Foo}\*(C'\fR denotes tha scalar variable whose
name be a cold-ass lil control\-\f(CW\*(C`F\*(C'\fR followed by two \f(CW\*(C`o\*(C'\fR's.  These variablez are
reserved fo' future special uses by Perl, except fo' tha ones that
begin wit \f(CW\*(C`^_\*(C'\fR (control-underscore or caret-underscore).  No
control-characta name dat begins wit \f(CW\*(C`^_\*(C'\fR will acquire a special
meanin up in any future version of Perl; such names may therefore be
used safely up in programs.  \f(CW$^_\fR itself, however, \fIis\fR reserved.
.PP
Perl identifiers dat begin wit digits, control characters, or
punctuation charactas is exempt from tha effectz of tha \f(CW\*(C`package\*(C'\fR
declaration n' is always forced ta be up in package \f(CW\*(C`main\*(C'\fR; they are
also exempt from \f(CW\*(C`strict \*(Aqvars\*(Aq\*(C'\fR errors.  A few other names is also
exempt up in these ways:
.PP
.Vb 5
\&    ENV      STDIN
\&    INC      STDOUT
\&    ARGV     STDERR
\&    ARGVOUT
\&    SIG
.Ve
.PP
In particular, tha special \f(CW\*(C`${^_XYZ}\*(C'\fR variablez is always taken
to be up in package \f(CW\*(C`main\*(C'\fR, regardless of any \f(CW\*(C`package\*(C'\fR declarations
presently up in scope.
.SH "SPECIAL VARIABLES"
.IX Header "SPECIAL VARIABLES"
Da followin names have special meanin ta Perl.  Most punctuation
names have reasonable mnemonics, or analogs up in tha shells.
Nevertheless, if you wish ta use long variable names, you need only say:
.PP
.Vb 1
\&    use Gangsta;
.Ve
.PP
at tha top of yo' program.  This aliases all tha short names ta tha long
names up in tha current package.  Some even have medium names, generally
borrowed from \fBawk\fR.  To avoid a performizzle hit, if you don't need the
\&\f(CW$PREMATCH\fR, \f(CW$MATCH\fR, or \f(CW$POSTMATCH\fR itz dopest ta use tha \f(CW\*(C`English\*(C'\fR
module without them:
.PP
.Vb 1
\&    use Gangsta \*(Aq\-no_match_vars\*(Aq;
.Ve
.PP
Before you continue, note tha sort order fo' variables.  In general, we
first list tha variablez up in case-insensitive, almost-lexigraphical
order (ignorin tha \f(CW\*(C`{\*(C'\fR or \f(CW\*(C`^\*(C'\fR precedin lyrics, as up in \f(CW\*(C`${^UNICODE}\*(C'\fR
or \f(CW$^T\fR), although \f(CW$_\fR n' \f(CW@_\fR move up ta tha top of tha pile.
For variablez wit tha same identifier, our slick asses list it up in order of scalar,
array, hash, n' bareword.
.SS "General Variables"
.IX Subsection "General Variables"
.ie n .IP "$ARG" 8
.el .IP "\f(CW$ARG\fR" 8
.IX Item "$ARG"
.PD 0
.ie n .IP "$_" 8
.el .IP "\f(CW$_\fR" 8
.IX Xref "$_ $ARG"
.IX Item "$_"
.PD
Da default input n' pattern-searchin space.  Da followin pairs are
equivalent:
.Sp
.Vb 2
\&    while (<>) {...}    # equivalent only up in while!
\&    while (defined($_ = <>)) {...}
\&
\&    /^Subject:/
\&    $_ =~ /^Subject:/
\&
\&    tr/a\-z/A\-Z/
\&    $_ =~ tr/a\-z/A\-Z/
\&
\&    chomp
\&    chomp($_)
.Ve
.Sp
Here is tha places where Perl will assume \f(CW$_\fR even if you don't use it:
.RS 8
.IP "\(bu" 3
Da followin functions use \f(CW$_\fR as a thugged-out default argument:
.Sp
abs, alarm, chomp, chop, chr, chroot,
cos, defined, eval, evalbytes, exp, fc, glob, hex, int, lc,
lcfirst, length, log, lstat, mkdir, oct, ord, pos, print, printf,
quotemeta, readlink, readpipe, ref, require, reverse (in scalar context only),
rmdir, say, sin, split (for its second
argument), sqrt, stat, study, uc, ucfirst,
unlink, unpack.
.IP "\(bu" 3
All file tests (\f(CW\*(C`\-f\*(C'\fR, \f(CW\*(C`\-d\*(C'\fR) except fo' \f(CW\*(C`\-t\*(C'\fR, which defaults ta \s-1STDIN.\s0
See \*(L"\-X\*(R" up in perlfunc
.IP "\(bu" 3
Da pattern matchin operations \f(CW\*(C`m//\*(C'\fR, \f(CW\*(C`s///\*(C'\fR n' \f(CW\*(C`tr///\*(C'\fR (aka \f(CW\*(C`y///\*(C'\fR)
when used without a \f(CW\*(C`=~\*(C'\fR operator.
.IP "\(bu" 3
Da default iterator variable up in a \f(CW\*(C`foreach\*(C'\fR loop if no other
variable is supplied.
.IP "\(bu" 3
Da implicit iterator variable up in tha \f(CW\*(C`grep()\*(C'\fR n' \f(CW\*(C`map()\*(C'\fR functions.
.IP "\(bu" 3
Da implicit variable of \f(CW\*(C`given()\*(C'\fR.
.IP "\(bu" 3
Da default place ta put tha next value or input record
when a \f(CW\*(C`<FH>\*(C'\fR, \f(CW\*(C`readline\*(C'\fR, \f(CW\*(C`readdir\*(C'\fR or \f(CW\*(C`each\*(C'\fR
operationz result is tested by itself as tha sole criterion of a \f(CW\*(C`while\*(C'\fR
test.  Outside a \f(CW\*(C`while\*(C'\fR test, dis aint gonna happen.
.RE
.RS 8
.Sp
\&\f(CW$_\fR is by default a global variable.  But fuck dat shiznit yo, tha word on tha street is dat as
of perl v5.10.0, you can bust a lexical version of
\&\f(CW$_\fR by declarin it up in a gangbangin' file or up in a funky-ass block wit \f(CW\*(C`my\*(C'\fR.  Mo'over,
declarin \f(CW\*(C`our $_\*(C'\fR restores tha global \f(CW$_\fR up in tha current scope.  Though
this seemed like a phat scam all up in tha time dat shiznit was introduced, lexical \f(CW$_\fR
actually causes mo' problems than it solves.  If you call a gangbangin' function that
expects ta be passed shiznit via \f(CW$_\fR, it may or may not work,
dependin on how tha fuck tha function is written, there not bein any easy as fuck  way to
solve all dis bullshit.  Just avoid lexical \f(CW$_\fR, unless yo ass is feelin particularly
masochistic.  For dis reason lexical \f(CW$_\fR is still experimenstrual n' will
produce a warnin unless warnings done been disabled. Y'all KNOW dat shit, muthafucka!  As wit other
experimenstrual features, tha behavior of lexical \f(CW$_\fR is subject ta chizzle
without notice, includin chizzle tha fuck into a gangbangin' fatal error.
.Sp
Mnemonic: underline is understood up in certain operations.
.RE
.ie n .IP "@ARG" 8
.el .IP "\f(CW@ARG\fR" 8
.IX Item "@ARG"
.PD 0
.ie n .IP "@_" 8
.el .IP "\f(CW@_\fR" 8
.IX Xref "@_ @ARG"
.IX Item "@_"
.PD
Within a subroutine tha array \f(CW@_\fR gotz nuff tha parametas passed to
that subroutine.  Inside a subroutine, \f(CW@_\fR is tha default array for
the array operators \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, n' \f(CW\*(C`unshift\*(C'\fR.
.Sp
See perlsub.
.ie n .IP "$LIST_SEPARATOR" 8
.el .IP "\f(CW$LIST_SEPARATOR\fR" 8
.IX Item "$LIST_SEPARATOR"
.PD 0
.IP "$""" 8
.IX Xref "$"" $LIST_SEPARATOR"
.PD
When a array or a array slice is interpolated tha fuck into a thugged-out double-quoted
strin or a similar context like fuckin \f(CW\*(C`/.../\*(C'\fR, its elements are
separated by dis value.  Default be a space.  For example, this:
.Sp
.Vb 1
\&    print "Da array is: @array\en";
.Ve
.Sp
is equivalent ta this:
.Sp
.Vb 1
\&    print "Da array is: " . join($", @array) . "\en";
.Ve
.Sp
Mnemonic: works up in double-quoted context.
.ie n .IP "$PROCESS_ID" 8
.el .IP "\f(CW$PROCESS_ID\fR" 8
.IX Item "$PROCESS_ID"
.PD 0
.ie n .IP "$PID" 8
.el .IP "\f(CW$PID\fR" 8
.IX Item "$PID"
.IP "$$" 8
.IX Xref "$$ $PID $PROCESS_ID"
.PD
Da process number of tha Perl hustlin dis script.  Though you \fIcan\fR set
this variable, bustin so is generally discouraged, although it can be
invaluable fo' some testin purposes.  It is ghon be reset automatically
across \f(CW\*(C`fork()\*(C'\fR calls.
.Sp
Note fo' Linux n' Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl
would emulate \s-1POSIX\s0 semantics on Linux systems rockin LinuxThreads, a
partial implementation of \s-1POSIX\s0 Threadz dat has since been superseded
by tha Natizzle \s-1POSIX\s0 Thread Library (\s-1NPTL\s0).
.Sp
LinuxThreadz is now obsolete on Linux, n' cachin \f(CW\*(C`getpid()\*(C'\fR
like dis made embeddin perl unnecessarily complex (since you'd have
to manually update tha value of $$), so now \f(CW$$\fR n' \f(CW\*(C`getppid()\*(C'\fR
will always return tha same joints as tha underlyin C library.
.Sp
Debian GNU/kFreeBSD systems also used LinuxThreadz up until and
includin tha 6.0 release yo, but afta dat moved ta FreeBSD thread
semantics, which is POSIX-like.
.Sp
To peep if yo' system be affected by dis discrepancy check if
\&\f(CW\*(C`getconf GNU_LIBPTHREAD_VERSION | grep \-q NPTL\*(C'\fR returns a gangbangin' false
value. \s-1NTPL\s0 threadz preserve tha \s-1POSIX\s0 semantics.
.Sp
Mnemonic: same as shells.
.ie n .IP "$PROGRAM_NAME" 8
.el .IP "\f(CW$PROGRAM_NAME\fR" 8
.IX Item "$PROGRAM_NAME"
.PD 0
.ie n .IP "$0" 8
.el .IP "\f(CW$0\fR" 8
.IX Xref "$0 $PROGRAM_NAME"
.IX Item "$0"
.PD
Gotz Nuff tha name of tha program bein executed.
.Sp
On some (but not all) operatin systems assignin ta \f(CW$0\fR modifies
the argument area dat tha \f(CW\*(C`ps\*(C'\fR program sees.  On some platforms you
may gotta use special \f(CW\*(C`ps\*(C'\fR options or a gangbangin' finger-lickin' different \f(CW\*(C`ps\*(C'\fR ta peep the
changes.  Modifyin tha \f(CW$0\fR is mo' useful as a way of indicatin the
current program state than it is fo' hidin tha program you is
running.
.Sp
Note dat there be platform-specific limitations on tha maximum
length of \f(CW$0\fR.  In da most thugged-out off tha hook case it may be limited ta the
space occupied by tha original gangsta \f(CW$0\fR.
.Sp
In some platforms there may be arbitrary amount of padding, for
example space characters, afta tha modified name as shown by \f(CW\*(C`ps\*(C'\fR.
In some platforms dis paddin may extend all tha way ta tha original
length of tha argument area, no matta what tha fuck you do (this is tha case
for example wit Linux 2.2).
.Sp
Note fo' \s-1BSD\s0 users: settin \f(CW$0\fR do not straight-up remove \*(L"perl\*(R"
from tha \fIps\fR\|(1) output.  For example, settin \f(CW$0\fR ta \f(CW"foobar"\fR may
result up in \f(CW"perl: foobar (perl)"\fR (whether both tha \f(CW"perl: "\fR prefix
and tha \*(L" (perl)\*(R" suffix is shown dependz on yo' exact \s-1BSD\s0 variant
and version).  This be a operatin system feature, Perl cannot help dat shit.
.Sp
In multithreaded scripts Perl coordinates tha threadz so dat any
thread may modify its copy of tha \f(CW$0\fR n' tha chizzle becomes visible
to \fIps\fR\|(1) (assumin tha operatin system skits along).  Note that
the view of \f(CW$0\fR tha other threadz have aint gonna chizzle since they
have they own copiez of dat shit.
.Sp
If tha program has been given ta perl via tha switches \f(CW\*(C`\-e\*(C'\fR or \f(CW\*(C`\-E\*(C'\fR,
\&\f(CW$0\fR will contain tha strang \f(CW"\-e"\fR.
.Sp
On Linux az of perl v5.14.0 tha legacy process name is ghon be set with
\&\f(CWprctl(2)\fR, up in addizzle ta alterin tha \s-1POSIX\s0 name via \f(CW\*(C`argv[0]\*(C'\fR as
perl has done since version 4.000.  Now system utilitizzles dat read the
legacy process name like fuckin ps, top n' killall will recognize the
name you set when assignin ta \f(CW$0\fR.  Da strang you supply will be
cut off at 16 bytes, dis be a limitation imposed by Linux.
.Sp
Mnemonic: same as \fBsh\fR n' \fBksh\fR.
.ie n .IP "$REAL_GROUP_ID" 8
.el .IP "\f(CW$REAL_GROUP_ID\fR" 8
.IX Item "$REAL_GROUP_ID"
.PD 0
.ie n .IP "$GID" 8
.el .IP "\f(CW$GID\fR" 8
.IX Item "$GID"
.IP "$(" 8
.IX Xref "$( $GID $REAL_GROUP_ID"
.PD
Da real gid of dis process.  If yo ass is on a machine dat supports
membershizzle up in multiple crews simultaneously, gives a space separated
list of crews yo ass is in. I aint talkin' bout chicken n' gravy biatch.  Da first number is tha one returned by
\&\f(CW\*(C`getgid()\*(C'\fR, n' tha subsequent ones by \f(CW\*(C`getgroups()\*(C'\fR, one of which may be
the same as tha straight-up original gangsta number.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat a value assigned ta \f(CW$(\fR must be a single number used to
set tha real gid. Y'all KNOW dat shit, muthafucka!  So tha value given by \f(CW$(\fR should \fInot\fR be assigned
back ta \f(CW$(\fR without bein forced numeric, like fuckin by addin zero.  Note
that dis is different ta tha effectizzle gid (\f(CW$)\fR) which do take a
list.
.Sp
Yo ass can chizzle both tha real gid n' tha effectizzle gid all up in tha same
time by rockin \f(CW\*(C`POSIX::setgid()\*(C'\fR.  Chizzles
to \f(CW$(\fR require a cold-ass lil check ta \f(CW$!\fR
to detect any possible errors afta a attempted chizzle.
.Sp
Mnemonic: parentheses is used ta \fIgroup\fR thangs.  Da real gid is the
group you \fIleft\fR, if you hustlin setgid.
.ie n .IP "$EFFECTIVE_GROUP_ID" 8
.el .IP "\f(CW$EFFECTIVE_GROUP_ID\fR" 8
.IX Item "$EFFECTIVE_GROUP_ID"
.PD 0
.ie n .IP "$EGID" 8
.el .IP "\f(CW$EGID\fR" 8
.IX Item "$EGID"
.IP "$)" 8
.IX Xref "$) $EGID $EFFECTIVE_GROUP_ID"
.PD
Da effectizzle gid of dis process.  If yo ass is on a machine that
supports membershizzle up in multiple crews simultaneously, gives a space
separated list of crews yo ass is in. I aint talkin' bout chicken n' gravy biatch.  Da first number is tha one
returned by \f(CW\*(C`getegid()\*(C'\fR, n' tha subsequent ones by \f(CW\*(C`getgroups()\*(C'\fR,
one of which may be tha same as tha straight-up original gangsta number.
.Sp
Similarly, a value assigned ta \f(CW$)\fR must also be a space-separated
list of numbers.  Da first number sets tha effectizzle gid, and
the rest (if any) is passed ta \f(CW\*(C`setgroups()\*(C'\fR.  To git tha effect of an
empty list fo' \f(CW\*(C`setgroups()\*(C'\fR, just repeat tha freshly smoked up effectizzle gid; dat is,
to force a effectizzle gid of 5 n' a effectively empty \f(CW\*(C`setgroups()\*(C'\fR
list, say \f(CW\*(C` $) = "5 5" \*(C'\fR.
.Sp
Yo ass can chizzle both tha effectizzle gid n' tha real gid all up in tha same
time by rockin \f(CW\*(C`POSIX::setgid()\*(C'\fR (use only a single numeric argument).
Changes ta \f(CW$)\fR require a cold-ass lil check ta \f(CW$!\fR ta detect any possible errors
afta a attempted chizzle.
.Sp
\&\f(CW$<\fR, \f(CW$>\fR, \f(CW$(\fR n' \f(CW$)\fR can be set only on
machines dat support tha correspondin \fIset[re][ug]\fIid()\fI\fR routine.  \f(CW$(\fR
and \f(CW$)\fR can be swapped only on machines supportin \f(CW\*(C`setregid()\*(C'\fR.
.Sp
Mnemonic: parentheses is used ta \fIgroup\fR thangs.  Da effectizzle gid
is tha crew thatz \fIright\fR fo' you, if you hustlin setgid.
.ie n .IP "$REAL_USER_ID" 8
.el .IP "\f(CW$REAL_USER_ID\fR" 8
.IX Item "$REAL_USER_ID"
.PD 0
.ie n .IP "$UID" 8
.el .IP "\f(CW$UID\fR" 8
.IX Item "$UID"
.IP "$<" 8
.IX Xref "$< $UID $REAL_USER_ID"
.PD
Da real uid of dis process.  Yo ass can chizzle both tha real uid n' the
effectizzle uid all up in tha same time by rockin \f(CW\*(C`POSIX::setuid()\*(C'\fR.  Since
changes ta \f(CW$<\fR require a system call, check \f(CW$!\fR afta a cold-ass lil chizzle
attempt ta detect any possible errors.
.Sp
Mnemonic: itz tha uid you came \fIfrom\fR, if you hustlin setuid.
.ie n .IP "$EFFECTIVE_USER_ID" 8
.el .IP "\f(CW$EFFECTIVE_USER_ID\fR" 8
.IX Item "$EFFECTIVE_USER_ID"
.PD 0
.ie n .IP "$EUID" 8
.el .IP "\f(CW$EUID\fR" 8
.IX Item "$EUID"
.IP "$>" 8
.IX Xref "$> $EUID $EFFECTIVE_USER_ID"
.PD
Da effectizzle uid of dis process.  For example:
.Sp
.Vb 2
\&    $< = $>;            # set real ta effectizzle uid
\&    ($<,$>) = ($>,$<);  # swap real n' effectizzle uids
.Ve
.Sp
Yo ass can chizzle both tha effectizzle uid n' tha real uid all up in tha same
time by rockin \f(CW\*(C`POSIX::setuid()\*(C'\fR.  Chizzlez ta \f(CW$>\fR require a cold-ass lil check
to \f(CW$!\fR ta detect any possible errors afta a attempted chizzle.
.Sp
\&\f(CW$<\fR n' \f(CW$>\fR can be swapped only on machines
supportin \f(CW\*(C`setreuid()\*(C'\fR.
.Sp
Mnemonic: itz tha uid you went \fIto\fR, if you hustlin setuid.
.ie n .IP "$SUBSCRIPT_SEPARATOR" 8
.el .IP "\f(CW$SUBSCRIPT_SEPARATOR\fR" 8
.IX Item "$SUBSCRIPT_SEPARATOR"
.PD 0
.ie n .IP "$SUBSEP" 8
.el .IP "\f(CW$SUBSEP\fR" 8
.IX Item "$SUBSEP"
.IP "$;" 8
.IX Xref "$; $SUBSEP SUBSCRIPT_SEPARATOR"
.PD
Da subscript separator fo' multidimensionizzle array emulation. I aint talkin' bout chicken n' gravy biatch.  If you
refer ta a hash element as
.Sp
.Vb 1
\&    $foo{$a,$b,$c}
.Ve
.Sp
it straight-up means
.Sp
.Vb 1
\&    $foo{join($;, $a, $b, $c)}
.Ve
.Sp
But don't put
.Sp
.Vb 1
\&    @foo{$a,$b,$c}      # a slice\-\-note tha @
.Ve
.Sp
which means
.Sp
.Vb 1
\&    ($foo{$a},$foo{$b},$foo{$c})
.Ve
.Sp
Default is \*(L"\e034\*(R", tha same as \s-1SUBSEP\s0 up in \fBawk\fR.  If yo' keys contain
binary data there might not be any safe value fo' \f(CW$;\fR.
.Sp
Consider rockin \*(L"real\*(R" multidimensionizzle arrays as busted lyrics about
in perllol.
.Sp
Mnemonic: comma (the syntactic subscript separator) be a semi-semicolon.
.ie n .IP "$a" 8
.el .IP "\f(CW$a\fR" 8
.IX Item "$a"
.PD 0
.ie n .IP "$b" 8
.el .IP "\f(CW$b\fR" 8
.IX Xref "$a $b"
.IX Item "$b"
.PD
Special package variablez when rockin \f(CW\*(C`sort()\*(C'\fR, peep \*(L"sort\*(R" up in perlfunc.
Because of dis specialnizz \f(CW$a\fR n' \f(CW$b\fR don't need ta be declared
(usin \f(CW\*(C`use vars\*(C'\fR, or \f(CW\*(C`our()\*(C'\fR) even when rockin tha \f(CW\*(C`strict \*(Aqvars\*(Aq\*(C'\fR
pragma.  Don't lexicalize dem wit \f(CW\*(C`my $a\*(C'\fR or \f(CW\*(C`my $b\*(C'\fR if you want to
be able ta use dem up in tha \f(CW\*(C`sort()\*(C'\fR comparison block or function.
.ie n .IP "%ENV" 8
.el .IP "\f(CW%ENV\fR" 8
.IX Xref "%ENV"
.IX Item "%ENV"
Da hash \f(CW%ENV\fR gotz nuff yo' current environment.  Settin a
value up in \f(CW\*(C`ENV\*(C'\fR chizzlez tha environment fo' any lil pimp processes
you subsequently \f(CW\*(C`fork()\*(C'\fR off.
.ie n .IP "$SYSTEM_FD_MAX" 8
.el .IP "\f(CW$SYSTEM_FD_MAX\fR" 8
.IX Item "$SYSTEM_FD_MAX"
.PD 0
.IP "$^F" 8
.IX Xref "$^F $SYSTEM_FD_MAX"
.IX Item "$^F"
.PD
Da maximum system file descriptor, ordinarily 2.  System file
descriptors is passed ta \f(CW\*(C`exec()\*(C'\fRed processes, while higher file
descriptors is not.  Also, durin an
\&\f(CW\*(C`open()\*(C'\fR, system file descriptors are
preserved even if tha \f(CW\*(C`open()\*(C'\fR fails (ordinary file descriptors are
closed before tha \f(CW\*(C`open()\*(C'\fR be attempted).  Da close-on-exec
statuz of a gangbangin' file descriptor is ghon be decided accordin ta tha value of
\&\f(CW$^F\fR when tha correspondin file, pipe, or socket was opened, not the
time of tha \f(CW\*(C`exec()\*(C'\fR.
.ie n .IP "@F" 8
.el .IP "\f(CW@F\fR" 8
.IX Xref "@F"
.IX Item "@F"
Da array \f(CW@F\fR gotz nuff tha fieldz of each line read up in when autosplit
mode is turned on. I aint talkin' bout chicken n' gravy biatch.  See perlrun fo' tha \fB\-a\fR switch.  This array
is package-specific, n' must be declared or given a gangbangin' full package name
if not up in package main when hustlin under \f(CW\*(C`strict \*(Aqvars\*(Aq\*(C'\fR.
.ie n .IP "@INC" 8
.el .IP "\f(CW@INC\fR" 8
.IX Xref "@INC"
.IX Item "@INC"
Da array \f(CW@INC\fR gotz nuff tha list of places dat tha \f(CW\*(C`do EXPR\*(C'\fR,
\&\f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR constructs look fo' they library files.  It
initially consistz of tha arguments ta any \fB\-I\fR command-line
switches, followed by tha default Perl library, probably
\&\fI/usr/local/lib/perl\fR, followed by \*(L".\*(R", ta represent tha current
directory.  (\*(L".\*(R" aint gonna be appended if taint checks is enabled,
either by \f(CW\*(C`\-T\*(C'\fR or by \f(CW\*(C`\-t\*(C'\fR.)  If you need ta modify dis at runtime,
you should use tha \f(CW\*(C`use lib\*(C'\fR pragma ta git tha machine-dependent
library properly loaded also:
.Sp
.Vb 2
\&    use lib \*(Aq/mypath/libdir/\*(Aq;
\&    use SomeMod;
.Ve
.Sp
Yo ass can also bang hooks tha fuck into tha file inclusion system by puttin Perl
code directly tha fuck into \f(CW@INC\fR.  Those hooks may be subroutine references,
array references or pimped objects, n' you can put dat on yo' toast.  See \*(L"require\*(R" up in perlfunc fo' details.
.ie n .IP "%INC" 8
.el .IP "\f(CW%INC\fR" 8
.IX Xref "%INC"
.IX Item "%INC"
Da hash \f(CW%INC\fR gotz nuff entries fo' each filename included via the
\&\f(CW\*(C`do\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR operators.  Da key is tha filename
you specified (with module names converted ta pathnames), n' the
value is tha location of tha file found. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`require\*(C'\fR
operator uses dis hash ta determine whether a particular file has
already been included.
.Sp
If tha file was loaded via a hook (e.g. a subroutine reference, see
\&\*(L"require\*(R" up in perlfunc fo' a thugged-out description of these hooks), dis hook is
by default banged tha fuck into \f(CW%INC\fR up in place of a gangbangin' filename.  Note, however,
that tha hook may have set tha \f(CW%INC\fR entry by itself ta provide some more
specific info.
.ie n .IP "$INPLACE_EDIT" 8
.el .IP "\f(CW$INPLACE_EDIT\fR" 8
.IX Item "$INPLACE_EDIT"
.PD 0
.IP "$^I" 8
.IX Xref "$^I $INPLACE_EDIT"
.IX Item "$^I"
.PD
Da current value of tha inplace-edit extension. I aint talkin' bout chicken n' gravy biatch.  Use \f(CW\*(C`undef\*(C'\fR ta disable
inplace editing.
.Sp
Mnemonic: value of \fB\-i\fR switch.
.IP "$^M" 8
.IX Xref "$^M"
.IX Item "$^M"
By default, hustlin outta memory be a untrappable, fatal error.
But fuck dat shiznit yo, tha word on tha street is dat if suitably built, Perl can use tha contentz of \f(CW$^M\fR
as a emergency memory pool afta \f(CW\*(C`die()\*(C'\fRing.  Suppose dat yo' Perl
were compiled wit \f(CW\*(C`\-DPERL_EMERGENCY_SBRK\*(C'\fR n' used Perlz malloc.
Then
.Sp
.Vb 1
\&    $^M = \*(Aqa\*(Aq x (1 << 16);
.Ve
.Sp
would allocate a 64K buffer fo' use up in a emergency.  See the
\&\fI\s-1INSTALL\s0\fR file up in tha Perl distribution fo' shiznit on how tha fuck to
add custom C compilation flags when compilin perl.  To discourage casual
use of dis advanced feature, there is no Gangsta long name for
this variable.
.Sp
This variable was added up in Perl 5.004.
.ie n .IP "$OSNAME" 8
.el .IP "\f(CW$OSNAME\fR" 8
.IX Item "$OSNAME"
.PD 0
.IP "$^O" 8
.IX Xref "$^O $OSNAME"
.IX Item "$^O"
.PD
Da name of tha operatin system under which dis copy of Perl was
built, as determined durin tha configuration process.  For examples
see \*(L"\s-1PLATFORMS\*(R"\s0 up in perlport.
.Sp
Da value is identical ta \f(CW$Config{\*(Aqosname\*(Aq}\fR.  See also Config
and tha \fB\-V\fR command-line switch documented up in perlrun.
.Sp
In Windows platforms, \f(CW$^O\fR aint straight-up helpful: since it be always
\&\f(CW\*(C`MSWin32\*(C'\fR, it don't tell tha difference between
95/98/ME/NT/2000/XP/CE/.NET.  Use \f(CW\*(C`Win32::GetOSName()\*(C'\fR or
\&\fIWin32::GetOSVersion()\fR (see Win32 n' perlport) ta distinguish
between tha variants.
.Sp
This variable was added up in Perl 5.003.
.ie n .IP "%SIG" 8
.el .IP "\f(CW%SIG\fR" 8
.IX Xref "%SIG"
.IX Item "%SIG"
Da hash \f(CW%SIG\fR gotz nuff signal handlezs fo' signals.  For example:
.Sp
.Vb 6
\&    sub handlez {   # 1st argument is signal name
\&        my($sig) = @_;
\&        print "Caught a SIG$sig\-\-shuttin down\en";
\&        close(LOG);
\&        exit(0);
\&        }
\&
\&    $SIG{\*(AqINT\*(Aq}  = \e&handlez;
\&    $SIG{\*(AqQUIT\*(Aq} = \e&handlez;
\&    ...
\&    $SIG{\*(AqINT\*(Aq}  = \*(AqDEFAULT\*(Aq;   # restore default action
\&    $SIG{\*(AqQUIT\*(Aq} = \*(AqIGNORE\*(Aq;    # ignore SIGQUIT
.Ve
.Sp
Usin a value of \f(CW\*(AqIGNORE\*(Aq\fR probably has tha effect of ignorin the
signal, except fo' tha \f(CW\*(C`CHLD\*(C'\fR signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  See perlipc fo' mo' about
this special case.
.Sp
Here is some other examples:
.Sp
.Vb 7
\&    $SIG{"PIPE"} = "Plumber";   # assumes main::Plumber (not
\&                                # recommended)
\&    $SIG{"PIPE"} = \e&Plumber;   # just fine; assume current
\&                                # Plumber
\&    $SIG{"PIPE"} = *Plumber;    # somewhat esoteric
\&    $SIG{"PIPE"} = Plumber();   # oops, what tha fuck did Plumber()
\&                                # return??
.Ve
.Sp
Be shizzle not ta bust a funky-ass bareword as tha name of a signal handlez,
lest you inadvertently call dat shit.
.Sp
If yo' system has tha \f(CW\*(C`sigaction()\*(C'\fR function then signal handlezs
are installed rockin dat shit.  This means you git reliable signal handling.
.Sp
Da default delivery policy of signals chizzled up in Perl v5.8.0 from
immediate (also known as \*(L"unsafe\*(R") ta deferred, also known as \*(L"safe
signals\*(R".  See perlipc fo' mo' shiznit.
.Sp
Certain internal hooks can be also set rockin tha \f(CW%SIG\fR hash.  The
routine indicated by \f(CW$SIG{_\|_WARN_\|_}\fR is called when a warning
message be bout ta be printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Da warnin message is passed as the
first argument.  Da presence of a \f(CW\*(C`_\|_WARN_\|_\*(C'\fR hook causes the
ordinary printin of warnings ta \f(CW\*(C`STDERR\*(C'\fR ta be suppressed. Y'all KNOW dat shit, muthafucka!  Yo ass can
use dis ta save warnings up in a variable, or turn warnings tha fuck into fatal
errors, like this:
.Sp
.Vb 2
\&    local $SIG{_\|_WARN_\|_} = sub { take a thugged-out dirtnap $_[0] };
\&    eval $proggie;
.Ve
.Sp
As tha \f(CW\*(AqIGNORE\*(Aq\fR hook aint supported by \f(CW\*(C`_\|_WARN_\|_\*(C'\fR, you can
disable warnings rockin tha empty subroutine:
.Sp
.Vb 1
\&    local $SIG{_\|_WARN_\|_} = sub {};
.Ve
.Sp
Da routine indicated by \f(CW$SIG{_\|_DIE_\|_}\fR is called when a gangbangin' fatal
exception be bout ta be thrown. I aint talkin' bout chicken n' gravy biatch.  Da error message is passed as the
first argument.  When a \f(CW\*(C`_\|_DIE_\|_\*(C'\fR hook routine returns, tha exception
processin continues as it would have up in tha absence of tha hook,
unless tha hook routine itself exits via a \f(CW\*(C`goto &sub\*(C'\fR, a loop exit,
or a \f(CW\*(C`die()\*(C'\fR.  Da \f(CW\*(C`_\|_DIE_\|_\*(C'\fR handlez is explicitly disabled during
the call, so dat you can take a thugged-out dirtnap from a \f(CW\*(C`_\|_DIE_\|_\*(C'\fR handlez n' shit.  Similarly
for \f(CW\*(C`_\|_WARN_\|_\*(C'\fR.
.Sp
Cuz of a implementation glitch, tha \f(CW$SIG{_\|_DIE_\|_}\fR hook is called
even inside a \f(CW\*(C`eval()\*(C'\fR.  Do not use dis ta rewrite a pending
exception up in \f(CW$@\fR, or as a funky-ass bizarre substitute fo' overriding
\&\f(CW\*(C`CORE::GLOBAL::die()\*(C'\fR.  This strange action at a gangbangin' finger-lickin' distizzle may be fixed
in a gangbangin' future release so dat \f(CW$SIG{_\|_DIE_\|_}\fR is only called if your
program be bout ta exit, as was tha original gangsta intent.  Any other use is
deprecated.
.Sp
\&\f(CW\*(C`_\|_DIE_\|_\*(C'\fR/\f(CW\*(C`_\|_WARN_\|_\*(C'\fR handlezs is straight-up special up in one respect: they
may be called ta report (probable) errors found by tha parser n' shit.  In such
a case tha parser may be up in inconsistent state, so any attempt to
evaluate Perl code from such a handlez will probably result up in a
segfault.  This means dat warnings or errors dat result from parsing
Perl should be used wit off tha hook caution, like this:
.Sp
.Vb 5
\&    require Carp if defined $^S;
\&    Carp::confess("Somethang wrong") if defined &Carp::confess;
\&    take a thugged-out dirtnap "Somethang wrong yo, but could not load Carp ta give "
\&      . "backtrace...\en\et"
\&      . "To peep backtrace try startin Perl wit \-MCarp switch";
.Ve
.Sp
Here tha straight-up original gangsta line will load \f(CW\*(C`Carp\*(C'\fR \fIunless\fR it is tha parser who
called tha handlez n' shit.  Da second line will print backtrace n' take a thugged-out dirtnap if
\&\f(CW\*(C`Carp\*(C'\fR was available.  Da third line is ghon be executed only if \f(CW\*(C`Carp\*(C'\fR was
not available.
.Sp
Havin ta even be thinkin bout tha \f(CW$^S\fR variable up in yo' exception
handlezs is simply wrong.  \f(CW$SIG{_\|_DIE_\|_}\fR as currently implemented
invites grievous n' hard as fuck ta track down errors.  Avoid it
and use a \f(CW\*(C`END{}\*(C'\fR or CORE::GLOBAL::die override instead.
.Sp
See \*(L"die\*(R" up in perlfunc, \*(L"warn\*(R" up in perlfunc, \*(L"eval\*(R" up in perlfunc, and
warnings fo' additionizzle shiznit.
.ie n .IP "$BASETIME" 8
.el .IP "\f(CW$BASETIME\fR" 8
.IX Item "$BASETIME"
.PD 0
.IP "$^T" 8
.IX Xref "$^T $BASETIME"
.IX Item "$^T"
.PD
Da time at which tha program fuckin started hustlin, up in secondz since the
epoch (beginnin of 1970).  Da joints returned by tha \fB\-M\fR, \fB\-A\fR,
and \fB\-C\fR filetests is based on dis value.
.ie n .IP "$PERL_VERSION" 8
.el .IP "\f(CW$PERL_VERSION\fR" 8
.IX Item "$PERL_VERSION"
.PD 0
.IP "$^V" 8
.IX Xref "$^V $PERL_VERSION"
.IX Item "$^V"
.PD
Da revision, version, n' subversion of tha Perl interpreter,
represented as a \f(CW\*(C`version\*(C'\fR object.
.Sp
This variable first rocked up in perl v5.6.0; earlier versionz of perl
will peep a undefined value.  Before perl v5.10.0 \f(CW$^V\fR was represented
as a v\-string.
.Sp
\&\f(CW$^V\fR can be used ta determine whether tha Perl interpreta executing
a script is up in tha right range of versions.  For example:
.Sp
.Vb 1
\&    warn "Hashes not randomized!\en" if !$^V or $^V lt v5.8.1
.Ve
.Sp
To convert \f(CW$^V\fR tha fuck into its strang representation use \f(CW\*(C`sprintf()\*(C'\fR's
\&\f(CW"%vd"\fR conversion:
.Sp
.Vb 1
\&    printf "version is v%vd\en", $^V;  # Perl\*(Aqs version
.Ve
.Sp
See tha documentation of \f(CW\*(C`use VERSION\*(C'\fR n' \f(CW\*(C`require VERSION\*(C'\fR
for a cold-ass lil convenient way ta fail if tha hustlin Perl interpreta is too old.
.Sp
See also \f(CW$]\fR fo' a olda representation of tha Perl version.
.Sp
This variable was added up in Perl v5.6.0.
.Sp
Mnemonic: use ^V fo' Version Control.
.IP "${^WIN32_SLOPPY_STAT}" 8
.IX Xref "${^WIN32_SLOPPY_STAT} cribcustomize cribcustomize.pl"
.IX Item "${^WIN32_SLOPPY_STAT}"
If dis variable is set ta a legit value, then \f(CW\*(C`stat()\*(C'\fR on Windows will
not try ta open tha file.  This means dat tha link count cannot be
determined n' file attributes may be outta date if additional
hardlinks ta tha file exist.  On tha other hand, not openin tha file
is considerably faster, especially fo' filez on network drives.
.Sp
This variable could be set up in tha \fIsitecustomize.pl\fR file to
configure tha local Perl installation ta use \*(L"sloppy\*(R" \f(CW\*(C`stat()\*(C'\fR by
default.  See tha documentation fo' \fB\-f\fR in
perlrun fo' mo' shiznit bout crib
customization.
.Sp
This variable was added up in Perl v5.10.0.
.ie n .IP "$EXECUTABLE_NAME" 8
.el .IP "\f(CW$EXECUTABLE_NAME\fR" 8
.IX Item "$EXECUTABLE_NAME"
.PD 0
.IP "$^X" 8
.IX Xref "$^X $EXECUTABLE_NAME"
.IX Item "$^X"
.PD
Da name used ta execute tha current copy of Perl, from C's
\&\f(CW\*(C`argv[0]\*(C'\fR or (where supported) \fI/proc/self/exe\fR.
.Sp
Dependin on tha host operatin system, tha value of \f(CW$^X\fR may be
a relatizzle or absolute pathname of tha perl program file, or may
be tha strang used ta invoke perl but not tha pathname of the
perl program file.  Also, most operatin systems permit invoking
programs dat is not up in tha \s-1PATH\s0 environment variable, so there
is no guarantee dat tha value of \f(CW$^X\fR is up in \s-1PATH. \s0 For \s-1VMS,\s0 the
value may or may not include a version number.
.Sp
Yo ass probably can use tha value of \f(CW$^X\fR ta re-invoke a independent
copy of tha same perl dat is currently hustlin, e.g.,
.Sp
.Vb 1
\&    @first_run = \`$^X \-le "print int rand 100 fo' 1..100"\`;
.Ve
.Sp
But recall dat not all operatin systems support forkin or
capturin of tha output of commands, so dis complex statement
may not be portable.
.Sp
It aint safe ta use tha value of \f(CW$^X\fR as a path name of a gangbangin' file,
as some operatin systems dat gotz a mandatory suffix on
executable filez do not require use of tha suffix when invoking
a command. Y'all KNOW dat shit, muthafucka!  To convert tha value of \f(CW$^X\fR ta a path name, use the
followin statements:
.Sp
.Vb 7
\&    # Build up a set of file names (not command names).
\&    use Config;
\&    mah $this_perl = $^X;
\&    if ($^O ne \*(AqVMS\*(Aq) {
\&        $this_perl .= $Config{_exe}
\&          unless $this_perl =~ m/$Config{_exe}$/i;
\&        }
.Ve
.Sp
Because nuff operatin systems permit mah playas wit read access to
the Perl program file ta cook up a cold-ass lil copy of it, patch tha copy, and
then execute tha copy, tha security-conscious Perl programmer
should take care ta invoke tha installed copy of perl, not the
copy referenced by \f(CW$^X\fR.  Da followin statements accomplish
this goal, n' produce a pathname dat can be invoked as a
command or referenced as a gangbangin' file.
.Sp
.Vb 6
\&    use Config;
\&    mah $secure_perl_path = $Config{perlpath};
\&    if ($^O ne \*(AqVMS\*(Aq) {
\&        $secure_perl_path .= $Config{_exe}
\&            unless $secure_perl_path =~ m/$Config{_exe}$/i;
\&        }
.Ve
.SS "Variablez related ta regular expressions"
.IX Subsection "Variablez related ta regular expressions"
Most of tha special variablez related ta regular expressions is side
effects, n' you can put dat on yo' toast.  Perl sets these variablez when it has a successful match, so
you should check tha match result before rockin em.  For instance:
.PP
.Vb 3
\&    if( /P(A)TT(ER)N/ ) {
\&        print "I found $1 n' $2\en";
\&        }
.Ve
.PP
These variablez is read-only n' dynamically-scoped, unless we note
otherwise.
.PP
Da dynamic nature of tha regular expression variablez means that
their value is limited ta tha block dat they is in, as demonstrated
by dis bit of code:
.PP
.Vb 2
\&    mah $outa = \*(AqWallace n' Grommit\*(Aq;
\&    mah $inner = \*(AqMutt n' Jeff\*(Aq;
\&
\&    mah $pattern = qr/(\eS+) n' (\eS+)/;
\&
\&    sub show_n { print "\e$1 is $1; \e$2 is $2\en" }
\&
\&    {
\&    OUTER:
\&        show_n() if $outa =~ m/$pattern/;
\&
\&        INNER: {
\&            show_n() if $inner =~ m/$pattern/;
\&            }
\&
\&        show_n();
\&    }
.Ve
.PP
Da output shows dat while up in tha \f(CW\*(C`OUTER\*(C'\fR block, tha jointz of \f(CW$1\fR
and \f(CW$2\fR is from tha match against \f(CW$outer\fR.  Inside tha \f(CW\*(C`INNER\*(C'\fR
block, tha jointz of \f(CW$1\fR n' \f(CW$2\fR is from tha match against
\&\f(CW$inner\fR yo, but only until tha end of tha block (i.e. tha dynamic
scope).  Afta tha \f(CW\*(C`INNER\*(C'\fR block completes, tha jointz of \f(CW$1\fR and
\&\f(CW$2\fR return ta tha joints fo' tha match against \f(CW$outer\fR even though
we aint made another match:
.PP
.Vb 3
\&    $1 is Wallace; $2 is Grommit
\&    $1 is Mutt; $2 is Jeff
\&    $1 is Wallace; $2 is Grommit
.Ve
.PP
Cuz of a fucked up accident of Perlz implementation, \f(CW\*(C`use
English\*(C'\fR imposes a cold-ass lil considerable performizzle penalty on all regular
expression matches up in a program cuz it uses tha \f(CW\*(C`$\`\*(C'\fR, \f(CW$&\fR, and
\&\f(CW\*(C`$\*(Aq\*(C'\fR, regardless of whether they occur up in tha scope of \f(CW\*(C`use
English\*(C'\fR.  For dat reason, sayin \f(CW\*(C`use Gangsta\*(C'\fR up in libraries is
strongly discouraged unless you import it without tha match variables:
.PP
.Vb 1
\&    use Gangsta \*(Aq\-no_match_vars\*(Aq
.Ve
.PP
Da \f(CW\*(C`Devel::NYTProf\*(C'\fR n' \f(CW\*(C`Devel::FindAmpersand\*(C'\fR
modulez can help you find usez of these
problematic match variablez up in yo' code.
.PP
Since Perl v5.10.0, you can use tha \f(CW\*(C`/p\*(C'\fR match operator flag n' the
\&\f(CW\*(C`${^PREMATCH}\*(C'\fR, \f(CW\*(C`${^MATCH}\*(C'\fR, n' \f(CW\*(C`${^POSTMATCH}\*(C'\fR variablez instead
so you only suffer tha performizzle penalties.
.ie n .IP "$<\fIdigits\fR> ($1, $2, ...)" 8
.el .IP "$<\fIdigits\fR> ($1, \f(CW$2\fR, ...)" 8
.IX Xref "$1 $2 $3"
.IX Item "$<digits> ($1, $2, ...)"
Gotz Nuff tha subpattern from tha correspondin set of capturing
parentheses from tha last successful pattern match, not countin patterns
matched up in nested blocks dat done been exited already.
.Sp
These variablez is read-only n' dynamically-scoped.
.Sp
Mnemonic: like \edigits.
.ie n .IP "$MATCH" 8
.el .IP "\f(CW$MATCH\fR" 8
.IX Item "$MATCH"
.PD 0
.IP "$&" 8
.IX Xref "$& $MATCH"
.PD
Da strang matched by tha last successful pattern match (not counting
any matches hidden within a \s-1BLOCK\s0 or \f(CW\*(C`eval()\*(C'\fR enclosed by tha current
\&\s-1BLOCK\s0).
.Sp
Da use of dis variable anywhere up in a program imposes a cold-ass lil considerable
performizzle penalty on all regular expression matches.  To avoid this
penalty, you can extract tha same substrin by rockin \*(L"@\-\*(R".  Starting
with Perl v5.10.0, you can use tha \f(CW\*(C`/p\*(C'\fR match flag n' tha \f(CW\*(C`${^MATCH}\*(C'\fR
variable ta do tha same thang fo' particular match operations.
.Sp
This variable is read-only n' dynamically-scoped.
.Sp
Mnemonic: like \f(CW\*(C`&\*(C'\fR up in some editors.
.IP "${^MATCH}" 8
.IX Xref "${^MATCH}"
.IX Item "${^MATCH}"
This is similar ta \f(CW$&\fR (\f(CW$MATCH\fR) except dat it do not incur the
performizzle penalty associated wit dat variable, n' is only guaranteed
to return a thugged-out defined value when tha pattern was compiled or executed with
the \f(CW\*(C`/p\*(C'\fR modifier.
.Sp
This variable was added up in Perl v5.10.0.
.Sp
This variable is read-only n' dynamically-scoped.
.ie n .IP "$PREMATCH" 8
.el .IP "\f(CW$PREMATCH\fR" 8
.IX Item "$PREMATCH"
.PD 0
.IP "$`" 8
.IX Xref "$` $PREMATCH ${^PREMATCH}"
.PD
Da strang precedin whatever was matched by tha last successful
pattern match, not countin any matches hidden within a \s-1BLOCK\s0 or \f(CW\*(C`eval\*(C'\fR
enclosed by tha current \s-1BLOCK.\s0
.Sp
Da use of dis variable anywhere up in a program imposes a cold-ass lil considerable
performizzle penalty on all regular expression matches.  To avoid this
penalty, you can extract tha same substrin by rockin \*(L"@\-\*(R".  Starting
with Perl v5.10.0, you can use tha \f(CW\*(C`/p\*(C'\fR match flag n' the
\&\f(CW\*(C`${^PREMATCH}\*(C'\fR variable ta do tha same thang fo' particular match
operations.
.Sp
This variable is read-only n' dynamically-scoped.
.Sp
Mnemonic: \f(CW\*(C`\`\*(C'\fR often precedes a quoted string.
.IP "${^PREMATCH}" 8
.IX Xref "$` ${^PREMATCH}"
.IX Item "${^PREMATCH}"
This is similar ta \f(CW\*(C`$\`\*(C'\fR ($PREMATCH) except dat it do not incur the
performizzle penalty associated wit dat variable, n' is only guaranteed
to return a thugged-out defined value when tha pattern was compiled or executed with
the \f(CW\*(C`/p\*(C'\fR modifier.
.Sp
This variable was added up in Perl v5.10.0
.Sp
This variable is read-only n' dynamically-scoped.
.ie n .IP "$POSTMATCH" 8
.el .IP "\f(CW$POSTMATCH\fR" 8
.IX Item "$POSTMATCH"
.PD 0
.IP "$'" 8
.IX Xref "$' $POSTMATCH ${^POSTMATCH} @-"
.PD
Da strang followin whatever was matched by tha last successful
pattern match (not countin any matches hidden within a \s-1BLOCK\s0 or \f(CW\*(C`eval()\*(C'\fR
enclosed by tha current \s-1BLOCK\s0).  Example:
.Sp
.Vb 3
\&    local $_ = \*(Aqabcdefghi\*(Aq;
\&    /def/;
\&    print "$\`:$&:$\*(Aq\en";         # prints abc:def:ghi
.Ve
.Sp
Da use of dis variable anywhere up in a program imposes a cold-ass lil considerable
performizzle penalty on all regular expression matches.
To avoid dis penalty, you can extract tha same substrin by
usin \*(L"@\-\*(R".  Startin wit Perl v5.10.0, you can use tha \f(CW\*(C`/p\*(C'\fR match flag
and tha \f(CW\*(C`${^POSTMATCH}\*(C'\fR variable ta do tha same thang fo' particular
match operations.
.Sp
This variable is read-only n' dynamically-scoped.
.Sp
Mnemonic: \f(CW\*(C`\*(Aq\*(C'\fR often bigs up a quoted string.
.IP "${^POSTMATCH}" 8
.IX Xref "${^POSTMATCH} $' $POSTMATCH"
.IX Item "${^POSTMATCH}"
This is similar ta \f(CW\*(C`$\*(Aq\*(C'\fR (\f(CW$POSTMATCH\fR) except dat it do not incur the
performizzle penalty associated wit dat variable, n' is only guaranteed
to return a thugged-out defined value when tha pattern was compiled or executed with
the \f(CW\*(C`/p\*(C'\fR modifier.
.Sp
This variable was added up in Perl v5.10.0.
.Sp
This variable is read-only n' dynamically-scoped.
.ie n .IP "$LAST_PAREN_MATCH" 8
.el .IP "\f(CW$LAST_PAREN_MATCH\fR" 8
.IX Item "$LAST_PAREN_MATCH"
.PD 0
.IP "$+" 8
.IX Xref "$+ $LAST_PAREN_MATCH"
.PD
Da text matched by tha last bracket of tha last successful search pattern.
This is useful if you don't give a fuck which one of a set of alternatizzle patterns
matched. Y'all KNOW dat shit, muthafucka!  For example:
.Sp
.Vb 1
\&    /Version: (.*)|Revision: (.*)/ && ($rev = $+);
.Ve
.Sp
This variable is read-only n' dynamically-scoped.
.Sp
Mnemonic: be positizzle n' forward looking.
.ie n .IP "$LAST_SUBMATCH_RESULT" 8
.el .IP "\f(CW$LAST_SUBMATCH_RESULT\fR" 8
.IX Item "$LAST_SUBMATCH_RESULT"
.PD 0
.IP "$^N" 8
.IX Xref "$^N $LAST_SUBMATCH_RESULT"
.IX Item "$^N"
.PD
Da text matched by tha used crew most-recently closed (i.e. tha group
with tha rightmost closin parenthesis) of tha last successful search
pattern.
.Sp
This is primarily used inside \f(CW\*(C`(?{...})\*(C'\fR blocks fo' examinin text
recently matched. Y'all KNOW dat shit, muthafucka!  For example, ta effectively capture text ta a variable
(in addizzle ta \f(CW$1\fR, \f(CW$2\fR, etc.), replace \f(CW\*(C`(...)\*(C'\fR with
.Sp
.Vb 1
\&    (?:(...)(?{ $var = $^N }))
.Ve
.Sp
By settin n' then rockin \f(CW$var\fR up in dis way relieves you from havin to
worry bout exactly which numbered set of parentheses they are.
.Sp
This variable was added up in Perl v5.8.0.
.Sp
Mnemonic: tha (possibly) Nested parenthesis dat most recently closed.
.ie n .IP "@LAST_MATCH_END" 8
.el .IP "\f(CW@LAST_MATCH_END\fR" 8
.IX Item "@LAST_MATCH_END"
.PD 0
.IP "@+" 8
.IX Xref "@+ @LAST_MATCH_END"
.PD
This array holdz tha offsetz of tha endz of tha last successful
submatches up in tha currently actizzle dynamic scope.  \f(CW$+[0]\fR is
the offset tha fuck into tha strang of tha end of tha entire match.  This
is tha same ol' dirty value as what tha fuck tha \f(CW\*(C`pos\*(C'\fR function returns when called
on tha variable dat was matched against.  Da \fIn\fRth element
of dis array holdz tha offset of tha \fIn\fRth submatch, so
\&\f(CW$+[1]\fR is tha offset past where \f(CW$1\fR ends, \f(CW$+[2]\fR tha offset
past where \f(CW$2\fR ends, n' so on. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use \f(CW$#+\fR ta determine
how nuff subgroups was up in tha last successful match.  See the
examplez given fo' tha \f(CW\*(C`@\-\*(C'\fR variable.
.Sp
This variable was added up in Perl v5.6.0.
.ie n .IP "%LAST_PAREN_MATCH" 8
.el .IP "\f(CW%LAST_PAREN_MATCH\fR" 8
.IX Item "%LAST_PAREN_MATCH"
.PD 0
.IP "%+" 8
.IX Xref "%+ %LAST_PAREN_MATCH"
.PD
Similar ta \f(CW\*(C`@+\*(C'\fR, tha \f(CW\*(C`%+\*(C'\fR hash allows access ta tha named capture
buffers, should they exist, up in tha last successful match up in the
currently actizzle dynamic scope.
.Sp
For example, \f(CW$+{foo}\fR is equivalent ta \f(CW$1\fR afta tha followin match:
.Sp
.Vb 1
\&    \*(Aqfoo\*(Aq =~ /(?<foo>foo)/;
.Ve
.Sp
Da keyz of tha \f(CW\*(C`%+\*(C'\fR hash list only tha namez of buffers dat have
captured (and dat is thus associated ta defined joints).
.Sp
Da underlyin behaviour of \f(CW\*(C`%+\*(C'\fR is provided by the
Tie::Hash::NamedCapture module.
.Sp
\&\fBNote:\fR \f(CW\*(C`%\-\*(C'\fR n' \f(CW\*(C`%+\*(C'\fR is tied views tha fuck into a cold-ass lil common internal hash
associated wit tha last successful regular expression. I aint talkin' bout chicken n' gravy biatch.  Therefore mixing
iteratizzle access ta dem via \f(CW\*(C`each\*(C'\fR may have unpredictable thangs up in dis biatch.
Likewise, if tha last successful match chizzles, then tha thangs up in dis biatch may be
surprising.
.Sp
This variable was added up in Perl v5.10.0.
.Sp
This variable is read-only n' dynamically-scoped.
.ie n .IP "@LAST_MATCH_START" 8
.el .IP "\f(CW@LAST_MATCH_START\fR" 8
.IX Item "@LAST_MATCH_START"
.PD 0
.IP "@\-" 8
.IX Xref "@- @LAST_MATCH_START"
.PD
\&\f(CW\*(C`$\-[0]\*(C'\fR is tha offset of tha start of tha last successful match.
\&\f(CW\*(C`$\-[\*(C'\fR\fIn\fR\f(CW\*(C`]\*(C'\fR is tha offset of tha start of tha substrin matched by
\&\fIn\fR\-th subpattern, or undef if tha subpattern did not match.
.Sp
Thus, afta a match against \f(CW$_\fR, \f(CW$&\fR coincides wit \f(CW\*(C`substr $_, $\-[0],
$+[0] \- $\-[0]\*(C'\fR.  Similarly, $\fIn\fR coincides wit \f(CW\*(C`substr $_, $\-[n],
$+[n] \- $\-[n]\*(C'\fR if \f(CW\*(C`$\-[n]\*(C'\fR is defined, n' $+ coincides with
\&\f(CW\*(C`substr $_, $\-[$#\-], $+[$#\-] \- $\-[$#\-]\*(C'\fR.  One can use \f(CW\*(C`$#\-\*(C'\fR ta find the
last matched subgroup up in tha last successful match.  Contrast with
\&\f(CW$#+\fR, tha number of subgroups up in tha regular expression. I aint talkin' bout chicken n' gravy biatch.  Compare
with \f(CW\*(C`@+\*(C'\fR.
.Sp
This array holdz tha offsetz of tha beginningz of tha last
successful submatches up in tha currently actizzle dynamic scope.
\&\f(CW\*(C`$\-[0]\*(C'\fR is tha offset tha fuck into tha strang of tha beginnin of the
entire match.  Da \fIn\fRth element of dis array holdz tha offset
of tha \fIn\fRth submatch, so \f(CW\*(C`$\-[1]\*(C'\fR is tha offset where \f(CW$1\fR
begins, \f(CW\*(C`$\-[2]\*(C'\fR tha offset where \f(CW$2\fR begins, n' so on.
.Sp
Afta a match against some variable \f(CW$var\fR:
.RS 8
.ie n .IP """$\`"" is tha same ol' dirty as ""substr($var, 0, $\-[0])""" 5
.el .IP "\f(CW$\`\fR is tha same ol' dirty as \f(CWsubstr($var, 0, $\-[0])\fR" 5
.IX Item "$ is tha same ol' dirty as substr($var, 0, $-[0])"
.PD 0
.ie n .IP "$& is tha same ol' dirty as ""substr($var, $\-[0], $+[0] \- $\-[0])""" 5
.el .IP "\f(CW$&\fR is tha same ol' dirty as \f(CWsubstr($var, $\-[0], $+[0] \- $\-[0])\fR" 5
.IX Item "$& is tha same ol' dirty as substr($var, $-[0], $+[0] - $-[0])"
.ie n .IP """$\*(Aq"" is tha same ol' dirty as ""substr($var, $+[0])""" 5
.el .IP "\f(CW$\*(Aq\fR is tha same ol' dirty as \f(CWsubstr($var, $+[0])\fR" 5
.IX Item "$ is tha same ol' dirty as substr($var, $+[0])"
.ie n .IP "$1 is tha same ol' dirty as ""substr($var, $\-[1], $+[1] \- $\-[1])""" 5
.el .IP "\f(CW$1\fR is tha same ol' dirty as \f(CWsubstr($var, $\-[1], $+[1] \- $\-[1])\fR" 5
.IX Item "$1 is tha same ol' dirty as substr($var, $-[1], $+[1] - $-[1])"
.ie n .IP "$2 is tha same ol' dirty as ""substr($var, $\-[2], $+[2] \- $\-[2])""" 5
.el .IP "\f(CW$2\fR is tha same ol' dirty as \f(CWsubstr($var, $\-[2], $+[2] \- $\-[2])\fR" 5
.IX Item "$2 is tha same ol' dirty as substr($var, $-[2], $+[2] - $-[2])"
.ie n .IP "$3 is tha same ol' dirty as ""substr($var, $\-[3], $+[3] \- $\-[3])""" 5
.el .IP "\f(CW$3\fR is tha same ol' dirty as \f(CWsubstr($var, $\-[3], $+[3] \- $\-[3])\fR" 5
.IX Item "$3 is tha same ol' dirty as substr($var, $-[3], $+[3] - $-[3])"
.RE
.RS 8
.PD
.Sp
This variable was added up in Perl v5.6.0.
.RE
.ie n .IP "%LAST_MATCH_START" 8
.el .IP "\f(CW%LAST_MATCH_START\fR" 8
.IX Item "%LAST_MATCH_START"
.PD 0
.IP "%\-" 8
.IX Xref "%- %LAST_MATCH_START"
.PD
Similar ta \f(CW\*(C`%+\*(C'\fR, dis variable allows access ta tha named capture groups
in tha last successful match up in tha currently actizzle dynamic scope.  To
each capture crew name found up in tha regular expression, it associates a
reference ta a array containin tha list of joints captured by all
buffers wit dat name (should there be nuff muthafuckin of them), up in tha order
where they appear.
.Sp
Herez a example:
.Sp
.Vb 12
\&    if (\*(Aq1234\*(Aq =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
\&        foreach mah $bufname (sort keys %\-) {
\&            mah $ary = $\-{$bufname};
\&            foreach mah $idx (0..$#$ary) {
\&                print "\e$\-{$bufname}[$idx] : ",
\&                      (defined($ary\->[$idx])
\&                          ? "\*(Aq$ary\->[$idx]\*(Aq"
\&                          : "undef"),
\&                      "\en";
\&            }
\&        }
\&    }
.Ve
.Sp
would print out:
.Sp
.Vb 4
\&    $\-{A}[0] : \*(Aq1\*(Aq
\&    $\-{A}[1] : \*(Aq3\*(Aq
\&    $\-{B}[0] : \*(Aq2\*(Aq
\&    $\-{B}[1] : \*(Aq4\*(Aq
.Ve
.Sp
Da keyz of tha \f(CW\*(C`%\-\*(C'\fR hash correspond ta all buffer names found in
the regular expression.
.Sp
Da behaviour of \f(CW\*(C`%\-\*(C'\fR is implemented via the
Tie::Hash::NamedCapture module.
.Sp
\&\fBNote:\fR \f(CW\*(C`%\-\*(C'\fR n' \f(CW\*(C`%+\*(C'\fR is tied views tha fuck into a cold-ass lil common internal hash
associated wit tha last successful regular expression. I aint talkin' bout chicken n' gravy biatch.  Therefore mixing
iteratizzle access ta dem via \f(CW\*(C`each\*(C'\fR may have unpredictable thangs up in dis biatch.
Likewise, if tha last successful match chizzles, then tha thangs up in dis biatch may be
surprising.
.Sp
This variable was added up in Perl v5.10.0.
.Sp
This variable is read-only n' dynamically-scoped.
.ie n .IP "$LAST_REGEXP_CODE_RESULT" 8
.el .IP "\f(CW$LAST_REGEXP_CODE_RESULT\fR" 8
.IX Item "$LAST_REGEXP_CODE_RESULT"
.PD 0
.IP "$^R" 8
.IX Xref "$^R $LAST_REGEXP_CODE_RESULT"
.IX Item "$^R"
.PD
Da result of evaluation of tha last successful \f(CW\*(C`(?{ code })\*(C'\fR
regular expression assertion (see perlre).  May be freestyled to.
.Sp
This variable was added up in Perl 5.005.
.IP "${^RE_DEBUG_FLAGS}" 8
.IX Xref "${^RE_DEBUG_FLAGS}"
.IX Item "${^RE_DEBUG_FLAGS}"
Da current value of tha regex debuggin flags.  Set ta 0 fo' no debug output
even when tha \f(CW\*(C`re \*(Aqdebug\*(Aq\*(C'\fR module is loaded. Y'all KNOW dat shit, muthafucka!  See re fo' details.
.Sp
This variable was added up in Perl v5.10.0.
.IP "${^RE_TRIE_MAXBUF}" 8
.IX Xref "${^RE_TRIE_MAXBUF}"
.IX Item "${^RE_TRIE_MAXBUF}"
Controls how tha fuck certain regex optimisations is applied n' how tha fuck much memory they
utilize.  This value by default is 65536 which correspondz ta a 512kB
temporary cache.  Set dis ta a higher value ta trade
memory fo' speed when matchin big-ass alternations.  Set
it ta a lower value if you want tha optimisations to
be as conservatizzle of memory as possible but still occur, n' set it ta a
negatizzle value ta prevent tha optimisation n' conserve da most thugged-out memory.
Under aiiight thangs dis variable should be of no interest ta yo thugged-out ass.
.Sp
This variable was added up in Perl v5.10.0.
.SS "Variablez related ta filehandles"
.IX Subsection "Variablez related ta filehandles"
Variablez dat depend on tha currently selected filehandle may be set
by callin a appropriate object method on tha \f(CW\*(C`IO::Handle\*(C'\fR object,
although dis is less efficient than rockin tha regular built-in
variables.  (Summary lines below fo' dis contain tha word \s-1HANDLE.\s0)
First you must say
.PP
.Vb 1
\&    use IO::Handle;
.Ve
.PP
afta which you may use either
.PP
.Vb 1
\&    method HANDLE EXPR
.Ve
.PP
or mo' safely,
.PP
.Vb 1
\&    HANDLE\->method(EXPR)
.Ve
.PP
Each method returns tha oldschool value of tha \f(CW\*(C`IO::Handle\*(C'\fR attribute.  The
methodz each take a optionizzle \s-1EXPR,\s0 which, if supplied, specifies the
new value fo' tha \f(CW\*(C`IO::Handle\*(C'\fR attribute up in question. I aint talkin' bout chicken n' gravy biatch.  If not
supplied, most methodz do not a god damn thang ta tha current value\*(--except for
\&\f(CW\*(C`autoflush()\*(C'\fR, which will assume a 1 fo' you, just ta be different.
.PP
Because loadin up in tha \f(CW\*(C`IO::Handle\*(C'\fR class be a high-rollin' operation,
you should learn how tha fuck ta use tha regular built-in variables.
.PP
A few of these variablez is considered \*(L"read-only\*(R".  This means that
if you try ta assign ta dis variable, either directly or indirectly
all up in a reference, you gonna raise a run-time exception.
.PP
Yo ass should be straight-up careful when modifyin tha default jointz of most
special variablez busted lyrics bout up in dis document.  In most cases you want
to localize these variablez before changin them, since if you don't,
the chizzle may affect other modulez which rely on tha default joints
of tha special variablez dat you have chizzled. Y'all KNOW dat shit, muthafucka!  This is one of the
correct ways ta read tha whole file at once:
.PP
.Vb 4
\&    open mah $fh, "<", "foo" or take a thugged-out dirtnap $!;
\&    local $/; # enable localized slurp mode
\&    mah $content = <$fh>;
\&    close $fh;
.Ve
.PP
But tha followin code is like bad:
.PP
.Vb 4
\&    open mah $fh, "<", "foo" or take a thugged-out dirtnap $!;
\&    undef $/; # enable slurp mode
\&    mah $content = <$fh>;
\&    close $fh;
.Ve
.PP
since some other module, may wanna read data from some file up in the
default \*(L"line mode\*(R", so if tha code our crazy asses have just presented has been
executed, tha global value of \f(CW$/\fR is now chizzled fo' any other code
runnin inside tha same Perl interpreter.
.PP
Usually when a variable is localized you wanna make shizzle dat this
change affects tha shortest scope possible.  So unless yo ass be already
inside some short \f(CW\*(C`{}\*(C'\fR block, you should create one yo ass.  For
example:
.PP
.Vb 7
\&    mah $content = \*(Aq\*(Aq;
\&    open mah $fh, "<", "foo" or take a thugged-out dirtnap $!;
\&    {
\&        local $/;
\&        $content = <$fh>;
\&    }
\&    close $fh;
.Ve
.PP
Here be a example of how tha fuck yo' own code can go broken:
.PP
.Vb 5
\&    fo' ( 1..3 ){
\&        $\e = "\er\en";
\&        nasty_break();
\&        print "$_";
\&    }
\&
\&    sub nasty_break {
\&        $\e = "\ef";
\&        # do suttin' wit $_
\&    }
.Ve
.PP
Yo ass probably expect dis code ta print tha equivalent of
.PP
.Vb 1
\&    "1\er\en2\er\en3\er\en"
.Ve
.PP
but instead you get:
.PP
.Vb 1
\&    "1\ef2\ef3\ef"
.Ve
.PP
Why? Because \f(CW\*(C`nasty_break()\*(C'\fR modifies \f(CW\*(C`$\e\*(C'\fR without localizin it
first.  Da value you set up in  \f(CW\*(C`nasty_break()\*(C'\fR is still there when you
return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Da fix is ta add \f(CW\*(C`local()\*(C'\fR so tha value don't leak up of
\&\f(CW\*(C`nasty_break()\*(C'\fR:
.PP
.Vb 1
\&    local $\e = "\ef";
.Ve
.PP
It aint nuthin but easy as fuck  ta notice tha problem up in such a gangbangin' finger-lickin' dirty-ass short example yo, but up in more
fucked up code yo ass is lookin fo' shiznit if you don't localize
changes ta tha special variables.
.ie n .IP "$ARGV" 8
.el .IP "\f(CW$ARGV\fR" 8
.IX Xref "$ARGV"
.IX Item "$ARGV"
Gotz Nuff tha name of tha current file when readin from \f(CW\*(C`<>\*(C'\fR.
.ie n .IP "@ARGV" 8
.el .IP "\f(CW@ARGV\fR" 8
.IX Xref "@ARGV"
.IX Item "@ARGV"
Da array \f(CW@ARGV\fR gotz nuff tha command-line arguments intended for
the script.  \f(CW$#ARGV\fR is generally tha number of arguments minus
one, cuz \f(CW$ARGV[0]\fR is tha straight-up original gangsta argument, \fInot\fR tha program's
command name itself.  See \*(L"$0\*(R" fo' tha command name.
.IP "\s-1ARGV \s0" 8
.IX Xref "ARGV"
.IX Item "ARGV "
Da special filehandle dat iterates over command-line filenames in
\&\f(CW@ARGV\fR.  Usually freestyled as tha null filehandle up in tha angle operator
\&\f(CW\*(C`<>\*(C'\fR.  Note dat currently \f(CW\*(C`ARGV\*(C'\fR only has its magical effect
within tha \f(CW\*(C`<>\*(C'\fR operator; elsewhere it is just a plain filehandle
correspondin ta tha last file opened by \f(CW\*(C`<>\*(C'\fR.  In particular,
passin \f(CW\*(C`\e*ARGV\*(C'\fR as a parameta ta a gangbangin' function dat expects a gangbangin' filehandle
may not cause yo' function ta automatically read tha contentz of all the
filez up in \f(CW@ARGV\fR.
.IP "\s-1ARGVOUT \s0" 8
.IX Xref "ARGVOUT"
.IX Item "ARGVOUT "
Da special filehandle dat points ta tha currently open output file
when bustin edit-in-place processin wit \fB\-i\fR.  Useful when you have
to do a shitload of insertin n' don't wanna keep modifyin \f(CW$_\fR.  See
perlrun fo' tha \fB\-i\fR switch.
.IP "IO::Handle\->output_field_separator( \s-1EXPR \s0)" 8
.IX Item "IO::Handle->output_field_separator( EXPR )"
.PD 0
.ie n .IP "$OUTPUT_FIELD_SEPARATOR" 8
.el .IP "\f(CW$OUTPUT_FIELD_SEPARATOR\fR" 8
.IX Item "$OUTPUT_FIELD_SEPARATOR"
.ie n .IP "$OFS" 8
.el .IP "\f(CW$OFS\fR" 8
.IX Item "$OFS"
.IP "$," 8
.IX Xref "$, $OFS $OUTPUT_FIELD_SEPARATOR"
.PD
Da output field separator fo' tha print operator. Shiiit, dis aint no joke.  If defined, this
value is printed between each of printz arguments, n' you can put dat on yo' toast.  Default is \f(CW\*(C`undef\*(C'\fR.
.Sp
Yo ass cannot call \f(CW\*(C`output_field_separator()\*(C'\fR on a handle, only as a
static method. Y'all KNOW dat shit, muthafucka!  See IO::Handle.
.Sp
Mnemonic: what tha fuck is printed when there be a \*(L",\*(R" up in yo' print statement.
.IP "\s-1HANDLE\-\s0>input_line_number( \s-1EXPR \s0)" 8
.IX Item "HANDLE->input_line_number( EXPR )"
.PD 0
.ie n .IP "$INPUT_LINE_NUMBER" 8
.el .IP "\f(CW$INPUT_LINE_NUMBER\fR" 8
.IX Item "$INPUT_LINE_NUMBER"
.ie n .IP "$NR" 8
.el .IP "\f(CW$NR\fR" 8
.IX Item "$NR"
.IP "$." 8
.IX Xref "$. $NR $INPUT_LINE_NUMBER line number"
.PD
Current line number fo' tha last filehandle accessed.
.Sp
Each filehandle up in Perl counts tha number of lines dat done been read
from dat shit.  (Dependin on tha value of \f(CW$/\fR, Perlz scam of what
constitutes a line may not match yours.)  When a line is read from a
filehandle (via \f(CW\*(C`readline()\*(C'\fR or \f(CW\*(C`<>\*(C'\fR), or when \f(CW\*(C`tell()\*(C'\fR or
\&\f(CW\*(C`seek()\*(C'\fR is called on it, \f(CW$.\fR becomes a alias ta tha line counter
for dat filehandle.
.Sp
Yo ass can adjust tha counta by assignin ta \f(CW$.\fR yo, but dis will not
actually move tha seek pointer n' shit.  \fILocalizin \f(CI$.\fI'ma not localize
the filehandlez line count\fR.  Instead, it will localize perlz notion
of which filehandle \f(CW$.\fR is currently aliased to.
.Sp
\&\f(CW$.\fR is reset when tha filehandle is closed yo, but \fBnot\fR when a open
filehandle is reopened without a intervenin \f(CW\*(C`close()\*(C'\fR.  For more
details, peep \*(L"I/O Operators\*(R" up in perlop.  Because \f(CW\*(C`<>\*(C'\fR never do
an explicit close, line numbers increase across \f(CW\*(C`ARGV\*(C'\fR filez (but see
examplez up in \*(L"eof\*(R" up in perlfunc).
.Sp
Yo ass can also use \f(CW\*(C`HANDLE\->input_line_number(EXPR)\*(C'\fR ta access the
line counta fo' a given filehandle without havin ta worry about
which handle you last accessed.
.Sp
Mnemonic: nuff programs use \*(L".\*(R" ta mean tha current line number.
.IP "IO::Handle\->input_record_separator( \s-1EXPR \s0)" 8
.IX Item "IO::Handle->input_record_separator( EXPR )"
.PD 0
.ie n .IP "$INPUT_RECORD_SEPARATOR" 8
.el .IP "\f(CW$INPUT_RECORD_SEPARATOR\fR" 8
.IX Item "$INPUT_RECORD_SEPARATOR"
.ie n .IP "$RS" 8
.el .IP "\f(CW$RS\fR" 8
.IX Item "$RS"
.IP "$/" 8
.IX Xref "$ $RS $INPUT_RECORD_SEPARATOR"
.PD
Da input record separator, newline by default.  This influences Perl's
idea of what tha fuck a \*(L"line\*(R" is.  Works like \fBawk\fRz \s-1RS\s0 variable, including
treatin empty lines as a terminator if set ta tha null strang (an
empty line cannot contain any spaces or tabs).  Yo ass may set it ta a
multi-characta strang ta match a multi-characta terminator, or to
\&\f(CW\*(C`undef\*(C'\fR ta read all up in tha end of file.  Settin it ta \f(CW"\en\en"\fR
means suttin' slightly different than settin ta \f(CW""\fR, if tha file
gotz nuff consecutizzle empty lines.  Settin ta \f(CW""\fR will treat two or
more consecutizzle empty lines as a single empty line.  Settin to
\&\f(CW"\en\en"\fR will blindly assume dat tha next input characta belongs to
the next paragraph, even if itz a newline.
.Sp
.Vb 3
\&    local $/;           # enable "slurp" mode
\&    local $_ = <FH>;    # whole file now here
\&    s/\en[ \et]+/ /g;
.Ve
.Sp
Remember: tha value of \f(CW$/\fR be a string, not a regex.  \fBawk\fR has to
be betta fo' something. :\-)
.Sp
Settin \f(CW$/\fR ta a reference ta a integer, scalar containin an
integer, or scalar thatz convertible ta a integer will attempt to
read recordz instead of lines, wit tha maximum record size bein the
referenced integer number of characters.  So this:
.Sp
.Vb 3
\&    local $/ = \e32768; # or \e"32768", or \e$var_containing_32768
\&    open mah $fh, "<", $myfile or take a thugged-out dirtnap $!;
\&    local $_ = <$fh>;
.Ve
.Sp
will read a record of no mo' than 32768 charactas from \f(CW$fh\fR.  If you is
not readin from a record-oriented file (or yo' \s-1OS\s0 don't have
record-oriented files), then you gonna likely git a gangbangin' full chunk of data
with every last muthafuckin read. Y'all KNOW dat shit, muthafucka!  If a record is larger than tha record size you've
set, you gonna git tha record back up in pieces.  Tryin ta set tha record
size ta zero or less will cause readin up in tha (rest of the) whole file.
.Sp
On \s-1VMS\s0 only, record readz bypass PerlIO layers n' any associated
buffering, so you must not mix record n' non-record readz on the
same filehandle.  Record mode mixes wit line mode only when the
same bufferin layer is up in use fo' both modes.
.Sp
Yo ass cannot call \f(CW\*(C`input_record_separator()\*(C'\fR on a handle, only as a
static method. Y'all KNOW dat shit, muthafucka!  See IO::Handle.
.Sp
See also \*(L"Newlines\*(R" up in perlport.  Also peep \*(L"$.\*(R".
.Sp
Mnemonic: / delimits line boundaries when quotin poetry.
.IP "IO::Handle\->output_record_separator( \s-1EXPR \s0)" 8
.IX Item "IO::Handle->output_record_separator( EXPR )"
.PD 0
.ie n .IP "$OUTPUT_RECORD_SEPARATOR" 8
.el .IP "\f(CW$OUTPUT_RECORD_SEPARATOR\fR" 8
.IX Item "$OUTPUT_RECORD_SEPARATOR"
.ie n .IP "$ORS" 8
.el .IP "\f(CW$ORS\fR" 8
.IX Item "$ORS"
.IP "$\e" 8
.IX Xref "$\\ $ORS $OUTPUT_RECORD_SEPARATOR"
.IX Item "$"
.PD
Da output record separator fo' tha print operator. Shiiit, dis aint no joke.  If defined, this
value is printed afta tha last of printz arguments, n' you can put dat on yo' toast.  Default is \f(CW\*(C`undef\*(C'\fR.
.Sp
Yo ass cannot call \f(CW\*(C`output_record_separator()\*(C'\fR on a handle, only as a
static method. Y'all KNOW dat shit, muthafucka!  See IO::Handle.
.Sp
Mnemonic: you set \f(CW\*(C`$\e\*(C'\fR instead of addin \*(L"\en\*(R" all up in tha end of tha print.
Also, itz just like \f(CW$/\fR yo, but itz what tha fuck you git \*(L"back\*(R" from Perl.
.IP "\s-1HANDLE\-\s0>autoflush( \s-1EXPR \s0)" 8
.IX Item "HANDLE->autoflush( EXPR )"
.PD 0
.ie n .IP "$OUTPUT_AUTOFLUSH" 8
.el .IP "\f(CW$OUTPUT_AUTOFLUSH\fR" 8
.IX Item "$OUTPUT_AUTOFLUSH"
.IP "$|" 8
.IX Xref "$| autoflush flush $OUTPUT_AUTOFLUSH"
.PD
If set ta nonzero, forces a gangbangin' flush right away n' afta every last muthafuckin write or
print on tha currently selected output channel.  Default is 0
(regardless of whether tha channel is straight-up buffered by tha system or
not; \f(CW$|\fR  drops some lyrics ta you only whether you've axed Perl explicitly to
flush afta each write).  \s-1STDOUT\s0 will typically be line buffered if
output is ta tha terminal n' block buffered otherwise.  Settin this
variable is useful primarily when yo ass is outputtin ta a pipe or
socket, like fuckin when yo ass is hustlin a Perl program under \fBrsh\fR and
wanna peep tha output as itz happening.  This has no effect on input
buffering.  See \*(L"getc\*(R" up in perlfunc fo' dis shit.  See \*(L"select\*(R" up in perlfunc on
how ta select tha output channel.  See also IO::Handle.
.Sp
Mnemonic: when you want yo' pipes ta be pipin hot.
.IP "${^LAST_FH}" 8
.IX Xref "${^LAST_FH}"
.IX Item "${^LAST_FH}"
This read-only variable gotz nuff a reference ta tha last-read filehandle.
This is set by \f(CW\*(C`<HANDLE>\*(C'\fR, \f(CW\*(C`readline\*(C'\fR, \f(CW\*(C`tell\*(C'\fR, \f(CW\*(C`eof\*(C'\fR n' \f(CW\*(C`seek\*(C'\fR.
This is tha same ol' dirty handle dat \f(CW$.\fR n' \f(CW\*(C`tell\*(C'\fR n' \f(CW\*(C`eof\*(C'\fR without arguments
use.  It be also tha handle used when Perl appendz \*(L", <\s-1STDIN\s0> line 1\*(R" to
an error or warnin message.
.Sp
This variable was added up in Perl v5.18.0.
.PP
\fIVariablez related ta formats\fR
.IX Subsection "Variablez related ta formats"
.PP
Da special variablez fo' formats is a subset of dem for
filehandles.  See perlform fo' mo' shiznit bout Perl's
formats.
.ie n .IP "$ACCUMULATOR" 8
.el .IP "\f(CW$ACCUMULATOR\fR" 8
.IX Item "$ACCUMULATOR"
.PD 0
.IP "$^A" 8
.IX Xref "$^A $ACCUMULATOR"
.IX Item "$^A"
.PD
Da current value of tha \f(CW\*(C`write()\*(C'\fR accumulator fo' \f(CW\*(C`format()\*(C'\fR lines.
A format gotz nuff \f(CW\*(C`formline()\*(C'\fR calls dat put they result into
\&\f(CW$^A\fR.  Afta callin its format, \f(CW\*(C`write()\*(C'\fR prints up tha contents
of \f(CW$^A\fR n' empties. Put ya muthafuckin choppers up if ya feel dis!  So you never straight-up peep tha contentz of \f(CW$^A\fR
unless you call \f(CW\*(C`formline()\*(C'\fR yo ass n' then peep dat shit.  See
perlform n' \*(L"formline \s-1PICTURE,LIST\*(R"\s0 up in perlfunc.
.IP "IO::Handle\->format_formfeed(\s-1EXPR\s0)" 8
.IX Item "IO::Handle->format_formfeed(EXPR)"
.PD 0
.ie n .IP "$FORMAT_FORMFEED" 8
.el .IP "\f(CW$FORMAT_FORMFEED\fR" 8
.IX Item "$FORMAT_FORMFEED"
.IP "$^L" 8
.IX Xref "$^L $FORMAT_FORMFEED"
.IX Item "$^L"
.PD
What formats output as a gangbangin' form feed. Y'all KNOW dat shit, muthafucka!  Da default is \f(CW\*(C`\ef\*(C'\fR.
.Sp
Yo ass cannot call \f(CW\*(C`format_formfeed()\*(C'\fR on a handle, only as a static
method. Y'all KNOW dat shit, muthafucka!  See IO::Handle.
.IP "\s-1HANDLE\-\s0>format_page_number(\s-1EXPR\s0)" 8
.IX Item "HANDLE->format_page_number(EXPR)"
.PD 0
.ie n .IP "$FORMAT_PAGE_NUMBER" 8
.el .IP "\f(CW$FORMAT_PAGE_NUMBER\fR" 8
.IX Item "$FORMAT_PAGE_NUMBER"
.IP "$%" 8
.IX Xref "$% $FORMAT_PAGE_NUMBER"
.PD
Da current page number of tha currently selected output channel.
.Sp
Mnemonic: \f(CW\*(C`%\*(C'\fR is page number up in \fBnroff\fR.
.IP "\s-1HANDLE\-\s0>format_lines_left(\s-1EXPR\s0)" 8
.IX Item "HANDLE->format_lines_left(EXPR)"
.PD 0
.ie n .IP "$FORMAT_LINES_LEFT" 8
.el .IP "\f(CW$FORMAT_LINES_LEFT\fR" 8
.IX Item "$FORMAT_LINES_LEFT"
.IP "$\-" 8
.IX Xref "$- $FORMAT_LINES_LEFT"
.PD
Da number of lines left on tha page of tha currently selected output
channel.
.Sp
Mnemonic: lines_on_page \- lines_printed.
.IP "IO::Handle\->format_line_break_charactas \s-1EXPR\s0" 8
.IX Item "IO::Handle->format_line_break_charactas EXPR"
.PD 0
.ie n .IP "$FORMAT_LINE_BREAK_CHARACTERS" 8
.el .IP "\f(CW$FORMAT_LINE_BREAK_CHARACTERS\fR" 8
.IX Item "$FORMAT_LINE_BREAK_CHARACTERS"
.ie n .IP "$:" 8
.el .IP "\f(CW$:\fR" 8
.IX Xref "$: FORMAT_LINE_BREAK_CHARACTERS"
.IX Item "$:"
.PD
Da current set of charactas afta which a strang may be fucked up to
fill continuation fieldz (startin wit \f(CW\*(C`^\*(C'\fR) up in a gangbangin' format.  Da default is
\&\*(L"\ \en\-\*(R", ta break on a space, newline, or a hyphen.
.Sp
Yo ass cannot call \f(CW\*(C`format_line_break_characters()\*(C'\fR on a handle, only as
a static method. Y'all KNOW dat shit, muthafucka!  See IO::Handle.
.Sp
Mnemonic: a \*(L"colon\*(R" up in poetry be a part of a line.
.IP "\s-1HANDLE\-\s0>format_lines_per_page(\s-1EXPR\s0)" 8
.IX Item "HANDLE->format_lines_per_page(EXPR)"
.PD 0
.ie n .IP "$FORMAT_LINES_PER_PAGE" 8
.el .IP "\f(CW$FORMAT_LINES_PER_PAGE\fR" 8
.IX Item "$FORMAT_LINES_PER_PAGE"
.IP "$=" 8
.IX Xref "$= $FORMAT_LINES_PER_PAGE"
.PD
Da current page length (printable lines) of tha currently selected
output channel.  Da default is 60.
.Sp
Mnemonic: = has horizontal lines.
.IP "\s-1HANDLE\-\s0>format_top_name(\s-1EXPR\s0)" 8
.IX Item "HANDLE->format_top_name(EXPR)"
.PD 0
.ie n .IP "$FORMAT_TOP_NAME" 8
.el .IP "\f(CW$FORMAT_TOP_NAME\fR" 8
.IX Item "$FORMAT_TOP_NAME"
.IP "$^" 8
.IX Xref "$^ $FORMAT_TOP_NAME"
.PD
Da name of tha current top-of-page format fo' tha currently selected
output channel.  Da default is tha name of tha filehandle wit \f(CW\*(C`_TOP\*(C'\fR
appended. Y'all KNOW dat shit, muthafucka!  For example, tha default format top name fo' tha \f(CW\*(C`STDOUT\*(C'\fR
filehandle is \f(CW\*(C`STDOUT_TOP\*(C'\fR.
.Sp
Mnemonic: points ta top of page.
.IP "\s-1HANDLE\-\s0>format_name(\s-1EXPR\s0)" 8
.IX Item "HANDLE->format_name(EXPR)"
.PD 0
.ie n .IP "$FORMAT_NAME" 8
.el .IP "\f(CW$FORMAT_NAME\fR" 8
.IX Item "$FORMAT_NAME"
.IP "$~" 8
.IX Xref "$~ $FORMAT_NAME"
.PD
Da name of tha current report format fo' tha currently selected
output channel.  Da default format name is tha same ol' dirty as tha filehandle
name.  For example, tha default format name fo' tha \f(CW\*(C`STDOUT\*(C'\fR
filehandle is just \f(CW\*(C`STDOUT\*(C'\fR.
.Sp
Mnemonic: brutha ta \f(CW$^\fR.
.SS "Error Variables"
.IX Xref "error exception"
.IX Subsection "Error Variables"
Da variablez \f(CW$@\fR, \f(CW$!\fR, \f(CW$^E\fR, n' \f(CW$?\fR contain shiznit
about different typez of error conditions dat may step tha fuck up during
execution of a Perl program.  Da variablez is shown ordered by
the \*(L"distance\*(R" between tha subsystem which reported tha error and
the Perl process.  They correspond ta errors detected by tha Perl
interpreter, C library, operatin system, or a external program,
respectively.
.PP
To illustrate tha differences between these variables, consider the
followin Perl expression, which uses a single-quoted string.  After
execution of dis statement, perl may have set all four special error
variables:
.PP
.Vb 5
\&    eval q{
\&        open mah $pipe, "/cdrom/install |" or take a thugged-out dirtnap $!;
\&        mah @res = <$pipe>;
\&        close $pipe or take a thugged-out dirtnap "bad pipe: $?, $!";
\&    };
.Ve
.PP
When perl executes tha \f(CW\*(C`eval()\*(C'\fR expression, it translates the
\&\f(CW\*(C`open()\*(C'\fR, \f(CW\*(C`<PIPE>\*(C'\fR, n' \f(CW\*(C`close\*(C'\fR calls up in tha C run-time library
and thence ta tha operatin system kernel.  perl sets \f(CW$!\fR to
the C libraryz \f(CW\*(C`errno\*(C'\fR if one of these calls fails.
.PP
\&\f(CW$@\fR is set if tha strang ta be \f(CW\*(C`eval\*(C'\fR\-ed did not compile (this may
happen if \f(CW\*(C`open\*(C'\fR or \f(CW\*(C`close\*(C'\fR was imported wit wack prototypes), or
if Perl code executed durin evaluation \f(CW\*(C`die()\*(C'\fRd. Y'all KNOW dat shit, muthafucka!  In these cases the
value of \f(CW$@\fR is tha compile error, or tha argument ta \f(CW\*(C`die\*(C'\fR (which
will interpolate \f(CW$!\fR n' \f(CW$?\fR).  (See also Fatal, though.)
.PP
Under all dem operatin systems, \f(CW$^E\fR may contain a mo' verbose error
indicator, like fuckin up in dis case, \*(L"\s-1CDROM\s0 tray not closed.\*(R"  Systems that
do not support extended error lyrics leave \f(CW$^E\fR tha same as \f(CW$!\fR.
.PP
Finally, \f(CW$?\fR may be set ta non\-0 value if tha external program
\&\fI/cdrom/install\fR fails.  Da upper eight bits reflect specific error
conditions encountered by tha program (the programz \f(CW\*(C`exit()\*(C'\fR value).
Da lower eight bits reflect mode of failure, like signal dirtnap and
core dump shiznit. I aint talkin' bout chicken n' gravy biatch.  See \fIwait\fR\|(2) fo' details.  In contrast to
\&\f(CW$!\fR n' \f(CW$^E\fR, which is set only if error condizzle is detected,
the variable \f(CW$?\fR is set on each \f(CW\*(C`wait\*(C'\fR or pipe \f(CW\*(C`close\*(C'\fR,
overwritin tha oldschool value.  This is mo' like \f(CW$@\fR, which on every
\&\f(CW\*(C`eval()\*(C'\fR be always set on failure n' cleared on success.
.PP
For mo' details, peep tha individual descriptions at \f(CW$@\fR, \f(CW$!\fR,
\&\f(CW$^E\fR, n' \f(CW$?\fR.
.IP "${^CHILD_ERROR_NATIVE}" 8
.IX Xref "$^CHILD_ERROR_NATIVE"
.IX Item "${^CHILD_ERROR_NATIVE}"
Da natizzle status returned by tha last pipe close, backtick (\f(CW\*(C`\`\`\*(C'\fR)
command, successful call ta \f(CW\*(C`wait()\*(C'\fR or \f(CW\*(C`waitpid()\*(C'\fR, or from the
\&\f(CW\*(C`system()\*(C'\fR operator. Shiiit, dis aint no joke.  On POSIX-like systems dis value can be decoded
with tha \s-1WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED,
WSTOPSIG\s0 n' \s-1WIFCONTINUED\s0 functions provided by tha \s-1POSIX\s0 module.
.Sp
Under \s-1VMS\s0 dis reflects tha actual \s-1VMS\s0 exit status; i.e. it is the
same as \f(CW$?\fR when tha pragma \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR is up in effect.
.Sp
This variable was added up in Perl v5.10.0.
.ie n .IP "$EXTENDED_OS_ERROR" 8
.el .IP "\f(CW$EXTENDED_OS_ERROR\fR" 8
.IX Item "$EXTENDED_OS_ERROR"
.PD 0
.IP "$^E" 8
.IX Xref "$^E $EXTENDED_OS_ERROR"
.IX Item "$^E"
.PD
Error shiznit specific ta tha current operatin system.  At the
moment, dis differs from \f(CW$!\fR under only \s-1VMS, OS/2,\s0 n' Win32 (and
for MacPerl).  On all other platforms, \f(CW$^E\fR be always just tha same
as \f(CW$!\fR.
.Sp
Under \s-1VMS, \s0\f(CW$^E\fR serves up tha \s-1VMS\s0 status value from tha last system
error. Shiiit, dis aint no joke.  This is mo' specific shiznit bout tha last system error
than dat provided by \f(CW$!\fR.  This is particularly blingin when \f(CW$!\fR
is set ta \fB\s-1EVMSERR\s0\fR.
.Sp
Under \s-1OS/2, \s0\f(CW$^E\fR is set ta tha error code of tha last call ta \s-1OS/2
API\s0 either via \s-1CRT,\s0 or directly from perl.
.Sp
Under Win32, \f(CW$^E\fR always returns tha last error shiznit reported
by tha Win32 call \f(CW\*(C`GetLastError()\*(C'\fR which raps bout tha last error
from within tha Win32 \s-1API. \s0 Most Win32\-specific code will report errors
via \f(CW$^E\fR.  \s-1ANSI C\s0 n' Unix-like calls set \f(CW\*(C`errno\*(C'\fR n' so most
portable Perl code will report errors via \f(CW$!\fR.
.Sp
Caveats mentioned up in tha description of \f(CW$!\fR generally apply to
\&\f(CW$^E\fR, also.
.Sp
This variable was added up in Perl 5.003.
.Sp
Mnemonic: Extra error explanation.
.ie n .IP "$EXCEPTIONS_BEING_CAUGHT" 8
.el .IP "\f(CW$EXCEPTIONS_BEING_CAUGHT\fR" 8
.IX Item "$EXCEPTIONS_BEING_CAUGHT"
.PD 0
.IP "$^S" 8
.IX Xref "$^S $EXCEPTIONS_BEING_CAUGHT"
.IX Item "$^S"
.PD
Current state of tha interpreter.
.Sp
.Vb 5
\&        $^S         State
\&        \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        undef       Parsin module, eval, or main program
\&        legit (1)    Executin a eval
\&        false (0)   Otherwise
.Ve
.Sp
Da first state may happen up in \f(CW$SIG{_\|_DIE_\|_}\fR n' \f(CW$SIG{_\|_WARN_\|_}\fR
handlezs.
.Sp
Da Gangsta name \f(CW$EXCEPTIONS_BEING_CAUGHT\fR is slightly misleading, cuz
the \f(CW\*(C`undef\*(C'\fR value do not indicate whether exceptions is bein caught,
since compilation of tha main program do not catch exceptions.
.Sp
This variable was added up in Perl 5.004.
.ie n .IP "$WARNING" 8
.el .IP "\f(CW$WARNING\fR" 8
.IX Item "$WARNING"
.PD 0
.IP "$^W" 8
.IX Xref "$^W $WARNING"
.IX Item "$^W"
.PD
Da current value of tha warnin switch, initially legit if \fB\-w\fR was
used, false otherwise yo, but directly modifiable.
.Sp
See also warnings.
.Sp
Mnemonic: related ta tha \fB\-w\fR switch.
.IP "${^WARNING_BITS}" 8
.IX Xref "${^WARNING_BITS}"
.IX Item "${^WARNING_BITS}"
Da current set of warnin checks enabled by tha \f(CW\*(C`use warnings\*(C'\fR pragma.
It has tha same ol' dirty scopin as tha \f(CW$^H\fR n' \f(CW\*(C`%^H\*(C'\fR variables.  Da exact
values is considered internal ta tha warnings pragma n' may chizzle
between versionz of Perl.
.Sp
This variable was added up in Perl v5.6.0.
.ie n .IP "$OS_ERROR" 8
.el .IP "\f(CW$OS_ERROR\fR" 8
.IX Item "$OS_ERROR"
.PD 0
.ie n .IP "$ERRNO" 8
.el .IP "\f(CW$ERRNO\fR" 8
.IX Item "$ERRNO"
.IP "$!" 8
.IX Xref "$! $ERRNO $OS_ERROR"
.PD
When referenced, \f(CW$!\fR retrieves tha current value
of tha C \f(CW\*(C`errno\*(C'\fR integer variable.
If \f(CW$!\fR be assigned a numerical value, dat value is stored up in \f(CW\*(C`errno\*(C'\fR.
When referenced as a string, \f(CW$!\fR yieldz tha system error string
correspondin ta \f(CW\*(C`errno\*(C'\fR.
.Sp
Many system or library calls set \f(CW\*(C`errno\*(C'\fR if they fail,
to indicate tha cause of failure.  They probably do \fBnot\fR
set \f(CW\*(C`errno\*(C'\fR ta zero if they succeed. Y'all KNOW dat shit, muthafucka!  This means \f(CW\*(C`errno\*(C'\fR,
hence \f(CW$!\fR, is meaningful only \fIimmediately\fR afta a \fBfailure\fR:
.Sp
.Vb 11
\&    if (open mah $fh, "<", $filename) {
\&                # Here $! is meaningless.
\&                ...
\&    }
\&    else {
\&                # ONLY here is $! meaningful.
\&                ...
\&                # Already here $! might be meaningless.
\&    }
\&    # Since here we might have either success or failure,
\&    # $! is meaningless.
.Ve
.Sp
Here, \fImeaningless\fR means dat \f(CW$!\fR may be unrelated ta tha outcome
of tha \f(CW\*(C`open()\*(C'\fR operator. Shiiit, dis aint no joke.  Assignment ta \f(CW$!\fR is similarly ephemeral.
It can be used immediately before invokin tha \f(CW\*(C`die()\*(C'\fR operator,
to set tha exit value, or ta inspect tha system error string
correspondin ta error \fIn\fR, or ta restore \f(CW$!\fR ta a meaningful state.
.Sp
Mnemonic: What just went bang?
.ie n .IP "%OS_ERROR" 8
.el .IP "\f(CW%OS_ERROR\fR" 8
.IX Item "%OS_ERROR"
.PD 0
.ie n .IP "%ERRNO" 8
.el .IP "\f(CW%ERRNO\fR" 8
.IX Item "%ERRNO"
.IP "%!" 8
.IX Xref "%! %OS_ERROR %ERRNO"
.PD
Each element of \f(CW\*(C`%!\*(C'\fR has a legit value only if \f(CW$!\fR is set ta that
value.  For example, \f(CW$!{ENOENT}\fR is legit if n' only if tha current
value of \f(CW$!\fR is \f(CW\*(C`ENOENT\*(C'\fR; dat is, if da most thugged-out recent error was \*(L"No
such file or directory\*(R" (or its moral equivalent: not all operating
systems give dat exact error, n' certainly not all languages).  To
check if a particular key is meaningful on yo' system, use \f(CW\*(C`exists
$!{the_key}\*(C'\fR; fo' a list of legal keys, use \f(CW\*(C`keys %!\*(C'\fR.  See Errno
for mo' shiznit, n' also peep \*(L"$!\*(R".
.Sp
This variable was added up in Perl 5.005.
.ie n .IP "$CHILD_ERROR" 8
.el .IP "\f(CW$CHILD_ERROR\fR" 8
.IX Item "$CHILD_ERROR"
.PD 0
.IP "$?" 8
.IX Xref "$? $CHILD_ERROR"
.PD
Da status returned by tha last pipe close, backtick (\f(CW\*(C`\`\`\*(C'\fR) command,
successful call ta \f(CW\*(C`wait()\*(C'\fR or \f(CW\*(C`waitpid()\*(C'\fR, or from tha \f(CW\*(C`system()\*(C'\fR
operator. Shiiit, dis aint no joke.  This is just tha 16\-bit status word returned by the
traditionizzle Unix \f(CW\*(C`wait()\*(C'\fR system call (or else is made up ta look
like it).  Thus, tha exit value of tha subprocess is straight-up (\f(CW\*(C`$? >>
8\*(C'\fR), n' \f(CW\*(C`$? & 127\*(C'\fR gives which signal, if any, tha process died
from, n' \f(CW\*(C`$? & 128\*(C'\fR reports whether there was a cold-ass lil core dump.
.Sp
Additionally, if tha \f(CW\*(C`h_errno\*(C'\fR variable is supported up in C, its value
is returned via \f(CW$?\fR if any \f(CW\*(C`gethost*()\*(C'\fR function fails.
.Sp
If you have installed a signal handlez fo' \f(CW\*(C`SIGCHLD\*(C'\fR, the
value of \f(CW$?\fR will probably be wack outside dat handlez.
.Sp
Inside a \f(CW\*(C`END\*(C'\fR subroutine \f(CW$?\fR gotz nuff tha value dat is goin ta be
given ta \f(CW\*(C`exit()\*(C'\fR.  Yo ass can modify \f(CW$?\fR up in a \f(CW\*(C`END\*(C'\fR subroutine to
change tha exit statuz of yo' program.  For example:
.Sp
.Vb 3
\&    END {
\&        $? = 1 if $? == 255;  # take a thugged-out dirtnap would make it 255
\&    }
.Ve
.Sp
Under \s-1VMS,\s0 tha pragma \f(CW\*(C`use vmsish \*(Aqstatus\*(Aq\*(C'\fR make \f(CW$?\fR reflect the
actual \s-1VMS\s0 exit status, instead of tha default emulation of \s-1POSIX\s0
status; peep \*(L"$?\*(R" up in perlvms fo' details.
.Sp
Mnemonic: similar ta \fBsh\fR n' \fBksh\fR.
.ie n .IP "$EVAL_ERROR" 8
.el .IP "\f(CW$EVAL_ERROR\fR" 8
.IX Item "$EVAL_ERROR"
.PD 0
.IP "$@" 8
.IX Xref "$@ $EVAL_ERROR"
.PD
Da Perl syntax error message from the
last \f(CW\*(C`eval()\*(C'\fR operator. Shiiit, dis aint no joke.  If \f(CW$@\fR is
the null string, tha last \f(CW\*(C`eval()\*(C'\fR parsed n' executed erectly
(although tha operations you invoked may have failed up in tha normal
fashion).
.Sp
Warnin lyrics is not collected up in dis variable.  Yo ass can, however,
set up a routine ta process warnings by settin \f(CW$SIG{_\|_WARN_\|_}\fR as
busted lyrics bout up in \*(L"%SIG\*(R".
.Sp
Mnemonic: Where was tha syntax error \*(L"at\*(R"?
.SS "Variablez related ta tha interpreta state"
.IX Subsection "Variablez related ta tha interpreta state"
These variablez provide shiznit bout tha current interpreta state.
.ie n .IP "$COMPILING" 8
.el .IP "\f(CW$COMPILING\fR" 8
.IX Item "$COMPILING"
.PD 0
.IP "$^C" 8
.IX Xref "$^C $COMPILING"
.IX Item "$^C"
.PD
Da current value of tha flag associated wit tha \fB\-c\fR switch.
Mainly of use wit \fB\-MO=...\fR ta allow code ta alta its behavior
when bein compiled, like fuckin fo' example ta \f(CW\*(C`AUTOLOAD\*(C'\fR at compile
time rather than normal, deferred loading.  Setting
\&\f(CW\*(C`$^C = 1\*(C'\fR is similar ta callin \f(CW\*(C`B::minus_c\*(C'\fR.
.Sp
This variable was added up in Perl v5.6.0.
.ie n .IP "$DEBUGGING" 8
.el .IP "\f(CW$DEBUGGING\fR" 8
.IX Item "$DEBUGGING"
.PD 0
.IP "$^D" 8
.IX Xref "$^D $DEBUGGING"
.IX Item "$^D"
.PD
Da current value of tha debuggin flags.  May be read or set.  Like its
command-line equivalent, you can use numeric or symbolic joints, eg
\&\f(CW\*(C`$^D = 10\*(C'\fR or \f(CW\*(C`$^D = "st"\*(C'\fR.
.Sp
Mnemonic: value of \fB\-D\fR switch.
.IP "${^ENCODING}" 8
.IX Xref "${^ENCODING}"
.IX Item "${^ENCODING}"
Da \fIobject reference\fR ta tha \f(CW\*(C`Encode\*(C'\fR object dat is used ta convert
the source code ta Unicode.  Thanks ta dis variable yo' Perl script
does not gotta be freestyled up in \s-1UTF\-8. \s0 Default is \fIundef\fR.  Da direct
manipulation of dis variable is highly discouraged.
.Sp
This variable was added up in Perl 5.8.2.
.IP "${^GLOBAL_PHASE}" 8
.IX Xref "${^GLOBAL_PHASE}"
.IX Item "${^GLOBAL_PHASE}"
Da current phase of tha perl interpreter.
.Sp
Possible joints are:
.RS 8
.IP "\s-1CONSTRUCT\s0" 8
.IX Item "CONSTRUCT"
Da \f(CW\*(C`PerlInterpreter*\*(C'\fR is bein constructed via \f(CW\*(C`perl_construct\*(C'\fR.  This
value is mostly there fo' completenizz n' fo' use via the
underlyin C variable \f(CW\*(C`PL_phase\*(C'\fR.  It aint nuthin but not straight-up possible fo' Perl
code ta be executed unless construction of tha interpreta is
finished.
.IP "\s-1START\s0" 8
.IX Item "START"
This is tha global compile-time.  That includes, basically, every
\&\f(CW\*(C`BEGIN\*(C'\fR block executed directly or indirectly from durin the
compile-time of tha top-level program.
.Sp
This phase aint called \*(L"\s-1BEGIN\*(R"\s0 ta avoid mad drama with
\&\f(CW\*(C`BEGIN\*(C'\fR\-blocks, as dem is executed durin compile-time of any
compilation unit, not just tha top-level program.  A new, localised
compile-time entered at run-time, fo' example by constructs as
\&\f(CW\*(C`eval "use SomeModule"\*(C'\fR is not global interpreta phases, and
therefore aren't reflected by \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR.
.IP "\s-1CHECK\s0" 8
.IX Item "CHECK"
Execution of any \f(CW\*(C`CHECK\*(C'\fR blocks.
.IP "\s-1INIT\s0" 8
.IX Item "INIT"
Similar ta \*(L"\s-1CHECK\*(R",\s0 but fo' \f(CW\*(C`INIT\*(C'\fR\-blocks, not \f(CW\*(C`CHECK\*(C'\fR blocks.
.IP "\s-1RUN\s0" 8
.IX Item "RUN"
Da main run-time, i.e. tha execution of \f(CW\*(C`PL_main_root\*(C'\fR.
.IP "\s-1END\s0" 8
.IX Item "END"
Execution of any \f(CW\*(C`END\*(C'\fR blocks.
.IP "\s-1DESTRUCT\s0" 8
.IX Item "DESTRUCT"
Global destruction.
.RE
.RS 8
.Sp
Also note dat there be a no value fo' UNITCHECK-blocks.  Thatz cuz
those is run fo' each compilation unit individually, n' therefore is
not a global interpreta phase.
.Sp
Not every last muthafuckin program has ta go all up in each of tha possible phases yo, but
transizzle from one phase ta another can only happen up in tha order
busted lyrics bout up in tha above list.
.Sp
An example of all of tha phases Perl code can see:
.Sp
.Vb 1
\&    BEGIN { print "compile\-time: ${^GLOBAL_PHASE}\en" }
\&
\&    INIT  { print "init\-time: ${^GLOBAL_PHASE}\en" }
\&
\&    CHECK { print "check\-time: ${^GLOBAL_PHASE}\en" }
\&
\&    {
\&        package Print::Phase;
\&
\&        sub freshly smoked up {
\&            mah ($class, $time) = @_;
\&            return bless \e$time, $class;
\&        }
\&
\&        sub DESTROY {
\&            mah $self = shift;
\&            print "$$self: ${^GLOBAL_PHASE}\en";
\&        }
\&    }
\&
\&    print "run\-time: ${^GLOBAL_PHASE}\en";
\&
\&    mah $runtime = Print::Phase\->new(
\&        "lexical variablez is garbage collected before END"
\&    );
\&
\&    END   { print "end\-time: ${^GLOBAL_PHASE}\en" }
\&
\&    our $destruct = Print::Phase\->new(
\&        "package variablez is garbage collected afta END"
\&    );
.Ve
.Sp
This will print out
.Sp
.Vb 7
\&    compile\-time: START
\&    check\-time: CHECK
\&    init\-time: INIT
\&    run\-time: RUN
\&    lexical variablez is garbage collected before END: RUN
\&    end\-time: END
\&    package variablez is garbage collected afta END: DESTRUCT
.Ve
.Sp
This variable was added up in Perl 5.14.0.
.RE
.IP "$^H" 8
.IX Xref "$^H"
.IX Item "$^H"
\&\s-1WARNING:\s0 This variable is strictly for
internal use only.  Its availability,
behavior, n' contents is subject ta chizzle without notice.
.Sp
This variable gotz nuff compile-time hints fo' tha Perl interpreter n' shit.  At the
end of compilation of a \s-1BLOCK\s0 tha value of dis variable is restored ta the
value when tha interpreta started ta compile tha \s-1BLOCK.\s0
.Sp
When perl begins ta parse any block construct dat serves up a lexical scope
(e.g., eval body, required file, subroutine body, loop body, or conditional
block), tha existin value of \f(CW$^H\fR is saved yo, but its value is left unchanged.
When tha compilation of tha block is completed, it regains tha saved value.
Between tha points where its value is saved n' restored, code that
executes within \s-1BEGIN\s0 blocks is free ta chizzle tha value of \f(CW$^H\fR.
.Sp
This behavior serves up tha semantic of lexical scoping, n' is used in,
for instance, tha \f(CW\*(C`use strict\*(C'\fR pragma.
.Sp
Da contents should be a integer; different bitz of it is used for
different pragmatic flags.  Herez a example:
.Sp
.Vb 1
\&    sub add_100 { $^H |= 0x100 }
\&
\&    sub foo {
\&        BEGIN { add_100() }
\&        bar\->baz($boon);
\&    }
.Ve
.Sp
Consider what tha fuck happens durin execution of tha \s-1BEGIN\s0 block.  At dis point
the \s-1BEGIN\s0 block has already been compiled yo, but tha body of \f(CW\*(C`foo()\*(C'\fR is still
bein compiled. Y'all KNOW dat shit, muthafucka!  Da freshly smoked up value of \f(CW$^H\fR
will therefore be visible only while
the body of \f(CW\*(C`foo()\*(C'\fR is bein compiled.
.Sp
Substitution of \f(CW\*(C`BEGIN { add_100() }\*(C'\fR block with:
.Sp
.Vb 1
\&    BEGIN { require strict; strict\->import(\*(Aqvars\*(Aq) }
.Ve
.Sp
demonstrates how tha fuck \f(CW\*(C`use strict \*(Aqvars\*(Aq\*(C'\fR is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Herez a cold-ass lil conditional
version of tha same lexical pragma:
.Sp
.Vb 3
\&    BEGIN {
\&        require strict; strict\->import(\*(Aqvars\*(Aq) if $condition
\&    }
.Ve
.Sp
This variable was added up in Perl 5.003.
.IP "%^H" 8
.IX Xref "%^H"
.IX Item "%^H"
Da \f(CW\*(C`%^H\*(C'\fR hash serves up tha same scopin semantic as \f(CW$^H\fR.  This makes
it useful fo' implementation of lexically scoped pragmas.  See
perlpragma.
.Sp
When puttin shit tha fuck into \f(CW\*(C`%^H\*(C'\fR, up in order ta avoid conflictin wit other
userz of tha hash there be a cold-ass lil convention regardin which keys ta use.
A module should use only keys dat begin wit tha modulez name (the
name of its main package) n' a \*(L"/\*(R" character n' shit.  For example, a module
\&\f(CW\*(C`Foo::Bar\*(C'\fR should use keys like fuckin \f(CW\*(C`Foo::Bar/baz\*(C'\fR.
.Sp
This variable was added up in Perl v5.6.0.
.IP "${^OPEN}" 8
.IX Xref "${^OPEN}"
.IX Item "${^OPEN}"
An internal variable used by PerlIO.  A strang up in two parts, separated
by a \f(CW\*(C`\e0\*(C'\fR byte, tha straight-up original gangsta part raps bout tha input layers, tha second
part raps bout tha output layers.
.Sp
This variable was added up in Perl v5.8.0.
.ie n .IP "$PERLDB" 8
.el .IP "\f(CW$PERLDB\fR" 8
.IX Item "$PERLDB"
.PD 0
.IP "$^P" 8
.IX Xref "$^P $PERLDB"
.IX Item "$^P"
.PD
Da internal variable fo' debuggin support.  Da meaningz of the
various bits is subject ta chizzle yo, but currently indicate:
.RS 8
.IP "0x01" 6
.IX Item "0x01"
Debug subroutine enter/exit.
.IP "0x02" 6
.IX Item "0x02"
Line-by-line debugging.  Causes \f(CW\*(C`DB::DB()\*(C'\fR subroutine ta be called for
each statement executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Also causes savin source code lines (like
0x400).
.IP "0x04" 6
.IX Item "0x04"
Switch off optimizations.
.IP "0x08" 6
.IX Item "0x08"
Preserve mo' data fo' future interactizzle inspections.
.IP "0x10" 6
.IX Item "0x10"
Keep info bout source lines on which a subroutine is defined.
.IP "0x20" 6
.IX Item "0x20"
Start wit single-step on.
.IP "0x40" 6
.IX Item "0x40"
Use subroutine address instead of name when reporting.
.IP "0x80" 6
.IX Item "0x80"
Report \f(CW\*(C`goto &subroutine\*(C'\fR as well.
.IP "0x100" 6
.IX Item "0x100"
Provide informatizzle \*(L"file\*(R" names fo' evals based on tha place they was compiled.
.IP "0x200" 6
.IX Item "0x200"
Provide informatizzle names ta anonymous subroutines based on tha place they
were compiled.
.IP "0x400" 6
.IX Item "0x400"
Save source code lines tha fuck into \f(CW\*(C`@{"_<$filename"}\*(C'\fR.
.RE
.RS 8
.Sp
Some bits may be relevant at compile-time only, some at
run-time only.  This be a freshly smoked up mechanizzle n' tha details may chizzle.
See also perldebguts.
.RE
.IP "${^TAINT}" 8
.IX Xref "${^TAINT}"
.IX Item "${^TAINT}"
Reflects if taint mode is on or off.  1 fo' on (the program was run with
\&\fB\-T\fR), 0 fo' off, \-1 when only taint warnings is enabled (i.e. with
\&\fB\-t\fR or \fB\-TU\fR).
.Sp
This variable is read-only.
.Sp
This variable was added up in Perl v5.8.0.
.IP "${^UNICODE}" 8
.IX Xref "${^UNICODE}"
.IX Item "${^UNICODE}"
Reflects certain Unicode settingz of Perl.  See perlrun
documentation fo' tha \f(CW\*(C`\-C\*(C'\fR switch fo' mo' shiznit about
the possible joints.
.Sp
This variable is set durin Perl startup n' is thereafta read-only.
.Sp
This variable was added up in Perl v5.8.2.
.IP "${^UTF8CACHE}" 8
.IX Xref "${^UTF8CACHE}"
.IX Item "${^UTF8CACHE}"
This variable controls tha state of tha internal \s-1UTF\-8\s0 offset cachin code.
1 fo' on (the default), 0 fo' off, \-1 ta debug tha cachin code by checking
all its thangs up in dis biatch against linear scans, n' panickin on any discrepancy.
.Sp
This variable was added up in Perl v5.8.9.  It be subject ta chizzle or
removal without notice yo, but is currently used ta avoid recalculatin the
boundariez of multi-byte UTF\-8\-encoded characters.
.IP "${^UTF8LOCALE}" 8
.IX Xref "${^UTF8LOCALE}"
.IX Item "${^UTF8LOCALE}"
This variable indicates whether a \s-1UTF\-8\s0 locale was detected by perl at
startup.  This shiznit is used by perl when itz in
adjust\-utf8ness\-to\-locale mode (as when run wit tha \f(CW\*(C`\-CL\*(C'\fR command-line
switch); peep perlrun fo' mo' info on all dis bullshit.
.Sp
This variable was added up in Perl v5.8.8.
.SS "Deprecated n' removed variables"
.IX Subsection "Deprecated n' removed variables"
Deprecatin a variable announces tha intent of tha perl maintainers to
eventually remove tha variable from tha language.  It may still be
available despite its status.  Usin a thugged-out deprecated variable triggers
a warning.
.PP
Once a variable is removed, its use triggers a error spittin some lyrics ta you
the variable is unsupported.
.PP
See perldiag fo' details bout error lyrics.
.ie n .IP "$OFMT" 8
.el .IP "\f(CW$OFMT\fR" 8
.IX Item "$OFMT"
.PD 0
.IP "$#" 8
.IX Xref "$# $OFMT"
.PD
\&\f(CW$#\fR was a variable dat could be used ta format printed numbers.
Afta a thugged-out deprecation cycle, its magic was removed up in Perl v5.10.0 and
usin it now triggers a warning: \f(CW\*(C`$# is no longer supported\*(C'\fR.
.Sp
This aint tha sigil you use up in front of a array name ta git the
last index, like \f(CW$#array\fR.  Thatz still how tha fuck you git tha last index
of a array up in Perl.  Da two have not a god damn thang ta do wit each other.
.Sp
Deprecated up in Perl 5.
.Sp
Removed up in Perl v5.10.0.
.IP "$*" 8
.IX Xref "$*"
\&\f(CW$*\fR was a variable dat you could use ta enable multiline matching.
Afta a thugged-out deprecation cycle, its magic was removed up in Perl v5.10.0.
Usin it now triggers a warning: \f(CW\*(C`$* is no longer supported\*(C'\fR.
Yo ass should use tha \f(CW\*(C`/s\*(C'\fR n' \f(CW\*(C`/m\*(C'\fR regexp modifiers instead.
.Sp
Deprecated up in Perl 5.
.Sp
Removed up in Perl v5.10.0.
.ie n .IP "$ARRAY_BASE" 8
.el .IP "\f(CW$ARRAY_BASE\fR" 8
.IX Item "$ARRAY_BASE"
.PD 0
.IP "$[" 8
.IX Xref "$[ $ARRAY_BASE"
.PD
This variable stores tha index of tha straight-up original gangsta element up in a array, and
of tha straight-up original gangsta characta up in a substring.  Da default is 0 yo, but you could
theoretically set it ta 1 ta make Perl behave mo' like \fBawk\fR (or Fortran)
when subscriptin n' when evaluatin tha \fIindex()\fR n' \fIsubstr()\fR functions.
.Sp
Az of release 5 of Perl, assignment ta \f(CW$[\fR is treated as a cold-ass lil compiler
directive, n' cannot influence tha behavior of any other file.
(Thatz why you can only assign compile-time constants ta dat shit.)
Its use is highly discouraged.
.Sp
Prior ta Perl v5.10.0, assignment ta \f(CW$[\fR could be peeped from outa lexical
scopes up in tha same file, unlike other compile-time directives (such as
strict).  Usin \fIlocal()\fR on it would bind its value strictly ta a lexical
block.  Now it be always lexically scoped.
.Sp
Az of Perl v5.16.0, it is implemented by tha arybase module.  See
arybase fo' mo' details on its behaviour.
.Sp
Under \f(CW\*(C`use v5.16\*(C'\fR, or \f(CW\*(C`no feature "array_base"\*(C'\fR, \f(CW$[\fR no longer has any
effect, n' always gotz nuff 0.  Assignin 0 ta it is permitted yo, but any
other value will produce a error.
.Sp
Mnemonic: [ begins subscripts.
.Sp
Deprecated up in Perl v5.12.0.
.ie n .IP "$OLD_PERL_VERSION" 8
.el .IP "\f(CW$OLD_PERL_VERSION\fR" 8
.IX Item "$OLD_PERL_VERSION"
.PD 0
.IP "$]" 8
.IX Xref "$] $OLD_PERL_VERSION"
.PD
See \*(L"$^V\*(R" fo' a mo' modern representation of tha Perl version dat allows
accurate strang comparisons.
.Sp
Da version + patchlevel / 1000 of tha Perl interpreter n' shit.  This variable
can be used ta determine whether tha Perl interpreta executin a
script is up in tha right range of versions:
.Sp
.Vb 1
\&    warn "No checksumming!\en" if $] < 3.019;
.Ve
.Sp
Da floatin point representation can sometimes lead ta inaccurate
numeric comparisons.
.Sp
See also tha documentation of \f(CW\*(C`use VERSION\*(C'\fR n' \f(CW\*(C`require VERSION\*(C'\fR
for a cold-ass lil convenient way ta fail if tha hustlin Perl interpreta is too old.
.Sp
Mnemonic: Is dis version of perl up in tha right bracket?
