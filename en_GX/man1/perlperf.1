.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPERF 1"
.TH PERLPERF 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlperf \- Perl Performizzle n' Optimization Techniques
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This be a introduction ta tha use of performizzle n' optimization steez
which can be used wit particular reference ta perl programs.  While nuff perl
developers have come from other languages, n' can use they prior knowledge
where appropriate, there be nuff other playas whoz ass might benefit from a gangbangin' few
perl specific pointers.  If you want tha condensed version, like tha best
advice be reppin tha renowned Japanese Samurai, Miyamoto Musashi, whoz ass holla'd:
.PP
.Vb 1
\&    "Do Not Engage up in Useless Activity"
.Ve
.PP
in 1645.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Perhaps da most thugged-out common fuck up programmers make is ta attempt ta optimize
their code before a program straight-up do anythang useful \- dis be a wack idea.
Therez no point up in havin a mad fast program dat don't work.  The
first thang is ta git a program ta \fIcorrectly\fR do suttin' \fBuseful\fR, (not to
mention ensurin tha test suite is straight-up functional), n' only then ta consider
optimizin dat shit.  Havin decided ta optimize existin hustlin code, there are
several simple but essential steps ta consider which is intrinsic ta any
optimization process.
.SS "\s-1ONE STEP SIDEWAYS\s0"
.IX Subsection "ONE STEP SIDEWAYS"
Firstly, you need ta establish a funky-ass baseline time fo' tha existin code, which
timin need ta be reliable n' repeatable.  You'll probably wanna use the
\&\f(CW\*(C`Benchmark\*(C'\fR or \f(CW\*(C`Devel::NYTProf\*(C'\fR modules, or suttin' similar, fo' dis step,
or like tha Unix system \f(CW\*(C`time\*(C'\fR utility, whichever be appropriate.  See the
base of dis document fo' a longer list of benchmarkin n' profilin modules,
and recommended further reading.
.SS "\s-1ONE STEP FORWARD\s0"
.IX Subsection "ONE STEP FORWARD"
Next, havin examined tha program fo' \fIhot spots\fR, (places where tha code
seems ta run slowly), chizzle tha code wit tha intention of makin it run
fasta n' shit.  Usin version control software, like \f(CW\*(C`subversion\*(C'\fR, will ensure no
changes is irreversible.  It aint nuthin but too easy as fuck  ta fiddle here n' fiddle there \-
don't chizzle too much at any one time or you might not discover which piece of
code \fBreally\fR was tha slow bit.
.SS "\s-1ANOTHER STEP SIDEWAYS\s0"
.IX Subsection "ANOTHER STEP SIDEWAYS"
It aint nuthin but not enough ta say: \*(L"that will make it run faster\*(R", you gotta check dat shit.
Rerun tha code under control of tha benchmarkin or profilin modules, from the
first step above, n' check dat tha freshly smoked up code executed tha \fBsame task\fR in
\&\fIless time\fR.  Save yo' work n' repeat...
.SH "GENERAL GUIDELINES"
.IX Header "GENERAL GUIDELINES"
Da critical thang when thankin bout performizzle is ta remember there is no such
thang as a \f(CW\*(C`Golden Bullet\*(C'\fR, which is why there be no rules, only guidelines.
.PP
It be clear dat inline code is goin ta be fasta than subroutine or method
calls, cuz there is less overhead yo, but dis approach has tha disadvantage
of bein less maintainable n' comes all up in tha cost of pimped outa memory usage \-
there is no such thang as a gangbangin' free lunch.  If yo ass is searchin fo' a element in
a list, it can be mo' efficient ta store tha data up in a hash structure, and
then simply look ta peep whether tha key is defined, rather than ta loop through
the entire array rockin \fIgrep()\fR fo' instance.  \fIsubstr()\fR may be (a lot) faster
than \fIgrep()\fR but not as flexible, so you have another trade-off ta access.  Your
code may contain a line which takes 0.01 of a second ta execute which if you
call it 1,000 times, like likely up in a program parsin even medium sized files
for instance, you already gotz a 10 second delay, up in just one single code
location, n' if you call dat line 100,000 times, yo' entire program will
slow down ta a unbearable crawl.
.PP
Usin a subroutine as part of yo' sort be a bangin way ta git exactly what
you want yo, but will probably be slower than tha built-in \fIalphabetic\fR \f(CW\*(C`cmp\*(C'\fR and
\&\fInumeric\fR \f(CW\*(C`<=>\*(C'\fR sort operators.  It be possible ta make multiple
passes over yo' data, buildin indices ta make tha upcomin sort more
efficient, n' ta use what tha fuck is known as tha \f(CW\*(C`OM\*(C'\fR (Orcish Maneuver) ta cache the
sort keys up in advance.  Da cache lookup, while a phat idea, can itself be a
source of slowdown by enforcin a thugged-out double pass over tha data \- once ta setup the
cache, n' once ta sort tha data.  Usin \f(CW\*(C`pack()\*(C'\fR ta extract tha required sort
key tha fuck into a cold-ass lil consistent strang can be a efficient way ta build a single string
to compare, instead of rockin multiple sort keys, which make it possible ta use
the standard, freestyled up in \f(CW\*(C`c\*(C'\fR n' fast, perl \f(CW\*(C`sort()\*(C'\fR function on tha output,
and is tha basiz of tha \f(CW\*(C`GRT\*(C'\fR (Guttman Rossla Transform).  Some string
combinations can slow tha \f(CW\*(C`GRT\*(C'\fR down, by just bein too plain complex fo' it's
own good.
.PP
For applications rockin database backends, tha standard \f(CW\*(C`DBIx\*(C'\fR namespace has
tries ta help wit keepin thangs nippy, not least cuz it tries ta \fInot\fR
query tha database until tha sickest fuckin possible moment yo, but always read tha docs
which come wit yo' chizzle of libraries. Put ya muthafuckin choppers up if ya feel dis!  Among tha nuff thangs facing
developers dealin wit databases should remain aware of is ta always use
\&\f(CW\*(C`SQL\*(C'\fR placeholdaz n' ta consider pre-fetchin data sets when dis might
prove advantageous.  Splittin up a big-ass file by assignin multiple processes
to parsin a single file, rockin say \f(CW\*(C`POE\*(C'\fR, \f(CW\*(C`threads\*(C'\fR or \f(CW\*(C`fork\*(C'\fR can also be a
useful way of optimizin yo' usage of tha available \f(CW\*(C`CPU\*(C'\fR resources, though
this technique is fraught wit concurrency thangs n' demandz high attention to
detail.
.PP
Every case has a specific application n' one or mo' exceptions, n' there is
no replacement fo' hustlin all dem tests n' findin up which method works best
for yo' particular environment, dis is why freestylin optimal code aint an
exact science, n' why our slick asses ludd rockin Perl so much \- \s-1TMTOWTDI.\s0
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Here is all dem examplez ta demonstrate usage of Perlz benchmarkin tools.
.SS "Assignin n' Dereferencin Variables."
.IX Subsection "Assignin n' Dereferencin Variables."
I be shizzle most of our asses have peeped code which looks like, (or worse than), this:
.PP
.Vb 2
\&    if ( $obj\->{_ref}\->{_myscore} >= $obj\->{_ref}\->{_yourscore} ) {
\&        ...
.Ve
.PP
This sort of code can be a real eyesore ta read, as well as bein hella
sensitizzle ta typos, n' itz much clearer ta dereference tha variable
explicitly.  We side-steppin tha issue of hustlin wit object-oriented
programmin steez ta encapsulate variable access via methods, only
accessible all up in a object.  Here our laid-back asses just discussin tha technical
implementation of chizzle, n' whether dis has a effect on performance.  We
can peep whether dis dereferencin operation, has any overhead by putting
comparatizzle code up in a gangbangin' file n' hustlin a \f(CW\*(C`Benchmark\*(C'\fR test.
.PP
# dereference
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    mah $ref = {
\&            \*(Aqref\*(Aq   => {
\&                _myscore    => \*(Aq100 + 1\*(Aq,
\&                _yourscore  => \*(Aq102 \- 1\*(Aq,
\&            },
\&    };
\&
\&    timethese(1000000, {
\&            \*(Aqdirect\*(Aq       => sub {
\&                mah $x = $ref\->{ref}\->{_myscore} . $ref\->{ref}\->{_yourscore} ;
\&            },
\&            \*(Aqdereference\*(Aq  => sub {
\&                mah $ref  = $ref\->{ref};
\&                mah $myscore = $ref\->{_myscore};
\&                mah $yourscore = $ref\->{_yourscore};
\&                mah $x = $myscore . $yourscore;
\&            },
\&    });
.Ve
.PP
It aint nuthin but essential ta run any timin measurements a sufficient number of times so
the numbers settle on a numerical average, otherwise each run will naturally
fluctuate cuz of variations up in tha environment, ta reduce tha effect of
contention fo' \f(CW\*(C`CPU\*(C'\fR resources n' network bandwidth fo' instance.  Running
the above code fo' one mazillion iterations, we can take a peep tha report
output by tha \f(CW\*(C`Benchmark\*(C'\fR module, ta peep which approach is da most thugged-out effective.
.PP
.Vb 1
\&    $> perl dereference
\&
\&    Benchmark: timin 1000000 iterationz of dereference, direct...
\&    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
\&        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)
.Ve
.PP
Da difference is clear ta peep n' tha dereferencin approach is slower n' shit.  While
it managed ta execute a average of 628,930 times a second durin our test, the
direct approach managed ta run a additionizzle 204,403 times, unfortunately.
Unfortunately, cuz there be nuff examplez of code freestyled rockin the
multiple layer direct variable access, n' itz probably horrible.  It is,
however, minusculy fasta n' shit.  Da question remains whether tha minute bust is
actually worth tha eyestrain, or tha loss of maintainability.
.SS "Search n' replace or tr"
.IX Subsection "Search n' replace or tr"
If our crazy asses gotz a strang which need ta be modified, while a regex will almost
always be much mo' flexible, \f(CW\*(C`tr\*(C'\fR, a oft underused tool, can still be a
useful naaahhmean?  One scenario might be replace all vowels wit another character n' shit.  The
regex solution might be lookin like this:
.PP
.Vb 1
\&    $str =~ s/[aeiou]/x/g
.Ve
.PP
Da \f(CW\*(C`tr\*(C'\fR alternatizzle might be lookin like this:
.PP
.Vb 1
\&    $str =~ tr/aeiou/xxxxx/
.Ve
.PP
We can put dat tha fuck into a test file which we can run ta check which approach is
the fastest, rockin a global \f(CW$STR\fR variable ta assign ta tha \f(CW\*(C`my $str\*(C'\fR
variable so as ta avoid perl tryin ta optimize any of tha work away by
noticin itz assigned only tha once.
.PP
# regex-transliterate
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    mah $STR = "$$\-this n' that";
\&
\&    timethese( 1000000, {
\&            \*(Aqsr\*(Aq  => sub { mah $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
\&            \*(Aqtr\*(Aq  => sub { mah $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
\&    });
.Ve
.PP
Hustlin tha code gives our asses our thangs up in dis biatch:
.PP
.Vb 1
\&    $> perl regex\-transliterate
\&
\&    Benchmark: timin 1000000 iterationz of sr, tr...
\&            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
\&            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)
.Ve
.PP
Da \f(CW\*(C`tr\*(C'\fR version be a cold-ass lil clear balla n' shit.  One solution is flexible, tha other is
fast \- n' itz appropriately tha programmerz chizzle which ta use.
.PP
Peep tha \f(CW\*(C`Benchmark\*(C'\fR docs fo' further useful steez.
.SH "PROFILING TOOLS"
.IX Header "PROFILING TOOLS"
A slightly larger piece of code will provide suttin' on which a profila can
produce mo' extensive reportin statistics.  This example uses tha simplistic
\&\f(CW\*(C`wordmatch\*(C'\fR program which parses a given input file n' spews up a gangbangin' finger-lickin' dirty-ass short
report on tha contents.
.PP
# wordmatch
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    =head1 NAME
\&
\&    filewordz \- word analysiz of input file
\&
\&    =head1 SYNOPSIS
\&
\&        filewordz \-f inputfilename [\-d]
\&
\&    =head1 DESCRIPTION
\&
\&    This program parses tha given filename, specified wit C<\-f>, n' displays a
\&    simple analysiz of tha lyrics found therein. I aint talkin' bout chicken n' gravy biatch.  Use tha C<\-d> switch ta enable
\&    debuggin lyrics.
\&
\&    =cut
\&
\&    use FileHandle;
\&    use Getopt::Long;
\&
\&    mah $debug   =  0;
\&    mah $file    = \*(Aq\*(Aq;
\&
\&    mah $result = GetOptions (
\&        \*(Aqdebug\*(Aq         => \e$debug,
\&        \*(Aqfile=s\*(Aq        => \e$file,
\&    );
\&    die("invalid args") unless $result;
\&
\&    unless ( \-f $file ) {
\&        die("Usage: $0 \-f filename [\-d]");
\&    }
\&    mah $FH = FileHandle\->new("< $file") or die("unable ta open file($file): $!");
\&
\&    mah $i_LINES = 0;
\&    mah $i_WORDS = 0;
\&    mah %count   = ();
\&
\&    mah @lines = <$FH>;
\&    foreach mah $line ( @lines ) {
\&        $i_LINES++;
\&        $line =~ s/\en//;
\&        mah @wordz = split(/ +/, $line);
\&        mah $i_wordz = scalar(@words);
\&        $i_WORDS = $i_WORDS + $i_words;
\&        debug("line: $i_LINES supplyin $i_wordz lyrics: @words");
\&        mah $i_word = 0;
\&        foreach mah $word ( @wordz ) {
\&            $i_word++;
\&            $count{$i_LINES}{spec} += matches($i_word, $word, \*(Aq[^a\-zA\-Z0\-9]\*(Aq);
\&            $count{$i_LINES}{only} += matches($i_word, $word, \*(Aq^[^a\-zA\-Z0\-9]+$\*(Aq);
\&            $count{$i_LINES}{cons} += matches($i_word, $word, \*(Aq^[(?i:bcdfghjklmnpqrstvwxyz)]+$\*(Aq);
\&            $count{$i_LINES}{vows} += matches($i_word, $word, \*(Aq^[(?i:aeiou)]+$\*(Aq);
\&            $count{$i_LINES}{caps} += matches($i_word, $word, \*(Aq^[(A\-Z)]+$\*(Aq);
\&        }
\&    }
\&
\&    print report( %count );
\&
\&    sub matches {
\&        mah $i_wd  = shift;
\&        mah $word  = shift;
\&        mah $regex = shift;
\&        mah $has = 0;
\&
\&        if ( $word =~ /($regex)/ ) {
\&            $has++ if $1;
\&        }
\&
\&        debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&
\&        return $has;
\&    }
\&
\&    sub report {
\&        mah %report = @_;
\&        mah %rep;
\&
\&        foreach mah $line ( keys %report ) {
\&            foreach mah $key ( keys %{ $report{$line} } ) {
\&                $rep{$key} += $report{$line}{$key};
\&            }
\&        }
\&
\&        mah $report = qq|
\&    $0 report fo' $file:
\&    lines up in file: $i_LINES
\&    lyrics up in file: $i_WORDS
\&    lyrics wit special (non\-word) characters: $i_spec
\&    lyrics wit only special (non\-word) characters: $i_only
\&    lyrics wit only consonants: $i_cons
\&    lyrics wit only capital letters: $i_caps
\&    lyrics wit only vowels: $i_vows
\&    |;
\&
\&        return $report;
\&    }
\&
\&    sub debug {
\&        mah $message = shift;
\&
\&        if ( $debug ) {
\&            print STDERR "DBG: $message\en";
\&        }
\&    }
\&
\&    exit 0;
.Ve
.SS "Devel::DProf"
.IX Subsection "Devel::DProf"
This venerable module has been tha de-facto standard fo' Perl code profiling
for mo' than a thugged-out decade yo, but has been replaced by a fuckin shitload of other modules
which have brought our asses back ta tha 21st century.  Although you recommended to
evaluate yo' tool from tha nuff muthafuckin mentioned here n' from tha \s-1CPAN\s0 list at
the base of dis document, (and currently Devel::NYTProf seems ta be the
weapon of chizzle \- peep below), we'll take a quick peep tha output from
Devel::DProf first, ta set a funky-ass baseline fo' Perl profilin tools.  Run the
above program under tha control of \f(CW\*(C`Devel::DProf\*(C'\fR by rockin tha \f(CW\*(C`\-d\*(C'\fR switch on
the command-line.
.PP
.Vb 1
\&    $> perl \-d:DProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report fo' perl5db.pl:
\&    lines up in file: 9428
\&    lyrics up in file: 50243
\&    lyrics wit special (non\-word) characters: 20480
\&    lyrics wit only special (non\-word) characters: 7790
\&    lyrics wit only consonants: 4801
\&    lyrics wit only capital letters: 1316
\&    lyrics wit only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::DProf\*(C'\fR produces a special file, called \fItmon.out\fR by default, and
this file is read by tha \f(CW\*(C`dprofpp\*(C'\fR program, which be already installed as part
of tha \f(CW\*(C`Devel::DProf\*(C'\fR distribution. I aint talkin' bout chicken n' gravy biatch.  If you call \f(CW\*(C`dprofpp\*(C'\fR wit no options,
it will read tha \fItmon.out\fR file up in tha current directory n' produce a human
readable statistics report of tha run of yo' program.  Note dat dis may take
a lil time.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time = 2.951677 Seconds
\&      User+System Time = 2.871677 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
\&     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
\&     1.74   0.050  0.050      1   0.0500 0.0500  main::report
\&     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
\&     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
\&     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::FindOption
\&     0.00       \- \-0.000      1        \-      \-  Symbol::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  warnings::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  IO::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::ConfigDefaults
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::Configure
\&     0.00       \- \-0.000      1        \-      \-  Symbol::gensym
.Ve
.PP
\&\f(CW\*(C`dprofpp\*(C'\fR will produce some like detailed reportin on tha activitizzle of the
\&\f(CW\*(C`wordmatch\*(C'\fR program.  Da wallclock, user n' system, times is all up in tha top of
the analysis, n' afta dis is tha main columns definin which define the
report.  Peep tha \f(CW\*(C`dprofpp\*(C'\fR docs fo' detailz of tha nuff options it supports.
.PP
See also \f(CW\*(C`Apache::DProf\*(C'\fR which hooks \f(CW\*(C`Devel::DProf\*(C'\fR tha fuck into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::Profiler"
.IX Subsection "Devel::Profiler"
Letz take a peep tha same program rockin a gangbangin' finger-lickin' different profiler:
\&\f(CW\*(C`Devel::Profiler\*(C'\fR, a thugged-out drop-in Perl-only replacement fo' \f(CW\*(C`Devel::DProf\*(C'\fR.  The
usage is straight-up slightly different up in dat instead of rockin tha special \f(CW\*(C`\-d:\*(C'\fR
flag, you pull \f(CW\*(C`Devel::Profiler\*(C'\fR up in directly as a module rockin \f(CW\*(C`\-M\*(C'\fR.
.PP
.Vb 1
\&    $> perl \-MDevel::Profila wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report fo' perl5db.pl:
\&    lines up in file: 9428
\&    lyrics up in file: 50243
\&    lyrics wit special (non\-word) characters: 20480
\&    lyrics wit only special (non\-word) characters: 7790
\&    lyrics wit only consonants: 4801
\&    lyrics wit only capital letters: 1316
\&    lyrics wit only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::Profiler\*(C'\fR generates a tmon.out file which is compatible wit the
\&\f(CW\*(C`dprofpp\*(C'\fR program, thus savin tha construction of a thugged-out dedicated statistics
reader program.  \f(CW\*(C`dprofpp\*(C'\fR usage is therefore identical ta tha above example.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time =   20.984 Seconds
\&      User+System Time =   19.981 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
\&     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
\&     0.25   0.049  0.049      1   0.0490 0.0490  main::report
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
\&     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open
.Ve
.PP
Interestingly we git slightly different thangs up in dis biatch, which is mostly cuz the
algorithm which generates tha report is different, even though tha output file
format was allegedly identical. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da elapsed, user n' system times is clearly
showin tha time it took fo' \f(CW\*(C`Devel::Profiler\*(C'\fR ta execute its own run yo, but
the column listings feel mo' accurate somehow than tha ones our crazy asses had earlier
from \f(CW\*(C`Devel::DProf\*(C'\fR.  Da 102% figure has disappeared, fo' example.  This is
where we gotta use tha tools at our disposal, n' recognise they pros and
cons, before rockin em.  Interestingly, tha numberz of calls fo' each
subroutine is identical up in tha two reports, itz tha cementages which differ.
As tha lyricist of \f(CW\*(C`Devel::Proviler\*(C'\fR writes:
.PP
.Vb 5
\&    ...runnin HTML::Template\*(Aqs test suite under Devel::DProf shows output()
\&    takin NO time but Devel::Profila shows round 10% of tha time is up in output().
\&    I don\*(Aqt know which ta trust but mah gut  drops some lyrics ta me suttin' is wack with
\&    Devel::DProf.  HTML::Template::output() be a funky-ass big-ass routine that\*(Aqs called for
\&    every last muthafuckin test. Either way, suttin' needz fixing.
.Ve
.PP
\&\s-1YMMV.\s0
.PP
See also \f(CW\*(C`Devel::Apache::Profiler\*(C'\fR which hooks \f(CW\*(C`Devel::Profiler\*(C'\fR tha fuck into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::SmallProf"
.IX Subsection "Devel::SmallProf"
Da \f(CW\*(C`Devel::SmallProf\*(C'\fR profila examines tha runtime of yo' Perl program and
produces a line-by-line listin ta show how tha fuck nuff times each line was called,
and how tha fuck long each line took ta execute.  It be called by supplyin tha familiar
\&\f(CW\*(C`\-d\*(C'\fR flag ta Perl at runtime.
.PP
.Vb 1
\&    $> perl \-d:SmallProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report fo' perl5db.pl:
\&    lines up in file: 9428
\&    lyrics up in file: 50243
\&    lyrics wit special (non\-word) characters: 20480
\&    lyrics wit only special (non\-word) characters: 7790
\&    lyrics wit only consonants: 4801
\&    lyrics wit only capital letters: 1316
\&    lyrics wit only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR writes itz output tha fuck into a gangbangin' file called \fIsmallprof.out\fR, by
default.  Da format of tha file be lookin like this:
.PP
.Vb 1
\&    <num> <time> <ctime> <line>:<text>
.Ve
.PP
When tha program has terminated, tha output may be examined n' sorted using
any standard text filterin utilities. Put ya muthafuckin choppers up if ya feel dis!  Somethang like tha followin may be
sufficient:
.PP
.Vb 1
\&    $> pussaaaaay smallprof.out | grep \ed*: | sort \-k3 | tac | head \-n20
\&
\&    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
\&    251215   0.03264   4.40000    79: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq :
\&    251215   0.02693   4.10000    81: return $has;
\&    260643   0.02841   4.07000   128: if ( $debug ) {
\&    260643   0.02601   4.04000   126: mah $message = shift;
\&    251215   0.02641   3.91000    73: mah $has = 0;
\&    251215   0.03311   3.71000    70: mah $i_wd  = shift;
\&    251215   0.02699   3.69000    72: mah $regex = shift;
\&    251215   0.02766   3.68000    71: mah $word  = shift;
\&     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
\&     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
\&     50243   0.00644   0.89000    56:  mah $i_cons = matches($i_word, $word,
\&     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
\&     50243   0.00516   0.88000    58:  mah $i_caps = matches($i_word, $word, \*(Aq^[(A\-
\&     50243   0.00631   0.81000    54:  mah $i_spec = matches($i_word, $word, \*(Aq[^a\-
\&     50243   0.00496   0.80000    57:  mah $i_vows = matches($i_word, $word,
\&     50243   0.00688   0.80000    53:  $i_word++;
\&     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
\&     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
\&     50243   0.00683   0.75000    55:  mah $i_only = matches($i_word, $word, \*(Aq^[^a\-
.Ve
.PP
Yo ass can immediately peep a slightly different focus ta tha subroutine profiling
modules, n' we start ta peep exactly which line of code is takin da most thugged-out
time.  That regex line is lookin a lil' bit suspicious, fo' example.  Remember that
these tools is supposed ta be used together, there is no single dopest way to
profile yo' code, you need ta use tha dopest tools fo' tha thang.
.PP
See also \f(CW\*(C`Apache::SmallProf\*(C'\fR which hooks \f(CW\*(C`Devel::SmallProf\*(C'\fR tha fuck into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::FastProf"
.IX Subsection "Devel::FastProf"
\&\f(CW\*(C`Devel::FastProf\*(C'\fR be another Perl line profila n' shit.  This was freestyled wit a view
to gettin a gangbangin' fasta line profiler, than is possible wit fo' example
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR, cuz itz freestyled up in \f(CW\*(C`C\*(C'\fR.  To use \f(CW\*(C`Devel::FastProf\*(C'\fR,
supply tha \f(CW\*(C`\-d\*(C'\fR argument ta Perl:
.PP
.Vb 1
\&    $> perl \-d:FastProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report fo' perl5db.pl:
\&    lines up in file: 9428
\&    lyrics up in file: 50243
\&    lyrics wit special (non\-word) characters: 20480
\&    lyrics wit only special (non\-word) characters: 7790
\&    lyrics wit only consonants: 4801
\&    lyrics wit only capital letters: 1316
\&    lyrics wit only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::FastProf\*(C'\fR writes statistics ta tha file \fIfastprof.out\fR up in tha current
directory.  Da output file, which can be specified, can be interpreted by using
the \f(CW\*(C`fprofpp\*(C'\fR command-line program.
.PP
.Vb 1
\&    $> fprofpp | head \-n20
\&
\&    # fprofpp output format is:
\&    # filename:line time count: source
\&    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
\&    wordmatch:79 1.77774 251215: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&    wordmatch:81 1.47604 251215: return $has;
\&    wordmatch:126 1.43441 260643: mah $message = shift;
\&    wordmatch:128 1.42156 260643: if ( $debug ) {
\&    wordmatch:70 1.36824 251215: mah $i_wd  = shift;
\&    wordmatch:71 1.36739 251215: mah $word  = shift;
\&    wordmatch:72 1.35939 251215: mah $regex = shift;
.Ve
.PP
Straightaway we can peep dat tha number of times each line has been called is
identical ta tha \f(CW\*(C`Devel::SmallProf\*(C'\fR output, n' tha sequence is only hella
slightly different based on tha orderin of tha amount of time each line took
to execute, \f(CW\*(C`if ( $debug ) { \*(C'\fR n' \f(CW\*(C`my $message = shift;\*(C'\fR, fo' example.  The
differences up in tha actual times recorded might be up in tha algorithm used
internally, or it could be cuz of system resource limitations or contention.
.PP
See also tha DBIx::Flava which will flava database queries hustlin
under tha \f(CW\*(C`DBIx::*\*(C'\fR namespace.
.SS "Devel::NYTProf"
.IX Subsection "Devel::NYTProf"
\&\f(CW\*(C`Devel::NYTProf\*(C'\fR is tha \fBnext generation\fR of Perl code profiler, fixin many
shortcomings up in other tools n' implementin nuff def features.  First of all it
can be used as either a \fIline\fR profiler, a \fIblock\fR or a \fIsubroutine\fR
profiler, all at once.  It can also use sub-microsecond (100ns) resolution on
systems which provide \f(CW\*(C`clock_gettime()\*(C'\fR.  It can be started n' stopped even
by tha program bein profiled. Y'all KNOW dat shit, muthafucka!  It aint nuthin but a one-line entry ta flava \f(CW\*(C`mod_perl\*(C'\fR
applications.  It aint nuthin but freestyled up in \f(CW\*(C`c\*(C'\fR n' is probably tha fastest profiler
available fo' Perl.  Da list of coolnizz just goes on. I aint talkin' bout chicken n' gravy biatch.  Enough of that, let's
see how tha fuck ta it works \- just use tha familiar \f(CW\*(C`\-d\*(C'\fR switch ta plug it up in n' run
the code.
.PP
.Vb 1
\&    $> perl \-d:NYTProf wordmatch \-f perl5db.pl
\&
\&    wordmatch report fo' perl5db.pl:
\&    lines up in file: 9427
\&    lyrics up in file: 50243
\&    lyrics wit special (non\-word) characters: 20480
\&    lyrics wit only special (non\-word) characters: 7790
\&    lyrics wit only consonants: 4801
\&    lyrics wit only capital letters: 1316
\&    lyrics wit only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`NYTProf\*(C'\fR will generate a report database tha fuck into tha file \fInytprof.out\fR by
default.  Human readable reports can be generated from here by rockin the
supplied \f(CW\*(C`nytprofhtml\*(C'\fR (\s-1HTML\s0 output) n' \f(CW\*(C`nytprofcsv\*(C'\fR (\s-1CSV\s0 output) programs.
We've used tha Unix system \f(CW\*(C`html2text\*(C'\fR utilitizzle ta convert the
\&\fInytprof/index.html\fR file fo' convenience here.
.PP
.Vb 1
\&    $> html2text nytprof/index.html
\&
\&    Performizzle Flava Index
\&    For wordmatch
\&      Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:23 2008
\&
\&             Top 15 Subroutines \-\- ordered by exclusive time
\&    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
\&    |      |  |  |Time     |Time     |                                    |
\&    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
\&    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
\&    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
\&    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
\&    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
\&    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
\&    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
\&    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
\&    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
\&    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
\&    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
\&    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
\&    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
\&    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
\&    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |
\&
\&    For mo' shiznit peep tha full list of 189 subroutines.
.Ve
.PP
Da first part of tha report already shows tha critical shiznit regarding
which subroutines is rockin da most thugged-out time.  Da next gives some statistics
about tha source filez profiled.
.PP
.Vb 10
\&            Source Code Filez \-\- ordered by exclusive time then name
\&    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
\&    |       |Time     |       |                            |                    |
\&    |2699761|15.66654 |6e\-06  |line   .    block   .    sub|wordmatch           |
\&    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
\&    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
\&    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
\&    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
\&    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
\&    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
\&    |323    |0.00248  |8e\-06  |line   .    block   .    sub|constant.pm         |
\&    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
\&    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
\&    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
\&    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
\&    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
\&    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
\&    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
\&    |198    |0.00085  |4e\-06  |line   .    block   .    sub|warnings/register.pm|
\&    |114    |0.00080  |7e\-06  |line   .    block   .    sub|strict.pm           |
\&    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
\&    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
\&    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
\&    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
\&    |2701595|15.73869 |       |Total                       |
\&    |128647 |0.74946  |       |Average                     |
\&    |       |0.00201  |0.00003|Median                      |
\&    |       |0.00121  |0.00003|Deviation                   |
\&
\&    Report produced by tha NYTProf 2.03 Perl profiler, pimped by Slim Tim Bunce and
\&    Adam Kaplan.
.Ve
.PP
At dis point, if you rockin tha \fIhtml\fR report, you can click all up in the
various links ta bore down tha fuck into each subroutine n' each line of code.  Because
we're rockin tha text reportin here, n' there be a a whole directory full of
reports built fo' each source file, we'll just display a part of the
correspondin \fIwordmatch\-line.html\fR file, sufficient ta give a scam of the
sort of output you can expect from dis def tool.
.PP
.Vb 1
\&    $> html2text nytprof/wordmatch\-line.html
\&
\&    Performizzle Flava \-\- \-block view\-.\-line view\-.\-sub view\-
\&    For wordmatch
\&    Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:22 2008
\&
\&    File wordmatch
\&
\&     Subroutines \-\- ordered by exclusive time
\&    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
\&    |      | | |Time     |Time     |              |
\&    |251215|5|1|13.09263 |10.47692 |main::|matches|
\&    |260642|2|1|2.71199  |2.71199  |main::|debug  |
\&    |1     |1|1|0.21404  |0.21404  |main::|report |
\&    |0     |0|0|0        |0        |main::|BEGIN  |
\&
\&
\&    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
\&    |    |      |Time     |       |                                               |
\&    |1   |      |         |       |#!/usr/bin/perl                                |
\&    |2   |      |         |       |                                               |
\&    |    |      |         |       |use strict;                                    |
\&    |3   |3     |0.00086  |0.00029|# dropped 0.00003s makin 1 calls ta strict::    |
\&    |    |      |         |       |import                                         |
\&    |    |      |         |       |use warnings;                                  |
\&    |4   |3     |0.01563  |0.00521|# dropped 0.00012s makin 1 calls ta warnings::  |
\&    |    |      |         |       |import                                         |
\&    |5   |      |         |       |                                               |
\&    |6   |      |         |       |=head1 NAME                                    |
\&    |7   |      |         |       |                                               |
\&    |8   |      |         |       |filewordz \- word analysiz of input file        |
\&    <...snip...>
\&    |62  |1     |0.00445  |0.00445|print report( %count );                        |
\&    |    |      |         |       |# dropped 0.21404s makin 1 calls ta main::report|
\&    |63  |      |         |       |                                               |
\&    |    |      |         |       |# dropped 23.56955s (10.47692+2.61571) within    |
\&    |    |      |         |       |main::matches which was called 251215 times,   |
\&    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
\&    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
\&    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
\&    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
\&    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
\&    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
\&    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
\&    |    |      |         |       |sub matches {                                  |
\&    <...snip...>
\&    |102 |      |         |       |                                               |
\&    |    |      |         |       |# dropped 2.71199s within main::debug which was  |
\&    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
\&    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
\&    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
\&    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
\&    |    |      |         |       |0.00001s/call                                  |
\&    |    |      |         |       |sub debug {                                    |
\&    |104 |260642|0.58496  |2e\-06  |my $message = shift;                           |
\&    |105 |      |         |       |                                               |
\&    |106 |260642|1.09917  |4e\-06  |if ( $debug ) {                                |
\&    |107 |      |         |       |print STDERR "DBG: $message\en";                |
\&    |108 |      |         |       |}                                              |
\&    |109 |      |         |       |}                                              |
\&    |110 |      |         |       |                                               |
\&    |111 |1     |0.01501  |0.01501|exit 0;                                        |
\&    |112 |      |         |       |                                               |
.Ve
.PP
Oodlez of straight-up useful shiznit up in there \- dis seems ta be tha way forward.
.PP
See also \f(CW\*(C`Devel::NYTProf::Apache\*(C'\fR which hooks \f(CW\*(C`Devel::NYTProf\*(C'\fR tha fuck into \f(CW\*(C`mod_perl\*(C'\fR.
.SH "SORTING"
.IX Header "SORTING"
Perl modulez is not tha only tools a performizzle analyst has at their
disposal, system tools like \f(CW\*(C`time\*(C'\fR should not be overlooked as tha next
example shows, where we take a quick peep sorting.  Many books, theses and
articles, done been freestyled bout efficient sortin algorithms, n' dis is not
the place ta repeat such work, there be a nuff muthafuckin phat sortin modulez which
deserve takin a peep too: \f(CW\*(C`Sort::Maker\*(C'\fR, \f(CW\*(C`Sort::Key\*(C'\fR sprang ta mind.
But fuck dat shiznit yo, tha word on tha street is dat itz still possible ta cook up some fuckin observations on certain Perl specific
interpretations on thangs relatin ta sortin data sets n' give a example or
two wit regard ta how tha fuck sortin big-ass data volumes can effect performance.
Firstly, a often overlooked point when sortin big-ass amountz of data, one can
attempt ta reduce tha data set ta be dealt wit n' up in nuff cases \f(CW\*(C`grep()\*(C'\fR can
be like useful as a simple filter:
.PP
.Vb 1
\&    @data = sort grep { /$filter/ } @incoming
.Ve
.PP
A command like fuckin dis can vastly reduce tha volume of material ta actually
sort all up in in tha straight-up original gangsta place, n' should not be too lightly disregarded
purely on tha basiz of its simplicity.  Da \f(CW\*(C`KISS\*(C'\fR principle is too often
overlooked \- tha next example uses tha simple system \f(CW\*(C`time\*(C'\fR utilitizzle to
demonstrate.  Letz take a peep a actual example of sortin tha contents of
a big-ass file, a apache logfile would do.  This one has over a quarta of a
mazillion lines, is 50M up in size, n' a snippet of it be lookin like this:
.PP
# logfile
.PP
.Vb 10
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:41 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:42 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:43 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:15 +0000] "GET / HTTP/1.1" 304 \- "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:16 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:48 +0000] "GET / HTTP/1.0" 200 3309 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:58 +0000] "GET /data/css HTTP/1.0" 404 206 "http://www.rfi.net/" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:59 +0000] "GET /favicon.ico HTTP/1.0" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:27:57 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "voyager/1.0"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:28:25 +0000] "GET /links.html HTTP/1.0" 200 3413 "\-" "voyager/1.0"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:32 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:34 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:35 +0000] "GET / HTTP/1.1" 200 3309 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:37 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    pop.compuscan.co.za \- \- [08/Feb/2007:14:10:43 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /html/oracle.html HTTP/1.0" 404 214 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    dslb\-088\-064\-005\-154.pools.arcor\-ip.net \- \- [08/Feb/2007:14:12:15 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    196.201.92.41 \- \- [08/Feb/2007:14:15:01 +0000] "GET / HTTP/1.1" 200 3309 "\-" "MOT\-L7/08.B7.DCR MIB/2.2.1 Profile/MIDP\-2.0 Configuration/CLDC\-1.1"
.Ve
.PP
Da specific task here is ta sort tha 286,525 linez of dis file by Response
Code, Query, Browser, Referrin Url, n' lastly Date.  One solution might be to
use tha followin code, which iterates over tha filez given on the
command-line.
.PP
# sort-apache-log
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    mah @data;
\&
\&    LINE:
\&    while ( <> ) {
\&        mah $line = $_;
\&        if (
\&            $line =~ m/^(
\&                ([\ew\e.\e\-]+)             # client
\&                \es*\-\es*\-\es*\e[
\&                ([^]]+)                 # date
\&                \e]\es*"\ew+\es*
\&                (\eS+)                   # query
\&                [^"]+"\es*
\&                (\ed+)                   # status
\&                \es+\eS+\es+"[^"]*"\es+"
\&                ([^"]*)                 # browser
\&                "
\&                .*
\&            )$/x
\&        ) {
\&            mah @chunks = split(/ +/, $line);
\&            mah $ip      = $1;
\&            mah $date    = $2;
\&            mah $query   = $3;
\&            mah $status  = $4;
\&            mah $browser = $5;
\&
\&            push(@data, [$ip, $date, $query, $status, $browser, $line]);
\&        }
\&    }
\&
\&    mah @sorted = sort {
\&        $a\->[3] cmp $b\->[3]
\&                ||
\&        $a\->[2] cmp $b\->[2]
\&                ||
\&        $a\->[0] cmp $b\->[0]
\&                ||
\&        $a\->[1] cmp $b\->[1]
\&                ||
\&        $a\->[4] cmp $b\->[4]
\&    } @data;
\&
\&    foreach mah $data ( @sorted ) {
\&        print $data\->[5];
\&    }
\&
\&    exit 0;
.Ve
.PP
When hustlin dis program, redirect \f(CW\*(C`STDOUT\*(C'\fR so it is possible ta check the
output is erect from followin test runs n' use tha system \f(CW\*(C`time\*(C'\fR utility
to check tha overall runtime.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log logfile > out\-sort
\&
\&    real    0m17.371s
\&    user    0m15.757s
\&    sys     0m0.592s
.Ve
.PP
Da program took just over 17 wallclock secondz ta run. I aint talkin' bout chicken n' gravy biatch.  Note tha different
values \f(CW\*(C`time\*(C'\fR outputs, itz blingin ta always use tha same one, n' ta not
confuse what tha fuck each one means.
.IP "Elapsed Real Time" 4
.IX Item "Elapsed Real Time"
Da overall, or wallclock, time between when \f(CW\*(C`time\*(C'\fR was called, n' when it
terminates.  Da elapsed time includes both user n' system times, n' time
spent waitin fo' other playas n' processes on tha system.  Inevitably, dis is
da most thugged-out approximate of tha measurements given.
.IP "User \s-1CPU\s0 Time" 4
.IX Item "User CPU Time"
Da user time is tha amount of time tha entire process dropped on behalf of the
user on dis system executin dis program.
.IP "System \s-1CPU\s0 Time" 4
.IX Item "System CPU Time"
Da system time is tha amount of time tha kernel itself dropped executing
routines, or system calls, on behalf of dis process user.
.PP
Hustlin dis same process as a \f(CW\*(C`Schwarzian Transform\*(C'\fR it is possible to
eliminizzle tha input n' output arrays fo' storin all tha data, n' work on the
input directly as it arrives like a muthafucka.  Otherwise, tha code looks fairly similar:
.PP
# sort-apache-log-schwarzian
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    print
\&
\&        map $_\->[0] =>
\&
\&        sort {
\&            $a\->[4] cmp $b\->[4]
\&                    ||
\&            $a\->[3] cmp $b\->[3]
\&                    ||
\&            $a\->[1] cmp $b\->[1]
\&                    ||
\&            $a\->[2] cmp $b\->[2]
\&                    ||
\&            $a\->[5] cmp $b\->[5]
\&        }
\&        map  [ $_, m/^(
\&            ([\ew\e.\e\-]+)             # client
\&            \es*\-\es*\-\es*\e[
\&            ([^]]+)                 # date
\&            \e]\es*"\ew+\es*
\&            (\eS+)                   # query
\&            [^"]+"\es*
\&            (\ed+)                   # status
\&            \es+\eS+\es+"[^"]*"\es+"
\&            ([^"]*)                 # browser
\&            "
\&            .*
\&        )$/xo ]
\&
\&        => <>;
\&
\&    exit 0;
.Ve
.PP
Run tha freshly smoked up code against tha same logfile, as above, ta check tha freshly smoked up time.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log\-schwarzian logfile > out\-schwarz
\&
\&    real    0m9.664s
\&    user    0m8.873s
\&    sys     0m0.704s
.Ve
.PP
Da time has been cut up in half, which be a respectable speed improvement by any
standard. Y'all KNOW dat shit, muthafucka!  Naturally, it is blingin ta check tha output is consistent with
the first program run, dis is where tha Unix system \f(CW\*(C`cksum\*(C'\fR utilitizzle comes in.
.PP
.Vb 3
\&    $> cksum out\-sort out\-schwarz
\&    3044173777 52029194 out\-sort
\&    3044173777 52029194 out\-schwarz
.Ve
.PP
\&\s-1BTW.\s0 Beware too of heat from managers whoz ass peep you speed a program up by 50%
of tha runtime once, only ta git a request one month lata ta do tha same again
(true story) \- you gonna just gotta point up yo' only human, even if yo ass be a
Perl programmer, n' you gonna peep what tha fuck you can do...
.SH "LOGGING"
.IX Header "LOGGING"
An essential part of any phat pimpment process be appropriate error handling
with appropriately informatizzle lyrics, however there exists a school of
thought which suggests dat log filez should be \fIchatty\fR, as if tha chain of
unbroken output somehow ensures tha game of tha program.  If speed is in
any way a issue, dis approach is wrong.
.PP
A common sight is code which looks suttin' like this:
.PP
.Vb 1
\&    logger\->debug( "A loggin message via process\-id: $$ INC: " . Dumper(\e%INC) )
.Ve
.PP
Da problem is dat dis code will always be parsed n' executed, even when the
debug level set up in tha loggin configuration file is zero.  Once tha \fIdebug()\fR
subroutine has been entered, n' tha internal \f(CW$debug\fR variable confirmed to
be zero, fo' example, tha message which has been busted up in is ghon be discarded and
the program will continue.  In tha example given though, tha \e%INC hash will
already done been dumped, n' tha message strang constructed, all of which work
could be bypassed by a thugged-out debug variable all up in tha statement level, like this:
.PP
.Vb 1
\&    logger\->debug( "A loggin message via process\-id: $$ INC: " . Dumper(\e%INC) ) if $DEBUG;
.Ve
.PP
This effect can be demonstrated by settin up a test script wit both forms,
includin a \f(CW\*(C`debug()\*(C'\fR subroutine ta emulate typical \f(CW\*(C`logger()\*(C'\fR functionality.
.PP
# ifdebug
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    mah $DEBUG = 0;
\&
\&    sub debug {
\&        mah $msg = shift;
\&
\&        if ( $DEBUG ) {
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 loggin message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqifdebug\*(Aq  => sub {
\&                debug( "A $0 loggin message via process\-id: $$" . Dumper(\e%INC) ) if $DEBUG
\&            },
\&    });
.Ve
.PP
Letz peep what tha fuck \f(CW\*(C`Benchmark\*(C'\fR make of this:
.PP
.Vb 5
\&    $> perl ifdebug
\&    Benchmark: timin 100000 iterationz of constant, sub...
\&       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
\&                (warning: too few iterations fo' a reliable count)
\&         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)
.Ve
.PP
In tha one case tha code, which do exactly tha same thang as far as
outputtin any debuggin shiznit is concerned, up in other lyrics nothing,
takes 14 seconds, n' up in tha other case tha code takes one hundredth of a
second. Y'all KNOW dat shit, muthafucka!  Looks fairly definitive.  Use a \f(CW$DEBUG\fR variable \s-1BEFORE\s0 you call the
subroutine, rather than relyin on tha smart-ass functionalitizzle inside dat shit.
.SS "Loggin if \s-1DEBUG \s0(constant)"
.IX Subsection "Loggin if DEBUG (constant)"
It aint nuthin but possible ta take tha previous scam a lil further, by rockin a cold-ass lil compile
time \f(CW\*(C`DEBUG\*(C'\fR constant.
.PP
# ifdebug-constant
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant
\&        DEBUG => 0
\&    ;
\&
\&    sub debug {
\&        if ( DEBUG ) {
\&            mah $msg = shift;
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 loggin message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqconstant\*(Aq  => sub {
\&                debug( "A $0 loggin message via process\-id: $$" . Dumper(\e%INC) ) if DEBUG
\&            },
\&    });
.Ve
.PP
Hustlin dis program produces tha followin output:
.PP
.Vb 5
\&    $> perl ifdebug\-constant
\&    Benchmark: timin 100000 iterationz of constant, sub...
\&      constant:  0 wallclock secs (\-0.00 usr +  0.00 sys = \-0.00 CPU) @ \-7205759403792793600000.00/s (n=100000)
\&                (warning: too few iterations fo' a reliable count)
\&           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)
.Ve
.PP
Da \f(CW\*(C`DEBUG\*(C'\fR constant wipes tha floor wit even tha \f(CW$debug\fR variable,
clockin up in at minus zero seconds, n' generates a \*(L"warning: too few iterations
for a reliable count\*(R" message tha fuck into tha bargain. I aint talkin' bout chicken n' gravy biatch.  To peep what tha fuck is straight-up going
on, n' why our crazy asses had too few iterations when we thought we axed fo' 100000, we
can use tha straight-up useful \f(CW\*(C`B::Deparse\*(C'\fR ta inspect tha freshly smoked up code:
.PP
.Vb 1
\&    $> perl \-MO=Deparse ifdebug\-constant
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant (\*(AqDEBUG\*(Aq, 0);
\&    sub debug {
\&        use warnings;
\&        use strict \*(Aqrefs\*(Aq;
\&        0;
\&    }
\&    use warnings;
\&    use strict \*(Aqrefs\*(Aq;
\&    timethese(100000, {\*(Aqsub\*(Aq, sub {
\&        debug "A $0 loggin message via process\-id: $$" . Dumper(\e%INC);
\&    }
\&    , \*(Aqconstant\*(Aq, sub {
\&        0;
\&    }
\&    });
\&    ifdebug\-constant syntax OK
.Ve
.PP
Da output shows tha \fIconstant()\fR subroutine we testin bein replaced with
the value of tha \f(CW\*(C`DEBUG\*(C'\fR constant: zero.  Da line ta be tested has been
completely optimized away, n' you can't git much mo' efficient than dis shit.
.SH "POSTSCRIPT"
.IX Header "POSTSCRIPT"
This document has provided nuff muthafuckin way ta go bout identifyin hot-spots, and
checkin whether any modifications have improved tha runtime of tha code.
.PP
As a gangbangin' final thought, remember dat it aint (at tha time of writing) possible to
produce a useful program which will run up in zero or wack time n' dis basic
principle can be freestyled as: \fIuseful programs is slow\fR by they hella
definition. I aint talkin' bout chicken n' gravy biatch.  It be of course possible ta write a nearly instantaneous program,
but it aint goin ta do straight-up much, herez a straight-up efficient one:
.PP
.Vb 1
\&    $> perl \-e 0
.Ve
.PP
Optimizin dat any further be a thang fo' \f(CW\*(C`p5p\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Further readin can be found rockin tha modulez n' links below.
.SS "\s-1PERLDOCS\s0"
.IX Subsection "PERLDOCS"
For example: \f(CW\*(C`perldoc \-f sort\*(C'\fR.
.PP
perlfaq4.
.PP
perlfork, perlfunc, perlretut, perlthrtut.
.PP
threads.
.SS "\s-1MAN PAGES\s0"
.IX Subsection "MAN PAGES"
\&\f(CW\*(C`time\*(C'\fR.
.SS "\s-1MODULES\s0"
.IX Subsection "MODULES"
It aint nuthin but not possible ta individually showcase all tha performizzle related code for
Perl here, naturally yo, but herez a gangbangin' finger-lickin' dirty-ass short list of modulez from tha \s-1CPAN\s0 which
deserve further attention.
.PP
.Vb 10
\&    Apache::DProf
\&    Apache::SmallProf
\&    Benchmark
\&    DBIx::Profile
\&    Devel::AutoProfiler
\&    Devel::DProf
\&    Devel::DProfLB
\&    Devel::FastProf
\&    Devel::GraphVizProf
\&    Devel::NYTProf
\&    Devel::NYTProf::Apache
\&    Devel::Profiler
\&    Devel::Profile
\&    Devel::Profit
\&    Devel::SmallProf
\&    Devel::WxProf
\&    POE::Devel::Profiler
\&    Sort::Key
\&    Sort::Maker
.Ve
.SS "\s-1URLS\s0"
.IX Subsection "URLS"
Straight-up useful online reference material:
.PP
.Vb 1
\&    http://www.ccl4.org/~nick/P/Fast_Enough/
\&
\&    http://www\-128.ibm.com/developerworks/library/l\-optperl.html
\&
\&    http://perlbuzz.com/2007/11/bind\-output\-variables\-in\-dbi\-for\-speed\-and\-safety.html
\&
\&    http://en.wikipedia.org/wiki/Performance_analysis
\&
\&    http://apache.perl.org/docs/1.0/guide/performance.html
\&
\&    http://perlgolf.sourceforge.net/
\&
\&    http://www.sysarch.com/Perl/sort_paper.html
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Slick Rick Foley <richard.foley@rfi.net> Copyright (c) 2008
