.TH ctest 1 "February 11, 2014" "ctest 2.8.12.2"
.SH NAME
.PP
.nf
  ctest \- Testin driver provided by CMake.
.fi

.SH USAGE
.PP
.nf
  ctest [options]
.fi

.SH DESCRIPTION
.PP
Da "ctest" executable is tha CMake test driver program.  CMake\-generated build trees pimped fo' projects dat use tha ENABLE_TESTING n' ADD_TEST commandz have testin support.  This program will run tha tests n' report thangs up in dis biatch.

.SH OPTIONS
.TP
.B -C <cfg>, --build-config <cfg>
Choose configuration ta test.

Some CMake\-generated build trees can have multiple build configurations up in tha same tree.  This option can be used ta specify which one should be tested. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Example configurations is "Debug" n' "Release".

.TP
.B -V,--verbose
Enable verbose output from tests.

Test output is normally suppressed n' only summary shiznit is displayed. Y'all KNOW dat shit, muthafucka!  This option will show all test output.

.TP
.B -VV,--extra-verbose
Enable mo' verbose output from tests.

Test output is normally suppressed n' only summary shiznit is displayed. Y'all KNOW dat shit, muthafucka!  This option will show even mo' test output.

.TP
.B --debug
Displayin mo' verbose internalz of CTest.

This feature will result up in a big-ass number of output dat is mostly useful fo' debuggin dashboard problems.

.TP
.B --output-on-failure
Output anythang outputted by tha test program if tha test should fail.  This option can also be enabled by settin tha environment variable CTEST_OUTPUT_ON_FAILURE

.TP
.B -F
Enable failover.

This option allows ctest ta resume a test set execution dat was previously interrupted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If no interruption occurred, tha \-F option gonna git no effect.

.TP
.B -j <jobs>, --parallel <jobs>
Run tha tests up in parallel rockin thegiven number of thangs.

This option  drops some lyrics ta ctest ta run tha tests up in parallel rockin given number of thangs.  This option can also be set by settin tha environment variable CTEST_PARALLEL_LEVEL.

.TP
.B -Q,--quiet
Make ctest on tha fuckin' down-low.

This option will suppress all tha output. Da output log file will still be generated if tha \-\-output\-log is specified. Y'all KNOW dat shit, muthafucka! Options like fuckin \-\-verbose, \-\-extra\-verbose, n' \-\-debug is ignored if \-\-quiet is specified.

.TP
.B -O <file>, --output-log <file>
Output ta log file

This option  drops some lyrics ta ctest ta write all its output ta a log file.

.TP
.B -N,--show-only
Disable actual execution of tests.

This option  drops some lyrics ta ctest ta list tha tests dat would be run but not straight-up run em.  Useful up in conjunction wit tha \-R n' \-E options.

.TP
.B -L <regex>, --label-regex <regex>
Run tests wit labels matchin regular expression.

This option  drops some lyrics ta ctest ta run only tha tests whose labels match tha given regular expression.

.TP
.B -R <regex>, --tests-regex <regex>
Run tests matchin regular expression.

This option  drops some lyrics ta ctest ta run only tha tests whose names match tha given regular expression.

.TP
.B -E <regex>, --exclude-regex <regex>
Exclude tests matchin regular expression.

This option  drops some lyrics ta ctest ta NOT run tha tests whose names match tha given regular expression.

.TP
.B -LE <regex>, --label-exclude <regex>
Exclude tests wit labels matchin regular expression.

This option  drops some lyrics ta ctest ta NOT run tha tests whose labels match tha given regular expression.

.TP
.B -D <dashboard>, --dashboard <dashboard>
Execute dashboard test

This option  drops some lyrics ta ctest ta act as a Dart client n' big-ass up a thugged-out dashboard test fo' realz. All tests is <Mode><Test>, where Mode can be Experimental, Nightly, n' Continuous, n' Test can be Start, Update, Configure, Build, Test, Coverage, n' Submit.

.TP
.B -D <var>:<type>=<value>
Define a variable fo' script mode

Pass up in variable joints on tha command line. Use up in conjunction wit \-S ta pass variable joints ta a thugged-out dashboard script. Parsin \-D arguments as variable joints is only attempted if tha value followin \-D do not match any of tha known dashboard types.

.TP
.B -M <model>, --test-model <model>
Sets tha model fo' a thugged-out dashboard

This option  drops some lyrics ta ctest ta act as a Dart client where tha TestModel can be Experimental, Nightly, n' Continuous. Combinin \-M n' \-T is similar ta \-D

.TP
.B -T <action>, --test-action <action>
Sets tha dashboard action ta perform

This option  drops some lyrics ta ctest ta act as a Dart client n' big-ass up some action like fuckin start, build, test etc. Combinin \-M n' \-T is similar ta \-D

.TP
.B --track <track>
Specify tha track ta submit dashboard to

Submit dashboard ta specified track instead of default one. By default, tha dashboard is submitted ta Nightly, Experimental, or Continuous track yo, but by specifyin dis option, tha track can be arbitrary.

.TP
.B -S <script>, --script <script>
Execute a thugged-out dashboard fo' a cold-ass lil configuration

This option  drops some lyrics ta ctest ta load up in a cold-ass lil configuration script which sets a fuckin shitload of parametas like fuckin tha binary n' source directories. Put ya muthafuckin choppers up if ya feel dis! Then ctest will do what tha fuck is required ta create n' run a thugged-out dashboard. Y'all KNOW dat shit, muthafucka! This option basically sets up a thugged-out dashboard n' then runs ctest \-D wit tha appropriate options.

.TP
.B -SP <script>, --script-new-process <script>
Execute a thugged-out dashboard fo' a cold-ass lil configuration

This option do tha same operations as \-S but it will do dem up in a separate process. This is primarily useful up in cases where tha script may modify tha environment n' you do not want tha modified environment ta impact other \-S scripts.

.TP
.B -A <file>, --add-notes <file>
Add a notes file wit submission

This option  drops some lyrics ta ctest ta include a notes file when submittin dashboard. Y'all KNOW dat shit, muthafucka! 

.TP
.B -I [Start,End,Stride,test#,test#|Test file], --tests-information
Run a specific number of tests by number.

This option causes ctest ta run tests startin at number Start, endin at number End, n' incrementin by Stride fo' realz. Any additionizzle numbers afta Stride is considered individual test numbers.  Start, End,or stride can be empty.  Optionally a gangbangin' file can be given dat gotz nuff tha same ol' dirty syntax as tha command line.

.TP
.B -U, --union
Take tha Union of \-I n' \-R

When both \-R n' \-I is specified by default tha intersection of tests is run. I aint talkin' bout chicken n' gravy biatch. By specifyin \-U tha union of tests is run instead.

.TP
.B --max-width <width>
Set tha max width fo' a test name ta output

Set tha maximum width fo' each test name ta show up in tha output.  This allows tha user ta widen tha output ta avoid clippin tha test name which can be straight-up buggin.

.TP
.B --interactive-debug-mode [0|1]
Set tha interactizzle mode ta 0 or 1.

This option causes ctest ta run tests up in either a interactizzle mode or a non\-interactizzle mode. On Windows dis means dat up in non\-interactizzle mode, all system debug pop up windows is blocked. Y'all KNOW dat shit, muthafucka! In dashboard mode (Experimental, Nightly, Continuous), tha default is non\-interactive.  When just hustlin tests not fo' a thugged-out dashboard tha default is ta allow popups n' interactizzle debugging.

.TP
.B --no-label-summary
Disable timin summary shiznit fo' labels.

This option  drops some lyrics ta ctest not ta print summary shiznit fo' each label associated wit tha tests run. I aint talkin' bout chicken n' gravy biatch. If there be no labels on tha tests, not a god damn thang extra is printed.

.TP
.B --build-and-test
Configure, build n' run a test.

This option  drops some lyrics ta ctest ta configure (i.e. run cmake on), build, n' or execute a test. Da configure n' test steps is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da arguments ta dis command line is tha source n' binary directories. Put ya muthafuckin choppers up if ya feel dis! By default dis will run CMake on tha Source/Bin directories specified unless \-\-build\-nocmake is specified. Y'all KNOW dat shit, muthafucka! Both \-\-build\-makeprogram n' \-\-build\-generator MUST be provided ta use \-\-build\-and\-test. If \-\-test\-command is specified then dat is ghon be run afta tha build is complete. Other options dat affect dis mode is \-\-build\-target \-\-build\-nocmake, \-\-build\-run\-dir, \-\-build\-two\-config, \-\-build\-exe\-dir, \-\-build\-project,\-\-build\-noclean, \-\-build\-options

.TP
.B --build-target
Specify a specific target ta build.

This option goes wit tha \-\-build\-and\-test option, if left up tha all target is built.

.TP
.B --build-nocmake
Run tha build without hustlin cmake first.

Skip tha cmake step.

.TP
.B --build-run-dir
Specify directory ta run programs from.

Directory where programs is ghon be afta it has been compiled.

.TP
.B --build-two-config
Run CMake twice

.TP
.B --build-exe-dir
Specify tha directory fo' tha executable.

.TP
.B --build-generator
Specify tha generator ta use.

.TP
.B --build-generator-toolset
Specify tha generator\-specific toolset.

.TP
.B --build-project
Specify tha name of tha project ta build.

.TP
.B --build-makeprogram
Specify tha make program ta use.

.TP
.B --build-noclean
Skip tha make clean step.

.TP
.B --build-config-sample
A sample executable ta use ta determine tha configuration

A sample executable ta use ta determine tha configuration dat should be used. Y'all KNOW dat shit, muthafucka! e.g. Debug/Release/etc

.TP
.B --build-options
Add extra options ta tha build step.

This option must be tha last option wit tha exception of \-\-test\-command

.TP
.B --test-command
Da test ta run wit tha \-\-build\-and\-test option.

.TP
.B --test-timeout
Da time limit up in seconds, internal use only.

.TP
.B --tomorrow-tag
Nightly or experimenstrual starts wit next dizzle tag.

This is useful if tha build aint gonna finish up in one day.

.TP
.B --ctest-config
Da configuration file used ta initialize CTest state when submittin dashboards.

This option  drops some lyrics ta CTest ta use different initialization file instead of CTestConfiguration.tcl. This way multiple initialization filez can be used fo' example ta submit ta multiple dashboards.

.TP
.B --overwrite
Overwrite CTest configuration option.

By default ctest uses configuration options from configuration file. This option will overwrite tha configuration option.

.TP
.B --extra-submit <file>[;<file>]
Submit extra filez ta tha dashboard.

This option will submit extra filez ta tha dashboard.

.TP
.B --force-new-ctest-process
Run lil pimp CTest instances as freshly smoked up processes

By default CTest will run lil pimp CTest instances within tha same process. If dis behavior aint desired, dis argument will enforce freshly smoked up processes fo' lil pimp CTest processes.

.TP
.B --schedule-random
Use a random order fo' schedulin tests

This option will run tha tests up in a random order n' shit. Well shiiiit, it is commonly used ta detect implicit dependencies up in a test suite.

.TP
.B --submit-index
Submit individual dashboard tests wit specific index

This option allows struttin tha same CTest action (like fuckin test) multiple times n' submit all stages ta tha same dashboard (Dart2 required). Each execution requires different index.

.TP
.B --timeout <seconds>
Set a global timeout on all tests.

This option will set a global timeout on all tests dat do not already gotz a timeout set on em.

.TP
.B --stop-time <time>
Set a time at which all tests should stop hustlin.

Set a real time of dizzle at which all tests should timeout. Example: 7:00:00 \-0400 fo' realz. Any time format understood by tha curl date parser be accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Local time be assumed if no timezone is specified.

.TP
.B --http1.0
Submit rockin HTTP 1.0.

This option will force CTest ta use HTTP 1.0 ta submit filez ta tha dashboard, instead of HTTP 1.1.

.TP
.B --no-compress-output
Do not compress test output when submitting.

This flag will turn off automatic compression of test output.  Use dis ta maintain compatibilitizzle wit a olda version of CDash which don't support compressed test output.

.TP
.B --print-labels
Print all available test labels.

This option aint gonna run any tests, it will simply print tha list of all labels associated wit tha test set.

.TP
.B --help-command <cmd> [<file>]
Show help fo' a single command n' exit.

Prints tha help fo' tha command ta stdout or ta tha specified file.

.TP
.B --help-command-list [<file>]
List available commandz n' exit.

Prints tha list of all available listfile commandz ta stdout or tha specified file.

.TP
.B --help-commandz [<file>]
Print help fo' all commandz n' exit.

Prints tha help fo' all commandz ta stdout or ta tha specified file.

.TP
.B --copyright [file]
Print tha CMake copyright n' exit.

If a gangbangin' file is specified, tha copyright is freestyled tha fuck into dat shit.

.TP
.B --help,-help,-usage,-h,-H,/?
Print usage shiznit n' exit.

Usage raps bout tha basic command line intercourse n' its options.

.TP
.B --help-full [file]
Print full help n' exit.

Full help displays most of tha documentation provided by tha UNIX playa page.  It be provided fo' use on non\-UNIX platforms yo, but be also convenient if tha playa page aint installed. Y'all KNOW dat shit, muthafucka!  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-html [file]
Print full help up in HTML format.

This option is used by CMake authors ta help produce wizzy pages.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --help-man [file]
Print full help as a UNIX playa page n' exit.

This option is used by tha cmake build ta generate tha UNIX playa page.  If a gangbangin' file is specified, tha help is freestyled tha fuck into dat shit.

.TP
.B --version,-version,/V [file]
Show program name/version banner n' exit.

If a gangbangin' file is specified, tha version is freestyled tha fuck into dat shit.

.SH GENERATORS
.PP
Da followin generators is available on dis platform:

.SH COMMANDS
.TP
.B break
Break from a enclosin foreach or while loop.

.nf
  break()
.fi

Breaks from a enclosin foreach loop or while loop

.TP
.B build_name
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use ${CMAKE_SYSTEM} n' ${CMAKE_CXX_COMPILER} instead.

.nf
  build_name(variable)
.fi

Sets tha specified variable ta a strang representin tha platform n' compila settings.  These joints is now available all up in tha CMAKE_SYSTEM n' CMAKE_CXX_COMPILER variables.

.TP
.B cmake_host_system_information
Query host system specific shiznit.

.nf
  cmake_host_system_information(RESULT <variable> QUERY <key> ...)
.fi

Queries system shiznit of tha host system on which cmake runs. One or mo' <key> can be provided ta select tha shiznit ta be queried. Y'all KNOW dat shit, muthafucka! Da list of queried joints is stored up in <variable>.


<key> can be one of tha followin joints:


.nf
  NUMBER_OF_LOGICAL_CORES   = Number of logical cores.
  NUMBER_OF_PHYSICAL_CORES  = Number of physical cores.
  HOSTNAME                  = Hostname.
  FQDN                      = Fully qualified domain name.
  TOTAL_VIRTUAL_MEMORY      = Total virtual memory up in megabytes.
  AVAILABLE_VIRTUAL_MEMORY  = Available virtual memory up in megabytes.
  TOTAL_PHYSICAL_MEMORY     = Total physical memory up in megabytes.
  AVAILABLE_PHYSICAL_MEMORY = Available physical memory up in megabytes.
.fi

.TP
.B cmake_minimum_required
Set tha minimum required version of cmake fo' a project.

.nf
  cmake_minimum_required(VERSION major[.minor[.patch[.tweak]]]
                         [FATAL_ERROR])
.fi

If tha current version of CMake is lower than dat required it will stop processin tha project n' report a error. Shiiit, dis aint no joke.  When a version higher than 2.4 is specified tha command implicitly invokes


.nf
  cmake_policy(VERSION major[.minor[.patch[.tweak]]])
.fi

which sets tha cmake policy version level ta tha version specified. Y'all KNOW dat shit, muthafucka!  When version 2.4 or lower is given tha command implicitly invokes


.nf
  cmake_policy(VERSION 2.4)
.fi

which enablez compatibilitizzle features fo' CMake 2.4 n' lower.


Da FATAL_ERROR option be accepted but ignored by CMake 2.6 n' higher n' shit.  It should be specified so CMake versions 2.4 n' lower fail wit a error instead of just a warning.

.TP
.B cmake_policy
Manage CMake Policy settings.

As CMake evolves it is sometimes necessary ta chizzle existin behavior up in order ta fix bugs or improve implementationz of existin features.  Da CMake Policy mechanizzle is designed ta help keep existin projects buildin as freshly smoked up versionz of CMake introduce chizzlez up in behavior. Shiiit, dis aint no joke.  Each freshly smoked up policy (behavioral chizzle) is given a identifier of tha form "CMP<NNNN>" where "<NNNN>" be a integer index.  Documentation associated wit each policy raps bout tha OLD n' NEW behavior n' tha reason tha policy was introduced. Y'all KNOW dat shit, muthafucka!  Projects may set each policy ta select tha desired behavior. Shiiit, dis aint no joke.  When CMake need ta know which behavior ta use it checks fo' a settin specified by tha project.  If no settin be available tha OLD behavior be assumed n' a warnin is produced requestin dat tha policy be set.


Da cmake_policy command is used ta set policies ta OLD or NEW behavior. Shiiit, dis aint no joke.  While settin policies individually is supported, we encourage projects ta set policies based on CMake versions.


.nf
  cmake_policy(VERSION major.minor[.patch[.tweak]])
.fi

Specify dat tha current CMake list file is freestyled fo' tha given version of CMake.  All policies introduced up in tha specified version or earlier is ghon be set ta use NEW behavior. Shiiit, dis aint no joke.  All policies introduced afta tha specified version is ghon be unset (unless variable CMAKE_POLICY_DEFAULT_CMP<NNNN> sets a thugged-out default).  This effectively requests behavior preferred az of a given CMake version n'  drops some lyrics ta newer CMake versions ta warn bout they freshly smoked up policies. Put ya muthafuckin choppers up if ya feel dis!  Da policy version specified must be at least 2.4 or tha command will report a error. Shiiit, dis aint no joke.  In order ta git compatibilitizzle features supportin versions earlier than 2.4 peep documentation of policy CMP0001.


.nf
  cmake_policy(SET CMP<NNNN> NEW)
  cmake_policy(SET CMP<NNNN> OLD)
.fi

Tell CMake ta use tha OLD or NEW behavior fo' a given policy.  Projects dependin on tha oldschool behavior of a given policy may silence a policy warnin by settin tha policy state ta OLD.  Alternatively one may fix tha project ta work wit tha freshly smoked up behavior n' set tha policy state ta NEW.


.nf
  cmake_policy(GET CMP<NNNN> <variable>)
.fi

Peep whether a given policy is set ta OLD or NEW behavior. Shiiit, dis aint no joke.  Da output variable value is ghon be "OLD" or "NEW" if tha policy is set, n' empty otherwise.


CMake keeps policy settings on a stack, so chizzlez made by tha cmake_policy command affect only tha top of tha stack.  A freshly smoked up entry on tha policy stack is managed automatically fo' each subdirectory ta protect its muthafathas n' siblings.  CMake also manages a freshly smoked up entry fo' scripts loaded by include() n' find_package() commandz except when invoked wit tha NO_POLICY_SCOPE option (see also policy CMP0011).  Da cmake_policy command serves up a intercourse ta manage custom entries on tha policy stack:


.nf
  cmake_policy(PUSH)
  cmake_policy(POP)
.fi

Each PUSH must gotz a matchin POP ta erase any chizzles.  This is useful ta make temporary chizzlez ta policy settings.


Functions n' macros record policy settings when they is pimped n' use tha pre\-record policies when they is invoked. Y'all KNOW dat shit, muthafucka!  If tha function or macro implementation sets policies, tha chizzlez automatically propagate up all up in callaz until they reach tha closest nested policy stack entry.

.TP
.B configure_file
Copy a gangbangin' file ta another location n' modify its contents.

.nf
  configure_file(<input> <output>
                 [COPYONLY] [ESCAPE_QUOTES] [@ONLY] 
                 [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])
.fi

Copies a gangbangin' file <input> ta file <output> n' substitutes variable joints referenced up in tha file content.  If <input> be a relatizzle path it is evaluated wit respect ta tha current source directory.  Da <input> must be a gangbangin' file, not a gangbangin' finger-lickin' directory.  If <output> be a relatizzle path it is evaluated wit respect ta tha current binary directory.  If <output> names a existin directory tha input file is placed up in dat directory wit its original gangsta name.  


If tha <input> file is modified tha build system will re\-run CMake ta re\-configure tha file n' generate tha build system again.


This command replaces any variablez up in tha input file referenced as ${VAR} or @VAR@ wit they joints as determined by CMake.  If a variable aint defined, it is ghon be replaced wit nothing.  If COPYONLY is specified, then no variable expansion will take place.  If ESCAPE_QUOTES is specified then any substituted quotes is ghon be C\-style escaped. Y'all KNOW dat shit, muthafucka!  Da file is ghon be configured wit tha current jointz of CMake variables. If @ONLY is specified, only variablez of tha form @VAR@ is ghon be replaced n' ${VAR} is ghon be ignored. Y'all KNOW dat shit, muthafucka!  This is useful fo' configurin scripts dat use ${VAR}.


Input file linez of tha form "#cmakedefine VAR ..." is ghon be replaced wit either "#define VAR ..." or "/* #undef VAR */" dependin on whether VAR is set up in CMake ta any value not considered a gangbangin' false constant by tha if() command. Y'all KNOW dat shit, muthafucka! (Content of "...", if any, is processed as above.) Input file linez of tha form "#cmakedefine01 VAR" is ghon be replaced wit either "#define VAR 1" or "#define VAR 0" similarly.


With NEWLINE_STYLE tha line endin could be adjusted: 


.nf
    'UNIX' or 'LF' fo' \\n, 'DOS', 'WIN32' or 'CRLF' fo' \\r\\n.
.fi

COPYONLY must not be used wit NEWLINE_STYLE.


.TP
.B ctest_build
Build tha project.

.nf
  ctest_build([BUILD build_dir] [TARGET target] [RETURN_VALUE res]
              [APPEND][NUMBER_ERRORS val] [NUMBER_WARNINGS val])
.fi

Buildz tha given build directory n' stores thangs up in dis biatch up in Build.xml. If no BUILD is given, tha CTEST_BINARY_DIRECTORY variable is used.


Da TARGET variable can be used ta specify a funky-ass build target.  If none is specified, tha "all" target is ghon be built.


Da RETURN_VALUE option specifies a variable up in which ta store tha return value of tha natizzle build tool. Da NUMBER_ERRORS n' NUMBER_WARNINGS options specify variablez up in which ta store tha number of build errors n' warnings detected.


Da APPEND option marks thangs up in dis biatch fo' append ta dem previously submitted ta a thugged-out dashboard server since tha last ctest_start.  Append semantics is defined by tha dashboard server up in use.

.TP
.B ctest_configure
Configure tha project build tree.

.nf
  ctest_configure([BUILD build_dir] [SOURCE source_dir] [APPEND]
                  [OPTIONS options] [RETURN_VALUE res])
.fi

Configures tha given build directory n' stores thangs up in dis biatch up in Configure.xml. If no BUILD is given, tha CTEST_BINARY_DIRECTORY variable is used. Y'all KNOW dat shit, muthafucka! If no SOURCE is given, tha CTEST_SOURCE_DIRECTORY variable is used. Y'all KNOW dat shit, muthafucka! Da OPTIONS argument specifies command line arguments ta pass ta tha configuration tool. Da RETURN_VALUE option specifies a variable up in which ta store tha return value of tha natizzle build tool.


Da APPEND option marks thangs up in dis biatch fo' append ta dem previously submitted ta a thugged-out dashboard server since tha last ctest_start.  Append semantics is defined by tha dashboard server up in use.

.TP
.B ctest_coverage
Collect coverage tool thangs up in dis biatch.

.nf
  ctest_coverage([BUILD build_dir] [RETURN_VALUE res] [APPEND]
                 [LABELS label1 [label2 [...]]])
.fi

Perform tha coverage of tha given build directory n' stores thangs up in dis biatch up in Coverage.xml. Da second argument be a variable dat will hold value.


Da LABELS option filtas tha coverage report ta include only source filez labeled wit at least one of tha labels specified.


Da APPEND option marks thangs up in dis biatch fo' append ta dem previously submitted ta a thugged-out dashboard server since tha last ctest_start.  Append semantics is defined by tha dashboard server up in use.

.TP
.B ctest_empty_binary_directory
emptizzles tha binary directory

.nf
  ctest_empty_binary_directory( directory )
.fi

Removes a funky-ass binary directory. This command will big-ass up some checks prior ta deletin tha directory up in a attempt ta avoid malicious or accidental directory deletion.

.TP
.B ctest_memcheck
Run tests wit a thugged-out dynamic analysis tool.

.nf
  ctest_memcheck([BUILD build_dir] [RETURN_VALUE res] [APPEND]
             [START start number] [END end number]
             [STRIDE stride number] [EXCLUDE exclude regex ]
             [INCLUDE include regex] 
             [EXCLUDE_LABEL exclude regex] 
             [INCLUDE_LABEL label regex] 
             [PARALLEL_LEVEL level] )
.fi

Tests tha given build directory n' stores thangs up in dis biatch up in MemCheck.xml. Da second argument be a variable dat will hold value. Optionally, you can specify tha startin test number START, tha endin test number END, tha number of tests ta skip between each test STRIDE, a regular expression fo' tests ta run INCLUDE, or a regular expression fo' tests not ta run EXCLUDE. EXCLUDE_LABEL n' INCLUDE_LABEL is regular expressions fo' tests ta be included or excluded by tha test property LABEL. PARALLEL_LEVEL should be set ta a positizzle number representin tha number of tests ta be run up in parallel.


Da APPEND option marks thangs up in dis biatch fo' append ta dem previously submitted ta a thugged-out dashboard server since tha last ctest_start.  Append semantics is defined by tha dashboard server up in use.

.TP
.B ctest_read_custom_files
read CTestCustom files.

.nf
  ctest_read_custom_files( directory ... )
.fi

Read all tha CTestCustom.ctest or CTestCustom.cmake filez from tha given directory.

.TP
.B ctest_run_script
runs a cold-ass lil ctest \-S script

.nf
  ctest_run_script([NEW_PROCESS] script_file_name script_file_name1 
              script_file_name2 ... [RETURN_VALUE var])
.fi

Runs a script or scripts much like if dat shiznit was run from ctest \-S. If no argument is provided then tha current script is run rockin tha current settingz of tha variables. If NEW_PROCESS is specified then each script is ghon be run up in a separate process.If RETURN_VALUE is specified tha return value of tha last script run is ghon be put tha fuck into var.

.TP
.B ctest_sleep
sleeps fo' some amount of time

.nf
  ctest_sleep(<seconds>)
.fi

Sleep fo' given number of seconds.


.nf
  ctest_sleep(<time1> <duration> <time2>)
.fi

Sleep fo' t=(time1 + duration \- time2) secondz if t > 0.

.TP
.B ctest_start
Starts tha testin fo' a given model

.nf
  ctest_start(Model [TRACK <track>] [APPEND] [source [binary]])
.fi

Starts tha testin fo' a given model. Da command should be called afta tha binary directory is initialized. Y'all KNOW dat shit, muthafucka! If tha 'source' n' 'binary' directory is not specified, it readz tha CTEST_SOURCE_DIRECTORY n' CTEST_BINARY_DIRECTORY. If tha track is specified, tha submissions will git all up in tha specified track. If APPEND is used, tha existin TAG is used rather than bustin a freshly smoked up one based on tha current time stamp.

.TP
.B ctest_submit
Submit thangs up in dis biatch ta a thugged-out dashboard server.

.nf
  ctest_submit([PARTS ...] [FILES ...] [RETRY_COUNT count]                [RETRY_DELAY delay][RETURN_VALUE res])
.fi

By default all available parts is submitted if no PARTS or FILES is specified. Y'all KNOW dat shit, muthafucka!  Da PARTS option lists a subset of parts ta be submitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Valid part names are:


.nf
  Start      = nothing
  Update     = ctest_update thangs up in dis biatch, up in Update.xml
  Configure  = ctest_configure thangs up in dis biatch, up in Configure.xml
  Build      = ctest_build thangs up in dis biatch, up in Build.xml
  Test       = ctest_test thangs up in dis biatch, up in Test.xml
  Coverage   = ctest_coverage thangs up in dis biatch, up in Coverage.xml
  MemPeep   = ctest_memcheck thangs up in dis biatch, up in DynamicAnalysis.xml
  Notes      = Filez listed by CTEST_NOTES_FILES, up in Notes.xml
  ExtraFilez = Filez listed by CTEST_EXTRA_SUBMIT_FILES
  Submit     = nothing
.fi

Da FILES option explicitly lists specific filez ta be submitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Each individual file must exist all up in tha time of tha call.


Da RETRY_DELAY option specifies how tha fuck long up in secondz ta wait afta a timed\-out submission before attemptin ta re\-submit.


Da RETRY_COUNT option specifies how tha fuck nuff times ta retry a timed\-out submission.


.TP
.B ctest_test
Run tests up in tha project build tree.

.nf
  ctest_test([BUILD build_dir] [APPEND]
             [START start number] [END end number]
             [STRIDE stride number] [EXCLUDE exclude regex ]
             [INCLUDE include regex] [RETURN_VALUE res] 
             [EXCLUDE_LABEL exclude regex] 
             [INCLUDE_LABEL label regex] 
             [PARALLEL_LEVEL level] 
             [SCHEDULE_RANDOM on] 
             [STOP_TIME time of day]) 
.fi

Tests tha given build directory n' stores thangs up in dis biatch up in Test.xml. Da second argument be a variable dat will hold value. Optionally, you can specify tha startin test number START, tha endin test number END, tha number of tests ta skip between each test STRIDE, a regular expression fo' tests ta run INCLUDE, or a regular expression fo' tests ta not run EXCLUDE. EXCLUDE_LABEL n' INCLUDE_LABEL is regular expression fo' test ta be included or excluded by tha test property LABEL. PARALLEL_LEVEL should be set ta a positizzle number representin tha number of tests ta be run up in parallel. Right back up in yo muthafuckin ass. SCHEDULE_RANDOM will launch tests up in a random order, n' is typically used ta detect implicit test dependencies. Put ya muthafuckin choppers up if ya feel dis! Right back up in yo muthafuckin ass. STOP_TIME is tha time of dizzle at which tha tests should all stop hustlin.


Da APPEND option marks thangs up in dis biatch fo' append ta dem previously submitted ta a thugged-out dashboard server since tha last ctest_start.  Append semantics is defined by tha dashboard server up in use.

.TP
.B ctest_update
Update tha work tree from version control.

.nf
  ctest_update([SOURCE source] [RETURN_VALUE res])
.fi

Updates tha given source directory n' stores thangs up in dis biatch up in Update.xml. If no SOURCE is given, tha CTEST_SOURCE_DIRECTORY variable is used. Y'all KNOW dat shit, muthafucka! Da RETURN_VALUE option specifies a variable up in which ta store tha result, which is tha number of filez updated or \-1 on error.

.TP
.B ctest_upload
Upload filez ta a thugged-out dashboard server.

.nf
  ctest_upload(FILES ...)
.fi

Pass a list of filez ta be busted along wit tha build thangs up in dis biatch ta tha dashboard server.


.TP
.B else
Starts tha else portion of a if block.

.nf
  else(expression)
.fi

See tha if command.

.TP
.B elseif
Starts tha elseif portion of a if block.

.nf
  elseif(expression)
.fi

See tha if command.

.TP
.B endforeach
Endz a list of commandz up in a FOREACH block.

.nf
  endforeach(expression)
.fi

See tha FOREACH command.

.TP
.B endfunction
Endz a list of commandz up in a gangbangin' function block.

.nf
  endfunction(expression)
.fi

See tha function command.

.TP
.B endif
Endz a list of commandz up in a if block.

.nf
  endif(expression)
.fi

See tha if command.

.TP
.B endmacro
Endz a list of commandz up in a macro block.

.nf
  endmacro(expression)
.fi

See tha macro command.

.TP
.B endwhile
Endz a list of commandz up in a while block.

.nf
  endwhile(expression)
.fi

See tha while command.

.TP
.B exec_program
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use tha execute_process() command instead.

Run a executable program durin tha processin of tha CMakeList.txt file.


.nf
  exec_program(Executable [directory up in which ta run]
               [ARGS <arguments ta executable>]
               [OUTPUT_VARIABLE <var>]
               [RETURN_VALUE <var>])
.fi

Da executable is run up in tha optionally specified directory.  Da executable can include arguments if it is double quoted yo, but it is betta ta use tha optionizzle ARGS argument ta specify arguments ta tha program.   This is cuz cmake will then be able ta escape spaces up in tha executable path.  An optionizzle argument OUTPUT_VARIABLE specifies a variable up in which ta store tha output. To capture tha return value of tha execution, provide a RETURN_VALUE. If OUTPUT_VARIABLE is specified, then no output will git all up in tha stdout/stderr of tha console hustlin cmake.


.TP
.B execute_process
Execute one or mo' lil pimp processes.

.nf
  execute_process(COMMAND <cmd1> [args1...]]
                  [COMMAND <cmd2> [args2...] [...]]
                  [WORKING_DIRECTORY <directory>]
                  [TIMEOUT <seconds>]
                  [RESULT_VARIABLE <variable>]
                  [OUTPUT_VARIABLE <variable>]
                  [ERROR_VARIABLE <variable>]
                  [INPUT_FILE <file>]
                  [OUTPUT_FILE <file>]
                  [ERROR_FILE <file>]
                  [OUTPUT_QUIET]
                  [ERROR_QUIET]
                  [OUTPUT_STRIP_TRAILING_WHITESPACE]
                  [ERROR_STRIP_TRAILING_WHITESPACE])
.fi

Runs tha given sequence of one or mo' commandz wit tha standard output of each process piped ta tha standard input of tha next.  A single standard error pipe is used fo' all processes.  If WORKING_DIRECTORY is given tha named directory is ghon be set as tha current hustlin directory of tha lil pimp processes.  If TIMEOUT is given tha lil pimp processes is ghon be terminated if they do not finish up in tha specified number of secondz (fractions is allowed).  If RESULT_VARIABLE is given tha variable is ghon be set ta contain tha result of hustlin tha processes.  This is ghon be a integer return code from tha last lil pimp or a strang describin a error condition. I aint talkin' bout chicken n' gravy biatch.  If OUTPUT_VARIABLE or ERROR_VARIABLE is given tha variable named is ghon be set wit tha contentz of tha standard output n' standard error pipes respectively.  If tha same variable is named fo' both pipes they output is ghon be merged up in tha order produced. Y'all KNOW dat shit, muthafucka!  If INPUT_FILE, OUTPUT_FILE, or ERROR_FILE is given tha file named is ghon be attached ta tha standard input of tha straight-up original gangsta process, standard output of tha last process, or standard error of all processes respectively.  If OUTPUT_QUIET or ERROR_QUIET is given then tha standard output or standard error thangs up in dis biatch is ghon be on tha fuckin' down-lowly ignored. Y'all KNOW dat shit, muthafucka!  If mo' than one OUTPUT_* or ERROR_* option is given fo' tha same pipe tha precedence aint specified. Y'all KNOW dat shit, muthafucka!  If no OUTPUT_* or ERROR_* options is given tha output is ghon be shared wit tha correspondin pipez of tha CMake process itself.


Da execute_process command be a newer mo' bangin version of exec_program yo, but tha oldschool command has been kept fo' compatibility.

.TP
.B file
File manipulation command.

.nf
  file(WRITE filename "message ta write"... )
  file(APPEND filename "message ta write"... )
  file(READ filename variable [LIMIT numBytes] [OFFSET offset] [HEX])
  file(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512> filename variable)
  file(STRINGS filename variable [LIMIT_COUNT num]
       [LIMIT_INPUT numBytes] [LIMIT_OUTPUT numBytes]
       [LENGTH_MINIMUM numBytes] [LENGTH_MAXIMUM numBytes]
       [NEWLINE_CONSUME] [REGEX regex]
       [NO_HEX_CONVERSION])
  file(GLOB variable [RELATIVE path] [globbin expressions]...)
  file(GLOB_RECURSE variable [RELATIVE path] 
       [FOLLOW_SYMLINKS] [globbin expressions]...)
  file(RENAME <oldname> <newname>)
  file(REMOVE [file1 ...])
  file(REMOVE_RECURSE [file1 ...])
  file(MAKE_DIRECTORY [directory1 directory2 ...])
  file(RELATIVE_PATH variable directory file)
  file(TO_CMAKE_PATH path result)
  file(TO_NATIVE_PATH path result)
  file(DOWNLOAD url file [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS]
       [EXPECTED_HASH ALGO=value] [EXPECTED_MD5 sum]
       [TLS_VERIFY on|off] [TLS_CAINFO file])
  file(UPLOAD filename url [INACTIVITY_TIMEOUT timeout]
       [TIMEOUT timeout] [STATUS status] [LOG log] [SHOW_PROGRESS])
  file(TIMESTAMP filename variable [<format string>] [UTC])
  file(GENERATE OUTPUT output_file
       <INPUT input_file|CONTENT input_content>
       [CONDITION expression])
.fi

WRITE will write a message tha fuck into a gangbangin' file called 'filename'. Well shiiiit, it overwrites tha file if it already exists, n' creates tha file if it do not exist. (If tha file be a funky-ass build input, use configure_file ta update tha file only when its content chizzles.)


APPEND will write a message tha fuck into a gangbangin' file same as WRITE, except it will append it ta tha end of tha file


READ will read tha content of a gangbangin' file n' store it tha fuck into tha variable. Well shiiiit, it will start all up in tha given offset n' read up ta numBytes. If tha argument HEX is given, tha binary data is ghon be converted ta hexadecimal representation n' dis is ghon be stored up in tha variable.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha content of a gangbangin' file.


STRINGS will parse a list of ASCII strings from a gangbangin' file n' store it up in a variable. Binary data up in tha file is ignored. Y'all KNOW dat shit, muthafucka! Carriage return (CR) charactas is ignored. Y'all KNOW dat shit, muthafucka! Well shiiiit, it works also fo' Intel Hex n' Motorola S\-record files, which is automatically converted ta binary format when readin em. Disable dis rockin NO_HEX_CONVERSION.


LIMIT_COUNT sets tha maximum number of strings ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. LIMIT_INPUT sets tha maximum number of bytes ta read from tha input file. LIMIT_OUTPUT sets tha maximum number of bytes ta store up in tha output variable. LENGTH_MINIMUM sets tha minimum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Shorta strings is ignored. Y'all KNOW dat shit, muthafucka! LENGTH_MAXIMUM sets tha maximum length of a strang ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch.  Longer strings is split tha fuck into strings no longer than tha maximum length. NEWLINE_CONSUME allows newlines ta be included up in strings instead of terminatin em.


REGEX specifies a regular expression dat a strang must match ta be returned. Y'all KNOW dat shit, muthafucka! Typical usage 


.nf
  file(STRINGS myfile.txt myfile)
.fi

stores a list up in tha variable "myfile" up in which each item be a line from tha input file.


GLOB will generate a list of all filez dat match tha globbin expressions n' store it tha fuck into tha variable. Globbin expressions is similar ta regular expressions yo, but much simpla n' shit. If RELATIVE flag is specified fo' a expression, tha thangs up in dis biatch is ghon be returned as a relatizzle path ta tha given path.  (Us dudes do not recommend rockin GLOB ta collect a list of source filez from yo' source tree.  If no CMakeLists.txt file chizzlez when a source be added or removed then tha generated build system cannot know when ta ask CMake ta regenerate.)


Examplez of globbin expressions include:


.nf
   *.cxx      \- match all filez wit extension cxx
   *.vt?      \- match all filez wit extension vta,...,vtz
   f[3\-5].txt \- match filez f3.txt, f4.txt, f5.txt
.fi

GLOB_RECURSE will generate a list similar ta tha regular GLOB, except it will traverse all tha subdirectoriez of tha matched directory n' match tha files. Right back up in yo muthafuckin ass. Subdirectories dat is symlinks is only traversed if FOLLOW_SYMLINKS is given or cmake policy CMP0009 aint set ta NEW. Right back up in yo muthafuckin ass. See cmake \-\-help\-policy CMP0009 fo' mo' shiznit.


Examplez of recursive globbin include:


.nf
   /dir/*.py  \- match all python filez up in /dir n' subdirectories
.fi

MAKE_DIRECTORY will create tha given directories, also if they parent directories don't exist yet


RENAME moves a gangbangin' file or directory within a gangbangin' filesystem, replacin tha destination atomically.


REMOVE will remove tha given files, also up in subdirectories


REMOVE_RECURSE will remove tha given filez n' directories, also non\-empty directories


RELATIVE_PATH will determine relatizzle path from directory ta tha given file.


TO_CMAKE_PATH will convert path tha fuck into a cold-ass lil cmake steez path wit unix /.  Da input can be a single path or a system path like "$ENV{PATH}".  Note tha double quotes round tha ENV call TO_CMAKE_PATH only takes  one argument. This command will also convert tha natizzle list delimitas fo' a list of paths like tha PATH environment variable.


TO_NATIVE_PATH works just like TO_CMAKE_PATH yo, but will convert from  a cold-ass lil cmake steez path tha fuck into tha natizzle path steez \\ fo' windows n' / fo' UNIX.


DOWNLOAD will downlizzle tha given URL ta tha given file. If LOG var is specified a log of tha downlizzle is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If EXPECTED_HASH ALGO=value is specified, tha operation will verify dat tha downloaded filez actual hash matches tha expected value, where ALGO is one of MD5, SHA1, SHA224, SHA256, SHA384, or SHA512.  If it do not match, tha operation fails wit a error. Shiiit, dis aint no joke. ("EXPECTED_MD5 sum" is short\-hand fo' "EXPECTED_HASH MD5=sum".) If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete. For https URLs CMake must be built wit OpenSSL.  TLS/SSL certificates is not checked by default.  Set TLS_VERIFY ta ON ta check certificates and/or use EXPECTED_HASH ta verify downloaded content.  Set TLS_CAINFO ta specify a cold-ass lil custom Certificate Authoritizzle file.  If either TLS option aint given CMake will check variablez CMAKE_TLS_VERIFY n' CMAKE_TLS_CAINFO, respectively.


UPLOAD will upload tha given file ta tha given URL. If LOG var is specified a log of tha upload is ghon be put up in var. Shiiit, dis aint no joke. If STATUS var is specified tha statuz of tha operation is ghon be put up in var. Shiiit, dis aint no joke. Da status is returned up in a list of length 2. Da first element is tha numeric return value fo' tha operation, n' tha second element be a strang value fo' tha error fo' realz. A 0 numeric error means no error up in tha operation. I aint talkin' bout chicken n' gravy biatch. If TIMEOUT time is specified, tha operation will timeout afta time seconds, time should be specified as a integer n' shit. Da INACTIVITY_TIMEOUT specifies a integer number of secondz of inactivitizzle afta which tha operation should terminate. If SHOW_PROGRESS is specified, progress shiznit is ghon be printed as status lyrics until tha operation is complete.


TIMESTAMP will write a strang representation of tha modification time of filename ta variable.


Should tha command be unable ta obtain a timestamp variable is ghon be set ta tha empty strang "".


See documentation of tha strang TIMESTAMP sub\-command fo' mo' details.


Da file() command also serves up COPY n' INSTALL signatures:


.nf
  file(<COPY|INSTALL> files... DESTINATION <dir>
       [FILE_PERMISSIONS permissions...]
       [DIRECTORY_PERMISSIONS permissions...]
       [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]
       [FILES_MATCHING]
       [[PATTERN <pattern> | REGEX <regex>]
        [EXCLUDE] [PERMISSIONS permissions...]] [...])
.fi

Da COPY signature copies files, directories, n' symlinks ta a thugged-out destination folda n' shit.  Relatizzle input paths is evaluated wit respect ta tha current source directory, n' a relatizzle destination is evaluated wit respect ta tha current build directory.  Copyin preserves input file timestamps, n' optimizes up a gangbangin' file if it exists all up in tha destination wit tha same timestamp.  Copyin preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS is given (default is USE_SOURCE_PERMISSIONS).  See tha install(DIRECTORY) command fo' documentation of permissions, PATTERN, REGEX, n' EXCLUDE options.  


Da INSTALL signature differs slightly from COPY: it prints status lyrics, n' NO_SOURCE_PERMISSIONS is default.  Installation scripts generated by tha install() command use dis signature (with some undocumented options fo' internal use).


GENERATE will write a <output_file> wit content from a <input_file>, or from <input_content>.  Da output is generated conditionally based on tha content of tha <condition>.  Da file is freestyled at CMake generate\-time n' tha input may contain generator expressions.  Da <condition>, <output_file> n' <input_file> may also contain generator expressions.  Da <condition> must evaluate ta either '0' or '1'.  Da <output_file> must evaluate ta a unique name among all configurations n' among all invocationz of file(GENERATE).

.TP
.B find_file
Find tha full path ta a gangbangin' file.

.nf
   find_file(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_file(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_file(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' full path ta named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha full path ta a gangbangin' file is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_file is invoked wit tha same variable.  Da name of tha full path ta a gangbangin' file dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_file(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_file(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B find_library
Find a library.

.nf
   find_library(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_library(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_library(
             <VAR>
             name | NAMES name1 [name2 ...] [NAMES_PER_DIR]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a library fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha library is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_library is invoked wit tha same variable.  Da name of tha library dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_LIBRARY_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   LIB
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/lib/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/lib fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_LIBRARY_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_library(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_library(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When mo' than one value is given ta tha NAMES option dis command by default will consider one name at a time n' search every last muthafuckin directory fo' dat shit.  Da NAMES_PER_DIR option  drops some lyrics ta dis command ta consider one directory at a time n' search fo' all names up in dat shit.


If tha library found be a gangbangin' framework, then VAR is ghon be set ta tha full path ta tha framework <fullPath>/A.framework. When a gangbangin' full path ta a gangbangin' framework is used as a library, CMake will bust a \-framework A, n' a \-F<fullPath> ta link tha framework ta tha target.


If tha global property FIND_LIBRARY_USE_LIB64_PATHS is set all search paths is ghon be tested as normal, wit "64/" appended, n' wit all matchez of "lib/" replaced wit "lib64/". This property be automatically set fo' tha platforms dat is known ta need it if at least one of tha languages supported by tha PROJECT command is enabled.

.TP
.B find_package
Load settings fo' a external project.

.nf
  find_package(<package> [version] [EXACT] [QUIET] [MODULE]
               [REQUIRED] [[COMPONENTS] [components...]]
               [OPTIONAL_COMPONENTS components...]
               [NO_POLICY_SCOPE])
.fi

Findz n' loadz settings from a external project.  <package>_FOUND is ghon be set ta indicate whether tha package was found. Y'all KNOW dat shit, muthafucka!  When tha package is found package\-specific shiznit is provided all up in variablez n' imported targets documented by tha package itself.  Da QUIET option disablez lyrics if tha package cannot be found. Y'all KNOW dat shit, muthafucka!  Da MODULE option disablez tha second signature documented below.  Da REQUIRED option stops processin wit a error message if tha package cannot be found.


A package\-specific list of required components may be listed afta tha COMPONENTS option (or afta tha REQUIRED option if present).  Additionizzle optionizzle components may be listed afta OPTIONAL_COMPONENTS.  Available components n' they influence on whether a package is considered ta be found is defined by tha target package.


Da [version] argument requests a version wit which tha package found should be compatible (format is major[.minor[.patch[.tweak]]]).  Da EXACT option requests dat tha version be matched exactly.  If no [version] and/or component list is given ta a recursive invocation inside a gangbangin' find\-module, tha correspondin arguments is forwarded automatically from tha outa call (includin tha EXACT flag fo' [version]).  Version support is currently provided only on a package\-by\-package basis (details below).


User code should generally look fo' packages rockin tha above simple signature.  Da remainder of dis command documentation specifies tha full command signature n' detailz of tha search process.  Project maintainers wishin ta provide a package ta be found by dis command is encouraged ta read on.


Da command has two modes by which it searches fo' packages: "Module" mode n' "Config" mode.  Module mode be available when tha command is invoked wit tha above reduced signature.  CMake searches fo' a gangbangin' file called "Find<package>.cmake" up in tha CMAKE_MODULE_PATH followed by tha CMake installation. I aint talkin' bout chicken n' gravy biatch.  If tha file is found, it is read n' processed by CMake.  It be responsible fo' findin tha package, checkin tha version, n' producin any needed lyrics.  Many find\-modulez provide limited or no support fo' versioning; check tha module documentation. I aint talkin' bout chicken n' gravy biatch.  If no module is found n' tha MODULE option aint given tha command proceedz ta Config mode.


Da complete Config mode command signature is:


.nf
  find_package(<package> [version] [EXACT] [QUIET]
               [REQUIRED] [[COMPONENTS] [components...]]
               [CONFIG|NO_MODULE]
               [NO_POLICY_SCOPE]
               [NAMES name1 [name2 ...]]
               [CONFIGS config1 [config2 ...]]
               [HINTS path1 [path2 ... ]]
               [PATHS path1 [path2 ... ]]
               [PATH_SUFFIXES suffix1 [suffix2 ...]]
               [NO_DEFAULT_PATH]
               [NO_CMAKE_ENVIRONMENT_PATH]
               [NO_CMAKE_PATH]
               [NO_SYSTEM_ENVIRONMENT_PATH]
               [NO_CMAKE_PACKAGE_REGISTRY]
               [NO_CMAKE_BUILDS_PATH]
               [NO_CMAKE_SYSTEM_PATH]
               [NO_CMAKE_SYSTEM_PACKAGE_REGISTRY]
               [CMAKE_FIND_ROOT_PATH_BOTH |
                ONLY_CMAKE_FIND_ROOT_PATH |
                NO_CMAKE_FIND_ROOT_PATH])
.fi

Da CONFIG option may be used ta skip Module mode explicitly n' switch ta Config mode.  It be synonymous ta rockin NO_MODULE.  Config mode be also implied by use of options not specified up in tha reduced signature.  


Config mode attempts ta locate a cold-ass lil configuration file provided by tha package ta be found. Y'all KNOW dat shit, muthafucka!  A cache entry called <package>_DIR is pimped ta hold tha directory containin tha file.  By default tha command searches fo' a package wit tha name <package>.  If tha NAMES option is given tha names followin it is used instead of <package>.  Da command searches fo' a gangbangin' file called "<name>Config.cmake" or "<lower\-case\-name>\-config.cmake" fo' each name specified. Y'all KNOW dat shit, muthafucka!  A replacement set of possible configuration file names may be given rockin tha CONFIGS option. I aint talkin' bout chicken n' gravy biatch.  Da search procedure is specified below.  Once found, tha configuration file is read n' processed by CMake.  Since tha file is provided by tha package it already knows tha location of package contents, n' you can put dat on yo' toast.  Da full path ta tha configuration file is stored up in tha cmake variable <package>_CONFIG.


All configuration filez which done been considered by CMake while searchin fo' a installation of tha package wit a appropriate version is stored up in tha cmake variable <package>_CONSIDERED_CONFIGS, tha associated versions up in <package>_CONSIDERED_VERSIONS. 


If tha package configuration file cannot be found CMake will generate a error describin tha problem unless tha QUIET argument is specified. Y'all KNOW dat shit, muthafucka!  If REQUIRED is specified n' tha package aint found a gangbangin' fatal error is generated n' tha configure step stops executing.  If <package>_DIR has been set ta a gangbangin' finger-lickin' directory not containin a cold-ass lil configuration file CMake will ignore it n' search from scratch.


When tha [version] argument is given Config mode will only find a version of tha package dat fronts compatibilitizzle wit tha axed version (format is major[.minor[.patch[.tweak]]]).  If tha EXACT option is given only a version of tha package frontin a exact match of tha axed version may be found. Y'all KNOW dat shit, muthafucka!  CMake do not establish any convention fo' tha meanin of version numbers.  Package version numbers is checked by "version" filez provided by tha packages theyselves.  For a cold-ass lil muthafucka package configuration file "<config\-file>.cmake" tha correspondin version file is located next ta it n' named either "<config\-file>\-version.cmake" or "<config\-file>Version.cmake".  If no such version file be available then tha configuration file be assumed ta not be compatible wit any axed version. I aint talkin' bout chicken n' gravy biatch.  A basic version file containin generic version matchin code can be pimped rockin tha macro write_basic_package_version_file(), peep its documentation fo' mo' details.  When a version file is found it is loaded ta check tha axed version number n' shit.  Da version file is loaded up in a nested scope up in which tha followin variablez done been defined:


.nf
  PACKAGE_FIND_NAME          = tha <package> name
  PACKAGE_FIND_VERSION       = full axed version string
  PACKAGE_FIND_VERSION_MAJOR = major version if requested, else 0
  PACKAGE_FIND_VERSION_MINOR = minor version if requested, else 0
  PACKAGE_FIND_VERSION_PATCH = patch version if requested, else 0
  PACKAGE_FIND_VERSION_TWEAK = tweak version if requested, else 0
  PACKAGE_FIND_VERSION_COUNT = number of version components, 0 ta 4
.fi

Da version file checks whether it satisfies tha axed version n' sets these variables:


.nf
  PACKAGE_VERSION            = full provided version string
  PACKAGE_VERSION_EXACT      = legit if version is exact match
  PACKAGE_VERSION_COMPATIBLE = legit if version is compatible
  PACKAGE_VERSION_UNSUITABLE = legit if unsuitable as any version
.fi

These variablez is checked by tha find_package command ta determine whether tha configuration file serves up a aaight version. I aint talkin' bout chicken n' gravy biatch.  They is not available afta tha find_package call returns.  If tha version be aaight tha followin variablez is set:


.nf
  <package>_VERSION       = full provided version string
  <package>_VERSION_MAJOR = major version if provided, else 0
  <package>_VERSION_MINOR = minor version if provided, else 0
  <package>_VERSION_PATCH = patch version if provided, else 0
  <package>_VERSION_TWEAK = tweak version if provided, else 0
  <package>_VERSION_COUNT = number of version components, 0 ta 4
.fi

and tha correspondin package configuration file is loaded. Y'all KNOW dat shit, muthafucka!  When multiple package configuration filez is available whose version filez claim compatibilitizzle wit tha version axed it is unspecified which one is chosen. I aint talkin' bout chicken n' gravy biatch.  No attempt is made ta chizzle a highest or closest version number.


Config mode serves up a elaborate intercourse n' search procedure.  Much of tha intercourse is provided fo' completenizz n' fo' use internally by find\-modulez loaded by Module mode.  Most user code should simply call


.nf
  find_package(<package> [major[.minor]] [EXACT] [REQUIRED|QUIET])
.fi

in order ta find a package.  Package maintainers providin CMake package configuration filez is encouraged ta name n' install dem such dat tha procedure outlined below will find dem without requirin use of additionizzle options.


CMake constructs a set of possible installation prefixes fo' tha package.  Under each prefix nuff muthafuckin directories is searched fo' a cold-ass lil configuration file.  Da tablez below show tha directories searched. Y'all KNOW dat shit, muthafucka!  Each entry is meant fo' installation trees followin Windows (W), UNIX (U), or Applez (A) conventions.


.nf
  <prefix>/                                               (W)
  <prefix>/(cmake|CMake)/                                 (W)
  <prefix>/<name>*/                                       (W)
  <prefix>/<name>*/(cmake|CMake)/                         (W)
  <prefix>/(lib/<arch>|lib|share)/cmake/<name>*/          (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/                (U)
  <prefix>/(lib/<arch>|lib|share)/<name>*/(cmake|CMake)/  (U)
.fi

On systems supportin OS X Frameworks n' Application Bundlez tha followin directories is searched fo' frameworks or bundlez containin a cold-ass lil configuration file:


.nf
  <prefix>/<name>.framework/Resources/                    (A)
  <prefix>/<name>.framework/Resources/CMake/              (A)
  <prefix>/<name>.framework/Versions/*/Resources/         (A)
  <prefix>/<name>.framework/Versions/*/Resources/CMake/   (A)
  <prefix>/<name>.app/Contents/Resources/                 (A)
  <prefix>/<name>.app/Contents/Resources/CMake/           (A)
.fi

In all cases tha <name> is treated as case\-insensitizzle n' correspondz ta any of tha names specified (<package> or names given by NAMES).  Paths wit lib/<arch> is enabled if CMAKE_LIBRARY_ARCHITECTURE is set.  If PATH_SUFFIXES is specified tha suffixes is appended ta each (W) or (U) directory entry one\-by\-one.


This set of directories is intended ta work up in cooperation wit projects dat provide configuration filez up in they installation trees.  Directories above marked wit (W) is intended fo' installations on Windows where tha prefix may point all up in tha top of a applicationz installation directory.  Those marked wit (U) is intended fo' installations on UNIX platforms where tha prefix is shared by multiple packages.  This is merely a cold-ass lil convention, so all (W) n' (U) directories is still searched on all platforms.  Directories marked wit (A) is intended fo' installations on Applez platforms.  Da cmake variablez CMAKE_FIND_FRAMEWORK n' CMAKE_FIND_APPBUNDLE determine tha order of preference as specified below.


Da set of installation prefixes is constructed rockin tha followin steps.  If NO_DEFAULT_PATH is specified all NO_* options is enabled.


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <package>_DIR
   CMAKE_PREFIX_PATH
   CMAKE_FRAMEWORK_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH is passed. Y'all KNOW dat shit, muthafucka!  Path entries endin up in "/bin" or "/sbin" is automatically converted ta they parent directories.


.nf
   PATH
.fi

5. Right back up in yo muthafuckin ass. Search project build trees recently configured up in a CMake GUI.  This can be skipped if NO_CMAKE_BUILDS_PATH is passed. Y'all KNOW dat shit, muthafucka!  It be intended fo' tha case when a user is buildin multiple dependent projects one afta another.


6. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake user package registry.  This can be skipped if NO_CMAKE_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  On UNIX platforms a <package> may step tha fuck up under tha directory


.nf
  ~/.cmake/packages/<package>
.fi

as a gangbangin' file, wit arbitrary name, whose content specifies tha directory containin tha package configuration file.  See tha export(PACKAGE) command ta create user package registry entries fo' project build trees.


7. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

8. Right back up in yo muthafuckin ass. Search paths stored up in tha CMake system package registry.  This can be skipped if NO_CMAKE_SYSTEM_PACKAGE_REGISTRY is passed. Y'all KNOW dat shit, muthafucka!  On Windows a <package> may step tha fuck up under registry key


.nf
  HKEY_LOCAL_MACHINE\\Software\\Kitware\\CMake\\Packages\\<package>
.fi

as a REG_SZ value, wit arbitrary name, dat specifies tha directory containin tha package configuration file.  There is no system package registry on non\-Windows platforms.


9. Right back up in yo muthafuckin ass. Search paths specified by tha PATHS option. I aint talkin' bout chicken n' gravy biatch.  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_package(<package> PATHS paths... NO_DEFAULT_PATH)
   find_package(<package>)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


Every non\-REQUIRED find_package() call can be disabled by settin tha variable CMAKE_DISABLE_FIND_PACKAGE_<package> ta TRUE. Right back up in yo muthafuckin ass. See tha documentation fo' tha CMAKE_DISABLE_FIND_PACKAGE_<package> variable fo' mo' shiznit.


When loadin a gangbangin' find module or package configuration file find_package defines variablez ta provide shiznit bout tha call arguments (and restores they original gangsta state before returning):


.nf
 <package>_FIND_REQUIRED      = legit if REQUIRED option was given
 <package>_FIND_QUIETLY       = legit if QUIET option was given
 <package>_FIND_VERSION       = full axed version string
 <package>_FIND_VERSION_MAJOR = major version if requested, else 0
 <package>_FIND_VERSION_MINOR = minor version if requested, else 0
 <package>_FIND_VERSION_PATCH = patch version if requested, else 0
 <package>_FIND_VERSION_TWEAK = tweak version if requested, else 0
 <package>_FIND_VERSION_COUNT = number of version components, 0 ta 4
 <package>_FIND_VERSION_EXACT = legit if EXACT option was given
 <package>_FIND_COMPONENTS    = list of axed components
 <package>_FIND_REQUIRED_<c>  = legit if component <c> is required
                                false if component <c> is optional
.fi

In Module mode tha loaded find module is responsible ta honor tha request detailed by these variables; peep tha find module fo' details.  In Config mode find_package handlez REQUIRED, QUIET, n' version options automatically but leaves it ta tha package configuration file ta handle components up in a way dat make sense fo' tha package.  Da package configuration file may set <package>_FOUND ta false ta tell find_package dat component requirements is not satisfied.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B find_path
Find tha directory containin a gangbangin' file.

.nf
   find_path(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_path(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_path(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a gangbangin' finger-lickin' directory containin tha named file fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha file up in a gangbangin' finger-lickin' directory is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_path is invoked wit tha same variable.  Da name of tha file up in a gangbangin' finger-lickin' directory dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_INCLUDE_PATH
   CMAKE_FRAMEWORK_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   INCLUDE
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/include/<arch> if CMAKE_LIBRARY_ARCHITECTURE is set, and
   <prefix>/include fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_INCLUDE_PATH
   CMAKE_SYSTEM_FRAMEWORK_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_path(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_path(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.


When searchin fo' frameworks, if tha file is specified as A/b.h, then tha framework search will look fo' A.framework/Headers/b.h. If dat is found tha path is ghon be set ta tha path ta tha framework. CMake will convert dis ta tha erect \-F option ta include tha file. 

.TP
.B find_program
Find a executable program.

.nf
   find_program(<VAR> name1 [path1 path2 ...])
.fi

This is tha short\-hand signature fo' tha command dat is sufficient up in nuff cases.  It be tha same as find_program(<VAR> name1 [PATHS path1 path2 ...])


.nf
   find_program(
             <VAR>
             name | NAMES name1 [name2 ...]
             [HINTS path1 [path2 ... ENV var]]
             [PATHS path1 [path2 ... ENV var]]
             [PATH_SUFFIXES suffix1 [suffix2 ...]]
             [DOC "cache documentation string"]
             [NO_DEFAULT_PATH]
             [NO_CMAKE_ENVIRONMENT_PATH]
             [NO_CMAKE_PATH]
             [NO_SYSTEM_ENVIRONMENT_PATH]
             [NO_CMAKE_SYSTEM_PATH]
             [CMAKE_FIND_ROOT_PATH_BOTH |
              ONLY_CMAKE_FIND_ROOT_PATH |
              NO_CMAKE_FIND_ROOT_PATH]
            )
.fi

This command is used ta find a program fo' realz. A cache entry named by <VAR> is pimped ta store tha result of dis command. Y'all KNOW dat shit, muthafucka!  If tha program is found tha result is stored up in tha variable n' tha search aint gonna be repeated unless tha variable is cleared. Y'all KNOW dat shit, muthafucka!  If not a god damn thang is found, tha result is ghon be <VAR>\-NOTFOUND, n' tha search is ghon be attempted again n' again n' again tha next time find_program is invoked wit tha same variable.  Da name of tha program dat is searched fo' is specified by tha names listed afta tha NAMES argument.   Additionizzle search locations can be specified afta tha PATHS argument.  If ENV var is found up in tha HINTS or PATHS section tha environment variable var is ghon be read n' converted from a system environment variable ta a cold-ass lil cmake steez list of paths.  For example ENV PATH would be a way ta list tha system path variable. Da argument afta DOC is ghon be used fo' tha documentation strang up in tha cache.  PATH_SUFFIXES specifies additionizzle subdirectories ta check below each search path.


If NO_DEFAULT_PATH is specified, then no additionizzle paths is added ta tha search. If NO_DEFAULT_PATH aint specified, tha search process be as bigs up:


1. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific cache variables.  These is intended ta be used on tha command line wit a \-DVAR=value.  This can be skipped if NO_CMAKE_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

2. Right back up in yo muthafuckin ass. Search paths specified up in cmake\-specific environment variables.  These is intended ta be set up in tha userz shell configuration. I aint talkin' bout chicken n' gravy biatch.  This can be skipped if NO_CMAKE_ENVIRONMENT_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_PREFIX_PATH
   CMAKE_PROGRAM_PATH
   CMAKE_APPBUNDLE_PATH
.fi

3. Right back up in yo muthafuckin ass. Search tha paths specified by tha HINTS option. I aint talkin' bout chicken n' gravy biatch.  These should be paths computed by system introspection, like fuckin a hint provided by tha location of another item already found. Y'all KNOW dat shit, muthafucka!  Hard\-coded guesses should be specified wit tha PATHS option.


4. Right back up in yo muthafuckin ass. Search tha standard system environment variables. This can be skipped if NO_SYSTEM_ENVIRONMENT_PATH be a argument.


.nf
   PATH
   
.fi

5. Right back up in yo muthafuckin ass. Search cmake variablez defined up in tha Platform filez fo' tha current system.  This can be skipped if NO_CMAKE_SYSTEM_PATH is passed.


.nf
   <prefix>/[s]bin fo' each <prefix> up in CMAKE_SYSTEM_PREFIX_PATH
   CMAKE_SYSTEM_PROGRAM_PATH
   CMAKE_SYSTEM_APPBUNDLE_PATH
.fi

6. Right back up in yo muthafuckin ass. Search tha paths specified by tha PATHS option or up in tha short\-hand version of tha command. Y'all KNOW dat shit, muthafucka!  These is typically hard\-coded guesses.


On Darwin or systems supportin OS X Frameworks, tha cmake variable    CMAKE_FIND_FRAMEWORK can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find frameworks before standard
              libraries or headers. This is tha default on Darwin.
   "LAST"   \- Try ta find frameworks afta standard
              libraries or headers.
   "ONLY"   \- Only try ta find frameworks.
   "NEVER" \- Never try ta find frameworks.
.fi

On Darwin or systems supportin OS X Application Bundles, tha cmake variable CMAKE_FIND_APPBUNDLE can be set ta empty or one of tha following:


.nf
   "FIRST"  \- Try ta find application bundlez before standard
              programs. This is tha default on Darwin.
   "LAST"   \- Try ta find application bundlez afta standard
              programs.
   "ONLY"   \- Only try ta find application bundles.
   "NEVER" \- Never try ta find application bundles.
.fi

Da CMake variable CMAKE_FIND_ROOT_PATH specifies one or mo' directories ta be prepended ta all other search directories. Put ya muthafuckin choppers up if ya feel dis! This effectively "re\-roots" tha entire search under given locations. By default it is empty. Well shiiiit, it is especially useful when cross\-compilin ta point ta tha root directory of tha target environment n' CMake will search there like a muthafucka. By default at first tha directories listed up in CMAKE_FIND_ROOT_PATH n' then tha non\-rooted directories is ghon be searched. Y'all KNOW dat shit, muthafucka! Da default behavior can be adjusted by settin CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.  This behavior can be manually overridden on a per\-call basis. By rockin CMAKE_FIND_ROOT_PATH_BOTH tha search order is ghon be as busted lyrics bout above. If NO_CMAKE_FIND_ROOT_PATH is used then CMAKE_FIND_ROOT_PATH aint gonna be used. Y'all KNOW dat shit, muthafucka! If ONLY_CMAKE_FIND_ROOT_PATH is used then only tha re\-rooted directories is ghon be searched.


Da default search order is designed ta be most\-specific ta least\-specific fo' common use cases.  Projects may override tha order by simply callin tha command multiple times n' rockin tha NO_* options:


.nf
   find_program(<VAR> NAMES name PATHS paths... NO_DEFAULT_PATH)
   find_program(<VAR> NAMES name)
.fi

Once one of tha calls succeedz tha result variable is ghon be set n' stored up in tha cache so dat no call will search again.

.TP
.B foreach
Evaluate a crew of commandz fo' each value up in a list.

.nf
  foreach(loop_var arg1 arg2 ...)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endforeach(loop_var)
.fi

All commandz between foreach n' tha matchin endforeach is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endforeach is evaluated, tha recorded list of commandz is invoked once fo' each argument listed up in tha original gangsta foreach command. Y'all KNOW dat shit, muthafucka!  Before each iteration of tha loop "${loop_var}" is ghon be set as a variable wit tha current value up in tha list.


.nf
  foreach(loop_var RANGE total)
  foreach(loop_var RANGE start stop [step])
.fi

Foreach can also iterate over a generated range of numbers. There is three typez of dis iteration:


* When specifyin single number, tha range gonna git elements 0 ta "total".


* When specifyin two numbers, tha range gonna git elements from tha straight-up original gangsta number ta tha second number.


* Da third optionizzle number is tha increment used ta iterate from tha straight-up original gangsta number ta tha second number.


.nf
  foreach(loop_var IN [LISTS [list1 [...]]]
                      [ITEMS [item1 [...]]])
.fi

Iterates over a precise list of items.  Da LISTS option names list\-valued variablez ta be traversed, includin empty elements (an empty strang be a zero\-length list).  Da ITEMS option endz argument parsin n' includes all arguments followin it up in tha iteration.

.TP
.B function
Start recordin a gangbangin' function fo' lata invocation as a cold-ass lil command.

.nf
  function(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endfunction(<name>)
.fi

Define a gangbangin' function named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta function yo, but before tha matchin endfunction, is not invoked until tha function is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha function is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha variable ARGC which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ARGV0 ARGV1 ARGV2 ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin functions wit optionizzle arguments fo' realz. Additionally ARGV holdz tha list of all arguments given ta tha function n' ARGN holdz tha list of arguments past tha last expected argument.


A function opens a freshly smoked up scope: peep set(var PARENT_SCOPE) fo' details.


See tha cmake_policy() command documentation fo' tha behavior of policies inside functions.

.TP
.B get_cmake_property
Git a property of tha CMake instance.

.nf
  get_cmake_property(VAR property)
.fi

Git a property from tha CMake instance.  Da value of tha property is stored up in tha variable VAR.  If tha property aint found, VAR is ghon be set ta "NOTFOUND".  Some supported propertizzles include: VARIABLES, CACHE_VARIABLES, COMMANDS, MACROS, n' COMPONENTS.


See also tha mo' general get_property() command.

.TP
.B get_directory_property
Git a property of DIRECTORY scope.

.nf
  get_directory_property(<variable> [DIRECTORY <dir>] <prop\-name>)
.fi

Store a property of directory scope up in tha named variable.  If tha property aint defined tha empty\-strin is returned. Y'all KNOW dat shit, muthafucka!  Da DIRECTORY argument specifies another directory from which ta retrieve tha property value.  Da specified directory must have already been traversed by CMake.


.nf
  get_directory_property(<variable> [DIRECTORY <dir>]
                         DEFINITION <var\-name>)
.fi

Git a variable definizzle from a gangbangin' finger-lickin' directory.  This form is useful ta git a variable definizzle from another directory.


See also tha mo' general get_property() command.

.TP
.B get_filename_component
Git a specific component of a gangbangin' full filename.

.nf
  get_filename_component(<VAR> <FileName> <COMP> [CACHE])
.fi

Set <VAR> ta a cold-ass lil component of <FileName>, where <COMP> is one of:


.nf
 DIRECTORY = Directory without file name
 NAME      = File name without directory
 EXT       = File name longest extension (.b.c from d/a.b.c)
 NAME_WE   = File name without directory or longest extension
 ABSOLUTE  = Full path ta file
 REALPATH  = Full path ta existin file wit symlinks resolved
 PATH      = Legacy alias fo' DIRECTORY (use fo' CMake <= 2.8.11)
.fi

Paths is returned wit forward slashes n' have no trailin slahes. Da longest file extension be always considered. Y'all KNOW dat shit, muthafucka! If tha optionizzle CACHE argument is specified, tha result variable be added ta tha cache.


.nf
  get_filename_component(<VAR> FileName
                         PROGRAM [PROGRAM_ARGS <ARG_VAR>]
                         [CACHE])
.fi

Da program up in FileName is ghon be found up in tha system search path or left as a gangbangin' full path.  If PROGRAM_ARGS is present wit PROGRAM, then any command\-line arguments present up in tha FileName strang is split from tha program name n' stored up in <ARG_VAR>.  This is used ta separate a program name from its arguments up in a cold-ass lil command line string.

.TP
.B get_property
Git a property.

.nf
  get_property(<variable>
               <GLOBAL             |
                DIRECTORY [dir]    |
                TARGET    <target> |
                SOURCE    <source> |
                TEST      <test>   |
                CACHE     <entry>  |
                VARIABLE>
               PROPERTY <name>
               [SET | DEFINED | BRIEF_DOCS | FULL_DOCS])
.fi

Git one property from one object up in a scope.  Da first argument specifies tha variable up in which ta store tha result.  Da second argument determines tha scope from which ta git tha property.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope must name one existin target.


SOURCE scope must name one source file.


TEST scope must name one existin test.


CACHE scope must name one cache entry.


VARIABLE scope is unique n' do not accept a name.


Da required PROPERTY option is immediately followed by tha name of tha property ta get.  If tha property aint set a empty value is returned. Y'all KNOW dat shit, muthafucka!  If tha SET option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been set.  If tha DEFINED option is given tha variable is set ta a funky-ass boolean value indicatin whether tha property has been defined like fuckin wit define_property. If BRIEF_DOCS or FULL_DOCS is given then tha variable is set ta a strang containin documentation fo' tha axed property.  If documentation be axed fo' a property dat has not been defined NOTFOUND is returned.

.TP
.B if
Conditionally execute a crew of commands.

.nf
  if(expression)
    # then section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  elseif(expression2)
    # elseif section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  else(expression)
    # else section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endif(expression)
.fi

Evaluates tha given expression. I aint talkin' bout chicken n' gravy biatch.  If tha result is true, tha commandz up in tha THEN section is invoked. Y'all KNOW dat shit, muthafucka!  Otherwise, tha commandz up in tha else section is invoked. Y'all KNOW dat shit, muthafucka!  Da elseif n' else sections is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Yo ass may have multiple elseif clauses. Note dat tha expression up in tha else n' endif clause is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Long expressions can be used n' there be a traditionizzle order of precedence. Parenthetical expressions is evaluated first followed by unary operators like fuckin EXISTS, COMMAND, n' DEFINED. Then any EQUAL, LESS, GREATER, STRLESS, STRGREATER, STREQUAL, MATCHES is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Then NOT operators n' finally AND, OR operators is ghon be evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Possible expressions are:


.nf
  if(<constant>)
.fi

True if tha constant is 1, ON, YES, TRUE, Y, or a non\-zero number n' shit.  False if tha constant is 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND, '', or endz up in tha suffix '\-NOTFOUND'.  Named boolean constants is case\-insensitive.  If tha argument aint one of these constants, it is treated as a variable:


.nf
  if(<variable>)
.fi

True if tha variable is defined ta a value dat aint a gangbangin' false constant.  False otherwise.  (Note macro arguments is not variables.)


.nf
  if(NOT <expression>)
.fi

True if tha expression aint true.


.nf
  if(<expr1> AND <expr2>)
.fi

True if both expressions would be considered legit individually.


.nf
  if(<expr1> OR <expr2>)
.fi

True if either expression would be considered legit individually.


.nf
  if(COMMAND command\-name)
.fi

True if tha given name be a cold-ass lil command, macro or function dat can be invoked.


.nf
  if(POLICY policy\-id)
.fi

True if tha given name be a existin policy (of tha form CMP<NNNN>).


.nf
  if(TARGET target\-name)
.fi

True if tha given name be a existin target, built or imported.


.nf
  if(EXISTS file\-name)
  if(EXISTS directory\-name)
.fi

True if tha named file or directory exists, n' you can put dat on yo' toast.  Behavior is well\-defined only fo' full paths.


.nf
  if(file1 IS_NEWER_THAN file2)
.fi

True if file1 is newer than file2 or if one of tha two filez don't exist. Behavior is well\-defined only fo' full paths. If tha file time stamps is exactly tha same, a IS_NEWER_THAN comparison returns true, so dat any dependent build operations will occur up in tha event of a tie. This includes tha case of passin tha same file name fo' both file1 n' file2.


.nf
  if(IS_DIRECTORY directory\-name)
.fi

True if tha given name be a gangbangin' finger-lickin' directory.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_SYMLINK file\-name)
.fi

True if tha given name be a symbolic link.  Behavior is well\-defined only fo' full paths.


.nf
  if(IS_ABSOLUTE path)
.fi

True if tha given path be a absolute path.


.nf
  if(<variable|string> MATCHES regex)
.fi

True if tha given strang or variablez value matches tha given regular expression.


.nf
  if(<variable|string> LESS <variable|string>)
  if(<variable|string> GREATER <variable|string>)
  if(<variable|string> EQUAL <variable|string>)
.fi

True if tha given strang or variablez value be a valid number n' tha inequalitizzle or equalitizzle is true.


.nf
  if(<variable|string> STRLESS <variable|string>)
  if(<variable|string> STRGREATER <variable|string>)
  if(<variable|string> STREQUAL <variable|string>)
.fi

True if tha given strang or variablez value is lexicographically less (or pimped outer, or equal) than tha strang or variable on tha right.


.nf
  if(<variable|string> VERSION_LESS <variable|string>)
  if(<variable|string> VERSION_EQUAL <variable|string>)
  if(<variable|string> VERSION_GREATER <variable|string>)
.fi

Component\-wise integer version number comparison (version format is major[.minor[.patch[.tweak]]]).


.nf
  if(DEFINED <variable>)
.fi

True if tha given variable is defined. Y'all KNOW dat shit, muthafucka! Well shiiiit, it do not matta if tha variable is legit or false just if it has been set.


.nf
  if((expression) AND (expression OR (expression)))
.fi

Da expressions inside tha parenthesis is evaluated first n' then tha remainin expression is evaluated as up in tha previous examples. Where there be nested parenthesis tha innermost is evaluated as part of evaluatin tha expression dat gotz nuff em.


Da if command was freestyled straight-up early up in CMakez history, prepimpin tha ${} variable evaluation syntax, n' fo' convenience evaluates variablez named by its arguments as shown up in tha above signatures.  Note dat aiiight variable evaluation wit ${} applies before tha if command even receives tha arguments, n' you can put dat on yo' toast.  Therefore code like


.nf
  set(var1 OFF)
  set(var2 "var1")
  if(${var2})
.fi

appears ta tha if command as


.nf
  if(var1)
.fi

and is evaluated accordin ta tha if(<variable>) case documented above.  Da result is OFF which is false.  But fuck dat shiznit yo, tha word on tha street is dat if we remove tha ${} from tha example then tha command sees


.nf
  if(var2)
.fi

which is legit cuz var2 is defined ta "var1" which aint a gangbangin' false constant.


Automatic evaluation applies up in tha other cases whenever tha above\-documented signature accepts <variable|string>:


1) Da left hand argument ta MATCHES is first checked ta peep if it aint nuthin but a thugged-out defined variable, if so tha variablez value is used, otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


2) If tha left hand argument ta MATCHES is missin it returns false without error 


3) Both left n' right hand arguments ta LESS GREATER EQUAL is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


4) Both left n' right hand arguments ta STRLESS STREQUAL STRGREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


5) Both left n' right hand argumemnts ta VERSION_LESS VERSION_EQUAL VERSION_GREATER is independently tested ta peep if they is defined variables, if so they defined joints is used otherwise tha original gangsta value is used. Y'all KNOW dat shit, muthafucka! 


6) Da right hand argument ta NOT is tested ta peep if it aint nuthin but a funky-ass boolean constant, if so tha value is used, otherwise it be assumed ta be a variable n' it is dereferenced. Y'all KNOW dat shit, muthafucka! 


7) Da left n' right hand arguments ta AND OR is independently tested ta peep if they is boolean constants, if so they is used as such, otherwise they is assumed ta be variablez n' is dereferenced. Y'all KNOW dat shit, muthafucka! 


.TP
.B include
Load n' run CMake code from a gangbangin' file or module.

.nf
  include(<file|module> [OPTIONAL] [RESULT_VARIABLE <VAR>]
                        [NO_POLICY_SCOPE])
.fi

Load n' run CMake code from tha file given. I aint talkin' bout chicken n' gravy biatch.  Variable readz n' writes access tha scope of tha calla (dynamic scoping).  If OPTIONAL is present, then no error is raised if tha file do not exist.  If RESULT_VARIABLE is given tha variable is ghon be set ta tha full filename which has been included or NOTFOUND if it failed.


If a module is specified instead of a gangbangin' file, tha file wit name <modulename>.cmake is searched first up in CMAKE_MODULE_PATH, then up in tha CMake module directory. There is one exception ta this: if tha file which calls include() is located itself up in tha CMake module directory, then first tha CMake module directory is searched n' CMAKE_MODULE_PATH afterwards. Right back up in yo muthafuckin ass. See also policy CMP0017.


See tha cmake_policy() command documentation fo' rap of tha NO_POLICY_SCOPE option.

.TP
.B list
List operations.

.nf
  list(LENGTH <list> <output variable>)
  list(GET <list> <element index> [<element index> ...]
       <output variable>)
  list(APPEND <list> <element> [<element> ...])
  list(FIND <list> <value> <output variable>)
  list(INSERT <list> <element_index> <element> [<element> ...])
  list(REMOVE_ITEM <list> <value> [<value> ...])
  list(REMOVE_AT <list> <index> [<index> ...])
  list(REMOVE_DUPLICATES <list>)
  list(REVERSE <list>)
  list(SORT <list>)
.fi

LENGTH will return a given listz length.


GET will return list of elements specified by indices from tha list.


APPEND will append elements ta tha list.


FIND will return tha index of tha element specified up in tha list or \-1 if it wasn't found.


INSERT will bang elements ta tha list ta tha specified location.


REMOVE_AT n' REMOVE_ITEM will remove shit from tha list. Da difference is dat REMOVE_ITEM will remove tha given items, while REMOVE_AT will remove tha shit all up in tha given indices.


REMOVE_DUPLICATES will remove duplicated shit up in tha list.


REVERSE reverses tha contentz of tha list in\-place.


SORT sorts tha list in\-place alphabetically.


Da list subcommandz APPEND, INSERT, REMOVE_AT, REMOVE_ITEM, REMOVE_DUPLICATES, REVERSE n' SORT may create freshly smoked up joints fo' tha list within tha current CMake variable scope. Right back up in yo muthafuckin ass. Similar ta tha SET command, tha LIST command creates freshly smoked up variable joints up in tha current scope, even if tha list itself is straight-up defined up in a parent scope. To propagate tha thangs up in dis biatch of these operations upwards, use SET wit PARENT_SCOPE, SET wit CACHE INTERNAL, or some other meanz of value propagation.


NOTES: A list up in cmake be a ; separated crew of strings. To create a list tha set command can be used. Y'all KNOW dat shit, muthafucka! For example, set(var a funky-ass b c d e)  creates a list wit a;b;c;d;e, n' set(var "a b c d e") creates a strang or a list wit one item up in dat shit.


When specifyin index joints, if <element index> is 0 or pimped outer, it is indexed from tha beginnin of tha list, wit 0 representin tha straight-up original gangsta list element. If <element index> is \-1 or lesser, it is indexed from tha end of tha list, wit \-1 representin tha last list element. Be careful when countin wit wack indices: they do not start from 0. \-0 is equivalent ta 0, tha straight-up original gangsta list element.


.TP
.B macro
Start recordin a macro fo' lata invocation as a cold-ass lil command.

.nf
  macro(<name> [arg1 [arg2 [arg3 ...]]])
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endmacro(<name>)
.fi

Define a macro named <name> dat takes arguments named arg1 arg2 arg3 (...).  Commandz listed afta macro yo, but before tha matchin endmacro, is not invoked until tha macro is invoked. Y'all KNOW dat shit, muthafucka!  When it is invoked, tha commandz recorded up in tha macro is first modified by replacin formal parametas (${arg1}) wit tha arguments passed, n' then invoked as aiiight commands. In addizzle ta referencin tha formal parametas you can reference tha joints ${ARGC} which is ghon be set ta tha number of arguments passed tha fuck into tha function as well as ${ARGV0} ${ARGV1} ${ARGV2} ... which gonna git tha actual jointz of tha arguments passed in. I aint talkin' bout chicken n' gravy biatch. This facilitates bustin macros wit optionizzle arguments fo' realz. Additionally ${ARGV} holdz tha list of all arguments given ta tha macro n' ${ARGN} holdz tha list of arguments past tha last expected argument. Note dat tha parametas ta a macro n' joints like fuckin ARGN is not variablez up in tha usual CMake sense. They is strang replacements much like tha C preprocessor would do wit a macro. If you want legit CMake variablez and/or betta CMake scope control you should peep tha function command.


See tha cmake_policy() command documentation fo' tha behavior of policies inside macros.

.TP
.B make_directory
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(MAKE_DIRECTORY ) command instead.

.nf
  make_directory(directory)
.fi

Creates tha specified directory.  Full paths should be given. I aint talkin' bout chicken n' gravy biatch.  Any parent directories dat do not exist will also be pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Use wit care.

.TP
.B mark_as_advanced
Mark cmake cached variablez as advanced.

.nf
  mark_as_advanced([CLEAR|FORCE] VAR VAR2 VAR...)
.fi

Mark tha named cached variablez as advanced. Y'all KNOW dat shit, muthafucka!  An advanced variable aint gonna be displayed up in any of tha cmake GUIs unless tha show advanced option is on. I aint talkin' bout chicken n' gravy biatch.  If CLEAR is tha straight-up original gangsta argument advanced variablez is chizzled back ta unadvanced. Y'all KNOW dat shit, muthafucka!  If FORCE is tha straight-up original gangsta argument, then tha variable is made advanced. Y'all KNOW dat shit, muthafucka!  If neither FORCE nor CLEAR is specified, freshly smoked up joints is ghon be marked as advanced yo, but if tha variable already has a advanced/non\-advanced state, it aint gonna be chizzled.


It do not a god damn thang up in script mode.

.TP
.B math
Mathematical expressions.

.nf
  math(EXPR <output variable> <math expression>)
.fi

EXPR evaluates mathematical expression n' returns result up in tha output variable. Example mathematical expression is '5 * ( 10 + 13 )'.  Supported operators is + \- * / % | & ^ ~ << >> * / %.  They have tha same meanin  as they do up in C code.

.TP
.B message
Display a message ta tha user.

.nf
  message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
          "message ta display" ...)
.fi

Da optionizzle keyword determines tha type of message:


.nf
  (none)         = Important shiznit
  STATUS         = Incidental shiznit
  WARNING        = CMake Warning, continue processing
  AUTHOR_WARNING = CMake Warnin (dev), continue processing
  SEND_ERROR     = CMake Error, continue processing,
                                but skip generation
  FATAL_ERROR    = CMake Error, stop processin n' generation
.fi

Da CMake command\-line tool displays STATUS lyrics on stdout n' all other message types on stderr. Shiiit, dis aint no joke.  Da CMake GUI displays all lyrics up in its log area.  Da interactizzle dialogs (ccmake n' CMakeSetup) show STATUS lyrics one at a time on a status line n' other lyrics up in interactizzle pop\-up boxes.


CMake Warnin n' Error message text displays rockin a simple markup language.  Non\-indented text is formatted up in line\-wrapped paragraphs delimited by newlines.  Indented text is considered pre\-formatted.

.TP
.B option
Provides a option dat tha user can optionally select.

.nf
  option(<option_variable> "help strang describin option"
         [initial value])
.fi

Provide a option fo' tha user ta select as ON or OFF.  If no initial value is provided, OFF is used.


If you have options dat depend on tha jointz of other options, peep tha module help fo' CMakeDependentOption.

.TP
.B remove
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha list(REMOVE_ITEM ) command instead.

.nf
  remove(VAR VALUE VALUE ...)
.fi

Removes VALUE from tha variable VAR.  This is typically used ta remove entries from a vector (e.g. semicolon separated list).  VALUE is expanded.

.TP
.B return
Return from a gangbangin' file, directory or function.

.nf
  return()
.fi

Returns from a gangbangin' file, directory or function. I aint talkin' bout chicken n' gravy biatch. When dis command is encountered up in a included file (via include() or find_package()), it causes processin of tha current file ta stop n' control is moonwalked back ta tha includin file. If it is encountered up in a gangbangin' file which aint included by another file, e.g. a CMakeLists.txt, control is moonwalked back ta tha parent directory if there is one. If return is called up in a gangbangin' function, control is moonwalked back ta tha calla of tha function. I aint talkin' bout chicken n' gravy biatch. Note dat a macro aint a gangbangin' function n' do not handle return like a gangbangin' function do.

.TP
.B separate_arguments
Parse space\-separated arguments tha fuck into a semicolon\-separated list.

.nf
  separate_arguments(<var> <UNIX|WINDOWS>_COMMAND "<args>")
.fi

Parses a unix\- or windows\-style command\-line strang "<args>" n' stores a semicolon\-separated list of tha arguments up in <var>.  Da entire command line must be given up in one "<args>" argument.


Da UNIX_COMMAND mode separates arguments by unquoted whitespace.  It recognizes both single\-quote n' double\-quote pairs.  A backslash escapes tha next literal characta (\\" is "); there be no special escapes (\\n is just n).


Da WINDOWS_COMMAND mode parses a windows command\-line rockin tha same syntax tha runtime library uses ta construct argv at startup.  It separates arguments by whitespace dat aint double\-quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  Backslashes is literal unless they precede double\-quotes.  See tha MSDN article "Parsin C Command\-Line Arguments" fo' details.


.nf
  separate_arguments(VARIABLE)
.fi

Convert tha value of VARIABLE ta a semi\-colon separated list.  All spaces is replaced wit ';'.  This helps wit generatin command lines.

.TP
.B set
Set a CMake, cache or environment variable ta a given value.

.nf
  set(<variable> <value>
      [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
.fi

Within CMake sets <variable> ta tha value <value>.  <value> is expanded before <variable> is set ta dat shit.  Normally, set will set a regular CMake variable. If CACHE is present, then tha <variable> is put up in tha cache instead, unless it be already up in tha cache. Right back up in yo muthafuckin ass. See section 'Variable types up in CMake' below fo' detailz of regular n' cache variablez n' they interactions. If CACHE is used, <type> n' <docstring> is required. Y'all KNOW dat shit, muthafucka! <type> is used by tha CMake GUI ta chizzle a widget wit which tha user sets a value. Da value fo' <type> may be one of


.nf
  FILEPATH = File chizzla dialog.
  PATH     = Directory chizzla dialog.
  STRING   = Arbitrary string.
  BOOL     = Boolean ON/OFF checkbox.
  INTERNAL = No GUI entry (used fo' persistent variables).
.fi

If <type> is INTERNAL, tha cache variable is marked as internal, n' aint gonna be shown ta tha user up in tools like cmake\-gui. This is intended fo' joints dat should be persisted up in tha cache yo, but which playas should not normally chizzle. INTERNAL implies FORCE.


Normally, set(...CACHE...) creates cache variablez yo, but do not modify em. If FORCE is specified, tha value of tha cache variable is set, even if tha variable be already up in tha cache. This should normally be avoided, as it will remove any chizzlez ta tha cache variablez value by tha user.


If PARENT_SCOPE is present, tha variable is ghon be set up in tha scope above tha current scope. Each freshly smoked up directory or function creates a freshly smoked up scope. This command will set tha value of a variable tha fuck into tha parent directory or callin function (whichever be applicable ta tha case at hand). PARENT_SCOPE cannot be combined wit CACHE.


If <value> aint specified then tha variable is removed instead of set.  See also: tha unset() command.


.nf
  set(<variable> <value1> ... <valueN>)
.fi

In dis case <variable> is set ta a semicolon separated list of joints.


<variable> can be a environment variable such as:


.nf
  set( ENV{PATH} /home/martink )
.fi

in which case tha environment variable is ghon be set.


*** Variable types up in CMake ***


In CMake there be two typez of variables: aiiight variablez n' cache variables. Normal variablez is meant fo' tha internal use of tha script (just like variablez up in most programmin languages); they is not persisted across CMake runs. Cache variablez (unless set wit INTERNAL) is mostly intended fo' configuration settings where tha straight-up original gangsta CMake run determines a suitable default value, which tha user can then override, by editin tha cache wit tools like fuckin ccmake or cmake\-gui. Cache variablez is stored up in tha CMake cache file, n' is persisted across CMake runs. 


Both types can exist all up in tha same time wit tha same name but different joints, n' you can put dat on yo' toast. When ${FOO} is evaluated, CMake first looks fo' a aiiight variable 'FOO' up in scope n' uses it if set. If n' only if no aiiight variable exists then it falls back ta tha cache variable 'FOO'.


Some examples:


Da code 'set(FOO "x")' sets tha aiiight variable 'FOO'. Well shiiiit, it do not bust a nut on tha cache yo, but it will hide any existin cache value 'FOO'.


Da code 'set(FOO "x" CACHE ...)' checks fo' 'FOO' up in tha cache, ignorin any aiiight variable of tha same name. If 'FOO' is up in tha cache then not a god damn thang happens ta either tha aiiight variable or tha cache variable. If 'FOO' aint up in tha cache, then it be added ta tha cache.


Finally, whenever a cold-ass lil cache variable be added or modified by a cold-ass lil command, CMake also *removes* tha aiiight variable of tha same name from tha current scope so dat a immediately followin evaluation of it will expose tha newly cached value.


Normally projects should avoid rockin aiiight n' cache variablez of tha same name, as dis interaction can be hard ta follow. But fuck dat shiznit yo, tha word on tha street is dat up in some thangs it can be useful naaahhmean? One example (used by some projects):


A project has a subproject up in its source tree. Da lil pimp project has its own CMakeLists.txt, which is included from tha parent CMakeLists.txt rockin add_subdirectory(). Now, if tha parent n' tha lil pimp project provide tha same option (for example a cold-ass lil compila option), tha parent gets tha straight-up original gangsta chizzle ta add a user\-editable option ta tha cache. Normally, tha lil pimp would then use tha same value dat tha parent uses. But fuck dat shiznit yo, tha word on tha street is dat it may be necessary ta hard\-code tha value fo' tha lil pimp projectz option while still allowin tha user ta edit tha value used by tha parent project. Da parent project can bust dis simply by settin a aiiight variable wit tha same name as tha option up in a scope sufficient ta hide tha optionz cache variable from tha lil pimp straight-up. Da parent has already set tha cache variable,  so tha childz set(...CACHE...) will do nothing, n' evaluatin tha option variable will use tha value from tha aiiight variable, which hides tha cache variable.

.TP
.B set_directory_properties
Set a property of tha directory.

.nf
  set_directory_properties(PROPERTIES prop1 value1 prop2 value2)
.fi

Set a property fo' tha current directory n' subdirectories. Put ya muthafuckin choppers up if ya feel dis! If tha property aint found, CMake will report a error. Shiiit, dis aint no joke. Da propertizzles include: INCLUDE_DIRECTORIES, LINK_DIRECTORIES, INCLUDE_REGULAR_EXPRESSION, n' ADDITIONAL_MAKE_CLEAN_FILES fo' realz. ADDITIONAL_MAKE_CLEAN_FILES be a list of filez dat is ghon be cleaned as a part of "make clean" stage.

.TP
.B set_property
Set a named property up in a given scope.

.nf
  set_property(<GLOBAL                            |
                DIRECTORY [dir]                   |
                TARGET    [target1 [target2 ...]] |
                SOURCE    [src1 [src2 ...]]       |
                TEST      [test1 [test2 ...]]     |
                CACHE     [entry1 [entry2 ...]]>
               [APPEND] [APPEND_STRING]
               PROPERTY <name> [value1 [value2 ...]])
.fi

Set one property on zero or mo' objectz of a scope.  Da first argument determines tha scope up in which tha property is set.  It must be one of tha following:


GLOBAL scope is unique n' do not accept a name.


DIRECTORY scope defaults ta tha current directory but another directory (already processed by CMake) may be named by full or relatizzle path.


TARGET scope may name zero or mo' existin targets.


SOURCE scope may name zero or mo' source files.  Note dat source file propertizzles is visible only ta targets added up in tha same directory (CMakeLists.txt).


TEST scope may name zero or mo' existin tests.


CACHE scope must name zero or mo' cache existin entries.


Da required PROPERTY option is immediately followed by tha name of tha property ta set.  Remainin arguments is used ta compose tha property value up in tha form of a semicolon\-separated list.  If tha APPEND option is given tha list be appended ta any existin property value.If tha APPEND_STRING option is given tha strang be append ta any existin property value as string, i.e. it thangs up in dis biatch up in a longer strang n' not a list of strings.

.TP
.B crib_name
Set tha given variable ta tha name of tha computer.

.nf
  crib_name(variable)
.fi

.TP
.B string
Strin operations.

.nf
  string(REGEX MATCH <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX MATCHALL <regular_expression>
         <output variable> <input> [<input>...])
  string(REGEX REPLACE <regular_expression>
         <replace_expression> <output variable>
         <input> [<input>...])
  string(REPLACE <match_string>
         <replace_string> <output variable>
         <input> [<input>...])
  string(<MD5|SHA1|SHA224|SHA256|SHA384|SHA512>
         <output variable> <input>)
  string(COMPARE EQUAL <string1> <string2> <output variable>)
  string(COMPARE NOTEQUAL <string1> <string2> <output variable>)
  string(COMPARE LESS <string1> <string2> <output variable>)
  string(COMPARE GREATER <string1> <string2> <output variable>)
  string(ASCII <number> [<number> ...] <output variable>)
  string(CONFIGURE <string1> <output variable>
         [@ONLY] [ESCAPE_QUOTES])
  string(TOUPPER <string1> <output variable>)
  string(TOLOWER <string1> <output variable>)
  string(LENGTH <string> <output variable>)
  string(SUBSTRING <string> <begin> <length> <output variable>)
  string(STRIP <string> <output variable>)
  string(RANDOM [LENGTH <length>] [ALPHABET <alphabet>]
         [RANDOM_SEED <seed>] <output variable>)
  string(FIND <string> <substring> <output variable> [REVERSE])
  string(TIMESTAMP <output variable> [<format string>] [UTC])
  string(MAKE_C_IDENTIFIER <input string> <output variable>)
.fi

REGEX MATCH will match tha regular expression once n' store tha match up in tha output variable.


REGEX MATCHALL will match tha regular expression as nuff times as possible n' store tha matches up in tha output variable as a list.


REGEX REPLACE will match tha regular expression as nuff times as possible n' substitute tha replacement expression fo' tha match up in tha output.  Da replace expression may refer ta paren\-delimited subexpressionz of tha match rockin \\1, \\2, ..., \\9.  Note dat two backslashes (\\\\1) is required up in CMake code ta git a funky-ass backslash all up in argument parsing.


REPLACE will replace all occurrencez of match_strin up in tha input wit replace_strin n' store tha result up in tha output.


MD5, SHA1, SHA224, SHA256, SHA384, n' SHA512 will compute a cold-ass lil cryptographic hash of tha input string.


COMPARE EQUAL/NOTEQUAL/LESS/GREATER will compare tha strings n' store legit or false up in tha output variable.


ASCII'ma convert all numbers tha fuck into correspondin ASCII characters.


CONFIGURE will transform a strang like CONFIGURE_FILE transforms a gangbangin' file.


TOUPPER/TOLOWER will convert strang ta upper/lower characters.


LENGTH will return a given stringz length.


SUBSTRING will return a substrin of a given string. If length is \-1 tha remainder of tha strang startin at begin is ghon be returned.


STRIP will return a substrin of a given strang wit leadin n' trailin spaces removed.


RANDOM will return a random strang of given length consistin of charactas from tha given alphabet. Default length is 5 charactas n' default alphabet be all numbers n' upper n' lower case letters.  If a integer RANDOM_SEED is given, its value is ghon be used ta seed tha random number generator.


FIND will return tha posizzle where tha given substrin was found up in tha supplied string. If tha REVERSE flag was used, tha command will search fo' tha posizzle of tha last occurrence of tha specified substring.


Da followin charactas have special meanin up in regular expressions:


.nf
   ^         Matches at beginnin of input
   $         Matches at end of input
   .         Matches any single character
   [ ]       Matches any character(s) inside tha brackets
   [^ ]      Matches any character(s) not inside tha brackets
    \-        Inside brackets, specifies a inclusive range between
             charactas on either side e.g. [a\-f] is [abcdef]
             To match a literal \- rockin brackets, make it tha first
             or tha last characta e.g. [+*/\-] matches basic
             mathematical operators.
   *         Matches precedin pattern zero or mo' times
   +         Matches precedin pattern one or mo' times
   ?         Matches precedin pattern zero or once only
   |         Matches a pattern on either side of tha |
   ()        Saves a matched subexpression, which can be referenced 
             up in tha REGEX REPLACE operation. I aint talkin' bout chicken n' gravy biatch fo' realz. Additionally it is saved
             by all regular expression\-related commands, includin 
             e.g. if( MATCHES ), up in tha variablez CMAKE_MATCH_(0..9).
.fi

*, + n' ? have higher precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. | has lower precedence than concatenation. I aint talkin' bout chicken n' gravy biatch. This means dat tha regular expression "^ab+d$" matches "abbd" but not "ababd", n' tha regular expression "^(ab|cd)$" matches "ab" but not "abd".


TIMESTAMP will write a strang representation of tha current date and/or time ta tha output variable.


Should tha command be unable ta obtain a timestamp tha output variable is ghon be set ta tha empty strang "".


Da optionizzle UTC flag requests tha current date/time representation ta be up in Coordinated Universal Time (UTC) rather than local time.


Da optionizzle <format string> may contain tha followin format specifiers: 


.nf
   %d        Da dizzle of tha current month (01\-31).
   %H        Da minute on a 24\-hour clock (00\-23).
   %I        Da minute on a 12\-hour clock (01\-12).
   %j        Da dizzle of tha current year (001\-366).
   %m        Da month of tha current year (01\-12).
   %M        Da minute of tha current minute (00\-59).
   %S        Da second of tha current minute.
             60 represents a leap second. Y'all KNOW dat shit, muthafucka! (00\-60)
   %U        Da week number of tha current year (00\-53).
   %w        Da dizzle of tha current week. 0 is Sunday. It make me wanna hollar playa! (0\-6)
   %y        Da last two digitz of tha current year (00\-99)
   %Y        Da current year. Shiiit, dis aint no joke. 
.fi

Unknown format specifiers is ghon be ignored n' copied ta tha output as\-is.


If no explicit <format string> is given it will default to:


.nf
   %Y\-%m\-%dT%H:%M:%S    fo' local time.
   %Y\-%m\-%dT%H:%M:%SZ   fo' UTC.
.fi

MAKE_C_IDENTIFIER will write a strang which can be used as a identifier up in C.

.TP
.B unset
Unset a variable, cache variable, or environment variable.

.nf
  unset(<variable> [CACHE])
.fi

Removes tha specified variable causin it ta become undefined. Y'all KNOW dat shit, muthafucka!  If CACHE is present then tha variable is removed from tha cache instead of tha current scope.


<variable> can be a environment variable such as:


.nf
  unset(ENV{LD_LIBRARY_PATH})
.fi

in which case tha variable is ghon be removed from tha current environment.

.TP
.B use_mangled_mesa
Copy mesa headaz fo' use up in combination wit system GL.

.nf
  use_mangled_mesa(PATH_TO_MESA OUTPUT_DIRECTORY)
.fi

Da path ta mesa includes, should contain gl_mangle.h.  Da mesa headaz is copied ta tha specified output directory.  This allows mangled mesa headaz ta override other GL headaz by bein added ta tha include directory path earlier.

.TP
.B variable_watch
Watch tha CMake variable fo' chizzle.

.nf
  variable_watch(<variable name> [<command ta execute>])
.fi

If tha specified variable chizzles, tha message is ghon be printed bout tha variable bein chizzled. Y'all KNOW dat shit, muthafucka! If tha command is specified, tha command is ghon be executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Da command will receive tha followin arguments: COMMAND(<variable> <access> <value> <current list file> <stack>)

.TP
.B while
Evaluate a crew of commandz while a cold-ass lil condizzle is true

.nf
  while(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
  endwhile(condition)
.fi

All commandz between while n' tha matchin endwhile is recorded without bein invoked. Y'all KNOW dat shit, muthafucka!  Once tha endwhile is evaluated, tha recorded list of commandz is invoked as long as tha condizzle is true. Da condizzle is evaluated rockin tha same logic as tha if command.

.TP
.B write_file
Deprecated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Use tha file(WRITE ) command instead.

.nf
  write_file(filename "message ta write"... [APPEND])
.fi

Da first argument is tha file name, tha rest of tha arguments is lyrics ta write. If tha argument APPEND is specified, then tha message is ghon be appended.


NOTE 1: file(WRITE ... n' file(APPEND ... do exactly tha same as dis one but add some mo' functionality.


NOTE 2: When rockin write_file tha produced file cannot be used as a input ta CMake (CONFIGURE_FILE, source file ...) cuz it will lead ta a infinite loop. Use configure_file if you wanna generate input filez ta CMake.

.SH PROPERTIES
.PP
.nf
  CMake Propertizzles \- Propertizzles supported by CMake, tha Cross\-Platform Makefile Generator.
.fi

.PP
This is tha documentation fo' tha propertizzles supported by CMake. Propertizzles can have different scopes. They can either be assigned ta a source file, a gangbangin' finger-lickin' directory, a target or globally ta CMake. By modifyin tha jointz of propertizzles tha behaviour of tha build system can be customized.

.SH COMPATIBILITY COMMANDS
.PP
.nf
  CMake Compatibilitizzle Listfile Commandz \- Obsolete commandz supported by CMake fo' compatibility.
.fi

.PP
This is tha documentation fo' now obsolete listfile commandz from previous CMake versions, which is still supported fo' compatibilitizzle reasons. Yo ass should instead use tha newer, fasta n' shinier freshly smoked up commands. ;\-)

.SH MODULES
.SH COPYRIGHT
.PP
Copyright 2000\-2012 Kitware, Inc., Insight Software Consortium.  All muthafuckin rights reserved.

.PP
Redistribution n' use up in source n' binary forms, wit or without modification, is permitted provided dat tha followin conditions is met:

.PP
Redistributionz of source code must retain tha above copyright notice, dis list of conditions n' tha followin disclaimer.

.PP
Redistributions up in binary form must reproduce tha above copyright notice, dis list of conditions n' tha followin disclaimer up in tha documentation and/or other shiznit provided wit tha distribution.

.PP
Neither tha namez of Kitware, Inc., tha Insight Software Consortium, nor tha namez of they contributors may be used ta endorse or promote shizzle derived from dis software without specific prior freestyled permission.

.PP
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

.SH SEE ALSO
.PP
.B cmake(1), ccmake(1)

.PP
Da followin resources is available ta git help rockin CMake:

.TP
.B Home Page
http://www.cmake.org

Da primary startin point fo' peepin' bout CMake.

.TP
.B Frequently Axed Questions
http://www.cmake.org/Wiki/CMake_FAQ

A Wiki is provided containin lyrics ta frequently axed thangs. 

.TP
.B Online Documentation
http://www.cmake.org/HTML/Documentation.html

Links ta available documentation may be found on dis wizzy page.

.TP
.B Mailin List
http://www.cmake.org/HTML/MailingLists.html

For help n' rap bout rockin cmake, a mailin list is provided at cmake@cmake.org. Da list is member\-post\-only but one may sign up on tha CMake wizzy page. Please first read tha full documentation at http://www.cmake.org before postin thangs ta tha list.

.SH AUTHOR
.PP
This manual page was generated by tha "\-\-help\-man" option.

