.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ7 1"
.TH PERLFAQ7 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq7 \- General Perl Language Issues
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section deals wit general Perl language thangs dat don't
clearly fit tha fuck into any of tha other sections.
.SS "Can I git a BNF/yacc/RE fo' tha Perl language?"
.IX Subsection "Can I git a BNF/yacc/RE fo' tha Perl language?"
There is no \s-1BNF,\s0 but you can paw yo' way all up in tha yacc grammar in
perly.y up in tha source distribution if you particularly brave. The
grammar relies on straight-up smart-ass tokenizin code, so be prepared to
venture tha fuck into toke.c as well.
.PP
In tha lyrics of Chaim Frenkel: \*(L"Perlz grammar can not be reduced ta \s-1BNF.\s0
Da work of parsin perl is distributed between yacc, tha lexer, smoke
and mirrors.\*(R"
.SS "What is all these $@%&* punctuation signs, n' how tha fuck do I know when ta use them?"
.IX Subsection "What is all these $@%&* punctuation signs, n' how tha fuck do I know when ta use them?"
They is type specifiers, as detailed up in perldata:
.PP
.Vb 6
\&    $ fo' scalar joints (number, strang or reference)
\&    @ fo' arrays
\&    % fo' hashes (associatizzle arrays)
\&    & fo' subroutines (aka functions, procedures, methods)
\&    * fo' all typez of dat symbol name. In version 4 you used dem like
\&      pointas yo, but up in modern perls you can just use references.
.Ve
.PP
There is a cold-ass lil couple other symbols that
yo ass is likely ta encounta dat aren't
really type specifiers:
.PP
.Vb 2
\&    <> is used fo' inputtin a record from a gangbangin' filehandle.
\&    \e  takes a reference ta something.
.Ve
.PP
Note dat <\s-1FILE\s0> is \fIneither\fR tha type specifier fo' files
nor tha name of tha handle. Well shiiiit, it is tha \f(CW\*(C`<>\*(C'\fR operator applied
to tha handle \s-1FILE.\s0 It readz one line (well, record\*(--see
\&\*(L"$/\*(R" up in perlvar) from tha handle \s-1FILE\s0 up in scalar context, or \fIall\fR lines
in list context. When struttin open, close, or any other operation
besides \f(CW\*(C`<>\*(C'\fR on files, or even when rappin' bout tha handle, do
\&\fInot\fR use tha brackets, n' you can put dat on yo' toast. These is erect: \f(CW\*(C`eof(FH)\*(C'\fR, \f(CW\*(C`seek(FH, 0,
2)\*(C'\fR n' \*(L"copyin from \s-1STDIN\s0 ta \s-1FILE\*(R".\s0
.SS "Do I always/never gotta quote mah strings or use semicolons n' commas?"
.IX Subsection "Do I always/never gotta quote mah strings or use semicolons n' commas?"
Normally, a funky-ass bareword don't need ta be quoted yo, but up in most cases
probably should be (and must be under \f(CW\*(C`use strict\*(C'\fR). But a hash key
consistin of a simple word n' tha left-hand
operand ta tha \f(CW\*(C`=>\*(C'\fR operator both
count as though they was quoted:
.PP
.Vb 4
\&    This                    is like this
\&    \-\-\-\-\-\-\-\-\-\-\-\-            \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    $foo{line}              $foo{\*(Aqline\*(Aq}
\&    bar => shiznit            \*(Aqbar\*(Aq => stuff
.Ve
.PP
Da final semicolon up in a funky-ass block is optional, as is tha final comma up in a
list. Dope steez (see perlstyle) say ta put dem up in except for
one-liners:
.PP
.Vb 2
\&    if ($whoops) { exit 1 }
\&    mah @nums = (1, 2, 3);
\&
\&    if ($whoops) {
\&        exit 1;
\&    }
\&
\&    mah @lines = (
\&        "There Beren came from mountains cold",
\&        "And lost da thug wandered under leaves",
\&    );
.Ve
.SS "How tha fuck do I skip some return joints?"
.IX Subsection "How tha fuck do I skip some return joints?"
One way is ta treat tha return joints as a list n' index tha fuck into it:
.PP
.Vb 1
\&    $dir = (getpwnam($user))[7];
.Ve
.PP
Another way is ta use undef as a element on tha left-hand-side:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
Yo ass can also bust a list slice ta select only tha elements that
you need:
.PP
.Vb 1
\&    ($dev, $ino, $uid, $gid) = ( stat($file) )[0,1,4,5];
.Ve
.SS "How tha fuck do I temporarily block warnings?"
.IX Subsection "How tha fuck do I temporarily block warnings?"
If yo ass is hustlin Perl 5.6.0 or better, tha \f(CW\*(C`use warnings\*(C'\fR pragma
allows fine control of what tha fuck warnings is produced.
See perllexwarn fo' mo' details.
.PP
.Vb 4
\&    {
\&        no warnings;          # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Additionally, you can enable n' disable categoriez of warnings.
Yo ass turn off tha categories you wanna ignore n' you can still
get other categoriez of warnings. Right back up in yo muthafuckin ass. See perllexwarn fo' the
complete details, includin tha category names n' hierarchy.
.PP
.Vb 4
\&    {
\&        no warnings \*(Aquninitialized\*(Aq;
\&        $x = $y + $z;
\&    }
.Ve
.PP
If you have a olda version of Perl, tha \f(CW$^W\fR variable (documented
in perlvar) controls runtime warnings fo' a funky-ass block:
.PP
.Vb 4
\&    {
\&        local $^W = 0;        # temporarily turn off warnings
\&        $x = $y + $z;         # I know these might be undef
\&    }
.Ve
.PP
Note dat like all tha punctuation variables, you cannot currently
use \fImy()\fR on \f(CW$^W\fR, only \fIlocal()\fR.
.SS "Whatz a extension?"
.IX Subsection "Whatz a extension?"
An extension be a way of callin compiled C code from Perl. Reading
perlxstut be a phat place ta learn mo' bout extensions.
.SS "Why do Perl operators have different precedence than C operators?"
.IX Subsection "Why do Perl operators have different precedence than C operators?"
Actually, they don't fo' realz. All C operators dat Perl copies have tha same
precedence up in Perl as they do up in C. Da problem is wit operators dat C
doesn't have, especially functions dat give a list context ta every last muthafuckin thang
on they right, eg. print, chmod, exec, n' so on. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. Such functions are
called \*(L"list operators\*(R" n' step tha fuck up as such up in tha precedence table in
perlop.
.PP
A common fuck up is ta write:
.PP
.Vb 1
\&    unlink $file || take a thugged-out dirtnap "snafu";
.Ve
.PP
This gets interpreted as:
.PP
.Vb 1
\&    unlink ($file || take a thugged-out dirtnap "snafu");
.Ve
.PP
To avoid dis problem, either put up in extra parentheses or use the
supa low precedence \f(CW\*(C`or\*(C'\fR operator:
.PP
.Vb 2
\&    (unlink $file) || take a thugged-out dirtnap "snafu";
\&    unlink $file or take a thugged-out dirtnap "snafu";
.Ve
.PP
Da \*(L"English\*(R" operators (\f(CW\*(C`and\*(C'\fR, \f(CW\*(C`or\*(C'\fR, \f(CW\*(C`xor\*(C'\fR, n' \f(CW\*(C`not\*(C'\fR)
deliberately have precedence lower than dat of list operators for
just such thangs as tha one above.
.PP
Another operator wit surprisin precedence is exponentiation. I aint talkin' bout chicken n' gravy biatch. It
bindz mo' tightly even than unary minus, makin \f(CW\*(C`\-2**2\*(C'\fR produce a
negatizzle four n' not a positizzle one. Well shiiiit, it be also right-associating, meaning
that \f(CW\*(C`2**3**2\*(C'\fR is two raised ta tha ninth power, not eight squared.
.PP
Although it has tha same ol' dirty precedence as up in C, Perlz \f(CW\*(C`?:\*(C'\fR operator
produces a lvalue. This assigns \f(CW$x\fR ta either \f(CW$if_true\fR or \f(CW$if_false\fR, depending
on tha truenizz of \f(CW$maybe:\fR
.PP
.Vb 1
\&    ($maybe , biatch? $if_true : $if_false) = $x;
.Ve
.SS "How tha fuck do I declare/create a structure?"
.IX Subsection "How tha fuck do I declare/create a structure?"
In general, you don't \*(L"declare\*(R" a structure. Just bust a (probably
anonymous) hash reference. Right back up in yo muthafuckin ass. See perlref n' perldsc fo' details.
Herez a example:
.PP
.Vb 3
\&    $thug = {};                   # freshly smoked up anonymous hash
\&    $person\->{AGE}  = 24;           # set field AGE ta 24
\&    $person\->{NAME} = "Nat";        # set field NAME ta "Nat"
.Ve
.PP
If you lookin fo' suttin' a lil' bit mo' rigorous, try perltoot.
.SS "How tha fuck do I create a module?"
.IX Subsection "How tha fuck do I create a module?"
perlnewmod be a phat place ta start, ignore tha bits
about uploadin ta \s-1CPAN\s0 if you don't wanna make your
module publicly available.
.PP
ExtUtils::ModuleMaker n' Module::Starta is also
phat places ta start. Many \s-1CPAN\s0 authors now use Dist::Zilla
to automate as much as possible.
.PP
Detailed documentation bout modulez can be found at:
perlmod, perlmodlib, perlmodstyle.
.PP
If you need ta include C code or C library intercourses 
use h2xs. h2xs will create tha module distribution structure 
and tha initial intercourse files.
perlxs n' perlxstut explain tha details.
.SS "How tha fuck do I adopt or take over a module already on \s-1CPAN\s0?"
.IX Subsection "How tha fuck do I adopt or take over a module already on CPAN?"
Ask tha current maintainer ta make you a cold-ass lil co-maintainer or
transfer tha module ta yo thugged-out ass.
.PP
If you can not reach tha lyricist fo' some reason contact
the \s-1PAUSE\s0 admins at modules@perl.org whoz ass may be able ta help,
but each case it treated seperatly.
.IP "\(bu" 4
Git a login fo' tha Perl Authors Upload Server (\s-1PAUSE\s0) if you don't
already have one: <http://pause.perl.org>
.IP "\(bu" 4
Write ta modules@perl.org explainin what tha fuck you did ta contact the
current maintainer n' shit. Da \s-1PAUSE\s0 admins will also try ta reach the
maintainer.
.IP "\(bu" 4
Post a hood message up in a heavily trafficked joint announcin your
intention ta take over tha module.
.IP "\(bu" 4
Wait a funky-ass bit. Da \s-1PAUSE\s0 admins don't wanna act too quickly up in case
the current maintainer is on holiday. It make me wanna hollar playa! If there be a no response to
private communication or tha hood post, a \s-1PAUSE\s0 admin can transfer
it ta yo thugged-out ass.
.SS "How tha fuck do I create a cold-ass lil class?"
.IX Xref "class, creation package"
.IX Subsection "How tha fuck do I create a cold-ass lil class?"
(contributed by brian d foy)
.PP
In Perl, a cold-ass lil class is just a package, n' methodz is just subroutines.
Perl don't git mo' formal than dat n' lets you set up tha package
just tha way dat you like it (that is, it don't set up anythang for
you).
.PP
Da Perl documentation has nuff muthafuckin tutorials dat cover class
creation, includin perlboot (Barnyard Object Oriented Tutorial),
perltoot (Tomz Object Oriented Tutorial), perlbot (Bag o'
Object Tricks), n' perlobj.
.SS "How tha fuck can I tell if a variable is tainted?"
.IX Subsection "How tha fuck can I tell if a variable is tainted?"
Yo ass can use tha \fItainted()\fR function of tha Scalar::Util module, available
from \s-1CPAN \s0(or included wit Perl since release 5.8.0).
See also \*(L"Launderin n' Detectin Tainted Data\*(R" up in perlsec.
.SS "Whatz a cold-ass lil closure?"
.IX Subsection "Whatz a cold-ass lil closure?"
Closures is documented up in perlref.
.PP
\&\fIClosure\fR be a cold-ass lil computa science term wit a precise but
hard-to-explain meaning. Usually, closures is implemented up in Perl as
anonymous subroutines wit lastin references ta lexical variables
outside they own scopes. These lexicals magically refer ta the
variablez dat was round when tha subroutine was defined (deep
binding).
.PP
Closures is most often used up in programmin languages where you can
have tha return value of a gangbangin' function be itself a gangbangin' function, as you can
in Perl. Note dat some languages provide anonymous functions but are
not capable of providin proper closures: tha Python language, for
example. For mo' shiznit on closures, check up any textbook on
functionizzle programming. Right back up in yo muthafuckin ass. Scheme be a language dat not only supports
but encourages closures.
.PP
Herez a cold-ass lil funky-ass non-closure function-generatin function:
.PP
.Vb 3
\&    sub add_function_generator {
\&        return sub { shift() + shift() };
\&    }
\&
\&    mah $add_sub = add_function_generator();
\&    mah $sum = $add_sub\->(4,5);                # $sum is 9 now, nahmeean?
.Ve
.PP
Da anonymous subroutine returned by \fIadd_function_generator()\fR aint
technologically a cold-ass lil closure cuz it refers ta no lexicals outside its own
scope. Usin a cold-ass lil closure gives you a \fIfunction template\fR wit some
customization slots left up ta be filled later.
.PP
Contrast dis wit tha followin \fImake_adder()\fR function, up in which the
returned anonymous function gotz nuff a reference ta a lexical variable
outside tha scope of dat function itself. Right back up in yo muthafuckin ass. Such a reference requires
that Perl return a proper closure, thus lockin up in fo' all time the
value dat tha lexical had when tha function was pimped.
.PP
.Vb 4
\&    sub make_adder {
\&        mah $addpiece = shift;
\&        return sub { shift() + $addpiece };
\&    }
\&
\&    mah $f1 = make_adder(20);
\&    mah $f2 = make_adder(555);
.Ve
.PP
Now \f(CW\*(C`$f1\->($n)\*(C'\fR be always 20 plus whatever \f(CW$n\fR you pass in, whereas
\&\f(CW\*(C`$f2\->($n)\*(C'\fR be always 555 plus whatever \f(CW$n\fR you pass in. I aint talkin' bout chicken n' gravy biatch. Da \f(CW$addpiece\fR
in tha closure sticks around.
.PP
Closures is often used fo' less esoteric purposes. For example, when
you wanna pass up in a lil' bit of code tha fuck into a gangbangin' function:
.PP
.Vb 2
\&    mah $line;
\&    timeout( 30, sub { $line = <STDIN> } );
.Ve
.PP
If tha code ta execute had been passed up in as a string,
\&\f(CW\*(Aq$line = <STDIN>\*(Aq\fR, there would done been no way fo' the
hypothetical \fItimeout()\fR function ta access tha lexical variable
\&\f(CW$line\fR back up in its callerz scope.
.PP
Another use fo' a cold-ass lil closure is ta cook up a variable \fIprivate\fR ta a
named subroutine, e.g. a cold-ass lil counta dat gets initialized at creation
time of tha sub n' can only be modified from within tha sub.
This is sometimes used wit a \s-1BEGIN\s0 block up in package filez ta make
sure a variable don't git meddled wit durin tha gametime of the
package:
.PP
.Vb 4
\&    BEGIN {
\&        mah $id = 0;
\&        sub next_id { ++$id }
\&    }
.Ve
.PP
This is discussed up in mo' detail up in perlsub; peep tha entry on
\&\fIPersistent Private Variables\fR.
.SS "What tha fuck iz variable suicizzle n' how tha fuck can I prevent it?"
.IX Subsection "What tha fuck iz variable suicizzle n' how tha fuck can I prevent it?"
This problem was fixed up in perl 5.004_05, so preventin it means upgrading
your version of perl. ;)
.PP
Variable suicizzle is when you (temporarily or permanently) lose tha value
of a variable. Well shiiiit, it is caused by scopin all up in \fImy()\fR n' \fIlocal()\fR
interactin wit either closures or aliased \fIforeach()\fR iterator variables
and subroutine arguments, n' you can put dat on yo' toast. Well shiiiit, it used ta be easy as fuck  ta inadvertently lose a
variablez value dis way yo, but now itz much harder n' shit. Take dis code:
.PP
.Vb 4
\&    mah $f = \*(Aqfoo\*(Aq;
\&    sub T {
\&        while ($i++ < 3) { mah $f = $f; $f .= "bar"; print $f, "\en" }
\&    }
\&
\&    T;
\&    print "Finally $f\en";
.Ve
.PP
If yo ass is fuckin wit variable suicide, dat \f(CW\*(C`my $f\*(C'\fR up in tha subroutine
doesn't pick up a gangbangin' fresh copy of tha \f(CW$f\fR whose value is \f(CW\*(Aqfoo\*(Aq\fR. The
output shows dat inside tha subroutine tha value of \f(CW$f\fR leaks through
when it shouldn't, as up in dis output:
.PP
.Vb 4
\&    foobar
\&    foobarbar
\&    foobarbarbar
\&    Finally foo
.Ve
.PP
Da \f(CW$f\fR dat has \*(L"bar\*(R" added ta it three times should be a freshly smoked up \f(CW$f\fR
\&\f(CW\*(C`my $f\*(C'\fR should create a freshly smoked up lexical variable each time all up in tha loop.
Da expected output is:
.PP
.Vb 4
\&    foobar
\&    foobar
\&    foobar
\&    Finally foo
.Ve
.SS "How tha fuck can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
.IX Subsection "How tha fuck can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?"
Yo ass need ta pass references ta these objects, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. See \*(L"Pass by
Reference\*(R" up in perlsub fo' dis particular question, n' perlref for
information on references.
.IP "Passin Variablez n' Functions" 4
.IX Item "Passin Variablez n' Functions"
Regular variablez n' functions is like easy as fuck  ta pass: just pass up in a
reference ta a existin or anonymous variable or function:
.Sp
.Vb 1
\&    func( \e$some_scalar );
\&
\&    func( \e@some_array  );
\&    func( [ 1 .. 10 ]   );
\&
\&    func( \e%some_hash   );
\&    func( { dis => 10, dat => 20 }   );
\&
\&    func( \e&some_func   );
\&    func( sub { $_[0] ** $_[1] }   );
.Ve
.IP "Passin Filehandles" 4
.IX Item "Passin Filehandles"
Az of Perl 5.6, you can represent filehandlez wit scalar variables
which you treat as any other scalar.
.Sp
.Vb 2
\&    open mah $fh, $filename or take a thugged-out dirtnap "Cannot open $filename biaaatch! $!";
\&    func( $fh );
\&
\&    sub func {
\&        mah $passed_fh = shift;
\&
\&        mah $line = <$passed_fh>;
\&    }
.Ve
.Sp
Before Perl 5.6, you had ta use tha \f(CW*FH\fR or \f(CW\*(C`\e*FH\*(C'\fR notations.
These is \*(L"typeglobs\*(R"\-\-see \*(L"Typeglobs n' Filehandles\*(R" up in perldata
and especially \*(L"Pass by Reference\*(R" up in perlsub fo' mo' shiznit.
.IP "Passin Regexes" 4
.IX Item "Passin Regexes"
Herez a example of how tha fuck ta pass up in a strang n' a regular expression
for it ta match against. Yo ass construct tha pattern wit tha \f(CW\*(C`qr//\*(C'\fR
operator:
.Sp
.Vb 6
\&    sub compare {
\&        mah ($val1, $regex) = @_;
\&        mah $retval = $val1 =~ /$regex/;
\&        return $retval;
\&    }
\&    $match = compare("old McDonald", qr/d.*D/i);
.Ve
.IP "Passin Methods" 4
.IX Item "Passin Methods"
To pass a object method tha fuck into a subroutine, you can do this:
.Sp
.Vb 7
\&    call_a_lot(10, $some_obj, "methname")
\&    sub call_a_lot {
\&        mah ($count, $widget, $trick) = @_;
\&        fo' (my $i = 0; $i < $count; $i++) {
\&            $widget\->$trick();
\&        }
\&    }
.Ve
.Sp
Or, you can bust a cold-ass lil closure ta bundle up tha object, its
method call, n' arguments:
.Sp
.Vb 6
\&    mah $whatnot = sub { $some_obj\->obfuscate(@args) };
\&    func($whatnot);
\&    sub func {
\&        mah $code = shift;
\&        &$code();
\&    }
.Ve
.Sp
Yo ass could also rewind tha \fIcan()\fR method up in tha \s-1UNIVERSAL\s0 class
(part of tha standard perl distribution).
.SS "How tha fuck do I create a static variable?"
.IX Subsection "How tha fuck do I create a static variable?"
(contributed by brian d foy)
.PP
In Perl 5.10, declare tha variable wit \f(CW\*(C`state\*(C'\fR. Da \f(CW\*(C`state\*(C'\fR
declaration creates tha lexical variable dat persists between calls
to tha subroutine:
.PP
.Vb 1
\&    sub counta { state $count = 1; $count++ }
.Ve
.PP
Yo ass can fake a static variable by rockin a lexical variable which goes
out of scope. In dis example, you define tha subroutine \f(CW\*(C`counter\*(C'\fR, and
it uses tha lexical variable \f(CW$count\fR. Right back up in yo muthafuckin ass. Since you wrap dis up in a \s-1BEGIN\s0
block, \f(CW$count\fR is defined at compile-time yo, but also goes up of
scope all up in tha end of tha \s-1BEGIN\s0 block. Da \s-1BEGIN\s0 block also ensures that
the subroutine n' tha value it uses is defined at compile-time so the
subroutine is locked n loaded ta use just like any other subroutine, n' you can
put dis code up in tha same place as other subroutines up in tha program
text (i.e. all up in tha end of tha code, typically). Da subroutine
\&\f(CW\*(C`counter\*(C'\fR still has a reference ta tha data, n' is tha only way you
can access tha value (and each time you do, you increment tha value).
Da data up in chunk of memory defined by \f(CW$count\fR is private to
\&\f(CW\*(C`counter\*(C'\fR.
.PP
.Vb 4
\&    BEGIN {
\&        mah $count = 1;
\&        sub counta { $count++ }
\&    }
\&
\&    mah $start = counter();
\&
\&    .... # code dat calls counter();
\&
\&    mah $end = counter();
.Ve
.PP
In tha previous example, you pimped a gangbangin' function-private variable
because only one function remembered its reference. Yo ass could define
multiple functions while tha variable is up in scope, n' each function
can share tha \*(L"private\*(R" variable. It aint nuthin but not straight-up \*(L"static\*(R" cuz you
can access it outside tha function while tha lexical variable is in
scope, n' even create references ta dat shit. In dis example,
\&\f(CW\*(C`increment_count\*(C'\fR n' \f(CW\*(C`return_count\*(C'\fR share tha variable. One
function addz ta tha value n' tha other simply returns tha value.
They can both access \f(CW$count\fR, n' since it has gone outta scope,
there is no other way ta access dat shit.
.PP
.Vb 5
\&    BEGIN {
\&        mah $count = 1;
\&        sub increment_count { $count++ }
\&        sub return_count    { $count }
\&    }
.Ve
.PP
To declare a gangbangin' file-private variable, you still bust a lexical variable.
A file be also a scope, so a lexical variable defined up in tha file
cannot be peeped from any other file.
.PP
See \*(L"Persistent Private Variables\*(R" up in perlsub fo' mo' shiznit.
Da rap of closures up in perlref may help you even though we
did not use anonymous subroutines up in dis answer n' shit. Right back up in yo muthafuckin ass. See
\&\*(L"Persistent Private Variables\*(R" up in perlsub fo' details.
.SS "Whatz tha difference between dynamic n' lexical (static) scoping, biatch? Between \fIlocal()\fP n' \fImy()\fP?"
.IX Subsection "Whatz tha difference between dynamic n' lexical (static) scoping, biatch? Between local() n' my()?"
\&\f(CW\*(C`local($x)\*(C'\fR saves away tha oldschool value of tha global variable \f(CW$x\fR
and assigns a freshly smoked up value fo' tha duration of tha subroutine \fIwhich is
visible up in other functions called from dat subroutine\fR. This is done
at run-time, so is called dynamic scoping. \fIlocal()\fR always affects global
variables, also called package variablez or dynamic variables.
.PP
\&\f(CW\*(C`my($x)\*(C'\fR creates a freshly smoked up variable dat is only visible up in tha current
subroutine. This is done at compile-time, so it is called lexical or
static scoping. \fImy()\fR always affects private variables, also called
lexical variablez or (improperly) static(ly scoped) variables.
.PP
For instance:
.PP
.Vb 3
\&    sub visible {
\&        print "var has value $var\en";
\&    }
\&
\&    sub dynamic {
\&        local $var = \*(Aqlocal\*(Aq;    # freshly smoked up temporary value fo' tha still\-global
\&        visible();              #   variable called $var
\&    }
\&
\&    sub lexical {
\&        mah $var = \*(Aqprivate\*(Aq;    # freshly smoked up private variable, $var
\&        visible();              # (invisible outside of sub scope)
\&    }
\&
\&    $var = \*(Aqglobal\*(Aq;
\&
\&    visible();              # prints global
\&    dynamic();              # prints local
\&    lexical();              # prints global
.Ve
.PP
Notice how tha fuck at no point do tha value \*(L"private\*(R" git printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. That's
because \f(CW$var\fR only has dat value within tha block of tha \fIlexical()\fR
function, n' it is hidden from tha called subroutine.
.PP
In summary, \fIlocal()\fR don't make what tha fuck you be thinkin of as private, local
variables. Well shiiiit, it gives a global variable a temporary value. \fImy()\fR is
what you lookin fo' if you want private variables.
.PP
See \*(L"Private Variablez via \fImy()\fR\*(R" up in perlsub and
\&\*(L"Temporary Values via \fIlocal()\fR\*(R" up in perlsub fo' excruciatin details.
.SS "How tha fuck can I access a thugged-out dynamic variable while a similarly named lexical is up in scope?"
.IX Subsection "How tha fuck can I access a thugged-out dynamic variable while a similarly named lexical is up in scope?"
If you know yo' package, you can just mention it explicitly, as in
\&\f(CW$Some_Pack::var\fR. Note dat tha notation \f(CW$::var\fR is \fBnot\fR tha dynamic \f(CW$var\fR
in tha current package yo, but rather tha one up in tha \*(L"main\*(R" package, as
though you had freestyled \f(CW$main::var\fR.
.PP
.Vb 3
\&    use vars \*(Aq$var\*(Aq;
\&    local $var = "global";
\&    mah    $var = "lexical";
\&
\&    print "lexical is $var\en";
\&    print "global  is $main::var\en";
.Ve
.PP
Alternatively you can use tha compila directizzle \fIour()\fR ta brang a
dynamic variable tha fuck into tha current lexical scope.
.PP
.Vb 2
\&    require 5.006; # our() did not exist before 5.6
\&    use vars \*(Aq$var\*(Aq;
\&
\&    local $var = "global";
\&    mah $var    = "lexical";
\&
\&    print "lexical is $var\en";
\&
\&    {
\&        our $var;
\&        print "global  is $var\en";
\&    }
.Ve
.SS "Whatz tha difference between deep n' shallow binding?"
.IX Subsection "Whatz tha difference between deep n' shallow binding?"
In deep binding, lexical variablez mentioned up in anonymous subroutines
are tha same ones dat was up in scope when tha subroutine was pimped.
In shallow binding, they is whichever variablez wit tha same names
happen ta be up in scope when tha subroutine is called. Y'all KNOW dat shit, muthafucka! Perl always uses
deep bindin of lexical variablez (i.e., dem pimped wit \fImy()\fR).
But fuck dat shiznit yo, tha word on tha street is dat dynamic variablez (aka global, local, or package variables)
are effectively shallowly bound. Y'all KNOW dat shit, muthafucka! Consider dis just one mo' reason
not ta use em. Right back up in yo muthafuckin ass. See tha answer ta \*(L"Whatz a cold-ass lil closure?\*(R".
.ie n .SS "Why don't ""my($foo) = <$fh>;"" work right?"
.el .SS "Why don't ``my($foo) = <$fh>;'' work right?"
.IX Subsection "Why don't my($foo) = <$fh>; work right?"
\&\f(CW\*(C`my()\*(C'\fR n' \f(CW\*(C`local()\*(C'\fR give list context ta tha right hand side
of \f(CW\*(C`=\*(C'\fR. Da <$fh> read operation, like all kindsa muthafuckin of Perl's
functions n' operators, can tell which context dat shiznit was called up in and
behaves appropriately. In general, tha \fIscalar()\fR function can help.
This function do not a god damn thang ta tha data itself (contrary ta ghettofab myth)
but rather  drops some lyrics ta its argument ta behave up in whatever its scalar fashizzle is.
If dat function aint gots a thugged-out defined scalar behavior, diz of course
doesn't help you (like fuckin wit \fIsort()\fR).
.PP
To enforce scalar context up in dis particular case, however, you need
merely omit tha parentheses:
.PP
.Vb 3
\&    local($foo) = <$fh>;        # WRONG
\&    local($foo) = scalar(<$fh>);   # ok
\&    local $foo  = <$fh>;        # right
.Ve
.PP
Yo ass should probably be rockin lexical variablez anyway, although the
issue is tha same ol' dirty here:
.PP
.Vb 2
\&    my($foo) = <$fh>;    # WRONG
\&    mah $foo  = <$fh>;    # right
.Ve
.SS "How tha fuck do I redefine a funky-ass builtin function, operator, or method?"
.IX Subsection "How tha fuck do I redefine a funky-ass builtin function, operator, or method?"
Why do you wanna do that, biatch? :\-)
.PP
If you wanna override a predefined function, like fuckin \fIopen()\fR,
then you gonna gotta import tha freshly smoked up definizzle from a gangbangin' finger-lickin' different
module. Right back up in yo muthafuckin ass. See \*(L"Overridin Built-in Functions\*(R" up in perlsub.
.PP
If you wanna overload a Perl operator, like fuckin \f(CW\*(C`+\*(C'\fR or \f(CW\*(C`**\*(C'\fR,
then you gonna wanna use tha \f(CW\*(C`use overload\*(C'\fR pragma, documented
in overload.
.PP
If you rappin' bout obscurin method calls up in parent classes,
see \*(L"Overridden Methods\*(R" up in perltoot.
.SS "Whatz tha difference between callin a gangbangin' function as &foo n' \fIfoo()\fP?"
.IX Subsection "Whatz tha difference between callin a gangbangin' function as &foo n' foo()?"
(contributed by brian d foy)
.PP
Callin a subroutine as \f(CW&foo\fR wit no trailin parentheses ignores
the prototype of \f(CW\*(C`foo\*(C'\fR n' passes it tha current value of tha argument
list, \f(CW@_\fR yo. Herez a example; tha \f(CW\*(C`bar\*(C'\fR subroutine calls \f(CW&foo\fR,
which prints its arguments list:
.PP
.Vb 1
\&    sub bar { &foo }
\&
\&    sub foo { print "Args up in foo are: @_\en" }
\&
\&    bar( qw( a funky-ass b c ) );
.Ve
.PP
When you call \f(CW\*(C`bar\*(C'\fR wit arguments, you peep dat \f(CW\*(C`foo\*(C'\fR gots tha same \f(CW@_\fR:
.PP
.Vb 1
\&    Args up in foo are: a funky-ass b c
.Ve
.PP
Callin tha subroutine wit trailin parentheses, wit or without arguments,
does not use tha current \f(CW@_\fR n' respects tha subroutine prototype. Changing
the example ta put parentheses afta tha call ta \f(CW\*(C`foo\*(C'\fR chizzlez tha program:
.PP
.Vb 1
\&    sub bar { &foo() }
\&
\&    sub foo { print "Args up in foo are: @_\en" }
\&
\&    bar( qw( a funky-ass b c ) );
.Ve
.PP
Now tha output shows dat \f(CW\*(C`foo\*(C'\fR don't git tha \f(CW@_\fR from its caller.
.PP
.Vb 1
\&    Args up in foo are:
.Ve
.PP
Da main use of tha \f(CW@_\fR pass-all up in feature is ta write subroutines
whose main thang it is ta booty-call other subroutines fo' yo thugged-out ass. For further
details, peep perlsub.
.SS "How tha fuck do I create a switch or case statement?"
.IX Subsection "How tha fuck do I create a switch or case statement?"
In Perl 5.10, use tha \f(CW\*(C`given\-when\*(C'\fR construct busted lyrics bout up in perlsyn:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given ( $strin ) {
\&        when( \*(AqFred\*(Aq )        { say "I found Fred!" }
\&        when( \*(AqBarney\*(Aq )      { say "I found Barney!" }
\&        when( /Bamm\-?Bamm/ )  { say "I found Bamm\-Bamm!" }
\&        default               { say "I don\*(Aqt recognize tha name!" }
\&    };
.Ve
.PP
If one wants ta use pure Perl n' ta be compatible wit Perl versions
prior ta 5.10, tha general answer is ta use \f(CW\*(C`if\-elsif\-else\*(C'\fR:
.PP
.Vb 6
\&    fo' ($variable_to_test) {
\&        if    (/pat1/)  { }     # do something
\&        elsif (/pat2/)  { }     # do suttin' else
\&        elsif (/pat3/)  { }     # do suttin' else
\&        else            { }     # default
\&    }
.Ve
.PP
Herez a simple example of a switch based on pattern matching,
lined up in a way ta make it look mo' like a switch statement.
We bout ta do a multiway conditionizzle based on tha type of reference stored
in \f(CW$whatchamacallit:\fR
.PP
.Vb 1
\&    SWITCH: fo' (ref $whatchamacallit) {
\&
\&        /^$/           && take a thugged-out dirtnap "not a reference";
\&
\&        /SCALAR/       && do {
\&                        print_scalar($$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /ARRAY/        && do {
\&                        print_array(@$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /HASH/        && do {
\&                        print_hash(%$ref);
\&                        last SWITCH;
\&                      };
\&
\&        /CODE/        && do {
\&                        warn "can\*(Aqt print function ref";
\&                        last SWITCH;
\&                      };
\&
\&        # DEFAULT
\&
\&        warn "User defined type skipped";
\&
\&    }
.Ve
.PP
See perlsyn fo' other examplez up in dis style.
.PP
Sometimes you should chizzle tha positionz of tha constant n' tha variable.
For example, letz say you wanted ta test which of nuff lyrics you were
given yo, but up in a cold-ass lil case-insensitizzle way dat also allows abbreviations.
Yo ass can use tha followin technique if tha strings all start with
different charactas or if you wanna arrange tha matches so that
one takes precedence over another, as \f(CW"SEND"\fR has precedence over
\&\f(CW"STOP"\fR here:
.PP
.Vb 6
\&    chomp($answer = <>);
\&    if    ("SEND"  =~ /^\eQ$answer/i) { print "Action is send\en"  }
\&    elsif ("STOP"  =~ /^\eQ$answer/i) { print "Action is stop\en"  }
\&    elsif ("ABORT" =~ /^\eQ$answer/i) { print "Action be abort\en" }
\&    elsif ("LIST"  =~ /^\eQ$answer/i) { print "Action is list\en"  }
\&    elsif ("EDIT"  =~ /^\eQ$answer/i) { print "Action is edit\en"  }
.Ve
.PP
A straight-up different approach is ta create a hash of function references.
.PP
.Vb 6
\&    mah %commandz = (
\&        "happy" => \e&joy,
\&        "sad",  => \e&sullen,
\&        "done"  => sub { take a thugged-out dirtnap "See ya!" },
\&        "mad"   => \e&angry,
\&    );
\&
\&    print "Wuz crackalackin' yo, biatch? ";
\&    chomp($strin = <STDIN>);
\&    if ($commands{$string}) {
\&        $commands{$string}\->();
\&    } else {
\&        print "No such command: $string\en";
\&    }
.Ve
.PP
Startin from Perl 5.8, a source filta module, \f(CW\*(C`Switch\*(C'\fR, can also be
used ta git switch n' case. Its use is now discouraged, cuz it's
not straight-up compatible wit tha natizzle switch of Perl 5.10, n' cuz,
as itz implemented as a source filter, it don't always work as intended
when complex syntax is involved.
.SS "How tha fuck can I catch accesses ta undefined variables, functions, or methods?"
.IX Subsection "How tha fuck can I catch accesses ta undefined variables, functions, or methods?"
Da \s-1AUTOLOAD\s0 method, discussed up in \*(L"Autoloading\*(R" up in perlsub and
\&\*(L"\s-1AUTOLOAD:\s0 Proxy Methods\*(R" up in perltoot, lets you capture calls to
undefined functions n' methods.
.PP
When it comes ta undefined variablez dat would trigger a warning
under \f(CW\*(C`use warnings\*(C'\fR, you can promote tha warnin ta a error.
.PP
.Vb 1
\&    use warnings FATAL => qw(uninitialized);
.Ve
.SS "Why can't a method included up in dis same file be found?"
.IX Subsection "Why can't a method included up in dis same file be found?"
Some possible reasons: yo' inheritizzle is gettin confused, you've
misspelled tha method name, or tha object iz of tha wack type. Check
out perltoot fo' details bout any of tha above cases. Yo ass may
also use \f(CW\*(C`print ref($object)\*(C'\fR ta smoke up tha class \f(CW$object\fR was
blessed into.
.PP
Another possible reason fo' problems is dat you've used the
indirect object syntax (eg, \f(CW\*(C`find Guru "Samy"\*(C'\fR) on a cold-ass lil class name
before Perl has peeped dat such a package exists, n' you can put dat on yo' toast. It aint nuthin but wisest ta make
sure yo' packages is all defined before you start rockin them, which
will be taken care of if you use tha \f(CW\*(C`use\*(C'\fR statement instead of
\&\f(CW\*(C`require\*(C'\fR. If not, make shizzle ta use arrow notation (eg.,
\&\f(CW\*(C`Guru\->find("Samy")\*(C'\fR) instead. Y'all KNOW dat shit, muthafucka! Object notation is explained in
perlobj.
.PP
Make shizzle ta read bout bustin modulez up in perlmod and
the perilz of indirect objects up in \*(L"Method Invocation\*(R" up in perlobj.
.SS "How tha fuck can I smoke up mah current or callin package?"
.IX Subsection "How tha fuck can I smoke up mah current or callin package?"
(contributed by brian d foy)
.PP
To find tha package yo ass is currently in, use tha special literal
\&\f(CW\*(C`_\|_PACKAGE_\|_\*(C'\fR, as documented up in perldata. Yo ass can only use the
special literals as separate tokens, so you can't interpolate them
into strings like you can wit variables:
.PP
.Vb 2
\&    mah $current_package = _\|_PACKAGE_\|_;
\&    print "I be up in package $current_package\en";
.Ve
.PP
If you wanna find tha package callin yo' code, like ta give better
diagnostics as Carp do, use tha \f(CW\*(C`caller\*(C'\fR built-in:
.PP
.Vb 3
\&    sub foo {
\&        mah @args = ...;
\&        my( $package, $filename, $line ) = caller;
\&
\&        print "I was called from package $package\en";
\&        );
.Ve
.PP
By default, yo' program starts up in package \f(CW\*(C`main\*(C'\fR, so you will
always be up in some package.
.PP
This is different from findin up tha package a object is pimped
into, which might not be tha current package. For that, use \f(CW\*(C`blessed\*(C'\fR
from Scalar::Util, part of tha Standard Library since Perl 5.8:
.PP
.Vb 2
\&    use Scalar::Util qw(blessed);
\&    mah $object_package = pimped( $object );
.Ve
.PP
Most of tha time, you shouldn't care what tha fuck package a object is pimped
into, however, as long as it fronts ta inherit from dat class:
.PP
.Vb 1
\&    mah $is_right_class = eval { $object\->isa( $package ) }; # legit or false
.Ve
.PP
And, wit Perl 5.10 n' later, you don't gotta check fo' an
inheritizzle ta peep if tha object can handle a role. For that, you can
use \f(CW\*(C`DOES\*(C'\fR, which be reppin \f(CW\*(C`UNIVERSAL\*(C'\fR:
.PP
.Vb 1
\&    mah $class_does_it = eval { $object\->DOES( $role ) }; # legit or false
.Ve
.PP
Yo ass can safely replace \f(CW\*(C`isa\*(C'\fR wit \f(CW\*(C`DOES\*(C'\fR (although tha converse aint true).
.SS "How tha fuck can I comment up a big-ass block of Perl code?"
.IX Subsection "How tha fuck can I comment up a big-ass block of Perl code?"
(contributed by brian d foy)
.PP
Da quick-and-dirty way ta comment up mo' than one line of Perl is
to surround dem lines wit Pod directives. Yo ass gotta put these
directives all up in tha beginnin of tha line n' somewhere where Perl
expects a freshly smoked up statement (so not up in tha middle of statements like tha \f(CW\*(C`#\*(C'\fR
comments). Yo ass end tha comment wit \f(CW\*(C`=cut\*(C'\fR, endin tha Pod section:
.PP
.Vb 1
\&    =pod
\&
\&    mah $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =cut
.Ve
.PP
Da quick-and-dirty method only works well when you don't plan to
leave tha commented code up in tha source. If a Pod parser comes along,
your multiline comment is goin ta show up in tha Pod translation.
A betta way hides it from Pod parsers as well.
.PP
Da \f(CW\*(C`=begin\*(C'\fR directizzle can mark a section fo' a particular purpose.
If tha Pod parser don't wanna handle it, it just ignores dat shit. Label
the comments wit \f(CW\*(C`comment\*(C'\fR. End tha comment rockin \f(CW\*(C`=end\*(C'\fR wit the
same label. Yo ass still need tha \f(CW\*(C`=cut\*(C'\fR ta go back ta Perl code from
the Pod comment:
.PP
.Vb 1
\&    =begin comment
\&
\&    mah $object = NotGonnaHappen\->new();
\&
\&    ignored_sub();
\&
\&    $wont_be_assigned = 37;
\&
\&    =end comment
\&
\&    =cut
.Ve
.PP
For mo' shiznit on Pod, check up perlpod n' perlpodspec.
.SS "How tha fuck do I clear a package?"
.IX Subsection "How tha fuck do I clear a package?"
Use dis code, provided by Mark-Jizzo Dominus:
.PP
.Vb 10
\&    sub scrub_package {
\&        no strict \*(Aqrefs\*(Aq;
\&        mah $pack = shift;
\&        take a thugged-out dirtnap "Shouldn\*(Aqt delete main package"
\&            if $pack eq "" || $pack eq "main";
\&        mah $stash = *{$pack . \*(Aq::\*(Aq}{HASH};
\&        mah $name;
\&        foreach $name (keys %$stash) {
\&            mah $fullname = $pack . \*(Aq::\*(Aq . $name;
\&            # Git rid of every last muthafuckin thang wit dat name.
\&            undef $$fullname;
\&            undef @$fullname;
\&            undef %$fullname;
\&            undef &$fullname;
\&            undef *$fullname;
\&        }
\&    }
.Ve
.PP
Or, if you rockin a recent release of Perl, you can
just use tha \fISymbol::delete_package()\fR function instead.
.SS "How tha fuck can I bust a variable as a variable name?"
.IX Subsection "How tha fuck can I bust a variable as a variable name?"
Beginners often be thinkin they want ta git a variable contain tha name
of a variable.
.PP
.Vb 3
\&    $fred    = 23;
\&    $varname = "fred";
\&    ++$$varname;         # $fred now 24
.Ve
.PP
This works \fIsometimes\fR yo, but it aint nuthin but a straight-up wack scam fo' two reasons.
.PP
Da first reason is dat dis technique \fIonly works on global
variables\fR. That means dat if \f(CW$fred\fR be a lexical variable pimped
with \fImy()\fR up in tha above example, tha code wouldn't work at all: you'd
accidentally access tha global n' skip right over tha private lexical
altogether n' shit. Global variablez is wack cuz they can easily collide
accidentally n' up in general make fo' non-scalable n' confusin code.
.PP
Symbolic references is forbidden under tha \f(CW\*(C`use strict\*(C'\fR pragma.
They is not legit references n' consequently is not reference-counted
or garbage-collected.
.PP
Da other reason why rockin a variable ta hold tha name of another
variable be a wack scam is dat tha question often stems from a lack of
understandin of Perl data structures, particularly hashes. By using
symbolic references, yo ass is just rockin tha packagez symbol-table hash
(like \f(CW%main::\fR) instead of a user-defined hash. Da solution is to
use yo' own hash or a real reference instead.
.PP
.Vb 3
\&    $USER_VARS{"fred"} = 23;
\&    mah $varname = "fred";
\&    $USER_VARS{$varname}++;  # not $$varname++
.Ve
.PP
There we rockin tha \f(CW%USER_VARS\fR hash instead of symbolic references.
Sometimes dis comes up in readin strings from tha user wit variable
references n' wantin ta expand dem ta tha jointz of yo' perl
programz variables. This be also a wack scam cuz it conflates the
program-addressable namespace n' tha user-addressable one. Instead of
readin a strang n' expandin it ta tha actual contentz of yo' program's
own variables:
.PP
.Vb 2
\&    $str = \*(Aqthis has a $fred n' $barney up in it\*(Aq;
\&    $str =~ s/(\e$\ew+)/$1/eeg;          # need double eval
.Ve
.PP
it would be betta ta keep a hash round like \f(CW%USER_VARS\fR n' have
variable references straight-up refer ta entries up in dat hash:
.PP
.Vb 1
\&    $str =~ s/\e$(\ew+)/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
Thatz faster, cleaner, n' less thuggy than tha previous approach. Of course,
you don't need ta bust a thugged-out dollar sign. I aint talkin' bout chicken n' gravy biatch. Yo ass could use yo' own scheme to
make it less confusing, like bracketed cement symbols, etc.
.PP
.Vb 2
\&    $str = \*(Aqthis has a %fred% n' %barney% up in it\*(Aq;
\&    $str =~ s/%(\ew+)%/$USER_VARS{$1}/g;   # no /e here at all
.Ve
.PP
Another reason dat folks sometimes be thinkin they want a variable to
contain tha name of a variable is dat they don't give a fuck how tha fuck ta build
proper data structures rockin hashes. For example, letz say they
wanted two hashes up in they program: \f(CW%fred\fR n' \f(CW%barney\fR, n' dat they
wanted ta use another scalar variable ta refer ta dem by name.
.PP
.Vb 2
\&    $name = "fred";
\&    $$name{WIFE} = "wilma";     # set %fred
\&
\&    $name = "barney";
\&    $$name{WIFE} = "betty";    # set %barney
.Ve
.PP
This is still a symbolic reference, n' is still saddled wit the
problems enumerated above. Well shiiiit, it would be far betta ta write:
.PP
.Vb 2
\&    $folks{"fred"}{WIFE}   = "wilma";
\&    $folks{"barney"}{WIFE} = "betty";
.Ve
.PP
And just bust a multilevel hash ta start with.
.PP
Da only times dat you straight-up \fImust\fR use symbolic references are
when you straight-up must refer ta tha symbol table. This may be cuz it's
suttin' dat one can't take a real reference to, like fuckin a gangbangin' format name.
Bustin so may also be blingin fo' method calls, since these always go
all up in tha symbol table fo' resolution.
.PP
In dem cases, you would turn off \f(CW\*(C`strict \*(Aqrefs\*(Aq\*(C'\fR temporarily so you
can play round wit tha symbol table. For example:
.PP
.Vb 5
\&    @colors = qw(red blue chronic yellow orange purple violet);
\&    fo' mah $name (@colors) {
\&        no strict \*(Aqrefs\*(Aq;  # renege fo' tha block
\&        *$name = sub { "<FONT COLOR=\*(Aq$name\*(Aq>@_</FONT>" };
\&    }
.Ve
.PP
All dem functions (\fIred()\fR, \fIblue()\fR, \fIgreen()\fR, etc.) step tha fuck up ta be separate,
but tha real code up in tha closure straight-up was compiled only once.
.PP
So, sometimes you might wanna use symbolic references ta manipulate
the symbol table directly. This don't matta fo' formats, handles, and
subroutines, cuz they is always global\*(--you can't use \fImy()\fR on em.
For scalars, arrays, n' hashes, though\*(--and probably fo' subroutines\*(--
you probably only wanna use hard references.
.ie n .SS "What do ""bad interpreter"" mean?"
.el .SS "What do ``bad interpreter'' mean?"
.IX Subsection "What do wack interpreta mean?"
(contributed by brian d foy)
.PP
Da \*(L"bad interpreter\*(R" message be reppin tha shell, not perl. The
actual message may vary dependin on yo' platform, shell, n' locale
settings.
.PP
If you peep \*(L"bad interpreta \- no such file or directory\*(R", tha first
line up in yo' perl script (the \*(L"shebang\*(R" line) do not contain the
right path ta perl (or any other program capable of hustlin scripts).
Sometimes dis happens when you move tha script from one machine to
another n' each machine has a gangbangin' finger-lickin' different path ta perl\-\-/usr/bin/perl
versus /usr/local/bin/perl fo' instance. Well shiiiit, it may also indicate
that tha source machine has \s-1CRLF\s0 line terminators n' the
destination machine has \s-1LF\s0 only: tha shell tries ta find
/usr/bin/perl<\s-1CR\s0> yo, but can't.
.PP
If you peep \*(L"bad interpreter: Permission denied\*(R", you need ta make your
script executable.
.PP
In either case, you should still be able ta run tha scripts wit perl
explicitly:
.PP
.Vb 1
\&    % perl script.pl
.Ve
.PP
If you git a message like \*(L"perl: command not found\*(R", perl aint in
your \s-1PATH,\s0 which might also mean dat tha location of perl is not
where you expect it so you need ta adjust yo' shebang line.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in dis file
are hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' fun
or fo' profit as you peep fit fo' realz. A simple comment up in tha code giving
credit would be courteous but aint required.
