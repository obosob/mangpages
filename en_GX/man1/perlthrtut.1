.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTHRTUT 1"
.TH PERLTHRTUT 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlthrtut \- Tutorial on threadz up in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tutorial raps bout tha use of Perl interpreta threadz (sometimes
referred ta as \fIithreads\fR).  In this
model, each thread runs up in its own Perl interpreter, n' any data sharing
between threadz must be explicit.  Da user-level intercourse fo' \fIithreads\fR
uses tha threadz class.
.PP
\&\fB\s-1NOTE\s0\fR: There was another olda Perl threadin flavor called tha 5.005 model
that used tha threadz class.  This oldschool model was known ta have problems, is
deprecated, n' was removed fo' release 5.10.  Yo ass are
strongly encouraged ta migrate any existin 5.005 threadz code ta tha new
model quicker than a muthafucka.
.PP
Yo ass can peep which (or neither) threadin flavour you have by
runnin \f(CW\*(C`perl \-V\*(C'\fR n' lookin all up in tha \f(CW\*(C`Platform\*(C'\fR section.
If you have \f(CW\*(C`useithreads=define\*(C'\fR you have ithreads, if you
have \f(CW\*(C`use5005threads=define\*(C'\fR you have 5.005 threads.
If you have neither, you aint gots any thread support built in.
If you have both, yo ass is up in shit.
.PP
Da threadz n' threads::shared modulez is included up in tha core Perl
distribution. I aint talkin' bout chicken n' gravy biatch.  Additionally, they is maintained as a separate modulez on
\&\s-1CPAN,\s0 so you can check there fo' any thugged-out shit.
.SH "What Is A Thread Anyway?"
.IX Header "What Is A Thread Anyway?"
A thread be a gangbangin' flow of control all up in a program wit a single
execution point.
.PP
Soundz a wack lot like a process, don't it? Well, it should.
Threadz is one of tha piecez of a process.  Every process has at least
one thread and, up until now, every last muthafuckin process hustlin Perl had only one
thread. Y'all KNOW dat shit, muthafucka!  With 5.8, though, you can create extra threads.  We going
to show you how, when, n' why.
.SH "Threaded Program Models"
.IX Header "Threaded Program Models"
There is three basic ways dat you can structure a threaded
program.  Which model you chizzle dependz on what tha fuck you need yo' program
to do.  For nuff non-trivial threaded programs, you gonna need ta chizzle
different models fo' different piecez of yo' program.
.SS "Boss/Worker"
.IX Subsection "Boss/Worker"
Da boss/worker model probably has one \fIboss\fR thread n' one or more
\&\fIworker\fR threads.  Da boss thread gathers or generates tasks dat need
to be done, then parcels dem tasks up ta tha appropriate worker
thread.
.PP
This model is common up in \s-1GUI\s0 n' server programs, where a main thread
waits fo' some event n' then passes dat event ta tha appropriate
worker threadz fo' processing.  Once tha event has been passed on, the
boss thread goes back ta waitin fo' another event.
.PP
Da boss thread do relatively lil work.  While tasks aren't
necessarily performed fasta than wit any other method, it tendz to
have tha dopest user-response times.
.SS "Work Crew"
.IX Subsection "Work Crew"
In tha work crew model, nuff muthafuckin threadz is pimped dat do
essentially tha same thang ta different piecez of data.  It closely
mirrors old-ass parallel processin n' vector processors, where a
pimpin' array of processors do tha exact same thang ta nuff pieces of
data.
.PP
This model is particularly useful if tha system hustlin tha program
will distribute multiple threadz across different processors.  It can
also be useful up in ray tracin or renderin engines, where the
individual threadz can pass on interim thangs up in dis biatch ta give tha user visual
feedback.
.SS "Pipeline"
.IX Subsection "Pipeline"
Da pipeline model divides up a task tha fuck into a seriez of steps, and
passes tha thangs up in dis biatch of one step on ta tha thread processin the
next.  Each thread do one thang ta each piece of data n' passes the
results ta tha next thread up in line.
.PP
This model make da most thugged-out sense if you have multiple processors so two
or mo' threadz is ghon be executin up in parallel, though it can often
make sense up in other contexts as well.  It tendz ta keep tha individual
tasks lil' small-ass n' simple, as well as allowin some partz of tha pipeline
to block (on I/O or system calls, fo' example) while other parts keep
going.  If you hustlin different partz of tha pipeline on different
processors you may also take advantage of tha caches on each
processor.
.PP
This model be also handy fo' a gangbangin' form of recursive programmin where,
rather than havin a subroutine call itself, it instead creates
another thread. Y'all KNOW dat shit, muthafucka!  Prime n' Fibonacci generators both map well ta this
form of tha pipeline model. (A version of a prime number generator is
presented lata on.)
.SH "What kind of threadz is Perl threads?"
.IX Header "What kind of threadz is Perl threads?"
If you have experience wit other thread implementations, you might
find dat thangs aren't like what tha fuck you expect.  It aint nuthin but straight-up blingin to
remember when dealin wit Perl threadz dat \fIPerl Threadz Is Not X
Threads\fR fo' all jointz of X.  They aren't \s-1POSIX\s0 threads, or
DecThreads, or Javaz Chronic threads, or Win32 threads.  There are
similarities, n' tha broad concepts is tha same yo, but if you start
lookin fo' implementation details you goin ta be either
disappointed or confused. Y'all KNOW dat shit, muthafucka!  Possibly both.
.PP
This aint ta say dat Perl threadz is straight-up different from
everythang thatz eva come before. They're not.  Perlz threading
model owes a shitload ta other thread models, especially \s-1POSIX. \s0 Just as
Perl aint C, though, Perl threadz is not \s-1POSIX\s0 threads.  So if you
find yo ass lookin fo' mutexes, or thread priorities, itz time to
step back a lil' bit n' be thinkin bout what tha fuck you wanna do n' how tha fuck Perl can
do dat shit.
.PP
But fuck dat shiznit yo, tha word on tha street is dat it is blingin ta remember dat Perl threadz cannot magically
do thangs unless yo' operatin systemz threadz allow dat shit. Right back up in yo muthafuckin ass. So if your
system blocks tha entire process on \f(CW\*(C`sleep()\*(C'\fR, Perl probably will, as well.
.PP
\&\fBPerl Threadz Is Different.\fR
.SH "Thread-Safe Modules"
.IX Header "Thread-Safe Modules"
Da addizzle of threadz has chizzled Perlz internals
substantially. There is implications fo' playas whoz ass write
modulez wit \s-1XS\s0 code or external libraries. Put ya muthafuckin choppers up if ya feel dis! But fuck dat shiznit yo, tha word on tha street is dat since Perl data is
not shared among threadz by default, Perl modulez stand a high chizzle of
bein thread-safe or can be made thread-safe doggystyle.  Modulez dat is not
tagged as thread-safe should be tested or code reviewed before bein used
in thang code.
.PP
Not all modulez dat you might use is thread-safe, n' you should
always assume a module is unsafe unless tha documentation says
otherwise.  This includes modulez dat is distributed as part of the
core.  Threadz is a relatively freshly smoked up feature, n' even a shitload of tha standard
modulez aren't thread-safe.
.PP
Even if a module is thread-safe, it don't mean dat tha module is optimized
to work well wit threadz fo' realz. A module could possibly be rewritten ta utilize
the freshly smoked up features up in threaded Perl ta increase performizzle up in a threaded
environment.
.PP
If you rockin a module thatz not thread-safe fo' some reason, you
can protect yo ass by rockin it from one, n' only one thread at all.
If you need multiple threadz ta access such a module, you can use semaphores and
lotz of programmin discipline ta control access ta dat shit.  Semaphores
are covered up in \*(L"Basic semaphores\*(R".
.PP
See also \*(L"Thread-Safety of System Libraries\*(R".
.SH "Thread Basics"
.IX Header "Thread Basics"
Da threadz module serves up tha basic functions you need ta write
threaded programs.  In tha followin sections, we'll cover tha basics,
showin you what tha fuck you need ta do ta create a threaded program.   After
that, we'll go over a shitload of tha featurez of tha threadz module that
make threaded programmin easier.
.SS "Basic Thread Support"
.IX Subsection "Basic Thread Support"
Thread support be a Perl compile-time option. I aint talkin' bout chicken n' gravy biatch. It aint nuthin but suttin' that's
turned on or off when Perl is built at yo' crib, rather than when
your programs is compiled. Y'all KNOW dat shit, muthafucka! If yo' Perl wasn't compiled wit thread
support enabled, then any attempt ta use threadz will fail.
.PP
Yo crazy-ass programs can use tha Config module ta check whether threadz are
enabled. Y'all KNOW dat shit, muthafucka! If yo' program can't run without them, you can say something
like:
.PP
.Vb 2
\&    use Config;
\&    $Config{useithreads} or die(\*(AqRecompile Perl wit threadz ta run dis program.\*(Aq);
.Ve
.PP
A possibly-threaded program rockin a possibly-threaded module might
have code like this:
.PP
.Vb 2
\&    use Config;
\&    use MyMod;
\&
\&    BEGIN {
\&        if ($Config{useithreads}) {
\&            # Our thugged-out asses have threads
\&            require MyMod_threaded;
\&            import MyMod_threaded;
\&        } else {
\&            require MyMod_unthreaded;
\&            import MyMod_unthreaded;
\&        }
\&    }
.Ve
.PP
Since code dat runs both wit n' without threadz is probably pretty
messy, itz dopest ta isolate tha thread-specific code up in its own
module.  In our example above, thatz what tha fuck \f(CW\*(C`MyMod_threaded\*(C'\fR is, n' it's
only imported if we hustlin on a threaded Perl.
.SS "A Note bout tha Examples"
.IX Subsection "A Note bout tha Examples"
In a real thang, care should be taken dat all threadz is finished
executin before tha program exits, n' you can put dat on yo' toast.  That care has \fBnot\fR been taken up in these
examplez up in tha interest of simplicity.  Hustlin these examplez \fIas is\fR will
produce error lyrics, probably caused by tha fact dat there be still
threadz hustlin when tha program exits, n' you can put dat on yo' toast.  Yo ass should not be alarmed by all dis bullshit.
.SS "Creatin Threads"
.IX Subsection "Creatin Threads"
Da threadz module serves up tha tools you need ta create new
threads.  Like any other module, you need ta tell Perl dat you wanna use
it; \f(CW\*(C`use threads;\*(C'\fR imports all tha pieces you need ta create basic
threads.
.PP
Da simplest, most straightforward way ta create a thread is wit \f(CW\*(C`create()\*(C'\fR:
.PP
.Vb 1
\&    use threads;
\&
\&    mah $thr = threads\->create(\e&sub1);
\&
\&    sub sub1 {
\&        print("In tha thread\en");
\&    }
.Ve
.PP
Da \f(CW\*(C`create()\*(C'\fR method takes a reference ta a subroutine n' creates a new
thread dat starts executin up in tha referenced subroutine.  Control
then passes both ta tha subroutine n' tha caller.
.PP
If you need to, yo' program can pass parametas ta tha subroutine as
part of tha thread startup.  Just include tha list of parametas as
part of tha \f(CW\*(C`threads\->create()\*(C'\fR call, like this:
.PP
.Vb 1
\&    use threads;
\&
\&    mah $Param3 = \*(Aqfoo\*(Aq;
\&    mah $thr1 = threads\->create(\e&sub1, \*(AqParam 1\*(Aq, \*(AqParam 2\*(Aq, $Param3);
\&    mah @ParamList = (42, \*(AqHello\*(Aq, 3.14);
\&    mah $thr2 = threads\->create(\e&sub1, @ParamList);
\&    mah $thr3 = threads\->create(\e&sub1, qw(Param1 Param2 Param3));
\&
\&    sub sub1 {
\&        mah @InboundParametas = @_;
\&        print("In tha thread\en");
\&        print(\*(AqGot parametas >\*(Aq, join(\*(Aq<>\*(Aq, @InboundParameters), "<\en");
\&    }
.Ve
.PP
Da last example illustrates another feature of threads.  Yo ass can spawn
off nuff muthafuckin threadz rockin tha same subroutine.  Each thread executes
the same subroutine yo, but up in a separate thread wit a separate
environment n' potentially separate arguments.
.PP
\&\f(CW\*(C`new()\*(C'\fR be a synonym fo' \f(CW\*(C`create()\*(C'\fR.
.SS "Waitin For A Thread To Exit"
.IX Subsection "Waitin For A Thread To Exit"
Since threadz is also subroutines, they can return joints, n' you can put dat on yo' toast.  To wait
for a thread ta exit n' extract any joints it might return, you can
use tha \f(CW\*(C`join()\*(C'\fR method:
.PP
.Vb 1
\&    use threads;
\&
\&    mah ($thr) = threads\->create(\e&sub1);
\&
\&    mah @ReturnData = $thr\->join();
\&    print(\*(AqThread returned \*(Aq, join(\*(Aq, \*(Aq, @ReturnData), "\en");
\&
\&    sub sub1 { return (\*(AqFifty\-six\*(Aq, \*(Aqfoo\*(Aq, 2); }
.Ve
.PP
In tha example above, tha \f(CW\*(C`join()\*(C'\fR method returns as soon as tha thread
ends.  In addizzle ta waitin fo' a thread ta finish n' gatherin up
any joints dat tha thread might have returned, \f(CW\*(C`join()\*(C'\fR also performs
any \s-1OS\s0 cleanup necessary fo' tha thread. Y'all KNOW dat shit, muthafucka!  That cleanup might be
important, especially fo' long-runnin programs dat spawn fuckin shitloadz of
threads.  If you don't want tha return joints n' don't wanna wait
for tha thread ta finish, you should call tha \f(CW\*(C`detach()\*(C'\fR method
instead, as busted lyrics bout next.
.PP
\&\s-1NOTE:\s0 In tha example above, tha thread returns a list, thus necessitating
that tha thread creation call be made up in list context (i.e., \f(CW\*(C`my ($thr)\*(C'\fR).
See \*(L"$thr\->\fIjoin()\fR\*(R" up in threadz n' \*(L"\s-1THREAD CONTEXT\*(R"\s0 up in threadz fo' more
details on thread context n' return joints.
.SS "Ignorin A Thread"
.IX Subsection "Ignorin A Thread"
\&\f(CW\*(C`join()\*(C'\fR do three thangs: it waits fo' a thread ta exit, cleans up
afta it, n' returns any data tha thread may have produced. Y'all KNOW dat shit, muthafucka!  But what
if you not horny bout tha threadz return joints, n' you don't
really care when tha thread finishes? All you want is fo' tha thread
to git cleaned up afta when itz done.
.PP
In dis case, you use tha \f(CW\*(C`detach()\*(C'\fR method. Y'all KNOW dat shit, muthafucka!  Once a thread is detached,
it'll run until itz finished; then Perl will clean up afta it
automatically.
.PP
.Vb 1
\&    use threads;
\&
\&    mah $thr = threads\->create(\e&sub1);   # Spawn tha thread
\&
\&    $thr\->detach();   # Now we officially don\*(Aqt care any more
\&
\&    chill(15);        # Let thread run fo' awhile
\&
\&    sub sub1 {
\&        $a = 0;
\&        while (1) {
\&            $a++;
\&            print("\e$a is $a\en");
\&            chill(1);
\&        }
\&    }
.Ve
.PP
Once a thread is detached, it may not be joined, n' any return data
that it might have produced (if dat shiznit was done n' waitin fo' a join) is
lost.
.PP
\&\f(CW\*(C`detach()\*(C'\fR can also be called as a cold-ass lil class method ta allow a thread to
detach itself:
.PP
.Vb 1
\&    use threads;
\&
\&    mah $thr = threads\->create(\e&sub1);
\&
\&    sub sub1 {
\&        threads\->detach();
\&        # Do mo' work
\&    }
.Ve
.SS "Process n' Thread Termination"
.IX Subsection "Process n' Thread Termination"
With threadz one must be careful ta make shizzle they all gotz a cold-ass lil chizzle to
run ta completion, assumin dat is what tha fuck you want.
.PP
An action dat terminates a process will terminizzle \fIall\fR hustlin
threads.  \fIdie()\fR n' \fIexit()\fR have dis property,
and perl do a exit when tha main thread exits,
like implicitly by fallin off tha end of yo' code,
even if thatz not what tha fuck you want.
.PP
As a example of dis case, dis code prints tha message
\&\*(L"Perl exited wit actizzle threads: 2 hustlin n' unjoined\*(R":
.PP
.Vb 8
\&    use threads;
\&    mah $thr1 = threads\->new(\e&thrsub, "test1");
\&    mah $thr2 = threads\->new(\e&thrsub, "test2");
\&    sub thrsub {
\&       mah ($message) = @_;
\&       chill 1;
\&       print "thread $message\en";
\&    }
.Ve
.PP
But when tha followin lines is added all up in tha end:
.PP
.Vb 2
\&    $thr1\->join();
\&    $thr2\->join();
.Ve
.PP
it prints two linez of output, a like mo' useful outcome.
.SH "Threadz And Data"
.IX Header "Threadz And Data"
Now dat we've covered tha basics of threads, itz time fo' our next
topic: Data.  Threadin introduces a cold-ass lil couple complications ta data
access dat non-threaded programs never need ta worry about.
.SS "Shared And Unshared Data"
.IX Subsection "Shared And Unshared Data"
Da freshest difference between Perl \fIithreads\fR n' tha oldschool 5.005 style
threading, or fo' dat matter, ta most other threadin systems up there,
is dat by default, no data is shared. Y'all KNOW dat shit, muthafucka! When a freshly smoked up Perl thread is pimped,
all tha data associated wit tha current thread is copied ta tha new
thread, n' is subsequently private ta dat freshly smoked up thread!
This is similar up in feel ta what tha fuck happens when a Unix process forks,
except dat up in dis case, tha data is just copied ta a gangbangin' finger-lickin' different part of
memory within tha same process rather than a real fork takin place.
.PP
To make use of threading, however, one probably wants tha threadz ta share
at least some data between theyselves. This is done wit the
threads::shared module n' tha \f(CW\*(C`:shared\*(C'\fR attribute:
.PP
.Vb 2
\&    use threads;
\&    use threads::shared;
\&
\&    mah $foo :shared = 1;
\&    mah $bar = 1;
\&    threads\->create(sub { $foo++; $bar++; })\->join();
\&
\&    print("$foo\en");  # Prints 2 since $foo is shared
\&    print("$bar\en");  # Prints 1 since $bar aint shared
.Ve
.PP
In tha case of a gangbangin' finger-lickin' dirty-ass shared array, all tha arrayz elements is shared, n' for
a shared hash, all tha keys n' joints is shared. Y'all KNOW dat shit, muthafucka! This places
restrictions on what tha fuck may be assigned ta shared array n' hash elements: only
simple joints or references ta shared variablez is allowed \- dis is
so dat a private variable can't accidentally become shared. Y'all KNOW dat shit, muthafucka! A bad
assignment will cause tha thread ta take a thugged-out dirt nap. For example:
.PP
.Vb 2
\&    use threads;
\&    use threads::shared;
\&
\&    mah $var          = 1;
\&    mah $svar :shared = 2;
\&    mah %hash :shared;
\&
\&    ... create some threadz ...
\&
\&    $hash{a} = 1;       # All threadz peep exists($hash{a}) n' $hash{a} == 1
\&    $hash{a} = $var;    # aiiight \- copy\-by\-value: same effect as previous
\&    $hash{a} = $svar;   # aiiight \- copy\-by\-value: same effect as previous
\&    $hash{a} = \e$svar;  # aiiight \- a reference ta a gangbangin' finger-lickin' dirty-ass shared variable
\&    $hash{a} = \e$var;   # This will die
\&    delete($hash{a});   # aiiight \- all threadz will peep !exists($hash{a})
.Ve
.PP
Note dat a gangbangin' finger-lickin' dirty-ass shared variable guarantees dat if two or mo' threadz try to
modify it all up in tha same time, tha internal state of tha variable will not
become corrupted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. But fuck dat shiznit yo, tha word on tha street is dat there be no guarantees beyond this, as
explained up in tha next section.
.SS "Thread Pitfalls: Races"
.IX Subsection "Thread Pitfalls: Races"
While threadz brang a freshly smoked up set of useful tools, they also brang a
number of pitfalls.  One pitfall is tha race condition:
.PP
.Vb 2
\&    use threads;
\&    use threads::shared;
\&
\&    mah $a :shared = 1;
\&    mah $thr1 = threads\->create(\e&sub1);
\&    mah $thr2 = threads\->create(\e&sub2);
\&
\&    $thr1\->join();
\&    $thr2\->join();
\&    print("$a\en");
\&
\&    sub sub1 { mah $foo = $a; $a = $foo + 1; }
\&    sub sub2 { mah $bar = $a; $a = $bar + 1; }
.Ve
.PP
What do you be thinkin \f(CW$a\fR will be? Da answer, unfortunately, is \fIit
depends\fR. Both \f(CW\*(C`sub1()\*(C'\fR n' \f(CW\*(C`sub2()\*(C'\fR access tha global variable \f(CW$a\fR, once
to read n' once ta write.  Dependin on factors rangin from your
thread implementationz schedulin algorithm ta tha phase of tha moon,
\&\f(CW$a\fR can be 2 or 3.
.PP
Race conditions is caused by unsynchronized access ta shared
data.  Without explicit synchronization, there be a no way ta be shizzle that
nothang has happened ta tha shared data between tha time you access it
and tha time you update dat shit.  Even dis simple code fragment has the
possibilitizzle of error:
.PP
.Vb 8
\&    use threads;
\&    mah $a :shared = 2;
\&    mah $b :shared;
\&    mah $c :shared;
\&    mah $thr1 = threads\->create(sub { $b = $a; $a = $b + 1; });
\&    mah $thr2 = threads\->create(sub { $c = $a; $a = $c + 1; });
\&    $thr1\->join();
\&    $thr2\->join();
.Ve
.PP
Two threadz both access \f(CW$a\fR.  Each thread can potentially be interrupted
at any point, or be executed up in any order n' shit.  At tha end, \f(CW$a\fR could be 3
or 4, n' both \f(CW$b\fR n' \f(CW$c\fR could be 2 or 3.
.PP
Even \f(CW\*(C`$a += 5\*(C'\fR or \f(CW\*(C`$a++\*(C'\fR is not guaranteed ta be atomic.
.PP
Whenever yo' program accesses data or resources dat can be accessed
by other threads, you must take steps ta coordinizzle access or risk
data inconsistency n' race conditions. Note dat Perl will protect its
internals from yo' race conditions yo, but it won't protect you from yo thugged-out ass.
.SH "Synchronization n' control"
.IX Header "Synchronization n' control"
Perl serves up a fuckin shitload of mechanizzlez ta coordinizzle tha interactions
between theyselves n' they data, ta avoid race conditions n' tha like.
Some of these is designed ta resemble tha common steez used up in thread
libraries like fuckin \f(CW\*(C`pthreads\*(C'\fR; others is Perl-specific. Often, the
standard steez is clumsy n' hard as fuck ta git right (such as
condizzle waits). Where possible, it is probably easier ta use Perlish
steez like fuckin queues, which remove a shitload of tha mad bullshit involved.
.SS "Controllin access: \fIlock()\fP"
.IX Subsection "Controllin access: lock()"
Da \f(CW\*(C`lock()\*(C'\fR function takes a gangbangin' finger-lickin' dirty-ass shared variable n' puts a lock on dat shit.
No other thread may lock tha variable until tha variable is unlocked
by tha thread holdin tha lock. Unlockin happens automatically
when tha lockin thread exits tha block dat gotz nuff tha call ta the
\&\f(CW\*(C`lock()\*(C'\fR function. I aint talkin' bout chicken n' gravy biatch.  Usin \f(CW\*(C`lock()\*(C'\fR is straightforward: This example has
several threadz bustin some calculations up in parallel, n' occasionally
uppimpin a hustlin total:
.PP
.Vb 2
\&    use threads;
\&    use threads::shared;
\&
\&    mah $total :shared = 0;
\&
\&    sub calc {
\&        while (1) {
\&            mah $result;
\&            # (... do some calculations n' set $result ...)
\&            {
\&                lock($total);  # Block until we obtain tha lock
\&                $total += $result;
\&            } # Lock implicitly busted out at end of scope
\&            last if $result == 0;
\&        }
\&    }
\&
\&    mah $thr1 = threads\->create(\e&calc);
\&    mah $thr2 = threads\->create(\e&calc);
\&    mah $thr3 = threads\->create(\e&calc);
\&    $thr1\->join();
\&    $thr2\->join();
\&    $thr3\->join();
\&    print("total=$total\en");
.Ve
.PP
\&\f(CW\*(C`lock()\*(C'\fR blocks tha thread until tha variable bein locked is
available.  When \f(CW\*(C`lock()\*(C'\fR returns, yo' thread can be shizzle dat no other
thread can lock dat variable until tha block containin the
lock exits.
.PP
It aint nuthin but blingin ta note dat locks don't prevent access ta tha variable
in question, only lock attempts, n' you can put dat on yo' toast.  This is up in keepin wit Perl's
longstandin tradizzle of courteous programming, n' tha advisory file
lockin dat \f(CW\*(C`flock()\*(C'\fR gives yo thugged-out ass.
.PP
Yo ass may lock arrays n' hashes as well as scalars.  Lockin a array,
though, aint gonna block subsequent locks on array elements, just lock
attempts on tha array itself.
.PP
Locks is recursive, which means itz all gravy fo' a thread to
lock a variable mo' than once.  Da lock will last until tha outermost
\&\f(CW\*(C`lock()\*(C'\fR on tha variable goes outta scope. For example:
.PP
.Vb 2
\&    mah $x :shared;
\&    doit();
\&
\&    sub doit {
\&        {
\&            {
\&                lock($x); # Wait fo' lock
\&                lock($x); # NOOP \- we already have tha lock
\&                {
\&                    lock($x); # NOOP
\&                    {
\&                        lock($x); # NOOP
\&                        lockit_some_more();
\&                    }
\&                }
\&            } # *** Implicit unlock here ***
\&        }
\&    }
\&
\&    sub lockit_some_more {
\&        lock($x); # NOOP
\&    } # Nothang happens here
.Ve
.PP
Note dat there is no \f(CW\*(C`unlock()\*(C'\fR function \- tha only way ta unlock a
variable is ta allow it ta go outta scope.
.PP
A lock can either be used ta guard tha data contained within tha variable
bein locked, or it can be used ta guard suttin' else, like a section
of code. In dis latta case, tha variable up in question do not hold any
useful data, n' exists only fo' tha purpose of bein locked. Y'all KNOW dat shit, muthafucka! In this
respect, tha variable behaves like tha mutexes n' basic semaphores of
traditionizzle thread libraries.
.SS "A Thread Pitfall: Deadlocks"
.IX Subsection "A Thread Pitfall: Deadlocks"
Locks is a handy tool ta synchronize access ta data, n' rockin them
properly is tha key ta safe shared data.  Unfortunately, locks aren't
without they dangers, especially when multiple locks is involved.
Consider tha followin code:
.PP
.Vb 1
\&    use threads;
\&
\&    mah $a :shared = 4;
\&    mah $b :shared = \*(Aqfoo\*(Aq;
\&    mah $thr1 = threads\->create(sub {
\&        lock($a);
\&        chill(20);
\&        lock($b);
\&    });
\&    mah $thr2 = threads\->create(sub {
\&        lock($b);
\&        chill(20);
\&        lock($a);
\&    });
.Ve
.PP
This program will probably hang until you bust a cap up in dat shit.  Da only way it
won't hang is if one of tha two threadz acquires both locks
first.  A guaranteed-to-hang version is mo' fucked up yo, but the
principle is tha same.
.PP
Da first thread will grab a lock on \f(CW$a\fR, then, afta a pause durin which
the second thread has probably had time ta do some work, try ta grab a
lock on \f(CW$b\fR.  Meanwhile, tha second thread grabs a lock on \f(CW$b\fR, then later
tries ta grab a lock on \f(CW$a\fR.  Da second lock attempt fo' both threadz will
block, each waitin fo' tha other ta release its lock.
.PP
This condizzle is called a thugged-out deadlock, n' it occurs whenever two or
more threadz is tryin ta git locks on resources dat tha others
own. I aint talkin' bout chicken n' gravy biatch.  Each thread will block, waitin fo' tha other ta release a lock
on a resource.  That never happens, though, since tha thread wit the
resource is itself waitin fo' a lock ta be busted out.
.PP
There is a fuckin shitload of ways ta handle dis sort of problem.  Da best
way is ta always have all threadz acquire locks up in tha exact same
order n' shit.  If, fo' example, you lock variablez \f(CW$a\fR, \f(CW$b\fR, n' \f(CW$c\fR, always lock
\&\f(CW$a\fR before \f(CW$b\fR, n' \f(CW$b\fR before \f(CW$c\fR.  It aint nuthin but also dopest ta hold on ta locks for
as short a period of time ta minimize tha riskz of deadlock.
.PP
Da other synchronization primitives busted lyrics bout below can suffer from
similar problems.
.SS "Queues: Passin Data Around"
.IX Subsection "Queues: Passin Data Around"
A queue be a special thread-safe object dat lets you put data up in one
end n' take it up tha other without havin ta worry about
synchronization issues.  They're pretty straightforward, n' look like
this:
.PP
.Vb 2
\&    use threads;
\&    use Thread::Queue;
\&
\&    mah $DataQueue = Thread::Queue\->new();
\&    mah $thr = threads\->create(sub {
\&        while (my $DataElement = $DataQueue\->dequeue()) {
\&            print("Popped $DataElement off tha queue\en");
\&        }
\&    });
\&
\&    $DataQueue\->enqueue(12);
\&    $DataQueue\->enqueue("A", "B", "C");
\&    chill(10);
\&    $DataQueue\->enqueue(undef);
\&    $thr\->join();
.Ve
.PP
Yo ass create tha queue wit \f(CW\*(C`Thread::Queue\->new()\*(C'\fR.  Then you can
add listz of scalars onto tha end wit \f(CW\*(C`enqueue()\*(C'\fR, n' pop scalars off
the front of it wit \f(CW\*(C`dequeue()\*(C'\fR.  A queue has no fixed size, n' can grow
as needed ta hold every last muthafuckin thang pushed on ta dat shit.
.PP
If a queue is empty, \f(CW\*(C`dequeue()\*(C'\fR blocks until another thread enqueues
something.  This make queues ideal fo' event loops n' other
communications between threads.
.SS "Semaphores: Synchronizin Data Access"
.IX Subsection "Semaphores: Synchronizin Data Access"
Semaphores is a kind of generic lockin mechanism. In they most basic
form, they behave straight-up much like lockable scalars, except dat they
can't hold data, n' dat they must be explicitly unlocked. Y'all KNOW dat shit, muthafucka! In their
advanced form, they act like a kind of counter, n' can allow multiple
threadz ta have tha \fIlock\fR at any one time.
.SS "Basic semaphores"
.IX Subsection "Basic semaphores"
Semaphores have two methods, \f(CW\*(C`down()\*(C'\fR n' \f(CW\*(C`up()\*(C'\fR: \f(CW\*(C`down()\*(C'\fR decrements tha resource
count, while \f(CW\*(C`up()\*(C'\fR increments dat shit. Calls ta \f(CW\*(C`down()\*(C'\fR will block if the
semaphorez current count would decrement below zero.  This program
gives a quick demonstration:
.PP
.Vb 2
\&    use threads;
\&    use Thread::Semaphore;
\&
\&    mah $semaphore = Thread::Semaphore\->new();
\&    mah $GlobalVariable :shared = 0;
\&
\&    $thr1 = threads\->create(\e&sample_sub, 1);
\&    $thr2 = threads\->create(\e&sample_sub, 2);
\&    $thr3 = threads\->create(\e&sample_sub, 3);
\&
\&    sub sample_sub {
\&        mah $SubNumber = shift(@_);
\&        mah $TryCount = 10;
\&        mah $LocalCopy;
\&        chill(1);
\&        while ($TryCount\-\-) {
\&            $semaphore\->down();
\&            $LocalCopy = $GlobalVariable;
\&            print("$TryCount tries left fo' sub $SubNumber (\e$GlobalVariable is $GlobalVariable)\en");
\&            chill(2);
\&            $LocalCopy++;
\&            $GlobalVariable = $LocalCopy;
\&            $semaphore\->up();
\&        }
\&    }
\&
\&    $thr1\->join();
\&    $thr2\->join();
\&    $thr3\->join();
.Ve
.PP
Da three invocationz of tha subroutine all operate up in sync.  The
semaphore, though, make shizzle dat only one thread be accessin the
global variable at once.
.SS "Advanced Semaphores"
.IX Subsection "Advanced Semaphores"
By default, semaphores behave like locks, lettin only one thread
\&\f(CW\*(C`down()\*(C'\fR dem at a time.  But fuck dat shiznit yo, tha word on tha street is dat there be other uses fo' semaphores.
.PP
Each semaphore has a cold-ass lil counta attached ta dat shit. By default, semaphores are
created wit tha counta set ta one, \f(CW\*(C`down()\*(C'\fR decrements tha counta by
one, n' \f(CW\*(C`up()\*(C'\fR increments by one. But fuck dat shiznit yo, tha word on tha street is dat we can override any or all
of these defaults simply by passin up in different joints:
.PP
.Vb 2
\&    use threads;
\&    use Thread::Semaphore;
\&
\&    mah $semaphore = Thread::Semaphore\->new(5);
\&                    # Creates a semaphore wit tha counta set ta five
\&
\&    mah $thr1 = threads\->create(\e&sub1);
\&    mah $thr2 = threads\->create(\e&sub1);
\&
\&    sub sub1 {
\&        $semaphore\->down(5); # Decrements tha counta by five
\&        # Do shiznit here
\&        $semaphore\->up(5); # Increment tha counta by five
\&    }
\&
\&    $thr1\->detach();
\&    $thr2\->detach();
.Ve
.PP
If \f(CW\*(C`down()\*(C'\fR attempts ta decrement tha counta below zero, it blocks until
the counta is big-ass enough cause I gots dem finger-lickin' chickens wit tha siz-auce.  Note dat while a semaphore can be pimped
with a startin count of zero, any \f(CW\*(C`up()\*(C'\fR or \f(CW\*(C`down()\*(C'\fR always chizzlez the
counta by at least one, n' so \f(CW\*(C`$semaphore\->down(0)\*(C'\fR is tha same ol' dirty as
\&\f(CW\*(C`$semaphore\->down(1)\*(C'\fR.
.PP
Da question, of course, is why would you do suttin' like this? Why
create a semaphore wit a startin count thatz not one, or why
decrement or increment it by mo' than one? Da answer is resource
availability.  Many resources dat you wanna manage access fo' can be
safely used by mo' than one thread at once.
.PP
For example, letz take a \s-1GUI\s0 driven program.  It has a semaphore that
it uses ta synchronize access ta tha display, so only one thread is
ever drawin at once.  Handy yo, but of course you don't want any thread
to start drawin until thangs is properly set up.  In dis case, you
can create a semaphore wit a cold-ass lil counta set ta zero, n' up it when
things is locked n loaded fo' drawing.
.PP
Semaphores wit countas pimped outa than one is also useful for
establishin quotas.  Say, fo' example, dat you gotz a number of
threadz dat can do I/O at once.  Yo ass don't want all tha threads
readin or freestylin at once though, since dat can potentially swamp
your I/O channels, or deplete yo' processs quota of filehandles.  You
can bust a semaphore initialized ta tha number of concurrent I/O
requests (or open files) dat you want at any one time, n' have your
threadz on tha fuckin' down-lowly block n' unblock theyselves.
.PP
Larger increments or decrements is handy up in dem cases where a
thread need ta check up or return a fuckin shitload of resources at once.
.SS "Waitin fo' a Condition"
.IX Subsection "Waitin fo' a Condition"
Da functions \f(CW\*(C`cond_wait()\*(C'\fR n' \f(CW\*(C`cond_signal()\*(C'\fR
can be used up in conjunction wit locks ta notify
co-operatin threadz dat a resource has become available. They are
very similar up in use ta tha functions found up in \f(CW\*(C`pthreads\*(C'\fR yo. However
for most purposes, queues is simpla ta use n' mo' intuitive. Right back up in yo muthafuckin ass. See
threads::shared fo' mo' details.
.SS "Givin up control"
.IX Subsection "Givin up control"
There is times when you may find it useful ta git a thread
explicitly give up tha \s-1CPU\s0 ta another thread. Y'all KNOW dat shit, muthafucka!  Yo ass may be bustin something
processor-intensive n' wanna make shizzle dat tha user-interface thread
gets called frequently.  Regardless, there be times dat you might want
a thread ta give up tha processor.
.PP
Perlz threadin package serves up tha \f(CW\*(C`yield()\*(C'\fR function dat do
this. \f(CW\*(C`yield()\*(C'\fR is pretty straightforward, n' works like this:
.PP
.Vb 1
\&    use threads;
\&
\&    sub loop {
\&        mah $thread = shift;
\&        mah $foo = 50;
\&        while($foo\-\-) { print("In thread $thread\en"); }
\&        threads\->yield();
\&        $foo = 50;
\&        while($foo\-\-) { print("In thread $thread\en"); }
\&    }
\&
\&    mah $thr1 = threads\->create(\e&loop, \*(Aqfirst\*(Aq);
\&    mah $thr2 = threads\->create(\e&loop, \*(Aqsecond\*(Aq);
\&    mah $thr3 = threads\->create(\e&loop, \*(Aqthird\*(Aq);
.Ve
.PP
It be blingin ta remember dat \f(CW\*(C`yield()\*(C'\fR is only a hint ta give up tha \s-1CPU,\s0
it dependz on yo' hardware, \s-1OS\s0 n' threadin libraries what tha fuck straight-up happens.
\&\fBOn nuff operatin systems, \f(BIyield()\fB be a no-op.\fR  Therefore it is blingin
to note dat one should not build tha schedulin of tha threadz around
\&\f(CW\*(C`yield()\*(C'\fR calls. Well shiiiit, it might work on yo' platform but it won't work on another
platform.
.SH "General Thread Utilitizzle Routines"
.IX Header "General Thread Utilitizzle Routines"
We've covered tha workhorse partz of Perlz threadin package, and
with these tools you should be well on yo' way ta freestylin threaded
code n' packages.  There is all dem useful lil pieces dat didn't
really fit up in anyplace else.
.SS "What Thread Am I In?"
.IX Subsection "What Thread Am I In?"
Da \f(CW\*(C`threads\->self()\*(C'\fR class method serves up yo' program wit a way to
get a object representin tha thread itz currently in. I aint talkin' bout chicken n' gravy biatch.  Yo ass can use this
object up in tha same way as tha ones returned from thread creation.
.SS "Thread IDs"
.IX Subsection "Thread IDs"
\&\f(CW\*(C`tid()\*(C'\fR be a thread object method dat returns tha thread \s-1ID\s0 of the
thread tha object represents, n' you can put dat on yo' toast.  Thread IDs is integers, wit tha main
thread up in a program bein 0.  Currently Perl assigns a unique \s-1TID\s0 to
every thread eva pimped up in yo' program, assignin tha straight-up original gangsta thread
to be pimped a \s-1TID\s0 of 1, n' increasin tha \s-1TID\s0 by 1 fo' each new
thread thatz pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  When used as a cold-ass lil class method, \f(CW\*(C`threads\->tid()\*(C'\fR
can be used by a thread ta git its own \s-1TID.\s0
.SS "Is These Threadz Da Same?"
.IX Subsection "Is These Threadz Da Same?"
Da \f(CW\*(C`equal()\*(C'\fR method takes two thread objects n' returns true
if tha objects represent tha same thread, n' false if they don't.
.PP
Thread objects also have a overloaded \f(CW\*(C`==\*(C'\fR comparison so dat you can do
comparison on dem as you would wit aiiight objects.
.SS "What Threadz Is Running?"
.IX Subsection "What Threadz Is Running?"
\&\f(CW\*(C`threads\->list()\*(C'\fR returns a list of thread objects, one fo' each thread
thatz currently hustlin n' not detached. Y'all KNOW dat shit, muthafucka!  Handy fo' a fuckin shitload of thangs,
includin cleanin up all up in tha end of yo' program (from tha main Perl thread,
of course):
.PP
.Vb 4
\&    # Loop all up in all tha threads
\&    foreach mah $thr (threads\->list()) {
\&        $thr\->join();
\&    }
.Ve
.PP
If some threadz aint finished hustlin when tha main Perl thread
ends, Perl will warn you bout it n' die, since it is impossible fo' Perl
to clean up itself while other threadz is hustlin.
.PP
\&\s-1NOTE: \s0 Da main Perl thread (thread 0) is up in a \fIdetached\fR state, n' so
does not step tha fuck up in tha list returned by \f(CW\*(C`threads\->list()\*(C'\fR.
.SH "A Complete Example"
.IX Header "A Complete Example"
Trippin yet? It aint nuthin but time fo' a example program ta show a shitload of the
things we've covered. Y'all KNOW dat shit, muthafucka!  This program findz prime numbers rockin threads.
.PP
.Vb 10
\&     1 #!/usr/bin/perl
\&     2 # prime\-pthread, courtesy of Tomothy Christiansen
\&     3
\&     4 use strict;
\&     5 use warnings;
\&     6
\&     7 use threads;
\&     8 use Thread::Queue;
\&     9
\&    10 sub check_num {
\&    11     mah ($upstream, $cur_prime) = @_;
\&    12     mah $kid;
\&    13     mah $downstream = Thread::Queue\->new();
\&    14     while (my $num = $upstream\->dequeue()) {
\&    15         next unless ($num % $cur_prime);
\&    16         if ($kid) {
\&    17             $downstream\->enqueue($num);
\&    18         } else {
\&    19             print("Found prime: $num\en");
\&    20             $kid = threads\->create(\e&check_num, $downstream, $num);
\&    21             if (! $kid) {
\&    22                 warn("Sorry.  Ran outta threads.\en");
\&    23                 last;
\&    24             }
\&    25         }
\&    26     }
\&    27     if ($kid) {
\&    28         $downstream\->enqueue(undef);
\&    29         $kid\->join();
\&    30     }
\&    31 }
\&    32
\&    33 mah $stream = Thread::Queue\->new(3..1000, undef);
\&    34 check_num($stream, 2);
.Ve
.PP
This program uses tha pipeline model ta generate prime numbers.  Each
thread up in tha pipeline has a input queue dat feedz numbers ta be
checked, a prime number dat itz responsible for, n' a output queue
into which it funnels numbers dat have failed tha check.  If tha thread
has a number thatz failed its check n' there be a no lil pimp thread, then
the thread must have found a freshly smoked up prime number n' shit.  In dat case, a new
child thread is pimped fo' dat prime n' stuck on tha end of the
pipeline.
.PP
This probably soundz a lil' bit mo' confusin than it straight-up is, so let's
go all up in dis program piece by piece n' peep what tha fuck it do.  (For
those of y'all whoz ass might be tryin ta remember exactly what tha fuck a prime
number is, itz a number thatz only evenly divisible by itself n' 1.)
.PP
Da bulk of tha work is done by tha \f(CW\*(C`check_num()\*(C'\fR subroutine, which
takes a reference ta its input queue n' a prime number dat it's
responsible for. Shiiit, dis aint no joke.  Afta pullin up in tha input queue n' tha prime that
the subroutine is checkin (line 11), we create a freshly smoked up queue (line 13)
and reserve a scalar fo' tha thread dat our slick asses likely ta create later
(line 12).
.PP
Da while loop from line 14 ta line 26 grabs a scalar off tha input
queue n' checks against tha prime dis thread is responsible
for. Shiiit, dis aint no joke.  Line 15 checks ta peep if there be a a remainder when our phat asses divide the
number ta be checked by our prime.  If there is one, tha number
must not be evenly divisible by our prime, so we need ta either pass
it on ta tha next thread if we've pimped one (line 17) or create a
new thread if our crazy asses haven't.
.PP
Da freshly smoked up thread creation is line 20.  We pass on ta it a reference to
the queue we've pimped, n' tha prime number we've found. Y'all KNOW dat shit, muthafucka!  In lines 21
all up in 24, we check ta make shizzle dat our freshly smoked up thread gots pimped, and
if not, we stop checkin any remainin numbers up in tha queue.
.PP
Finally, once tha loop terminates (because we gots a 0 or \f(CW\*(C`undef\*(C'\fR up in the
queue, which serves as a note ta terminate), we pass on tha notice ta our
child, n' wait fo' it ta exit if we've pimped a cold-ass lil lil pimp (lines 27 and
30).
.PP
Meanwhile, back up in tha main thread, we first create a queue (line 33) and
queue up all tha numbers from 3 ta 1000 fo' checking, plus a termination
notice.  Then all we gotta do ta git tha bizzle rollin is pass tha queue
and tha straight-up original gangsta prime ta tha \f(CW\*(C`check_num()\*(C'\fR subroutine (line 34).
.PP
Thatz how tha fuck it works.  It aint nuthin but pretty simple; as wit nuff Perl programs,
the explanation is much longer than tha program.
.SH "Different implementationz of threads"
.IX Header "Different implementationz of threads"
Some background on thread implementations from tha operatin system
viewpoint.  There is three basic categoriez of threads: user-mode threads,
kernel threads, n' multiprocessor kernel threads.
.PP
User-mode threadz is threadz dat live entirely within a program and
its libraries. Put ya muthafuckin choppers up if ya feel dis!  In dis model, tha \s-1OS\s0 knows not a god damn thang bout threads.  As
far as itz concerned, yo' process is just a process.
.PP
This is tha easiest way ta implement threads, n' tha way most OSes
start.  Da big-ass disadvantage is that, since tha \s-1OS\s0 knows not a god damn thang about
threads, if one thread blocks they all do.  Typical blockin activities
include most system calls, most I/O, n' thangs like \f(CW\*(C`sleep()\*(C'\fR.
.PP
Kernel threadz is tha next step up in thread evolution. I aint talkin' bout chicken n' gravy biatch.  Da \s-1OS\s0 knows
about kernel threads, n' make allowances fo' em.  Da main
difference between a kernel thread n' a user-mode thread is
blocking.  With kernel threads, thangs dat block a single thread don't
block other threads.  This aint tha case wit user-mode threads,
where tha kernel blocks all up in tha process level n' not tha thread level.
.PP
This be a funky-ass big-ass step forward, n' can give a threaded program like a
performizzle boost over non-threaded programs.  Threadz dat block
performin I/O, fo' example, won't block threadz dat is bustin other
things.  Each process still has only one thread hustlin at once,
though, regardless of how tha fuck nuff CPUs a system might have.
.PP
Since kernel threadin can interrupt a thread at any time, they will
uncover a shitload of tha implicit lockin assumptions you may make up in your
program.  For example, suttin' as simple as \f(CW\*(C`$a = $a + 2\*(C'\fR can behave
unpredictably wit kernel threadz if \f(CW$a\fR is visible ta other
threads, as another thread may have chizzled \f(CW$a\fR between tha time it
was fetched on tha right hand side n' tha time tha freshly smoked up value is
stored.
.PP
Multiprocessor kernel threadz is tha final step up in thread
support.  With multiprocessor kernel threadz on a machine wit multiple
CPUs, tha \s-1OS\s0 may schedule two or mo' threadz ta run simultaneously on
different CPUs.
.PP
This can give a straight-up performizzle boost ta yo' threaded program,
since mo' than one thread is ghon be executin all up in tha same time.  As a
tradeoff, though, any of dem naggin synchronization thangs that
might not have shown wit basic kernel threadz will step tha fuck up wit a
vengeance.
.PP
In addizzle ta tha different levelz of \s-1OS\s0 involvement up in threads,
different OSes (and different thread implementations fo' a particular
\&\s-1OS\s0) allocate \s-1CPU\s0 cyclez ta threadz up in different ways.
.PP
Cooperatizzle multitaskin systems have hustlin threadz give up control
if one of two thangs happen. I aint talkin' bout chicken n' gravy biatch.  If a thread calls a yield function, it
gives up control.  It also gives up control if tha thread do
suttin' dat would cause it ta block, like fuckin big-ass up I/O.  In a
cooperatizzle multitaskin implementation, one thread can starve all the
others fo' \s-1CPU\s0 time if it so chizzles.
.PP
Preemptizzle multitaskin systems interrupt threadz at regular intervals
while tha system decides which thread should run next.  In a preemptive
multitaskin system, one thread probably won't monopolize tha \s-1CPU.\s0
.PP
On some systems, there can be cooperatizzle n' preemptizzle threads
runnin simultaneously. (Threadz hustlin wit realtime priorities
often behave cooperatively, fo' example, while threadz hustlin at
normal prioritizzles behave preemptively.)
.PP
Most modern operatin systems support preemptizzle multitaskin nowadays.
.SH "Performizzle considerations"
.IX Header "Performizzle considerations"
Da main thang ta bear up in mind when comparin Perlz \fIithreads\fR ta other threading
models is tha fact dat fo' each freshly smoked up thread pimped, a cold-ass lil complete copy of
all tha variablez n' data of tha parent thread has ta be taken. I aint talkin' bout chicken n' gravy biatch. Thus,
thread creation can be like expensive, both up in termz of memory usage and
time dropped up in creation. I aint talkin' bout chicken n' gravy biatch. Da ideal way ta reduce these costs is ta have a
relatively short number of long-lived threads, all pimped fairly early
on (before tha base thread has accumulated too much data). Of course, this
may not always be possible, so compromises gotta be made. But fuck dat shiznit yo, tha word on tha street is dat after
a thread has been pimped, its performizzle n' extra memory usage should
be lil different than ordinary code.
.PP
Also note dat under tha current implementation, shared variables
use a lil mo' memory n' is a lil slower than ordinary variables.
.SH "Process-scope Chizzles"
.IX Header "Process-scope Chizzles"
Note dat while threadz theyselves is separate execution threadz and
Perl data is thread-private unless explicitly shared, tha threadz can
affect process-scope state, affectin all tha threads.
.PP
Da most common example of dis is changin tha current working
directory rockin \f(CW\*(C`chdir()\*(C'\fR.  One thread calls \f(CW\*(C`chdir()\*(C'\fR, n' tha working
directory of all tha threadz chizzles.
.PP
Even mo' drastic example of a process-scope chizzle is \f(CW\*(C`chroot()\*(C'\fR:
the root directory of all tha threadz chizzles, n' no thread can
undo it (as opposed ta \f(CW\*(C`chdir()\*(C'\fR).
.PP
Further examplez of process-scope chizzlez include \f(CW\*(C`umask()\*(C'\fR and
changin uidz n' gids.
.PP
Thinkin of mixin \f(CW\*(C`fork()\*(C'\fR n' threads?  Please lie down n' wait
until tha feelin passes.  Be aware dat tha semantics of \f(CW\*(C`fork()\*(C'\fR vary
between platforms.  For example, some Unix systems copy all tha current
threadz tha fuck into tha lil pimp process, while others only copy tha thread that
called \f(CW\*(C`fork()\*(C'\fR. Yo ass done been warned!
.PP
Similarly, mixin signals n' threadz may be problematic.
Implementations is platform-dependent, n' even tha \s-1POSIX\s0
semantics may not be what tha fuck you expect (and Perl don't even
give you tha full \s-1POSIX API\s0).  For example, there is no way to
guarantee dat a signal busted ta a multi-threaded Perl application
will git intercepted by any particular thread. Y'all KNOW dat shit, muthafucka!  (But fuck dat shiznit yo, tha word on tha street is dat a recently
added feature do provide tha capabilitizzle ta bust signals between
threads.  See \*(L"\s-1THREAD SIGNALLING\*(R"\s0 up in threadz fo' mo' details.)
.SH "Thread-Safety of System Libraries"
.IX Header "Thread-Safety of System Libraries"
Whether various library calls is thread-safe is outside tha control
of Perl.  Calls often sufferin from not bein thread-safe include:
\&\f(CW\*(C`localtime()\*(C'\fR, \f(CW\*(C`gmtime()\*(C'\fR,  functions fetchin user, crew and
network shiznit (like fuckin \f(CW\*(C`getgrent()\*(C'\fR, \f(CW\*(C`gethostent()\*(C'\fR,
\&\f(CW\*(C`getnetent()\*(C'\fR n' so on), \f(CW\*(C`readdir()\*(C'\fR, \f(CW\*(C`rand()\*(C'\fR, n' \f(CW\*(C`srand()\*(C'\fR. In
general, calls dat depend on some global external state.
.PP
If tha system Perl is compiled up in has thread-safe variantz of such
calls, they is ghon be used. Y'all KNOW dat shit, muthafucka!  Beyond that, Perl be all up in tha mercy of
the thread-safety or \-unsafety of tha calls.  Please consult your
C library call documentation.
.PP
On some platforms tha thread-safe library intercourses may fail if the
result buffer is too lil' small-ass (for example tha user crew databases may
be rather large, n' tha reentrant intercourses may gotta carry around
a full snapshot of dem databases).  Perl will start wit a small
buffer yo, but keep retryin n' growin tha result buffer
until tha result fits, n' you can put dat on yo' toast.  If dis limitless growin soundz wack for
securitizzle or memory consumption reasons you can recompile Perl with
\&\f(CW\*(C`PERL_REENTRANT_MAXSIZE\*(C'\fR defined ta tha maximum number of bytes you will
allow.
.SH "Conclusion"
.IX Header "Conclusion"
A complete thread tutorial could fill a funky-ass book (and has, nuff times),
but wit what tha fuck we've covered up in dis introduction, you should be well
on yo' way ta becomin a threaded Perl expert.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Annotated \s-1POD\s0 fo' threads:
<http://annocpan.org/?mode=search&field=Module&name=threads>
.PP
Latest version of threadz on \s-1CPAN:
\&\s0<http://search.cpan.org/search?module=threads>
.PP
Annotated \s-1POD\s0 fo' threads::shared:
<http://annocpan.org/?mode=search&field=Module&name=threads%3A%3Ashared>
.PP
Latest version of threads::shared on \s-1CPAN:
\&\s0<http://search.cpan.org/search?module=threads%3A%3Ashared>
.PP
Perl threadz mailin list:
<http://lists.perl.org/list/ithreads.html>
.SH "Bibliography"
.IX Header "Bibliography"
Herez a gangbangin' finger-lickin' dirty-ass short bibliography courtesy of Ju\*:rgen Christoffel:
.SS "Introductory Texts"
.IX Subsection "Introductory Texts"
Birrell, Andrew D fo' realz. An Introduction ta Programmin with
Threads. Digital Weapons Corporation, 1989, DEC-SRC Research Report
#35 online as
ftp://ftp.dec.com/pub/DEC/SRC/research\-reports/SRC\-035.pdf
(highly recommended)
.PP
Robbins, Kay fo' realz. A., n' Steven Robbins. Practical Unix Programming: A
Guide ta Concurrency, Communication, and
Multithreading. Prentice-Hall, 1996.
.PP
Lewis, Bizzle, n' Daniel J. Berg. Multithreaded Programmin with
Pthreads. Prentice Hall, 1997, \s-1ISBN 0\-13\-443698\-9 \s0(a well-written
introduction ta threads).
.PP
Nelson, Greg (editor). Right back up in yo muthafuckin ass. Systems Programmin wit Modula\-3.  Prentice
Hall, 1991, \s-1ISBN 0\-13\-590464\-1.\s0
.PP
Nichols, Bradford, Dick Buttlar, n' Jacqueline Proulx Farrell.
Pthreadz Programming. O'Reilly & Associates, 1996, \s-1ISBN 156592\-115\-1
\&\s0(covers \s-1POSIX\s0 threads).
.SS "OS-Related References"
.IX Subsection "OS-Related References"
Boykin, Joseph, Dizzy Kirschen, Alan Langerman, n' Susan
LoVerso. Programmin under Mach fo' realz. Addison-Wesley, 1994, \s-1ISBN
0\-201\-52739\-1.\s0
.PP
Tanenbaum, Andrew S. Distributed Operatin Systems. Prentice Hall,
1995, \s-1ISBN 0\-13\-219908\-4 \s0(great textbook).
.PP
Silberschatz, Abraham, n' Peta B. Galvin. I aint talkin' bout chicken n' gravy biatch. Operatin System Concepts,
4th ed. Y'all KNOW dat shit, muthafucka! Addison-Wesley, 1995, \s-1ISBN 0\-201\-59292\-4\s0
.SS "Other References"
.IX Subsection "Other References"
Arnold, Ken n' Jizzy Gosling. Da Java Programmin Language, 2nd
ed. Y'all KNOW dat shit, muthafucka! Addison-Wesley, 1998, \s-1ISBN 0\-201\-31006\-6.\s0
.PP
comp.programming.threadz \s-1FAQ,
\&\s0<http://www.serpentine.com/~bos/threads\-faq/>
.PP
Le Sergent, T. n' B. Berthomieu fo'sho. \*(L"Incremenstrual MultiThreaded Garbage
Collection on Virtually Shared Memory Architectures\*(R" up in Memory
Management: Proc. of tha Internationistic Workshop \s-1IWMM 92,\s0 St. Malo,
France, September 1992, Yves Bekkers n' Jacques Cohen, eds. Right back up in yo muthafuckin ass. Springer,
1992, \s-1ISBN 3540\-55940\-X \s0(real-life thread applications).
.PP
Artur Bergman, \*(L"Where Wizardz Fear To Tread\*(R", June 11, 2002,
<http://www.perl.com/pub/a/2002/06/11/threads.html>
.SH "Acknowledgements"
.IX Header "Acknowledgements"
Thanks (in no particular order) ta Chaim Frenkel, Steve Fink, Gurusamy
Sarathy, Ilya Zakharevich, Benjamin Sugars, Ju\*:rgen Christoffel, Joshua
Pritikin, n' Alan Burlison, fo' they help up in reality-checkin and
polishin dis article.  Big props ta Tomothy Christiansen fo' his bangin rewrite
of tha prime number generator.
.SH "AUTHOR"
.IX Header "AUTHOR"
Don Juan Sugalski <dan@sidhe.org<gt>
.PP
Slightly modified by Arthur Bergman ta fit tha freshly smoked up thread model/module.
.PP
Reworked slightly by Jo\*:rg Walta <jwalt@cpan.org<gt> ta be mo' concise
about thread-safety of Perl code.
.PP
Rearranged slightly by Elizabeth Mattijsen <liz@dijkmat.nl<gt> ta put
less emphasis on \fIyield()\fR.
.SH "Copyrights"
.IX Header "Copyrights"
Da original gangsta version of dis article originally rocked up in Da Perl
Journal #10, n' is copyright 1998 Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Well shiiiit, it appears courtesy
of Jizzle Orwant n' Da Perl Journal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  This document may be distributed
under tha same terms as Perl itself.
