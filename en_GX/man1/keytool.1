." Copyright (c) 1998-2011 keytool tool, Oracle and/or its affiliates fo' realz. All muthafuckin rights reserved.
." DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
."
." This code is free software; you can redistribute it and/or modify it
." under tha termz of tha GNU General Public License version 2 only, as
." published by tha Jacked Software Foundation.
."
." This code is distributed up in tha hope dat it is ghon be useful yo, but WITHOUT
." ANY WARRANTY; without even tha implied warranty of MERCHANTABILITY or
." FITNESS FOR A PARTICULAR PURPOSE.  See tha GNU General Public License
." version 2 fo' mo' details (a copy is included up in tha LICENSE file that
." accompanied dis code).
."
." Yo ass should have received a cold-ass lil copy of tha GNU General Public License version
." 2 along wit dis work; if not, write ta tha Jacked Software Foundation,
." Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
."
." Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
." or visit www.oracle.com if you need additionizzle shiznit or have any
." thangs.
."
.TH keytool 1 "16 Mar 2012"

.LP
.SH "Name"
keytool \- Key n' Certificate Management Tool
.LP
.LP
Manages a keystore (database) of cryptographic keys, X.509 certificate chains, n' trusted certificates.
.LP
.SH "SYNOPSIS"
.LP
.nf
\f3
.fl
\fP\f3keytool\fP [ commandz ]
.fl
.fi

.LP
.LP
Da keytool command intercourse has chizzled up in Java SE 6. Right back up in yo muthafuckin ass. See tha Chizzlez Section fo' a thugged-out detailed description. I aint talkin' bout chicken n' gravy biatch. Note dat previously defined commandz is still supported.
.LP
.SH "DESCRIPTION"
.LP
\f3keytool\fP be a key n' certificate pimpment utility. Well shiiiit, it allows playas ta administa they own public/private key pairs n' associated certificates fo' use up in self\-authentication (where tha user authenticates his dirty ass/herself ta other users/skillz) or data integritizzle n' authentication skillz, rockin digital signatures. Well shiiiit, it also allows playas ta cache tha hood keys (in tha form of certificates) of they communicatin peers. 
.LP
A \f2certificate\fP be a gangbangin' finger-lickin' digitally signed statement from one entitizzle (person, company, etc.), sayin dat tha hood key (and some other shiznit) of some other entitizzle has a particular value. (See Certificates.) When data is digitally signed, tha signature can be verified ta check tha data integritizzle n' authenticity. \f2Integrity\fP means dat tha data has not been modified or tampered with, n' \f2authenticity\fP means tha data indeed be reppin whoever fronts ta have pimped n' signed dat shit.
.LP
.LP
\f3keytool\fP also enablez playas ta administa secret keys used up in symmetric encryption/decryption (e.g. DES).
.LP
.LP
\f3keytool\fP stores tha keys n' certificates up in a \f2keystore\fP.
.LP
.SH "COMMAND AND OPTION NOTES"
.LP
.LP
Da various commandz n' they options is listed n' busted lyrics bout below. Note:
.LP
.RS 3
.TP 2
o
All command n' option names is preceded by a minus sign (\-). 
.TP 2
o
Da options fo' each command may be provided up in any order n' shit. 
.TP 2
o
All shit not italicized or up in braces or square brackets is required ta step tha fuck up as is. 
.TP 2
o
Braces surroundin a option generally signify dat a thugged-out default value is ghon be used if tha option aint specified on tha command line. Braces is also used round tha \f2\-v\fP, \f2\-rfc\fP, n' \f2\-J\fP options, which only have meanin if they step tha fuck up on tha command line (that is, they aint gots any "default" joints other than not existing). 
.TP 2
o
Brackets surroundin a option signify dat tha user is prompted fo' tha value(s) if tha option aint specified on tha command line. (For a \f2\-keypass\fP option, if you do not specify tha option on tha command line, \f3keytool\fP will first attempt ta use tha keystore password ta recover tha private/secret key, n' if dis fails, will then prompt you fo' tha private/secret key password.) 
.TP 2
o
Items up in italics (option joints) represent tha actual joints dat must be supplied. Y'all KNOW dat shit, muthafucka! For example, here is tha format of tha \f2\-printcert\fP command: 
.nf
\f3
.fl
  keytool \-printcert {\-file \fP\f4cert_file\fP\f3} {\-v}
.fl
\fP
.fi
.LP
When specifyin a \f2\-printcert\fP command, replace \f2cert_file\fP wit tha actual file name, as in: 
.nf
\f3
.fl
  keytool \-printcert \-file VScert.cer
.fl
\fP
.fi
.TP 2
o
Option joints must be quoted if they contain a funky-ass blank (space). 
.TP 2
o
Da \f2\-help\fP command is tha default. Thus, tha command line 
.nf
\f3
.fl
  keytool
.fl
\fP
.fi
.LP
is equivalent ta 
.nf
\f3
.fl
  keytool \-help
.fl
\fP
.fi
.RE

.LP
.SS 
Option Defaults
.LP
.LP
Below is tha defaults fo' various option joints.
.LP
.nf
\f3
.fl
\-alias "mykey"
.fl

.fl
\-keyalg
.fl
    "DSA" (when rockin \fP\f3\-genkeypair\fP\f3)
.fl
    "DES" (when rockin \fP\f3\-genseckey\fP\f3)
.fl

.fl
\-keysize
.fl
    2048 (when rockin \fP\f3\-genkeypair\fP\f3 n' \-keyalg is "RSA")
.fl
    1024 (when rockin \fP\f3\-genkeypair\fP\f3 n' \-keyalg is "DSA")
.fl
    256 (when rockin \fP\f3\-genkeypair\fP\f3 n' \-keyalg is "EC")
.fl
    56 (when rockin \fP\f3\-genseckey\fP\f3 n' \-keyalg is "DES")
.fl
    168 (when rockin \fP\f3\-genseckey\fP\f3 n' \-keyalg is "DESede")
.fl

.fl

.fl
\-validitizzle 90
.fl

.fl
\-keystore tha file named \fP\f4.keystore\fP\f3 up in tha userz home directory
.fl

.fl
\-storetype tha value of tha "keystore.type" property up in tha securitizzle propertizzles file,
.fl
           which is returned by tha static \fP\f4getDefaultType\fP\f3 method in
.fl
           \fP\f4java.security.KeyStore\fP\f3
.fl

.fl
\-file stdin if reading, stdout if writing
.fl

.fl
\-protected false
.fl
\fP
.fi

.LP
.LP
In generatin a public/private key pair, tha signature algorithm (\f2\-sigalg\fP option) is derived from tha algorithm of tha underlyin private key:
.LP
.RS 3
.TP 2
o
If tha underlyin private key iz of type "DSA", tha \f2\-sigalg\fP option defaults ta "SHA1withDSA" 
.TP 2
o
If tha underlyin private key iz of type "RSA", tha \f2\-sigalg\fP option defaults ta "SHA256withRSA". 
.TP 2
o
If tha underlyin private key iz of type "EC", tha \f2\-sigalg\fP option defaults ta "SHA256withECDSA". 
.RE

.LP
.LP
Please consult tha 
.na
\f2Java Cryptography Architecture API Justification & Reference\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA fo' a gangbangin' full list of \f2\-keyalg\fP n' \f2\-sigalg\fP you can chizzle from.
.LP
.SS 
Common Options
.LP
.LP
Da \f2\-v\fP option can step tha fuck up fo' all commandz except \f2\-help\fP. If it appears, it signifies "verbose" mode; mo' shiznit is ghon be provided up in tha output.
.LP
.LP
There be also a \f2\-J\fP\f2javaoption\fP option dat may step tha fuck up fo' any command. Y'all KNOW dat shit, muthafucka! If it appears, tha specified \f2javaoption\fP strang is passed all up in directly ta tha Java interpreter n' shit. This option should not contain any spaces. Well shiiiit, it is useful fo' adjustin tha execution environment or memory usage. For a list of possible interpreta options, type \f2java \-h\fP or \f2java \-X\fP all up in tha command line.
.LP
.LP
These options may step tha fuck up fo' all commandz operatin on a keystore:
.LP
.RS 3
.TP 3
\-storetype storetype 
.LP
This qualifier specifies tha type of keystore ta be instantiated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  
.TP 3
\-keystore keystore 
.LP
Da keystore location. I aint talkin' bout chicken n' gravy biatch. 
.LP
If tha JKS storetype is used n' a keystore file do not yet exist, then certain \f3keytool\fP commandz may result up in a freshly smoked up keystore file bein pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For example, if \f2keytool \-genkeypair\fP is invoked n' tha \f2\-keystore\fP option aint specified, tha default keystore file named \f2.keystore\fP up in tha userz home directory is ghon be pimped if it do not already exist. Right back up in yo muthafuckin ass. Similarly, if tha \f2\-keystore \fP\f2ks_file\fP option is specified but \f2ks_file\fP do not exist, then it is ghon be pimped 
.LP
Note dat tha input stream from tha \f2\-keystore\fP option is passed ta tha \f2KeyStore.load\fP method. Y'all KNOW dat shit, muthafucka! If \f2NONE\fP is specified as tha URL, then a null stream is passed ta tha \f2KeyStore.load\fP method. Y'all KNOW dat shit, muthafucka! \f2NONE\fP should be specified if tha \f2KeyStore\fP aint file\-based (for example, if it resides on a hardware token device).  
.TP 3
\-storepass[:env|:file] argument 
.LP
Da password which is used ta protect tha integritizzle of tha keystore. 
.LP
If tha modifier \f2env\fP or \f2file\fP aint specified, then tha password has tha value \f2argument\fP, which must be at least 6 charactas long. Otherwise, tha password is retrieved as bigs up: 
.RS 3
.TP 2
o
\f2env\fP: Retrieve tha password from tha environment variable named \f2argument\fP 
.TP 2
o
\f2file\fP: Retrieve tha password from tha file named \f2argument\fP 
.RE
.LP
\f3Note\fP: All other options dat require passwords, like fuckin \f2\-keypass\fP, \f2\-srckeypass\fP, \f2\-destkeypass\fP \f2\-srcstorepass\fP, n' \f2\-deststorepass\fP, accept tha \f2env\fP n' \f2file\fP modifiers. (Remember ta separate tha password option n' tha modifier wit a cold-ass lil colon, (\f2:\fP).) 
.LP
Da password must be provided ta all commandz dat access tha keystore contents, n' you can put dat on yo' toast. For such commands, if a \f2\-storepass\fP option aint provided all up in tha command line, tha user is prompted fo' dat shit. 
.LP
When retrievin shiznit from tha keystore, tha password is optional; if no password is given, tha integritizzle of tha retrieved shiznit cannot be checked n' a warnin is displayed. Y'all KNOW dat shit, muthafucka!  
.TP 3
\-providerName provider_name 
.LP
Used ta identify a cold-ass lil cryptographic steez providerz name when listed up in tha securitizzle propertizzles file.  
.TP 3
\-providerClass provider_class_name 
.LP
Used ta specify tha name of cryptographic steez providerz masta class file when tha steez provider aint listed up in tha securitizzle propertizzles file.  
.TP 3
\-providerArg provider_arg 
.LP
Used up in conjunction wit \f2\-providerClass\fP. Represents a optionizzle strang input argument fo' tha constructor of \f2provider_class_name\fP.  
.TP 3
\-protected 
.LP
Either \f2true\fP or \f2false\fP. This value should be specified as \f2true\fP if a password must be given via a protected authentication path like fuckin a thugged-out dedicated PIN reader n' shit. 
.LP
Note: Since there be two keystores involved up in \f2\-importkeystore\fP command, two options, namely, \f2\-srcprotected\fP n' \f2\-destprotected\fP is provided fo' tha source keystore n' tha destination keystore respectively.  
.TP 3
\-ext {name{:critical}{=value}} 
.LP
Denotes a X.509 certificate extension. I aint talkin' bout chicken n' gravy biatch. Da option can be used up in \-genkeypair n' \-gencert ta embed extensions tha fuck into tha certificate generated, or up in \f2\-certreq\fP ta show what tha fuck extensions is axed up in tha certificate request. Da option can step tha fuck up multiple times. name can be a supported extension name (see below) or a arbitrary OID number n' shit. value, if provided, denotes tha parameta fo' tha extension; if omitted, denotes tha default value (if defined) of tha extension or tha extension requires no parameter n' shit. Da \f2:critical\fP modifier, if provided, means tha extensionz isCritical attribute is true; otherwise, false. Yo ass may use \f2:c\fP up in place of \f2:critical\fP.  
.RE

.LP
.LP
Currently keytool supports these named extensions (case\-insensitive):
.LP
.LP
.TS
.if \n+(b.=1 .nr d. Y'all KNOW dat shit, muthafucka! \n(.c-\n(c.-1
.de 35
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 33 \n(.s
.rm 80 81
.nr 34 \n(.lu
.eo
.am 81
.br
.di a+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
Da full form: "ca:{true|false}[,pathlen:<len>]"; or, <len>, a gangbangin' finger-lickin' dirty-ass shorthand fo' "ca:true,pathlen:<len>"; or omitted, means "ca:true"
.br
.di
.nr a| \n(dn
.nr a- \n(dl
..
.ec \
.eo
.am 81
.br
.di b+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
usage(,usage)*, usage can be one of digitalSignature, nonRepudiation (contentCommitment), keyEncipherment, dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly, decipherOnly. Usage can be abbreviated wit tha straight-up original gangsta few lettas (say, dig fo' digitalSignature) or up in camel\-case steez (say, dS fo' digitalSignature, cRLS fo' cRLSign), as long as no ambiguitizzle is found. Y'all KNOW dat shit, muthafucka! Usage is case\-insensitive.
.br
.di
.nr b| \n(dn
.nr b- \n(dl
..
.ec \
.eo
.am 81
.br
.di c+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
usage(,usage)*, usage can be one of anyExtendedKeyUsage, serverAuth, clientAuth, codeSigning, emailProtection, timeStamping, OCSPSigning, or any OID string. Named usage can be abbreviated wit tha straight-up original gangsta few lettas or up in camel\-case style, as long as no ambiguitizzle is found. Y'all KNOW dat shit, muthafucka! Usage is case\-insensitive.
.br
.di
.nr c| \n(dn
.nr c- \n(dl
..
.ec \
.eo
.am 80
.br
.di d+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(80 .ll \n(80u
.in 0
SAN or SubjectAlternativeName
.br
.di
.nr d| \n(dn
.nr d- \n(dl
..
.ec \
.eo
.am 81
.br
.di e+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
type:value(,type:value)*, type can be EMAIL, URI, DNS, IP, or OID, value is tha strang format value fo' tha type.
.br
.di
.nr e| \n(dn
.nr e- \n(dl
..
.ec \
.eo
.am 80
.br
.di f+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(80 .ll \n(80u
.in 0
IAN or IssuerAlternativeName
.br
.di
.nr f| \n(dn
.nr f- \n(dl
..
.ec \
.eo
.am 81
.br
.di g+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
same as SubjectAlternativeName
.br
.di
.nr g| \n(dn
.nr g- \n(dl
..
.ec \
.eo
.am 81
.br
.di h+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
method:location\-type:location\-value (,method:location\-type:location\-value)*, method can be "timeStamping", "caRepository" or any OID. location\-type n' location\-value can be any type:value supported by tha SubjectAlternativeName extension.
.br
.di
.nr h| \n(dn
.nr h- \n(dl
..
.ec \
.eo
.am 80
.br
.di i+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(80 .ll \n(80u
.in 0
AIA or AuthorityInfoAccess
.br
.di
.nr i| \n(dn
.nr i- \n(dl
..
.ec \
.eo
.am 81
.br
.di j+
.35
.ft \n(.f
.ll \n(34u*1u/3u
.if \n(.l<\n(81 .ll \n(81u
.in 0
same as SubjectInfoAccess. method can be "ocsp","caIssuers" or any OID.
.br
.di
.nr j| \n(dn
.nr j- \n(dl
..
.ec \
.35
.nf
.ll \n(34u
.nr 80 0
.nr 38 \w\f3Name\fP
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wBC or BasicConstraints
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wKU or KeyUsage
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wEKU or ExtendedkeyUsage
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \wSIA or SubjectInfoAccess
.if \n(80<\n(38 .nr 80 \n(38
.80
.rm 80
.nr 38 \n(d-
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \n(f-
.if \n(80<\n(38 .nr 80 \n(38
.nr 38 \n(i-
.if \n(80<\n(38 .nr 80 \n(38
.nr 81 0
.nr 38 \w\f3Value\fP
.if \n(81<\n(38 .nr 81 \n(38
.81
.rm 81
.nr 38 \n(a-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(b-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(c-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(e-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(g-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(h-
.if \n(81<\n(38 .nr 81 \n(38
.nr 38 \n(j-
.if \n(81<\n(38 .nr 81 \n(38
.35
.nf
.ll \n(34u
.nr 38 1n
.nr 79 0
.nr 40 \n(79+(0*\n(38)
.nr 80 +\n(40
.nr 41 \n(80+(3*\n(38)
.nr 81 +\n(41
.nr TW \n(81
.if t .if \n(TW>\n(.li .tm Table at line 319 file Input is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\f3Name\fP\h'|\n(41u'\f3Value\fP
.ne \n(a|u+\n(.Vu
.if (\n(a|+\n(#^-1v)>\n(#- .nr #- +(\n(a|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'BC or BasicConstraints\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.a+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(b|u+\n(.Vu
.if (\n(b|+\n(#^-1v)>\n(#- .nr #- +(\n(b|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'KU or KeyUsage\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.b+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(c|u+\n(.Vu
.if (\n(c|+\n(#^-1v)>\n(#- .nr #- +(\n(c|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'EKU or ExtendedkeyUsage\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.c+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(d|u+\n(.Vu
.ne \n(e|u+\n(.Vu
.if (\n(d|+\n(#^-1v)>\n(#- .nr #- +(\n(d|+\n(#^-\n(#--1v)
.if (\n(e|+\n(#^-1v)>\n(#- .nr #- +(\n(e|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(40u
.in +\n(37u
.d+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.e+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(f|u+\n(.Vu
.ne \n(g|u+\n(.Vu
.if (\n(f|+\n(#^-1v)>\n(#- .nr #- +(\n(f|+\n(#^-\n(#--1v)
.if (\n(g|+\n(#^-1v)>\n(#- .nr #- +(\n(g|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(40u
.in +\n(37u
.f+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.g+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(h|u+\n(.Vu
.if (\n(h|+\n(#^-1v)>\n(#- .nr #- +(\n(h|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'SIA or SubjectInfoAccess\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.h+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.ne \n(i|u+\n(.Vu
.ne \n(j|u+\n(.Vu
.if (\n(i|+\n(#^-1v)>\n(#- .nr #- +(\n(i|+\n(#^-\n(#--1v)
.if (\n(j|+\n(#^-1v)>\n(#- .nr #- +(\n(j|+\n(#^-\n(#--1v)
.ta \n(80u \n(81u 
.nr 31 \n(.f
.nr 35 1m
\&\h'|\n(40u'\h'|\n(41u'
.mk ##
.nr 31 \n(##
.sp |\n(##u-1v
.nr 37 \n(40u
.in +\n(37u
.i+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(##u-1v
.nr 37 \n(41u
.in +\n(37u
.j+
.in -\n(37u
.mk 32
.if \n(32>\n(31 .nr 31 \n(32
.sp |\n(31u
.fc
.nr T. 1
.T# 1
.35
.rm a+
.rm b+
.rm c+
.rm d+
.rm e+
.rm f+
.rm g+
.rm h+
.rm i+
.rm j+
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-38

.LP
.LP
For name as OID, value is tha HEX dumped DER encodin of tha extnValue fo' tha extension excludin tha OCTET STRING type n' length bytes fo' realz. Any extra characta other than standard HEX numbers (0\-9, a\-f, A\-F) is ignored up in tha HEX string. Therefore, both \f2"01:02:03:04"\fP n' \f2"01020304"\fP is accepted as identical joints, n' you can put dat on yo' toast. If there is no value, tha extension has a empty value field then.
.LP
.LP
A special name \f2'honored'\fP, used up in \f2\-gencert\fP only, denotes how tha fuck tha extensions included up in tha certificate request should be honored. Y'all KNOW dat shit, muthafucka! Da value fo' dis name be a cold-ass lil comma separated list of \f2"all"\fP (all axed extensions is honored), \f2"name{:[critical|non\-critical]}"\fP (the named extension is honored yo, but rockin a gangbangin' finger-lickin' different isCritical attribute) n' \f2"\-name"\fP (used wit all, denotes a exception). Requested extensions is not honored by default.
.LP
.LP
If, besides tha \-ext honored option, another named or OID \-ext option is provided, dis extension is ghon be added ta dem already honored. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat if dis name (or OID) also appears up in tha honored value, its value n' criticalitizzle overrides tha one up in tha request.
.LP
.LP
Da subjectKeyIdentifier extension be always pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For non self\-signed certificates, tha authorityKeyIdentifier be always pimped.
.LP
.LP
\f3Note:\fP Users should be aware dat some combinationz of extensions (and other certificate fields) may not conform ta tha Internizzle standard. Y'all KNOW dat shit, muthafucka! See Warnin Regardin Certificate Conformizzle fo' details.
.LP
.SH "COMMANDS"
.LP
.SS 
Creatin or Addin Data ta tha Keystore
.LP
.RS 3
.TP 3
\-gencert {\-rfc} {\-infile infile} {\-outfile outfile} {\-alias alias} {\-sigalg sigalg} {\-dname dname} {\-startdate startdate {\-ext ext}* {\-validitizzle valDays} [\-keypass keypass] {\-keystore keystore} [\-storepass storepass] {\-storetype storetype} {\-providername provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Generates a cold-ass lil certificate as a response ta a cold-ass lil certificate request file (which can be pimped by tha \f2keytool \-certreq\fP command). Da command readz tha request from \f2infile\fP (if omitted, from tha standard input), signs it rockin aliass private key, n' output tha X.509 certificate tha fuck into \f2outfile\fP (if omitted, ta tha standard output). If \f2\-rfc\fP is specified, output format is BASE64\-encoded PEM; otherwise, a funky-ass binary DER is pimped. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.LP
\f2sigalg\fP specifies tha algorithm dat should be used ta sign tha certificate. \f2startdate\fP is tha start time/date dat tha certificate is valid. Y'all KNOW dat shit, muthafucka! \f2valDays\fP  drops some lyrics ta tha number of minutes fo' which tha certificate should be considered valid. Y'all KNOW dat shit, muthafucka! 
.LP
If \f2dname\fP is provided, itz used as tha subject of tha generated certificate. Otherwise, tha one from tha certificate request is used. Y'all KNOW dat shit, muthafucka! 
.LP
\f2ext\fP shows what tha fuck X.509 extensions is ghon be embedded up in tha certificate. Read Common Options fo' tha grammar of \f2\-ext\fP. 
.LP
Da \f2\-gencert\fP command enablez you ta create certificate chains. Da followin example creates a cold-ass lil certificate, \f2e1\fP, dat gotz nuff three certificates up in its certificate chain. I aint talkin' bout chicken n' gravy biatch. 
.LP
Da followin commandz creates four key pairs named \f2ca\fP, \f2ca1\fP, \f2ca2\fP, n' \f2e1\fP: 
.nf
\f3
.fl
keytool \-alias ca \-dname CN=CA \-genkeypair
.fl
keytool \-alias ca1 \-dname CN=CA \-genkeypair
.fl
keytool \-alias ca2 \-dname CN=CA \-genkeypair
.fl
keytool \-alias e1 \-dname CN=E1 \-genkeypair
.fl
\fP
.fi
.LP
Da followin two commandz create a cold-ass lil chain of signed certificates; \f2ca\fP signs ca1 n' \f2ca1 signs ca2\fP, all of which is self\-issued: 
.nf
\f3
.fl
keytool \-alias ca1 \-certreq | keytool \-alias ca \-gencert \-ext san=dns:ca1 | keytool \-alias ca1 \-importcert
.fl
keytool \-alias ca2 \-certreq | $KT \-alias ca1 \-gencert \-ext san=dns:ca2 | $KT \-alias ca2 \-importcert
.fl
\fP
.fi
.LP
Da followin command creates tha certificate \f2e1\fP n' stores it up in tha file \f2e1.cert\fP, which is signed by \f2ca2\fP fo' realz. As a result, \f2e1\fP should contain \f2ca\fP, \f2ca1\fP, n' \f2ca2\fP up in its certificate chain: 
.nf
\f3
.fl
keytool \-alias e1 \-certreq | keytool \-alias ca2 \-gencert > e1.cert
.fl
\fP
.fi
.TP 3
\-genkeypair {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} {\-sigalg sigalg} [\-dname dname] [\-keypass keypass] {\-startdate value} {\-ext ext}* {\-validitizzle valDays} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Generates a key pair (a hood key n' associated private key). Wraps tha hood key tha fuck into a X.509 v3 self\-signed certificate, which is stored as a single\-element certificate chain. I aint talkin' bout chicken n' gravy biatch. This certificate chain n' tha private key is stored up in a freshly smoked up keystore entry identified by \f2alias\fP. 
.LP
\f2keyalg\fP specifies tha algorithm ta be used ta generate tha key pair, n' \f2keysize\fP specifies tha size of each key ta be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \f2sigalg\fP specifies tha algorithm dat should be used ta sign tha self\-signed certificate; dis algorithm must be compatible wit \f2keyalg\fP. 
.LP
\f2dname\fP specifies tha X.500 Distinguished Name ta be associated wit \f2alias\fP, n' is used as tha \f2issuer\fP n' \f2subject\fP fieldz up in tha self\-signed certificate. If no distinguished name is provided all up in tha command line, tha user is ghon be prompted fo' one. 
.LP
\f2keypass\fP be a password used ta protect tha private key of tha generated key pair. Shiiit, dis aint no joke. If no password is provided, tha user is prompted fo' dat shit. If you press RETURN all up in tha prompt, tha key password is set ta tha same password as dat used fo' tha keystore. \f2keypass\fP must be at least 6 charactas long. 
.LP
\f2startdate\fP specifies tha issue time of tha certificate, also known as tha "Not Before" value of tha X.509 certificatez Validitizzle field. Y'all KNOW dat shit, muthafucka! 
.LP
Da option value can be set up in one of these two forms: 
.RS 3
.TP 3
1.
([+\-]\f2nnn\fP[ymdHMS])+ 
.TP 3
2.
[yyyy/mm/dd] [HH:MM:SS] 
.RE
.LP
With tha straight-up original gangsta form, tha issue time is shifted by tha specified value from tha current time. Da value be a cold-ass lil concatenation of a sequence of sub joints, n' you can put dat on yo' toast. Inside each sub value, tha plus sign ("+") means shiftin forward, n' tha minus sign ("\-") means shiftin backward. Y'all KNOW dat shit, muthafucka! Da time ta be shifted is \f2nnn\fP unitz of years, months, days, hours, minutes, or secondz (denoted by a single characta of "y", "m", "d", "H", "M", or "S" respectively). Da exact value of tha issue time is calculated rockin tha \f2java.util.GregorianCalendar.add(int field, int amount)\fP method on each sub value, from left ta right. For example, by specifyin \f2"\-startdate \-1y+1m\-1d"\fP, tha issue time will be: 
.nf
\f3
.fl
   Calendar c = freshly smoked up GregorianCalendar();
.fl
   c.add(Calendar.YEAR, \-1);
.fl
   c.add(Calendar.MONTH, 1);
.fl
   c.add(Calendar.DATE, \-1);
.fl
   return c.getTime()
.fl
\fP
.fi
.LP
With tha second form, tha user sets tha exact issue time up in two parts, year/month/dizzle n' hour:minute:second (usin tha local time unit). Da user may provide only one part, which means tha other part is tha same ol' dirty as tha current date (or time). User must provide tha exact number of digits as shown up in tha format definizzle (paddin wit 0 if shorter). When both tha date n' time is provided, there is one (and only one) space characta between tha two parts, n' you can put dat on yo' toast. Da minute should always be provided up in 24 minute format. 
.LP
When tha option aint provided, tha start date is tha current time. Da option can be provided at most once. 
.LP
\f2valDays\fP specifies tha number of minutes (startin all up in tha date specified by \f2\-startdate\fP, or tha current date if \f2\-startdate\fP aint specified) fo' which tha certificate should be considered valid. Y'all KNOW dat shit, muthafucka! 
.LP
This command was named \f2\-genkey\fP up in previous releases. This oldschool name is still supported up in dis release n' is ghon be supported up in future releases yo, but fo' claritizzle tha freshly smoked up name, \f2\-genkeypair\fP, is preferred goin forward. Y'all KNOW dat shit, muthafucka!  
.TP 3
\-genseckey {\-alias alias} {\-keyalg keyalg} {\-keysize keysize} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Generates a secret key n' stores it up in a freshly smoked up \f2KeyStore.SecretKeyEntry\fP identified by \f2alias\fP. 
.LP
\f2keyalg\fP specifies tha algorithm ta be used ta generate tha secret key, n' \f2keysize\fP specifies tha size of tha key ta be generated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \f2keypass\fP be a password used ta protect tha secret key. If no password is provided, tha user is prompted fo' dat shit. If you press RETURN all up in tha prompt, tha key password is set ta tha same password as dat used fo' tha keystore. \f2keypass\fP must be at least 6 charactas long.  
.TP 3
\-importcert {\-alias alias} {\-file cert_file} [\-keypass keypass] {\-noprompt} {\-trustcacerts} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Readz tha certificate or certificate chain (where tha latta is supplied up in a PKCS#7 formatted reply or a sequence of X.509 certificates) from tha file \f2cert_file\fP, n' stores it up in tha keystore entry identified by \f2alias\fP. If no file is given, tha certificate or certificate chain is read from stdin. I aint talkin' bout chicken n' gravy biatch. 
.LP
\f3keytool\fP can import X.509 v1, v2, n' v3 certificates, n' PKCS#7 formatted certificate chains consistin of certificatez of dat type. Da data ta be imported must be provided either up in binary encodin format, or up in printable encodin format (also known as Base64 encoding) as defined by tha Internizzle RFC 1421 standard. Y'all KNOW dat shit, muthafucka! In tha latta case, tha encodin must be bounded all up in tha beginnin by a strang dat starts wit "\-\-\-\-\-BEGIN", n' bounded all up in tha end by a strang dat starts wit "\-\-\-\-\-END". 
.LP
Yo ass import a cold-ass lil certificate fo' two reasons: 
.RS 3
.TP 3
1.
to add it ta tha list of trusted certificates, or 
.TP 3
2.
to import a cold-ass lil certificate reply received from a CA as tha result of submittin a Certificate Signin Request (see tha \-certreq command) ta dat CA. 
.RE
.LP
Which type of import is intended is indicated by tha value of tha \f2\-alias\fP option: 
.RS 3
.TP 3
1.
\f3If tha alias do not point ta a key entry\fP, then \f3keytool\fP assumes yo ass be addin a trusted certificate entry. In dis case, tha alias should not already exist up in tha keystore. If tha alias do already exist, then \f3keytool\fP outputs a error, since there be already a trusted certificate fo' dat alias, n' do not import tha certificate. 
.TP 3
2.
\f3If tha alias points ta a key entry\fP, then \f3keytool\fP assumes yo ass is importin a cold-ass lil certificate reply. 
.RE
\f3Importin a New Trusted Certificate\fP 
.LP
Before addin tha certificate ta tha keystore, \f3keytool\fP tries ta verify it by attemptin ta construct a cold-ass lil chain of trust from dat certificate ta a self\-signed certificate (belongin ta a root CA), rockin trusted certificates dat is already available up in tha keystore. 
.LP
If tha \f2\-trustcacerts\fP option has been specified, additionizzle certificates is considered fo' tha chain of trust, namely tha certificates up in a gangbangin' file named "cacerts". 
.LP
If \f3keytool\fP fails ta establish a trust path from tha certificate ta be imported up ta a self\-signed certificate (either from tha keystore or tha "cacerts" file), tha certificate shiznit is printed out, n' tha user is prompted ta verify it, e.g., by comparin tha displayed certificate fingerprints wit tha fingerprints obtained from some other (trusted) source of shiznit, which might be tha certificate balla his dirty ass/herself. Be straight-up careful ta ensure tha certificate is valid prior ta importin it as a "trusted" certificate biaaatch! \-\- peep WARNING Regardin Importin Trusted Certificates. Da user then has tha option of abortin tha import operation. I aint talkin' bout chicken n' gravy biatch. If tha \f2\-noprompt\fP option is given, however, there is ghon be no interaction wit tha user n' shit. 
\f3Importin a Certificate Reply\fP 
.LP
When importin a cold-ass lil certificate reply, tha certificate reply is validated rockin trusted certificates from tha keystore, n' optionally rockin tha certificates configured up in tha "cacerts" keystore file (if tha \f2\-trustcacerts\fP option was specified). 
.LP
Da methodz of determinin whether tha certificate reply is trusted is busted lyrics bout up in tha following: 
.RS 3
.TP 2
o
\f3If tha reply be a single X.509 certificate\fP, \f3keytool\fP attempts ta establish a trust chain, startin all up in tha certificate reply n' endin at a self\-signed certificate (belongin ta a root CA). Da certificate reply n' tha hierarchy of certificates used ta authenticate tha certificate reply form tha freshly smoked up certificate chain of \f2alias\fP. If a trust chain cannot be established, tha certificate reply aint imported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In dis case, \f3keytool\fP do not print up tha certificate n' prompt tha user ta verify it, cuz it is straight-up hard (if not impossible) fo' a user ta determine tha authenticitizzle of tha certificate reply. 
.TP 2
o
\f3If tha reply be a PKCS#7 formatted certificate chain or a sequence of X.509 certificates\fP, tha chain is ordered wit tha user certificate first followed by zero or mo' CA certificates. If tha chain endz wit a self\-signed root CA certificate n' \f2\-trustcacerts\fP option was specified, \f3keytool\fP will attempt ta match it wit any of tha trusted certificates up in tha keystore or tha "cacerts" keystore file. If tha chain do not end wit a self\-signed root CA certificate n' tha \f2\-trustcacerts\fP option was specified, \f3keytool\fP will try ta find one from tha trusted certificates up in tha keystore or tha "cacerts" keystore file n' add it ta tha end of tha chain. I aint talkin' bout chicken n' gravy biatch. If tha certificate aint found n' \f2\-noprompt\fP option aint specified, tha shiznit of tha last certificate up in tha chain is printed out, n' tha user is prompted ta verify dat shit. 
.RE
.LP
If tha hood key up in tha certificate reply matches tha userz hood key already stored wit under \f2alias\fP, tha oldschool certificate chain is replaced wit tha freshly smoked up certificate chain up in tha reply. Da oldschool chain can only be replaced if a valid \f2keypass\fP, tha password used ta protect tha private key of tha entry, is supplied. Y'all KNOW dat shit, muthafucka! If no password is provided, n' tha private key password is different from tha keystore password, tha user is prompted fo' dat shit. 
.LP
This command was named \f2\-import\fP up in previous releases. This oldschool name is still supported up in dis release n' is ghon be supported up in future releases yo, but fo' clarify tha freshly smoked up name, \f2\-importcert\fP, is preferred goin forward. Y'all KNOW dat shit, muthafucka!    
.TP 3
\-importkeystore \-srckeystore srckeystore \-destkeystore destkeystore {\-srcstoretype srcstoretype} {\-deststoretype deststoretype} [\-srcstorepass srcstorepass] [\-deststorepass deststorepass] {\-srcprotected} {\-destprotected} {\-srcalias srcalias {\-destalias destalias} [\-srckeypass srckeypass] [\-destkeypass destkeypass] } {\-noprompt} {\-srcProviderName src_provider_name} {\-destProviderName dest_provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Imports a single entry or all entries from a source keystore ta a thugged-out destination keystore. 
.LP
When tha \f2srcalias\fP option is provided, tha command imports tha single entry identified by tha alias ta tha destination keystore. If a thugged-out destination alias aint provided wit \f2destalias\fP, then \f2srcalias\fP is used as tha destination alias. If tha source entry is protected by a password, \f2srckeypass\fP is ghon be used ta recover tha entry. If \f2srckeypass\fP aint provided, then \f3keytool\fP will attempt ta use \f2srcstorepass\fP ta recover tha entry. If \f2srcstorepass\fP is either not provided or is incorrect, tha user is ghon be prompted fo' a password. Y'all KNOW dat shit, muthafucka! Da destination entry is ghon be protected rockin \f2destkeypass\fP. If \f2destkeypass\fP aint provided, tha destination entry is ghon be protected wit tha source entry password. Y'all KNOW dat shit, muthafucka! 
.LP
If tha \f2srcalias\fP option aint provided, then all entries up in tha source keystore is imported tha fuck into tha destination keystore. Each destination entry is ghon be stored under tha alias from tha source entry. If tha source entry is protected by a password, \f2srcstorepass\fP is ghon be used ta recover tha entry. If \f2srcstorepass\fP is either not provided or is incorrect, tha user is ghon be prompted fo' a password. Y'all KNOW dat shit, muthafucka! If a source keystore entry type aint supported up in tha destination keystore, or if a error occurs while storin a entry tha fuck into tha destination keystore, tha user is ghon be prompted whether ta skip tha entry n' continue, or ta quit. Da destination entry is ghon be protected wit tha source entry password. Y'all KNOW dat shit, muthafucka! 
.LP
If tha destination alias already exists up in tha destination keystore, tha user is prompted ta either overwrite tha entry, or ta create a freshly smoked up entry under a gangbangin' finger-lickin' different alias name. 
.LP
Note dat if \f2\-noprompt\fP is provided, tha user aint gonna be prompted fo' a freshly smoked up destination alias. Existin entries will automatically be overwritten wit tha destination alias name. Finally, entries dat can not be imported is automatically skipped n' a warnin is output.  
.TP 3
\-printcertreq {\-file file} 
.LP
Prints tha content of a PKCS #10 format certificate request, which can be generated by tha keytool \-certreq command. Y'all KNOW dat shit, muthafucka! Da command readz tha request from file; if omitted, from tha standard input.  
.RE

.LP
.SS 
Exportin Data
.LP
.RS 3
.TP 3
\-certreq {\-alias alias} {\-dname dname} {\-sigalg sigalg} {\-file certreq_file} [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Generates a Certificate Signin Request (CSR), rockin tha PKCS#10 format. 
.LP
A CSR is intended ta be busted ta a cold-ass lil certificate authoritizzle (CA). Da CA will authenticate tha certificate requestor (usually off\-line) n' will return a cold-ass lil certificate or certificate chain, used ta replace tha existin certificate chain (which initially consistz of a self\-signed certificate) up in tha keystore. 
.LP
Da private key associated wit \f2alias\fP is used ta create tha PKCS#10 certificate request. In order ta access tha private key, tha appropriate password must be provided, since private keys is protected up in tha keystore wit a password. Y'all KNOW dat shit, muthafucka! If \f2keypass\fP aint provided all up in tha command line, n' is different from tha password used ta protect tha integritizzle of tha keystore, tha user is prompted fo' dat shit. If dname is provided, itz used as tha subject up in tha CSR. Otherwise, tha X.500 Distinguished Name associated wit alias is used. Y'all KNOW dat shit, muthafucka! 
.LP
\f2sigalg\fP specifies tha algorithm dat should be used ta sign tha CSR. 
.LP
Da CSR is stored up in tha file \f2certreq_file\fP. If no file is given, tha CSR is output ta stdout. 
.LP
Use tha \f2importcert\fP command ta import tha response from tha CA.  
.TP 3
\-exportcert {\-alias alias} {\-file cert_file} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-rfc} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Readz (from tha keystore) tha certificate associated wit \f2alias\fP, n' stores it up in tha file \f2cert_file\fP. 
.LP
If no file is given, tha certificate is output ta stdout. 
.LP
Da certificate is by default output up in binary encodin yo, but will instead be output up in tha printable encodin format, as defined by tha Internizzle RFC 1421 standard, if tha \f2\-rfc\fP option is specified. Y'all KNOW dat shit, muthafucka! 
.LP
If \f2alias\fP refers ta a trusted certificate, dat certificate is output. Otherwise, \f2alias\fP refers ta a key entry wit a associated certificate chain. I aint talkin' bout chicken n' gravy biatch. In dat case, tha straight-up original gangsta certificate up in tha chain is returned. Y'all KNOW dat shit, muthafucka! This certificate authenticates tha hood key of tha entitizzle addressed by \f2alias\fP. 
.LP
This command was named \f2\-export\fP up in previous releases. This oldschool name is still supported up in dis release n' is ghon be supported up in future releases yo, but fo' clarify tha freshly smoked up name, \f2\-exportcert\fP, is preferred goin forward. Y'all KNOW dat shit, muthafucka!  
.RE

.LP
.SS 
Displayin Data
.LP
.RS 3
.TP 3
\-list {\-alias alias} {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v | \-rfc} {\-protected} {\-Jjavaoption} 
.LP
Prints (to stdout) tha contentz of tha keystore entry identified by \f2alias\fP. If no alias is specified, tha contentz of tha entire keystore is printed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
.LP
This command by default prints tha SHA1 fingerprint of a cold-ass lil certificate. If tha \f2\-v\fP option is specified, tha certificate is printed up in human\-readable format, wit additionizzle shiznit like fuckin tha baller, issuer, serial number, n' any extensions. If tha \f2\-rfc\fP option is specified, certificate contents is printed rockin tha printable encodin format, as defined by tha Internizzle RFC 1421 standard 
.LP
Yo ass cannot specify both \f2\-v\fP n' \f2\-rfc\fP.  
.TP 3
\-printcert {\-file cert_file | \-sslserver host[:port]} {\-jarfile JAR_file {\-rfc} {\-v} {\-Jjavaoption} 
.LP
Readz tha certificate from tha file \f2cert_file\fP, tha SSL server located at \f2host:port\fP, or tha signed JAR file \f2JAR_file\fP (with tha option \f2\-jarfile\fP n' prints its contents up in a human\-readable format. When no port is specified, tha standard HTTPS port 443 be assumed. Y'all KNOW dat shit, muthafucka! Note dat \f2\-sslserver\fP n' \f2\-file\fP options cannot be provided all up in tha same time. Otherwise, a error is reported. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. If neither option is given, tha certificate is read from stdin. I aint talkin' bout chicken n' gravy biatch. 
.LP
If \f2\-rfc\fP is specified, keytool prints tha certificate up in PEM mode as defined by tha Internizzle RFC 1421 standard. Y'all KNOW dat shit, muthafucka! 
.LP
If tha certificate is read from a gangbangin' file or stdin, it may be either binary encoded or up in printable encodin format, as defined by tha Internizzle RFC 1421 standard 
.LP
If tha SSL server is behind a gangbangin' firewall, \f2\-J\-Dhttps.proxyHost=proxyhost\fP n' \f2\-J\-Dhttps.proxyPort=proxyport\fP can be specified on tha command line fo' proxy tunneling. Right back up in yo muthafuckin ass. See tha 
.na
\f2JSSE Reference Guide\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html fo' mo' shiznit. I aint talkin' bout chicken n' gravy biatch. 
.LP
\f3Note\fP: This option can be used independently of a keystore.  
.TP 3
\-printcrl \-file crl_ {\-v} 
.LP
Readz tha certificate revocation list (CRL) from tha file \f2crl_file\fP. 
.LP
A Certificate Revocation List (CRL) be a list of digital certificates which done been revoked by tha Certificate Authoritizzle (CA) dat issued em. Da CA generates \f2crl_file\fP. 
.LP
\f3Note\fP: This option can be used independently of a keystore.  
.RE

.LP
.SS 
Managin tha Keystore
.LP
.RS 3
.TP 3
\-storepasswd [\-new new_storepass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption} 
.LP
Changes tha password used ta protect tha integritizzle of tha keystore contents, n' you can put dat on yo' toast. Da freshly smoked up password is \f2new_storepass\fP, which must be at least 6 charactas long.  
.TP 3
\-keypasswd {\-alias alias} [\-keypass old_keypass] [\-new new_keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-Jjavaoption} 
.LP
Changes tha password under which tha private/secret key identified by \f2alias\fP is protected, from \f2old_keypass\fP ta \f2new_keypass\fP, which must be at least 6 charactas long. 
.LP
If tha \f2\-keypass\fP option aint provided all up in tha command line, n' tha key password is different from tha keystore password, tha user is prompted fo' dat shit. 
.LP
If tha \f2\-new\fP option aint provided all up in tha command line, tha user is prompted fo' dat shit.  
.TP 3
\-delete [\-alias alias] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Deletes from tha keystore tha entry identified by \f2alias\fP. Da user is prompted fo' tha alias, if no alias is provided all up in tha command line.  
.TP 3
\-changealias {\-alias alias} [\-destalias destalias] [\-keypass keypass] {\-storetype storetype} {\-keystore keystore} [\-storepass storepass] {\-providerName provider_name} {\-providerClass provider_class_name {\-providerArg provider_arg}} {\-v} {\-protected} {\-Jjavaoption} 
.LP
Move a existin keystore entry from tha specified \f2alias\fP ta a freshly smoked up alias, \f2destalias\fP. If no destination alias is provided, tha command will prompt fo' one. If tha original gangsta entry is protected wit a entry password, tha password can be supplied via tha "\-keypass" option. I aint talkin' bout chicken n' gravy biatch. If no key password is provided, tha \f2storepass\fP (if given) is ghon be attempted first. If dat attempt fails, tha user is ghon be prompted fo' a password. Y'all KNOW dat shit, muthafucka!  
.RE

.LP
.SS 
Gettin Help
.LP
.RS 3
.TP 3
\-help 
.LP
Lists tha basic commandz n' they options. 
.LP
For mo' shiznit on some specific command, enta tha following, where \f2command_name\fP is tha name of tha command: 
.nf
\f3
.fl
    keytool \-\fP\f4command_name\fP\f3 \-help
.fl
\fP
.fi
.RE

.LP
.SH "EXAMPLES"
.LP
.LP
Suppose you wanna create a keystore fo' managin yo' public/private key pair n' certificates from entitizzles you trust.
.LP
.SS 
Generatin Yo crazy-ass Key Pair
.LP
.LP
Da first thang you need ta do is create a keystore n' generate tha key pair. Shiiit, dis aint no joke. Yo ass could bust a cold-ass lil command like fuckin tha following:
.LP
.nf
\f3
.fl
    keytool \-genkeypair \-dname "cn=Mark Jones, ou=Java, o=Oracle, c=US"
.fl
      \-alias bidnizz \-keypass \fP\f4<new password fo' private key>\fP\f3 \-keystore /working/mykeystore
.fl
      \-storepass \fP\f4<new password fo' keystore>\fP\f3 \-validitizzle 180
.fl
\fP
.fi

.LP
.LP
(Please note: This must be typed as a single line. Multiple lines is used up in tha examplez just fo' legibilitizzle purposes.)
.LP
.LP
This command creates tha keystore named "mykeystore" up in tha "working" directory (assumin it don't already exist), n' assigns it tha password specified by \f2<new password fo' keystore>\fP. Well shiiiit, it generates a public/private key pair fo' tha entitizzle whose "distinguished name" has a cold-ass lil common name of "Mark Jones", organizationizzle unit of "Java", organization of "Oracle" n' two\-letta ghetto code of "US". Well shiiiit, it uses tha default "DSA" key generation algorithm ta create tha keys, both 1024 bits long.
.LP
.LP
It creates a self\-signed certificate (usin tha default "SHA1withDSA" signature algorithm) dat includes tha hood key n' tha distinguished name shiznit. I aint talkin' bout chicken n' gravy biatch. This certificate is ghon be valid fo' 180 days, n' be associated wit tha private key up in a keystore entry referred ta by tha alias "business". Da private key be assigned tha password specified by \f2<new password fo' private key>\fP.
.LP
.LP
Da command could be hella shorta if option defaults was accepted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. As a matta of fact, no options is required; defaults is used fo' unspecified options dat have default joints, n' yo ass is prompted fo' any required joints, n' you can put dat on yo' toast. Thus, you could simply have tha following:
.LP
.nf
\f3
.fl
    keytool \-genkeypair
.fl
\fP
.fi

.LP
.LP
In dis case, a keystore entry wit alias "mykey" is pimped, wit a newly\-generated key pair n' a cold-ass lil certificate dat is valid fo' 90 days. This entry is placed up in tha keystore named ".keystore" up in yo' home directory. (Da keystore is pimped if it don't already exist.) Yo ass is ghon be prompted fo' tha distinguished name shiznit, tha keystore password, n' tha private key password.
.LP
.LP
Da rest of tha examplez assume you executed tha \f2\-genkeypair\fP command without options specified, n' dat you responded ta tha prompts wit joints equal ta dem given up in tha straight-up original gangsta \f2\-genkeypair\fP command, above (for example, a gangbangin' finger-lickin' distinguished name of "cn=Mark Jones, ou=Java, o=Oracle, c=US").
.LP
.SS 
Requestin a Signed Certificate from a Certification Authority
.LP
.LP
So far all we've gots be a self\-signed certificate fo' realz. A certificate is mo' likely ta be trusted by others if it is signed by a Certification Authoritizzle (CA). To git such a signature, you first generate a Certificate Signin Request (CSR), via tha following:
.LP
.nf
\f3
.fl
    keytool \-certreq \-file MarkJ.csr
.fl
\fP
.fi

.LP
.LP
This creates a CSR (for tha entitizzle identified by tha default alias "mykey") n' puts tha request up in tha file named "MarkJ.csr". Right back up in yo muthafuckin ass. Submit dis file ta a CA, like fuckin VeriSign, Inc. Da CA will authenticate you, tha requestor (usually off\-line), n' then will return a cold-ass lil certificate, signed by them, authenticatin yo' hood key. (In some cases, they will straight-up return a cold-ass lil chain of certificates, each one authenticatin tha hood key of tha signer of tha previous certificate up in tha chain.)
.LP
.SS 
Importin a Certificate fo' tha CA
.LP
.LP
Yo ass need ta replace yo' self\-signed certificate wit a cold-ass lil certificate chain, where each certificate up in tha chain authenticates tha hood key of tha signer of tha previous certificate up in tha chain, up ta a "root" CA.
.LP
.LP
Before you import tha certificate reply from a CA, you need one or mo' "trusted certificates" up in yo' keystore or up in tha \f2cacerts\fP keystore file (which is busted lyrics bout up in importcert command):
.LP
.RS 3
.TP 2
o
If tha certificate reply be a cold-ass lil certificate chain, you just need tha top certificate of tha chain (that is, tha "root" CA certificate authenticatin dat CAz hood key). 
.TP 2
o
If tha certificate reply be a single certificate, you need a cold-ass lil certificate fo' tha issuin CA (the one dat signed it), n' if dat certificate aint self\-signed, you need a cold-ass lil certificate fo' its signer, n' so on, up ta a self\-signed "root" CA certificate. 
.RE

.LP
.LP
Da "cacerts" keystore file ships wit nuff muthafuckin VeriSign root CA certificates, so you probably won't need ta import a VeriSign certificate as a trusted certificate up in yo' keystore. But if you request a signed certificate from a gangbangin' finger-lickin' different CA, n' a cold-ass lil certificate authenticatin dat CAz hood key aint been added ta "cacerts", yo big-ass booty is ghon need ta import a cold-ass lil certificate from tha CA as a "trusted certificate".
.LP
.LP
A certificate from a CA is probably either self\-signed, or signed by another CA (in which case you also need a cold-ass lil certificate authenticatin dat CAz hood key). Right back up in yo muthafuckin ass. Suppose company ABC, Inc., be a CA, n' you obtain a gangbangin' file named "ABCCA.cer" dat is purportedly a self\-signed certificate from ABC, authenticatin dat CAz hood key.
.LP
.LP
Be straight-up careful ta ensure tha certificate is valid prior ta importin it as a "trusted" certificate biaaatch! View it first (usin tha \f3keytool\fP \f2\-printcert\fP command, or tha \f3keytool\fP \f2\-importcert\fP command without tha \f2\-noprompt\fP option), n' make shizzle dat tha displayed certificate fingerprint(s) match tha expected ones. Yo ass can call tha thug whoz ass busted tha certificate, n' compare tha fingerprint(s) dat you peep wit tha ones dat they show (or dat a secure hood key repository shows). Only if tha fingerprints is equal is it guaranteed dat tha certificate has not been replaced up in transit wit some muthafucka elsez (for example, a attacker's) certificate. If such a battle took place, n' you did not check tha certificate before you imported it, you would end up trustin anythang tha attacker has signed.
.LP
.LP
If you trust dat tha certificate is valid, then you can add it ta yo' keystore via tha following:
.LP
.nf
\f3
.fl
    keytool \-importcert \-alias abc \-file ABCCA.cer
.fl
\fP
.fi

.LP
.LP
This creates a "trusted certificate" entry up in tha keystore, wit tha data from tha file "ABCCA.cer", n' assigns tha alias "abc" ta tha entry.
.LP
.SS 
Importin tha Certificate Reply from tha CA
.LP
.LP
Once you've imported a cold-ass lil certificate authenticatin tha hood key of tha CA you submitted yo' certificate signin request ta (or there be already such a cold-ass lil certificate up in tha "cacerts" file), you can import tha certificate reply n' thereby replace yo' self\-signed certificate wit a cold-ass lil certificate chain. I aint talkin' bout chicken n' gravy biatch. This chain is tha one returned by tha CA up in response ta yo' request (if tha CA reply be a cold-ass lil chain), or one constructed (if tha CA reply be a single certificate) rockin tha certificate reply n' trusted certificates dat is already available up in tha keystore where you import tha reply or up in tha "cacerts" keystore file.
.LP
.LP
For example, suppose you busted yo' certificate signin request ta VeriSign. I aint talkin' bout chicken n' gravy biatch. Yo ass can then import tha reply via tha following, which assumes tha returned certificate is named "VSMarkJ.cer":
.LP
.nf
\f3
.fl
    keytool \-importcert \-trustcacerts \-file VSMarkJ.cer
.fl
\fP
.fi

.LP
.SS 
Exportin a Certificate Authenticatin Yo crazy-ass Public Key
.LP
.LP
Suppose you have used tha jarsigner(1) tool ta sign a Java ARchive (JAR) file. Clients dat wanna use tha file will wanna authenticate yo' signature.
.LP
.LP
One way they can do dis is by first importin yo' hood key certificate tha fuck into they keystore as a "trusted" entry. Yo ass can export tha certificate n' supply it ta yo' clients fo' realz. As a example, you can copy yo' certificate ta a gangbangin' file named \f2MJ.cer\fP via tha following, assumin tha entry be aliased by "mykey":
.LP
.nf
\f3
.fl
    keytool \-exportcert \-alias mykey \-file MJ.cer
.fl
\fP
.fi

.LP
.LP
Given dat certificate, n' tha signed JAR file, a cold-ass lil client can use tha \f3jarsigner\fP tool ta authenticate yo' signature.
.LP
.SS 
Importin Keystore
.LP
.LP
Da command "importkeystore" is used ta import a entire keystore tha fuck into another keystore, which means all entries from tha source keystore, includin keys n' certificates, is all imported ta tha destination keystore within a single command. Y'all KNOW dat shit, muthafucka! Yo ass can use dis command ta import entries from a gangbangin' finger-lickin' different type of keystore. Durin tha import, all freshly smoked up entries up in tha destination keystore gonna git tha same alias names n' protection passwordz (for secret keys n' private keys). If \f3keytool\fP has bullshit recover tha private keys or secret keys from tha source keystore, it will prompt you fo' a password. Y'all KNOW dat shit, muthafucka! If it detects alias duplication, it will ask you fo' a freshly smoked up one, you can specify a freshly smoked up alias or simply allow \f3keytool\fP ta overwrite tha existin one.
.LP
.LP
For example, ta import entries from a aiiight JKS type keystore key.jks tha fuck into a PKCS #11 type hardware based keystore, you can use tha command:
.LP
.nf
\f3
.fl
  keytool \-importkeystore
.fl
    \-srckeystore key.jks \-destkeystore NONE
.fl
    \-srcstoretype JKS \-deststoretype PKCS11
.fl
    \-srcstorepass \fP\f4<source keystore password>\fP\f3 \-deststorepass \fP\f4<destination keystore password>\fP\f3
.fl
\fP
.fi

.LP
.LP
Da importkeystore command can also be used ta import a single entry from a source keystore ta a thugged-out destination keystore. In dis case, besides tha options you peep up in tha above example, you need ta specify tha alias you wanna import. With tha srcalias option given, you can also specify tha destination alias name up in tha command line, as well as protection password fo' a secret/private key n' tha destination protection password you want. Da followin command demonstrates this:
.LP
.nf
\f3
.fl
  keytool \-importkeystore
.fl
    \-srckeystore key.jks \-destkeystore NONE
.fl
    \-srcstoretype JKS \-deststoretype PKCS11
.fl
    \-srcstorepass \fP\f4<source keystore password>\fP\f3 \-deststorepass \fP\f4<destination keystore password>\fP\f3
.fl
    \-srcalias myprivatekey \-destalias myoldprivatekey
.fl
    \-srckeypass \fP\f4<source entry password>\fP\f3 \-destkeypass \fP\f4<destination entry password>\fP\f3
.fl
    \-noprompt
.fl
\fP
.fi

.LP
.SS 
Generatin Certificates fo' a Typical SSL Server
.LP
.LP
Da followin is keytool commandz ta generate keypairs n' certificates fo' three entities, namely, Root CA (root), Intermediate CA (ca), n' SSL server (server). Ensure dat you store all tha certificates up in tha same keystore. In these examples, it is recommended dat you specify RSA as tha key algorithm.
.LP
.nf
\f3
.fl
keytool \-genkeypair \-keystore root.jks \-alias root \-ext bc:c
.fl
keytool \-genkeypair \-keystore ca.jks \-alias ca \-ext bc:c
.fl
keytool \-genkeypair \-keystore server.jks \-alias server
.fl

.fl
keytool \-keystore root.jks \-alias root \-exportcert \-rfc > root.pem
.fl

.fl
keytool \-storepass \fP\f4<storepass>\fP\f3 \-keystore ca.jks \-certreq \-alias ca | keytool \-storepass \fP\f4<storepass>\fP\f3 \-keystore root.jks \-gencert \-alias root \-ext BC=0 \-rfc > ca.pem
.fl
keytool \-keystore ca.jks \-importcert \-alias ca \-file ca.pem
.fl

.fl
keytool \-storepass \fP\f4<storepass>\fP\f3 \-keystore server.jks \-certreq \-alias server | keytool \-storepass \fP\f4<storepass>\fP\f3 \-keystore ca.jks \-gencert \-alias ca \-ext ku:c=dig,kE \-rfc > server.pem
.fl
cat root.pem ca.pem server.pem | keytool \-keystore server.jks \-importcert \-alias server
.fl
\fP
.fi

.LP
.SH "TERMINOLOGY n' WARNINGS"
.LP
.SS 
KeyStore
.LP
.LP
A keystore be a storage facilitizzle fo' cryptographic keys n' certificates.
.LP
.RS 3
.TP 2
o
\f3KeyStore Entries\fP 
.LP
Keystores may have different typez of entries. Put ya muthafuckin choppers up if ya feel dis! Da two most applicable entry types fo' \f3keytool\fP include: 
.RS 3
.TP 3
1.
\f3key entries\fP \- each holdz straight-up sensitizzle cryptographic key shiznit, which is stored up in a protected format ta prevent unauthorized access. Typically, a key stored up in dis type of entry be a secret key, or a private key accompanied by tha certificate "chain" fo' tha correspondin hood key. Da \f3keytool\fP can handle both typez of entries, while tha \f3jarsigner\fP tool only handle tha latta type of entry, dat is private keys n' they associated certificate chains. 
.TP 3
2.
\f3trusted certificate entries\fP \- each gotz nuff a single hood key certificate belongin ta another party. Well shiiiit, it is called a "trusted certificate" cuz tha keystore balla trusts dat tha hood key up in tha certificate indeed belongs ta tha identitizzle identified by tha "subject" (baller) of tha certificate. Da issuer of tha certificate vouches fo' this, by signin tha certificate. 
.RE
.TP 2
o
\f3KeyStore Aliases\fP 
.LP
All keystore entries (key n' trusted certificate entries) is accessed via unique \f2aliases\fP. 
.LP
An alias is specified when you add a entitizzle ta tha keystore rockin tha \-genseckey command ta generate a secret key, \-genkeypair command ta generate a key pair (hood n' private key) or tha \-importcert command ta add a cold-ass lil certificate or certificate chain ta tha list of trusted certificates. Right back up in yo muthafuckin ass. Subsequent \f3keytool\fP commandz must use dis same alias ta refer ta tha entity. 
.LP
For example, suppose you use tha alias \f2duke\fP ta generate a freshly smoked up public/private key pair n' wrap tha hood key tha fuck into a self\-signed certificate (see Certificate Chains) via tha followin command: 
.nf
\f3
.fl
    keytool \-genkeypair \-alias duke \-keypass dukekeypasswd
.fl
\fP
.fi
.LP
This specifies a initial password of "dukekeypasswd" required by subsequent commandz ta access tha private key associated wit tha alias \f2duke\fP. If you lata wanna chizzle dukez private key password, you bust a cold-ass lil command like tha following: 
.nf
\f3
.fl
    keytool \-keypasswd \-alias duke \-keypass dukekeypasswd \-new newpass
.fl
\fP
.fi
.LP
This chizzlez tha password from "dukekeypasswd" ta "newpass". 
.LP
Please note: A password should not straight-up be specified on a cold-ass lil command line or up in a script unless it is fo' testin purposes, or yo ass is on a secure system. If you don't specify a required password option on a cold-ass lil command line, yo big-ass booty is ghon be prompted fo' dat shit.   
.TP 2
o
\f3KeyStore Implementation\fP 
.LP
Da \f2KeyStore\fP class provided up in tha \f2java.security\fP package supplies well\-defined intercourses ta access n' modify tha shiznit up in a keystore. Well shiiiit, it is possible fo' there ta be multiple different concrete implementations, where each implementation is dat fo' a particular \f2type\fP of keystore. 
.LP
Currently, two command\-line tools (\f3keytool\fP n' \f3jarsigner\fP) n' a GUI\-based tool named \f3Policy Tool\fP make use of keystore implementations. Right back up in yo muthafuckin ass. Since \f2KeyStore\fP is publicly available, playas can write additionizzle securitizzle applications dat use dat shit. 
.LP
There be a funky-ass built\-in default implementation, provided by Oracle. Well shiiiit, it implements tha keystore as a gangbangin' file, utilizin a proprietary keystore type (format) named "JKS". Well shiiiit, it protects each private key wit its individual password, n' also protects tha integritizzle of tha entire keystore wit a (possibly different) password. Y'all KNOW dat shit, muthafucka! 
.LP
Keystore implementations is provider\-based. Y'all KNOW dat shit, muthafucka! Mo' specifically, tha application intercourses supplied by \f2KeyStore\fP is implemented up in termz of a "Service Provider Interface" (SPI). That is, there be a cold-ass lil correspondin abstract \f2KeystoreSpi\fP class, also up in tha \f2java.security\fP package, which defines tha Service Provider Interface methodz dat "providers" must implement. (Da term "provider" refers ta a package or a set of packages dat supply a cold-ass lil concrete implementation of a subset of skillz dat can be accessed by tha Java Securitizzle API.) Thus, ta provide a keystore implementation, clients must implement a "provider" n' supply a KeystoreSpi subclass implementation, as busted lyrics bout up in 
.na
\f2How tha fuck ta Implement a Provider fo' tha Java Cryptography Architecture\fP @
.fi
http://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/HowToImplAProvider.html. 
.LP
Applications can chizzle different \f2types\fP of keystore implementations from different providers, rockin tha "getInstance" factory method supplied up in tha \f2KeyStore\fP class fo' realz. A keystore type defines tha storage n' data format of tha keystore shiznit, n' tha algorithms used ta protect private/secret keys up in tha keystore n' tha integritizzle of tha keystore itself. Keystore implementationz of different types is not compatible. 
.LP
\f3keytool\fP works on any file\-based keystore implementation. I aint talkin' bout chicken n' gravy biatch. (It treats tha keystore location dat is passed ta it all up in tha command line as a gangbangin' filename n' converts it ta a FileInputStream, from which it loadz tha keystore shiznit.) Da \f3jarsigner\fP n' \f3policytool\fP tools, on tha other hand, can read a keystore from any location dat can be specified rockin a URL. 
.LP
For \f3keytool\fP n' \f3jarsigner\fP, you can specify a keystore type all up in tha command line, via tha \f2\-storetype\fP option. I aint talkin' bout chicken n' gravy biatch. For \f3Policy Tool\fP, you can specify a keystore type via tha "Keystore" menu fo'sho. 
.LP
If you don't explicitly specify a keystore type, tha tools chizzle a keystore implementation based simply on tha value of tha \f2keystore.type\fP property specified up in tha securitizzle propertizzles file. Da securitizzle propertizzles file is called \f2java.security\fP, n' it resides up in tha securitizzle propertizzles directory, \f2java.home\fP/lib/security, where \f2java.home\fP is tha runtime environmentz directory (the \f2jre\fP directory up in tha SDK or tha top\-level directory of tha Java 2 Runtime Environment).  
.LP
Each tool gets tha \f2keystore.type\fP value n' then examines all tha currently\-installed providaz until it findz one dat implements keystorez of dat type. Well shiiiit, it then uses tha keystore implementation from dat provider n' shit. 
.LP
Da \f2KeyStore\fP class defines a static method named \f2getDefaultType\fP dat lets applications n' applets retrieve tha value of tha \f2keystore.type\fP property. Da followin line of code creates a instizzle of tha default keystore type (as specified up in tha \f2keystore.type\fP property): 
.nf
\f3
.fl
    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
.fl
\fP
.fi
.LP
Da default keystore type is "jks" (the proprietary type of tha keystore implementation provided by Oracle). This is specified by tha followin line up in tha securitizzle propertizzles file: 
.nf
\f3
.fl
    keystore.type=jks
.fl
\fP
.fi
.LP
To have tha tools utilize a keystore implementation other than tha default, you can chizzle dat line ta specify a gangbangin' finger-lickin' different keystore type. 
.LP
For example, if you gotz a provider package dat supplies a keystore implementation fo' a keystore type called "pkcs12", chizzle tha line ta 
.nf
\f3
.fl
    keystore.type=pkcs12
.fl
\fP
.fi
.LP
Note: case don't matta up in keystore type designations. For example, "JKS" would be considered tha same as "jks".  
.RE

.LP
.SS 
Certificate
.LP
A \f3certificate\fP (also known as a \f3public\-key certificate\fP) be a gangbangin' finger-lickin' digitally signed statement from one entitizzle (the \f2issuer\fP), sayin dat tha hood key (and some other shiznit) of another entitizzle (the \f2subject\fP) has some specific value. 
.RS 3
.TP 2
o
\f3Certificate Terms\fP 
.RS 3
.TP 3
Public Keys 
.LP
These is numbers associated wit a particular entity, n' is intended ta be known ta all dem fools dat need ta have trusted interactions wit dat entity. Public keys is used ta verify signatures.  
.TP 3
Digitally Signed 
.LP
If some data is \f2digitally signed\fP it has been stored wit tha "identity" of a entity, n' a signature dat proves dat entitizzle knows bout tha data. Da data is rendered unforgeable by signin wit tha entityz private key.  
.TP 3
Identitizzle 
.LP
A known way of addressin a entity. In some systems tha identitizzle is tha hood key, up in others it can be anythang from a Unix UID ta a Email address ta a X.509 Distinguished Name.  
.TP 3
Signature 
.LP
A signature is computed over some data rockin tha private key of a entitizzle (the \f2signer\fP, which up in tha case of a cold-ass lil certificate be also known as tha \f2issuer\fP).  
.TP 3
Private Keys 
.LP
These is numbers, each of which is supposed ta be known only ta tha particular entitizzle whose private key it is (that is, itz supposed ta be kept secret). Private n' hood keys exist up in pairs up in all hood key cryptography systems (also referred ta as "hood key crypto systems"). In a typical hood key crypto system, like fuckin DSA, a private key correspondz ta exactly one hood key. Private keys is used ta compute signatures.  
.TP 3
Entitizzle 
.LP
An entitizzle be a person, organization, program, computer, bidnizz, bank, or suttin' else yo ass is trustin ta some degree.  
.RE
.LP
Basically, hood key cryptography requires access ta users' hood keys. In a large\-scale networked environment it is impossible ta guarantee dat prior relationshizzlez between communicatin entitizzles done been established or dat a trusted repository exists wit all used hood keys. Certificates was invented as a solution ta dis hood key distribution problem. Now a \f2Certification Authority\fP (CA) can act as a trusted third party. CAs is entitizzles (for example, bidnizzes) dat is trusted ta sign (issue) certificates fo' other entities. Put ya muthafuckin choppers up if ya feel dis! Well shiiiit, it be assumed dat CAs will only create valid n' reliable certificates, as they is bound by legal agreements, n' you can put dat on yo' toast. There is nuff hood Certification Authorities, like fuckin 
.na
\f2VeriSign\fP @
.fi
http://www.verisign.com/, 
.na
\f2Thawte\fP @
.fi
http://www.thawte.com/, 
.na
\f2Entrust\fP @
.fi
http://www.entrust.com/, n' so on. I aint talkin' bout chicken n' gravy biatch. Yo ass can also run yo' own Certification Authoritizzle rockin shizzle like fuckin Microsizzlez Certificate Server or tha Entrust CA thang fo' yo' organization. I aint talkin' bout chicken n' gravy biatch. 
.LP
Usin \f3keytool\fP, it is possible ta display, import, n' export certificates. Well shiiiit, it be also possible ta generate self\-signed certificates. 
.LP
\f3keytool\fP currently handlez X.509 certificates.  
.TP 2
o
\f3X.509 Certificates\fP 
.LP
Da X.509 standard defines what tha fuck shiznit can go tha fuck into a cold-ass lil certificate, n' raps bout how tha fuck ta write it down (the data format) fo' realz. All tha data up in a cold-ass lil certificate is encoded rockin two related standardz called ASN.1/DER. \f2Abstract Syntax Notation 1\fP raps bout data. Da \f2Definite Encodin Rules\fP describe a single way ta store n' transfer dat data. 
.LP
All X.509 certificates have tha followin data, up in addizzle ta tha signature: 
.RS 3
.TP 3
Version 
.LP
This identifies which version of tha X.509 standard applies ta dis certificate, which affects what tha fuck shiznit can be specified up in dat shit. Thus far, three versions is defined. Y'all KNOW dat shit, muthafucka! \f3keytool\fP can import n' export v1, v2, n' v3 certificates. Well shiiiit, it generates v3 certificates. 
.LP
\f2X.509 Version 1\fP has been available since 1988, is widely deployed, n' is da most thugged-out generic. 
.LP
\f2X.509 Version 2\fP introduced tha concept of subject n' issuer unique identifiers ta handle tha possibilitizzle of reuse of subject and/or issuer names over time. Most certificate flava documents straight fuckin recommend dat names not be reused, n' dat certificates should not make use of unique identifiers. Version 2 certificates is not widely used. Y'all KNOW dat shit, muthafucka! 
.LP
\f2X.509 Version 3\fP is da most thugged-out recent (1996) n' supports tha notion of extensions, whereby mah playas can define a extension n' include it up in tha certificate. Right back up in yo muthafuckin ass. Some common extensions up in use todizzle are: \f2KeyUsage\fP (limits tha use of tha keys ta particular purposes like fuckin "signing\-only") n' \f2AlternativeNames\fP (allows other identitizzles ta also be associated wit dis hood key, e.g. DNS names, Email addresses, IP addresses). Extensions can be marked \f2critical\fP ta indicate dat tha extension should be checked n' enforced/used. Y'all KNOW dat shit, muthafucka! For example, if a cold-ass lil certificate has tha KeyUsage extension marked critical n' set ta "keyCertSign" then if dis certificate is presented durin SSL communication, it should be rejected, as tha certificate extension indicates dat tha associated private key should only be used fo' signin certificates n' not fo' SSL use.  
.TP 3
Serial Number 
.LP
Da entitizzle dat pimped tha certificate is responsible fo' assignin it a serial number ta distinguish it from other certificates it issues. This shiznit is used up in a shitload of ways, fo' example when a cold-ass lil certificate is revoked its serial number is placed up in a Certificate Revocation List (CRL).  
.TP 3
Signature Algorithm Identifier 
.LP
This identifies tha algorithm used by tha CA ta sign tha certificate.  
.TP 3
Issuer Name 
.LP
Da X.500 Distinguished Name of tha entitizzle dat signed tha certificate. This is normally a CA. Usin dis certificate implies trustin tha entitizzle dat signed dis certificate. (Note dat up in some cases, like fuckin \f2root or top\-level\fP CA certificates, tha issuer signs its own certificate.)  
.TP 3
Validitizzle Period 
.LP
Each certificate is valid only fo' a limited amount of time. This period is busted lyrics bout by a start date n' time n' a end date n' time, n' can be as short as all dem secondz or almost as long as a cold-ass lil century. Da validitizzle period chosen dependz on a fuckin shitload of factors, like fuckin tha strength of tha private key used ta sign tha certificate or tha amount one is willin ta pay fo' a cold-ass lil certificate. This is tha expected period dat entitizzles can rely on tha hood value, if tha associated private key has not been compromised. Y'all KNOW dat shit, muthafucka!  
.TP 3
Subject Name 
.LP
Da name of tha entitizzle whose hood key tha certificate identifies. Put ya muthafuckin choppers up if ya feel dis! This name uses tha X.500 standard, so it is intended ta be unique across tha Internet. This is tha X.500 Distinguished Name (DN) of tha entity, fo' example, 
.nf
\f3
.fl
    CN=Java Duke, OU=Java Software Division, O=Oracle Corporation, C=US
.fl
\fP
.fi
.LP
(These refer ta tha subjectz Common Name, Organizationizzle Unit, Organization, n' Country.)  
.TP 3
Subject Public Key Hype 
.LP
This is tha hood key of tha entitizzle bein named, together wit a algorithm identifier which specifies which hood key crypto system dis key belongs ta n' any associated key parameters.  
.RE
.TP 2
o
\f3Certificate Chains\fP 
.LP
\f3keytool\fP can create n' manage keystore "key" entries dat each contain a private key n' a associated certificate "chain". Da first certificate up in tha chain gotz nuff tha hood key correspondin ta tha private key. 
.LP
When keys is first generated (see tha \-genkeypair command), tha chain starts off containin a single element, a \f2self\-signed certificate\fP fo' realz. A self\-signed certificate is one fo' which tha issuer (signer) is tha same ol' dirty as tha subject (the entitizzle whose hood key is bein authenticated by tha certificate). Whenever tha \f2\-genkeypair\fP command is called ta generate a freshly smoked up public/private key pair, it also wraps tha hood key tha fuck into a self\-signed certificate. 
.LP
Later, afta a Certificate Signin Request (CSR) has been generated (see tha \-certreq command) n' busted ta a Certification Authoritizzle (CA), tha response from tha CA is imported (see \-importcert), n' tha self\-signed certificate is replaced by a cold-ass lil chain of certificates fo' realz. At tha bottom of tha chain is tha certificate (reply) issued by tha CA authenticatin tha subjectz hood key. Da next certificate up in tha chain is one dat authenticates tha \f2CA\fPz hood key. 
.LP
In nuff cases, dis be a self\-signed certificate (that is, a cold-ass lil certificate from tha CA authenticatin its own hood key) n' tha last certificate up in tha chain. I aint talkin' bout chicken n' gravy biatch. In other cases, tha CA may return a cold-ass lil chain of certificates. In dis case, tha bottom certificate up in tha chain is tha same ol' dirty (a certificate signed by tha CA, authenticatin tha hood key of tha key entry) yo, but tha second certificate up in tha chain be a cold-ass lil certificate signed by a \f2different\fP CA, authenticatin tha hood key of tha CA you busted tha CSR to. Then, tha next certificate up in tha chain is ghon be a cold-ass lil certificate authenticatin tha second CAz key, n' so on, until a self\-signed "root" certificate is reached. Y'all KNOW dat shit, muthafucka! Each certificate up in tha chain (afta tha first) thus authenticates tha hood key of tha signer of tha previous certificate up in tha chain. I aint talkin' bout chicken n' gravy biatch. 
.LP
Many CAs only return tha issued certificate, wit no supportin chain, especially when there be a gangbangin' flat hierarchy (no intermediates CAs). In dis case, tha certificate chain must be established from trusted certificate shiznit already stored up in tha keystore. 
.LP
A different reply format (defined by tha PKCS#7 standard) also includes tha supportin certificate chain, up in addizzle ta tha issued certificate. Both reply formats can be handled by \f3keytool\fP. 
.LP
Da top\-level (root) CA certificate is self\-signed. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat tha trust tha fuck into tha rootz hood key do not come from tha root certificate itself (anybody could generate a self\-signed certificate wit tha distinguished name of say, tha VeriSign root CA!) yo, but from other sources like a newspaper n' shit. Da root CA hood key is widely known. I aint talkin' bout chicken n' gravy biatch. Da only reason it is stored up in a cold-ass lil certificate is cuz dis is tha format understood by most tools, so tha certificate up in dis case is only used as a "vehicle" ta transhiznit tha root CAz hood key. Before you add tha root CA certificate ta yo' keystore, you should view it (usin tha \f2\-printcert\fP option) n' compare tha displayed fingerprint wit tha well\-known fingerprint (obtained from a newspaper, tha root CAz Web page, etc.).   
.TP 2
o
\f3Da cacerts Certificates File\fP 
.LP
A certificates file named \f3"cacerts"\fP resides up in tha securitizzle propertizzles directory, \f2java.home\fP/lib/security, where \f2java.home\fP is tha runtime environmentz directory (the \f2jre\fP directory up in tha SDK or tha top\-level directory of tha Java 2 Runtime Environment).  
.LP
Da "cacerts" file represents a system\-wide keystore wit CA certificates. Right back up in yo muthafuckin ass. System administrators can configure n' manage dat file rockin \f3keytool\fP, specifyin "jks" as tha keystore type. Da "cacerts" keystore file ships wit a thugged-out default set of root CA certificates; list dem wit tha followin command: 
.nf
\f3
.fl
keytool \-list \-keystore \fP\f4java.home\fP\f3/lib/security/cacerts
.fl
\fP
.fi
.LP
Da initial password of tha "cacerts" keystore file is "changeit". Right back up in yo muthafuckin ass. System administrators should chizzle dat password n' tha default access permission of dat file upon installin tha SDK. 
.LP
\f3IMPORTANT: Verify Yo crazy-ass \fP\f4cacerts\fP\f3 File\fP: Since you trust tha CAs up in tha \f2cacerts\fP file as entitizzles fo' signin n' issuin certificates ta other entities, you must manage tha \f2cacerts\fP file carefully. Da \f2cacerts\fP file should contain only certificatez of tha CAs you trust. Well shiiiit, it is yo' responsibilitizzle ta verify tha trusted root CA certificates bundled up in tha \f2cacerts\fP file n' make yo' own trust decisions. To remove a untrusted CA certificate from tha \f2cacerts\fP file, use tha delete option of tha \f2keytool\fP command. Y'all KNOW dat shit, muthafucka! Yo ass can find tha \f2cacerts\fP file up in tha JRE installation directory. Contact yo' system administrator if you aint gots permission ta edit dis file.  
.TP 2
o
\f3Da Internizzle RFC 1421 Certificate Encodin Standard\fP 
.LP
Certificates is often stored rockin tha printable encodin format defined by tha Internizzle RFC 1421 standard, instead of they binary encoding. This certificate format, also known as "Base 64 encoding", facilitates exportin certificates ta other applications by email or all up in some other mechanism. 
.LP
Certificates read by tha \f2\-importcert\fP n' \f2\-printcert\fP commandz can be up in either dis format or binary encoded. Y'all KNOW dat shit, muthafucka! 
.LP
Da \f2\-exportcert\fP command by default outputs a cold-ass lil certificate up in binary encodin yo, but will instead output a cold-ass lil certificate up in tha printable encodin format, if tha \f2\-rfc\fP option is specified. Y'all KNOW dat shit, muthafucka! 
.LP
Da \f2\-list\fP command by default prints tha SHA1 fingerprint of a cold-ass lil certificate. If tha \f2\-v\fP option is specified, tha certificate is printed up in human\-readable format, while if tha \f2\-rfc\fP option is specified, tha certificate is output up in tha printable encodin format. 
.LP
In its printable encodin format, tha encoded certificate is bounded all up in tha beginnin by 
.nf
\f3
.fl
\-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
.fl
\fP
.fi
.LP
and all up in tha end by 
.nf
\f3
.fl
\-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.fl
\fP
.fi
.RE

.LP
.SS 
X.500 Distinguished Names
.LP
.LP
X.500 Distinguished Names is used ta identify entities, like fuckin dem which is named by tha \f2subject\fP n' \f2issuer\fP (signer) fieldz of X.509 certificates. \f3keytool\fP supports tha followin subparts:
.LP
.RS 3
.TP 2
o
\f2commonName\fP \- common name of a person, e.g., "Susan Jones" 
.TP 2
o
\f2organizationUnit\fP \- lil' small-ass organization (e.g., department or division) name, e.g., "Purchasing" 
.TP 2
o
\f2organizationName\fP \- big-ass organization name, e.g., "ABCSystems, Inc." 
.TP 2
o
\f2localityName\fP \- localitizzle (city) name, e.g., "Palo Alto" 
.TP 2
o
\f2stateName\fP \- state or province name, e.g., "California" 
.TP 2
o
\f2country\fP \- two\-letta ghetto code, e.g., "CH" 
.RE

.LP
.LP
When supplyin a gangbangin' finger-lickin' distinguished name strang as tha value of a \f2\-dname\fP option, as fo' tha \f2\-genkeypair\fP  command, tha strang must be up in tha followin format:
.LP
.nf
\f3
.fl
CN=\fP\f4cName\fP\f3, OU=\fP\f4orgUnit\fP\f3, O=\fP\f4org\fP\f3, L=\fP\f4city\fP\f3, S=\fP\f4state\fP\f3, C=\fP\f4countryCode\fP\f3
.fl
\fP
.fi

.LP
.LP
where all tha italicized shit represent actual joints n' tha above keywordz is abbreviations fo' tha following:
.LP
.nf
\f3
.fl
        CN=commonName
.fl
        OU=organizationUnit
.fl
        O=organizationName
.fl
        L=localityName
.fl
        S=stateName
.fl
        C=country
.fl
\fP
.fi

.LP
.LP
A sample distinguished name strang is
.LP
.nf
\f3
.fl
CN=Mark Smizzle, OU=Java, O=Oracle, L=Cupertino, S=California, C=US
.fl
\fP
.fi

.LP
.LP
and a sample command rockin such a strang is
.LP
.nf
\f3
.fl
keytool \-genkeypair \-dname "CN=Mark Smizzle, OU=Java, O=Oracle, L=Cupertino,
.fl
S=California, C=US" \-alias mark
.fl
\fP
.fi

.LP
.LP
Case do not matta fo' tha keyword abbreviations. For example, "CN", "cn", n' "Cn" is all treated tha same.
.LP
.LP
Order matters; each subcomponent must step tha fuck up in tha designated order n' shit. But fuck dat shiznit yo, tha word on tha street is dat it aint necessary ta have all tha subcomponents, n' you can put dat on yo' toast. Yo ass may bust a subset, fo' example:
.LP
.nf
\f3
.fl
CN=Steve Meier, OU=Java, O=Oracle, C=US
.fl
\fP
.fi

.LP
.LP
If a gangbangin' finger-lickin' distinguished name strang value gotz nuff a cold-ass lil comma, tha comma must be escaped by a "\\" characta when you specify tha strang on a cold-ass lil command line, as in
.LP
.nf
\f3
.fl
   cn=Peta Schuster, ou=Java\\, Product Development, o=Oracle, c=US
.fl
\fP
.fi

.LP
.LP
It be never necessary ta specify a gangbangin' finger-lickin' distinguished name strang on a cold-ass lil command line. If it is needed fo' a cold-ass lil command yo, but not supplied on tha command line, tha user is prompted fo' each of tha subcomponents, n' you can put dat on yo' toast. In dis case, a cold-ass lil comma do not need ta be escaped by a "\\".
.LP
.SS 
WARNING Regardin Importin Trusted Certificates
.LP
.LP
IMPORTANT: Be shizzle ta check a cold-ass lil certificate straight-up carefully before importin it as a trusted certificate!
.LP
.LP
View it first (usin tha \f2\-printcert\fP command, or tha \f2\-importcert\fP command without tha \f2\-noprompt\fP option), n' make shizzle dat tha displayed certificate fingerprint(s) match tha expected ones. For example, suppose one of mah thugs sendz or emails you a cold-ass lil certificate, n' you put it up in a gangbangin' file named \f2/tmp/cert\fP. Before you consider addin tha certificate ta yo' list of trusted certificates, you can execute a \f2\-printcert\fP command ta view its fingerprints, as in
.LP
.nf
\f3
.fl
  keytool \-printcert \-file /tmp/cert
.fl
    Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
.fl
    Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
.fl
    Serial Number: 59092b34
.fl
    Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
.fl
    Certificate Fingerprints:
.fl
         MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
.fl
         SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
.fl
         SHA256: 90:7B:70:0A:EA:DC:16:79:92:99:41:FF:8A:FE:EB:90:
.fl
                 17:75:E0:90:B2:24:4D:3A:2A:16:A6:E4:11:0F:67:A4
.fl
\fP
.fi

.LP
.LP
Then call or otherwise contact tha thug whoz ass busted tha certificate, n' compare tha fingerprint(s) dat you peep wit tha ones dat they show. Only if tha fingerprints is equal is it guaranteed dat tha certificate has not been replaced up in transit wit some muthafucka elsez (for example, a attacker's) certificate. If such a battle took place, n' you did not check tha certificate before you imported it, you would end up trustin anythang tha attacker has signed (for example, a JAR file wit malicious class filez inside).
.LP
.LP
Note: it aint required dat you execute a \f2\-printcert\fP command prior ta importin a cold-ass lil certificate, since before addin a cold-ass lil certificate ta tha list of trusted certificates up in tha keystore, tha \f2\-importcert\fP command prints up tha certificate shiznit n' prompts you ta verify dat shit. Yo ass then have tha option of abortin tha import operation. I aint talkin' bout chicken n' gravy biatch. Note, however, dis is only tha case if you invoke tha \f2\-importcert\fP command without tha \f2\-noprompt\fP option. I aint talkin' bout chicken n' gravy biatch. If tha \f2\-noprompt\fP option is given, there is no interaction wit tha user.
.LP
.SS 
Warnin Regardin Passwords
.LP
.LP
Most commandz operatin on a keystore require tha store password. Y'all KNOW dat shit, muthafucka! Some commandz require a private/secret key password.
.LP
.LP
Passwordz can be specified on tha command line (in tha \f2\-storepass\fP n' \f2\-keypass\fP options, respectively). But fuck dat shiznit yo, tha word on tha street is dat a password should not be specified on a cold-ass lil command line or up in a script unless it is fo' testin purposes, or yo ass is on a secure system.
.LP
.LP
If you don't specify a required password option on a cold-ass lil command line, yo big-ass booty is ghon be prompted fo' dat shit.
.LP
.SS 
Warnin Regardin Certificate Conformance
.LP
.LP
Da Internizzle standard 
.na
\f2RFC 5280\fP @
.fi
http://tools.ietf.org/rfc/rfc5280.txt has defined a flava on conformin X.509 certificates, which includes what tha fuck joints n' value combinations is valid fo' certificate fieldz n' extensions. \f3keytool\fP has not enforced all these rulez so it can generate certificates which do not conform ta tha standard, n' these certificates might be rejected by JRE or other applications. Users should make shizzle dat they provide tha erect options fo' \f2\-dname\fP, \f2\-ext\fP, etc.
.LP
.SH "SEE ALSO"
.LP
.RS 3
.TP 2
o
jar(1) tool documentation 
.TP 2
o
jarsigner(1) tool documentation 
.TP 2
o
the 
.na
\f4Security\fP @
.fi
http://docs.oracle.com/javase/tutorial/security/index.html trail of tha 
.na
\f4Java Tutorial\fP @
.fi
http://docs.oracle.com/javase/tutorial/ fo' examplez of tha use of \f3keytool\fP 
.RE

.LP
.SH "CHANGES"
.LP
.LP
Da command intercourse fo' keytool chizzled up in Java SE 6.
.LP
.LP
\f3keytool\fP no longer displays password input when entered by users. Right back up in yo muthafuckin ass. Since password input can no longer be viewed when entered, playas is ghon be prompted ta re\-enta passwordz any time a password is bein set or chizzled (for example, when settin tha initial keystore password, or when changin a key password).
.LP
.LP
Some commandz have simply been renamed, n' other commandz deemed obsolete is no longer listed up in dis document fo' realz. All previous commandz (both renamed n' obsolete) is still supported up in dis release n' will continue ta be supported up in future releases. Da followin summarizes all of tha chizzlez made ta tha keytool command intercourse:
.LP
.LP
Renamed commands:
.LP
.RS 3
.TP 2
o
\f2\-export\fP, renamed ta \f2\-exportcert\fP 
.TP 2
o
\f2\-genkey\fP, renamed ta \f2\-genkeypair\fP 
.TP 2
o
\f2\-import\fP, renamed ta \f2\-importcert\fP 
.RE

.LP
.LP
Commandz deemed obsolete n' no longer documented:
.LP
.RS 3
.TP 2
o
.na
\f2\-keyclone\fP @
.fi
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#keycloneCmd 
.TP 2
o
.na
\f2\-identitydb\fP @
.fi
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#identitydbCmd 
.TP 2
o
.na
\f2\-selfcert\fP @
.fi
http://java.sun.com/j2se/1.5.0/docs/tooldocs/windows/keytool.html#selfcertCmd 
.RE

.LP
 
