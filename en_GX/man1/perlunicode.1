.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLUNICODE 1"
.TH PERLUNICODE 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlunicode \- Unicode support up in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Important Caveats"
.IX Subsection "Important Caveats"
Unicode support be a extensive requirement. While Perl do not
implement tha Unicode standard or tha accompanyin technical reports
from cover ta cover, Perl do support nuff Unicode features.
.PP
Muthafuckas whoz ass wanna learn ta use Unicode up in Perl, should probably read
the Perl Unicode tutorial, perlunitut and
perluniintro, before reading
this reference document.
.PP
Also, tha use of Unicode may present securitizzle thangs dat aren't obvious.
Read Unicode Securitizzle Considerations <http://www.unicode.org/reports/tr36>.
.ie n .IP "Safest if you ""use feature 'unicode_strings'""" 4
.el .IP "Safest if you ``use feature 'unicode_strings'''" 4
.IX Item "Safest if you use feature 'unicode_strings'"
In order ta preserve backward compatibility, Perl do not turn
on full internal Unicode support unless tha pragma
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR is specified. Y'all KNOW dat shit, muthafucka!  (This be automatically
selected if you use \f(CW\*(C`use 5.012\*(C'\fR or higher.)  Failure ta do dis can
trigger unexpected surprises.  See \*(L"Da \*(R"Unicode Bug"" below.
.Sp
This pragma don't affect I/O.  Nor do it chizzle tha internal
representation of strings, only they interpretation. I aint talkin' bout chicken n' gravy biatch.  There is still
several places where Unicode aint straight-up supported, like fuckin in
filenames.
.IP "Input n' Output Layers" 4
.IX Item "Input n' Output Layers"
Perl knows when a gangbangin' filehandle uses Perlz internal Unicode encodings
(\s-1UTF\-8,\s0 or UTF-EBCDIC if up in \s-1EBCDIC\s0) if tha filehandle is opened with
the \*(L":encoding(utf8)\*(R" layer n' shit.  Other encodings can be converted ta Perl's
encodin on input or from Perlz encodin on output by use of the
\&\*(L":encoding(...)\*(R"  layer n' shit.  See open.
.Sp
To indicate dat Perl source itself is up in \s-1UTF\-8,\s0 use \f(CW\*(C`use utf8;\*(C'\fR.
.ie n .IP """use utf8"" still needed ta enable \s-1UTF\-8/UTF\-EBCDIC\s0 up in scripts" 4
.el .IP "\f(CWuse utf8\fR still needed ta enable \s-1UTF\-8/UTF\-EBCDIC\s0 up in scripts" 4
.IX Item "use utf8 still needed ta enable UTF-8/UTF-EBCDIC up in scripts"
As a cold-ass lil compatibilitizzle measure, tha \f(CW\*(C`use utf8\*(C'\fR pragma must be explicitly
included ta enable recognizzle of \s-1UTF\-8\s0 up in tha Perl scripts theyselves
(in strang or regular expression literals, or up in identifier names) on
ASCII-based machines or ta recognize UTF-EBCDIC on EBCDIC-based
machines.  \fBThese is tha only times when a explicit \f(CB\*(C`use utf8\*(C'\fB
is needed.\fR  See utf8.
.IP "BOM-marked scripts n' \s-1UTF\-16\s0 scripts autodetected" 4
.IX Item "BOM-marked scripts n' UTF-16 scripts autodetected"
If a Perl script begins marked wit tha Unicode \s-1BOM \s0(\s-1UTF\-16LE, UTF16\-BE,\s0
or \s-1UTF\-8\s0), or if tha script be lookin like non-BOM-marked \s-1UTF\-16\s0 of either
endianness, Perl will erectly read up in tha script as Unicode.
(BOMless \s-1UTF\-8\s0 cannot be effectively recognized or differentiated from
\&\s-1ISO 8859\-1\s0 or other eight-bit encodings.)
.ie n .IP """use encoding"" needed ta upgrade non\-Latin\-1 byte strings" 4
.el .IP "\f(CWuse encoding\fR needed ta upgrade non\-Latin\-1 byte strings" 4
.IX Item "use encodin needed ta upgrade non-Latin-1 byte strings"
By default, there be a gangbangin' fundamenstrual asymmetry up in Perlz Unicode model:
implicit upgradin from byte strings ta Unicode strings assumes that
they was encoded up in \fI\s-1ISO 8859\-1 \s0(Latin\-1)\fR yo, but Unicode strings are
downgraded wit \s-1UTF\-8\s0 encoding.  This happens cuz tha straight-up original gangsta 256
codepoints up in Unicode happens ta smoke wit Latin\-1.
.Sp
See \*(L"Byte n' Characta Semantics\*(R" fo' mo' details.
.SS "Byte n' Characta Semantics"
.IX Subsection "Byte n' Characta Semantics"
Perl uses logically-wide charactas ta represent strings internally.
.PP
Startin up in Perl 5.14, Perl-level operations work with
charactas rather than bytes within tha scope of a
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR (or equivalently
\&\f(CW\*(C`use 5.012\*(C'\fR or higher).  (This aint legit if bytes have been
explicitly axed by \f(CW\*(C`use bytes\*(C'\fR, nor necessarily true
for interactions wit tha platformz operatin system.)
.PP
For earlier Perls, n' when \f(CW\*(C`unicode_strings\*(C'\fR aint up in effect, Perl
provides a gangbangin' fairly safe environment dat can handle both types of
semantics up in programs.  For operations where Perl can unambiguously
decizzle dat tha input data is characters, Perl switches ta character
semantics.  For operations where dis determination cannot be made
without additionizzle shiznit from tha user, Perl decides up in favor of
compatibilitizzle n' chizzlez ta use byte semantics.
.PP
When \f(CW\*(C`use locale\*(C'\fR (but not \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR) is in
effect, Perl uses tha semantics associated wit tha current locale.
(\f(CW\*(C`use locale\*(C'\fR overrides \f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR up in tha same scope;
while \f(CW\*(C`use locale \*(Aq:not_characters\*(Aq\*(C'\fR effectively also selects
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR up in its scope; peep perllocale.)
Otherwise, Perl uses tha platformz native
byte semantics fo' charactas whose code points is less than 256, and
Unicode semantics fo' dem pimped outa than 255.  That means dat non-ASCII
charactas is undefined except fo' their
ordinal numbers.  This means dat none have case (upper n' lower), nor is any
a gangmember of characta classes, like \f(CW\*(C`[:alpha:]\*(C'\fR or \f(CW\*(C`\ew\*(C'\fR.  (But all do belong
to tha \f(CW\*(C`\eW\*(C'\fR class or tha Perl regular expression extension \f(CW\*(C`[:^alpha:]\*(C'\fR.)
.PP
This behavior preserves compatibilitizzle wit earlier versionz of Perl,
which allowed byte semantics up in Perl operations only if
none of tha programz inputs was marked as bein a source of Unicode
characta data.  Such data may come from filehandles, from calls to
external programs, from shiznit provided by tha system (like fuckin \f(CW%ENV\fR),
or from literals n' constants up in tha source text.
.PP
Da \f(CW\*(C`utf8\*(C'\fR pragma is primarily a cold-ass lil compatibilitizzle thang dat enables
recognizzle of \s-1UTF\-\s0(8|EBCDIC) up in literals encountered by tha parser.
Note dat dis pragma is only required while Perl defaults ta byte
semantics; when characta semantics become tha default, dis pragma
may become a no-op.  See utf8.
.PP
If strings operatin under byte semantics n' strings wit Unicode
characta data is concatenated, tha freshly smoked up strang will have
characta semantics.  This can cause surprises: See \*(L"\s-1BUGS\*(R"\s0, below.
Yo ass can chizzle ta be warned when dis happens.  See encoding::warnings.
.PP
Under characta semantics, nuff operations dat formerly operated on
bytes now operate on charactas fo' realz. A characta up in Perl is
logically just a number rangin from 0 ta 2**31 or so. Larger
charactas may encode tha fuck into longer sequencez of bytes internally yo, but
this internal detail is mostly hidden fo' Perl code.
See perluniintro fo' more.
.SS "Effectz of Characta Semantics"
.IX Subsection "Effectz of Characta Semantics"
Characta semantics have tha followin effects:
.IP "\(bu" 4
Strings\*(--includin hash keys\*(--and regular expression patterns may
contain charactas dat have a ordinal value larger than 255.
.Sp
If you bust a Unicode editor ta edit yo' program, Unicode charactas may
occur directly within tha literal strings up in \s-1UTF\-8\s0 encoding, or \s-1UTF\-16.
\&\s0(Da forma requires a \s-1BOM\s0 or \f(CW\*(C`use utf8\*(C'\fR, tha latta requires a \s-1BOM.\s0)
.Sp
Unicode charactas can also be added ta a strang by rockin tha \f(CW\*(C`\eN{U+...}\*(C'\fR
notation. I aint talkin' bout chicken n' gravy biatch.  Da Unicode code fo' tha desired character, up in hexadecimal,
should be placed up in tha braces, afta tha \f(CW\*(C`U\*(C'\fR. For instance, a smiley grill is
\&\f(CW\*(C`\eN{U+263A}\*(C'\fR.
.Sp
Alternatively, you can use tha \f(CW\*(C`\ex{...}\*(C'\fR notation fo' charactas 0x100 and
above.  For charactas below 0x100 you may git byte semantics instead of
characta semantics;  peep \*(L"Da \*(R"Unicode Bug"".  On \s-1EBCDIC\s0 machines there is
the additionizzle problem dat tha value fo' such charactas gives tha \s-1EBCDIC\s0
characta rather than tha Unicode one, thus it is mo' portable ta use
\&\f(CW\*(C`\eN{U+...}\*(C'\fR instead.
.Sp
Additionally, you can use tha \f(CW\*(C`\eN{...}\*(C'\fR notation n' put tha official
Unicode characta name within tha braces, such as
\&\f(CW\*(C`\eN{WHITE SMILING FACE}\*(C'\fR.  This automatically loadz tha charnames
module wit tha \f(CW\*(C`:full\*(C'\fR n' \f(CW\*(C`:short\*(C'\fR options.  If you prefer different
options fo' dis module, you can instead, before tha \f(CW\*(C`\eN{...}\*(C'\fR,
explicitly load it wit yo' desired options; fo' example,
.Sp
.Vb 1
\&   use charnames \*(Aq:loose\*(Aq;
.Ve
.IP "\(bu" 4
If a appropriate encodin is specified, identifiers within the
Perl script may contain Unicode alphanumeric characters, including
ideographs.  Perl do not currently attempt ta canonicalize variable
names.
.IP "\(bu" 4
Regular expressions match charactas instead of bytes.  \*(L".\*(R" matches
a characta instead of a funky-ass byte.
.IP "\(bu" 4
Bracketed characta classes up in regular expressions match charactas instead of
bytes n' match against tha characta propertizzles specified up in the
Unicode propertizzles database.  \f(CW\*(C`\ew\*(C'\fR can be used ta match a Japanese
ideograph, fo' instance.
.IP "\(bu" 4
Named Unicode properties, scripts, n' block ranges may be used (like bracketed
characta classes) by rockin tha \f(CW\*(C`\ep{}\*(C'\fR \*(L"matches property\*(R" construct and
the \f(CW\*(C`\eP{}\*(C'\fR negation, \*(L"doesn't match property\*(R".
See \*(L"Unicode Characta Properties\*(R" fo' mo' details.
.Sp
Yo ass can define yo' own characta propertizzles n' use them
in tha regular expression wit tha \f(CW\*(C`\ep{}\*(C'\fR or \f(CW\*(C`\eP{}\*(C'\fR construct.
See \*(L"User-Defined Characta Properties\*(R" fo' mo' details.
.IP "\(bu" 4
Da special pattern \f(CW\*(C`\eX\*(C'\fR matches a logical character, a \*(L"extended grapheme
cluster\*(R" up in Standardese n' you can put dat on yo' toast.  In Unicode what tha fuck appears ta tha user ta be a single
character, fo' example a accented \f(CW\*(C`G\*(C'\fR, may up in fact be composed of a sequence
of characters, up in dis case a \f(CW\*(C`G\*(C'\fR followed by a accent character n' shit.  \f(CW\*(C`\eX\*(C'\fR
will match tha entire sequence.
.IP "\(bu" 4
Da \f(CW\*(C`tr///\*(C'\fR operator translates charactas instead of bytes.  Note
that tha \f(CW\*(C`tr///CU\*(C'\fR functionalitizzle has been removed. Y'all KNOW dat shit, muthafucka!  For similar
functionalitizzle peep pack('U0', ...) n' pack('C0', ...).
.IP "\(bu" 4
Case translation operators use tha Unicode case translation tables
when characta input is provided. Y'all KNOW dat shit, muthafucka!  Note dat \f(CW\*(C`uc()\*(C'\fR, or \f(CW\*(C`\eU\*(C'\fR in
interpolated strings, translates ta uppercase, while \f(CW\*(C`ucfirst\*(C'\fR,
or \f(CW\*(C`\eu\*(C'\fR up in interpolated strings, translates ta titlecase up in languages
that make tha distinction (which is equivalent ta uppercase up in languages
without tha distinction).
.IP "\(bu" 4
Most operators dat deal wit positions or lengths up in a strang will
automatically switch ta rockin characta positions, including
\&\f(CW\*(C`chop()\*(C'\fR, \f(CW\*(C`chomp()\*(C'\fR, \f(CW\*(C`substr()\*(C'\fR, \f(CW\*(C`pos()\*(C'\fR, \f(CW\*(C`index()\*(C'\fR, \f(CW\*(C`rindex()\*(C'\fR,
\&\f(CW\*(C`sprintf()\*(C'\fR, \f(CW\*(C`write()\*(C'\fR, n' \f(CW\*(C`length()\*(C'\fR.  An operator that
specifically do not switch is \f(CW\*(C`vec()\*(C'\fR.  Operators dat straight-up don't
care include operators dat treat strings as a funky-ass bucket of bits such as
\&\f(CW\*(C`sort()\*(C'\fR, n' operators dealin wit filenames.
.IP "\(bu" 4
Da \f(CW\*(C`pack()\*(C'\fR/\f(CW\*(C`unpack()\*(C'\fR letta \f(CW\*(C`C\*(C'\fR do \fInot\fR chizzle, since it is often
used fo' byte-oriented formats, n' you can put dat on yo' toast.  Again, be thinkin \f(CW\*(C`char\*(C'\fR up in tha C language.
.Sp
There be a freshly smoked up \f(CW\*(C`U\*(C'\fR specifier dat converts between Unicode characters
and code points, n' you can put dat on yo' toast. There be also a \f(CW\*(C`W\*(C'\fR specifier dat is tha equivalent of
\&\f(CW\*(C`chr\*(C'\fR/\f(CW\*(C`ord\*(C'\fR n' properly handlez characta joints even if they is above 255.
.IP "\(bu" 4
Da \f(CW\*(C`chr()\*(C'\fR n' \f(CW\*(C`ord()\*(C'\fR functions work on characters, similar to
\&\f(CW\*(C`pack("W")\*(C'\fR n' \f(CW\*(C`unpack("W")\*(C'\fR, \fInot\fR \f(CW\*(C`pack("C")\*(C'\fR and
\&\f(CW\*(C`unpack("C")\*(C'\fR.  \f(CW\*(C`pack("C")\*(C'\fR n' \f(CW\*(C`unpack("C")\*(C'\fR is methodz for
emulatin byte-oriented \f(CW\*(C`chr()\*(C'\fR n' \f(CW\*(C`ord()\*(C'\fR on Unicode strings.
While these methodz reveal tha internal encodin of Unicode strings,
that aint suttin' one normally need ta care bout at all.
.IP "\(bu" 4
Da bit strang operators, \f(CW\*(C`& | ^ ~\*(C'\fR, can operate on characta data.
But fuck dat shiznit yo, tha word on tha street is dat fo' backward compatibility, like fuckin when rockin bit string
operations when charactas is all less than 256 up in ordinal value, one
should not use \f(CW\*(C`~\*(C'\fR (the bit complement) wit charactaz of both
values less than 256 n' joints pimped outa than 256.  Most blinginly,
DeMorganz laws (\f(CW\*(C`~($x|$y) eq ~$x&~$y\*(C'\fR n' \f(CW\*(C`~($x&$y) eq ~$x|~$y\*(C'\fR)
will not hold. Y'all KNOW dat shit, muthafucka!  Da reason fo' dis mathematical \fIfaux pas\fR is that
the complement cannot return \fBboth\fR tha 8\-bit (byte-wide) bit
complement \fBand\fR tha full character-wide bit complement.
.IP "\(bu" 4
There be a \s-1CPAN\s0 module, Unicode::Casing, which allows you ta define
your own mappings ta be used up in \f(CW\*(C`lc()\*(C'\fR, \f(CW\*(C`lcfirst()\*(C'\fR, \f(CW\*(C`uc()\*(C'\fR,
\&\f(CW\*(C`ucfirst()\*(C'\fR, n' \f(CW\*(C`fc\*(C'\fR (or they double-quoted strang inlined
versions like fuckin \f(CW\*(C`\eU\*(C'\fR).
(Prior ta Perl 5.16, dis functionalitizzle was partially provided
in tha Perl core yo, but suffered from a fuckin shitload of insurmountable
drawbacks, so tha \s-1CPAN\s0 module was freestyled instead.)
.IP "\(bu" 4
And finally, \f(CW\*(C`scalar reverse()\*(C'\fR reverses by characta rather than by byte.
.SS "Unicode Characta Properties"
.IX Subsection "Unicode Characta Properties"
(Da only time dat Perl considaz a sequence of individual code
points as a single logical characta is up in tha \f(CW\*(C`\eX\*(C'\fR construct, already
mentioned above.   Therefore \*(L"character\*(R" up in dis rap means a single
Unicode code point.)
.PP
Straight-up nearly all Unicode characta propertizzles is accessible through
regular expressions by rockin tha \f(CW\*(C`\ep{}\*(C'\fR \*(L"matches property\*(R" construct
and tha \f(CW\*(C`\eP{}\*(C'\fR \*(L"doesn't match property\*(R" fo' its negation.
.PP
For instance, \f(CW\*(C`\ep{Uppercase}\*(C'\fR matches any single characta wit tha Unicode
\&\*(L"Uppercase\*(R" property, while \f(CW\*(C`\ep{L}\*(C'\fR matches any characta wit a
General_Category of \*(L"L\*(R" (letter) property.  Brackets is not
required fo' single letta property names, so \f(CW\*(C`\ep{L}\*(C'\fR is equivalent ta \f(CW\*(C`\epL\*(C'\fR.
.PP
Mo' formally, \f(CW\*(C`\ep{Uppercase}\*(C'\fR matches any single characta whose Unicode
Uppercase property value is True, n' \f(CW\*(C`\eP{Uppercase}\*(C'\fR matches any character
whose Uppercase property value is False, n' they could done been freestyled as
\&\f(CW\*(C`\ep{Uppercase=True}\*(C'\fR n' \f(CW\*(C`\ep{Uppercase=False}\*(C'\fR, respectively.
.PP
This formalitizzle is needed when propertizzles is not binary; dat is, if they can
take on mo' joints than just True n' False.  For example, tha Bidi_Class (see
\&\*(L"Bidirectionizzle Characta Types\*(R" below), can take on nuff muthafuckin different
values, like fuckin Left, Right, Whitespace, n' others.  To match these, one needs
to specify both tha property name (Bidi_Class), \s-1AND\s0 tha value being
matched against
(Left, Right, etc.).  This is done, as up in tha examplez above, by havin the
two components separated by a equal sign (or interchangeably, a cold-ass lil colon), like
\&\f(CW\*(C`\ep{Bidi_Class: Left}\*(C'\fR.
.PP
All Unicode-defined characta propertizzles may be freestyled up in these compound forms
of \f(CW\*(C`\ep{property=value}\*(C'\fR or \f(CW\*(C`\ep{property:value}\*(C'\fR yo, but Perl serves up some
additionizzle propertizzles dat is freestyled only up in tha single form, as well as
single-form short-cuts fo' all binary propertizzles n' certain others busted lyrics about
below, up in which you may omit tha property name n' tha equals or colon
separator.
.PP
Most Unicode characta propertizzles have at least two synonyms (or aliases if you
prefer): a gangbangin' finger-lickin' dirty-ass short one dat is easier ta type n' a longer one dat is more
descriptizzle n' hence easier ta understand. Y'all KNOW dat shit, muthafucka!  Thus tha \*(L"L\*(R" n' \*(L"Letter\*(R" properties
above is equivalent n' can be used interchangeably.  Likewise,
\&\*(L"Upper\*(R" be a synonym fo' \*(L"Uppercase\*(R", n' we could have written
\&\f(CW\*(C`\ep{Uppercase}\*(C'\fR equivalently as \f(CW\*(C`\ep{Upper}\*(C'\fR.  Also, there be typically
various synonyms fo' tha joints tha property can be.   For binary properties,
\&\*(L"True\*(R" has 3 synonyms: \*(L"T\*(R", \*(L"Yes\*(R", n' \*(L"Y\*(R"; n' \*(L"False has correspondingly \*(R"F\*(L",
\&\*(R"No\*(L", n' \*(R"N\*(L".  But be careful naaahhmean, biatch?  A short form of a value fo' one property may
not mean tha same thang as tha same ol' dirty short form fo' another n' shit.  Thus, fo' the
General_Category property, \*(R"L\*(L" means \*(R"Letter\*(L" yo, but fo' tha Bidi_Class property,
\&\*(R"L\*(L" means \*(R"Left".  A complete list of propertizzles n' synonyms is in
perluniprops.
.PP
Upper/lower case differences up in property names n' joints is irrelevant;
thus \f(CW\*(C`\ep{Upper}\*(C'\fR means tha same ol' dirty thang as \f(CW\*(C`\ep{upper}\*(C'\fR or even \f(CW\*(C`\ep{UpPeR}\*(C'\fR.
Similarly, you can add or subtract underscores anywhere up in tha middle of a
word, so dat these is also equivalent ta \f(CW\*(C`\ep{U_p_p_e_r}\*(C'\fR.  And white space
is irrelevant adjacent ta non-word characters, like fuckin tha braces n' tha equals
or colon separators, so \f(CW\*(C`\ep{   Upper  }\*(C'\fR n' \f(CW\*(C`\ep{ Upper_case : Y }\*(C'\fR are
equivalent ta these as well.  In fact, white space n' even
hyphens can probably be added or deleted anywhere, so peek-a-boo, clear tha way, I be comin' thru fo'sho.  So even \f(CW\*(C`\ep{ Up\-per case = Yes}\*(C'\fR is
equivalent.  All dis is called \*(L"loose-matching\*(R" by Unicode.  Da few places
where stricta matchin is used is up in tha middle of numbers, n' up in tha Perl
extension propertizzles dat begin or end wit a underscore.  Stricta matching
cares bout white space (except adjacent ta non-word characters),
hyphens, n' non-interior underscores.
.PP
Yo ass can also use negation up in both \f(CW\*(C`\ep{}\*(C'\fR n' \f(CW\*(C`\eP{}\*(C'\fR by introducin a cold-ass lil caret
(^) between tha straight-up original gangsta brace n' tha property name: \f(CW\*(C`\ep{^Tamil}\*(C'\fR is
equal ta \f(CW\*(C`\eP{Tamil}\*(C'\fR.
.PP
Almost all propertizzles is immune ta case-insensitizzle matching.  That is,
addin a \f(CW\*(C`/i\*(C'\fR regular expression modifier do not chizzle what tha fuck they
match.  There is two sets dat is affected.
Da first set is
\&\f(CW\*(C`Uppercase_Letter\*(C'\fR,
\&\f(CW\*(C`Lowercase_Letter\*(C'\fR,
and \f(CW\*(C`Titlecase_Letter\*(C'\fR,
all of which match \f(CW\*(C`Cased_Letter\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
And tha second set is
\&\f(CW\*(C`Uppercase\*(C'\fR,
\&\f(CW\*(C`Lowercase\*(C'\fR,
and \f(CW\*(C`Titlecase\*(C'\fR,
all of which match \f(CW\*(C`Cased\*(C'\fR under \f(CW\*(C`/i\*(C'\fR matching.
This set also includes its subsets \f(CW\*(C`PosixUpper\*(C'\fR n' \f(CW\*(C`PosixLower\*(C'\fR both
of which under \f(CW\*(C`/i\*(C'\fR matchin match \f(CW\*(C`PosixAlpha\*(C'\fR.
(Da difference between these sets is dat some thangs, like fuckin Roman
numerals, come up in both upper n' lower case so they is \f(CW\*(C`Cased\*(C'\fR yo, but aren't considered
letters, so they aren't \f(CW\*(C`Cased_Letter\*(C'\fRs.)
.PP
Da result is undefined if you try ta match a non-Unicode code point
(that is, one above 0x10FFFF) against a Unicode property.  Currently, a
warnin is raised, n' tha match will fail.  In some cases, dis is
counterintuitive, as both these fail:
.PP
.Vb 2
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=True}      # Fails.
\& chr(0x110000) =~ \ep{ASCII_Hex_Digit=False}     # Fails!
.Ve
.PP
\fI\f(BIGeneral_Category\fI\fR
.IX Subsection "General_Category"
.PP
Every Unicode characta be assigned a general category, which is tha \*(L"most
usual categorization of a cold-ass lil character\*(R" (from
<http://www.unicode.org/reports/tr44>).
.PP
Da compound way of freestylin these is like \f(CW\*(C`\ep{General_Category=Number}\*(C'\fR
(short, \f(CW\*(C`\ep{gc:n}\*(C'\fR).  But Perl furnishes shortcuts up in which every last muthafuckin thang up
all up in tha equal or colon separator is omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  So you can instead just write
\&\f(CW\*(C`\epN\*(C'\fR.
.PP
Here is tha short n' long formz of tha General Category properties:
.PP
.Vb 1
\&    Short       Long
\&
\&    L           Letter
\&    LC, L&      Cased_Letta (that is: [\ep{Ll}\ep{Lu}\ep{Lt}])
\&    Lu          Uppercase_Letter
\&    Ll          Lowercase_Letter
\&    Lt          Titlecase_Letter
\&    Lm          Modifier_Letter
\&    Lo          Other_Letter
\&
\&    M           Mark
\&    Mn          Nonspacing_Mark
\&    Mc          Spacing_Mark
\&    Me          Enclosing_Mark
\&
\&    N           Number
\&    Nd          Decimal_Number (also Digit)
\&    Nl          Letter_Number
\&    No          Other_Number
\&
\&    P           Punctuation (also Punct)
\&    Pc          Connector_Punctuation
\&    Pd          Dash_Punctuation
\&    Ps          Open_Punctuation
\&    Pe          Close_Punctuation
\&    Pi          Initial_Punctuation
\&                (may behave like Ps or Pe dependin on usage)
\&    Pf          Final_Punctuation
\&                (may behave like Ps or Pe dependin on usage)
\&    Po          Other_Punctuation
\&
\&    S           Symbol
\&    Sm          Math_Symbol
\&    Sc          Currency_Symbol
\&    Sk          Modifier_Symbol
\&    So          Other_Symbol
\&
\&    Z           Separator
\&    Zs          Space_Separator
\&    Zl          Line_Separator
\&    Zp          Paragraph_Separator
\&
\&    C           Other
\&    Cc          Control (also Cntrl)
\&    Cf          Format
\&    Cs          Surrogate
\&    Co          Private_Use
\&    Cn          Unassigned
.Ve
.PP
Single-letta propertizzles match all charactas up in any of the
two-letta sub-propertizzles startin wit tha same letter.
\&\f(CW\*(C`LC\*(C'\fR n' \f(CW\*(C`L&\*(C'\fR is special: both is aliases fo' tha set consistin of every last muthafuckin thang matched by \f(CW\*(C`Ll\*(C'\fR, \f(CW\*(C`Lu\*(C'\fR, n' \f(CW\*(C`Lt\*(C'\fR.
.PP
\fI\f(BIBidirectionizzle Characta Types\fI\fR
.IX Subsection "Bidirectionizzle Characta Types"
.PP
Because scripts differ up in they directionalitizzle (Hebrew n' Arabic are
written right ta left, fo' example) Unicode supplies these propertizzles in
the Bidi_Class class:
.PP
.Vb 1
\&    Property    Meaning
\&
\&    L           Left\-to\-Right
\&    LRE         Left\-to\-Right Embedding
\&    LRO         Left\-to\-Right Override
\&    R           Right\-to\-Left
\&    AL          Arabic Letter
\&    RLE         Right\-to\-Left Embedding
\&    RLO         Right\-to\-Left Override
\&    PDF         Pop Directionizzle Format
\&    EN          European Number
\&    ES          European Separator
\&    ET          European Terminator
\&    AN          Arabic Number
\&    CS          Common Separator
\&    NSM         Non\-Spacin Mark
\&    BN          Boundary Neutral
\&    B           Paragraph Separator
\&    S           Segment Separator
\&    WS          Whitespace
\&    ON          Other Neutrals
.Ve
.PP
This property be always freestyled up in tha compound form.
For example, \f(CW\*(C`\ep{Bidi_Class:R}\*(C'\fR matches charactas dat is normally
written right ta left.
.PP
\fI\f(BIScripts\fI\fR
.IX Subsection "Scripts"
.PP
Da ghettoz languages is freestyled up in nuff different scripts, n' you can put dat on yo' toast.  This sentence
(unless you readin it up in translation) is freestyled up in Latin, while Russian is
written up in Cyrillic, n' Greek is freestyled in, well, Greek; Japanese mainly in
Hiragana or Katakana.  There is nuff more.
.PP
Da Unicode Script n' Script_Extensions propertizzles give what tha fuck script a
given characta is in. I aint talkin' bout chicken n' gravy biatch.  Either property can be specified wit the
compound form like
\&\f(CW\*(C`\ep{Script=Hebrew}\*(C'\fR (short: \f(CW\*(C`\ep{sc=hebr}\*(C'\fR), or
\&\f(CW\*(C`\ep{Script_Extensions=Javanese}\*(C'\fR (short: \f(CW\*(C`\ep{scx=java}\*(C'\fR).
In addition, Perl furnishes shortcuts fo' all
\&\f(CW\*(C`Script\*(C'\fR property names.  Yo ass can omit every last muthafuckin thang up all up in tha equals
(or colon), n' simply write \f(CW\*(C`\ep{Latin}\*(C'\fR or \f(CW\*(C`\eP{Cyrillic}\*(C'\fR.
(This aint legit fo' \f(CW\*(C`Script_Extensions\*(C'\fR, which is required ta be
written up in tha compound form.)
.PP
Da difference between these two propertizzles involves charactas dat are
used up in multiple scripts, n' you can put dat on yo' toast.  For example tha digits '0' all up in '9' are
used up in nuff partz of tha ghetto. Right back up in yo muthafuckin ass. Y'all KNOW dat shit, muthafucka!  These is placed up in a script named
\&\f(CW\*(C`Common\*(C'\fR.  Other charactas is used up in just all dem scripts, n' you can put dat on yo' toast.  For
example, tha \*(L"KATAKANA-HIRAGANA \s-1DOUBLE HYPHEN\*(R"\s0 is used up in both Japanese
scripts, Katakana n' Hiragana yo, but nowhere else.  Da \f(CW\*(C`Script\*(C'\fR
property places all charactas dat is used up in multiple scripts up in the
\&\f(CW\*(C`Common\*(C'\fR script, while tha \f(CW\*(C`Script_Extensions\*(C'\fR property places them
that is used up in only all dem scripts tha fuck into each of dem scripts; while
still rockin \f(CW\*(C`Common\*(C'\fR fo' dem used up in nuff scripts, n' you can put dat on yo' toast.  Thus both these
match:
.PP
.Vb 2
\& "0" =~ /\ep{sc=Common}/     # Matches
\& "0" =~ /\ep{scx=Common}/    # Matches
.Ve
.PP
and only tha straight-up original gangsta of these match:
.PP
.Vb 2
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{sc=Common}  # Matches
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{scx=Common} # No match
.Ve
.PP
And only tha last two of these match:
.PP
.Vb 4
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{sc=Hiragana}  # No match
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{sc=Katakana}  # No match
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{scx=Hiragana} # Matches
\& "\eN{KATAKANA\-HIRAGANA DOUBLE HYPHEN}" =~ /\ep{scx=Katakana} # Matches
.Ve
.PP
\&\f(CW\*(C`Script_Extensions\*(C'\fR is thus a improved \f(CW\*(C`Script\*(C'\fR, up in which there are
fewer charactas up in tha \f(CW\*(C`Common\*(C'\fR script, n' correspondingly mo' in
other scripts, n' you can put dat on yo' toast.  It be freshly smoked up in Unicode version 6.0, n' its data is likely
to chizzle hella up in lata releases, as thangs git sorted out.
.PP
(Actually, besides \f(CW\*(C`Common\*(C'\fR, tha \f(CW\*(C`Inherited\*(C'\fR script, gotz nuff
charactas dat is used up in multiple scripts, n' you can put dat on yo' toast.  These is modifier
charactas which modify other characters, n' inherit tha script value
of tha controllin character n' shit.  Some of these is used up in nuff scripts,
and so go tha fuck into \f(CW\*(C`Inherited\*(C'\fR up in both \f(CW\*(C`Script\*(C'\fR n' \f(CW\*(C`Script_Extensions\*(C'\fR.
Others is used up in just all dem scripts, so is up in \f(CW\*(C`Inherited\*(C'\fR in
\&\f(CW\*(C`Script\*(C'\fR yo, but not up in \f(CW\*(C`Script_Extensions\*(C'\fR.)
.PP
It be worth stressin dat there be nuff muthafuckin different setz of digits in
Unicode dat is equivalent ta 0\-9 n' is matchable by \f(CW\*(C`\ed\*(C'\fR up in a
regular expression. I aint talkin' bout chicken n' gravy biatch.  If they is used up in a single language only, they
are up in dat languagez \f(CW\*(C`Script\*(C'\fR n' \f(CW\*(C`Script_Extension\*(C'\fR.  If they are
used up in mo' than one script, they is ghon be up in \f(CW\*(C`sc=Common\*(C'\fR yo, but only
if they is used up in nuff scripts should they be up in \f(CW\*(C`scx=Common\*(C'\fR.
.PP
A complete list of scripts n' they shortcuts is up in perluniprops.
.PP
\fI\f(BIUse of \*(L"Is\*(R" Prefix\fI\fR
.IX Subsection "Use of Is Prefix"
.PP
For backward compatibilitizzle (with Perl 5.6), all propertizzles mentioned
so far may have \f(CW\*(C`Is\*(C'\fR or \f(CW\*(C`Is_\*(C'\fR prepended ta they name, so \f(CW\*(C`\eP{Is_Lu}\*(C'\fR, for
example, is equal ta \f(CW\*(C`\eP{Lu}\*(C'\fR, n' \f(CW\*(C`\ep{IsScript:Arabic}\*(C'\fR is equal to
\&\f(CW\*(C`\ep{Arabic}\*(C'\fR.
.PP
\fI\f(BIBlocks\fI\fR
.IX Subsection "Blocks"
.PP
In addizzle ta \fBscripts\fR, Unicode also defines \fBblocks\fR of
characters.  Da difference between scripts n' blocks is dat the
concept of scripts is closer ta natural languages, while tha concept
of blocks is mo' of a artificial groupin based on crewz of Unicode
charactas wit consecutizzle ordinal joints, n' you can put dat on yo' toast. For example, tha \*(L"Basic Latin\*(R"
block be all charactas whose ordinals is between 0 n' 127, inclusive; in
other lyrics, tha \s-1ASCII\s0 characters.  Da \*(L"Latin\*(R" script gotz nuff some letters
from dis as well as nuff muthafuckin other blocks, like \*(L"Latin\-1 Supplement\*(R",
\&\*(L"Latin Extended-A\*(R", etc. yo, but it do not contain all tha charactas from
those blocks. Well shiiiit, it do not, fo' example, contain tha digits 0\-9, cuz
those digits is shared across nuff scripts, n' hence is up in the
\&\f(CW\*(C`Common\*(C'\fR script.
.PP
For mo' bout scripts versus blocks, peep UAX#24 \*(L"Unicode Script Property\*(R":
<http://www.unicode.org/reports/tr24>
.PP
Da \f(CW\*(C`Script\*(C'\fR or \f(CW\*(C`Script_Extensions\*(C'\fR propertizzles is likely ta be the
ones you wanna use when processing
natural language; tha Block property may occasionally be useful up in working
with tha nuts n' boltz of Unicode.
.PP
Block names is matched up in tha compound form, like \f(CW\*(C`\ep{Block: Arrows}\*(C'\fR or
\&\f(CW\*(C`\ep{Blk=Hebrew}\*(C'\fR.  Unlike most other properties, only all dem block names have a
Unicode-defined short name.  But Perl do provide a (slight) shortcut:  You
can say, fo' example \f(CW\*(C`\ep{In_Arrows}\*(C'\fR or \f(CW\*(C`\ep{In_Hebrew}\*(C'\fR.  For backwards
compatibility, tha \f(CW\*(C`In\*(C'\fR prefix may be omitted if there is no namin conflict
with a script or any other property, n' you can even use a \f(CW\*(C`Is\*(C'\fR prefix
instead up in dem cases.  But it aint a phat scam ta do this, fo' a cold-ass lil couple
reasons:
.IP "1." 4
It be confusing.  There is nuff namin conflicts, n' you may forget some.
For example, \f(CW\*(C`\ep{Hebrew}\*(C'\fR means tha \fIscript\fR Hebrew, n' \s-1NOT\s0 tha \fIblock\fR
Hebrew.  But would you remember dat 6 months from now?
.IP "2." 4
It be unstable.  A freshly smoked up version of Unicode may pre-empt tha current meanin by
bustin a property wit tha same name.  There was a time up in straight-up early Unicode
releases when \f(CW\*(C`\ep{Hebrew}\*(C'\fR would have matched tha \fIblock\fR Hebrew; now it
doesn't.
.PP
Some playas prefer ta always use \f(CW\*(C`\ep{Block: foo}\*(C'\fR n' \f(CW\*(C`\ep{Script: bar}\*(C'\fR
instead of tha shortcuts, whether fo' clarity, cuz they can't remember the
difference between 'In' n' 'Is' anyway, or they aren't Kool & Tha Gang dat dem who
eventually will read they code will know dat difference.
.PP
A complete list of blocks n' they shortcuts is up in perluniprops.
.PP
\fI\f(BIOther Properties\fI\fR
.IX Subsection "Other Properties"
.PP
There is nuff mo' propertizzles than tha straight-up basic ones busted lyrics bout here.
A complete list is up in perluniprops.
.PP
Unicode defines all its propertizzles up in tha compound form, so all single-form
propertizzles is Perl extensions.  Most of these is just synonyms fo' the
Unicode ones yo, but some is genuine extensions, includin nuff muthafuckin dat is in
the compound form.  And like all dem of these is straight-up recommended by Unicode
(in <http://www.unicode.org/reports/tr18>).
.PP
This section gives some details on all extensions dat aren't just
synonyms fo' compound-form Unicode properties
(for dem properties, you gonna gotta refer ta the
Unicode Standard <http://www.unicode.org/reports/tr44>.
.ie n .IP "\fB\fB""\ep{All}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{All}\fB\fR" 4
.IX Item "p{All}"
This matches any of tha 1_114_112 Unicode code points, n' you can put dat on yo' toast.  It be a synonym for
\&\f(CW\*(C`\ep{Any}\*(C'\fR.
.ie n .IP "\fB\fB""\ep{Alnum}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Alnum}\fB\fR" 4
.IX Item "p{Alnum}"
This matches any \f(CW\*(C`\ep{Alphabetic}\*(C'\fR or \f(CW\*(C`\ep{Decimal_Number}\*(C'\fR character.
.ie n .IP "\fB\fB""\ep{Any}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Any}\fB\fR" 4
.IX Item "p{Any}"
This matches any of tha 1_114_112 Unicode code points, n' you can put dat on yo' toast.  It be a synonym for
\&\f(CW\*(C`\ep{All}\*(C'\fR.
.ie n .IP "\fB\fB""\ep{ASCII}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{ASCII}\fB\fR" 4
.IX Item "p{ASCII}"
This matches any of tha 128 charactas up in tha US-ASCII characta set,
which be a subset of Unicode.
.ie n .IP "\fB\fB""\ep{Assigned}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Assigned}\fB\fR" 4
.IX Item "p{Assigned}"
This matches any assigned code point; dat is, any code point whose general
category aint Unassigned (or equivalently, not Cn).
.ie n .IP "\fB\fB""\ep{Blank}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Blank}\fB\fR" 4
.IX Item "p{Blank}"
This is tha same ol' dirty as \f(CW\*(C`\eh\*(C'\fR n' \f(CW\*(C`\ep{HorizSpace}\*(C'\fR:  A characta dat chizzlez the
spacin horizontally.
.ie n .IP "\fB\fB""\ep{Decomposition_Type: Non_Canonical}""\fB\fR    (Short: ""\ep{Dt=NonCanon}"")" 4
.el .IP "\fB\f(CB\ep{Decomposition_Type: Non_Canonical}\fB\fR    (Short: \f(CW\ep{Dt=NonCanon}\fR)" 4
.IX Item "p{Decomposition_Type: Non_Canonical} (Short: p{Dt=NonCanon})"
Matches a cold-ass lil characta dat has a non-canonical decomposition.
.Sp
To KNOW tha use of dis rarely used property=value combination, it is
necessary ta know some basics bout decomposition.
Consider a cold-ass lil character, say H.  It could step tha fuck up wit various marks round it,
like fuckin a acute accent, or a cold-ass lil circumflex, or various hooks, circles, arrows,
\&\fIetc.\fR, above, below, ta one side or tha other, etc.  There is many
possibilitizzles among tha ghettoz languages.  Da number of combinations is
astronomical, n' if there was a cold-ass lil characta fo' each combination, it would
soon exhaust Unicodez mo' than a mazillion possible characters.  So Unicode
took a gangbangin' finger-lickin' different approach: there be a cold-ass lil characta fo' tha base H, n' a
characta fo' each of tha possible marks, n' these can be variously combined
to git a gangbangin' final logical character n' shit.  So a logical character\*(--what appears ta be a
single character\*(--can be a sequence of mo' than one individual characters.
This is called a \*(L"extended grapheme cluster\*(R";  Perl furnishes tha \f(CW\*(C`\eX\*(C'\fR
regular expression construct ta match such sequences.
.Sp
But Unicodez intent is ta unify tha existin characta set standardz and
practices, n' nuff muthafuckin pre-existin standardz have single charactas that
mean tha same thang as a shitload of these combinations.  An example is \s-1ISO\-8859\-1,\s0
which has like all dem of these up in tha Latin\-1 range, a example bein \*(L"\s-1LATIN
CAPITAL LETTER E WITH ACUTE\*(R". \s0 Because dis characta was up in dis pre-existing
standard, Unicode added it ta its repertoire.  But dis characta is considered
by Unicode ta be equivalent ta tha sequence consistin of tha character
\&\*(L"\s-1LATIN CAPITAL LETTER E\*(R"\s0 followed by tha characta \*(L"\s-1COMBINING ACUTE ACCENT\*(R".\s0
.Sp
\&\*(L"\s-1LATIN CAPITAL LETTER E WITH ACUTE\*(R"\s0 is called a \*(L"pre-composed\*(R" character, and
its equivalence wit tha sequence is called canonical equivalence.  All
pre-composed charactas is holla'd ta git a thugged-out decomposizzle (into tha equivalent
sequence), n' tha decomposizzle type be also called canonical.
.Sp
But fuck dat shiznit yo, tha word on tha street is dat nuff mo' charactas gotz a gangbangin' finger-lickin' different type of decomposition, a
\&\*(L"compatible\*(R" or \*(L"non-canonical\*(R" decomposition. I aint talkin' bout chicken n' gravy biatch.  Da sequences dat form these
decompositions is not considered canonically equivalent ta tha pre-composed
character n' shit.  An example, again n' again n' again up in tha Latin\-1 range, is tha \*(L"\s-1SUPERSCRIPT ONE\*(R".\s0
It be somewhat like a regular digit 1 yo, but not exactly; its decomposition
into tha digit 1 is called a \*(L"compatible\*(R" decomposition, specifically a
\&\*(L"super\*(R" decomposition. I aint talkin' bout chicken n' gravy biatch.  There is nuff muthafuckin such compatibility
decompositions (see <http://www.unicode.org/reports/tr44>), includin one
called \*(L"compat\*(R", which means some miscellaneous type of decomposition
that don't fit tha fuck into tha decomposizzle categories dat Unicode has chosen.
.Sp
Note dat most Unicode charactas aint gots a thugged-out decomposition, so their
decomposizzle type is \*(L"None\*(R".
.Sp
For yo' convenience, Perl has added tha \f(CW\*(C`Non_Canonical\*(C'\fR decomposition
type ta mean any of tha nuff muthafuckin compatibilitizzle decompositions.
.ie n .IP "\fB\fB""\ep{Graph}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Graph}\fB\fR" 4
.IX Item "p{Graph}"
Matches any characta dat is graphic.  Theoretically, dis means a cold-ass lil character
that on a printa would cause ink ta be used.
.ie n .IP "\fB\fB""\ep{HorizSpace}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{HorizSpace}\fB\fR" 4
.IX Item "p{HorizSpace}"
This is tha same ol' dirty as \f(CW\*(C`\eh\*(C'\fR n' \f(CW\*(C`\ep{Blank}\*(C'\fR:  a cold-ass lil characta dat chizzlez the
spacin horizontally.
.ie n .IP "\fB\fB""\ep{In=*}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{In=*}\fB\fR" 4
.IX Item "p{In=*}"
This be a synonym fo' \f(CW\*(C`\ep{Present_In=*}\*(C'\fR
.ie n .IP "\fB\fB""\ep{PerlSpace}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{PerlSpace}\fB\fR" 4
.IX Item "p{PerlSpace}"
This is tha same ol' dirty as \f(CW\*(C`\es\*(C'\fR, restricted ta \s-1ASCII,\s0 namely \f(CW\*(C`[\ \ef\en\er\et]\*(C'\fR
and startin up in Perl v5.18, experimentally, a vertical tab.
.Sp
Mnemonic: Perlz (original) space
.ie n .IP "\fB\fB""\ep{PerlWord}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{PerlWord}\fB\fR" 4
.IX Item "p{PerlWord}"
This is tha same ol' dirty as \f(CW\*(C`\ew\*(C'\fR, restricted ta \s-1ASCII,\s0 namely \f(CW\*(C`[A\-Za\-z0\-9_]\*(C'\fR
.Sp
Mnemonic: Perlz (original) word.
.ie n .IP "\fB\fB""\ep{Posix...}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Posix...}\fB\fR" 4
.IX Item "p{Posix...}"
There is nuff muthafuckin of these, which is equivalents rockin tha \f(CW\*(C`\ep\*(C'\fR
notation fo' Posix classes n' is busted lyrics bout in
\&\*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass.
.ie n .IP "\fB\fB""\ep{Present_In: *}""\fB\fR    (Short: ""\ep{In=*}"")" 4
.el .IP "\fB\f(CB\ep{Present_In: *}\fB\fR    (Short: \f(CW\ep{In=*}\fR)" 4
.IX Item "p{Present_In: *} (Short: p{In=*})"
This property is used when you need ta know up in what tha fuck Unicode version(s) a
characta is.
.Sp
Da \*(L"*\*(R" above standz fo' some two digit Unicode version number, such as
\&\f(CW1.1\fR or \f(CW4.0\fR; or tha \*(L"*\*(R" can also be \f(CW\*(C`Unassigned\*(C'\fR.  This property will
match tha code points whose final disposizzle has been settled az of the
Unicode release given by tha version number; \f(CW\*(C`\ep{Present_In: Unassigned}\*(C'\fR
will match dem code points whose meanin has yet ta be assigned.
.Sp
For example, \f(CW\*(C`U+0041\*(C'\fR \*(L"\s-1LATIN CAPITAL LETTER A\*(R"\s0 was present up in tha straight-up first
Unicode release available, which is \f(CW1.1\fR, so dis property is legit fo' all
valid \*(L"*\*(R" versions.  On tha other hand, \f(CW\*(C`U+1EFF\*(C'\fR was not assigned until version
5.1 when it became \*(L"\s-1LATIN SMALL LETTER Y WITH LOOP\*(R",\s0 so tha only \*(L"*\*(R" that
would match it is 5.1, 5.2, n' later.
.Sp
Unicode furnishes tha \f(CW\*(C`Age\*(C'\fR property from which dis is derived. Y'all KNOW dat shit, muthafucka!  Da problem
with Age is dat a strict interpretation of it (which Perl takes) has it
matchin tha precise release a cold-ass lil code pointz meanin is introduced in. I aint talkin' bout chicken n' gravy biatch.  Thus
\&\f(CW\*(C`U+0041\*(C'\fR would match only 1.1; n' \f(CW\*(C`U+1EFF\*(C'\fR only 5.1.  This aint probably what
you want.
.Sp
Some non-Perl implementationz of tha Age property may chizzle its meanin ta be
the same as tha Perl Present_In property; just be aware of dis shit.
.Sp
Another mad drama wit both these propertizzles is dat tha definizzle is not
that tha code point has been \fIassigned\fR yo, but dat tha meanin of tha code point
has been \fIdetermined\fR.  This is cuz 66 code points will always be
unassigned, n' so tha Age fo' dem is tha Unicode version up in which tha decision
to make dem so was made.  For example, \f(CW\*(C`U+FDD0\*(C'\fR is ta be permanently
unassigned ta a cold-ass lil character, n' tha decision ta do dat was made up in version 3.1,
so \f(CW\*(C`\ep{Age=3.1}\*(C'\fR matches dis character, as also do \f(CW\*(C`\ep{Present_In: 3.1}\*(C'\fR n' up.
.ie n .IP "\fB\fB""\ep{Print}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Print}\fB\fR" 4
.IX Item "p{Print}"
This matches any characta dat is graphical or blank, except controls.
.ie n .IP "\fB\fB""\ep{SpacePerl}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{SpacePerl}\fB\fR" 4
.IX Item "p{SpacePerl}"
This is tha same ol' dirty as \f(CW\*(C`\es\*(C'\fR, includin beyond \s-1ASCII.\s0
.Sp
Mnemonic: Space, as modified by Perl.  (It don't include tha vertical tab
which both tha Posix standard n' Unicode consider white space.)
.ie n .IP "\fB\fB""\ep{Title}""\fB\fR n'  \fB\fB""\ep{Titlecase}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Title}\fB\fR n'  \fB\f(CB\ep{Titlecase}\fB\fR" 4
.IX Item "p{Title} n' p{Titlecase}"
Under case-sensitizzle matching, these both match tha same code points as
\&\f(CW\*(C`\ep{General Category=Titlecase_Letter}\*(C'\fR (\f(CW\*(C`\ep{gc=lt}\*(C'\fR).  Da difference
is dat under \f(CW\*(C`/i\*(C'\fR caseless matching, these match tha same as
\&\f(CW\*(C`\ep{Cased}\*(C'\fR, whereas \f(CW\*(C`\ep{gc=lt}\*(C'\fR matches \f(CW\*(C`\ep{Cased_Letter\*(C'\fR).
.ie n .IP "\fB\fB""\ep{VertSpace}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{VertSpace}\fB\fR" 4
.IX Item "p{VertSpace}"
This is tha same ol' dirty as \f(CW\*(C`\ev\*(C'\fR:  A characta dat chizzlez tha spacin vertically.
.ie n .IP "\fB\fB""\ep{Word}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{Word}\fB\fR" 4
.IX Item "p{Word}"
This is tha same ol' dirty as \f(CW\*(C`\ew\*(C'\fR, includin over 100_000 charactas beyond \s-1ASCII.\s0
.ie n .IP "\fB\fB""\ep{XPosix...}""\fB\fR" 4
.el .IP "\fB\f(CB\ep{XPosix...}\fB\fR" 4
.IX Item "p{XPosix...}"
There is nuff muthafuckin of these, which is tha standard Posix classes
extended ta tha full Unicode range.  They is busted lyrics bout in
\&\*(L"\s-1POSIX\s0 Characta Classes\*(R" up in perlrecharclass.
.SS "User-Defined Characta Properties"
.IX Subsection "User-Defined Characta Properties"
Yo ass can define yo' own binary characta propertizzles by definin subroutines
whose names begin wit \*(L"In\*(R" or \*(L"Is\*(R".  (Da experimenstrual feature
\&\*(L"(?[ ])\*(R" up in perlre serves up a alternatizzle which allows mo' complex
definitions.)  Da subroutines can be defined up in any
package.  Da user-defined propertizzles can be used up in tha regular expression
\&\f(CW\*(C`\ep\*(C'\fR n' \f(CW\*(C`\eP\*(C'\fR constructs; if yo ass is rockin a user-defined property from a
package other than tha one yo ass is in, you must specify its package up in the
\&\f(CW\*(C`\ep\*(C'\fR or \f(CW\*(C`\eP\*(C'\fR construct.
.PP
.Vb 3
\&    # assumin property Is_Foreign defined up in Lang::
\&    package main;  # property package name required
\&    if ($txt =~ /\ep{Lang::IsForeign}+/) { ... }
\&
\&    package Lang;  # property package name not required
\&    if ($txt =~ /\ep{IsForeign}+/) { ... }
.Ve
.PP
Note dat tha effect is compile-time n' immutable once defined.
But fuck dat shiznit yo, tha word on tha street is dat tha subroutines is passed a single parameter, which is 0 if
case-sensitizzle matchin is up in effect n' non-zero if caseless matching
is up in effect.  Da subroutine may return different joints dependin on
the value of tha flag, n' one set of joints will immutably be up in effect
for all case-sensitizzle matches, n' tha other set fo' all case-insensitive
matches.
.PP
Note dat if tha regular expression is tainted, then Perl will take a thugged-out dirtnap rather
than callin tha subroutine, where tha name of tha subroutine is
determined by tha tainted data.
.PP
Da subroutines must return a specially-formatted string, wit one
or mo' newline-separated lines.  Each line must be one of tha following:
.IP "\(bu" 4
A single hexadecimal number denotin a Unicode code point ta include.
.IP "\(bu" 4
Two hexadecimal numbers separated by horizontal whitespace (space or
tabular characters) denotin a range of Unicode code points ta include.
.IP "\(bu" 4
Somethang ta include, prefixed by \*(L"+\*(R": a funky-ass built-in character
property (prefixed by \*(L"utf8::\*(R") or a gangbangin' straight-up qualified (includin package
name) user-defined characta property,
to represent all tha charactas up in dat property; two hexadecimal code
points fo' a range; or a single hexadecimal code point.
.IP "\(bu" 4
Somethang ta exclude, prefixed by \*(L"\-\*(R": a existin character
property (prefixed by \*(L"utf8::\*(R") or a gangbangin' straight-up qualified (includin package
name) user-defined characta property,
to represent all tha charactas up in dat property; two hexadecimal code
points fo' a range; or a single hexadecimal code point.
.IP "\(bu" 4
Somethang ta negate, prefixed \*(L"!\*(R": a existin character
property (prefixed by \*(L"utf8::\*(R") or a gangbangin' straight-up qualified (includin package
name) user-defined characta property,
to represent all tha charactas up in dat property; two hexadecimal code
points fo' a range; or a single hexadecimal code point.
.IP "\(bu" 4
Somethang ta intersect with, prefixed by \*(L"&\*(R": a existin character
property (prefixed by \*(L"utf8::\*(R") or a gangbangin' straight-up qualified (includin package
name) user-defined characta property,
for all tha charactas except tha charactas up in tha property; two
hexadecimal code points fo' a range; or a single hexadecimal code point.
.PP
For example, ta define a property dat covers both tha Japanese
syllabaries (hiragana n' katakana), you can define
.PP
.Vb 6
\&    sub InKana {
\&        return <<END;
\&    3040\et309F
\&    30A0\et30FF
\&    END
\&    }
.Ve
.PP
Imagine dat tha here-doc end marker be all up in tha beginnin of tha line.
Now you can use \f(CW\*(C`\ep{InKana}\*(C'\fR n' \f(CW\*(C`\eP{InKana}\*(C'\fR.
.PP
Yo ass could also have used tha existin block property names:
.PP
.Vb 6
\&    sub InKana {
\&        return <<\*(AqEND\*(Aq;
\&    +utf8::InHiragana
\&    +utf8::InKatakana
\&    END
\&    }
.Ve
.PP
Suppose you wanted ta match only tha allocated characters,
not tha raw block ranges: up in other lyrics, you wanna remove
the non-characters:
.PP
.Vb 7
\&    sub InKana {
\&        return <<\*(AqEND\*(Aq;
\&    +utf8::InHiragana
\&    +utf8::InKatakana
\&    \-utf8::IsCn
\&    END
\&    }
.Ve
.PP
Da negation is useful fo' definin (surprise!) negated classes.
.PP
.Vb 7
\&    sub InNotKana {
\&        return <<\*(AqEND\*(Aq;
\&    !utf8::InHiragana
\&    \-utf8::InKatakana
\&    +utf8::IsCn
\&    END
\&    }
.Ve
.PP
This will match all non-Unicode code points, since every last muthafuckin one of dem is
not up in Kana.  Yo ass can use intersection ta exclude these, if desired, as
this modified example shows:
.PP
.Vb 8
\&    sub InNotKana {
\&        return <<\*(AqEND\*(Aq;
\&    !utf8::InHiragana
\&    \-utf8::InKatakana
\&    +utf8::IsCn
\&    &utf8::Any
\&    END
\&    }
.Ve
.PP
\&\f(CW&utf8::Any\fR must be tha last line up in tha definition.
.PP
Intersection is used generally fo' gettin tha common charactas matched
by two (or more) classes.  It aint nuthin but blingin ta remember not ta use \*(L"&\*(R" for
the first set; dat would be intersectin wit nothing, resultin up in an
empty set.
.PP
(Note dat straight-up legit Unicode propertizzles differ from these up in dat they
automatically exclude non-Unicode code points n' a warnin is raised if
a match be attempted on one of them.)
.SS "User-Defined Case Mappings (for straight-up hackers only)"
.IX Subsection "User-Defined Case Mappings (for straight-up hackers only)"
\&\fBThis feature has been removed az of Perl 5.16.\fR
Da \s-1CPAN\s0 module Unicode::Casin serves up betta functionalitizzle without
the drawbacks dat dis feature had. Y'all KNOW dat shit, muthafucka!  If yo ass is rockin a Perl earlier
than 5.16, dis feature was most straight-up documented up in tha 5.14 version of
this pod:
<http://perldoc.perl.org/5.14.0/perlunicode.html#User\-Defined\-Case\-Mappings\-%28for\-serious\-hackers\-only%29>
.SS "Characta Encodings fo' Input n' Output"
.IX Subsection "Characta Encodings fo' Input n' Output"
See Encode.
.SS "Unicode Regular Expression Support Level"
.IX Subsection "Unicode Regular Expression Support Level"
Da followin list of Unicode supported features fo' regular expressions raps about
all features currently directly supported by core Perl.  Da references ta \*(L"Level N\*(R"
and tha section numbers refer ta tha Unicode Technical Standard #18,
\&\*(L"Unicode Regular Expressions\*(R", version 13, from August 2008.
.IP "\(bu" 4
Level 1 \- Basic Unicode Support
.Sp
.Vb 8
\& RL1.1   Hex Notation                     \- done          [1]
\& RL1.2   Propertizzles                       \- done          [2][3]
\& RL1.2a  Compatibilitizzle Propertizzles         \- done          [4]
\& RL1.3   Subtraction n' Intersection     \- experimenstrual  [5]
\& RL1.4   Simple Word Boundaries           \- done          [6]
\& RL1.5   Simple Loose Matches             \- done          [7]
\& RL1.6   Line Boundaries                  \- MISSING       [8][9]
\& RL1.7   Supplementary Code Points        \- done          [10]
.Ve
.RS 4
.IP "[1]" 4
.IX Item "[1]"
\&\ex{...}
.IP "[2]" 4
.IX Item "[2]"
\&\ep{...} \eP{...}
.IP "[3]" 4
.IX Item "[3]"
supports not only minimal list yo, but all Unicode characta propertizzles (see Unicode Characta Propertizzles above)
.IP "[4]" 4
.IX Item "[4]"
\&\ed \eD \es \eS \ew \eW \eX [:prop:] [:^prop:]
.IP "[5]" 4
.IX Item "[5]"
Da experimenstrual feature up in v5.18 \*(L"(?[...])\*(R" accomplishes all dis bullshit.  See
\&\*(L"(?[ ])\*(R" up in perlre.  If you don't wanna use a experimenstrual feature,
you can use one of tha following:
.RS 4
.IP "\(bu" 4
Regular expression look-ahead
.Sp
Yo ass can mimic class subtraction rockin lookahead.
For example, what tha fuck UTS#18 might write as
.Sp
.Vb 1
\&    [{Block=Greek}\-[{UNASSIGNED}]]
.Ve
.Sp
in Perl can be freestyled as:
.Sp
.Vb 2
\&    (?!\ep{Unassigned})\ep{Block=Greek}
\&    (?=\ep{Assigned})\ep{Block=Greek}
.Ve
.Sp
But up in dis particular example, you probably straight-up want
.Sp
.Vb 1
\&    \ep{Greek}
.Ve
.Sp
which will match assigned charactas known ta be part of tha Greek script.
.IP "\(bu" 4
\&\s-1CPAN\s0 module Unicode::Regex::Set
.Sp
It do implement tha full UTS#18 grouping, intersection, union, and
removal (subtraction) syntax.
.IP "\(bu" 4
\&\*(L"User-Defined Characta Properties\*(R"
.Sp
\&'+' fo' union, '\-' fo' removal (set-difference), '&' fo' intersection
.RE
.RS 4
.RE
.IP "[6]" 4
.IX Item "[6]"
\&\eb \eB
.IP "[7]" 4
.IX Item "[7]"
Note dat Perl do Full case-foldin up in matchin (but wit bugs), not Simple: fo' example U+1F88 is equivalent ta U+1F00 U+03B9, instead of just U+1F80.  This difference mattas mainly fo' certain Greek capital lettas wit certain modifiers: tha Full case-foldin decomposes tha letter, while tha Simple case-foldin would map it ta a single character.
.IP "[8]" 4
.IX Item "[8]"
Should do ^ n' $ also on U+000B (\ev up in C), \s-1FF \s0(\ef), \s-1CR \s0(\er), \s-1CRLF
\&\s0(\er\en), \s-1NEL \s0(U+0085), \s-1LS \s0(U+2028), n' \s-1PS \s0(U+2029); should also affect
<>, $., n' script line numbers; should not split lines within \s-1CRLF
\&\s0(i.e. there is no empty line between \er n' \en).  For \s-1CRLF,\s0 try the
\&\f(CW\*(C`:crlf\*(C'\fR layer (see PerlIO).
.IP "[9]" 4
.IX Item "[9]"
Linebreakin conformant wit UAX#14 \*(L"Unicode Line Breakin Algorithm\*(R" be available all up in tha Unicode::LineBreakin module.
.IP "[10]" 4
.IX Item "[10]"
\&\s-1UTF\-8/UTF\-EBDDIC\s0 used up in Perl allows not only U+10000 to
U+10FFFF but also beyond U+10FFFF
.RE
.RS 4
.RE
.IP "\(bu" 4
Level 2 \- Extended Unicode Support
.Sp
.Vb 6
\& RL2.1   Canonical Equivalents           \- MISSING       [10][11]
\& RL2.2   Default Grapheme Clustas       \- MISSING       [12]
\& RL2.3   Default Word Boundaries         \- MISSING       [14]
\& RL2.4   Default Loose Matches           \- MISSING       [15]
\& RL2.5   Name Propertizzles                 \- DONE
\& RL2.6   Wildcard Propertizzles             \- MISSING
\&
\& [10] peep UAX#15 "Unicode Normalization Forms"
\& [11] have Unicode::Normalize but not integrated ta regexes
\& [12] have \eX but our phat asses don\*(Aqt gotz a "Grapheme Clusta Mode"
\& [14] peep UAX#29, Word Boundaries
\& [15] This is covered up in Chapta 3.13 (in Unicode 6.0)
.Ve
.IP "\(bu" 4
Level 3 \- Tailored Support
.Sp
.Vb 11
\& RL3.1   Tailored Punctuation            \- MISSING
\& RL3.2   Tailored Grapheme Clustas      \- MISSING       [17][18]
\& RL3.3   Tailored Word Boundaries        \- MISSING
\& RL3.4   Tailored Loose Matches          \- MISSING
\& RL3.5   Tailored Ranges                 \- MISSING
\& RL3.6   Context Matchin                \- MISSING       [19]
\& RL3.7   Incremenstrual Matches             \- MISSING
\&      ( RL3.8   Unicode Set Sharin )
\& RL3.9   Possible Match Sets             \- MISSING
\& RL3.10  Folded Matchin                 \- MISSING       [20]
\& RL3.11  Submatchers                     \- MISSING
\&
\& [17] peep UAX#10 "Unicode Collation Algorithms"
\& [18] have Unicode::Collate but not integrated ta regexes
\& [19] have (?<=x) n' (?=x) yo, but look\-aheadz or look\-behinds
\&      should peep outside of tha target substring
\& [20] need insensitizzle matchin fo' linguistic features other
\&      than case; fo' example, hiragana ta katakana, wide and
\&      narrow, simplified Han ta traditionizzle Han (see UTR#30
\&      "Characta Foldings")
.Ve
.SS "Unicode Encodings"
.IX Subsection "Unicode Encodings"
Unicode charactas is assigned ta \fIcode points\fR, which is abstract
numbers.  To use these numbers, various encodings is needed.
.IP "\(bu" 4
\&\s-1UTF\-8\s0
.Sp
\&\s-1UTF\-8\s0 be a variable-length (1 ta 4 bytes), byte-order independent
encoding. For \s-1ASCII \s0(and we straight-up do mean 7\-bit \s-1ASCII,\s0 not another
8\-bit encoding), \s-1UTF\-8\s0 is transparent.
.Sp
Da followin table is from Unicode 3.2.
.Sp
.Vb 1
\& Code Points            1st Byte  2nd Byte  3rd Byte 4th Byte
\&
\&   U+0000..U+007F       00..7F
\&   U+0080..U+07FF     * C2..DF    80..BF
\&   U+0800..U+0FFF       E0      * A0..BF    80..BF
\&   U+1000..U+CFFF       E1..EC    80..BF    80..BF
\&   U+D000..U+D7FF       ED        80..9F    80..BF
\&   U+D800..U+DFFF       +++++ utf16 surrogates, not legal utf8 +++++
\&   U+E000..U+FFFF       EE..EF    80..BF    80..BF
\&  U+10000..U+3FFFF      F0      * 90..BF    80..BF    80..BF
\&  U+40000..U+FFFFF      F1..F3    80..BF    80..BF    80..BF
\& U+100000..U+10FFFF     F4        80..8F    80..BF    80..BF
.Ve
.Sp
Note tha gaps marked by \*(L"*\*(R" before nuff muthafuckin of tha byte entries above.  These are
caused by legal \s-1UTF\-8\s0 avoidin non-shortest encodings: it is technically
possible ta UTF\-8\-encode a single code point up in different ways yo, but dat is
explicitly forbidden, n' tha shortest possible encodin should always be used
(and dat is what tha fuck Perl do).
.Sp
Another way ta peep it is via bits:
.Sp
.Vb 1
\&                Code Points  1st Byte  2nd Byte  3rd Byte  4th Byte
\&
\&                   0aaaaaaa  0aaaaaaa
\&           00000bbbbbaaaaaa  110bbbbb  10aaaaaa
\&           ccccbbbbbbaaaaaa  1110cccc  10bbbbbb  10aaaaaa
\& 00000dddccccccbbbbbbaaaaaa  11110ddd  10cccccc  10bbbbbb  10aaaaaa
.Ve
.Sp
As you can see, tha continuation bytes all begin wit \*(L"10\*(R", n' the
leadin bitz of tha start byte tell how tha fuck nuff bytes there be up in the
encoded character.
.Sp
Da original gangsta \s-1UTF\-8\s0 justification allowed up ta 6 bytes, ta allow
encodin of numbers up ta 0x7FFF_FFFF.  Perl continues ta allow them,
and has extended dat up ta 13 bytes ta encode code points up ta what
can fit up in a 64\-bit word. Y'all KNOW dat shit, muthafucka!  But fuck dat shiznit yo, tha word on tha street is dat Perl will warn if you output any of
these as bein non-portable; n' under strict \s-1UTF\-8\s0 input protocols,
they is forbidden.
.Sp
Da Unicode non-characta code points is also disallowed up in \s-1UTF\-8\s0 in
\&\*(L"open interchange\*(R".  See \*(L"Non-characta code points\*(R".
.IP "\(bu" 4
UTF-EBCDIC
.Sp
Like \s-1UTF\-8\s0 but EBCDIC-safe, up in tha way dat \s-1UTF\-8\s0 is ASCII-safe.
.IP "\(bu" 4
\&\s-1UTF\-16, UTF\-16BE, UTF\-16LE,\s0 Surrogates, n' BOMs (Byte Order Marks)
.Sp
Da followings shit is mostly fo' reference n' general Unicode
knowledge, Perl don't use these constructs internally.
.Sp
Like \s-1UTF\-8, UTF\-16\s0 be a variable-width encodin yo, but where
\&\s-1UTF\-8\s0 uses 8\-bit code units, \s-1UTF\-16\s0 uses 16\-bit code units.
All code points occupy either 2 or 4 bytes up in \s-1UTF\-16:\s0 code points
\&\f(CW\*(C`U+0000..U+FFFF\*(C'\fR is stored up in a single 16\-bit unit, n' code
points \f(CW\*(C`U+10000..U+10FFFF\*(C'\fR up in two 16\-bit units, n' you can put dat on yo' toast.  Da latta case is
usin \fIsurrogates\fR, tha straight-up original gangsta 16\-bit unit bein tha \fIhigh
surrogate\fR, n' tha second bein tha \fIlow surrogate\fR.
.Sp
Surrogates is code points set aside ta encode tha \f(CW\*(C`U+10000..U+10FFFF\*(C'\fR
range of Unicode code points up in pairz of 16\-bit units, n' you can put dat on yo' toast.  Da \fIhigh
surrogates\fR is tha range \f(CW\*(C`U+D800..U+DBFF\*(C'\fR n' tha \fIlow surrogates\fR
are tha range \f(CW\*(C`U+DC00..U+DFFF\*(C'\fR.  Da surrogate encodin is
.Sp
.Vb 2
\&    $hi = ($uni \- 0x10000) / 0x400 + 0xD800;
\&    $lo = ($uni \- 0x10000) % 0x400 + 0xDC00;
.Ve
.Sp
and tha decodin is
.Sp
.Vb 1
\&    $uni = 0x10000 + ($hi \- 0xD800) * 0x400 + ($lo \- 0xDC00);
.Ve
.Sp
Because of tha 16\-bitness, \s-1UTF\-16\s0 is byte-order dependent.  \s-1UTF\-16\s0
itself can be used fo' in-memory computations yo, but if storage or
transfer is required either \s-1UTF\-16BE \s0(big-endian) or \s-1UTF\-16LE
\&\s0(lil-endian) encodings must be chosen.
.Sp
This introduces another problem: what tha fuck if you just know dat yo' data
is \s-1UTF\-16,\s0 but you don't give a fuck which endianness, biatch?  Byte Order Marks, or
BOMs, is a solution ta all dis bullshit.  A special characta has been reserved
in Unicode ta function as a funky-ass byte order marker: tha characta wit the
code point \f(CW\*(C`U+FEFF\*(C'\fR is tha \s-1BOM.\s0
.Sp
Da trick is dat if you read a \s-1BOM,\s0 yo big-ass booty is ghon know tha byte order,
since if dat shiznit was freestyled on a funky-ass big-endian platform, yo big-ass booty is ghon read the
bytes \f(CW\*(C`0xFE 0xFF\*(C'\fR yo, but if dat shiznit was freestyled on a lil-endian platform,
you will read tha bytes \f(CW\*(C`0xFF 0xFE\*(C'\fR.  (And if tha originatin platform
was freestylin up in \s-1UTF\-8,\s0 yo big-ass booty is ghon read tha bytes \f(CW\*(C`0xEF 0xBB 0xBF\*(C'\fR.)
.Sp
Da way dis trick works is dat tha characta wit tha code point
\&\f(CW\*(C`U+FFFE\*(C'\fR aint supposed ta be up in input streams, so the
sequence of bytes \f(CW\*(C`0xFF 0xFE\*(C'\fR is unambiguously \*(L"\s-1BOM,\s0 represented in
lil-endian format\*(R" n' cannot be \f(CW\*(C`U+FFFE\*(C'\fR, represented up in big-endian
format".
.Sp
Surrogates have no meanin up in Unicode outside they use up in pairs to
represent other code points, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat Perl allows dem ta be
represented individually internally, fo' example by saying
\&\f(CW\*(C`chr(0xD801)\*(C'\fR, so dat all code points, not just dem valid fo' open
interchange, are
representable.  Unicode do define semantics fo' them, like fuckin their
General Category is \*(L"Cs\*(R".  But cuz they use is somewhat dangerous,
Perl will warn (usin tha warnin category \*(L"surrogate\*(R", which be a
sub-category of \*(L"utf8\*(R") if a attempt is made
to do thangs like take tha lower case of one, or match
case-insensitively, or ta output em.  (But don't try dis on Perls
before 5.14.)
.IP "\(bu" 4
\&\s-1UTF\-32, UTF\-32BE, UTF\-32LE\s0
.Sp
Da \s-1UTF\-32\s0 crew is pretty much like tha \s-1UTF\-16\s0 crew, expect that
the units is 32\-bit, n' therefore tha surrogate scheme is not
needed. Y'all KNOW dat shit, muthafucka!  \s-1UTF\-32\s0 be a gangbangin' fixed-width encoding.  Da \s-1BOM\s0 signatures are
\&\f(CW\*(C`0x00 0x00 0xFE 0xFF\*(C'\fR fo' \s-1BE\s0 n' \f(CW\*(C`0xFF 0xFE 0x00 0x00\*(C'\fR fo' \s-1LE.\s0
.IP "\(bu" 4
\&\s-1UCS\-2, UCS\-4\s0
.Sp
Legacy, fixed-width encodings defined by tha \s-1ISO 10646\s0 standard. Y'all KNOW dat shit, muthafucka!  \s-1UCS\-2\s0 be a 16\-bit
encoding.  Unlike \s-1UTF\-16, UCS\-2\s0 aint extensible beyond \f(CW\*(C`U+FFFF\*(C'\fR,
because it do not use surrogates.  \s-1UCS\-4\s0 be a 32\-bit encoding,
functionally identical ta \s-1UTF\-32 \s0(the difference bein that
\&\s-1UCS\-4\s0 forbidz neither surrogates nor code points larger than 0x10_FFFF).
.IP "\(bu" 4
\&\s-1UTF\-7\s0
.Sp
A seven-bit safe (non-eight-bit) encoding, which is useful if the
transhiznit or storage aint eight-bit safe.  Defined by \s-1RFC 2152.\s0
.SS "Non-characta code points"
.IX Subsection "Non-characta code points"
66 code points is set aside up in Unicode as \*(L"non-characta code points\*(R".
These all have tha Unassigned (Cn) General Category, n' they never will
be assigned. Y'all KNOW dat shit, muthafucka!  These is never supposed ta be up in legal Unicode input
streams, so dat code can use dem as sentinels dat can be mixed in
with characta data, n' they always is ghon be distinguishable from dat data.
To keep dem outta Perl input streams, strict \s-1UTF\-8\s0 should be
specified, like fuckin by rockin tha layer \f(CW\*(C`:encoding(\*(AqUTF\-8\*(Aq)\*(C'\fR.  The
non-characta code points is tha 32 between U+FDD0 n' U+FDEF, n' the
34 code points U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, ... U+10FFFE, U+10FFFF.
Some playas is under tha mistaken impression dat these is \*(L"illegal\*(R",
but dat aint true.  An application or cooperatin set of applications
can legally use dem at will internally; but these code points are
\&\*(L"illegal fo' open interchange\*(R".  Therefore, Perl aint gonna accept these
from input streams unless lax rulez is bein used, n' will warn
(usin tha warnin category \*(L"nonchar\*(R", which be a sub-category of \*(L"utf8\*(R") if
an attempt is made ta output em.
.SS "Beyond Unicode code points"
.IX Subsection "Beyond Unicode code points"
Da maximum Unicode code point is U+10FFFF.  But Perl accepts code
points up ta tha maximum permissible unsigned number available on the
platform.  But fuck dat shiznit yo, tha word on tha street is dat Perl aint gonna accept these from input streams unless
lax rulez is bein used, n' will warn (usin tha warnin category
\&\*(L"non_unicode\*(R", which be a sub-category of \*(L"utf8\*(R") if a attempt is made to
operate on or output em.  For example, \f(CW\*(C`uc(0x11_0000)\*(C'\fR will generate
this warning, returnin tha input parameta as its result, as tha upper
case of every last muthafuckin non-Unicode code point is tha code point itself.
.SS "Securitizzle Implicationz of Unicode"
.IX Subsection "Securitizzle Implicationz of Unicode"
Read Unicode Securitizzle Considerations <http://www.unicode.org/reports/tr36>.
Also, note tha following:
.IP "\(bu" 4
Malformed \s-1UTF\-8\s0
.Sp
Unfortunately, tha original gangsta justification of \s-1UTF\-8\s0 leaves some room for
interpretation of how tha fuck nuff bytez of encoded output one should generate
from one input Unicode character n' shit.  Strictly bustin lyrics, tha shortest
possible sequence of \s-1UTF\-8\s0 bytes should be generated,
because otherwise there is potential fo' a input buffer overflow at
the receivin end of a \s-1UTF\-8\s0 connection. I aint talkin' bout chicken n' gravy biatch.  Perl always generates the
shortest length \s-1UTF\-8,\s0 n' wit warnings on, Perl will warn about
non-shortest length \s-1UTF\-8\s0 along wit other malformations, like fuckin the
surrogates, which is not Unicode code points valid fo' interchange.
.IP "\(bu" 4
Regular expression pattern matchin may surprise you if you not
accustomed ta Unicode.  Startin up in Perl 5.14, nuff muthafuckin pattern
modifiers is available ta control this, called tha characta set
modifiers.  Details is given up in \*(L"Characta set modifiers\*(R" up in perlre.
.PP
As discussed elsewhere, Perl has one foot (two hooves?) planted in
each of two ghettos: tha oldschool ghetto of bytes n' tha freshly smoked up ghetto of
characters, upgradin from bytes ta charactas when necessary.
If yo' legacy code do not explicitly use Unicode, no automatic
switch-over ta charactas should happen. I aint talkin' bout chicken n' gravy biatch.  Charactas shouldn't get
downgraded ta bytes, either n' shit.  It be possible ta accidentally mix bytes
and characters, however (see perluniintro), up in which case \f(CW\*(C`\ew\*(C'\fR in
regular expressions might start behavin differently (unless tha \f(CW\*(C`/a\*(C'\fR
modifier is up in effect).  Review yo' code.  Use warnings n' tha \f(CW\*(C`strict\*(C'\fR pragma.
.SS "Unicode up in Perl on \s-1EBCDIC\s0"
.IX Subsection "Unicode up in Perl on EBCDIC"
Da way Unicode is handled on \s-1EBCDIC\s0 platforms is still
experimental. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  On such platforms, references ta \s-1UTF\-8\s0 encodin up in this
document n' elsewhere should be read as meanin tha UTF-EBCDIC
specified up in Unicode Technical Report 16, unless \s-1ASCII\s0 vs. \s-1EBCDIC\s0 issues
are specifically discussed. Y'all KNOW dat shit, muthafucka! There is no \f(CW\*(C`utfebcdic\*(C'\fR pragma or
\&\*(L":utfebcdic\*(R" layer; rather, \*(L"utf8\*(R" n' \*(L":utf8\*(R" is reused ta mean
the platformz \*(L"natural\*(R" 8\-bit encodin of Unicode. Right back up in yo muthafuckin ass. See perlebcdic
for mo' rap of tha issues.
.SS "Locales"
.IX Subsection "Locales"
See \*(L"Unicode n' \s-1UTF\-8\*(R"\s0 up in perllocale
.SS "When Unicode Do Not Happen"
.IX Subsection "When Unicode Do Not Happen"
While Perl do have extensive ways ta input n' output up in Unicode,
and all dem other \*(L"entry points\*(R" like tha \f(CW@ARGV\fR array (which can sometimes be
interpreted as \s-1UTF\-8\s0), there be still nuff places where Unicode
(in some encodin or another) could be given as arguments or received as
results, or both yo, but it is not.
.PP
Da followin is such intercourses.  Also, peep \*(L"Da \*(R"Unicode Bug"".
For all of these intercourses Perl
currently (az of v5.16.0) simply assumes byte strings both as arguments
and thangs up in dis biatch, or \s-1UTF\-8\s0 strings if tha (problematic) \f(CW\*(C`encoding\*(C'\fR pragma has been used.
.PP
One reason dat Perl do not attempt ta resolve tha role of Unicode in
these thangs is dat tha lyrics is highly dependent on tha operating
system n' tha file system(s).  For example, whether filenames can be
in Unicode n' up in exactly what tha fuck kind of encoding, aint exactly a
portable concept.  Similarly fo' \f(CW\*(C`qx\*(C'\fR n' \f(CW\*(C`system\*(C'\fR: how tha fuck well will the
\&\*(L"command-line intercourse\*(R" (and which of them?) handle Unicode?
.IP "\(bu" 4
chdir, chmod, chown, chroot, exec, link, lstat, mkdir,
rename, rmdir, stat, symlink, truncate, unlink, utime, \-X
.IP "\(bu" 4
\&\f(CW%ENV\fR
.IP "\(bu" 4
glob (aka tha <*>)
.IP "\(bu" 4
open, opendir, sysopen
.IP "\(bu" 4
qx (aka tha backtick operator), system
.IP "\(bu" 4
readdir, readlink
.ie n .SS "Da ""Unicode Bug"""
.el .SS "Da ``Unicode Bug''"
.IX Subsection "Da Unicode Bug"
Da term, \*(L"Unicode bug\*(R" has been applied ta a inconsistency
on \s-1ASCII\s0 platforms wit the
Unicode code points up in tha Latin\-1 Supplement block, that
is, between 128 n' 255.  Without a locale specified, unlike all other
charactas or code points, these charactas have straight-up different semantics in
byte semantics versus characta semantics, unless
\&\f(CW\*(C`use feature \*(Aqunicode_strings\*(Aq\*(C'\fR is specified, directly or indirectly.
(It be indirectly specified by a \f(CW\*(C`use v5.12\*(C'\fR or higher.)
.PP
In characta semantics these upper\-Latin1 charactas is interpreted as
Unicode code points, which means
they have tha same semantics as Latin\-1 (\s-1ISO\-8859\-1\s0).
.PP
In byte semantics (without \f(CW\*(C`unicode_strings\*(C'\fR), they is considered to
be unassigned characters, meanin dat tha only semantics they have is
their ordinal numbers, n' dat they are
not thugz of various characta classes.  None is considered ta match \f(CW\*(C`\ew\*(C'\fR
for example yo, but all match \f(CW\*(C`\eW\*(C'\fR.
.PP
Perl 5.12.0 added \f(CW\*(C`unicode_strings\*(C'\fR ta force characta semantics on
these code points up in some circumstances, which fixed portionz of the
bug; Perl 5.14.0 fixed almost all of it; n' Perl 5.16.0 fixed the
remainder (so far as we know, anyway).  Da lesson here is ta enable
\&\f(CW\*(C`unicode_strings\*(C'\fR ta avoid tha headaches busted lyrics bout below.
.PP
Da old, problematic behavior affects these areas:
.IP "\(bu" 4
Changin tha case of a scalar, dat is, rockin \f(CW\*(C`uc()\*(C'\fR, \f(CW\*(C`ucfirst()\*(C'\fR, \f(CW\*(C`lc()\*(C'\fR,
and \f(CW\*(C`lcfirst()\*(C'\fR, or \f(CW\*(C`\eL\*(C'\fR, \f(CW\*(C`\eU\*(C'\fR, \f(CW\*(C`\eu\*(C'\fR n' \f(CW\*(C`\el\*(C'\fR up in double-quotish
contexts, like fuckin regular expression substitutions.
Under \f(CW\*(C`unicode_strings\*(C'\fR startin up in Perl 5.12.0, characta semantics are
generally used. Y'all KNOW dat shit, muthafucka!  See \*(L"lc\*(R" up in perlfunc fo' details on how tha fuck dis works
in combination wit various other pragmas.
.IP "\(bu" 4
Usin caseless (\f(CW\*(C`/i\*(C'\fR) regular expression matching.
Startin up in Perl 5.14.0, regular expressions compiled within
the scope of \f(CW\*(C`unicode_strings\*(C'\fR use characta semantics
even when executed or compiled tha fuck into larger
regular expressions outside tha scope.
.IP "\(bu" 4
Matchin any of nuff muthafuckin propertizzles up in regular expressions, namely \f(CW\*(C`\eb\*(C'\fR,
\&\f(CW\*(C`\eB\*(C'\fR, \f(CW\*(C`\es\*(C'\fR, \f(CW\*(C`\eS\*(C'\fR, \f(CW\*(C`\ew\*(C'\fR, \f(CW\*(C`\eW\*(C'\fR, n' all tha Posix characta classes
\&\fIexcept\fR \f(CW\*(C`[[:ascii:]]\*(C'\fR.
Startin up in Perl 5.14.0, regular expressions compiled within
the scope of \f(CW\*(C`unicode_strings\*(C'\fR use characta semantics
even when executed or compiled tha fuck into larger
regular expressions outside tha scope.
.IP "\(bu" 4
In \f(CW\*(C`quotemeta\*(C'\fR or its inline equivalent \f(CW\*(C`\eQ\*(C'\fR, no code points above 127
are quoted up in \s-1UTF\-8\s0 encoded strings yo, but up in byte encoded strings, code
points between 128\-255 is always quoted.
Startin up in Perl 5.16.0, consistent quotin rulez is used within the
scope of \f(CW\*(C`unicode_strings\*(C'\fR, as busted lyrics bout up in \*(L"quotemeta\*(R" up in perlfunc.
.PP
This behavior can lead ta unexpected thangs up in dis biatch up in which a stringz semantics
suddenly chizzle if a cold-ass lil code point above 255 be appended ta or removed from it,
which chizzlez tha stringz semantics from byte ta characta or vice versa.  As
an example, consider tha followin program n' its output:
.PP
.Vb 11
\& $ perl \-le\*(Aq
\&     no feature \*(Aqunicode_strings\*(Aq;
\&     $s1 = "\exC2";
\&     $s2 = "\ex{2660}";
\&     fo' ($s1, $s2, $s1.$s2) {
\&         print /\ew/ || 0;
\&     }
\& \*(Aq
\& 0
\& 0
\& 1
.Ve
.PP
If there be a no \f(CW\*(C`\ew\*(C'\fR up in \f(CW\*(C`s1\*(C'\fR or up in \f(CW\*(C`s2\*(C'\fR, why do they concatenation have one?
.PP
This anomaly stems from Perlz attempt ta not disturb olda programs that
didn't use Unicode, n' hence had no semantics fo' charactas outside of the
\&\s-1ASCII\s0 range (except up in a locale), along wit Perlz desire ta add Unicode
support seamlessly.  Da result wasn't seamless: these charactas were
orphaned.
.PP
For Perls earlier than dem busted lyrics bout above, or when a strang is passed
to a gangbangin' function outside tha subpragmaz scope, a workaround is ta always
call \f(CW\*(C`utf8::upgrade($string)\*(C'\fR,
or ta use tha standard module Encode.   Also, a scalar dat has any characters
whose ordinal be above 0x100, or which was specified rockin either of the
\&\f(CW\*(C`\eN{...}\*(C'\fR notations, will automatically have characta semantics.
.SS "Forcin Unicode up in Perl (Or Unforcin Unicode up in Perl)"
.IX Subsection "Forcin Unicode up in Perl (Or Unforcin Unicode up in Perl)"
Sometimes (see \*(L"When Unicode Do Not Happen\*(R" or \*(L"Da \*(R"Unicode Bug"")
there is thangs where you simply need ta force a funky-ass byte
strin tha fuck into \s-1UTF\-8,\s0 or vice versa.  Da low-level calls
utf8::upgrade($bytestring) n' utf8::downgrade($utf8string[, \s-1FAIL_OK\s0]) are
the lyrics.
.PP
Note dat \fIutf8::downgrade()\fR can fail if tha strang gotz nuff characters
that don't fit tha fuck into a funky-ass byte.
.PP
Callin either function on a strang dat already is up in tha desired state be a
no-op.
.SS "Usin Unicode up in \s-1XS\s0"
.IX Subsection "Usin Unicode up in XS"
If you wanna handle Perl Unicode up in \s-1XS\s0 extensions, you may find the
followin C APIs useful naaahhmean, biatch?  See also \*(L"Unicode Support\*(R" up in perlguts fo' an
explanation bout Unicode all up in tha \s-1XS\s0 level, n' perlapi fo' tha \s-1API\s0
details.
.IP "\(bu" 4
\&\f(CW\*(C`DO_UTF8(sv)\*(C'\fR returns legit if tha \f(CW\*(C`UTF8\*(C'\fR flag is on n' tha bytes
pragma aint up in effect.  \f(CW\*(C`SvUTF8(sv)\*(C'\fR returns legit if tha \f(CW\*(C`UTF8\*(C'\fR
flag is on; tha bytes pragma is ignored. Y'all KNOW dat shit, muthafucka!  Da \f(CW\*(C`UTF8\*(C'\fR flag bein on
does \fBnot\fR mean dat there be any charactaz of code points pimped outer
than 255 (or 127) up in tha scalar or dat there be even any characters
in tha scalar. Shiiit, dis aint no joke.  What tha \f(CW\*(C`UTF8\*(C'\fR flag means is dat tha sequence of
octets up in tha representation of tha scalar is tha sequence of \s-1UTF\-8\s0
encoded code pointz of tha charactaz of a string.  Da \f(CW\*(C`UTF8\*(C'\fR flag
bein off means dat each octet up in dis representation encodes a
single characta wit code point 0..255 within tha string.  Perl's
Unicode model aint ta use \s-1UTF\-8\s0 until it is straight-up necessary.
.IP "\(bu" 4
\&\f(CW\*(C`uvchr_to_utf8(buf, chr)\*(C'\fR writes a Unicode characta code point into
a buffer encodin tha code point as \s-1UTF\-8,\s0 n' returns a pointer
pointin afta tha \s-1UTF\-8\s0 bytes.  It works appropriately on \s-1EBCDIC\s0 machines.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_to_uvchr_buf(buf, bufend, lenp)\*(C'\fR readz \s-1UTF\-8\s0 encoded bytes from a
buffer and
returns tha Unicode characta code point and, optionally, tha length of
the \s-1UTF\-8\s0 byte sequence.  It works appropriately on \s-1EBCDIC\s0 machines.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_length(start, end)\*(C'\fR returns tha length of tha \s-1UTF\-8\s0 encoded buffer
in characters.  \f(CW\*(C`sv_len_utf8(sv)\*(C'\fR returns tha length of tha \s-1UTF\-8\s0 encoded
scalar.
.IP "\(bu" 4
\&\f(CW\*(C`sv_utf8_upgrade(sv)\*(C'\fR converts tha strang of tha scalar ta its \s-1UTF\-8\s0
encoded form.  \f(CW\*(C`sv_utf8_downgrade(sv)\*(C'\fR do tha opposite, if
possible.  \f(CW\*(C`sv_utf8_encode(sv)\*(C'\fR is like sv_utf8_upgrade except that
it do not set tha \f(CW\*(C`UTF8\*(C'\fR flag.  \f(CW\*(C`sv_utf8_decode()\*(C'\fR do the
opposite of \f(CW\*(C`sv_utf8_encode()\*(C'\fR.  Note dat none of these is ta be
used as general-purpose encodin or decodin intercourses: \f(CW\*(C`use Encode\*(C'\fR
for dis shit.  \f(CW\*(C`sv_utf8_upgrade()\*(C'\fR be affected by tha encodin pragma
but \f(CW\*(C`sv_utf8_downgrade()\*(C'\fR aint (since tha encodin pragma is
designed ta be a one-way street).
.IP "\(bu" 4
\&\f(CW\*(C`is_utf8_string(buf, len)\*(C'\fR returns legit if \f(CW\*(C`len\*(C'\fR bytez of tha buffer
are valid \s-1UTF\-8.\s0
.IP "\(bu" 4
\&\f(CW\*(C`is_utf8_char_buf(buf, buf_end)\*(C'\fR returns legit if tha pointa points to
a valid \s-1UTF\-8\s0 character.
.IP "\(bu" 4
\&\f(CW\*(C`UTF8SKIP(buf)\*(C'\fR will return tha number of bytes up in tha \s-1UTF\-8\s0 encoded
characta up in tha buffer n' shit.  \f(CW\*(C`UNISKIP(chr)\*(C'\fR will return tha number of bytes
required ta UTF\-8\-encode tha Unicode characta code point.  \f(CW\*(C`UTF8SKIP()\*(C'\fR
is useful fo' example fo' iteratin over tha charactaz of a \s-1UTF\-8\s0
encoded buffer; \f(CW\*(C`UNISKIP()\*(C'\fR is useful, fo' example, up in computing
the size required fo' a \s-1UTF\-8\s0 encoded buffer.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_distance(a, b)\*(C'\fR will tell tha distizzle up in charactas between the
two pointas pointin ta tha same \s-1UTF\-8\s0 encoded buffer.
.IP "\(bu" 4
\&\f(CW\*(C`utf8_hop(s, off)\*(C'\fR will return a pointa ta a \s-1UTF\-8\s0 encoded buffer
that is \f(CW\*(C`off\*(C'\fR (positizzle or negative) Unicode charactas displaced
from tha \s-1UTF\-8\s0 buffer \f(CW\*(C`s\*(C'\fR.  Be careful not ta overstep tha buffer:
\&\f(CW\*(C`utf8_hop()\*(C'\fR will merrily run off tha end or tha beginnin of the
buffer if holla'd at ta do so.
.IP "\(bu" 4
\&\f(CW\*(C`pv_uni_display(dsv, spv, len, pvlim, flags)\*(C'\fR and
\&\f(CW\*(C`sv_uni_display(dsv, ssv, pvlim, flags)\*(C'\fR is useful fo' debuggin the
output of Unicode strings n' scalars.  By default they is useful
only fo' debugging\*(--they display \fBall\fR charactas as hexadecimal code
points\*(--but wit tha flags \f(CW\*(C`UNI_DISPLAY_ISPRINT\*(C'\fR,
\&\f(CW\*(C`UNI_DISPLAY_BACKSLASH\*(C'\fR, n' \f(CW\*(C`UNI_DISPLAY_QQ\*(C'\fR you can make the
output mo' readable.
.IP "\(bu" 4
\&\f(CW\*(C`foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2)\*(C'\fR can be used to
compare two strings case-insensitively up in Unicode.  For case-sensitive
comparisons you can just use \f(CW\*(C`memEQ()\*(C'\fR n' \f(CW\*(C`memNE()\*(C'\fR as usual, except
if one strang is up in utf8 n' tha other aint.
.PP
For mo' shiznit, peep perlapi, n' \fIutf8.c\fR n' \fIutf8.h\fR
in tha Perl source code distribution.
.SS "Hackin Perl ta work on earlier Unicode versions (for straight-up straight-up hackers only)"
.IX Subsection "Hackin Perl ta work on earlier Unicode versions (for straight-up straight-up hackers only)"
Perl by default comes wit tha sickest fuckin supported Unicode version built up in yo, but
you can chizzle ta use any earlier one.
.PP
Downlizzle tha filez up in tha desired version of Unicode from tha Unicode web
site <http://www.unicode.org>).  These should replace tha existin filez in
\&\fIlib/unicore\fR up in tha Perl source tree.  Big up tha instructions in
\&\fI\s-1README\s0.perl\fR up in dat directory ta chizzle a shitload of they names, n' then build
perl (see \s-1INSTALL\s0).
.SH "BUGS"
.IX Header "BUGS"
.SS "Interaction wit Locales"
.IX Subsection "Interaction wit Locales"
See \*(L"Unicode n' \s-1UTF\-8\*(R"\s0 up in perllocale
.SS "Problems wit charactas up in tha Latin\-1 Supplement range"
.IX Subsection "Problems wit charactas up in tha Latin-1 Supplement range"
See \*(L"Da \*(R"Unicode Bug""
.SS "Interaction wit Extensions"
.IX Subsection "Interaction wit Extensions"
When Perl exchanges data wit a extension, tha extension should be
able ta KNOW tha \s-1UTF8\s0 flag n' act accordingly. If the
extension don't recognize dat flag, itz likely dat tha extension
will return incorrectly-flagged data.
.PP
So if you hustlin wit Unicode data, consult tha documentation of
every module you rockin if there be any thangs wit Unicode data
exchange. If tha documentation do not rap bout Unicode at all,
suspect da most thugged-out shitty n' probably peep tha source ta learn how tha fuck the
module is implemented. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Modulez freestyled straight-up up in Perl shouldn't
cause problems. Modulez dat directly or indirectly access code written
in other programmin languages is at risk.
.PP
For affected functions, tha simple game ta avoid data corruption is
to always make tha encodin of tha exchanged data explicit. Chizzle an
encodin dat you know tha extension can handle. Convert arguments passed
to tha extensions ta dat encodin n' convert thangs up in dis biatch back from that
encoding. Write wrapper functions dat do tha conversions fo' you, so
you can lata chizzle tha functions when tha extension catches up.
.PP
To provide a example, letz say tha ghettofab Foo::Bar::escape_html
function don't deal wit Unicode data yet. Da wrapper function
would convert tha argument ta raw \s-1UTF\-8\s0 n' convert tha result back to
Perlz internal representation like so:
.PP
.Vb 6
\&    sub my_escape_html ($) {
\&        my($what) = shift;
\&        return unless defined $what;
\&        Encode::decode_utf8(Foo::Bar::escape_html(
\&                                         Encode::encode_utf8($what)));
\&    }
.Ve
.PP
Sometimes, when tha extension do not convert data but just stores
and retrieves them, yo big-ass booty is ghon be able ta use tha otherwise
dangerous \fIEncode::_utf8_on()\fR function. I aint talkin' bout chicken n' gravy biatch. Letz say tha popular
\&\f(CW\*(C`Foo::Bar\*(C'\fR extension, freestyled up in C, serves up a \f(CW\*(C`param\*(C'\fR method that
lets you store n' retrieve data accordin ta these prototypes:
.PP
.Vb 2
\&    $self\->param($name, $value);            # set a scalar
\&    $value = $self\->param($name);           # retrieve a scalar
.Ve
.PP
If it do not yet provide support fo' any encoding, one could write a
derived class wit such a \f(CW\*(C`param\*(C'\fR method:
.PP
.Vb 12
\&    sub param {
\&      my($self,$name,$value) = @_;
\&      utf8::upgrade($name);     # make shizzle it is UTF\-8 encoded
\&      if (defined $value) {
\&        utf8::upgrade($value);  # make shizzle it is UTF\-8 encoded
\&        return $self\->SUPER::param($name,$value);
\&      } else {
\&        mah $ret = $self\->SUPER::param($name);
\&        Encode::_utf8_on($ret); # we know, it is UTF\-8 encoded
\&        return $ret;
\&      }
\&    }
.Ve
.PP
Some extensions provide filtas on data entry/exit points, such as
DB_File::filter_store_key n' crew. Look up fo' such filtas in
the documentation of yo' extensions, they can make tha transizzle to
Unicode data much easier.
.SS "Speed"
.IX Subsection "Speed"
Some functions is slower when hustlin on \s-1UTF\-8\s0 encoded strings than
on byte encoded strings.  All functions dat need ta hop over
charactas like fuckin \fIlength()\fR, \fIsubstr()\fR or \fIindex()\fR, or matchin regular
expressions can work \fBmuch\fR fasta when tha underlyin data are
byte-encoded.
.PP
In Perl 5.8.0 tha slownizz was often like spectacular; up in Perl 5.8.1
a cachin scheme was introduced which will hopefully make tha slowness
somewhat less spectacular, at least fo' some operations.  In general,
operations wit \s-1UTF\-8\s0 encoded strings is still slower n' shiznit fo' realz. As a example,
the Unicode propertizzles (characta classes) like \f(CW\*(C`\ep{Nd}\*(C'\fR is known to
be like a lil' bit slower (5\-20 times) than they simpla counterparts
like \f(CW\*(C`\ed\*(C'\fR (then again, there be hundredz of Unicode charactas matchin \f(CW\*(C`Nd\*(C'\fR
compared wit tha 10 \s-1ASCII\s0 charactas matchin \f(CW\*(C`d\*(C'\fR).
.SS "Problems on \s-1EBCDIC\s0 platforms"
.IX Subsection "Problems on EBCDIC platforms"
There is nuff muthafuckin known problems wit Perl on \s-1EBCDIC\s0 platforms.  If you
wanna use Perl there, bust email ta perlbug@perl.org.
.PP
In earlier versions, when byte n' characta data was concatenated,
the freshly smoked up strang was sometimes pimped by
decodin tha byte strings as \fI\s-1ISO 8859\-1 \s0(Latin\-1)\fR, even if the
old Unicode strang used \s-1EBCDIC.\s0
.PP
If you find any of these, please report dem as bugs.
.SS "Portin code from perl\-5.6.X"
.IX Subsection "Portin code from perl-5.6.X"
Perl 5.8 has a gangbangin' finger-lickin' different Unicode model from 5.6. In 5.6 tha programmer
was required ta use tha \f(CW\*(C`utf8\*(C'\fR pragma ta declare dat a given scope
sposed ta fuckin deal wit Unicode data n' had ta make shizzle dat only
Unicode data was reachin dat scope. If you have code dat is
workin wit 5.6, yo big-ass booty is ghon need a shitload of tha followin adjustments to
your code. Da examplez is freestyled such dat tha code will continue
to work under 5.6, so you should be safe ta try dem out.
.IP "\(bu" 3
A filehandle dat should read or write \s-1UTF\-8\s0
.Sp
.Vb 3
\&  if ($] > 5.008) {
\&    binmode $fh, ":encoding(utf8)";
\&  }
.Ve
.IP "\(bu" 3
A scalar dat is goin ta be passed ta some extension
.Sp
Be it Compress::Zlib, Apache::Request or any extension dat has no
mention of Unicode up in tha manpage, you need ta make shizzle dat the
\&\s-1UTF8\s0 flag is stripped off. Note dat all up in tha time of dis writing
(January 2012) tha mentioned modulez is not UTF\-8\-aware. Please
check tha documentation ta verify if dis is still true.
.Sp
.Vb 4
\&  if ($] > 5.008) {
\&    require Encode;
\&    $val = Encode::encode_utf8($val); # make octets
\&  }
.Ve
.IP "\(bu" 3
A scalar we gots back from a extension
.Sp
If you believe tha scalar comes back as \s-1UTF\-8,\s0 yo big-ass booty is ghon most likely
want tha \s-1UTF8\s0 flag restored:
.Sp
.Vb 4
\&  if ($] > 5.008) {
\&    require Encode;
\&    $val = Encode::decode_utf8($val);
\&  }
.Ve
.IP "\(bu" 3
Same thang, if yo ass is straight-up shizzle it is \s-1UTF\-8\s0
.Sp
.Vb 4
\&  if ($] > 5.008) {
\&    require Encode;
\&    Encode::_utf8_on($val);
\&  }
.Ve
.IP "\(bu" 3
A wrapper fo' fetchrow_array n' fetchrow_hashref
.Sp
When tha database gotz nuff only \s-1UTF\-8,\s0 a wrapper function or method is
a convenient way ta replace all yo' fetchrow_array and
fetchrow_hashref calls fo' realz. A wrapper function will also make it easier to
adapt ta future enhancements up in yo' database driver n' shit. Note dat at the
time of dis freestylin (January 2012), tha \s-1DBI\s0 has no standardized way
to deal wit \s-1UTF\-8\s0 data. Please check tha documentation ta verify if
that is still true.
.Sp
.Vb 10
\&  sub fetchrow {
\&    # $what is one of fetchrow_{array,hashref}
\&    my($self, $sth, $what) = @_;
\&    if ($] < 5.008) {
\&      return $sth\->$what;
\&    } else {
\&      require Encode;
\&      if (wantarray) {
\&        mah @arr = $sth\->$what;
\&        fo' (@arr) {
\&          defined && /[^\e000\-\e177]/ && Encode::_utf8_on($_);
\&        }
\&        return @arr;
\&      } else {
\&        mah $ret = $sth\->$what;
\&        if (ref $ret) {
\&          fo' mah $k (keys %$ret) {
\&            defined
\&            && /[^\e000\-\e177]/
\&            && Encode::_utf8_on($_) fo' $ret\->{$k};
\&          }
\&          return $ret;
\&        } else {
\&          defined && /[^\e000\-\e177]/ && Encode::_utf8_on($_) fo' $ret;
\&          return $ret;
\&        }
\&      }
\&    }
\&  }
.Ve
.IP "\(bu" 3
A big-ass scalar dat you know can only contain \s-1ASCII\s0
.Sp
Scalars dat contain only \s-1ASCII\s0 n' is marked as \s-1UTF\-8\s0 is sometimes
a drag ta yo' program. If you recognize such a thang, just remove
the \s-1UTF8\s0 flag:
.Sp
.Vb 1
\&  utf8::downgrade($val) if $] > 5.008;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlunitut, perluniintro, perluniprops, Encode, open, utf8, bytes,
perlretut, \*(L"${^UNICODE}\*(R" up in perlvar
<http://www.unicode.org/reports/tr44>).
