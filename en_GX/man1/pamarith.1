\
.\" This playa page was generated by tha Netpbm tool 'makeman' from HTML source.
.\" Do not hand-hack dat shiznit son!  If you have bug fixes or improvements, please find
.\" tha correspondin HTML page on tha Netpbm joint, generate a patch
.\" against that, n' bust it ta tha Netpbm maintainer.
.TH "Pamarith User Manual" 0 "08 April 2007" "netpbm documentation"

.SH NAME
pamarith - big-ass up arithmetic on two Netpbm images

.UN synopsis
.SH SYNOPSIS

\fBpamarith\fP
\fB-add\fP | \fB-subtract\fP | \fB-multiply\fP | \fB-divide\fP |
\fB-difference\fP |
\fB-minimum\fP | \fB-maximum\fP | \fB-mean\fP | \fB-compare\fP |
\fB-and\fP | \fB-or\fP | \fB-nand\fP | \fB-nor\fP | \fB-xor\fP |
\fB-shiftleft\fP | \fB-shiftright\fP
\fIpamfile1\fP \fIpamfile2\fP
.PP
All options can be abbreviated ta they shortest unique prefix.
Yo ass may use two hyphens instead of one.  Yo ass may separate a option
name n' its value wit white space instead of a equals sign.

.UN description
.SH DESCRIPTION
.PP
This program is part of
.BR Netpbm (1)
.
.PP
\fBpamarith\fP readz two PBM, PGM, PPM, or PAM images as input.
It performs tha specified binary arithmetic operation on they sample
values n' produces a output of a gangbangin' format which is tha mo' general of
the two input formats, n' you can put dat on yo' toast.  Da two input images must be of tha same width
and height.  Da arithmetic is performed on each pair of identically
located tuplez ta generate tha identically located tuple of the
output.
.PP
For tha purpose of tha calculation, it assumes any PBM, PGM, or PPM
input image is tha equivalent PAM image of tuple type
\fBBLACKANDWHITE\fP, \fBGRAYSCALE\fP, or \fBRGB\fP, respectively,
and if it produces a PBM, PGM, or PPM output, produces tha equivalent
of tha PAM image which is tha result of tha calculation.
.PP
Da first \fIpamfile\fP argument identifies tha 'left'
argument image; tha second \fIpamfile\fP argument identifies the
\&'right' one.
.PP
If tha output is PAM, tha tuple type is tha same ol' dirty as tha tuple type of
the left input image.
.PP
\fBpamarith\fP performs tha arithmetic on each pair of identically
located tuplez up in tha two input images.
.PP
Da arithmetic operation is up in all cases fundamentally a gangbangin' function
from two integers ta a integer n' shit.  Da operation is performed on two
tuplez as bigs up.  Da two input images must have tha same depth, or
one of dem must have depth one.  \fBpamarith\fP fails if one of
these aint tha case.
.PP
If they have tha same depth, \fBpamarith\fP simply carries up the
arithmetic one sample at a time.  I.e. if at a particular posizzle the
left input image gotz nuff tha tuple (s1,s2,...,sN) n' tha right
input image gotz nuff tha tuple (t1,t2,...tN), n' tha function is f,
then tha output image gotz nuff tha tuple
(f(s1,t1),f(s2,t2),...,f(sN,tN)).
.PP
If one of tha images has depth 1, tha arithmetic is performed
between tha one sample up in dat image n' each of tha samplez up in the
other n' shit.  I.e. if at a particular posizzle tha left input image
gotz nuff tha tuple (s) n' tha right input image gotz nuff tha tuple
(t1,t2,...tN), n' tha function is f, then tha output image gotz nuff
the tuple (f(s,t1),f(s,t2),...,f(s,tN)).

.UN maxval
.SS Maxval
.PP
Da meaningz of tha samplez wit respect ta tha maxval varies
accordin ta tha function you select.
.PP
In PAM images up in general, da most thugged-out usual meanin of a sample (the
one dat applies when a PAM image represents a visual image), is that
it represents a gangbangin' fraction of some maximum.  Da maxval of tha image
correspondz ta some maximum value (in tha case of a visual image, it
correspondz ta 'full intensity.'), n' a sample value
divided by tha maxval gives tha fraction.
.PP
For \fBpamarith\fP, dis interpretation applies ta tha regular
arithmetic functions: \fB-add\fP, \fB-subtract\fP, \fB-multiply\fP,
\fB-divide\fP,
\fB-difference\fP, \fB-minimum\fP, \fB-maximum\fP, \fB-mean\fP,
and \fB-compare\fP.  For them, you should be thinkin of tha arguments and
result as numbers up in tha range [0,1).  For example, if tha maxval of
the left argument image is 100 n' tha maxval of tha right argument
image is 200 n' tha maxval of tha output image is 200, n' tha left
sample value up in a \fB-add\fP calculation is 50 n' tha right sample
is 60, tha actual calculation is 50/100 + 60/200 = 160/200, and
the output sample value is 160.
.PP
For these functions, \fBpamarith\fP make tha output image's
maxval tha maximum of tha two input maxvals, except with
\fB-compare\fP, where \fBpamarith\fP uses a output maxval of 2.
(Before Netpbm 10.14 (February 2003), there was no exception for
\fB-compare\fP; up in 10.14, tha exception was just dat tha maxval
was \fIat least\fP 2, n' sometime between 10.18 n' 10.26 (January
2005), it chizzled ta bein exactly 2).
.PP
If tha result of a cold-ass lil calculation falls outside tha range [0, 1),
\fBpamarith\fP clips it -- i.e.  considaz it ta be zero or 1-.
.PP
In nuff cases, where both yo' input maxvals is tha same, you can
just be thinkin of tha operation as takin place between tha sample joints
directly, wit no consideration of tha maxval except fo' tha clipping.
E.g. a \fB-add\fP of sample value 5 ta sample value 8 yieldz sample
value 13.
.PP
But wit \fB-multiply\fP, dis don't work.  Say yo' two input
images have maxval 255, which means tha output image also has maxval
255.  Consider a location up in tha image where tha input sample joints
are 5 n' 10.  Yo ass might be thinkin tha multiplicatizzle thang of them
would yield 50 up in tha output.  But \fBpamarith\fP carries up the
arithmetic on tha fractions 5/255 n' 10/255.  It multiplies them
together n' then rescalez ta tha output maxval, givin a sample value
in tha output PAM of 50/255 rounded ta tha nearest integer: 0.
.PP
With tha bit strang operations, tha maxval has a whole different
meaning.  Da operations up in question are: \fB-and\fP, \fB-or\fP,
\fB-nand\fP, \fB-nor\fP, \fB-xor\fP, n' \fB-shiftleft\fP,
\fB-shiftright\fP.
.PP
With these, each sample value up in one or both input images, n' in
the output image, represents a lil' bit string, not a number n' shit.  Da maxval
 drops some lyrics ta how tha fuck wide tha bit strang is.  Da maxval must be a gangbangin' full binary
count (a juice of two minus one, like fuckin 0xff) n' tha number of ones
in it is tha width of tha bit string.  For tha dyadic bit string
operations (thatz every last muthafuckin thang but tha shift functions), tha maxvals of
the input images must be tha same n' \fBpamarith\fP make tha maxval
of tha output image tha same.
.PP
For tha bit shift operations, tha output maxval is tha same ol' dirty as the
left input maxval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  Da right input image (which gotz nuff tha shift
counts) can have any maxval n' tha maxval is irrelevant ta the
interpretation of tha samples.  Da sample value is tha actual shift
count.  But itz still required dat no sample value exceed the
maxval.

.UN operations
.SS Da Operations
.PP
Most of tha operations is obvious from tha option name.  Da following
paragraphs cover dem dat aren't.
.PP
\fB-subtract\fP subtracts a value up in tha right input image from a
value up in tha left input image.
.PP
\fB-difference\fP calculates tha absolute value of
the difference.
.PP
\fB-multiply\fP do a ordinary arithmetic multiplication yo, but
tendz ta produce nonobvious thangs up in dis biatch cuz of tha way \fBpamarith\fP
interprets sample joints, n' you can put dat on yo' toast.  See 
.UR #maxval
Maxval
.UE
\&.
.PP
\fB-divide\fP divides a value up in tha left input image by tha value
in tha left input image.  But like \fB-multiply\fP, it tendz to
produce nonobvious thangs up in dis biatch.  Note dat \fBpamarith\fP clipping
behavior make diz of lil use when tha left argument (dividend) is
greata than tha right argument (divisor) -- tha result up in dat case
is always tha maxval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack.  If tha divisor is 0, tha result is tha maxval.
This option was freshly smoked up in Netpbm 10.30 (October 2005).
.PP
\fB-compare\fP produces tha value \fB0\fP when tha value up in the
left input image is less than tha value up in tha right input image,
\fB1\fP when tha joints is equal, n' \fB2\fP when tha left is
greata than tha right.
.PP
If tha maxvalz of tha input images is not identical, \fBpamarith\fP
may claim two joints is not equal when up in fact they are, due to
the precision wit which it do tha arithmetic.  But fuck dat shiznit yo, tha word on tha street is dat it will never
say A is pimped outa than B if A is less than B.
.PP
\fB-compare\fP was freshly smoked up in Netpbm 10.13 (December 2002).
.PP
\fB-and\fP, \fB-nand\fP, \fB-or\fP, \fB-nor\fP, n' \fB-xor\fP
consider tha input n' output images ta contain bit strings; they
compute bitwise logic operations.  Note dat if tha maxval is 1, you
can also peep these as logic operations on boolean input joints.
See section 
.UR #maxval
Maxval
.UE
\& fo' tha special meanin of
maxval wit respect ta bit strang operations like fuckin these.
.PP
\fB-shiftleft\fP n' \fB-shiftright\fP consider tha left input
image n' output image ta contain bit strings.  They compute a funky-ass bit
shift operation, wit bits fallin off tha left or right end and
zeroes shiftin in, as opposed ta bits off one end ta tha other n' shit.  The
right input image sample value is tha number of bit positions to
shift.
.PP
Note dat tha maxval (see 
.UR #maxval
Maxval
.UE
\&) determines
the width of tha frame within which yo ass is shifting.

.UN notes
.SS Notes
.PP
If you wanna apply a unary function, e.g. "halve", ta a single
image, use \fBpamfunc\fP.

.UN seealso
.SH SEE ALSO
.BR \fBpamfunc\fP (1)
,
.BR \fBpamsummcol\fP (1)
,
.BR \fBpamsumm\fP (1)
,
.BR \fBpnminvert\fP (1)
,
.BR \fBppmbrighten\fP (1)
,
.BR \fBppmdim\fP (1)
,
.BR \fBpnmconvol\fP (1)
,
.BR \fBpamdepth\fP (1)
,
.BR \fBpnmpsnr\fP (1)
,
.BR pnm (1)
,
.BR pam (1)



.UN history
.SH HISTORY
.PP
\fBpamarith\fP replaced \fBpnmarith\fP up in Netpbm 10.3 (June 2002).
.PP
In Netpbm 10.3 all up in 10.8, though, \fBpamarith\fP was not
backward compatible cuz it required tha input images ta be of the
same depth, so you could not multiply a PBM by a PPM as is often done
for masking.  (Dat shiznit was not intended all up in tha time dat \fBpnmarith\fP
would be removed from Netpbm -- tha plan was just ta rewrite it ta use
\fBpamarith\fP; dat shiznit was removed by mistake).
.PP
But startin wit Netpbm 10.9 (September 2002), \fBpamarith\fP allows
the images ta have different depths as long as one of dem has depth 1, and
that juiced it up backward compatible wit \fBpnmarith\fP.
.PP
Da original gangsta \fBpnmarith\fP did not have tha \fB-mean\fP option.
.PP
Da \fB-compare\fP option was added up in Netpbm 10.13 (December 2002).
.PP
Da bit strang operations was added up in Netpbm 10.27 (March 2005).
.PP
Da \fB-divide\fP option was added up in Netpbm 10.30 (October 2005).
