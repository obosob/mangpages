.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLINTERP 1"
.TH PERLINTERP 1 "2014-01-31" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlinterp \- An overview of tha Perl interpreter
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document serves up a overview of how tha fuck tha Perl interpreta works at
the level of C code, along wit pointas ta tha relevant C source code
files.
.SH "ELEMENTS OF THE INTERPRETER"
.IX Header "ELEMENTS OF THE INTERPRETER"
Da work of tha interpreta has two main stages: compilin tha code
into tha internal representation, or bytecode, n' then executin dat shit.
\&\*(L"Compiled code\*(R" up in perlguts explains exactly how tha fuck tha compilation stage
happens.
.PP
Here be a gangbangin' finger-lickin' dirty-ass short breakdown of perlz operation:
.SS "Startup"
.IX Subsection "Startup"
Da action begins up in \fIperlmain.c\fR. (or \fIminiperlmain.c\fR fo' miniperl)
This is straight-up high-level code, enough ta fit on a single screen, n' it
resemblez tha code found up in perlembed; most of tha real action takes
place up in \fIperl.c\fR
.PP
\&\fIperlmain.c\fR is generated by \f(CW\*(C`ExtUtils::Miniperl\*(C'\fR from
\&\fIminiperlmain.c\fR at make time, so you should make perl ta follow this
along.
.PP
First, \fIperlmain.c\fR allocates some memory n' constructs a Perl
interpreter, along these lines:
.PP
.Vb 9
\&    1 PERL_SYS_INIT3(&argc,&argv,&env);
\&    2
\&    3 if (!PL_do_undump) {
\&    4     my_perl = perl_alloc();
\&    5     if (!my_perl)
\&    6         exit(1);
\&    7     perl_construct(my_perl);
\&    8     PL_perl_destruct_level = 0;
\&    9 }
.Ve
.PP
Line 1 be a macro, n' its definizzle is dependent on yo' operating
system. Line 3 references \f(CW\*(C`PL_do_undump\*(C'\fR, a global variable \- all
global variablez up in Perl start wit \f(CW\*(C`PL_\*(C'\fR. This  drops some lyrics ta you whether the
current hustlin program was pimped wit tha \f(CW\*(C`\-u\*(C'\fR flag ta perl and
then \fIundump\fR, which means itz goin ta be false up in any sane context.
.PP
Line 4 calls a gangbangin' function up in \fIperl.c\fR ta allocate memory fo' a Perl
interpreter n' shit. It aint nuthin but like a simple function, n' tha gutz of it looks
like this:
.PP
.Vb 1
\& my_perl = (PerlInterpreter*)PerlMem_malloc(sizeof(PerlInterpreter));
.Ve
.PP
Here you peep a example of Perlz system abstraction, which we'll see
later: \f(CW\*(C`PerlMem_malloc\*(C'\fR is either yo' systemz \f(CW\*(C`malloc\*(C'\fR, or Perl's
own \f(CW\*(C`malloc\*(C'\fR as defined up in \fImalloc.c\fR if you selected dat option at
configure time.
.PP
Next, up in line 7, we construct tha interpreta rockin perl_construct,
also up in \fIperl.c\fR; dis sets up all tha special variablez dat Perl
needs, tha stacks, n' so on.
.PP
Now we pass Perl tha command line options, n' tell it ta go:
.PP
.Vb 3
\& exitstatus = perl_parse(my_perl, xs_init, argc, argv, (char **)NULL);
\& if (!exitstatus)
\&     perl_run(my_perl);
\&
\& exitstatus = perl_destruct(my_perl);
\&
\& perl_free(my_perl);
.Ve
.PP
\&\f(CW\*(C`perl_parse\*(C'\fR is straight-up a wrapper round \f(CW\*(C`S_parse_body\*(C'\fR, as defined
in \fIperl.c\fR, which processes tha command line options, sets up any
statically linked \s-1XS\s0 modules, opens tha program n' calls \f(CW\*(C`yyparse\*(C'\fR to
parse dat shit.
.SS "Parsing"
.IX Subsection "Parsing"
Da aim of dis stage is ta take tha Perl source, n' turn it tha fuck into an
op tree. We bout ta peep what tha fuck one of dem be lookin like later n' shit. Right back up in yo muthafuckin ass. Strictly
speaking, there be a three thangs goin on here.
.PP
\&\f(CW\*(C`yyparse\*(C'\fR, tha parser, lives up in \fIperly.c\fR, although you betta off
readin tha original gangsta \s-1YACC\s0 input up in \fIperly.y\fR. (Yes, Virginia, there
\&\fBis\fR a \s-1YACC\s0 grammar fo' Perl!) Da thang of tha parser is ta take your
code n' \*(L"understand\*(R" it, splittin it tha fuck into sentences, decidin which
operandz go wit which operators n' so on.
.PP
Da parser is nobly assisted by tha lexer, which chunks up yo' input
into tokens, n' decides what tha fuck type of thang each token is: a variable
name, a operator, a funky-ass bareword, a subroutine, a cold-ass lil core function, n' so
on. I aint talkin' bout chicken n' gravy biatch. Da main point of entry ta tha lexer is \f(CW\*(C`yylex\*(C'\fR, n' dat n' its
associated routines can be found up in \fItoke.c\fR. Perl aint much like
other computa languages; itz highly context sensitizzle at times, it
can be tricky ta work up what tha fuck sort of token suttin' is, or where a
token endz fo' realz. As such, there be a a shitload of interplay between tha tokeniser
and tha parser, which can git pretty frightenin if you not used to
it.
.PP
As tha parser understandz a Perl program, it buildz up a tree of
operations fo' tha interpreta ta big-ass up durin execution. I aint talkin' bout chicken n' gravy biatch. The
routines which construct n' link together tha various operations are
to be found up in \fIop.c\fR, n' is ghon be examined later.
.SS "Optimization"
.IX Subsection "Optimization"
Now tha parsin stage is complete, n' tha finished tree represents the
operations dat tha Perl interpreta need ta big-ass up ta execute our
program. Next, Perl do a thugged-out dry run over tha tree lookin for
optimisations: constant expressions like fuckin \f(CW\*(C`3 + 4\*(C'\fR is ghon be computed
now, n' tha optimizer will also peep if any multiple operations can be
replaced wit a single one. For instance, ta fetch tha variable
\&\f(CW$foo\fR, instead of grabbin tha glob \f(CW*foo\fR n' lookin all up in tha scalar
component, tha optimizer fiddlez tha op tree ta bust a gangbangin' function which
directly looks up tha scalar up in question. I aint talkin' bout chicken n' gravy biatch. Da main optimizer is \f(CW\*(C`peep\*(C'\fR
in \fIop.c\fR, n' nuff ops have they own optimizin functions.
.SS "Running"
.IX Subsection "Running"
Now we finally locked n loaded ta go: our crazy asses have compiled Perl byte code, n' all
thatz left ta do is run dat shit. Da actual execution is done by the
\&\f(CW\*(C`runops_standard\*(C'\fR function up in \fIrun.c\fR; mo' specifically, itz done
by these three innocent lookin lines:
.PP
.Vb 3
\&    while ((PL_op = PL_op\->op_ppaddr(aTHX))) {
\&        PERL_ASYNC_CHECK();
\&    }
.Ve
.PP
Yo ass may be mo' laid back wit tha Perl version of that:
.PP
.Vb 1
\&    PERL_ASYNC_CHECK() while $Perl::op = &{$Perl::op\->{function}};
.Ve
.PP
Well, maybe not fo' realz. Anyway, each op gotz nuff a gangbangin' function pointer, which
stipulates tha function which will straight-up carry up tha operation.
This function will return tha next op up in tha sequence \- dis allows for
things like \f(CW\*(C`if\*(C'\fR which chizzle tha next op dynamically at run time. The
\&\f(CW\*(C`PERL_ASYNC_CHECK\*(C'\fR make shizzle dat thangs like signals interrupt
execution if required.
.PP
Da actual functions called is known as \s-1PP\s0 code, n' they spread
between four files: \fIpp_hot.c\fR gotz nuff tha \*(L"hot\*(R" code, which is most
often used n' highly optimized, \fIpp_sys.c\fR gotz nuff all the
system-specific functions, \fIpp_ctl.c\fR gotz nuff tha functions which
implement control structures (\f(CW\*(C`if\*(C'\fR, \f(CW\*(C`while\*(C'\fR n' tha like) n' \fIpp.c\fR
gotz nuff every last muthafuckin thang else. These are, if you like, tha C code fo' Perl's
built-in functions n' operators.
.PP
Note dat each \f(CW\*(C`pp_\*(C'\fR function is sposed ta fuckin return a pointa ta the
next op. Calls ta perl subs (and eval blocks) is handled within the
same runops loop, n' do not consume extra space on tha C stack. For
example, \f(CW\*(C`pp_entersub\*(C'\fR n' \f(CW\*(C`pp_entertry\*(C'\fR just push a \f(CW\*(C`CxSUB\*(C'\fR or
\&\f(CW\*(C`CxEVAL\*(C'\fR block struct onto tha context stack which contain tha address
of tha op followin tha sub call or eval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. They then return tha straight-up original gangsta op
of dat sub or eval block, n' so execution continuez of dat sub or
block. Later, a \f(CW\*(C`pp_leavesub\*(C'\fR or \f(CW\*(C`pp_leavetry\*(C'\fR op pops tha \f(CW\*(C`CxSUB\*(C'\fR
or \f(CW\*(C`CxEVAL\*(C'\fR, retrieves tha return op from it, n' returns dat shit.
.SS "Exception handing"
.IX Subsection "Exception handing"
Perlz exception handin (i.e. \f(CW\*(C`die\*(C'\fR etc.) is built on top of the
low-level \f(CW\*(C`setjmp()\*(C'\fR/\f(CW\*(C`longjmp()\*(C'\fR C\-library functions. These basically
provide a way ta capture tha current \s-1PC\s0 n' \s-1SP\s0 registas n' later
restore them; i.e. a \f(CW\*(C`longjmp()\*(C'\fR continues all up in tha point up in code where
a previous \f(CW\*(C`setjmp()\*(C'\fR was done, wit anythang further up on tha C
stack bein lost. This is why code should always save joints using
\&\f(CW\*(C`SAVE_FOO\*(C'\fR rather than up in auto variables.
.PP
Da perl core wraps \f(CW\*(C`setjmp()\*(C'\fR etc up in tha macros \f(CW\*(C`JMPENV_PUSH\*(C'\fR and
\&\f(CW\*(C`JMPENV_JUMP\*(C'\fR. Da basic rule of perl exceptions is dat \f(CW\*(C`exit\*(C'\fR, and
\&\f(CW\*(C`die\*(C'\fR (in tha absence of \f(CW\*(C`eval\*(C'\fR) big-ass up a \f(CWJMPENV_JUMP(2)\fR, while
\&\f(CW\*(C`die\*(C'\fR within \f(CW\*(C`eval\*(C'\fR do a \f(CWJMPENV_JUMP(3)\fR.
.PP
At entry points ta perl, like fuckin \f(CW\*(C`perl_parse()\*(C'\fR, \f(CW\*(C`perl_run()\*(C'\fR and
\&\f(CW\*(C`call_sv(cv, G_EVAL)\*(C'\fR each do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR, then enta a runops
loop or whatever, n' handle possible exception returns. For a 2
return, final cleanup is performed, like fuckin poppin stacks n' calling
\&\f(CW\*(C`CHECK\*(C'\fR or \f(CW\*(C`END\*(C'\fR blocks fo' realz. Amongst other thangs, dis is how tha fuck scope
cleanup still occurs durin a \f(CW\*(C`exit\*(C'\fR.
.PP
If a \f(CW\*(C`die\*(C'\fR can find a \f(CW\*(C`CxEVAL\*(C'\fR block on tha context stack, then the
stack is popped ta dat level n' tha return op up in dat block is
assigned ta \f(CW\*(C`PL_restartop\*(C'\fR; then a \f(CWJMPENV_JUMP(3)\fR is performed.
This normally passes control back ta tha guard. Y'all KNOW dat shit, muthafucka! In tha case of
\&\f(CW\*(C`perl_run\*(C'\fR n' \f(CW\*(C`call_sv\*(C'\fR, a non-null \f(CW\*(C`PL_restartop\*(C'\fR triggers
re-entry ta tha runops loop. Da is tha aiiight way dat \f(CW\*(C`die\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR is handled within a \f(CW\*(C`eval\*(C'\fR.
.PP
Sometimes ops is executed within a inner runops loop, like fuckin tie,
sort or overload code. In dis case, suttin' like
.PP
.Vb 1
\&    sub FETCH { eval { take a thugged-out dirtnap } }
.Ve
.PP
would cause a longjmp right back ta tha guard up in \f(CW\*(C`perl_run\*(C'\fR, popping
both runops loops, which is clearly incorrect. One way ta avoid dis is
for tha tie code ta do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR before executin \f(CW\*(C`FETCH\*(C'\fR in
the inner runops loop yo, but fo' efficiency reasons, perl up in fact just
sets a gangbangin' flag, rockin \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR. Da \f(CW\*(C`pp_require\*(C'\fR,
\&\f(CW\*(C`pp_entereval\*(C'\fR n' \f(CW\*(C`pp_entertry\*(C'\fR ops check dis flag, n' if true,
they call \f(CW\*(C`docatch\*(C'\fR, which do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR n' starts a new
runops level ta execute tha code, rather than bustin it on tha current
loop.
.PP
As a gangbangin' further optimisation, on exit from tha eval block up in tha \f(CW\*(C`FETCH\*(C'\fR,
execution of tha code followin tha block is still carried on up in the
inner loop. When a exception is raised, \f(CW\*(C`docatch\*(C'\fR compares the
\&\f(CW\*(C`JMPENV\*(C'\fR level of tha \f(CW\*(C`CxEVAL\*(C'\fR wit \f(CW\*(C`PL_top_env\*(C'\fR n' if they differ,
just re-throws tha exception. I aint talkin' bout chicken n' gravy biatch. In dis way any inner loops git popped.
.PP
Herez a example.
.PP
.Vb 5
\&    1: eval { tie @a, \*(AqA\*(Aq };
\&    2: sub A::TIEARRAY {
\&    3:     eval { take a thugged-out dirtnap };
\&    4:     die;
\&    5: }
.Ve
.PP
To run dis code, \f(CW\*(C`perl_run\*(C'\fR is called, which do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR
then entas a runops loop. This loop executes tha eval n' tie ops on
line 1, wit tha eval pushin a \f(CW\*(C`CxEVAL\*(C'\fR onto tha context stack.
.PP
Da \f(CW\*(C`pp_tie\*(C'\fR do a \f(CW\*(C`CATCH_SET(TRUE)\*(C'\fR, then starts a second runops
loop ta execute tha body of \f(CW\*(C`TIEARRAY\*(C'\fR. When it executes tha entertry
op on line 3, \f(CW\*(C`CATCH_GET\*(C'\fR is true, so \f(CW\*(C`pp_entertry\*(C'\fR calls \f(CW\*(C`docatch\*(C'\fR
which do a \f(CW\*(C`JMPENV_PUSH\*(C'\fR n' starts a third runops loop, which then
executes tha take a thugged-out dirtnap op fo' realz. At dis point tha C call stack be lookin like this:
.PP
.Vb 10
\&    Perl_pp_die
\&    Perl_runops      # third loop
\&    S_docatch_body
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
and tha context n' data stacks, as shown by \f(CW\*(C`\-Dstv\*(C'\fR, look like:
.PP
.Vb 9
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
\&      CX 1: EVAL   => *
\&    retop=nextstate
.Ve
.PP
Da take a thugged-out dirtnap pops tha straight-up original gangsta \f(CW\*(C`CxEVAL\*(C'\fR off tha context stack, sets
\&\f(CW\*(C`PL_restartop\*(C'\fR from it, do a \f(CWJMPENV_JUMP(3)\fR, n' control returns
to tha top \f(CW\*(C`docatch\*(C'\fR. This then starts another third-level runops
level, which executes tha nextstate, pushmark n' take a thugged-out dirtnap ops on line 4 fo' realz. At
the point dat tha second \f(CW\*(C`pp_die\*(C'\fR is called, tha C call stack looks
exactly like dat above, even though we is no longer within a inner
eval; dis is cuz of tha optimization mentioned earlier n' shiznit yo. However,
the context stack now be lookin like this, ie wit tha top CxEVAL popped:
.PP
.Vb 7
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
\&      CX 1: EVAL   => AV()  PV("A"\e0)
\&      retop=leave
\&    STACK 1: MAGIC
\&      CX 0: SUB    =>
\&      retop=(null)
.Ve
.PP
Da take a thugged-out dirtnap on line 4 pops tha context stack back down ta tha CxEVAL,
leavin it as:
.PP
.Vb 2
\&    STACK 0: MAIN
\&      CX 0: BLOCK  =>
.Ve
.PP
As usual, \f(CW\*(C`PL_restartop\*(C'\fR is extracted from tha \f(CW\*(C`CxEVAL\*(C'\fR, n' a
\&\f(CWJMPENV_JUMP(3)\fR done, which pops tha C stack back ta tha docatch:
.PP
.Vb 10
\&    S_docatch
\&    Perl_pp_entertry
\&    Perl_runops      # second loop
\&    S_call_body
\&    Perl_call_sv
\&    Perl_pp_tie
\&    Perl_runops      # first loop
\&    S_run_body
\&    perl_run
\&    main
.Ve
.PP
In  dis case, cuz tha \f(CW\*(C`JMPENV\*(C'\fR level recorded up in tha \f(CW\*(C`CxEVAL\*(C'\fR
differs from tha current one, \f(CW\*(C`docatch\*(C'\fR just do a \f(CWJMPENV_JUMP(3)\fR
and tha C stack unwindz to:
.PP
.Vb 2
\&    perl_run
\&    main
.Ve
.PP
Because \f(CW\*(C`PL_restartop\*(C'\fR is non-null, \f(CW\*(C`run_body\*(C'\fR starts a freshly smoked up runops
loop n' execution continues.
.SS "\s-1INTERNAL VARIABLE TYPES\s0"
.IX Subsection "INTERNAL VARIABLE TYPES"
Yo ass should by now have had a peep perlguts, which  drops some lyrics ta you about
Perlz internal variable types: SVs, HVs, AVs n' tha rest. If not, do
that now, nahmeean?
.PP
These variablez is used not only ta represent Perl-space variables,
but also any constants up in tha code, as well as some structures
completely internal ta Perl. Da symbol table, fo' instance, be an
ordinary Perl hash. Yo crazy-ass code is represented by a \s-1SV\s0 as itz read into
the parser; any program filez you call is opened via ordinary Perl
filehandles, n' so on.
.PP
Da core Devel::Peek module lets our asses examine SVs from a
Perl program. Letz see, fo' instance, how tha fuck Perl treats tha constant
\&\f(CW"hello"\fR.
.PP
.Vb 7
\&      % perl \-MDevel::Peek \-e \*(AqDump("hello")\*(Aq
\&    1 SV = PV(0xa041450) at 0xa04ecbc
\&    2   REFCNT = 1
\&    3   FLAGS = (POK,READONLY,pPOK)
\&    4   PV = 0xa0484e0 "hello"\e0
\&    5   CUR = 5
\&    6   LEN = 6
.Ve
.PP
Readin \f(CW\*(C`Devel::Peek\*(C'\fR output takes a lil' bit of practise, so letz go
all up in it line by line.
.PP
Line 1  drops some lyrics ta our asses our slick asses lookin at a \s-1SV\s0 which lives at \f(CW0xa04ecbc\fR in
memory. Right back up in yo muthafuckin ass. SVs theyselves is straight-up simple structures yo, but they contain a
pointa ta a mo' complex structure. In dis case, itz a \s-1PV,\s0 a
structure which holdz a strang value, at location \f(CW0xa041450\fR. Line 2
is tha reference count; there be no other references ta dis data, so
itz 1.
.PP
Line 3 is tha flags fo' dis \s-1SV \-\s0 itz \s-1OK\s0 ta use it as a \s-1PV,\s0 itz a
read-only \s-1SV \s0(because itz a cold-ass lil constant) n' tha data be a \s-1PV\s0 internally.
Next we've gots tha contentz of tha string, startin at location
\&\f(CW0xa0484e0\fR.
.PP
Line 5 gives our asses tha current length of tha strang \- note dat dis do
\&\fBnot\fR include tha null terminator. Shiiit, dis aint no joke. Line 6 aint tha length of the
strin yo, but tha length of tha currently allocated buffer; as tha string
grows, Perl automatically extendz tha available storage via a routine
called \f(CW\*(C`SvGROW\*(C'\fR.
.PP
Yo ass can git at any of these quantitizzles from C straight-up easily; just add
\&\f(CW\*(C`Sv\*(C'\fR ta tha name of tha field shown up in tha snippet, n' you've gots a
macro which will return tha value: \f(CW\*(C`SvCUR(sv)\*(C'\fR returns tha current
length of tha string, \f(CW\*(C`SvREFCOUNT(sv)\*(C'\fR returns tha reference count,
\&\f(CW\*(C`SvPV(sv, len)\*(C'\fR returns tha strang itself wit its length, n' so on.
Mo' macros ta manipulate these propertizzles can be found up in perlguts.
.PP
Letz take a example of manipulatin a \s-1PV,\s0 from \f(CW\*(C`sv_catpvn\*(C'\fR, in
\&\fIsv.c\fR
.PP
.Vb 5
\&     1  void
\&     2  Perl_sv_catpvn(pTHX_ SV *sv, const char *ptr, STRLEN len)
\&     3  {
\&     4      STRLEN tlen;
\&     5      char *junk;
\&
\&     6      junk = SvPV_force(sv, tlen);
\&     7      SvGROW(sv, tlen + len + 1);
\&     8      if (ptr == junk)
\&     9          ptr = SvPVX(sv);
\&    10      Move(ptr,SvPVX(sv)+tlen,len,char);
\&    11      SvCUR(sv) += len;
\&    12      *SvEND(sv) = \*(Aq\e0\*(Aq;
\&    13      (void)SvPOK_only_UTF8(sv);          /* validate pointa */
\&    14      SvTAINT(sv);
\&    15  }
.Ve
.PP
This be a gangbangin' function which addz a string, \f(CW\*(C`ptr\*(C'\fR, of length \f(CW\*(C`len\*(C'\fR onto
the end of tha \s-1PV\s0 stored up in \f(CW\*(C`sv\*(C'\fR. Da first thang our phat asses do up in line 6 is
make shizzle dat tha \s-1SV \s0\fBhas\fR a valid \s-1PV,\s0 by callin tha \f(CW\*(C`SvPV_force\*(C'\fR
macro ta force a \s-1PV.\s0 As a side effect, \f(CW\*(C`tlen\*(C'\fR gets set ta tha current
value of tha \s-1PV,\s0 n' tha \s-1PV\s0 itself is moonwalked back ta \f(CW\*(C`junk\*(C'\fR.
.PP
In line 7, we make shizzle dat tha \s-1SV\s0 gonna git enough room to
accommodate tha oldschool string, tha freshly smoked up strang n' tha null terminator. Shiiit, dis aint no joke. If
\&\f(CW\*(C`LEN\*(C'\fR aint big-ass enough, \f(CW\*(C`SvGROW\*(C'\fR will reallocate space fo' us.
.PP
Now, if \f(CW\*(C`junk\*(C'\fR is tha same ol' dirty as tha strang we tryin ta add, we can
grab tha strang directly from tha \s-1SV\s0; \f(CW\*(C`SvPVX\*(C'\fR is tha address of tha \s-1PV\s0
in tha \s-1SV.\s0
.PP
Line 10 do tha actual catenation: tha \f(CW\*(C`Move\*(C'\fR macro moves a cold-ass lil chunk of
memory around: we move tha strang \f(CW\*(C`ptr\*(C'\fR ta tha end of tha \s-1PV \-\s0 that's
the start of tha \s-1PV\s0 plus its current length. We movin \f(CW\*(C`len\*(C'\fR bytes
of type \f(CW\*(C`char\*(C'\fR fo' realz. Afta bustin so, we need ta tell Perl we've extended
the string, by alterin \f(CW\*(C`CUR\*(C'\fR ta reflect tha freshly smoked up length. \f(CW\*(C`SvEND\*(C'\fR be a
macro which gives our asses tha end of tha string, so dat need ta be a
\&\f(CW"\e0"\fR.
.PP
Line 13 manipulates tha flags; since we've chizzled tha \s-1PV,\s0 any \s-1IV\s0 or \s-1NV\s0
values will no longer be valid: if our crazy asses have \f(CW\*(C`$a=10; $a.="6";\*(C'\fR our phat asses don't
wanna use tha oldschool \s-1IV\s0 of 10. \f(CW\*(C`SvPOK_only_utf8\*(C'\fR be a special
UTF\-8\-aware version of \f(CW\*(C`SvPOK_only\*(C'\fR, a macro which turns off tha \s-1IOK\s0
and \s-1NOK\s0 flags n' turns on \s-1POK.\s0 Da final \f(CW\*(C`SvTAINT\*(C'\fR be a macro which
laundaz tainted data if taint mode is turned on.
.PP
AVs n' HVs is mo' fucked up yo, but SVs is by far da most thugged-out common
variable type bein thrown around. Y'all KNOW dat shit, muthafucka! Havin peeped suttin' of how tha fuck we
manipulate these, letz go on n' peep how tha fuck tha op tree is
constructed.
.SH "OP TREES"
.IX Header "OP TREES"
First, what tha fuck is tha op tree, anyway, biatch? Da op tree is tha parsed
representation of yo' program, as we saw up in our section on parsing,
and itz tha sequence of operations dat Perl goes all up in ta execute
your program, as we saw up in \*(L"Running\*(R".
.PP
An op be a gangbangin' fundamenstrual operation dat Perl can perform: all the
built-in functions n' operators is ops, n' there be a seriez of ops
which deal wit concepts tha interpreta needz internally \- entering
and leavin a funky-ass block, endin a statement, fetchin a variable, n' so
on.
.PP
Da op tree is connected up in two ways: you can imagine dat there are
two \*(L"routes\*(R" all up in it, two ordaz up in which you can traverse tha tree.
First, parse order reflects how tha fuck tha parser understood tha code, and
secondly, execution order  drops some lyrics ta perl what tha fuck order ta big-ass up the
operations in.
.PP
Da easiest way ta examine tha op tree is ta stop Perl afta it has
finished parsing, n' git it ta dump up tha tree. This is exactly what
the compila backendz B::Terse, B::Concise
and B::Debug do.
.PP
Letz gotz a peep how tha fuck Perl sees \f(CW\*(C`$a = $b + $c\*(C'\fR:
.PP
.Vb 12
\&     % perl \-MO=Terse \-e \*(Aq$a=$b+$c\*(Aq
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
\&     4      BINOP (0x8179828) sassign
\&     5          BINOP (0x8179800) add [1]
\&     6              UNOP (0x81796e0) null [15]
\&     7                  SVOP (0x80fafe0) gvsv  GV (0x80fa4cc) *b
\&     8              UNOP (0x81797e0) null [15]
\&     9                  SVOP (0x8179700) gvsv  GV (0x80efeb0) *c
\&    10          UNOP (0x816b4f0) null [15]
\&    11              SVOP (0x816dcf0) gvsv  GV (0x80fa460) *a
.Ve
.PP
Letz start up in tha middle, at line 4. This be a \s-1BINOP,\s0 a funky-ass binary
operator, which be at location \f(CW0x8179828\fR. Da specific operator in
question is \f(CW\*(C`sassign\*(C'\fR \- scalar assignment \- n' you can find tha code
which implements it up in tha function \f(CW\*(C`pp_sassign\*(C'\fR up in \fIpp_hot.c\fR fo' realz. As a
binary operator, it has two children: tha add operator, providin the
result of \f(CW\*(C`$b+$c\*(C'\fR, is uppermost on line 5, n' tha left hand side is
on line 10.
.PP
Line 10 is tha null op: dis do exactly nothing. What tha fuck iz dat bustin
there, biatch? If you peep tha null op, itz a sign dat suttin' has been
optimized away afta parsin fo' realz. As we mentioned up in \*(L"Optimization\*(R", the
optimization stage sometimes converts two operations tha fuck into one, for
example when fetchin a scalar variable. When dis happens, instead of
rewritin tha op tree n' cleanin up tha danglin pointers, it's
easier just ta replace tha redundant operation wit tha null op.
Originally, tha tree would have looked like this:
.PP
.Vb 2
\&    10          SVOP (0x816b4f0) rv2sv [15]
\&    11              SVOP (0x816dcf0) gv  GV (0x80fa460) *a
.Ve
.PP
That is, fetch tha \f(CW\*(C`a\*(C'\fR entry from tha main symbol table, n' then look
at tha scalar component of it: \f(CW\*(C`gvsv\*(C'\fR (\f(CW\*(C`pp_gvsv\*(C'\fR tha fuck into \fIpp_hot.c\fR)
happens ta do both these thangs.
.PP
Da right hand side, startin at line 5 is similar ta what tha fuck we've just
seen: our crazy asses have tha \f(CW\*(C`add\*(C'\fR op (\f(CW\*(C`pp_add\*(C'\fR also up in \fIpp_hot.c\fR) add
together two \f(CW\*(C`gvsv\*(C'\fRs.
.PP
Now, whatz dis about?
.PP
.Vb 3
\&     1  LISTOP (0x8179888) leave
\&     2      OP (0x81798b0) enter
\&     3      COP (0x8179850) nextstate
.Ve
.PP
\&\f(CW\*(C`enter\*(C'\fR n' \f(CW\*(C`leave\*(C'\fR is scopin ops, n' they thang is ta big-ass up any
housekeepin every last muthafuckin time you enta n' leave a funky-ass block: lexical variables
are tidied up, unreferenced variablez is destroyed, n' so on. I aint talkin' bout chicken n' gravy biatch. Every
program gonna git dem first three lines: \f(CW\*(C`leave\*(C'\fR be a list, n' its
lil pimps is all tha statements up in tha block. Right back up in yo muthafuckin ass. Statements is delimited
by \f(CW\*(C`nextstate\*(C'\fR, so a funky-ass block be a cold-ass lil collection of \f(CW\*(C`nextstate\*(C'\fR ops, with
the ops ta be performed fo' each statement bein tha lil pimps of
\&\f(CW\*(C`nextstate\*(C'\fR. \f(CW\*(C`enter\*(C'\fR be a single op which functions as a marker.
.PP
Thatz how tha fuck Perl parsed tha program, from top ta bottom:
.PP
.Vb 10
\&                        Program
\&                           |
\&                       Statement
\&                           |
\&                           =
\&                          / \e
\&                         /   \e
\&                        $a   +
\&                            / \e
\&                          $b   $c
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat itz impossible ta \fBperform\fR tha operations up in dis order:
you gotta find tha jointz of \f(CW$b\fR n' \f(CW$c\fR before you add them
together, fo' instance. Right back up in yo muthafuckin ass. So, tha other thread dat runs all up in tha op
tree is tha execution order: each op has a gangbangin' field \f(CW\*(C`op_next\*(C'\fR which
points ta tha next op ta be run, so followin these pointas  drops some lyrics ta us
how perl executes tha code. We can traverse tha tree up in dis order
usin tha \f(CW\*(C`exec\*(C'\fR option ta \f(CW\*(C`B::Terse\*(C'\fR:
.PP
.Vb 9
\&     % perl \-MO=Terse,exec \-e \*(Aq$a=$b+$c\*(Aq
\&     1  OP (0x8179928) enter
\&     2  COP (0x81798c8) nextstate
\&     3  SVOP (0x81796c8) gvsv  GV (0x80fa4d4) *b
\&     4  SVOP (0x8179798) gvsv  GV (0x80efeb0) *c
\&     5  BINOP (0x8179878) add [1]
\&     6  SVOP (0x816dd38) gvsv  GV (0x80fa468) *a
\&     7  BINOP (0x81798a0) sassign
\&     8  LISTOP (0x8179900) leave
.Ve
.PP
This probably make mo' sense fo' a human: enta a funky-ass block, start a
statement. Git tha jointz of \f(CW$b\fR n' \f(CW$c\fR, n' add dem together.
Find \f(CW$a\fR, n' assign one ta tha other n' shit. Then muthafuckin bounce.
.PP
Da way Perl buildz up these op trees up in tha parsin process can be
unravelled by examinin \fIperly.y\fR, tha \s-1YACC\s0 grammar. Shiiit, dis aint no joke. Letz take the
piece we need ta construct tha tree fo' \f(CW\*(C`$a = $b + $c\*(C'\fR
.PP
.Vb 4
\&    1 term    :   term ASSIGNOP term
\&    2                { $$ = newASSIGNOP(OPf_STACKED, $1, $2, $3); }
\&    3         |   term ADDOP term
\&    4                { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
If you not used ta readin \s-1BNF\s0 grammars, dis is how tha fuck it works:
Yo ass is fed certain thangs by tha tokeniser, which generally end up in
upper case yo. Here, \f(CW\*(C`ADDOP\*(C'\fR, is provided when tha tokeniser sees \f(CW\*(C`+\*(C'\fR in
your code. \f(CW\*(C`ASSIGNOP\*(C'\fR is provided when \f(CW\*(C`=\*(C'\fR is used fo' assigning.
These is \*(L"terminal symbols\*(R", cuz you can't git any simpla than
them.
.PP
Da grammar, lines one n' three of tha snippet above,  drops some lyrics ta you how tha fuck to
build up mo' complex forms. These complex forms, \*(L"non-terminal
symbols\*(R" is generally placed up in lower case. \f(CW\*(C`term\*(C'\fR here be a
non-terminal symbol, representin a single expression.
.PP
Da grammar gives you tha followin rule: you can make tha thang on the
left of tha colon if you peep all tha thangs on tha right up in sequence.
This is called a \*(L"reduction\*(R", n' tha aim of parsin is ta straight-up
reduce tha input. There is nuff muthafuckin different ways you can big-ass up a
reduction, separated by vertical bars: so, \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`=\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR cook up a \f(CW\*(C`term\*(C'\fR, n' \f(CW\*(C`term\*(C'\fR followed by \f(CW\*(C`+\*(C'\fR
followed by \f(CW\*(C`term\*(C'\fR can also cook up a \f(CW\*(C`term\*(C'\fR.
.PP
So, if you peep two terms wit a \f(CW\*(C`=\*(C'\fR or \f(CW\*(C`+\*(C'\fR, between them, you can
turn dem tha fuck into a single expression. I aint talkin' bout chicken n' gravy biatch. When you do this, you execute the
code up in tha block on tha next line: if you peep \f(CW\*(C`=\*(C'\fR, you gonna do tha code
in line 2. If you peep \f(CW\*(C`+\*(C'\fR, you gonna do tha code up in line 4. It aint nuthin but this
code which contributes ta tha op tree.
.PP
.Vb 2
\&            |   term ADDOP term
\&            { $$ = newBINOP($2, 0, scalar($1), scalar($3)); }
.Ve
.PP
What dis do is creates a freshly smoked up binary op, n' feedz it a number of
variables. Da variablez refer ta tha tokens: \f(CW$1\fR is tha straight-up original gangsta token
in tha input, \f(CW$2\fR tha second, n' so on \- be thinkin regular expression
backreferences. \f(CW$$\fR is tha op returned from dis reduction. I aint talkin' bout chicken n' gravy biatch. Right back up in yo muthafuckin ass. So, we
call \f(CW\*(C`newBINOP\*(C'\fR ta create a freshly smoked up binary operator. Shiiit, dis aint no joke. Da first parameter
to \f(CW\*(C`newBINOP\*(C'\fR, a gangbangin' function up in \fIop.c\fR, is tha op type. It aint nuthin but a addition
operator, so we want tha type ta be \f(CW\*(C`ADDOP\*(C'\fR. We could specify this
directly yo, but itz right there as tha second token up in tha input, so we
use \f(CW$2\fR. Da second parameta is tha opz flags: 0 means \*(L"nothing
special\*(R". Then tha thangs ta add: tha left n' right hand side of our
expression, up in scalar context.
.SH "STACKS"
.IX Header "STACKS"
When perl executes suttin' like \f(CW\*(C`addop\*(C'\fR, how tha fuck do it pass on its
results ta tha next op, biatch? Da answer is, all up in tha use of stacks. Perl
has a fuckin shitload of stacks ta store thangs itz currently hustlin on, and
we'll peep tha three most blingin ones here.
.SS "Argument stack"
.IX Subsection "Argument stack"
Arguments is passed ta \s-1PP\s0 code n' returned from \s-1PP\s0 code rockin the
argument stack, \f(CW\*(C`ST\*(C'\fR. Da typical way ta handle arguments is ta pop
them off tha stack, deal wit dem how tha fuck you wish, n' then push the
result back onto tha stack. This is how, fo' instance, tha cosine
operator works:
.PP
.Vb 4
\&      NV value;
\&      value = POPn;
\&      value = Perl_cos(value);
\&      XPUSHn(value);
.Ve
.PP
We bout ta peep a mo' tricky example of dis when we consider Perlz macros
below. \f(CW\*(C`POPn\*(C'\fR gives you tha \s-1NV \s0(floatin point value) of tha top \s-1SV\s0 on
the stack: tha \f(CW$x\fR up in \f(CW\*(C`cos($x)\*(C'\fR. Then we compute tha cosine, and
push tha result back as a \s-1NV.\s0 Da \f(CW\*(C`X\*(C'\fR up in \f(CW\*(C`XPUSHn\*(C'\fR means dat the
stack should be extended if necessary \- it can't be necessary here,
because we know there be a room fo' one mo' item on tha stack, since
we've just removed one biaaatch! Da \f(CW\*(C`XPUSH*\*(C'\fR macros at least guarantee safety.
.PP
Alternatively, you can fiddle wit tha stack directly: \f(CW\*(C`SP\*(C'\fR gives you
the first element up in yo' portion of tha stack, n' \f(CW\*(C`TOP*\*(C'\fR gives you
the top SV/IV/NV/etc. on tha stack. Right back up in yo muthafuckin ass. So, fo' instance, ta do unary
negation of a integer:
.PP
.Vb 1
\&     SETi(\-TOPi);
.Ve
.PP
Just set tha integer value of tha top stack entry ta its negation.
.PP
Argument stack manipulation up in tha core is exactly tha same as it is in
XSUBs \- peep perlxstut, perlxs n' perlguts fo' a longer
description of tha macros used up in stack manipulation.
.SS "Mark stack"
.IX Subsection "Mark stack"
I say \*(L"your portion of tha stack\*(R" above cuz \s-1PP\s0 code don't
necessarily git tha whole stack ta itself: if yo' function calls
another function, you gonna only wanna expose tha arguments aimed for
the called function, n' not (necessarily) let it git at yo' own data.
Da way our phat asses do dis is ta git a \*(L"virtual\*(R" bottom-of-stack, exposed to
each function. I aint talkin' bout chicken n' gravy biatch. Da mark stack keeps bookmarks ta locations up in the
argument stack usable by each function. I aint talkin' bout chicken n' gravy biatch. For instance, when dealin with
a tied variable, (internally, suttin' wit \*(L"P\*(R" magic) Perl has to
call methodz fo' accesses ta tha tied variables. But fuck dat shiznit yo, tha word on tha street is dat we need to
separate tha arguments exposed ta tha method ta tha argument exposed to
the original gangsta function \- tha store or fetch or whatever it may be.
Herez roughly how tha fuck tha tied \f(CW\*(C`push\*(C'\fR is implemented; peep \f(CW\*(C`av_push\*(C'\fR in
\&\fIav.c\fR:
.PP
.Vb 8
\&     1  PUSHMARK(SP);
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
\&     5  PUTBACK;
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
Letz examine tha whole implementation, fo' practice:
.PP
.Vb 1
\&     1  PUSHMARK(SP);
.Ve
.PP
Push tha current state of tha stack pointa onto tha mark stack. This
is so dat when we've finished addin shit ta tha argument stack, Perl
knows how tha fuck nuff thangs we've added recently.
.PP
.Vb 3
\&     2  EXTEND(SP,2);
\&     3  PUSHs(SvTIED_obj((SV*)av, mg));
\&     4  PUSHs(val);
.Ve
.PP
We goin ta add two mo' shit onto tha argument stack: when you
have a tied array, tha \f(CW\*(C`PUSH\*(C'\fR subroutine receives tha object n' the
value ta be pushed, n' thatz exactly what tha fuck our crazy asses have here \- tha tied
object, retrieved wit \f(CW\*(C`SvTIED_obj\*(C'\fR, n' tha value, tha \s-1SV \s0\f(CW\*(C`val\*(C'\fR.
.PP
.Vb 1
\&     5  PUTBACK;
.Ve
.PP
Next we tell Perl ta update tha global stack pointa from our internal
variable: \f(CW\*(C`dSP\*(C'\fR only gave our asses a local copy, not a reference ta the
global.
.PP
.Vb 3
\&     6  ENTER;
\&     7  call_method("PUSH", G_SCALAR|G_DISCARD);
\&     8  LEAVE;
.Ve
.PP
\&\f(CW\*(C`ENTER\*(C'\fR n' \f(CW\*(C`LEAVE\*(C'\fR localise a funky-ass block of code \- they make shizzle that
all variablez is tidied up, every last muthafuckin thang dat has been localised gets
its previous value returned, n' so on. I aint talkin' bout chicken n' gravy biatch. Think of dem as tha \f(CW\*(C`{\*(C'\fR and
\&\f(CW\*(C`}\*(C'\fR of a Perl block.
.PP
To straight-up do tha magic method call, we gotta call a subroutine in
Perl space: \f(CW\*(C`call_method\*(C'\fR takes care of that, n' itz busted lyrics bout in
perlcall. We call tha \f(CW\*(C`PUSH\*(C'\fR method up in scalar context, n' we're
goin ta discard its return value. Da \fIcall_method()\fR function removes
the top element of tha mark stack, so there is not a god damn thang fo' tha caller
to clean up.
.SS "Save stack"
.IX Subsection "Save stack"
C aint gots a cold-ass lil concept of local scope, so perl serves up one. We've
seen dat \f(CW\*(C`ENTER\*(C'\fR n' \f(CW\*(C`LEAVE\*(C'\fR is used as scopin braces; tha save
stack implements tha C equivalent of, fo' example:
.PP
.Vb 4
\&    {
\&        local $foo = 42;
\&        ...
\&    }
.Ve
.PP
See \*(L"Localizin chizzles\*(R" up in perlguts fo' how tha fuck ta use tha save stack.
.SH "MILLIONS OF MACROS"
.IX Header "MILLIONS OF MACROS"
One thang you gonna notice bout tha Perl source is dat itz full of
macros. Right back up in yo muthafuckin ass. Some have called tha pervasive use of macros tha hardest thang
to understand, others find it addz ta clarity. Letz take a example,
the code which implements tha addizzle operator:
.PP
.Vb 9
\&   1  PP(pp_add)
\&   2  {
\&   3      dSP; dATARGET; tryAMAGICbin(add,opASSIGN);
\&   4      {
\&   5        dPOPTOPnnrl_ul;
\&   6        SETn( left + right );
\&   7        RETURN;
\&   8      }
\&   9  }
.Ve
.PP
Every line here (apart from tha braces, of course) gotz nuff a macro.
Da first line sets up tha function declaration as Perl expects fo' \s-1PP\s0
code; line 3 sets up variable declarations fo' tha argument stack and
the target, tha return value of tha operation. I aint talkin' bout chicken n' gravy biatch. Finally, it tries ta see
if tha addizzle operation is overloaded; if so, tha appropriate
subroutine is called.
.PP
Line 5 be another variable declaration \- all variable declarations
start wit \f(CW\*(C`d\*(C'\fR \- which pops from tha top of tha argument stack two NVs
(hence \f(CW\*(C`nn\*(C'\fR) n' puts dem tha fuck into tha variablez \f(CW\*(C`right\*(C'\fR n' \f(CW\*(C`left\*(C'\fR,
hence tha \f(CW\*(C`rl\*(C'\fR. These is tha two operandz ta tha addizzle operator.
Next, we call \f(CW\*(C`SETn\*(C'\fR ta set tha \s-1NV\s0 of tha return value ta tha result
of addin tha two joints, n' you can put dat on yo' toast. This done, we return \- tha \f(CW\*(C`RETURN\*(C'\fR macro
makes shizzle dat our return value is properly handled, n' we pass the
next operator ta run back ta tha main run loop.
.PP
Most of these macros is explained up in perlapi, n' a shitload of tha more
important ones is explained up in perlxs as well. Pay special
attention ta \*(L"Background n' \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 up in perlguts for
information on tha \f(CW\*(C`[pad]THX_?\*(C'\fR macros.
.SH "FURTHER READING"
.IX Header "FURTHER READING"
For mo' shiznit on tha Perl internals, please peep tha documents
listed at \*(L"Internals n' C Language Interface\*(R" up in perl.
