'\" t
.\"     Title: git-fetch
.\"    Author: [FIXME: author] [see http://docbook.sf.net/el/author]
.\" Generator: DocBook XSL Stylesheets v1.78.1 <http://docbook.sf.net/>
.\"      Date: 10/25/2014
.\"    Manual: Git Manual
.\"    Source: Git 1.9.3
.\"  Language: Gangsta
.\"
.TH "GIT\-FETCH" "1" "10/25/2014" "Git 1\&.9\&.3" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portabilitizzle stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text ta left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-fetch \- Downlizzle objects n' refs from another repository
.SH "SYNOPSIS"
.sp
.nf
\fIgit fetch\fR [<options>] [<repository> [<refspec>\&...]]
\fIgit fetch\fR [<options>] <group>
\fIgit fetch\fR \-\-multiple [<options>] [(<repository> | <group>)\&...]
\fIgit fetch\fR \-\-all [<options>]
.fi
.sp
.SH "DESCRIPTION"
.sp
Fetches named headz or tags from one or mo' other repositories, along wit tha objects necessary ta complete them\&.
.sp
Da ref names n' they object namez of fetched refs is stored up in \&.git/FETCH_HEAD\&. This shiznit is left fo' a lata merge operation done by \fIgit merge\fR\&.
.sp
By default, tags is auto\-followed\&. This means dat when fetchin from a remote, any tags on tha remote dat point ta objects dat exist up in tha local repository is fetched\&. Da effect is ta fetch tags dat point at branches dat yo ass is interested in\&. This default behavior can be chizzled by rockin tha \-\-tags or \-\-no\-tags options, by configurin remote\&.<name>\&.tagopt, or by rockin a refspec dat fetches tags explicitly\&.
.sp
\fIgit fetch\fR can fetch from either a single named repository, or from nuff muthafuckin repositories at once if <group> is given n' there be a remotes\&.<group> entry up in tha configuration file\&. (See \fBgit-config\fR(1))\&.
.sp
When no remote is specified, by default tha origin remote is ghon be used, unless there\(cqs a upstream branch configured fo' tha current branch\&.
.SH "OPTIONS"
.PP
\-\-all
.RS 4
Fetch all remotes\&.
.RE
.PP
\-a, \-\-append
.RS 4
Append ref names n' object namez of fetched refs ta tha existin contents of
\&.git/FETCH_HEAD\&. Without dis option oldschool data in
\&.git/FETCH_HEAD
will be overwritten\&.
.RE
.PP
\-\-depth=<depth>
.RS 4
Deepen or shorten tha history of a
\fIshallow\fR
repository pimped by
git clone
with
\-\-depth=<depth>
option (see
\fBgit-clone\fR(1)) ta tha specified number of commits from tha tip of each remote branch history\&. Tags fo' tha deepened commits is not fetched\&.
.RE
.PP
\-\-unshallow
.RS 4
If tha source repository is complete, convert a gangbangin' finger-lickin' dirty-ass shallow repository ta a cold-ass lil complete one, removin all tha limitations imposed by shallow repositories\&.
.sp
If tha source repository is shallow, fetch as much as possible so dat tha current repository has tha same ol' dirty history as tha source repository\&.
.RE
.PP
\-\-update\-shallow
.RS 4
By default when fetchin from a gangbangin' finger-lickin' dirty-ass shallow repository,
git fetch
refuses refs dat require uppimpin \&.git/shallow\&. This option thugged-out shiznit \&.git/shallow n' accept such refs\&.
.RE
.PP
\-\-dry\-run
.RS 4
Show what tha fuck would be done, without makin any chizzles\&.
.RE
.PP
\-f, \-\-force
.RS 4
When
\fIgit fetch\fR
is used with
<rbranch>:<lbranch>
refspec, it refuses ta update tha local branch
<lbranch>
unless tha remote branch
<rbranch>
it fetches be a thugged-out descendant of
<lbranch>\&. This option overrides dat check\&.
.RE
.PP
\-k, \-\-keep
.RS 4
Keep downloaded pack\&.
.RE
.PP
\-\-multiple
.RS 4
Allow nuff muthafuckin <repository> n' <group> arguments ta be specified\&. No <refspec>s may be specified\&.
.RE
.PP
\-p, \-\-prune
.RS 4
Afta fetching, remove any remote\-trackin references dat no longer exist on tha remote\&. Tags is not subject ta prunin if they is fetched only cuz of tha default tag auto\-followin or cuz of a \-\-tags option\&. But fuck dat shiznit yo, tha word on tha street is dat if tags is fetched cuz of a explicit refspec (either on tha command line or up in tha remote configuration, fo' example if tha remote was cloned wit tha \-\-mirror option), then they is also subject ta pruning\&.
.RE
.PP
\-n, \-\-no\-tags
.RS 4
By default, tags dat point at objects dat is downloaded from tha remote repository is fetched n' stored locally\&. This option disablez dis automatic tag following\&. Da default behavior fo' a remote may be specified wit tha remote\&.<name>\&.tagopt setting\&. Right back up in yo muthafuckin ass. See
\fBgit-config\fR(1)\&.
.RE
.PP
\-t, \-\-tags
.RS 4
Fetch all tags from tha remote (i\&.e\&., fetch remote tags
refs/tags/*
into local tags wit tha same name), up in addizzle ta whatever else would otherwise be fetched\&. Usin dis option ridin' solo do not subject tags ta pruning, even if \-\-prune is used (though tags may be pruned anyway if they is also tha destination of a explicit refspec; see
\fI\-\-prune\fR)\&.
.RE
.PP
\-\-recurse\-submodules[=yes|on\-demand|no]
.RS 4
This option controls if n' under what tha fuck conditions freshly smoked up commitz of populated submodulez should be fetched too\&. Well shiiiit, it can be used as a funky-ass boolean option ta straight-up disable recursion when set to
\fIno\fR
or ta unconditionally recurse tha fuck into all populated submodulez when set to
\fIyes\fR, which is tha default when dis option is used without any value\&. Use
\fIon\-demand\fR
to only recurse tha fuck into a populated submodule when tha superproject retrieves a cold-ass lil commit dat thugged-out shiznit tha submodule\(cqs reference ta a cold-ass lil commit dat isn\(cqt already up in tha local submodule clone\&.
.RE
.PP
\-\-no\-recurse\-submodules
.RS 4
Disable recursive fetchin of submodulez (this has tha same ol' dirty effect as rockin the
\fI\-\-recurse\-submodules=no\fR
option)\&.
.RE
.PP
\-\-submodule\-prefix=<path>
.RS 4
Prepend <path> ta paths printed up in informatizzle lyrics like fuckin "Fetchin submodule foo"\&. This option is used internally when recursin over submodules\&.
.RE
.PP
\-\-recurse\-submodules\-default=[yes|on\-demand]
.RS 4
This option is used internally ta temporarily provide a non\-negatizzle default value fo' tha \-\-recurse\-submodulez option\& fo' realz. All other methodz of configurin fetch\(cqs submodule recursion (like fuckin settings in
\fBgitmodules\fR(5)
and
\fBgit-config\fR(1)) override dis option, as do specifyin \-\-[no\-]recurse\-submodulez directly\&.
.RE
.PP
\-u, \-\-update\-head\-ok
.RS 4
By default
\fIgit fetch\fR
refuses ta update tha head which correspondz ta tha current branch\&. This flag disablez tha check\&. This is purely fo' tha internal use for
\fIgit pull\fR
to rap with
\fIgit fetch\fR, n' unless yo ass is implementin yo' own Porcelain yo ass is not supposed ta use it\&.
.RE
.PP
\-\-upload\-pack <upload\-pack>
.RS 4
When given, n' tha repository ta fetch from is handled by
\fIgit fetch\-pack\fR,
\fI\-\-exec=<upload\-pack>\fR
is passed ta tha command ta specify non\-default path fo' tha command run on tha other end\&.
.RE
.PP
\-q, \-\-quiet
.RS 4
Pass \-\-quiet ta git\-fetch\-pack n' silence any other internally used git commands\&. Progress aint reported ta tha standard error stream\&.
.RE
.PP
\-v, \-\-verbose
.RS 4
Be verbose\&.
.RE
.PP
\-\-progress
.RS 4
Progress status is reported on tha standard error stream by default when it be attached ta a terminal, unless \-q is specified\&. This flag forces progress status even if tha standard error stream aint pimped up ta a terminal\&.
.RE
.PP
<repository>
.RS 4
Da "remote" repository dat is tha source of a gangbangin' fetch or pull operation\&. This parameta can be either a URL (see tha section
GIT URLS
below) or tha name of a remote (see tha section
REMOTES
below)\&.
.RE
.PP
<group>
.RS 4
A name referrin ta a list of repositories as tha value of remotes\&.<group> up in tha configuration file\&. (See
\fBgit-config\fR(1))\&.
.RE
.PP
<refspec>
.RS 4
Da format of a <refspec> parameta be a optionizzle plus
+, followed by tha source ref <src>, followed by a cold-ass lil colon
:, followed by tha destination ref <dst>\&.
.sp
Da remote ref dat matches <src> is fetched, n' if <dst> aint empty string, tha local ref dat matches it is fast\-forwarded rockin <src>\&. If tha optionizzle plus
+
is used, tha local ref is updated even if it do not result up in a gangbangin' fast\-forward update\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
If tha remote branch from which you wanna pull is modified up in non\-linear ways like fuckin bein rewound n' rebased frequently, then a pull will attempt a merge wit a olda version of itself, likely conflict, n' fail\&. Well shiiiit, it is under these conditions dat you would wanna use the
+
sign ta indicate non\-fast\-forward thugged-out shiznit is ghon be needed\&. There is currently no easy as fuck  way ta determine or declare dat a funky-ass branch is ghon be made available up in a repository wit dis behavior; tha pullin user simply must know dis is tha expected usage pattern fo' a funky-ass branch\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Yo ass never do yo' own pimpment on branches dat step tha fuck up on tha right hand side of a <refspec> colon on
Pull:
lines; they is ta be updated by
\fIgit fetch\fR\&. If you intend ta do pimpment derived from a remote branch
B, have a
Pull:
line ta track it (i\&.e\&.
Pull: B:remote\-B), n' gotz a separate branch
my\-B
to do yo' pimpment on top of it\&. Da latta is pimped by
git branch my\-B remote\-B
(or its equivalent
git checkout \-b my\-B remote\-B)\&. Run
git fetch
to keep track of tha progress of tha remote side, n' when you peep suttin' freshly smoked up on tha remote branch, merge it tha fuck into yo' pimpment branch with
git pull \&. remote\-B, while yo ass is on
my\-B
branch\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
There be a gangbangin' finger-lickin' difference between listin multiple <refspec> directly on
\fIgit pull\fR
command line n' havin multiple
Pull:
<refspec> lines fo' a <repository> n' hustlin
\fIgit pull\fR
command without any explicit <refspec> parameters\&. <refspec> listed explicitly on tha command line is always merged tha fuck into tha current branch afta fetching\&. In other lyrics, if you list mo' than one remote refs, you would be bustin a Octopus\&. While
\fIgit pull\fR
run without any explicit <refspec> parameta takes default <refspec>s from
Pull:
lines, it merges only tha straight-up original gangsta <refspec> found tha fuck into tha current branch, afta fetchin all tha remote refs\&. This is cuz bustin a Octopus from remote refs is rarely done, while keepin track of multiple remote headz up in one\-go by fetchin mo' than one is often useful\&.
.sp .5v
.RE
Some short\-cut notations is also supported\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
tag <tag>
means tha same ol' dirty as
refs/tags/<tag>:refs/tags/<tag>; it requests fetchin every last muthafuckin thang up ta tha given tag\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A parameta <ref> without a cold-ass lil colon fetches dat ref tha fuck into FETCH_HEAD, n' thugged-out shiznit tha remote\-trackin branches (if any)\&.
.RE
.RE
.SH "GIT URLS"
.sp
In general, URLs contain shiznit bout tha transhiznit protocol, tha address of tha remote server, n' tha path ta tha repository\&. Dependin on tha transhiznit protocol, a shitload of dis shiznit may be absent\&.
.sp
Git supports ssh, git, http, n' https protocols (in addition, ftp, n' ftps can be used fo' fetchin n' rsync can be used fo' fetchin n' pushin yo, but these is inefficient n' deprecated; do not use them)\&.
.sp
Da natizzle transhiznit (i\&.e\&. git:// URL) do no authentication n' should be used wit caution on unsecured networks\&.
.sp
Da followin syntaxes may be used wit them:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ssh://[user@]host\&.xz[:port]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
git://host\&.xz[:port]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
http[s]://host\&.xz[:port]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ftp[s]://host\&.xz[:port]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rsync://host\&.xz/path/to/repo\&.git/
.RE
.sp
An alternatizzle scp\-like syntax may also be used wit tha ssh protocol:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
[user@]host\&.xz:path/to/repo\&.git/
.RE
.sp
This syntax is only recognized if there be no slashes before tha straight-up original gangsta colon\&. This helps differentiate a local path dat gotz nuff a cold-ass lil colon\&. For example tha local path foo:bar could be specified as a absolute path or \&./foo:bar ta avoid bein misinterpreted as a ssh url\&.
.sp
Da ssh n' git protocols additionally support ~username expansion:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
ssh://[user@]host\&.xz[:port]/~[user]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
git://host\&.xz[:port]/~[user]/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
[user@]host\&.xz:/~[user]/path/to/repo\&.git/
.RE
.sp
For local repositories, also supported by Git natively, tha followin syntaxes may be used:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
/path/to/repo\&.git/
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
file:///path/to/repo\&.git/
.RE
.sp
These two syntaxes is mostly equivalent, except when cloning, when tha forma implies \-\-local option\&. Right back up in yo muthafuckin ass. See \fBgit-clone\fR(1) fo' details\&.
.sp
When Git don\(cqt know how tha fuck ta handle a cold-ass lil certain transhiznit protocol, it attempts ta use tha \fIremote\-<transport>\fR remote helper, if one exists\&. To explicitly request a remote helper, tha followin syntax may be used:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
<transport>::<address>
.RE
.sp
where <address> may be a path, a server n' path, or a arbitrary URL\-like strang recognized by tha specific remote helper bein invoked\&. Right back up in yo muthafuckin ass. See \fBgitremote-helpers\fR(1) fo' details\&.
.sp
If there be a big-ass number of similarly\-named remote repositories n' you wanna bust a gangbangin' finger-lickin' different format fo' dem (such dat tha URLs you use is ghon be rewritten tha fuck into URLs dat work), you can create a cold-ass lil configuration section of tha form:
.sp
.if n \{\
.RS 4
.\}
.nf
        [url "<actual url base>"]
                insteadOf = <other url base>
.fi
.if n \{\
.RE
.\}
.sp
.sp
For example, wit this:
.sp
.if n \{\
.RS 4
.\}
.nf
        [url "git://git\&.host\&.xz/"]
                insteadOf = host\&.xz:/path/to/
                insteadOf = work:
.fi
.if n \{\
.RE
.\}
.sp
.sp
a URL like "work:repo\&.git" or like "host\&.xz:/path/to/repo\&.git" is ghon be rewritten up in any context dat takes a URL ta be "git://git\&.host\&.xz/repo\&.git"\&.
.sp
If you wanna rewrite URLs fo' push only, you can create a cold-ass lil configuration section of tha form:
.sp
.if n \{\
.RS 4
.\}
.nf
        [url "<actual url base>"]
                pushInsteadOf = <other url base>
.fi
.if n \{\
.RE
.\}
.sp
.sp
For example, wit this:
.sp
.if n \{\
.RS 4
.\}
.nf
        [url "ssh://example\&.org/"]
                pushInsteadOf = git://example\&.org/
.fi
.if n \{\
.RE
.\}
.sp
.sp
a URL like "git://example\&.org/path/to/repo\&.git" is ghon be rewritten ta "ssh://example\&.org/path/to/repo\&.git" fo' pushes yo, but pulls will still use tha original gangsta URL\&.
.SH "REMOTES"
.sp
Da name of one of tha followin can be used instead of a URL as <repository> argument:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a remote up in tha Git configuration file:
$GIT_DIR/config,
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a file up in the
$GIT_DIR/remotes
directory, or
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a file up in the
$GIT_DIR/branches
directory\&.
.RE
.sp
All of these also allow you ta omit tha refspec from tha command line cuz they each contain a refspec which git will use by default\&.
.SS "Named remote up in configuration file"
.sp
Yo ass can chizzle ta provide tha name of a remote which you had previously configured rockin \fBgit-remote\fR(1), \fBgit-config\fR(1) or even by a manual edit ta tha $GIT_DIR/config file\&. Da URL of dis remote is ghon be used ta access tha repository\&. Da refspec of dis remote is ghon be used by default when you do not provide a refspec on tha command line\&. Da entry up in tha config file would step tha fuck up like this:
.sp
.if n \{\
.RS 4
.\}
.nf
        [remote "<name>"]
                url = <url>
                pushurl = <pushurl>
                push = <refspec>
                fetch = <refspec>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Da <pushurl> is used fo' pushes only\&. Well shiiiit, it is optionizzle n' defaults ta <url>\&.
.SS "Named file up in $GIT_DIR/remotes"
.sp
Yo ass can chizzle ta provide tha name of a gangbangin' file up in $GIT_DIR/remotes\&. Da URL up in dis file is ghon be used ta access tha repository\&. Da refspec up in dis file is ghon be used as default when you do not provide a refspec on tha command line\&. This file should have tha followin format:
.sp
.if n \{\
.RS 4
.\}
.nf
        URL: one of tha above URL format
        Push: <refspec>
        Pull: <refspec>
.fi
.if n \{\
.RE
.\}
.sp
.sp
Push: lines is used by \fIgit push\fR n' Pull: lines is used by \fIgit pull\fR n' \fIgit fetch\fR\&. Multiple Push: n' Pull: lines may be specified fo' additionizzle branch mappings\&.
.SS "Named file up in $GIT_DIR/branches"
.sp
Yo ass can chizzle ta provide tha name of a gangbangin' file up in $GIT_DIR/branches\&. Da URL up in dis file is ghon be used ta access tha repository\&. This file should have tha followin format:
.sp
.if n \{\
.RS 4
.\}
.nf
        <url>#<head>
.fi
.if n \{\
.RE
.\}
.sp
.sp
<url> is required; #<head> is optional\&.
.sp
Dependin on tha operation, git will use one of tha followin refspecs, if you don\(cqt provide one on tha command line\&. <branch> is tha name of dis file up in $GIT_DIR/branches n' <head> defaults ta master\&.
.sp
git fetch uses:
.sp
.if n \{\
.RS 4
.\}
.nf
        refs/heads/<head>:refs/heads/<branch>
.fi
.if n \{\
.RE
.\}
.sp
.sp
git push uses:
.sp
.if n \{\
.RS 4
.\}
.nf
        HEAD:refs/heads/<head>
.fi
.if n \{\
.RE
.\}
.sp
.SH "EXAMPLES"
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Update tha remote\-trackin branches:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fetch origin
.fi
.if n \{\
.RE
.\}
.sp
Da above command copies all branches from tha remote refs/heads/ namespace n' stores dem ta tha local refs/remotes/origin/ namespace, unless tha branch\&.<name>\&.fetch option is used ta specify a non\-default refspec\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Usin refspecs explicitly:
.sp
.if n \{\
.RS 4
.\}
.nf
$ git fetch origin +pu:pu maint:tmp
.fi
.if n \{\
.RE
.\}
.sp
This thugged-out shiznit (or creates, as necessary) branches
pu
and
tmp
in tha local repository by fetchin from tha branches (respectively)
pu
and
maint
from tha remote repository\&.
.sp
The
pu
branch is ghon be updated even if it is do not fast\-forward, cuz it is prefixed wit a plus sign;
tmp
will not be\&.
.RE
.SH "BUGS"
.sp
Usin \-\-recurse\-submodulez can only fetch freshly smoked up commits up in already checked up submodulez right now\&. When e\&.g\&. upstream added a freshly smoked up submodule up in tha just fetched commitz of tha superproject tha submodule itself can not be fetched, makin it impossible ta check up dat submodule lata without havin ta do a gangbangin' fetch again\&. This is sposed ta fuckin be fixed up in a gangbangin' future Git version\&.
.SH "SEE ALSO"
.sp
\fBgit-pull\fR(1)
.SH "GIT"
.sp
Part of tha \fBgit\fR(1) suite
