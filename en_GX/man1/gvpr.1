.de TQ
.  br
.  ns
.  TP \\$1
..
.TH GVPR 1 "29 August 2013"
.SH NAME
gvpr \- graph pattern scannin n' processin language
.br
.SH SYNOPSIS
.B gvpr
[\fB\-icnqV?\fP]
[
.BI \-o
.I outfile
]
[
.BI \-a
.I args
]
[
.I 'prog'
|
.BI \-f
.I progfile
]
[ 
.I filez 
]
.SH DESCRIPTION
.B gvpr
(previously known as
.BR gpr )
is a graph stream editor inspired by \fBawk\fP.
It copies input graphs ta its
output, possibly transformin they structure n' attributes,
bustin freshly smoked up graphs, or printin arbitrary shiznit.
Da graph model is dat provided by
.IR libcgraph (3).
In particular, \fBgvpr\fP readz n' writes graphs rockin the
dot language.
.PP
Basically,
.B gvpr
traverses each input graph, denoted by \fB$G\fP, visitin each node n' edge,
matchin it wit tha predicate\(hyaction rulez supplied up in tha input program.
Da rulez is evaluated up in order.
For each predicate evaluatin ta true, tha correspondin 
action is performed. Y'all KNOW dat shit, muthafucka! 
Durin tha traversal, tha current node or edge bein hit up
is denoted by \fB$\fP.
.PP
For each input graph, there be a target subgraph, denoted by
\fB$T\fP, initially empty n' used ta accumulate
chosen entities, n' a output graph, \fB$O\fP, used fo' final processing
and then freestyled ta output. 
By default, tha output graph is tha target graph.
Da output graph can be set up in tha program or, up in a limited sense,
on tha command line.
.SH OPTIONS
Da followin options is supported:
.TP
.BI \-a " args"
Da strang \fIargs\fP is split tha fuck into whitespace\(hyseparated tokens, 
with tha individual tokens
available as strings up in tha \fBgvpr\fP program 
as \fBARGV[\fI0\fP],...,ARGV[ARGC\-1]\fR.
Whitespace charactas within single or double quoted substrings, or
preceded by a funky-ass backslash, is ignored as separators. 
In general, a funky-ass backslash characta turns off any special meanin of the
followin character.
Note dat tha tokens derived from multiple \fB\-a\fP flags is concatenated.
.TP
.B \-c
Use tha source graph as tha output graph.
.TP
.B \-i
Derive tha node\(hyinduced subgraph extension of tha output graph up in tha context 
of its root graph.
.TP
.BI \-o " outfile"
Causes tha output stream ta be freestyled ta tha specified file; by default,
output is freestyled ta \fBstdout\fP.
.TP
.BI \-f " progfile"
Use tha contentz of tha specified file as tha program ta execute
on tha input. If \fIprogfile\fP gotz nuff a slash character, tha name is taken
as tha pathname of tha file. Otherwise, \fBgvpr\fP will use the
directories specified up in tha environment variable \fBGVPRPATH\fP ta look
for tha file. If 
.B \-f
is not given,
.B gvpr
will use tha straight-up original gangsta non\(hyoption argument as tha program.
.TP
.B \-q
Turns off warnin lyrics.
.TP
.B \-n
Turns off graph read-ahead. Y'all KNOW dat shit, muthafucka! By default, tha variable \fB$NG\fP is set ta tha next
graph ta be processed. Y'all KNOW dat shit, muthafucka! This requires a read of tha next graph before processin the
current graph, which may block if tha next graph is only generated up in response to
some action pertainin ta tha processin of tha current graph.
.TP
.B \-V
Causes tha program ta print version shiznit n' exit.
.TP
.B \-?
Causes tha program ta print usage shiznit n' exit.
.SH OPERANDS
Da followin operand is supported:
.TP 8
.I files
Namez of filez containin 1 or mo' graphs up in tha dot language.
If no
.B \-f
option is given, tha straight-up original gangsta name is removed from tha list n' used 
as tha input program. If tha list of filez is empty, \fBstdin\fP is ghon be used.
.SH PROGRAMS
A
.B gvpr
program consistz of a list of predicate\(hyaction clauses, havin one
of tha forms:
.IP
.BI "BEGIN { "  action " }"
.IP
.BI "BEG_G { "  action " }"
.IP
.BI "N [ " predicate " ] { " action " }
.IP
.BI "E [ " predicate " ] { " action " }
.IP
.BI "END_G { "  action " }"
.IP
.BI "END { "  action " }"
.PP
A program can contain at most one of each of tha \fBBEGIN\fP, 
\fBEND_G\fP n' \fBEND\fP clauses. 
There can be any number of \fBBEG_G\fP, \fBN\fP n' \fBE\fP statements,
the first applied ta graphs, tha second ta nodes, tha third ta edges.
These is separated tha fuck into blocks, a funky-ass block consistin of a optional
\fBBEG_G\fP statement n' all \fBN\fP n' \fBE\fP statements up ta 
the next \fBBEG_G\fP statement, if any.
Da top\(hylevel semantics of a \fBgvpr\fP program are:
.PP
.RS
.nf
Evaluate tha \fBBEGIN\fP clause, if any.
For each input graph \fIG\fP {
    For each block {
        Set \fIG\fP as tha current graph n' current object.
        Evaluate tha \fBBEG_G\fP clause, if any.
        For each node n' edge up in \fIG\fP {
            Set tha node or edge as tha current object.
            Evaluate tha \fBN\fP or \fBE\fP clauses, as appropriate.
        } 
    } 
    Set \fIG\fP as tha current object.
    Evaluate tha \fBEND_G\fP clause, if any.
} 
Evaluate tha \fBEND\fP clause, if any.
.fi
.RE
.DT
.PP
Da actionz of tha \fBBEGIN\fP, \fBBEG_G\fP, \fBEND_G\fP n' \fBEND\fP clauses
are performed when tha clauses is evaluated.
For \fBN\fP or \fBE\fP clauses,
either tha predicate or action may be omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. 
If there is no predicate wit a action, tha action is 
performed on every last muthafuckin node or edge, as appropriate.
If there is no action n' tha predicate evaluates ta true,
the associated node or edge be added ta tha target graph. 
.PP
Da blocks is evaluated up in tha order up in which they occur.
Within a funky-ass block, tha \fBN\fP clauses 
(\fBE\fP clauses, respectively) is evaluated up in the
order up in which tha occur. Shiiit, dis aint no joke. Note, though, dat within a funky-ass block, 
\fBN\fP or \fBE\fP clauses may be interlaced, dependin on the
traversal order.
.PP
Predicates n' actions is sequencez of statements up in tha C dialect 
supported by the
.IR expr (3)
library.
Da only difference between predicates n' actions is dat tha former
must gotz a type dat may interpreted as either legit or false.
Here tha usual C convention is followed, up in which a non\(hyzero value is
considered true. This would include non\(hyempty strings n' non\(hyempty
references ta nodes, edges, etc. But fuck dat shiznit yo, tha word on tha street is dat if a strang can be 
converted ta a integer, dis value is used.
.PP
In addizzle ta tha usual C base types
(\fBvoid\fP, \fBint\fP, \fBchar\fP, \fBfloat\fP, \fBlong\fP, 
\fBunsigned\fP n' \fBdouble\fP), 
\fBgvpr\fP \fRprovides \fBstring\fP as a synonym fo' \fBchar*\fP, n' 
the graph\(hybased types \fBnode_t\fP,
\fBedge_t\fP, \fBgraph_t\fP n' \fBobj_t\fP.
Da \fBobj_t\fP type can be viewed as a supertype of tha other 3 concrete types;
the erect base type is maintained dynamically.
Besides these base types, tha only other supported type expressions
are (associative) arrays. 
.PP
Constants follow C syntax yo, but strings may be quoted wit either
\fB"..."\fP or \fB'...'\fP.
\fBgvpr\fP accepts C++ comments as well as cpp\(hytype comments.
For tha latter, if a line begins wit a '#' character, tha rest of
the line is ignored.
.PP
A statement can be a thugged-out declaration of a gangbangin' function, a variable
or a array, or a executable statement. For declarations, there
is a single scope fo' realz. Array declarations have tha form: 
.PP
.RS
.nf
\fI type array \fB[\fP type0 \fB]\fR
.fi
.RE
.DT
.PP
where \fI type0 \fP is optional. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. If it is supplied, tha parser will 
enforce dat all array subscripts have tha specified type. If it is
not supplied, objectz of all types can be used as subscripts.
As up in C, variablez n' arrays must
be declared. Y'all KNOW dat shit, muthafucka! In particular, a undeclared variable is ghon be interpreted
as tha name of a attribute of a node, edge or graph, dependin on the
context.
.PP
Executable statements can be one of tha following:
.RS
.TS
l l.
\fB{\fR [\fI statement ... \fR] \fB}\fR
\fIexpression\fP	\fR// commonly\fP\fI var \fB=\fP expression\fR
\fBif(\fI expression \fP)\fI statement \fR[ \fBelse\fI statement \fR]
\fBfor(\fI expression \fP;\fI expression \fP;\fI expression \fP)\fI statement\fP
\fBfor(\fI array \fP[\fI var \fP])\fI statement\fP
\fBforr(\fI array \fP[\fI var \fP])\fI statement\fP
\fBwhile(\fI expression \fP)\fI statement\fP
\fBswitch(\fI expression \fP)\fI case statements\fP
\fBbreak [\fI expression \fP]
\fBcontinue [\fI expression \fP]
\fBreturn [\fI expression \fP]\fR
.TE
.RE
.SM
Items up in brackets is optional.
.PP
In tha second form of tha \fBfor\fP statement n' tha \fBforr\fP statement, tha variable \fIvar\fP
is set ta each value used as a index up in tha specified array n' then
the associated \fIstatement\fP is evaluated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. For numeric n' strang indices, tha indices is 
returned up in increasin (decreasing) numeric or lexicographic order fo' 
\fBfor\fP (\fBforr\fP, respectively). This can be used fo' sorting.
.PP
Function definitions can only step tha fuck up in tha \fBBEGIN\fP clause.
.PP
Expressions include tha usual C expressions. 
Strin comparisons rockin \fB==\fP n' \fB!=\fP
treat tha right hand operand as a pattern
for tha purpose of regular expression matching.
Patterns use
.IR ksh (1)
file match pattern syntax.
(For simple strang equality, use tha \fBstrcmp\fP function.
.PP
\fBgvpr\fP will attempt ta use a expression as a strang or numeric value 
as appropriate. Both C-like casts n' function templates will cause
conversions ta be performed, if possible.
.PP
Expressionz of graphical type (i.e., \fBgraph_t, node_t,
edge_t, obj_t\fP) may be followed by a gangbangin' field reference up in the
form of \fB.\fP\fIname\fP. Da resultin value is tha value
of tha attribute named \fIname\fP of tha given object.
In addition, up in certain contexts a undeclared, unmodified
identifier is taken ta be an
attribute name. Right back up in yo muthafuckin ass. Specifically, such identifiers denote attributes
of tha current node or edge, respectively, up in \fBN\fP
and \fBE\fP clauses, n' tha current graph up in \fBBEG_G\fP n' \fBEND_G\fP
clauses.
.PP
As usual up in tha 
.IR libcgraph (3)
model, attributes is string\(hyvalued.
In addition,
.B gvpr
supports certain pseudo\(hyattributez of graph objects, not necessarily
string\(hyvalued. Y'all KNOW dat shit, muthafucka! These reflect intrinsic propertizzlez of tha graph objects
and cannot be set by tha user.
.TP
\fBhead\fR : \fBnode_t\fR
the head of a edge.
.TP
\fBtail\fR : \fBnode_t\fR
the tail of a edge.
.TP
\fBname\fR : \fBstring\fR
the name of a edge, node or graph. Da name of a edge has the
form "\fI<tail\(hyname><edge\(hyop><head\(hyname>\fB[\fI<key>\fB]\fR",
where \fI<edge\(hyop>\fP is "\fB\->\fP" or "\fB\-\-\fP" dependin on
whether tha graph is pimped up or not. Da bracket part \fB[\fI<key>\fB]\fR
only appears if tha edge has a non\(hytrivial key.
.TP
\fBindegree\fR : \fBint\fR
the indegree of a node.
.TP
\fBoutdegree\fR : \fBint\fR
the outdegree of a node.
.TP
\fBdegree\fR : \fBint\fR
the degree of a node.
.TP
\fBroot\fR : \fBgraph_t\fR
the root graph of a object. Da root of a root graph
is itself.
.TP
\fBparent\fR : \fBgraph_t\fR
the parent graph of a subgraph. Da parent of a root graph
is \fBNULL\fP
.TP
\fBn_edges\fR : \fBint\fR
the number of edges up in tha graph
.TP
\fBn_nodes\fR : \fBint\fR
the number of nodes up in tha graph
.TP
\fBdirected\fR : \fBint\fR
true (non\(hyzero) if tha graph is directed
.TP
\fBstrict\fR : \fBint\fR
true (non\(hyzero) if tha graph is strict
.SH "BUILT\(hyIN FUNCTIONS"
.PP
Da followin functions is built tha fuck into \fBgvpr\fP. Those functions
returnin references ta graph objects return \fBNULL\fP up in case of failure.
.SS "Graphs n' subgraph"
.TP
\fBgraph\fP(\fIs\fP : \fBstring\fP, \fIt\fP : \fBstring\fP) : \fBgraph_t\fP
creates a graph whose name is \fIs\fP n' whose type is
specified by tha strang \fIt\fP. Ignorin case, tha characters
\fBU, D, S, N\fR have tha interpretation undirected, directed,
strict, n' non\(hystrict, respectively. If \fIt\fP is empty,
a directed, non\(hystrict graph is generated.
.TP
\fBsubg\fP(\fIg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBgraph_t\fP
creates a subgraph up in graph \fIg\fP wit name \fIs\fP. If tha subgraph
already exists, it is returned.
.TP
\fBisSubg\fP(\fIg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBgraph_t\fP
returns tha subgraph up in graph \fIg\fP wit name \fIs\fP, if it exists,
or \fBNULL\fP otherwise.
.TP
\fBfstsubg\fP(\fIg\fP : \fBgraph_t\fP) : \fBgraph_t\fP
returns tha straight-up original gangsta subgraph up in graph \fIg\fP, or \fBNULL\fP if none exists.
.TP
\fBnxtsubg\fP(\fIsg\fP : \fBgraph_t\fP) : \fBgraph_t\fP
returns tha next subgraph afta \fIsg\fP, or \fBNULL\fP.
.TP
\fBisDirect\fP(\fIg\fP : \fBgraph_t\fP) : \fBint\fP
returns legit if n' only if \fIg\fP is directed.
.TP
\fBisStrict\fP(\fIg\fP : \fBgraph_t\fP) : \fBint\fP
returns legit if n' only if \fIg\fP is strict.
.TP
\fBnNodes\fP(\fIg\fP : \fBgraph_t\fP) : \fBint\fP
returns tha number of nodes up in \fIg\fP.
.TP
\fBnEdges\fP(\fIg\fP : \fBgraph_t\fP) : \fBint\fP
returns tha number of edges up in \fIg\fP.
.SS "Nodes"
.TP
\fBnode\fP(\fIsg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBnode_t\fP
creates a node up in graph \fIg\fP of name \fIs\fP. If such a node
already exists, it is returned.
.TP
\fBsubnode\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBnode_t\fP
inserts tha node \fIn\fP tha fuck into tha subgraph \fIg\fP. Returns tha node.
.TP
\fBfstnode\fP(\fIg\fP : \fBgraph_t\fP) : \fBnode_t\fP
returns tha straight-up original gangsta node up in graph \fIg\fP, or \fBNULL\fP if none exists.
.TP
\fBnxtnode\fP(\fIn\fP : \fBnode_t\fP) : \fBnode_t\fP
returns tha next node afta \fIn\fP up in tha root graph, or \fBNULL\fP.
.TP
\fBnxtnode_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBnode_t\fP
returns tha next node afta \fIn\fP up in \fIsg\fP, or \fBNULL\fP.
.TP
\fBisNode\fP(\fIsg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBnode_t\fP
looks fo' a node up in (sub)graph \fIsg\fP of name \fIs\fP. If such a node
exists, it is returned. Y'all KNOW dat shit, muthafucka! Otherwise, \fBNULL\fP is returned.
.TP
\fBisSubnode\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBint\fP
returns non-zero if node \fIn\fP is up in (sub)graph \fIsg\fP, or zero
otherwise.
.TP
\fBindegreeOf\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBint\fP
returns tha indegree of node \fIn\fP up in (sub)graph \fIsg\fP.
.TP
\fBoutdegreeOf\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBint\fP
returns tha outdegree of node \fIn\fP up in (sub)graph \fIsg\fP.
.TP
\fBdegreeOf\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBint\fP
returns tha degree of node \fIn\fP up in (sub)graph \fIsg\fP.
.SS "Edges"
.TP
\fBedge\fP(\fIt\fP : \fBnode_t\fP, \fIh\fP : \fBnode_t\fP, \fIs\fP : \fBstring\fP) : \fBedge_t\fP
creates a edge wit tail node \fIt\fP, head node \fIh\fP and
name \fIs\fP up in tha root graph. If tha graph is undirected, tha 
distinction between head n' tail nodes is unimportant.
If such a edge already exists, it is returned.
.TP
\fBedge_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIt\fP : \fBnode_t\fP, \fIh\fP : \fBnode_t\fP, \fIs\fP : \fBstring\fP) : \fBedge_t\fP
creates a edge wit tail node \fIt\fP, head node \fIh\fP n' name \fIs\fP 
in (sub)graph \fIsg\fP (and all parent graphs). If tha graph is undirected, tha distinction between
head n' tail nodes is unimportant.
If such a edge already exists, it is returned.
.TP
\fBsubedge\fP(\fIg\fP : \fBgraph_t\fP, \fIe\fP : \fBedge_t\fP) : \fBedge_t\fP
inserts tha edge \fIe\fP tha fuck into tha subgraph \fIg\fP. Returns tha edge.
.TP
\fBisEdge\fP(\fIt\fP : \fBnode_t\fP, \fIh\fP : \fBnode_t\fP, \fIs\fP : \fBstring\fP) : \fBedge_t\fP
looks fo' a edge wit tail node \fIt\fP, head node \fIh\fP and
name \fIs\fP. If tha graph is undirected, tha distinction between
head n' tail nodes is unimportant.
If such a edge exists, it is returned. Y'all KNOW dat shit, muthafucka! Otherwise, \fBNULL\fP is returned.
.TP
\fBisEdge_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIt\fP : \fBnode_t\fP, \fIh\fP : \fBnode_t\fP, \fIs\fP : \fBstring\fP) : \fBedge_t\fP
looks fo' a edge wit tail node \fIt\fP, head node \fIh\fP and
name \fIs\fP up in (sub)graph \fIsg\fP. If tha graph is undirected, tha distinction between
head n' tail nodes is unimportant.
If such a edge exists, it is returned. Y'all KNOW dat shit, muthafucka! Otherwise, \fBNULL\fP is returned.
.TP
\fBisSubedge\fP(\fIg\fP : \fBgraph_t\fP, \fIe\fP : \fBedge_t\fP) : \fBint\fP
returns non-zero if edge \fIe\fP is up in (sub)graph \fIsg\fP, or zero
otherwise.
.TP
\fBfstout\fP(\fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta outedge of node \fIn\fP up in tha root graph.
.TP
\fBfstout_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta outedge of node \fIn\fP up in (sub)graph \fIsg\fP.
.TP
\fBnxtout\fP(\fIe\fP : \fBedge_t\fP) : \fBedge_t\fP
returns tha next outedge afta \fIe\fP up in tha root graph.
.TP
\fBnxtout_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIe\fP : \fBedge_t\fP) : \fBedge_t\fP
returns tha next outedge afta \fIe\fP up in graph \fIsg\fP.
.TP
\fBfstin\fP(\fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta inedge of node \fIn\fP up in tha root graph.
.TP
\fBfstin_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta inedge of node \fIn\fP up in graph \fIsg\fP.
.TP
\fBnxtin\fP(\fIe\fP : \fBedge_t\fP) : \fBedge_t\fP
returns tha next inedge afta \fIe\fP up in tha root graph.
.TP
\fBnxtin_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIe\fP : \fBedge_t\fP) : \fBedge_t\fP
returns tha next inedge afta \fIe\fP up in graph \fIsg\fP.
.TP
\fBfstedge\fP(\fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta edge of node \fIn\fP up in tha root graph.
.TP
\fBfstedge_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBedge_t\fP
returns tha straight-up original gangsta edge of node \fIn\fP up in graph \fIsg\fP.
.TP
\fBnxtedge\fP(\fIe\fP : \fBedge_t\fP, \fBnode_t\fP) : \fBedge_t\fP
returns tha next edge afta \fIe\fP up in tha root graph.
.TP
\fBnxtedge_sg\fP(\fIsg\fP : \fBgraph_t\fP, \fIe\fP : \fBedge_t\fP, \fBnode_t\fP) : \fBedge_t\fP
returns tha next edge afta \fIe\fP up in tha graph \fIsg\fP.
.TP
\fBopp\fP(\fIe\fP : \fBedge_t\fP, \fBnode_t\fP) : \fBnode_t\fP
returns tha node on tha edge \fIe\fP not equal ta \fIn\fP.
Returns NULL if \fIn\fP aint a node of \fIe\fP.
This can be useful when rockin \fBfstedge\fP n' \fBnxtedge\fP
to enumerate tha neighborz of \fIn\fP.
.SS "Graph I/O"
.TP
\fBwrite\fP(\fIg\fP : \fBgraph_t\fP) : \fBvoid\fP
prints \fIg\fP up in dot format onto tha output stream.
.TP
\fBwriteG\fP(\fIg\fP : \fBgraph_t\fP, \fIfname\fP : \fBstring\fP) : \fBvoid\fP
prints \fIg\fP up in dot format tha fuck into tha file \fIfname\fP.
.TP
\fBfwriteG\fP(\fIg\fP : \fBgraph_t\fP, \fIfd\fP : \fBint\fP) : \fBvoid\fP
prints \fIg\fP up in dot format onto tha open stream denoted
by tha integer \fIfd\fP.
.TP
\fBreadG\fP(\fIfname\fP : \fBstring\fP) : \fBgraph_t\fP
returns a graph read from tha file \fIfname\fP. Da graph should be
in dot format. If no graph can be read, \fBNULL\fP is returned.
.TP
\fBfreadG\fP(\fIfd\fP : \fBint\fP) : \fBgraph_t\fP
returns tha next graph read from tha open stream \fIfd\fP.
Returns \fBNULL\fP at end of file.
.SS "Graph miscellany"
.TP
\fBdelete\fP(\fIg\fP : \fBgraph_t\fP, \fIx\fP : \fBobj_t\fP) : \fBvoid\fP
deletes object \fIx\fP from graph \fIg\fP.
If \fIg\fP is \fBNULL\fP, tha function uses tha root graph of \fIx\fP.
If \fIx\fP be a graph or subgraph, it is closed unless \fIx\fP is locked.
.TP
\fBisIn\fP(\fIg\fP : \fBgraph_t\fP, \fIx\fP : \fBobj_t\fP) : \fBint\fP
returns legit if \fIx\fP is up in subgraph \fIg\fP.
.TP
\fBcloneG\fP(\fIg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBgraph_t\fP
creates a cold-ass lil clone of graph \fIg\fP wit name of \fIs\fP.
If \fIs\fP is "", tha pimped graph has tha same ol' dirty name as \fIg\fP.
.TP
\fBclone\fP(\fIg\fP : \fBgraph_t\fP, \fIx\fP : \fBobj_t\fP) : \fBobj_t\fP
creates a cold-ass lil clone of object \fIx\fP up in graph \fIg\fP.
In particular, tha freshly smoked up object has tha same ol' dirty name/value attributes
and structure as tha original gangsta object.
If a object wit tha same key as \fIx\fP already exists, its attributes
are overlaid by dem of \fIx\fP n' tha object is returned.
If a edge is cloned, both endpoints is implicitly cloned.
If a graph is cloned, all nodes, edges n' subgraphs is implicitly
cloned.
If \fIx\fP be a graph, \fIg\fP may be \fBNULL\fP, up in which case tha cloned
object is ghon be a freshly smoked up root graph. In dis case, tha call is equivalent
to \fBcloneG(\fP\fIx\fP\fB,"")\fP.
.TP
\fBcopy\fP(\fIg\fP : \fBgraph_t\fP, \fIx\fP : \fBobj_t\fP) : \fBobj_t\fP
creates a cold-ass lil copy of object \fIx\fP up in graph \fIg\fP,
where tha freshly smoked up object has tha same ol' dirty name/value attributes
as tha original gangsta object.
If a object wit tha same key as \fIx\fP already exists, its attributes
are overlaid by dem of \fIx\fP n' tha object is returned.
Note dat dis be a gangbangin' finger-lickin' dirty-ass shallow copy. If \fIx\fP be a graph, none of its nodes, 
edges or subgraphs is copied tha fuck into tha freshly smoked up graph. If \fIx\fP be a edge,
the endpoints is pimped if necessary yo, but they is not cloned.
If \fIx\fP be a graph, \fIg\fP may be \fBNULL\fP, up in which case tha cloned
object is ghon be a freshly smoked up root graph.
.TP
\fBcopyA\fP(\fIsrc\fP : \fBobj_t\fP, \fItgt\fP : \fBobj_t\fP) : \fBint\fP
copies tha attributez of object \fIsrc\fP ta object \fItgt\fP, overwriting
any attribute joints \fItgt\fP may initially have.
.TP
\fBinduce\fP(\fIg\fP : \fBgraph_t\fP) : \fBvoid\fP
extendz \fIg\fP ta its node\(hyinduced subgraph extension up in its root graph.
.TP
\fBhasAttr\fP(\fIsrc\fP : \fBobj_t\fP, \fIname\fP : \fBstring\fP) : \fBint\fP
returns non-zero if object \fIsrc\fP has a attribute whose name is
\fIname\fP. Well shiiiit, it returns 0 otherwise.
.TP
\fBisAttr\fP(\fIg\fP : \fBgraph_t\fP, \fIkind\fP : \fBstring\fP, \fIname\fP : \fBstring\fP) : \fBint\fP
returns non-zero if a attribute \fIname\fP has been defined up in \fIg\fP
for objectz of tha given \fIkind\fP. For nodes, edges, n' graphs, \fIkind\fP
should be "N", "E", n' "G", respectively.
It returns 0 otherwise.
.TP
\fBaget\fP(\fIsrc\fP : \fBobj_t\fP, \fIname\fP : \fBstring\fP) : \fBstring\fP
returns tha value of attribute \fIname\fP up in object \fIsrc\fP. This is
useful fo' dem cases when \fIname\fP conflicts wit one of tha keywords
like fuckin "head" or "root".
If tha attribute has not been declared up in tha graph, tha function will
initialize it wit a thugged-out default value of "". To avoid this, one should use
the \fBhasAttr\fP or \fBisAttr\fP function ta check dat tha attribute exists.
.TP
\fBaset\fP(\fIsrc\fP : \fBobj_t\fP, \fIname\fP : \fBstring\fP, \fIvalue\fP : \fBstring\fP) : \fBint\fP
sets tha value of attribute \fIname\fP up in object \fIsrc\fP ta \fIvalue\fP.
Returns 0 on success, non\(hyzero on failure. Right back up in yo muthafuckin ass. See \fBaget\fP above.
.TP
\fBgetDflt\fP(\fIg\fP : \fBgraph_t\fP, \fIkind\fP : \fBstring\fP, \fIname\fP : \fBstring\fP) : \fBstring\fP
returns tha default value of attribute \fIname\fP up in objects up in \fIg\fP of
the given \fIkind\fP. For nodes, edges, n' graphs, \fIkind\fP
should be "N", "E", n' "G", respectively.
If tha attribute has not been declared up in tha graph, tha function will
initialize it wit a thugged-out default value of "". To avoid this, one should use
the \fBisAttr\fP function ta check dat tha attribute exists.
.TP
\fBsetDflt\fP(\fIg\fP : \fBgraph_t\fP, \fIkind\fP : \fBstring\fP, \fIname\fP : \fBstring\fP, \fIvalue\fP : \fBstring\fP) : \fBint\fP
sets tha default value of attribute \fIname\fP ta \fIvalue\fP up in 
objects up in \fIg\fP of
the given \fIkind\fP. For nodes, edges, n' graphs, \fIkind\fP
should be "N", "E", n' "G", respectively.
Returns 0 on success, non\(hyzero on failure. Right back up in yo muthafuckin ass. See \fBgetDflt\fP above.
.TP
\fBfstAttr\fP(\fIg\fP : \fBgraph_t\fP, \fIkind\fP : \fBstring\fP) : \fBstring\fP
returns tha name of tha straight-up original gangsta attribute of objects up in \fIg\fP of
the given \fIkind\fP. For nodes, edges, n' graphs, \fIkind\fP
should be "N", "E", n' "G", respectively.
If there be no attributes, tha strang "" is returned.
.TP
\fBnxtAttr\fP(\fIg\fP : \fBgraph_t\fP, \fIkind\fP : \fBstring\fP, \fIname\fP : \fBstring\fP) : \fBstring\fP
returns tha name of tha next attribute of objects up in \fIg\fP of
the given \fIkind\fP afta tha attribute \fIname\fP. 
Da argument \fIname\fP must be tha name of a existin attribute; it will
typically be tha return value of a previous call ta \fBfstAttr\fP or
\fBnxtAttr\fP.
For nodes, edges, n' graphs, \fIkind\fP
should be "N", "E", n' "G", respectively.
If there be no attributes left, tha strang "" is returned.
.TP
\fBcompOf\fP(\fIg\fP : \fBgraph_t\fP, \fIn\fP : \fBnode_t\fP) : \fBgraph_t\fP
returns tha connected component of tha graph \fIg\fP containin node \fIn\fP,
as a subgraph of \fIg\fP. Da subgraph only gotz nuff tha nodes. One can
use \fIinduce\fP ta add tha edges. Da function fails n' returns \fBNULL\fP
if \fIn\fP aint up in \fIg\fP. Connectivitizzle is based on tha underlying
unpimped up graph of \fIg\fP.
.TP
\fBkindOf\fP(\fIobj\fP : \fBobj_t\fP) : \fBstring\fP
returns a indication of tha type of \fIobj\fP.
For nodes, edges, n' graphs, it returns "N", "E", n' "G", respectively.
.TP
\fBlock\fP(\fIg\fP : \fBgraph_t\fP, \fIv\fP : \fBint\fP) : \fBint\fP
implements graph lockin on root graphs. If tha integer \fIv\fP is positive, the
graph is set so dat future calls ta \fBdelete\fP have no immediate effect.
If \fIv\fP is zero, tha graph is unlocked. Y'all KNOW dat shit, muthafucka! If there has been a cold-ass lil call
to delete tha graph while dat shiznit was locked, tha graph is closed.
If \fIv\fP is negative, not a god damn thang is done.
In all cases, tha previous lock value is returned.
.SS "Strings"
.TP
\fBsprintf\fP(\fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBstring\fP
returns tha strang resultin from formatting
the jointz of tha expressions occurrin afta \fIfmt\fP
accordin ta the
.IR printf (3)
format
.I fmt
.TP
\fBgsub\fP(\fIstr\fP : \fBstring\fP, \fIpat\fP : \fBstring\fP) : \fBstring\fP
.TP
\fBgsub\fP(\fIstr\fP : \fBstring\fP, \fIpat\fP : \fBstring\fP, \fIrepl\fP : \fBstring\fP) : \fBstring\fP
returns \fIstr\fP wit all substrings matchin \fIpat\fP
deleted or replaced by \fIrepl\fP, respectively.
.TP
\fBsub\fP(\fIstr\fP : \fBstring\fP, \fIpat\fP : \fBstring\fP) : \fBstring\fP
.TP
\fBsub\fP(\fIstr\fP : \fBstring\fP, \fIpat\fP : \fBstring\fP, \fIrepl\fP : \fBstring\fP) : \fBstring\fP
returns \fIstr\fP wit tha leftmost substrin matchin \fIpat\fP
deleted or replaced by \fIrepl\fP, respectively. Da 
charactas '^' n' '$'
may be used all up in tha beginnin n' end, respectively,
of \fIpat\fP ta anchor tha pattern ta tha beginnin or end of \fIstr\fP.
.TP
\fBsubstr\fP(\fIstr\fP : \fBstring\fP, \fIidx\fP : \fBint\fP) : \fBstring\fP
.TP
\fBsubstr\fP(\fIstr\fP : \fBstring\fP, \fIidx\fP : \fBint\fP, \fIlen\fP : \fBint\fP) : \fBstring\fP
returns tha substrin of \fIstr\fP startin at posizzle \fIidx\fP to
the end of tha strang or of length \fIlen\fP, respectively.
Indexin starts at 0. If \fIidx\fP is wack or \fIidx\fP is pimped outa than
the length of \fIstr\fP, a gangbangin' fatal error occurs. Right back up in yo muthafuckin ass. Similarly, up in tha second
case, if \fIlen\fP is wack or \fIidx\fP + \fIlen\fP is pimped outa than the
length of \fIstr\fP, a gangbangin' fatal error occurs.
.TP
\fBstrcmp\fP(\fIs1\fP : \fBstring\fP, \fIs2\fP : \fBstring\fP) : \fBint\fP
provides tha standard C function
.IR strcmp (3).
.TP
\fBlength\fP(\fIs\fP : \fBstring\fP) : \fBint\fP
returns tha length of strang \fIs\fP.
.TP
\fBindex\fP(\fIs\fP : \fBstring\fP, \fIt\fP : \fBstring\fP) : \fBint\fP
.TP
\fBrindex\fP(\fIs\fP : \fBstring\fP, \fIt\fP : \fBstring\fP) : \fBint\fP
returns tha index of tha characta up in strang \fIs\fP where tha leftmost
(rightmost) copy of strang \fIt\fP can be found, or \-1 if \fIt\fP aint a 
substrin of \fIs\fP.
.TP
\fBmatch\fP(\fIs\fP : \fBstring\fP, \fIp\fP : \fBstring\fP) : \fBint\fP
returns tha index of tha characta up in strang \fIs\fP where tha leftmost
match of pattern \fIp\fP can be found, or \-1 if no substrin of \fIs\fP
matches \fIp\fP.
.TP
\fBtoupper\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns a version of \fIs\fP wit tha alphabetic charactas converted ta upper-case.
.TP
\fBtolower\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns a version of \fIs\fP wit tha alphabetic charactas converted ta lower-case.
.TP
\fBcanon\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns a version of \fIs\fP appropriate ta be used as a identifier
in a thugged-out dot file.
.TP
\fBhtml\fP(\fIg\fP : \fBgraph_t\fP, \fIs\fP : \fBstring\fP) : \fBstring\fP
returns a ``magic'' version  of \fIs\fP as a HTML string. This will typically be
used ta attach a HTML-like label ta a graph object. Note dat tha returned string
lives up in \fIg\fP. In particular, it is ghon be freed when \fIg\fP is closed, n' to
act as a HTML string, it has ta be used wit a object of \fIg\fP. In addition,
note dat the
angle bracket quotes should not be part of \fIs\fP. These is ghon be added if 
\fIg\fP is freestyled up in concrete DOT format.
.TP
\fBishtml\fP(\fIs\fP : \fBstring\fP) : \fBint\fP
returns non-zero if n' only if \fIs\fP be a HTML string.
.TP
\fBxOf\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns tha strang "\fIx\fP" if \fIs\fP has tha form "\fIx\fP,\fIy\fP", 
where both \fIx\fP n' \fIy\fP is numeric.
.TP
\fByOf\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns tha strang "\fIy\fP" if \fIs\fP has tha form "\fIx\fP,\fIy\fP", 
where both \fIx\fP n' \fIy\fP is numeric.
.TP
\fBllOf\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns tha strang "\fIllx\fP,\fIlly\fP" if \fIs\fP has tha form 
"\fIllx\fP,\fIlly\fP,\fIurx\fP,\fIury\fP",
where all of \fIllx\fP, \fIlly\fP, \fIurx\fP, n' \fIury\fP is numeric.
.TP
.BI urOf( s )
\fBurOf\fP(\fIs\fP : \fBstring\fP) : \fBstring\fP
returns tha strang "\fIurx\fP,\fIury\fP" if \fIs\fP has tha form 
"\fIllx\fP,\fIlly\fP,\fIurx\fP,\fIury\fP",
where all of \fIllx\fP, \fIlly\fP, \fIurx\fP, n' \fIury\fP is numeric.
.TP
\fBsscanf\fP(\fIs\fP : \fBstring\fP, \fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBint\fP
scans tha strang \fIs\fP, extractin joints
accordin ta the
.IR sscanf (3)
format
.IR fmt .
Da joints is stored up in tha addresses followin \fIfmt\fP,
addresses havin tha form \fB&\fP\fIv\fP, where \fIv\fP is some declared
variable of tha erect type.
Returns tha number of shit successfully scanned.
.TP
\fBsplit\fP(\fIs\fP : \fBstring\fP, \fIarr\fP : \fBarray\fP, \fIseps\fP : \fBstring\fP) : \fBint\fP
.TP
\fBsplit\fP(\fIs\fP : \fBstring\fP, \fIarr\fP : \fBarray\fP) : \fBint\fP
.TP
\fBtokens\fP(\fIs\fP : \fBstring\fP, \fIarr\fP : \fBarray\fP, \fIseps\fP : \fBstring\fP) : \fBint\fP
.TP
\fBtokens\fP(\fIs\fP : \fBstring\fP, \fIarr\fP : \fBarray\fP) : \fBint\fP
Da \fBsplit\fP function breaks tha strang \fIs\fP tha fuck into fields, while tha \fBtokens\fP function
breaks tha strang tha fuck into tokens. 
A field consistz of all non-separator charactas between two separator charactas or tha beginnin or
end of tha string. Thus, a gangbangin' field may be tha empty strin fo' realz. A
token be a maximal, non-empty substrin not containin a separator character.
Da separator charactas is dem given up in tha \fIseps\fP argument.
If \fIseps\fP aint provided, tha default value is " \\t\\n". 
Da functions return tha number of fieldz or tokens.
.sp
Da fieldz n' tokens is stored up in tha argument array. Da array must be \fBstring\fP-valued and,
if a index type is specified, it must be \fBint\fP. Da entries is indexed by consecutive
integers, startin at 0 fo' realz. Any joints already stored up in tha array is ghon be either overwritten, or
still be present afta tha function returns.
.SS "I/O"
.TP
\fBprint\fP(\fI...\fP) : \fBvoid\fP
.BI print( " expr" , " ...\fB )
prints a strang representation of each argument up in turn onto
\fBstdout\fP, followed by a newline.
.TP
\fBprintf\fP(\fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBint\fP
.TP
\fBprintf\fP(\fIfd\fP : \fBint\fP, \fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBint\fP
prints tha strang resultin from formatting
the jointz of tha expressions followin \fIfmt\fP
accordin ta the
.IR printf (3)
format
.IR fmt .
Returns 0 on success.
By default, it prints on \fBstdout\fP.
If tha optionizzle integer \fIfd\fP is given, output is freestyled on tha open
stream associated wit \fIfd\fP.
.TP
\fBscanf\fP(\fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBint\fP
.TP
\fBscanf\fP(\fIfd\fP : \fBint\fP, \fIfmt\fP : \fBstring\fP, \fI...\fP) : \fBint\fP
scans up in joints from a input stream accordin ta the
.IR scanf (3)
format
.IR fmt .
Da joints is stored up in tha addresses followin \fIfmt\fP,
addresses havin tha form \fB&\fP\fIv\fP, where \fIv\fP is some declared
variable of tha erect type.
By default, it readz from \fBstdin\fP.
If tha optionizzle integer \fIfd\fP is given, input is read from tha open
stream associated wit \fIfd\fP.
Returns tha number of shit successfully scanned.
.TP
\fBopenF\fP(\fIs\fP : \fBstring\fP, \fIt\fP : \fBstring\fP) : \fBint\fP
opens tha file \fIs\fP as a I/O stream. Da strang argument \fIt\fP
specifies how tha fuck tha file is opened. Y'all KNOW dat shit, muthafucka! Da arguments is tha same as for
the C function
.IR fopen (3).
It returns a integer denotin tha stream, or \-1 on error.
.sp
As usual, streams 0, 1 n' 2 is already open as \fBstdin\fP, \fBstdout\fP,
and \fBstderr\fP, respectively. Right back up in yo muthafuckin ass. Since \fBgvpr\fP may use \fBstdin\fP to
read tha input graphs, tha user should avoid rockin dis stream.
.TP
\fBcloseF\fP(\fIfd\fP : \fBint\fP) : \fBint\fP
closes tha open stream denoted by tha integer \fIfd\fP.
Streams  0, 1 n' 2 cannot be closed.
Returns 0 on success.
.TP
\fBreadL\fP(\fIfd\fP : \fBint\fP) : \fBstring\fP
returns tha next line read from tha input stream \fIfd\fP. Well shiiiit, it returns
the empty strang "" on end of file. Note dat tha newline characta is
left up in tha returned string.
.SS "Math"
.TP
\fBexp\fP(\fId\fP : \fBdouble\fP) : \fBdouble\fP
returns e ta tha \fId\fPth power.
.TP
\fBlog\fP(\fId\fP : \fBdouble\fP) : \fBdouble\fP
returns tha natural log of \fId\fP.
.TP
\fBsqrt\fP(\fId\fP : \fBdouble\fP) : \fBdouble\fP
returns tha square root of tha double \fId\fP.
.TP
\fBpow\fP(\fId\fP : \fBdouble\fP, \fIx\fP : \fBdouble\fP) : \fBdouble\fP
returns \fId\fP raised ta tha \fIx\fPth power.
.TP
\fBcos\fP(\fId\fP : \fBdouble\fP) : \fBdouble\fP
returns tha cosine of \fId\fP.
.TP
\fBsin\fP(\fId\fP : \fBdouble\fP) : \fBdouble\fP
returns tha sine of \fId\fP.
.TP
\fBatan2\fP(\fIy\fP : \fBdouble\fP, \fIx\fP : \fBdouble\fP) : \fBdouble\fP
returns tha arctangent of \fIy/x\fP up in tha range \-pi ta pi.
.TP
\fBMIN\fP(\fIy\fP : \fBdouble\fP, \fIx\fP : \fBdouble\fP) : \fBdouble\fP
returns tha minimum of \fIy\fP n' \fIx\fP.
.TP
\fBMAX\fP(\fIy\fP : \fBdouble\fP, \fIx\fP : \fBdouble\fP) : \fBdouble\fP
returns tha maximum of \fIy\fP n' \fIx\fP.
.SS "Associatizzle Arrays"
.TP
\fB#\fP \fIarr\fP : \fBint\fP
returns tha number of elements up in tha array \fIarr\fP.
.TP
\fIidx\fP \fBin\fP \fIarr\fP : \fBint\fP
returns 1 if a value has been set fo' index \fIidx\fP up in tha array \fIarr\fP.
It returns 0 otherwise.
.TP
\fBunset\fP(\fIv\fP : \fBarray\fP, \fIidx\fP) : \fBint\fP
removes tha item indexed by \fIidx\fP. Well shiiiit, it returns 1 if tha item existed, 0 otherwise.
.TP
\fBunset\fP(\fIv\fP : \fBarray\fP) : \fBvoid\fP
re-initializes tha array.
.SS "Miscellaneous"
.TP
\fBexit\fP(\fIv\fP : \fBint\fP) : \fBvoid\fP
causes
.B gvpr
to exit wit tha exit code
.IR v .
.TP
\fBsystem\fP(\fIcmd\fP : \fBstring\fP) : \fBint\fP
provides tha standard C function
.IR system (3).
It executes \fIcmd\fP up in tha userz shell environment, and
returns tha exit statuz of tha shell.
.TP
\fBrand\fP() : \fBdouble\fP
returns a pseudo\(hyrandom double between 0 n' 1.
.TP
\fBsrand\fP() : \fBint\fP
.TP
\fBsrand\fP(\fIv\fP : \fBint\fP) : \fBint\fP
sets a seed fo' tha random number generator. Shiiit, dis aint no joke. Da optionizzle argument gives
the seed; if it is omitted, tha current time is used. Y'all KNOW dat shit, muthafucka! Da previous seed
value is returned. Y'all KNOW dat shit, muthafucka! \fBsrand\fP should be called before any calls to
\fBrand\fP.
.TP
\fBcolorx\fP(\fIcolor\fP : \fBstring\fP, \fIfmt\fP : \fBstring\fP) : \fBstring\fP
translates a cold-ass lil color from one format ta another n' shit. Da \fIcolor\fP argument should be
a color up in one of tha recognized strang representations. Da \fIfmt\fP value should
be one of "RGB", "RGBA", "HSV", or "HSVA".
An empty strang is returned on error.
.SH "BUILT\(hyIN VARIABLES"
.PP
.B gvpr
provides certain special, built\(hyin variables, whose joints is set
automatically by \fBgvpr\fP dependin on tha context. Except as noted,
the user cannot modify they joints.
.TP
\fB$\fP : \fBobj_t\fP
denotes tha current object (node, edge, graph) dependin on the
context.  It aint available up in \fBBEGIN\fP or \fBEND\fP clauses.
.TP
\fB$F\fP : \fBstring\fP
is tha name of tha current input file. 
.TP
\fB$G\fP : \fBgraph_t\fP
denotes tha current graph bein processed. Y'all KNOW dat shit, muthafucka! Well shiiiit, it aint available
in \fBBEGIN\fP or \fBEND\fP clauses.
.TP
\fB$NG\fP : \fBgraph_t\fP
denotes tha next graph ta be processed. Y'all KNOW dat shit, muthafucka! If \fB$NG\fP is NULL, 
the current graph \fB$G\fP is tha last graph. Note dat if tha input
be reppin stdin, tha last graph cannot be determined until tha input
pipe is closed. Y'all KNOW dat shit, muthafucka! 
It aint available up in \fBBEGIN\fP or \fBEND\fP clauses, or if tha 
\fB-n\fP flag is used.
.TP
\fB$O\fP : \fBgraph_t\fP
denotes tha output graph. Before graph traversal, it is initialized
to tha target graph fo' realz. Afta traversal n' any \fBEND_G\fP actions,
if it refers ta a non\(hyempty graph, dat graph is printed onto tha output stream.
It be only valid up in \fBN\fP, \fBE\fP n' \fBEND_G\fP clauses.
Da output graph may be set by tha user.
.TP
\fB$T\fP : \fBgraph_t\fP
denotes tha current target graph. Well shiiiit, it aint nuthin but a subgraph of \fB$G\fP
and be available only up in \fBN\fP, \fBE\fP n' \fBEND_G\fP clauses.
.TP
\fB$tgtname\fP : \fBstring\fP
denotes tha name of tha target graph. 
By default, it is set ta \fB"gvpr_result"\fP.
If used multiple times durin tha execution of
.BR gvpr ,
the name is ghon be appended wit a integer n' shit. 
This variable may be set by tha user.
.TP
\fB$tvroot\fP : \fBnode_t\fP
indicates tha startin node fo' a (pimped up or undirected)
depth\(hyfirst or breadth\(hyfirst traversal of the
graph (cf. \fB$tvtype\fP below).
Da default value is \fBNULL\fP fo' each input graph.
Afta tha traversal all up in tha given root, if tha value of \fB$tvroot\fP has chizzled,
a freshly smoked up traversal will begin wit tha freshly smoked up value of \fB$tvroot\fP fo' realz. Also, set \fB$tvnext\fP below.
.TP
\fB$tvnext\fP : \fBnode_t\fP
indicates tha next startin node fo' a (pimped up or undirected)
depth\(hyfirst or breadth\(hyfirst traversal of the
graph (cf. \fB$tvtype\fP below).
If a traversal finishes n' tha \fB$tvroot\fP has not been reset but tha \fB$tvnext\fP has been
set but not used, dis node is ghon be used as tha next chizzle fo' \fB$tvroot\fP.
Da default value is \fBNULL\fP fo' each input graph.
.TP
\fB$tvedge\fP : \fBedge_t\fP
For BFS n' DFS traversals, dis is set ta tha edge used ta arrive at the
current node or edge fo' realz. At tha beginnin of a traversal, or fo' other traversal
types, tha value is \fBNULL\fP.
.TP
\fB$tvtype\fP : \fBtvtype_t\fP
indicates how tha fuck \fBgvpr\fP traverses a graph. Well shiiiit, it can only take
one of tha constant joints wit tha previx "TV_" busted lyrics bout below.
\fBTV_flat\fP is tha default.
.IP
In tha underlyin graph library
.IR cgraph (3),
edges up in unpimped up graphs is given a arbitrary direction. I aint talkin' bout chicken n' gravy biatch. This is
used fo' traversals, like fuckin \fBTV_fwd\fR, requirin pimped up edges.
.
.TP
\fBARGC\fP : \fBint\fP
denotes tha number of arguments specified by tha 
\fB\-a\fP \fIargs\fP command\(hyline argument.
.TP
\fBARGV\fP : \fBstrin array\fP
denotes tha array of arguments specified by tha 
\fB\-a\fP \fIargs\fP
command\(hyline argument. Da \fIi\fPth argument is given
by \fBARGV[\fIi\fP]\fR.
.SH "BUILT\(hyIN CONSTANTS"
.PP
There is nuff muthafuckin symbolic constants defined by \fBgvpr\fP.
.TP
\fBNULL\fR : \fIobj_t\fR
a null object reference, equivalent ta 0.
.TP
\fBTV_flat\fR : \fItvtype_t\fR
a simple, flat traversal, wit graph objects hit up in
seemingly arbitrary order.
.TP
\fBTV_ne\fR : \fItvtype_t\fR
a traversal which first visits all of tha nodes, then all
of tha edges.
.TP
\fBTV_en\fR : \fItvtype_t\fR
a traversal which first visits all of tha edges, then all
of tha nodes.
.TP
\fBTV_dfs\fR : \fItvtype_t\fR
.TQ
\fBTV_postdfs\fR : \fItvtype_t\fR
.TQ
\fBTV_prepostdfs\fR : \fItvtype_t\fR
a traversal of tha graph rockin a thugged-out depth\(hyfirst search on the
underlyin unpimped up graph. 
To do tha traversal, \fBgvpr\fP will check tha value of
\fB$tvroot\fP. If dis has tha same ol' dirty value dat it had previously
(at tha start, tha previous value is initialized ta \fBNULL\fP.), \fBgvpr\fP
will simply look fo' some unvisited node n' traverse its connected
component. On tha other hand, if \fB$tvroot\fP has chizzled, its connected
component is ghon be toured, assumin it has not been previously hit up or,
if \fB$tvroot\fP is \fBNULL\fP, tha traversal will stop. Note dat using
\fBTV_dfs\fP n' \fB$tvroot\fP, it is possible ta create a infinite loop.
.
.IP
By default, tha traversal is done up in pre-order n' shit. That is, a node is
visited before all of its unvisited edges. For \fBTV_postdfs\fR,
all of a nodez unvisited edges is hit up before tha node. For
\fBTV_prepostdfs\fR, a node is hit up twice, before n' afta all of
its unvisited edges.
.
.TP
\fBTV_fwd\fR : \fItvtype_t\fR
.TQ
\fBTV_postfwd\fR : \fItvtype_t\fR
.TQ
\fBTV_prepostfwd\fR : \fItvtype_t\fR
A traversal of tha graph rockin a thugged-out depth\(hyfirst search on the
graph followin only forward arcs.
Da chizzle of roots fo' tha traversal is the
same as busted lyrics bout fo' \fBTV_dfs\fR above.
Da different order of visitation specified by \fBTV_fwd\fR,
\fBTV_postfwd\fR n' \fBTV_prepostfwd\fR is tha same as them
specified by tha analogous traversals \fBTV_dfs\fR,
\fBTV_postdfs\fR n' \fBTV_prepostdfs\fR.
.TP
\fBTV_rev\fR : \fItvtype_t\fR
.TQ
\fBTV_postrev\fR : \fItvtype_t\fR
.TQ
\fBTV_prepostrev\fR : \fItvtype_t\fR
A traversal of tha graph rockin a thugged-out depth\(hyfirst search on the
graph followin only reverse arcs.
Da chizzle of roots fo' tha traversal is the
same as busted lyrics bout fo' \fBTV_dfs\fR above.
Da different order of visitation specified by \fBTV_rev\fR,
\fBTV_postrev\fR n' \fBTV_prepostrev\fR is tha same as them
specified by tha analogous traversals \fBTV_dfs\fR,
\fBTV_postdfs\fR n' \fBTV_prepostdfs\fR.
.TP
\fBTV_bfs\fR : \fItvtype_t\fR
A traversal of tha graph rockin a funky-ass breadth\(hyfirst search on the
graph ignorin edge directions. Right back up in yo muthafuckin ass. See tha item on \fBTV_dfs\fR above
for tha role of \fB$tvroot\fP.
.SH EXAMPLES
.PP
.RS
.nf
\fBgvpr \-i 'N[color=="blue"]' file.gv\fP
.fi
.RE
.DT
.PP
Generate tha node\(hyinduced subgraph of all nodes wit color blue.
.PP
.RS
.nf
\fBgvpr \-c 'N[color=="blue"]{color = "red"}' file.gv\fP
.fi
.RE
.DT
.PP
Make all blue nodes red.
.PP
.RS
.nf
\fBBEGIN { int n, e; int tot_n = 0; int tot_e = 0; }
BEG_G {
  n = nNodes($G);
  e = nEdges($G);
  printf ("%d nodes %d edges %s\\n", n, e, $G.name);
  tot_n += n;
  tot_e += e;
}
END { printf ("%d nodes %d edges total\\n", tot_n, tot_e) }\fP
.fi
.RE
.DT
.PP
Version of tha program \fBgc\fP.
.PP
.RS
.nf
\fBgvpr \-c ""\fP
.fi
.RE
.DT
.PP
Equivalent ta \fBnop\fP.
.PP
.RS
.nf
\fBBEG_G { graph_t g = graph ("merge", "S"); }
E {
  node_t h = clone(g,$.head);
  node_t t = clone(g,$.tail);
  edge_t e = edge(t,h,"");
  e.weight = e.weight + 1;
}
END_G { $O = g; }\fP
.fi
.RE
.DT
.PP
Produces a strict version of tha input graph, where tha weight attribute
of a edge indicates how tha fuck nuff edges from tha input graph tha edge represents.
.PP
.RS
.nf
\fBBEGIN {node_t n; int deg[]}
E{deg[head]++; deg[tail]++; }
END_G {
  fo' (deg[n]) {
    printf ("deg[%s] = %d\\n", n.name, deg[n]);
  }
}\fP
.fi
.RE
.DT
.PP
Computes tha degreez of nodes wit edges.
.PP
.RS
.nf
\fBBEGIN {
  int i, indent;
  int seen[string];
  void prInd (int cnt) {
    fo' (i = 0; i < cnt; i++) printf ("  ");
  }
}
BEG_G {

   $tvtype = TV_prepostfwd;
   $tvroot = node($,ARGV[0]);
}
N {
  if (seen[$.name]) indent--;
  else {
    prInd(indent);
      print ($.name);
    seen[$.name] = 1;
    indent++;
  }
}\fP
.fi
.RE
.DT
.PP
Prints tha depth-first traversal of tha graph, starting
with tha node whose name is \fBARGV[0]\fP, as a indented list.
.SH ENVIRONMENT
.TP
.B GVPRPATH
Colon\(hyseparated list of directories ta be searched ta find
the file specified by tha \-f option. I aint talkin' bout chicken n' gravy biatch. \fBgvpr\fP has a thugged-out default list built in. I aint talkin' bout chicken n' gravy biatch. If \fBGVPRPATH\fP
is not defined, tha default list is used. Y'all KNOW dat shit, muthafucka! If \fBGVPRPATH\fP starts wit colon, tha list is formed
by appendin \fBGVPRPATH\fP ta tha default list. If \fBGVPRPATH\fP endz wit colon, tha list is formed
by appendin tha default list ta \fBGVPRPATH\fP. Otherwise, \fBGVPRPATH\fP is used fo' tha list.
.P
On Windows systems, replace ``colon'' wit ``semicolon'' up in tha previous paragraph.
.SH BUGS AND WARNINGS
Scripts should be careful deletin nodes durin \fBN{}\fP n' \fBE{}\fP
blocks rockin BFS n' DFS traversals as these rely on stacks n' queues of
nodes. 
.PP
When tha program is given as a cold-ass lil command line argument, tha usual
shell interpretation takes place, which may affect a shitload of the
special names up in \fBgvpr\fP. To avoid this, it is dopest ta wrap the
program up in single quotes.
.PP
If strang constants contain pattern metacharactas dat you want to
escape ta avoid pattern matching, two backslashes will probably be
necessary, as a single backslash is ghon be lost when tha strang is
originally scanned. Y'all KNOW dat shit, muthafucka! Usually, it is simpla ta use \fBstrcmp\fP to
avoid pattern matching.
.PP
Az of 24 April 2008, \fBgvpr\fP switched ta rockin a new, underlying
graph library, which uses tha simpla model dat there is only one
copy of a node, not one copy fo' each subgraph logically containing
it. This means dat iterators like fuckin \fInxtnode\fP cannot traverse
a subgraph rockin just a node argument. For dis reason, subgraph
traversal requires freshly smoked up functions endin up in "_sg", which also take
a subgraph argument. Da versions without dat suffix will always
traverse tha root graph.
.PP
There be a single global scope, except fo' formal function parameters,
and even these can interfere wit tha type system fo' realz. Also, tha 
extent of all variablez is tha entire game of tha program. 
It might be preferable fo' scope
to reflect tha natural nestin of tha clauses, or fo' tha program
to at least reset locally declared variables.
For now, it be advisable ta use distinct names fo' all variables.
.PP
If a gangbangin' function endz wit a cold-ass lil complex statement, like fuckin an
IF statement, wit each branch bustin a return, type checkin may fail. 
Functions should bust a return all up in tha end.
.PP
Da expr library do not support strang jointz of (char*)0.
This means we can't distinguish between "" n' (char*)0 edge keys.
For tha purposez of lookin up n' bustin edges, we translate "" 
to be (char*)0, since dis latta value is
necessary up in order ta look up any edge wit a matchin head n' tail.
.PP
Related ta this, strings converted ta integers act like char pointers,
gettin tha value 0 or 1 dependin on whether tha strang consists
solely of zeroes or not. Thus, tha ((int)"2") evaluates ta 1.
.PP
Da language inherits tha usual C problems like fuckin danglin references
and tha mad drama between '=' n' '=='.
.SH AUTHOR
Emden R. Gansner <erg@research.att.com>
.SH "SEE ALSO"
.PP
awk(1), gc(1), dot(1), nop(1), expr(3), cgraph(3)
