.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ8 1"
.TH PERLFAQ8 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq8 \- System Interaction
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of tha Perl \s-1FAQ\s0 covers thangs involvin operating
system interaction. I aint talkin' bout chicken n' gravy biatch. Topics include interprocess communication (\s-1IPC\s0),
control over tha user-interface (keyboard, screen n' pointing
devices), n' most anythang else not related ta data manipulation.
.PP
Read tha FAQUIZZYs n' documentation specific ta tha port of perl ta your
operatin system (eg, perlvms, perlplan9, ...). These should
contain mo' detailed shiznit on tha vagariez of yo' perl.
.SS "How tha fuck do I smoke up which operatin system I be hustlin under?"
.IX Subsection "How tha fuck do I smoke up which operatin system I be hustlin under?"
Da \f(CW$^O\fR variable (\f(CW$OSNAME\fR if you use \f(CW\*(C`English\*(C'\fR) gotz nuff an
indication of tha name of tha operatin system (not its release
number) dat yo' perl binary was built for.
.SS "How tha fuck come \fIexec()\fP don't return?"
.IX Xref "exec system fork open pipe"
.IX Subsection "How tha fuck come exec() don't return?"
(contributed by brian d foy)
.PP
Da \f(CW\*(C`exec\*(C'\fR functionz thang is ta turn yo' process tha fuck into another
command n' never ta return, so check it before ya wreck it. I aint talkin' bout chicken n' gravy biatch. If thatz not what tha fuck you wanna do, don't
use \f(CW\*(C`exec\*(C'\fR. :)
.PP
If you wanna run a external command n' still keep yo' Perl process
going, peep a piped \f(CW\*(C`open\*(C'\fR, \f(CW\*(C`fork\*(C'\fR, or \f(CW\*(C`system\*(C'\fR.
.SS "How tha fuck do I do fancy shiznit wit tha keyboard/screen/mouse?"
.IX Subsection "How tha fuck do I do fancy shiznit wit tha keyboard/screen/mouse?"
How tha fuck you access/control keyboards, screens, n' pointin devices
(\*(L"mice\*(R") is system-dependent. Try tha followin modules:
.IP "Keyboard" 4
.IX Item "Keyboard"
.Vb 5
\&    Term::Cap               Standard perl distribution
\&    Term::ReadKey           CPAN
\&    Term::ReadLine::Gnu     CPAN
\&    Term::ReadLine::Perl    CPAN
\&    Term::Screen            CPAN
.Ve
.IP "Screen" 4
.IX Item "Screen"
.Vb 3
\&    Term::Cap               Standard perl distribution
\&    Curses                  CPAN
\&    Term::ANSIColor         CPAN
.Ve
.IP "Mouse" 4
.IX Item "Mouse"
.Vb 4
\&    Tk                      CPAN
\&    Wx                      CPAN
\&    Gtk2                    CPAN
\&    Qt4                     kdebindings4 package
.Ve
.PP
Some of these specific cases is shown as examplez up in other lyrics
in dis section of tha perlfaq.
.SS "How tha fuck do I print suttin' up in color?"
.IX Subsection "How tha fuck do I print suttin' up in color?"
In general, you don't, cuz you don't give a fuck whether
the recipient has a cold-ass lil color-aware display device. If you
know dat they have a \s-1ANSI\s0 terminal dat understands
color, you can use tha Term::ANSIColor module from \s-1CPAN:\s0
.PP
.Vb 3
\&    use Term::ANSIColor;
\&    print color("red"), "Stop!\en", color("reset");
\&    print color("green"), "Go!\en", color("reset");
.Ve
.PP
Or like this:
.PP
.Vb 3
\&    use Term::ANSIColor qw(:constants);
\&    print RED, "Stop!\en", RESET;
\&    print GREEN, "Go!\en", RESET;
.Ve
.SS "How tha fuck do I read just one key without waitin fo' a return key?"
.IX Subsection "How tha fuck do I read just one key without waitin fo' a return key?"
Controllin input bufferin be a remarkably system-dependent matter.
On nuff systems, you can just use tha \fBstty\fR command as shown in
\&\*(L"getc\*(R" up in perlfunc yo, but as you see, thatz already gettin you into
portabilitizzle snags.
.PP
.Vb 6
\&    open(TTY, "+</dev/tty") or take a thugged-out dirtnap "no tty: $!";
\&    system "stty  cbreak </dev/tty >/dev/tty 2>&1";
\&    $key = getc(TTY);        # like dis works
\&    # OR ELSE
\&    sysread(TTY, $key, 1);    # probably dis do
\&    system "stty \-cbreak </dev/tty >/dev/tty 2>&1";
.Ve
.PP
Da Term::ReadKey module from \s-1CPAN\s0 offers a easy as fuck -to-use intercourse that
should be mo' efficient than shellin up ta \fBstty\fR fo' each key.
It even includes limited support fo' Windows.
.PP
.Vb 4
\&    use Term::ReadKey;
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&    $key = ReadKey(0);
\&    ReadMode(\*(Aqnormal\*(Aq);
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat rockin tha code requires dat you gotz a hustlin C compiler
and can use it ta build n' install a \s-1CPAN\s0 module yo. Herez a solution
usin tha standard \s-1POSIX\s0 module, which be already on yo' system
(assumin yo' system supports \s-1POSIX\s0).
.PP
.Vb 2
\&    use HotKey;
\&    $key = readkey();
.Ve
.PP
And herez tha \f(CW\*(C`HotKey\*(C'\fR module, which hides tha somewhat mystifyin calls
to manipulate tha \s-1POSIX\s0 termios structures.
.PP
.Vb 2
\&    # HotKey.pm
\&    package HotKey;
\&
\&    use strict;
\&    use warnings;
\&
\&    use parent \*(AqExporter\*(Aq;
\&    our @EXPORT = qw(cbreak cooked readkey);
\&
\&    use POSIX qw(:termios_h);
\&    mah ($term, $oterm, $echo, $noecho, $fd_stdin);
\&
\&    $fd_stdin = fileno(STDIN);
\&    $term     = POSIX::Termios\->new();
\&    $term\->getattr($fd_stdin);
\&    $oterm     = $term\->getlflag();
\&
\&    $echo     = ECHO | ECHOK | ICANON;
\&    $noecho   = $oterm & ~$echo;
\&
\&    sub cbreak {
\&        $term\->setlflag($noecho);  # ok, so i don\*(Aqt want echo either
\&        $term\->setcc(VTIME, 1);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub cooked {
\&        $term\->setlflag($oterm);
\&        $term\->setcc(VTIME, 0);
\&        $term\->setattr($fd_stdin, TCSANOW);
\&    }
\&
\&    sub readkey {
\&        mah $key = \*(Aq\*(Aq;
\&        cbreak();
\&        sysread(STDIN, $key, 1);
\&        cooked();
\&        return $key;
\&    }
\&
\&    END { cooked() }
\&
\&    1;
.Ve
.SS "How tha fuck do I check whether input is locked n loaded on tha keyboard?"
.IX Subsection "How tha fuck do I check whether input is locked n loaded on tha keyboard?"
Da easiest way ta do dis is ta read a key up in nonblockin mode wit the
Term::ReadKey module from \s-1CPAN,\s0 passin it a argument of \-1 ta indicate
not ta block:
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqcbreak\*(Aq);
\&
\&    if (defined (my $char = ReadKey(\-1)) ) {
\&        # input was waitin n' dat shiznit was $char
\&    } else {
\&        # no input was waiting
\&    }
\&
\&    ReadMode(\*(Aqnormal\*(Aq);                  # restore aiiight tty settings
.Ve
.SS "How tha fuck do I clear tha screen?"
.IX Subsection "How tha fuck do I clear tha screen?"
(contributed by brian d foy)
.PP
To clear tha screen, you just gotta print tha special sequence
that  drops some lyrics ta tha terminal ta clear tha screen. I aint talkin' bout chicken n' gravy biatch. Once you have that
sequence, output it when you wanna clear tha screen.
.PP
Yo ass can use tha Term::ANSIScreen module ta git tha special
sequence. Import tha \f(CW\*(C`cls\*(C'\fR function (or tha \f(CW\*(C`:screen\*(C'\fR tag):
.PP
.Vb 2
\&    use Term::ANSIScreen qw(cls);
\&    mah $clear_screen = cls();
\&
\&    print $clear_screen;
.Ve
.PP
Da Term::Cap module can also git tha special sequence if you want
to deal wit tha low-level detailz of terminal control. Da \f(CW\*(C`Tputs\*(C'\fR
method returns tha strang fo' tha given capability:
.PP
.Vb 1
\&    use Term::Cap;
\&
\&    mah $terminal = Term::Cap\->Tgetent( { OSPEED => 9600 } );
\&    mah $clear_strin = $terminal\->Tputs(\*(Aqcl\*(Aq);
\&
\&    print $clear_screen;
.Ve
.PP
On Windows, you can use tha Win32::Console module fo' realz. Afta bustin
an object fo' tha output filehandle you wanna affect, call the
\&\f(CW\*(C`Cls\*(C'\fR method:
.PP
.Vb 1
\&    Win32::Console;
\&
\&    mah $OUT = Win32::Console\->new(STD_OUTPUT_HANDLE);
\&    mah $clear_strin = $OUT\->Cls;
\&
\&    print $clear_screen;
.Ve
.PP
If you gotz a cold-ass lil command-line program dat do tha thang, you can call
it up in backticks ta capture whatever it outputs so you can use it
later:
.PP
.Vb 1
\&    mah $clear_strin = \`clear\`;
\&
\&    print $clear_string;
.Ve
.SS "How tha fuck do I git tha screen size?"
.IX Subsection "How tha fuck do I git tha screen size?"
If you have Term::ReadKey module installed from \s-1CPAN,\s0
you can use it ta fetch tha width n' height up in characters
and up in pixels:
.PP
.Vb 2
\&    use Term::ReadKey;
\&    mah ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();
.Ve
.PP
This is mo' portable than tha raw \f(CW\*(C`ioctl\*(C'\fR yo, but not as
illustrative:
.PP
.Vb 10
\&    require \*(Aqsys/ioctl.ph\*(Aq;
\&    take a thugged-out dirtnap "no TIOCGWINSZ " unless defined &TIOCGWINSZ;
\&    open(my $tty_fh, "+</dev/tty")                     or take a thugged-out dirtnap "No tty: $!";
\&    unless (ioctl($tty_fh, &TIOCGWINSZ, $winsize=\*(Aq\*(Aq)) {
\&        take a thugged-out dirtnap sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\en", &TIOCGWINSZ;
\&    }
\&    mah ($row, $col, $xpixel, $ypixel) = unpack(\*(AqS4\*(Aq, $winsize);
\&    print "(row,col) = ($row,$col)";
\&    print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
\&    print "\en";
.Ve
.SS "How tha fuck do I ask tha user fo' a password?"
.IX Subsection "How tha fuck do I ask tha user fo' a password?"
(This question has not a god damn thang ta do wit tha web. Right back up in yo muthafuckin ass. See a gangbangin' finger-lickin' different
\&\s-1FAQ\s0 fo' dis shit.)
.PP
Therez a example of dis up in \*(L"crypt\*(R" up in perlfunc). First, you put the
terminal tha fuck into \*(L"no echo\*(R" mode, then just read tha password normally.
Yo ass may do dis wit a old-style \f(CW\*(C`ioctl()\*(C'\fR function, \s-1POSIX\s0 terminal
control (see \s-1POSIX\s0 or its documentation tha Camel Book), or a cold-ass lil call
to tha \fBstty\fR program, wit varyin degreez of portability.
.PP
Yo ass can also do dis fo' most systems rockin tha Term::ReadKey module
from \s-1CPAN,\s0 which is easier ta use n' up in theory mo' portable.
.PP
.Vb 1
\&    use Term::ReadKey;
\&
\&    ReadMode(\*(Aqnoecho\*(Aq);
\&    mah $password = ReadLine(0);
.Ve
.SS "How tha fuck do I read n' write tha serial port?"
.IX Subsection "How tha fuck do I read n' write tha serial port?"
This dependz on which operatin system yo' program is hustlin on. I aint talkin' bout chicken n' gravy biatch. In
the case of Unix, tha serial ports is ghon be accessible all up in filez in
\&\f(CW\*(C`/dev\*(C'\fR; on other systems, thang names will doubtless differ.
Several problem areas common ta all thang interaction is the
following:
.IP "lockfiles" 4
.IX Item "lockfiles"
Yo crazy-ass system may use lockfilez ta control multiple access. Make sure
you follow tha erect protocol. Unpredictable behavior can result
from multiple processes readin from one device.
.IP "open mode" 4
.IX Item "open mode"
If you expect ta use both read n' write operations on tha device,
yo dirty ass is gonna gotta open it fo' update (see \*(L"open\*(R" up in perlfunc for
details). Yo ass may wish ta open it without hustlin tha risk of
blockin by rockin \f(CW\*(C`sysopen()\*(C'\fR n' \f(CW\*(C`O_RDWR|O_NDELAY|O_NOCTTY\*(C'\fR from the
Fcntl module (part of tha standard perl distribution). Right back up in yo muthafuckin ass. See
\&\*(L"sysopen\*(R" up in perlfunc fo' mo' on dis approach.
.IP "end of line" 4
.IX Item "end of line"
Some devices is ghon be expectin a \*(L"\er\*(R" all up in tha end of each line rather
than a \*(L"\en\*(R". In some portz of perl, \*(L"\er\*(R" n' \*(L"\en\*(R" is different from
their usual (Unix) \s-1ASCII\s0 jointz of \*(L"\e015\*(R" n' \*(L"\e012\*(R". Yo ass may have to
give tha numeric joints you want directly, rockin octal (\*(L"\e015\*(R"), hex
(\*(L"0x0D\*(R"), or as a cold-ass lil control-characta justification (\*(L"\ecM\*(R").
.Sp
.Vb 2
\&    print DEV "atv1\e012";    # wrong, fo' some devices
\&    print DEV "atv1\e015";    # right, fo' some devices
.Ve
.Sp
Even though wit aiiight text filez a \*(L"\en\*(R" will do tha trick, there is
still no unified scheme fo' terminatin a line dat is portable
between Unix, DOS/Win, n' Macintosh, except ta terminizzle \fI\s-1ALL\s0\fR line
endz wit \*(L"\e015\e012\*(R", n' strip what tha fuck you don't need from tha output.
This applies especially ta socket I/O n' autoflushing, discussed
next.
.IP "flushin output" 4
.IX Item "flushin output"
If you expect charactas ta git ta yo' thang when you \f(CW\*(C`print()\*(C'\fR them,
yo dirty ass is gonna wanna autoflush dat filehandle. Yo ass can use \f(CW\*(C`select()\*(C'\fR
and tha \f(CW$|\fR variable ta control autoflushin (see \*(L"$|\*(R" up in perlvar
and \*(L"select\*(R" up in perlfunc, or perlfaq5, \*(L"How tha fuck do I flush/unbuffer an
output filehandle, biatch? Why must I do this?\*(R"):
.Sp
.Vb 3
\&    mah $old_handle = select($dev_fh);
\&    $| = 1;
\&    select($old_handle);
.Ve
.Sp
You'll also peep code dat do dis without a temporary variable, as in
.Sp
.Vb 1
\&    select((select($deb_handle), $| = 1)[0]);
.Ve
.Sp
Or if you don't mind pullin up in all dem thousand lines
of code just cuz you afraid of a lil \f(CW$|\fR variable:
.Sp
.Vb 2
\&    use IO::Handle;
\&    $dev_fh\->autoflush(1);
.Ve
.Sp
As mentioned up in tha previous item, dis still don't work when using
socket I/O between Unix n' Macintosh. You'll need ta hard code your
line terminators, up in dat case.
.IP "non-blockin input" 4
.IX Item "non-blockin input"
If yo ass is bustin a funky-ass blockin \f(CW\*(C`read()\*(C'\fR or \f(CW\*(C`sysread()\*(C'\fR, you gonna have to
arrange fo' a alarm handlez ta provide a timeout (see
\&\*(L"alarm\*(R" up in perlfunc). If you gotz a non-blockin open, you gonna likely
have a non-blockin read, which means you may gotta bust a 4\-arg
\&\f(CW\*(C`select()\*(C'\fR ta determine whether I/O is locked n loaded on dat thang (see
\&\*(L"select\*(R" up in perlfunc.
.PP
While tryin ta read from his caller-id box, tha notorious Jamie
Zawinski \f(CW\*(C`<jwz@netscape.com>\*(C'\fR, afta much gnashin of teeth and
fightin wit \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`sysopen\*(C'\fR, \s-1POSIX\s0z \f(CW\*(C`tcgetattr\*(C'\fR bidnizz,
and various other functions dat go bump up in tha night, finally came up
with this:
.PP
.Vb 10
\&    sub open_modem {
\&        use IPC::Open2;
\&        mah $stty = \`/bin/stty \-g\`;
\&        open2( \e*MODEM_IN, \e*MODEM_OUT, "cu \-l$modem_device \-s2400 2>&1");
\&        # startin cu hoses /dev/tty\*(Aqs stty settings, even when it has
\&        # been opened on a pipe...
\&        system("/bin/stty $stty");
\&        $_ = <MODEM_IN>;
\&        chomp;
\&        if ( !m/^Connected/ ) {
\&            print STDERR "$0: cu printed \`$_\*(Aq instead of \`Connected\*(Aq\en";
\&        }
\&    }
.Ve
.SS "How tha fuck do I decode encrypted password files?"
.IX Subsection "How tha fuck do I decode encrypted password files?"
Yo ass spend fuckin shitloadz n' fuckin shitloadz of scrilla on dedicated hardware yo, but dis is
bound ta git you talked about.
.PP
Seriously, you can't if they is Unix password files\*(--the Unix
password system employs one-way encryption. I aint talkin' bout chicken n' gravy biatch. It aint nuthin but mo' like hashing
than encryption. I aint talkin' bout chicken n' gravy biatch. Da dopest you can do is check whether suttin' else
hashes ta tha same string. Yo ass can't turn a hash back tha fuck into the
original gangsta string. Programs like Crack can forcibly (and intelligently)
try ta guess passwordz yo, but don't (can't) guarantee quick success.
.PP
If you worried bout playas selectin wack passwords, you should
proactively check when they try ta chizzle they password (by modifying
\&\fIpasswd\fR\|(1), fo' example).
.SS "How tha fuck do I start a process up in tha background?"
.IX Subsection "How tha fuck do I start a process up in tha background?"
(contributed by brian d foy)
.PP
Therez not a single way ta run code up in tha background so you don't
have ta wait fo' it ta finish before yo' program moves on ta other
tasks. Process pimpment dependz on yo' particular operatin system,
and nuff of tha steez is covered up in perlipc.
.PP
Several \s-1CPAN\s0 modulez may be able ta help, includin IPC::Open2 or
IPC::Open3, IPC::Run, Parallel::Jobs,
Parallel::ForkManager, \s-1POE\s0, Proc::Background, and
Win32::Process. There is nuff other modulez you might use, so
check dem namespaces fo' other options like a muthafucka.
.PP
If yo ass is on a Unix-like system, you might be able ta git away wit a
system call where you put a \f(CW\*(C`&\*(C'\fR on tha end of tha command:
.PP
.Vb 1
\&    system("cmd &")
.Ve
.PP
Yo ass can also try rockin \f(CW\*(C`fork\*(C'\fR, as busted lyrics bout up in perlfunc (although
this is tha same ol' dirty thang dat nuff of tha modulez will do fo' you).
.IP "\s-1STDIN, STDOUT,\s0 n' \s-1STDERR\s0 is shared" 4
.IX Item "STDIN, STDOUT, n' STDERR is shared"
Both tha main process n' tha backgrounded one (the \*(L"child\*(R" process)
share tha same \s-1STDIN, STDOUT\s0 n' \s-1STDERR\s0 filehandles. If both try to
access dem at once, strange thangs can happen. I aint talkin' bout chicken n' gravy biatch. Yo ass may wanna close
or reopen these fo' tha child. Y'all KNOW dat shit, muthafucka! Yo ass can git round dis with
\&\f(CW\*(C`open\*(C'\fRin a pipe (see \*(L"open\*(R" up in perlfunc) but on some systems this
means dat tha lil pimp process cannot outlive tha parent.
.IP "Signals" 4
.IX Item "Signals"
You'll gotta catch tha \s-1SIGCHLD\s0 signal, n' possibly \s-1SIGPIPE\s0 like a muthafucka.
\&\s-1SIGCHLD\s0 is busted when tha backgrounded process finishes. \s-1SIGPIPE\s0 is
sent when you write ta a gangbangin' filehandle whose lil pimp process has closed (an
untrapped \s-1SIGPIPE\s0 can cause yo' program ta silently die). This is
not a issue wit \f(CW\*(C`system("cmd&")\*(C'\fR.
.IP "Zombies" 4
.IX Item "Zombies"
Yo ass gotta be prepared ta \*(L"reap\*(R" tha lil pimp process when it finishes.
.Sp
.Vb 1
\&    $SIG{CHLD} = sub { wait };
\&
\&    $SIG{CHLD} = \*(AqIGNORE\*(Aq;
.Ve
.Sp
Yo ass can also bust a thugged-out double fork. Yo ass immediately \f(CW\*(C`wait()\*(C'\fR fo' your
first child, n' tha init daemon will \f(CW\*(C`wait()\*(C'\fR fo' yo' grandchild once
it exits.
.Sp
.Vb 8
\&    unless ($pid = fork) {
\&        unless (fork) {
\&            exec "what you straight-up wanna do";
\&            take a thugged-out dirtnap "exec failed!";
\&        }
\&        exit 0;
\&    }
\&    waitpid($pid, 0);
.Ve
.Sp
See \*(L"Signals\*(R" up in perlipc fo' other examplez of code ta do all dis bullshit.
Zombies is not a issue wit \f(CW\*(C`system("prog &")\*(C'\fR.
.SS "How tha fuck do I trap control characters/signals?"
.IX Subsection "How tha fuck do I trap control characters/signals?"
Yo ass don't straight-up \*(L"trap\*(R" a cold-ass lil control character n' shit. Instead, dat character
generates a signal which is busted ta yo' terminalz currently
foregrounded process group, which you then trap up in yo' process.
Signals is documented up in \*(L"Signals\*(R" up in perlipc n' the
section on \*(L"Signals\*(R" up in tha Camel.
.PP
Yo ass can set tha jointz of tha \f(CW%SIG\fR hash ta be tha functions you want
to handle tha signal. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack fo' realz. Afta perl catches tha signal, it looks up in \f(CW%SIG\fR
for a key wit tha same name as tha signal, then calls tha subroutine
value fo' dat key.
.PP
.Vb 1
\&    # as a anonymous subroutine
\&
\&    $SIG{INT} = sub { syswrite(STDERR, "ouch\en", 5 ) };
\&
\&    # or a reference ta a gangbangin' function
\&
\&    $SIG{INT} = \e&ouch;
\&
\&    # or tha name of tha function as a string
\&
\&    $SIG{INT} = "ouch";
.Ve
.PP
Perl versions before 5.8 had up in its C source code signal handlezs which
would catch tha signal n' possibly run a Perl function dat you had set
in \f(CW%SIG\fR. This violated tha rulez of signal handlin at dat level
causin perl ta dump core. Right back up in yo muthafuckin ass. Since version 5.8.0, perl looks at \f(CW%SIG\fR
\&\fBafter\fR tha signal has been caught, rather than while it is bein caught.
Previous versionz of dis answer was incorrect.
.SS "How tha fuck do I modify tha shadow password file on a Unix system?"
.IX Subsection "How tha fuck do I modify tha shadow password file on a Unix system?"
If perl was installed erectly n' yo' shadow library was written
properly, tha \f(CW\*(C`getpw*()\*(C'\fR functions busted lyrics bout up in perlfunc should in
theory provide (read-only) access ta entries up in tha shadow password
file. To chizzle tha file, cook up a freshly smoked up shadow password file (the format
varies from system ta system\*(--see \fIpasswd\fR\|(1) fo' specifics) n' use
\&\f(CWpwd_mkdb(8)\fR ta install it (see \fIpwd_mkdb\fR\|(8) fo' mo' details).
.SS "How tha fuck do I set tha time n' date?"
.IX Subsection "How tha fuck do I set tha time n' date?"
Assumin you hustlin under sufficient permissions, you should be
able ta set tha system-wide date n' time by hustlin tha \f(CWdate(1)\fR
program. (There is no way ta set tha time n' date on a per-process
basis.)  This mechanizzle will work fo' Unix, MS-DOS, Windows, n' \s-1NT\s0;
the \s-1VMS\s0 equivalent is \f(CW\*(C`set time\*(C'\fR.
.PP
But fuck dat shiznit yo, tha word on tha street is dat if all you wanna do is chizzle yo' time unit, you can
probably git away wit settin a environment variable:
.PP
.Vb 3
\&    $ENV{TZ} = "MST7MDT";           # Unixish
\&    $ENV{\*(AqSYS$TIMEZONE_DIFFERENTIAL\*(Aq}="\-5" # vms
\&    system(\*(Aqtrn\*(Aq, \*(Aqcomp.lang.perl.misc\*(Aq);
.Ve
.SS "How tha fuck can I \fIsleep()\fP or \fIalarm()\fP fo' under a second?"
.IX Xref "Time::HiRes BSD::Itimer chill select"
.IX Subsection "How tha fuck can I chill() or alarm() fo' under a second?"
If you want finer granularitizzle than tha 1 second dat tha \f(CW\*(C`sleep()\*(C'\fR
function provides, tha easiest way is ta use tha \f(CW\*(C`select()\*(C'\fR function as
documented up in \*(L"select\*(R" up in perlfunc. Try tha Time::HiRes and
the BSD::Itimer modulez (available from \s-1CPAN,\s0 n' startin from
Perl 5.8 Time::HiRes is part of tha standard distribution).
.SS "How tha fuck can I measure time under a second?"
.IX Xref "Time::HiRes BSD::Itimer chill select"
.IX Subsection "How tha fuck can I measure time under a second?"
(contributed by brian d foy)
.PP
Da Time::HiRes module (part of tha standard distribution as of
Perl 5.8) measures time wit tha \f(CW\*(C`gettimeofday()\*(C'\fR system call, which
returns tha time up in microsecondz since tha epoch. If you can't install
Time::HiRes fo' olda Perls n' yo ass is on a Unixish system, you
may be able ta booty-call \f(CWgettimeofday(2)\fR directly. Right back up in yo muthafuckin ass. See
\&\*(L"syscall\*(R" up in perlfunc.
.SS "How tha fuck can I do a \fIatexit()\fP or \fIsetjmp()\fP/\fIlongjmp()\fP, biatch? (Exception handling)"
.IX Subsection "How tha fuck can I do a atexit() or setjmp()/longjmp(), biatch? (Exception handling)"
Yo ass can use tha \f(CW\*(C`END\*(C'\fR block ta simulate \f(CW\*(C`atexit()\*(C'\fR. Each package's
\&\f(CW\*(C`END\*(C'\fR block is called when tha program or thread ends. Right back up in yo muthafuckin ass. See tha perlmod
manpage fo' mo' details bout \f(CW\*(C`END\*(C'\fR blocks.
.PP
For example, you can use dis ta make shizzle yo' filta program managed
to finish its output without fillin up tha disk:
.PP
.Vb 3
\&    END {
\&        close(STDOUT) || take a thugged-out dirtnap "stdout close failed: $!";
\&    }
.Ve
.PP
Da \f(CW\*(C`END\*(C'\fR block aint called when untrapped signals bust a cap up in tha program,
though, so if you use \f(CW\*(C`END\*(C'\fR blocks you should also use
.PP
.Vb 1
\&    use sigtrap qw(die normal\-signals);
.Ve
.PP
Perlz exception-handlin mechanizzle is its \f(CW\*(C`eval()\*(C'\fR operator. Shiiit, dis aint no joke. You
can use \f(CW\*(C`eval()\*(C'\fR as \f(CW\*(C`setjmp\*(C'\fR n' \f(CW\*(C`die()\*(C'\fR as \f(CW\*(C`longjmp\*(C'\fR. For
detailz of this, peep tha section on signals, especially tha time-out
handlez fo' a funky-ass blockin \f(CW\*(C`flock()\*(C'\fR up in \*(L"Signals\*(R" up in perlipc or the
section on \*(L"Signals\*(R" up in \fIProgrammin Perl\fR.
.PP
If exception handlin be all you interested in, use one of the
many \s-1CPAN\s0 modulez dat handle exceptions, like fuckin Try::Tiny.
.PP
If you want tha \f(CW\*(C`atexit()\*(C'\fR syntax (and a \f(CW\*(C`rmexit()\*(C'\fR as well), try the
\&\f(CW\*(C`AtExit\*(C'\fR module available from \s-1CPAN.\s0
.ie n .SS "Why don't mah sockets program work under System V (Solaris), biatch? What do tha error message ""Protocol not supported"" mean?"
.el .SS "Why don't mah sockets program work under System V (Solaris), biatch? What do tha error message ``Protocol not supported'' mean?"
.IX Subsection "Why don't mah sockets program work under System V (Solaris), biatch? What do tha error message Protocol not supported mean?"
Some Sys-V based systems, notably Solaris 2.X, redefined a shitload of the
standard socket constants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Since these was constant across all
architectures, they was often hardwired tha fuck into perl code. Da proper
way ta deal wit dis is ta \*(L"use Socket\*(R" ta git tha erect joints.
.PP
Note dat even though SunOS n' Solaris is binary compatible, these
values is different. Go figure.
.SS "How tha fuck can I call mah systemz unique C functions from Perl?"
.IX Subsection "How tha fuck can I call mah systemz unique C functions from Perl?"
In most cases, you write a external module ta do it\*(--see tha answer
to \*(L"Where can I learn bout linkin C wit Perl, biatch? [h2xs, xsubpp]\*(R".
But fuck dat shiznit yo, tha word on tha street is dat if tha function be a system call, n' yo' system supports
\&\f(CW\*(C`syscall()\*(C'\fR, you can use tha \f(CW\*(C`syscall\*(C'\fR function (documented in
perlfunc).
.PP
Remember ta check tha modulez dat came wit yo' distribution, and
\&\s-1CPAN\s0 as well\*(--someone may already have freestyled a module ta do dat shit. On
Windows, try Win32::API. On Macs, try Mac::Carbon. I aint talkin' bout chicken n' gravy biatch. If no module
has a intercourse ta tha C function, you can inline a lil' bit of C up in your
Perl source wit Inline::C.
.SS "Where do I git tha include filez ta do \fIioctl()\fP or \fIsyscall()\fP?"
.IX Subsection "Where do I git tha include filez ta do ioctl() or syscall()?"
Historically, these would be generated by tha h2ph tool, part of the
standard perl distribution. I aint talkin' bout chicken n' gravy biatch. This program converts \f(CWcpp(1)\fR directives
in C header filez ta filez containin subroutine definitions, like
\&\f(CW\*(C`SYS_getitimer()\*(C'\fR, which you can use as arguments ta yo' functions.
It don't work perfectly yo, but it probably gets most of tha thang done.
Simple filez like \fIerrno.h\fR, \fIsyscall.h\fR, n' \fIsocket.h\fR was fine,
but tha hard ones like \fIioctl.h\fR nearly always need ta be hand-edited.
Herez how tha fuck ta install tha *.ph files:
.PP
.Vb 3
\&    1. Become tha super\-user
\&    2. cd /usr/include
\&    3. h2ph *.h */*.h
.Ve
.PP
If yo' system supports dynamic loading, fo' reasonz of portabilitizzle and
sanitizzle you probably ought ta use h2xs (also part of tha standard perl
distribution). This tool converts C header filez ta Perl extensions.
See perlxstut fo' how tha fuck ta git started wit h2xs.
.PP
If yo' system don't support dynamic loading, you still probably
ought ta use h2xs. Right back up in yo muthafuckin ass. See perlxstut n' ExtUtils::MakeMaker for
more shiznit (in brief, just use \fBmake perl\fR instead of a plain
\&\fBmake\fR ta rebuild perl wit a freshly smoked up static extension).
.SS "Why do setuid perl scripts diss bout kernel problems?"
.IX Subsection "Why do setuid perl scripts diss bout kernel problems?"
Some operatin systems have bugs up in tha kernel dat make setuid
scripts inherently insecure. Perl gives you a fuckin shitload of options
(busted lyrics bout up in perlsec) ta work round such systems.
.SS "How tha fuck can I open a pipe both ta n' from a cold-ass lil command?"
.IX Subsection "How tha fuck can I open a pipe both ta n' from a cold-ass lil command?"
Da IPC::Open2 module (part of tha standard perl distribution) is
an easy as fuck -to-use approach dat internally uses \f(CW\*(C`pipe()\*(C'\fR, \f(CW\*(C`fork()\*(C'\fR, and
\&\f(CW\*(C`exec()\*(C'\fR ta do tha thang. Make shizzle you read tha deadlock warnings in
its documentation, though (see IPC::Open2). Right back up in yo muthafuckin ass. See
\&\*(L"Bidirectionizzle Communication wit Another Process\*(R" up in perlipc and
\&\*(L"Bidirectionizzle Communication wit Yourself\*(R" up in perlipc
.PP
Yo ass may also use tha IPC::Open3 module (part of tha standard perl
distribution) yo, but be warned dat it has a gangbangin' finger-lickin' different order of
arguments from IPC::Open2 (see IPC::Open3).
.SS "Why can't I git tha output of a cold-ass lil command wit \fIsystem()\fP?"
.IX Subsection "Why can't I git tha output of a cold-ass lil command wit system()?"
Yo ass is confusin tha purpose of \f(CW\*(C`system()\*(C'\fR n' backticks (``). \f(CW\*(C`system()\*(C'\fR
runs a cold-ass lil command n' returns exit status shiznit (as a 16 bit value:
the low 7 bits is tha signal tha process took a dirt nap from, if any, and
the high 8 bits is tha actual exit value). Backticks (``) run a
command n' return what tha fuck it busted ta \s-1STDOUT.\s0
.PP
.Vb 2
\&    mah $exit_status   = system("mail\-users");
\&    mah $output_strin = \`ls\`;
.Ve
.SS "How tha fuck can I capture \s-1STDERR\s0 from a external command?"
.IX Subsection "How tha fuck can I capture STDERR from a external command?"
There is three basic wayz of hustlin external commands:
.PP
.Vb 3
\&    system $cmd;        # rockin system()
\&    mah $output = \`$cmd\`;        # rockin backticks (\`\`)
\&    open (my $pipe_fh, "$cmd |");    # rockin open()
.Ve
.PP
With \f(CW\*(C`system()\*(C'\fR, both \s-1STDOUT\s0 n' \s-1STDERR\s0 will go tha same place as the
scriptz \s-1STDOUT\s0 n' \s-1STDERR,\s0 unless tha \f(CW\*(C`system()\*(C'\fR command redirects em.
Backticks n' \f(CW\*(C`open()\*(C'\fR read \fBonly\fR tha \s-1STDOUT\s0 of yo' command.
.PP
Yo ass can also use tha \f(CW\*(C`open3()\*(C'\fR function from IPC::Open3. Benjamin
Goldberg serves up some sample code:
.PP
To capture a programz \s-1STDOUT,\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    mah $pid = open3(gensym, \e*PH, ">&NULL", "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a programz \s-1STDERR,\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 7
\&    use IPC::Open3;
\&    use File::Spec;
\&    use Symbol qw(gensym);
\&    open(NULL, ">", File::Spec\->devnull);
\&    mah $pid = open3(gensym, ">&NULL", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To capture a programz \s-1STDERR,\s0 n' let its \s-1STDOUT\s0 git all up in our own \s-1STDERR:\s0
.PP
.Vb 5
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    mah $pid = open3(gensym, ">&STDERR", \e*PH, "cmd");
\&    while( <PH> ) { }
\&    waitpid($pid, 0);
.Ve
.PP
To read both a cold-ass lil commandz \s-1STDOUT\s0 n' its \s-1STDERR\s0 separately, you can
redirect dem ta temp files, let tha command run, then read tha temp
files:
.PP
.Vb 10
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHOUT = IO::File\->new_tmpfile;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    mah $pid = open3(gensym, ">&CATCHOUT", ">&CATCHERR", "cmd");
\&    waitpid($pid, 0);
\&    seek $_, 0, 0 fo' \e*CATCHOUT, \e*CATCHERR;
\&    while( <CATCHOUT> ) {}
\&    while( <CATCHERR> ) {}
.Ve
.PP
But there be a no real need fo' \fBboth\fR ta be tempfiles... tha following
should work just as well, without deadlocking:
.PP
.Vb 9
\&    use IPC::Open3;
\&    use Symbol qw(gensym);
\&    use IO::File;
\&    local *CATCHERR = IO::File\->new_tmpfile;
\&    mah $pid = open3(gensym, \e*CATCHOUT, ">&CATCHERR", "cmd");
\&    while( <CATCHOUT> ) {}
\&    waitpid($pid, 0);
\&    seek CATCHERR, 0, 0;
\&    while( <CATCHERR> ) {}
.Ve
.PP
And it'll be faster, too, since we can begin processin tha program's
stdout immediately, rather than waitin fo' tha program ta finish.
.PP
With any of these, you can chizzle file descriptors before tha call:
.PP
.Vb 2
\&    open(STDOUT, ">logfile");
\&    system("ls");
.Ve
.PP
or you can use Bourne shell file-descriptor redirection:
.PP
.Vb 2
\&    $output = \`$cmd 2>some_file\`;
\&    open (PIPE, "cmd 2>some_file |");
.Ve
.PP
Yo ass can also use file-descriptor redirection ta make \s-1STDERR\s0 a
duplicate of \s-1STDOUT:\s0
.PP
.Vb 2
\&    $output = \`$cmd 2>&1\`;
\&    open (PIPE, "cmd 2>&1 |");
.Ve
.PP
Note dat you \fIcannot\fR simply open \s-1STDERR\s0 ta be a thugged-out dup of \s-1STDOUT\s0
in yo' Perl program n' avoid callin tha shell ta do tha redirection.
This don't work:
.PP
.Vb 2
\&    open(STDERR, ">&STDOUT");
\&    $alloutput = \`cmd args\`;  # stderr still escapes
.Ve
.PP
This fails cuz tha \f(CW\*(C`open()\*(C'\fR make \s-1STDERR\s0 git all up in where \s-1STDOUT\s0 was
goin all up in tha time of tha \f(CW\*(C`open()\*(C'\fR. Da backticks then make \s-1STDOUT\s0 go to
a strin yo, but don't chizzle \s-1STDERR \s0(which still goes ta tha old
\&\s-1STDOUT\s0).
.PP
Note dat you \fImust\fR use Bourne shell (\f(CWsh(1)\fR) redirection syntax in
backticks, not \f(CWcsh(1)\fR!  Details on why Perlz \f(CW\*(C`system()\*(C'\fR n' backtick
and pipe opens all use tha Bourne shell is up in the
\&\fIversus/csh.whynot\fR article up in tha \*(L"Far Mo' Than Yo ass Ever Wanted To
Know\*(R" collection up in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> . To
capture a cold-ass lil commandz \s-1STDERR\s0 n' \s-1STDOUT\s0 together:
.PP
.Vb 3
\&    $output = \`cmd 2>&1\`;                       # either wit backticks
\&    $pid = open(PH, "cmd 2>&1 |");              # or wit a open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a cold-ass lil commandz \s-1STDOUT\s0 but discard its \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>/dev/null\`;                # either wit backticks
\&    $pid = open(PH, "cmd 2>/dev/null |");       # or wit a open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To capture a cold-ass lil commandz \s-1STDERR\s0 but discard its \s-1STDOUT:\s0
.PP
.Vb 3
\&    $output = \`cmd 2>&1 1>/dev/null\`;           # either wit backticks
\&    $pid = open(PH, "cmd 2>&1 1>/dev/null |");  # or wit a open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To exchange a cold-ass lil commandz \s-1STDOUT\s0 n' \s-1STDERR\s0 up in order ta capture tha \s-1STDERR\s0
but leave its \s-1STDOUT\s0 ta come up our oldschool \s-1STDERR:\s0
.PP
.Vb 3
\&    $output = \`cmd 3>&1 1>&2 2>&3 3>&\-\`;        # either wit backticks
\&    $pid = open(PH, "cmd 3>&1 1>&2 2>&3 3>&\-|");# or wit a open pipe
\&    while (<PH>) { }                            #    plus a read
.Ve
.PP
To read both a cold-ass lil commandz \s-1STDOUT\s0 n' its \s-1STDERR\s0 separately, itz easiest
to redirect dem separately ta files, n' then read from dem files
when tha program is done:
.PP
.Vb 1
\&    system("program args 1>program.stdout 2>program.stderr");
.Ve
.PP
Orderin is blingin up in all these examples. Thatz cuz tha shell
processes file descriptor redirections up in strictly left ta right order.
.PP
.Vb 2
\&    system("prog args 1>tmpfile 2>&1");
\&    system("prog args 2>&1 1>tmpfile");
.Ve
.PP
Da first command sendz both standard up n' standard error ta the
temporary file. Da second command sendz only tha oldschool standard output
there, n' tha oldschool standard error shows up on tha oldschool standard out.
.SS "Why don't \fIopen()\fP return a error when a pipe open fails?"
.IX Subsection "Why don't open() return a error when a pipe open fails?"
If tha second argument ta a piped \f(CW\*(C`open()\*(C'\fR gotz nuff shell
metacharacters, perl \f(CW\*(C`fork()\*(C'\fRs, then \f(CW\*(C`exec()\*(C'\fRs a gangbangin' finger-lickin' dirty-ass shell ta decode the
metacharactas n' eventually run tha desired program. If tha program
couldn't be run, itz tha shell dat gets tha message, not Perl fo' realz. All
your Perl program can smoke up is whether tha shell itself could be
successfully started. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. Yo ass can still capture tha shellz \s-1STDERR\s0 and
check it fo' error lyrics. Right back up in yo muthafuckin ass. See \*(L"How tha fuck can I capture \s-1STDERR\s0 from an
external command?\*(R" elsewhere up in dis document, or use the
IPC::Open3 module.
.PP
If there be no shell metacharactas up in tha argument of \f(CW\*(C`open()\*(C'\fR, Perl
runs tha command directly, without rockin tha shell, n' can erectly
report whether tha command started.
.SS "Whatz wack wit rockin backticks up in a void context?"
.IX Subsection "Whatz wack wit rockin backticks up in a void context?"
Strictly bustin lyrics, nothing. Right back up in yo muthafuckin ass. Stylistically bustin lyrics, it aint a good
way ta write maintainable code. Perl has nuff muthafuckin operators for
runnin external commands. Backticks is one; they collect tha output
from tha command fo' use up in yo' program. Da \f(CW\*(C`system\*(C'\fR function is
another; it don't do all dis bullshit.
.PP
Freestylin backticks up in yo' program sendz a cold-ass lil clear message ta tha readers
of yo' code dat you wanted ta collect tha output of tha command.
Why bust a cold-ass lil clear message dat aint true?
.PP
Consider dis line:
.PP
.Vb 1
\&    \`cat /etc/termcap\`;
.Ve
.PP
Yo ass forgot ta check \f(CW$?\fR ta peep whether tha program even ran
correctly. Even if you wrote
.PP
.Vb 1
\&    print \`cat /etc/termcap\`;
.Ve
.PP
this code could n' probably should be freestyled as
.PP
.Vb 2
\&    system("cat /etc/termcap") == 0
\&    or take a thugged-out dirtnap "cat program failed!";
.Ve
.PP
which will echo tha pussaaaaay commandz output as it is generated, instead
of waitin until tha program has completed ta print it out. Well shiiiit, it also
checks tha return value.
.PP
\&\f(CW\*(C`system\*(C'\fR also serves up direct control over whether shell wildcard
processin may take place, whereas backticks do not.
.SS "How tha fuck can I call backticks without shell processing?"
.IX Subsection "How tha fuck can I call backticks without shell processing?"
This be a lil' bit tricky. Yo ass can't simply write tha command
like this:
.PP
.Vb 1
\&    @ok = \`grep @opts \*(Aq$search_string\*(Aq @filenames\`;
.Ve
.PP
Az of Perl 5.8.0, you can use \f(CW\*(C`open()\*(C'\fR wit multiple arguments.
Just like tha list formz of \f(CW\*(C`system()\*(C'\fR n' \f(CW\*(C`exec()\*(C'\fR, no shell
escapes happen.
.PP
.Vb 3
\&    open( GREP, "\-|", \*(Aqgrep\*(Aq, @opts, $search_string, @filenames );
\&    chomp(@ok = <GREP>);
\&    close GREP;
.Ve
.PP
Yo ass can also:
.PP
.Vb 10
\&    mah @ok = ();
\&    if (open(GREP, "\-|")) {
\&        while (<GREP>) {
\&            chomp;
\&            push(@ok, $_);
\&        }
\&        close GREP;
\&    } else {
\&        exec \*(Aqgrep\*(Aq, @opts, $search_string, @filenames;
\&    }
.Ve
.PP
Just as wit \f(CW\*(C`system()\*(C'\fR, no shell escapes happen when you \f(CW\*(C`exec()\*(C'\fR a
list. Further examplez of dis can be found up in \*(L"Safe Pipe
Opens\*(R" up in perlipc.
.PP
Note dat if you rockin Windows, no solution ta dis vexin issue is
even possible. Even though Perl emulates \f(CW\*(C`fork()\*(C'\fR, you gonna still be
stuck, cuz Windows aint gots a argc/argv\-style \s-1API.\s0
.SS "Why can't mah script read from \s-1STDIN\s0 afta I gave it \s-1EOF \s0(^D on Unix, ^Z on MS-DOS)?"
.IX Subsection "Why can't mah script read from STDIN afta I gave it EOF (^D on Unix, ^Z on MS-DOS)?"
This happens only if yo' perl is compiled ta use stdio instead of
perlio, which is tha default. Right back up in yo muthafuckin ass. Some (maybe all?) stdios set error and
eof flags dat you may need ta clear. Shiiit, dis aint no joke. Da \s-1POSIX\s0 module defines
\&\f(CW\*(C`clearerr()\*(C'\fR dat you can use. That is tha technologically erect way to
do it yo. Here is some less reliable workarounds:
.IP "1." 4
Try keepin round tha seekpointa n' go there, like this:
.Sp
.Vb 2
\&    mah $where = tell($log_fh);
\&    seek($log_fh, $where, 0);
.Ve
.IP "2." 4
If dat don't work, try seekin ta a gangbangin' finger-lickin' different part of tha file and
then back.
.IP "3." 4
If dat don't work, try seekin ta a gangbangin' finger-lickin' different part of
the file, readin something, n' then seekin back.
.IP "4." 4
If dat don't work, give up on yo' stdio package n' use sysread.
.SS "How tha fuck can I convert mah shell script ta perl?"
.IX Subsection "How tha fuck can I convert mah shell script ta perl?"
Peep Perl n' rewrite dat shit. Right back up in yo muthafuckin ass. Seriously, there be a no simple converter.
Things dat is awkward ta do up in tha shell is easy as fuck  ta do up in Perl, and
this straight-up awkwardnizz is what tha fuck would cook up a gangbangin' finger-lickin' dirty-ass shell\->perl converter
nigh-on impossible ta write. By rewritin it, you gonna be thinkin bout what
yo ass is straight-up tryin ta do, n' hopefully will escape tha shell's
pipeline datastream paradigm, which while convenient fo' some matters,
causes nuff inefficiencies.
.SS "Can I use perl ta run a telnet or ftp session?"
.IX Subsection "Can I use perl ta run a telnet or ftp session?"
Try tha Net::FTP, TCP::Client, n' Net::Telnet modules
(available from \s-1CPAN\s0).
<http://www.cpan.org/scripts/netstuff/telnet.emul.shar> will also help
for emulatin tha telnet protocol yo, but Net::Telnet is quite
probably easier ta use.
.PP
If all you wanna do is pretend ta be telnet but don't need
the initial telnet handbobbin, then tha standard dual-process
approach will suffice:
.PP
.Vb 12
\&    use IO::Socket;             # freshly smoked up in 5.004
\&    mah $handle = IO::Socket::INET\->new(\*(Aqwww.perl.com:80\*(Aq)
\&        or take a thugged-out dirtnap "can\*(Aqt connect ta port 80 on www.perl.com $!";
\&    $handle\->autoflush(1);
\&    if (fork()) {               # XXX: undef means failure
\&        select($handle);
\&        print while <STDIN>;    # every last muthafuckin thang from stdin ta socket
\&    } else {
\&        print while <$handle>;  # every last muthafuckin thang from socket ta stdout
\&    }
\&    close $handle;
\&    exit;
.Ve
.SS "How tha fuck can I write expect up in Perl?"
.IX Subsection "How tha fuck can I write expect up in Perl?"
Back up in tha day, there was a library called \fIchat2.pl\fR (part of the
standard perl distribution), which never straight-up gots finished. Y'all KNOW dat shit, muthafucka! If you
find it somewhere, \fIdon't use it\fR. These days, yo' dopest bet is to
peep tha Expect module available from \s-1CPAN,\s0 which also requires two
other modulez from \s-1CPAN, \s0IO::Pty n' IO::Stty.
.ie n .SS "Is there a way ta hide perlz command line from programs like fuckin ""ps""?"
.el .SS "Is there a way ta hide perlz command line from programs like fuckin ``ps''?"
.IX Subsection "Is there a way ta hide perlz command line from programs like fuckin ps?"
First of all note dat if you bustin dis fo' securitizzle reasons (to
avoid playas seein passwords, fo' example) then you should rewrite
your program so dat critical shiznit is never given as an
argument yo. Hidin tha arguments won't make yo' program straight-up
secure.
.PP
To straight-up alta tha visible command line, you can assign ta the
variable \f(CW$0\fR as documented up in perlvar. Shiiit, dis aint no joke. This won't work on all
operatin systems, though cause I gots dem finger-lickin' chickens wit tha siz-auce. Daemon programs like sendmail place their
state there, as in:
.PP
.Vb 1
\&    $0 = "orcus [acceptin connections]";
.Ve
.SS "I {changed directory, modified mah environment} up in a perl script yo. How tha fuck come tha chizzle disappeared when I exited tha script, biatch? How tha fuck do I git mah chizzlez ta be visible?"
.IX Subsection "I {changed directory, modified mah environment} up in a perl script yo. How tha fuck come tha chizzle disappeared when I exited tha script, biatch? How tha fuck do I git mah chizzlez ta be visible?"
.IP "Unix" 4
.IX Item "Unix"
In tha strictest sense, it can't be done\*(--the script executes as a
different process from tha shell dat shiznit was started from. Chizzlez ta a
process is not reflected up in its parent\*(--only up in any children
created afta tha chizzle. There is shell magic dat may allow you to
fake it by \f(CW\*(C`eval()\*(C'\fRin tha scriptz output up in yo' shell; check up the
comp.unix.questions \s-1FAQ\s0 fo' details.
.SS "How tha fuck do I close a processs filehandle without waitin fo' it ta complete?"
.IX Subsection "How tha fuck do I close a processs filehandle without waitin fo' it ta complete?"
Assumin yo' system supports such thangs, just bust a appropriate signal
to tha process (see \*(L"kill\*(R" up in perlfunc). It aint nuthin but common ta first bust a \s-1TERM\s0
signal, wait a lil bit, n' then bust a \s-1KILL\s0 signal ta finish it off.
.SS "How tha fuck do I fork a thugged-out daemon process?"
.IX Subsection "How tha fuck do I fork a thugged-out daemon process?"
If by daemon process you mean one thatz detached (disassociated from
its tty), then tha followin process is reported ta work on most
Unixish systems. Non-Unix playas should check they Your_OS::Process
module fo' other solutions.
.IP "\(bu" 4
Open /dev/tty n' use tha \s-1TIOCNOTTY\s0 ioctl on dat shit. Right back up in yo muthafuckin ass. See \fItty\fR\|(1)
for details. Or betta yet, you can just use tha \f(CW\*(C`POSIX::setsid()\*(C'\fR
function, so you don't gotta worry bout process groups.
.IP "\(bu" 4
Change directory ta /
.IP "\(bu" 4
Reopen \s-1STDIN, STDOUT,\s0 n' \s-1STDERR\s0 so they not connected ta tha old
tty.
.IP "\(bu" 4
Background yo ass like this:
.Sp
.Vb 1
\&    fork && exit;
.Ve
.PP
Da Proc::Daemon module, available from \s-1CPAN,\s0 serves up a gangbangin' function to
perform these actions fo' yo thugged-out ass.
.SS "How tha fuck do I smoke up if I be hustlin interactively or not?"
.IX Subsection "How tha fuck do I smoke up if I be hustlin interactively or not?"
(contributed by brian d foy)
.PP
This be a gangbangin' finger-lickin' hard as fuck question ta answer, n' tha dopest answer is
only a guess.
.PP
What do you straight-up wanna know, biatch? If you merely wanna know if one of
your filehandlez is connected ta a terminal, you can try tha \f(CW\*(C`\-t\*(C'\fR
file test:
.PP
.Vb 3
\&    if( \-t STDOUT ) {
\&        print "I\*(Aqm connected ta a terminal!\en";
\&    }
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat you might be outta luck if you expect dat means there be a
real thug on tha other side. With tha Expect module, another
program can pretend ta be a person. I aint talkin' bout chicken n' gravy biatch. Da program might even come close
to passin tha Turin test.
.PP
Da IO::Interactizzle module do tha dopest it can ta hit you wit an
answer n' shit. Its \f(CW\*(C`is_interactive\*(C'\fR function returns a output filehandle;
that filehandle points ta standard output if tha module be thinkin the
session is interactive. Otherwise, tha filehandle be a null handle
that simply discardz tha output:
.PP
.Vb 1
\&    use IO::Interactive;
\&
\&    print { is_interactizzle } "I might git all up in standard output!\en";
.Ve
.PP
This still don't guarantee dat a real thug be answerin your
prompts or readin yo' output.
.PP
If you wanna know how tha fuck ta handle automated testin fo' your
distribution, you can check tha environment. Da \s-1CPAN\s0
Testers, fo' instance, set tha value of \f(CW\*(C`AUTOMATED_TESTING\*(C'\fR:
.PP
.Vb 3
\&    unless( $ENV{AUTOMATED_TESTING} ) {
\&        print "Wuz crackalackin' interactizzle tester!\en";
\&    }
.Ve
.SS "How tha fuck do I timeout a slow event?"
.IX Subsection "How tha fuck do I timeout a slow event?"
Use tha \f(CW\*(C`alarm()\*(C'\fR function, probably up in conjunction wit a signal
handlez, as documented up in \*(L"Signals\*(R" up in perlipc n' tha section on
\&\*(L"Signals\*(R" up in tha Camel. Yo ass may instead use tha mo' flexible
Sys::AlarmCall module available from \s-1CPAN.\s0
.PP
Da \f(CW\*(C`alarm()\*(C'\fR function aint implemented on all versionz of Windows.
Peep tha documentation fo' yo' specific version of Perl.
.SS "How tha fuck do I set \s-1CPU\s0 limits?"
.IX Xref "BSD::Resource limit CPU"
.IX Subsection "How tha fuck do I set CPU limits?"
(contributed by Xho)
.PP
Use tha BSD::Resource module from \s-1CPAN.\s0 As a example:
.PP
.Vb 2
\&    use BSD::Resource;
\&    setrlimit(RLIMIT_CPU,10,20) or take a thugged-out dirtnap $!;
.Ve
.PP
This sets tha soft n' hard limits ta 10 n' 20 seconds, respectively.
Afta 10 secondz of time dropped hustlin on tha \s-1CPU \s0(not \*(L"wall\*(R" time),
the process is ghon be busted a signal (\s-1XCPU\s0 on some systems) which, if not
trapped, will cause tha process ta terminate. If dat signal is
trapped, then afta 10 mo' secondz (20 secondz up in total) tha process
will be capped wit a non-trappable signal.
.PP
See tha BSD::Resource n' yo' systems documentation fo' tha gory
details.
.SS "How tha fuck do I avoid zombies on a Unix system?"
.IX Subsection "How tha fuck do I avoid zombies on a Unix system?"
Use tha reaper code from \*(L"Signals\*(R" up in perlipc ta booty-call \f(CW\*(C`wait()\*(C'\fR when a
\&\s-1SIGCHLD\s0 is received, or else use tha double-fork technique busted lyrics about
in \*(L"How tha fuck do I start a process up in tha background?\*(R" up in perlfaq8.
.SS "How tha fuck do I use a \s-1SQL\s0 database?"
.IX Subsection "How tha fuck do I use a SQL database?"
Da \s-1DBI\s0 module serves up a abstract intercourse ta most database
servers n' types, includin Oracle, \s-1DB2,\s0 Sybase, mysql, Postgresql,
\&\s-1ODBC,\s0 n' flat files. Da \s-1DBI\s0 module accesses each database type
all up in a thugged-out database driver, or \s-1DBD.\s0 Yo ass can peep a cold-ass lil complete list of
available drivers on \s-1CPAN: \s0<http://www.cpan.org/modules/by\-module/DBD/> .
Yo ass can read mo' bout \s-1DBI\s0 on <http://dbi.perl.org/> .
.PP
Other modulez provide mo' specific access: Win32::ODBC, Alzabo,
\&\f(CW\*(C`iodbc\*(C'\fR, n' others found on \s-1CPAN\s0 Search: <http://search.cpan.org/> .
.SS "How tha fuck do I cook up a \fIsystem()\fP exit on control-C?"
.IX Subsection "How tha fuck do I cook up a system() exit on control-C?"
Yo ass can't. Yo ass need ta imitate tha \f(CW\*(C`system()\*(C'\fR call (see perlipc for
sample code) n' then gotz a signal handlez fo' tha \s-1INT\s0 signal that
passes tha signal on ta tha subprocess. Or you can check fo' it:
.PP
.Vb 2
\&    $rc = system($cmd);
\&    if ($rc & 127) { take a thugged-out dirtnap "signal dirtnap" }
.Ve
.SS "How tha fuck do I open a gangbangin' file without blocking?"
.IX Subsection "How tha fuck do I open a gangbangin' file without blocking?"
If you dirty enough ta be rockin a system dat supports
non-blockin readz (most Unixish systems do), you need only ta use the
\&\f(CW\*(C`O_NDELAY\*(C'\fR or \f(CW\*(C`O_NONBLOCK\*(C'\fR flag from tha \f(CW\*(C`Fcntl\*(C'\fR module up in conjunction with
\&\f(CW\*(C`sysopen()\*(C'\fR:
.PP
.Vb 3
\&    use Fcntl;
\&    sysopen(my $fh, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
\&        or take a thugged-out dirtnap "can\*(Aqt open /foo/somefile: $!":
.Ve
.SS "How tha fuck do I tell tha difference between errors from tha shell n' perl?"
.IX Subsection "How tha fuck do I tell tha difference between errors from tha shell n' perl?"
(answer contributed by brian d foy)
.PP
When you run a Perl script, suttin' else is hustlin tha script fo' you,
and dat suttin' else may output error lyrics. Da script might
emit its own warnings n' error lyrics. Most of tha time you cannot
tell whoz ass holla'd what.
.PP
Yo ass probably cannot fix tha thang dat runs perl yo, but you can chizzle how
perl outputs its warnings by definin a cold-ass lil custom warnin n' take a thugged-out dirtnap functions.
.PP
Consider dis script, which has a error you may not notice immediately.
.PP
.Vb 1
\&    #!/usr/locl/bin/perl
\&
\&    print "Wuz crackalackin' World\en";
.Ve
.PP
I git a error when I run dis from mah shell (which happens ta be
bash). That may be lookin like perl forgot it has a \f(CW\*(C`print()\*(C'\fR function,
but mah shebang line aint tha path ta perl, so tha shell runs the
script, n' I git tha error.
.PP
.Vb 2
\&    $ ./test
\&    ./test: line 3: print: command not found
.Ve
.PP
A quick n' dirty fix involves a lil bit of code yo, but dis may be all
you need ta figure up tha problem.
.PP
.Vb 1
\&    #!/usr/bin/perl \-w
\&
\&    BEGIN {
\&        $SIG{_\|_WARN_\|_} = sub{ print STDERR "Perl: ", @_; };
\&        $SIG{_\|_DIE_\|_}  = sub{ print STDERR "Perl: ", @_; exit 1};
\&    }
\&
\&    $a = 1 + undef;
\&    $x / 0;
\&    _\|_END_\|_
.Ve
.PP
Da perl message comes up wit \*(L"Perl\*(R" up in front. Da \f(CW\*(C`BEGIN\*(C'\fR block
works at compile time so all of tha compilation errors n' warnings
get tha \*(L"Perl:\*(R" prefix like a muthafucka.
.PP
.Vb 7
\&    Perl: Useless use of division (/) up in void context at ./test line 9.
\&    Perl: Name "main::a" used only once: possible typo at ./test line 8.
\&    Perl: Name "main::x" used only once: possible typo at ./test line 9.
\&    Perl: Use of uninitialized value up in addizzle (+) at ./test line 8.
\&    Perl: Use of uninitialized value up in division (/) at ./test line 9.
\&    Perl: Illegal division by zero at ./test line 9.
\&    Perl: Illegal division by zero at \-e line 3.
.Ve
.PP
If I don't peep dat \*(L"Perl:\*(R", it aint from perl.
.PP
Yo ass could also just know all tha perl errors, n' although there are
some playas whoz ass may know all of them, you probably don't. But fuck dat shiznit yo, tha word on tha street is dat they
all should be up in tha perldiag manpage. If you don't find tha error in
there, it probably aint a perl error.
.PP
Lookin up every last muthafuckin message aint tha easiest way, so let perl ta do it
for yo thugged-out ass. Use tha diagnostics pragma wit turns perlz aiiight lyrics
into longer raps on tha topic.
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
If you don't git a paragraph or two of expanded rap, it
might not be perlz message.
.SS "How tha fuck do I install a module from \s-1CPAN\s0?"
.IX Subsection "How tha fuck do I install a module from CPAN?"
(contributed by brian d foy)
.PP
Da easiest way is ta git a module also named \s-1CPAN\s0 do it fo' you by using
the \f(CW\*(C`cpan\*(C'\fR command dat comes wit Perl. Yo ass can give it a list of modules
to install:
.PP
.Vb 1
\&    $ cpan IO::Interactizzle Getopt::Whatever
.Ve
.PP
If you prefer \f(CW\*(C`CPANPLUS\*(C'\fR, itz just as easy as fuck :
.PP
.Vb 1
\&    $ cpanp i IO::Interactizzle Getopt::Whatever
.Ve
.PP
If you wanna install a gangbangin' finger-lickin' distribution from tha current directory, you can
tell \f(CW\*(C`CPAN.pm\*(C'\fR ta install \f(CW\*(C`.\*(C'\fR (the full stop):
.PP
.Vb 1
\&    $ cpan .
.Ve
.PP
See tha documentation fo' either of dem commandz ta peep what tha fuck else
you can do.
.PP
If you wanna try ta install a gangbangin' finger-lickin' distribution by yo ass, resolving
all dependencies on yo' own, you follow one of two possible build
paths.
.PP
For distributions dat use \fIMakefile.PL\fR:
.PP
.Vb 2
\&    $ perl Makefile.PL
\&    $ make test install
.Ve
.PP
For distributions dat use \fIBuild.PL\fR:
.PP
.Vb 3
\&    $ perl Build.PL
\&    $ ./Build test
\&    $ ./Build install
.Ve
.PP
Some distributions may need ta link ta libraries or other third-party
code n' they build n' installation sequences may be mo' fucked up.
Peep any \fI\s-1README\s0\fR or \fI\s-1INSTALL\s0\fR filez dat you may find.
.SS "Whatz tha difference between require n' use?"
.IX Subsection "Whatz tha difference between require n' use?"
(contributed by brian d foy)
.PP
Perl runs \f(CW\*(C`require\*(C'\fR statement at run-time. Once Perl loads, compiles,
and runs tha file, it don't do anythang else. Da \f(CW\*(C`use\*(C'\fR statement
is tha same ol' dirty as a \f(CW\*(C`require\*(C'\fR run at compile-time yo, but Perl also calls the
\&\f(CW\*(C`import\*(C'\fR method fo' tha loaded package. These two is tha same:
.PP
.Vb 1
\&    use MODULE qw(import list);
\&
\&    BEGIN {
\&        require MODULE;
\&        MODULE\->import(import list);
\&    }
.Ve
.PP
But fuck dat shiznit yo, tha word on tha street is dat you can suppress tha \f(CW\*(C`import\*(C'\fR by rockin a explicit, empty
import list. Both of these still happen at compile-time:
.PP
.Vb 1
\&    use MODULE ();
\&
\&    BEGIN {
\&        require MODULE;
\&    }
.Ve
.PP
Since \f(CW\*(C`use\*(C'\fR will also call tha \f(CW\*(C`import\*(C'\fR method, tha actual value
for \f(CW\*(C`MODULE\*(C'\fR must be a funky-ass bareword. Y'all KNOW dat shit, muthafucka! That is, \f(CW\*(C`use\*(C'\fR cannot load files
by name, although \f(CW\*(C`require\*(C'\fR can:
.PP
.Vb 1
\&    require "$ENV{HOME}/lib/Foo.pm"; # no @INC searching!
.Ve
.PP
See tha entry fo' \f(CW\*(C`use\*(C'\fR up in perlfunc fo' mo' details.
.SS "How tha fuck do I keep mah own module/library directory?"
.IX Subsection "How tha fuck do I keep mah own module/library directory?"
When you build modules, tell Perl where ta install tha modules.
.PP
If you wanna install modulez fo' yo' own use, tha easiest way might
be local::lib, which you can downlizzle from \s-1CPAN.\s0 It sets various
installation settings fo' you, n' uses dem same settings within
your programs.
.PP
If you want mo' flexibility, you need ta configure yo' \s-1CPAN\s0 client
for yo' particular thang.
.PP
For \f(CW\*(C`Makefile.PL\*(C'\fR\-based distributions, use tha \s-1INSTALL_BASE\s0 option
when generatin Makefiles:
.PP
.Vb 1
\&    perl Makefile.PL INSTALL_BASE=/mydir/perl
.Ve
.PP
Yo ass can set dis up in yo' \f(CW\*(C`CPAN.pm\*(C'\fR configuration so modules
automatically install up in yo' private library directory when you use
the \s-1CPAN\s0.pm shell:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf makepl_arg INSTALL_BASE=/mydir/perl
\&    cpan> o conf commit
.Ve
.PP
For \f(CW\*(C`Build.PL\*(C'\fR\-based distributions, use tha \-\-install_base option:
.PP
.Vb 1
\&    perl Build.PL \-\-install_base /mydir/perl
.Ve
.PP
Yo ass can configure \f(CW\*(C`CPAN.pm\*(C'\fR ta automatically use dis option too:
.PP
.Vb 3
\&    % cpan
\&    cpan> o conf mbuild_arg "\-\-install_base /mydir/perl"
\&    cpan> o conf commit
.Ve
.PP
\&\s-1INSTALL_BASE\s0  drops some lyrics ta these tools ta put yo' modulez into
\&\fI/mydir/perl/lib/perl5\fR. Right back up in yo muthafuckin ass. See \*(L"How tha fuck do I add a gangbangin' finger-lickin' directory ta my
include path (@INC) at runtime?\*(R" fo' details on how tha fuck ta run yo' newly
installed modules.
.PP
There is one caveat wit \s-1INSTALL_BASE,\s0 though, since it acts
differently from tha \s-1PREFIX\s0 n' \s-1LIB\s0 settings dat olda versions of
ExtUtils::MakeMaker advocated. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. \s-1INSTALL_BASE\s0 do not support
installin modulez fo' multiple versionz of Perl or different
architectures under tha same directory. Yo ass should consider whether you
really want dat and, if you do, use tha olda \s-1PREFIX\s0 n' \s-1LIB\s0
settings. Right back up in yo muthafuckin ass. See tha ExtUtils::Makemaker documentation fo' mo' details.
.SS "How tha fuck do I add tha directory mah program lives up in ta tha module/library search path?"
.IX Subsection "How tha fuck do I add tha directory mah program lives up in ta tha module/library search path?"
(contributed by brian d foy)
.PP
If you know tha directory already, you can add it ta \f(CW@INC\fR as you would
for any other directory. Yo ass might <use lib> if you know tha directory
at compile time:
.PP
.Vb 1
\&    use lib $directory;
.Ve
.PP
Da trick up in dis task is ta find tha directory. Before yo' script do
anythang else (like fuckin a \f(CW\*(C`chdir\*(C'\fR), you can git tha current working
directory wit tha \f(CW\*(C`Cwd\*(C'\fR module, which comes wit Perl:
.PP
.Vb 4
\&    BEGIN {
\&        use Cwd;
\&        our $directory = cwd;
\&    }
\&
\&    use lib $directory;
.Ve
.PP
Yo ass can do a similar thang wit tha value of \f(CW$0\fR, which holdz the
script name. That might hold a relatizzle path yo, but \f(CW\*(C`rel2abs\*(C'\fR can turn
it tha fuck into a absolute path. Once you have the
.PP
.Vb 3
\&    BEGIN {
\&        use File::Spec::Functions qw(rel2abs);
\&        use File::Basename qw(dirname);
\&
\&        mah $path   = rel2abs( $0 );
\&        our $directory = dirname( $path );
\&    }
\&
\&    use lib $directory;
.Ve
.PP
Da FindBin module, which comes wit Perl, might work. Well shiiiit, it findz the
directory of tha currently hustlin script n' puts it up in \f(CW$Bin\fR, which
you can then use ta construct tha right library path:
.PP
.Vb 1
\&    use FindBin qw($Bin);
.Ve
.PP
Yo ass can also use local::lib ta do much of tha same thang. Install
modulez rockin local::libz settings then use tha module up in your
program:
.PP
.Vb 1
\&     use local::lib; # sets up a local lib at ~/perl5
.Ve
.PP
See tha local::lib documentation fo' mo' details.
.SS "How tha fuck do I add a gangbangin' finger-lickin' directory ta mah include path (@INC) at runtime?"
.IX Subsection "How tha fuck do I add a gangbangin' finger-lickin' directory ta mah include path (@INC) at runtime?"
Here is tha suggested wayz of modifyin yo' include path, including
environment variables, run-time switches, n' in-code statements:
.ie n .IP "the ""PERLLIB"" environment variable" 4
.el .IP "the \f(CWPERLLIB\fR environment variable" 4
.IX Item "the PERLLIB environment variable"
.Vb 2
\&    $ export PERLLIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""PERL5LIB"" environment variable" 4
.el .IP "the \f(CWPERL5LIB\fR environment variable" 4
.IX Item "the PERL5LIB environment variable"
.Vb 2
\&    $ export PERL5LIB=/path/to/my/dir
\&    $ perl program.pl
.Ve
.ie n .IP "the ""perl \-Idir"" command line flag" 4
.el .IP "the \f(CWperl \-Idir\fR command line flag" 4
.IX Item "the perl -Idir command line flag"
.Vb 1
\&    $ perl \-I/path/to/my/dir program.pl
.Ve
.ie n .IP "the ""lib"" pragma:" 4
.el .IP "the \f(CWlib\fR pragma:" 4
.IX Item "the lib pragma:"
.Vb 1
\&    use lib "$ENV{HOME}/myown_perllib";
.Ve
.IP "the local::lib module:" 4
.IX Item "the local::lib module:"
.Vb 1
\&    use local::lib;
\&
\&    use local::lib "~/myown_perllib";
.Ve
.PP
Da last is particularly useful cuz it knows bout machine-dependent
architectures. Da \f(CW\*(C`lib.pm\*(C'\fR pragmatic module was first
included wit tha 5.002 release of Perl.
.SS "What tha fuck iz socket.ph n' where do I git it?"
.IX Subsection "What tha fuck iz socket.ph n' where do I git it?"
It aint nuthin but a Perl 4 steez file definin joints fo' system networking
constants, n' you can put dat on yo' toast. Right back up in yo muthafuckin ass. Sometimes it is built rockin h2ph when Perl is installed,
but other times it is not. Modern programs should use \f(CW\*(C`use Socket;\*(C'\fR
instead.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tomothy Christiansen, Nathan Torkington, and
other authors as noted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time fo' realz. All muthafuckin rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under tha same terms as Perl itself.
.PP
Irrespectizzle of its distribution, all code examplez up in dis file
are hereby placed tha fuck into tha hood domain. I aint talkin' bout chicken n' gravy biatch. Yo ass is permitted and
encouraged ta use dis code up in yo' own programs fo' fun
or fo' profit as you peep fit fo' realz. A simple comment up in tha code giving
credit would be courteous but aint required.
