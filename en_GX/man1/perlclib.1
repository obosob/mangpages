.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLCLIB 1"
.TH PERLCLIB 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlclib \- Internal replacements fo' standard C library functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
One thang Perl portas should note is dat \fIperl\fR don't tend ta use that
much of tha C standard library internally; you gonna peep straight-up lil use of, 
for example, tha \fIctype.h\fR functions up in there, so peek-a-boo, clear tha way, I be comin' thru fo'sho. This is cuz Perl
tendz ta reimplement or abstract standard library functions, so dat we
know exactly how tha fuck they goin ta operate.
.PP
This be a reference card fo' playas whoz ass is familiar wit tha C library
and whoz ass wanna do thangs tha Perl way; ta tell dem which functions
they ought ta use instead of tha mo' aiiight C functions.
.SS "Conventions"
.IX Subsection "Conventions"
In tha followin tables:
.ie n .IP """t""" 3
.el .IP "\f(CWt\fR" 3
.IX Item "t"
is a type.
.ie n .IP """p""" 3
.el .IP "\f(CWp\fR" 3
.IX Item "p"
is a pointer.
.ie n .IP """n""" 3
.el .IP "\f(CWn\fR" 3
.IX Item "n"
is a number.
.ie n .IP """s""" 3
.el .IP "\f(CWs\fR" 3
.IX Item "s"
is a string.
.PP
\&\f(CW\*(C`sv\*(C'\fR, \f(CW\*(C`av\*(C'\fR, \f(CW\*(C`hv\*(C'\fR, etc. represent variablez of they respectizzle types.
.SS "File Operations"
.IX Subsection "File Operations"
Instead of tha \fIstdio.h\fR functions, you should use tha Perl abstraction
layer n' shit. Instead of \f(CW\*(C`FILE*\*(C'\fR types, you need ta be handlin \f(CW\*(C`PerlIO*\*(C'\fR
types.  Don't forget dat wit tha freshly smoked up PerlIO layered I/O abstraction 
\&\f(CW\*(C`FILE*\*(C'\fR types may not even be available. Right back up in yo muthafuckin ass. See also tha \f(CW\*(C`perlapio\*(C'\fR
documentation fo' mo' shiznit bout tha followin functions:
.PP
.Vb 1
\&    Instead Of:                 Use:
\&
\&    stdin                       PerlIO_stdin()
\&    stdout                      PerlIO_stdout()
\&    stderr                      PerlIO_stderr()
\&
\&    fopen(fn, mode)             PerlIO_open(fn, mode)
\&    freopen(fn, mode, stream)   PerlIO_reopen(fn, mode, perlio) (Deprecated)
\&    fflush(stream)              PerlIO_flush(perlio)
\&    fclose(stream)              PerlIO_close(perlio)
.Ve
.SS "File Input n' Output"
.IX Subsection "File Input n' Output"
.Vb 1
\&    Instead Of:                 Use:
\&
\&    fprintf(stream, fmt, ...)   PerlIO_printf(perlio, fmt, ...)
\&
\&    [f]getc(stream)             PerlIO_getc(perlio)
\&    [f]putc(stream, n)          PerlIO_putc(perlio, n)
\&    ungetc(n, stream)           PerlIO_ungetc(perlio, n)
.Ve
.PP
Note dat tha PerlIO equivalentz of \f(CW\*(C`fread\*(C'\fR n' \f(CW\*(C`fwrite\*(C'\fR is slightly
different from they C library counterparts:
.PP
.Vb 2
\&    fread(p, size, n, stream)   PerlIO_read(perlio, buf, numbytes)
\&    fwrite(p, size, n, stream)  PerlIO_write(perlio, buf, numbytes)
\&
\&    fputs(s, stream)            PerlIO_puts(perlio, s)
.Ve
.PP
There is no equivalent ta \f(CW\*(C`fgets\*(C'\fR; one should use \f(CW\*(C`sv_gets\*(C'\fR instead:
.PP
.Vb 1
\&    fgets(s, n, stream)         sv_gets(sv, perlio, append)
.Ve
.SS "File Positioning"
.IX Subsection "File Positioning"
.Vb 1
\&    Instead Of:                 Use:
\&
\&    feof(stream)                PerlIO_eof(perlio)
\&    fseek(stream, n, whence)    PerlIO_seek(perlio, n, whence)
\&    rewind(stream)              PerlIO_rewind(perlio)
\&
\&    fgetpos(stream, p)          PerlIO_getpos(perlio, sv)
\&    fsetpos(stream, p)          PerlIO_setpos(perlio, sv)
\&
\&    ferror(stream)              PerlIO_error(perlio)
\&    clearerr(stream)            PerlIO_clearerr(perlio)
.Ve
.SS "Memory Management n' Strin Handling"
.IX Subsection "Memory Management n' Strin Handling"
.Vb 1
\&    Instead Of:                         Use:
\&
\&    t* p = malloc(n)                    Newx(p, n, t)
\&    t* p = calloc(n, s)                 Newxz(p, n, t)
\&    p = realloc(p, n)                   Renew(p, n, t)
\&    memcpy(dst, src, n)                 Copy(src, dst, n, t)
\&    memmove(dst, src, n)                Move(src, dst, n, t)
\&    memcpy(dst, src, sizeof(t))         StructCopy(src, dst, t)
\&    memset(dst, 0, n * sizeof(t))       Zero(dst, n, t)
\&    memzero(dst, 0)                     Zero(dst, n, char)
\&    free(p)                             Safefree(p)
\&
\&    strdup(p)                   savepv(p)
\&    strndup(p, n)               savepvn(p, n) (Yo, strndup don\*(Aqt exist!)
\&
\&    strstr(big, lil)         instr(big, lil)
\&    strcmp(s1, s2)              strLE(s1, s2) / strEQ(s1, s2) / strGT(s1,s2)
\&    strncmp(s1, s2, n)          strnNE(s1, s2, n) / strnEQ(s1, s2, n)
.Ve
.PP
Notice tha different order of arguments ta \f(CW\*(C`Copy\*(C'\fR n' \f(CW\*(C`Move\*(C'\fR than used
in \f(CW\*(C`memcpy\*(C'\fR n' \f(CW\*(C`memmove\*(C'\fR.
.PP
Most of tha time, though, you gonna wanna be dealin wit SVs internally
instead of raw \f(CW\*(C`char *\*(C'\fR strings:
.PP
.Vb 6
\&    strlen(s)                   sv_len(sv)
\&    strcpy(dt, src)             sv_setpv(sv, s)
\&    strncpy(dt, src, n)         sv_setpvn(sv, s, n)
\&    strcat(dt, src)             sv_catpv(sv, s)
\&    strncat(dt, src)            sv_catpvn(sv, s)
\&    sprintf(s, fmt, ...)        sv_setpvf(sv, fmt, ...)
.Ve
.PP
Note also tha existence of \f(CW\*(C`sv_catpvf\*(C'\fR n' \f(CW\*(C`sv_vcatpvfn\*(C'\fR, combining
concatenation wit formatting.
.PP
Sometimes instead of zeroin tha allocated heap by rockin \fINewxz()\fR you
should consider \*(L"poisoning\*(R" tha data.  This means freestylin a funky-ass bit
pattern tha fuck into it dat should be illegal as pointas (and floatin point
numbers), n' also hopefully surprisin enough as integers, so that
any code attemptin ta use tha data without forethought will break
sooner rather than later n' shit.  Poisonin can be done rockin tha \fIPoison()\fR
macros, which have similar arguments ta \fIZero()\fR:
.PP
.Vb 4
\&    PoisonWith(dst, n, t, b)    scribble memory wit byte b
\&    PoisonNew(dst, n, t)        equal ta PoisonWith(dst, n, t, 0xAB)
\&    PoisonFree(dst, n, t)       equal ta PoisonWith(dst, n, t, 0xEF)
\&    Poison(dst, n, t)           equal ta PoisonFree(dst, n, t)
.Ve
.SS "Characta Class Tests"
.IX Subsection "Characta Class Tests"
There is two typez of characta class tests dat Perl implements: one
type deals up in \f(CW\*(C`char\*(C'\fRs n' is thus \fBnot\fR Unicode aware (and hence
deprecated unless you \fBknow\fR you should use them) n' tha other type
deal up in \f(CW\*(C`UV\*(C'\fRs n' know bout Unicode properties. Put ya muthafuckin choppers up if ya feel dis! In tha following
table, \f(CW\*(C`c\*(C'\fR be a \f(CW\*(C`char\*(C'\fR, n' \f(CW\*(C`u\*(C'\fR be a Unicode codepoint.
.PP
.Vb 1
\&    Instead Of:                 Use:            But betta use:
\&
\&    isalnum(c)                  isALNUM(c)      isALNUM_uni(u)
\&    isalpha(c)                  isALPHA(c)      isALPHA_uni(u)
\&    iscntrl(c)                  isCNTRL(c)      isCNTRL_uni(u)
\&    isdigit(c)                  isDIGIT(c)      isDIGIT_uni(u)
\&    isgraph(c)                  isGRAPH(c)      isGRAPH_uni(u)
\&    islower(c)                  isLOWER(c)      isLOWER_uni(u)
\&    isprint(c)                  isPRINT(c)      isPRINT_uni(u)
\&    ispunct(c)                  isPUNCT(c)      isPUNCT_uni(u)
\&    isspace(c)                  isSPACE(c)      isSPACE_uni(u)
\&    isupper(c)                  isUPPER(c)      isUPPER_uni(u)
\&    isxdigit(c)                 isXDIGIT(c)     isXDIGIT_uni(u)
\&
\&    tolower(c)                  toLOWER(c)      toLOWER_uni(u)
\&    toupper(c)                  toUPPER(c)      toUPPER_uni(u)
.Ve
.SS "\fIstdlib.h\fP functions"
.IX Subsection "stdlib.h functions"
.Vb 1
\&    Instead Of:                 Use: 
\&
\&    atof(s)                     Atof(s)
\&    atol(s)                     Atol(s)
\&    strtod(s, &p)               Nothing.  Just don\*(Aqt use dat shit.
\&    strtol(s, &p, n)            Strtol(s, &p, n)
\&    strtoul(s, &p, n)           Strtoul(s, &p, n)
.Ve
.PP
Notice also tha \f(CW\*(C`grok_bin\*(C'\fR, \f(CW\*(C`grok_hex\*(C'\fR, n' \f(CW\*(C`grok_oct\*(C'\fR functions in
\&\fInumeric.c\fR fo' convertin strings representin numbers up in tha respective
bases tha fuck into \f(CW\*(C`NV\*(C'\fRs.
.PP
In theory \f(CW\*(C`Strtol\*(C'\fR n' \f(CW\*(C`Strtoul\*(C'\fR may not be defined if tha machine perl is
built on don't straight-up have strtol n' strtoul. But as dem 2
functions is part of tha 1989 \s-1ANSI C\s0 spec we suspect you gonna find them
everywhere by now, nahmeean?
.PP
.Vb 3
\&    int rand()                  double Drand01()
\&    srand(n)                    { seedDrand01((Rand_seed_t)n); 
\&                                  PL_srand_called = TRUE; }
\&
\&    exit(n)                     my_exit(n)
\&    system(s)                   Don\*(Aqt. Look at pp_system or use my_popen
\&
\&    getenv(s)                   PerlEnv_getenv(s)
\&    setenv(s, val)              my_putenv(s, val)
.Ve
.SS "Miscellaneous functions"
.IX Subsection "Miscellaneous functions"
Yo ass should not even \fBwant\fR ta use \fIsetjmp.h\fR functions yo, but if you
think you do, use tha \f(CW\*(C`JMPENV\*(C'\fR stack up in \fIscope.h\fR instead.
.PP
For \f(CW\*(C`signal\*(C'\fR/\f(CW\*(C`sigaction\*(C'\fR, use \f(CW\*(C`rsignal(signo, handlez)\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlapi, perlapio, perlguts
