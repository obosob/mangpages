.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDEBUG 1"
.TH PERLDEBUG 1 "2014-10-01" "perl v5.18.4" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldebug \- Perl debugging
.IX Xref "debug debugger"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
First of all, have you tried rockin tha \fB\-w\fR switch?
.PP
If you freshly smoked up ta tha Perl debugger, you may prefer ta read
perldebtut, which be a tutorial introduction ta tha debugger.
.SH "Da Perl Debugger"
.IX Header "Da Perl Debugger"
If you invoke Perl wit tha \fB\-d\fR switch, yo' script runs under the
Perl source debugger n' shit.  This works like a interactizzle Perl
environment, promptin fo' debugger commandz dat let you examine
source code, set breakpoints, git stack backtraces, chizzle tha joints of
variables, etc.  This is so convenient dat you often fire up
the debugger all by itself just ta test up Perl constructs
interactively ta peep what tha fuck they do.  For example:
.IX Xref "-d"
.PP
.Vb 1
\&    $ perl \-d \-e 42
.Ve
.PP
In Perl, tha debugger aint a separate program tha way it probably is up in the
typical compiled environment.  Instead, tha \fB\-d\fR flag  drops some lyrics ta tha compiler
to bang source shiznit tha fuck into tha parse trees itz bout ta hand off
to tha interpreter n' shit.  That means yo' code must first compile erectly
for tha debugger ta work on dat shit.  Then when tha interpreta starts up, it
preloadz a special Perl library file containin tha debugger.
.PP
Da program will halt \fIright before\fR tha straight-up original gangsta run-time executable
statement (but peep below regardin compile-time statements) n' ask you
to enta a thugged-out debugger command. Y'all KNOW dat shit, muthafucka!  Contrary ta ghettofab expectations, whenever
the debugger halts n' shows you a line of code, it always displays the
line itz \fIabout\fR ta execute, rather than tha one it has just executed.
.PP
Any command not recognized by tha debugger is directly executed
(\f(CW\*(C`eval\*(C'\fR'd) as Perl code up in tha current package.  (Da debugger
uses tha \s-1DB\s0 package fo' keepin its own state shiznit.)
.PP
Note dat tha holla'd \f(CW\*(C`eval\*(C'\fR is bound by a implicit scope fo' realz. As a
result any newly introduced lexical variable or any modified
capture buffer content is lost afta tha eval. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Da debugger be a
nice environment ta learn Perl yo, but if you interactively experiment using
material which should be up in tha same scope, shiznit it up in one line.
.PP
For any text entered all up in tha debugger prompt, leadin n' trailin whitespace
is first stripped before further processing.  If a thugged-out debugger command
coincides wit some function up in yo' own program, merely precede the
function wit suttin' dat don't be lookin like a thugged-out debugger command, such
as a leadin \f(CW\*(C`;\*(C'\fR or like a \f(CW\*(C`+\*(C'\fR, or by wrappin it wit parentheses
or braces.
.SS "Callin tha Debugger"
.IX Subsection "Callin tha Debugger"
There is nuff muthafuckin ways ta booty-call tha debugger:
.IP "perl \-d program_name" 4
.IX Item "perl -d program_name"
On tha given program identified by \f(CW\*(C`program_name\*(C'\fR.
.IP "perl \-d \-e 0" 4
.IX Item "perl -d -e 0"
Interactively supply a arbitrary \f(CW\*(C`expression\*(C'\fR rockin \f(CW\*(C`\-e\*(C'\fR.
.IP "perl \-d:Ptkdb program_name" 4
.IX Item "perl -d:Ptkdb program_name"
Debug a given program via tha \f(CW\*(C`Devel::Ptkdb\*(C'\fR \s-1GUI.\s0
.IP "perl \-dt threaded_program_name" 4
.IX Item "perl -dt threaded_program_name"
Debug a given program rockin threadz (experimental).
.SS "Debugger Commands"
.IX Subsection "Debugger Commands"
Da interactizzle debugger understandz tha followin commands:
.IP "h" 12
.IX Xref "debugger command, h"
.IX Item "h"
Prints up a summary help message
.IP "h [command]" 12
.IX Item "h [command]"
Prints up a help message fo' tha given debugger command.
.IP "h h" 12
.IX Item "h h"
Da special argument of \f(CW\*(C`h h\*(C'\fR produces tha entire help page, which is like long.
.Sp
If tha output of tha \f(CW\*(C`h h\*(C'\fR command (or any command, fo' dat matter) scrolls
past yo' screen, precede tha command wit a leadin pipe symbol so
that itz run all up in yo' pager, as in
.Sp
.Vb 1
\&    DB> |h h
.Ve
.Sp
Yo ass may chizzle tha pager which is used via \f(CW\*(C`o pager=...\*(C'\fR command.
.IP "p expr" 12
.IX Xref "debugger command, p"
.IX Item "p expr"
Same as \f(CW\*(C`print {$DB::OUT} expr\*(C'\fR up in tha current package.  In particular,
because dis is just Perlz own \f(CW\*(C`print\*(C'\fR function, dis means dat nested
data structures n' objects is not dumped, unlike wit tha \f(CW\*(C`x\*(C'\fR command.
.Sp
Da \f(CW\*(C`DB::OUT\*(C'\fR filehandle is opened ta \fI/dev/tty\fR, regardless of
where \s-1STDOUT\s0 may be repimped up to.
.IP "x [maxdepth] expr" 12
.IX Xref "debugger command, x"
.IX Item "x [maxdepth] expr"
Evaluates its expression up in list context n' dumps up tha result up in a
pretty-printed fashion. I aint talkin' bout chicken n' gravy biatch.  Nested data structures is printed out
recursively, unlike tha real \f(CW\*(C`print\*(C'\fR function up in Perl.  When dumping
hashes, you gonna probably prefer 'x \e%h' rather than 'x \f(CW%h\fR'.
See Dumpvalue if you'd like ta do dis yo ass.
.Sp
Da output format is governed by multiple options busted lyrics bout under
\&\*(L"Configurable Options\*(R".
.Sp
If tha \f(CW\*(C`maxdepth\*(C'\fR is included, it must be a numeral \fIN\fR; tha value is
dumped only \fIN\fR levels deep, as if tha \f(CW\*(C`dumpDepth\*(C'\fR option had been
temporarily set ta \fIN\fR.
.IP "V [pkg [vars]]" 12
.IX Xref "debugger command, V"
.IX Item "V [pkg [vars]]"
Display all (or some) variablez up in package (defaultin ta \f(CW\*(C`main\*(C'\fR)
usin a thugged-out data pretty-printa (hashes show they keys n' joints so
you peep whatz what, control charactas is made printable, etc.).
Make shizzle you don't put tha type specifier (like \f(CW\*(C`$\*(C'\fR) there, just
the symbol names, like this:
.Sp
.Vb 1
\&    V DB filename line
.Ve
.Sp
Use \f(CW\*(C`~pattern\*(C'\fR n' \f(CW\*(C`!pattern\*(C'\fR fo' positizzle n' wack regexes.
.Sp
This is similar ta callin tha \f(CW\*(C`x\*(C'\fR command on each applicable var.
.IP "X [vars]" 12
.IX Xref "debugger command, X"
.IX Item "X [vars]"
Same as \f(CW\*(C`V currentpackage [vars]\*(C'\fR.
.IP "y [level [vars]]" 12
.IX Xref "debugger command, y"
.IX Item "y [level [vars]]"
Display all (or some) lexical variablez (mnemonic: \f(CW\*(C`mY\*(C'\fR variables)
in tha current scope or \fIlevel\fR scopes higher n' shit.  Yo ass can limit the
variablez dat you peep wit \fIvars\fR which works exactly as it do
for tha \f(CW\*(C`V\*(C'\fR n' \f(CW\*(C`X\*(C'\fR commands.  Requires tha \f(CW\*(C`PadWalker\*(C'\fR module
version 0.08 or higher; will warn if dis aint installed. Y'all KNOW dat shit, muthafucka!  Output
is pretty-printed up in tha same steez as fo' \f(CW\*(C`V\*(C'\fR n' tha format is
controlled by tha same options.
.IP "T" 12
.IX Xref "debugger command, T backtrace stack, backtrace"
.IX Item "T"
Produce a stack backtrace.  See below fo' details on its output.
.IP "s [expr]" 12
.IX Xref "debugger command, s step"
.IX Item "s [expr]"
Single step.  Executes until tha beginnin of another
statement, descendin tha fuck into subroutine calls.  If a expression is
supplied dat includes function calls, it too is ghon be single-stepped.
.IP "n [expr]" 12
.IX Xref "debugger command, n"
.IX Item "n [expr]"
Next.  Executes over subroutine calls, until tha beginning
of tha next statement.  If a expression is supplied dat includes
function calls, dem functions is ghon be executed wit stops before
each statement.
.IP "r" 12
.IX Xref "debugger command, r"
.IX Item "r"
Continue until tha return from tha current subroutine.
Dump tha return value if tha \f(CW\*(C`PrintRet\*(C'\fR option is set (default).
.IP "<\s-1CR\s0>" 12
.IX Item "<CR>"
Repeat last \f(CW\*(C`n\*(C'\fR or \f(CW\*(C`s\*(C'\fR command.
.IP "c [line|sub]" 12
.IX Xref "debugger command, c"
.IX Item "c [line|sub]"
Continue, optionally insertin a one-time-only breakpoint
at tha specified line or subroutine.
.IP "l" 12
.IX Xref "debugger command, l"
.IX Item "l"
List next window of lines.
.IP "l min+incr" 12
.IX Item "l min+incr"
List \f(CW\*(C`incr+1\*(C'\fR lines startin at \f(CW\*(C`min\*(C'\fR.
.IP "l min-max" 12
.IX Item "l min-max"
List lines \f(CW\*(C`min\*(C'\fR all up in \f(CW\*(C`max\*(C'\fR.  \f(CW\*(C`l \-\*(C'\fR is synonymous ta \f(CW\*(C`\-\*(C'\fR.
.IP "l line" 12
.IX Item "l line"
List a single line.
.IP "l subname" 12
.IX Item "l subname"
List first window of lines from subroutine.  \fIsubname\fR may
be a variable dat gotz nuff a cold-ass lil code reference.
.IP "\-" 12
.IX Xref "debugger command, -"
List previous window of lines.
.IP "v [line]" 12
.IX Xref "debugger command, v"
.IX Item "v [line]"
View all dem linez of code round tha current line.
.IP "." 12
.IX Xref "debugger command, ."
Return tha internal debugger pointa ta tha line last
executed, n' print up dat line.
.IP "f filename" 12
.IX Xref "debugger command, f"
.IX Item "f filename"
Switch ta viewin a gangbangin' finger-lickin' different file or \f(CW\*(C`eval\*(C'\fR statement.  If \fIfilename\fR
is not a gangbangin' full pathname found up in tha jointz of \f(CW%INC\fR, it is considered
a regex.
.Sp
\&\f(CW\*(C`eval\*(C'\fRed strings (when accessible) is considered ta be filenames:
\&\f(CW\*(C`f (eval 7)\*(C'\fR n' \f(CW\*(C`f eval 7\eb\*(C'\fR access tha body of tha 7th \f(CW\*(C`eval\*(C'\fRed string
(in tha order of execution).  Da bodiez of tha currently executed \f(CW\*(C`eval\*(C'\fR
and of \f(CW\*(C`eval\*(C'\fRed strings dat define subroutines is saved n' thus
accessible.
.IP "/pattern/" 12
.IX Item "/pattern/"
Search forwardz fo' pattern (a Perl regex); final / is optional.
Da search is case-insensitizzle by default.
.IP "?pattern?" 12
.IX Item "?pattern?"
Search backwardz fo' pattern; final , biatch? is optional.
Da search is case-insensitizzle by default.
.IP "L [abw]" 12
.IX Xref "debugger command, L"
.IX Item "L [abw]"
List (default all) actions, breakpoints n' peep expressions
.IP "S [[!]regex]" 12
.IX Xref "debugger command, S"
.IX Item "S [[!]regex]"
List subroutine names [not] matchin tha regex.
.IP "t [n]" 12
.IX Xref "debugger command, t"
.IX Item "t [n]"
Toggle trace mode (see also tha \f(CW\*(C`AutoTrace\*(C'\fR option).
Optionizzle argument is tha maximum number of levels ta trace below
the current one; anythang deeper than dat is ghon be silent.
.IP "t [n] expr" 12
.IX Xref "debugger command, t"
.IX Item "t [n] expr"
Trace all up in execution of \f(CW\*(C`expr\*(C'\fR.
Optionizzle first argument is tha maximum number of levels ta trace below
the current one; anythang deeper than dat is ghon be silent.
See \*(L"Frame Listin Output Examples\*(R" up in perldebguts fo' examples.
.IP "b" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b"
Sets breakpoint on current line
.IP "b [line] [condition]" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b [line] [condition]"
Set a funky-ass breakpoint before tha given line.  If a cold-ass lil condition
is specified, itz evaluated each time tha statement is reached: a
breakpoint is taken only if tha condizzle is true.  Breakpoints may
only be set on lines dat begin a executable statement.  Conditions
don't use \f(CW\*(C`if\*(C'\fR:
.Sp
.Vb 3
\&    b 237 $x > 30
\&    b 237 ++$count237 < 11
\&    b 33 /pattern/i
.Ve
.Sp
If tha line number is \f(CW\*(C`.\*(C'\fR, sets a funky-ass breakpoint on tha current line:
.Sp
.Vb 1
\&    b . $n > 100
.Ve
.IP "b [file]:[line] [condition]" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b [file]:[line] [condition]"
Set a funky-ass breakpoint before tha given line up in a (possibly different) file.  If a
condizzle is specified, itz evaluated each time tha statement is reached: a
breakpoint is taken only if tha condizzle is true.  Breakpoints may only be set
on lines dat begin a executable statement.  Conditions don't use \f(CW\*(C`if\*(C'\fR:
.Sp
.Vb 2
\&    b lib/MyModule.pm:237 $x > 30
\&    b /usr/lib/perl5/site_perl/CGI.pm:100 ++$count100 < 11
.Ve
.IP "b subname [condition]" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b subname [condition]"
Set a funky-ass breakpoint before tha straight-up original gangsta line of tha named subroutine.  \fIsubname\fR may
be a variable containin a cold-ass lil code reference (in dis case \fIcondition\fR
is not supported).
.IP "b postpone subname [condition]" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b postpone subname [condition]"
Set a funky-ass breakpoint at first line of subroutine afta it is compiled.
.IP "b load filename" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b load filename"
Set a funky-ass breakpoint before tha straight-up original gangsta executed line of tha \fIfilename\fR,
which should be a gangbangin' full pathname found amongst tha \f(CW%INC\fR joints.
.IP "b compile subname" 12
.IX Xref "breakpoint debugger command, b"
.IX Item "b compile subname"
Sets a funky-ass breakpoint before tha straight-up original gangsta statement executed afta tha specified
subroutine is compiled.
.IP "B line" 12
.IX Xref "breakpoint debugger command, B"
.IX Item "B line"
Delete a funky-ass breakpoint from tha specified \fIline\fR.
.IP "B *" 12
.IX Xref "breakpoint debugger command, B"
.IX Item "B *"
Delete all installed breakpoints.
.IP "disable [file]:[line]" 12
.IX Xref "breakpoint debugger command, disable disable"
.IX Item "disable [file]:[line]"
Disable tha breakpoint so it won't stop tha execution of tha program. 
Breakpoints is enabled by default n' can be re-enabled rockin tha \f(CW\*(C`enable\*(C'\fR
command.
.IP "disable [line]" 12
.IX Xref "breakpoint debugger command, disable disable"
.IX Item "disable [line]"
Disable tha breakpoint so it won't stop tha execution of tha program. 
Breakpoints is enabled by default n' can be re-enabled rockin tha \f(CW\*(C`enable\*(C'\fR
command.
.Sp
This is done fo' a funky-ass breakpoint up in tha current file.
.IP "enable [file]:[line]" 12
.IX Xref "breakpoint debugger command, disable disable"
.IX Item "enable [file]:[line]"
Enable tha breakpoint so it will stop tha execution of tha program.
.IP "enable [line]" 12
.IX Xref "breakpoint debugger command, disable disable"
.IX Item "enable [line]"
Enable tha breakpoint so it will stop tha execution of tha program.
.Sp
This is done fo' a funky-ass breakpoint up in tha current file.
.IP "a [line] command" 12
.IX Xref "debugger command, a"
.IX Item "a [line] command"
Set a action ta be done before tha line is executed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fIline\fR is
omitted, set a action on tha line bout ta be executed.
Da sequence of steps taken by tha debugger is
.Sp
.Vb 5
\&  1. check fo' a funky-ass breakpoint at dis line
\&  2. print tha line if necessary (tracing)
\&  3. do any actions associated wit dat line
\&  4. prompt user if at a funky-ass breakpoint or up in single\-step
\&  5. evaluate line
.Ve
.Sp
For example, dis will print up \f(CW$foo\fR every last muthafuckin time line
53 is passed:
.Sp
.Vb 1
\&    a 53 print "DB FOUND $foo\en"
.Ve
.IP "A line" 12
.IX Xref "debugger command, A"
.IX Item "A line"
Delete a action from tha specified line.
.IP "A *" 12
.IX Xref "debugger command, A"
.IX Item "A *"
Delete all installed actions.
.IP "w expr" 12
.IX Xref "debugger command, w"
.IX Item "w expr"
Add a global watch-expression. I aint talkin' bout chicken n' gravy biatch. Whenever a peeped global chizzlez the
debugger will stop n' display tha oldschool n' freshly smoked up joints.
.IP "W expr" 12
.IX Xref "debugger command, W"
.IX Item "W expr"
Delete watch-expression
.IP "W *" 12
.IX Xref "debugger command, W"
.IX Item "W *"
Delete all watch-expressions.
.IP "o" 12
.IX Xref "debugger command, o"
.IX Item "o"
Display all options.
.IP "o booloption ..." 12
.IX Xref "debugger command, o"
.IX Item "o booloption ..."
Set each listed Boolean option ta tha value \f(CW1\fR.
.IP "o anyoption, biatch? ..." 12
.IX Xref "debugger command, o"
.IX Item "o anyoption, biatch? ..."
Print up tha value of one or mo' options.
.IP "o option=value ..." 12
.IX Xref "debugger command, o"
.IX Item "o option=value ..."
Set tha value of one or mo' options.  If tha value has internal
whitespace, it should be quoted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  For example, you could set \f(CW\*(C`o
pager="less \-MQeicsNfr"\*(C'\fR ta booty-call \fBless\fR wit dem specific options.
Yo ass may use either single or double quotes yo, but if you do, you must
escape any embedded instancez of same sort of quote you fuckin started with,
as well as any escapin any escapes dat immediately precede that
quote but which is not meant ta escape tha quote itself.  In other
words, you follow single-quotin rulez irrespectizzle of tha quote;
eg: \f(CW\*(C`o option=\*(Aqthis isn\e\*(Aqt bad\*(Aq\*(C'\fR or \f(CW\*(C`o option="Bitch holla'd, \e"Isn\*(Aqt
it?\e""\*(C'\fR.
.Sp
For oldschool reasons, tha \f(CW\*(C`=value\*(C'\fR is optionizzle yo, but defaults to
1 only where it is safe ta do so\*(--that is, mostly fo' Boolean
options.  It be always betta ta assign a specific value rockin \f(CW\*(C`=\*(C'\fR.
Da \f(CW\*(C`option\*(C'\fR can be abbreviated yo, but fo' claritizzle probably should
not be.  Several options can be set together n' shit.  See \*(L"Configurable Options\*(R"
for a list of these.
.IP "< ?" 12
.IX Xref "debugger command, <"
List up all pre-prompt Perl command actions.
.IP "< [ command ]" 12
.IX Xref "debugger command, <"
.IX Item "< [ command ]"
Set a action (Perl command) ta happen before every last muthafuckin debugger prompt.
A multi-line command may be entered by backslashin tha newlines.
.IP "< *" 12
.IX Xref "debugger command, <"
Delete all pre-prompt Perl command actions.
.IP "<< command" 12
.IX Xref "debugger command, <<"
.IX Item "<< command"
Add a action (Perl command) ta happen before every last muthafuckin debugger prompt.
A multi-line command may be entered by backwhackin tha newlines.
.IP "> ?" 12
.IX Xref "debugger command, >"
List up post-prompt Perl command actions.
.IP "> command" 12
.IX Xref "debugger command, >"
.IX Item "> command"
Set a action (Perl command) ta happen afta tha prompt when you've
just given a cold-ass lil command ta return ta executin tha script.  A multi-line
command may be entered by backslashin tha newlines (we bet you
couldn't have guessed dis by now).
.IP "> *" 12
.IX Xref "debugger command, >"
Delete all post-prompt Perl command actions.
.IP ">> command" 12
.IX Xref "debugger command, >>"
.IX Item ">> command"
Addz a action (Perl command) ta happen afta tha prompt when you've
just given a cold-ass lil command ta return ta executin tha script.  A multi-line
command may be entered by backslashin tha newlines.
.IP "{ ?" 12
.IX Xref "debugger command, {"
List up pre-prompt debugger commands.
.IP "{ [ command ]" 12
.IX Item "{ [ command ]"
Set a action (debugger command) ta happen before every last muthafuckin debugger prompt.
A multi-line command may be entered up in tha customary fashion.
.Sp
Because dis command is up in some senses new, a warnin is issued if
you step tha fuck up ta have accidentally entered a funky-ass block instead. Y'all KNOW dat shit, muthafucka!  If that's
what you mean ta do, write it as wit \f(CW\*(C`;{ ... }\*(C'\fR or even
\&\f(CW\*(C`do { ... }\*(C'\fR.
.IP "{ *" 12
.IX Xref "debugger command, {"
Delete all pre-prompt debugger commands.
.IP "{{ command" 12
.IX Xref "debugger command, {{"
.IX Item "{{ command"
Add a action (debugger command) ta happen before every last muthafuckin debugger prompt.
A multi-line command may be entered, if you can guess how: peep above.
.IP "! number" 12
.IX Xref "debugger command, !"
.IX Item "! number"
Redo a previous command (defaults ta tha previous command).
.IP "! \-number" 12
.IX Xref "debugger command, !"
.IX Item "! -number"
Redo number'th previous command.
.IP "! pattern" 12
.IX Xref "debugger command, !"
.IX Item "! pattern"
Redo last command dat started wit pattern.
See \f(CW\*(C`o recallCommand\*(C'\fR, like a muthafucka.
.IP "!! cmd" 12
.IX Xref "debugger command, !!"
.IX Item "!! cmd"
Run cmd up in a subprocess (readz from \s-1DB::IN,\s0 writes ta \s-1DB::OUT\s0) See
\&\f(CW\*(C`o shellBang\*(C'\fR, also.  Note dat tha userz current shell (well,
their \f(CW$ENV{SHELL}\fR variable) is ghon be used, which can interfere
with proper interpretation of exit status or signal n' coredump
information.
.IP "source file" 12
.IX Xref "debugger command, source"
.IX Item "source file"
Read n' execute debugger commandz from \fIfile\fR.
\&\fIfile\fR may itself contain \f(CW\*(C`source\*(C'\fR commands.
.IP "H \-number" 12
.IX Xref "debugger command, H"
.IX Item "H -number"
Display last n commands.  Only commandz longer than one characta are
listed. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If \fInumber\fR is omitted, list dem all.
.IP "q or ^D" 12
.IX Xref "debugger command, q debugger command, ^D"
.IX Item "q or ^D"
Quit.  (\*(L"quit\*(R" don't work fo' this, unless you've made a alias)
This is tha only supported way ta exit tha debugger, though typing
\&\f(CW\*(C`exit\*(C'\fR twice might work.
.Sp
Set tha \f(CW\*(C`inhibit_exit\*(C'\fR option ta 0 if you wanna be able ta step
off tha end tha script.  Yo ass may also need ta set \f(CW$finished\fR ta 0
if you wanna step all up in global destruction.
.IP "R" 12
.IX Xref "debugger command, R"
.IX Item "R"
Restart tha debugger by \f(CW\*(C`exec()\*(C'\fRin a freshly smoked up session. I aint talkin' bout chicken n' gravy biatch.  We try ta maintain
your history across dis yo, but internal settings n' command-line options
may be lost.
.Sp
Da followin settin is currently preserved: history, breakpoints,
actions, debugger options, n' tha Perl command-line
options \fB\-w\fR, \fB\-I\fR, n' \fB\-e\fR.
.IP "|dbcmd" 12
.IX Xref "debugger command, |"
.IX Item "|dbcmd"
Run tha debugger command, pipin \s-1DB::OUT\s0 tha fuck into yo' current pager.
.IP "||dbcmd" 12
.IX Xref "debugger command, ||"
.IX Item "||dbcmd"
Same as \f(CW\*(C`|dbcmd\*(C'\fR but \s-1DB::OUT\s0 is temporarily \f(CW\*(C`select\*(C'\fRed as well.
.IP "= [alias value]" 12
.IX Xref "debugger command, ="
.IX Item "= [alias value]"
Define a cold-ass lil command alias, like
.Sp
.Vb 1
\&    = quit q
.Ve
.Sp
or list current aliases.
.IP "command" 12
.IX Item "command"
Execute command as a Perl statement.  A trailin semicolon will be
supplied. Y'all KNOW dat shit, muthafucka!  If tha Perl statement would otherwise be trippin fo' a
Perl debugger, bust a leadin semicolon, like a muthafucka.
.IP "m expr" 12
.IX Xref "debugger command, m"
.IX Item "m expr"
List which methodz may be called on tha result of tha evaluated
expression. I aint talkin' bout chicken n' gravy biatch.  Da expression may evaluated ta a reference ta a
blessed object, or ta a package name.
.IP "M" 12
.IX Xref "debugger command, M"
.IX Item "M"
Display all loaded modulez n' they versions.
.IP "man [manpage]" 12
.IX Xref "debugger command, man"
.IX Item "man [manpage]"
Despite its name, dis calls yo' systemz default documentation
viewer on tha given page, or on tha viewer itself if \fImanpage\fR is
omitted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time.  If dat viewer is \fBman\fR, tha current \f(CW\*(C`Config\*(C'\fR shiznit
is used ta invoke \fBman\fR rockin tha proper \s-1MANPATH\s0 or \fB\-M\fR\ \fImanpath\fR option. I aint talkin' bout chicken n' gravy biatch.  Failed lookupz of tha form \f(CW\*(C`XXX\*(C'\fR dat match
known manpagez of tha form \fIperlXXX\fR is ghon be retried. Y'all KNOW dat shit, muthafucka!  This lets
you type \f(CW\*(C`man debug\*(C'\fR or \f(CW\*(C`man op\*(C'\fR from tha debugger.
.Sp
On systems traditionally bereft of a usable \fBman\fR command, the
debugger invokes \fBperldoc\fR.  Occasionally dis determination is
incorrect cuz of recalcitrant vendors or rather mo' felicitously,
to enterprisin users.  If you fall tha fuck into either category, just
manually set tha \f(CW$DB::doccmd\fR variable ta whatever viewer ta view
the Perl documentation on yo' system.  This may be set up in a rc
file, or all up in direct assignment.  We still waitin fo' a
workin example of suttin' along tha lines of:
.Sp
.Vb 1
\&    $DB::doccmd = \*(Aqnetscape \-remote http://something.here/\*(Aq;
.Ve
.SS "Configurable Options"
.IX Subsection "Configurable Options"
Da debugger has a shitload of options settable rockin tha \f(CW\*(C`o\*(C'\fR command,
either interactively or from tha environment or a rc file.
(./.perldb or ~/.perldb under Unix.)
.ie n .IP """recallCommand"", ""ShellBang""" 12
.el .IP "\f(CWrecallCommand\fR, \f(CWShellBang\fR" 12
.IX Xref "debugger option, recallCommand debugger option, ShellBang"
.IX Item "recallCommand, ShellBang"
Da charactas used ta recall a cold-ass lil command or spawn a gangbangin' finger-lickin' dirty-ass shell.  By
default, both is set ta \f(CW\*(C`!\*(C'\fR, which is unfortunate.
.ie n .IP """pager""" 12
.el .IP "\f(CWpager\fR" 12
.IX Xref "debugger option, pager"
.IX Item "pager"
Program ta use fo' output of pager-piped commandz (those beginning
with a \f(CW\*(C`|\*(C'\fR character.)  By default, \f(CW$ENV{PAGER}\fR is ghon be used.
Because tha debugger uses yo' current terminal characteristics
for bold n' underlining, if tha chosen pager do not pass escape
sequences all up in unchanged, tha output of some debugger commands
will not be readable when busted all up in tha pager.
.ie n .IP """tkRunning""" 12
.el .IP "\f(CWtkRunning\fR" 12
.IX Xref "debugger option, tkRunning"
.IX Item "tkRunning"
Run Tk while promptin (with ReadLine).
.ie n .IP """signalLevel"", ""warnLevel"", ""dieLevel""" 12
.el .IP "\f(CWsignalLevel\fR, \f(CWwarnLevel\fR, \f(CWdieLevel\fR" 12
.IX Xref "debugger option, signalLevel debugger option, warnLevel debugger option, dieLevel"
.IX Item "signalLevel, warnLevel, dieLevel"
Level of verbosity.  By default, tha debugger leaves yo' exceptions
and warnings alone, cuz alterin dem can break erectly hustlin
programs.  It will attempt ta print a message when uncaught \s-1INT, BUS,\s0 or
\&\s-1SEGV\s0 signals arrive.  (But peep tha mention of signals up in \*(L"\s-1BUGS\*(R"\s0 below.)
.Sp
To disable dis default safe mode, set these joints ta suttin' higher
than 0.  At a level of 1, you git backtraces upon receivin any kind
of warnin (this is often buggin) or exception (this is
often valuable).  Unfortunately, tha debugger cannot discern fatal
exceptions from non-fatal ones.  If \f(CW\*(C`dieLevel\*(C'\fR is even 1, then your
non-fatal exceptions is also traced n' unceremoniously altered if they
came from \f(CW\*(C`eval\*(Aqed\*(C'\fR strings or from any kind of \f(CW\*(C`eval\*(C'\fR within modules
yo ass be attemptin ta load. Y'all KNOW dat shit, muthafucka!  If \f(CW\*(C`dieLevel\*(C'\fR is 2, tha debugger don't
care where they came from:  It usurps yo' exception handlez n' prints
out a trace, then modifies all exceptions wit its own embellishments.
This may like be useful fo' some tracin purposes yo, but tendz ta hopelessly
destroy any program dat takes its exception handlin seriously.
.ie n .IP """AutoTrace""" 12
.el .IP "\f(CWAutoTrace\fR" 12
.IX Xref "debugger option, AutoTrace"
.IX Item "AutoTrace"
Trace mode (similar ta \f(CW\*(C`t\*(C'\fR command yo, but can be put into
\&\f(CW\*(C`PERLDB_OPTS\*(C'\fR).
.ie n .IP """LineInfo""" 12
.el .IP "\f(CWLineInfo\fR" 12
.IX Xref "debugger option, LineInfo"
.IX Item "LineInfo"
File or pipe ta print line number info to.  If it aint nuthin but a pipe (say,
\&\f(CW\*(C`|visual_perl_db\*(C'\fR), then a gangbangin' finger-lickin' dirty-ass short message is used. Y'all KNOW dat shit, muthafucka!  This is the
mechanizzle used ta interact wit a slave editor or visual debugger,
like fuckin tha special \f(CW\*(C`vi\*(C'\fR or \f(CW\*(C`emacs\*(C'\fR hooks, or tha \f(CW\*(C`ddd\*(C'\fR graphical
debugger.
.ie n .IP """inhibit_exit""" 12
.el .IP "\f(CWinhibit_exit\fR" 12
.IX Xref "debugger option, inhibit_exit"
.IX Item "inhibit_exit"
If 0, allows \fIsteppin off\fR tha end of tha script.
.ie n .IP """PrintRet""" 12
.el .IP "\f(CWPrintRet\fR" 12
.IX Xref "debugger option, PrintRet"
.IX Item "PrintRet"
Print return value afta \f(CW\*(C`r\*(C'\fR command if set (default).
.ie n .IP """ornaments""" 12
.el .IP "\f(CWornaments\fR" 12
.IX Xref "debugger option, ornaments"
.IX Item "ornaments"
Affects screen appearizzle of tha command line (see Term::ReadLine).
There is currently no way ta disable these, which can render
some output illegible on some displays, or wit some pagers.
This is considered a funky-ass bug.
.ie n .IP """frame""" 12
.el .IP "\f(CWframe\fR" 12
.IX Xref "debugger option, frame"
.IX Item "frame"
Affects tha printin of lyrics upon entry n' exit from subroutines.  If
\&\f(CW\*(C`frame & 2\*(C'\fR is false, lyrics is printed on entry only. (Printing
on exit might be useful if interspersed wit other lyrics.)
.Sp
If \f(CW\*(C`frame & 4\*(C'\fR, arguments ta functions is printed, plus context
and calla info.  If \f(CW\*(C`frame & 8\*(C'\fR, overloaded \f(CW\*(C`stringify\*(C'\fR and
\&\f(CW\*(C`tie\*(C'\fRd \f(CW\*(C`FETCH\*(C'\fR is enabled on tha printed arguments, n' you can put dat on yo' toast.  If \f(CW\*(C`frame
& 16\*(C'\fR, tha return value from tha subroutine is printed.
.Sp
Da length at which tha argument list is truncated is governed by the
next option:
.ie n .IP """maxTraceLen""" 12
.el .IP "\f(CWmaxTraceLen\fR" 12
.IX Xref "debugger option, maxTraceLen"
.IX Item "maxTraceLen"
Length ta truncate tha argument list when tha \f(CW\*(C`frame\*(C'\fR option's
bit 4 is set.
.ie n .IP """windowSize""" 12
.el .IP "\f(CWwindowSize\fR" 12
.IX Xref "debugger option, windowSize"
.IX Item "windowSize"
Change tha size of code list window (default is 10 lines).
.PP
Da followin options affect what tha fuck happens wit \f(CW\*(C`V\*(C'\fR, \f(CW\*(C`X\*(C'\fR, n' \f(CW\*(C`x\*(C'\fR
commands:
.ie n .IP """arrayDepth"", ""hashDepth""" 12
.el .IP "\f(CWarrayDepth\fR, \f(CWhashDepth\fR" 12
.IX Xref "debugger option, arrayDepth debugger option, hashDepth"
.IX Item "arrayDepth, hashDepth"
Print only first N elements ('' fo' all).
.ie n .IP """dumpDepth""" 12
.el .IP "\f(CWdumpDepth\fR" 12
.IX Xref "debugger option, dumpDepth"
.IX Item "dumpDepth"
Limit recursion depth ta N levels when dumpin structures.
Negatizzle joints is interpreted as infinity.  Default: infinity.
.ie n .IP """compactDump"", ""veryCompact""" 12
.el .IP "\f(CWcompactDump\fR, \f(CWveryCompact\fR" 12
.IX Xref "debugger option, compactDump debugger option, hellaCompact"
.IX Item "compactDump, hellaCompact"
Change tha steez of array n' hash output.  If \f(CW\*(C`compactDump\*(C'\fR, short array
may be printed on one line.
.ie n .IP """globPrint""" 12
.el .IP "\f(CWglobPrint\fR" 12
.IX Xref "debugger option, globPrint"
.IX Item "globPrint"
Whether ta print contentz of globs.
.ie n .IP """DumpDBFiles""" 12
.el .IP "\f(CWDumpDBFiles\fR" 12
.IX Xref "debugger option, DumpDBFiles"
.IX Item "DumpDBFiles"
Dump arrays holdin debugged files.
.ie n .IP """DumpPackages""" 12
.el .IP "\f(CWDumpPackages\fR" 12
.IX Xref "debugger option, DumpPackages"
.IX Item "DumpPackages"
Dump symbol tablez of packages.
.ie n .IP """DumpReused""" 12
.el .IP "\f(CWDumpReused\fR" 12
.IX Xref "debugger option, DumpReused"
.IX Item "DumpReused"
Dump contentz of \*(L"reused\*(R" addresses.
.ie n .IP """quote"", ""HighBit"", ""undefPrint""" 12
.el .IP "\f(CWquote\fR, \f(CWHighBit\fR, \f(CWundefPrint\fR" 12
.IX Xref "debugger option, quote debugger option, HighBit debugger option, undefPrint"
.IX Item "quote, HighBit, undefPrint"
Change tha steez of strang dump.  Da default value fo' \f(CW\*(C`quote\*(C'\fR
is \f(CW\*(C`auto\*(C'\fR; one can enable double-quotish or single-quotish format
by settin it ta \f(CW\*(C`"\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR, respectively.  By default, characters
with they high bit set is printed verbatim.
.ie n .IP """UsageOnly""" 12
.el .IP "\f(CWUsageOnly\fR" 12
.IX Xref "debugger option, UsageOnly"
.IX Item "UsageOnly"
Rudimentary per-package memory usage dump.  Calculates total
size of strings found up in variablez up in tha package.  This do not
include lexicals up in a modulez file scope, or lost up in closures.
.ie n .IP """HistFile""" 12
.el .IP "\f(CWHistFile\fR" 12
.IX Xref "debugger option, history, HistFile"
.IX Item "HistFile"
Da path of tha file from which tha history (assumin a usable
Term::ReadLine backend) is ghon be read on tha debuggerz startup, n' ta which
it is ghon be saved on shutdown (for persistence across sessions). Right back up in yo muthafuckin ass. Similar in
concept ta Bashz \f(CW\*(C`.bash_history\*(C'\fR file.
.ie n .IP """HistSize""" 12
.el .IP "\f(CWHistSize\fR" 12
.IX Xref "debugger option, history, HistSize"
.IX Item "HistSize"
Da count of tha saved lines up in tha history (assumin \f(CW\*(C`HistFile\*(C'\fR above).
.PP
Afta tha rc file is read, tha debugger readz tha \f(CW$ENV{PERLDB_OPTS}\fR
environment variable n' parses dis as tha remainder of a \*(L"O ...\*(R"
line as one might enta all up in tha debugger prompt.  Yo ass may place the
initialization options \f(CW\*(C`TTY\*(C'\fR, \f(CW\*(C`noTTY\*(C'\fR, \f(CW\*(C`ReadLine\*(C'\fR, n' \f(CW\*(C`NonStop\*(C'\fR
there.
.PP
If yo' rc file gotz nuff:
.PP
.Vb 1
\&  parse_options("NonStop=1 LineInfo=db.out AutoTrace");
.Ve
.PP
then yo' script will run without human intervention, puttin trace
information tha fuck into tha file \fIdb.out\fR.  (If you interrupt it, you'd
betta reset \f(CW\*(C`LineInfo\*(C'\fR ta \fI/dev/tty\fR if you expect ta peep anything.)
.ie n .IP """TTY""" 12
.el .IP "\f(CWTTY\fR" 12
.IX Xref "debugger option, TTY"
.IX Item "TTY"
Da \s-1TTY\s0 ta use fo' debuggin I/O.
.ie n .IP """noTTY""" 12
.el .IP "\f(CWnoTTY\fR" 12
.IX Xref "debugger option, noTTY"
.IX Item "noTTY"
If set, tha debugger goes tha fuck into \f(CW\*(C`NonStop\*(C'\fR mode n' aint gonna connect ta a \s-1TTY. \s0 If
interrupted (or if control goes ta tha debugger via explicit settin of
\&\f(CW$DB::signal\fR or \f(CW$DB::single\fR from tha Perl script), it connects ta a \s-1TTY\s0
specified up in tha \f(CW\*(C`TTY\*(C'\fR option at startup, or ta a tty found at
runtime rockin tha \f(CW\*(C`Term::Rendezvous\*(C'\fR module of yo' chizzle.
.Sp
This module should implement a method named \f(CW\*(C`new\*(C'\fR dat returns a object
with two methods: \f(CW\*(C`IN\*(C'\fR n' \f(CW\*(C`OUT\*(C'\fR.  These should return filehandlez ta use
for debuggin input n' output correspondingly.  Da \f(CW\*(C`new\*(C'\fR method should
inspect a argument containin tha value of \f(CW$ENV{PERLDB_NOTTY}\fR at
startup, or \f(CW"$ENV{HOME}/.perldbtty$$"\fR otherwise.  This file is not
inspected fo' proper ballership, so securitizzle hazardz is theoretically
possible.
.ie n .IP """ReadLine""" 12
.el .IP "\f(CWReadLine\fR" 12
.IX Xref "debugger option, ReadLine"
.IX Item "ReadLine"
If false, readline support up in tha debugger is disabled up in order
to debug applications dat theyselves use ReadLine.
.ie n .IP """NonStop""" 12
.el .IP "\f(CWNonStop\fR" 12
.IX Xref "debugger option, NonStop"
.IX Item "NonStop"
If set, tha debugger goes tha fuck into non-interactizzle mode until interrupted, or
programmatically by settin \f(CW$DB::signal\fR or \f(CW$DB::single\fR.
.PP
Herez a example of rockin tha \f(CW$ENV{PERLDB_OPTS}\fR variable:
.PP
.Vb 1
\&    $ PERLDB_OPTS="NonQuit frame=2" perl \-d myprogram
.Ve
.PP
That will run tha script \fBmyprogram\fR without human intervention,
printin up tha call tree wit entry n' exit points, n' you can put dat on yo' toast.  Note that
\&\f(CW\*(C`NonStop=1 frame=2\*(C'\fR is equivalent ta \f(CW\*(C`N f=2\*(C'\fR, n' dat originally,
options could be uniquely abbreviated by tha straight-up original gangsta letta (modulo
the \f(CW\*(C`Dump*\*(C'\fR options).  It be nevertheless recommended dat you
always spell dem up in full fo' legibilitizzle n' future compatibility.
.PP
Other examplez include
.PP
.Vb 1
\&    $ PERLDB_OPTS="NonQuit LineInfo=listin frame=2" perl \-d myprogram
.Ve
.PP
which runs script non-interactively, printin info on each entry
into a subroutine n' each executed line tha fuck into tha file named \fIlisting\fR.
(If you interrupt it, you would betta reset \f(CW\*(C`LineInfo\*(C'\fR ta something
\&\*(L"interactive\*(R"!)
.PP
Other examplez include (usin standard shell syntax ta show environment
variable settings):
.PP
.Vb 2
\&  $ ( PERLDB_OPTS="NonQuit frame=1 AutoTrace LineInfo=tperl.out"
\&      perl \-d myprogram )
.Ve
.PP
which may be useful fo' debuggin a program dat uses \f(CW\*(C`Term::ReadLine\*(C'\fR
itself.  Do not forget ta detach yo' shell from tha \s-1TTY\s0 up in tha window that
correspondz ta \fI/dev/ttyXX\fR, say, by issuin a cold-ass lil command like
.PP
.Vb 1
\&  $ chill 1000000
.Ve
.PP
See \*(L"Debugger Internals\*(R" up in perldebguts fo' details.
.SS "Debugger Input/Output"
.IX Subsection "Debugger Input/Output"
.IP "Prompt" 8
.IX Item "Prompt"
Da debugger prompt is suttin' like
.Sp
.Vb 1
\&    DB<8>
.Ve
.Sp
or even
.Sp
.Vb 1
\&    DB<<17>>
.Ve
.Sp
where dat number is tha command number, n' which you'd use to
access wit tha built-in \fBcsh\fR\-like history mechanism.  For example,
\&\f(CW\*(C`!17\*(C'\fR would repeat command number 17.  Da depth of tha angle
brackets indicates tha nestin depth of tha debugger n' shit.  Yo ass could
get mo' than one set of brackets, fo' example, if you'd already
at a funky-ass breakpoint n' then printed tha result of a gangbangin' function call that
itself has a funky-ass breakpoint, or you step tha fuck into a expression via \f(CW\*(C`s/n/t
expression\*(C'\fR command.
.IP "Multiline commands" 8
.IX Item "Multiline commands"
If you wanna enta a multi-line command, like fuckin a subroutine
definizzle wit nuff muthafuckin statements or a gangbangin' format, escape tha newline
that would normally end tha debugger command wit a funky-ass backslash.
Herez a example:
.Sp
.Vb 7
\&      DB<1> fo' (1..4) {         \e
\&      cont:     print "ok\en";   \e
\&      cont: }
\&      ok
\&      ok
\&      ok
\&      ok
.Ve
.Sp
Note dat dis bidnizz of escapin a newline is specific ta interactive
commandz typed tha fuck into tha debugger.
.IP "Stack backtrace" 8
.IX Xref "backtrace stack, backtrace"
.IX Item "Stack backtrace"
Herez a example of what tha fuck a stack backtrace via \f(CW\*(C`T\*(C'\fR command might
look like:
.Sp
.Vb 3
\&    $ = main::infested called from file \*(AqAmbulation.pm\*(Aq line 10
\&    @ = Ambulation::legs(1, 2, 3, 4) called from file \*(Aqcamel_flea\*(Aq line 7
\&    $ = main::pests(\*(Aqbactrian\*(Aq, 4) called from file \*(Aqcamel_flea\*(Aq line 4
.Ve
.Sp
Da left-hand characta up there indicates tha context up in which the
function was called, wit \f(CW\*(C`$\*(C'\fR n' \f(CW\*(C`@\*(C'\fR meanin scalar or list
contexts respectively, n' \f(CW\*(C`.\*(C'\fR meanin void context (which is
actually a sort of scalar context).  Da display above says
that you was up in tha function \f(CW\*(C`main::infested\*(C'\fR when you ran the
stack dump, n' dat dat shiznit was called up in scalar context from line
10 of tha file \fIAmbulation.pm\fR yo, but without any arguments at all,
meanin dat shiznit was called as \f(CW&infested\fR.  Da next stack frame shows
that tha function \f(CW\*(C`Ambulation::legs\*(C'\fR was called up in list context
from tha \fIcamel_flea\fR file wit four arguments, n' you can put dat on yo' toast.  Da last stack
frame shows dat \f(CW\*(C`main::pests\*(C'\fR was called up in scalar context,
also from \fIcamel_flea\fR yo, but from line 4.
.Sp
If you execute tha \f(CW\*(C`T\*(C'\fR command from inside a actizzle \f(CW\*(C`use\*(C'\fR
statement, tha backtrace will contain both a \f(CW\*(C`require\*(C'\fR frame and
an \f(CW\*(C`eval\*(C'\fR frame.
.IP "Line Listin Format" 8
.IX Item "Line Listin Format"
This shows tha sortz of output tha \f(CW\*(C`l\*(C'\fR command can produce:
.Sp
.Vb 11
\&    DB<<13>> l
\&  101:                @i{@i} = ();
\&  102:b               @isa{@i,$pack} = ()
\&  103                     if(exists $i{$prevpack} || exists $isa{$pack});
\&  104             }
\&  105
\&  106             next
\&  107==>              if(exists $isa{$pack});
\&  108
\&  109:a           if ($extra\-\- > 0) {
\&  110:                %isa = ($pack,1);
.Ve
.Sp
Breakable lines is marked wit \f(CW\*(C`:\*(C'\fR.  Lines wit breakpoints are
marked by \f(CW\*(C`b\*(C'\fR n' dem wit actions by \f(CW\*(C`a\*(C'\fR.  Da line that's
about ta be executed is marked by \f(CW\*(C`==>\*(C'\fR.
.Sp
Please be aware dat code up in debugger listings may not look tha same
as yo' original gangsta source code.  Line directives n' external source
filtas can alta tha code before Perl sees it, causin code ta move
from its original gangsta positions or take on entirely different forms.
.IP "Frame listing" 8
.IX Item "Frame listing"
When tha \f(CW\*(C`frame\*(C'\fR option is set, tha debugger would print entered (and
optionally exited) subroutines up in different styles.  See perldebguts
for incredibly long examplez of these.
.SS "Debuggin Compile-Time Statements"
.IX Subsection "Debuggin Compile-Time Statements"
If you have compile-time executable statements (like fuckin code within
\&\s-1BEGIN, UNITCHECK\s0 n' \s-1CHECK\s0 blocks or \f(CW\*(C`use\*(C'\fR statements), these will
\&\fInot\fR be stopped by debugger, although \f(CW\*(C`require\*(C'\fRs n' \s-1INIT\s0 blocks
will, n' compile-time statements can be traced wit tha \f(CW\*(C`AutoTrace\*(C'\fR
option set up in \f(CW\*(C`PERLDB_OPTS\*(C'\fR).  From yo' own Perl code, however, you
can transfer control back ta tha debugger rockin tha following
statement, which is harmless if tha debugger aint hustlin:
.PP
.Vb 1
\&    $DB::single = 1;
.Ve
.PP
If you set \f(CW$DB::single\fR ta 2, itz equivalent ta having
just typed tha \f(CW\*(C`n\*(C'\fR command, whereas a value of 1 means tha \f(CW\*(C`s\*(C'\fR
command. Y'all KNOW dat shit, muthafucka!  Da \f(CW$DB::trace\fR  variable should be set ta 1 ta simulate
havin typed tha \f(CW\*(C`t\*(C'\fR command.
.PP
Another way ta debug compile-time code is ta start tha debugger, set a
breakpoint on tha \fIload\fR of some module:
.PP
.Vb 2
\&    DB<7> b load f:/perllib/lib/Carp.pm
\&  Will stop on load of \*(Aqf:/perllib/lib/Carp.pm\*(Aq.
.Ve
.PP
and then restart tha debugger rockin tha \f(CW\*(C`R\*(C'\fR command (if possible).  One can use \f(CW\*(C`b
compile subname\*(C'\fR fo' tha same purpose.
.SS "Debugger Customization"
.IX Subsection "Debugger Customization"
Da debugger probably gotz nuff enough configuration hooks dat you
won't eva gotta modify it yo ass.  Yo ass may chizzle tha behaviour
of tha debugger from within tha debugger rockin its \f(CW\*(C`o\*(C'\fR command, from
the command line via tha \f(CW\*(C`PERLDB_OPTS\*(C'\fR environment variable, and
from customization files.
.PP
Yo ass can do some customization by settin up a \fI.perldb\fR file, which
gotz nuff initialization code.  For instance, you could make aliases
like these (the last one is one playas expect ta be there):
.PP
.Vb 4
\&    $DB::alias{\*(Aqlen\*(Aq}  = \*(Aqs/^len(.*)/p length($1)/\*(Aq;
\&    $DB::alias{\*(Aqstop\*(Aq} = \*(Aqs/^stop (at|in)/b/\*(Aq;
\&    $DB::alias{\*(Aqps\*(Aq}   = \*(Aqs/^ps\eb/p scalar /\*(Aq;
\&    $DB::alias{\*(Aqquit\*(Aq} = \*(Aqs/^quit(\es*)/exit/\*(Aq;
.Ve
.PP
Yo ass can chizzle options from \fI.perldb\fR by rockin calls like dis one;
.PP
.Vb 1
\&    parse_options("NonStop=1 LineInfo=db.out AutoTrace=1 frame=2");
.Ve
.PP
Da code is executed up in tha package \f(CW\*(C`DB\*(C'\fR.  Note dat \fI.perldb\fR is
processed before processin \f(CW\*(C`PERLDB_OPTS\*(C'\fR.  If \fI.perldb\fR defines the
subroutine \f(CW\*(C`afterinit\*(C'\fR, dat function is called afta debugger
initialization ends.  \fI.perldb\fR may be contained up in tha current
directory, or up in tha home directory.  Because dis file is sourced
in by Perl n' may contain arbitrary commands, fo' securitizzle reasons,
it must be owned by tha superuser or tha current user, n' writable
by no one but its baller.
.PP
Yo ass can mock \s-1TTY\s0 input ta debugger by addin arbitrary commandz to
\&\f(CW@DB::typeahead\fR. For example, yo' \fI.perldb\fR file might contain:
.PP
.Vb 1
\&    sub afterinit { push @DB::typeahead, "b 4", "b 6"; }
.Ve
.PP
Which would attempt ta set breakpoints on lines 4 n' 6 immediately
afta debugger initialization. I aint talkin' bout chicken n' gravy biatch. Note dat \f(CW@DB::typeahead\fR aint a supported
interface n' is subject ta chizzle up in future releases.
.PP
If you wanna modify tha debugger, copy \fIperl5db.pl\fR from the
Perl library ta another name n' hack it ta yo' heartz content.
You'll then wanna set yo' \f(CW\*(C`PERL5DB\*(C'\fR environment variable ta say
suttin' like this:
.PP
.Vb 1
\&    BEGIN { require "myperl5db.pl" }
.Ve
.PP
As a last resort, you could also use \f(CW\*(C`PERL5DB\*(C'\fR ta customize tha debugger
by directly settin internal variablez or callin debugger functions.
.PP
Note dat any variablez n' functions dat is not documented in
this document (or up in perldebguts) is considered fo' internal
use only, n' as such is subject ta chizzle without notice.
.SS "Readline Support / History up in tha Debugger"
.IX Subsection "Readline Support / History up in tha Debugger"
As shipped, tha only command-line history supplied be a simplistic one
that checks fo' leadin exclamation points, n' you can put dat on yo' toast.  But fuck dat shiznit yo, tha word on tha street is dat if you install
the Term::ReadKey n' Term::ReadLine modulez from \s-1CPAN \s0(such as
Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will
have full editin capabilitizzles much like dem \s-1GNU \s0\fIreadline\fR(3) provides.
Look fo' these up in tha \fImodules/by\-module/Term\fR directory on \s-1CPAN.\s0
These do not support aiiight \fBvi\fR command-line editing, however.
.PP
A rudimentary command-line completion be also available, including
lexical variablez up in tha current scope if tha \f(CW\*(C`PadWalker\*(C'\fR module
is installed.
.PP
Without Readline support you may peep tha symbols \*(L"^[[A\*(R", \*(L"^[[C\*(R", \*(L"^[[B\*(R",
\&\*(L"^[[D\*(R"\*(L", \*(R"^H", ... when rockin tha arrow keys and/or tha backspace key.
.SS "Editor Support fo' Debugging"
.IX Subsection "Editor Support fo' Debugging"
If you have tha \s-1FSF\s0z version of \fBemacs\fR installed on yo' system,
it can interact wit tha Perl debugger ta provide a integrated
software pimpment environment reminiscent of its interactions
with C debuggers.
.PP
Recent versionz of Emacs come wit a
start file fo' makin \fBemacs\fR act like a
syntax-pimped up editor dat understandz (some of) Perlz syntax.
See perlfaq3.
.PP
A similar setup by Tomothy Christiansen fo' interactin wit any
vendor-shipped \fBvi\fR n' tha X11 window system be also available.
This works similarly ta tha integrated multiwindow support that
\&\fBemacs\fR provides, where tha debugger drives tha editor. Shiiit, dis aint no joke.  At the
time of dis writing, however, dat toolz eventual location up in the
Perl distribution was uncertain.
.PP
Userz of \fBvi\fR should also look tha fuck into \fBvim\fR n' \fBgvim\fR, tha mousey
and windy version, fo' colorin of Perl keywords.
.PP
Note dat only perl can truly parse Perl, so all such \s-1CASE\s0 tools
fall somewhat short of tha mark, especially if you don't program
your Perl as a C programmer might.
.SS "Da Perl Profiler"
.IX Xref "profile profilin profiler"
.IX Subsection "Da Perl Profiler"
If you wish ta supply a alternatizzle debugger fo' Perl ta run,
invoke yo' script wit a cold-ass lil colon n' a package argument given ta the
\&\fB\-d\fR flag.  Perlz alternatizzle debuggers include a Perl profiler,
Devel::NYTProf, which be available separately as a \s-1CPAN\s0
distribution. I aint talkin' bout chicken n' gravy biatch.  To flava yo' Perl program up in tha file \fImycode.pl\fR,
just type:
.PP
.Vb 1
\&    $ perl \-d:NYTProf mycode.pl
.Ve
.PP
When tha script terminates tha profila will create a thugged-out database of the
profile shiznit dat you can turn tha fuck into reports rockin tha profiler's
tools. Right back up in yo muthafuckin ass. See <perlperf> fo' details.
.SH "Debuggin Regular Expressions"
.IX Xref "regular expression, debuggin regex, debuggin regexp, debugging"
.IX Header "Debuggin Regular Expressions"
\&\f(CW\*(C`use re \*(Aqdebug\*(Aq\*(C'\fR enablez you ta peep tha gory detailz of how tha fuck tha Perl
regular expression engine works. In order ta KNOW dis typically
voluminous output, one must not only have some scam bout how tha fuck regular
expression matchin works up in general yo, but also know how tha fuck Perlz regular
expressions is internally compiled tha fuck into a automaton. I aint talkin' bout chicken n' gravy biatch. These matters
are explored up in some detail in
\&\*(L"Debuggin Regular Expressions\*(R" up in perldebguts.
.SH "Debuggin Memory Usage"
.IX Xref "memory usage"
.IX Header "Debuggin Memory Usage"
Perl gotz nuff internal support fo' reportin its own memory usage,
but dis be a gangbangin' fairly advanced concept dat requires some understanding
of how tha fuck memory allocation works.
See \*(L"Debuggin Perl Memory Usage\*(R" up in perldebguts fo' tha details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Yo ass did try tha \fB\-w\fR switch, didn't yo slick ass?
.PP
perldebtut,
perldebguts,
re,
\&\s-1DB\s0,
Devel::NYTProf,
Dumpvalue,
and
perlrun.
.PP
When debuggin a script dat uses #! n' is thus normally found in
\&\f(CW$PATH\fR, tha \-S option causes perl ta search \f(CW$PATH\fR fo' it, so you don't
have ta type tha path or \f(CW\*(C`which $scriptname\*(C'\fR.
.PP
.Vb 1
\&  $ perl \-Sd foo.pl
.Ve
.SH "BUGS"
.IX Header "BUGS"
Yo ass cannot git stack frame shiznit or up in any fashizzle debug functions
that was not compiled by Perl, like fuckin dem from C or \*(C+ extensions.
.PP
If you alta yo' \f(CW@_\fR arguments up in a subroutine (like fuckin wit \f(CW\*(C`shift\*(C'\fR
or \f(CW\*(C`pop\*(C'\fR), tha stack backtrace aint gonna show tha original gangsta joints.
.PP
Da debugger do not currently work up in conjunction wit tha \fB\-W\fR
command-line switch, cuz it itself aint free of warnings.
.PP
If you up in a slow syscall (like \f(CW\*(C`wait\*(C'\fRing, \f(CW\*(C`accept\*(C'\fRing, or \f(CW\*(C`read\*(C'\fRing
from yo' keyboard or a socket) n' aint set up yo' own \f(CW$SIG{INT}\fR
handlez, then you won't be able ta CTRL-C yo' way back ta tha debugger,
because tha debuggerz own \f(CW$SIG{INT}\fR handlez don't KNOW that
it need ta raise a exception ta \fIlongjmp\fR\|(3) outta slow syscalls.
