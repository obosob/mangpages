.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PKEYUTL 1"
.TH PKEYUTL 1 "2013-02-11" "1.0.1e" "OpenSSL"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
pkeyutl \- hood key algorithm utility
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBopenssl\fR \fBpkeyutl\fR
[\fB\-in file\fR]
[\fB\-out file\fR]
[\fB\-sigfile file\fR]
[\fB\-inkey file\fR]
[\fB\-keyform PEM|DER\fR]
[\fB\-passin arg\fR]
[\fB\-peerkey file\fR]
[\fB\-peerform PEM|DER\fR]
[\fB\-pubin\fR]
[\fB\-certin\fR]
[\fB\-rev\fR]
[\fB\-sign\fR]
[\fB\-verify\fR]
[\fB\-verifyrecover\fR]
[\fB\-encrypt\fR]
[\fB\-decrypt\fR]
[\fB\-derive\fR]
[\fB\-pkeyopt opt:value\fR]
[\fB\-hexdump\fR]
[\fB\-asn1parse\fR]
[\fB\-engine id\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Da \fBpkeyutl\fR command can be used ta big-ass up hood key operations using
any supported algorithm.
.SH "COMMAND OPTIONS"
.IX Header "COMMAND OPTIONS"
.IP "\fB\-in filename\fR" 4
.IX Item "-in filename"
This specifies tha input filename ta read data from or standard input
if dis option aint specified.
.IP "\fB\-out filename\fR" 4
.IX Item "-out filename"
specifies tha output filename ta write ta or standard output by
default.
.IP "\fB\-inkey file\fR" 4
.IX Item "-inkey file"
the input key file, by default it should be a private key.
.IP "\fB\-keyform PEM|DER\fR" 4
.IX Item "-keyform PEM|DER"
the key format \s-1PEM, DER\s0 or \s-1ENGINE.\s0
.IP "\fB\-passin arg\fR" 4
.IX Item "-passin arg"
the input key password source. For mo' shiznit bout tha format of \fBarg\fR
see tha \fB\s-1PASS PHRASE ARGUMENTS\s0\fR section up in \fIopenssl\fR\|(1).
.IP "\fB\-peerkey file\fR" 4
.IX Item "-peerkey file"
the peer key file, used by key derivation (agreement) operations.
.IP "\fB\-peerform PEM|DER\fR" 4
.IX Item "-peerform PEM|DER"
the peer key format \s-1PEM, DER\s0 or \s-1ENGINE.\s0
.IP "\fB\-engine id\fR" 4
.IX Item "-engine id"
specifyin a engine (by its unique \fBid\fR string) will cause \fBpkeyutl\fR
to attempt ta obtain a gangbangin' functionizzle reference ta tha specified engine,
thus initialisin it if needed. Y'all KNOW dat shit, muthafucka! Da engine will then be set as tha default
for all available algorithms.
.IP "\fB\-pubin\fR" 4
.IX Item "-pubin"
the input file be a hood key.
.IP "\fB\-certin\fR" 4
.IX Item "-certin"
the input be a cold-ass lil certificate containin a hood key.
.IP "\fB\-rev\fR" 4
.IX Item "-rev"
reverse tha order of tha input buffer n' shit. This is useful fo' some libraries
(like fuckin CryptoAPI) which represent tha buffer up in lil endian format.
.IP "\fB\-sign\fR" 4
.IX Item "-sign"
sign tha input data n' output tha signed result. This requires
a private key.
.IP "\fB\-verify\fR" 4
.IX Item "-verify"
verify tha input data against tha signature file n' indicate if the
verification succeeded or failed.
.IP "\fB\-verifyrecover\fR" 4
.IX Item "-verifyrecover"
verify tha input data n' output tha recovered data.
.IP "\fB\-encrypt\fR" 4
.IX Item "-encrypt"
encrypt tha input data rockin a hood key.
.IP "\fB\-decrypt\fR" 4
.IX Item "-decrypt"
decrypt tha input data rockin a private key.
.IP "\fB\-derive\fR" 4
.IX Item "-derive"
derive a gangbangin' finger-lickin' dirty-ass shared secret rockin tha peer key.
.IP "\fB\-hexdump\fR" 4
.IX Item "-hexdump"
hex dump tha output data.
.IP "\fB\-asn1parse\fR" 4
.IX Item "-asn1parse"
asn1parse tha output data, dis is useful when combined wit the
\&\fB\-verifyrecover\fR option when a \s-1ASN1\s0 structure is signed.
.SH "NOTES"
.IX Header "NOTES"
Da operations n' options supported vary accordin ta tha key algorithm
and its implementation. I aint talkin' bout chicken n' gravy biatch. Da OpenSSL operations n' options is indicated below.
.PP
Unless otherwise mentioned all algorithms support tha \fBdigest:alg\fR option
which specifies tha digest up in use fo' sign, verify n' verifyrecover operations.
Da value \fBalg\fR should represent a gangbangin' finger-lickin' digest name as used up in the
\&\fIEVP_get_digestbyname()\fR function fo' example \fBsha1\fR.
.SH "RSA ALGORITHM"
.IX Header "RSA ALGORITHM"
Da \s-1RSA\s0 algorithm supports encrypt, decrypt, sign, verify n' verifyrecover
operations up in general. It aint nuthin but tha nick nack patty wack, I still gots tha bigger sack. Right back up in yo muthafuckin ass. Some paddin modes only support a shitload of these 
operations however.
.IP "\-\fBrsa_padding_mode:mode\fR" 4
.IX Item "-rsa_padding_mode:mode"
This sets tha \s-1RSA\s0 paddin mode fo' realz. Acceptable joints fo' \fBmode\fR is \fBpkcs1\fR for
PKCS#1 padding, \fBsslv23\fR fo' SSLv23 padding, \fBnone\fR fo' no padding, \fBoaep\fR
for \fB\s-1OAEP\s0\fR mode, \fBx931\fR fo' X9.31 mode n' \fBpss\fR fo' \s-1PSS.\s0
.Sp
In PKCS#1 paddin if tha message digest aint set then tha supplied data is 
signed or verified directly instead of rockin a \fBDigestInfo\fR structure. If a
digest is set then tha a \fBDigestInfo\fR structure is used n' its tha length
must correspond ta tha digest type.
.Sp
For \fBoeap\fR mode only encryption n' decryption is supported.
.Sp
For \fBx931\fR if tha digest type is set it is used ta format tha block data
otherwise tha straight-up original gangsta byte is used ta specify tha X9.31 digest \s-1ID.\s0 Sign,
verify n' verifyrecover is can be performed up in dis mode.
.Sp
For \fBpss\fR mode only sign n' verify is supported n' tha digest type must be
specified.
.IP "\fBrsa_pss_saltlen:len\fR" 4
.IX Item "rsa_pss_saltlen:len"
For \fBpss\fR mode only dis option specifies tha salt length. Two special joints
are supported: \-1 sets tha salt length ta tha digest length. When signin \-2
sets tha salt length ta tha maximum permissible value. When verifyin \-2 causes
the salt length ta be automatically determined based on tha \fB\s-1PSS\s0\fR block
structure.
.SH "DSA ALGORITHM"
.IX Header "DSA ALGORITHM"
Da \s-1DSA\s0 algorithm supports signin n' verification operations only. Currently
there is no additionizzle options other than \fBdigest\fR. Only tha \s-1SHA1\s0
digest can be used n' dis digest be assumed by default.
.SH "DH ALGORITHM"
.IX Header "DH ALGORITHM"
Da \s-1DH\s0 algorithm only supports tha derivation operation n' no additional
options.
.SH "EC ALGORITHM"
.IX Header "EC ALGORITHM"
Da \s-1EC\s0 algorithm supports sign, verify n' derive operations. Da sign and
verify operations use \s-1ECDSA\s0 n' derive uses \s-1ECDH.\s0 Currently there be no
additionizzle options other than \fBdigest\fR. Only tha \s-1SHA1\s0 digest can be used and
this digest be assumed by default.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Sign some data rockin a private key:
.PP
.Vb 1
\& openssl pkeyutl \-sign \-in file \-inkey key.pem \-out sig
.Ve
.PP
Recover tha signed data (e.g. if a \s-1RSA\s0 key is used):
.PP
.Vb 1
\& openssl pkeyutl \-verifyrecover \-in sig \-inkey key.pem
.Ve
.PP
Verify tha signature (e.g. a \s-1DSA\s0 key):
.PP
.Vb 1
\& openssl pkeyutl \-verify \-in file \-sigfile sig \-inkey key.pem
.Ve
.PP
Sign data rockin a message digest value (this is currently only valid fo' \s-1RSA\s0):
.PP
.Vb 1
\& openssl pkeyutl \-sign \-in file \-inkey key.pem \-out sig \-pkeyopt digest:sha256
.Ve
.PP
Derive a gangbangin' finger-lickin' dirty-ass shared secret value:
.PP
.Vb 1
\& openssl pkeyutl \-derive \-inkey key.pem \-peerkey pubkey.pem \-out secret
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIgenpkey\fR\|(1), \fIpkey\fR\|(1), \fIrsautl\fR\|(1)
\&\fIdgst\fR\|(1), \fIrsa\fR\|(1), \fIgenrsa\fR\|(1)
