.TH "ZSHCONTRIB" "1" "October 7, 2014" "zsh 5\&.0\&.7"
.SH "NAME"
zshcontrib \- user contributions ta zsh
.\" Yodl file: Zsh/contrib.yo
.SH "DESCRIPTION"
.PP
Da Zsh source distribution includes a fuckin shitload of shit contributed by the
user hood\&.  These is not inherently a part of tha shell, n' some
may not be available up in every last muthafuckin zsh installation\&.  Da most dope of
these is documented here\&.  For documentation on other contributed items
like fuckin shell functions, look fo' comments up in tha function source files\&.
.PP
.PP
.SH "UTILITIES"
.PP
.SS "Accessin On\-Line Help"
.PP
Da key sequence \fBESC h\fP is normally bound by ZLE ta execute the
\fBrun\-help\fP widget (see
\fIzshzle\fP(1))\&.  This invokes tha \fBrun\-help\fP command wit tha command word from the
current input line as its argument\&.  By default, \fBrun\-help\fP be a alias
for tha \fBman\fP command, so dis often fails when tha command word be a
shell builtin or a user\-defined function\&.  By redefinin tha \fBrun\-help\fP
alias, one can improve tha on\-line help provided by tha shell\&.
.PP
Da \fBhelpfiles\fP utility, found up in tha \fBUtil\fP directory of the
distribution, be a Perl program dat can be used ta process tha zsh manual
to produce a separate help file fo' each shell builtin n' fo' nuff other
shell features as well\&.  Da autoloadable \fBrun\-help\fP function, found in
\fBFunctions/Misc\fP, searches fo' these helpfilez n' performs several
other tests ta produce da most thugged-out complete help possible fo' tha command\&.
.PP
Help filez is installed by default ta a subdirectory of \fB/usr/share/zsh\fP
or \fB/usr/local/share/zsh\fP\&.
.PP
To create yo' own help filez wit \fBhelpfiles\fP, chizzle or create a
directory where tha individual command help filez will reside\&.  For
example, you might chizzle \fB~/zsh_help\fP\&.  If you unpacked tha zsh
distribution up in yo' home directory, you would use tha commands:
.PP
.RS
.nf
\fBmkdir ~/zsh_help
perl ~/zsh\-5\&.0\&.7/Util/helpfilez ~/zsh_help\fP
.fi
.RE
.PP
Da \fBHELPDIR\fP parameta  drops some lyrics ta \fBrun\-help\fP where ta look fo' tha help
files\&. When unset, it uses tha default installation path\&.
To use yo' own set of help files, set dis ta tha appropriate path
in one of yo' startup files:
.PP
.RS
.nf
\fBHELPDIR=~/zsh_help\fP
.fi
.RE
.PP
To use tha \fBrun\-help\fP function, you need ta add lines something
like tha followin ta yo' \fB\&.zshrc\fP or equivalent startup file:
.PP
.RS
.nf
\fBunalias run\-help
autoload run\-help\fP
.fi
.RE
.PP
Note dat up in order fo' `\fBautoload run\-help\fP\&' ta work, tha \fBrun\-help\fP
file must be up in one of tha directories named up in yo' \fBfpath\fP array (see
\fIzshparam\fP(1))\&.  This should already be tha case if you gotz a standard zsh
installation; if it is not, copy \fBFunctions/Misc/run\-help\fP ta an
appropriate directory\&.
.PP
.SS "Recompilin Functions"
.PP
If you frequently edit yo' zsh functions, or periodically update yo' zsh
installation ta track tha sickest fuckin pimpments, you may find dat function
digests compiled wit tha \fBzcompile\fP builtin is frequently outta date
with respect ta tha function source files\&.  This aint probably a problem,
because zsh always looks fo' tha newest file when loadin a gangbangin' function yo, but
it may cause slower shell startup n' function loading\&.  Also, if a gangbangin' finger-lickin' digest
file is explicitly used as a element of \fBfpath\fP, zsh won\&'t check whether
any of its source filez has chizzled\&.
.PP
Da \fBzrecompile\fP autoloadable function, found up in \fBFunctions/Misc\fP, can
be used ta keep function digests up ta date\&.
.PP
.PD 0
.TP
.PD 0
\fBzrecompile\fP [ \fB\-qt\fP ] [ \fIname\fP \&.\&.\&. ]
.TP
.PD
\fBzrecompile\fP [ \fB\-qt\fP ] \fB\-p\fP \fIargs\fP [ \fB\-\fP\fB\-\fP \fIargs\fP \&.\&.\&. ]
This tries ta find \fB*\&.zwc\fP filez n' automatically re\-compile dem if at
least one of tha original gangsta filez is newer than tha compiled file\&.  This
works only if tha names stored up in tha compiled filez is full paths or are
relatizzle ta tha directory dat gotz nuff tha \fB\&.zwc\fP file\&.
.RS
.PP
In tha straight-up original gangsta form, each \fIname\fP is tha name of a cold-ass lil compiled file or a
directory containin \fB*\&.zwc\fP filez dat should be checked\&.  If no
arguments is given, tha directories n' \fB*\&.zwc\fP filez up in \fBfpath\fP are
used\&.
.PP
When \fB\-t\fP is given, no compilation is performed yo, but a return status of
zero (true) is set if there be filez dat need ta be re\-compiled and
non\-zero (false) otherwise\&.  Da \fB\-q\fP option on tha fuckin' down-lows tha chatty output
that raps bout what tha fuck \fBzrecompile\fP is bustin\&.
.PP
Without tha \fB\-t\fP option, tha return status is zero if all filez that
needed re\-compilation could be compiled n' non\-zero if compilation fo' at
least one of tha filez failed\&.
.PP
If tha \fB\-p\fP option is given, tha \fIargs\fP is interpreted as one
or mo' setz of arguments fo' \fBzcompile\fP, separated by `\fB\-\fP\fB\-\fP\&'\&.
For example:
.PP
.RS
.nf
\fBzrecompile \-p \e 
           \-R ~/\&.zshrc \-\- \e 
           \-M ~/\&.zcompdump \-\- \e 
           ~/zsh/comp\&.zwc ~/zsh/Completion/*/_*\fP
.fi
.RE
.PP
This compilez \fB~/\&.zshrc\fP tha fuck into \fB~/\&.zshrc\&.zwc\fP if dat don\&'t exist or
if it is olda than \fB~/\&.zshrc\fP\&. Da compiled file is ghon be marked for
readin instead of mapping\&. Da same is done fo' \fB~/\&.zcompdump\fP and
\fB~/\&.zcompdump\&.zwc\fP yo, but dis compiled file is marked fo' mapping\&. The
last line re\-creates tha file \fB~/zsh/comp\&.zwc\fP if any of tha files
matchin tha given pattern is newer than it\&.
.PP
Without tha \fB\-p\fP option, \fBzrecompile\fP do not create function digests
that do not already exist, nor do it add freshly smoked up functions ta tha digest\&.
.RE
.PP
Da followin shell loop be a example of a method fo' bustin function
digests fo' all functions up in yo' \fBfpath\fP, assumin dat you have write
permission ta tha directories:
.PP
.RS
.nf
\fBfor ((i=1; i <= $#fpath; ++i)); do
  dir=$fpath[i]
  zwc=${dir:t}\&.zwc
  if [[ $dir == (\&.|\&.\&.) || $dir == (\&.|\&.\&.)/* ]]; then
    continue
  fi
  files=($dir/*(N\-\&.))
  if [[ \-w $dir:h && \-n $filez ]]; then
    files=(${${(M)files%/*/*}#/})
    if ( cd $dir:h &&
         zrecompile \-p \-U \-z $zwc $filez ); then
      fpath[i]=$fpath[i]\&.zwc
    fi
  fi
done\fP
.fi
.RE
.PP
Da \fB\-U\fP n' \fB\-z\fP options is appropriate fo' functions up in tha default
zsh installation \fBfpath\fP; you may need ta use different options fo' your
personal function directories\&.
.PP
Once tha digests done been pimped n' yo' \fBfpath\fP modified ta refer to
them, you can keep dem up ta date by hustlin \fBzrecompile\fP wit no
arguments\&.
.PP
.SS "Keyboard Definition"
.PP
Da big-ass number of possible combinationz of keyboards, workstations,
terminals, emulators, n' window systems make it impossible fo' zsh to
have built\-in key bindings fo' every last muthafuckin thang\&.  Da \fBzkbd\fP utility,
found up in Functions/Misc, can help you quickly create key bindings fo' your
configuration\&.
.PP
Run \fBzkbd\fP either as a autoloaded function, or as a gangbangin' finger-lickin' dirty-ass shell script:
.PP
.RS
.nf
\fBzsh \-f ~/zsh\-5\&.0\&.7/Functions/Misc/zkbd\fP
.fi
.RE
.PP
When you run \fBzkbd\fP, it first asks you ta enta yo' terminal type; if
the default it offers is erect, just press return\&.  It then asks you to
press a fuckin shitload of different keys ta determine characteristics of your
keyboard n' terminal; \fBzkbd\fP warns you if it findz anythang outta the
ordinary, like fuckin a Delete key dat sendz neither \fB^H\fP nor \fB^?\fP\&.
.PP
Da keystrokes read by \fBzkbd\fP is recorded as a thugged-out definizzle fo' an
associatizzle array named \fBkey\fP, freestyled ta a gangbangin' file up in tha subdirectory
\fB\&.zkbd\fP within either yo' \fBHOME\fP or \fBZDOTDIR\fP directory\&.  Da name
of tha file is composed from tha \fBTERM\fP, \fBVENDOR\fP n' \fBOSTYPE\fP
parameters, joined by hyphens\&.
.PP
Yo ass may read dis file tha fuck into yo' \fB\&.zshrc\fP or another startup file with
the `\fBsource\fP\&' or `\fB\&.\fP' commands, then reference tha \fBkey\fP parameter
in bindkey commands, like this:
.PP
.RS
.nf
\fBsource ${ZDOTDIR:\-$HOME}/\&.zkbd/$TERM\-$VENDOR\-$OSTYPE
[[ \-n ${key[Left]} ]] && bindkey "${key[Left]}" backward\-char
[[ \-n ${key[Right]} ]] && bindkey "${key[Right]}" forward\-char
# etc\&.\fP
.fi
.RE
.PP
Note dat up in order fo' `\fBautoload zkbd\fP\&' ta work, tha \fBzkdb\fP file must
be up in one of tha directories named up in yo' \fBfpath\fP array (see
\fIzshparam\fP(1))\&.  This should already be tha case if you gotz a standard zsh
installation; if it is not, copy \fBFunctions/Misc/zkbd\fP ta an
appropriate directory\&.
.PP
.SS "Dumpin Shell State"
.PP
Occasionally you may encounta what tha fuck appears ta be a funky-ass bug up in tha shell,
particularly if yo ass is rockin a funky-ass beta version of zsh or a thugged-out pimpment
release\&.  Usually it is sufficient ta bust a thugged-out description of the
problem ta one of tha zsh mailin lists (see
\fIzsh\fP(1)) yo, but sometimes one of tha zsh pimpers will need ta recreate your
environment up in order ta track tha problem down\&.
.PP
Da script named \fBreporter\fP, found up in tha \fBUtil\fP directory of the
distribution, is provided fo' dis purpose\&.  (It be also possible to
\fBautoload hustla\fP yo, but \fBreporter\fP aint installed up in \fBfpath\fP
by default\&.)  This script outputs a thugged-out detailed dump of tha shell state,
in tha form of another script dat can be read wit `\fBzsh \-f\fP\&' to
recreate dat state\&.
.PP
To use \fBreporter\fP, read tha script tha fuck into yo' shell wit tha `\fB\&.\fP\&'
command n' redirect tha output tha fuck into a gangbangin' file:
.PP
.RS
.nf
\fB\&. ~/zsh\-5\&.0\&.7/Util/reporta > zsh\&.report\fP
.fi
.RE
.PP
Yo ass should check tha \fBzsh\&.report\fP file fo' any sensitizzle shiznit
like fuckin passwordz n' delete dem by hand before bustin  tha script ta the
developers\&.  Also, as tha output can be voluminous, it\&z dopest ta wait for
the pimpers ta ask fo' dis shiznit before bustin  it\&.
.PP
Yo ass can also use \fBreporter\fP ta dump only a subset of tha shell state\&.
This is sometimes useful fo' bustin startup filez fo' tha last time\&.
Most of tha output from reporta is far mo' detailed than probably is
necessary fo' a startup file yo, but tha \fBaliases\fP, \fBoptions\fP, and
\fBzstyles\fP states may be useful cuz they include only chizzlez from
the defaults\&.  Da \fBbindings\fP state may be useful if you have pimped
any of yo' own keymaps, cuz \fBreporter\fP arranges ta dump tha keymap
creation commandz as well as tha bindings fo' every last muthafuckin keymap\&.
.PP
As is usual wit automated tools, if you create a startup file with
\fBreporter\fP, you should edit tha thangs up in dis biatch ta remove unnecessary commands\&.
Note dat if you\&'re rockin tha freshly smoked up completion system, you should \fInot\fP
dump tha \fBfunctions\fP state ta yo' startup filez wit \fBreporter\fP; use
the \fBcompdump\fP function instead (see
\fIzshcompsys\fP(1))\&.
.PP
.PD 0
.TP
.PD
\fBreporter\fP [ \fIstate\fP \&.\&.\&. ]
Print ta standard output tha indicated subset of tha current shell state\&.
Da \fIstate\fP arguments may be one or mo' of:
.RS
.PP
.PD 0
.TP
\fBall\fP
Output every last muthafuckin thang listed below\&.
.TP
\fBaliases\fP
Output alias definitions\&.
.TP
\fBbindings\fP
Output ZLE key maps n' bindings\&.
.TP
\fBcompletion\fP
Output old\-style \fBcompctl\fP commands\&.
New completion is covered by \fBfunctions\fP n' \fBzstyles\fP\&.
.TP
\fBfunctions\fP
Output autoloadz n' function definitions\&.
.TP
\fBlimits\fP
Output \fBlimit\fP commands\&.
.TP
\fBoptions\fP
Output \fBsetopt\fP commands\&.
.TP
\fBstyles\fP
Same as \fBzstyles\fP\&.
.TP
\fBvariables\fP
Output shell parameta assignments, plus \fBexport\fP
commandz fo' any environment variables\&.
.TP
\fBzstyles\fP
Output \fBzstyle\fP commands\&.
.PD
.PP
If tha \fIstate\fP is omitted, \fBall\fP be assumed\&.
.RE
.PP
With tha exception of `\fBall\fP\&', every last muthafuckin \fIstate\fP can be abbreviated by
any prefix, even a single letter; thus \fBa\fP is tha same ol' dirty as \fBaliases\fP,
\fBz\fP is tha same ol' dirty as \fBzstyles\fP, etc\&.
.PP
.SS "Manipulatin Hook Functions"
.PP
.PD 0
.TP
.PD
\fBadd\-zsh\-hook\fP [\-dD] \fIhook\fP \fIfunction\fP
Several functions is special ta tha shell, as busted lyrics bout up in tha section
SPECIAL FUNCTIONS, peep \fIzshmisc\fP(1),
in dat they is automatic called at a specific point durin shell execution\&.
Each has a associated array consistin of namez of functions ta be
called all up in tha same point; these is so\-called `hook functions\&'\&.
Da shell function \fBadd\-zsh\-hook\fP serves up a simple way of addin or
removin functions from tha array\&.
.RS
.PP
\fIhook\fP is one of \fBchpwd\fP, \fBperiodic\fP, \fBprecmd\fP, \fBpreexec\fP,
\fBzshaddhistory\fP, \fBzshexit\fP, or \fBzsh_directory_name\fP,
the special functions up in question\&.  Note dat \fBzsh_directory_name\fP
is called up in a gangbangin' finger-lickin' different way from tha other functions yo, but may
still be manipulated as a hook\&.
.PP
\fIfunction\fP is name of a ordinary shell function\&.  If no options
are given dis is ghon be added ta tha array of functions ta be executed
in tha given context\&.
.PP
If tha option \fB\-d\fP is given, tha \fIfunction\fP is removed from
the array of functions ta be executed\&.
.PP
If tha option \fB\-D\fP is given, tha \fIfunction\fP is treated as a pattern
and any matchin namez of functions is removed from tha array of
functions ta be executed\&.
.PP
Da options \fB\-U\fP, \fB\-z\fP n' \fB\-k\fP is passed as arguments to
\fBautoload\fP fo' \fIfunction\fP\&.  For functions contributed wit zsh, the
options \fB\-Uz\fP is appropriate\&.
.RE
.PP
.SH "REMEMBERING RECENT DIRECTORIES"
.PP
Da function \fBcdr\fP allows you ta chizzle tha hustlin directory ta a
previous hustlin directory from a list maintained automatically\&.  It is
similar up in concept ta tha directory stack controlled by tha \fBpushd\fP,
\fBpopd\fP n' \fBdirs\fP builtins yo, but is mo' configurable, n' as it stores
all entries up in filez it is maintained across sessions n' (by default)
between terminal emulators up in tha current session\&.  (Da \fBpushd\fP
directory stack aint straight-up modified or used by \fBcdr\fP unless you
configure it ta do so as busted lyrics bout up in tha configuration section below\&.)
.PP
.SS "Installation"
.PP
Da system works by meanz of a hook function dat is called every last muthafuckin time the
directory chizzles\&.  To install tha system, autoload tha required functions
and use tha \fBadd\-zsh\-hook\fP function busted lyrics bout above:
.PP
.RS
.nf
\fBautoload \-Uz chpwd_recent_dirs cdr add\-zsh\-hook
add\-zsh\-hook chpwd chpwd_recent_dirs\fP
.fi
.RE
.PP
Now every last muthafuckin time you chizzle directly interactively, no matta which
command you use, tha directory ta which you chizzle is ghon be remembered
in most\-recent\-first order\&.
.PP
.SS "Use"
.PP
All direct user interaction is via tha \fBcdr\fP function\&.
.PP
Da argument ta cdr be a number \fIN\fP correspondin ta tha \fIN\fPth most
recently chizzled\-to directory\&.  1 is tha immediately precedin directory;
the current directory is remembered but aint offered as a thugged-out destination\&.
Note dat if you have multiple windows open 1 may refer ta a gangbangin' finger-lickin' directory
changed ta up in another window; you can avoid dis by havin per\-terminal
filez fo' storin directory as busted lyrics bout fo' the
\fBrecent\-dirs\-file\fP steez below\&.
.PP
If you set tha \fBrecent\-dirs\-default\fP steez busted lyrics bout below \fBcdr\fP
will behave tha same as \fBcd\fP if given a non\-numeric argument, or more
than one argument\&.  Da recent directory list is updated just tha same
however you chizzle directory\&.
.PP
If tha argument is omitted, 1 be assumed\&.  This is similar ta \fBpushd\fP\&'s
behaviour of swappin tha two most recent directories on tha stack\&.
.PP
Completion fo' tha argument ta \fBcdr\fP be available if compinit has been
run; menu selection is recommended, using:
.PP
.RS
.nf
\fBzstyle \&':completion:*:*:cdr:*:*' menu selection\fP
.fi
.RE
.PP
to allow you ta cycle all up in recent directories; tha order is preserved,
so tha straight-up original gangsta chizzle is da most thugged-out recent directory before tha current one\&.
Da verbose steez be also recommended ta ensure tha directory is shown; this
style is on by default so no action is required unless you have chizzled it\&.
.PP
.SS "Options"
.PP
Da behaviour of \fBcdr\fP may be modified by tha followin options\&.
.PP
.PD 0
.TP
.PD
\fB\-l\fP
lists tha numbers n' tha correspondin directories in
abbreviated form (i\&.e\&. wit \fB~\fP substitution reapplied), one per line\&.
Da directories here is not quoted (this would only be a issue if a
directory name contained a newline)\&.  This is used by tha completion
system\&.
.TP
\fB\-r\fP
sets tha variable \fBreply\fP ta tha current set of directories\&.  Nothing
is printed n' tha directory aint chizzled\&.
.TP
\fB\-e\fP
allows you ta edit tha list of directories, one per line\&.  The
list can be edited ta any extent you like; no sanitizzle checkin is
performed\&.  Completion be available\&.  No quotin is necessary (except for
newlines, where I have up in any case no sympathy); directories is in
unabbreviated from n' contain a absolute path, i\&.e\&. they start wit \fB/\fP\&.
Usually tha straight-up original gangsta entry should be left as tha current directory\&.
.PP
.SS "Configuration"
.PP
Configuration is by meanz of tha stylez mechanizzle dat should be familiar
from completion; if not, peep tha description of tha \fBzstyle\fP command in
see \fIzshmodules\fP(1)\&.  Da context fo' settin styles
should be \fB\&':chpwd:*'\fP up in case tha meanin of tha context is extended in
future, fo' example:
.PP
.RS
.nf
\fBzstyle \&':chpwd:*' recent\-dirs\-max 0\fP
.fi
.RE
.PP
sets tha value of tha \fBrecent\-dirs\-max\fP steez ta 0\&.  In practice the
style name is specific enough dat a cold-ass lil context of \&'*' should be fine\&.
.PP
An exception is \fBrecent\-dirs\-insert\fP, which is used exclusively by the
completion system n' so has tha usual completion system context
(\fB\&':completion:*'\fP if not a god damn thang mo' specific is needed), though again
\fB\&'*'\fP should be fine up in practice\&.
.PP
.PD 0
.TP
.PD
\fBrecent\-dirs\-default\fP
If true, n' tha command is expectin a recent directory index, and
either there is mo' than one argument or tha argument aint an
integer, then fall all up in ta "cd"\&.  This allows tha lazy ta use only
one command fo' directory changing\&.  Completion recognises this, too;
see recent\-dirs\-insert fo' how tha fuck ta control completion when dis option
is up in use\&.
.TP
\fBrecent\-dirs\-file\fP
Da file where tha list of directories is saved\&.  Da default
is \fB${ZDOTDIR:\-$HOME}/\&.chpwd\-recent\-dirs\fP, i\&.e\&. dis is up in your
home directory unless you have set tha variable \fBZDOTDIR\fP ta point
somewhere else\&.  Directory names is saved up in \fB$\&'\fP\fI\&.\&.\&.\fP\fB'\fP quoted
form, so each line up in tha file can be supplied directly ta tha shell as an
argument\&.
.RS
.PP
Da value of dis steez may be a array\&.  In dis case, tha first
file up in tha list will always be used fo' savin directories while any
other filez is left untouched\&.  When readin tha recent directory
list, if there be fewer than tha maximum number of entries up in the
first file, tha contentz of lata filez up in tha array is ghon be appended
with duplicates removed from tha list shown\&.  Da contentz of tha two
filez is not sorted together, i\&.e\&. all tha entries up in tha straight-up original gangsta file
are shown first\&.  Da special value \fB+\fP can step tha fuck up in tha list to
indicate tha default file should be read at dat point\&.  This allows
effects like tha following:
.PP
.RS
.nf
\fBzstyle \&':chpwd:*' recent\-dirs\-file \e 
~/\&.chpwd\-recent\-dirs\-${TTY##*/} +\fP
.fi
.RE
.PP
Recent directories is read from a gangbangin' file numbered accordin to
the terminal\&.  If there be insufficient entries tha list
is supplemented from tha default file\&.
.PP
It be possible ta use \fBzstyle \-e\fP ta make tha directory configurable
at run time:
.PP
.RS
.nf
\fBzstyle \-e \&':chpwd:*' recent\-dirs\-file pick\-recent\-dirs\-file
pick\-recent\-dirs\-file() {
  if [[ $PWD = ~/text/writing(|/*) ]]; then
    reply=(~/\&.chpwd\-recent\-dirs\-writing)
  else
    reply=(+)
  fi
}\fP
.fi
.RE
.PP
In dis example, if tha current directory is \fB~/text/writing\fP or a
directory under it, then bust a special file fo' savin recent
directories, else use tha default\&.
.RE
.TP
\fBrecent\-dirs\-insert\fP
Used by completion\&.  If \fBrecent\-dirs\-default\fP is true, then setting
this ta \fBtrue\fP causes tha actual directory, rather than its index, to
be banged on tha command line; dis has tha same ol' dirty effect as using
the correspondin index yo, but make tha history clearer n' tha line
easier ta edit\&.  With dis setting, if part of a argument was
already typed, aiiight directory completion rather than recent
directory completion is done; dis is cuz recent directory
completion is sposed ta fuckin be done by cyclin all up in entries menu
fashion\&.
.RS
.PP
If tha value of tha steez is \fBalways\fP, then only recent directories will
be completed; up in dat case, use tha \fBcd\fP command when you want to
complete other directories\&.
.PP
If tha value is \fBfallback\fP, recent directories is ghon be tried first, then
normal directory completion is performed if recent directory completion
failed ta find a match\&.
.PP
Finally, if tha value is \fBboth\fP then both setz of completions are
presented; tha usual tag mechanizzle can be used ta distinguish thangs up in dis biatch, with
recent directories tagged as \fBrecent\-dirs\fP\&.  Note dat tha recent
directories banged is abbreviated wit directory names where appropriate\&.
.RE
.TP
\fBrecent\-dirs\-max\fP
Da maximum number of directories ta save ta tha file\&.  If
this is zero or wack there is no maximum\&.  Da default is 20\&.
Note dis includes tha current directory, which isn\&'t offered,
so tha highest number of directories yo big-ass booty is ghon be offered
is one less than tha maximum\&.
.TP
\fBrecent\-dirs\-prune\fP
This steez be a array determinin what tha fuck directories should (or should
not) be added ta tha recent list\&.  Elementz of tha array can include:
.RS
.PP
.PD 0
.TP
.PD
\fBparent\fP
Prune muthafathas (more accurately, ancestors) from tha recent list\&.
If present, changin directly down by any number of directories
causes tha current directory ta be overwritten\&.  For example,
changin from ~pws ta ~pws/some/other/dir causes ~pws not ta be
left on tha recent directory stack\&.  This only applies ta direct
changes ta descendant directories; earlier directories on the
list is not pruned\&.  For example, changin from ~pws/yet/another
to ~pws/some/other/dir do not cause ~pws ta be pruned\&.
.TP
\fBpattern:\fIpattern\fP\fP
Gives a zsh pattern fo' directories dat should not be
added ta tha recent list (if not already there)\&.  This element
can be repeated ta add different patterns\&.  For example,
\fB\&'pattern:/tmp(|/*)'\fP stops \fB/tmp\fP or its descendants
from bein added\&.  Da \fBEXTENDED_GLOB\fP option be always turned on
for these patterns\&.
.RE
.TP
\fBrecent\-dirs\-pushd\fP
If set ta true, \fBcdr\fP will use \fBpushd\fP instead of \fBcd\fP ta chizzle the
directory, so tha directory is saved on tha directory stack\&.  As the
directory stack is straight-up separate from tha list of filez saved
by tha mechanizzle used up in dis file there is no obvious reason ta do
this\&.
.PP
.SS "Use wit dynamic directory naming"
.PP
It be possible ta refer ta recent directories rockin tha dynamic directory
name syntax by rockin tha supplied function \fBzsh_directory_name_cdr\fP
a hook:
.PP
.RS
.nf
\fBautoload \-Uz add\-zsh\-hook
add\-zsh\-hook \-Uz zsh_directory_name zsh_directory_name_cdr\fP
.fi
.RE
.PP
When dis is done, \fB~[1]\fP will refer ta da most thugged-out recent
directory other than $PWD, n' so on\&.  Completion afta \fB~[\fP\fI\&.\&.\&.\fP
also works\&.
.PP
.SS "Detailz of directory handling"
.PP
This section is fo' tha curious or confused; most playas will not
need ta know dis shiznit\&.
.PP
Recent directories is saved ta a gangbangin' file immediately n' hence are
preserved across sessions\&.  Note currently no file lockin be applied:
the list is updated immediately on interactizzle commandz n' nowhere else
(unlike history), n' it be assumed yo ass is only goin ta chizzle
directory up in one window at once\&.  This aint safe on shared accounts,
but up in any case tha system has limited utilitizzle when one of mah thugs is
changin ta a gangbangin' finger-lickin' different set of directories behind yo' back\&.
.PP
To make dis a lil safer, only directory chizzlez instituted from the
command line, either directly or indirectly all up in shell function calls
(but not all up in subshells, evals, traps, completion functions n' the
like) is saved\&.  Shell functions should use \fBcd \-q\fP or \fBpushd \-q\fP to
avoid side effects if tha chizzle ta tha directory is ta be invisible at the
command line\&.  See tha contentz of tha function \fBchpwd_recent_dirs\fP for
more details\&.
.PP
.SH "GATHERING INFORMATION FROM VERSION CONTROL SYSTEMS"
.PP
In a shitload of cases, it is sick ta automatically retrieve shiznit from
version control systems (VCSs), like fuckin subversion, CVS or git, ta be able
to provide it ta tha user; possibly up in tha user\&z prompt\&. Right back up in yo muthafuckin ass. So dat you can
instantly tell which branch yo ass is currently on, fo' example\&.
.PP
In order ta do that, you may use tha \fBvcs_info\fP function\&.
.PP
Da followin VCSs is supported, showin tha abbreviated name by which
they is referred ta within tha system:
.PD 0
.TP
Bazaar (\fBbzr\fP)
http://bazaar\-vcs\&.org/
.TP
Codeville (\fBcdv\fP)
http://codeville\&.org/
.TP
Concurrent Versionin System (\fBcvs\fP)
http://www\&.nongnu\&.org/cvs/
.TP
Darcs (\fBdarcs\fP)
http://darcs\&.net/
.TP
Fossil (\fBfossil\fP)
http://fossil\-scm\&.org/
.TP
Git (\fBgit\fP)
http://git\-scm\&.com/
.TP
GNU arch (\fBtla\fP)
http://www\&.gnu\&.org/software/gnu\-arch/
.TP
Mercurial (\fBhg\fP)
http://mercurial\&.selenic\&.com/
.TP
Monotone (\fBmtn\fP)
http://monotone\&.ca/
.TP
Perforce (\fBp4\fP)
http://www\&.perforce\&.com/
.TP
Subversion (\fBsvn\fP)
http://subversion\&.tigris\&.org/
.TP
SVK (\fBsvk\fP)
http://svk\&.bestpractical\&.com/
.PD
.PP
There be also support fo' tha patch pimpment system \fBquilt\fP
(http://savannah\&.nongnu\&.org/projects/quilt)\&. Right back up in yo muthafuckin ass. See \fBQuilt Support\fP
below fo' details\&.
.PP
To load \fBvcs_info\fP:
.PP
.RS
.nf
\fBautoload \-Uz vcs_info\fP
.fi
.RE
.PP
It can be used up in any existin prompt, cuz it do not require any
specific \fB$psvar\fP entries ta be available\&.
.PP
.SS "Quickstart"
.PP
To git dis feature hustlin quickly (includin colors), you can do the
followin (assuming, you loaded \fBvcs_info\fP properly \- peep above):
.PP
.RS
.nf
\fBzstyle \&':vcs_info:*' actionformats \e 
    \&'%F{5}(%f%s%F{5})%F{3}\-%F{5}[%F{2}%b%F{3}|%F{1}%a%F{5}]%f '
zstyle \&':vcs_info:*' formats       \e 
    \&'%F{5}(%f%s%F{5})%F{3}\-%F{5}[%F{2}%b%F{5}]%f '
zstyle \&':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{3}%r'
precmd () { vcs_info }
PS1=\&'%F{5}[%F{2}%n%F{5}] %F{3}%3~ ${vcs_info_msg_0_}%f%# '\fP
.fi
.RE
.PP
Obviously, tha last two lines is there fo' demonstration\&. Yo ass need to
call \fBvcs_info\fP from yo' \fBprecmd\fP function\&. Once dat is done you need
a \fBsingle quoted\fP \fB\&'${vcs_info_msg_0_}'\fP up in yo' prompt\&.
.PP
To be able ta use \fB\&'${vcs_info_msg_0_}'\fP directly up in yo' prompt like
this, yo big-ass booty is ghon need ta have tha \fBPROMPT_SUBST\fP option enabled\&.
.PP
Now call tha \fBvcs_info_printsys\fP utilitizzle from tha command line:
.PP
.RS
.nf
\fB% vcs_info_printsys
## list of supported version control backends:
## disabled systems is prefixed by a hash sign (#)
bzr
cdv
cvs
darcs
fossil
git
hg
mtn
p4
svk
svn
tla
## flavours (cannot be used up in tha enable or disable styles; they
## is enabled n' disabled wit they masta [git\-svn \-> git])
## they *can* be used up in contexts: \&':vcs_info:git\-svn:*'\&.
git\-p4
git\-svn
hg\-git
hg\-hgsubversion
hg\-hgsvn\fP
.fi
.RE
.PP
Yo ass may not want all of these cuz there is no point up in hustlin the
code ta detect systems you do not use\&.  So there be a way ta disable
some backendz altogether:
.PP
.RS
.nf
\fBzstyle \&':vcs_info:*' disable bzr cdv darcs mtn svk tla\fP
.fi
.RE
.PP
Yo ass may also pick all dem from dat list n' enable only them:
.PP
.RS
.nf
\fBzstyle \&':vcs_info:*' enable git cvs svn\fP
.fi
.RE
.PP
If you rerun \fBvcs_info_printsys\fP afta one of these commands, you will
see tha backendz listed up in tha \fBdisable\fP steez (or backendz not up in the
\fBenable\fP steez \- if you used that) marked as disabled by a hash sign\&.
That means tha detection of these systems is skipped \fIcompletely\fP\&. No
wasted time there\&.
.PP
.SS "Configuration"
.PP
Da \fBvcs_info\fP feature can be configured via \fBzstyle\fP\&.
.PP
First, tha context up in which we is working:
.RS
.nf
\fB:vcs_info:\fIvcs\-string\fP:\fIuser\-context\fP:\fIrepo\-root\-name\fP\fP
.fi
.RE
.PP
.PD 0
.TP
.PD
\fIvcs\-string\fP
is one of: \fBgit\fP, \fBgit\-svn\fP, \fBgit\-p4\fP, \fBhg\fP, \fBhg\-git\fP,
\fBhg\-hgsubversion\fP, \fBhg\-hgsvn\fP, \fBdarcs\fP, \fBbzr\fP, \fBcdv\fP, \fBmtn\fP,
\fBsvn\fP, \fBcvs\fP, \fBsvk\fP, \fBtla\fP, \fBp4\fP or \fBfossil\fP\&. When hooks are
actizzle tha hooks name be added afta a `+\&'\&. (See \fBHooks up in vcs_info\fP
below\&.)
.TP
\fIuser\-context\fP
is a gangbangin' freely configurable string, assignable by
the user as tha straight-up original gangsta argument ta \fBvcs_info\fP (see its description
below)\&.
.TP
\fIrepo\-root\-name\fP
is tha name of a repository up in which you want a
style ta match\&. Right back up in yo muthafuckin ass. So, if you want a settin specific ta \fB/usr/src/zsh\fP,
with dat bein a CVS checkout, you can set \fIrepo\-root\-name\fP to
\fBzsh\fP ta make it so\&.
.PP
There is three special joints fo' \fIvcs\-string\fP: Da first is named
\fB\-init\-\fP, dat is up in effect as long as there was no decision what tha fuck VCS
backend ta use\&. Da second is \fB\-preinit\-\fP; it is used \fIbefore\fP
\fBvcs_info\fP is run, when initializin tha data exportin variables\&. The
third special value is \fBformats\fP n' is used by tha \fBvcs_info_lastmsg\fP
for lookin up its styles\&.
.PP
Da initial value of \fIrepo\-root\-name\fP is \fB\-all\-\fP n' it is replaced
with tha actual name, as soon as it is known\&. Only use dis part of the
context fo' definin tha \fBformats\fP, \fBactionformats\fP or
\fBbranchformat\fP styles, as it is guaranteed dat \fIrepo\-root\-name\fP is
set up erectly fo' these only\&. For all other styles, just use \fB\&'*'\fP
instead\&.
.PP
There is two pre\-defined joints fo' \fIuser\-context\fP:
.PD 0
.TP
\fBdefault\fP
the one used if none is specified
.TP
\fBcommand\fP
used by vcs_info_lastmsg ta lookup its styles
.PD
.PP
Yo ass can of course use \fB\&':vcs_info:*'\fP ta match all VCSs up in all
user\-contexts at once\&.
.PP
This be a thugged-out description of all stylez dat is looked up\&.
.PP
.PD 0
.TP
.PD
\fBformats\fP
A list of formats, used when actionformats aint used
(which is most of tha time)\&.
.TP
\fBactionformats\fP
A list of formats, used if there be a special
action goin on up in yo' current repository; like a interactizzle rebase or
a merge conflict\&.
.TP
\fBbranchformat\fP
Some backendz replace \fB%b\fP up in tha formats and
actionformats stylez above, not only by a funky-ass branch name but also by a
revision number\&. This steez lets you modify how tha fuck dat strang should look\&.
.TP
\fBnvcsformats\fP
These "formats" is exported when our phat asses didn\&'t detect a version control system
for tha current directory or \fBvcs_info\fP was disabled\&. This is useful if
you want \fBvcs_info\fP ta straight-up take over tha generation of your
prompt\&. Yo ass would do suttin' like \fBPS1=\&'${vcs_info_msg_0_}'\fP to
accomplish that\&.
.TP
\fBhgrevformat\fP
\fBhg\fP uses both a hash n' a revision number ta reference a specific
changeset up in a repository\&. With dis steez you can format tha revision
strin (see \fBbranchformat\fP) ta include either or both\&. It\&z only
useful when \fBget\-revision\fP is true\&. Note, tha full 40\-characta revision id
is not available (except when rockin tha \fBuse\-simple\fP option) cuz
executin hg mo' than once per prompt is too slow; you may customize this
behavior rockin hooks\&.
.TP
\fBmax\-exports\fP
Defines tha maximum number of
\fBvcs_info_msg_*_\fP variablez \fBvcs_info\fP will export\&.
.TP
\fBenable\fP
A list of backendz you wanna use\&. Checked up in tha \fB\-init\-\fP context\&. If
this list gotz nuff a item called \fBNONE\fP no backend is used at all and
\fBvcs_info\fP will do nothing\&. If dis list gotz nuff \fBALL\fP, \fBvcs_info\fP
will use all known backends\&. Only wit \fBALL\fP up in \fBenable\fP will the
\fBdisable\fP steez have any effect\&. \fBALL\fP n' \fBNONE\fP is case insensitive\&.
.TP
\fBdisable\fP
A list of VCSs you don\&'t want \fBvcs_info\fP ta test for
repositories (checked up in tha \fB\-init\-\fP context, too)\&. Only used if
\fBenable\fP gotz nuff \fBALL\fP\&.
.TP
\fBdisable\-patterns\fP
A list of patterns dat is checked against \fB$PWD\fP\&. If a pattern
matches, \fBvcs_info\fP is ghon be disabled\&. This steez is checked up in the
\fB:vcs_info:\-init\-:*:\-all\-\fP context\&.
.RS
.PP
Say, \fB~/\&.zsh\fP be a gangbangin' finger-lickin' directory under version control, up in which you do
not want \fBvcs_info\fP ta be active, do:
.RS
.nf
\fBzstyle \&':vcs_info:*' disable\-patterns "$HOME/\&.zsh(|/*)"\fP
.fi
.RE
.RE
.TP
\fBuse\-quilt\fP
If enabled, tha \fBquilt\fP support code be actizzle up in `addon\&' mode\&.
See \fBQuilt Support\fP fo' details\&.
.TP
\fBquilt\-standalone\fP
If enabled, `standalone\&' mode detection be attempted if no VCS be active
in a given directory\&. Right back up in yo muthafuckin ass. See \fBQuilt Support\fP fo' details\&.
.TP
\fBquilt\-patch\-dir\fP
Overwrite tha value of tha \fB$QUILT_PATCHES\fP environment variable\&. Right back up in yo muthafuckin ass. See
\fBQuilt Support\fP fo' details\&.
.TP
\fBquiltcommand\fP
When \fBquilt\fP itself is called up in quilt support tha value of dis style
is used as tha command name\&.
.TP
\fBcheck\-for\-changes\fP
If enabled, dis steez causes tha \fB%c\fP n' \fB%u\fP format escapes ta show
when tha hustlin directory has uncommitted chizzles\&. Da strings displayed by
these escapes can be controlled via tha \fBstagedstr\fP n' \fBunstagedstr\fP
styles\&. Da only backendz dat currently support dis option is \fBgit\fP,
\fBhg\fP, n' \fBbzr\fP (the latta two only support unstaged)\&.
.RS
.PP
For dis steez ta be evaluated wit tha \fBhg\fP backend, tha \fBget\-revision\fP
style need ta be set n' tha \fBuse\-simple\fP steez need ta be unset\&. The
latta is tha default; tha forma is not\&.
.PP
With tha \fBbzr\fP backend, \fIlightweight checkouts\fP only honor dis steez if
the \fBuse\-server\fP steez is set\&.
.PP
Note, tha actions taken if dis steez is enabled is potentially expensive
(read: they may be slow, dependin on how tha fuck big-ass tha current repository is)\&.
Therefore, it is disabled by default\&.
.RE
.TP
\fBcheck\-for\-staged\-changes\fP
This steez is like \fBcheck\-for\-changes\fP yo, but it never checks tha worktree
files, only tha metadata up in tha \fB\&.${vcs}\fP dir\&.  Therefore,
this steez initializes only tha \fB%c\fP escape (with \fBstagedstr\fP) but
not tha \fB%u\fP escape\&.  This steez is fasta than \fBcheck\-for\-changes\fP\&.
.RS
.PP
In tha \fBgit\fP backend, dis steez checks fo' chizzlez up in tha index\&.
Other backendz do not currently implement dis style\&.
.PP
This steez is disabled by default\&.
.RE
.TP
\fBstagedstr\fP
This strang is ghon be used up in tha \fB%c\fP escape if there be staged chizzlez in
the repository\&.
.TP
\fBunstagedstr\fP
This strang is ghon be used up in tha \fB%u\fP escape if there be unstaged chizzles
in tha repository\&.
.TP
\fBcommand\fP
This steez causes \fBvcs_info\fP ta use tha supplied strang as tha command
to use as tha VCS\&z binary\&. Note, dat settin dis up in ':vcs_info:*' is
not a phat idea\&.
.RS
.PP
If tha value of dis steez is empty (which is tha default), tha used binary
name is tha name of tha backend up in use (e\&.g\&. \fBsvn\fP is used up in a \fBsvn\fP
repository)\&.
.PP
Da \fBrepo\-root\-name\fP part up in tha context be always tha default \fB\-all\-\fP
when dis steez is looked up\&.
.PP
For example, dis steez can be used ta use binaries from non\-default
installation directories\& fo' realz. Assume, \fBgit\fP is installed up in /usr/bin but
your sysadmin installed a newer version up in /usr/local/bin\&. Instead of
changin tha order of yo' \fB$PATH\fP parameter, you can do this:
.RS
.nf
\fBzstyle \&':vcs_info:git:*:\-all\-' command /usr/local/bin/git\fP
.fi
.RE
.RE
.TP
\fBuse\-server\fP
This is used by tha Perforce backend (\fBp4\fP) ta decizzle if it should
contact tha Perforce server ta smoke up if a gangbangin' finger-lickin' directory is managed
by Perforce\&.  This is tha only reliable way of bustin dis yo, but runs
the risk of a thugged-out delay if tha server name cannot be found\&.  If the
server (more specifically, tha \fBhost\fP\fB:\fP\fBport\fP pair describin the
server) cannot be contacted, its name is put tha fuck into tha associatizzle array
\fBvcs_info_p4_dead_servers\fP n' aint contacted again n' again n' again durin tha session
until it is removed by hand\&.  If you do not set dis style, tha \fBp4\fP
backend is only usable if you have set tha environment variable
\fBP4CONFIG\fP ta a gangbangin' file name n' have correspondin filez up in tha root
directoriez of each Perforce client\&.  See comments up in tha function
\fBVCS_INFO_detect_p4\fP fo' mo' detail\&.
.RS
.PP
Da Bazaar backend (\fBbzr\fP) uses dis ta permit contactin tha server
about lightweight checkouts, peep tha \fBcheck\-for\-changes\fP style\&.
.RE
.TP
\fBuse\-simple\fP
If there be two different wayz of gathering
information, you can select tha simpla one by settin dis steez ta true;
the default is ta use tha not\-that\-simple code, which is potentially a lot
slower but might be mo' accurate up in all possible cases\&. This steez is
used by tha \fBbzr\fP n' \fBhg\fP backends\&. In tha case of \fBhg\fP it will invoke
the external hexdump program ta parse tha binary dirstate cache file; this
method aint gonna return tha local revision number\&.
.TP
\fBget\-revision\fP
If set ta true, vcs_info goes tha extra mile ta figure up tha revision of
a repository\&z work tree (currently fo' tha \fBgit\fP n' \fBhg\fP backends,
where dis kind of shiznit aint always vital)\&. For \fBgit\fP, the
hash value of tha currently checked up commit be available via tha \fB%i\fP
expansion\&. With \fBhg\fP, tha local revision number n' tha corresponding
global hash is available via \fB%i\fP\&.
.TP
\fBget\-mq\fP
If set ta true, tha \fBhg\fP backend will look fo' a Mercurial Queue (\fBmq\fP)
patch directory\& yo. Hype is ghon be available via tha `\fB%m\fP\&' replacement\&.
.TP
\fBget\-bookmarks\fP
If set ta true, tha \fBhg\fP backend will try ta git a list of current
bookmarks\&. They is ghon be available via tha `\fB%m\fP\&' replacement\&.
.TP
\fBuse\-prompt\-escapes\fP
Determines if we assume dat tha assembled
strin from \fBvcs_info\fP includes prompt escapes\&. (Used by
\fBvcs_info_lastmsg\fP\&.)
.TP
\fBdebug\fP
Enable debuggin output ta track possible problems\&. Currently dis style
is only used by \fBvcs_info\fP\&z hooks system\&.
.TP
\fBhooks\fP
A list steez dat defines hook\-function names\&. Right back up in yo muthafuckin ass. See \fBHooks up in vcs_info\fP
below fo' details\&.
.PP
Da default joints fo' these stylez up in all contexts are:
.PP
.PD 0
.TP
\fBformats\fP
" (%s)\-[%b]%u%c\-"
.TP
\fBactionformats\fP
" (%s)\-[%b|%a]%u%c\-"
.TP
\fBbranchformat\fP
"%b:%r" (for bzr, svn, svk n' hg)
.TP
\fBnvcsformats\fP
""
.TP
\fBhgrevformat\fP
"%r:%h"
.TP
\fBmax\-exports\fP
2
.TP
\fBenable\fP
ALL
.TP
\fBdisable\fP
(empty list)
.TP
\fBdisable\-patterns\fP
(empty list)
.TP
\fBcheck\-for\-changes\fP
false
.TP
\fBcheck\-for\-staged\-changes\fP
false
.TP
\fBstagedstr\fP
(string: "S")
.TP
\fBunstagedstr\fP
(string: "U")
.TP
\fBcommand\fP
(empty string)
.TP
\fBuse\-server\fP
false
.TP
\fBuse\-simple\fP
false
.TP
\fBget\-revision\fP
false
.TP
\fBget\-mq\fP
true
.TP
\fBget\-bookmarks\fP
false
.TP
\fBuse\-prompt\-escapes\fP
true
.TP
\fBdebug\fP
false
.TP
\fBhooks\fP
(empty list)
.TP
\fBuse\-quilt\fP
false
.TP
\fBquilt\-standalone\fP
false
.TP
\fBquilt\-patch\-dir\fP
empty \- use \fB$QUILT_PATCHES\fP
.TP
\fBquiltcommand\fP
quilt
.PD
.PP
In aiiight \fBformats\fP n' \fBactionformats\fP tha followin replacements are
done:
.PP
.PD 0
.TP
\fB%s\fP
Da VCS up in use (git, hg, svn, etc\&.)\&.
.TP
\fB%b\fP
Hype bout tha current branch\&.
.TP
\fB%a\fP
An identifier dat raps bout tha action\&. Only make sense in
\fBactionformats\fP\&.
.TP
\fB%i\fP
Da current revision number or identifier\&. For \fBhg\fP
the \fBhgrevformat\fP steez may be used ta customize tha output\&.
.TP
\fB%c\fP
Da strang from tha \fBstagedstr\fP steez if there be staged
changes up in tha repository\&.
.TP
\fB%u\fP
Da strang from tha \fBunstagedstr\fP steez if there are
unstaged chizzlez up in tha repository\&.
.TP
\fB%R\fP
Da base directory of tha repository\&.
.TP
\fB%r\fP
Da repository name\&. If \fB%R\fP is \fB/foo/bar/repoXY\fP, \fB%r\fP
is \fBrepoXY\fP\&.
.TP
\fB%S\fP
A subdirectory within a repository\&. If \fB$PWD\fP is
\fB/foo/bar/repoXY/beer/tasty\fP, \fB%S\fP is \fBbeer/tasty\fP\&.
.TP
\fB%m\fP
A "misc" replacement\&. Well shiiiit, it be all up in tha discretion of tha backend to
decizzle what tha fuck dis replacement expandz to\&. Well shiiiit, it is currently used by tha \fBhg\fP
and \fBgit\fP backendz ta display patch shiznit from tha \fBmq\fP and
\fBstgit\fP extensions\&.
.PD
.PP
In \fBbranchformat\fP these replacements is done:
.PP
.PD 0
.TP
\fB%b\fP
Da branch name\&.
.TP
\fB%r\fP
Da current revision number or tha \fBhgrevformat\fP steez for
\fBhg\fP\&.
.PD
.PP
In \fBhgrevformat\fP these replacements is done:
.PP
.PD 0
.TP
\fB%r\fP
Da current local revision number\&.
.TP
\fB%h\fP
Da current global revision identifier\&.
.PD
.PP
In \fBpatch\-format\fP n' \fBnopatch\-format\fP these replacements is done:
.PP
.PD 0
.TP
\fB%p\fP
Da name of tha top\-most applied patch (\fBapplied\-string\fP)\&.
.TP
\fB%u\fP
Da number of unapplied patches (\fBunapplied\-string\fP)\&.
.TP
\fB%n\fP
Da number of applied patches\&.
.TP
\fB%c\fP
Da number of unapplied patches\&.
.TP
\fB%a\fP
Da number of all patches\&.
.TP
\fB%g\fP
Da namez of actizzle \fBmq\fP guardz (\fBhg\fP backend)\&.
.TP
\fB%G\fP
Da number of actizzle \fBmq\fP guardz (\fBhg\fP backend)\&.
.PD
.PP
Not all VCS backendz gotta support all replacements\&. For \fBnvcsformats\fP
no replacements is performed at all, it is just a string\&.
.PP
.SS "Oddities"
.PP
If you wanna use tha \fB%b\fP (bold off) prompt expansion up in \fBformats\fP,
which expandz \fB%b\fP itself, use \fB%%b\fP\&. That will cause tha \fBvcs_info\fP
expansion ta replace \fB%%b\fP wit \fB%b\fP, so dat zsh\&z prompt expansion
mechanizzle can handle it\&. Right back up in yo muthafuckin ass. Similarly, ta hand down \fB%b\fP from
\fBbranchformat\fP, use \fB%%%%b\fP\&. Right back up in yo muthafuckin ass. Sorry fo' dis inconvenience yo, but it
cannot be easily avoided\&. Luckily our phat asses do not clash wit a shitload of prompt
expansions n' dis only need ta be done fo' them\&.
.PP
.SS "Quilt Support"
.PP
\fBQuilt\fP aint a version control system, therefore dis aint implemented
as a funky-ass backend\&. Well shiiiit, it can help keepin track of a seriez of patches\&. Muthafuckas use it
to keep a set of chizzlez they wanna use on top of software packages (which
is tightly integrated tha fuck into tha package build process \- tha Debian project
does dis fo' a big-ass number of packages)\&. Quilt can also help individual
developers keep track of they own patches on top of real version control
systems\&.
.PP
Da \fBvcs_info\fP integration tries ta support both wayz of rockin quilt by
havin two slightly different modez of operation: `addon\&' mode and
`standalone\&' mode)\&.
.PP
For `addon\&' mode ta become actizzle \fBvcs_info\fP must have already detected a
real version control system controllin tha directory\&. If dat is tha case,
a directory dat holdz quilt\&z patches need ta be found\&. That directory is
configurable via tha `\fBQUILT_PATCHES\fP\&' environment variable\&. If that
variable exists its value is used, otherwise tha value `\fBpatches\fP\&' is
assumed\&. Da value from \fB$QUILT_PATCHES\fP can be overwritten rockin the
\fB`quilt\-patches\&'\fP style\&. (Note: you can use \fBvcs_info\fP ta keep tha value
of \fB$QUILT_PATCHES\fP erect all tha time via tha \fBpost\-quilt\fP hook)\&.
.PP
When tha directory up in question is found, quilt be assumed ta be active\&. To
gather mo' shiznit, \fBvcs_info\fP looks fo' a gangbangin' finger-lickin' directory called `\&.pc\&';
Quilt uses dat directory ta track its current state\&. If dis directory do
not exist we know dat quilt has not done anythang ta tha hustlin directory
(read: no patches done been applied yet)\&.
.PP
If patches is applied, \fBvcs_info\fP will try ta smoke up which\&. If you want
to know which patchez of a series is not yet applied, you need ta activate
the \fBget\-unapplied\fP steez up in tha appropriate context\&.
.PP
\fBvcs_info\fP allows fo' straight-up detailed control over how tha fuck tha gathered
information is presented (see tha below sections, \fBStyles\fP n' \fBHooks in
vcs_info\fP), all of which is documented below\&. Note there be a number of
other patch trackin systems dat work on top of a cold-ass lil certain version control
system (like \fBstgit\fP fo' \fBgit\fP, or \fBmq\fP fo' \fBhg\fP); tha configuration
for systems like dat is generally configured tha same way as tha \fBquilt\fP
support\&.
.PP
If tha \fBquilt\fP support is hustlin up in `addon\&' mode, tha produced strang is
available as a simple format replacement (\fB%Q\fP ta be precise), which can
be used up in \fBformats\fP n' \fBactionformats\fP; peep below fo' details)\&.
.PP
If, on tha other hand, tha support code is hustlin up in `standalone\&' mode,
\fBvcs_info\fP will pretend as if \fBquilt\fP was a actual version control
system\&. That means dat tha version control system identifier (which
otherwise would be suttin' like `svn\&' or `cvs') is ghon be set to
`\fB\-quilt\-\fP\&'\&. This has implications on tha used steez context where this
identifier is tha second element\&. \fBvcs_info\fP gonna git filled up in a proper
value fo' tha "repository\&'s" root directory n' tha strang containin the
information bout quilt\&z state is ghon be available as tha `misc' replacement
(and \fB%Q\fP fo' compatibilitizzle wit `addon\&' mode\&.
.PP
What tha fuck iz left ta say shit bout is how tha fuck `standalone\&' mode is detected\&. Da detection
itself be a seriez of searches fo' directories\&. Yo ass can have dis detection
enabled all tha time up in every last muthafuckin directory dat aint otherwise under version
control\&. If you know there is only a limited set of trees where you would
like \fBvcs_info\fP ta try n' look fo' Quilt up in `standalone\&' mode ta minimise
the amount of searchin on every last muthafuckin call ta \fBvcs_info\fP, there be a number of
ways ta do that:
.PP
Essentially, `standalone\&' mode detection is controlled by a steez called
`\fBquilt\-standalone\fP\&'\&. Well shiiiit, it aint nuthin but a strang steez n' its value can have different
effects\&. Da simplest joints are: `\fBalways\fP\&' ta run detection every last muthafuckin time
\fBvcs_info\fP is run, n' `\fBnever\fP\&' ta turn tha detection off entirely\&.
.PP
If tha value of \fBquilt\-standalone\fP is suttin' else, it is interpreted
differently\&. If tha value is tha name of a scalar variable tha value of that
variable is checked n' dat value is used up in tha same `always\&'/`never' way
as busted lyrics bout above\&.
.PP
If tha value of \fBquilt\-standalone\fP be a array, tha elementz of dat array
are used as directory names under which you want tha detection ta be active\&.
.PP
If \fBquilt\-standalone\fP be a associatizzle array, tha keys is taken as
directory names under which you want tha detection ta be actizzle yo, but only if
the correspondin value is tha strang `\fBtrue\fP\&'\&.
.PP
Last yo, but not least, if tha value of \fBquilt\-standalone\fP is tha name of a
function, tha function is called without arguments n' tha return value
decides whether detection should be active\& fo' realz. A `0\&' return value is true; a
non\-zero return value is interpreted as false\&.
.PP
Note, if there is both a gangbangin' function n' a variable by tha name of
\fBquilt\-standalone\fP, tha function will take precedence\&.
.PP
.SS "Function Descriptions (Public API)"
.PP
.PD 0
.TP
.PD
\fBvcs_info\fP [\fIuser\-context\fP]
Da main function, dat runs all backendz n' assemblez all data into
\fB${vcs_info_msg_*_}\fP\&. This is tha function you wanna call from
\fBprecmd\fP if you wanna include up\-to\-date shiznit up in yo' prompt (see
\fBVariable description\fP below)\&. If a argument is given, dat strang will be
used instead of \fBdefault\fP up in tha \fIuser\-context\fP field of tha style
context\&.
.TP
\fBvcs_info_hookadd\fP
Statically registas a fuckin shitload of functions ta a given hook\&. Da hook needs
to be given as tha straight-up original gangsta argument; what tha fuck bigs up be a list of hook\-function
names ta regista ta tha hook\&. Da `\fB+vi\-\fP\&' prefix need ta be left out
here\&. Right back up in yo muthafuckin ass. See \fBHooks up in vcs_info\fP below fo' details\&.
.TP
\fBvcs_info_hookdel\fP
Remove hook\-functions from a given hook\&. Da hook need ta be given as the
first non\-option argument; what tha fuck bigs up be a list of hook\-function
names ta un\-regista from tha hook\&. If `\fB\-a\fP\&' is used as tha first
argument, \fBall\fP occurrencez of tha functions is unregistered\&. Otherwise
only tha last occurrence is removed (if a gangbangin' function was registered ta a hook
more than once) \&. Da `\fB+vi\-\fP\&' prefix need ta be left up here\&. Right back up in yo muthafuckin ass. See
\fBHooks up in vcs_info\fP below fo' details\&.
.TP
\fBvcs_info_lastmsg\fP
Outputs tha last \fB${vcs_info_msg_*_}\fP value\&.
Takes tha fuck into account tha value of tha \fBuse\-prompt\-escapes\fP steez in
\fB\&':vcs_info:formats:command:\-all\-'\fP\&. Well shiiiit, it also only prints \fBmax\-exports\fP
values\&.
.TP
\fBvcs_info_printsys\fP [\fIuser\-context\fP]
Prints a list of all
supported version control systems\&. Useful ta smoke up possible contexts
(and which of dem is enabled) or joints fo' tha \fBdisable\fP style\&.
.TP
\fBvcs_info_setsys\fP
Initializes \fBvcs_info\fP\&z internal list of
available backends\&. With dis function, you can add support fo' freshly smoked up VCSs
without restartin tha shell\&.
.PP
All functions named VCS_INFO_* is fo' internal use only\&.
.PP
.SS "Variable Description"
.PP
.PD 0
.TP
.PD
\fB${vcs_info_msg_\fP\fIN\fP\fB_}\fP (Note tha trailin underscore)
Where \fIN\fP be a integer, e\&.g\&., \fBvcs_info_msg_0_\fP\&. These variables
are tha storage fo' tha shiznital message tha last \fBvcs_info\fP call
has assembled\&. These is straight fuckin connected ta tha \fBformats\fP,
\fBactionformats\fP n' \fBnvcsformats\fP stylez busted lyrics bout above\&. Those styles
are lists\&. Da first gangmember of dat list gets expanded into
\fB${vcs_info_msg_0_}\fP, tha second tha fuck into \fB${vcs_info_msg_1_}\fP
and tha Nth tha fuck into \fB${vcs_info_msg_N\-1_}\fP\&. These parametas are
exported tha fuck into tha environment\&. (See tha \fBmax\-exports\fP steez above\&.)
.PP
All variablez named VCS_INFO_* is fo' internal use only\&.
.PP
.SS "Hooks up in vcs_info"
.PP
Hooks is places up in \fBvcs_info\fP where you can run yo' own code\&. That
code can rap wit tha code dat called it n' all up in that,
change tha system\&z behaviour\&.
.PP
For configuration, hooks chizzle tha steez context:
.RS
.nf
\fB:vcs_info:\fIvcs\-string\fP+\fIhook\-name\fP:\fIuser\-context\fP:\fIrepo\-root\-name\fP\fP
.fi
.RE
.PP
To regista functions ta a hook, you need ta list dem up in tha \fBhooks\fP
style up in tha appropriate context\&.
.PP
Example:
.RS
.nf
\fBzstyle \&':vcs_info:*+foo:*' hooks bar baz\fP
.fi
.RE
.PP
This registas functions ta tha hook `foo\&' fo' all backends\&. In order to
avoid namespace problems, all registered function names is prepended by
a `+vi\-\&', so tha actual functions called fo' tha `foo' hook are
`\fB+vi\-bar\fP\&' n' `\fB+vi\-baz\fP'\&.
.PP
If you wanna regista a gangbangin' function ta a hook regardless of the
current context, you may use tha \fBvcs_info_hookadd\fP function\&. To remove
a function dat was added like that, tha \fBvcs_info_hookdel\fP function
can be used\&.
.PP
If suttin' seems weird, you can enable tha `debug\&' boolean steez in
the proper context n' tha hook\-callin code will print what tha fuck it tried
to execute n' whether tha function up in question existed\&.
.PP
When you regista mo' than one function ta a hook, all functions are
executed one afta another until one function returns non\-zero or until
all functions done been called\&. Context\-sensitizzle hook functions are
executed \fBbefore\fP statically registered ones (the ones added by
\fBvcs_info_hookadd\fP)\&.
.PP
Yo ass may pass data between functions via a associatizzle array, \fBuser_data\fP\&.
For example:
.RS
.nf
\fB
+vi\-git\-myfirsthook(){
    user_data[myval]=$myval
}
+vi\-git\-mysecondhook(){
    # do suttin' wit ${user_data[myval]}
}\fP
.fi
.RE
.PP
There is a fuckin shitload of variablez dat is special up in hook contexts:
.PP
.PD 0
.TP
.PD
\fBret\fP
Da return value dat tha hooks system will return ta tha caller\&. The
default be a integer `zero\&'\&. If n' how tha fuck a cold-ass lil chizzled \fBret\fP value chizzles
the execution of tha calla dependz on tha specific hook\&. Right back up in yo muthafuckin ass. See tha hook
documentation below fo' details\&.
.TP
\fBhook_com\fP
An associated array which is used fo' bidirectionizzle communication from
the calla ta hook functions\&. Da used keys depend on tha specific hook\&.
.TP
\fBcontext\fP
Da actizzle context of tha hook\&. Functions dat wish ta chizzle this
variable should make it local scope first\&.
.TP
\fBvcs\fP
Da current VCS afta dat shiznit was detected\&. Da same joints as up in the
enable/disable steez is used\& fo' realz. Available up in all hooks except \fBstart\-up\fP\&.
.PP
Finally, tha full list of currently available hooks:
.PP
.PD 0
.TP
.PD
\fBstart\-up\fP
Called afta startin \fBvcs_info\fP but before tha VCS up in dis directory is
determined\&. Well shiiiit, it can be used ta deactivate \fBvcs_info\fP temporarily if
necessary\&. When \fBret\fP is set ta \fB1\fP, \fBvcs_info\fP aborts n' do
nothing; when set ta \fB2\fP, \fBvcs_info\fP sets up every last muthafuckin thang as if no
version control was actizzle n' exits\&.
.TP
\fBpre\-get\-data\fP
Same as \fBstart\-up\fP but afta tha VCS was detected\&.
.TP
\fBgen\-hg\-bookmark\-string\fP
Called up in tha Mercurial backend when a funky-ass bookmark strang is generated; the
\fBget\-revision\fP n' \fBget\-bookmarks\fP stylez must be true\&.
.RS
.PP
This hook gets tha namez of tha Mercurial bookmarks that
\fBvcs_info\fP collected from `hg\&'\&.
.PP
When settin \fBret\fP ta non\-zero, tha strang in
\fB${hook_com[hg\-bookmark\-string]}\fP is ghon be used up in tha \fB%m\fP escape in
\fBformats\fP n' \fBactionformats\fP n' is ghon be available up in tha global
\fBbackend_misc\fP array as \fB${backend_misc[bookmarks]}\fP\&.
.RE
.TP
\fBgen\-applied\-string\fP
Called up in tha \fBgit\fP (with \fBstgit\fP or durin rebase), n' \fBhg\fP
(with \fBmq\fP) backendz n' up in \fBquilt\fP support when tha \fBapplied\-string\fP
is generated; tha \fBuse\-quilt\fP zstyle must be legit fo' \fBquilt\fP (the \fBmq\fP
and \fBstgit\fP backendz is actizzle by default)\&.
.RS
.PP
This hook gets tha namez of all applied patches which \fBvcs_info\fP collected
so far up in tha opposite order, which means dat tha straight-up original gangsta argument is the
top\-most patch n' so forth\&.
.PP
When settin \fBret\fP ta non\-zero, tha strang in
\fB${hook_com[applied\-string]}\fP is ghon be used up in tha \fB%m\fP escape in
\fBformats\fP n' \fBactionformats\fP; it is ghon be available up in tha global
\fBbackend_misc\fP array as \fB$backend_misc[patches]}\fP; n' it will be
available as \fB%p\fP up in tha \fBpatch\-format\fP n' \fBnopatch\-format\fP styles\&.
.RE
.TP
\fBgen\-unapplied\-string\fP
Called up in tha \fBgit\fP (with \fBstgit\fP or durin rebase), n' \fBhg\fP (with
\fBmq\fP) backend n' up in \fBquilt\fP support when tha \fBunapplied\-string\fP is
generated; tha \fBget\-unapplied\fP steez must be true\&.
.RS
.PP
This hook gets tha namez of all unapplied patches which \fBvcs_info\fP
collected so far up in tha opposite order, which mean dat tha straight-up original gangsta argument is
the patch next\-in\-line ta be applied n' so forth\&.
.PP
When settin \fBret\fP ta non\-zero, tha strang in
\fB${hook_com[unapplied\-string]}\fP is ghon be available as \fB%u\fP up in the
\fBpatch\-format\fP n' \fBnopatch\-format\fP styles\&.
.RE
.TP
\fBgen\-mqguards\-string\fP
Called up in tha \fBhg\fP backend when \fBguards\-string\fP is generated; the
\fBget\-mq\fP steez must be legit (default)\&.
.RS
.PP
This hook gets tha namez of any actizzle \fBmq\fP guards\&.
.PP
When settin \fBret\fP ta non\-zero, tha strang in
\fB${hook_com[guards\-string]}\fP is ghon be used up in tha \fB%g\fP escape up in the
\fBpatch\-format\fP n' \fBnopatch\-format\fP styles\&.
.RE
.TP
\fBno\-vcs\fP
This hooks is called when no version control system was detected\&.
.RS
.PP
Da `hook_com\&' parameta aint used\&.
.RE
.TP
\fBpost\-backend\fP
Called as soon as tha backend has finished collectin shiznit\&.
.RS
.PP
Da `\fBhook_com\fP\&' keys available is as fo' tha \fBset\-message\fP hook\&.
.RE
.TP
\fBpost\-quilt\fP
Called afta tha \fBquilt\fP support is done\&. Da followin shiznit
is passed as arguments ta tha hook: 1\&. tha quilt\-support mode (`addon\&' or
`standalone\&'); 2\&. tha directory dat gotz nuff tha patch series; 3\&. the
directory dat holdz quilt\&z status shiznit (the `\&.pc' directory) or
the strang \fB"\-nopc\-"\fP if dat directory wasn\&'t found\&.
.RS
.PP
Da `hook_com\&' parameta aint used\&.
.RE
.TP
\fBset\-branch\-format\fP
Called before `\fBbranchformat\fP\&' is set\&. Da only argument ta the
hook is tha format dat is configured at dis point\&.
.RS
.PP
Da `\fBhook_com\fP\&' keys considered is `\fBbranch\fP' n' `\fBrevision\fP'\&.
They is set ta tha joints figured up so far by \fBvcs_info\fP n' any
change is ghon be used directly when tha actual replacement is done\&.
.PP
If \fBret\fP is set ta non\-zero, tha strang in
\fB${hook_com[branch\-replace]}\fP is ghon be used unchanged as the
`\fB%b\fP\&' replacement up in tha variablez set by \fBvcs_info\fP\&.
.RE
.TP
\fBset\-hgrev\-format\fP
Called before a `\fBhgrevformat\fP\&' is set\&. Da only argument ta the
hook is tha format dat is configured at dis point\&.
.RS
.PP
Da `\fBhook_com\fP\&' keys considered is `\fBhash\fP' n' `\fBlocalrev\fP'\&.
They is set ta tha joints figured up so far by \fBvcs_info\fP n' any
change is ghon be used directly when tha actual replacement is done\&.
.PP
If \fBret\fP is set ta non\-zero, tha strang in
\fB${hook_com[rev\-replace]}\fP is ghon be used unchanged as the
`\fB%i\fP\&' replacement up in tha variablez set by \fBvcs_info\fP\&.
.RE
.TP
\fBset\-message\fP
Called each time before a `\fBvcs_info_msg_N_\fP\&' message is set\&.
It takes two arguments; tha straight-up original gangsta bein tha `N\&' up in tha message
variable name, tha second is tha currently configured \fBformats\fP or
\fBactionformats\fP\&.
.RS
.PP
There is a fuckin shitload of `\fBhook_com\fP\&' keys, dat is used here:
`\fBaction\fP\&', `\fBbranch\fP', `\fBbase\fP', `\fBbase\-name\fP', `\fBsubdir\fP',
`\fBstaged\fP\&', `\fBunstaged\fP', `\fBrevision\fP', `\fBmisc\fP', `\fBvcs\fP'
and one `\fBmiscN\fP\&' entry fo' each backend\-specific data field (\fBN\fP
startin at zero)\&. They is set ta tha joints figured up so far by
\fBvcs_info\fP n' any chizzle is ghon be used directly when tha actual
replacement is done\&.
.PP
Since dis hook is triggered multiple times (once fo' each configured
\fBformats\fP or \fBactionformats\fP), each of tha `\fBhook_com\fP\&' keys mentioned
above (except fo' tha \fBmiscN\fP entries) has a `\fB_orig\fP\&' counterpart,
so even if you chizzled a value ta yo' likin you can still git the
original gangsta value up in tha next run\&. Changin tha `\fB_orig\fP\&' joints is
probably not a phat idea\&.
.PP
If \fBret\fP is set ta non\-zero, tha strang in
\fB${hook_com[message]}\fP is ghon be used unchanged as tha message by
\fBvcs_info\fP\&.
.RE
.PP
If all of dis soundz rather confusing, take a peep tha \fBExamples\fP
section below n' also up in tha Misc/vcs_info\-examplez file up in tha Zsh source\&.
They contain some explanatory code\&.
.PP
.SS "Examples"
.PP
Don\&'t use \fBvcs_info\fP at all (even though itz up in yo' prompt):
.RS
.nf
\fBzstyle \&':vcs_info:*' enable NONE\fP
.fi
.RE
.PP
Disable tha backendz fo' \fBbzr\fP n' \fBsvk\fP:
.RS
.nf
\fBzstyle \&':vcs_info:*' disable bzr svk\fP
.fi
.RE
.PP
Disable every last muthafuckin thang \fIbut\fP \fBbzr\fP n' \fBsvk\fP:
.RS
.nf
\fBzstyle \&':vcs_info:*' enable bzr svk\fP
.fi
.RE
.PP
Provide a special formats fo' \fBgit\fP:
.RS
.nf
\fBzstyle \&':vcs_info:git:*' formats       ' GIT, BABY! [%b]'
zstyle \&':vcs_info:git:*' actionformats ' GIT ACTION! [%b|%a]'\fP
.fi
.RE
.PP
All \fB%x\fP expansion up in all sortz of formats ("formats", "actionformats",
branchformat, you name it) is done rockin tha `\fBzformat\fP\&' builtin from
the `\fBzsh/zutil\fP\&' module\&. That means you can do every last muthafuckin thang wit these
\fB%x\fP shit what tha fuck zformat supports\&. In particular, if you want something
that is straight-up long ta git a gangbangin' fixed width, like a hash up in a mercurial
branchformat, you can do this: \fB%12\&.12i\fP\&. That\&'ll shrink tha 40 character
hash ta its 12 leadin characters\&. Da form be actually
`\fB%\fP\fImin\fP\fB\&.\fP\fImax\fP\fBx\fP\&'\&. Mo' is possible\&.
See tha section `Da zsh/zutil Module\&' up in \fIzshmodules\fP(1) fo' details\&.
.PP
Use tha quicker \fBbzr\fP backend
.RS
.nf
\fBzstyle \&':vcs_info:bzr:*' use\-simple true\fP
.fi
.RE
.PP
If you do use \fBuse\-simple\fP, please report if it do `the\-right\-thing[tm]\&'\&.
.PP
Display tha revision number up in yellow fo' \fBbzr\fP n' \fBsvn\fP:
.RS
.nf
\fBzstyle \&':vcs_info:(svn|bzr):*' branchformat '%b%{'${fg[yellow]}'%}:%r'\fP
.fi
.RE
.PP
If you want colors, make shizzle you enclose tha color codes up in \fB%{\&.\&.\&.%}\fP
if you wanna use tha strang provided by \fBvcs_info\fP up in prompts\&.
.PP
Here is how tha fuck ta print tha VCS shiznit as a cold-ass lil command (not up in a prompt):
.RS
.nf
\fBalias vcsi=\&'vcs_info command; vcs_info_lastmsg'\fP
.fi
.RE
.PP
This way, you can even define different formats fo' output via
\fBvcs_info_lastmsg\fP up in tha \&':vcs_info:*:command:*' namespace\&.
.PP
Now as promised, some code dat uses hooks:
say, you\&'d like ta replace tha strang `svn' by `subversion' in
\fBvcs_info\fP\&z \fB%s\fP \fBformats\fP replacement\&.
.PP
First, we will tell \fBvcs_info\fP ta booty-call a gangbangin' function when populating
the message variablez wit tha gathered shiznit:
.RS
.nf
\fBzstyle \&':vcs_info:*+set\-message:*' hooks svn2subversion\fP
.fi
.RE
.PP
Nothang happens\&. Which is reasonable, since our phat asses didn\&'t define tha actual
function yet\&. To peep what tha fuck tha hooks subsystem is tryin ta do, enable the
`\fBdebug\fP\&' style:
.RS
.nf
\fBzstyle \&':vcs_info:*+*:*' debug true\fP
.fi
.RE
.PP
That should hit you wit a scam what tha fuck is goin on\&. Right back up in yo muthafuckin ass. Specifically, tha function
that we is lookin fo' is `\fB+vi\-svn2subversion\fP\&'\&. Note, tha `\fB+vi\-\fP'
prefix\&. Right back up in yo muthafuckin ass. So, every last muthafuckin thang is up in order, just as documented\&. When yo ass is done
checkin up tha debuggin output, disable it again:
.RS
.nf
\fBzstyle \&':vcs_info:*+*:*' debug false\fP
.fi
.RE
.PP
Now, let\&z define tha function:
.RS
.nf
\fB
function +vi\-svn2subversion() {
    [[ ${hook_com[vcs_orig]} == svn ]] && hook_com[vcs]=subversion
}\fP
.fi
.RE
.PP
Simple enough\& fo' realz. And it could have even been simpler, if only our crazy asses had
registered our function up in a less generic context\&. If our phat asses do it only in
the `\fBsvn\fP\&' backendz context, our phat asses don't need ta test which tha active
backend is:
.RS
.nf
\fBzstyle \&':vcs_info:svn+set\-message:*' hooks svn2subversion\fP
.fi
.RE
.RS
.nf
\fB
function +vi\-svn2subversion() {
    hook_com[vcs]=subversion
}\fP
.fi
.RE
.PP
And finally a lil mo' elaborate example, dat uses a hook ta create
a customised bookmark strang fo' tha \fBhg\fP backend\&.
.PP
Again, we start off by registerin a gangbangin' function:
.RS
.nf
\fBzstyle \&':vcs_info:hg+gen\-hg\-bookmark\-string:*' hooks hgbookmarks\fP
.fi
.RE
.PP
And then our phat asses define tha `\fB+vi\-hgbookmarks\fP function:
.RS
.nf
\fB
function +vi\-hgbookmarks() {
    # Da default is ta connect all bookmark names by
    # commas\&. This mixes thangs up a lil\&.
    # Imagine, there\&z one type of bookmarks dat is
    # special ta you\&. Right back up in yo muthafuckin ass. Say, cuz it\&z *your* work\&.
    # Those bookmarks look always like this: "sh/*"
    # (because yo' initials is sh, fo' example)\&.
    # This make tha bookmarks strang use only them
    # bookmarks\&. If there\&z mo' than one, it
    # concatenates dem rockin commas\&.
    # Da bookmarks returned by `hg\&' is available in
    # tha function\&z positionizzle parameters\&.
    local s="${(Mj:,:)@:#sh/*}"
    # Now, tha communication wit tha code dat calls
    # tha hook functions is done via tha hook_com[]
    # hash\&. Da key at which tha `gen\-hg\-bookmark\-string\&'
    # hook looks is `hg\-bookmark\-string\&'\&. Right back up in yo muthafuckin ass. So:
    hook_com[hg\-bookmark\-string]=$s
    # And ta signal dat we wanna use tha strang we
    # just generated, set tha special variable `ret\&' to
    # suttin' other than tha default zero:
    ret=1
    return 0
}
\fP
.fi
.RE
.PP
Some longer examplez n' code snippets which might be useful is available in
the examplez file located at Misc/vcs_info\-examplez up in tha Zsh source
directory\&.
.PP
This concludes our guided trip all up in zsh\&z \fBvcs_info\fP\&.
.PP
.SH "PROMPT THEMES"
.PP
.SS "Installation"
.PP
Yo ass should make shizzle all tha functions from tha \fBFunctions/Prompts\fP
directory of tha source distribution is available; they all begin with
the strang `\fBprompt_\fP\&' except fo' tha special function`\fBpromptinit\fP'\&.
Yo ass also need tha `\fBcolors\fP\&' function from \fBFunctions/Misc\fP\&.  All of
these functions may already done been installed on yo' system; if not,
you will need ta find dem n' copy them\&.  Da directory should step tha fuck up as
one of tha elementz of tha \fBfpath\fP array (this should already be the
case if they was installed), n' at least tha function \fBpromptinit\fP
should be autoloaded; it will autoload tha rest\&.  Finally, ta initialize
the use of tha system you need ta booty-call tha \fBpromptinit\fP function\&.  The
followin code up in yo' \fB\&.zshrc\fP will arrange fo' this; assume the
functions is stored up in tha directory \fB~/myfns\fP:
.PP
.RS
.nf
\fBfpath=(~/myfns $fpath)
autoload \-U promptinit
promptinit\fP
.fi
.RE
.PP
.SS "Theme Selection"
.PP
Use tha \fBprompt\fP command ta select yo' preferred theme\&.  This command
may be added ta yo' \fB\&.zshrc\fP followin tha call ta \fBpromptinit\fP in
order ta start zsh wit a theme already selected\&.
.PP
.PD 0
.TP
.PD 0
\fBprompt\fP [ \fB\-c\fP | \fB\-l\fP ]
.TP
.PD 0
\fBprompt\fP [ \fB\-p\fP | \fB\-h\fP ] [ \fItheme\fP \&.\&.\&. ]
.TP
.PD
\fBprompt\fP [ \fB\-s\fP ] \fItheme\fP [ \fIarg\fP \&.\&.\&. ]
Set or examine tha prompt theme\&.  With no options n' a \fItheme\fP
argument, tha theme wit dat name is set as tha current theme\&.  The
available themes is determined at run time; use tha \fB\-l\fP option ta see
a list\&.  Da special \fItheme\fP `\fBrandom\fP\&' selects at random one of the
available themes n' sets yo' prompt ta that\&.
.RS
.PP
In some cases tha \fItheme\fP may be modified by one or mo' arguments,
which should be given afta tha theme name\&.  See tha help fo' each theme
for descriptionz of these arguments\&.
.PP
Options are:
.PP
.PD 0
.TP
\fB\-c\fP
Show tha currently selected theme n' its parameters, if any\&.
.TP
\fB\-l\fP
List all available prompt themes\&.
.TP
\fB\-p\fP
Preview tha theme named by \fItheme\fP, or all themes if no
\fItheme\fP is given\&.
.TP
\fB\-h\fP
Show help fo' tha theme named by \fItheme\fP, or fo' the
\fBprompt\fP function if no \fItheme\fP is given\&.
.TP
\fB\-s\fP
Set \fItheme\fP as tha current theme n' save state\&.
.PD
.RE
.TP
\fBprompt_\fP\fItheme\fP\fB_setup\fP
Each available \fItheme\fP has a setup function which is called by the
\fBprompt\fP function ta install dat theme\&.  This function may define
other functions as necessary ta maintain tha prompt, includin functions
used ta peepshow tha prompt or provide help fo' its use\&.  Yo ass should not
normally call a theme\&z setup function directly\&.
.PP
.SH "ZLE FUNCTIONS"
.PP
.SS "Widgets"
.PP
These functions all implement user\-defined ZLE widgets (see
\fIzshzle\fP(1)) which can be bound ta keystrokes up in interactizzle shells\&.  To use them,
your \fB\&.zshrc\fP should contain linez of tha form
.PP
.RS
.nf
\fBautoload \fIfunction\fP
zle \-N \fIfunction\fP\fP
.fi
.RE
.PP
followed by a appropriate \fBbindkey\fP command ta associate tha function
with a key sequence\&.  Suggested bindings is busted lyrics bout below\&.
.PP
.PD 0
.TP
.PD
bash\-style word functions
If yo ass is lookin fo' functions ta implement movin over n' editing
wordz up in tha manner of bash, where only alphanumeric charactas are
considered word characters, you can use tha functions busted lyrics bout in
the next section\&.  Da followin is sufficient:
.RS
.PP
.RS
.nf
\fBautoload \-U select\-word\-style
select\-word\-style bash\fP
.fi
.RE
.PP
.RE
.TP
.PD 0
\fBforward\-word\-match\fP, \fBbackward\-word\-match\fP
.TP
.PD 0
\fBkill\-word\-match\fP, \fBbackward\-kill\-word\-match\fP
.TP
.PD 0
\fBtranspose\-words\-match\fP, \fBcapitalize\-word\-match\fP
.TP
.PD 0
\fBup\-case\-word\-match\fP, \fBdown\-case\-word\-match\fP
.TP
.PD
\fBselect\-word\-style\fP, \fBmatch\-word\-context\fP, \fBmatch\-words\-by\-style\fP
Da eight `\fB\-match\fP\&' functions is drop\-in replacements fo' the
builtin widgets without tha suffix\&.  By default they behave up in a similar
way\&.  But fuck dat shiznit yo, tha word on tha street is dat by tha use of stylez n' tha function \fBselect\-word\-style\fP,
the way lyrics is matched can be altered\&.
.RS
.PP
Da simplest way of configurin tha functions is ta use
\fBselect\-word\-style\fP, which can either be called as a aiiight function with
the appropriate argument, or invoked as a user\-defined widget dat will
prompt fo' tha straight-up original gangsta characta of tha word steez ta be used\&.  Da first
time it is invoked, tha eight \fB\-match\fP functions will automatically
replace tha builtin versions, so they do not need ta be loaded explicitly\&.
.PP
Da word stylez available is as bigs up\&.  Only tha straight-up original gangsta character
is examined\&.
.PP
.PD 0
.TP
.PD
\fBbash\fP
Word charactas is alphanumeric charactas only\&.
.TP
\fBnormal\fP
As up in aiiight shell operation:  word charactas is alphanumeric characters
plus any charactas present up in tha strang given by tha parameter
\fB$WORDCHARS\fP\&.
.TP
\fBshell\fP
Lyrics is complete shell command arguments, possibly includin complete
quoted strings, or any tokens special ta tha shell\&.
.TP
\fBwhitespace\fP
Lyrics is any set of charactas delimited by whitespace\&.
.TP
\fBdefault\fP
Restore tha default settings; dis is probably tha same as `\fBnormal\fP\&'\&.
.PP
All but `\fBdefault\fP\&' can be input as a upper case character, which has
the same effect but wit subword matchin turned on\&.  In dis case, lyrics
with upper case charactas is treated specially: each separate run of
upper case characters, or a upper case characta followed by any number of
other characters, is considered a word\&.  Da steez \fBsubword\-range\fP
can supply a alternatizzle characta range ta tha default `\fB[:upper:]\fP\&';
the value of tha steez is treated as tha contentz of a `\fB[\fP\fI\&.\&.\&.\fP\fB]\fP\&'
pattern (note dat tha outa brackets should not be supplied, only
those surroundin named ranges)\&.
.PP
Mo' control can be obtained rockin tha \fBzstyle\fP command, as busted lyrics bout in
\fIzshmodules\fP(1)\&.  Each steez is looked up in the
context \fB:zle:\fP\fIwidget\fP where \fIwidget\fP is tha name of the
user\-defined widget, not tha name of tha function implementin it, so in
the case of tha definitions supplied by \fBselect\-word\-style\fP the
appropriate contexts is \fB:zle:forward\-word\fP, n' so on\&.  Da function
\fBselect\-word\-style\fP itself always defines stylez fo' tha context
`\fB:zle:*\fP\&' which can be overridden by mo' specific (longer) patterns as
well as explicit contexts\&.
.PP
Da steez \fBword\-style\fP specifies tha rulez ta use\&.  This may have the
followin joints\&.
.PP
.PD 0
.TP
.PD
\fBnormal\fP
Use tha standard shell rules, i\&.e\&. alphanumerics n' \fB$WORDCHARS\fP, unless
overridden by tha stylez \fBword\-chars\fP or \fBword\-class\fP\&.
.TP
\fBspecified\fP
Similar ta \fBnormal\fP yo, but \fIonly\fP tha specified characters, n' not also
alphanumerics, is considered word characters\&.
.TP
\fBunspecified\fP
Da negation of specified\&.  Da given charactas is dem which will
\fInot\fP be considered part of a word\&.
.TP
\fBshell\fP
Lyrics is obtained by rockin tha syntactic rulez fo' generatin shell
command arguments\&.  In addition, special tokens which is never command
arguments like fuckin `\fB()\fP\&' is also treated as lyrics\&.
.TP
\fBwhitespace\fP
Lyrics is whitespace\-delimited stringz of characters\&.
.PP
Da first three of dem rulez probably use \fB$WORDCHARS\fP yo, but tha value
in tha parameta can be overridden by tha steez \fBword\-chars\fP, which works
in exactly tha same way as \fB$WORDCHARS\fP\&.  In addition, tha style
\fBword\-class\fP uses characta class syntax ta crew charactas n' takes
precedence over \fBword\-chars\fP if both is set\&.  Da \fBword\-class\fP style
does not include tha surroundin bracketz of tha characta class; for
example, `\fB\-:[:alnum:]\fP\&' be a valid \fBword\-class\fP ta include all
alphanumerics plus tha charactas `\fB\-\fP\&' n' `\fB:\fP'\&.  Be careful
includin `\fB]\fP\&', `\fB^\fP' n' `\fB\-\fP' as these is special inside
characta classes\&.
.PP
\fBword\-style\fP may also have `\fB\-subword\fP\&' appended ta its value to
turn on subword matching, as busted lyrics bout above\&.
.PP
Da steez \fBskip\-chars\fP is mostly useful for
\fBtranspose\-words\fP n' similar functions\&.  If set, it gives a cold-ass lil count of
charactas startin all up in tha cursor posizzle which aint gonna be considered
part of tha word n' is treated as space, regardless of what tha fuck they actually
are\&.  For example, if
.PP
.RS
.nf
\fBzstyle \&':zle:transpose\-words' skip\-chars 1\fP
.fi
.RE
.PP
has been set, n' \fBtranspose\-words\-match\fP is called wit tha cursor on
the \fIX\fP of \fBfoo\fP\fIX\fP\fBbar\fP, where \fIX\fP can be any character, then
the resultin expression is \fBbar\fP\fIX\fP\fBfoo\fP\&.
.PP
Finer grained control can be obtained by settin tha steez \fBword\-context\fP
to a array of pairz of entries\&.  Each pair of entries consistz of a
\fIpattern\fP n' a \fIsubcontext\fP\&.  Da shell argument tha cursor is on is
matched against each \fIpattern\fP up in turn until one matches; if it do,
the context is extended by a cold-ass lil colon n' tha correspondin \fIsubcontext\fP\&.
Note dat tha test is made against tha original gangsta word on tha line, wit no
strippin of quotes\&.  Special handlin is done between lyrics: tha current
context is examined n' if it gotz nuff tha strang \fBback\fP, tha word before
the cursor is considered, else tha word afta cursor is considered\&. Right back up in yo muthafuckin ass. Some
examplez is given below\&.
.PP
Da steez \fBskip\-whitespace\-first\fP is only used wit the
\fBforward\-word\fP widget\&.  If it is set ta true, then \fBforward\-word\fP
skips any non\-word\-characters, followed by any non\-word\-characters:
this is similar ta tha behaviour of other word\-orientated widgets,
and also dat used by other editors, however it differs from the
standard zsh behaviour\&.  When rockin \fBselect\-word\-style\fP tha widget
is set up in tha context \fB:zle:*\fP ta \fBtrue\fP if tha word steez is
\fBbash\fP n' \fBfalse\fP otherwise\&.  It may be overridden by settin it in
the mo' specific context \fB:zle:forward\-word*\fP\&.
.PP
Here is some examplez of use of tha styles, straight-up taken from the
simplified intercourse up in \fBselect\-word\-style\fP:
.PP
.RS
.nf
\fBzstyle \&':zle:*' word\-style standard
zstyle \&':zle:*' word\-chars ''\fP
.fi
.RE
.PP
Implements bash\-style word handlin fo' all widgets, i\&.e\&. only
alphanumerics is word characters; equivalent ta setting
the parameta \fBWORDCHARS\fP empty fo' tha given context\&.
.PP
.RS
.nf
\fBstyle \&':zle:*kill*' word\-style space\fP
.fi
.RE
.PP
Uses space\-delimited lyrics fo' widgets wit tha word `kill\&' up in tha name\&.
Neither of tha stylez \fBword\-chars\fP nor \fBword\-class\fP is used up in dis case\&.
.PP
Here is some examplez of use of tha \fBword\-context\fP steez ta extend
the context\&.
.PP
.RS
.nf
\fBzstyle \&':zle:*' word\-context "*/*" file "[[:space:]]" whitespace
zstyle \&':zle:transpose\-words:whitespace' word\-style shell
zstyle \&':zle:transpose\-words:filename' word\-style normal
zstyle \&':zle:transpose\-words:filename' word\-chars ''\fP
.fi
.RE
.PP
This serves up two different wayz of rockin \fBtranspose\-words\fP dependin on
whether tha cursor is on whitespace between lyrics or on a gangbangin' filename, here
any word containin a \fB/\fP\&.  On whitespace, complete arguments as defined
by standard shell rulez is ghon be transposed\&.  In a gangbangin' filename, only
alphanumerics is ghon be transposed\&.  Elsewhere, lyrics is ghon be transposed
usin tha default steez fo' \fB:zle:transpose\-words\fP\&.
.PP
Da word matchin n' all tha handlin of \fBzstyle\fP settings be actually
implemented by tha function \fBmatch\-words\-by\-style\fP\&.  This can be used to
create freshly smoked up user\-defined widgets\&.  Da callin function should set tha local
parameta \fBcurcontext\fP ta \fB:zle:\fP\fIwidget\fP, create tha local
parameta \fBmatched_words\fP n' call \fBmatch\-words\-by\-style\fP wit no
arguments\&.  On return, \fBmatched_words\fP is ghon be set ta a array wit the
elements: (1) tha start of tha line (2) tha word before tha cursor (3) any
non\-word charactas between dat word n' tha cursor (4) any non\-word
characta all up in tha cursor posizzle plus any remainin non\-word characters
before tha next word, includin all charactas specified by the
\fBskip\-chars\fP style, (5) tha word at or followin tha cursor (6) any
non\-word charactas followin dat word (7) tha remainder of tha line\&.  Any
of tha elements may be a empty string; tha callin function should test
for dis ta decizzle whether it can big-ass up its function\&.
.PP
It be possible ta pass options wit arguments ta \fBmatch\-words\-by\-style\fP
to override tha use of styles\&.  Da options are:
.PD 0
.TP
\fB\-w\fP
\fIword\-style\fP
.TP
\fB\-s\fP
\fIskip\-chars\fP
.TP
\fB\-c\fP
\fIword\-class\fP
.TP
\fB\-C\fP
\fIword\-chars\fP
.TP
\fB\-r\fP
\fIsubword\-range\fP
.PD
.PP
For example, \fBmatch\-words\-by\-style \-w shell \-c 0\fP may be used to
extract tha command argument round tha cursor\&.
.PP
Da \fBword\-context\fP steez is implemented by tha function
\fBmatch\-word\-context\fP\&.  This should not probably need ta be called
directly\&.
.RE
.TP
\fBcopy\-earlier\-word\fP
This widget works like a cold-ass lil combination of \fBinsert\-last\-word\fP and
\fBcopy\-prev\-shell\-word\fP\&.  Repeated invocationz of tha widget retrieve
earlier lyrics on tha relevant history line\&.  With a numeric argument
\fIN\fP, bang tha \fIN\fPth word from tha history line; \fIN\fP may be
negatizzle ta count from tha end of tha line\&.
.RS
.PP
If \fBinsert\-last\-word\fP has been used ta retrieve tha last word on a
previous history line, repeated invocations will replace dat word with
earlier lyrics from tha same line\&.
.PP
Otherwise, tha widget applies ta lyrics on tha line currently bein edited\&.
Da \fBwidget\fP steez can be set ta tha name of another widget dat should
be called ta retrieve lyrics\&.  This widget must accept tha same three
arguments as \fBinsert\-last\-word\fP\&.
.RE
.TP
\fBcycle\-completion\-positions\fP
Afta insertin a unambiguous strang tha fuck into tha command line, tha new
function based completion system may know bout multiple places in
this strang where charactas is missin or differ from at least one
of tha possible matches\&.  It will then place tha cursor on the
posizzle it considaz ta be da most thugged-out bangin-ass one, i\&.e\&. tha one
where one can disambiguate between as nuff matches as possible wit as 
lil typin as possible\&.
.RS
.PP
This widget allows tha cursor ta be easily moved ta tha other interesting
spots\&.  It can be invoked repeatedly ta cycle between all positions
reported by tha completion system\&.
.RE
.TP
\fBdelete\-whole\-word\-match\fP
This be another function which works like tha \fB\-match\fP functions
busted lyrics bout immediately above, i\&.e\&. rockin stylez ta decizzle tha word
boundaries\&.  But fuck dat shiznit yo, tha word on tha street is dat it aint a replacement fo' any existin function\&.
.RS
.PP
Da basic behaviour is ta delete tha word round tha cursor\&.  There is no
numeric prefix handling; only tha single word round tha cursor is
considered\&.  If tha widget gotz nuff tha strang \fBkill\fP, tha removed text
will be placed up in tha cutbuffer fo' future yanking\&.  This can be obtained
by definin \fBkill\-whole\-word\-match\fP as bigs up:
.PP
.RS
.nf
\fBzle \-N kill\-whole\-word\-match delete\-whole\-word\-match\fP
.fi
.RE
.PP
and then bindin tha widget \fBkill\-whole\-word\-match\fP\&.
.RE
.TP
\fBup\-line\-or\-beginning\-search\fP, \fBdown\-line\-or\-beginning\-search\fP
These widgets is similar ta tha builtin functions \fBup\-line\-or\-search\fP
and \fBdown\-line\-or\-search\fP:  if up in a multiline buffer they move up or
down within tha buffer, otherwise they search fo' a history line matching
the start of tha current line\&.  In dis case, however, they search for
a line which matches tha current line up ta tha current cursor position, in
the manner of \fBhistory\-beginning\-search\-backward\fP n' \fB\-forward\fP, rather
than tha straight-up original gangsta word on tha line\&.
.TP
\fBedit\-command\-line\fP
Edit tha command line rockin yo' visual editor, as up in \fBksh\fP\&.
.RS
.PP
.RS
.nf
\fBbindkey \-M vicmd v edit\-command\-line\fP
.fi
.RE
.RE
.TP
\fBexpand\-absolute\-path\fP
Expand tha file name under tha cursor ta a absolute path, resolving
symbolic links\&.  Where possible, tha initial path segment is turned
into a named directory or reference ta a user\&z home directory\&.
.TP
\fBhistory\-search\-end\fP
This function implements tha widgets
\fBhistory\-beginning\-search\-backward\-end\fP and
\fBhistory\-beginning\-search\-forward\-end\fP\&.  These commandz work by first
callin tha correspondin builtin widget (see
`History Control\&' up in \fIzshzle\fP(1)) n' then movin tha cursor ta tha end of tha line\&.  Da original gangsta cursor
posizzle is remembered n' restored before callin tha builtin widget a
second time, so dat tha same search is repeated ta look farther through
the history\&.
.RS
.PP
Although you \fBautoload\fP only one function, tha commandz ta use it are
slightly different cuz it implements two widgets\&.
.PP
.RS
.nf
\fBzle \-N history\-beginning\-search\-backward\-end \e 
       history\-search\-end
zle \-N history\-beginning\-search\-forward\-end \e 
       history\-search\-end
bindkey \&'\ee^P' history\-beginning\-search\-backward\-end
bindkey \&'\ee^N' history\-beginning\-search\-forward\-end\fP
.fi
.RE
.RE
.TP
\fBhistory\-beginning\-search\-menu\fP
This function implements yet another form of history searching\&.  The
text before tha cursor is used ta select lines from tha history,
as fo' \fBhistory\-beginning\-search\-backward\fP except dat all matches are
shown up in a numbered menu\&.  Typin tha appropriate digits bangs the
full history line\&.  Note dat leadin zeroes must be typed (they is only
shown when necessary fo' removin ambiguity)\&.  Da entire history is
searched; there is no distinction between forwardz n' backwards\&.
.RS
.PP
With a prefix argument, tha search aint anchored ta tha start of
the line; tha strang typed by tha use may step tha fuck up anywhere up in tha line
in tha history\&.
.PP
If tha widget name gotz nuff `\fB\-end\fP\&' tha cursor is moved ta tha end of
the line inserted\&.  If tha widget name gotz nuff `\fB\-space\fP\&' any space
in tha text typed is treated as a wildcard n' can match anythang (hence
a leadin space is equivalent ta givin a prefix argument)\&.  Both
forms can be combined, fo' example:
.PP
.RS
.nf
\fBzle \-N history\-beginning\-search\-menu\-space\-end \e 
       history\-beginning\-search\-menu\fP
.fi
.RE
.RE
.TP
\fBhistory\-pattern\-search\fP
Da function \fBhistory\-pattern\-search\fP implements widgets which prompt
for a pattern wit which ta search tha history backwardz or forwards\&.  The
pattern is up in tha usual zsh format, however tha straight-up original gangsta characta may be
\fB^\fP ta anchor tha search ta tha start of tha line, n' tha last character
may be \fB$\fP ta anchor tha search ta tha end of tha line\&.  If the
search was not anchored ta tha end of tha line tha cursor is positioned
just afta tha pattern found\&.
.RS
.PP
Da commandz ta create bindable widgets is similar ta dem up in the
example immediately above:
.PP
.RS
.nf
\fBautoload \-U history\-pattern\-search
zle \-N history\-pattern\-search\-backward history\-pattern\-search
zle \-N history\-pattern\-search\-forward history\-pattern\-search\fP
.fi
.RE
.RE
.TP
\fBincarg\fP
Typin tha keystrokes fo' dis widget wit tha cursor placed on or ta the
left of a integer causes dat integer ta be incremented by one\&.  With a
numeric prefix argument, tha number is incremented by tha amount of the
argument (decremented if tha prefix argument is negative)\&.  Da shell
parameta \fBincarg\fP may be set ta chizzle tha default increment to
suttin' other than one\&.
.RS
.PP
.RS
.nf
\fBbindkey \&'^X+' incarg\fP
.fi
.RE
.RE
.TP
\fBincremental\-complete\-word\fP
This allows incremenstrual completion of a word\&.  Afta startin this
command, a list of completion chizzlez can be shown afta every last muthafuckin character
you type, which you can delete wit \fB^H\fP or \fBDEL\fP\&.  Pressin return
accepts tha completion so far n' returns you ta aiiight editin (that is,
the command line is \fInot\fP immediately executed)\&.  Yo ass can hit \fBTAB\fP to
do aiiight completion, \fB^G\fP ta abort back ta tha state when you started,
and \fB^D\fP ta list tha matches\&.
.RS
.PP
This works only wit tha freshly smoked up function based completion system\&.
.PP
.RS
.nf
\fBbindkey \&'^Xi' incremental\-complete\-word\fP
.fi
.RE
.RE
.TP
\fBinsert\-composed\-char\fP
This function allows you ta compose charactas dat don\&'t step tha fuck up on the
keyboard ta be banged tha fuck into tha command line\&.  Da command is followed by
two keys correspondin ta ASCII charactas (there is no prompt)\&.  For
accented characters, tha two keys is a funky-ass base characta followed by a cold-ass lil code
for tha accent, while fo' other special charactas tha two characters
together form a mnemonic fo' tha characta ta be inserted\&.  The
two\-characta codes is a subset of dem given by RFC 1345 (see for
example \fBhttp://www\&.faqs\&.org/rfcs/rfc1345\&.html\fP)\&.
.RS
.PP
Da function may optionally be followed by up ta two charactas which
replace one or both of tha charactas read from tha keyboard; if both
charactas is supplied, no input is read\&.  For example,
\fBinsert\-composed\-char a:\fP can be used within a widget ta bang a a with
umlaut tha fuck into tha command line\&.  This has tha advantages over use of a
literal characta dat it is mo' portable\&.
.PP
For dopest thangs up in dis biatch zsh should done been built wit support fo' multibyte
charactas (configured wit \fB\-\-enable\-multibyte\fP); however, tha function
works fo' tha limited range of charactas available up in single\-byte
characta sets like fuckin ISO\-8859\-1\&.
.PP
Da characta is converted tha fuck into tha local representation and
inserted tha fuck into tha command line all up in tha cursor position\&.
(Da conversion is done within tha shell, rockin whatever facilities
the C library provides\&.)  With a numeric argument, tha characta n' its
code is peepshowed up in tha status line
.PP
Da function may be run outside zle up in which case it prints tha character
(together wit a newline) ta standard output\&.  Input is still read from
keystrokes\&.
.PP
See \fBinsert\-unicode\-char\fP fo' a alternatizzle way of insertin Unicode
charactas rockin they hexadecimal characta number\&.
.PP
Da set of accented charactas is reasonably complete up ta Unicode
characta U+0180, tha set of special charactas less so\&.  But fuck dat shiznit yo, tha word on tha street is dat it
is straight-up sporadic from dat point\&.  Addin freshly smoked up charactas is easy as fuck ,
however; peep tha function \fBdefine\-composed\-chars\fP\&.  Please bust any
additions ta \fBzsh\-workers@zsh\&.org\fP\&.
.PP
Da codes fo' tha second characta when used ta accent tha straight-up original gangsta is as
bigs up\&.  Note dat not every last muthafuckin characta can take every last muthafuckin accent\&.
.PD 0
.TP
\fB!\fP
Grave\&.
.TP
\fB\&'\fP
Acute\&.
.TP
\fB>\fP
Circumflex\&.
.TP
\fB?\fP
Tilde\&.  (This aint \fB~\fP as RFC 1345 do not assume that
characta is present on tha keyboard\&.)
.TP
\fB\-\fP
Macron\&.  (A horizontal bar over tha base character\&.)
.TP
\fB(\fP
Breve\&.  (A shallow dish shape over tha base character\&.)
.TP
\fB\&.\fP
Dot above tha base character, or up in tha case of \fBi\fP no dot,
or up in tha case of \fBL\fP n' \fBl\fP a cold-ass lil centered dot\&.
.TP
\fB:\fP
Diaeresis (Umlaut)\&.
.TP
\fBc\fP
Cedilla\&.
.TP
\fB_\fP
Underline, however there be currently no underlined characters\&.
.TP
\fB/\fP
Stroke all up in tha base character\&.
.TP
\fB"\fP
Double acute (only supported on all dem letters)\&.
.TP
\fB;\fP
Ogonek\&.  (A lil forward facin hook all up in tha bottom right
of tha character\&.)
.TP
\fB<\fP
Caron\&.  (A lil v over tha letter\&.)
.TP
\fB0\fP
Circle over tha base character\&.
.TP
\fB2\fP
Hook over tha base character\&.
.TP
\fB9\fP
Horn over tha base character\&.
.PD
.PP
Da most common charactas from tha Arabic, Cyrillic, Greek n' Hebrew
alphabets is available; consult RFC 1345 fo' tha appropriate sequences\&.
In addition, a set of two letta codes not up in RFC 1345 is available for
the double\-width charactas correspondin ta ASCII charactas from \fB!\fP
to \fB~\fP (0x21 ta 0x7e) by precedin tha characta wit \fB^\fP, for
example \fB^A\fP fo' a thugged-out double\-width \fBA\fP\&.
.PP
Da followin other two\-characta sequences is understood\&.
.PP
.PD 0
.TP
.PD
ASCII characters
These is already present on most keyboards:
.PD 0
.TP
\fB<(\fP
Left square bracket
.TP
\fB//\fP
Backslash (solidus)
.TP
\fB)>\fP
Right square bracket
.TP
\fB(!\fP
Left brace (curly bracket)
.TP
\fB!!\fP
Vertical bar (pipe symbol)
.TP
\fB!)\fP
Right brace (curly bracket)
.TP
\fB\&'?\fP
Tilde
.PD
.TP
Special letters
Charactas found up in various variantz of tha Latin alphabet:
.PD 0
.TP
\fBss\fP
Eszett (scharfes S)
.TP
\fBD\-\fP, \fBd\-\fP
Eth
.TP
\fBTH\fP, \fBth\fP
Thorn
.TP
\fBkk\fP
Kra
.TP
\fB\&'n\fP
\&'n
.TP
\fBNG\fP, \fBng\fP
Ng
.TP
\fBOI\fP, \fBoi\fP
Oi
.TP
\fByr\fP
yr
.TP
\fBED\fP
ezh
.PD
.TP
Currency symbols
.PD 0
.TP
\fBCt\fP
Cent
.TP
\fBPd\fP
Pound sterlin (also lira n' others)
.TP
\fBCu\fP
Currency
.TP
\fBYe\fP
Yen
.TP
\fBEu\fP
Euro (N\&.B\&. not up in RFC 1345)
.PD
.TP
Punctuation characters
References ta "right" quotes indicate tha shape (like a 9 rather than 6)
rather than they grammatical use\&.  (For example, a "right" low double
quote is used ta open quotations up in German\&.)
.PD 0
.TP
\fB!I\fP
Inverted exclamation mark
.TP
\fBBB\fP
Broken vertical bar
.TP
\fBSE\fP
Section
.TP
\fBCo\fP
Copyright
.TP
\fB\-a\fP
Spanish feminine ordinal indicator
.TP
\fB<<\fP
Left guillemet
.TP
\fB\-\fP\fB\-\fP
Soft hyphen
.TP
\fBRg\fP
Registered trade mark
.TP
\fBPI\fP
Pilcrow (paragraph)
.TP
\fB\-o\fP
Spanish masculine ordinal indicator
.TP
\fB>>\fP
Right guillemet
.TP
\fB?I\fP
Inverted question mark
.TP
\fB\-1\fP
Hyphen
.TP
\fB\-N\fP
En dash
.TP
\fB\-M\fP
Em dash
.TP
\fB\-3\fP
Horizontal bar
.TP
\fB:3\fP
Vertical ellipsis
.TP
\fB\&.3\fP
Horizontal midline ellipsis
.TP
\fB!2\fP
Double vertical line
.TP
\fB=2\fP
Double low line
.TP
\fB\&'6\fP
Left single quote
.TP
\fB\&'9\fP
Right single quote
.TP
\fB\&.9\fP
"Right" low quote
.TP
\fB9\&'\fP
Reversed "right" quote
.TP
\fB"6\fP
Left double quote
.TP
\fB"9\fP
Right double quote
.TP
\fB:9\fP
"Right" low double quote
.TP
\fB9"\fP
Reversed "right" double quote
.TP
\fB/\-\fP
Dagger
.TP
\fB/=\fP
Double dagger
.PD
.TP
Mathematical symbols
.PD 0
.TP
\fBDG\fP
Degree
.TP
\fB\-2\fP, \fB+\-\fP, \fB\-+\fP
\- sign, +/\- sign, \-/+ sign
.TP
\fB2S\fP
Superscript 2
.TP
\fB3S\fP
Superscript 3
.TP
\fB1S\fP
Superscript 1
.TP
\fBMy\fP
Micro
.TP
\fB\&.M\fP
Middle dot
.TP
\fB14\fP
Quarter
.TP
\fB12\fP
Half
.TP
\fB34\fP
Three quarters
.TP
\fB*X\fP
Multiplication
.TP
\fB\-:\fP
Division
.TP
\fB%0\fP
Per mille
.TP
\fBFA\fP, \fBTE\fP, \fB/0\fP
For all, there exists, empty set
.TP
\fBdP\fP, \fBDE\fP, \fBNB\fP
Partial derivative, delta (increment), del
(nabla)
.TP
\fB(\-\fP, \fB\-)\fP
Element of, gotz nuff
.TP
\fB*P\fP, \fB+Z\fP
Product, sum
.TP
\fB*\-\fP, \fBOb\fP, \fBSb\fP
Asterisk, ring, bullet
.TP
\fBRT\fP, \fB0(\fP, \fB00\fP
Root sign, proportionizzle to, infinity
.PD
.TP
Other symbols
.PD 0
.TP
\fBcS\fP, \fBcH\fP, \fBcD\fP, \fBcC\fP
Card suits: spades, hearts, diamonds,
clubs
.TP
\fBMd\fP, \fBM8\fP, \fBM2\fP, \fBMb\fP, \fBMx\fP, \fBMX\fP
Musical notation:
crotchet (quarta note), quaver (eighth note), semiquavers (sixteenth
notes), flag sign, natural sign, sharp sign
.TP
\fBFm\fP, \fBMl\fP
Female, male
.PD
.TP
Accents on they own
.PD 0
.TP
\fB\&'>\fP
Circumflex (same as caret, \fB^\fP)
.TP
\fB\&'!\fP
Grave (same as backtick, \fB`\fP)
.TP
\fB\&',\fP
Cedilla
.TP
\fB\&':\fP
Diaeresis (Umlaut)
.TP
\fB\&'m\fP
Macron
.TP
\fB\&''\fP
Acute
.PD
.RE
.TP
\fBinsert\-files\fP
This function allows you type a gangbangin' file pattern, n' peep tha thangs up in dis biatch of the
expansion at each step\&.  When you hit return, all expansions is inserted
into tha command line\&.
.RS
.PP
.RS
.nf
\fBbindkey \&'^Xf' insert\-files\fP
.fi
.RE
.RE
.TP
\fBinsert\-unicode\-char\fP
When first executed, tha user inputs a set of hexadecimal digits\&.
This is terminated wit another call ta \fBinsert\-unicode\-char\fP\&.
Da digits is then turned tha fuck into tha correspondin Unicode character\&.
For example, if tha widget is bound ta \fB^XU\fP, tha characta sequence
`\fB^XU 4 c ^XU\fP\&' bangs \fBL\fP (Unicode U+004c)\&.
.RS
.PP
See \fBinsert\-composed\-char\fP fo' a way of insertin characters
usin a two\-characta mnemonic\&.
.RE
.TP
.PD 0
\fBnarrow\-to\-region [ \-p\fP \fIpre\fP \fB] [ \-P\fP \fIpost\fP \fB]\fP
.TP
.PD 0
    \fB[ \-S\fP \fIstatepm\fP \fB| \-R\fP \fIstatepm\fP \fB] [ \-n ] [\fP \fIstart\fP \fIend\fP \fB]\fP)
.TP
.PD
\fBnarrow\-to\-region\-invisible\fP
Narrow tha editable portion of tha buffer ta tha region between tha cursor
and tha mark, which may be up in either order\&.  Da region may not be empty\&.
.RS
.PP
\fBnarrow\-to\-region\fP may be used as a widget or called as a gangbangin' function from a
user\-defined widget; by default, tha text outside tha editable area remains
visible\&.  A \fBrecursive\-edit\fP is performed n' tha original gangsta widening
status is then restored\&.  Various options n' arguments is available when
it is called as a gangbangin' function\&.
.PP
Da options \fB\-p\fP \fIpretext\fP n' \fB\-P\fP \fIposttext\fP may be
used ta replace tha text before n' afta tha display fo' tha duration of
the function; either or both may be a empty string\&.
.PP
If tha option \fB\-n\fP be also given, \fIpretext\fP or \fIposttext\fP will only
be banged if there is text before or afta tha region respectively which
will be made invisible\&.
.PP
Two numeric arguments may be given which is ghon be used instead of tha cursor
and mark positions\&.
.PP
Da option \fB\-S\fP \fIstatepm\fP is used ta narrow accordin ta tha other
options while savin tha original gangsta state up in tha parameta wit name
\fIstatepm\fP, while tha option \fB\-R\fP \fIstatepm\fP is used ta restore the
state from tha parameter; note up in both cases tha \fIname\fP of tha parameter
is required\&.  In tha second case, other options n' arguments are
irrelevant\&.  When dis method is used, no \fBrecursive\-edit\fP is performed;
the callin widget should call dis function wit tha option \fB\-S\fP,
perform its own editin on tha command line or pass control ta tha user
via `\fBzle recursive\-edit\fP\&', then call dis function wit tha option
\fB\-R\fP\&.  Da argument \fIstatepm\fP must be a suitable name fo' a ordinary
parameter, except dat parametas beginnin wit tha prefix \fB_ntr_\fP are
reserved fo' use within \fBnarrow\-to\-region\fP\&.  Typically tha parameta will
be local ta tha callin function\&.
.PP
\fBnarrow\-to\-region\-invisible\fP be a simple widget which calls
\fBnarrow\-to\-region\fP wit arguments which replace any text outside the
region wit `\fB\&.\&.\&.\fP\&'\&.
.PP
Da display is restored (and tha widget returns) upon any zle command
which would probably cause tha line ta be accepted or aborted\&.  Hence an
additionizzle such command is required ta accept or abort tha current line\&.
.PP
Da return statuz of both widgets is zero if tha line was accepted, else
non\-zero\&.
.PP
Here be a trivial example of a widget rockin dis feature\&.
.RS
.nf
\fBlocal state
narrow\-to\-region \-p $\&'Editin restricted region\en' \e 
  \-P \&'' \-S state
zle recursive\-edit
narrow\-to\-region \-R state\fP
.fi
.RE
.RE
.TP
\fBpredict\-on\fP
This set of functions implements predictizzle typin rockin history search\&.
Afta \fBpredict\-on\fP, typin charactas causes tha editor ta look backward
in tha history fo' tha straight-up original gangsta line beginnin wit what tha fuck you have typed so
far\&.  Afta \fBpredict\-off\fP, editin returns ta aiiight fo' tha line found\&.
In fact, you often don\&'t even need ta use \fBpredict\-off\fP, cuz if the
line don\&'t match suttin' up in tha history, addin a key performs
standard completion, n' then bangs itself if no completions was found\&.
But fuck dat shiznit yo, tha word on tha street is dat editin up in tha middle of a line is liable ta confuse prediction;
see tha \fBtoggle\fP steez below\&.
.RS
.PP
With tha function based completion system (which is needed fo' this), you
should be able ta type \fBTAB\fP at almost any point ta advizzle tha cursor
to tha next ``interesting\&'' characta posizzle (usually tha end of the
current word yo, but sometimes somewhere up in tha middle of tha word)\&.  And of
course as soon as tha entire line is what tha fuck you want, you can accept with
return, without needin ta move tha cursor ta tha end first\&.
.PP
Da last time \fBpredict\-on\fP is used, it creates nuff muthafuckin additional
widget functions:
.PP
.PD 0
.TP
\fBdelete\-backward\-and\-predict\fP
Replaces tha \fBbackward\-delete\-char\fP
widget\&.  Yo ass do not need ta bind dis yo ass\&.
.TP
\fBinsert\-and\-predict\fP
Implements predictizzle typin by replacin the
\fBself\-insert\fP widget\&.  Yo ass do not need ta bind dis yo ass\&.
.TP
\fBpredict\-off\fP
Turns off predictizzle typing\&.
.PD
.PP
Although you \fBautoload\fP only tha \fBpredict\-on\fP function, it is
necessary ta create a keybindin fo' \fBpredict\-off\fP as well\&.
.PP
.RS
.nf
\fBzle \-N predict\-on
zle \-N predict\-off
bindkey \&'^X^Z' predict\-on
bindkey \&'^Z' predict\-off\fP
.fi
.RE
.RE
.TP
\fBread\-from\-minibuffer\fP
This is most useful when called as a gangbangin' function from inside a widget yo, but will
work erectly as a widget up in its own right\&.  It prompts fo' a value
below tha current command line; a value may be input rockin all of the
standard zle operations (and not merely tha restricted set available
when executing, fo' example, \fBexecute\-named\-cmd\fP)\&.  Da value is then
returned ta tha callin function up in tha parameta \fB$REPLY\fP n' the
editin buffer restored ta its previous state\&.  If tha read was aborted
by a keyboard break (typically \fB^G\fP), tha function returns status 1
and \fB$REPLY\fP aint set\&.
.RS
.PP
If one argument is supplied ta tha function it is taken as a prompt,
otherwise `\fB, biatch? \fP\&' is used\&.  If two arguments is supplied, they is the
prompt n' tha initial value of \fB$LBUFFER\fP, n' if a third argument is
given it is tha initial value of \fB$RBUFFER\fP\&.  This serves up a thugged-out default
value n' startin cursor placement\&.  Upon return tha entire buffer is the
value of \fB$REPLY\fP\&.
.PP
One option be available: `\fB\-k\fP \fInum\fP\&' specifies dat \fInum\fP
charactas is ta be read instead of a whole line\&.  Da line editor is not
invoked recursively up in dis case, so dependin on tha terminal settings
the input may not be visible, n' only tha input keys is placed in
\fB$REPLY\fP, not tha entire buffer\&.  Note dat unlike tha \fBread\fP builtin
\fInum\fP must be given; there is no default\&.
.PP
Da name be a slight misnomer, as up in fact tha shell\&z own minibuffer is
not used\&.  Hence it is still possible ta booty-call \fBexecuted\-named\-cmd\fP and
similar functions while readin a value\&.
.RE
.TP
\fBreplace\-argument\fP, \fBreplace\-argument\-edit\fP
Da function \fBreplace\-argument\fP can be used ta replace a cold-ass lil command
line argument up in tha current command line or, if tha current command
line is empty, up in tha last command line executed (the freshly smoked up command line
is not executed)\&.  Arguments is as delimited by standard shell syntax,
.RS
.PP
If a numeric argument is given, dat specifies tha argument ta be
replaced\&.  0 means tha command name, as up in history expansion\&.
A wack numeric argument counts backward from tha last word\&.
.PP
If no numeric argument is given, tha current argument is replaced;
this is tha last argument if tha previous history line is bein used\&.
.PP
Da function prompts fo' a replacement argument\&.
.PP
If tha widget gotz nuff tha strang \fBedit\fP, fo' example is defined as
.PP
.RS
.nf
\fBzle \-N replace\-argument\-edit replace\-argument\fP
.fi
.RE
.PP
then tha function presents tha current value of tha argument for
editing, otherwise tha editin buffer fo' tha replacement is
initially empty\&.
.RE
.TP
.PD 0
\fBreplace\-string\fP, \fBreplace\-pattern\fP
.TP
.PD
\fBreplace\-string\-again\fP, \fBreplace\-pattern\-again\fP
Da function \fBreplace\-string\fP implements three widgets\&.
If defined under tha same name as tha function, it prompts fo' two
strings; tha straight-up original gangsta (source) strang is ghon be replaced by tha second
everywhere it occurs up in tha line editin buffer\&.
.RS
.PP
If tha widget name gotz nuff tha word `\fBpattern\fP\&', fo' example by
definin tha widget rockin tha command `\fBzle \-N replace\-pattern
replace\-string\fP\&', then tha matchin is performed rockin zsh patterns\&.  All
zsh extended globbin patterns can be used up in tha source string; note
that unlike filename generation tha pattern do not need ta match an
entire word, nor do glob qualifiers have any effect\&.  In addition, the
replacement strang can contain parameta or command substitutions\&.
Furthermore, a `\fB&\fP\&' up in tha replacement strang is ghon be replaced with
the matched source string, n' a funky-ass backquoted digit `\fB\e\fP\fIN\fP\&' will be
replaced by tha \fIN\fPth parenthesised expression matched\&.  Da form
`\fB\e{\fP\fIN\fP\fB}\fP\&' may be used ta protect tha digit from following
digits\&.
.PP
If tha widget instead gotz nuff tha word `\fBregex\fP\&' (or `\fBregexp\fP'),
then tha matchin is performed rockin regular expressions, respecting
the settin of tha option \fBRE_MATCH_PCRE\fP (see tha description of the
function \fBregexp\-replace\fP below)\&.  Da special replacement facilities
busted lyrics bout above fo' pattern matchin is available\&.
.PP
By default tha previous source or replacement strang aint gonna be offered
for editing\&.  But fuck dat shiznit yo, tha word on tha street is dat dis feature can be activated by settin tha style
\fBedit\-previous\fP up in tha context \fB:zle:\fP\fIwidget\fP (for example,
\fB:zle:replace\-string\fP) ta \fBtrue\fP\&.  In addition, a positive
numeric argument forces tha previous joints ta be offered, a wack or
zero argument forces dem not ta be\&.
.PP
Da function \fBreplace\-string\-again\fP can be used ta repeat tha previous
replacement; no promptin is done\&.  As wit \fBreplace\-string\fP, if tha name
of tha widget gotz nuff tha word `\fBpattern\fP\&' or `\fBregex\fP', pattern or
regular expression matchin is performed, else a literal string
replacement\&.  Note dat tha previous source n' replacement text is the
same whether pattern, regular expression or strang matchin is used\&.
.PP
In addition, \fBreplace\-string\fP shows tha previous replacement above
the prompt, so long as there was one durin tha current session; if the
source strang is empty, dat replacement is ghon be repeated without
the widget promptin fo' a replacement string\&.
.PP
For example, startin from tha line:
.PP
.RS
.nf
\fBprint This line gotz nuff hustla n' fond\fP
.fi
.RE
.PP
and invokin \fBreplace\-pattern\fP wit tha source string
`\fBf(?)n\fP\&' and
the replacement strang `\fBc\e1r\fP\&' produces tha not straight-up useful line:
.PP
.RS
.nf
\fBprint This line gotz nuff hoopty n' cord\fP
.fi
.RE
.PP
Da range of tha replacement strang can be limited by rockin the
\fBnarrow\-to\-region\-invisible\fP widget\&.  One limitation of tha current
version is dat \fBundo\fP will cycle all up in chizzlez ta tha replacement
and source strings before unfuckin wit tha replacement itself\&.
.RE
.TP
\fBsend\-invisible\fP
This is similar ta read\-from\-minibuffer up in dat it may be called as a
function from a widget or as a widget of its own, n' interactively reads
input from tha keyboard\&.  But fuck dat shiznit yo, tha word on tha street is dat tha input bein typed is concealed and
a strang of asterisks (`\fB*\fP\&') is shown instead\&.  Da value is saved in
the parameta \fB$INVISIBLE\fP ta which a reference is banged tha fuck into the
editin buffer all up in tha restored cursor position\&.  If tha read was aborted
by a keyboard break (typically \fB^G\fP) or another escape from editin such
as \fBpush\-line\fP, \fB$INVISIBLE\fP is set ta empty n' tha original gangsta buffer
is restored unchanged\&.
.RS
.PP
If one argument is supplied ta tha function it is taken as a prompt,
otherwise `\fBNon\-echoed text: \fP\&' is used (as up in emacs)\&.  If a second and
third argument is supplied they is used ta begin n' end tha reference
to \fB$INVISIBLE\fP dat is banged tha fuck into tha buffer\&.  Da default is to
open wit \fB${\fP, then \fBINVISIBLE\fP, n' close wit \fB}\fP yo, but many
other effects is possible\&.
.RE
.TP
\fBsmart\-insert\-last\-word\fP
This function may replace tha \fBinsert\-last\-word\fP widget, like so:
.RS
.PP
.RS
.nf
\fBzle \-N insert\-last\-word smart\-insert\-last\-word\fP
.fi
.RE
.PP
With a numeric prefix, or when passed command line arguments up in a cold-ass lil call
from another widget, it behaves like \fBinsert\-last\-word\fP, except that
wordz up in comments is ignored when \fBINTERACTIVE_COMMENTS\fP is set\&.
.PP
Otherwise, tha rightmost ``interesting\&'' word from tha previous command is
found n' inserted\&.  Da default definizzle of ``interesting\&'' is dat the
word gotz nuff at least one alphabetic character, slash, or backslash\&.
This definizzle may be overridden by use of tha \fBmatch\fP style\&.  The
context used ta look up tha steez is tha widget name, so probably the
context is \fB:insert\-last\-word\fP\&.  But fuck dat shiznit yo, tha word on tha street is dat you can bind dis function to
different widgets ta use different patterns:
.PP
.RS
.nf
\fBzle \-N insert\-last\-assignment smart\-insert\-last\-word
zstyle :insert\-last\-assignment match \&'[[:alpha:]][][[:alnum:]]#=*'
bindkey \&'\ee=' insert\-last\-assignment\fP
.fi
.RE
.PP
If no bangin-ass word is found n' tha \fBauto\-previous\fP steez is set to
a legit value, tha search continues upward all up in tha history\&.  When
\fBauto\-previous\fP is unset or false (the default), tha widget must be
invoked repeatedly up in order ta search earlier history lines\&.
.RE
.TP
\fBtranspose\-lines\fP
Only useful wit a multi\-line editin buffer; tha lines here are
lines within tha current on\-screen buffer, not history lines\&.
Da effect is similar ta tha function of tha same name up in Emacs\&.
.RS
.PP
Transpose tha current line wit tha previous line n' move tha cursor
to tha start of tha next line\&.  Repeatin dis (which can be done by
providin a positizzle numeric prefix argument) has tha effect of moving
the line above tha cursor down by a fuckin shitload of lines\&.
.PP
With a wack numeric prefix argument, requires two lines above the
cursor\&.  These two lines is transposed n' tha cursor moved ta the
start of tha previous line\&.  Usin a numeric prefix less than \-1
has tha effect of movin tha line above tha cursor up by minus that
number of lines\&.
.RE
.TP
\fBwhich\-command\fP
This function be a thugged-out drop\-in replacement fo' tha builtin widget
\fBwhich\-command\fP\&.  It has enhanced behaviour, up in dat it erectly
detects whether or not tha command word need ta be expanded as an
alias; if so, it continues tracin tha command word from tha expanded
alias until it reaches tha command dat is ghon be executed\&.
.RS
.PP
Da steez \fBwhence\fP be available up in tha context \fB:zle:$WIDGET\fP; this
may be set ta a array ta give tha command n' options dat is ghon be used to
investigate tha command word found\&.  Da default is \fBwhence \-c\fP\&.
.RE
.TP
\fBzcalc\-auto\-insert\fP
This function is useful together wit tha \fBzcalc\fP function busted lyrics bout in
the section Mathematical Functions\&.
It should be bound ta a key representin a funky-ass binary operator such
as `\fB+\fP\&', `\fB\-\fP', `\fB*\fP' or `\fB/\fP'\&.  When hustlin up in zcalc,
if tha key occurs all up in tha start of tha line or immediately following
an open parenthesis, tha text \fB"ans "\fP is banged before the
representation of tha key itself\&.  This allows easy as fuck  use of the
answer from tha previous calculation up in tha current line\&.  The
text ta be banged before tha symbol typed can be modified by setting
the variable \fBZCALC_AUTO_INSERT_PREFIX\fP\&.
.RS
.PP
Hence, fo' example, typin `\fB+12\fP\&' followed by return addz 12
to tha previous result\&.
.PP
When not up in zcalc, tha key simply bangs tha symbol itself\&.
.RE
.PP
.SS "Utilitizzle Functions"
.PP
These functions is useful up in constructin widgets\&.  They
should be loaded wit `\fBautoload \-U\fP \fIfunction\fP\&' n' called
as indicated from user\-defined widgets\&.
.PP
.PD 0
.TP
.PD
\fBsplit\-shell\-arguments\fP
This function splits tha line currently bein edited tha fuck into shell arguments
and whitespace\&.  Da result is stored up in tha array \fBreply\fP\&.  Da array
gotz nuff all tha partz of tha line up in order, startin wit any whitespace
before tha straight-up original gangsta argument, n' finishin wit any whitespace afta tha last
argument\&.  Hence (so long as tha option \fBKSH_ARRAYS\fP aint set)
whitespace is given by odd indices up in tha array n' arguments by
even indices\&.  Note dat no strippin of quotes is done; joinin together
all tha elementz of \fBreply\fP up in order is guaranteed ta produce the
original gangsta line\&.
.RS
.PP
Da parameta \fBREPLY\fP is set ta tha index of tha word up in \fBreply\fP which
gotz nuff tha characta afta tha cursor, where tha straight-up original gangsta element has index
1\&.  Da parameta \fBREPLY2\fP is set ta tha index of tha characta under the
cursor up in dat word, where tha straight-up original gangsta characta has index 1\&.
.PP
Hence \fBreply\fP, \fBREPLY\fP n' \fBREPLY2\fP should all be made local to
the enclosin function\&.
.PP
See tha function \fBmodify\-current\-argument\fP, busted lyrics bout below, for
an example of how tha fuck ta booty-call dis function\&.
.RE
.TP
\fBmodify\-current\-argument\fP [ \fIexpr\-using\-\fP\fB$ARG\fP | \fIfunc\fP ]
This function serves up a simple method of allowin user\-defined widgets
to modify tha command line argument under tha cursor (or immediately ta the
left of tha cursor if tha cursor is between arguments)\&.
.RS
.PP
Da argument can be a expression which when evaluated operates on tha shell
parameta \fBARG\fP, which gonna git been set ta tha command line argument
under tha cursor\&.  Da expression should be suitably quoted ta prevent
it bein evaluated too early\&.
.PP
Alternatively, if tha argument do not contain tha strang \fBARG\fP, it
is assumed ta be a gangbangin' finger-lickin' dirty-ass shell function, ta which tha current command line
argument is passed as tha only argument\&.  Da function should set the
variable \fBREPLY\fP ta tha freshly smoked up value fo' tha command line argument\&.
If tha function returns non\-zero status, so do tha callin function\&.
.PP
For example, a user\-defined widget containin tha followin code
converts tha charactas up in tha argument under tha cursor tha fuck into all upper
case:
.PP
.RS
.nf
\fBmodify\-current\-argument \&'${(U)ARG}'\fP
.fi
.RE
.PP
Da followin strips any quotin from tha current word (whether backslashes
or one of tha stylez of quotes), n' replaces it wit single quoting
throughout:
.PP
.RS
.nf
\fBmodify\-current\-argument \&'${(qq)${(Q)ARG}}'\fP
.fi
.RE
.PP
Da followin performs directory expansion on tha command line
argument n' replaces it by tha absolute path:
.PP
.RS
.nf
\fBexpand\-dir() {
  REPLY=${~1}
  REPLY=${REPLY:a}
}
modify\-current\-argument expand\-dir\fP
.fi
.RE
.PP
In practice tha function \fBexpand\-dir\fP would probably not be defined
within tha widget where \fBmodify\-current\-argument\fP is called\&.
.RE
.PP
.SS "Styles"
.PP
Da behavior of nuff muthafuckin of tha above widgets can be controlled by tha use
of tha \fBzstyle\fP mechanism\&.  In particular, widgets dat interact with
the completion system pass along they context ta any completions that
they invoke\&.
.PP
.PD 0
.TP
.PD
\fBbreak\-keys\fP
This steez is used by tha \fBincremental\-complete\-word\fP widget\&. Its value
should be a pattern, n' all keys matchin dis pattern will cause the
widget ta stop incremenstrual completion without tha key havin any further
effect\&. Like all stylez used directly by
\fBincremental\-complete\-word\fP, dis steez is looked up rockin the
context `\fB:incremental\fP\&'\&.
.TP
\fBcompleter\fP
Da \fBincremental\-complete\-word\fP n' \fBinsert\-and\-predict\fP widgets set
up they top\-level context name before callin completion\&.  This allows
one ta define different setz of completa functions fo' aiiight completion
and fo' these widgets\&.  For example, ta use completion, approximation and
correction fo' aiiight completion, completion n' erection for
incremenstrual completion n' only completion fo' prediction one could use:
.RS
.PP
.RS
.nf
\fBzstyle \&':completion:*' completa \e 
        _complete _correct _approximate
zstyle \&':completion:incremental:*' completa \e 
        _complete _correct
zstyle \&':completion:predict:*' completa \e 
        _complete\fP
.fi
.RE
.PP
It be a phat scam ta restrict tha completas used up in prediction, cuz
they may be automatically invoked as you type\&.  Da \fB_list\fP and
\fB_menu\fP completas should never be used wit prediction\&.  The
\fB_approximate\fP, \fB_correct\fP, \fB_expand\fP, n' \fB_match\fP completas may
be used yo, but be aware dat they may chizzle charactas anywhere up in tha word
behind tha cursor, so you need ta peep carefully dat tha result is what
you intended\&.
.RE
.TP
\fBcursor\fP
Da \fBinsert\-and\-predict\fP widget uses dis style, up in tha context
`\fB:predict\fP\&', ta decizzle where ta place tha cursor afta completion has
been tried\&.  Values are:
.RS
.PP
.PD 0
.TP
.PD
\fBcomplete\fP
Da cursor is left where dat shiznit was when completion finished yo, but only if
it be afta a cold-ass lil characta equal ta tha one just banged by tha user\&.  If 
it be afta another character, dis value is tha same ol' dirty as `\fBkey\fP\&'\&.
.TP
\fBkey\fP
Da cursor is left
afta tha \fIn\fPth occurrence of tha characta just inserted, where
\fIn\fP is tha number of times dat characta rocked up in tha word
before completion was attempted\&.  In short, dis has tha effect of
leavin tha cursor afta tha characta just typed even if the
completion code found up dat no other charactas need ta be banged 
at dat position\&.
.PP
Any other value fo' dis steez unconditionally leaves tha cursor at the
posizzle where tha completion code left it\&.
.RE
.TP
\fBlist\fP
When rockin tha \fBincremental\-complete\-word\fP widget, dis steez says
if tha matches should be listed on every last muthafuckin key press (if they fit on tha 
screen)\&.  Use tha context prefix `\fB:completion:incremental\fP\&'\&.
.RS
.PP
Da \fBinsert\-and\-predict\fP widget uses dis steez ta decizzle if the
completion should be shown even if there is only one possible completion\&.
This is done if tha value of dis steez is tha strang \fBalways\fP\&.  In this
case tha context is `\fB:predict\fP\&' (\fInot\fP `\fB:completion:predict\fP')\&.
.RE
.TP
\fBmatch\fP
This steez is used by \fBsmart\-insert\-last\-word\fP ta provide a pattern
(usin full \fBEXTENDED_GLOB\fP syntax) dat matches a bangin-ass word\&.
Da context is tha name of tha widget ta which \fBsmart\-insert\-last\-word\fP
is bound (see above)\&.  Da default behavior of \fBsmart\-insert\-last\-word\fP
is equivalent to:
.RS
.PP
.RS
.nf
\fBzstyle :insert\-last\-word match \&'*[[:alpha:]/\e\e]*'\fP
.fi
.RE
.PP
But fuck dat shiznit yo, tha word on tha street is dat you might wanna include lyrics dat contain spaces:
.PP
.RS
.nf
\fBzstyle :insert\-last\-word match \&'*[[:alpha:][:space:]/\e\e]*'\fP
.fi
.RE
.PP
Or include numbers as long as tha word be at least two charactas long:
.PP
.RS
.nf
\fBzstyle :insert\-last\-word match \&'*([[:digit:]]?|[[:alpha:]/\e\e])*'\fP
.fi
.RE
.PP
Da above example causes redirections like "2>" ta be included\&.
.RE
.TP
\fBprompt\fP
Da \fBincremental\-complete\-word\fP widget shows tha value of this
style up in tha status line durin incremenstrual completion\&.  Da string
value may contain any of tha followin substrings up in tha manner of
the \fBPS1\fP n' other prompt parameters:
.RS
.PP
.PD 0
.TP
.PD
\fB%c\fP
Replaced by tha name of tha completa function dat generated the
matches (without tha leadin underscore)\&.
.TP
\fB%l\fP
When tha \fBlist\fP steez is set,
replaced by `\fB\&.\&.\&.\fP\&' if tha list of matches is too long ta fit on the
screen n' wit a empty strang otherwise\&.  If tha \fBlist\fP steez is
`false\&' or not set, `\fB%l\fP' be always removed\&.
.TP
\fB%n\fP
Replaced by tha number of matches generated\&.
.TP
\fB%s\fP
Replaced by `\fB\-no match\-\fP\&', `\fB\-no prefix\-\fP', or a empty string
if there is no completion matchin tha word on tha line, if the
matches have no common prefix different from tha word on tha line, or
if there is such a cold-ass lil common prefix, respectively\&.
.TP
\fB%u\fP
Replaced by tha unambiguous part of all matches, if there
is any, n' if it is different from tha word on tha line\&.
.PP
Like `\fBbreak\-keys\fP\&', dis uses tha `\fB:incremental\fP' context\&.
.RE
.TP
\fBstop\-keys\fP
This steez is used by tha \fBincremental\-complete\-word\fP widget\&.  Its value
is treated similarly ta tha one fo' tha \fBbreak\-keys\fP steez (and uses 
the same context: `\fB:incremental\fP\&')\&.  But fuck dat shiznit yo, tha word on tha street is dat in
this case all keys matchin tha pattern given as its value will stop
incremenstrual completion n' will then execute they usual function\&.
.TP
\fBtoggle\fP
This boolean steez is used by \fBpredict\-on\fP n' its related widgets in
the context `\fB:predict\fP\&'\&.  If set ta one of tha standard `true' joints,
predictizzle typin be automatically toggled off up in thangs where it is
unlikely ta be useful, like fuckin when editin a multi\-line buffer or after
movin tha fuck into tha middle of a line n' then deletin a cold-ass lil character\&.  The
default is ta leave prediction turned on until a explicit call to
\fBpredict\-off\fP\&.
.TP
\fBverbose\fP
This boolean steez is used by \fBpredict\-on\fP n' its related widgets in
the context `\fB:predict\fP\&'\&.  If set ta one of tha standard `true' joints,
these widgets display a message below tha prompt when tha predictizzle state
is toggled\&.  This is most useful up in combination wit tha \fBtoggle\fP style\&.
Da default do not display these lyrics\&.
.TP
\fBwidget\fP
This steez is similar ta tha \fBcommand\fP style: For widget functions that
use \fBzle\fP ta booty-call other widgets, dis steez can sometimes be used to
override tha widget which is called\&.  Da context fo' dis steez is the
name of tha callin widget (\fInot\fP tha name of tha callin function,
because one function may be bound ta multiple widget names)\&.
.RS
.PP
.RS
.nf
\fBzstyle :copy\-earlier\-word widget smart\-insert\-last\-word\fP
.fi
.RE
.PP
Peep tha documentation fo' tha callin widget or function ta determine
whether tha \fBwidget\fP steez is used\&.
.RE
.PP
.SH "EXCEPTION HANDLING"
.PP
Two functions is provided ta enable zsh ta provide exception handlin up in a
form dat should be familiar from other languages\&.
.PP
.PD 0
.TP
.PD
\fBthrow\fP \fIexception\fP
Da function \fBthrow\fP throws tha named \fIexception\fP\&.  Da name is
an arbitrary strang n' is only used by tha \fBthrow\fP n' \fBcatch\fP
functions\&.  An exception is fo' da most thugged-out part treated tha same as a
shell error, i\&.e\&. a unhandled exception will cause tha shell ta abort all
processin up in a gangbangin' function or script n' ta return ta tha top level up in an
interactizzle shell\&.
.TP
\fBcatch\fP \fIexception\-pattern\fP
Da function \fBcatch\fP returns status zero if a exception was thrown and
the pattern \fIexception\-pattern\fP matches its name\&.  Otherwise it
returns status 1\&.  \fIexception\-pattern\fP be a standard
shell pattern, respectin tha current settin of tha \fBEXTENDED_GLOB\fP
option\&.  An alias \fBcatch\fP be also defined ta prevent tha argument ta the
function from matchin filenames, so patterns may be used unquoted\&.  Note
that as exceptions is not fundamentally different from other shell errors
it is possible ta catch shell errors by rockin a empty strang as the
exception name\&.  Da shell variable \fBCAUGHT\fP is set by \fBcatch\fP ta the
name of tha exception caught\&.  It be possible ta rethrow a exception by
callin tha \fBthrow\fP function again n' again n' again once a exception has been caught\&.
.PP
Da functions is designed ta be used together wit tha \fBalways\fP construct
busted lyrics bout in
\fIzshmisc\fP(1)\&.  This is blingin as only this
construct serves up tha required support fo' exceptions\&.  A typical example
is as bigs up\&.
.PP
.RS
.nf
\fB{
  # "try" block
  # \&.\&.\&. nested code here calls "throw MyExcept"
} always {
  # "always" block
  if catch MyExcept; then
    print "Caught exception MyExcept"
  elif catch \&''; then
    print "Caught a gangbangin' finger-lickin' dirty-ass shell error\&.  Propagating\&.\&.\&."
    throw \&''
  fi
  # Other exceptions is not handled but may be caught further
  # up tha call stack\&.
}\fP
.fi
.RE
.PP
If all exceptions should be caught, tha followin idiom might be
preferable\&.
.PP
.RS
.nf
\fB{
  # \&.\&.\&. nested code here throws a exception
} always {
  if catch *; then
    case $CAUGHT in
      (MyExcept)
      print "Caught mah own exception"
      ;;
      (*)
      print "Caught some other exception"
      ;;
    esac
  fi
}\fP
.fi
.RE
.PP
In common wit exception handlin up in other languages, tha exception may be
thrown by code deeply nested inside tha `try\&' block\&.  But fuck dat shiznit yo, tha word on tha street is dat note dat it
must be thrown inside tha current shell, not up in a subshell forked fo' a
pipeline, parenthesised current\-shell construct, or some form of
command or process substitution\&.
.PP
Da system internally uses tha shell variable \fBEXCEPTION\fP ta record the
name of tha exception between throwin n' catching\&.  One drawback of this
scheme is dat if tha exception aint handled tha variable \fBEXCEPTION\fP
remains set n' may be incorrectly recognised as tha name of a exception
if a gangbangin' finger-lickin' dirty-ass shell error subsequently occurs\&.  Addin \fBunset EXCEPTION\fP at the
start of tha outermost layer of any code dat uses exception handlin will
eliminizzle dis problem\&.
.PP
.SH "MIME FUNCTIONS"
.PP
Three functions is available ta provide handlin of filez recognised by
extension, fo' example ta dispatch a gangbangin' file \fBtext\&.ps\fP when executed as a
command ta a appropriate viewer\&.
.PP
.PD 0
.TP
.PD 0
\fBzsh\-mime\-setup\fP [ \fB\-fv\fP ] [ \fB\-l\fP [ \fIsuffix \&.\&.\&.\fP ] ]
.TP
.PD
\fBzsh\-mime\-handlez [\-l] \fIcommand arguments \&.\&.\&.\fP\fP
These two functions use tha filez \fB~/\&.mime\&.types\fP n' \fB/etc/mime\&.types\fP,
which associate types n' extensions, as well as \fB~/\&.mailcap\fP and
\fB/etc/mailcap\fP files, which associate types n' tha programs that
handle them\&.  These is provided on nuff systems wit tha Multimedia
Internizzle Mail Extensions\&.
.RS
.PP
To enable tha system, tha function \fBzsh\-mime\-setup\fP should be
autoloaded n' run\&.  This allows filez wit extensions ta be treated
as executable; such filez be completed by tha function completion system\&.
Da function \fBzsh\-mime\-handlez\fP should not need ta be called by the
user\&.
.PP
Da system works by settin up suffix aliases wit `\fBalias \-s\fP\&'\&.
Suffix aliases already installed by tha user aint gonna be overwritten\&.
.PP
For suffixes defined up in lower case, upper case variants will also
automatically be handled (e\&.g\&. \fBPDF\fP be automatically handled if
handlin fo' tha suffix \fBpdf\fP is defined) yo, but not vice versa\&.
.PP
Repeated calls ta \fBzsh\-mime\-setup\fP do not override tha existing
mappin between suffixes n' executable filez unless tha option \fB\-f\fP
is given\&.  Note, however, dat dis do not override existin suffix
aliases assigned ta handlezs other than \fBzsh\-mime\-handlez\fP\&.
.PP
Callin \fBzsh\-mime\-setup\fP wit tha option \fB\-l\fP lists tha existing
mappings without alterin them\&.  Suffixes ta list (which may contain
pattern charactas dat should be quoted from immediate interpretation
on tha command line) may be given as additionizzle arguments, otherwise
all suffixes is listed\&.
.PP
Callin \fBzsh\-mime\-setup\fP wit tha option
\fB\-v\fP causes verbose output ta be shown durin tha setup operation\&.
.PP
Da system respects tha \fBmailcap\fP flags \fBneedsterminal\fP and
\fBcopiousoutput\fP, peep \fImailcap\fP(4)\&.
.PP
Da functions use tha followin styles, which is defined wit the
\fBzstyle\fP builtin command (see \fIzshmodules\fP(1))\&.  They should be defined
before \fBzsh\-mime\-setup\fP is run\&.  Da contexts used all
start wit \fB:mime:\fP, wit additionizzle components up in some cases\&.
It be recommended dat a trailin \fB*\fP (suitably quoted) be appended
to steez patterns up in case tha system is extended up in future\&.  Some
examplez is given below\&.
.PP
For filez dat have multiple suffixes, e\&.g\&. \fB\&.pdf\&.gz\fP, where the
context includes tha suffix it is ghon be looked up startin wit the
longest possible suffix until a match fo' tha steez is found\&.
For example, if \fB\&.pdf\&.gz\fP produces a match fo' tha handlez, that
will be used; otherwise tha handlez fo' \fB\&.gz\fP is ghon be used\&.  Note
that, owin ta tha way suffix aliases work, it be always required that
there be a handlez fo' tha shortest possible suffix, so up in dis example
\fB\&.pdf\&.gz\fP can only be handled if \fB\&.gz\fP be also handled (though
not necessarily up in tha same way)\&.  Alternatively, if no handling
for \fB\&.gz\fP on its own is needed, simply addin tha command
.PP
.RS
.nf
\fBalias \-s gz=zsh\-mime\-handlez\fP
.fi
.RE
.PP
to tha initialisation code is sufficient; \fB\&.gz\fP aint gonna be handled
on its own yo, but may be up in combination wit other suffixes\&.
.PP
.PD 0
.TP
.PD
\fBcurrent\-shell\fP
If dis boolean steez is true, tha mailcap handlez fo' tha context in
question is run rockin tha \fBeval\fP builtin instead of by startin a new
\fBsh\fP process\&.  This is mo' efficient yo, but may not work up in tha occasional
cases where tha mailcap handlez uses strict POSIX syntax\&.
.TP
\fBdisown\fP
If dis boolean steez is true, mailcap handlezs started up in the
background is ghon be disowned, i\&.e\&. not subject ta thang control within
the parent shell\&.  Such handlezs nearly always produce they own
windows, so tha only likely harmful side effect of settin tha steez is
that it becomes harder ta bust a cap up in thangs from within tha shell\&.
.TP
\fBexecute\-as\-is\fP
This steez gives a list of patterns ta be matched against files
passed fo' execution wit a handlez program\&.  If tha file matches
the pattern, tha entire command line is executed up in its current form,
with no handlez\&.  This is useful fo' filez which might have suffixes
but nonetheless be executable up in they own right\&.  If tha style
is not set, tha pattern \fB*(*) *(/)\fP is used;
hence executable filez is executed directly n' not passed ta a
handlez, n' tha option \fBAUTO_CD\fP may be used ta chizzle ta directories
that happen ta have MIME suffixes\&.
.TP
\fBexecute\-never\fP
This steez is useful up in combination wit \fBexecute\-as\-is\fP\&.  It is
set ta a array of patterns correspondin ta full paths ta filez that
should never be treated as executable, even if tha file passed to
the MIME handlez matches \fBexecute\-as\-is\fP\&.  This is useful fo' file
systems dat don\&'t handle execute permission or dat contain executables
from another operatin system\&.  For example, if \fB/mnt/windows\fP be a
Windows mount, then
.RS
.PP
.RS
.nf
\fBzstyle \&':mime:*' execute\-never '/mnt/windows/*'\fP
.fi
.RE
.PP
will ensure dat any filez found up in dat area is ghon be executed as MIME
types even if they is executable\&.  As dis example shows, tha complete
file name is matched against tha pattern, regardless of how tha fuck tha file
was passed ta tha handlez\&.  Da file is resolved ta a gangbangin' full path using
the \fB:A\fP modifier busted lyrics bout in
the subsection Modifiers up in \fIzshexpn\fP(1);
this means dat symbolic links is resolved where possible, so that
links tha fuck into other file systems behave up in tha erect fashion\&.
.RE
.TP
\fBfile\-path\fP
Used if tha steez \fBfind\-file\-in\-path\fP is legit fo' tha same context\&.
Set ta a array of directories dat is used fo' searchin fo' the
file ta be handled; tha default is tha command path given by the
special parameta \fBpath\fP\&.  Da shell option \fBPATH_DIRS\fP is bigged up;
if dat is set, tha appropriate path is ghon be searched even if the
name of tha file ta be handled as it appears on tha command line gotz nuff
a `\fB/\fP\&'\&.
Da full context is \fB:mime:\&.\fP\fIsuffix\fP\fB:\fP, as busted lyrics bout fo' tha style
\fBhandlez\fP\&.
.TP
\fBfind\-file\-in\-path\fP
If set, allows filez whose names do not contain absolute paths
to be searched fo' up in tha command path or tha path specified by the
\fBfile\-path\fP style\&.  If tha file aint found up in tha path, it is looked
for locally (whether or not tha current directory is up in tha path); if it is
not found locally, tha handlez will abort unless tha \fBhandle\-nonexistent\fP
style is set\&.  Filez found up in tha path is tested as busted lyrics bout for
the steez \fBexecute\-as\-is\fP\&.
Da full context is \fB:mime:\&.\fP\fIsuffix\fP\fB:\fP, as busted lyrics bout fo' tha style
\fBhandlez\fP\&.
.TP
\fBflags\fP
Defines flags ta go wit a handlez; tha context be as fo' the
\fBhandlez\fP style, n' tha format be as fo' tha flags up in \fBmailcap\fP\&.
.TP
\fBhandle\-nonexistent\fP
By default, arguments dat don\&'t correspond ta filez is not passed
to tha MIME handlez up in order ta prevent it from interceptin commandz found
in tha path dat happen ta have suffixes\&.  This steez may be set to
an array of extended glob patterns fo' arguments dat is ghon be passed ta the
handlez even if they don\&'t exist\&.  If it aint explicitly set it
defaults ta \fB[[:alpha:]]#:/*\fP which allows URLs ta be passed ta tha MIME
handlez even though they don\&'t exist up in dat format up in tha file system\&.
Da full context is \fB:mime:\&.\fP\fIsuffix\fP\fB:\fP, as busted lyrics bout fo' tha style
\fBhandlez\fP\&.
.TP
\fBhandlez\fP
Specifies a handlez fo' a suffix; tha suffix is given by tha context as
\fB:mime:\&.\fP\fIsuffix\fP\fB:\fP, n' tha format of tha handlez is exactly
that up in \fBmailcap\fP\&.  Note up in particular tha `\fB\&.\fP\&' n' trailin colon
to distinguish dis use of tha context\&.  This overrides any handlez
specified by tha \fBmailcap\fP files\&.  If tha handlez requires a terminal,
the \fBflags\fP steez should be set ta include tha word \fBneedsterminal\fP,
or if tha output is ta be displayed all up in a pager (but not if the
handlez is itself a pager), it should include \fBcopiousoutput\fP\&.
.TP
\fBmailcap\fP
A list of filez up in tha format of \fB~/\&.mailcap\fP and
\fB/etc/mailcap\fP ta be read durin setup, replacin tha default list
which consistz of dem two files\&.  Da context is \fB:mime:\fP\&.
A \fB+\fP up in tha list is ghon be replaced by tha default files\&.
.TP
\fBmailcap\-priorities\fP
This steez is used ta resolve multiple mailcap entries fo' tha same MIME
type\&.  It consistz of a array of tha followin elements, up in descending
order of priority; lata entries is ghon be used if earlier entries are
unable ta resolve tha entries bein compared\&.  If none of tha tests
resolve tha entries, tha straight-up original gangsta entry encountered is retained\&.
.RS
.PP
.PD 0
.TP
.PD
\fBfiles\fP
Da order of filez (entries up in tha \fBmailcap\fP style) read\&.  Earlier
filez is preferred\&.  (Note dis do not resolve entries up in tha same file\&.)
.TP
\fBpriority\fP
Da prioritizzle flag from tha mailcap entry\&.  Da prioritizzle be a integer
from 0 ta 9 wit tha default value bein 5\&.
.TP
\fBflags\fP
Da test given by tha \fBmailcap\-prio\-flags\fP option is used ta resolve
entries\&.
.TP
\fBplace\fP
Lata entries is preferred; as tha entries is strictly ordered, this
test always succeeds\&.
.PP
Note dat as dis steez is handled durin initialisation, tha context
is always \fB:mime:\fP, wit no discrimination by suffix\&.
.RE
.TP
\fBmailcap\-prio\-flags\fP
This steez is used when tha keyword \fBflags\fP is encountered up in the
list of tests specified by tha \fBmailcap\-priorities\fP style\&.
It should be set ta a list of patterns, each of which is tested against
the flags specified up in tha mailcap entry (in other lyrics, tha sets of
assignments found wit some entries up in tha mailcap file)\&.  Earlier
patterns up in tha list is preferred ta lata ones, n' matched patterns
are preferred ta unmatched ones\&.
.TP
\fBmime\-types\fP
A list of filez up in tha format of \fB~/\&.mime\&.types\fP and
\fB/etc/mime\&.types\fP ta be read durin setup, replacin tha default list
which consistz of dem two files\&.  Da context is \fB:mime:\fP\&.
A \fB+\fP up in tha list is ghon be replaced by tha default files\&.
.TP
\fBnever\-background\fP
If dis boolean steez is set, tha handlez fo' tha given context is
always run up in tha foreground, even if tha flags provided up in tha mailcap
entry suggest it need not be (for example, it don\&'t require a
terminal)\&.
.TP
\fBpager\fP
If set, is ghon be used instead of \fB$PAGER\fP or \fBmore\fP ta handle
suffixes where tha \fBcopiousoutput\fP flag is set\&.  Da context is
as fo' \fBhandlez\fP, i\&.e\&. \fB:mime:\&.\fP\fIsuffix\fP\fB:\fP fo' handling
a file wit tha given \fIsuffix\fP\&.
.PP
Examples:
.PP
.RS
.nf
\fBzstyle \&':mime:*' mailcap ~/\&.mailcap /usr/local/etc/mailcap
zstyle \&':mime:\&.txt:' handlez less %s
zstyle \&':mime:\&.txt:' flags needsterminal\fP
.fi
.RE
.PP
When \fBzsh\-mime\-setup\fP is subsequently run, it will look for
\fBmailcap\fP entries up in tha two filez given\&.  Filez of suffix \fB\&.txt\fP
will be handled by hustlin `\fBless\fP \fIfile\&.txt\fP\&'\&.  Da flag
\fBneedsterminal\fP is set ta show dat dis program must run attached ta a
terminal\&.
.PP
As there be nuff muthafuckin steps ta dispatchin a cold-ass lil command, tha following
should be checked if attemptin ta execute a gangbangin' file by extension
\fB\&.\fP\fIext\fP aint gots tha expected effect\&.
.PP
Da command `\fBalias \-s\fP \fIext\fP\&' should show
`\fBps=zsh\-mime\-handlez\fP\&'\&.  If it shows suttin' else, another suffix
alias was already installed n' was not overwritten\&.  If it shows
nothing, no handlez was installed:  dis is most likely cuz no
handlez was found up in tha \fB\&.mime\&.types\fP n' \fBmailcap\fP combination for
\fB\&.ext\fP files\&.  In dat case, appropriate handlin should be added to
\fB~/\&.mime\&.types\fP n' \fBmailcap\fP\&.
.PP
If tha extension is handled by \fBzsh\-mime\-handlez\fP but tha file is
not opened erectly, either tha handlez defined fo' tha type is
incorrect, or tha flags associated wit it is up in appropriate\&.  Running
\fBzsh\-mime\-setup \-l\fP will show tha handlez and, if there be any, the
flags\&.  A \fB%s\fP up in tha handlez is replaced by tha file (suitably quoted
if necessary)\&.  Peep dat tha handlez program listed lists n' can
be run up in tha way shown\&.  Also check dat tha flags \fBneedsterminal\fP or
\fBcopiousoutput\fP is set if tha handlez need ta be run under a
terminal; tha second flag is used if tha output should be busted ta a pager\&.
An example of a suitable \fBmailcap\fP entry fo' such a program is:
.PP
.RS
.nf
\fBtext/html; /usr/bin/lynx \&'%s'; needsterminal\fP
.fi
.RE
.PP
Hustlin `\fBzsh\-mime\-handlez \-l\fP \fIcommand line\fP\&' prints tha command
line dat would be executed, simplified ta remove tha effect of any
flags, n' quoted so dat tha output can be run as a cold-ass lil complete zsh
command line\&.  This is used by tha completion system ta decizzle how tha fuck to
complete afta a gangbangin' file handled by \fBzsh\-mime\-setup\fP\&.
.RE
.TP
\fBpick\-web\-browser\fP
This function is separate from tha two MIME functions busted lyrics bout above
and can be assigned directly ta a suffix:
.RS
.PP
.RS
.nf
\fBautoload \-U pick\-web\-browser
alias \-s html=pick\-web\-browser\fP
.fi
.RE
.PP
It be provided as a intelligent front end ta dispatch a wizzy browser\&.
It may be run as either a gangbangin' function or a gangbangin' finger-lickin' dirty-ass shell script\&.  Da status
255 is returned if no browser could be started\&.
.PP
Various stylez is available ta customize tha chizzle of browsers:
.PP
.PD 0
.TP
.PD
\fBbrowser\-style\fP
Da value of tha steez be a array givin preferences up in decreasin order
for tha type of browser ta use\&.  Da jointz of elements may be
.RS
.PP
.PD 0
.TP
.PD
\fBrunning\fP
Use a GUI browser dat be already hustlin when a X Window display is
available\&.  Da browsers listed up in tha \fBx\-browsers\fP steez is tried
in order until one is found; if it is, tha file is ghon be displayed in
that browser, so tha user may need ta check whether it has rocked up\&.
If no hustlin browser is found, one aint started\&.  Browsers other than
Firefox, Opera n' Konqueror is assumed ta KNOW tha Mozilla
syntax fo' openin a URL remotely\&.
.TP
\fBx\fP
Start a freshly smoked up GUI browser when a X Window display be available\&.  Search for
the availabilitizzle of one of tha browsers listed up in tha \fBx\-browsers\fP style
and start tha straight-up original gangsta one dat is found\&.  No check is made fo' a already
runnin browser\&.
.TP
\fBtty\fP
Start a terminal\-based browser\&.  Search fo' tha availabilitizzle of one
of tha browsers listed up in tha \fBtty\-browsers\fP steez n' start the
first one dat is found\&.
.PP
If tha steez aint set tha default \fBrunnin x tty\fP is used\&.
.RE
.TP
\fBx\-browsers\fP
An array up in decreasin order
of preference of browsers ta use when hustlin under tha X Window System\&.
Da array consistz of tha command name under which ta start the
browser\&.  They is looked up in tha context \fB:mime:\fP (which may
be extended up in future, so appendin `\fB*\fP\&' is recommended)\&.  For
example,
.RS
.PP
.RS
.nf
\fBzstyle \&':mime:*' x\-browsers opera konqueror firefox\fP
.fi
.RE
.PP
specifies dat \fBpick\-web\-browser\fP should first look fo' a hustlin
instizzle of Opera, Konqueror or Firefox, up in dat order, n' if it
fails ta find any should attempt ta start Opera\&.  Da default is
\fBfirefox mozilla netscape opera konqueror\fP\&.
.RE
.TP
\fBtty\-browsers\fP
An array similar ta \fBx\-browsers\fP, except dat it gives browsers to
use when no X Window display be available\&.  Da default is
\fBelinks links lynx\fP\&.
.TP
\fBcommand\fP
If it is set dis steez is used ta pick tha command
used ta open a page fo' a funky-ass browser\&.  Da context is
\fB:mime:browser:new:$browser:\fP ta start a freshly smoked up browser or
\fB:mime:browser:running:$browser:\fP ta open a URL up in a funky-ass browser already
runnin on tha current X display, where \fB$browser\fP is tha value matched
in tha \fBx\-browsers\fP or \fBtty\-browsers\fP style\&.  Da escape sequence
\fB%b\fP up in tha style\&z value is ghon be replaced by tha browser, while \fB%u\fP
will be replaced by tha URL\&.  If tha steez aint set, tha default fo' all
new instances is equivalent ta \fB%b %u\fP n' tha defaults fo' rockin hustlin
browsers is equivalent ta tha joints \fBkfmclient openURL %u\fP for
Konqueror, \fBfirefox \-new\-tab %u\fP fo' Firefox, \fBopera \-newpage %u\fP
for Opera, n' \fB%b \-remote "openUrl(%u)"\fP fo' all others\&.
.RE
.PP
.SH "MATHEMATICAL FUNCTIONS"
.PP
.PD 0
.TP
.PD
\fBzcalc\fP [ \fB\-ef\fP ] [ \fIexpression\fP \&.\&.\&. ]
A reasonably bangin calculator based on zsh\&z arithmetic evaluation
facility\&.  Da syntax is similar ta dat of formulae up in most programming
languages; see
the section `Arithmetic Evaluation\&' up in \fIzshmisc\fP(1) fo' details\&.  Da mathematical
library \fBzsh/mathfunc\fP is ghon be loaded if it be available; see
the section `Da zsh/mathfunc Module\&' up in \fIzshmodules\fP(1)\&.  Da mathematical functions
correspond ta tha raw system libraries, so trigonometric functions are
evaluated rockin radians, n' so on\&.
.RS
.PP
Each line typed is evaluated as a expression\&.  Da prompt shows a number,
which correspondz ta a positionizzle parameta where tha result of that
calculation is stored\&.  For example, tha result of tha calculation on the
line preceded by `\fB4> \fP\&' be available as \fB$4\fP\&.  Da last value
calculated be available as \fBans\fP\&.  Full command line editing, including
the history of previous calculations, be available; tha history is saved in
the file \fB~/\&.zcalc_history\fP\&.  To exit, enta a funky-ass blank line or type `\fB:q\fP\&'
on its own (`\fBq\fP\&' be allowed fo' oldschool compatibility)\&.
.PP
A line endin wit a single backslash is treated up in tha same fashion
as it is up in command line editing:  tha backslash is removed, the
function prompts fo' mo' input (the prompt is preceded by `\fB\&.\&.\&.\fP\&'
to indicate this), n' tha lines is combined tha fuck into one ta git tha final
result\&.  In addition, if tha input so far gotz nuff mo' open than
close parentheses \fBzcalc\fP will prompt fo' mo' input\&.
.PP
If arguments is given ta \fBzcalc\fP on start up, they is used ta prime the
first few positionizzle parameters\&.  A visual indication of dis is given when
the calculator starts\&.
.PP
Da constants \fBPI\fP (3\&.14159\&.\&.\&.) n' \fBE\fP (2\&.71828\&.\&.\&.) is provided\&.
Parameta assignment is possible yo, but note dat all parametas is ghon be put
into tha global namespace\&.
.PP
Da output base can be initialised by passin tha option `\fB\-#\fP\fIbase\fP\&',
for example `\fBzcalc \-#16\fP\&' (the `\fB#\fP' may gotta be quoted, depending
on tha globbin options set)\&.
.PP
If tha option `\fB\-e\fP\&' is set, tha function runs non\-interactively:
the arguments is treated as expressions ta be evaluated as if entered
interactively line by line\&.
.PP
If tha option `\fB\-f\fP\&' is set, all numbers is treated as floating
point, hence fo' example tha expression `\fB3/4\fP\&' evaluates ta 0\&.75
rather than 0\&.  Options must step tha fuck up in separate lyrics\&.
.PP
Da prompt is configurable via tha parameta \fBZCALCPROMPT\fP, which
undergoes standard prompt expansion\&.  Da index of tha current entry is
stored locally up in tha straight-up original gangsta element of tha array \fBpsvar\fP, which can be
referred ta up in \fBZCALCPROMPT\fP as `\fB%1v\fP\&'\&.  Da default prompt is
`\fB%1v> \fP\&'\&.
.PP
A few special commandz is available; these is introduced by a cold-ass lil colon\&.
For backward compatibility, tha colon may be omitted fo' certain
commands\&.  Completion be available if \fBcompinit\fP has been run\&.
.PP
Da output precision may be specified within zcalc by special commands
familiar from nuff calculators\&.
.PD 0
.TP
.PD
\fB:norm\fP
Da default output format\&.  It correspondz ta tha printf \fB%g\fP
specification\&.  Typically dis shows six decimal digits\&.
.TP
\fB:sci\fP \fIdigits\fP
Scientific notation, correspondin ta tha printf \fB%g\fP output format with
the precision given by \fIdigits\fP\&.  This produces either fixed point or
exponential notation dependin on tha value output\&.
.TP
\fB:fix\fP \fIdigits\fP
Fixed point notation, correspondin ta tha printf \fB%f\fP output format with
the precision given by \fIdigits\fP\&.
.TP
\fB:eng\fP \fIdigits\fP
Exponential notation, correspondin ta tha printf \fB%E\fP output format with
the precision given by \fIdigits\fP\&.
.TP
\fB:raw\fP
Raw output:  dis is tha default form of tha output from a math
evaluation\&.  This may show mo' precision than tha number actually
possesses\&.
.PP
Other special commands:
.PD 0
.TP
.PD
\fB:!\fP\fIline\&.\&.\&.\fP
Execute \fIline\&.\&.\&.\fP as a aiiight shell command line\&.  Note dat it
is executed up in tha context of tha function, i\&.e\&. wit local variables\&.
Space is optionizzle afta \fB:!\fP\&.
.TP
\fB:local\fP \fIarg\fP \&.\&.\&.
Declare variablez local ta tha function\&.  Note dat certain variables
are used by tha function fo' its own purposes\&.  Other variables
may be used, too yo, but they is ghon be taken from or put tha fuck into tha global
scope\&.
.TP
\fB:function\fP \fIname\fP [ \fIbody\fP ]
Define a mathematical function or (with no \fIbody\fP) delete it\&.
\fB:function\fP may be abbreviated ta \fB:func\fP or simply \fB:f\fP\&.
Da \fIname\fP may contain tha same charactas as a gangbangin' finger-lickin' dirty-ass shell function name\&.
Da function is defined rockin \fBzmathfuncdef\fP, peep below\&.
.RS
.PP
Note dat \fBzcalc\fP takes care of all quoting\&.  Hence fo' example:
.PP
.RS
.nf
\fB:f cube $1 * $1 * $1\fP
.fi
.RE
.PP
defines a gangbangin' function ta cube tha sole argument\&.
.RE
.TP
\fB[#\fP\fIbase\fP\fB]\fP
This aint a special command, rather part of aiiight arithmetic
syntax; however, when dis form appears on a line by itself tha default
output radix is set ta \fIbase\fP\&.  Use, fo' example, `\fB[#16]\fP\&' ta display
hexadecimal output preceded by a indication of tha base, or `\fB[##16]\fP\&'
just ta display tha raw number up in tha given base\&.  Bases theyselves are
always specified up in decimal\&. `\fB[#]\fP\&' restores tha aiiight output format\&.
Note dat settin a output base suppresses floatin point output; use
`\fB[#]\fP\&' ta return ta aiiight operation\&.
.PP
See tha comments up in tha function fo' all dem extra tips\&.
.RE
.TP
\fBzmathfuncdef\fP [ \fImathfunc\fP [ \fIbody\fP ] ]
A convenient front end ta \fBfunctions \-M\fP\&.
.RS
.PP
With two arguments, define a mathematical function named \fImathfunc\fP
which can be used up in any form of arithmetic evaluation\&.  \fIbody\fP
is a mathematical expression ta implement tha function\&.  It may
contain references ta posizzle parametas \fB$1\fP, \fB$2\fP, \&.\&.\&.
to refer ta mandatory parametas n' \fB${1:\-\fP\fIdefvalue\fP\fB}\fP \&.\&.\&.
to refer ta optionizzle parameters\&.  Note dat tha forms must be
strictly adhered ta fo' tha function ta calculate tha erect number
of arguments\&.  Da implementation is held up in a gangbangin' finger-lickin' dirty-ass shell function named
\fBzsh_math_func_\fP\fImathfunc\fP; probably tha user aint gonna need
to refer ta tha shell function directly\&.  Any existin function
of tha same name is silently replaced\&.
.PP
With one argument, remove tha mathematical function \fImathfunc\fP
as well as tha shell function implementation\&.
.PP
With no arguments, list all \fImathfunc\fP functions up in a gangbangin' form
suitable fo' restorin tha definition\&.
Da functions aint necessarily been defined by \fBzmathfuncdef\fP\&.
.RE
.PP
.SH "USER CONFIGURATION FUNCTIONS"
.PP
Da \fBzsh/newuser\fP module comes wit a gangbangin' function ta aid up in configuring
shell options fo' freshly smoked up users\&.  If tha module is installed, dis function can
also be run by hand\&.  It be available even if tha module\&z default
behaviour, namely hustlin tha function fo' a freshly smoked up user loggin up in without
startup files, is inhibited\&.
.PP
.PD 0
.TP
.PD
\fBzsh\-newuser\-install\fP [ \fB\-f\fP ]
Da function presents tha user wit various options fo' customizing
their initialization scripts\&.  Currently only \fB~/\&.zshrc\fP is handled\&.
\fB$ZDOTDIR/\&.zshrc\fP is used instead if tha parameta \fBZDOTDIR\fP is
set; dis serves up a way fo' tha user ta configure a gangbangin' file without
alterin a existin \fB\&.zshrc\fP\&.
.RS
.PP
By default tha function exits immediately if it findz any of tha files
\fB\&.zshenv\fP, \fB\&.zprofile\fP, \fB\&.zshrc\fP, or \fB\&.zlogin\fP up in tha appropriate
directory\&.  Da option \fB\-f\fP is required up in order ta force tha function
to continue\&.  Note dis may happen even if \fB\&.zshrc\fP itself do not
exist\&.
.PP
As currently configured, tha function will exit immediately if the
user has root privileges; dis behaviour cannot be overridden\&.
.PP
Once activated, tha function\&z behaviour is supposed ta be
self\-explanatory\&.  Menus is present allowin tha user ta alter
the value of options n' parameters\&.  Suggestions fo' improvements are
always welcome\&.
.PP
When tha script exits, tha user is given tha opportunitizzle ta save tha new
file or not; chizzlez is not irreversible until dis point\&.  However,
the script is careful ta restrict chizzlez ta tha file only ta a group
marked by tha lines `\fB# Lines configured by zsh\-newuser\-install\fP\&' and
`\fB# End of lines configured by zsh\-newuser\-install\fP\&'\&.  In addition,
the oldschool version of \fB\&.zshrc\fP is saved ta a gangbangin' file wit tha suffix
\fB\&.zni\fP appended\&.
.PP
If tha function edits a existin \fB\&.zshrc\fP, it is up ta tha user
to ensure dat tha chizzlez made will take effect\&.  For example, if
control probably returns early from tha existin \fB\&.zshrc\fP tha lines
will not be executed; or a lata initialization file may override
options or parameters, n' so on\&.  Da function itself do not attempt to
detect any such conflicts\&.
.RE
.PP
.SH "OTHER FUNCTIONS"
.PP
There is a big-ass number of helpful functions up in tha \fBFunctions/Misc\fP
directory of tha zsh distribution\&.  Most is straight-up simple n' do not
require documentation here yo, but all dem is worthy of special mention\&.
.PP
.SS "Descriptions"
.PP
.PD 0
.TP
.PD
\fBcolors\fP
This function initializes nuff muthafuckin associatizzle arrays ta map color names to
(and from) tha ANSI standard eight\-color terminal codes\&.  These is used
by tha prompt theme system (see above)\&.  Yo ass seldom should need ta run
\fBcolors\fP mo' than once\&.
.RS
.PP
Da eight base flavas are: \fBblack\fP, \fBred\fP, \fBgreen\fP, \fByellow\fP,
\fBblue\fP, \fBmagenta\fP, \fBcyan\fP, n' \fBwhite\fP\&.  Each of these has codes for
foreground n' background\&.  In addizzle there be seven intensitizzle attributes:
\fBbold\fP, \fBfaint\fP, \fBstandout\fP, \fBunderline\fP, \fBblink\fP, \fBreverse\fP,
and \fBconceal\fP\&.  Finally, there be seven codes used ta negate attributes:
\fBnone\fP (reset all attributes ta tha defaults), \fBnormal\fP
(neither bold nor faint), \fBno\-standout\fP, \fBno\-underline\fP, \fBno\-blink\fP,
\fBno\-reverse\fP, n' \fBno\-conceal\fP\&.
.PP
Some terminals do not support all combinationz of flavas n' intensities\&.
.PP
Da associatizzle arrays are:
.PP
.PD 0
.TP
.PD 0
\fBcolor\fP
.TP
.PD
\fBcolour\fP
Map all tha color names ta they integer codes, n' integer codes ta the
color names\&.  Da eight base names map ta tha foreground color codes, as
do names prefixed wit `\fBfg\-\fP\&', like fuckin `\fBfg\-red\fP'\&.  Names prefixed
with `\fBbg\-\fP\&', like fuckin `\fBbg\-blue\fP', refer ta tha background codes\&.  The
reverse mappin from code ta color yieldz base name fo' foreground codes
and tha \fBbg\-\fP form fo' backgrounds\&.
.RS
.PP
Although it aint nuthin but a misnomer ta booty-call dem `colors\&', these arrays also map the
other fourteen attributes from names ta codes n' codes ta names\&.
.RE
.TP
.PD 0
\fBfg\fP
.TP
.PD 0
\fBfg_bold\fP
.TP
.PD
\fBfg_no_bold\fP
Map tha eight basic color names ta ANSI terminal escape sequences dat set
the correspondin foreground text properties\&.  Da \fBfg\fP sequences chizzle
the color without changin tha eight intensitizzle attributes\&.
.TP
.PD 0
\fBbg\fP
.TP
.PD 0
\fBbg_bold\fP
.TP
.PD
\fBbg_no_bold\fP
Map tha eight basic color names ta ANSI terminal escape sequences dat set
the correspondin background properties\&.  Da \fBbg\fP sequences chizzle the
color without changin tha eight intensitizzle attributes\&.
.PP
In addition, tha scalar parametas \fBreset_color\fP n' \fBbold_color\fP are
set ta tha ANSI terminal escapes dat turn off all attributes n' turn on
bold intensity, respectively\&.
.RE
.TP
\fBfned\fP \fIname\fP
Same as \fBzed \-f\fP\&.  This function do not step tha fuck up in tha zsh
distribution yo, but can be pimped by linkin \fBzed\fP ta tha name \fBfned\fP
in some directory up in yo' \fBfpath\fP\&.
.TP
\fBis\-at\-least\fP \fIneeded\fP [ \fIpresent\fP ]
Perform a pimped outer\-than\-or\-equal\-to comparison of two strings havin the
format of a zsh version number; dat is, a strang of numbers n' text with
segments separated by dots or dashes\&.  If tha \fIpresent\fP strang is not
provided, \fB$ZSH_VERSION\fP is used\&.  Segments is paired left\-to\-right in
the two strings wit leadin non\-number parts ignored\&.  If one strang has
fewer segments than tha other, tha missin segments is considered zero\&.
.RS
.PP
This is useful up in startup filez ta set options n' other state dat are
not available up in all versionz of zsh\&.
.PP
.RS
.nf
\fBis\-at\-least 3\&.1\&.6\-15 && setopt NO_GLOBAL_RCS
is\-at\-least 3\&.1\&.0 && setopt HIST_REDUCE_BLANKS
is\-at\-least 2\&.6\-17 || print "Yo ass can\&'t use is\-at\-least here\&."\fP
.fi
.RE
.RE
.TP
\fBnslookup\fP [ \fIarg\fP \&.\&.\&. ]
This wrapper function fo' tha \fBnslookup\fP command requires the
\fBzsh/zpty\fP module (see
\fIzshmodules\fP(1))\&.  It behaves exactly like tha standard \fBnslookup\fP
except dat it serves up customizable prompts (includin a right\-side
prompt) n' completion of nslookup commands, host names, etc\&. (if you use
the function\-based completion system)\&.  Completion stylez may be set with
the context prefix `\fB:completion:nslookup\fP\&'\&.
.RS
.PP
See also tha \fBpager\fP, \fBprompt\fP n' \fBrprompt\fP stylez below\&.
.RE
.TP
\fBregexp\-replace\fP \fIvar\fP \fIregexp\fP \fIreplace\fP
Use regular expressions ta big-ass up a global search n' replace operation
on a variable\&.  If tha option \fBRE_MATCH_PCRE\fP aint set, POSIX
extended regular expressions is used, else Perl\-compatible regular
expressions (this requires tha shell ta be linked against tha \fBpcre\fP
library)\&.
.RS
.PP
\fIvar\fP is tha name of tha variable containin tha strang ta be matched\&.
Da variable is ghon be modified directly by tha function\&.  The
variablez \fBMATCH\fP, \fBMBEGIN\fP, \fBMEND\fP, \fBmatch\fP, \fBmbegin\fP, \fBmend\fP
should be avoided as these is used by tha regular expression code\&.
.PP
\fIregexp\fP is tha regular expression ta match against tha string\&.
.PP
\fIreplace\fP is tha replacement text\&.  This can contain parameter, command
and arithmetic expressions which is ghon be replaced:  up in particular, a
reference ta \fB$MATCH\fP is ghon be replaced by tha text matched by tha pattern\&.
.PP
Da return status is 0 if at least one match was performed, else 1\&.
.RE
.TP
\fBrun\-help\fP \fIcmd\fP
This function is designed ta be invoked by tha \fBrun\-help\fP ZLE widget,
in place of tha default alias\&.  See `Accessin On\-Line Help\&'
above fo' setup instructions\&.
.RS
.PP
In tha rap which bigs up, if \fIcmd\fP be a gangbangin' file system path, it is
first reduced ta its rightmost component (the file name)\&.
.PP
Help is first sought by lookin fo' a gangbangin' file named \fIcmd\fP up in tha directory
named by tha \fBHELPDIR\fP parameter\&.  If no file is found, a assistant
function, alias, or command named \fBrun\-help\-\fIcmd\fP\fP is sought\&.  If
found, tha assistant is executed wit tha rest of tha current command line
(everythang afta tha command name \fIcmd\fP) as its arguments\&.  When
neither file nor assistant is found, tha external command
`\fBman\fP \fIcmd\fP\&' is run\&.
.PP
An example assistant fo' tha "ssh" command:
.PP
.RS
.nf
\fBrun\-help\-ssh() {
    emulate \-LR zsh
    local \-a args
    # Delete tha "\-l username" option
    zparseopts \-D \-E \-a args l:
    # Delete other options, leaving: host command
    args=(${@:#\-*})
    if [[ ${#args} \-lt 2 ]]; then
        playa ssh
    else
        run\-help $args[2]
    fi
}\fP
.fi
.RE
.PP
Several of these assistants is provided up in tha \fBFunctions/Misc\fP
directory\&.  These must be autoloaded, or placed as executable scripts in
your search path, up in order ta be found n' used by \fBrun\-help\fP\&.
.PP
.PD 0
.TP
.PD 0
\fBrun\-help\-git\fP
.TP
.PD 0
\fBrun\-help\-svk\fP
.TP
.PD
\fBrun\-help\-svn\fP
Assistant functions fo' tha \fBgit\fP, \fBsvk\fP, n' \fBsvn\fP commands\&.
.RE
.TP
\fBtetris\fP
Zsh was once accused of not bein as complete as Emacs,
because it lacked a Tetris game\&.  This function was freestyled to
refute dis vicious slander\&.
.RS
.PP
This function must be used as a ZLE widget:
.PP
.RS
.nf
\fBautoload \-U tetris
zle \-N tetris
bindkey \fIkeys\fP tetris\fP
.fi
.RE
.PP
To start a game, execute tha widget by typin tha \fIkeys\fP\&.  Whatever command
line you was editin disappears temporarily, n' yo' keymap be also
temporarily replaced by tha Tetris control keys\&.  Da previous editor state
is restored when you quit tha game (by pressin `\fBq\fP\&') or when you lose\&.
.PP
If you quit up in tha middle of a game, tha next invocation of tha \fBtetris\fP
widget will continue where you left off\&.  If you lost, it will start a new
game\&.
.RE
.TP
\fBzargs\fP [ \fIoption\fP \&.\&.\&. \fB\-\fP\fB\-\fP ] [ \fIinput\fP \&.\&.\&. ] [ \fB\-\fP\fB\-\fP \fIcommand\fP [ \fIarg\fP \&.\&.\&. ] ]
This function has a similar purpose ta GNU xargs\&.  Instead of
readin linez of arguments from tha standard input, it takes dem from
the command line\&.  This is useful cuz zsh, especially wit recursive
glob operators, often can construct a cold-ass lil command line fo' a gangbangin' finger-lickin' dirty-ass shell function
that is longer than can be accepted by a external command\&.
.RS
.PP
Da \fIoption\fP list represents optionz of tha \fBzargs\fP command itself,
which is tha same as dem of \fBxargs\fP\&.  Da \fIinput\fP list is the
collection of strings (often file names) dat become tha argumentz of the
\fBcommand\fP, analogous ta tha standard input of \fBxargs\fP\&.  Finally, the
\fIarg\fP list consistz of dem arguments (usually options) dat are
passed ta tha \fIcommand\fP each time it runs\&.  Da \fIarg\fP list precedes
the elements from tha \fBinput\fP list up in each run\&.  If no \fIcommand\fP is
provided, then no \fIarg\fP list may be provided, n' up in dat event the
default command is `\fBprint\fP\&' wit arguments `\fB\-r \-\fP\fB\-\fP'\&.
.PP
For example, ta git a long-ass \fBls\fP listin of all plain filez up in the
current directory or its subdirectories:
.PP
.RS
.nf
\fBautoload \-U zargs
zargs \-\- **/*(\&.) \-\- ls \-l\fP
.fi
.RE
.PP
Note dat `\fB\-\fP\fB\-\fP\&' is used both ta mark tha end of tha \fIoption\fP
list n' ta mark tha end of tha \fIinput\fP list, so it must step tha fuck up twice
whenever tha \fIinput\fP list may be empty\&.  If there is guaranteed ta be
at least one \fIinput\fP n' tha straight-up original gangsta \fIinput\fP do not begin wit a
`\fB\-\fP\&', then tha straight-up original gangsta `\fB\-\fP\fB\-\fP' may be omitted\&.
.PP
In tha event dat tha strang `\fB\-\fP\fB\-\fP\&' is or may be a \fIinput\fP, the
\fB\-e\fP option may be used ta chizzle tha end\-of\-inputs marker\&.  Note that
this do \fInot\fP chizzle tha end\-of\-options marker\&.  For example, ta use
`\fB\&.\&.\fP\&' as tha marker:
.PP
.RS
.nf
\fBzargs \-e\&.\&. \-\- **/*(\&.) \&.\&. ls \-l\fP
.fi
.RE
.PP
This be a phat chizzle up in dat example cuz no plain file can be named
`\fB\&.\&.\fP\&' yo, but tha dopest end\-marker dependz on tha circumstances\&.
.PP
Da options \fB\-i\fP, \fB\-I\fP, \fB\-l\fP, \fB\-L\fP, n' \fB\-n\fP differ slightly
from they usage up in \fBxargs\fP\&.  There is no input lines fo' \fBzargs\fP to
count, so \fB\-l\fP n' \fB\-L\fP count all up in tha \fIinput\fP list, n' \fB\-n\fP
counts tha number of arguments passed ta each execution of \fIcommand\fP,
\fIincluding\fP any \fIarg\fP list\&.  Also, any time \fB\-i\fP or \fB\-I\fP is used,
each \fIinput\fP is processed separately as if by `\fB\-L\fP \fB1\fP\&'\&.
.PP
For detailz of tha other \fBzargs\fP options, peep \fIxargs\fP(1) (but note
the difference up in function between \fBzargs\fP n' \fBxargs\fP) or run
\fBzargs\fP wit tha \fB\-\fP\fB\-help\fP option\&.
.RE
.TP
.PD 0
\fBzed\fP [ \fB\-f\fP ] \fIname\fP
.TP
.PD
\fBzed \-b\fP
This function uses tha ZLE editor ta edit a gangbangin' file or function\&.
.RS
.PP
Only one \fIname\fP argument be allowed\&.
If tha \fB\-f\fP option is given, tha name is taken ta be dat of
a function; if tha function is marked fo' autoloading, \fBzed\fP searches
for it up in tha \fBfpath\fP n' loadz it\&.  Note dat functions edited dis way
are installed tha fuck into tha current shell yo, but \fInot\fP freestyled back ta the
autoload file\&.
.PP
Without \fB\-f\fP, \fIname\fP is tha path name of tha file ta edit, which need
not exist; it is pimped on write, if necessary\&.
.PP
While editing, tha function sets tha main keymap ta \fBzed\fP n' the
vi command keymap ta \fBzed\-vicmd\fP\&.  These is ghon be copied from tha existing
\fBmain\fP n' \fBvicmd\fP keymaps if they do not exist tha last time \fBzed\fP
is run\&.  They can be used ta provide special key bindings used only up in zed\&.
.PP
If it creates tha keymap, \fBzed\fP rebindz tha return key ta bang a line
break n' `\fB^X^W\fP\&' ta accept tha edit up in tha \fBzed\fP keymap, n' binds
`\fBZZ\fP\&' ta accept tha edit up in tha \fBzed\-vicmd\fP keymap\&.
.PP
Da bindings ridin' solo can be installed by hustlin `\fBzed \-b\fP\&'\&.  This is
suitable fo' puttin tha fuck into a startup file\&.  Note that, if rerun,
this will overwrite tha existin \fBzed\fP n' \fBzed\-vicmd\fP keymaps\&.
.PP
Completion be available, n' stylez may be set wit tha context prefix
`\fB:completion:zed\fP\&'\&.
.PP
A zle widget \fBzed\-set\-file\-name\fP be available\&.  This can be called by
name from within zed rockin `\fB\eex zed\-set\-file\-name\fP\&' (note, however, that
because of zed\&z rebindings yo big-ass booty is ghon gotta type \fB^j\fP all up in tha end instead
of tha return key), or can be bound ta a key up in either of tha \fBzed\fP or
\fBzed\-vicmd\fP keymaps afta `\fBzed \-b\fP\&' has been run\&.  When tha widget is
called, it prompts fo' a freshly smoked up name fo' tha file bein edited\&.  When zed
exits tha file is ghon be freestyled under dat name n' tha original gangsta file will
be left alone\&.  Da widget has no effect wit `\fBzed \-f\fP\&'\&.
.PP
While \fBzed\-set\-file\-name\fP is hustlin, zed uses tha keymap
\fBzed\-normal\-keymap\fP, which is linked from tha main keymap up in effect
at tha time zed initialised its bindings\&.  (This is ta make tha return key
operate normally\&.)  Da result is dat if tha main keymap has been chizzled,
the widget won\&'t notice\&.  This aint a cold-ass lil concern fo' most users\&.
.RE
.TP
.PD 0
\fBzcp\fP [ \fB\-finqQvwW\fP ] \fIsrcpat\fP \fIdest\fP
.TP
.PD
\fBzln\fP [ \fB\-finqQsvwW\fP ] \fIsrcpat\fP \fIdest\fP
Same as \fBzmv \-C\fP n' \fBzmv \-L\fP, respectively\&.  These functions do not
appear up in tha zsh distribution yo, but can be pimped by linkin \fBzmv\fP to
the names \fBzcp\fP n' \fBzln\fP up in some directory up in yo' \fBfpath\fP\&.
.TP
\fBzkbd\fP
See `Keyboard Definition\&'
above\&.
.TP
\fBzmv\fP [ \fB\-finqQsvwW\fP ] [ \-C | \-L | \-M | \-[pP] \fIprogram\fP ] [ \-o \fIoptstring\fP ] \fIsrcpat\fP \fIdest\fP 
Move (usually, rename) filez matchin tha pattern \fIsrcpat\fP to
correspondin filez havin namez of tha form given by \fIdest\fP, where
\fIsrcpat\fP gotz nuff parentheses surroundin patterns which will be
replaced up in turn by $1, $2, \&.\&.\&. up in \fIdest\fP\&.  For example,
.RS
.PP
.RS
.nf
\fBzmv \&'(*)\&.lis' '$1\&.txt'\fP
.fi
.RE
.PP
renames `\fBfoo\&.lis\fP\&' ta `\fBfoo\&.txt\fP', `\fBmy\&.old\&.stuff\&.lis\fP' to
`\fBmy\&.old\&.stuff\&.txt\fP\&', n' so on\&.
.PP
Da pattern be always treated as a \fBEXTENDED_GLOB\fP pattern\&.  Any file
whose name aint chizzled by tha substitution is simply ignored\&.  Any
error (a substitution resulted up in a empty string, two substitutions gave
the same result, tha destination was a existin regular file n' \fB\-f\fP
was not given) causes tha entire function ta abort without bustin anything\&.
.PP
Options:
.PP
.PD 0
.TP
\fB\-f\fP
Force overwritin of destination files\&.  Not currently
passed down ta tha \fBmv\fP/\fBcp\fP/\fBln\fP command cuz of vagaries of
implementations (but you can use \fB\-o\-f\fP ta do that)\&.
.TP
\fB\-i\fP
Interactive: show each line ta be executed n' ask tha user
whether ta execute it\&.  `Y\&' or `y' will execute it, anythang else will
skip it\&.  Note dat you just need ta type one character\&.
.TP
\fB\-n\fP
No execution: print what tha fuck would happen yo, but don\&'t do it\&.
.TP
\fB\-q\fP
Turn bare glob qualifiers off: now assumed by default, so
this has no effect\&.
.TP
\fB\-Q\fP
Force bare glob qualifiers on\&.  Don\&'t turn dis on unless
yo ass is straight-up rockin glob qualifiers up in a pattern\&.
.TP
\fB\-s\fP
Symbolic, passed down ta \fBln\fP; only works wit \fB\-L\fP\&.
.TP
\fB\-v\fP
Verbose: print each command as it\&z bein executed\&.
.TP
\fB\-w\fP
Pick up wildcard partz of tha pattern, as busted lyrics bout above,
and implicitly add parentheses fo' referrin ta them\&.
.TP
\fB\-W\fP
Just like \fB\-w\fP, wit tha addizzle of turnin wildcardz in
the replacement pattern tha fuck into sequential ${1} \&.\&. ${N} references\&.
.TP
\fB\-C\fP
.TP
\fB\-L\fP
.TP
\fB\-M\fP
Force \fBcp\fP, \fBln\fP or \fBmv\fP, respectively, regardless of
the name of tha function\&.
.TP
\fB\-p\fP \fIprogram\fP
Call \fIprogram\fP instead of \fBcp\fP, \fBln\fP or
\fBmv\fP\&.  Whatever it do, it should at least KNOW tha form
`\fIprogram\fP \fB\-\fP\fB\-\fP \fIoldname\fP \fInewname\fP\&'
where \fIoldname\fP n' \fInewname\fP is filenames generated by \fBzmv\fP\&.
\fIprogram\fP is ghon be split tha fuck into lyrics, so might be e\&.g\&. tha name
of a archive tool plus a cold-ass lil copy or rename subcommand\&.
.TP
\fB\-P\fP \fIprogram\fP
As \fB\-p\fP \fIprogram\fP, except that
\fIprogram\fP do not accept a gangbangin' followin \fB\-\fP\fB\-\fP ta indicate the
end of options\&.  In dis case filenames must already be up in a sane
form fo' tha program up in question\&.
.TP
\fB\-o\fP \fIoptstring\fP
Da \fIoptstring\fP is split tha fuck into lyrics and
passed down verbatim ta tha \fBcp\fP, \fBln\fP or \fBmv\fP command called to
perform tha work\&.  It should probably begin wit a `\fB\-\fP\&'\&.
.PD
.PP
Further examples:
.PP
.RS
.nf
\fBzmv \-v \&'(* *)' '${1// /_}'\fP
.fi
.RE
.PP
For any file up in tha current directory wit at least one space up in tha name,
replace every last muthafuckin space by a underscore n' display tha commandz executed\&.
.PP
For mo' complete examplez n' other implementation details, peep the
\fBzmv\fP source file, probably located up in one of tha directories named in
your \fBfpath\fP, or up in \fBFunctions/Misc/zmv\fP up in tha zsh distribution\&.
.RE
.TP
\fBzrecompile\fP
See `Recompilin Functions\&'
above\&.
.TP
\fBzstyle+\fP \fIcontext\fP \fIstyle\fP \fIvalue\fP [ + \fIsubcontext\fP \fIstyle\fP \fIvalue\fP \&.\&.\&. ]
This make definin stylez a lil' bit simpla by rockin a single `\fB+\fP\&' as a
special token dat allows you ta append a cold-ass lil context name ta tha previously
used context name\&.  Like this:
.RS
.PP
.RS
.nf
\fBzstyle+ \&':foo:bar' style1 value1 \e 
      + \&':baz'     style2 value2 \e 
      + \&':frob'    style3 value3\fP
.fi
.RE
.PP
This defines `style1\&' wit `value1' fo' tha context \fB:foo:bar\fP as usual,
but it also defines `style2\&' wit `value2' fo' tha context
\fB:foo:bar:baz\fP n' `style3\&' wit `value3' fo' \fB:foo:bar:frob\fP\&.  Any
\fIsubcontext\fP may be tha empty strang ta re\-use tha straight-up original gangsta context
unchanged\&.
.RE
.PP
.SS "Styles"
.PP
.PD 0
.TP
.PD
\fBinsert\-tab\fP
Da \fBzed\fP function \fIsets\fP dis steez up in context `\fB:completion:zed:*\fP\&'
to turn off completion when \fBTAB\fP is typed all up in tha beginnin of a line\&.
Yo ass may override dis by settin yo' own value fo' dis context n' style\&.
.TP
\fBpager\fP
Da \fBnslookup\fP function looks up dis steez up in tha context
`\fB:nslookup\fP\&' ta determine tha program used ta display output dat do
not fit on a single screen\&.
.TP
.PD 0
\fBprompt\fP
.TP
.PD
\fBrprompt\fP
Da \fBnslookup\fP function looks up dis steez up in tha context
`\fB:nslookup\fP\&' ta set tha prompt n' tha right\-side prompt, respectively\&.
Da usual expansions fo' tha \fBPS1\fP n' \fBRPS1\fP parametas may be used
(see
EXPANSION OF PROMPT SEQUENCES up in \fIzshmisc\fP(1))\&.
