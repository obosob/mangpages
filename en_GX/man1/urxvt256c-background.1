.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some characta translations n' predefined strings.  \*(-- will
.\" give a unbreakable dash, \*(PI'ma give pi, \*(L" will give a left
.\" double quote, n' \*(R" will give a right double quote.  \*(C+ will
.\" give a sickr C++.  Capital omega is used ta do unbreakable dashes and
.\" therefore won't be available.  \*(C` n' \*(C' expand ta `' up in nroff,
.\" not a god damn thang up in troff, fo' use wit C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    dz -- \(*W-
.    dz PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    dz L" ""
.    dz R" ""
.    dz C` ""
.    dz C' ""
'br\}
.el\{\
.    dz -- \|\(em\|
.    dz PI \(*p
.    dz L" ``
.    dz R" ''
.    dz C`
.    dz C'
'br\}
.\"
.\" Escape single quotes up in literal strings from groffz Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If tha F regista is turned on, we'll generate index entries on stderr for
.\" titlez (.TH), headaz (.SH), subsections (.SS), shit (.Ip), n' index
.\" entries marked wit X<> up in POD.  Of course, you gonna gotta process the
.\" output yo ass up in some meaningful fashion.
.\"
.\" Avoid warnin from groff bout undefined regista 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear. Shiiit, dis aint no joke.  Run. I aint talkin' bout chicken n' gravy biatch.  Save yo ass.  No user-serviceable parts.
.    \" fudge factors fo' nroff n' troff
.if n \{\
.    dz #H 0
.    dz #V .8m
.    dz #F .3m
.    dz #[ \f1
.    dz #] \fP
.\}
.if t \{\
.    dz #H ((1u-(\\\\n(.fu%2u))*.13m)
.    dz #V .6m
.    dz #F 0
.    dz #[ \&
.    dz #] \&
.\}
.    \" simple accents fo' nroff n' troff
.if n \{\
.    dz ' \&
.    dz ` \&
.    dz ^ \&
.    dz , \&
.    dz ~ ~
.    dz /
.\}
.if t \{\
.    dz ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    dz ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    dz ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    dz , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    dz ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    dz / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff n' (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" erections fo' vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" fo' low resolution devices (crt n' lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    dz : e
.    dz 8 ss
.    dz o a
.    dz d- d\h'-1'\(ga
.    dz D- D\h'-1'\(hy
.    dz th \o'bp'
.    dz Th \o'LP'
.    dz ae ae
.    dz Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "urxvt-background 1"
.TH urxvt-background 1 "2014-05-13" "9.20" "RXVT-UNICODE"
.\" For nroff, turn off justification. I aint talkin' bout chicken n' gravy biatch.  Always turn off hyphenation; it makes
.\" way too nuff mistakes up in technical documents.
.if n .ad l
.nh
.SH "NAME"
background \- manage terminal background
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&   urxvt \-\-background\-expr \*(Aqbackground expression\*(Aq
\&         \-\-background\-border
\&         \-\-background\-interval seconds
.Ve
.SH "QUICK AND DIRTY CHEAT SHEET"
.IX Header "QUICK AND DIRTY CHEAT SHEET"
Just load a random jpeg image n' tile tha background wit it without
scalin or anythang else:
.PP
.Vb 1
\&   load "/path/to/img.jpg"
.Ve
.PP
Da same yo, but use mirroring/reflection instead of tiling:
.PP
.Vb 1
\&   mirror load "/path/to/img.jpg"
.Ve
.PP
Load a image n' scale it ta exactly fill tha terminal window:
.PP
.Vb 1
\&   scale keep { load "/path/to/img.jpg" }
.Ve
.PP
Implement pseudo-transparency by rockin a suitably-aligned root pixmap
as window background:
.PP
.Vb 1
\&   rootalign root
.Ve
.PP
Likewise yo, but keep a funky-ass blurred copy:
.PP
.Vb 1
\&   rootalign keep { blur 10, root }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This extension manages tha terminal background by bustin a picture that
is behind tha text, replacin tha aiiight background colour.
.PP
It do so by evaluatin a Perl expression dat \fIcalculates\fR tha image on
the fly, fo' example, by grabbin tha root background or loadin a gangbangin' file.
.PP
While tha full juice of Perl be available, tha operators done been design
to be as simple as possible.
.PP
For example, ta load a image n' scale it ta tha window size, you would
use:
.PP
.Vb 1
\&   urxvt \-\-background\-expr \*(Aqscale keep { load "/path/to/mybg.png" }\*(Aq
.Ve
.PP
Or specified as a X resource:
.PP
.Vb 1
\&   URxvt.background\-expr: scale keep { load "/path/to/mybg.png" }
.Ve
.SH "THEORY OF OPERATION"
.IX Header "THEORY OF OPERATION"
At startup, just before tha window is mapped fo' tha last time, the
expression is evaluated n' must yield a image. Da image is then
extended as necessary ta cover tha whole terminal window, n' is set as a
background pixmap.
.PP
If tha image gotz nuff a alpha channel, then it is ghon be used as-is in
visuals dat support alpha channels (for example, fo' a cold-ass lil compositing
manager). In other visuals, tha terminal background colour is ghon be used to
replace any transparency.
.PP
When tha expression relies, directly or indirectly, on tha window size,
position, tha root pixmap, or a timer, then it is ghon be remembered. Y'all KNOW dat shit, muthafucka! If not,
then it is ghon be removed.
.PP
If any of tha parametas dat tha expression relies on chizzlez (when the
window is moved or resized, its posizzle or size chizzles; when tha root
pixmap is replaced by another one tha root background chizzles; or when the
timer elapses), then tha expression is ghon be evaluated again.
.PP
For example, a expression like fuckin \f(CW\*(C`scale keep { load "$HOME/mybg.png"
}\*(C'\fR scalez tha image ta tha window size, so it relies on tha window size
and is ghon be reevaluated each time it is chizzled yo, but not when it moves for
example. That ensures dat tha picture always fills tha terminal, even
afta its size chizzles.
.SS "\s-1EXPRESSIONS\s0"
.IX Subsection "EXPRESSIONS"
Expressions is aiiight Perl expressions, up in fact, they is Perl blocks \-
which means you could use multiple lines n' statements:
.PP
.Vb 8
\&   scale keep {
\&      again n' again n' again 3600;
\&      if (localtime now)[6]) {
\&         return load "$HOME/weekday.png";
\&      } else {
\&         return load "$HOME/sunday.png";
\&      }
\&   }
.Ve
.PP
This inner expression is evaluated once per minute (and whenever the
terminal window is resized). Well shiiiit, it sets \fIsunday.png\fR as background on
Sundays, n' \fIweekday.png\fR on all other days.
.PP
Fortunately, we expect dat most expressions is ghon be much simpler, with
lil Perl knowledge needed.
.PP
Basically, you always start wit a gangbangin' function dat \*(L"generates\*(R" a image
object, like fuckin \f(CW\*(C`load\*(C'\fR, which loadz a image from disk, or \f(CW\*(C`root\*(C'\fR, which
returns tha root window background image:
.PP
.Vb 1
\&   load "$HOME/mypic.png"
.Ve
.PP
Da path is probably specified as a quoted strang (the exact rulez can be
found up in tha perlop manpage). Da \fI\f(CI$HOME\fI\fR all up in tha beginnin of the
strin is expanded ta tha home directory.
.PP
Then you prepend one or mo' modifiers or filterin expressions, such as
\&\f(CW\*(C`scale\*(C'\fR:
.PP
.Vb 1
\&   scale load "$HOME/mypic.png"
.Ve
.PP
Just like a mathematical expression wit functions, you should read these
expressions from right ta left, as tha \f(CW\*(C`load\*(C'\fR is evaluated first, and
its result becomes tha argument ta tha \f(CW\*(C`scale\*(C'\fR function.
.PP
Many operators also allow some parametas precedin tha input image
that modify its behaviour. Shiiit, dis aint no joke. For example, \f(CW\*(C`scale\*(C'\fR without any additional
arguments scalez tha image ta size of tha terminal window. If you specify
an additionizzle argument, it uses it as a scale factor (multiply by 100 to
get a cementage):
.PP
.Vb 1
\&   scale 2, load "$HOME/mypic.png"
.Ve
.PP
This enlarges tha image by a gangbangin' factor of 2 (200%) fo' realz. As you can see, \f(CW\*(C`scale\*(C'\fR
has now two arguments, tha \f(CW200\fR n' tha \f(CW\*(C`load\*(C'\fR expression, while
\&\f(CW\*(C`load\*(C'\fR only has one argument fo' realz. Arguments is separated from each other by
commas.
.PP
Scale also accepts two arguments, which is then separate factors fo' both
horizontal n' vertical dimensions. For example, dis halves tha image
width n' doublez tha image height:
.PP
.Vb 1
\&   scale 0.5, 2, load "$HOME/mypic.png"
.Ve
.PP
\&\s-1IF\s0 you hook up these expressions, you might suffer from some sluggishness,
because each time tha terminal is resized, it loadz tha \s-1PNG\s0 image again
and scalez dat shit. Right back up in yo muthafuckin ass. Scalin is probably fast (and unavoidable) yo, but loadin the
image can be like time consuming. This is where \f(CW\*(C`keep\*(C'\fR comes up in handy:
.PP
.Vb 1
\&   scale 0.5, 2, keep { load "$HOME/mypic.png" }
.Ve
.PP
Da \f(CW\*(C`keep\*(C'\fR operator executes all tha statements inside tha braces only
once, or when it be thinkin tha outcome might chizzle. In other cases it
returns tha last value computed by tha brace block.
.PP
This means dat tha \f(CW\*(C`load\*(C'\fR is only executed once, which make it much
fasta yo, but also means dat mo' memory is bein used, cuz tha loaded
image must be kept up in memory at all times. In dis expression, the
trade-off is likely worth dat shit.
.PP
But back ta effects: Other effects than scalin is also readily
available, fo' example, you can tile tha image ta fill tha whole window,
instead of resizin it:
.PP
.Vb 1
\&   tile keep { load "$HOME/mypic.png" }
.Ve
.PP
In fact, images returned by \f(CW\*(C`load\*(C'\fR is up in \f(CW\*(C`tile\*(C'\fR mode by default, so the
\&\f(CW\*(C`tile\*(C'\fR operator is kind of superfluous.
.PP
Another common effect is ta mirror tha image, so dat tha same edges
touch:
.PP
.Vb 1
\&   mirror keep { load "$HOME/mypic.png" }
.Ve
.PP
Another common background expression is:
.PP
.Vb 1
\&   rootalign root
.Ve
.PP
This one first takes a snapshot of tha screen background image, n' then
moves it ta tha upper left corner of tha screen (as opposed ta tha upper
left corner of tha terminal window)\- tha result is pseudo-transparency:
the image seems ta be static while tha window is moved around.
.SS "\s-1COLOUR SPECIFICATIONS\s0"
.IX Subsection "COLOUR SPECIFICATIONS"
Whenever a operator expects a \*(L"colour\*(R", then dis can be specified up in one
of two ways: Either as strang wit a X11 colour justification, such as:
.PP
.Vb 4
\&   "red"               # named colour
\&   "#f00"              # simple rgb
\&   "[50]red"           # red wit 50% alpha
\&   "TekHVC:300/50/50"  # anythang goes
.Ve
.PP
\&\s-1OR\s0 as a array reference wit one, three or four components:
.PP
.Vb 3
\&   [0.5]               # 50% gray, 100% alpha
\&   [0.5, 0, 0]         # dark red, no chronic or blur, 100% alpha
\&   [0.5, 0, 0, 0.7]    # same wit explicit 70% alpha
.Ve
.SS "\s-1CACHING AND SENSITIVITY\s0"
.IX Subsection "CACHING AND SENSITIVITY"
Since some operations (like fuckin \f(CW\*(C`load\*(C'\fR n' \f(CW\*(C`blur\*(C'\fR) can take a long-ass time,
cachin thangs up in dis biatch can be straight-up blingin fo' a smooth operation. I aint talkin' bout chicken n' gravy biatch. Cachin can
also be useful ta reduce memory usage, though, fo' example, when a image
is cached by \f(CW\*(C`load\*(C'\fR, it could be shared by multiple terminal windows
runnin inside urxvtd.
.PP
\fI\f(CI\*(C`keep { ... }\*(C'\fI caching\fR
.IX Subsection "keep { ... } caching"
.PP
Da most blingin way ta cache high-rollin' operations is ta use \f(CW\*(C`keep {
\&... }\*(C'\fR. Da \f(CW\*(C`keep\*(C'\fR operator takes a funky-ass block of multiple statements enclosed
by \f(CW\*(C`{}\*(C'\fR n' keeps tha return value up in memory.
.PP
An expression can be \*(L"sensitive\*(R" ta various external events, such as
scalin or movin tha window, root background chizzlez n' timers. Right back up in yo muthafuckin ass. Simply
usin a expression (like fuckin \f(CW\*(C`scale\*(C'\fR without parameters) dat dependz on
certain changin joints (called \*(L"variables\*(R"), or rockin dem variables
directly, will cook up a expression sensitizzle ta these events \- fo' example,
usin \f(CW\*(C`scale\*(C'\fR or \f(CW\*(C`TW\*(C'\fR will make tha expression sensitizzle ta tha terminal
size, n' thus ta resizin events.
.PP
When such a event happens, \f(CW\*(C`keep\*(C'\fR will automatically trigger a
reevaluation of tha whole expression wit tha freshly smoked up value of tha expression.
.PP
\&\f(CW\*(C`keep\*(C'\fR is most useful fo' high-rollin' operations, like fuckin \f(CW\*(C`blur\*(C'\fR:
.PP
.Vb 1
\&   rootalign keep { blur 20, root }
.Ve
.PP
This cook up a funky-ass blurred copy of tha root background once, n' on subsequent
calls, just root-aligns dat shit. Right back up in yo muthafuckin ass. Since \f(CW\*(C`blur\*(C'\fR is probably like slow and
\&\f(CW\*(C`rootalign\*(C'\fR is like fast, dis trades extra memory (for tha cached
blurred pixmap) wit speed (blur only need ta be redone when root
changes).
.PP
\fI\f(CI\*(C`load\*(C'\fI caching\fR
.IX Subsection "load caching"
.PP
Da \f(CW\*(C`load\*(C'\fR operator itself do not keep images up in memory yo, but as long as
the image is still up in memory, \f(CW\*(C`load\*(C'\fR will use tha in-memory image instead
of loadin it freshly from disk.
.PP
That means dat dis expression:
.PP
.Vb 1
\&   keep { load "$HOME/path..." }
.Ve
.PP
Not only caches tha image up in memory, other terminal instances dat try to
\&\f(CW\*(C`load\*(C'\fR it can reuse dat in-memory copy.
.SH "REFERENCE"
.IX Header "REFERENCE"
.SS "\s-1COMMAND LINE SWITCHES\s0"
.IX Subsection "COMMAND LINE SWITCHES"
.IP "\-\-background\-expr perl-expression" 4
.IX Item "--background-expr perl-expression"
Specifies tha Perl expression ta evaluate.
.IP "\-\-background\-border" 4
.IX Item "--background-border"
By default, tha expression creates a image dat fills tha full window,
overwritin bordaz n' any other areas, like fuckin tha scrollbar.
.Sp
Specifyin dis flag chizzlez tha behaviour, so dat tha image only
replaces tha background of tha characta area.
.IP "\-\-background\-interval seconds" 4
.IX Item "--background-interval seconds"
Since some operations up in tha underlyin XRender extension can effectively
freeze yo' X\-server fo' prolonged time, dis extension enforces a minimum
time between thugged-out shit, which is normally bout 0.1 seconds.
.Sp
If you wanna do thugged-out shiznit mo' often, you can decrease dis safety
interval wit dis switch.
.SS "\s-1PROVIDERS/GENERATORS\s0"
.IX Subsection "PROVIDERS/GENERATORS"
These functions provide a image, by loadin it from disk, grabbin it
from tha root screen or by simply generatin dat shit. They is used as starting
points ta git a image you can play with.
.ie n .IP "load $path" 4
.el .IP "load \f(CW$path\fR" 4
.IX Item "load $path"
Loadz tha image all up in tha given \f(CW$path\fR. Da image is set ta plane tiling
mode.
.Sp
If tha image be already up in memory (e.g. cuz another terminal instance
uses it), then tha in-memory copy is returned instead.
.ie n .IP "load_uc $path" 4
.el .IP "load_uc \f(CW$path\fR" 4
.IX Item "load_uc $path"
Load uncached \- same as load yo, but do not cache tha image, which means it
is \fIalways\fR loaded from tha filesystem again, even if another copy of it
is up in memory all up in tha time.
.IP "root" 4
.IX Item "root"
Returns tha root window pixmap, dat is, hopefully, tha background image
of yo' screen.
.Sp
This function make yo' expression root sensitive, dat means it will be
reevaluated when tha bg image chizzles.
.ie n .IP "solid $colour" 4
.el .IP "solid \f(CW$colour\fR" 4
.IX Item "solid $colour"
.PD 0
.ie n .IP "solid $width, $height, $colour" 4
.el .IP "solid \f(CW$width\fR, \f(CW$height\fR, \f(CW$colour\fR" 4
.IX Item "solid $width, $height, $colour"
.PD
Creates a freshly smoked up image n' straight-up fills it wit tha given colour. Shiiit, dis aint no joke. The
image is set ta tilin mode.
.Sp
If \f(CW$width\fR n' \f(CW$height\fR is omitted, it creates a 1x1 image, which is
useful fo' solid backgroundz or fo' use up in filterin effects.
.ie n .IP "clone $img" 4
.el .IP "clone \f(CW$img\fR" 4
.IX Item "clone $img"
Returns a exact copy of tha image. This is useful if you wanna have
multiple copiez of tha same image ta apply different effects to.
.ie n .IP "merge $img ..." 4
.el .IP "merge \f(CW$img\fR ..." 4
.IX Item "merge $img ..."
Takes any number of images n' merges dem together, bustin a single
image containin dem all. Da tilin mode of tha straight-up original gangsta image is used as
the tilin mode of tha resultin image.
.Sp
This function is called automatically when a expression returns multiple
images.
.SS "\s-1TILING MODES\s0"
.IX Subsection "TILING MODES"
Da followin operators modify tha tilin mode of a image, dat is, the
way dat pixels outside tha image area is painted when tha image is used.
.ie n .IP "tile $img" 4
.el .IP "tile \f(CW$img\fR" 4
.IX Item "tile $img"
Tilez tha whole plane wit tha image n' returns dis freshly smoked up image \- or in
other lyrics, it returns a cold-ass lil copy of tha image up in plane tilin mode.
.Sp
Example: load a image n' tile it over tha background, without
resizing. Da \f(CW\*(C`tile\*(C'\fR call is superfluous cuz \f(CW\*(C`load\*(C'\fR already defaults
to tilin mode.
.Sp
.Vb 1
\&   tile load "mybg.png"
.Ve
.ie n .IP "mirror $img" 4
.el .IP "mirror \f(CW$img\fR" 4
.IX Item "mirror $img"
Similar ta tile yo, but reflects tha image each time it uses a freshly smoked up copy, so
that top edges always bust a nut on top edges, right edges always bust a nut on right
edges n' so on (with aiiight tiling, left edges always bust a nut on right edges
and top always bust a nut on bottom edges).
.Sp
Example: load a image n' mirror it over tha background, avoidin sharp
edges all up in tha image bordaz all up in tha expense of mirrorin tha image itself
.Sp
.Vb 1
\&   mirror load "mybg.png"
.Ve
.ie n .IP "pad $img" 4
.el .IP "pad \f(CW$img\fR" 4
.IX Item "pad $img"
Takes a image n' modifies it so dat all pixels outside tha image area
become transparent. This mode is most useful when you wanna place an
image over another image or tha background colour while leavin all
background pixels outside tha image unchanged.
.Sp
Example: load a image n' display it up in tha upper left corner n' shit. Da rest
of tha space is left \*(L"empty\*(R" (transparent or whatever yo' compositor do
in alpha mode, else background colour).
.Sp
.Vb 1
\&   pad load "mybg.png"
.Ve
.ie n .IP "extend $img" 4
.el .IP "extend \f(CW$img\fR" 4
.IX Item "extend $img"
Extendz tha image over tha whole plane, rockin tha closest pixel up in the
area outside tha image. This mode is mostly useful when you use mo' complex
filterin operations n' want tha pixels outside tha image ta have the
same joints as tha pixels near tha edge.
.Sp
Example: just fo' curiosity, how tha fuck do dis pixel extension shiznit work?
.Sp
.Vb 1
\&   extend move 50, 50, load "mybg.png"
.Ve
.SS "\s-1VARIABLE VALUES\s0"
.IX Subsection "VARIABLE VALUES"
Da followin functions provide variable data like fuckin tha terminal window
dimensions. They is not (Perl\-) variables, they just return shiznit that
varies. Put ya muthafuckin choppers up if ya feel dis! Most of dem make yo' expression sensitizzle ta some events, for
example rockin \f(CW\*(C`TW\*(C'\fR (terminal width) means yo' expression is evaluated
again when tha terminal is resized.
.IP "\s-1TX\s0" 4
.IX Item "TX"
.PD 0
.IP "\s-1TY\s0" 4
.IX Item "TY"
.PD
Return tha X n' Y coordinatez of tha terminal window (the terminal
window is tha full window by default, n' tha characta area only when in
border-respect mode).
.Sp
Usin these functions make yo' expression sensitizzle ta window moves.
.Sp
These functions is mainly useful ta align images ta tha root window.
.Sp
Example: load a image n' align it so it looks as if anchored ta the
background (thatz exactly what tha fuck \f(CW\*(C`rootalign\*(C'\fR do btw.):
.Sp
.Vb 1
\&   move \-TX, \-TY, keep { load "mybg.png" }
.Ve
.IP "\s-1TW\s0" 4
.IX Item "TW"
.PD 0
.IP "\s-1TH\s0" 4
.IX Item "TH"
.PD
Return tha width (\f(CW\*(C`TW\*(C'\fR) n' height (\f(CW\*(C`TH\*(C'\fR) of tha terminal window (the
terminal window is tha full window by default, n' tha characta area only
when up in border-respect mode).
.Sp
Usin these functions make yo' expression sensitizzle ta window resizes.
.Sp
These functions is mainly useful ta scale images, or ta clip images to
the window size ta conserve memory.
.Sp
Example: take tha screen background, clip it ta tha window size, blur it a
bit, align it ta tha window posizzle n' use it as background.
.Sp
.Vb 1
\&   clip move \-TX, \-TY, keep { blur 5, root }
.Ve
.IP "\s-1FOCUS\s0" 4
.IX Item "FOCUS"
Returns a funky-ass boolean indicatin whether tha terminal window has keyboard
focus, up in which case it returns true.
.Sp
Usin dis function make yo' expression sensitizzle ta focus chizzles.
.Sp
A common use case is ta fade tha background image when tha terminal loses
focus, often together wit tha \f(CW\*(C`\-fade\*(C'\fR command line option. I aint talkin' bout chicken n' gravy biatch. In fact,
there be a special function fo' just dat use case: \f(CW\*(C`focus_fade\*(C'\fR.
.Sp
Example: use two entirely different background images, dependin on
whether tha window has focus.
.Sp
.Vb 1
\&   FOCUS , biatch? keep { load "has_focus.jpg" } : keep { load "no_focus.jpg" }
.Ve
.IP "now" 4
.IX Item "now"
Returns tha current time as (fractional) secondz since tha epoch.
.Sp
Usin dis expression do \fInot\fR make yo' expression sensitizzle ta time,
but tha next two functions do.
.ie n .IP "again $seconds" 4
.el .IP "again \f(CW$seconds\fR" 4
.IX Item "again $seconds"
When dis function is used tha expression is ghon be reevaluated again n' again n' again in
\&\f(CW$seconds\fR seconds.
.Sp
Example: load some image n' rotate it accordin ta tha time of dizzle (as if it were
the minute pointa of a cold-ass lil clock). Update dis image every last muthafuckin minute.
.Sp
.Vb 2
\&   again n' again n' again 60;
\&   rotate 50, 50, (now % 86400) * \-72 / 8640, scale keep { load "myclock.png" }
.Ve
.ie n .IP "counta $seconds" 4
.el .IP "counta \f(CW$seconds\fR" 4
.IX Item "counta $seconds"
Like \f(CW\*(C`again\*(C'\fR yo, but also returns a increasin counta value, startin at
0, which might be useful fo' some simple animation effects.
.SS "\s-1SHAPE CHANGING OPERATORS\s0"
.IX Subsection "SHAPE CHANGING OPERATORS"
Da followin operators modify tha shape, size or posizzle of tha image.
.ie n .IP "clip $img" 4
.el .IP "clip \f(CW$img\fR" 4
.IX Item "clip $img"
.PD 0
.ie n .IP "clip $width, $height, $img" 4
.el .IP "clip \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "clip $width, $height, $img"
.ie n .IP "clip $x, $y, $width, $height, $img" 4
.el .IP "clip \f(CW$x\fR, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "clip $x, $y, $width, $height, $img"
.PD
Clips a image ta tha given rectangle. If tha rectangle is outside the
image area (e.g. when \f(CW$x\fR or \f(CW$y\fR is negative) or tha rectangle is
larger than tha image, then tha tilin mode defines how tha fuck tha extra pixels
will be filled.
.Sp
If \f(CW$x\fR n' \f(CW$y\fR is missing, then \f(CW0\fR be assumed fo' both.
.Sp
If \f(CW$width\fR n' \f(CW$height\fR is missing, then tha window size will be
assumed.
.Sp
Example: load a image, blur it, n' clip it ta tha window size ta save
memory.
.Sp
.Vb 1
\&   clip keep { blur 10, load "mybg.png" }
.Ve
.ie n .IP "scale $img" 4
.el .IP "scale \f(CW$img\fR" 4
.IX Item "scale $img"
.PD 0
.ie n .IP "scale $size_factor, $img" 4
.el .IP "scale \f(CW$size_factor\fR, \f(CW$img\fR" 4
.IX Item "scale $size_factor, $img"
.ie n .IP "scale $width_factor, $height_factor, $img" 4
.el .IP "scale \f(CW$width_factor\fR, \f(CW$height_factor\fR, \f(CW$img\fR" 4
.IX Item "scale $width_factor, $height_factor, $img"
.PD
Scalez tha image by tha given factors up in horizontal
(\f(CW$width\fR) n' vertical (\f(CW$height\fR) direction.
.Sp
If only one factor is given, it is used fo' both directions.
.Sp
If no factors is given, scalez tha image ta tha window size without
keepin aspect.
.ie n .IP "resize $width, $height, $img" 4
.el .IP "resize \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "resize $width, $height, $img"
Resizes tha image ta exactly \f(CW$width\fR times \f(CW$height\fR pixels.
.ie n .IP "fit $img" 4
.el .IP "fit \f(CW$img\fR" 4
.IX Item "fit $img"
.PD 0
.ie n .IP "fit $width, $height, $img" 4
.el .IP "fit \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "fit $width, $height, $img"
.PD
Fits tha image tha fuck into tha given \f(CW$width\fR n' \f(CW$height\fR without changing
aspect, or tha terminal size. That means it is ghon be shrunk or grown until
the whole image fits tha fuck into tha given area, possibly leavin borders.
.ie n .IP "cover $img" 4
.el .IP "cover \f(CW$img\fR" 4
.IX Item "cover $img"
.PD 0
.ie n .IP "cover $width, $height, $img" 4
.el .IP "cover \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "cover $width, $height, $img"
.PD
Similar ta \f(CW\*(C`fit\*(C'\fR yo, but shrinks or grows until all of tha area is covered
by tha image, so instead of potentially leavin borders, it will cut off
image data dat don't fit.
.ie n .IP "move $dx, $dy, $img" 4
.el .IP "move \f(CW$dx\fR, \f(CW$dy\fR, \f(CW$img\fR" 4
.IX Item "move $dx, $dy, $img"
Moves tha image by \f(CW$dx\fR pixels up in tha horizontal, n' \f(CW$dy\fR pixels in
the vertical.
.Sp
Example: move tha image right by 20 pixels n' down by 30.
.Sp
.Vb 1
\&   move 20, 30, ...
.Ve
.ie n .IP "align $xalign, $yalign, $img" 4
.el .IP "align \f(CW$xalign\fR, \f(CW$yalign\fR, \f(CW$img\fR" 4
.IX Item "align $xalign, $yalign, $img"
Aligns tha image accordin ta a gangbangin' factor \- \f(CW0\fR means tha image is moved to
the left or top edge (for \f(CW$xalign\fR or \f(CW$yalign\fR), \f(CW0.5\fR means it is
exactly centered n' \f(CW1\fR means it touches tha right or bottom edge.
.Sp
Example: remove any visible border round a image, centa it vertically but move
it ta tha right hand side.
.Sp
.Vb 1
\&   align 1, 0.5, pad $img
.Ve
.ie n .IP "centa $img" 4
.el .IP "centa \f(CW$img\fR" 4
.IX Item "centa $img"
.PD 0
.ie n .IP "centa $width, $height, $img" 4
.el .IP "centa \f(CW$width\fR, \f(CW$height\fR, \f(CW$img\fR" 4
.IX Item "centa $width, $height, $img"
.PD
Centas tha image, i.e. tha centa of tha image is moved ta tha centa of
the terminal window (or tha box specified by \f(CW$width\fR n' \f(CW$height\fR if
given).
.Sp
Example: load a image n' centa dat shit.
.Sp
.Vb 1
\&  centa keep { pad load "mybg.png" }
.Ve
.ie n .IP "rootalign $img" 4
.el .IP "rootalign \f(CW$img\fR" 4
.IX Item "rootalign $img"
Moves tha image so dat it appears glued ta tha screen as opposed ta the
window. This gives tha illusion of a larger area behind tha window. Well shiiiit, it is
exactly equivalent ta \f(CW\*(C`move \-TX, \-TY\*(C'\fR, dat is, it moves tha image ta the
top left of tha screen.
.Sp
Example: load a funky-ass background image, put it up in mirror mode n' root align dat shit.
.Sp
.Vb 1
\&   rootalign keep { mirror load "mybg.png" }
.Ve
.Sp
Example: take tha screen background n' align it, givin tha illusion of
transparency as long as tha window aint up in front of other windows.
.Sp
.Vb 1
\&   rootalign root
.Ve
.ie n .IP "rotate $center_x, $center_y, $degrees, $img" 4
.el .IP "rotate \f(CW$center_x\fR, \f(CW$center_y\fR, \f(CW$degrees\fR, \f(CW$img\fR" 4
.IX Item "rotate $center_x, $center_y, $degrees, $img"
Rotates tha image clockwise by \f(CW$degrees\fR degrees, round tha point at
\&\f(CW$center_x\fR n' \f(CW$center_y\fR (specified as factor of image width/height).
.Sp
Example: rotate tha image by 90 degrees round its center.
.Sp
.Vb 1
\&   rotate 0.5, 0.5, 90, keep { load "$HOME/mybg.png" }
.Ve
.SS "\s-1COLOUR MODIFICATIONS\s0"
.IX Subsection "COLOUR MODIFICATIONS"
Da followin operators chizzle tha pixelz of tha image.
.ie n .IP "tint $color, $img" 4
.el .IP "tint \f(CW$color\fR, \f(CW$img\fR" 4
.IX Item "tint $color, $img"
Tints tha image up in tha given colour.
.Sp
Example: tint tha image red.
.Sp
.Vb 1
\&   tint "red", load "rgb.png"
.Ve
.Sp
Example: tha same yo, but specify tha colour by component.
.Sp
.Vb 1
\&   tint [1, 0, 0], load "rgb.png"
.Ve
.ie n .IP "shade $factor, $img" 4
.el .IP "shade \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "shade $factor, $img"
Shade tha image by tha given factor.
.ie n .IP "contrast $factor, $img" 4
.el .IP "contrast \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "contrast $factor, $img"
.PD 0
.ie n .IP "contrast $r, $g, $b, $img" 4
.el .IP "contrast \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$img\fR" 4
.IX Item "contrast $r, $g, $b, $img"
.ie n .IP "contrast $r, $g, $b, $a, $img" 4
.el .IP "contrast \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR, \f(CW$img\fR" 4
.IX Item "contrast $r, $g, $b, $a, $img"
.PD
Adjusts tha \fIcontrast\fR of a image.
.Sp
Da first form applies a single \f(CW$factor\fR ta red, chronic n' blue, the
second form applies separate factors ta each colour channel, n' tha last
form includes tha alpha channel.
.Sp
Values from 0 ta 1 lower tha contrast, joints higher than 1 increase the
contrast.
.Sp
Cuz of limitations up in tha underlyin XRender extension, lowerin contrast
also reduces brightness, while increasin contrast currently also
increases brightness.
.ie n .IP "brightnizz $bias, $img" 4
.el .IP "brightnizz \f(CW$bias\fR, \f(CW$img\fR" 4
.IX Item "brightnizz $bias, $img"
.PD 0
.ie n .IP "brightnizz $r, $g, $b, $img" 4
.el .IP "brightnizz \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$img\fR" 4
.IX Item "brightnizz $r, $g, $b, $img"
.ie n .IP "brightnizz $r, $g, $b, $a, $img" 4
.el .IP "brightnizz \f(CW$r\fR, \f(CW$g\fR, \f(CW$b\fR, \f(CW$a\fR, \f(CW$img\fR" 4
.IX Item "brightnizz $r, $g, $b, $a, $img"
.PD
Adjusts tha brightnizz of a image.
.Sp
Da first form applies a single \f(CW$bias\fR ta red, chronic n' blue, the
second form applies separate biases ta each colour channel, n' tha last
form includes tha alpha channel.
.Sp
Values less than 0 reduce brightness, while joints larger than 0 increase
it. Useful range is from \-1 ta 1 \- tha forma thangs up in dis biatch up in a funky-ass black, the
latta up in a white picture.
.Sp
Cuz of idiosyncrasies up in tha underlyin XRender extension, biases less
than zero can be \fIvery\fR slow.
.Sp
Yo ass can also try tha experimental(!) \f(CW\*(C`muladd\*(C'\fR operator.
.ie n .IP "muladd $mul, $add, $img # \s-1EXPERIMENTAL\s0" 4
.el .IP "muladd \f(CW$mul\fR, \f(CW$add\fR, \f(CW$img\fR # \s-1EXPERIMENTAL\s0" 4
.IX Item "muladd $mul, $add, $img # EXPERIMENTAL"
First multiplies tha pixels by \f(CW$mul\fR, then addz \f(CW$add\fR. This can be used
to implement brightnizz n' contrast all up in tha same time, wit a wider value
range than contrast n' brightnizz operators.
.Sp
Cuz of a shitload of bugs up in XRender implementations, it can also introduce a
number of visual artifacts.
.Sp
Example: increase contrast by a gangbangin' factor of \f(CW$c\fR without changin image
brightnizz too much.
.Sp
.Vb 1
\&   muladd $c, (1 \- $c) * 0.5, $img
.Ve
.ie n .IP "blur $radius, $img" 4
.el .IP "blur \f(CW$radius\fR, \f(CW$img\fR" 4
.IX Item "blur $radius, $img"
.PD 0
.ie n .IP "blur $radius_horz, $radius_vert, $img" 4
.el .IP "blur \f(CW$radius_horz\fR, \f(CW$radius_vert\fR, \f(CW$img\fR" 4
.IX Item "blur $radius_horz, $radius_vert, $img"
.PD
Gaussian-blurs tha image wit (roughly) \f(CW$radius\fR pixel radius. Da radii
can also be specified separately.
.Sp
Blurrin is often \fIvery\fR slow, at least compared or other
operators. Larger blur radii is slower than smalla ones, too, so if you
don't wanna freeze yo' screen fo' long times, start fuckin wit with
low joints fo' radius (<5).
.ie n .IP "focus_fade $img" 4
.el .IP "focus_fade \f(CW$img\fR" 4
.IX Item "focus_fade $img"
.PD 0
.ie n .IP "focus_fade $factor, $img" 4
.el .IP "focus_fade \f(CW$factor\fR, \f(CW$img\fR" 4
.IX Item "focus_fade $factor, $img"
.ie n .IP "focus_fade $factor, $color, $img" 4
.el .IP "focus_fade \f(CW$factor\fR, \f(CW$color\fR, \f(CW$img\fR" 4
.IX Item "focus_fade $factor, $color, $img"
.PD
Fades tha image by tha given factor (and colour) when focus is lost (the
same as tha \f(CW\*(C`\-fade\*(C'\fR/\f(CW\*(C`\-fadecolor\*(C'\fR command line options, which also supply
the default joints fo' \f(CW\*(C`factor\*(C'\fR n' \f(CW$color\fR. Unlike wit \f(CW\*(C`\-fade\*(C'\fR, the
\&\f(CW$factor\fR be a real value, not a cementage value (that is, 0..1, not
0..100).
.Sp
Example: do tha right thang when focus fadin is requested.
.Sp
.Vb 1
\&   focus_fade load "mybg.jpg";
.Ve
.SS "\s-1OTHER STUFF\s0"
.IX Subsection "OTHER STUFF"
Anythang dat didn't fit any of tha other categories, even afta applying
force n' closin our eyes.
.IP "keep { ... }" 4
.IX Item "keep { ... }"
This operator takes a cold-ass lil code block as argument, dat is, one or more
statements enclosed by braces.
.Sp
Da trick is dat dis code block is only evaluated when tha outcome
changes \- on other calls tha \f(CW\*(C`keep\*(C'\fR simply returns tha image it computed
previously (yes, it should only be used wit images). Or up in other lyrics,
\&\f(CW\*(C`keep\*(C'\fR \fIcaches\fR tha result of tha code block so it don't need ta be
computed again.
.Sp
This can be mad useful ta avoid refuckin wit slow operations \- for
example, if yo' background expression takes tha root background, blurs it
and then root-aligns it it would gotta blur tha root background on every
window move or resize.
.Sp
Another example is \f(CW\*(C`load\*(C'\fR, which can be like slow.
.Sp
In fact, urxvt itself encloses tha whole expression up in some kind of
\&\f(CW\*(C`keep\*(C'\fR block so it only is reevaluated as required.
.Sp
Puttin tha blur tha fuck into a \f(CW\*(C`keep\*(C'\fR block will make shizzle tha blur is only done
once, while tha \f(CW\*(C`rootalign\*(C'\fR is still done each time tha window moves.
.Sp
.Vb 1
\&   rootalign keep { blur 10, root }
.Ve
.Sp
This leaves tha question of how tha fuck ta force reevaluation of tha block,
in case tha root background chizzles: If expression inside tha block
is sensitizzle ta some event (root background chizzles, window geometry
changes), then it is ghon be reevaluated automatically as needed.
