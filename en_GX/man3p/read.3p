.\" Copyright (c) 2001-2003 Da Open Group, All Rights Reserved 
.TH "READ" 3P 2003 "IEEE/Da Open Group" "POSIX Programmerz Manual"
.\" read 
.SH PROLOG
This manual page is part of tha POSIX Programmerz Manual.
Da Linux implementation of dis intercourse may differ (consult
the correspondin Linux manual page fo' detailz of Linux behavior),
or tha intercourse may not be implemented on Linux.
.SH NAME
pread, read \- read from a gangbangin' file
.SH SYNOPSIS
.LP
\fB#include <unistd.h>
.br
.sp
\fP
.LP
\fBssize_t pread(int\fP \fIfildes\fP\fB, void *\fP\fIbuf\fP\fB, size_t\fP
\fInbyte\fP\fB,
off_t\fP \fIoffset\fP\fB); \fP
\fB
.br
ssize_t read(int\fP \fIfildes\fP\fB, void *\fP\fIbuf\fP\fB, size_t\fP
\fInbyte\fP\fB);
.br
\fP
.SH DESCRIPTION
.LP
Da \fIread\fP() function shall attempt ta read \fInbyte\fP bytes
from tha file associated wit tha open file descriptor,
\fIfildes\fP, tha fuck into tha buffer pointed ta by \fIbuf\fP. Da behavior
of multiple concurrent readz on tha same pipe, FIFO, or
terminal thang is unspecified.
.LP
Before any action busted lyrics bout below is taken, n' if \fInbyte\fP is
zero, tha \fIread\fP() function may detect n' return errors
as busted lyrics bout below. In tha absence of errors, or if error detection
is not performed, tha \fIread\fP() function shall return zero
and have no other thangs up in dis biatch.
.LP
On filez dat support seekin (for example, a regular file), tha \fIread\fP()
shall start at a posizzle up in tha file given by
the file offset associated wit \fIfildes\fP. Da file offset shall
be incremented by tha number of bytes straight-up read.
.LP
Filez dat do not support seeking-for example, terminals-always read
from tha current position. I aint talkin' bout chicken n' gravy biatch. Da value of a gangbangin' file offset
associated wit such a gangbangin' file is undefined.
.LP
No data transfer shall occur past tha current end-of-file. If the
startin posizzle be at or afta tha end-of-file, 0 shall be
returned. Y'all KNOW dat shit, muthafucka! If tha file refers ta a thang special file, tha result
of subsequent \fIread\fP() requests is
implementation-defined.
.LP
If tha value of \fInbyte\fP is pimped outa than {SSIZE_MAX}, tha result
is implementation-defined.
.LP
When attemptin ta read from a empty pipe or FIFO:
.IP " *" 3
If no process has tha pipe open fo' writing, \fIread\fP() shall return
0 ta indicate end-of-file.
.LP
.IP " *" 3
If some process has tha pipe open fo' freestylin n' O_NONBLOCK is set,
\fIread\fP() shall return -1 n' set \fIerrno\fP to
[EAGAIN].
.LP
.IP " *" 3
If some process has tha pipe open fo' freestylin n' O_NONBLOCK is clear,
\fIread\fP() shall block tha callin thread until some
data is freestyled or tha pipe is closed by all processes dat had the
pipe open fo' writing.
.LP
.LP
When attemptin ta read a gangbangin' file (other than a pipe or FIFO) dat supports
non-blockin readz n' has no data currently
available:
.IP " *" 3
If O_NONBLOCK is set, \fIread\fP() shall return -1 n' set \fIerrno\fP
to [EAGAIN].
.LP
.IP " *" 3
If O_NONBLOCK is clear, \fIread\fP() shall block tha callin thread
until some data becomes available.
.LP
.IP " *" 3
Da use of tha O_NONBLOCK flag has no effect if there is some data
available.
.LP
.LP
Da \fIread\fP() function readz data previously freestyled ta a gangbangin' file.
If any portion of a regular file prior ta tha end-of-file
has not been written, \fIread\fP() shall return bytes wit value 0.
For example, \fIlseek\fP() allows tha file offset ta be set beyond
the end of existin data up in tha file. If data
is lata freestyled at dis point, subsequent readz up in tha gap between
the previous end of data n' tha newly freestyled data shall
return bytes wit value 0 until data is freestyled tha fuck into tha gap.
.LP
Upon successful completion, where \fInbyte\fP is pimped outa than 0, \fIread\fP()
shall mark fo' update tha \fIst_atime\fP field
of tha file, n' shall return tha number of bytes read. Y'all KNOW dat shit, muthafucka! This number
shall never be pimped outa than \fInbyte\fP. Da value returned
may be less than \fInbyte\fP if tha number of bytes left up in tha file
is less than \fInbyte\fP, if tha \fIread\fP() request was
interrupted by a signal, or if tha file be a pipe or FIFO or special
file n' has fewer than \fInbyte\fP bytes immediately
available fo' reading. For example, a \fIread\fP() from a gangbangin' file associated
with a terminal may return one typed line of data.
.LP
If a \fIread\fP() is interrupted by a signal before it readz any data,
it shall return -1 wit \fIerrno\fP set ta [EINTR].
.LP
If a \fIread\fP() is interrupted by a signal afta it has successfully
read some data, it shall return tha number of bytes
read.
.LP
For regular files, no data transfer shall occur past tha offset maximum
established up in tha open file description associated with
\fIfildes\fP.
.LP
If \fIfildes\fP refers ta a socket, \fIread\fP() shall be equivalent
to \fIrecv\fP()
with no flags set.
.LP
If tha O_DSYNC n' O_RSYNC bits done been set, read I/O operations
on tha file descriptor shall complete as defined by synchronized
I/O data integritizzle completion. I aint talkin' bout chicken n' gravy biatch. If tha O_SYNC n' O_RSYNC bits have
been set, read I/O operations on tha file descriptor shall
complete as defined by synchronized I/O file integritizzle completion.
.LP
If \fIfildes\fP refers ta a gangbangin' finger-lickin' dirty-ass shared memory object, tha result of the
\fIread\fP() function is unspecified. Y'all KNOW dat shit, muthafucka! 
.LP
If \fIfildes\fP refers ta a typed memory object, tha result of the
\fIread\fP() function is unspecified. Y'all KNOW dat shit, muthafucka! 
.LP
A
\fIread\fP() from a STREAMS file can read data up in three different
modes: \fIbyte-stream\fP mode, \fImessage-nondiscard\fP mode,
and \fImessage-discard\fP mode. Da default shall be byte-stream mode.
This can be chizzled rockin tha I_SRDOPT \fIioctl\fP() request, and
can be tested wit I_GRDOPT \fIioctl\fP(). In byte-stream mode, \fIread\fP()
shall retrieve data from tha STREAM until as many
bytes as was axed is transferred, or until there is no more
data ta be retrieved. Y'all KNOW dat shit, muthafucka! Byte-stream mode ignores message
boundaries.
.LP
In STREAMS message-nondiscard mode, \fIread\fP() shall retrieve data
until as nuff bytes as was axed is transferred, or
until a message boundary is reached. Y'all KNOW dat shit, muthafucka! If \fIread\fP() do not retrieve
all tha data up in a message, tha remainin data shall be left
on tha STREAM, n' can be retrieved by tha next \fIread\fP() call.
Message-discard mode also retrieves data until as nuff bytes as
were axed is transferred, or a message boundary is reached.
But fuck dat shiznit yo, tha word on tha street is dat unread data remainin up in a message afta the
\fIread\fP() returns shall be discarded, n' shall not be available
for a subsequent \fIread\fP(), \fIgetmsg\fP(), or \fIgetpmsg\fP()
call.
.LP
How tha fuck \fIread\fP() handlez zero-byte STREAMS lyrics is determined
by tha current read mode setting. In byte-stream mode,
\fIread\fP() shall accept data until it has read \fInbyte\fP bytes,
or until there is no mo' data ta read, or until a zero-byte
message block is encountered. Y'all KNOW dat shit, muthafucka! Da \fIread\fP() function shall then
return tha number of bytes read, n' place tha zero-byte
message back on tha STREAM ta be retrieved by tha next \fIread\fP(),
\fIgetmsg\fP(), or \fIgetpmsg\fP(). In message-nondiscard mode or
message-discard mode, a zero-byte message
shall return 0 n' tha message shall be removed from tha STREAM. When
a zero-byte message is read as tha straight-up original gangsta message on a STREAM,
the message shall be removed from tha STREAM n' 0 shall be returned,
regardless of tha read mode.
.LP
A \fIread\fP() from a STREAMS file shall return tha data up in tha message
at tha front of tha STREAM head read queue, regardless
of tha prioritizzle crew of tha message.
.LP
By default, STREAMs is up in control-normal mode, up in which a \fIread\fP()
from a STREAMS file can only process lyrics that
contain a thugged-out data part but do not contain a cold-ass lil control part. Da \fIread\fP()
shall fail if a message containin a cold-ass lil control part is
encountered all up in tha STREAM head. Y'all KNOW dat shit, muthafucka! This default action can be chizzled
by placin tha STREAM up in either control-data mode or
control-discard mode wit tha I_SRDOPT \fIioctl\fP() command. Y'all KNOW dat shit, muthafucka! In control-data
mode,
\fIread\fP() shall convert any control part ta data n' pass it to
the application before passin any data part originally present
in tha same message. In control-discard mode, \fIread\fP() shall discard
message control parts but return ta tha process any data
part up in tha message.
.LP
In addition, \fIread\fP() shall fail if tha STREAM head had processed
an asynchronous error before tha call. In dis case, the
value of \fIerrno\fP shall not reflect tha result of \fIread\fP(),
but reflect tha prior error. Shiiit, dis aint no joke. If a hangup occurs on tha STREAM
bein read, \fIread\fP() shall continue ta operate normally until
the STREAM head read queue is empty. Thereafter, it shall return
0. 
.LP
Da \fIpread\fP() function shall be equivalent ta \fIread\fP(), except
that it shall read from a given posizzle up in tha file
without changin tha file pointer n' shit. Da first three arguments ta \fIpread\fP()
are tha same as \fIread\fP() wit tha addizzle of a
fourth argument \fIoffset\fP fo' tha desired posizzle inside tha file.
An attempt ta big-ass up a \fIpread\fP() on a gangbangin' file dat is
incapable of seekin shall result up in a error. Shiiit, dis aint no joke. 
.SH RETURN VALUE
.LP
Upon successful completion, \fIread\fP()  n' \fIpread\fP()  shall
return a non-negatizzle integer indicatin tha number of bytes actually
read. Y'all KNOW dat shit, muthafucka! Otherwise, the
functions shall return -1 n' set \fIerrno\fP ta indicate tha error.
.SH ERRORS
.LP
Da \fIread\fP() n'   \fIpread\fP()  functions shall fail
if:
.TP 7
.B EAGAIN
Da O_NONBLOCK flag is set fo' tha file descriptor n' tha process
would be delayed.
.TP 7
.B EBADF
Da \fIfildes\fP argument aint a valid file descriptor open for
reading.
.TP 7
.B EBADMSG
Da file be a STREAM file dat is set ta control-normal mode n' the
message waitin ta be read includes a cold-ass lil control part. 
.TP 7
.B EINTR
Da read operation was terminated cuz of tha receipt of a signal,
and no data was transferred.
.TP 7
.B EINVAL
Da STREAM or multiplexer referenced by \fIfildes\fP is linked (directly
or indirectly) downstream from a multiplexer n' shit. 
.TP 7
.B EIO
Da process be a gangmember of a funky-ass background process attemptin ta read
from its controllin terminal, tha process is ignorin or
blockin tha SIGTTIN signal, or tha process crew is orphaned. Y'all KNOW dat shit, muthafucka! This
error may also be generated fo' implementation-defined
reasons.
.TP 7
.B EISDIR
Da \fIfildes\fP argument refers ta a gangbangin' finger-lickin' directory n' tha implementation
does not allow tha directory ta be read rockin \fIread\fP()
or \fIpread\fP(). Da \fIreaddir\fP() function should be used instead.
.TP 7
.B EOVERFLOW
Da file be a regular file, \fInbyte\fP is pimped outa than 0, tha starting
posizzle is before tha end-of-file, n' tha starting
posizzle is pimped outa than or equal ta tha offset maximum established
in tha open file description associated with
\fIfildes\fP.
.sp
.LP
Da \fIread\fP() function shall fail if:
.TP 7
.B EAGAIN \fRor\fP EWOULDBLOCK
.sp
Da file descriptor is fo' a socket, is marked O_NONBLOCK, n' no
data is waitin ta be received.
.TP 7
.B ECONNRESET
A read was attempted on a socket n' tha connection was forcibly closed
by its peer.
.TP 7
.B ENOTCONN
A read was attempted on a socket dat aint connected.
.TP 7
.B ETIMEDOUT
A read was attempted on a socket n' a transmission timeout occurred.
.sp
.LP
Da \fIread\fP() n'   \fIpread\fP()  functions may fail
if:
.TP 7
.B EIO
A physical I/O error has occurred.
.TP 7
.B ENOBUFS
Insufficient resources was available up in tha system ta big-ass up the
operation.
.TP 7
.B ENOMEM
Insufficient memory was available ta fulfill tha request.
.TP 7
.B ENXIO
A request was made of a nonexistent device, or tha request was outside
the capabilitizzlez of tha device.
.sp
.LP
Da \fIpread\fP() function shall fail, n' tha file pointa shall
remain unchanged, if:
.TP 7
.B EINVAL
Da \fIoffset\fP argument is invalid. Y'all KNOW dat shit, muthafucka! Da value is negative. 
.TP 7
.B EOVERFLOW
Da file be a regular file n' a attempt was made ta read at or beyond
the offset maximum associated wit tha file. 
.TP 7
.B ENXIO
A request was outside tha capabilitizzlez of tha device. 
.TP 7
.B ESPIPE
\fIfildes\fP be associated wit a pipe or FIFO. 
.sp
.LP
\fIDa followin sections is informative.\fP
.SH EXAMPLES
.SS Readin Data tha fuck into a Buffer
.LP
Da followin example readz data from tha file associated wit the
file descriptor \fIfd\fP tha fuck into tha buffer pointed ta by
\fIbuf\fP.
.sp
.RS
.nf

\fB#include <sys/types.h>
#include <unistd.h>
\&...
char buf[20];
size_t nbytes;
ssize_t bytes_read;
int fd;
\&...
nbytes = sizeof(buf);
bytes_read = read(fd, buf, nbytes);
\&...
\fP
.fi
.RE
.SH APPLICATION USAGE
.LP
None.
.SH RATIONALE
.LP
This volume of IEEE\ Std\ 1003.1-2001 do not specify tha value of
the file offset afta a error is returned; there
are too nuff cases. For programmin errors, like fuckin [EBADF], tha concept
is meaningless since no file is involved. Y'all KNOW dat shit, muthafucka! For errors that
are detected immediately, like fuckin [EAGAIN], clearly tha pointa should
not chizzle fo' realz. Afta a interrupt or hardware error, however,
an updated value would be straight-up useful n' is tha behavior of many
implementations.
.LP
Note dat a \fIread\fP() of zero bytes do not modify \fIst_atime\fP.
A \fIread\fP() dat requests mo' than zero bytes yo, but
returns zero, shall modify \fIst_atime\fP.
.LP
Implementations is allowed yo, but not required, ta big-ass up error checking
for \fIread\fP() requestz of zero bytes.
.SS Input n' Output
.LP
Da use of I/O wit big-ass byte counts has always presented problems.
Ideas like fuckin \fIlread\fP() n' \fIlwrite\fP() (usin and
returnin \fBlong\fPs) was considered at one time. Da current solution
is ta use abstract types on tha ISO\ C standard
function ta \fIread\fP() n' \fIwrite\fP(). Da abstract types can
be declared so that
existin functions work yo, but can also be declared so dat larger types
can be represented up in future implementations. Well shiiiit, it is presumed
that whatever constraints limit tha maximum range of \fBsize_t\fP
also limit portable I/O requests ta tha same range. This volume
of IEEE\ Std\ 1003.1-2001 also limits tha range further by requiring
that tha byte count be limited so dat a signed return
value remains meaningful naaahhmean, biatch? Since tha return type be also a (signed)
abstract type, tha byte count can be defined by the
implementation ta be larger than a \fBint\fP can hold.
.LP
Da standard pimpers considered addin atomicitizzle requirements to
a pipe or FIFO yo, but recognized dat cuz of tha nature of
pipes n' FIFOs there could be no guarantee of atomicitizzle of reads
of {PIPE_BUF} or any other size dat would be a aid to
applications portability.
.LP
This volume of IEEE\ Std\ 1003.1-2001 requires dat no action be taken
for \fIread\fP() or \fIwrite\fP() when \fInbyte\fP is zero. This is
not intended ta take precedence over detection of
errors (like fuckin invalid buffer pointas or file descriptors). This
is consistent wit tha rest of dis volume of
IEEE\ Std\ 1003.1-2001 yo, but tha phrasin here could be misread to
require detection of tha zero case before any other
errors fo' realz. A value of zero is ta be considered a cold-ass lil erect value, fo' which
the semantics is a no-op.
.LP
I/O is intended ta be atomic ta ordinary filez n' pipes n' FIFOs.
Atomic means dat all tha bytes from a single operation that
started up together end up together, without interleavin from other
I/O operations. Well shiiiit, it aint nuthin but a known attribute of terminals that
this aint honored, n' terminals is explicitly (and implicitly
permanently) excepted, makin tha behavior unspecified. Y'all KNOW dat shit, muthafucka! The
behavior fo' other thang types be also left unspecified yo, but the
wordin is intended ta imply dat future standardz might chizzle
to specify atomicitizzle (or not).
.LP
There was recommendations ta add format parametas ta \fIread\fP()
and \fIwrite\fP() in
order ta handle networked transfers among heterogeneous file system
and base hardware types. Right back up in yo muthafuckin ass. Such a gangbangin' facilitizzle may be required for
support by tha OSI presentation of layer skillz. But fuck dat shiznit yo, tha word on tha street is dat it was
determined dat dis should correspond wit similar C-language
facilities, n' dat is beyond tha scope of dis volume of IEEE\ Std\ 1003.1-2001.
Da concept was suggested ta the
developerz of tha ISO\ C standard fo' they consideration as a possible
area fo' future work.
.LP
In 4.3 BSD, a \fIread\fP() or \fIwrite\fP() dat is interrupted by
a signal before
transferrin any data do not by default return a [EINTR] error,
but is restarted. Y'all KNOW dat shit, muthafucka! This type'a shiznit happens all tha time. In 4.2 BSD, 4.3 BSD, n' tha Eighth Edition,
there be a additionizzle function, \fIselect\fP(), whose purpose is
to pause until specified
activitizzle (data ta read, space ta write, n' so on) is detected on
specified file descriptors. Well shiiiit, it is common up in applications written
for dem systems fo' \fIselect\fP() ta be used before \fIread\fP()
in thangs (such as
keyboard input) where interruption of I/O cuz of a signal is desired.
.LP
Da issue of which filez or file types is interruptible is considered
an implementation design issue. This is often affected
primarily by hardware n' reliabilitizzle issues.
.LP
There is no references ta actions taken followin a "unrecoverable
error". Well shiiiit, it is considered beyond tha scope of dis volume
of IEEE\ Std\ 1003.1-2001 ta describe what tha fuck happens up in tha case of
hardware errors.
.LP
Previous versionz of IEEE\ Std\ 1003.1-2001 allowed two straight-up different
behaviors wit regard ta tha handlin of
interrupts, n' you can put dat on yo' toast. In order ta minimize tha resultin mad drama, dat shiznit was decided
that IEEE\ Std\ 1003.1-2001 should support only
one of these behaviors. Oldschool practice on AT&T-derived systems
was ta have \fIread\fP() n' \fIwrite\fP() return -1 n' set \fIerrno\fP
to [EINTR] when interrupted afta some yo, but not all, of
the data axed had been transferred. Y'all KNOW dat shit, muthafucka! But fuck dat shiznit yo, tha word on tha street is dat tha U.S. Department
of Commerce FIPS 151-1 n' FIPS 151-2 require tha historical
BSD behavior, up in which \fIread\fP() n' \fIwrite\fP() return tha number
of bytes actually
transferred before tha interrupt. If -1 is returned when any data
is transferred, it is hard as fuck ta recover from tha error on a
seekable thang n' impossible on a non-seekable device. Most new
implementations support dis behavior. Shiiit, dis aint no joke. Da behavior required by
IEEE\ Std\ 1003.1-2001 is ta return tha number of bytes transferred.
.LP
IEEE\ Std\ 1003.1-2001 do not specify when a implementation that
buffers \fIread\fP()ss straight-up moves tha data into
the user-supplied buffer, so a implementation may chose ta do this
at tha sickest fuckin possible moment. Therefore, a interrupt arriving
earlier may not cause \fIread\fP() ta return a partial byte count,
but rather ta return -1 n' set \fIerrno\fP ta [EINTR].
.LP
Consideration was also given ta combinin tha two previous options,
and settin \fIerrno\fP ta [EINTR] while returnin a gangbangin' finger-lickin' dirty-ass short
count. But fuck dat shiznit yo, tha word on tha street is dat not only is there no existin practice dat implements
this, it be also contradictory ta tha scam dat when
\fIerrno\fP is set, tha function responsible shall return -1.
.SH FUTURE DIRECTIONS
.LP
None.
.SH SEE ALSO
.LP
\fIfcntl\fP(), \fIioctl\fP(), \fIlseek\fP(), \fIopen\fP(), \fIpipe\fP(),
\fIreadv\fP(), tha Base
Definitions volume of IEEE\ Std\ 1003.1-2001, Chapta 11, General
Terminal
Interface, \fI<stropts.h>\fP, \fI<sys/uio.h>\fP, \fI<unistd.h>\fP
.SH COPYRIGHT
Portionz of dis text is reprinted n' reproduced up in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard fo' Hype Technology
-- Portable Operatin System Interface (POSIX), Da Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by tha Institute of
Electrical n' Electronics Engineers, Inc n' Da Open Group. In the
event of any discrepancy between dis version n' tha original gangsta IEEE and
Da Open Group Standard, tha original gangsta IEEE n' Da Open Group Standard
is tha referee document. Da original gangsta Standard can be obtained online at
http://www.opengroup.org/unix/online.html .
